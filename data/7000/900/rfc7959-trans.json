{
  "title": {
    "text": "RFC 7959 - Block-Wise Transfers in the Constrained Application Protocol (CoAP)",
    "ja": "RFC 7959 - 制約アプリケーションプロトコルで転送ブロック単位（CoAP）"
  },
  "number": 7959,
  "created_at": "2019-11-02 17:00:48.399309+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                        C. Bormann\nRequest for Comments: 7959                       Universitaet Bremen TZI\nUpdates: 7252                                             Z. Shelby, Ed.\nCategory: Standards Track                                            ARM\nISSN: 2070-1721                                              August 2016",
      "raw": true
    },
    {
      "indent": 2,
      "text": "Block-Wise Transfers in the Constrained Application Protocol (CoAP)",
      "ja": "制約アプリケーションプロトコルで転送ブロック単位（CoAP）"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "The Constrained Application Protocol (CoAP) is a RESTful transfer protocol for constrained nodes and networks. Basic CoAP messages work well for small payloads from sensors and actuators; however, applications will need to transfer larger payloads occasionally -- for instance, for firmware updates. In contrast to HTTP, where TCP does the grunt work of segmenting and resequencing, CoAP is based on datagram transports such as UDP or Datagram Transport Layer Security (DTLS). These transports only offer fragmentation, which is even more problematic in constrained nodes and networks, limiting the maximum size of resource representations that can practically be transferred.",
      "ja": "制約アプリケーションプロトコル（CoAP）が制約ノードとネットワークのためのRESTful転送プロトコルです。基本CoAPメッセージは、センサやアクチュエータから小さなペイロードのために働きます。例えば、ファームウェアのアップデートのために - しかし、アプリケーションは、時折大きなペイロードを転送する必要があります。 TCPは、セグメント化および再配列決定の単調な作業を行うHTTP、とは対照的に、CoAPがデータグラムに基づいていますが、このようなUDPまたはデータグラムトランスポート層セキュリティ（DTLS）として転送します。これらのトランスポートは、実際に転送することができるリソースの表現の最大サイズを制限し、制約ノード及びネットワークにさらに多くの問題がある断片を提供します。"
    },
    {
      "indent": 3,
      "text": "Instead of relying on IP fragmentation, this specification extends basic CoAP with a pair of \"Block\" options for transferring multiple blocks of information from a resource representation in multiple request-response pairs. In many important cases, the Block options enable a server to be truly stateless: the server can handle each block transfer separately, with no need for a connection setup or other server-side memory of previous block transfers. Essentially, the Block options provide a minimal way to transfer larger representations in a block-wise fashion.",
      "ja": "代わりに、IP断片化に依存するのは、この明細書は、複数の要求 - 応答ペアにおけるリソース表現から情報の複数のブロックを転送するための「ブロック」のオプションのペアと基本CoAPを拡張します。多くの重要なケースでは、ブロックのオプションは、本当にステートレスであるために、サーバーを有効にします。サーバーは、前のブロック転送の接続設定やその他のサーバー側のメモリを必要とせず、個別に各ブロック転送を処理することができます。本質的に、ブロックオプションは、ブロックワイズの様式で、より大きな表現を転送するための最小の方法を提供します。"
    },
    {
      "indent": 3,
      "text": "A CoAP implementation that does not support these options generally is limited in the size of the representations that can be exchanged, so there is an expectation that the Block options will be widely used in CoAP implementations. Therefore, this specification updates RFC 7252.",
      "ja": "一般的にこれらのオプションをサポートしていないCoAP実装は、交換することができる表現のサイズが制限されるので、ブロック・オプションが広くCoAP実装に使用されるであろうという期待があります。したがって、この仕様の更新RFC 7252。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 7841のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7959.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7959で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2016 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2016 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   4\n2.  Block-Wise Transfers  . . . . . . . . . . . . . . . . . . . .   6\n  2.1.  The Block2 and Block1 Options . . . . . . . . . . . . . .   7\n  2.2.  Structure of a Block Option . . . . . . . . . . . . . . .   8\n  2.3.  Block Options in Requests and Responses . . . . . . . . .  10\n  2.4.  Using the Block2 Option . . . . . . . . . . . . . . . . .  12\n  2.5.  Using the Block1 Option . . . . . . . . . . . . . . . . .  14\n  2.6.  Combining Block-Wise Transfers with the Observe Option  .  15\n  2.7.  Combining Block1 and Block2 . . . . . . . . . . . . . . .  16\n  2.8.  Combining Block2 with Multicast . . . . . . . . . . . . .  16\n  2.9.  Response Codes  . . . . . . . . . . . . . . . . . . . . .  17\n    2.9.1.  2.31 Continue . . . . . . . . . . . . . . . . . . . .  17\n    2.9.2.  4.08 Request Entity Incomplete  . . . . . . . . . . .  17\n    2.9.3.  4.13 Request Entity Too Large . . . . . . . . . . . .  17\n  2.10. Caching Considerations  . . . . . . . . . . . . . . . . .  18\n3.  Examples  . . . . . . . . . . . . . . . . . . . . . . . . . .  18\n  3.1.  Block2 Examples . . . . . . . . . . . . . . . . . . . . .  19\n  3.2.  Block1 Examples . . . . . . . . . . . . . . . . . . . . .  23\n  3.3.  Combining Block1 and Block2 . . . . . . . . . . . . . . .  25\n  3.4.  Combining Observe and Block2  . . . . . . . . . . . . . .  26\n4.  The Size2 and Size1 Options . . . . . . . . . . . . . . . . .  29\n5.  HTTP-Mapping Considerations . . . . . . . . . . . . . . . . .  31\n6.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  32\n7.  Security Considerations . . . . . . . . . . . . . . . . . . .  33\n  7.1.  Mitigating Resource Exhaustion Attacks  . . . . . . . . .  33\n  7.2.  Mitigating Amplification Attacks  . . . . . . . . . . . .  34\n8.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  34\n  8.1.  Normative References  . . . . . . . . . . . . . . . . . .  34\n  8.2.  Informative References  . . . . . . . . . . . . . . . . .  35\nAcknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  36\nAuthors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  37",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "The work on Constrained RESTful Environments (CoRE) aims at realizing the Representational State Transfer (REST) architecture in a suitable form for the most constrained nodes (such as microcontrollers with limited RAM and ROM [RFC7228]) and networks (such as IPv6 over Low-Power Wireless Personal Area Networks (6LoWPANs) [RFC4944]) [RFC7252]. The CoAP protocol is intended to provide RESTful [REST] services not unlike HTTP [RFC7230], while reducing the complexity of implementation as well as the size of packets exchanged in order to make these services useful in a highly constrained network of highly constrained nodes.",
      "ja": "制約RESTfulな環境（コア）の作業は、低上のIPv6等のネットワーク（（例えば、限定されたRAMとを有するマイクロコントローラROM [RFC7228]などの）最も制約ノードに適した形態でのRepresentational State Transfer（REST）アーキテクチャを実現することを目的と - パワー無線パーソナルエリアネットワーク（6LoWPANs）[RFC4944]）[RFC7252]。実装の複雑さ、ならびに、パケットのサイズを低減することが非常に制約ノードの高度に制約ネットワークでこれらのサービスを便利にするために交換しながらCoAPプロトコルはなく、HTTP [RFC7230]とは異なり、RESTfulな[REST]サービスを提供することを目的とします。"
    },
    {
      "indent": 3,
      "text": "This objective requires restraint in a number of sometimes conflicting ways:",
      "ja": "この目的は、時には矛盾するいくつかの方法で拘束が必要です。"
    },
    {
      "indent": 3,
      "text": "o reducing implementation complexity in order to minimize code size,",
      "ja": "コードサイズを最小にするために、実装の複雑さを低減することO、"
    },
    {
      "indent": 3,
      "text": "o reducing message sizes in order to minimize the number of fragments needed for each message (to maximize the probability of delivery of the message), the amount of transmission power needed, and the loading of the limited-bandwidth channel,",
      "ja": "（メッセージの配信の確率を最大にするために）各メッセージのために必要なフラグメントの数を最小限にするために、メッセージのサイズを減少O、必要な送信電力の量、および限られた帯域幅チャネルのローディング、"
    },
    {
      "indent": 3,
      "text": "o reducing requirements on the environment such as stable storage, good sources of randomness, or user-interaction capabilities.",
      "ja": "そのような安定なストレージ、ランダム性の良い情報源、またはユーザー対話機能などの環境上の要件を軽減O。"
    },
    {
      "indent": 3,
      "text": "Because CoAP is based on datagram transports such as UDP or Datagram Transport Layer Security (DTLS), the maximum size of resource representations that can be transferred without too much fragmentation is limited. In addition, not all resource representations will fit into a single link-layer packet of a constrained network, which may cause adaptation layer fragmentation even if IP-layer fragmentation is not required. Using fragmentation (either at the adaptation layer or at the IP layer) for the transport of larger representations would be possible up to the maximum size of the underlying datagram protocol (such as UDP), but the fragmentation/reassembly process burdens the lower layers with conversation state that is better managed in the application layer.",
      "ja": "CoAPがデータグラムに基づいているため、このようなUDPまたはデータグラムトランスポート層セキュリティ（DTLS）として輸送し、あまりにも多くの断片化せずに転送することができるリソース表現の最大サイズは限られています。また、すべてのリソース表現は、IP層のフラグメント化が必要とされていない場合でも、アダプテーション層の断片化を引き起こす可能性が制約されたネットワークの単一のリンク層パケットの中にフィットします。 （UDPなど）、基礎となるデータグラムプロトコルの最大サイズまで可能であろうより大きな表現の輸送のために断片化（アダプテーション層において、またはIPレイヤでのいずれか）を使用するが、断片化/再アセンブリプロセスを用いて下層を負担より良いアプリケーション層で管理されている会話の状態。"
    },
    {
      "indent": 3,
      "text": "The present specification defines a pair of CoAP options to enable block-wise access to resource representations. The Block options provide a minimal way to transfer larger resource representations in a block-wise fashion. The overriding objective is to avoid the need for creating conversation state at the server for block-wise GET requests. (It is impossible to fully avoid creating conversation state for POST/PUT, if the creation/replacement of resources is to be atomic; where that property is not needed, there is no need to create server conversation state in this case, either.)",
      "ja": "本明細書は、リソース表現をブロック単位のアクセスを可能にするCoAPオプションのペアを定義します。ブロックオプションは、ブロックワイズの様式で、より大きなリソースの表現を転送するための最小の方法を提供します。最優先の目的は、ブロック単位のGET要求のためのサーバでの会話の状態を作成するための必要性を回避するためです。 （リソースの作成/交換がアトミックにする場合には、完全にPOST / PUTのための会話の状態を作成しないようにすることは不可能であり、そのプロパティが必要とされていない場合は、この場合には、サーバーの会話の状態を作成する必要はどちらか、存在しません。）"
    },
    {
      "indent": 3,
      "text": "Block-wise transfers are realized as combinations of exchanges, each of which is performed according to the CoAP base protocol [RFC7252]. Each exchange in such a combination is governed by the specifications in [RFC7252], including the congestion control specifications (Section 4.7 of [RFC7252]) and the security considerations (Section 11 of [RFC7252]; additional security considerations then apply to the transfers as a whole, see Section 7). The present specification minimizes the constraints it adds to those base exchanges; however, not all variants of using CoAP are very useful inside a block-wise transfer (e.g., using Non-confirmable requests within block-wise transfers outside the use case of Section 2.8 would escalate the overall non-delivery probability). To be perfectly clear, the present specification also does not remove any of the constraints posed by the base specification it is strictly layered on top of. For example, back-to-back packets are limited by the congestion control described in Section 4.7 of [RFC7252] (NSTART as a limit for initiating exchanges, PROBING_RATE as a limit for sending with no response); block-wise transfers cannot send/solicit more traffic than a client could be sending to / soliciting from the same server without the block-wise mode.",
      "ja": "ブロック単位の転送がCoAPベースプロトコル[RFC7252]に従って実行されるそれぞれが交流の組み合わせとして実現されます。次いでとして転送に適用される付加的なセキュリティ問題、このような組み合わせは、輻輳制御仕様（[RFC7252]のセクション4.7）とセキュリティ問題（[RFC7252]のセクション11を含む[RFC7252]で仕様によって支配される各交換全体、セクション7を参照してください）。本明細書は、それがこれらの塩基交換に追加の制約を最小限に抑えます。しかし、ないCoAPを使用してすべての変異体は、ブロック単位の転送（例えば、2.8項のユースケース外部ブロックワイズ転送内の非確認可能リクエストを使用して全体的な配信不能確率をエスカレートであろう）の内部に非常に有用です。完全に透明にするために、本明細書はまた、それは厳密の上に階層化された基本仕様によってもたらされる制約のいずれかを削除しません。例えば、バックツーバックパケットは（応答なしで送信するための限界としてPROBING_RATE、n始動交換を開始するための限界として）[RFC7252]のセクション4.7に記載の輻輳制御により制限されています。ブロック単位の転送は勧誘/クライアントは、ブロック単位のモードずに同じサーバーから募集/に送信することができるより多くのトラフィックを送信することはできません。"
    },
    {
      "indent": 3,
      "text": "In some cases, the present specification will RECOMMEND that a client perform a sequence of block-wise transfers \"without undue delay\". This cannot be phrased as an interoperability requirement, but is an expectation on implementation quality. Conversely, the expectation is that servers will not have to go out of their way to accommodate clients that take considerable time to finish a block-wise transfer. For example, for a block-wise GET, if the resource changes while this proceeds, the entity-tag (ETag) for a further block obtained may be different. To avoid this happening all the time for a fast-changing resource, a server MAY try to keep a cache around for a specific client for a short amount of time. The expectation here is that the lifetime for such a cache can be kept short, on the order of a few expected round-trip times, counting from the previous block transferred.",
      "ja": "いくつかのケースでは、本明細書は、クライアントが「不当に遅延することなく、」ブロック単位の転送のシーケンスを実行することをお勧めします。これは、相互運用性の要件と言うこともできませんが、実装品質の期待があります。逆に、期待はサーバがブロック単位の転送を完了するためにかなりの時間がかかるクライアントに対応するために彼らの方法の外に行かなければならないということです。ブロックワイズGETのために、例えば、この移行中にリソースが変更された場合、得られたさらなるブロックのエンティティタグ（ETagの）が異なっていてもよいです。これは、急速に変化するリソースのすべての時間が起きないようにするには、サーバーは短時間のために特定のクライアントのために周りのキャッシュを維持しようとするかもしれません。ここでの期待は、キャッシュの有効期間は、転送前のブロックから数えて、いくつかの予想されるラウンドトリップ時間程度の短い保つことができるということです。"
    },
    {
      "indent": 3,
      "text": "In summary, this specification adds a pair of Block options to CoAP that can be used for block-wise transfers. Benefits of using these options include:",
      "ja": "要約すると、本明細書は、ブロック単位の転送のために使用することができるCoAPにブロックオプションのペアを追加します。これらのオプションを使用する利点は、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o Transfers larger than what can be accommodated in constrained-network link-layer packets can be performed in smaller blocks.",
      "ja": "制約されたネットワークリンク層パケット内に収容することができるものよりも大きいO転送は、より小さなブロックで行うことができます。"
    },
    {
      "indent": 3,
      "text": "o No hard-to-manage conversation state is created at the adaptation layer or IP layer for fragmentation.",
      "ja": "Oノーハード・ツー・管理し、会話状態は断片化のためのアダプテーション層またはIP層で作成されます。"
    },
    {
      "indent": 3,
      "text": "o The transfer of each block is acknowledged, enabling individual retransmission if required.",
      "ja": "oを各ブロックの転送が必要な場合、個々の再送信を可能にする、認められています。"
    },
    {
      "indent": 3,
      "text": "o Both sides have a say in the block size that actually will be used.",
      "ja": "O双方は、実際に使用されるブロックサイズでの発言権を持っています。"
    },
    {
      "indent": 3,
      "text": "o The resulting exchanges are easy to understand using packet analyzer tools, and thus quite accessible to debugging.",
      "ja": "結果として交流oをパケットアナライザツールを使用して理解しやすく、およびデバッグすることは非常にアクセス可能です。"
    },
    {
      "indent": 3,
      "text": "o If needed, the Block options can also be used (without changes) to provide random access to power-of-two sized blocks within a resource representation.",
      "ja": "必要に応じてO、ブロック・オプションは、リソース表現内の2のべき乗のサイズのブロックへのランダムアクセスを提供する（変更なし）を使用することができます。"
    },
    {
      "indent": 3,
      "text": "A CoAP implementation that does not support these options generally is limited in the size of the representations that can be exchanged, see Section 4.6 of [RFC7252]. Even though the options are Critical, a server may decide to start using them in an unsolicited way in a response. No effort was expended to provide a capability indication mechanism supporting that decision: since the block-wise transfer mechanisms are so fundamental to the use of CoAP for representations larger than about a kilobyte, there is an expectation that they are very widely implemented.",
      "ja": "[RFC7252]のセクション4.6を参照して、一般的に交換することができる表現のサイズに制限され、これらのオプションをサポートしていないCoAP実装。オプションがクリティカルであっても、サーバが応答して、迷惑な方法でそれらを使用して起動することもできます。努力は、その意思決定を支援する能力表示機構を提供するために費やさなかった：ブロック単位の転送メカニズムがキロバイト約より大きい表現のためCoAPの使用に非常に基本的であるので、それらは非常に広く実装されていることを期待されています。"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119, BCP 14 [RFC2119] and indicate requirement levels for compliant CoAP implementations.",
      "ja": "キーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、 \"SHALL\"、 \"SHOULD\"、 \"ないもの\"、 \"推奨\" \"ない（SHOULD NOT）\"、 \"MAY\"、 \"推奨NOT\"、および「OPTIONAL 「本書ではRFC 2119に記載され、BCP 14 [RFC2119]として解釈されるべきであり、対応CoAP実装するための要件レベルを示します。"
    },
    {
      "indent": 3,
      "text": "In this document, the term \"byte\" is used in its now customary sense as a synonym for \"octet\".",
      "ja": "この文書では、用語「バイト」は「オクテット」の同義語としてその今慣習的な意味で使用されています。"
    },
    {
      "indent": 3,
      "text": "Where bit arithmetic is explained, this document uses the notation familiar from the programming language C, except that the operator \"**\" stands for exponentiation.",
      "ja": "ビット演算が説明される演算子「**」はべき乗を表していることを除いて、このドキュメントは、プログラミング言語Cから馴染みの表記法を使用します。"
    },
    {
      "indent": 0,
      "text": "2. Block-Wise Transfers",
      "section_title": true,
      "ja": "2.ブロック単位の転送"
    },
    {
      "indent": 3,
      "text": "As discussed in the introduction, there are good reasons to limit the size of datagrams in constrained networks:",
      "ja": "導入部で論じたように、制約されたネットワークにデータグラムのサイズを制限する理由があります。"
    },
    {
      "indent": 3,
      "text": "o by the maximum datagram size (~ 64 KiB for UDP)",
      "ja": "最大データグラムサイズ（UDPのための〜64 KiBの）によってO"
    },
    {
      "indent": 3,
      "text": "o by the desire to avoid IP fragmentation (MTU of 1280 for IPv6)",
      "ja": "IPフラグメンテーション（IPv6のための1280のMTUを）避けたいという願望によってO"
    },
    {
      "indent": 3,
      "text": "o by the desire to avoid adaptation-layer fragmentation (60-80 bytes for 6LoWPAN [RFC4919])",
      "ja": "アダプテーション層フラグメンテーションを回避する要望によりO（6LoWPANため60~80バイト[RFC4919]）"
    },
    {
      "indent": 3,
      "text": "When a resource representation is larger than can be comfortably transferred in the payload of a single CoAP datagram, a Block option can be used to indicate a block-wise transfer. As payloads can be sent both with requests and with responses, this specification provides two separate options for each direction of payload transfer. In naming these options (for block-wise transfers as well as in Section 4), we use the number 1 (\"Block1\", \"Size1\") to refer to the transfer of the resource representation that pertains to the request, and the number 2 (\"Block2\", \"Size2\") to refer to the transfer of the resource representation for the response.",
      "ja": "リソース表現が快適単一CoAPデータグラムのペイロードに転送することができるよりも大きい場合、ブロック・オプションは、ブロック単位の転送を示すために使用することができます。ペイロードは、要求と応答との両方で送信することができるように、この仕様は、ペイロード転送の各方向のための2つの別々のオプションを提供します。これらのオプション（ブロック単位の転送のため、ならびに第4）の命名では、要求に関連するリソース表現の転送、および番号を参照するために番号1（「ブロック1」、「サイズ1」）を使用します応答のためのリソース表現の転送を参照する2（「ブロック2」、「SIZE2」）。"
    },
    {
      "indent": 3,
      "text": "In the following, the term \"payload\" will be used for the actual content of a single CoAP message, i.e., a single block being transferred, while the term \"body\" will be used for the entire resource representation that is being transferred in a block-wise fashion. The Content-Format Option applies to the body, not to the payload; in particular, the boundaries between the blocks may be in places that are not separating whole units in terms of the structure, encoding, or content-coding used by the Content-Format. (Similarly, the ETag Option defined in Section 5.10.6 of [RFC7252] applies to the whole representation of the resource, and thus to the body of the response.)",
      "ja": "用語「本体」はに転送されている全体のリソース表現のために使用される一方、以下では、用語「ペイロード」は、単一のブロックが転送される単一CoAPメッセージ、すなわち、実際のコンテンツに使用されますブロック単位のファッション。コンテンツフォーマットオプションはありませんペイロードに、身体に適用されます。具体的には、ブロック間の境界は、構造、エンコード、またはコンテンツ符号化コンテンツフォーマットで使用されるという点で全体のユニットを分離されていない場所であってもよいです。 （同様に、[RFC7252]のセクション5.10.6に規定されたETagオプションは、リソースの全体の表現であり、従って応答のボディに適用されます。）"
    },
    {
      "indent": 3,
      "text": "In most cases, all blocks being transferred for a body (except for the last one) will be of the same size. (If the first request uses a bigger block size than the receiver prefers, subsequent requests will use the preferred block size.) The block size is not fixed by the protocol. To keep the implementation as simple as possible, the Block options support only a small range of power-of-two block sizes, from 2**4 (16) to 2**10 (1024) bytes. As bodies often will not evenly divide into the power-of-two block size chosen, the size need not be reached in the final block (but even for the final block, the chosen power-of-two size will still be indicated in the block size field of the Block option).",
      "ja": "ほとんどの場合、すべてのブロックが同じサイズになります（最後のものを除く）ボディのために転送されています。 （最初の要求は、受信機が好むより大きなブロックサイズを使用する場合、後続の要求は、好ましいブロックサイズを使用する。）ブロックサイズは、プロトコルによって固定されていません。できるだけ単純な実装を維持するために、ブロックのオプションは2 ** 4（16）から2 ** 10（1024）バイト、2のべき乗のブロックサイズのわずかな範囲をサポートします。体は、しばしば均一選択、2のべき乗のブロックサイズに分割しないであろうように、大きさが最終ブロックに到達する必要はない（それでも最終ブロックについて、選択された2のべき乗の大きさは依然としてに示されますブロックオプションのブロックサイズフィールド）。"
    },
    {
      "indent": 0,
      "text": "2.1. The Block2 and Block1 Options",
      "section_title": true,
      "ja": "2.1。ブロック2とブロック1のオプション"
    },
    {
      "indent": 7,
      "text": "+-----+---+---+---+---+--------+--------+--------+---------+\n| No. | C | U | N | R | Name   | Format | Length | Default |\n+-----+---+---+---+---+--------+--------+--------+---------+\n|  23 | C | U | - | - | Block2 | uint   |    0-3 | (none)  |\n|     |   |   |   |   |        |        |        |         |\n|  27 | C | U | - | - | Block1 | uint   |    0-3 | (none)  |\n+-----+---+---+---+---+--------+--------+--------+---------+",
      "raw": true
    },
    {
      "indent": 23,
      "text": "Table 1: Block Option Numbers",
      "ja": "表1：ブロックオプション番号"
    },
    {
      "indent": 3,
      "text": "Both Block1 and Block2 Options can be present in both the request and response messages. In either case, the Block1 Option pertains to the request payload, and the Block2 Option pertains to the response payload.",
      "ja": "ブロック1とブロック2のオプションの両方が要求および応答メッセージの両方に存在することができます。いずれの場合においても、ブロック1のオプションは、要求ペイロードに関連し、ブロック2のオプションは、応答ペイロードに関する。"
    },
    {
      "indent": 3,
      "text": "Hence, for the methods defined in [RFC7252], Block1 is useful with the payload-bearing POST and PUT requests and their responses. Block2 is useful with GET, POST, and PUT requests and their payload-bearing responses (2.01, 2.02, 2.04, and 2.05 -- see Section 5.5 of [RFC7252]).",
      "ja": "したがって、[RFC7252]で定義されたメソッドのために、ブロック1は、ペイロード担持POSTおよびPUT要求とその応答で有用です。ブロック2は、GET、POSTで有用であり、要求とそのペイロード・ベアリング応答をPUT（2.01、2.02、2.04、および2.05  - の5.5節を参照してください[RFC7252]）。"
    },
    {
      "indent": 3,
      "text": "Where Block1 is present in a request or Block2 in a response (i.e., in that message to the payload of which it pertains) it indicates a block-wise transfer and describes how this specific block-wise payload forms part of the entire body being transferred (\"descriptive usage\"). Where it is present in the opposite direction, it provides additional control on how that payload will be formed or was processed (\"control usage\").",
      "ja": "ブロック1は、（それが属するのペイロードへのメッセージ、すなわち、）応答要求またはブロック2中に存在する場合には、ブロック単位の転送を示し、全身のこの特定のブロック単位のペイロードの一部を形成するが転送される方法を説明します（ \"記述的用法\"）。それは反対方向に存在する場合、そのペイロードが形成されるか（「コントロールの使用」）を処理した方法の追加の制御を提供します。"
    },
    {
      "indent": 3,
      "text": "Implementation of either Block option is intended to be optional. However, when it is present in a CoAP message, it MUST be processed (or the message rejected); therefore, it is identified as a Critical option. Either Block option MUST NOT occur more than once in a single message.",
      "ja": "いずれかのブロックオプションの実装はオプションであることを意図しています。それはCoAPメッセージ内に存在している場合しかし、それは処理されなければならない（又はメッセージは拒否します）。したがって、それは重要なオプションとして識別されます。どちらのブロックオプションは、単一のメッセージに複数回発生してはなりません。"
    },
    {
      "indent": 0,
      "text": "2.2. Structure of a Block Option",
      "section_title": true,
      "ja": "2.2。ブロック・オプションの構造"
    },
    {
      "indent": 3,
      "text": "Three items of information may need to be transferred in a Block (Block1 or Block2) option:",
      "ja": "情報の三つの項目は、ブロック（ブロック1又はブロック2）オプションで転送する必要があるかもしれません。"
    },
    {
      "indent": 3,
      "text": "o the size of the block (SZX);",
      "ja": "Oブロック（SZX）の大きさ。"
    },
    {
      "indent": 3,
      "text": "o whether more blocks are following (M);",
      "ja": "より多くのブロックは、（M）以下であるかどうか、O、"
    },
    {
      "indent": 3,
      "text": "o the relative number of the block (NUM) within a sequence of blocks with the given size.",
      "ja": "与えられたサイズのブロックのシーケンス内のブロック（NUM）の相対数O。"
    },
    {
      "indent": 3,
      "text": "The value of the Block option is a variable-size (0 to 3 byte) unsigned integer (uint, see Section 3.2 of [RFC7252]). This integer value encodes these three fields, see Figure 1. (Due to the CoAP uint-encoding rules, when all of NUM, M, and SZX happen to be zero, a zero-byte integer will be sent.)",
      "ja": "ブロック・オプションの値は、可変サイズ（0~3バイト）の符号なし整数（UINT、[RFC7252]のセクション3.2を参照）です。この整数値は、これら3つのフィールドコード、（NUM、Mの全て、及びSZXがゼロバイトの整数が送信され、ゼロであることが起こる場合、これによりCoAP UINT符号化規則に。）図1を参照してください"
    },
    {
      "indent": 10,
      "text": " 0\n 0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+\n|  NUM  |M| SZX |\n+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 10,
      "text": " 0                   1\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          NUM          |M| SZX |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 10,
      "text": " 0                   1                   2\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                   NUM                 |M| SZX |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 23,
      "text": "Figure 1: Block Option Value",
      "ja": "図1：ブロックオプション値"
    },
    {
      "indent": 3,
      "text": "The block size is encoded using a three-bit unsigned integer (0 for 2**4 bytes to 6 for 2**10 bytes), which we call the \"SZX\" (\"size exponent\"); the actual block size is then \"2**(SZX + 4)\". SZX is transferred in the three least significant bits of the option value (i.e., \"val & 7\" where \"val\" is the value of the option).",
      "ja": "ブロックサイズは、我々が「SZX」（「サイズ指数」）を呼び出し、（2 ** 10バイトのために6に2つの** 4バイト0）は、3ビット符号なし整数を使用して符号化されます。実際のブロックサイズは、次いで、 \"2 **（SZX + 4）\" です。 SZXは、オプション値（「valが」オプションの値、すなわち、「ヴァル＆7」）の下位3ビットに転送されます。"
    },
    {
      "indent": 3,
      "text": "The fourth least significant bit, the M or \"more\" bit (\"val & 8\"), indicates whether more blocks are following or if the current block-wise transfer is the last block being transferred.",
      "ja": "第四の最下位ビット、Mまたは「複数」ビット（「ヴァル＆8」）は、より多くのブロックは、次または現在のブロック単位の転送が転送される最後のブロックである場合にされているかどうかを示します。"
    },
    {
      "indent": 3,
      "text": "The option value divided by sixteen (the NUM field) is the sequence number of the block currently being transferred, starting from zero. The current transfer is, therefore, about the \"size\" bytes starting at byte \"NUM << (SZX + 4)\".",
      "ja": "16（NUMフィールド）で割ったオプションの値は、現在、ゼロから出発して、転送されるブロックのシーケンス番号です。現在の転送はバイトから始まる「サイズ」バイト「NUM <<（SZX + 4）」について、したがって、です。"
    },
    {
      "indent": 3,
      "text": "Implementation note: As an implementation convenience, \"(val & ~0xF) << (val & 7)\", i.e., the option value with the last 4 bits masked out, shifted to the left by the value of SZX, gives the byte position of the first byte of the block being transferred.",
      "ja": "実装上の注意：実装の利便性、「（ヴァル＆〜0xFの）<<（ヴァル＆7）」、すなわち、マスクされた最後の4ビットのオプションの値として、SZXの値によって左にシフトし、バイトを与えますブロックの最初のバイトの位置が転送されます。"
    },
    {
      "indent": 3,
      "text": "More specifically, within the option value of a Block1 or Block2 Option, the meaning of the option fields is defined as follows:",
      "ja": "具体的には、次のようブロック1またはブロック2オプションのオプション値の範囲内で、オプションフィールドの意味は定義されています。"
    },
    {
      "indent": 3,
      "text": "NUM: Block Number, indicating the block number being requested or provided. Block number 0 indicates the first block of a body (i.e., starting with the first byte of the body).",
      "ja": "NUM：ブロック番号、要求または提供されているブロック番号を示します。ブロック番号0は、体の最初のブロック（すなわち、体の最初のバイトから始まる）を示します。"
    },
    {
      "indent": 3,
      "text": "M: More Flag (\"not last block\"). For descriptive usage, this flag, if unset, indicates that the payload in this message is the last block in the body; when set, it indicates that there are one or more additional blocks available. When a Block2 Option is used in a request to retrieve a specific block number (\"control usage\"), the M bit MUST be sent as zero and ignored on reception. (In a Block1 Option in a response, the M flag is used to indicate atomicity, see below.)",
      "ja": "M：その他のフラグ（「ない最後のブロック」）。記述的使用のために、このフラグは、設定しない場合、このメッセージ内のペイロードは、体内の最後のブロックであることを示しています。セットされると、それは1つの以上の追加のブロックが利用可能であることを示しています。ブロック2のオプションは、特定のブロック番号（「コントロールの使用」）を取得するための要求で使用される場合、Mビットはゼロとして送信され、受信時には無視されなければなりません。 （応答ブロック1オプションで、Mフラグは以下を参照、アトミック性を示すために使用されます。）"
    },
    {
      "indent": 3,
      "text": "SZX: Block Size. The block size is represented as a three-bit unsigned integer indicating the size of a block to the power of two. Thus, block size = 2**(SZX + 4). The allowed values of SZX are 0 to 6, i.e., the minimum block size is 2**(0+4) = 16 and the maximum is 2**(6+4) = 1024. The value 7 for SZX (which would indicate a block size of 2048) is reserved, i.e., MUST NOT be sent and MUST lead to a 4.00 Bad Request response code upon reception in a request.",
      "ja": "SZX：ブロックサイズ。ブロックサイズは2の累乗にブロックのサイズを示す3ビットの符号なし整数として表現されます。従って、ブロックサイズ= 2 **（SZX + 4）。 SZXの許容値は、0〜6、すなわち、最小ブロックサイズがある2 **（0 + 4）= 16、最大値はだろう（SZX値7 2 **（+ 4 6）= 1024であります2048のブロックサイズ）が予約されていることを示し、すなわち、送ってはいけませんし、要求の受信時に4.00不正なリクエストの応答コードにつながる必要があります。"
    },
    {
      "indent": 3,
      "text": "There is no default value for the Block1 and Block2 Options. Absence of one of these options is equivalent to an option value of 0 with respect to the value of NUM and M that could be given in the option, i.e., it indicates that the current block is the first and only block of the transfer (block number 0, M bit not set). However, in contrast to the explicit value 0, which would indicate an SZX of 0 and thus a size value of 16 bytes, there is no specific explicit size implied by the absence of the option -- the size is left unspecified. (As for any uint, the explicit value 0 is efficiently indicated by a zero-length option; this, therefore, is different in semantics from the absence of the option.)",
      "ja": "ブロック1とブロック2のオプションにはデフォルト値はありません。これらのオプションのいずれかが存在しない場合は、オプションで与えることができるNUMとMの値、すなわちに対して0のオプション値に相当し、それは現在のブロック転送の最初で唯一のブロックであることを示す（ブロック番号0、Mビット）が設定されていません。サイズが指定されていないままである - しかし、0のSZXを示し、したがって、16バイトの大きさの値になる明示的な値0、とは対照的に、オプションが存在しないことによって暗黙特段の明示的な大きさがありません。 （任意UINTとして、明示的な値0を効率的に長さゼロのオプションによって示され、これは、従って、オプションの不在からのセマンティクスが異なります。）"
    },
    {
      "indent": 0,
      "text": "2.3. Block Options in Requests and Responses",
      "section_title": true,
      "ja": "2.3。リクエストとレスポンスでブロックオプション"
    },
    {
      "indent": 3,
      "text": "The Block options are used in one of three roles:",
      "ja": "ブロックオプションは3つの役割のいずれかで使用されます。"
    },
    {
      "indent": 3,
      "text": "o In descriptive usage, i.e., a Block2 Option in a response (such as a 2.05 response for GET), or a Block1 Option in a request (a PUT or POST):",
      "ja": "記述使用中のO、すなわち、応答ブロック2オプション（GET用など2.05応答）、またはリクエスト（PUTまたはPOST）でブロック1オプション："
    },
    {
      "indent": 6,
      "text": "* The NUM field in the option value describes what block number is contained in the payload of this message.",
      "ja": "*オプション値のNUMフィールドは、ブロック番号は、このメッセージのペイロードに含まれているものについて説明します。"
    },
    {
      "indent": 6,
      "text": "* The M bit indicates whether further blocks need to be transferred to complete the transfer of that body.",
      "ja": "* Mビットは、さらに、ブロックがその本体の転送を完了するために転送する必要があるかどうかを示します。"
    },
    {
      "indent": 6,
      "text": "* The block size implied by SZX MUST match the size of the payload in bytes, if the M bit is set. (SZX does not govern the payload size if M is unset). For Block2, if the request suggested a larger value of SZX, the next request MUST move SZX down to the size given in the response. (The effect is that, if the server uses the smaller of (1) its preferred block size and (2) the block size requested, all blocks for a body use the same block size.)",
      "ja": "Mビットが設定されている場合* SZXによって暗示ブロックサイズは、バイト単位でペイロードのサイズと一致しなければなりません。 （Mが設定されていない場合SZXは、ペイロードサイズを支配しません）。要求がSZXの大きな値を示唆している場合ブロック2については、次の要求を受けて所定の大きさまでSZXを移動しなければなりません。 （効果は、サーバ（1）はその好ましいブロックサイズの小さい方を使用し、（2）ブロックサイズが要求された場合、本体のために全てのブロックが同じブロックサイズを使用することです。）"
    },
    {
      "indent": 3,
      "text": "o A Block2 Option in control usage in a request (e.g., GET):",
      "ja": "O要求（例えば、GET）における制御の使用におけるブロック2オプション："
    },
    {
      "indent": 6,
      "text": "* The NUM field in the Block2 Option gives the block number of the payload that is being requested to be returned in the response.",
      "ja": "*ブロック2オプションでNUMフィールドは、応答で返されるように要求されているペイロードのブロック番号を与えます。"
    },
    {
      "indent": 6,
      "text": "* In this case, the M bit has no function and MUST be set to zero.",
      "ja": "*この場合、Mビットは機能を持たず、ゼロに設定しなければなりません。"
    },
    {
      "indent": 6,
      "text": "* The block size given (SZX) suggests a block size (in the case of block number 0) or repeats the block size of previous blocks received (in the case of a non-zero block number).",
      "ja": "*所定のブロックサイズ（SZX）は（ブロック番号0の場合）ブロックサイズを示唆しているか、（非ゼロのブロック番号の場合）前のブロックのブロックサイズ受信を繰り返します。"
    },
    {
      "indent": 3,
      "text": "o A Block1 Option in control usage in a response (e.g., a 2.xx response for a PUT or POST request):",
      "ja": "O応答して制御の使用におけるブロック1のオプション（例えば、PUTまたはPOST要求の2.xxの応答）："
    },
    {
      "indent": 6,
      "text": "* The NUM field of the Block1 Option indicates what block number is being acknowledged.",
      "ja": "*ブロック1オプションのNUMフィールドは、ブロック番号が認識されているものを示しています。"
    },
    {
      "indent": 6,
      "text": "* If the M bit was set in the request, the server can choose whether to act on each block separately, with no memory, or whether to handle the request for the entire body atomically, or any mix of the two.",
      "ja": "* Mビットが要求に設定されていた場合、サーバーはメモリーなしで、それぞれ別々のブロックに作用するか、またはアトミック体全体の要求、または2のいずれかの組み合わせを処理するかどうかを選択することができます。"
    },
    {
      "indent": 9,
      "text": "+ If the M bit is also set in the response, it indicates that this response does not carry the final response code to the request, i.e., the server collects further blocks from the same endpoint and plans to implement the request atomically (e.g., acts only upon reception of the last block of payload). In this case, the response MUST NOT carry a Block2 Option.",
      "ja": "+ Mビットも対応して設定されている場合は、この応答は、要求に対する最終応答コードを携帯しないことを示し、すなわち、サーバが同じエンドポイントからさらにブロックを収集し、アトミック（例えば、要求を実装する予定で、働きのみ）ペイロードの最後のブロックを受信します。この場合、応答は、ブロック2のオプションを運ぶならありません。"
    },
    {
      "indent": 9,
      "text": "+ Conversely, if the M bit is unset even though it was set in the request, it indicates the block-wise request was enacted now specifically for this block, and the response carries the final response to this request (and to any previous ones with the M bit set in the response's Block1 Option in this sequence of block-wise transfers); the client is still expected to continue sending further blocks, the request method for which may or may not also be enacted per-block. (Note that the resource is now in a partially updated state; this approach is only appropriate where exposing such an intermediate state is acceptable. The client can reduce the window by quickly continuing to update the resource, or, in case of failure, restarting the update.)",
      "ja": "+逆にそれが要求に設定したにもかかわらず、Mビットが設定されていない場合、それは、ブロックワイズ要求は、具体的には、このブロックのために今制定されたことを示し、そして応答は、この要求に対する最終的な応答を行う（とを有する任意の以前のものにブロック単位の転送の順序では、応答のブロック1のオプションで設定さMビット）。クライアントは、さらに他のブロックの送信を継続することが予想され、要求の方法は、あるいはまた、ブロック毎制定してもしなくてもよいです。 （リソースが部分的に更新された状態にあることに注意してください。このような中間状態を露光する場合、このアプローチは、適切であることは許容され、クライアントが再起動し、障害が発生した場合に、迅速にリソースを更新し続けることにより、ウィンドウを減らすかすることができます。更新。）"
    },
    {
      "indent": 6,
      "text": "* Finally, the SZX block size given in a control Block1 Option indicates the largest block size preferred by the server for transfers toward the resource that is the same or smaller than the one used in the initial exchange; the client SHOULD use this block size or a smaller one in all further requests in the transfer sequence, even if that means changing the block size (and possibly scaling the block number accordingly) from now on.",
      "ja": "*最後に、制御ブロック1のオプションで指定されたSZXブロックサイズは、同一または初期の交換に使用されるものよりも小さいリソースに向かって転送するためにサーバによって好まれる最大ブロックサイズを示します。クライアントは、それが今からブロックサイズを変更する（そしておそらくそれに応じてブロック番号をスケーリング）を意味する場合であっても、このブロックサイズや転送シーケンス内のすべてのさらなる要求が小さいものを使用すべきです。"
    },
    {
      "indent": 3,
      "text": "Using one or both Block options, a single REST operation can be split into multiple CoAP message exchanges. As specified in [RFC7252], each of these message exchanges uses their own CoAP Message ID.",
      "ja": "一方または両方のブロック・オプションを使用して、単一REST操作が複数CoAPメッセージ交換に分割することができます。 [RFC7252]で指定されるように、これらのメッセージ交換の各々は、独自CoAPメッセージIDを使用します。"
    },
    {
      "indent": 3,
      "text": "The Content-Format Option sent with the requests or responses MUST reflect the Content-Format of the entire body. If blocks of a response body arrive with different Content-Format Options, it is up to the client how to handle this error (it will typically abort any ongoing block-wise transfer). If blocks of a request arrive at a server with mismatching Content-Format Options, the server MUST NOT assemble them into a single request; this usually leads to a 4.08 (Request Entity Incomplete, Section 2.9.2) error response on the mismatching block.",
      "ja": "要求または応答で送信されたコンテンツフォーマットオプションは、体全体のコンテンツフォーマットを反映しなければなりません。レスポンスボディのブロックは異なるコンテンツフォーマットオプションで到着した場合、それはこのエラーを処理する方法をクライアント（それは、典型的には、任意の継続的なブロック単位の転送を中止します）までです。要求のブロックが不一致のContent-形式オプションを使用してサーバに到着した場合、サーバーは、単一の要求にそれらを組み立ててはなりません。これは通常、ミスマッチブロックの4.08（リクエストエンティティが不完全、セクション2.9.2）エラー応答につながります。"
    },
    {
      "indent": 0,
      "text": "2.4. Using the Block2 Option",
      "section_title": true,
      "ja": "2.4。ブロック2オプションの使用"
    },
    {
      "indent": 3,
      "text": "When a request is answered with a response carrying a Block2 Option with the M bit set, the requester may retrieve additional blocks of the resource representation by sending further requests with the same options as the initial request and a Block2 Option giving the block number and block size desired. In a request, the client MUST set the M bit of a Block2 Option to zero and the server MUST ignore it on reception.",
      "ja": "要求がMビットセットとブロック2のオプションを運ぶ応答で応答された場合、リクエスタは、最初の要求とブロック番号とブロックを与えるブロック2のオプションと同じオプションを使用してさらに要求を送信することによってリソース表現の追加のブロックを取り出すことができますサイズは、望ましいです。要求において、クライアントは、ブロック2オプションのMビットが0に設定しなければならないとサーバが受信時にそれを無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "To influence the block size used in a response, the requester MAY also use the Block2 Option on the initial request, giving the desired size, a block number of zero and an M bit of zero. A server MUST use the block size indicated or a smaller size. Any further block-wise requests for blocks beyond the first one MUST indicate the same block size that was used by the server in the response for the first request that gave a desired size using a Block2 Option.",
      "ja": "反応に使用されるブロックサイズに影響を与えるために、要求者はまた、所望のサイズ、ゼロのブロック数及びゼロのMビットを与え、最初の要求でブロック2のオプションを使用するかもしれません。サーバは、示されたブロックサイズまたはより小さいサイズを使用しなければなりません。最初のものを超えてブロックするための任意の更なるブロック単位の要求がブロック2のオプションを使用して所望の大きさを与えた最初の要求に対する応答でサーバによって使用された同じブロックサイズを指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Once the Block2 Option is used by the requester and a first response has been received with a possibly adjusted block size, all further requests in a single block-wise transfer will ultimately converge on using the same size, except that there may not be enough content to fill the last block (the one returned with the M bit not set). (Note that the client may start using the Block2 Option in a second request after a first request without a Block2 Option resulted in a Block2 Option in the response.) The server uses the block size indicated in the request option or a smaller size, but the requester MUST take note of the actual block size used in the response it receives to its initial request and proceed to use it in subsequent requests. The server behavior MUST ensure that this client behavior results in the same block size for all responses in a sequence (except for the last one with the M bit not set, and possibly the first one if the initial request did not contain a Block2 Option).",
      "ja": "ブロック2オプションはリクエスタによって使用され、最初の応答はおそらく調整ブロックサイズで受信された後、単一のブロック単位転送中のすべてのさらなる要求は、最終的に十分なコンテンツが存在しないことを除いて、同じサイズを使用して収束します最後のブロックを埋めるために（1が設定されていないMビットで返されます）。 （ブロック2のオプションなしで最初の要求が応答してブロック2のオプションが得られた後、クライアントは、第2の要求にブロック2オプションを使用して開始してもよいことに留意されたい。）サーバは、要求オプションまたは小さいサイズで示されるブロックサイズを使用するが、依頼者は、その最初の要求に受け取り、その後の要求でそれを使用するために進んで応答で使用される実際のブロックサイズのノートを取る必要があります。サーバーの動作は、（設定されていないMビットと最後のものを除いて、おそらく最初の要求は、ブロック2のオプションが含まれていなかった場合は、最初の1）シーケンスのすべての応答のための同じブロックサイズで、このクライアントの動作の結果を保証しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Block-wise transfers can be used to GET resources whose representations are entirely static (not changing over time at all, such as in a schema describing a device), or for dynamically changing resources. In the latter case, the Block2 Option SHOULD be used in conjunction with the ETag Option ([RFC7252], Section 5.10.6), to ensure that the blocks being reassembled are from the same version of the representation: The server SHOULD include an ETag Option in each response. If an ETag Option is available, the client, when reassembling the representation from the blocks being exchanged, MUST compare ETag Options. If the ETag Options do not match in a GET transfer, the requester has the option of attempting to retrieve fresh values for the blocks it retrieved first. To minimize the resulting inefficiency, the server MAY cache the current value of a representation for an ongoing sequence of requests. (The server may identify the sequence by the combination of the requesting endpoint and the URI being the same in each block-wise request.) Note well that this specification makes no requirement for the server to establish any state; however, servers that offer quickly changing resources may thereby make it impossible for a client to ever retrieve a consistent set of blocks. Clients that want to retrieve all blocks of a resource SHOULD strive to do so without undue delay. Servers can fully expect to be free to discard any cached state after a period of EXCHANGE_LIFETIME ([RFC7252], Section 4.8.2) after the last access to the state, however, there is no requirement to always keep the state for as long.",
      "ja": "ブロック単位の転送は、その表現全体が静的（そのようなデバイスを記述するスキーマのように、まったく時間にわたって変化しない）であるリソースを取得するために使用される、またはリソースを動的に変化させることができます。サーバは、ETagのを含める必要があります。後者の場合には、ブロック2のオプションは、表現の同じバージョンからあるブロックが再組み立てされることを確実にするために、ETagのオプション（[RFC7252]、セクション5.10.6）と組み合わせて使用​​されてください各応答でオプション。 ETagのオプションが利用可能な場合は交換されているブロックからの表現を再構築するとき、クライアントは、ETagのオプションを比較しなければなりません。 ETagのオプションは、GET転送に一致しない場合、要求者は、それが最初に取り出されたブロックのための新鮮な値を取得しようとするオプションがあります。結果として非効率性を最小限に抑えるために、サーバはリクエストの継続的な一連の表現の現在の値をキャッシュすることができます。 （サーバは、要求エンドポイントとURI各ブロックワイズ要求で同じであることの組合せによって配列を同定してもよい。）本明細書は、任意の状態を確立するサーバーのための要件を行っていないことを十分に注意してください。しかし、急速に変化のリソースを提供するサーバは、それによって、それが不可能なクライアントは、これまでのブロックの一貫性のあるセットを取得するために作ることがあります。リソースのすべてのブロックを取得したいクライアントは、不当な遅滞なくこれを行うに努力すべきです。サーバーが完全な状態に最後にアクセスした後EXCHANGE_LIFETIME（[RFC7252]、セクション4.8.2）の期間の後に任意のキャッシュされた状態を破棄して自由になることを期待することができ、しかし、いつものように長い間、状態を維持する必要がありません。"
    },
    {
      "indent": 3,
      "text": "The Block2 Option provides no way for a single endpoint to perform multiple concurrently proceeding block-wise response payload transfer (e.g., GET) operations to the same resource. This is rarely a requirement, but as a workaround, a client may vary the cache key (e.g., by using one of several URIs accessing resources with the same semantics, or by varying a proxy-safe elective option).",
      "ja": "ブロック2のオプションは、単一のエンドポイントが同時に同じリソースにブロック単位の応答ペイロード転送（例えば、GET）操作を進める複数実行するための方法を提供しません。これはめったに要件ではありませんが、回避策として、クライアントが（例えば、同じ意味を持つリソースにアクセスするいくつかのURIのいずれかを使用して、またはプロキシ・安全な選択科目オプションを変更することによって）キャッシュキーを変更することがあります。"
    },
    {
      "indent": 0,
      "text": "2.5. Using the Block1 Option",
      "section_title": true,
      "ja": "2.5。ブロック1オプションの使用"
    },
    {
      "indent": 3,
      "text": "In a request with a request payload (e.g., PUT or POST), the Block1 Option refers to the payload in the request (descriptive usage).",
      "ja": "要求ペイロード（例えば、PUTまたはPOST）とのリクエストで、ブロック1のオプションは、要求（記述使用）でペイロードを指します。"
    },
    {
      "indent": 3,
      "text": "In response to a request with a payload (e.g., a PUT or POST transfer), the block size given in the Block1 Option indicates the block size preference of the server for this resource (control usage). Obviously, at this point the first block has already been transferred by the client without benefit of this knowledge. Still, the client SHOULD heed the preference indicated and, for all further blocks, use the block size preferred by the server or a smaller one. Note that any reduction in the block size may mean that the second request starts with a block number larger than one, as the first request already transferred multiple blocks as counted in the smaller size.",
      "ja": "ペイロード（例えば、PUTまたはPOST転送）との要求に応答して、ブロック1のオプションで指定されたブロックサイズは、このリソース（コントロールの使用）のためのサーバのブロックサイズ設定を示します。明らかに、この時点で、最初のブロックは、すでにこの知識の恩恵なしにクライアントによって転送されてきました。依然として、クライアントは、嗜好が示され、他の全てのブロックについて、サーバまたは小さい方によって好ましいブロックサイズを使用留意すべきです。ブロックサイズの減少は、第2の要求は、より小さなサイズに数えて既に複数のブロックを転送最初の要求として、1より大きいブロック番号から始まることを意味することに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "To counter the effects of adaptation-layer fragmentation on packet-delivery probability, a client may want to give up retransmitting a request with a relatively large payload even before MAX_RETRANSMIT has been reached, and try restating the request as a block-wise transfer with a smaller payload. Note that this new attempt is then a new message-layer transaction and requires a new Message ID. (Because of the uncertainty about whether the request or the acknowledgement was lost, this strategy is useful mostly for idempotent requests.)",
      "ja": "パケット配信確率に適応層の断片化の影響に対抗するために、クライアントはMAX_RETRANSMITに達した前でも、比較的大きなペイロードを持つ要求を再送信をあきらめ、としてブロック単位の転送などのリクエストを修正再表示しようとする場合があります小さなペイロード。この新しい試みは、新しいメッセージ層のトランザクションで、新しいメッセージIDが必要であることに注意してください。 （そのため、要求または受信確認が失われたかどうかについての不確実性のため、この戦略は、ほとんどべき等要求するのに便利です。）"
    },
    {
      "indent": 3,
      "text": "In a block-wise transfer of a request payload (e.g., a PUT or POST) that is intended to be implemented in an atomic fashion at the server, the actual creation/replacement takes place at the time the final block, i.e., a block with the M bit unset in the Block1 Option, is received. In this case, all success responses to non-final blocks carry the response code 2.31 (Continue, Section 2.9.1). If not all previous blocks are available at the server at the time of processing the final block, the transfer fails and error code 4.08 (Request Entity Incomplete, Section 2.9.2) MUST be returned. A server MAY also return a 4.08 error code for any (final or non-final) Block1 transfer that is not in sequence; therefore, clients that do not have specific mechanisms to handle this case SHOULD always start with block zero and send the following blocks in order.",
      "ja": "要求ペイロードのブロック単位の転送に（例えば、PUTまたはPOST）サーバでアトミックな方法で実施されることが意図され、実際の作成/交換は時間最終ブロック、すなわち、ブロックで行われますブロック1のオプションで解除Mビットで、受信されます。この場合、非最終ブロックへのすべての成功応答は（セクション2.9.1を続行）応答コード2.31を運びます。必ずしもすべての以前のブロックが最終ブロックの処理時にサーバで利用可能である場合、転送は失敗し、4.08（要求エンティティ不完全、セクション2.9.2）エラーコードが返されなければなりません。サーバはまた、配列内にない（最終または非最終）ブロック1の転送のための4.08のエラーコードを返すかもしれ。そのため、このケースを処理するための具体的なメカニズムを持っていないクライアントは常にブロックゼロから始めて、順番に次のブロックを送るべきです。"
    },
    {
      "indent": 3,
      "text": "One reason that a client might encounter a 4.08 error code is that the server has already timed out and discarded the partial request body being assembled. Clients SHOULD strive to send all blocks of a request without undue delay. Servers can fully expect to be free to discard any partial request body when a period of EXCHANGE_LIFETIME ([RFC7252], Section 4.8.2) has elapsed after the most recent block was transferred; however, there is no requirement on a server to always keep the partial request body for as long.",
      "ja": "クライアントが4.08エラーコードが発生することがあります一つの理由は、サーバがすでにタイムアウトし、部分的なリクエストボディが組み立てられて廃棄したことです。クライアントは、不当な遅延なく、要求のすべてのブロックを送信するために努力すべきです。サーバーは完全に最新のブロックが転送された後EXCHANGE_LIFETIME（[RFC7252]、セクション4.8.2）の期間が経過した任意の部分的なリクエストボディを破棄して自由であることを期待することができます。しかし、いつものように長いため、部分的リクエストボディを保つために、サーバー上の必要はありません。"
    },
    {
      "indent": 3,
      "text": "The error code 4.13 (Request Entity Too Large) can be returned at any time by a server that does not currently have the resources to store blocks for a block-wise request payload transfer that it would intend to implement in an atomic fashion. (Note that a 4.13 response to a request that does not employ Block1 is a hint for the client to try sending Block1, and a 4.13 response with a smaller SZX in its Block1 Option than requested is a hint to try a smaller SZX.)",
      "ja": "エラーコード4.13（エンティティが大きすぎる要求）現在、それはアトミックな方法で実装するつもりだろうとブロック単位の要求ペイロード転送用ブロックを格納するためのリソースを持っていないサーバーでいつでも戻すことができます。 （ブロック1を使用しない要求に4.13応答が小さくSZXをしようとするヒントクライアントはブロック1を送信しようとするためのヒント、および要求されたよりも、そのブロック1オプションが小さいSZXと4.13応答されていることに注意してください。）"
    },
    {
      "indent": 3,
      "text": "A block-wise transfer of a request payload that is implemented in a stateless fashion at the server is likely to leave the resource being operated on in an inconsistent state while the transfer is still ongoing or when the client does not complete the transfer. This characteristic is closer to that of remote file systems than to that of HTTP, where state is always kept on the server during a transfer. Techniques well known from shared file access (e.g., client-specific temporary resources) can be used to mitigate this difference from HTTP.",
      "ja": "転送がまだ進行中であるか、クライアントが転送を完了していないときながら、サーバでステートレスな方法で実装されている要求ペイロードのブロック単位の転送が矛盾した状態での操作されたリソースを残す可能性があります。この特性は、状態は常に転送中にサーバー上に保存されたHTTP、のそれに比べてリモートファイルシステムのそれに近いです。うまく共有ファイルへのアクセス（例えば、クライアント固有の一時的なリソース）から知られている技術は、HTTPからこの違いを緩和するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "The Block1 Option provides no way for a single endpoint to perform multiple concurrently proceeding block-wise request payload transfer (e.g., PUT or POST) operations to the same resource. Starting a new block-wise sequence of requests to the same resource (before an old sequence from the same endpoint was finished) simply overwrites the context the server may still be keeping. (This is probably exactly what one wants in this case -- the client may simply have restarted and lost its knowledge of the previous sequence.)",
      "ja": "ブロック1のオプションは、複数の同時進行ブロックワイズ要求ペイロード転送（例えば、PUTまたはPOST）が同じリソースへの操作を実行するための単一のエンドポイントのための方法を提供しません。 （同じエンドポイントからの古いシーケンスが終了した前に）同じリソースへの要求の新しいブロック単位のシーケンスを開始すると、単にサーバがまだ維持することができるコンテキストを上書きします。 （これは1つが、この場合に望んでいるまさにおそらくです - クライアントは、単純に再起動し、前のシーケンスの知識を失っている可能性があります。）"
    },
    {
      "indent": 0,
      "text": "2.6. Combining Block-Wise Transfers with the Observe Option",
      "section_title": true,
      "ja": "2.6。守っオプションでブロック単位の転送を組み合わせます"
    },
    {
      "indent": 3,
      "text": "The Observe option provides a way for a client to be notified about changes over time of a resource [RFC7641]. Resources observed by clients may be larger than can be comfortably processed or transferred in one CoAP message. The following rules apply to the combination of block-wise transfers with notifications.",
      "ja": "観察オプションは、クライアントがリソース[RFC7641]の時間変化を通知するための方法を提供します。クライアントによって観察リソース快適1つのCoAPメッセージで処理または転送することができるよりも大きくてもよいです。次のルールは、通知とブロック単位の転送の組み合わせに適用されます。"
    },
    {
      "indent": 3,
      "text": "Observation relationships always apply to an entire resource; the Block2 Option does not provide a way to observe a single block of a resource.",
      "ja": "観測の関係は、常に全体のリソースに適用されます。ブロック2のオプションは、リソースの単一のブロックを観察する方法を提供していません。"
    },
    {
      "indent": 3,
      "text": "As with basic GET transfers, the client can indicate its desired block size in a Block2 Option in the GET request establishing or renewing the observation relationship. If the server supports block-wise transfers, it SHOULD take note of the block size and apply it as a maximum size to all notifications/responses resulting from the GET request (until the client is removed from the list of observers or the entry in that list is updated by the server receiving a new GET request for the resource from the client).",
      "ja": "基本的なGET転送と同様に、クライアントは、観測関係を確立又は更新GET要求内のブロック2のオプションでその所望のブロックサイズを示すことができます。サーバーは、ブロック単位の転送をサポートしている場合、それはブロックサイズのノートを取り、クライアントがオブザーバーのリストか、その内のエントリから削除されるまで（GETリクエストから生じたすべての通知/応答の最大サイズとしてそれを適用する必要がありますこのリストは、クライアントからリソース）のための新しいGET要求を受信するサーバーによって更新されます。"
    },
    {
      "indent": 3,
      "text": "When sending a 2.05 (Content) notification, the server only sends the first block of the representation. The client retrieves the rest of the representation as if it had caused this first response by a GET request, i.e., by using additional GET requests with Block2 Options containing NUM values greater than zero. (This results in the transfer of the entire representation, even if only some of the blocks have changed with respect to a previous notification.)",
      "ja": "2.05（コンテンツ）の通知を送信する場合、サーバは表現の最初のブロックを送信します。それはすなわち、NUMゼロより大きい値を含むブロック2のオプションと、追加のGET要求を使用して、GET要求によって、この最初の応答を引き起こしたかのように、クライアントは、表現の残りの部分を取得します。 （これは、いくつかのブロックは、前の通知に対して変更された場合でも、全体の表現の転送をもたらします。）"
    },
    {
      "indent": 3,
      "text": "As with other dynamically changing resources, to ensure that the blocks being reassembled are from the same version of the representation, the server SHOULD include an ETag Option in each response, and the reassembling client MUST compare the ETag Options (Section 2.4). Even more so than for the general case of Block2, clients that want to retrieve all blocks of a resource they have been notified about with a first block SHOULD strive to do so without undue delay.",
      "ja": "他の動的に変化するリソースと同様に、再組み立てされたブロックは、表現の同じバージョンからのものであることを保証するために、サーバは各応答のETagオプションを含めるべきであり、再組み立てクライアントのETagオプション（セクション2.4）を比較しなければなりません。さらにそのブロック2の一般的な場合よりも、彼らは最初のブロックとについて通知されているリソースのすべてのブロックを取得するクライアントは、不当な遅滞なくこれを行うに努力すべきです。"
    },
    {
      "indent": 3,
      "text": "See Section 3.4 for examples.",
      "ja": "例については、3.4節を参照してください。"
    },
    {
      "indent": 0,
      "text": "2.7. Combining Block1 and Block2",
      "section_title": true,
      "ja": "2.7。ブロック1とブロック2を組み合わせます"
    },
    {
      "indent": 3,
      "text": "In PUT and particularly in POST exchanges, both the request body and the response body may be large enough to require the use of block-wise transfers. First, the Block1 transfer of the request body proceeds as usual. In the exchange of the last slice of this block-wise transfer, the response carries the first slice of the Block2 transfer (NUM is zero). To continue this Block2 transfer, the client continues to send requests similar to the requests in the Block1 phase, but leaves out the Block1 Options and includes a Block2 request option with non-zero NUM.",
      "ja": "PUTに特にPOST交換に、リクエストボディとレスポンスボディの両方は、ブロック単位の転送の使用を必要とするのに十分な大きさであってもよいです。まず、リクエストボディのブロック1の転送がいつものように進行します。このブロック単位の転送の最後のスライスの交換では、応答は、ブロック2の転送（NUMがゼロである）の最初のスライスを運びます。このブロック2の転送を継続するには、クライアントは、ブロック1のフェーズにおける要求に似たリクエストを送信し続けますが、ブロック1のオプションを離れ、非ゼロNUMとBlock2の要求オプションを含んでいます。"
    },
    {
      "indent": 3,
      "text": "Block2 transfers that retrieve the response body for a request that used Block1 MUST be performed in sequential order.",
      "ja": "ブロック1を使用した要求に対する応答の本体を取得BLOCK2転送が順番に実行されなければなりません。"
    },
    {
      "indent": 0,
      "text": "2.8. Combining Block2 with Multicast",
      "section_title": true,
      "ja": "2.8。マルチキャストでブロック2を組み合わせます"
    },
    {
      "indent": 3,
      "text": "A client can use the Block2 Option in a multicast GET request with NUM = 0 to aid in limiting the size of the response.",
      "ja": "クライアントは、応答の大きさを制限するのに役立つためにNUM = 0とマルチキャストGETリクエストでブロック2のオプションを使用することができます。"
    },
    {
      "indent": 3,
      "text": "Similarly, a response to a multicast GET request can use a Block2 Option with NUM = 0 if the representation is large, or to further limit the size of the response.",
      "ja": "同様に、表現が大きい、又はさらに応答の大きさを制限する場合NUM = 0とブロック2のオプションを使用することができ、マルチキャストGET要求に対する応答。"
    },
    {
      "indent": 3,
      "text": "In both cases, the client retrieves any further blocks using unicast exchanges; in the unicast requests, the client SHOULD heed any block size preferences indicated by the server in the response to the multicast request.",
      "ja": "両方の場合において、クライアントは、ユニキャスト交換を使用して任意のさらなるブロックを取り出します。ユニキャスト要求で、クライアントがマルチキャスト要求に応じてサーバから指摘されたブロック・サイズの好みに耳を傾けるべきです。"
    },
    {
      "indent": 3,
      "text": "Other uses of the Block options in conjunction with multicast messages are for further study.",
      "ja": "マルチキャストメッセージと一緒にブロックオプションの他の用途は、今後の検討課題です。"
    },
    {
      "indent": 0,
      "text": "2.9. Response Codes",
      "section_title": true,
      "ja": "2.9。応答コード"
    },
    {
      "indent": 3,
      "text": "Beyond the response codes defined in [RFC7252], this specification defines two response codes and extends the meaning of one.",
      "ja": "[RFC7252]で定義されたレスポンスコードを超えて、本明細書は、2つの応答コードを定義し、一方の意味を拡張します。"
    },
    {
      "indent": 0,
      "text": "2.9.1. 2.31 Continue",
      "section_title": true,
      "ja": "2.9.1。 2.31続行"
    },
    {
      "indent": 3,
      "text": "This new success status code indicates that the transfer of this block of the request body was successful and that the server encourages sending further blocks, but that a final outcome of the whole block-wise request cannot yet be determined. No payload is returned with this response code.",
      "ja": "この新しい成功ステータスコードは、リクエストボディのこのブロックの転送が成功したことを示し、サーバは、さらにブロックを送信するが、全体ブロック単位の要求の最終的な結果はまだ決定できない奨励しています。何ペイロードは、この応答コードを返されません。"
    },
    {
      "indent": 0,
      "text": "2.9.2. 4.08 Request Entity Incomplete",
      "section_title": true,
      "ja": "2.9.2。 4.08リクエストエンティティが不完全"
    },
    {
      "indent": 3,
      "text": "This new client error status code indicates that the server has not received the blocks of the request body that it needs to proceed. The client has not sent all blocks, not sent them in the order required by the server, or has sent them long enough ago that the server has already discarded them.",
      "ja": "この新しいクライアントエラーステータスコードは、サーバーが続行する必要がリクエストボディのブロックを受信して​​いないことを示しています。クライアントは、すべてのブロックを送信していない、サーバに必要な順序でそれらを送信し、またはサーバがすでにそれらを廃棄したことを十分に前に長い彼らを送ってきたではありません。"
    },
    {
      "indent": 3,
      "text": "(Note that one reason for not having the necessary blocks at hand may be a Content-Format mismatch, see Section 2.3. Implementation note: A server can reject a Block1 transfer with this code when NUM != 0 and a different Content-Format is indicated than expected from the current state of the resource. If it implements the transfer in a stateless fashion, it can match up the Content-Format of the block against that of the existing resource. If it implements the transfer in an atomic fashion, it can match up the block against the partially reassembled piece of representation that is going to replace the state of the resource.)",
      "ja": "。！NUM = 0と異なるコンテンツフォーマットである場合は、サーバーはこのコードのブロック1の転送を拒否することができます（手元に必要なブロックを持っていない理由の一つは、セクション2.3を参照してください、コンテンツ・フォーマットの不一致であってもよいこと実装上の注意に注意してくださいリソースの現在の状態から予想以上に示されている。それはステートレスな方法で転送を実装している場合、それは、既存のリソースのそれに対するブロックのコンテンツフォーマットを一致させることができます。それは、原子の方法で転送を実装している場合、それはリソースの状態を交換しようとしている表現の部分的に再組み立て作品に対するブロックを一致させることができます。）"
    },
    {
      "indent": 0,
      "text": "2.9.3. 4.13 Request Entity Too Large",
      "section_title": true,
      "ja": "2.9.3。 4.13要求エンティティが大きすぎます"
    },
    {
      "indent": 3,
      "text": "In Section 5.9.2.9 of [RFC7252], the response code 4.13 (Request Entity Too Large) is defined to be like HTTP 413 \"Request Entity Too Large\". [RFC7252] also recommends that this response SHOULD include a Size1 Option (Section 4) to indicate the maximum size of request entity the server is able and willing to handle, unless the server is not in a position to make this information available.",
      "ja": "[RFC7252]のセクション5.9.2.9において、応答コード4.13（大きすぎ要求エンティティ）がHTTP 413「要求エンティティが大きすぎます」のようであると定義されます。 [RFC7252]も、この応答は、サーバがこの情報を利用可能にする位置にない場合を除き、サーバは、扱うことができると喜んで要求エンティティの最大サイズを示すサイズ1のオプション（第4章）を含むべきであることをお勧めします。"
    },
    {
      "indent": 3,
      "text": "The present specification allows the server to return this response code at any time during a Block1 transfer to indicate that it does not currently have the resources to store blocks for a transfer that it would intend to implement in an atomic fashion. It also allows the server to return a 4.13 response to a request that does not employ Block1 as a hint for the client to try sending Block1. Finally, a 4.13 response to a request with a Block1 Option (control usage, see Section 2.3) where the response carries a smaller SZX in its Block1 Option is a hint to try that smaller SZX.",
      "ja": "本明細書は、サーバーが現在、それはアトミックな方法で実施する予定です転送のためのブロックを格納するためのリソースを持っていないことを示すために、ブロック1の転送中に任意の時点で、この応答コードを返すことができます。また、サーバーがブロック1を送信しようとするクライアントのためのヒントとしてブロック1を使用しない要求に4.13応答を返すことができます。最後に、ブロック1オプション付き要求に対して4.13応答レスポンスが小さくSZXことを試みるためのヒントは、そのブロック1のオプションで小さいSZXを担持（コントロールの使用は、セクション2.3を参照します）。"
    },
    {
      "indent": 0,
      "text": "2.10. Caching Considerations",
      "section_title": true,
      "ja": "2.10。キャッシングの考慮事項"
    },
    {
      "indent": 3,
      "text": "This specification attempts to leave a variety of implementation strategies open for caches, in particular those in caching proxies. For example, a cache is free to cache blocks individually, but also could wait to obtain the complete representation before it serves parts of it. Partial caching may be more efficient in a cross-proxy (equivalent to a streaming HTTP proxy). A cached block (partial cached response) can be used in place of a complete response to satisfy a block-wise request that is presented to a cache. Note that different blocks can have different Max-Age values, as they are transferred at different times. A response with a block updates the freshness of the complete representation. Individual blocks can be validated, and validating a single block validates the complete representation. A response with a Block1 Option in control usage with the M bit set invalidates cached responses for the target URI.",
      "ja": "この仕様は、キャッシングプロキシのもの、特に、キャッシュのためのオープンな実装戦略の多様性を残すようにしようとします。たとえば、キャッシュが個別にブロックをキャッシュして自由ですが、また、それはそれの部品を提供しています前に、完全な表現を得るために待つことができます。部分的キャッシングは、クロスプロキシ（ストリーミングHTTPプロキシに相当する）に、より効率的であり得ます。キャッシュされたブロック（パーシャルキャッシュされた応答）はキャッシュに提示されるブロック単位の要求を満たすために、完全な応答の代わりに使用することができます。彼らは異なる時間に転送される別のブロックは、異なるマックスエイジ値を持つことができることに注意してください。ブロックでの応答は、完全な表現の鮮度を更新します。個々のブロックは、検証、および単一のブロックを検証することの完全な表現を検証することができます。 Mビットが設定された制御の使用におけるブロック1オプション付き応答がターゲットURIのキャッシュされた応答を無効化します。"
    },
    {
      "indent": 3,
      "text": "A cache or proxy that combines responses (e.g., to split blocks in a request or increase the block size in a response, or a cross-proxy) may need to combine 2.31 and 2.01/2.04 responses; a stateless server may be responding with 2.01 only on the first Block1 block transferred, which dominates any 2.04 responses for later blocks.",
      "ja": "応答を結合キャッシュまたはプロキシは、2.31と2.01 / 2.04応答を結合する必要があるかもしれない（例えば、要求のブロックを分割または応答、またはクロスプロキシでブロックサイズを増加させます）。ステートレス・サーバは、後ブロックの任意2.04応答を支配する転写第ブロック1ブロックに2.01で応答することができます。"
    },
    {
      "indent": 3,
      "text": "If-None-Match only works correctly on Block1 requests with (NUM=0) and MUST NOT be used on Block1 requests with NUM != 0.",
      "ja": "もし-なし - マッチのみ（NUM = 0）とブロック1のリクエストで正しく動作し、NUM！= 0とブロック1の要求に使用してはいけません。"
    },
    {
      "indent": 0,
      "text": "3. Examples",
      "section_title": true,
      "ja": "3.例"
    },
    {
      "indent": 3,
      "text": "This section gives a number of short examples with message flows for a block-wise GET, and for a PUT or POST. These examples demonstrate the basic operation, the operation in the presence of retransmissions, and examples for the operation of the block size negotiation.",
      "ja": "このセクションでは、メッセージはブロック単位GETのための、およびPUTまたはPOSTのためにフローに短い例の数を与えます。これらの例は、基本的な操作、再送信の存在下での動作、およびブロックサイズのネゴシエーションの動作の例を示しています。"
    },
    {
      "indent": 3,
      "text": "In all these examples, a Block option is shown in a decomposed way indicating the kind of Block option (1 or 2) followed by a colon, and then the block number (NUM), more bit (M), and block size exponent (2**(SZX+4)) separated by slashes. For example, a Block2 Option value of 33 would be shown as 2:2/0/32) and a Block1 Option value of 59 would be shown as 1:3/1/128.",
      "ja": "すべてのこれらの例では、ブロック・オプションが（1又は2）ブロック・オプションの種類を示す分解方法で示されているコロン、次にブロック番号（NUM）、複数ビット（M）、及びブロックサイズ指数（ 2 **（SZX + 4））、スラッシュで区切られました。 2/0/32）及び59のブロック1のオプション値が1として示されるであろう：3/1/128例えば、33のブロック2のオプション値は2として示されるであろう。"
    },
    {
      "indent": 3,
      "text": "As in [RFC7252], \"MID\" is used as an abbreviation for \"Message ID\".",
      "ja": "[RFC7252]のように、「MID」は「メッセージID」の略語として使用されます。"
    },
    {
      "indent": 0,
      "text": "3.1. Block2 Examples",
      "section_title": true,
      "ja": "3.1。ブロック2例"
    },
    {
      "indent": 3,
      "text": "The first example (Figure 2) shows a GET request that is split into three blocks. The server proposes a block size of 128, and the client agrees. The first two ACKs contain a payload of 128 bytes each, and the third ACK contains a payload between 1 and 128 bytes.",
      "ja": "最初の例（図2）は、3つのブロックに分割されたGET要求を示しています。サーバーは、128のブロックサイズを提案し、クライアントが同意します。最初の二つのACKは、128バイト毎のペイロードを含み、第三のACKは、1と128バイトのペイロードを含んでいます。"
    },
    {
      "indent": 3,
      "text": "CLIENT                                                     SERVER\n  |                                                            |\n  | CON [MID=1234], GET, /status                       ------> |\n  |                                                            |\n  | <------   ACK [MID=1234], 2.05 Content, 2:0/1/128          |\n  |                                                            |\n  | CON [MID=1235], GET, /status, 2:1/0/128            ------> |\n  |                                                            |\n  | <------   ACK [MID=1235], 2.05 Content, 2:1/1/128          |\n  |                                                            |\n  | CON [MID=1236], GET, /status, 2:2/0/128            ------> |\n  |                                                            |\n  | <------   ACK [MID=1236], 2.05 Content, 2:2/0/128          |",
      "raw": true
    },
    {
      "indent": 22,
      "text": "Figure 2: Simple Block-Wise GET",
      "ja": "図2：シンプルなブロック単位GET"
    },
    {
      "indent": 3,
      "text": "In the second example (Figure 3), the client anticipates the block-wise transfer (e.g., because of a size indication in the link-format description [RFC6690]) and sends a block size proposal. All ACK messages except for the last carry 64 bytes of payload; the last one carries between 1 and 64 bytes.",
      "ja": "第二の例（図3）において、クライアントは、ブロック単位の転送（例えば、なぜならリンク形式の説明では、サイズ表示の[RFC6690]）を予想し、ブロックサイズの提案を送信します。最後のキャリーペイロードの64のバイトを除くすべてのACKメッセージ。最後のものは、1〜64バイトを運びます。"
    },
    {
      "indent": 3,
      "text": "CLIENT                                                     SERVER\n  |                                                          |\n  | CON [MID=1234], GET, /status, 2:0/0/64           ------> |\n  |                                                          |\n  | <------   ACK [MID=1234], 2.05 Content, 2:0/1/64         |\n  |                                                          |\n  | CON [MID=1235], GET, /status, 2:1/0/64           ------> |\n  |                                                          |\n  | <------   ACK [MID=1235], 2.05 Content, 2:1/1/64         |\n  :                                                          :\n  :                          ...                             :\n  :                                                          :\n  | CON [MID=1238], GET, /status, 2:4/0/64           ------> |\n  |                                                          |\n  | <------   ACK [MID=1238], 2.05 Content, 2:4/1/64         |\n  |                                                          |\n  | CON [MID=1239], GET, /status, 2:5/0/64           ------> |\n  |                                                          |\n  | <------   ACK [MID=1239], 2.05 Content, 2:5/0/64         |",
      "raw": true
    },
    {
      "indent": 14,
      "text": "Figure 3: Block-Wise GET with Early Negotiation",
      "ja": "図3：ブロック単位は、早期交渉でGET"
    },
    {
      "indent": 3,
      "text": "In the third example (Figure 4), the client is surprised by the need for a block-wise transfer, and unhappy with the size chosen unilaterally by the server. As it did not send a size proposal initially, the negotiation only influences the size from the second message exchange onward. Since the client already obtained both the first and second 64-byte block in the first 128-byte exchange, it goes on requesting the third 64-byte block (\"2/0/64\"). None of this is (or needs to be) understood by the server, which simply responds to the requests as it best can.",
      "ja": "第三の例（図4）において、クライアントは、サーバによって一方的に選択されたサイズのブロック単位の転送の必要性に驚き、そして不幸されています。それは最初にサイズの提案を送信しなかったため、交渉は2回目以降のメッセージ交換からのサイズに影響を与えます。クライアントは、既に最初の128バイト交換における第1および第2の64バイトブロックの両方が得られるので、第64バイトのブロック（「2/0/64」）を要求していきます。これのどれもありません（またはする必要があります）、単にそれ最高の缶などの要求に応答するサーバーで理解します。"
    },
    {
      "indent": 3,
      "text": "CLIENT                                                     SERVER\n  |                                                          |\n  | CON [MID=1234], GET, /status                     ------> |\n  |                                                          |\n  | <------   ACK [MID=1234], 2.05 Content, 2:0/1/128        |\n  |                                                          |\n  | CON [MID=1235], GET, /status, 2:2/0/64           ------> |\n  |                                                          |\n  | <------   ACK [MID=1235], 2.05 Content, 2:2/1/64         |\n  |                                                          |\n  | CON [MID=1236], GET, /status, 2:3/0/64           ------> |\n  |                                                          |\n  | <------   ACK [MID=1236], 2.05 Content, 2:3/1/64         |\n  |                                                          |\n  | CON [MID=1237], GET, /status, 2:4/0/64           ------> |\n  |                                                          |\n  | <------   ACK [MID=1237], 2.05 Content, 2:4/1/64         |\n  |                                                          |\n  | CON [MID=1238], GET, /status, 2:5/0/64           ------> |\n  |                                                          |\n  | <------   ACK [MID=1238], 2.05 Content, 2:5/0/64         |",
      "raw": true
    },
    {
      "indent": 14,
      "text": "Figure 4: Block-Wise GET with Late Negotiation",
      "ja": "図4：ブロック単位は、後期交渉でGET"
    },
    {
      "indent": 3,
      "text": "In all these (and the following) cases, retransmissions are handled by the CoAP message exchange layer, so they don't influence the block operations (Figures 5 and 6).",
      "ja": "すべてのこれらの（および以下）の場合に、再送信はCoAPメッセージ交換層によって処理されるので、それらはブロック操作影響しない（図5および6）。"
    },
    {
      "indent": 3,
      "text": "CLIENT                                                     SERVER\n  |                                                          |\n  | CON [MID=1234], GET, /status                     ------> |\n  |                                                          |\n  | <------   ACK [MID=1234], 2.05 Content, 2:0/1/128        |\n  |                                                          |\n  | CON [MID=1235], GE/////////////////////////              |\n  |                                                          |\n  | (timeout)                                                |\n  |                                                          |\n  | CON [MID=1235], GET, /status, 2:2/0/64           ------> |\n  |                                                          |\n  | <------   ACK [MID=1235], 2.05 Content, 2:2/1/64         |\n  :                                                          :\n  :                          ...                             :\n  :                                                          :\n  | CON [MID=1238], GET, /status, 2:5/0/64           ------> |\n  |                                                          |\n  | <------   ACK [MID=1238], 2.05 Content, 2:5/0/64         |",
      "raw": true
    },
    {
      "indent": 8,
      "text": "Figure 5: Block-Wise GET with Late Negotiation and Lost CON",
      "ja": "図5：ブロック単位は後期交渉とロストCONでGET"
    },
    {
      "indent": 3,
      "text": "CLIENT                                                     SERVER\n  |                                                          |\n  | CON [MID=1234], GET, /status                     ------> |\n  |                                                          |\n  | <------   ACK [MID=1234], 2.05 Content, 2:0/1/128        |\n  |                                                          |\n  | CON [MID=1235], GET, /status, 2:2/0/64           ------> |\n  |                                                          |\n  | //////////////////////////////////tent, 2:2/1/64         |\n  |                                                          |\n  | (timeout)                                                |\n  |                                                          |\n  | CON [MID=1235], GET, /status, 2:2/0/64           ------> |\n  |                                                          |\n  | <------   ACK [MID=1235], 2.05 Content, 2:2/1/64         |\n  :                                                          :\n  :                          ...                             :\n  :                                                          :\n  | CON [MID=1238], GET, /status, 2:5/0/64           ------> |\n  |                                                          |\n  | <------   ACK [MID=1238], 2.05 Content, 2:5/0/64         |",
      "raw": true
    },
    {
      "indent": 8,
      "text": "Figure 6: Block-Wise GET with Late Negotiation and Lost ACK",
      "ja": "図6：ブロック単位は後期交渉し、失われたACKをGET"
    },
    {
      "indent": 0,
      "text": "3.2. Block1 Examples",
      "section_title": true,
      "ja": "3.2。ブロック1例"
    },
    {
      "indent": 3,
      "text": "The following examples demonstrate a PUT exchange; a POST exchange looks the same, with different requirements on atomicity/idempotence. Note that, similar to GET, the responses to the requests that have a more bit in the request Block1 Option are provisional and carry the response code 2.31 (Continue); only the final response tells the client that the PUT succeeded.",
      "ja": "次の例では、PUT交換を発揮します。 POST交換は、原子/冪等の異なる要件で、同じように見えます。 （継続）、取得するために同様の、要求ブロック1のオプションで複数ビットを有するリクエストに対する応答が暫定的であり、応答コード2.31を運ぶことに留意されたいです。唯一の最終的な応答は、PUTが成功したクライアントに指示します。"
    },
    {
      "indent": 3,
      "text": "CLIENT                                                     SERVER\n  |                                                          |\n  | CON [MID=1234], PUT, /options, 1:0/1/128    ------>      |\n  |                                                          |\n  | <------   ACK [MID=1234], 2.31 Continue, 1:0/1/128       |\n  |                                                          |\n  | CON [MID=1235], PUT, /options, 1:1/1/128    ------>      |\n  |                                                          |\n  | <------   ACK [MID=1235], 2.31 Continue, 1:1/1/128       |\n  |                                                          |\n  | CON [MID=1236], PUT, /options, 1:2/0/128    ------>      |\n  |                                                          |\n  | <------   ACK [MID=1236], 2.04 Changed, 1:2/0/128        |",
      "raw": true
    },
    {
      "indent": 18,
      "text": "Figure 7: Simple Atomic Block-Wise PUT",
      "ja": "図7：シンプルなアトミックブロック単位のPUT"
    },
    {
      "indent": 3,
      "text": "A stateless server that simply builds/updates the resource in place (statelessly) may indicate this by not setting the more bit in the response (Figure 8); in this case, the response codes are valid separately for each block being updated. This is of course only an acceptable behavior of the server if the potential inconsistency present during the run of the message exchange sequence does not lead to problems, e.g., because the resource being created or changed is not yet or not currently in use.",
      "ja": "単に/が適所にリソースを更新構築ステートレスサーバ（ステートレス）応答（図8）以上のビットを設定しないことによってこれを示すことができます。この場合には、応答コードが更新され、ブロック毎に個別に有効です。作成または変更されたリソースが使用されていない、まだか、現在あるため、メッセージ交換シーケンスの実行時に存在する潜在的な矛盾は、例えば、問題につながらない場合、これは当然のことながら、サーバーの唯一の許容できる動作です。"
    },
    {
      "indent": 3,
      "text": "CLIENT                                                     SERVER\n  |                                                          |\n  | CON [MID=1234], PUT, /options, 1:0/1/128    ------>      |\n  |                                                          |\n  | <------   ACK [MID=1234], 2.04 Changed, 1:0/0/128        |\n  |                                                          |\n  | CON [MID=1235], PUT, /options, 1:1/1/128    ------>      |\n  |                                                          |\n  | <------   ACK [MID=1235], 2.04 Changed, 1:1/0/128        |\n  |                                                          |\n  | CON [MID=1236], PUT, /options, 1:2/0/128    ------>      |\n  |                                                          |\n  | <------   ACK [MID=1236], 2.04 Changed, 1:2/0/128        |",
      "raw": true
    },
    {
      "indent": 17,
      "text": "Figure 8: Simple Stateless Block-Wise PUT",
      "ja": "図8：単純なステートレスブロック単位のPUT"
    },
    {
      "indent": 3,
      "text": "Finally, a server receiving a block-wise PUT or POST may want to indicate a smaller block size preference (Figure 9). In this case, the client SHOULD continue with a smaller block size; if it does, it MUST adjust the block number to properly count in that smaller size.",
      "ja": "最後に、受信サーバは、ブロックワイズPUTまたはPOSTは、より小さなブロックサイズ優先（図9）を指示することができます。この場合、クライアントは、より小さなブロックサイズを継続すべきです。それがない場合は、それが適切にその小さなサイズにカウントするブロックの数を調整しなければなりません。"
    },
    {
      "indent": 3,
      "text": "CLIENT                                                     SERVER\n  |                                                          |\n  | CON [MID=1234], PUT, /options, 1:0/1/128    ------>      |\n  |                                                          |\n  | <------   ACK [MID=1234], 2.31 Continue, 1:0/1/32        |\n  |                                                          |\n  | CON [MID=1235], PUT, /options, 1:4/1/32     ------>      |\n  |                                                          |\n  | <------   ACK [MID=1235], 2.31 Continue, 1:4/1/32        |\n  |                                                          |\n  | CON [MID=1236], PUT, /options, 1:5/1/32     ------>      |\n  |                                                          |\n  | <------   ACK [MID=1235], 2.31 Continue, 1:5/1/32        |\n  |                                                          |\n  | CON [MID=1237], PUT, /options, 1:6/0/32     ------>      |\n  |                                                          |\n  | <------   ACK [MID=1236], 2.04 Changed, 1:6/0/32         |",
      "raw": true
    },
    {
      "indent": 10,
      "text": "Figure 9: Simple Atomic Block-Wise PUT with Negotiation",
      "ja": "図9：交渉したシンプルなアトミックブロック単位のPUT"
    },
    {
      "indent": 0,
      "text": "3.3. Combining Block1 and Block2",
      "section_title": true,
      "ja": "3.3。ブロック1とブロック2を組み合わせます"
    },
    {
      "indent": 3,
      "text": "Block options may be used in both directions of a single exchange. The following example demonstrates a block-wise POST request, resulting in a separate block-wise response.",
      "ja": "ブロックオプションは、単一の交換の両方向に使用することができます。次の例では、別個のブロック単位の応答が得られ、ブロック単位のPOSTリクエストを示しています。"
    },
    {
      "indent": 3,
      "text": "CLIENT                                                     SERVER\n  |                                                              |\n  | CON [MID=1234], POST, /soap, 1:0/1/128      ------>          |\n  |                                                              |\n  | <------   ACK [MID=1234], 2.31 Continue, 1:0/1/128           |\n  |                                                              |\n  | CON [MID=1235], POST, /soap, 1:1/1/128      ------>          |\n  |                                                              |\n  | <------   ACK [MID=1235], 2.31 Continue, 1:1/1/128           |\n  |                                                              |\n  | CON [MID=1236], POST, /soap, 1:2/0/128      ------>          |\n  |                                                              |\n  | <------   ACK [MID=1236], 2.04 Changed, 2:0/1/128, 1:2/0/128 |\n  |                                                              |\n  | CON [MID=1237], POST, /soap, 2:1/0/128      ------>          |\n  | (no payload for requests with Block2 with NUM != 0)          |\n  | (could also do late negotiation by requesting,               |\n  |  e.g., 2:2/0/64)                                             |\n  |                                                              |\n  | <------   ACK [MID=1237], 2.04 Changed, 2:1/1/128            |\n  |                                                              |\n  | CON [MID=1238], POST, /soap, 2:2/0/128      ------>          |\n  |                                                              |\n  | <------   ACK [MID=1238], 2.04 Changed, 2:2/1/128            |\n  |                                                              |\n  | CON [MID=1239], POST, /soap, 2:3/0/128      ------>          |\n  |                                                              |\n  | <------   ACK [MID=1239], 2.04 Changed, 2:3/0/128            |",
      "raw": true
    },
    {
      "indent": 8,
      "text": "Figure 10: Atomic Block-Wise POST with Block-Wise Response",
      "ja": "図10：ブロック単位のレスポンスとアトミックブロック単位POST"
    },
    {
      "indent": 3,
      "text": "This model does provide for early negotiation input to the Block2 block-wise transfer, as shown below.",
      "ja": "下記に示すように、このモデルは、ブロック2ブロック単位の転送に早期の交渉入力を提供しません。"
    },
    {
      "indent": 3,
      "text": "CLIENT                                                     SERVER\n  |                                                              |\n  | CON [MID=1234], POST, /soap, 1:0/1/128 ------>               |\n  |                                                              |\n  | <------   ACK [MID=1234], 2.31 Continue, 1:0/1/128           |\n  |                                                              |\n  | CON [MID=1235], POST, /soap, 1:1/1/128 ------>               |\n  |                                                              |\n  | <------   ACK [MID=1235], 2.31 Continue, 1:1/1/128           |\n  |                                                              |\n  | CON [MID=1236], POST, /soap, 1:2/0/128, 2:0/0/64 ------>     |\n  |                                                              |\n  | <------   ACK [MID=1236], 2.04 Changed, 1:2/0/128, 2:0/1/64  |\n  |                                                              |\n  | CON [MID=1237], POST, /soap, 2:1/0/64      ------>           |\n  | (no payload for requests with Block2 with NUM != 0)          |\n  |                                                              |\n  | <------   ACK [MID=1237], 2.04 Changed, 2:1/1/64             |\n  |                                                              |\n  | CON [MID=1238], POST, /soap, 2:2/0/64      ------>           |\n  |                                                              |\n  | <------   ACK [MID=1238], 2.04 Changed, 2:2/1/64             |\n  |                                                              |\n  | CON [MID=1239], POST, /soap, 2:3/0/64      ------>           |\n  |                                                              |\n  | <------   ACK [MID=1239], 2.04 Changed, 2:3/0/64             |",
      "raw": true
    },
    {
      "indent": 8,
      "text": "Figure 11: Atomic Block-Wise POST with Block-Wise Response,\n                     Early Negotiation",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.4. Combining Observe and Block2",
      "section_title": true,
      "ja": "3.4。観察し、ブロック2の組み合わせ"
    },
    {
      "indent": 3,
      "text": "In the following example, the server first sends a direct response (Observe sequence number 62350) to the initial GET request (the resulting block-wise transfer is as in Figure 4 and has therefore been left out). The second transfer is started by a 2.05 notification that contains just the first block (Observe sequence number 62354); the client then goes on to obtain the rest of the blocks.",
      "ja": "次の例では、サーバは、最初の初期のGET要求に直接応答は、（シーケンス番号62350を観察）（得られたブロック単位の転送は、図4のようであるので、除外されている）を送信します。第二の転送がちょうど最初のブロック（シーケンス番号62354を観察）を含む2.05通知によって開始されます。次に、クライアントは、ブロックの残りの部分を取得するために行きます。"
    },
    {
      "indent": 7,
      "text": "CLIENT  SERVER\n  |      |\n  +----->|     Header: GET 0x41011636\n  | GET  |      Token: 0xfb\n  |      |   Uri-Path: status-icon\n  |      |    Observe: (empty)\n  |      |\n  |<-----+     Header: 2.05 0x61451636\n  | 2.05 |      Token: 0xfb\n  |      |     Block2: 0/1/128\n  |      |    Observe: 62350\n  |      |       ETag: 6f00f38e\n  |      |    Payload: [128 bytes]\n  |      |\n  |      |  (Usual GET transfer left out)\n    ...\n  |      |  (Notification of first block)\n  |      |\n  |<-----+     Header: 2.05 0x4145af9c\n  | 2.05 |      Token: 0xfb\n  |      |     Block2: 0/1/128\n  |      |    Observe: 62354\n  |      |       ETag: 6f00f392\n  |      |    Payload: [128 bytes]\n  |      |\n  +- - ->|     Header: 0x6000af9c\n  |      |\n  |      |  (Retrieval of remaining blocks)\n  |      |\n  +----->|     Header: GET 0x41011637\n  | GET  |      Token: 0xfc\n  |      |   Uri-Path: status-icon\n  |      |     Block2: 1/0/128\n  |      |\n  |<-----+     Header: 2.05 0x61451637\n  | 2.05 |      Token: 0xfc\n  |      |     Block2: 1/1/128\n  |      |       ETag: 6f00f392\n  |      |    Payload: [128 bytes]\n  |      |\n  +----->|     Header: GET 0x41011638\n  | GET  |      Token: 0xfc\n  |      |   Uri-Path: status-icon\n  |      |     Block2: 2/0/128\n  |      |",
      "raw": true
    },
    {
      "indent": 9,
      "text": "|<-----+     Header: 2.05 0x61451638\n| 2.05 |      Token: 0xfc\n|      |     Block2: 2/0/128\n|      |       ETag: 6f00f392\n|      |    Payload: [53 bytes]",
      "raw": true
    },
    {
      "indent": 11,
      "text": "Figure 12: Observe Sequence with Block-Wise Response",
      "ja": "図12：ブロック単位のレスポンスと順序を守って"
    },
    {
      "indent": 3,
      "text": "(Note that the choice of token 0xfc in this example is arbitrary; tokens are just shown in this example to illustrate that the requests for additional blocks cannot make use of the token of the Observation relationship. As a general comment on tokens, there is no other mention of tokens in this document, as block-wise transfers handle tokens like any other CoAP exchange. As usual, the client is free to choose tokens for each exchange as it likes.)",
      "ja": "（この例では、トークン0xfcの選択は任意であることに注意してくださいません。トークンは、単に追加のブロックに対する要求が観測関係のトークンを利用することができないことを示すために、この例に示されているトークンに関する一般的な意見としては、何があります。ブロック単位の転送など、この文書内のトークンの他の言及は、他のどのCoAP交換などのトークンを処理します。いつものように、クライアントはそれが好きで、各交換のためのトークンを自由に選択することができます。）"
    },
    {
      "indent": 3,
      "text": "In the following example, the client also uses early negotiation to limit the block size to 64 bytes.",
      "ja": "次の例では、クライアントは、64バイトにブロックサイズを制限するために、早期に交渉を使用しています。"
    },
    {
      "indent": 7,
      "text": "CLIENT  SERVER\n  |      |\n  +----->|     Header: GET 0x41011636\n  | GET  |      Token: 0xfb\n  |      |   Uri-Path: status-icon\n  |      |    Observe: (empty)\n  |      |     Block2: 0/0/64\n  |      |\n  |<-----+     Header: 2.05 0x61451636\n  | 2.05 |      Token: 0xfb\n  |      |     Block2: 0/1/64\n  |      |    Observe: 62350\n  |      |       ETag: 6f00f38e\n  |      |    Max-Age: 60\n  |      |    Payload: [64 bytes]\n  |      |\n  |      |  (Usual GET transfer left out)\n    ...\n  |      |  (Notification of first block)\n  |      |\n  |<-----+     Header: 2.05 0x4145af9c\n  | 2.05 |      Token: 0xfb\n  |      |     Block2: 0/1/64\n  |      |    Observe: 62354\n  |      |       ETag: 6f00f392\n  |      |    Payload: [64 bytes]\n  |      |",
      "raw": true
    },
    {
      "indent": 9,
      "text": "+- - ->|     Header: 0x6000af9c\n|      |\n|      |  (Retrieval of remaining blocks)\n|      |\n+----->|     Header: GET 0x41011637\n| GET  |      Token: 0xfc\n|      |   Uri-Path: status-icon\n|      |     Block2: 1/0/64\n|      |\n|<-----+     Header: 2.05 0x61451637\n| 2.05 |      Token: 0xfc\n|      |     Block2: 1/1/64\n|      |       ETag: 6f00f392\n|      |    Payload: [64 bytes]\n  ....\n|      |\n+----->|     Header: GET 0x41011638\n| GET  |      Token: 0xfc\n|      |   Uri-Path: status-icon\n|      |     Block2: 4/0/64\n|      |\n|<-----+     Header: 2.05 0x61451638\n| 2.05 |      Token: 0xfc\n|      |     Block2: 4/0/64\n|      |       ETag: 6f00f392\n|      |    Payload: [53 bytes]",
      "raw": true
    },
    {
      "indent": 12,
      "text": "Figure 13: Observe Sequence with Early Negotiation",
      "ja": "図13：早期交渉で順序を守って"
    },
    {
      "indent": 0,
      "text": "4. The Size2 and Size1 Options",
      "section_title": true,
      "ja": "4. SIZE2とサイズ1のオプション"
    },
    {
      "indent": 3,
      "text": "In many cases when transferring a large resource representation block by block, it is advantageous to know the total size early in the process. Some indication may be available from the maximum size estimate attribute \"sz\" provided in a resource description [RFC6690]. However, the size may vary dynamically, so a more up-to-date indication may be useful.",
      "ja": "ブロックにより大きなリソース表現のブロックを転送するとき、多くの場合には、プロセスの初期合計サイズを知ることが有利です。いくつかの指標は、リソース記述[RFC6690]に提供される最大サイズ推定属性「SZ」から入手可能です。しかし、サイズが動的に変化することができるので、より最新の表示が有用であり得ます。"
    },
    {
      "indent": 3,
      "text": "This specification defines two CoAP options, Size1 for indicating the size of the representation transferred in requests, and Size2 for indicating the size of the representation transferred in responses. (Size1 has already been defined in Section 5.10.9 of [RFC7252] to provide \"size information about the resource representation in a request\"; however, that section only details the narrow case of indicating in 4.13 responses the maximum size of request payload that the server is able and willing to handle. The present specification provides details about its use as a request option as well.)",
      "ja": "この仕様は、応答で転送表現のサイズを指示するための要求で転送表現のサイズを示すための2つのCoAPオプション、サイズ1を定義、およびSIZE2。 （サイズ1は既に「要求にリソース表現に関するサイズ情報」を提供する[RFC7252]のセクション5.10.9に規定されているが、そのセクションは、4.13応答で要求ペイロードの最大サイズを示す狭い場合を詳述することサーバができ、取り扱いしていく所存です。なお、本明細書も同様に要求オプションとしての使用に関する詳細を提供します。）"
    },
    {
      "indent": 3,
      "text": "The Size2 Option may be used for two purposes:",
      "ja": "SIZE2オプションは、次の2つの目的のために使用することができます。"
    },
    {
      "indent": 3,
      "text": "o In a request, to ask the server to provide a size estimate along with the usual response (\"size request\"). For this usage, the value MUST be set to 0.",
      "ja": "リクエスト中のO、通常の応答（「サイズ要求」）と一緒にサイズの見積もりを提供するために、サーバーを依頼します。この使用方法については、値は0に設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o In a response carrying a Block2 Option, to indicate the current estimate the server has of the total size of the resource representation, measured in bytes (\"size indication\").",
      "ja": "Oブロック2オプションを運ぶ応答して、サーバは合計バイト数で測定されたリソース表現のサイズ、（「サイズ表示」）を有する現在の推定値を示すことができます。"
    },
    {
      "indent": 3,
      "text": "Similarly, the Size1 Option may be used for two purposes:",
      "ja": "同様に、サイズ1のオプションは、2つの目的のために使用することができます。"
    },
    {
      "indent": 3,
      "text": "o In a request carrying a Block1 Option, to indicate the current estimate the client has of the total size of the resource representation, measured in bytes (\"size indication\").",
      "ja": "Oブロック1オプションを保有する要求では、クライアントは合計バイト数で測定されたリソース表現のサイズ、（「サイズ表示」）を有する現在の推定値を示すことができます。"
    },
    {
      "indent": 3,
      "text": "o In a 4.13 response, to indicate the maximum size that would have been acceptable [RFC7252], measured in bytes.",
      "ja": "Oバイト単位に許容される[RFC7252]であったであろう最大サイズを示すために4.13応答して。"
    },
    {
      "indent": 3,
      "text": "Apart from conveying/asking for size information, the Size options have no other effect on the processing of the request or response. If the client wants to minimize the size of the payload in the resulting response, it should add a Block2 Option to the request with a small block size (e.g., setting SZX=0).",
      "ja": "別にサイズ情報を要求/搬送から、サイズオプションは、要求または応答の処理に他の影響を与えません。クライアントが得られた応答ペイロードのサイズを最小化したい場合、それは（例えば、SZX = 0を設定）小ブロックサイズの要求にブロック2のオプションを追加しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The Size options are \"elective\", i.e., a client MUST be prepared for the server to ignore the size estimate request. Either Size option MUST NOT occur more than once in a single message.",
      "ja": "サイズオプションは、すなわち、クライアントがサイズの見積り依頼を無視するサーバーのために準備しなければなりません、「選択科目」です。どちらのサイズのオプションは、単一のメッセージに複数回発生してはなりません。"
    },
    {
      "indent": 8,
      "text": "+-----+---+---+---+---+-------+--------+--------+---------+\n| No. | C | U | N | R | Name  | Format | Length | Default |\n+-----+---+---+---+---+-------+--------+--------+---------+\n|  60 |   |   | x |   | Size1 | uint   |    0-4 | (none)  |\n|     |   |   |   |   |       |        |        |         |\n|  28 |   |   | x |   | Size2 | uint   |    0-4 | (none)  |\n+-----+---+---+---+---+-------+--------+--------+---------+",
      "raw": true
    },
    {
      "indent": 23,
      "text": "Table 2: Size Option Numbers",
      "ja": "表2：サイズオプション番号"
    },
    {
      "indent": 3,
      "text": "Implementation Notes:",
      "ja": "実装上の注意："
    },
    {
      "indent": 3,
      "text": "o As a quality of implementation consideration, block-wise transfers for which the total size considerably exceeds the size of one block are expected to include size indications, whenever those can be provided without undue effort (preferably with the first block exchanged). If the size estimate does not change, the indication does not need to be repeated for every block.",
      "ja": "O実装の考慮の品質として、合計サイズが大幅つのブロックのサイズを超えているブロック単位の転送はサイズ指示を含むことが期待され、それらは、過度の努力なしで提供することができるたびに（好ましくは、最初のブロックを交換して）。サイズ推定値は変更されない場合は、表示はブロックごとに繰り返す必要はありません。"
    },
    {
      "indent": 3,
      "text": "o The end of a block-wise transfer is governed by the M bits in the Block options, _not_ by exhausting the size estimates exchanged.",
      "ja": "Oブロック単位の転送の終了は、ブロックオプションで、_not_推定値は交換サイズを排出することによってMビットによって支配されます。"
    },
    {
      "indent": 3,
      "text": "o As usual for an option of type uint, the value 0 is best expressed as an empty option (0 bytes). There is no default value for either Size option.",
      "ja": "O型UINTのオプション、値0として、通常は、最良の空のオプション（0バイト）として表現されます。いずれかのサイズのオプションのデフォルト値はありません。"
    },
    {
      "indent": 3,
      "text": "o The Size options are neither critical nor unsafe, and are marked as No-Cache-Key.",
      "ja": "Oサイズのオプションは、重要でも安全ではないでもない、とキャッシュなしキーとしてマークされています。"
    },
    {
      "indent": 0,
      "text": "5. HTTP-Mapping Considerations",
      "section_title": true,
      "ja": "5. HTTP-マッピングの考慮事項"
    },
    {
      "indent": 3,
      "text": "In this subsection, we give some brief examples of the influence that the Block options might have on intermediaries that map between CoAP and HTTP.",
      "ja": "このサブセクションでは、我々は、ブロックのオプションがCoAPとHTTPの間のマッピングの仲介に持っているかもしれないという影響のいくつかの簡単な例を与えます。"
    },
    {
      "indent": 3,
      "text": "For mapping CoAP requests to HTTP, the intermediary may want to map the sequence of block-wise transfers into a single HTTP transfer. For example, for a GET request, the intermediary could perform the HTTP request once the first block has been requested and could then fulfill all further block requests out of its cache. A constrained implementation may not be able to cache the entire object and may use a combination of TCP flow control and (in particular if timeouts occur) HTTP range requests to obtain the information necessary for the next block transfer at the right time.",
      "ja": "HTTPにマッピングするCoAP要求の場合、仲介者は、単一のHTTP転送にブロック単位の転送のシーケンスをマッピングすることもできます。例えば、GETリクエストのために、仲介者は最初のブロックが要求された後、HTTPリクエストを行うことができ、その後、そのキャッシュのうち、すべての更なるブロック要求を満たすことができます。制約された実装では、オブジェクト全体をキャッシュすることができないかもしれないと（タイムアウトが発生した場合に特に）適切なタイミングで次のブロックの転送に必要な情報を取得するためにHTTP範囲要求をTCPフロー制御の組み合わせを使用することができます。"
    },
    {
      "indent": 3,
      "text": "For PUT or POST requests, historically there was more variation in how HTTP servers might implement ranges; recently, [RFC7233] has defined that Range header fields received with a request method other than GET are not to be interpreted. So, in general, the CoAP-to-HTTP intermediary will have to try sending the payload of all the blocks of a block-wise transfer for these other methods within one HTTP request. If enough buffering is available, this request can be started when the last CoAP block is received. A constrained implementation may want to relieve its buffering by already starting to send the HTTP request at the time the first CoAP block is received; any HTTP 408 status code that indicates that the HTTP server became impatient with the resulting transfer can then be mapped into a CoAP 4.08 response code (similarly, 413 maps to 4.13).",
      "ja": "PUTやPOSTリクエストの場合、歴史的にHTTPサーバは範囲を実装する方法を、よりばらつきがありました。最近、[RFC7233]はRangeヘッダフィールドが解釈されるべきではなく、GET以外の要求の方法で受信することを定義しています。だから、一般的には、CoAPツーHTTPの仲介は、1つのHTTPリクエスト内のこれらの他のメソッドのブロック単位の転送のすべてのブロックのペイロードを送信してくださいする必要があります。十分なバッファリングが使用可能な場合は、最後のCoAPブロックを受信したときに、この要求を開始することができます。制約の実装は、すでに最初のCoAPブロックが受信された時点でのHTTPリクエストを送信するために開始することにより、そのバッファリングを軽減することができます。 HTTPサーバは、結果の転送とせっかちになったことを示す任意のHTTP 408ステータスコードは、CoAP 4.08応答コード（4.13と同様に、413のマップ）にマッピングすることができます。"
    },
    {
      "indent": 3,
      "text": "For mapping HTTP to CoAP, the intermediary may want to map a single HTTP transfer into a sequence of block-wise transfers. If the HTTP client is too slow delivering a request body on a PUT or POST, the CoAP server might time out and return a 4.08 response code, which in turn maps well to an HTTP 408 status code (again, 4.13 maps to 413). HTTP range requests received on the HTTP side may be served out of a cache and/or mapped to GET requests that request a sequence of blocks that cover the range.",
      "ja": "CoAPにマッピングするHTTPの場合は、仲介者は、ブロック単位の転送のシーケンスに単一のHTTP転送をマッピングすることもできます。 HTTPクライアントは、PUTやPOSTでリクエストボディを実現遅すぎる場合、CoAPサーバがタイムアウトし、今度はHTTP 408ステータスコード（413に再び、4.13マップ）にもマップさ4.08レスポンスコードを、返すことがあります。 HTTP側で受信したHTTP範囲要求はキャッシュから配信及び/又は範囲をカバーするブロックのシーケンスを要求するリクエストを取得するためにマッピングされてもよいです。"
    },
    {
      "indent": 3,
      "text": "(Note that, while the semantics of CoAP 4.08 and HTTP 408 differ, this difference is largely due to the different way the two protocols are mapped to transport. HTTP has an underlying TCP connection, which supplies connection state, so an HTTP 408 status code can immediately be used to indicate that a timeout occurred during transmitting a request through that active TCP connection. The CoAP 4.08 response code indicates one or more missing blocks, which may be due to timeouts or resource constraints; as there is no connection state, there is no way to deliver such a response immediately; instead, it is delivered on the next block transfer. Still, HTTP 408 is probably the best mapping back to HTTP, as the timeout is the most likely cause for a CoAP 4.08. Note that there is no way to distinguish a timeout from a missing block for a server without creating additional state, the need for which we want to avoid.)",
      "ja": "（CoAP 4.08のセマンティクスとHTTP 408は異なるが、なお、この差は、主として2つのプロトコルがトランスポートにマッピングされる別の方法である。HTTP接続状態を供給する下層のTCPコネクション、そうHTTP 408のステータスコードを有します直ちにタイムアウトがそのアクティブTCP接続を介して要求を送信中に発生したことを示すために使用することができるCoAP 4.08応答コードが原因タイムアウトまたはリソース制約のためであってもよい、一つ以上の失われたブロックを示し;は接続状態が存在しないように、そこすぐにこのような応答を提供する方法はありません。代わりに、それは次のブロック転送に配信され、タイムアウトがCoAP 4.08のための最も可能性の高い原因であるとはいえ、HTTP 408は、おそらく戻ってHTTPに最良のマッピングであることに注意してくださいが。追加の状態、我々は避けたい対象の必要性を作成せずにサーバーの欠落ブロックからのタイムアウトを区別する方法はありません。）"
    },
    {
      "indent": 0,
      "text": "6. IANA Considerations",
      "section_title": true,
      "ja": "6. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document adds the following option numbers to the \"CoAP Option Numbers\" registry defined by [RFC7252]:",
      "ja": "この文書では、[RFC7252]で定義された「CoAPオプション番号」レジストリに次のオプション番号を追加します。"
    },
    {
      "indent": 22,
      "text": "+--------+--------+-----------+\n| Number | Name   | Reference |\n+--------+--------+-----------+\n| 23     | Block2 | RFC 7959  |\n|        |        |           |\n| 27     | Block1 | RFC 7959  |\n|        |        |           |\n| 28     | Size2  | RFC 7959  |\n+--------+--------+-----------+",
      "raw": true
    },
    {
      "indent": 23,
      "text": "Table 3: CoAP Option Numbers",
      "ja": "表3：CoAPオプション番号"
    },
    {
      "indent": 3,
      "text": "This document adds the following response codes to the \"CoAP Response Codes\" registry defined by [RFC7252]:",
      "ja": "この文書では、[RFC7252]で定義された「CoAP応答コード」レジストリに以下の応答コードを追加します。"
    },
    {
      "indent": 13,
      "text": "+------+---------------------------+-----------+\n| Code | Description               | Reference |\n+------+---------------------------+-----------+\n| 2.31 | Continue                  | RFC 7959  |\n|      |                           |           |\n| 4.08 | Request Entity Incomplete | RFC 7959  |\n+------+---------------------------+-----------+",
      "raw": true
    },
    {
      "indent": 23,
      "text": "Table 4: CoAP Response Codes",
      "ja": "表4：CoAP応答コード"
    },
    {
      "indent": 0,
      "text": "7. Security Considerations",
      "section_title": true,
      "ja": "7.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "Providing access to blocks within a resource may lead to surprising vulnerabilities. Where requests are not implemented atomically, an attacker may be able to exploit a race condition or confuse a server by inducing it to use a partially updated resource representation. Partial transfers may also make certain problematic data invisible to Intrusion Detection Systems (IDSs); it is RECOMMENDED that an IDS that analyzes resource representations transferred by CoAP implement the Block options to gain access to entire resource representations. Still, approaches such as transferring even-numbered blocks on one path and odd-numbered blocks on another path, or even transferring blocks multiple times with different content and obtaining a different interpretation of temporal order at the IDS than at the server, may prevent an IDS from seeing the whole picture. These kinds of attacks are well understood from IP fragmentation and TCP segmentation; CoAP does not add fundamentally new considerations.",
      "ja": "リソース内のブロックへのアクセスを提供することは驚くべき脆弱性につながる可能性があります。要求がアトミックに実装されていない場合は、攻撃者が競合状態を悪用したり、部分的に更新されたリソースの表現を使用するように誘導することにより、サーバーを混同することができるかもしれません。部分的な転送はまた、侵入検知システム（侵入検出システム）には見えない特定の問題のデータをすることができます。 CoAPによって転送されたリソース表現を解析IDS全体リソース表現へのアクセスをブロックするオプションを実装することが推奨されます。依然として、そのような別の経路上に一つの経路と奇数ブロックに対して偶数ブロックを転送する、あるいはブロックを転送複数回異なるコンテンツと、サーバよりもIDSで時間的順序の異なる解釈を得るように接近する、防止することができます全体像を見てから、IDS。攻撃のこれらの種類はよくIPフラグメンテーションとTCPセグメンテーションから理解されています。 CoAPは根本的に新しい考慮事項を追加しません。"
    },
    {
      "indent": 3,
      "text": "Where access to a resource is only granted to clients making use of specific security associations, all blocks of that resource MUST be subject to the same security checks; it MUST NOT be possible for unprotected exchanges to influence blocks of an otherwise protected resource. As a related consideration, where object security is employed, PUT/POST should be implemented in the atomic fashion, unless the object security operation is performed on each access and the creation of unusable resources can be tolerated. Future end-to-end security mechanisms that may be added to CoAP itself may have related security considerations, this includes considerations about caching of blocks in clients and in proxies (see Sections 2.10 and 5 for different strategies in performing this caching); these security considerations will need to be described in the specifications of those mechanisms.",
      "ja": "リソースへのアクセスは、特定のセキュリティアソシエーションを利用してクライアントに付与されている場合、そのリソースのすべてのブロックが同じセキュリティチェックの対象にする必要があります。保護されていない取引所がそうでなければ保護されたリソースのブロックに影響を与えることが可能にすることはできません。オブジェクトのセキュリティ動作が各アクセスに対して実行され、使用不可能なリソースの作成を許容することができない限り、オブジェクトのセキュリティが使用される関連する考察として、PUT / POSTは、アトミックな方法で実施されるべきです。 CoAP自体に添加することができる将来のエンドツーエンドのセキュリティメカニズムは、セキュリティ上の考慮事項に関連している可能性があり、これは（このキャッシングを実行する際に様々な戦略のためのセクション2.10及び5を参照）クライアントおよびプロキシ内のブロックのキャッシングについての考慮を含みます。これらのセキュリティ上の考慮事項は、それらのメカニズムの仕様書に記述する必要があります。"
    },
    {
      "indent": 3,
      "text": "A stateless server might be susceptible to an attack where the adversary sends a Block1 (e.g., PUT) block with a high block number: A naive implementation might exhaust its resources by creating a huge resource representation.",
      "ja": "ナイーブな実装では、巨大なリソース表現を作成することにより、そのリソースを使い果たす可能性がある：ステートレスサーバは、敵が高いブロック番号とブロック1（例えば、PUT）ブロックを送信する攻撃を受けやすいかもしれません。"
    },
    {
      "indent": 3,
      "text": "Misleading size indications may be used by an attacker to induce buffer overflows in poor implementations, for which the usual considerations apply.",
      "ja": "誤解を招くようなサイズの表示は、通常の考慮事項が適用される貧弱な実装において、バッファオーバーフローを誘発するために攻撃者によって使用されてもよいです。"
    },
    {
      "indent": 0,
      "text": "7.1. Mitigating Resource Exhaustion Attacks",
      "section_title": true,
      "ja": "7.1。資源枯渇の攻撃を緩和"
    },
    {
      "indent": 3,
      "text": "Certain block-wise requests may induce the server to create state, e.g., to create a snapshot for the block-wise GET of a fast-changing resource to enable consistent access to the same version of a resource for all blocks, or to create temporary resource representations that are collected until pressed into service by a final PUT or POST with the more bit unset. All mechanisms that induce a server to create state that cannot simply be cleaned up create opportunities for denial-of-service attacks. Servers SHOULD avoid being subject to resource exhaustion based on state created by untrusted sources. But even if this is done, the mitigation may cause a denial-of-service to a legitimate request when it is drowned out by other state-creating requests. Wherever possible, servers should therefore minimize the opportunities to create state for untrusted sources, e.g., by using stateless approaches.",
      "ja": "特定のブロック単位の要求は、すべてのブロックのためのリソースの同じバージョンへの一貫したアクセスを可能にするために、または一時的に作成するために、急速に変化するリソースのブロック単位GETのためのスナップショットを作成するには、例えば、状態を作成するには、サーバーを誘導することができます複数ビット解除有する最終PUTまたはPOSTによってサービスに押されるまで収集されるリソース表現。単にクリーンアップすることができない状態を作成するには、サーバーを誘発するすべてのメカニズムは、サービス拒否攻撃の機会を作成します。サーバーは信頼できないソースによって作成された状態に基づいて、枯渇資源を受けることは避けるべきです。これが行われた場合でもしかし、緩和策は、それが他の状態作成要求によってかき消される正当な要求にサービス拒否を引き起こす可能性があります。可能な限り、サーバは、従って、ステートレスなアプローチを用いて、例えば、信頼できないソースの状態を作成する機会を最小限にすべきです。"
    },
    {
      "indent": 3,
      "text": "Performing segmentation at the application layer is almost always better in this respect than at the transport layer or lower (IP fragmentation, adaptation-layer fragmentation), for instance, because there are application-layer semantics that can be used for mitigation or because lower layers provide security associations that can prevent attacks. However, it is less common to apply timeouts and keepalive mechanisms at the application layer than at lower layers. Servers MAY want to clean up accumulated state by timing it out (cf. response code 4.08), and clients SHOULD be prepared to run block-wise transfers in an expedient way to minimize the likelihood of running into such a timeout.",
      "ja": "緩和または下層ために使用することができるアプリケーション層のセマンティクスがあるので、アプリケーション層でセグメンテーションを行うこと、例えば、トランスポート層以下（IPフラグメンテーション、アダプテーション層フラグメンテーション）よりもこの点でほとんど常に良好です攻撃を防ぐことができますセキュリティアソシエーションを提供しています。しかし、下位層よりもアプリケーション層でタイムアウトとキープアライブ機構を適用することがあまり一般的です。サーバは（参照応答コード4.08）のそれをタイミングによって蓄積された状態をクリーンアップすることができ、クライアントは、そのようなタイムアウトに実行している可能性を最小限にするために好都合な方法でブロック単位の転送を実行するために準備する必要があります。"
    },
    {
      "indent": 0,
      "text": "7.2. Mitigating Amplification Attacks",
      "section_title": true,
      "ja": "7.2。増幅攻撃を軽減"
    },
    {
      "indent": 3,
      "text": "[RFC7252] discusses the susceptibility of CoAP endpoints for use in amplification attacks.",
      "ja": "[RFC7252]は、増幅攻撃に使用するためのCoAPエンドポイントの感受性を論じています。"
    },
    {
      "indent": 3,
      "text": "A CoAP server can reduce the amount of amplification it provides to an attacker by offering large resource representations only in relatively small blocks. With this, e.g., for a 1000-byte resource, a 10-byte request might result in an 80-byte response (with a 64-byte block) instead of a 1016-byte response, considerably reducing the amplification provided.",
      "ja": "CoAPサーバは、比較的小さなブロックで大きなリソース表現を提供することによって、それが攻撃者に提供する増幅量を低減することができます。これにより、例えば、1000バイトのリソースに対して、10バイトの要求はかなり提供される増幅を減少させる代わりに、1016バイトの応答（64バイトブロックを有する）80バイトの応答をもたらすかもしれません。"
    },
    {
      "indent": 0,
      "text": "8. References",
      "section_title": true,
      "ja": "8.参照文献"
    },
    {
      "indent": 0,
      "text": "8.1. Normative References",
      "section_title": true,
      "ja": "8.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<http://www.rfc-editor.org/info/ RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC7252] Shelby, Z., Hartke, K., and C. Bormann, \"The Constrained Application Protocol (CoAP)\", RFC 7252, DOI 10.17487/RFC7252, June 2014, <http://www.rfc-editor.org/info/rfc7252>.",
      "ja": "[RFC7252]シェルビー、Z.、HARTKE、K.、およびC.ボルマン、 \"制約アプリケーションプロトコル（CoAP）\"、RFC 7252、DOI 10.17487 / RFC7252、2014年6月、<HTTP：//www.rfc-editor。組織/情報/ rfc7252>。"
    },
    {
      "indent": 3,
      "text": "[RFC7641] Hartke, K., \"Observing Resources in the Constrained Application Protocol (CoAP)\", RFC 7641, DOI 10.17487/RFC7641, September 2015, <http://www.rfc-editor.org/info/rfc7641>.",
      "ja": "[RFC7641] HARTKE、K.、 \"制約アプリケーションプロトコル（CoAP）で観測資源\"、RFC 7641、DOI 10.17487 / RFC7641、2015年9月、<http://www.rfc-editor.org/info/rfc7641>。"
    },
    {
      "indent": 0,
      "text": "8.2. Informative References",
      "section_title": true,
      "ja": "8.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[REST] Fielding, R., \"Architectural Styles and the Design of Network-based Software Architectures\", Ph.D. Dissertation, University of California, Irvine, 2000, <http://www.ics.uci.edu/~fielding/pubs/dissertation/ fielding_dissertation.pdf>.",
      "ja": "[REST]フィールディング、R.、「建築スタイルとネットワークベースのソフトウェアアーキテクチャの設計」、博士論文、カリフォルニア大学アーバイン校、2000年、<http://www.ics.uci.edu/~fielding/pubs/dissertation/ fielding_dissertation.pdf>。"
    },
    {
      "indent": 3,
      "text": "[RFC4919] Kushalnagar, N., Montenegro, G., and C. Schumacher, \"IPv6 over Low-Power Wireless Personal Area Networks (6LoWPANs): Overview, Assumptions, Problem Statement, and Goals\", RFC 4919, DOI 10.17487/RFC4919, August 2007, <http://www.rfc-editor.org/info/rfc4919>.",
      "ja": "[RFC4919]クシャルナガル、N.、モンテネグロ、G.、およびC.シューマッハ、 \"低消費電力無線パーソナルエリアネットワーク上のIPv6（6LoWPANs）：概要、仮定、問題文、および目標\"、RFC 4919、DOI 10.17487 / RFC4919 2007年8月、<http://www.rfc-editor.org/info/rfc4919>。"
    },
    {
      "indent": 3,
      "text": "[RFC4944] Montenegro, G., Kushalnagar, N., Hui, J., and D. Culler, \"Transmission of IPv6 Packets over IEEE 802.15.4 Networks\", RFC 4944, DOI 10.17487/RFC4944, September 2007, <http://www.rfc-editor.org/info/rfc4944>.",
      "ja": "[RFC4944]モンテネグロ、G.、クシャルナガル、N.、ホイ、J.、およびD. Culler、 \"IEEEの上のIPv6パケットのトランスミッション802.15.4ネットワーク\"、RFC 4944、DOI 10.17487 / RFC4944、2007年9月、<のhttp： //www.rfc-editor.org/info/rfc4944>。"
    },
    {
      "indent": 3,
      "text": "[RFC6690] Shelby, Z., \"Constrained RESTful Environments (CoRE) Link Format\", RFC 6690, DOI 10.17487/RFC6690, August 2012, <http://www.rfc-editor.org/info/rfc6690>.",
      "ja": "[RFC6690]シェルビー、Z.、 \"制約RESTfulな環境（コア）リンク・フォーマット\"、RFC 6690、DOI 10.17487 / RFC6690、2012年8月、<http://www.rfc-editor.org/info/rfc6690>。"
    },
    {
      "indent": 3,
      "text": "[RFC7228] Bormann, C., Ersue, M., and A. Keranen, \"Terminology for Constrained-Node Networks\", RFC 7228, DOI 10.17487/RFC7228, May 2014, <http://www.rfc-editor.org/info/rfc7228>.",
      "ja": "[RFC7228]ボルマン、C.、Ersue、M.、およびA. Keranen、 \"制約ノードのネットワークのための用語\"、RFC 7228、DOI 10.17487 / RFC7228、2014年5月、<http://www.rfc-editor.org /情報/ rfc7228>。"
    },
    {
      "indent": 3,
      "text": "[RFC7230] Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing\", RFC 7230, DOI 10.17487/RFC7230, June 2014, <http://www.rfc-editor.org/info/rfc7230>.",
      "ja": "[RFC7230]フィールディング、R.、エド。及びJ. Reschke、編、 \"ハイパーテキスト転送プロトコル（HTTP / 1.1）：メッセージの構文およびルーティング\"、RFC 7230、DOI 10.17487 / RFC7230、2014年6月、<http://www.rfc-editor.org/info/ rfc7230>。"
    },
    {
      "indent": 3,
      "text": "[RFC7233] Fielding, R., Ed., Lafon, Y., Ed., and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Range Requests\", RFC 7233, DOI 10.17487/RFC7233, June 2014, <http://www.rfc-editor.org/info/rfc7233>.",
      "ja": "[RFC7233]フィールディング、R.、エド、ラフォン、Y.、エド、及びJ. Reschke、編、 \"ハイパーテキスト転送プロトコル（HTTP / 1.1）：範囲要求\"。。。、RFC 7233、DOI 10.17487 / RFC7233 6月2014年、<http://www.rfc-editor.org/info/rfc7233>。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Much of the content of this document is the result of discussions with the [RFC7252] authors, and via many CoRE WG discussions.",
      "ja": "このドキュメントの内容の多くは、[RFC7252]著者との協議の結果であり、そして多くのコアWGでの議論を通じて。"
    },
    {
      "indent": 3,
      "text": "Charles Palmer provided extensive editorial comments to a previous draft version of this document, some of which have been covered in this document. Esko Dijk reviewed a more recent version, leading to a number of further editorial improvements, a solution to the 4.13 ambiguity problem, and the section about combining Block and multicast (Section 2.8). Markus Becker proposed getting rid of an ill-conceived default value for the Block2 and Block1 Options. Peter Bigot insisted on a more systematic coverage of the options and response code. Qin Wu provided a review for the IETF Operations directorate, and Goeran Selander commented on the security considerations.",
      "ja": "チャールズ・パーマーは、この文書でカバーされているそのうちのいくつかは、このドキュメントの以前のドラフト版に大規模な編集コメントを提供しました。エスコダイクはさらに社説多くの改良、4.13曖昧さの問題を解決し、ブロックおよびマルチキャスト（2.8節）を組み合わせに関するセクションにつながる、より新しいバージョンを検討しました。マルクス・ベッカーは、ブロック2とブロック1のオプションのための悪い考えのデフォルト値を取り払う提案しました。ピーター・ビゴはオプションと応答コードのより体系的なカバレッジを主張しました。秦呉は、IETFの操作総局のレビューを提供し、Goeran Selanderは、セキュリティ上の考慮事項についてコメントしました。"
    },
    {
      "indent": 3,
      "text": "Kepeng Li, Linyi Tian, and Barry Leiba wrote up an early version of the Size option, which is described in this document. Klaus Hartke wrote some of the text describing the interaction of Block2 with Observe. Matthias Kovatsch provided a number of significant simplifications of the protocol.",
      "ja": "Kepeng李、臨沂市天、そしてバリー・レイバは、本書に記載されているサイズオプションの初期バージョンを書きました。クラウスHARTKEは観察とブロック2との相互作用を記述したテキストの一部を書きました。マティアスKovatschプロトコルの著しい単純化の数を提供しました。"
    },
    {
      "indent": 3,
      "text": "The IESG reviewers provided very useful comments. Spencer Dawkins even suggested new text. He and Mirja Kuehlewind insisted on more explicit information about the layering of block-wise transfers on top of the base protocol. Ben Campbell helped untangle some MUST/ SHOULD soup. Comments by Alexey Melnikov, as well as the Gen-ART review by Jouni Korhonen, resulted in further improvements to the text.",
      "ja": "IESGのレビューアは非常に有益なコメントを提供しました。スペンサードーキンスも、新しいテキストを示唆しました。彼とMirja Kuehlewindは基本プロトコルの上にブロック単位の転送の積層についてのより明示的な情報を主張しました。ベン・キャンベルは、いくつかのMUST / SHOULDスープを解く助けました。 Jouni Korhonenによってアレクセイ・メルニコフのコメントと同様に、ジェン・ARTのレビューは、テキストへの更なる改善をもたらし。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Carsten Bormann Universitaet Bremen TZI Postfach 330440 Bremen D-28359 Germany",
      "ja": "カルステンボルマンUniversitaetブレーメンTZI POSTFACH 330440 D-28359ブレーメンドイツ"
    },
    {
      "indent": 3,
      "text": "Phone: +49-421-218-63921 Email: cabo@tzi.org",
      "ja": "電話：+ 49-421-218-63921 Eメール：cabo@tzi.org"
    },
    {
      "indent": 3,
      "text": "Zach Shelby (editor) ARM 150 Rose Orchard San Jose, CA 95134 United States of America",
      "ja": "ザックシェルビー（エディタ）ARM 150アメリカのローズオーチャードサンノゼ、CA 95134米国"
    },
    {
      "indent": 3,
      "text": "Phone: +1-408-203-9434 Email: zach.shelby@arm.com",
      "ja": "電話：+ 1-408-203-9434 Eメール：zach.shelby@arm.com"
    }
  ]
}