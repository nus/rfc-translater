{
  "title": {
    "text": "RFC 7046 - A Common API for Transparent Hybrid Multicast",
    "ja": "RFC 7046 - 透明ハイブリッドマルチキャストのための共通API"
  },
  "number": 7046,
  "created_at": "2019-10-28 00:19:06.676486+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Research Task Force (IRTF)                         M. Waehlisch\nRequest for Comments: 7046                          link-lab & FU Berlin\nCategory: Experimental                                        T. Schmidt\nISSN: 2070-1721                                              HAW Hamburg\n                                                               S. Venaas\n                                                           Cisco Systems\n                                                           December 2013",
      "raw": true
    },
    {
      "indent": 13,
      "text": "A Common API for Transparent Hybrid Multicast",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "Group communication services exist in a large variety of flavors and technical implementations at different protocol layers. Multicast data distribution is most efficiently performed on the lowest available layer, but a heterogeneous deployment status of multicast technologies throughout the Internet requires an adaptive service binding at runtime. Today, it is difficult to write an application that runs everywhere and at the same time makes use of the most efficient multicast service available in the network. Facing robustness requirements, developers are frequently forced to use a stable upper-layer protocol provided by the application itself. This document describes a common multicast API that is suitable for transparent communication in underlay and overlay and that grants access to the different flavors of multicast. It proposes an abstract naming scheme that uses multicast URIs, and it discusses mapping mechanisms between different namespaces and distribution technologies. Additionally, this document describes the application of this API for building gateways that interconnect current Multicast Domains throughout the Internet. It reports on an implementation of the programming Interface, including service middleware. This document is a product of the Scalable Adaptive Multicast (SAM) Research Group.",
      "ja": "グループ通信サービスは、異なるプロトコル層におけるフレーバーおよび技術の実装の多種多様に存在します。マルチキャストデータ配信は、最も効率的に利用可能な最低層で実行されますが、インターネットを通じてマルチキャスト技術の異機種間の配置状況は、実行時にバインディング適応サービスを必要とします。今日、どこでも動作するアプリケーションを記述することは困難であると同時に、ネットワークで利用可能な最も効率的なマルチキャストサービスを利用します。ロバスト性の要件に直面して、開発者はしばしば、アプリケーション自体によって提供される安定した上位層プロトコルを使用することを余儀なくされています。この文書では、アンダーレイとオーバーレイに透明の通信に適しており、それは、マルチキャストの異なる味へのアクセスを許可する一般的なマルチキャストAPIについて説明します。これは、マルチキャストのURIを使用して、抽象命名方式を提案し、それは別の名前空間と配布技術との間のマッピングの仕組みについて説明します。また、この文書は、インターネットを通じて、現在のマルチキャストドメインを相互接続するゲートウェイを構築するため、このAPIのアプリケーションを記述しています。これは、サービスミドルウェアを含む、プログラミングインタフェースの実装について報告します。この文書では、スケーラブルアダプティブマルチキャスト（SAM）研究グループの製品です。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for examination, experimental implementation, and evaluation.",
      "ja": "このドキュメントはインターネット標準化過程仕様ではありません。それは、検査、実験的な実装、および評価のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document defines an Experimental Protocol for the Internet community. This document is a product of the Internet Research Task Force (IRTF). The IRTF publishes the results of Internet-related research and development activities. These results might not be suitable for deployment. This RFC represents the consensus of the Scalable Adaptive Multicast Research Group of the Internet Research Task Force (IRTF). Documents approved for publication by the IRSG are not a candidate for any level of Internet Standard; see Section 2 of RFC 5741.",
      "ja": "この文書は、インターネットコミュニティのためにExperimentalプロトコルを定義します。この文書はインターネットResearch Task Force（IRTF）の製品です。 IRTFはインターネット関連の研究開発活動の成果を公表しています。これらの結果は、展開に適していない可能性があります。このRFCはインターネットリサーチタスクフォースのスケーラブル適応マルチキャスト研究グループ（IRTF）のコンセンサスを表しています。 IRSGによって公表のために承認されたドキュメントは、インターネット標準の任意のレベルの候補ではありません。 RFC 5741のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7046.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7046で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2013 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2013 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................4\n   1.1. Use Cases for the Common API ...............................6\n   1.2. Illustrative Examples ......................................7\n        1.2.1. Support of Multiple Underlying Technologies .........7\n        1.2.2. Support of Multi-Resolution Multicast ...............9\n2. Terminology ....................................................10\n3. Overview .......................................................10\n   3.1. Objectives and Reference Scenarios ........................10\n   3.2. Group Communication API and Protocol Stack ................12\n   3.3. Naming and Addressing .....................................14\n   3.4. Namespaces ................................................15",
      "raw": true
    },
    {
      "indent": 3,
      "text": "   3.5. Name-to-Address Mapping ...................................15\n        3.5.1. Canonical Mapping ..................................16\n        3.5.2. Mapping at End Points ..............................16\n        3.5.3. Mapping at Inter-Domain Multicast Gateways .........16\n   3.6. A Note on Explicit Multicast (Xcast) ......................16\n   3.7. MTU Handling ..............................................17\n4. Common Multicast API ...........................................18\n   4.1. Notation ..................................................18\n   4.2. URI Scheme Definition .....................................18\n        4.2.1. Syntax .............................................18\n        4.2.2. Semantic ...........................................19\n        4.2.3. Generic Namespaces .................................20\n        4.2.4. Application-Centric Namespaces .....................20\n        4.2.5. Future Namespaces ..................................20\n   4.3. Additional Abstract Data Types ............................21\n        4.3.1. Interface ..........................................21\n        4.3.2. Membership Events ..................................21\n   4.4. Group Management Calls ....................................22\n        4.4.1. Create .............................................22\n        4.4.2. Delete .............................................22\n        4.4.3. Join ...............................................22\n        4.4.4. Leave ..............................................23\n        4.4.5. Source Register ....................................23\n        4.4.6. Source Deregister ..................................23\n   4.5. Send and Receive Calls ....................................24\n        4.5.1. Send ...............................................24\n        4.5.2. Receive ............................................24\n   4.6. Socket Options ............................................25\n        4.6.1. Get Interfaces .....................................25\n        4.6.2. Add Interface ......................................25\n        4.6.3. Delete Interface ...................................26\n        4.6.4. Set TTL ............................................26\n        4.6.5. Get TTL ............................................26\n        4.6.6. Atomic Message Size ................................27\n   4.7. Service Calls .............................................27\n        4.7.1. Group Set ..........................................27\n        4.7.2. Neighbor Set .......................................28\n        4.7.3. Children Set .......................................28\n        4.7.4. Parent Set .........................................28\n        4.7.5. Designated Host ....................................29\n        4.7.6. Enable Membership Events ...........................29\n        4.7.7. Disable Membership Events ..........................30\n        4.7.8. Maximum Message Size ...............................30\n5. Implementation .................................................30\n6. IANA Considerations ............................................30\n7. Security Considerations ........................................31\n8. Acknowledgements ...............................................31",
      "raw": true
    },
    {
      "indent": 3,
      "text": "9. References .....................................................32\n   9.1. Normative References ......................................32\n   9.2. Informative References ....................................33\nAppendix A. C Signatures ..........................................35\nAppendix B. Use Case for the API ..................................37\nAppendix C. Deployment Use Cases for Hybrid Multicast .............38\n  C.1. DVMRP ......................................................38\n  C.2. PIM-SM .....................................................38\n  C.3. PIM-SSM ....................................................39\n  C.4. BIDIR-PIM ..................................................40",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "Currently, group application programmers need to choose the distribution technology that the application will require at runtime. There is no common communication Interface that abstracts multicast transmission and subscriptions from the deployment state at runtime, nor has the use of DNS for Group Addresses been established. The standard multicast socket options [RFC3493] [RFC3678] are bound to an IP version by not distinguishing between the naming and addressing of multicast identifiers. Group communication, however,",
      "ja": "現在、グループのアプリケーションプログラマは、アプリケーションが実行時に必要となる配信技術を選択する必要があります。実行時に展開状態からマルチキャスト伝送とサブスクリプションを抽象化し、また確立されたグループアドレスのためのDNSの使用を持っている共通の通信インターフェースはありません。標準のマルチキャストソケットオプション[RFC3493] [RFC3678]は、ネーミングを区別し、マルチキャスト識別子のアドレッシングないでIPバージョンにバインドされています。グループ通信は、しかし、"
    },
    {
      "indent": 3,
      "text": "o is commonly implemented in different flavors, such as any-source multicast (ASM) vs. source-specific multicast (SSM),",
      "ja": "Oは、一般に、そのような任意のソースのマルチキャストソース固有マルチキャスト対（ASM）（SSM）のように、異なる風味で実装されて"
    },
    {
      "indent": 3,
      "text": "o is commonly implemented on different layers (e.g., IP vs. application-layer multicast), and",
      "ja": "Oは、一般的に異なる層（例えば、IPアプリケーションレイヤマルチキャスト対）上に実装され、"
    },
    {
      "indent": 3,
      "text": "o may be based on different technologies on the same tier, as seen with IPv4 vs. IPv6.",
      "ja": "IPv6の対のIPv4で見られるように、O、同じ層上の異なる技術に基づくことができます。"
    },
    {
      "indent": 3,
      "text": "The objective of this document is to provide for programmers a universal access to group services.",
      "ja": "このドキュメントの目的は、プログラマのためのグループサービスへの普遍的なアクセスを提供することです。"
    },
    {
      "indent": 3,
      "text": "Multicast application development should be decoupled from technological deployment throughout the infrastructure. It requires a common multicast API that offers calls to transmit and receive multicast data independent of the supporting layer and the underlying technological details. For inter-technology transmissions, a consistent view of multicast states is needed as well. This document describes an abstract group communication API and core functions necessary for transparent operations. Specific implementation guidelines with respect to operating systems or programming languages are out of scope for this document.",
      "ja": "マルチキャストアプリケーションの開発は、インフラストラクチャ全体の技術の展開からデカップリングする必要があります。これは、支持層とその下にある技術的な詳細のマルチキャストデータの独立を送受信するための呼び出しを提供しています一般的なマルチキャストAPIが必要です。技術間の送信では、マルチキャスト状態の一貫したビューも同様に必要とされています。この文書では、透明動作に必要な抽象グループ通信APIとコア機能について説明します。オペレーティングシステムやプログラミング言語についての具体的な実施ガイドラインは、このドキュメントの範囲外です。"
    },
    {
      "indent": 3,
      "text": "In contrast to the standard multicast socket Interface, the API introduced in this document abstracts naming from addressing. Using a multicast address in the current socket API predefines the corresponding routing layer. In this specification, the multicast name used for joining a group denotes an application-layer data stream that is identified by a multicast URI, independent of its binding to a specific distribution technology. Such a Group Name can be mapped to variable routing identifiers.",
      "ja": "標準のマルチキャストソケットインタフェースとは対照的に、APIは、アドレッシングから命名本書の抄録で導入します。現在のソケットAPIのマルチキャストアドレスを使用して、対応するルーティング層をあらかじめ定義します。本明細書では、グループに参加するために使用されるマルチキャスト名前は、その特定の配信技術への結合から独立してマルチキャストURIによって識別されるアプリケーション層のデータストリームを表します。このようなグループ名は、変数ルーティング識別子にマッピングすることができます。"
    },
    {
      "indent": 3,
      "text": "The aim of this common API is twofold:",
      "ja": "この共通APIの目的は2つあり："
    },
    {
      "indent": 3,
      "text": "o Enable any application programmer to implement group-oriented data communication independent of the underlying delivery mechanisms. In particular, allow for a late binding of group applications to multicast technologies that makes applications efficient but robust with respect to deployment aspects.",
      "ja": "O基礎となる配信メカニズムのグループ指向データ通信独立を実装する任意のアプリケーション・プログラマを有効にします。具体的には、展開面に関してアプリケーションが効率的でなく、堅牢にマルチキャスト技術へのグループのアプリケーションの遅延バインディングを可能にします。"
    },
    {
      "indent": 3,
      "text": "o Allow for flexible namespace support in group addressing and thereby separate naming and addressing (or routing) schemes from the application design. This abstraction not only decouples programs from specific aspects of underlying protocols but may open application design to extend to specifically flavored group services.",
      "ja": "Oアプリケーションの設計からアドレッシンググループ可撓性名前空間のサポートを可能にし、それによって別個の命名およびアドレッシング（またはルーティング）方式。この抽象化は、基礎となるプロトコルの特定の側面からプログラムを切り離すが、特に味のするグループサービスを拡張するためのアプリケーションの設計を開くことができないだけ。"
    },
    {
      "indent": 3,
      "text": "Multicast technologies may be of various peer-to-peer kinds, IPv4 or IPv6 network-layer multicast, or implemented by some other application service. Corresponding namespaces may be IP addresses or DNS naming, overlay hashes, or other application-layer group identifiers like <sip:*@peanuts.org>, but they can also be names independently defined by the applications. Common namespaces are introduced later in this document but follow an open concept suitable for further extensions.",
      "ja": "マルチキャスト技術は、様々なピア・ツー・ピアの種類、IPv4またはIPv6ネットワークレイヤマルチキャストであること、またはいくつかの他のアプリケーションサービスによって実現してもよいです。対応する名前空間は次のようにIPアドレスやDNSの名前付け、オーバーレイハッシュ、または他のアプリケーション層のグループ識別子であってもよい。<SIP：* @ peanuts.org>、彼らはまた、独立したアプリケーションによって定義された名前することができます。一般的な名前空間は、このドキュメントの導入が、さらなる拡張に適したオープンコンセプトに従っています。"
    },
    {
      "indent": 3,
      "text": "This document also discusses mapping mechanisms between different namespaces and forwarding technologies and proposes expressions of defaults for an intended binding. Additionally, the multicast API provides internal Interfaces to access current multicast states at the host. Multiple multicast protocols may run in parallel on a single host. These protocols may interact to provide a gateway function that bridges data between different domains. The usage of this API at gateways operating between current multicast instances throughout the Internet is described as well. Finally, a report on an implementation of the programming Interface, including service middleware, is presented.",
      "ja": "この文書はまた、異なる名前空間と転送技術との間のマッピングメカニズムを説明し、意図的な結合のためのデフォルトの式を提案しています。また、マルチキャストAPIは、ホストで現在のマルチキャストの状態にアクセスするための内部インタフェースを提供します。複数のマルチキャストプロトコルは、単一のホスト上で並列に実行することができます。これらのプロトコルは、異なるドメイン間でデータをブリッジゲートウェイ機能を提供するように相互作用することができます。インターネットを通じて現在のマルチキャストのインスタンス間で動作するゲートウェイでこのAPIの利用も同様に記述されています。最後に、サービスミドルウェアを含む、プログラミングインタフェースの実装に関する報告書は、提示されます。"
    },
    {
      "indent": 3,
      "text": "This document represents the consensus of the SAM Research Group. It has been reviewed by the Research Group members active in the specific area of work. In addition, this document has been comprehensively reviewed by people who are not \"in\" the Research Group but are experts in the area.",
      "ja": "この文書では、SAM研究グループのコンセンサスを表しています。それは仕事の特定の領域に積極的に研究グループのメンバーによって検討されています。また、この文書は包括研究グループ「に」ありませんが、エリア内の専門家である人々によって検討されています。"
    },
    {
      "indent": 0,
      "text": "1.1. Use Cases for the Common API",
      "section_title": true,
      "ja": "1.1. 共通APIの使用例"
    },
    {
      "indent": 3,
      "text": "The following generic use cases can be identified; these use cases require an abstract common API for multicast services:",
      "ja": "次の一般的なユースケースを識別することができます。これらのユースケースは、マルチキャストサービスのための抽象共通APIが必要です。"
    },
    {
      "indent": 3,
      "text": "Application Programming Independent of Technologies: Application programmers are provided with group primitives that remain independent of multicast technologies and their deployment in target domains. Thus, for a given application, they can develop a program that will run in every deployment scenario. The use of Group Names in the form of abstract metadata types allows applications to remain namespace-agnostic in the sense that the resolution of namespaces and name-to-address mappings may be delegated to a system service at runtime. Complexity is thereby minimized, as developers need not care about how data is distributed in groups, while the system service can take advantage of extended information of the network environment as acquired at startup.",
      "ja": "Technologies社のアプリケーション・プログラミング・独立：アプリケーションプログラマは、マルチキャスト技術とターゲットドメインでの展開とは独立したままグループプリミティブが設けられています。このように、与えられたアプリケーションのために、彼らはすべての展開シナリオで実行するプログラムを開発することができます。抽象メタデータ型の形式でグループ名を使用すると、アプリケーションが名前空間と名前とアドレスのマッピングの解像度は、実行時にシステムサービスに委任することができるという意味で、名前空間に依存しないままにすることができます。開発者は、データがグループにどのように分配されるかを気にする必要はないと起動時に取得したシステムサービスは、ネットワーク環境の拡張情報を活用することができますしながら、複雑さは、それによって、最小化されます。"
    },
    {
      "indent": 3,
      "text": "Global Identification of Groups: Groups can be identified independent of technological instantiations and beyond deployment domains. Taking advantage of the abstract naming, an application can thus match data received from different Interface technologies (e.g., IPv4, IPv6, and overlays) to belong to the same group. This not only increases flexibility -- an application may, for instance, combine heterogeneous multipath streams -- but also simplifies the design and implementation of gateways.",
      "ja": "グローバルグループの同定：グループは、技術インスタンスのと展開のドメインを越えた独立した識別することができます。抽象命名を利用して、このようにデータを一致させることができ、アプリケーションは、同じグループに属するように異なるインタフェース技術（例えば、IPv4の、IPv6、およびオーバーレイ）から受け取りました。アプリケーションは、例えば、異種のマルチストリームを組み合わせることができる -   - これは、柔軟性を増加させるだけでなく、ゲートウェイの設計と実装を簡素化します。"
    },
    {
      "indent": 3,
      "text": "Uniform Access to Multicast Flavors: The URI naming scheme uniformly supports different flavors of group communication, such as any-source multicast and source-specific multicast, and selective broadcast, independent of their service instantiation. The traditional SSM model, for instance, can experience manifold support by directly mapping the multicast URI (i.e., \"group@instantiation\") to an (S,G) state on the IP layer, by first resolving S for a subsequent Group Address query, by transferring this process to any of the various source-specific overlay schemes, or by delegating to a plain replication server. The application programmer can invoke any of these underlying mechanisms with the same line of code.",
      "ja": "マルチキャストフレーバーへの均一なアクセス：URIの命名方式は一様に、このような彼らのサービスのインスタンス化とは無関係に任意のソースのマルチキャストおよびソース固有のマルチキャスト、および選択放送などのグループ通信の異なる味を、サポートしています。従来のSSMモデルは、例えば、最初に、後続のグループアドレスの問い合わせのためのSを解決することによって、直接IP層の上に（S、G）状態にマルチキャストURI（すなわち、「グループ@のインスタンス化」）をマッピングすることにより、マニホールドのサポートを体験することができます様々なソース固有のオーバーレイ方式のいずれかに、このプロセスを転送することにより、またはプレーン複製サーバに委譲することによって。アプリケーションプログラマは、コードの同じ行で、これらの基礎となるメカニズムのいずれかを呼び出すことができます。"
    },
    {
      "indent": 3,
      "text": "Simplified Service Deployment through Generic Gateways: The common multicast API allows for an implementation of abstract gateway functions with mappings to specific technologies residing at the system level. Generic gateways may provide a simple bridging service and facilitate an inter-domain deployment of multicast.",
      "ja": "ジェネリックゲートウェイを通じて簡体サービスの展開：一般的なマルチキャストAPIは、システムレベルで常駐する特定の技術へのマッピングを持つ抽象ゲートウェイ機能の実装が可能になります。一般的なゲートウェイは、単純なブリッジングサービスを提供し、マルチキャストのドメイン間の展開を容易にすることができます。"
    },
    {
      "indent": 3,
      "text": "Mobility-Agnostic Group Communication: Group naming and management as foreseen in the common multicast API remain independent of locators. Naturally, applications stay unaware of any mobility-related address changes. Handover-initiated re-addressing is delegated to the mapping services at the system level and may be designed to smoothly interact with mobility management solutions provided at the network or transport layer (see [RFC5757] for mobility-related aspects).",
      "ja": "モビリティ・不可知論者グループ通信：一般的なマルチキャストAPIに予見としてグループは、ネーミングおよび管理ロケータの独立したまま。当然のことながら、アプリケーションは、任意のモビリティ関連アドレス変更を認識しないままです。ハンドオーバ開始システムレベルでマッピングサービスに委譲され、再アドレッシング及び円滑ネットワークまたはトランスポート層に設けられたモビリティ管理ソリューションと相互作用するように設計されてもよい（モビリティ関連の態様に関して[RFC5757]を参照）。"
    },
    {
      "indent": 0,
      "text": "1.2. Illustrative Examples",
      "section_title": true,
      "ja": "1.2. 具体的な例"
    },
    {
      "indent": 0,
      "text": "1.2.1. Support of Multiple Underlying Technologies",
      "section_title": true,
      "ja": "1.2.1. 複数の基礎となるテクノロジのサポート"
    },
    {
      "indent": 3,
      "text": "On a very high level, the common multicast API provides the application programmer with one single Interface to manage multicast content independent of the technology underneath. Considering the following simple example in Figure 1, a multicast source S is connected via IPv4 and IPv6. It distributes one flow of multicast content (e.g., a movie). Receivers are connected via IPv4/v6 and Overlay Multicast (OM), respectively.",
      "ja": "非常に高いレベルでは、一般的なマルチキャストAPIは、下の技術のマルチキャストコンテンツの独立を管理するために、1つのインターフェイスを持つアプリケーションプログラマを提供します。図1の次の簡単な例を考えると、マルチキャストソースSは、IPv4とIPv6を介して接続されています。これは、マルチキャストコンテンツ（例えば、映画）の流れを分配します。受信機は、それぞれ、V6のIPv4 /オーバーレイマルチキャスト（OM）を介して接続されています。"
    },
    {
      "indent": 3,
      "text": " +-------+       +-------+                       +-------+\n |   S   |       |  R1   |                       |  R3   |\n +-------+       +-------+                       +-------+\nv6|   v4|           |v4                             |OM\n  |     |          /                                |\n  |  ***| ***  ***/ **                          *** /***  ***  ***\n   \\*   |*   **  /**   *                       *   /*   **   **   *\n   *\\   \\_______/_______*__v4__+-------+      *   /                *\n    *\\    IPv4/v6      *       |  R2   |__OM__ *_/ Overlay Mcast  *\n   *  \\_________________*__v6__+-------+      *                    *\n    *   **   **   **   *                       *    **   **   **  *\n     ***  ***  ***  ***                         ***  ***  ***  ***",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Figure 1: Common Scenario: Source S Sends the Same Multicast Content via Different Technologies",
      "ja": "図1：一般的なシナリオ：ソースSは、異なる技術を経由して同一のマルチキャストコンテンツを送信します"
    },
    {
      "indent": 3,
      "text": "Using the current BSD socket API, the application programmer needs to decide on the IP technologies at coding time. Additional distribution techniques, such as overlay multicast, must be individually integrated into the application. For each technology, the application programmer needs to create a separate socket and initiate a dedicated join or send. As the current socket API does not distinguish between Group Name and Group Address, the content will be delivered multiple times to the same receiver (cf. R2). Whenever the source distributes content via a technology that is not supported by the receivers or its Internet Service Provider (cf. R3), a gateway is required. Gateway functions rely on a coherent view of the Multicast Group states.",
      "ja": "現在のBSDソケットAPIを使用して、アプリケーションプログラマは時間をコーディングにIP技術を決定する必要があります。そのようなオーバレイマルチキャストなどの追加の配信技術は、個々のアプリケーションに統合されなければなりません。各技術について、アプリケーションプログラマは別のソケットを作成する必要があり、参加したり、送信専用を開始します。現在のソケットAPIは、グループ名とグループアドレスを区別しないように、コンテンツは同じレシーバ（参照：R2）に複数回配信されます。ソースは受信者またはそのインターネットサービスプロバイダ（参照R3）でサポートされていない技術を経由してコンテンツを配信するたびに、ゲートウェイが必要です。ゲートウェイ機能は、マルチキャストグループの状態のコヒーレントビューに依存しています。"
    },
    {
      "indent": 3,
      "text": "The common multicast API simplifies programming of multicast applications, as it abstracts content distribution from specific technologies. In addition to calls that implement the receiving and sending of multicast data, the API provides service calls to grant access to internal multicast states at the host. The API description provided in this document defines a minimal set of programming Interfaces to the system components at the host to operate group communication. It is left to specific implementations to provide additional convenience functions for programmers.",
      "ja": "それは特定の技術からのコンテンツ配信を抽象化などの一般的なマルチキャストAPIは、マルチキャストアプリケーションのプログラミングを簡素化します。マルチキャストデータの受信と送信を実装通話に加えて、APIは、サービスがホストに内部のマルチキャスト状態へのアクセスを許可するために呼び出しています。本書で提供されるAPIの説明は、グループ通信を動作させるホストのシステム構成要素へのプログラミング・インターフェースの最小セットを定義します。プログラマのための追加の便利な機能を提供するために、特定の実装に任されています。"
    },
    {
      "indent": 3,
      "text": "The implementation of content distribution for the example shown in Figure 1 may then look like:",
      "ja": "図1に示す例のコンテンツ配信の実装は、次にようになります。"
    },
    {
      "indent": 5,
      "text": "//Initialize multicast socket\nMulticastSocket m = new MulticastSocket();\n//Associate all available Interfaces\nm.addInterface(getInterfaces());\n//Subscribe to Multicast Group\nm.join(URI(\"ham:opaque:news@cnn.com\"));\n//Send to Multicast Group\nm.send(URI(\"ham:opaque:news@cnn.com\"),message);",
      "raw": true
    },
    {
      "indent": 12,
      "text": "Send/receive example using the common multicast API",
      "ja": "一般的なマルチキャストAPIを使用した例を受信/送信"
    },
    {
      "indent": 3,
      "text": "The gateway function for R2 can be implemented by service calls that look like:",
      "ja": "R2のためのゲートウェイ機能は次のようになり、サービスコールによって実装することができます。"
    },
    {
      "indent": 5,
      "text": "//Initialize multicast socket\nMulticastSocket m = new MulticastSocket();\n//Check (a) host is designated multicast node for this Interface\n//      (b) receivers exist\nfor all this.getInterfaces() {\n  if(designatedHost(this.interface) &&\n       childrenSet(this.interface,\n          URI(\"ham:opaque:news@cnn.com\")) != NULL) {\n    m.addInterface(this.interface);\n  }\n}\nwhile(true) {\n  m.send(URI(\"ham:opaque:news@cnn.com\"),message);\n}",
      "raw": true
    },
    {
      "indent": 14,
      "text": "Gateway example using the common multicast API",
      "ja": "一般的なマルチキャストAPIを使用してゲートウェイの例"
    },
    {
      "indent": 0,
      "text": "1.2.2. Support of Multi-Resolution Multicast",
      "section_title": true,
      "ja": "1.2.2. 多重解像度マルチキャストのサポート"
    },
    {
      "indent": 3,
      "text": "Multi-resolution multicast adjusts the multicast stream to consider heterogeneous end devices. The multicast data (e.g., available by different compression levels) is typically announced using multiple multicast addresses that are unrelated to each other. Using the common API, multi-resolution multicast can be implemented transparently by an operator with the help of name-to-address mapping, or by systematic naming from a subscriber-centric perspective.",
      "ja": "マルチ解像度のマルチキャストは、異種のエンドデバイスを検討するマルチキャストストリームを調整します。 （異なる圧縮レベルにより、例えば、利用可能な）マルチキャストデータは、典型的には、相互に無関係である複数のマルチキャストアドレスを使用して発表されています。共通APIを使用して、マルチ解像度のマルチキャストは、名前からアドレスのマッピングの助けを借りて、オペレータによって透過的に実装され、または加入者中心の視点から体系的命名することによってすることができます。"
    },
    {
      "indent": 3,
      "text": "Operator-Centric: An operator deploys a domain-specific mapping. In this case, any multicast receiver (e.g., mobile or DSL user) subscribes to the same multicast name, which will be resolved locally to different multicast addresses. In this case, each Group Address represents a different level of data quality.",
      "ja": "オペレータ中心の：オペレータは、ドメイン固有のマッピングをデプロイします。この場合には、任意のマルチキャスト受信機（例えば、モバイル又はDSLユーザ）は、異なるマルチキャストアドレスに局所的に解決される同じマルチキャスト名前、に加入します。この場合、各グループアドレスは、データ品質の異なるレベルを表します。"
    },
    {
      "indent": 3,
      "text": "Subscriber-Centric: In a subscriber-centric example, the multicast receiver chooses the quality in advance, based on a predefined naming syntax. Consider a layered video stream \"blockbuster\" available at different qualities Q_i, each of which consists of the base layer plus the sum of EL_j, j <= i enhancement layers. Each individual layer may then be accessible by a name \"EL_j.Q_i.blockbuster\", j <= i, while a specific quality aggregates the corresponding layers to \"Q_i.blockbuster\", and the full-size movie may be just called \"blockbuster\".",
      "ja": "加入者中心のは：加入者中心の例では、マルチキャスト受信側は、事前定義された命名構文に基づいて、予め品質を選択します。ベースレイヤプラスEL_j、J <=の和から成る各々はQ_I、Iエンハンスメントレイヤ異なる品質で利用可能な階層化ビデオストリーム「ブロックバスター」を考えます。個々の層は、名前「EL_j.Q_i.blockbuster」、J <具体的な品質が対応する層に「Q_i.blockbuster」、およびフルサイズの映画を集約しながら、=私は、ちょうど呼ばれる「大ヒットによってアクセスすることができます」。"
    },
    {
      "indent": 0,
      "text": "2. Terminology",
      "section_title": true,
      "ja": "2.用語"
    },
    {
      "indent": 3,
      "text": "This document uses the terminology as defined for the multicast protocols discussed in [RFC2710], [RFC3376], [RFC3810], [RFC4601], and [RFC4604]. In addition, the following terms will be used:",
      "ja": "このドキュメントは[RFC2710]で説明したマルチキャストプロトコルのために定義されるような用語を使用して、[RFC3376]、[RFC3810]、[RFC4601]及び[RFC4604]。また、以下の用語が使用されます。"
    },
    {
      "indent": 3,
      "text": "Group Address: A Group Address is a routing identifier. It represents a technological specifier and thus reflects the distribution technology in use. Multicast packet forwarding is based on this address.",
      "ja": "グループ住所：グループアドレスは、ルーティング識別子です。それは技術的な指定子を表し、したがって、使用中の配信技術を反映しています。マルチキャストパケットの転送は、このアドレスに基づいています。"
    },
    {
      "indent": 3,
      "text": "Group Name: A Group Name is an application identifier used by applications to manage communication in a Multicast Group (e.g., join/leave and send/receive). The Group Name does not predefine any distribution technologies. Even if it syntactically corresponds to an address, it solely represents a logical identifier.",
      "ja": "グループ名：グループ名は、マルチキャストグループ（例えば、参加/ままにして送信/受信）における通信を管理するためにアプリケーションによって使用されるアプリケーション識別子です。グループ名は、任意の配布技術を事前に定義しません。それは構文的アドレスに対応したとしても、それは単に論理識別子を表します。"
    },
    {
      "indent": 3,
      "text": "Multicast Namespace: A Multicast Namespace is a collection of designators (i.e., names or addresses) for groups that share a common syntax. Typical instances of namespaces are IPv4 or IPv6 multicast addresses, overlay group IDs, Group Names defined on the application layer (e.g., SIP or email), or some human-readable string.",
      "ja": "マルチキャスト名前空間：マルチキャスト名前空間には、共通の構文を共有するグループのための指示子のコレクション（すなわち、名前や住所）です。名前空間の典型的な例は、アプリケーション層（例えば、SIPまたは電子メール）、またはいくつかの人間が読み取り可能な文字列に定義されたIPv4またはIPv6マルチキャストアドレス、オーバーレイ・グループID、グループ名です。"
    },
    {
      "indent": 3,
      "text": "Interface: An Interface is a forwarding instance of a distribution technology on a given node, for example, the IP Interface 192.168.1.1 at an IPv4 host, or an overlay routing Interface.",
      "ja": "インターフェイス：インターフェイスは、IPv4ホストの所与のノード、例えば、IPインターフェース192.168.1.1、またはインタフェースルーティングオーバレイ上の配信技術の転送インスタンスです。"
    },
    {
      "indent": 3,
      "text": "Multicast Domain: A Multicast Domain hosts nodes and routers of a common, single multicast forwarding technology and is bound to a single namespace.",
      "ja": "マルチキャストドメイン：マルチキャストドメインは、一般的な、単一のマルチキャスト転送技術のノードとルータをホストし、単一の名前空間にバインドされています。"
    },
    {
      "indent": 3,
      "text": "Inter-domain Multicast Gateway (IMG): An IMG is an entity that interconnects different Multicast Domains. Its objective is to forward data between these domains, e.g., between an IP layer and overlay multicast.",
      "ja": "ドメイン間のマルチキャストゲートウェイ（IMG）：IMGは異なるマルチキャストドメインを相互接続するエンティティです。その目的は、IP層とオーバレイマルチキャストの間に、例えば、これらのドメイン間でデータを転送することです。"
    },
    {
      "indent": 0,
      "text": "3. Overview",
      "section_title": true,
      "ja": "3.概要"
    },
    {
      "indent": 0,
      "text": "3.1. Objectives and Reference Scenarios",
      "section_title": true,
      "ja": "3.1. 目的とリファレンスシナリオ"
    },
    {
      "indent": 3,
      "text": "The default use case addressed in this document targets applications that participate in a group by using some common identifier taken from some common namespace. This Group Name is typically learned at runtime from user interaction, such as the selection of an IPTV channel, or from dynamic session negotiations as used with the Session Initiation Protocol (SIP) [RFC3261] or Peer-to-Peer SIP",
      "ja": "本書で扱わデフォルトのユースケースは、いくつかの共通の名前空間から取られたいくつかの共通の識別子を使用して、グループに参加するアプリケーションをターゲットとしています。このグループ名は、典型的に、またはセッション開始プロトコル（SIP）[RFC3261]またはピア・ツー・ピアSIPで使用される動的セッションネゴシエーションからIPTVチャネルの選択として、ユーザーとの対話から、実行時に学習され"
    },
    {
      "indent": 3,
      "text": "(P2PSIP) [SIP-RELOAD], but may as well have been predefined for an application as a common Group Name. Technology-specific system functions then transparently map the Group Name to Group Addresses such that",
      "ja": "（P2PSIP）[SIPリロード]が、同様に、共通のグループ名などのアプリケーションのために事前に定義されていてもよいです。技術特有のシステム機能は、透過的に、このようなグループアドレスにグループ名をマッピング"
    },
    {
      "indent": 3,
      "text": "o programmers can process Group Names in their programs without the need to consider technological mappings that relate to designated deployments in target domains;",
      "ja": "Oプログラマは、ターゲットドメイン内の指定の展開に関連する技術のマッピングを考慮することなく、自分たちのプログラムにグループ名を処理することができます。"
    },
    {
      "indent": 3,
      "text": "o applications can identify packets that belong to a logically named group, independent of the Interface technology used for sending and receiving packets; this shall also hold true for multicast gateways.",
      "ja": "Oアプリケーションは、パケットを送受信するために使用するインターフェース技術とは無関係に、論理的に名前のグループに属しているパケットを識別することができます。これは、マルチキャストゲートウェイに当てはまるものとします。"
    },
    {
      "indent": 3,
      "text": "This document considers two reference scenarios that cover the following hybrid deployment cases displayed in Figure 2:",
      "ja": "この文書では、図2に表示され、次のハイブリッド展開のケースをカバーする二つの基準シナリオを考慮する。"
    },
    {
      "indent": 3,
      "text": "1. Multicast Domains running the same multicast technology but remaining isolated, possibly only connected by network-layer unicast.",
      "ja": "おそらく唯一のネットワーク層ユニキャスト接続、同じマルチキャスト技術を実行しているが、単離された残り1のマルチキャストドメイン。"
    },
    {
      "indent": 3,
      "text": "2. Multicast Domains running different multicast technologies but hosting nodes that are members of the same Multicast Group.",
      "ja": "2.マルチキャストドメインが異なるマルチキャスト技術を実行しているが、同じマルチキャストグループのメンバーであるノードをホストしています。"
    },
    {
      "indent": 3,
      "text": "                                    +-------+         +-------+\n                                    | Member|         | Member|\n                                    |  Foo  |         |   G   |\n                                    +-------+         +-------+\n                                          \\            /\n                                        ***  ***  ***  ***\n                                       *   **   **   **   *\n                                      *                    *\n                                       *  Mcast Tech. A   *\n                                      *                    *\n                                       *   **   **   **   *\n                                        ***  ***  ***  ***\n+-------+          +-------+                     |\n| Member|          | Member|                 +-------+\n|   G   |          |  Foo  |                 |  IMG  |\n+-------+          +-------+                 +-------+\n    |                |                           |\n    ***  ***  ***  ***                 ***  ***  ***  ***\n   *   **   **   **   *               *   **   **   **   *\n  *                    *  +-------+  *                    *\n   *  Mcast Tech. A   * --|  IMG  |-- *  Mcast Tech. B   *   +------+\n  *                    *  +-------+  *                    * -|Member|\n   *   **   **   **   *               *   **   **   **   *   |  G   |\n    ***  ***  ***  ***                 ***  ***  ***  ***    +------+",
      "raw": true
    },
    {
      "indent": 4,
      "text": "Figure 2: Reference Scenarios for Hybrid Multicast, Interconnecting Group Members from Isolated Homogeneous and Heterogeneous Domains",
      "ja": "図2：ハイブリッドマルチキャストのためのリファレンスシナリオ、孤立同種および異種ドメインからグループメンバーの相互接続"
    },
    {
      "indent": 0,
      "text": "3.2. Group Communication API and Protocol Stack",
      "section_title": true,
      "ja": "3.2. グループ通信のAPIとプロトコルスタック"
    },
    {
      "indent": 3,
      "text": "The group communication API abstracts the socket concept and consists of four parts. Two parts combine the essential communication functions, while the remaining two offer optional extensions for enhanced monitoring and management:",
      "ja": "グループ通信APIは、ソケットの概念を抽象化し、4つの部分から構成されています。強化監視と管理のための2つのオファーオプションの拡張機能を維持しながら2つの部分が、基本的な通信機能を組み合わせます："
    },
    {
      "indent": 3,
      "text": "Group Management Calls: provide the minimal API to instantiate an abstract multicast socket and manage group membership;",
      "ja": "グループ管理は呼び出し：抽象マルチキャストソケットをインスタンス化し、グループメンバーシップを管理するために、最小限のAPIを提供すること。"
    },
    {
      "indent": 3,
      "text": "Send/Receive Calls: provide the minimal API to send and receive multicast data in a technology-transparent fashion;",
      "ja": "コールを受信/送信：技術透明な方法でマルチキャストデータを送受信する最小限のAPIを提供すること。"
    },
    {
      "indent": 3,
      "text": "Socket Options: provide extension calls for an explicit configuration of the multicast socket, such as setting hop limits or associated Interfaces;",
      "ja": "ソケットオプション：そのようなホップ限界または関連するインターフェースを設定するように、マルチキャストソケットを明示的に構成するための拡張コールを提供します。"
    },
    {
      "indent": 3,
      "text": "Service Calls: provide extension calls that grant access to internal multicast states of an Interface, such as the Multicast Groups under subscription or the multicast forwarding information base.",
      "ja": "サービスコール：拡張機能を提供し、このようなサブスクリプションの下でマルチキャストグループやマルチキャスト転送情報ベースとして、インタフェースの内部マルチキャスト状態、への補助金のアクセスを呼び出します。"
    },
    {
      "indent": 3,
      "text": "Multicast applications that use the common API require assistance from a group communication stack. This protocol stack serves two needs:",
      "ja": "共通APIを使用するマルチキャストアプリケーションは、グループ通信スタックからの支援を必要としています。このプロトコル・スタックは、二つのニーズを提供しています："
    },
    {
      "indent": 3,
      "text": "o It provides system-level support to transfer the abstract functions of the common API, including namespace support, into protocol operations at Interfaces.",
      "ja": "Oそれは、界面でのプロトコル操作に、名前空間のサポートを含む共通のAPIの抽象機能を転送するシステムレベルのサポートを提供します。"
    },
    {
      "indent": 3,
      "text": "o It provides group communication services across different multicast technologies at the local host.",
      "ja": "Oそれは、ローカルホストで異なるマルチキャストテクノロジー間グループ通信サービスを提供しています。"
    },
    {
      "indent": 3,
      "text": "A general initiation of a multicast communication in this setting proceeds as follows:",
      "ja": "次のように、この設定が進行中のマルチキャスト通信の一般的な開始"
    },
    {
      "indent": 3,
      "text": "1. An application opens an abstract multicast socket.",
      "section_title": true,
      "ja": "1.アプリケーションは、抽象マルチキャストソケットを開きます。"
    },
    {
      "indent": 3,
      "text": "2. The application subscribes to / leaves / (de)registers a group using a Group Name.",
      "ja": "2.アプリケーションは、加入に/葉/（デ）グループ名を使用してグループを登録します。"
    },
    {
      "indent": 3,
      "text": "3. An intrinsic function of the stack maps the logical group ID (Group Name) to a technical group ID (Group Address). This function may make use of deployment-specific knowledge, such as available technologies and Group Address management in its domain.",
      "ja": "スタックの3本来の機能は、技術的なグループID（グループアドレス）に論理グループID（グループ名）をマッピングします。この機能は、そのドメインで利用可能な技術とグループアドレス管理などのデプロイメント固有の知識、を利用することができます。"
    },
    {
      "indent": 3,
      "text": "4. Packet distribution proceeds to and from one or several multicast-enabled Interfaces.",
      "ja": "4.パケット分布および1つまたはいくつかのマルチキャスト対応インターフェイスから進みます。"
    },
    {
      "indent": 3,
      "text": "The abstract multicast socket represents a group communication channel composed of one or multiple Interfaces. A socket may be created without explicit Interface association by the application, which leaves the choice of the underlying forwarding technology to the group communication stack. However, an application may also bind the socket to one or multiple dedicated Interfaces and therefore predefine the forwarding technology and the Multicast Namespace(s) of the Group Address(es).",
      "ja": "抽象マルチキャストソケットは、一つまたは複数のインターフェイスからなるグループ通信チャネルを表します。ソケットは、グループ通信スタックに根本的な転送技術の選択肢を残しアプリケーションによって明示的なインターフェイスの関連付けなしで作成することができます。ただし、アプリケーションはまた、一つまたは複数の専用インターフェースにソケットを結合することができるので、転送技術とグループアドレス（ES）のマルチキャスト名前空間（複数可）を事前に定義します。"
    },
    {
      "indent": 3,
      "text": "Applications are not required to maintain mapping states for Group Addresses. The group communication stack accounts for the mapping of the Group Name to the Group Address(es) and vice versa. Multicast data passed to the application will be augmented by the corresponding Group Name. Multiple multicast subscriptions thus can be conducted on a single multicast socket without the need for Group Name encoding on the application side.",
      "ja": "アプリケーションは、グループアドレスのマッピング状態を維持するために必要とされていません。グループアドレス（ES）およびその逆にグループ名のマッピングのためのグループ通信スタック・アカウント。アプリケーションに渡されたマルチキャストデータは、対応するグループ名によって拡張されます。複数のマルチキャストサブスクリプションは、このようにアプリケーション側でグループ名符号化を必要とせずに単一のマルチキャストソケットで行うことができます。"
    },
    {
      "indent": 3,
      "text": "Hosts may support several multicast protocols. The group communication stack discovers available multicast-enabled Interfaces. It provides a minimal hybrid function that bridges data between different Interfaces and Multicast Domains. The details of service discovery are out of scope for this document.",
      "ja": "ホストは、複数のマルチキャストプロトコルをサポートすることができます。グループ通信スタックが可能なマルチキャスト対応のインターフェイスを検出します。これは、異なるインタフェースおよびマルチキャストドメイン間でデータをブリッジ最小ハイブリッド機能を提供します。サービス検出の詳細は、このドキュメントの範囲外です。"
    },
    {
      "indent": 3,
      "text": "The extended multicast functions can be implemented by middleware, as conceptually presented in Figure 3.",
      "ja": "概念的には、図3に示すように拡張されたマルチキャスト機能は、ミドルウェアによって実現することができます。"
    },
    {
      "indent": 8,
      "text": "*-------*     *-------*\n| App 1 |     | App 2 |\n*-------*     *-------*\n    |             |\n*---------------------*         ---|\n|   Middleware        |            |\n*---------------------*            |\n     |          |                  |\n*---------*     |                  |\n| Overlay |     |                   \\  Group Communication\n*---------*     |                   /  Stack\n     |          |                  |\n     |          |                  |\n*---------------------*            |\n|   Underlay          |            |\n*---------------------*         ---|",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Figure 3: Architecture of a Group Communication Stack with Middleware Offering Uniform Access to Multicast in Underlay and Overlay",
      "ja": "図3：ミドルウェアは、アンダーレイとオーバーレイでマルチキャストへの統一アクセスを提供するとのグループ通信スタックのアーキテクチャ"
    },
    {
      "indent": 0,
      "text": "3.3. Naming and Addressing",
      "section_title": true,
      "ja": "3.3. 命名とアドレッシング"
    },
    {
      "indent": 3,
      "text": "Applications use Group Names to identify groups. Names can uniquely determine a group in a global communication context and hide technological deployment for data distribution from the application. In contrast, multicast forwarding operates on Group Addresses. Even though both identifiers may be symbolically identical, they carry different meanings. They may also belong to different Multicast Namespaces. The namespace of a Group Address reflects a routing technology, while the namespace of a Group Name represents the context in which the application operates.",
      "ja": "アプリケーションは、グループを識別するために、グループ名を使用します。名前は一意のグローバル通信コンテキストにグループを決定し、アプリケーションからのデータ配信のための技術展開を隠すことができます。これとは対照的に、マルチキャスト転送は、グループアドレス上で動作します。両方の識別子が象徴的に同一であっても、彼らは異なる意味を運びます。彼らはまた、別のマルチキャスト名前空間に属していてもよいです。グループ名の名前空間は、アプリケーションが動作する状況を表しているグループアドレスの名前空間は、ルーティング技術を反映しています。"
    },
    {
      "indent": 3,
      "text": "URIs [RFC3986] are a common way to represent namespace-specific identifiers in applications in the form of an abstract metadata type. Throughout this document, all Group Names follow a URI notation using the syntax defined in Section 4.2. Examples are ham:ip:224.1.2.3:5000 for a canonical IPv4 ASM group at UDP port 5000 and ham:sip:news@cnn.com for application-specific naming with service instantiator and default port selection.",
      "ja": "URIは[RFC3986]は抽象メタデータ型の形式でアプリケーション名前空間固有の識別子を表現する一般的な方法です。本書では、すべてのグループ名は、セクション4.2で定義された構文を使用してURI表記に従ってください。サービスインスタンと、デフォルトのポート選択とアプリケーション固有の命名news@cnn.com：IP：224.1.2.3：5000 UDPポート5000とハムの標準的なIPv4のASMグループ用：SIP例としては、ハムです。"
    },
    {
      "indent": 3,
      "text": "An implementation of the group communication stack can provide convenience functions that detect the namespace of a Group Name or further optimize service instantiation. In practice, such a library would provide support for high-level data types to the application, similar to some versions of the current socket API (e.g., InetAddress in Java). Using this data type could implicitly determine the namespace. The details of automatic namespace identification or service handling are out of scope for this document.",
      "ja": "グループ通信スタックの実装では、グループ名またはさらなる最適化サービスインスタンスの名前空間を検出する便利な機能を提供することができます。実際に、そのようなライブラリは、現在のソケットAPI（Javaで例えば、InetAddressの）のいくつかのバージョンと同様のアプリケーションにハイレベルのデータ型のサポートを提供します。このデータ型を使用すると、暗黙的に名前空間を決定することができます。自動名前空間の識別やサービスの取り扱いの詳細は、このドキュメントの範囲外です。"
    },
    {
      "indent": 0,
      "text": "3.4. Namespaces",
      "section_title": true,
      "ja": "3.4. 名前空間"
    },
    {
      "indent": 3,
      "text": "Namespace identifiers in URIs are placed in the scheme element and characterize syntax and semantics of the group identifier. They enable the use of convenience functions and high-level data types while processing URIs. When used in names, they may indicate an application context or may facilitate a default mapping and a recovery of names from addresses. When used in addresses, they characterize the group identifier's type.",
      "ja": "URIの中に名前空間識別子は、スキーム要素に入れ、グループ識別子の構文と意味論を特徴付けています。 URIを処理している間、彼らは便利な機能とハイレベルのデータ・タイプの使用を可能にします。名前に使用すると、彼らは、アプリケーション・コンテキストを示すことか、デフォルトのマッピングとアドレスから名前の回復を容易にすることができます。アドレスで使用する場合、彼らはグループ識別子のタイプを特徴づけます。"
    },
    {
      "indent": 3,
      "text": "In compliance with the URI concept, namespace schemes can be added. Examples of schemes are generic (see Section 4.2.3) or inherited from applications (see Section 4.2.4).",
      "ja": "URIの概念に準拠して、名前空間スキームを追加することができます。スキームの例としては、一般的な（4.2.3項を参照）、またはアプリケーション（4.2.4項を参照）から継承されます。"
    },
    {
      "indent": 0,
      "text": "3.5. Name-to-Address Mapping",
      "section_title": true,
      "ja": "3.5. 名前からアドレスへのマッピング"
    },
    {
      "indent": 3,
      "text": "The multicast communication paradigm requires all group members to subscribe to the same Group Name, taken from a common Multicast Namespace, and to thereby identify the group in a technology-agnostic way. Following this common API, a sender correspondingly registers a Group Name prior to transmission.",
      "ja": "マルチキャスト通信パラダイムは、共通のマルチキャスト名前空間から取られた同じグループ名に加入し、それによって技術に依存しない方法でグループを識別するために、すべてのグループメンバーが必要です。この共通APIの後に、送信者は、それに応じて、送信する前にグループ名を登録します。"
    },
    {
      "indent": 3,
      "text": "At communication end points, Group Names require a mapping to Group Addresses prior to service instantiation at the Interfaces of the end points. Similarly, a mapping is needed at gateways to consistently translate between Group Addresses from different namespaces. Two requirements need to be met by a mapping function that translates between Multicast Names and Addresses:",
      "ja": "通信エンドポイントで、グループ名は、グループへのマッピングは、エンドポイントのインターフェースでのサービスのインスタンス化する前にアドレスが必要です。同様に、マッピングは一貫して異なる名前空間からのグループアドレス間の変換にゲートウェイで必要とされています。 2つの要件がマルチキャスト名前とアドレス間の変換マッピング機能によって満たされる必要があります。"
    },
    {
      "indent": 3,
      "text": "a. For a given Group Name, identify an Address that is appropriate for a local distribution instance.",
      "ja": "A。与えられたグループ名のために、ローカル配信インスタンスに適したアドレスを識別する。"
    },
    {
      "indent": 3,
      "text": "b. For a given Group Address, invert the mapping to recover the Group Name.",
      "ja": "B。与えられたグループアドレスの場合は、グループ名を回復するために、マッピングを反転。"
    },
    {
      "indent": 3,
      "text": "In general, mappings can be complex and do not need to be invertible. A mapping can be realized by embedding smaller namespaces into larger namespaces or selecting an arbitrary, unused ID in a smaller target namespace. For example, it is not obvious how to map a large identifier space (e.g., IPv6) to a smaller, collision-prone set like IPv4 (see [MCAST-v4v6-FRAMEWORK], [MCAST-v4v6], and [RFC6219]). Mapping functions can be stateless in some contexts but may require states in others. The application of such functions depends on the cardinality of the namespaces, the structure of address spaces, and possible address collisions. However, some namespaces facilitate a canonical, invertible transformation to default address spaces.",
      "ja": "一般的に、マッピングは、複雑にすることができ、可逆である必要はありません。マッピングは、より大きな名前空間に小さな名前空間を埋め込む以下ターゲット名前空間内の任意の未使用のIDを選択することによって実現することができます。例えば、IPv4のような小さい、衝突が発生しやすいセットに大きな識別子空間（例えば、IPv6）をマップする方法は明らかではない（参照[MCAST-v4v6-FRAMEWORK]、[MCAST-v4v6]、および[RFC6219]） 。マッピング機能は、一部のコンテキストでステートレスすることができますが、他に状態を必要とするかもしれません。このような機能のアプリケーションは、アドレス空間、および可能なアドレス衝突の構造、名前空間の基数に依存します。しかし、いくつかの名前空間は、アドレス空間をデフォルトに標準的な、可逆変換を促進します。"
    },
    {
      "indent": 0,
      "text": "3.5.1. Canonical Mapping",
      "section_title": true,
      "ja": "3.5.1.  Canonicalのマッピング"
    },
    {
      "indent": 3,
      "text": "Some Multicast Namespaces defined in Section 3.4 can express a canonical default mapping. For example, ham:ip:224.1.2.3:5000 indicates the correspondence to 224.1.2.3 in the default IPv4 multicast address space at port 5000. This default mapping is bound to a technology and may not always be applicable, e.g., in the case of address collisions. Note that under canonical mapping, the multicast URI can be completely recovered from any data message received within this group.",
      "ja": "3.4節で定義されたいくつかのマルチキャスト名前空間には、標準的なデフォルトのマッピングを表現することができます。たとえば、ハム：IPは：224.1.2.3：5000の場合には、例えば、ポート5000このデフォルトのマッピングは技術にバインドされている時にデフォルトのIPv4マルチキャストアドレス空間に224.1.2.3への対応を示し、常に適用されない場合がありますアドレス衝突の。正規マッピングの下で​​、マルチキャストURIが完全にこのグループ内で受信された任意のデータ・メッセージから回収することができることに留意されたいです。"
    },
    {
      "indent": 0,
      "text": "3.5.2. Mapping at End Points",
      "section_title": true,
      "ja": "3.5.2. エンドポイントでのマッピング"
    },
    {
      "indent": 3,
      "text": "Multicast listeners or senders require a name-to-address conversion for all technologies they actively run in a group. Even though a mapping applies to the local Multicast Domain only, end points may need to learn a valid Group Address from neighboring nodes, e.g., from a gateway in the collision-prone IPv4 domain. Once set, an end point will always be aware of the name-to-address correspondence and thus can autonomously invert the mapping.",
      "ja": "マルチキャストリスナまたは送信者は、彼らが積極的にグループ内で実行されるすべての技術の名前とアドレスの変換が必要になります。マッピングは、ローカルマルチキャストドメインに適用されるにもかかわらず、エンドポイントは、衝突が発生しやすいのIPv4ドメインのゲートウェイから、例えば、近隣ノードから有効なグループアドレスを学習する必要があるかもしれません。一度設定すると、エンドポイントは、常に自律的にマッピングを反転させることができるので、名前とアドレスの対応関係を認識することとなります。"
    },
    {
      "indent": 0,
      "text": "3.5.3. Mapping at Inter-Domain Multicast Gateways",
      "section_title": true,
      "ja": "3.5.3. ドメイン間のマルチキャストゲートウェイでのマッピング"
    },
    {
      "indent": 3,
      "text": "Multicast data may arrive at an IMG via one technology and request that the gateway re-address packets for another distribution system. At initial arrival, the IMG may not have explicit knowledge of the corresponding Multicast Group Name. To perform a consistent mapping, the Group Name needs to be acquired. It may have been distributed at source registration or may have been learned from a neighboring node, the details of which are beyond the scope of this document.",
      "ja": "マルチキャストデータは、1つの技術を介してIMGに到着し、別の分配システムのためのゲートウェイ再アドレスパケットことを要求してもよいです。最初の到着時に、IMGは、対応するマルチキャストグループ名の明示的な知識を持っていないかもしれません。一貫性のあるマッピングを実行するには、グループ名を取得する必要があります。これは、ソース登録時に配布されているか、またはこの文書の範囲を超えてその詳細は、隣接ノードから学習されていてもよいです。"
    },
    {
      "indent": 0,
      "text": "3.6. A Note on Explicit Multicast (Xcast)",
      "section_title": true,
      "ja": "3.6. 明示的マルチキャスト上の注意（のXcast）"
    },
    {
      "indent": 3,
      "text": "In Explicit Multicast (Xcast) [RFC5058], the multicast source explicitly predefines the receivers. From a conceptual perspective, Xcast is an additional distribution technology (i.e., a new technology-specific Interface) for this API. Xcast requires aggregated knowledge of receivers that is available at the origin of the distribution tree. The instantiation part of the Group Name may refer to such a management instance and tree root, which can be the source or some co-located processor.",
      "ja": "明示的マルチキャスト（のXcast）[RFC5058]に、マルチキャストソースは、明示的に受信機が事前に定義され。概念的な観点から、のXcastは、このAPIのための追加の配信技術（すなわち、新しい技術固有インタフェース）です。 XCASTは、配信木の原点に利用可能である受信機の集合知識を必要とします。グループ名のインスタンスの一部は、ソースまたはいくつかの同一位置のプロセッサとすることができる、そのような管理インスタンスおよびツリーのルートを指すことができます。"
    },
    {
      "indent": 3,
      "text": "An implementation of Xcast then requires a topology-dependent mapping of the Group Name to the set of subscribers. The defining details of this multi-destination mapping are out of scope for this document.",
      "ja": "Xcastの実装では、加入者のセットにグループ名のトポロジー依存のマッピングが必要です。このマルチ宛先マッピングの定義の詳細は、この文書の範囲外です。"
    },
    {
      "indent": 0,
      "text": "3.7. MTU Handling",
      "section_title": true,
      "ja": "3.7.  MTUの取り扱い"
    },
    {
      "indent": 3,
      "text": "This API considers a multi-technology scenario in which different technologies may have different Maximum Transmission Unit (MTU) sizes. Even if the MTU size between two hosts has been determined, it may change over time, as initiated by either the network (e.g., path changes) or end hosts (e.g., Interface changes due to mobility).",
      "ja": "このAPIは、異なる技術が異なる最大伝送単位（MTU）サイズを有することができるマルチテクノロジーのシナリオを検討します。 2つのホスト間のMTUサイズが決定された場合でも、ネットワーク（例えば、パスの変更）、またはエンドホスト（例えば、インタフェースにより移動度に変化する）のいずれかによって開始されるように、それは、時間の経過と共に変化してもよいです。"
    },
    {
      "indent": 3,
      "text": "The design of this API is based on the objective of robust communication and easy application development. MTU handling and the implementation of fragmentation are thus guided by the following observations:",
      "ja": "このAPIの設計は、堅牢なコミュニケーションと容易なアプリケーション開発の目的に基づいています。 MTU処理およびフラグメンテーションの実装は、このように、以下の観察によって導かれます。"
    },
    {
      "indent": 3,
      "text": "Application: Application programmers need a simple way to transmit packets in a technology-agnostic fashion. For this, it is convenient at the time of coding to rely on a transparent maximum amount of data that can be sent in one message from a socket. A regular program flow should not be distracted by querying and changing MTU sizes. Technically, the configuration of the maximum message size used by the application programmer may change and disrupt communication when (a) Interfaces are added or excluded or (b) the path MTU changes during transmission and thus disables the corresponding Interfaces.",
      "ja": "アプリケーション：アプリケーションプログラマは、技術にとらわれない形でパケットを送信するための簡単な方法が必要です。このため、それがソケットから一つのメッセージで送信できるデータの透明最大量に依存するコーディングの際に便利です。通常のプログラムの流れは、MTUサイズを照会し、変更することに気を取られてはいけません。 （A）インタフェースを追加または除外または（b）の経路はMTUが送信中に変化するので、対応するインタフェースを無効にしている場合、技術的に、アプリケーション・プログラマによって使用されるメッセージの最大サイズの設定は、通信を変更し、破壊してもよいです。"
    },
    {
      "indent": 3,
      "text": "Middleware: Middleware situated between application and technology Interfaces ensures a general packet-handling capability, which in turn prevents the application programmer from implementing fragmentation. A uniform maximum message size that cannot be changed during runtime shall be guaranteed by the group communication stack (e.g., middleware). Otherwise, this would conflict with a technology-agnostic application.",
      "ja": "ミドルウェア：アプリケーションと技術のインターフェイスとの間に位置するミドルウェアは、順番に断片化を実装するから、アプリケーションプログラマを防ぐ一般的なパケット処理機能を、保証します。実行時に変更することができない、均一なメッセージの最大サイズは、グループ通信スタック（例えば、ミドルウェア）によって保証されなければなりません。そうでなければ、これは技術に依存しないアプリケーションと競合します。"
    },
    {
      "indent": 3,
      "text": "Technology Interfaces: Fragmentation requirements depend on the technology in use. Hence, the (technology-bound) Interfaces need to cope with MTU sizes that may vary among Interfaces and along different paths.",
      "ja": "テクノロジーインターフェース：断片化要件使用中の技術に依存しています。したがって、（技術結合した）インターフェイスはインターフェイス間および異なる経路に沿って変化してもよいMTUサイズに対応する必要があります。"
    },
    {
      "indent": 3,
      "text": "The concept of this API also aims at guaranteeing a maximum message size for the application programmer, to thereby handle fragmentation at the Interface level, if needed. Nevertheless, the application programmer should be able to determine the technology-specific atomic message size to optimize data distribution, or for other reasons.",
      "ja": "このAPIの概念はまた、必要であれば、これにより、インターフェイスレベルでの断片化を処理するために、アプリケーションプログラマのための最大メッセージサイズを保証することを目指しています。それにもかかわらず、アプリケーション・プログラマは、データの分布を最適化する技術に固有の原子のメッセージサイズを決定することができる、または他の理由のためにすべきです。"
    },
    {
      "indent": 3,
      "text": "The uniform maximum message size should take realistic values (e.g., following IP clients) to enable smooth and efficient services. A detailed selection scheme of MTU values is out of scope for this document.",
      "ja": "均一なメッセージの最大サイズは、円滑かつ効率的なサービスを可能にするために（例えば、IPクライアント以下）現実的な値をとるべきです。 MTU値の詳細な選択スキームはこの文書の範囲外です。"
    },
    {
      "indent": 0,
      "text": "4. Common Multicast API",
      "section_title": true,
      "ja": "4.一般的なマルチキャストAPI"
    },
    {
      "indent": 0,
      "text": "4.1. Notation",
      "section_title": true,
      "ja": "4.1. 表記法"
    },
    {
      "indent": 3,
      "text": "The following description of the common multicast API is expressed in pseudo-syntax. Variables that are passed to function calls are declared by \"in\", and return values are declared by \"out\". A list of elements is denoted by \"<>\". The pseudo-syntax assumes that lists include an attribute that represents the number of elements.",
      "ja": "共通のマルチキャストAPIの以下の説明は、擬似構文で表現されます。関数呼び出しに渡された変数は「中」で宣言され、戻り値が「アウト」によって宣言されています。要素のリストは、「<>」で示されています。擬似構文は、リストは要素の数を表す属性を含むことを想定しています。"
    },
    {
      "indent": 3,
      "text": "The corresponding C signatures are defined in Appendix A.",
      "ja": "対応するC署名は、付録Aで定義されます"
    },
    {
      "indent": 0,
      "text": "4.2. URI Scheme Definition",
      "section_title": true,
      "ja": "4.2.  URIスキームの定義"
    },
    {
      "indent": 3,
      "text": "Multicast Names and Multicast Addresses used in this API are represented by a URI scheme that is specified in the following subsections. A corresponding ham-URI denotes a multicast channel and may be dereferenced to retrieve data published to that channel.",
      "ja": "このAPIで使用されるマルチキャスト名前とマルチキャストアドレスは、以下のサブセクションで指定されたURIスキームで表されます。対応HAM-URIは、マルチキャストチャネルを表し、そのチャネルに公開されたデータを取得するために逆参照されてもよいです。"
    },
    {
      "indent": 0,
      "text": "4.2.1. Syntax",
      "section_title": true,
      "ja": "4.2.1. 構文"
    },
    {
      "indent": 3,
      "text": "The syntax of the multicast URI is specified using the Augmented Backus-Naur Form (ABNF) [RFC5234] and is defined as follows:",
      "ja": "次のようにマルチキャストURIの構文は、拡張バッカス・ナウアフォーム（ABNF）[RFC5234]を使用して指定されると定義されます。"
    },
    {
      "indent": 3,
      "text": "ham-URI = ham-scheme \":\" namespace \":\" group [ \"@\" instantiation ] [ \":\" port ] [ \"/\" sec-credentials ]",
      "ja": "HAM-URI = HAM-方式 \"：\" 名前空間 \"：\" グループ[ \"@\" インスタンス] [ \"：\" ポート] [ \"/\" SEC-クレデンシャル]"
    },
    {
      "indent": 3,
      "text": "ham-scheme = \"ham\" ; hybrid adaptive multicast namespace = ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" ) group = \"*\" / 1*unreserved ; unreserved per [RFC3986] instantiation = 1*unreserved ; unreserved per [RFC3986] port = 1*DIGIT sec-credentials = alg \";\" val alg = 1*unreserved ; unreserved per [RFC3986] val = 1*unreserved ; unreserved per [RFC3986]",
      "ja": "ハム・スキーム=「ハム」。ハイブリッド適応マルチキャスト名前空間= ALPHA×（ALPHA / DIGIT / \"+\" / \" - \" / \"\"）群= \"*\" / 1 *予約されていません。予約されていないあたり[RFC3986]インスタンス= 1 *予約されていません。予約されていないあたり[RFC3986]ポート= 1 * DIGIT秒-クレデンシャル= ALG \";\"ヴァルALG = 1 *予約されていません。予約されていないあたり[RFC3986]のval = 1 *予約されていません。 [RFC3986]あたりの予約されていません"
    },
    {
      "indent": 3,
      "text": "Percent-encoding is applied to distinguish between reserved and unreserved assignments of the same character in the same ham-URI component (cf. [RFC3986]).",
      "ja": "パーセント符号は同一HAM-URI成分（参照[RFC3986]）で同じ文字の予約と予約されていない割り当てを区別するために適用されます。"
    },
    {
      "indent": 0,
      "text": "4.2.2. Semantic",
      "section_title": true,
      "ja": "4.2.2. セマンティック"
    },
    {
      "indent": 3,
      "text": "The semantic of the different parts of the URI is defined as follows:",
      "ja": "次のようにURIの異なる部分の意味が定義されています。"
    },
    {
      "indent": 3,
      "text": "ham-scheme: refers to the specification of the assigned identifier \"ham\".",
      "ja": "HAM-スキームは：割り当てられた識別子「ハム」の仕様を指します。"
    },
    {
      "indent": 3,
      "text": "namespace: takes the role of the Multicast Namespace. It defines the syntax of the group and instantiation part of the ham-URI. A basic syntax for these elements is specified in Section 4.2.1. The namespace may further restrict the syntax of designators. Example namespaces are described in Sections 4.2.3 and 4.2.4.",
      "ja": "名前空間は：マルチキャスト名前空間の役割を果たしています。これは、ハム-URIのグループとインスタンス化部分の構文を定義します。これらの要素のための基本的な構文はセクション4.2.1で指定されています。名前空間は、さらに指定子の構文を制限することができます。例名前空間は、セクション4.2.3および4.2.4に記載されています。"
    },
    {
      "indent": 3,
      "text": "group: uniquely identifies the group within the Multicast Namespace given in the namespace. The literal \"*\" represents all members of the Multicast Group.",
      "ja": "グループは、一意の名前空間内の所与のマルチキャスト名前空間内のグループを識別する。 「*」リテラルは、マルチキャストグループのすべてのメンバーを表します。"
    },
    {
      "indent": 3,
      "text": "instantiation: identifies the entity that generates the instance of the group (e.g., a SIP domain or a source in SSM, a dedicated routing entity, or a named processor that accounts for the group communication), using syntax and semantics as defined by the namespace. This parameter is optional. Note that ambiguities (e.g., identical node addresses in multiple overlay instances) can be distinguished by ports.",
      "ja": "インスタンス：名前空間によって定義されるような構文およびセマンティクスを使用して、基（例えば、SIPドメインまたはSSMソース、専用のルーティング・エンティティ、またはグループ通信を占める名付けプロセッサ）のインスタンスを生成するエンティティを識別する。このパラメータはオプションです。曖昧（複数オーバーレイインスタンスで、例えば、同一のノード・アドレス）が、ポートによって識別することができることに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "port: identifies a specific application at an instance of a group. This parameter is optional.",
      "ja": "ポートは：グループのインスタンスに特定のアプリケーションを識別する。このパラメータはオプションです。"
    },
    {
      "indent": 3,
      "text": "sec-credentials: used to implement security mechanisms (e.g., to authorize Multicast Group access or authenticate multicast operations). This parameter is optional. \"alg\" represents the security algorithm in use. \"val\" represents the actual value for Authentication, Authorization, and Accounting (AAA). Note that security credentials may carry a distinct technical meaning w.r.t. AAA schemes and may differ between group members. Hence, the sec-credentials are not considered part of the Group Name.",
      "ja": "SEC-クレデンシャル：（マルチキャストグループへのアクセスを許可またはマルチキャストオペレーションを認証するために、例えば）セキュリティメカニズムを実装するために使用されます。このパラメータはオプションです。 「ALGは、」使用中のセキュリティアルゴリズムを表します。 「valが」認証、許可、アカウンティング（AAA）の実際の値を表します。セキュリティ証明書は、個別の技術的な意味w.r.t.を運ぶことができることに注意してくださいAAAは、スキームおよびグループメンバー間で異なることができます。したがって、SEC-資格情報は、グループ名の一部とはみなされません。"
    },
    {
      "indent": 0,
      "text": "4.2.3. Generic Namespaces",
      "section_title": true,
      "ja": "4.2.3. 一般的な名前空間"
    },
    {
      "indent": 3,
      "text": "IP: This namespace is comprised of regular IP node naming, i.e., DNS names and addresses taken from any version of the Internet Protocol. The syntax of the group and instantiation follows the \"host\" definition in [RFC3986], Section 3.2.2. A processor dealing with the IP namespace is required to determine the syntax (DNS name, IP address, version) of the group and instantiation expression.",
      "ja": "IP：この名前空間は、通常のIPノードの命名で構成されている、すなわち、インターネットプロトコルのいずれかのバージョンから取られたDNS名とアドレス。グループおよびインスタンス化の構文は、[RFC3986]で「ホスト」の定義は、セクション3.2.2に従っています。 IPの名前空間を扱うプロセッサは、グループおよびインスタンス化表現の構文（DNS名、IPアドレス、バージョン）を決定するために必要とされます。"
    },
    {
      "indent": 3,
      "text": "SHA-2: This namespace carries address strings compliant with SHA-2 hash digests. The syntax of the group and instantiation follows the \"val\" definition in [RFC6920], Section 3. A processor handling those strings is required to determine the length of the expressions and passes appropriate values directly to a corresponding overlay.",
      "ja": "SHA-2：この名前空間は、SHA-2ハッシュダイジェストに準拠したアドレス文字列を運びます。グループの構文およびインスタンス[RFC6920]に「ヴァル」の定義を、以下、第3節は、これらの文字列を処理するプロセッサは、式の長さを決定するために必要とそれに対応するオーバーレイに直接適切な値を通過します。"
    },
    {
      "indent": 3,
      "text": "Opaque: This namespace transparently carries strings without further syntactical information, meanings, or associated resolution mechanisms. The corresponding syntax for the group and instantiation part of the ham-URI is defined in Section 4.2.1.",
      "ja": "不透明：この名前空間は透過さらに構文情報、意味、または関連する解決メカニズムなしで文字列を運びます。 HAM-URIのグループ及びインスタンス化部分に対応する構文は、セクション4.2.1で定義されています。"
    },
    {
      "indent": 0,
      "text": "4.2.4. Application-Centric Namespaces",
      "section_title": true,
      "ja": "4.2.4. アプリケーション中心の名前空間"
    },
    {
      "indent": 3,
      "text": "SIP: The SIP namespace is an example of an application-layer scheme that bears inherent group functions (conferencing). SIP conference URIs may be directly exchanged and interpreted at the application, and mapped to Group Addresses at the system level to generate a corresponding Multicast Group. The syntax of the group and instantiation is represented by the \"userinfo\" component [RFC3261], Section 25.1.",
      "ja": "SIP：SIP名前空間固有のグループ機能（会議）を担持するアプリケーション層スキームの一例です。 SIP会議URIは直接交換し、アプリケーションで解釈され、対応するマルチキャストグループを生成するために、システム・レベルでグループアドレスにマッピングすることができます。グループ及びインスタンス化の構文は、「ユーザー情報」成分[RFC3261]、セクション25.1で表されます。"
    },
    {
      "indent": 3,
      "text": "RELOAD: This namespace covers address strings that are valid in a REsource LOcation And Discovery [RELOAD] overlay network. A processor handling those strings may pass these values directly to a corresponding overlay that may manage multicast distribution according to [RFC7019].",
      "ja": "RELOAD：この名前空間は、リソースの場所と発見[RELOAD]オーバーレイ・ネットワークで有効なアドレス文字列をカバーしています。これらの文字列を処理するプロセッサは、[RFC7019]に記載のマルチキャスト配信を管理することができる、対応するオーバーレイに直接これらの値を渡すことができます。"
    },
    {
      "indent": 0,
      "text": "4.2.5. Future Namespaces",
      "section_title": true,
      "ja": "4.2.5. 今後の名前空間"
    },
    {
      "indent": 3,
      "text": "The concept of the common multicast API allows for any namespace that complies with the superset syntax defined in Section 4.2.1. This document specifies a basic set of Multicast Namespaces in Sections 4.2.3 and 4.2.4. If additional namespaces are needed in the future, a registry for those namespaces should be created and should be defined in a future document. All namespaces defined in such a document should then also be assigned to the registry.",
      "ja": "一般的なマルチキャストAPIの概念は、4.2.1項で定義されたスーパーセットの構文に準拠して任意の名前空間が可能になります。この文書は、セクション4.2.3と4.2.4でマルチキャスト名前空間の基本的なセットを指定します。追加の名前空間は、将来的に必要とされている場合は、これらの名前空間のレジストリを作成する必要がありますし、将来の文書で定義する必要があります。そのような文書で定義されたすべての名前空間は、その後も、レジストリに割り当てる必要があります。"
    },
    {
      "indent": 0,
      "text": "4.3. Additional Abstract Data Types",
      "section_title": true,
      "ja": "4.3. 追加の抽象データ型"
    },
    {
      "indent": 0,
      "text": "4.3.1. Interface",
      "section_title": true,
      "ja": "4.3.1. インタフェース"
    },
    {
      "indent": 3,
      "text": "The Interface denotes the layer and instance on which the corresponding call takes effect. In agreement with [RFC3493], we identify an Interface by an identifier, which is a positive integer starting at 1.",
      "ja": "インタフェースは、対応するコールが有効になるた層及びインスタンスを表します。 [RFC3493]と一致して、我々は、1から始まる正の整数識別子によってインタフェースを識別する。"
    },
    {
      "indent": 3,
      "text": "Properties of an Interface are stored in the following data structure:",
      "ja": "インターフェイスのプロパティは、次のようなデータ構造に格納されています。"
    },
    {
      "indent": 7,
      "text": "struct ifProp {\n  UnsignedInt if_index; /* 1, 2, ... */\n  String        *ifName;  /* \"eth0\", \"eth1:1\", \"lo\", ... */\n  String        *ifAddr;  /* \"1.2.3.4\", \"abc123\", ... */\n  String        *ifTech;  /* \"ip\", \"overlay\", ... */\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The following function retrieves all available Interfaces from the system:",
      "ja": "次の関数は、システムから利用可能なすべてのインターフェースを取得します。"
    },
    {
      "indent": 7,
      "text": "getInterfaces(out Interface <ifs>);",
      "ja": "でgetInterfaces（アウト・インタフェース<IFS>）;"
    },
    {
      "indent": 3,
      "text": "It extends the functions for Interface identification as defined in [RFC3493], Section 4 and can be implemented by:",
      "ja": "これは[RFC3493]で定義されるように、インタフェース識別するための機能を拡張部4によって実現することができます。"
    },
    {
      "indent": 7,
      "text": "struct ifProp(out IfProp <ifsProps>);",
      "ja": "構造体ifProp（アウトIfProp <ifsProps>）;"
    },
    {
      "indent": 0,
      "text": "4.3.2. Membership Events",
      "section_title": true,
      "ja": "4.3.2. 会員イベント"
    },
    {
      "indent": 3,
      "text": "A membership event is triggered by a multicast state change that is observed by the current node. It is related to a specific Group Name and may be receiver or source oriented.",
      "ja": "会員イベントは、現在のノードによって観測されたマルチキャスト状態変化によってトリガされます。これは、特定のグループ名に関連していると受信機またはソース配向させることができます。"
    },
    {
      "indent": 7,
      "text": "eventType {\n        joinEvent;\n        leaveEvent;\n        newSourceEvent;\n};",
      "raw": true
    },
    {
      "indent": 7,
      "text": "event {\n       EventType event;\n       Uri groupName;\n       Interface if;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "An event will be created by the group communication stack and passed to applications that have registered for events.",
      "ja": "イベントは、グループ通信スタックによって作成されたイベントのために登録されたアプリケーションに渡されます。"
    },
    {
      "indent": 0,
      "text": "4.4. Group Management Calls",
      "section_title": true,
      "ja": "4.4. グループ管理コール"
    },
    {
      "indent": 0,
      "text": "4.4.1. Create",
      "section_title": true,
      "ja": "4.4.1. 作ります"
    },
    {
      "indent": 3,
      "text": "The create call initiates a multicast socket and provides the application programmer with a corresponding handle. If no Interfaces will be assigned based on the call, the default Interface will be selected and associated with the socket. The call returns an error code in the case of failures, e.g., due to non-operational communication middleware.",
      "ja": "作成呼び出しはマルチキャストソケットを開始し、対応するハンドルをアプリケーションプログラマが用意されています。何のインターフェイスはコールに基づいて割り当てられません場合は、デフォルトのインタフェースが選択され、ソケットに関連付けられます。コールは、非動作通信ミドルウェアに、例えば故障の場合にエラーコードを返します。"
    },
    {
      "indent": 7,
      "text": "createMSocket(in Interface <ifs>,\n              out Socket s);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The ifs argument denotes a list of Interfaces (if_indexes) that will be associated with the multicast socket. This parameter is optional.",
      "ja": "IFS引数はマルチキャストソケットに関連するインターフェイス（if_indexes）のリストを示しています。このパラメータはオプションです。"
    },
    {
      "indent": 3,
      "text": "On success, a multicast socket identifier is returned; otherwise, it is NULL.",
      "ja": "成功した場合、マルチキャストソケット識別子が返されます。それ以外の場合はNULLです。"
    },
    {
      "indent": 0,
      "text": "4.4.2. Delete",
      "section_title": true,
      "ja": "4.4.2. 削除"
    },
    {
      "indent": 3,
      "text": "The delete call removes the multicast socket.",
      "ja": "削除コールは、マルチキャストソケットを削除します。"
    },
    {
      "indent": 7,
      "text": "deleteMSocket(in Socket s, out Int error);",
      "ja": "deleteMSocket（ソケットS、intエラーアウト）。"
    },
    {
      "indent": 3,
      "text": "The s argument identifies the multicast socket for destruction.",
      "ja": "引数sは破壊のためのマルチキャストソケットを識別します。"
    },
    {
      "indent": 3,
      "text": "On success, the out parameter error is 0; otherwise, -1 is returned.",
      "ja": "成功すると、outパラメータの誤差は0です。それ以外の場合は、-1が返されます。"
    },
    {
      "indent": 0,
      "text": "4.4.3. Join",
      "section_title": true,
      "ja": "4.4.3. 加わります"
    },
    {
      "indent": 3,
      "text": "The join call initiates a subscription for the given Group Name. Depending on the Interfaces that are associated with the socket, this may result in an IGMP / Multicast Listener Discovery (MLD) report or overlay subscription, for example.",
      "ja": "参加の呼び出しは、与えられたグループ名のサブスクリプションを開始します。ソケットに関連付けられているインタフェースに応じて、これは例えば、IGMP /マルチキャストリスナ発見（MLD）レポートまたはオーバーレイサブスクリプションをもたらすことができます。"
    },
    {
      "indent": 7,
      "text": "join(in Socket s, in Uri groupName, out Int error);",
      "ja": "参加（ウリグループ名には、ソケットの中に、intエラーアウト）。"
    },
    {
      "indent": 3,
      "text": "The s argument identifies the multicast socket.",
      "ja": "引数sは、マルチキャストソケットを識別します。"
    },
    {
      "indent": 3,
      "text": "The groupName argument identifies the group.",
      "ja": "グループ名の引数には、グループを識別します。"
    },
    {
      "indent": 3,
      "text": "On success, the out parameter error is 0; otherwise, -1 is returned.",
      "ja": "成功すると、outパラメータの誤差は0です。それ以外の場合は、-1が返されます。"
    },
    {
      "indent": 0,
      "text": "4.4.4. Leave",
      "section_title": true,
      "ja": "4.4.4. 去ります"
    },
    {
      "indent": 3,
      "text": "The leave call results in an unsubscription for the given Group Name.",
      "ja": "与えられたグループ名のために退会で休暇通話結果。"
    },
    {
      "indent": 7,
      "text": "leave(in Socket s, in Uri groupName, out Int error);",
      "ja": "残す（URIグループ名で、ソケットSに、intエラーアウト）。"
    },
    {
      "indent": 3,
      "text": "The s argument identifies the multicast socket.",
      "ja": "引数sは、マルチキャストソケットを識別します。"
    },
    {
      "indent": 3,
      "text": "The groupName argument identifies the group.",
      "ja": "グループ名の引数には、グループを識別します。"
    },
    {
      "indent": 3,
      "text": "On success, the out parameter error is 0; otherwise, -1 is returned.",
      "ja": "成功すると、outパラメータの誤差は0です。それ以外の場合は、-1が返されます。"
    },
    {
      "indent": 0,
      "text": "4.4.5. Source Register",
      "section_title": true,
      "ja": "4.4.5. ソースの登録"
    },
    {
      "indent": 3,
      "text": "The srcRegister call registers a source for a group on all active Interfaces of the socket s. This call may assist group distribution in some technologies -- for example, the creation of sub-overlays -- or may facilitate a name-to-address mapping. Likewise, it may remain without effect in some multicast technologies.",
      "ja": "srcRegisterコールはソケットSのすべてのアクティブインターフェイスのグループのソースを登録します。この呼び出しは、いくつかの技術のグループの配布を支援すること - 例えば、サブオーバーレイの作成 - または名前とアドレスのマッピングを容易にすることができます。同様に、それはいくつかのマルチキャスト技術に影響を与えずに残ることがあります。"
    },
    {
      "indent": 7,
      "text": "srcRegister(in Socket s, in Uri groupName,\n            out Interface <ifs>, out Int error);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The s argument identifies the multicast socket.",
      "ja": "引数sは、マルチキャストソケットを識別します。"
    },
    {
      "indent": 3,
      "text": "The groupName argument identifies the Multicast Group to which a source intends to send data.",
      "ja": "グループ名の引数は、ソースがデータを送信しようとどのマルチキャストグループを識別します。"
    },
    {
      "indent": 3,
      "text": "The ifs argument points to the list of Interface indexes for which the source registration failed. A NULL pointer is returned if the list is empty. This parameter is optional.",
      "ja": "ソースの登録が失敗したインターフェイスインデックスのリストにIFS引数ポイント。リストが空の場合はNULLポインタが返されます。このパラメータはオプションです。"
    },
    {
      "indent": 3,
      "text": "If source registration succeeded for all Interfaces associated with the socket, the out parameter error is 0; otherwise, -1 is returned.",
      "ja": "ソースの登録がソケットに関連付けられているすべてのインターフェイスのために成功した場合は、outパラメータの誤差は0です。それ以外の場合は、-1が返されます。"
    },
    {
      "indent": 0,
      "text": "4.4.6. Source Deregister",
      "section_title": true,
      "ja": "4.4.6. ソース登録解除"
    },
    {
      "indent": 3,
      "text": "The srcDeregister call indicates that a source no longer intends to send data to the Multicast Group. This call may remain without effect in some multicast technologies.",
      "ja": "srcDeregisterコールは、ソースがもはやマルチキャストグループにデータを送信しようとしていることを示していません。この呼び出しは、いくつかのマルチキャスト技術に影響を与えずに残ることがあります。"
    },
    {
      "indent": 7,
      "text": "srcDeregister(in Socket s, in Uri groupName,\n              out Interface <ifs>, out Int error);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The s argument identifies the multicast socket.",
      "ja": "引数sは、マルチキャストソケットを識別します。"
    },
    {
      "indent": 3,
      "text": "The groupName argument identifies the Multicast Group to which a source has stopped sending multicast data.",
      "ja": "グループ名の引数は、ソースがマルチキャストデータの送信を停止したマルチキャストグループを識別します。"
    },
    {
      "indent": 3,
      "text": "The ifs argument points to the list of Interfaces for which the source deregistration failed. A NULL pointer is returned if the list is empty.",
      "ja": "ソース登録解除に失敗したインタフェースのリストにIFS引数ポイント。リストが空の場合はNULLポインタが返されます。"
    },
    {
      "indent": 3,
      "text": "If source deregistration succeeded for all Interfaces associated with the socket, the out parameter error is 0; otherwise, -1 is returned.",
      "ja": "ソース登録解除はソケットに関連付けられているすべてのインターフェイスのために成功した場合は、outパラメータの誤差は0です。それ以外の場合は、-1が返されます。"
    },
    {
      "indent": 0,
      "text": "4.5. Send and Receive Calls",
      "section_title": true,
      "ja": "4.5. 通話を送受信"
    },
    {
      "indent": 0,
      "text": "4.5.1. Send",
      "section_title": true,
      "ja": "4.5.1. 送ります"
    },
    {
      "indent": 3,
      "text": "The send call passes multicast data destined for a Multicast Name from the application to the multicast socket.",
      "ja": "送信呼び出しは、マルチキャストソケットへのアプリケーションからマルチキャスト名前宛てのマルチキャストデータを渡します。"
    },
    {
      "indent": 3,
      "text": "It is worth noting that it is the choice of the programmer to send data via one socket per group or to use a single socket for multiple groups.",
      "ja": "グループごとに1つのソケットを介してデータを送信したり、複数のグループのための単一のソケットを使用するプログラマの選択であることは注目に値します。"
    },
    {
      "indent": 7,
      "text": "send(in Socket s, in Uri groupName,\n     in Size msgLen, in Msg msgBuf,\n     out Int error);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The s argument identifies the multicast socket.",
      "ja": "引数sは、マルチキャストソケットを識別します。"
    },
    {
      "indent": 3,
      "text": "The groupName argument identifies the group to which data will be sent.",
      "ja": "グループ名の引数は、データが送信されますするグループを識別します。"
    },
    {
      "indent": 3,
      "text": "The msgLen argument holds the length of the message to be sent.",
      "ja": "さmsglen引数は、送信するメッセージの長さを保持しています。"
    },
    {
      "indent": 3,
      "text": "The msgBuf argument passes the multicast data to the multicast socket.",
      "ja": "MSGBUF引数は、マルチキャストソケットへのマルチキャストデータを渡します。"
    },
    {
      "indent": 3,
      "text": "On success, the out parameter error is 0; otherwise, -1 is returned. A message that is too long is indicated by an implementation-specific error code (e.g., EMSGSIZE in C).",
      "ja": "成功すると、outパラメータの誤差は0です。それ以外の場合は、-1が返されます。長すぎるメッセージは、実装固有のエラーコード（Cで例えば、EMSGSIZE）で示されています。"
    },
    {
      "indent": 0,
      "text": "4.5.2. Receive",
      "section_title": true,
      "ja": "4.5.2. 受け取ります"
    },
    {
      "indent": 3,
      "text": "The receive call passes multicast data and the corresponding Group Name to the application. This may come in a blocking or non-blocking variant.",
      "ja": "受信呼び出しは、マルチキャストデータやアプリケーションに対応するグループ名を渡します。これは、ブロッキングまたは非ブロッキングバリアントで来るかもしれません。"
    },
    {
      "indent": 3,
      "text": "It is worth noting that it is the choice of the programmer to receive data via one socket per group or to use a single socket for multiple groups.",
      "ja": "グループごとに1つのソケットを介してデータを送受信したり、複数のグループのための単一のソケットを使用するプログラマの選択であることは注目に値します。"
    },
    {
      "indent": 7,
      "text": "receive(in Socket s, out Uri groupName,\n        out Size msgLen, out Msg msgBuf,\n        out Int error);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The s argument identifies the multicast socket.",
      "ja": "引数sは、マルチキャストソケットを識別します。"
    },
    {
      "indent": 3,
      "text": "The groupName argument identifies the Multicast Group for which data was received.",
      "ja": "グループ名の引数は、データが受信されたマルチキャストグループを識別します。"
    },
    {
      "indent": 3,
      "text": "The msgLen argument holds the length of the received message.",
      "ja": "さmsglen引数は、受信したメッセージの長さを保持しています。"
    },
    {
      "indent": 3,
      "text": "The msgBuf argument points to the payload of the received multicast data.",
      "ja": "受信したマルチキャストデータのペイロードにMSGBUF引数ポイント。"
    },
    {
      "indent": 3,
      "text": "On success, the out parameter error is 0; otherwise, -1 is returned. A message that is too long is indicated by an implementation-specific error code (e.g., EMSGSIZE).",
      "ja": "成功すると、outパラメータの誤差は0です。それ以外の場合は、-1が返されます。長すぎるメッセージは、実装固有のエラーコード（例えば、EMSGSIZE）で示されています。"
    },
    {
      "indent": 0,
      "text": "4.6. Socket Options",
      "section_title": true,
      "ja": "4.6. ソケットオプション"
    },
    {
      "indent": 3,
      "text": "The following calls configure an existing multicast socket.",
      "ja": "次の呼び出しは、既存のマルチキャストソケットを設定します。"
    },
    {
      "indent": 0,
      "text": "4.6.1. Get Interfaces",
      "section_title": true,
      "ja": "4.6.1. インタフェースを取得"
    },
    {
      "indent": 3,
      "text": "The getInterfaces call returns an array of all available multicast communication Interfaces associated with the multicast socket.",
      "ja": "でgetInterfacesマルチキャストソケットに関連付けられたすべての利用可能なマルチキャスト通信インターフェースのアレイリターンを呼び出します。"
    },
    {
      "indent": 7,
      "text": "getInterfaces(in Socket s,\n              out Interface <ifs>, out Int error);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The s argument identifies the multicast socket.",
      "ja": "引数sは、マルチキャストソケットを識別します。"
    },
    {
      "indent": 3,
      "text": "The ifs argument points to an array of Interface index identifiers.",
      "ja": "インターフェイスインデックス識別子の配列にIFS引数ポイント。"
    },
    {
      "indent": 3,
      "text": "On success, the out parameter error is 0; otherwise, -1 is returned.",
      "ja": "成功すると、outパラメータの誤差は0です。それ以外の場合は、-1が返されます。"
    },
    {
      "indent": 0,
      "text": "4.6.2. Add Interface",
      "section_title": true,
      "ja": "4.6.2. インタフェースを追加"
    },
    {
      "indent": 3,
      "text": "The addInterface call adds a distribution channel to the socket. This may be an overlay or underlay Interface, e.g., IPv6 or Distributed Hash Table (DHT). Multiple Interfaces of the same technology may be associated with the socket.",
      "ja": "addInterfaceコールは、ソケットに流通チャネルを追加します。これは、オーバーレイまたはアンダーレイ・インタフェース、例えば、IPv6の又は分散ハッシュテーブル（DHT）であってもよいです。同じ技術の複数のインタフェースはソケットに関連することができます。"
    },
    {
      "indent": 7,
      "text": "addInterface(in Socket s, in Interface if,\n             out Int error);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The s and if arguments identify a multicast socket and Interface, respectively.",
      "ja": "sおよび引数はそれぞれ、マルチキャストソケットおよびインターフェイスを識別します。"
    },
    {
      "indent": 3,
      "text": "On success, the value 0 is returned; otherwise, -1 is returned.",
      "ja": "成功した場合、値0が返されます。それ以外の場合は、-1が返されます。"
    },
    {
      "indent": 0,
      "text": "4.6.3. Delete Interface",
      "section_title": true,
      "ja": "4.6.3. インターフェイスを削除します"
    },
    {
      "indent": 3,
      "text": "The delInterface call removes the Interface from the multicast socket.",
      "ja": "delInterfaceコールは、マルチキャストソケットからインターフェイスを削除します。"
    },
    {
      "indent": 7,
      "text": "delInterface(in Socket s, Interface if,\n             out Int error);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The s and if arguments identify a multicast socket and Interface, respectively.",
      "ja": "sおよび引数はそれぞれ、マルチキャストソケットおよびインターフェイスを識別します。"
    },
    {
      "indent": 3,
      "text": "On success, the out parameter error is 0; otherwise, -1 is returned.",
      "ja": "成功すると、outパラメータの誤差は0です。それ以外の場合は、-1が返されます。"
    },
    {
      "indent": 0,
      "text": "4.6.4. Set TTL",
      "section_title": true,
      "ja": "4.6.4.  TTLを設定します。"
    },
    {
      "indent": 3,
      "text": "The setTTL call configures the maximum hop count for the socket that a multicast message is allowed to traverse.",
      "ja": "setTTLコールは、マルチキャストメッセージが通過することを許可されているソケットの最大ホップカウントを設定します。"
    },
    {
      "indent": 7,
      "text": "setTTL(in Socket s, in Int h,\n       in Interface <ifs>,\n       out Int error);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The s and h arguments identify a multicast socket and the maximum hop count, respectively.",
      "ja": "S及びH引数はそれぞれ、マルチキャストソケットと最大ホップカウントを識別する。"
    },
    {
      "indent": 3,
      "text": "The ifs argument points to an array of Interface index identifiers. This parameter is optional.",
      "ja": "インターフェイスインデックス識別子の配列にIFS引数ポイント。このパラメータはオプションです。"
    },
    {
      "indent": 3,
      "text": "On success, the out parameter error is 0; otherwise, -1 is returned.",
      "ja": "成功すると、outパラメータの誤差は0です。それ以外の場合は、-1が返されます。"
    },
    {
      "indent": 0,
      "text": "4.6.5. Get TTL",
      "section_title": true,
      "ja": "4.6.5.  TTLを取得"
    },
    {
      "indent": 3,
      "text": "The getTTL call returns the maximum hop count that a multicast message is allowed to traverse for the interface bound to the socket.",
      "ja": "getTTLコールは、マルチキャストメッセージがソケットにバインドされたインターフェースのために通過することを許可される最大ホップ数を返します。"
    },
    {
      "indent": 7,
      "text": "getTTL(in Socket s, in Interface if,\n       out Int h, out Int error);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The s argument identifies a multicast socket.",
      "ja": "引数sは、マルチキャストソケットを識別します。"
    },
    {
      "indent": 3,
      "text": "The if argument identifies an interface that is bound to socket s.",
      "ja": "もし引数がsをソケットにバインドされたインターフェイスを識別します。"
    },
    {
      "indent": 3,
      "text": "The h argument holds the maximum number of hops associated with the interface.",
      "ja": "H引数は、インターフェイスに関連付けられたホップの最大数を保持します。"
    },
    {
      "indent": 3,
      "text": "On success, the out parameter error is 0; otherwise, -1 is returned.",
      "ja": "成功すると、outパラメータの誤差は0です。それ以外の場合は、-1が返されます。"
    },
    {
      "indent": 0,
      "text": "4.6.6. Atomic Message Size",
      "section_title": true,
      "ja": "4.6.6. アトミックメッセージサイズ"
    },
    {
      "indent": 3,
      "text": "The getAtomicMsgSize function returns the maximum message size that an application is allowed to transmit per socket at once without fragmentation. This value depends on the Interfaces associated with the socket in use and thus may change during runtime.",
      "ja": "getAtomicMsgSize関数は、アプリケーションが断片化することなく、一度にソケット当たりの送信を許可された最大メッセージサイズを返します。この値は、使用中のソケットに関連付けられたインタフェースに依存し、したがって、実行時に変更されることがあります。"
    },
    {
      "indent": 7,
      "text": "getAtomicMsgSize(in Socket s,\n                 out Int return);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "On success, the function returns a positive value of appropriate message size; otherwise, -1 is returned.",
      "ja": "成功すると、関数は、適切なメッセージサイズの正の値を返します。それ以外の場合は、-1が返されます。"
    },
    {
      "indent": 0,
      "text": "4.7. Service Calls",
      "section_title": true,
      "ja": "4.7. サービスコール"
    },
    {
      "indent": 0,
      "text": "4.7.1. Group Set",
      "section_title": true,
      "ja": "4.7.1. グループセット"
    },
    {
      "indent": 3,
      "text": "The groupSet call returns all Multicast Groups registered at a given Interface. This information can be provided by group management states or routing protocols. The return values distinguish between sender and listener states.",
      "ja": "グループセットのコールは、指定されたインターフェイスで登録されているすべてのマルチキャストグループを返します。この情報は、グループ管理状態またはルーティングプロトコルによって提供することができます。戻り値は、送信者とリスナーの状態を区別します。"
    },
    {
      "indent": 7,
      "text": "struct GroupSet {\n  Uri groupName; /* registered Multicast Group */\n  Int type;       /* 0 = listener state, 1 = sender state,\n                     2 = sender and listener state */\n}",
      "raw": true
    },
    {
      "indent": 7,
      "text": "groupSet(in Interface if, out GroupSet <groupSet>, out Int error);",
      "ja": "グループセット（インターフェースであれば、グループセット<グループセット>アウト、intエラーアウト）。"
    },
    {
      "indent": 3,
      "text": "The if argument identifies the Interface for which states are maintained.",
      "ja": "もし引数は、状態が維持されるためのインターフェイスを識別します。"
    },
    {
      "indent": 3,
      "text": "The groupSet argument points to a list of group states.",
      "ja": "グループセットの引数には、グループの状態のリストを指します。"
    },
    {
      "indent": 3,
      "text": "On success, the out parameter error is 0; otherwise, -1 is returned.",
      "ja": "成功すると、outパラメータの誤差は0です。それ以外の場合は、-1が返されます。"
    },
    {
      "indent": 0,
      "text": "4.7.2. Neighbor Set",
      "section_title": true,
      "ja": "4.7.2. ネイバーセット"
    },
    {
      "indent": 3,
      "text": "The neighborSet function returns the set of neighboring nodes for a given Interface as seen by the multicast routing protocol.",
      "ja": "neighborSet機能は、マルチキャストルーティングプロトコルによって見られるように所定のインターフェイスのための隣接ノードのセットを返します。"
    },
    {
      "indent": 7,
      "text": "neighborSet(in Interface if,\n            out Uri <neighborsAddresses>, out Int error);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The if argument identifies the Interface for which information regarding neighbors is requested.",
      "ja": "もし引数ネイバーに関する情報が要求されているインターフェイスを識別します。"
    },
    {
      "indent": 3,
      "text": "The neighborsAddresses argument points to a list of neighboring nodes on a successful return.",
      "ja": "成功したリターンの隣接ノードのリストにneighborsAddresses引数ポイント。"
    },
    {
      "indent": 3,
      "text": "On success, the out parameter error is 0; otherwise, -1 is returned.",
      "ja": "成功すると、outパラメータの誤差は0です。それ以外の場合は、-1が返されます。"
    },
    {
      "indent": 0,
      "text": "4.7.3. Children Set",
      "section_title": true,
      "ja": "4.7.3. 子どもを設定"
    },
    {
      "indent": 3,
      "text": "The childrenSet function returns the set of child nodes that receive multicast data from a specified Interface for a given group. For a common multicast router, this call retrieves the multicast forwarding information base per Interface.",
      "ja": "childrenSet関数は、指定されたグループのために指定されたインタフェースからマルチキャストデータを受信する子ノードのセットを返します。共通のマルチキャストルータの場合、この呼び出しは、インタフェースごとのマルチキャスト転送情報ベースを検索します。"
    },
    {
      "indent": 7,
      "text": "childrenSet(in Interface if, in Uri groupName,\n            out Uri <childrenAddresses>, out Int error);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The if argument identifies the Interface for which information regarding children is requested.",
      "ja": "もし引数は、子供に関する情報が要求されているインターフェイスを識別します。"
    },
    {
      "indent": 3,
      "text": "The groupName argument defines the Multicast Group for which distribution is considered.",
      "ja": "グループ名の引数は、分布を考慮したマルチキャストグループを定義します。"
    },
    {
      "indent": 3,
      "text": "The childrenAddresses argument points to a list of neighboring nodes on a successful return.",
      "ja": "成功リターンで、隣接ノードのリストにchildrenAddresses引数ポイント。"
    },
    {
      "indent": 3,
      "text": "On success, the out parameter error is 0; otherwise, -1 is returned.",
      "ja": "成功すると、outパラメータの誤差は0です。それ以外の場合は、-1が返されます。"
    },
    {
      "indent": 0,
      "text": "4.7.4. Parent Set",
      "section_title": true,
      "ja": "4.7.4. 母集団"
    },
    {
      "indent": 3,
      "text": "The parentSet function returns the set of neighbors from which the current node receives multicast data at a given Interface for the specified group.",
      "ja": "parentSet関数は、現在のノードが指定されたグループの特定のインターフェイスにマルチキャストデータを受信し、そこから近隣のセットを返します。"
    },
    {
      "indent": 7,
      "text": "parentSet(in Interface if, in Uri groupName,\n          out Uri <parentsAddresses>, out Int error);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The if argument identifies the Interface for which information regarding parents is requested.",
      "ja": "もし引数両親に関する情報が要求されているインターフェイスを識別します。"
    },
    {
      "indent": 3,
      "text": "The groupName argument defines the Multicast Group for which distribution is considered.",
      "ja": "グループ名の引数は、分布を考慮したマルチキャストグループを定義します。"
    },
    {
      "indent": 3,
      "text": "The parentsAddresses argument points to a list of neighboring nodes on a successful return.",
      "ja": "成功したリターンの隣接ノードのリストにparentsAddresses引数ポイント。"
    },
    {
      "indent": 3,
      "text": "On success, the out parameter error is 0; otherwise, -1 is returned.",
      "ja": "成功すると、outパラメータの誤差は0です。それ以外の場合は、-1が返されます。"
    },
    {
      "indent": 0,
      "text": "4.7.5. Designated Host",
      "section_title": true,
      "ja": "4.7.5. 指定されたホスト"
    },
    {
      "indent": 3,
      "text": "The designatedHost function inquires about whether this host has the role of a designated forwarder (or querier), or not. Such information is provided by almost all multicast protocols to prevent packet duplication, if multiple multicast instances provide service on the same subnet.",
      "ja": "designatedHost機能は、このホストが指定フォワーダ（またはクエリア）の役割を持っているか、いないかどうかを問い合わせます。このような情報は、複数のマルチキャストのインスタンスが同じサブネット上のサービスを提供する場合、パケットの重複を防ぐために、ほとんどすべてのマルチキャストプロトコルによって提供されます。"
    },
    {
      "indent": 7,
      "text": "designatedHost(in Interface if, in Uri groupName\n               out Int return);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The if argument identifies the Interface for which information regarding designated forwarding is requested.",
      "ja": "もし引数が指定された転送に関する情報を要求されたインターフェイスを識別します。"
    },
    {
      "indent": 3,
      "text": "The groupName argument specifies the group for which the host may attain the role of designated forwarder.",
      "ja": "グループ名の引数は、ホストが指定フォワーダの役割を達成する可能性があるためにグループを指定します。"
    },
    {
      "indent": 3,
      "text": "The function returns 1 if the host is a designated forwarder or querier. The return value -1 indicates an error. Otherwise, 0 is returned.",
      "ja": "ホストが指定フォワーダまたはクエリアである場合、関数は1を返します。戻り値が-1のエラーを示します。それ以外の場合は、0が返されます。"
    },
    {
      "indent": 0,
      "text": "4.7.6. Enable Membership Events",
      "section_title": true,
      "ja": "4.7.6. メンバーシップのイベントを有効にします"
    },
    {
      "indent": 3,
      "text": "The enableEvents function registers an application at the group communication stack to receive information about group changes. State changes are the result of new receiver subscriptions or leaves, as well as source changes. Upon receiving an event, the group service may obtain additional information from further service calls.",
      "ja": "enableEvents関数は、グループの変更に関する情報を受信するグループ通信スタックでアプリケーションを登録します。状態の変化は、新たな受信機のサブスクリプションまたは葉と同様に、ソースの変更の結果です。イベントを受信すると、グループサービスはさらに、サービス呼び出しから追加情報を得ることができます。"
    },
    {
      "indent": 7,
      "text": "enableEvents();",
      "ja": "enableEvents（）;"
    },
    {
      "indent": 3,
      "text": "Calling this function, the stack starts to pass membership events to the application. Each event includes an event type identifier and a Group Name (cf. Section 4.3.2).",
      "ja": "この関数を呼び出すと、スタックは、アプリケーションへのメンバーシップのイベントを渡すように開始します。各イベントは、イベントタイプ識別子とグループ名（参照セクション4.3.2）を含みます。"
    },
    {
      "indent": 3,
      "text": "The multicast protocol does not have to support membership tracking in order to enable this feature. This function can also be implemented at the middleware layer.",
      "ja": "マルチキャストプロトコルは、この機能を有効にするためには、会員の追跡をサポートする必要はありません。この機能は、ミドルウェア層で実装することができます。"
    },
    {
      "indent": 0,
      "text": "4.7.7. Disable Membership Events",
      "section_title": true,
      "ja": "4.7.7. メンバーシップのイベントを無効にします"
    },
    {
      "indent": 3,
      "text": "The disableEvents function deactivates the information about group state changes.",
      "ja": "disableEvents機能は、グループの状態の変化に関する情報を無効にします。"
    },
    {
      "indent": 7,
      "text": "disableEvents();",
      "ja": "disableEvents（）;"
    },
    {
      "indent": 3,
      "text": "On success, the stack will not pass membership events to the application.",
      "ja": "成功した場合、スタックは、アプリケーションへのメンバーシップのイベントを渡しません。"
    },
    {
      "indent": 0,
      "text": "4.7.8. Maximum Message Size",
      "section_title": true,
      "ja": "4.7.8. 最大メッセージサイズ"
    },
    {
      "indent": 3,
      "text": "The getMaxMsgSize function returns the maximum message size that an application is allowed to transmit per socket at once. This value is statically guaranteed by the group communication stack.",
      "ja": "getMaxMsgSize関数は、アプリケーションが一度にソケット当たりの送信を許可された最大メッセージサイズを返します。この値は、静的グループ通信スタックによって保証されています。"
    },
    {
      "indent": 7,
      "text": "getMaxMsgSize(out Int return);",
      "ja": "getMaxMsgSize（のIntリターンアウト）。"
    },
    {
      "indent": 3,
      "text": "On success, the function returns a positive value of allowed message size; otherwise, -1 is returned.",
      "ja": "成功すると、関数は、許可メッセージサイズの正の値を返します。それ以外の場合は、-1が返されます。"
    },
    {
      "indent": 0,
      "text": "5. Implementation",
      "section_title": true,
      "ja": "5.実装"
    },
    {
      "indent": 3,
      "text": "A reference implementation of the Common API for Transparent Hybrid Multicast is available with the HAMcast stack [HAMcast-DEV] [GC2010] [LCN2012]. This open-source software supports the multicast API (C++ and Java library) for group application development, the middleware as a user space system service, and several multicast-technology modules. The middleware is implemented in C++.",
      "ja": "透明ハイブリッドマルチキャストのための共通APIのリファレンス実装は、[LCN2012] [GC2010] HAMcastスタック[HAMcast-DEV]で利用可能です。このオープンソースソフトウェアは、グループのアプリケーション開発のためのマルチキャストAPI（C ++およびJavaライブラリ）をサポートし、ユーザー空間のシステムサービス、およびいくつかのマルチキャスト技術モジュールとしてミドルウェア。ミドルウェアは、C ++で実装されています。"
    },
    {
      "indent": 3,
      "text": "This API is verified and adjusted based on the real-world experiences gathered in the HAMcast project, and by additional users of the stack.",
      "ja": "このAPIは、HAMcastプロジェクトでは、スタックの追加のユーザーによって収集された実世界の経験に基づいて検証し、調整されています。"
    },
    {
      "indent": 0,
      "text": "6. IANA Considerations",
      "section_title": true,
      "ja": "6. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document specifies the \"ham\" URI scheme that has been registered by IANA as one of the \"Provisional URI Schemes\" according to [RFC4395].",
      "ja": "この文書では、「ハム」[RFC4395]によれば、「仮URIスキーム」の一つとして、IANAによって登録されたURIスキームを指定します。"
    },
    {
      "indent": 3,
      "text": "URI scheme name ham",
      "ja": "URIのスキーム名のハム"
    },
    {
      "indent": 3,
      "text": "Status provisional",
      "ja": "仮ステータス"
    },
    {
      "indent": 3,
      "text": "URI scheme syntax See Section 4.2.1.",
      "ja": "URIスキームの構文は、4.2.1項を参照してください。"
    },
    {
      "indent": 3,
      "text": "URI scheme semantics See Section 4.2.2.",
      "ja": "URIスキームのセマンティクスは、セクション4.2.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Encoding See Section 4.2.1 considerations",
      "ja": "エンコードを参照してくださいセクション4.2.1考慮事項"
    },
    {
      "indent": 3,
      "text": "Applications/protocols The scheme is used by multicast applications that use this URI to access multicast content. scheme name",
      "ja": "アプリケーション/スキームは、マルチキャストコンテンツにアクセスするには、このURIを使用して、マルチキャストアプリケーションで使用されるプロトコル。スキーム名"
    },
    {
      "indent": 3,
      "text": "Interoperability None considerations",
      "ja": "相互運用性なし注意事項"
    },
    {
      "indent": 3,
      "text": "Security See Section 7. considerations",
      "ja": "セキュリティを参照してくださいセクション7.注意事項"
    },
    {
      "indent": 3,
      "text": "Contact Matthias Waehlisch, mw@link-lab.net",
      "ja": "連絡先マティアスWählisch、mw@link-lab.net"
    },
    {
      "indent": 3,
      "text": "Author/Change IRTF controller",
      "ja": "著者/変更IRTFコントローラ"
    },
    {
      "indent": 3,
      "text": "References As specified in this document.",
      "ja": "この文書で指定されているように参照。"
    },
    {
      "indent": 0,
      "text": "7. Security Considerations",
      "section_title": true,
      "ja": "7.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document does not introduce additional messages or novel protocol operations.",
      "ja": "この文書では、追加のメッセージまたは新しいプロトコルオペレーションを導入しません。"
    },
    {
      "indent": 0,
      "text": "8. Acknowledgements",
      "section_title": true,
      "ja": "8.謝辞"
    },
    {
      "indent": 3,
      "text": "We would like to thank the HAMcast team at the HAW Hamburg -- Nora Berg, Gabriel Hege, Fabian Holler, Alexander Knauf, Sebastian Meiling, Sebastian Woelke, and Sebastian Zagaria -- for many fruitful discussions and for their continuous critical feedback while implementing the common multicast API and hybrid multicast middleware. Special thanks to Dominik Charousset of the HAMcast team for in-depth perspectives on the matter of code. We gratefully acknowledge WeeSan, Mario Kolberg, and John Buford for reviewing and their suggestions to improve the document. We would like to thank the Name-Based Socket BoF (in particular Dave Thaler) for clarifying insights into the question of meta-function calls. We thank Lisandro Zambenedetti Granville and Tony Li for very careful reviews of the pre-final versions of this document. Barry Leiba and Graham Klyne provided very constructive input to find a suitable URI scheme. They are gratefully acknowledged.",
      "ja": "ノラベルク、ガブリエルHEGE、ファビアン大声、アレクサンダークナウフ、セバスチャン美鈴、セバスチャンWoelke、とセバスチャンZagaria  -   - 私たちは、HAWハンブルクでHAMcastチームに感謝したい実装しながら、多くの実りある議論をし、その継続的な批判的なフィードバックのために一般的なマルチキャストAPIとハイブリッドマルチキャストミドルウェア。コードの問題に関する詳細な視点用HAMcastチームのドミニクCharoussetに感謝します。我々は感謝して、ドキュメントを改善するために検討し、その提案をWeeSan、マリオKOLBERG、そしてジョン・ビュフォードを認めます。私たちは、メタ関数呼び出しの問題に洞察を明確にするために（特にデーブターラーで）名前ベースソケットのBoFに感謝したいと思います。私たちは、この文書の前の最終バージョンの非常に慎重なレビューのためにリサンドロZambenedettiグランビルとトニー李に感謝します。バリー・レイバとグラハムKlyneは、適切なURIスキームを見つけることは非常に建設的な入力を提供します。彼らは深く感謝しています。"
    },
    {
      "indent": 3,
      "text": "This work is partially supported by the German Federal Ministry of Education and Research within the HAMcast project (see <http://hamcast.realmv6.org>), which is part of G-Lab.",
      "ja": "この作業は、部分的にG-ラボの一部であるHAMcastプロジェクト内の教育研究のドイツ連邦環境省（<http://hamcast.realmv6.org>参照）、によってサポートされています。"
    },
    {
      "indent": 0,
      "text": "9. References",
      "section_title": true,
      "ja": "9.参考文献"
    },
    {
      "indent": 0,
      "text": "9.1. Normative References",
      "section_title": true,
      "ja": "9.1. 引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC1075] Waitzman, D., Partridge, C., and S. Deering, \"Distance Vector Multicast Routing Protocol\", RFC 1075, November 1988.",
      "ja": "[RFC1075] Waitzman、D.、ヤマウズラ、C.、およびS.デアリング、 \"距離ベクトルマルチキャストルーティングプロトコル\"、RFC 1075、1988年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC2710] Deering, S., Fenner, W., and B. Haberman, \"Multicast Listener Discovery (MLD) for IPv6\", RFC 2710, October 1999.",
      "ja": "[RFC2710]デアリング、S.、フェナー、W.、およびB.ハーバーマン、 \"IPv6のためのマルチキャストリスナー発見（MLD）\"、RFC 2710、1999年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC3261] Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston, A., Peterson, J., Sparks, R., Handley, M., and E. Schooler, \"SIP: Session Initiation Protocol\", RFC 3261, June 2002.",
      "ja": "[RFC3261]ローゼンバーグ、J.、Schulzrinneと、H.、カマリロ、G.、ジョンストン、A.、ピーターソン、J.、スパークス、R.、ハンドレー、M.、およびE.学生、 \"SIP：セッション開始プロトコル\" 、RFC 3261、2002年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC3376] Cain, B., Deering, S., Kouvelas, I., Fenner, B., and A. Thyagarajan, \"Internet Group Management Protocol, Version 3\", RFC 3376, October 2002.",
      "ja": "[RFC3376]カイン、B.、デアリング、S.、Kouvelas、I.、フェナー、B.、およびA. Thyagarajan、 \"インターネットグループ管理プロトコル、バージョン3\"、RFC 3376、2002年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC3493] Gilligan, R., Thomson, S., Bound, J., McCann, J., and W. Stevens, \"Basic Socket Interface Extensions for IPv6\", RFC 3493, February 2003.",
      "ja": "[RFC3493]ギリガン、R.、トムソン、S.、バウンド、J.、マッキャン、J.、およびW.スティーブンス、 \"IPv6の基本的なソケットインタフェース拡張\"、RFC 3493、2003年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC3678] Thaler, D., Fenner, B., and B. Quinn, \"Socket Interface Extensions for Multicast Source Filters\", RFC 3678, January 2004.",
      "ja": "[RFC3678]ターラー、D.、フェナー、B.、およびB.クイン、RFC 3678 \"マルチキャストソースフィルタのためのソケットインタフェース拡張\"、2004年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC3810] Vida, R. and L. Costa, \"Multicast Listener Discovery Version 2 (MLDv2) for IPv6\", RFC 3810, June 2004.",
      "ja": "\"IPv6のマルチキャストリスナ発見バージョン2（MLDv2の）\" [RFC3810]ヴィーダ、R.とL.コスタ、RFC 3810、2004年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC3986] Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform Resource Identifier (URI): Generic Syntax\", STD 66, RFC 3986, January 2005.",
      "ja": "[RFC3986]バーナーズ - リー、T.、フィールディング、R.、およびL. Masinter、 \"ユニフォームリソース識別子（URI）：汎用構文\"、STD 66、RFC 3986、2005年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC4395] Hansen, T., Hardie, T., and L. Masinter, \"Guidelines and Registration Procedures for New URI Schemes\", BCP 35, RFC 4395, February 2006.",
      "ja": "[RFC4395]ハンセン、T.、ハーディ、T.、およびL. Masinter、 \"新しいURIスキームのためのガイドラインと登録手順\"、BCP 35、RFC 4395、2006年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC4601] Fenner, B., Handley, M., Holbrook, H., and I. Kouvelas, \"Protocol Independent Multicast - Sparse Mode (PIM-SM): Protocol Specification (Revised)\", RFC 4601, August 2006.",
      "ja": "[RFC4601]フェナー、B.、ハンドリー、M.、ホルブルック、H.、およびI. Kouvelas、 \"プロトコル独立マルチキャスト - スパースモード（PIM-SM）：プロトコル仕様（改訂）\"、RFC 4601、2006年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC4604] Holbrook, H., Cain, B., and B. Haberman, \"Using Internet Group Management Protocol Version 3 (IGMPv3) and Multicast Listener Discovery Protocol Version 2 (MLDv2) for Source-Specific Multicast\", RFC 4604, August 2006.",
      "ja": "[RFC4604]ホルブルック、H.、カイン、B.、およびB.ハーバーマン、 \"ソース固有マルチキャストのためにインターネットグループ管理プロトコルバージョン3（IGMPv3の）およびマルチキャストリスナ発見プロトコルバージョン2（MLDv2の）の使用\"、RFC 4604、8月2006。"
    },
    {
      "indent": 3,
      "text": "[RFC5015] Handley, M., Kouvelas, I., Speakman, T., and L. Vicisano, \"Bidirectional Protocol Independent Multicast (BIDIR-PIM)\", RFC 5015, October 2007.",
      "ja": "[RFC5015]ハンドレー、M.、Kouvelas、I.、スピークマン、T.、およびL. Vicisano、 \"双方向プロトコル独立マルチキャスト（BIDIR-PIM）\"、RFC 5015、2007年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC5058] Boivie, R., Feldman, N., Imai, Y., Livens, W., and D. Ooms, \"Explicit Multicast (Xcast) Concepts and Options\", RFC 5058, November 2007.",
      "ja": "[RFC5058] Boivie、R.、フェルドマン、N.、今井、Y.、Livens、W.、およびD. Ooms、 \"明示的なマルチキャスト（のXcast）の概念とオプション\"、RFC 5058、2007年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC5234] Crocker, D. and P. Overell, \"Augmented BNF for Syntax Specifications: ABNF\", STD 68, RFC 5234, January 2008.",
      "ja": "[RFC5234]クロッカー、D.、およびP. Overell、 \"構文仕様のための増大しているBNF：ABNF\"、STD 68、RFC 5234、2008年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC6920] Farrell, S., Kutscher, D., Dannewitz, C., Ohlman, B., Keranen, A., and P. Hallam-Baker, \"Naming Things with Hashes\", RFC 6920, April 2013.",
      "ja": "[RFC6920]ファレル、S.、Kutscher、D.、Dannewitz、C.、Ohlman、B.、Keranen、A.、およびP.ハラム・ベーカー、 \"ハッシュで物事を命名\"、RFC 6920、2013年4月。"
    },
    {
      "indent": 0,
      "text": "9.2. Informative References",
      "section_title": true,
      "ja": "9.2. 参考文献"
    },
    {
      "indent": 3,
      "text": "[AMT] Bumgardner, G., \"Automatic Multicast Tunneling\", Work in Progress, October 2013.",
      "ja": "[AMT] Bumgardner、G.、 \"自動マルチキャストトンネリング\"、進歩、2013年10月に作業します。"
    },
    {
      "indent": 3,
      "text": "[GC2010] Meiling, S., Charousset, D., Schmidt, T., and M. Waehlisch, \"System-assisted Service Evolution for a Future Internet - The HAMcast Approach to Pervasive Multicast\", Proc. IEEE GLOBECOM 2010 Workshops, MCS 2010, pp. 913-917, Piscataway, NJ, USA, IEEE Press, December 2010.",
      "ja": "【GC2010]美鈴、S.、Charousset、D.、シュミット、T。、およびM. Waehlisch、「システム支援次世代のインターネットサービス進化 - パーベイシブマルチキャストにHAMcastアプローチ」、PROC。 IEEEのGLOBECOM 2010ワークショップ、MCS 2010、頁913から917、ピスカタウェイ、NJ、USA、IEEEプレス、2010年12月。"
    },
    {
      "indent": 3,
      "text": "[HAMcast-DEV] \"HAMcast developers\", <http://hamcast.realmv6.org/developers>.",
      "ja": "[HAMcast-DEV] \"HAMcastの開発\"、<http://hamcast.realmv6.org/developers>。"
    },
    {
      "indent": 3,
      "text": "[LCN2012] Meiling, S., Schmidt, T., and M. Waehlisch, \"Large-Scale Measurement and Analysis of One-Way Delay in Hybrid Multicast Networks\", Proc. 37th Annual IEEE Conference on Local Computer Networks (LCN 2012), Piscataway, NJ, USA, IEEE Press, October 2012.",
      "ja": "【LCN2012]美鈴、S.、シュミット、T。、およびM. Waehlisch、PROC「ハイブリッドマルチキャストネットワークにおける一方向遅延の大規模測定と分析」。第37回IEEEローカルコンピュータネットワーク上の会議（2012 LCN）、ピスカタウェイ、NJ、USA、IEEEプレス、2012年10月。"
    },
    {
      "indent": 3,
      "text": "[MCAST-v4v6] Venaas, S., Asaeda, H., SUZUKI, S., and T. Fujisaki, \"An IPv4 - IPv6 multicast translator\", Work in Progress, December 2010.",
      "ja": "[MCAST-v4v6] Venaas、S.、Asaeda、H.、SUZUKI、S.、およびT.藤崎 \"のIPv4  -  IPv6マルチキャスト翻訳\"、進歩、2010年12月ワーク。"
    },
    {
      "indent": 3,
      "text": "[MCAST-v4v6-FRAMEWORK] Venaas, S., Li, X., and C. Bao, \"Framework for IPv4/IPv6 Multicast Translation\", Work in Progress, June 2011.",
      "ja": "[MCAST-v4v6-FRAMEWORK] Venaas、S.、リチウム、X.、及びC.バオ、進歩、2011年6月仕事 \"のIPv4 / IPv6マルチキャスト翻訳のためのフレームワーク\"。"
    },
    {
      "indent": 3,
      "text": "[RELOAD] Jennings, C., Lowekamp, B., Ed., Rescorla, E., Baset, S., and H. Schulzrinne, \"REsource LOcation And Discovery (RELOAD) Base Protocol\", Work in Progress, February 2013.",
      "ja": "[リロード]ジェニングス、C.、Lowekamp、B.、編。、レスコラ、E.、BASET、S.、およびH. Schulzrinneと、 \"リソースロケーションと発見（リロード）ベースプロトコル\"、進歩、2013年2月に働いています。"
    },
    {
      "indent": 3,
      "text": "[RFC5757] Schmidt, T., Waehlisch, M., and G. Fairhurst, \"Multicast Mobility in Mobile IP Version 6 (MIPv6): Problem Statement and Brief Survey\", RFC 5757, February 2010.",
      "ja": "[RFC5757]シュミット、T.、Waehlisch、M.、およびG. Fairhurst、 \"モバイルIPバージョン6におけるマルチキャストモビリティ（MIPv6の）問題文と簡単な調査\"、RFC 5757、2010年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC6219] Li, X., Bao, C., Chen, M., Zhang, H., and J. Wu, \"The China Education and Research Network (CERNET) IVI Translation Design and Deployment for the IPv4/IPv6 Coexistence and Transition\", RFC 6219, May 2011.",
      "ja": "[RFC6219]のLi、X.、バオ、C.、チェン、M.、チャン、H.、及びJ.ウー、「中国教育研究ネットワーク（CERNET）のIPv4 / IPv6の共存のためのIVI翻訳設計および展開とトランジション」、RFC 6219、2011年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC7019] Buford, J. and M. Kolberg, \"Application-Layer Multicast Extensions to REsource LOcation And Discovery (RELOAD)\", RFC 7019, September 2013.",
      "ja": "[RFC7019]ビュ、J.とM. KOLBERG、 \"アプリケーションレイヤリソースロケーションとディスカバリー（リロード）にマルチキャスト拡張\"、RFC 7019、2013年9月。"
    },
    {
      "indent": 3,
      "text": "[SIP-RELOAD] Jennings, C., Lowekamp, B., Rescorla, E., Baset, S., Schulzrinne, H., and T. Schmidt, Ed., \"A SIP Usage for RELOAD\", Work in Progress, July 2013.",
      "ja": "[SIPリロード]ジェニングス、C.、Lowekamp、B.、レスコラ、E.、BASET、S.、Schulzrinneと、H.、およびT.シュミット、エド。、 \"リロードのSIPの使用\"、進行中で働いて、 2013年7月。"
    },
    {
      "indent": 0,
      "text": "Appendix A. C Signatures",
      "ja": "付録A. C署名"
    },
    {
      "indent": 3,
      "text": "This section describes the C signatures of the common multicast API (Section 4).",
      "ja": "このセクションでは、共通のマルチキャストAPI（第4）のCシグネチャを記述する。"
    },
    {
      "indent": 7,
      "text": "int createMSocket(int* result, size_t num_ifs,\n                  const uint32_t* ifs);",
      "raw": true
    },
    {
      "indent": 7,
      "text": "int deleteMSocket(int s);",
      "ja": "int型deleteMSocket（int型秒）。"
    },
    {
      "indent": 7,
      "text": "int join(int msock, const char* group_uri);",
      "ja": "int型（int型msock、CONSTのchar * group_uri）に参加。"
    },
    {
      "indent": 7,
      "text": "int leave(int msock, const char* group_uri);",
      "ja": "int型の休暇（int型msock、CONST文字* group_uri）。"
    },
    {
      "indent": 7,
      "text": "int srcRegister(int msock, const char* group_uri, size_t num_ifs, uint32_t* ifs);",
      "ja": "INT srcRegister（INT msock、CONSTするchar * group_uri、size_tのnum_ifs、のuint32_t * IFS）。"
    },
    {
      "indent": 7,
      "text": "int srcDeregister(int msock, const char* group_uri, size_t num_ifs, uint32_t* ifs);",
      "ja": "INT srcDeregister（INT msock、CONSTするchar * group_uri、size_tのnum_ifs、のuint32_t * IFS）。"
    },
    {
      "indent": 7,
      "text": "int send(int msock, const char* group_uri, size_t buf_len, const void* buf);",
      "ja": "int型の送信（int型msock、CONSTするchar * group_uri、size_tのはbuf_len、CONST void *型BUF）。"
    },
    {
      "indent": 7,
      "text": "int receive(int msock, const char* group_uri, size_t buf_len, void* buf);",
      "ja": "int型（int型msock、CONSTするchar * group_uri、size_tのはbuf_len、void *型BUF）を受け取ります。"
    },
    {
      "indent": 7,
      "text": "int getInterfaces(int msock, size_t* num_ifs, uint32_t** ifs);",
      "ja": "int型でgetInterfaces（int型msock、size_t型* num_ifs、のuint32_t ** IFS）。"
    },
    {
      "indent": 7,
      "text": "int addInterface(int msock, uint32_t iface);",
      "ja": "int型addInterface（int型msock、のuint32_tのiface）;"
    },
    {
      "indent": 7,
      "text": "int delInterface(int msock, uint32_t iface);",
      "ja": "int型delInterface（int型msock、のuint32_tのiface）;"
    },
    {
      "indent": 7,
      "text": "int setTTL(int msock, uint8_t value, size_t num_ifs, uint32_t* ifs);",
      "ja": "INT setTTL（INT msock、uint8_t値、size_tのnum_ifs、のuint32_t * IFS）。"
    },
    {
      "indent": 7,
      "text": "int getTTL(int msock, uint8_t* result);",
      "ja": "int型getTTL（int型msock、uint8_t *結果）。"
    },
    {
      "indent": 7,
      "text": "int getAtomicMsgSize(int msock);",
      "ja": "int型getAtomicMsgSize（int型msock）。"
    },
    {
      "indent": 7,
      "text": "typedef struct {\n    char* group_uri; /* registered mcast group */\n    int type; /* 0: listener state\n                 1: sender state\n                 2: sender and listener state */\n}\nGroupSet;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "int groupSet(uint32_t iface, size_t* num_groups, GroupSet** groups);",
      "ja": "int型グループセット（のuint32_tのifaceの、size_t型* num_groups、GROUPSET **グループ）。"
    },
    {
      "indent": 7,
      "text": "int neighborSet(uint32_t iface, const char* group_name, size_t* num_neighbors, char** neighbor_uris);",
      "ja": "int型neighborSet（のuint32_tのiface、CONSTするchar * group_nameに、size_t型* num_neighbors、CHAR ** neighbor_uris）。"
    },
    {
      "indent": 7,
      "text": "int childrenSet(uint32_t iface, const char* group_name, size_t* num_children, char** children_uris);",
      "ja": "int型childrenSet（のuint32_tのiface、CONSTするchar * group_nameに、size_t型* num_children、CHAR ** children_uris）。"
    },
    {
      "indent": 7,
      "text": "int parentSet(uint32_t iface, const char* group_name, size_t* num_parents, char** parents_uris);",
      "ja": "int型parentSet（のuint32_tのiface、CONSTするchar * group_nameに、size_t型* num_parents、CHAR ** parents_uris）。"
    },
    {
      "indent": 7,
      "text": "int designatedHost(uint32_t iface, const char* group_name);",
      "ja": "int型designatedHost（のuint32_tのiface、constのchar型* GROUP_NAME）。"
    },
    {
      "indent": 10,
      "text": "typedef void (*MembershipEventCallback)\n                           (int,          /* event type   */\n                            uint32_t,     /* Interface id */\n                            const char*); /* group uri    */",
      "raw": true
    },
    {
      "indent": 10,
      "text": "int registerEventCallback(MembershipEventCallback callback);",
      "ja": "int型registerEventCallback（MembershipEventCallbackコールバック）;"
    },
    {
      "indent": 10,
      "text": "int enableEvents();",
      "ja": "enableEventsをint型（）;"
    },
    {
      "indent": 10,
      "text": "int disableEvents();",
      "ja": "disableEventsをint型（）;"
    },
    {
      "indent": 7,
      "text": "int getMaxMsgSize();",
      "ja": "int型getMaxMsgSize（）;"
    },
    {
      "indent": 0,
      "text": "Appendix B. Use Case for the API",
      "ja": "API付録B.ユースケース"
    },
    {
      "indent": 3,
      "text": "For the sake of readability, we demonstrate development of applications using the API based on a high-level Java-like syntax; we do not consider error handling.",
      "ja": "読みやすさのために、我々は、高レベルのJavaに似た構文に基づいたAPIを使用したアプリケーションの開発を発揮します。我々は、エラー処理を考慮していません。"
    },
    {
      "indent": 5,
      "text": "-- Application above middleware:",
      "ja": " - ミドルウェア上でアプリケーション："
    },
    {
      "indent": 5,
      "text": "//Initialize multicast socket;\n//the middleware selects all available Interfaces\nMulticastSocket m = new MulticastSocket();",
      "raw": true
    },
    {
      "indent": 5,
      "text": "m.join(URI(\"ham:ip:224.1.2.3:5000\"));\nm.join(URI(\"ham:ip:[ff02:0:0:0:0:0:0:3]:6000\"));\nm.join(URI(\"ham:sip:news@cnn.com\"));",
      "raw": true
    },
    {
      "indent": 5,
      "text": "-- Middleware:",
      "ja": " - ミドルウェア："
    },
    {
      "indent": 5,
      "text": "join(URI mcAddress) {\n  //Select Interfaces in use\n  for all this.interfaces {\n    switch (interface.type) {\n      case \"ipv6\":\n        //... map logical ID to routing address\n        Inet6Address rtAddressIPv6 = new Inet6Address();\n        mapNametoAddress(mcAddress,rtAddressIPv6);\n        interface.join(rtAddressIPv6);\n      case \"ipv4\":\n        //... map logical ID to routing address\n        Inet4Address rtAddressIPv4 = new Inet4Address();\n        mapNametoAddress(mcAddress,rtAddressIPv4);\n        interface.join(rtAddressIPv4);\n      case \"sip-session\":\n        //... map logical ID to routing address\n        SIPAddress rtAddressSIP = new SIPAddress();\n        mapNametoAddress(mcAddress,rtAddressSIP);\n        interface.join(rtAddressSIP);\n      case \"dht\":\n        //... map logical ID to routing address\n        DHTAddress rtAddressDHT = new DHTAddress();\n        mapNametoAddress(mcAddress,rtAddressDHT);\n        interface.join(rtAddressDHT);\n       //...\n    }\n  }\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Appendix C. Deployment Use Cases for Hybrid Multicast",
      "ja": "ハイブリッドマルチキャスト付録C.展開の使用事例"
    },
    {
      "indent": 3,
      "text": "This section describes the application of the defined API to implement an IMG.",
      "ja": "このセクションでは、IMGを実装するために定義されたAPIのアプリケーションを記述しています。"
    },
    {
      "indent": 0,
      "text": "C.1. DVMRP",
      "ja": "C.1。 DVMRP"
    },
    {
      "indent": 3,
      "text": "The following procedure describes a transparent mapping of a DVMRP-based any-source multicast service to another many-to-many multicast technology, e.g., an overlay.",
      "ja": "次の手順は、別の多対多マルチキャスト技術、例えば、オーバーレイにDVMRPベース任意ソースマルチキャストサービスの透明マッピングを記述する。"
    },
    {
      "indent": 3,
      "text": "An arbitrary Distance Vector Multicast Routing Protocol (DVMRP) [RFC1075] router will not be informed of new receivers but will learn about new sources immediately. The concept of DVMRP does not provide any central multicast instance. Thus, the IMG can be placed anywhere inside the multicast region, but the IMG requires a DVMRP neighbor connectivity. Thus, the group communication stack used by the IMG is enhanced by a DVMRP implementation. New sources in the underlay will be advertised based on the DVMRP flooding mechanism and received by the IMG. Based on this, the event \"new_source_event\" is created and passed to the application. The relay agent initiates a corresponding join in the native network and forwards the received source data towards the overlay routing protocol. Depending on the group states, the data will be distributed to overlay peers.",
      "ja": "任意の距離ベクトルマルチキャストルーティングプロトコル（DVMRP）[RFC1075]ルータは、新たな受信機が通知されることはありませんが、すぐに新しいソースについて学習します。 DVMRPの概念は、任意の中央マルチキャストインスタンスを提供していません。したがって、IMGは、マルチキャスト領域内の任意の場所に配置することができるが、IMGは、DVMRPネイバー接続を必要とします。したがって、IMGが使用するグループ通信スタックは、DVMRP実装によって増強されます。アンダーレイの新しいソースは、DVMRPの氾濫メカニズムに基づいており、IMGで受信したアドバタイズされます。これに基づき、イベント「new_source_event」が作成され、アプリケーションに渡されます。リレーエージェントは、対応するネイティブネットワークに参加を開始し、オーバーレイ・ルーティング・プロトコルに向かって受信したソースデータを転送します。グループの状態によっては、データがピアをオーバーレイするために配布されます。"
    },
    {
      "indent": 3,
      "text": "DVMRP establishes source-specific multicast trees. Therefore, a graft message is only visible to DVMRP routers on the path from the new receiver subnet to the source, but in general not to an IMG. To overcome this problem, data of multicast senders in the overlay may become noticeable via the Source Register call, as well as by an IMG that initiates an all-group join in the overlay using the namespace extension of the API. Each IMG is initially required to forward the data received in the overlay to the underlay, independent of native multicast receivers. Subsequent prunes may limit unwanted data distribution thereafter.",
      "ja": "DVMRPは、ソース固有マルチキャストツリーを確立します。したがって、グラフトメッセージは、ソースへの新しい受信サブネットからの経路上のルータをDVMRPのみ可視であるが、一般的ではないIMGに。この問題を克服するために、オーバーレイマルチキャスト送信者のデータは、だけでなく、すべてのグループが、APIの名前空間拡張を使用してオーバーレイに参加開始IMGによってソース・レジスタの呼び出しを経由して顕著になることがあります。各IMGは、最初のネイティブマルチキャスト受信機とは独立して、アンダーレイにオーバーレイで受信したデータを転送する必要があります。後続のプルーンは、その後、不要なデータの配信を制限してもよいです。"
    },
    {
      "indent": 0,
      "text": "C.2. PIM-SM",
      "ja": "C.2。 DRINK-SM"
    },
    {
      "indent": 3,
      "text": "The following procedure describes a transparent mapping of a PIM-SM-based any-source multicast service to another many-to-many multicast technology, e.g., an overlay.",
      "ja": "次の手順は、別の多対多マルチキャスト技術、例えば、オーバーレイにPIM-SMベースの任意のソースマルチキャストサービスの透明マッピングを記述する。"
    },
    {
      "indent": 3,
      "text": "The Protocol Independent Multicast - Sparse Mode (PIM-SM) [RFC4601] establishes rendezvous points (RPs). These entities receive listener subscriptions and source registering of a domain. For a continuous update, an IMG has to be co-located with an RP. Whenever PIM register messages are received, the IMG must signal internally a new multicast source using the event \"new_source_event\". Subsequently, the IMG joins the group and a shared tree between the RP and the sources will be established; this shared tree may change to a source-specific tree after PIM switches to phase three. Source traffic will be forwarded to the RP based on the IMG join, even if there are no further receivers in the native Multicast Domain. Designated routers of a PIM domain send receiver subscriptions towards the PIM-SM RP. The reception of such messages initiates the event \"join_event\" at the IMG, which initiates a join towards the overlay routing protocol. Overlay multicast data arriving at the IMG will then be transparently forwarded in the underlay network and distributed through the RP instance.",
      "ja": "プロトコル独立マルチキャスト - スパースモード（PIM-SM）[RFC4601]は、ランデブーポイント（RPS）を確立します。これらのエンティティは、リスナーのサブスクリプションおよびドメインのソース登録を受けます。連続更新のために、IMGは、RP​​と同じ場所に配置する必要があります。 PIM登録メッセージを受信するたびに、IMGは内部イベント「new_source_event」を使用して、新しいマルチキャストソースを通知しなければなりません。その後、IMGは、グループに参加し、RPとソースとの間で共有ツリーが確立されます。 PIM三相に切り替えた後に、この共有ツリーは、ソース固有のツリーに変更することができます。元トラフィックは、ネイティブマルチキャストドメインには、さらに受信機が存在しない場合でも、参加IMGに基づいてRPに転送されます。 PIMドメインの指定ルータは、PIM-SM RPに向けレシーバサブスクリプションを送信します。そのようなメッセージの受信は、オーバーレイルーティングプロトコルに向かって参加開始IMG、でイベント「join_event」を開始します。 IMGに到着オーバレイマルチキャストデータは、透過アンダーレイネットワークで転送し、RPインスタンスを介して配布されます。"
    },
    {
      "indent": 0,
      "text": "C.3. PIM-SSM",
      "ja": "C.3。 PIM-SSM"
    },
    {
      "indent": 3,
      "text": "The following procedure describes a transparent mapping of a PIM-SSM-based source-specific multicast service to another one-to-many multicast technology, e.g., an overlay.",
      "ja": "以下の手順は、別の一対多マルチキャスト技術、例えば、オーバーレイにPIM-SSMベースのソース固有マルチキャストサービスの透明マッピングを記述する。"
    },
    {
      "indent": 3,
      "text": "PIM Source-Specific Multicast (PIM-SSM) is defined as part of PIM-SM and admits source-specific joins (S,G) according to the source-specific host group model [RFC4604]. A multicast distribution tree can be established without the assistance of a rendezvous point.",
      "ja": "PIMソース固有マルチキャスト（PIM-SSM）は、PIM-SMの一部として定義され、ソース固有のを許可されたソース固有のホストグループモデル[RFC4604]に記載の（S、G）加入。マルチキャスト配信ツリーは、ランデブーポイントの援助なしに確立することができます。"
    },
    {
      "indent": 3,
      "text": "Sources are not advertised within a PIM-SSM domain. Consequently, an IMG cannot anticipate the local join inside a sender domain and deliver a priori the multicast data to the overlay instance. If an IMG of a receiver domain initiates a group subscription via the overlay routing protocol, relaying multicast data fails, as data is not available at the overlay instance. The IMG instance of the receiver domain thus has to locate the IMG instance of the source domain to trigger the corresponding join. In agreement with the objectives of PIM-SSM, the signaling should not be flooded in the underlay and overlay.",
      "ja": "ソースは、PIM-SSMのドメイン内に通知されていません。その結果、IMGは、ローカルの送信者ドメイン内の参加予測し、オーバーレイインスタンスに先験的マルチキャストデータを配信することはできません。レシーバドメインのIMGは、オーバーレイ・ルーティング・プロトコルを介して、グループ・サブスクリプションを開始する場合、データがオーバーレイ・インスタンスで利用できないように、マルチキャストデータを中継することは、失敗しました。レシーバドメインのIMGのインスタンスは、このように、対応する参加をトリガするために、ソースドメインのIMGインスタンスを見つけなければなりません。 PIM-SSMの目的と一致して、シグナリングは、アンダーレイとオーバーレイで浸水するべきではありません。"
    },
    {
      "indent": 3,
      "text": "A solution can be to intercept the subscription at both source sites and receiver sites: To monitor multicast receiver subscriptions (\"join_event\" or \"leave_event\") in the underlay, the IMG is placed on the path towards the source, e.g., at a domain border router. This router intercepts join messages and extracts the unicast source address S, initializing an IMG-specific join to S via regular unicast. Multicast data arriving at the IMG of the sender domain can be distributed via the overlay. Discovering the IMG of a multicast sender domain may be implemented analogously to Automatic Multicast Tunneling [AMT] by anycast. Consequently, the source address S of the group (S,G) should be built based on an anycast prefix. The corresponding IMG anycast address for a source domain is then derived from the prefix of S.",
      "ja": "溶液は、ソースサイトと受信サイトの両方でサブスクリプションを傍受することができる。下敷きにマルチキャスト受信サブスクリプション（「join_event」または「leave_event」）を監視するには、IMGは、ドメインに、例えば、ソースに向かって経路上に配置されます境界ルータ。このルータは、インターセプトは、メッセージを結合し、IMG-特定が通常のユニキャストを介してSに参加初期化、ユニキャスト送信元アドレスSを抽出します。送信者ドメインのIMGに到着するマルチキャストデータは、オーバーレイを介して配布することができます。マルチキャスト送信元ドメインのIMGを発見すると、エニーキャストによって自動マルチキャストトンネリング[AMT]と同様に実施することができます。したがって、グループ（S、G）のソースアドレスSは、エニーキャストプレフィックスに基づいて構築されなければなりません。ソースドメインの対応するIMGのエニーキャストアドレスは、Sのプレフィックスから導出され"
    },
    {
      "indent": 0,
      "text": "C.4. BIDIR-PIM",
      "ja": "C.4。 BIDIR-PIM"
    },
    {
      "indent": 3,
      "text": "The following procedure describes a transparent mapping of a BIDIR-PIM-based any-source multicast service to another many-to-many multicast technology, e.g., an overlay.",
      "ja": "次の手順は、別の多対多マルチキャスト技術、例えば、オーバーレイにBIDIR-PIMベースの任意のソースマルチキャストサービスの透明マッピングを記述する。"
    },
    {
      "indent": 3,
      "text": "Bidirectional PIM [RFC5015] is a variant of PIM-SM. In contrast to PIM-SM, the protocol pre-establishes bidirectional shared trees per group, connecting multicast sources and receivers. The rendezvous points are virtualized in BIDIR-PIM as an address to identify on-tree directions (up and down). Routers with the best link towards the (virtualized) rendezvous point address are selected as designated forwarders for a link-local domain and represent the actual distribution tree. The IMG is to be placed at the RP link, where the rendezvous point address is located. As source data in either case will be transmitted to the RP link, the BIDIR-PIM instance of the IMG receives the data and can internally signal new senders towards the stack via the \"new_source_event\". The first receiver subscription for a new group within a BIDIR-PIM domain needs to be transmitted to the RP to establish the first branching point. Using the \"join_event\", an IMG will thereby be informed of group requests from its domain, which are then delegated to the overlay.",
      "ja": "双方向PIM [RFC5015]はPIM-SMの変異体です。 PIM-SMとは対照的に、プロトコルは、マルチキャスト送信元と受信機を接続し、グループごとに双方向共有ツリーを事前に確立します。ランデブーポイントは、オンツリー方向（上下）を識別するためのアドレスとしてBIDIR-PIMに仮想化されています。 （仮想）ランデブーポイントアドレスに向かって最高のリンクを持つルータはリンクローカルドメインの指定フォワーダとして選択され、実際の配信ツリーを表しています。 IMGは、ランデブーポイントのアドレスが配置されているRPリンク、に配置されます。いずれの場合も、ソースデータをRPリンクに送信されるように、IMGのBIDIR-PIMインスタンスは、データを受信し、内部「new_source_event」を介してスタックに向かって新しい送信者に信号を送ることができます。 BIDIR-PIMドメイン内の新しいグループの第1の受信機のサブスクリプションは、最初の分岐点を確立するために、RPに送信する必要があります。 「join_event」を使用して、IMGは、それによって、その後、オーバーレイに委任されているそのドメインからのグループ要求が通知されます。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Matthias Waehlisch link-lab & FU Berlin Hoenower Str. 35 Berlin 10318 Germany",
      "ja": "マティアスWählischリンク・ラボ＆FUベルリンHönowerのStr。35 10318ベルリンドイツ"
    },
    {
      "indent": 3,
      "text": "EMail: mw@link-lab.net URI: http://www.inf.fu-berlin.de/~waehl",
      "ja": "電子メール：mw@link-lab.net URI：http://www.inf.fu-berlin.de/~waehl"
    },
    {
      "indent": 3,
      "text": "Thomas C. Schmidt HAW Hamburg Berliner Tor 7 Hamburg 20099 Germany",
      "ja": "トーマス・C.シュミットHAWハンブルクベルリナートア7 20099ハンブルクドイツ"
    },
    {
      "indent": 3,
      "text": "EMail: schmidt@informatik.haw-hamburg.de URI: http://inet.cpt.haw-hamburg.de/members/schmidt",
      "ja": "電子メール：schmidt@informatik.haw-hamburg.de URI：http://inet.cpt.haw-hamburg.de/members/schmidt"
    },
    {
      "indent": 3,
      "text": "Stig Venaas Cisco Systems Tasman Drive San Jose, CA 95134 USA",
      "ja": "スティグVenaasシスコシステムズタスマン・ドライブサンノゼ、CA 95134 USA"
    },
    {
      "indent": 3,
      "text": "EMail: stig@cisco.com",
      "ja": "メールアドレス：stig@cisco.com"
    }
  ]
}