{
  "title": {
    "text": "RFC 7712 - Domain Name Associations (DNA) in the Extensible Messaging and Presence Protocol (XMPP)",
    "ja": "RFC 7712 - 拡張メッセージングおよびプレゼンスプロトコル（XMPP）でドメイン名協会（DNA）"
  },
  "number": 7712,
  "created_at": "2019-11-01 12:14:25.037342+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                    P. Saint-Andre\nRequest for Comments: 7712                                          &yet\nCategory: Standards Track                                      M. Miller\nISSN: 2070-1721                                      Cisco Systems, Inc.\n                                                               P. Hancke\n                                                                    &yet\n                                                           November 2015",
      "raw": true
    },
    {
      "indent": 8,
      "text": "             Domain Name Associations (DNA)\nin the Extensible Messaging and Presence Protocol (XMPP)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document improves the security of the Extensible Messaging and Presence Protocol (XMPP) in two ways. First, it specifies how to establish a strong association between a domain name and an XML stream, using the concept of \"prooftypes\". Second, it describes how to securely delegate a service domain name (e.g., example.com) to a target server hostname (e.g., hosting.example.net); this is especially important in multi-tenanted environments where the same target server hosts a large number of domains.",
      "ja": "この文書では、2つの方法で拡張可能なメッセージングおよびプレゼンスプロトコル（XMPP）のセキュリティを向上させます。まず、それは「prooftypes」の概念を使用して、ドメイン名とXMLストリームとの間に強い関連性を確立する方法を指定します。第二に、それはしっかりとターゲット・サーバーのホスト名（例えば、hosting.example.net）にサービスドメイン名を（たとえば、example.com）に委任する方法について説明します。これは、同じターゲットサーバがドメインの多数をホストするマルチテナント環境では特に重要です。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 5741のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7712.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7712で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2015 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2015 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................3\n2. Terminology .....................................................4\n3. Client-to-Server (C2S) DNA ......................................4\n   3.1. C2S Flow ...................................................4\n   3.2. C2S Description ............................................5\n4. Server-to-Server (S2S) DNA ......................................5\n   4.1. S2S Flow ...................................................6\n   4.2. A Simple S2S Scenario .....................................10\n   4.3. No Mutual PKIX Authentication .............................12\n   4.4. Piggybacking ..............................................13\n        4.4.1. Assertion ..........................................13\n        4.4.2. Supposition ........................................15\n5. Alternative Prooftypes .........................................16\n   5.1. DANE ......................................................16\n   5.2. POSH ......................................................17\n6. Secure Delegation and Multi-Tenancy ............................18\n7. Prooftype Model ................................................18\n8. Guidance for Server Operators ..................................19\n9. IANA Considerations ............................................20\n   9.1. POSH Service Name for xmpp-client Service .................20\n   9.2. POSH Service Name for xmpp-server Service .................20\n10. Security Considerations .......................................20\n11. References ....................................................21\n   11.1. Normative References .....................................21\n   11.2. Informative References ...................................23\nAcknowledgements ..................................................24\nAuthors' Addresses ................................................24",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "In systems that use the Extensible Messaging and Presence Protocol (XMPP) [RFC6120], it is important to establish a strong association between the DNS domain name of an XMPP service (e.g., example.com) and the XML stream that a client or peer server initiates with that service. In other words, the client or peer server needs to verify the identity of the server to which it connects. Additionally, servers need to verify incoming connections from other servers.",
      "ja": "[RFC6120]拡張メッセージングおよびプレゼンスプロトコル（XMPP）を使用するシステムでは、クライアントまたはピアこと（例えば、example.com）XMPPサービスのDNSドメイン名とXMLストリームとの間に強い関連性を確立することが重要ですサーバは、そのサービスを開始します。言い換えれば、クライアントまたはピアサーバーは、それが接続するサーバーの身元を確認する必要があります。また、サーバは、他のサーバーからの着信接続を確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "To date, such verification has been established based on information obtained from the Domain Name System (DNS), the Public Key Infrastructure (PKI), or similar sources. In particular, XMPP as defined in [RFC6120] assumed that Domain Name Associations (DNA) are to be proved using the \"PKIX prooftype\"; that is, the server's proof consists of a PKIX certificate that is checked according to the XMPP profile of the matching rules from [RFC6125] (and the overall validation rules from [RFC5280]), the client's verification material is obtained out of band in the form of a trusted root, and secure DNS is not necessary.",
      "ja": "現在まで、そのような検証は、ドメインネームシステム（DNS）、公開鍵インフラストラクチャ（PKI）、または類似した情報源から得た情報に基づいて設立されました。具体的には、[RFC6120]で定義されるようXMPPドメイン名協会（DNA）「はPKIXのprooftype」を用いて証明することを想定しました。それは、サーバの証明は[RFC6125]（および[RFC5280]からの全体的な検証ルール）からマッチングルールのXMPPプロファイルに従ってチェックされ、クライアントの検証材料は、バンドの外得られるPKIX証明書で構成され、あります信頼されたルートの形式、およびセキュアなDNSは必要ありません。"
    },
    {
      "indent": 3,
      "text": "By extending the concept of a domain name association within XMPP, this document does the following:",
      "ja": "XMPP内のドメイン名関連の概念を拡張することによって、この文書には、次のことを行います。"
    },
    {
      "indent": 3,
      "text": "1. Generalizes the model currently in use so that additional prooftypes can be defined if needed.",
      "ja": "必要に応じて追加のprooftypesを定義することができるように、1は、現在使用されているモデルを一般化します。"
    },
    {
      "indent": 3,
      "text": "2. Provides a basis for modernizing some prooftypes to reflect progress in underlying technologies such as DNS Security [RFC4033].",
      "ja": "2.は、DNSセキュリティ[RFC4033]などの基本的な技術の進歩を反映するために、いくつかのprooftypesの近代化のための基盤を提供します。"
    },
    {
      "indent": 3,
      "text": "3. Describes the flow of operations for establishing a domain name association.",
      "ja": "3.ドメイン名の関連付けを確立するための動作の流れを説明します。"
    },
    {
      "indent": 3,
      "text": "This document also provides guidelines for secure delegation of a service domain name (e.g., example.com) to a target server hostname (e.g., hosting.example.net). The need for secure delegation arises because the process for resolving the domain name of an XMPP service into the IP address at which an XML stream will be negotiated (see [RFC6120]) can involve delegation of a service domain name to a target server hostname using technologies such as DNS SRV records [RFC2782]. A more detailed description of the delegation problem can be found in [RFC7711]. The domain name association can be verified only if the delegation is done in a secure manner.",
      "ja": "また、このドキュメントでは、ターゲットサーバのホスト名（例えば、hosting.example.net）へのサービスドメイン名（たとえば、example.com）を安全に委任するためのガイドラインを提供します。 （[RFC6120]を参照）XMLストリームが交渉される時にIPアドレスにXMPPサービスのドメイン名を解決するためのプロセスを使用して、ターゲット・サーバーのホスト名にサービスドメイン名の代表団を含むことができるので、安全な委任の必要性が生じましたそのようなDNS SRVレコード[RFC2782]などの技術。委任の問題のより詳細な説明は、[RFC7711]で見つけることができます。ドメイン名の関連付けは、代表団は安全な方法で行われている場合にのみ確認することができます。"
    },
    {
      "indent": 0,
      "text": "2. Terminology",
      "section_title": true,
      "ja": "2.用語"
    },
    {
      "indent": 3,
      "text": "This document inherits XMPP terminology from [RFC6120] and [XEP-0220]; DNS terminology from [RFC1034], [RFC1035], [RFC2782], and [RFC4033]; and security terminology from [RFC4949] and [RFC5280]. The terms \"reference identity\" and \"presented identity\" are used as defined in the \"CertID\" specification [RFC6125]. For the sake of consistency with [RFC7673], this document uses the terms \"service domain name\" and \"target server hostname\" to refer to the same entities identified by the terms \"source domain\" and \"derived domain\" from [RFC6125].",
      "ja": "このドキュメントは[RFC6120]と[XEP-0220]からXMPP用語を継承します。 [RFC1034]、[RFC1035]、[RFC2782]及び[RFC4033]からDNS用語。 [RFC4949]と[RFC5280]からセキュリティ用語。 「CertID」仕様[RFC6125]で定義されるように、用語「基準同一性」および「提示同一性」は使用されています。 [RFC7673]との整合性のために、この文書では、用語「ソースドメイン」と[RFC6125]から「派生ドメイン」で識別される同じエンティティを参照するために用語「サービスドメイン名」と「ターゲット・サーバーのホスト名を」使用しています。"
    },
    {
      "indent": 0,
      "text": "3. Client-to-Server (C2S) DNA",
      "section_title": true,
      "ja": "3.クライアントとサーバー（C2S）DNA"
    },
    {
      "indent": 3,
      "text": "The client-to-server case is much simpler than the server-to-server case because the client does not assert a domain name; this means that verification happens in only one direction. Therefore, we describe this case first to help the reader understand domain name associations in XMPP.",
      "ja": "クライアントは、ドメイン名を主張していないため、クライアントからサーバーへの場合は、サーバー間の場合よりもはるかに簡単です。これは検証が一方向にのみ起こることを意味しています。したがって、我々は読者がXMPPにドメイン名の関連付けを理解するために、最初にこのケースについて説明します。"
    },
    {
      "indent": 0,
      "text": "3.1. C2S Flow",
      "section_title": true,
      "ja": "3.1。 C2Sの流れ"
    },
    {
      "indent": 3,
      "text": "The following flow chart illustrates the protocol flow for establishing a domain name association for an XML stream from a client (C) to a server (S) using the standard PKIX prooftype specified in [RFC6120].",
      "ja": "以下のフローチャートは、[RFC6120]で指定された標準PKIXのprooftypeを使用して、サーバにクライアント（C）（S）からXMLストリームのドメイン名の関連付けを確立するためのプロトコルの流れを示します。"
    },
    {
      "indent": 3,
      "text": "                        |\n                DNS RESOLUTION ETC.\n                        |\n+-----------------STREAM HEADERS---------------------+\n|                                                    |\n|  C: <stream to='a.example'>                        |\n|                                                    |\n|  S: <stream from='a.example'>                      |\n|                                                    |\n+----------------------------------------------------+\n                        |\n+-----------------TLS NEGOTIATION--------------------+\n|                                                    |\n|  S: Server Certificate                             |\n|                                                    |\n+----------------------------------------------------+\n                        |\n          (client checks certificate and\n           establishes DNA for a.example)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.2. C2S Description",
      "section_title": true,
      "ja": "3.2。 C2S説明"
    },
    {
      "indent": 3,
      "text": "The simplified order of events (see [RFC6120] for details) in establishing an XML stream from a client (user@a.example) to a server (a.example) is as follows:",
      "ja": "次のようにサーバ（a.example）にクライアント（user@a.example）からXMLストリームを確立する（詳細については[RFC6120]参照）イベントの簡略化順序であります："
    },
    {
      "indent": 3,
      "text": "1. The client resolves via DNS the service _xmpp-client._tcp.a.example.",
      "ja": "1.クライアントは、DNSを介してサービス_xmpp-client._tcp.a.exampleを解決します。"
    },
    {
      "indent": 3,
      "text": "2. The client opens a TCP connection to the resolved IP address.",
      "section_title": true,
      "ja": "2.クライアントは、解決されたIPアドレスへのTCP接続を開きます。"
    },
    {
      "indent": 3,
      "text": "3. The client sends an initial stream header to the server:",
      "section_title": true,
      "ja": "3.クライアントは、サーバーへの初期ストリームヘッダを送信します。"
    },
    {
      "indent": 7,
      "text": "<stream:stream to='a.example'>",
      "ja": "<ストリーム：= 'a.example' への流れ>"
    },
    {
      "indent": 3,
      "text": "4. The server sends a response stream header to the client, asserting that it is a.example:",
      "ja": "4.サーバーは、それがa.exampleであることを主張し、クライアントへの応答ストリームヘッダを送信します。"
    },
    {
      "indent": 7,
      "text": "<stream:stream from='a.example'>",
      "ja": "<ストリーム：= 'a.example' からの流れ>"
    },
    {
      "indent": 3,
      "text": "5. The parties attempt TLS negotiation, during which the XMPP server (acting as a TLS server) presents a PKIX certificate proving that it is a.example.",
      "ja": "5.当事者は、XMPPサーバー（TLSサーバとして動作するが）それがa.exampleであることを証明PKIX証明書を提示している間、TLSネゴシエーションを、試みます。"
    },
    {
      "indent": 3,
      "text": "6. The client checks the PKIX certificate that the server provided; if the proof is consistent with the XMPP profile of the matching rules from [RFC6125] and the certificate is otherwise valid according to [RFC5280], the client accepts that there is a strong domain name association between its stream to the target server and the DNS domain name of the XMPP service.",
      "ja": "6.クライアントは、サーバが提供PKIX証明書をチェックします。証明は[RFC6125]からのマッチングルールのXMPPプロファイルと一致していると証明書は、[RFC5280]によればそうでない有効な場合、クライアントはターゲット・サーバとDNSへの流れとの間の強力なドメイン名の関連付けがあることを受け入れXMPPサービスのドメイン名。"
    },
    {
      "indent": 3,
      "text": "The certificate that the server presents might not be acceptable to the client. As one example, the server might be hosting multiple domains and secure delegation as described in Section 6 is necessary. As another example, the server might present a self-signed certificate, which requires the client to either (1) apply the fallback process described in Section 6.6.4 of [RFC6125] or (2) prompt the user to accept an unauthenticated connection as described in Section 3.4 of [RFC7590].",
      "ja": "サーバーのプレゼントがクライアントに受け入れられない可能性があることを証明。第6節で説明したように、一例として、サーバが複数のドメインとの安全な委任をホストする可能性があることが必要です。別の例として、サーバは、（1）[RFC6125]のセクション6.6.4に記載の代替プロセスを適用するのいずれかにクライアントを必要とする自己署名証明書を提示するか、（2）として認証されていない接続を受け入れるようにユーザに促すかもしれません[RFC7590]のセクション3.4で説明。"
    },
    {
      "indent": 0,
      "text": "4. Server-to-Server (S2S) DNA",
      "section_title": true,
      "ja": "4.サーバー間（S2S）DNA"
    },
    {
      "indent": 3,
      "text": "The server-to-server case is significantly more complex than the client-to-server case, and it involves the checking of domain name associations in both directions along with other \"wrinkles\" described in the following sections. In some parts of the flow, server-to-server communications use the Server Dialback protocol first specified in (the now obsolete) [RFC3920] and since moved to",
      "ja": "サーバー間の場合は、クライアントからサーバーへの場合よりもかなり複雑であり、それは次のセクションで説明する他の「しわ」と一緒に両方向のドメイン名協会の検査を必要とします。フローの一部では、サーバー間の通信は、最初の（廃止）[RFC3920]で指定とに移動するのでサーバーダイアルバックプロトコルを使用します"
    },
    {
      "indent": 3,
      "text": "[XEP-0220]. See \"Impact of TLS and DNSSEC on Dialback\" [XEP-0344] for considerations when using it together with TLS and DNSSEC. Also, \"Bidirectional Server-to-Server Connections\" [XEP-0288] provides a way to use the server-to-server connections for bidirectional exchange of XML stanzas, which reduces the complexity of some of the processes involved.",
      "ja": "[XEP-0220]。 TLSとDNSSECと一緒に使用する際の考慮事項については、「ダイアルバックにTLSとDNSSECの影響」[XEP-0344]を参照してください。また、「双方向サーバー間接続」[XEP-0288]関与する過程のいくつかの複雑さを軽減XMLスタンザの双方向の交流のためのサーバー間接続を使用する方法を提供します。"
    },
    {
      "indent": 0,
      "text": "4.1. S2S Flow",
      "section_title": true,
      "ja": "4.1。 S2Sの流れ"
    },
    {
      "indent": 3,
      "text": "The following flow charts illustrate the protocol flow for establishing domain name associations between Server 1 (the initiating entity) and Server 2 (the receiving entity), as described in the remaining sections of this document.",
      "ja": "この文書の残りのセクションで説明したように、以下のフローチャートでは、サーバ1（開始エンティティ）とサーバ2（受信エンティティ）との間でドメイン名の関連付けを確立するためのプロトコルの流れを示す図です。"
    },
    {
      "indent": 3,
      "text": "A simple S2S scenario would be as follows:",
      "ja": "次のように簡単なS2Sシナリオは次のようになります。"
    },
    {
      "indent": 3,
      "text": "                    |\n             DNS RESOLUTION ETC.\n                    |\n+-------------STREAM HEADERS--------------------+\n|                                               |\n|  A: <stream from='a.example' to='b.example'>  |\n|                                               |\n|  B: <stream from='b.example' to='a.example'>  |\n|                                               |\n+-----------------------------------------------+\n                    |\n+-------------TLS NEGOTIATION-------------------+\n|                                               |\n|  B: Server Certificate                        |\n|  B: Certificate Request                       |\n|  A: Client Certificate                        |\n|                                               |\n+-----------------------------------------------+\n                    |\n    (A establishes DNA for b.example)\n                    |",
      "raw": true
    },
    {
      "indent": 3,
      "text": "After the domain name association has been established in one direction, it is possible to perform mutual authentication using the Simple Authentication and Security Layer (SASL) [RFC4422] and thus establish domain name associations in both directions.",
      "ja": "ドメイン名の関連付けが一方向に確立された後、簡単な認証およびセキュリティ層（SASL）[RFC4422]を使用して相互認証を行うので、両方向にドメイン名の関連付けを確立することが可能です。"
    },
    {
      "indent": 3,
      "text": "                    |\n+-------------AUTHENTICATION--------------------+\n|                   |                           |\n|       {valid client certificate?} --+         |\n|                   |                 |         |\n|                   | yes         no  |         |\n|                   v                 |         |\n|             SASL EXTERNAL           |         |\n|             (mutual auth)           |         |\n|   (B establishes DNA for a.example) |         |\n+-------------------------------------|---------+\n                                      |",
      "raw": true
    },
    {
      "indent": 3,
      "text": "However, if mutual authentication cannot be completed using SASL, the receiving server needs to establish a domain name association in another way. This scenario is described in Section 4.3.",
      "ja": "相互認証は、SASLを使用して完了することができない場合は、受信サーバーは、別の方法でドメイン名の関連付けを確立する必要があります。このシナリオでは、4.3節に記載されています。"
    },
    {
      "indent": 3,
      "text": "                                      |\n                    +-----------------+\n                    |\n        (Section 4.3: No Mutual PKIX Authentication)\n                    |\n                    | B needs to establish DNA\n                    | for this stream from a.example,\n                    | so A asserts its identity\n                    |\n+----------DIALBACK IDENTITY ASSERTION----------+\n|                                               |\n|  A: <db:result from='a.example'               |\n|                to='b.example'>                |\n|       some-dialback-key                       |\n|     </db:result>                              |\n|                                               |\n+-----------------------------------------------+\n                    |",
      "raw": true
    },
    {
      "indent": 3,
      "text": "             DNS RESOLUTION ETC.\n                    |\n+-------------STREAM HEADERS--------------------+\n|                                               |\n|  B: <stream from='b.example' to='a.example'>  |\n|                                               |\n|  A: <stream from='a.example' to='b.example'>  |\n|                                               |\n+-----------------------------------------------+\n                    |\n+-------------TLS NEGOTIATION-------------------+\n|                                               |\n|  A: Server Certificate                        |\n|                                               |\n+-----------------------------------------------+\n                    |\n+----------DIALBACK IDENTITY VERIFICATION-------+\n|                                               |\n|  B: <db:verify from='b.example'               |\n|                to='a.example'                 |\n|                id='...'>                      |\n|       some-dialback-key                       |\n|     </db:verify>                              |\n|                                               |\n|  A: <db:verify from='a.example'               |\n|                to='b.example'                 |\n|                type='valid'                   |\n|                id='...'>                      |\n|                                               |\n+-----------------------------------------------+\n                    |\n    (B establishes DNA for a.example)\n                    |",
      "raw": true
    },
    {
      "indent": 3,
      "text": "If one of the servers hosts additional service names (e.g., Server 2 might host c.example in addition to b.example and Server 1 might host rooms.a.example in addition to a.example), then the servers can use Server Dialback \"piggybacking\" to establish additional domain name associations for the stream, as described in Section 4.4.",
      "ja": "いずれかのサーバが追加のサービス名をホストする場合（例えば、サーバー2はb.exampleに加えてc.exampleをホストする可能性があり、サーバ1はa.exampleに加えてrooms.a.exampleをホストする可能性がある）、その後、サーバーは、サーバーのダイアルバックを使用することができます4.4節で説明したように、ストリーム用の追加ドメイン名の関連付けを確立するために「便乗」。"
    },
    {
      "indent": 3,
      "text": "There are two varieties of piggybacking. The first is here called \"assertion\".",
      "ja": "ピギーバックの2種類があります。最初は、ここで「アサーション」と呼ばれています。"
    },
    {
      "indent": 3,
      "text": "                    |\n      (Section 4.4.1: Piggybacking Assertion)\n                    |\n+----------DIALBACK IDENTITY ASSERTION----------+\n|                                               |\n|  B: <db:result from='c.example'               |\n|                to='a.example'/>               |\n|                                               |\n+-----------------------------------------------+\n                    |\n+-------DNA ESTABLISHMENT AS ABOVE--------------+\n|                                               |\n|    DNS RESOLUTION, STREAM HEADERS,            |\n|    TLS NEGOTIATION, AUTHENTICATION            |\n|                                               |\n+-----------------------------------------------+\n                    |\n+----------DIALBACK IDENTITY VERIFICATION-------+\n|                                               |\n|  A: <db:result from='a.example'               |\n|                to='c.example'                 |\n|                type='valid'/>                 |\n|                                               |\n+-----------------------------------------------+\n                    |",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The second variety of piggybacking is here called \"supposition\".",
      "ja": "ピギーバックの第二の多様は、ここでは「仮定」と呼ばれています。"
    },
    {
      "indent": 3,
      "text": "                    |\n      (Section 4.4.2: Piggybacking Supposition)\n                    |\n+-----------SUBSEQUENT CONNECTION---------------+\n|                                               |\n|  B: <stream from='c.example'                  |\n|             to='rooms.a.example'>             |\n|                                               |\n|  A: <stream from='rooms.a.example'            |\n|             to='c.example'>                   |\n|                                               |\n+-----------------------------------------------+\n                    |\n+-------DNA ESTABLISHMENT AS ABOVE--------------+\n|                                               |\n|    DNS RESOLUTION, STREAM HEADERS,            |\n|    TLS NEGOTIATION, AUTHENTICATION            |\n|                                               |\n+-----------------------------------------------+\n                    |\n+-----------DIALBACK OPTIMIZATION---------------+\n|                                               |\n|  B: <db:result from='c.example'               |\n|                to='rooms.a.example'/>         |\n|                                               |\n|  B: <db:result from='rooms.a.example'         |\n|                to='c.example'                 |\n|                type='valid'/>                 |\n|                                               |\n+-----------------------------------------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.2. A Simple S2S Scenario",
      "section_title": true,
      "ja": "4.2。シンプルS2Sシナリオ"
    },
    {
      "indent": 3,
      "text": "To illustrate the problem, consider the simplified order of events (see [RFC6120] for details) in establishing an XML stream between Server 1 (a.example) and Server 2 (b.example):",
      "ja": "問題を示すために、サーバ1（a.example）とサーバ2（b.example）との間にXMLストリームを確立する（詳細については[RFC6120]参照）イベントの簡略化された順序を考慮してください。"
    },
    {
      "indent": 3,
      "text": "1. Server 1 resolves via DNS the service _xmpp-server._tcp.b.example.",
      "ja": "1.サーバー1は、DNSを介してサービス_xmpp-server._tcp.b.exampleを解決します。"
    },
    {
      "indent": 3,
      "text": "2. Server 1 opens a TCP connection to the resolved IP address.",
      "section_title": true,
      "ja": "2.サーバ1は、解決されたIPアドレスへのTCP接続を開きます。"
    },
    {
      "indent": 3,
      "text": "3. Server 1 sends an initial stream header to Server 2, asserting that it is a.example:",
      "ja": "3.サーバ1は、それがa.exampleであることを主張する、サーバ2に初期ストリームヘッダを送信します。"
    },
    {
      "indent": 7,
      "text": "<stream:stream from='a.example' to='b.example'>",
      "ja": "<ストリーム：= 'b.example' へ= 'a.example' からの流れ>"
    },
    {
      "indent": 3,
      "text": "4. Server 2 sends a response stream header to Server 1, asserting that it is b.example:",
      "ja": "4.サーバー2は、それがb.exampleであることを主張する、サーバ1への応答ストリームのヘッダを送信します。"
    },
    {
      "indent": 7,
      "text": "<stream:stream from='b.example' to='a.example'>",
      "ja": "<ストリーム：= 'a.example' へ= 'b.example' からの流れ>"
    },
    {
      "indent": 3,
      "text": "5. The servers attempt TLS negotiation, during which Server 2 (acting as a TLS server) presents a PKIX certificate proving that it is b.example and Server 1 (acting as a TLS client) presents a PKIX certificate proving that it is a.example.",
      "ja": "5.サーバーは、（TLSクライアントとして動作する）サーバー2（TLSサーバとして動作するが）、それはb.exampleとサーバー1であることを証明PKIX証明書を提示している間に、TLSネゴシエーションを試み、それがあることを証明PKIX証明書を提示します。例。"
    },
    {
      "indent": 3,
      "text": "6. Server 1 checks the PKIX certificate that Server 2 provided, and Server 2 checks the PKIX certificate that Server 1 provided; if these proofs are consistent with the XMPP profile of the matching rules from [RFC6125] and are otherwise valid according to [RFC5280], each server accepts that there is a strong domain name association between its stream to the other party and the DNS domain name of the other party (i.e., mutual authentication is achieved).",
      "ja": "6.サーバー1つのチェックPKIXサーバ2に設けられた証明書、およびサーバ2つのチェックサーバ1が提供PKIX証明書。これらの証明は[RFC6125]からのマッチングルールのXMPPプロファイルと一致していると[RFC5280]によればそうでない有効な場合、各サーバは、他の当事者とDNSドメイン名への流れとの間の強力なドメイン名の関連付けがあることを受け入れ相手の（すなわち、相互認証が達成されます）。"
    },
    {
      "indent": 3,
      "text": "Several simplifying assumptions underlie the \"happy path\" scenario just outlined:",
      "ja": "いくつかの単純化の仮定がちょうど概説「ハッピーパス」シナリオの根底："
    },
    {
      "indent": 3,
      "text": "o The PKIX certificate presented by Server 2 during TLS negotiation is acceptable to Server 1 and matches the expected identity.",
      "ja": "O TLSネゴシエーション中にサーバ2が提示PKIX証明書がサーバ1に受け入れられると期待されるアイデンティティにマッチします。"
    },
    {
      "indent": 3,
      "text": "o The PKIX certificate presented by Server 1 during TLS negotiation is acceptable to Server 2; this enables the parties to complete mutual authentication.",
      "ja": "O TLSネゴシエーション中にサーバ1により提示PKIX証明書がサーバ2に受け入れられます。これは、相互認証を完了するために、関係者を可能にします。"
    },
    {
      "indent": 3,
      "text": "o There are no additional domains associated with Server 1 and Server 2 (say, a sub-domain rooms.a.example on Server 1 or a second domain c.example on Server 2).",
      "ja": "Oサーバ1とサーバ2（例えば、サーバ1上のサブドメインrooms.a.exampleまたはサーバー2上の第2ドメインc.example）に関連付けられた追加のドメインは存在しません。"
    },
    {
      "indent": 3,
      "text": "o The server administrators are able to obtain PKIX certificates issued by a widely accepted Certification Authority (CA) in the first place.",
      "ja": "サーバー管理者は、最初の場所で広く受け入れられている認証局（CA）によって発行されたPKIX証明書を取得することができますoを。"
    },
    {
      "indent": 3,
      "text": "o The server administrators are running their own XMPP servers, rather than using hosting services.",
      "ja": "Oサーバー管理者ではなくホスティングサービスを使用するよりも、自分のXMPPサーバーを実行しています。"
    },
    {
      "indent": 3,
      "text": "Let's consider each of these \"wrinkles\" in turn.",
      "ja": "のは、順番にこれらの「しわ」のそれぞれを考えてみましょう。"
    },
    {
      "indent": 0,
      "text": "4.3. No Mutual PKIX Authentication",
      "section_title": true,
      "ja": "4.3。いいえ相互PKIX認証ません"
    },
    {
      "indent": 3,
      "text": "If the PKIX certificate presented by Server 1 during TLS negotiation is not acceptable to Server 2, Server 2 is unable to mutually authenticate Server 1. Therefore, Server 2 needs to verify the asserted identity of Server 1 by other means.",
      "ja": "TLSネゴシエーション中にサーバ1が提示PKIX証明書がサーバ2に受け入れられない場合は、サーバ2は、相互に他の手段によって、サーバ1のアサートされた身元を確認するために、したがって、サーバ2つの要求をサーバ1を認証することができません。"
    },
    {
      "indent": 3,
      "text": "1. Server 1 asserts that it is a.example using the Server Dialback protocol:",
      "ja": "1.サーバー1は、サーバーのダイアルバックプロトコルを使用してa.exampleであることを主張します："
    },
    {
      "indent": 7,
      "text": "<db:result from='a.example' to='b.example'>\n           some-dialback-key</db:result>",
      "raw": true
    },
    {
      "indent": 3,
      "text": "2. Server 2 resolves via DNS the service _xmpp-server._tcp.a.example.",
      "ja": "2.サーバー2は、DNSを介してサービス_xmpp-server._tcp.a.exampleを解決します。"
    },
    {
      "indent": 3,
      "text": "3. Server 2 opens a TCP connection to the resolved IP address.",
      "section_title": true,
      "ja": "3.サーバー2は解決されたIPアドレスへのTCP接続を開きます。"
    },
    {
      "indent": 3,
      "text": "4. Server 2 sends an initial stream header to Server 1, asserting that it is b.example:",
      "ja": "4.サーバー2は、それがb.exampleであることを主張する、サーバ1に初期ストリームヘッダを送信します。"
    },
    {
      "indent": 7,
      "text": "<stream:stream from='b.example' to='a.example'>",
      "ja": "<ストリーム：= 'a.example' へ= 'b.example' からの流れ>"
    },
    {
      "indent": 3,
      "text": "5. Server 1 sends a response stream header to Server 2, asserting that it is a.example:",
      "ja": "5.サーバ1は、それがa.exampleであることを主張する、サーバ2に応答ストリームヘッダを送信します。"
    },
    {
      "indent": 7,
      "text": "<stream:stream from='a.example' to='b.example'>",
      "ja": "<ストリーム：= 'b.example' へ= 'a.example' からの流れ>"
    },
    {
      "indent": 3,
      "text": "6. The servers attempt TLS negotiation, during which Server 1 (acting as a TLS server) presents a PKIX certificate.",
      "ja": "6.サーバは、サーバ1（TLSサーバとして作用する）PKIX証明書を提示している間に、TLSネゴシエーションを試みます。"
    },
    {
      "indent": 3,
      "text": "7. Server 2 checks the PKIX certificate that Server 1 provided (this might be the same certificate presented by Server 1 as a client certificate in the initial connection). However, Server 2 does not accept this certificate as proving that Server 1 is authorized as a.example and therefore uses another method (here, the Server Dialback protocol) to establish the domain name association.",
      "ja": "7.サーバー2つのチェックサーバ1が提供PKIX証明書（これは最初の接続でのクライアント証明書としてサーバ1により提示される同一の証明書であるかもしれません）。しかし、サーバ2そのサーバ1を証明するように、この証明書を受け入れていないがa.exampleとして認可されているため、ドメイン名の関連付けを確立するために、別の方法（ここでは、サーバーのダイアルバックプロトコル）を使用しています。"
    },
    {
      "indent": 3,
      "text": "8. Server 2 proceeds with Server Dialback in order to establish the domain name association. In order to do this, it sends a request for verification as described in [XEP-0220]:",
      "ja": "ドメイン名の関連付けを確立するために、サーバーダイアルバック8.サーバ2進行。 [XEP-0220]に記載されているように、これを行うためには、検証要求を送信します。"
    },
    {
      "indent": 7,
      "text": "<db:verify from='b.example' to='a.example'\n           id='...'>some-dialback-key</db:verify>",
      "raw": true
    },
    {
      "indent": 3,
      "text": "9. Server 1 responds to this:",
      "section_title": true,
      "ja": "9.サーバ1は、これに応答します。"
    },
    {
      "indent": 7,
      "text": "<db:verify from='a.example' to='b.example' id='...' type='valid/>",
      "ja": "<DB：= 'b.example' ID =へ= 'a.example' から検証 '...' タイプ= '有効/>"
    },
    {
      "indent": 7,
      "text": "allowing Server 2 to establish the domain name association.",
      "ja": "サーバ2は、ドメイン名の関連付けを確立することができます。"
    },
    {
      "indent": 3,
      "text": "In some situations (e.g., if the Authoritative Server in Server Dialback presents the same certificate as the Originating Server), it is the practice of some XMPP server implementations to skip steps 8 and 9. These situations are discussed in \"Impact of TLS and DNSSEC on Dialback\" [XEP-0344].",
      "ja": "いくつかの状況（例えば、サーバーダイアルバックで権威サーバが元のサーバーと同じ証明書を提示している場合）には、これらの状況は、TLSの影響とDNSSEC」で説明されている手順8と9をスキップするためにいくつかのXMPPサーバーの実装の練習ですダイアルバックの」[XEP-0344]。"
    },
    {
      "indent": 0,
      "text": "4.4. Piggybacking",
      "section_title": true,
      "ja": "4.4。ピギーバック"
    },
    {
      "indent": 0,
      "text": "4.4.1. Assertion",
      "section_title": true,
      "ja": "4.4.1。アサーション"
    },
    {
      "indent": 3,
      "text": "Consider the common scenario in which Server 2 hosts not only b.example but also a second domain c.example (often called a \"multi-tenanted\" environment). If a user of Server 2 associated with c.example wishes to communicate with a friend at a.example, Server 2 needs to send XMPP stanzas from the domain c.example rather than b.example. Although Server 2 could open a new TCP connection and negotiate new XML streams for the domain pair of c.example and a.example, that is wasteful (especially if Server 2 hosts a large number of domains). Server 2 already has a connection to a.example, so how can it assert that it would like to add a new domain pair to the existing connection?",
      "ja": "（多くの場合、「マルチテナント」環境と呼ばれる）b.exampleだけでなく、第二のドメインc.exampleどのサーバーで2つのホストだけでなく、一般的なシナリオを考えてみましょう。 c.exampleに関連付けられたサーバ2のユーザが、a.exampleで友人と通信することを希望する場合は、サーバ2つの要求は、ドメインc.exampleからというよりも、b.example XMPPスタンザを送信します。サーバ2は、新しいTCP接続を開き、c.exampleとa.exampleのドメインのペアのための新しいXMLストリームを交渉することができますが、それは（特にサーバ2つのホストドメインの数が多い場合は）無駄です。サーバ2は、すでにa.exampleへの接続を持っているので、どのようにそれが既存の接続に新しいドメインのペアを追加したいと主張することができますか？"
    },
    {
      "indent": 3,
      "text": "The traditional method for doing so is the Server Dialback protocol [XEP-0220]. Here, Server 2 can send a <db:result/> element for the new domain pair over the existing stream.",
      "ja": "そうするための従来の方法は、サーバーのダイアルバックプロトコル[XEP-0220]です。既存のストリームを超える新しいドメインのペアのために：<結果/ DB>要素ここでは、サーバ2は、送信することができます。"
    },
    {
      "indent": 7,
      "text": "<db:result from='c.example' to='a.example'>\n  some-dialback-key\n</db:result>",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This <db:result/> element functions as Server 2's assertion that it is (also) c.example (thus, the element is functionally equivalent to the 'from' address of an initial stream header as previously described).",
      "ja": "この<DB：結果/>要素の機能が（も）c.example（従って、要素は、前述のように、初期ストリームヘッダの「から」アドレスと機能的に等価である）であることをサーバ2のアサーションとして。"
    },
    {
      "indent": 3,
      "text": "In response to this assertion, Server 1 needs to obtain some kind of proof that Server 2 really is also c.example. If the certificate presented by Server 2 is also valid for c.example, then no further action is necessary. However, if not, then Server 1 needs to do a bit more work. Specifically, Server 1 can pursue the same strategy it used before:",
      "ja": "この主張に応じて、サーバ1つの要求をサーバ2は本当にもc.exampleであることの証明のいくつかの種類を取得します。サーバー2で提示された証明書がc.exampleのためにも有効であれば、それ以上の操作は必要ありません。ない場合は、[サーバー1は、もう少し仕事をする必要があります。具体的には、サーバ1は、それが前に使用したのと同じ戦略を追求することができます。"
    },
    {
      "indent": 3,
      "text": "1. Server 1 resolves via DNS the service _xmpp-server._tcp.c.example.",
      "ja": "1.サーバー1は、DNSを介してサービス_xmpp-server._tcp.c.exampleを解決します。"
    },
    {
      "indent": 3,
      "text": "2. Server 1 opens a TCP connection to the resolved IP address (which might be the same IP address as for b.example).",
      "ja": "2.サーバ1は、（b.exampleと同じIPアドレスであるかもしれない）解決されたIPアドレスへのTCP接続を開きます。"
    },
    {
      "indent": 3,
      "text": "3. Server 1 sends an initial stream header to Server 2, asserting that it is a.example:",
      "ja": "3.サーバ1は、それがa.exampleであることを主張する、サーバ2に初期ストリームヘッダを送信します。"
    },
    {
      "indent": 7,
      "text": "<stream:stream from='a.example' to='c.example'>",
      "ja": "<ストリーム：= 'c.example' へ= 'a.example' からの流れ>"
    },
    {
      "indent": 3,
      "text": "4. Server 2 sends a response stream header to Server 1, asserting that it is c.example:",
      "ja": "4.サーバー2は、それがc.exampleであることを主張する、サーバ1への応答ストリームのヘッダを送信します。"
    },
    {
      "indent": 7,
      "text": "<stream:stream from='c.example' to='a.example'>",
      "ja": "<ストリーム：= 'a.example' へ= 'c.example' からの流れ>"
    },
    {
      "indent": 3,
      "text": "5. The servers attempt TLS negotiation, during which Server 2 (acting as a TLS server) presents a PKIX certificate proving that it is c.example.",
      "ja": "5.サーバーは、それがc.exampleであることを証明PKIX証明書を提示するサーバー2（TLSサーバとして動作）の間にTLSネゴシエーションを、試みます。"
    },
    {
      "indent": 3,
      "text": "6. At this point, Server 1 needs to establish that, despite different certificates, c.example is associated with the origin of the request. This is done using Server Dialback [XEP-0220]:",
      "ja": "6.この時点で、サーバ1は、異なる証明書にもかかわらず、c.exampleは、要求の発信元に関連付けられている、ことを確立する必要があります。これは、サーバーのダイアルバック[XEP-0220]を使用して行われます。"
    },
    {
      "indent": 7,
      "text": "<db:verify from='a.example' to='c.example'\n           id='...'>some-dialback-key</db:verify>",
      "raw": true
    },
    {
      "indent": 3,
      "text": "7. Server 2 responds to this:",
      "section_title": true,
      "ja": "7.サーバ2はこれに応答します。"
    },
    {
      "indent": 7,
      "text": "<db:verify from='c.example' to='a.example' id='...' type='valid/>",
      "ja": "<DB：= 'a.example' に= 'c.example' から検証するID = '...' タイプ= '有効/>"
    },
    {
      "indent": 7,
      "text": "allowing Server 1 to establish the domain name association.",
      "ja": "サーバ1は、ドメイン名の関連付けを確立することができます。"
    },
    {
      "indent": 3,
      "text": "Now that Server 1 accepts the domain name association, it informs Server 2 of that fact:",
      "ja": "今、そのサーバ1は、ドメイン名の関連付けを受け入れ、それがその事実をサーバ2に通知します："
    },
    {
      "indent": 7,
      "text": "<db:result from='a.example' to='c.example' type='valid'/>",
      "ja": "<DB：タイプ= 'c.example' へ= 'a.example' からもたらさ= '有効' />"
    },
    {
      "indent": 3,
      "text": "The parties can then terminate the second connection, because it was used only for Server 1 to associate a stream with the domain name c.example (the dialback key links the original stream to the new association).",
      "ja": "それはドメイン名c.example（ダイヤルバックキーリンク新しいアソシエーションに元のストリーム）でストリームを関連付けるためにのみサーバ1のために使用されたため、当事者はその後、第二の接続を終了することができます。"
    },
    {
      "indent": 0,
      "text": "4.4.2. Supposition",
      "section_title": true,
      "ja": "4.4.2。仮定"
    },
    {
      "indent": 3,
      "text": "Piggybacking can also occur in the other direction. Consider the common scenario in which Server 1 provides XMPP services not only for a.example but also for a sub-domain such as a Multi-User Chat [XEP-0045] service at rooms.a.example. If a user from c.example at Server 2 wishes to join a room on the groupchat service, Server 2 needs to send XMPP stanzas from the domain c.example to the domain rooms.a.example rather than a.example.",
      "ja": "ピギーバッキングは、他の方向に発生する可能性があります。サーバ1は、a.exampleのためだけでなく、マルチユーザーチャット[XEP-0045] rooms.a.exampleのサービスとして、サブドメインのためだけでなく、XMPPサービスを提供する一般的なシナリオを考えてみましょう。サーバー2でc.exampleからユーザーがグループチャットサービスのルームに参加することを希望する場合は、サーバ2つの要求はXMPPがドメインrooms.a.exampleではなくa.exampleにドメインc.exampleからスタンザ送信します。"
    },
    {
      "indent": 3,
      "text": "First, Server 2 needs to determine whether it can piggyback the domain rooms.a.example on the connection to a.example:",
      "ja": "まず、サーバ2は、それがa.exampleへの接続にドメインrooms.a.exampleを背負うことができるかどうかを判断する必要があります："
    },
    {
      "indent": 3,
      "text": "1. Server 2 resolves via DNS the service _xmpp-server._tcp.rooms.a.example.",
      "ja": "1.サーバー2は、DNSを介してサービス_xmpp-server._tcp.rooms.a.exampleを解決します。"
    },
    {
      "indent": 3,
      "text": "2. Server 2 determines that this resolves to an IP address and port to which it is already connected.",
      "ja": "2.サーバ2は、これは、それがすでに接続されているIPアドレスとポートに解決されることを決定します。"
    },
    {
      "indent": 3,
      "text": "3. Server 2 determines that the PKIX certificate for that active connection would also be valid for the rooms.a.example domain and that Server 1 has announced support for dialback errors.",
      "ja": "3.サーバー2はrooms.a.exampleドメインとそのサーバ1は、ダイヤルバック・エラーのサポートを発表しているため、そのアクティブな接続のためのPKIX証明書も有効だろうと判断します。"
    },
    {
      "indent": 3,
      "text": "Server 2 sends a dialback key to Server 1 over the existing connection:",
      "ja": "サーバ2は、既存の接続を介してサーバ1へのダイヤルバックキーを送信します。"
    },
    {
      "indent": 7,
      "text": "<db:result from='c.example' to='rooms.a.example'>\n  some-dialback-key\n</db:result>",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Server 1 then informs Server 2 that it accepts the domain name association:",
      "ja": "サーバ1は、それがドメイン名の関連付けを受け入れるサーバ2に通知します："
    },
    {
      "indent": 7,
      "text": "<db:result from='rooms.a.example' to='c.example' type='valid'/>",
      "ja": "<DB：タイプ= 'c.example' へ= 'rooms.a.example' からもたらさ= '有効' />"
    },
    {
      "indent": 0,
      "text": "5. Alternative Prooftypes",
      "section_title": true,
      "ja": "5.代替Prooftypes"
    },
    {
      "indent": 3,
      "text": "The foregoing protocol flows assumed that domain name associations were proved using the PKIX prooftype. However, sometimes XMPP server administrators are unable or unwilling to obtain valid PKIX certificates for all of the domains they host at their servers. For example:",
      "ja": "上記のプロトコル・フローは、ドメイン名の関連付けは、PKIXのprooftypeを用いて証明されたと仮定する。しかし、時々、XMPPサーバーの管理者は、彼らが自分のサーバーでホストするドメインのすべての有効なPKIX証明書を取得することができないか、不本意です。例えば："
    },
    {
      "indent": 3,
      "text": "o In order to issue a PKIX certificate, a CA might try to send email messages to authoritative mailbox names [RFC2142], but the administrator of a subsidiary service such as im.cs.podunk.example cannot receive email sent to hostmaster@podunk.example.",
      "ja": "O PKIX証明書を発行するために、CAは、信頼できるメールボックス名[RFC2142]に電子メールメッセージを送信しようとするかもしれませんが、そのようなim.cs.podunk.exampleなどの補助サービスの管理者は、ホストマスタの@ podunkに送信されたメールを受信できません。例。"
    },
    {
      "indent": 3,
      "text": "o A hosting provider such as hosting.example.net might not want to take on the liability of holding the certificate and private key for a tenant such as example.com (or the tenant might not want the hosting provider to hold its certificate and private key).",
      "ja": "Oなどのホスティングプロバイダはhosting.example.netはexample.comなどテナントの証明書と秘密鍵を保持する責任を取るしたくないかもしれません（またはテナントは、その証明書と秘密を保持するためのホスティングプロバイダを望んでいない可能性がありますキー）。"
    },
    {
      "indent": 3,
      "text": "o Even if PKIX certificates for each tenant can be obtained, the management of so many certificates can introduce a large administrative load.",
      "ja": "各テナントのためのPKIX証明書を得ることができたとしても、O、非常に多くの証明書の管理は、大規模な管理負荷を導入することができます。"
    },
    {
      "indent": 3,
      "text": "(Additional discussion can be found in [RFC7711].)",
      "ja": "（さらなる議論は[RFC7711]に見出すことができます。）"
    },
    {
      "indent": 3,
      "text": "In these circumstances, prooftypes other than PKIX are desirable or necessary. As described below, two alternatives have been defined so far: DNS-Based Authentication of Named Entities (DANE) and PKIX over Secure HTTP (POSH).",
      "ja": "このような状況では、PKIX以外prooftypesが望ましいまたは必要です。後述するように、2つの選択肢がこれまでに定義されています。名前付きエンティティ（DANE）とPKIXのDNSベースの認証をセキュアHTTP（POSH）の上に。"
    },
    {
      "indent": 0,
      "text": "5.1. DANE",
      "section_title": true,
      "ja": "5.1。 DETAILS"
    },
    {
      "indent": 3,
      "text": "The DANE prooftype is defined as follows:",
      "ja": "次のようにDANEのprooftypeが定義されています。"
    },
    {
      "indent": 3,
      "text": "1. The server's proof consists of either a service certificate or domain-issued certificate (TLSA usage PKIX-EE or DANE-EE; see [RFC6698] and [RFC7218]).",
      "ja": "1.サーバーの証明は、サービス証明書またはドメイン発行の証明書のいずれかで構成され（TLSAの使用PKIX-EEまたはDANE-EE; [RFC6698]と[RFC7218]を参照します）。"
    },
    {
      "indent": 3,
      "text": "2. The proof is checked by verifying an exact match or a hash of either the SubjectPublicKeyInfo or the full certificate.",
      "ja": "2.証拠は、完全一致またはSubjectPublicKeyInfoで、または完全な証明書のいずれかのハッシュを検証することにより確認されます。"
    },
    {
      "indent": 3,
      "text": "3. The client's verification material is obtained via secure DNS [RFC4033] as described in [RFC7673].",
      "ja": "[RFC7673]に記載されているように3クライアントの検証材料は、セキュアDNS [RFC4033]を介して得られます。"
    },
    {
      "indent": 3,
      "text": "4. Secure DNS is necessary in order to effectively establish an alternative chain of trust from the service certificate or domain-issued certificate to the DNS root.",
      "ja": "4.セキュアなDNSが効果的にDNSルートへのサービスの証明書またはドメインから発行された証明書の信頼の代替チェーンを確立するために必要です。"
    },
    {
      "indent": 3,
      "text": "The DANE prooftype makes use of DNS-Based Authentication of Named Entities [RFC6698], specifically the use of DANE with DNS SRV records [RFC7673]. For XMPP purposes, the following rules apply:",
      "ja": "DANEのprooftypeは、名前付きエンティティのDNSベースの認証[RFC6698]、DNS SRVレコード[RFC7673]とDANEの、具体的使用を使用しています。 XMPPの目的のために、以下の規則が適用されます。"
    },
    {
      "indent": 3,
      "text": "o If there is no SRV resource record, pursue the fallback methods described in [RFC6120].",
      "ja": "何SRVリソースレコードが存在しない場合はO、[RFC6120]に記載の代替方法を追求します。"
    },
    {
      "indent": 3,
      "text": "o Use the 'to' address of the initial stream header to determine the domain name of the TLS client's reference identifier (because the use of the Server Name Indication extension (TLS SNI) [RFC6066] is purely discretionary in XMPP, as mentioned in [RFC6120]).",
      "ja": "Oサーバ名表示拡張（TLS SNI）[RFC6066]の使用は、XMPPに純粋に任意であるためで述べたように、（TLSクライアントの参照識別子のドメイン名を決定するために、初期ストリームヘッダの「」のアドレスを使用して[ RFC6120]）。"
    },
    {
      "indent": 0,
      "text": "5.2. POSH",
      "section_title": true,
      "ja": "5.2。 POSH"
    },
    {
      "indent": 3,
      "text": "The POSH prooftype is defined as follows:",
      "ja": "次のようにPOSH prooftypeが定義されています。"
    },
    {
      "indent": 3,
      "text": "1. The server's proof consists of a PKIX certificate.",
      "section_title": true,
      "ja": "1.サーバーの証明は、PKIX証明書で構成されています。"
    },
    {
      "indent": 3,
      "text": "2. The proof is checked according to the rules from [RFC6120] and [RFC6125].",
      "ja": "2.証拠は、[RFC6120]及び[RFC6125]のルールに従ってチェックされます。"
    },
    {
      "indent": 3,
      "text": "3. The client's verification material is obtained by retrieving a hash of the PKIX certificate over HTTPS at a well-known URI [RFC5785].",
      "ja": "3.クライアントの検証材料は、よく知られたURI [RFC5785]でHTTPS経由でPKIX証明書のハッシュを取得することによって得られます。"
    },
    {
      "indent": 3,
      "text": "4. Secure DNS is not necessary, because the HTTPS retrieval mechanism relies on the chain of trust from the public key infrastructure.",
      "ja": "HTTPSの検索機構は、公開鍵インフラストラクチャからの信頼の連鎖に依存しているため4.セキュアDNSは、必要ありません。"
    },
    {
      "indent": 3,
      "text": "POSH is defined in [RFC7711]. For XMPP purposes, the following rules apply:",
      "ja": "POSHは、[RFC7711]で定義されています。 XMPPの目的のために、以下の規則が適用されます。"
    },
    {
      "indent": 3,
      "text": "o If no verification material is found via POSH, pursue the fallback methods described in [RFC6120].",
      "ja": "全く検証材料がPOSHを介して検出されない場合、O、[RFC6120]に記載のフォールバック方法を追求します。"
    },
    {
      "indent": 3,
      "text": "o Use the 'to' address of the initial stream header to determine the domain name of the TLS client's reference identifier (because the use of TLS SNI [RFC6066] is purely discretionary in XMPP, as mentioned in [RFC6120]).",
      "ja": "O TLSクライアントの参照識別子のドメイン名を決定するために、初期ストリームヘッダの「」のアドレスを使用して（TLS SNI [RFC6066]の使用は、XMPPに純粋に任意であるためで述べたように、[RFC6120]）。"
    },
    {
      "indent": 3,
      "text": "The well-known URIs [RFC5785] to be used for POSH are:",
      "ja": "POSHのために使用される周知のURI [RFC5785]は、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o \"/.well-known/posh/xmpp-client.json\" for client-to-server connections",
      "ja": "クライアントからサーバーへの接続のためのO「/.well-known/posh/xmpp-client.json」"
    },
    {
      "indent": 3,
      "text": "o \"/.well-known/posh/xmpp-server.json\" for server-to-server connections",
      "ja": "サーバー間接続用O「/.well-known/posh/xmpp-server.json」"
    },
    {
      "indent": 0,
      "text": "6. Secure Delegation and Multi-Tenancy",
      "section_title": true,
      "ja": "6.セキュア委任とマルチテナント"
    },
    {
      "indent": 3,
      "text": "One common method for deploying XMPP services is multi-tenancy: e.g., XMPP services for the service domain name example.com are actually hosted at the target server hosting.example.net. Such an arrangement is relatively convenient in XMPP given the use of DNS SRV records [RFC2782], such as the following delegation from example.com to hosting.example.net:",
      "ja": "XMPPサービスを展開するための1つの一般的な方法は、マルチテナントである：例えば、サービスのドメイン名example.comのXMPPサービスは、実際にターゲットサーバhosting.example.netでホストされています。このような配置は、hosting.example.netにexample.comから次の委任としてDNS SRVレコード[RFC2782]を使用する与えられたXMPPに比較的便利です。"
    },
    {
      "indent": 3,
      "text": "_xmpp-server._tcp.example.com. 0 IN SRV 0 0 5269 hosting.example.net",
      "ja": "_xmpp-server._tcp.example.com。 SRV 0 0 5269 0 hosting.example.net"
    },
    {
      "indent": 3,
      "text": "Secure connections with multi-tenancy can work using the PKIX prooftype on a small scale if the provider itself wishes to host several domains (e.g., related domains such as jabber-de.example and jabber-ch.example). However, in practice the security of multi-tenancy has been found to be unwieldy when the provider hosts large numbers of XMPP services on behalf of multiple tenants (see [RFC7711] for a detailed description). There are two possible results: either (1) server-to-server communications to example.com are unencrypted or (2) the communications are TLS-encrypted but the certificates are not checked (which is functionally equivalent to a connection using an anonymous key exchange). This is also true of client-to-server communications, forcing end users to override certificate warnings or configure their clients to accept or \"pin\" certificates for hosting.example.net instead of example.com. The fundamental problem here is that if DNSSEC is not used, then the act of delegation via DNS SRV records is inherently insecure.",
      "ja": "プロバイダ自体が複数のドメインをホストすることを望む場合、マルチテナントとのセキュア接続が小規模でPKIXのprooftypeを使用して動作することができ（例えば、ジャバ・de.exampleとジャバー-ch.exampleなどの関連ドメイン）。しかし、実際にはマルチテナントのセキュリティプロバイダは、複数のテナントの代わりにXMPPサービスの多数をホストするときに扱いにくいことが判明している（詳細については[RFC7711]を参照）。結果は2通りの可能性があります。どちらか（1）example.comとサーバー間の通信は暗号化されていないか、（2）通信は、TLSは、暗号化されますが、証明書が匿名キーを使用して接続と機能的に同等である（チェックされないです交換）。これは、証明書の警告を上書きするか、代わりにexample.comのhosting.example.netのために受け入れるか、または「ピン」証明するために彼らのクライアントを設定するには、エンドユーザーを強制的に、また、クライアントからサーバへの通信の事実です。ここでの基本的な問題は、DNSSECが使用されていない場合は、DNS SRVレコードを介した代表団の行為は本質的に安全であるということです。"
    },
    {
      "indent": 3,
      "text": "The specification for the use of SRV records with DANE [RFC7673] explains how to use DNSSEC for secure delegation with the DANE prooftype, and the POSH specification [RFC7711] explains how to use HTTPS redirects for secure delegation with the POSH prooftype.",
      "ja": "DANE [RFC7673]でSRVレコードを使用するための仕様は、DANEのprooftypeとの安全な委任にDNSSECを使用する方法について説明し、POSH仕様[RFC7711]はHTTPSがPOSH prooftypeとのセキュアな委任にリダイレクトを使用する方法について説明します。"
    },
    {
      "indent": 0,
      "text": "7. Prooftype Model",
      "section_title": true,
      "ja": "7. Prooftypeモデル"
    },
    {
      "indent": 3,
      "text": "In general, a Domain Name Association (DNA) prooftype conforms to the following definition:",
      "ja": "一般的に、ドメイン名協会（DNA）prooftypeは、次の定義に準拠しています。"
    },
    {
      "indent": 3,
      "text": "prooftype: A mechanism for proving an association between a domain name and an XML stream, where the mechanism defines (1) the nature of the server's proof, (2) the matching rules for comparing the client's verification material against the server's proof, (3) how the client obtains its verification material, and (4) whether or not the mechanism depends on secure DNS.",
      "ja": "prooftype：ドメイン名と機構は、サーバの証明の（1）の性質を定義するXMLストリームとの間の関連性を証明するための機構、（2）サーバの証明、反対クライアントの検証材料を比較するためのマッチングルール（3 ）クライアントは、その検証の材料を取得する方法、および（4）のメカニズムは、セキュアなDNSに依存しているか否か。"
    },
    {
      "indent": 3,
      "text": "The PKIX, DANE, and POSH prooftypes adhere to this model. (Some prooftypes depend on, or are enhanced by, secure DNS [RFC4033] and thus also need to describe how they ensure secure delegation.)",
      "ja": "PKIX、DANE、及びPOSH prooftypesは、このモデルに準拠しています。 （一部prooftypesが依存する、または、セキュアなDNS [RFC4033]によって強化されているので、また、彼らは安全な委任を確保する方法を説明する必要があります。）"
    },
    {
      "indent": 3,
      "text": "Other prooftypes are possible; examples might include TLS with Pretty Good Privacy (PGP) keys [RFC6091], a token mechanism such as Kerberos [RFC4120] or OAuth [RFC6749], and Server Dialback keys [XEP-0220].",
      "ja": "その他prooftypesが可能です。例はかなり良いようにケルベロス[RFC4120]やOAuthの[RFC6749]としてプライバシー（PGP）キー[RFC6091]、トークンのメカニズム、およびサーバーのダイアルバックキー[XEP-0220]でTLSが含まれる場合があります。"
    },
    {
      "indent": 3,
      "text": "Although the PKIX prooftype reuses the syntax of the XMPP Server Dialback protocol [XEP-0220] for signaling between servers, this framework document does not define how the generation and validation of Server Dialback keys (also specified in [XEP-0220]) constitute a DNA prooftype. However, nothing in this document prevents the continued use of Server Dialback for signaling, and a future specification (or an updated version of [XEP-0220]) might define a DNA prooftype for Server Dialback keys in a way that is consistent with this framework.",
      "ja": "PKIXのprooftype、サーバ間のシグナリングのためのXMPPサーバダイアルバックプロトコル[XEP-0220】の構文を再利用するが、このフレームワークのドキュメントサーバーダイアルバックキーの生成および検証（こちらも指定する[XEP-0220】）を構成する方法を定義していませんDNAのprooftype。しかし、この文書に記載されているものは、シグナリングのためにサーバーダイアルバックの継続使用を防止しない、および将来の仕様（または[XEP-0220]の更新されたバージョン）は、このフレームワークと一致するようにサーバダイアルバックキーのDNAのprooftypeを定義するかもしれません。"
    },
    {
      "indent": 0,
      "text": "8. Guidance for Server Operators",
      "section_title": true,
      "ja": "サーバー事業者向け8.ガイダンス"
    },
    {
      "indent": 3,
      "text": "This document introduces the concept of a prooftype in order to explain and generalize the approach to establishing a strong association between the DNS domain name of an XMPP service and the XML stream that a client or peer server initiates with that service.",
      "ja": "この文書は、クライアントまたはピアサーバーは、そのサービスに開始することをXMPPサービスのDNSドメイン名とXMLストリームとの間に強い関連性を確立するためのアプローチを説明し、一般化するためにprooftypeの概念を導入しています。"
    },
    {
      "indent": 3,
      "text": "The operations and management implications of DNA prooftypes will depend on the particular prooftypes that an operator supports. For example:",
      "ja": "DNAのprooftypesの運用及び管理の含意は、オペレータがサポートする特定のprooftypesに依存するであろう。例えば："
    },
    {
      "indent": 3,
      "text": "o To support the PKIX prooftype [RFC6120], an operator needs to obtain certificates for the XMPP server from a Certification Authority (CA). However, DNS Security is not required.",
      "ja": "PKIXのprooftype [RFC6120]をサポートするためにO、オペレータは、証明機関（CA）からのXMPPサーバの証明書を取得する必要があります。しかし、DNSセキュリティが必要とされていません。"
    },
    {
      "indent": 3,
      "text": "o To support the DANE prooftype [RFC7673], an operator can generate its own certificates for the XMPP server or obtain them from a CA. In addition, DNS Security is required.",
      "ja": "OオペレータがXMPPサーバー用に独自の証明書を生成したり、CAからそれらを得ることができ、DANEのprooftype [RFC7673]をサポートするためにまた、DNSのセキュリティが要求されます。"
    },
    {
      "indent": 3,
      "text": "o To support the POSH prooftype [RFC7711], an operator can generate its own certificates for the XMPP server or obtain them from a CA, but in addition needs to deploy the web server for POSH files with certificates obtained from a CA. However, DNS Security is not required.",
      "ja": "POSH prooftype [RFC7711]をサポートするためにoは、オペレータは、XMPPサーバー用に独自の証明書を生成したり、CAからそれらを取得し、それに加えて、CAから入手した証明書を使用してPOSHファイルのためのWebサーバーを展開する必要がありますすることができますしかし、DNSセキュリティが必要とされていません。"
    },
    {
      "indent": 3,
      "text": "Considerations for the use of the foregoing prooftypes are explained in the relevant specifications. See in particular Section 13.7 of [RFC6120], Section 6 of [RFC7673], and Section 7 of [RFC7711].",
      "ja": "前述prooftypesを使用するための考慮事項は、関連する仕様書に説明されています。特定[RFC6120]、[RFC7673]のセクション6のセクション13.7、及び[RFC7711]のセクション7を参照。"
    },
    {
      "indent": 3,
      "text": "Naturally, these operations and management considerations are additive: if an operator wishes to use multiple prooftypes, the complexity of deployment increases (e.g., the operator might want to obtain a PKIX certificate from a CA for use in the PKIX prooftype and generate its own certificate for use in the DANE prooftype). This is an unavoidable aspect of supporting as many prooftypes as needed in order to ensure that domain name associations can be established in the largest possible percentage of cases.",
      "ja": "当然のことながら、これらの操作及び管理に関する考慮事項が添加されている：オペレータは、複数のprooftypesを使用したい場合は、展開の複雑さが増す（例えば、オペレータは、PKIX prooftypeで使用するためにCAからPKIX証明書を取得し、独自の証明書を生成する場合がありますDANEのprooftypeで使用するため）。これは、ドメイン名の関連は例可能な最大の割合で確立することができることを確実にするために必要なだけprooftypesをサポートするの避けられない側面です。"
    },
    {
      "indent": 0,
      "text": "9. IANA Considerations",
      "section_title": true,
      "ja": "9. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "The POSH specification [RFC7711] establishes the \"POSH Service Names\" registry for use in well-known URIs [RFC5785]. This specification registers two such service names for use in XMPP: \"xmpp-client\" and \"xmpp-server\". The completed registration templates follow.",
      "ja": "POSH仕様[RFC7711]は、よく知られたURI [RFC5785]で使用する「POSHサービス名」レジストリを確立します。 「XMPPクライアント」および「XMPPサーバー」：この仕様は、XMPPでの使用のための2人のようなサービス名を登録します。完成した登録テンプレートが続きます。"
    },
    {
      "indent": 0,
      "text": "9.1. POSH Service Name for xmpp-client Service",
      "section_title": true,
      "ja": "9.1。 XMPPクライアントサービスのPOSHサービス名"
    },
    {
      "indent": 3,
      "text": "Service name: xmpp-client",
      "ja": "サービス名：XMPPクライアント"
    },
    {
      "indent": 3,
      "text": "Change controller: IETF",
      "ja": "変更コントローラ：IETF"
    },
    {
      "indent": 3,
      "text": "Definition and usage: Specifies the location of a POSH file containing verification material or a reference thereto that enables a client to verify the identity of a server for a client-to-server stream in XMPP",
      "ja": "定義及び使用法は：それはXMPPクライアントからサーバーへのストリームのサーバーの身元を確認するためにクライアントを可能それ検証物質または参照を含むPOSHファイルの場所を指定します"
    },
    {
      "indent": 3,
      "text": "Specification: RFC 7712 (this document)",
      "ja": "仕様：RFC 7712（本書）"
    },
    {
      "indent": 0,
      "text": "9.2. POSH Service Name for xmpp-server Service",
      "section_title": true,
      "ja": "9.2。 XMPPサーバーサービスのPOSHサービス名"
    },
    {
      "indent": 3,
      "text": "Service name: xmpp-server",
      "ja": "サービス名：XMPPサーバー"
    },
    {
      "indent": 3,
      "text": "Change controller: IETF",
      "ja": "変更コントローラ：IETF"
    },
    {
      "indent": 3,
      "text": "Definition and usage: Specifies the location of a POSH file containing verification material or a reference thereto that enables a server to verify the identity of a peer server for a server-to-server stream in XMPP",
      "ja": "定義及び使用法は：それはXMPPにサーバー間のストリームのためのピア・サーバーの身元を確認するためにサーバーを可能それ検証物質または参照を含むPOSHファイルの場所を指定します"
    },
    {
      "indent": 3,
      "text": "Specification: RFC 7712 (this document)",
      "ja": "仕様：RFC 7712（本書）"
    },
    {
      "indent": 0,
      "text": "10. Security Considerations",
      "section_title": true,
      "ja": "10.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "With regard to the PKIX prooftype, this document supplements but does not supersede the security considerations of [RFC6120] and [RFC6125].",
      "ja": "PKIXのprooftypeに関しては、このドキュメントのサプリメントが、[RFC6120]と[RFC6125]のセキュリティ上の配慮を優先していません。"
    },
    {
      "indent": 3,
      "text": "With regard to the DANE and POSH prooftypes, the reader is referred to [RFC7673] and [RFC7711], respectively.",
      "ja": "DANEとPOSH prooftypesに関しては、読者は、それぞれ、[RFC7673]及び[RFC7711]と呼ばれます。"
    },
    {
      "indent": 3,
      "text": "Any future prooftypes need to thoroughly describe how they conform to the prooftype model specified in Section 7 of this document.",
      "ja": "将来prooftypesは徹底的に彼らはこのドキュメントのセクション7で指定されたprooftypeモデルに適合方法を記述する必要があります。"
    },
    {
      "indent": 0,
      "text": "11. References",
      "section_title": true,
      "ja": "11.参考文献"
    },
    {
      "indent": 0,
      "text": "11.1. Normative References",
      "section_title": true,
      "ja": "11.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC1034] Mockapetris, P., \"Domain names - concepts and facilities\", STD 13, RFC 1034, DOI 10.17487/RFC1034, November 1987, <http://www.rfc-editor.org/info/rfc1034>.",
      "ja": "[RFC1034] Mockapetris、P.、 \"ドメイン名 - 概念と設備\"、STD 13、RFC 1034、DOI 10.17487 / RFC1034、1987年11月、<http://www.rfc-editor.org/info/rfc1034>。"
    },
    {
      "indent": 3,
      "text": "[RFC1035] Mockapetris, P., \"Domain names - implementation and specification\", STD 13, RFC 1035, DOI 10.17487/RFC1035, November 1987, <http://www.rfc-editor.org/info/rfc1035>.",
      "ja": "[RFC1035] Mockapetris、P.、 \"ドメイン名 - 実装及び仕様\"、STD 13、RFC 1035、DOI 10.17487 / RFC1035、1987年11月、<http://www.rfc-editor.org/info/rfc1035>。"
    },
    {
      "indent": 3,
      "text": "[RFC2782] Gulbrandsen, A., Vixie, P., and L. Esibov, \"A DNS RR for specifying the location of services (DNS SRV)\", RFC 2782, DOI 10.17487/RFC2782, February 2000, <http://www.rfc-editor.org/info/rfc2782>.",
      "ja": "[RFC2782] Gulbrandsenの、A.、いるVixie、P.、およびL. Esibov、 \"サービスの場所を特定するためのDNS RR（DNSのSRV）\"、RFC 2782、DOI 10.17487 / RFC2782、2000年2月、<HTTP：// www.rfc-editor.org/info/rfc2782>。"
    },
    {
      "indent": 3,
      "text": "[RFC4033] Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, \"DNS Security Introduction and Requirements\", RFC 4033, DOI 10.17487/RFC4033, March 2005, <http://www.rfc-editor.org/info/rfc4033>.",
      "ja": "[RFC4033]アレンズ、R.、Austeinと、R.、ラーソン、M.、マッシー、D.、およびS.ローズ、 \"DNSセキュリティ序論と要件\"、RFC 4033、DOI 10.17487 / RFC4033、2005年3月、<のhttp： //www.rfc-editor.org/info/rfc4033>。"
    },
    {
      "indent": 3,
      "text": "[RFC4422] Melnikov, A., Ed., and K. Zeilenga, Ed., \"Simple Authentication and Security Layer (SASL)\", RFC 4422, DOI 10.17487/RFC4422, June 2006, <http://www.rfc-editor.org/info/rfc4422>.",
      "ja": "[RFC4422]メルニコフ、A.、エド、およびK. Zeilenga、エド、 \"簡易認証セキュリティー層（SASL）\"、RFC 4422、DOI 10.17487 / RFC4422、2006年6月、<のhttp：。。//www.rfc- editor.org/info/rfc4422>。"
    },
    {
      "indent": 3,
      "text": "[RFC4949] Shirey, R., \"Internet Security Glossary, Version 2\", FYI 36, RFC 4949, DOI 10.17487/RFC4949, August 2007, <http://www.rfc-editor.org/info/rfc4949>.",
      "ja": "[RFC4949] Shirey、R.、 \"インターネットセキュリティ用語集、バージョン2\"、FYI 36、RFC 4949、DOI 10.17487 / RFC4949、2007年8月、<http://www.rfc-editor.org/info/rfc4949>。"
    },
    {
      "indent": 3,
      "text": "[RFC5280] Cooper, D., Santesson, S., Farrell, S., Boeyen, S., Housley, R., and W. Polk, \"Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile\", RFC 5280, DOI 10.17487/RFC5280, May 2008, <http://www.rfc-editor.org/info/rfc5280>.",
      "ja": "[RFC5280]クーパー、D.、Santesson、S.、ファレル、S.、Boeyen、S.、Housley氏、R.、およびW.ポーク、「インターネットX.509公開鍵暗号基盤証明書と証明書失効リスト（CRL）のプロフィール」、RFC 5280、DOI 10.17487 / RFC5280、2008年5月、<http://www.rfc-editor.org/info/rfc5280>。"
    },
    {
      "indent": 3,
      "text": "[RFC5785] Nottingham, M. and E. Hammer-Lahav, \"Defining Well-Known Uniform Resource Identifiers (URIs)\", RFC 5785, DOI 10.17487/RFC5785, April 2010, <http://www.rfc-editor.org/info/rfc5785>.",
      "ja": "[RFC5785]ノッティンガム、M.およびE.ハンマーLahav、 \"既知のUniform Resource Identifier（URI）を定義\"、RFC 5785、DOI 10.17487 / RFC5785、2010年4月<http://www.rfc-editor.org /情報/ rfc5785>。"
    },
    {
      "indent": 3,
      "text": "[RFC6120] Saint-Andre, P., \"Extensible Messaging and Presence Protocol (XMPP): Core\", RFC 6120, DOI 10.17487/RFC6120, March 2011, <http://www.rfc-editor.org/info/rfc6120>.",
      "ja": "[RFC6120]サンアンドレ、P.、 \"拡張メッセージングおよびプレゼンスプロトコル（XMPP）：コア\"、RFC 6120、DOI 10.17487 / RFC6120、2011年3月、<http://www.rfc-editor.org/info/rfc6120 >。"
    },
    {
      "indent": 3,
      "text": "[RFC6125] Saint-Andre, P. and J. Hodges, \"Representation and Verification of Domain-Based Application Service Identity within Internet Public Key Infrastructure Using X.509 (PKIX) Certificates in the Context of Transport Layer Security (TLS)\", RFC 6125, DOI 10.17487/RFC6125, March 2011, <http://www.rfc-editor.org/info/rfc6125>.",
      "ja": "[RFC6125]サンアンドレ、P.およびJ.ホッジス、「表現およびTransport Layer Security（TLS）の文脈でインターネット公開鍵インフラストラクチャの使用X.509内のドメインベースのアプリケーションサービスのアイデンティティの検証（PKIX）証明書」、 RFC 6125、DOI 10.17487 / RFC6125、2011年3月、<http://www.rfc-editor.org/info/rfc6125>。"
    },
    {
      "indent": 3,
      "text": "[RFC6698] Hoffman, P. and J. Schlyter, \"The DNS-Based Authentication of Named Entities (DANE) Transport Layer Security (TLS) Protocol: TLSA\", RFC 6698, DOI 10.17487/RFC6698, August 2012, <http://www.rfc-editor.org/info/rfc6698>.",
      "ja": "[RFC6698]ホフマン、P.およびJ. Schlyter、 \"名前付きエンティティ（DANE）トランスポート層セキュリティ（TLS）プロトコルのDNSベースの認証：TLSA\"、RFC 6698、DOI 10.17487 / RFC6698、2012年8月、<のhttp：/ /www.rfc-editor.org/info/rfc6698>。"
    },
    {
      "indent": 3,
      "text": "[RFC7218] Gudmundsson, O., \"Adding Acronyms to Simplify Conversations about DNS-Based Authentication of Named Entities (DANE)\", RFC 7218, DOI 10.17487/RFC7218, April 2014, <http://www.rfc-editor.org/info/rfc7218>.",
      "ja": "[RFC7218]グドムンソン、O.、RFC 7218 \"略語は、名前付きエンティティ（DANE）のDNSベースの認証についての会話を簡単にするために追加\"、DOI 10.17487 / RFC7218、2014年4月、<http://www.rfc-editor.org /情報/ rfc7218>。"
    },
    {
      "indent": 3,
      "text": "[RFC7673] Finch, T., Miller, M., and P. Saint-Andre, \"Using DNS-Based Authentication of Named Entities (DANE) TLSA Records with SRV Records\", RFC 7673, DOI 10.17487/RFC7673, October 2015, <http://www.rfc-editor.org/info/rfc7673>.",
      "ja": "[RFC7673]フィンチ、T.、ミラー、M.、およびP.サンアンドレ、RFC 7673 \"名前付きエンティティSRVレコードを持つ（DANE）TLSAレコードのDNSベースの認証を使用\"、DOI 10.17487 / RFC7673、2015年10月、 <http://www.rfc-editor.org/info/rfc7673>。"
    },
    {
      "indent": 3,
      "text": "[RFC7711] Miller, M. and P. Saint-Andre, \"PKIX over Secure HTTP (POSH)\", RFC 7711, DOI 10.17487/RFC7711, November 2015, <http://www.rfc-editor.org/info/rfc7711>.",
      "ja": "[RFC7711]ミラー、M.およびP.サンアンドレ、 \"セキュアHTTP上PKIX（POSH）\"、RFC 7711、DOI 10.17487 / RFC7711、2015年11月、<http://www.rfc-editor.org/info/ rfc7711>。"
    },
    {
      "indent": 3,
      "text": "[XEP-0220] Miller, J., Saint-Andre, P., and P. Hancke, \"Server Dialback\", XSF XEP 0220, August 2014, <http://xmpp.org/extensions/xep-0220.html>.",
      "ja": "[XEP-0220】ミラー、J.、サンアンドレ、P.、およびP. Hancke、 \"サーバーダイアルバック\"、XSF XEP 0220、2014年8月、<http://xmpp.org/extensions/xep-0220.html >。"
    },
    {
      "indent": 0,
      "text": "11.2. Informative References",
      "section_title": true,
      "ja": "11.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[RFC2142] Crocker, D., \"Mailbox Names for Common Services, Roles and Functions\", RFC 2142, DOI 10.17487/RFC2142, May 1997, <http://www.rfc-editor.org/info/rfc2142>.",
      "ja": "[RFC2142]クロッカー、D.、 \"Common Servicesのためのメールボックス名、役割と機能\"、RFC 2142、DOI 10.17487 / RFC2142、1997年5月、<http://www.rfc-editor.org/info/rfc2142>。"
    },
    {
      "indent": 3,
      "text": "[RFC3920] Saint-Andre, P., Ed., \"Extensible Messaging and Presence Protocol (XMPP): Core\", RFC 3920, DOI 10.17487/RFC3920, October 2004, <http://www.rfc-editor.org/info/rfc3920>.",
      "ja": "[RFC3920]サンアンドレ、P.、エド、 \"拡張メッセージングおよびプレゼンスプロトコル（XMPP）：コア\"。、RFC 3920、DOI 10.17487 / RFC3920、2004年10月、<http://www.rfc-editor.org/情報/ rfc3920>。"
    },
    {
      "indent": 3,
      "text": "[RFC4120] Neuman, C., Yu, T., Hartman, S., and K. Raeburn, \"The Kerberos Network Authentication Service (V5)\", RFC 4120, DOI 10.17487/RFC4120, July 2005, <http://www.rfc-editor.org/info/rfc4120>.",
      "ja": "[RFC4120]ノイマン、C.、ゆう、T.、ハルトマン、S.、およびK.レイバーン、 \"ケルベロスネットワーク認証サービス（V5）\"、RFC 4120、DOI 10.17487 / RFC4120、2005年7月、<HTTP：// www.rfc-editor.org/info/rfc4120>。"
    },
    {
      "indent": 3,
      "text": "[RFC6066] Eastlake 3rd, D., \"Transport Layer Security (TLS) Extensions: Extension Definitions\", RFC 6066, DOI 10.17487/RFC6066, January 2011, <http://www.rfc-editor.org/info/rfc6066>.",
      "ja": "[RFC6066]イーストレイク3日、D.、 \"トランスポート層セキュリティ（TLS）拡張機能：拡張定義\"、RFC 6066、DOI 10.17487 / RFC6066、2011年1月、<http://www.rfc-editor.org/info/rfc6066> 。"
    },
    {
      "indent": 3,
      "text": "[RFC6091] Mavrogiannopoulos, N. and D. Gillmor, \"Using OpenPGP Keys for Transport Layer Security (TLS) Authentication\", RFC 6091, DOI 10.17487/RFC6091, February 2011, <http://www.rfc-editor.org/info/rfc6091>.",
      "ja": "[RFC6091] Mavrogiannopoulos、N.およびD. Gillmor氏、RFC 6091、DOI 10.17487 / RFC6091、2011年2月、<http://www.rfc-editor.org/ \"トランスポート層セキュリティ（TLS）認証のためのOpenPGPキーの使用\"情報/ rfc6091>。"
    },
    {
      "indent": 3,
      "text": "[RFC6749] Hardt, D., Ed., \"The OAuth 2.0 Authorization Framework\", RFC 6749, DOI 10.17487/RFC6749, October 2012, <http://www.rfc-editor.org/info/rfc6749>.",
      "ja": "[RFC6749]ハルト、D.編、 \"OAuth 2.0の認証フレームワーク\"、RFC 6749、DOI 10.17487 / RFC6749、2012年10月、<http://www.rfc-editor.org/info/rfc6749>。"
    },
    {
      "indent": 3,
      "text": "[RFC7590] Saint-Andre, P. and T. Alkemade, \"Use of Transport Layer Security (TLS) in the Extensible Messaging and Presence Protocol (XMPP)\", RFC 7590, DOI 10.17487/RFC7590, June 2015, <http://www.rfc-editor.org/info/rfc7590>.",
      "ja": "[RFC7590]サンアンドレ、P.およびT. Alkemade、 \"拡張メッセージングおよびプレゼンスプロトコル（XMPP）でTransport Layer Security（TLS）の使用\"、RFC 7590、DOI 10.17487 / RFC7590、2015年6月、<のhttp：/ /www.rfc-editor.org/info/rfc7590>。"
    },
    {
      "indent": 3,
      "text": "[XEP-0045] Saint-Andre, P., \"Multi-User Chat\", XSF XEP 0045, February 2012, <http://xmpp.org/extensions/xep-0045.html>.",
      "ja": "[XEP-0045]サンアンドレ、P.、 \"マルチユーザーチャット\"、XSF XEP 0045、2012年2月、<http://xmpp.org/extensions/xep-0045.html>。"
    },
    {
      "indent": 3,
      "text": "[XEP-0288] Hancke, P. and D. Cridland, \"Bidirectional Server-to-Server Connections\", XSF XEP 0288, September 2013, <http://xmpp.org/extensions/xep-0288.html>.",
      "ja": "[XEP-0288] Hancke、P。およびD. Cridland、 \"双方向サーバー間接続\"、XSF XEP 0288、2013年9月、<http://xmpp.org/extensions/xep-0288.html>。"
    },
    {
      "indent": 3,
      "text": "[XEP-0344] Hancke, P. and D. Cridland, \"Impact of TLS and DNSSEC on Dialback\", XSF XEP 0344, March 2015, <http://xmpp.org/extensions/xep-0344.html>.",
      "ja": "[XEP-0344] Hancke、P。およびD. Cridland、 \"TLSおよびダイアルバックにDNSSECの影響\"、XSF XEP 0344、2015年3月、<http://xmpp.org/extensions/xep-0344.html>。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Richard Barnes, Stephen Farrell, and Jonas Lindberg contributed as co-authors to earlier draft versions of this document.",
      "ja": "リチャード・バーンズ、スティーブン・ファレル、およびジョナス・リンドバーグはこのドキュメントの以前のドラフトバージョンに共著者として貢献しました。"
    },
    {
      "indent": 3,
      "text": "Derek Atkins, Mahesh Jethanandani, and Dan Romascanu reviewed the document on behalf of the Security Directorate, the Operations and Management Directorate, and the General Area Review Team, respectively.",
      "ja": "デレク・アトキンス、マヘシュJethanandani、そしてダンRomascanuはそれぞれ、セキュリティ総局、運用及び管理総局、および一般的なエリアレビューチームを代表して、文書をレビューしました。"
    },
    {
      "indent": 3,
      "text": "During IESG review, Stephen Farrell and Barry Leiba provided helpful input that led to improvements in the specification.",
      "ja": "IESGレビューの間、ステファン・ファレルとバリー・レイバは、仕様の改善につながっ役立つ入力を提供します。"
    },
    {
      "indent": 3,
      "text": "Thanks to Dave Cridland as document shepherd, Joe Hildebrand as working group chair, and Ben Campbell as area director.",
      "ja": "エリアディレクターとしてワーキンググループの議長として、文書の羊飼いとしてデイブCridland、ジョー・ヒルデブラント、およびベン・キャンベルに感謝します。"
    },
    {
      "indent": 3,
      "text": "Peter Saint-Andre wishes to acknowledge Cisco Systems, Inc., for employing him during his work on earlier draft versions of this document.",
      "ja": "ピーターサンアンドレはこのドキュメントの以前のドラフトバージョンの彼の仕事中に彼を採用するため、シスコシステムズ、株式会社を確認したいです。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Peter Saint-Andre &yet",
      "ja": "まだピーターサンアンドレ＆"
    },
    {
      "indent": 3,
      "text": "Email: peter@andyet.com URI: https://andyet.com/",
      "ja": "メール：peter@andyet.com URI：https://andyet.com/"
    },
    {
      "indent": 3,
      "text": "Matthew Miller Cisco Systems, Inc. 1899 Wynkoop Street, Suite 600 Denver, CO 80202 United States",
      "ja": "マシュー・ミラーシスコシステムズ株式会社1899 Wynkoopストリート、スイート600デンバー、CO 80202米国"
    },
    {
      "indent": 3,
      "text": "Email: mamille2@cisco.com",
      "ja": "メール：mamille2@cisco.com"
    },
    {
      "indent": 3,
      "text": "Philipp Hancke &yet",
      "ja": "まだフィリップHancke＆"
    },
    {
      "indent": 3,
      "text": "Email: fippo@andyet.com URI: https://andyet.com/",
      "ja": "メール：fippo@andyet.com URI：https://andyet.com/"
    }
  ]
}