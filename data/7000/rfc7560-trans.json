{
  "title": {
    "text": "RFC 7560 - Problem Statement and Requirements for Increased Accuracy in Explicit Congestion Notification (ECN) Feedback",
    "ja": "RFC 7560 - 問題文と明示的輻輳通知（ECN）フィードバックにおける精度を高めるための要件"
  },
  "number": 7560,
  "created_at": "2019-10-30 11:35:20.047400+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                M. Kuehlewind, Ed.\nRequest for Comments: 7560                                    ETH Zurich\nCategory: Informational                                 R. Scheffenegger\nISSN: 2070-1721                                             NetApp, Inc.\n                                                              B. Briscoe\n                                                                      BT\n                                                             August 2015",
      "raw": true
    },
    {
      "indent": 7,
      "text": "Problem Statement and Requirements for Increased Accuracy\n    in Explicit Congestion Notification (ECN) Feedback",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "Explicit Congestion Notification (ECN) is a mechanism where network nodes can mark IP packets, instead of dropping them, to indicate congestion to the endpoints. An ECN-capable receiver will feed this information back to the sender. ECN is specified for TCP in such a way that it can only feed back one congestion signal per Round-Trip Time (RTT). In contrast, ECN for other transport protocols, such as RTP/UDP and SCTP, is specified with more accurate ECN feedback. Recent new TCP mechanisms (like Congestion Exposure (ConEx) or Data Center TCP (DCTCP)) need more accurate ECN feedback in the case where more than one marking is received in one RTT. This document specifies requirements for an update to the TCP protocol to provide more accurate ECN feedback.",
      "ja": "明示的輻輳通知（ECN）は、ネットワークノードがエンドポイントへの輻輳を示すために、代わりにそれらを滴下する、IPパケットをマークすることができる機構です。 ECN対応の受信機は、送信者にこの情報を送ります。 ECNは、それが唯一のラウンドトリップ時間（RTT）ごとに1つの輻輳信号をフィードバックできるようにTCPのために指定されています。対照的に、ECNは、RTP / UDPおよびSCTPなどの他のトランスポートプロトコルのために、より正確なECNフィードバックと指定されています。最近の新しい（輻輳暴露のような（コーネックス）またはデータセンターTCP（DCTCP））TCPメカニズムマーキングつ以上が1 RTTで受信した場合には、より正確なECNのフィードバックを必要としています。この文書では、より正確なECNフィードバックを提供するために、TCPプロトコルに更新するための要件を指定します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "ja": "このドキュメントはインターネット標準化過程仕様ではありません。それは、情報提供の目的のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are a candidate for any level of Internet Standard; see Section 2 of RFC 5741.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。 IESGによって承認されていないすべての文書がインターネットStandardのどんなレベルの候補です。 RFC 5741のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7560.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7560で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2015 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2015 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3\n  1.1.  Terminology . . . . . . . . . . . . . . . . . . . . . . .   4\n2.  Recap of Classic ECN and ECN Nonce in IP/TCP  . . . . . . . .   5\n3.  Use Cases . . . . . . . . . . . . . . . . . . . . . . . . . .   6\n4.  Requirements  . . . . . . . . . . . . . . . . . . . . . . . .   8\n5.  Design Approaches . . . . . . . . . . . . . . . . . . . . . .  11\n  5.1.  Redefinition of ECN/NS Header Bits  . . . . . . . . . . .  11\n  5.2.  Using Other Header Bits . . . . . . . . . . . . . . . . .  13\n  5.3.  Using a TCP Option  . . . . . . . . . . . . . . . . . . .  13\n6.  Security Considerations . . . . . . . . . . . . . . . . . . .  14\n7.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  14\n  7.1.  Normative References  . . . . . . . . . . . . . . . . . .  14\n  7.2.  Informative References  . . . . . . . . . . . . . . . . .  14\nAppendix A.  Ambiguity of the More Accurate ECN Feedback in DCTCP  16\nAcknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  17\nAuthors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  17",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "Explicit Congestion Notification (ECN) [RFC3168] is a mechanism where network nodes can mark IP packets instead of dropping them to indicate congestion to the endpoints. An ECN-capable receiver will feed this information back to the sender. ECN is specified for TCP in such a way that only one feedback signal can be transmitted per Round-Trip Time (RTT). This is sufficient for preexisting TCP congestion control mechanisms that perform only one reduction in sending rate per RTT, independent of the number of ECN congestion marks. But recently proposed or deployed mechanisms like Congestion Exposure (ConEx) [RFC6789] or Data Center TCP (DCTCP) [DCTCP] need more accurate ECN feedback than 'classic ECN' [RFC3168] to work correctly in the case where more than one marking is received in any one RTT.",
      "ja": "明示的輻輳通知（ECN）[RFC3168]は、ネットワークノードがエンドポイントへの輻輳を示すために、それらを落とすのではなく、IPパケットをマークすることができる機構です。 ECN対応の受信機は、送信者にこの情報を送ります。 ECNは、ただ1つのフィードバック信号は、ラウンドトリップ時間（RTT）ごとに送信することができるように、TCPのために指定されています。これは、ECNの輻輳マークの数の独立したRTTあたりの料金を、送信に一つだけ削減を実行するTCPの輻輳制御機構を既存のには十分です。しかし、最近、マーキングつ以上である場合には正しく動作する「古典的なECN」[RFC3168]よりも正確なECNのフィードバックを必要とする[DCTCP] [RFC6789]やデータセンターTCP（DCTCP）を提案したり輻輳露出（コーネックス）のような仕組みを導入いずれかのRTTで受信。"
    },
    {
      "indent": 3,
      "text": "For an in-depth discussion of the application benefits of using ECN (including with sufficiently granular feedback), see [ECN-BENEFITS].",
      "ja": "ECN（十分に粒状フィードバックを含む）を使用するアプリケーションの利点の詳細な議論については、[ECN-利点を参照してください。"
    },
    {
      "indent": 3,
      "text": "ECN is also defined for transport protocols beside TCP. ECN feedback as defined for RTP/UDP [RFC6679] provides a very detailed level of information, delivering individual counters for all four ECN codepoints as well as lost and duplicate segments, but at the cost of high signalling overhead. ECN feedback for SCTP has been proposed in [SCTP-ECN]. This delivers a counter for the number of ECN-capable packets that were marked due to congestion (since the last sender-side window reduction), but it comes at the cost of increased overhead.",
      "ja": "ECNはまた、TCPの横のトランスポートプロトコルのために定義されています。 RTP / UDP [RFC6679]について定義されたとおりECNフィードバックはすべての4つのECNコードポイントのための個々のカウンタを送達ならびに失われたと重複セグメントが、高いシグナリングオーバーヘッドを犠牲にして、情報の非常に詳細なレベルを提供します。 SCTP用ECNフィードバックは[SCTP-ECN]で提案されています。これは、輻輳（最後の送信側からウィンドウの削減）にマークされたECN対応のパケット数のカウンタを提供しますが、それは増加したオーバーヘッドのコストがかかります。"
    },
    {
      "indent": 3,
      "text": "Today, implementations of DCTCP already exist that alter TCP's ECN feedback protocol in proprietary ways (DCTCP was released in Microsoft Windows 8, and implementations exist for Linux and FreeBSD). However, the changes DCTCP makes to TCP omit capability negotiation, relying instead on uniform configuration across all hosts and network devices with ECN capability. A primary motivation for this document is to intervene before each proprietary implementation invents its own non-interoperable handshake, which could lead to _de facto_ consumption of the few flags or codepoints that remain available for standardizing capability negotiation.",
      "ja": "今日、DCTCPの実装は、すでにそれは、独自の方法でTCPのECNフィードバックプロトコル（DCTCPは、Microsoft Windows 8にリリースされた、および実装は、LinuxとFreeBSDのために存在する）を変える存在します。しかし、DCTCPはTCPに行う変更は、ECN機能を持つすべてのホストおよびネットワークデバイス全体で均一な構成に代わりに頼って、機能ネゴシエーションを省略します。この文書の主な動機は、それぞれ独自の実装が機能ネゴシエーションを標準化するために利用可能なままにいくつかのフラグやコードポイントのfacto_消費を_deにつながる可能性があり、独自の非相互運用可能ハンドシェイクを、発明する前に介入することです。"
    },
    {
      "indent": 3,
      "text": "This document lists requirements for a robust and interoperable TCP/ ECN feedback protocol that is more accurate than classic ECN [RFC3168] and that all implementations of new TCP extensions, like ConEx and/or DCTCP, can use. While a new feedback scheme should still deliver as much information as classic ECN, this document also clarifies what has to be taken into consideration in addition. Thus, the listed requirements should be addressed in the specification of a more accurate ECN feedback scheme. A few solutions have already been proposed. Section 5 demonstrates how to use the requirements to compare them, by briefly sketching their high-level design choices and discussing the benefits and drawbacks of each.",
      "ja": "この文書では、古典的なECN [RFC3168]よりも正確で堅牢かつ相互運用可能TCP / ECNフィードバックプロトコルのための、新たなTCP拡張のすべての実装は、コーネックスおよび/またはDCTCPのように、使うことができる要件を示しています。新しいフィードバック方式は、まだ古典的なECNな限り多くの情報を提供する必要がありますが、この文書はまた、ほかに考慮しなければならないものを明確にしています。したがって、記載された要件は、より正確なECNフィードバック方式の仕様に対処しなければなりません。いくつかの解決策が既に提案されています。第5節では、簡単に自分のハイレベル設計の選択肢をスケッチし、それぞれの利点と欠点を議論することで、それらを比較するための要件を使用する方法を示します。"
    },
    {
      "indent": 3,
      "text": "The scope of these requirements is not limited to any specific environment and is intended for general deployment over public and private IP networks. Candidate solutions should try to adhere to all these requirements, but, where this is not possible, they should justify the deviation. The ordering of the requirements listed in this document is not to be taken as an order of importance, because each requirement might have different weight in different deployment scenarios.",
      "ja": "これらの要件の範囲は、任意の特定の環境に限定されるものではなく、パブリックおよびプライベートIPネットワーク上での一般的な展開を目的としています。彼らは偏差を正当化する必要があり、候補ソリューションは、これらすべての要件を遵守してみてください、しかし、これは不可能です。各要件が異なる展開シナリオに異なる重みを持っている可能性があるため、このドキュメントに記載されている要件の順序は、重要度の順と解釈されるべきではありません。"
    },
    {
      "indent": 3,
      "text": "These requirements are only concerned with the type and quality of the ECN feedback signal. The requirements do not stipulate how a TCP sender might react to the improved ECN signal. The requirements also do not imply that any modifications to TCP senders or receivers are obligatory.",
      "ja": "これらの要件は、ECNフィードバック信号の種類と品質を持つ唯一の懸念しています。要件は、TCPの送信側が改善ECN信号に反応する方法を規定していません。要件もTCP送信者や受信機に何らかの変更が義務であることを意味するものではありません。"
    },
    {
      "indent": 0,
      "text": "1.1. Terminology",
      "section_title": true,
      "ja": "1.1. 用語"
    },
    {
      "indent": 3,
      "text": "We use the following terminology from [RFC3168] and [RFC3540]:",
      "ja": "私たちは、[RFC3168]と[RFC3540]から以下の用語を使用します。"
    },
    {
      "indent": 3,
      "text": "The ECN field in the IP header:",
      "ja": "IPヘッダーのECNフィールド："
    },
    {
      "indent": 6,
      "text": "Not-ECT: the not ECN-Capable Transport codepoint,",
      "ja": "ない-ECT：ECNに対応していないトランスポートコードポイント、"
    },
    {
      "indent": 6,
      "text": "CE: the Congestion Experienced codepoint,",
      "ja": "CE：輻輳に遭遇したコードポイント、"
    },
    {
      "indent": 6,
      "text": "ECT(0): the first ECN-Capable Transport codepoint, and",
      "ja": "ECT（0）：最初のECN-できるTransportコードポイント、および"
    },
    {
      "indent": 6,
      "text": "ECT(1): the second ECN-Capable Transport codepoint.",
      "ja": "ECT（1）：第二ECN-できるTransportコードポイント。"
    },
    {
      "indent": 3,
      "text": "The ECN flags in the TCP header:",
      "ja": "TCPヘッダ内のECNフラグ："
    },
    {
      "indent": 6,
      "text": "CWR: the Congestion Window Reduced flag,",
      "ja": "CWR：輻輳ウィンドウの減少フラグ、"
    },
    {
      "indent": 6,
      "text": "ECE: the ECN-Echo flag, and",
      "ja": "ECE：ECN-エコーフラグ、および"
    },
    {
      "indent": 6,
      "text": "NS: ECN Nonce Sum.",
      "ja": "NS：ECNナンス合計。"
    },
    {
      "indent": 3,
      "text": "In this document, the ECN feedback scheme as specified in [RFC3168] is called 'classic ECN' and any new proposal is called a 'more accurate ECN feedback' scheme. A 'congestion mark' is defined as an IP packet where the CE codepoint is set. A 'congestion episode' refers to one or more congestion marks that belong to the same overload situation in the network (usually during one RTT). A TCP segment with the acknowledgement flag set is simply called an ACK.",
      "ja": "この文書では、[RFC3168]で指定されたECNのフィードバック方式を「古典的なECN」と呼ばれ、任意の新しい提案は、「より正確なECNフィードバック」スキームと呼ばれています。 「渋滞マークは」CEコードポイントが設定されたIPパケットとして定義されます。 「混雑エピソードは」（通常は1 RTTの間に）ネットワーク内の同じ過負荷状態に属している1つ以上の渋滞マークを指します。受信確認フラグが設定されたTCPセグメントが単にACKと呼ばれています。"
    },
    {
      "indent": 0,
      "text": "2. Recap of Classic ECN and ECN Nonce in IP/TCP",
      "section_title": true,
      "ja": "IP / TCPでのクラシックECNと電子証券取引ネットワークのNonceの2要約"
    },
    {
      "indent": 3,
      "text": "ECN requires two bits in the IP header. The ECN capability of a packet is indicated when either one of the two bits is set. A network node can set both bits simultaneously when it experiences congestion. This leads to the four codepoints (Not-ECT, ECT(0), ECT(1), and CE) as listed above.",
      "ja": "ECNは、IPヘッダ内の2ビットを必要とします。 2ビットのいずれかが設定されている場合、パケットのECN能力が示されています。それは、輻輳を経験する場合、ネットワークノードは、同時に両方のビットを設定することができます。上記のように、これは4つのコードポイント（NOT-ECT、ECT（0）、ECT（1）、およびCE）につながります。"
    },
    {
      "indent": 3,
      "text": "In the TCP header, the first two bits in byte 14 are defined as ECN feedback for each half-connection. A TCP receiver signals the reception of a congestion mark using the ECN-Echo (ECE) flag in the TCP header. For reliability, the receiver continues to set the ECE flag on every ACK. To enable the TCP receiver to determine when to stop setting the ECE flag, the sender sets the CWR flag upon reception of an ECE feedback signal. This always leads to a full RTT of ACKs with ECE set. Thus, the receiver cannot signal back any additional CE markings arriving within the same RTT.",
      "ja": "TCPヘッダに、バイト14の最初の2ビットは、各半接続用ECNフィードバックとして定義されます。 TCP受信機は、TCPヘッダにECN-エコー（ECE）フラグを使用して、輻輳マークの受信を知らせます。信頼性のために、受信機は、すべてのACKにECEフラグを設定し続けます。 ECEフラグを設定する停止する時を決定するためにTCP受信を可能にするために、送信者はECEフィードバック信号を受信するとCWRフラグをセットします。これは、常にECEセットでACKのフルRTTにつながります。したがって、受信機は、同じRTT内に到着する任意の追加のCEマークをバック信号ことができません。"
    },
    {
      "indent": 3,
      "text": "The ECN Nonce [RFC3540] is an experimental addition to ECN that the TCP sender can use to protect itself against accidental or malicious concealment of CE-marked or dropped packets. This addition defines the last bit of byte 13 in the TCP header as the Nonce Sum (NS) flag. The receiver maintains a nonce sum that counts the occurrence of ECT(1) packets and signals the least significant bit of this sum on the NS flag. There are no known deployments of a TCP stack that makes use of the ECN Nonce extension.",
      "ja": "ECNナンス[RFC3540]はTCPの送信者はCEマーク付きまたはパケットのドロップの偶発的または悪質な隠蔽に対して自分自身を保護するために使用できることをECNに実験的な追加です。この添加は、ノンス合計（NS）フラグとしてTCPヘッダーのバイト13の最後のビットを定義します。受信機は、ECT（1）パケットの発生をカウントし、NSフラグにこの合計の最下位ビットを信号ノンス和を維持します。 ECNナンス拡張子を使用するTCPスタックのない既知の展開はありません。"
    },
    {
      "indent": 5,
      "text": "  0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15\n+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n|               |           | N | C | E | U | A | P | R | S | F |\n| Header Length | Reserved  | S | W | C | R | C | S | S | Y | I |\n|               |           |   | R | E | G | K | H | T | N | N |\n+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Figure 1: The (Post-ECN Nonce) Definition of the TCP Header Flags",
      "ja": "図1：TCPヘッダのフラグの（ポストECNナンス）の定義"
    },
    {
      "indent": 3,
      "text": "An alternative for a sender to assure feedback integrity has been proposed where the sender itself occasionally inserts a CE mark or reorders packets, and checks that the receiver feeds these back faithfully [TEST-RCV]. This alternative consumes no header bits or codepoints, and it releases the ECT(1) codepoint in the IP header and the NS flag in the TCP header for other uses.",
      "ja": "送信者自身が時折CEマークを挿入するか、パケットを並べ替え、そして受信機は[TEST-RCV]忠実これらをフィードバックすることをチェックする場合、フィードバックの完全性を保証するために、送信者のための代替が提案されています。この代替的には、ヘッダビットまたはコードポイントを消費しない、それは他の用途のためのTCPヘッダにIPヘッダーのECT（1）コードポイントとNSフラグを解除します。"
    },
    {
      "indent": 0,
      "text": "3. Use Cases",
      "section_title": true,
      "ja": "3.ユースケース"
    },
    {
      "indent": 3,
      "text": "The following two examples serve to show where existing mechanisms would already benefit from more accurate ECN feedback information. However, as it is hard to predict the future, once a more accurate ECN feedback mechanism that adheres to the requirements stated in this document is widely deployed, it's very likely that additional uses will be found. The examples listed below are in no particular order.",
      "ja": "次の2つの例では、既存のメカニズムはすでに、より正確なECNフィードバック情報の恩恵を受けるだろう場所を示すのに役立ちます。この文書に記載された要件に準拠して、より正確なECNのフィードバック機構が広く展開されると、それは、未来を予測することは困難であるとして、しかし、それは追加の用途が発見される可能性が非常に高いです。下記の実施例は、順不同です。"
    },
    {
      "indent": 3,
      "text": "ConEx is an experimental approach that allows a sender to relay congestion feedback provided by the receiver into the network along the forward data path. ConEx information can be used for traffic management to limit traffic proportionate to the actual congestion being caused, rather than limiting traffic based on rate or volume [RFC6789]. A ConEx sender uses selective acknowledgements (SACK) [RFC2018] for accurate feedback of loss signals, but until now TCP has offered no equivalent accurate feedback for ECN.",
      "ja": "コーネックスは、送信者がフォワードデータ経路に沿ってネットワークに受信機によって提供される輻輳フィードバックを中継することを可能にする実験的アプローチです。コーネックス情報はむしろレート又はボリューム[RFC6789]に基づいてトラフィックを制限するよりも、引き起こされる実際の混雑に比例トラフィックを制限するために、トラフィック管理のために使用することができます。コーネックス送信者は、損失信号の正確なフィードバックのための選択的肯定応答（SACK）[RFC2018]を使用し、今までTCPは、ECNのための同等の正確なフィードバックを提供していません。"
    },
    {
      "indent": 3,
      "text": "DCTCP offers very low and predictable queuing delay. DCTCP changes the reaction to congestion of a TCP sender and additionally requires switches/routers to have ECN enabled and configured with a low step threshold and no signal smoothing, so it is currently only used in private networks, e.g., internal to data centers. DCTCP was released in Microsoft Windows 8, and implementations exist for Linux and FreeBSD. To retrieve sufficient congestion information, the different DCTCP implementations use a proprietary ECN feedback protocol, but they omit capability negotiation. Moreover, the feedback protocol proposed in [DCTCP] only works if there are no losses at all, and otherwise it gets very confused (see Appendix A). Therefore, if a generic, more accurate ECN feedback scheme were available, it would solve two problems for DCTCP: i) the need for a consistent variant of DCTCP to be deployed network-wide and ii) the inability to cope with ACK loss.",
      "ja": "DCTCPは非常に低いと予測可能なキューイング遅延を提供しています。 DCTCPはTCP送信者の輻輳に対する反応を変化させ、さらに、ECNが有効と低いステップしきい値と無信号平滑で構成されているためにスイッチ/ルータを必要とするので、それは、現在、データセンターの内部に、例えば、プライベートネットワークで使用されています。 DCTCPは、Microsoft Windows 8にリリース、および実装は、LinuxとFreeBSDのために存在しました。十分な渋滞情報を取得するには、異なるDCTCP実装は独自のECNフィードバックプロトコルを使用しますが、彼らは機能ネゴシエーションを省略します。また、フィードバックプロトコル[DCTCP]で提案されている全く損失がない場合にのみ動作し、それ以外の場合は（付録A参照）は非常に混乱します。 I）DCTCPの一貫性の変種に対するニーズが展開されるネットワーク全体とACKの損失に対処するⅱ）できないこと：一般的な、より正確なECNのフィードバック方式が利用可能であればそのため、それはDCTCPのための2つの問題を解決するだろう。"
    },
    {
      "indent": 3,
      "text": "Classic ECN-TCP would not benefit from more accurate ECN feedback, but it would not suffer either. The same signal that is currently conveyed with ECN following the specification given in [RFC3168] would be available.",
      "ja": "クラシックECN-TCPは、より正確なECNフィードバックから利益を得ていないだろうが、それはどちらか受けないでしょう。現在[RFC3168]で与えられた仕様以下ECNで搬送される同じ信号が利用可能です。"
    },
    {
      "indent": 3,
      "text": "The following scenarios should briefly show where accurate ECN feedback is needed or adds value:",
      "ja": "次のシナリオは、簡単に正確なECNのフィードバックが必要とされている場所を示すか、値を追加する必要があります。"
    },
    {
      "indent": 3,
      "text": "A sender with standardized TCP congestion control that supports ConEx: In this case, the ConEx mechanism uses the extra information per RTT to re-echo the precise congestion information, but the congestion control algorithm still ignores multiple marks per RTT [RFC5681].",
      "ja": "この場合、コーネックスメカニズムは再エコーするために正確な渋滞情報RTTごとに追加の情報を使用しますが、輻輳制御アルゴリズムは、まだRTT [RFC5681]ごとに複数のマークを無視します：コーネックスをサポートして標準化されたTCPの輻輳制御と送信者。"
    },
    {
      "indent": 3,
      "text": "A sender using DCTCP congestion control without ConEx: The congestion control algorithm uses the extra info per RTT to perform its decrease depending on the number of congestion marks.",
      "ja": "コーネックスなしDCTCP輻輳制御を使用して送信者：輻輳制御アルゴリズムは、輻輳マークの数に応じて、その減少を実行するためにRTTごとに余分な情報を使用しています。"
    },
    {
      "indent": 3,
      "text": "A sender using DCTCP congestion control and supporting ConEx: Both the congestion control algorithm and ConEx use the more accurate ECN feedback mechanism.",
      "ja": "センダDCTCP輻輳制御を使用し、コーネックスをサポート：輻輳制御アルゴリズムとコーネックスの両方は、より正確なECNフィードバック機構を使用します。"
    },
    {
      "indent": 3,
      "text": "As-yet-unspecified sender mechanisms: The above are two examples of more general interest in sender mechanisms that respond to the extent of congestion feedback, not just its existence. It will greatly simplify incremental deployment if the sender can unilaterally deploy new behaviours and rely on the presence of generic receivers that have already implemented more accurate feedback.",
      "ja": "同様に、まだ指定されていない送信者のメカニズム：上記は、輻輳フィードバックの範囲だけではなく、その存在に反応し、送信者のメカニズムでは、より一般的な関心の2つの例です。送信者が一方的に新しい行動を展開し、すでに、より正確なフィードバックを実施している一般的な受信機の存在に依存していることができればそれは非常に増分の展開を簡素化します。"
    },
    {
      "indent": 3,
      "text": "A TCP sender using congestion control as specified in RFC 5681 without ConEx: No accurate feedback is necessary here. The congestion control algorithm still reacts to only one signal per RTT. But, it is best to feed back all the information the receiver gets, whether or not the sender uses it -- at least as long as overhead is low or zero.",
      "ja": "コーネックスなしRFC 5681で指定された輻輳制御を使用してTCP送信者：いいえ、正確なフィードバックは必要です。輻輳制御アルゴリズムは、まだRTTごとに1つだけの信号に反応します。少なくとも限り、オーバーヘッドが低いかゼロであるとして - しかし、それは送信者がそれを使用するかどうかを、受信機が取得するすべての情報をフィードバックするのが最善です。"
    },
    {
      "indent": 3,
      "text": "Using CE for checking integrity: If a more accurate ECN feedback scheme feeds all occurrences of CE marks back, a sender could perform integrity checking by occasionally injecting CE marks itself. Specifically, a sender can send packets that it randomly marks with CE (at low frequency), then check if feedback is received for these packets. The congestion notification feedback for these self-injected markings would not require a congestion control reaction [TEST-RCV].",
      "ja": "整合性をチェックするためにCEを使用：より正確なECNのフィードバック方式は、バックCEマークのすべての出現を供給した場合、送信者は時折CE自体をマーク注入することにより、整合性チェックを行うことができます。具体的には、送信側はフィードバックがこれらのパケットのために受信されたかどうかを確認し、その後、それはランダムに（低い周波数で）CEとマークパケットを送信することができます。これらの自己注射マーキング用輻輳通知フィードバックは、輻輳制御反応[TEST-RCV]を必要としません。"
    },
    {
      "indent": 0,
      "text": "4. Requirements",
      "section_title": true,
      "ja": "4.要件"
    },
    {
      "indent": 3,
      "text": "The requirements of the accurate ECN feedback protocol are to have fairly accurate (not necessarily perfect), timely, and protected signalling. This leads to the following requirements, which should be discussed for any proposed more accurate ECN feedback scheme:",
      "ja": "正確なECNフィードバックプロトコルの要件は、（必ずしも完璧ではない）かなり正確、タイムリー、かつ保護されたシグナリングを持っています。これは、任意の提案より正確なECNのフィードバック方式のために議論されるべき次の要件につながります："
    },
    {
      "indent": 3,
      "text": "Resilience The ECN feedback signal is carried within the ACK. Pure TCP ACKs can get lost without recovery (not just due to congestion but also due to deliberate ACK thinning). Moreover, delayed ACKs are commonly used with TCP. Typically, an ACK is triggered after two data segments (or more, e.g., due to receive segment coalescing, ACK compression, ACK congestion control [RFC5690], or other phenomena; see [RFC3449]). In a high-congestion situation where most of the packets are marked with CE, an accurate feedback mechanism should still be able to signal sufficient congestion information. Thus, the accurate ECN feedback extension has to take delayed ACKs and ACK loss into account. Also, a more accurate feedback protocol should still provide more accurate feedback than classic ECN when delayed ACKs cover more than two segments, or when a thin stream disables Nagle's algorithm [RFC896]. Finally, the feedback mechanism should not be impacted by reordering of ACKs, even when the ACKed sequence number does not increase.",
      "ja": "弾性はECNフィードバック信号は、ACK内に担持されています。純粋なTCPのACKは（輻輳によるも、故意ACK間伐にだけではなく）回復せずに迷子になることができます。また、遅延ACKは、一般的にTCPで使用されています。典型的には、ACKが（例えば、以上のセグメント合体、ACK圧縮、ACK輻輳制御[RFC5690]、又は他の現象を受信することにより、[RFC3449]を参照）は、2つのデータ・セグメントの後にトリガされます。パケットのほとんどがCEでマークされた高混雑状況では、正確なフィードバック機構はまだ十分な渋滞情報を知らせることができるはずです。したがって、正確なECNフィードバック拡張を考慮に遅延ACKとACK損失を取る必要があります。遅延されたACKが二つ以上のセグメントをカバーする場合、又は薄いストリームは[RFC896] Nagleアルゴリズムを無効にした場合にも、より正確なフィードバックプロトコルは、依然として古典ECNより正確なフィードバックを提供すべきです。最後に、フィードバック機構は、ACKされたシーケンス番号が増加しない場合でも、ACKの並べ替えの影響を受けてはいけません。"
    },
    {
      "indent": 3,
      "text": "Timeliness A CE mark can be induced by the sending host, or more commonly a network node on the transmission path, and is then echoed by the receiver in the TCP ACK. Thus, when this information arrives at the sender, it is naturally already about one RTT old. With a sufficient ACK rate, a further delay of a small number of packets can be tolerated. However, this information will become stale with large delays, given the dynamic nature of networks. TCP congestion control (which itself partly introduces these dynamics) operates on a time scale of one RTT. Thus, to be timely, congestion feedback information should be delivered within about one RTT.",
      "ja": "CEマークは、伝送路に送信ホスト、またはより一般的にネットワークノードによって誘導することができ、その後、TCP ACKに受信機によってエコーされ適時。この情報は、送信者に到達したときにこのように、それは当然、既に約RTT古いです。十分ACKレートで、パケットの少数のさらなる遅延を許容することができます。しかし、この情報はネットワークの動的な性質を考えると、大きな遅延と古くなります。 （それ自体が部分的にこれらのダイナミクスを紹介）TCPの輻輳制御は、1 RTTの時間スケールで動作します。このように、タイムリーであることを、輻輳フィードバック情報は、およそ1 RTT内で配信されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Integrity The integrity of the feedback in a more accurate ECN feedback scheme should be assured, at least as well as the ECN Nonce. Alternatively, it should at least be possible to give strong incentives for the receiver and network nodes to cooperate honestly.",
      "ja": "整合性のより正確なECNのフィードバック方式におけるフィードバックの整合性は、電子証券取引ネットワークのNonce、少なくともだけでなく、保証されなければなりません。あるいは、少なくとも受信機とネットワークノードが正直に協力するための強力なインセンティブを与えることが可能であるべきです。"
    },
    {
      "indent": 6,
      "text": "Given there are known problems with ECN Nonce deployment, this document only requires that the integrity of the more accurate ECN feedback can be assured; it does not require that the ECN Nonce mechanism is employed to achieve this. Indeed, if integrity could be provided in another manner, a more accurate ECN feedback protocol might repurpose the nonce sum (NS) flag in the TCP header.",
      "ja": "ECNナンスの展開に関する既知の問題がある考えると、このドキュメントでは、より正確なECNフィードバックの完全性を保証することができることが必要です。それは、ECNナンス・メカニズムがこれを達成するために使用されている必要はありません。整合性は、別の方法で提供することができれば、実際に、より正確なECNフィードバックプロトコルは、TCPヘッダ内のノンス和（NS）フラグを再利用可能性があります。"
    },
    {
      "indent": 6,
      "text": "If the more accurate ECN feedback scheme provides sufficient information, the integrity check could be performed by, e.g., deterministically setting the CE in the sender and monitoring the respective feedback (similar to ECT(1) and the ECN Nonce sum). Whether a sender should enforce when it detects wrong feedback information, and what kind of enforcement it should apply, are policy issues that need not be specified as part of the more accurate ECN feedback signal scheme itself, but rather when specifying an update to core TCP mechanisms like congestion control that make use of the more accurate ECN signal.",
      "ja": "より正確なECNフィードバック方式は、十分な情報を提供する場合、整合性チェックは、例えば、決定論送信者にCEを設定し（ECTと同様（1）及びECNノンス和）それぞれのフィードバックを監視することによって実行することができます。それは間違ったフィードバック情報を検出したときに送信者が実施すべきかどうか、そしてそれが適用されるべき執行の種類を、より正確なECNフィードバック信号スキーム自体の一部として指定されたのではなく、コアTCPへの更新を指定するときにする必要はない政策課題ですより正確なECN信号を利用する輻輳制御などのメカニズム。"
    },
    {
      "indent": 3,
      "text": "Accuracy Classic ECN feeds back one congestion notification per RTT; this is sufficient for classic TCP congestion control, which reduces the sending rate at most once per RTT. Thus, the more accurate ECN feedback scheme should ensure that, if a congestion episode occurs, at least one congestion notification is echoed and received per RTT as classic ECN would do. Of course, the goal of a more accurate ECN extension is to reconstruct the number of CE markings more accurately. In the best case, the new scheme should even allow reconstruction of the exact number of payload bytes that a CE-marked packet was carrying. However, it is accepted that it may be too complex for a sender to get the exact number of congestion markings or marked bytes in all situations. Ideally, the feedback scheme should preserve the order in which any (of the four) ECN signals were received. And, ideally, it would even be possible for the sender to determine which of the packets covered by one delayed ACK were congestion marked, e.g., if the flow consists of packets of different sizes, or to allow for future protocols where the order of the markings may be important.",
      "ja": "精度クラシックECNはRTTごとに輻輳通知をフィードバックします。これはRTTごとに最大で1回の送信速度を減少させる古典的なTCPの輻輳制御、のために十分です。このため、より正確なECNのフィードバック方式は、輻輳エピソードが発生した場合、少なくとも一つの輻輳通知は、エコーとどうなるの古典的なECNとしてRTTごとに受信された、ことを確保すべきです。もちろん、より正確なECNの拡張の目標は、より正確にCEマーキングの数を再構築することです。最良のケースでは、新しいスキームでも、ペイロードの正確な数の再構成はCEマーク付きのパケットを運んでいたことをバイト許可する必要があります。しかし、送信者がすべての状況での輻輳のマーキングやマークされた正確なバイト数を取得するために、それはあまりにも複雑であることが認められています。理想的には、フィードバック方式は、ECN信号（4本）いずれかが受信された順序を維持すべきです。送信側がフローは、異なるサイズのパケットで構成されている場合、例えば、渋滞マークされた1遅延ACKでカバーするパケットのかを決定するために、または将来のプロトコルを可能にするためと、理想的に、それも可能であろう場所の順序マーキングは重要であるかもしれません。"
    },
    {
      "indent": 6,
      "text": "In the best case, a sender that sees more accurate ECN feedback information would be able to reconstruct the occurrence of any of the four codepoints (Not-ECT, CE, ECT(0), ECT(1)). However, assuming the sender marks all data packets as ECN-capable and uses a default setting of ECT(0) (as with [RFC3168]), solely feeding back the occurrence of CE and ECT(1) might be sufficient. Because the sender can keep account of the transmitted segments with any of the three ECN codepoints, conveying any two of these back to the sender is sufficient for it to reconstruct the third as observed by the receiver. Thus, a more accurate ECN feedback scheme should at least provide information on two of these signals, e.g., CE and ECT(1).",
      "ja": "最良の場合には、より正確なECNフィードバック情報を見て、送信者は、4つのコードポイントのいずれかの発生を再構築することができるだろう（NOT-ECT、CE、ECT（0）、ECT（1））。しかし、ECN-できるように送信者マークをすべてのデータパケットを想定し、（0）（[RFC3168]のように）ECTのデフォルト設定を使用して、単にCEの発生をフィードバックし、ECTは、（1）十分であるかもしれません。送信者がこれらのいずれか2つの搬送三のECNコードポイントのいずれかで送信セグメントのアカウントを維持することができるため、送信者に受信機によって観察されるように、それは三分の一を再構成するために十分です。したがって、より正確なECNフィードバック方式は、少なくともこれらの信号の2つの例えば、CEおよびECT（1）に関する情報を提供すべきです。"
    },
    {
      "indent": 6,
      "text": "If a more accurate ECN scheme can reliably deliver feedback in most but not all circumstances, ideally the scheme should at least not introduce bias. In other words, undetected loss of some ACKs should be as likely to increase as decrease the sender's estimate of the probability of ECN marking.",
      "ja": "より正確なECN方式は確実に最もすべてではない状況でのフィードバックを提供することができれば、理想的スキームは、少なくともバイアスを導入してはなりません。言い換えれば、いくつかのACKの未検出の損失が減少としてマーキングECNの確率の送信者の評価を高めるためにそうする必要があります。"
    },
    {
      "indent": 3,
      "text": "Complexity Implementation should be as simple as possible, and only a minimum of additional state information should be needed. This will enable more accurate ECN feedback to be used as the default feedback mechanism, even if only one ECN feedback signal per RTT is needed.",
      "ja": "複雑性の実装は、できるだけ簡単であるべきであり、唯一の追加の状態情報の最小値を必要としなければなりません。これはRTTごとに1つのだけECNフィードバック信号が必要な場合でも、デフォルトのフィードバック機構として使用される、より正確なECNのフィードバックを可能にします。"
    },
    {
      "indent": 3,
      "text": "Overhead A more accurate ECN feedback signal should limit the additional network load, because ECN feedback is ultimately not critical information (in the worst case, loss will still be available as a congestion signal of last resort). As feedback information has to be provided frequently and in a timely fashion, potentially all or a large fraction of TCP acknowledgements might carry this information. Ideally, no additional segments should be exchanged compared to a TCP session as specified in RFC 3168, and the overhead in each segment should be minimized.",
      "ja": "ECNのフィードバックは、最終的に重要な情報（最悪の場合には、損失はまだ最後の混雑信号として利用できるようになります）ではないので、オーバーヘッドより正確なECNフィードバック信号は、追加のネットワーク負荷を制限する必要があります。フィードバック情報は、潜在的に、頻繁にかつタイムリーに提供する必要があるとして、すべてまたはTCPの確認応答の大部分は、この情報を運ぶかもしれません。理想的には、追加のセグメントは、RFC 3168で指定されたTCPセッションに比べて交換されるべきではない、各セグメント内のオーバーヘッドが最小化されるべきです。"
    },
    {
      "indent": 3,
      "text": "Backward and forward compatibility Given more accurate ECN feedback will involve a change to the TCP protocol, it should be negotiated between the two TCP endpoints. If either end does not support the more accurate feedback, they should both be able to fall back to classic ECN feedback.",
      "ja": "より正確なECNのフィードバックを考えると下位と上位互換性がTCPプロトコルへの変更を伴うだろう、それは2つのTCPエンドポイント間で交渉しなければなりません。どちらかの端には、より正確なフィードバックをサポートしていない場合、彼らは両方のバック古典的なECNのフィードバックに落ちることができるはずです。"
    },
    {
      "indent": 6,
      "text": "A more accurate ECN feedback extension should aim to traverse most middleboxes, including firewalls and Network Address Translators (NATs). Further, a feedback mechanism should provide a method to fall back to classic ECN signalling if the new signal is suppressed by certain middleboxes.",
      "ja": "より正確なECNフィードバック拡張子は、ファイアウォールとネットワークアドレス変換（NAT）を含むほとんどのミドルボックスを、トラバースを目指すべきです。さらに、フィードバック機構は、新たな信号が特定の中間装置によって抑制されている場合、古典的なECNシグナリングにフォールバックする方法を提供すべきです。"
    },
    {
      "indent": 6,
      "text": "In order to avoid a fork in the TCP protocol specifications, if experiments with the new ECN feedback protocol are successful, the intention is to eventually update RFC 3168 for any TCP/ECN sender, not just for ConEx or DCTCP senders. Then, future senders will be able to unilaterally deploy new behaviours that exploit the existence of more accurate ECN feedback in receivers (forward compatibility). Conversely, even if another sender only needs one ECN feedback signal per RTT, it should be able to use more accurate ECN feedback and simply ignore the excess information.",
      "ja": "新しいECNフィードバックプロトコルを用いた実験が成功した場合、TCPプロトコル仕様のフォークを避けるために、意図は、最終的には任意のTCP / ECN送信者のためだけでなく、コーネックスやDCTCP送信者のためのRFC 3168を更新することです。その後、将来の送信者が一方的に受信機では、より正確なECNフィードバック（上位互換性）の存在を活用する新しい行動を展開することができるようになります。逆に、別の送信者が唯一RTTごとに1つのECNフィードバック信号を必要とする場合でも、より正確なECNのフィードバックを使用し、単に余分な情報を無視することができるはずです。"
    },
    {
      "indent": 3,
      "text": "Furthermore, the receiver should not make assumptions about the mechanism that was used to set the markings nor about any interpretation or reaction to the congestion signal. The receiver only needs to faithfully reflect congestion information back to the sender.",
      "ja": "さらに、受信機は、マーキングを設定するために使用されたメカニズムについても混雑信号に任意の解釈又は反応に関する仮定を行うべきではありません。受信機は忠実に送信者に渋滞情報を反映する必要があります。"
    },
    {
      "indent": 0,
      "text": "5. Design Approaches",
      "section_title": true,
      "ja": "5.設計手法"
    },
    {
      "indent": 3,
      "text": "This section introduces some possible design approaches for TCP ECN feedback. The purpose of this section is to give examples of how trade-offs might be needed between the requirements, as input to future IETF work to specify a protocol. The order is not significant, and there is no intention to endorse any particular approach.",
      "ja": "このセクションでは、TCP ECNフィードバックのためのいくつかの可能な設計アプローチを紹介します。このセクションの目的は、トレードオフは、プロトコルを指定するには、将来のIETF仕事への入力として、要件の間で必要になる可能性がある方法の例を与えることです。順序は重要ではありません、そして任意の特定のアプローチを推奨する意図はありません。"
    },
    {
      "indent": 3,
      "text": "All approaches presented below (and proposed so far) are able to provide accurate ECN feedback information as long as no ACK loss occurs and the congestion rate is reasonable. In the case of a high ACK loss rate or very high congestion (CE-marking) rate, the proposed schemes have different resilience characteristics depending on the number of bits used for the encoding. While classic ECN provides reliable (but inaccurate) feedback of a maximum of one congestion signal per RTT, the proposed schemes do not implement an explicit acknowledgement mechanism for the feedback (as, e.g., the ECE/CWR exchange of [RFC3168]).",
      "ja": "以下に（と、これまでに提案されている）すべてのアプローチは限り何のACKの損失が発生していないと混雑率が合理的であるとして、正確なECNフィードバック情報を提供することができます。高いACKロス率又は非常に高い混雑（CEマーキング）レートの場合には、提案されたスキームは、符号化に使用されるビットの数に応じて異なる弾性特性を有します。古典ECNはRTTごとに輻輳信号の最大値の信頼性（しかし不正確な）フィードバックを提供するが、提案されたスキームは、フィードバックのための明示的な肯定応答機構を実装していない（として、例えば、[RFC3168]のECE / CWR交換）。"
    },
    {
      "indent": 0,
      "text": "5.1. Redefinition of ECN/NS Header Bits",
      "section_title": true,
      "ja": "5.1.  ECN / NSヘッダービットの再定義"
    },
    {
      "indent": 3,
      "text": "Schemes in this category can additionally use the NS bit for capability negotiation during the TCP handshake exchange. Thus a more accurate ECN could be negotiated without changing the classic ECN negotiation and thus being backwards compatible.",
      "ja": "このカテゴリーのスキームは、さらにTCPハンドシェイク交換中に能力交渉のためのNSビットを使用することができます。したがって、より正確なECNは、古​​典的なECNネゴシエーションを変更するので、後方互換せずネゴシエートすることができます。"
    },
    {
      "indent": 3,
      "text": "Schemes in this category can simply redefine the ECN header flags, ECE and CWR, to encode the occurrence of a CE marking at the receiver. This approach provides very limited resilience against loss of ACK, particularly pure ACKs (no payload and therefore delivered unreliably).",
      "ja": "このカテゴリのスキームは、単に、受信機でマーキングCEの発生を符号化するために、ECNヘッダフラグ、ECEとCWRを再定義することができます。このアプローチは、ACKの損失に対して非常に限られた弾力性、特に純粋のACK（NOペイロード従って不確実送達）を提供します。"
    },
    {
      "indent": 3,
      "text": "A couple of schemes have been proposed so far:",
      "ja": "スキームのカップルは、これまでに提案されています。"
    },
    {
      "indent": 3,
      "text": "o A naive 1-bit scheme that sends one ECE for each CE received could use CWR to increase robustness against ACK loss by introducing redundant information on the next ACK, but this is still vulnerable to ACK loss.",
      "ja": "各CEのための1つのECEが次のACKに冗長情報を導入することによってACK損失に対するロバスト性を高めるためにCWRを使用し、これは、まだACK損失に対して脆弱である可能性があり、受信し送信ナイーブ1ビット方式O。"
    },
    {
      "indent": 3,
      "text": "o The scheme defined for DCTCP [DCTCP], which toggles the ECE feedback on an immediate ACK whenever the CE marking changes, and otherwise feeds back delayed ACKs with the ECE value unchanged. Appendix A demonstrates that this scheme is still ambiguous to the sender if the ACKs are pure ACKs, and if some may have been lost.",
      "ja": "CE変更をマーキングするたびに、即時ACKにECEフィードバックを切り替えDCTCP [DCTCP]に対して定義されたスキーム、O、およびそうでなければ不変ECE値と遅延ACKをフィードバックします。付録Aは、ACKが純粋のACKであれば、一部が失われている可能性がある場合、このスキームは、まだ送信者に曖昧であることを示しています。"
    },
    {
      "indent": 3,
      "text": "Alternatively, the receiver uses the three ECN/NS header flags, ECE, CWR, and NS, to represent a counter that signals the accumulated number of CE markings it has received. Resilience against loss is better than the flag-based schemes but may not suffice in the presence of extended ACK loss that otherwise would not affect the TCP sender's performance.",
      "ja": "あるいは、受信機は、受信したCEマーキングの累積数を知らせるカウンタを表すために、ECE、CWR、及びNS三のECN / NSヘッダー・フラグを使用します。損失に対する回復力はフラグベースのスキームよりも優れているが、それ以外のTCP送信者のパフォーマンスに影響を与えない拡張ACK損失の存在下では十分でないかもしれません。"
    },
    {
      "indent": 3,
      "text": "A number of coding schemes have been proposed so far in this category:",
      "ja": "符号化方式の数は、このカテゴリーにこれまでに提案されています。"
    },
    {
      "indent": 3,
      "text": "o A 3-bit counter scheme continuously feeds back the three least significant bits of a CE counter;",
      "ja": "O 3ビットカウンタ方式は、連続CEカウンタの下位3ビットをフィードバックします。"
    },
    {
      "indent": 3,
      "text": "o A scheme that defines a standardized lookup table to map the eight codepoints onto either a CE counter or an ECT(1) counter.",
      "ja": "CEカウンタ又はECT（1）カウンタのいずれかに8つのコードポイントをマッピングするために標準化されたルックアップテーブルを定義スキームO。"
    },
    {
      "indent": 3,
      "text": "These proposed schemes provide accumulated information on CE marking feedback, similar to the number of acknowledged bytes in the TCP header. Due to the limited number of bits, the ECN feedback information will wrap much more often than the acknowledgement field. Thus, feedback information could be lost due to a relatively small sequence of pure-ACK losses. Resilience could be increased by introducing redundancy, e.g., send each counter increase two or more times. Of course, any of these additional mechanisms will increase the complexity. If the congestion rate is greater than the ACK rate (multiplied by the number of congestion marks that can be signaled per ACK), the congestion information cannot correctly be fed back. Covering the worst case (where every packet is CE marked) can potentially be realized by dynamically adapting the ACK rate and redundancy. This again increases complexity and perhaps the signalling overhead as well. Schemes that do not repurpose the ECN NS bit could still support the ECN Nonce.",
      "ja": "これらの提案されたスキームは、TCPヘッダに認めバイトの数と同様のフィードバックをCEマーキングに蓄積された情報を、提供します。限られたビット数のため、ECNフィードバック情報は、確認応答フィールドよりもはるかに頻繁に折り返されます。このように、フィードバック情報が原因純粋-ACK損失の比較的小さい順に失われる可能性があります。レジリエンスは冗長性を導入することによって増加させることができ、例えば、各カウンタが2回以上増加送ります。もちろん、これらの追加のメカニズムのいずれかが複雑になります。混雑率が（ACKごとにシグナリングすることができる輻輳マークの数を乗じた）ACKレートよりも大きい場合に、渋滞情報を正確にフィードバックすることができません。 （すべてのパケットがマークCEである）最悪のケースをカバーすることは、潜在的に動的ACK率と冗長性を適応させることによって実現することができます。これは、再び、同様の複雑さおよびおそらくシグナリング・オーバーヘッドを増大させます。 ECN NSビットを再利用していないスキームは、まだECN nonceをサポートすることができました。"
    },
    {
      "indent": 0,
      "text": "5.2. Using Other Header Bits",
      "section_title": true,
      "ja": "5.2. 他のヘッダビットを使用して"
    },
    {
      "indent": 3,
      "text": "As seen in Figure 1, there are currently three unused flags in the TCP header. The proposed 3-bit counter or codepoint schemes could be extended by one or more bits to add higher resilience against ACK loss. The relative gain would be exponentially higher resilience against ACK loss, while the respective drawbacks would remain identical.",
      "ja": "図1に見られるように、TCPヘッダ三の未使用フラグが現在存在します。提案された3ビットカウンタまたはコードポイント方式はACK損失に対する高い耐性を追加するために、1つまたは複数のビットによって拡張することができます。それぞれの欠点は、同じままだろうが相対利得は、ACKの損失に対して指数関数的により高いレジリエンスであろう。"
    },
    {
      "indent": 3,
      "text": "Alternatively, a new method could standardize the use of the bits in the Urgent Pointer field (see [RFC6093]) to signal more bits of its congestion signal counter, but only whenever the Urgent Flag is not set. As this is often the case, resilience could be increased without additional header overhead.",
      "ja": "あるいは、新しい方法は、緊急ポインタフィールド内のビットの使用を標準化することができなく緊急フラグがセットされていないだけたびに、その輻輳信号カウンタのより多くのビットをシグナリングする（[RFC6093]を参照）。これは、多くの場合そうであるように、弾力性は、追加のヘッダーオーバーヘッドなしに増加させることができます。"
    },
    {
      "indent": 3,
      "text": "Any proposal to use such bits would need to check the likelihood that some middleboxes might discard or 'normalize' the currently unused flag bits or a non-zero Urgent Pointer when the Urgent Flag is cleared. If during experimentation certain bits have been proven to be usable, the assignment of any of these bits would then require an IETF standards action.",
      "ja": "そのようなビットを使用するための任意の提案は、緊急フラグがクリアされたときに、いくつかのミドルボックスは、現在未使用のフラグビットまたは非ゼロの緊急ポインタを破棄するか、「ノーマライズ」かもしれないという可能性をチェックする必要があります。実験中に特定のビットが使用可能であることが証明されている場合は、これらのビットのいずれかの割り当ては、IETF標準化行動を必要とします。"
    },
    {
      "indent": 0,
      "text": "5.3. Using a TCP Option",
      "section_title": true,
      "ja": "5.3.  TCPオプションの使用"
    },
    {
      "indent": 3,
      "text": "Alternatively, a new TCP option could be introduced, to help maintain the accuracy and integrity of ECN feedback between receiver and sender. Such an option could provide higher resilience and even more information, e.g., as much as is provided by a proposal for SCTP that counts the number of CE marked packet [SCTP-ECN] since the last CWR was observed, or by ECN for RTP/UDP [RFC6679]. The latter explicitly provides the total number of packets during a connection where the IP ECN field is set to ECT(0), ECT(1), CE, or Not-ECT, as well as the number of lost packets. However, deploying new TCP options has its own challenges. Moreover, to actually achieve high resilience, this option would need to be carried by most or all ACKs as the receiver cannot know if and when ACKs may be dropped. Thus, this approach would introduce considerable signalling overhead even though ECN feedback is not extremely critical information (in the worst case, loss will still be available to provide a strong congestion feedback signal). Nevertheless, such a TCP option could be used in addition to a more accurate ECN feedback scheme in the TCP header or in addition to classic ECN, only when needed and when space is available.",
      "ja": "また、新しいTCPオプションは、受信機と送信者の間でECNフィードバックの正確性と完全性を維持するために、導入することができます。このようなオプションが同じくらいCEの数をカウントSCTPの提案により提供されるように、例えば、より高い回復力とさらに多くの情報を、提供することができマークパケットRTPのための最後のCWRが観察されたので、[SCTP-ECN]、またはECNによって/ UDP [RFC6679]。後者は、明示的にIP ECNフィールドがECT（0）、ECT（1）、CE、またはNot-ECT、ならびに失われたパケットの数に設定されている接続中のパケットの合計数を提供します。しかし、新しいTCPオプションを導入することは、独自の課題があります。また、実際には高反発を達成するために、このオプションでは、ACKがドロップされる可能性がある場合とするとき、受信機が知ることができないとして、ほとんどまたは全てのACKによって運ばれる必要があります。したがって、このアプローチは、ECNのフィードバックは非常に重要な情報（最悪の場合には、損失がまだ強い混雑フィードバック信号を提供するために利用できるようになります）でなくても、かなりのシグナリングオーバーヘッドを導入します。それにもかかわらず、このようTCPオプションは、必要なときにだけ、TCPヘッダ内またはクラシックECNに加えて、より正確なECNのフィードバック方式に加えて使用することができ、スペースが利用可能になったとき。"
    },
    {
      "indent": 0,
      "text": "6. Security Considerations",
      "section_title": true,
      "ja": "6.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "ECN feedback information must only be used if the other information contained in a received TCP segment indicates that the congestion was genuinely part of the flow and not spoofed. That is, the normal TCP acceptance techniques have to be used to verify that the segment is part of the flow before returning any contained ECN information, and, similarly, ECN feedback is only accepted on valid ACKs.",
      "ja": "受信したTCPセグメントに含まれる他の情報は、輻輳が真にフローの一部であり、なりすましではないことを示す場合ECNフィードバック情報にのみ使用されなければなりません。すなわち、通常のTCP受付技術は、セグメントは、任意含まECN情報を戻す前に、フローの一部であり、そして、同様に、ECNフィードバックのみ有効のACKに受け入れられていることを確認するために使用されなければならない、です。"
    },
    {
      "indent": 3,
      "text": "Given ECN feedback is used as input for congestion control, the respective algorithm would not react appropriately if ECN feedback were lost and the resilience mechanism to recover it was inadequate. This resilience requirement is articulated in Section 4. However, it should be noted that ECN feedback is not the last resort against congestion collapse, because if there is insufficient response to ECN, loss will ensue, and TCP will still react appropriately to loss.",
      "ja": "ECNフィードバックが失われた場合、所与のECNフィードバックは輻輳制御のための入力として使用され、それぞれのアルゴリズムが適切に反応しないであろうと反発機構は、それが不十分であった回復します。この回復力の要件は、ECNに不十分な応答があった場合、損失が続いて起こるため、ECNフィードバックは、輻輳崩壊に対する最後の手段ではないことに留意すべきである。しかし、第4節で連接され、そしてTCPはまだ損失に適切に反応します。"
    },
    {
      "indent": 3,
      "text": "A receiver could suppress ECN feedback information leading to its connections consuming excess sender or network resources. This problem is similar to that seen with the classic ECN feedback scheme and should be addressed by integrity checking as required in Section 4.",
      "ja": "受信機は、過剰な送信者またはネットワークリソースを消費してその接続につながるECNフィードバック情報を抑制することができます。この問題は、古典的なECNフィードバック方式で見られるし、第4節で必要に応じて整合性チェックによって対処されなければならないものと同様です。"
    },
    {
      "indent": 0,
      "text": "7. References",
      "section_title": true,
      "ja": "7.参考"
    },
    {
      "indent": 0,
      "text": "7.1. Normative References",
      "section_title": true,
      "ja": "7.1. 引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC3168] Ramakrishnan, K., Floyd, S., and D. Black, \"The Addition of Explicit Congestion Notification (ECN) to IP\", RFC 3168, DOI 10.17487/RFC3168, September 2001, <http://www.rfc-editor.org/info/rfc3168>.",
      "ja": "\"IPへの明示的輻輳通知の追加（ECN）\" [RFC3168]ラマクリシュナン、K.、フロイド、S.、およびD.ブラック、RFC 3168、DOI 10.17487 / RFC3168、2001年9月、<のhttp：// WWW。 rfc-editor.org/info/rfc3168>。"
    },
    {
      "indent": 3,
      "text": "[RFC3540] Spring, N., Wetherall, D., and D. Ely, \"Robust Explicit Congestion Notification (ECN) Signaling with Nonces\", RFC 3540, DOI 10.17487/RFC3540, June 2003, <http://www.rfc-editor.org/info/rfc3540>.",
      "ja": "[RFC3540]春、N.、Wetherall、D.、およびD.イーリー、 \"堅牢な明示的輻輳通知（ECN）ナンスとシグナリング\"、RFC 3540、DOI 10.17487 / RFC3540、2003年6月、<のhttp：//www.rfc -editor.org/info/rfc3540>。"
    },
    {
      "indent": 0,
      "text": "7.2. Informative References",
      "section_title": true,
      "ja": "7.2. 参考文献"
    },
    {
      "indent": 3,
      "text": "[DCTCP] Bensley, S., Eggert, L., and D. Thaler, \"Microsoft's Datacenter TCP (DCTCP): TCP Congestion Control for Datacenters\", Work in Progress, draft-bensley-tcpm-dctcp-05, July 2015.",
      "ja": "[DCTCP] Bensley、S.、エッゲルト、L.、およびD.ターラー、 \"MicrosoftのデータセンターTCP（DCTCP）：データセンターのためのTCPの輻輳制御\" が進行中で働いて、ドラフトbensley-tcpm-dctcp-05、2015年7月。"
    },
    {
      "indent": 3,
      "text": "[ECN-BENEFITS] Fairhurst, G. and M. Welzl, \"The Benefits of using Explicit Congestion Notification (ECN)\", Work in Progress draft-ietf-aqm-ecn-benefits-06, July 2015.",
      "ja": "[ECN-利点] Fairhurst、G.およびM. Welzl、 \"明示的輻輳通知を使用する利点（ECN）\"、プログレスドラフト-IETF-AQM-ECN-メリット-06、2015年7月での作業。"
    },
    {
      "indent": 3,
      "text": "[RFC896] Nagle, J., \"Congestion Control in IP/TCP Internetworks\", RFC 896, DOI 10.17487/RFC0896, January 1984, <http://www.rfc-editor.org/info/rfc896>.",
      "ja": "[RFC896]ネーグル、J.、 \"IP / TCPインターネットワークにおける輻輳制御\"、RFC 896、DOI 10.17487 / RFC0896、1984年1月、<http://www.rfc-editor.org/info/rfc896>。"
    },
    {
      "indent": 3,
      "text": "[RFC2018] Mathis, M., Mahdavi, J., Floyd, S., and A. Romanow, \"TCP Selective Acknowledgment Options\", RFC 2018, DOI 10.17487/RFC2018, October 1996, <http://www.rfc-editor.org/info/rfc2018>.",
      "ja": "[RFC2018]マティス、M.、Mahdavi、J.、フロイド、S.、とA. Romanow、 \"TCPの選択確認応答オプション\"、RFC 2018、DOI 10.17487 / RFC2018、1996年10月、<HTTP：//www.rfc- editor.org/info/rfc2018>。"
    },
    {
      "indent": 3,
      "text": "[RFC3449] Balakrishnan, H., Padmanabhan, V., Fairhurst, G., and M. Sooriyabandara, \"TCP Performance Implications of Network Path Asymmetry\", BCP 69, RFC 3449, DOI 10.17487/RFC3449, December 2002, <http://www.rfc-editor.org/info/rfc3449>.",
      "ja": "[RFC3449]バラクリシュナン、H.、Padmanabhan、V.、Fairhurst、G.、およびM. Sooriyabandara、 \"ネットワークパス非対称のTCPパフォーマンスへの影響\"、BCP 69、RFC 3449、DOI 10.17487 / RFC3449、2002年12月、<のhttp： //www.rfc-editor.org/info/rfc3449>。"
    },
    {
      "indent": 3,
      "text": "[RFC5681] Allman, M., Paxson, V., and E. Blanton, \"TCP Congestion Control\", RFC 5681, DOI 10.17487/RFC5681, September 2009, <http://www.rfc-editor.org/info/rfc5681>.",
      "ja": "[RFC5681]オールマン、M.、パクソン、V.、およびE.ブラントン、 \"TCP輻輳制御\"、RFC 5681、DOI 10.17487 / RFC5681、2009年9月、<http://www.rfc-editor.org/info/ rfc5681>。"
    },
    {
      "indent": 3,
      "text": "[RFC5690] Floyd, S., Arcia, A., Ros, D., and J. Iyengar, \"Adding Acknowledgement Congestion Control to TCP\", RFC 5690, DOI 10.17487/RFC5690, February 2010, <http://www.rfc-editor.org/info/rfc5690>.",
      "ja": "[RFC5690]フロイド、S.、Arcia、A.、ロス、D.、およびJ.アイアンガー、 \"TCPに対する確認応答輻輳制御を追加\"、RFC 5690、DOI 10.17487 / RFC5690、2010年2月、<HTTP：// WWW。 rfc-editor.org/info/rfc5690>。"
    },
    {
      "indent": 3,
      "text": "[RFC6093] Gont, F. and A. Yourtchenko, \"On the Implementation of the TCP Urgent Mechanism\", RFC 6093, DOI 10.17487/RFC6093, January 2011, <http://www.rfc-editor.org/info/rfc6093>.",
      "ja": "[RFC6093] Gont、F.およびA. Yourtchenko、RFC 6093 \"TCP緊急機構の実現について\"、DOI 10.17487 / RFC6093、2011年1月、<http://www.rfc-editor.org/info/rfc6093 >。"
    },
    {
      "indent": 3,
      "text": "[RFC6679] Westerlund, M., Johansson, I., Perkins, C., O'Hanlon, P., and K. Carlberg, \"Explicit Congestion Notification (ECN) for RTP over UDP\", RFC 6679, DOI 10.17487/RFC6679, August 2012, <http://www.rfc-editor.org/info/rfc6679>.",
      "ja": "[RFC6679]ウェスター、M.、ヨハンソン、I.、パーキンス、C.、オハンロン、P.、およびK.カールバーグ、 \"明示的輻輳通知UDP上のRTPのための（ECN）\"、RFC 6679、DOI 10.17487 / RFC6679 、2012年8月、<http://www.rfc-editor.org/info/rfc6679>。"
    },
    {
      "indent": 3,
      "text": "[RFC6789] Briscoe, B., Ed., Woundy, R., Ed., and A. Cooper, Ed., \"Congestion Exposure (ConEx) Concepts and Use Cases\", RFC 6789, DOI 10.17487/RFC6789, December 2012, <http://www.rfc-editor.org/info/rfc6789>.",
      "ja": "[RFC6789]ブリスコー、B.、エド。、Woundy、R.、エド。、およびA.クーパー、エド。、 \"輻輳露出（コーネックス）の概念とユースケース\"、RFC 6789、DOI 10.17487 / RFC6789、2012年12月、 <http://www.rfc-editor.org/info/rfc6789>。"
    },
    {
      "indent": 3,
      "text": "[SCTP-ECN] Stewart, R., Tuexen, M., and X. Dong, \"ECN for Stream Control Transmission Protocol (SCTP)\", Work in Progress, draft-stewart-tsvwg-sctpecn-05, January 2014.",
      "ja": "[SCTP-ECN]スチュワート、R.、Tuexen、M.、およびX.ドン、進行中で働いて、ドラフト・スチュワート・TSVWG-sctpecn-05、2014年1月 \"ストリーム制御伝送プロトコル（SCTP）のためECN\"。"
    },
    {
      "indent": 3,
      "text": "[TEST-RCV] Moncaster, T., Briscoe, B., and A. Jacquet, \"A TCP Test to Allow Senders to Identify Receiver Non-Compliance\", Work in Progress, draft-moncaster-tcpm-rcv-cheat-03, July 2014.",
      "ja": "[TEST-RCV] Moncaster、T.、ブリスコー、B.、およびA.ジャケは、進行中で働いて、 \"TCPテストは送信者が受信非コンプライアンスを識別できるようにするために、\" ドラフトmoncaster-tcpm-RCV-チート-03 、2014年7月。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Ambiguity of the More Accurate ECN Feedback in DCTCP",
      "ja": "DCTCPで、より正確なECNフィードバックの付録A.のあいまいさ"
    },
    {
      "indent": 3,
      "text": "As defined in [DCTCP], a DCTCP receiver feeds back ECE=0 on delayed ACKs as long as CE remains 0, and also immediately sends an ACK with ECE=0 when CE transitions to 1. Similarly, it continually feeds back ECE=1 on delayed ACKs while CE remains 1 and immediately feeds back ECE=1 when CE transitions to 0. A sender can unambiguously decode this scheme if there is never any ACK loss, and the sender assumes there will never be any ACK loss.",
      "ja": "【DCTCP]で定義されるように、DCTCP受信機であればCEが0のままとして遅延ACKにECE = 0をフィードバックし、またすぐに同様に1にECE = 0の場合CE遷移にACKを送信し、それが継続的にECE = 1をフィードバック遅延ACKのCEは1のままで、すぐに= 1つのCE遷移ECEをフィードバック0に任意のACK損失は決してありません場合は、送信者が明確にこのスキームをデコードすることができ、および送信者が任意のACK損失がなることはありません前提としていながら。"
    },
    {
      "indent": 3,
      "text": "The following two examples show that the feedback sequence becomes highly ambiguous to the sender if either of these conditions is broken. Below, '0' represents ECE=0, '1' represents ECE=1, and '.' represents a gap of one segment between delayed ACKs. Now imagine that the sender receives the following sequence of feedback on three pure ACKs:",
      "ja": "次の2つの例は、これらの条件のいずれかが壊れている場合、フィードバックシーケンスが送信者に非常に曖昧になっていることを示しています。以下、 '0' ECE = 0は、 '1' 表しECE = 1、及び ''遅延されたACKの間の1つのセグメントのギャップを表します。今、送信者が3個の純粋のACKにフィードバックの次のシーケンスを受け取ることを想像："
    },
    {
      "indent": 6,
      "text": "0.0.0",
      "section_title": true,
      "ja": "０。０。０"
    },
    {
      "indent": 3,
      "text": "When the receiver sent this sequence, it could have been any of the following four sequences:",
      "ja": "受信機はこのシーケンスを送信した場合、それは次の4つの配列のいずれかだったかもしれません。"
    },
    {
      "indent": 3,
      "text": "a. 0.0.0 (0 x CE)",
      "ja": "。0.0.0（0 X EC）"
    },
    {
      "indent": 3,
      "text": "b. 010.0 (1 x CE)",
      "ja": "B。010.0（1×EC）"
    },
    {
      "indent": 3,
      "text": "c. 0.010 (1 x CE)",
      "ja": "C。0.010（1×EC）"
    },
    {
      "indent": 3,
      "text": "d. 01010 (2 x CE)",
      "ja": "D。01010（2×EC）"
    },
    {
      "indent": 3,
      "text": "where any of the 1s represent a possible pure ACK carrying ECE feedback that could have been lost. If the sender guesses (a), it might be correct, or it might miss 1 or 2 congestion marks over 5 packets. Therefore, when confronted with this simple sequence (that is not contrived), a sender can guess that congestion might have been 0%, 20%, or 40%, but it doesn't know which.",
      "ja": "どこ1Sのいずれかが失われている可能性がECEのフィードバックを運ぶことができ、純粋なACKを表します。送信者の推測（a）の場合、それは正しいかもしれない、またはそれは、5つのパケットの上に1または2輻輳マークを欠場することがあります。この単純なシーケンス（それは不自然ではない）に直面したときしたがって、送信者は輻輳が0％、20％、または40％であったかもしれないことを推測することができますが、それは知りません。"
    },
    {
      "indent": 3,
      "text": "Sequences with a longer gap (e.g., 0...0.0) become far more ambiguous. It helps a little if the sender knows the distance the receiver uses between delayed ACKs, and it helps a lot if the distance is 1, i.e., no delayed ACKs. However, even without delayed ACKs there will still be ambiguity whenever there are pure ACK losses.",
      "ja": "長いギャップ（例えば、0〜0.0）を有する配列は、はるかに曖昧になります。送信者が受信機が遅延ACKの間で使用する距離を知っていればそれは少しを助け、そして距離は、すなわち、無遅延ACK 1であれば、それは多くのことができます。純粋なACKの損失があるたびしかし、遅延ACKなしまだ曖昧さがあるでしょう。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Thanks to Gorry Fairhurst for his review and for ideas on CE-based integrity checking and to Mohammad Alizadeh for suggesting the need to avoid bias.",
      "ja": "彼のレビューのためのバイアスを回避する必要性を示唆ためのチェックCEベースの整合性にし、モハマド・AlizadehにアイデアをGorry Fairhurstに感謝します。"
    },
    {
      "indent": 3,
      "text": "Bob Briscoe was partly funded by the European Community under its Seventh Framework Programme through the Reducing Internet Transport Latency (RITE) project (ICT-317700) and through the Trilogy 2 project (ICT-317756). The views expressed here are solely those of the authors, in the context of the mentioned funding projects.",
      "ja": "ボブ・ブリスコーは、部分的に削減するインターネット交通レイテンシ（RITE）プロジェクト（ICT-317700）を通って、トリロジー2プロジェクト（ICT-317756）を介して、その第七フレームワーク・プログラムの下で欧州共同体によって賄われていました。ここでの見解はもっぱら言及した資金調達プロジェクトの文脈における著者のものです。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Mirja Kuehlewind (editor) ETH Zurich Gloriastrasse 35 Zurich 8092 Switzerland",
      "ja": "Mirja Kuehlewind（エディタ）ETHチューリッヒGloriastrasse 35 8092チューリッヒスイス"
    },
    {
      "indent": 3,
      "text": "Email: mirja.kuehlewind@tik.ee.ethz.ch",
      "ja": "メール：mirja.kuehlewind@tik.ee.ethz.ch"
    },
    {
      "indent": 3,
      "text": "Richard Scheffenegger NetApp, Inc. Am Euro Platz 2 Vienna 1120 Austria",
      "ja": "リチャードScheffeneggerのNetApp、Inc.のアムプラッツユーロ2 1120ウィーンオーストリア"
    },
    {
      "indent": 3,
      "text": "Phone: +43 1 3676811 3146 Email: rs@netapp.com",
      "ja": "電話：+43 1 3676811 3146 Eメール：rs@netapp.com"
    },
    {
      "indent": 3,
      "text": "Bob Briscoe BT B54/77, Adastral Park Martlesham Heath Ipswich IP5 3RE United Kingdom",
      "ja": "ボブ・ブリスコーBT B54 / 77、Adastral公園MartleshamヒースイプスウィッチIP5 3REイギリス"
    },
    {
      "indent": 3,
      "text": "Phone: +44 1473 645196 Email: ietf@bobbriscoe.net URI: http://bobbriscoe.net/",
      "ja": "電話：+44 1473 645196 Eメール：ietf@bobbriscoe.net URI：http://bobbriscoe.net/"
    }
  ]
}