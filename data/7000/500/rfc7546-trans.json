{
  "title": {
    "text": "RFC 7546 - Structure of the Generic Security Service (GSS) Negotiation Loop",
    "ja": "RFC 7546 - 一般的なセキュリティサービス（GSS）交渉ループの構造"
  },
  "number": 7546,
  "created_at": "2019-10-30 07:17:33.904292+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                          B. Kaduk\nRequest for Comments: 7546                                           MIT\nCategory: Informational                                         May 2015\nISSN: 2070-1721",
      "raw": true
    },
    {
      "indent": 4,
      "text": "Structure of the Generic Security Service (GSS) Negotiation Loop",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document specifies the generic structure of the negotiation loop to establish a Generic Security Service (GSS) security context between initiator and acceptor. The control flow of the loop is indicated for both parties, including error conditions, and indications are given for where application-specific behavior must be specified.",
      "ja": "この文書では、イニシエータとアクセプターの間の一般的なセキュリティサービス（GSS）のセキュリティコンテキストを確立するための交渉ループの一般的な構造を指定します。ループの制御フローは、エラー条件を含む両当事者のために示され、指示は、アプリケーション固有の動作を指定しなければならない場合のために与えられています。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "ja": "このドキュメントはインターネット標準化過程仕様ではありません。それは、情報提供の目的のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are a candidate for any level of Internet Standard; see Section 2 of RFC 5741.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。 IESGによって承認されていないすべての文書がインターネットStandardのどんなレベルの候補です。 RFC 5741のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7546.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7546で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2015 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2015 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................2\n2. Application Protocol Requirements ...............................3\n3. Loop Structure ..................................................4\n   3.1. Anonymous Initiators .......................................5\n   3.2. GSS_Init_sec_context .......................................5\n   3.3. Sending from Initiator to Acceptor .........................6\n   3.4. Acceptor Sanity Checking ...................................6\n   3.5. GSS_Accept_sec_context .....................................7\n   3.6. Sending from Acceptor to Initiator .........................8\n   3.7. Initiator Input Validation .................................9\n   3.8. Continue the Loop ..........................................9\n4. After Security Context Negotiation ..............................9\n   4.1. Authorization Checks ......................................10\n   4.2. Using Partially Complete Security Contexts ................10\n   4.3. Additional Context Tokens .................................11\n5. Sample Code ....................................................12\n   5.1. GSS Application Sample Code ...............................13\n6. Security Considerations ........................................19\n7. References .....................................................20\n   7.1. Normative References ......................................20\n   7.2. Informative References ....................................20\nAcknowledgements ..................................................21\nAuthor's Address ..................................................21",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "\"Generic Security Service Application Program Interface Version 2, Update 1\" [RFC2743] provides a generic interface for security services in the form of an abstraction layer over the underlying security mechanisms that an application may use. A GSS initiator and acceptor exchange messages, called \"tokens\", until a security context is established. Such a security context allows for each party to authenticate the other, the passing of confidential and/or integrity-protected messages between the initiator and acceptor, the generation of identical pseudorandom bit strings by both participants [RFC4401], and more.",
      "ja": "「ジェネリックセキュリティーサービス適用業務プログラムインタフェースバージョン2、アップデート1」[RFC2743]は、アプリケーションが使用することができます基本的なセキュリティメカニズムの上に抽象化レイヤの形でセキュリティサービスのための汎用的なインタフェースを提供します。セキュリティコンテキストが確立されるまで、「トークン」と呼ばれるGSSイニシエータとアクセプタ交換メッセージ。各当事者は、両方の参加者によるイニシエータとアクセプタ、同じ擬似ランダムビット列の生成の間に機密および/または完全性保護されたメッセージの受け渡し[RFC4401]他の、よりを認証するためにこのようなセキュリティコンテキストが可能となります。"
    },
    {
      "indent": 3,
      "text": "During context establishment, security context tokens are exchanged synchronously, one at a time; the initiator sends the first context token. The number of tokens that must be exchanged between the initiator and acceptor in order to establish the security context is dependent on the underlying mechanism as well as the desired properties of the security context and is, in general, not known to the application. Accordingly, the application's control flow must include a loop within which GSS security context tokens are exchanged; the loop terminates upon successful establishment of a security context or an error condition. The GSS-API, together with its security mechanisms, specifies the format and encoding of the context tokens themselves, but the application protocol must specify the necessary framing for the application to determine what octet strings constitute GSS security context tokens and pass them into the GSS-API implementation as appropriate.",
      "ja": "コンテキストが確立しているときに、セキュリティコンテキストトークンは、同期時に1つを交換しています。イニシエータは、最初のコンテキスト・トークンを送信します。セキュリティコンテキストを確立するために、イニシエータとアクセプタの間で交換されなければならないトークンの数は、根底にある機構、ならびにセキュリティコンテキストの所望の特性に依存し、一般的に、アプリケーションには知られていない、です。したがって、アプリケーションの制御フローは、GSSセキュリティコンテキストトークンが交換される内ループを含まなければなりません。ループは、セキュリティコンテキストまたはエラー条件の確立に成功すると終了します。 GSS-API、一緒にそのセキュリティメカニズムと、自身トークンが、アプリケーションプロトコルはGSSセキュリティコンテキストトークンを構成するものオクテットストリング決定し、GSSにそれらを渡すために、アプリケーションに必要なフレーミングを指定しなければならないコンテキストのフォーマットおよびエンコーディングを指定適切な-APIの実装。"
    },
    {
      "indent": 3,
      "text": "The GSS-API C-bindings [RFC2744] provide some example code for such a negotiation loop, but this code does not specify the application's behavior on unexpected or error conditions. As such, individual application protocol specifications have had to specify the structure of their GSS negotiation loops, including error handling, on a per-protocol basis (see [RFC4462], [RFC3645], [RFC5801], [RFC4752], and [RFC2203]). This represents a substantial duplication of effort, and the various specifications go into different levels of detail and describe different possible error conditions. Therefore, it is preferable to have the structure of the GSS negotiation loop, including error conditions and token passing, described in a single specification that can then be referred to from other documents in lieu of repeating the structure of the loop each time. This document fills that role.",
      "ja": "GSS-APIのC-バインディング[RFC2744]は、このような交渉ループのためのいくつかのサンプルコードを提供していますが、このコードは、予期しない、またはエラー条件に、アプリケーションの動作を指定しません。例えば、個々のアプリケーションプロトコル仕様ごとのプロトコルに基づいて、エラー処理を含め、それらのGSSネゴシエーションループの構造を指定しなければならなかったように（[RFC4462]、[RFC3645]、[RFC5801]、[RFC4752]及び[RFC2203を参照]）。これは努力のかなりの重複を示しており、様々な仕様が異なる詳細レベルに行くと異なる可能なエラー条件を記述する。したがって、ループの構造毎に繰り返す代わりに、他の文書から参照することができる単一の明細書に記載されたエラー条件とトークンパッシング、を含むGSSネゴシエーションループの構造を有することが好ましいです。この文書では、その役割を果たします。"
    },
    {
      "indent": 3,
      "text": "The necessary requirements for correctly performing a GSS negotiation loop are essentially all included in [RFC2743], but they are scattered in many different places. This document brings all the requirements together into one place for the convenience of implementors, even though the normative requirements remain in [RFC2743]. In a few places, this document notes additional behavior that is useful for applications but is not mandated by [RFC2743].",
      "ja": "正しくGSS交渉ループを実行するために必要な要件は、基本的にすべての[RFC2743]に含まれているが、それらは、多くの異なる場所に散在しています。このドキュメントは、規範的要件は[RFC2743]に残っているにもかかわらず、実装者の便宜のために一箇所にまとめてすべての要件をもたらします。いくつかの場所では、この文書には、用途に有用であるが、[RFC2743]で義務付けされていない追加的な行動を指摘しています。"
    },
    {
      "indent": 0,
      "text": "2. Application Protocol Requirements",
      "section_title": true,
      "ja": "2.アプリケーションプロトコルの要件"
    },
    {
      "indent": 3,
      "text": "Part of the purpose of this document is to guide the development of new application protocols using the GSS-API, as well as the development of new application software using such protocols. The following list consists of features that are necessary or useful in such an application protocol:",
      "ja": "このドキュメントの目的の一部は、GSS-APIを使用して、新しいアプリケーションプロトコルの開発、ならびにそのようなプロトコルを使用して、新しいアプリケーションソフトウェアの開発を導くことです。以下のリストは、アプリケーションプロトコルに必要または有用な機能で構成されています。"
    },
    {
      "indent": 3,
      "text": "o Protocols require a way to frame and identify security context negotiation tokens during the GSS negotiation loop.",
      "ja": "Oプロトコルは、フレームとGSS交渉ループ中にセキュリティコンテキストのネゴシエーショントークンを識別するための方法が必要です。"
    },
    {
      "indent": 3,
      "text": "o Error tokens should generally also get special framing, as the recipient may have no other way to distinguish unexpected error context tokens from per-message tokens.",
      "ja": "受信者がメッセージごとのトークンから予期しないエラーコンテキストトークンを区別する他の方法を持っていないことであるOエラー・トークンは、一般的にも、特別なフレーミングを取得する必要があります。"
    },
    {
      "indent": 3,
      "text": "o Protocols may benefit from a generic means of indicating an error, possibly accompanied by a descriptive string, to be used if error tokens are not available or not usable due to constraints of the application protocol.",
      "ja": "エラートークンが原因アプリケーションプロトコルの制約のために使用可能な利用できるかない場合、Oプロトコルは、エラーを示すの一般的手段から利益を得ることができる、おそらく使用する、説明的な文字列を伴います。"
    },
    {
      "indent": 3,
      "text": "o A protocol may use the negotiated GSS security context for per-message operations; in such cases, the protocol will need a way to frame and identify those per-message tokens and the nature of their contents. For example, a protocol message may be accompanied by the output of GSS_GetMIC() over that message; the protocol must identify the location and size of that Message Identity Code (MIC) token and indicate that it is a MIC token and to what cleartext it corresponds.",
      "ja": "Oプロトコルは、メッセージごとの操作のために交渉GSSセキュリティコンテキストを使用してもよいです。このようなケースでは、プロトコルは、フレームと、それらのメッセージごとのトークンとその内容の性質を識別するための方法が必要になります。例えば、プロトコル・メッセージは、そのメッセージ上GSS_GetMIC（）の出力を伴うことができます。プロトコルは、メッセージ識別コード（MIC）トークンの位置とサイズを特定し、それはトークンとそれが対応するもの平文のMICであることを示さなければなりません。"
    },
    {
      "indent": 3,
      "text": "o Applications are responsible for authorization of the authenticated peer principal names that are supplied by the GSS-API. Such names are mechanism specific and may come from a different portion of a federated identity scheme. Application protocols may need to supply additional information to support the authorization of access to a given resource, such as the Secure Shell version 2 (SSHv2) \"username\" parameter.",
      "ja": "Oアプリケーションは、GSS-APIによって提供されている認証されたピア・プリンシパル名の承認を担当しています。そのような名前は、機構固有のものであり、連合アイデンティティ・スキームの異なる部分から来るかもしれません。アプリケーションプロトコルは、セキュアシェルバージョン2（SSHv2の）「ユーザ名」のパラメータとして、指定されたリソースへのアクセスの許可をサポートするための追加情報を提供する必要があるかもしれません。"
    },
    {
      "indent": 0,
      "text": "3. Loop Structure",
      "section_title": true,
      "ja": "3.ループ構造"
    },
    {
      "indent": 3,
      "text": "The loop is begun by the appropriately named initiator, which calls GSS_Init_sec_context() with an empty (zero-length) input_token and a fixed set of input flags containing the desired attributes for the security context. The initiator should not change any of the input parameters to GSS_Init_sec_context() between calls to it during the loop, with the exception of the input_token parameter, which will contain a message from the acceptor after the initial call, and the input_context_handle, which must be the result returned in the output_context_handle of the previous call to GSS_Init_sec_context() (GSS_C_NO_CONTEXT for the first call). (In the C bindings, there is only a single read/modify context_handle argument, so the same variable should be passed for each call in the loop.) RFC 2743 only requires that the claimant_cred_handle argument remain constant over all calls in the loop, but the other non-excepted arguments should also remain fixed for reliable operation.",
      "ja": "ループは、空（長さゼロ）入力トークンおよびセキュリティコンテキストのための所望の属性を含む入力フラグの固定セットともしGSS_Init_sec_context（）を呼び出して適切な名前開始剤によって開始されます。イニシエータは、である必要があり、最初の呼び出しの後、アクセプタからのメッセージ、及びinput_context_handleを含むであろう入力トークンパラメータを除いて、ループの間にそれへの呼び出しの間）（もしGSS_Init_sec_contextへの入力パラメータのいずれかを変更しないでくださいもしGSS_Init_sec_context（前回の呼び出しのoutput_context_handleに返された結果）（最初の呼び出しのためGSS_C_NO_CONTEXT）。 （同一の変数がループ内の各コールのために通過しなければならないので、Cバインディングでは、単一のリード/引数context_handleを変更されている。）RFC 2743のみclaimant_cred_handle引数は、ループ内のすべてのコールにわたって一定のままであるが、その必要他の非除外引数も信頼性の高い動作のために固定されたままにする必要があります。"
    },
    {
      "indent": 3,
      "text": "The following subsections will describe the various steps of the loop, without special consideration to whether a call to GSS_Init_sec_context() or GSS_Accept_sec_context() is the first such call in the loop.",
      "ja": "以下のサブセクションでは、もしGSS_Init_sec_context（）または場合gss_accept_sec_context（）への呼び出しは、ループの最初のそのようなコールであるか否かに特別な考慮せず、ループの様々なステップを説明します。"
    },
    {
      "indent": 0,
      "text": "3.1. Anonymous Initiators",
      "section_title": true,
      "ja": "3.1。匿名イニシエータ"
    },
    {
      "indent": 3,
      "text": "If the initiator is requesting anonymity by setting the anon_req_flag input to GSS_Init_sec_context(), then on non-error returns from GSS_Init_sec_context() (that is, when the major status is GSS_S_COMPLETE or GSS_S_CONTINUE_NEEDED) the initiator must verify that the output value of anon_state from GSS_Init_sec_context() is true before sending the security context token to the acceptor. Failing to perform this check could cause the initiator to lose anonymity.",
      "ja": "イニシエータ）がもしGSS_Init_sec_context（にanon_req_flag入力を設定することにより、匿名性を要求している場合、もしGSS_Init_sec_contextから非エラー復帰（）（すなわち、主要な状態がGSS_S_COMPLETEまたはGSS_S_CONTINUE_NEEDEDである場合、である）にイニシエータからanon_stateの出力値を確認する必要がありますもしGSS_Init_sec_context（）は、アクセプタにセキュリティコンテキストトークンを送信する前に真です。このチェックを実行しないと、イニシエータは、匿名性を失うことになる可能性があります。"
    },
    {
      "indent": 0,
      "text": "3.2. GSS_Init_sec_context",
      "section_title": true,
      "ja": "3.2。もしGSS_Init_sec_context"
    },
    {
      "indent": 3,
      "text": "The initiator calls GSS_Init_sec_context() using the input_context_handle for the current security context being established and its fixed set of input parameters and the input_token received from the acceptor (if this is not the first iteration of the loop). The presence or absence of a nonempty output_token and the value of the major status code are the indicators for how to proceed:",
      "ja": "イニシエータは、確立されている現在のセキュリティコンテキストのinput_context_handleと入力パラメータのその固定セットを使用して（）もしGSS_Init_sec_contextを呼び出し（これは、ループの最初の反復ではない場合）入力トークンは、アクセプターから受け取りました。存在または不在たoutput_token非空の主要なステータスコードの値は、進め方の指標です。"
    },
    {
      "indent": 3,
      "text": "o If the major status code is GSS_S_COMPLETE and the output_token is empty, then the context negotiation is fully complete and ready for use by the initiator with no further actions.",
      "ja": "主要なステータスコードがGSS_S_COMPLETEであるとのoutput_tokenが空の場合、O、コンテキスト交渉は完全に完全であり、更なる行動をイニシエータで使用するための準備ができています。"
    },
    {
      "indent": 3,
      "text": "o If the major status code is GSS_S_COMPLETE and the output_token is nonempty, then the initiator's portion of the security context negotiation is complete but the acceptor's is not. The initiator must send the output_token to the acceptor so that the acceptor can establish its half of the security context.",
      "ja": "主要なステータスコードがGSS_S_COMPLETEであるとのoutput_tokenが空でない場合は、O、セキュリティコンテキスト交渉のイニシエータの一部が完了しているが、アクセプタのではありません。アクセプターは、セキュリティコンテキストのその半分を確立できるように、イニシエータは、受け入れ側にたoutput_tokenを送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "o If the major status code is GSS_S_CONTINUE_NEEDED and the output_token is nonempty, the context negotiation is incomplete. The initiator must send the output_token to the acceptor and await another input_token from the acceptor.",
      "ja": "主要なステータスコードがGSS_S_CONTINUE_NEEDEDであるとのoutput_tokenが空でない場合は、O、コンテキストネゴシエーションが不完全です。イニシエータは、アクセプターへのoutput_tokenを送信し、アクセプターから別の入力トークンを待つ必要があります。"
    },
    {
      "indent": 3,
      "text": "o If the major status code is GSS_S_CONTINUE_NEEDED and the output_token is empty, the mechanism has produced an output that is not compliant with [RFC2743]. However, there are some known implementations of certain mechanisms such as NT LAN Manager Security Support Provider [NTLMSSP] that do produce empty context negotiation tokens. For maximum interoperability, applications should be prepared to accept such tokens and should transmit them to the acceptor if they are generated.",
      "ja": "主要なステータスコードがGSS_S_CONTINUE_NEEDEDであり、たoutput_tokenが空の場合、O、機構は、[RFC2743]に準拠していない出力を生成しました。しかし、そのような空のコンテキストネゴシエーショントークンを生成しないNT LAN Managerのセキュリティサポートプロバイダ[NTLMSSP]などの特定のメカニズムのいくつかの既知の実装があります。最大の相互運用性のため、アプリケーションは、そのようなトークンを受け入れるように準備する必要があり、それらが発生した場合、アクセプタに送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "o If the major status code is any other value, the context negotiation has failed. If the output_token is nonempty, it is an error token and the initiator should send it to the acceptor. If the output_token is empty, then the initiator should indicate the failure to the acceptor if an appropriate application-protocol channel to do so is available.",
      "ja": "主要なステータスコードは他の値である場合には、O、コンテキストのネゴシエーションに失敗しました。たoutput_tokenが空でない場合は、エラー・トークンがあると、イニシエータは、受け入れ側にそれを送信する必要があります。たoutput_tokenが空の場合、そうするための適切なアプリケーション・プロトコル・チャネルが利用可能である場合、イニシエータは、アクセプターに失敗したことを示すべきです。"
    },
    {
      "indent": 0,
      "text": "3.3. Sending from Initiator to Acceptor",
      "section_title": true,
      "ja": "3.3。イニシエータからアクセプターへの送信"
    },
    {
      "indent": 3,
      "text": "The establishment of a GSS security context between initiator and acceptor requires some communication channel by which to exchange the context negotiation tokens. The nature of this channel is not specified by the GSS specification -- it could be a dedicated TCP channel, a UDP-based Remote Procedure Call (RPC) protocol, or any other sort of channel. In many cases, the channel will be multiplexed with non-GSS application data; the application protocol must always provide some means by which the GSS context tokens can be identified (e.g., length and start location) and passed through to the mechanism accordingly. The application protocol may also include a facility for indicating errors from one party to the other, which can be used to convey errors resulting from GSS-API calls when appropriate (such as when no error token was generated by the GSS-API implementation). Note that GSS major and minor status codes are specified by language bindings, not the abstract API; sending a major status code and optionally the display form of the two error codes may be the best that can be done in this case.",
      "ja": "イニシエータとアクセプタの間のGSSセキュリティコンテキストの確立は、コンテキストネゴシエーショントークンを交換することにより、いくつかの通信チャネルを必要とします。このチャネルの性質はGSS仕様で指定されていない - それは、専用のTCPチャネル、UDPベースのリモートプロシージャコール（RPC）プロトコル、またはチャネルの任意の他の種類である可能性があります。多くの場合、チャネルは非GSS・アプリケーション・データと多重化されます。アプリケーションプロトコルは常にGSSコンテキストトークン（例えば、長さ及び位置を開始する）を同定することができるいくつかの手段を提供し、それに応じて機構を通過しなければなりません。アプリケーションプロトコルはまた、適切な場合（例えば、エラートークンがGSS-APIの実装によって生成されなかった場合など）GSS-APIの呼び出しに起因するエラーを伝えるために使用することができる他の1つの当事者からのエラーを示すための設備を含むことができます。 GSSメジャーとマイナー状態コードが言語バインディングではなく、抽象APIによって指定されていることに注意してください。主要なステータスコードと2つのエラー・コードの必要に応じて表示形式を送信することは、この場合に行うことができる最良であってもよいです。"
    },
    {
      "indent": 3,
      "text": "However, even the presence of a communication channel does not necessarily indicate that it is appropriate for the initiator to indicate such errors. For example, if the acceptor is a stateless or near-stateless UDP server, there is probably no need for the initiator to explicitly indicate its failure to the acceptor. Conditions such as this can be treated in individual application protocol specifications.",
      "ja": "しかしながら、通信チャネルであっても存在することは、必ずしもそのようなエラーを示すために、開始剤に適していることを示すものではありません。アクセプターはステートレスまたはほぼステートレスUDPサーバーであれば、例えば、イニシエータに明示的受容体にその失敗を示すための必要はおそらくありません。このような条件は、個々のアプリケーションプロトコル仕様で処理することができます。"
    },
    {
      "indent": 3,
      "text": "If a regular security context output_token is produced by the call to GSS_Init_sec_context(), the initiator must transmit this token to the acceptor over the application's communication channel. If the call to GSS_Init_sec_context() returns an error token as output_token, it is recommended that the initiator transmit this token to the acceptor over the application's communication channel.",
      "ja": "定期的なセキュリティコンテキストのoutput_tokenがもしGSS_Init_sec_context（）への呼び出しによって生成された場合、イニシエータは、アプリケーションの通信チャネルを介して受容体にこのトークンを送信しなければなりません。もしGSS_Init_sec_context（）への呼び出しがたoutput_tokenとしてエラートークンを返す場合、イニシエータは、アプリケーションの通信チャネルを介してアクセプターにこのトークンを送信することが推奨されます。"
    },
    {
      "indent": 0,
      "text": "3.4. Acceptor Sanity Checking",
      "section_title": true,
      "ja": "3.4。アクセプター正気チェック"
    },
    {
      "indent": 3,
      "text": "The acceptor's half of the negotiation loop is triggered by the receipt of a context token from the initiator. Before calling GSS_Accept_sec_context(), the acceptor may find it useful to perform some sanity checks on the state of the negotiation loop.",
      "ja": "交渉ループの受容体の半分は、イニシエータからのコンテキストトークンの受信によってトリガされます。場合gss_accept_sec_context（）を呼び出す前に、アクセプターは、それが便利な交渉ループの状態にいくつかの健全性チェックを実行するかもしれません。"
    },
    {
      "indent": 3,
      "text": "If the acceptor receives a context token but was not expecting such a token (for example, if the acceptor's previous call to GSS_Accept_sec_context() returned GSS_S_COMPLETE), this is probably an error condition indicating that the initiator's state is invalid. See Section 4.3 for some exceptional cases. It is likely appropriate for the acceptor to report this error condition to the initiator via the application's communication channel.",
      "ja": "アクセプターは、コンテキストトークンを受信するが、これはおそらく、イニシエータの状態が無効であることを示すエラー状態である（場合gss_accept_sec_contextにアクセプターの以前の呼び出しは（）GSS_S_COMPLETEを返した場合、たとえば）などのトークンを期待していなかった場合。いくつかの例外的なケースについては、セクション4.3を参照してください。アクセプターは、アプリケーションの通信チャネルを介してイニシエータにこのエラー状態を報告することはおそらく適切です。"
    },
    {
      "indent": 3,
      "text": "If the acceptor is expecting a context token (e.g., if the previous call to GSS_Accept_sec_context() returned GSS_S_CONTINUE_NEEDED) but does not receive such a token within a reasonable amount of time after transmitting the previous output_token to the initiator, the acceptor should assume that the initiator's state is invalid (timeout) and fail the GSS negotiation. Again, it is likely appropriate for the acceptor to report this error condition to the initiator via the application's communication channel.",
      "ja": "アクセプターがコンテキストトークンを期待されている場合は（場合gss_accept_sec_contextの以前の呼び出しは（）GSS_S_CONTINUE_NEEDEDを返した場合など、）が、イニシエータに以前のoutput_tokenを送信した後、妥当な時間内に、このようなトークンを受信しない、受容体は、その前提とすべきですイニシエータの状態は無効（タイムアウト）であるとGSSの交渉に失敗します。アクセプターは、アプリケーションの通信チャネルを介してイニシエータにこのエラー状態を報告するために再度、それはおそらく適切です。"
    },
    {
      "indent": 0,
      "text": "3.5. GSS_Accept_sec_context",
      "section_title": true,
      "ja": "3.5。場合gss_accept_sec_context"
    },
    {
      "indent": 3,
      "text": "The GSS acceptor responds to the actions of an initiator; as such, there should always be a nonempty input_token to calls to GSS_Accept_sec_context(). The input_context_handle parameter will always be given as the output_context_handle from the previous call to GSS_Accept_sec_context() in a given negotiation loop, or GSS_C_NO_CONTEXT on the first call, but the acceptor_cred_handle and chan_bindings arguments should remain fixed over the course of a given GSS negotiation loop. [RFC2743] only requires that the acceptor_cred_handle remain fixed throughout the loop, but the chan_bindings argument should also remain fixed for reliable operation.",
      "ja": "GSSアクセプターは、イニシエータのアクションに応答します。など、いつものgss_accept_sec_contextの呼び出しに空でない入力トークンがあるはずです（）。 input_context_handleパラメータは常に最初の呼び出しの場合gss_accept_sec_context（）与えられた交渉ループ内、またはGSS_C_NO_CONTEXT前回の呼び出しからoutput_context_handleとして与えられますが、acceptor_cred_handleとchan_bindings引数が与えられたGSS交渉ループの過程で固定されたままにする必要があります。 [RFC2743]は唯一acceptor_cred_handleループを通じて固定されたまま、しかしchan_bindings引数はまた、信頼性の高い動作のために固定されたままでなければならないことを要求します。"
    },
    {
      "indent": 3,
      "text": "The GSS acceptor calls GSS_Accept_sec_context(), using the input_context_handle for the current security context being established and the input_token received from the initiator. The presence or absence of a nonempty output_token and the value of the major status code are the indicators for how to proceed:",
      "ja": "GSSアクセプターが確立されている現在のセキュリティコンテキストのinput_context_handleを用いて、場合gss_accept_sec_context（）を呼び出し、入力トークンは、イニシエータから受信しました。存在または不在たoutput_token非空の主要なステータスコードの値は、進め方の指標です。"
    },
    {
      "indent": 3,
      "text": "o If the major status code is GSS_S_COMPLETE and the output_token is empty, then the context negotiation is fully complete and ready for use by the acceptor with no further actions.",
      "ja": "主要なステータスコードがGSS_S_COMPLETEであるとのoutput_tokenが空の場合、O、コンテキスト交渉は完全に完全であり、更なる行動とアクセプターで使用するための準備ができています。"
    },
    {
      "indent": 3,
      "text": "o If the major status code is GSS_S_COMPLETE and the output_token is nonempty, then the acceptor's portion of the security context negotiation is complete but the initiator's is not. The acceptor must send the output_token to the initiator so that the initiator can establish its half of the security context.",
      "ja": "主要なステータスコードがGSS_S_COMPLETEであるとのoutput_tokenが空でない場合は、O、セキュリティコンテキスト交渉の受容体の一部が完了しているが、イニシエータのではありません。イニシエータは、セキュリティコンテキストのその半分を確立できるように、アクセプターは、イニシエータにたoutput_tokenを送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "o If the major status code is GSS_S_CONTINUE_NEEDED and the output_token is nonempty, the context negotiation is incomplete. The acceptor must send the output_token to the initiator and await another input_token from the initiator.",
      "ja": "主要なステータスコードがGSS_S_CONTINUE_NEEDEDであるとのoutput_tokenが空でない場合は、O、コンテキストネゴシエーションが不完全です。アクセプターは、イニシエータへのoutput_tokenを送信し、イニシエータからの別の入力トークンを待つ必要があります。"
    },
    {
      "indent": 3,
      "text": "o If the major status code is GSS_S_CONTINUE_NEEDED and the output_token is empty, the mechanism has produced an output that is not compliant with [RFC2743]. However, there are some known implementations of certain mechanisms such as NTLMSSP [NTLMSSP] that do produce empty context negotiation tokens. For maximum interoperability, applications should be prepared to accept such tokens and should transmit them to the initiator if they are generated.",
      "ja": "主要なステータスコードがGSS_S_CONTINUE_NEEDEDであり、たoutput_tokenが空の場合、O、機構は、[RFC2743]に準拠していない出力を生成しました。しかしながら、そのような空のコンテキストネゴシエーショントークンを生成行うNTLMSSP [NTLMSSP]などの特定の機構のいくつかの既知の実装が存在します。最大の相互運用性のため、アプリケーションは、そのようなトークンを受け入れるように準備する必要があり、それらが発生した場合、イニシエータに送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "o If the major status code is any other value, the context negotiation has failed. If the output_token is nonempty, it is an error token and the acceptor should send it to the initiator. If the output_token is empty, then the acceptor should indicate the failure to the initiator if an appropriate application-protocol channel to do so is available.",
      "ja": "主要なステータスコードは他の値である場合には、O、コンテキストのネゴシエーションに失敗しました。たoutput_tokenが空でない場合は、エラー・トークンがあるとアクセプターは、イニシエータに送信する必要があります。たoutput_tokenが空の場合、そうするための適切なアプリケーション・プロトコル・チャネルが利用可能である場合、アクセプターはイニシエータに失敗したことを示すべきです。"
    },
    {
      "indent": 0,
      "text": "3.6. Sending from Acceptor to Initiator",
      "section_title": true,
      "ja": "3.6。アクセプターからイニシエータに送信します"
    },
    {
      "indent": 3,
      "text": "The mechanism for sending the context token from acceptor to initiator will depend on the nature of the communication channel between the two parties. For a synchronous bidirectional channel, it can be just another piece of data sent over the link, but for a stateless UDP RPC acceptor, the token will probably end up being sent as an RPC output parameter. Application protocol specifications will need to specify the nature of this behavior.",
      "ja": "イニシエータとアクセプターからコンテキストトークンを送信するためのメカニズムは、二つの当事者間の通信チャネルの性質に依存するであろう。同期双方向チャネルの場合は、リンクを介して送信されるデータのちょうど別の部分でもよいが、ステートレスなUDP RPC受容のために、トークンは、おそらくRPC出力パラメータとして送信されてしまいます。アプリケーションプロトコルの仕様は、この動作の性質を指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the application protocol has the initiator driving the application's control flow, it is particularly helpful for the acceptor to indicate a failure to the initiator, as mentioned in some of the above cases conditional on \"an appropriate application-protocol channel to do so\".",
      "ja": "アプリケーションプロトコルがアプリケーションの制御フローを駆動開始を持っている場合、アクセプター「は、そうするための適切なアプリケーション・プロトコル・チャネル」を条件上記の場合のいくつかで述べたように、イニシエータに失敗したことを示すために特に有用です。"
    },
    {
      "indent": 3,
      "text": "If a regular security context output_token is produced by the call to GSS_Accept_sec_context(), the acceptor must transmit this token to the initiator over the application's communication channel. If the call to GSS_Accept_sec_context() returns an error token as output_token, it is recommended that the acceptor transmit this token to the initiator over the application's communication channel.",
      "ja": "定期的なセキュリティコンテキストのoutput_tokenが場合gss_accept_sec_context（）の呼び出しによって生成された場合、アクセプターは、アプリケーションの通信チャネルを介してイニシエータにこのトークンを送信しなければなりません。場合gss_accept_sec_context（）への呼び出しがたoutput_tokenとしてエラートークンを返す場合、アクセプターは、アプリケーションの通信チャネルを介してイニシエータにこのトークンを送信することが推奨されます。"
    },
    {
      "indent": 0,
      "text": "3.7. Initiator Input Validation",
      "section_title": true,
      "ja": "3.7。イニシエータ入力の検証"
    },
    {
      "indent": 3,
      "text": "The initiator's half of the negotiation loop is triggered (after the first call) by receipt of a context token from the acceptor. Before calling GSS_Init_sec_context(), the initiator may find it useful to perform some sanity checks on the state of the negotiation loop.",
      "ja": "交渉ループのイニシエータの半分は、アクセプターからのコンテキストトークンの受信によって（最初の呼び出しの後に）トリガされます。もしGSS_Init_sec_context（）を呼び出す前に、イニシエータは、それが便利な交渉ループの状態にいくつかの健全性チェックを実行するかもしれません。"
    },
    {
      "indent": 3,
      "text": "If the initiator receives a context token but was not expecting such a token (for example, if the initiator's previous call to GSS_Init_sec_context() returned GSS_S_COMPLETE), this is probably an error condition indicating that the acceptor's state is invalid. See Section 4.3 for some exceptional cases. It may be appropriate for the initiator to report this error condition to the acceptor via the application's communication channel.",
      "ja": "イニシエータは、コンテキストトークンを受信するが、これはおそらく、アクセプターの状態が無効であることを示すエラー状態である（もしGSS_Init_sec_contextへのイニシエータの前の呼び出しは（）GSS_S_COMPLETEを返した場合、たとえば）などのトークンを期待していなかった場合。いくつかの例外的なケースについては、セクション4.3を参照してください。イニシエータは、アプリケーションの通信チャネルを介して受容体にこのエラー状態を報告することが適切かもしれません。"
    },
    {
      "indent": 3,
      "text": "If the initiator is expecting a context token (that is, the previous call to GSS_Init_sec_context() returned GSS_S_CONTINUE_NEEDED) but does not receive such a token within a reasonable amount of time after transmitting the previous output_token to the acceptor, the initiator should assume that the acceptor's state is invalid and fail the GSS negotiation. Again, it may be appropriate for the initiator to report this error condition to the acceptor via the application's communication channel.",
      "ja": "イニシエータは、コンテキストトークンを期待している場合（つまり、もしGSS_Init_sec_contextへの以前の呼び出しは（）GSS_S_CONTINUE_NEEDEDを戻した）が、アクセプターへの以前のoutput_tokenを送信した後、妥当な時間内に、このようなトークンを受信しない、イニシエータがあることを前提とすべきですアクセプターの状態が無効であるとGSSの交渉に失敗します。イニシエータは、アプリケーションの通信チャネルを介して受容体にこのエラー状態を報告するために再度、それが適切かもしれません。"
    },
    {
      "indent": 0,
      "text": "3.8. Continue the Loop",
      "section_title": true,
      "ja": "3.8。ループを続行"
    },
    {
      "indent": 3,
      "text": "If the loop is in neither a success nor a failure condition, then the loop must continue. Control flow returns to Section 3.2.",
      "ja": "ループは、成功も失敗もない状態にある場合、ループは継続しなければなりません。制御フローは、3.2節に戻ります。"
    },
    {
      "indent": 0,
      "text": "4. After Security Context Negotiation",
      "section_title": true,
      "ja": "セキュリティコンテキストの交渉の後に4"
    },
    {
      "indent": 3,
      "text": "Once a party has completed its half of the security context and fulfilled its obligations to the other party, the context is complete, but it is not necessarily ready and appropriate for use. In particular, the security context flags may not be appropriate for the given application's use. In some cases, the context may be ready for use before the negotiation is complete, see Section 4.2.",
      "ja": "当事者がセキュリティコンテキストのその半分を完了し、相手にその義務を果たした後は、コンテキストが完了しているが、それは必ずしも準備し、使用には適していません。具体的には、セキュリティコンテキストのフラグが与えられたアプリケーションの使用のために適切ではないかもしれません。いくつかのケースでは、コンテキストは、交渉が完了する前に、使用する準備ができて、セクション4.2を参照してくださいことがあります。"
    },
    {
      "indent": 3,
      "text": "The initiator specifies, as part of its fixed set of inputs to GSS_Init_sec_context(), values for all defined request flag booleans, among them: deleg_req_flag, mutual_req_flag, replay_det_req_flag, sequence_req_flag, conf_req_flag, and integ_req_flag. Upon completion of the security context negotiation, the initiator must verify that the values of deleg_state, mutual_state, replay_det_state, sequence_state, conf_avail, and integ_avail (and any additional flags added by extensions) from the last call to GSS_Init_sec_context() correspond to the requested flags. If a flag was requested but is not available and that feature is necessary for the application protocol, the initiator must destroy the security context and not use the security context for application traffic.",
      "ja": "イニシエータは、もしGSS_Init_sec_contextへの入力のその固定されたセットの一部として、指定し（）、それらの間のすべての定義済み要求フラグブール、に対する値：deleg_req_flag、mutual_req_flag、replay_det_req_flag、sequence_req_flag、conf_req_flag、及びinteg_req_flag。セキュリティコンテキストのネゴシエーションが完了すると、イニシエータは、もしGSS_Init_sec_context（最後の呼び出しからdeleg_state、mutual_state、replay_det_state、sequence_state、conf_avail、及びinteg_availの値（および拡張によって追加された任意の追加のフラグ））が要求されたフラグに対応することを確認する必要があります。フラグが要求されますが使用できず、その機能は、アプリケーションプロトコルのために必要であるた場合、イニシエータは、セキュリティコンテキストを破棄し、アプリケーショントラフィックのセキュリティコンテキストを使用することはできません。"
    },
    {
      "indent": 3,
      "text": "Application protocol specifications citing this document should indicate which context flags are required for their application protocol.",
      "ja": "この文書を引用するアプリケーションプロトコルの仕様は、フラグが自分のアプリケーションプロトコルのために必要とされる状況を示すべきです。"
    },
    {
      "indent": 3,
      "text": "The acceptor receives as output the following booleans: deleg_state, mutual_state, replay_det_state, sequence_state, anon_state, trans_state, conf_avail, and integ_avail, and any additional flags added by extensions to the GSS-API. The acceptor must verify that any flags necessary for the application protocol are set. If a necessary flag is not set, the acceptor must destroy the security context and not use the security context for application traffic.",
      "ja": "deleg_state、mutual_state、replay_det_state、sequence_state、anon_state、trans_state、conf_avail、およびinteg_avail、およびGSS-APIの拡張機能によって追加された追加のフラグ：アクセプターは、出力として、次のブール値を受け取ります。アクセプターは、アプリケーションプロトコルのために必要なすべてのフラグが設定されていることを確認する必要があります。必要なフラグが設定されていない場合、アクセプターは、セキュリティコンテキストを破棄し、アプリケーショントラフィックのセキュリティコンテキストを使用することはできません。"
    },
    {
      "indent": 0,
      "text": "4.1. Authorization Checks",
      "section_title": true,
      "ja": "4.1。承認チェック"
    },
    {
      "indent": 3,
      "text": "The acceptor receives as one of the outputs of GSS_Accept_sec_context() the name of the initiator that has authenticated during the security context negotiation. Applications need to implement authorization checks on this received name ('client_name' in the sample code) before providing access to restricted resources. In particular, security context negotiation can be successful when the client is anonymous or is from a different identity realm than the acceptor, depending on the details of the mechanism used by the GSS-API to establish the security context. Acceptor applications can check which target name was used by the initiator, but the details are out of scope for this document. See Sections 2.2.6 and 1.1.5 of [RFC2743]. Additional information can be available in GSS-API Naming Extensions [RFC6680].",
      "ja": "アクセプターは、場合gss_accept_sec_context（）セキュリティ・コンテキスト・ネゴシエーション中に認証されているイニシエータ名の出力の一つとして受信します。アプリケーションは、制限されたリソースへのアクセスを提供する前に、この受け取った名前（サンプルコードの「クライアント名」）の認証チェックを実装する必要があります。クライアントが匿名であるか、セキュリティコンテキストを確立するために、GSS-APIが使用するメカニズムの詳細に応じて、アクセプタとは異なるアイデンティティレルムからであるとき、特に、セキュリティコンテキスト交渉が成功することができます。アクセプターアプリケーションは、イニシエータによって使用されたターゲット名をチェックすることができますが、詳細はこの文書の範囲外です。セクションに[RFC2743]の2.2.6と1.1.5を参照してください。追加情報は、GSS-APIの命名拡張[RFC6680]で利用できるようにすることができます。"
    },
    {
      "indent": 0,
      "text": "4.2. Using Partially Complete Security Contexts",
      "section_title": true,
      "ja": "4.2。部分的に完全なセキュリティコンテキストの使用"
    },
    {
      "indent": 3,
      "text": "For mechanism/flag combinations that require multiple token exchanges, the GSS-API specification [RFC2743] provides a prot_ready_state output value from GSS_Init_sec_context() and GSS_Accept_sec_context(), which indicates when per-message operations are available. However, many mechanism implementations do not provide this functionality and the analysis of the security consequences of its use is rather complicated, so it is not expected to be useful in most application protocols.",
      "ja": "複数のトークン交換を必要とする機構/フラグの組合せのために、GSS-API仕様[RFC2743]は、メッセージごとの操作が利用可能であるときを示すもしGSS_Init_sec_context（）及び場合gss_accept_sec_context（）からのprot_ready_state出力値を提供します。しかし、多くのメカニズムの実装では、ほとんどのアプリケーションプロトコルに有用であると期待されていないので、この機能とその利用の安全保障への影響の分析は、かなり複雑で提供されていません。"
    },
    {
      "indent": 3,
      "text": "In particular, mutual authentication, replay protection, and other services (if requested) are services that will be active when GSS_S_COMPLETE is returned but that are not necessarily active before the security context is fully established.",
      "ja": "具体的には、相互認証、再生保護、および他のサービス（要求された場合）GSS_S_COMPLETEが返されたときに有効になりますサービスですが、セキュリティコンテキストが完全に確立される前に、それは必ずしも有効ではありません。"
    },
    {
      "indent": 0,
      "text": "4.3. Additional Context Tokens",
      "section_title": true,
      "ja": "4.3。追加のコンテキストトークン"
    },
    {
      "indent": 3,
      "text": "Under some conditions, a context token will be received by a party to a security context negotiation after that party has completed the negotiation (i.e., after GSS_Init_sec_context() or GSS_Accept_sec_context() has returned GSS_S_COMPLETE). Such tokens must be passed to GSS_Process_context_token() for processing. It may not always be necessary for a mechanism implementation to generate an error token on the initiator side or for an initiator application to transmit that token to the acceptor; such decisions are out of scope for this document. Both peers should always be prepared to process such tokens and application protocols should provide means by which they can be transmitted.",
      "ja": "その当事者が交渉を完了した（すなわち、もしGSS_Init_sec_context後の（）またはのgss_accept_sec_context（）がGSS_S_COMPLETEを返した）後に、いくつかの条件の下では、コンテキスト・トークンは、セキュリティコンテキスト交渉の当事者によって受信されます。このようなトークンは、処理のためGSS_Process_context_token（）に渡す必要があります。機構実装が開始側またはアクセプターにそのトークンを送信するイニシエータアプリケーションのエラートークンを生成することは必ずしも必要ではないかもしれません。そのような決定はこの文書の範囲外です。両方のピアは常に、それらが送信されることができる手段を提供する必要があり、そのようなトークンとアプリケーションプロトコルを処理するために用意されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Such tokens can be security context deletion tokens, emitted when the remote party called GSS_Delete_sec_context() with a non-null output_context_token parameter, or error tokens, emitted when the remote party experiences an error processing the last token in a security context negotiation exchange. Errors experienced when processing tokens earlier in the negotiation would be transmitted as normal security context tokens and processed by GSS_Init_sec_context() or GSS_Accept_sec_context(), as appropriate. With the GSS-API version 2, it is not recommended to use security context deletion tokens, so error tokens are expected to be the most common form of additional context token for new application protocols.",
      "ja": "このようなトークンは、セキュリティコンテキスト削除トークン、相手がセキュリティコンテキスト交渉交換の最後のトークンの処理中にエラーを経験するとき、null以外のoutput_context_tokenパラメータ、またはエラー・トークンとGSS_Delete_sec_context（）と呼ばれる相手は、放出されたときに放出することができます。必要に応じて、以前のネゴシエーションにおいてもしGSS_Init_sec_context（）または場合gss_accept_sec_context（によって通常のセキュリティコンテキストトークンとして送信され、処理されるトークン）を処理する際にエラーが経験しました。 GSS-APIバージョン2では、セキュリティコンテキスト削除トークンを使用することは推奨されませんので、エラー・トークンは、新しいアプリケーションプロトコルのための追加のコンテキスト・トークンの最も一般的な形式であると予想されます。"
    },
    {
      "indent": 3,
      "text": "GSS_Process_context_token() may indicate an error in its major_status field if an error is encountered locally during token processing or to indicate that an error was encountered on the peer and conveyed in an error token. See [Err4151] of [RFC2743]. Regardless of the major_status output of GSS_Process_context_token(), GSS_Inquire_context() should be used after processing the extra token, to query the status of the security context and whether it can supply the features necessary for the application protocol.",
      "ja": "GSS_Process_context_token（）はエラーがトークン処理中に局所的に発生した場合、そのmajor_statusフィールドにエラーを示すか、またはエラーがピアで発生したエラートークンに搬送されたことを示すために。 [Err4151] [RFC2743]の参照してください。かかわらずGSS_Process_context_token（）、GSS_Inquire_context（）のmajor_status出力のセキュリティコンテキストの状態を照会するために、余分なトークンを処理した後に使用されるべきであり、それはアプリケーションプロトコルのために必要な機能を提供できるかどうか。"
    },
    {
      "indent": 3,
      "text": "At present, all tokens that should be handled by GSS_Process_context_token() will lead to the security context being effectively unusable. Future extensions to the GSS-API may allow for applications to continue to function after a call to GSS_Process_context_token(), and it is expected that the outputs of GSS_Inquire_context() will indicate whether it is safe to do so. However, since there are no such extensions at present (error tokens and deletion tokens both result in the security context being essentially unusable), there is no guidance to give to applications regarding this possibility at this time.",
      "ja": "現時点では、）GSS_Process_context_token（によって処理されなければならないすべてのトークンは、セキュリティコンテキストが効果的に使用不可能であることにつながります。 GSS-APIへの将来の拡張）は、アプリケーションがGSS_Process_context_token（への呼び出し後に機能し続けることを可能にする、それがGSS_Inquire_context（の出力ことが期待されている）、そうしても安全であるかどうかを示します。現在のところ、このような機能拡張が（エラー・トークンと削除トークンの両方のセキュリティコンテキストは、基本的に使用不能になる）が存在しないので、この時点では、この可能性についてのアプリケーションに与えるために何のガイダンスはありません。"
    },
    {
      "indent": 3,
      "text": "Even if GSS_Process_context_token() processes an error or deletion token that renders the context essentially unusable, the resources associated with the context must eventually be freed with a call to GSS_Delete_sec_context(), just as would be needed if GSS_Init_sec_context() or GSS_Accept_sec_context() had returned an error while processing an input context token and the input_context_handle was not GSS_C_NO_CONTEXT. RFC 2743 has some text that is slightly ambiguous in this regard, but the best practice is to always call GSS_Delete_sec_context().",
      "ja": "GSS_Process_context_tokenは（）コンテキストが、本質的に使用不能エラーまたは削除トークンを処理した場合でも、コンテキストに関連付けられたリソースが最終的GSS_Delete_sec_context（）を呼び出して解放する必要があり、必要とされるであろうと同じようにもしGSS_Init_sec_context（）またはのgss_accept_sec_context（）が持っていた場合入力コンテキストトークンの処理中にエラーが返され、input_context_handleはGSS_C_NO_CONTEXTなかったです。 RFC 2743は、この点でやや曖昧であるいくつかのテキストを持っていますが、ベストプラクティスは、常にGSS_Delete_sec_context（）を呼び出すことです。"
    },
    {
      "indent": 0,
      "text": "5. Sample Code",
      "section_title": true,
      "ja": "5.サンプルコード"
    },
    {
      "indent": 3,
      "text": "This section gives sample code for the GSS negotiation loop, both for a regular application and for an application where the initiator wishes to remain anonymous. Since the code for the two cases is very similar, the anonymous-specific additions are wrapped in a conditional check; that check and the conditional code may be ignored if anonymous processing is not needed.",
      "ja": "このセクションでは、定期的な用途のため及びイニシエータが匿名を希望するアプリケーションの両方、GSSネゴシエーションループのためのサンプルコードを与えます。 2例のコードは非常に類似しているので、匿名の固有の追加は、条件チェックに包まれています。匿名処理が必要ない場合ことを確認し、条件付きコードは無視することができます。"
    },
    {
      "indent": 3,
      "text": "Since the communication channel between the initiator and acceptor is a matter for individual application protocols, it is inherently unspecified at the GSS-API level, which can lead to examples that are less satisfying than may be desired. For example, the sample code in [RFC2744] uses an unspecified send_token_to_peer() routine. Fully correct and general code to frame and transmit tokens requires a substantial amount of error checking and would detract from the core purpose of this document, so we only present the function signature for one example of what such functions might be and leave some comments in the otherwise empty function bodies.",
      "ja": "イニシエータとアクセプタの間の通信チャネルは、個々のアプリケーションプロトコルの問題であるので、所望され得るよりも満足している例をもたらすことができるGSS-APIレベルで本質的に不特定です。例えば、[RFC2744]のサンプルコードは、不特定send_token_to_peer（）ルーチンを使用します。フレームと、トークンを送信する完全に正しいと一般的なコードのエラーチェックのかなりの量を必要とし、この文書のコア目的を損なうことになるので、我々は、そのような機能が何であるかの一例として機能シグネチャを提示しにおけるいくつかのコメントを残しますそうでない場合は、空の関数本体。"
    },
    {
      "indent": 3,
      "text": "This sample code is written in C, using the GSS-API C-bindings [RFC2744]. It uses the macro GSS_ERROR() to help unpack the various sorts of information that can be stored in the major status field; supplementary information does not necessarily indicate an error. Applications written in other languages will need to exercise care that checks against the major status value are written correctly.",
      "ja": "このサンプルコードは、GSS-APIのC-バインディング[RFC2744]を使用して、Cで書かれています。これは、主要なステータスフィールドに保存することができる各種の情報を展開を支援するマクロGSS_ERROR（）を使用しています。補足情報は、必ずしもエラーを示すものではありません。他の言語で書かれたアプリケーションは、正しく書かれている主要なステータス値に対するチェックの注意を払う必要があります。"
    },
    {
      "indent": 3,
      "text": "This sample code should be compilable as a standalone program, linked against a GSS-API library. In addition to supplying implementations for the token transmission/receipt routines, in order for the program to successfully run when linked against most GSS-API libraries, the initiator will need to specify an explicit target name for the acceptor, which must match the credentials available to the acceptor. A skeleton for how this may be done is provided, using a dummy name.",
      "ja": "このサンプルコードはGSS-APIライブラリとリンクし、スタンドアロンプ​​ログラムとしてコンパイルする必要があります。トークンの送信/受信ルーチンの実装を提供することに加えて、ほとんどのGSS-APIのライブラリにリンクすると、プログラムが正常に実行するためには、イニシエータは、利用可能な資格情報と一致しなければならない、アクセプターの明示的なターゲット名を指定する必要がありますアクセプタへ。これを実行することができる方法のスケルトンは、ダミーの名前を使用して、提供されます。"
    },
    {
      "indent": 3,
      "text": "This sample code assumes use of v2 of the GSS-API. Applications wishing to remain compatible with v1 of the GSS-API may need to perform additional checks in some locations.",
      "ja": "このサンプルコードはGSS-APIのV2の使用を前提としています。 GSS-APIのV1との互換性を維持したいアプリケーションは、いくつかの場所で追加チェックを実行する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.1. GSS Application Sample Code",
      "section_title": true,
      "ja": "5.1。 GSSアプリケーションのサンプル・コード"
    },
    {
      "indent": 0,
      "text": "#include <unistd.h> #include <err.h> #include <stdio.h> #include <stdlib.h> #include <string.h> #include <gssapi/gssapi.h>",
      "ja": "する#include <unistd.h>の#include <err.h>する#include <stdio.hに>する#include <STDLIB.H>の#include <string.hの>する#include <GSSAPI / gssapi.h>"
    },
    {
      "indent": 0,
      "text": "/*\n * This helper is used only on buffers that we allocate ourselves (e.g.,\n * from receive_token()).  Buffers allocated by GSS routines must use\n * gss_release_buffer().\n */\nstatic void\nrelease_buffer(gss_buffer_t buf)\n{\n    free(buf->value);\n    buf->value = NULL;\n    buf->length = 0;\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/*\n * Helper to send a token on the specified file descriptor.\n *\n * If errors are encountered, this routine must not directly cause\n * termination of the process because compliant GSS applications\n * must release resources allocated by the GSS library before\n * exiting.\n *\n * Returns 0 on success, nonzero on failure.\n */\nstatic int\nsend_token(int fd, gss_buffer_t token)\n{\n    /*\n     * Supply token framing and transmission code here.\n     *\n     * It is advisable for the application protocol to specify the\n     * length of the token being transmitted unless the underlying\n     * transit does so implicitly.\n     *\n     * In addition to checking for error returns from whichever\n     * syscall(s) are used to send data, applications should have\n     * a loop to handle EINTR returns.\n     */\n    return 1;\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/*\n * Helper to receive a token on the specified file descriptor.\n *\n * If errors are encountered, this routine must not directly cause\n * termination of the process because compliant GSS applications\n * must release resources allocated by the GSS library before\n * exiting.\n *\n * Returns 0 on success, nonzero on failure.\n */\nstatic int\nreceive_token(int fd, gss_buffer_t token)\n{\n    /*\n     * Supply token framing and transmission code here.\n     *\n     * In addition to checking for error returns from whichever\n     * syscall(s) are used to receive data, applications should have\n     * a loop to handle EINTR returns.\n     *\n     * This routine is assumed to allocate memory for the local copy\n     * of the received token, which must be freed with release_buffer().\n     */\n    return 1;\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "static void\ndo_initiator(int readfd, int writefd, int anon)\n{\n    int initiator_established = 0, ret;\n    gss_ctx_id_t ctx = GSS_C_NO_CONTEXT;\n    OM_uint32 major, minor, req_flags, ret_flags;\n    gss_buffer_desc input_token = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc output_token = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc name_buf = GSS_C_EMPTY_BUFFER;\n    gss_name_t target_name = GSS_C_NO_NAME;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "/* Applications should set target_name to a real value. */\nname_buf.value = \"<service>@<hostname.domain>\";\nname_buf.length = strlen(name_buf.value);\nmajor = gss_import_name(&minor, &name_buf,\n                        GSS_C_NT_HOSTBASED_SERVICE, &target_name);\nif (GSS_ERROR(major)) {\n    warnx(1, \"Could not import name\\n\");\n    goto cleanup;\n}",
      "raw": true
    },
    {
      "indent": 4,
      "text": "/* Mutual authentication will require a token from acceptor to\n * initiator and thus a second call to gss_init_sec_context(). */\nreq_flags = GSS_C_MUTUAL_FLAG | GSS_C_CONF_FLAG | GSS_C_INTEG_FLAG;\nif (anon)\n    req_flags |= GSS_C_ANON_FLAG;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "while (!initiator_established) {\n    /* The initiator_cred_handle, mech_type, time_req,\n     * input_chan_bindings, actual_mech_type, and time_rec\n     * parameters are not needed in many cases.  We pass\n     * GSS_C_NO_CREDENTIAL, GSS_C_NO_OID, 0, NULL, NULL, and NULL\n     * for them, respectively. */\n    major = gss_init_sec_context(&minor, GSS_C_NO_CREDENTIAL, &ctx,\n                                 target_name, GSS_C_NO_OID,\n                                 req_flags, 0, NULL, &input_token,\n                                 NULL, &output_token, &ret_flags,\n                                 NULL);\n    /* This was allocated by receive_token() and is no longer\n     * needed.  Free it now to avoid leaks if the loop continues. */\n    release_buffer(&input_token);\n    if (anon) {\n        /* Initiators that wish to remain anonymous must check\n         * whether their request has been honored before sending\n         * each token. */\n        if (!(ret_flags & GSS_C_ANON_FLAG)) {\n            warnx(\"Anonymous requested but not available\\n\");\n            goto cleanup;\n        }\n    }\n    /* Always send a token if we are expecting another input token\n     * (GSS_S_CONTINUE_NEEDED is set) or if it is nonempty. */\n    if ((major & GSS_S_CONTINUE_NEEDED) ||\n        output_token.length > 0) {\n        ret = send_token(writefd, &output_token);\n        if (ret != 0)\n            goto cleanup;\n    }\n    /* Check for errors after sending the token so that we will send\n     * error tokens. */\n    if (GSS_ERROR(major)) {\n        warnx(\"gss_init_sec_context() error major 0x%x\\n\", major);\n        goto cleanup;\n    }\n    /* Free the output token's storage; we don't need it anymore.\n     * gss_release_buffer() is safe to call on the output buffer\n     * from gss_int_sec_context(), even if there is no storage\n     * associated with that buffer. */\n    (void)gss_release_buffer(&minor, &output_token);",
      "raw": true
    },
    {
      "indent": 0,
      "text": "        if (major & GSS_S_CONTINUE_NEEDED) {\n            ret = receive_token(readfd, &input_token);\n            if (ret != 0)\n                goto cleanup;\n        } else if (major == GSS_S_COMPLETE) {\n            initiator_established = 1;\n        } else {\n            /* This situation is forbidden by RFC 2743.  Bail out. */\n            warnx(\"major not complete or continue but not error\\n\");\n            goto cleanup;\n        }\n    }   /* while (!initiator_established) */\n    if ((ret_flags & req_flags) != req_flags) {\n        warnx(\"Negotiated context does not support requested flags\\n\");\n        goto cleanup;\n    }\n    printf(\"Initiator's context negotiation successful\\n\");\ncleanup:\n    /* We are required to release storage for nonzero-length output\n     * tokens.  gss_release_buffer() zeros the length, so we\n     * will not attempt to release the same buffer twice. */\n    if (output_token.length > 0)\n        (void)gss_release_buffer(&minor, &output_token);\n    /* Do not request a context deletion token; pass NULL. */\n    (void)gss_delete_sec_context(&minor, &ctx, NULL);\n    (void)gss_release_name(&minor, &target_name);\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/*\n * Perform authorization checks on the initiator's GSS name object.\n *\n * Returns 0 on success (the initiator is authorized) and nonzero\n * when the initiator is not authorized.\n */\nstatic int\ncheck_authz(gss_name_t client_name)\n{\n    /*\n     * Supply authorization checking code here.\n     *\n     * Options include bitwise comparison of the exported name against\n     * a local database and introspection against name attributes.\n     */\n    return 0;\n} static void\ndo_acceptor(int readfd, int writefd)\n{\n    int acceptor_established = 0, ret;\n    gss_ctx_id_t ctx = GSS_C_NO_CONTEXT;\n    OM_uint32 major, minor, ret_flags;\n    gss_buffer_desc input_token = GSS_C_EMPTY_BUFFER;\n    gss_buffer_desc output_token = GSS_C_EMPTY_BUFFER;\n    gss_name_t client_name;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "major = GSS_S_CONTINUE_NEEDED;",
      "ja": "主要= GSS_S_CONTINUE_NEEDED。"
    },
    {
      "indent": 4,
      "text": "while (!acceptor_established) {\n    if (major & GSS_S_CONTINUE_NEEDED) {\n        ret = receive_token(readfd, &input_token);\n        if (ret != 0)\n            goto cleanup;\n    } else if (major == GSS_S_COMPLETE) {\n        acceptor_established = 1;\n        break;\n    } else {\n        /* This situation is forbidden by RFC 2743.  Bail out. */\n        warnx(\"major not complete or continue but not error\\n\");\n        goto cleanup;\n    }\n    /* We can use the default behavior or do not need the returned\n     * information for the parameters acceptor_cred_handle,\n     * input_chan_bindings, mech_type, time_rec, and\n     * delegated_cred_handle, and pass the values\n     * GSS_C_NO_CREDENTIAL, NULL, NULL, NULL, and NULL,\n     * respectively.  In some cases the src_name will not be\n     * needed, but most likely it will be needed for some\n     * authorization or logging functionality. */\n    major = gss_accept_sec_context(&minor, &ctx,\n                                   GSS_C_NO_CREDENTIAL,\n                                   &input_token, NULL,\n                                   &client_name, NULL,\n                                   &output_token, &ret_flags, NULL,\n                                   NULL);\n    /* This was allocated by receive_token() and is no longer\n     * needed.  Free it now to avoid leaks if the loop continues. */\n    release_buffer(&input_token);\n    /* Always send a token if we are expecting another input token\n     * (GSS_S_CONTINUE_NEEDED is set) or if it is nonempty. */\n    if ((major & GSS_S_CONTINUE_NEEDED) ||\n        output_token.length > 0) {\n        ret = send_token(writefd, &output_token);\n        if (ret != 0)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "                goto cleanup;\n        }\n        /* Check for errors after sending the token so that we will send\n         * error tokens. */\n        if (GSS_ERROR(major)) {\n            warnx(\"gss_accept_sec_context() error major 0x%x\\n\", major);\n            goto cleanup;\n        }\n        /* Free the output token's storage; we don't need it anymore.\n         * gss_release_buffer() is safe to call on the output buffer\n         * from gss_accept_sec_context(), even if there is no storage\n         * associated with that buffer. */\n        (void)gss_release_buffer(&minor, &output_token);\n    }   /* while (!acceptor_established) */\n    if (!(ret_flags & GSS_C_INTEG_FLAG)) {\n        warnx(\"Negotiated context does not support integrity\\n\");\n        goto cleanup;\n    }\n    printf(\"Acceptor's context negotiation successful\\n\");\n    ret = check_authz(client_name);\n    if (ret != 0)\n        printf(\"Client is not authorized; rejecting access\\n\");\ncleanup:\n    release_buffer(&input_token);\n    /* We are required to release storage for nonzero-length output\n     * tokens.  gss_release_buffer() zeros the length, so we\n     * will not attempt to release the same buffer twice. */\n    if (output_token.length > 0)\n        (void)gss_release_buffer(&minor, &output_token);\n    /* Do not request a context deletion token, pass NULL. */\n    (void)gss_delete_sec_context(&minor, &ctx, NULL);\n    (void)gss_release_name(&minor, &client_name);\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "int\nmain(void)\n{\n    pid_t pid;\n    int fd1 = -1, fd2 = -1;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "/* Create file descriptors for reading/writing here. */\npid = fork();\nif (pid == 0)\n    do_initiator(fd1, fd2, 0);\nelse if (pid > 0)\n    do_acceptor(fd2, fd1);\nelse\n    err(1, \"fork() failed\\n\");",
      "raw": true
    },
    {
      "indent": 0,
      "text": " exit(0); }",
      "ja": "出口（0）; }"
    },
    {
      "indent": 0,
      "text": "6. Security Considerations",
      "section_title": true,
      "ja": "6.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document provides a (reasonably) concise description and example for correct construction of the GSS-API security context negotiation loop. Since everything relating to the construction and use of a GSS security context is security related, there are security-relevant considerations throughout the document. It is useful to call out a few things in this section, though.",
      "ja": "このドキュメントでは、GSS-APIセキュリティコンテキストのネゴシエーションループの正しい構築のための（適度）簡潔な説明および実施例を提供します。 GSSのセキュリティコンテキストの構築および使用に関連するすべてのものは、セキュリティ関連しているので、文書全体にセキュリティ関連の考慮事項があります。しかし、このセクションのいくつかのことを呼び出すのに便利です。"
    },
    {
      "indent": 3,
      "text": "The GSS-API uses a request-and-check model for features. An application using the GSS-API requests certain features (e.g., confidentiality protection for messages or anonymity), but such a request does not require the GSS implementation to provide that feature. The application must check the returned flags to verify whether a requested feature is present; if the feature was non-optional for the application, the application must generate an error. Phrased differently, the GSS-API will not generate an error if it is unable to satisfy the features requested by the application.",
      "ja": "GSS-APIは、機能の要求とチェックモデルを使用しています。 GSS-APIを使用するアプリケーションは、特定の機能を要求する（例えば、機密メッセージや匿名性の保護）が、その機能を提供するために、GSSの実装を必要としないように要求。アプリケーションは、要求された機能が存在するかどうかを確認するために返されるフラグをチェックする必要があります。機能は、アプリケーションのための非オプションだった場合、アプリケーションがエラーを生成する必要があります。アプリケーションによって要求された機能を満たすことができない場合は違った言い方、GSS-APIはエラーを生成しません。"
    },
    {
      "indent": 3,
      "text": "In many cases, it is convenient for GSS acceptors to accept security contexts using multiple acceptor names (such as by using the default credential set, as happens when GSS_C_NO_CREDENTIAL is passed to GSS_Accept_sec_context()). This allows acceptors to use any credentials to which they have access for accepting security contexts, which may not be the desired behavior for a given application. (For example, the Secure Shell daemon (sshd) may wish to accept only using GSS_C_NT_HOSTBASED credentials of the form host@<hostname>, and not nfs@<hostname>.) Acceptor applications can check which target name was used by the initiator, but the details are out of scope for this document. See Sections 2.2.6 and 1.1.5 of [RFC2743]",
      "ja": "GSSは（GSS_C_NO_CREDENTIALが場合gss_accept_sec_context（）に渡されたときに起こるようなデフォルトの資格セットを使用するなど、）複数のアクセプターの名前を使用して、セキュリティコンテキストを受け入れるように受容するために多くの場合、それは便利です。これは、アクセプターは、特定の用途のために必要な動作ではないかもしれない、彼らはセキュリティコンテキストを受け入れるためのアクセス権を持っているいずれかの資格情報を使用することができます。 （例えば、Secure Shellデーモン（sshd）のみの形式のホスト@ <ホスト名>のGSS_C_NT_HOSTBASEDの資格情報を使用して受け入れたくないこと、およびNFS @ <ホスト名>。）アクセプターアプリケーションは、名前がイニシエータによって使用されたターゲットにされ確認することができますしかし、詳細はこの文書の範囲外です。参照してくださいセクション2.2.6および1.1.5の[RFC2743]"
    },
    {
      "indent": 3,
      "text": "The C sample code uses the macro GSS_ERROR() to assess the return value of gss_init_sec_context() and gss_accept_sec_context(). This is done to indicate where checks are needed in writing code for other languages and what the nature of those checks might be. The C code could be made simpler by omitting that macro. In applications expecting to receive protected octet streams, this macro should not be used on the result of per-message operations, as it omits checking for supplementary status values such as GSS_S_DUPLICATE_TOKEN, GSS_S_OLD_TOKEN, etc. Use of the GSS_ERROR() macro on the results of GSS-API per-message operations has resulted in security vulnerabilities in existing software.",
      "ja": "Cのサンプルコードは、場合gss_init_sec_context（）および場合gss_accept_sec_context（）の戻り値を評価するマクロGSS_ERROR（）を使用します。これは、チェックは他の言語とどのようなこれらのチェックの性質があるかもしれないためのコードを書くに必要とされる場所を示すために行われています。 Cコードは、そのマクロを省略することによって簡素化することができます。そのようなGSS_S_DUPLICATE_TOKEN、GSS_S_OLD_TOKENとして補足状態値をチェック省略として保護オクテットストリームを受信することを期待アプリケーションでは、このマクロは、メッセージごとの操作の結果に使用すべきではない、などの結果にGSS_ERROR（）マクロの使用GSS-APIメッセージごとの操作既存のソフトウェアのセキュリティ上の脆弱性をもたらしました。"
    },
    {
      "indent": 3,
      "text": "The security considerations from RFCs 2743 and 2744 remain applicable to consumers of this document.",
      "ja": "RFC 2743および2744からのセキュリティの考慮事項は、この文書の消費者に適用可能です。"
    },
    {
      "indent": 0,
      "text": "7. References",
      "section_title": true,
      "ja": "7.参考"
    },
    {
      "indent": 0,
      "text": "7.1. Normative References",
      "section_title": true,
      "ja": "7.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC2743] Linn, J., \"Generic Security Service Application Program Interface Version 2, Update 1\", RFC 2743, DOI 10.17487/RFC2743, January 2000, <http://www.rfc-editor.org/info/rfc2743>.",
      "ja": "[RFC2743]リン、J.、 \"ジェネリックセキュリティーサービス適用業務プログラムインタフェースバージョン2、アップデート1\"、RFC 2743、DOI 10.17487 / RFC2743、2000年1月、<http://www.rfc-editor.org/info/rfc2743> 。"
    },
    {
      "indent": 3,
      "text": "[RFC2744] Wray, J., \"Generic Security Service API Version 2 : C-bindings\", RFC 2744, DOI 10.17487/RFC2744, January 2000, <http://www.rfc-editor.org/info/rfc2744>.",
      "ja": "[RFC2744]レイ、J.、 \"ジェネリックセキュリティサービスAPIバージョン2：C-バインディング\"、RFC 2744、DOI 10.17487 / RFC2744、2000年1月、<http://www.rfc-editor.org/info/rfc2744>。"
    },
    {
      "indent": 0,
      "text": "7.2. Informative References",
      "section_title": true,
      "ja": "7.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[Err4151] RFC Errata, Erratum ID 4151, RFC 2743.",
      "ja": "【Err4151] RFCエラッタ、エラータID 4151、RFC 2743。"
    },
    {
      "indent": 3,
      "text": "[NTLMSSP] Microsoft Corporation, \"[MS-NLMP]: NT LAN Manager (NTLM) Authentication Protocol\", May 2014, <https://msdn.microsoft.com/en-us/library/cc236621.aspx>.",
      "ja": "[NTLMSSP]マイクロソフトコーポレーション、 \"[MS-NLMP]：NT LANマネージャー（NTLM）認証プロトコル\"、2014年5月、<https://msdn.microsoft.com/en-us/library/cc236621.aspx>。"
    },
    {
      "indent": 3,
      "text": "[RFC2203] Eisler, M., Chiu, A., and L. Ling, \"RPCSEC_GSS Protocol Specification\", RFC 2203, DOI 10.17487/RFC2203, September 1997, <http://www.rfc-editor.org/info/rfc2203>.",
      "ja": "[RFC2203]アイスラー、M.、チウ、A.、およびL.リン、 \"RPCSEC_GSSプロトコル仕様\"、RFC 2203、DOI 10.17487 / RFC2203、1997年9月、<http://www.rfc-editor.org/info/ rfc2203>。"
    },
    {
      "indent": 3,
      "text": "[RFC3645] Kwan, S., Garg, P., Gilroy, J., Esibov, L., Westhead, J., and R. Hall, \"Generic Security Service Algorithm for Secret Key Transaction Authentication for DNS (GSS-TSIG)\", RFC 3645, DOI 10.17487/RFC3645, October 2003, <http://www.rfc-editor.org/info/rfc3645>.",
      "ja": "[RFC3645]クワン、S.、ガーグ、P.、ギルロイ、J.、Esibov、L.、Westhead、J.、およびR.ホール、DNS（GSS-TSIG）用の秘密鍵取引認証のための「一般的なセキュリティサービスアルゴリズム」、RFC 3645、DOI 10.17487 / RFC3645、2003年10月、<http://www.rfc-editor.org/info/rfc3645>。"
    },
    {
      "indent": 3,
      "text": "[RFC4401] Williams, N., \"A Pseudo-Random Function (PRF) API Extension for the Generic Security Service Application Program Interface (GSS-API)\", RFC 4401, DOI 10.17487/RFC4401, February 2006, <http://www.rfc-editor.org/info/rfc4401>.",
      "ja": "[RFC4401]ウィリアムズ、N.、 \"擬似ランダム関数（PRF）ジェネリックセキュリティサービスアプリケーションプログラムインタフェース（GSS-API）のためのAPIの拡張\"、RFC 4401、DOI 10.17487 / RFC4401、2006年2月、<のhttp：// www.rfc-editor.org/info/rfc4401>。"
    },
    {
      "indent": 3,
      "text": "[RFC4462] Hutzelman, J., Salowey, J., Galbraith, J., and V. Welch, \"Generic Security Service Application Program Interface (GSS-API) Authentication and Key Exchange for the Secure Shell (SSH) Protocol\", RFC 4462, DOI 10.17487/RFC4462, May 2006, <http://www.rfc-editor.org/info/rfc4462>.",
      "ja": "[RFC4462] Hutzelman、J.、Salowey、J.、ガルブレイス、J.、およびV.ウェルチ、 \"ジェネリックセキュリティーサービス適用業務プログラムインタフェース（GSS-API）の認証とセキュアシェル（SSH）プロトコルのための鍵交換\"、RFC 4462、DOI 10.17487 / RFC4462、2006年5月、<http://www.rfc-editor.org/info/rfc4462>。"
    },
    {
      "indent": 3,
      "text": "[RFC4752] Melnikov, A., Ed., \"The Kerberos V5 (\"GSSAPI\") Simple Authentication and Security Layer (SASL) Mechanism\", RFC 4752, DOI 10.17487/RFC4752, November 2006, <http://www.rfc-editor.org/info/rfc4752>.",
      "ja": "[RFC4752]メルニコフ、A.、エド、 \"ケルベロスV5（\" GSSAPI \"）簡易認証セキュリティー層（SASL）メカニズム\"、RFC 4752、DOI 10.17487 / RFC4752、2006年11月、<のhttp：。//www.rfc -editor.org/info/rfc4752>。"
    },
    {
      "indent": 3,
      "text": "[RFC5801] Josefsson, S. and N. Williams, \"Using Generic Security Service Application Program Interface (GSS-API) Mechanisms in Simple Authentication and Security Layer (SASL): The GS2 Mechanism Family\", RFC 5801, DOI 10.17487/RFC5801, July 2010, <http://www.rfc-editor.org/info/rfc5801>.",
      "ja": "[RFC5801] Josefsson氏、S.およびN.ウィリアムズ、 \"ジェネリックセキュリティーサービス適用業務プログラムインタフェース（GSS-API）を使用した簡易認証セキュリティー層（SASL）でのメカニズム：GS2メカニズムファミリー\"、RFC 5801、DOI 10.17487 / RFC5801、 2010年7月、<http://www.rfc-editor.org/info/rfc5801>。"
    },
    {
      "indent": 3,
      "text": "[RFC6680] Williams, N., Johansson, L., Hartman, S., and S. Josefsson, \"Generic Security Service Application Programming Interface (GSS-API) Naming Extensions\", RFC 6680, DOI 10.17487/RFC6680, August 2012, <http://www.rfc-editor.org/info/rfc6680>.",
      "ja": "[RFC6680]ウィリアムズ、N.、ヨハンソン、L.、ハートマン、S.、およびS. Josefsson氏、 \"一般的なセキュリティサービスアプリケーションプログラミングインターフェイス（GSS-API）拡張機能に名前を付ける\"、RFC 6680、DOI 10.17487 / RFC6680、2012年8月、 <http://www.rfc-editor.org/info/rfc6680>。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Thanks to Nico Williams and Jeff Hutzleman for prompting me to write this document.",
      "ja": "この文書を書くために私を促すためのニコ・ウィリアムズとジェフHutzlemanに感謝します。"
    },
    {
      "indent": 0,
      "text": "Author's Address",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Benjamin Kaduk MIT Kerberos Consortium",
      "ja": "ベンジャミンKaduk MIT Kerberosのコンソーシアム"
    },
    {
      "indent": 3,
      "text": "EMail: kaduk@mit.edu",
      "ja": "メールアドレス：kaduk@mit.edu"
    }
  ]
}