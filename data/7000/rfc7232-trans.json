{
  "title": {
    "text": "RFC 7232 - Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests",
    "ja": "RFC 7232 - ハイパーテキスト転送プロトコル（HTTP / 1.1）：条件付きリクエスト"
  },
  "number": 7232,
  "created_at": "2019-10-30 12:51:39.392338+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                  R. Fielding, Ed.\nRequest for Comments: 7232                                         Adobe\nObsoletes: 2616                                          J. Reschke, Ed.\nCategory: Standards Track                                     greenbytes\nISSN: 2070-1721                                                June 2014",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems. This document defines HTTP/1.1 conditional requests, including metadata header fields for indicating state changes, request header fields for making preconditions on such state, and rules for constructing the responses to a conditional request when one or more preconditions evaluate to false.",
      "ja": "ハイパーテキスト転送プロトコル（HTTP）は、分散、協調、ハイパーテキスト情報システムのためのステートレスなアプリケーションレベルのプロトコルです。この文書では、状態が変化し、そのような状態の前提条件を作成するためのリクエストヘッダフィールド、および1つ以上の前提条件が偽と評価されたときに、条件付き要求に対する応答を構築するためのルールを示すためのメタデータ・ヘッダ・フィールドを含むHTTP / 1.1の条件付き要求を定義します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 5741のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7232.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7232で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2014 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2014 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 3,
      "text": "This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.",
      "ja": "この材料の一部がIETFトラストにこのような材料の変更を許可する権利を与えられていない可能性がありますにこの文書は、2008年、IETFドキュメントまたは11月10日以前に発行または公開さIETF貢献から著作権を支配する者（複数可）材料を含んでいてもよいですIETF標準化プロセスの外。そのような材料の著作権を管理者（単数または複数）から適切なライセンスを取得することなく、この文書は、IETF標準化過程の外側修正されないかもしれません、そして、それの派生物は、IETF標準化過程の外側に作成されない場合があり、それをフォーマットする以外出版RFCとして、英語以外の言語に翻訳します。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................4\n   1.1. Conformance and Error Handling .............................4\n   1.2. Syntax Notation ............................................4\n2. Validators ......................................................5\n   2.1. Weak versus Strong .........................................5\n   2.2. Last-Modified ..............................................7\n        2.2.1. Generation ..........................................7\n        2.2.2. Comparison ..........................................8\n   2.3. ETag .......................................................9\n        2.3.1. Generation .........................................10\n        2.3.2. Comparison .........................................10\n        2.3.3. Example: Entity-Tags Varying on\n               Content-Negotiated Resources .......................11\n   2.4. When to Use Entity-Tags and Last-Modified Dates ...........12\n3. Precondition Header Fields .....................................13\n   3.1. If-Match ..................................................13\n   3.2. If-None-Match .............................................14\n   3.3. If-Modified-Since .........................................16\n   3.4. If-Unmodified-Since .......................................17\n   3.5. If-Range ..................................................18\n4. Status Code Definitions ........................................18\n   4.1. 304 Not Modified ..........................................18\n   4.2. 412 Precondition Failed ...................................19\n5. Evaluation .....................................................19\n6. Precedence .....................................................20\n7. IANA Considerations ............................................22\n   7.1. Status Code Registration ..................................22\n   7.2. Header Field Registration .................................22\n8. Security Considerations ........................................22\n9. Acknowledgments ................................................23\n10. References ....................................................24\n   10.1. Normative References .....................................24\n   10.2. Informative References ...................................24\nAppendix A. Changes from RFC 2616 .................................25\nAppendix B. Imported ABNF .........................................25\nAppendix C. Collected ABNF ........................................26\nIndex .............................................................27",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "Conditional requests are HTTP requests [RFC7231] that include one or more header fields indicating a precondition to be tested before applying the method semantics to the target resource. This document defines the HTTP/1.1 conditional request mechanisms in terms of the architecture, syntax notation, and conformance criteria defined in [RFC7230].",
      "ja": "条件付きの要求は、ターゲットリソースへのメソッドのセマンティクスを適用する前にテストされるべき前提条件を示す1つのまたは複数のヘッダフィールドを含むHTTPリクエスト[RFC7231]です。この文書では、HTTP / 1.1の条件アーキテクチャの点で要求機構、構文記法、及び[RFC7230]で定義された適合基準を定義します。"
    },
    {
      "indent": 3,
      "text": "Conditional GET requests are the most efficient mechanism for HTTP cache updates [RFC7234]. Conditionals can also be applied to state-changing methods, such as PUT and DELETE, to prevent the \"lost update\" problem: one client accidentally overwriting the work of another client that has been acting in parallel.",
      "ja": "条件付きGET要求はHTTPキャッシュの更新[RFC7234]のための最も効率的なメカニズムです。条件文は、「失われた更新」の問題を防ぐために、このようPUTやDELETEなどの状態変更方法に適用することができる：1つのクライアント誤って並行して活動している他のクライアントの仕事を上書きします。"
    },
    {
      "indent": 3,
      "text": "Conditional request preconditions are based on the state of the target resource as a whole (its current value set) or the state as observed in a previously obtained representation (one value in that set). A resource might have multiple current representations, each with its own observable state. The conditional request mechanisms assume that the mapping of requests to a \"selected representation\" (Section 3 of [RFC7231]) will be consistent over time if the server intends to take advantage of conditionals. Regardless, if the mapping is inconsistent and the server is unable to select the appropriate representation, then no harm will result when the precondition evaluates to false.",
      "ja": "以前に得られた表現（そのセット内の1つの値）で観察されるように、条件付き要求前提条​​件は、全体として対象リソース（現在の値が設定される）、または状態の状態に基づいています。リソースは、複数の電流の表現、独自の観測可能な状態でそれぞれを持っているかもしれません。条件付きの要求メカニズムは、サーバが条件文を活用しようとする場合、「選択された表現」への要求のマッピング（[RFC7231]のセクション3）は、経時的一貫性であろうと仮定する。マッピングが矛盾していると、サーバが適切な表現を選択することができない場合には前提条件がfalseに評価された場合にかかわらず、その後、害は生じないだろう。"
    },
    {
      "indent": 3,
      "text": "The conditional request preconditions defined by this specification (Section 3) are evaluated when applicable to the recipient (Section 5) according to their order of precedence (Section 6).",
      "ja": "本明細書（セクション3）によって定義された条件要求前提条​​件は、優先の順序（第6節）に従って受信者（セクション5）に該当する場合に評価されます。"
    },
    {
      "indent": 0,
      "text": "1.1. Conformance and Error Handling",
      "section_title": true,
      "ja": "1.1. 適合性とエラー処理"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はあります[RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 3,
      "text": "Conformance criteria and considerations regarding error handling are defined in Section 2.5 of [RFC7230].",
      "ja": "適合基準およびエラー処理についての考察は、[RFC7230]のセクション2.5で定義されています。"
    },
    {
      "indent": 0,
      "text": "1.2. Syntax Notation",
      "section_title": true,
      "ja": "1.2. 構文記法"
    },
    {
      "indent": 3,
      "text": "This specification uses the Augmented Backus-Naur Form (ABNF) notation of [RFC5234] with a list extension, defined in Section 7 of [RFC7230], that allows for compact definition of comma-separated lists using a '#' operator (similar to how the '*' operator indicates repetition). Appendix B describes rules imported from other documents. Appendix C shows the collected grammar with all list operators expanded to standard ABNF notation.",
      "ja": "この仕様は次のように「＃」演算子を使用して、カンマ区切りのリストのコンパクトな定義を可能にする[RFC7230]のセクション7で定義されたリストの拡張子、と[RFC5234]の増補バッカス - ナウアフォーム（ABNF）の表記を（使用しますどのように「*」オペレータ）は繰り返しを示します。付録Bは、他の文書からインポートルールを説明します。付録Cには、標準のABNF表記に展開すべてのリスト演算子で収集した文法を示しています。"
    },
    {
      "indent": 0,
      "text": "2. Validators",
      "section_title": true,
      "ja": "2.バリ"
    },
    {
      "indent": 3,
      "text": "This specification defines two forms of metadata that are commonly used to observe resource state and test for preconditions: modification dates (Section 2.2) and opaque entity tags (Section 2.3). Additional metadata that reflects resource state has been defined by various extensions of HTTP, such as Web Distributed Authoring and Versioning (WebDAV, [RFC4918]), that are beyond the scope of this specification. A resource metadata value is referred to as a \"validator\" when it is used within a precondition.",
      "ja": "変更日（セクション2.2）と不透明なエンティティタグ（セクション2.3）：この仕様は、二つの一般的前提条件のリソース状態及びテストを観察するために使用されるメタデータの形態を定義します。リソースの状態を反映する追加のメタデータは、本明細書の範囲を超えて、このようなWeb分散オーサリングとバージョン管理（WebDAV、[RFC4918]）のようなHTTPの様々な拡張、によって定義されています。リソースメタデータの値は、それが前提条件内で使用される「バリデータ」と呼ばれます。"
    },
    {
      "indent": 0,
      "text": "2.1. Weak versus Strong",
      "section_title": true,
      "ja": "2.1. 強い対弱いです"
    },
    {
      "indent": 3,
      "text": "Validators come in two flavors: strong or weak. Weak validators are easy to generate but are far less useful for comparisons. Strong validators are ideal for comparisons but can be very difficult (and occasionally impossible) to generate efficiently. Rather than impose that all forms of resource adhere to the same strength of validator, HTTP exposes the type of validator in use and imposes restrictions on when weak validators can be used as preconditions.",
      "ja": "強いまたは弱い：バリデータは2つの種類があります。弱いバリデータが生成するのは簡単ですが、はるかに便利な比較のためにあります。強力なバリデータは比較のための理想的ですが、効率的に生成することは非常に困難（時には不可能）することができます。リソースのすべての形態は、バリの同じ強度に付着することを課すのではなく、HTTPを使用中のバリデータの種類を公開し、弱いバリデータは、前提条件として使用することができる場合に制限を課します。"
    },
    {
      "indent": 3,
      "text": "A \"strong validator\" is representation metadata that changes value whenever a change occurs to the representation data that would be observable in the payload body of a 200 (OK) response to GET.",
      "ja": "「強いバリデータは、」変化はGETする200（OK）応答のペイロードボディに観察あろう表現データに発生するたびに値が変化する表現メタデータです。"
    },
    {
      "indent": 3,
      "text": "A strong validator might change for reasons other than a change to the representation data, such as when a semantically significant part of the representation metadata is changed (e.g., Content-Type), but it is in the best interests of the origin server to only change the value when it is necessary to invalidate the stored responses held by remote caches and authoring tools.",
      "ja": "表現のメタデータの意味的に重要な部分は、（例えば、Content-Typeの）変更されたときに強いバリデータは、次のような表現データへの変更以外の理由で変更される場合がありますが、それが唯一のオリジンサーバの最善の利益でありますリモート・キャッシュおよびオーサリングツールによって保持された保存された応答を無効にする必要があるときに値を変更します。"
    },
    {
      "indent": 3,
      "text": "Cache entries might persist for arbitrarily long periods, regardless of expiration times. Thus, a cache might attempt to validate an entry using a validator that it obtained in the distant past. A strong validator is unique across all versions of all representations associated with a particular resource over time. However, there is no implication of uniqueness across representations of different resources (i.e., the same strong validator might be in use for representations of multiple resources at the same time and does not imply that those representations are equivalent).",
      "ja": "キャッシュエントリは関係なく、有効期限の、任意の長期間持続することがあります。このように、キャッシュは、それは遠い過去に取得したバリデータを使用してエントリを検証しようとする場合があります。強いバリデータは、時間の経過、特定のリソースに関連付けられたすべての表現のすべてのバージョン間で一意です。しかし、異なるリソースの表現を横切る一意のない意味がない（すなわち、同じ強いバリデータは、同時に複数のリソースの表現のために使用中であるかもしれないし、それらの表現が等価であることを意味するものではありません）。"
    },
    {
      "indent": 3,
      "text": "There are a variety of strong validators used in practice. The best are based on strict revision control, wherein each change to a representation always results in a unique node name and revision identifier being assigned before the representation is made accessible to GET. A collision-resistant hash function applied to the representation data is also sufficient if the data is available prior to the response header fields being sent and the digest does not need to be recalculated every time a validation request is received. However, if a resource has distinct representations that differ only in their metadata, such as might occur with content negotiation over media types that happen to share the same data format, then the origin server needs to incorporate additional information in the validator to distinguish those representations.",
      "ja": "実際に使用される強力なバリの様々なものがあります。最良の表現への各変化は、常に一意のノード名になると表現を取得するためにアクセス可能にされる前に、リビジョン識別子が割り当てられており、厳密なリビジョン管理に基づいています。データはレスポンスヘッダフィールドの前に送信される利用可能であり、ダイジェスト認証要求が受信されるたびに再計算する必要がない場合表現データに適用される衝突困難ハッシュ関数も十分です。リソースは、同じデータ・フォーマットを共有するために起こるのメディアタイプを介してコンテンツの交渉で発生する可能性があるとして、そのメタデータのみが異なる明確な表現を、持っている場合は、その後、オリジンサーバは、それらの表現を区別するためにバリデータに追加情報を組み込む必要。"
    },
    {
      "indent": 3,
      "text": "In contrast, a \"weak validator\" is representation metadata that might not change for every change to the representation data. This weakness might be due to limitations in how the value is calculated, such as clock resolution, an inability to ensure uniqueness for all possible representations of the resource, or a desire of the resource owner to group representations by some self-determined set of equivalency rather than unique sequences of data. An origin server SHOULD change a weak entity-tag whenever it considers prior representations to be unacceptable as a substitute for the current representation. In other words, a weak entity-tag ought to change whenever the origin server wants caches to invalidate old responses.",
      "ja": "これとは対照的に、「弱いバリデータは、」表現データへの変更ごとに変更されない場合があります表現のメタデータです。この弱点は、そのようなクロックの分解能、リソースのすべての可能な表現のための一意性を確保することができない、または等価の一部自己決定集合によって群の表現にリソースの所有者の欲求として値を計算する方法の制限に起因するかもしれませんむしろ、データのユニークな配列よりも。オリジンサーバは、前の表現は、現在の表現の代替として受け入れられないと考えるたびに弱いエンティティタグを変更する必要があります。言い換えれば、弱いエンティティタグは、オリジンサーバが古い応答を無効にするためにキャッシュを望んでいる時はいつでも変更するべきです。"
    },
    {
      "indent": 3,
      "text": "For example, the representation of a weather report that changes in content every second, based on dynamic measurements, might be grouped into sets of equivalent representations (from the origin server's perspective) with the same weak validator in order to allow cached representations to be valid for a reasonable period of time (perhaps adjusted dynamically based on server load or weather quality). Likewise, a representation's modification time, if defined with only one-second resolution, might be a weak validator if it is possible for the representation to be modified twice during a single second and retrieved between those modifications.",
      "ja": "例えば、動的測定に基づいてコンテンツ秒ごとに変化する気象情報の表示は、キャッシュされた表現が有効であることを可能にするために、同じ弱いバリと（オリジンサーバの視点から）同等の表現のセットにグループ化されるかもしれません合理的な期間のために（おそらく、サーバーの負荷や天候品質に基づいて動的に調整）。表現は、単一の第2の中に2回変更され、これらの変更の間に取得することが可能であれば同様に、表現の変更時間は、唯一1秒の分解能で定義されている場合、弱いバリデータであるかもしれません。"
    },
    {
      "indent": 3,
      "text": "Likewise, a validator is weak if it is shared by two or more representations of a given resource at the same time, unless those representations have identical representation data. For example, if the origin server sends the same validator for a representation with a gzip content coding applied as it does for a representation with no content coding, then that validator is weak. However, two simultaneous representations might share the same strong validator if they differ only in the representation metadata, such as when two different media types are available for the same representation data.",
      "ja": "これらの表現は同一の表現データを持っていない限りそれは、同時に与えられたリソースのうちの2つの以上の表現によって共有されている場合も同様に、バリデータは弱いです。例えば、オリジンサーバは、それがコンテンツコードとの表現のために、そのバリが弱いないとして適用GZIPコンテンツコードとの表現のために同じバリデータを送信した場合。彼らは唯一の表現のメタデータが異なる場合は、2つの同時表現は、このような二つの異なるメディアタイプが同じ表現データのために用意されていた場合、同一の強いバリデータを共有することがあります。"
    },
    {
      "indent": 3,
      "text": "Strong validators are usable for all conditional requests, including cache validation, partial content ranges, and \"lost update\" avoidance. Weak validators are only usable when the client does not require exact equality with previously obtained representation data, such as when validating a cache entry or limiting a web traversal to recent changes.",
      "ja": "強力なバリデータはキャッシュの検証、部分コンテンツ範囲、そして「失われた更新」の回避を含むすべての条件付きリクエストのために利用可能です。クライアントは、このようなキャッシュエントリを検証したり、最近の変化にウェブトラバーサルを制限するときのように、先に得られた表現データ、との正確な平等を必要としないときに弱いバリデータは使用可能です。"
    },
    {
      "indent": 0,
      "text": "2.2. Last-Modified",
      "section_title": true,
      "ja": "2.2. 最終更新日"
    },
    {
      "indent": 3,
      "text": "The \"Last-Modified\" header field in a response provides a timestamp indicating the date and time at which the origin server believes the selected representation was last modified, as determined at the conclusion of handling the request.",
      "ja": "応答の「最終修飾」ヘッダフィールドは、オリジンサーバがリクエストを処理の最後に決定されるように選択された表現は、最後に変更されたと考えている日時を示すタイムスタンプを提供します。"
    },
    {
      "indent": 5,
      "text": "Last-Modified = HTTP-date",
      "ja": "= HTTP-日のLast-Modified"
    },
    {
      "indent": 3,
      "text": "An example of its use is",
      "ja": "その使用の例があります"
    },
    {
      "indent": 5,
      "text": "Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT",
      "ja": "最終更新：火、1994年12時45分26秒GMT 11月15日"
    },
    {
      "indent": 0,
      "text": "2.2.1. Generation",
      "section_title": true,
      "ja": "2.2.1. 世代"
    },
    {
      "indent": 3,
      "text": "An origin server SHOULD send Last-Modified for any selected representation for which a last modification date can be reasonably and consistently determined, since its use in conditional requests and evaluating cache freshness ([RFC7234]) results in a substantial reduction of HTTP traffic on the Internet and can be a significant factor in improving service scalability and reliability.",
      "ja": "オリジンサーバは条件付きのリクエストでその使用するので、最終更新日は、合理的かつ一貫して決定することができたために任意の選択の表現のためのLast-Modifiedを送信し、キャッシュ鮮度（[RFC7234]）上のHTTPトラフィックの大幅な削減で結果を評価すべきですインターネットとサービスのスケーラビリティと信頼性を向上させる上で重要な要因となることができます。"
    },
    {
      "indent": 3,
      "text": "A representation is typically the sum of many parts behind the resource interface. The last-modified time would usually be the most recent time that any of those parts were changed. How that value is determined for any given resource is an implementation detail beyond the scope of this specification. What matters to HTTP is how recipients of the Last-Modified header field can use its value to make conditional requests and test the validity of locally cached responses.",
      "ja": "表現は、一般的に、リソース・インターフェースの背後にある多くの部分の総和です。最終更新時間は、通常、それらのいずれかが変更された最新の時間になります。その値は、任意の与えられたリソースに対してどのように決定されるか、この仕様の範囲を超えて、実装の詳細です。どのようなHTTPに重要なのは、最終-Modifiedヘッダフィールドの受信者が条件付きリクエストを作成し、ローカルにキャッシュされた応答の有効性をテストするために、その値を使用する方法です。"
    },
    {
      "indent": 3,
      "text": "An origin server SHOULD obtain the Last-Modified value of the representation as close as possible to the time that it generates the Date field value for its response. This allows a recipient to make an accurate assessment of the representation's modification time, especially if the representation changes near the time that the response is generated.",
      "ja": "オリジンサーバは、その応答の日付フィールドの値を生成し、時間にできるだけ近い表現のLast-Modifiedの値を取得する必要があります。これは、表現が、応答が生成された時間の近くに変わる場合は特に、受信者は表現の修正時刻の正確な評価を行うことができます。"
    },
    {
      "indent": 3,
      "text": "An origin server with a clock MUST NOT send a Last-Modified date that is later than the server's time of message origination (Date). If the last modification time is derived from implementation-specific metadata that evaluates to some time in the future, according to the origin server's clock, then the origin server MUST replace that value with the message origination date. This prevents a future modification date from having an adverse impact on cache validation.",
      "ja": "クロックとオリジンサーバは、メッセージの発信（日）のサーバの時刻より後の最終更新日時を送ってはいけません。最終更新時刻がオリジンサーバの時計によると、将来のある時点に評価され、実装固有のメタデータから導出されている場合、オリジンサーバは、メッセージの発信日時とその値を置き換える必要があります。これは、キャッシュの検証に悪影響を与えることから、将来の更新日時を防ぐことができます。"
    },
    {
      "indent": 3,
      "text": "An origin server without a clock MUST NOT assign Last-Modified values to a response unless these values were associated with the resource by some other system or user with a reliable clock.",
      "ja": "これらの値は信頼性の高いクロックでのいくつかの他のシステムまたはユーザーによってリソースに関連付けられた場合を除きクロックなしオリジンサーバが応答にLast-Modifiedの値を割り当ててはなりません。"
    },
    {
      "indent": 0,
      "text": "2.2.2. Comparison",
      "section_title": true,
      "ja": "2.2.2. 比較"
    },
    {
      "indent": 3,
      "text": "A Last-Modified time, when used as a validator in a request, is implicitly weak unless it is possible to deduce that it is strong, using the following rules:",
      "ja": "最終更新時刻は、要求の中のバリデータとして使用した場合、次の規則を使用して、それが強いと推定することが可能である場合を除き、暗黙的に弱いです。"
    },
    {
      "indent": 3,
      "text": "o The validator is being compared by an origin server to the actual current validator for the representation and,",
      "ja": "バリデータは、表現のための実際の現在のバリデータにオリジンサーバによって比較されているOと、"
    },
    {
      "indent": 3,
      "text": "o That origin server reliably knows that the associated representation did not change twice during the second covered by the presented validator.",
      "ja": "Oそれオリジンサーバは、確実に関連する表現が提示バリでカバー第二中に2回変更されていないことを知っています。"
    },
    {
      "indent": 3,
      "text": "or",
      "ja": "または"
    },
    {
      "indent": 3,
      "text": "o The validator is about to be used by a client in an If-Modified-Since, If-Unmodified-Since, or If-Range header field, because the client has a cache entry for the associated representation, and",
      "ja": "バリデータは、クライアントが関連付けられた表現のためのキャッシュエントリを有しているので、もし修飾-ので、クライアントによって使用されようとした場合、未修飾-ので、場合やレンジヘッダフィールドであり、およびo"
    },
    {
      "indent": 3,
      "text": "o That cache entry includes a Date value, which gives the time when the origin server sent the original response, and",
      "ja": "そのキャッシュエントリがオリジンサーバが元の応答を送信した時刻を与えるDate値を含み、かつO"
    },
    {
      "indent": 3,
      "text": "o The presented Last-Modified time is at least 60 seconds before the Date value.",
      "ja": "O提示のLast-Modified時間が日付値の前に少なくとも60秒です。"
    },
    {
      "indent": 3,
      "text": "or",
      "ja": "または"
    },
    {
      "indent": 3,
      "text": "o The validator is being compared by an intermediate cache to the validator stored in its cache entry for the representation, and",
      "ja": "バリデータは、表現のためにそのキャッシュエントリに格納されたバリの中間キャッシュによって比較され、O、及び"
    },
    {
      "indent": 3,
      "text": "o That cache entry includes a Date value, which gives the time when the origin server sent the original response, and",
      "ja": "そのキャッシュエントリがオリジンサーバが元の応答を送信した時刻を与えるDate値を含み、かつO"
    },
    {
      "indent": 3,
      "text": "o The presented Last-Modified time is at least 60 seconds before the Date value.",
      "ja": "O提示のLast-Modified時間が日付値の前に少なくとも60秒です。"
    },
    {
      "indent": 3,
      "text": "This method relies on the fact that if two different responses were sent by the origin server during the same second, but both had the same Last-Modified time, then at least one of those responses would have a Date value equal to its Last-Modified time. The arbitrary 60-second limit guards against the possibility that the Date and Last-Modified values are generated from different clocks or at somewhat different times during the preparation of the response. An implementation MAY use a value larger than 60 seconds, if it is believed that 60 seconds is too short.",
      "ja": "この方法は、二つの異なるレスポンスが同じ秒の間、オリジンサーバによって送信されますが、両方が同じ最終更新時刻を持っていた場合、それらの応答の少なくとも一つはそのLast-Modifiedのと同じ日付値を持っているという事実に依存しています時間。日付およびLast-Modifiedの値が応答の準備中に、異なるクロックまたは幾分異なる時間に生成される可能性に対して任意の60秒の限界ガード。 60秒は短すぎると考えられている場合、実装は、60秒以上の値を使用するかもしれません。"
    },
    {
      "indent": 0,
      "text": "2.3. ETag",
      "section_title": true,
      "ja": "2.3.  ETagを"
    },
    {
      "indent": 3,
      "text": "The \"ETag\" header field in a response provides the current entity-tag for the selected representation, as determined at the conclusion of handling the request. An entity-tag is an opaque validator for differentiating between multiple representations of the same resource, regardless of whether those multiple representations are due to resource state changes over time, content negotiation resulting in multiple representations being valid at the same time, or both. An entity-tag consists of an opaque quoted string, possibly prefixed by a weakness indicator.",
      "ja": "要求を処理の最後に決定されるように応答して「のETag」ヘッダーフィールドは、選択された表現のための現在のエンティティタグを提供します。エンティティタグにかかわらず、それらの複数の表現は複数の表現が同時に有効である、または両方で得られた経時的な状態変化、コンテンツネゴシエーションをリソースに起因するかどうかの、同じリソースの複数の表現を区別するための不透明なバリデータです。エンティティタグは、おそらく弱インジケータで始まる不透明な引用符で囲まれた文字列からなります。"
    },
    {
      "indent": 5,
      "text": "ETag = entity-tag",
      "ja": "ETag =エンティティタグ"
    },
    {
      "indent": 5,
      "text": "entity-tag = [ weak ] opaque-tag weak = %x57.2F ; \"W/\", case-sensitive opaque-tag = DQUOTE *etagc DQUOTE etagc = %x21 / %x23-7E / obs-text ; VCHAR except double quotes, plus obs-text",
      "ja": "エンティティタグ= [弱]不透明タグ弱=％のx57.2F。 \"W /\"、大文字と小文字を区別不透明タグ= DQUOTE * etagc DQUOTE etagc =％X21 /％x23-7E / OBSテキスト。二重引用符を除くVCHAR、プラスOBS-テキスト"
    },
    {
      "indent": 6,
      "text": "Note: Previously, opaque-tag was defined to be a quoted-string ([RFC2616], Section 3.11); thus, some recipients might perform backslash unescaping. Servers therefore ought to avoid backslash characters in entity tags.",
      "ja": "注：以前は、不透明なタグが引用文字列（[RFC2616]、セクション3.11）としました。このように、一部の受信者は、バックスラッシュアンエスケープを行う可能性があります。サーバーは、したがって、エンティティタグにバックスラッシュ文字を避けるべきです。"
    },
    {
      "indent": 3,
      "text": "An entity-tag can be more reliable for validation than a modification date in situations where it is inconvenient to store modification dates, where the one-second resolution of HTTP date values is not sufficient, or where modification dates are not consistently maintained.",
      "ja": "エンティティタグは、HTTP日付値の1秒の分解能が十分でない、又はここで修正日付が一貫して維持されていないストア変更日付、に不便である状況で変更日より検証のためのより信頼性であることができます。"
    },
    {
      "indent": 3,
      "text": "Examples:",
      "ja": "例："
    },
    {
      "indent": 5,
      "text": "ETag: \"xyzzy\" ETag: W/\"xyzzy\" ETag: \"\"",
      "ja": "ETag： \"XYZZY\" のETag：W / \"XYZZY\" のETag： \"\""
    },
    {
      "indent": 3,
      "text": "An entity-tag can be either a weak or strong validator, with strong being the default. If an origin server provides an entity-tag for a representation and the generation of that entity-tag does not satisfy all of the characteristics of a strong validator (Section 2.1), then the origin server MUST mark the entity-tag as weak by prefixing its opaque value with \"W/\" (case-sensitive).",
      "ja": "エンティティタグは強いがデフォルトであることと、どちらか弱いか強いバリすることができます。オリジンサーバが表現と強いバリ（セクション2.1）の特性の全てを満足しないそのエンティティタグを生成するためのエンティティタグを提供する場合、オリジンサーバはプレフィックスによって弱いとしてエンティティタグをマークしなければなりません「W /」（大文字と小文字を区別）との不透明値。"
    },
    {
      "indent": 0,
      "text": "2.3.1. Generation",
      "section_title": true,
      "ja": "2.3.1. 世代"
    },
    {
      "indent": 3,
      "text": "The principle behind entity-tags is that only the service author knows the implementation of a resource well enough to select the most accurate and efficient validation mechanism for that resource, and that any such mechanism can be mapped to a simple sequence of octets for easy comparison. Since the value is opaque, there is no need for the client to be aware of how each entity-tag is constructed.",
      "ja": "エンティティタグの原理は、サービスの著者は、そのリソースのための最も正確かつ効率的な検証メカニズムを選択するように十分リソースの実装を知っていること、およびそのようなメカニズムを簡単に比較するためのオクテットの簡単なシーケンスにマップすることができるということです。値が不透明であるので、クライアントは各エンティティタグを構築する方法を認識するための必要はありません。"
    },
    {
      "indent": 3,
      "text": "For example, a resource that has implementation-specific versioning applied to all changes might use an internal revision number, perhaps combined with a variance identifier for content negotiation, to accurately differentiate between representations. Other implementations might use a collision-resistant hash of representation content, a combination of various file attributes, or a modification timestamp that has sub-second resolution.",
      "ja": "例えば、すべての変更に適用される実装固有のバージョンを持っているリソースを正確に表現を区別するために、おそらくコンテンツネゴシエーションのための分散識別子と組み合わされ、内部リビジョン番号を使用するかもしれません。他の実装では、表現内容の衝突困難ハッシュ、様々なファイル属性の組合せ、またはサブ秒の分解能を有する修正タイムスタンプを使用するかもしれません。"
    },
    {
      "indent": 3,
      "text": "An origin server SHOULD send an ETag for any selected representation for which detection of changes can be reasonably and consistently determined, since the entity-tag's use in conditional requests and evaluating cache freshness ([RFC7234]) can result in a substantial reduction of HTTP network traffic and can be a significant factor in improving service scalability and reliability.",
      "ja": "条件付きの要求および評価キャッシュ鮮度（[RFC7234]）内のエンティティタグの使用は、HTTPネットワークの実質的な減少をもたらすことができるので、オリジンサーバは、変更の検出が合理的かつ一貫して決定することができるため、任意の選択された表現のためのETagを送りますトラフィックとサービスのスケーラビリティと信頼性を向上させる上で重要な要因となることができます。"
    },
    {
      "indent": 0,
      "text": "2.3.2. Comparison",
      "section_title": true,
      "ja": "2.3.2. 比較"
    },
    {
      "indent": 3,
      "text": "There are two entity-tag comparison functions, depending on whether or not the comparison context allows the use of weak validators:",
      "ja": "2エンティティタグ比較関数は、比較文脈が弱いバリデータの使用を可能にするか否かに応じて、あります。"
    },
    {
      "indent": 3,
      "text": "o Strong comparison: two entity-tags are equivalent if both are not weak and their opaque-tags match character-by-character.",
      "ja": "O強力な比較：2エンティティタグの両方が弱いものではなく、その不透明なタグが文字と一致した場合と同等です。"
    },
    {
      "indent": 3,
      "text": "o Weak comparison: two entity-tags are equivalent if their opaque-tags match character-by-character, regardless of either or both being tagged as \"weak\".",
      "ja": "O弱い比較：その不透明タグに関係なくいずれか一方または両方の「弱い」としてタグ付けされ、文字単位に一致する場合、2つのエンティティタグは同等です。"
    },
    {
      "indent": 3,
      "text": "The example below shows the results for a set of entity-tag pairs and both the weak and strong comparison function results:",
      "ja": "以下の例では、エンティティタグのペアとの両方弱いと強い比較関数の結果のセットの結果を示します。"
    },
    {
      "indent": 3,
      "text": "+--------+--------+-------------------+-----------------+\n| ETag 1 | ETag 2 | Strong Comparison | Weak Comparison |\n+--------+--------+-------------------+-----------------+\n| W/\"1\"  | W/\"1\"  | no match          | match           |\n| W/\"1\"  | W/\"2\"  | no match          | no match        |\n| W/\"1\"  | \"1\"    | no match          | match           |\n| \"1\"    | \"1\"    | match             | match           |\n+--------+--------+-------------------+-----------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "2.3.3. Example: Entity-Tags Varying on Content-Negotiated Resources",
      "section_title": true,
      "ja": "2.3.3. 例：コンテンツ-交渉資源に変えるエンティティ - タグ"
    },
    {
      "indent": 3,
      "text": "Consider a resource that is subject to content negotiation (Section 3.4 of [RFC7231]), and where the representations sent in response to a GET request vary based on the Accept-Encoding request header field (Section 5.3.4 of [RFC7231]):",
      "ja": "コンテンツネゴシエーション（[RFC7231]のセクション3.4）の対象となるリソースを考慮して、GET要求に応答して送信された表現を受け入れ、符号化を要求ヘッダフィールド（[RFC7231]のセクション5.3.4）に基づいて変化する場合："
    },
    {
      "indent": 3,
      "text": ">> Request:",
      "ja": ">>リクエスト："
    },
    {
      "indent": 5,
      "text": "GET /index HTTP/1.1 Host: www.example.com Accept-Encoding: gzip",
      "ja": "GET /インデックスHTTP / 1.1ホスト：www.example.comは受け入れ-エンコード：gzipで"
    },
    {
      "indent": 3,
      "text": "In this case, the response might or might not use the gzip content coding. If it does not, the response might look like:",
      "ja": "この場合、応答は、またはgzipのコンテンツのコーディングを使用しない場合があります。そうでない場合、応答は次のようになります。"
    },
    {
      "indent": 3,
      "text": ">> Response:",
      "ja": ">>回答："
    },
    {
      "indent": 5,
      "text": "HTTP/1.1 200 OK Date: Fri, 26 Mar 2010 00:05:00 GMT ETag: \"123-a\" Content-Length: 70 Vary: Accept-Encoding Content-Type: text/plain",
      "ja": "HTTP / 1.1 200 OK日：金、2010年3月26日夜十二時05分00秒GMTのETagを： \"123-\" のContent-Length：70ヴァリ：受け入れエンコードのContent-Type：text / plainのを"
    },
    {
      "indent": 5,
      "text": "Hello World! Hello World! Hello World! Hello World! Hello World!",
      "ja": "\"こんにちは世界\" \"こんにちは世界\" \"こんにちは世界\" \"こんにちは世界\" \"こんにちは世界\""
    },
    {
      "indent": 3,
      "text": "An alternative representation that does use gzip content coding would be:",
      "ja": "GZIPコンテンツのコーディングを使用しない代替表現は次のようになります。"
    },
    {
      "indent": 3,
      "text": ">> Response:",
      "ja": ">>回答："
    },
    {
      "indent": 5,
      "text": "HTTP/1.1 200 OK Date: Fri, 26 Mar 2010 00:05:00 GMT ETag: \"123-b\" Content-Length: 43 Vary: Accept-Encoding Content-Type: text/plain Content-Encoding: gzip",
      "ja": "HTTP / 1.1 200 OK日：金、2010年3月26日夜十二時05分00秒GMTのETag： \"123-B\" のContent-Length：43ヴァリ：受け入れエンコードのContent-Type：text / plainのコンテンツエンコード：GZIPを"
    },
    {
      "indent": 5,
      "text": "...binary data...",
      "ja": "...バイナリデータ..."
    },
    {
      "indent": 6,
      "text": "Note: Content codings are a property of the representation data, so a strong entity-tag for a content-encoded representation has to be distinct from the entity tag of an unencoded representation to prevent potential conflicts during cache updates and range requests. In contrast, transfer codings (Section 4 of [RFC7230]) apply only during message transfer and do not result in distinct entity-tags.",
      "ja": "注：コンテンツコーディングは、表現データのプロパティであるため、コンテンツ符号化された表現のための強力なエンティティタグがキャッシュ更新と範囲要求中に潜在的な競合を防止するためにエンコードされていない表現のエンティティタグと区別しなければなりません。対照的に、転送コーディング（[RFC7230]のセクション4）は、メッセージの転送中にのみ適用され、別個のエンティティタグをもたらしません。"
    },
    {
      "indent": 0,
      "text": "2.4. When to Use Entity-Tags and Last-Modified Dates",
      "section_title": true,
      "ja": "2.4. エンティティタグとLast-Modifiedの日付を使用する場合"
    },
    {
      "indent": 3,
      "text": "In 200 (OK) responses to GET or HEAD, an origin server:",
      "ja": "200（OK）応答では、オリジンサーバをGETまたはHEADします："
    },
    {
      "indent": 3,
      "text": "o SHOULD send an entity-tag validator unless it is not feasible to generate one.",
      "ja": "1を生成することは不可能でない限り、oは、エンティティタグバリデータを送るべきです。"
    },
    {
      "indent": 3,
      "text": "o MAY send a weak entity-tag instead of a strong entity-tag, if performance considerations support the use of weak entity-tags, or if it is unfeasible to send a strong entity-tag.",
      "ja": "パフォーマンスの考慮が弱いエンティティタグの使用をサポートしている場合、または強いエンティティタグを送信することは実現不可能である場合には、O、弱いエンティティタグの代わりに、強いエンティティタグを送ることができます。"
    },
    {
      "indent": 3,
      "text": "o SHOULD send a Last-Modified value if it is feasible to send one.",
      "ja": "1を送信することが可能である場合oはLast-Modifiedの値を送るべきです。"
    },
    {
      "indent": 3,
      "text": "In other words, the preferred behavior for an origin server is to send both a strong entity-tag and a Last-Modified value in successful responses to a retrieval request.",
      "ja": "言い換えれば、オリジンサーバのための有利な挙動は強いエンティティタグや検索要求に成功した応答でのLast-Modified値の両方を送信することです。"
    },
    {
      "indent": 3,
      "text": "A client:",
      "ja": "クライアント："
    },
    {
      "indent": 3,
      "text": "o MUST send that entity-tag in any cache validation request (using If-Match or If-None-Match) if an entity-tag has been provided by the origin server.",
      "ja": "エンティティタグがオリジンサーバによって提供されている場合oは（使用してマッチする場合またはもし-なしマッチ）任意のキャッシュ検証要求にそのエンティティタグを送らなければなりません。"
    },
    {
      "indent": 3,
      "text": "o SHOULD send the Last-Modified value in non-subrange cache validation requests (using If-Modified-Since) if only a Last-Modified value has been provided by the origin server.",
      "ja": "非サブレンジキャッシュ確認要求でのLast-Modified値を送るべきであるoはLast-Modified値のみがオリジンサーバによって提供されている場合（ - 以降に変更した場合、使用して）。"
    },
    {
      "indent": 3,
      "text": "o MAY send the Last-Modified value in subrange cache validation requests (using If-Unmodified-Since) if only a Last-Modified value has been provided by an HTTP/1.0 origin server. The user agent SHOULD provide a way to disable this, in case of difficulty.",
      "ja": "Last-Modified値のみがHTTP / 1.0オリジンサーバによって提供されている場合には、O（場合非改変-以来使用して）サブレンジキャッシュ確認要求でのLast-Modified値を送信することができます。ユーザエージェントは、困難な場合には、これを無効にする方法を提供する必要があります。"
    },
    {
      "indent": 3,
      "text": "o SHOULD send both validators in cache validation requests if both an entity-tag and a Last-Modified value have been provided by the origin server. This allows both HTTP/1.0 and HTTP/1.1 caches to respond appropriately.",
      "ja": "エンティティタグとLast-Modified値の両方がオリジンサーバによって提供されている場合は、Oキャッシュ検証要求の両方のバリデータを送るべきです。これは、両方のHTTP / 1.0およびHTTP / 1.1キャッシュが適切に対応することができます。"
    },
    {
      "indent": 0,
      "text": "3. Precondition Header Fields",
      "section_title": true,
      "ja": "3.前提条件ヘッダフィールド"
    },
    {
      "indent": 3,
      "text": "This section defines the syntax and semantics of HTTP/1.1 header fields for applying preconditions on requests. Section 5 defines when the preconditions are applied. Section 6 defines the order of evaluation when more than one precondition is present.",
      "ja": "このセクションでは、要求の前提条件を適用するためのHTTP / 1.1ヘッダフィールドの構文と意味論を定義します。前提条件が適用される場合第5節では定義されています。以上の前提条件が存在するとき部6は、評価の順序を定義します。"
    },
    {
      "indent": 0,
      "text": "3.1. If-Match",
      "section_title": true,
      "ja": "3.1. もしマッチ"
    },
    {
      "indent": 3,
      "text": "The \"If-Match\" header field makes the request method conditional on the recipient origin server either having at least one current representation of the target resource, when the field-value is \"*\", or having a current representation of the target resource that has an entity-tag matching a member of the list of entity-tags provided in the field-value.",
      "ja": "「マッチした場合、」ヘッダフィールドは、受信者のオリジンサーバがフィールド値が「*」である場合、ターゲットリソースの少なくとも1つの電流の表現を有するか、またはその対象リソースの現在の表現を有するいずれかの上の要求メソッドが条件になりフィールド値内に設けられたエンティティタグのリストのメンバーと一致するエンティティタグを有しています。"
    },
    {
      "indent": 3,
      "text": "An origin server MUST use the strong comparison function when comparing entity-tags for If-Match (Section 2.3.2), since the client intends this precondition to prevent the method from being applied if there have been any changes to the representation data.",
      "ja": "もしマッチ（2.3.2）のためのエンティティタグを比較するとき、クライアントは表現データに変更があった場合に適用されることから、この方法を防ぐために、この前提条件を意図するので、オリジンサーバは、強い比較機能を使わなければなりません。"
    },
    {
      "indent": 5,
      "text": "If-Match = \"*\" / 1#entity-tag",
      "ja": "もしマッチ=「*」/ 1＃エンティティタグ"
    },
    {
      "indent": 3,
      "text": "Examples:",
      "ja": "例："
    },
    {
      "indent": 5,
      "text": "If-Match: \"xyzzy\" If-Match: \"xyzzy\", \"r2d2xxxx\", \"c3piozzzz\" If-Match: *",
      "ja": "マッチの場合：もしマッチ \"XYZZY\"： \"XYZZY\"、 \"r2d2xxxx\"、 \"c3piozzzz\" もしマッチ：*"
    },
    {
      "indent": 3,
      "text": "If-Match is most often used with state-changing methods (e.g., POST, PUT, DELETE) to prevent accidental overwrites when multiple user agents might be acting in parallel on the same resource (i.e., to prevent the \"lost update\" problem). It can also be used with safe methods to abort a request if the selected representation does not match one already stored (or partially stored) from a prior request.",
      "ja": "マッチをした場合、最も頻繁に状態変化する方法で使用される（例えば、POST、PUT、DELETE）は、複数のユーザーエージェントは、同じリソース上で並列に動作するかもしれない時に不慮の上書きを防ぐために（すなわち、「失われた更新」の問題を防ぐために） 。選択された表現は、一つ前のリクエストから既に記憶されている（または部分的に格納されている）と一致しない場合にも、要求を中止する安全な方法で使用することができます。"
    },
    {
      "indent": 3,
      "text": "An origin server that receives an If-Match header field MUST evaluate the condition prior to performing the method (Section 5). If the field-value is \"*\", the condition is false if the origin server does not have a current representation for the target resource. If the field-value is a list of entity-tags, the condition is false if none of the listed tags match the entity-tag of the selected representation.",
      "ja": "If-Matchヘッダフィールドを受信したオリジンサーバは、従来の方法（セクション5）を実行することに条件を評価しなければなりません。フィールド値が「*」であればオリジンサーバがターゲットリソースの現在の表現を持っていない場合は、条件が偽です。フィールド値は、エンティティタグのリストがある場合は記載されているタグのいずれも選択された表現のエンティティタグが一致しない場合、条件はfalseです。"
    },
    {
      "indent": 3,
      "text": "An origin server MUST NOT perform the requested method if a received If-Match condition evaluates to false; instead, the origin server MUST respond with either a) the 412 (Precondition Failed) status code or b) one of the 2xx (Successful) status codes if the origin server has verified that a state change is being requested and the final state is already reflected in the current state of the target resource (i.e., the change requested by the user agent has already succeeded, but the user agent might not be aware of it, perhaps because the prior response was lost or a compatible change was made by some other user agent). In the latter case, the origin server MUST NOT send a validator header field in the response unless it can verify that the request is a duplicate of an immediately prior change made by the same user agent.",
      "ja": "受け取った場合は、一致条件がfalseと評価された場合、オリジンサーバはリクエストされたメソッドを実行してはなりません。オリジンサーバは、状態変化が要求されていることが確認された最終的な状態がすでにある場合代わりに、オリジンサーバは、A）412（前提条件が失敗した）ステータスコードまたはb）の2xxの一方（成功）ステータスコードのいずれかで応答しなければなりませんターゲット・リソースの現在の状態に反映（すなわち、ユーザエージェントによって要求された変更は、すでに成功しているが、ユーザーエージェントは、それを認識していない可能性がありますおそらく、前の応答が失われたまたは互換性の変更は、いくつかの他によって作られたので、ユーザーエージェント）。その要求は、同じユーザエージェントによって行われた直前の変更の複製であることを確認できない限り、後者の場合、オリジンサーバは、応答してバリデータヘッダフィールドを送ってはいけません。"
    },
    {
      "indent": 3,
      "text": "The If-Match header field can be ignored by caches and intermediaries because it is not applicable to a stored response.",
      "ja": "それが格納された応答には適用されないため、If-Matchヘッダフィールドは、キャッシュや仲介によって無視することができます。"
    },
    {
      "indent": 0,
      "text": "3.2. If-None-Match",
      "section_title": true,
      "ja": "3.2. もし-なしマッチ"
    },
    {
      "indent": 3,
      "text": "The \"If-None-Match\" header field makes the request method conditional on a recipient cache or origin server either not having any current representation of the target resource, when the field-value is \"*\", or having a selected representation with an entity-tag that does not match any of those listed in the field-value.",
      "ja": "「IF-なしマッチ」ヘッダフィールドは、受信者キャッシュまたはオリジンサーバフィールドの値が「*」である場合、ターゲット・リソースの任意の現在の表現を有する、または有する選択された表現を持っていないのいずれかで、要求メソッドが条件になりフィールド値に列挙されているもののいずれにも一致しないエンティティタグ。"
    },
    {
      "indent": 3,
      "text": "A recipient MUST use the weak comparison function when comparing entity-tags for If-None-Match (Section 2.3.2), since weak entity-tags can be used for cache validation even if there have been changes to the representation data.",
      "ja": "もし-なしマッチ（2.3.2）のためのエンティティタグを比較するとき、弱いエンティティタグが表現データに変更があった場合でも、キャッシュの検証のために使用することができるので、受信者は、弱い比較関数を使わなければなりません。"
    },
    {
      "indent": 5,
      "text": "If-None-Match = \"*\" / 1#entity-tag",
      "ja": "もし-なしマッチ= \"*\" / 1＃エンティティタグ"
    },
    {
      "indent": 3,
      "text": "Examples:",
      "ja": "例："
    },
    {
      "indent": 5,
      "text": "If-None-Match: \"xyzzy\" If-None-Match: W/\"xyzzy\" If-None-Match: \"xyzzy\", \"r2d2xxxx\", \"c3piozzzz\" If-None-Match: W/\"xyzzy\", W/\"r2d2xxxx\", W/\"c3piozzzz\" If-None-Match: *",
      "ja": "もし-なし - マッチ：もし-なしマッチ \"XYZZY\"：Wもし-なしマッチ \"XYZZY\" /： \"XYZZY\"、 \"r2d2xxxx\"、 \"c3piozzzz\" IF-なし - マッチ： \"XYZZY\"、W / W / \"r2d2xxxx\"、W / \"c3piozzzz\" の場合 - なし - マッチ：*"
    },
    {
      "indent": 3,
      "text": "If-None-Match is primarily used in conditional GET requests to enable efficient updates of cached information with a minimum amount of transaction overhead. When a client desires to update one or more stored responses that have entity-tags, the client SHOULD generate an If-None-Match header field containing a list of those entity-tags when making a GET request; this allows recipient servers to send a 304 (Not Modified) response to indicate when one of those stored responses matches the selected representation.",
      "ja": "場合-なしマッチは、主に、最小のトランザクションオーバーヘッドでキャッシュされた情報の効率的な更新を可能にするために条件付きGETリクエストで使用されています。クライアントがエンティティタグを有する1つまたは複数の保存された応答を更新したい場合、クライアントはGETリクエストを行うときに、これらのエンティティタグのリストを含むIf-None-Matchヘッダフィールドを生成する必要があります。これは、受信者のサーバは、これらの保存された応答のいずれかが選択された表現に一致したときを示すために304（変更されていない）応答を送信することができます。"
    },
    {
      "indent": 3,
      "text": "If-None-Match can also be used with a value of \"*\" to prevent an unsafe request method (e.g., PUT) from inadvertently modifying an existing representation of the target resource when the client believes that the resource does not have a current representation (Section 4.2.1 of [RFC7231]). This is a variation on the \"lost update\" problem that might arise if more than one client attempts to create an initial representation for the target resource.",
      "ja": "なし - マッチした場合、また、危険な要求メソッドを防ぐために、「*」の値を使用することができ、クライアントはリソースが現在の表現を持っていないと考えていたときに、誤って対象リソースの既存の表現を修正するから（例えば、PUT） （[RFC7231]のセクション4.2.1）。これは、複数のクライアントがターゲット・リソースの初期表現を作成しようとした場合に発生する可能性のある「失われた更新」の問題のバリエーションです。"
    },
    {
      "indent": 3,
      "text": "An origin server that receives an If-None-Match header field MUST evaluate the condition prior to performing the method (Section 5). If the field-value is \"*\", the condition is false if the origin server has a current representation for the target resource. If the field-value is a list of entity-tags, the condition is false if one of the listed tags match the entity-tag of the selected representation.",
      "ja": "If-None-Matchヘッダフィールドを受信したオリジンサーバは、従来の方法（セクション5）を実行することに条件を評価しなければなりません。フィールド値が「*」であればオリジンサーバがターゲットリソースの現在の表現を持っている場合、条件はfalseです。フィールド値は、エンティティタグのリストがある場合は記載されているタグのいずれかが選択された表現のエンティティタグが一致した場合、条件はfalseです。"
    },
    {
      "indent": 3,
      "text": "An origin server MUST NOT perform the requested method if the condition evaluates to false; instead, the origin server MUST respond with either a) the 304 (Not Modified) status code if the request method is GET or HEAD or b) the 412 (Precondition Failed) status code for all other request methods.",
      "ja": "条件がfalseと評価された場合、オリジンサーバはリクエストされたメソッドを実行してはなりません。リクエストメソッドがGETまたはHEADまたは他のすべてのリクエストメソッドB）412（前提条件が失敗した）ステータスコードである場合代わりに、オリジンサーバは、A）304（変更されていません）ステータスコードのいずれかで応答しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Requirements on cache handling of a received If-None-Match header field are defined in Section 4.3.2 of [RFC7234].",
      "ja": "受信If-None-Matchヘッダフィールドのキャッシュ取り扱いに関する要件[RFC7234]のセクション4.3.2で定義されています。"
    },
    {
      "indent": 0,
      "text": "3.3. If-Modified-Since",
      "section_title": true,
      "ja": "3.3. 変更 - 開始"
    },
    {
      "indent": 3,
      "text": "The \"If-Modified-Since\" header field makes a GET or HEAD request method conditional on the selected representation's modification date being more recent than the date provided in the field-value. Transfer of the selected representation's data is avoided if that data has not changed.",
      "ja": "「修飾場合-ので」ヘッダフィールドは、選択された表現の変更日付フィールド値で、日付より新しいことでGETまたはHEADリクエストメソッドが条件となります。そのデータが変更されていない場合は、選択表現のデータの転送が回避されます。"
    },
    {
      "indent": 5,
      "text": "If-Modified-Since = HTTP-date",
      "ja": "変更 - 開始= HTTP-日"
    },
    {
      "indent": 3,
      "text": "An example of the field is:",
      "ja": "フィールドの例は次のとおりです。"
    },
    {
      "indent": 5,
      "text": "If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT",
      "ja": "変更 - 開始：土、1994年10月29日午後7時43分31秒GMT"
    },
    {
      "indent": 3,
      "text": "A recipient MUST ignore If-Modified-Since if the request contains an If-None-Match header field; the condition in If-None-Match is considered to be a more accurate replacement for the condition in If-Modified-Since, and the two are only combined for the sake of interoperating with older intermediaries that might not implement If-None-Match.",
      "ja": "要求がIf-None-Matchヘッダフィールドが含まれている場合、受信者が変更した場合-ので無視しなければなりません。もし-なしマッチで条件が変更 - 開始中状態のため、より正確な代替であるとみなされ、そして2は、場合にのみ、-なしマッチを実装していない可能性があります古い仲介との相互運用のために組み合わされています。"
    },
    {
      "indent": 3,
      "text": "A recipient MUST ignore the If-Modified-Since header field if the received field-value is not a valid HTTP-date, or if the request method is neither GET nor HEAD.",
      "ja": "受信電界値が有効なHTTP-日付でない場合、または要求メソッドがGETやHEADでもない場合、受信者は、もし修飾-のでヘッダーフィールドを無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "A recipient MUST interpret an If-Modified-Since field-value's timestamp in terms of the origin server's clock.",
      "ja": "受信者は、If-Modifiedの-ので、オリジンサーバの時計の面でフィールド値のタイムスタンプを解釈する必要があります。"
    },
    {
      "indent": 3,
      "text": "If-Modified-Since is typically used for two distinct purposes: 1) to allow efficient updates of a cached representation that does not have an entity-tag and 2) to limit the scope of a web traversal to resources that have recently changed.",
      "ja": "変更した場合-ので、典型的には二つの異なる目的のために使用される：1）エンティティタグと2を持っていないキャッシュされた表現の効率的な更新を可能にするために）、最近変更されたリソースへのウェブ・トラバーサルの範囲を限定します。"
    },
    {
      "indent": 3,
      "text": "When used for cache updates, a cache will typically use the value of the cached message's Last-Modified field to generate the field value of If-Modified-Since. This behavior is most interoperable for cases where clocks are poorly synchronized or when the server has chosen to only honor exact timestamp matches (due to a problem with Last-Modified dates that appear to go \"back in time\" when the origin server's clock is corrected or a representation is restored from an archived backup). However, caches occasionally generate the field value based on other data, such as the Date header field of the cached message or the local clock time that the message was received, particularly when the cached message does not contain a Last-Modified field.",
      "ja": "キャッシュの更新のために使用した場合、キャッシュは一般的に変更される場合は-以降のフィールドの値を生成するために、キャッシュされたメッセージの最終-Modifiedのフィールドの値を使用します。この動作は、サーバーがオリジンサーバの時計を補正する際にのみ起因する「時間に戻って」行くように見えるのLast-Modified日付での問題に（正確なタイムスタンプの一致を尊重することを選択した時にクロックが不十分同期したりする場合のために、ほとんどの相互運用が可能ですまたは表現）は、アーカイブ、バックアップから復元されます。しかし、キャッシュは時折、キャッシュされたメッセージは、最終変性フィールドが含まれていない場合は特に、そのようなキャッシュされたメッセージの日付ヘッダフィールドまたはメッセージが受信されたことローカルクロック時間のような他のデータに基づいてフィールド値を生成します。"
    },
    {
      "indent": 3,
      "text": "When used for limiting the scope of retrieval to a recent time window, a user agent will generate an If-Modified-Since field value based on either its own local clock or a Date header field received from the server in a prior response. Origin servers that choose an exact timestamp match based on the selected representation's Last-Modified field will not be able to help the user agent limit its data transfers to only those changed during the specified window.",
      "ja": "最近の時間ウィンドウに検索の範囲を制限するために使用されるとき、ユーザーエージェントが生成され、それ自身のローカルクロックまたは日付ヘッダーフィールドのいずれかに基づく場合変性-のでフィールドの値は、先行応答してサーバから受信しました。選択された表現ののLast-Modifiedフィールドに基づいて、正確なタイムスタンプの試合を選択オリジンサーバはユーザエージェントが指定したウィンドウ中に変更のみへのデータ転送を制限する手助けすることができません。"
    },
    {
      "indent": 3,
      "text": "An origin server that receives an If-Modified-Since header field SHOULD evaluate the condition prior to performing the method (Section 5). The origin server SHOULD NOT perform the requested method if the selected representation's last modification date is earlier than or equal to the date provided in the field-value; instead, the origin server SHOULD generate a 304 (Not Modified) response, including only those metadata that are useful for identifying or updating a previously cached response.",
      "ja": "受信したオリジンサーバもし修飾-のでヘッダフィールドは、方法（セクション5）を実行する前に条件を評価すべきです。選択された表現の最終更新日時はフィールド値で、日付より早いか等しい場合、オリジンサーバはリクエストされたメソッドを実行するべきではありません。代わりに、オリジンサーバは、以前にキャッシュされた応答を同定または更新するのに便利ですのみメタデータを含む304（未修正）応答を、生成する必要があります。"
    },
    {
      "indent": 3,
      "text": "Requirements on cache handling of a received If-Modified-Since header field are defined in Section 4.3.2 of [RFC7234].",
      "ja": "受信された変更した場合-ので、ヘッダフィールドのキャッシュハンドリング上の要件は、[RFC7234]のセクション4.3.2で定義されています。"
    },
    {
      "indent": 0,
      "text": "3.4. If-Unmodified-Since",
      "section_title": true,
      "ja": "3.4. もし、変更されていない、ので、"
    },
    {
      "indent": 3,
      "text": "The \"If-Unmodified-Since\" header field makes the request method conditional on the selected representation's last modification date being earlier than or equal to the date provided in the field-value. This field accomplishes the same purpose as If-Match for cases where the user agent does not have an entity-tag for the representation.",
      "ja": "「場合非改変-ので」ヘッダフィールドは、選択された表現の最終更新日時よりも早いか、フィールド値で、日付に等しい上の要求メソッドが条件となります。このフィールドは、ユーザーエージェントは表現のためのエンティティタグを持っていない場合のためであればマッチと同じ目的を達成します。"
    },
    {
      "indent": 5,
      "text": "If-Unmodified-Since = HTTP-date",
      "ja": "もし非改変-以来= HTTP-日"
    },
    {
      "indent": 3,
      "text": "An example of the field is:",
      "ja": "フィールドの例は次のとおりです。"
    },
    {
      "indent": 5,
      "text": "If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT",
      "ja": "もし非改変-以降：土、1994年10月29日午前19時43分31秒GMT"
    },
    {
      "indent": 3,
      "text": "A recipient MUST ignore If-Unmodified-Since if the request contains an If-Match header field; the condition in If-Match is considered to be a more accurate replacement for the condition in If-Unmodified-Since, and the two are only combined for the sake of interoperating with older intermediaries that might not implement If-Match.",
      "ja": "場合非改変-ので要求がIf-Matchヘッダフィールドが含まれている場合、受信者は無視しなければなりません。もしマッチでの条件があれば、変更されていない-以降で条件のより正確な代替であるとみなされ、そして2は、場合にのみマッチ実装しない可能性があります古い仲介との相互運用のために組み合わされています。"
    },
    {
      "indent": 3,
      "text": "A recipient MUST ignore the If-Unmodified-Since header field if the received field-value is not a valid HTTP-date.",
      "ja": "受信電界値が有効なHTTP-日付でない場合、受信者は、もし非改変-のでヘッダーフィールドを無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "A recipient MUST interpret an If-Unmodified-Since field-value's timestamp in terms of the origin server's clock.",
      "ja": "受信者は、オリジンサーバの時計の面であれば、変更されていない - ので、フィールド値のタイムスタンプを解釈する必要があります。"
    },
    {
      "indent": 3,
      "text": "If-Unmodified-Since is most often used with state-changing methods (e.g., POST, PUT, DELETE) to prevent accidental overwrites when multiple user agents might be acting in parallel on a resource that does not supply entity-tags with its representations (i.e., to prevent the \"lost update\" problem). It can also be used with safe methods to abort a request if the selected representation does not match one already stored (or partially stored) from a prior request.",
      "ja": "場合は、未修飾-以降は、ほとんどの場合、状態変更方法で使用された複数のユーザエージェントはその表現（とエンティティタグを供給しないリソース上で並列に動作するかもしれない時に不慮の上書きを防ぐために（例えば、POST、DELETE、PUT）すなわち、）「失われた更新」の問題を防ぐために。選択された表現は、一つ前のリクエストから既に記憶されている（または部分的に格納されている）と一致しない場合にも、要求を中止する安全な方法で使用することができます。"
    },
    {
      "indent": 3,
      "text": "An origin server that receives an If-Unmodified-Since header field MUST evaluate the condition prior to performing the method (Section 5). The origin server MUST NOT perform the requested method if the selected representation's last modification date is more recent than the date provided in the field-value; instead the origin server MUST respond with either a) the 412 (Precondition Failed) status code or b) one of the 2xx (Successful) status codes if the origin server has verified that a state change is being requested and the final state is already reflected in the current state of the target resource (i.e., the change requested by the user agent has already succeeded, but the user agent might not be aware of that because the prior response message was lost or a compatible change was made by some other user agent). In the latter case, the origin server MUST NOT send a validator header field in the response unless it can verify that the request is a duplicate of an immediately prior change made by the same user agent.",
      "ja": "もし非改変-のでヘッダーフィールドを受け取るオリジンサーバは、従来の方法（セクション5）を実行することに条件を評価しなければなりません。選択された表現の最終更新日時はフィールド値で、日付よりも新しい場合、オリジンサーバはリクエストされたメソッドを実行してはなりません。オリジンサーバは、状態変化が要求されていることが確認された最終的な状態が既に反映されている場合代わりに、オリジンサーバは、A）412（前提条件が失敗した）ステータスコードまたはb）の2xxの一方（成功）ステータスコードのいずれかで応答しなければなりませんターゲット・リソース（すなわち、現在の状態では、ユーザエージェントによって要求された変更は、すでに成功しているが、以前の応答メッセージが失われたまたは互換性のある変更がいくつかの他のユーザエージェントによって行われたため、ユーザーエージェントは、その認識していない可能性があります）。その要求は、同じユーザエージェントによって行われた直前の変更の複製であることを確認できない限り、後者の場合、オリジンサーバは、応答してバリデータヘッダフィールドを送ってはいけません。"
    },
    {
      "indent": 3,
      "text": "The If-Unmodified-Since header field can be ignored by caches and intermediaries because it is not applicable to a stored response.",
      "ja": "それが格納された応答には適用されないので、もし、未修飾-のでヘッダフィールドはキャッシュや仲介によって無視することができます。"
    },
    {
      "indent": 0,
      "text": "3.5. If-Range",
      "section_title": true,
      "ja": "3.5. もしレンジ"
    },
    {
      "indent": 3,
      "text": "The \"If-Range\" header field provides a special conditional request mechanism that is similar to the If-Match and If-Unmodified-Since header fields but that instructs the recipient to ignore the Range header field if the validator doesn't match, resulting in transfer of the new selected representation instead of a 412 (Precondition Failed) response. If-Range is defined in Section 3.2 of [RFC7233].",
      "ja": "「IFレンジ」ヘッダフィールドは、もしマッチしてIF非改変-のでヘッダーフィールドに類似しているが、それは、その結果、バリデータが一致しない場合Rangeヘッダフィールドを無視するように受信者に指示する特殊な条件要求メカニズムを提供します代わりに412（前提条件が失敗した）応答の新たな選択表現の転送です。場合は、範囲は[RFC7233]のセクション3.2で定義されています。"
    },
    {
      "indent": 0,
      "text": "4. Status Code Definitions",
      "section_title": true,
      "ja": "4.ステータスコードの定義"
    },
    {
      "indent": 0,
      "text": "4.1. 304 Not Modified",
      "section_title": true,
      "ja": "4.1.  304は変更されません"
    },
    {
      "indent": 3,
      "text": "The 304 (Not Modified) status code indicates that a conditional GET or HEAD request has been received and would have resulted in a 200 (OK) response if it were not for the fact that the condition evaluated to false. In other words, there is no need for the server to transfer a representation of the target resource because the request indicates that the client, which made the request conditional, already has a valid representation; the server is therefore redirecting the client to make use of that stored representation as if it were the payload of a 200 (OK) response.",
      "ja": "304（変更不可）ステータスコードが条件付きGETやHEADリクエストを受信して​​いると、それは条件がfalseに評価されているという事実がなければ200（OK）応答をもたらしたであろうことを示しています。言い換えれば、要求は、要求条件製クライアントは、すでに有効な表現を持っていることを示しているため、サーバーはターゲット・リソースの表現を転送するための必要はありません。サーバーは、したがって、それは200（OK）応答のペイロードであるかのように、その保存された表現を使用するようにクライアントをリダイレクトしています。"
    },
    {
      "indent": 3,
      "text": "The server generating a 304 response MUST generate any of the following header fields that would have been sent in a 200 (OK) response to the same request: Cache-Control, Content-Location, Date, ETag, Expires, and Vary.",
      "ja": "キャッシュ・コントロール、コンテンツの場所、日付、ETagの有効期限、およびヴァリ：304応答を生成するサーバは、同一の要求に200（OK）応答で送信されたであろう次のヘッダフィールドのいずれかを生成しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Since the goal of a 304 response is to minimize information transfer when the recipient already has one or more cached representations, a sender SHOULD NOT generate representation metadata other than the above listed fields unless said metadata exists for the purpose of guiding cache updates (e.g., Last-Modified might be useful if the response does not have an ETag field).",
      "ja": "304応答の目標は、受信者がすでに1つ以上のキャッシュされた表現がある場合の情報伝達を最小限にすることであるので、メタデータがキャッシュの更新を案内する目的のために存在していると述べていない限り、送信者が（上記のフィールド以外の表現のメタデータを生成するべきではありません例えば、レスポンスがETagのフィールドを持っていない場合のLast-Modified）が便利かもしれません。"
    },
    {
      "indent": 3,
      "text": "Requirements on a cache that receives a 304 response are defined in Section 4.3.4 of [RFC7234]. If the conditional request originated with an outbound client, such as a user agent with its own cache sending a conditional GET to a shared proxy, then the proxy SHOULD forward the 304 response to that client.",
      "ja": "304レスポンスを受信したキャッシュ上の要件は、[RFC7234]のセクション4.3.4で定義されています。条件付きの要求は、アウトバウンドのクライアントで発信された場合は、そのような独自のキャッシュが共有プロキシに条件付きGETを送信すると、ユーザーエージェントとして、プロキシはそのクライアントに304レスポンスを転送する必要があります。"
    },
    {
      "indent": 3,
      "text": "A 304 response cannot contain a message-body; it is always terminated by the first empty line after the header fields.",
      "ja": "304応答は、メッセージボディを含むことはできません。それは、常にヘッダフィールドの後の最初の空行で終了します。"
    },
    {
      "indent": 0,
      "text": "4.2. 412 Precondition Failed",
      "section_title": true,
      "ja": "4.2.  412前提条件の失敗"
    },
    {
      "indent": 3,
      "text": "The 412 (Precondition Failed) status code indicates that one or more conditions given in the request header fields evaluated to false when tested on the server. This response code allows the client to place preconditions on the current resource state (its current representations and metadata) and, thus, prevent the request method from being applied if the target resource is in an unexpected state.",
      "ja": "412（前提条件が失敗した）ステータスコードは、サーバ上で試験した場合に1つ以上の条件が偽と評価リクエストヘッダフィールドで与えられることを示しています。この応答コードは、クライアントが現在のリソース状態に前提条件を置いて（現在の表現とメタデータ）と、ターゲットリソースが予期しない状態にある場合、したがって、印加される要求方式を防止することを可能にします。"
    },
    {
      "indent": 0,
      "text": "5. Evaluation",
      "section_title": true,
      "ja": "5.評価"
    },
    {
      "indent": 3,
      "text": "Except when excluded below, a recipient cache or origin server MUST evaluate received request preconditions after it has successfully performed its normal request checks and just before it would perform the action associated with the request method. A server MUST ignore all received preconditions if its response to the same request without those conditions would have been a status code other than a 2xx (Successful) or 412 (Precondition Failed). In other words, redirects and failures take precedence over the evaluation of preconditions in conditional requests.",
      "ja": "以下の除外場合を除き、それは成功し、通常のリクエストの確認を行っており、それは、リクエストメソッドに関連付けられたアクションを実行することになり直前の後に、受信者キャッシュやオリジンサーバは、受信した要求の前提条件を評価しなければなりません。これらの条件なしの同じ要求に対する応答が（成功）または412（前提条件が失敗）の2xx以外のステータスコードされているならば、サーバは、受信したすべての前提条件を無視しなければなりません。言い換えると、リダイレクトされ、障害が条件付きリクエストで前提条件の評価よりも優先されます。"
    },
    {
      "indent": 3,
      "text": "A server that is not the origin server for the target resource and cannot act as a cache for requests on the target resource MUST NOT evaluate the conditional request header fields defined by this specification, and it MUST forward them if the request is forwarded, since the generating client intends that they be evaluated by a server that can provide a current representation. Likewise, a server MUST ignore the conditional request header fields defined by this specification when received with a request method that does not involve the selection or modification of a selected representation, such as CONNECT, OPTIONS, or TRACE.",
      "ja": "ターゲット・リソースのオリジンサーバではなく、ターゲット・リソースへの要求のためのキャッシュとして機能することはできませんサーバーは、この仕様で定義された条件付きリクエストヘッダフィールドを評価してはならない、との要求が転送されている場合には、以来、それらを転送しなければなりません。クライアントを生成する、彼らは現在の表現を提供することができ、サーバーによって評価されることを意図しています。同様に、サーバは、CONNECT、OPTIONS、またはTRACEとして、選択された表現の選択または変更を伴わない要求方式で受信すると、この仕様で定義された条件付リクエストヘッダフィールドを無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Conditional request header fields that are defined by extensions to HTTP might place conditions on all recipients, on the state of the target resource in general, or on a group of resources. For instance, the \"If\" header field in WebDAV can make a request conditional on various aspects of multiple resources, such as locks, if the recipient understands and implements that field ([RFC4918], Section 10.4).",
      "ja": "HTTPの拡張で定義されている条件付きリクエストヘッダフィールドは、一般的にターゲットリソースの状態に、またはリソースのグループに、すべての受信者に条件を置くかもしれません。受信者が理解し、そのフィールド（[RFC4918]、セクション10.4）を実装している場合、例えば、WebDAVので「IF」ヘッダフィールドは、ロックなど、複数のリソースの様々な側面、上の要求を条件付きにすることができます。"
    },
    {
      "indent": 3,
      "text": "Although conditional request header fields are defined as being usable with the HEAD method (to keep HEAD's semantics consistent with those of GET), there is no point in sending a conditional HEAD because a successful response is around the same size as a 304 (Not Modified) response and more useful than a 412 (Precondition Failed) response.",
      "ja": "条件付リクエストヘッダフィールドは（GETのものと一致HEADのセマンティクスを維持するために）HEADメソッドで利用可能であると定義されているが成功した応答を修正しません304と同じサイズ（周囲にあるため、条件付きの頭部を送信しても意味がありません）応答及び412（前提条件が失敗した）応答よりも有用。"
    },
    {
      "indent": 0,
      "text": "6. Precedence",
      "section_title": true,
      "ja": "6.優先順位"
    },
    {
      "indent": 3,
      "text": "When more than one conditional request header field is present in a request, the order in which the fields are evaluated becomes important. In practice, the fields defined in this document are consistently implemented in a single, logical order, since \"lost update\" preconditions have more strict requirements than cache validation, a validated cache is more efficient than a partial response, and entity tags are presumed to be more accurate than date validators.",
      "ja": "複数の条件付きのリクエストヘッダフィールドがリクエスト中に存在する場合、フィールドが評価される順序が重要となります。実際には、この文書で定義されたフィールドは、一貫して「失われた更新」の前提条件は、キャッシュの検証よりも厳格な要件を持っているので、検証済みのキャッシュはパーシャルレスポンスよりも効率的であり、エンティティタグがあると推定され、単一の論理的な順序で実装されています日付バリデータよりも正確です。"
    },
    {
      "indent": 3,
      "text": "A recipient cache or origin server MUST evaluate the request preconditions defined by this specification in the following order:",
      "ja": "受信者キャッシュやオリジンサーバは、次の順序で、この仕様で定義された要求の前提条件を評価する必要があります："
    },
    {
      "indent": 3,
      "text": "1. When recipient is the origin server and If-Match is present, evaluate the If-Match precondition:",
      "ja": "1.受信者がオリジンサーバであるとマッチした場合、存在している、もしマッチ前提条件を評価します："
    },
    {
      "indent": 7,
      "text": "* if true, continue to step 3",
      "ja": "* trueの場合は、手順3に進み"
    },
    {
      "indent": 7,
      "text": "* if false, respond 412 (Precondition Failed) unless it can be determined that the state-changing request has already succeeded (see Section 3.1)",
      "ja": "状態変更要求が既に成功したと判断することができない限り、* falseの場合、412（前提条件が失敗した）対応（3.1節を参照してください）"
    },
    {
      "indent": 3,
      "text": "2. When recipient is the origin server, If-Match is not present, and If-Unmodified-Since is present, evaluate the If-Unmodified-Since precondition:",
      "ja": "：マッチした場合、存在しない場合、および非改変-ので、もし非改変-ので、前提条件を評価し、存在している受信者は、オリジンサーバである2。"
    },
    {
      "indent": 7,
      "text": "* if true, continue to step 3",
      "ja": "* trueの場合は、手順3に進み"
    },
    {
      "indent": 7,
      "text": "* if false, respond 412 (Precondition Failed) unless it can be determined that the state-changing request has already succeeded (see Section 3.4)",
      "ja": "状態変更要求が既に成功したと判断することができない限り、* falseの場合、412（前提条件が失敗した）対応（3.4節を参照してください）"
    },
    {
      "indent": 3,
      "text": "3. When If-None-Match is present, evaluate the If-None-Match precondition:",
      "ja": "なし - マッチした場合、存在している、もし-なし - マッチ前提条件を評価する3："
    },
    {
      "indent": 7,
      "text": "* if true, continue to step 5",
      "ja": "* trueの場合は、5に進み"
    },
    {
      "indent": 7,
      "text": "* if false for GET/HEAD, respond 304 (Not Modified)",
      "ja": "* GET / HEADためのfalseの場合、対応304（変更されません）"
    },
    {
      "indent": 7,
      "text": "* if false for other methods, respond 412 (Precondition Failed)",
      "ja": "*他のメソッドのためのfalseの場合、412（前提条件に失敗しました）が応答します"
    },
    {
      "indent": 3,
      "text": "4. When the method is GET or HEAD, If-None-Match is not present, and If-Modified-Since is present, evaluate the If-Modified-Since precondition:",
      "ja": "4.メソッドがGETまたはHEADである場合には、もし-なしマッチは存在せず、存在する場合は、変更 - 開始、場合 - 変更-ので前提条件の評価します："
    },
    {
      "indent": 7,
      "text": "* if true, continue to step 5",
      "ja": "* trueの場合は、5に進み"
    },
    {
      "indent": 7,
      "text": "* if false, respond 304 (Not Modified)",
      "ja": "* falseの場合、対応304（変更されません）"
    },
    {
      "indent": 3,
      "text": "5. When the method is GET and both Range and If-Range are present, evaluate the If-Range precondition:",
      "ja": "5.方法はレンジとレンジが存在している場合は、もしレンジの前提条件を評価し、両方をGETする場合："
    },
    {
      "indent": 7,
      "text": "*  if the validator matches and the Range specification is\n   applicable to the selected representation, respond 206\n   (Partial Content) [RFC7233]",
      "raw": true
    },
    {
      "indent": 3,
      "text": "6. Otherwise,",
      "section_title": true,
      "ja": "6.それ以外の場合は、"
    },
    {
      "indent": 7,
      "text": "*  all conditions are met, so perform the requested action and\n   respond according to its success or failure.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Any extension to HTTP/1.1 that defines additional conditional request header fields ought to define its own expectations regarding the order for evaluating such fields in relation to those defined in this document and other conditionals that might be found in practice.",
      "ja": "追加の条件付きのリクエストヘッダフィールドを定義するHTTP / 1.1に任意の拡張子が実際に見出され得る、この文書およびその他の条件式で定義されたものに関連してそのようなフィールドを評価するための順序に関する独自の期待を定義するべきです。"
    },
    {
      "indent": 0,
      "text": "7. IANA Considerations",
      "section_title": true,
      "ja": "7. IANAの考慮事項"
    },
    {
      "indent": 0,
      "text": "7.1. Status Code Registration",
      "section_title": true,
      "ja": "7.1. ステータスコード登録"
    },
    {
      "indent": 3,
      "text": "The \"Hypertext Transfer Protocol (HTTP) Status Code Registry\" located at <http://www.iana.org/assignments/http-status-codes> has been updated with the registrations below:",
      "ja": "ある「ハイパーテキスト転送プロトコル（HTTP）ステータスコードレジストリ」<http://www.iana.org/assignments/http-status-codes>下記の登録で更新されました："
    },
    {
      "indent": 3,
      "text": "+-------+---------------------+-------------+\n| Value | Description         | Reference   |\n+-------+---------------------+-------------+\n| 304   | Not Modified        | Section 4.1 |\n| 412   | Precondition Failed | Section 4.2 |\n+-------+---------------------+-------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.2. Header Field Registration",
      "section_title": true,
      "ja": "7.2. ヘッダーフィールドの登録"
    },
    {
      "indent": 3,
      "text": "HTTP header fields are registered within the \"Message Headers\" registry maintained at <http://www.iana.org/assignments/message-headers/>.",
      "ja": "HTTPヘッダフィールドは、<http://www.iana.org/assignments/message-headers/>に維持「メッセージヘッダ」レジストリ内に登録されています。"
    },
    {
      "indent": 3,
      "text": "This document defines the following HTTP header fields, so their associated registry entries have been updated according to the permanent registrations below (see [BCP90]):",
      "ja": "（[BCP90]参照）、以下に永久登録に応じて、この文書は、次のHTTPヘッダーフィールドを定義するので、それらに関連するレジストリエントリが更新されました。"
    },
    {
      "indent": 3,
      "text": "+---------------------+----------+----------+-------------+\n| Header Field Name   | Protocol | Status   | Reference   |\n+---------------------+----------+----------+-------------+\n| ETag                | http     | standard | Section 2.3 |\n| If-Match            | http     | standard | Section 3.1 |\n| If-Modified-Since   | http     | standard | Section 3.3 |\n| If-None-Match       | http     | standard | Section 3.2 |\n| If-Unmodified-Since | http     | standard | Section 3.4 |\n| Last-Modified       | http     | standard | Section 2.2 |\n+---------------------+----------+----------+-------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The change controller is: \"IETF (iesg@ietf.org) - Internet Engineering Task Force\".",
      "ja": "変更コントローラは次のとおりです。「IETF（iesg@ietf.org） - インターネットエンジニアリングタスクフォース」。"
    },
    {
      "indent": 0,
      "text": "8. Security Considerations",
      "section_title": true,
      "ja": "8.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "This section is meant to inform developers, information providers, and users of known security concerns specific to the HTTP conditional request mechanisms. More general security considerations are addressed in HTTP \"Message Syntax and Routing\" [RFC7230] and \"Semantics and Content\" [RFC7231].",
      "ja": "このセクションでは、開発者、情報提供者、およびHTTPリクエスト条件付きメカニズムに固有の既知のセキュリティ上の懸念のユーザーに通知するものとします。より一般的なセキュリティ上の考慮事項は、「メッセージ構文とルーティング」[RFC7230]および「セマンティクスおよびコンテンツ」[RFC7231] HTTPで対処されています。"
    },
    {
      "indent": 3,
      "text": "The validators defined by this specification are not intended to ensure the validity of a representation, guard against malicious changes, or detect man-in-the-middle attacks. At best, they enable more efficient cache updates and optimistic concurrent writes when all participants are behaving nicely. At worst, the conditions will fail and the client will receive a response that is no more harmful than an HTTP exchange without conditional requests.",
      "ja": "この仕様で定義されたバリデータは、表現の妥当性を確保するため、悪質な変更を防ぐ、またはman-in-the-middle攻撃を検出するためのものではありません。すべての参加者がうまく動作しているとき最高で、彼らはより効率的なキャッシュの更新と楽観的同時書き込みを可能にします。最悪の場合、条件が失敗し、クライアントはこれ以上の有害な条件を要求せずにHTTP交換よりもレスポンスを受信します。"
    },
    {
      "indent": 3,
      "text": "An entity-tag can be abused in ways that create privacy risks. For example, a site might deliberately construct a semantically invalid entity-tag that is unique to the user or user agent, send it in a cacheable response with a long freshness time, and then read that entity-tag in later conditional requests as a means of re-identifying that user or user agent. Such an identifying tag would become a persistent identifier for as long as the user agent retained the original cache entry. User agents that cache representations ought to ensure that the cache is cleared or replaced whenever the user performs privacy-maintaining actions, such as clearing stored cookies or changing to a private browsing mode.",
      "ja": "エンティティタグは、プライバシー上のリスクを作成する方法で悪用される可能性が。たとえば、サイトが故意に、ユーザーまたはユーザーエージェントに固有の意味的に無効なエンティティタグを構築する可能性がある長い鮮度時間でキャッシュ可能な応答でそれを送信し、その後の手段として、後に条件付きの要求でそのエンティティタグを読んでユーザーまたはユーザーエージェントを再特定します。そのような識別タグであれば、ユーザエージェントは、元のキャッシュエントリを保持するようにするための永続的な識別子となります。表現をキャッシュするユーザーエージェントは、ユーザーがそのような保存されたCookieをクリアするか、プライベートブラウジングモードに変更するなど、プライバシー維持アクションを実行するたびにキャッシュがクリアまたは交換されていることを確認するべきです。"
    },
    {
      "indent": 0,
      "text": "9. Acknowledgments",
      "section_title": true,
      "ja": "9.謝辞"
    },
    {
      "indent": 3,
      "text": "See Section 10 of [RFC7230].",
      "ja": "[RFC7230]のセクション10を参照してください。"
    },
    {
      "indent": 0,
      "text": "10. References",
      "section_title": true,
      "ja": "10.参考文献"
    },
    {
      "indent": 0,
      "text": "10.1. Normative References",
      "section_title": true,
      "ja": "10.1. 引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC5234] Crocker, D., Ed. and P. Overell, \"Augmented BNF for Syntax Specifications: ABNF\", STD 68, RFC 5234, January 2008.",
      "ja": "[RFC5234]クロッカー、D.、エド。そして、P. Overell、 \"構文仕様のための増大しているBNF：ABNF\"、STD 68、RFC 5234、2008年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC7230] Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing\", RFC 7230, June 2014.",
      "ja": "[RFC7230]フィールディング、R.、エド。 。とJ. Reschke、エド、 \"ハイパーテキスト転送プロトコル（HTTP / 1.1）：メッセージの構文とルーティング\"、RFC 7230、2014年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC7231] Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content\", RFC 7231, June 2014.",
      "ja": "[RFC7231]フィールディング、R.、エド。そして、J. Reschke、エド、 \"ハイパーテキスト転送プロトコル（HTTP / 1.1）：セマンティクスおよびコンテンツ\"、RFC 7231、2014年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC7233] Fielding, R., Ed., Lafon, Y., Ed., and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Range Requests\", RFC 7233, June 2014.",
      "ja": "[RFC7233]フィールディング、R.、エド、ラフォン、Y.、エド、及びJ. Reschke、編、 \"ハイパーテキスト転送プロトコル（HTTP / 1.1）：範囲要求\"。。。、RFC 7233、2014年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC7234] Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Caching\", RFC 7234, June 2014.",
      "ja": "[RFC7234]フィールディング、R.、エド、ノッティンガム、M.、エド、及びJ. Reschke、編、 \"ハイパーテキスト転送プロトコル（HTTP / 1.1）：キャッシュ\"。。。、RFC 7234、2014年6月。"
    },
    {
      "indent": 0,
      "text": "10.2. Informative References",
      "section_title": true,
      "ja": "10.2. 参考文献"
    },
    {
      "indent": 3,
      "text": "[BCP90] Klyne, G., Nottingham, M., and J. Mogul, \"Registration Procedures for Message Header Fields\", BCP 90, RFC 3864, September 2004.",
      "ja": "[BCP90] Klyne、G.、ノッティンガム、M.、およびJ.モーグル、 \"メッセージヘッダフィールドの登録手順\"、BCP 90、RFC 3864、2004年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC2616] Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P., and T. Berners-Lee, \"Hypertext Transfer Protocol -- HTTP/1.1\", RFC 2616, June 1999.",
      "ja": "[RFC2616]フィールディング、R.、ゲティス、J.、モーグル、J.、Frystyk、H.、Masinter、L.、リーチ、P.、およびT.バーナーズ - リー、 \"ハイパーテキスト転送プロトコル -  HTTP / 1.1\" 、RFC 2616、1999年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC4918] Dusseault, L., Ed., \"HTTP Extensions for Web Distributed Authoring and Versioning (WebDAV)\", RFC 4918, June 2007.",
      "ja": "[RFC4918] Dusseault、L.、エド。、RFC 4918、2007年6月 \"Web分散オーサリングとバージョン管理（WebDAV）のためのHTTP拡張機能\"。"
    },
    {
      "indent": 1,
      "text": "Appendix A. Changes from",
      "ja": "付録A.からの変更点"
    },
    {
      "indent": 3,
      "text": "The definition of validator weakness has been expanded and clarified. (Section 2.1)",
      "ja": "バリの弱さの定義が拡大し、明らかにされています。 （2.1節）"
    },
    {
      "indent": 3,
      "text": "Weak entity-tags are now allowed in all requests except range requests. (Sections 2.1 and 3.2)",
      "ja": "弱いエンティティタグは、現在範囲要求を除くすべての要求に許可されています。 （セクション2.1および3.2）"
    },
    {
      "indent": 3,
      "text": "The ETag header field ABNF has been changed to not use quoted-string, thus avoiding escaping issues. (Section 2.3)",
      "ja": "ETagヘッダフィールドのABNFは、このようにエスケープ問題を回避、引用符で囲まれた文字列を使用しないように変更されました。 （2.3節）"
    },
    {
      "indent": 3,
      "text": "ETag is defined to provide an entity tag for the selected representation, thereby clarifying what it applies to in various situations (such as a PUT response). (Section 2.3)",
      "ja": "ETagは、それによって（例えばPUT応答として）、様々な状況でに適用されるものを明確に、選択された表現のためのエンティティタグを提供するために定義されています。 （2.3節）"
    },
    {
      "indent": 3,
      "text": "The precedence for evaluation of conditional requests has been defined. (Section 6)",
      "ja": "条件付きリクエストの評価のための優先順位が定義されています。 （セクション6）"
    },
    {
      "indent": 0,
      "text": "Appendix B. Imported ABNF",
      "ja": "付録B.インポートABNF"
    },
    {
      "indent": 3,
      "text": "The following core rules are included by reference, as defined in Appendix B.1 of [RFC5234]: ALPHA (letters), CR (carriage return), CRLF (CR LF), CTL (controls), DIGIT (decimal 0-9), DQUOTE (double quote), HEXDIG (hexadecimal 0-9/A-F/a-f), LF (line feed), OCTET (any 8-bit sequence of data), SP (space), and VCHAR (any visible US-ASCII character).",
      "ja": "[RFC5234]の付録B.1で定義されるように以下のコアルールは、参照することにより含まれる：ALPHA（文字）、CR（キャリッジリターン）、CRLF（CR LF）、CTL（コントロール）、数字（小数0-9） 、DQUOTE（二重引用符）、HEXDIG（16進数0-9 / AF / AF）、LF（ラインフィード）、OCTET（データの8ビットシーケンス）、SP（空間）、及びVCHAR（目に見えるUS-ASCII文字）。"
    },
    {
      "indent": 3,
      "text": "The rules below are defined in [RFC7230]:",
      "ja": "以下[RFC7230]で定義されたルール。"
    },
    {
      "indent": 5,
      "text": "OWS = <OWS, see [RFC7230], Section 3.2.3> obs-text = <obs-text, see [RFC7230], Section 3.2.6>",
      "ja": "OWS = <OWS、参照[RFC7230]、セクション3.2.3> OBSテキスト= <OBSテキスト、[RFC7230]を参照して、セクション3.2.6>"
    },
    {
      "indent": 3,
      "text": "The rules below are defined in other parts:",
      "ja": "以下の規則は、他の部分で定義されています。"
    },
    {
      "indent": 5,
      "text": "HTTP-date = <HTTP-date, see [RFC7231], Section 7.1.1.1>",
      "ja": "HTTP-日付= <HTTP-日付、[RFC7231]、セクション7.1.1.1を参照してください>"
    },
    {
      "indent": 0,
      "text": "Appendix C. Collected ABNF",
      "ja": "付録C.はABNFを収集しました"
    },
    {
      "indent": 3,
      "text": "In the collected ABNF below, list rules are expanded as per Section 1.2 of [RFC7230].",
      "ja": "以下収集ABNFにおいて、リストルールは、[RFC7230]のセクション1.2に従って展開されます。"
    },
    {
      "indent": 3,
      "text": "ETag = entity-tag",
      "ja": "ETag =エンティティタグ"
    },
    {
      "indent": 3,
      "text": "HTTP-date = <HTTP-date, see [RFC7231], Section 7.1.1.1>",
      "ja": "HTTP-日付= <HTTP-日付、[RFC7231]、セクション7.1.1.1を参照してください>"
    },
    {
      "indent": 3,
      "text": "If-Match = \"*\" / ( *( \",\" OWS ) entity-tag *( OWS \",\" [ OWS entity-tag ] ) ) If-Modified-Since = HTTP-date If-None-Match = \"*\" / ( *( \",\" OWS ) entity-tag *( OWS \",\" [ OWS entity-tag ] ) ) If-Unmodified-Since = HTTP-date",
      "ja": "もしマッチ= \"*\" /（*（ \"\" OWS）エンティティタグ*（OWS \"\" [OWSエンティティタグ]））変更した場合-ので= HTTP-日付IF-なしマッチ=「* \"/（*（\"、 \"OWS）エンティティタグ*（OWS\"、」[OWSエンティティタグ]））もし非改変-ので= HTTP-日付"
    },
    {
      "indent": 3,
      "text": "Last-Modified = HTTP-date",
      "ja": "= HTTP-日のLast-Modified"
    },
    {
      "indent": 3,
      "text": "OWS = <OWS, see [RFC7230], Section 3.2.3>",
      "ja": "OWS = <OWS、[RFC7230]を見てください、セクション3.2.3>"
    },
    {
      "indent": 3,
      "text": "entity-tag = [ weak ] opaque-tag etagc = \"!\" / %x23-7E ; '#'-'~' / obs-text",
      "ja": "エンティティタグ= [弱い]不透明なタグetagc =「！」 /％x23-7E。 '＃'  -  '〜' / OBSテキスト"
    },
    {
      "indent": 3,
      "text": "obs-text = <obs-text, see [RFC7230], Section 3.2.6> opaque-tag = DQUOTE *etagc DQUOTE",
      "ja": "OBS-テキスト= <OBS-テキスト、[RFC7230]を見てください、セクション3.2.6>不透明なタグ= DQUOTE * etagc DQUOTE"
    },
    {
      "indent": 3,
      "text": "weak = %x57.2F ; W/",
      "ja": "=％Kschh.ovウェイク。および/"
    },
    {
      "indent": 0,
      "text": "Index",
      "ja": "指数"
    },
    {
      "indent": 3,
      "text": "3 304 Not Modified (status code) 19",
      "ja": "3 304修飾されていない（ステータスコード）19"
    },
    {
      "indent": 3,
      "text": "4 412 Precondition Failed (status code) 18",
      "ja": "4 412前提条件失敗（状態コード）18"
    },
    {
      "indent": 3,
      "text": "E ETag header field 9",
      "ja": "E ETagヘッダフィールド9"
    },
    {
      "indent": 3,
      "text": "G Grammar entity-tag 9 ETag 9 etagc 9 If-Match 13 If-Modified-Since 15 If-None-Match 14 If-Unmodified-Since 17 Last-Modified 7 opaque-tag 9 weak 9",
      "ja": "G文法エンティティタグ9のETag 9 etagc 9もしマッチ13変更した場合-ので15であれば、なしマッチ14の場合、未修飾-以来17最終変性7不透明タグ9弱い9"
    },
    {
      "indent": 3,
      "text": "I If-Match header field 13 If-Modified-Since header field 16 If-None-Match header field 14 If-Unmodified-Since header field 17",
      "ja": "Iもしマッチヘッダフィールド13変更した場合-ので、ヘッダフィールド16の場合、なしマッチヘッダフィールド14の場合、未修飾-ので、ヘッダフィールド17"
    },
    {
      "indent": 3,
      "text": "L Last-Modified header field 7",
      "ja": "L最終-Modifiedヘッダフィールド7"
    },
    {
      "indent": 3,
      "text": "M metadata 5",
      "ja": "Mメタデータ5"
    },
    {
      "indent": 3,
      "text": "S selected representation 4",
      "ja": "S選択表現4"
    },
    {
      "indent": 3,
      "text": "V validator 5 strong 5 weak 5",
      "ja": "Vのバリ5強い5弱い5"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Roy T. Fielding (editor) Adobe Systems Incorporated 345 Park Ave San Jose, CA 95110 USA",
      "ja": "ロイT.フィールディング（編集者）Adobe Systems Incorporated（アドビシステムズ社）345パークアベニューサンノゼ、CA 95110 USA"
    },
    {
      "indent": 3,
      "text": "EMail: fielding@gbiv.com URI: http://roy.gbiv.com/",
      "ja": "電子メール：fielding@gbiv.com URI：http://roy.gbiv.com/"
    },
    {
      "indent": 3,
      "text": "Julian F. Reschke (editor) greenbytes GmbH Hafenweg 16 Muenster, NW 48155 Germany",
      "ja": "ジュリアンF. Reschke（エディタ）greenbytes社Hafenweg 16ミュンスター、NW 48155ドイツ"
    },
    {
      "indent": 3,
      "text": "EMail: julian.reschke@greenbytes.de URI: http://greenbytes.de/tech/webdav/",
      "ja": "電子メール：julian.reschke@greenbytes.de URI：http://greenbytes.de/tech/webdav/"
    }
  ]
}