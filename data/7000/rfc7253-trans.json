{
  "title": {
    "text": "RFC 7253 - The OCB Authenticated-Encryption Algorithm",
    "ja": "RFC 7253 - OCB認証、暗号化アルゴリズム"
  },
  "number": 7253,
  "created_at": "2019-10-30 19:19:07.689102+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Research Task Force (IRTF)                           T. Krovetz\nRequest for Comments: 7253                              Sacramento State\nCategory: Informational                                       P. Rogaway\nISSN: 2070-1721                                                 UC Davis\n                                                                May 2014",
      "raw": true
    },
    {
      "indent": 15,
      "text": "The OCB Authenticated-Encryption Algorithm",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document specifies OCB, a shared-key blockcipher-based encryption scheme that provides confidentiality and authenticity for plaintexts and authenticity for associated data. This document is a product of the Crypto Forum Research Group (CFRG).",
      "ja": "この文書では、OCB、関連するデータの機密性と平文のための真正性と信頼性を提供する共有鍵ブロック暗号ベースの暗号化方式を指定します。この文書では、暗号化フォーラム研究グループ（CFRG）の製品です。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "ja": "このドキュメントはインターネット標準化過程仕様ではありません。それは、情報提供の目的のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Research Task Force (IRTF). The IRTF publishes the results of Internet-related research and development activities. These results might not be suitable for deployment. This RFC represents the consensus of the Crypto Forum Research Group of the Internet Research Task Force (IRTF). Documents approved for publication by the IRSG are not a candidate for any level of Internet Standard; see Section 2 of RFC 5741.",
      "ja": "この文書はインターネットResearch Task Force（IRTF）の製品です。 IRTFはインターネット関連の研究開発活動の成果を公表しています。これらの結果は、展開に適していない可能性があります。このRFCはインターネットResearch Task Force（IRTF）の暗号化フォーラム研究グループのコンセンサスを表しています。 IRSGによって公表のために承認されたドキュメントは、インターネット標準の任意のレベルの候補ではありません。 RFC 5741のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7253.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7253で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2014 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2014 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................2\n2. Notation and Basic Operations ...................................4\n3. OCB Global Parameters ...........................................5\n   3.1. Named OCB Parameter Sets and RFC 5116 Constants ............6\n4. OCB Algorithms ..................................................6\n   4.1. Processing Associated Data: HASH ...........................6\n   4.2. Encryption: OCB-ENCRYPT ....................................8\n   4.3. Decryption: OCB-DECRYPT ....................................9\n5. Security Considerations ........................................11\n   5.1. Nonce Requirements ........................................12\n6. IANA Considerations ............................................13\n7. Acknowledgements ...............................................13\n8. References .....................................................14\n   8.1. Normative References ......................................14\n   8.2. Informative References ....................................14\nAppendix A.  Sample Results .......................................15",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "Schemes for authenticated encryption (AE) simultaneously provide for confidentiality and authentication. While this goal would traditionally be achieved by melding separate encryption and authentication mechanisms, each using its own key, integrated AE schemes intertwine what is needed for confidentiality and what is needed for authenticity. By conceptualizing AE as a single cryptographic goal, AE schemes are less likely to be misused than conventional encryption schemes. Also, integrated AE schemes can be significantly faster than what one sees from composing separate confidentiality and authenticity means.",
      "ja": "認証された暗号化（AE）のためのスキームを同時に機密性と認証を提供します。この目標は、伝統的に、独自のキーを使用して、それぞれの、別々の暗号化および認証メカニズムをmeldingによって達成されるであろうが、統合されたAE方式は、機密性と何の信憑性のために必要とされるために必要なもの絡み合います。単一の暗号化目標としてAEを概念化することにより、AE方式は、従来の暗号化方式よりも悪用される可能性は低いです。また、統合されたAEスキームは、1つの別々の機密性と信頼性を意味を構成から見ているものよりも大幅に高速化することができます。"
    },
    {
      "indent": 3,
      "text": "When an AE scheme allows for the authentication of unencrypted data at the same time that a plaintext is being encrypted and authenticated, the scheme is an authenticated encryption with associated data (AEAD) scheme. Associated data can be useful when, for example, a network packet has unencrypted routing information and an encrypted payload.",
      "ja": "AE方式は、平文を暗号化して認証されていると同時に、暗号化されていないデータの認証を可能にする場合、スキームは、関連するデータ（AEAD）方式と認証された暗号化です。例えば、ネットワークパケットが暗号化されていないルーティング情報と暗号化されたペイロードを有する場合、関連するデータは、有用であり得ます。"
    },
    {
      "indent": 3,
      "text": "OCB is an AEAD scheme that depends on a blockcipher. This document fully defines OCB encryption and decryption except for the choice of the blockcipher and the length of authentication tag that is part of the ciphertext. The blockcipher must have a 128-bit blocksize. Each choice of blockcipher and tag length specifies a different variant of OCB. Several AES-based variants are defined in Section 3.1.",
      "ja": "OCBは、ブロック暗号に依存AEADスキームです。この文書は、完全にブロック暗号の選択と暗号文の一部である認証タグの長さを除き、OCBの暗号化と復号化を定義します。ブロック暗号は128ビットのブロックサイズを持っている必要があります。ブロック暗号とタグの長さのそれぞれの選択はOCBの異なるバリアントを指定します。いくつかのAESベースの変異体は、3.1節で定義されています。"
    },
    {
      "indent": 3,
      "text": "OCB encryption and decryption employ a nonce N, which must be distinct for each invocation of the OCB encryption operation. OCB requires the associated data A to be specified when one encrypts or decrypts, but it may be zero-length. The plaintext P and the associated data A can have any bitlength. The ciphertext C one gets by encrypting P in the presence of A consists of a ciphertext-core having the same length as P, plus an authentication tag. One can view the resulting ciphertext as either the pair (ciphertext-core, tag) or their concatenation (ciphertext-core || tag), the difference being purely how one assembles and parses ciphertexts. This document uses concatenation.",
      "ja": "OCB暗号化および復号化は、OCB暗号化操作の各呼び出しのために別個でなければならないノンスNを用います。 OCBは、1つの暗号化または復号化時に指定される関連データAを必要とするが、それはゼロ長であってもよいです。平文Pと関連付けられたデータAは、任意のビット長を有することができます。暗号文Cの一方はPと同じ長さ、プラス認証タグを有する暗号文コアから構成Aの存在下でPを暗号化することによって取得します。一つの違いは一つの組み立て、暗号文を解析純粋方法である、対（暗号文コア、タグ）、またはそれらの連結（暗号文コア||タグ）のいずれかとして得られた暗号文を見ることができます。この文書では、連結を使用しています。"
    },
    {
      "indent": 3,
      "text": "OCB encryption protects the confidentiality of P and the authenticity of A, N, and P. It does this using, on average, about a + m + 1.02 blockcipher calls, where a is the blocklength of A, m is the blocklength of P, and the nonce N is implemented as a counter (if N is random, then OCB uses a + m + 2 blockcipher calls). If A is fixed during a session, then, after preprocessing, there is effectively no cost to having A authenticated on subsequent encryptions, and the mode will average m + 1.02 blockcipher calls. OCB requires a single key K for the underlying blockcipher, and all blockcipher calls are keyed by K. OCB is online. In particular, one need not know the length of A or P to proceed with encryption, nor need one know the length of A or C to proceed with decryption. OCB is parallelizable: the bulk of its blockcipher calls can be performed simultaneously. Computational work beyond blockcipher calls consists of a small and fixed number of logical operations per call. OCB enjoys provable security: the mode of operation is secure assuming that the underlying blockcipher is secure. As with most modes of operation, security degrades as the number of blocks processed gets large (see Section 5 for details).",
      "ja": "OCB暗号化は、それは、mはPのブロック長Aのブロック長であるコールブロック暗号この使用、平均して、約+のM + 1.02、あるんPの機密性とA、N、及びPの真正性を保護しますそして、ノンスN（Nはランダムである場合、OCBコールブロック暗号+のM + 2を使用して）カウンタとして実装されます。 Aがセッション中に固定されている場合、その後、前処理した後、後続の暗号化で認証したことに何のコストを効果的に存在せず、モードM + 1.02ブロック暗号コールを平均化します。 OCBは、基礎となるブロック暗号のための単一のキーKを必要とし、K. OCBがオンラインになっていることによって、すべてのブロック暗号の呼び出しはキーが付いています。具体的には、一方は暗号化を進めるためにAまたはPの長さを知って、また一つは復号化を進めるためにAまたはCの長さを知る必要がある必要はありません。 OCBは並列化：そのブロック暗号の呼び出しの大部分を同時に行うことができます。ブロック暗号の呼び出しを超えた計算作業は、コールごとの論理演算の小さな固定数で構成されています。 OCBは証明可能安全性を楽しんでいます：動作モードは、基礎となるブロック暗号が安全であると仮定して安全です。処理されたブロックの数が大きくなるように、操作のほとんどのモードと同じように、セキュリティ（詳細は第5章を参照してください）低下します。"
    },
    {
      "indent": 3,
      "text": "For reasons of generality, OCB is defined to operate on arbitrary bitstrings. But for reasons of simplicity and efficiency, most implementations will assume that strings operated on are bytestrings (i.e., strings that are a multiple of 8 bits). To promote interoperability, implementations of OCB that communicate with implementations of unknown capabilities should restrict all provided values (nonces, tags, plaintexts, ciphertexts, and associated data) to bytestrings.",
      "ja": "一般性の理由のために、OCBは、任意のビット列で動作するように定義されます。しかし、単純性および効率の理由のために、ほとんどの実装は、上で動作する文字列がバイト文字列（8ビットの倍数である、すなわち、文字列）であると仮定する。相互運用性を促進するために、未知の機能の実装と通信OCBの実装は、バイト文字列へのすべての提供された値（ナンス、タグ、平文、暗号文、および関連するデータ）を制限しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The version of OCB defined in this document is a refinement of two prior schemes. The original OCB version was published in 2001 [OCB1] and was listed as an optional component in IEEE 802.11i. A second version was published in 2004 [OCB2] and is specified in ISO 19772. The scheme described here is called OCB3 in the 2011 paper describing the mode [OCB3]; it shall be referred to simply as OCB throughout this document. The only difference between the algorithm of this RFC and that of the [OCB3] paper is that the tag length is now encoded into the internally formatted nonce. See [OCB3] for complete references, timing information, and a discussion of the differences between the algorithms. OCB was initially the acronym for Offset Codebook but is now the algorithm's full name.",
      "ja": "この文書で定義されたOCBのバージョンでは、2つの従来の方式の改良したものです。オリジナルOCBバージョンは[OCB1] 2001年に出版された及びIEEE 802.11i規格に任意成分として記載されていました。第二版は、[OCB2] 2004年に出版され、ここで説明するスキームは、[OCB3]モードを記述する2011年紙にOCB3と呼ばれているISO 19772.に指定されています。それが本書でOCBと単に呼ぶことにします。このRFCのアルゴリズム及び[OCB3】紙との間の唯一の違いは、タグの長さは、現在内部フォーマットナンスに符号化されることです。完全なリファレンス、タイミング情報を、およびアルゴリズムの相違点については、[OCB3]を参照してください。 OCBは当初、オフセットコードブックの頭文字をとったが、現在は、アルゴリズムの完全な名前です。"
    },
    {
      "indent": 3,
      "text": "OCB has received years of in-depth analysis previous to its submission to the CFRG and has been under review by the members of the CFRG for over a year. It is the consensus of the CFRG that the security mechanisms provided by the OCB AEAD algorithm described in this document are suitable for use in providing confidentiality and authentication.",
      "ja": "OCBはCFRGへの提出に前の詳細な分析の年を受けており、一年以上CFRGのメンバーによって検討されてきました。これは、この文書で説明OCB AEADアルゴリズムによって提供されるセキュリティ・メカニズムは、機密性と認証を提供する上での使用に適しているCFRGのコンセンサスです。"
    },
    {
      "indent": 0,
      "text": "2. Notation and Basic Operations",
      "section_title": true,
      "ja": "2.表記と基本操作"
    },
    {
      "indent": 3,
      "text": "There are two types of variables used in this specification, strings and integers. Although strings processed by most implementations of OCB will be strings of bytes, bit-level operations are used throughout this specification document for defining OCB. String variables are always written with an initial uppercase letter while integer variables are written in all lowercase. Following C's convention, a single equals (\"=\") indicates variable assignment and double equals (\"==\") is the equality relation. Whenever a variable is followed by an underscore (\"_\"), the underscore is intended to denote a subscript, with the subscripted expression requiring evaluation to resolve the meaning of the variable. For example, when i == 2, then P_i refers to the variable P_2.",
      "ja": "本明細書では、文字列と整数で使用される変数の2種類があります。 OCBのほとんどの実装で処理文字列はバイトの文字列になるが、ビットレベルの操作は、OCBを定義するための、本明細書全体にわたって使用されます。 String型の変数は常に整数の変数はすべて小文字で書かれている間、最初の大文字で書かれています。 Cの慣習に従って、単一等号（「=」）は変数の代入とダブル等号（「==」）を示し平等の関係です。変数はアンダースコア（「_」）が続いているときはいつでも、下線は変数の意味を解決するために評価を必要添字式で、添え字を意味することが意図されます。例えば、私は== 2、次いでP_Iは可変P_2を意味します。"
    },
    {
      "indent": 3,
      "text": "c^i The integer c raised to the i-th power.",
      "ja": "C ^私は、整数cは、i番目のパワーに引き上げ。"
    },
    {
      "indent": 3,
      "text": "bitlen(S) The length of string S in bits (e.g., bitlen(101) == 3).",
      "ja": "bitlen（S）ビットの文字列Sの長さ（例えば、bitlen（101）== 3）。"
    },
    {
      "indent": 3,
      "text": "zeros(n) The string made of n zero bits.",
      "ja": "ゼロ（N）ゼロ・ビットからなる文字列。"
    },
    {
      "indent": 3,
      "text": "ntz(n) The number of trailing zero bits in the base-2 representation of the positive integer n. More formally, ntz(n) is the largest integer x for which 2^x divides n.",
      "ja": "NTZ（n）は正の整数nのベース2表現のゼロ・ビットを末尾の数。より正式に、NTZ（n）は2 ^ XがNを分割するための最大の整数xです。"
    },
    {
      "indent": 3,
      "text": "S xor T The string that is the bitwise exclusive-or of S and T. Strings S and T will always have the same length.",
      "ja": "S XOR Tの排他的論理和SとT.文字列SとTのビット単位が常に同じ長さを持つことになります文字列。"
    },
    {
      "indent": 3,
      "text": "S[i] The i-th bit of the string S (indices begin at 1, so if S is 011, then S[1] == 0, S[2] == 1, S[3] == 1).",
      "ja": "S [i]は、文字列Sのi番目のビット（インデックスが1から始まるので、Sが011である場合、S [1] == 0、S [2] == 1、S [3] == 1） 。"
    },
    {
      "indent": 3,
      "text": "S[i..j] The substring of S consisting of bits i through j, inclusive.",
      "ja": "I jを介してビットからなるSのS [i..j]ストリング、包括。"
    },
    {
      "indent": 3,
      "text": "S || T String S concatenated with string T (e.g., 000 || 111 == 000111).",
      "ja": "S || T列s連結された文字列T（例えば、000 || 111 == 000111）です。"
    },
    {
      "indent": 3,
      "text": "str2num(S) The base-2 interpretation of bitstring S (e.g., str2num(1110) == 14).",
      "ja": "str2num（S）S（例えば、はstr2num（1110）== 14）ビット文字列のベース2解釈。"
    },
    {
      "indent": 3,
      "text": "num2str(i,n) The n-bit string whose base-2 interpretation is i (e.g., num2str(14,4) == 1110 and num2str(1,2) == 01).",
      "ja": "num2strは（I、N）、そのベース2解釈iはnビットの列（例えば、num2strは（14,4）== 1110とnum2strは（1,2）== 01）。"
    },
    {
      "indent": 3,
      "text": "double(S) If S[1] == 0, then double(S) == (S[2..128] || 0); otherwise, double(S) == (S[2..128] || 0) xor (zeros(120) || 10000111).",
      "ja": "二重（S）もしS [1] == 0の場合、二重（S）==（S [2..128] || 0）。そうでない場合は、二重（S）==（S [2..128] || 0）XOR（ゼロ（120）|| 10000111）。"
    },
    {
      "indent": 0,
      "text": "3. OCB Global Parameters",
      "section_title": true,
      "ja": "3. OCBグローバルパラメータ"
    },
    {
      "indent": 3,
      "text": "To be complete, the algorithms in this document require specification of two global parameters: a blockcipher operating on 128-bit blocks and the length of authentication tags in use.",
      "ja": "使用されている128ビットのブロック上で動作するブロック暗号、認証タグの長さ：完全であることが、この文書に記載されているアルゴリズムは、二つのグローバルパラメータの指定を必要とします。"
    },
    {
      "indent": 3,
      "text": "Specifying a blockcipher implicitly defines the following symbols.",
      "ja": "ブロック暗号を指定すると、暗黙のうちに、次の記号を定義します。"
    },
    {
      "indent": 3,
      "text": "KEYLEN The blockcipher's key length in bits.",
      "ja": "KEYLENビットでブロック暗号の鍵の長さ。"
    },
    {
      "indent": 3,
      "text": "ENCIPHER(K,P) The blockcipher function mapping 128-bit plaintext block P to its corresponding ciphertext block using KEYLEN-bit key K.",
      "ja": "ENCIPHER（K、P）KEYLENビット鍵Kを用いて、その対応する暗号文ブロックにブロック暗号関数マッピング128ビットの平文ブロックP"
    },
    {
      "indent": 3,
      "text": "DECIPHER(K,C) The inverse blockcipher function mapping 128-bit ciphertext block C to its corresponding plaintext block using KEYLEN-bit key K.",
      "ja": "KEYLENビットの鍵Kを使用して、対応する平文ブロックの逆ブロック暗号関数マッピング128ビットの暗号文ブロックC（K、C）をDECIPHER"
    },
    {
      "indent": 3,
      "text": "The TAGLEN parameter specifies the length of authentication tag used by OCB and may be any value up to 128. Greater values for TAGLEN provide greater assurances of authenticity, but ciphertexts produced by OCB are longer than their corresponding plaintext by TAGLEN bits. See Section 5 for details about TAGLEN and security.",
      "ja": "TAGLENパラメータは、OCBによって使用される認証タグの長さを指定し、真正性のより大きな保証を提供TAGLENための128より大きい値までの任意の値であってもよいが、OCBによって産生さ暗号文はTAGLENビットによって、それらの対応する平文よりも長いです。 TAGLENとセキュリティについての詳細は、第5章を参照してください。"
    },
    {
      "indent": 3,
      "text": "As an example, if 128-bit authentication tags and AES with 192-bit keys are to be used, then KEYLEN is 192, ENCIPHER refers to the AES-192 cipher, DECIPHER refers to the AES-192 inverse cipher, and TAGLEN is 128 [AES].",
      "ja": "192ビットキーを使用して128ビットの認証タグとAESを使用する場合、一例として、次にKEYLENはDECIPHERはAES-192逆暗号を指し、ENCIPHERは、AES-192暗号化を意味し、192であり、そしてTAGLEN 128であります[AES]。"
    },
    {
      "indent": 0,
      "text": "3.1. Named OCB Parameter Sets and Constants",
      "section_title": true,
      "ja": "3.1. 名前付きOCBパラメータセットと定数"
    },
    {
      "indent": 3,
      "text": "The following table gives names to common OCB global parameter sets. Each of the AES variants is defined in [AES].",
      "ja": "次の表は、一般的なOCBグローバルパラメータセットに名前を与えます。 AES変異体のそれぞれには、[AES]で定義されています。"
    },
    {
      "indent": 11,
      "text": "+----------------------------+-------------+--------+\n| Name                       | Blockcipher | TAGLEN |\n+----------------------------+-------------+--------+\n| AEAD_AES_128_OCB_TAGLEN128 |   AES-128   |  128   |\n| AEAD_AES_128_OCB_TAGLEN96  |   AES-128   |   96   |\n| AEAD_AES_128_OCB_TAGLEN64  |   AES-128   |   64   |\n| AEAD_AES_192_OCB_TAGLEN128 |   AES-192   |  128   |\n| AEAD_AES_192_OCB_TAGLEN96  |   AES-192   |   96   |\n| AEAD_AES_192_OCB_TAGLEN64  |   AES-192   |   64   |\n| AEAD_AES_256_OCB_TAGLEN128 |   AES-256   |  128   |\n| AEAD_AES_256_OCB_TAGLEN96  |   AES-256   |   96   |\n| AEAD_AES_256_OCB_TAGLEN64  |   AES-256   |   64   |\n+----------------------------+-------------+--------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "RFC 5116 defines an interface for authenticated-encryption schemes [RFC5116]. RFC 5116 requires the specification of certain constants for each named AEAD scheme. For each of the OCB parameter sets listed above: P_MAX, A_MAX, and C_MAX are all unbounded; N_MIN is 1 byte, and N_MAX is 15 bytes. The parameter sets indicating the use of AES-128, AES-192, and AES-256 have K_LEN equal to 16, 24, and 32 bytes, respectively.",
      "ja": "RFC 5116は、認証、暗号化方式[RFC5116]のためのインタフェースを定義します。 RFC 5116は、それぞれの名前のAEADスキームのための一定の定数を指定する必要があります。上記OCBパラメータセットのそれぞれについて：P_MAX、A_MAX、及びC_MAX全て無制限です。 N_MINは1バイトで、N_MAXは15バイトです。 AES-128、AES-192、およびAES-256の使用を示すパラメータセットは、それぞれ、16​​、24、及び32バイトK_LENが等しい有します。"
    },
    {
      "indent": 3,
      "text": "Each ciphertext is longer than its corresponding plaintext by exactly TAGLEN bits, and TAGLEN is given at the end of each name. For instance, an AEAD_AES_128_OCB_TAGLEN64 ciphertext is exactly 64 bits longer than its corresponding plaintext.",
      "ja": "各暗号文が長く正確TAGLENビットによってその対応する平文よりも、そしてTAGLENは、それぞれの名前の末尾に付与されます。例えば、AEAD_AES_128_OCB_TAGLEN64暗号文は、対応する平文よりも長く正確に64ビットです。"
    },
    {
      "indent": 0,
      "text": "4. OCB Algorithms",
      "section_title": true,
      "ja": "4. OCBアルゴリズム"
    },
    {
      "indent": 3,
      "text": "OCB is described in this section using pseudocode. Given any collection of inputs of the required types, following the pseudocode description for a function will produce the correct output of the promised type.",
      "ja": "OCBは擬似コードを使用して、このセクションで説明されています。約束したタイプの正しい出力を生成する関数のための擬似コード記述以下、必要な種類の入力の任意の集合を考えます。"
    },
    {
      "indent": 0,
      "text": "4.1. Processing Associated Data: HASH",
      "section_title": true,
      "ja": "4.1. 関連するデータの処理：HASH"
    },
    {
      "indent": 3,
      "text": "OCB has the ability to authenticate unencrypted associated data at the same time that it provides for authentication and encrypts a plaintext. The following hash function is central to providing this functionality. If an application has no associated data, then the associated data should be considered to exist and to be the empty string. HASH, conveniently, always returns zeros(128) when the associated data is the empty string.",
      "ja": "OCBは、認証のために提供し、平文を暗号化し、同時に暗号化されていない関連するデータを認証する機能を持っています。以下のハッシュ関数は、この機能を提供する中心的です。アプリケーションに関連付けられているデータがない場合、関連するデータが存在すると、空の文字列であるとみなされるべきです。関連するデータが空の文字列である場合HASHは、好都合には、常にゼロ（128）を返します。"
    },
    {
      "indent": 3,
      "text": "Function name: HASH Input: K, string of KEYLEN bits // Key A, string of any length // Associated data Output: Sum, string of 128 bits // Hash result",
      "ja": "関数名：HASH入力：K、KEYLENビット//キーA、任意の長さ//関連するデータ出力の文字列の文字列：合計、128ビットの文字列//ハッシュ結果"
    },
    {
      "indent": 3,
      "text": "Sum is defined as follows.",
      "ja": "次のように合計が定義されています。"
    },
    {
      "indent": 5,
      "text": "// // Key-dependent variables // L_* = ENCIPHER(K, zeros(128)) L_$ = double(L_*) L_0 = double(L_$) L_i = double(L_{i-1}) for every integer i > 0",
      "ja": "// //キー従属変数// L_ * = ENCIPHER（K、ゼロ（128））L_ $ =二重（L_ *）L_0 =二重（L_ $）L_iを=二重（L_ {I-1}）ごと整数I> 0"
    },
    {
      "indent": 5,
      "text": "// // Consider A as a sequence of 128-bit blocks // Let m be the largest integer so that 128m <= bitlen(A) Let A_1, A_2, ..., A_m and A_* be strings so that A == A_1 || A_2 || ... || A_m || A_*, and bitlen(A_i) == 128 for each 1 <= i <= m. Note: A_* may possibly be the empty string.",
      "ja": "// //そのように、A = 128メートル<= bitlen（A）は、A_1、A_2、...、A_MとA_ *のことストリングうように、128ビットブロック//の配列としてmが最大の整数とする検討します= A_1 || A_2 || ... || A_M || A_ *とbitlen各1 <= l <= mについて（a_iを）== 128。注意：A_ *は、おそらく空の文字列かもしれません。"
    },
    {
      "indent": 5,
      "text": "// // Process any whole blocks // Sum_0 = zeros(128) Offset_0 = zeros(128) for each 1 <= i <= m Offset_i = Offset_{i-1} xor L_{ntz(i)} Sum_i = Sum_{i-1} xor ENCIPHER(K, A_i xor Offset_i) end for",
      "ja": "// //プロセスの任意の全体ブロック// Sum_0 =ゼロ（128）Offset_0 =ゼロ（128）は、各1 <= l <= M Offset_i = Offset_ {I-1} XOR L_ {NTZ（I）} Sum_i = Sum_ {I-1}のXOR ENCIPHER（K、a_iをXOR Offset_i）終了の"
    },
    {
      "indent": 5,
      "text": "// // Process any final partial block; compute final hash value // if bitlen(A_*) > 0 then Offset_* = Offset_m xor L_* CipherInput = (A_* || 1 || zeros(127-bitlen(A_*))) xor Offset_* Sum = Sum_m xor ENCIPHER(K, CipherInput) else Sum = Sum_m end if",
      "ja": "// //最終的な部分ブロックを処理。 bitlen場合//最終ハッシュ値を計算する（A_ *）> 0、次いでOffset_ * = Offset_m XOR L_ * CipherInput =（A_ * || 1 ||ゼロ（127-bitlen（A_ *）））XOR Offset_ *合計= Sum_mのXOR ENCIPHER（K、CipherInput）他の和= Sum_mエンド場合"
    },
    {
      "indent": 0,
      "text": "4.2. Encryption: OCB-ENCRYPT",
      "section_title": true,
      "ja": "4.2. 暗号化：OCB-ENCRYPT"
    },
    {
      "indent": 3,
      "text": "This function computes a ciphertext (which includes a bundled authentication tag) when given a plaintext, associated data, nonce, and key. For each invocation of OCB-ENCRYPT using the same key K, the value of the nonce input N must be distinct.",
      "ja": "この関数は、平文、関連するデータ、ノンス、およびキーが与えられたとき（バンドル認証タグを含む）暗号文を計算します。同一の鍵Kを用いたOCB-ENCRYPTの各呼び出しのために、ナンス入力Nの値は別個でなければなりません。"
    },
    {
      "indent": 3,
      "text": "Function name: OCB-ENCRYPT Input: K, string of KEYLEN bits // Key N, string of no more than 120 bits // Nonce A, string of any length // Associated data P, string of any length // Plaintext Output: C, string of length bitlen(P) + TAGLEN bits // Ciphertext",
      "ja": "関数名：OCB-ENCRYPT入力：K、KEYLENビット//キーN、せいぜい120ビットのストリングのストリング//ノンスA、データP関連する任意の長//のストリング、任意の長//平文出力の文字列： C、長さの文字列がbitlen（P）+ TAGLENビット//暗号文"
    },
    {
      "indent": 3,
      "text": "C is defined as follows.",
      "ja": "次のようにCが定義されます。"
    },
    {
      "indent": 5,
      "text": "// // Key-dependent variables // L_* = ENCIPHER(K, zeros(128)) L_$ = double(L_*) L_0 = double(L_$) L_i = double(L_{i-1}) for every integer i > 0",
      "ja": "// //キー従属変数// L_ * = ENCIPHER（K、ゼロ（128））L_ $ =二重（L_ *）L_0 =二重（L_ $）L_iを=二重（L_ {I-1}）ごと整数I> 0"
    },
    {
      "indent": 5,
      "text": "// // Consider P as a sequence of 128-bit blocks // Let m be the largest integer so that 128m <= bitlen(P) Let P_1, P_2, ..., P_m and P_* be strings so that P == P_1 || P_2 || ... || P_m || P_*, and bitlen(P_i) == 128 for each 1 <= i <= m. Note: P_* may possibly be the empty string.",
      "ja": "// //そのようP = P_1、P_2、...、P_MとP_ *ことストリングう128メートル<= bitlen（P）となるようP 128ビットブロックのシーケンスとして// mは最大の整数とする検討= P_1 || P_2 || ... || P_M || P_ *、および各1 bitlen（P_I）== 128 <= l <= M。注意：P_は*おそらく、空の文字列かもしれません。"
    },
    {
      "indent": 5,
      "text": "// // Nonce-dependent and per-encryption variables // Nonce = num2str(TAGLEN mod 128,7) || zeros(120-bitlen(N)) || 1 || N bottom = str2num(Nonce[123..128]) Ktop = ENCIPHER(K, Nonce[1..122] || zeros(6)) Stretch = Ktop || (Ktop[1..64] xor Ktop[9..72]) Offset_0 = Stretch[1+bottom..128+bottom] Checksum_0 = zeros(128)",
      "ja": "// //ノンス依存ごとの暗号化変数//ナンス= num2strは（TAGLEN MOD 128,7）||ゼロ（120-bitlen（N））|| 1 || Nボトム=はstr2num（ノンス[123..128]）Ktop = ENCIPHER（K、ノンス[1..122] ||ゼロ（6））ストレッチ= Ktop || （Ktop [1..64] XOR Ktop [9..72]）Offset_0 =ストレッチ[1 + bottom..128 +底] Checksum_0 =ゼロ（128）"
    },
    {
      "indent": 5,
      "text": "// // Process any whole blocks // for each 1 <= i <= m Offset_i = Offset_{i-1} xor L_{ntz(i)} C_i = Offset_i xor ENCIPHER(K, P_i xor Offset_i) Checksum_i = Checksum_{i-1} xor P_i end for",
      "ja": "//プロセスの各1 <= l <= M Offset_i = Offset_ {I-1} XOR L_ {NTZ（I）} C_I = Offset_i XOR ENCIPHER（K、P_I XOR Offset_i）Checksum_i = Checksum_するための任意の全体ブロック// {I-1}のXOR P_I端"
    },
    {
      "indent": 5,
      "text": "// // Process any final partial block and compute raw tag // if bitlen(P_*) > 0 then Offset_* = Offset_m xor L_* Pad = ENCIPHER(K, Offset_*) C_* = P_* xor Pad[1..bitlen(P_*)] Checksum_* = Checksum_m xor (P_* || 1 || zeros(127-bitlen(P_*))) Tag = ENCIPHER(K, Checksum_* xor Offset_* xor L_$) xor HASH(K,A) else C_* = <empty string> Tag = ENCIPHER(K, Checksum_m xor Offset_m xor L_$) xor HASH(K,A) end if",
      "ja": "// //プロセスの任意の最終的な部分ブロックとbitlen場合//生のタグを計算する（P_ *）> 0、次いでOffset_ * = Offset_m XOR L_ *パッド= ENCIPHER（K、Offset_ *）C_ * = P_ * XORパッド[1。 .bitlen（P_ *）] Checksum_ * = Checksum_mのXOR（P_ * || 1 ||ゼロ（127-bitlen（P_ *）））タグ= ENCIPHER（K、Checksum_ * XOR Offset_ * XOR L_ $）XORハッシュ（K 、A）他C_ * = <空の文字列>タグ= ENCIPHER（K、Checksum_m XOR Offset_m XOR L_ $）のXOR HASH（K、A）END IF"
    },
    {
      "indent": 5,
      "text": "// // Assemble ciphertext // C = C_1 || C_2 || ... || C_m || C_* || Tag[1..TAGLEN]",
      "ja": "// // //暗号文C = C_1を組み立て|| C_2 || ... || C_m || C_ * ||タグ[1..TAGLEN]"
    },
    {
      "indent": 0,
      "text": "4.3. Decryption: OCB-DECRYPT",
      "section_title": true,
      "ja": "4.3. 復号化：OCB-DECRYPT"
    },
    {
      "indent": 3,
      "text": "This function computes a plaintext when given a ciphertext, associated data, nonce, and key. An authentication tag is embedded in the ciphertext. If the tag is not correct for the ciphertext, associated data, nonce, and key, then an INVALID signal is produced.",
      "ja": "暗号文、関連するデータ、ノンス、およびキーが与えられたとき、この関数は、平文を計算します。認証タグが暗号文に埋め込まれています。タグが暗号文、関連するデータ、ノンス、およびキーの正しくない場合、次に無効信号が生成されます。"
    },
    {
      "indent": 3,
      "text": "Function name: OCB-DECRYPT Input: K, string of KEYLEN bits // Key N, string of no more than 120 bits // Nonce A, string of any length // Associated data C, string of at least TAGLEN bits // Ciphertext Output: P, string of length bitlen(C) - TAGLEN bits, // Plaintext or INVALID indicating authentication failure",
      "ja": "関数名：入力をOCB-DECRYPT：K、KEYLENビット//キーN、せいぜい120ビットの文字列の文字列を//ノンスA、データC関連する任意の長//のストリング、少なくともTAGLENビット//暗号文の文字列出力：P、（C）bitlen長さのストリング -  TAGLENビット、//平文またはINVALID認証失敗を示します"
    },
    {
      "indent": 3,
      "text": "P is defined as follows.",
      "ja": "次のようにPが定義されます。"
    },
    {
      "indent": 5,
      "text": "// // Key-dependent variables // L_* = ENCIPHER(K, zeros(128)) L_$ = double(L_*) L_0 = double(L_$) L_i = double(L_{i-1}) for every integer i > 0",
      "ja": "// //キー従属変数// L_ * = ENCIPHER（K、ゼロ（128））L_ $ =二重（L_ *）L_0 =二重（L_ $）L_iを=二重（L_ {I-1}）ごと整数I> 0"
    },
    {
      "indent": 5,
      "text": "// // Consider C as a sequence of 128-bit blocks // Let m be the largest integer so that 128m <= bitlen(C) - TAGLEN Let C_1, C_2, ..., C_m, C_* and T be strings so that C == C_1 || C_2 || ... || C_m || C_* || T, bitlen(C_i) == 128 for each 1 <= i <= m, and bitlen(T) == TAGLEN. Note: C_* may possibly be the empty string.",
      "ja": "、C_m、C_ *とTが文字列であるTAGLENレッツC_1、C_2、...  -  // 128メートル<= bitlen（C）ようにC 128ビットブロックのシーケンスとして// mは最大の整数とする検討そのためC == C_1 || C_2 || ... || C_m || C_ * ||各1 T、bitlen（C_I）== 128 <= l <= M、及びbitlen（T）== TAGLEN。注意：C_ *はおそらく空の文字列かもしれません。"
    },
    {
      "indent": 5,
      "text": "// // Nonce-dependent and per-decryption variables // Nonce = num2str(TAGLEN mod 128,7) || zeros(120-bitlen(N)) || 1 || N bottom = str2num(Nonce[123..128]) Ktop = ENCIPHER(K, Nonce[1..122] || zeros(6)) Stretch = Ktop || (Ktop[1..64] xor Ktop[9..72]) Offset_0 = Stretch[1+bottom..128+bottom] Checksum_0 = zeros(128)",
      "ja": "// //ノンス依存性とあたり復号変数//ノンス= num2strは（TAGLEN MOD 128,7）||ゼロ（120-bitlen（N））|| 1 || Nボトム=はstr2num（ノンス[123..128]）Ktop = ENCIPHER（K、ノンス[1..122] ||ゼロ（6））ストレッチ= Ktop || （Ktop [1..64] XOR Ktop [9..72]）Offset_0 =ストレッチ[1 + bottom..128 +底] Checksum_0 =ゼロ（128）"
    },
    {
      "indent": 5,
      "text": "// // Process any whole blocks // for each 1 <= i <= m Offset_i = Offset_{i-1} xor L_{ntz(i)} P_i = Offset_i xor DECIPHER(K, C_i xor Offset_i) Checksum_i = Checksum_{i-1} xor P_i end for",
      "ja": "//プロセスの各1 <= l <= M Offset_i = Offset_ {I-1} XOR L_ {NTZ（I）} P_I = Offset_i XOR DECIPHER（K、C_I XOR Offset_i）Checksum_i = Checksum_するための任意の全体ブロック// {I-1}のXOR P_I端"
    },
    {
      "indent": 5,
      "text": "// // Process any final partial block and compute raw tag // if bitlen(C_*) > 0 then Offset_* = Offset_m xor L_* Pad = ENCIPHER(K, Offset_*) P_* = C_* xor Pad[1..bitlen(C_*)] Checksum_* = Checksum_m xor (P_* || 1 || zeros(127-bitlen(P_*))) Tag = ENCIPHER(K, Checksum_* xor Offset_* xor L_$) xor HASH(K,A)",
      "ja": "// //プロセスの任意の最終的な部分ブロックとbitlen場合//生のタグを計算する（C_ *）> 0、次いでOffset_ * = Offset_m XOR L_ *パッド= ENCIPHER（K、Offset_ *）P_ * = C_ * XORパッド[1。 .bitlen（C_ *）] Checksum_ * = Checksum_mのXOR（P_ * || 1 ||ゼロ（127-bitlen（P_ *）））タグ= ENCIPHER（K、Checksum_ * XOR Offset_ * XOR L_ $）XORハッシュ（K 、A）"
    },
    {
      "indent": 5,
      "text": "else P_* = <empty string> Tag = ENCIPHER(K, Checksum_m xor Offset_m xor L_$) xor HASH(K,A) end if",
      "ja": "他P_ * = <空の文字列>タグ= ENCIPHER（K、Checksum_m XOR Offset_m XOR L_ $）のXOR HASH（K、A）END IF"
    },
    {
      "indent": 5,
      "text": "// // Check for validity and assemble plaintext // if (Tag[1..TAGLEN] == T) then P = P_1 || P_2 || ... || P_m || P_* else P = INVALID end if",
      "ja": "// //妥当性を確認し、あれば平文//を組み立てる（タグ[1..TAGLEN] == T）その後、P = P_1 || P_2 || ... || P_M || P_ *他のP = INVALID END IF"
    },
    {
      "indent": 0,
      "text": "5. Security Considerations",
      "section_title": true,
      "ja": "5.セキュリティについての考慮事項"
    },
    {
      "indent": 3,
      "text": "OCB achieves two security properties, confidentiality and authenticity. Confidentiality is defined via \"indistinguishability from random bits\", meaning that an adversary is unable to distinguish OCB outputs from an equal number of random bits. Authenticity is defined via \"authenticity of ciphertexts\", meaning that an adversary is unable to produce any valid nonce-ciphertext pair that it has not already acquired. The security guarantees depend on the underlying blockcipher being secure in the sense of a strong pseudorandom permutation. Thus, if OCB is used with a blockcipher that is not secure as a strong pseudorandom permutation, the security guarantees vanish. The need for the strong pseudorandom permutation property means that OCB should be used with a conservatively designed, well-trusted blockcipher, such as AES.",
      "ja": "OCBは、2つのセキュリティ・プロパティ、機密性と信頼性を実現しています。機密性は、攻撃者がランダムビットの等しい数からOCB出力を区別することができないことを意味し、「ランダムビットから識別不能」を介して定義されます。真正の敵が、それはまだ取得していないことを任意の有効なナンス・暗号文ペアを生成することができないことを意味し、「暗号文の信憑性」を経由して定義されます。セキュリティの保証は強い擬似ランダム置換の意味で安全である根本的なブロック暗号に依存します。 OCBは強い擬似ランダム置換などのセキュアでないブロック暗号で使用されている場合このように、セキュリティの保証は消滅します。強い擬似ランダム置換プロパティの必要性はOCBは、AESなどの保守的に設計され、十分に信頼できるブロック暗号で使用されるべきであることを意味しています。"
    },
    {
      "indent": 3,
      "text": "Both the confidentiality and the authenticity properties of OCB degrade as per s^2 / 2^128, where s is the total number of blocks that the adversary acquires. The consequence of this formula is that the proven security disappears when s becomes as large as 2^64. Thus, the user should never use a key to generate an amount of ciphertext that is near to, or exceeds, 2^64 blocks. In order to ensure that s^2 / 2^128 remains small, a given key should be used to encrypt at most 2^48 blocks (2^55 bits or 4 petabytes), including the associated data. To ensure these limits are not crossed, automated key management is recommended in systems exchanging large amounts of data [RFC4107].",
      "ja": "Sは、敵対者が取得することをブロックの総数であり、機密性およびOCBの真正特性S ^ 2/2 ^ 128ごとに分解、両方。この式の結果は、sが2 ^ 64のように大きくなると、実績のあるセキュリティが消えるということです。これにより、ユーザは、近くにある、または超えた暗号文の量、2 ^ 64ブロックを生成するためにキーを使用しないでください。そのS ^ / 2 ^ 128は小さいまま確保するために、与えられたキーは、関連するデータを含む最大で2 ^ 48ブロック（2 ^ 55ビットまたは4ペタバイト）を、暗号化するために使用されるべきです。これらの制限を超えていないことを確認するには、自動化された鍵管理は、[RFC4107]大量のデータをやり取りするシステムで推奨されます。"
    },
    {
      "indent": 3,
      "text": "When a ciphertext decrypts as INVALID, it is the implementor's responsibility to make sure that no information beyond this fact is made adversarially available.",
      "ja": "暗号文は無効と解読すると、この事実を越えて何も情報がadversarially利用できるようにされていないことを確認するために、実装者の責任です。"
    },
    {
      "indent": 3,
      "text": "OCB encryption and decryption produce an internal 128-bit authentication tag. The parameter TAGLEN determines how many bits of this internal tag are included in ciphertexts and used for authentication. The value of TAGLEN has two impacts: an adversary can trivially forge with probability 2^{-TAGLEN}, and ciphertexts are TAGLEN bits longer than their corresponding plaintexts. It is up to the application designer to choose an appropriate value for TAGLEN. Long tags cost no more computationally than short ones.",
      "ja": "OCB暗号化および復号化は、内部128ビットの認証タグを生成します。パラメータTAGLENこの内部タグの多くのビットが暗号文に含まれ、認証のために使用される方法を決定します。 TAGLENの値は、2つの影響を有する：敵対者は自明確率2 ^で偽造することができ、{ - } TAGLEN、及び暗号文は、対応する平文より長いTAGLENビットです。それはTAGLENのために適切な値を選択するために、アプリケーションの設計者に任されています。ロングタグには短いものより、計算コストません。"
    },
    {
      "indent": 3,
      "text": "Normally, a given key should be used to create ciphertexts with a single tag length, TAGLEN, and an application should reject any ciphertext that claims authenticity under the same key but a different tag length. While the ciphertext core and all of the bits of the tag do depend on the tag length, this is done for added robustness to misuse and should not suggest that receivers accept ciphertexts employing variable tag lengths under a single key.",
      "ja": "通常、与えられたキーは、単一のタグの長さ、TAGLENで暗号文を作成するために使用されるべきであり、アプリケーションは同じ鍵が、異なるタグ長の下で正当性を主張する任意の暗号文を拒否すべきです。暗号文コアとタグのすべてのビットは、タグの長さに依存しないが、これは誤用に添加ロバスト性のために行われ、受信機は、単一のキーの下の変数タグの長さを用いる暗号文を受け入れることを示唆してはなりません。"
    },
    {
      "indent": 3,
      "text": "Timing attacks are not a part of the formal security model and an implementation should take care to mitigate them in contexts where this is a concern. To render timing attacks impotent, the amount of time to encrypt or decrypt a string should be independent of the key and the contents of the string. The only explicitly conditional OCB operation that depends on private data is double(), which means that using constant-time blockcipher and double() implementations eliminates most (if not all) sources of timing attacks on OCB. Power-usage attacks are likewise out of the scope of the formal model and should be considered for environments where they are threatening.",
      "ja": "タイミング攻撃は、正式なセキュリティモデルの一部ではなく、実装は、これが懸念される状況でそれらを軽減するために世話をする必要があります。無力タイミング攻撃をレンダリングするには、文字列の暗号化または復号化するための時間の量は、キーと文字列の内容と無関係であるべきです。プライベートデータに依存のみ明示的に条件付きOCB操作が一定時間のブロック暗号とダブルを（使用していることを意味し、）（ダブル）で実装OCBへの攻撃のタイミングのほとんど（すべてではない）のソースを排除します。電源の使用攻撃は、正式なモデルの範囲外でも同様であり、彼らが脅かしている環境を考慮すべきです。"
    },
    {
      "indent": 3,
      "text": "The OCB encryption scheme reveals in the ciphertext the length of the plaintext. Sometimes the length of the plaintext is a valuable piece of information that should be hidden. For environments where \"traffic analysis\" is a concern, techniques beyond OCB encryption (typically involving padding) would be necessary.",
      "ja": "OCB暗号化方式は、暗号文に平文の長さを明らかにする。時には、平文の長さが隠されるべき情報の貴重な作品です。 「トラフィック分析」は懸念される環境では、（一般的にパディングを含む）OCBの暗号化を超えた技術は必要であろう。"
    },
    {
      "indent": 3,
      "text": "Defining the ciphertext that results from OCB-ENCRYPT to be the pair (C_1 || C_2 || ... || C_m || C_*, Tag[1..TAGLEN]) instead of the concatenation C_1 || C_2 || ... || C_m || C_* || Tag[1..TAGLEN] introduces no security concerns. Because TAGLEN is fixed, both versions allow ciphertexts to be parsed unambiguously.",
      "ja": "代わり連結C_1の（C_1 || C_2 || ... || || C_m C_ *、タグ[1..TAGLEN]）ペアであることがOCB暗号化から生じる暗号文を定義する|| C_2 || ... || C_m || C_ * ||タグ[1..TAGLEN]は何のセキュリティ上の懸念を導入していません。 TAGLENが固定されているので、両方のバージョンは、暗号文を明確に解析されることを可能にします。"
    },
    {
      "indent": 0,
      "text": "5.1. Nonce Requirements",
      "section_title": true,
      "ja": "5.1. ノンス要件"
    },
    {
      "indent": 3,
      "text": "It is crucial that, as one encrypts, one does not repeat a nonce. The inadvertent reuse of the same nonce by two invocations of the OCB encryption operation, with the same key, but with distinct plaintext values, undermines the confidentiality of the plaintexts protected in those two invocations and undermines all of the authenticity and integrity protection provided by that key. For this reason, OCB should only be used whenever nonce uniqueness can be provided with certainty. Note that it is acceptable to input the same nonce value multiple times to the decryption operation. We emphasize that the security consequences are quite serious if an attacker observes two ciphertexts that were created using the same nonce and key values, unless the plaintext and associated data values in both invocations of the encrypt operation were identical. First, a loss of confidentiality ensues because the attacker will be able to infer relationships between the two plaintext values. Second, a loss of authenticity ensues because the attacker will be able to recover secret information used to provide authenticity, making subsequent forgeries trivial. Note that there are AEAD schemes, particularly the Synthetic Initialization Vector (SIV) [RFC5297], appropriate for environments where nonces are unavailable or unreliable. OCB is not such a scheme.",
      "ja": "1つの暗号化として、1がnonceを繰り返さない、ということが重要です。同じキーを持つが、明確な平文の値を持つOCBの暗号化操作の2つの呼び出しによって、同じナンスの不注意による再利用は、これら二つの呼び出しで保護された平文の機密性を損なうし、そのによって提供さ真正性と完全性保護のすべてを損ないますキー。ノンスの一意性を確実に提供することができるときはいつでもこのような理由から、OCBにのみ使用されるべきです。それは復号化操作に同じノンス値を複数回入力に許容可能であることに留意されたいです。私たちは、攻撃者が暗号化操作の両方の呼び出しで平文と関連するデータ値が同一であった場合を除き、同じナンスおよびキー値を使用して作成された2つの暗号文を観測した場合、セキュリティ上の影響は非常に深刻であることを強調する。攻撃者は2つの平文の値の間の関係を推測することができるようになりますので、まず、機密性の損失が続きます。攻撃者は、その後の偽造は些細な作り、信頼性を提供するために使用する秘密情報を復元することができますので、第二に、信憑性の損失が続きます。ナンスが利用できない、または信頼できない環境に適しAEADスキーム、特に合成初期ベクトル（SIV）[RFC5297]があることに留意されたいです。 OCBは、このようなスキームではありません。"
    },
    {
      "indent": 3,
      "text": "Nonces need not be secret, and a counter may be used for them. If two parties send OCB-encrypted plaintexts to one another using the same key, then the space of nonces used by the two parties must be partitioned so that no nonce that could be used by one party to encrypt could be used by the other to encrypt (e.g., odd and even counters).",
      "ja": "ナンスは秘密である必要はなく、カウンタは彼らのために使用することができます。 2人の当事者が同じ鍵を使用して相互にOCB-暗号化された平文を送信する場合は暗号化するために一方の当事者によって使用される可能性が全くナンスを暗号化するために他で使用することはできなかったように、2つの当事者によって使用されるナンスのスペースを分割する必要があります（例えば、奇数と偶数のカウンター）。"
    },
    {
      "indent": 0,
      "text": "6. IANA Considerations",
      "section_title": true,
      "ja": "6. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "The Internet Assigned Numbers Authority (IANA) has defined a registry for Authenticated Encryption with Associated Data parameters. The IANA has added the following entries to the AEAD Registry. Each name refers to a set of parameters defined in Section 3.1.",
      "ja": "IANA（Internet Assigned Numbers Authority）は、関連するデータのパラメータを持つ認証された暗号化のために、レジストリを定義しています。 IANAはAEADレジストリに次のエントリを追加しました。それぞれの名前は、3.1節で定義されたパラメータのセットを指します。"
    },
    {
      "indent": 9,
      "text": "+----------------------------+-------------+------------+\n| Name                       |  Reference  | Numeric ID |\n+----------------------------+-------------+------------+\n| AEAD_AES_128_OCB_TAGLEN128 | Section 3.1 |     20     |\n| AEAD_AES_128_OCB_TAGLEN96  | Section 3.1 |     21     |\n| AEAD_AES_128_OCB_TAGLEN64  | Section 3.1 |     22     |\n| AEAD_AES_192_OCB_TAGLEN128 | Section 3.1 |     23     |\n| AEAD_AES_192_OCB_TAGLEN96  | Section 3.1 |     24     |\n| AEAD_AES_192_OCB_TAGLEN64  | Section 3.1 |     25     |\n| AEAD_AES_256_OCB_TAGLEN128 | Section 3.1 |     26     |\n| AEAD_AES_256_OCB_TAGLEN96  | Section 3.1 |     27     |\n| AEAD_AES_256_OCB_TAGLEN64  | Section 3.1 |     28     |\n+----------------------------+-------------+------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7. Acknowledgements",
      "section_title": true,
      "ja": "7.謝辞"
    },
    {
      "indent": 3,
      "text": "The design of the original OCB scheme [OCB1] was done while Rogaway was at Chiang Mai University, Thailand. Follow-up work [OCB2] was done with support of NSF grant 0208842 and a gift from Cisco. The final work by Krovetz and Rogaway [OCB3] that has resulted in this",
      "ja": "Rogawayはチェンマイ大学、タイであったが、元のOCB方式で[OCB1]の設計が行われました。フォローアップ作業は、[OCB2] NSFの助成金0208842およびシスコからの贈り物の支援を受けて行われました。このもたらしたKrovetzとRogaway [OCB3]による最終作業"
    },
    {
      "indent": 3,
      "text": "specification was supported by NSF grant 0904380. Thanks go to the many members of the Crypto Forum Research Group (CFRG) who provided feedback on earlier drafts. Thanks in particular go to David McGrew for contributing some text and for managing the RFC approval process, to James Manger for initiating a productive discussion on tag-length dependency and for greatly improving Appendix A, to Matt Caswell and Peter Dettman for writing implementations and verifying test vectors, and to Stephen Farrell and Spencer Dawkins for their careful reading and suggestions.",
      "ja": "仕様は0904380.おかげで、以前のドラフトにフィードバックを提供する暗号フォーラム研究グループ（CFRG）の多くのメンバーに行くNSFの助成金によってサポートされていました。おかげで、特にいくつかのテキストを貢献するため、およびRFCの承認プロセスを管理するために、ジェームス・マンジェにタグ長依存性の生産的な議論を開始するための大幅な実装を書き込み、検証のためにマットキャスウェルとピーターDettmanに、付録Aを改善するためのデビッドマグリューに行きます彼らの注意深い読書や提案のためのテストベクトル、およびスティーブン・ファレルとスペンサードーキンスへ。"
    },
    {
      "indent": 0,
      "text": "8. References",
      "section_title": true,
      "ja": "8.参照文献"
    },
    {
      "indent": 0,
      "text": "8.1. Normative References",
      "section_title": true,
      "ja": "8.1. 引用規格"
    },
    {
      "indent": 3,
      "text": "[AES] National Institute of Standards and Technology, \"Advanced Encryption Standard (AES)\", FIPS PUB 197, November 2001.",
      "ja": "[AES]米国国立標準技術研究所、 \"高度暗号化標準（AES）\"、FIPS PUBの197、2001年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC5116] McGrew, D., \"An Interface and Algorithms for Authenticated Encryption\", RFC 5116, January 2008.",
      "ja": "[RFC5116]マグリュー、D.、 \"認証暗号化のためのインタフェースとアルゴリズム\"、RFC 5116、2008年1月。"
    },
    {
      "indent": 0,
      "text": "8.2. Informative References",
      "section_title": true,
      "ja": "8.2. 参考文献"
    },
    {
      "indent": 3,
      "text": "[OCB1] Rogaway, P., Bellare, M., Black, J., and T. Krovetz, \"OCB: A Block-Cipher Mode of Operation for Efficient Authenticated Encryption\", ACM Conference on Computer and Communications Security 2001 - CCS 2001, ACM Press, 2001.",
      "ja": "[OCB1] Rogaway、P.、ベラー、M.、ブラック、J.、および、 \"OCB：効率的な認証暗号のためのオペレーションのブロック暗号モード\" T. Krovetz、コンピュータ上のACM会議および通信セキュリティ2001  -  CCS 2001 、ACMプレス、2001。"
    },
    {
      "indent": 3,
      "text": "[OCB2] Rogaway, P., \"Efficient Instantiations of Tweakable Blockciphers and Refinements to Modes OCB and PMAC\", Advances in Cryptology - ASIACRYPT 2004, Springer, 2004.",
      "ja": "ASIACRYPT 2004、スプリンガー2004年 -  [OCB2] Rogaway、P.、 \"モードOCBとPMACの調整機能付きブロック暗号と絞り込みの効率的なインスタンス化\"、暗号理論の進歩します。"
    },
    {
      "indent": 3,
      "text": "[OCB3] Krovetz, T. and P. Rogaway, \"The Software Performance of Authenticated-Encryption Modes\", Fast Software Encryption - FSE 2011 Springer, 2011.",
      "ja": "[OCB3] Krovetz、T.およびP. Rogaway、 \"認証・暗号化モードのソフトウェアパフォーマンス\"、高速ソフトウェア暗号化 -  FSE 2011スプリンガー、2011。"
    },
    {
      "indent": 3,
      "text": "[RFC4107] Bellovin, S. and R. Housley, \"Guidelines for Cryptographic Key Management\", BCP 107, RFC 4107, June 2005.",
      "ja": "[RFC4107] Bellovin氏、S.とR. Housley氏、 \"暗号鍵管理のためのガイドライン\"、BCP 107、RFC 4107、2005年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC5297] Harkins, D., \"Synthetic Initialization Vector (SIV) Authenticated Encryption Using the Advanced Encryption Standard (AES)\", RFC 5297, October 2008.",
      "ja": "[RFC5297]ハーキンズ、D.、2008年10月、RFC 5297 \"合成の初期ベクトル（SIV）は、Advanced Encryption Standard（AES）を使用して暗号化認証します\"。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Sample Results",
      "ja": "付録A.サンプルの結果"
    },
    {
      "indent": 3,
      "text": "This section gives sample output values for various inputs when using OCB with AES as per the parameters defined in Section 3.1. All strings are represented in hexadecimal (e.g., 0F represents the bitstring 00001111).",
      "ja": "セクション3.1で定義されたパラメータに従ってAESとOCBを使用する場合、このセクションでは、様々な入力のためのサンプルの出力値を与えます。すべての文字列は16進数で表現されている（例えば、0Fは、ビット列00001111を表します）。"
    },
    {
      "indent": 3,
      "text": "The following 16 (N,A,P,C) tuples show the ciphertext C that results from OCB-ENCRYPT(K,N,A,P) for various lengths of associated data (A) and plaintext (P). The key (K) has a fixed value, the tag length is 128 bits, and the nonce (N) increments.",
      "ja": "次の16（N、A、P、C）タプルは、関連するデータ（A）と、平文（P）の種々の長さのためにOCB-ENCRYPT（K、N、A、P）から生じる暗号文Cを示しています。キー（K）は固定値を有し、タグの長さは128ビットであり、ノンス（N）をインクリメントします。"
    },
    {
      "indent": 5,
      "text": "K : 000102030405060708090A0B0C0D0E0F",
      "ja": "K：000102030405060708090A0B0C0D0E0F"
    },
    {
      "indent": 3,
      "text": "An empty entry indicates the empty string.",
      "ja": "空のエントリは空の文字列を示します。"
    },
    {
      "indent": 5,
      "text": "N: BBAA99887766554433221100 A: P: C: 785407BFFFC8AD9EDCC5520AC9111EE6",
      "ja": "N：BBAA99887766554433221100 A：P：C：785407BFFFC8AD9EDCC5520AC9111EE6"
    },
    {
      "indent": 5,
      "text": "N: BBAA99887766554433221101 A: 0001020304050607 P: 0001020304050607 C: 6820B3657B6F615A5725BDA0D3B4EB3A257C9AF1F8F03009",
      "ja": "N：BBAA99887766554433221101 A：0001020304050607 P：0001020304050607 C：6820B3657B6F615A5725BDA0D3B4EB3A257C9AF1F8F03009"
    },
    {
      "indent": 5,
      "text": "N: BBAA99887766554433221102 A: 0001020304050607 P: C: 81017F8203F081277152FADE694A0A00",
      "ja": "N：BBAA99887766554433221102 A：0001020304050607 P：C：81017F8203F081277152FADE694A0A00"
    },
    {
      "indent": 5,
      "text": "N: BBAA99887766554433221103 A: P: 0001020304050607 C: 45DD69F8F5AAE72414054CD1F35D82760B2CD00D2F99BFA9",
      "ja": "N：BBAA99887766554433221103 A：P：0001020304050607 C：45DD69F8F5AAE72414054CD1F35D82760B2CD00D2F99BFA9"
    },
    {
      "indent": 5,
      "text": "N: BBAA99887766554433221104 A: 000102030405060708090A0B0C0D0E0F P: 000102030405060708090A0B0C0D0E0F C: 571D535B60B277188BE5147170A9A22C3AD7A4FF3835B8C5 701C1CCEC8FC3358",
      "ja": "N：BBAA99887766554433221104 A：000102030405060708090A0B0C0D0E0F P：000102030405060708090A0B0C0D0E0F C：571D535B60B277188BE5147170A9A22C3AD7A4FF3835B8C5 701C1CCEC8FC3358"
    },
    {
      "indent": 5,
      "text": "N: BBAA99887766554433221105 A: 000102030405060708090A0B0C0D0E0F P: C: 8CF761B6902EF764462AD86498CA6B97",
      "ja": "N：BBAA99887766554433221105 A：000102030405060708090A0B0C0D0E0F P：C：8CF761B6902EF764462AD86498CA6B97"
    },
    {
      "indent": 5,
      "text": "N: BBAA99887766554433221106 A: P: 000102030405060708090A0B0C0D0E0F C: 5CE88EC2E0692706A915C00AEB8B2396F40E1C743F52436B DF06D8FA1ECA343D",
      "ja": "N：BBAA99887766554433221106 A：P：000102030405060708090A0B0C0D0E0F C：5CE88EC2E0692706A915C00AEB8B2396F40E1C743F52436B DF06D8FA1ECA343D"
    },
    {
      "indent": 5,
      "text": "N: BBAA99887766554433221107 A: 000102030405060708090A0B0C0D0E0F1011121314151617 P: 000102030405060708090A0B0C0D0E0F1011121314151617 C: 1CA2207308C87C010756104D8840CE1952F09673A448A122 C92C62241051F57356D7F3C90BB0E07F",
      "ja": "N：BBAA99887766554433221107 A：000102030405060708090A0B0C0D0E0F1011121314151617 P：000102030405060708090A0B0C0D0E0F1011121314151617 C：1CA2207308C87C010756104D8840CE1952F09673A448A122 C92C62241051F57356D7F3C90BB0E07F"
    },
    {
      "indent": 5,
      "text": "N: BBAA99887766554433221108 A: 000102030405060708090A0B0C0D0E0F1011121314151617 P: C: 6DC225A071FC1B9F7C69F93B0F1E10DE",
      "ja": "N：BBAA99887766554433221108 A：000102030405060708090A0B0C0D0E0F1011121314151617 P：C：6DC225A071FC1B9F7C69F93B0F1E10DE"
    },
    {
      "indent": 5,
      "text": "N: BBAA99887766554433221109 A: P: 000102030405060708090A0B0C0D0E0F1011121314151617 C: 221BD0DE7FA6FE993ECCD769460A0AF2D6CDED0C395B1C3C E725F32494B9F914D85C0B1EB38357FF",
      "ja": "N：BBAA99887766554433221109 A：P：000102030405060708090A0B0C0D0E0F1011121314151617 C：221BD0DE7FA6FE993ECCD769460A0AF2D6CDED0C395B1C3C E725F32494B9F914D85C0B1EB38357FF"
    },
    {
      "indent": 5,
      "text": "N: BBAA9988776655443322110A A: 000102030405060708090A0B0C0D0E0F1011121314151617 18191A1B1C1D1E1F P: 000102030405060708090A0B0C0D0E0F1011121314151617 18191A1B1C1D1E1F C: BD6F6C496201C69296C11EFD138A467ABD3C707924B964DE AFFC40319AF5A48540FBBA186C5553C68AD9F592A79A4240",
      "ja": "N：BBAA9988776655443322110A A：000102030405060708090A0B0C0D0E0F1011121314151617 18191A1B1C1D1E1F P：000102030405060708090A0B0C0D0E0F1011121314151617 18191A1B1C1D1E1F C：BD6F6C496201C69296C11EFD138A467ABD3C707924B964DE AFFC40319AF5A48540FBBA186C5553C68AD9F592A79A4240"
    },
    {
      "indent": 5,
      "text": "N: BBAA9988776655443322110B A: 000102030405060708090A0B0C0D0E0F1011121314151617 18191A1B1C1D1E1F P: C: FE80690BEE8A485D11F32965BC9D2A32",
      "ja": "N：BBAA9988776655443322110B A：000102030405060708090A0B0C0D0E0F1011121314151617 18191A1B1C1D1E1F P：C：FE80690BEE8A485D11F32965BC9D2A32"
    },
    {
      "indent": 5,
      "text": "N: BBAA9988776655443322110C A: P: 000102030405060708090A0B0C0D0E0F1011121314151617 18191A1B1C1D1E1F C: 2942BFC773BDA23CABC6ACFD9BFD5835BD300F0973792EF4 6040C53F1432BCDFB5E1DDE3BC18A5F840B52E653444D5DF",
      "ja": "N：BBAA9988776655443322110CのA：P：000102030405060708090A0B0C0D0E0F1011121314151617 18191A1B1C1D1E1F C：2942BFC773BDA23CABC6ACFD9BFD5835BD300F0973792EF4 6040C53F1432BCDFB5E1DDE3BC18A5F840B52E653444D5DF"
    },
    {
      "indent": 5,
      "text": "N: BBAA9988776655443322110D A: 000102030405060708090A0B0C0D0E0F1011121314151617 18191A1B1C1D1E1F2021222324252627 P: 000102030405060708090A0B0C0D0E0F1011121314151617 18191A1B1C1D1E1F2021222324252627 C: D5CA91748410C1751FF8A2F618255B68A0A12E093FF45460 6E59F9C1D0DDC54B65E8628E568BAD7AED07BA06A4A69483 A7035490C5769E60",
      "ja": "N：BBAA9988776655443322110D A：000102030405060708090A0B0C0D0E0F1011121314151617 18191A1B1C1D1E1F2021222324252627 P：000102030405060708090A0B0C0D0E0F1011121314151617 18191A1B1C1D1E1F2021222324252627 C：D5CA91748410C1751FF8A2F618255B68A0A12E093FF45460 6E59F9C1D0DDC54B65E8628E568BAD7AED07BA06A4A69483 A7035490C5769E60"
    },
    {
      "indent": 5,
      "text": "N: BBAA9988776655443322110E A: 000102030405060708090A0B0C0D0E0F1011121314151617 18191A1B1C1D1E1F2021222324252627 P: C: C5CD9D1850C141E358649994EE701B68",
      "ja": "N：BBAA9988776655443322110E A：000102030405060708090A0B0C0D0E0F1011121314151617 18191A1B1C1D1E1F2021222324252627 P：C：C5CD9D1850C141E358649994EE701B68"
    },
    {
      "indent": 5,
      "text": "N: BBAA9988776655443322110F A: P: 000102030405060708090A0B0C0D0E0F1011121314151617 18191A1B1C1D1E1F2021222324252627 C: 4412923493C57D5DE0D700F753CCE0D1D2D95060122E9F15 A5DDBFC5787E50B5CC55EE507BCB084E479AD363AC366B95 A98CA5F3000B1479",
      "ja": "N：BBAA9988776655443322110F A：P：000102030405060708090A0B0C0D0E0F1011121314151617 18191A1B1C1D1E1F2021222324252627 C：4412923493C57D5DE0D700F753CCE0D1D2D95060122E9F15 A5DDBFC5787E50B5CC55EE507BCB084E479AD363AC366B95 A98CA5F3000B1479"
    },
    {
      "indent": 3,
      "text": "Next are several internal values generated during the OCB-ENCRYPT computation for the last test vector listed above.",
      "ja": "次は、上記の最後のテストベクトルのOCB-ENCRYPT計算時に発生するいくつかの内部値です。"
    },
    {
      "indent": 5,
      "text": "L_* : C6A13B37878F5B826F4F8162A1C8D879 L_$ : 8D42766F0F1EB704DE9F02C54391B075 L_0 : 1A84ECDE1E3D6E09BD3E058A8723606D L_1 : 3509D9BC3C7ADC137A7C0B150E46C0DA bottom : 15 (decimal) Ktop : 9862B0FDEE4E2DD56DBA6433F0125AA2 Stretch : 9862B0FDEE4E2DD56DBA6433F0125AA2FAD24D13A063F8B8 Offset_0 : 587EF72716EAB6DD3219F8092D517D69 Offset_1 : 42FA1BF908D7D8D48F27FD83AA721D04 Offset_2 : 77F3C24534AD04C7F55BF696A434DDDE Offset_* : B152F972B3225F459A1477F405FC05A7 Checksum_1: 000102030405060708090A0B0C0D0E0F Checksum_2: 10101010101010101010101010101010 Checksum_*: 30313233343536379010101010101010",
      "ja": "L_ *：C6A13B37878F5B826F4F8162A1C8D879 L_ $：8D42766F0F1EB704DE9F02C54391B075 L_0：1A84ECDE1E3D6E09BD3E058A8723606D L_1：3509D9BC3C7ADC137A7C0B150E46C0DA底部：15（10進数）Ktop：9862B0FDEE4E2DD56DBA6433F0125AA2ストレッチ：9862B0FDEE4E2DD56DBA6433F0125AA2FAD24D13A063F8B8 Offset_0：587EF72716EAB6DD3219F8092D517D69 offset_1は：42FA1BF908D7D8D48F27FD83AA721D04 Offset_2：77F3C24534AD04C7F55BF696A434DDDE Offset_ *：B152F972B3225F459A1477F405FC05A7 Checksum_1：000102030405060708090A0B0C0D0E0F Checksum_2：10101010101010101010101010101010 Checksum_ *：30313233343536379010101010101010"
    },
    {
      "indent": 3,
      "text": "The next tuple shows a result with a tag length of 96 bits and a different key.",
      "ja": "次のタプルは、96ビットのタグの長さと異なるキーを持つ結果を示します。"
    },
    {
      "indent": 5,
      "text": "K: 0F0E0D0C0B0A09080706050403020100",
      "ja": "K：0F0E0D0C0B0A09080706050403020100"
    },
    {
      "indent": 5,
      "text": "N: BBAA9988776655443322110D A: 000102030405060708090A0B0C0D0E0F1011121314151617 18191A1B1C1D1E1F2021222324252627 P: 000102030405060708090A0B0C0D0E0F1011121314151617 18191A1B1C1D1E1F2021222324252627 C: 1792A4E31E0755FB03E31B22116E6C2DDF9EFD6E33D536F1 A0124B0A55BAE884ED93481529C76B6AD0C515F4D1CDD4FD AC4F02AA",
      "ja": "N：BBAA9988776655443322110D A：000102030405060708090A0B0C0D0E0F1011121314151617 18191A1B1C1D1E1F2021222324252627 P：000102030405060708090A0B0C0D0E0F1011121314151617 18191A1B1C1D1E1F2021222324252627 C：1792A4E31E0755FB03E31B22116E6C2DDF9EFD6E33D536F1 A0124B0A55BAE884ED93481529C76B6AD0C515F4D1CDD4FD AC4F02AA"
    },
    {
      "indent": 3,
      "text": "The following algorithm tests a wider variety of inputs. Results are given for each parameter set defined in Section 3.1.",
      "ja": "次のアルゴリズムは、入力の幅広い種類をテストします。結果は、3.1節で定義された各パラメータセットのために与えられています。"
    },
    {
      "indent": 6,
      "text": "K = zeros(KEYLEN-8) || num2str(TAGLEN,8) C = <empty string> for i = 0 to 127 do S = zeros(8i) N = num2str(3i+1,96) C = C || OCB-ENCRYPT(K,N,S,S) N = num2str(3i+2,96) C = C || OCB-ENCRYPT(K,N,<empty string>,S) N = num2str(3i+3,96) C = C || OCB-ENCRYPT(K,N,S,<empty string>) end for N = num2str(385,96) Output : OCB-ENCRYPT(K,N,C,<empty string>)",
      "ja": "K =ゼロ（KEYLEN-8）|| 127 I = 0 num2strは（TAGLEN、8）C = <空の文字列が> S =ゼロ（8I）N = num2strは（3I + 1,96）C = Cを行う|| OCB-ENCRYPT（K、N、S、S）N = num2strは（3I + 2,96）C = C || OCB-ENCRYPT（K、N、<空の文字列>、S）N = num2strは（3I + 3,96）C = C || N = num2strは用OCB-ENCRYPT（K、N、S、<空の文字列>）の端部（385,96）出力：OCB-ENCRYPT（K、N、C、<空の文字列>）"
    },
    {
      "indent": 3,
      "text": "Iteration i of the loop adds 2i + (3 * TAGLEN / 8) bytes to C, resulting in an ultimate length for C of 22,400 bytes when TAGLEN == 128, 20,864 bytes when TAGLEN == 192, and 19,328 bytes when TAGLEN == 64. The final OCB-ENCRYPT has an empty plaintext component, so serves only to authenticate C. The output should be:",
      "ja": "Iループの反復が追加2I +（3 * TAGLEN / 8）Cの22,400バイトの最終的な長さが得られ、Cバイト場合TAGLENの== 128、20864バイト場合TAGLENの== 192、及び19328バイトTAGLEN == 64.最終的なOCB-ENCRYPT空平文成分を有するので、出力のみがあるべきC.を認証するのに役立ちます。"
    },
    {
      "indent": 5,
      "text": "AEAD_AES_128_OCB_TAGLEN128 Output: 67E944D23256C5E0B6C61FA22FDF1EA2 AEAD_AES_192_OCB_TAGLEN128 Output: F673F2C3E7174AAE7BAE986CA9F29E17 AEAD_AES_256_OCB_TAGLEN128 Output: D90EB8E9C977C88B79DD793D7FFA161C AEAD_AES_128_OCB_TAGLEN96 Output : 77A3D8E73589158D25D01209 AEAD_AES_192_OCB_TAGLEN96 Output : 05D56EAD2752C86BE6932C5E AEAD_AES_256_OCB_TAGLEN96 Output : 5458359AC23B0CBA9E6330DD AEAD_AES_128_OCB_TAGLEN64 Output : 192C9B7BD90BA06A AEAD_AES_192_OCB_TAGLEN64 Output : 0066BC6E0EF34E24 AEAD_AES_256_OCB_TAGLEN64 Output : 7D4EA5D445501CBE",
      "ja": "AEAD_AES_128_OCB_TAGLEN128出力：67E944D23256C5E0B6C61FA22FDF1EA2 AEAD_AES_192_OCB_TAGLEN128出力：F673F2C3E7174AAE7BAE986CA9F29E17 AEAD_AES_256_OCB_TAGLEN128出力：D90EB8E9C977C88B79DD793D7FFA161C AEAD_AES_128_OCB_TAGLEN96出力：77A3D8E73589158D25D01209 AEAD_AES_192_OCB_TAGLEN96出力：05D56EAD2752C86BE6932C5E AEAD_AES_256_OCB_TAGLEN96出力：5458359AC23B0CBA9E6330DD AEAD_AES_128_OCB_TAGLEN64出力：192C9B7BD90BA06A AEAD_AES_192_OCB_TAGLEN64出力：0066BC6E0EF34E24 AEAD_AES_256_OCB_TAGLEN64出力：7D4EA5D445501CBE"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Ted Krovetz Computer Science Department California State University, Sacramento 6000 J Street Sacramento, CA 95819-6021 USA",
      "ja": "テッドKrovetzコンピュータサイエンス学部カリフォルニア州立大学、サクラメント6000 Jストリートサクラメント、CA 95819から6021 USA"
    },
    {
      "indent": 3,
      "text": "EMail: ted@krovetz.net",
      "ja": "メールアドレス：ted@krovetz.net"
    },
    {
      "indent": 3,
      "text": "Phillip Rogaway Computer Science Department University of California, Davis One Shields Avenue Davis, CA 95616-8562 USA",
      "ja": "カリフォルニア州のフィリップ・ロガウェイコンピュータサイエンス学部大学デービス校の一つシールズアベニューデイビス、CA 95616-8562 USA"
    },
    {
      "indent": 3,
      "text": "EMail: rogaway@cs.ucdavis.edu",
      "ja": "メールアドレス：rogaway@cs.ucdavis.edu"
    }
  ]
}