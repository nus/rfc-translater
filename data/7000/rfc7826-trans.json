{
  "title": {
    "text": "RFC 7826 - Real-Time Streaming Protocol Version 2.0",
    "ja": "RFC 7826 - リアルタイムストリーミングプロトコルバージョン2.0"
  },
  "number": 7826,
  "created_at": "2019-11-02 06:06:49.943802+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                    H. Schulzrinne\nRequest for Comments: 7826                           Columbia University\nObsoletes: 2326                                                   A. Rao\nCategory: Standards Track                                          Cisco\nISSN: 2070-1721                                              R. Lanphier",
      "raw": true
    },
    {
      "indent": 32,
      "text": "                           M. Westerlund\n                                Ericsson\n                     M. Stiemerling, Ed.\nUniversity of Applied Sciences Darmstadt\n                           December 2016",
      "raw": true
    },
    {
      "indent": 16,
      "text": "Real-Time Streaming Protocol Version 2.0",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This memorandum defines the Real-Time Streaming Protocol (RTSP) version 2.0, which obsoletes RTSP version 1.0 defined in RFC 2326.",
      "ja": "このメモは、RFC 2326で定義されたRTSPバージョン1.0を時代遅れリアルタイムストリーミングプロトコル（RTSP）バージョン2.0を定義します。"
    },
    {
      "indent": 3,
      "text": "RTSP is an application-layer protocol for the setup and control of the delivery of data with real-time properties. RTSP provides an extensible framework to enable controlled, on-demand delivery of real-time data, such as audio and video. Sources of data can include both live data feeds and stored clips. This protocol is intended to control multiple data delivery sessions; provide a means for choosing delivery channels such as UDP, multicast UDP, and TCP; and provide a means for choosing delivery mechanisms based upon RTP (RFC 3550).",
      "ja": "RTSPは、リアルタイム特性をもつデータの配信のセットアップおよび制御するためのアプリケーション層プロトコルです。 RTSPは、オーディオやビデオなどのリアルタイムデータの制御され、オンデマンド配信を可能にするための拡張可能なフレームワークを提供します。データのソースはライブデータフィードと保存されたクリップの両方を含めることができます。このプロトコルは、複数のデータ配信セッションを制御するために意図されています。このようUDP、マルチキャストUDP、およびTCPなどの配信チャネルを選択するための手段を提供します。そしてRTP（RFC 3550）に基づいて配信メカニズムを選択するための手段を提供します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 7841のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7826.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7826で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2016 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2016 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 3,
      "text": "This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.",
      "ja": "この材料の一部がIETFトラストにこのような材料の変更を許可する権利を与えられていない可能性がありますにこの文書は、2008年、IETFドキュメントまたは11月10日以前に発行または公開さIETF貢献から著作権を支配する者（複数可）材料を含んでいてもよいですIETF標準化プロセスの外。そのような材料の著作権を管理者（単数または複数）から適切なライセンスを取得することなく、この文書は、IETF標準化過程の外側修正されないかもしれません、そして、それの派生物は、IETF標準化過程の外側に作成されない場合があり、それをフォーマットする以外出版RFCとして、英語以外の言語に翻訳します。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ...................................................10\n2. Protocol Overview ..............................................11\n   2.1. Presentation Description ..................................12\n   2.2. Session Establishment .....................................12\n   2.3. Media Delivery Control ....................................14\n   2.4. Session Parameter Manipulations ...........................15\n   2.5. Media Delivery ............................................16\n        2.5.1. Media Delivery Manipulations .......................16\n   2.6. Session Maintenance and Termination .......................19\n   2.7. Extending RTSP ............................................20\n3. Document Conventions ...........................................21\n   3.1. Notational Conventions ....................................21\n   3.2. Terminology ...............................................21\n4. Protocol Parameters ............................................25\n   4.1. RTSP Version ..............................................25\n   4.2. RTSP IRI and URI ..........................................25\n   4.3. Session Identifiers .......................................28",
      "raw": true
    },
    {
      "indent": 3,
      "text": "   4.4. Media-Time Formats ........................................28\n        4.4.1. SMPTE-Relative Timestamps ..........................28\n        4.4.2. Normal Play Time ...................................29\n        4.4.3. Absolute Time ......................................30\n   4.5. Feature Tags ..............................................31\n   4.6. Message Body Tags .........................................32\n   4.7. Media Properties ..........................................32\n        4.7.1. Random Access and Seeking ..........................33\n        4.7.2. Retention ..........................................34\n        4.7.3. Content Modifications ..............................34\n        4.7.4. Supported Scale Factors ............................34\n        4.7.5. Mapping to the Attributes ..........................35\n5. RTSP Message ...................................................35\n   5.1. Message Types .............................................36\n   5.2. Message Headers ...........................................36\n   5.3. Message Body ..............................................37\n   5.4. Message Length ............................................37\n6. General-Header Fields ..........................................37\n7. Request ........................................................39\n   7.1. Request Line ..............................................40\n   7.2. Request-Header Fields .....................................42\n8. Response .......................................................43\n   8.1. Status-Line ...............................................43\n        8.1.1. Status Code and Reason Phrase ......................43\n   8.2. Response Headers ..........................................47\n9. Message Body ...................................................47\n   9.1. Message Body Header Fields ................................48\n   9.2. Message Body ..............................................49\n   9.3. Message Body Format Negotiation ...........................49\n10. Connections ...................................................50\n   10.1. Reliability and Acknowledgements .........................50\n   10.2. Using Connections ........................................51\n   10.3. Closing Connections ......................................54\n   10.4. Timing Out Connections and RTSP Messages .................56\n   10.5. Showing Liveness .........................................57\n   10.6. Use of IPv6 ..............................................58\n   10.7. Overload Control .........................................58\n11. Capability Handling ...........................................60\n   11.1. Feature Tag: play.basic ..................................62\n12. Pipelining Support ............................................62\n13. Method Definitions ............................................63\n   13.1. OPTIONS ..................................................65\n   13.2. DESCRIBE .................................................66\n   13.3. SETUP ....................................................68\n        13.3.1. Changing Transport Parameters .....................71\n   13.4. PLAY .....................................................72\n        13.4.1. General Usage .....................................72\n        13.4.2. Aggregated Sessions ...............................77",
      "raw": true
    },
    {
      "indent": 3,
      "text": "        13.4.3. Updating Current PLAY Requests ....................78\n        13.4.4. Playing On-Demand Media ...........................81\n        13.4.5. Playing Dynamic On-Demand Media ...................81\n        13.4.6. Playing Live Media ................................81\n        13.4.7. Playing Live with Recording .......................82\n        13.4.8. Playing Live with Time-Shift ......................83\n   13.5. PLAY_NOTIFY ..............................................83\n        13.5.1. End-of-Stream .....................................84\n        13.5.2. Media-Properties-Update ...........................86\n        13.5.3. Scale-Change ......................................87\n   13.6. PAUSE ....................................................89\n   13.7. TEARDOWN .................................................92\n        13.7.1. Client to Server ..................................92\n        13.7.2. Server to Client ..................................93\n   13.8. GET_PARAMETER ............................................94\n   13.9. SET_PARAMETER ............................................96\n   13.10. REDIRECT ................................................98\n14. Embedded (Interleaved) Binary Data ...........................101\n15. Proxies ......................................................103\n   15.1. Proxies and Protocol Extensions .........................104\n   15.2. Multiplexing and Demultiplexing of Messages .............105\n16. Caching ......................................................106\n   16.1. Validation Model ........................................107\n        16.1.1. Last-Modified Dates ..............................108\n        16.1.2. Message Body Tag Cache Validators ................108\n        16.1.3. Weak and Strong Validators .......................108\n        16.1.4. Rules for When to Use Message Body Tags\n                and Last-Modified Dates ..........................110\n        16.1.5. Non-validating Conditionals ......................112\n   16.2. Invalidation after Updates or Deletions .................112\n17. Status Code Definitions ......................................113\n   17.1. Informational 1xx .......................................113\n        17.1.1. 100 Continue .....................................113\n   17.2. Success 2xx .............................................113\n        17.2.1. 200 OK ...........................................113\n   17.3. Redirection 3xx .........................................113\n        17.3.1. 300 ..............................................114\n        17.3.2. 301 Moved Permanently ............................114\n        17.3.3. 302 Found ........................................114\n        17.3.4. 303 See Other ....................................115\n        17.3.5. 304 Not Modified .................................115\n        17.3.6. 305 Use Proxy ....................................115\n   17.4. Client Error 4xx ........................................116\n        17.4.1. 400 Bad Request ..................................116\n        17.4.2. 401 Unauthorized .................................116\n        17.4.3. 402 Payment Required .............................116\n        17.4.4. 403 Forbidden ....................................116\n        17.4.5. 404 Not Found ....................................116",
      "raw": true
    },
    {
      "indent": 3,
      "text": "        17.4.6. 405 Method Not Allowed ...........................117\n        17.4.7. 406 Not Acceptable ...............................117\n        17.4.8. 407 Proxy Authentication Required ................117\n        17.4.9. 408 Request Timeout ..............................117\n        17.4.10. 410 Gone ........................................118\n        17.4.11. 412 Precondition Failed .........................118\n        17.4.12. 413 Request Message Body Too Large ..............118\n        17.4.13. 414 Request-URI Too Long ........................118\n        17.4.14. 415 Unsupported Media Type ......................119\n        17.4.15. 451 Parameter Not Understood ....................119\n        17.4.16. 452 Illegal Conference Identifier ...............119\n        17.4.17. 453 Not Enough Bandwidth ........................119\n        17.4.18. 454 Session Not Found ...........................119\n        17.4.19. 455 Method Not Valid in This State ..............119\n        17.4.20. 456 Header Field Not Valid for Resource .........119\n        17.4.21. 457 Invalid Range ...............................120\n        17.4.22. 458 Parameter Is Read-Only ......................120\n        17.4.23. 459 Aggregate Operation Not Allowed .............120\n        17.4.24. 460 Only Aggregate Operation Allowed ............120\n        17.4.25. 461 Unsupported Transport .......................120\n        17.4.26. 462 Destination Unreachable .....................120\n        17.4.27. 463 Destination Prohibited ......................120\n        17.4.28. 464 Data Transport Not Ready Yet ................121\n        17.4.29. 465 Notification Reason Unknown .................121\n        17.4.30. 466 Key Management Error ........................121\n        17.4.31. 470 Connection Authorization Required ...........121\n        17.4.32. 471 Connection Credentials Not Accepted .........121\n        17.4.33. 472 Failure to Establish Secure Connection ......121\n   17.5. Server Error 5xx ........................................122\n        17.5.1. 500 Internal Server Error ........................122\n        17.5.2. 501 Not Implemented ..............................122\n        17.5.3. 502 Bad Gateway ..................................122\n        17.5.4. 503 Service Unavailable ..........................122\n        17.5.5. 504 Gateway Timeout ..............................123\n        17.5.6. 505 RTSP Version Not Supported ...................123\n        17.5.7. 551 Option Not Supported .........................123\n        17.5.8. 553 Proxy Unavailable ............................123\n18. Header Field Definitions .....................................124\n   18.1. Accept ..................................................134\n   18.2. Accept-Credentials ......................................135\n   18.3. Accept-Encoding .........................................135\n   18.4. Accept-Language .........................................136\n   18.5. Accept-Ranges ...........................................137\n   18.6. Allow ...................................................138\n   18.7. Authentication-Info .....................................138\n   18.8. Authorization ...........................................138\n   18.9. Bandwidth ...............................................139\n   18.10. Blocksize ..............................................140",
      "raw": true
    },
    {
      "indent": 6,
      "text": "18.11. Cache-Control ..........................................140\n18.12. Connection .............................................143\n18.13. Connection-Credentials .................................143\n18.14. Content-Base ...........................................144\n18.15. Content-Encoding .......................................145\n18.16. Content-Language .......................................145\n18.17. Content-Length .........................................146\n18.18. Content-Location .......................................146\n18.19. Content-Type ...........................................148\n18.20. CSeq ...................................................148\n18.21. Date ...................................................150\n18.22. Expires ................................................151\n18.23. From ...................................................151\n18.24. If-Match ...............................................152\n18.25. If-Modified-Since ......................................152\n18.26. If-None-Match ..........................................153\n18.27. Last-Modified ..........................................154\n18.28. Location ...............................................154\n18.29. Media-Properties .......................................154\n18.30. Media-Range ............................................156\n18.31. MTag ...................................................157\n18.32. Notify-Reason ..........................................158\n18.33. Pipelined-Requests .....................................158\n18.34. Proxy-Authenticate .....................................159\n18.35. Proxy-Authentication-Info ..............................159\n18.36. Proxy-Authorization ....................................159\n18.37. Proxy-Require ..........................................160\n18.38. Proxy-Supported ........................................160\n18.39. Public .................................................161\n18.40. Range ..................................................162\n18.41. Referrer ...............................................164\n18.42. Request-Status .........................................164\n18.43. Require ................................................165\n18.44. Retry-After ............................................166\n18.45. RTP-Info ...............................................167\n18.46. Scale ..................................................169\n18.47. Seek-Style .............................................170\n18.48. Server .................................................171\n18.49. Session ................................................172\n18.50. Speed ..................................................173\n18.51. Supported ..............................................174\n18.52. Terminate-Reason .......................................175\n18.53. Timestamp ..............................................175\n18.54. Transport ..............................................176\n18.55. Unsupported ............................................183\n18.56. User-Agent .............................................184\n18.57. Via ....................................................184\n18.58. WWW-Authenticate .......................................185",
      "raw": true
    },
    {
      "indent": 3,
      "text": "19. Security Framework ...........................................185\n   19.1. RTSP and HTTP Authentication ............................185\n        19.1.1. Digest Authentication ............................186\n   19.2. RTSP over TLS ...........................................187\n   19.3. Security and Proxies ....................................188\n        19.3.1. Accept-Credentials ...............................189\n        19.3.2. User-Approved TLS Procedure ......................190\n20. Syntax .......................................................192\n   20.1. Base Syntax .............................................193\n   20.2. RTSP Protocol Definition ................................195\n        20.2.1. Generic Protocol Elements ........................195\n        20.2.2. Message Syntax ...................................198\n        20.2.3. Header Syntax ....................................201\n   20.3. SDP Extension Syntax ....................................209\n21. Security Considerations ......................................209\n   21.1. Signaling Protocol Threats ..............................210\n   21.2. Media Stream Delivery Threats ...........................213\n        21.2.1. Remote DoS Attack ................................215\n        21.2.2. RTP Security Analysis ............................216\n22. IANA Considerations ..........................................217\n   22.1. Feature Tags ............................................218\n        22.1.1. Description ......................................218\n        22.1.2. Registering New Feature Tags with IANA ...........218\n        22.1.3. Registered Entries ...............................219\n   22.2. RTSP Methods ............................................219\n        22.2.1. Description ......................................219\n        22.2.2. Registering New Methods with IANA ................219\n        22.2.3. Registered Entries ...............................220\n   22.3. RTSP Status Codes .......................................220\n        22.3.1. Description ......................................220\n        22.3.2. Registering New Status Codes with IANA ...........220\n        22.3.3. Registered Entries ...............................221\n   22.4. RTSP Headers ............................................221\n        22.4.1. Description ......................................221\n        22.4.2. Registering New Headers with IANA ................221\n        22.4.3. Registered Entries ...............................222\n   22.5. Accept-Credentials ......................................223\n        22.5.1. Accept-Credentials Policies ......................223\n        22.5.2. Accept-Credentials Hash Algorithms ...............224\n   22.6. Cache-Control Cache Directive Extensions ................224\n   22.7. Media Properties ........................................225\n        22.7.1. Description ......................................225\n        22.7.2. Registration Rules ...............................226\n        22.7.3. Registered Values ................................226\n   22.8. Notify-Reason Values ....................................226\n        22.8.1. Description ......................................226\n        22.8.2. Registration Rules ...............................226\n        22.8.3. Registered Values ................................227",
      "raw": true
    },
    {
      "indent": 3,
      "text": "   22.9. Range Header Formats ....................................227\n        22.9.1. Description ......................................227\n        22.9.2. Registration Rules ...............................227\n        22.9.3. Registered Values ................................228\n   22.10. Terminate-Reason Header ................................228\n        22.10.1. Redirect Reasons ................................228\n        22.10.2. Terminate-Reason Header Parameters ..............229\n   22.11. RTP-Info Header Parameters .............................229\n        22.11.1. Description .....................................229\n        22.11.2. Registration Rules ..............................229\n        22.11.3. Registered Values ...............................230\n   22.12. Seek-Style Policies ....................................230\n        22.12.1. Description .....................................230\n        22.12.2. Registration Rules ..............................230\n        22.12.3. Registered Values ...............................230\n   22.13. Transport Header Registries ............................231\n        22.13.1. Transport Protocol Identifier ...................231\n        22.13.2. Transport Modes .................................233\n        22.13.3. Transport Parameters ............................233\n   22.14. URI Schemes ............................................234\n        22.14.1. The \"rtsp\" URI Scheme ...........................234\n        22.14.2. The \"rtsps\" URI Scheme ..........................235\n        22.14.3. The \"rtspu\" URI Scheme ..........................237\n   22.15. SDP Attributes .........................................238\n   22.16. Media Type Registration for text/parameters ............238\n23. References ...................................................240\n   23.1. Normative References ....................................240\n   23.2. Informative References ..................................245\nAppendix A. Examples .............................................248\n   A.1. Media on Demand (Unicast) ................................248\n   A.2. Media on Demand Using Pipelining .........................251\n   A.3. Secured Media Session for On-Demand Content ..............254\n   A.4. Media on Demand (Unicast) ................................257\n   A.5. Single-Stream Container Files ............................260\n   A.6. Live Media Presentation Using Multicast ..................263\n   A.7. Capability Negotiation ...................................264\nAppendix B. RTSP Protocol State Machine ..........................265\n   B.1. States ...................................................266\n   B.2. State Variables ..........................................266\n   B.3. Abbreviations ............................................266\n   B.4. State Tables .............................................267\nAppendix C. Media-Transport Alternatives .........................272\n   C.1. RTP ......................................................272\n     C.1.1. AVP ..................................................272\n     C.1.2. AVP/UDP ..............................................273\n     C.1.3. AVPF/UDP .............................................274\n     C.1.4. SAVP/UDP .............................................275\n     C.1.5. SAVPF/UDP ............................................277",
      "raw": true
    },
    {
      "indent": 3,
      "text": "     C.1.6. RTCP Usage with RTSP .................................278\n   C.2. RTP over TCP .............................................279\n     C.2.1. Interleaved RTP over TCP .............................280\n     C.2.2. RTP over Independent TCP .............................280\n   C.3. Handling Media-Clock Time Jumps in the RTP Media Layer ...284\n   C.4. Handling RTP Timestamps after PAUSE ......................287\n   C.5. RTSP/RTP Integration  ....................................290\n   C.6. Scaling with RTP .........................................290\n   C.7. Maintaining NPT Synchronization with RTP Timestamps ......290\n   C.8. Continuous Audio .........................................290\n   C.9. Multiple Sources in an RTP Session .......................290\n   C.10. Usage of SSRCs and the RTCP BYE Message during an RTSP\n         Session .................................................290\n   C.11. Future Additions ........................................291\nAppendix D. Use of SDP for RTSP Session Descriptions .............292\n   D.1. Definitions  .............................................292\n     D.1.1. Control URI ..........................................292\n     D.1.2. Media Streams ........................................294\n     D.1.3. Payload Type(s) ......................................294\n     D.1.4. Format-Specific Parameters ...........................294\n     D.1.5. Directionality of Media Stream .......................295\n     D.1.6. Range of Presentation ................................295\n     D.1.7. Time of Availability .................................296\n     D.1.8. Connection Information ...............................297\n     D.1.9. Message Body Tag .....................................297\n   D.2. Aggregate Control Not Available ..........................298\n   D.3. Aggregate Control Available ..............................298\n   D.4. Grouping of Media Lines in SDP ...........................299\n   D.5. RTSP External SDP Delivery ...............................300\nAppendix E. RTSP Use Cases .......................................300\n   E.1. On-Demand Playback of Stored Content .....................300\n   E.2. Unicast Distribution of Live Content .....................302\n   E.3. On-Demand Playback Using Multicast .......................303\n   E.4. Inviting an RTSP Server into a Conference ................303\n   E.5. Live Content Using Multicast .............................304\nAppendix F. Text Format for Parameters ...........................305\nAppendix G. Requirements for Unreliable Transport of RTSP ........305\nAppendix H. Backwards-Compatibility Considerations ...............306\n   H.1. Play Request in Play State ...............................307\n   H.2. Using Persistent Connections .............................307\nAppendix I. Changes ..............................................307\n   I.1. Brief Overview ...........................................308\n   I.2. Detailed List of Changes .................................309\nAcknowledgements .................................................316\nContributors  ....................................................317\nAuthors' Addresses ...............................................318",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "This memo defines version 2.0 of the Real-Time Streaming Protocol (RTSP 2.0). RTSP 2.0 is an application-layer protocol for the setup and control over the delivery of data with real-time properties, typically streaming media. Streaming media is, for instance, video on demand or audio live streaming. Put simply, RTSP acts as a \"network remote control\" for multimedia servers.",
      "ja": "このメモは、リアルタイムストリーミングプロトコル（RTSP 2.0）のバージョン2.0を定義します。 RTSP 2.0は、典型的には、ストリーミングメディアをセットアップし、リアルタイム特性をもつデータの配信を制御するためのアプリケーション層プロトコルです。ストリーミングメディアは、例えば、オンデマンドまたはオーディオライブストリーミングの動画です。簡単に言えば、RTSPは、マルチメディアサーバ用の「ネットワークリモートコントロール」として機能します。"
    },
    {
      "indent": 3,
      "text": "The protocol operates between RTSP 2.0 clients and servers, but it also supports the use of proxies placed between clients and servers. Clients can request information about streaming media from servers by asking for a description of the media or use media description provided externally. The media delivery protocol is used to establish the media streams described by the media description. Clients can then request to play out the media, pause it, or stop it completely. The requested media can consist of multiple audio and video streams that are delivered as time-synchronized streams from servers to clients.",
      "ja": "プロトコルは、RTSP 2.0クライアントとサーバの間で作動するが、それはまた、クライアントとサーバの間に配置されたプロキシの使用をサポートしています。クライアントは、メディアの説明を求めることにより、サーバからストリーミングメディアについての情報を要求したり、外部から提供されたメディア記述を使用することができます。メディア配信プロトコルは、メディア記述によって記述されるメディアストリームを確立するために使用されます。クライアントは、その後、メディアを再生、それを一時停止、またはそれを完全に停止するように要求することができます。要求されたメディアは、サーバからクライアントに時間同期ストリームとして配信され、複数のオーディオおよびビデオストリームで構成することができます。"
    },
    {
      "indent": 3,
      "text": "RTSP 2.0 is a replacement of RTSP 1.0 [RFC2326] and this document obsoletes that specification. This protocol is based on RTSP 1.0 but is not backwards compatible other than in the basic version negotiation mechanism. The changes between the two documents are listed in Appendix I. There are many reasons why RTSP 2.0 can't be backwards compatible with RTSP 1.0; some of the main ones are as follows:",
      "ja": "RTSP 2.0 RTSP 1.0 [RFC2326]の置換であり、この文書は、その仕様を時代遅れ。このプロトコルは、RTSP 1.0に基づいていますが、基本的なバージョン交渉メカニズム以外の下位互換性がありません。 2つの文書の変更は、RTSP 2.0は、RTSP 1.0との下位互換性がないことができます多くの理由がありますが、付録Iに記載されています。次のように主なものをいくつか紹介します。"
    },
    {
      "indent": 3,
      "text": "o Most headers that needed to be extensible did not define the allowed syntax, preventing safe deployment of extensions;",
      "ja": "O拡張できるように必要なほとんどのヘッダは拡張の安全な展開を防止し、許可される構文を定義していませんでした。"
    },
    {
      "indent": 3,
      "text": "o the changed behavior of the PLAY method when received in Play state;",
      "ja": "再生状態で受​​信PLAY方法の変更動作O。"
    },
    {
      "indent": 3,
      "text": "o the changed behavior of the extensibility model and its mechanism; and",
      "ja": "拡張モデルとそのメカニズムの変化挙動O。そして"
    },
    {
      "indent": 3,
      "text": "o the change of syntax for some headers.",
      "ja": "いくつかのヘッダーのための構文の変更、O。"
    },
    {
      "indent": 3,
      "text": "There are so many small updates that changing versions became necessary to enable clarification and consistent behavior. Anyone implementing RTSP for a new use case in which they have not installed RTSP 1.0 should only implement RTSP 2.0 to avoid having to deal with RTSP 1.0 inconsistencies.",
      "ja": "変更バージョンが明確化と一貫性のある動作を可能にするために必要になったので、多くの小規模な更新があります。彼らはRTSP 1.0をインストールしていないした新しいユースケースのためにRTSPを実装する誰もが唯一のRTSP 1.0矛盾に対処することを避けるためにRTSP 2.0を実装する必要があります。"
    },
    {
      "indent": 3,
      "text": "This document is structured as follows. It begins with an overview of the protocol operations and its functions in an informal way. Then, a set of definitions of terms used and document conventions is introduced. These are followed by the actual RTSP 2.0 core protocol specification. The appendices describe and define some functionalities that are not part of the core RTSP specification, but which are still important to enable some usages. Among them, the RTP usage is defined in Appendix C, the Session Description Protocol (SDP) usage with RTSP is defined in Appendix D, and the \"text/ parameters\" file format Appendix F, are three normative specification appendices. Other appendices include a number of informational parts discussing the changes, use cases, different considerations or motivations.",
      "ja": "次のようにこの文書では、構成されています。それは非公式な方法でプロトコル操作とその機能の概要から始まります。次に、使用される用語および文書の表記法の定義のセットが導入されます。これらは、実際のRTSP 2.0コアプロトコル仕様が続きます。付録は、説明及びコアRTSP仕様の一部ではないいくつかの機能を定義するが、それでもいくつかの用途を可能にするのに重要です。中でも、RTPの使用は、付録Cに定義され、RTSPとのセッション記述プロトコル（SDP）使用が付録Dに定義され、「テキスト/パラメータ」ファイル形式付録F、3つの規範規格の付録です。その他の付録は情報の変更を議論する部品、ユースケース、別の配慮や動機の数が含まれます。"
    },
    {
      "indent": 0,
      "text": "2. Protocol Overview",
      "section_title": true,
      "ja": "2.プロトコルの概要"
    },
    {
      "indent": 3,
      "text": "This section provides an informative overview of the different mechanisms in the RTSP 2.0 protocol to give the reader a high-level understanding before getting into all the specific details. In case of conflict with this description and the later sections, the later sections take precedence. For more information about use cases considered for RTSP, see Appendix E.",
      "ja": "このセクションでは、すべての特定の詳細に入る前に、読者に高レベルの理解を与えるためにRTSP 2.0プロトコルの異なるメカニズムの有益な概要を提供します。本明細書及び後のセクションと矛盾する場合には、後のセクションが優先されます。 RTSPのために考慮さユースケースの詳細については、付録Eを参照してください。"
    },
    {
      "indent": 3,
      "text": "RTSP 2.0 is a bidirectional request and response protocol that first establishes a context including content resources (the media) and then controls the delivery of these content resources from the provider to the consumer. RTSP has three fundamental parts: Session Establishment, Media Delivery Control, and an extensibility model described below. The protocol is based on some assumptions about existing functionality to provide a complete solution for client-controlled real-time media delivery.",
      "ja": "RTSP 2.0は、第1のコンテンツリソース（メディア）を含むコンテキストを確立した後、消費者へのプロバイダからこれらのコンテンツリソースの配信を制御する双方向要求及び応答プロトコルです。セッションの確立、メディア配信制御、および後述の拡張性モデル：RTSPは、3つの基本的な部分があります。プロトコルは、クライアント制御のリアルタイムメディア配信のための完全なソリューションを提供するために、既存の機能に関するいくつかの仮定に基づいています。"
    },
    {
      "indent": 3,
      "text": "RTSP uses text-based messages, requests and responses, that may contain a binary message body. An RTSP request starts with a method line that identifies the method, the protocol, and version and the resource on which to act. The resource is identified by a URI and the hostname part of the URI is used by RTSP client to resolve the IPv4 or IPv6 address of the RTSP server. Following the method line are a number of RTSP headers. These lines are ended by two consecutive carriage return line feed (CRLF) character pairs. The message body, if present, follows the two CRLF character pairs, and the body's length is described by a message header. RTSP responses are similar, but they start with a response line with the protocol and version followed by a status code and a reason phrase. RTSP messages are sent over a reliable transport protocol between the client and server. RTSP 2.0 requires clients and servers to implement TCP and TLS over TCP as mandatory transports for RTSP messages.",
      "ja": "RTSPは、バイナリメッセージボディを含むことができ、テキストベースのメッセージ、リクエストとレスポンスを、使用しています。 RTSP要求は、メソッドを識別する方法回線、プロトコル、およびバージョンと作用することのリソースで始まります。リソースはURIによって識別され、URIのホスト名部分は、RTSPサーバのIPv4またはIPv6アドレスを解決するためにRTSPクライアントによって使用されます。方法ライン以下のRTSPヘッダーの数です。これらの行は、2つの連続キャリッジリターン改行（CRLF）文字ペアによって終了されています。メッセージ本体は、存在する場合、2 CRLF文字対に従い、体の長さはメッセージヘッダに記載されています。 RTSP応答は似ていますが、ステータスコードと理由フレーズが続くプロトコルおよびバージョンとレスポンス行で始まります。 RTSPメッセージは、クライアントとサーバ間の信頼できるトランスポートプロトコルを介して送信されます。 RTSP 2.0は、RTSPメッセージのための必須のトランスポートとしてTCP上でTCPおよびTLSを実装するために、クライアントとサーバーが必要です。"
    },
    {
      "indent": 0,
      "text": "2.1. Presentation Description",
      "section_title": true,
      "ja": "2.1. プレゼンテーションの説明"
    },
    {
      "indent": 3,
      "text": "RTSP exists to provide access to multimedia presentations and content but tries to be agnostic about the media type or the actual media delivery protocol that is used. To enable a client to implement a complete system, an RTSP-external mechanism for describing the presentation and the delivery protocol(s) is used. RTSP assumes that this description is either delivered completely out of band or as a data object in the response to a client's request using the DESCRIBE method (Section 13.2).",
      "ja": "RTSPは、マルチメディアプレゼンテーションやコンテンツへのアクセスを提供するために存在するが、メディアタイプ又は使用される実際のメディア配信プロトコル約とらわれないことを試みます。完全なシステムを実装するためにクライアントを有効にするために、プレゼンテーション及び配信プロトコル（単数または複数）を説明するためのRTSP-外部機構が使用されます。 RTSPは、本明細書のいずれかの帯域外またはDESCRIBEメソッド（セクション13.2）を使用して、クライアントの要求に応答してデータ・オブジェクトとして完全に送達されることを想定しています。"
    },
    {
      "indent": 3,
      "text": "Parameters that commonly have to be included in the presentation description are the following:",
      "ja": "一般的にプレゼンテーション記述に含まれる必要なパラメータは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o The number of media streams;",
      "ja": "メディアストリームの数は、O。"
    },
    {
      "indent": 3,
      "text": "o the resource identifier for each media stream/resource that is to be controlled by RTSP;",
      "ja": "RTSPによって制御される各メディアストリーム/リソースのリソース識別子O。"
    },
    {
      "indent": 3,
      "text": "o the protocol that will be used to deliver each media stream;",
      "ja": "各メディア・ストリームを配信するために使用されるプロトコルO。"
    },
    {
      "indent": 3,
      "text": "o the transport protocol parameters that are not negotiated or vary with each client;",
      "ja": "ネゴシエートされた各クライアントに応じて変化されていないトランスポートプロトコルパラメータO;"
    },
    {
      "indent": 3,
      "text": "o the media-encoding information enabling a client to correctly decode the media upon reception; and",
      "ja": "正しく受信時にメディアを復号するためにクライアントを可能メディア符号化情報を、O。そして"
    },
    {
      "indent": 3,
      "text": "o an aggregate control resource identifier.",
      "ja": "凝集制御リソース識別子O。"
    },
    {
      "indent": 3,
      "text": "RTSP uses its own URI schemes (\"rtsp\" and \"rtsps\") to reference media resources and aggregates under common control (see Section 4.2).",
      "ja": "RTSPは、（4.2節を参照）共通支配下のメディアリソースと集合体を参照するために、独自のURIスキーム（「RTSP」と「RTSPS」）を使用しています。"
    },
    {
      "indent": 3,
      "text": "This specification describes in Appendix D how one uses SDP [RFC4566] for describing the presentation.",
      "ja": "この仕様は、1つのプレゼンテーションを記述するためのSDP [RFC4566]を使用する方法付録Dに記載されています。"
    },
    {
      "indent": 0,
      "text": "2.2. Session Establishment",
      "section_title": true,
      "ja": "2.2. セッションの確立"
    },
    {
      "indent": 3,
      "text": "The RTSP client can request the establishment of an RTSP session after having used the presentation description to determine which media streams are available, which media delivery protocol is used, and the resource identifiers of the media streams. The RTSP session is a common context between the client and the server that consists of one or more media resources that are to be under common media delivery control.",
      "ja": "RTSPクライアントは、メディアストリームが使用されるメディア配信プロトコル、利用可能であるかを決定するためにプレゼンテーション記述を使用した後にRTSPセッションの確立を要求し、メディアストリームのリソース識別子ができます。 RTSPセッションは、クライアントと共通のメディア配信制御下にある1つまたは複数のメディアリソースで構成され、サーバとの間で共通のコンテキストです。"
    },
    {
      "indent": 3,
      "text": "The client creates an RTSP session by sending a request using the SETUP method (Section 13.3) to the server. In the Transport header (Section 18.54) of the SETUP request, the client also includes all",
      "ja": "クライアントは、サーバーへのセットアップ方法（13.3節）を使用して要求を送信することにより、RTSPセッションを作成します。 SETUP要求の転送ヘッダ（セクション18.54）において、クライアントは、すべて含まれ"
    },
    {
      "indent": 3,
      "text": "the transport parameters necessary to enable the media delivery protocol to function. This includes parameters that are preestablished by the presentation description but necessary for any middlebox to correctly handle the media delivery protocols. The Transport header in a request may contain multiple alternatives for media delivery in a prioritized list, which the server can select from. These alternatives are typically based on information in the presentation description.",
      "ja": "関数へのメディア配信プロトコルを可能にするのに必要なトランスポートパラメータ。これは正しくメディア配信プロトコルを処理するために、任意のミドルのためのプレゼンテーション記述が、必要により予め確立されたパラメータを含んでいます。要求にトランスポートヘッダは、サーバが選択できる優先順位リストにおけるメディア配信のための複数の代替を含むことができます。これらの代替は、一般的にプレゼンテーション記述の情報に基づいています。"
    },
    {
      "indent": 3,
      "text": "When receiving a SETUP request, the server determines if the media resource is available and if one or more of the of the transport parameter specifications are acceptable. If that is successful, an RTSP session context is created and the relevant parameters and state is stored. An identifier is created for the RTSP session and included in the response in the Session header (Section 18.49). The SETUP response includes a Transport header that specifies which of the alternatives has been selected and relevant parameters.",
      "ja": "SETUP要求を受信すると、トランスポートパラメータ仕様の1つ以上が許容される場合、メディアリソースが使用可能であれば、サーバが決定します。それが成功した場合、RTSPセッションのコンテキストが作成され、関連するパラメータと状態が保存されています。識別子は、RTSPセッションのために作成され、セッション・ヘッダ（セクション18.49）での応答に含まれています。 SETUP応答は、選択肢の選択と関連されたパラメータを指定するトランスポート・ヘッダを含んでいます。"
    },
    {
      "indent": 3,
      "text": "A SETUP request that references an existing RTSP session but identifies a new media resource is a request to add that media resource under common control with the already-present media resources in an aggregated session. A client can expect this to work for all media resources under RTSP control within a multimedia content container. However, a server will likely refuse to aggregate resources from different content containers. Even if an RTSP session contains only a single media stream, the RTSP session can be referenced by the aggregate control URI.",
      "ja": "既存のRTSPセッションを参照するが、新しいメディアリソースを識別するSETUP要求が集約されたセッションで既に存在メディアリソースと共通の制御下で、そのメディアリソースを追加するための要求です。クライアントは、これは、マルチメディアコンテンツコンテナ内でRTSPの制御下にあるすべてのメディアリソースのために働くことを期待することができます。ただし、サーバーはおそらく異なるコンテンツコンテナからリソースを集約することを拒否します。 RTSPセッションは、単一のメディアストリームが含まれている場合でも、RTSPセッションは集約コントロールURIで参照することができます。"
    },
    {
      "indent": 3,
      "text": "To avoid an extra round trip in the session establishment of aggregated RTSP sessions, RTSP 2.0 supports pipelined requests; i.e., the client can send multiple requests back-to-back without waiting first for the completion of any of them. The client uses a client-selected identifier in the Pipelined-Requests header (Section 18.33) to instruct the server to bind multiple requests together as if they included the session identifier.",
      "ja": "集約されたRTSPセッションのセッション確立中に余分なラウンドトリップを回避するために、RTSP 2.0は、パイプラインの要求をサポートしています。すなわち、クライアントはそれらのいずれかの完了を待たず最初のバックツーバック複数の要求を送信することができます。クライアントは、彼らがセッション識別子が含まれている場合のように一緒に複数の要求をバインドするようにサーバーを指示するパイプライン・リクエストヘッダ（セクション18.33）にクライアント選択された識別子を使用します。"
    },
    {
      "indent": 3,
      "text": "The SETUP response also provides additional information about the established sessions in a couple of different headers. The Media-Properties header (Section 18.29) includes a number of properties that apply for the aggregate that is valuable when doing media delivery control and configuring user interface. The Accept-Ranges header (Section 18.5) informs the client about range formats that the server supports for these media resources. The Media-Range header (Section 18.30) informs the client about the time range of the media currently available.",
      "ja": "SETUP応答も異なるヘッダのカップルで確立されたセッションに関する追加情報を提供します。メディアプロパティヘッダ（セクション18.29）は、メディア配信制御を実行し、ユーザーインターフェースを設定する際に有用である骨材のために適用されるプロパティの数を含みます。受け入れ-範囲ヘッダー（セクション18.5）は、サーバがこれらのメディアリソースのサポート範囲のフォーマットについてクライアントに通知します。メディア-Rangeヘッダ（セクション18.30）は、現在利用可能なメディアの時間範囲についてクライアントに通知します。"
    },
    {
      "indent": 0,
      "text": "2.3. Media Delivery Control",
      "section_title": true,
      "ja": "2.3. メディア配信制御"
    },
    {
      "indent": 3,
      "text": "After having established an RTSP session, the client can start controlling the media delivery. The basic operations are \"begin playback\", using the PLAY method (Section 13.4) and \"suspend (pause) playback\" by using the PAUSE method (Section 13.6). PLAY also allows for choosing the starting media position from which the server should deliver the media. The positioning is done by using the Range header (Section 18.40) that supports several different time formats: Normal Play Time (NPT) (Section 4.4.2), Society of Motion Picture and Television Engineers (SMPTE) Timestamps (Section 4.4.1), and absolute time (Section 4.4.3). The Range header also allows the client to specify a position where delivery should end, thus allowing a specific interval to be delivered.",
      "ja": "RTSPセッションを確立した後、クライアントは、メディア配信の制御を開始することができます。基本的な動作は、PAUSE方法（セクション13.6）を使用して、PLAYメソッド（13.4）と、「サスペンド（一時停止）再生」を使用して、「再生開始」されます。 PLAYは、サーバーがメディアを配信する必要があり、そこから始まるメディア位置を選択することができます。映画テレビ技術者協会（SMPTE）タイムスタンプ（4.4.1項）、通常再生時間（NPT）（4.4.2）：位置決めは、いくつかの異なる時間形式をサポートしています（項18.40）Rangeヘッダを使用して行われます、絶対時間（セクション4.4.3）。 Rangeヘッダは、クライアントは、このように送達されるべき特定の間隔を可能にする、配信が終了すべき位置を指定することができます。"
    },
    {
      "indent": 3,
      "text": "The support for positioning/searching within media content depends on the content's media properties. Content exists in a number of different types, such as on-demand, live, and live with simultaneous recording. Even within these categories, there are differences in how the content is generated and distributed, which affect how it can be accessed for playback. The properties applicable for the RTSP session are provided by the server in the SETUP response using the Media-Properties header (Section 18.29). These are expressed using one or several independent attributes. A first attribute is Random-Access, which indicates whether positioning is possible, and with what granularity. Another aspect is whether the content will change during the lifetime of the session. While on-demand content will be provided in full from the beginning, a live stream being recorded results in the length of the accessible content growing as the session goes on. There also exists content that is dynamically built by a protocol other than RTSP and, thus, also changes in steps during the session, but maybe not continuously. Furthermore, when content is recorded, there are cases where the complete content is not maintained, but, for example, only the last hour. All of these properties result in the need for mechanisms that will be discussed below.",
      "ja": "位置決め/メディアコンテンツ内での検索をサポートするには、コンテンツのメディア特性に依存します。コンテンツは、ライブなど、オンデマンドなど、異なる種類、数に存在し、同時録画と一緒に住んでいます。でも、これらのカテゴリの中に、それは再生のためにアクセスすることができますどのように影響を与えるコンテンツが生成され、どのように分配されるかの違いが、あります。 RTSPセッションに適用可能なプロパティは、メディアプロパティヘッダ（セクション18.29）を使用して、SETUP応答のサーバによって提供されます。これらは、一つまたは複数の独立した属性を使用して表現されています。最初の属性は、位置決めが可能であるかどうかを示すランダムアクセス、そしてどのような粒度です。もう一つの側面は、コンテンツは、セッションの存続期間中に変更されるかどうかです。オンデマンドコンテンツが最初からフルで提供されますが、セッションが進むにつれて、ライブストリームは、成長してアクセス可能なコンテンツの長さで結果を記録しています。また、動的にRTSPと、このように、また、セッション中に段階的に変更する以外のプロトコルによって構築されているコンテンツは多分ない連続し、存在します。コンテンツが記録されている場合さらに、完全なコンテンツは、最後の時間を維持し、しかし、例えばされていない場合があります。これらの性質のすべては、以下に説明するメカニズムが必要になります。"
    },
    {
      "indent": 3,
      "text": "When the client accesses on-demand content that allows random access, the client can issue the PLAY request for any point in the content between the start and the end. The server will deliver media from the closest random access point prior to the requested point and indicate that in its PLAY response. If the client issues a PAUSE, the delivery will be halted and the point at which the server stopped will be reported back in the response. The client can later resume by sending a PLAY request without a Range header. When the server is about to complete the PLAY request by delivering the end of the content or the requested range, the server will send a PLAY_NOTIFY request (Section 13.5) indicating this.",
      "ja": "クライアントは、ランダムアクセスを可能にする、オンデマンドコンテンツにアクセスすると、クライアントは、開始と終了の間でコンテンツ内の任意のポイントのためのPLAY要求を発行することができます。サーバーは、最も近いランダムアクセスポイントから前に要求されたポイントにメディアを配信し、そのPLAY応答であることを示します。クライアントは、PAUSEを発行した場合、配信が停止され、サーバーが停止した時点では対応して戻って報告されます。クライアントは、後にRangeヘッダなしPLAY要求を送信することで再開することができます。サーバは、コンテンツまたは要求された範囲の終わりを提供することにより、PLAY要求を完了しようとしている場合、サーバはこれを示すPLAY_NOTIFY要求（セクション13.5）を送信します。"
    },
    {
      "indent": 3,
      "text": "When playing live content with no extra functions, such as recording, the client will receive the live media from the server after having sent a PLAY request. Seeking in such content is not possible as the server does not store it, but only forwards it from the source of the session. Thus, delivery continues until the client sends a PAUSE request, tears down the session, or the content ends.",
      "ja": "これらの記録として余分な機能を備えたライブコンテンツを再生する場合、クライアントはPLAY要求を送信した後、サーバーからライブメディアを受け取ることになります。このようなコンテンツを探していると、サーバはそれを保存しないようことはできませんが、唯一のセッションのソースからそれを転送します。クライアントは、PAUSE要求を送信し、セッションを切断し、またはコンテンツが終了するまでこのように、配信が継続されます。"
    },
    {
      "indent": 3,
      "text": "For live sessions that are being recorded, the client will need to keep track of how the recording progresses. Upon session establishment, the client will learn the current duration of the recording from the Media-Range header. Because the recording is ongoing, the content grows in direct relation to the time passed. Therefore, each server's response to a PLAY request will contain the current Media-Range header. The server should also regularly send (approximately every 5 minutes) the current media range in a PLAY_NOTIFY request (Section 13.5.2). If the live transmission ends, the server must send a PLAY_NOTIFY request with the updated Media-Properties indicating that the content stopped being a recorded live session and instead became on-demand content; the request also contains the final media range. While the live delivery continues, the client can request to play the current live point by using the NPT timescale symbol \"now\", or it can request a specific point in the available content by an explicit range request for that point. If the requested point is outside of the available interval, the server will adjust the position to the closest available point, i.e., either at the beginning or the end.",
      "ja": "記録されているライブ・セッションでは、クライアントは、記録の進行状況を追跡する必要があります。セッション確立時に、クライアントはメディア-Rangeヘッダからの記録の現在の期間を学びます。記録が進行中であるため、コンテンツが渡された時に直接関係して成長します。したがって、PLAY要求に対する各サーバの応答は、現在のメディア-Rangeヘッダを含んでいます。また、サーバは定期的にPLAY_NOTIFY要求（13.5.2項）に現在のメディアの範囲を（約5分ごとに）送信する必要があります。ライブ送信が終了した場合、サーバは、コンテンツが記録されてライブセッションを停止し、代わりにオンデマンドコンテンツになったことを示す更新されたメディア・プロパティとPLAY_NOTIFY要求を送信する必要があります。リクエストはまた、最終的なメディアの範囲が含まれています。ライブ配信が継続している間、クライアントは「今」NPTタイムスケールの記号を使用して、現在のライブのポイントを再生するために要求することができ、またはそれは、その点の明示的な範囲の要求によって利用可能なコンテンツ内の特定のポイントを要求することができます。要求されたポイントが利用可能な区間の外にある場合、サーバは、いずれかの先頭または末尾に、最も近い利用可能な点、即ち位置を調整します。"
    },
    {
      "indent": 3,
      "text": "A special case of recording is that where the recording is not retained longer than a specific time period; thus, as the live delivery continues, the client can access any media within a moving window that covers, for example, \"now\" to \"now\" minus 1 hour. A client that pauses on a specific point within the content may not be able to retrieve the content anymore. If the client waits too long before resuming the pause point, the content may no longer be available. In this case, the pause point will be adjusted to the closest point in the available media.",
      "ja": "記録の特別な場合は、記録が特定の期間よりも長く保持されない場合ということです。ライブ配信が継続するので、クライアントは、「今」マイナス1時間に例えば、「今」、カバー移動ウィンドウ内の任意のメディアにアクセスすることができます。コンテンツ内の特定のポイントで一時停止し、クライアントはもうコンテンツを取得することができないかもしれません。クライアントが一時停止地点を再開する前に、あまりにも長い間待っている場合、コンテンツが利用できなくなることがあります。この場合には、一時停止ポイントは、利用可能なメディア内の最も近い点に調整されます。"
    },
    {
      "indent": 0,
      "text": "2.4. Session Parameter Manipulations",
      "section_title": true,
      "ja": "2.4. セッション・パラメータマニピュレーション"
    },
    {
      "indent": 3,
      "text": "A session may have additional state or functionality that affects how the server or client treats the session or content, how it functions, or feedback on how well the session works. Such extensions are not defined in this specification, but they may be covered in various extensions. RTSP has two methods for retrieving and setting parameter values on either the client or the server: GET_PARAMETER (Section 13.8) and SET_PARAMETER (Section 13.9). These methods carry the parameters in a message body of the appropriate format. One can also use headers to query state with the GET_PARAMETER method. As an example, clients needing to know the current media range for a time-progressing session can use the GET_PARAMETER method and include the media range. Furthermore, synchronization information can be requested by using a combination of RTP-Info (Section 18.45) and Range (Section 18.40).",
      "ja": "セッションはどれだけセッションが正常に機能の追加や機能の状態に機能するか、サーバーまたはクライアントがセッションやコンテンツを扱う方法に影響を与え、またはフィードバックを有することができます。このような拡張は、この仕様で定義されていないが、彼らは様々な拡張で覆われていてもよいです。 GET_PARAMETER（セクション13.8）とSET_PARAMETER（セクション13.9）：RTSPは、クライアントまたはサーバーのいずれかでパラメータ値を取得し、設定するための二つの方法があります。これらの方法は、適切なフォーマットのメッセージ本体のパラメータを運びます。一つは、また、GET_PARAMETERメソッドで状態を照会するためにヘッダーを使用することができます。一例として、時間進行セッションの現在のメディアの範囲を知る必要クライアントがGET_PARAMETER方法を使用して、メディア範囲を含むことができます。また、同期情報は、RTP-INFO（セクション18.45）及び範囲（セクション18.40）の組み合わせを使用して要求することができます。"
    },
    {
      "indent": 3,
      "text": "RTSP 2.0 does not have a strong mechanism for negotiating the headers or parameters and their formats. However, responses will indicate request-headers or parameters that are not supported. A priori determination of what features are available needs to be done through out-of-band mechanisms, like the session description, or through the usage of feature tags (Section 4.5).",
      "ja": "RTSP 2.0は、ヘッダやパラメータとそのフォーマットを交渉するための強力なメカニズムを持っていません。しかし、応答はサポートされていないリクエストのヘッダーまたはパラメータを示します。機能が利用可能であるかの先験的決意は、セッション記述のような、又は特徴タグ（セクション4.5）の使用を介して、アウトオブバンドメカニズムを介して行われる必要があります。"
    },
    {
      "indent": 0,
      "text": "2.5. Media Delivery",
      "section_title": true,
      "ja": "2.5. メディア配信"
    },
    {
      "indent": 3,
      "text": "This document specifies how media is delivered with RTP [RFC3550] over UDP [RFC768], TCP [RFC793], or the RTSP connection. Additional protocols may be specified in the future as needed.",
      "ja": "この文書では、メディアがUDP [RFC768]、TCP [RFC793]、またはRTSP接続を通じてRTP [RFC3550]で配信される方法を指定します。必要に応じて、追加のプロトコルは、将来的に指定することができます。"
    },
    {
      "indent": 3,
      "text": "The usage of RTP as a media delivery protocol requires some additional information to function well. The PLAY response contains information to enable reliable and timely delivery of how a client should synchronize different sources in the different RTP sessions. It also provides a mapping between RTP timestamps and the content-time scale. When the server wants to notify the client about the completion of the media delivery, it sends a PLAY_NOTIFY request to the client. The PLAY_NOTIFY request includes information about the stream end, including the last RTP sequence number for each stream, thus enabling the client to empty the buffer smoothly.",
      "ja": "メディア配信プロトコルとしてRTPの使用は、十分に機能するためにいくつかの追加情報を必要とします。 PLAY応答は、クライアントが異なるRTPセッションで異なるソースを同期する方法の信頼性とタイムリーな配信を可能にするための情報が含まれています。また、RTPタイムスタンプとコンテンツ・時間スケールとの間のマッピングを提供します。サーバーは、メディア配信の完了についてクライアントに通知したい場合は、クライアントにPLAY_NOTIFY要求を送信します。 PLAY_NOTIFY要求がスムーズバッファを空にするクライアントを有効、各ストリームの最後のRTPシーケンス番号を含むストリーム終端に関する情報を含みます。"
    },
    {
      "indent": 0,
      "text": "2.5.1. Media Delivery Manipulations",
      "section_title": true,
      "ja": "2.5.1. メディア配信マニピュレーション"
    },
    {
      "indent": 3,
      "text": "The basic playback functionality of RTSP enables delivery of a range of requested content to the client at the pace intended by the content's creator. However, RTSP can also manipulate the delivery to the client in two ways.",
      "ja": "RTSPの基本的な再生機能は、コンテンツの作成者が意図したペースでクライアントに要求されたコンテンツの範囲の配信を可能にします。しかし、RTSPは、2つの方法でクライアントへの配信を操作することができます。"
    },
    {
      "indent": 3,
      "text": "Scale: The ratio of media-content time delivered per unit of playback time.",
      "ja": "スケール：再生単位時間当たりに配信されるメディア・コンテンツの時間の割合。"
    },
    {
      "indent": 3,
      "text": "Speed: The ratio of playback time delivered per unit of wallclock time.",
      "ja": "スピード：壁時計時間の単位あたりの配信再生時間の割合。"
    },
    {
      "indent": 3,
      "text": "Both affect the media delivery per time unit. However, they manipulate two independent timescales and the effects are possible to combine.",
      "ja": "どちらも、単位時間あたりのメディア配信に影響を与えます。しかし、彼らは、2つの独立したタイムスケールを操作し、効果は組み合わせることも可能です。"
    },
    {
      "indent": 3,
      "text": "Scale (Section 18.46) is used for fast-forward or slow-motion control as it changes the amount of content timescale that should be played back per time unit. Scale > 1.0, means fast forward, e.g., scale = 2.0 results in that 2 seconds of content being played back every second of playback. Scale = 1.0 is the default value that is used if no scale is specified, i.e., playback at the content's original rate. Scale values between 0 and 1.0 provide for slow motion. Scale can be negative to allow for reverse playback in either regular pace (scale = -1.0), fast backwards (scale < -1.0), or slow-motion backwards (-1.0 < scale < 0). Scale = 0 would be equal to pause and is not allowed.",
      "ja": "それは単位時間当たりに再生されるべきコンテンツタイムスケールの量を変化させるようにスケール（セクション18.46）は、早送りまたはスローモーション制御のために使用されます。 > 1.0のスケールは、バック再生の毎秒再生中のコンテンツの2秒で、例えば、スケール= 2.0結果、早送りを意味します。スケール= 1.0、コンテンツの元の速度でデフォルト全くスケールが指定されていない場合に使用されている値、即ち、再生されます。 0と1.0の間のスケール値は、スローモーションを提供します。スケールは、定期的なペース（スケール= -1.0）のいずれかで逆再生を可能にするために陰性であることができ、高速逆方向（スケール<-1.0）、または後方スローモーション（-1.0 <スケール<0）。スケール= 0は一時停止に等しくなると、許可されていません。"
    },
    {
      "indent": 3,
      "text": "In most cases, the realization of scale means server-side manipulation of the media to ensure that the client can actually play it back. The nature of these media manipulations and when they are needed is highly media-type dependent. Let's consider two common media types, audio and video.",
      "ja": "ほとんどの場合、スケールの実現には、クライアントが実際にそれを再生することができることを保証するために、メディアのサーバー側の操作を意味しています。これらの情報操作の性質及びそれらが必要とされる依存性の高いメディアタイプです。のは、2つの一般的なメディアタイプ、オーディオとビデオを見てみましょう。"
    },
    {
      "indent": 3,
      "text": "It is very difficult to modify the playback rate of audio. Typically, no more than a factor of two is possible while maintaining intelligibility by changing the pitch and rate of speech. Music goes out of tune if one tries to manipulate the playback rate by resampling it. This is a well-known problem, and audio is commonly muted or played back in short segments with skips to keep up with the current playback point.",
      "ja": "オーディオの再生速度を変更することは非常に困難です。音声のピッチや速度を変えることにより、明瞭度を維持しながら、典型的には、どの2つの要因よりも不可能です。 1がそれをリサンプリングによって、再生速度を操作しようとすると、音楽は曲の外に出ます。これは、よく知られた問題であり、音声は、一般的にミュートまたは現在の再生時点に追いつくためにスキップして短いセグメントで再生されます。"
    },
    {
      "indent": 3,
      "text": "For video, it is possible to manipulate the frame rate, although the rendering capabilities are often limited to certain frame rates. Also, the allowed bitrates in decoding, the structure used in the encoding, and the dependency between frames and other capabilities of the rendering device limits the possible manipulations. Therefore, the basic fast-forward capabilities often are implemented by selecting certain subsets of frames.",
      "ja": "レンダリング機能は、多くの場合、特定のフレームレートに制限されていますが、ビデオの場合、フレームレートを操作することが可能です。また、復号に許容ビットレート、符号化に使用される構造、及びフレーム及びレンダリング装置の可能な操作を制限する他の機能間の依存関係。そのため、基本的な早送り機能は、多くの場合、フレームの特定のサブセットを選択することで実現されています。"
    },
    {
      "indent": 3,
      "text": "Due to the media restrictions, the possible scale values are commonly restricted to the set of realizable scale ratios. To enable the clients to select from the possible scale values, RTSP can signal the supported scale ratios for the content. To support aggregated or dynamic content, where this may change during the ongoing session and dependent on the location within the content, a mechanism for updating the media properties and the scale factor currently in use, exists.",
      "ja": "メディア規制に、可能なスケール値は、一般的に実現可能なスケール比のセットに制限されています。可能なスケール値から選択するようにクライアントを有効にするために、RTSPは、コンテンツのためのサポートされているスケール比をシグナリングすることができます。凝集または動的コンテンツをサポートするために、ここでこれは、進行中のセッション中に変更して、コンテンツ内の位置に依存することができる、現在使用中のメディア特性とスケール係数を更新するための機構が存在します。"
    },
    {
      "indent": 3,
      "text": "Speed (Section 18.50) affects how much of the playback timeline is delivered in a given wallclock period. The default is Speed = 1 which means to deliver at the same rate the media is consumed. Speed > 1 means that the receiver will get content faster than it regularly would consume it. Speed < 1 means that delivery is slower than the regular media rate. Speed values of 0 or lower have no meaning and are not allowed. This mechanism enables two general functionalities. One is client-side scale operations, i.e., the client receives all the frames and makes the adjustment to the playback locally. The second is delivery control for the buffering of media. By specifying a speed over 1.0, the client can build up the amount of playback time it has present in its buffers to a level that is sufficient for its needs.",
      "ja": "スピード（セクション18.50）が与えられた壁時計の期間に配信されますどのくらいの再生タイムラインの影響を与えます。デフォルトでは、メディアが消費されているのと同じレートで配信することを意味しているスピード= 1です。 > 1速度は、受信機がより速く、それが定期的に消費してしまうよりも、コンテンツを取得することを意味します。スピード<1は、配信が通常のメディアレートよりも遅いことを意味しています。 0以下の速度値は意味がありませんし、許可されていません。このメカニズムは、二つの一般的な機能を可能にします。一方、すなわち、クライアントは、すべてのフレームを受信し、ローカル再生の調整を行い、クライアント側の規模操作です。第二は、メディアのバッファリングのための配信制御です。 1.0よりも速度を指定することで、クライアントは、そのニーズに十分なレベルにまでそのバッファ内に存在している再生時間の量を構築することができます。"
    },
    {
      "indent": 3,
      "text": "A naive implementation of Speed would only affect the transmission schedule of the media and has a clear impact on the needed bandwidth. This would result in the data rate being proportional to the speed factor. Speed = 1.5, i.e., 50% faster than normal delivery, would result in a 50% increase in the data-transport rate. Whether or not that can be supported depends solely on the underlying network path. Scale may also have some impact on the required bandwidth due to the manipulation of the content in the new playback schedule. An example is fast forward where only the independently decodable intra-frames are included in the media stream. This usage of solely intra-frames increases the data rate significantly compared to a normal sequence with the same number of frames, where most frames are encoded using prediction.",
      "ja": "スピードの素朴な実装では、メディアのみの送信スケジュールに影響し、必要な帯域幅に明確な影響を与えているでしょう。これは、データ・レートは、速度係数に比例することになります。速度= 1.5、すなわち、通常の配達よりも50％速く、データ輸送速度が50％増加をもたらすであろう。サポートすることができるかどうかは、基礎となるネットワークパスのみに依存します。スケールはまた、新しい再生スケジュール内のコンテンツの操作に必要な帯域幅に何らかの影響を与える可能性があります。例は、独立して復号可能なイントラフレームは、メディア・ストリームに含まれて早送りです。のみイントラフレームのこの使用は、大幅最もフレームは予測を用いて符号化されたフレームの同じ数と正常配列と比較して、データレートを増加させます。"
    },
    {
      "indent": 3,
      "text": "This potential increase of the data rate needs to be handled by the media sender. The client has requested that the media be delivered in a specific way, which should be honored. However, the media sender cannot ignore if the network path between the sender and the receiver can't handle the resulting media stream. In that case, the media stream needs to be adapted to fit the available resources of the path. This can result in a reduced media quality.",
      "ja": "データ・レートのこの潜在的な増加は、メディアの送信者によって扱われる必要があります。クライアントは、メディアが表彰されるべき特定の方法、で配信されることを要求しています。送信側と受信側の間のネットワークパスが得られるメディア・ストリームを処理できない場合は、メディアの送信側は無視できません。その場合には、メディアストリームは、パスの利用可能なリソースに合わせて適応させる必要があります。これは減少し、メディアの品質をもたらす可能性があります。"
    },
    {
      "indent": 3,
      "text": "The need for bitrate adaptation becomes especially problematic in connection with the Speed semantics. If the goal is to fill up the buffer, the client may not want to do that at the cost of reduced quality. If the client wants to make local playout changes, then it may actually require that the requested speed be honored. To resolve this issue, Speed uses a range so that both cases can be supported. The server is requested to use the highest possible speed value within the range, which is compatible with the available bandwidth. As long as the server can maintain a speed value within the range, it shall not change the media quality, but instead modify the actual delivery rate in response to available bandwidth and reflect this in the Speed value in the response. However, if this is not possible, the server should instead modify the media quality to respect the lowest speed value and the available bandwidth.",
      "ja": "ビットレート適応の必要性は、スピードの意味に関連して、特に問題となります。目標は、バッファを埋めるためにある場合、クライアントは、品質低下のコストでそれを行うにはしたくないかもしれません。クライアントは、ローカルプレイアウト変更を行いたい場合は、それが実際に要求速度が表彰されることを必要とするかもしれません。両方のケースがサポートできるように、この問題を解決するには、スピードレンジを使用しています。サーバは、利用可能な帯域幅と互換性がある範囲内で可能な最高速度値を使用することが要求されます。限り、サーバーが範囲内の速度値を維持することができるように、メディア品質を変更してはならないが、その代わりに利用可能な帯域幅に応じて、実際の送達速度を変更し、応答速度値でこれを反映しています。これが不可能な場合は、サーバーではなく、最低速度値と使用可能な帯域幅を尊重するために、メディアの品質を変更する必要があります。"
    },
    {
      "indent": 3,
      "text": "This functionality enables the local scaling implementation to use a tight range, or even a range where the lower bound equals the upper bound, to identify that it requires the server to deliver the requested amount of media time per delivery time, independent of how much it needs to adapt the media quality to fit within the available path bandwidth. For buffer filling, it is suitable to use a range with a reasonable span and with a lower bound at the nominal media rate 1.0, such as 1.0 - 2.5. If the client wants to reduce the buffer, it can specify an upper bound that is below 1.0 to force the server to deliver slower than the nominal media rate.",
      "ja": "この機能は、それは配達時間あたりのメディア時間の要求された量を送達するためのサーバが必要であることを識別するために、下限が上限と等しいタイトな範囲、あるいは範囲を使用するためにどれだけの独立した局所的なスケーリングの実装を可能にし、それ利用できるパスの帯域幅内に収まるようにメディアの品質を適応する必要があります。 2.5  - バッファの充填のために、名目メディアレート1.0、等1.0で妥当スパンと下限との範囲を使用することが好適です。クライアントはバッファを削減したい場合、それは名目メディアレートよりも遅い提供するために、サーバーを強制的に1.0を下回っているという上限を指定することができます。"
    },
    {
      "indent": 0,
      "text": "2.6. Session Maintenance and Termination",
      "section_title": true,
      "ja": "2.6. セッションのメンテナンスと終了"
    },
    {
      "indent": 3,
      "text": "The session context that has been established is kept alive by having the client show liveness. This is done in two main ways:",
      "ja": "確立されたセッション・コンテキストは、クライアントのショーの生存性を持つことによって生かされています。これは主に二つの方法で行われます。"
    },
    {
      "indent": 3,
      "text": "o Media-transport protocol keep-alive. RTP Control Protocol (RTCP) may be used when using RTP.",
      "ja": "O-メディアトランスポートプロトコルのキープアライブ。 RTPを使用する場合にRTP制御プロトコル（RTCP）を使用することができます。"
    },
    {
      "indent": 3,
      "text": "o Any RTSP request referencing the session context.",
      "ja": "セッションコンテキストを参照する任意のRTSP要求O。"
    },
    {
      "indent": 3,
      "text": "Section 10.5 discusses the methods for showing liveness in more depth. If the client fails to show liveness for more than the established session timeout value (normally 60 seconds), the server may terminate the context. Other values may be selected by the server through the inclusion of the timeout parameter in the session header.",
      "ja": "10.5節は、より深く生存性を示すための方法を説明します。クライアントが確立されたセッションのタイムアウト値（通常は60秒）よりも長く生存性を示すために、失敗した場合、サーバはコンテキストを終了させることができます。他の値は、セッション・ヘッダにおけるタイムアウトパラメータを含めることによって、サーバによって選択されてもよいです。"
    },
    {
      "indent": 3,
      "text": "The session context is normally terminated by the client sending a TEARDOWN request (Section 13.7) to the server referencing the aggregated control URI. An individual media resource can be removed from a session context by a TEARDOWN request referencing that particular media resource. If all media resources are removed from a session context, the session context is terminated.",
      "ja": "セッションコンテキストは通常​​、集約された制御URIを参照するサーバにTEARDOWN要求（セクション13.7）を送信するクライアントによって終了されます。個々のメディアリソースは、その特定のメディアリソースを参照するTEARDOWN要求によってセッションコンテキストから除去することができます。すべてのメディアリソースがセッションコンテキストから削除された場合は、セッションのコンテキストが終了されます。"
    },
    {
      "indent": 3,
      "text": "A client may keep the session alive indefinitely if allowed by the server; however, a client is advised to release the session context when an extended period of time without media delivery activity has passed. The client can re-establish the session context if required later. What constitutes an extended period of time is dependent on the client, server, and their usage. It is recommended that the client terminate the session before ten times the session timeout value has passed. A server may terminate the session after one session timeout period without any client activity beyond keep-alive. When a server terminates the session context, it does so by sending a TEARDOWN request indicating the reason.",
      "ja": "サーバーによって許可されている場合、クライアントは無期限セッションを存続します。ただし、クライアントは、メディア配信活動のない時間の延長期間が経過すると、セッションのコンテキストを解放することをお勧めします。後で必要に応じてクライアントがセッションコンテキストを再確立することができます。何時間の延長期間を構成すると、クライアント、サーバー、およびその使用方法に依存しています。 10回のセッションタイムアウト値が経過する前に、クライアントがセッションを終了することをお勧めします。サーバーはキープアライブを超えた任意のクライアント活動なしに1つのセッションタイムアウト時間後にセッションを終了することができます。サーバがセッションコンテキストを終了すると、それは理由を示すTEARDOWN要求を送信することによって、そうします。"
    },
    {
      "indent": 3,
      "text": "A server can also request that the client tear down the session and re-establish it at an alternative server, as may be needed for maintenance. This is done by using the REDIRECT method (Section 13.10). The Terminate-Reason header (Section 18.52) is used to indicate when and why. The Location header indicates where it should connect if there is an alternative server available. When the deadline expires, the server simply stops providing the service. To achieve a clean closure, the client needs to initiate session termination prior to the deadline. In case the server has no other server to redirect to, and it wants to close the session for maintenance, it shall use the TEARDOWN method with a Terminate-Reason header.",
      "ja": "また、サーバは、クライアントがセッションを切断し、メンテナンスのために必要とすることができるように、代替サーバーでそれを再確立することを要求することができます。これは、Redirectメソッド（セクション13.10）を使用して行われます。終了理由をヘッダ（セクション18.52）は、いつ、なぜ示すために使用されます。利用可能な代替サーバがある場合、それが接続する場所Locationヘッダを示します。期限が経過すると、サーバーは、単純にサービスを提供して停止します。きれいなクロージャを達成するために、クライアントは、期限前にセッション終了を開始する必要があります。サーバがリダイレクトする他のサーバを持っていない、それがメンテナンスのためにセッションを終了したい場合には、終了理由をヘッダとTEARDOWNメソッドを使用しなければなりません。"
    },
    {
      "indent": 0,
      "text": "2.7. Extending RTSP",
      "section_title": true,
      "ja": "2.7.  RTSPを拡張"
    },
    {
      "indent": 3,
      "text": "RTSP is quite a versatile protocol that supports extensions in many different directions. Even this core specification contains several blocks of functionality that are optional to implement. The use case and need for the protocol deployment should determine what parts are implemented. Allowing for extensions makes it possible for RTSP to address additional use cases. However, extensions will affect the interoperability of the protocol; therefore, it is important that they can be added in a structured way.",
      "ja": "RTSPは、多くの異なる方向に拡張をサポートし、非常に汎用性の高いプロトコルです。でも、このコア仕様の実装はオプションです機能のいくつかのブロックが含まれています。ユースケースとプロトコルの導入の必要性は、部品が実装されているかを判断すべきです。 RTSPは、追加のユースケースに対処するための拡張を可能にすることが可能となります。ただし、拡張子は、プロトコルの相互運用性に影響を与えます。したがって、彼らが構造化された方法で添加することができることが重要です。"
    },
    {
      "indent": 3,
      "text": "The client can learn the capability of a server by using the OPTIONS method (Section 13.1) and the Supported header (Section 18.51). It can also try and possibly fail using new methods or require that particular features be supported using the Require (Section 18.43) or Proxy-Require (Section 18.37) header.",
      "ja": "クライアントはOPTIONSメソッド（13.1）およびサポートされているヘッダ（セクション18.51）を使用して、サーバーの機能を学ぶことができます。また、試してみて、おそらく新たな方法を使用して失敗するか、または特定の機能が（セクション18.43）要求またはプロキシ要求（セクション18.37）ヘッダを使用してサポートされることを必要とすることができます。"
    },
    {
      "indent": 3,
      "text": "The RTSP, in itself, can be extended in three ways, listed here in increasing order of the magnitude of changes supported:",
      "ja": "RTSPは、それ自体が、サポートさ変化の大きさの増加順にここにリストされている三つの方法で拡張することができます。"
    },
    {
      "indent": 3,
      "text": "o Existing methods can be extended with new parameters, for example, headers, as long as these parameters can be safely ignored by the recipient. If the client needs negative acknowledgment when a method extension is not supported, a tag corresponding to the extension may be added in the field of the Require or Proxy-Require headers.",
      "ja": "O既存の方法は、例えば、ヘッダは、限り、これらのパラメータは、安全に、受信者によって無視することができますよう、新しいパラメータを拡張することができます。方法の拡張がサポートされていない場合、クライアントは否定応答を必要とする場合、拡張に対応するタグを必要とするか、またはプロキシ要求ヘッダーのフィールドに加えてもよいです。"
    },
    {
      "indent": 3,
      "text": "o New methods can be added. If the recipient of the message does not understand the request, it must respond with error code 501 (Not Implemented) so that the sender can avoid using this method again. A client may also use the OPTIONS method to inquire about methods supported by the server. The server must list the methods it supports using the Public response-header.",
      "ja": "O新しいメソッドを追加することができます。メッセージの受信者が要求を理解していない場合は、送信者が再び、このメソッドを使用して避けることができるように、それはエラーコード501（実装されていない）で応答しなければなりません。また、クライアントは、サーバでサポートされている方法を問い合わせるOPTIONSメソッドを使用することができます。サーバは公開レスポンスヘッダを使用してサポートするメソッドをリストする必要があります。"
    },
    {
      "indent": 3,
      "text": "o A new version of the protocol can be defined, allowing almost all aspects (except the position of the protocol version number) to change. A new version of the protocol must be registered through a Standards Track document.",
      "ja": "プロトコルの新バージョンO（プロトコルバージョン番号の位置を除いて）ほぼすべての側面を変更することができ、定義することができます。プロトコルの新しいバージョンでは、標準化過程の文書を登録する必要があります。"
    },
    {
      "indent": 3,
      "text": "The basic capability discovery mechanism can be used to both discover support for a certain feature and to ensure that a feature is available when performing a request. For a detailed explanation of this, see Section 11.",
      "ja": "基本的な機能の発見メカニズムは、特定の機能のサポートを発見し、要求を実行するときに機能が使用可能であることを確実にするための両方に使用することができます。このの詳細については、セクション11を参照してください。"
    },
    {
      "indent": 3,
      "text": "New media delivery protocols may be added and negotiated at session establishment, in addition to extensions to the core protocol. Certain types of protocol manipulations can be done through parameter formats using SET_PARAMETER and GET_PARAMETER.",
      "ja": "新しいメディア配信プロトコルは、コアプロトコルの拡張に加えて、セッションの確立に加え、交渉されてもよいです。プロトコル操作の特定の種類は、SET_PARAMETERとGET_PARAMETERを使用してパラメータ・フォーマットを介して行うことができます。"
    },
    {
      "indent": 0,
      "text": "3. Document Conventions",
      "section_title": true,
      "ja": "3.ドキュメントの表記規則"
    },
    {
      "indent": 0,
      "text": "3.1. Notational Conventions",
      "section_title": true,
      "ja": "3.1. 表記規則"
    },
    {
      "indent": 3,
      "text": "All the mechanisms specified in this document are described in both prose and the Augmented Backus-Naur form (ABNF) described in detail in [RFC5234].",
      "ja": "この文書で指定されたすべてのメカニズムは、両方の散文に記載されていると拡張バッカス・ナウアフォーム（ABNF）は[RFC5234]に詳細に記載しました。"
    },
    {
      "indent": 3,
      "text": "Indented paragraphs are used to provide informative background and motivation. This is intended to give readers who were not involved with the formulation of the specification an understanding of why things are the way they are in RTSP.",
      "ja": "インデント段落は、有益な背景や動機を提供するために使用されています。これは、仕様の策定、物事は、彼らがRTSPである方法である理由を理解して関与していない読者を与えることを目的としています。"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "キーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、 \"SHALL\"、 \"SHOULD\"、 \"ないもの\"、 \"推奨\" \"ない（SHOULD NOT）\"、 \"MAY\"、 \"推奨NOT\"、および「OPTIONAL 「本書では[RFC2119]で説明されるように解釈されるべきです。"
    },
    {
      "indent": 3,
      "text": "The word, \"unspecified\" is used to indicate functionality or features that are not defined in this specification. Such functionality cannot be used in a standardized manner without further definition in an extension specification to RTSP.",
      "ja": "単語、「未指定」は、この仕様で定義されていない機能や特徴を示すために使用されます。そのような機能がRTSPを拡張仕様でさらに定義することなく、標準化された方法で使用することができません。"
    },
    {
      "indent": 0,
      "text": "3.2. Terminology",
      "section_title": true,
      "ja": "3.2. 用語"
    },
    {
      "indent": 3,
      "text": "Aggregate control: The concept of controlling multiple streams using a single timeline, generally one maintained by the server. A client, for example, uses aggregate control when it issues a single play or pause message to simultaneously control both the audio and video in a movie. A session that is under aggregate control is referred to as an \"aggregated session\".",
      "ja": "凝集制御：単一のタイムラインを使用して、複数のストリームを制御するという概念は、一般に、1つのサーバによって維持されます。クライアントは、例えば、それは同時に、映画のオーディオとビデオの両方を制御する単一のプレイまたは一時停止のメッセージを発行集約コントロールを使用しています。凝集制御下にあるセッションは、「集約セッション」と呼ばれます。"
    },
    {
      "indent": 3,
      "text": "Aggregate control URI: The URI used in an RTSP request to refer to and control an aggregated session. It normally, but not always, corresponds to the presentation URI specified in the session description. See Section 13.3 for more information.",
      "ja": "集計コントロールURIは：URIは、を参照し、集約セッションを制御するためにRTSP要求に使用されます。それは通常、常にではないが、セッション記述で指定されたプレゼンテーションURIに対応しています。詳細は項13.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "Client: The client is the requester of media service from the media server.",
      "ja": "クライアント：クライアントは、メディアサーバからメディアサービスの要求元です。"
    },
    {
      "indent": 3,
      "text": "Connection: A transport-layer virtual circuit established between two programs for the purpose of communication.",
      "ja": "接続：通信の目的のための2つのプログラム間に確立されたトランスポート層仮想回路。"
    },
    {
      "indent": 3,
      "text": "Container file: A file that may contain multiple media streams that often constitute a presentation when played together. The concept of a container file is not embedded in the protocol. However, RTSP servers may offer aggregate control on the media streams within these files.",
      "ja": "コンテナファイル：一緒にプレイしたとき、多くの場合、プレゼンテーションを構成する複数のメディアストリームを含むことができ、ファイル。コンテナファイルの概念は、プロトコルに組み込まれていません。しかし、RTSPサーバは、これらのファイル内のメディアストリーム上の集約制御を提供することがあります。"
    },
    {
      "indent": 3,
      "text": "Continuous media: Data where there is a timing relationship between source and sink; that is, the sink needs to reproduce the timing relationship that existed at the source. The most common examples of continuous media are audio and motion video. Continuous media can be real time (interactive or conversational), where there is a \"tight\" timing relationship between source and sink or it can be streaming where the relationship is less strict.",
      "ja": "連続メディアデータソースとシンクとの間のタイミング関係があります。つまり、シンクは、ソースに存在していたタイミング関係を再現する必要があります。連続メディアの最も一般的な例は、オーディオとビデオの動きです。連続メディアソースとシンクまたは関係が以下厳密である場合、それは、ストリーミングすることができるとの間の「タイトな」タイミング関係が存在する（対話または会話）リアルタイムとすることができます。"
    },
    {
      "indent": 3,
      "text": "Feature tag: A tag representing a certain set of functionality, i.e., a feature.",
      "ja": "特徴タグ：機能、即ち、機能の特定のセットを表すタグ。"
    },
    {
      "indent": 3,
      "text": "IRI: An Internationalized Resource Identifier is similar to a URI but allows characters from the whole Universal Character Set (Unicode/ISO 10646), rather than the US-ASCII only. See [RFC3987] for more information.",
      "ja": "IRI：国際化リソース識別子はURIに似ていますができます全体のユニバーサル文字セット（ユニコード/ ISO 10646）、だけではなくUS-ASCII文字から。詳細については、[RFC3987]を参照してください。"
    },
    {
      "indent": 3,
      "text": "Live: A live presentation or session originates media from an event taking place at the same time as the media delivery. Live sessions often have an unbound or only loosely defined duration and seek operations may not be possible.",
      "ja": "ライブ：ライブプレゼンテーションまたはセッションは、メディア配信と同時に行われているイベントからメディアを発信します。ライブセッションは、多くの場合、結合していないかだけ緩く定義された持続時間を有するシーク操作ができない場合があります。"
    },
    {
      "indent": 3,
      "text": "Media initialization: The datatype- or codec-specific initialization. This includes such things as clock rates, color tables, etc. Any transport-independent information that is required by a client for playback of a media stream occurs in the media initialization phase of stream setup.",
      "ja": "メディアの初期化：datatype-やコーデック固有の初期化。これは、メディアストリームの再生のために、クライアントによって要求されているすべてのトランスポートに依存しない情報がストリームセットアップのメディア初期化フェーズで発生するなどのクロックレート、カラーテーブル、のようなものを含んでいます。"
    },
    {
      "indent": 3,
      "text": "Media parameter: A parameter specific to a media type that may be changed before or during stream delivery.",
      "ja": "メディアパラメータ：前またはストリーム配信中に変更することができるメディアの種類に固有のパラメータ。"
    },
    {
      "indent": 3,
      "text": "Media server: The server providing media-delivery services for one or more media streams. Different media streams within a presentation may originate from different media servers. A media server may reside on the same host or on a different host from which the presentation is invoked.",
      "ja": "メディアサーバー：1つ以上のメディアストリームのメディア配信サービスを提供するサーバ。プレゼンテーション内の別のメディアストリームは、異なるメディアサーバーに由来してもよいです。メディアサーバは、同じホスト上またはプレゼンテーションが呼び出された別のホスト上に存在してもよいです。"
    },
    {
      "indent": 3,
      "text": "(Media) Stream: A single media instance, e.g., an audio stream or a video stream as well as a single whiteboard or shared application group. When using RTP, a stream consists of all RTP and RTCP packets created by a media source within an RTP session.",
      "ja": "（メディア）ストリーム：単一のメディアインスタンス、例えば、オーディオストリームまたはビデオストリーム、ならびに単一ホワイトボードまたは共有アプリケーショングループ。 RTPを使用する場合は、ストリームは、RTPセッション内のメディアソースによって作成されたすべてのRTPとRTCPパケットから構成されています。"
    },
    {
      "indent": 3,
      "text": "Message: The basic unit of RTSP communication, consisting of a structured sequence of octets matching the syntax defined in Section 20 and transmitted over a transport between RTSP agents. A message is either a request or a response.",
      "ja": "メッセージ：セクション20で定義され、RTSPエージェントとの間のトランスポートを介して送信されたシンタックスに一致オクテットの構造配列からなるRTSP通信の基本ユニット。メッセージは、要求または応答のいずれかです。"
    },
    {
      "indent": 3,
      "text": "Message body: The information transferred as the payload of a message (request or response). A message body consists of meta-information in the form of message body headers and content in the form of an arbitrary number of data octets, as described in Section 9.",
      "ja": "メッセージ本文：メッセージ（要求または応答）のペイロードとして転送される情報。セクション9に記載されているように、メッセージボディは、メッセージ本文のヘッダとデータオクテットの任意の数の形態のコンテンツの形でメタ情報から構成されています。"
    },
    {
      "indent": 3,
      "text": "Non-aggregated control: Control of a single media stream.",
      "ja": "非凝集制御：単一のメディアストリームの制御。"
    },
    {
      "indent": 3,
      "text": "Presentation: A set of one or more streams presented to the client as a complete media feed and described by a presentation description as defined below. Presentations with more than one media stream are often handled in RTSP under aggregate control.",
      "ja": "プレゼンテーション：以下に定義されるプレゼンテーション記述によって完全なメディアフィードとしてクライアントに提示して説明される1つまたは複数のストリームのセット。複数のメディアストリームとプレゼンテーションは、多くの場合、集約制御下RTSPで処理されます。"
    },
    {
      "indent": 3,
      "text": "Presentation description: A presentation description contains information about one or more media streams within a presentation, such as the set of encodings, network addresses, and information about the content. Other IETF protocols, such as SDP ([RFC4566]), use the term \"session\" for a presentation. The presentation description may take several different formats, including but not limited to SDP format.",
      "ja": "プレゼンテーション記述：プレゼンテーション記述は、そのような符号化方式のセット、ネットワークアドレス、およびコンテンツに関する情報として、プレゼンテーション内の1つまたは複数のメディア・ストリームについての情報を含みます。そのようなSDP（[RFC4566]）のような他のIETFプロトコルは、プレゼンテーションのために、用語「セッション」を使用します。プレゼンテーション記述は、SDP形式を含むがこれらに限定されないいくつかの異なる形式をとることができます。"
    },
    {
      "indent": 3,
      "text": "Response: An RTSP response to a request. One type of RTSP message. If an HTTP response is meant, it is indicated explicitly.",
      "ja": "応答：要求に対するRTSP応答。 RTSPメッセージの一種。 HTTPレスポンスを意味している場合は、それが明示的に示されています。"
    },
    {
      "indent": 3,
      "text": "Request: An RTSP request. One type of RTSP message. If an HTTP request is meant, it is indicated explicitly.",
      "ja": "要求：RTSP要求。 RTSPメッセージの一種。 HTTPリクエストが意図されている場合は、それが明示的に示されています。"
    },
    {
      "indent": 3,
      "text": "Request-URI: The URI used in a request to indicate the resource on which the request is to be performed.",
      "ja": "リクエストURI：URIは、要求が実行されるリソースを示すために要求で使用しました。"
    },
    {
      "indent": 3,
      "text": "RTSP agent: Either an RTSP client, an RTSP server, or an RTSP proxy. In this specification, there are many capabilities that are common to these three entities such as the capability to send requests or receive responses. This term will be used when describing functionality that is applicable to all three of these entities.",
      "ja": "RTSPエージェント：RTSPクライアント、RTSPサーバ、またはRTSPプロキシのどちらか。本明細書では、このような要求を送信したり、応答を受信する機能として、これらの3つのエンティティに共通する多くの機能があります。これらの事業体の3つのすべてに適用された機能を説明するときに、この用語が使用されます。"
    },
    {
      "indent": 3,
      "text": "RTSP session: A stateful abstraction upon which the main control methods of RTSP operate. An RTSP session is a common context; it is created and maintained on a client's request and can be destroyed by either the client or server. It is established by an RTSP server upon the completion of a successful SETUP request (when a 200 OK response is sent) and is labeled with a session identifier at that time. The session exists until timed out by the server or explicitly removed by a TEARDOWN request. An RTSP session is a stateful entity; an RTSP server maintains an explicit session state machine (see Appendix B) where most state transitions are triggered by client requests. The existence of a session implies the existence of state about the session's media streams and their respective transport mechanisms. A given session can have one or more media streams associated with it. An RTSP server uses the session to aggregate control over multiple media streams.",
      "ja": "RTSPセッション：RTSPの主制御方法が動作する際にステートフル抽象。 RTSPセッションは、一般的な文脈です。それが作成され、クライアントの要求に維持し、クライアントまたはサーバのいずれかによって破壊することができています。これは、成功したSETUP要求の完了時にRTSPサーバによって確立される（200 OK応答が送信されるとき）、その時点でセッション識別子で標識されます。サーバーによってタイムアウトまたは明示的にTEARDOWN要求によって除去されるまで、セッションが存在します。 RTSPセッションは、ステートフル実体です。 RTSPサーバは、ほとんどの状態遷移は、クライアントの要求によってトリガされ、明示的なセッション・ステート・マシンを（付録Bを参照）を維持します。セッションの存在は、セッションのメディアストリームとそれぞれのトランスポート・メカニズムについての状態が存在することを意味します。与えられたセッションは、それに関連する1つのまたは複数のメディアストリームを持つことができます。 RTSPサーバは、複数のメディアストリームの制御を集約するためにセッションを使用しています。"
    },
    {
      "indent": 3,
      "text": "Origin server: The server on which a given resource resides.",
      "ja": "オリジンサーバ：与えられたリソースが存在するサーバー。"
    },
    {
      "indent": 3,
      "text": "Seeking: Requesting playback from a particular point in the content time line.",
      "ja": "探している：コンテンツのタイムライン内の特定の位置から再生を要求します。"
    },
    {
      "indent": 3,
      "text": "Transport initialization: The negotiation of transport information (e.g., port numbers, transport protocols) between the client and the server.",
      "ja": "交通の初期化：クライアントとサーバ間の交通情報（例えば、ポート番号、トランスポートプロトコル）の交渉。"
    },
    {
      "indent": 3,
      "text": "URI: A Universal Resource Identifier; see [RFC3986]. The URIs used in RTSP are generally URLs as they give a location for the resource. As URLs are a subset of URIs, they will be referred to as URIs to cover also the cases when an RTSP URI would not be a URL.",
      "ja": "URI：ユニバーサルリソース識別子。 [RFC3986]を参照してください。 RTSPで使用されるURIは、それらがリソースの場所を与えるように、一般的なURLです。 URLはURIのサブセットであるため、彼らはRTSP URIはURLではないだろうというときにも例をカバーするためのURIと呼ぶことにします。"
    },
    {
      "indent": 3,
      "text": "URL: A Universal Resource Locator is a URI that identifies the resource through its primary access mechanism rather than identifying the resource by name or by some other attribute(s) of that resource.",
      "ja": "URL：ユニバーサルリソースロケータは、名前またはそのリソースのいくつかの他の属性（単数または複数）によってリソースを特定するのではなく、そのプライマリアクセス機構を介してリソースを識別するURIです。"
    },
    {
      "indent": 0,
      "text": "4. Protocol Parameters",
      "section_title": true,
      "ja": "4.プロトコルパラメータ"
    },
    {
      "indent": 0,
      "text": "4.1. RTSP Version",
      "section_title": true,
      "ja": "4.1.  RTSPバージョン"
    },
    {
      "indent": 3,
      "text": "This specification defines version 2.0 of RTSP.",
      "ja": "この仕様は、RTSPのバージョン2.0を定義します。"
    },
    {
      "indent": 3,
      "text": "RTSP uses a \"<major>.<minor>\" numbering scheme to indicate versions of the protocol. The protocol versioning policy is intended to allow the sender to indicate the format of a message and its capacity for understanding further RTSP communication rather than the features obtained via that communication. No change is made to the version number for the addition of message components that do not affect communication behavior or that only add to extensible field values.",
      "ja": "RTSPプロトコルのバージョンを示すために、「<主要な>。<マイナー>」番号付けスキームを使用しています。プロトコルのバージョン管理ポリシーは、メッセージのフォーマットおよび機能は、通信を介して取得するのではなく、さらに、RTSP通信を理解するための能力を示すために、送信者を許可することを意図しています。変更なしは、通信動作に影響を与えるかということだけで拡張可能なフィールド値に追加しないメッセージ成分の添加のためのバージョン番号に行われません。"
    },
    {
      "indent": 3,
      "text": "The <minor> number is incremented when the changes made to the protocol add features that do not change the general message parsing algorithm but that may add to the message semantics and imply additional capabilities of the sender. The <major> number is incremented when the format of a message within the protocol is changed. The version of an RTSP message is indicated by an RTSP-Version field in the first line of the message. Note that the major and minor numbers MUST be treated as separate integers and that each MAY be incremented higher than a single digit. Thus, RTSP/2.4 is a lower version than RTSP/2.13, which, in turn, is lower than RTSP/12.3. Leading zeros SHALL NOT be sent and MUST be ignored by recipients.",
      "ja": "プロトコルに加えられた変更は、アルゴリズムを解析し、一般的なメッセージを変更しませんが、それはメッセージのセマンティクスに追加して、送信者の追加機能を意味し得る機能を追加するとき、<マイナー>番号がインクリメントされます。プロトコル内のメッセージのフォーマットが変更された場合、<メジャー>数をインクリメントします。 RTSPメッセージのバージョンは、メッセージの1行目にRTSP-Versionフィールドで示されています。メジャー番号とマイナー番号が別々の整数として扱われ、それぞれが一桁以上高い増分することができることをしなければならないことに注意してください。従って、RTSP / 2.4 RTSP / 2.13、今度は、RTSP / 12.3未満である、より低いバージョンです。先頭のゼロは送信されないものとし、受信者は無視しなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.2. RTSP IRI and URI",
      "section_title": true,
      "ja": "4.2.  RTSPと上にあります"
    },
    {
      "indent": 3,
      "text": "RTSP 2.0 defines and registers or updates three URI schemes \"rtsp\", \"rtsps\", and \"rtspu\". The usage of the last, \"rtspu\", is unspecified in RTSP 2.0 and is defined here to register the URI scheme that was defined in RTSP 1.0. The \"rtspu\" scheme indicates unspecified transport of the RTSP messages over unreliable transport means (UDP in RTSP 1.0). An RTSP server MUST respond with an error code indicating the \"rtspu\" scheme is not implemented (501) to a request that carries a \"rtspu\" URI scheme.",
      "ja": "RTSP 2.0定義およびレジスタまたは更新3つのURIスキーム \"RTSP\"、 \"RTSPS\"、および \"RTSPU\"。最後に、「RTSPU」の使用量は、RTSP 2.0で定義されていないためRTSP 1.0で定義されたURIスキームを登録するには、ここで定義されています。 「RTSPU」方式では、信頼性の低い輸送手段（RTSP 1.0でUDP）を超えるRTSPメッセージの不特定のトランスポートを示します。 RTSPサーバは、「RTSPU」URIスキームを運ぶリクエストに（501）実装されていません「RTSPU」方式を示すエラーコードで応答しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The details of the syntax of \"rtsp\" and \"rtsps\" URIs have been changed from RTSP 1.0. These changes include the addition of:",
      "ja": "「RTSP」と「RTSPS」URIの構文の詳細は、RTSP 1.0から変更されました。これらの変更はの付加を含みます。"
    },
    {
      "indent": 3,
      "text": "o Support for an IPv6 literal in the host part and future IP literals through a mechanism defined in [RFC3986].",
      "ja": "[RFC3986]で定義された機構を介してホスト部と将来IPリテラル中のO IPv6のサポートリテラル。"
    },
    {
      "indent": 3,
      "text": "o A new relative format to use in the RTSP elements that is not required to start with \"/\".",
      "ja": "O新しい相対形式は「/」で開始する必要はないRTSP要素で使用します。"
    },
    {
      "indent": 3,
      "text": "Neither should have any significant impact on interoperability. If IPv6 literals are needed in the RTSP URI, then that RTSP server must be IPv6 capable, and RTSP 1.0 is not a fully IPv6 capable protocol. If an RTSP 1.0 client attempts to process the URI, the URI will not match the allowed syntax, it will be considered invalid, and processing will be stopped. This is clearly a failure to reach the resource; however, it is not a signification issue as RTSP 2.0 support was needed anyway in both server and client. Thus, failure will only occur in a later step when there is an RTSP version mismatch between client and server. The second change will only occur inside RTSP message headers, as the Request-URI must be an absolute URI. Thus, such usages will only occur after an agent has accepted and started processing RTSP 2.0 messages, and an agent using RTSP 1.0 only will not be required to parse such types of relative URIs.",
      "ja": "どちらも相互運用性に重大な影響を与えるべきではありません。 IPv6のリテラルはRTSP URIで必要とされている場合、そのRTSPサーバがIPv6対応でなければならない、とRTSP 1.0は完全にIPv6の対応プロトコルではありません。 RTSP 1.0クライアントがURIを処理しようとすると、URIは許さ構文と一致しません、それは無効とみなされ、処理が停止します。これは明らかに、リソースに到達するための障害です。しかし、RTSP 2.0のサポートは、サーバーとクライアントの両方で、とにかく必要だったとして意義の問題ではありません。クライアントとサーバの間のRTSPバージョンの不一致がある場合にこのように、失敗は、後工程で発生します。リクエストURIは、絶対URIでなければならないように、第2の変更は、RTSPメッセージヘッダー内部で発生します。薬剤が受け入れられ、RTSP 2.0メッセージの処理を開始し、RTSP 1.0を使用してエージェントのみ相対URIのようなタイプを解析する必要はありませんした後にこのように、そのような用途にのみ発生します。"
    },
    {
      "indent": 3,
      "text": "This specification also defines the format of RTSP IRIs [RFC3987] that can be used as RTSP resource identifiers and locators on web pages, user interfaces, on paper, etc. However, the RTSP request message format only allows usage of the absolute URI format. The RTSP IRI format MUST use the rules and transformation for IRIs to URIs, as defined in [RFC3987]. This allows a URI that matches the RTSP 2.0 specification, and so is suitable for use in a request, to be created from an RTSP IRI.",
      "ja": "本明細書はまた、RTSPリソース識別子とロケータウェブページ上で、ユーザ・インターフェース、紙の上に、等として使用することができるRTSPのIRI [RFC3987]の形式しかし、RTSP要求メッセージフォーマットのみ絶対URIフォーマットの使用を可能にする規定します。 RTSP IRIの形式は[RFC3987]で定義されるように、URIの虹彩の規則および変換を使用しなければなりません。これは、RTSP 2.0仕様に一致するURIを可能にし、そうRTSP IRIから作成される、要求に使用するのに適しています。"
    },
    {
      "indent": 3,
      "text": "The RTSP IRI and URI are both syntax restricted compared to the generic syntax defined in [RFC3986] and [RFC3987]:",
      "ja": "RTSP IRIとURIは、[RFC3986]で定義されている一般的な構文に比べて制限構文と[RFC3987]の両方であります："
    },
    {
      "indent": 3,
      "text": "o An absolute URI requires the authority part; i.e., a host identity MUST be provided.",
      "ja": "絶対URI oを権限の一部を必要とします。即ち、ホストアイデンティティを提供しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o Parameters in the path element are prefixed with the reserved separator \";\".",
      "ja": "パス要素中のOパラメータは予約セパレータで始まります「;」。"
    },
    {
      "indent": 3,
      "text": "The \"scheme\" and \"host\" parts of all URIs [RFC3986] and IRIs [RFC3987] are case insensitive. All other parts of RTSP URIs and IRIs are case sensitive, and they MUST NOT be case mapped.",
      "ja": "「スキーム」及びすべてのURIの「ホスト」の部分[RFC3986]と虹彩[RFC3987]は、大文字と小文字を区別しています。 RTSP URIと虹彩のすべての他の部分は大文字と小文字が区別され、そして、彼らはケースをマッピングしてはなりません。"
    },
    {
      "indent": 3,
      "text": "The fragment identifier is used as defined in Sections 3.5 and 4.3 of [RFC3986], i.e., the fragment is to be stripped from the IRI by the requester and not included in the Request-URI. The user agent needs to interpret the value of the fragment based on the media type the request relates to; i.e., the media type indicated in Content-Type header in the response to a DESCRIBE request.",
      "ja": "セクション3.5と[RFC3986]、すなわち4.3で定義されているフラグメント識別子が使用されて、断片は、リクエスタによってIRIから剥離とRequest-URIに含まれないことになります。ユーザエージェントは、要求が関連メディアタイプに基づいて、フラグメントの値を解釈する必要があります。即ち、DESCRIBE要求に応答して、Content-Typeヘッダに示されるメディアタイプ。"
    },
    {
      "indent": 3,
      "text": "The syntax of any URI query string is unspecified and responder (usually the server) specific. The query is, from the requester's perspective, an opaque string and needs to be handled as such.",
      "ja": "任意のURIのクエリ文字列の構文が指定されていないと、レスポンダ（通常はサーバー）固有のものです。クエリは、依頼者の視点から、不透明な文字列であり、そのようなものとして扱われる必要があります。"
    },
    {
      "indent": 3,
      "text": "Please note that relative URIs with queries are difficult to handle due to the relative URI handling rules of RFC 3986. Any change of the path element using a relative URI results in the stripping of the query, which means the relative part needs to contain the query.",
      "ja": "相対的な部分は、クエリが含まれている必要が意味し、クエリとの相対URIが原因RFC 3986の相対URI処理規則にクエリーのストリッピングに相対URIの結果を使用してパス要素の任意の変更を処理することは困難であることに注意してください。"
    },
    {
      "indent": 3,
      "text": "The URI scheme \"rtsp\" requires that commands be issued via a reliable protocol (within the Internet, TCP), while the scheme \"rtsps\" identifies a reliable transport using secure transport (TLS [RFC5246]); see Section 19.",
      "ja": "URIスキーム「RTSP」は、セキュアなトランスポート（TLS [RFC5246]）を使用して、信頼性の高いトランスポートを識別する方式「RTSPS」ながらコマンドは、信頼性の高いプロトコル（インターネット内、TCP）を介して発行することを必要とします。セクション19を参照してください。"
    },
    {
      "indent": 3,
      "text": "For the scheme \"rtsp\", if no port number is provided in the authority part of the URI, the port number 554 MUST be used. For the scheme \"rtsps\", if no port number is provided in the authority part of the URI port number, the TCP port 322 MUST be used.",
      "ja": "ポート番号がURIの権限部分に提供されていない場合のスキーム「RTSP」については、ポート番号554を使用しなければなりません。ポート番号がURIのポート番号の権限部分に提供されていない場合のスキーム「RTSPS」については、TCPポート322を使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "A presentation or a stream is identified by a textual media identifier, using the character set and escape conventions of URIs [RFC3986]. URIs may refer to a stream or an aggregate of streams; i.e., a presentation. Accordingly, requests described in Section 13 can apply to either the whole presentation or an individual stream within the presentation. Note that some request methods can only be applied to streams, not presentations, and vice versa.",
      "ja": "プレゼンテーションやストリームは、文字セットを使用して、テキスト形式のメディア識別子によって識別されたURI [RFC3986]の規則を逃れています。 URIは、ストリームまたはストリームの集合体を指すことができます。すなわち、プレゼンテーション。したがって、セクション13で説明した要求は、全体のプレゼンテーションやプレゼンテーション内の個々のストリームのいずれにも適用することができます。いくつかのリクエストメソッドのみのストリームではなく、プレゼンテーション、およびその逆にも適用することができることに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "For example, the RTSP URI:",
      "ja": "例えば、RTSP URI："
    },
    {
      "indent": 6,
      "text": "rtsp://media.example.com:554/twister/audiotrack",
      "ja": "RTSP：//media.example.com：554 /ツイスター/ audiotrack"
    },
    {
      "indent": 3,
      "text": "may identify the audio stream within the presentation \"twister\", which can be controlled via RTSP requests issued over a TCP connection to port 554 of host media.example.com.",
      "ja": "ホストmedia.example.comのポート554へのTCP接続を介して発行されたRTSP要求を介して制御することができ、プレゼンテーション「ツイスター」内のオーディオストリームを識別することができます。"
    },
    {
      "indent": 3,
      "text": "Also, the RTSP URI:",
      "ja": "また、RTSP URI："
    },
    {
      "indent": 6,
      "text": "rtsp://media.example.com:554/twister",
      "ja": "RTSP：//media.example.com：554 /ツイスター"
    },
    {
      "indent": 3,
      "text": "identifies the presentation \"twister\", which may be composed of audio and video streams, but could also be something else, such as a random media redirector.",
      "ja": "オーディオとビデオのストリームから構成されてもよいプレゼンテーション「ツイスター」を、識別し、また、そのようなランダムメディアリダイレクタとして何か他のものである可能性があります。"
    },
    {
      "indent": 6,
      "text": "This does not imply a standard way to reference streams in URIs. The presentation description defines the hierarchical relationships in the presentation and the URIs for the individual streams. A presentation description may name a stream \"a.mov\" and the whole presentation \"b.mov\".",
      "ja": "これは、URIの中でストリームを参照するための標準的な方法を意味するものではありません。プレゼンテーション記述は、個々のストリームのプレゼンテーションの階層関係及びURIを定義します。プレゼンテーション記述はストリーム「a.mov」とプレゼンテーション全体「b.mov」という名前を付けて。"
    },
    {
      "indent": 3,
      "text": "The path components of the RTSP URI are opaque to the client and do not imply any particular file system structure for the server.",
      "ja": "RTSP URIのパスコンポーネントは、クライアントには不透明であり、サーバーのいずれかの特定のファイルシステム構造を意味するものではありません。"
    },
    {
      "indent": 6,
      "text": "This decoupling also allows presentation descriptions to be used with non-RTSP media control protocols simply by replacing the scheme in the URI.",
      "ja": "このデカップリングは、プレゼンテーションの説明は単にURIにスキームを置き換えることにより、非RTSPメディア制御プロトコルで使用することができます。"
    },
    {
      "indent": 0,
      "text": "4.3. Session Identifiers",
      "section_title": true,
      "ja": "4.3. セッション識別子"
    },
    {
      "indent": 3,
      "text": "Session identifiers are strings of a length between 8-128 characters. A session identifier MUST be generated using methods that make it cryptographically random (see [RFC4086]). It is RECOMMENDED that a session identifier contain 128 bits of entropy, i.e., approximately 22 characters from a high-quality generator (see Section 21). However, note that the session identifier does not provide any security against session hijacking unless it is kept confidential by the client, server, and trusted proxies.",
      "ja": "セッション識別子は8から128文字までの長さの文字列です。セッション識別子は、それが暗号ランダム（[RFC4086]を参照）を作る方法を使用して生成されなければなりません。セッション識別子は128ビットのエントロピー、すなわち、高品質の発生から約22文字（セクション21を参照）を含むことが推奨されます。しかし、それは、クライアント、サーバによって機密保持、およびプロキシを信頼されない限り、セッション識別子は、セッションハイジャックに対してどのようなセキュリティを提供しないことに注意してください。"
    },
    {
      "indent": 0,
      "text": "4.4. Media-Time Formats",
      "section_title": true,
      "ja": "4.4. メディア-時刻の書式"
    },
    {
      "indent": 3,
      "text": "RTSP currently supports three different media-time formats defined below. Additional time formats may be specified in the future. These time formats can be used with the Range header (Section 18.40) to request playback and specify at which media position protocol requests actually will or have taken place. They are also used in description of the media's properties using the Media-Range header (Section 18.30). The unqualified format identifier is used on its own in Accept-Ranges header (Section 18.5) to declare supported time formats and also in the Range header (Section 18.40) to request the time format used in the response.",
      "ja": "RTSPは現在、以下に定義する三つの異なるメディア・タイム・フォーマットをサポートしています。追加の時刻形式は、将来的に指定することができます。これらの時間フォーマットは、再生を要求し、メディア位置プロトコル要求が実際又は起こったであろう時に指定するRangeヘッダー（セクション18.40）で使用することができます。それらはまた、メディア-Rangeヘッダ（セクション18.30）を使用して、メディアのプロパティの説明に使用されます。非修飾フォーマット識別子は、サポートされている時間フォーマットを宣言するために独自に受け入れ-範囲ヘッダ（セクション18.5）で使用され、また、Rangeヘッダ（セクション18.40）に応答して使用される時間形式を要求します。"
    },
    {
      "indent": 0,
      "text": "4.4.1. SMPTE-Relative Timestamps",
      "section_title": true,
      "ja": "4.4.1.  SMPTE-相対タイムスタンプ"
    },
    {
      "indent": 3,
      "text": "A timestamp may use a format derived from a Society of Motion Picture and Television Engineers (SMPTE) specification and expresses time offsets anchored at the start of the media clip. Relative timestamps are expressed as SMPTE time codes [SMPTE-TC] for frame-level access accuracy. The time code has the format:",
      "ja": "タイムスタンプは映画テレビ技術（SMPTE）規格協会に由来するフォーマットを使用してメディアクリップの開始で固定時間オフセットを表すことができます。相対タイムスタンプは、フレームレベルのアクセス精度のためのSMPTEタイムコード[SMPTE-TC]として表されます。タイムコードの形式は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "hours:minutes:seconds:frames.subframes",
      "ja": "時間：分：秒：frames.subframes"
    },
    {
      "indent": 3,
      "text": "with the origin at the start of the clip. The default SMPTE format is \"SMPTE 30 drop\" format, with a frame rate of 29.97 frames per second. Other SMPTE codes MAY be supported (such as \"SMPTE 25\") through the use of \"smpte-type\". For SMPTE 30, the \"frames\" field in the time value can assume the values 0 through 29. The difference between 30 and 29.97 frames per second is handled by dropping the first two frame indices (values 00 and 01) of every minute, except every tenth minute. If the frame and the subframe values are zero, they may be omitted. Subframes are measured in hundredths of a frame.",
      "ja": "クリップの開始時に起源を持ちます。デフォルトSMPTEフォーマットは、毎秒29.97フレームのフレームレートで、「SMPTE 30ドロップ」の形式です。他のSMPTEコードは「SMPTE型」の使用を介して（例えば、「SMPTE 25」など）がサポートされるかもしれません。 SMPTE 30のために、時間値の「フレーム」フィールドは、毎秒30と29.97フレーム間の差分を除いて、毎分（00と01値）最初の2つのフレームインデックスをドロップすることによって処理された値に29を介して0をとることができます10回に1回分。フレームとサブフレームの値がゼロである場合、それらは省略してもよいです。サブフレームは、フレームの1/100に測定されています。"
    },
    {
      "indent": 3,
      "text": "Examples:",
      "ja": "例："
    },
    {
      "indent": 5,
      "text": "smpte=10:12:33:20- smpte=10:07:33- smpte=10:07:00-10:07:33:05.01 smpte-25=10:07:00-10:07:33:05.01",
      "ja": "SMPTE = 10：12：33：20- SMPTE = 10：07：33- SMPTE = 10：07：00-10：07：33：5.1 SMPTE-25 = 10：07：00-10：07：33：5.1"
    },
    {
      "indent": 0,
      "text": "4.4.2. Normal Play Time",
      "section_title": true,
      "ja": "4.4.2. 通常再生時間"
    },
    {
      "indent": 3,
      "text": "Normal Play Time (NPT) indicates the stream-absolute position relative to the beginning of the presentation. The timestamp consists of two parts: The mandatory first part may be expressed in either seconds only or in hours, minutes, and seconds. The optional second part consists of a decimal point and decimal figures and indicates fractions of a second.",
      "ja": "通常再生時間（NPT）は、プレゼンテーションの先頭からの相対ストリーム絶対位置を示します。タイムスタンプは2つの部分から構成：必須の最初の部分のみまたは時間、分、秒のいずれか秒単位で表すことができます。任意の第二の部分は、小数点と小数の数値で構成され、第二の画分を示します。"
    },
    {
      "indent": 3,
      "text": "The beginning of a presentation corresponds to 0.0 seconds. Negative values are not defined.",
      "ja": "プレゼンテーションの始まりは0.0秒に対応しています。負の値は定義されていません。"
    },
    {
      "indent": 3,
      "text": "The special constant \"now\" is defined as the current instant of a live event. It MAY only be used for live events and MUST NOT be used for on-demand (i.e., non-live) content.",
      "ja": "特別な定数は、「今」ライブイベントの現在の瞬間として定義されます。それが唯一のライブイベントのために用いることができ、オンデマンド（すなわち、非ライブ）コンテンツのために使用してはいけません。"
    },
    {
      "indent": 3,
      "text": "NPT is defined as in Digital Storage Media Command and Control (DSMb;CC) [ISO.13818-6.1995]:",
      "ja": "：[ISO.13818-6.1995]; NPTは、デジタルストレージメディアコマンドおよびコントロール（CC DSMB）のように定義されます"
    },
    {
      "indent": 6,
      "text": "Intuitively, NPT is the clock the viewer associates with a program. It is often digitally displayed on a DVD player. NPT advances normally when in normal play mode (scale = 1), advances at a faster rate when in fast-scan forward (high positive scale ratio), decrements when in scan reverse (negative scale ratio) and is fixed in pause mode. NPT is (logically) equivalent to SMPTE time codes.",
      "ja": "直感的に、NPTは、プログラムで、視聴者の仲間クロックです。それは、多くの場合、デジタルDVDプレーヤーに表示されています。 NPTは、通常再生モード（スケール= 1）で、より速い速度で進むときに通常進むときに前方に高速走査（高い正縮尺比率）で、スキャン逆（負スケール比）とに休止モードに固定されてデクリメント。 NPTは（論理的）SMPTEタイムコードと同等です。"
    },
    {
      "indent": 3,
      "text": "Examples:",
      "ja": "例："
    },
    {
      "indent": 5,
      "text": "npt=123.45-125 npt=12:05:35.3- npt=now-",
      "ja": "NPT = 123.45から125 NPT = 12：05：35.3- NPT = NOW-"
    },
    {
      "indent": 3,
      "text": "The syntax is based on ISO 8601 [ISO.8601.2000] and expresses the time elapsed since presentation start, with two different notations allowed:",
      "ja": "構文は[ISO.8601.2000] ISO 8601に基づいて、許可される二つの異なる表記で、プレゼンテーションの開始からの経過時間を表しています。"
    },
    {
      "indent": 3,
      "text": "o The npt-hhmmss notation uses an ISO 8601 extended complete representation of the time of the day format (Section 5.3.1.1 of [ISO.8601.2000] ) using colons (\":\") as separators between hours, minutes, and seconds (hh:mm:ss). The hour counter is not limited to 0-24 hours; up to nineteen (19) hour digits are allowed.",
      "ja": "HH（時間、分、秒の間のセパレータとして：NPT-HHMMSS表記はISO 8601がコロン（「」）を使用して、日フォーマット（[ISO.8601.2000]のセクション5.3.1.1）の時間の完全な表現を拡張使用oを：MM：SS）。時間カウンタは0から24時間に限定されるものではありません。 19まで（19）時間の桁が許可されています。"
    },
    {
      "indent": 6,
      "text": "* In accordance with the requirements of the ISO 8601 time format, the hours, minutes, and seconds MUST all be present, with two digits used for minutes and for seconds and with at least two digits for hours. An NPT of 7 minutes and 0 seconds is represented as \"00:07:00\", and an NPT of 392 hours, 0 minutes, and 6 seconds is represented as \"392:00:06\".",
      "ja": "* ISO 8601時刻形式の要件、時間、分、秒によると、すべての分と秒と時間のために少なくとも2桁で使用2桁で、存在しなければなりません。 7分0秒のNPTを「0時07分00秒」として表され、そして392時間、0分、6秒のNPTは、以下のように表され、「392：00：06」。"
    },
    {
      "indent": 6,
      "text": "* RTSP 1.0 allowed NPT in the npt-hhmmss notation without any leading zeros to ensure that implementations don't fail; for backward compatibility, all RTSP 2.0 implementations are REQUIRED to support receiving NPT values, hours, minutes, or seconds, without leading zeros.",
      "ja": "* RTSP実装が失敗しないことを確実にするために、任意の先行ゼロなしNPT-HHMMSS表記NPT許容1.0。下位互換性のために、すべてのRTSP 2.0実装は先行ゼロなしで、NPT値、時間、分、秒の受信をサポートするために必要とされます。"
    },
    {
      "indent": 3,
      "text": "o The npt-sec notation expresses the time in seconds, using between one and nineteen (19) digits.",
      "ja": "NPT秒表記O（19）数字1と19との間に使用して、秒単位の時間を表しています。"
    },
    {
      "indent": 3,
      "text": "Both notations allow decimal fractions of seconds as specified in Section 5.3.1.3 of [ISO.8601.2000], using at most nine digits, and allowing only \".\" (full stop) as the decimal separator.",
      "ja": "[ISO.8601.2000]のセクション5.3.1.3で指定された両方の表記は、最大で9桁の数字を使用して、とだけ可能、秒の小数を許します「」小数セパレータとして（完全停止）。"
    },
    {
      "indent": 3,
      "text": "The npt-sec notation is optimized for automatic generation; the npt-hhmmss notation is optimized for consumption by human readers. The \"now\" constant allows clients to request to receive the live feed rather than the stored or time-delayed version. This is needed since neither absolute time nor zero time are appropriate for this case.",
      "ja": "NPT秒表記は、自動生成のために最適化されています。 NPT-HHMMSS表記は、人間の読者による消費のために最適化されています。 「今」の定数は、クライアントがライブフィードではなく、保存されたまたは時間遅延バージョンを受けるために要求することができます。絶対時間も時間ゼロでもないが、この場合に適していますので、これが必要とされています。"
    },
    {
      "indent": 0,
      "text": "4.4.3. Absolute Time",
      "section_title": true,
      "ja": "4.4.3. 絶対時間"
    },
    {
      "indent": 3,
      "text": "Absolute time is expressed using a timestamp based on ISO 8601 [ISO.8601.2000]. The date is a complete representation of the calendar date in basic format (YYYYMMDD) without separators (per Section 5.2.1.1 of [ISO.8601.2000]). The time of day is provided in the complete representation basic format (hhmmss) as specified in Section 5.3.1.1 of [ISO.8601.2000], allowing decimal fractions of seconds following Section 5.3.1.3 requiring \".\" (full stop) as decimal separator and limiting the number of digits to no more than nine. The time expressed MUST use UTC (GMT), i.e., no time zone offsets are allowed. The full date and time specification is the eight-digit date followed by a \"T\" followed by the six-digit time value, optionally followed by a full stop followed by one to nine fractions of a second and ended by \"Z\", e.g., YYYYMMDDThhmmss.ssZ.",
      "ja": "絶対時間は、[ISO.8601.2000] ISO 8601に基づくタイムスタンプを使用して表現されます。日付は、基本的な形式のカレンダー日付（[ISO.8601.2000]のセクション5.2.1.1当たり）セパレータ無し（YYYYMMDD）の完全な表現です。 【ISO.8601.2000]のセクション5.3.1.1で指定されるように一日の時間が必要セクション5.3.1.3を次の秒の小数を可能にする、完全な表現の基本的な形式（HHMMSS）に設けられています「」小数点およびこれ以上9以下の桁数を制限するように（完全停止）。発現時間、すなわち、タイムゾーンオフセットが許可されていない、UTC（GMT）を使用する必要があります。完全な日付と時刻の指定は、例えば、必要に応じて第二及び「Z」によって終了の9画分に1が続くピリオドが続く6桁の時間値、続いて「T」に続く8桁の日付であります、YYYYMMDDThhmmss.ssZ。"
    },
    {
      "indent": 6,
      "text": "The reasons for this time format rather than using \"Date and Time on the Internet: Timestamps\" [RFC3339] are historic. We continue to use the format specified in RTSP 1.0. The motivations raised in RFC 3339 apply to why a selection from ISO 8601 was made; however, a different and even more restrictive selection was applied in this case.",
      "ja": "むしろ、「日付と時刻インターネット上：タイムスタンプ」を使用してよりも、この時刻の形式の理由[RFC3339]は、歴史的です。私たちは、RTSP 1.0で指定された形式を使用し続けています。 RFC 3339で育った動機は、ISO 8601からの選択が行われた理由に適用されます。ただし、異なることがより制限的選択が、この場合に適用されました。"
    },
    {
      "indent": 3,
      "text": "Below are three examples of media time formats, first, a request for a clock format range request for a starting time of November 8, 1996 at 14 h 37 min and 20 1/4 seconds UTC playing for 10 min and 5 seconds, followed by a Media-Properties header's \"Time-Limited\" UTC property for the 24th of December 2014 at 15 hours and 00 minutes, and finally a Terminate-Reason header \"time\" property for the 18th of June 2013 at 16 hours, 12 minutes, and 56 seconds:",
      "ja": "以下メディア時間フォーマットの三つの例であり、最初の10分間および5秒間再生14時間37分及び20 1/4秒UTCで1996年11月8日の開始時のクロックフォーマット範囲要求の要求は、続いて16時間、12分、および最終的に15時間と00分、2013年6月18日のために終了-理由をヘッダ「時」プロパティで2014年12月24日のためのメディア・プロパティヘッダーの「期間限定」UTCプロパティ56秒："
    },
    {
      "indent": 5,
      "text": "clock=19961108T143720.25Z-19961108T144725.25Z Time-Limited=20141224T1500Z time=20130618T161256Z",
      "ja": "クロック= 19961108T143720.25Z-19961108T144725.25Z期間限定= 20141224T1500Z時間= 20130618T161256Z"
    },
    {
      "indent": 0,
      "text": "4.5. Feature Tags",
      "section_title": true,
      "ja": "4.5. フィーチャータグ"
    },
    {
      "indent": 3,
      "text": "Feature tags are unique identifiers used to designate features in RTSP. These tags are used in Require (Section 18.43), Proxy-Require (Section 18.37), Proxy-Supported (Section 18.38), Supported (Section 18.51), and Unsupported (Section 18.55) header fields.",
      "ja": "フィーチャータグは、RTSPの機能を指定するために使用される一意の識別子です。これらのタグは、（セクション18.43）、プロキシ要求（セクション18.37）、プロキシサポート（セクション18.38）、サポートされている（セクション18.51）、およびサポートされていない（セクション18.55）ヘッダーフィールドが必要で使用されています。"
    },
    {
      "indent": 3,
      "text": "A feature tag definition MUST indicate which combination of clients, servers, or proxies to which it applies.",
      "ja": "フィーチャータグの定義は、それが適用されるクライアント、サーバ、またはプロキシのどの組み合わせを示さなければなりません。"
    },
    {
      "indent": 3,
      "text": "The creator of a new RTSP feature tag should either prefix the feature tag with a reverse domain name (e.g., \"com.example.mynewfeature\" is an apt name for a feature whose inventor can be reached at \"example.com\") or register the new feature tag with the Internet Assigned Numbers Authority (IANA). (See Section 22, \"IANA Considerations\".)",
      "ja": "新しいRTSPフィーチャータグの作成者は、逆ドメイン名でフィーチャータグの前に付ける必要があるのいずれかまたはレジスタ（例えば、「com.example.mynewfeature」aptの発明「example.com」に到達することができる機能の名前です） IANA（Internet Assigned Numbers Authority）の持つ新しい機能タグ。 （第22、 \"IANAの考慮事項\" を参照してください。）"
    },
    {
      "indent": 3,
      "text": "The usage of feature tags is further described in Section 11, which deals with capability handling.",
      "ja": "フィーチャータグの使用は、さらに機能の処理を扱うセクション11に記載されています。"
    },
    {
      "indent": 0,
      "text": "4.6. Message Body Tags",
      "section_title": true,
      "ja": "4.6. メッセージ本文のタグ"
    },
    {
      "indent": 3,
      "text": "Message body tags are opaque strings that are used to compare two message bodies from the same resource, for example, in caches or to optimize setup after a redirect. Message body tags can be carried in the MTag header (see Section 18.31) or in SDP (see Appendix D.1.9). MTag is similar to ETag in HTTP/1.1 (see Section 3.11 of [RFC2068]).",
      "ja": "メッセージ本文のタグがキャッシュに、例えば、同一のリソースからの2人のメッセージ体を比較するか、リダイレクト後に設定を最適化するために使用される不透明な文字列です。メッセージ本文タグがMTAGヘッダーで実施することができる（セクション18.31を参照）またはSDPに（付録D.1.9参照）。 MTAGは（[RFC2068]のセクション3.11を参照）HTTP / 1.1でのETagと同様です。"
    },
    {
      "indent": 3,
      "text": "A message body tag MUST be unique across all versions of all message bodies associated with a particular resource. A given message body tag value MAY be used for message bodies obtained by requests on different URIs. The use of the same message body tag value in conjunction with message bodies obtained by requests on different URIs does not imply the equivalence of those message bodies.",
      "ja": "メッセージのbodyタグは、特定のリソースに関連付けられたすべてのメッセージ体のすべてのバージョンで一意である必要があります。与えられたメッセージ本体タグの値が異なるのURIにリクエストして得られたメッセージ本体のために使用されるかもしれません。別のURIにリクエストして得られたメッセージ本文と一緒に同じメッセージボディタグ値の使用は、それらのメッセージ本体の等価性を意味するものではありません。"
    },
    {
      "indent": 3,
      "text": "Message body tags are used in RTSP to make some methods conditional. The methods are made conditional through the inclusion of headers; see Section 18.24 and Section 18.26 for information on the If-Match and If-None-Match headers, respectively. Note that RTSP message body tags apply to the complete presentation, i.e., both the presentation description and the individual media streams. Thus, message body tags can be used to verify at setup time after a redirect that the same session description applies to the media at the new location using the If-Match header.",
      "ja": "メッセージ本文タグは、いくつかのメソッドを条件付きにするRTSPで使用されています。方法は、ヘッダを含めることによって条件行われます。それぞれのセクション18.24とIF-マッチの詳細については、セクション18.26とIF-なしマッチヘッダを参照してください。プレゼンテーション記述および個々のメディアストリームの両方、すなわち、RTSPメッセージボディタグが完了プレゼンテーションに適用されます。したがって、メッセージボディタグは、同じセッション記述は、If-Matchヘッダーを使用して新しい場所にメディアに適用リダイレクト後にセットアップ時に確認するために使用することができます。"
    },
    {
      "indent": 0,
      "text": "4.7. Media Properties",
      "section_title": true,
      "ja": "4.7. メディアのプロパティ"
    },
    {
      "indent": 3,
      "text": "When an RTSP server handles media, it is important to consider the different properties a media instance for delivery and playback can have. This specification considers the media properties listed below in its protocol operations. They are derived from the differences between a number of supported usages.",
      "ja": "RTSPサーバがメディアを扱う際には、配信、再生のためのメディアインスタンスを持つことができます異なる特性を考慮することが重要です。この仕様は、プロトコル動作に下記のメディア特性を考慮する。これらは、サポート使用回数との違いに由来しています。"
    },
    {
      "indent": 3,
      "text": "On-demand: Media that has a fixed (given) duration that doesn't change during the lifetime of the RTSP session and is known at the time of the creation of the session. It is expected that the content of the media will not change, even if the representation, such as encoding, or quality, may change. Generally, one can seek, i.e., request any range, within the media.",
      "ja": "オンデマンド：RTSPセッションの存続期間中に変化しない固定（一定）持続時間を有し、セッションの作成時に知られているメディア。このような符号化、又は品質などの表現は、変更することができる場合であっても、メディアの内容が変化しないことが予想されます。一般的に、一つはメディア内に、すなわち、任意の範囲を要求する、求めることができます。"
    },
    {
      "indent": 3,
      "text": "Dynamic On-demand: This is a variation of the on-demand case where external methods are used to manipulate the actual content of the media setup for the RTSP session. The main example is content defined by a playlist.",
      "ja": "ダイナミックなオンデマンド：これは、外部メソッドがRTSPセッションのためのメディアのセットアップの実際のコンテンツを操作するために使用されているオンデマンド例ばらつきがあります。主な例は、プレイリストによって定義されたコンテンツです。"
    },
    {
      "indent": 3,
      "text": "Live: Live media represents a progressing content stream (such as broadcast TV) where the duration may or may not be known. It is not seekable, only the content presently being delivered can be accessed.",
      "ja": "ライブ：ライブメディアは継続時間が、または知られていてもいなくてもよい（例えば、放送テレビなどの）進行コンテンツストリームを表します。これは、現在配信中のコンテンツのみがアクセスすることができ、シークではありません。"
    },
    {
      "indent": 3,
      "text": "Live with Recording: A live stream that is combined with a server-side capability to store and retain the content of the live session and allow for random access delivery within the part of the already-recorded content. The actual behavior of the media stream is very much dependent on the retention policy for the media stream; either the server will be able to capture the complete media stream or it will have a limitation in how much will be retained. The media range will dynamically change as the session progress. For servers with a limited amount of storage available for recording, there will typically be a sliding window that moves forward while new data is made available and older data is discarded.",
      "ja": "レコーディングと同居：サーバ側の能力と組み合わされるライブストリームを格納し、ライブセッションの内容を保持し、既に記録されたコンテンツの一部内のランダムアクセスの配信を可能にします。メディア・ストリームの実際の動作は、メディアストリームのための保持ポリシーに大きく依存しています。いずれかのサーバーは、完全なメディアストリームをキャプチャすることができるようになりますか、それは保持されますどのくらいの制限があります。メディアの範囲は、動的にセッションの進行状況と変化します。記録のために使用可能なストレージの限られた量を持つサーバの場合は、通常、新しいデータが利用可能になると古いデータが破棄されながら前方に移動スライディングウィンドウが存在します。"
    },
    {
      "indent": 3,
      "text": "To cover the above usages, the following media properties with appropriate values are specified.",
      "ja": "上記の用途をカバーするために、適切な値を次のメディアプロパティが指定されています。"
    },
    {
      "indent": 0,
      "text": "4.7.1. Random Access and Seeking",
      "section_title": true,
      "ja": "4.7.1. ランダムアクセスと探しています"
    },
    {
      "indent": 3,
      "text": "Random access is the ability to specify and get media delivered starting from any time (instant) within the content, an operation called \"seeking\". The Media-Properties header will indicate the general capability for a media resource to perform random access.",
      "ja": "ランダムアクセスは、メディアは、コンテンツ内の任意の時間（瞬間）から始まる「求める」と呼ばれる操作を納入指定して取得する機能です。メディアのプロパティヘッダーは、ランダムアクセスを実行するためのメディアリソースのための一般的な機能を示します。"
    },
    {
      "indent": 3,
      "text": "Random-Access: The media is seekable to any out of a large number of points within the media. Due to media-encoding limitations, a particular point may not be reachable, but seeking to a point close by is enabled. A floating-point number of seconds may be provided to express the worst-case distance between random access points.",
      "ja": "ランダムアクセス：メディアはメディア内の多数の点のうちいずれかにシーク可能です。メディア符号化の制約のために、特定のポイントが到達可能ではないかもしれないが、有効になっていることにより近い点にシーク。秒の浮動小数点数は、ランダムアクセスポイントとの間の最悪の場合の距離を表現するために提供されてもよいです。"
    },
    {
      "indent": 3,
      "text": "Beginning-Only: Seeking is only possible to the beginning of the content.",
      "ja": "始まり-のみ：探しているコンテンツの先頭にのみ可能です。"
    },
    {
      "indent": 3,
      "text": "No-Seeking: Seeking is not possible at all.",
      "ja": "無探している：探しているが、全く不可能です。"
    },
    {
      "indent": 3,
      "text": "If random access is possible, as indicated by the Media-Properties header, the actual behavior policy when seeking can be controlled using the Seek-Style header (Section 18.47).",
      "ja": "メディアプロパティヘッダによって示されるように、ランダムアクセスは、可能であれば、実際の行動方針シークするときシークスタイルヘッダ（セクション18.47）を使用して制御することができます。"
    },
    {
      "indent": 0,
      "text": "4.7.2. Retention",
      "section_title": true,
      "ja": "4.7.2. 保持"
    },
    {
      "indent": 3,
      "text": "The following retention policies are used by media to limit possible protocol operations:",
      "ja": "以下の保持ポリシーは、可能なプロトコル動作を制限するために、メディアによって使用されます。"
    },
    {
      "indent": 3,
      "text": "Unlimited: The media will not be removed as long as the RTSP session is in existence.",
      "ja": "アンリミテッド：メディアは限りRTSPセッションが存在しているように除去されることはありません。"
    },
    {
      "indent": 3,
      "text": "Time-Limited: The media will not be removed before the given wallclock time. After that time, it may or may not be available anymore.",
      "ja": "期間限定：メディアは、与えられた壁時計の時間の前に削除されません。その時間の後、それは、またはもう使用できない可能性があります。"
    },
    {
      "indent": 3,
      "text": "Time-Duration: The media (on fragment or unit basis) will be retained for the specified duration.",
      "ja": "時間期間：（断片又は単位で）メディアが指定された期間のために保持されるであろう。"
    },
    {
      "indent": 0,
      "text": "4.7.3. Content Modifications",
      "section_title": true,
      "ja": "4.7.3. コンテンツの変更"
    },
    {
      "indent": 3,
      "text": "The media content and its timeline can be of different types, e.g. pre-produced content on demand, a live source that is being generated as time progresses, or something that is dynamically altered or recomposed during playback. Therefore, a media property for content modifications is needed and the following initial values are defined:",
      "ja": "メディアコンテンツとそのタイムラインは、例えば、異なる種類のものとすることができますオンデマンドコンテンツ、時間の経過、または動的に再生中に変更または再構成されたものとして生成されているライブソースを事前に作成。したがって、コンテンツの変更のためのメディアプロパティが必要とされ、次の初期値が定義されています。"
    },
    {
      "indent": 3,
      "text": "Immutable: The content of the media will not change, even if the representation, such as encoding or quality changes.",
      "ja": "不変：メディアの内容は変更されません、たとえそのような符号化や品質の変化として表現。"
    },
    {
      "indent": 3,
      "text": "Dynamic: The content can change due to external methods or triggers, such as playlists, but this will be announced by explicit updates.",
      "ja": "ダイナミック：コンテンツは、そのようなプレイリストなどの外部メソッドまたはトリガーに変更することができますが、これは明示的な更新によって発表されます。"
    },
    {
      "indent": 3,
      "text": "Time-Progressing: As time progresses, new content will become available. If the content is also retained, it will become longer as everything between the start point and the point currently being made available can be accessed. If the media server uses a sliding-window policy for retention, the start point will also change as time progresses.",
      "ja": "時間が進むと-：時間が進むにつれて、新しいコンテンツが利用可能になります。内容も保持されている場合は、開始点の間のすべてのように長くなり、現在利用可能になる点は、アクセスすることができます。メディアサーバーが保持のためのスライディングウィンドウポリシーを使用している場合は、時間が進むにつれて、開始点も変更されます。"
    },
    {
      "indent": 0,
      "text": "4.7.4. Supported Scale Factors",
      "section_title": true,
      "ja": "4.7.4. サポートされているスケールファクター"
    },
    {
      "indent": 3,
      "text": "A particular media content item often supports only a limited set or range of scales when delivering the media. To enable the client to know what values or ranges of scale operations that the whole content or the current position supports, a media properties attribute for this is defined that contains a list with the values or ranges that are supported. The attribute is named \"Scales\". The \"Scales\" attribute may be updated at any point in the content due to content consisting of spliced pieces or content being dynamically updated by out-of-band mechanisms.",
      "ja": "メディアを配信する際に、特定のメディアコンテンツアイテムは、多くの場合、限られたセットまたはスケールの範囲をサポートします。全体のコンテンツや現在位置がサポートしていることを、プロパティはこのためにmedia属性がサポートされている値または範囲のリストを含むように定義されているものの値またはスケール操作の範囲を知っているクライアントを有効にするには。属性は、「スケール」と命名されます。 「スケール」属性は、動的にアウトオブバンドメカニズムによって更新されるスプライスさ個又はコンテンツからなるコンテンツによるコンテンツの任意の時点で更新されてもよいです。"
    },
    {
      "indent": 0,
      "text": "4.7.5. Mapping to the Attributes",
      "section_title": true,
      "ja": "4.7.5. 属性へのマッピング"
    },
    {
      "indent": 3,
      "text": "This section shows examples of how one would map the above usages to the properties and their values.",
      "ja": "このセクションでは、1つのプロパティとその値に上記用途をマップする方法の例を示しています。"
    },
    {
      "indent": 3,
      "text": "Example of On-Demand: Random Access: Random-Access=5.0, Content Modifications: Immutable, Retention: Unlimited or Time-Limited.",
      "ja": "オンデマンドの例：ランダムアクセス：ランダム・アクセス= 5.0、コンテンツの変更：不変、保持期間：無制限または期間限定。"
    },
    {
      "indent": 3,
      "text": "Example of Dynamic On-Demand: Random Access: Random-Access=3.0, Content Modifications: Dynamic, Retention: Unlimited or Time-Limited.",
      "ja": "ダイナミックなオンデマンドの例：ランダムアクセス：ランダム・アクセス= 3.0、コンテンツの変更：ダイナミック、保持期間：無制限または期間限定。"
    },
    {
      "indent": 3,
      "text": "Example of Live: Random Access: No-Seeking, Content Modifications: Time-Progressing, Retention: Time-Duration=0.0",
      "ja": "ライブの例：ランダムアクセス：無探して、コンテンツの変更：時間進み、保持：時間持続時間= 0.0"
    },
    {
      "indent": 3,
      "text": "Example of Live with Recording: Random Access: Random-Access=3.0, Content Modifications: Time-Progressing, Retention: Time-Duration=7200.0",
      "ja": "レコーディングとライブの例：ランダムアクセス：ランダム・アクセス= 3.0、コンテンツの変更：時間進み、保持期間：タイム期間= 7200.0"
    },
    {
      "indent": 0,
      "text": "5. RTSP Message",
      "section_title": true,
      "ja": "5. RTSPメッセージ"
    },
    {
      "indent": 3,
      "text": "RTSP is a text-based protocol that uses the ISO 10646 character set in UTF-8 encoding per RFC 3629 [RFC3629]. Lines MUST be terminated by a CRLF.",
      "ja": "RTSPは、RFC 3629 [RFC3629]あたりのUTF-8エンコーディングにISO 10646文字セットを使用して、テキストベースのプロトコルです。行はCRLFで終了する必要があります。"
    },
    {
      "indent": 6,
      "text": "Text-based protocols make it easier to add optional parameters in a self-describing manner. Since the number of parameters and the frequency of commands is low, processing efficiency is not a concern. Text-based protocols, if used carefully, also allow easy implementation of research prototypes in scripting languages such as Python, PHP, Perl and TCL.",
      "ja": "テキストベースのプロトコルは、それが簡単に自己記述的にオプションのパラメータを追加します。パラメータの数及びコマンドの頻度が低いため、処理効率が問題ではありません。テキストベースのプロトコル、慎重に使用している場合、また、PythonやPHP、PerlやTCLなどのスクリプト言語の研究試作品の容易な実装を可能にします。"
    },
    {
      "indent": 3,
      "text": "The ISO 10646 character set avoids character-set switching, but is invisible to the application as long as US-ASCII is being used. This is also the encoding used for text fields in RTCP [RFC3550].",
      "ja": "ISO 10646文字セットは、文字セットの切り替えを回避できますが、限り、US-ASCIIが使用されているように、アプリケーションには見えません。これはまた、RTCP [RFC3550]のテキストフィールドに使用される符号です。"
    },
    {
      "indent": 3,
      "text": "A request contains a method, the object the method is operating upon, and parameters to further describe the method. Methods are idempotent unless otherwise noted. Methods are also designed to require little or no state maintenance at the media server.",
      "ja": "要求は、別の方法を説明するための方法であって、この方法は、上に動作しているオブジェクト、およびパラメータを含みます。特に断りのない限り、方法が冪等されています。方法は、メディアサーバーではほとんどあるいはまったく状態の維持を必要とするように設計されています。"
    },
    {
      "indent": 0,
      "text": "5.1. Message Types",
      "section_title": true,
      "ja": "5.1. メッセージタイプ"
    },
    {
      "indent": 3,
      "text": "RTSP messages are either requests from client to server or from server to client, and responses in the reverse direction. Request (Section 7) and response (Section 8) messages use a format based on the generic message format of RFC 5322 [RFC5322] for transferring bodies (the payload of the message). Both types of messages consist of a start-line, zero or more header fields (also known as \"headers\"), an empty line (i.e., a line with nothing preceding the CRLF) indicating the end of the headers, and possibly the data of the message body. The ABNF [RFC5234] below is for illustration only; the formal message specification is presented in Section 20.2.2.",
      "ja": "RTSPメッセージは、クライアントからサーバーへ、またはサーバーからクライアントへの要求、および逆方向の応答のどちらかです。要求（セクション7）及び応答（セクション8）メッセージ本体を転送するためのRFC 5322 [RFC5322]の一般的なメッセージフォーマットに基づいてフォーマット（メッセージのペイロード）を使用します。メッセージの両方のタイプは、スタートライン、ゼロまたはそれ以上のヘッダーフィールド（また、「ヘッダー」としても知られる）、空行から成る（すなわち、CRLF前に何もない行）ヘッダの終了を示す、およびおそらくデータメッセージ本文の。以下ABNF [RFC5234]は単に例示のためのものです。正式なメッセージ仕様は、20.2.2項に示されています。"
    },
    {
      "indent": 3,
      "text": "generic-message = start-line *(rtsp-header CRLF) CRLF [ message-body-data ] start-line = Request-Line / Status-Line",
      "ja": "一般的なメッセージ=開始行*（RTSPヘッダCRLF）CRLF [メッセージボディデータ]スタートライン=要求ライン/ステータスラインを"
    },
    {
      "indent": 3,
      "text": "In the interest of robustness, agents MUST ignore any empty line(s) received where a Request-Line or Status-Line is expected. In other words, if the agent is reading the protocol stream at the beginning of a message and receives any number of CRLFs first, it MUST ignore all of the CRLFs.",
      "ja": "ロバスト性の利益のために、薬剤は、Request-Lineまたはステータスラインが予想される場合、任意の空のライン（S）を受信無視しなければなりません。エージェントは、メッセージの先頭にプロトコル・ストリームを読み取り、最初のCRLFの任意の番号を受信した場合、他の言葉で、それはのCRLFのすべてを無視しなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.2. Message Headers",
      "section_title": true,
      "ja": "5.2. メッセージヘッダ"
    },
    {
      "indent": 3,
      "text": "RTSP header fields (see Section 18) include general-header, request-header, response-header, and message body header fields.",
      "ja": "RTSPヘッダフィールド（セクション18を参照）は、一般的なヘッダ、リクエストヘッダ、応答ヘッダとメッセージボディヘッダフィールドを含みます。"
    },
    {
      "indent": 3,
      "text": "The order in which header fields with differing field names are received is not significant. However, it is \"good practice\" to send general-header fields first, followed by a request-header or response-header field, and ending with the message body header fields.",
      "ja": "異なるフィールド名を持つヘッダフィールドが受信される順序は重要ではありません。しかし、リクエストヘッダやレスポンスヘッダフィールドに続く最初の一般的なヘッダフィールドを送信するために「お勧め」であり、メッセージボディヘッダフィールドで終わります。"
    },
    {
      "indent": 3,
      "text": "Multiple header fields with the same field-name MAY be present in a message if and only if the entire field-value for that header field is defined as a comma-separated list. It MUST be possible to combine the multiple header fields into one \"field-name: field-value\" pair, without changing the semantics of the message, by appending each subsequent field-value to the first, each separated by a comma. The order in which header fields with the same field-name are received is therefore significant to the interpretation of the combined field value; thus, a proxy MUST NOT change the order of these field-values when a message is forwarded.",
      "ja": "そのヘッダフィールドの全体のフィールド値をカンマ区切りのリストとして定義されている場合にのみ場合に同じフィールド名を持つ複数のヘッダフィールドは、メッセージ中に存在してもよいです。カンマで区切られ、最初に後続の各フィールド値を追加することによって、メッセージのセマンティクスを変更することなく、「フィールド値のフィールド名」ペア1つに複数のヘッダフィールドを組み合わせることが可能でなければなりません。同じフィールド名を持つヘッダフィールドが受信される順序は、合成フィールド値の解釈することが重要です。メッセージが転送されたときにこのように、プロキシは、これらのフィールドの値の順序を変更しないでください。"
    },
    {
      "indent": 3,
      "text": "Unknown message headers MUST be ignored (skipping over the header to the next protocol element, and not causing an error) by an RTSP server or client. An RTSP proxy MUST forward unknown message headers. Message headers defined outside of this specification that are required to be interpreted by the RTSP agent will need to use feature tags (Section 4.5) and include them in the appropriate Require (Section 18.43) or Proxy-Require (Section 18.37) header.",
      "ja": "未知のメッセージヘッダはRTSPサーバまたはクライアントが（次のプロトコル・エレメントにヘッダをスキップし、エラーの原因となっていない）を無視しなければなりません。 RTSPプロキシは、未知のメッセージヘッダを転送する必要があります。 RTSPエージェントによって解釈されるために必要とされる本明細書の外部で定義されたメッセージヘッダは、特徴タグ（セクション4.5）を使用する必要があり、適切なそれらを含む（セクション18.43）を必要とするか、またはプロキシ要求（セクション18.37）ヘッダ。"
    },
    {
      "indent": 0,
      "text": "5.3. Message Body",
      "section_title": true,
      "ja": "5.3. メッセージ本文"
    },
    {
      "indent": 3,
      "text": "The message body (if any) of an RTSP message is used to carry further information for a particular resource associated with the request or response. An example of a message body is an SDP message.",
      "ja": "RTSPメッセージのメッセージ本体は、（もしあれば）要求または応答に関連付けられた特定のリソースのためのさらなる情報を搬送するために使用されます。メッセージ本文の例は、SDPメッセージです。"
    },
    {
      "indent": 3,
      "text": "The presence of a message body in either a request or a response MUST be signaled by the inclusion of a Content-Length header (see Section 18.17) and Content-Type header (see Section 18.19). A message body MUST NOT be included in a request or response if the specification of the particular method (see Method Definitions (Section 13)) does not allow sending a message body. In case a message body is received in a message when not expected, the message body data SHOULD be discarded. This is to allow future extensions to define optional use of a message body.",
      "ja": "要求又は応答のいずれかでメッセージボディの存在は、Content-Lengthヘッダ（セクション18.17を参照）、Content-Typeヘッダ（セクション18.19を参照）を含めることによって通知されなければなりません。特定の方法（方法の定義（セクション13）を参照）の仕様は、メッセージ本文を送信許可しない場合、メッセージボディは、要求または応答に含まれてはいけません。場合、メッセージ本体は期待できない、メッセージ本文のデータが廃棄されるべきメッセージで受信されます。これは、将来の拡張は、メッセージ本文の任意の使用を定義することができるようにすることです。"
    },
    {
      "indent": 0,
      "text": "5.4. Message Length",
      "section_title": true,
      "ja": "5.4. メッセージの長さ"
    },
    {
      "indent": 3,
      "text": "An RTSP message that does not contain any message body is terminated by the first empty line after the header fields (note: an empty line is a line with nothing preceding the CRLF.). In RTSP messages that contain message bodies, the empty line is followed by the message body. The length of that body is determined by the value of the Content-Length header (Section 18.17). The value in the header represents the length of the message body in octets. If this header field is not present, a value of zero is assumed, i.e., no message body present in the message. Unlike an HTTP message, an RTSP message MUST contain a Content-Length header whenever it contains a message body. Note that RTSP does not support the HTTP/1.1 \"chunked\" transfer coding (see Section 4.1 of [RFC7230]).",
      "ja": "任意のメッセージ本体を含まないRTSPメッセージは、ヘッダフィールドの後の最初の空行で終了する（注：空の行はCRLFの前に何もない行です）。メッセージ本文を含むRTSPメッセージに、空行は、メッセージ本体が続きます。その本体の長さは、Content-Lengthヘッダ（セクション18.17）の値によって決定されます。ヘッダの値はオクテットでメッセージ本文の長さを表します。このヘッダフィールドが存在しない場合、ゼロの値は、メッセージで、すなわち、メッセージ本体が存在する、と仮定されます。それはメッセージ本体を含んでいるたびにHTTPメッセージとは異なり、RTSPメッセージは、Content-Lengthヘッダを含まなければなりません。 RTSPは、HTTP / 1.1をサポートしていないことに注意してください転送コーディング（[RFC7230]のセクション4.1を参照）、「チャンク」。"
    },
    {
      "indent": 6,
      "text": "Given the moderate length of presentation descriptions returned, the server should always be able to determine its length, even if it is generated dynamically, making the chunked transfer encoding unnecessary.",
      "ja": "返されたプレゼンテーション記述の適度な長さを考えると、サーバは常にそれがチャンク転送エンコードが不要になって、動的に生成された場合でも、その長さを決定することができるはずです。"
    },
    {
      "indent": 0,
      "text": "6. General-Header Fields",
      "section_title": true,
      "ja": "6.一般ヘッダフィールド"
    },
    {
      "indent": 3,
      "text": "General headers are headers that may be used in both requests and responses. The general-headers are listed in Table 1:",
      "ja": "一般的なヘッダは、要求と応答の両方で使用することができるヘッダです。一般ヘッダーは、表1に列挙されています。"
    },
    {
      "indent": 18,
      "text": "+--------------------+----------------+\n| Header Name        | Defined in     |\n+--------------------+----------------+\n| Accept-Ranges      | Section 18.5   |\n|                    |                |\n| Cache-Control      | Section 18.11  |\n|                    |                |\n| Connection         | Section 18.12  |\n|                    |                |\n| CSeq               | Section 18.20  |\n|                    |                |\n| Date               | Section 18.21  |\n|                    |                |\n| Media-Properties   | Section 18.29  |\n|                    |                |\n| Media-Range        | Section 18.30  |\n|                    |                |\n| Pipelined-Requests | Section 18.33  |\n|                    |                |\n| Proxy-Supported    | Section 18.38  |\n|                    |                |\n| Range              | Section 18.40  |\n|                    |                |\n| RTP-Info           | Section 18.45  |\n|                    |                |\n| Scale              | Section 18.46  |\n|                    |                |\n| Seek-Style         | Section 18.47  |\n|                    |                |\n| Server             | Section 18.48  |\n|                    |                |\n| Session            | Section 18.49  |\n|                    |                |\n| Speed              | Section 18.50  |\n|                    |                |\n| Supported          | Section 18.51  |\n|                    |                |\n| Timestamp          | Section 18.53  |\n|                    |                |\n| Transport          | Section 18.54  |\n|                    |                |\n| User-Agent         | Section 18.56  |\n|                    |                |\n| Via                | Section 18.57  |\n+--------------------+----------------+",
      "raw": true
    },
    {
      "indent": 17,
      "text": "Table 1: The General Headers Used in RTSP",
      "ja": "表1：RTSPで使用される一般ヘッダ"
    },
    {
      "indent": 0,
      "text": "7. Request",
      "section_title": true,
      "ja": "7.リクエスト"
    },
    {
      "indent": 3,
      "text": "A request message uses the format outlined below regardless of the direction of a request, whether client to server or server to client:",
      "ja": "要求メッセージは、クライアントかサーバまたはサーバへのクライアントに関係なく、要求の方向を以下に概説するフォーマットを使用します。"
    },
    {
      "indent": 3,
      "text": "o Request line, containing the method to be applied to the resource, the identifier of the resource, and the protocol version in use;",
      "ja": "Oメソッドを含む要求ラインは、リソース、リソースの識別子、および使用中のプロトコル・バージョンに適用されます。"
    },
    {
      "indent": 3,
      "text": "o Zero or more Header lines, which can be of the following types: general-headers (Section 6), request-headers (Section 7.2), or message body headers (Section 9.1);",
      "ja": "Oゼロまたは次のタイプのものとすることができるより多くのヘッダ行、：一般ヘッダ（第6節）、リクエスト・ヘッダー（セクション7.2）、またはメッセージボディヘッダ（セクション9.1）。"
    },
    {
      "indent": 3,
      "text": "o One empty line (CRLF) to indicate the end of the header section;",
      "ja": "O 1つの空行（CRLF）はヘッダ部の終わりを示すために。"
    },
    {
      "indent": 3,
      "text": "o Optionally, a message body, consisting of one or more lines. The length of the message body in octets is indicated by the Content-Length message header.",
      "ja": "必要に応じて、メッセージ本体は、一つ以上の行から成るO。オクテット内のメッセージボディの長さは、コンテンツ長メッセージヘッダにより示されます。"
    },
    {
      "indent": 0,
      "text": "7.1. Request Line",
      "section_title": true,
      "ja": "7.1. 要求行"
    },
    {
      "indent": 3,
      "text": "The request line provides the key information about the request: what method, on what resources, and using which RTSP version. The methods that are defined by this specification are listed in Table 2.",
      "ja": "どのような方法で、どのように資源を、どのRTSPのバージョンを使用して：リクエストラインは、要求に関する重要な情報を提供します。本明細書で定義されている方法は、表2に列挙されています。"
    },
    {
      "indent": 20,
      "text": "+---------------+----------------+\n| Method        | Defined in     |\n+---------------+----------------+\n| DESCRIBE      | Section 13.2   |\n|               |                |\n| GET_PARAMETER | Section 13.8   |\n|               |                |\n| OPTIONS       | Section 13.1   |\n|               |                |\n| PAUSE         | Section 13.6   |\n|               |                |\n| PLAY          | Section 13.4   |\n|               |                |\n| PLAY_NOTIFY   | Section 13.5   |\n|               |                |\n| REDIRECT      | Section 13.10  |\n|               |                |\n| SETUP         | Section 13.3   |\n|               |                |\n| SET_PARAMETER | Section 13.9   |\n|               |                |\n| TEARDOWN      | Section 13.7   |\n+---------------+----------------+",
      "raw": true
    },
    {
      "indent": 25,
      "text": "Table 2: The RTSP Methods",
      "ja": "表2：RTSPメソッド"
    },
    {
      "indent": 3,
      "text": "The syntax of the RTSP request line has the following:",
      "ja": "RTSP要求ラインの構文は次のようにあります。"
    },
    {
      "indent": 6,
      "text": "<Method> SP <Request-URI> SP <RTSP-Version> CRLF",
      "ja": "<方法> SP <要求URI> SP <RTSP-バージョン> CRLF"
    },
    {
      "indent": 3,
      "text": "Note: This syntax cannot be freely changed in future versions of RTSP. This line needs to remain parsable by older RTSP implementations since it indicates the RTSP version of the message.",
      "ja": "注：この構文は、自由にRTSPの将来のバージョンで変更することはできません。この行は、メッセージのRTSPのバージョンを示しているため、古いRTSP実装によって解析可能なままにする必要があります。"
    },
    {
      "indent": 3,
      "text": "In contrast to HTTP/1.1 [RFC7230], RTSP requests identify the resource through an absolute RTSP URI (including scheme, host, and port) (see Section 4.2) rather than just the absolute path.",
      "ja": "HTTP / 1.1 [RFC7230]とは対照的に、RTSP要求ではなく単に絶対パスよりも（セクション4.2を参照）（スキーム、ホスト、およびポートを含む）絶対RTSP URIを介してリソースを識別する。"
    },
    {
      "indent": 6,
      "text": "HTTP/1.1 requires servers to understand the absolute URI, but clients are supposed to use the Host request-header. This is purely needed for backward compatibility with HTTP/1.0 servers, a consideration that does not apply to RTSP.",
      "ja": "HTTP / 1.1は、絶対URIを理解するためにサーバを必要としますが、クライアントがホストリクエストヘッダを使用することになっています。これは純粋にHTTP / 1.0サーバ、RTSPには適用されません考慮して、下位互換性のために必要とされています。"
    },
    {
      "indent": 3,
      "text": "An asterisk \"*\" can be used instead of an absolute URI in the Request-URI part to indicate that the request does not apply to a particular resource but to the server or proxy itself, and is only allowed when the request method does not necessarily apply to a resource.",
      "ja": "アスタリスク「*」のRequest-URI部分に絶対URIの代わりに使用することができ、要求が特定のリソースではなく、サーバまたはプロキシ自体には適用されないことを示すために、要求メソッドが必ずしもない場合にのみ許可されていますリソースに適用されます。"
    },
    {
      "indent": 3,
      "text": "For example:",
      "ja": "例えば："
    },
    {
      "indent": 6,
      "text": "OPTIONS * RTSP/2.0",
      "ja": "OPTIONS * RTSP / 2.0"
    },
    {
      "indent": 3,
      "text": "An OPTIONS in this form will determine the capabilities of the server or the proxy that first receives the request. If the capability of the specific server needs to be determined, without regard to the capability of an intervening proxy, the server should be addressed explicitly with an absolute URI that contains the server's address.",
      "ja": "この形式のオプションは、サーバ又は第1の要求を受信したプロキシの能力を決定します。特定のサーバの能力は介在プロキシの能力に関係なく、決定する必要がある場合、サーバは、サーバのアドレスが含まれて絶対URIを明示的に対処する必要があります。"
    },
    {
      "indent": 3,
      "text": "For example:",
      "ja": "例えば："
    },
    {
      "indent": 6,
      "text": "OPTIONS rtsp://example.com RTSP/2.0",
      "ja": "OPTIONSのRTSP：//example.com RTSP / 2.0"
    },
    {
      "indent": 0,
      "text": "7.2. Request-Header Fields",
      "section_title": true,
      "ja": "7.2. リクエストヘッダフィールド"
    },
    {
      "indent": 3,
      "text": "The RTSP headers in Table 3 can be included in a request, as request-headers, to modify the specifics of the request.",
      "ja": "表3のRTSPヘッダは、要求の内容を変更するには、リクエストヘッダとして、要求に含めることができます。"
    },
    {
      "indent": 17,
      "text": "+---------------------+----------------+\n| Header              | Defined in     |\n+---------------------+----------------+\n| Accept              | Section 18.1   |\n|                     |                |\n| Accept-Credentials  | Section 18.2   |\n|                     |                |\n| Accept-Encoding     | Section 18.3   |\n|                     |                |\n| Accept-Language     | Section 18.4   |\n|                     |                |\n| Authorization       | Section 18.8   |\n|                     |                |\n| Bandwidth           | Section 18.9   |\n|                     |                |\n| Blocksize           | Section 18.10  |\n|                     |                |\n| From                | Section 18.23  |\n|                     |                |\n| If-Match            | Section 18.24  |\n|                     |                |\n| If-Modified-Since   | Section 18.25  |\n|                     |                |\n| If-None-Match       | Section 18.26  |\n|                     |                |\n| Notify-Reason       | Section 18.32  |\n|                     |                |\n| Proxy-Authorization | Section 18.36  |\n|                     |                |\n| Proxy-Require       | Section 18.37  |\n|                     |                |\n| Referrer            | Section 18.41  |\n|                     |                |\n| Request-Status      | Section 18.42  |\n|                     |                |\n| Require             | Section 18.43  |\n|                     |                |\n| Terminate-Reason    | Section 18.52  |\n+---------------------+----------------+",
      "raw": true
    },
    {
      "indent": 21,
      "text": "Table 3: The RTSP Request-Headers",
      "ja": "表3：RTSP要求 - ヘッダ"
    },
    {
      "indent": 3,
      "text": "Detailed header definitions are provided in Section 18.",
      "ja": "詳細ヘッダの定義はセクション18に設けられています。"
    },
    {
      "indent": 3,
      "text": "New request-headers may be defined. If the receiver of the request is required to understand the request-header, the request MUST include a corresponding feature tag in a Require or Proxy-Require header to ensure the processing of the header.",
      "ja": "新しいリクエストのヘッダーを定義することができます。要求の受信をリクエストヘッダを理解する必要がある場合、要求は、ヘッダの処理を確実にするために必要とするか、またはプロキシ要求ヘッダに対応する特徴タグを含まなければなりません。"
    },
    {
      "indent": 0,
      "text": "8. Response",
      "section_title": true,
      "ja": "8.レスポンス"
    },
    {
      "indent": 3,
      "text": "After receiving and interpreting a request message, the recipient responds with an RTSP response message. Normally, there is only one, final, response. Responses using the response code class 1xx is the only class for which there MAY be sent one or more responses prior to the final response message.",
      "ja": "要求メッセージを受信し、解釈した後、受信者は、RTSP応答メッセージで応答します。通常、一つだけ、最終的に、応答があります。応答コードクラス1XXを使用して応答は、従来最終応答メッセージへの1つ以上の応答が送信されても​​よいための唯一のクラスです。"
    },
    {
      "indent": 3,
      "text": "The valid response codes and the methods they can be used with are listed in Table 4.",
      "ja": "有効な応答コードとそれらが一緒に使用することができる方法は、表4に列挙されています。"
    },
    {
      "indent": 0,
      "text": "8.1. Status-Line",
      "section_title": true,
      "ja": "8.1. ステータスライン"
    },
    {
      "indent": 3,
      "text": "The first line of a response message is the Status-Line, consisting of the protocol version followed by a numeric status code and the textual phrase associated with the status code, with each element separated by SP characters. No CR or LF is allowed except in the final CRLF sequence.",
      "ja": "応答メッセージの最初の行は、数値ステータスコードとSPの文字で区切られた各要素と、状態コードに関連付けられたテキストフレーズに続くプロトコルバージョンからなる、ステータスラインです。 CRまたはLF NOが最終のCRLFシーケンス以外で許可されていません。"
    },
    {
      "indent": 3,
      "text": "<RTSP-Version> SP <Status-Code> SP <Reason Phrase> CRLF",
      "ja": "<RTSP-バージョン> SP <ステータスコード> SP <理由フレーズ> CRLF"
    },
    {
      "indent": 0,
      "text": "8.1.1. Status Code and Reason Phrase",
      "section_title": true,
      "ja": "8.1.1. ステータスコードと理由フレーズ"
    },
    {
      "indent": 3,
      "text": "The Status-Code element is a 3-digit integer result code of the attempt to understand and satisfy the request. These codes are fully defined in Section 17. The reason phrase is intended to give a short textual description of the Status-Code. The Status-Code is intended for use by automata and the reason phrase is intended for the human user. The client is not required to examine or display the reason phrase.",
      "ja": "ステータスコードエレメントは、理解し、要求を満足させる試みの3桁の整数の結果コードです。これらのコードが完全にセクション17で定義されている理由の句は、ステータスコードの短いテキスト記述を与えることを目的としています。ステータスコードは、オートマトンによる使用を目的としており、その理由フレーズは、人間のユーザを対象としています。クライアントが理由フレーズを調べたり表示するために必要とされていません。"
    },
    {
      "indent": 3,
      "text": "The first digit of the Status-Code defines the class of response. The last two digits do not have any categorization role. There are five values for the first digit:",
      "ja": "ステータスコードの最初の数字は応答のクラスを定義します。最後の2桁は任意の分類の役割を持っていません。最初の桁のための5つの値があります。"
    },
    {
      "indent": 3,
      "text": "1xx: Informational - Request received, continuing process",
      "ja": "1xx：情報 - リクエスト受け、継続的なプロセス"
    },
    {
      "indent": 3,
      "text": "2xx: Success - The action was successfully received, understood, and accepted",
      "ja": "2XX：成功 - アクションが成功し、受信理解し、受け入れられました"
    },
    {
      "indent": 3,
      "text": "3rr: Redirection - Further action needs to be taken in order to complete the request (3rr rather than 3xx is used as 304 is excluded; see Section 17.3)",
      "ja": "3RR：リダイレクション - さらなるアクションは（除外さ3XX 304として使用されるのではなく3RRと、セクション17.3を参照）要求を完了するために取られる必要があります"
    },
    {
      "indent": 3,
      "text": "4xx: Client Error - The request contains bad syntax or cannot be fulfilled",
      "ja": "4XX：クライアントエラー - 要求が不正な構文を含む、または満たすことができません"
    },
    {
      "indent": 3,
      "text": "5xx: Server Error - The server failed to fulfill an apparently valid request",
      "ja": "5xxの：サーバーエラー - サーバーが明らかに有効な要求を満たすことができませんでした"
    },
    {
      "indent": 3,
      "text": "The individual values of the numeric status codes defined for RTSP 2.0, and an example set of corresponding reason phrases, are presented in Table 4. The reason phrases listed here are only recommended; they may be replaced by local equivalents without affecting the protocol. Note that RTSP adopted most HTTP/1.1 [RFC2068] status codes and then added RTSP-specific status codes starting at x50 to avoid conflicts with future HTTP status codes that are desirable to import into RTSP. All these codes are RTSP specific and RTSP has its own registry separate from HTTP for status codes.",
      "ja": "RTSP 2.0で定義された数値ステータスコードの個々の値、および対応する理由フレーズのセットの例は、ここに記載されている理由フレーズのみ推奨され、表4に示されています。彼らは、プロトコルに影響を与えることなく、地元の同等物に置き換えることができます。 RTSPは、ほとんどHTTP / 1.1 [RFC2068]ステータスコードを採用した後、RTSPにインポートすることが望ましい将来のHTTPステータスコードとの競合を避けるために、X50で始まるRTSP固有のステータスコードを追加することに注意してください。すべてのこれらのコードは、RTSPは固有のものであり、RTSPはステータスコードについてHTTPとは別に、独自のレジストリを持っています。"
    },
    {
      "indent": 3,
      "text": "RTSP status codes are extensible. RTSP applications are not required to understand the meaning of all registered status codes, though such understanding is obviously desirable. However, applications MUST understand the class of any status code, as indicated by the first digit, and treat any unrecognized response as being equivalent to the x00 status code of that class, with an exception for unknown 3xx codes, which MUST be treated as a 302 (Found). The reason for that exception is that the status code 300 (Multiple Choices in HTTP) is not defined for RTSP. A response with an unrecognized status code MUST NOT be cached. For example, if an unrecognized status code of 431 is received by the client, it can safely assume that there was something wrong with its request and treat the response as if it had received a 400 status code. In such cases, user agents SHOULD present to the user the message body returned with the response, since that message body is likely to include human-readable information that will explain the unusual status.",
      "ja": "RTSPステータスコードは、拡張可能です。そのような理解は明らかに望ましいですが、RTSPアプリケーションは、登録されているすべてのステータスコードの意味を理解する必要はありません。しかし、最初の桁によって示されるように、アプリケーションは、任意のステータスコードのクラスを理解しなければならない、とのように扱わなければならない未知の3XXコード、例外で、そのクラスのX00ステータスコードと同等であると認識されない応答を治療します302（実測値）。その例外の理由は、ステータスコード300（HTTPにおける複数の選択肢）はRTSP用に定義されていないことです。認識されていないステータスコードで応答がキャッシュされてはなりません。例えば、431の認識されていないステータスコードがクライアントによって受信された場合、それは安全にその要求に何か問題があったと仮定することができますし、それが400のステータスコードを受け取ったかのように応答を扱います。そのメッセージ本体が異常な状態を説明する人間可読情報を含む可能性があるので、このような場合、ユーザエージェントは、メッセージ本体が応答で返さユーザに提示しなければなりません。"
    },
    {
      "indent": 3,
      "text": "+------+---------------------------------+--------------------------+\n| Code | Reason                          | Method                   |\n+------+---------------------------------+--------------------------+\n| 100  | Continue                        | all                      |\n|      |                                 |                          |\n| 200  | OK                              | all                      |\n|      |                                 |                          |\n| 301  | Moved Permanently               | all                      |\n|      |                                 |                          |\n| 302  | Found                           | all                      |\n|      |                                 |                          |\n| 303  | See Other                       | n/a                      |\n|      |                                 |                          |\n| 304  | Not Modified                    | all                      |\n|      |                                 |                          |",
      "raw": true
    },
    {
      "indent": 3,
      "text": "| 305 | Use Proxy | all | | | | | | 400 | Bad Request | all | | | | | | 401 | Unauthorized | all | | | | | | 402 | Payment Required | all | | | | | | 403 | Forbidden | all | | | | | | 404 | Not Found | all | | | | | | 405 | Method Not Allowed | all | | | | | | 406 | Not Acceptable | all | | | | | | 407 | Proxy Authentication Required | all | | | | | | 408 | Request Timeout | all | | | | | | 410 | Gone | all | | | | | | 412 | Precondition Failed | DESCRIBE, SETUP | | | | | | 413 | Request Message Body Too Large | all | | | | | | 414 | Request-URI Too Long | all | | | | | | 415 | Unsupported Media Type | all | | | | | | 451 | Parameter Not Understood | SET_PARAMETER, | | | | GET_PARAMETER | | | | | | 452 | reserved | n/a | | | | | | 453 | Not Enough Bandwidth | SETUP | | | | | | 454 | Session Not Found | all | | | | | | 455 | Method Not Valid in This State | all | | | | | | 456 | Header Field Not Valid for | all | | | Resource | | | | | | | 457 | Invalid Range | PLAY, PAUSE | | | | | | 458 | Parameter Is Read-Only | SET_PARAMETER | | | | |",
      "ja": "| 305 |プロキシを使用します|すべて| | | | | | 400 |不正なリクエスト|すべて| | | | | | 401 |無断|すべて| | | | | | 402 |支払いが必要|すべて| | | | | | 403 |禁断|すべて| | | | | | 404 |見つかりません|すべて| | | | | | 405 |メソッド許可されません|すべて| | | | | | 406 |許容できません|すべて| | | | | | 407 |プロキシ認証が必要|すべて| | | | | | 408 |要求タイムアウト|すべて| | | | | | 410 |ゴーン|すべて| | | | | | 412 |前提条件の失敗| DESCRIBE、SETUP | | | | | | 413 |メッセージ本文が大きすぎる依頼|すべて| | | | | | 414 |要求URIが長すぎます|すべて| | | | | | 415 |サポートされていないメディアタイプ|すべて| | | | | | 451 |パラメータ分かりません| SET_PARAMETER、| | | | GET_PARAMETER | | | | | | 452 |予約| N / A | | | | | | 453 |ない十分な帯域幅| SETUP | | | | | | 454 |セッションが見つかりません|すべて| | | | | | 455 |この状態では有効ではありませんメソッド|すべて| | | | | | 456 |ヘッダーフィールドには有効ではありません|すべて| | |リソース| | | | | | | 457 |無効な範囲| PLAY、PAUSE | | | | | | 458 |パラメータは、読み取り専用であります| SET_PARAMETER | | | | |"
    },
    {
      "indent": 3,
      "text": "| 459  | Aggregate Operation Not Allowed | all                      |\n|      |                                 |                          |\n| 460  | Only Aggregate Operation        | all                      |\n|      | Allowed                         |                          |\n|      |                                 |                          |\n| 461  | Unsupported Transport           | all                      |\n|      |                                 |                          |\n| 462  | Destination Unreachable         | all                      |\n|      |                                 |                          |\n| 463  | Destination Prohibited          | SETUP                    |\n|      |                                 |                          |\n| 464  | Data Transport Not Ready Yet    | PLAY                     |\n|      |                                 |                          |\n| 465  | Notification Reason Unknown     | PLAY_NOTIFY              |\n|      |                                 |                          |\n| 466  | Key Management Error            | all                      |\n|      |                                 |                          |\n| 470  | Connection Authorization        | all                      |\n|      | Required                        |                          |\n|      |                                 |                          |\n| 471  | Connection Credentials Not      | all                      |\n|      | Accepted                        |                          |\n|      |                                 |                          |\n| 472  | Failure to Establish Secure     | all                      |\n|      | Connection                      |                          |\n|      |                                 |                          |\n| 500  | Internal Server Error           | all                      |\n|      |                                 |                          |\n| 501  | Not Implemented                 | all                      |\n|      |                                 |                          |\n| 502  | Bad Gateway                     | all                      |\n|      |                                 |                          |\n| 503  | Service Unavailable             | all                      |\n|      |                                 |                          |\n| 504  | Gateway Timeout                 | all                      |\n|      |                                 |                          |\n| 505  | RTSP Version Not Supported      | all                      |\n|      |                                 |                          |\n| 551  | Option Not Supported            | all                      |\n|      |                                 |                          |\n| 553  | Proxy Unavailable               | all                      |\n+------+---------------------------------+--------------------------+",
      "raw": true
    },
    {
      "indent": 10,
      "text": "Table 4: Status Codes and Their Usage with RTSP Methods",
      "ja": "表4：ステータスコードとRTSP方法とその使用方法"
    },
    {
      "indent": 0,
      "text": "8.2. Response Headers",
      "section_title": true,
      "ja": "8.2. レスポンスヘッダ"
    },
    {
      "indent": 3,
      "text": "The response-headers allow the request recipient to pass additional information about the response that cannot be placed in the Status-Line. This header gives information about the server and about further access to the resource identified by the Request-URI. All headers currently classified as response-headers are listed in Table 5.",
      "ja": "レスポンスヘッダは、リクエスト受信者がステータスラインに配置することはできません応答に関する追加情報を渡すことができます。このヘッダは、サーバに関するとRequest-URIによって識別されたリソースへのさらなるアクセスについての情報を与えます。現在、レスポンス・ヘッダーとして分類されたすべてのヘッダーを、表5に列挙されています。"
    },
    {
      "indent": 16,
      "text": "+------------------------+----------------+\n| Header                 | Defined in     |\n+------------------------+----------------+\n| Authentication-Info    | Section 18.7   |\n|                        |                |\n| Connection-Credentials | Section 18.13  |\n|                        |                |\n| Location               | Section 18.28  |\n|                        |                |\n| MTag                   | Section 18.31  |\n|                        |                |\n| Proxy-Authenticate     | Section 18.34  |\n|                        |                |\n| Public                 | Section 18.39  |\n|                        |                |\n| Retry-After            | Section 18.44  |\n|                        |                |\n| Unsupported            | Section 18.55  |\n|                        |                |\n| WWW-Authenticate       | Section 18.58  |\n+------------------------+----------------+",
      "raw": true
    },
    {
      "indent": 20,
      "text": "Table 5: The RTSP Response Headers",
      "ja": "表5：RTSPレスポンスヘッダー"
    },
    {
      "indent": 3,
      "text": "Response-header names can be extended reliably only in combination with a change in the protocol version. However, the usage of feature tags in the request allows the responding party to learn the capability of the receiver of the response. A new or experimental header can be given the semantics of response-header if all parties in the communication recognize them to be a response-header. Unrecognized headers in responses MUST be ignored.",
      "ja": "レスポンスヘッダ名はプロトコルバージョンにおける変化との組み合わせでのみ確実に拡張することができます。しかし、要求における特徴タグの使用は、応答当事者が応答の受信機の機能を学ぶことができます。通信のすべての当事者がレスポンスヘッダであることをそれらを認識した場合、新規または実験ヘッダはレスポンスヘッダの意味を与えることができます。応答の認識できないヘッダは無視しなければなりません。"
    },
    {
      "indent": 0,
      "text": "9. Message Body",
      "section_title": true,
      "ja": "9.メッセージ本文"
    },
    {
      "indent": 3,
      "text": "Some request and response messages include a message body, if not otherwise restricted by the request method or response status code. The message body consists of the content data itself (see also Section 5.3).",
      "ja": "そうでない場合は、要求メソッドやレスポンスのステータスコードによって制限されていない場合、一部の要求メッセージと応答メッセージには、メッセージ本体を含みます。メッセージ本体は、コンテンツデータ自体から成る（セクション5.3を参照）。"
    },
    {
      "indent": 3,
      "text": "The SET_PARAMETER and GET_PARAMETER requests and responses, and the DESCRIBE response as defined by this specification, can have a message body; the purpose of the message body is defined in each case. All 4xx and 5xx responses MAY also have a message body to carry additional response information. Generally, a message body MAY be attached to any RTSP 2.0 request or response, but the content of the message body MAY be ignored by the receiver. Extensions to this specification can specify the purpose and content of message bodies, including requiring their inclusion.",
      "ja": "SET_PARAMETERとGET_PARAMETER要求と応答、および本明細書で定義されるようDESCRIBE応答は、メッセージ本体を有することができます。メッセージ本文の目的は、それぞれの場合に定義されています。すべての4xxと5xxの応答はまた、追加の応答情報を運ぶためにメッセージ本体を持っているかもしれません。一般に、メッセージ本体は、任意のRTSP 2.0要求または応答に取り付けられてもよいが、メッセージ本文の内容は、受信機によって無視されてもよいです。この仕様への拡張は、それらの包含を必要とするなど、メッセージ本文の目的と内容を指定することができます。"
    },
    {
      "indent": 3,
      "text": "In this section, both sender and recipient refer to either the client or the server, depending on who sends and who receives the message body.",
      "ja": "このセクションでは、送信者と受信者の両方を送信し、誰がメッセージ本文を受信者に応じて、クライアントまたはサーバのいずれかを参照してください。"
    },
    {
      "indent": 0,
      "text": "9.1. Message Body Header Fields",
      "section_title": true,
      "ja": "9.1. メッセージ本文ヘッダフィールド"
    },
    {
      "indent": 3,
      "text": "Message body header fields define meta-information about the content data in the message body. The message body header fields are listed in Table 6.",
      "ja": "メッセージボディヘッダフィールドは、メッセージボディ内のコンテンツデータに関するメタ情報を定義します。メッセージボディヘッダフィールドを、表6に列挙されています。"
    },
    {
      "indent": 19,
      "text": "+------------------+----------------+\n| Header           | Defined in     |\n+------------------+----------------+\n| Allow            | Section 18.6   |\n|                  |                |\n| Content-Base     | Section 18.14  |\n|                  |                |\n| Content-Encoding | Section 18.15  |\n|                  |                |\n| Content-Language | Section 18.16  |\n|                  |                |\n| Content-Length   | Section 18.17  |\n|                  |                |\n| Content-Location | Section 18.18  |\n|                  |                |\n| Content-Type     | Section 18.19  |\n|                  |                |\n| Expires          | Section 18.22  |\n|                  |                |\n| Last-Modified    | Section 18.27  |\n+------------------+----------------+",
      "raw": true
    },
    {
      "indent": 18,
      "text": "Table 6: The RTSP Message Body Headers",
      "ja": "表6：RTSPメッセージ本文ヘッダー"
    },
    {
      "indent": 3,
      "text": "The extension-header mechanism allows additional message body header fields to be defined without changing the protocol, but these fields cannot be assumed to be recognizable by the recipient. Unrecognized header fields MUST be ignored by the recipient and forwarded by proxies.",
      "ja": "拡張ヘッダメカニズムは、プロトコルを変更せずに定義する追加のメッセージボディヘッダフィールドを可能にするが、これらのフィールドは、受信者によって認識可能であると仮定することはできません。認識されていないヘッダフィールドは、受信者によって無視され、プロキシによって転送されなければなりません。"
    },
    {
      "indent": 0,
      "text": "9.2. Message Body",
      "section_title": true,
      "ja": "9.2. メッセージ本文"
    },
    {
      "indent": 3,
      "text": "An RTSP message with a message body MUST include the Content-Type and Content-Length headers. When a message body is included with a message, the data type of that content data is determined via the Content-Type and Content-Encoding header fields.",
      "ja": "メッセージ本文とRTSPメッセージは、Content-TypeとContent-Lengthヘッダを含まなければなりません。メッセージ本体がメッセージに含まれている場合、そのコンテンツデータのデータ・タイプは、Content-TypeとContent-Encodingヘッダフィールドを介して決定されます。"
    },
    {
      "indent": 3,
      "text": "Content-Type specifies the media type of the underlying data. There is no default media format and the actual format used in the body is required to be explicitly stated in the Content-Type header. By being explicit and always requiring the inclusion of the Content-Type header with accurate information, one avoids the many pitfalls in a heuristic-based interpretation of the body content. The user experience of HTTP and email have suffered from relying on such heuristics.",
      "ja": "コンテンツタイプは、基礎となるデータのメディアタイプを指定します。体内で使用されるデフォルトのメディア形式と実際の形式はありませんが、明示的にContent-Typeヘッダに記述する必要があります。明示されており、常に正確な情報をContent-Typeヘッダを含めることを要求することによって、人は身体コンテンツのヒューリスティックベースの解釈に多くの落とし穴を回避します。 HTTPおよび電子メールのユーザーエクスペリエンスは、このような経験則に頼って苦しんでいます。"
    },
    {
      "indent": 3,
      "text": "Content-Encoding may be used to indicate any additional content-codings applied to the data, usually for the purpose of data compression, that are a property of the requested resource. The default encoding is 'identity', i.e. no transformation of the message body.",
      "ja": "コンテンツのエンコーディングは要求されたリソースの所有物であり、通常はデータ圧縮の目的のために、データに適用される任意の追加の内容コーディングを示すために使用されてもよいです。デフォルトのエンコーディングは「アイデンティティ」と、メッセージボディの、すなわち無変換です。"
    },
    {
      "indent": 3,
      "text": "The Content-Length of a message is the length of the content, measured in octets.",
      "ja": "メッセージのコンテンツ長をオクテット単位で測定されたコンテンツの長さ、です。"
    },
    {
      "indent": 0,
      "text": "9.3. Message Body Format Negotiation",
      "section_title": true,
      "ja": "9.3. メッセージ本文のフォーマットネゴシエーション"
    },
    {
      "indent": 3,
      "text": "The content format of the message body is provided using the Content-Type header (Section 18.19). To enable the responder of a request to determine which media type it should use, the requester may include the Accept header (Section 18.1) in a request to identify supported media types or media type ranges suitable to the response. In case the responder is not supporting any of the specified formats, then the request response will be a 406 (Not Acceptable) error code.",
      "ja": "メッセージ本文のコンテンツフォーマットは、Content-Typeヘッダ（セクション18.19）を使用して提供されます。それが使用すべきメディアタイプを決定する要求の応答を可能にするために、要求者は、サポートされるメディアタイプを識別するための要求またはメディアタイプに受け入れヘッダ（セクション18.1）を含むことができる応答に適した範囲です。応答者が指定した形式のいずれかをサポートしていない場合には、その後、要求応答406（許容できない）エラーコードであろう。"
    },
    {
      "indent": 3,
      "text": "The media types that may be used on requests with message bodies need to be determined through the use of feature tags, specification requirement, or trial and error. Trial and error works because when the responder does not support the media type of the message body, it will respond with a 415 (Unsupported Media Type).",
      "ja": "メッセージ本文との要求に使用できるメディアの種類は、フィーチャータグ、仕様の要求、または試行錯誤を使用して決定する必要があります。レスポンダがメッセージボディのメディアタイプをサポートしていないとき、それは415（サポートされていないメディアタイプ）に対応させていただきますので、試行錯誤で動作します。"
    },
    {
      "indent": 3,
      "text": "The formats supported and their negotiation is done individually on a per method and direction (request or response body) direction. Requirements on supporting particular media types for use as message bodies in requests and response SHALL also be specified on a per-method and per-direction basis.",
      "ja": "フォーマットがサポートされ、それらの交渉方法および方向（要求または応答本体）当たり方向に個別に行われます。要求および応答のメッセージ体として使用するための特定のメディアタイプをサポートする上での要件は、メソッドごとおよび方向に基づいて規定されなければなりません。"
    },
    {
      "indent": 0,
      "text": "10. Connections",
      "section_title": true,
      "ja": "10.接続"
    },
    {
      "indent": 3,
      "text": "RTSP messages are transferred between RTSP agents and proxies using a transport connection. This transport connection uses TCP or TCP/TLS. This transport connection is referred to as the \"connection\" or \"RTSP connection\" within this document.",
      "ja": "RTSPメッセージは、トランスポート接続を使用してRTSPエージェントとプロキシ間で転送されます。このトランスポート接続は、TCPまたはTCP / TLSを使用しています。このトランスポート接続は、このドキュメント内の「接続」または「RTSP接続」と呼ばれています。"
    },
    {
      "indent": 3,
      "text": "RTSP requests can be transmitted using the two different connection scenarios listed below:",
      "ja": "RTSP要求は、下記の二つの異なる接続シナリオを使用して送信することができます。"
    },
    {
      "indent": 3,
      "text": "o persistent - a transport connection is used for several request/ response transactions;",
      "ja": "O永続 - トランスポート接続は、複数の要求/応答トランザクションのために使用されます。"
    },
    {
      "indent": 3,
      "text": "o transient - a transport connection is used for each single request/response transaction.",
      "ja": "O過渡 - トランスポート接続は、それぞれ単一の要求/応答トランザクションのために使用されています。"
    },
    {
      "indent": 3,
      "text": "RFC 2326 attempted to specify an optional mechanism for transmitting RTSP messages in connectionless mode over a transport protocol such as UDP. However, it was not specified in sufficient detail to allow for interoperable implementations. In an attempt to reduce complexity and scope, and due to lack of interest, RTSP 2.0 does not attempt to define a mechanism for supporting RTSP over UDP or other connectionless transport protocols. A side effect of this is that RTSP requests MUST NOT be sent to multicast groups since no connection can be established with a specific receiver in multicast environments.",
      "ja": "RFC 2326は、UDPなどのトランスポートプロトコルを介してコネクションレスモードでRTSPメッセージを送信するための任意のメカニズムを指定することを試みました。しかし、それは、相互運用可能な実装を可能にするために十分な詳細に指定されていませんでした。関心の欠如に複雑さと範囲、および原因を軽減する試みでは、RTSP 2.0は、UDPまたは他のコネクションレスのトランスポートプロトコル上でRTSPをサポートするためのメカニズムを定義しようとしません。この副作用は全く接続は、マルチキャスト環境において特定の受信機との間で確立することができないので、RTSP要求がマルチキャストグループに送信してはならないことです。"
    },
    {
      "indent": 3,
      "text": "Certain RTSP headers, such as the CSeq header (Section 18.20), which may appear to be relevant only to connectionless transport scenarios, are still retained and MUST be implemented according to this specification. In the case of CSeq, it is quite useful for matching responses to requests if the requests are pipelined (see Section 12). It is also useful in proxies for keeping track of the different requests when aggregating several client requests on a single TCP connection.",
      "ja": "そのようなだけコネクション輸送シナリオに関連するように見えることができるのCSeqヘッダ（セクション18.20）、などの特定のRTSPヘッダは、依然として保持され、この仕様に従って実装されなければなりません。 CSeqの場合、それは（セクション12を参照）要求がパイプライン化されている場合は要求に対する応答を合わせるために非常に便利です。これは、単一のTCP接続上で複数のクライアント要求を集約する際に異なる要求を追跡するためのプロキシにも便利です。"
    },
    {
      "indent": 0,
      "text": "10.1. Reliability and Acknowledgements",
      "section_title": true,
      "ja": "10.1. 信頼性と謝辞"
    },
    {
      "indent": 3,
      "text": "Since RTSP messages are transmitted using reliable transport protocols, they MUST NOT be retransmitted at the RTSP level. Instead, the implementation must rely on the underlying transport to provide reliability. The RTSP implementation may use any indication of reception acknowledgment of the message from the underlying transport protocols to optimize the RTSP behavior.",
      "ja": "RTSPメッセージが信頼できるトランスポートプロトコルを使用して送信されるので、RTSPレベルで再送信してはなりません。その代わり、実装信頼性を提供するために、基礎となるトランスポートに依存しなければなりません。 RTSP実装は、RTSPの動作を最適化するために、基礎となるトランスポートプロトコルからのメッセージの受信確認の指示を使用することができます。"
    },
    {
      "indent": 6,
      "text": "If both the underlying reliable transport, such as TCP, and the RTSP application retransmit requests, each packet loss or message loss may result in two retransmissions. The receiver typically cannot take advantage of the application-layer retransmission since the transport stack will not deliver the application-layer retransmission before the first attempt has reached the receiver. If the packet loss is caused by congestion, multiple retransmissions at different layers will exacerbate the congestion.",
      "ja": "TCPのような基本的な信頼性の高いトランスポート、およびRTSPアプリケーションの再送信要求の両方場合は、各パケット損失またはメッセージの損失は2つの再送信になることがあります。最初の試みがレシーバに達する前にトランスポートスタックは、アプリケーション層の再送を配信しませんので、受信機は、通常、アプリケーション層の再送信を利用することはできません。パケット損失が混雑によって引き起こされている場合、異なる層に複数の再送は、輻輳を悪化させるだろう。"
    },
    {
      "indent": 3,
      "text": "Lack of acknowledgment of an RTSP request should be handled within the constraints of the connection timeout considerations described below (Section 10.4).",
      "ja": "RTSP要求の肯定応答の欠如は、後述する接続タイムアウトの考慮事項（セクション10.4）の制約内で処理されるべきです。"
    },
    {
      "indent": 0,
      "text": "10.2. Using Connections",
      "section_title": true,
      "ja": "10.2. 接続を使用"
    },
    {
      "indent": 3,
      "text": "A TCP transport can be used for both persistent connections (for several message exchanges) and transient connections (for a single message exchange). Implementations of this specification MUST support RTSP over TCP. The scheme of the RTSP URI (Section 4.2) allows the client to specify the port it will contact the server on, and defines the default port to use if one is not explicitly given.",
      "ja": "TCPトランスポートは、（いくつかのメッセージ交換のための）永続的な接続と、（単一のメッセージ交換のための）一時的な接続の両方のために使用することができます。この仕様の実装は、TCP上のRTSPをサポートしなければなりません。 RTSP URI（セクション4.2）の方式では、クライアントが、それは上のサーバに接続するポートを指定することができ、かつ1が明示的に指定されていない場合に使用するデフォルトのポートを定義します。"
    },
    {
      "indent": 3,
      "text": "In addition to the registered default ports, i.e., 554 (rtsp) and 322 (rtsps), there is an alternative port 8554 registered. This port may provide some benefits over non-registered ports if an RTSP server is unable to use the default ports. The benefits may include preconfigured security policies as well as classifiers in network monitoring tools.",
      "ja": "登録されたデフォルトのポート、即ち、554（RTSP）および322（RTSPS）に加えて、登録された別のポート8554があります。 RTSPサーバはデフォルトのポートを使用することができない場合は、このポートは非​​登録ポート経由のいくつかの利点を提供することができます。メリットは、ネットワーク監視ツールで事前にセキュリティポリシーなどの分類を含むことができます。"
    },
    {
      "indent": 3,
      "text": "An RTSP client opening a TCP connection to access a particular resource as identified by a URI uses the IP address and port derived from the host and port parts of the URI. The IP address is either the explicit address provided in the URI or any of the addresses provided when performing A and AAAA record DNS lookups of the hostname in the URI.",
      "ja": "URIによって識別される特定のリソースにアクセスするためにTCP接続を開くRTSPクライアントは、URIのホストとポート部分から派生したIPアドレスとポートを使用しています。 IPアドレスは、URIでホスト名のAとAAAAレコードDNSルックアップを実行するときに提供URIまたはアドレスのいずれかで提供明示的なアドレスのいずれかです。"
    },
    {
      "indent": 3,
      "text": "A server MUST handle both persistent and transient connections.",
      "ja": "サーバーは、永続的かつ一過性の両方の接続を処理しなければなりません。"
    },
    {
      "indent": 6,
      "text": "Transient connections facilitate mechanisms for fault tolerance. They also allow for application-layer mobility. A server-and-client pair that supports transient connections can survive the loss of a TCP connection; e.g., due to a NAT timeout. When the client has discovered that the TCP connection has been lost, it can set up a new one when there is need to communicate again.",
      "ja": "一時的な接続は、フォールトトレランスのためのメカニズムを促進します。彼らはまた、アプリケーション層の移動を可能とします。一時的な接続をサポートし、サーバとクライアントのペアは、TCP接続の損失を乗り切ることができます。例えば、NATタイムアウトによるもの。クライアントは、TCP接続が失われたことを発見した場合は、再び通信する必要があるとき、それは新しいものを設定することができます。"
    },
    {
      "indent": 3,
      "text": "A persistent connection is RECOMMENDED to be used for all transactions between the server and client, including messages for multiple RTSP sessions. However, a persistent connection MAY be closed after a few message exchanges. For example, a client may use a persistent connection for the initial SETUP and PLAY message exchanges in a session and then close the connection. Later, when the client wishes to send a new request, such as a PAUSE for the session, a new connection would be opened. This connection may be either transient or persistent.",
      "ja": "持続的接続は、複数のRTSPセッションのメッセージなど、サーバとクライアントの間のすべての取引のために使用されることをお勧めします。しかし、持続的な接続は、いくつかのメッセージ交換の後に閉鎖することができます。例えば、クライアントは、セッションの最初のセットアップとPLAYメッセージ交換のための永続的な接続を使用し、接続を閉じてもよいです。クライアントは新しいリクエストを送信したい場合、後で、このようなセッションの一時停止と、新しい接続が開かれます。この接続は、一時的または永続的のいずれであってもよいです。"
    },
    {
      "indent": 3,
      "text": "An RTSP agent MAY use one connection to handle multiple RTSP sessions on the same server. The RTSP agent SHALL NOT use more than one connection per RTSP session at any given point.",
      "ja": "RTSPエージェントは、同一サーバ上で複数のRTSPセッションを処理するために一つの接続を使用するかもしれません。 RTSPエージェントは、任意の時点でRTSPセッションごとに複数の接続を使用してはなりません。"
    },
    {
      "indent": 6,
      "text": "Having only one connection in use at any time avoids confusion regarding on which connection any server-to-client requests shall be sent. Using a single connection for multiple RTSP sessions also saves complexity by enabling the server to maintain less state about its connection resources on the server. Not using more than one connection at a time for a particular RTSP session avoids wasting connection resources and allows the server to track only the most recently used client-to-server connection for each RTSP session as being the currently valid server-to-client connection.",
      "ja": "いつでも使用されている唯一つの接続を持つことは、任意のサーバーからクライアントへの要求が送信されなければならないその接続上に関する混乱を避けることができます。複数のRTSPセッションの単一の接続を使用すると、サーバー上の接続リソースに関する以下の状態を維持するために、サーバーを有効にすることで、複雑さを節約します。特定のRTSPセッションのために、一度に複数の接続を使用しないと、接続リソースを無駄に回避し、サーバが現在有効なサーバーからクライアントへの接続であるとして、各RTSPセッションのための唯一の最も最近使用クライアントからサーバーへの接続を追跡することができます。"
    },
    {
      "indent": 3,
      "text": "RTSP allows a server to send requests to a client. However, this can be supported only if a client establishes a persistent connection with the server. In cases where a persistent connection does not exist between a server and its client, due to the lack of a signaling channel, the server may be forced to silently discard RTSP messages, and it may even drop an RTSP session without notifying the client. An example of such a case is when the server desires to send a REDIRECT request for an RTSP session to the client but is not able to do so because it cannot reach the client. A server that attempts to send a request to a client that has no connection currently to the server SHALL discard the request.",
      "ja": "RTSPは、サーバがクライアントにリクエストを送信することができます。しかし、これは、クライアントがサーバーとの永続的な接続を確立している場合にのみサポートされます。持続的な接続が原因シグナリングチャネルの不足のため、サーバーとそのクライアントの間に存在しない場合には、サーバは黙ってRTSPメッセージを破棄するように強制することができる、と言っても、クライアントに通知することなくRTSPセッションをドロップすることがあります。サーバーがクライアントにRTSPセッションのリダイレクト要求を送信することを望むが、それはクライアントに到達することはできませんので、そうすることができないときに、このような場合の例です。現在の要求を廃棄するサーバーに接続されていないクライアントに要求を送信しようとサーバー。"
    },
    {
      "indent": 6,
      "text": "Without a persistent connection between the client and the server, the media server has no reliable way of reaching the client. Because of the likely failure of server-to-client established connections, the server will not even attempt establishing any connection.",
      "ja": "クライアントとサーバ間の持続的な接続せずに、メディアサーバは、クライアントに到達する信頼できる方法がありません。そのため、サーバからクライアントへの確立された接続の可能性障害の、サーバーでも任意の接続を確立しようとしません。"
    },
    {
      "indent": 6,
      "text": "Queuing of server-to-client requests has been considered. However, a security issue exists as to how it might be possible to authorize a client establishing a new connection as being a legitimate receiver of a request related to a particular RTSP session, without the client first issuing requests related to the pending request. Thus, it would be likely to make any such requests even more delayed and less useful.",
      "ja": "サーバーからクライアントへの要求のキューイングが考慮されています。しかし、セキュリティ上の問題が、クライアントが最初の保留中の要求に関連する要求を発行することなく、特定のRTSPセッションに関連する要求の正当な受信機であるとして、新たな接続を確立するクライアントを許可することは可能かもしれませんどのようにとして存在します。したがって、どのような要求が一層遅延の少ない有用なものにする可能性が高いだろう。"
    },
    {
      "indent": 3,
      "text": "The sending of client and server requests can be asynchronous events. To avoid deadlock situations, both client and server MUST be able to send and receive requests simultaneously. As an RTSP response may be queued up for transmission, reception or processing behind the peer RTSP agent's own requests, all RTSP agents are required to have a certain capability of handling outstanding messages. A potential issue is that outstanding requests may time out despite being processed by the peer; this can be due to the response being caught in the queue behind a number of requests that the RTSP agent is processing but that take some time to complete. To avoid this problem, an RTSP agent should buffer incoming messages locally so that any response messages can be processed immediately upon reception. If responses are separated from requests and directly forwarded for processing, not only can the result be used immediately, the state associated with that outstanding request can also be released. However, buffering a number of requests on the receiving RTSP agent consumes resources and enables a resource exhaustion attack on the agent. Therefore, this buffer should be limited so that an unreasonable number of requests or total message size is not allowed to consume the receiving agent's resources. In most APIs, having the receiving agent stop reading from the TCP socket will result in TCP's window being clamped, thus forcing the buffering onto the sending agent when the load is larger than expected. However, as both RTSP message sizes and frequency may be changed in the future by protocol extensions, an agent should be careful about taking harsher measurements against a potential attack. When under attack, an RTSP agent can close TCP connections and release state associated with that TCP connection.",
      "ja": "クライアントとサーバのリクエストの送信を非同期イベントすることができます。デッドロック状況を回避するには、クライアントとサーバの両方が同時に要求を送信し、受け取ることができなければなりません。 RTSP応答がピアRTSPエージェント自身の要求の背後に送信、受信または処理のためにキューに入れられるように、すべてのRTSPエージェントが未処理メッセージを処理する特定の能力が要求されています。潜在的な問題は、未処理の要求が、ピアによって処理されているにもかかわらずタイムアウトするかもしれないということです。これは、RTSPエージェントが処理しているが、それが完了するまでに多少時間がかかる要求数の背後にあるキューに巻き込まれる応答にすることができます。任意の応答メッセージを受信するとすぐに処理できるようにこの問題を回避するには、RTSPエージェントはローカルに、着信メッセージをバッファリングする必要があります。応答は要求から分離し、直接処理のために転送された場合、結果はすぐに使用することができ、その未処理の要求に関連付けられている状態も解除することができないだけ。しかし、受信RTSPエージェントに要求の数をバッファリングすると、リソースを消費し、エージェントのリソース枯渇攻撃を可能にします。要求またはメッセージの合計サイズの無理数は、受信エージェントのリソースを消費することが許可されていないそのため、このバッファは制限されるべきです。ほとんどのAPIでは、受信エージェントは、負荷が予想よりも大きい場合ので、送信エージェントにバッファリングを強制的に、クランプされたTCPのウィンドウになりますTCPソケットからの読み取りを停止持ちます。しかし、両方のRTSPメッセージのサイズと周波数として薬剤が潜在的攻撃に対してより厳しい測定を行う約注意する必要があり、プロトコルの拡張により、将来的に変更することができます。ときに攻撃を受けて、RTSPエージェントは、TCPコネクションを閉じて、そのTCP接続に関連付けられている状態を解除することができます。"
    },
    {
      "indent": 3,
      "text": "To provide some guidance on what is reasonable, the following guidelines are given. It is RECOMMENDED that:",
      "ja": "合理的であるかについて、いくつかのガイダンスを提供するには、以下のガイドラインが与えられています。これは、することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "o an RTSP agent should not have more than 10 outstanding requests per RTSP session;",
      "ja": "O RTSPエージェントは、RTSPセッションごとに10の以上の未処理の要求を持つべきではありません。"
    },
    {
      "indent": 3,
      "text": "o an RTSP agent should not have more than 10 outstanding requests that are not related to an RTSP session or that are requesting to create an RTSP session.",
      "ja": "O RTSPエージェントは、RTSPセッションに関連していないか、RTSPセッションを作成するために要求される10の以上の未処理の要求を持つべきではありません。"
    },
    {
      "indent": 3,
      "text": "In light of the above, it is RECOMMENDED that clients use persistent connections whenever possible. A client that supports persistent connections MAY \"pipeline\" its requests (see Section 12).",
      "ja": "上記に照らして、可能な限り、クライアントは永続的な接続を使用することをお勧めします。持続的接続をサポートするクライアントは、「パイプライン」のリクエスト（セクション12を参照）ことがあります。"
    },
    {
      "indent": 3,
      "text": "RTSP agents can send requests to multiple different destinations, either server or client contexts over the same connection to a proxy. Then, the proxy forks the message to the different destinations over proxy-to-agent connections. In these cases when multiple requests are outstanding, the requesting agent MUST be ready to receive the responses out of order compared to the order they where sent on the connection. The order between multiple messages for each destination will be maintained; however, the order between response from different destinations can be different.",
      "ja": "RTSPエージェントは、プロキシへの同じ接続を介してサーバーまたはクライアントのコンテキストのいずれか、複数の異なる宛先にリクエストを送信することができます。そして、プロキシフォークプロキシ・ツー・エージェント接続を介して別の目的地へのメッセージ。複数の要求が傑出しているこれらのケースでは、要求エージェントは、接続上で送信され、彼らはどこに順番に比べ順不同でレスポンスを受信する準備ができなければなりません。宛先ごとに複数のメッセージの順序が維持されます。しかし、異なる宛先からの応答間の順序が異なる場合があります。"
    },
    {
      "indent": 6,
      "text": "The reason for this is to avoid a head-of-line blocking situation. In a sequence of requests, an early outstanding request may take time to be processed at one destination. Simultaneously, a response from any other destination that was later in the sequence of requests may have arrived at the proxy; thus, allowing out-of-order responses avoids forcing the proxy to buffer this response and instead deliver it as soon as possible. Note, this will not affect the order in which the messages sent to each separate destination were processed at the request destination.",
      "ja": "この理由は、ヘッドオブラインブロッキングの状況を回避することです。要求のシーケンスでは、初期の未処理の要求は、1つの先に処理されるのに時間がかかる場合があります。同時に、リクエストの順序の後半であった他の宛先からの応答がプロキシに到達したかもしれません。このように、アウト・オブ・オーダー応答を許可すると、この応答をバッファリングし、代わりに、できるだけ早くそれを実現するためにプロキシを強制的に避けることができます。これは、各個別の宛先に送信されたメッセージは、要求先で処理された順序には影響しません、注意してください。"
    },
    {
      "indent": 3,
      "text": "This scenario can occur in two cases involving proxies. The first is a client issuing requests for sessions on different servers using a common client-to-proxy connection. The second is for server-to-client requests, like REDIRECT being sent by the server over a common transport connection the proxy created for its different connecting clients.",
      "ja": "このシナリオでは、プロキシを含む2つの場合に発生する可能性があります。最初は、一般的なクライアント - プロキシ接続を使用して、異なるサーバー上のセッションに対するリクエストを発行するクライアントです。 REDIRECTは、プロキシはその異なる接続するクライアントのために作成した共通のトランスポート接続を介してサーバによって送信されるように第二は、サーバーからクライアントへの要求のためです。"
    },
    {
      "indent": 0,
      "text": "10.3. Closing Connections",
      "section_title": true,
      "ja": "10.3. 閉会の接続"
    },
    {
      "indent": 3,
      "text": "The client MAY close a connection at any point when no outstanding request/response transactions exist for any RTSP session being managed through the connection. The server, however, SHOULD NOT close a connection until all RTSP sessions being managed through the connection have been timed out (Section 18.49). A server SHOULD NOT close a connection immediately after responding to a session-level TEARDOWN request for the last RTSP session being controlled through the connection. Instead, the server should wait for a reasonable amount of time for the client to receive and act upon the TEARDOWN response and then initiate the connection closing. The server SHOULD wait at least 10 seconds after sending the TEARDOWN response before closing the connection.",
      "ja": "クライアントには、未処理の要求/応答トランザクションは、接続を介して管理されている任意のRTSPセッションのために存在しない任意の時点で接続を終えるかもしれません。すべてのRTSPセッションが（セクション18.49）タイムアウトになってきた接続を介して管理されてまで、サーバーは、しかし、接続を閉じるべきではありません。サーバーはすぐに接続を介して制御されている最後のRTSPセッションのためのセッションレベルのTEARDOWN要求に応答した後、接続を閉じるべきではありません。代わりに、サーバはTEARDOWN応答時に受信して動作するクライアントのための妥当な時間を待ってから、接続閉鎖を開始する必要があります。サーバが接続を閉じる前にTEARDOWN応答を送信した後、10秒以上待つ必要があります。"
    },
    {
      "indent": 6,
      "text": "This is to ensure that the client has time to issue a SETUP for a new session on the existing connection after having torn the last one down. Ten seconds should give the client ample opportunity to get its message to the server.",
      "ja": "これは、クライアントが最後のダウンを引き裂かれた後、既存の接続上の新しいセッションのためのSETUPを発行するための時間を持っていることを確認することです。 10秒は、クライアントにサーバーへのメッセージを取得するための十分な機会を与える必要があります。"
    },
    {
      "indent": 3,
      "text": "A server SHOULD NOT close the connection directly as a result of responding to a request with an error code.",
      "ja": "サーバはエラーコードで要求に応答するの結果として直接接続をクローズすべきではありません。"
    },
    {
      "indent": 6,
      "text": "Certain error responses such as 460 (Only Aggregate Operation Allowed) (Section 17.4.24) are used for negotiating capabilities of a server with respect to content or other factors. In such cases, it is inefficient for the server to close a connection on an error response. Also, such behavior would prevent implementation of advanced or special types of requests or result in extra overhead for the client when testing for new features. On the other hand, keeping connections open after sending an error response poses a Denial-of-Service (DoS) security risk (Section 21).",
      "ja": "こうした460（許可された唯一の集約演算）（セクション17.4.24）などの特定のエラー応答は、コンテンツまたはその他の要因に関連して、サーバーの能力を交渉するために使用されています。サーバはエラーレスポンスに接続を閉じるためのこのような場合には、それは非効率的です。また、このような行動は、要求の高度または特殊なタイプの実装を防止または新しい機能のためにテストするときに、クライアントのための余分なオーバーヘッドにつながります。一方、エラー応答を送信した後にオープン接続を維持することはサービス拒否（DoS）のセキュリティリスク（セクション21）を提起します。"
    },
    {
      "indent": 3,
      "text": "The server MAY close a connection if it receives an incomplete message and if the message is not completed within a reasonable amount of time. It is RECOMMENDED that the server wait at least 10 seconds for the completion of a message or for the next part of the message to arrive (which is an indication that the transport and the client are still alive). Servers believing they are under attack or that are otherwise starved for resources during that event MAY consider using a shorter timeout.",
      "ja": "メッセージは妥当な時間内に完了しない場合、それは不完全なメッセージを受信した場合、サーバーは接続を閉じます。サーバがメッセージの完了または（トランスポートとクライアントがまだ生きていることの指標である）が到着するメッセージの次の部分のために少なくとも10秒待つことが推奨されます。彼らは攻撃を受けているか、信じサーバーは、それ以外の場合は短いタイムアウトを使用することを検討するかもしれそのイベント中にリソースに飢えています。"
    },
    {
      "indent": 3,
      "text": "If a server closes a connection while the client is attempting to send a new request, the client will have to close its current connection, establish a new connection, and send its request over the new connection.",
      "ja": "クライアントは、新しい要求を送信しようとしている間に、サーバーが接続を閉じた場合、クライアントは、その現在の接続を閉じ、新しい接続を確立し、新しい接続を介してその要求を送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "An RTSP message SHOULD NOT be terminated by closing the connection. Such a message MAY be considered to be incomplete by the receiver and discarded. An RTSP message is properly terminated as defined in Section 5.",
      "ja": "RTSPメッセージは、接続を閉じることで終了されるべきではありません。そのようなメッセージは、受信機による不完全で廃棄されると考えることができます。第5節で定義されたRTSPメッセージが正常に終了されます。"
    },
    {
      "indent": 0,
      "text": "10.4. Timing Out Connections and RTSP Messages",
      "section_title": true,
      "ja": "10.4. タイムアウト接続とRTSPメッセージ"
    },
    {
      "indent": 3,
      "text": "Receivers of a request (responders) SHOULD respond to requests in a timely manner even when a reliable transport such as TCP is used. Similarly, the sender of a request (requester) SHOULD wait for a sufficient time for a response before concluding that the responder will not be acting upon its request.",
      "ja": "リクエスト（応答）のレシーバは、TCPのような信頼性の高いトランスポートが使用されても、タイムリーに要求に応答する必要があります。同様に、リクエスト（要求元）の送信者は、応答者がその要求に作用しないことを結論付ける前に、応答のための十分な時間を待つべき。"
    },
    {
      "indent": 3,
      "text": "A responder SHOULD respond to all requests within 5 seconds. If the responder recognizes that the processing of a request will take longer than 5 seconds, it SHOULD send a 100 (Continue) response as soon as possible. It SHOULD continue sending a 100 response every 5 seconds thereafter until it is ready to send the final response to the requester. After sending a 100 response, the responder MUST send a final response indicating the success or failure of the request.",
      "ja": "レスポンダは5秒以内にすべての要求に応答する必要があります。応答者は、要求の処理が5秒以上の時間がかかるだろうと認識した場合は、できるだけ早く100（続行）応答を送信すべきです。要求者への最終応答を送信する準備ができるまで5秒ごとに、その後、100応答を送信し続けるべきです。 100応答を送信した後、応答は、要求の成功または失敗を示す最終応答を送らなければなりません。"
    },
    {
      "indent": 3,
      "text": "A requester SHOULD wait at least 10 seconds for a response before concluding that the responder will not be responding to its request. After receiving a 100 response, the requester SHOULD continue waiting for further responses. If more than 10 seconds elapse without receiving any response, the requester MAY assume that the responder is unresponsive and abort the connection by closing the TCP connection.",
      "ja": "依頼者は、応答者がその要求に応答しないことを結論付ける前に応答するために、少なくとも10秒間待つ必要があります。 100応答を受け取った後、依頼者は、さらに応答を待ち続けるべきです。 10秒以上が何らかの応答を受信せずに経過した場合は、依頼者は、応答者が応答しないことを前提とし、TCP接続を閉じることで、接続を中断することができます。"
    },
    {
      "indent": 3,
      "text": "In some cases, multiple RTSP sessions share the same transport connection; abandoning a request and closing the connection may have significant impact on those other sessions. First of all, other RTSP requests may have become queued up due to the request taking a long time to process. Secondly, those sessions also lose the possibility to receive server-to-client requests. To mitigate that situation, the RTSP client or server SHOULD establish a new connection and send any requests that are queued up or that haven't received a response on this new connection. Thirdly, to ensure that the RTSP server knows which connection is valid for a particular RTSP session, the RTSP agent SHOULD send a keep-alive request, if no other request will be sent immediately for that RTSP session, for each RTSP session on the old connection. The keep-alive request will normally be a SET_PARAMETER with a session header to inform the server that this agent cares about this RTSP session.",
      "ja": "いくつかのケースでは、複数のRTSPセッションは、同じトランスポート接続を共有します。要求を放棄し、接続を閉じると、それらの他のセッションに重大な影響を与える可能性があります。まず第一に、他のRTSP要求が原因処理に長い時間がかかっ要求までにキューイングされている可能性があります。第二に、これらのセッションは、サーバーからクライアントへのリクエストを受信する可能性を失います。そのような状況を緩和するために、RTSPクライアントまたはサーバが新しい接続を確立し、キューに入れられているか、それがこの新しい接続に応答を受信して​​いないすべての要求を送信します。他の要求が古い上の各RTSPセッションのために、そのRTSPセッションのために直ちに送信されません場合は第三に、RTSPサーバは、接続が特定のRTSPセッションに対して有効であるかを知っていることを保証するために、RTSPエージェントは、キープアライブ要求を送信すべきです接続。キープアライブ要求は、通常、このエージェントは、このRTSPセッションを気にサーバーに通知するためにセッションヘッダとSET_PARAMETERになります。"
    },
    {
      "indent": 3,
      "text": "A requester SHOULD wait longer than 10 seconds for a response if it is experiencing significant transport delays on its connection to the responder. The requester is capable of determining the Round-Trip Time (RTT) of the request/response cycle using the Timestamp header (Section 18.53) in any RTSP request.",
      "ja": "それは、レスポンダへの接続に重要な輸送の遅延が発生している場合、要求者は、応答のために10秒以上待つ必要があります。リクエスタは、任意のRTSP要求にタイムスタンプヘッダ（セクション18.53）を使用して、要求/応答サイクルの往復時間（RTT）を決定することが可能です。"
    },
    {
      "indent": 6,
      "text": "The 10-second wait was chosen for the following reasons. It gives TCP time to perform a couple of retransmissions, even if operating on default values. It is short enough that users may not abandon the process themselves. However, it should be noted that 10 seconds can be aggressive on certain types of networks. The 5-second value for 1xx messages is half the timeout giving a reasonable chance of successful delivery before timeout happens on the requester side.",
      "ja": "10秒の待ち時間は、次の理由のために選択しました。これは、デフォルト値で動作した場合でも、再送信のカップルを実行するためにTCPの時間を与えます。これにより、ユーザーは、プロセスそのものを放棄しないことが十分に短いです。しかし、10秒がネットワークの特定の種類に積極的であることに留意されたいです。タイムアウトが依頼者側で発生する前の1xxメッセージのための5秒の値が正常な配信の合理的なチャンスを与え半分タイムアウトです。"
    },
    {
      "indent": 0,
      "text": "10.5. Showing Liveness",
      "section_title": true,
      "ja": "10.5. ライブネスを表示"
    },
    {
      "indent": 3,
      "text": "RTSP requires the client to periodically show its liveness to the server or the server may terminate any session state. Several different protocol mechanism include in their usage a liveness proof from the client. These mechanisms are RTSP requests with a Session header to the server; if RTP & RTCP is used for media data transport and the transport is established, the RTCP message proves liveness; or through any other used media-transport protocol capable of indicating liveness of the RTSP client. It is RECOMMENDED that a client not wait to the last second of the timeout before trying to send a liveness message. The RTSP message may take some time to arrive safely at the receiver, due to packet loss and TCP retransmissions. To show liveness between RTSP requests being issued to accomplish other things, the following mechanisms can be used, in descending order of preference:",
      "ja": "RTSPは、定期的にサーバにその活動性を示すために、クライアントを必要とするか、またはサーバが任意のセッション状態を終了させることができます。いくつかの異なるプロトコルのメカニズムは、その用途にクライアントからの生存性の証明が含まれます。これらの機構は、サーバーにセッションヘッダとRTSP要求です。 RTPとRTCPは、メディアデータ伝送のために使用され、輸送が確立されている場合、RTCPメッセージは、ライブネス証明します。またはRTSPクライアントの生存性を示すことができる任意の他の中古メディアトランスポートプロトコルを介し。クライアントがライブネスメッセージを送信しようとする前にタイムアウトの最後の秒まで待たないことをお勧めします。 RTSPメッセージは、パケットロスおよびTCP再送信に、受信機に安全に到着する時間がかかる場合があります。他のものを達成するために発行されたRTSP要求間の生存性を表示するには、以下のメカニズムは、好みの降順で、使用することができます。"
    },
    {
      "indent": 3,
      "text": "RTCP: If RTP is used for media transport, RTCP SHOULD be used. If RTCP is used to report transport statistics, it will necessarily also function as a keep-alive. The server can determine the client by network address and port together with the fact that the client is reporting on the server's RTP sender sources (synchronization source (SSRCs)). A downside of using RTCP is that it only gives statistical guarantees of reaching the server. However, the probability of a false client timeout is so low that it can be ignored in most cases. For example, assume a session with a 60-second timeout and enough bitrate assigned to RTCP messages to send a message from client to server on average every 5 seconds. That client has, for a network with 5% packet loss, a probability of failing to confirm liveness within the timeout interval for that session of 2.4*E-16. Sessions with shorter timeouts, much higher packet loss, or small RTCP bandwidths SHOULD also implement one or more of the mechanisms below.",
      "ja": "RTCP：RTPは、メディア転送のために使用されている場合は、RTCPを使用する必要があります。 RTCPは、トランスポートの統計情報を報告するために使用された場合、それは必ずしももキープアライブとして機能します。サーバは、一緒にクライアントがサーバーのRTP送信者ソース（同期ソース（SSRCs））に報告しているという事実とネットワークアドレスとポートでクライアントを決定することができます。 RTCPを使用しての欠点は、それが唯一のサーバーに到達する統計的保証を与えることです。しかし、偽のクライアントのタイムアウトの確率は、それはほとんどの場合、無視できるほど小さいです。例えば、平均5秒ごとに、クライアントからサーバーにメッセージを送信するために60秒のタイムアウトとRTCPメッセージに割り当てられた十分なビットレートとのセッションを想定しています。そのクライアントは、5％のパケットロス、2.4 * E-16のそのセッションのタイムアウト時間内に生存性を確認するために失敗する確率を持つネットワークのために、持っています。短いタイムアウト、はるかに高いパケット損失、または小さなRTCP帯域幅とのセッションは、以下のメカニズムの一つ以上を実装する必要があります。"
    },
    {
      "indent": 3,
      "text": "SET_PARAMETER: When using SET_PARAMETER for keep-alives, a body SHOULD NOT be included. This method is the RECOMMENDED RTSP method to use for a request intended only to perform keep-alives. RTSP servers MUST support the SET_PARAMETER method, so that clients can always use this mechanism.",
      "ja": "SET_PARAMETER：キープアライブのためのSET_PARAMETERを使用する場合は、本体が含まれるべきではありません。このメソッドは、キープアライブを実行することを目的と要求のために使用することをお勧めRTSP方式です。クライアントは常にこのメカニズムを使用できるように、RTSPサーバは、SET_PARAMETERメソッドをサポートしなければなりません。"
    },
    {
      "indent": 3,
      "text": "GET_PARAMETER: When using GET_PARAMETER for keep-alives, a body SHOULD NOT be included, dependent on implementation support in the server. Use the OPTIONS method to determine if there is method support or simply try.",
      "ja": "GET_PARAMETER：キープアライブのためのGET_PARAMETERを使用する場合は、本体がサーバーでの実装のサポートに依存して、含まれるべきではありません。メソッドのサポートがあるかどうかを決定または単にしようとするOPTIONSメソッドを使用します。"
    },
    {
      "indent": 3,
      "text": "OPTIONS: This method is also usable, but it causes the server to perform more unnecessary processing and results in bigger responses than necessary for the task. The reason is that the server needs to determine the capabilities associated with the media resource to correctly populate the Public and Allow headers.",
      "ja": "OPTIONS：この方法を用いることもできるが、それは、サーバがタスクのために必要以上に大きな応答でより多くの不必要な処理し、結果を実行させます。その理由は、サーバーが正しく公開を移入し、ヘッダを許可するメディアリソースに関連付けられた機能を決定する必要があるということです。"
    },
    {
      "indent": 3,
      "text": "The timeout parameter of the Session header (Section 18.49) MAY be included in a SETUP response and MUST NOT be included in requests. The server uses it to indicate to the client how long the server is prepared to wait between RTSP commands or other signs of life before closing the session due to lack of activity (see Appendix B). The timeout is measured in seconds, with a default of 60 seconds. The length of the session timeout MUST NOT be changed in an established session.",
      "ja": "セッションヘッダ（セクション18.49）のタイムアウトパラメータは、SETUP応答に含まれてもよく、要求に含まれてはいけません。サーバーは、サーバーがRTSP間で待機する準備がどのくらいクライアントに示すためにそれを使用してコマンドまたは生命の他の徴候による活動の不足のためにセッションを閉じる前に、（付録Bを参照してください）。タイムアウトは60秒のデフォルトで、秒単位で測定されます。セッションタイムアウトの長さは、確立されたセッションで変更しないでください。"
    },
    {
      "indent": 0,
      "text": "10.6. Use of IPv6",
      "section_title": true,
      "ja": "10.6.  IPv6の使用"
    },
    {
      "indent": 3,
      "text": "Explicit IPv6 [RFC2460] support was not present in RTSP 1.0. RTSP 2.0 has been updated for explicit IPv6 support. Implementations of RTSP 2.0 MUST understand literal IPv6 addresses in URIs and RTSP headers. Although the general URI format envisages potential future new versions of the literal IP address, usage of any such new version would require other modifications to the RTSP specification (e.g., address fields in the Transport header (Section 18.54)).",
      "ja": "明示的なIPv6の[RFC2460]のサポートは、RTSP 1.0には存在しませんでした。 RTSP 2.0は、明示的なIPv6サポートのために更新されました。 RTSP 2.0の実装は、URIとRTSPヘッダー内のリテラルIPv6アドレスを理解する必要があります。一般的なURI形式がリテラルIPアドレスの潜在的な将来の新しいバージョンを想定しているが、このような新しいバージョンの使用は、RTSP仕様に他の修飾（例えば、トランスポート・ヘッダのアドレスフィールド（セクション18.54））を必要とするであろう。"
    },
    {
      "indent": 0,
      "text": "10.7. Overload Control",
      "section_title": true,
      "ja": "10.7. 過負荷制御"
    },
    {
      "indent": 3,
      "text": "Overload in RTSP can occur when servers and proxies have insufficient resources to complete the processing of a request. An improper handling of such an overload situation at proxies and servers can impact the operation of the RTSP deployment, and probably worsen the situation. RTSP defines the 503 (Service Unavailable) response (Section 17.5.4) to let servers and proxies notify requesting proxies and RTSP clients about an overload situation. In conjunction with the Retry-After header (Section 18.44), the server or proxy can indicate the time after which the requesting entity can send another request to the proxy or server.",
      "ja": "サーバやプロキシが要求の処理を完了するのに十分なリソースを持っているとき、RTSPで過負荷が発生する可能性があります。プロキシやサーバの過負荷状況の不適切な取り扱いは、RTSPの展開の動作に影響を与え、そしておそらく状況を悪化させることができます。 RTSPは、サーバやプロキシが過負荷状況について要求プロキシおよびRTSPクライアントに通知できるように503（サービス利用不可）応答（セクション17.5.4）を定義します。リトライ後ヘッダ（セクション18.44）に関連して、サーバまたはプロキシは、要求エンティティがプロキシまたはサーバへの別の要求を送ることができるまでの時間を示すことができます。"
    },
    {
      "indent": 3,
      "text": "There are two scopes of such 503 answers. The first scope is for an established RTSP session, where the request resulting in the 503 response as well as the response itself carries a Session header identifying the session that is suffering overload. This response only applies to this particular session. The other scope is the general RTSP server as identified by the host in the Request-URI. Such a 503 answer with any Retry-After header applies to all requests that are not session specific to that server, including a SETUP request intended to create a new RTSP session.",
      "ja": "そのような503件の回答の2つのスコープがあります。最初の範囲は503応答をもたらす要求ならびに応答自体が過負荷に罹患しているセッションを識別するセッションヘッダを運ぶ確立し、RTSPセッションのためです。この応答は、この特定のセッションに適用されます。他の範囲は、Request-URI内のホストによって識別される一般的なRTSPサーバです。すべての再試行-Afterヘッダを持つような503の答えは、新しいRTSPセッションを作成することを目的とSETUP要求を含むそのサーバーに固有のセッションではありませんすべての要求に適用されます。"
    },
    {
      "indent": 3,
      "text": "Another scope for overload situations exists: the RTSP proxy. To enable an RTSP proxy to signal that it is overloaded, or otherwise unavailable and unable to handle the request, a 553 response code has been defined with the meaning \"Proxy Unavailable\". As with servers, there is a separation in response scopes between requests associated with existing RTSP sessions and requests to create new sessions or general proxy requests.",
      "ja": "過負荷状態のためのもう一つの範囲が存在する：RTSPプロキシを。それが過負荷であることを知らせるためにRTSPプロキシを有効にする、またはそうでなければ利用できないと、要求を処理できないために、553応答コードが意味「プロキシ利用不可」と定義されています。サーバと同じように、既存のRTSPセッションと新規セッションまたは一般的なプロキシ要求を作成するための要求に関連する要求間の応答スコープでの分離があります。"
    },
    {
      "indent": 3,
      "text": "Simply implementing and using the 503 (Service Unavailable) and 553 (Proxy Unavailable) response codes is not sufficient for properly handling overload situations. For instance, a simplistic approach would be to send the 503 response with a Retry-After header set to a fixed value. However, this can cause a situation in which multiple RTSP clients again send requests to a proxy or server at roughly the same time, which may again cause an overload situation. Another situation would be if the \"old\" overload situation is not yet resolved, i.e., the length indicated in the Retry-After header was too short for the overload situation to subside.",
      "ja": "単純に実装すると、503（サービス利用不可）と553（プロキシ使用不可）応答コードを使用すると、適切に過負荷状態を処理するのに十分ではありません。例えば、単純なアプローチは、固定値に設定リトライ後ヘッダと503応答を送信することであろう。しかし、これは再び過負荷状態を引き起こす可能性があり、複数のRTSPクライアントが再びほぼ同じ時刻にプロキシまたはサーバーに要求を送信する状況を引き起こす可能性があります。 「古い」過負荷状況がまだ解決されていない場合、再試行後、ヘッダが沈静する過負荷状態のために短すぎた別の状況では、すなわち、長さが示されるであろう。"
    },
    {
      "indent": 3,
      "text": "An RTSP server or proxy in an overload situation must select the value of the Retry-After header carefully, bearing in mind its current load situation. It is REQUIRED to increase the timeout period in proportion to the current load on the server, i.e., an increasing workload should result in an increased length of the indicated unavailability. It is REQUIRED not to send the same value in the Retry-After header to all requesting proxies and clients, but to add a variation to the mean value of the Retry-After header.",
      "ja": "過負荷状態でのRTSPサーバまたはプロキシは、心の中で、現在の負荷状況をベアリング、慎重に再試行-Afterヘッダの値を選択する必要があります。すなわち、増加ワークロードが示された利用不可の増大した長さをもたらすはずで、サーバ上の現在の負荷に比例してタイムアウト期間を増加する必要があります。すべての要求のプロキシとクライアントへの再試行-Afterヘッダで同じ値を送信しないように必要ですが、再試行-Afterヘッダの平均値に変動を追加します。"
    },
    {
      "indent": 3,
      "text": "A more complex case may arise when a load-balancing RTSP proxy is in use. This is the case when an RTSP proxy is used to select amongst a set of RTSP servers to handle the requests or when multiple server addresses are available for a given server name. The proxy or client may receive a 503 (Service Unavailable) or 553 (Proxy Unavailable) response code from one of its RTSP servers or proxies, or a TCP timeout (if the server is even unable to handle the request message). The proxy or client simply retries the other addresses or configured proxies, but it may also receive a 503 (Service Unavailable) or 553 (Proxy Unavailable) response or TCP timeouts from those addresses. In such a situation, where none of the RTSP servers/proxies/addresses can handle the request, the RTSP agent has to wait before it can send any new requests to the RTSP server. Any additional request to a specific address MUST be delayed according to the Retry-After headers received. For addresses where no response was received or TCP timeout occurred, an initial wait timer SHOULD be set to 5 seconds. That timer MUST be doubled for each additional failure to connect or receive response until the value exceeds 30 minutes when the timer's mean value may be set to 30 minutes. It is REQUIRED not to set the same value in the timer for each scheduling, but instead to add a variation to the mean value, resulting in picking a random value within the range of 0.5 to 1.5 times the mean value.",
      "ja": "負荷分散RTSPプロキシが使用中であるときに、より複雑なケースが生じ得ます。これは、RTSPプロキシが要求または複数のサーバのアドレスが指定されたサーバー名のために利用可能な場合を扱うためのRTSPサーバのセットの間で選択するために使用された場合です。 （サーバは、要求メッセージを処理することも、できない場合）、プロキシまたはクライアントが503（サービス利用不可）またはそのRTSPサーバやプロキシの1から553（プロキシ使用不可）レスポンスコード、またはTCPのタイムアウトを受け取ることができます。プロキシまたはクライアントは、単に他のアドレスまたは構成プロキシを再試行し、それはまた、503（サービス利用不可）または553（プロキシ使用不可）応答を受信することができるか、TCPがそれらのアドレスからタイムアウト。 RTSPサーバ/プロキシ/アドレスのどれが要求を扱うことができないような状況では、RTSPエージェントは、それがRTSPサーバへの新しい要求を送信する前に待機する必要があります。特定のアドレスに任意の追加の要求は再試行後ヘッダ受信に応じて遅延されなければなりません。応答がないか、TCPのタイムアウトが発生したアドレスの場合、初期待ちタイマは5秒に設定する必要があります。値は、タイマの平均値は30分に設定することができる30分を超えるまで、すなわち、タイマは、応答を接続または受信するそれぞれの追加の失敗のために倍増しなければなりません。各スケジューリングのためのタイマと同じ値を設定しないことが要求され、その代わりに0.5〜1.5倍の平均値の範囲内でランダムな値を選んで、その結果、平均値に変動を追加します。"
    },
    {
      "indent": 0,
      "text": "11. Capability Handling",
      "section_title": true,
      "ja": "11.能力取扱い"
    },
    {
      "indent": 3,
      "text": "This section describes the available capability-handling mechanism that allows RTSP to be extended. Extensions to this version of the protocol are basically done in two ways. Firstly, new headers can be added. Secondly, new methods can be added. The capability-handling mechanism is designed to handle both cases.",
      "ja": "このセクションでは、RTSPを拡張することを可能にする利用可能能力の処理メカニズムを説明しています。プロトコルのこのバージョンへの拡張は、基本的に2つの方法で行われます。まず、新しいヘッダを追加することができます。第二に、新しいメソッドを追加することができます。機能処理メカニズムは、両方のケースを処理するように設計されています。"
    },
    {
      "indent": 3,
      "text": "When a method is added, the involved parties can use the OPTIONS method to discover whether it is supported. This is done by issuing an OPTIONS request to the other party. Depending on the URI, it will either apply in regard to a certain media resource, the whole server in general, or simply the next hop. The OPTIONS response MUST contain a Public header that declares all methods supported for the indicated resource.",
      "ja": "メソッドが追加されると、関係者は、それがサポートされているかどうかを発見するためにOPTIONSメソッドを使用することができます。これは、他の当事者にOPTIONS要求を発行することによって行われます。 URIに応じて、いずれかの特定のメディア・リソース、一般的にはサーバ全体、または単に次のホップに関して適用されます。 OPTIONS応答は、示されたリソースのためにサポートされるすべてのメソッドを宣言する公開ヘッダを含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "It is not necessary to use OPTIONS to discover support of a method, as the client could simply try the method. If the receiver of the request does not support the method, it will respond with an error code indicating the method is either not implemented (501) or does not apply for the resource (405). The choice between the two discovery methods depends on the requirements of the service.",
      "ja": "クライアントは単に方法を試みることができるよう、メソッドのサポートを発見するためのオプションを使用する必要はありません。要求の受信メソッドをサポートしない場合、それは、（501）で実現されていないか、またはリソース（405）には適用されない方法を示すエラーコードで応答します。 2つの発見方法の選択は、サービスの要件によって異なります。"
    },
    {
      "indent": 3,
      "text": "Feature tags are defined to handle functionality additions that are not new methods. Each feature tag represents a certain block of functionality. The amount of functionality that a feature tag represents can vary significantly. For example, a feature tag can represent the functionality a single RTSP header provides. Another feature tag can represent much more functionality, such as the \"play.basic\" feature tag (Section 11.1), which represents the minimal media delivery for playback implementation.",
      "ja": "フィーチャータグは、新たな方法ではありません機能の追加を処理するために定義されています。各特徴タグは、機能性のあるブロックを表します。フィーチャータグが表す機能の量は大きく異なります。例えば、特徴タグは、単一のRTSPヘッダが提供する機能を表すことができます。別の特徴タグは、再生の実装のための最小限のメディア配信を表す「play.basic」特徴タグ（セクション11.1）として、より多くの機能を表すことができます。"
    },
    {
      "indent": 3,
      "text": "Feature tags are used to determine whether the client, server, or proxy supports the functionality that is necessary to achieve the desired service. To determine support of a feature tag, several different headers can be used, each explained below:",
      "ja": "フィーチャータグは、クライアント、サーバー、またはプロキシが必要なサービスを実現するために必要な機能をサポートしているかどうかを決定するために使用されています。特徴タグのサポートを決定するために、いくつかの異なるヘッダは、それぞれ以下に説明する、使用することができます。"
    },
    {
      "indent": 3,
      "text": "Supported: This header is used to determine the complete set of functionality that both client and server have, in general, and is not dependent on a specific resource. The intended usage is to determine before one needs to use a functionality that it is supported. It can be used in any method, but OPTIONS is the most suitable as it simultaneously determines all methods that are implemented. When sending a request, the requester declares all its capabilities by including all supported feature tags. This results in the receiver learning the requester's feature support. The receiver then includes its set of features in the response.",
      "ja": "サポート：このヘッダは、クライアントとサーバーの両方が、一般的に、持っていた機能の完全なセットを決定するために使用され、特定のリソースに依存しないです。意図した使用方法は1つが、それはサポートされている機能を使用する必要がある前に決定することです。これは、任意の方法で使用することができるが、それは同時に実施されているすべての方法を決定するなどのオプションが最も適しています。リクエストを送信すると、依頼者は、サポートされているすべての機能タグを含めることによって、そのすべての機能を宣言します。これは、要求者の機能のサポートを学ん受信機になります。受信機は、応答内の特徴のセットを含んでいます。"
    },
    {
      "indent": 3,
      "text": "Proxy-Supported: This header is used in a similar fashion as the Supported header, but instead of giving the supported functionality of the client or server, it provides both the requester and the responder a view of the common functionality supported in general by all members of the proxy chain between the client and server; it does not depend on the resource. Proxies are required to add this header whenever the Supported header is present, but proxies may also add it independently of the requester.",
      "ja": "プロキシサポート：このヘッダはSupportedヘッダと同様の方法で使用されるが、代わりに、クライアントまたはサーバのサポート機能を与える、それはすべてのメンバーが一般的にサポートされている共通の機能の観点から要求側と応答の両方を提供していますクライアントとサーバ間のプロキシチェーンの。それはリソースに依存しません。プロキシは、Supportedヘッダが存在するときはいつでも、このヘッダーを追加するために必要とされるが、プロキシはまた、独立して、リクエスタのそれを追加してもよいです。"
    },
    {
      "indent": 3,
      "text": "Require: This header can be included in any request where the endpoint, i.e., the client or server, is required to understand the feature to correctly perform the request. This can, for example, be a SETUP request, where the server is required to understand a certain parameter to be able to set up the media delivery correctly. Ignoring this parameter would not have the desired effect and is not acceptable. Therefore, the endpoint receiving a request containing a Require MUST negatively acknowledge any feature that it does not understand and not perform the request. The response in cases where features are not supported is 551 (Option Not Supported). Also, the features that are not supported are given in the Unsupported header in the response.",
      "ja": "必要とする：このヘッダは、エンドポイント、即ち、クライアントまたはサーバが、正しく要求を実行するための機能を理解するために必要とされる任意の要求に含めることができます。これは、例えば、サーバーが正しくメディア配信を設定できるようにするには、特定のパラメータを理解するために必要なSETUP要求、することができます。このパラメータを無視すると、所望の効果を持っていないと受け入れられないでしょう。そのため、マイナスのことは理解していないと、要求を実行していない任意の特徴を確認しなければならない必要含むリクエストを受信するエンドポイント。機能がサポートされていない場合の応答は551（オプションサポートされていない）です。また、サポートされていない機能は、応答でサポートされていないヘッダに記載されています。"
    },
    {
      "indent": 3,
      "text": "Proxy-Require: This header has the same purpose and behavior as Require except that it only applies to proxies and not the endpoint. Features that need to be supported by both proxies and endpoints need to be included in both the Require and Proxy-Require header.",
      "ja": "プロキシは、要求：それはプロキシだけではなくエンドポイントに適用されることを除いて必要とするこのヘッダは、同じ目的や行動を持っています。プロキシとエンドポイントの両方でサポートされる必要がある機能は、両方の要求とプロキシ要求ヘッダに含まれる必要があります。"
    },
    {
      "indent": 3,
      "text": "Unsupported: This header is used in a 551 (Option Not Supported) error response, to indicate which features were not supported. Such a response is only the result of the usage of the Require or Proxy-Require headers where one or more features were not supported. This information allows the requester to make the best of situations as it knows which features are not supported.",
      "ja": "サポートされていない：このヘッダは、機能がサポートされていなかったかを示すために、551（オプションサポートされていない）エラー応答に使用されます。そのような応答は、一つ以上の機能がサポートされていなかった要求またはプロキシ要求ヘッダーの使用の唯一の結果です。この情報は、機能がサポートされていないかを知っているよう要求者が状況を最大限に活用することができます。"
    },
    {
      "indent": 0,
      "text": "11.1. Feature Tag: play.basic",
      "section_title": true,
      "ja": "11.1. 特集タグ：play.basic"
    },
    {
      "indent": 3,
      "text": "An implementation supporting all normative parts of this specification for the setup and control of playback of media uses the feature tag \"play.basic\" to indicate this support. The appendices (starting with letters) are not part of the functionality included in the feature tag unless the appendix is explicitly specified in a main section as being a required appendix.",
      "ja": "メディアの再生の設定と制御のためにこの仕様のすべての規定の一部をサポートする実装は、このサポートを示すために、フィーチャータグ「play.basic」を使用しています。付録（英字で始まる）は付録を明示的に要求付録であるとしてメインセクションに指定されていない限り、機能タグに含まれる機能の一部ではありません。"
    },
    {
      "indent": 6,
      "text": "Note: This feature tag does not mandate any media delivery protocol, such as RTP.",
      "ja": "注：この機能タグはRTPのような任意のメディア配信プロトコルを規定していません。"
    },
    {
      "indent": 6,
      "text": "In RTSP 1.0, there was a minimal implementation section. However, that was not consistent with the rest of the specification. So, rather than making an attempt to explicitly enumerate the features for play.basic, this specification has to be taken as a whole and the necessary features normatively defined as being required are included.",
      "ja": "RTSP 1.0で、最小限の実装部分がありました。しかし、それは仕様の残りの部分と一致しませんでした。だから、むしろ明示的play.basicのための機能を列挙しようとする試みをするよりも、この仕様は、全体として注意しなければならないと規範的に要求されるように定義に必要な機能が含まれています。"
    },
    {
      "indent": 0,
      "text": "12. Pipelining Support",
      "section_title": true,
      "ja": "12.パイプラインのサポート"
    },
    {
      "indent": 3,
      "text": "Pipelining is a general method to improve performance of request/ response protocols by allowing the requesting agent to have more than one request outstanding and to send them over the same persistent connection. For RTSP, where the relative order of requests will matter, it is important to maintain the order of the requests. Because of this, the responding agent MUST process the incoming requests in their sending order. The sending order can be determined by the CSeq header and its sequence number. For TCP, the delivery order will be the same, between two agents, as the sending order. The processing of the request MUST also have been finished before processing the next request from the same agent. The responses MUST be sent in the order the requests were processed.",
      "ja": "パイプラインは、要求エージェントは、優れた複数の要求を持っているし、同じ永続的な接続を介してそれらを送信できるようにすることで、要求/応答プロトコルのパフォーマンスを改善するための一般的な方法です。リクエストの相対的順序が問題になるRTSP、の場合は、要求の順序を維持することが重要です。このため、応答エージェントは、自分の送信順序で着信要求を処理しなければなりません。送信順序は、のCSeqヘッダとそのシーケンス番号によって決定することができます。 TCPの場合、配信順序が送信順序として、二つの薬剤の間、同じになります。リクエストの処理も同じエージェントからの次の要求を処理する前に終了しておく必要があります。応答は要求が処理された順に送らなければなりません。"
    },
    {
      "indent": 3,
      "text": "RTSP 2.0 has extended support for pipelining beyond the capabilities in RTSP 1.0. As a major improvement, all requests involved in setting up and initiating media delivery can now be pipelined, indicated by the Pipelined-Request header (see Section 18.33). This header allows a client to request that two or more requests be processed in the same RTSP session context that the first request creates. In other words, a client can request that two or more media streams be set up and then played without needing to wait for a single response. This speeds up the initial start-up time for an RTSP session by at least one RTT.",
      "ja": "RTSP 2.0は、RTSP 1.0での能力を超えたパイプラインのサポートを拡張しました。 （セクション18.33を参照）の主要な改善として、セットアップ及びメディア配信の開始に関与するすべての要求は、現在、パイプライン化することができるパイプライン・リクエスト・ヘッダが示します。このヘッダは、クライアントは、2つの以上の要求が最初の要求を作成し、同じRTSPセッションコンテキストで処理することを要求することを可能にします。言い換えれば、クライアントは、二つ以上のメディアストリームを設定して、単一の応答を待つ必要なしに再生することを要求することができます。これは、少なくとも1 RTTによるRTSPセッションの初期起動時間を高速化します。"
    },
    {
      "indent": 3,
      "text": "If a pipelined request builds on the successful completion of one or more prior requests, the requester must verify that all requests were executed as expected. A common example will be two SETUP requests and a PLAY request. In case one of the SETUP requests fails unexpectedly, the PLAY request can still be successfully executed. However, the resulting presentation will not be as expected by the requesting client, as only a single media instead of two will be played. In this case, the client can send a PAUSE request, correct the failing SETUP request, and then request it be played.",
      "ja": "パイプライン化された要求は、1つまたは複数の前の要求が正常に完了の上に構築した場合、要求者は、予想通り、すべての要求が実行されたことを確認する必要があります。一般的な例は、2つのSETUP要求とPLAY要求されます。 SETUP要求の一つが突然故障した場合には、PLAY要求がまだ正常に実行することができます。代わりに、2の唯一のメディアが再生されますよう、要求しているクライアントによってただし、期待どおり結果のプレゼンテーションができません。この場合、クライアントは、PAUSE要求を送信失敗SETUP要求を修正し、それを再生することを要求することができます。"
    },
    {
      "indent": 0,
      "text": "13. Method Definitions",
      "section_title": true,
      "ja": "13メソッド定義"
    },
    {
      "indent": 3,
      "text": "The method indicates what is to be performed on the resource identified by the Request-URI. The method name is case sensitive. New methods may be defined in the future. Method names MUST NOT start with a $ character (decimal 36) and MUST be a token as defined by the ABNF [RFC5234] in Section 20. The methods are summarized in Table 7.",
      "ja": "この方法は、Request-URIによって識別されたリソース上で実行されるかを示します。メソッド名は大文字と小文字が区別されます。新しい方法は、将来的に定義されてもよいです。メソッド名は、$文字（36進）で始めることはできませんと方法は、表7に要約されている項20にABNF [RFC5234]で定義されるようなトークンでなければなりません。"
    },
    {
      "indent": 4,
      "text": "+---------------+-----------+--------+-------------+-------------+\n| method        | direction | object | Server req. | Client req. |\n+---------------+-----------+--------+-------------+-------------+\n| DESCRIBE      | C -> S    | P,S    | recommended | recommended |\n|               |           |        |             |             |\n| GET_PARAMETER | C -> S    | P,S    | optional    | optional    |\n|               |           |        |             |             |\n|               | S -> C    | P,S    | optional    | optional    |\n|               |           |        |             |             |\n| OPTIONS       | C -> S    | P,S    | required    | required    |\n|               |           |        |             |             |\n|               | S -> C    | P,S    | optional    | optional    |\n|               |           |        |             |             |\n| PAUSE         | C -> S    | P,S    | required    | required    |\n|               |           |        |             |             |\n| PLAY          | C -> S    | P,S    | required    | required    |\n|               |           |        |             |             |\n| PLAY_NOTIFY   | S -> C    | P,S    | required    | required    |\n|               |           |        |             |             |\n| REDIRECT      | S -> C    | P,S    | optional    | required    |\n|               |           |        |             |             |\n| SETUP         | C -> S    | S      | required    | required    |\n|               |           |        |             |             |\n| SET_PARAMETER | C -> S    | P,S    | required    | optional    |\n|               |           |        |             |             |\n|               | S -> C    | P,S    | optional    | optional    |\n|               |           |        |             |             |\n| TEARDOWN      | C -> S    | P,S    | required    | required    |\n|               |           |        |             |             |\n|               | S -> C    | P      | required    | required    |\n+---------------+-----------+--------+-------------+-------------+",
      "raw": true
    },
    {
      "indent": 21,
      "text": "Table 7: Overview of RTSP Methods",
      "ja": "表7：RTSPメソッドの概要"
    },
    {
      "indent": 6,
      "text": "Note on Table 7: This table covers RTSP methods, their direction, and on what objects (P: presentation, S: stream) they operate. Further, it indicates whether a server or a client implementation is required (mandatory), recommended, or optional.",
      "ja": "表7に注意：それらが動作（ストリーム：プレゼンテーション、S P）このテーブルには、RTSPの方法、その方向、およびどのようなオブジェクト上をカバーしています。さらに、それは、サーバーまたはクライアントの実装は、（必須）必要な推奨、またはオプションされているかどうかを示します。"
    },
    {
      "indent": 6,
      "text": "Further note on Table 7: the GET_PARAMETER is optional. For example, a fully functional server can be built to deliver media without any parameters. However, SET_PARAMETER is required, i.e., mandatory to implement for the server; this is due to its usage for keep-alive. PAUSE is required because it is the only way of leaving the Play state without terminating the whole session.",
      "ja": "表7にさらに注意：GET_PARAMETERはオプションです。例えば、完全に機能するサーバは、パラメータを指定せずにメディアを配信するために構築することができます。しかし、SET_PARAMETERが必要である、すなわち、サーバのための実装が必須。これは、キープアライブのためのその使用によるものです。それは全体のセッションを終了せずにプレイ状態を残す唯一の方法であるため、PAUSEが必要です。"
    },
    {
      "indent": 3,
      "text": "If an RTSP agent does not support a particular method, it MUST return a 501 (Not Implemented) response code and the requesting RTSP agent, in turn, SHOULD NOT try this method again for the given agent/ resource combination. An RTSP proxy whose main function is to log or audit and not modify transport or media handling in any way MAY forward RTSP messages with unknown methods. Note that the proxy still needs to perform the minimal required processing, like adding the Via header.",
      "ja": "RTSPエージェントは、特定のメソッドをサポートしていない場合、それは501（実装されていない）応答コードと要求RTSPエージェントを返さなければならない、今度は、与えられたエージェント/リソースの組み合わせに対してこのメ​​ソッドを再度試みるべきではありません。その主な機能RTSPプロキシは、ログインするか、監査および未知の方法でRTSPメッセージを転送することができる任意の方法で取り扱う輸送やメディアを変更しないことです。プロキシが依然としてViaヘッダを追加するように、最小限の必要な処理を実行する必要があることに留意されたいです。"
    },
    {
      "indent": 0,
      "text": "13.1. OPTIONS",
      "section_title": true,
      "ja": "13.1.  OPTIONS"
    },
    {
      "indent": 3,
      "text": "The semantics of the RTSP OPTIONS method is similar to that of the HTTP OPTIONS method described in Section 4.3.7 of [RFC7231]. However, in RTSP, OPTIONS is bidirectional in that a client can send the request to a server and vice versa. A client MUST implement the capability to send an OPTIONS request and a server or a proxy MUST implement the capability to respond to an OPTIONS request. In addition to this \"MUST-implement\" functionality, clients, servers and proxies MAY provide support both for sending OPTIONS requests and for generating responses to the requests.",
      "ja": "RTSP OPTIONSメソッドのセマンティクスは、[RFC7231]のセクション4.3.7に記載したHTTP OPTIONSメソッドと同様です。しかし、RTSPでは、OPTIONSは、クライアントがサーバーとその逆にリクエストを送ることができるという点で、双方向です。クライアントはOPTIONS要求を送信する機能を実装しなければならないし、サーバやプロキシはOPTIONS要求に応答する機能を実装しなければなりません。これに加えて、「-実装しなければならない」機能、クライアント、サーバやプロキシはOPTIONS要求を送信すると、要求に対する応答を生成するための両方のサポートを提供することができます。"
    },
    {
      "indent": 3,
      "text": "An OPTIONS request may be issued at any time. Such a request does not modify the session state. However, it may prolong the session lifespan (see below). The URI in an OPTIONS request determines the scope of the request and the corresponding response. If the Request-URI refers to a specific media resource on a given host, the scope is limited to the set of methods supported for that media resource by the indicated RTSP agent. A Request-URI with only the host address limits the scope to the specified RTSP agent's general capabilities without regard to any specific media. If the Request-URI is an asterisk (\"*\"), the scope is limited to the general capabilities of the next hop (i.e., the RTSP agent in direct communication with the request sender).",
      "ja": "OPTIONS要求はいつでも発行することができます。このような要求には、セッション状態を変更しません。しかし、それは（下記参照）のセッションの寿命を延ばすことがあります。 OPTIONS要求におけるURIは、要求及び対応する応答の範囲を決定します。リクエストURIが指定されたホスト上の特定のメディアリソースを参照する場合、範囲は、示されRTSPエージェントによってそのメディア資源用にサポートされるメソッドの集合に制限されます。唯一のホストアドレスとのRequest-URIは、任意の特定のメディアに関係なく、指定されたRTSPエージェントの一般的な機能にスコープを制限します。リクエストURIがアスタリスク（「*」）である場合、範囲は次のホップ（リクエスト送信者と直接通信している、すなわち、RTSP剤）の一般的な機能に制限されます。"
    },
    {
      "indent": 3,
      "text": "Regardless of the scope of the request, the Public header MUST always be included in the OPTIONS response, listing the methods that are supported by the responding RTSP agent. In addition, if the scope of the request is limited to a media resource, the Allow header MUST be included in the response to enumerate the set of methods that are allowed for that resource unless the set of methods completely matches the set in the Public header. If the given resource is not available, the RTSP agent SHOULD return an appropriate response code, such as 3rr or 4xx. The Supported header MAY be included in the request to query the set of features that are supported by the responding RTSP agent.",
      "ja": "かかわらず、要求の範囲、公開ヘッダは常に応答RTSPエージェントによってサポートされているメソッドをリスト、OPTIONS応答に含まれなければなりません。請求の範囲は、メディアリソースに限定されている場合メソッドのセットが完全に公開ヘッダにセットと一致しない限り加えて、そのリソースのために許可されているメソッドのセットを列挙するためにヘッダが応答に含まれなければならない許可。所与のリソースが使用できない場合、RTSP剤は、3RRまたは4XXとして、適切な応答コードを返すべきです。サポートされているヘッダは、応答RTSPエージェントによってサポートされる機能のセットを照会する要求に含まれるかもしれません。"
    },
    {
      "indent": 3,
      "text": "The OPTIONS method can be used to keep an RTSP session alive. However, this is not the preferred way of session keep-alive signaling; see Section 18.49. An OPTIONS request intended for keeping alive an RTSP session MUST include the Session header with the associated session identifier. Such a request SHOULD also use the media or the aggregated control URI as the Request-URI.",
      "ja": "OPTIONSメソッドは、生きているRTSPセッションを維持するために使用することができます。しかし、これはセッションキープアライブシグナリングの好ましい方法ではありません。セクション18.49を参照してください。 RTSPセッションを生きている保つために意図OPTIONS要求は、関連するセッション識別子を有するセッションヘッダを含まなければなりません。そのような要求は、要求URIとして、培地または凝集制御URIを使用すべきです。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 5,
      "text": "C->S: OPTIONS rtsp://server.example.com RTSP/2.0 CSeq: 1 User-Agent: PhonyClient/1.2 Proxy-Require: gzipped-messages Supported: play.basic",
      "ja": "C-> S：OPTIONSのRTSP：//server.example.com RTSP / 2.0のCSeq：1つのUser-Agent：PhonyClient / 1.2プロキシが-必要：gzip圧縮され、メッセージはサポートされている：play.basic"
    },
    {
      "indent": 5,
      "text": "S->C: RTSP/2.0 200 OK CSeq: 1 Public: DESCRIBE, SETUP, TEARDOWN, PLAY, PAUSE, OPTIONS Supported: play.basic, setup.rtp.rtcp.mux, play.scale Server: PhonyServer/1.1",
      "ja": "S-> C：RTSP / 2.0 200 OKのCSeq：1公開：DESCRIBE、SETUP、TEARDOWN、PLAY、PAUSE、OPTIONSサポート：play.basic、setup.rtp.rtcp.mux、play.scaleサーバー：PhonyServer / 1.1"
    },
    {
      "indent": 3,
      "text": "Note that the \"gzipped-messages\" feature tag in the Proxy-Require is a fictitious feature.",
      "ja": "プロキシ要求で「gzip圧縮され、メッセージ」機能タグが架空の特徴であることに注意してください。"
    },
    {
      "indent": 0,
      "text": "13.2. DESCRIBE",
      "section_title": true,
      "ja": "13.2.  DESCRIBE"
    },
    {
      "indent": 3,
      "text": "The DESCRIBE method is used to retrieve the description of a presentation or media object from a server. The Request-URI of the DESCRIBE request identifies the media resource of interest. The client MAY include the Accept header in the request to list the description formats that it understands. The server MUST respond with a description of the requested resource and return the description in the message body of the response, if the DESCRIBE method request can be successfully fulfilled. The DESCRIBE reply-response pair constitutes the media initialization phase of RTSP.",
      "ja": "DESCRIBEメソッドは、サーバーからのプレゼンテーションやメディアオブジェクトの説明を取得するために使用されます。 DESCRIBEリクエストのRequest-URIは、関心のメディアリソースを識別します。クライアントは、それが理解できる記述形式の一覧を表示する要求にAcceptヘッダーを含むかもしれません。サーバーは、要求されたリソースの記述で応答し、DESCRIBEメソッド要求を正常に満たすことができるならば、レスポンスのメッセージ本文に記述を返さなければなりません。 DESCRIBE応答 - 応答ペアは、RTSPのメディア初期化フェーズを構成します。"
    },
    {
      "indent": 3,
      "text": "The DESCRIBE response SHOULD contain all media initialization information for the resource(s) that it describes. Servers SHOULD NOT use the DESCRIBE response as a means of media indirection by having the description point at another server; instead, using the 3rr responses is RECOMMENDED.",
      "ja": "DESCRIBE応答は、それが記述するリソース（複数可）のためのすべてのメディアの初期化情報を含むべきです。サーバは他のサーバに説明ポイントを有することによって、メディア間接手段としてDESCRIBE応答を使用するべきではありません。代わりに、3RRの応答を使用することをお勧めします。"
    },
    {
      "indent": 6,
      "text": "By forcing a DESCRIBE response to contain all media initialization information for the set of streams that it describes, and discouraging the use of DESCRIBE for media indirection, any looping problems can be avoided that might have resulted from other approaches.",
      "ja": "それは説明ストリームの集合のためのすべてのメディアの初期化情報を含むようにDESCRIBE応答を強制し、メディア・間接のためのDESCRIBEの使用を落胆することにより、任意のループの問題は、他のアプローチから生じた可能性があることを回避することができます。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 5,
      "text": "C->S: DESCRIBE rtsp://server.example.com/fizzle/foo RTSP/2.0 CSeq: 312 User-Agent: PhonyClient/1.2 Accept: application/sdp, application/example",
      "ja": "C-> S：DESCRIBE RTSP：//server.example.com/fizzle/foo RTSP / 2.0のCSeq：312のUser-Agent：PhonyClient / 1.2受け入れ：アプリケーション/ SDP、応用/実施例"
    },
    {
      "indent": 5,
      "text": "S->C: RTSP/2.0 200 OK CSeq: 312 Date: Thu, 23 Jan 1997 15:35:06 GMT Server: PhonyServer/1.1 Content-Base: rtsp://server.example.com/fizzle/foo/ Content-Type: application/sdp Content-Length: 358",
      "ja": "S-> C：RTSP / 2.0 200 OKのCSeq：312日付：木、1997年1月23日午後03時35分06秒GMTサーバー：PhonyServer / 1.1のContent-ベース：RTSP：//server.example.com/fizzle/foo/コンテンツ - タイプ：アプリケーション/ SDPコンテンツの長さ：358"
    },
    {
      "indent": 11,
      "text": "v=0\no=MNobody 2890844526 2890842807 IN IP4 192.0.2.46\ns=SDP Seminar\ni=A Seminar on the session description protocol\nu=http://www.example.com/lectures/sdp.ps\ne=seminar@example.com (Seminar Management)\nc=IN IP4 0.0.0.0\na=control:*\nt=2873397496 2873404696\nm=audio 3456 RTP/AVP 0\na=control:audio\nm=video 2232 RTP/AVP 31\na=control:video",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Media initialization is a requirement for any RTSP-based system, but the RTSP specification does not dictate that this is required to be done via the DESCRIBE method. There are three ways that an RTSP client may receive initialization information:",
      "ja": "メディアの初期化は、任意のRTSPベースのシステムのための必要条件であるが、RTSP仕様では、これはDESCRIBEメソッドを介して実行する必要があることを規定していません。 RTSPクライアントが初期化情報を受け取ることができる3つの方法があります。"
    },
    {
      "indent": 3,
      "text": "o via an RTSP DESCRIBE request",
      "ja": "RTSP要求をDESCRIBE経由O"
    },
    {
      "indent": 3,
      "text": "o via some other protocol (HTTP, email attachment, etc.)",
      "ja": "いくつかの他のプロトコル（HTTP、電子メールの添付ファイルなど）を介してO"
    },
    {
      "indent": 3,
      "text": "o via some form of user interface",
      "ja": "ユーザーインターフェースのいくつかのフォームを介してO"
    },
    {
      "indent": 3,
      "text": "If a client obtains a valid description from an alternate source, the client MAY use this description for initialization purposes without issuing a DESCRIBE request for the same media. The client should use any MTag to either validate the presentation description or make the session establishment conditional on being valid.",
      "ja": "クライアントが別のソースからの有効な説明を取得した場合、クライアントは同じメディアのためのDESCRIBE要求を発行せずに、初期化の目的のために、この記述を使用するかもしれません。クライアントは、プレゼンテーション記述を検証したり、有効なものでセッション確立を条件付きにするか任意のMTAGを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "It is RECOMMENDED that minimal servers support the DESCRIBE method, and highly recommended that minimal clients support the ability to act as \"helper applications\" that accept a media initialization file from a user interface, or other means that are appropriate to the operating environment of the clients.",
      "ja": "最小限のサーバーがDESCRIBEメソッドをサポートすることを推奨し、非常に最小限のクライアントは、ユーザインターフェースから、メディアの初期化ファイルを受け入れる「ヘルパーアプリケーション」、またはの動作環境に適した他の手段として作用する能力をサポートすることをお勧めしますクライアント。"
    },
    {
      "indent": 0,
      "text": "13.3. SETUP",
      "section_title": true,
      "ja": "13.3. セットアップ"
    },
    {
      "indent": 3,
      "text": "The description below uses the following states in a protocol state machine that is related to a specific session when that session has been created. The state transitions are driven by protocol interactions. For additional information about the state machine, see Appendix B.",
      "ja": "以下の説明は、セッションが作成されたときに特定のセッションに関連するプロトコル状態マシンの次の状態を使用します。状態遷移は、プロトコル相互作用によって駆動されます。ステートマシンの詳細については、付録Bを参照してください。"
    },
    {
      "indent": 3,
      "text": "Init: Initial state. No session exists.",
      "ja": "初期化：初期状態。いいえセッションが存在しません。"
    },
    {
      "indent": 3,
      "text": "Ready: Session is ready to start playing.",
      "ja": "レディ：セッションの再生を開始する準備ができています。"
    },
    {
      "indent": 3,
      "text": "Play: Session is playing, i.e., sending media-stream data in the direction S->C.",
      "ja": "プレイ：セッションが再生されている、すなわち、方向にメディア・ストリーム・データを送信し、S-> C。"
    },
    {
      "indent": 3,
      "text": "The SETUP request for a URI specifies the transport mechanism to be used for the streamed media. The SETUP method may be used in two different cases, namely, creating an RTSP session and changing the transport parameters of media streams that are already set up. SETUP can be used in all three states, Init, Ready, and Play, to change the transport parameters. Additionally, Init and Ready can also be used for the creation of the RTSP session. The usage of the SETUP method in the Play state to add a media resource to the session is unspecified.",
      "ja": "URIのSETUP要求は、ストリーミングメディアに使用するトランスポート機構を指定します。 SETUPメソッドは、RTSPセッションを作成し、既に設定されているメディアストリームのトランスポートパラメータを変更する、即ち、二つの異なる場合に使用することができます。 SETUPは、トランスポートパラメータを変更するには、すべての3つの状態、初期化、準備に使用され、再生することができます。また、初期化と準備もRTSPセッションの作成に使用することができます。セッションにメディアリソースを追加するプレイ状態でSETUPメソッドの使用量が指定されていません。"
    },
    {
      "indent": 3,
      "text": "The Transport header, see Section 18.54, specifies the media-transport parameters acceptable to the client for data transmission; the response will contain the transport parameters selected by the server. This allows the client to enumerate, in descending order of preference, the transport mechanisms and parameters acceptable to it, so the server can select the most appropriate. It is expected that the session description format used will enable the client to select a limited number of possible configurations that are offered as choices to the server. All transport-related parameters SHALL be included in the Transport header; the use of other headers for this purpose is NOT RECOMMENDED due to middleboxes, such as firewalls or NATs.",
      "ja": "トランスポートヘッダ、セクション18.54参照は、データ伝送のためにクライアントに許容される媒体輸送パラメータを特定します。応答は、サーバによって選択されたトランスポートパラメータが含まれています。これは、サーバーが最も適切に選択できるように、クライアントは、嗜好、それに対して許容されるトランスポート機構およびパラメータの降順に列挙することを可能にします。使用されるセッション記述形式は、サーバーへの選択肢として提供されている可能な構成の限られた数を選択するようにクライアントを有効にすることが期待されます。すべての輸送関連パラメータは、トランスポート・ヘッダに含めなければなりません。この目的のために他のヘッダの使用は、そのようなファイアウォールやNATのよう中間箱、することは推奨されません。"
    },
    {
      "indent": 3,
      "text": "For the benefit of any intervening firewalls, a client MUST indicate the known transport parameters, even if it has no influence over these parameters, for example, where the server advertises a fixed-multicast address as destination.",
      "ja": "介在するファイアウォールの利益のために、クライアントは、サーバが宛先として固定されたマルチキャストアドレスをアドバタイズたとえば、のために、これらのパラメータに対して何ら影響を与えない場合でも、知られているトランスポートパラメータを指定する必要があります。"
    },
    {
      "indent": 6,
      "text": "Since SETUP includes all transport initialization information, firewalls and other intermediate network devices (which need this information) are spared the more arduous task of parsing the DESCRIBE response, which has been reserved for media initialization.",
      "ja": "SETUPは、すべてのトランスポート初期化情報が含まれているので、ファイアウォール（この情報を必要とする）は、他の中間ネットワークデバイスは、メディアの初期化のために予約されたDESCRIBE応答を解析するより困難なタスクを免れています。"
    },
    {
      "indent": 3,
      "text": "The client MUST include the Accept-Ranges header in the request, indicating all supported unit formats in the Range header. This allows the server to know which formats it may use in future session-related responses, such as a PLAY response without any range in the request. If the client does not support a time format necessary for the presentation, the server MUST respond using 456 (Header Field Not Valid for Resource) and include the Accept-Ranges header with the range unit formats supported for the resource.",
      "ja": "クライアントが受け入れ-範囲はRangeヘッダ内のすべてのサポートされているユニットのフォーマットを示す、要求のヘッダ含まなければなりません。これは、サーバがそのような要求の中の任意の範囲なしPLAY応答として、将来のセッション関連の応答に使用することができますフォーマットかを知ることができます。クライアントは、プレゼンテーションのために必要な時間形式をサポートしていない場合、サーバは456（リソースに対して有効でないヘッダーフィールド）を使用して対応し、資源のためにサポートされている範囲の単位形式でヘッダーにAccept-範囲を含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "In a SETUP response, the server MUST include the Accept-Ranges header (see Section 18.5) to indicate which time formats are acceptable to use for this media resource.",
      "ja": "SETUP応答において、サーバは、フォーマットは、このメディアリソースに対して使用することが許容される時間を示すために（セクション18.5を参照）を受け入れ、範囲ヘッダを含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "The SETUP 200 OK response MUST include the Media-Properties header (see Section 18.29). The combination of the parameters of the Media-Properties header indicates the nature of the content present in the session (see also Section 4.7). For example, a live stream with time shifting is indicated by",
      "ja": "SETUP 200 OK応答は、メディアプロパティヘッダ（セクション18.29を参照）を含める必要があります。メディアプロパティヘッダのパラメータの組み合わせが（セクション4.7を参照）セッション中に存在するコンテンツの性質を示しています。例えば、時間シフトとライブストリームはによって示され"
    },
    {
      "indent": 3,
      "text": "o Random access set to Random-Access,",
      "ja": "Oランダムアクセスに設定されたランダムアクセス、"
    },
    {
      "indent": 3,
      "text": "o Content Modifications set to Time-Progressing, and",
      "ja": "O含有量の変更は、タイム進むとに設定され、"
    },
    {
      "indent": 3,
      "text": "o Retention set to Time-Duration (with specific recording window time value).",
      "ja": "O保持は、（特定の記録ウィンドウ時間値で）時間期間に設定しました。"
    },
    {
      "indent": 3,
      "text": "The SETUP 200 OK response MUST include the Media-Range header (see Section 18.30) if the media is Time-Progressing.",
      "ja": "メディアは時間進んでいる場合にはSETUP 200 OK応答は、（セクション18.30を参照）メディア-Rangeヘッダを含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "A basic example for SETUP:",
      "ja": "SETUPのための基本的な例："
    },
    {
      "indent": 5,
      "text": "C->S: SETUP rtsp://example.com/foo/bar/baz.rm RTSP/2.0 CSeq: 302 Transport: RTP/AVP;unicast;dest_addr=\":4588\"/\":4589\", RTP/AVP/TCP;unicast;interleaved=0-1 Accept-Ranges: npt, clock User-Agent: PhonyClient/1.2",
      "ja": "C-> S：SETUPのRTSP：//example.com/foo/bar/baz.rm RTSP / 2.0のCSeq：302トランスポート：RTP / AVP;ユニキャスト; dest_addrは= \"4588\" / \"4589\"、RTP / AVP / TCP;ユニキャスト、インターリーブされた= 0-1のAccept-範囲：NPT、クロックのUser-Agent：PhonyClient / 1.2"
    },
    {
      "indent": 5,
      "text": "S->C: RTSP/2.0 200 OK CSeq: 302 Date: Thu, 23 Jan 1997 15:35:06 GMT Server: PhonyServer/1.1 Session: QKyjN8nt2WqbWw4tIYof52;timeout=60 Transport: RTP/AVP;unicast;dest_addr=\"192.0.2.53:4588\"/ \"192.0.2.53:4589\"; src_addr=\"198.51.100.241:6256\"/ \"198.51.100.241:6257\"; ssrc=2A3F93ED Accept-Ranges: npt Media-Properties: Random-Access=3.2, Time-Progressing, Time-Duration=3600.0 Media-Range: npt=0-2893.23",
      "ja": "S-> C：RTSP / 2.0 200 OKのCSeq：302日付：木、1997年1月23日午後03時35分06秒GMTサーバー：PhonyServer / 1.1セッション：QKyjN8nt2WqbWw4tIYof52;タイムアウト= 60トランスポート：RTP / AVP;ユニキャスト; dest_addrは= \"192.0 .2.53：4588\" / \"192.0.2.53:4589\"。 src_addrを= \"198.51.100.241:6256\" / \"198.51.100.241:6257\"。 SSRC = 2A3F93EDは受け入れ-範囲を：NPTメディア・プロパティ：ランダム・アクセス= 3.2、時間進み、タイム期間= 3600.0メディアレンジ：NPT = 0から2893.23"
    },
    {
      "indent": 3,
      "text": "In the above example, the client wants to create an RTSP session containing the media resource \"rtsp://example.com/foo/bar/baz.rm\". The transport parameters acceptable to the client are either RTP/AVP/ UDP (UDP per default) to be received on client port 4588 and 4589 at the address the RTSP setup connection comes from or RTP/AVP interleaved on the RTSP control channel. The server selects the RTP/AVP/UDP transport and adds the address and ports it will send and receive RTP and RTCP from, and the RTP SSRC that will be used by the server.",
      "ja": "上記の例では、クライアントは、メディアリソース「：//example.com/foo/bar/baz.rm RTSP」を含むRTSPセッションを作成したいと考えています。クライアントへの許容可能なトランスポートパラメータは、RTP / AVP / UDP（デフォルトあたりのUDP）がアドレスにクライアントポート4588と4589で受信されるべきであるのいずれかRTSPのセットアップ接続はから来ているか、RTSP制御チャネルのインターリーブされたRTP / AVP。サーバは、RTP / AVP / UDPトランスポートを選択し、それを送信および受信RTPとRTCPをから、サーバによって使用されるRTP SSRCますアドレスとポートを追加します。"
    },
    {
      "indent": 3,
      "text": "The server MUST generate a session identifier in response to a successful SETUP request unless a SETUP request to a server includes a session identifier or a Pipelined-Requests header referencing an existing session context. In that latter case, the server MUST bundle this SETUP request into the existing session (aggregated session) or return a 459 (Aggregate Operation Not Allowed) error code (see Section 17.4.23). An aggregate control URI MUST be used to control an aggregated session. This URI MUST be different from the stream control URIs of the individual media streams included in the aggregate (see Section 13.4.2 for aggregated sessions and for the particular URIs see Appendix D.1.1). The aggregate control URI is to be specified by the session description if the server supports aggregated control and aggregated control is desired for the session.",
      "ja": "サーバにSETUP要求は、セッション識別子、または既存のセッションコンテキストを参照するパイプライン・リクエストヘッダが含まれていない限り、サーバは、成功したSETUP要求に応答して、セッション識別子を生成しなければなりません。後者の場合、サーバは、既存のセッション（セッション集約）には、このSETUP要求をバンドルまたは459（集約演算不可）エラーコード（セクション17.4.23参照）を返さなければなりません。凝集制御URIは、集約セッションを制御するために使用されなければなりません。このURIは、ストリームが集計に含まれる個々のメディアのストリーム制御のURIは異なっている必要があり（付録D.1.1参照アグリゲートされたセッションのための特定のURIのセクション13.4.2を参照）。サーバは、集約制御をサポートし、凝集制御がセッションのために所望される場合、集約制御URIは、セッション記述によって指定されます。"
    },
    {
      "indent": 3,
      "text": "However, even if aggregated control is offered, the client MAY choose not to set up the session in aggregated control. If an aggregate control URI is not specified in the session description, it is normally an indication that non-aggregated control should be used.",
      "ja": "しかし、集約された制御が提供されていても、クライアントが集約されたコントロールでセッションを設定しないこともできます。凝集制御URIをセッション記述に指定されていない場合、通常は非凝集制御が使用されるべきであることの指標です。"
    },
    {
      "indent": 3,
      "text": "The SETUP of media streams in an aggregate that has not been given an aggregated control URI is unspecified.",
      "ja": "集約された制御URIを与えられていない集合体におけるメディアストリームの設定が指定されていません。"
    },
    {
      "indent": 6,
      "text": "While the session ID sometimes carries enough information for aggregate control of a session, the aggregate control URI is still important for some methods such as SET_PARAMETER where the control URI enables the resource in question to be easily identified. The aggregate control URI is also useful for proxies, enabling them to route the request to the appropriate server, and for logging, where it is useful to note the actual resource on which a request was operating.",
      "ja": "セッションIDは、時にはセッションの集合制御のための十分な情報を搬送しながら、凝集制御URIは、依然として制御URIを容易に識別することが問題のリソースを有効にし、このようなSET_PARAMETERのようないくつかの方法のために重要です。集約コントロールURIは、ルートに適切なサーバへ、そして要求が動作された実際のリソースを注意することは有益である、ロギング、要求をそれらを有効にする、また、プロキシのために有用です。"
    },
    {
      "indent": 3,
      "text": "A session will exist until it is either removed by a TEARDOWN request or is timed out by the server. The server MAY remove a session that has not demonstrated liveness signs from the client(s) within a certain timeout period. The default timeout value is 60 seconds; the server MAY set this to a different value and indicate so in the timeout field of the Session header in the SETUP response. For further discussion, see Section 18.49. Signs of liveness for an RTSP session include any RTSP requests from a client that contain a Session header with the ID for that session, as well as RTCP sender or receiver reports if RTP is used to transport the underlying media stream. RTCP sender reports may, for example, be received in session where the server is invited into a conference session and are thus valid as a liveness indicator.",
      "ja": "それはTEARDOWN要求によって除去されるか、またはサーバーによってタイムアウトするまでのセッションが存在します。サーバーは、特定のタイムアウト時間内にクライアント（複数可）からのライブネス兆候を実証していないセッションを削除することができます。デフォルトのタイムアウト値は60秒です。サーバは異なる値に設定し、セットアップ応答のセッションヘッダのタイムアウトフィールドにそう示すかもしれ。さらなる議論については、項18.49を参照してください。 RTPは、基礎となるメディアストリームを転送するために使用されている場合RTSPセッションのための生存性の兆候はどのそのセッションのIDを持つSessionヘッダーが含まれているクライアントからのRTSP要求だけでなく、RTCPの送信者または受信者のレポートが含まれています。 RTCP送信者レポートは、例えば、サーバは会議セッションに招待され、これ生存性の指標として有効であるされたセッションで受信することができます。"
    },
    {
      "indent": 3,
      "text": "If a SETUP request on a session fails for any reason, the session state, as well as transport and other parameters for associated streams, MUST remain unchanged from their values as if the SETUP request had never been received by the server.",
      "ja": "セッションのSETUP要求が何らかの理由で、セッションの状態だけでなく、輸送および関連するストリームの他のパラメータのために失敗した場合SETUP要求がサーバによって受信されていなかったかのように、それらの値から変わらないしなければなりません。"
    },
    {
      "indent": 0,
      "text": "13.3.1. Changing Transport Parameters",
      "section_title": true,
      "ja": "13.3.1. トランスポートパラメータの変更"
    },
    {
      "indent": 3,
      "text": "A client MAY issue a SETUP request for a stream that is already set up or playing in the session to change transport parameters, which a server MAY allow. If it does not allow the changing of parameters, it MUST respond with error 455 (Method Not Valid in This State). The reasons to support changing transport parameters include allowing application-layer mobility and flexibility to utilize the best available transport as it becomes available. If a client receives a 455 error when trying to change transport parameters while the server is in Play state, it MAY try to put the server in Ready state using PAUSE before issuing the SETUP request again. If that also fails, the changing of transport parameters will require that the client perform a TEARDOWN of the affected media and then set it up again. For an aggregated session, not tearing down all the media at the same time will avoid the creation of a new session.",
      "ja": "クライアントが既に設定またはサーバーが可能トランスポート・パラメータを変更するセッションで再生しているストリームのSETUP要求を発行することができます。それはパラメータの変更を許可しない場合は、エラー455（この状態では有効な方法ではない）で応じなければなりません。変更トランスポート・パラメータをサポートするための理由は、それが利用可能になるよう最善の使用可能なトランスポートを利用するアプリケーション層の機動性と柔軟性があります。サーバがプレイ状態にある間トランスポートパラメータを変更しようとしたとき、クライアントは455エラーを受信した場合、再びSETUP要求を発行する前にPAUSEを使用して準備完了状態にサーバーを配置しようとするかもしれません。それも失敗した場合、トランスポートパラメータの変更は、クライアントが影響を受けたメディアのTEARDOWNを実施することを要求し、再度それを設定します。集約されたセッションでは、新しいセッションの作成を回避することと同時に、すべてのメディアを取りこわしません。"
    },
    {
      "indent": 3,
      "text": "All transport parameters MAY be changed. However, the primary usage expected is to either change the transport protocol completely, like switching from Interleaved TCP mode to UDP or vice versa, or to change the delivery address.",
      "ja": "すべてのトランスポートパラメータを変更してもよいです。しかし、予想される主な用途は、UDPまたはその逆にインターリーブTCPモードから切り替えるように、完全にトランスポートプロトコルを変更するか、または送達アドレスを変更することです。"
    },
    {
      "indent": 3,
      "text": "In a SETUP response for a request to change the transport parameters while in Play state, the server MUST include the Range header to indicate at what point the new transport parameters will be used. Further, if RTP is used for delivery, the server MUST also include the RTP-Info header to indicate at what timestamp and RTP sequence number the change will take place. If both RTP-Info and Range are included in the response, the \"rtp_time\" parameter and start point in the Range header MUST be for the corresponding time, i.e., be used in the same way as for PLAY to ensure the correct synchronization information is available.",
      "ja": "再生状態にしながら、トランスポートパラメータを変更する要求のためのSETUP応答で、サーバは、新しいトランスポートパラメータが使用されるかの点で示すRangeヘッダを含まなければなりません。 RTPは、配信のために使用されている場合また、サーバーは、変更が行われるか、タイムスタンプとRTPシーケンス番号で示すために、RTP-Infoヘッダーを含まなければなりません。 RTP-INFOと範囲の両方は、応答に含まれる「rtp_time」パラメータとRangeヘッダ内のポイントを開始している場合に相当する時間でなければなりません、すなわち、情報が正しい同期を確実にするPLAYと同じ方法で使用することが利用可能。"
    },
    {
      "indent": 3,
      "text": "If the transport-parameters change that happened while in Play state results in a change of synchronization-related information, for example, changing RTP SSRC, the server MUST include the necessary synchronization information in the SETUP response. However, the server SHOULD avoid changing the synchronization information if possible.",
      "ja": "同期関連情報の変更に再生状態の結果でながらRTP SSRCを変化させる、例えば、起こったトランスポートパラメータ変更した場合、サーバは、SETUP応答に必要な同期情報を含まなければなりません。ただし、サーバーは、可能な場合には、同期情報を変更することは避けるべきです。"
    },
    {
      "indent": 0,
      "text": "13.4. PLAY",
      "section_title": true,
      "ja": "13.4. 遊びます"
    },
    {
      "indent": 3,
      "text": "This section describes the usage of the PLAY method in general, for aggregated sessions, and in different usage scenarios.",
      "ja": "このセクションでは、一般に、アグリゲートされたセッションのために、異なる使用シナリオで再生法の使用を記載しています。"
    },
    {
      "indent": 0,
      "text": "13.4.1. General Usage",
      "section_title": true,
      "ja": "13.4.1. 一般的な使用法"
    },
    {
      "indent": 3,
      "text": "The PLAY method tells the server to start sending data via the mechanism specified in SETUP and which part of the media should be played out. PLAY requests are valid when the session is in Ready or Play state. A PLAY request MUST include a Session header to indicate to which session the request applies.",
      "ja": "PLAY方法は、メディアの一部が出て再生される必要があるSETUPで指定されたメカニズムとこれを介してデータの送信を開始するようにサーバに指示します。セッションが準備完了または再生状態にあるとき、PLAY要求が有効です。 PLAY要求は、要求が適用されるセッションに示すために、セッション・ヘッダを含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "Upon receipt of the PLAY request, the server MUST position the normal play time to the beginning of the range specified in the received Range header, within the limits of the media resource and in accordance with the Seek-Style header (Section 18.47). It MUST deliver stream data until the end of the range if given, until a new PLAY request is received, until a PAUSE request (Section 13.5) is received, or until the end of the media is reached. If no Range header is present in the PLAY request, the server SHALL play from current pause point until the end of media. The pause point defaults at session start to the beginning of the media. For media that is time-progressing and has no retention, the pause point will always be set equal to NPT \"now\", i.e., the current delivery point. The pause point may also be set to a particular point in the media by the PAUSE method; see Section 13.6. The pause point for media that is currently playing is equal to the current media position. For time-progressing media with time-limited retention, if the pause point represents a position that is older than what is retained by the server, the pause point will be moved to the oldest retained position.",
      "ja": "PLAY要求を受信すると、サーバは、メディアリソースの制限内シークスタイルヘッダ（セクション18.47）に従って、受信されたRangeヘッダで指定された範囲の先頭に通常再生時刻を配置しなければなりません。それが与えられた場合、新しいPLAY要求が受信されるまで一時停止要求（セクション13.5）が受信されるまで、範囲の端までストリームデータを供給しなければならない、またはメディアの端が到達するまで。何Rangeヘッダは、PLAY要求に存在しない場合、サーバはメディアの終わりまで、現在の一時停止点から再生SHALL。セッションの一時停止ポイントのデフォルトは、メディアの先頭に開始します。時間進行していると全く保持を有していないメディアの場合、一時停止点は、常にNPT「今」、すなわち、現在の配信ポイントに等しく設定されます。一時停止点もPAUSE法により培地中の特定の点に設定してもよいです。 13.6節を参照してください。現在再生中のメディアの一時停止ポイントは、現在のメディアの位置と同じです。時間進行し、一時停止ポイントは、サーバーによって保持されているものより古い位置を表す場合、期間限定の保持とメディアをするために、一時停止ポイントは、最も古い保持位置に移動されます。"
    },
    {
      "indent": 3,
      "text": "What range values are valid depends on the type of content. For content that isn't time-progressing, the range value is valid if the given range is part of any media within the aggregate. In other words, the valid media range for the aggregate is the union of all of the media components in the aggregate. If a given range value points outside of the media, the response MUST be the 457 (Invalid Range) error code and include the Media-Range header (Section 18.30) with the valid range for the media. Except for time-progressing content where the client requests a start point prior to what is retained, the start point is adjusted to the oldest retained content. For a start point that is beyond the media front edge, i.e., beyond the current value for \"now\", the server SHALL adjust the start value to the current front edge. The Range header's stop point value may point beyond the current media edge. In that case, the server SHALL deliver media from the requested (and possibly adjusted) start point until the first of either the provided stop point or the end of the media. Please note that if one simply wants to play from a particular start point until the end of media, using a Range header with an implicit stop point is RECOMMENDED.",
      "ja": "どのような範囲の値が有効なコンテンツの種類によって異なります。所定の範囲は、集約内の任意のメディアの一部である場合、時間進行していないコンテンツの場合、範囲の値が有効です。つまり、集約のための有効なメディアの範囲は、集約内のメディアコンポーネントのすべての労働組合です。与えられた範囲の値のポイントメディアの外場合、応答は、457（無効な範囲）のエラーコードであるとメディアの有効範囲を有するメディアRangeヘッダ（セクション18.30）を含まなければなりません。クライアントが保持されているものに先立って開始点を要求した時、進んでコンテンツを除き、開始点が保持された最も古いコンテンツに調整されています。メディア前縁を超えている開始点のために、即ち、「今」の現在の値を超えて、サーバは、現在の前縁に開始値を調整するものとします。 Rangeヘッダのストップポイント値は、現在のメディア縁を越えて指してもよいです。その場合、サーバは、提供停止点または媒体のいずれかの端の最初まで開始点要求（およびおそらく調整）からメディアを引き渡さなければなりません。 1は、単に暗黙の停止点を持つRangeヘッダを使用して、メディアの終わりまで、特定の開始点から再生したい場合に推奨されていることに注意してください。"
    },
    {
      "indent": 3,
      "text": "If a client requests to start playing at the end of media, either explicitly with a Range header or implicitly with a pause point that is at the end of media, a 457 (Invalid Range) error MUST be sent and include the Media-Range header (Section 18.30). It is specified below that the Range header also must be included in the response and that it will carry the pause point in the media, in the case of the session being in Ready State. Note that this also applies if the pause point or requested start point is at the beginning of the media and a Scale header (Section 18.46) is included with a negative value (playing backwards).",
      "ja": "クライアントの要求が明示的にRangeヘッダまたは暗黙的にメディアの末尾にある一時停止ポイントで、メディアの最後に再生を開始する場合は、457（無効な範囲）エラーが送信され、メディア-Rangeヘッダを含めなければなりません（セクション18.30）。これは、Rangeヘッダは、応答に含まれなければならないことを下回ると、それが準備完了状態にあるセッションの場合、メディアに一時停止点を伝送することが規定されています。これはまた、一時停止点または要求された開始ポイントが負の値（逆方向再生）に含まれているメディアとスケールヘッダ（セクション18.46）の先頭にある場合に適用されることに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "For media with random access properties, a client may indicate which policy for start point selection the server should use. This is done by including the Seek-Style header (Section 18.47) in the PLAY",
      "ja": "ランダムアクセス性を有する媒体では、クライアントは、サーバが使用する開始点を選択するためのどの方針を示すことがあります。これはPLAYにシークスタイルヘッダ（セクション18.47）を含むことによって行われます"
    },
    {
      "indent": 3,
      "text": "request. The Seek-Style applied will affect the content of the Range header as it will be adjusted to indicate from what point the media actually is delivered.",
      "ja": "要求。メディアが実際に配信されているものポイントから指示するために調整されるように適用されるシークスタイルRangeヘッダの内容に影響を与えます。"
    },
    {
      "indent": 3,
      "text": "A client desiring to play the media from the beginning MUST send a PLAY request with a Range header pointing at the beginning, e.g., \"npt=0-\". If a PLAY request is received without a Range header and media delivery has stopped at the end, the server SHOULD respond with a 457 (Invalid Range) error response. In that response, the current pause point MUST be included in a Range header.",
      "ja": "最初からメディアを再生することを望むクライアントは、最初に指しRangeヘッダと、例えば、「0- = NPT」PLAY要求を送らなければなりません。 PLAY要求がRangeヘッダなしで受信され、メディア配信が終了時に停止している場合、サーバは457（無効レンジ）エラー応答で応答すべきです。それに応答して、現在の一時停止点がRangeヘッダに含まれなければなりません。"
    },
    {
      "indent": 3,
      "text": "All range specifiers in this specification allow for ranges with an implicit start point (e.g., \"npt=-30\"). When used in a PLAY request, the server treats this as a request to start or resume delivery from the current pause point, ending at the end time specified in the Range header. If the pause point is located later than the given end value, a 457 (Invalid Range) response MUST be returned.",
      "ja": "本明細書中のすべての範囲指定子は暗黙開始点と範囲を可能にする（例えば、「NPT = -30」）。場合サーバー扱いは、Rangeヘッダで指定された終了時間で終了、現在の一時停止ポイントから配信を開始または再開するための要求として、PLAY要求で使用されます。一時停止点が与えられ終了値よりも後に位置する場合、457（無効範囲）応答が返されなければなりません。"
    },
    {
      "indent": 3,
      "text": "The example below will play seconds 10 through 25. It also requests that the server deliver media from the first random access point prior to the indicated start point.",
      "ja": "以下の例では、それはまた、サーバーが前指示された開始点への最初のランダムアクセスポイントからメディアを配信することを要求した25を介し秒10を再生します。"
    },
    {
      "indent": 5,
      "text": "C->S: PLAY rtsp://audio.example.com/audio RTSP/2.0 CSeq: 835 Session: ULExwZCXh2pd0xuFgkgZJW Range: npt=10-25 Seek-Style: RAP User-Agent: PhonyClient/1.2",
      "ja": "C-> S：PLAYのRTSP：835セッション：：ULExwZCXh2pd0xuFgkgZJW範囲：RTSP / 2.0のCSeq //audio.example.com/audio NPT = 10-25-スタイルを探す：RAPユーザーエージェント：PhonyClient / 1.2"
    },
    {
      "indent": 3,
      "text": "Servers MUST include a Range header in any PLAY response, even if no Range header was present in the request. The response MUST use the same format as the request's Range header contained. If no Range header was in the request, the format used in any previous PLAY request within the session SHOULD be used. If no format has been indicated in a previous request, the server MAY use any time format supported by the media and indicated in the Accept-Ranges header in the SETUP request. It is RECOMMENDED that NPT is used if supported by the media.",
      "ja": "サーバーにはRangeヘッダが要求に存在しない場合でも、任意のPLAY応答にRangeヘッダを含まなければなりません。要求のRangeヘッダが含まれているように、応答は、同じフォーマットを使用しなければなりません。何Rangeヘッダが要求でなかった場合、セッション内の任意の以前のPLAY要求で使用されるフォーマットを使用すべきです。いかなるフォーマットが前の要求に示されていない場合、サーバは、SETUP要求のヘッダのAccept-範囲の媒体によって支持され、示された任意の時間フォーマットを使用してもよいです。メディアでサポートされている場合NPTを使用することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "For any error response to a PLAY request, the server's response depends on the current session state. If the session is in Ready state, the current pause point is returned using a Range header with the pause point as the explicit start point and an implicit stop point. For time-progressing content, where the pause-point moves with real-time due to limited retention, the current pause point is returned. For sessions in Play state, the current playout point and the remaining parts of the range request are returned. For any media with retention longer than 0 seconds, the currently valid Media-Range header SHALL also be included in the response.",
      "ja": "PLAY要求に任意のエラー応答のために、サーバの応答は、現在のセッションの状態に依存します。セッションが準備完了状態であれば、現在の一時停止ポイントは、明示的な開始点として一時停止ポイントと暗黙的な停止点とのRangeヘッダを使用して戻されます。一時停止点が原因限られた保持をリアルタイムで移動時間が進ん内容については、現在の一時停止ポイントが返されます。再生状態でセッションのために、現在の再生点と範囲要求の残りの部分が返されます。長い0秒以上保持したまますべてのメディアの場合は、現在有効なメディア-Rangeヘッダは、応答に含めなければなりません。"
    },
    {
      "indent": 3,
      "text": "A PLAY response MAY include a header carrying synchronization information. As the information necessary is dependent on the media-transport format, further rules specifying the header and its usage are needed. For RTP the RTP-Info header is specified, see Section 18.45, and used in the following example.",
      "ja": "PLAY応答は、同期情報を運ぶヘッダを含むかもしれません。必要な情報は、メディアトランスポートフォーマットに依存しているように、ヘッダとその使用方法を指定するさらなるルールが必要とされています。 RTPのためのRTP-Infoヘッダは、セクション18.45を参照して、指定され、以下の実施例で使用しました。"
    },
    {
      "indent": 3,
      "text": "Here is a simple example for a single audio stream where the client requests the media starting from 3.52 seconds and to the end. The server sends a 200 OK response with the actual play time, which is 10 ms prior (3.51), and the RTP-Info header that contains the necessary parameters for the RTP stack.",
      "ja": "ここでは、クライアントが3.52秒からと最後に起動メディアを要求し、単一のオーディオストリームのための簡単な例です。サーバは、10ミリ秒前で実際の再生時間、（3.51）、およびRTPスタックに必要なパラメータが含まれているRTP-Infoヘッダを有する200 OK応答を送信します。"
    },
    {
      "indent": 3,
      "text": "C->S: PLAY rtsp://example.com/audio RTSP/2.0 CSeq: 836 Session: ULExwZCXh2pd0xuFgkgZJW Range: npt=3.52- User-Agent: PhonyClient/1.2",
      "ja": "C-> S：PLAYのRTSP：//example.com/audio RTSP / 2.0のCSeq：836セッション：ULExwZCXh2pd0xuFgkgZJW範囲：NPT = 3.52-のUser-Agent：PhonyClient / 1.2"
    },
    {
      "indent": 3,
      "text": "S->C: RTSP/2.0 200 OK CSeq: 836 Date: Thu, 23 Jan 1997 15:35:06 GMT Server: PhonyServer/1.0 Range: npt=3.51-324.39 Seek-Style: First-Prior Session: ULExwZCXh2pd0xuFgkgZJW RTP-Info:url=\"rtsp://example.com/audio\" ssrc=0D12F123:seq=14783;rtptime=2345962545",
      "ja": "S-> C：RTSP / 2.0 200 OKのCSeq：836日付：木、1997年1月23日午後03時35分06秒GMTサーバー：PhonyServer / 1.0範囲：NPT = 3.51から324.39シークスタイルを：まず、前のセッションを：ULExwZCXh2pd0xuFgkgZJW RTP-インフォメーション：URL = \"RTSP：//example.com/audio\" SSRC = 0D12F123：SEQ = 14783; rtptime = 2345962545"
    },
    {
      "indent": 3,
      "text": "S->C: RTP Packet TS=2345962545 => NPT=3.51 Media duration=0.16 seconds",
      "ja": "S-> C：RTPパケットのTS = 2345962545 => NPT = 3.51メディア期間= 0.16秒"
    },
    {
      "indent": 3,
      "text": "The server replies with the actual start point that will be delivered. This may differ from the requested range if alignment of the requested range to valid frame boundaries is required for the media source. Note that some media streams in an aggregate may need to be delivered from even earlier points. Also, some media formats have a very long duration per individual data unit; therefore, it might be necessary for the client to parse the data unit, and select where to start. The server SHALL also indicate which policy it uses for selecting the actual start point by including a Seek-Style header.",
      "ja": "サーバが配信されます実際のスタートポイントで応答します。有効なフレーム境界に要求された範囲の位置合わせは、メディアソースのために必要とされる場合、これは要求された範囲と異なる場合があります。骨材の一部のメディアストリームも、以前のポイントから配信される必要があり得ることに留意されたいです。また、いくつかのメディアフォーマットは、個々のデータ単位あたりの非常に長い持続時間を有します。クライアントは、データユニットを解析し、開始する場所を選択するので、それが必要になる場合があります。サーバはまた、シークスタイルヘッダを含めることによって、実際のスタートポイントを選択するために使用するポリシーを示さなければなりません。"
    },
    {
      "indent": 3,
      "text": "In the following example, the client receives the first media packet that stretches all the way up and past the requested playtime. Thus, it is the client's decision whether to render to the user the time between 3.52 and 7.05 or to skip it. In most cases, it is probably most suitable not to render that time period.",
      "ja": "次の例では、クライアントがアップし、要求されたプレイタイムを過ぎてすべての道を広がって最初のメディアパケットを受信します。したがって、ユーザーに3.52と7.05の間の時間をレンダリングするか、それをスキップするかどうか、クライアントの決定です。ほとんどの場合、その期間をレンダリングしていない、おそらく最も適しています。"
    },
    {
      "indent": 3,
      "text": "C->S: PLAY rtsp://example.com/audio RTSP/2.0 CSeq: 836 Session: ZGGyCJOs8xaLkdNK2dmxQO Range: npt=7.05- User-Agent: PhonyClient/1.2",
      "ja": "C-> S：PLAYのRTSP：//example.com/audio RTSP / 2.0のCSeq：836セッション：ZGGyCJOs8xaLkdNK2dmxQO範囲：NPT = 7.05-のUser-Agent：PhonyClient / 1.2"
    },
    {
      "indent": 3,
      "text": "S->C: RTSP/2.0 200 OK CSeq: 836 Date: Thu, 23 Jan 1997 15:35:06 GMT Server: PhonyServer/1.0 Session: ZGGyCJOs8xaLkdNK2dmxQO Range: npt=3.52- Seek-Style: First-Prior RTP-Info:url=\"rtsp://example.com/audio\" ssrc=0D12F123:seq=14783;rtptime=2345962545",
      "ja": "S-> C：RTSP / 2.0 200 OKのCSeq：836日付：木、1997年1月23日午後03時35分06秒GMTサーバー：PhonyServer / 1.0セッション：ZGGyCJOs8xaLkdNK2dmxQO範囲：NPT = 3.52-シークスタイルを：まず、前RTP-情報：URL = \"RTSP：//example.com/audio\" SSRC = 0D12F123：SEQ = 14783; rtptime = 2345962545"
    },
    {
      "indent": 3,
      "text": "S->C: RTP Packet TS=2345962545 => NPT=3.52 Duration=4.15 seconds",
      "ja": "S-> C：RTPパケットのTS = 2345962545 => NPT = 3.52持続時間= 4.15秒"
    },
    {
      "indent": 3,
      "text": "After playing the desired range, the presentation does NOT change to the Ready state, media delivery simply stops. If it is necessary to put the stream into the Ready state, a PAUSE request MUST be issued. A PLAY request while the stream is still in the Play state is legal and can be issued without an intervening PAUSE request. Such a request MUST replace the current PLAY action with the new one requested, i.e., being handled in the same way as if as the request was received in Ready state. In the case that the range in the Range header has an implicit start time (\"-endtime\"), the server MUST continue to play from where it currently was until the specified endpoint. This is useful to change the end to at another point than in the previous request.",
      "ja": "所望の範囲を演奏した後、プレゼンテーションがReady状態に変更されません、メディア配信は、単純に停止します。それがReady状態にストリームを配置する必要がある場合は、PAUSE要求を発行する必要があります。ストリームがプレイ状態にある間、PLAY要求が合法で、介在PAUSE要求なしで発行することができます。そのような要求は、要求が準備完了状態で受信されたようかのように、すなわち、同じ方法で処理される要求された新しいもの、と現在の再生アクションを交換する必要があります。 Rangeヘッダにおける範囲は、暗黙的な開始時間を有する場合（「-endtime」）において、サーバは、現在指定されたエンドポイントまであった場所から再生し続けなければなりません。これは、前の要求よりも、別の時点での終了を変更することが有用です。"
    },
    {
      "indent": 3,
      "text": "The following example plays the whole presentation starting at SMPTE time code 0:10:20 until the end of the clip. Note: the RTP-Info headers have been broken into several lines, where subsequent lines start with whitespace as allowed by the syntax.",
      "ja": "次の例では、クリップの最後まで、SMPTEタイムコード0時10分20秒から始まる全体のプレゼンテーションを果たしています。注意：RTP-情報ヘッダは、構文によって許可され、その後の行は空白で始まる複数の行、に分割されています。"
    },
    {
      "indent": 3,
      "text": "C->S: PLAY rtsp://audio.example.com/twister.en RTSP/2.0 CSeq: 833 Session: N465Wvsv0cjUy6tLqINkcf Range: smpte=0:10:20- User-Agent: PhonyClient/1.2",
      "ja": "C-> S：PLAYのRTSP：//audio.example.com/twister.en RTSP / 2.0のCSeq：833セッション：N465Wvsv0cjUy6tLqINkcf範囲：SMPTE = 0：10：20-のUser-Agent：PhonyClient / 1.2"
    },
    {
      "indent": 3,
      "text": "S->C: RTSP/2.0 200 OK CSeq: 833 Date: Thu, 23 Jan 1997 15:35:06 GMT Session: N465Wvsv0cjUy6tLqINkcf Server: PhonyServer/1.0 Range: smpte=0:10:22-0:15:45 Seek-Style: Next RTP-Info:url=\"rtsp://example.com/twister.en\" ssrc=0D12F123:seq=14783;rtptime=2345962545",
      "ja": "S-> C：RTSP / 2.0 200 OKのCSeq：833日付：木、1997年1月23日は、夜3時35分06秒GMTセッション：N465Wvsv0cjUy6tLqINkcfサーバー：PhonyServer / 1.0範囲：SMPTE = 0：10：22-0：15：45は、シークスタイル：次RTP-情報：URL = \"RTSP：//example.com/twister.en\" SSRC = 0D12F123：SEQ = 14783; rtptime = 2345962545"
    },
    {
      "indent": 3,
      "text": "For playing back a recording of a live presentation, it may be desirable to use clock units:",
      "ja": "ライブプレゼンテーションの録画を再生するためには、クロック・ユニットを使用することが望ましいです。"
    },
    {
      "indent": 3,
      "text": "C->S: PLAY rtsp://audio.example.com/meeting.en RTSP/2.0 CSeq: 835 Session: N465Wvsv0cjUy6tLqINkcf Range: clock=19961108T142300Z-19961108T143520Z User-Agent: PhonyClient/1.2",
      "ja": "C-> S：PLAYのRTSP：//audio.example.com/meeting.en RTSP / 2.0のCSeq：835セッション：N465Wvsv0cjUy6tLqINkcf範囲：クロック= 19961108T142300Z-19961108T143520Zユーザーエージェント：PhonyClient / 1.2"
    },
    {
      "indent": 3,
      "text": "S->C: RTSP/2.0 200 OK CSeq: 835 Date: Thu, 23 Jan 1997 15:35:06 GMT Session: N465Wvsv0cjUy6tLqINkcf Server: PhonyServer/1.0 Range: clock=19961108T142300Z-19961108T143520Z Seek-Style: Next RTP-Info:url=\"rtsp://example.com/meeting.en\" ssrc=0D12F123:seq=53745;rtptime=484589019",
      "ja": "S-> C：RTSP / 2.0 200 OKのCSeq：835日付：木、1997年1月23日午後03時35分06秒GMTセッション：N465Wvsv0cjUy6tLqINkcfサーバー：PhonyServer / 1.0範囲：クロック= 19961108T142300Z-19961108T143520Zシークスタイルを：次のRTP-情報： URL = \"RTSP：//example.com/meeting.en\" SSRC = 0D12F123：SEQ = 53745; rtptime = 484589019"
    },
    {
      "indent": 0,
      "text": "13.4.2. Aggregated Sessions",
      "section_title": true,
      "ja": "13.4.2. アグリゲートされたセッション"
    },
    {
      "indent": 3,
      "text": "PLAY requests can operate on sessions controlling a single media stream and on aggregated sessions controlling multiple media streams.",
      "ja": "PLAY要求は、単一のメディアストリームを制御するセッションで、複数のメディアストリームを制御アグリゲートされたセッション上で動作することができます。"
    },
    {
      "indent": 3,
      "text": "In an aggregated session, the PLAY request MUST contain an aggregated control URI. A server MUST respond with a 460 error (Only Aggregate Operation Allowed) if the client PLAY Request-URI is for a single media. The media in an aggregate MUST be played in sync. If a client wants individual control of the media, it needs to use separate RTSP sessions for each media.",
      "ja": "集約されたセッションでは、PLAY要求は、集約制御URIを含まなければなりません。クライアントPLAYのRequest-URIは、単一のメディアのためであれば、サーバーが460エラーで応答しなければならない（のみ集計操作可）。集約内のメディアが同期して再生されなければなりません。クライアントは、メディアの個々の制御を望んでいるなら、それは各メディアに対して個別のRTSPセッションを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "For aggregated sessions where the initial SETUP request (creating a session) is followed by one or more additional SETUP requests, a PLAY request MAY be pipelined (Section 12) after those additional SETUP requests without awaiting their responses. This procedure can reduce the delay from the start of session establishment until media playout has started with one RTT. However, a client needs to be aware that using this procedure will result in the playout of the server state established at the time of processing the PLAY, i.e., after the processing of all the requests prior to the PLAY request in the pipeline. This state may not be the intended one due to failure of any of the prior requests. A client can easily determine this based on the responses from those requests. In case of failure, the client can halt the media playout using PAUSE and try to establish the intended state again before issuing another PLAY request.",
      "ja": "（セッションの作成）初期設定要求は、1つのまたは複数の追加の設定要求が続いているアグリゲートされたセッションのために、PLAY要求は、それらの応答を待たずに、これらの追加の設定要求後（セクション12）パイプライン化されるかもしれません。メディア再生が1 RTTで開始されるまでこの手順は、セッション確立の開始から遅延を低減することができます。ただし、クライアントは、パイプラインでのPLAY要求する前にすべての要求を処理した後、この手順を使用して、すなわち、PLAYを処理する時に設定し、サーバーの状態の再生につながることを認識する必要があります。この状態が原因前の要求のいずれかの障害のために意図された1ではないかもしれません。クライアントは、簡単にこれらの要求からの応答に基づいてこれを決定することができます。障害が発生した場合には、クライアントは、PAUSEを使用してメディア再生を停止し、別のPLAY要求を発行する前に、再び意図状態を確立しようとすることができます。"
    },
    {
      "indent": 0,
      "text": "13.4.3. Updating Current PLAY Requests",
      "section_title": true,
      "ja": "13.4.3. 現在のPLAY要求を更新"
    },
    {
      "indent": 3,
      "text": "Clients can issue PLAY requests while the stream is in Play state and thus updating their request.",
      "ja": "クライアントは、ストリームがプレイ状態にある間PLAY要求を発行するので、それらの要求を更新することができます。"
    },
    {
      "indent": 3,
      "text": "The important difference compared to a PLAY request in Ready state is the handling of the current play point and how the Range header in the request is constructed. The session is actively playing media and the play point will be moving, making the exact time a request will take effect hard to predict. Depending on how the PLAY header appears, two different cases exist: total replacement or continuation. A total replacement is signaled by having the first range specification have an explicit start value, e.g., \"npt=45-\" or \"npt=45-60\", in which case the server stops playout at the current playout point and then starts delivering media according to the Range header. This is equivalent to having the client first send a PAUSE and then a new PLAY request that isn't based on the pause point. In the case of continuation, the first range specifier has an implicit start point and an explicit stop value (Z), e.g., \"npt=-60\", which indicate that it MUST convert the range specifier being played prior to this PLAY request (X to Y) into (X to Z) and continue as if this was the request originally played. If the current delivery point is beyond the stop point, the server SHALL immediately pause delivery. As the request has been completed successfully, it shall be responded to with a 200 OK response. A PLAY_NOTIFY with end-of-stream is also sent to indicate the actual stop point. The pause point is set to the requested stop point.",
      "ja": "レディ状態でPLAY要求に比べて重要な相違点は、現在の再生ポイントの取り扱いとどのように要求でRangeヘッダが構築されています。セッションでは、積極的にメディアを再生しているプレイポイントは、要求が予測することは困難に有効になります正確な時間を作り、移動されます。 PLAYヘッダの表示方法に応じて、2つの異なるケースが存在する：総置換または継続。総置換は、明示的な開始値は、例えば、「NPT = 45-」または「NPT = 45-60」サーバは、現在の再生ポイントで再生を停止し、その場合には、配信開始している第1の範囲の仕様を有することによってシグナリングされますRangeヘッダによる媒体。これは、クライアントが最初にPAUSEして、一時停止ポイントに基づいていない新しいPLAY要求を送信持つと同等です。継続の場合には、第1の範囲指定は、暗黙的な開始点と明示的なストップ値（Z）、例えば、「NPT = -60」、それが範囲指定を変換しなければならないことを示し、このPLAY要求の前に再生されているが（持ちますZへ（X）へのYのX）、これは元々再生要求であったかのように続けます。現在の配信ポイントは、停止点を超えている場合、サーバーはすぐに配信を一時停止するものとします。要求が正常に完了したように、それは200 OK応答を返信されなければなりません。エンドオブストリームとPLAY_NOTIFYも実際の停止点を示すために送信されます。一時停止ポイントは、要求された停止点に設定されています。"
    },
    {
      "indent": 3,
      "text": "The following is an example of this behavior: The server has received requests to play ranges 10 to 15. If the new PLAY request arrives at the server 4 seconds after the previous one, it will take effect while the server still plays the first range (10-15). The server changes the current play to continue to 25 seconds, i.e., the equivalent single request would be PLAY with \"range: npt=10-25\".",
      "ja": "以下は、この動作の例である：サーバーは新しいPLAY要求が前の後にサーバ4秒で到着した場合、サーバーがまだ最初の範囲を（再生中に、それが有効になります15の範囲である10を再生するためのリクエストを受信しました10-15）。サーバーは、現在の再生、すなわち、同等の単一の要求は「：NPT = 10-25範囲」とPLAYになり、25秒に継続するために変更されます。"
    },
    {
      "indent": 5,
      "text": "C->S: PLAY rtsp://example.com/fizzle/foo RTSP/2.0 CSeq: 834 Session: apzA8LnjQ5KWTdw0kUkiRh Range: npt=10-15 User-Agent: PhonyClient/1.2",
      "ja": "C-> S：PLAY RTSP：//example.com/fizzle/foo RTSP / 2.0のCSeq：834セッション：apzA8LnjQ5KWTdw0kUkiRh範囲：NPT = 10-15のUser-Agent：PhonyClient / 1.2"
    },
    {
      "indent": 5,
      "text": "S->C: RTSP/2.0 200 OK CSeq: 834 Date: Thu, 23 Jan 1997 15:35:06 GMT Session: apzA8LnjQ5KWTdw0kUkiRh Server: PhonyServer/1.0 Range: npt=10-15 Seek-Style: Next RTP-Info:url=\"rtsp://example.com/fizzle/audiotrack\" ssrc=0D12F123:seq=5712;rtptime=934207921, url=\"rtsp://example.com/fizzle/videotrack\" ssrc=789DAF12:seq=57654;rtptime=2792482193",
      "ja": "S-> C：RTSP / 2.0 200 OKのCSeq：834日付：木、1997年1月23日午後03時35分06秒GMTセッション：apzA8LnjQ5KWTdw0kUkiRhサーバー：PhonyServer / 1.0範囲：NPT = 10-15シークスタイルを：次のRTP-情報： URL = \"RTSP：//example.com/fizzle/audiotrack\" SSRC = 0D12F123：SEQ = 5712; rtptime = 934207921、URL = \"RTSP：//example.com/fizzle/videotrack\" SSRC = 789DAF12：SEQ = 57654; rtptime = 2792482193"
    },
    {
      "indent": 5,
      "text": "C->S: PLAY rtsp://example.com/fizzle/foo RTSP/2.0 CSeq: 835 Session: apzA8LnjQ5KWTdw0kUkiRh Range: npt=-25 User-Agent: PhonyClient/1.2",
      "ja": "C-> S：PLAY RTSP：//example.com/fizzle/foo RTSP / 2.0のCSeq：835セッション：apzA8LnjQ5KWTdw0kUkiRh範囲：NPT = -25のUser-Agent：PhonyClient / 1.2"
    },
    {
      "indent": 5,
      "text": "S->C: RTSP/2.0 200 OK CSeq: 835 Date: Thu, 23 Jan 1997 15:35:09 GMT Session: apzA8LnjQ5KWTdw0kUkiRh Server: PhonyServer/1.0 Range: npt=14-25 Seek-Style: Next RTP-Info:url=\"rtsp://example.com/fizzle/audiotrack\" ssrc=0D12F123:seq=5712;rtptime=934239921, url=\"rtsp://example.com/fizzle/videotrack\" ssrc=789DAF12:seq=57654;rtptime=2792842193",
      "ja": "S-> C：RTSP / 2.0 200 OKのCSeq：835日付：木、1997年1月23日15時35分09秒GMTセッション：apzA8LnjQ5KWTdw0kUkiRhサーバー：PhonyServer / 1.0範囲：NPT = 14-25シークスタイルを：次のRTP-情報： URL = \"RTSP：//example.com/fizzle/audiotrack\" SSRC = 0D12F123：SEQ = 5712; rtptime = 934239921、URL = \"RTSP：//example.com/fizzle/videotrack\" SSRC = 789DAF12：SEQ = 57654; rtptime = 2792842193"
    },
    {
      "indent": 3,
      "text": "A common use of a PLAY request while in Play state is changing the scale of the media, i.e., entering or leaving fast forward or fast rewind. The client can issue an updating PLAY request that is either a continuation or a complete replacement, as discussed above this section. Below is an example of a client that is requesting a fast forward (scale = 2) without giving a stop point and then a change from fast forward to regular playout (scale = 1). In the second PLAY request, the time is set explicitly to be wherever the server currently plays out (npt=now-) and the server responds with the actual playback point where the new scale actually takes effect (npt=02:17:27.144-).",
      "ja": "一方、再生状態でPLAY要求の一般的な使用は、すなわち、入力や早送り残し又は早戻し、メディアのスケールを変えています。クライアントは、このセクションの上に述べたように、継続または完全な交換のどちらかで更新PLAY要求を発行することができます。以下停止点を与えることなく早送り（スケール= 2）、次いで、正規再生（スケール= 1）の早送りからの変更を要求しているクライアントの例です。 17：27.144-サーバーが現在（NPT = NOW-）を果たし、サーバが新しいスケールが実際に（NPTは= 02有効になり、実際の再生ポイントで応答どこ秒PLAY要求では、時間があることを明示的に設定されています）。"
    },
    {
      "indent": 5,
      "text": "C->S: PLAY rtsp://example.com/fizzle/foo RTSP/2.0 CSeq: 2034 Session: apzA8LnjQ5KWTdw0kUkiRh Range: npt=now-Scale: 2.0 User-Agent: PhonyClient/1.2",
      "ja": "C-> S：PLAYのRTSP：//example.com/fizzle/foo RTSP / 2.0のCSeq：2034セッション：apzA8LnjQ5KWTdw0kUkiRh範囲：NPT =今-スケール：2.0のUser-Agent：PhonyClient / 1.2"
    },
    {
      "indent": 5,
      "text": "S->C: RTSP/2.0 200 OK CSeq: 2034 Date: Thu, 23 Jan 1997 15:35:06 GMT Session: apzA8LnjQ5KWTdw0kUkiRh Server: PhonyServer/1.0 Range: npt=02:17:21.394- Seek-Style: Next Scale: 2.0 RTP-Info:url=\"rtsp://example.com/fizzle/audiotrack\" ssrc=0D12F123:seq=5712;rtptime=934207921, url=\"rtsp://example.com/fizzle/videotrack\" ssrc=789DAF12:seq=57654;rtptime=2792482193",
      "ja": "S-> C：RTSP / 2.0 200 OKのCSeq：2034日付：木、1997年1月23日15時35分06秒GMTセッション：apzA8LnjQ5KWTdw0kUkiRhサーバー：PhonyServer / 1.0範囲：NPT = 02：17：21.394-シークスタイルを：次のスケール：2.0 RTP-情報：URL = \"RTSP：//example.com/fizzle/audiotrack\" SSRC = 0D12F123：SEQ = 5712; rtptime = 934207921、URL = \"RTSP：//example.com/fizzle/videotrack\" SSRC = 789DAF12：配列= 57654; rtptime = 2792482193"
    },
    {
      "indent": 3,
      "text": "[playing in fast forward and now returning to scale = 1]",
      "ja": "[早送りで再生し、今= 1スケールに戻ります]"
    },
    {
      "indent": 5,
      "text": "C->S: PLAY rtsp://example.com/fizzle/foo RTSP/2.0 CSeq: 2035 Session: apzA8LnjQ5KWTdw0kUkiRh Range: npt=now-Scale: 1.0 User-Agent: PhonyClient/1.2",
      "ja": "C-> S：PLAYのRTSP：//example.com/fizzle/foo RTSP / 2.0のCSeq：2035セッション：apzA8LnjQ5KWTdw0kUkiRh範囲：NPT =今-スケール：1.0のUser-Agent：PhonyClient / 1.2"
    },
    {
      "indent": 5,
      "text": "S->C: RTSP/2.0 200 OK CSeq: 2035 Date: Thu, 23 Jan 1997 15:35:09 GMT Session: apzA8LnjQ5KWTdw0kUkiRh Server: PhonyServer/1.0 Range: npt=02:17:27.144- Seek-Style: Next Scale: 1.0 RTP-Info:url=\"rtsp://example.com/fizzle/audiotrack\" ssrc=0D12F123:seq=5712;rtptime=934239921, url=\"rtsp://example.com/fizzle/videotrack\" ssrc=789DAF12:seq=57654;rtptime=2792842193",
      "ja": "S-> C：RTSP / 2.0 200 OKのCSeq：2035日付：木、1997年1月23日午後03時三十五分09秒GMTセッション：apzA8LnjQ5KWTdw0kUkiRhサーバー：PhonyServer / 1.0範囲：NPT = 02：17：27.144-シークスタイルを：次のスケール：1.0 RTP-情報：URL = \"RTSP：//example.com/fizzle/audiotrack\" SSRC = 0D12F123：SEQ = 5712; rtptime = 934239921、URL = \"RTSP：//example.com/fizzle/videotrack\" SSRC = 789DAF12：配列= 57654; rtptime = 2792842193"
    },
    {
      "indent": 0,
      "text": "13.4.4. Playing On-Demand Media",
      "section_title": true,
      "ja": "13.4.4. オンデマンドメディアの再生"
    },
    {
      "indent": 3,
      "text": "On-demand media is indicated by the content of the Media-Properties header in the SETUP response when (see also Section 18.29):",
      "ja": "（また、セクション18.29を参照）場合、オンデマンドメディアは、SETUP応答にメディアプロパティヘッダの内容によって示されます。"
    },
    {
      "indent": 3,
      "text": "o the Random Access property is set to Random-Access;",
      "ja": "O・ランダム・アクセス・プロパティは、ランダムアクセスに設定されています。"
    },
    {
      "indent": 3,
      "text": "o the Content Modifications property is set to Immutable;",
      "ja": "プロパティは不変に設定されているコンテンツの変更O;"
    },
    {
      "indent": 3,
      "text": "o the Retention property is set to Unlimited or Time-Limited.",
      "ja": "O保持性は無制限またはTime-Limitedに設定されています。"
    },
    {
      "indent": 3,
      "text": "Playing on-demand media follows the general usage as described in Section 13.4.1.",
      "ja": "セクション13.4.1で説明したように、オンデマンドメディアを再生する一般的な使用法に従います。"
    },
    {
      "indent": 0,
      "text": "13.4.5. Playing Dynamic On-Demand Media",
      "section_title": true,
      "ja": "13.4.5. ダイナミックなオンデマンドメディアの再生"
    },
    {
      "indent": 3,
      "text": "Dynamic on-demand media is indicated by the content of the Media-Properties header in the SETUP response when (see also Section 18.29):",
      "ja": "（セクション18.29を参照）と、ダイナミックオンデマンドメディアは、SETUP応答のメディア・プロパティヘッダの内容によって示されます。"
    },
    {
      "indent": 3,
      "text": "o the Random Access property is set to Random-Access;",
      "ja": "O・ランダム・アクセス・プロパティは、ランダムアクセスに設定されています。"
    },
    {
      "indent": 3,
      "text": "o the Content Modifications property is set to Dynamic;",
      "ja": "プロパティがダイナミックに設定されているコンテンツの変更O;"
    },
    {
      "indent": 3,
      "text": "o the Retention property is set to Unlimited or Time-Limited.",
      "ja": "O保持性は無制限またはTime-Limitedに設定されています。"
    },
    {
      "indent": 3,
      "text": "Playing on-demand media follows the general usage as described in Section 13.4.1 as long as the media has not been changed.",
      "ja": "限り、メディアが変更されていないとして、セクション13.4.1で説明したように、オンデマンドメディアを再生する一般的な使用法に従います。"
    },
    {
      "indent": 3,
      "text": "There are two ways for the client to be informed about changes of media resources in Play state. The first being that the client will receive a PLAY_NOTIFY request with the Notify-Reason header set to media-properties-update (see Section 13.5.2). The client can use the value of the Media-Range header to decide further actions, if the Media-Range header is present in the PLAY_NOTIFY request. The second way is that the client issues a GET_PARAMETER request without a body but including a Media-Range header. The 200 OK response MUST include the current Media-Range header (see Section 18.30).",
      "ja": "プレイ状態にあるメディアリソースの変更について通知するためのクライアントのための2つの方法があります。最初のクライアントがメディアプロパティ更新（セクション13.5.2を参照）に設定通知-ReasonヘッダとPLAY_NOTIFY要求を受信することです。メディア-RangeヘッダがPLAY_NOTIFY要求に存在する場合、クライアントは、さらにアクションを決定するメディア-Rangeヘッダの値を使用することができます。第二の方法は、クライアントがなく、メディア-Rangeヘッダを含むボディなしGET_PARAMETER要求を発行ということです。 200 OK応答は、（セクション18.30を参照）は、現在のメディアRangeヘッダを含まなければなりません。"
    },
    {
      "indent": 0,
      "text": "13.4.6. Playing Live Media",
      "section_title": true,
      "ja": "13.4.6. ライブメディアの再生"
    },
    {
      "indent": 3,
      "text": "Live media is indicated by the content of the Media-Properties header in the SETUP response when (see also Section 18.29):",
      "ja": "ライブメディアをするとき（セクション18.29を参照してください）SETUP応答のメディア・プロパティヘッダの内容によって示されます。"
    },
    {
      "indent": 3,
      "text": "o the Random Access property is set to No-Seeking;",
      "ja": "O・ランダム・アクセス・プロパティは無探しているに設定されています。"
    },
    {
      "indent": 3,
      "text": "o the Content Modifications property is set to Time-Progressing;",
      "ja": "コンテンツの変更oをプロパティは、タイム進むとに設定されています。"
    },
    {
      "indent": 3,
      "text": "o the Retention property's Time-Duration is set to 0.0.",
      "ja": "O保持特性の時間持続時間は0.0に設定されています。"
    },
    {
      "indent": 3,
      "text": "For live media, the SETUP 200 OK response MUST include the Media-Range header (see Section 18.30).",
      "ja": "ライブメディアの場合は、SETUP 200 OK応答は、（セクション18.30を参照）メディア-Rangeヘッダを含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "A client MAY send PLAY requests without the Range header. If the request includes the Range header, it MUST use a symbolic value representing \"now\". For NPT, that range specification is \"npt=now-\". The server MUST include the Range header in the response, and it MUST indicate an explicit time value and not a symbolic value. In other words, \"npt=now-\" cannot be used in the response. Instead, the time since session start is recommended, expressed as an open interval, e.g., \"npt=96.23-\". An absolute time value (clock) for the corresponding time MAY be given, i.e., \"clock=20030213T143205Z-\". The Absolute Time format can only be used if the client has shown support for it using the Accept-Ranges header.",
      "ja": "クライアントは、RangeヘッダなしPLAY要求を送信することができます。リクエストがRangeヘッダを含む場合、それは「今」を表す記号値を使用しなければなりません。 NPTのために、その範囲の仕様は、 \"NOW- = NPT\" です。サーバが応答してRangeヘッダを含まなければなりません、そして、それは、明示的な時間値ではなく、シンボリック値を示さなければなりません。換言すれば、「NPT = NOW-」応答に使用することができません。代わりに、セッション開始が推奨されてからの時間は、開区間、例えば、「NPT = 96.23-」と表現しました。対応する時間の絶対時間値（クロック）、すなわち、「クロック= 20030213T143205Z-」を与えることができます。クライアントは、それが受け入れ-範囲のヘッダを使用するためのサポートを示している場合は絶対時間形式にのみ使用することができます。"
    },
    {
      "indent": 0,
      "text": "13.4.7. Playing Live with Recording",
      "section_title": true,
      "ja": "13.4.7. レコーディングとライブ演奏"
    },
    {
      "indent": 3,
      "text": "Certain media servers may offer recording services of live sessions to their clients. This recording would normally be from the beginning of the media session. Clients can randomly access the media between now and the beginning of the media session. This live media with recording is indicated by the content of the Media-Properties header in the SETUP response when (see also Section 18.29):",
      "ja": "一部のメディアサーバーはそのクライアントにライブセッションの記録サービスを提供することがあります。この記録は、通常、メディアセッションの最初からだろう。クライアントはランダムになりましたし、メディアセッションの開始との間でメディアにアクセスすることができます。記録を持つこのライブメディアは、SETUP応答する場合（セクション18.29を参照）におけるメディア・プロパティヘッダの内容によって示されます。"
    },
    {
      "indent": 3,
      "text": "o the Random Access property is set to Random-Access;",
      "ja": "O・ランダム・アクセス・プロパティは、ランダムアクセスに設定されています。"
    },
    {
      "indent": 3,
      "text": "o the Content Modifications property is set to Time-Progressing;",
      "ja": "コンテンツの変更oをプロパティは、タイム進むとに設定されています。"
    },
    {
      "indent": 3,
      "text": "o the Retention property is set to Time-Limited or Unlimited",
      "ja": "O保持性は期間限定または無制限に設定されています"
    },
    {
      "indent": 3,
      "text": "The SETUP 200 OK response MUST include the Media-Range header (see Section 18.30) for this type of media. For live media with recording, the Range header indicates the current delivery point in the media and the Media-Range header indicates the currently available media window around the current time. This window can cover recorded content in the past (seen from current time in the media) or recorded content in the future (seen from current time in the media). The server adjusts the delivery point to the requested border of the window. If the client requests a delivery point that is located outside the recording window, e.g., if the requested point is too far in the past, the server selects the oldest point in the recording. The considerations in Section 13.5.3 apply if a client requests delivery with scale (Section 18.46) values other than 1.0 (normal playback rate) while delivering live media with recording.",
      "ja": "SETUP 200 OK応答は、メディアのこのタイプのメディア-Rangeヘッダ（セクション18.30を参照）を含まなければなりません。レコーディングとライブメディアのために、Rangeヘッダは、メディアとメディアRangeヘッダは、現在時刻の周りに現在利用可能なメディアウィンドウを示しにおける現在の配信ポイントを示しています。このウィンドウには、（メディアに現在の時刻から見て）過去に記録されたコンテンツまたは（メディアに現在の時刻から見て）将来的に記録されたコンテンツをカバーすることができます。サーバは、ウィンドウの要求された国境に配信ポイントを調整します。クライアントが要求されたポイントは遠すぎる過去にある場合、例えば、記録ウィンドウの外側に配置された配信ポイントを要求した場合、サーバーは記録最古のポイントを選択します。クライアントは、スケール（セクション18.46）との配信が1.0（通常の再生レート）以外の値要求した場合に記録して、ライブメディアを提供しながら、セクション13.5.3での考慮事項が適用されます。"
    },
    {
      "indent": 0,
      "text": "13.4.8. Playing Live with Time-Shift",
      "section_title": true,
      "ja": "13.4.8. タイムシフトでライブ演奏"
    },
    {
      "indent": 3,
      "text": "Certain media servers may offer time-shift services to their clients. This time shift records a fixed interval in the past, i.e., a sliding window recording mechanism, but not past this interval. Clients can randomly access the media between now and the interval. This live media with recording is indicated by the content of the Media-Properties header in the SETUP response when (see also Section 18.29):",
      "ja": "一部のメディアサーバーはそのクライアントにタイムシフトサービスを提供することがあります。この時間シフトはなく、この間隔過去、過去の一定期間、すなわち、スライディングウィンドウの記録メカニズムを記録します。クライアントはランダムになりましたし、間隔の間メディアにアクセスすることができます。記録を持つこのライブメディアは、SETUP応答する場合（セクション18.29を参照）におけるメディア・プロパティヘッダの内容によって示されます。"
    },
    {
      "indent": 3,
      "text": "o the Random Access property is set to Random-Access;",
      "ja": "O・ランダム・アクセス・プロパティは、ランダムアクセスに設定されています。"
    },
    {
      "indent": 3,
      "text": "o the Content Modifications property is set to Time-Progressing;",
      "ja": "コンテンツの変更oをプロパティは、タイム進むとに設定されています。"
    },
    {
      "indent": 3,
      "text": "o the Retention property is set to Time-Duration and a value indicating the recording interval (>0).",
      "ja": "O保持特性が時間期間および記録間隔を示す値に設定されている（> 0）。"
    },
    {
      "indent": 3,
      "text": "The SETUP 200 OK response MUST include the Media-Range header (see Section 18.30) for this type of media. For live media with recording, the Range header indicates the current time in the media and the Media-Range header indicates a window around the current time. This window can cover recorded content in the past (seen from current time in the media) or recorded content in the future (seen from current time in the media). The server adjusts the play point to the requested border of the window, if the client requests a play point that is located outside the recording windows, e.g., if requested too far in the past, the server selects the oldest range in the recording. The considerations in Section 13.5.3 apply if a client requests delivery using a scale (Section 18.46) value other than 1.0 (normal playback rate) while delivering live media with time-shift.",
      "ja": "SETUP 200 OK応答は、メディアのこのタイプのメディア-Rangeヘッダ（セクション18.30を参照）を含まなければなりません。記録とライブメディアの場合は、Rangeヘッダには、メディアとメディア-Rangeヘッダに現在の時刻が現在時刻の周りのウィンドウを示して示しています。このウィンドウには、（メディアに現在の時刻から見て）過去に記録されたコンテンツまたは（メディアに現在の時刻から見て）将来的に記録されたコンテンツをカバーすることができます。クライアントが過去にすぎ要求された場合、例えば記録ウィンドウ、外側に配置されているプレイ・ポイントを要求した場合、サーバは、サーバが記録で最も古い範囲を選択し、ウィンドウの要求国境にプレイポイントを調整します。クライアントは、タイムシフトでライブメディアを提供しながら、スケール（セクション18.46）1.0（通常の再生レート）以外の値を使用して配信を要求した場合、セクション13.5.3での考慮事項が適用されます。"
    },
    {
      "indent": 0,
      "text": "13.5. PLAY_NOTIFY",
      "section_title": true,
      "ja": "13.5.  PLAY_NOTIFY"
    },
    {
      "indent": 3,
      "text": "The PLAY_NOTIFY method is issued by a server to inform a client about an asynchronous event for a session in Play state. The Session header MUST be presented in a PLAY_NOTIFY request and indicates the scope of the request. Sending of PLAY_NOTIFY requests requires a persistent connection between server and client; otherwise, there is no way for the server to send this request method to the client.",
      "ja": "PLAY_NOTIFY方法は、プレイ状態のセッションのために非同期イベントについてクライアントに通知するために、サーバによって発行されます。セッションヘッダはPLAY_NOTIFY要求に提示し、要求の範囲を示しなければなりません。 PLAY_NOTIFY要求の送信は、サーバーとクライアントの間の永続的な接続が必要です。そうでない場合は、サーバーがクライアントにこの要求メソッドを送信するための方法はありません。"
    },
    {
      "indent": 3,
      "text": "PLAY_NOTIFY requests have an end-to-end (i.e., server-to-client) scope, as they carry the Session header, and apply only to the given session. The client SHOULD immediately return a response to the server.",
      "ja": "PLAY_NOTIFY要求は、それらがセッションヘッダを運ぶように、エンド・ツー・エンド（すなわち、サーバからクライアントへの）範囲を有し、所定のセッションにのみ適用されます。クライアントは、すぐにサーバーへの応答を返すべきです。"
    },
    {
      "indent": 3,
      "text": "PLAY_NOTIFY requests MAY use both an aggregate control URI and individual media resource URIs, depending on the scope of the notification. This scope may have important distinctions for aggregated sessions, and each reason for a PLAY_NOTIFY request needs to specify the interpretation as well as if aggregated control URIs or individual URIs may be used in requests.",
      "ja": "PLAY_NOTIFY要求が通知範囲に応じて、集計制御URIおよび個々のメディアリソースのURIの両方を使用するかもしれません。このスコープは、アグリゲートされたセッションのための重要な違いを有していてもよく、およびPLAY_NOTIFY要求の各理由は、集約制御のURIまたは個々のURIはリクエストで使用することができる場合の解釈を指定するだけでなく、する必要があります。"
    },
    {
      "indent": 3,
      "text": "PLAY_NOTIFY requests can be used with a message body, depending on the value of the Notify-Reason header. It is described in the particular section for each Notify-Reason if a message body is used. However, currently there is no Notify-Reason that allows the use of a message body. In this case, there is a need to obey some limitations when adding new Notify-Reasons that intend to use a message body: the server can send any type of message body, but it is not ensured that the client can understand the received message body. This is related to DESCRIBE (see Section 13.2 ); but, in this particular case, the client can state its acceptable message bodies by using the Accept header. In the case of PLAY_NOTIFY, the server does not know which message bodies are understood by the client.",
      "ja": "PLAY_NOTIFY要求が通知-理由ヘッダの値に応じて、メッセージ本体と共に使用することができます。メッセージ本体を使用する場合には、各通知-理由で特定のセクションに記載されています。しかし、現在のメッセージ本体を使用することができない通知-理由はありません。サーバーは、メッセージ本文の任意のタイプを送ることができますが、クライアントが受信したメッセージの本文を理解できることを保証されていません。この場合は、そこにメッセージ本体を使用する予定の新しい通知-理由を追加する際に、いくつかの制限に従うする必要があります。これは（13.2節を参照）を記述するために関連しています。しかし、この特定のケースでは、クライアントは、Acceptヘッダーを使用して、その上許容されるメッセージ体を述べることができます。 PLAY_NOTIFYの場合、サーバはクライアントが理解されているメッセージの体を知りません。"
    },
    {
      "indent": 3,
      "text": "The Notify-Reason header (see Section 18.32) specifies the reason why the server sends the PLAY_NOTIFY request. This is extensible and new reasons can be added in the future (see Section 22.8). In case the client does not understand the reason for the notification, it MUST respond with a 465 (Notification Reason Unknown) (Section 17.4.29) error code. This document defines how servers can send PLAY_NOTIFY with Notify-Reason values of these types:",
      "ja": "通知-理由をヘッダ（セクション18.32を参照）、サーバーがPLAY_NOTIFY要求を送信した理由を指定します。これは拡張可能であり、新たな理由は（項22.8を参照）、将来的に追加することができます。クライアントは、通知の理由を理解していない場合は、465（通知理由不明）（セクション17.4.29）エラーコードで応じなければなりません。この文書では、サーバは、これらのタイプの通知、理由値とPLAY_NOTIFYを送ることができますどのように定義しています。"
    },
    {
      "indent": 3,
      "text": "o end-of-stream (see Section 13.5.1);",
      "ja": "Oエンドオブストリーム（セクション13.5.1を参照）。"
    },
    {
      "indent": 3,
      "text": "o media-properties-update (see Section 13.5.2);",
      "ja": "Oメディアプロパティ更新（セクション13.5.2を参照）。"
    },
    {
      "indent": 3,
      "text": "o scale-change (see Section 13.5.3).",
      "ja": "Oスケール変更（項13.5.3を参照してください）。"
    },
    {
      "indent": 0,
      "text": "13.5.1. End-of-Stream",
      "section_title": true,
      "ja": "13.5.1. ストリームの終わり"
    },
    {
      "indent": 3,
      "text": "A PLAY_NOTIFY request with the Notify-Reason header set to end-of-stream indicates the completion or near completion of the PLAY request and the ending delivery of the media stream(s). The request MUST NOT be issued unless the server is in the Play state. The end of the media stream delivery notification may be used either to indicate a successful completion of the PLAY request currently being served or to indicate some error resulting in failure to complete the request. The Request-Status header (Section 18.42) MUST be included to indicate which request the notification is for and its completion status. The message response status codes (Section 8.1.1) are used to indicate how the PLAY request concluded. The sender of a PLAY_NOTIFY MAY issue an updated PLAY_NOTIFY, in the case of a",
      "ja": "エンド・オブ・ストリームに設定通知-ReasonヘッダとPLAY_NOTIFY要求が完了またはPLAY要求の近く完了とメディアストリーム（S）の終了送達を示します。サーバがプレイ状態にある場合を除き、要求が発行されてはなりません。メディアストリーム配信通知の端部は、現在サービスされているPLAY要求が正常に完了したことを示すために、または要求を完了するために障害の原因となるいくつかのエラーを示すために使用することができます。リクエスト・ステータスヘッダ（セクション18.42）を通知するために、その完了状態で要求するかを示すために含まれなければなりません。メッセージ応答のステータスコード（セクション8.1.1）は、PLAY要求が締結方法を示すために使用されます。 PLAY_NOTIFYの送信者がある場合には、更新されPLAY_NOTIFYを発行することができます"
    },
    {
      "indent": 3,
      "text": "PLAY_NOTIFY sent with wrong information. For instance, a PLAY_NOTIFY was issued before reaching the end-of-stream, but some error occurred resulting in that the previously sent PLAY_NOTIFY contained a wrong time when the stream will end. In this case, a new PLAY_NOTIFY MUST be sent including the correct status for the completion and all additional information.",
      "ja": "PLAY_NOTIFYは間違った情報を送りました。例えば、PLAY_NOTIFYは、ストリームの終わりに達する前に発行されましたが、若干の誤差が以前に送信されPLAY_NOTIFYは、ストリームが終了します間違った時間が含まれていることが結果として発生しました。この場合、新しいPLAY_NOTIFYが完了し、すべての追加情報については、正しいステータスを含む送らなければなりません。"
    },
    {
      "indent": 3,
      "text": "PLAY_NOTIFY requests with the Notify-Reason header set to end-of-stream MUST include a Range header and the Scale header if the scale value is not 1. The Range header indicates the point in the stream or streams where delivery is ending with the timescale that was used by the server in the PLAY response for the request being fulfilled. The server MUST NOT use the \"now\" constant in the Range header; it MUST use the actual numeric end position in the proper timescale. When end-of-stream notifications are issued prior to having sent the last media packets, this is made evident because the end time in the Range header is beyond the current time in the media being received by the client, e.g., \"npt=-15\", if npt is currently at 14.2 seconds. The Scale header is to be included so that it is evident if the media timescale is moving backwards or has a non-default pace. The end-of-stream notification does not prevent the client from sending a new PLAY request.",
      "ja": "PLAY_NOTIFY要求はエンド・オブ・ストリームに設定通知-ReasonヘッダはRangeヘッダ及びスケールヘッダを含まなければならないとスケール値が1でない場合Rangeヘッダは、ストリーム内の点を示すか、配信がタイムスケールで終了されるストリームそれが満たされている要求に対するPLAY応答でサーバによって使用されました。サーバーは、Rangeヘッダに「今」の定数を使用してはなりません。それは適切なタイムスケールで実際の数値の終了位置を使用しなければなりません。ストリームの終わり通知が前に最後のメディアパケットを送信したに発行されたときに、範囲ヘッダー内の終了時間は、クライアントによって受信されているメディアの現在時刻を超えているので、これは明らかに作られるなど、「NPT =  - 15\" 、NPTは14.2秒で、現在ある場合。スケールヘッダは、メディアタイムスケールが後方移動または非デフォルトペースを有している場合には明らかになるように含まれるべきです。ストリームの終わり通知は新しいPLAY要求を送信からクライアントを防ぐことはできません。"
    },
    {
      "indent": 3,
      "text": "If RTP is used as media transport, an RTP-Info header MUST be included, and the RTP-Info header MUST indicate the last sequence number in the sequence parameter.",
      "ja": "RTPは、メディアトランスポートとして使用される場合、RTP-Infoヘッダを含まなければなりません、そしてRTP-Infoヘッダは、シーケンスパラメータの最後のシーケンス番号を指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "For an RTSP Session where media resources are under aggregated control, the media resources will normally end at approximately the same time, although some small differences may exist, on the scale of a few hundred milliseconds. In those cases, an RTSP session under aggregated control SHOULD send only a single PLAY_NOTIFY request. By using the aggregate control URI in the PLAY_NOTIFY request, the RTSP server indicates that this applies to all media resources within the session. In cases in which RTP is used for media delivery, corresponding RTP-Info needs to be included for all media resources. In cases where one or more media resources have a significantly shorter duration than some other resources in the aggregated session, the server MAY send end-of-stream notifications using individual media resource URIs to indicate to agents that there will be no more media for this particular media resource related to the current active PLAY request. In such cases, when the remaining media resources come to the end of the stream, they MUST send a PLAY_NOTIFY request using the aggregate control URI to indicate that no more resources remain.",
      "ja": "いくつかの小さな違いが数百ミリ秒の規模で、存在するかもしれないが、メディアリソースが集約された制御下にあるRTSPセッションのために、メディアリソースは、通常、ほぼ同時に終了します。これらの場合、凝集制御下RTSPセッションは、単一のPLAY_NOTIFY要求を送信すべきです。 PLAY_NOTIFY要求に集約コントロールURIを使用することにより、RTSPサーバは、このセッション内のすべてのメディアリソースに適用されることを示しています。 RTPは、メディア配信のために使用されている場合には、対応するRTP-情報はすべてのメディアリソースのために含まれる必要があります。 1つまたは複数のメディアリソースが集約されたセッションでは、いくつかの他のリソースよりも大幅に短い期間を有する場合には、サーバは、このための複数のメディアがないことをエージェントに示すために、個々のメディアリソースのURIを使用してストリームの終わりの通知を送信することができ現在アクティブなPLAY要求に関連する特定のメディアリソース。残りのメディアリソースは、ストリームの終わりに来たときにそのような場合、彼らはより多くのリソースが残っていないことを示すために、集計制御URIを使用してPLAY_NOTIFY要求を送信しなければなりません。"
    },
    {
      "indent": 3,
      "text": "A PLAY_NOTIFY request with Notify-Reason header set to end-of-stream MUST NOT carry a message body.",
      "ja": "エンド・オブ・ストリームに設定通知-ReasonヘッダとPLAY_NOTIFY要求は、メッセージボディを運ばないしなければなりません。"
    },
    {
      "indent": 3,
      "text": "This example request notifies the client about a future end-of-stream event:",
      "ja": "この例の要求は将来ストリームの終わりイベントについてクライアントに通知します。"
    },
    {
      "indent": 5,
      "text": "S->C: PLAY_NOTIFY rtsp://example.com/fizzle/foo RTSP/2.0 CSeq: 854 Notify-Reason: end-of-stream Request-Status: cseq=853 status=200 reason=\"OK\" Range: npt=-145 RTP-Info:url=\"rtsp://example.com/fizzle/foo/audio\" ssrc=0D12F123:seq=14783;rtptime=2345962545, url=\"rtsp://example.com/fizzle/video\" ssrc=789DAF12:seq=57654;rtptime=2792482193 Session: CDtUJfDQXJWtJ7Iqua2xOi Date: Mon, 08 Mar 2010 13:37:16 GMT",
      "ja": "S-> C：PLAY_NOTIFY RTSP：//example.com/fizzle/foo RTSP / 2.0のCSeq：854通知-理由：エンドオブストリームリクエスト・ステータスのCSeq = 853のステータス= 200理由= \"OK\" 範囲：NPT = -145 RTP-情報：URL = \"RTSP：//example.com/fizzle/foo/audio\" SSRC = 0D12F123：SEQ = 14783; rtptime = 2345962545、URL = \"RTSP：//example.com/fizzle/video 「SSRC = 789DAF12：SEQ = 57654; rtptime = 2792482193セッション：CDtUJfDQXJWtJ7Iqua2xOi日：月、2010年3月8日13時37分16秒GMT"
    },
    {
      "indent": 5,
      "text": "C->S: RTSP/2.0 200 OK CSeq: 854 User-Agent: PhonyClient/1.2 Session: CDtUJfDQXJWtJ7Iqua2xOi",
      "ja": "C-> S：RTSP / 2.0 200 OKのCSeq：854のUser-Agent：PhonyClient / 1.2セッション：CDtUJfDQXJWtJ7Iqua2xOi"
    },
    {
      "indent": 0,
      "text": "13.5.2. Media-Properties-Update",
      "section_title": true,
      "ja": "13.5.2. メディア・プロパティ - アップデート"
    },
    {
      "indent": 3,
      "text": "A PLAY_NOTIFY request with a Notify-Reason header set to media-properties-update indicates an update of the media properties for the given session (see Section 18.29) or the available media range that can be played as indicated by the Media-Range header (Section 18.30). PLAY_NOTIFY requests with Notify-Reason header set to media-properties-update MUST include a Media-Properties and Date header and SHOULD include a Media-Range header. The Media-Properties header has session scope; thus, for aggregated sessions, the PLAY_NOTIFY request MUST use the aggregated control URI.",
      "ja": "更新メディアプロパティに設定通知-ReasonヘッダとPLAY_NOTIFY要求が与えられたセッションのメディア特性の更新を示しているか、メディアRangeヘッダによって示されるように再生することができる利用可能な媒体の範囲（（セクション18.29を参照のこと）セクション18.30）。 PLAY_NOTIFYは、メディア・プロパティとDateヘッダを含まなければならないメディアのプロパティ更新に設定通知-Reasonヘッダを要求し、メディア-Rangeヘッダを含めるべきです。メディアのプロパティヘッダーは、セッションスコープを持っています。従って、アグリゲートされたセッションのために、PLAY_NOTIFY要求は、集約制御URIを使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "This notification MUST be sent for media that are time-progressing every time an event happens that changes the basis for making estimates on how the available for play-back media range will progress with wall clock time. In addition, it is RECOMMENDED that the server send these notifications approximately every 5 minutes for time-progressing content to ensure the long-term stability of the client estimation and allow for clock skew detection by the client. The time between notifications should be greater than 1 minute and less than 2 hours. For the reasons just explained, requests MUST include a Media-Range header to provide current Media duration and a Range header to indicate the current playing point and any remaining parts of the requested range.",
      "ja": "この通知は、イベントはそれがウォールクロック時間で進行する方法をプレイバックメディアレンジのために利用可能に見積りを行うための基礎を変える起こるたびに、時間進行しているメディアのために送らなければなりません。加えて、サーバがクライアント推定の長期安定性を確保し、クライアントによってクロック・スキューの検出を可能にするために、これらの通知に時間が進んでコンテンツのための約5分ごとに送ることが推奨されます。通知の間の時間は1分未満、2時間以上でなければなりません。理由は、単に説明のために、要求は、現在のメディア時間と現在の再生位置を示すためにRangeヘッダと要求された範囲の任意の残りの部分を提供するために、メディアRangeヘッダを含まなければなりません。"
    },
    {
      "indent": 6,
      "text": "The recommendation for sending updates every 5 minutes is due to any clock skew issues. In 5 minutes, the clock skew should not become too significant as this is not used for media playback and synchronization, it is only for determining which content is available to the user.",
      "ja": "アップデートごとに5分を送信するための推奨事項は、任意のクロック・スキューの問題が原因です。これは、メディアの再生と同期のために使用されないように5分で、クロックスキューがあまり重要になるべきではない、それだけでコンテンツがユーザに利用可能であるかを決定するためのものです。"
    },
    {
      "indent": 3,
      "text": "A PLAY_NOTIFY request with Notify-Reason header set to media-properties-update MUST NOT carry a message body.",
      "ja": "メディアプロパティ更新に設定通知-ReasonヘッダとPLAY_NOTIFY要求は、メッセージボディを運ばないしなければなりません。"
    },
    {
      "indent": 4,
      "text": "S->C: PLAY_NOTIFY rtsp://example.com/fizzle/foo RTSP/2.0 Date: Tue, 14 Apr 2008 15:48:06 GMT CSeq: 854 Notify-Reason: media-properties-update Session: CDtUJfDQXJWtJ7Iqua2xOi Media-Properties: Time-Progressing, Time-Limited=20080415T153919.36Z, Random-Access=5.0 Media-Range: npt=00:00:00-01:37:21.394 Range: npt=01:15:49.873-",
      "ja": "S-> C：PLAY_NOTIFY RTSP：//example.com/fizzle/foo RTSP / 2.0日付：火曜、2008年4月14日午前15時48分06秒GMTのCSeq：854通知-理由：メディアのプロパティ更新セッション：CDtUJfDQXJWtJ7Iqua2xOiメディア - プロパティ：タイム進み、期間限定= 20080415T153919.36Zは、ランダムアクセスが5.0メディアレンジを=：NPT = 00：00：00-01：37：21.394範囲：NPT = 01：15：49.873-"
    },
    {
      "indent": 5,
      "text": "C->S: RTSP/2.0 200 OK CSeq: 854 User-Agent: PhonyClient/1.2 Session: CDtUJfDQXJWtJ7Iqua2xOi",
      "ja": "C-> S：RTSP / 2.0 200 OKのCSeq：854のUser-Agent：PhonyClient / 1.2セッション：CDtUJfDQXJWtJ7Iqua2xOi"
    },
    {
      "indent": 0,
      "text": "13.5.3. Scale-Change",
      "section_title": true,
      "ja": "13.5.3. スケールの変更"
    },
    {
      "indent": 3,
      "text": "The server may be forced to change the rate of media time per playback time when a client requests delivery using a scale (Section 18.46) value other than 1.0 (normal playback rate). For time-progressing media with some retention, i.e., the server stores already-sent content, a client requesting to play with scale values larger than 1 may catch up with the front end of the media. The server will then be unable to continue to provide content at scale larger than 1 as content is only made available by the server at scale = 1. Another case is when scale < 1 and the media retention is Time-Duration limited. In this case, the delivery point can reach the oldest media unit available, and further playback at this scale becomes impossible as there will be no media available. To avoid having the client lose any media, the scale will need to be adjusted to the same rate at which the media is removed from the storage buffer, commonly scale = 1.0.",
      "ja": "サーバーは、クライアントが、スケール（セクション18.46）1.0（通常の再生レート）以外の値を使用して配信を要求率メディア時間の再生あたりの時間を変更するように強制することができます。いくつかの保持、すなわち、サーバーストアは、既に送信されたコンテンツと時間進んメディアの場合、スケールが1より大きな値と遊ぶのが要求しているクライアントは、メディアのフロントエンドに追いつくことがあります。次に、サーバはコンテンツのみスケール= 1の別のケースでは、サーバによって利用可能になるように1よりも大きい規模でコンテンツを提供し続けることができないであろう場合、スケール<1とメディア・保持は、時間期間制限されています。利用可能なメディアが存在しないので、この場合には、配信ポイントは、このスケールで使用可能な最も古いメディアユニット、さらに再生に達することができることは不可能となります。クライアントは、任意のメディアを失うことを避けるために、スケールはメディアが格納用バッファから除去されるのと同じ速度に調整する必要があります、一般的にスケール= 1.0。"
    },
    {
      "indent": 3,
      "text": "Another case is when the content itself consists of spliced pieces or is dynamically updated. In these cases, the server may be required to change from one supported scale value (different than scale = 1.0) to another. In this case, the server will pick the closest value and inform the client of what it has picked. In these cases, the media properties will also be sent, updating the supported scale values. This enables a client to adjust the scale value used.",
      "ja": "コンテンツ自体は、スプライシングされた部分からなるか、または動的に更新されたときに別のケースです。これらのケースでは、サーバは、別の（スケール= 1.0とは異なる）を一度に支持スケール値から変更するために必要とされてもよいです。この場合、サーバは、最も近い値を選択し、それが選んだものをクライアントに通知します。これらのケースでは、メディアの特性にも対応してスケール値を更新し、送信されます。これは、使用するスケール値を調整するためのクライアントを可能にします。"
    },
    {
      "indent": 3,
      "text": "To minimize impact on playback in any of the above cases, the server MUST modify the playback properties, set scale to a supportable value, and continue delivery of the media. When doing this modification, it MUST send a PLAY_NOTIFY message with the Notify-Reason header set to \"scale-change\". The request MUST contain a Range header with the media time when the change took effect, a Scale header with the new value in use, a Session header with the identifier for the session to which it applies, and a Date header with the server wallclock time of the change. For time-progressing content, the Media-Range and the Media-Properties headers at this point in time also MUST be included. The Media-Properties header MUST be included if the scale change was due to the content changing what scale values (\"Scales\") are supported.",
      "ja": "上記の場合のいずれかで再生への影響を最小限に抑えるために、サーバがサポート可能値にスケールを設定した再生特性を、変更、およびメディアの配信を継続しなければなりません。この変更を行う場合は、「スケール変更」に設定通知-ReasonヘッダにPLAY_NOTIFYメッセージを送らなければなりません。要求は、サーバーの壁時計の時間で変更が発効したメディア時間、使用中の新しい値でスケールヘッダー、それが適用されるセッションの識別子、およびDateヘッダとSessionヘッダーでRangeヘッダを含まなければなりません変更の。時間進んコンテンツの場合、この時点でメディア・レンジとメディア・プロパティ・ヘッダも含まれなければなりません。スケールの変更がサポートされているスケール値（「スケール」）変更内容によるものであった場合、メディアプロパティヘッダを含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "For media streams delivered using RTP, an RTP-Info header MUST also be included. It MUST contain the rtptime parameter with a value corresponding to the point of change in that media and optionally the sequence number.",
      "ja": "メディアストリームは、RTPを使用して送達するために、RTP-Infoヘッダも含まれなければなりません。そのメディアの変化点に対応する値を有するr​​tptimeパラメータを含むシーケンス番号を任意選択しなければなりません。"
    },
    {
      "indent": 3,
      "text": "PLAY_NOTIFY requests for aggregated sessions MUST use the aggregated control URI in the request. The scale change for any aggregated session applies to all media streams that are part of the aggregate.",
      "ja": "アグリゲートされたセッションのためのPLAY_NOTIFY要求は、要求に集約された制御URIを使用しなければなりません。任意集約セッションのスケール変更は、集合体の一部であるすべてのメディアストリームに適用されます。"
    },
    {
      "indent": 3,
      "text": "A PLAY_NOTIFY request with Notify-Reason header set to \"Scale-Change\" MUST NOT carry a message body.",
      "ja": "「スケール変更」に設定通知-ReasonヘッダとPLAY_NOTIFY要求は、メッセージボディを運ばないしなければなりません。"
    },
    {
      "indent": 5,
      "text": "S->C: PLAY_NOTIFY rtsp://example.com/fizzle/foo RTSP/2.0 Date: Tue, 14 Apr 2008 15:48:06 GMT CSeq: 854 Notify-Reason: scale-change Session: CDtUJfDQXJWtJ7Iqua2xOi Media-Properties: Time-Progressing, Time-Limited=20080415T153919.36Z, Random-Access=5.0 Media-Range: npt=00:00:00-01:37:21.394 Range: npt=01:37:21.394- Scale: 1 RTP-Info: url=\"rtsp://example.com/fizzle/foo/audio\" ssrc=0D12F123:rtptime=2345962545, url=\"rtsp://example.com/fizzle/foo/videotrack\" ssrc=789DAF12:seq=57654;rtptime=2792482193",
      "ja": "S-> C：PLAY_NOTIFY RTSP：//example.com/fizzle/foo RTSP / 2.0日付：火曜、2008年4月14日午前15時48分06秒GMTののCSeq：854通知-理由：スケール変更セッション：CDtUJfDQXJWtJ7Iqua2xOiメディア-プロパティ：時間進み、期間限定= 20080415T153919.36Z、ランダム・アクセス= 5.0メディアレンジ：NPT = 00：00：00-01：37：21.394範囲：NPT = 01：37：21.394-スケール：1 RTP-情報：URL = \"RTSP：//example.com/fizzle/foo/audio\" SSRC = 0D12F123：rtptime = 2345962545、URL = \"RTSP：//example.com/fizzle/foo/videotrack\" SSRC = 789DAF12：SEQ = 57654 ; rtptime = 2792482193"
    },
    {
      "indent": 5,
      "text": "C->S: RTSP/2.0 200 OK CSeq: 854 User-Agent: PhonyClient/1.2 Session: CDtUJfDQXJWtJ7Iqua2xOi",
      "ja": "C-> S：RTSP / 2.0 200 OKのCSeq：854のUser-Agent：PhonyClient / 1.2セッション：CDtUJfDQXJWtJ7Iqua2xOi"
    },
    {
      "indent": 0,
      "text": "13.6. PAUSE",
      "section_title": true,
      "ja": "13.6.  PAUSE"
    },
    {
      "indent": 3,
      "text": "The PAUSE request causes the stream delivery to immediately be interrupted (halted). A PAUSE request MUST be made either with the aggregated control URI for aggregated sessions, resulting in all media being halted, or with the media URI for non-aggregated sessions. Any attempt to mute a single media with a PAUSE request in an aggregated session MUST be responded to with a 460 (Only Aggregate Operation Allowed) error. After resuming playback, synchronization of the tracks MUST be maintained. Any server resources are kept, though servers MAY close the session and free resources after being paused for the duration specified with the timeout parameter of the Session header in the SETUP message.",
      "ja": "PAUSE要求が直ちに中断するストリーム配信（停止）を引き起こします。 PAUSE要求は、すべてのメディアが停止され、または非アグリゲートされたセッションのためのメディアURIで得られた、いずれかのアグリゲートされたセッションのために凝集制御URIを用いて行わなければなりません。集約されたセッションでPAUSE要求を単一のメディアをミュートしようとすると、460（のみ集計操作可）エラーで応答しなければなりません。再生を再開した後、トラックの同期が維持されなければなりません。サーバは、SETUPメッセージ内のセッションヘッダーのタイムアウトパラメータで指定された期間のために一時停止された後、セッションやリソースの解放を閉じるかもしれませんが、任意のサーバリソースは、保持されます。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 5,
      "text": "C->S: PAUSE rtsp://example.com/fizzle/foo RTSP/2.0 CSeq: 834 Session: OoOUPyUwt0VeY9fFRHuZ6L User-Agent: PhonyClient/1.2",
      "ja": "C-> S：PAUSEのRTSP：//example.com/fizzle/foo RTSP / 2.0のCSeq：834セッション：OoOUPyUwt0VeY9fFRHuZ6LのUser-Agent：PhonyClient / 1.2"
    },
    {
      "indent": 5,
      "text": "S->C: RTSP/2.0 200 OK CSeq: 834 Date: Thu, 23 Jan 1997 15:35:06 GMT Session: OoOUPyUwt0VeY9fFRHuZ6L Range: npt=45.76-75.00",
      "ja": "S-> C：RTSP / 2.0 200 OKのCSeq：834日付：木、1997年1月23日午後03時35分06秒GMTセッション：OoOUPyUwt0VeY9fFRHuZ6L範囲：NPT = 45.76から75.00"
    },
    {
      "indent": 3,
      "text": "The PAUSE request causes stream delivery to be interrupted immediately on receipt of the message, and the pause point is set to the current point in the presentation. That pause point in the media stream needs to be maintained. A subsequent PLAY request without a Range header resumes from the pause point and plays until media end.",
      "ja": "PAUSE要求は、メッセージの受信時に直ちに中断するストリーム配信を引き起こし、一時停止点は、プレゼンテーション内の現在のポイントに設定されています。メディアストリームのその一時停止点が維持される必要があります。 Rangeヘッダすることなく次のPLAY要求が一時停止ポイントから再開し、メディア最後まで再生されます。"
    },
    {
      "indent": 3,
      "text": "The pause point after any PAUSE request MUST be returned to the client by adding a Range header with what remains unplayed of the PLAY request's range. For media with random access properties, if one desires to resume playing a ranged request, one simply includes the Range header from the PAUSE response and includes the Seek-Style header with the Next policy in the PLAY request. For media that is time-progressing and has retention duration=0, the follow-up PLAY request to start media delivery again MUST use \"npt=now-\" and not the answer given in the response to PAUSE.",
      "ja": "任意のPAUSE要求した後、一時停止点がPLAY要求の範囲の未再生の残るものでRangeヘッダを追加することにより、クライアントに返さなければなりません。一つの範囲要求の再生を再開したい場合、ランダムアクセス特性を有する媒体のために、一つは単にPAUSE応答からRangeヘッダを含み、PLAY要求の次のポリシーにシークスタイルヘッダを含みます。時間が進んでいると保持期間= 0、再び一時停止するに応じて与えられた答えは「NPT = NOW-」を使用していないしなければならないメディア配信を開始するためのフォローアップPLAY要求を持っているメディアの場合。"
    },
    {
      "indent": 5,
      "text": "C->S: PLAY rtsp://example.com/fizzle/foo RTSP/2.0 CSeq: 834 Session: OccldOFFq23KwjYpAnBbUr Range: npt=10-30 User-Agent: PhonyClient/1.2",
      "ja": "C-> S：PLAY RTSP：//example.com/fizzle/foo RTSP / 2.0のCSeq：834セッション：OccldOFFq23KwjYpAnBbUr範囲：NPT = 10~30のUser-Agent：PhonyClient / 1.2"
    },
    {
      "indent": 5,
      "text": "S->C: RTSP/2.0 200 OK CSeq: 834 Date: Thu, 23 Jan 1997 15:35:06 GMT Server: PhonyServer/1.0 Range: npt=10-30 Seek-Style: First-Prior RTP-Info:url=\"rtsp://example.com/fizzle/audiotrack\" ssrc=0D12F123:seq=5712;rtptime=934207921, url=\"rtsp://example.com/fizzle/videotrack\" ssrc=4FAD8726:seq=57654;rtptime=2792482193 Session: OccldOFFq23KwjYpAnBbUr",
      "ja": "S-> C：RTSP / 2.0 200 OKのCSeq：834日付：木、1997年1月23日午後03時35分06秒GMTサーバー：PhonyServer / 1.0範囲：NPT = 10~30シークスタイル：ファースト前RTP-情報：URL = \"RTSP：//example.com/fizzle/audiotrack\" SSRC = 0D12F123：SEQ = 5712; rtptime = 934207921、URL = \"RTSP：//example.com/fizzle/videotrack\" SSRC = 4FAD8726：SEQ = 57654; rtptime = 2792482193セッション：OccldOFFq23KwjYpAnBbUr"
    },
    {
      "indent": 3,
      "text": "After 11 seconds, i.e., at 21 seconds into the presentation:",
      "ja": "11秒後、すなわち、21秒でのプレゼンテーションに："
    },
    {
      "indent": 5,
      "text": "C->S: PAUSE rtsp://example.com/fizzle/foo RTSP/2.0 CSeq: 835 Session: OccldOFFq23KwjYpAnBbUr User-Agent: PhonyClient/1.2",
      "ja": "C-> S：PAUSEのRTSP：//example.com/fizzle/foo RTSP / 2.0のCSeq：835セッション：OccldOFFq23KwjYpAnBbUrユーザーエージェント：PhonyClient / 1.2"
    },
    {
      "indent": 5,
      "text": "S->C: RTSP/2.0 200 OK CSeq: 835 Date: 23 Jan 1997 15:35:17 GMT Server: PhonyServer/1.0 Range: npt=21-30 Session: OccldOFFq23KwjYpAnBbUr",
      "ja": "S-> C：RTSP / 2.0 200 OKのCSeq：835日付：1997年1月23日午後三時35分17秒GMTサーバー：PhonyServer / 1.0範囲：NPT = 21-30セッション：OccldOFFq23KwjYpAnBbUr"
    },
    {
      "indent": 3,
      "text": "If a client issues a PAUSE request and the server acknowledges and enters the Ready state, the proper server response, if the player issues another PAUSE, is still 200 OK. The 200 OK response MUST include the Range header with the current pause point. See examples below:",
      "ja": "クライアントは、PAUSE要求を発行し、サーバーが認識し、準備完了状態になった場合はプレイヤーが別のPAUSEを発行した場合、適切なサーバーの応答は、まだ200 OKです。 200 OK応答は、現在の一時停止点がRangeヘッダを含まなければなりません。以下の例を参照してください。"
    },
    {
      "indent": 5,
      "text": "C->S: PAUSE rtsp://example.com/fizzle/foo RTSP/2.0 CSeq: 834 Session: OccldOFFq23KwjYpAnBbUr User-Agent: PhonyClient/1.2",
      "ja": "C-> S：PAUSEのRTSP：//example.com/fizzle/foo RTSP / 2.0のCSeq：834セッション：OccldOFFq23KwjYpAnBbUrユーザーエージェント：PhonyClient / 1.2"
    },
    {
      "indent": 5,
      "text": "S->C: RTSP/2.0 200 OK CSeq: 834 Session: OccldOFFq23KwjYpAnBbUr Date: Thu, 23 Jan 1997 15:35:06 GMT Range: npt=45.76-98.36",
      "ja": "S-> C：RTSP / 2.0 200 OKのCSeq：834セッション：OccldOFFq23KwjYpAnBbUr日：木、1997年1月23日午後3時35分06秒GMT範囲：NPT = 45.76から98.36"
    },
    {
      "indent": 5,
      "text": "C->S: PAUSE rtsp://example.com/fizzle/foo RTSP/2.0 CSeq: 835 Session: OccldOFFq23KwjYpAnBbUr User-Agent: PhonyClient/1.2",
      "ja": "C-> S：PAUSEのRTSP：//example.com/fizzle/foo RTSP / 2.0のCSeq：835セッション：OccldOFFq23KwjYpAnBbUrユーザーエージェント：PhonyClient / 1.2"
    },
    {
      "indent": 5,
      "text": "S->C: RTSP/2.0 200 OK CSeq: 835 Session: OccldOFFq23KwjYpAnBbUr Date: 23 Jan 1997 15:35:07 GMT Range: npt=45.76-98.36",
      "ja": "S-> C：RTSP / 2.0 200 OKのCSeq：835セッション：OccldOFFq23KwjYpAnBbUr日：1997年1月23日夜03時35分07秒GMT範囲：NPT = 45.76から98.36"
    },
    {
      "indent": 0,
      "text": "13.7. TEARDOWN",
      "section_title": true,
      "ja": "13.7. 取り壊す"
    },
    {
      "indent": 0,
      "text": "13.7.1. Client to Server",
      "section_title": true,
      "ja": "13.7.1. サーバーへのクライアント"
    },
    {
      "indent": 3,
      "text": "The TEARDOWN client-to-server request stops the stream delivery for the given URI, freeing the resources associated with it. A TEARDOWN request can be performed on either an aggregated or a media control URI. However, some restrictions apply depending on the current state. The TEARDOWN request MUST contain a Session header indicating to what session the request applies. The TEARDOWN request MUST NOT include a Terminate-Reason header.",
      "ja": "TEARDOWNクライアントからサーバへのリクエストは、それに関連付けられたリソースを解放し、与えられたURIのためのストリーム配信を停止します。 TEARDOWN要求は、集約またはメディア制御URIのいずれかで行うことができます。しかし、いくつかの制限は、現在の状態に応じて適用されます。 TEARDOWN要求は、要求が適用されるどのようなセッションに示すセッションヘッダを含まなければなりません。 TEARDOWN要求は終了-理由ヘッダを含めることはできません。"
    },
    {
      "indent": 3,
      "text": "A TEARDOWN using the aggregated control URI or the media URI in a session under non-aggregated control (single media session) MAY be done in any state (Ready and Play). A successful request MUST result in that media delivery being immediately halted and the session state being destroyed. This MUST be indicated through the lack of a Session header in the response.",
      "ja": "非凝集制御（単一メディアセッション）の下でセッションに凝集制御URIまたはメディアURIを使用して、TEARDOWNは、任意の状態（レディ・アンド・プレイ）で行われてもよいです。成功した要求は直ちに停止されると、セッション状態が破壊され、そのメディア配信をもたらさなければなりません。これは、応答のセッションヘッダの欠如を通じて示さなければなりません。"
    },
    {
      "indent": 3,
      "text": "A TEARDOWN using a media URI in an aggregated session can only be done in Ready state. Such a request only removes the indicated media stream and associated resources from the session. This may result in a session returning to non-aggregated control, because it only contains a single media after the request's completion. A session that will exist after the processing of the TEARDOWN request MUST, in the response to that TEARDOWN request, contain a Session header.",
      "ja": "集約されたセッションのメディアURIを使用して、TEARDOWNのみレディ状態で行うことができます。このような要求はセッションから指示されたメディアストリームと関連付けられたリソースを削除します。それが唯一の要求の完了後に、単一のメディアが含まれているので、これは、非集約制御に復帰セッションになることがあります。 TEARDOWN要求の処理の後に存在するセッションは、そのTEARDOWN要求に応答して、セッション・ヘッダを含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "Thus, the presence of the Session header indicates to the receiver of the response if the session is still extant or has been removed.",
      "ja": "セッションがまだ現存であるか、または削除された場合したがって、セッションヘッダの存在はレスポンスの受信機に示します。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 5,
      "text": "C->S: TEARDOWN rtsp://example.com/fizzle/foo RTSP/2.0 CSeq: 892 Session: OccldOFFq23KwjYpAnBbUr User-Agent: PhonyClient/1.2",
      "ja": "C-> S：TEARDOWNのRTSP：//example.com/fizzle/foo RTSP / 2.0のCSeq：892セッション：OccldOFFq23KwjYpAnBbUrユーザーエージェント：PhonyClient / 1.2"
    },
    {
      "indent": 5,
      "text": "S->C: RTSP/2.0 200 OK CSeq: 892 Server: PhonyServer/1.0",
      "ja": "S-> C：RTSP / 2.0 200 OKのCSeq：892サーバー：PhonyServer / 1.0"
    },
    {
      "indent": 0,
      "text": "13.7.2. Server to Client",
      "section_title": true,
      "ja": "13.7.2. クライアントへのサーバー"
    },
    {
      "indent": 3,
      "text": "The server can send TEARDOWN requests in the server-to-client direction to indicate that the server has been forced to terminate the ongoing session. This may happen for several reasons, such as server maintenance without available backup, or that the session has been inactive for extended periods of time. The reason is provided in the Terminate-Reason header (Section 18.52).",
      "ja": "サーバは、サーバが進行中のセッションを終了することを余儀なくされたことを示すために、サーバからクライアントへの方向にTEARDOWN要求を送信することができます。これは、利用可能なバックアップなしに、このようなサーバーメンテナンスなど、いくつかの理由のために起こる、またはセッションが長時間非アクティブにされたことがあります。その理由は、終了理由をヘッダ（セクション18.52）に設けられています。"
    },
    {
      "indent": 3,
      "text": "When an RTSP client has maintained an RTSP session that otherwise is inactive for an extended period of time, the server may reclaim the resources. That is done by issuing a TEARDOWN request with the Terminate-Reason set to \"Session-Timeout\". This MAY be done when the client has been inactive in the RTSP session for more than one Session Timeout period (Section 18.49). However, the server is NOT RECOMMENDED to perform this operation until an extended period of inactivity of 10 times the Session-Timeout period has passed. It is up to the operator of the RTSP server to actually configure how long this extended period of inactivity is. An operator should take into account, when doing this configuration, what the served content is and what this means for the extended period of inactivity.",
      "ja": "RTSPクライアントは、そうでない場合は長時間にわたって非アクティブであるRTSPセッションを維持していると、サーバーはリソースを再利用します。それは、「セッションタイムアウト」に設定終了-理由でTEARDOWN要求を発行することによって行われます。クライアントが複数のセッションタイムアウト期間（セクション18.49）用のRTSPセッションで非アクティブになっているとき、これが行うことができます。しかし、サーバがセッションタイムアウト期間が経過した10回の不活動の延長期間まで、この操作を実行するために推奨されていません。これは、実際に非アクティブのこの延長期間がどれくらい長く設定するには、RTSPサーバの運営者次第です。オペレータは考慮に入れる必要があり、この設定を行う際に、提供されるコンテンツが何であるか、これが非アクティブの長時間何を意味するのか。"
    },
    {
      "indent": 3,
      "text": "In case the server needs to stop providing service to the established sessions and there is no server to point at in a REDIRECT request, then TEARDOWN SHALL be used to terminate the session. This method can also be used when non-recoverable internal errors have happened and the server has no other option than to terminate the sessions.",
      "ja": "ケースでは、サーバは、確立されたセッションにサービスの提供を停止する必要があるポイントへのサーバがリダイレクト要求内に存在しない場合、TEARDOWNは、セッションを終了するために使用されなければなりません。回復不能な内部エラーが起こったときに、この方法を使用することも可能で、サーバがセッションを終了するよりも、他の選択肢を持っていません。"
    },
    {
      "indent": 3,
      "text": "The TEARDOWN request MUST be made only on the session aggregate control URI (i.e., it is not allowed to terminate individual media streams, if it is a session aggregate), and it MUST include the following headers: Session and Terminate-Reason. The request only applies to the session identified in the Session header. The server may include a message to the client's user with the \"user-msg\" parameter.",
      "ja": "TEARDOWN要求のみ（すなわち、それがセッション集合体である場合、個々のメディアストリームを終了することが許可されていない）セッション集約制御URIで行う必要があり、それは次のヘッダーを含める必要がありますセッションと終了-理由。リクエストは、セッションヘッダで識別されるセッションに適用されます。サーバーは、「ユーザー-MSG」パラメータを使用して、クライアントのユーザーへのメッセージを含んでいてもよいです。"
    },
    {
      "indent": 3,
      "text": "The TEARDOWN request may alternatively be done on the wildcard URI \"*\" and without any session header. The scope of such a request is limited to the next-hop (i.e., the RTSP agent in direct communication with the server) and applies, as well, to the RTSP connection between the next-hop RTSP agent and the server. This request indicates that all sessions and pending requests being managed via the connection are terminated. Any intervening proxies SHOULD do all of the following in the order listed:",
      "ja": "TEARDOWN要求は、代替的に、ワイルドカードURI「*」で、任意のセッション・ヘッダなしで行うことができます。そのような要求の範囲（すなわち、サーバと直接通信におけるRTSP剤）ネクストホップに制限され、次のホップRTSPエージェントとサーバとの間のRTSP接続に、同様に、適用されます。この要求は、すべてのセッションおよび接続を介して管理されている保留中の要求が終了していることを示しています。任意の介在プロキシがリストされている順に以下のすべてを実行する必要があります。"
    },
    {
      "indent": 3,
      "text": "1. respond to the TEARDOWN request",
      "section_title": true,
      "ja": "1. TEARDOWN要求に応答"
    },
    {
      "indent": 3,
      "text": "2. disconnect the control channel from the requesting server",
      "section_title": true,
      "ja": "2.要求サーバからの制御チャネルを切断"
    },
    {
      "indent": 3,
      "text": "3. pass the TEARDOWN request to each applicable client (typically those clients with an active session or an unanswered request)",
      "ja": "3.該当する各クライアント（アクティブセッションまたは未応答要求に典型的にはこれらのクライアント）にTEARDOWN要求を渡します"
    },
    {
      "indent": 6,
      "text": "Note: The proxy is responsible for accepting TEARDOWN responses from its clients; these responses MUST NOT be passed on to either the original server or the target server in the redirect.",
      "ja": "注意：プロキシがそのクライアントからのTEARDOWN応答を受け入れるための責任があります。これらの応答は、元のサーバーまたはリダイレクトでターゲット・サーバーのいずれかに渡されてはなりません。"
    },
    {
      "indent": 0,
      "text": "13.8. GET_PARAMETER",
      "section_title": true,
      "ja": "13.8.  GET_PARAMETER"
    },
    {
      "indent": 3,
      "text": "The GET_PARAMETER request retrieves the value of any specified parameter or parameters for a presentation or stream specified in the URI. If the Session header is present in a request, the value of a parameter MUST be retrieved in the specified session context. There are two ways of specifying the parameters to be retrieved.",
      "ja": "GET_PARAMETER要求は、URIで指定されたプレゼンテーションやストリームのための任意の指定されたパラメータまたはパラメータの値を取得します。セッション・ヘッダはリクエスト中に存在する場合、パラメータの値は、指定されたセッションコンテキストで検索されなければなりません。検索するパラメータを指定するには、2つの方法があります。"
    },
    {
      "indent": 3,
      "text": "The first approach includes headers that have been defined to be usable for this purpose. Headers for this purpose should allow empty, or stripped value parts to avoid having to specify bogus data when indicating the desire to retrieve a value. The successful completion of the request should also be evident from any filled out values in the response. The headers in this specification that MAY be used for retrieving their current value using GET_PARAMETER are listed below; additional headers MAY be specified in the future:",
      "ja": "第1のアプローチは、この目的のために使用可能であることが定義されているヘッダを含みます。この目的のためのヘッダは値を取得したいという要望を示す場合に偽のデータを指定することを避けるために、空の、または剥離値の部品を可能にすべきです。要求が正常に完了は、応答内の任意の記入値から明らかです。 GET_PARAMETERを使用して現在の値を取得するために使用されるかもしれ本明細書中のヘッダを以下に列挙する。追加ヘッダは、将来的に指定することができます。"
    },
    {
      "indent": 3,
      "text": "o Accept-Ranges",
      "ja": "O-範囲を受け入れます"
    },
    {
      "indent": 3,
      "text": "o Media-Range",
      "ja": "お めぢあーらんげ"
    },
    {
      "indent": 3,
      "text": "o Media-Properties",
      "ja": "O-メディアのプロパティ"
    },
    {
      "indent": 3,
      "text": "o Range",
      "ja": "お らんげ"
    },
    {
      "indent": 3,
      "text": "o RTP-Info",
      "ja": "RTP-情報"
    },
    {
      "indent": 3,
      "text": "The other way is to specify a message body that lists the parameter(s) that are desired to be retrieved. The Content-Type header (Section 18.19) is used to specify which format the message body has. If the receiver of the request does not support the media type used for the message body, it SHALL respond using the error code 415 (Unsupported Media Type). The responder to a GET_PARAMETER request MUST use the media type of the request for the response. For additional considerations regarding message body negotiation, see Section 9.3.",
      "ja": "他の方法は、検索したいパラメータを一覧表示し、メッセージ本文を指定することです。 Content-Typeヘッダ（セクション18.19）は、メッセージ本体が有するフォーマットを指定するために使用されます。リクエストの受信者がメッセージ本文に使用するメディアの種類をサポートしていない場合は、エラーコード415（サポートされていないメディアタイプ）を使用して応答しなければなりません。 GET_PARAMETER要求への応答は、応答のための要求のメディアタイプを使用しなければなりません。メッセージ本文の交渉に関する追加の考慮事項については、9.3節を参照してください。"
    },
    {
      "indent": 3,
      "text": "RTSP agents implementing support for responding to GET_PARAMETER requests SHALL implement the \"text/parameters\" format (Appendix F). This to ensure that at least one known format for parameters is implemented and, thus, prevent parameter format negotiation failure.",
      "ja": "リクエストをGET_PARAMETERに応答するためのサポートを実装するRTSPエージェントは、「テキスト/パラメータ」形式（付録F）を実施するものとします。このパラメータの少なくとも1つの既知のフォーマットが実装されていることを確認し、従って、パラメータフォーマットのネゴシエーション失敗を防止します。"
    },
    {
      "indent": 3,
      "text": "Parameters specified within the body of the message must all be understood by the request-receiving agent. If one or more parameters are not understood a 451 (Parameter Not Understood) MUST be sent including a body listing the parameters that weren't understood. If all parameters are understood, their values are filled in and returned in the response message body.",
      "ja": "メッセージの本体内に指定されたパラメータは、すべての要求、受信エージェントによって理解されなければなりません。一つ以上のパラメータが理解されていない場合は451（パラメータ分からないが）理解していなかったパラメータをリストに体を含む送らなければなりません。すべてのパラメータが理解されている場合、それらの値はに充填し、応答メッセージボディに返されます。"
    },
    {
      "indent": 3,
      "text": "The method can also be used without a message body or any header that requests parameters for keep-alive purposes. The keep-alive timer has been updated for any request that is successful, i.e., a 200 OK response is received. Any non-required header present in such a request may or may not have been processed. Normally, the presence of filled-out values in the header will be indication that the header has been processed. However, for cases when this is difficult to determine, it is recommended to use a feature tag and the Require header. For this reason, it is usually easier if any parameters to be retrieved are sent in the body, rather than using any header.",
      "ja": "この方法はまた、メッセージ本文またはキープアライブ目的のためのパラメータを要求する任意のヘッダなしで使用することができます。キープアライブタイマーは、200 OK応答が受信され、すなわち、成功しているすべての要求のために更新されています。このような要求に存在する任意の非必須ヘッダは、または処理されていなくてもよいです。通常、ヘッダ内の充填アウト値の存在は、ヘッダが処理されたことを示すであろう。これは決定することは困難である場合しかし、ケースのために、特徴タグおよびRequireヘッダーを使用することが推奨されます。取得される任意のパラメータはなく、任意のヘッダを使用するよりも、本体で送信される場合、このような理由から、通常は容易です。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 5,
      "text": "S->C: GET_PARAMETER rtsp://example.com/fizzle/foo RTSP/2.0 CSeq: 431 User-Agent: PhonyClient/1.2 Session: OccldOFFq23KwjYpAnBbUr Content-Length: 26 Content-Type: text/parameters",
      "ja": "S-> C：GET_PARAMETERのRTSP：//example.com/fizzle/foo RTSP / 2.0のCSeq：431のUser-Agent：PhonyClient / 1.2セッション：OccldOFFq23KwjYpAnBbUrのContent-Length：26 Content-Typeの：テキスト/パラメータ"
    },
    {
      "indent": 11,
      "text": "packets_received\njitter",
      "raw": true
    },
    {
      "indent": 5,
      "text": "C->S: RTSP/2.0 200 OK CSeq: 431 Session: OccldOFFq23KwjYpAnBbUr Server: PhonyServer/1.1 Date: Mon, 08 Mar 2010 13:43:23 GMT Content-Length: 38 Content-Type: text/parameters",
      "ja": "C-> S：RTSP / 2.0 200 OKのCSeq：431セッション：OccldOFFq23KwjYpAnBbUrサーバー：PhonyServer / 1.1日付：月、2010年3月8日午前13時43分二十三秒GMTのコンテンツの長さ：38のContent-Type：テキスト/パラメータ"
    },
    {
      "indent": 11,
      "text": "packets_received: 10\njitter: 0.3838",
      "raw": true
    },
    {
      "indent": 0,
      "text": "13.9. SET_PARAMETER",
      "section_title": true,
      "ja": "13.9.  SET_PARAMETER"
    },
    {
      "indent": 3,
      "text": "This method requests the setting of the value of a parameter or a set of parameters for a presentation or stream specified by the URI. If the Session header is present in a request, the value of a parameter MUST be retrieved in the specified session context. The method MAY also be used without a message body. It is the RECOMMENDED method to be used in a request sent for the sole purpose of updating the keep-alive timer. If this request is successful, i.e., a 200 OK response is received, then the keep-alive timer has been updated. Any non-required header present in such a request may or may not have been processed. To allow a client to determine if any such header has been processed, it is necessary to use a feature tag and the Require header. Due to this reason it is RECOMMENDED that any parameters are sent in the body rather than using any header.",
      "ja": "このメソッドは、パラメータの値、またはURIで指定されたプレゼンテーションやストリームのパラメータのセットの設定を要求します。セッション・ヘッダはリクエスト中に存在する場合、パラメータの値は、指定されたセッションコンテキストで検索されなければなりません。この方法はまた、メッセージボディせずに使用することができます。キープアライブタイマーを更新する唯一の目的のために送られた要求で使用される推奨される方法です。この要求は、すなわち、200 OK応答が受信され、成功した場合、キープアライブタイマーが更新されました。このような要求に存在する任意の非必須ヘッダは、または処理されていなくてもよいです。そのようなヘッダが処理された場合、クライアントが決定できるようにするために、特徴タグおよびRequireヘッダーを使用する必要があります。この理由のため、任意のパラメータではなく、任意のヘッダを使用するよりも体内に送信することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "When using a message body to list the parameter(s) desired to be set, the Content-Type header (Section 18.19) is used to specify which format the message body has. If the receiver of the request is not supporting the media type used for the message body, it SHALL respond using the error code 415 (Unsupported Media Type). For additional considerations regarding message body negotiation, see Section 9.3. The responder to a SET_PARAMETER request MUST use the media type of the request for the response. For additional considerations regarding message body negotiation, see Section 9.3.",
      "ja": "設定したいパラメータを一覧表示するメッセージ本体を使用する場合は、Content-Typeヘッダ（セクション18.19）は、メッセージ本体が有するフォーマットを指定するために使用されます。リクエストの受信機は、メッセージ本文に使用されるメディアタイプをサポートしていない場合は、エラーコード415（サポートされていないメディアタイプ）を使用して応答しなければなりません。メッセージ本文の交渉に関する追加の考慮事項については、9.3節を参照してください。 SET_PARAMETER要求への応答は、応答のための要求のメディアタイプを使用しなければなりません。メッセージ本文の交渉に関する追加の考慮事項については、9.3節を参照してください。"
    },
    {
      "indent": 3,
      "text": "RTSP agents implementing support for responding to SET_PARAMETER requests SHALL implement the text/parameters format (Appendix F). This is to ensure that at least one known format for parameters is implemented and, thus, prevent parameter format negotiation failure.",
      "ja": "SET_PARAMETER要求に対応するためのサポートを実装RTSPエージェントは、テキスト/パラメータ形式（付録F）を実施するものとします。これは、パラメータの少なくとも1つの公知の形式が実装されていることを確認し、従って、パラメータフォーマットのネゴシエーション失敗を防止するためです。"
    },
    {
      "indent": 3,
      "text": "A request is RECOMMENDED to only contain a single parameter to allow the client to determine why a particular request failed. If the request contains several parameters, the server MUST only act on the request if all of the parameters can be set successfully. A server MUST allow a parameter to be set repeatedly to the same value, but it MAY disallow changing parameter values. If the receiver of the request does not understand or cannot locate a parameter, error 451 (Parameter Not Understood) MUST be used. When a parameter is not allowed to change, the error code is 458 (Parameter Is Read-Only). The response body MUST contain only the parameters that have errors. Otherwise, a body MUST NOT be returned. The response body MUST use the media type of the request for the response.",
      "ja": "要求は、特定の要求が失敗した理由を、クライアントが決定できるようにするために、単一のパラメータを含めることをお勧めします。リクエストは、いくつかのパラメータが含まれている場合、サーバはすべてのパラメータが正常に設定できるのであれば、要求に基づいて行動しなければなりません。サーバは、パラメータが同じ値に繰り返し設定することができるようにしなければならないが、それは、パラメータ値を変更する許可しない場合があります。リクエストの受信機が理解していないか、パラメータが見つからない場合、エラー451は（パラメータが分からない）使用しなければなりません。パラメータを変更することが許可されていない場合は、エラーコードが458（パラメータが読み取り専用である）です。レスポンスボディは、エラーを持っている唯一のパラメータを含まなければなりません。そうしないと、体が返されてはなりません。レスポンスボディには、応答の要求のメディアタイプを使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Note: transport parameters for the media stream MUST only be set with the SETUP command.",
      "ja": "注意：メディアストリームのためのトランスポートパラメータはSETUPコマンドで設定しなければなりません。"
    },
    {
      "indent": 6,
      "text": "Restricting setting transport parameters to SETUP is for the benefit of firewalls connected to border RTSP proxies.",
      "ja": "SETUPに設定するトランスポートパラメータを制限する境界RTSPプロキシに接続されているファイアウォールの利益のためです。"
    },
    {
      "indent": 6,
      "text": "The parameters are split in a fine-grained fashion so that there can be more meaningful error indications. However, it may make sense to allow the setting of several parameters if an atomic setting is desirable. Imagine device control where the client does not want the camera to pan unless it can also tilt to the right angle at the same time.",
      "ja": "より意味のあるエラー表示ができるように、パラメータは、きめの細かい方法で分割されています。アトミック設定が望ましい場合しかし、それはいくつかのパラメータの設定を許可しても意味があります。クライアントは、それはまた同時に直角に傾けることができない限り、カメラがパンしたくないデバイスの制御を想像してみてください。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 5,
      "text": "C->S: SET_PARAMETER rtsp://example.com/fizzle/foo RTSP/2.0 CSeq: 421 User-Agent: PhonyClient/1.2 Session: iixT43KLc Date: Mon, 08 Mar 2010 14:45:04 GMT Content-length: 20 Content-type: text/parameters",
      "ja": "C-> S：SET_PARAMETERのRTSP：//example.com/fizzle/foo RTSP / 2.0のCSeq：421のUser-Agent：PhonyClient / 1.2セッション：iixT43KLc日：月、2010年3月8日午前14時45分04秒GMTのコンテンツの長さ： 20コンテンツタイプ：テキスト/パラメータ"
    },
    {
      "indent": 11,
      "text": "barparam: barstuff",
      "ja": "barparam：barstuff"
    },
    {
      "indent": 5,
      "text": "S->C: RTSP/2.0 451 Parameter Not Understood CSeq: 421 Session: iixT43KLc Server: PhonyServer/1.0 Date: Mon, 08 Mar 2010 14:44:56 GMT Content-length: 20 Content-type: text/parameters",
      "ja": "S-> C：RTSP / 2.0 451パラメータ分からないのCSeq：421セッション：iixT43KLcサーバー：PhonyServer / 1.0日付：月、2010年3月8日午後02時44分56秒GMTコンテンツの長さ：20コンテンツタイプ：テキスト/パラメータ"
    },
    {
      "indent": 11,
      "text": "barparam: barstuff",
      "ja": "barparam：barstuff"
    },
    {
      "indent": 0,
      "text": "13.10. REDIRECT",
      "section_title": true,
      "ja": "13.10. リダイレクト"
    },
    {
      "indent": 3,
      "text": "The REDIRECT method is issued by a server to inform a client that the service provided will be terminated and where a corresponding service can be provided instead. This may happen for different reasons. One is that the server is being administered such that it must stop providing service. Thus, the client is required to connect to another server location to access the resource indicated by the Request-URI.",
      "ja": "Redirectメソッドは、提供されるサービスが終了され、対応するサービスを代わりに提供できる場所ことをクライアントに通知するために、サーバによって発行されます。これは、様々な理由で発生する可能性があります。一つは、サーバがサービスの提供を停止しなければならないように投与されていることです。したがって、クライアントは、Request-URIで示されるリソースにアクセスするために別のサーバーの場所に接続するために必要とされます。"
    },
    {
      "indent": 3,
      "text": "The REDIRECT request SHALL contain a Terminate-Reason header (Section 18.52) to inform the client of the reason for the request. Additional parameters related to the reason may also be included. The intention here is to allow a server administrator to do a controlled shutdown of the RTSP server. That requires sufficient time to inform all entities having associated state with the server and for them to perform a controlled migration from this server to a fall-back server.",
      "ja": "リダイレクト要求は、要求の理由をクライアントに通知するために終了-理由をヘッダ（セクション18.52）を含まなければなりません。理由に関連する追加のパラメータを含めることもできます。ここでの意図は、サーバ管理者がRTSPサーバの制御されたシャットダウンを行うことができるようにすることです。これは、サーバと関連する状態を有するすべてのエンティティに通知するのに十分な時間を必要とし、彼らのためにフォールバックサーバにこのサーバから制御移行を実行します。"
    },
    {
      "indent": 3,
      "text": "A REDIRECT request with a Session header has end-to-end (i.e., server-to-client) scope and applies only to the given session. Any intervening proxies SHOULD NOT disconnect the control channel while there are other remaining end-to-end sessions. The REQUIRED Location header MUST contain a complete absolute URI pointing to the resource to which the client SHOULD reconnect. Specifically, the Location",
      "ja": "セッションヘッダとリダイレクト要求は、エンドツーエンド（すなわち、サーバからクライアントへの）範囲を有し、所定のセッションにのみ適用されます。他の残りのエンド・ツー・エンドのセッションがある一方で、任意の介在プロキシは、制御チャネルを切断してはなりません。 REQUIREDロケーションヘッダは、クライアントが再接続するべきかのリソースを指し、完全な絶対URIを含まなければなりません。具体的には、場所"
    },
    {
      "indent": 3,
      "text": "MUST NOT contain just the host and port. A client may receive a REDIRECT request with a Session header, if and only if, an end-to-end session has been established.",
      "ja": "ちょうどホストとポートを含めることはできません。クライアントは、エンドツーエンドのセッションが確立されている場合にのみ、場合に、セッションヘッダとリダイレクト要求を受信することができます。"
    },
    {
      "indent": 3,
      "text": "A client may receive a REDIRECT request without a Session header at any time when it has communication or a connection established with a server. The scope of such a request is limited to the next-hop (i.e., the RTSP agent in direct communication with the server) and applies to all sessions controlled, as well as the connection between the next-hop RTSP agent and the server. A REDIRECT request without a Session header indicates that all sessions and pending requests being managed via the connection MUST be redirected. The Location header, if included in such a request, SHOULD contain an absolute URI with only the host address and the OPTIONAL port number of the server to which the RTSP agent SHOULD reconnect. Any intervening proxies SHOULD do all of the following in the order listed:",
      "ja": "クライアントは、それが通信やサーバと確立された接続を有する任意の時点でセッションヘッダなしリダイレクト要求を受信することができます。そのような要求の範囲は、ネクストホップ（サーバと直接通信している、すなわち、RTSPエージェント）に制限され、すべてのセッション制御、ならびに次のホップRTSPエージェントとサーバ間の接続に適用されます。セッションヘッダなしのリダイレクト要求は、すべてのセッションおよび接続を介して管理されている保留中の要求がリダイレクトされなければならないことを示しています。 Locationヘッダには、そのような要求に含まれている場合、唯一のホストアドレスとRTSP剤が再接続先となるサーバのオプションのポート番号と絶対URIを含むべきです。任意の介在プロキシがリストされている順に以下のすべてを実行する必要があります。"
    },
    {
      "indent": 3,
      "text": "1. respond to the REDIRECT request",
      "section_title": true,
      "ja": "1.リダイレクト要求に応えます"
    },
    {
      "indent": 3,
      "text": "2. disconnect the control channel from the requesting server",
      "section_title": true,
      "ja": "2.要求サーバからの制御チャネルを切断"
    },
    {
      "indent": 3,
      "text": "3. connect to the server at the given host address",
      "section_title": true,
      "ja": "3.特定のホストアドレスでサーバーに接続"
    },
    {
      "indent": 3,
      "text": "4. pass the REDIRECT request to each applicable client (typically those clients with an active session or an unanswered request)",
      "ja": "4.該当する各クライアント（アクティブセッションまたは未応答要求に典型的にはこれらのクライアント）へのリダイレクト要求を渡します"
    },
    {
      "indent": 6,
      "text": "Note: The proxy is responsible for accepting REDIRECT responses from its clients; these responses MUST NOT be passed on to either the original server or the redirected server.",
      "ja": "注：プロキシがそのクライアントからの応答をリダイレクト受け入れる責任です。これらの応答は、元のサーバーまたはリダイレクトサーバーのいずれかに渡されてはなりません。"
    },
    {
      "indent": 3,
      "text": "A server that needs to terminate a session or all its sessions and lacks an alternative server to redirect to, SHALL instead use TEARDOWN requests.",
      "ja": "セッションまたはすべてのセッションを終了する必要があり、リダイレクト先の代替サーバーを欠いサーバは、代わりにTEARDOWN要求を使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "When no Terminate-Reason \"time\" parameter is included in a REDIRECT request, the client SHALL perform the redirection immediately and return a response to the server. The server shall consider the session to be terminated and can free any associated state after it receives the successful (2xx) response. The server MAY close the signaling connection upon receiving the response, and the client SHOULD close the signaling connection after sending the 2xx response. The exception to this is when the client has several sessions on the server being managed by the given signaling connection. In this case, the client SHOULD close the connection when it has received and responded to REDIRECT requests for all the sessions managed by the signaling connection.",
      "ja": "何の終了-理由「時間」パラメータがリダイレクト要求に含まれていない場合、クライアントはすぐにリダイレクトを実行し、サーバへの応答を返します。サーバが終了するセッションを考慮しなければならないし、それが成功した（の2xx）レスポンスを受信した後、関連する状態を解放することができます。サーバが応答を受信すると、シグナリング接続を閉じることができ、クライアントは2xx応答を送信した後、シグナリング接続を閉じる必要があります。クライアントが特定のシグナリング接続によって管理されているサーバ上で複数のセッションを持つ場合は例外です。この場合、クライアントは、それが受信し、シグナリング接続によって管理されるすべてのセッションの要求をリダイレクトするために応答した接続を閉じる必要があります。"
    },
    {
      "indent": 3,
      "text": "The Terminate-Reason header \"time\" parameter MAY be used to indicate the wallclock time by which the redirection MUST have taken place. To allow a client to determine that redirect time without being time synchronized with the server, the server MUST include a Date header in the request. The client should have terminated the session and closed the connection before the redirection time-line terminated. The server MAY simply cease to provide service when the deadline time has been reached, or it can issue a TEARDOWN requests to the remaining sessions.",
      "ja": "終了理由をヘッダ「時間」パラメータは、リダイレクトが行われている必要があることにより、ウォールクロック時間を示すために使用され得ます。クライアントがサーバに同期した時刻されずにそのリダイレクト時間を決定できるようにするために、サーバはリクエストにDateヘッダを含まなければなりません。クライアントは、セッションを終了し、終了リダイレクトタイムラインの前に、接続を閉じている必要があります。締切時間に達したときに、サーバは、単純にサービスを提供しなくなる可能性があり、またはそれは、残りのセッションへのTEARDOWN要求を発行することができます。"
    },
    {
      "indent": 3,
      "text": "If the REDIRECT request times out following the rules in Section 10.4, the server MAY terminate the session or transport connection that would be redirected by the request. This is a safeguard against misbehaving clients that refuse to respond to a REDIRECT request. This action removes any incentive of not acknowledging the reception of a REDIRECT request.",
      "ja": "リダイレクト要求がタイムアウトセクション10.4の規則を、以下の場合は、サーバーはその要求によってリダイレクトされるだろうセッションまたは輸送の接続を終了することができます。これは、リダイレクト要求に応じることを拒否し、クライアントに不正な動作に対する保護手段です。このアクションは、リダイレクト要求を受信したことを認めていないのいずれかのインセンティブを削除します。"
    },
    {
      "indent": 3,
      "text": "After a REDIRECT request has been processed, a client that wants to continue to receive media for the resource identified by the Request-URI will have to establish a new session with the designated host. If the URI given in the Location header is a valid resource URI, a client SHOULD issue a DESCRIBE request for the URI.",
      "ja": "リダイレクト要求が処理された後は、Request-URIによって識別されるリソースのメディアを受け取るために続けたいクライアントは、指定されたホストとの新しいセッションを確立する必要があります。 Locationヘッダで指定されたURIが有効なリソースURIであれば、クライアントはURIのためのDESCRIBE要求を発行する必要があります。"
    },
    {
      "indent": 6,
      "text": "Note: The media resource indicated by the Location header can be identical, slightly different, or totally different. This is the reason why a new DESCRIBE request SHOULD be issued.",
      "ja": "注：Locationヘッダで示されるメディアリソースは、同じわずかに異なる、又は完全に異なっていてもよいです。これは、新しいDESCRIBE要求が発行されるべき理由です。"
    },
    {
      "indent": 3,
      "text": "If the Location header contains only a host address, the client may assume that the media on the new server is identical to the media on the old server, i.e., all media configuration information from the old session is still valid except for the host address. However, the usage of conditional SETUP using MTag identifiers is RECOMMENDED as a means to verify the assumption.",
      "ja": "Locationヘッダのみがホストアドレスが含まれている場合、クライアントは新しいサーバー上のメディアが古いサーバー上のメディアと同一であることを仮定してもよい、すなわち、古いセッションからすべてのメディア構成情報は、ホストアドレス以外まだ有効です。しかし、MTAG識別子を使用して条件付きSETUPの使用は、仮定を検証する手段として推奨されています。"
    },
    {
      "indent": 3,
      "text": "This example request redirects traffic for this session to the new server at the given absolute time:",
      "ja": "この例で要求が与えられた絶対時間で新しいサーバーにこのセッションのトラフィックをリダイレクトします。"
    },
    {
      "indent": 5,
      "text": "S->C: REDIRECT rtsp://example.com/fizzle/foo RTSP/2.0 CSeq: 732 Location: rtsp://s2.example.com:8001/fizzle/foo Terminate-Reason: Server-Admin ;time=19960213T143205Z Session: uZ3ci0K+Ld-M Date: Thu, 13 Feb 1996 14:30:43 GMT",
      "ja": "S-> C：//example.com/fizzle/foo RTSP / 2.0のCSeq：732場所：RTSP：//s2.example.com：8001 /不首尾/ fooの終了-理由：RTSP REDIRECTサーバ管理;時間= 19960213T143205Zセッション：uZ3ci0K + LD-M日：木、1996年2月13日午後02時30分43秒GMT"
    },
    {
      "indent": 5,
      "text": "C->S: RTSP/2.0 200 OK CSeq: 732 User-Agent: PhonyClient/1.2 Session: uZ3ci0K+Ld-M",
      "ja": "C-> S：RTSP / 2.0 200 OKのCSeq：732のUser-Agent：PhonyClient / 1.2セッション：uZ3ci0K + LD-M"
    },
    {
      "indent": 0,
      "text": "14. Embedded (Interleaved) Binary Data",
      "section_title": true,
      "ja": "14.組み込み（インターリーブ）バイナリデータ"
    },
    {
      "indent": 3,
      "text": "In order to fulfill certain requirements on the network side, e.g., in conjunction with network address translators that block RTP traffic over UDP, it may be necessary to interleave RTSP messages and media-stream data. This interleaving should generally be avoided unless necessary since it complicates client and server operation and imposes additional overhead. Also, head-of-line blocking may cause problems. Interleaved binary data SHOULD only be used if RTSP is carried over TCP. Interleaved data is not allowed inside RTSP messages.",
      "ja": "ネットワーク側の特定の要件を満たすために、例えば、UDP上のRTPトラフィックをブロックするネットワークアドレス変換に関連して、RTSPメッセージとメディアストリームデータをインタリーブする必要があるかもしれません。それは、クライアントとサーバーの操作を複雑にし、追加のオーバーヘッドを課しているので、このインターリーブは、一般的に必要でない限り避けるべきです。また、ヘッドオブラインブロッキングが問題を引き起こす可能性があります。 RTSPはTCP上で実行された場合にインターリーブバイナリデータにのみ使用してください。インターリーブされたデータは、RTSPメッセージ内で許可されていません。"
    },
    {
      "indent": 3,
      "text": "Stream data, such as RTP packets, is encapsulated by an ASCII dollar sign (36 decimal) followed by a one-octet channel identifier and the length of the encapsulated binary data as a binary, two-octet unsigned integer in network octet order (Appendix B of [RFC791]). The stream data follows immediately afterwards, without a CRLF, but including the upper-layer protocol headers. Each dollar sign block MUST contain exactly one upper-layer protocol data unit, e.g., one RTP packet.",
      "ja": "このようなRTPパケットなどのストリームデータは、付録（ネットワークオクテットために、1オクテットのチャネル識別子とバイナリ、2オクテットの符号なし整数としてカプセル化されたバイナリデータの長さに続くASCIIドル記号（36進）によってカプセル化され[RFC791]のB）。ストリームデータは、CRLFことなく、直後に従うが、上位層プロトコルヘッダーを含みます。各ドル記号のブロックは、1つの上位層プロトコルデータユニット、例えば、1つのRTPパケットを含まなければなりません。"
    },
    {
      "indent": 6,
      "text": "Note that this mechanism does not support PDUs larger than 65535 octets, which matches the maximum payload size of regular, non-jumbo IPv4 and IPv6 packets. If the media delivery protocol intended to be used has larger PDUs than that, a definition of a PDU fragmentation mechanism will be required to support embedded binary data.",
      "ja": "このメカニズムは、通常の、非ジャンボIPv4およびIPv6パケットの最大ペイロードサイズと一致65535オクテット、より大きいPDUをサポートしていないことに留意されたいです。使用されることを意図メディア配信プロトコルは、より大きなPDUを有する場合に、PDU断片化メカニズムの定義が埋め込まれたバイナリデータをサポートするために必要とされます。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| \"$\" = 36      | Channel ID    | Length in octets              |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n: Binary data (Length according to Length field)                :\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 13,
      "text": "Figure 1: Embedded Interleaved Binary Data Format",
      "ja": "図1：内蔵インターリーブバイナリデータ形式"
    },
    {
      "indent": 3,
      "text": "The channel identifier is defined in the Transport header with the interleaved parameter (Section 18.54).",
      "ja": "チャンネル識別子は、インターリーブパラメータ（セクション18.54）を有するトランスポート・ヘッダに定義されています。"
    },
    {
      "indent": 3,
      "text": "When the transport choice is RTP, RTCP messages are also interleaved by the server over the TCP connection. The usage of RTCP messages is indicated by including an interval containing a second channel in the interleaved parameter of the Transport header (see Section 18.54). If RTCP is used, packets MUST be sent on the first available channel that is higher than the RTP channel. The channels are bidirectional, using the same Channel ID in both directions; therefore, RTCP traffic is sent on the second channel in both directions.",
      "ja": "輸送選択がRTPである場合には、RTCPメッセージはまた、TCP接続を介してサーバーによってインターリーブされています。 RTCPメッセージの使用は、トランスポートヘッダ（セクション18.54を参照）のインターリーブパラメータにおける第二のチャネルを含む区間などで示されています。 RTCPが使用される場合、パケットは、RTPチャネルよりも高い第1の利用可能なチャネル上で送信されなければなりません。チャネルは両方向に同じチャネルIDを使用して、双方向です。従って、RTCPトラフィックが両方向に第二のチャネル上で送信されます。"
    },
    {
      "indent": 6,
      "text": "RTCP is sometimes needed for synchronization when two or more streams are interleaved in such a fashion. Also, this provides a convenient way to tunnel RTP/RTCP packets through the RTSP connection (TCP or TCP/TLS) when required by the network configuration and to transfer them onto UDP when possible.",
      "ja": "二つ以上のストリームがこのようなやり方でインターリーブされる場合RTCPは、時々、同期のために必要とされます。また、これは、ネットワークの構成によって要求されると、可能な場合UDP上にそれらを転送するためにRTSP接続（TCPまたはTCP / TLS）を介してトンネルRTP / RTCPパケットに便利な方法を提供します。"
    },
    {
      "indent": 5,
      "text": "C->S: SETUP rtsp://example.com/bar.file RTSP/2.0 CSeq: 2 Transport: RTP/AVP/TCP;unicast;interleaved=0-1 Accept-Ranges: npt, smpte, clock User-Agent: PhonyClient/1.2",
      "ja": "C-> S：SETUPのRTSP：2トランスポート：RTP / AVP / TCP、ユニキャスト、インターリーブ= 0-1-範囲を受け入れ：RTSP / 2.0のCSeq //example.com/bar.file NPT、SMPTE、クロックのUser-Agent ：PhonyClient / 1.2"
    },
    {
      "indent": 5,
      "text": "S->C: RTSP/2.0 200 OK CSeq: 2 Date: Thu, 05 Jun 1997 18:57:18 GMT Transport: RTP/AVP/TCP;unicast;interleaved=5-6 Session: OccldOFFq23KwjYpAnBbUr Accept-Ranges: npt Media-Properties: Random-Access=0.2, Immutable, Unlimited",
      "ja": "S-> C：RTSP / 2.0 200 OKのCSeq：2日：木、1997年6月5日夜六時57分18秒GMTトランスポート：RTP / AVP / TCP;ユニキャスト、インターリーブされた= 5-6セッション：OccldOFFq23KwjYpAnBbUrのAccept-範囲：NPTメディア-properties：ランダム・アクセス= 0.2、不変、無制限"
    },
    {
      "indent": 5,
      "text": "C->S: PLAY rtsp://example.com/bar.file RTSP/2.0 CSeq: 3 Session: OccldOFFq23KwjYpAnBbUr User-Agent: PhonyClient/1.2",
      "ja": "C-> S：PLAYのRTSP：3セッション：OccldOFFq23KwjYpAnBbUrユーザーエージェント：RTSP / 2.0のCSeq //example.com/bar.file PhonyClient / 1.2"
    },
    {
      "indent": 5,
      "text": "S->C: RTSP/2.0 200 OK CSeq: 3 Session: OccldOFFq23KwjYpAnBbUr Date: Thu, 05 Jun 1997 18:57:19 GMT RTP-Info: url=\"rtsp://example.com/bar.file\" ssrc=0D12F123:seq=232433;rtptime=972948234 Range: npt=0-56.8 Seek-Style: RAP",
      "ja": "S-> C：RTSP / 2.0 200 OKのCSeq：3セッション：OccldOFFq23KwjYpAnBbUr日：木、1997年6月5日午後06時57分19秒GMT RTP-情報：URL = \"RTSP：//example.com/bar.file\" SSRC = NPT = 0から56.8シークスタイル：：RAP;：0D12F123 rtptime = 972948234範囲= 232433以降"
    },
    {
      "indent": 5,
      "text": "S->C: $005{2 octet length}{\"length\" octets data, w/RTP header} S->C: $005{2 octet length}{\"length\" octets data, w/RTP header} S->C: $006{2 octet length}{\"length\" octets RTCP packet}",
      "ja": "S-> C：$ 005 {2オクテットの長さ} { \"長さ\" オクテットデータは、W / RTPヘッダ} S-> C：$ 005 {2オクテットの長さ} { \"長さ\" オクテットデータ、W / RTPヘッダ} S-> C ：$ 006 {2オクテットの長さ} { \"長さ\" オクテットRTCPパケット}"
    },
    {
      "indent": 0,
      "text": "15. Proxies",
      "section_title": true,
      "ja": "15.プロキシ"
    },
    {
      "indent": 3,
      "text": "RTSP Proxies are RTSP agents that are located in between a client and a server. A proxy can take on the roles of both client and server depending on what it tries to accomplish. RTSP proxies use two transport-layer connections: one from the RTSP client to the RTSP proxy and a second from the RTSP proxy to the RTSP server. Proxies are introduced for several different reasons; those listed below are often combined.",
      "ja": "RTSPプロキシは、クライアントとサーバの間に配置されているRTSP剤です。プロキシは、それが達成しようとするものに応じて、クライアントとサーバーの両方の役割を引き受けることができます。 RTSPプロキシとRTSPサーバへRTSPプロキシからの第二のRTSPクライアントから1：RTSPプロキシは、2トランスポート層接続を使用しています。プロキシは、いくつかの異なる理由のために導入されています。以下に列挙したものは、多くの場合、結合されます。"
    },
    {
      "indent": 3,
      "text": "Caching Proxy: This type of proxy is used to reduce the workload on servers and connections. By caching the description and media streams, i.e., the presentation, the proxy can serve a client with content, but without requesting it from the server once it has been cached and has not become stale. See Section 16. This type of proxy is also expected to understand RTSP endpoint functionality, i.e., functionality identified in the Require header in addition to what Proxy-Require demands.",
      "ja": "Caching Proxyは：プロキシのこのタイプは、サーバーとの接続の負荷を軽減するために使用されます。記述およびメディアストリーム、すなわち、プレゼンテーションをキャッシュすることにより、プロキシは、コンテンツと、それがキャッシュされていると、古くなっていない後、サーバーからそれを要求せずにクライアントにサービスを提供することができます。プロキシのこのタイプはまたすなわちRTSPエンドポイントの機能、要求をプロキシが、要求ものに加えて必須ヘッダで識別された機能性を理解することが期待される第16参照。"
    },
    {
      "indent": 3,
      "text": "Translator Proxy: This type of proxy is used to ensure that an RTSP client gets access to servers and content on an external network or gets access by using content encodings not supported by the client. The proxy performs the necessary translation of addresses, protocols, or encodings. This type of proxy is expected also to understand RTSP endpoint functionality, i.e., functionality identified in the Require header in addition to what Proxy-Require demands.",
      "ja": "翻訳プロキシ：プロキシのこのタイプは、RTSPクライアントが外部ネットワーク上のサーバーやコンテンツへのアクセスを取得したり、クライアントでサポートされていないコンテンツのエンコーディングを使用してアクセスを取得することを保証するために使用されます。プロキシは、アドレス、プロトコル、またはエンコードの必要な変換を実行します。プロキシこの種の要求をプロキシが、要求ものに加えて、要求ヘッダで識別されたRTSPエンドポイントの機能、すなわち、機能を理解することも期待されています。"
    },
    {
      "indent": 3,
      "text": "Access Proxy: This type of proxy is used to ensure that an RTSP client gets access to servers on an external network. Thus, this proxy is placed on the border between two domains, e.g., a private address space and the public Internet. The proxy performs the necessary translation, usually addresses. This type of proxy is required to redirect the media to itself or a controlled gateway that performs the translation before the media can reach the client.",
      "ja": "アクセスプロキシ：プロキシのこのタイプは、RTSPクライアントが外部ネットワーク上のサーバへのアクセスを取得することを保証するために使用されます。したがって、このプロキシは二つのドメイン、例えば、プライベートアドレス空間と公共のインターネット間の境界に配置されます。プロキシは通常、アドレス、必要な変換を実行します。プロキシのこのタイプは、それ自体、またはメディアがクライアントに到達する前に変換を実行する制御ゲートウェイにメディアをリダイレクトする必要があります。"
    },
    {
      "indent": 3,
      "text": "Security Proxy: This type of proxy is used to help facilitate security functions around RTSP. For example, in the case of a firewalled network, the security proxy requests that the necessary pinholes in the firewall are opened when a client in the protected network wants to access media streams on the external side. This proxy can perform its function without redirecting the media between the server and client. However, in deployments with private address spaces, this proxy is likely to be combined with the access proxy. The functionality of this proxy is usually closely tied into understanding all aspects of the media transport.",
      "ja": "セキュリティのプロキシ：プロキシのこのタイプは、RTSPの周りにセキュリティ機能を促進するために使用されます。たとえば、ファイアウォールネットワークの場合には、セキュリティプロキシは、保護されたネットワーク内のクライアントが外部側にメディアストリームにアクセスしたい場合、ファイアウォールで必要なピンホールが開いていることを要求します。このプロキシはサーバとクライアントの間でメディアをリダイレクトすることなく、その機能を実行することができます。ただし、プライベートアドレス空間を持つ展開で、このプロキシはアクセスプロキシと組み合わせることも可能性があります。このプロキシの機能は通常、密接メディアトランスポートのすべての側面を理解することに結びついています。"
    },
    {
      "indent": 3,
      "text": "Auditing Proxy: RTSP proxies can also provide network owners with a logging and auditing point for RTSP sessions, e.g., for corporations that track their employees usage of the network. This type of proxy can perform its function without inserting itself or any other node in the media transport. This proxy type can also accept unknown methods as it doesn't interfere with the clients' requests.",
      "ja": "監査プロキシ：RTSPプロキシは、ネットワークの従業員の使用状況を追跡する企業のために、例えば、RTSPセッションのロギングおよび監査ポイントとネットワークの所有者を提供することができます。プロキシのこのタイプは、それ自体、またはメディアトランスポート内の他のノードを挿入することなく、その機能を実行することができます。それは、クライアントの要求に干渉しないよう、このプロキシタイプはまた、未知の方法を受け入れることができます。"
    },
    {
      "indent": 3,
      "text": "All types of proxies can also be used when using secured communication with TLS, as RTSP 2.0 allows the client to approve certificate chains used for connection establishment from a proxy; see Section 19.3.2. However, that trust model may not be suitable for all types of deployment. In those cases, the secured sessions do bypass the proxies.",
      "ja": "RTSP 2.0がプロキシからの接続の確立に使用される証明書チェーンを承認するクライアントを可能にするように、TLSで保護された通信を使用する場合、プロキシのすべてのタイプを使用することもできます。セクション19.3.2を参照してください。しかし、その信頼モデルは、展開のすべてのタイプのために適切ではないかもしれません。これらの例では、セキュリティで保護されたセッションは、プロキシをバイパスします。"
    },
    {
      "indent": 3,
      "text": "Access proxies SHOULD NOT be used in equipment like NATs and firewalls that aren't expected to be regularly maintained, like home or small office equipment. In these cases, it is better to use the NAT traversal procedures defined for RTSP 2.0 [RFC7825]. The reason for these recommendations is that any extensions of RTSP resulting in new media-transport protocols or profiles, new parameters, etc., may fail in a proxy that isn't maintained. This would impede RTSP's future development and usage.",
      "ja": "アクセスプロキシが定期的に家庭や小規模オフィス機器のように、維持されると予想されていないのNATやファイアウォールなどの機器では使用しないでください。これらの場合には、RTSP 2.0 [RFC7825]のために定義されたNATトラバーサル手順を使用した方がよいです。これらの推奨理由は、新たなメディア・トランスポート・プロトコルまたはプロファイル、新しいパラメータ、等をもたらすRTSPのいずれかの拡張機能は、維持されていないプロキシに失敗する可能性があることです。これは、RTSPの将来の発展と利用を妨げます。"
    },
    {
      "indent": 0,
      "text": "15.1. Proxies and Protocol Extensions",
      "section_title": true,
      "ja": "15.1. プロキシおよびプロトコル拡張"
    },
    {
      "indent": 3,
      "text": "The existence of proxies must always be considered when developing new RTSP extensions. Most types of proxies will need to implement any new method to operate correctly in the presence of that extension. New headers can be introduced and will not be blocked by older proxies. However, it is important to consider if this header and its function are required to be understood by the proxy or if it can be simply forwarded. If the header needs to be understood, a feature tag representing the functionality MUST be included in the Proxy-Require header. Below are guidelines for analysis whether the header needs to be understood. The Transport header and its parameters are extensible, which requires handling rules for a proxy in order to ensure a correct interpretation.",
      "ja": "新しいRTSP拡張を開発する際にプロキシの存在が常に考慮しなければなりません。プロキシのほとんどのタイプは、その拡張子の存在下で正しく動作する任意の新しいメソッドを実装する必要があります。新しいヘッダを導入することができるし、古いプロキシによってブロックされることはありません。しかし、このヘッダとその機能は、プロキシが理解される必要があるか、それが簡単に転送することができるかどうかあれば検討することが重要です。ヘッダを理解する必要がある場合、機能性を表す特徴タグは、プロキシ要求ヘッダに含まれなければなりません。以下のヘッダを理解する必要があるかどうかを分析するためのガイドラインです。トランスポートヘッダとそのパラメータは、正しい解釈を確保するためにプロキシのルールを取り扱う必要とする、拡張可能です。"
    },
    {
      "indent": 3,
      "text": "Whether or not a proxy needs to understand a header is not easy to determine as they serve a broad variety of functions. When evaluating if a header needs to be understood, one can divide the functionality into three main categories:",
      "ja": "プロキシは、ヘッダーを理解する必要があるかどうかは、彼らは機能の幅広いサービスを提供として決定することは容易ではありません。ヘッダが理解される必要があるかどうかを評価するとき、1は、3つの主要なカテゴリに機能を分割することができます。"
    },
    {
      "indent": 3,
      "text": "Media modifying: The caching and translator proxies modify the actual media and therefore need also to understand the request directed to the server that affects how the media is rendered. Thus, this type of proxy also needs to understand the server-side functionality.",
      "ja": "メディアは、修正：キャッシュと翻訳者プロキシが実際のメディアを変更するため、メディアがレンダリングされる方法に影響を与えるサーバーに向け、要求を理解しておくことも必要です。したがって、このタイプのプロキシは、サーバー側の機能を理解する必要があります。"
    },
    {
      "indent": 3,
      "text": "Transport modifying: The access and the security proxy both need to understand how the media transport is performed, either for opening pinholes or translating the outer headers, e.g., IP and UDP or TCP.",
      "ja": "トランスポートの変更：アクセスとセキュリティプロキシの両方がメディアトランスポートは、ピンホールを開いたり、外側のヘッダ、例えば、IPおよびUDPまたはTCPを翻訳するためのいずれかで、どのように行われるかを理解する必要があります。"
    },
    {
      "indent": 3,
      "text": "Non-modifying: The audit proxy is special in that it does not modify the messages in other ways than to insert the Via header. That makes it possible for this type to forward RTSP messages that contain different types of unknown methods, headers, or header parameters.",
      "ja": "非改：Viaヘッダーを挿入するよりも、それは他の方法でメッセージを変更しないという点で、監査プロキシは特別です。この型が未知の方法、ヘッダ、またはヘッダパラメータの異なるタイプを含むRTSPメッセージを転送するために、それはそれが可能となります。"
    },
    {
      "indent": 3,
      "text": "An extension has to be classified as mandatory to be implemented for a proxy, if an extension has to be understood by a \"Transport modifying\" type of proxy.",
      "ja": "拡張は、拡張プロキシの「トランスポート変更」タイプによって理解されなければならない場合、プロキシのために実装することが必須と分類されなければなりません。"
    },
    {
      "indent": 0,
      "text": "15.2. Multiplexing and Demultiplexing of Messages",
      "section_title": true,
      "ja": "15.2. メッセージの多重・分離"
    },
    {
      "indent": 3,
      "text": "RTSP proxies may have to multiplex several RTSP sessions from their clients towards RTSP servers. This requires that RTSP requests from multiple clients be multiplexed onto a common connection for requests outgoing to an RTSP server, and, on the way back, the responses be demultiplexed from the server to per-client responses. On the protocol level, this requires that request and response messages be handled in both directions, requiring that there be a mechanism to correlate which request/response pair exchanged between proxy and server is mapped to which client (or client request).",
      "ja": "RTSPプロキシは、RTSPサーバに向けて、顧客からのいくつかのRTSPセッションを多重化する必要があります。これは、帰りに、応答がクライアントごとの応答にサーバーから多重分離され、複数のクライアントからのRTSP要求はRTSPサーバへ発信要求するための共通の接続に多重化されている必要があります、と。プロトコルレベルでは、これは要求メッセージと応答メッセージがどのクライアント（またはクライアント要求）にマッピングされるプロキシとサーバの間で交換要求/応答ペア相関するメカニズムが存在することを要求、両方向で処理されることを必要とします。"
    },
    {
      "indent": 3,
      "text": "This multiplexing of requests and demultiplexing of responses is done by using the CSeq header field. The proxy has to rewrite the CSeq in requests to the server and responses from the server and remember which CSeq is mapped to which client. The proxy also needs to ensure that the order of the message related to each client is maintained. Section 18.20 defines the handling of how requests and responses are rewritten.",
      "ja": "要求と応答の逆多重化のこの多重化はCSeqヘッダーフィールドを使用して行われます。プロキシは、サーバーからサーバーと応答への要求でのCSeqを書き換えるとのCSeqがどのクライアントにマッピングされた覚えがあります。プロキシは、各クライアントに関連するメッセージの順序が維持されることを保証する必要があります。セクション18.20は、要求と応答が書き換えられているかの処理を定義します。"
    },
    {
      "indent": 0,
      "text": "16. Caching",
      "section_title": true,
      "ja": "16.キャッシュ"
    },
    {
      "indent": 3,
      "text": "In HTTP, request/response pairs are cached. RTSP differs significantly in that respect. Responses are not cacheable, with the exception of the presentation description returned by DESCRIBE. (Since the responses for anything but DESCRIBE and GET_PARAMETER do not return any data, caching is not really an issue for these requests.) However, it is desirable for the continuous media data, typically delivered out-of-band with respect to RTSP, to be cached, as well as the session description.",
      "ja": "HTTPでは、リクエスト/レスポンスのペアがキャッシュされます。 RTSPはその点で大きく異なります。応答はDESCRIBEによって返されたプレゼンテーション記述を除いて、キャッシュ可能ではありません。 （何のための応答のでしかし、DESCRIBEとGET_PARAMETERはデータを返しませんが、キャッシュは本当にこれらの要求のための問題ではありません。）しかし、それは、通常、RTSPに対する帯域外配信連続メディアデータ、のために望ましいですキャッシュされただけでなく、セッション記述されます。"
    },
    {
      "indent": 3,
      "text": "On receiving a SETUP or PLAY request, a proxy ascertains whether it has an up-to-date copy of the continuous media content and its description. It can determine whether the copy is up to date by issuing a SETUP or DESCRIBE request, respectively, and comparing the Last-Modified header with that of the cached copy. If the copy is not up to date, it modifies the SETUP transport parameters as appropriate and forwards the request to the origin server. Subsequent control commands such as PLAY or PAUSE then pass the proxy unmodified. The proxy delivers the continuous media data to the client, while possibly making a local copy for later reuse. The exact allowed behavior of the cache is given by the cache-response directives described in Section 18.11. A cache MUST answer any DESCRIBE requests if it is currently serving the stream to the requester, as it is possible that low-level details of the stream description may have changed on the origin server.",
      "ja": "SETUPまたはPLAY要求を受信すると、プロキシはそれが連続メディアコンテンツとその説明の最新のコピーを持っているかどうかを確認します。これは、コピーは、それぞれ、SETUPやDESCRIBE要求を発行し、キャッシュされたコピーのそれと最終-Modifiedヘッダを比較することによって最新の状態であるか否かを判断することができます。コピーが最新でない場合は、必要に応じてSETUP輸送パラメーターを変更し、元のサーバに要求を転送します。そのような再生または一時停止などの後続の制御コマンドはその後、未修飾プロキシを通過します。おそらく、後で再利用するためのローカルコピーを作成しながら、プロキシは、クライアントへの連続メディアデータを提供します。キャッシュの正確な許容挙動は、セクション18.11に記載のキャッシュ応答ディレクティブによって与えられます。キャッシュは、それが現在、要求者へのストリームを提供している場合、ストリーム記述の低レベルの詳細は、オリジンサーバ上で変更されている可能性もあるとして任意のは、要求の記述答える必要があります。"
    },
    {
      "indent": 3,
      "text": "Note that an RTSP cache is of the \"cut-through\" variety. Rather than retrieving the whole resource from the origin server, the cache simply copies the streaming data as it passes by on its way to the client. Thus, it does not introduce additional latency.",
      "ja": "RTSPキャッシュは「カットスルー」多様であることに注意してください。むしろそれはクライアントへの途中で通過するときのように、キャッシュ単にコピーするストリーミングデータをオリジンサーバからの全体のリソースを取得するよりも。したがって、それは追加の遅延を導入しません。"
    },
    {
      "indent": 3,
      "text": "To the client, an RTSP proxy cache appears like a regular media server. To the media origin server, an RTSP proxy cache appears like a client. Just as an HTTP cache has to store the content type, content language, and so on for the objects it caches, a media cache has to store the presentation description. Typically, a cache eliminates all transport references (e.g., multicast information) from the presentation description, since these are independent of the data delivery from the cache to the client. Information on the encodings remains the same. If the cache is able to translate the cached media data, it would create a new presentation description with all the encoding possibilities it can offer.",
      "ja": "クライアントに、RTSPプロキシキャッシュは、通常のメディアサーバのように表示されます。メディアオリジンサーバに、RTSPプロキシキャッシュは、クライアントのように表示されます。 HTTPキャッシュは、それがキャッシュしたオブジェクトのようにコンテンツタイプ、コンテンツの言語、およびを保存するために持っているのと同じように、メディアキャッシュはプレゼンテーション記述を格納することがあります。これらは、クライアントにキャッシュからデータ配信の独立しているため、典型的には、キャッシュは、プレゼンテーション記述からすべてのトランスポート参照（例えば、マルチキャスト情報）を排除します。エンコーディングに関する情報は同じまま。キャッシュは、キャッシュされたメディアデータを変換することができれば、それが提供できるすべてのエンコーディングの可能性を持つ新しいプレゼンテーション記述を作成します。"
    },
    {
      "indent": 0,
      "text": "16.1. Validation Model",
      "section_title": true,
      "ja": "16.1. 検証モデル"
    },
    {
      "indent": 3,
      "text": "When a cache has a stale entry that it would like to use as a response to a client's request, it first has to check with the origin server (or possibly an intermediate cache with a fresh response) to see if its cached entry is still usable. This is called \"validating\" the cache entry. To avoid having to pay the overhead of retransmitting the full response if the cached entry is good, and at the same time avoiding having to pay the overhead of an extra round trip if the cached entry is invalid, RTSP supports the use of conditional methods.",
      "ja": "キャッシュは、クライアントの要求に対する応答として使用したいという古いエントリを持っている場合、それは最初にキャッシュされたエントリがまだ使用可能かどうかを確認するためにオリジンサーバ（あるいは新鮮なレスポンスを持つ中間キャッシュ）に確認する必要があります。これは、キャッシュエントリを「有効」と呼ばれています。キャッシュされたエントリが良好であれば、完全な応答を再送信すると同時に、キャッシュされたエントリが無効である場合、余分なラウンドトリップのオーバーヘッドを支払うこと回避のオーバーヘッドを支払うことを避けるために、RTSPは、条件付きメソッドの使用をサポートしています。"
    },
    {
      "indent": 3,
      "text": "The key protocol features for supporting conditional methods are those concerned with \"cache validators.\" When an origin server generates a full response, it attaches some sort of validator to it, which is kept with the cache entry. When a client (user agent or proxy cache) makes a conditional request for a resource for which it has a cache entry, it includes the associated validator in the request.",
      "ja": "条件付きメソッドをサポートするための主要なプロトコル機能は、に関するものであり、「キャッシュバリデータ。」オリジンサーバが完全な応答を生成するときに、キャッシュエントリに保持され、それにバリデータのいくつかの並べ替えを添付します。クライアント（ユーザエージェントまたはプロキシキャッシュ）がキャッシュエントリを持っているリソースのための条件付き要求を行う際に、その要求に関連したバリデータを含みます。"
    },
    {
      "indent": 3,
      "text": "The server then checks that validator against the current validator for the requested resource, and, if they match (see Section 16.1.3), it responds with a special status code (usually, 304 (Not Modified)) and no message body. Otherwise, it returns a full response (including message body). Thus, avoiding transmitting the full response if the validator matches and avoiding an extra round trip if it does not match.",
      "ja": "その後、サーバは、要求されたリソースの現在のバリデータに対してそのバリデータをチェックし、そして、彼らは（項16.1.3を参照）と一致した場合、それは特別なステータスコード（通常、304（）は変更されません）なしメッセージ本体で応答します。それ以外の場合は、（メッセージ本体を含む）完全な応答を返します。このように、バリデータが一致した場合には、完全な応答を送信し、それが一致しない場合、余分なラウンドトリップを回避回避することができます。"
    },
    {
      "indent": 3,
      "text": "In RTSP, a conditional request looks exactly the same as a normal request for the same resource, except that it carries a special header (which includes the validator) that implicitly turns the method (usually DESCRIBE or SETUP) into a conditional.",
      "ja": "RTSPでは、条件付き要求は、それが条件に暗黙的方法を回す特別なヘッダを（バリデータを含む）（通常DESCRIBEまたはSETUP）を運ぶことを除いて、同じリソースに対する通常の要求と全く同じに見えます。"
    },
    {
      "indent": 3,
      "text": "The protocol includes both positive and negative senses of cache-validating conditions. That is, it is possible to request that a method be performed either if and only if a validator matches or if and only if no validators match.",
      "ja": "プロトコルは、キャッシュ検証条件の正および負の感覚の両方を含みます。すなわち、この方法は、場合にのみバリデータが一致しないか、場合に限りないバリデータが一致する場合のいずれかで行われることを要求することが可能となります。"
    },
    {
      "indent": 6,
      "text": "Note: a response that lacks a validator may still be cached, and served from cache until it expires, unless this is explicitly prohibited by a cache directive (see Section 18.11). However, a cache cannot perform a conditional retrieval if it does not have a validator for the resource, which means it will not be refreshable after it expires.",
      "ja": "注意：バリデータが欠けている応答がまだキャッシュされ、そしてそれが、これは明示的にキャッシュディレクティブで禁止されていない限り、（項18.11を参照してください）有効期限が切れるまでキャッシュから提供することができます。それが満了した後、それはリフレッシュされませんを意味し、リソースのためのバリデータを持っていない場合は、キャッシュは条件付き検索を実行することはできません。"
    },
    {
      "indent": 3,
      "text": "Media streams that are being adapted based on the transport capacity between the server and the cache make caching more difficult. A server needs to consider how it views the caching of media streams that it adapts and potentially instruct any caches not to cache such streams.",
      "ja": "サーバとキャッシュ間の輸送能力に基づいて適合されているメディアストリームは、キャッシングをより困難にします。サーバーは、それがメディアのキャッシュを見て、それが適応することをストリームし、潜在的なストリームをキャッシュしない任意のキャッシュを指示する方法を検討する必要があります。"
    },
    {
      "indent": 0,
      "text": "16.1.1. Last-Modified Dates",
      "section_title": true,
      "ja": "16.1.1.  Last-Modifiedの日付"
    },
    {
      "indent": 3,
      "text": "The Last-Modified header (Section 18.27) value is often used as a cache validator. In simple terms, a cache entry is considered to be valid if the cache entry was created after the Last-Modified time.",
      "ja": "Last-Modifiedのヘッダ（セクション18.27）の値は、多くの場合、キャッシュ・バリデータとして使用されます。簡単に言えば、キャッシュエントリは、キャッシュエントリは最終更新時刻の後に作成された場合に有効であると考えられています。"
    },
    {
      "indent": 0,
      "text": "16.1.2. Message Body Tag Cache Validators",
      "section_title": true,
      "ja": "16.1.2. メッセージ本文のタグのキャッシュバリ"
    },
    {
      "indent": 3,
      "text": "The MTag response-header field-value, a message body tag, provides for an \"opaque\" cache validator. This might allow more reliable validation in situations where it is inconvenient to store modification dates, where the one-second resolution of RTSP-date values is not sufficient, or where the origin server wishes to avoid certain paradoxes that might arise from the use of modification dates.",
      "ja": "MTAGレスポンスヘッダフィールド値、メッセージのbodyタグは、「不透明な」キャッシュ・バリデータを提供します。これは、RTSP-日付の値の1秒の解像度が十分でない、またはオリジンサーバは、修正の使用から生じる可能性のある特定のパラドックスを避けたい場所、修正日を保存するために不便である状況でより信頼性の検証を、許可するかもしれません日付。"
    },
    {
      "indent": 3,
      "text": "Message body tags are described in Section 4.6",
      "ja": "メッセージ本文のタグがセクション4.6で説明されています"
    },
    {
      "indent": 0,
      "text": "16.1.3. Weak and Strong Validators",
      "section_title": true,
      "ja": "16.1.3. 強弱バリ"
    },
    {
      "indent": 3,
      "text": "Since both origin servers and caches will compare two validators to decide if they represent the same or different entities, one normally would expect that if the message body (i.e., the presentation description) or any associated message body headers changes in any way, then the associated validator would change as well. If this is true, then this validator is a \"strong validator\". The Message body (i.e., the presentation description) or any associated message body headers is named an entity for a better understanding.",
      "ja": "オリジンサーバとキャッシュの両方が、彼らは同じまたは異なるエンティティを表すかどうかを判断するために、2つのバリデータを比較しますので、一つは通常、メッセージ本体（すなわち、プレゼンテーション記述）、または任意の関連するメッセージ本体は、その後どのような方法で変化を、ヘッダあればという期待します関連するバリデータも同様に変化するであろう。これがtrueの場合、このバリデータは、「強いバリ」です。メッセージ本体（すなわち、プレゼンテーション記述）、または任意の関連するメッセージボディヘッダは、より良い理解のためにエンティティと命名されています。"
    },
    {
      "indent": 3,
      "text": "However, there might be cases when a server prefers to change the validator only on semantically significant changes and not when insignificant aspects of the entity change. A validator that does not always change when the resource changes is a \"weak validator\".",
      "ja": "サーバは時にエンティティの変更の些細な側面だけで意味的に重要な変更のバリデータを変更しないことを好むしかし、ケースがあるかもしれません。リソースの変更は常に変化していないバリデータは「弱いバリデータ」です。"
    },
    {
      "indent": 3,
      "text": "Message body tags are normally strong validators, but the protocol provides a mechanism to tag a message body tag as \"weak\". One can think of a strong validator as one that changes whenever the bits of an entity changes, while a weak value changes whenever the meaning of an entity changes. Alternatively, one can think of a strong validator as part of an identifier for a specific entity, while a weak validator is part of an identifier for a set of semantically equivalent entities.",
      "ja": "メッセージ本文のタグは、通常は強いバリデータであるが、プロトコルが「弱い」としてメッセージ本文タグをタグ付けするためのメカニズムを提供します。一つは、エンティティの意味が変更されるたびに、弱い値が変化しながら、エンティティの変更のたびビットを変更するものとして強いバリデータと考えることができます。弱いバリデータが意味的に等価なエンティティのセットのための識別子の一部である別の方法として、一つは、特定のエンティティの識別子の一部などの強力なバリデータと考えることができます。"
    },
    {
      "indent": 6,
      "text": "Note: One example of a strong validator is an integer that is incremented in stable storage every time an entity is changed.",
      "ja": "注：強力なバリデータの一例は、安定したストレージにエンティティが変更されるたびに増分される整数です。"
    },
    {
      "indent": 6,
      "text": "An entity's modification time, if represented with one-second resolution, could be a weak validator, since it is possible that the resource might be modified twice during a single second.",
      "ja": "リソースが単一の第2中に2回変更される可能性があるということができるので、エンティティの変更時間は、1秒の分解能で表されている場合、弱いバリデータである可能性があります。"
    },
    {
      "indent": 6,
      "text": "Support for weak validators is optional. However, weak validators allow for more efficient caching of equivalent objects.",
      "ja": "弱いバリデータのサポートはオプションです。しかし、弱いバリデータは、同等のオブジェクトのより効率的なキャッシングが可能になります。"
    },
    {
      "indent": 3,
      "text": "A \"use\" of a validator is either when a client generates a request and includes the validator in a validating header field or when a server compares two validators.",
      "ja": "クライアントが要求を生成して検証ヘッダフィールドとき、またはサーバは、2つのバリデータを比較にバリデータを含む場合、バリデータの「使用」とは、いずれかです。"
    },
    {
      "indent": 3,
      "text": "Strong validators are usable in any context. Weak validators are only usable in contexts that do not depend on exact equality of an entity. For example, either kind is usable for a conditional DESCRIBE of a full entity. However, only a strong validator is usable for a subrange retrieval, since otherwise the client might end up with an internally inconsistent entity.",
      "ja": "強力なバリデータは、任意のコンテキストで使用可能です。弱いバリデータは、エンティティの正確な等価性に依存しないコンテキストでのみ使用可能です。例えば、いずれかの種類は、条件付き完全エンティティのDESCRIBEために使用可能です。しかし、唯一の強力なバリデータは、そうでない場合は、クライアントが内部的に一貫性のないエンティティで終わるかもしれないので、サブレンジの検索のために使用可能です。"
    },
    {
      "indent": 3,
      "text": "Clients MAY issue DESCRIBE requests with either weak or strong validators. Clients MUST NOT use weak validators in other forms of requests.",
      "ja": "クライアントが弱いか強いバリデータのいずれかとのリクエストをDESCRIBE発行することができます。クライアントは、要求の他の形態で弱いバリデータを使用してはなりません。"
    },
    {
      "indent": 3,
      "text": "The only function that RTSP defines on validators is comparison. There are two validator comparison functions, depending on whether or not the comparison context allows the use of weak validators:",
      "ja": "RTSPは、バリデータに定義されて唯一の機能は、比較です。 2つのバリデータの比較関数は、比較文脈が弱いバリデータの使用を許可するか否かに応じて、あります。"
    },
    {
      "indent": 3,
      "text": "o The strong comparison function: in order to be considered equal, both validators MUST be identical in every way, and both MUST NOT be weak.",
      "ja": "強い比較機能○：等しいと見なされるためには、両方のバリデータは、あらゆる方法で同一でなければならない、との両方が弱いはずがありません。"
    },
    {
      "indent": 3,
      "text": "o The weak comparison function: in order to be considered equal, both validators MUST be identical in every way, but either or both of them MAY be tagged as \"weak\" without affecting the result.",
      "ja": "弱い比較機能○：等しいと見なされるためには、両方のバリデータは、あらゆる方法で同一でなければならないが、それらのいずれかまたは両方が結果に影響を与えることなく、「弱い」としてタグ付けすることができます。"
    },
    {
      "indent": 3,
      "text": "A message body tag is strong unless it is explicitly tagged as weak.",
      "ja": "それが明示的に弱いとしてタグ付けされていない限り、メッセージ本文のタグが強いです。"
    },
    {
      "indent": 3,
      "text": "A Last-Modified time, when used as a validator in a request, is implicitly weak unless it is possible to deduce that it is strong, using the following rules:",
      "ja": "最終更新時刻は、要求の中のバリデータとして使用した場合、次の規則を使用して、それが強いと推定することが可能である場合を除き、暗黙的に弱いです。"
    },
    {
      "indent": 3,
      "text": "o The validator is being compared by an origin server to the actual current validator for the entity and,",
      "ja": "バリデータは、エンティティの実際の現在のバリデータにオリジンサーバによって比較されているOと、"
    },
    {
      "indent": 3,
      "text": "o That origin server reliably knows that the associated entity did not change more than once during the second covered by the presented validator.",
      "ja": "Oそれオリジンサーバは、確実に関連するエンティティが提示バリでカバー秒の間に複数回変更していないことを知っています。"
    },
    {
      "indent": 3,
      "text": "OR",
      "ja": "または"
    },
    {
      "indent": 3,
      "text": "o The validator is about to be used by a client in an If-Modified-Since, because the client has a cache entry for the associated entity, and",
      "ja": "Oバリデータは、クライアントが関連するエンティティのためのキャッシュエントリがあるため、変更 - 開始にクライアントによって使用されようとしている、と"
    },
    {
      "indent": 3,
      "text": "o That cache entry includes a Date value, which gives the time when the origin server sent the original response, and",
      "ja": "そのキャッシュエントリがオリジンサーバが元の応答を送信した時刻を与えるDate値を含み、かつO"
    },
    {
      "indent": 3,
      "text": "o The presented Last-Modified time is at least 60 seconds before the Date value.",
      "ja": "O提示のLast-Modified時間が日付値の前に少なくとも60秒です。"
    },
    {
      "indent": 3,
      "text": "OR",
      "ja": "または"
    },
    {
      "indent": 3,
      "text": "o The validator is being compared by an intermediate cache to the validator stored in its cache entry for the entity, and",
      "ja": "バリデータは、エンティティのキ​​ャッシュエントリに格納されたバリの中間キャッシュによって比較され、O、及び"
    },
    {
      "indent": 3,
      "text": "o That cache entry includes a Date value, which gives the time when the origin server sent the original response, and",
      "ja": "そのキャッシュエントリがオリジンサーバが元の応答を送信した時刻を与えるDate値を含み、かつO"
    },
    {
      "indent": 3,
      "text": "o The presented Last-Modified time is at least 60 seconds before the Date value.",
      "ja": "O提示のLast-Modified時間が日付値の前に少なくとも60秒です。"
    },
    {
      "indent": 3,
      "text": "This method relies on the fact that if two different responses were sent by the origin server during the same second, but both had the same Last-Modified time, then at least one of those responses would have a Date value equal to its Last-Modified time. The arbitrary 60-second limit guards against the possibility that the Date and Last-Modified values are generated from different clocks or at somewhat different times during the preparation of the response. An implementation MAY use a value larger than 60 seconds, if it is believed that 60 seconds is too short.",
      "ja": "この方法は、二つの異なるレスポンスが同じ秒の間、オリジンサーバによって送信されますが、両方が同じ最終更新時刻を持っていた場合、それらの応答の少なくとも一つはそのLast-Modifiedのと同じ日付値を持っているという事実に依存しています時間。日付およびLast-Modifiedの値が応答の準備中に、異なるクロックまたは幾分異なる時間に生成される可能性に対して任意の60秒の限界ガード。 60秒は短すぎると考えられている場合、実装は、60秒以上の値を使用するかもしれません。"
    },
    {
      "indent": 3,
      "text": "If a client wishes to perform a subrange retrieval on a value for which it has only a Last-Modified time and no opaque validator, it MAY do this only if the Last-Modified time is strong in the sense described here.",
      "ja": "クライアントは、それが唯一のLast-Modified時間なし、不透明なバリデータを持っている値にサブレンジの検索を実行したい場合、それは最終更新時刻は、ここで説明した意味での強い場合にのみ、これを行うことができます。"
    },
    {
      "indent": 0,
      "text": "16.1.4. Rules for When to Use Message Body Tags and Last-Modified Dates",
      "section_title": true,
      "ja": "16.1.4. メッセージ本文タグとLast-Modifiedの日付を使用する場合のルール"
    },
    {
      "indent": 3,
      "text": "This document adopts a set of rules and recommendations for origin servers, clients, and caches regarding when various validator types ought to be used, and for what purposes.",
      "ja": "この文書では、さまざまなバリデータタイプが使用されるべき、と何の目的でに関するオリジンサーバ、クライアント、およびキャッシュのためのルールや推奨事項のセットを採用しています。"
    },
    {
      "indent": 3,
      "text": "RTSP origin servers:",
      "ja": "RTSPのオリジンサーバ："
    },
    {
      "indent": 3,
      "text": "o SHOULD send a message body tag validator unless it is not feasible to generate one.",
      "ja": "1を生成することは不可能である場合を除きOメッセージのbodyタグのバリデータを送るべきです。"
    },
    {
      "indent": 3,
      "text": "o MAY send a weak message body tag instead of a strong message body tag, if performance considerations support the use of weak message body tags, or if it is unfeasible to send a strong message body tag.",
      "ja": "パフォーマンスの考慮事項が弱いメッセージボディタグの使用をサポートしている場合、または強いメッセージ本文のタグを送信することは実現不可能である場合には、O、代わりに強力なメッセージのbodyタグの弱いメッセージボディタグを送信することができます。"
    },
    {
      "indent": 3,
      "text": "o SHOULD send a Last-Modified value if it is feasible to send one, unless the risk of a breakdown in semantic transparency that could result from using this date in an If-Modified-Since header would lead to serious problems. In other words, the preferred behavior for an RTSP origin server is to send both a strong message body tag and a Last-Modified value.",
      "ja": "1を送信することが可能であれば場合 - 変更-Sinceヘッダにこの日付を使用することから生じる可能性の意味的透明性の崩壊の危険性が深刻な問題につながる場合を除きoは、Last-Modifiedの値を送るべきです。言い換えれば、RTSPのオリジンサーバのための好適な動作は、強いメッセージのボディタグとLast-Modified値の両方を送信することです。"
    },
    {
      "indent": 3,
      "text": "In order to be legal, a strong message body tag MUST change whenever the associated entity value changes in any way. A weak message body tag SHOULD change whenever the associated entity changes in a semantically significant way.",
      "ja": "合法的であるために、強いメッセージbodyタグは、任意の方法でたびに関連付けられたエンティティ値の変更を変更しなければなりません。関連するエンティティを意味的に重要な方法で変更するたびに弱いメッセージボディタグは変更する必要があります。"
    },
    {
      "indent": 6,
      "text": "Note: in order to provide semantically transparent caching, an origin server MUST avoid reusing a specific strong message body tag value for two different entities or reusing a specific weak message body tag value for two semantically different entities. Cache entries might persist for arbitrarily long periods, regardless of expiration times, so it might be inappropriate to expect that a cache will never again attempt to validate an entry using a validator that it obtained at some point in the past.",
      "ja": "注：意味的に透過キャッシングを提供するために、オリジンサーバは、二つの異なるエンティティのための特定の強いメッセージ本文タグ値を再利用又は二意味的に異なるエンティティのための特定の弱いメッセージ本文タグ値を再使用を避けなければなりません。キャッシュエントリは関係なく、有効期限の、任意の長期間持続可能性があるので、キャッシュは再び、それは過去のある時点で取得したバリデータを使用してエントリを検証しようとしないことを期待するのは不適切かもしれません。"
    },
    {
      "indent": 3,
      "text": "RTSP clients:",
      "ja": "RTSPクライアント："
    },
    {
      "indent": 3,
      "text": "o If a message body tag has been provided by the origin server, MUST use that message body tag in any cache-conditional request (using If-Match or If-None-Match).",
      "ja": "Oメッセージのbodyタグは、オリジンサーバによって提供されている場合、（マッチした場合、または場合-なしマッチを使用して）任意のキャッシュ条件付き要求にそのメッセージボディタグを使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o If only a Last-Modified value has been provided by the origin server, SHOULD use that value in non-subrange cache-conditional requests (using If-Modified-Since).",
      "ja": "O Last-Modified値のみがオリジンサーバによって提供されている場合は、（変更される場合は--以来使用して）非サブレンジキャッシュ条件付きリクエストにその値を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "o If both a message body tag and a Last-Modified value have been provided by the origin server, SHOULD use both validators in cache-conditional requests.",
      "ja": "OメッセージのボディタグとLast-Modified値の両方がオリジンサーバによって提供されている場合は、キャッシュ条件付きリクエストの両方でバリデータを使うべきです。"
    },
    {
      "indent": 3,
      "text": "An RTSP origin server, upon receiving a conditional request that includes both a Last-Modified date (e.g., in an If-Modified-Since header) and one or more message body tags (e.g., in an If-Match,",
      "ja": "RTSPのオリジンサーバ、もしマッチで、例えば（および1つまたは複数のメッセージボディタグ（ヘッダ場合-ので修飾で、例えば）最終更新日時の両方を含む条件付きの要求を受信すると、"
    },
    {
      "indent": 3,
      "text": "If-None-Match, or If-Range header field) as cache validators, MUST NOT return a response status of 304 (Not Modified) unless doing so is consistent with all of the conditional header fields in the request.",
      "ja": "レンジ場合はヘッダフィールド）キャッシュバリデータとして、304の応答ステータスを返してはならない場合は、なしマッチ、または（そうすることが要求における条件付きヘッダフィールドのすべてと一致していない限り）変更されていません。"
    },
    {
      "indent": 6,
      "text": "Note: The general principle behind these rules is that RTSP servers and clients should transmit as much non-redundant information as is available in their responses and requests. RTSP systems receiving this information will make the most conservative assumptions about the validators they receive.",
      "ja": "注：これらのルールの背後にある一般的な原則は、その応答やリクエストで利用できるようRTSPサーバとクライアントが同じくらい非冗長情報を送信すべきであるということです。この情報を受信するRTSPシステムは、彼らが受け取るバリデータについての最も保守的な仮定を行います。"
    },
    {
      "indent": 0,
      "text": "16.1.5. Non-validating Conditionals",
      "section_title": true,
      "ja": "16.1.5. 非検証条件文"
    },
    {
      "indent": 3,
      "text": "The principle behind message body tags is that only the service author knows the semantics of a resource well enough to select an appropriate cache validation mechanism, and the specification of any validator comparison function more complex than octet equality would open up a can of worms. Thus, comparisons of any other headers are never used for purposes of validating a cache entry.",
      "ja": "メッセージのbodyタグの原理は、サービス作成者が適切なキャッシュ検証メカニズムを選択しても十分なリソース、およびワームの缶を開けるだろうオクテットの平等よりも複雑な任意のバリデータの比較機能の仕様の意味を知っているということです。このように、任意の他のヘッダの比較はキャッシュエントリを検証する目的のために使用されることはありません。"
    },
    {
      "indent": 0,
      "text": "16.2. Invalidation after Updates or Deletions",
      "section_title": true,
      "ja": "16.2. 更新または削除後の無効化"
    },
    {
      "indent": 3,
      "text": "The effect of certain methods performed on a resource at the origin server might cause one or more existing cache entries to become non-transparently invalid. That is, although they might continue to be \"fresh,\" they do not accurately reflect what the origin server would return for a new request on that resource.",
      "ja": "オリジンサーバのリソース上で実行される特定の方法の効果は、1つの以上の既存のキャッシュエントリが非透過無効になる場合があります。それは、彼らがであり続けるかもしれないが、「新鮮な、」彼らは正確にオリジンサーバはそのリソース上の新しい要求のために戻ってくるものを反映していない、です。"
    },
    {
      "indent": 3,
      "text": "There is no way for RTSP to guarantee that all such cache entries are marked invalid. For example, the request that caused the change at the origin server might not have gone through the proxy where a cache entry is stored. However, several rules help reduce the likelihood of erroneous behavior.",
      "ja": "RTSPは、そのようなすべてのキャッシュエントリが無効とマークされることを保証する方法はありません。例えば、オリジンサーバに変更を生じたリクエストはキャッシュエントリが保存されているプロキシを経ていない可能性があります。しかし、いくつかのルールは誤った行動の可能性を減らすのに役立ちます。"
    },
    {
      "indent": 3,
      "text": "In this section, the phrase \"invalidate an entity\" means that the cache will either remove all instances of that entity from its storage or mark these as \"invalid\" and in need of a mandatory revalidation before they can be returned in response to a subsequent request.",
      "ja": "このセクションでは、フレーズ「エンティティを無効には、」キャッシュがそのストレージからそのエンティティのすべてのインスタンスを削除するか、彼らは、その後に応じて返すことができます前に、「無効」と必須の再検証の必要があるとして、これらをマークするかということ要求。"
    },
    {
      "indent": 3,
      "text": "Some RTSP methods MUST cause a cache to invalidate an entity. This is either the entity referred to by the Request-URI or by the Location or Content-Location headers (if present). These methods are:",
      "ja": "いくつかのRTSPメソッドは、エンティティを無効にするキャッシュを起こす必要があります。これは、いずれかのエンティティは、Request-URIによって、または場所またはコンテンツロケーションヘッダー（存在する場合）によって参照されます。これらのメソッドは以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "o DESCRIBE",
      "ja": "O DESCRIBE"
    },
    {
      "indent": 3,
      "text": "o SETUP",
      "ja": "O設定"
    },
    {
      "indent": 3,
      "text": "In order to prevent DoS attacks, an invalidation based on the URI in a Location or Content-Location header MUST only be performed if the host part is the same as in the Request-URI.",
      "ja": "ホスト部分がRequest-URIと同じである場合は、DoS攻撃を防ぐために、場所またはContent-LocationヘッダにURIに基づいて、無効化のみを実行しなければなりません。"
    },
    {
      "indent": 3,
      "text": "A cache that passes through requests for methods it does not understand SHOULD invalidate any entities referred to by the Request-URI.",
      "ja": "それは理解していないメソッドの要求を通過したキャッシュは、Request-URIで参照されるすべてのエンティティを無効にすべきです。"
    },
    {
      "indent": 0,
      "text": "17. Status Code Definitions",
      "section_title": true,
      "ja": "17.ステータスコードの定義"
    },
    {
      "indent": 3,
      "text": "Where applicable, HTTP status codes (see Section 6 of [RFC7231]) are reused. See Table 4 in Section 8.1 for a listing of which status codes may be returned by which requests. All error messages, 4xx and 5xx, MAY return a body containing further information about the error.",
      "ja": "適用可能な場合、HTTPステータスコードは、（[RFC7231]のセクション6を参照）が再利用されます。ステータスコードは、その要求によって返される可能性があるの一覧については、8.1節の表4を参照してください。すべてのエラーメッセージ、4XXと5xxのは、エラーに関する詳細情報を含むボディを返す場合があります。"
    },
    {
      "indent": 0,
      "text": "17.1. Informational 1xx",
      "section_title": true,
      "ja": "17.1. 情報の1xx"
    },
    {
      "indent": 0,
      "text": "17.1.1. 100 Continue",
      "section_title": true,
      "ja": "17.1.1.  100は続行します"
    },
    {
      "indent": 3,
      "text": "The requesting agent SHOULD continue with its request. This interim response is used to inform the requesting agent that the initial part of the request has been received and has not yet been rejected by the responding agent. The requesting agent SHOULD continue by sending the remainder of the request or, if the request has already been completed, continue to wait for a final response (see Section 10.4). The responding agent MUST send a final response after the request has been completed.",
      "ja": "要求エージェントはその要求を継続する必要があります。この暫定応答は、要求の最初の部分が受信されていて、まだ応答エージェントによって拒否されていないことを要求エージェントに通知するために使用されています。要求エージェントは、要求が既に（項10.4を参照してください）最終応答を待ち続け、完了している場合は、要求の残りの部分を送信したりすることによって継続する必要があります。要求が完了した後に応答エージェントは、最終的な応答を送らなければなりません。"
    },
    {
      "indent": 0,
      "text": "17.2. Success 2xx",
      "section_title": true,
      "ja": "17.2. 成功2XX"
    },
    {
      "indent": 3,
      "text": "This class of status code indicates that the agent's request was successfully received, understood, and accepted.",
      "ja": "このクラスのステータスコードは、エージェントの要求が正常に受信されたことを示して理解し、受け入れられました。"
    },
    {
      "indent": 0,
      "text": "17.2.1. 200 OK",
      "section_title": true,
      "ja": "17.2.1.  200 OK"
    },
    {
      "indent": 3,
      "text": "The request has succeeded. The information returned with the response is dependent on the method used in the request.",
      "ja": "リクエストが成功しました。応答で返された情報は、要求に使用される方法に依存しています。"
    },
    {
      "indent": 0,
      "text": "17.3. Redirection 3xx",
      "section_title": true,
      "ja": "17.3. リダイレクション3XX"
    },
    {
      "indent": 3,
      "text": "The notation \"3xx\" indicates response codes from 300 to 399 inclusive that are meant for redirection. We use the notation \"3rr\" to indicate all 3xx codes used for redirection, i.e., excluding 304. The 304 response code appears here, rather than a 2xx response code, which would have been appropriate; 304 has also been used in RTSP 1.0 [RFC2326].",
      "ja": "表記「3XX」はリダイレクションのために意味されている300 399に含めてから応答コードを示しています。我々は、すなわち、304を除いた304応答コードはむしろ適切であったであろう2XX応答コードよりも、ここで表示され、リダイレクションのために使用されるすべての3xxコードを示すために表記「3RR」を使用します。 304は、RTSP 1.0 [RFC2326]で使用されてきました。"
    },
    {
      "indent": 3,
      "text": "Within RTSP, redirection may be used for load-balancing or redirecting stream requests to a server topologically closer to the agent. Mechanisms to determine topological proximity are beyond the scope of this specification.",
      "ja": "RTSPの中では、リダイレクトは、ロード・バランシングやエージェントへのトポロジ的に近いサーバーにストリーム要求をリダイレクトするために使用することができます。トポロジカル近接性を決定するメカニズムはこの仕様の範囲を超えています。"
    },
    {
      "indent": 3,
      "text": "A 3rr code MAY be used to respond to any request. The Location header MUST be included in any 3rr response. It is RECOMMENDED that they are used if necessary before a session is established, i.e., in response to DESCRIBE or SETUP. However, in cases where a server is not able to send a REDIRECT request to the agent, the server MAY need to resort to using 3rr responses to inform an agent with an established session about the need for redirecting the session. If a 3rr response is received for a request in relation to an established session, the agent SHOULD send a TEARDOWN request for the session and MAY reestablish the session using the resource indicated by the Location.",
      "ja": "3RRコードは、任意の要求に応答するために使用されるかもしれません。 Locationヘッダは任意3RR応答に含まれなければなりません。つまり、セッションが確立される前に、必要に応じて、彼らはDESCRIBEまたはSETUPに応じて、使用することをお勧めします。ただし、サーバーがエージェントにリダイレクト要求を送信することができない場合には、サーバがセッションをリダイレクトするための必要性について確立されたセッションでエージェントを知らせるために3RR応答を使用してに頼る必要があるかもしれません。 3RR応答が確立されたセッションに関連する要求を受信した場合、エージェントは、セッションのTEARDOWN要求を送信しなければならず、場所によって示されるリソースを使用してセッションを再確立するかもしれません。"
    },
    {
      "indent": 3,
      "text": "If the Location header is used in a response, it MUST contain an absolute URI pointing out the media resource the agent is redirected to; the URI MUST NOT only contain the hostname.",
      "ja": "ロケーションヘッダが応答に使用されている場合は、エージェントがにリダイレクトされるメディアリソースを指摘絶対URIを含まなければなりません。 URIは、ホスト名のみを含めることはできません。"
    },
    {
      "indent": 3,
      "text": "In the event that an unknown 3rr status code is received, the agent SHOULD behave as if a 302 response code had been received (Section 17.3.3).",
      "ja": "302応答コード（セクション17.3.3）を受けていたかのように、未知の3RRステータスコードが受信された場合に、エージェントが動作する必要があり。"
    },
    {
      "indent": 0,
      "text": "17.3.1. 300",
      "section_title": true,
      "ja": "１７。３。１。 ３００"
    },
    {
      "indent": 3,
      "text": "The 300 response code is not used in RTSP 2.0.",
      "ja": "300レスポンスコードは、RTSP 2.0で使用されていません。"
    },
    {
      "indent": 0,
      "text": "17.3.2. 301 Moved Permanently",
      "section_title": true,
      "ja": "17.3.2.  301永久移動します"
    },
    {
      "indent": 3,
      "text": "The requested resource is moved permanently and resides now at the URI given by the Location header. The user agent SHOULD redirect automatically to the given URI. This response MUST NOT contain a message body. The Location header MUST be included in the response.",
      "ja": "要求されたリソースは、永続的に移動し、Locationヘッダによって指定されたURIに今存在しています。ユーザエージェントは、指定されたURIに自動的にリダイレクトする必要があります。この応答は、メッセージ本体を含んではなりません。 Locationヘッダは、応答に含まれなければなりません。"
    },
    {
      "indent": 0,
      "text": "17.3.3. 302 Found",
      "section_title": true,
      "ja": "17.3.3. 発見302"
    },
    {
      "indent": 3,
      "text": "The requested resource resides temporarily at the URI given by the Location header. This response is intended to be used for many types of temporary redirects, e.g., load balancing. It is RECOMMENDED that the server set the reason phrase to something more meaningful than \"Found\" in these cases. The Location header MUST be included in the response. The user agent SHOULD redirect automatically to the given URI. This response MUST NOT contain a message body.",
      "ja": "要求されたリソースはLocationヘッダにより指定されたURIに一時的に存在します。この応答は、一時的なリダイレクトの多くの種類、例えば、負荷分散のために使用されることを意図しています。サーバーがこれらのケースで「発見」よりも、より意味のあるものに理由フレーズを設定することをお勧めします。 Locationヘッダは、応答に含まれなければなりません。ユーザエージェントは、指定されたURIに自動的にリダイレクトする必要があります。この応答は、メッセージ本体を含んではなりません。"
    },
    {
      "indent": 3,
      "text": "This example shows a client being redirected to a different server:",
      "ja": "この例では、別のサーバーにリダイレクトされているクライアントを示しています。"
    },
    {
      "indent": 5,
      "text": "C->S: SETUP rtsp://example.com/fizzle/foo RTSP/2.0 CSeq: 2 Transport: RTP/AVP/TCP;unicast;interleaved=0-1 Accept-Ranges: npt, smpte, clock User-Agent: PhonyClient/1.2",
      "ja": "C-> S：SETUPのRTSP：//example.com/fizzle/foo RTSP / 2.0のCSeq：2トランスポート：RTP / AVP / TCP、ユニキャスト、インターリーブ= 0~1のAccept-範囲：NPT、SMPTE、クロックのUser-Agent ：PhonyClient / 1.2"
    },
    {
      "indent": 5,
      "text": "S->C: RTSP/2.0 302 Try Other Server CSeq: 2 Location: rtsp://s2.example.com:8001/fizzle/foo",
      "ja": "S-> C：RTSP / 2.0 302は、他のサーバのCSeqを試し：2ロケーション：RTSP：//s2.example.com：8001 /不首尾/ FOO"
    },
    {
      "indent": 0,
      "text": "17.3.4. 303 See Other",
      "section_title": true,
      "ja": "17.3.4.  303を参照してくださいその他"
    },
    {
      "indent": 3,
      "text": "This status code MUST NOT be used in RTSP 2.0. However, it was allowed in RTSP 1.0 [RFC2326].",
      "ja": "このステータスコードは、RTSP 2.0で使用してはいけません。しかし、RTSP 1.0 [RFC2326]で許可されました。"
    },
    {
      "indent": 0,
      "text": "17.3.5. 304 Not Modified",
      "section_title": true,
      "ja": "17.3.5.  304は変更されません"
    },
    {
      "indent": 3,
      "text": "If the agent has performed a conditional DESCRIBE or SETUP (see Sections 18.25 and 18.26) and the requested resource has not been modified, the server SHOULD send a 304 response. This response MUST NOT contain a message body.",
      "ja": "薬剤はDESCRIBE条件や設定を行った（セクション18.25と18.26を参照）、要求されたリソースが変更されていない場合、サーバは304応答を送信すべきです。この応答は、メッセージ本体を含んではなりません。"
    },
    {
      "indent": 3,
      "text": "The response MUST include the following header fields:",
      "ja": "応答は、次ヘッダフィールドを含める必要があります。"
    },
    {
      "indent": 3,
      "text": "o Date",
      "ja": "データ"
    },
    {
      "indent": 3,
      "text": "o MTag or Content-Location, if the headers would have been sent in a 200 response to the same request.",
      "ja": "O MTAGまたはContent-場所、ヘッダが同じリクエストに対して200応答で送られてきたならば。"
    },
    {
      "indent": 3,
      "text": "o Expires and Cache-Control if the field-value might differ from that sent in any previous response for the same variant.",
      "ja": "oが有効期限とのCache-Controlは、フィールド値が同じバリアントに対する以前の応答で送信されたものとは異なる場合があります。"
    },
    {
      "indent": 3,
      "text": "This response is independent for the DESCRIBE and SETUP requests. That is, a 304 response to DESCRIBE does NOT imply that the resource content is unchanged (only the session description) and a 304 response to SETUP does NOT imply that the resource description is unchanged. The MTag and If-Match header (Section 18.24) may be used to link the DESCRIBE and SETUP in this manner.",
      "ja": "この応答は、記述し、SETUP要求のための独立しています。すなわち、リソースコンテンツが変更されていないことを意味するものではない記述するために304応答（のみセッション記述）とSETUPに304応答は、リソース記述が変更されていないことを意味するものではない、です。 MTAGともしマッチヘッダ（セクション18.24）は、このように記述し、SETUPをリンクするために使用されてもよいです。"
    },
    {
      "indent": 0,
      "text": "17.3.6. 305 Use Proxy",
      "section_title": true,
      "ja": "17.3.6.  305プロキシを使用"
    },
    {
      "indent": 3,
      "text": "The requested resource MUST be accessed through the proxy given by the Location header that MUST be included. The Location header field-value gives the URI of the proxy. The recipient is expected to repeat this single request via the proxy. 305 responses MUST only be generated by origin servers.",
      "ja": "要求されたリソースを含まなければなりませんLocationヘッダによって指定されたプロキシを介してアクセスしなければなりません。ロケーションヘッダーフィールド値は、プロキシのURIを与えます。受信者は、プロキシを経由してこの単一の要求を繰り返すことが予想されます。 305個の応答が唯一のオリジンサーバによって生成されなければなりません。"
    },
    {
      "indent": 0,
      "text": "17.4. Client Error 4xx",
      "section_title": true,
      "ja": "17.4. クライアントエラーの4xx"
    },
    {
      "indent": 0,
      "text": "17.4.1. 400 Bad Request",
      "section_title": true,
      "ja": "17.4.1.  400不正な要求"
    },
    {
      "indent": 3,
      "text": "The request could not be understood by the agent due to malformed syntax. The agent SHOULD NOT repeat the request without modifications. If the request does not have a CSeq header, the agent MUST NOT include a CSeq in the response.",
      "ja": "リクエストの文法が間違っているため、エージェントによって理解することができませんでした。エージェントは、修正して再度要求してください。要求がのCSeqヘッダーを持っていない場合は、エージェントが応答のCSeqを含んではいけません。"
    },
    {
      "indent": 0,
      "text": "17.4.2. 401 Unauthorized",
      "section_title": true,
      "ja": "17.4.2.  401無許可"
    },
    {
      "indent": 3,
      "text": "The request requires user authentication using the HTTP authentication mechanism [RFC7235]. The usage of the error code is defined in [RFC7235] and any applicable HTTP authentication scheme, such as Digest [RFC7616]. The response is to include a WWW-Authenticate header (Section 18.58) field containing a challenge applicable to the requested resource. The agent can repeat the request with a suitable Authorization header field. If the request already included authorization credentials, then the 401 response indicates that authorization has been refused for those credentials. If the 401 response contains the same challenge as the prior response, and the user agent has already attempted authentication at least once, then the user SHOULD be presented the message body that was given in the response, since that message body might include relevant diagnostic information.",
      "ja": "要求は、HTTP認証メカニズム[RFC7235]を使用して、ユーザ認証を必要とします。エラーコードの使用は[RFC7235]などのダイジェストなどの任意の適用可能なHTTP認証方式、[RFC7616]で定義されています。応答は、要求されたリソースに適用可能なチャレンジを含むWWW-Authenticateヘッダ（セクション18.58）フィールドを含めることです。エージェントは、適切なAuthorizationヘッダフィールドで要求を繰り返すことができます。要求が既に認証資格情報が含まれている場合、401レスポンスは認証がこれらの資格情報のために拒否されたことを示しています。 401応答は、前の応答と同じチャレンジを含み、ユーザエージェントが既に少なくとも一回の認証を試みた場合、ユーザーは、メッセージ本体が、関連する診断情報を含むかもしれないので、応答して与えられたメッセージ本体を提示すべき。"
    },
    {
      "indent": 0,
      "text": "17.4.3. 402 Payment Required",
      "section_title": true,
      "ja": "17.4.3.  402支払いが必要"
    },
    {
      "indent": 3,
      "text": "This code is reserved for future use.",
      "ja": "このコードは、将来の使用のために予約されています。"
    },
    {
      "indent": 0,
      "text": "17.4.4. 403 Forbidden",
      "section_title": true,
      "ja": "17.4.4.  403禁止します"
    },
    {
      "indent": 3,
      "text": "The agent understood the request, but is refusing to fulfill it. Authorization will not help, and the request SHOULD NOT be repeated. If the agent wishes to make public why the request has not been fulfilled, it SHOULD describe the reason for the refusal in the message body. If the agent does not wish to make this information available to the agent, the status code 404 (Not Found) can be used instead.",
      "ja": "エージェントは、要求を理解したが、それを実行することを拒否しています。承認は助けにはなりませんし、要求が繰り返されるべきではありません。エージェントは、要求が満たされていない理由を公表することを希望する場合は、メッセージ本文の拒否の理由を説明する必要があります。エージェントは、エージェントがこの情報を利用できるようにしたくない場合は、ステータスコード404（見つかりません）が代わりに使用することができます。"
    },
    {
      "indent": 0,
      "text": "17.4.5. 404 Not Found",
      "section_title": true,
      "ja": "17.4.5.  404お探しのページが見つかりませんでした"
    },
    {
      "indent": 3,
      "text": "The agent has not found anything matching the Request-URI. No indication is given of whether the condition is temporary or permanent. The 410 (Gone) status code SHOULD be used if the agent knows, through some internally configurable mechanism, that an old resource is permanently unavailable and has no forwarding address.",
      "ja": "エージェントは、Request-URIに一致するものを見つけていません。表示なしは、条件が一時的または恒久的であるかどうかについて説明されていません。エージェントが知っていれば410（ゴーン）ステータスコードは、古いリソースが恒久的に利用不可で転送アドレスを持っていないことを、いくつかの内部的に設定可能なメカニズムを介して、使用されるべきです。"
    },
    {
      "indent": 3,
      "text": "This status code is commonly used when the agent does not wish to reveal exactly why the request has been refused, or when no other response is applicable.",
      "ja": "エージェントは、要求が拒否された理由を正確に明らかにすることを希望していないとき、または他の応答が適用されない場合は、このステータスコードは一般的に使用されます。"
    },
    {
      "indent": 0,
      "text": "17.4.6. 405 Method Not Allowed",
      "section_title": true,
      "ja": "17.4.6.  405メソッドは許可されていません"
    },
    {
      "indent": 3,
      "text": "The method specified in the request is not allowed for the resource identified by the Request-URI. The response MUST include an Allow header containing a list of valid methods for the requested resource. This status code is also to be used if a request attempts to use a method not indicated during SETUP.",
      "ja": "要求で指定されたメソッドは、Request-URIによって識別されたリソースのために許可されていません。応答は、要求されたリソースのための有効な方法のリストを含む許可ヘッダを含まなければなりません。このステータスコードは、要求がセットアップ中に示されていないメソッドを使用しようとする場合に使用されることもあります。"
    },
    {
      "indent": 0,
      "text": "17.4.7. 406 Not Acceptable",
      "section_title": true,
      "ja": "17.4.7. 許容できない406"
    },
    {
      "indent": 3,
      "text": "The resource identified by the request is only capable of generating response message bodies that have content characteristics not acceptable according to the Accept headers sent in the request.",
      "ja": "リクエストによって識別されたリソースは、リクエストで送信された受け入れヘッダによれば受け入れられないコンテンツ特性を有する応答メッセージ本文を生成することができるだけです。"
    },
    {
      "indent": 3,
      "text": "The response SHOULD include a message body containing a list of available message body characteristics and location(s) from which the user or user agent can choose the one most appropriate. The message body format is specified by the media type given in the Content-Type header field. Depending upon the format and the capabilities of the user agent, selection of the most appropriate choice MAY be performed automatically. However, this specification does not define any standard for such automatic selection.",
      "ja": "応答は、ユーザーまたはユーザーエージェントが最も適切なものを選択することができ、そこから使用可能なメッセージボディの特性及び位置（単数または複数）のリストを含むメッセージ本体を含むべきです。メッセージ本文の形式は、Content-Typeヘッダフィールドで指定されたメディアタイプによって指定されます。フォーマットやユーザエージェントの能力に応じて、最も適切な選択の選択が自動的に実行することができます。しかし、この仕様書は、そのような自動選択のための任意の標準を定義していません。"
    },
    {
      "indent": 3,
      "text": "If the response could be unacceptable, a user agent SHOULD temporarily stop receipt of more data and query the user for a decision on further actions.",
      "ja": "レスポンスが受け入れられないことができれば、ユーザエージェントは一時的に、より多くのデータの受信を停止し、さらにアクションの決定のためにユーザに問い合わせるべきです。"
    },
    {
      "indent": 0,
      "text": "17.4.8. 407 Proxy Authentication Required",
      "section_title": true,
      "ja": "17.4.8.  407プロキシ認証が必要"
    },
    {
      "indent": 3,
      "text": "This code is similar to 401 (Unauthorized) (Section 17.4.2), but it indicates that the client must first authenticate itself with the proxy. The usage of this error code is defined in [RFC7235] and any applicable HTTP authentication scheme, such as Digest [RFC7616]. The proxy MUST return a Proxy-Authenticate header field (Section 18.34) containing a challenge applicable to the proxy for the requested resource.",
      "ja": "このコードは401（Unauthorized）（セクション17.4.2）に似ていますが、クライアントはまず自分をプロキシで認証しなければならないことを示しています。このエラーコードの使用は[RFC7235]などのダイジェストなどの任意の適用可能なHTTP認証方式、[RFC7616]で定義されています。プロキシは、要求されたリソースのプロキシに適用チャレンジを含むプロキシ認証ヘッダフィールド（セクション18.34）を返さなければなりません。"
    },
    {
      "indent": 0,
      "text": "17.4.9. 408 Request Timeout",
      "section_title": true,
      "ja": "17.4.9.  408要求タイムアウト"
    },
    {
      "indent": 3,
      "text": "The agent did not produce a request within the time that the agent was prepared to wait. The agent MAY repeat the request without modifications at any later time.",
      "ja": "エージェントは、エージェントが待機するように調製された時間内に要求を生成しませんでした。エージェントは、後で変更することなく、要求を繰り返してもよいです。"
    },
    {
      "indent": 0,
      "text": "17.4.10. 410 Gone",
      "section_title": true,
      "ja": "17.4.10.  410ゴーン"
    },
    {
      "indent": 3,
      "text": "The requested resource is no longer available at the server and the forwarding address is not known. This condition is expected to be considered permanent. If the server does not know, or has no facility to determine, whether or not the condition is permanent, the status code 404 (Not Found) SHOULD be used instead. This response is cacheable unless indicated otherwise.",
      "ja": "要求されたリソースはサーバーで使用できなくなり、転送アドレスが知られていません。この状態は永久的と見なされることが予想されます。サーバは状態が永久的であるかどうか、知っている、または決定するための施設を持っていないいない場合は、ステータスコード404（見つかりません）が代わりに使用する必要があります。特に指示がない限り、このレスポンスはキャッシュ可能です。"
    },
    {
      "indent": 3,
      "text": "The 410 response is primarily intended to assist the task of repository maintenance by notifying the recipient that the resource is intentionally unavailable and that the server owners desire that remote links to that resource be removed. Such an event is common for limited-time, promotional services and for resources belonging to individuals no longer working at the server's site. It is not necessary to mark all permanently unavailable resources as \"gone\" or to keep the mark for any length of time -- that is left to the discretion of the owner of the server.",
      "ja": "410応答は、主にリソースが意図的に利用できない受信者に通知することによって、サーバの所有者がそのリソースへのリモートリンクが削除されることを望むことリポジトリメンテナンスの作業を支援することを意図しています。このようなイベントは、期間限定、プロモーションサービスのために、サーバーのサイトで働いて、もはや個人に属するリソースのための一般的です。サーバーの所有者の裁量に任されている - 「ゴーン」として、すべての永久利用できないリソースをマークするか、時間の任意の長さのためのマークを維持する必要はありません。"
    },
    {
      "indent": 0,
      "text": "17.4.11. 412 Precondition Failed",
      "section_title": true,
      "ja": "17.4.11.  412前提条件の失敗"
    },
    {
      "indent": 3,
      "text": "The precondition given in one or more of the 'if-' request-header fields evaluated to false when it was tested on the agent. See these sections for the 'if-' headers: If-Match Section 18.24, If-Modified-Since Section 18.25, and If-None-Match Section 18.26. This response code allows the agent to place preconditions on the current resource meta-information (header field data) and, thus, prevent the requested method from being applied to a resource other than the one intended.",
      "ja": "前提条件は、それがエージェント上で試験したときに偽と評価「IF-」リクエストヘッダフィールドの一つ以上に与えられます。 「IF-」ヘッダのためにこれらのセクションを参照してください。もしマッチセクション18.24、変更された場合-ので、セクション18.25、とIF-なしマッチ節18.26。この応答コードは、エージェントが現在のリソースメタ情報の前提条件（ヘッダフィールドデータ）を配置し、したがって、意図したもの以外のリソースに適用されることから、要求されたメソッドを防止することを可能にします。"
    },
    {
      "indent": 0,
      "text": "17.4.12. 413 Request Message Body Too Large",
      "section_title": true,
      "ja": "17.4.12.  413リクエストメッセージ本文が大きすぎます"
    },
    {
      "indent": 3,
      "text": "The agent is refusing to process a request because the request message body is larger than the agent is willing or able to process. The agent MAY close the connection to prevent the requesting agent from continuing the request.",
      "ja": "エージェントは、要求メッセージの本体は、エージェントが喜んまたは処理することができるよりも大きいため、要求を処理するために拒否されます。エージェントは、要求を続けてから、要求エージェントを防ぐために、接続を閉じます。"
    },
    {
      "indent": 3,
      "text": "If the condition is temporary, the agent SHOULD include a Retry-After header field to indicate that it is temporary and after what time the requesting agent MAY try again.",
      "ja": "条件が一時的である場合、エージェントは、それが一時的なもので、何時間後に要求エージェントが再度お試し可能性があることを示すために再試行-Afterヘッダフィールドを含むべきです。"
    },
    {
      "indent": 0,
      "text": "17.4.13. 414 Request-URI Too Long",
      "section_title": true,
      "ja": "17.4.13.  414のRequest-URIが長すぎます"
    },
    {
      "indent": 3,
      "text": "The responding agent is refusing to service the request because the Request-URI is longer than the agent is willing to interpret. This rare condition is only likely to occur when an agent has used a request with long query information, when the agent has descended into a URI \"black hole\" of redirection (e.g., a redirected URI prefix that points to a suffix of itself), or when the agent is under attack by an agent attempting to exploit security holes present in some agents using fixed-length buffers for reading or manipulating the Request-URI.",
      "ja": "応答エージェントは、エージェントが解釈していく所存ですよりも、リクエスト-URIが長くなるため、要求のサービスを拒否しています。このまれな状況では、エージェントは、エージェントがリダイレクトのURI「ブラックホール」（例えば、自身のサフィックスを指しリダイレクトURIプレフィックス）に降りた長いクエリ情報との要求を、使用しているときに発生する唯一の可能性があり、またはエージェントがRequest-URIを読み取るまたは操作するための固定長バッファを使用して、いくつかの薬剤中に存在するセキュリティホールを悪用しようとするエージェントによって攻撃を受けている場合。"
    },
    {
      "indent": 0,
      "text": "17.4.14. 415 Unsupported Media Type",
      "section_title": true,
      "ja": "17.4.14.  415サポートされていないメディアタイプ"
    },
    {
      "indent": 3,
      "text": "The server is refusing to service the request because the message body of the request is in a format not supported by the requested resource for the requested method.",
      "ja": "サーバーは、要求のメッセージボディには要求されたメソッドのために要求されたリソースによってサポートされていない形式であるため、要求のサービスを拒否しています。"
    },
    {
      "indent": 0,
      "text": "17.4.15. 451 Parameter Not Understood",
      "section_title": true,
      "ja": "17.4.15.  451パラメータ分かりません"
    },
    {
      "indent": 3,
      "text": "The recipient of the request does not support one or more parameters contained in the request. When returning this error message the agent SHOULD return a message body containing the offending parameter(s).",
      "ja": "リクエストの受信者は、要求に含まれる1つ以上のパラメータをサポートしていません。このエラーメッセージを返す場合、エージェントは、問題のパラメータ（単数または複数）を含むメッセージ本体を返すべきです。"
    },
    {
      "indent": 0,
      "text": "17.4.16. 452 Illegal Conference Identifier",
      "section_title": true,
      "ja": "17.4.16.  452不正な会議識別子"
    },
    {
      "indent": 3,
      "text": "This status code MUST NOT be used in RTSP 2.0. However, it was allowed in RTSP 1.0 [RFC2326].",
      "ja": "このステータスコードは、RTSP 2.0で使用してはいけません。しかし、RTSP 1.0 [RFC2326]で許可されました。"
    },
    {
      "indent": 0,
      "text": "17.4.17. 453 Not Enough Bandwidth",
      "section_title": true,
      "ja": "17.4.17.  453帯域幅不足"
    },
    {
      "indent": 3,
      "text": "The request was refused because there was insufficient bandwidth. This may, for example, be the result of a resource reservation failure.",
      "ja": "十分な帯域幅があったため、要求は拒否されました。これは、例えば、リソース予約の失敗の結果であり得ます。"
    },
    {
      "indent": 0,
      "text": "17.4.18. 454 Session Not Found",
      "section_title": true,
      "ja": "17.4.18.  454セッションが見つかりません"
    },
    {
      "indent": 3,
      "text": "The RTSP session identifier in the Session header is missing, is invalid, or has timed out.",
      "ja": "セッションヘッダ内のRTSPセッション識別子が不足している、無効である、またはタイムアウトしました。"
    },
    {
      "indent": 0,
      "text": "17.4.19. 455 Method Not Valid in This State",
      "section_title": true,
      "ja": "17.4.19. この状態で455メソッド有効でありません"
    },
    {
      "indent": 3,
      "text": "The agent cannot process this request in its current state. The response MUST contain an Allow header to make error recovery possible.",
      "ja": "エージェントは現在の状態でこの要求を処理できません。応答がエラーリカバリを可能にすることを許可するヘッダを含まなければなりません。"
    },
    {
      "indent": 0,
      "text": "17.4.20. 456 Header Field Not Valid for Resource",
      "section_title": true,
      "ja": "17.4.20.  456ヘッダーフィールドリソースには有効ではありません"
    },
    {
      "indent": 3,
      "text": "The targeted agent could not act on a required request-header. For example, if PLAY request contains the Range header field but the stream does not allow seeking. This error message may also be used for specifying when the time format in Range is impossible for the resource. In that case, the Accept-Ranges header MUST be returned to inform the agent of which formats are allowed.",
      "ja": "標的薬剤は、必要なリクエストヘッダに作用することができませんでした。 PLAY要求がRangeヘッダフィールドが含まれているが、たとえば、ストリームが求めていることはできません。このエラーメッセージはまた、範囲の時間フォーマットはリソースのため不可能である場合に指定するために使用することができます。その場合には、受け入れ-範囲ヘッダはフォーマットが許可されたエージェントに通知するために戻さなければなりません。"
    },
    {
      "indent": 0,
      "text": "17.4.21. 457 Invalid Range",
      "section_title": true,
      "ja": "17.4.21.  457無効な範囲"
    },
    {
      "indent": 3,
      "text": "The Range value given is out of bounds, e.g., beyond the end of the presentation.",
      "ja": "所定の範囲の値が範囲外、例えば、プレゼンテーションの終わりを超えています。"
    },
    {
      "indent": 0,
      "text": "17.4.22. 458 Parameter Is Read-Only",
      "section_title": true,
      "ja": "17.4.22.  458パラメータは読み取り専用です"
    },
    {
      "indent": 3,
      "text": "The parameter to be set by SET_PARAMETER can be read but not modified. When returning this error message, the sender SHOULD return a message body containing the offending parameter(s).",
      "ja": "SET_PARAMETERによって設定されるパラメータは読みますが変更されないことができます。このエラーメッセージを返す場合、送信者は、問題のパラメータ（単数または複数）を含むメッセージ本体を返すべきです。"
    },
    {
      "indent": 0,
      "text": "17.4.23. 459 Aggregate Operation Not Allowed",
      "section_title": true,
      "ja": "17.4.23.  459集計操作は許可されていません"
    },
    {
      "indent": 3,
      "text": "The requested method may not be applied on the URI in question since it is an aggregate (presentation) URI. The method may be applied on a media URI.",
      "ja": "それは集計（プレゼンテーション）URIであるため、要求された方法は、問題のURIに適用されない場合があります。この方法は、メディアURIに適用することができます。"
    },
    {
      "indent": 0,
      "text": "17.4.24. 460 Only Aggregate Operation Allowed",
      "section_title": true,
      "ja": "17.4.24.  460のみ集計操作可"
    },
    {
      "indent": 3,
      "text": "The requested method may not be applied on the URI in question since it is not an aggregate control (presentation) URI. The method may be applied on the aggregate control URI.",
      "ja": "それは、集約制御（プレゼンテーション）URIないので要求された方法は、当該URIに適用されなくてもよいです。この方法は、凝集体コントロールURIに適用することができます。"
    },
    {
      "indent": 0,
      "text": "17.4.25. 461 Unsupported Transport",
      "section_title": true,
      "ja": "17.4.25.  461サポートされていない交通"
    },
    {
      "indent": 3,
      "text": "The Transport field did not contain a supported transport specification.",
      "ja": "トランスポートフィールドは、サポートされているトランスポート仕様が含まれていませんでした。"
    },
    {
      "indent": 0,
      "text": "17.4.26. 462 Destination Unreachable",
      "section_title": true,
      "ja": "17.4.26.  462宛先到達不能"
    },
    {
      "indent": 3,
      "text": "The data transmission channel could not be established because the agent address could not be reached. This error will most likely be the result of an agent attempt to place an invalid dest_addr parameter in the Transport field.",
      "ja": "エージェント・アドレスは到達できなかったので、データ伝送チャネルを確立できませんでした。このエラーは、最も可能性の高い交通フィールドに無効なdest_addrはパラメータを配置するエージェントの試みの結果になります。"
    },
    {
      "indent": 0,
      "text": "17.4.27. 463 Destination Prohibited",
      "section_title": true,
      "ja": "17.4.27.  463デスティネーション禁止"
    },
    {
      "indent": 3,
      "text": "The data transmission channel was not established because the server prohibited access to the agent address. This error is most likely the result of an agent attempt to redirect media traffic to another destination with a dest_addr parameter in the Transport header.",
      "ja": "サーバーは、エージェント・アドレスへのアクセスを禁止しているため、データ伝送チャネルが確立されませんでした。このエラーは、最も可能性の高いトランスポートヘッダのdest_addrはパラメータで別の宛先にメディアトラフィックをリダイレクトするための薬剤の試みの結果です。"
    },
    {
      "indent": 0,
      "text": "17.4.28. 464 Data Transport Not Ready Yet",
      "section_title": true,
      "ja": "17.4.28. しかし、464のデータ転送不可"
    },
    {
      "indent": 3,
      "text": "The data transmission channel to the media destination is not yet ready for carrying data. However, the responding agent still expects that the data transmission channel will be established at some point in time. Note, however, that this may result in a permanent failure like 462 (Destination Unreachable).",
      "ja": "メディアへのデータ伝送チャネルは、まだデータを搬送するための準備ができていません。しかし、応答エージェントは、まだデータ伝送チャネルは、ある時点で確立されることを期待しています。これは、462（宛先到達不能）などの永続的な障害が発生することが、しかし、注意してください。"
    },
    {
      "indent": 3,
      "text": "An example of when this error may occur is in the case in which a client sends a PLAY request to a server prior to ensuring that the TCP connections negotiated for carrying media data were successfully established (in violation of this specification). The server would use this error code to indicate that the requested action could not be performed due to the failure of completing the connection establishment.",
      "ja": "このエラーが発生する可能性ときの例では、クライアントは、前のメディアデータを搬送するために交渉TCP接続が成功（本明細書に違反して）確立されたことを確実にするためにサーバにPLAY要求を送信する場合にあります。サーバは要求されたアクションが原因接続の確立を完了の障害のために実行されなかったことを示すために、このエラーコードを使用します。"
    },
    {
      "indent": 0,
      "text": "17.4.29. 465 Notification Reason Unknown",
      "section_title": true,
      "ja": "17.4.29. 不明465通知の理由"
    },
    {
      "indent": 3,
      "text": "This indicates that the client has received a PLAY_NOTIFY (Section 13.5) with a Notify-Reason header (Section 18.32) unknown to the client.",
      "ja": "これは、クライアントがクライアントに未知の通知-Reasonヘッダ（セクション18.32）でPLAY_NOTIFY（セクション13.5）を受信したことを示しています。"
    },
    {
      "indent": 0,
      "text": "17.4.30. 466 Key Management Error",
      "section_title": true,
      "ja": "17.4.30.  466キー管理エラー"
    },
    {
      "indent": 3,
      "text": "This indicates that there has been an error in a Key Management function used in conjunction with a request. For example, usage of Multimedia Internet KEYing (MIKEY) [RFC3830] according to Appendix C.1.4.1 may result in this error.",
      "ja": "これは、要求と一緒に使用する鍵管理機能にエラーがあったことを示しています。例えば、付録C.1.4.1によるマルチメディアインターネットキーイング（MIKEY）[RFC3830]の使用は、このエラーが発生することができます。"
    },
    {
      "indent": 0,
      "text": "17.4.31. 470 Connection Authorization Required",
      "section_title": true,
      "ja": "17.4.31.  470の接続認証が必要です"
    },
    {
      "indent": 3,
      "text": "The secured connection attempt needs user or client authorization before proceeding. The next hop's certificate is included in this response in the Accept-Credentials header.",
      "ja": "セキュアな接続試行は、先に進む前に、ユーザーやクライアントの承認を必要とします。ネクストホップの証明書を受け入れ、資格情報のヘッダで、この応答に含まれています。"
    },
    {
      "indent": 0,
      "text": "17.4.32. 471 Connection Credentials Not Accepted",
      "section_title": true,
      "ja": "17.4.32.  471の接続資格情報受け付けられません"
    },
    {
      "indent": 3,
      "text": "When performing a secure connection over multiple connections, an intermediary has refused to connect to the next hop and carry out the request due to unacceptable credentials for the used policy.",
      "ja": "複数の接続を介したセキュアな接続を行う場合、仲介者は、次のホップに接続して、使用されるポリシーの許容できない資格情報への要求を行うことを拒否しました。"
    },
    {
      "indent": 0,
      "text": "17.4.33. 472 Failure to Establish Secure Connection",
      "section_title": true,
      "ja": "17.4.33. セキュアな接続を確立するために472失敗"
    },
    {
      "indent": 3,
      "text": "A proxy fails to establish a secure connection to the next-hop RTSP agent. This is primarily caused by a fatal failure at the TLS handshake, for example, due to the agent not accepting any cipher suites.",
      "ja": "プロキシは、次のホップRTSPエージェントへの安全な接続を確立するために失敗しました。これは主に、エージェントが任意の暗号スイートを受け入れないように、例えば、TLSハンドシェイクでの致命的な障害によって引き起こされます。"
    },
    {
      "indent": 0,
      "text": "17.5. Server Error 5xx",
      "section_title": true,
      "ja": "17.5. サーバーエラーの5xx"
    },
    {
      "indent": 3,
      "text": "Response status codes beginning with the digit \"5\" indicate cases in which the server is aware that it has erred or is incapable of performing the request. The server SHOULD include a message body containing an explanation of the error situation and whether it is a temporary or permanent condition. User agents SHOULD display any included message body to the user. These response codes are applicable to any request method.",
      "ja": "数字「5」から始まるレスポンスステータスコードは、サーバが、それが誤りを犯したり、要求を実行することができないしていることを認識している例を示しています。サーバーは、メッセージ本体がエラー状況の説明を含む、それは一時的または永久的な状態であるかどうかを含めるべきです。ユーザーエージェントは、ユーザーに任意の含まれるメッセージ本文が表示されます。これらの応答コードはどんなリクエストメソッドに適用されます。"
    },
    {
      "indent": 0,
      "text": "17.5.1. 500 Internal Server Error",
      "section_title": true,
      "ja": "17.5.1.  500内部サーバーエラー"
    },
    {
      "indent": 3,
      "text": "The agent encountered an unexpected condition that prevented it from fulfilling the request.",
      "ja": "エージェントは、要求を満たすことを妨げる予期しない状態に遭遇しました。"
    },
    {
      "indent": 0,
      "text": "17.5.2. 501 Not Implemented",
      "section_title": true,
      "ja": "17.5.2.  501実装されていません"
    },
    {
      "indent": 3,
      "text": "The agent does not support the functionality required to fulfill the request. This is the appropriate response when the agent does not recognize the request method and is not capable of supporting it for any resource.",
      "ja": "エージェントは、要求を満たすために必要な機能をサポートしていません。これは、エージェントがリクエストメソッドを認識しないし、すべてのリソースに対して、それに対応する機能がない適切な対応です。"
    },
    {
      "indent": 0,
      "text": "17.5.3. 502 Bad Gateway",
      "section_title": true,
      "ja": "17.5.3.  502不正なゲートウェイ"
    },
    {
      "indent": 3,
      "text": "The agent, while acting as a gateway or proxy, received an invalid response from the upstream agent it accessed in attempting to fulfill the request.",
      "ja": "エージェントは、ゲートウェイまたはプロキシとして動作しながら、それが要求を満たすためにアクセス上流エージェントから無効な応答を受け取りました。"
    },
    {
      "indent": 0,
      "text": "17.5.4. 503 Service Unavailable",
      "section_title": true,
      "ja": "17.5.4.  503サービスを使用できません"
    },
    {
      "indent": 3,
      "text": "The server is currently unable to handle the request due to a temporary overloading or maintenance of the server. The implication is that this is a temporary condition that will be alleviated after some delay. If known, the length of the delay MAY be indicated in a Retry-After header. If no Retry-After is given, the agent SHOULD handle the response as it would for a 500 response. The agent MUST honor the length, if given, in the Retry-After header.",
      "ja": "サーバーは、現在サーバーの一時的な過負荷またはメンテナンスのためにリクエストを処理することができません。含意は、これはしばらく待つと緩和される一時的な状態であるということです。既知の場合、遅延の長さは、リトライ後ヘッダに示されてもよいです。何のリトライ後が指定されていない場合、エージェントは応答それは500応答の場合と同じように処理する必要があります。リトライ後ヘッダに、与えられた場合、エージェントは、長さを尊重しなければなりません。"
    },
    {
      "indent": 9,
      "text": "Note: The existence of the 503 status code does not imply that\na server must use it when becoming overloaded.  Some servers\nmay wish to simply refuse the transport connection.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The response scope is dependent on the request. If the request was in relation to an existing RTSP session, the scope of the overload response is to this individual RTSP session. If the request was not session specific or intended to form an RTSP session, it applies to the RTSP server identified by the hostname in the Request-URI.",
      "ja": "応答スコープは、リクエストに依存しています。リクエストが既存のRTSPセッションに関連していた場合は、過負荷応答の範囲は、この個々のRTSPセッションにあります。リクエストがセッション固有またはRTSPセッションを形成することを意図しなかった場合、それは、Request-URIにホスト名で識別されるRTSPサーバに適用されます。"
    },
    {
      "indent": 0,
      "text": "17.5.5. 504 Gateway Timeout",
      "section_title": true,
      "ja": "17.5.5.  504ゲートウェイのタイムアウト"
    },
    {
      "indent": 3,
      "text": "The agent, while acting as a proxy, did not receive a timely response from the upstream agent specified by the URI or some other auxiliary server (e.g., DNS) that it needed to access in attempting to complete the request.",
      "ja": "エージェントは、プロキシとして動作しているとき、それは要求を完了しようとしてアクセスするために必要なことをURIで指定された上流剤や他のいくつかの補助のサーバ（例えば、DNS）からタイムリーな応答を受信しませんでした。"
    },
    {
      "indent": 0,
      "text": "17.5.6. 505 RTSP Version Not Supported",
      "section_title": true,
      "ja": "17.5.6.  505 RTSPのバージョンはサポートされません"
    },
    {
      "indent": 3,
      "text": "The agent does not support, or refuses to support, the RTSP version that was used in the request message. The agent is indicating that it is unable or unwilling to complete the request using the same major version as the agent other than with this error message. The response SHOULD contain a message body describing why that version is not supported and what other protocols are supported by that agent.",
      "ja": "エージェントがサポートする、または、要求メッセージで使用されたRTSPのバージョンをサポートすることを拒否していません。エージェントは、このエラーメッセージよりも他の薬剤と同じメジャーバージョンを使用して要求を完了することができない、または不本意であることを示しています。応答はそのバージョンがサポートされておらず、他のどのようなプロトコルは、そのエージェントによってサポートされている理由を説明するメッセージの本文を含むべきです。"
    },
    {
      "indent": 0,
      "text": "17.5.7. 551 Option Not Supported",
      "section_title": true,
      "ja": "17.5.7.  551オプションがサポートされていません"
    },
    {
      "indent": 3,
      "text": "A feature tag given in the Require or the Proxy-Require fields was not supported. The Unsupported header MUST be returned stating the feature for which there is no support.",
      "ja": "必要とするか、またはプロキシは、必要なフィールドに与えられた特徴タグはサポートされませんでした。サポートされていないヘッダは、サポートはありませんそのための機能を述べ返されなければなりません。"
    },
    {
      "indent": 0,
      "text": "17.5.8. 553 Proxy Unavailable",
      "section_title": true,
      "ja": "17.5.8.  553プロキシの使用不可"
    },
    {
      "indent": 3,
      "text": "The proxy is currently unable to handle the request due to a temporary overloading or maintenance of the proxy. The implication is that this is a temporary condition that will be alleviated after some delay. If known, the length of the delay MAY be indicated in a Retry-After header. If no Retry-After is given, the agent SHOULD handle the response as it would for a 500 response. The agent MUST honor the length, if given in the Retry-After header.",
      "ja": "プロキシが原因プロキシの一時的な過負荷またはメンテナンスのため、現在リクエストを処理することができません。含意は、これはしばらく待つと緩和される一時的な状態であるということです。既知の場合、遅延の長さは、リトライ後ヘッダに示されてもよいです。何のリトライ後が指定されていない場合、エージェントは応答それは500応答の場合と同じように処理する必要があります。リトライ後ヘッダで与えられる場合、エージェントは、長さを尊重しなければなりません。"
    },
    {
      "indent": 9,
      "text": "Note: The existence of the 553 status code does not imply that\na proxy must use it when becoming overloaded.  Some proxies may\nwish to simply refuse the connection.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The response scope is dependent on the Request. If the request was in relation to an existing RTSP session, the scope of the overload response is to this individual RTSP session. If the request was non-session specific or intended to form an RTSP session, it applies to all such requests to this proxy.",
      "ja": "応答範囲は、リクエストに依存しています。リクエストが既存のRTSPセッションに関連していた場合は、過負荷応答の範囲は、この個々のRTSPセッションにあります。リクエストが非セッション固有またはRTSPセッションを形成することを目的としたならば、それはこのプロキシに対するすべてのそのような要求に適用されます。"
    },
    {
      "indent": 0,
      "text": "18. Header Field Definitions",
      "section_title": true,
      "ja": "18ヘッダフィールド定義"
    },
    {
      "indent": 7,
      "text": "+---------------+----------------+--------+---------+------+\n| method        | direction      | object | acronym | Body |\n+---------------+----------------+--------+---------+------+\n| DESCRIBE      | C -> S         | P,S    | DES     | r    |\n|               |                |        |         |      |\n| GET_PARAMETER | C -> S, S -> C | P,S    | GPR     | R,r  |\n|               |                |        |         |      |\n| OPTIONS       | C -> S, S -> C | P,S    | OPT     |      |\n|               |                |        |         |      |\n| PAUSE         | C -> S         | P,S    | PSE     |      |\n|               |                |        |         |      |\n| PLAY          | C -> S         | P,S    | PLY     |      |\n|               |                |        |         |      |\n| PLAY_NOTIFY   | S -> C         | P,S    | PNY     | R    |\n|               |                |        |         |      |\n| REDIRECT      | S -> C         | P,S    | RDR     |      |\n|               |                |        |         |      |\n| SETUP         | C -> S         | S      | STP     |      |\n|               |                |        |         |      |\n| SET_PARAMETER | C -> S, S -> C | P,S    | SPR     | R,r  |\n|               |                |        |         |      |\n| TEARDOWN      | C -> S         | P,S    | TRD     |      |\n|               |                |        |         |      |\n|               | S -> C         | P      | TRD     |      |\n+---------------+----------------+--------+---------+------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This table is an overview of RTSP methods, their direction, and what objects (P: presentation, S: stream) they operate on. \"Body\" denotes if a method is allowed to carry body and in which direction; R = request, r=response. Note: All error messages for statuses 4xx and 5xx are allowed to carry a body.",
      "ja": "このテーブルには、RTSPの方法の概要、その方向であり、どのようなオブジェクト（P：プレゼンテーション、S：ストリーム）彼らは上で動作します。方法は、本体および方向を運ぶために許可されている場合、「ボディ」を意味します。 R =要求、R =応答。注意：ステータスの4xxと5xxのためのすべてのエラーメッセージは、体を運ぶために許可されています。"
    },
    {
      "indent": 21,
      "text": "Table 8: Overview of RTSP Methods",
      "ja": "表8：RTSPメソッドの概要"
    },
    {
      "indent": 3,
      "text": "The general syntax for header fields is covered in Section 5.2. This section lists the full set of header fields along with notes on meaning and usage. The syntax definitions for header fields are present in Section 20.2.3. Examples of each header field are given.",
      "ja": "ヘッダフィールドの一般的な構文は、5.2節で覆われています。このセクションでは、意味と使用法に関する注記と一緒にヘッダフィールドのフルセットを示しています。ヘッダフィールドの構文定義はセクション20.2.3に存在します。各ヘッダフィールドの例が示されています。"
    },
    {
      "indent": 3,
      "text": "Information about header fields in relation to methods and proxy processing is summarized in Figures 2, 3, 4, and 5.",
      "ja": "方法およびプロキシ処理に関連するヘッダ・フィールドについての情報は、図2、図3、図4、及び図5に要約されています。"
    },
    {
      "indent": 3,
      "text": "The \"where\" column describes the request and response types in which the header field can be used. Values in this column are:",
      "ja": "「ここ」の列は、ヘッダーフィールドが使用可能な要求および応答の種類を記載しています。この列の値は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "R: header field may only appear in requests;",
      "ja": "R：ヘッダフィールドは、リクエストのみに現れてもよいです。"
    },
    {
      "indent": 3,
      "text": "r: header field may only appear in responses;",
      "ja": "R：ヘッダフィールドは、応答に現れてもよいです。"
    },
    {
      "indent": 3,
      "text": "2xx, 4xx, etc.: numerical value or range indicates response codes with which the header field can be used;",
      "ja": "2XX、4XX、等：数値または範囲がヘッダフィールドを使用することができると応答コードを示します。"
    },
    {
      "indent": 3,
      "text": "c: header field is copied from the request to the response.",
      "ja": "C：ヘッダフィールドは、応答をリクエストからコピーされます。"
    },
    {
      "indent": 3,
      "text": "G: header field is a general-header and may be present in both requests and responses.",
      "ja": "G：ヘッダフィールドは、一般的なヘッダであり、要求と応答の両方に存在してもよいです。"
    },
    {
      "indent": 3,
      "text": "Note: General headers do not always use the \"G\" value in the \"where\" column. This is due to differences when the header may be applied in requests compared to responses. When such differences exist, they are expressed using two different rows: one with \"where\" being \"R\" and one with it being \"r\".",
      "ja": "注意：一般的なヘッダは常に「どこで」欄に「G」値を使用しないでください。ヘッダは、応答と比較要求に適用することができる場合、これは違いによるものです。 「R」であると、それは「R」であると一つの「場所」と、ワン：そのような差異が存在する場合、それらは二つの異なる行を使用して表現されます。"
    },
    {
      "indent": 3,
      "text": "The \"proxy\" column describes the operations a proxy may perform on a header field. An empty proxy column indicates that the proxy MUST NOT make any changes to that header, all allowed operations are explicitly stated:",
      "ja": "「プロキシ」の列は、プロキシがヘッダーフィールドに実行することができる動作を説明します。空のプロキシ欄はすべて許可された操作を明示的に記述されている、プロキシはそのヘッダーに変更を加えてはならないことを示しています。"
    },
    {
      "indent": 3,
      "text": "a: A proxy can add or concatenate the header field if not present.",
      "ja": "A：プロキシが存在しない場合ヘッダフィールドを追加したり、連結することができます。"
    },
    {
      "indent": 3,
      "text": "m: A proxy can modify an existing header field value.",
      "ja": "M：プロキシは既存のヘッダフィールド値を変更することができます。"
    },
    {
      "indent": 3,
      "text": "d: A proxy can delete a header field-value.",
      "ja": "D：プロキシはヘッダーフィールド値を削除することができます。"
    },
    {
      "indent": 3,
      "text": "r: A proxy needs to be able to read the header field; thus, this header field cannot be encrypted.",
      "ja": "R：プロキシはヘッダーフィールドを読み取ることができる必要があります。従って、このヘッダーフィールドは、暗号化することができません。"
    },
    {
      "indent": 3,
      "text": "The rest of the columns relate to the presence of a header field in a method. The method names when abbreviated, are according to Table 8:",
      "ja": "残りの列は、メソッドのヘッダフィールドの存在に関係します。表8に記載されている略称メソッド名："
    },
    {
      "indent": 3,
      "text": "c: Conditional; requirements on the header field depend on the context of the message.",
      "ja": "C：条件付き。ヘッダフィールド上の要件は、メッセージの文脈に依存します。"
    },
    {
      "indent": 3,
      "text": "m: The header field is mandatory.",
      "ja": "M：ヘッダフィールドは必須です。"
    },
    {
      "indent": 3,
      "text": "m*: The header field SHOULD be sent, but agents need to be prepared to receive messages without that header field.",
      "ja": "M *：ヘッダフィールドは、送信されるべきであるが、薬剤は、そのヘッダフィールドなしでメッセージを受信するように準備される必要があります。"
    },
    {
      "indent": 3,
      "text": "o: The header field is optional.",
      "ja": "O：ヘッダーフィールドはオプションです。"
    },
    {
      "indent": 3,
      "text": "*: The header field MUST be present if the message body is not empty. See Sections 18.17, 18.19 and 5.3 for details.",
      "ja": "*：メッセージ本体が空でない場合ヘッダフィールドが存在しなければなりません。詳細については、セクション18.17、18.19と5.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "-: The header field is not applicable.",
      "ja": " - ：ヘッダーフィールドは適用されません。"
    },
    {
      "indent": 3,
      "text": "\"Optional\" means that an agent MAY include the header field in a request or response. The agent behavior when receiving such headers varies; for some, it may ignore the header field. In other cases, it is a request to process the header. This is regulated by the method and header descriptions. Examples of headers that require processing are the Require and Proxy-Require header fields discussed in Sections 18.43 and 18.37. A \"mandatory\" header field MUST be present in a request, and it MUST be understood by the agent receiving the request. A mandatory response-header field MUST be present in the response, and the header field MUST be understood by the processing the response. \"Not applicable\" means that the header field MUST NOT be present in a request. If one is placed in a request by mistake, it MUST be ignored by the agent receiving the request. Similarly, a header field labeled \"not applicable\" for a response means that the agent MUST NOT place the header field in the response, and the agent MUST ignore the header field in the response.",
      "ja": "「オプション」は、エージェントは、要求または応答のヘッダフィールドを含んでもよいことを意味します。エージェントの動作このようなヘッダを受信した場合に変化します。いくつかのために、それはヘッダフィールドを無視することができます。他の場合には、ヘッダを処理するための要求です。これは、メソッド、ヘッダ記述によって調節されます。処理を必要とするヘッダの例としては、必要とし、セクション18.43と18.37で説明したヘッダフィールドをプロキシ必要とします。 「必須」ヘッダフィールドは要求に存在していなければなりません、そして、それは要求を受け取るエージェントによって理解されなければなりません。必須レスポンス・ヘッダー・フィールドは、応答中に存在していなければなりません、そしてヘッダフィールドは処理応答によって理解されなければなりません。 「該当なし」ヘッダーフィールドがリクエストに存在してはならないことを意味しています。 1が誤って要求に配置されている場合は、その要求を受けたエージェントによって無視されなければなりません。同様に、応答は、「該当しない」とラベル付けされたヘッダフィールドは、エージェントが応答してヘッダーフィールドを配置してはならず、エージェントが応答してヘッダーフィールドを無視しなければならないことを意味します。"
    },
    {
      "indent": 3,
      "text": "An RTSP agent MUST ignore extension headers that are not understood.",
      "ja": "RTSPエージェントは理解されていない拡張ヘッダを無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The From and Location header fields contain a URI. If the URI contains a comma (') or semicolon (;), the URI MUST be enclosed in double quotes (\"). Any URI parameters are contained within these quotes. If the URI is not enclosed in double quotes, any semicolon-delimited parameters are header-parameters, not URI parameters.",
      "ja": "ヘッダフィールドからと場所URIが含まれています。 （;）URIは、カンマ（ '）またはセミコロンが含まれている場合は、URIは、二重引用符（ \"）で囲む必要があります任意のURIパラメータはこれらの引用符の中に含まれているURIを二重引用符で囲まれていない場合、任意のセミコロン区切り。パラメータは、ヘッダパラメータはなく、URIパラメータです。"
    },
    {
      "indent": 3,
      "text": "+-------------------+------+------+----+----+-----+-----+-----+-----+\n| Header            |Where |Proxy |DES | OPT| STP | PLY | PSE | TRD |\n+-------------------+------+------+----+----+-----+-----+-----+-----+\n| Accept            | R    |      | o  | -  | -   | -   | -   | -   |\n| Accept-           | R    | rm   | o  | o  | o   | o   | o   | o   |\n| Credentials       |      |      |    |    |     |     |     |     |\n| Accept-Encoding   | R    | r    | o  | -  | -   | -   | -   | -   |\n| Accept-Language   | R    | r    | o  | -  | -   | -   | -   | -   |\n| Accept-Ranges     | G    | r    | -  | -  | m   | -   | -   | -   |\n| Accept-Ranges     | 456  | r    | -  | -  | -   | m   | -   | -   |\n| Allow             | r    | am   | c  | c  | c   | -   | -   | -   |\n| Allow             | 405  | am   | m  | m  | m   | m   | m   | m   |\n| Authentication-   | r    |      | o  | o  | o   | o   | o   | o/- |\n| Info              |      |      |    |    |     |     |     |     |\n| Authorization     | R    |      | o  | o  | o   | o   | o   | o/- |\n| Bandwidth         | R    |      | o  | o  | o   | o   | -   | -   |\n| Blocksize         | R    |      | o  | -  | o   | o   | -   | -   |\n| Cache-Control     | G    | r    | o  | -  | o   | -   | -   | -   |\n| Connection        | G    | ad   | o  | o  | o   | o   | o   | o   |\n| Connection-       | 470, | ar   | o  | o  | o   | o   | o   | o   |\n| Credentials       | 407  |      |    |    |     |     |     |     |\n| Content-Base      | r    |      | o  | -  | -   | -   | -   | -   |\n| Content-Base      | 4xx, |      | o  | o  | o   | o   | o   | o   |\n|                   | 5xx  |      |    |    |     |     |     |     |\n| Content-Encoding  | R    | r    | -  | -  | -   | -   | -   | -   |\n| Content-Encoding  | r    | r    | o  | -  | -   | -   | -   | -   |\n| Content-Encoding  | 4xx, | r    | o  | o  | o   | o   | o   | o   |\n|                   | 5xx  |      |    |    |     |     |     |     |\n| Content-Language  | R    | r    | -  | -  | -   | -   | -   | -   |\n| Content-Language  | r    | r    | o  | -  | -   | -   | -   | -   |\n| Content-Language  | 4xx, | r    | o  | o  | o   | o   | o   | o   |\n|                   | 5xx  |      |    |    |     |     |     |     |\n| Content-Length    | r    | r    | *  | -  | -   | -   | -   | -   |\n| Content-Length    | 4xx, | r    | *  | *  | *   | *   | *   | *   |\n|                   | 5xx  |      |    |    |     |     |     |     |\n| Content-Location  | r    | r    | o  | -  | -   | -   | -   | -   |\n| Content-Location  | 4xx, | r    | o  | o  | o   | o   | o   | o   |\n|                   | 5xx  |      |    |    |     |     |     |     |\n| Content-Type      | r    | r    | *  | -  | -   | -   | -   | -   |\n| Content-Type      | 4xx, | ar   | *  | *  | *   | *   | *   | *   |\n|                   | 5xx  |      |    |    |     |     |     |     |\n| CSeq              | Gc   | rm   | m  | m  | m   | m   | m   | m   |\n| Date              | G    | am   | o/*| o/*| o/* | o/* | o/* | o/* |\n| Expires           | r    | r    | o  | -  | o   | -   | -   | -   |\n| From              | R    | r    | o  | o  | o   | o   | o   | o   |\n| If-Match          | R    | r    | -  | -  | o   | -   | -   | -   |\n| If-Modified-Since | R    | r    | o  | -  | o   | -   | -   | -   |\n| If-None-Match     | R    | r    | o  | -  | o   | -   | -   | -   |",
      "raw": true
    },
    {
      "indent": 3,
      "text": "| Last-Modified     | r    | r    | o  | -  | o   | -   | -   | -   |\n| Location          | 3rr  |      | m  | m  | m   | m   | m   | m   |\n+-------------------+------+------+----+----+-----+-----+-----+-----+\n| Header            |Where |Proxy |DES | OPT| STP | PLY | PSE | TRD |\n+-------------------+------+------+----+----+-----+-----+-----+-----+",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Figure 2: Overview of RTSP Header Fields (A-L) Related to Methods DESCRIBE, OPTIONS, SETUP, PLAY, PAUSE, and TEARDOWN",
      "ja": "図2：方法に関するRTSPヘッダフィールド（A-L）の概要は、OPTIONSをDESCRIBE、SETUP、PLAY、PAUSE、TEARDOWNと"
    },
    {
      "indent": 3,
      "text": "+------------------+---------+-----+----+----+----+-----+-----+-----+\n| Header           | Where   |Proxy|DES |OPT |STP | PLY | PSE | TRD |\n+------------------+---------+-----+----+----+----+-----+-----+-----+\n| Media-Properties | r       |     | -  | -  | m  | o   | o   | -   |\n| Media-Range      | r       |     | -  | -  | c  | c   | c   | -   |\n| MTag             | r       | r   | o  | -  | o  | -   | -   | -   |\n| Pipelined-       | G       | amd | -  | o  | o  | o   | o   | o   |\n| Requests         |         | r   |    |    |    |     |     |     |\n| Proxy-           | 407     | amr | m  | m  | m  | m   | m   | m   |\n| Authenticate     |         |     |    |    |    |     |     |     |\n| Proxy-           | r       | amd | o  | o  | o  | o   | o   | o/- |\n| Authentication-  |         | r   |    |    |    |     |     |     |\n| Info             |         |     |    |    |    |     |     |     |\n| Proxy-           | R       | rd  | o  | o  | o  | o   | o   | o   |\n| Authorization    |         |     |    |    |    |     |     |     |\n| Proxy-Require    | R       | ar  | o  | o  | o  | o   | o   | o   |\n| Proxy-Require    | r       | r   | c  | c  | c  | c   | c   | c   |\n| Proxy-Supported  | R       | amr | c  | c  | c  | c   | c   | c   |\n| Proxy-Supported  | r       |     | c  | c  | c  | c   | c   | c   |\n| Public           | r       | amr | -  | m  | -  | -   | -   | -   |\n| Public           | 501     | amr | m  | m  | m  | m   | m   | m   |\n| Range            | R       |     | -  | -  | -  | o   | -   | -   |\n| Range            | r       |     | -  | -  | c  | m   | m   | -   |\n| Referrer         | R       |     | o  | o  | o  | o   | o   | o   |\n| Request-Status   | R       |     | -  | -  | -  | -   | -   | -   |\n| Require          | R       |     | o  | o  | o  | o   | o   | o   |\n| Retry-After      | 3rr,503 |     | o  | o  | o  | o   | o   | -   |\n|                  | ,553    |     |    |    |    |     |     |     |\n| Retry-After      | 413     |     | o  | -  | -  | -   | -   | -   |\n| RTP-Info         | r       |     | -  | -  | c  | c   | -   | -   |\n| Scale            | R       | r   | -  | -  | -  | o   | -   | -   |\n| Scale            | r       | amr | -  | -  | c  | c   | c   | -   |\n| Seek-Style       | R       |     | -  | -  | -  | o   | -   | -   |\n| Seek-Style       | r       |     | -  | -  | -  | m   | -   | -   |\n| Server           | R       | r   | -  | o  | -  | -   | -   | o   |\n| Server           | r       | r   | o  | o  | o  | o   | o   | o   |\n| Session          | R       | r   | -  | o  | o  | m   | m   | m   |\n| Session          | r       | r   | -  | c  | m  | m   | m   | o   |\n| Speed            | R       | admr| -  | -  | -  | o   | -   | -   |\n| Speed            | r       | admr| -  | -  | -  | c   | -   | -   |\n| Supported        | R       | r   | o  | o  | o  | o   | o   | o   |\n| Supported        | r       | r   | c  | c  | c  | c   | c   | c   |\n| Terminate-Reason | R       | r   | -  | -  | -  | -   | -   | -/o |\n| Timestamp        | R       | admr| o  | o  | o  | o   | o   | o   |\n| Timestamp        | c       | admr| m  | m  | m  | m   | m   | m   |\n| Transport        | G       | mr  | -  | -  | m  | -   | -   | -   |\n| Unsupported      | r       |     | c  | c  | c  | c   | c   | c   |\n| User-Agent       | R       |     | m* | m* | m* | m*  | m*  | m*  |",
      "raw": true
    },
    {
      "indent": 3,
      "text": "| Via              | R       | amr | c  | c  | c  | c   | c   | c   |\n| Via              | r       | amr | c  | c  | c  | c   | c   | c   |\n| WWW-Authenticate | 401     |     | m  | m  | m  | m   | m   | m   |\n+------------------+---------+-----+----+----+----+-----+-----+-----+\n| Header           | Where   |Proxy|DES |OPT |STP | PLY | PSE | TRD |\n+------------------+---------+-----+----+----+----+-----+-----+-----+",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Figure 3: Overview of RTSP Header Fields (M-W) Related to Methods DESCRIBE, OPTIONS, SETUP, PLAY, PAUSE, and TEARDOWN",
      "ja": "図3：RTSPヘッダフィールド（M-W）関連のメソッドを記述するために、OPTIONS、SETUP、PLAY、PAUSE、およびTEARDOWNの概要"
    },
    {
      "indent": 3,
      "text": "+---------------------------+-------+-------+-----+-----+-----+-----+\n| Header                    | Where | Proxy | GPR | SPR | RDR | PNY |\n+---------------------------+-------+-------+-----+-----+-----+-----+\n| Accept-Credentials        | R     | rm    | o   | o   | o   | -   |\n| Accept-Encoding           | R     | r     | o   | o   | o   | -   |\n| Accept-Language           | R     | r     | o   | o   | o   | -   |\n| Accept-Ranges             | G     | rm    | o   | -   | -   | -   |\n| Allow                     | 405   | amr   | m   | m   | m   | m   |\n| Authentication-Info       | r     |       | o/- | o/- | -   | -   |\n| Authorization             | R     |       | o   | o   | o   | -   |\n| Bandwidth                 | R     |       | -   | o   | -   | -   |\n| Blocksize                 | R     |       | -   | o   | -   | -   |\n| Cache-Control             | G     | r     | o   | o   | -   | -   |\n| Connection                | G     |       | o   | o   | o   | o   |\n| Connection-Credentials    | 470,  | ar    | o   | o   | o   | -   |\n|                           | 407   |       |     |     |     |     |\n| Content-Base              | R     |       | o   | o   | -   | o   |\n| Content-Base              | r     |       | o   | o   | -   | -   |\n| Content-Base              | 4xx,  |       | o   | o   | o   | o   |\n|                           | 5xx   |       |     |     |     |     |\n| Content-Encoding          | R     | r     | o   | o   | -   | o   |\n| Content-Encoding          | r     | r     | o   | o   | -   | -   |\n| Content-Encoding          | 4xx,  | r     | o   | o   | o   | o   |\n|                           | 5xx   |       |     |     |     |     |\n| Content-Language          | R     | r     | o   | o   | -   | o   |\n| Content-Language          | r     | r     | o   | o   | -   | -   |\n| Content-Language          | 4xx,  | r     | o   | o   | o   | o   |\n|                           | 5xx   |       |     |     |     |     |\n| Content-Length            | R     | r     | *   | *   | -   | *   |\n| Content-Length            | r     | r     | *   | *   | -   | -   |\n| Content-Length            | 4xx,  | r     | *   | *   | *   | *   |\n|                           | 5xx   |       |     |     |     |     |\n| Content-Location          | R     |       | o   | o   | -   | o   |\n| Content-Location          | r     |       | o   | o   | -   | -   |\n| Content-Location          | 4xx,  |       | o   | o   | o   | o   |\n|                           | 5xx   |       |     |     |     |     |\n| Content-Type              | R     |       | *   | *   | -   | *   |\n| Content-Type              | r     |       | *   | *   | -   | -   |\n| Content-Type              | 4xx,  |       | *   | *   | *   | *   |\n|                           | 5xx   |       |     |     |     |     |\n| CSeq                      | R,c   | mr    | m   | m   | m   | m   |\n| Date                      | R     | a     | o/* | o/* | m   | o/* |\n| Date                      | r     | am    | o/* | o/* | o/* | o/* |\n| Expires                   | r     | r     | -   | -   | -   | -   |\n| From                      | R     | r     | o   | o   | o   | -   |\n| If-Match                  | R     | r     | -   | -   | -   | -   |\n| If-Modified-Since         | R     | am    | o   | -   | -   | -   |\n| If-None-Match             | R     | am    | o   | -   | -   | -   |",
      "raw": true
    },
    {
      "indent": 3,
      "text": "| Last-Modified             | R     | r     | -   | -   | -   | -   |\n| Last-Modified             | r     | r     | o   | -   | -   | -   |\n| Location                  | 3rr   |       | m   | m   | m   | -   |\n| Location                  | R     |       | -   | -   | m   | -   |\n+---------------------------+-------+-------+-----+-----+-----+-----+\n| Header                    | Where | Proxy | GPR | SPR | RDR | PNY |\n+---------------------------+-------+-------+-----+-----+-----+-----+",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Figure 4: Overview of RTSP Header Fields (A-L) Related to Methods GET_PARAMETER, SET_PARAMETER, REDIRECT, and PLAY_NOTIFY",
      "ja": "図4：方法GET_PARAMETER、SET_PARAMETER、REDIRECT、およびPLAY_NOTIFY関連RTSPヘッダフィールド（A-L）の概要"
    },
    {
      "indent": 1,
      "text": "+---------------------------+---------+-------+-----+-----+-----+-----+\n| Header                    |  Where  | Proxy | GPR | SPR | RDR | PNY |\n+---------------------------+---------+-------+-----+-----+-----+-----+\n| Media-Properties          | R       | amr   | o   | -   | -   | c   |\n| Media-Properties          | r       | mr    | c   | -   | -   | -   |\n| Media-Range               | R       |       | o   | -   | -   | c   |\n| Media-Range               | r       |       | c   | -   | -   | -   |\n| MTag                      | r       | r     | o   | -   | -   | -   |\n| Notify-Reason             | R       |       | -   | -   | -   | m   |\n| Pipelined-Requests        | R       | amdr  | o   | o   | -   | -   |\n| Proxy-Authenticate        | 407     | amdr  | m   | m   | m   | -   |\n| Proxy-Authentication-Info | r       | amdr  | o/- | o/- | -   | -   |\n| Proxy-Authorization       | R       | amdr  | o   | o   | o   | -   |\n| Proxy-Require             | R       | ar    | o   | o   | o   | -   |\n| Proxy-Supported           | R       | amr   | c   | c   | c   | -   |\n| Proxy-Supported           | r       |       | c   | c   | c   | -   |\n| Public                    | 501     | admr  | m   | m   | m   | -   |\n| Range                     | R       |       | o   | -   | -   | m   |\n| Range                     | r       |       | c   | -   | -   | -   |\n| Referrer                  | R       |       | o   | o   | o   | -   |\n| Request-Status            | R       | mr    | -   | -   | -   | c   |\n| Require                   | R       | r     | o   | o   | o   | o   |\n| Retry-After               | 3rr,503,|       | o   | o   | -   | -   |\n|                           | 553     |       |     |     |     |     |\n| Retry-After               | 413     |       | o   | o   | -   | -   |\n| RTP-Info                  | R       | r     | o   | -   | -   | C   |\n| RTP-Info                  | r       | r     | c   | -   | -   | -   |\n| Scale                     | G       |       | c   | -   | c   | c   |\n| Seek-Style                | G       |       | -   | -   | -   | -   |\n| Server                    | R       | r     | o   | o   | o   | o   |\n| Server                    | r       | r     | o   | o   | -   | -   |\n| Session                   | R       | r     | o   | o   | o   | m   |\n| Session                   | r       | r     | c   | c   | o   | m   |\n| Speed                     | G       |       | -   | -   | -   | -   |\n| Supported                 | R       | r     | o   | o   | o   | -   |\n| Supported                 | r       | r     | c   | c   | c   | -   |\n| Terminate-Reason          | R       | r     | -   | -   | m   | -   |\n| Timestamp                 | R       | adrm  | o   | o   | o   | o   |\n| Timestamp                 | c       | adrm  | m   | m   | m   | m   |\n| Transport                 | G       | mr    | -   | -   | -   | -   |\n| Unsupported               | r       | arm   | c   | c   | c   | c   |\n| User-Agent                | R       | r     | m*  | m*  | -   | -   |\n| User-Agent                | r       | r     | m*  | m*  | m*  | m*  |\n| Via                       | R       | amr   | c   | c   | c   | c   |",
      "raw": true
    },
    {
      "indent": 1,
      "text": "| Via                       | r       | amr   | c   | c   | c   | c   |\n| WWW-Authenticate          | 401     |       | m   | m   | m   | -   |\n+---------------------------+---------+-------+-----+-----+-----+-----+\n| Header                    |  Where  | Proxy | GPR | SPR | RDR | PNY |\n+---------------------------+---------+-------+-----+-----+-----+-----+",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Figure 5: Overview of RTSP Header Fields (M-W) Related to Methods\n     GET_PARAMETER, SET_PARAMETER, REDIRECT, and PLAY_NOTIFY",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.1. Accept",
      "section_title": true,
      "ja": "18.1. 受け入れます"
    },
    {
      "indent": 3,
      "text": "The Accept request-header field can be used to specify certain presentation description and parameter media types [RFC6838] that are acceptable for the response to the DESCRIBE request.",
      "ja": "受け入れリクエストヘッダフィールドは、DESCRIBE要求に応答するために許容される特定のプレゼンテーション記述とパラメータメディアタイプ[RFC6838]を指定するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "See Section 20.2.3 for the syntax.",
      "ja": "構文については20.2.3項を参照してください。"
    },
    {
      "indent": 3,
      "text": "The asterisk \"*\" character is used to group media types into ranges,\nwith \"*/*\" indicating all media types and \"type/*\" indicating all\nsubtypes of that type.  The range MAY include media type parameters\nthat are generally applicable to that range.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Each media type or range MAY be followed by one or more accept-params, beginning with the \"q\" parameter to indicate a relative quality factor. The first \"q\" parameter (if any) separates the media type or range's parameters from the accept-params. Quality factors allow the user or user agent to indicate the relative degree of preference for that media type, using the qvalue scale from 0 to 1 (Section 5.3.1 of [RFC7231]). The default value is q=1.",
      "ja": "各メディアタイプまたは範囲は、相対的な品質係数を示すために「Q」パラメータで始まる、一つ以上の-paramsはを受け入れるが続いてもよいです。最初の「Q」パラメータは（もしあれば）メディアタイプまたは受け入れる-paramsは範囲のパラメータを分離します。品質係数は0から1までのqvalue尺度を使用して、ユーザーまたはユーザーエージェントは、そのメディアタイプの嗜好の相対的な程度を示すことができ（セクション5.3.1 [RFC7231]）。デフォルト値はq = 1です。"
    },
    {
      "indent": 3,
      "text": "Example of use:",
      "ja": "使用例："
    },
    {
      "indent": 5,
      "text": "Accept: application/example ;q=0.7, application/sdp",
      "ja": "受け入れ：アプリケーション/例を、Q = 0.7、アプリケーション/ SDP"
    },
    {
      "indent": 3,
      "text": "Indicates that the requesting agent prefers the media type application/sdp through the default 1.0 rating but also accepts the application/example media type with a 0.7 quality rating.",
      "ja": "要求エージェントはデフォルトの1.0の評価を介してメディアタイプapplication / SDPを好むが、また0.7品質評価とアプリケーション/例のメディアタイプを受け入れることを示します。"
    },
    {
      "indent": 3,
      "text": "If no Accept header field is present, then it is assumed that the client accepts all media types. If an Accept header field is present, and if the server cannot send a response that is acceptable according to the combined Accept field-value, then the server SHOULD send a 406 (Not Acceptable) response.",
      "ja": "何のAcceptヘッダーフィールドが存在しない場合、クライアントはすべてのメディアタイプを受け入れることが想定されます。 Acceptヘッダフィールドが存在し、サーバが受け入れる合成フィールドの値に応じて許容される応答を送信できない場合、サーバは406（許容できない）応答を送信する必要がある場合。"
    },
    {
      "indent": 0,
      "text": "18.2. Accept-Credentials",
      "section_title": true,
      "ja": "18.2.  -資格を受け入れます"
    },
    {
      "indent": 3,
      "text": "The Accept-Credentials header is a request-header used to indicate to any trusted intermediary how to handle further secured connections to proxies or servers. It MUST NOT be included in server-to-client requests. See Section 19 for the usage of this header",
      "ja": "受け入れ-資格情報ヘッダは、プロキシまたはサーバへの更なる安全な接続を処理するために、どのように任意の信頼できる仲介者に示すために使用リクエストヘッダです。これは、サーバーからクライアントへの要求に含まれてはいけません。このヘッダの使用については、セクション19を参照してください。"
    },
    {
      "indent": 3,
      "text": "In a request, the header MUST contain the method (User, Proxy, or Any) for approving credentials selected by the requester. The method MUST NOT be changed by any proxy, unless it is \"Proxy\" when a proxy MAY change it to \"user\" to take the role of user approving each further hop. If the method is \"User\", the header contains zero or more of the credentials that the client accepts. The header may contain zero credentials in the first RTSP request to an RTSP server via a proxy when using the \"User\" method. This is because the client has not yet received any credentials to accept. Each credential MUST consist of one URI identifying the proxy or server, the hash algorithm identifier, and the hash over that agent's ASN.1 DER-encoded certificate [RFC5280] in Base64, according to Section 4 of [RFC4648] and where the padding bits are set to zero. All RTSP clients and proxies MUST implement the SHA-256 [FIPS180-4] algorithm for computation of the hash of the DER-encoded certificate. The SHA-256 algorithm is identified by the token \"sha-256\".",
      "ja": "要求は、ヘッダは要求者によって選択された資格を承認するための方法（ユーザ、プロキシ、または任意）を含まなければなりません。プロキシがそれぞれさらにホップを承認するユーザの役割を取るために「ユーザー」にそれを変更することができたとき、それは「プロキシ」でない限り、この方法は、任意のプロキシによって変更してはいけません。この方法は、「ユーザー」である場合、ヘッダは、クライアントが受け入れる資格情報のゼロまたはそれ以上が含まれています。 「ユーザー」方式を使用する場合、ヘッダは、プロキシを介して、RTSPサーバへの最初のRTSP要求にゼロ資格情報を含んでいてもよいです。クライアントはまだ受け入れる任意の認証情報を受信して​​いないためです。各資格は、[RFC4648]のセクション4とパディングビットに応じて、プロキシまたはサーバ、ハッシュアルゴリズム識別子、およびBase64でのそのエージェントのASN.1のDER符号化された証明書[RFC5280]上のハッシュを識別する1つのURIで構成する必要がありますゼロに設定されています。すべてのRTSPクライアントとプロキシはDER符号化された証明書のハッシュを計算するためのSHA-256 [FIPS180-4]アルゴリズムを実装しなければなりません。 SHA-256アルゴリズムは、トークン「SHA-256」によって識別されます。"
    },
    {
      "indent": 3,
      "text": "The intention of allowing for other hash algorithms is to enable the future retirement of algorithms that are not implemented somewhere other than here. Thus, the definition of future algorithms for this purpose is intended to be extremely limited. A feature tag can be used to ensure that support for the replacement algorithm exists.",
      "ja": "他のハッシュアルゴリズムを可能にする意図はここ以外の場所に実装されていないアルゴリズムの将来の退職を有効にすることです。したがって、この目的のために、将来のアルゴリズムの定義は非常に限定されるものです。フィーチャータグは、置換アルゴリズムのサポートが存在することを確認するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 3,
      "text": "Accept-Credentials:User \"rtsps://proxy2.example.com/\";sha-256;exaIl9VMbQMOFGClx5rXnPJKVNI=, \"rtsps://server.example.com/\";sha-256;lurbjj5khhB0NhIuOXtt4bBRH1M=",
      "ja": "-資格を受け入れる：ユーザー \"RTSPS：//proxy2.example.com/\"; SHA-256; exaIl9VMbQMOFGClx5rXnPJKVNI =、 \"RTSPS：//server.example.com/\"; SHA-256; lurbjj5khhB0NhIuOXtt4bBRH1M ="
    },
    {
      "indent": 0,
      "text": "18.3. Accept-Encoding",
      "section_title": true,
      "ja": "18.3. 受け入れエンコード"
    },
    {
      "indent": 3,
      "text": "The Accept-Encoding request-header field is similar to Accept, but it restricts the content-codings (see Section 18.15), i.e., transformation codings of the message body, such as gzip compression, that are acceptable in the response.",
      "ja": "Accept-Encodingリクエスト・ヘッダー・フィールドは受け入れに似ているが、それは内容コーディング（セクション18.15を参照）を制限し、即ち、レスポンスに許容されるそのようなgzip圧縮のようなメッセージボディの変換コーディング、、。"
    },
    {
      "indent": 3,
      "text": "A server tests whether a content-coding is acceptable, according to an Accept-Encoding field, using these rules:",
      "ja": "：コンテンツ・コーディングはこれらのルールを使用して、受け入れをコードフィールドによれば、許容可能であるか否かをサーバ・テスト"
    },
    {
      "indent": 3,
      "text": "1. If the content-coding is one of the content-codings listed in the Accept-Encoding field, then it is acceptable, unless it is accompanied by a qvalue of 0. (As defined in Section 5.3.1 of [RFC7231], a qvalue of 0 means \"not acceptable.\")",
      "ja": "1.コンテンツコーディングが受け入れ-エンコーディングフィールドに記載されている内容コーディングのいずれかである場合、それは0のqvalueを伴うされていない限り、それは、[RFC7231]のセクション5.3.1で定義されるように（、許容可能です0のqvalueをは「受け入れられない」を意味します。）"
    },
    {
      "indent": 3,
      "text": "2. The special \"*\" symbol in an Accept-Encoding field matches any available content-coding not explicitly listed in the header field.",
      "ja": "2.特別には「*」にAccept-Encodingフィールド内のシンボルは、任意の利用可能なコンテンツコードを明示的ヘッダフィールドにリストされていないと一致しました。"
    },
    {
      "indent": 3,
      "text": "3. If multiple content-codings are acceptable, then the acceptable content-coding with the highest non-zero qvalue is preferred.",
      "ja": "複数のコンテンツ・コーディングが許容される場合3.その後に許容されるコンテンツコーディング最高非ゼロのqvalueを有することが好ましいです。"
    },
    {
      "indent": 3,
      "text": "4. The \"identity\" content-coding is always acceptable, i.e., no transformation at all, unless specifically refused because the Accept-Encoding field includes \"identity;q=0\" or because the field includes \"*;q=0\" and does not explicitly include the \"identity\" content-coding. If the Accept-Encoding field-value is empty, then only the \"identity\" encoding is acceptable.",
      "ja": "前記のAccept-Encodingフィールドが含まれているため、具体的に拒否しない限り、「同一性」は、コンテンツコードが、必ずしもすべてで許容される、すなわち、全く変換されない「同一性; Q = 0」またはフィールドが含まれているため、「*; q = 0で」と明示的に「アイデンティティ」コンテンツコードが含まれていません。受け入れエンコードフィールド値が空の場合、唯一の「アイデンティティ」エンコードが可能です。"
    },
    {
      "indent": 3,
      "text": "If an Accept-Encoding field is present in a request, and if the server cannot send a response that is acceptable according to the Accept-Encoding header, then the server SHOULD send an error response with the 406 (Not Acceptable) status code.",
      "ja": "もし受け入れエンコーディングフィールドは要求に存在し、サーバが受け入れる-Encodingヘッダに従って許容される応答を送信できない場合、サーバは406（許容できない）ステータスコードとエラー応答を送信すべきです。"
    },
    {
      "indent": 3,
      "text": "If no Accept-Encoding field is present in a request, the server MAY assume that the client will accept any content-coding. In this case, if \"identity\" is one of the available content-codings, then the server SHOULD use the \"identity\" content-coding, unless it has additional information that a different content-coding is meaningful to the client.",
      "ja": "何のAccept-Encodingフィールドがリクエストに存在しない場合、サーバーは、クライアントがどんな内容コーディングを受け入れることを仮定してもよいです。この場合、「同一性」は、それが異なるコンテンツコードは、クライアントにとって意味のあることを、追加情報を持っていない限り、サーバーは、「アイデンティティ」コンテンツコーディングを使用すべきである、可能な内容コーディングの一つです。"
    },
    {
      "indent": 0,
      "text": "18.4. Accept-Language",
      "section_title": true,
      "ja": "18.4. 受け入れる言語"
    },
    {
      "indent": 3,
      "text": "The Accept-Language request-header field is similar to Accept, but restricts the set of natural languages that are preferred as a response to the request. Note that the language specified applies to the presentation description (response message body) and any reason phrases, but not the media content.",
      "ja": "Accept-Languageリクエストヘッダフィールドは、そのまま使用することが同様であるが、要求に対する応答として好ましい自然言語のセットを制限します。指定された言語は、プレゼンテーション記述（応答メッセージ本体）と、何らかの理由フレーズではなく、メディアコンテンツに適用されることに注意してください。"
    },
    {
      "indent": 3,
      "text": "A language tag identifies a natural language spoken, written, or otherwise conveyed by human beings for communication of information to other human beings. Computer languages are explicitly excluded. The syntax and registry of RTSP 2.0 language tags are the same as those defined by [RFC5646].",
      "ja": "言語タグが書き込まれ、またはそうでなければ他の人間への情報の通信のための人間によって運ば、発話自然言語を識別する。コンピュータ言語は明示的に除外されています。 RTSP 2.0言語タグの構文およびレジストリは[RFC5646]で定義されたものと同じです。"
    },
    {
      "indent": 3,
      "text": "Each language-range MAY be given an associated quality value that represents an estimate of the user's preference for the languages specified by that range. The quality value defaults to \"q=1\". For example:",
      "ja": "各言語範囲は、その範囲で指定された言語に対するユーザの嗜好の推定値を表す関連する品質値を与えられてもよいです。 「Q = 1」に品質値をデフォルトとします。例えば："
    },
    {
      "indent": 6,
      "text": "Accept-Language: da, en-gb;q=0.8, en;q=0.7",
      "ja": "受け入れ-言語：DA、EN-GB; Q = 0.8、EN; Q = 0.7"
    },
    {
      "indent": 3,
      "text": "would mean: \"I prefer Danish, but will accept British English and other types of English.\" A language-range matches a language tag if it exactly equals the full tag or if it exactly equals a prefix of the tag, i.e., the primary-tag in the ABNF, such that the character following primary-tag is \"-\". The special range \"*\", if present in the Accept-Language field, matches every tag not matched by any other range present in the Accept-Language field.",
      "ja": "意味するだろう：「私はデンマークを好むが、イギリス英語と英語の他のタイプを受け入れます。」 「 - 」それは正確に主なタグ以下の文字があるように、完全なタグまたは、それは正確にタグの接頭辞と等しい場合、ABNFで、すなわち、主タグを、等しい場合は言語範囲は、言語タグに一致します。特別な範囲「*」は、にAccept-Languageフィールドに存在する場合、受け入れる言語をフィールドに存在する任意の他の範囲で一致していないすべてのタグに一致します。"
    },
    {
      "indent": 6,
      "text": "Note: This use of a prefix matching rule does not imply that language tags are assigned to languages in such a way that it is always true that if a user understands a language with a certain tag, then this user will also understand all languages with tags for which this tag is a prefix. The prefix rule simply allows the use of prefix tags if this is the case.",
      "ja": "注：接頭辞の一致ルールの使用は、その言語タグは、ユーザが特定のタグが付けられた言語を理解している場合、このユーザーはまた、タグですべての言語を理解することは常に真であるように言語に割り当てられている意味するものではありません。そのため、このタグは、接頭辞です。このような場合には、プレフィックス規則は単にプレフィックスタグの使用を可能にします。"
    },
    {
      "indent": 3,
      "text": "In the process of selecting a language, each language tag is assigned a qualification factor, i.e., if a language being supported by the client is actually supported by the server and what \"preference\" level the language achieves. The quality value (q-value) of the longest language-range in the field that matches the language tag is assigned as the qualification factor for a particular language tag. If no language-range in the field matches the tag, the language qualification factor assigned is 0. If no Accept-Language header is present in the request, the server SHOULD assume that all languages are equally acceptable. If an Accept-Language header is present, then all languages that are assigned a qualification factor greater than 0 are acceptable.",
      "ja": "言語の選択処理において、各言語タグが言語がクライアントによってサポートされている場合、すなわち、実際にサーバと何「嗜好」レベル言語が達成に支持されている資格係数を、割り当てられています。言語タグに一致するフィールドの中で最も長い言語範囲の品質値（Q値）は、特定の言語タグの資格因子として割り当てられています。フィールドには、言語範囲がタグと一致しない場合、割り当てられた言語資格係数は0である何のAccept-Languageヘッダーが要求に存在しない場合、サーバは、全ての言語が等しく許容されると仮定すべきです。受け入れ言語をヘッダが存在する場合、すべての言語0より大きいが許容される資格因子を割り当てられています。"
    },
    {
      "indent": 0,
      "text": "18.5. Accept-Ranges",
      "section_title": true,
      "ja": "18.5.  -範囲を受け入れます"
    },
    {
      "indent": 3,
      "text": "The Accept-Ranges general-header field allows indication of the format supported in the Range header. The client MUST include the header in SETUP requests to indicate which formats are acceptable when received in PLAY and PAUSE responses and REDIRECT requests. The server MUST include the header in SETUP responses and 456 (Header Field Not Valid for Resource) error responses to indicate the formats supported for the resource indicated by the Request-URI. The header MAY be included in GET_PARAMETER request and response pairs. The GET_PARAMETER request MUST contain a Session header to identify the session context the request is related to. The requester and responder will indicate their capabilities regarding Range formats respectively.",
      "ja": "受け入れ-範囲の一般的なヘッダフィールドは、Rangeヘッダにサポートされている形式の表示を可能にします。クライアントはPLAYで受信したときのフォーマットが許容可能であるかを示すと応答を一時停止して要求をリダイレクトするSETUP要求にヘッダを含まなければなりません。サーバは、Request-URIで示されるリソースに対してサポートされるフォーマットを示すSETUP応答のヘッダ及び456（リソースに対して有効でないヘッダーフィールド）エラー応答を含まなければなりません。ヘッダは、GET_PARAMETER要求および応答のペアに含まれるかもしれ。 GET_PARAMETER要求は、要求が関連するセッションコンテキストを識別するために、セッション・ヘッダを含まなければなりません。リクエスタとレスポンダは、それぞれの範囲のフォーマットについてその機能を示します。"
    },
    {
      "indent": 6,
      "text": "Accept-Ranges: npt, smpte, clock",
      "ja": "受け入れ-範囲：NPT、SMPTE、クロック"
    },
    {
      "indent": 3,
      "text": "The syntax is defined in Section 20.2.3.",
      "ja": "構文は20.2.3項で定義されています。"
    },
    {
      "indent": 0,
      "text": "18.6. Allow",
      "section_title": true,
      "ja": "18.6. 許します"
    },
    {
      "indent": 3,
      "text": "The Allow message body header field lists the methods supported by the resource identified by the Request-URI. The purpose of this field is to inform the recipient of the complete set of valid methods associated with the resource. An Allow header field MUST be present in a 405 (Method Not Allowed) response. The Allow header MUST also be present in all OPTIONS responses where the content of the header will not include exactly the same methods as listed in the Public header.",
      "ja": "許可メッセージボディヘッダフィールドは、Request-URIによって識別されたリソースによってサポートされるメソッドを示します。このフィールドの目的は、リソースに関連する有効な方法の完全なセットの受信者に通知することです。許可ヘッダフィールドは405（方法不可）応答中に存在していなければなりません。許可ヘッダは、公開ヘッダに記載されているように、ヘッダの内容が正確に同一の方法を含まないすべてのオプション応答中に存在していなければなりません。"
    },
    {
      "indent": 3,
      "text": "The Allow message body header MUST also be included in SETUP and DESCRIBE responses, if the methods allowed for the resource are different from the complete set of methods defined in this memo.",
      "ja": "許可メッセージボディヘッダはまた、SETUPに含まれるリソースに許可方法は、このメモで定義されたメソッドの完全なセットと異なる場合、応答の記述されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Example of use:",
      "ja": "使用例："
    },
    {
      "indent": 6,
      "text": "Allow: SETUP, PLAY, SET_PARAMETER, DESCRIBE",
      "ja": "許可：SETUP、PLAY、SET_PARAMETER、DESCRIBE"
    },
    {
      "indent": 0,
      "text": "18.7. Authentication-Info",
      "section_title": true,
      "ja": "18.7. 認証情報"
    },
    {
      "indent": 3,
      "text": "The Authentication-Info response-header is used by the server to communicate some information regarding the successful HTTP authentication [RFC7235] in the response message. The definition of the header is in [RFC7615], and any applicable HTTP authentication schemes appear in other RFCs, such as Digest [RFC7616]. This header MUST only be used in response messages related to client to server requests.",
      "ja": "認証-INFO応答ヘッダは、応答メッセージに成功HTTP認証[RFC7235]に関するいくつかの情報を通信するためにサーバによって使用されます。ヘッダの定義は、[RFC7615]であり、任意の適用可能なHTTP認証方式は、ダイジェスト[RFC7616]などの他のRFCに現れます。このヘッダーは、サーバー要求にクライアントに関連した応答メッセージに使用しなければなりません。"
    },
    {
      "indent": 0,
      "text": "18.8. Authorization",
      "section_title": true,
      "ja": "18.8. 認定"
    },
    {
      "indent": 3,
      "text": "An RTSP client that wishes to authenticate itself with a server using the authentication mechanism from HTTP [RFC7235], usually (but not necessarily) after receiving a 401 response, does so by including an Authorization request-header field with the request. The Authorization field-value consists of credentials containing the authentication information of the user agent for the realm of the resource being requested. The definition of the header is in",
      "ja": "401応答を受信した後、通常、HTTP [RFC7235]、（必ずしもそうではない）からの認証メカニズムを使用してサーバに自身を認証することを望むRTSPクライアントは、要求と認可要求ヘッダフィールドを含むことによってそうします。 Authorizationフィールド値は、要求されたリソースのレルムのユーザエージェントの認証情報を含む資格情報で構成されています。ヘッダの定義がです"
    },
    {
      "indent": 3,
      "text": "[RFC7235], and any applicable HTTP authentication schemes appear in other RFCs, such as Digest [RFC7616] and Basic [RFC7617]. This header MUST only be used in client-to-server requests.",
      "ja": "[RFC7235]、および任意の適用可能なHTTP認証方式は、ダイジェスト[RFC7616]と基本[RFC7617]などの他のRFCに現れます。このヘッダーは、クライアントからサーバーへのリクエストで使用されなければなりません。"
    },
    {
      "indent": 3,
      "text": "If a request is authenticated and a realm specified, the same credentials SHOULD be valid for all other requests within this realm (assuming that the authentication scheme itself does not require otherwise, such as credentials that vary according to a challenge value or using synchronized clocks). Each client-to-server request MUST be individually authorized by including the Authorization header with the information.",
      "ja": "要求が認証され、領域が指定されている場合は、同じ資格情報が（例えば、チャレンジ値に応じて、または同期したクロックを用いて変化資格情報として、認証方式自体が他を必要としないと仮定して）、この領域内の他のすべての要求に対して有効である必要があり。各クライアントからサーバへのリクエストは、個別情報をAuthorizationヘッダを含むによって承認されなければなりません。"
    },
    {
      "indent": 3,
      "text": "When a shared cache (see Section 16) receives a request containing an Authorization field, it MUST NOT return the corresponding response as a reply to any other request, unless one of the following specific exceptions holds:",
      "ja": "共有キャッシュ（セクション16を参照）Authorizationフィールドを含むリクエストを受信すると、以下の特定の例外のいずれかが成立しない限り、それは、他の要求に対する応答として対応する応答を返してはなりません。"
    },
    {
      "indent": 3,
      "text": "1. If the response includes the \"max-age\" cache directive, the cache MAY use that response in replying to a subsequent request. But (if the specified maximum age has passed) a proxy cache MUST first revalidate it with the origin server, using the request-headers from the new request to allow the origin server to authenticate the new request. (This is the defined behavior for max-age.) If the response includes \"max-age=0\", the proxy MUST always revalidate it before reusing it.",
      "ja": "応答は「最大エージング」キャッシュディレクティブが含ま1.場合は、キャッシュは、後続の要求への応答でその応答を使用するかもしれません。 （指定された最大年齢が経過している場合）でも、プロキシキャッシュは、最初のオリジンサーバが新しい要求を認証できるようにするために、新たなリクエストからリクエストヘッダを使用して、オリジンサーバでそれを再検証しなければなりません。レスポンスが「= 0最大エージング」が含まれている場合（これは、最大エージングのために定義された動作です。）、プロキシは常にそれを再利用する前に、それを再検証しなければなりません。"
    },
    {
      "indent": 3,
      "text": "2. If the response includes the \"must-revalidate\" cache-control directive, the cache MAY use that response in replying to a subsequent request. But if the response is stale, all caches MUST first revalidate it with the origin server, using the request-headers from the new request to allow the origin server to authenticate the new request.",
      "ja": "2.応答が「MUST-再検証」キャッシュ制御ディレクティブが含まれている場合、キャッシュは、後続の要求に応答してその応答を使用するかもしれません。レスポンスが古くなっている場合でも、すべてのキャッシュは、最初のオリジンサーバが新しい要求を認証できるようにするために、新たなリクエストからリクエストヘッダを使用して、オリジンサーバでそれを再検証しなければなりません。"
    },
    {
      "indent": 3,
      "text": "3. If the response includes the \"public\" cache directive, it MAY be returned in reply to any subsequent request.",
      "ja": "3.応答が「公共」のキャッシュディレクティブが含まれている場合、それはそれ以降の要求に対する応答で返されることがあります。"
    },
    {
      "indent": 0,
      "text": "18.9. Bandwidth",
      "section_title": true,
      "ja": "18.9. 帯域幅"
    },
    {
      "indent": 3,
      "text": "The Bandwidth request-header field describes the estimated bandwidth available to the client, expressed as a positive integer and measured in kilobits per second. The bandwidth available to the client may change during an RTSP session, e.g., due to mobility, congestion, etc.",
      "ja": "帯域幅要求ヘッダフィールドは、正の整数として表され、毎秒キロビットで測定され、クライアントが利用可能な推定帯域幅が記載されています。クライアントが利用可能な帯域幅が原因モビリティ、渋滞などに、例えば、RTSPセッション中に変更されることがあり"
    },
    {
      "indent": 3,
      "text": "Clients may not be able to accurately determine the available bandwidth, for example, because the first hop is not a bottleneck. Such a case is when the local area network (LAN) is not the bottleneck, instead the LAN's Internet access link is, if the server is not in the same LAN. Thus, link speeds of WLAN or Ethernet networks are normally not a basis for estimating the available bandwidth. Cellular devices or other devices directly connected to a modem or connection-enabling device may more accurately estimate the bottleneck bandwidth and what is a reasonable share of it for RTSP-controlled media. The client will also need to take into account other traffic sharing the bottleneck. For example, by only assigning a certain fraction to RTSP and its media streams. It is RECOMMENDED that only clients that have accurate and explicit information about bandwidth bottlenecks use this header.",
      "ja": "最初のホップがボトルネックではないので、クライアントは、例えば、正確に利用可能な帯域幅を決定することができないかもしれません。サーバが同じLAN内にない場合は、ローカルエリアネットワーク（LAN）は、代わりに、LANのインターネット・アクセス・リンクがあり、ボトルネックにならないときに、このような場合です。したがって、WLANまたはEthernetネットワークのリンク速度は、通常、利用可能な帯域幅を推定するための基礎ではありません。セルラデバイスまたは他のデバイスを直接モデムに接続された、または接続可能デバイスは、より正確にボトルネック帯域幅を推定してもよいし、RTSP制御メディアにとっての合理的な割合は何です。クライアントも考慮に他のトラフィックのボトルネックを共有を取る必要があります。例えば、唯一のRTSPおよびそのメディア・ストリームに一定の割合を割り当てること。帯域幅のボトルネックに関する正確かつ明示的な情報を持っている唯一のクライアントは、このヘッダを使用することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "This header is not a substitute for proper congestion control. It is only a method providing an initial estimate and coarsely determines if the selected content can be delivered at all.",
      "ja": "このヘッダは、適切な輻輳制御のための代替ではありません。これは、初期推定値を提供する唯一の方法であり、粗く選択されたコンテンツが全く送達することができるかどうかを決定します。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 5,
      "text": "Bandwidth: 62360",
      "ja": "帯域幅：62360"
    },
    {
      "indent": 0,
      "text": "18.10. Blocksize",
      "section_title": true,
      "ja": "18.10. ブロックサイズ"
    },
    {
      "indent": 3,
      "text": "The Blocksize request-header field is sent from the client to the media server asking the server for a particular media packet size. This packet size does not include lower-layer headers such as IP, UDP, or RTP. The server is free to use a blocksize that is lower than the one requested. The server MAY truncate this packet size to the closest multiple of the minimum, media-specific block size or override it with the media-specific size, if necessary. The block size MUST be a positive decimal number measured in octets. The server only returns an error (4xx) if the value is syntactically invalid.",
      "ja": "ブロックサイズリクエストヘッダフィールドは、特定のメディアパケットサイズのサーバーを尋ねるメディアクライアントからサーバに送信されます。このパケットサイズは、IP、UDP、またはRTPなどの下層ヘッダーを含みません。サーバーは、要求されたものよりも低くなっているブロックサイズを使用して自由です。必要であれば、サーバは、最小の最も近い倍数にこのパケットサイズを切り捨て、メディア固有のブロックサイズまたはメディア特有のサイズでそれを無効にすることができます。ブロックサイズはオクテットで測定された正の10進数でなければなりません。サーバが唯一の値が構文的に無効である場合、エラー（4xxの）を返します。"
    },
    {
      "indent": 0,
      "text": "18.11. Cache-Control",
      "section_title": true,
      "ja": "18.11.  Cache-Control"
    },
    {
      "indent": 3,
      "text": "The Cache-Control general-header field is used to specify directives that MUST be obeyed by all caching mechanisms along the request/ response chain.",
      "ja": "Cache-Control一般ヘッダフィールドは、要求/応答チェーンに沿ったすべてのキャッシングメカニズムが従わなければならないディレクティブを指定するために使用されます。"
    },
    {
      "indent": 3,
      "text": "Cache directives MUST be passed through by a proxy or gateway application, regardless of their significance to that application, since the directives may be applicable to all recipients along the request/response chain. It is not possible to specify a cache-directive for a specific cache.",
      "ja": "ディレクティブは、要求/応答チェーンに沿ってすべての受信者に適用することができるので、キャッシュディレクティブは関係なく、そのアプリケーションに対するそれらの重要性の、プロキシまたはゲートウェイアプリケーションが通過しなければなりません。特定のキャッシュのキャッシュ・ディレクティブを指定することはできません。"
    },
    {
      "indent": 3,
      "text": "Cache-Control should only be specified in a DESCRIBE, GET_PARAMETER, SET_PARAMETER, and SETUP request and its response. Note: Cache-Control does not govern only the caching of responses for the RTSP messages, instead it also applies to the media stream identified by the SETUP request. The RTSP requests are generally not cacheable; for further information, see Section 16. Below are the descriptions of the cache directives that can be included in the Cache-Control header.",
      "ja": "Cache-ControlだけDESCRIBE、GET_PARAMETER、SET_PARAMETER、およびSETUP要求とその応答で指定する必要があります。注意：のCache-Controlは、RTSPメッセージに対する応答の唯一のキャッシュを支配しません、代わりにそれはまた、SETUP要求によって識別されたメディアストリームに適用されます。 RTSP要求は、一般的にキャッシュ可能ではありません。詳細については、以下のCache-Controlヘッダに含めることができ、キャッシュ・ディレクティブの記述があり、セクション16を参照してください。"
    },
    {
      "indent": 3,
      "text": "no-cache: Indicates that the media stream or RTSP response MUST NOT be cached anywhere. This allows an origin server to prevent caching even by caches that have been configured to return stale responses to client requests. Note: there is no security function preventing the caching of content.",
      "ja": "ノーキャッシュは：メディア・ストリームまたはRTSP応答がどこかにキャッシュされてはならないことを意味しません。これも、クライアントの要求に古くなったレスポンスを返すように設定されているキャッシュによるキャッシングを防ぐために、オリジンサーバが可能になります。注意：コンテンツのキャッシュを防止することはセキュリティ機能はありません。"
    },
    {
      "indent": 3,
      "text": "public: Indicates that the media stream or RTSP response is cacheable by any cache.",
      "ja": "国民は：メディア・ストリームまたはRTSP応答は任意のキャッシュにより、キャッシュ可能であることを示します。"
    },
    {
      "indent": 3,
      "text": "private: Indicates that the media stream or RTSP response is intended for a single user and MUST NOT be cached by a shared cache. A private (non-shared) cache may cache the media streams.",
      "ja": "プライベート：メディア・ストリームまたはRTSP応答が単一のユーザーを対象とし、共有キャッシュでキャッシュされてはならないことを示します。プライベート（非共有）キャッシュは、メディアストリームをキャッシュすることができます。"
    },
    {
      "indent": 3,
      "text": "no-transform: An intermediate cache (proxy) may find it useful to convert the media type of a certain stream. A proxy might, for example, convert between video formats to save cache space or to reduce the amount of traffic on a slow link. Serious operational problems may occur, however, when these transformations have been applied to streams intended for certain kinds of applications. For example, applications for medical imaging, scientific data analysis and those using end-to-end authentication all depend on receiving a stream that is bit-for-bit identical to the original media stream or RTSP response. Therefore, if a response includes the no-transform directive, an intermediate cache or proxy MUST NOT change the encoding of the stream or response. Unlike HTTP, RTSP does not provide for partial transformation at this point, e.g., allowing translation into a different language.",
      "ja": "無変換：中間キャッシュ（プロキシ）は、それが有用な特定のストリームのメディアタイプを変換することかもしれません。プロキシは、例えば、キャッシュスペースを節約したり、低速リンク上のトラフィックの量を減らすためにビデオフォーマット間の変換可能性があります。これらの変換は、アプリケーションの特定の種類のために意図されたストリームに適用された場合、深刻な操作上の問題は、しかし、発生する可能性があります。例えば、医療用画像、科学的データ分析と、すべてのエンド・ツー・エンド認証を使用してそれらのためのアプリケーションは、ビット単位元のメディアストリームまたはRTSPレスポンスと同一であるストリームを受信に依存します。応答が無変換のディレクティブが含まれている場合そのため、中間キャッシュやプロキシは、ストリームやレスポンスのエンコーディングを変更しないでください。 HTTPとは異なり、RTSPは、異なる言語への翻訳を可能にする、例えば、この時点で部分的変換を提供しません。"
    },
    {
      "indent": 3,
      "text": "only-if-cached: In some cases, such as times of extremely poor network connectivity, a client may want a cache to return only those media streams or RTSP responses that it currently has stored and not to receive these from the origin server. To do this, the client may include the only-if-cached directive in a request. If the cache receives this directive, it SHOULD either respond using a cached media stream or response that is consistent with the other constraints of the request or respond with a 504 (Gateway Timeout) status. However, if a group of caches is being operated as a unified system with good internal connectivity, such a request MAY be forwarded within that group of caches.",
      "ja": "のみ-IF-キャッシュされた：いくつかのケースでは、このような極めて悪いネットワーク接続の時間として、クライアントはキャッシュが現在保存されており、オリジンサーバからこれらを受け取ることはないということだけで、それらのメディアストリームまたはRTSP応答を返すようにしたいことがあります。これを行うには、クライアントはリクエストでのみ-IF-キャッシュされたディレクティブを含むことができます。キャッシュはこの指示を受けた場合、その要求の他の制約と一致しているか、504（ゲートウェイタイムアウト）の状態で応答し、キャッシュされたメディア・ストリームまたは応答を使用して対応すべきであるのいずれか。キャッシュのグループが良好な内部接続で統一されたシステムとして動作している場合は、そのような要求は、キャッシュのそのグループ内で転送されてもよいです。"
    },
    {
      "indent": 3,
      "text": "max-stale: Indicates that the client is willing to accept a media stream or RTSP response that has exceeded its expiration time. If max-stale is assigned a value, then the client is willing to accept a response that has exceeded its expiration time by no more than the specified number of seconds. If no value is assigned to max-stale, then the client is willing to accept a stale response of any age.",
      "ja": "MAX-古い：クライアントは、その有効期限を超過したメディアストリームまたはRTSP応答を受け入れることを望んでいることを示します。 MAX-古いに値が割り当てられている場合、クライアントは、指定された秒数を超えないことによって、その有効期限を超過した応答を受け入れていく所存です。値がMAX-陳腐に割り当てられていない場合は、クライアントはすべての年齢の古い応答を受け入れていく所存です。"
    },
    {
      "indent": 3,
      "text": "min-fresh: Indicates that the client is willing to accept a media stream or RTSP response whose freshness lifetime is no less than its current age plus the specified time in seconds. That is, the client wants a response that will still be fresh for at least the specified number of seconds.",
      "ja": "分、新鮮：クライアントは、その新鮮生涯その現在の年齢プラス秒で指定された時間以上であるメディア・ストリームまたはRTSP応答を受け入れることを望んでいることを示します。これは、クライアントがまだ秒の少なくとも指定された数のために新鮮になります応答を望んでいる、です。"
    },
    {
      "indent": 3,
      "text": "must-revalidate: When the must-revalidate directive is present in a SETUP response received by a cache, that cache MUST NOT use the cache entry after it becomes stale to respond to a subsequent request without first revalidating it with the origin server. That is, the cache is required to do an end-to-end revalidation every time, if, based solely on the origin server's Expires, the cached response is stale.",
      "ja": "必要があり、再検証：必須-再検証ディレクティブは、キャッシュが受信したSETUP応答中に存在する場合、それは最初にオリジンサーバとそれを再検証せずに、後続の要求に応答するために古くなった後、そのキャッシュがキャッシュエントリを使用してはなりません。もっぱらのは、有効期限オリジンサーバに基づいて、キャッシュされたレスポンスが古くなって、場合つまり、キャッシュは、エンドツーエンドの再検証を毎回行うために必要とされます。"
    },
    {
      "indent": 3,
      "text": "proxy-revalidate: The proxy-revalidate directive has the same meaning as the must-revalidate directive, except that it does not apply to non-shared user agent caches. It can be used on a response to an authenticated request to permit the user's cache to store and later return the response without needing to revalidate it (since it has already been authenticated once by that user), while still requiring proxies that service many users to revalidate each time (in order to make sure that each user has been authenticated). Note that such authenticated responses also need the \"public\" cache directive in order to allow them to be cached at all.",
      "ja": "プロキシ再検証：プロキシ再検証ディレクティブそれが非共有ユーザエージェントキャッシュには適用されないことを除いて、必見再検証ディレクティブと同じ意味を持っています。まだ必要としながら、プロキシはに多くのユーザー、サービス、保存し、後で（それはすでにそのユーザが一度認証されたので）それを再検証する必要なしに応答を返すために、ユーザーのキャッシュを可能にするために、認証要求への応答に使用することができます（各ユーザーが認証されていることを確認するために）毎回再検証。このように認証応答はまた、彼らはまったくキャッシュされることを可能にするために「公共」のキャッシュディレクティブが必要であることに注意してください。"
    },
    {
      "indent": 3,
      "text": "max-age: When an intermediate cache is forced, by means of a max-age=0 directive, to revalidate its own cache entry, and the client has supplied its own validator in the request, the supplied validator might differ from the validator currently stored with the cache entry. In this case, the cache MAY use either validator in making its own request without affecting semantic transparency.",
      "ja": "最大エージング：中間キャッシュが独自のキャッシュエントリを再検証するために、最大エージング= 0ディレクティブによって、強制され、そしてクライアントが要求して、独自のバリデータを提供してきました、供給バリデータは現在、バリデータと異なる場合がありますキャッシュエントリに保存されました。この場合、キャッシュは、意味の透明性に影響を与えることなく、独自の要求を行うことでバリデータのいずれかを使用するかもしれません。"
    },
    {
      "indent": 9,
      "text": "However, the choice of validator might affect performance.  The\nbest approach is for the intermediate cache to use its own\nvalidator when making its request.  If the server replies with\n304 (Not Modified), then the cache can return its now validated\ncopy to the client with a 200 (OK) response.  If the server\nreplies with a new message body and cache validator, however, the intermediate cache can compare the returned validator with\nthe one provided in the client's request, using the strong\ncomparison function.  If the client's validator is equal to the\norigin server's, then the intermediate cache simply returns 304\n(Not Modified).  Otherwise, it returns the new message body\nwith a 200 (OK) response.",
      "raw": true
    },
    {
      "indent": 0,
      "text": "18.12. Connection",
      "section_title": true,
      "ja": "18.12. 接続"
    },
    {
      "indent": 3,
      "text": "The Connection general-header field allows the sender to specify options that are desired for that particular connection. It MUST NOT be communicated by proxies over further connections.",
      "ja": "接続一般的なヘッダフィールドは、送信者がその特定の接続のために所望されるオプションを指定することを可能にします。さらに、接続上でプロキシが伝えてはなりません。"
    },
    {
      "indent": 3,
      "text": "RTSP 2.0 proxies MUST parse the Connection header field before a message is forwarded and, for each connection-token in this field, remove any header field(s) from the message with the same name as the connection-token. Connection options are signaled by the presence of a connection-token in the Connection header field, not by any corresponding additional header field(s), since the additional header field may not be sent if there are no parameters associated with that connection option.",
      "ja": "RTSP 2.0プロキシはメッセージが転送される前に、接続ヘッダフィールドを解析して、各接続トークンは、この分野では、接続トークンと同じ名前を持つメッセージから任意のヘッダフィールド（複数可）を削除する必要があります。その接続オプションに関連付けられたパラメータがない場合は、追加ヘッダフィールドは送信されないかもしれないので、接続オプションは、接続ヘッダフィールドではなく、任意の対応する追加のヘッダフィールド（複数可）によって接続トークンの存在によってシグナリングされます。"
    },
    {
      "indent": 3,
      "text": "Message headers listed in the Connection header MUST NOT include end-to-end headers, such as Cache-Control.",
      "ja": "接続ヘッダに記載されているメッセージヘッダーは、キャッシュ・コントロールのようなエンド・ツー・エンドのヘッダを含んではいけません。"
    },
    {
      "indent": 3,
      "text": "RTSP 2.0 defines the \"close\" connection option for the sender to signal that the connection will be closed after completion of the response. For example, \"Connection: close in either the request or the response-header fields\" indicates that the connection SHOULD NOT be considered \"persistent\" (Section 10.2) after the current request/ response is complete.",
      "ja": "RTSP 2.0は、接続応答完了後にクローズされることを知らせるために、送信者は、「クローズ」接続オプションを定義します。例えば、「接続：リクエストまたはレスポンス・ヘッダー・フィールドのいずれかに近い」とは、現在の要求/応答が完了した後、接続が（10.2）「永続的」とみなされるべきではないことを示しています。"
    },
    {
      "indent": 3,
      "text": "The use of the connection option \"close\" in RTSP messages SHOULD be limited to error messages when the server is unable to recover and therefore sees it necessary to close the connection. The reason being that the client has the choice of continuing using a connection indefinitely, as long as it sends valid messages.",
      "ja": "「クローズ」RTSPメッセージでの接続オプションを使用すると、サーバーが回復することができないため、接続をクローズすることが必要で見たときにエラーメッセージに限定されるべきです。その理由は、クライアントがあれば、有効なメッセージを送信して、無期限に接続を使用して継続する選択肢を持っているということで。"
    },
    {
      "indent": 0,
      "text": "18.13. Connection-Credentials",
      "section_title": true,
      "ja": "18.13. 接続資格情報"
    },
    {
      "indent": 3,
      "text": "The Connection-Credentials response-header is used to carry the chain of credentials for any next hop that needs to be approved by the requester. It MUST only be used in server-to-client responses.",
      "ja": "コネクション・クレデンシャルレスポンスヘッダは、要求者によって承認される必要がある任意の次のホップの資格情報の鎖を運ぶために使用されます。それだけで、サーバからクライアントへの応答に使用されなければなりません。"
    },
    {
      "indent": 3,
      "text": "The Connection-Credentials header in an RTSP response MUST, if included, contain the credential information (in the form of a list of certificates providing the chain of certification) of the next hop to which an intermediary needs to securely connect. The header MUST include the URI of the next hop (proxy or server) and a Base64-encoded (according to Section 4 of [RFC4648] and where the padding bits are set to zero) binary structure containing a sequence of DER-encoded X.509v3 certificates [RFC5280].",
      "ja": "接続-クレデンシャルRTSPレスポンスのヘッダ、含まれている場合、中間に安全に接続する必要があるの次のホップの（証明書のチェーンを提供する証明書のリストの形で）資格情報を含まなければなりません。ヘッダは、次のホップのURI（プロキシまたはサーバ）とを含まなければなりませんBase64でエンコードされたDER符号化されたXの配列を含むバイナリ構造（パディングビットはゼロに設定されている[RFC4648]のセクション4とに応じて） 509v3証明書[RFC5280]。"
    },
    {
      "indent": 3,
      "text": "The binary structure starts with the number of certificates (NR_CERTS) included as a 16-bit unsigned integer. This is followed by an NR_CERTS number of 16-bit unsigned integers providing the size, in octets, of each DER-encoded certificate. This is followed by an NR_CERTS number of DER-encoded X.509v3 certificates in a sequence (chain). This format is exemplified in Figure 6. The certificate of the proxy or server must come first in the structure. Each following certificate must directly certify the one preceding it. Because certificate validation requires that root keys be distributed independently, the self-signed certificate that specifies the root certificate authority may optionally be omitted from the chain, under the assumption that the remote end must already possess it in order to validate it in any case.",
      "ja": "バイナリ構造は、証明書（NR_CERTS）の数で始まる16ビットの符号なし整数として含まれます。これはオクテットで、各DER符号化された証明書の大きさを提供する16ビット符号なし整数のNR_CERTS番号が続きます。これは、配列（鎖）でDER符号化されたX.509v3証明書のNR_CERTS番号が続きます。このフォーマットは、プロキシまたはサーバの証明書構造に最初に来る必要があり、図6に例示されています。それぞれの次の証明書は直接それに先行するものを証明する必要があります。証明書の検証がルートキーは独立に分布されることを必要とするので、ルート認証局を特定する自己署名証明書は、必要に応じて、リモートエンドが既にどのような場合に、それを検証するためにそれを持っていなければならないという仮定の下で、チェーンから省略されてもよいです。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 3,
      "text": "Connection-Credentials:\"rtsps://proxy2.example.com/\";MIIDNTCC...",
      "ja": "接続資格情報： \"RTSPS：//proxy2.example.com/\"; MIIDNTCC ..."
    },
    {
      "indent": 3,
      "text": "Where MIIDNTCC... is a Base64 encoding of the following structure:",
      "ja": "MIIDNTCCは...次の構造のBase64エンコーディングです。"
    },
    {
      "indent": 7,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Number of certificates       | Size of certificate #1        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Size of certificate #2        | Size of certificate #3        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n: DER Encoding of Certificate #1                                :\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n: DER Encoding of Certificate #2                                :\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n: DER Encoding of Certificate #3                                :\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Figure 6: Format Example of Connection-Credentials Header Certificate",
      "ja": "図6：接続-資格情報ヘッダー証明書の書式例"
    },
    {
      "indent": 0,
      "text": "18.14. Content-Base",
      "section_title": true,
      "ja": "18.14. コンテンツベース"
    },
    {
      "indent": 3,
      "text": "The Content-Base message body header field may be used to specify the base URI for resolving relative URIs within the message body.",
      "ja": "コンテンツベースのメッセージボディヘッダフィールドは、メッセージボディ内の相対URIを解決するためのベースURIを指定するために使用されてもよいです。"
    },
    {
      "indent": 3,
      "text": "Content-Base: rtsp://media.example.com/movie/twister/",
      "ja": "コンテンツベース：RTSP：//media.example.com/movie/twister/"
    },
    {
      "indent": 3,
      "text": "If no Content-Base field is present, the base URI of a message body is defined by either its Content-Location (if that Content-Location URI is an absolute URI) or the URI used to initiate the request, in that order of precedence. Note, however, that the base URI of the contents within the message body may be redefined within that message body.",
      "ja": "いかなるコンテンツベースのフィールドが存在しない場合、メッセージボディのベースURIは、そのコンテンツの場所のいずれかによって定義される（すなわちコンテンツロケーションURIは、絶対URIである場合）またはURIが優先のために、要求を開始するために使用しました。メッセージ本体内の内容のベースURIは、そのメッセージ本体内で再定義されてもよいことが、注意してください。"
    },
    {
      "indent": 0,
      "text": "18.15. Content-Encoding",
      "section_title": true,
      "ja": "18.15. コンテンツのエンコード"
    },
    {
      "indent": 3,
      "text": "The Content-Encoding message body header field is used as a modifier of the media-type. When present, its value indicates what additional content-codings have been applied to the message body, and thus what decoding mechanisms must be applied in order to obtain the media-type referenced by the Content-Type header field. Content-Encoding is primarily used to allow a document to be compressed without losing the identity of its underlying media type.",
      "ja": "コンテンツ符号化メッセージボディヘッダフィールドはメディアタイプの修飾子として使用されます。存在する場合、その値は、追加の内容コーディングは、復号メカニズムはContent-Typeヘッダフィールドによって参照されるメディアタイプを得るために適用されなければならないもの、したがって、メッセージボディに適用されてきたものを示しています。コンテンツのエンコーディングは、主に文書がその根底にあるメディアタイプのアイデンティティを失わずに圧縮することができるようにするために使用されます。"
    },
    {
      "indent": 3,
      "text": "The content-coding is a characteristic of the message body identified by the Request-URI. Typically, the message body is stored with this encoding and is only decoded before rendering or analogous usage. However, an RTSP proxy MAY modify the content-coding if the new coding is known to be acceptable to the recipient, unless the \"no-transform\" cache directive is present in the message.",
      "ja": "コンテンツコードは、Request-URIによって識別されるメッセージボディの特性です。典型的には、メッセージ本体は、この符号化で記憶されるのみレンダリングまたは類似の使用の前に復号されます。新しいコーディングは「無変換」キャッシュディレクティブは、メッセージ中に存在しない限り、受信者に許容可能であることが知られている場合は、RTSPプロキシは、コンテンツのコーディングを変更することができます。"
    },
    {
      "indent": 3,
      "text": "If the content-coding of a message body is not \"identity\", then the message MUST include a Content-Encoding message body header that lists the non-identity content-coding(s) used.",
      "ja": "メッセージ本文の内容コーディングは、「同一性」ではない場合、そのメッセージは、使用される非同一（S）コンテンツコードを一覧表示し、コンテンツ符号化メッセージボディヘッダを含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the content-coding of a message body in a request message is not acceptable to the origin server, the server SHOULD respond with a status code of 415 (Unsupported Media Type).",
      "ja": "リクエスト・メッセージのメッセージ体の内容コーディングは、オリジンサーバに対して許容できない場合、サーバは415（サポートされていないメディアタイプ）のステータスコードで応答すべきです。"
    },
    {
      "indent": 3,
      "text": "If multiple encodings have been applied to a message body, the content-codings MUST be listed in the order in which they were applied, first to last from left to right. Additional information about the encoding parameters MAY be provided by other header fields not defined by this specification.",
      "ja": "複数のエンコーディングは、メッセージボディに適用された場合は、内容コーディングは、左から右に続く最初、それらが適用された順にリストされなければなりません。符号化パラメータに関する追加情報は、本明細書で定義されていない他のヘッダフィールドによって提供されてもよいです。"
    },
    {
      "indent": 0,
      "text": "18.16. Content-Language",
      "section_title": true,
      "ja": "18.16. コンテンツ言語"
    },
    {
      "indent": 3,
      "text": "The Content-Language message body header field describes the natural language(s) of the intended audience for the enclosed message body. Note that this might not be equivalent to all the languages used within the message body.",
      "ja": "コンテンツ言語メッセージボディヘッダフィールドは、同封のメッセージボディの対象読者の自然言語（単数または複数）を記述する。これは、メッセージ本文内で使用されるすべての言語と同等ではないかもしれないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "Language tags are mentioned in Section 18.4. The primary purpose of Content-Language is to allow a user to identify and differentiate entities according to the user's own preferred language. Thus, if the body content is intended only for a Danish-literate audience, the appropriate field is",
      "ja": "言語タグは、18.4節に記載されています。コンテンツ言語の主な目的は、ユーザーがユーザー自身の好みの言語に応じて、エンティティを識別し、区別できるようにすることです。本文の内容のみデンマーク読み書き聴衆のために意図されている場合このように、適切なフィールドがあります"
    },
    {
      "indent": 6,
      "text": "Content-Language: da",
      "ja": "コンテンツ言語：ダ"
    },
    {
      "indent": 3,
      "text": "If no Content-Language is specified, the default is that the content is intended for all language audiences. This might mean that the sender does not consider it to be specific to any natural language or that the sender does not know for which language it is intended.",
      "ja": "何のContent-言語が指定されていない場合、デフォルトでは、コンテンツは、すべての言語の視聴者のために意図されていることです。これは、送信者が、それは任意の自然言語または送信者が、それが意図されている言語に知らないことに特異的であることが考慮されていないことを意味します。"
    },
    {
      "indent": 3,
      "text": "Multiple languages MAY be listed for content that is intended for multiple audiences. For example, a rendition of the \"Treaty of Waitangi\", presented simultaneously in the original Maori and English versions, would call for",
      "ja": "複数の言語では、複数の聴衆のために意図されているコンテンツのために表示されることがあります。たとえば、オリジナルのマオリ語版と英語版に同時に提示「ワイタンギ条約」の演出は、のために呼び出します"
    },
    {
      "indent": 6,
      "text": "Content-Language: mi, en",
      "ja": "コンテンツ言語：私、"
    },
    {
      "indent": 3,
      "text": "However, just because multiple languages are present within a message body does not mean that it is intended for multiple linguistic audiences. An example would be a beginner's language primer, such as \"A First Lesson in Latin\", which is clearly intended to be used by an English-literate audience. In this case, the Content-Language would properly only include \"en\".",
      "ja": "しかし、複数の言語は、メッセージ本文内に存在しているという理由だけで、それが複数の言語の聴衆のために意図されていることを意味するものではありません。一例では、このような明確英語 - 学問の聴衆が使用することを意図している「ラテン語で最初のレッスン」、として、初心者の言語プライマーだろう。この場合、コンテンツ言語が適切にのみ「EN」が含まれるであろう。"
    },
    {
      "indent": 3,
      "text": "Content-Language MAY be applied to any media type -- it is not limited to textual documents.",
      "ja": "コンテンツ言語は、任意のメディアタイプにも適用することができる - それは、テキスト文書に限定されるものではありません。"
    },
    {
      "indent": 0,
      "text": "18.17. Content-Length",
      "section_title": true,
      "ja": "18.17. コンテンツの長さ"
    },
    {
      "indent": 3,
      "text": "The Content-Length message body header field contains the length of the message body of the RTSP message (i.e., after the double CRLF following the last header) in octets of bits. Unlike HTTP, it MUST be included in all messages that carry a message body beyond the header portion of the RTSP message. If it is missing, a default value of zero is assumed. Any Content-Length greater than or equal to zero is a valid value.",
      "ja": "コンテンツ長のメッセージボディヘッダフィールドは、ビットのオクテットでRTSPメッセージ（すなわち、最後のヘッダに続く二重CRLF後）のメッセージ本体の長さを含みます。 HTTPとは異なり、RTSPメッセージのヘッダ部を越えてメッセージ本体を運ぶすべてのメッセージに含まれなければなりません。それが欠落している場合、デフォルト値のゼロが想定されます。 0以上の任意のContent-Lengthは有効な値です。"
    },
    {
      "indent": 0,
      "text": "18.18. Content-Location",
      "section_title": true,
      "ja": "18.18. コンテンツの場所"
    },
    {
      "indent": 3,
      "text": "The Content-Location message body header field MAY be used to supply the resource location for the message body enclosed in the message when that body is accessible from a location separate from the requested resource's URI. A server SHOULD provide a Content-Location for the variant corresponding to the response message body; especially in the case where a resource has multiple variants associated with it, and those entities actually have separate locations by which they might be individually accessed, the server SHOULD provide a Content-Location for the particular variant that is returned.",
      "ja": "コンテンツロケーションメッセージボディヘッダフィールドその本体は、要求されたリソースのURIから離れた場所からアクセス可能なメッセージで囲まれたメッセージ本文のためのリソースの場所を供給するために使用され得ます。サーバは、応答メッセージのボディに対応する変異体のためのコンテンツの場所を提供すべきです。特に、リソースがそれに関連付けられた複数のバリアントを持っており、それらのエンティティは、実際に彼らは個別にアクセスされるかもしれないことで、別の場所を持っている場合には、サーバが返され、特定の変異体のためのContent-場所を提供する必要があります。"
    },
    {
      "indent": 3,
      "text": "As an example, if an RTSP client performs a DESCRIBE request on a given resource, e.g., \"rtsp://a.example.com/movie/ Plan9FromOuterSpace\", then the server may use additional information, such as the User-Agent header, to determine the capabilities of the agent. The server will then return a media description tailored to that class of RTSP agents. To indicate which specific description the agent receives, the resource identifier (\"rtsp://a.example.com/movie/Plan9FromOuterSpace/FullHD.sdp\") is provided in Content-Location, while the description is still a valid response for the generic resource identifier, thus enabling both debugging and cache operation as discussed below.",
      "ja": "RTSPクライアントが実行する場合の例として、特定のリソースにリクエストをDESCRIBE、例えば、「RTSP：//a.example.com/movie/ Plan9FromOuterSpace」は、次いで、サーバは、User-Agentヘッダのような付加的な情報を、使用することができます、エージェントの能力を決定します。その後、サーバは、RTSPエージェントのそのクラスに合わせたメディア記述を返します。エージェントが受信するどの特定の説明を示すために、リソース識別子（「RTSP：//a.example.com/movie/Plan9FromOuterSpace/FullHD.sdp」）が記述は依然としての有効な応答であるが、コンテンツの場所に設けられています。後述するように、一般的なリソース識別子は、従って、デバッグ及びキャッシュ操作の両方を可能にします。"
    },
    {
      "indent": 3,
      "text": "The Content-Location value is not a replacement for the original requested URI; it is only a statement of the location of the resource corresponding to this particular variant at the time of the request. Future requests MAY specify the Content-Location URI as the Request-URI if the desire is to identify the source of that particular variant. This is useful if the RTSP agent desires to verify if the resource variant is current through a conditional request.",
      "ja": "コンテンツの場所の値は、元の要求されたURIに代わるものではありません。それは、要求時に、この特定の変異体に対応するリソースの場所の唯一の文です。欲求は、その特定の変異体の原因を特定することである場合には、将来の要求は、Request-URIとしてContent-場所URIを指定するかもしれません。 RTSPエージェントはリソースのバリアントが条件付きリクエストを流れる電流であるかどうかを確認したい場合に便利です。"
    },
    {
      "indent": 3,
      "text": "A cache cannot assume that a message body with a Content-Location different from the URI used to retrieve it can be used to respond to later requests on that Content-Location URI. However, the Content-Location can be used to differentiate between multiple variants retrieved from a single requested resource.",
      "ja": "キャッシュは、URIは異なるコンテンツの場所とメッセージ本文は、そのコンテンツの場所URIの後のリクエストに応答するために使用することができます取得するために使用されることを想定することはできません。しかし、コンテンツの場所は、単一の要求されたリソースから取得した複数の亜種を区別するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "If the Content-Location is a relative URI, the relative URI is interpreted relative to the Request-URI.",
      "ja": "コンテンツの場所が相対URIであれば、相対URIは、Request-URIに関連して解釈されます。"
    },
    {
      "indent": 3,
      "text": "Note that Content-Location can be used in some cases to derive the base-URI for relative URI(s) present in session description formats. This needs to be taken into account when Content-Location is used. The easiest way to avoid needing to consider that issue is to include the Content-Base whenever the Content-Location is included.",
      "ja": "コンテンツロケーションセッション記述形式で存在する相対URI（S）のためのベースURIを導出するためにいくつかのケースで使用することができることに留意されたいです。これは、コンテンツの場所を使用する場合に考慮する必要があります。その問題を検討する必要がないようにする最も簡単な方法は、コンテンツの場所が含まれているときは常にコンテンツベースを含めることです。"
    },
    {
      "indent": 3,
      "text": "Note also, when using Media Tags in conjunction with Content-Location, it is important that the different versions have different MTags, even if provided under different Content-Location URIs. This is because the different content variants still have been provided in response to the same request URI.",
      "ja": "コンテンツの場所と一緒にメディアタグを使用しているときにも注意してください、別のバージョンが異なるコンテンツの場所のURIの下に設けられていても、異なるMTagsを有することが重要です。異なるコンテンツ変異体はまだ同じリクエストURIに応じて提供されているためです。"
    },
    {
      "indent": 3,
      "text": "Note also, as in most cases, the URIs used in the DESCRIBE and the SETUP requests are different: the URI provided in a DESCRIBE Content-Location response can't directly be used in a SETUP request. Instead, the steps of deriving the media resource URIs are necessary. This commonly involves combing the media description's relative URIs, e.g., from the SDP's a=control attribute, with the base-URI to create the absolute URIs needed in the SETUP request.",
      "ja": "また、ほとんどの場合のように、URIはで使用されるノートについて説明し、SETUP要求が異なっている：URIは直接SETUP要求で使用することはできませんDESCRIBEのContent-場所応答して提供。代わりに、メディアリソースのURIを導出する手順が必要です。これは、一般に、ベースURIのSETUP要求に必要な絶対URIを作成すると、SDPのA =制御属性から、例えば、メディア記述の相対URIをコーミングすることを含みます。"
    },
    {
      "indent": 0,
      "text": "18.19. Content-Type",
      "section_title": true,
      "ja": "18.19. コンテンツタイプ"
    },
    {
      "indent": 3,
      "text": "The Content-Type message body header indicates the media type of the message body sent to the recipient. Note that the content types suitable for RTSP are likely to be restricted in practice to presentation descriptions and parameter-value types.",
      "ja": "コンテンツタイプメッセージボディヘッダは、受信者に送信されたメッセージ本体のメディアタイプを示しています。 RTSPに適したコンテンツタイプは、プレゼンテーションの説明とパラメータ値の型に実際に制限される可能性があることに注意してください。"
    },
    {
      "indent": 0,
      "text": "18.20. CSeq",
      "section_title": true,
      "ja": "18.20.  CSeq"
    },
    {
      "indent": 3,
      "text": "The CSeq general-header field specifies the sequence number (integer) for an RTSP request/response pair. This field MUST be present in all requests and responses. RTSP agents maintain a sequence number series for each responder to which they have an open message transport channel. For each new RTSP request an agent originates on a particular RTSP message transport, the CSeq value MUST be incremented by one. The initial sequence number can be any number; however, it is RECOMMENDED to start at 0. Each sequence number series is unique between each requester and responder, i.e., the client has one series for its requests to a server and the server has another when sending requests to the client. Each requester and responder is identified by its socket address (IP address and port number), i.e., per direction of a TCP connection. Any retransmitted request MUST contain the same sequence number as the original, i.e., the sequence number is not incremented for retransmissions of the same request. The RTSP agent receiving requests MUST process the requests arriving on a particular transport in the order of the sequence numbers. Responses are sent in the order that they are generated. The RTSP response MUST have the same sequence number as was present in the corresponding request. An RTSP agent receiving a response MAY receive the responses out of order compared to the order of the requests it sent. Thus, the agent MUST use the sequence number in the response to pair it with the corresponding request.",
      "ja": "CSeq一般ヘッダフィールドは、RTSPリクエスト/レスポンス・ペアのシーケンス番号（整数）を指定します。このフィールドは、すべての要求と応答中に存在しなければなりません。 RTSP剤は、それらがオープンメッセージのトランスポート・チャネルを有するれる各応答のシーケンス番号のシリーズを維持します。エージェントが特定のRTSPメッセージ輸送に起因各新しいRTSP要求に対して、のCSeq値を1つインクリメントしなければなりません。初期シーケンス番号は、任意の数とすることができます。しかし、各シーケンス番号シリーズは、各リクエスタとレスポンダとの間で一意である0で開始するように推奨される、すなわち、クライアントは、サーバへの要求のための1つのシリーズがあり、クライアントに要求を送信するとき、サーバは、別のものを有しています。各リクエスターとレスポンダは、すなわち、TCPコネクションの方向ごとに、そのソケットアドレス（IPアドレス及びポート番号）によって識別されます。任意再送要求、すなわち、シーケンス番号が同じ要求の再送信のために増加されていない、オリジナルと同一のシーケンス番号を含まなければなりません。リクエストを受けたRTSPエージェントは、シーケンス番号順に特定のトランスポートに到着リクエストを処理しなければなりません。応答は、それらが生成された順に送信されます。対応する要求に存在したとしてRTSP応答は、同じシーケンス番号を持たなければなりません。応答を受信したRTSPエージェントは、それが送信された要求の順序に比べ順不同で応答を受け取ることができます。したがって、エージェントは対応する要求とペアリングすることに応答して、シーケンス番号を使用しなければなりません。"
    },
    {
      "indent": 6,
      "text": "The main purpose of the sequence number is to map responses to requests.",
      "ja": "シーケンス番号の主な目的は、要求への応答をマッピングすることです。"
    },
    {
      "indent": 6,
      "text": "The requirement to use a sequence-number increment of one for each new request is to support any future specification of RTSP message transport over a protocol that does not provide in-order delivery or is unreliable.",
      "ja": "各新しい要求ための一つのシーケンス番号のインクリメントを使用するための要件は、インオーダー配信を提供したり、信頼できないないプロトコル上のRTSPメッセージトランスポートのいずれかの将来の仕様をサポートすることです。"
    },
    {
      "indent": 6,
      "text": "The above rules relating to the initial sequence number may appear unnecessarily loose. The reason for this is to cater to some common behavior of existing implementations: when using multiple reliable connections in sequence, it may still be easiest to use a single sequence-number series for a client connecting with a particular server. Thus, the initial sequence number may be arbitrary depending on the number of previous requests. For any unreliable transport, a stricter definition or other solution will be required to enable detection of any loss of the first request.",
      "ja": "初期シーケンス番号に関連する上記の規則は、不必要に緩んで表示されることがあります。この理由は、既存の実装のいくつかの一般的な動作に対応するためである：順序で複数の信頼性の高い接続を使用する場合、それはまだ、特定のサーバに接続するクライアントのための単一のシーケンス番号のシリーズを使用するのが最も簡単かもしれません。このように、初期シーケンス番号は、前の要求の数に応じて任意であってもよいです。任意の信頼性の低いトランスポートのために、より厳格な定義または他の溶液が最初の要求の損失の検出を可能にするために必要とされるであろう。"
    },
    {
      "indent": 6,
      "text": "When using multiple sequential transport connections, there is no protocol mechanism to ensure in-order processing as the sequence number is scoped on the individual transport connection and its five tuple. Thus, there are potential issues with opening a new transport connection to the same host for which there already exists a transport connection with outstanding requests and previously dispatched requests related to the same RTSP session.",
      "ja": "複数の連続輸送の接続を使用する場合、シーケンス番号は、個々のトランスポート接続およびその5つのタプルにスコープされているように次の処理を確実にするために何のプロトコルメカニズムは存在しません。このように、すでに未処理の要求と同じRTSPセッションに関連する以前に派遣要求とトランスポート接続が存在しているため、同じホストへの新しいトランスポート接続をオープンするとの潜在的な問題があります。"
    },
    {
      "indent": 3,
      "text": "RTSP Proxies also need to follow the above rules. This implies that proxies that aggregate requests from multiple clients onto a single transport towards a server or a next-hop proxy need to renumber these requests to form a unified sequence on that transport, fulfilling the above rules. A proxy capable of fulfilling some agent's request without emitting its own request (e.g., a caching proxy that fulfills a request from its cache) also causes a need to renumber as the number of received requests with a particular target may not be the same as the number of emitted requests towards that target agent. A proxy that needs to renumber needs to perform the corresponding renumbering back to the original sequence number for any received response before forwarding it back to the originator of the request.",
      "ja": "RTSPプロキシはまた、上記のルールに従う必要があります。これは、サーバまたはネクストホッププロキシに向かって単一のトランスポート上で複数のクライアントからの要求を集約プロキシは、上記の規則を満たす、その輸送に統一された配列を形成するためにこれらの要求を付け直す必要があることを意味します。特定のターゲットと受信要求の数が同じではないかもしれないとして、独自の要求（例えば、そのキャッシュからの要求を満たし、キャッシングプロキシ）を放出することなく、いくつかのエージェントの要求を満たすことができるプロキシは、番号を付け直す必要性が発生しますそのターゲットエージェントへの放出された要求の数。対応するいずれかの元のシーケンス番号にリナンバリングを実行する必要性を付け直す必要があるプロキシは、要求の発信元に戻し転送する前に応答を受信しました。"
    },
    {
      "indent": 6,
      "text": "A client connected to a proxy, and using that transport to send requests to multiple servers, creates a situation where it is quite likely to receive the responses out of order. This is because the proxy will establish separate transports from the proxy to the servers on which to forward the client's requests. When the responses arrive from the different servers, they will be forwarded to the client in the order they arrive at the proxy and can be processed, not the order of the client's original sequence numbers. This is intentional to avoid some session's requests being blocked by another server's slow processing of requests.",
      "ja": "クライアントがプロキシに接続され、複数のサーバに要求を送信するためにそのトランスポートを使用して、故障して応答を受信することは非常に可能性のある状況を作成します。プロキシは、クライアントの要求を転送するためのサーバーへのプロキシから独立したトランスポートを確立するためです。応答が異なるサーバから到着すると、それらは、プロキシに到着すると、クライアントの元のシーケンス番号のないようにするため、処理できるために、クライアントに転送されます。これは、いくつかのセッションのリクエストは、リクエストの別のサーバの遅い処理によってブロックされないように意図的なものです。"
    },
    {
      "indent": 0,
      "text": "18.21. Date",
      "section_title": true,
      "ja": "18.21. 日付"
    },
    {
      "indent": 3,
      "text": "The Date general-header field represents the date and time at which the message was originated. The inclusion of the Date header in an RTSP message follows these rules:",
      "ja": "日一般的なヘッダフィールドは、メッセージが発信された日付と時刻を表します。 RTSPメッセージ内の日付ヘッダを含めることは、これらの規則に従います。"
    },
    {
      "indent": 3,
      "text": "o An RTSP message, sent by either the client or the server, containing a body MUST include a Date header, if the sending host has a clock;",
      "ja": "送信ホストはクロックを有する場合、クライアントまたはサーバのいずれかによって送信されたRTSPメッセージ、O、体を含有する、日付ヘッダを含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "o Clients and servers are RECOMMENDED to include a Date header in all other RTSP messages, if the sending host has a clock;",
      "ja": "Oクライアントとサーバは、送信ホストがクロックを持っている場合は、他のすべてのRTSPメッセージにDateヘッダを含めることをお勧めします。"
    },
    {
      "indent": 3,
      "text": "o If the server does not have a clock that can provide a reasonable approximation of the current time, its responses MUST NOT include a Date header field. In this case, this rule MUST be followed: some origin-server implementations might not have a clock available. An origin server without a clock MUST NOT assign Expires or Last-Modified values to a response, unless these values were associated with the resource by a system or user with a reliable clock. It MAY assign an Expires value that is known, at or before server-configuration time, to be in the past (this allows \"pre-expiration\" of responses without storing separate Expires values for each resource).",
      "ja": "サーバは、現在の時間の合理的な近似を提供することができます時計を持っていない場合は、O、その応答はDateヘッダフィールドを含んではいけません。この場合は、この規則に従わなければなりません：いくつかのオリジンサーバの実装が可能なクロックを持っていない可能性があります。時計のないオリジンサーバは、これらの値は信頼性の高いクロックを持つシステムまたはユーザーによってリソースに関連付けられた場合を除き、応答に値を期限切れになるかのLast-Modified割り当ててはなりません。それは（これは、別個の記憶せず応答の「前有効期限」を可能にする、各リソースの値を有効期限）は、過去にあると、サーバ構成時またはそれ以前に、知られている有効期限の値を割り当てることができます。"
    },
    {
      "indent": 3,
      "text": "A received message that does not have a Date header field MUST be assigned one by the recipient if the message will be cached by that recipient. An RTSP implementation without a clock MUST NOT cache responses without revalidating them on every use. An RTSP cache, especially a shared cache, SHOULD use a mechanism, such as the Network Time Protocol (NTP) [RFC5905], to synchronize its clock with a reliable external standard.",
      "ja": "メッセージはその受信者によってキャッシュされる場合はDateヘッダフィールドを持っていない、受信したメッセージは、受信者によって1を割り当てなければなりません。クロックなしRTSPの実装では、使用するたびに、それらを再確認せずにキャッシュ応答してはなりません。 RTSPキャッシュ、特に共有キャッシュは、信頼性の高い外部標準とそのクロックを同期させるために、Network Time Protocol（NTP）などのメカニズム、[RFC5905]を使用すべきです。"
    },
    {
      "indent": 3,
      "text": "The RTSP-date, a full date as specified by Section 3.3 of [RFC5322], sent in a Date header SHOULD NOT represent a date and time subsequent to the generation of the message. It SHOULD represent the best available approximation of the date and time of message generation, unless the implementation has no means of generating a reasonably accurate date and time. In theory, the date ought to represent the moment just before the message body is generated. In practice, the date can be generated at any time during the message origination without affecting its semantic value.",
      "ja": "RTSP-日付、日付ヘッダで送信され、[RFC5322]のセクション3.3で指定された完全な日付は、メッセージの生成に続いて、日付と時刻を表すべきではありません。実装が合理的に正確な日付と時刻を生成する手段がない場合を除きこれは、メッセージの発生日時の利用可能な最善の近似を表現して下さい。理論的には、日付がメッセージ本文が生成される直前の瞬間を表すべきです。実際には、日付はその意味値に影響を与えることなく、メッセージの発信時にいつでも生成することができます。"
    },
    {
      "indent": 6,
      "text": "Note: The RTSP 2.0 date format is defined to be the full-date format in RFC 5322. This format is more flexible than the date format in RFC 1123 used by RTSP 1.0. Thus, implementations should use single spaces as separators, as recommended by RFC 5322, and support receiving the obsolete format.",
      "ja": "注：RTSP 2.0日付形式がこの形式はRTSP 1.0で使用されるRFC 1123に日付形式よりも柔軟であるRFC 5322にフル日付フォーマットであると定義されます。したがって、実装は、RFC 5322によって推奨されるように、セパレータとして単一のスペースを使用して、廃止された形式の受信をサポートすべきです。"
    },
    {
      "indent": 6,
      "text": "Further, note that the syntax allows for a comment to be added at the end of the date.",
      "ja": "さらに、構文は、日付の末尾に追加するコメントを可能にすることに注意してください。"
    },
    {
      "indent": 0,
      "text": "18.22. Expires",
      "section_title": true,
      "ja": "18.22. 有効期限"
    },
    {
      "indent": 3,
      "text": "The Expires message body header field gives a date and time after which the description or media-stream should be considered stale. The interpretation depends on the method:",
      "ja": "メッセージボディヘッダフィールドが記述またはメディアストリームが古くなったとみなされるべき後の日付と時間を与える有効期限。解釈は方法によって異なります。"
    },
    {
      "indent": 3,
      "text": "DESCRIBE response: The Expires header indicates a date and time after which the presentation description (body) SHOULD be considered stale.",
      "ja": "応答の記述：ザ・ヘッダは、プレゼンテーション記述（本体）が無効と見なされるべき後の日付と時間を示す有効期限。"
    },
    {
      "indent": 3,
      "text": "SETUP response: The Expires header indicates a date and time after which the media stream SHOULD be considered stale.",
      "ja": "SETUP応答：ザはExpiresヘッダは、メディア・ストリームが無効と見なされるべき後の日付と時間を示します。"
    },
    {
      "indent": 3,
      "text": "A stale cache entry should not be returned by a cache (either a proxy cache or a user agent cache) unless it is first validated with the origin server (or with an intermediate cache that has a fresh copy of the message body). See Section 16 for further discussion of the expiration model.",
      "ja": "それが最初のオリジンサーバ（またはメッセージボディの新しいコピーを持っている中間キャッシュを有する）で検証されていない限り、古いキャッシュエントリがキャッシュ（プロキシキャッシュまたはユーザー・エージェント・キャッシュのいずれか）によって返されるべきではありません。期限モデルのさらなる議論については、セクション16を参照してください。"
    },
    {
      "indent": 3,
      "text": "The presence of an Expires field does not imply that the original resource will change or cease to exist at, before, or after that time.",
      "ja": "有効期限フィールドの存在は、元のリソースを変更したりする前に、またはその時間の後、に存在しなくなることを意味するものではありません。"
    },
    {
      "indent": 3,
      "text": "The format is an absolute date and time as defined by RTSP-date. An example of its use is",
      "ja": "RTSP-日付によって定義されるフォーマットは、絶対的な日付と時刻です。その使用の例があります"
    },
    {
      "indent": 5,
      "text": "Expires: Wed, 23 Jan 2013 15:36:52 +0000",
      "ja": "有効期限：2013年15時36分52秒0000水曜日、1月23日を"
    },
    {
      "indent": 3,
      "text": "RTSP 2.0 clients and caches MUST treat other invalid date formats, especially those including the value \"0\", as having occurred in the past (i.e., already expired).",
      "ja": "RTSP 2.0クライアントとキャッシュは（即ち、既に有効期限が切れて）過去に発生したように、値「0」を含む特にその他の無効な日付フォーマットを扱う必要があります。"
    },
    {
      "indent": 3,
      "text": "To mark a response as \"already expired,\" an origin server should use an Expires date that is equal to the Date header value. To mark a response as \"never expires\", an origin server SHOULD use an Expires date approximately one year from the time the response is sent. RTSP 2.0 servers SHOULD NOT send Expires dates that are more than one year in the future.",
      "ja": "応答をマークする「はすでに期限切れ、」オリジンサーバはDateヘッダの値に等しい有効期限の日付を使用する必要があります。 「無期限にする」と回答をマークするには、オリジンサーバは、応答が送信された時点から約1年の日付を期限切れに使用すべきです。送るべきではありませんRTSP 2.0のサーバーは、将来的には一年以上あるの日付を有効期限。"
    },
    {
      "indent": 0,
      "text": "18.23. From",
      "section_title": true,
      "ja": "18.23. から"
    },
    {
      "indent": 3,
      "text": "The From request-header field, if given, SHOULD contain an Internet email address for the human user who controls the requesting user agent. The address SHOULD be machine usable, as defined by \"mailbox\" in [RFC1123].",
      "ja": "リクエストヘッダフィールドから、与えられた場合には、要求元のユーザエージェントを制御し、人間のユーザのためのインターネット電子メールアドレスを含むべきです。 [RFC1123]に「メールボックス」によって定義されるアドレスは、機械使用可能であるべきです。"
    },
    {
      "indent": 3,
      "text": "This header field MAY be used for logging purposes and as a means for identifying the source of invalid or unwanted requests. It SHOULD NOT be used as an insecure form of access protection. The interpretation of this field is that the request is being performed on behalf of the person given, who accepts responsibility for the method performed. In particular, robot agents SHOULD include this header so that the person responsible for running the robot can be contacted if problems occur on the receiving end.",
      "ja": "このヘッダーフィールドは、ロギングのために、無効または不要なリクエストの送信元を識別するための手段として使用することができます。これは、アクセス保護の安全でない形として使用しないでください。このフィールドの解釈は、要求が実行される方法のために責任を負う与えられた人に代わって行われていることです。問題は、受信側で発生した場合、ロボットを動作させるための責任者に連絡することができるように、特に、ロボットエージェントは、このヘッダを含むべきです。"
    },
    {
      "indent": 3,
      "text": "The Internet email address in this field MAY be separate from the Internet host that issued the request. For example, when a request is passed through a proxy, the original issuer's address SHOULD be used.",
      "ja": "この分野でのインターネット電子メールアドレスは、要求を発行したインターネットホストから分離することができます。要求がプロキシを通過する際に、例えば、発行元のアドレスを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "The client SHOULD NOT send the From header field without the user's approval, as it might conflict with the user's privacy interests or their site's security policy. It is strongly recommended that the user be able to disable, enable, and modify the value of this field at any time prior to a request.",
      "ja": "それは、ユーザーのプライバシーの利益や自分のサイトのセキュリティポリシーと競合する可能性がありますように、クライアントは、ユーザーの承認なしFromヘッダーフィールド送るべきではありません。強く、ユーザーが要求する前に、任意の時点で、無効化、有効化、およびこのフィールドの値を変更することができることをお勧めします。"
    },
    {
      "indent": 0,
      "text": "18.24. If-Match",
      "section_title": true,
      "ja": "18.24. もしマッチ"
    },
    {
      "indent": 3,
      "text": "The If-Match request-header field is especially useful for ensuring the integrity of the presentation description, independent of how the presentation description was received. The presentation description can be fetched via means external to RTSP (such as HTTP) or via the DESCRIBE message. In the case of retrieving the presentation description via RTSP, the server implementation is guaranteeing the integrity of the description between the time of the DESCRIBE message and the SETUP message. By including the MTag given in or with the session description in an If-Match header part of the SETUP request, the client ensures that resources set up are matching the description. A SETUP request with the If-Match header for which the MTag validation check fails MUST generate a response using 412 (Precondition Failed).",
      "ja": "もしマッチリクエストヘッダフィールドは、プレゼンテーション記述が受信されたかの独立したプレゼンテーション記述の整合性を確保するために特に有用です。プレゼンテーション記述は、（HTTPなど）、RTSP又はDESCRIBEメッセージを介して外部手段を介して取り出すことができます。 RTSPを介してプレゼンテーション記述を検索する場合には、サーバの実装は、DESCRIBEメッセージの時間とSETUPメッセージとの間の説明の完全性を保証します。またはSETUP要求の場合マッチヘッダ部内のセッション記述で指定されたMTAGを含むことによって、クライアントは、リソースが記述と一致している設定することを保証します。 MTAG検証チェックが失敗するためのIf-Matchヘッダ412（前提条件が失敗した）を使用して応答を生成しなければならないとともにSETUP要求。"
    },
    {
      "indent": 3,
      "text": "This validation check is also very useful if a session has been redirected from one server to another.",
      "ja": "セッションは、あるサーバーから別のサーバーへリダイレクトされている場合は、この検証チェックにも非常に便利です。"
    },
    {
      "indent": 0,
      "text": "18.25. If-Modified-Since",
      "section_title": true,
      "ja": "18.25. 変更 - 開始"
    },
    {
      "indent": 3,
      "text": "The If-Modified-Since request-header field is used with the DESCRIBE and SETUP methods to make them conditional. If the requested variant has not been modified since the time specified in this field, a description will not be returned from the server (DESCRIBE) or a stream will not be set up (SETUP). Instead, a 304 (Not Modified) response MUST be returned without any message body.",
      "ja": "もし修飾-のでリクエストヘッダフィールドは、それらの条件にするために説明し、SETUP方法で使用されています。要求されたバリアントがこのフィールドで指定した時間以降に変更されていない場合は、説明は、サーバから返されることはありません（DESCRIBE）またはストリームが（SETUP）を設定することはありません。代わりに、304（未修正）応答は、任意のメッセージ本体なしで戻されなければなりません。"
    },
    {
      "indent": 3,
      "text": "An example of the field is:",
      "ja": "フィールドの例は次のとおりです。"
    },
    {
      "indent": 5,
      "text": "If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT",
      "ja": "変更 - 開始：土、1994年10月29日午後7時43分31秒GMT"
    },
    {
      "indent": 0,
      "text": "18.26. If-None-Match",
      "section_title": true,
      "ja": "18.26. もし-なしマッチ"
    },
    {
      "indent": 3,
      "text": "This request-header can be used with one or several message body tags to make DESCRIBE requests conditional. A client that has one or more message bodies previously obtained from the resource can verify that none of those entities is current by including a list of their associated message body tags in the If-None-Match header field. The purpose of this feature is to allow efficient updates of cached information with a minimum amount of transaction overhead. As a special case, the value \"*\" matches any current entity of the resource.",
      "ja": "このリクエスト・ヘッダーは、条件付きの要求をDESCRIBEするために1個のまたは複数のメッセージボディタグと共に使用することができます。以前にリソースから取得した1つまたは複数のメッセージボディを持つクライアントは、これらのエンティティのいずれもIf-None-Matchヘッダフィールドにそれらに関連するメッセージ本文のタグのリストを含むことにより、現在ではないことを確認することができます。この機能の目的は最小のトランザクションオーバーヘッドでキャッシュされた情報の効率的な更新を可能にすることです。特別な場合として、値「*」はリソースのいずれかの現在のエンティティと一致します。"
    },
    {
      "indent": 3,
      "text": "If any of the message body tags match the message body tag of the message body that would have been returned in the response to a similar DESCRIBE request (without the If-None-Match header) on that resource, or if \"*\" is given and any current entity exists for that resource, then the server MUST NOT perform the requested method, unless required to do so because the resource's modification date fails to match that supplied in an If-Modified-Since header field in the request. Instead, if the request method was DESCRIBE, the server SHOULD respond with a 304 (Not Modified) response, including the cache-related header fields (particularly MTag) of one of the message bodies that matched. For all other request methods, the server MUST respond with a status of 412 (Precondition Failed).",
      "ja": "メッセージボディタグのいずれかがそのリソース上で（If-None-Matchヘッダなし）同様のDESCRIBE要求に応答して返されたであろうメッセージ本文のメッセージボディタグと一致する場合、「*」が付与されている場合、または現在のどのエンティティが、リソースの変更日は、If-Modifiedの-ので、リクエストのヘッダフィールドに供給されると一致しないので、そうするために必要な場合を除き、そのリソースのために、サーバーは、要求されたメソッドを実行してはならない存在します。リクエストメソッドがDESCRIBEした場合、代わりに、サーバは、一致したメッセージ本文のいずれかのキャッシュに関連するヘッダフィールド（特にMTAG）を含む、304（変更されていません）応答で応答すべきです。他のすべてのリクエストメソッドの場合、サーバは412の状態で応じなければなりません（前提条件に失敗しました）。"
    },
    {
      "indent": 3,
      "text": "See Section 16.1.3 for rules on how to determine if two message body tags match.",
      "ja": "2つのメッセージボディのタグが一致するかどうかを決定する方法に関する規則については、セクション16.1.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "If none of the message body tags match, then the server MAY perform the requested method as if the If-None-Match header field did not exist, but MUST also ignore any If-Modified-Since header field(s) in the request. That is, if no message body tags match, then the server MUST NOT return a 304 (Not Modified) response.",
      "ja": "メッセージ本文のタグが一致のいずれも、サーバは要求されたメソッドを実行しなくてもよい場合If-None-Matchヘッダフィールドが存在しなかっただけでなく、変更した場合-ので要求内のヘッダフィールド（複数可）は、任意の無視しなければならない場合のように。これには、メッセージ本文のタグが一致しない場合、サーバは304（未修正）応答を返してはならない、です。"
    },
    {
      "indent": 3,
      "text": "If the request would, without the If-None-Match header field, result in anything other than a 2xx or 304 status, then the If-None-Match header MUST be ignored. (See Section 16.1.4 for a discussion of server behavior when both If-Modified-Since and If-None-Match appear in the same request.)",
      "ja": "リクエストは、If-None-Matchヘッダフィールドなし、の2xxまたは304ステータス以外の何かにつながる場合は、If-None-Matchヘッダは無視しなければなりません。 （変更した場合は-ので両方となし、マッチした場合、同じ要求に表示されるサーバーの挙動についての議論については、セクション16.1.4を参照してください。）"
    },
    {
      "indent": 3,
      "text": "The result of a request having both an If-None-Match header field and an If-Match header field is unspecified and MUST be considered an illegal request.",
      "ja": "If-None-MatchヘッダフィールドとIf-Matchヘッダフィールドの両方を有する要求の結果は不定であり、不正な要求とみなされなければなりません。"
    },
    {
      "indent": 0,
      "text": "18.27. Last-Modified",
      "section_title": true,
      "ja": "18.27. 最終更新日"
    },
    {
      "indent": 3,
      "text": "The Last-Modified message body header field indicates the date and time at which the origin server believes the presentation description or media stream was last modified. For the DESCRIBE method, the header field indicates the last modification date and time of the description, for the SETUP of the media stream.",
      "ja": "Last-Modifiedのメッセージボディヘッダフィールドは、オリジンサーバがプレゼンテーション記述またはメディアストリームが最後に変更されたと考えていた日付と時刻を示しています。 DESCRIBEメソッドに対して、ヘッダフィールドは、メディア・ストリームのセットアップのため、説明の最終更新日時を示します。"
    },
    {
      "indent": 3,
      "text": "An origin server MUST NOT send a Last-Modified date that is later than the server's time of message origination. In such cases, where the resource's last modification would indicate some time in the future, the server MUST replace that date with the message origination date.",
      "ja": "オリジンサーバは、メッセージ発信のサーバの時刻より後の最終更新日時を送ってはいけません。リソースの最後の変更が将来のある時点を示すことになるような場合では、サーバーは、メッセージの発信日付で、その日付を交換しなければなりません。"
    },
    {
      "indent": 3,
      "text": "An origin server SHOULD obtain the Last-Modified value of the message body as close as possible to the time that it generates the Date value of its response. This allows a recipient to make an accurate assessment of the message body's modification time, especially if the message body changes near the time that the response is generated.",
      "ja": "オリジンサーバは、その応答の日付値を生成し、時間にできるだけ近いメッセージ本体のLast-Modifiedの値を取得する必要があります。これは、受信者は、特に応答が生成される時間に近いメッセージ本体が変更された場合、メッセージ本文の修正時刻の正確な評価を行うことができます。"
    },
    {
      "indent": 3,
      "text": "RTSP servers SHOULD send Last-Modified whenever feasible.",
      "ja": "RTSPサーバは、Last-Modifiedのときは常に可能を送るべきです。"
    },
    {
      "indent": 0,
      "text": "18.28. Location",
      "section_title": true,
      "ja": "18.28. ロケーション"
    },
    {
      "indent": 3,
      "text": "The Location response-header field is used to redirect the recipient to a location other than the Request-URI for completion of the request or identification of a new resource. For 3rr responses, the location SHOULD indicate the server's preferred URI for automatic redirection to the resource. The field-value consists of a single absolute URI.",
      "ja": "ロケーションレスポンスヘッダフィールドは、新しいリソースの要求または識別を完了するためのRequest-URI以外の場所に受信者をリダイレクトするために使用されます。 3RR応答では、場所は、リソースへの自動リダイレクトするために、サーバーの優先URIを示すべきです。フィールド値は、単一の絶対URIから成ります。"
    },
    {
      "indent": 3,
      "text": "Note: The Content-Location header field (Section 18.18) differs from Location in that the Content-Location identifies the original location of the message body enclosed in the request. Therefore, it is possible for a response to contain header fields for both Location and Content-Location. Also, see Section 16.2 for cache requirements of some methods.",
      "ja": "注：コンテンツロケーション要求で囲まれたメッセージ本体の元の位置を識別するのContent-Locationヘッダフィールド（セクション18.18）は、ロケーションとは異なります。従って、場所とコンテンツの場所の両方のためのヘッダフィールドを含む応答することが可能です。また、いくつかのメソッドのキャッシュ要件については、セクション16.2を参照してください。"
    },
    {
      "indent": 0,
      "text": "18.29. Media-Properties",
      "section_title": true,
      "ja": "18.29. メディア・プロパティ"
    },
    {
      "indent": 3,
      "text": "This general-header is used in SETUP responses or PLAY_NOTIFY requests to indicate the media's properties that currently are applicable to the RTSP session. PLAY_NOTIFY MAY be used to modify these properties at any point. However, the client SHOULD have received the update prior to any action related to the new media properties taking effect. For aggregated sessions, the Media-Properties header will be returned in each SETUP response. The header received in the latest response is the one that applies on the whole session from this point until any future update. The header MAY be included without value in GET_PARAMETER requests to the server with a Session header included to query the current Media-Properties for the session. The responder MUST include the current session's media properties.",
      "ja": "この一般ヘッダは、SETUP応答、または現在RTSPセッションに適用可能なメディアの性質を示すためにPLAY_NOTIFY要求で使用されています。 PLAY_NOTIFYは、任意の時点で、これらのプロパティを変更するために使用されるかもしれません。ただし、クライアントは前効果を取って新しいメディアの特性に関連する任意のアクションへの更新を受け取っているはずです。アグリゲートされたセッションのために、メディアプロパティヘッダは、各SETUP応答で返されます。最新の応答で受信したヘッダは、この点から任意の将来のアップデートまで、セッション全体に適用されるものです。ヘッダは、セッションのために現在のメディア・プロパティを照会するために含まSessionヘッダーでサーバにGET_PARAMETER要求に値なしで含まれるかもしれません。レスポンダは、現在のセッションのメディアの特性を含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "The media properties expressed by this header are the ones applicable to all media in the RTSP session. For aggregated sessions, the header expressed the combined media-properties. As a result, aggregation of media MAY result in a change of the media properties and, thus, the content of the Media-Properties header contained in subsequent SETUP responses.",
      "ja": "このヘッダで表さメディアプロパティは、RTSPセッション内のすべてのメディアに適用可能なものです。アグリゲートされたセッションのために、ヘッダは、複合メディア・プロパティを発現しました。結果として、メディアの集合は、このように、メディアプロパティヘッダの内容は、後続SETUP応答に含まれるメディアの特性との変化をもたらすことができます。"
    },
    {
      "indent": 3,
      "text": "The header contains a list of property values that are applicable to the currently setup media or aggregate of media as indicated by the RTSP URI in the request. No ordering is enforced within the header. Property values should be placed into a single group that handles a particular orthogonal property. Values or groups that express multiple properties SHOULD NOT be used. The list of properties that can be expressed MAY be extended at any time. Unknown property values MUST be ignored.",
      "ja": "ヘッダは、要求にRTSP URIによって示されるように、現在のセットアップメディアまたはメディアの集合体に適用されるプロパティ値のリストを含みます。何順序は、ヘッダー内強制されません。プロパティ値は、特定の直交性を処理する1つのグループに配置されるべきです。複数のプロパティを表現する値またはグループを使用しないでください。表現することができるプロパティのリストは、いつでも延長することができます。不明なプロパティ値を無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "This specification defines the following four groups and their property values:",
      "ja": "この仕様は、次の4つのグループとそのプロパティの値を定義します。"
    },
    {
      "indent": 3,
      "text": "Random Access:",
      "ja": "ランダムアクセス："
    },
    {
      "indent": 6,
      "text": "Random-Access: Indicates that random access is possible. May optionally include a floating-point value in seconds indicating the longest duration between any two random access points in the media.",
      "ja": "ランダムアクセス：ランダムアクセスが可能であることを示します。必要に応じてメディア内の任意の2つのランダムアクセスポイント間の最長時間を示す秒の浮動小数点値を含むことができます。"
    },
    {
      "indent": 6,
      "text": "Beginning-Only: Seeking is limited to the beginning only.",
      "ja": "のみ-始まり：探しているが、始まったばかりに制限されています。"
    },
    {
      "indent": 6,
      "text": "No-Seeking: No seeking is possible.",
      "ja": "無探している：いいえシークは可能ではありません。"
    },
    {
      "indent": 3,
      "text": "Content Modifications:",
      "ja": "コンテンツの変更："
    },
    {
      "indent": 6,
      "text": "Immutable: The content will not be changed during the lifetime of the RTSP session.",
      "ja": "不変：コンテンツは、RTSPセッションの存続期間中に変更されることはありません。"
    },
    {
      "indent": 6,
      "text": "Dynamic: The content may be changed based on external methods or triggers.",
      "ja": "ダイナミック：コンテンツは、外部メソッドまたはトリガに基づいて変更することができます。"
    },
    {
      "indent": 6,
      "text": "Time-Progressing: The media accessible progresses as wallclock time progresses.",
      "ja": "時間が進むと-：壁時計の時間が進むにつれて、メディアアクセスが進行します。"
    },
    {
      "indent": 3,
      "text": "Retention:",
      "ja": "保持："
    },
    {
      "indent": 6,
      "text": "Unlimited: Content will be retained for the duration of the lifetime of the RTSP session.",
      "ja": "アンリミテッド：コンテンツはRTSPセッションの存続期間の期間保持されます。"
    },
    {
      "indent": 6,
      "text": "Time-Limited: Content will be retained at least until the specified wallclock time. The time must be provided in the absolute time format specified in Section 4.4.3.",
      "ja": "期間限定：コンテンツは、少なくとも指定された壁時計の時刻まで保持されます。時間は、4.4.3項で指定された絶対時間形式で提供されなければなりません。"
    },
    {
      "indent": 6,
      "text": "Time-Duration: Each individual media unit is retained for at least the specified Time-Duration. This definition allows for retaining data with a time-based sliding window. The time duration is expressed as floating-point number in seconds. The value 0.0 is a valid as this indicates that no data is retained in a time-progressing session.",
      "ja": "時間所要時間：個々のメディアユニットは、少なくとも指定された時間期間のために保持されます。この定義は、時間ベースのスライディングウィンドウでデータを保持することができます。持続時間は秒単位での浮動小数点数として表現されます。これは、データが時間的に進行セッションに保持されていないことを示すように値0.0が有効です。"
    },
    {
      "indent": 3,
      "text": "Supported Scale:",
      "ja": "サポートされているスケール："
    },
    {
      "indent": 6,
      "text": "Scales: A quoted comma-separated list of one or more decimal values or ranges of scale values supported by the content in arbitrary order. A range has a start and stop value separated by a colon. A range indicates that the content supports a fine-grained selection of scale values. Fine-graining allows for steps at least as small as one tenth of a scale value. Content is considered to support fine-grained selection when the server in response to a given scale value can produce content with an actual scale that is less than one tenth of scale unit, i.e., 0.1, from the requested value. Negative values are supported. The value 0 has no meaning and MUST NOT be used.",
      "ja": "スケール：任意の順序でコンテンツによってサポートされる1つの以上の10進値またはスケール値の範囲の引用符で囲まれたカンマ区切りのリスト。範囲は、コロンで区切られた開始及び停止値を有します。範囲は、コンテンツがスケール値のきめ細かい選択をサポートしていることを示しています。微細粗面化は、スケール値の10分の1と少なくとも同じくらい小さなステップを可能にします。コンテンツは、所定のスケール値に応じて、サーバは要求された値から、スケール部、すなわち、0.1の10分の1未満であり、実際のスケールでコンテンツを生成することができる場合にきめ細かい選択をサポートするために考えられています。負の値はサポートされています。値0は意味を持ちませんし、使用してはいけません。"
    },
    {
      "indent": 3,
      "text": "Examples of this header for on-demand content and a live stream without recording are:",
      "ja": "オンデマンドコンテンツおよび記録せずにライブストリームのためのこのヘッダの例であります："
    },
    {
      "indent": 3,
      "text": "On-demand: Media-Properties: Random-Access=2.5, Unlimited, Immutable, Scales=\"-20, -10, -4, 0.5:1.5, 4, 8, 10, 15, 20\"",
      "ja": "オンデマンド：メディアプロパティ：ランダムアクセス= 2.5、無制限、不変、スケール= \" -  20、-10、-4、0.5：1.5、4、8、10、15、20\""
    },
    {
      "indent": 3,
      "text": "Live stream without recording/timeshifting: Media-Properties: No-Seeking, Time-Progressing, Time-Duration=0.0",
      "ja": "メディア・プロパティ：：録画/タイムシフトせずにライブストリーム無探して、時間進み、タイム期間= 0.0"
    },
    {
      "indent": 0,
      "text": "18.30. Media-Range",
      "section_title": true,
      "ja": "18.30. メディアレンジ"
    },
    {
      "indent": 3,
      "text": "The Media-Range general-header is used to give the range of the media at the time of sending the RTSP message. This header MUST be included in the SETUP response, PLAY and PAUSE responses for media that are time-progressing, PLAY and PAUSE responses after any change for media that are Dynamic, and in PLAY_NOTIFY requests that are sent due to Media-Property-Update. A Media-Range header without any range specifications MAY be included in GET_PARAMETER requests to the server to request the current range. In this case, the server MUST include the current range at the time of sending the response.",
      "ja": "メディアレンジ一般的なヘッダはRTSPメッセージを送信する時にメディアの範囲を与えるために使用されます。このヘッダは、SETUP応答、PLAYに含まれ、時間が進行しているメディアの応答を一時停止、再生、およびダイナミック、そしてによるメディア・プロパティ・アップデートに送信されPLAY_NOTIFY要求であるメディアの変更後の応答を一時停止しなければなりません。任意の範囲の指定のないメディア-Rangeヘッダは、現在の範囲を要求するために、サーバーへのGET_PARAMETER要求に含まれるかもしれません。この場合、サーバは、応答を送信する時の電流範囲を含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "The header MUST include range specifications for all time formats supported for the media, as indicated in Accept-Ranges header (Section 18.5) when setting up the media. The server MAY include more than one range specification of any given time format to indicate media that has non-continuous range. The range specifications SHALL be ordered with the range with the lowest value or earliest start time first, followed by ranges with increasingly higher values or later start time.",
      "ja": "受け入れ-範囲で示されたヘッダ（セクション18.5）のようにメディアを設定するときヘッダは、メディアのサポートされるすべての時間形式の範囲仕様を含まなければなりません。サーバは、非連続的な範囲を有する媒体を示すために、任意の所与の時間形式の複数の範囲指定を含むかもしれません。範囲指定が最小値又は第一の最も早い開始時間を有する範囲で順序付けされるべきであり、ますますより高い値を有する範囲に続く以降の開始時刻。"
    },
    {
      "indent": 3,
      "text": "For media that has the time-progressing property, the Media-Range header values will only be valid for the particular point in time when it was issued. As the wallclock progresses, so will the media range. However, it shall be assumed that media time progresses in direct relationship to wallclock time (with the exception of clock skew) so that a reasonably accurate estimation of the media range can be calculated.",
      "ja": "時間進ん性質を持っているメディアの場合、メディア-Rangeヘッダの値は、それが発行された特定の時点について有効となります。壁時計が進行すると、そのメディアの範囲はなります。しかし、メディア時間は、メディアの範囲の合理的に正確な推定を計算することができるように（クロック・スキューを除く）時間をウォールクロックするために直接関係で進行することを想定しなければなりません。"
    },
    {
      "indent": 0,
      "text": "18.31. MTag",
      "section_title": true,
      "ja": "午前18時31分。 MTAG"
    },
    {
      "indent": 3,
      "text": "The MTag response-header MAY be included in DESCRIBE, GET_PARAMETER, or SETUP responses. The message body tags (Section 4.6) returned in a DESCRIBE response and the one in SETUP refer to the presentation, i.e., both the returned session description and the media stream. This allows for verification that one has the right session description to a media resource at the time of the SETUP request. However, it has the disadvantage that a change in any of the parts results in invalidation of all the parts.",
      "ja": "MTAGレスポンスヘッダはで記述GET_PARAMETER、またはSETUP応答に含まれるかもしれません。メッセージ本文タグ（セクション4.6）DESCRIBE応答して返され、SETUP内の1つは、プレゼンテーション、即ち、両方の返されたセッション記述とメディア・ストリームを指します。これは、1つは、SETUP要求時のメディアリソースに右のセッション記述を持っていることを確認することができます。しかし、それは部品のいずれかの変化はすべての部分の無効化につながるという欠点があります。"
    },
    {
      "indent": 3,
      "text": "If the MTag is provided both inside the message body, e.g., within the \"a=mtag\" attribute in SDP, and in the response message, then both tags MUST be identical. It is RECOMMENDED that the MTag be primarily given in the RTSP response message, to ensure that caches can use the MTag without requiring content inspection. However, for session descriptions that are distributed outside of RTSP, for example, using HTTP, etc., it will be necessary to include the message body tag in the session description as specified in Appendix D.1.9.",
      "ja": "MTAGは、メッセージ本体の内部には、例えば、SDPの「A = MTAG」属性内、および応答メッセージの両方に設けられている場合、両方のタグが同一でなければなりません。 MTAGは主キャッシュはコンテンツ検査を必要とすることなく、MTAGを使用できることを保証するために、RTSP応答メッセージに与えられることが推奨されます。しかし、等、HTTPを使用して、例えば、RTSPの外側に分布しているセッション記述のためには、付録D.1.9で指定されたセッション記述にメッセージボディタグを含むことが必要であろう。"
    },
    {
      "indent": 3,
      "text": "SETUP and DESCRIBE requests can be made conditional upon the MTag using the headers If-Match (Section 18.24) and If-None-Match (Section 18.26).",
      "ja": "（セクション18.24）マッチした場合とした場合 - なし - マッチ（項18.26）SETUPと要求を記述するには、ヘッダーを使用してMTAGを条件とすることができます。"
    },
    {
      "indent": 0,
      "text": "18.32. Notify-Reason",
      "section_title": true,
      "ja": "18.32. 通知-理由"
    },
    {
      "indent": 3,
      "text": "The Notify-Reason response-header is solely used in the PLAY_NOTIFY method. It indicates the reason why the server has sent the asynchronous PLAY_NOTIFY request (see Section 13.5).",
      "ja": "通知-理由レスポンスヘッダは、単にPLAY_NOTIFY方法に使用されます。これは、サーバーが非同期PLAY_NOTIFY要求（13.5項を参照）を送信した理由を示します。"
    },
    {
      "indent": 0,
      "text": "18.33. Pipelined-Requests",
      "section_title": true,
      "ja": "18.33. パイプライン化、要求"
    },
    {
      "indent": 3,
      "text": "The Pipelined-Requests general-header is used to indicate that a request is to be executed in the context created by a previous request(s). The primary usage of this header is to allow pipelining of SETUP requests so that any additional SETUP request after the first one does not need to wait for the session ID to be sent back to the requesting agent. The header contains a unique identifier that is scoped by the persistent connection used to send the requests.",
      "ja": "パイプライン・リクエスト一般ヘッダは、要求が前の要求（単数または複数）によって作成されたコンテキスト内で実行されることを示すために使用されます。このヘッダの主な用途は、最初の1の後に追加のSETUP要求は要求エージェントに送り返されるセッションIDを待つ必要がないように、SETUP要求のパイプライン化を可能にすることです。ヘッダは、要求を送信するために使用される永続的な接続によりスコープいる固有の識別子を含みます。"
    },
    {
      "indent": 3,
      "text": "Upon receiving a request with the Pipelined-Requests, the responding agent MUST look up if there exists a binding between this Pipelined-Requests identifier for the current persistent connection and an RTSP session ID. If the binding exists, then the received request is processed the same way as if it contained the Session header with the found session ID. If there does not exist a mapping and no Session header is included in the request, the responding agent MUST create a binding upon the successful completion of a session creating request, i.e., SETUP. A binding MUST NOT be created, if the request failed to create an RTSP session. In case the request contains both a Session header and the Pipelined-Requests header, the Pipelined-Requests header MUST be ignored.",
      "ja": "現在の固定接続及びRTSPセッションIDは、このパイプライン・リクエスト識別子との間の結合が存在する場合はパイプライン・リクエストで要求を受信すると、応答エージェントは、ルックアップしなければなりません。結合が存在する場合、受信した要求は、それが見つかったセッションIDとセッションヘッダが含まれている場合と同じように処理されます。そこにマッピングが存在せず、セッションヘッダが要求に含まれていない場合、応答側エージェントは、セッション作成要求、即ち、SETUPが正常に完了するとバインディングを作成する必要があります。要求はRTSPセッションの作成に失敗した場合バインディングは、作成してはなりません。要求は、セッション・ヘッダ及びパイプライン・リクエストヘッダの両方を含む場合には、パイプライン・リクエストヘッダは無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Note: Based on the above definition, at least the first request containing a new unique Pipelined-Requests header will be required to be a SETUP request (unless the protocol is extended with new methods of creating a session). After that first one, additional SETUP requests or requests of any type using the RTSP session context may include the Pipelined-Requests header.",
      "ja": "注：上記の定義に基づいて、新しいユニークなパイプライン・リクエストヘッダを含む少なくとも第一の要求は、（プロトコルがセッションを作成するための新たな方法で拡張されていない限り）SETUP要求であることが要求されるであろう。その最初のもの後、RTSPセッションコンテキストを使用して追加のSETUP要求、又は任意のタイプの要求はパイプライン・リクエストヘッダを含むことができます。"
    },
    {
      "indent": 3,
      "text": "When responding to any request that contained the Pipelined-Requests header, the server MUST also include the Session header when a binding to a session context exists. An RTSP agent that knows the session identifier SHOULD NOT use the Pipelined-Requests header in any request and only use the Session header. This as the Session identifier is persistent across transport contexts, like TCP connections, which the Pipelined-Requests identifier is not.",
      "ja": "パイプライン・リクエスト・ヘッダーを含まれている任意の要求に応答するときにコンテキストが存在するセッションに結合する場合、サーバは、セッションヘッダを含まなければなりません。セッション識別子を知っているRTSPエージェントは、すべてのリクエストにパイプライン・リクエストヘッダーを使用してのみSessionヘッダーを使用しないでください。セッション識別子としてこれは、パイプライン・リクエスト識別子がされていない、TCPコネクションのように、トランスポート・コンテキスト間で永続的です。"
    },
    {
      "indent": 3,
      "text": "The RTSP agent sending the request with a Pipelined-Requests header has the responsibility for using a unique and previously unused identifier within the transport context. Currently, only a TCP connection is defined as such a transport context. A server MUST delete the Pipelined-Requests identifier and its binding to a session upon the termination of that session. Despite the previous mandate, RTSP agents are RECOMMENDED not to reuse identifiers to allow for better error handling and logging.",
      "ja": "パイプライン・リクエストヘッダで要求を送信するRTSPエージェントは、トランスポート・コンテキスト内でユニークで以前に使用されていない識別子を使用する責任を有します。現在、唯一のTCP接続は、このようなトランスポート・コンテキストとして定義されます。サーバーは、パイプライン・リクエスト識別子を削除しなければなりませんし、そのは、そのセッションの終了時にセッションに結合します。以前の任務にもかかわらず、RTSPエージェントは、より優れたエラー処理とロギングを可能にするための識別子を再利用しないことをお勧めされています。"
    },
    {
      "indent": 3,
      "text": "RTSP Proxies may need to translate Pipelined-Requests identifier values from incoming requests to outgoing to allow for aggregation of requests onto a persistent connection.",
      "ja": "RTSPプロキシは、永続的な接続への要求の集約を可能にするために、発信への着信要求からパイプライン・リクエスト識別子の値を変換する必要があるかもしれません。"
    },
    {
      "indent": 0,
      "text": "18.34. Proxy-Authenticate",
      "section_title": true,
      "ja": "18.34. プロキシ認証"
    },
    {
      "indent": 3,
      "text": "The Proxy-Authenticate response-header field MUST be included as part of a 407 (Proxy Authentication Required) response. The field-value consists of a challenge that indicates the authentication scheme and parameters applicable to the proxy for this Request-URI. The definition of the header is in [RFC7235], and any applicable HTTP authentication schemes appear in other RFCs, such as Digest [RFC7616] and Basic [RFC7617].",
      "ja": "プロキシ認証レスポンス・ヘッダー・フィールドは、407（プロキシ認証が必要）応答の一部として含まれなければなりません。フィールド値はこのRequest-URIに対してプロキシに適用できる認証スキームとパラメータを示し挑戦で構成されています。ヘッダの定義は、[RFC7235]であり、任意の適用可能なHTTP認証方式は、ダイジェスト[RFC7616]と基本[RFC7617]などの他のRFCに現れます。"
    },
    {
      "indent": 3,
      "text": "The HTTP access authentication process is described in [RFC7235]. This header MUST only be used in response messages related to client-to-server requests.",
      "ja": "HTTPアクセス認証プロセスは、[RFC7235]に記載されています。このヘッダーは、クライアントからサーバーへの要求に関連する応答メッセージに使用しなければなりません。"
    },
    {
      "indent": 0,
      "text": "18.35. Proxy-Authentication-Info",
      "section_title": true,
      "ja": "18.35. プロキシ認証 - インフォメーション"
    },
    {
      "indent": 3,
      "text": "The Proxy-Authentication-Info response-header is used by the proxy to communicate some information regarding the successful authentication to the proxy in the message response in some authentication schemes, such as the Digest scheme [RFC7616]. The definition of the header is in [RFC7615], and any applicable HTTP authentication schemes appear in other RFCs. This header MUST only be used in response messages related to client-to-server requests. This header has hop-by-hop scope.",
      "ja": "プロキシ認証-INFO応答ヘッダは、ダイジェストスキーム[RFC7616]などのいくつかの認証方式でメッセージ応答内のプロキシに認証成功に関するいくつかの情報を通信するためにプロキシによって使用されます。ヘッダの定義は、[RFC7615]であり、任意の適用可能なHTTP認証方式は、他のRFCに現れます。このヘッダーは、クライアントからサーバーへの要求に関連する応答メッセージに使用しなければなりません。このヘッダは、ホップバイホップ範囲を有しています。"
    },
    {
      "indent": 0,
      "text": "18.36. Proxy-Authorization",
      "section_title": true,
      "ja": "18.36. プロキシ認証"
    },
    {
      "indent": 3,
      "text": "The Proxy-Authorization request-header field allows the client to identify itself (or its user) to a proxy that requires authentication. The Proxy-Authorization field-value consists of credentials containing the authentication information of the user agent for the proxy or realm of the resource being requested. The definition of the header is in [RFC7235], and any applicable HTTP authentication schemes appear in other RFCs, such as Digest [RFC7616] and Basic [RFC7617].",
      "ja": "プロキシ認証リクエストヘッダフィールドは、クライアントが認証を必要とするプロキシにそれ自体（又はそのユーザ）を識別することを可能にします。プロキシ認証フィールド値は、リソースのプロキシまたはレルムのユーザエージェントの認証情報を含む認証情報が要求されるから成ります。ヘッダの定義は、[RFC7235]であり、任意の適用可能なHTTP認証方式は、ダイジェスト[RFC7616]と基本[RFC7617]などの他のRFCに現れます。"
    },
    {
      "indent": 3,
      "text": "The HTTP access authentication process is described in [RFC7235]. Unlike Authorization, the Proxy-Authorization header field applies only to the next-hop proxy. This header MUST only be used in client-to-server requests.",
      "ja": "HTTPアクセス認証プロセスは、[RFC7235]に記載されています。許可とは異なり、Proxy-Authorizationヘッダフィールドは、ネクストホッププロキシに適用されます。このヘッダーは、クライアントからサーバーへのリクエストで使用されなければなりません。"
    },
    {
      "indent": 0,
      "text": "18.37. Proxy-Require",
      "section_title": true,
      "ja": "18.37. プロキシ要求"
    },
    {
      "indent": 3,
      "text": "The Proxy-Require request-header field is used to indicate proxy-sensitive features that MUST be supported by the proxy. Any Proxy-Require header features that are not supported by the proxy MUST be negatively acknowledged by the proxy to the client using the Unsupported header. The proxy MUST use the 551 (Option Not Supported) status code in the response. Any feature tag included in the Proxy-Require does not apply to the endpoint (server or client). To ensure that a feature is supported by both proxies and servers, the tag needs to be included in also a Require header.",
      "ja": "プロキシ要求するリクエストヘッダフィールドは、プロキシによってサポートされなければならないプロキシ感受性の特徴を示すために使用されます。プロキシによってサポートされていないすべてのプロキシ-Requireヘッダーの機能がサポートされていない負のヘッダを使用して、クライアントへのプロキシによって承認されなければなりません。プロキシが応答して551（オプションサポートされていない）状態コードを使用しなければなりません。含まれない機能タグプロキシ要求するエンドポイント（サーバーまたはクライアント）には適用されません。機能がプロキシとサーバの両方でサポートされていることを確実にするために、タグは、要求ヘッダに含まれる必要があります。"
    },
    {
      "indent": 3,
      "text": "See Section 18.43 for more details on the mechanics of this message and a usage example. See discussion in the proxies section (Section 15.1) about when to consider that a feature requires proxy support.",
      "ja": "このメッセージの仕組みの詳細については、セクション18.43と使用例を参照してください。機能は、プロキシのサポートが必要であることを考慮するときについて、プロキシ区間（15.1）での議論を参照してください。"
    },
    {
      "indent": 3,
      "text": "Example of use:",
      "ja": "使用例："
    },
    {
      "indent": 6,
      "text": "Proxy-Require: play.basic",
      "ja": "プロキシが必要：play.basicを"
    },
    {
      "indent": 0,
      "text": "18.38. Proxy-Supported",
      "section_title": true,
      "ja": "18.38. プロキシサポート"
    },
    {
      "indent": 3,
      "text": "The Proxy-Supported general-header field enumerates all the extensions supported by the proxy using feature tags. The header carries the intersection of extensions supported by the forwarding proxies. The Proxy-Supported header MAY be included in any request by a proxy. It MUST be added by any proxy if the Supported header is present in a request. When present in a request, the receiver MUST copy the received Proxy-Supported header in the response.",
      "ja": "プロキシサポートされている一般ヘッダフィールドは、フィーチャータグを使用してプロキシでサポートされているすべての拡張機能を列挙します。ヘッダは、転送プロキシによってサポートされる拡張の交差点を運びます。プロキシSupportedヘッダは、プロキシによって、任意の要求に含まれるかもしれません。サポートされているヘッダーが要求に存在する場合、それは、任意のプロキシによって追加されなければなりません。存在する場合、要求に、受信機は応答して受信されたProxy-Supportedヘッダをコピーする必要があります。"
    },
    {
      "indent": 3,
      "text": "The Proxy-Supported header field contains a list of feature tags applicable to proxies, as described in Section 4.5. The list is the intersection of all feature tags understood by the proxies. To achieve an intersection, the proxy adding the Proxy-Supported header includes all proxy feature tags it understands. Any proxy receiving a request with the header MUST check the list and remove any feature tag(s) it does not support. A Proxy-Supported header present in the response MUST NOT be modified by the proxies. These feature tags are the ones the proxy chains support in general and are not specific to the request resource.",
      "ja": "4.5節で説明したように、プロキシ-Supportedヘッダーフィールドは、プロキシに適用される機能タグのリストが含まれています。リストには、プロキシが理解すべての機能タグの交点です。交差点を達成するために、プロキシサポートされているヘッダを追加するプロキシは、それが理解し、すべてのプロキシ機能タグが含まれています。ヘッダで要求を受信する任意のプロキシリストをチェックし、それがサポートしていない任意の特徴タグ（複数可）を削除する必要があります。応答中に存在するプロキシSupportedヘッダは、プロキシによって改変されてはいけません。これらの機能タグは、プロキシチェーンは、一般的にサポートし、要求リソースに固有ではないものです。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 5,
      "text": "C->P1: OPTIONS rtsp://example.com/ RTSP/2.0 Supported: foo, bar, blech User-Agent: PhonyClient/1.2",
      "ja": "C-> P1：OPTIONSのRTSP：RTSP / 2.0 //example.com/サポート：FOO、バー、BLECHユーザーエージェント：PhonyClient / 1.2"
    },
    {
      "indent": 4,
      "text": "P1->P2: OPTIONS rtsp://example.com/ RTSP/2.0 Supported: foo, bar, blech Proxy-Supported: proxy-foo, proxy-bar, proxy-blech Via: 2.0 pro.example.com",
      "ja": "P1-> P2：OPTIONSのRTSP：RTSP / 2.0 //example.com/サポート：FOO、バー、BLECHプロキシ・サポート：プロキシFOO、プロキシ・バー、プロキシ経由BLECH：2.0 pro.example.com"
    },
    {
      "indent": 4,
      "text": "P2->S: OPTIONS rtsp://example.com/ RTSP/2.0 Supported: foo, bar, blech Proxy-Supported: proxy-foo, proxy-blech Via: 2.0 pro.example.com, 2.0 prox2.example.com",
      "ja": "P2-> S：OPTIONSのRTSP：RTSP / 2.0 //example.com/サポート：FOO、バー、BLECHプロキシ・サポート：プロキシFOO、プロキシ経由BLECH：2.0 pro.example.com、2.0 prox2.example.com"
    },
    {
      "indent": 5,
      "text": "S->C: RTSP/2.0 200 OK Supported: foo, bar, baz Proxy-Supported: proxy-foo, proxy-blech Public: OPTIONS, SETUP, PLAY, PAUSE, TEARDOWN Via: 2.0 pro.example.com, 2.0 prox2.example.com",
      "ja": "S-> C：サポートされているRTSP / 2.0 200 OK：FOO、バー、バズプロキシサポート：プロキシFOO、プロキシBLECH公開：OPTIONS、SETUP、PLAY、PAUSE、TEARDOWN経由：2.0 pro.example.com、2.0 prox2 .example.comと"
    },
    {
      "indent": 0,
      "text": "18.39. Public",
      "section_title": true,
      "ja": "18.39. 公"
    },
    {
      "indent": 3,
      "text": "The Public response-header field lists the set of methods supported by the response sender. This header applies to the general capabilities of the sender, and its only purpose is to indicate the sender's capabilities to the recipient. The methods listed may or may not be applicable to the Request-URI; the Allow header field (Section 18.6) MAY be used to indicate methods allowed for a particular URI.",
      "ja": "公共レスポンスヘッダフィールドは、レスポンスの送信者がサポートするメソッドのセットを示しています。このヘッダは、送信者の一般的な機能に適用され、その唯一の目的は、受信者に送信者の能力を示すためです。列挙された方法は、またはのRequest-URIに適用可能であってもなくてもよいです。許可ヘッダフィールド（セクション18.6）は、特定のURIに許可する方法を示すために使用され得ます。"
    },
    {
      "indent": 3,
      "text": "Example of use:",
      "ja": "使用例："
    },
    {
      "indent": 6,
      "text": "Public: OPTIONS, SETUP, PLAY, PAUSE, TEARDOWN",
      "ja": "公共：OPTIONS、SETUP、PLAY、PAUSE、TEARDOWN"
    },
    {
      "indent": 3,
      "text": "In the event that there are proxies between the sender and the recipient of a response, each intervening proxy MUST modify the Public header field to remove any methods that are not supported via that proxy. The resulting Public header field will contain an intersection of the sender's methods and the methods allowed through by the intervening proxies.",
      "ja": "送信者と応答の受信者との間にプロキシが存在した場合に、各介在プロキシは、プロキシを介してサポートされていないメソッドを除去するために、公開ヘッダフィールドを変更する必要があります。結果の公開ヘッダフィールドは、送信者のメソッドの交差点および介在プロキシによって通過を許可する方法が含まれます。"
    },
    {
      "indent": 6,
      "text": "In general, proxies should allow all methods to transparently pass through from the sending RTSP agent to the receiving RTSP agent, but there may be cases where this is not desirable for a given proxy. Modification of the Public response-header field by the intervening proxies ensures that the request sender gets an accurate response indicating the methods that can be used on the target agent via the proxy chain.",
      "ja": "一般に、プロキシは、すべてのメソッドが透過受信RTSPエージェントに送信RTSPエージェントから通過できるようにする必要があり、これは指定されたプロキシのために望ましくない場合があります。介在するプロキシによって公開レスポンス・ヘッダー・フィールドの変更はリクエスト送信者がプロキシチェーンを介して標的剤に使用することができる方法を示す正確な応答を得ることを確実にします。"
    },
    {
      "indent": 0,
      "text": "18.40. Range",
      "section_title": true,
      "ja": "18.40. 範囲"
    },
    {
      "indent": 3,
      "text": "The Range general-header specifies a time range in PLAY (Section 13.4), PAUSE (Section 13.6), SETUP (Section 13.3), and PLAY_NOTIFY (Section 13.5) requests and responses. It MAY be included in GET_PARAMETER requests from the client to the server with only a Range format and no value to request the current media position, whether the session is in Play or Ready state in the included format. The server SHALL, if supporting the range format, respond with the current playing point or pause point as the start of the range. If an explicit stop point was used in the previous PLAY request, then that value shall be included as stop point. Note that if the server is currently under any type of media playback manipulation affecting the interpretation of the Range header, like scale value other than 1, that fact is also required to be included in any GET_PARAMETER response by including the Scale header to provide complete information.",
      "ja": "レンジ一般的なヘッダは、PLAY（セクション13.4）、PAUSE（セクション13.6）、SETUP（セクション13.3）での時間範囲を指定し、PLAY_NOTIFY（セクション13.5）要求および応答。それが唯一の範囲形式とセッションが含ま形式で再生したり、準備完了状態にあるかどうかを現在のメディアの位置を、要求する値を持たないクライアントからサーバへのGET_PARAMETER要求に含まれるかもしれません。サーバは、範囲の形式をサポートしている場合は、範囲の開始として現在の再生ポイントまたは一時停止ポイントで応答します。明示的な停止点は、前PLAY要求で使用された場合、その値は、停止点として含まれるものとします。サーバがRangeヘッダの解釈に影響を与えるメディア再生操作の任意のタイプの中である場合は、1以外のスケール値と同様に、その事実もスケールヘッダは、完全な情報を提供するために含めることによって任意GET_PARAMETER応答に含まれることが必要であることに注意してください。"
    },
    {
      "indent": 3,
      "text": "The range can be specified in a number of units. This specification defines smpte (Section 4.4.1), npt (Section 4.4.2), and clock (Section 4.4.3) range units. While octet ranges (Byte Ranges) (see Section 2.1 of [RFC7233]) and other extended units MAY be used, their behavior is unspecified since they are not normally meaningful in RTSP. Servers supporting the Range header MUST understand the NPT range format and SHOULD understand the SMPTE range format. If the Range header is sent in a time format that is not understood, the recipient SHOULD return 456 (Header Field Not Valid for Resource) and include an Accept-Ranges header indicating the supported time formats for the given resource.",
      "ja": "範囲は、ユニットの数で指定することができます。この仕様は、SMPTE（4.4.1項）、NPT（セクション4.4.2）、およびクロック（4.4.3項）単位の範囲を定義します。オクテット範囲（バイト範囲）（[RFC7233]のセクション2.1を参照）、他の拡張ユニットを使用することができるが、彼らはRTSPで正常に無意味であるので、その動作は不定です。 Rangeヘッダをサポートするサーバは、NPT範囲形式を理解しなければならないとSMPTE範囲形式を理解すべきです。 Rangeヘッダが理解されていない時間形式で送信された場合、受信者は、（リソースに対して有効でないヘッダーフィールド）456を返し、指定されたリソースのサポート時間フォーマットを示す受け入れ-範囲をヘッダを含むべきです。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 5,
      "text": "Range: clock=19960213T143205Z-",
      "ja": "範囲：クロック= 19960213T143205Z-"
    },
    {
      "indent": 3,
      "text": "The Range header contains a range of one single range format. A range is a half-open interval with a start and an end point, including the start point but excluding the end point. A range may either be fully specified with explicit values for start point and end point or have either the start or end point be implicit. An implicit start point indicates the session's pause point, and if no pause point is set, the start of the content. An implicit end point indicates the end of the content. The usage of both implicit start and end points is not allowed in the same Range header; however, the omission of the Range header has that meaning, i.e., from pause point (or start) until end of content.",
      "ja": "Rangeヘッダは、単一レンジフォーマットの範囲を含んでいます。範囲は、開始及び終了点、開始点を含むが、エンドポイントを除くと半開区間です。範囲は、完全に、開始点と終了点、又はいずれかの開始または終了点が暗黙であったため、明示的な値で指定することができます。暗黙の開始点は、セッションの一時停止点を示し、何の一時停止ポイントが設定されていない場合、コンテンツの開始。暗黙のエンドポイントは、コンテンツの終わりを示します。両方の暗黙的な始点と終点の使用は、同じ範囲ヘッダーに許可されていません。しかしながら、Rangeヘッダの省略は、一時停止点（又は開始）からのコンテンツの最後まで、すなわち、その意味を有します。"
    },
    {
      "indent": 6,
      "text": "As noted, Range headers define half-open intervals. A range of A-B starts exactly at time A, but ends just before B. Only the start time of a media unit such as a video or audio frame is relevant. For example, assume that video frames are generated every 40 ms. A range of 10.0-10.1 would include a video frame starting at 10.0 or later time and would include a video frame starting at 10.08, even though it lasted beyond the interval. A range of 10.0-10.08, on the other hand, would exclude the frame at 10.08.",
      "ja": "前述のように、レンジヘッダはハーフオープンの間隔を定義します。 -Bの範囲は、正確に時間Aで始まり、しかしB.のみ、ビデオまたはオーディオフレーム等のメディアユニットの開始時間が関連する直前に終了します。例えば、ビデオ・フレームは40msごとに生成されていることを前提としています。 10.0から10.1の範囲は、10.0以降の時間で開始する映像フレームを含むであろうし、それは間隔を超えて続いたにもかかわらず、10.08から始まるビデオフレームを含むであろう。 10.0から10.08の範囲は、一方で、10.08のフレームを除外する。"
    },
    {
      "indent": 6,
      "text": "Please note the difference between NPT timescales' \"now\" and an implicit start value. Implicit values reference the current pause-point, while \"now\" is the current time. In a time-progressing session with recording (retention for some or full time), the pause point may be 2 min into the session while now could be 1 hour into the session.",
      "ja": "『今』 NPTタイムスケールと暗黙の開始値の違いに注意してください。 「今」、現在の時刻である暗黙的な値は、現在の一時停止ポイントを参照します。今セッションに1時間であることができるが（一部または完全な時間保持）を記録すると、時間進行のセッションにおいて、一時停止ポイントは、セッション中に2分であってもよいです。"
    },
    {
      "indent": 3,
      "text": "By default, range intervals increase, where the second point is larger than the first point.",
      "ja": "第二の点は、最初の点よりも大きい場合、デフォルトでは、範囲の間隔が増します。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 7,
      "text": "Range: npt=10-15",
      "ja": "範囲：NPT = 10-15"
    },
    {
      "indent": 3,
      "text": "However, range intervals can also decrease if the Scale header (see Section 18.46) indicates a negative scale value. For example, this would be the case when a playback in reverse is desired.",
      "ja": "スケールヘッダ（セクション18.46を参照）、負のスケール値を示している場合は、範囲の間隔も減少させることができます。例えば、これは、逆方向の再生が望まれる場合です。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 7,
      "text": "Scale: -1\nRange: npt=15-10",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Decreasing ranges are still half-open intervals as described above. Thus, for range A-B, A is closed and B is open. In the above example, 15 is closed and 10 is open. An exception to this rule is the case when B=0 is in a decreasing range. In this case, the range is closed on both ends, as otherwise there would be no way to reach 0 on a reverse playback for formats that have such a notion, like NPT and SMPTE.",
      "ja": "上記のように減少した範囲は、まだ半分開いた区間です。したがって、範囲A-Bについて、Aは閉じており、Bが開いています。上記の例では、閉じている15及び10が開放されています。 B = 0が減少する範囲内にある場合は、この規則の例外は、ケースです。そうでなければNPT及びSMPTE等のような概念を持っている形式の逆方向再生時に0に到達する方法がないであろうように、この場合、範囲は、両端で閉じられています。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 7,
      "text": "Scale: -1\nRange: npt=15-0",
      "raw": true
    },
    {
      "indent": 3,
      "text": "In this range, both 15 and 0 are closed.",
      "ja": "この範囲では、15と0の両方が閉じられています。"
    },
    {
      "indent": 3,
      "text": "A decreasing range interval without a corresponding negative value in the Scale header is not valid.",
      "ja": "スケールヘッダに対応する負の値のない減少範囲間隔が有効ではありません。"
    },
    {
      "indent": 0,
      "text": "18.41. Referrer",
      "section_title": true,
      "ja": "18.41. リファラー"
    },
    {
      "indent": 3,
      "text": "The Referrer request-header field allows the client to specify, for the server's benefit, the address (URI) of the resource from which the Request-URI was obtained. The URI refers to that of the presentation description, typically retrieved via HTTP. The Referrer request-header allows a server to generate lists of back-links to resources for interest, logging, optimized caching, etc. It also allows obsolete or mistyped links to be traced for maintenance. The Referrer field MUST NOT be sent if the Request-URI was obtained from a source that does not have its own URI, such as input from the user keyboard.",
      "ja": "リファラーリクエストヘッダフィールドは、クライアントが、サーバの利益のために、リクエストURIが取得されたリソースのアドレス（URI）を指定することを可能にします。 URIは、典型的には、HTTPを介して取り出され、プレゼンテーション記述のものを指します。リファラーリクエストヘッダには、サーバがそれはまた時代遅れやタイプミスのリンクがメンテナンスのためにトレースすることを可能にする関心、ロギング、最適化されたキャッシュなどのためのリソースへのバックリンクのリストを生成することができます。リクエストURIは、ユーザのキーボードからの入力として、それ自身のURIを持たないソースから入手した場合リファラフィールドが送信されてはいけません。"
    },
    {
      "indent": 3,
      "text": "If the field-value is a relative URI, it SHOULD be interpreted relative to the Request-URI. The URI MUST NOT include a fragment identifier.",
      "ja": "フィールド値が相対URIである場合、それは、Request-URIに対して解釈されるべきです。 URIには、フラグメント識別子を含んではいけません。"
    },
    {
      "indent": 3,
      "text": "Because the source of a link might be private information or might reveal an otherwise private information source, it is strongly recommended that the user be able to select whether or not the Referrer field is sent. For example, a streaming client could have a toggle switch for openly/anonymously, which would respectively enable/disable the sending of Referrer and From information.",
      "ja": "リンクのソースは、個人情報であるかもしれない、あるいは民間の情報源を明らかにする可能性があるため、強く、ユーザーが参照元フィールドが送信されたかどうかを選択できるようにすることをお勧めします。例えば、ストリーミングクライアントは、それぞれリファラの送信や情報から有効/無効にすることになる、公然/匿名のためのトグルスイッチを持つことができます。"
    },
    {
      "indent": 3,
      "text": "Clients SHOULD NOT include a Referrer header field in an (non-secure) RTSP request if the referring page was transferred with a secure protocol.",
      "ja": "参照ページがセキュアプロトコルで転送されていた場合、クライアントは、（非セキュア）RTSP要求にRefererヘッダフィールドを含むべきではありません。"
    },
    {
      "indent": 0,
      "text": "18.42. Request-Status",
      "section_title": true,
      "ja": "18.42. リクエストのステータス"
    },
    {
      "indent": 3,
      "text": "This request-header is used to indicate the end result for requests that take time to complete, such as PLAY (Section 13.4). It is sent in PLAY_NOTIFY (Section 13.5) with the end-of-stream reason to report how the PLAY request concluded, either in success or in failure. The header carries a reference to the request it reports on using the CSeq number and the Session ID used in the request reported on. This is not ensured to be unambiguous due to the fact that the CSeq number is scoped by the transport connection. Agents originating requests can reduce the issue by using a monotonically increasing counter across all sequential transports used. The header provides both a numerical status code (according to Section 8.1.1) and a human-readable reason phrase.",
      "ja": "このリクエストヘッダは、PLAY（セクション13.4）として完了するまでに時間がかかるリクエストに対する最終的な結果を示すために使用されます。それは、成功または失敗のいずれかで、PLAY要求が締結方法を報告するストリームの終わり理由でPLAY_NOTIFY（13.5節）に送信されます。ヘッダは、それがのCSeq番号とに報告された要求に使用されるセッションIDを使用して報告要求への参照を運びます。これが原因のCSeq番号はトランスポート接続によりスコープされているという事実に明確なことが保証されていません。リクエストを発信するエージェントが使用されるすべてのシーケンシャルトランスポート間で単調に増加するカウンタを使用することによって、問題を軽減することができます。ヘッダ（セクション8.1.1による）の数値ステータスコードと人間が読み取り可能な理由句の両方を提供します。"
    },
    {
      "indent": 3,
      "text": "Example: Request-Status: cseq=63 status=500 reason=\"Media data unavailable\"",
      "ja": "例：リクエスト-ステータス：のCSeq = 63のステータス= 500理由= \"メディアデータを利用できません\""
    },
    {
      "indent": 3,
      "text": "Proxies that renumber the CSeq header need to perform corresponding remapping of the cseq parameter in this header when forwarding the request to the next-hop agent.",
      "ja": "CSeqヘッダを付け直すプロキシは次のホップエージェントに要求を転送するとき、このヘッダ内のCSeqパラメータの対応する再マッピングを実行する必要があります。"
    },
    {
      "indent": 0,
      "text": "18.43. Require",
      "section_title": true,
      "ja": "18.43. 必要とします"
    },
    {
      "indent": 3,
      "text": "The Require request-header field is used by agents to ensure that the other endpoint supports features that are required in respect to this request. It can also be used to query if the other endpoint supports certain features; however, the use of the Supported general-header (Section 18.51) is much more effective in this purpose. In case any of the feature tags listed by the Require header are not supported by the server or client receiving the request, it MUST respond to the request using the error code 551 (Option Not Supported) and include the Unsupported header listing those feature tags that are NOT supported. This header does not apply to proxies; for the same functionality with respect to proxies, see the Proxy-Require header (Section 18.37) with the exception of media-modifying proxies. Media-modifying proxies, due to their nature of handling media in a way that is very similar to a server, do need to understand also the server's features to correctly serve the client.",
      "ja": "要求リクエストヘッダフィールドは、他のエンドポイントがこの要求に対してで必要とされる機能をサポートしていることを保証するために、エージェントによって使用されます。また、他のエンドポイントが特定の機能をサポートしている場合は照会するために使用することができます。ただし、サポートされている一般的なヘッダ（セクション18.51）の使用は、はるかに効果的な本目的です。場合に必要とヘッダでリストアップされた特徴タグのいずれかが要求を受信するサーバまたはクライアントでサポートされていない、それはエラーコード551（オプションサポートされていない）を使用して要求に応答し、それらの特徴タグをリストサポートされていないヘッダを含まなければならないことサポートされていません。このヘッダは、プロキシには適用されません。プロキシに対して同じ機能のために、メディア修飾プロキシを除いてプロキシ要求ヘッダ（セクション18.37）を参照。メディア修飾によるサーバーと非常によく似ている方法でメディアを扱う彼らの性質のために、プロキシを、正しくクライアントにサービスを提供するためにも、サーバーの機能を理解する必要があります。"
    },
    {
      "indent": 6,
      "text": "This is to make sure that the client-server interaction will proceed without delay when all features are understood by both sides and only slow down if features are not understood (as in the example below). For a well-matched client-server pair, the interaction proceeds quickly, saving a round trip often required by negotiation mechanisms. In addition, it also removes state ambiguity when the client requires features that the server does not understand.",
      "ja": "これは、すべての機能が両側で理解し、機能は（以下の例のように）理解されていない場合にのみスローダウンしているときに、クライアント - サーバ間の対話は、遅滞なく進めることを確認することです。よくマッチしたクライアント・サーバ・ペアの場合、相互作用は、多くの場合、交渉メカニズムによって必要なラウンドトリップを削減、迅速に進行します。クライアントがサーバが理解していない機能を必要とする場合に加えて、それはまた、国家の曖昧さを取り除きます。"
    },
    {
      "indent": 3,
      "text": "Example (Not complete):",
      "ja": "例（完全ではありません）："
    },
    {
      "indent": 3,
      "text": "C->S: SETUP rtsp://server.com/foo/bar/baz.rm RTSP/2.0 CSeq: 302 Require: funky-feature Funky-Parameter: funkystuff",
      "ja": "C-> S：SETUPのRTSP：//server.com/foo/bar/baz.rm RTSP / 2.0のCSeq：302で必要：ファンキー特徴ファンキー・パラメータを：funkystuff"
    },
    {
      "indent": 3,
      "text": "S->C: RTSP/2.0 551 Option not supported CSeq: 302 Unsupported: funky-feature",
      "ja": "S-> C：RTSP / 2.0 551オプションサポートされていないのCSeq：302サポートされていない：ファンキー特徴"
    },
    {
      "indent": 3,
      "text": "In this example, \"funky-feature\" is the feature tag that indicates to the client that the fictional Funky-Parameter field is required. The relationship between \"funky-feature\" and Funky-Parameter is not communicated via the RTSP exchange, since that relationship is an immutable property of \"funky-feature\" and thus should not be transmitted with every exchange.",
      "ja": "この例では、「ファンキー・機能は、」架空のファンキー・パラメータのフィールドが必要であることをクライアントに示した特徴タグです。その関係は、「ファンキー特徴」の不変性であり、したがって、すべての交換で送信されるべきではないので、「ファンキー特徴」の関係とファンキー・パラメータは、RTSP交換を介して伝達されません。"
    },
    {
      "indent": 3,
      "text": "Proxies and other intermediary devices MUST ignore this header. If a particular extension requires that intermediate devices support it, the extension should be tagged in the Proxy-Require field instead (see Section 18.37). See discussion in the proxies section (Section 15.1) about when to consider that a feature requires proxy support.",
      "ja": "プロキシおよび他の中間デバイスは、このヘッダを無視しなければなりません。特定の拡張は、中間デバイスがそれをサポートする必要がある場合、エクステンションは、（セクション18.37を参照）の代わりにプロキシ要求フィールドにタグ付けされるべきです。機能は、プロキシのサポートが必要であることを考慮するときについて、プロキシ区間（15.1）での議論を参照してください。"
    },
    {
      "indent": 0,
      "text": "18.44. Retry-After",
      "section_title": true,
      "ja": "18.44. リトライ後"
    },
    {
      "indent": 3,
      "text": "The Retry-After response-header field can be used with a 503 (Service Unavailable) or 553 (Proxy Unavailable) response to indicate how long the service is expected to be unavailable to the requesting client. This field MAY also be used with any 3rr (Redirection) response to indicate the minimum time the user agent is asked to wait before issuing the redirected request. A response using 413 (Request Message Body Too Large) when the restriction is temporary MAY also include the Retry-After header. The value of this field can be either an RTSP-date or an integer number of seconds (in decimal) after the time of the response.",
      "ja": "リトライ後レスポンス・ヘッダー・フィールドは、503（サービス利用不可）、またはサービスを要求しているクライアントに利用できないと予想される時間の長さを示すために553（プロキシ使用不可）応答と共に使用することができます。このフィールドは、ユーザエージェントがリダイレクト要求を発行する前に待機するように要求される最小時間を示すために、任意の3RR（リダイレクト）応答で使用されるかもしれません。制限が一時的である場合413（大きすぎる要求メッセージボディ）を使用して応答はまた、リトライ後ヘッダを含むかもしれません。このフィールドの値は、応答の時間後にRTSP日付または（10進数）秒の整数のいずれかであり得ます。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 3,
      "text": "Retry-After: Fri, 31 Dec 1999 23:59:59 GMT Retry-After: 120",
      "ja": "リトライ後：金、1999年12月31日午後11時59分59秒GMT再試行し、後：120"
    },
    {
      "indent": 3,
      "text": "In the latter example, the delay is 2 minutes.",
      "ja": "後者の例では、遅延は2分です。"
    },
    {
      "indent": 0,
      "text": "18.45. RTP-Info",
      "section_title": true,
      "ja": "18：45。 RTP-情報"
    },
    {
      "indent": 3,
      "text": "The RTP-Info general-header field is used to set RTP-specific parameters in the PLAY and GET_PARAMETER responses or PLAY_NOTIFY and GET_PARAMETER requests. For streams using RTP as transport protocol, the RTP-Info header SHOULD be part of a 200 response to PLAY.",
      "ja": "RTP-INFO一般ヘッダフィールドは、PLAYとGET_PARAMETER応答またはPLAY_NOTIFYとGET_PARAMETER要求におけるRTP固有のパラメータを設定するために使用されています。トランスポートプロトコルとしてRTPを使用してストリームの場合、RTP-Infoヘッダを再生する200応答の一部であるべきです。"
    },
    {
      "indent": 6,
      "text": "The exclusion of the RTP-Info in a PLAY response for RTP-transported media will result in a client needing to synchronize the media streams using RTCP. This may have negative impact as the RTCP can be lost and does not need to be particularly timely in its arrival. Also, functionality that informs the client from which packet a seek has occurred is affected.",
      "ja": "RTP-輸送メディアのPLAY応答のRTP-情報の除外は、RTCPを使用して、メディアストリームを同期する必要がクライアントになります。 RTCPが失われることがあり、その到着で、特にタイムリーである必要はありませんので、これはマイナスの影響を与える可能性があります。また、パケットaが発生して求め、そこからクライアントに通知機能が影響を受けています。"
    },
    {
      "indent": 3,
      "text": "The RTP-Info MAY be included in SETUP responses to provide synchronization information when changing transport parameters, see Section 13.3. The RTP-Info header and the Range header MAY be included in a GET_PARAMETER request from client to server without any values to request the current playback point and corresponding RTP synchronization information. When the RTP-Info header is included in a Request, the Range header MUST also be included. The server response SHALL include both the Range header and the RTP-Info header. If the session is in Play state, then the value of the Range header SHALL be filled in with the current playback point and with the corresponding RTP-Info values. If the server is in another state, no values are included in the RTP-Info header. The header is included in PLAY_NOTIFY requests with the Notify-Reason of the end of stream to provide RTP information about the end of the stream.",
      "ja": "RTP-情報は、トランスポートパラメータを変更する場合、セクション13.3を参照してください、同期情報を提供するために、SETUP応答に含まれるかもしれません。 RTP-InfoヘッダとRangeヘッダは、現在の再生時点と対応するRTP同期情報を要求する任意の値を持たないクライアントからサーバへのGET_PARAMETER要求に含まれるかもしれません。 RTP-Infoヘッダがリクエストに含まれている場合、Rangeヘッダも含まなければなりません。サーバーの応答は、RangeヘッダおよびRTP-Infoヘッダーの両方を含むものとします。セッションが再生状態である場合には、Rangeヘッダの値は、現在の再生時点とし、対応するRTP-INFO値で充填することがSHALL。サーバが別の状態にある場合、値がRTP-Infoヘッダに含まれていません。ヘッダは、ストリームの終了に関するRTP情報を提供するために、ストリームの終了の通知-理由とPLAY_NOTIFY要求に含まれています。"
    },
    {
      "indent": 3,
      "text": "The header can carry the following parameters:",
      "ja": "ヘッダは、以下のパラメータを運ぶことができます。"
    },
    {
      "indent": 3,
      "text": "url: Indicates the stream URI for which the following RTP parameters correspond; this URI MUST be the same as used in the SETUP request for this media stream. Any relative URI MUST use the Request-URI as base URI. This parameter MUST be present.",
      "ja": "URLは次のRTPパラメータが対応するためのストリームURIを示します。このURIは、このメディアストリームのためのSETUP要求で使用したものと同じでなければなりません。任意の相対URIは、ベースURIとしてのRequest-URIを使用しなければなりません。このパラメータが存在しなければなりません。"
    },
    {
      "indent": 3,
      "text": "ssrc: The SSRC to which the RTP timestamp and sequence number provided applies. This parameter MUST be present.",
      "ja": "SSRC：SSRC提供RTPタイムスタンプとシーケンス番号が適用されます。このパラメータが存在しなければなりません。"
    },
    {
      "indent": 3,
      "text": "seq: Indicates the sequence number of the first packet of the stream that is direct result of the request. This allows clients to gracefully deal with packets when seeking. The client uses this value to differentiate packets that originated before the seek from packets that originated after the seek. Note that a client may not receive the packet with the expressed sequence number and instead may receive packets with a higher sequence number due to packet loss or reordering. This parameter is RECOMMENDED to be present.",
      "ja": "配列は：要求の直接の結果であるストリームの最初のパケットのシーケンス番号を示します。これが求めている時に、クライアントが優雅パケットに対処することができます。クライアントは、シーク後に発信したパケットから求める前に、発信元のパケットを区別するために、この値を使用しています。クライアントは、パケット損失または再順序付けに高いシーケンス番号を有するパケットを受信することができる代わりに、発現された配列番号を有するパケットを受信しなくてもよいことに留意されたいです。このパラメータは存在することが推奨されます。"
    },
    {
      "indent": 3,
      "text": "rtptime: MUST indicate the RTP timestamp value corresponding to the start time value in the Range response-header or, if not explicitly given, the implied start point. The client uses this value to calculate the mapping of RTP time to NPT or other media timescale. This parameter SHOULD be present to ensure inter-media synchronization is achieved. There exists no requirement that any received RTP packet will have the same RTP timestamp value as the one in the parameter used to establish synchronization.",
      "ja": "rtptime：明示的に、暗黙の開始点を与えられていない場合、レンジ応答ヘッダで開始時間値に対応するRTPタイムスタンプ値を示すか、しなければなりません。クライアントは、NPTや他のメディアのタイムスケールにRTP時間のマッピングを計算し、この値を使用しています。このパラメータは、メディア間同期が達成されることを保証するために存在すべきです。任意の同期を確立するために使用されるパラメータの1と同じRTPタイムスタンプ値を持つことになりますRTPパケットを受信要件は存在しません。"
    },
    {
      "indent": 6,
      "text": "A mapping from RTP timestamps to NTP format timestamps (wallclock) is available via RTCP. However, this information is not sufficient to generate a mapping from RTP timestamps to media clock time (NPT, etc.). Furthermore, in order to ensure that this information is available at the necessary time (immediately at startup or after a seek), and that it is delivered reliably, this mapping is placed in the RTSP control channel.",
      "ja": "NTPフォーマットのタイムスタンプにRTPタイムスタンプからのマッピング（ウォールクロック）は、RTCPを介して利用可能です。しかし、この情報は、メディアクロック時間にRTPタイムスタンプ（NPT、等）からのマッピングを生成するために十分ではありません。また、ために、この情報は必要時に（直ちに、シーク起動時または後に）利用可能であることを確認し、それが確実に配信されることを、このマッピングは、RTSP制御チャネルに配置されます。"
    },
    {
      "indent": 6,
      "text": "In order to compensate for drift for long, uninterrupted presentations, RTSP clients should additionally map NPT to NTP, using initial RTCP sender reports to do the mapping, and later reports to check drift against the mapping.",
      "ja": "長い、中断のないプレゼンテーションのためにドリフトを補償するためには、RTSPクライアントは、さらにマッピングに対するドリフトをチェックするためにマッピングを行うには、最初のRTCP送信者レポートを使用して、後でレポート、NTPにNPTをマップする必要があります。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 3,
      "text": "Range:npt=3.25-15 RTP-Info:url=\"rtsp://example.com/foo/audio\" ssrc=0A13C760:seq=45102; rtptime=12345678,url=\"rtsp://example.com/foo/video\" ssrc=9A9DE123:seq=30211;rtptime=29567112",
      "ja": "範囲：NPT = 3.25から15 RTP-情報：URL = \"RTSP：//example.com/foo/audio\" SSRC = 0A13C760：SEQ = 45102; rtptime = 12345678、URL = \"RTSP：//example.com/foo/video\" SSRC = 9A9DE123：SEQ = 30211; rtptime = 29567112"
    },
    {
      "indent": 3,
      "text": "Lets assume that Audio uses a 16 kHz RTP timestamp clock and Video a 90 kHz RTP timestamp clock. Then, the media synchronization is depicted in the following way.",
      "ja": "オーディオは、16 kHzのRTPタイムスタンプのクロックとビデオ90 kHzのRTPタイムスタンプのクロックを使用することを前提としています。その後、メディア同期は次のように描かれています。"
    },
    {
      "indent": 3,
      "text": "NPT    3.0---3.1---3.2-X-3.3---3.4---3.5---3.6\nAudio               PA A\nVideo                  V    PV",
      "raw": true
    },
    {
      "indent": 3,
      "text": "X: NPT time value = 3.25, from Range header. A: RTP timestamp value for Audio from RTP-Info header (12345678). V: RTP timestamp value for Video from RTP-Info header (29567112). PA: RTP audio packet carrying an RTP timestamp of 12344878, which corresponds to NPT = (12344878 - A) / 16000 + 3.25 = 3.2 PV: RTP video packet carrying an RTP timestamp of 29573412, which corresponds to NPT = (29573412 - V) / 90000 + 3.25 = 3.32",
      "ja": "X：NPT時刻の値= 3.25、Rangeヘッダから。 ：RTP-Infoヘッダからオーディオ用のRTPタイムスタンプ値（12345678）。 V：RTP-Infoヘッダー（29567112）からのビデオのためのRTPタイムスタンプ値。 PA：NPT =（12344878  -  A）に対応する12344878のRTPタイムスタンプを運ぶRTPオーディオパケット/ 16000 + 3.25 = 3.2 PV：NPT =に対応する29573412のRTPタイムスタンプを運ぶRTPビデオパケット、（29573412  -  V） / 90000 + 3.25 = 3.32"
    },
    {
      "indent": 0,
      "text": "18.46. Scale",
      "section_title": true,
      "ja": "18.46. 規模"
    },
    {
      "indent": 3,
      "text": "The Scale general-header indicates the requested or used view rate for the media resource being played back. A scale value of 1 indicates normal play at the normal forward viewing rate. If not 1, the value corresponds to the rate with respect to normal viewing rate. For example, a value of 2 indicates twice the normal viewing rate (\"fast forward\") and a value of 0.5 indicates half the normal viewing rate. In other words, a value of 2 has content time increase at twice the playback time. For every second of elapsed (wallclock) time, 2 seconds of content time will be delivered. A negative value indicates reverse direction. For certain media transports, this may require certain considerations to work consistently; see Appendix C.1 for description on how RTP handles this.",
      "ja": "スケール一般的なヘッダは、再生中のメディアリソースの要求または使用される視聴率を示しています。 1のスケール値は、通常の前方の視聴率で、通常のプレイを示しています。ない1の場合、値は通常の視聴速度に対する割合に相当します。例えば、2の値が倍通常の視聴率を示している（「早送り」）及び0.5の値は、通常の半分の視聴率を示しています。言い換えれば、2の値は、二回の再生時にコンテンツの時間が増加しています。経過（ウォールクロック）時間の毎秒のために、コンテンツの時間の2秒が配信されます。負の値は逆方向を示しています。特定のメディアトランスポートの場合、これは一貫して動作するために一定の配慮が必要な場合があります。 RTPは、これをどのように処理するかについての説明は、付録C.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "The transmitted-data rate SHOULD NOT be changed by selection of a different scale value. The resulting bitrate should be reasonably close to the nominal bitrate of the content for scale = 1. The server has to actively manipulate the data when needed to meet the bitrate constraints. Implementation of scale changes depends on the server and media type. For video, a server may, for example, deliver only key frames or selected frames. For audio, it may time-scale the audio while preserving pitch or, less desirably, deliver fragments of audio, or completely mute the audio.",
      "ja": "送信されたデータレートは、異なるスケール値を選択することによって変更してはなりません。結果のビットレートは= 1.サーバーが、ビットレートの制約を満たすために必要なときに積極的にデータを操作するために持っている規模のコンテンツの公称ビットレートにかなり近いはずです。規模な変更の実装は、サーバーおよびメディアタイプによって異なります。ビデオの場合、サーバは、例えば、キーフレーム、または選択されたフレームのみを配信してもよいです。オーディオの場合、それはあまり望ましく、ピッチを維持しながら、または、オーディオをスケール時間を計るオーディオ、または完全にミュートオーディオの断片を送達することができます。"
    },
    {
      "indent": 3,
      "text": "The server and content may restrict the range of scale values that it supports. The supported values are indicated by the Media-Properties header (Section 18.29). The client SHOULD only indicate request values to be supported. However, as the values may change as the content progresses, a requested value may no longer be valid when the request arrives. Thus, a non-supported value in a request does not generate an error, it only forces the server to choose the closest value. The response MUST always contain the actual scale value chosen by the server.",
      "ja": "サーバとコンテンツは、それがサポートするスケール値の範囲を制限することができます。サポートされる値は、メディアプロパティヘッダ（セクション18.29）で示しています。クライアントは、要求値がサポートされるようにのみ示す必要があります。コンテンツが進むにつれて値が変更される可能性として要求が到着したときただし、要求された値は、もはや有効ではないかもしれません。このように、要求でサポートされていない値はエラーを生成しません、それだけで最も近い値を選択するには、サーバーを強制します。応答は常にサーバーによって選ばれた実際のスケール値を含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the server does not implement the possibility to scale, it will not return a Scale header. A server supporting scale operations for PLAY MUST indicate this with the use of the \"play.scale\" feature tag.",
      "ja": "サーバが拡張する可能性を実装していない場合は、スケールヘッダーを返しません。 PLAYのスケール操作をサポートするサーバーは、「play.scale」フィーチャータグの使用でこれを指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "When indicating a negative scale for a reverse playback, the Range header MUST indicate a decreasing range as described in Section 18.40.",
      "ja": "逆再生のための負のスケールを示す場合、セクション18.40に記載されているように、Rangeヘッダは、減少範囲を示さなければなりません。"
    },
    {
      "indent": 3,
      "text": "Example of playing in reverse at 3.5 times normal rate:",
      "ja": "3.5倍、通常の速度で逆で遊んでの例："
    },
    {
      "indent": 5,
      "text": "Scale: -3.5 Range: npt=15-10",
      "ja": "スケール：-3.5範囲：NPT = 15-10"
    },
    {
      "indent": 0,
      "text": "18.47. Seek-Style",
      "section_title": true,
      "ja": "18.47. シークスタイル"
    },
    {
      "indent": 3,
      "text": "When a client sends a PLAY request with a Range header to perform a random access to the media, the client does not know if the server will pick the first media samples or the first random access point prior to the request range. Depending on the use case, the client may have a strong preference. To express this preference and provide the client with information on how the server actually acted on that preference, the Seek-Style general-header is defined.",
      "ja": "クライアントがメディアへのランダムアクセスを実行するためのRangeヘッダとPLAY要求を送信すると、サーバーは、要求範囲に先立って、最初のメディアサンプルまたは最初のランダムアクセスポイントを選択する場合は、クライアントは知りません。ユースケースによっては、クライアントが強い好みを有することができます。この設定を表現し、サーバーが実際にその好みに作用する方法についての情報をクライアントに提供するために、シーク・スタイル一般ヘッダが定義されています。"
    },
    {
      "indent": 3,
      "text": "Seek-Style is a general-header that MAY be included in any PLAY request to indicate the client's preference for any media stream that has the random access properties. The server MUST always include the header in any PLAY response for media with random access properties to indicate what policy was applied. A server that receives an unknown Seek-Style policy MUST ignore it and select the server default policy. A client receiving an unknown policy MUST ignore it and use the Range header and any media synchronization information as basis to determine what the server did.",
      "ja": "シークスタイルは、ランダムアクセス特性を有する任意のメディアストリームのためのクライアントの好みを示すために、任意のPLAY要求に含まれるかもしれ一般ヘッダです。サーバーは常にポリシーが適用されたものを示すために、ランダムアクセスプロパティを持つメディアのための任意のPLAY応答のヘッダを含まなければなりません。未知のシーク・スタイルのポリシーを受信するサーバーはそれを無視して、サーバーのデフォルトポリシーを選択する必要があります。未知の方針を受けて、クライアントはそれを無視し、サーバが何をしたかを判断するための基礎としてRangeヘッダおよび任意のメディア同期情報を使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "This specification defines the following seek policies that may be requested (see also Section 4.7.1):",
      "ja": "この仕様は、（セクション4.7.1を参照）を要求することができる以下の求める方針を定義しています。"
    },
    {
      "indent": 3,
      "text": "RAP: Random Access Point (RAP) is the behavior of requesting the server to locate the closest previous random access point that exists in the media aggregate and deliver from that. By requesting a RAP, media quality will be the best possible as all media will be delivered from a point where full media state can be established in the media decoder.",
      "ja": "RAP：ランダムアクセスポイント（RAP）は、メディアの集計に存在する最も近い前回のランダムアクセスポイントを見つけて、それから提供するサーバに要求の動作です。すべてのメディアが満杯メディア状態は、メディアデコーダに確立することができる点から送達されるようにRAPを要求することによって、メディア品質が最良可能となります。"
    },
    {
      "indent": 3,
      "text": "CoRAP: Conditional Random Access Point (CoRAP) is a variant of the above RAP behavior. This policy is primarily intended for cases where there is larger distance between the random access points in the media. CoRAP uses the RAP policy if the condition that there is a Random Access Point closer to the requested start point than to the current pause point is fulfilled. Otherwise, no seeking is performed and playback will continue from the current pause point. This policy assumes that the media state existing prior to the pause is usable if delivery is continued. If the client or server knows that this is not the fact, the RAP policy should be used. In other words, in most cases when the client requests a start point prior to the current pause point, a valid decoding dependency chain from the media delivered prior to the pause and to the requested media unit will not exist. If the server searched to a random access point, the server MUST return the CoRAP policy in the Seek-Style header and adjust the Range header to reflect the position of the selected RAP. In case the random access point is farther away and the server chooses to continue from the current pause point, it MUST include the \"Next\" policy in the Seek-Style header and adjust the Range header start point to the current pause point.",
      "ja": "CoRAP：条件付きランダム・アクセス・ポイント（CoRAP）は、上記のRAPの挙動の変種です。このポリシーは、主にメディア内のランダムアクセスポイントとの間のより大きな距離がある場合のために意図されています。近い要求された開始点までの現在の一時停止地点までよりランダムアクセスポイントがあるという条件が満たされた場合CoRAPはRAPポリシーを使用しています。そうでない場合は、シークが実行されず、再生が一時停止現在のポイントから続行されます。このポリシーは、配信が継続された場合に一時停止する前に既存のメディアの状態が使用可能であることを前提としています。クライアントまたはサーバーが、これは事実ではないことを知っている場合、RAPのポリシーを使用する必要があります。言い換えれば、ほとんどの場合、クライアントが現在の一時停止ポイントに先立って開始点を要求したときに、一時停止の前に、要求されたメディアユニットに配信メディアから有効なデコード依存チェーンが存在しません。サーバは、ランダムアクセスポイントを検索した場合、サーバはシークスタイルのヘッダーにCoRAPポリシーを返し、選択されたRAPの位置を反映するようにRangeヘッダを調整しなければなりません。場合にランダムアクセスポイントが遠く離れていると、サーバは、現在の一時停止点から継続することを選択し、それがシークスタイルのヘッダに「次へ」ポリシーを含み、現在の一時停止ポイントまでの範囲のヘッダ開始点を調整しなければなりません。"
    },
    {
      "indent": 3,
      "text": "First-Prior: The first-prior policy will start delivery with the media unit that has a playout time first prior to the requested time. For discrete media, that would only include media units that would still be rendered at the request time. For continuous media, that is media that will be rendered during the requested start time of the range.",
      "ja": "まず、前：最初の前にポリシーが要求された時に最初の前に再生時間を持つメディアユニットで配信を開始します。離散的な媒体のため、それはまだ要求時にレンダリングされるであろうメディアユニットのみを含むことになります。連続メディアの場合は、その範囲の要求された開始時間の間にレンダリングされるメディアです。"
    },
    {
      "indent": 3,
      "text": "Next: The next media units after the provided start time of the range: for continuous framed media, that would mean the first next frame after the provided time and for discrete media, the first unit that is to be rendered after the provided time. The main usage for this case is when the client knows it has all media up to a certain point and would like to continue delivery so that a complete uninterrupted media playback can be achieved. An example of such a scenario would be switching from a broadcast/multicast delivery to a unicast-based delivery. This policy MUST only be used on the client's explicit request.",
      "ja": "次：範囲の提供開始時間の後の次のメディアユニットが：連続的なフレームのメディアのために、それが提供される時間後に離散メディア、提供時間後にレンダリングされる最初のユニットのための第一次のフレームを意味します。クライアントは、それが特定のポイントまでのすべてのメディアを持って知っていて、完全な途切れのないメディアの再生を達成することができるように配信を続けていきたいと考えたときに、この場合の主な使用法はあります。このようなシナリオの例は、ユニキャストベースの送達にブロードキャスト/マルチキャスト配信に切り替えることになります。このポリシーは、クライアントの明示的な要求に使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Please note that these expressed preferences exist for optimizing the startup time or the media quality. The \"Next\" policy breaks the normal definition of the Range header to enable a client to request media with minimal overlap, although some may still occur for aggregated sessions. RAP and First-Prior both fulfill the requirement of providing media from the requested range and forward. However, unless RAP is used, the media quality for many media codecs using predictive methods can be severely degraded unless additional data is available as, for example, already buffered, or through other side channels.",
      "ja": "これらの表現の好みは、起動時間やメディアの品質を最適化するために存在することに注意してください。 「次へ」政策は、いくつかは依然としてアグリゲートされたセッションのために起こるかもしれないが、最小の重なりでメディアを要求するクライアントを可能にするために、Rangeヘッダの通常の定義を壊します。 RAPと要求された範囲と前方からメディアを提供する第一前両方満たす要件。 RAPが使用されていない限り、例えば、既にバッファされ、または他のサイドチャネルを介して、のような追加データが利用可能でない限りしかし、予測方法を用いて、多くのメディアコーデックのメディア品質が著しく低下することができます。"
    },
    {
      "indent": 0,
      "text": "18.48. Server",
      "section_title": true,
      "ja": "18.48. サーバ"
    },
    {
      "indent": 3,
      "text": "The Server general-header field contains information about the software used by the origin server to create or handle the request. This field can contain multiple product tokens and comments identifying the server and any significant subproducts. The product tokens are listed in order of their significance for identifying the application.",
      "ja": "サーバー一般ヘッダフィールドは、リクエストを作成または処理するために、オリジンサーバによって使用されているソフトウェアに関する情報が含まれています。このフィールドは、サーバーとすべての重要なサブプロダクトを特定する複数の製品トークンやコメントを含めることができます。製品トークンはアプリケーションを識別するためのその重要性の順に記載されています。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 3,
      "text": "Server: PhonyServer/1.0",
      "ja": "サーバー：PhonyServer / 1.0"
    },
    {
      "indent": 3,
      "text": "If the response is being forwarded through a proxy, the proxy application MUST NOT modify the Server response-header. Instead, it SHOULD include a Via field (Section 18.57). If the response is generated by the proxy, the proxy application MUST return the Server response-header as previously returned by the server.",
      "ja": "応答がプロキシを介して転送されている場合は、プロキシ・アプリケーションは、サーバーの応答ヘッダを変更してはいけません。代わりに、Viaフィールド（セクション18.57）を含むべきです。応答がプロキシによって生成された場合、以前にサーバによって返され、プロキシ・アプリケーションは、サーバーの応答ヘッダを返さなければなりません。"
    },
    {
      "indent": 0,
      "text": "18.49. Session",
      "section_title": true,
      "ja": "18.49. セッション"
    },
    {
      "indent": 3,
      "text": "The Session general-header field identifies an RTSP session. An RTSP session is created by the server as a result of a successful SETUP request, and in the response, the session identifier is given to the client. The RTSP session exists until destroyed by a TEARDOWN or a REDIRECT or is timed out by the server.",
      "ja": "セッション一般的なヘッダフィールドは、RTSPセッションを識別する。 RTSPセッションは成功したSETUP要求の結果として、サーバーによって作成され、それに応答して、セッション識別子は、クライアントに与えられています。 TEARDOWNまたはREDIRECTによって破壊されたり、サーバーによってタイムアウトするまでのRTSPセッションが存在します。"
    },
    {
      "indent": 3,
      "text": "The session identifier is chosen by the server (see Section 4.3) and MUST be returned in the SETUP response. Once a client receives a session identifier, it MUST be included in any request related to that session. This means that the Session header MUST be included in a request, using the following methods: PLAY, PAUSE, PLAY_NOTIFY and TEARDOWN. It MAY be included in SETUP, OPTIONS, SET_PARAMETER, GET_PARAMETER, and REDIRECT. It MUST NOT be included in DESCRIBE. The Session header MUST NOT be included in the following methods, if these requests are pipelined and if the session identifier is not yet known: PLAY, PAUSE, TEARDOWN, SETUP, OPTIONS SET_PARAMETER, and GET_PARAMETER.",
      "ja": "セッション識別子がサーバによって選択されている（4.3節を参照）、SETUP応答で返さなければなりません。クライアントは、セッション識別子を受信すると、そのセッションに関連するすべての要求に含まれなければなりません。 PLAY、PAUSE、TEARDOWN PLAY_NOTIFYと：これは、セッション・ヘッダは、以下の方法を使用して、要求に含まれなければならないことを意味します。これは、SETUP、OPTIONS、SET_PARAMETER、GET_PARAMETER、およびREDIRECTに含まれるかもしれません。 DESCRIBEに含めることはできません。セッションヘッダは、これらの要求はパイプライン化された場合、以下の方法に含まれてはいけませんセッション識別子がまだ知られていない場合：PLAY、PAUSE、TEARDOWN、SETUP、OPTIONSのSET_PARAMETERとGET_PARAMETER。"
    },
    {
      "indent": 3,
      "text": "In an RTSP response, the session header MUST be included in methods, SETUP, PLAY, PAUSE, and PLAY_NOTIFY, and it MAY be included in methods TEARDOWN and REDIRECT. If included in the request of the following methods it MUST also be included in the response: OPTIONS, GET_PARAMETER, and SET_PARAMETER. It MUST NOT be included in DESCRIBE responses.",
      "ja": "RTSP応答で、セッション・ヘッダは、メソッド、SETUP、PLAY、PAUSE、およびPLAY_NOTIFYに含まれなければならず、方法のTEARDOWNとREDIRECTに含まれるかもしれ。次の方法の要求に含まれている場合、それはまた、応答に含まれなければならない：OPTIONS、GET_PARAMETER、およびSET_PARAMETERを。応答の記述に含めることはできません。"
    },
    {
      "indent": 3,
      "text": "Note that a session identifier identifies an RTSP session across transport sessions or connections. RTSP requests for a given session can use different URIs (Presentation and media URIs). Note, that there are restrictions depending on the session as to which URIs are acceptable for a given method. However, multiple \"user\" sessions for the same URI from the same client will require use of different session identifiers.",
      "ja": "セッション識別子は、トランスポートセッションまたは接続でRTSPセッションを識別することに留意されたいです。特定のセッションのためのRTSP要求が異なるのURI（プレゼンテーションおよびメディアのURI）を使用することができます。そのURIが指定された方法のために許容可能であるようセッションに応じて制限があることに留意されたいです。しかし、同じクライアントから同じURIに対して複数の「ユーザー」セッションは別のセッション識別子を使用する必要があります。"
    },
    {
      "indent": 6,
      "text": "The session identifier is needed to distinguish several delivery requests for the same URI coming from the same client.",
      "ja": "セッション識別子は、同じクライアントから同じURIのためのいくつかの配信要求を区別するために必要とされています。"
    },
    {
      "indent": 3,
      "text": "The response 454 (Session Not Found) MUST be returned if the session identifier is invalid.",
      "ja": "セッション識別子が無効である場合、応答454は、（セッションが見つかりません）が返されなければなりません。"
    },
    {
      "indent": 3,
      "text": "The header MAY include a parameter for session timeout period. If not explicitly provided, this value is set to 60 seconds. As this affects how often session keep-alives are needed, values smaller than 30 seconds are not recommended. However, larger-than-default values can be useful in applications of RTSP that have inactive but established sessions for longer time periods.",
      "ja": "ヘッダは、セッションタイムアウト期間のパラメータを含むかもしれません。明示的に提供されていない場合、この値は60秒に設定されています。これはセッションキープアライブが必要とされる頻度に影響として、30秒が推奨されていないよりも小さい値。しかし、より規模の大きいデフォルト値は、長い期間のために不活性であるが、確立されたセッションを持っているRTSPの用途に有用であることができます。"
    },
    {
      "indent": 6,
      "text": "The 60-second value was chosen as the session timeout value as it results in keep-alive messages that are not too frequent and low sensitivity to variations in request/response timing. If one reduces the timeout value to below 30 seconds, the corresponding request/response timeout becomes a significant part of the session timeout. The 60-second value also allows for reasonably rapid recovery of committed server resources in case of client failure.",
      "ja": "それはあまりにも頻繁に要求/応答タイミングの変動に対する低感度ないキープアライブメッセージをもたらすように60秒の値は、セッションタイムアウト値として選択しました。一つは30秒以下にタイムアウト値を減少させた場合、対応するリクエスト/レスポンスタイムアウトは、セッションタイムアウトの重要な部分となります。 60秒の値は、クライアントに障害が発生した場合にコミットサーバリソースの合理的に迅速な復旧が可能になります。"
    },
    {
      "indent": 0,
      "text": "18.50. Speed",
      "section_title": true,
      "ja": "18.50. 速度"
    },
    {
      "indent": 3,
      "text": "The Speed general-header field requests the server to deliver specific amounts of nominal media time per unit of delivery time, contingent on the server's ability and desire to serve the media stream at the given speed. The client requests the delivery speed to be within a given range with a lower and upper bound. The server SHALL deliver at the highest possible speed within the range, but not faster than the upper bound, for which the underlying network path can support the resulting transport data rates. As long as any speed value within the given range can be provided, the server SHALL NOT modify the media quality. Only if the server is unable to deliver media at the speed value provided by the lower bound shall it reduce the media quality.",
      "ja": "スピード一般ヘッダフィールドは、サーバの能力と所定の速度でメディアストリームを提供する欲求の偶発配達時間の単位当たりの名目上のメディア時間の特定の量を、提供するサーバに要求します。クライアントは、下限と上限と所定の範囲内に配信速度を要求します。サーバーは、基盤となるネットワークパスが結果のトランスポート・データ・レートをサポートできるため、上限よりも速い範囲内で可能な限り最高の速度で提供しますが、してはなりません。限り、所与の範囲内の任意の速度値を提供することができるように、サーバは、メディア品質を変更しないもの。サーバーは、下限が提供する速度値でメディアを配信することができない場合にのみ、それはメディアの品質を低下させるものとします。"
    },
    {
      "indent": 3,
      "text": "Implementation of the Speed functionality by the server is OPTIONAL. The server can indicate its support through a feature tag, play.speed. The lack of a Speed header in the response is an indication of lack of support of this functionality.",
      "ja": "サーバーによる速度機能の実装はオプションです。サーバーは、機能、タグ、play.speedを通じてサポートを示すことができます。応答速度ヘッダの欠如は、この機能のサポートの欠如の指標です。"
    },
    {
      "indent": 3,
      "text": "The speed parameter values are expressed as a positive decimal value, e.g., a value of 2.0 indicates that data is to be delivered twice as fast as normal. A speed value of zero is invalid. The range is specified in the form \"lower bound - upper bound\". The lower-bound value may be smaller or equal to the upper bound. All speeds may not be possible to support. Therefore, the server MAY modify the requested values to the closest supported. The actual supported speed MUST be included in the response. However, note that the use cases may vary and that Speed value ranges such as 0.7-0.8, 0.3-2.0, 1.0-2.5, and 2.5-2.5 all have their usages.",
      "ja": "速度パラメータの値は正の10進値で表され、例えば、2.0の値は、データが通常の2倍の速配信されることを示しています。ゼロの速度値が無効です。範囲は、「 - 上限下限」形式で指定されています。下限値が上限に小さいか、または等しくてもよいです。すべての速度がサポートできない場合があります。そのため、サーバーは、サポートされている最も近い要求された値を変更することができます。実際のサポート速度は応答に含まれなければなりません。しかし、ユースケースは変更になる場合がありますと、このような0.7から0.8、0.3から2.0、1.0から2.5、および2.5から2.5としてその速度値の範囲はすべてその使い方を持っていることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 5,
      "text": "Speed: 1.0-2.5",
      "ja": "スピード：1.0〜2.5"
    },
    {
      "indent": 3,
      "text": "Use of this header changes the bandwidth used for data delivery. It is meant for use in specific circumstances where delivery of the presentation at a higher or lower rate is desired. The main use cases are buffer operations or local scale operations. Implementers should keep in mind that bandwidth for the session may be negotiated beforehand (by means other than RTSP) and, therefore, renegotiation may be necessary. To perform Speed operations, the server needs to ensure that the network path can support the resulting bitrate. Thus, the media transport needs to support feedback so that the server can react and adapt to the available bitrate.",
      "ja": "このヘッダの使用は、データ配信に使用される帯域幅を変化させます。これは、より高いまたはより低い速度でのプレゼンテーションの送達が望まれる特定の状況での使用のために意図されています。主な使用事例は、バッファ操作またはローカルスケール操作です。実装は、セッションのための帯域幅が（RTSP以外の手段によって）予め交渉されてもよく、したがって、再交渉が必要であり得ることを心に留めておくべきです。スピードの操作を実行するには、サーバがネットワークパスが結果のビットレートをサポートできることを確認する必要があります。このように、メディアトランスポートは、サーバが反応し、利用可能なビットレートに適応できるように、フィードバックをサポートする必要があります。"
    },
    {
      "indent": 0,
      "text": "18.51. Supported",
      "section_title": true,
      "ja": "18.51. サポートされています"
    },
    {
      "indent": 3,
      "text": "The Supported general-header enumerates all the extensions supported by the client or server using feature tags. The header carries the extensions supported by the message-sending client or server. The Supported header MAY be included in any request. When present in a request, the receiver MUST respond with its corresponding Supported header. Note that the Supported header is also included in 4xx and 5xx responses.",
      "ja": "サポートされている一般ヘッダは、機能のタグを使用して、クライアントまたはサーバーでサポートされているすべての拡張機能を列挙します。ヘッダは、メッセージ送信クライアントまたはサーバーでサポートされている拡張子を運びます。 Supportedヘッダは、任意の要求に含まれるかもしれません。存在する場合、要求に、受信機は、その対応するSupportedヘッダで応答しなければなりません。サポートされているヘッダもの4xxと5xxの応答に含まれていることに注意してください。"
    },
    {
      "indent": 3,
      "text": "The Supported header contains a list of feature tags, described in Section 4.5, that are understood by the client or server. These feature tags are the ones the server or client supports in general and are not specific to the request resource.",
      "ja": "サポートされているヘッダは、クライアントまたはサーバによって理解されている4.5節で説明した特徴タグのリストを、含まれています。これらの機能タグは、サーバーまたはクライアントが一般的にサポートしているものであり、要求リソースに固有のものではありません。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 5,
      "text": "C->S: OPTIONS rtsp://example.com/ RTSP/2.0 Supported: foo, bar, blech User-Agent: PhonyClient/1.2",
      "ja": "C-> S：OPTIONSのRTSP：RTSP / 2.0 //example.com/サポート：FOO、バー、BLECHユーザーエージェント：PhonyClient / 1.2"
    },
    {
      "indent": 5,
      "text": "S->C: RTSP/2.0 200 OK Supported: bar, blech, baz",
      "ja": "S-> C：サポートされているRTSP / 2.0 200 OK：バー、シート、バズ"
    },
    {
      "indent": 0,
      "text": "18.52. Terminate-Reason",
      "section_title": true,
      "ja": "18.52. 終了-理由"
    },
    {
      "indent": 3,
      "text": "The Terminate-Reason request-header allows the server, when sending a REDIRECT or TEARDOWN request, to provide a reason for the session termination and any additional information. This specification identifies three reasons for Redirections and may be extended in the future:",
      "ja": "セッション終了および追加情報の理由を提供するために、REDIRECT又はTEARDOWN要求を送信するときに終了-理由リクエストヘッダは、サーバーを可能にします。この仕様は、リダイレクトのための3つの理由を識別し、将来的に拡張することがあります。"
    },
    {
      "indent": 3,
      "text": "Server-Admin: The server needs to be shut down for some administrative reason.",
      "ja": "サーバー管理：サーバーは、いくつかの管理理由でシャットダウンする必要があります。"
    },
    {
      "indent": 3,
      "text": "Session-Timeout: A client's session has been kept alive for extended periods of time and the server has determined that it needs to reclaim the resources associated with this session.",
      "ja": "セッションタイムアウト：クライアントのセッションは、長時間にわたって生き続けてきたし、サーバは、このセッションに関連付けられたリソースを再利用する必要があると判断しました。"
    },
    {
      "indent": 3,
      "text": "Internal-Error An internal error that is impossible to recover from has occurred, forcing the server to terminate the session.",
      "ja": "内部エラーから回復することは不可能である内部エラーがセッションを終了するために、サーバーを強制的に、発生しました。"
    },
    {
      "indent": 3,
      "text": "The Server may provide additional parameters containing information around the redirect. This specification defines the following ones.",
      "ja": "サーバーは、リダイレクトの周りの情報を含む追加のパラメータを提供することができます。この仕様は、次のものを定義します。"
    },
    {
      "indent": 3,
      "text": "time: Provides a wallclock time when the server will stop providing any service.",
      "ja": "時間：サーバーがサービスの提供を停止します壁時計の時間を提供します。"
    },
    {
      "indent": 3,
      "text": "user-msg: A UTF-8 text string with a message from the server to the user. This message SHOULD be displayed to the user.",
      "ja": "ユーザー-MSG：サーバからユーザへのメッセージとUTF-8のテキスト文字列。このメッセージは、ユーザーに表示されるべきです。"
    },
    {
      "indent": 0,
      "text": "18.53. Timestamp",
      "section_title": true,
      "ja": "18.53. タイムスタンプ"
    },
    {
      "indent": 3,
      "text": "The Timestamp general-header describes when the agent sent the request. The value of the timestamp is of significance only to the agent and may use any timescale. The responding agent MUST echo the exact same value and MAY, if it has accurate information about this, add a floating-point number indicating the number of seconds that has elapsed since it has received the request. The timestamp can be used by the agent to compute the round-trip time to the responding agent so that it can adjust the timeout value for retransmissions when running over an unreliable protocol. It also resolves retransmission ambiguities for unreliable transport of RTSP.",
      "ja": "エージェントは、要求を送信したときにタイムスタンプ一般ヘッダが記載されています。タイムスタンプの値は、エージェントに重要であり、任意のスケールを使用してもよいです。応答側エージェントは、このに関する正確な情報を持っている場合、それは要求を受信した経過秒数を示す浮動小数点数を追加し、まったく同じ値とMAYをエコーし​​なければなりません。タイムスタンプは、信頼性の低いプロトコル上で実行している場合、それは再送信のタイムアウト値を調整することができるように応答エージェントに往復時間を計算するために、エージェントによって使用することができます。また、RTSPの信頼性の低い輸送のための再送信の曖昧さを解決します。"
    },
    {
      "indent": 3,
      "text": "Note that the present specification provides only for reliable transport of RTSP messages. The Timestamp general-header is specified in case the protocol is extended in the future to use unreliable transport.",
      "ja": "なお、本明細書は、RTSPメッセージの信頼性の輸送のためにのみ提供しています。タイムスタンプ一般ヘッダは、プロトコルは、信頼性の低いトランスポートを使用するように、将来的に拡張される場合に指定されています。"
    },
    {
      "indent": 0,
      "text": "18.54. Transport",
      "section_title": true,
      "ja": "18.54. 輸送"
    },
    {
      "indent": 3,
      "text": "The Transport general-header indicates which transport protocol is to be used and configures its parameters such as destination address, compression, multicast time-to-live and destination port for a single stream. It sets those values not already determined by a presentation description.",
      "ja": "トランスポート一般的なヘッダは、トランスポートプロトコルが使用されると、宛先アドレス、圧縮、単一ストリームのマルチキャスト時間ライブおよび宛先ポートとしてのパラメータを設定しているかを示します。これは、すでにプレゼンテーション記述によって決定されないそれらの値を設定します。"
    },
    {
      "indent": 3,
      "text": "A Transport request-header MAY contain a list of transport options acceptable to the client, in the form of multiple transport specification entries. Transport specifications are comma separated and listed in decreasing order of preference. Each transport specification consists of a transport protocol identifier, followed by any number of parameters separated by semicolons. A Transport request-header MAY contain multiple transport specifications using the same transport protocol identifier. The server MUST return a Transport response-header in the response to indicate the values actually chosen, if any. If no transport specification is supported, no transport header is returned and the response MUST use the status code 461 (Unsupported Transport) (Section 17.4.25). In case more than one transport specification was present in the request, the server MUST return the single transport specification (transport-spec) that was actually chosen, if any. The number of transport-spec entries is expected to be limited as the client will receive guidance on what configurations are possible from the presentation description.",
      "ja": "トランスポートリクエストヘッダは、複数のトランスポート仕様エントリの形で、クライアントに許容されるトランスポート・オプションのリストを含むことができます。トランスポート仕様を分離し、優先順にリストされているコンマれます。各トランスポート仕様は、セミコロンで区切られた任意の数のパラメータが続くトランスポートプロトコル識別子と、から構成されています。トランスポートリクエストヘッダは、同じトランスポート・プロトコル識別子を使用して、複数のトランスポート仕様を含むかもしれません。もしあれば、サーバは、実際に選択された値を示すために応答トランスポートの応答ヘッダを返さなければなりません。いかなる輸送仕様がサポートされていない場合、トランスポート・ヘッダが返されていないと応答は、ステータスコード461（サポートされていないトランスポート）（セクション17.4.25）を使用する必要があります。場合には、複数のトランスポート仕様が要求に存在し、サーバがあれば、実際に、選択された単一のトランスポート仕様（トランスポート仕様）を返さなければなりません。輸送スペックエントリの数は、クライアントがプレゼンテーション記述から可能であるかの設定に関するガイダンスを受けるように制限されることが期待されます。"
    },
    {
      "indent": 3,
      "text": "The Transport header MAY also be used in subsequent SETUP requests to change transport parameters. A server MAY refuse to change parameters of an existing stream.",
      "ja": "トランスポートヘッダは、トランスポートパラメータを変更するために、後続のSETUPリクエストに使用されるかもしれません。サーバーは、既存のストリームのパラメータを変更することを拒否するかもしれません。"
    },
    {
      "indent": 3,
      "text": "The transport protocol identifier defines, for each transport specification, which transport protocol to use and any related rules. Each transport protocol identifier defines the parameters that are required to occur; additional optional parameters MAY occur. This flexibility is provided as parameters may be different and provide different options to the RTSP agent. A transport specification may only contain one of any given parameter within it. A parameter consists of a name and optionally a value string. Parameters MAY be given in any order. Additionally, a transport specification may only contain either the unicast or the multicast transport type parameter. The transport protocol identifier, and all parameters, need to be understood in a transport specification; if not, the transport specification MUST be ignored. An RTSP proxy of any type that uses or modifies the transport specification, e.g., access proxy or security proxy, MUST remove specifications with unknown parameters before forwarding the RTSP message. If that results in no remaining transport specification, the proxy SHALL send a 461 (Unsupported Transport) (Section 17.4.25) response without any Transport header.",
      "ja": "トランスポート・プロトコル識別子は、トランスポートプロトコルが使用する各トランスポート仕様、および関連するルールの定義します。各トランスポート・プロトコル識別子が発生するために必要なパラメータを定義します。追加のオプションのパラメータが発生することがあります。パラメータが異なっていてもよく、RTSPエージェントに異なるオプションを提供することができるように、この柔軟性が提供されます。トランスポート仕様は、その中に任意のパラメータのいずれかを含んでいてもよいです。パラメータは、名前および必要に応じて値の文字列で構成されています。パラメータは任意の順序で与えられてもよいです。また、トランスポート仕様は、ユニキャストまたはマルチキャストトランスポート・タイプのパラメータのいずれかを含んでいてもよいです。トランスポート・プロトコル識別子、及び全てのパラメータは、トランスポート仕様で理解される必要があります。ない場合は、トランスポート仕様を無視しなければなりません。トランスポート仕様、例えば、アクセスプロキシまたはセキュリティプロキシを使用するか、または変更する任意のタイプのRTSPプロキシは、RTSPメッセージを転送する前に、未知のパラメータを持つ仕様を削除する必要があります。すなわち、NO残り輸送仕様をもたらす場合、プロキシは、任意のトランスポートヘッダーなし461（サポートされていないトランスポート）（セクション17.4.25）応答を送信しなければなりません。"
    },
    {
      "indent": 6,
      "text": "The Transport header is restricted to describing a single media stream. (RTSP can also control multiple streams as a single entity.) Making it part of RTSP rather than relying on a multitude of session description formats greatly simplifies designs of firewalls.",
      "ja": "トランスポートヘッダは、単一のメディアストリームを記述するに制限されます。 （RTSPはまた、単一のエンティティとして複数のストリームを制御することができる。）それRTSPの一部ではなく、大幅ファイアウォールの設計を簡素化し、セッション記述形式の多くに依存する作ります。"
    },
    {
      "indent": 3,
      "text": "The general syntax for the transport protocol identifier is a list of slash-separated tokens:",
      "ja": "トランスポート・プロトコル識別子の一般的な構文は、スラッシュで区切られたトークンのリストです。"
    },
    {
      "indent": 3,
      "text": "Value1/Value2/Value3...",
      "ja": "値1 /値2 / VALUE3 ..."
    },
    {
      "indent": 3,
      "text": "Which, for RTP transports, takes the form:",
      "ja": "これは、RTPトランスポートのために、形式を取ります："
    },
    {
      "indent": 3,
      "text": "RTP/profile/lower-transport.",
      "ja": "RTP /プロフィール/下輸送。"
    },
    {
      "indent": 3,
      "text": "The default value for the \"lower-transport\" parameters is specific to the profile. For RTP/AVP, the default is UDP.",
      "ja": "「低級輸送」のパラメータのデフォルト値は、プロファイルに固有のものです。 RTP / AVPの場合、デフォルトはUDPです。"
    },
    {
      "indent": 3,
      "text": "There are two different methods for how to specify where the media should be delivered for unicast transport:",
      "ja": "メディアは、ユニキャスト輸送のために配信されるように指定する方法には2つの異なる方法があります。"
    },
    {
      "indent": 3,
      "text": "dest_addr: The presence of this parameter and its values indicates the destination address or addresses (host address and port pairs for IP flows) necessary for the media transport.",
      "ja": "dest_addrは：このパラメータが存在すると、その値はメディア転送の宛先アドレスまたはアドレス（IPフローのためのホストアドレスとポートのペア）必要を示しています。"
    },
    {
      "indent": 3,
      "text": "No dest_addr: The lack of the dest_addr parameter indicates that the server MUST send media to the same address from which the RTSP messages originates.",
      "ja": "いいえdest_addrは：dest_addrはパラメータの欠如は、サーバが同じアドレスからのRTSPメッセージが発信するメディアを送信しなければならないことを示していません。"
    },
    {
      "indent": 3,
      "text": "The choice of method for indicating where the media is to be delivered depends on the use case. In some cases, the only allowed method will be to use no explicit address indication and have the server deliver media to the source of the RTSP messages.",
      "ja": "メディアが配信されるべきであることを示すための方法の選択は、ユースケースに依存します。いくつかのケースでは、唯一許さ方法は、明示的なアドレスの表示を使用しないと、サーバーがRTSPメッセージのソースにメディアを配信持つことになります。"
    },
    {
      "indent": 3,
      "text": "For multicast, there are several methods for specifying addresses, but they are different in how they work compared with unicast:",
      "ja": "マルチキャストの場合は、そこのアドレスを指定するためのいくつかの方法がありますが、彼らは、ユニキャストと比べてどのように動作するかで異なります。"
    },
    {
      "indent": 3,
      "text": "dest_addr with client picked address: The address and relevant parameters, like TTL (scope), for the actual multicast group to deliver the media to. There are security implications (Section 21) with this method that need to be addressed because an RTSP server can be used as a DoS attacker on an existing multicast group.",
      "ja": "にメディアを配信する実際のマルチキャスト・グループのために、TTL（スコープ）のように、アドレスと関連するパラメータ：クライアントとdest_addrは、アドレスを選びました。 RTSPサーバは、既存のマルチキャストグループ上のDoS攻撃として使用することができますので、対処する必要があり、この方法ではセキュリティ上の問題（セクション21）があります。"
    },
    {
      "indent": 3,
      "text": "dest_addr using Session Description Information: The information included in the transport header can all be coming from the session description, e.g., the SDP \"c=\" and \"m=\" lines. This mitigates some of the security issues of the previous methods as it is the session provider that picks the multicast group and scope. The client MUST include the information if it is available in the session description.",
      "ja": "トランスポート・ヘッダに含まれる情報は、セッション記述、例えば、SDP「C =」および「M =」の行から全て来ることができる：セッション記述情報を使用してdest_addrは。それは、マルチキャストグループと範囲を選ぶセッションプロバイダであるので、これは従来の方法のセキュリティ上の問題のいくつかを軽減します。それはセッション記述で使用可能な場合、クライアントは、情報を含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "No dest_addr: The behavior when no explicit multicast group is present in a request is not defined.",
      "ja": "いいえdest_addrはありません：明示的なマルチキャストグループが定義されていない要求に存在しない行動。"
    },
    {
      "indent": 3,
      "text": "An RTSP proxy will need to take care. If the media is not desired to be routed through the proxy, the proxy will need to introduce the destination indication.",
      "ja": "RTSPプロキシは、世話をする必要があります。メディアがプロキシ経由でルーティングされることが望まれていない場合、プロキシは、宛先表示を導入する必要があります。"
    },
    {
      "indent": 3,
      "text": "Below are the configuration parameters associated with transport:",
      "ja": "以下は、輸送に関連した設定パラメータは、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "General parameters:",
      "ja": "一般的なパラメータ："
    },
    {
      "indent": 3,
      "text": "unicast / multicast: This parameter is a mutually exclusive indication of whether unicast or multicast delivery will be attempted. One of the two values MUST be specified. Clients that are capable of handling both unicast and multicast transmission need to indicate such capability by including two full transport-specs with separate parameters for each.",
      "ja": "ユニキャスト/マルチキャスト：このパラメータは、ユニキャストまたはマルチキャスト配信が試行されるかどうかの相互に排他的な指標です。 2つの値のいずれかを指定する必要があります。ユニキャストとマルチキャストの両方の送信を処理することが可能なクライアントは、それぞれに対して別々のパラメータを有する2つの完全なトランスポート仕様を含めることにより、このような能力を示す必要があります。"
    },
    {
      "indent": 3,
      "text": "layers: The number of multicast layers to be used for this media stream. The layers are sent to consecutive addresses starting at the dest_addr address. If the parameter is not included, it defaults to a single layer.",
      "ja": "層：このメディアストリームのために使用されるマルチキャストレイヤの数。層はdest_addrはアドレスから始まる連続したアドレスに送信されます。単層へのパラメータが含まれていない場合、それがデフォルトになります。"
    },
    {
      "indent": 3,
      "text": "dest_addr: A general destination address parameter that can contain one or more address specifications. Each combination of protocol/profile/lower transport needs to have the format and interpretation of its address specification defined. For RTP/AVP/UDP and RTP/AVP/TCP, the address specification is a tuple containing a host address and port. Note, only a single destination parameter per transport spec is intended. The usage of multiple destinations to distribute a single media to multiple entities is unspecified.",
      "ja": "dest_addrは：1つの以上のアドレス指定を含めることができ、一般的な宛先アドレスパラメータ。プロトコル/プロファイルの各組み合わせ/低い輸送は、定義され、そのアドレス指定のフォーマット及び解釈を有する必要があります。 RTP / AVP / UDPおよびRTP / AVP / TCPの場合は、アドレスの指定は、ホストアドレスとポートを含むタプルです。トランスポート仕様ごとに1つだけの宛先パラメータが意図され、注意してください。複数のエンティティに単一のメディアを配布する複数の宛先の使用量が指定されていません。"
    },
    {
      "indent": 9,
      "text": "The client originating the RTSP request MAY specify the\ndestination address of the stream recipient with the host\naddress as part of the tuple.  When the destination address is\nspecified, the recipient may be a different party than the\noriginator of the request.  To avoid becoming the unwitting\nperpetrator of a remote-controlled DoS attack, a server MUST\nperform security checks (see Section 21.2.1) and SHOULD log",
      "raw": true
    },
    {
      "indent": 9,
      "text": "such attempts before allowing the client to direct a media stream to a recipient address not chosen by the server. Implementations cannot rely on TCP as a reliable means of client identification. If the server does not allow the host address part of the tuple to be set, it MUST return 463 (Destination Prohibited).",
      "ja": "クライアントがサーバによって選ばれていない受信者のアドレスにメディアストリームを指示できるようにする前に、そのような試み。実装は、クライアント識別の信頼できる手段として、TCPに頼ることはできません。サーバは、タプルのホストアドレスの一部を設定することができない場合は、463（デスティネーション禁止）を返さなければなりません。"
    },
    {
      "indent": 9,
      "text": "The host address part of the tuple MAY be empty, for example \":58044\", in cases when it is desired to specify only the destination port. Responses to requests including the Transport header with a dest_addr parameter SHOULD include the full destination address that is actually used by the server. The server MUST NOT remove address information that is already present in the request when responding, unless the protocol requires it.",
      "ja": "唯一の宛先ポートを指定することが望まれる場合のケースでは、「58044」タプルのホストアドレスの部分は、例えば、空であってもよいです。 dest_addrはパラメータを使用してトランスポート・ヘッダを含む要求に対する応答は、実際にサーバによって使用され、完全な宛先アドレスを含むべきです。プロトコルは、それを必要としない限り、サーバーは、すでに応答要求に存在しているアドレス情報を削除してはなりません。"
    },
    {
      "indent": 3,
      "text": "src_addr: A general source address parameter that can contain one or more address specifications. Each combination of protocol/profile/lower transport needs to have the format and interpretation of its address specification defined. For RTP/AVP/UDP and RTP/AVP/TCP, the address specification is a tuple containing a host address and port.",
      "ja": "src_addrを：一の以上のアドレス指定を含めることができ、一般的なソースアドレスパラメータ。プロトコル/プロファイルの各組み合わせ/低い輸送は、定義され、そのアドレス指定のフォーマット及び解釈を有する必要があります。 RTP / AVP / UDPおよびRTP / AVP / TCPの場合は、アドレスの指定は、ホストアドレスとポートを含むタプルです。"
    },
    {
      "indent": 9,
      "text": "This parameter MUST be specified by the server if it transmits\nmedia packets from an address other than the one RTSP messages\nare sent to.  This will allow the client to verify the source\naddress and give it a destination address for its RTCP feedback\npackets, if RTP is used.  The address or addresses indicated in\nthe src_addr parameter SHOULD be used both for the sending and\nreceiving of the media stream's data packets.  The main reasons\nare threefold: First, indicating the port and source address(s)\nlets the receiver know where from the packets is expected to\noriginate.  Second, traversal of NATs is greatly simplified\nwhen traffic is flowing symmetrically over a NAT binding.\nThird, certain NAT traversal mechanisms need to know to which\naddress and port to send so-called \"binding packets\" from the\nreceiver to the sender, thus creating an address binding in the\nNAT that the sender-to-receiver packet flow can use.",
      "raw": true
    },
    {
      "indent": 12,
      "text": "This information may also be available through SDP. However, since this is more a feature of transport than media initialization, the authoritative source for this information should be in the SETUP response.",
      "ja": "この情報は、SDPを介して利用することがあります。これは、より多くのメディアの初期化よりも輸送の特徴であるので、この情報の信頼できるソースは、SETUP応答であるべきです。"
    },
    {
      "indent": 3,
      "text": "mode: The mode parameter indicates the methods to be supported for this session. The currently defined valid value is \"PLAY\". If not provided, the default is \"PLAY\". The \"RECORD\" value was defined in RFC 2326; in this specification, it is unspecified but reserved. RECORD and other values may be specified in the future.",
      "ja": "モード：modeパラメータは、このセッションのためにサポートする方法を示します。現在定義されている有効な値は、「PLAY」です。提供されていない場合、デフォルトでは「PLAY」です。 「RECORD」の値は、RFC 2326で定義されました。この仕様では、それが指定されていないが、予約されています。 RECORDと他の値は将来的に指定することができます。"
    },
    {
      "indent": 3,
      "text": "interleaved: The interleaved parameter implies mixing the media stream with the control stream in whatever protocol is being used by the control stream, using the mechanism defined in Section 14. The argument provides the channel number to be used in the $ block (see Section 14) and MUST be present. This parameter MAY be specified as an interval, e.g., interleaved=4-5 in cases where the transport choice for the media stream requires it, e.g., for RTP with RTCP. The channel number given in the request is only a guidance from the client to the server on what channel number(s) to use. The server MAY set any valid channel number in the response. The declared channels are bidirectional, so both end parties MAY send data on the given channel. One example of such usage is the second channel used for RTCP, where both server and client send RTCP packets on the same channel.",
      "ja": "インターリーブ：インターリーブパラメータは、どのようなプロトコルで制御ストリームとメディアストリームがセクション14で定義されたメカニズムを使用して、制御ストリームによって使用されている引数は$ブロックで使用されるチャンネル番号を提供する（第14章を参照の混合暗示します）と存在しなければなりません。このパラメータは、RTCPとRTPのメディアストリームのトランスポート選択は、それを必要とする場合には間隔、例えば、インターリーブ= 4~5、例えば、のように指定することができます。リクエストで指定したチャンネル番号はどのようなチャネル番号（複数可）を使用することで、クライアントからサーバへの指針です。サーバが応答した任意の有効なチャンネル番号を設定することができます。宣言したチャンネルは双方向であるので、両端の当事者は、所定のチャネル上でデータを送信することができます。このような使用の一例では、サーバーとクライアントの両方が同じチャネル上にRTCPパケットを送信RTCPのために使用される第二のチャネルです。"
    },
    {
      "indent": 12,
      "text": "This allows RTP/RTCP to be handled similarly to the way that\nit is done with UDP, i.e., one channel for RTP and the other\nfor RTCP.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "MIKEY: This parameter is used in conjunction with transport specifications that can utilize MIKEY [RFC3830] for security context establishment. So far, only the SRTP-based RTP profiles SAVP and SAVPF can utilize MIKEY, and this is defined in Appendix C.1.4.1. This parameter can be included both in request and response messages. The binary MIKEY message SHALL be Base64-encoded [RFC4648] before being included in the value part of the parameter, where the encoding adheres to the definition in Section 4 of RFC 4648 and where the padding bits are set to zero.",
      "ja": "MIKEY：このパラメータは、セキュリティコンテキストの確立のためMIKEY [RFC3830]を利用することができるトランスポート仕様と併せて使用されます。これまでのところ、唯一のSRTPベースのRTPプロファイルSAVPとSAVPFはMIKEYを利用することができ、これは、付録C.1.4.1で定義されています。このパラメータは、要求メッセージと応答メッセージの両方に含めることができます。バイナリMIKEYメッセージは符号化がパディングビットがゼロに設定されているRFC 4648のセクション4で定義に付着したパラメータの値の一部に含まれる前に[RFC4648]をBase64エンコードされなければなりません。"
    },
    {
      "indent": 3,
      "text": "Multicast-specific:",
      "ja": "マルチキャスト固有："
    },
    {
      "indent": 3,
      "text": "ttl: multicast time-to-live for IPv4. When included in requests, the value indicates the TTL value that the client requests the server to use. In a response, the value actually being used by the server is returned. A server will need to consider what values that are reasonable and also the authority of the user to set this value. Corresponding functions are not needed for IPv6 as the scoping is part of the IPv6 multicast address [RFC4291].",
      "ja": "TTL：マルチキャスト生存時間IPv4の。リクエストに含まれる場合、値は、クライアントがサーバーを使用するように要求したTTLの値を示しています。応答では、実際にサーバによって使用されている値が返されます。サーバーは合理的であり、また、ユーザの権限は、この値を設定するためにどのような値を考慮する必要があります。スコープは、[RFC4291]をマルチキャストアドレスのIPv6の一部であるとして対応する機能は、IPv6のために必要とされません。"
    },
    {
      "indent": 3,
      "text": "RTP-specific:",
      "ja": "RTP固有："
    },
    {
      "indent": 3,
      "text": "These parameters MAY only be used if the media-transport protocol is RTP.",
      "ja": "メディア・トランスポート・プロトコルがRTPであれば、これらのパラメータにのみ使用されるかもしれません。"
    },
    {
      "indent": 3,
      "text": "ssrc: The ssrc parameter, if included in a SETUP response, indicates the RTP SSRC [RFC3550] value(s) that will be used by the media server for RTP packets within the stream. The values are expressed as a slash-separated sequence of SSRC values, each SSRC expressed as an eight-digit hexadecimal value.",
      "ja": "SSRC：SSRCパラメータは、SETUP応答に含まれている場合、ストリーム内のRTPパケット用メディアサーバによって使用されるRTP SSRC [RFC3550]の値（S）を示します。値はSSRC値のスラッシュで区切られた配列として表され、各SSRCは、8桁の16進数として表現しました。"
    },
    {
      "indent": 9,
      "text": "The ssrc parameter MUST NOT be specified in requests.  The\nfunctionality of specifying the ssrc parameter in a SETUP\nrequest is deprecated as it is incompatible with the\nspecification of RTP [RFC3550].  If the parameter is included\nin the Transport header of a SETUP request, the server SHOULD\nignore it, and choose appropriate SSRCs for the stream.  The\nserver SHOULD set the ssrc parameter in the Transport header of\nthe response.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "RTCP-mux: Used to negotiate the usage of RTP and RTCP multiplexing [RFC5761] on a single underlying transport stream/flow. The presence of this parameter in a SETUP request indicates the client's support and requires the server to use RTP and RTCP multiplexing. The client SHALL only include one transport stream in the Transport header specification. To provide the server with a choice between using RTP/RTCP multiplexing or not, two different transport header specifications must be included.",
      "ja": "RTCP-MUX：単一の基礎となるトランスポートストリーム/フローにRTP及びRTCP多重[RFC5761]の使用を交渉するために使用されます。 SETUPリクエストでこのパラメータの存在は、クライアントのサポートを示し、RTPとRTCPの多重化を使用するようにサーバーを必要とします。クライアントは、トランスポートヘッダ仕様で1つのトランスポートストリームを含むものとします。 RTP / RTCPの多重化を使用するかしないかの選択を使用してサーバーを提供するために、二つの異なるトランスポートヘッダ仕様が含まれていなければなりません。"
    },
    {
      "indent": 3,
      "text": "The parameter setup and connection defined below MAY only be used if the media-transport protocol of the lower-level transport is connection oriented (such as TCP). However, these parameters MUST NOT be used when interleaving data over the RTSP connection.",
      "ja": "下位のトランスポートのメディアトランスポートプロトコル接続（例えばTCPのような）に配向されている場合、以下に定義されたパラメータ設定との接続にのみ使用されるかもしれません。 RTSP接続を介してデータをインターリーブする場合ただし、これらのパラメータを使用してはいけません。"
    },
    {
      "indent": 3,
      "text": "setup: Clients use the setup parameter on the Transport line in a SETUP request to indicate the roles it wishes to play in a TCP connection. This parameter is adapted from [RFC4145]. The use of this parameter in RTP/AVP/TCP non-interleaved transport is discussed in Appendix C.2.2; the discussion below is limited to syntactic issues. Clients may specify the following values for the setup parameter:",
      "ja": "セットアップ：クライアントは、それがTCP接続でプレーしたい役割を示すために、SETUP要求に搬送ライン上の設定パラメータを使用します。このパラメータは、[RFC4145]から適合されています。 RTP / AVP / TCP非インターリーブ輸送におけるこのパラメータの使用は、付録C.2.2に議論されています。以下の議論は、構文上の問題に限定されています。クライアントは、セットアップパラメータに次の値を指定できます。"
    },
    {
      "indent": 9,
      "text": "active: The client will initiate an outgoing connection.",
      "ja": "アクティブ：クライアントが発信接続を開始します。"
    },
    {
      "indent": 9,
      "text": "passive: The client will accept an incoming connection.",
      "ja": "パッシブ：クライアントは、着信接続を受け入れます。"
    },
    {
      "indent": 9,
      "text": "actpass: The client is willing to accept an incoming connection or to initiate an outgoing connection.",
      "ja": "actpass：クライアントは、着信接続を受け入れるまたは発信接続を開始する用意があります。"
    },
    {
      "indent": 9,
      "text": "If a client does not specify a setup value, the \"active\" value is assumed.",
      "ja": "クライアントが設定値を指定しない場合は、「アクティブ」の値が想定されます。"
    },
    {
      "indent": 9,
      "text": "In response to a client SETUP request where the setup parameter is set to \"active\", a server's 2xx reply MUST assign the setup parameter to \"passive\" on the Transport header line.",
      "ja": "セットアップパラメータが「アクティブ」に設定されているクライアントのSETUPの要求に応じて、サーバーのの2xx応答はトランスポートヘッダ行のセットアップパラメータに「受動的」に割り当てる必要があります。"
    },
    {
      "indent": 9,
      "text": "In response to a client SETUP request where the setup parameter is set to \"passive\", a server's 2xx reply MUST assign the setup parameter to \"active\" on the Transport header line.",
      "ja": "セットアップパラメータが「受動的」に設定されているクライアントのSETUPの要求に応じて、サーバーのの2xx応答はトランスポートヘッダ行に設定パラメータを「アクティブ」を割り当てる必要があります。"
    },
    {
      "indent": 9,
      "text": "In response to a client SETUP request where the setup parameter is set to \"actpass\", a server's 2xx reply MUST assign the setup parameter to \"active\" or \"passive\" on the Transport header line.",
      "ja": "セットアップパラメータは「actpass」に設定されているクライアントのSETUP要求に応答して、サーバのの2xx応答はトランスポートヘッダライン上に「アクティブ」または「受動的」セットアップパラメータを割り当てる必要があります。"
    },
    {
      "indent": 9,
      "text": "Note that the \"holdconn\" value for setup is not defined for RTSP use, and MUST NOT appear on a Transport line.",
      "ja": "セットアップのための「holdconn」値がRTSPを使用するために定義されておらず、搬送ライン上に表示されてはならないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "connection: Clients use the connection parameter in a transport specification part of the Transport header in a SETUP request to indicate the client's preference for either reusing an existing connection between client and server (in which case the client sets the \"connection\" parameter to \"existing\") or requesting the creation of a new connection between client and server (in which cast the client sets the \"connection\" parameter to \"new\"). Typically, clients use the \"new\" value for the first SETUP request for a URL, and \"existing\" for subsequent SETUP requests for a URL.",
      "ja": "接続：クライアントは、クライアントとサーバとの間の既存の接続を再利用するいずれかのクライアントの好みを示すために、SETUP要求にトランスポートヘッダのトランスポート仕様部に接続パラメータを使用して（クライアントが「存在する「接続」パラメータを設定する場合『新しい『にパラメータ』接続「）またはクライアントをキャストしているクライアントとサーバ間（新しい接続の作成を要求するには、設定されます』）。一般的に、クライアントはURLの最初のSETUP要求のための「新しい」値を使用して、URLに対する後続SETUP要求に対して、「既存します」。"
    },
    {
      "indent": 9,
      "text": "If a client SETUP request assigns the \"new\" value to\n\"connection\", the server response MUST also assign the \"new\"\nvalue to \"connection\" on the Transport line.",
      "raw": true
    },
    {
      "indent": 9,
      "text": "If a client SETUP request assigns the \"existing\" value to \"connection\", the server response MUST assign a value of \"existing\" or \"new\" to \"connection\" on the Transport line, at its discretion.",
      "ja": "クライアントSETUP要求は、「接続」と「既存の」値を割り当てた場合は、サーバの応答は、その裁量で、搬送ライン上の「接続」に「既存」または「新しい」の値を割り当てる必要があります。"
    },
    {
      "indent": 9,
      "text": "The default value of \"connection\" is \"existing\", for all SETUP requests (initial and subsequent).",
      "ja": "「接続」のデフォルト値は、すべてのSETUP要求（初期およびそれ以降）のために、「既存」されます。"
    },
    {
      "indent": 3,
      "text": "The combination of transport protocol, profile and lower transport needs to be defined. A number of combinations are defined in the Appendix C.",
      "ja": "トランスポート・プロトコル、プロファイル及び下部搬送の組み合わせを定義する必要があります。組み合わせの数は、付録Cに定義されています"
    },
    {
      "indent": 3,
      "text": "Below is a usage example, showing a client advertising the capability to handle multicast or unicast, preferring multicast. Since this is a unicast-only stream, the server responds with the proper transport parameters for unicast.",
      "ja": "以下は、マルチキャストを好む、マルチキャストまたはユニキャストを処理する機能を広告するクライアントを示す、使用例です。これは、ユニキャストストリームのみであるので、サーバは、ユニキャストのための適切なトランスポートパラメータで応答します。"
    },
    {
      "indent": 5,
      "text": "C->S: SETUP rtsp://example.com/foo/bar/baz.rm RTSP/2.0 CSeq: 302 Transport: RTP/AVP;multicast;mode=\"PLAY\", RTP/AVP;unicast;dest_addr=\"192.0.2.5:3456\"/ \"192.0.2.5:3457\";mode=\"PLAY\" Accept-Ranges: npt, smpte, clock User-Agent: PhonyClient/1.2",
      "ja": "C-> S：SETUP RTSP：//example.com/foo/bar/baz.rm RTSP / 2.0のCSeq：302トランスポート：RTP / AVP;マルチキャスト;モード= \"PLAY\"、RTP / AVP;ユニキャスト; dest_addrは=」 192.0.2.5:3456\"/ \"192.0.2.5:3457\";mode=\"PLAY\" のAccept-範囲：NPT、SMPTE、クロックのUser-Agent：PhonyClient / 1.2"
    },
    {
      "indent": 5,
      "text": "S->C: RTSP/2.0 200 OK CSeq: 302 Date: Fri, 20 Dec 2013 10:20:32 +0000 Session: rQi1hBrGlFdiYld241FxUO Transport: RTP/AVP;unicast;dest_addr=\"192.0.2.5:3456\"/ \"192.0.2.5:3457\";src_addr=\"192.0.2.224:6256\"/ \"192.0.2.224:6257\";mode=\"PLAY\" Accept-Ranges: npt Media-Properties: Random-Access=0.6, Dynamic, Time-Limited=20081128T165900",
      "ja": "S-> C：RTSP / 2.0 200 OKのCSeq：302日付：金、2013年12月20日午前10時20分32秒+0000セッション：rQi1hBrGlFdiYld241FxUOトランスポート：RTP / AVP;ユニキャスト; dest_addrは= \"192.0.2.5:3456\" /「192.0 3457 \"; src_addrを=\" 192.0.2.224:6256\" / \"192.0.2.224:6257\";mode=\"PLAYは\"-範囲を受け入れます：.2.5 NPTメディア・プロパティ：ランダム・アクセス= 0.6、ダイナミックに、期間限定= 20081128T165900"
    },
    {
      "indent": 0,
      "text": "18.55. Unsupported",
      "section_title": true,
      "ja": "18.55. 非対応"
    },
    {
      "indent": 3,
      "text": "The Unsupported response-header lists the features not supported by the responding RTSP agent. In the case where the feature was specified via the Proxy-Require field (Section 18.37), if there is a proxy on the path between the client and the server, the proxy MUST send a response message with a status code of 551 (Option Not Supported). The request MUST NOT be forwarded.",
      "ja": "サポートされていないレスポンス・ヘッダーは、応答RTSPエージェントによってサポートされていない機能を示します。特徴は、プロキシ要求フィールド（セクション18.37）を介して、指定された場合には、クライアントとサーバとの間のパス上のプロキシが存在する場合、プロキシは（551のステータスコードをオプション応答メッセージを送らなければなりませんていませんサポートされています）。要求が転送されてはなりません。"
    },
    {
      "indent": 3,
      "text": "See Section 18.43 for a usage example.",
      "ja": "使用例については、セクション18.43を参照してください。"
    },
    {
      "indent": 0,
      "text": "18.56. User-Agent",
      "section_title": true,
      "ja": "18.56. ユーザーエージェント"
    },
    {
      "indent": 3,
      "text": "The User-Agent general-header field contains information about the user agent originating the request or producing a response. This is for statistical purposes, the tracing of protocol violations, and automated recognition of user agents for the sake of tailoring responses to avoid particular user agent limitations. User agents SHOULD include this field with requests. The field can contain multiple product tokens and comments identifying the agent and any subproducts which form a significant part of the user agent. By convention, the product tokens are listed in order of their significance for identifying the application.",
      "ja": "ユーザーエージェントの一般的なヘッダフィールドは、ユーザエージェント要求を発信または応答を産生に関する情報が含まれています。これは、統計目的、プロトコル違反の追跡、および特定のユーザエージェントの制限を回避するために応答を調整するためにユーザエージェントの自動化された認識のためです。ユーザエージェントはリクエストにこのフィールドを含むべきです。フィールドは、エージェントとユーザエージェントの重要な部分を形成する任意のサブプロダクトを識別する複数の製品トークンおよびコメントを含むことができます。慣例により、製品トークンはアプリケーションを識別するためのその重要性の順に記載されています。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 3,
      "text": "User-Agent: PhonyClient/1.2",
      "ja": "User-Agent：PhonyClient / 1.2"
    },
    {
      "indent": 0,
      "text": "18.57. Via",
      "section_title": true,
      "ja": "18.57. 経由"
    },
    {
      "indent": 3,
      "text": "The Via general-header field MUST be used by proxies to indicate the intermediate protocols and recipients between the user agent and the server on requests and between the origin server and the client on responses. The field is intended to be used for tracking message forwards, avoiding request loops, and identifying the protocol capabilities of all senders along the request/response chain.",
      "ja": "経由一般ヘッダフィールドは、ユーザエージェントや要望にとオリジンサーバと応答上のクライアント間のサーバーの間の中間プロトコルと受信者を示すためにプロキシによって使用されなければなりません。フィールドは、転送メッセージを追跡要求ループを回避し、そして要求/応答チェーンに沿ってすべての送信者のプロトコル能力を識別するために使用されることが意図されます。"
    },
    {
      "indent": 3,
      "text": "Each of multiple values in the Via field represents each proxy that has forwarded the message. Each recipient MUST append its information such that the end result is ordered according to the sequence of forwarding applications. So messages originating with the client or server do not include the Via header. The first proxy or other intermediate adds the header and its information into the field. Any additional intermediate adds additional field-values. Resulting in the server seeing the chains of intermediates in a client-to-server request and the client seeing the full chain in the response message.",
      "ja": "Viaフィールド内の複数の値のそれぞれは、メッセージを転送した各プロキシを表します。各受信者は、最終的な結果は、転送アプリケーションの順序に従って順序付けされるように、その情報を追加しなければなりません。だから、クライアントまたはサーバに送信されたメッセージは、Viaヘッダーが含まれていません。最初のプロキシまたは他の中間体は、ヘッダフィールドにその情報を追加します。任意の追加の中間には、追加のフィールド値を追加します。クライアントからサーバへの要求と応答メッセージでフルチェーンを見て、クライアントに中間体のチェーンを見て、サーバーに結果。"
    },
    {
      "indent": 3,
      "text": "Proxies (e.g., Access Proxy or Translator Proxy) SHOULD NOT, by default, forward the names and ports of hosts within the private/ protected region. This information SHOULD only be propagated if explicitly enabled. If not enabled, the via-received of any host behind the firewall/NAT SHOULD be replaced by an appropriate pseudonym for that host.",
      "ja": "プロキシ（例えば、アクセスプロキシまたは翻訳プロキシ）は、デフォルトでは、プライベート/保護された領域内のホストの名前とポートを転送すべきではありません。明示的に有効にした場合、この情報にのみ伝搬されるべきです。有効でない場合は、経由して、受信ファイアウォール/ NATの背後にある任意のホストのは、そのホストのための適切なペンネームで交換する必要があります。"
    },
    {
      "indent": 3,
      "text": "For organizations that have strong privacy requirements for hiding internal structures, a proxy MAY combine an ordered subsequence of Via header field entries with identical sent-protocol values into a single such entry. Applications MUST NOT combine entries that have different received-protocol values.",
      "ja": "内部構造を隠蔽するための強力なプライバシー要件を持っている組織では、プロキシは、そのような単一のエントリに同じ送られたプロトコル値を持つViaヘッダーフィールドエントリの順序付きサブシーケンスを組み合わせることができます。アプリケーションは、異なる受信プロトコル値を持つエントリを組み合わせてはなりません。"
    },
    {
      "indent": 0,
      "text": "18.58. WWW-Authenticate",
      "section_title": true,
      "ja": "18.58.  WWW認証"
    },
    {
      "indent": 3,
      "text": "The WWW-Authenticate header is specified in [RFC7235]; its usage depends on the used authentication schemes, such as Digest [RFC7616] and Basic [RFC7617]. The WWW-Authenticate response-header field MUST be included in 401 (Unauthorized) response messages. The field-value consists of at least one challenge that indicates the authentication scheme(s) and parameters applicable to the Request-URI. This header MUST only be used in response messages related to client to server requests.",
      "ja": "WWW-Authenticateヘッダは、[RFC7235]で指定されています。その使用は、ダイジェスト[RFC7616]と基本[RFC7617]として使用されている認証方式に依存します。 WWW認証応答ヘッダフィールドは401（不正な）応答メッセージに含まれなければなりません。フィールド値は、Request-URIに適用可能な認証方式（S）とパラメータを示す少なくとも一つのチャレンジから成ります。このヘッダーは、サーバー要求にクライアントに関連した応答メッセージに使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The HTTP access authentication process is described in [RFC7235] with some clarification in Section 19.1. User agents are advised to take special care in parsing the WWW-Authenticate field-value as it might contain more than one challenge, or if more than one WWW-Authenticate header field is provided, the contents of a challenge itself can contain a comma-separated list of authentication parameters.",
      "ja": "HTTPアクセス認証プロセスは、セクション19.1において、いくつかの明確化と[RFC7235]に記載されています。それは、複数の課題が含まれている可能性がある、または複数のWWW-Authenticateヘッダフィールドが用意されている場合、挑戦自体の内容はカンマを含めることができるよう、ユーザーエージェントは、WWW認証フィールド値を解析するには、特別な注意を払うことをお勧めします認証パラメータのリストを分離しました。"
    },
    {
      "indent": 0,
      "text": "19. Security Framework",
      "section_title": true,
      "ja": "19.セキュリティ・フレームワーク"
    },
    {
      "indent": 3,
      "text": "The RTSP security framework consists of two high-level components: the pure authentication mechanisms based on HTTP authentication and the message transport protection based on TLS, which is independent of RTSP. Because of the similarity in syntax and usage between RTSP servers and HTTP servers, the security for HTTP is reused to a large extent.",
      "ja": "HTTP認証とRTSPとは無関係であるTLSに基づいて、メッセージ・トランスポート・保護に基づいて、純粋な認証メカニズム：RTSPセキュリティフレームワークは、二つの高レベルのコンポーネントで構成されています。そのためRTSPサーバとHTTPサーバ間の構文および使用方法の類似性のため、HTTPのセキュリティを大幅に再利用されます。"
    },
    {
      "indent": 0,
      "text": "19.1. RTSP and HTTP Authentication",
      "section_title": true,
      "ja": "19.1.  RTSPとHTTP認証"
    },
    {
      "indent": 3,
      "text": "RTSP and HTTP share common authentication schemes; thus, they follow the same framework as specified in [RFC7235]. RTSP uses the corresponding RTSP error codes (401 and 407) and headers (WWW-Authenticate, Authorization, Proxy-Authenticate, Proxy-Authorization) by importing the definitions from [RFC7235]. Servers SHOULD implement both the Basic [RFC7617] and the Digest [RFC7616] authentication schemes. Clients MUST implement both the Basic and the Digest authentication schemes so that a server that requires the client to authenticate can trust that the capability is present. If implementing the Digest authentication scheme, then the additional considerations specified below in Section 19.1.1 MUST be followed.",
      "ja": "RTSPやHTTP共通の認証方式。 [RFC7235]で指定されるように、したがって、それらは同じフレームワークに従います。 RTSPは、[RFC7235]の定義をインポートすることにより、対応するRTSPエラーコード（401及び407）とヘッダ（WWW認証、認可、プロキシ認証、プロキシ認証）を使用します。サーバは基本[RFC7617]とダイジェスト[RFC7616]認証方式の両方を実装する必要があります。認証するようにクライアントを必要とするサーバーは、機能が存在していることを信頼できるように、クライアントは基本とダイジェスト認証方式の両方を実装しなければなりません。ダイジェスト認証スキームを実装する場合は、セクション19.1.1で以下に指定の追加の考慮事項に従わなければなりません。"
    },
    {
      "indent": 3,
      "text": "It should be stressed that using the HTTP authentication alone does not provide full RTSP message security. Therefore, TLS SHOULD be used; see Section 19.2. Any RTSP message containing an Authorization header using the Basic authentication scheme MUST be using a TLS connection with confidentiality protection enabled, i.e., no NULL encryption.",
      "ja": "それだけではHTTP認証を使用すると、完全なRTSPメッセージのセキュリティを提供しないことを強調しなければなりません。したがって、TLSが使用されるべきです。セクション19.2を参照してください。機密保護機能を備えたTLS接続を使用しなければならない基本的な認証スキームを使用して、Authorizationヘッダを含む任意のRTSPメッセージは、即ち、ヌル暗号化を可能にしません。"
    },
    {
      "indent": 3,
      "text": "In cases where there is a chain of proxies between the client and the server, each proxy may individually request the client or previous proxy to authenticate itself. This is done using the Proxy-Authenticate (Section 18.34), the Proxy-Authorization (Section 18.36), and the Proxy-Authentication-Info (Section 18.35) headers. These headers are hop-by-hop headers and are only scoped to the current connection and hop. Thus, if a proxy chain exists, a proxy connecting to another proxy will have to act as a client to authorize itself towards the next proxy. The WWW-Authenticate (Section 18.58), Authorization (Section 18.8), and Authentication-Info (Section 18.7) headers are end-to-end and MUST NOT be modified by proxies.",
      "ja": "クライアントとサーバとの間のプロキシの鎖が存在する場合には、各プロキシは、個々に自身を認証するためにクライアントまたは以前のプロキシを要求することができます。これは、プロキシ認証（セクション18.34）、プロキシ認証（セクション18.36）、およびプロキシ認証-INFO（セクション18.35）ヘッダーを使用して行われます。これらのヘッダーは、ホップバイホップヘッダであり、唯一の現在の接続とホップにスコープされています。プロキシチェーンが存在する場合はこのように、別のプロキシに接続するプロキシは、次のプロキシに向けて自分自身を認証するために、クライアントとして動作する必要があります。 WWW認証（セクション18.58）、認可（セクション18.8）、および認証-INFO（セクション18.7）ヘッダは、エンドツーエンドであり、プロキシによって改変されてはいけません。"
    },
    {
      "indent": 3,
      "text": "This authentication mechanism works only for client-to-server requests as currently defined. This leaves server-to-client request outside of the context of TLS-based communication more vulnerable to message-injection attacks on the client. Based on the server-to-client methods that exist, the potential risks are various: hijacking (REDIRECT), denial of service (TEARDOWN and PLAY_NOTIFY), or attacks with uncertain results (SET_PARAMETER).",
      "ja": "現在定義されているように、この認証メカニズムは、クライアントからサーバーへのリクエストに対してのみ機能します。これは、クライアント上のメッセージ・インジェクション攻撃に対してより脆弱TLSベースの通信のコンテキストの外部にあるサーバーからクライアントへのリクエストを残します。存在し、サーバからクライアントへの方法に基づき、潜在的なリスクは様々です：ハイジャック（REDIRECT）、サービス拒否（TEARDOWNとPLAY_NOTIFY）、または不確実な結果（SET_PARAMETER）で攻撃。"
    },
    {
      "indent": 0,
      "text": "19.1.1. Digest Authentication",
      "section_title": true,
      "ja": "19.1.1. ダイジェスト認証"
    },
    {
      "indent": 3,
      "text": "This section describes the modifications and clarifications required to apply the HTTP Digest authentication scheme to RTSP. The RTSP scheme usage is almost completely identical to that for HTTP [RFC7616]. These modifications are based on the procedures defined for SIP 2.0 [RFC3261] (in Section 22.4) but updated to use RFC 7235, RFC 7616 and RFC 7615 instead of RFC 2617.",
      "ja": "このセクションでは、RTSPにHTTPダイジェスト認証方式を適用するために必要な修正および明確化を記載しています。 RTSPスキームの使用は、HTTP [RFC7616]の場合とほぼ完全に同一です。これらの修飾は（セクション22.4で）SIP 2.0 [RFC3261]のために定義された手順に基づいているが、RFC 7235、RFC 7616及びRFC 2617代わりのRFC 7615を使用するように更新されます。"
    },
    {
      "indent": 3,
      "text": "Digest authentication uses two additional headers, Authentication-Info and Proxy-Authentication-Info, that are defined as in [RFC7615]. The rules for Digest authentication follow those defined in [RFC7616], with \"HTTP/1.1\" replaced by \"RTSP/2.0\" in addition to the following differences:",
      "ja": "ダイジェスト認証は、[RFC7615]のように定義されている2つの追加ヘッダ、認証、情報およびプロキシ認証-INFOを使用します。ダイジェスト認証のためのルールは、次の相違点に加えて、「RTSP / 2.0」に置き換え、「HTTP / 1.1」と、[RFC7616]で定義されたものに従います。"
    },
    {
      "indent": 3,
      "text": "1. Use the ABNF specified in the referenced documents, with the difference that the URI parameter uses the request URI format for RTSP, i.e. the ABNF element: Request-URI (see Section 20.2.1). The domain parameter uses the RTSP-URI-Ref element for absolute and relative URIs.",
      "ja": "1. URIパラメータ、すなわちABNF要素RTSP要求URI形式、使用する差で、参照文書で指定されたABNF：のRequest-URIを（20.2.1項を参照）。ドメインパラメータは、絶対的および相対URIのRTSP-URI-REF要素を使用します。"
    },
    {
      "indent": 3,
      "text": "2. If MTags are used, then the example procedure for choosing a nonce based on ETag can work, based on replacing the ETag with the MTag.",
      "ja": "2. MTagsが使用される場合、次いでMTAGとのETagを交換に基づいて、動作することができたETagに基づいてnonceを選択するための手順例。"
    },
    {
      "indent": 3,
      "text": "3. As a clarification to the calculation of the A2 value for message integrity assurance in the Digest authentication scheme, implementers should assume, when the entity-body is empty (that is, when the RTSP messages have no message body) that the hash of the message body resolves to the hash of an empty string, or: H(entity-body), example MD5(\"\") = \"d41d8cd98f00b204e9800998ecf8427e\".",
      "ja": "3.ダイジェスト認証方式におけるメッセージ完全性保証のためのA2値の算出に明確化されるように、実装はエンティティボディが空のとき、と仮定すべきであるが、（RTSPメッセージがメッセージ・ボディを有していない場合には、である）のハッシュその例えばMD5（「」）=「d41d8cd98f00b204e9800998ecf8427e」、H（エンティティボディ）：メッセージ本文は、空の文字列のハッシュに解決、又は。"
    },
    {
      "indent": 0,
      "text": "19.2. RTSP over TLS",
      "section_title": true,
      "ja": "19.2.  TLSオーバーRTSP"
    },
    {
      "indent": 3,
      "text": "RTSP agents MUST implement RTSP over TLS as defined in this section and the next Section 19.3. RTSP MUST follow the same guidelines with regard to TLS [RFC5246] usage as specified for HTTP; see [RFC2818]. RTSP over TLS is separated from unsecured RTSP both on the URI level and the port level. Instead of using the \"rtsp\" scheme identifier in the URI, the \"rtsps\" scheme identifier MUST be used to signal RTSP over TLS. If no port is given in a URI with the \"rtsps\" scheme, port 322 MUST be used for TLS over TCP/IP.",
      "ja": "このセクションと次のセクション19.3で定義されるようにRTSP剤は、TLS上RTSPを実装しなければなりません。 RTSPは、HTTPのために指定されるようにTLS [RFC5246]用法に関して同じガイドラインに従わなければなりません。 [RFC2818]を参照してください。 TLS上RTSPは、URIレベルおよびポートレベルの両方で保護されていないRTSPから分離されます。代わりに、URI中の「RTSP」スキーム識別子を使用しての、「RTSPS」方式識別子は、TLS上RTSPを知らせるために使用されなければなりません。ポートが「RTSPS」スキームとURIに指定されていない場合、ポート322は、TCP / IP上でTLSを使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "When a client tries to set up an insecure channel to the server (using the \"rtsp\" URI), and the policy for the resource requires a secure channel, the server MUST redirect the client to the secure service by sending a 301 redirect response code together with the correct Location URI (using the \"rtsps\" scheme). A user or client MAY upgrade a non secured URI to a secured by changing the scheme from \"rtsp\" to \"rtsps\". A server implementing support for \"rtsps\" MUST allow this.",
      "ja": "クライアントがサーバに安全でないチャネルを設定しようとすると（「RTSP」URIを使用して）、及びリソースのポリシーは、セキュリティで保護されたチャネルを必要とする、サーバ301は、リダイレクトレスポンスコードを送信することにより、セキュアなサービスにクライアントをリダイレクトしなければなりません一緒に正しい場所（「RTSPS」スキームを使用して）URIを持ちます。ユーザーやクライアントが「RTSPS」に「RTSP」からスキ​​ームを変更することにより、確保に非確保URIをアップグレードすることができます。 「RTSPS」のサポートを実装するサーバはこれを許可しなければなりません。"
    },
    {
      "indent": 3,
      "text": "It should be noted that TLS allows for mutual authentication (when using both server and client certificates). Still, one of the more common ways TLS is used is to provide only server-side authentication (often to avoid client certificates). TLS is then used in addition to HTTP authentication, providing transport security and server authentication, while HTTP Authentication is used to authenticate the client.",
      "ja": "TLSは、（サーバーおよびクライアント証明書の両方を使用して）相互認証を可能にすることに注意すべきです。それでも、TLSが使用され、より一般的な方法の一つは、（クライアント証明書を避けるために、多くの場合）のみ、サーバー側の認証を提供することです。 HTTP認証は、クライアントを認証するために使用されている間、TLSは、その後、トランスポート・セキュリティおよびサーバー認証を提供し、HTTP認証に加えて使用されます。"
    },
    {
      "indent": 3,
      "text": "RTSP includes the possibility to keep a TCP session up between the client and server, throughout the RTSP session lifetime. It may be convenient to keep the TCP session, not only to save the extra setup time for TCP, but also the extra setup time for TLS (even if TLS uses the resume function, there will be almost two extra round trips). Still, when TLS is used, such behavior introduces extra active state in the server, not only for TCP and RTSP, but also for TLS. This may increase the vulnerability to DoS attacks.",
      "ja": "RTSPは、RTSPセッション生涯を通じて、クライアントとサーバの間でTCPセッションを維持する可能性を含んでいます。 TCPセッションを維持するために便利かもしれTCPのための余分なセットアップ時間を節約するためだけでなく、TLSのための余分なセットアップ時間（TLSは、レジューム機能を使用している場合でも、ほとんど2つの余分なラウンドトリップがあるでしょう）。それでも、TLSを使用する場合、そのような行動は、TCPおよびRTSPのためでなく、TLSのためだけではなく、サーバーに余分なアクティブ状態を紹介します。これはDoS攻撃に対する脆弱性を増大させることができます。"
    },
    {
      "indent": 3,
      "text": "There exists a potential security vulnerability when reusing TCP and TLS state for different resources (URIs). If two different hostnames point at the same IP address, it can be desirable to reuse the TCP/ TLS connection to that server. In that case, the RTSP agent having the TCP/TLS connection MUST verify that the server certificate associated with the connection has a SubjectAltName matching the hostname present in the URI for the resource an RTSP request is to be issued.",
      "ja": "異なるリソース（URIの）のためのTCPおよびTLSの状態を再利用する際に潜在的なセキュリティの脆弱性が存在します。二つの異なるホスト名が同じIPアドレスを指している場合、そのサーバーへのTCP / TLS接続を再利用することが望ましいです。その場合には、TCP / TLS接続を有するRTSPエージェントは、接続に関連付けられたサーバ証明書がRTSP要求を発行するリソースのURIにおけるホスト名の存在と一致するのSubjectAltNameを有していることを確かめなければなりません。"
    },
    {
      "indent": 3,
      "text": "In addition to these recommendations, Section 19.3 gives further recommendations of TLS usage with proxies.",
      "ja": "これらの推奨事項に加えて、セクション19.3は、プロキシとのTLSの使用の更なる推奨事項を示します。"
    },
    {
      "indent": 0,
      "text": "19.3. Security and Proxies",
      "section_title": true,
      "ja": "19.3. セキュリティとプロキシ"
    },
    {
      "indent": 3,
      "text": "The nature of a proxy is often to act as a \"man in the middle\", while security is often about preventing the existence of one. This section provides clients with the possibility to use proxies even when applying secure transports (TLS) between the RTSP agents. The TLS proxy mechanism allows for server and proxy identification using certificates. However, the client cannot be identified based on certificates. The client needs to select between using the procedure specified below or using a TLS connection directly (bypassing any proxies) to the server. The choice may be dependent on policies.",
      "ja": "セキュリティは、1の存在を防止することについては、多くの場合である一方で、プロキシの性質は、「中間者」として行動することが多いです。このセクションでは、RTSPエージェントとの間の安全なトランスポート（TLS）を適用する場合でも、プロキシを使用する可能性を顧客に提供します。 TLSプロキシ機構は、証明書を使用してサーバとプロキシの識別を可能にします。ただし、クライアント証明書に基づいて識別することはできません。クライアントは、サーバに（任意のプロキシをバイパスして）以下の指定された手順を使用して、または直接TLS接続を使用しての間で選択する必要があります。選択は、ポリシーに依存することができます。"
    },
    {
      "indent": 3,
      "text": "In general, there are two categories of proxies: the transparent proxies (of which the client is not aware) and the non-transparent proxies (of which the client is aware). This memo specifies only non-transparent RTSP proxies, i.e., proxies visible to the RTSP client and RTSP server. An infrastructure based on proxies requires that the trust model be such that both client and server can trust the proxies to handle the RTSP messages correctly. To be able to trust a proxy, the client and server also need to be aware of the proxy. Hence, transparent proxies cannot generally be seen as trusted and will not work well with security (unless they work only at the transport layer). In the rest of this section, any reference to \"proxy\" will be to a non-transparent proxy, which inspects or manipulates the RTSP messages.",
      "ja": "透明プロキシ（そのクライアントが認識していない）と非透過プロキシ（そのクライアントが認識している）：一般的には、プロキシの2つのカテゴリがあります。このメモは唯一の非透明RTSPプロキシを指定し、RTSPクライアントとRTSPサーバに見えるつまり、プロキシ。プロキシに基づいたインフラストラクチャは、信頼モデルは、クライアントとサーバーの両方が正しくRTSPメッセージを処理するためにプロキシを信頼できるようなものである必要があります。プロキシを信頼できるようにするには、クライアントとサーバーは、プロキシを認識する必要があります。信頼されるようしたがって、透明プロキシは、一般的に見ることができないと（彼らはトランスポート層でのみ動作していない限り）セキュリティとうまく動作しません。このセクションの残りの部分では、「プロキシ」への参照は、RTSPメッセージを検査したり操作する非透過プロキシになります。"
    },
    {
      "indent": 3,
      "text": "HTTP Authentication is built on the assumption of proxies and can provide user-proxy authentication and proxy-proxy/server authentication in addition to the client-server authentication.",
      "ja": "HTTP認証は、プロキシの前提に基づいて構築され、クライアント・サーバ認証に加えて、ユーザーのプロキシ認証およびプロキシプロキシ/サーバ認証を提供することができます。"
    },
    {
      "indent": 3,
      "text": "When TLS is applied and a proxy is used, the client will connect to the proxy's address when connecting to any RTSP server. This implies that for TLS, the client will authenticate the proxy server and not the end server. Note that when the client checks the server certificate in TLS, it MUST check the proxy's identity (URI or possibly other known identity) against the proxy's identity as presented in the proxy's Certificate message.",
      "ja": "TLSが適用されると、プロキシを使用する場合は任意のRTSPサーバに接続するとき、クライアントは、プロキシのアドレスに接続します。これはTLSのために、クライアントがプロキシサーバーではなくエンドサーバを認証することを意味します。クライアントがTLSにおけるサーバ証明書をチェックするときにプロキシの証明書メッセージに提示され、それはプロキシのアイデンティティに対するプロキシのID（URIまたはおそらく他の既知の身元を）チェックしなければなりませんので注意してください。"
    },
    {
      "indent": 3,
      "text": "The problem is that for a proxy accepted by the client, the proxy needs to be provided information on which grounds it should accept the next-hop certificate. Both the proxy and the user may have rules for this, and the user should have the possibility to select the desired behavior. To handle this case, the Accept-Credentials header (see Section 18.2) is used, where the client can request the proxy or proxies to relay back the chain of certificates used to authenticate any intermediate proxies as well as the server. The assumption that the proxies are viewed as trusted gives the user a possibility to enforce policies on each trusted proxy of whether it should accept the next agent in the chain. However, it should be noted that not all deployments will return the chain of certificates used to authenticate any intermediate proxies as well as the server. An operator of such a deployment may want to hide its topology from the client. It should be noted well that the client does not have any insight into the proxy's operation. Even if the proxy is trusted, it can still return an incomplete chain of certificates.",
      "ja": "この問題は、クライアントで受け入れプロキシの、プロキシが、それは次のホップの証明書を受け入れるべき根拠に基づいた情報を提供する必要があるということです。プロキシとユーザーの両方が、このためのルールを有していてもよく、ユーザが所望の行動を選択する可能性を有していなければなりません。このような場合を扱うために、受け入れ・クレデンシャルヘッダ（セクション18.2を参照）、クライアントが任意の中間プロキシならびにサーバを認証するために使用される証明書のチェーンをバック中継するプロキシまたはプロキシを要求することができる場合に、使用されています。プロキシが信頼できると見ているという仮定は、ユーザーにそれはチェーンの次のエージェントを受け入れるべきかどうかのそれぞれの信頼できるプロキシにポリシーを適用する可能性を与えます。しかし、すべての展開は、任意の中間プロキシだけでなく、サーバーを認証するために使用される証明書のチェーンを返しますないことに留意すべきです。こうした展開のオペレータは、クライアントからのトポロジを非表示にすることがあります。クライアントがプロキシの操作に任意の​​洞察力を持っていないことにも注意すべきです。プロキシが信頼されている場合でも、それはまだ証明書の不完全なチェーンを返すことができます。"
    },
    {
      "indent": 3,
      "text": "A proxy MUST use TLS for the next hop if the RTSP request includes an \"rtsps\" URI. TLS MAY be applied on intermediate links (e.g., between client and proxy or between proxy and proxy) even if the resource and the end server are not required to use it. The chain of proxies used by a client to reach a server and its TLS sessions MUST have commensurate security. Therefore, a proxy MUST, when initiating the next-hop TLS connection, use the incoming TLS connections cipher-suite list, only modified by removing any cipher suites that the proxy does not support. In case a proxy fails to establish a TLS connection due to cipher-suite mismatch between proxy and next-hop proxy or server, this is indicated using error code 472 (Failure to Establish Secure Connection).",
      "ja": "RTSP要求は「RTSPS」URIが含まれている場合、プロキシは、次のホップにTLSを使用しなければなりません。 TLSは、リソースとエンドサーバがそれを使用する必要がない場合であっても（例えば、クライアントとプロキシの間またはプロキシとプロキシとの間の）中間リンクに適用されてもよいです。サーバとそのTLSセッションに到達するためにクライアントが使用するプロキシの連鎖は、相応のセキュリティを持っていなければなりません。したがって、次のホップにTLS接続を開始するとき、着信TLS接続暗号スイートのリストを使用しなければならないプロキシは、プロキシのみがサポートされていない任意の暗号スイートを除去することにより改変しました。プロキシが伴うプロキシとネクストホッププロキシまたはサーバの間の暗号スイートの不一致にTLS接続を確立するために失敗した場合には、これはエラーコード472（安全な接続を確立するのに失敗）を使用して示されています。"
    },
    {
      "indent": 0,
      "text": "19.3.1. Accept-Credentials",
      "section_title": true,
      "ja": "19.3.1.  -資格を受け入れます"
    },
    {
      "indent": 3,
      "text": "The Accept-Credentials header can be used by the client to distribute simple authorization policies to intermediate proxies. The client includes the Accept-Credentials header to dictate how the proxy treats the server / next proxy certificate. There are currently three methods defined:",
      "ja": "受け入れ-資格情報をヘッダには、中間プロキシに簡単な認可ポリシーを配布するために、クライアントで使用することができます。クライアントが受け入れ、資格情報がプロキシは、サーバ/次のプロキシ証明書をどのように扱うかを指示するヘッダーが含まれます。定義された3つの方法が現在ありません。"
    },
    {
      "indent": 3,
      "text": "Any: With \"any\", the proxy (or proxies) MUST accept whatever certificate is presented. Of course, this is not a recommended option to use, but it may be useful in certain circumstances (such as testing).",
      "ja": "どれ：「任意の」では、プロキシ（またはプロキシ）が提示されているものの証明書受け入れなければなりません。もちろん、これは使用することは推奨オプションではないが、それは（例えば、テストなど）特定の状況において有用であり得ます。"
    },
    {
      "indent": 3,
      "text": "Proxy: For the \"proxy\" method, the proxy (or proxies) MUST use its own policies to validate the certificate and decide whether or not to accept it. This is convenient in cases where the user has a strong trust relation with the proxy. Reasons why a strong trust relation may exist are personal/company proxy or the proxy has an out-of-band policy configuration mechanism.",
      "ja": "プロキシ：「プロキシ」の方法は、プロキシ（またはプロキシ）の場合は、証明書を検証し、それを受け入れるかどうかを決定するために、独自のポリシーを使用しなければなりません。これにより、ユーザーは、プロキシとの強い信頼関係を持っている場合に便利です。強い信頼関係が存在する可能性がある理由は、個人/企業の代理であるか、プロキシは、アウトオブバンドポリシー設定機構を備えています。"
    },
    {
      "indent": 3,
      "text": "User: For the \"user\" method, the proxy (or proxies) MUST send credential information about the next hop to the client for authorization. The client can then decide whether or not the proxy should accept the certificate. See Section 19.3.2 for further details.",
      "ja": "ユーザー：「ユーザー」の方法については、プロキシ（またはプロキシ）は、認可のためにクライアントに次のホップについての資格情報を送らなければなりません。次に、クライアントはプロキシが証明書を受け入れるかどうかを決定することができます。詳細については、セクション19.3.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "If the Accept-Credentials header is not included in the RTSP request from the client, then the \"Proxy\" method MUST be used as default. If a method other than the \"Proxy\" is to be used, then the Accept-Credentials header MUST be included in all of the RTSP requests from the client. This is because it cannot be assumed that the proxy always keeps the TLS state or the user's previous preference between different RTSP messages (in particular, if the time interval between the messages is long).",
      "ja": "受け入れ-資格情報ヘッダがクライアントからのRTSP要求に含まれていない場合は、「プロキシ」方法がデフォルトとして使用されなければなりません。 「プロキシ」以外の方法が使用される場合、受け入れ-資格ヘッダは、クライアントからのRTSP要求の全てに含まれなければなりません。 （メッセージ間の時間間隔が長い場合、特に）プロキシが常にTLS状態または異なるRTSPメッセージ間のユーザーの以前の好みを続けると仮定することができないためです。"
    },
    {
      "indent": 3,
      "text": "With the \"Any\" and \"Proxy\" methods, the proxy will apply the policy as defined for each method. If the policy does not accept the credentials of the next hop, the proxy MUST respond with a message using status code 471 (Connection Credentials Not Accepted).",
      "ja": "「任意」と「プロキシ」の方法では、プロキシは、メソッドごとに定義されたポリシーを適用します。ポリシーは次のホップの資格情報を受け入れない場合、プロキシはステータスコード471を使用してメッセージで応じなければなりません（接続資格情報を受け付けません）。"
    },
    {
      "indent": 3,
      "text": "An RTSP request in the direction server to client MUST NOT include the Accept-Credentials header. As for the non-secured communication, the possibility for these requests depends on the presence of a client established connection. However, if the server-to-client request is in relation to a session established over a TLS secured channel, it MUST be sent in a TLS secured connection. That secured connection MUST also be the one used by the last client-to-server request. If no such transport connection exists at the time when the server desires to send the request, the server MUST discard the message.",
      "ja": "クライアントへの方向サーバーでRTSP要求を受け入れ、資格情報のヘッダを含んではいけません。非セキュアな通信については、これらの要求のための可能性は、クライアント確立された接続の存在に依存します。サーバーからクライアントへの要求はTLSセキュアなチャネルを介して確立されたセッションに関連している場合は、それはTLSの安全な接続に送らなければなりません。それセキュアな接続も最後のクライアントからサーバーへのリクエストで使用されるものでなければなりません。そのようなトランスポート接続は、サーバがリクエストを送信することを望む時に存在しない場合、サーバーはメッセージを捨てなければなりません。"
    },
    {
      "indent": 3,
      "text": "Further policies MAY be defined and registered, but this should be done with caution.",
      "ja": "また、ポリシーが定義されており、登録されたが、これは慎重に行わなければならないかもしれません。"
    },
    {
      "indent": 0,
      "text": "19.3.2. User-Approved TLS Procedure",
      "section_title": true,
      "ja": "19.3.2. ユーザー承認TLS手順"
    },
    {
      "indent": 3,
      "text": "For the \"User\" method, each proxy MUST perform the following procedure for each RTSP request:",
      "ja": "「ユーザー」の方法については、各プロキシは、各RTSP要求のために、次の手順を実行する必要があります。"
    },
    {
      "indent": 3,
      "text": "o Set up the TLS session to the next hop if not already present (i.e., run the TLS handshake, but do not send the RTSP request).",
      "ja": "O既に存在していない（つまり、TLSハンドシェイクを実行しますが、RTSP要求を送信しない）場合は、次のホップにTLSセッションを設定します。"
    },
    {
      "indent": 3,
      "text": "o Extract the peer certificate chain for the TLS session.",
      "ja": "O TLSセッションのピア証明書チェーンを展開します。"
    },
    {
      "indent": 3,
      "text": "o Check if a matching identity and hash of the peer certificate are present in the Accept-Credentials header. If present, send the message to the next hop and conclude these procedures. If not, go to the next step.",
      "ja": "ピア証明書のマッチングIDとハッシュが受け入れ-資格ヘッダーに存在する場合にOチェックします。存在する場合は、次のホップにメッセージを送信し、これらの手順を締結。ない場合は、次のステップに進みます。"
    },
    {
      "indent": 3,
      "text": "o The proxy responds to the RTSP request with a 470 or 407 response code. The 407 response code MAY be used when the proxy requires both user and connection authorization from user or client. In this message the proxy MUST include a Connection-Credentials header, see Section 18.13, with the next hop's identity and certificate.",
      "ja": "Oプロキシは、470または407レスポンスコードでRTSP要求に応答します。プロキシが、ユーザーやクライアントからのユーザーとの接続承認の両方を必要とする場合に407応答コードを使用することができます。このメッセージでは、プロキシは、接続資格情報は、次のホップのIDと証明書を使用して、セクション18.13を参照、ヘッダを含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "The client MUST upon receiving a 470 (Connection Authorization Required) or 407 (Proxy Authentication Required) response with Connection-Credentials header take the decision on whether or not to accept the certificate (if it cannot do so, the user SHOULD be consulted). Using IP addresses in the next-hop URI and certificates rather than domain names makes it very difficult for a user to determine whether or not it should approve the next hop. Proxies are RECOMMENDED to use domain names to identify themselves in URIs and in the certificates. If the certificate is accepted, the client has to again send the RTSP request. In that request, the client has to include the Accept-Credentials header including the hash over the DER-encoded certificate for all trusted proxies in the chain.",
      "ja": "470（接続認証が必要）、またはConnection-資格情報を持つ407（プロキシ認証が必要）応答を受信すると、クライアントのMUSTは、証明書を受け入れるかどうかの判断（それがそうすることができない場合、ユーザーは相談する必要があります）を取るヘッダー。ネクストホップURIと証明書内のIPアドレスではなくドメイン名を使用すると、それは次のホップを承認すべきかどうかを判断するために、ユーザのために、それは非常に困難になります。プロキシは、URIの中と証明書で自分自身を識別するためにドメイン名を使用することをお勧めします。証明書が受理された場合、クライアントは再びRTSP要求を送信する必要があります。その要求には、クライアントは、チェーン内のすべての信頼されたプロキシのDERでエンコードされた証明書の上にハッシュを含めたAccept-資格情報のヘッダーを含める必要があります。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 3,
      "text": "C->P: SETUP rtsps://test.example.org/secret/audio RTSP/2.0 CSeq: 2 Transport: RTP/AVP;unicast;dest_addr=\"192.0.2.5:4588\"/ \"192.0.2.5:4589\" Accept-Ranges: npt, smpte, clock Accept-Credentials: User",
      "ja": "C-> P：SETUPのRTSPS：//test.example.org/secret/audio RTSP / 2.0のCSeq：2トランスポート：RTP / AVP;ユニキャスト; dest_addrは= \"192.0.2.5:4588\" / \"192.0.2.5:4589\" -範囲を受け入れ：NPT、SMPTE、クロックは、資格を受け入れる：ユーザー"
    },
    {
      "indent": 3,
      "text": "P->C: RTSP/2.0 470 Connection Authorization Required CSeq: 2 Connection-Credentials: \"rtsps://test.example.org\"; MIIDNTCCAp...",
      "ja": "P-> C：RTSP / 2.0 470の接続認証が必要のCSeq：2接続-資格情報： \"RTSPS：//test.example.org\"; MIIDNTCCAp ..."
    },
    {
      "indent": 3,
      "text": "C->P: SETUP rtsps://test.example.org/secret/audio RTSP/2.0 CSeq: 3 Transport: RTP/AVP;unicast;dest_addr=\"192.0.2.5:4588\"/ \"192.0.2.5:4589\" Accept-Credentials: User \"rtsps://test.example.org\";sha-256; dPYD7txpoGTbAqZZQJ+vaeOkyH4= Accept-Ranges: npt, smpte, clock",
      "ja": "C-> P：SETUPのRTSPS：//test.example.org/secret/audio RTSP / 2.0のCSeq：3トランスポート：RTP / AVP;ユニキャスト; dest_addrは= \"192.0.2.5:4588\" / \"192.0.2.5:4589\" -資格を受け入れる：ユーザー \"RTSPS：//test.example.org\"; SHA-256; dPYD7txpo​​GTbAqZZQJ + vaeOkyH4 =-範囲を受け入れ：NPT、SMPTE、クロック"
    },
    {
      "indent": 3,
      "text": "P->S: SETUP rtsps://test.example.org/secret/audio RTSP/2.0 CSeq: 3 Transport: RTP/AVP;unicast;dest_addr=\"192.0.2.5:4588\"/ \"192.0.2.5:4589\" Via: RTSP/2.0 proxy.example.org Accept-Credentials: User \"rtsps://test.example.org\";sha-256; dPYD7txpoGTbAqZZQJ+vaeOkyH4= Accept-Ranges: npt, smpte, clock",
      "ja": "P-> S：セットアップRTSPS：//test.example.org/secret/audio RTSP / 2.0のCSeq：3トランスポート：RTP / AVP;ユニキャスト; dest_addrは= \"192.0.2.5:4588\" / \"192.0.2.5:4589\"経由：RTSP / 2.0 proxy.example.org-資格を受け入れる：ユーザー \"RTSPS：//test.example.org\"; SHA-256; dPYD7txpo​​GTbAqZZQJ + vaeOkyH4 =-範囲を受け入れ：NPT、SMPTE、クロック"
    },
    {
      "indent": 3,
      "text": "One implication of this process is that the connection for secured RTSP messages may take significantly more round-trip times for the first message. A complete extra message exchange between the proxy connecting to the next hop and the client results because of the process for approval for each hop. However, if each message contains the chain of proxies that the requester accepts, the remaining message exchange should not be delayed. The procedure of including the credentials in each request rather than building state in each proxy avoids the need for revocation procedures.",
      "ja": "このプロセスの一つの含意はセキュアなRTSPメッセージの接続は、最初のメッセージのためにかなり多くの往復時間がかかる場合があります。なぜなら各ホップのための承認を得るためのプロセスの次のホップとクライアントの結果に接続するプロキシ間の完全な余分なメッセージ交換。各メッセージは、要求者が受け入れるプロキシのチェーンが含まれている場合しかし、残りのメッセージ交換は、遅延されるべきではありません。各要求で証明書などではなく、各プロキシの状態を構築する手順は、失効手続きの必要性を回避します。"
    },
    {
      "indent": 0,
      "text": "20. Syntax",
      "section_title": true,
      "ja": "20.構文"
    },
    {
      "indent": 3,
      "text": "The RTSP syntax is described in an Augmented Backus-Naur Form (ABNF) as defined in RFC 5234 [RFC5234]. It uses the basic definitions present in RFC 5234.",
      "ja": "RFC 5234 [RFC5234]で定義されるようにRTSPの構文は、拡張バッカス・ナウアフォーム（ABNF）に記載されています。これは、RFC 5234に存在する基本的な定義を使用しています。"
    },
    {
      "indent": 3,
      "text": "Please note that ABNF strings, e.g., \"Accept\", are case insensitive as specified in Section 2.3 of RFC 5234.",
      "ja": "RFC 5234のセクション2.3で指定されたABNFの文字列は、例えば、「同意する」、大文字と小文字を区別しませんのでご注意ください。"
    },
    {
      "indent": 3,
      "text": "The RTSP syntax makes use of the ISO 10646 character set in UTF-8 encoding [RFC3629].",
      "ja": "RTSPの構文は、UTF-8エンコーディング[RFC3629]でISO 10646文字セットを使用します。"
    },
    {
      "indent": 0,
      "text": "20.1. Base Syntax",
      "section_title": true,
      "ja": "20.1. 基本構文"
    },
    {
      "indent": 3,
      "text": "RTSP header values can be folded onto multiple lines if the continuation line begins with a space or horizontal tab. All linear whitespace, including folding, has the same semantics as SP. A recipient MAY replace any linear whitespace with a single SP before interpreting the field-value or forwarding the message downstream. The SWS construct is used when linear whitespace is optional, generally between tokens and separators.",
      "ja": "継続行はスペースまたは水平タブで始まる場合RTSPヘッダ値が複数行に折り畳むことができます。折りたたみを含むすべてのリニアの空白は、SPと同じ意味を持っています。受信者は、フィールドの値を解釈または下流メッセージを転送する前に、単一のSPを有する任意の線形空白を置き換えることができます。線形空白は一般にトークンとセパレータとの間に、任意のときSWS構築物が使用されます。"
    },
    {
      "indent": 3,
      "text": "To separate the header name from the rest of value, a colon is used, which, by the above rule, allows whitespace before, but no line break, and whitespace after, including a line break. The HCOLON defines this construct.",
      "ja": "値の残りの部分からヘッダ名を分離するために、結腸は、上記の規則によって、前に空白を可能にする、使用される、ない改行、および空白改行など、後。 HCOLONは、この構造を定義します。"
    },
    {
      "indent": 3,
      "text": "OCTET = %x00-FF ; any 8-bit sequence of data CHAR = %x01-7F ; any US-ASCII character (octets 1 - 127) UPALPHA = %x41-5A ; any US-ASCII uppercase letter \"A\"..\"Z\" LOALPHA = %x61-7A ; any US-ASCII lowercase letter \"a\"..\"z\" ALPHA = UPALPHA / LOALPHA DIGIT = %x30-39 ; any US-ASCII digit \"0\"..\"9\" CTL = %x00-1F / %x7F ; any US-ASCII control character ; (octets 0 - 31) and DEL (127) CR = %x0D ; US-ASCII CR, carriage return (13) LF = %x0A ; US-ASCII LF, linefeed (10) SP = %x20 ; US-ASCII SP, space (32) HT = %x09 ; US-ASCII HT, horizontal-tab (9) BACKSLASH = %x5C ; US-ASCII backslash (92) CRLF = CR LF LWS = [CRLF] 1*( SP / HT ) ; Line-breaking whitespace SWS = [LWS] ; Separating whitespace HCOLON = *( SP / HT ) \":\" SWS TEXT = %x20-7E / %x80-FF ; any OCTET except CTLs tspecials = \"(\" / \")\" / \"<\" / \">\" / \"@\" / \",\" / \";\" / \":\" / BACKSLASH / DQUOTE / \"/\" / \"[\" / \"]\" / \"?\" / \"=\" / \"{\" / \"}\" / SP / HT token = 1*(%x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7A / %x7C / %x7E) ; 1*<any CHAR except CTLs or tspecials> quoted-string = ( DQUOTE *qdtext DQUOTE ) qdtext = %x20-21 / %x23-5B / %x5D-7E / quoted-pair / UTF8-NONASCII ; No DQUOTE and no \"\\\" quoted-pair = \"\\\\\" / ( \"\\\" DQUOTE ) ctext = %x20-27 / %x2A-7E / %x80-FF ; any OCTET except CTLs, \"(\" and \")\" generic-param = token [ EQUAL gen-value ] gen-value = token / host / quoted-string",
      "ja": "OCTET =％X00-FF。データの任意の8ビットシーケンスCHAR =％x01-7F。任意のUS-ASCII文字（オクテット1から127）UPALPHA =％x41-5A。任意のUS-ASCII文字の大文字 \"A\" .. \"Z\" LOALPHA =％x61-7A。任意のUS-ASCII小文字 \"\" .. \"Z\" ALPHA = UPALPHA / LOALPHA DIGIT =％x30-39;任意のUS-ASCII数字 \"0\" .. \"9\" CTL =％x00-1F /％x7F。任意のUS-ASCIIの制御文字。 （オクテット0から31）およびDEL（127）CR =％x0D。 US-ASCII CR、キャリッジリターン（13）LF =％X0A。 US-ASCII LF、改行（10）SP =％X20; US-ASCII SP、スペース（32）HT =％x09の。 US-ASCII HT、水平タブ（9）BACKSLASH =％のx5C。 US-ASCIIのバックスラッシュ（92）CRLF = CR LF LWS = [CRLF] 1 *（SP / HT）。改行空白SWSを= [LWS]。空白HCOLON = *（SP / HT）を分離 \"：\" SWSのTEXT =％x20-7E /％X80-FF。 CTLをtspecials = \"（\" / \"）\" / \"<\" / \">\" / \"@\" / \"\" /以外の任意のOCTET \";\" / \"：\" / BACKSLASH / DQUOTE / \"/\" / \"[\" / \"]\" / \"？\" / \"=\" / \"{\" / \"}\" / SP / HTトークン= 1 *（％X21 /％x23-27 /％X2A-2B /％x2D-2E /％x30-39 /％x41-5A /％ x5E-7A /％x7C /％のx7E）。 1 * <的CTLまたはtspecials除く任意のCHAR>引用符で囲まれた文字列=（DQUOTE * qdtext DQUOTE）qdtext =％x20-21 /％x23-5B /％x5D-7E /引用ペア/ UTF8-NONASCII。 DQUOTE、ノー \"\\\" 引用対= \"\\\\\" /（ \"\\\" DQUOTE）CTEXT =％x20-27 /％X2A-7E /％のX80-FF; NO CTLは、 \"（\" および \"）\" ジェネリック-PARAM =トークン[EQUAL GEN-値] GEN-値=トークン/ホスト/引用符で囲まれた文字列以外の任意のOCTET"
    },
    {
      "indent": 3,
      "text": "safe = \"$\" / \"-\" / \"_\" / \".\" / \"+\" extra = \"!\" / \"*\" / \"'\" / \"(\" / \")\" / \",\" rtsp-extra = \"!\" / \"*\" / \"'\" / \"(\" / \")\"",
      "ja": "安全= \"$\" / \" - \" / \"_\" / \"\" / \"+\" 余分= \"！\" / \"*\" / \"'\" / \"（\" / \"）\" / \"、\" RTSP-余分= \"！\" / \"*\" / \"'\" / \"（\" / \"）\""
    },
    {
      "indent": 3,
      "text": "HEX = DIGIT / \"A\" / \"B\" / \"C\" / \"D\" / \"E\" / \"F\" / \"a\" / \"b\" / \"c\" / \"d\" / \"e\" / \"f\" LHEX = DIGIT / \"a\" / \"b\" / \"c\" / \"d\" / \"e\" / \"f\" ; lowercase \"a-f\" Hex reserved = \";\" / \"/\" / \"?\" / \":\" / \"@\" / \"&\" / \"=\"",
      "ja": "HEX = DIGIT / \"A\" / \"B\" / \"C\" / \"D\" / \"E\" / \"F\" / \"\" / \"B\" / \"C\" / \"D\" / \"E\" /「F 「LHEX = DIGIT / \"\" / \"B\" / \"C\" / \"D\" / \"E\" / \"F\"。小文字予約「-F」六角=「;」 / \"/\" / \"？\" / \"：\" / \"@\" / \"＆\" / \"=\""
    },
    {
      "indent": 3,
      "text": "unreserved = ALPHA / DIGIT / safe / extra rtsp-unreserved = ALPHA / DIGIT / safe / rtsp-extra",
      "ja": "予約されていない= ALPHA / DIGIT /安全/エクストラRTSP-予約されていない= ALPHA / DIGIT /安全/ RTSP-余分"
    },
    {
      "indent": 3,
      "text": "base64 = *base64-unit [base64-pad] base64-unit = 4base64-char base64-pad = (2base64-char \"==\") / (3base64-char \"=\") base64-char = ALPHA / DIGIT / \"+\" / \"/\" SLASH = SWS \"/\" SWS ; slash EQUAL = SWS \"=\" SWS ; equal LPAREN = SWS \"(\" SWS ; left parenthesis RPAREN = SWS \")\" SWS ; right parenthesis COMMA = SWS \",\" SWS ; comma SEMI = SWS \";\" SWS ; semicolon COLON = SWS \":\" SWS ; colon MINUS = SWS \"-\" SWS ; minus/dash LDQUOT = SWS DQUOTE ; open double quotation mark RDQUOT = DQUOTE SWS ; close double quotation mark RAQUOT = \">\" SWS ; right angle quote LAQUOT = SWS \"<\" ; left angle quote",
      "ja": "BASE64 = * BASE64ユニット[BASE64-PAD] BASE64ユニット= 4base64-チャーBASE64パッド=（2base64-CHAR \"==\"）/（3base64-CHAR \"=\"）base64でチャー= ALPHA / DIGIT /「+ \"/ \"/\" スラッシュ= SWS \"/\" SWS。 EQUAL = SWS \"=\" SWSを大幅に削減。等しいLPAREN = SWS \"（\" SWS;左括弧RPAREN = SWS \"）\" SWS。右括弧COMMAはSWS \"\" SWSを=。コンマSEMI = SWS \";\" SWS;セミコロンコロン= SWS \"：\" SWS;大腸MINUS = SWS \" - \" SWS。マイナス/ダッシュLDQUOT = SWS DQUOTE。二重引用符のRDQUOT = DQUOTE SWSを開きます。近くに二重引用符のRAQUOT = \">\" SWS;直角の引用LAQUOT = SWS \"<\";左の角度の引用"
    },
    {
      "indent": 3,
      "text": "TEXT-UTF8char = %x21-7E / UTF8-NONASCII UTF8-NONASCII = UTF8-2 / UTF8-3 / UTF8-4 UTF8-1 = <As defined in RFC 3629> UTF8-2 = <As defined in RFC 3629> UTF8-3 = <As defined in RFC 3629> UTF8-4 = <As defined in RFC 3629> UTF8-tail = <As defined in RFC 3629>",
      "ja": "TEXT-UTF8char =％x21-7E / UTF8-NONASCII UTF8-NONASCII = UTF8-2 / UTF8-3 / UTF8-4 UTF8-1 = <RFC 3629で定義されているよう> UTF8-2 = <RFC 3629で定義されているよう> UTF8 -3 = <RFC 3629で定義されているよう> UTF8-尾= <RFC 3629で定義されているよう> UTF8-4 = <RFC 3629で定義されたように>"
    },
    {
      "indent": 3,
      "text": "POS-FLOAT = 1*12DIGIT [\".\" 1*9DIGIT] FLOAT = [\"-\"] POS-FLOAT",
      "ja": "POS-FLOAT = 1 * 12桁の[ \"\" \" - \"] POS-FLOAT] FLOAT = 1 * DIGIT 9"
    },
    {
      "indent": 0,
      "text": "20.2. RTSP Protocol Definition",
      "section_title": true,
      "ja": "20.2.  RTSPプロトコルの定義"
    },
    {
      "indent": 0,
      "text": "20.2.1. Generic Protocol Elements",
      "section_title": true,
      "ja": "20.2.1. 汎用プロトコル要素"
    },
    {
      "indent": 3,
      "text": "RTSP-IRI = schemes \":\" IRI-rest IRI-rest = ihier-part [ \"?\" iquery ] ihier-part = \"//\" iauthority ipath-abempty RTSP-IRI-ref = RTSP-IRI / irelative-ref irelative-ref = irelative-part [ \"?\" iquery ] irelative-part = \"//\" iauthority ipath-abempty / ipath-absolute / ipath-noscheme / ipath-empty",
      "ja": "RTSP-IRIは=スキーム \"：\" IRI-残りIRI-残り= ihierパート[ \"？\" IQUERY] ihierパート= \"//\" iauthority IPATH-abempty RTSP-IRI-REF = RTSP-IRI / irelative-REF irelative-REF = irelativeパート[ \"？\" IQUERY] irelativeパート= \"//\" iauthorityのIPATH-abempty / IPATH絶対/ IPATH-noscheme / IPATH空"
    },
    {
      "indent": 3,
      "text": "iauthority = < As defined in RFC 3987> ipath = ipath-abempty ; begins with \"/\" or is empty / ipath-absolute ; begins with \"/\" but not \"//\" / ipath-noscheme ; begins with a non-colon segment / ipath-rootless ; begins with a segment / ipath-empty ; zero characters",
      "ja": "iauthority = <RFC 3987で定義されているよう> IPATH = IPATH-abempty。 「/」で始まるまたは空/ IPATH絶対です。 \"/\" ではなく \"//\" / IPATH-noschemeで始まります。非結腸セグメント/ IPATH-ルートレスで始まります。セグメント/ IPATH空で始まります。ゼロの文字"
    },
    {
      "indent": 3,
      "text": "ipath-abempty = *( \"/\" isegment ) ipath-absolute = \"/\" [ isegment-nz *( \"/\" isegment ) ] ipath-noscheme = isegment-nz-nc *( \"/\" isegment ) ipath-rootless = isegment-nz *( \"/\" isegment ) ipath-empty = 0<ipchar>",
      "ja": "IPATH-abempty = *（ \"/\" isegment）IPATH絶対= \"/\" [isegment-NZ *（ \"/\" isegment）] IPATH-noscheme = isegment-NZ-NC *（ \"/\" isegment）IPATH、ルートレス= NZ-isegment *（ \"/\" isegment）IPATH空= 0 <ipchar>"
    },
    {
      "indent": 3,
      "text": "isegment = *ipchar [\";\" *ipchar] isegment-nz = 1*ipchar [\";\" *ipchar] / \";\" *ipchar isegment-nz-nc = (1*ipchar-nc [\";\" *ipchar-nc]) / \";\" *ipchar-nc ; non-zero-length segment without any colon \":\" ; No parameter (; delimited) inside path.",
      "ja": "isegment = * ipcharの[ \";\" * ipchar] isegment-NZ = 1 * ipcharの[ \";\" * ipchar] / \";\" * ipchar isegment-NZ-NC =（1 * ipchar-NC [ \";\" * ipchar-NC]）/ \";\" * ipchar-NC;任意結腸ことなく、非ゼロ長セグメント「：」。パス内の; NOパラメータない（区切り）。"
    },
    {
      "indent": 3,
      "text": "ipchar = iunreserved / pct-encoded / sub-delims / \":\" / \"@\" ipchar-nc = iunreserved / pct-encoded / sub-delims / \"@\" ; sub-delims is different from RFC 3987 ; not including \";\"",
      "ja": "ipchar = iunreserved / PCTエンコード/サブdelims / \"：\" / \"@\" ipchar-NC = iunreserved / PCTエンコード/サブdelims / \"@\"。サブdelims RFC 3987と異なっています。含みません「;」"
    },
    {
      "indent": 3,
      "text": "iquery = < As defined in RFC 3987> iunreserved = < As defined in RFC 3987> pct-encoded = < As defined in RFC 3987>",
      "ja": "IQUERY = <RFC 3987で定義されているよう> iunreserved = <RFC 3987で定義されているよう> PCTエンコード= <RFC 3987で定義されたように>"
    },
    {
      "indent": 3,
      "text": "RTSP-URI = schemes \":\" URI-rest RTSP-REQ-URI = schemes \":\" URI-req-rest RTSP-URI-Ref = RTSP-URI / RTSP-Relative RTSP-REQ-Ref = RTSP-REQ-URI / RTSP-REQ-Rel schemes = \"rtsp\" / \"rtsps\" / scheme scheme = < As defined in RFC 3986> URI-rest = hier-part [ \"?\" query ] URI-req-rest = hier-part [ \"?\" query ] ; Note fragment part not allowed in requests hier-part = \"//\" authority path-abempty",
      "ja": "RTSP-URI =スキーム \"：\" URI-残りRTSP-REQ-URI =スキーム \"：\" URI-REQ-残りRTSP-URI-REF = RTSP-URI / RTSP-相対RTS​​P-REQ-REF = RTSP-REQ-URI / RTSP-REQ-相対スキーム= \"RTSP\" / \"RTSPS\" /スキームスキーム= <RFC 3986で定義されているよう> URIレスト= HIERパート[ \"？\"クエリ] URI-REQ-残り=のhierパート[ \"？\"クエリ];注フラグメントの一部はのhier-部分=「//」権威パス-abemptyリクエストで許可されていません"
    },
    {
      "indent": 3,
      "text": "RTSP-Relative = relative-part [ \"?\" query ] RTSP-REQ-Rel = relative-part [ \"?\" query ] relative-part = \"//\" authority path-abempty / path-absolute / path-noscheme / path-empty",
      "ja": "RTSP-相対=相対パート[ \"？\"クエリ] RTSP-REQ-のRel =相対パート[ \"？\"クエリ]相対一部=「//」権限パスabempty /パス絶対/パスnoscheme /パス空"
    },
    {
      "indent": 3,
      "text": "authority = < As defined in RFC 3986> query = < As defined in RFC 3986>",
      "ja": "権限= <RFC 3986で定義されているように> <RFC 3986で定義されているように>クエリ="
    },
    {
      "indent": 3,
      "text": "path = path-abempty ; begins with \"/\" or is empty / path-absolute ; begins with \"/\" but not \"//\" / path-noscheme ; begins with a non-colon segment / path-rootless ; begins with a segment / path-empty ; zero characters",
      "ja": "パス=パスabempty。 「/」で始まるまたは空/パス絶対あります。 「/」ではなく「//」/パスnoschemeで始まります。非結腸セグメント/パスルートレスで始まります。セグメント/パス空始まります。ゼロの文字"
    },
    {
      "indent": 3,
      "text": "path-abempty = *( \"/\" segment ) path-absolute = \"/\" [ segment-nz *( \"/\" segment ) ] path-noscheme = segment-nz-nc *( \"/\" segment ) path-rootless = segment-nz *( \"/\" segment ) path-empty = 0<pchar>",
      "ja": "パスabempty = *（ \"/\" セグメント）パス絶対= \"/\" [セグメントNZ *（ \"/\" セグメント）]パスnoscheme =セグメント-NZ-NC×（ \"/\" セグメント）パスルートレス=セグメントNZ *（ \"/\" セグメント）パス空= 0 <PChar型>"
    },
    {
      "indent": 3,
      "text": "segment = *pchar [\";\" *pchar] segment-nz = ( 1*pchar [\";\" *pchar]) / (\";\" *pchar) segment-nz-nc = ( 1*pchar-nc [\";\" *pchar-nc]) / (\";\" *pchar-nc) ; non-zero-length segment without any colon \":\" ; No parameter (; delimited) inside path.",
      "ja": "セグメント= * PChar型の[ \";\" * PChar型】セグメントNZ =（1 * PChar型の[ \";\" * PChar型]）/（ \";\" * PChar型）セグメント-NZ-NC =（1 * PChar型-NC [ \";\" * PChar型-NC]）/ （ \";\" * PChar型-NC）;任意結腸ことなく、非ゼロ長セグメント「：」。パス内の; NOパラメータない（区切り）。"
    },
    {
      "indent": 3,
      "text": "pchar = unreserved / pct-encoded / sub-delims / \":\" / \"@\" pchar-nc = unreserved / pct-encoded / sub-delims / \"@\"",
      "ja": "PChar型=未予約/ PCTエンコード/サブdelims / \"：\" / \"@\" PChar型-NC =未予約/ PCTエンコード/サブdelims / \"@\""
    },
    {
      "indent": 3,
      "text": "sub-delims = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\" / \"*\" / \"+\" / \",\" / \"=\" ; sub-delims is different from RFC 3986/3987 ; not including \";\"",
      "ja": "サブdelims = \"！\" / \"$\" / \"＆\" / \"'\" / \"（\" / \"）\" / \"*\" / \"+\" / \"、\" / \"=\";サブdelims RFC 3986/3987と異なっています。含みません「;」"
    },
    {
      "indent": 3,
      "text": "smpte-range = smpte-type [EQUAL smpte-range-spec] ; See section 4.4 smpte-range-spec = ( smpte-time \"-\" [ smpte-time ] ) / ( \"-\" smpte-time ) smpte-type = \"smpte\" / \"smpte-30-drop\" / \"smpte-25\" / smpte-type-extension ; other timecodes may be added smpte-type-extension = \"smpte\" token smpte-time = 1*2DIGIT \":\" 1*2DIGIT \":\" 1*2DIGIT [ \":\" 1*2DIGIT [ \".\" 1*2DIGIT ] ]",
      "ja": "SMPTE-範囲= SMPTE型[EQUAL SMPTE-範囲仕様]。 （ \" - \" SMPTE-時間）/  - （[SMPTEタイム] \"\" SMPTEタイム）セクション4.4 SMPTE-範囲仕様=を参照SMPTE-TYPE = \"SMPTE\" / \"SMPTE-30ドロップ\" /「smpte- 25\" / SMPTE-型エクステンション。 \"：\" 1 * 2DIGIT \"：\" 1 * 2DIGIT [ \"：\" 他のタイムコードはSMPTE-型拡張= \"SMPTE\" トークンSMPTEタイム= 1 * 2DIGIT添加することができる \"\" 1 * 2DIGITを[ 1 * 2DIGIT]]"
    },
    {
      "indent": 3,
      "text": "npt-range = \"npt\" [EQUAL npt-range-spec] npt-range-spec = ( npt-time \"-\" [ npt-time ] ) / ( \"-\" npt-time ) npt-time = \"now\" / npt-sec / npt-hhmmss / npt-hhmmss-comp npt-sec = 1*19DIGIT [ \".\" 1*9DIGIT ] npt-hhmmss = npt-hh \":\" npt-mm \":\" npt-ss [ \".\" 1*9DIGIT ] npt-hh = 2*19DIGIT ; any positive number npt-mm = 2*2DIGIT ; 0-59 npt-ss = 2*2DIGIT ; 0-59 npt-hhmmss-comp = npt-hh-comp \":\" npt-mm-comp \":\" npt-ss-comp [ \".\" 1*9DIGIT ] ; Compatibility format npt-hh-comp = 1*19DIGIT ; any positive number npt-mm-comp = 1*2DIGIT ; 0-59 npt-ss-comp = 1*2DIGIT ; 0-59",
      "ja": "NPT-範囲= \"NPT\" [EQUAL NPTレンジ仕様] NPT範囲仕様=（NPTタイム \" - \" [NPT時間]）/（ \" - \" NPTタイム）NPTタイム= \"今\" / NPT秒/ NPT-HHMMSS / NPT-HHMMSS-COMP NPT-秒= 1 * 19DIGIT [ \"\" 1 * 9DIGIT] NPT-HHMMSS = NPT-HH：NPT-MM \"\" \"：\" NPT-SS [ \"\" 1 * 9DIGIT] NPT-HH = 2 * 19DIGIT。任意の正数NPT-MM = 2 * 2DIGIT。 0-59 NPT-SS = 2 * 2DIGIT。 0-59 NPT-HHMMSS-COMP = NPT-HH-COMP \"：\" NPT-MM-COMP \"：\" \"\" NPT-SS-コンプ[ 1 * 9DIGIT]。互換形式NPT-HH-COMP = 1 * 19DIGIT。任意の正数NPT-MM-COMP = 1 * 2DIGIT。 0-59 NPT-SS-COMP = 1 * 2DIGIT。 0-59"
    },
    {
      "indent": 3,
      "text": "utc-range = \"clock\" [EQUAL utc-range-spec] utc-range-spec = ( utc-time \"-\" [ utc-time ] ) / ( \"-\" utc-time ) utc-time = utc-date \"T\" utc-clock \"Z\" utc-date = 8DIGIT utc-clock = 6DIGIT [ \".\" 1*9DIGIT ]",
      "ja": "UTC-範囲= \"時計\" [EQUAL UTCレンジ仕様] = UTCレンジ仕様（UTC時間 \" - \" [UTC時間]）/（ \" - \" UTC時間）UTC時間= UTC日付\"T\" UTCクロック \"Z\" UTC-日付= 8DIGITのUTCクロック= 6DIGIT [ \"\" 1 * 9DIGIT]"
    },
    {
      "indent": 3,
      "text": "feature-tag = token",
      "ja": "機能タグ=トークン"
    },
    {
      "indent": 3,
      "text": "session-id = 1*256( ALPHA / DIGIT / safe )",
      "ja": "セッションID = 1×256（ALPHA / DIGIT /安全）"
    },
    {
      "indent": 3,
      "text": "extension-header = header-name HCOLON header-value header-name = token header-value = *(TEXT-UTF8char / LWS)",
      "ja": "拡張ヘッダー=ヘッダ名HCOLONヘッダ値ヘッダ名=トークンヘッダ値= *（TEXT-UTF8char / LWS）"
    },
    {
      "indent": 0,
      "text": "20.2.2. Message Syntax",
      "section_title": true,
      "ja": "20.2.2. メッセージの構文"
    },
    {
      "indent": 3,
      "text": "RTSP-message = Request / Response ; RTSP/2.0 messages",
      "ja": "RTSPメッセージ=要求/応答。 RTSP / 2.0のメッセージ"
    },
    {
      "indent": 3,
      "text": "Request = Request-Line *((general-header / request-header / message-body-header) CRLF) CRLF [ message-body-data ]",
      "ja": "リクエスト=リクエストライン*（（一般的なヘッダ/リクエスト・ヘッダー/メッセージボディヘッダ）CRLF）CRLF [メッセージボディデータ]"
    },
    {
      "indent": 3,
      "text": "Response = Status-Line *((general-header / response-header / message-body-header) CRLF) CRLF [ message-body-data ]",
      "ja": "応答=ステータスライン*（（一般的なヘッダ/レスポンス・ヘッダー/メッセージボディヘッダ）CRLF）CRLF [メッセージボディデータ]"
    },
    {
      "indent": 3,
      "text": "Request-Line = Method SP Request-URI SP RTSP-Version CRLF",
      "ja": "リクエストライン=メソッドSPのRequest-URI SP RTSP  - バージョンCRLF"
    },
    {
      "indent": 3,
      "text": "Status-Line = RTSP-Version SP Status-Code SP Reason-Phrase CRLF",
      "ja": "ステータスライン= RTSP-バージョンのSPステータスコードSP理由-フレーズCRLF"
    },
    {
      "indent": 3,
      "text": "Method = \"DESCRIBE\" / \"GET_PARAMETER\" / \"OPTIONS\" / \"PAUSE\" / \"PLAY\" / \"PLAY_NOTIFY\" / \"REDIRECT\" / \"SETUP\" / \"SET_PARAMETER\" / \"TEARDOWN\" / extension-method",
      "ja": "方法= \"DESCRIBE\" / \"GET_PARAMETER\" / \"OPTIONS\" / \"一時停止\" / \"PLAY\" / \"PLAY_NOTIFY\" / \"リダイレクトする\" / \"SETUP\" / \"SET_PARAMETER\" / \"TEARDOWN\" /拡張方法"
    },
    {
      "indent": 3,
      "text": "extension-method = token",
      "ja": "拡張方式=トークン"
    },
    {
      "indent": 3,
      "text": "Request-URI = \"*\" / RTSP-REQ-URI RTSP-Version = \"RTSP/\" 1*DIGIT \".\" 1*DIGIT",
      "ja": "Request-URI = \"*\" / RTSP-REQ-URI RTSP-バージョン= \"RTSP /\" 1 * DIGIT \"\" 1 * DIGIT"
    },
    {
      "indent": 3,
      "text": "message-body-data = 1*OCTET",
      "ja": "= 1 * OCTETメッセージボディデータ"
    },
    {
      "indent": 3,
      "text": "Status-Code = \"100\" ; Continue / \"200\" ; OK / \"301\" ; Moved Permanently / \"302\" ; Found / \"303\" ; See Other / \"304\" ; Not Modified / \"305\" ; Use Proxy",
      "ja": "ステータスコード=「100」;続行/「200」。 OK / \"301\"。 /「302」永久に移動。 /「303」が見つかりました。その他/「304」を参照してください。 /「305」変更されません。プロキシを使う"
    },
    {
      "indent": 16,
      "text": "/  \"400\"  ; Bad Request\n/  \"401\"  ; Unauthorized\n/  \"402\"  ; Payment Required\n/  \"403\"  ; Forbidden\n/  \"404\"  ; Not Found\n/  \"405\"  ; Method Not Allowed\n/  \"406\"  ; Not Acceptable\n/  \"407\"  ; Proxy Authentication Required\n/  \"408\"  ; Request Timeout\n/  \"410\"  ; Gone\n/  \"412\"  ; Precondition Failed\n/  \"413\"  ; Request Message Body Too Large\n/  \"414\"  ; Request-URI Too Long\n/  \"415\"  ; Unsupported Media Type\n/  \"451\"  ; Parameter Not Understood\n/  \"452\"  ; reserved\n/  \"453\"  ; Not Enough Bandwidth\n/  \"454\"  ; Session Not Found\n/  \"455\"  ; Method Not Valid In This State\n/  \"456\"  ; Header Field Not Valid for Resource\n/  \"457\"  ; Invalid Range\n/  \"458\"  ; Parameter Is Read-Only\n/  \"459\"  ; Aggregate Operation Not Allowed\n/  \"460\"  ; Only Aggregate Operation Allowed\n/  \"461\"  ; Unsupported Transport\n/  \"462\"  ; Destination Unreachable\n/  \"463\"  ; Destination Prohibited\n/  \"464\"  ; Data Transport Not Ready Yet\n/  \"465\"  ; Notification Reason Unknown\n/  \"466\"  ; Key Management Error\n/  \"470\"  ; Connection Authorization Required\n/  \"471\"  ; Connection Credentials Not Accepted\n/  \"472\"  ; Failure to Establish Secure Connection\n/  \"500\"  ; Internal Server Error\n/  \"501\"  ; Not Implemented\n/  \"502\"  ; Bad Gateway\n/  \"503\"  ; Service Unavailable\n/  \"504\"  ; Gateway Timeout\n/  \"505\"  ; RTSP Version Not Supported\n/  \"551\"  ; Option Not Supported\n/  \"553\"  ; Proxy Unavailable\n/  extension-code",
      "raw": true
    },
    {
      "indent": 3,
      "text": "extension-code = 3DIGIT",
      "ja": "拡張コード= 3DIGIT"
    },
    {
      "indent": 3,
      "text": "Reason-Phrase = 1*(TEXT-UTF8char / HT / SP) rtsp-header = general-header / request-header / response-header / message-body-header",
      "ja": "理由-フレーズ= 1 *（TEXT-UTF8char / HT / SP）RTSPヘッダ=一般的なヘッダ/リクエストヘッダ/レスポンス・ヘッダー/メッセージボディヘッダ"
    },
    {
      "indent": 3,
      "text": "general-header = Accept-Ranges / Cache-Control / Connection / CSeq / Date / Media-Properties / Media-Range / Pipelined-Requests / Proxy-Supported / Range / RTP-Info / Scale / Seek-Style / Server / Session / Speed / Supported / Timestamp / Transport / User-Agent / Via / extension-header",
      "ja": "一般ヘッダ=受け入れ-範囲/のCache-Control /接続/のCSeq /日付/メディア・プロパティ/メディアレンジ/パイプライン-要求/プロキシ・サポート/レンジ/ RTP-情報/スケール/シークスタイル/サーバ/セッション/スピード/サポート/タイムスタンプ/トランスポート/ユーザーエージェント/経由/拡張ヘッダ"
    },
    {
      "indent": 3,
      "text": "request-header = Accept / Accept-Credentials / Accept-Encoding / Accept-Language / Authorization / Bandwidth / Blocksize / From / If-Match / If-Modified-Since / If-None-Match / Notify-Reason / Proxy-Authorization / Proxy-Require / Referrer / Request-Status / Require / Terminate-Reason / extension-header",
      "ja": "リクエストヘッダ=受け入れる/受け入れ、資格情報/受け入れエンコード/のAccept-Language /言語の許可/帯域幅/ブロックサイズ/から/ IF-マッチ/変更 - 開始/ IF-なしマッチ/通知-理由/プロキシ認証/プロキシ要求/リファラー/リクエスト・ステータス/要求/終了-理由/拡張ヘッダ"
    },
    {
      "indent": 3,
      "text": "response-header = Authentication-Info / Connection-Credentials / Location / MTag / Proxy-Authenticate / Proxy-Authentication-Info / Public / Retry-After / Unsupported / WWW-Authenticate / extension-header",
      "ja": "レスポンス・ヘッダー=認証-INFO /接続-クレデンシャル/ロケーション/ MTAG /プロキシ認証/プロキシ認証-INFO /パブリック/リトライ後/サポートされていない/ WWW認証/拡張ヘッダ"
    },
    {
      "indent": 3,
      "text": "message-body-header = Allow / Content-Base / Content-Encoding / Content-Language / Content-Length / Content-Location / Content-Type / Expires / Last-Modified / extension-header",
      "ja": "メッセージボディヘッダ=許可/コンテンツベース/コンテンツ符号化/コンテンツ言語/コンテンツ長/コンテンツロケーション/コンテンツタイプ/有効期限/最終変性/拡張ヘッダ"
    },
    {
      "indent": 0,
      "text": "20.2.3. Header Syntax",
      "section_title": true,
      "ja": "20.2.3. ヘッダーの構文"
    },
    {
      "indent": 3,
      "text": "Accept            =  \"Accept\" HCOLON\n                     [ accept-range *(COMMA accept-range) ]\naccept-range      =  media-type-range [SEMI accept-params]\nmedia-type-range  =  ( \"*/*\"\n                     / ( m-type SLASH \"*\" )\n                     / ( m-type SLASH m-subtype )\n                    ) *( SEMI m-parameter )\naccept-params     =  \"q\" EQUAL qvalue *(SEMI generic-param )\nqvalue            =  ( \"0\" [ \".\" *3DIGIT ] )\n                  /  ( \"1\" [ \".\" *3(\"0\") ] )\nAccept-Credentials =  \"Accept-Credentials\" HCOLON cred-decision\ncred-decision     =  (\"User\" [LWS cred-info])\n                  /  \"Proxy\"\n                  /  \"Any\"\n                  /  (token [LWS 1*header-value])\n                                  ; For future extensions\ncred-info         =  cred-info-data *(COMMA cred-info-data)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "cred-info-data = DQUOTE RTSP-REQ-URI DQUOTE SEMI hash-alg SEMI base64 hash-alg = \"sha-256\" / extension-alg extension-alg = token Accept-Encoding = \"Accept-Encoding\" HCOLON",
      "ja": "= DQUOTE RTSP-REQ-URI DQUOTE SEMIハッシュ-ALG SEMI BASE64ハッシュ-ALG = \"SHA-256\" /拡張ALG延長-ALG =トークンのAccept-エンコーディング= \"同意エンコード\" をHCOLON CRED-情報データ"
    },
    {
      "indent": 3,
      "text": " [ encoding *(COMMA encoding) ] encoding = codings [SEMI accept-params] codings = content-coding / \"*\" content-coding = \"identity\" / token Accept-Language = \"Accept-Language\" HCOLON language *(COMMA language) language = language-range [SEMI accept-params] language-range = language-tag / \"*\" language-tag = primary-tag *( \"-\" subtag ) primary-tag = 1*8ALPHA subtag = 1*8ALPHA Accept-Ranges = \"Accept-Ranges\" HCOLON acceptable-ranges acceptable-ranges = (range-unit *(COMMA range-unit)) range-unit = \"npt\" / \"smpte\" / \"smpte-30-drop\" / \"smpte-25\" / \"clock\" / extension-format extension-format = token Allow = \"Allow\" HCOLON Method *(COMMA Method) Authentication-Info = \"Authentication-Info\" HCOLON auth-param-list auth-param-list = <As the Authentication-Info element in RFC 7615> Authorization = \"Authorization\" HCOLON credentials credentials = <As defined by RFC 7235>",
      "ja": "[符号化*（COMMAエンコーディング）]エンコード=コーディング[SEMI受け入れる-paramsは】コーディング=コンテンツ符号化/ \"*\" コンテンツコーディング= \"アイデンティティ\" /トークン受け入れ言語= HCOLON言語* \"言語を受け入れ\"（COMMA言語）言語=言語範囲[SEMI受け入れる-paramsは】言語範囲=言語タグ/ \"*\" 言語タグ=プライマリタグ*（ \" - \" サブタグ）一次タグ= 1 * 8ALPHAサブタグ= 1 * 8ALPHA同意-Ranges =許容される-範囲=（レンジユニット*（COMMAレンジ単位））HCOLON許容される-範囲レンジ単位= \"NPT\" / \"SMPTE\" / \"SMPTE-30ドロップ\" \"的な範囲を受け入れ\" /「SMPTE -25\" / \"クロック\" /拡張フォーマットの拡張フォーマット=トークン=許可 \"= <許可\" HCOLON法*（COMMA方法）認証-INFO = \"認証-INFO\" HCOLON AUTH-PARAMリストAUTH-PARAMリストRFC 7615での認証、情報要素として>認可=「許可」HCOLON資格資格= <RFC 7235によって定義されるように>"
    },
    {
      "indent": 3,
      "text": "Bandwidth = \"Bandwidth\" HCOLON 1*19DIGIT",
      "ja": "帯域幅= \"帯域幅\" HCOLON 1 * 19DIGIT"
    },
    {
      "indent": 3,
      "text": "Blocksize = \"Blocksize\" HCOLON 1*9DIGIT",
      "ja": "ブロックサイズ= \"ブロックサイズ\" HCOLON 1 * 9 DIGIT"
    },
    {
      "indent": 3,
      "text": "Cache-Control = \"Cache-Control\" HCOLON cache-directive *(COMMA cache-directive) cache-directive = cache-rqst-directive / cache-rspns-directive",
      "ja": "Cache-Control = \"のCache-Control\" キャッシュディレクティブHCOLON *（COMMA非表示指令）指令非表示=非表示RQST指令/非表示rspns指令"
    },
    {
      "indent": 3,
      "text": "cache-rqst-directive = \"no-cache\" / \"max-stale\" [EQUAL delta-seconds] / \"min-fresh\" EQUAL delta-seconds / \"only-if-cached\" / cache-extension",
      "ja": "キャッシュ-RQSTディレクティブ= \"キャッシュなし\" / \"MAX-古い\" [EQUALデルタ秒] / \"MIN-新鮮な\" EQUALデルタ秒/ \"のみ-IF-キャッシュされた\" /キャッシュの拡張"
    },
    {
      "indent": 3,
      "text": "cache-rspns-directive = \"public\" / \"private\" / \"no-cache\" / \"no-transform\" / \"must-revalidate\" / \"proxy-revalidate\" / \"max-age\" EQUAL delta-seconds / cache-extension",
      "ja": "キャッシュrspnsディレクティブ= \"公共\" / \"プライベート\" / \"キャッシュなし\" / \"無変換\" / \"しなければならない-再検証\" / \"プロキシ再検証\" / \"最大エージング\" EQUALデルタ秒/ cache-拡張"
    },
    {
      "indent": 3,
      "text": "cache-extension = token [EQUAL (token / quoted-string)] delta-seconds = 1*19DIGIT",
      "ja": "キャッシュ延長=トークン[EQUAL（トークン/引用符で囲まれた文字列）]デルタ秒= 1 * 19DIGIT"
    },
    {
      "indent": 3,
      "text": "Connection = \"Connection\" HCOLON connection-token *(COMMA connection-token) connection-token = \"close\" / token",
      "ja": "接続=「接続」HCOLON接続トークン*（COMMA接続トークン）接続トークン=「クローズ」/トークン"
    },
    {
      "indent": 3,
      "text": "Connection-Credentials = \"Connection-Credentials\" HCOLON cred-chain cred-chain = DQUOTE RTSP-REQ-URI DQUOTE SEMI base64",
      "ja": "接続資格情報= \"接続資格情報\" HCOLONクレド鎖CRED-チェーン= DQUOTE RTSP-REQ-URI DQUOTE SEMI BASE64"
    },
    {
      "indent": 3,
      "text": "Content-Base = \"Content-Base\" HCOLON RTSP-URI Content-Encoding = \"Content-Encoding\" HCOLON content-coding *(COMMA content-coding) Content-Language = \"Content-Language\" HCOLON language-tag *(COMMA language-tag) Content-Length = \"Content-Length\" HCOLON 1*19DIGIT Content-Location = \"Content-Location\" HCOLON RTSP-REQ-Ref Content-Type = \"Content-Type\" HCOLON media-type media-type = m-type SLASH m-subtype *(SEMI m-parameter) m-type = discrete-type / composite-type discrete-type = \"text\" / \"image\" / \"audio\" / \"video\" / \"application\" / extension-token composite-type = \"message\" / \"multipart\" / extension-token extension-token = ietf-token / x-token ietf-token = token x-token = \"x-\" token m-subtype = extension-token / iana-token iana-token = token m-parameter = m-attribute EQUAL m-value m-attribute = token m-value = token / quoted-string",
      "ja": "コンテンツ・ベース= \"コンテンツベース\" HCOLON RTSP-URIのコンテンツエンコード= \"コンテンツエンコード\" HCOLONコンテンツコーディング*（COMMAコンテンツコーディング）コンテンツ言語= \"内容言語\" HCOLON言語タグ*（COMMA言語-tag）のContent-Length = \"のContent-Length\" HCOLON 1 * 19DIGITのContent-場所=の \"Content-場所\" HCOLON RTSP-REQ-REFのContent-Type = \"Content-Typeの\" HCOLONメディア型メディアタイプ= M-タイプスラッシュMサブタイプ*（SEMI Mパラメータ）M型=ディスクリート型/複合型は、離散型=「テキスト」/「画像」/「オーディオ」/「ビデオ」/「アプリケーション」/拡張トークン複合型= \"メッセージ\" / \"マルチパート\" /拡張トークン拡張トークン= IETFトークン/ X-トークンIETFトークン=トークンX-トークン= \"X-\" トークンMサブタイプ=拡張トークン/ iana-トークンIANAトークン=トークンM-パラメータ= M-属性EQUALのm値m-属性=トークンm値=トークン/引用符で囲まれた文字列"
    },
    {
      "indent": 3,
      "text": "CSeq = \"CSeq\" HCOLON cseq-nr cseq-nr = 1*9DIGIT Date = \"Date\" HCOLON RTSP-date RTSP-date = date-time ; date-time = <As defined in RFC 5322> Expires = \"Expires\" HCOLON RTSP-date From = \"From\" HCOLON from-spec from-spec = ( name-addr / addr-spec ) *( SEMI from-param ) name-addr = [ display-name ] LAQUOT addr-spec RAQUOT addr-spec = RTSP-REQ-URI / absolute-URI absolute-URI = < As defined in RFC 3986> display-name = *(token LWS) / quoted-string from-param = tag-param / generic-param tag-param = \"tag\" EQUAL token If-Match = \"If-Match\" HCOLON (\"*\" / message-tag-list) message-tag-list = message-tag *(COMMA message-tag) message-tag = [ weak ] opaque-tag weak = \"W/\" opaque-tag = quoted-string",
      "ja": "CSeq = \"のCSeq\" HCOLONののCSeq-NRのCSeq-NR = 1 * 9DIGIT日= \"日付\" HCOLON RTSP-日RTSP-日=日時;日時= <RFCに定義されているように5322>期限= HCOLON \"から\" =からHCOLON RTSP-日付を \"有効期限\" からスペックからスペック=（名前-ADDR / ADDR-SPEC）*（SEMIから-PARAM）名-addr = [表示名] LAQUOT ADDRスペックRAQUOTのADDRスペック= RTSP-REQ-URI /絶対URI絶対URI = <RFC 3986で定義されているよう>表示名= *（トークンLWS）/引用符で囲まれた文字列-PARAM =タグのparam /ジェネリック-paramタグ-のparam = \"タグ\" EQUALトークンもしマッチ= \"もしマッチ\" HCOLON（ \"*\" /メッセージ・タグリスト）メッセージタグリスト=メッセージタグ*（COMMAメッセージタグ）メッセージタグ= [弱]不透明タグ弱=「W /」不透明タグ=引用符で囲まれた文字列"
    },
    {
      "indent": 3,
      "text": "If-Modified-Since = \"If-Modified-Since\" HCOLON RTSP-date If-None-Match = \"If-None-Match\" HCOLON (\"*\" / message-tag-list) Last-Modified = \"Last-Modified\" HCOLON RTSP-date Location = \"Location\" HCOLON RTSP-REQ-URI Media-Properties = \"Media-Properties\" HCOLON [media-prop-list] media-prop-list = media-prop-value *(COMMA media-prop-value) media-prop-value = (\"Random-Access\" [EQUAL POS-FLOAT]) / \"Beginning-Only\" / \"No-Seeking\" / \"Immutable\" / \"Dynamic\" / \"Time-Progressing\" / \"Unlimited\" / (\"Time-Limited\" EQUAL utc-time) / (\"Time-Duration\" EQUAL POS-FLOAT) / (\"Scales\" EQUAL scale-value-list) / media-prop-ext media-prop-ext = token [EQUAL (1*rtsp-unreserved / quoted-string)] scale-value-list = DQUOTE scale-entry *(COMMA scale-entry) DQUOTE scale-entry = scale-value / (scale-value COLON scale-value) scale-value = FLOAT Media-Range = \"Media-Range\" HCOLON [ranges-list] ranges-list = ranges-spec *(COMMA ranges-spec) MTag = \"MTag\" HCOLON message-tag Notify-Reason = \"Notify-Reason\" HCOLON Notify-Reas-val Notify-Reas-val = \"end-of-stream\" / \"media-properties-update\" / \"scale-change\" / Notify-Reason-extension Notify-Reason-extension = token Pipelined-Requests = \"Pipelined-Requests\" HCOLON startup-id startup-id = 1*8DIGIT",
      "ja": "変更された場合は、-ので= \"変更した場合は-ので\" HCOLON RTSP-日のIf-なしマッチ= \"もし-なし - マッチ\" HCOLON（ \"*\" /メッセージ・タグリスト）のLast-Modified =「最終修飾します「HCOLON RTSP-日場所= \"場所\" HCOLON RTSP-REQ-URIメディア・プロパティ= \"メディア・プロパティ\" HCOLON [メディアプロパリスト]メディア - プロプリスト=メディア - プロプ値*（COMMAメディア小道具 - 値）メディアプロパ値=（ \"ランダムアクセス\" [EQUAL POS-FLOAT]）/ \"はじまりのみ\" / \"無探している\" / \"不変\" / \"ダイナミック\" / \"時間進むと\" / \"無制限の」/（ \"期限付き\" EQUAL UTC-時間）/（ \"タイム期間\" EQUAL POS-FLOAT）/（ \"スケール\" EQUALスケール値リスト）/メディア小道具-EXTメディア - プロプEXT =トークン[EQUAL（1 * RTSP-未予約/引用符で囲まれた文字列）]スケール値リストを= DQUOTEスケールエントリ*（COMMAスケールエントリ）DQUOTEスケールエントリ=スケール値/（スケール値結腸スケール値）スケール値= FLOATメディアレンジ= \"メディアレンジ\" HCOLON [範囲リスト]の範囲リスト=範囲スペック*（COMMAレンジ仕様）をMTAG = \"MTAG\" HCOLONメッセージタグ通知-理由=「のnotify-理由」HCOLON通知 - レアS-VAL通知-REAS-VAL = \"エンドオブストリーム\" / \"メディアプロパティ更新\" / \"スケール変更\" /通知-理由拡張通知-理由延長=トークンパイプライン・リクエスト=「Pipelined-リクエスト」HCOLON起動-IDの起動-ID = 1 * 8DIGIT"
    },
    {
      "indent": 3,
      "text": "Proxy-Authenticate = \"Proxy-Authenticate\" HCOLON challenge-list challenge-list = <As defined by the WWW-Authenticate in RFC 7235> Proxy-Authentication-Info = \"Proxy-Authentication-Info\" HCOLON auth-param-list Proxy-Authorization = \"Proxy-Authorization\" HCOLON credentials Proxy-Require = \"Proxy-Require\" HCOLON feature-tag-list feature-tag-list = feature-tag *(COMMA feature-tag) Proxy-Supported = \"Proxy-Supported\" HCOLON [feature-tag-list]",
      "ja": "プロキシ認証は、= \"プロキシ認証\" HCOLONチャレンジリストチャレンジリスト=プロキシ認証 - インフォメーション= \"プロキシ認証-情報\" HCOLONのauth-のparam-リスト<RFC 7235にWWW認証によって定義されているように> Proxy-認証=「プロキシ認証」HCOLON資格情報プロキシ要求=「プロキシ要求する」HCOLONフィーチャータグリスト機能 - タグリスト=フィーチャータグ*（COMMA機能タグ）プロキシサポートされている=「プロキシサポート」HCOLON [機能タグリスト]"
    },
    {
      "indent": 3,
      "text": "Public = \"Public\" HCOLON Method *(COMMA Method)",
      "ja": "公共= \"公開\" HCOLONメソッド*（COMMA方法）"
    },
    {
      "indent": 3,
      "text": "Range = \"Range\" HCOLON ranges-spec",
      "ja": "範囲=「範囲」HCOLON範囲スペック"
    },
    {
      "indent": 3,
      "text": "ranges-spec = npt-range / utc-range / smpte-range / range-ext",
      "ja": "範囲仕様= NPTレンジ/ UTCレンジ/ SMPTE-範囲/範囲-EXT"
    },
    {
      "indent": 3,
      "text": "range-ext = extension-format [EQUAL range-value] range-value = 1*(rtsp-unreserved / quoted-string / \":\" )",
      "ja": "範囲-EXT =拡張フォーマット[EQUAL範囲値]の範囲値= 1 *（RTSP-予約されていない/引用符で囲まれた文字列/ \"：\"）"
    },
    {
      "indent": 3,
      "text": "Referrer = \"Referrer\" HCOLON (absolute-URI / RTSP-URI-Ref) Request-Status = \"Request-Status\" HCOLON req-status-info req-status-info = cseq-info LWS status-info LWS reason-info cseq-info = \"cseq\" EQUAL cseq-nr status-info = \"status\" EQUAL Status-Code reason-info = \"reason\" EQUAL DQUOTE Reason-Phrase DQUOTE Require = \"Require\" HCOLON feature-tag-list",
      "ja": "リファラー= \"リファラー\" HCOLON（絶対URI / RTSP-URI-REF）要求-ステータス= \"要求-ステータス\" HCOLONのREQ-ステータス情報REQ-ステータス情報=のCSeq-情報LWSのステータス情報LWS理由-情報のCSeq -info = \"のCSeq\" EQUALのCSeq-NRステータス情報= \"ステータス\" EQUALステータスコード理由-情報= \"理由\" EQUAL DQUOTE理由-フレーズDQUOTEは= \"必要\" HCOLONフィーチャータグリストを要求します"
    },
    {
      "indent": 3,
      "text": "RTP-Info = \"RTP-Info\" HCOLON [rtsp-info-spec *(COMMA rtsp-info-spec)] rtsp-info-spec = stream-url 1*ssrc-parameter stream-url = \"url\" EQUAL DQUOTE RTSP-REQ-Ref DQUOTE ssrc-parameter = LWS \"ssrc\" EQUAL ssrc HCOLON ri-parameter *(SEMI ri-parameter) ri-parameter = (\"seq\" EQUAL 1*5DIGIT) / (\"rtptime\" EQUAL 1*10DIGIT) / generic-param",
      "ja": "RTP-情報= \"RTP-情報\" HCOLON [RTSP-情報スペック*（COMMA RTSP-情報スペック）] RTSP-情報スペック=ストリームURL 1 * SSRC-パラメータストリーム-URL = \"URL\" EQUAL DQUOTE RTSP -REQ-REF DQUOTE SSRCパラメータ= LWS \"SSRC\" EQUAL SSRC HCOLONのRIパラメータ*（SEMI RIパラメータ）RIパラメータ=（ \"配列\" EQUAL 1 * 5DIGIT）/（ \"rtptime\" EQUAL 1 * 10DIGIT）/ジェネリック-PARAM"
    },
    {
      "indent": 3,
      "text": "Retry-After = \"Retry-After\" HCOLON (RTSP-date / delta-seconds) Scale = \"Scale\" HCOLON scale-value Seek-Style = \"Seek-Style\" HCOLON Seek-S-values Seek-S-values = \"RAP\" / \"CoRAP\" / \"First-Prior\" / \"Next\" / Seek-S-value-ext Seek-S-value-ext = token",
      "ja": "リトライ後= \"再試行後\" HCOLON（RTSP日付/デルタ秒）スケール= \"スケール\" HCOLONスケール値シークスタイル= \"シークスタイル\" HCOLONシークS値シーク-S-値= \" RAP」/ \"CoRAP\" / \"ファースト前\" / \"次へ\" /シークS値-EXTシークS値-EXT =トークン"
    },
    {
      "indent": 3,
      "text": "Server = \"Server\" HCOLON ( product / comment ) *(LWS (product / comment)) product = token [SLASH product-version] product-version = token comment = LPAREN *( ctext / quoted-pair) RPAREN",
      "ja": "サーバー= \"サーバー\" HCOLON（製品/コメント）*（LWS（製品/コメント））製品=トークン[SLASH製品バージョン]製品バージョン=トークンコメント= LPAREN *（CTEXT /引用されたペア）RPAREN"
    },
    {
      "indent": 3,
      "text": "Session = \"Session\" HCOLON session-id [ SEMI \"timeout\" EQUAL delta-seconds ]",
      "ja": "セッション=「セッション」HCOLONセッションID [SEMI「タイムアウト」EQUALデルタ - 秒]"
    },
    {
      "indent": 3,
      "text": "Speed = \"Speed\" HCOLON lower-bound MINUS upper-bound lower-bound = POS-FLOAT upper-bound = POS-FLOAT",
      "ja": "スピード= \"スピード\" HCOLON下限MINUS上限下限= POS-FLOAT上限= POS-FLOAT"
    },
    {
      "indent": 3,
      "text": "Supported = \"Supported\" HCOLON [feature-tag-list]",
      "ja": "サポートされている=「サポート」HCOLON [機能タグリスト]"
    },
    {
      "indent": 3,
      "text": "Terminate-Reason = \"Terminate-Reason\" HCOLON TR-Info TR-Info = TR-Reason *(SEMI TR-Parameter) TR-Reason = \"Session-Timeout\" / \"Server-Admin\" / \"Internal-Error\" / token TR-Parameter = TR-time / TR-user-msg / generic-param TR-time = \"time\" EQUAL utc-time TR-user-msg = \"user-msg\" EQUAL quoted-string",
      "ja": "終了-理由= \"終了-理由\" HCOLON TR-情報TR-情報= TR-理由*（SEMI TR-パラメータ）TR-理由= \"セッションタイムアウト\" / \"サーバー管理\" / \"内部-エラー\" /トークンをTR-パラメータ= TR-時間/ TR-ユーザー-MSG /ジェネリック-PARAM TR-時間= \"時間\" EQUAL UTC-時間TR-ユーザー-MSG = \"ユーザー-MSG\" EQUALは引用符で囲まれた文字列"
    },
    {
      "indent": 3,
      "text": "Timestamp = \"Timestamp\" HCOLON timestamp-value [LWS delay] timestamp-value = *19DIGIT [ \".\" *9DIGIT ] delay = *9DIGIT [ \".\" *9DIGIT ]",
      "ja": "タイムスタンプ= \"タイムスタンプ\" HCOLONスタンプ値[LWS遅延]タイムスタンプ値= * 19DIGITの[ \"\" * 9DIGIT]遅延= * 9DIGITの[ \"\" * 9DIGIT]"
    },
    {
      "indent": 3,
      "text": "Transport = \"Transport\" HCOLON transport-spec *(COMMA transport-spec) transport-spec = transport-id *trns-parameter transport-id = trans-id-rtp / other-trans trans-id-rtp = \"RTP/\" profile [\"/\" lower-transport] ; no LWS is allowed inside transport-id other-trans = token *(\"/\" token) profile = \"AVP\" / \"SAVP\" / \"AVPF\" / \"SAVPF\" / token lower-transport = \"TCP\" / \"UDP\" / token trns-parameter = (SEMI ( \"unicast\" / \"multicast\" )) / (SEMI \"interleaved\" EQUAL channel [\"-\" channel]) / (SEMI \"ttl\" EQUAL ttl) / (SEMI \"layers\" EQUAL 1*DIGIT) / (SEMI \"ssrc\" EQUAL ssrc *(SLASH ssrc)) / (SEMI \"mode\" EQUAL mode-spec) / (SEMI \"dest_addr\" EQUAL addr-list) / (SEMI \"src_addr\" EQUAL addr-list) / (SEMI \"setup\" EQUAL contrans-setup) / (SEMI \"connection\" EQUAL contrans-con) / (SEMI \"RTCP-mux\") / (SEMI \"MIKEY\" EQUAL MIKEY-Value) / (SEMI trn-param-ext) contrans-setup = \"active\" / \"passive\" / \"actpass\" contrans-con = \"new\" / \"existing\" trn-param-ext = par-name [EQUAL trn-par-value] par-name = token trn-par-value = *(rtsp-unreserved / quoted-string) ttl = 1*3DIGIT ; 0 to 255 ssrc = 8HEX channel = 1*3DIGIT ; 0 to 255 MIKEY-Value = base64 mode-spec = ( DQUOTE mode *(COMMA mode) DQUOTE ) mode = \"PLAY\" / token addr-list = quoted-addr *(SLASH quoted-addr) quoted-addr = DQUOTE (host-port / extension-addr) DQUOTE host-port = ( host [\":\" port] ) / ( \":\" port ) extension-addr = 1*qdtext host = < As defined in RFC 3986> port = < As defined in RFC 3986>",
      "ja": "トランスポート= \"輸送\" HCOLON輸送仕様*（COMMAトランスポート仕様）トランスポート仕様=輸送-ID * TRNSパラメータ輸送-ID =トランス -  ID-RTP /他のトランス、トランス -  ID-RTP = \"RTP /\" [「/」下搬送]プロフィール。いいえLWSは、トランスポートID他のトランス=トークン*（ \"/\" トークン）プロフィール= \"AVP\" / \"SAVP\" / \"AVPF\" / \"SAVPF\" 内部許可され/トークン低い輸送= \"TCP\" / \"UDP\" /トークンTRNSパラメータ=（SEMI（ \"ユニキャスト\"）/ \"マルチキャスト\"）/（SEMI \"インターリーブ\" EQUALチャネル[ \" - \" チャネル]）/（SEMI \"TTL\" EQUAL TTL）/（SEMI \"層\" EQUAL 1 * DIGIT）/（SEMI \"SSRC\" EQUAL SSRC *（SLASHのSSRC））/（SEMI \"モード\" EQUALモードスペック）/（SEMI \"dest_addrは\" EQUALのaddr-リスト）/（SEMI \"src_addrを\" EQUALのaddr-リスト） /（SEMI \"セットアップ\" EQUAL contransセットアップ）/（SEMI \"接続\" EQUAL contrans-CON）/（SEMI \"RTCP-MUX\"）/（SEMI \"MIKEY\" EQUAL MIKEY値）/（SEMI TRN-PARAM-EXT PAR-名=トークンTRN）contransセットアップ= \"アクティブ\" / \"受動的\" / \"actpass\" contrans-CON = \"新しい\" / \"既存の\" TRN-PARAM-EXT =パー名[EQUAL TRN-額面] -par値= *（RTSP-予約されていない/引用符で囲まれた文字列）TTL = 1 * 3DIGIT。 0〜255 SSRC = 8HEXチャネル= 1 * 3DIGIT。 0〜255 MIKEY値= BASE64モードスペック=（DQUOTEモード*（COMMAモード）DQUOTE）モード= \"PLAY\" /トークンのaddr-リスト=引用され-addrには*（SLASH引用され-addrに）引用された-addrに= DQUOTE（ホスト-port /拡張ADDR）DQUOTEホストポート=（ホスト[ \"：\" ポート]）/（ \"：\" ポート）拡張-ADDR = 1 * qdtextホスト=で定義されているように、ポート= <<RFC 3986で定義されたように> RFC 3986>"
    },
    {
      "indent": 3,
      "text": "Unsupported = \"Unsupported\" HCOLON feature-tag-list User-Agent = \"User-Agent\" HCOLON ( product / comment ) *(LWS (product / comment)) Via = \"Via\" HCOLON via-parm *(COMMA via-parm) via-parm = sent-protocol LWS sent-by *( SEMI via-params ) via-params = via-ttl / via-maddr / via-received / via-extension via-ttl = \"ttl\" EQUAL ttl via-maddr = \"maddr\" EQUAL host via-received = \"received\" EQUAL (IPv4address / IPv6address) IPv4address = < As defined in RFC 3986> IPv6address = < As defined in RFC 3986> via-extension = generic-param sent-protocol = protocol-name SLASH protocol-version SLASH transport-prot protocol-name = \"RTSP\" / token protocol-version = token transport-prot = \"UDP\" / \"TCP\" / \"TLS\" / other-transport other-transport = token sent-by = host [ COLON port ]",
      "ja": "サポートされていない= \"サポートされていない\" HCOLONフィーチャータグリストのUser-Agent = \"のUser-Agent\" HCOLON（製品/コメント）*（LWS（製品/コメント））を介し= \"経由\" HCOLON経由-PARM *（COMMA経由-PARM送信ごと*ビアparamsは（SEMI）=介し-TTL /ビアMADDR /ビア受信/ビア拡張ビアTTL = \"TTL\" EQUAL TTL-paramsはビア-MADDR）を介して、PARM =送信プロトコルLWS = \"MADDR\" EQUALホスト<RFC 3986で定義されているよう>を介して、受信=介して延長EQUAL（IPv4Addressを/ IPv6address）IPv4Addressを= <RFC 3986で定義されているよう> IPv6address =を \"受信\" = GENERIC-PARAM送信プロトコル=プロトコルに名前SLASHプロトコルバージョンSLASH輸送-PROTプロトコル名= \"RTSP\" /トークン・プロトコル・バージョン=トークン輸送-PROT = \"UDP\" / \"TCP\" / \"TLS\" /その他輸送その他の輸送=トークンが送られたバイ=ホスト[大腸ポート]"
    },
    {
      "indent": 3,
      "text": "WWW-Authenticate = \"WWW-Authenticate\" HCOLON challenge-list",
      "ja": "WWW認証=「WWW認証」HCOLONチャレンジリスト"
    },
    {
      "indent": 0,
      "text": "20.3. SDP Extension Syntax",
      "section_title": true,
      "ja": "20.3.  SDP拡張構文"
    },
    {
      "indent": 3,
      "text": "This section defines in ABNF the SDP extensions defined for RTSP. See Appendix D for the definition of the extensions in text.",
      "ja": "このセクションでは、ABNFでRTSPのために定義されたSDP拡張を定義します。テキスト内の拡張機能の定義については、付録Dを参照してください。"
    },
    {
      "indent": 3,
      "text": "control-attribute = \"a=control:\" *SP RTSP-REQ-Ref CRLF",
      "ja": "コントロール属性= \"A =コントロール：\" * SP RTSP-REQ-REF CRLF"
    },
    {
      "indent": 3,
      "text": "a-range-def = \"a=range:\" ranges-spec CRLF",
      "ja": "レンジ-DEF = \"A =範囲：\" レンジスペックCRLF"
    },
    {
      "indent": 3,
      "text": "a-mtag-def = \"a=mtag:\" message-tag CRLF",
      "ja": "A-mタグ-DEF = \"= mタグ：\" メッセージタグCRLF"
    },
    {
      "indent": 0,
      "text": "21. Security Considerations",
      "section_title": true,
      "ja": "21.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "The security considerations and threats around RTSP and its usage can be divided into considerations around the signaling protocol itself and the issues related to the media-stream delivery. However, when it comes to mitigation of security threats, a threat depending on the media-stream delivery may in fact be mitigated by a mechanism in the signaling protocol.",
      "ja": "RTSPとその使用に関するセキュリティ上の考慮事項と脅威は、シグナリングプロトコル自体の周りに配慮し、メディアストリームの配信に関連する問題に分けることができます。それはセキュリティ上の脅威の軽減に来るときしかし、メディアストリームの配信に応じて、脅威が実際にシグナリングプロトコルメカニズムによって軽減することができます。"
    },
    {
      "indent": 3,
      "text": "There are several chapters and an appendix in this document that define security solutions for the protocol. These sections will be referenced when discussing the threats below. However, the reader should take special notice of the Security Framework (Section 19) and the specification of how to use SRTP and its key-management (Appendix C.1.4) to achieve certain aspects of the media security.",
      "ja": "プロトコルのためのセキュリティソリューションを定義し、この文書に記載されているいくつかの章と付録があります。以下の脅威を議論するときに、これらのセクションが参照されます。しかし、読者は、セキュリティ・フレームワーク（セクション19）とメディアセキュリティの特定の側面を達成するためにSRTPとそのキー管理（付録C.1.4）を使用する方法の仕様の特別な注意を払う必要があります。"
    },
    {
      "indent": 0,
      "text": "21.1. Signaling Protocol Threats",
      "section_title": true,
      "ja": "21.1. シグナリングプロトコルの脅威"
    },
    {
      "indent": 3,
      "text": "This section focuses on issues related to the signaling protocol. Because of the similarity in syntax and usage between RTSP servers and HTTP servers, the security considerations outlined in [RFC7230], [RFC7231], [RFC7232], [RFC7233], [RFC7234], and [RFC7235] apply as well.",
      "ja": "このセクションでは、シグナリングプロトコルに関連する問題に焦点を当てています。 RTSPサーバとHTTPサーバ間の構文および使用方法の類似性、[RFC7230]に概説されたセキュリティ上の考慮事項、[RFC7231]、[RFC7232]のため、[RFC7233]、[RFC7234]、および[RFC7235]は同様に適用されます。"
    },
    {
      "indent": 3,
      "text": "Specifically, please note the following:",
      "ja": "具体的には、以下の点に注意してください。"
    },
    {
      "indent": 3,
      "text": "Abuse of Server Log Information: A server is in the position to save personal data about a user's requests that might identify their media consumption patterns or subjects of interest. This information is clearly confidential in nature, and its handling can be constrained by law in certain countries. Log information needs to be securely stored and appropriate guidelines followed for its analysis. See Section 9.8 of [RFC7230] for additional guidelines.",
      "ja": "サーバーログ情報の乱用：サーバーは、自分のメディア消費パターンや興味の対象を特定する可能性があるユーザーの要求に関する個人データを保存する立場にあります。この情報は、自然の中で明確に機密であり、その取り扱いが特定の国の法律で制約することができます。ログ情報を安全に保存する必要があり、適切なガイドラインは、その分析のために続きます。追加のガイドラインについては、[RFC7230]のセクション9.8を参照してください。"
    },
    {
      "indent": 3,
      "text": "Transfer of Sensitive Information: There is no reason to believe that information transferred in RTSP message, such as the URI and the content of headers, especially the Server, Via, Referrer, and From headers, may be any less sensitive than when used in HTTP. Therefore, all of the precautions regarding the protection of data privacy and user privacy apply to implementers of RTSP clients, servers, and proxies. See Sections 9.3-9.6 of [RFC7231] for further details.",
      "ja": "機密情報の伝達：そのようなURIとヘッダの内容、特にサーバー、経由、リファラー、ようやヘッダから、RTSPメッセージに転送され、その情報を信じるべき理由はありませんが、HTTPで使用した場合よりも任意の少ない感受性がある可能性があります。そのため、データのプライバシーとユーザーのプライバシーの保護に関する注意事項のすべては、RTSPクライアント、サーバ、およびプロキシの実装に適用されます。詳細については、セクション[RFC7231]の9.3から9.6を参照してください。"
    },
    {
      "indent": 9,
      "text": "The RTSP methods defined in this document are primarily used to\nestablish and control the delivery of the media data\nrepresented by the URI; thus, the RTSP message bodies are\ngenerally less sensitive than the ones in HTTP.  Where HTTP\nbodies could contain, for example, your medical records, in\nRTSP, the sensitive video of your medical operation would be in\nthe media stream over the media-transport protocol, not in the\nRTSP message.  Still, one has to take note of what potential\nsensitive information is included in RTSP.  The protection of\nthe media data is separate, can be applied directly between\nclient and server, and is dependent on the media-transport\nprotocol in use.  See Section 21.2 for further discussion.\nThis possibility for separation of security between media- resource content and the signaling protocol mitigates the risk\nof exposing the media content when using hop-by-hop security\nfor RTSP signaling using proxies (Section 19.3).",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Attacks Based On File and Path Names: Though RTSP URIs are opaque handles that do not necessarily have file-system semantics, it is anticipated that many implementations will translate portions of the Request-URIs directly to file-system calls. In such cases, file systems SHOULD follow the precautions outlined in Section 9.1 of [RFC7231], such as checking for \"..\" in path components.",
      "ja": "ファイルとパス名に基づく攻撃は：しかしRTSP URIは必ずしもファイルシステムのセマンティクスを持たない不透明なハンドルです、多くの実装は、システムファイルの呼び出しをするために直接リクエスト-URIの部分を翻訳することが予想されます。このような場合、ファイルシステムは、パスコンポーネントの「..」のチェックとして[RFC7231]のセクション9.1に概説注意事項を、従うべきです。"
    },
    {
      "indent": 3,
      "text": "Personal Information: RTSP clients are often privy to the same information that HTTP clients are (username, location, etc.) and thus should be equally sensitive. See Section 9.8 of [RFC7230], Sections 9.3-9.7 of [RFC7231], and Section 8 of [RFC7234] for further recommendations.",
      "ja": "個人情報：RTSPクライアントは、多くの場合、HTTPクライアントが（ユーザー名、場所など）であり、したがって、平等に敏感でなければならないことと同じ情報に関与しています。 [RFC7230]のセクション9.8、[RFC7231]のセクション9.3から9.7、さらに推奨事項については[RFC7234]のセクション8を参照してください。"
    },
    {
      "indent": 3,
      "text": "Privacy Issues Connected to Accept Headers: Since similar usages of the \"Accept\" headers exist in RTSP as in HTTP, the same caveats outlined in Section 9.4 of [RFC7231] with regard to their use should be followed.",
      "ja": "ヘッダを許可するように接続プライバシーの問題は、「同意する」ヘッダーの同様の用途は、HTTPのようにRTSPに存在するので、それらの使用に関して、[RFC7231]のセクション9.4に概説したものと同じ警告が従わなければなりません。"
    },
    {
      "indent": 3,
      "text": "Establishing Authority: RTSP shares with HTTP the question of how a client communicates with the authoritative source for media streams (Section 9.1 of [RFC7230]). The used DNS servers, the security of the communication, and any possibility of a man in the middle, and the trust in any RTSP proxies all affect the possibility that a client has received a non-authoritative response to a request. Ensuring that a client receives an authoritative response is challenging, although using the secure communication for RTSP signaling (rtsps) simplifies it significantly as the server can provide a hostname identity assertion in the TLS handshake.",
      "ja": "権威の確立：HTTPとRTSP共有クライアントは、メディアストリーム（[RFC7230]のセクション9.1）の信頼できるソースと通信する方法の質問が。使用するDNSサーバ、通信のセキュリティ、そして真ん中の男の可能性、および任意のRTSPプロキシへの信頼は、すべてのクライアントが要求する権限のない応答を受信したという可能性に影響を与えます。 RTSPシグナリング（RTSPS）のためのセキュアな通信を使用しているが、クライアントは、権限の応答が困難である受け取ることを保証することはTLSハンドシェイクにおけるホスト名IDアサーションを提供することができるサーバとして大幅に簡素化されます。"
    },
    {
      "indent": 3,
      "text": "Location Headers and Spoofing: If a single server supports multiple organizations that do not trust each another, then it MUST check the values of the Content-Location header fields in responses that are generated under control of said organizations to make sure that they do not attempt to invalidate resources over which they have no authority (see Section 15.4 of [RFC2616]).",
      "ja": "場所ヘッダーおよびなりすまし：単一のサーバは、それは彼らがしようとしないことを確認すると、組織の制御下で生成された応答のContent-Locationヘッダフィールドの値をチェックしなければなりません、それぞれ別のものを信頼していない複数の組織をサポートしている場合彼らは何の権限を持っていないその上のリソースを無効にする（[RFC2616]のセクション15.4を参照してください）。"
    },
    {
      "indent": 3,
      "text": "In addition to the recommendations in the current HTTP specifications ([RFC7230], [RFC7231], [RFC7232], [RFC7233], [RFC7234], and [RFC7235] as of this writing) and also those of the previous relevant RFCs [RFC2068] [RFC2616], future HTTP specifications may provide additional guidance on security issues.",
      "ja": "現在のHTTP仕様の推奨事項に加えて（これを書いているような[RFC7230]、[RFC7231]、[RFC7232]、[RFC7233]、[RFC7234]及び[RFC7235]）、また、それらの前の関連するRFCの[RFC2068 ] [RFC2616]、将来のHTTP仕様は、セキュリティ上の問題に関する追加のガイダンスを提供することができます。"
    },
    {
      "indent": 3,
      "text": "The following are added considerations for RTSP implementations.",
      "ja": "以下は、RTSPの実装のための考慮事項を追加されます。"
    },
    {
      "indent": 3,
      "text": "Session Hijacking: Since there is no or little relation between a transport-layer connection and an RTSP session, it is possible for a malicious client to issue requests with random session identifiers that could affect other clients of an unsuspecting server. To mitigate this, the server SHALL use a large, random and non-sequential session identifier to minimize the possibility of this kind of attack. However, unless the RTSP signaling is always confidentiality protected, e.g., using TLS, an on-path attacker will be able to hijack a session. Another choice for preventing session hijacking is to use client authentication and only allow the authenticated client creating the session to access that session.",
      "ja": "セッションハイジャックは：トランスポート層の接続とRTSPセッションの間に何のかはほとんど関係がないため、悪意のあるクライアントは、疑うことを知らない、サーバーの他のクライアントに影響を与える可能性がランダムなセッション識別子を持つ要求を発行することが可能です。これを緩和するために、サーバーは、この種の攻撃の可能性を最小限に抑えるために、大規模なランダムおよび非連続のセッション識別子を使用しなければなりません。 RTSPシグナリングが常に機密保護されていない限りしかし、例えば、TLSを使用して、オン・パス攻撃者がセッションをハイジャックすることができるであろう。セッションハイジャックを防ぐためのもう一つの選択肢は、クライアント認証を使用してのみ認証されたクライアントは、そのセッションにアクセスするためのセッションを作成できるようにすることです。"
    },
    {
      "indent": 3,
      "text": "Authentication: Servers SHOULD implement both basic and Digest [RFC2617] authentication. In environments requiring tighter security for the control messages, the transport-layer mechanism TLS [RFC5246] SHOULD be used.",
      "ja": "認証：サーバーは、基本的ダイジェスト[RFC2617]認証の両方を実装する必要があります。制御メッセージのより厳しいセキュリティを必要とする環境では、トランスポート層機構TLS [RFC5246]は使用されるべきです。"
    },
    {
      "indent": 3,
      "text": "Suspicious Behavior: Upon detecting instances of behavior that is deemed a security risk, RTSP servers SHOULD return error code 403 (Forbidden). RTSP servers SHOULD also be aware of attempts to probe the server for weaknesses and entry points and MAY arbitrarily disconnect and ignore further requests from clients that are deemed to be in violation of local security policy.",
      "ja": "不審な行動：セキュリティ上のリスクがあるとみなされる行動のインスタンスを検出すると、RTSPサーバがエラーコード403を返すべきである（禁止）。 RTSPサーバも弱点とエントリポイントのサーバーをプローブするための試みを認識すべきであり、任意に切断し、ローカルセキュリティポリシーに違反であるとみなされるクライアントからのさらなる要求を無視するかもしれません。"
    },
    {
      "indent": 3,
      "text": "TLS through Proxies: If one uses the possibility to connect TLS in multiple legs (Section 19.3), one really needs to be aware of the trust model. This procedure requires trust in all proxies part of the path to the server. The proxies one connects through are identified, assuming the proxies so far connected through are well behaved and fulfilling the trust. The accepted proxies are men in the middle and have access to all that goes on over the TLS connection. Thus, it is important to consider if that trust model is acceptable in the actual application. Further discussion of the actual trust model is in Section 19.3. It is important to note what difference in security properties, if any, may exist with the used media-transport protocol and its security mechanism. Using SRTP and the MIKEY-based key-establishment defined in Appendix C.1.4.1 enables media key-establishment to be done end-to-end without revealing the keys to the proxies.",
      "ja": "プロキシ経由TLS：1は1つが本当に信頼モデルを認識している必要があり、複数の足（セクション19.3）でTLSを接続するための可能性を使用している場合。この手順は、サーバーへのパスのすべてのプロキシ部の信頼が必要です。一つを介して接続プロキシはこれまで介して接続プロキシは行儀と信頼関係を満たすされていると仮定すると、識別されます。受け入れプロキシは途中で男性であり、すべてのことは、TLS接続上に行くへのアクセス権を持っています。したがって、その信頼モデルは、実際のアプリケーションで許容可能である場合に考慮することが重要です。実際の信頼モデルのさらなる議論は、セクション19.3です。任意の場合は、使用するメディア・トランスポート・プロトコルとそのセキュリティ・メカニズムに存在する可能性があるセキュリティプロパティではどのような違い、注意することが重要です。 SRTP付録C.1.4.1で定義されたMIKEYベース鍵確立を使用してメディア鍵確立は、プロキシへの鍵を明らかにすることなく、エンドツーエンドで行われることを可能にします。"
    },
    {
      "indent": 3,
      "text": "Resource Exhaustion: As RTSP is a stateful protocol and establishes resource usage on the server, there is a clear possibility to attack the server by trying to overbook these resources to perform a DoS attack. This attack can be both against ongoing sessions and to prevent others from establishing sessions. RTSP agents will need to have mechanisms to prevent single peers from consuming extensive amounts of resources. The methods for guarding against this are varied and depend on the agent's role and capabilities and policies. Each implementation has to carefully consider its methods and policies to mitigate this threat. There are recommendations regarding the handling of connections in Section 10.7.",
      "ja": "リソースの枯渇：RTSPはステートフルプロトコルで、サーバー上のリソース使用量を確立として、DoS攻撃を実行するために、これらのリソースをオーバーブッキングしようとすることで、サーバーを攻撃する明確な可能性があります。この攻撃は、進行中のセッションに対しての両方にすることができ、セッションを確立するから他人を防ぐために。 RTSPエージェントは、資源の豊富な量を消費するから、単一のピアを防止するための仕組みを持っている必要があります。このに対する保護のための方法は多様であり、エージェントの役割と機能とポリシーに依存します。各実装は慎重にこの脅威を軽減するために、その方法や政策を考慮しなければなりません。 10.7節内の接続の取り扱いに関する推奨事項があります。"
    },
    {
      "indent": 3,
      "text": "The above threats and considerations have resulted in a set of security functions and mechanisms built into or used by the protocol. The signaling protocol relies on two security features defined in the Security Framework (Section 19): namely client authentication using HTTP authentication and TLS-based transport protection of the signaling messages. Both of these mechanisms are required to be implemented by any RTSP agent.",
      "ja": "上記の脅威と考慮事項は、セキュリティ機能とメカニズムに組み込まれたかのプロトコルで使用されるのセットをもたらしました。 HTTP認証およびシグナリングメッセージのTLSベースのトランスポートの保護を使用して、すなわちクライアント認証：シグナリングプロトコルは、セキュリティ・フレームワーク（第19条）で定義された2つのセキュリティ機能に依存しています。これらのメカニズムの両方は、任意のRTSPエージェントによって実装される必要があります。"
    },
    {
      "indent": 3,
      "text": "A number of different security mitigations have been designed into the protocol and will be instantiated if the specification is implemented as written, for example, by ensuring sufficient amounts of entropy in the randomly generated session identifiers when not using client authentication to minimize the risk of session hijacking. When client authentication is used, protection against hijacking will be greatly improved by scoping the accessible sessions to the one this client identity has created. Some of the above threats are such that the implementation of the RTSP functionality itself needs to consider which policy and strategy it uses to mitigate them.",
      "ja": "異なるセキュリティ緩和策の数は、プロトコルに設計されていると書かれた明細書は、例えば、実装されている場合、セッションのリスクを最小限にするためにクライアント認証を使用しない場合、ランダムに生成されたセッション識別子にエントロピーの十分な量を確保することによって、インスタンス化されますハイジャック。クライアント認証を使用する場合は、ハイジャックに対する保護を大幅にこのクライアントIDが作成したものにアクセスできるセッションをスコープによって改善されます。上記の脅威のいくつかは、RTSPの機能自体の実装は、それはそれらを軽減するために使用する方針や戦略を検討する必要があるようなものです。"
    },
    {
      "indent": 0,
      "text": "21.2. Media Stream Delivery Threats",
      "section_title": true,
      "ja": "21.2. メディアストリーム配信の脅威"
    },
    {
      "indent": 3,
      "text": "The fact that RTSP establishes and controls a media-stream delivery results in a set of security issues related to the media streams. This section will attempt to analyze general threats; however, the choice of media-stream transport protocol, such as RTP, will result in some differences in threats and what mechanisms exist to mitigate them. Thus, it becomes important that each specification of a new media-stream transport and delivery protocol usable by RTSP requires its own security analysis. This section includes one for RTP.",
      "ja": "RTSPは、メディアストリームに関連したセキュリティ問題のセットで、メディアストリーム配信結果を確立し、制御しているという事実。このセクションでは、一般的な脅威を分析しようとします。しかし、RTPなどのメディアストリームのトランスポートプロトコルの選択は、それらを軽減するために存在する脅威とどのような仕組みにいくつかの違いになります。したがって、それはRTSPで使用できる新しいメディアストリーム転送および配信プロトコルの各仕様は、独自のセキュリティ分析を必要とすることが重要になります。このセクションでは、RTPのための1つが含まれています。"
    },
    {
      "indent": 3,
      "text": "The set of general threats from or by the media-stream delivery itself are:",
      "ja": "メディアストリーム配信自体からかによって、一般的な脅威のセットは以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "Concentrated Denial-of-Service Attack: The protocol offers the opportunity for a remote-controlled DoS attack, where the media stream is the hammer in that DoS attack. See Section 21.2.1.",
      "ja": "集中サービス拒否攻撃：プロトコルはメディアストリームがそのDoS攻撃でハンマーで遠隔制御DoS攻撃のための機会を提供しています。セクション21.2.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "Media Confidentiality: The media delivery may contain content of any type, and it is not possible, in general, to determine how sensitive this content is from a confidentiality point. Thus, it is a strong requirement that any media delivery protocol supply a method for providing confidentiality of the actual media content. In addition to the media-level confidentiality, it becomes critical that no resource identifiers used in the signaling be exposed to an attacker as they may have human-understandable names or may be available to the attacker, allowing it to determine the content the user received. Thus, the signaling protocol must also provide confidentiality protection of any information related to the media resource.",
      "ja": "メディア機密性：メディア配信は、あらゆるタイプのコンテンツを含むことができ、そしてそれは、このコンテンツは、機密性の観点からどのように敏感決定するために、一般的には、可能ではありません。したがって、任意のメディア配信プロトコルは、実際のメディアコンテンツの機密性を提供するための方法を提供し、強力な要件です。メディアレベルの機密性に加えて、それは、ユーザが受信したコンテンツを決定することができ、これらは人間が理解名を有していてもよく、または攻撃者に利用可能とすることができるようにシグナリングに使用されるいかなるリソース識別子が攻撃にさらさないことが重要となります。このように、シグナリングプロトコルは、メディアリソースに関連するあらゆる情報の機密性保護を提供する必要があります。"
    },
    {
      "indent": 3,
      "text": "Media Integrity and Authentication: There are several reasons why an attacker will be interested in substituting the media stream sent out from the RTSP server with one of the attacker's creation or selection, such as discrediting the target and misinformation about the target. Therefore, it is important that the media protocol provide mechanisms to verify the source authentication and integrity and to prevent replay attacks on the media stream.",
      "ja": "メディア整合性と認証：そのようなターゲットに関するターゲットと誤報信用を落とすように、攻撃者は攻撃者の作成または選択の一つとRTSPサーバから送出されたメディアストリームを代入することに興味があるだろう理由はいくつかあります。したがって、メディアプロトコルは、ソース認証と完全性を検証するために、メディアストリームのリプレイ攻撃を防ぐためのメカニズムを提供することが重要です。"
    },
    {
      "indent": 3,
      "text": "Scope of Multicast: If RTSP is used to control the transmission of media onto a multicast network, the scope of the delivery must be considered. RTSP supports the TTL Transport header parameter to indicate this scope for IPv4. IPv6 has a different mechanism for the scope boundary. However, such scope control has risks, as it may be set too large and distribute media beyond the intended scope.",
      "ja": "マルチキャストの範囲：RTSPマルチキャストネットワーク上のメディアの送信を制御するために使用される場合、配達の範囲を考慮しなければなりません。 RTSPは、IPv4のために、この範囲を示すTTLトランスポートヘッダパラメータをサポートします。 IPv6は、スコープの境界に異なる機構を有しています。それはあまりにも大きく設定し、意図した範囲を超えてメディアを配布することができるようしかし、そのような範囲の制御は、リスクがあります。"
    },
    {
      "indent": 3,
      "text": "Below (Section 21.2.2) a protocol-specific analysis of security considerations for RTP-based media transport is included. In that section, the requirements on implementing security functions for RTSP agents supporting media delivery over RTP are made clear.",
      "ja": "（セクション21.2.2）RTPベースのメディア転送のためのセキュリティの考慮事項のプロトコル固有の分析が含まれているの下に。そのセクションでは、RTSPエージェントはRTP上でメディア配信をサポートするためのセキュリティ機能を実装上の要件が明確に作られています。"
    },
    {
      "indent": 0,
      "text": "21.2.1. Remote DoS Attack",
      "section_title": true,
      "ja": "21.2.1. リモートのDoS攻撃"
    },
    {
      "indent": 3,
      "text": "The attacker may initiate traffic flows to one or more IP addresses by specifying them as the destination in SETUP requests. While the attacker's IP address may be known in this case, this is not always useful in the prevention of more attacks or ascertaining the attacker's identity. Thus, an RTSP server MUST only allow client-specified destinations for RTSP-initiated traffic flows if the server has ensured that the specified destination address accepts receiving media through different security mechanisms. Security mechanisms that are acceptable in order of increasing generality are:",
      "ja": "トラフィックを開始することができる攻撃者は、SETUP要求の宛先として指定することにより、1つ以上のIPアドレスに流れます。攻撃者のIPアドレスが、この場合には知られているかもしれないが、これは常により多くの攻撃や攻撃者の身元を確認するの予防に有用ではありません。このように、RTSPサーバは、サーバが指定した宛先アドレスが異なるセキュリティ・メカニズムを通じてメディアを受信受け入れることを保証している場合RTSP-開始されるトラフィックのためのクライアント指定の宛先が流れ許容しなければなりません。一般性を高めるために、許容されているセキュリティ・メカニズムは、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o Verification of the client's identity against a database of known users using RTSP authentication mechanisms (preferably Digest authentication or stronger)",
      "ja": "RTSPの認証メカニズムを使用して、既知のユーザーのデータベース（好ましくはダイジェスト認証または強い）に対するクライアントのアイデンティティのO検証"
    },
    {
      "indent": 3,
      "text": "o A list of addresses that have consented to be media destinations, especially considering user identity",
      "ja": "特に、ユーザのアイデンティティを考慮し、メディアの目的地であることを同意したアドレスのリストO"
    },
    {
      "indent": 3,
      "text": "o Verification based on media path",
      "ja": "O検証メディアパスに基づいて、"
    },
    {
      "indent": 3,
      "text": "The server SHOULD NOT allow the destination field to be set unless a mechanism exists in the system to authorize the request originator to direct streams to the recipient. It is preferred that this authorization be performed by the media recipient (destination) itself and the credentials be passed along to the server. However, in certain cases, such as when the recipient address is a multicast group or when the recipient is unable to communicate with the server in an out-of-band manner, this may not be possible. In these cases, the server may choose another method such as a server-resident authorization list to ensure that the request originator has the proper credentials to request stream delivery to the recipient.",
      "ja": "機構は、レシピエントへの直接ストリームへの要求元を認証するシステムに存在しない限り、サーバは、宛先フィールドが設定されることを可能にするべきではありません。この承認は、サーバーに渡されるメディアの受け手（宛先）自身と資格情報によって行われることが好ましいです。しかしながら、このような受信者のアドレスがマルチキャストグループであるか、または受信者がアウトオブバンド方法でサーバと通信できない場合、これは可能ではないかもしれない場合など、特定の場合、です。これらのケースでは、サーバは、要求元の受信者にストリーム配信を要求するために適切な資格情報を持っていることを保証するために、サーバー常駐認証リストとして、別の方法を選択することができます。"
    },
    {
      "indent": 3,
      "text": "One solution that performs the necessary verification of acceptance of media suitable for unicast-based delivery is the NAT traversal method based on Interactive Connectivity Establishment (ICE) [RFC5245] described in [RFC7825]. This mechanism uses random passwords and a username so that the probability of unintended indication as a valid media destination is very low. In addition, the server includes in its Session Traversal Utilities for NAT (STUN) [RFC5389] requests a cookie (consisting of random material) that the destination echoes back; thus, the solution also safeguards against having an off-path attacker being able to spoof the STUN checks. This leaves this solution vulnerable only to on-path attackers that can see the STUN requests go to the target of attack and thus forge a response.",
      "ja": "ユニキャストベースの送達に適した媒体の受け入れに必要な検証を実行する一つの解決策は、インタラクティブ接続確立（ICE）[RFC7825]に記載の[RFC5245]に基づいて、NATトラバーサル方法です。有効なメディア先として意図しない表示の確率は非常に低くなるように、このメカニズムは、ランダムなパスワードとユーザー名を使用しています。また、サーバは、NAT（STUN）[RFC5389]のためにそのセッショントラバーサルユーティリティに含まれ、宛先がエコーバックすることを（ランダム材料から成る）クッキーを要求します。従って、また、溶液STUNチェックを偽装することができるオフパス攻撃を有するに対するセーフガード。これは、STUNリクエストが攻撃の対象に行くので、応答を偽造見ることができる上、パス攻撃に対して脆弱このソリューションを残します。"
    },
    {
      "indent": 3,
      "text": "For delivery to multicast addresses, there is a need for another solution that is not specified in this memo.",
      "ja": "マルチキャストアドレスへの配信のために、このメモで指定されていない別の解決策が必要です。"
    },
    {
      "indent": 0,
      "text": "21.2.2. RTP Security Analysis",
      "section_title": true,
      "ja": "21.2.2.  RTPセキュリティ分析"
    },
    {
      "indent": 3,
      "text": "RTP is a commonly used media-transport protocol and has been the most common choice for RTSP 1.0 implementations. The core RTP protocol has been in use for a long time, and it has well-known security properties and the RTP security consideration (Section 9 of [RFC3550]) needs to be reviewed. In perspective of the usage of RTP in the context of RTSP, the following properties should be noted:",
      "ja": "RTPは、一般的に使用されるメディア・トランスポート・プロトコルであり、RTSP 1.0の実装のための最も一般的な選択肢となっています。コアRTPプロトコルは、長い間使用されており、それは既知のセキュリティ特性を有し、RTPセキュリティ考察（[RFC3550]のセクション9）を検討する必要があります。 RTSPの文脈におけるRTPの使用の観点では、次の特性が注目されるべきです。"
    },
    {
      "indent": 3,
      "text": "Stream Additions: RTP has support for multiple simultaneous media streams in each RTP session. As some use cases require support for non-synchronized adding and removal of media streams and their identifiers, an attacker can easily insert additional media streams into a session context that, according to protocol design, is intended to be played out. Another threat vector is one of DoS by exhausting the resources of the RTP session receiver, for example, by using a large number of SSRC identifiers simultaneously. The strong mitigation of this is to ensure that one cryptographically authenticates any incoming packet flow to the RTP session. Weak mitigations like blocking additional media streams in session contexts easily lead to a DoS vulnerability in addition to preventing certain RTP extensions or use cases that rely on multiple media streams, such as RTP retransmission [RFC4588] to function.",
      "ja": "ストリームの追加：RTPは、各RTPセッションで複数の同時メディアストリームをサポートしています。いくつかのユースケースは、非同期を追加し、メディアストリームとその識別子を除去するためのサポートを必要として、攻撃者は簡単に追加のメディアは、プロトコルの設計に応じて、プレイアウトされることを意図しているセッションコンテキストにストリームを挿入することができます。別の脅威ベクターは、例えば、同時にSSRC識別子の多数を使用してRTPセッションの受信機のリソースを排気することによってDoS攻撃の一つです。この強力な緩和は1つが、暗号RTPセッションへのすべての着信パケットフローを認証することを確認することです。セッション・コンテキストに追加のメディアストリームを遮断するような弱い緩和策が容易に特定のRTP拡張又はRTP再送[RFC4588]などの複数のメディアストリームに依存ユースケースを防止することに加えて、DoS脆弱性につながる機能します。"
    },
    {
      "indent": 3,
      "text": "Forged Feedback: The built-in RTCP also offers a large attack surface for a couple of different types of attacks. One venue is to send RTCP feedback to the media sender indicating large amounts of packet loss and thus trigger a media bitrate adaptation response from the sender resulting in lowered media quality and potentially a shutdown of the media stream. Another attack is to perform a resource-exhaustion attack on the receiver by using many SSRC identifiers to create large state tables and increase the RTCP-related processing demands.",
      "ja": "鍛造フィードバック：ビルトインRTCPも、攻撃の異なるタイプのカップルのための大規模な攻撃面を提供しています。一の会場は、パケット損失の大きな量を示すメディア送信元にRTCPフィードバックを送信し、従って下降メディア品質とメディアストリームの潜在的にシャットダウンを生じさせる送信者からメディアビットレート適応応答を誘発することです。別の攻撃が大きな状態テーブルを作成し、RTCP関連処理の需要を高めるために、多くのSSRC識別子を使用して受信機のリソース枯渇攻撃を実行することです。"
    },
    {
      "indent": 3,
      "text": "RTP/RTCP Extensions: RTP and RTCP extensions generally provide additional and sometimes extremely powerful tools for DoS attacks or service disruption. For example, the Code Control Message [RFC5104] RTCP extensions enables both the lock down of the bitrate to low values and disruption of video quality by requesting intra-frames.",
      "ja": "RTP / RTCPの拡張機能：RTPとRTCPの拡張機能は、一般的にDoS攻撃やサービスの中断のための追加的な、時には非常に強力なツールを提供しています。例えば、コード管理メッセージ[RFC5104] RTCP拡張は、イントラフレームを要求することによって低い値とビデオ品質の破壊にビットレートのロックダウンの両方を可能にします。"
    },
    {
      "indent": 3,
      "text": "Taking into account the above general discussion in Section 21.2 and the RTP-specific discussion in this section, it is clear that it is necessary that a strong security mechanism be supported to protect",
      "ja": "セクション21.2と、このセクションのRTP特有の議論で考慮に上記の一般的な議論を取ると、強力なセキュリティ・メカニズムを保護するために、サポートすることが必要であることは明らかです"
    },
    {
      "indent": 3,
      "text": "RTP. Therefore, this specification has the following requirements on RTP security functions for all RTSP agents that handle media streams and where media-stream transport is completed using RTP.",
      "ja": "RTP。したがって、この仕様は、メディア・ストリーム・トランスポートは、RTPを使用して完了した場合、メディアストリームを処理し、すべてのRTSPエージェントのRTPのセキュリティ機能には、次の要件があります。"
    },
    {
      "indent": 3,
      "text": "RTSP agents supporting RTP MUST implement Secure RTP (SRTP) [RFC3711] and, thus, SAVP. In addition, SAVPF [RFC5124] MUST also be supported if AVPF is implemented. This specification requires no additional cryptographic transforms or configuration values beyond those specified as mandatory to implement in RFC 3711, i.e., AES-CM and HMAC-SHA1. The default key-management mechanism that MUST be implemented is the one defined in MIKEY Key Establishment (Appendix C.1.4.1). The MIKEY implementation MUST implement the necessary functions for MIKEY-RSA-R mode [RFC4738] and the SRTP parameter negotiation necessary to negotiate the supported SRTP transforms and parameters.",
      "ja": "RTPをサポートRTSP剤は、従って、SAVPをセキュアRTP（SRTP）[RFC3711]を実装しなければなりません。 AVPFが実装されている場合に加えて、SAVPF [RFC5124]もサポートしなければなりません。この仕様は、すなわち、AES-CM及びHMAC-SHA1、RFC 3711に実装するために必須と指定されたもの以外の追加の暗号変換または設定値を必要としません。実装しなければならないデフォルトの鍵管理メカニズムはMIKEY鍵確立（付録C.1.4.1）で定義されたものです。 MIKEY実装はMIKEY-RSA-Rモード[RFC4738]とサポートSRTPの変換およびパラメータをネゴシエートするために必要なSRTPパラメータネゴシエーションのために必要な機能を実装しなければなりません。"
    },
    {
      "indent": 0,
      "text": "22. IANA Considerations",
      "section_title": true,
      "ja": "22. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This section describes a number of registries for RTSP 2.0 that have been established and are maintained by IANA. These registries are separate from any registries existing for RTSP 1.0. For each registry, there is a description of the required content, the registration procedures, and the entries that this document registers. For more information on extending RTSP, see Section 2.7. In addition, this document registers three SDP attributes.",
      "ja": "このセクションでは、確立されており、IANAによって維持されているRTSP 2.0のレジストリの数を記載しています。これらのレジストリは、RTSP 1.0のために、既存のすべてのレジストリとは別のものです。各レジストリのために、必要なコンテンツの記述、登録手順、および本文書は、レジスタのエントリがあります。 RTSPを拡張する方法の詳細については、2.7節を参照してください。また、この文書は3つのSDP属性を登録します。"
    },
    {
      "indent": 3,
      "text": "Registries or entries in registries that have been made for RTSP 1.0 are not moved to RTSP 2.0: the registries and entries of RTSP 1.0 and RTSP 2.0 are independent. If any registry or entry in a registry is also required in RTSP 2.0, it MUST follow the procedure defined below to allocate the registry or entry in a registry.",
      "ja": "RTSP 1.0のために作られているレジストリでレジストリまたはエントリがRTSP 2.0に移動されません：RTSP 1.0およびRTSP 2.0のレジストリエントリとは独立しています。レジストリ内の任意のレジストリまたはエントリもRTSP 2.0で必要とされる場合、それは、レジストリのレジストリまたはエントリを割り当てるには、以下の定義された手順に従わなければなりません。"
    },
    {
      "indent": 3,
      "text": "The sections describing how to register an item use some of the registration policies described in [RFC5226] -- namely, \"First Come First Served\", \"Expert Review\", \"Specification Required\", and \"Standards Action\".",
      "ja": "すなわち、「エキスパートレビュー」、「仕様が必要」、および「標準アクション」、「まず第一に役立っ是非」 - セクションでは、[RFC5226]で説明した登録ポリシーの一部を使用するアイテムを登録する方法を説明します。"
    },
    {
      "indent": 3,
      "text": "In case a registry requires a contact person, the authors (with Magnus Westerlund <magnus.westerlund@ericsson.com> as primary) are the contact persons for any entries created by this document.",
      "ja": "場合は、レジストリは、連絡担当者を必要とし、（プライマリとしてマグヌスウェスター<magnus.westerlund@ericsson.com>との）著者は、この文書で作成されたすべてのエントリのための担当者です。"
    },
    {
      "indent": 3,
      "text": "IANA will request the following information for any registration request:",
      "ja": "IANAは、任意の登録要求のために、以下の情報を要求します："
    },
    {
      "indent": 3,
      "text": "o A name of the item to register according to the rules specified by the intended registry",
      "ja": "O項目の名前は、意図レジストリで指定された規則に従って登録します"
    },
    {
      "indent": 3,
      "text": "o Indication of who has change control over the feature (for example, the IETF, ISO, ITU-T, other international standardization bodies, a consortium, a particular company or group of companies, or an individual)",
      "ja": "O機能の制御を変更する持っている者の指示（例えば、IETF、ISO、ITU-T、他の国際標準化機関、コンソーシアム、特定の企業や企業グループ、または個別）"
    },
    {
      "indent": 3,
      "text": "o A reference to a further description, if available, for example (in decreasing order of preference), an RFC, a published standard, a published paper, a patent filing, a technical report, documented source code or a computer manual",
      "ja": "さらに説明を参照O、利用可能な場合、例えば（優先順に）、RFC、公開された標準、発表された論文、特許出願、技術レポート、文書ソースコードまたはコンピュータ・マニュアル"
    },
    {
      "indent": 3,
      "text": "o For proprietary features, contact information (postal and email address)",
      "ja": "O独自の機能については、連絡先情報（郵便、電子メールアドレス）"
    },
    {
      "indent": 0,
      "text": "22.1. Feature Tags",
      "section_title": true,
      "ja": "22.1. フィーチャータグ"
    },
    {
      "indent": 0,
      "text": "22.1.1. Description",
      "section_title": true,
      "ja": "22.1.1. 説明"
    },
    {
      "indent": 3,
      "text": "When a client and server try to determine what part and functionality of the RTSP specification and any future extensions that its counterpart implements, there is need for a namespace. This registry contains named entries representing certain functionality.",
      "ja": "クライアントとサーバは、RTSPの仕様とその対応の実装は、名前空間が必要とされるすべての将来の拡張のどの部分と機能性を決定しようとします。このレジストリは、特定の機能を表す名前のエントリが含まれています。"
    },
    {
      "indent": 3,
      "text": "The usage of feature tags is explained in Section 11 and Section 13.1.",
      "ja": "フィーチャータグの使用は、セクション11とセクション13.1で説明されています。"
    },
    {
      "indent": 0,
      "text": "22.1.2. Registering New Feature Tags with IANA",
      "section_title": true,
      "ja": "22.1.2.  IANAでの新機能タグを登録します"
    },
    {
      "indent": 3,
      "text": "The registering of feature tags is done on a First Come, First Served [RFC5226] basis.",
      "ja": "フィーチャータグの登録は、最初に行われはじめ[RFC5226]の基礎を務め、来ます。"
    },
    {
      "indent": 3,
      "text": "The registry entry for a feature tag has the following information:",
      "ja": "フィーチャータグのレジストリエントリは、次の情報があります。"
    },
    {
      "indent": 3,
      "text": "o The name of the feature tag",
      "ja": "フィーチャータグの名前O"
    },
    {
      "indent": 6,
      "text": "* If the registrant indicates that the feature is proprietary, IANA should request a vendor \"prefix\" portion of the name. The name will then be the vendor prefix followed by a \".\" followed by the rest of the provided feature name.",
      "ja": "*登録者は、機能は独自のものであることを示している場合、IANAは名前のベンダー「接頭辞」の部分を要求する必要があります。名前はその後、Aに続くベンダー接頭辞になります「」提供される機能名の残りの部分が続きます。"
    },
    {
      "indent": 6,
      "text": "* If the feature is not proprietary, then IANA need not collect a prefix for the name.",
      "ja": "*機能はない独自の場合は、IANAは名前の接頭辞を収集する必要はありません。"
    },
    {
      "indent": 3,
      "text": "o A one-paragraph description of what the feature tag represents",
      "ja": "O機能タグが何を表すかのいずれかのパラグラフの説明"
    },
    {
      "indent": 3,
      "text": "o The applicability (server, client, proxy, or some combination)",
      "ja": "O適用（サーバー、クライアント、プロキシ、またはいくつかの組み合わせ）"
    },
    {
      "indent": 3,
      "text": "o A reference to a specification, if applicable",
      "ja": "該当する場合、仕様を参照O"
    },
    {
      "indent": 3,
      "text": "Feature tag names (including the vendor prefix) may contain any non-space and non-control characters. There is no length limit on feature tags.",
      "ja": "（ベンダープレフィックスを含む）フィーチャータグ名は、任意の非スペースと非制御文字を含めることができます。機能タグには長さの制限はありません。"
    },
    {
      "indent": 3,
      "text": "Examples for a vendor tag describing a proprietary feature are:",
      "ja": "独自の機能を記述したベンダータグの例は以下のとおりです。"
    },
    {
      "indent": 9,
      "text": "vendorA.specfeat01",
      "ja": "vendora.spetsfeat01"
    },
    {
      "indent": 9,
      "text": "vendorA.specfeat02",
      "ja": "vendora.spetsfeat02"
    },
    {
      "indent": 0,
      "text": "22.1.3. Registered Entries",
      "section_title": true,
      "ja": "22.1.3. 登録されたエントリ"
    },
    {
      "indent": 3,
      "text": "The following feature tags are defined in this specification and hereby registered. The change control belongs to the IETF.",
      "ja": "次の機能のタグは、この仕様で定義され、ここに登録されています。変更管理は、IETFに属します。"
    },
    {
      "indent": 3,
      "text": "play.basic: The implementation for delivery and playback operations according to the core RTSP specification, as defined in this memo. Applies for clients, servers, and proxies. See Section 11.1.",
      "ja": "play.basic：コアRTSP仕様に従って配信と再生操作の実装は、このメモで定義されています。クライアント、サーバ、およびプロキシに適用されます。 11.1節を参照してください。"
    },
    {
      "indent": 3,
      "text": "play.scale: Support of scale operations for media playback. Applies only for servers. See Section 18.46.",
      "ja": "play.scale：メディア再生のためのスケール操作のサポート。サーバーにのみ適用されます。セクション18.46を参照してください。"
    },
    {
      "indent": 3,
      "text": "play.speed: Support of the speed functionality for media delivery. Applies only for servers. See Section 18.50.",
      "ja": "play.speed：メディア配信のための高速機能のサポート。サーバーにのみ適用されます。セクション18.50を参照してください。"
    },
    {
      "indent": 3,
      "text": "setup.rtp.rtcp.mux: Support of the RTP and RTCP multiplexing as discussed in Appendix C.1.6.4. Applies for both client and servers and any media caching proxy.",
      "ja": "setup.rtp.rtcp.mux：付録C.1.6.4で説明したようにRTPとRTCPの多重化のサポート。クライアントとサーバーと任意のメディアキャッシングプロキシの両方に適用されます。"
    },
    {
      "indent": 3,
      "text": "The IANA registry is a table with the name, description, and reference for each feature tag.",
      "ja": "IANAレジストリは名前、説明、および各特徴タグの参照を持つテーブルです。"
    },
    {
      "indent": 0,
      "text": "22.2. RTSP Methods",
      "section_title": true,
      "ja": "22.2.  RTSPメソッド"
    },
    {
      "indent": 0,
      "text": "22.2.1. Description",
      "section_title": true,
      "ja": "22.2.1. 説明"
    },
    {
      "indent": 3,
      "text": "Methods are described in Section 13. Extending the protocol with new methods allows for totally new functionality.",
      "ja": "メソッドは、新しいメソッドを持つプロトコルは全く新しい機能を可能に延びる部分13に記載されています。"
    },
    {
      "indent": 0,
      "text": "22.2.2. Registering New Methods with IANA",
      "section_title": true,
      "ja": "22.2.2.  IANAとの新しいメソッドを登録します"
    },
    {
      "indent": 3,
      "text": "A new method is registered through a Standards Action [RFC5226] because new methods may radically change the protocol's behavior and purpose.",
      "ja": "新しい方法は根本プロトコルの動作と目的を変更する可能性があるため、新たな方法は、標準アクション[RFC5226]を通じて登録されています。"
    },
    {
      "indent": 3,
      "text": "A specification for a new RTSP method consists of the following items:",
      "ja": "新しいRTSPメソッドの仕様は以下の項目で構成されています。"
    },
    {
      "indent": 3,
      "text": "o A method name that follows the ABNF rules for methods.",
      "ja": "メソッドのABNF規則に従うメソッド名O。"
    },
    {
      "indent": 3,
      "text": "o A clear specification of what a request using the method does and what responses are expected. In which directions the method is used: C->S, S->C, or both. How the use of headers, if any, modifies the behavior and effect of the method.",
      "ja": "メソッドを使用して要求を行い、どのような応答が期待されているかの明確な仕様O。どの方向に方法が使用される：C-> S、S-> C、またはその両方。どのようにヘッダの使用は、もしあれば、メソッドの動作と効果を変更します。"
    },
    {
      "indent": 3,
      "text": "o A list or table specifying which of the IANA-registered headers that are allowed to be used with the method in the request or/and response. The list or table SHOULD follow the format of tables in Section 18.",
      "ja": "要求および/または応答における方法で使用することが許可されているIANAに登録ヘッダのリストまたはテーブル指定O。リストまたは表は、セクション18内のテーブルのフォーマットに従ってください。"
    },
    {
      "indent": 3,
      "text": "o Describe how the method relates to network proxies.",
      "ja": "O方法は、ネットワークプロキシに関する方法を説明できます。"
    },
    {
      "indent": 0,
      "text": "22.2.3. Registered Entries",
      "section_title": true,
      "ja": "22.2.3. 登録されたエントリ"
    },
    {
      "indent": 3,
      "text": "This specification, RFC 7826, registers 10 methods: DESCRIBE, GET_PARAMETER, OPTIONS, PAUSE, PLAY, PLAY_NOTIFY, REDIRECT, SETUP, SET_PARAMETER, and TEARDOWN. The initial table of the registry is provided below.",
      "ja": "DESCRIBE、GET_PARAMETER、OPTIONS、一時停止、再生、PLAY_NOTIFY、REDIRECT、SETUP、SET_PARAMETER、及びTEARDOWN：本明細書、RFC 7826は、10のメソッドを登録します。レジストリの初期表を以下に示します。"
    },
    {
      "indent": 3,
      "text": "Method         Directionality           Reference\n-----------------------------------------------------\nDESCRIBE       C->S                     RFC 7826\nGET_PARAMETER  C->S, S->C               RFC 7826\nOPTIONS        C->S, S->C               RFC 7826\nPAUSE          C->S                     RFC 7826\nPLAY           C->S                     RFC 7826\nPLAY_NOTIFY    S->C                     RFC 7826\nREDIRECT       S->C                     RFC 7826\nSETUP          C->S                     RFC 7826\nSET_PARAMETER  C->S, S->C               RFC 7826\nTEARDOWN       C->S, S->C               RFC 7826",
      "raw": true
    },
    {
      "indent": 0,
      "text": "22.3. RTSP Status Codes",
      "section_title": true,
      "ja": "22.3.  RTSPステータスコード"
    },
    {
      "indent": 0,
      "text": "22.3.1. Description",
      "section_title": true,
      "ja": "22.3.1. 説明"
    },
    {
      "indent": 3,
      "text": "A status code is the three-digit number used to convey information in RTSP response messages; see Section 8. The number space is limited, and care should be taken not to fill the space.",
      "ja": "ステータスコードは、RTSP応答メッセージ内の情報を伝えるために使用される3桁の数です。 8章を参照してください数のスペースが限られており、注意がスペースを埋めるしないように注意してください。"
    },
    {
      "indent": 0,
      "text": "22.3.2. Registering New Status Codes with IANA",
      "section_title": true,
      "ja": "22.3.2.  IANAとの新しいステータスコードを登録します"
    },
    {
      "indent": 3,
      "text": "A new status code registration follows the policy of IETF Review [RFC5226]. New RTSP functionality requiring Status Codes should first be registered in the range of x50-x99. Only when the range is full should registrations be made in the x00-x49 range, unless it is to adopt an HTTP extension to RTSP. This is done to enable any HTTP extension to be adopted to RTSP without needing to renumber any related status codes. A specification for a new status code must include the following:",
      "ja": "新しいステータスコード登録はIETFレビュー[RFC5226]のポリシーに従います。ステータスコードを必要とする新しいRTSP機能は、最初のX50-X99の範囲内に登録する必要があります。範囲がいっぱいになった場合にのみ、それはRTSPにHTTPの拡張機能を採用することでない限り、登録は、X00-X49の範囲内でなされるべきです。これは、任意の関連するステータスコードの番号を変更することなくRTSPを採用する任意のHTTP拡張を可能にするために行われます。新しいステータスコードの仕様は以下を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "o The registered number.",
      "ja": "登録番号O。"
    },
    {
      "indent": 3,
      "text": "o A description of what the status code means and the expected behavior of the sender and receiver of the code.",
      "ja": "Oステータスコードの意味の説明とコードの送信者と受信者の予想される動作。"
    },
    {
      "indent": 0,
      "text": "22.3.3. Registered Entries",
      "section_title": true,
      "ja": "22.3.3. 登録されたエントリ"
    },
    {
      "indent": 3,
      "text": "RFC 7826 (this document) registers the numbered status code defined in the ABNF entry \"Status-Code\", except \"extension-code\" (that defines the syntax allowed for future extensions) in Section 20.2.2.",
      "ja": "RFC 7826（本書）は、セクション20.2.2で（つまり、将来の拡張のために許可される構文を定義）「の拡張コード」を除いて、ABNFエントリ「ステータスコード」で定義されている番号がステータスコードを登録します。"
    },
    {
      "indent": 0,
      "text": "22.4. RTSP Headers",
      "section_title": true,
      "ja": "22.4.  RTSPヘッダー"
    },
    {
      "indent": 0,
      "text": "22.4.1. Description",
      "section_title": true,
      "ja": "22.4.1. 説明"
    },
    {
      "indent": 3,
      "text": "By specifying new headers, one or more methods can be enhanced in many different ways. An unknown header will be ignored by the receiving agent. If the new header is vital for certain functionality, a feature tag for the functionality can be created and demanded to be used by the counterpart with the inclusion of a Require header carrying the feature tag.",
      "ja": "新しいヘッダを指定することで、一の以上の方法は、多くの異なる方法で向上させることができます。未知のヘッダは受信エージェントによって無視されます。新しいヘッダが特定の機能のために不可欠である場合は、機能の特徴タグが作成され、特徴タグを運ぶ必要ヘッダを含めて相手によって使用されるように要求することができます。"
    },
    {
      "indent": 0,
      "text": "22.4.2. Registering New Headers with IANA",
      "section_title": true,
      "ja": "22.4.2.  IANAとの新しいヘッダの登録"
    },
    {
      "indent": 3,
      "text": "Registrations can be made following the Expert Review policy [RFC5226]. A specification is recommended to be provided, preferably an RFC or other specification from a Standards Developing Organization. The minimal information in a registration request is the header name and the contact information.",
      "ja": "登録は専門家の審査方針[RFC5226]以下にすることができます。仕様は、標準開発組織から、好ましくはRFCまたは他の仕様を提供することが推奨されます。登録要求に最小限の情報は、ヘッダ名と連絡先情報です。"
    },
    {
      "indent": 3,
      "text": "The expert reviewer verifies that the registration request contains the following information:",
      "ja": "専門家の審査は、登録要求には、以下の情報が含まれていることを確認します"
    },
    {
      "indent": 3,
      "text": "o The name of the header.",
      "ja": "ヘッダの名前O。"
    },
    {
      "indent": 3,
      "text": "o An ABNF specification of the header syntax.",
      "ja": "ヘッダシンタクスのABNF仕様O。"
    },
    {
      "indent": 3,
      "text": "o A list or table specifying when the header may be used, encompassing all methods, their request or response, and the direction (C->S or S->C).",
      "ja": "Oリストまたはテーブル、ヘッダを使用することができる場合に指定全ての方法を包含する、それらの要求または応答、および方向（C-> S又はS-> C）。"
    },
    {
      "indent": 3,
      "text": "o How the header is to be handled by proxies.",
      "ja": "Oヘッダは、プロキシによって処理される方法。"
    },
    {
      "indent": 3,
      "text": "o A description of the purpose of the header.",
      "ja": "ヘッダの目的の記述O。"
    },
    {
      "indent": 0,
      "text": "22.4.3. Registered Entries",
      "section_title": true,
      "ja": "22.4.3. 登録されたエントリ"
    },
    {
      "indent": 3,
      "text": "All headers specified in Section 18 in RFC 7826 have been registered. The registry includes the header name and reference.",
      "ja": "RFC 7826で、セクション18で指定されたすべてのヘッダが登録されています。レジストリは、ヘッダ名と言及を含みます。"
    },
    {
      "indent": 3,
      "text": "Furthermore, the following legacy RTSP headers defined in other specifications are registered with header name, and reference according to below list. Note: these references may not fulfill all of the above rules for registrations due to their legacy status.",
      "ja": "また、他の仕様で定義された次のレガシーRTSPヘッダはリストの下に係るヘッダ名、および参照して登録されています。注：これらの参照は、そのレガシー状況による登録のために上記のルールのすべてを満たしていないことがあります。"
    },
    {
      "indent": 3,
      "text": "o x-wap-profile defined in [TS-26234]. The x-wap-profile request-header contains one or more absolute URLs to the requesting agent's device-capability profile.",
      "ja": "[TS-26234]で定義されたO X-WAPプロファイル。 X-WAPプロファイルリクエストヘッダは、要求元エージェントのデバイス能力プロファイルに対する1つまたは複数の絶対URLを含んでいます。"
    },
    {
      "indent": 3,
      "text": "o x-wap-profile-diff defined in [TS-26234]. The x-wap-profile-diff request-header contains a subset of a device-capability profile.",
      "ja": "[TS-26234]で定義されたO X-WAP-プロファイルデフ。 X-WAP-プロファイル差分要求ヘッダーは、デバイス能力プロファイルのサブセットを含みます。"
    },
    {
      "indent": 3,
      "text": "o x-wap-profile-warning defined in [TS-26234]. The x-wap-profile-warning is a response-header that contains error codes explaining to what extent the server has been able to match the terminal request in regard to device-capability profiles, as described using x-wap-profile and x-wap-profile-diff headers.",
      "ja": "[TS-26234]で定義されたO X-WAPプロファイル警告。 X-WAPプロファイル警告を説明するエラーコードを含む応答ヘッダでのX-WAPプロファイル及びX-を用いて説明したように、サーバは、デバイス能力プロファイルに関しては、端末の要求と一致することができたどの程度WAP-プロファイル差分ヘッダ。"
    },
    {
      "indent": 3,
      "text": "o x-predecbufsize defined in [TS-26234]. This response-header provides an RTSP agent with the TS 26.234 Annex G hypothetical pre-decoder buffer size.",
      "ja": "[TS-26234]で定義されたO-X predecbufsize。このレスポンス・ヘッダーは、TS 26.234付属書G仮説プリデコーダバッファサイズでRTSP剤を提供します。"
    },
    {
      "indent": 3,
      "text": "o x-initpredecbufperiod defined in [TS-26234]. This response-header provides an RTSP agent with the TS 26.234 Annex G hypothetical pre-decoder buffering period.",
      "ja": "[TS-26234]で定義されたO-X initpredecbufperiod。このレスポンス・ヘッダーは、TS 26.234付属書G仮説プリデコーダバッファ期間とRTSP剤を提供します。"
    },
    {
      "indent": 3,
      "text": "o x-initpostdecbufperiod defined in [TS-26234]. This response-header provides an RTSP agent with the TS 26.234 Annex G post-decoder buffering period.",
      "ja": "[TS-26234]で定義されたO-X initpostdecbufperiod。このレスポンス・ヘッダーは、TS 26.234付録Gポストデコーダバッファ期間とRTSP剤を提供します。"
    },
    {
      "indent": 3,
      "text": "o 3gpp-videopostdecbufsize defined in [TS-26234]. This response-header provides an RTSP agent with the TS 26.234 defined post-decoder buffer size usable for H.264 (AVC) video streams.",
      "ja": "[TS-26234]で定義された入出力3GPP-videopostdecbufsize。このレスポンス・ヘッダーはH.264（AVC）ビデオストリームに使用可能なTS 26.234に定義ポストデコーダバッファサイズでRTSP剤を提供します。"
    },
    {
      "indent": 3,
      "text": "o 3GPP-Link-Char defined in [TS-26234]. This request-header provides the RTSP server with the RTSP client's link characteristics as determined from the radio interface. The information that can be provided are guaranteed bitrate, maximum bitrate and maximum transfer delay.",
      "ja": "O 3GPP-リンクチャーは、[TS-26234]で定義されます。無線インターフェースから決定されるように、このリクエスト・ヘッダーは、RTSPクライアントのリンク特性とRTSPサーバを提供します。提供することができる情報はビットレート、最大ビットレート、最大転送遅延を保証しています。"
    },
    {
      "indent": 3,
      "text": "o 3GPP-Adaptation defined in [TS-26234]. This general-header is part of the bitrate adaptation solution specified for the Packet-switched Streaming Service (PSS). It provides the RTSP client's buffer sizes and target buffer levels to the server, and responses are used to acknowledge the support and values.",
      "ja": "O 3GPP適応は、[TS-26234]で定義されます。この一般的なヘッダは、パケット交換ストリーミングサービス（PSS）に指定されたビットレート適応ソリューションの一部です。これは、サーバーへのRTSPクライアントのバッファサイズと目標バッファレベルを提供し、応答がサポートして値を確認するために使用されています。"
    },
    {
      "indent": 3,
      "text": "o 3GPP-QoE-Metrics defined in [TS-26234]. This general-header is used by PSS RTSP agents to negotiate the quality of experience metrics that a client should gather and report to the server.",
      "ja": "[TS-26234]で定義された3GPP-のQoEメトリクスO。この一般ヘッダは、クライアントが収集し、サーバに報告しなければならない経験メトリックの品質を交渉するPSS RTSPエージェントによって使用されます。"
    },
    {
      "indent": 3,
      "text": "o 3GPP-QoE-Feedback defined in [TS-26234]. This request-header is used by RTSP clients supporting PSS to report the actual values of the metrics gathered in its quality of experience metering.",
      "ja": "O 3GPP-QoEの帰還は、[TS-26234]で定義されます。このリクエストヘッダは経験の計量のその品質に集まったメトリクスの実際の値を報告するPSSをサポートするRTSPクライアントによって使用されています。"
    },
    {
      "indent": 3,
      "text": "The use of \"x-\" is NOT RECOMMENDED, but the above headers in the list were defined prior to the clarification.",
      "ja": "「X-」の使用が推奨されていませんが、リスト中の上記のヘッダは、明確化する前に定義されていました。"
    },
    {
      "indent": 0,
      "text": "22.5. Accept-Credentials",
      "section_title": true,
      "ja": "22.5.  -資格を受け入れます"
    },
    {
      "indent": 3,
      "text": "The security framework's TLS connection mechanism has two registerable entities.",
      "ja": "セキュリティフレームワークのTLS接続機構は、2つの登録可能実体を持っています。"
    },
    {
      "indent": 0,
      "text": "22.5.1. Accept-Credentials Policies",
      "section_title": true,
      "ja": "22.5.1. ポリシー・資格情報の受け入れ"
    },
    {
      "indent": 3,
      "text": "This registry is for policies for an RTSP proxy's handling and verification of TLS certificates when establishing an outbound TLS connection on behalf of a client. In Section 19.3.1, three policies for how to handle certificates are specified. Further policies may be defined; registration is made through Standards Action [RFC5226]. A registration request is required to contain the following information:",
      "ja": "このレジストリは、RTSPプロキシの取り扱いとTLS証明書の検証、クライアントに代わって発信TLS接続を確立するための政策のためです。セクション19.3.1では、証明書を処理する方法のための3つのポリシーが指定されています。また、ポリシーが定義されます。登録は標準アクション[RFC5226]を介して行われます。登録要求は、以下の情報を含むために必要とされています。"
    },
    {
      "indent": 3,
      "text": "o Name of the policy.",
      "ja": "Oポリシーの名前。"
    },
    {
      "indent": 3,
      "text": "o Text that describes how the policy works for handling the certificates.",
      "ja": "ポリシーは、証明書を処理するためにどのように動作するかを説明Oテキスト。"
    },
    {
      "indent": 3,
      "text": "o A contact person.",
      "ja": "担当者O。"
    },
    {
      "indent": 3,
      "text": "This specification registers the following values:",
      "ja": "この仕様は、以下の値を登録します。"
    },
    {
      "indent": 3,
      "text": "Any: A policy requiring the proxy to accept any received certificate.",
      "ja": "任意：任意の受信した証明書を受け入れるようにプロキシを必要とする政策。"
    },
    {
      "indent": 3,
      "text": "Proxy: A policy where the proxy applies its own policies to determine which certificates are accepted.",
      "ja": "プロキシ：プロキシが受け入れられている証明書を決定するために、独自のポリシーを適用するポリシー。"
    },
    {
      "indent": 3,
      "text": "User: A policy where the certificate is required to be forwarded down the proxy chain to the client, thus allowing the user to decided to accept or refuse a certificate.",
      "ja": "ユーザー：証明書は、このように証明書を受け入れるか拒否することを決定したために、ユーザーをできるように、クライアントにプロキシチェーンに転送する必要があるポリシー。"
    },
    {
      "indent": 0,
      "text": "22.5.2. Accept-Credentials Hash Algorithms",
      "section_title": true,
      "ja": "22.5.2. 受け入れ、資格のハッシュアルゴリズム"
    },
    {
      "indent": 3,
      "text": "The Accept-Credentials header (see Section 18.2) allows for the usage of other algorithms for hashing the DER records of accepted entities. The registration of any future algorithm is expected to be extremely rare and could also cause interoperability problems. Therefore, the bar for registering new algorithms is intentionally placed high.",
      "ja": "受け入れ-資格ヘッダ（セクション18.2を参照）を受け入れたエンティティのDERレコードをハッシュするための他のアルゴリズムの使用を可能にします。将来のアルゴリズムの登録は非常にまれであることが予想され、また相互運用性の問題を引き起こす可能性があります。そのため、新しいアルゴリズムを登録するためのバーでは、意図的に高く置かれます。"
    },
    {
      "indent": 3,
      "text": "Any registration of a new hash algorithm requires Standards Action [RFC5226]. The registration needs to fulfill the following requirement:",
      "ja": "新しいハッシュアルゴリズムの任意の登録は標準アクション[RFC5226]を必要とします。登録は、次の要件を満たす必要があります："
    },
    {
      "indent": 3,
      "text": "o The algorithms identifier meeting the \"token\" ABNF requirement.",
      "ja": "アルゴリズム識別子会「トークン」ABNF要件O。"
    },
    {
      "indent": 3,
      "text": "o Provide a definition of the algorithm.",
      "ja": "Oアルゴリズムの定義を提供します。"
    },
    {
      "indent": 3,
      "text": "The registered value is:",
      "ja": "登録された値は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "Hash Alg. ID   Reference\n------------------------\nsha-256        RFC 7826",
      "raw": true
    },
    {
      "indent": 0,
      "text": "22.6. Cache-Control Cache Directive Extensions",
      "section_title": true,
      "ja": "22.6.  Cache-Controlのキャッシュディレクティブの拡張"
    },
    {
      "indent": 3,
      "text": "There exist a number of cache directives that can be sent in the Cache-Control header. A registry for these cache directives has been established by IANA. New registrations in this registry require Standards Action or IESG Approval [RFC5226]. A registration request needs to contain the following information.",
      "ja": "キャッシュ制御ヘッダーで送信することができるキャッシュディレクティブの数が存在します。これらのキャッシュ・ディレクティブのレジストリは、IANAによって確立されています。このレジストリ内の新規登録は標準アクションまたはIESG承認[RFC5226]が必要です。登録要求は、次の情報が含まれている必要があります。"
    },
    {
      "indent": 3,
      "text": "o The name of the cache directive.",
      "ja": "キャッシュディレクティブの名前O。"
    },
    {
      "indent": 3,
      "text": "o A definition of the parameter value, if any is allowed.",
      "ja": "Oパラメータ値の定義は、いずれの場合は許可されています。"
    },
    {
      "indent": 3,
      "text": "o The specification if it is a request or response directive.",
      "ja": "仕様Oそれは、要求または応答指令である場合。"
    },
    {
      "indent": 3,
      "text": "o Text that explains how the cache directive is used for RTSP-controlled media streams.",
      "ja": "キャッシュディレクティブがRTSP制御メディアストリームのために使用されている方法を説明しますOテキスト。"
    },
    {
      "indent": 3,
      "text": "o A contact person.",
      "ja": "担当者O。"
    },
    {
      "indent": 3,
      "text": "This specification registers the following values:",
      "ja": "この仕様は、以下の値を登録します。"
    },
    {
      "indent": 6,
      "text": "no-cache:",
      "ja": "ノーキャッシュません。"
    },
    {
      "indent": 6,
      "text": "public:",
      "ja": "公："
    },
    {
      "indent": 6,
      "text": "private:",
      "ja": "民間："
    },
    {
      "indent": 6,
      "text": "no-transform:",
      "ja": "無変換："
    },
    {
      "indent": 6,
      "text": "only-if-cached:",
      "ja": "唯一-IF-キャッシュされました："
    },
    {
      "indent": 6,
      "text": "max-stale:",
      "ja": "MAX-古いです："
    },
    {
      "indent": 6,
      "text": "min-fresh:",
      "ja": "放散します："
    },
    {
      "indent": 6,
      "text": "must-revalidate:",
      "ja": "-再検証する必要があります。"
    },
    {
      "indent": 6,
      "text": "proxy-revalidate:",
      "ja": "プロキシ再検証："
    },
    {
      "indent": 6,
      "text": "max-age:",
      "ja": "MAX-年齢："
    },
    {
      "indent": 3,
      "text": "The registry contains the name of the directive and the reference.",
      "ja": "レジストリは、ディレクティブおよび参照の名前が含まれています。"
    },
    {
      "indent": 0,
      "text": "22.7. Media Properties",
      "section_title": true,
      "ja": "22.7. メディアのプロパティ"
    },
    {
      "indent": 0,
      "text": "22.7.1. Description",
      "section_title": true,
      "ja": "22.7.1. 説明"
    },
    {
      "indent": 3,
      "text": "The media streams being controlled by RTSP can have many different properties. The media properties required to cover the use cases that were in mind when writing the specification are defined. However, it can be expected that further innovation will result in new use cases or media streams with properties not covered by the ones specified here. Thus, new media properties can be specified. As new media properties may need a substantial amount of new definitions to correctly specify behavior for this property, the bar is intended to be high.",
      "ja": "RTSPによって制御されているメディア・ストリームは、多くの異なる性質を持つことができます。仕様を書くときに念頭に置いていたユースケースをカバーするために必要なメディアのプロパティが定義されています。しかし、更なる技術革新がここで指定したものでカバーされていないプロパティを持つ新しいユースケースやメディアストリームにつながることが期待できます。このように、新しいメディアのプロパティを指定することができます。新しいメディアのプロパティが正しく、このプロパティの動作を指定する新しい定義のかなりの量が必要な場合がありますと、バーが高いことを意図しています。"
    },
    {
      "indent": 0,
      "text": "22.7.2. Registration Rules",
      "section_title": true,
      "ja": "22.7.2. 登録ルール"
    },
    {
      "indent": 3,
      "text": "Registering a new media property is done following the Specification Required policy [RFC5226]. The expert reviewer verifies that a registration request fulfills the following requirements.",
      "ja": "新しいメディアのプロパティの登録は仕様が必要ポリシー[RFC5226]以下で行われます。専門家の審査は、登録要求が次の要件を満たしていることを確認します。"
    },
    {
      "indent": 3,
      "text": "o An ABNF definition of the media property value name that meets \"media-prop-ext\" definition is included.",
      "ja": "O満たしているメディアのプロパティ値の名前のABNF定義は、「メディア・小道具-EXT」の定義が含まれています。"
    },
    {
      "indent": 3,
      "text": "o A definition of which media property group it belongs to or define a new group is included.",
      "ja": "Oそれに属するか、または新しいグループを定義するメディアプロパティグループの定義が含まれています。"
    },
    {
      "indent": 3,
      "text": "o A description of all changes to the behavior of RTSP as result of these changes is included.",
      "ja": "Oこれらの変化の結果としてRTSPの動作に対するすべての変更についての説明が含まれています。"
    },
    {
      "indent": 3,
      "text": "o A contact person for the registration is listed.",
      "ja": "O登録の担当者が一覧表示されます。"
    },
    {
      "indent": 0,
      "text": "22.7.3. Registered Values",
      "section_title": true,
      "ja": "22.7.3. 登録された値"
    },
    {
      "indent": 3,
      "text": "This specification registers the ten values listed in Section 18.29. The registry contains the property group, the name of the media property, and the reference.",
      "ja": "この仕様は、セクション18.29に記載されている10の値を登録します。レジストリは、プロパティ・グループ、メディア・プロパティの名前、および参照が含まれています。"
    },
    {
      "indent": 0,
      "text": "22.8. Notify-Reason Values",
      "section_title": true,
      "ja": "22.8. 値-理由通知"
    },
    {
      "indent": 0,
      "text": "22.8.1. Description",
      "section_title": true,
      "ja": "22.8.1. 説明"
    },
    {
      "indent": 3,
      "text": "Notify-Reason values are used to indicate the reason the notification was sent. Each reason has its associated rules on what headers and information may or must be included in the notification. New notification behaviors need to be specified to enable interoperable usage; thus, a specification of each new value is required.",
      "ja": "通知-理由の値は、通知が送信された理由を示すために使用されています。各理由は、通知に含まれなければならないかもしれないもののヘッダ情報にその関連する規則を有します。新しい通知行動は、相互運用可能な使用を可能にするために指定する必要があります。従って、それぞれの新しい値の指定が必要です。"
    },
    {
      "indent": 0,
      "text": "22.8.2. Registration Rules",
      "section_title": true,
      "ja": "22.8.2. 登録ルール"
    },
    {
      "indent": 3,
      "text": "Registrations for new Notify-Reason values follow the Specification Required policy [RFC5226]. The expert reviewer verifies that the request fulfills the following requirements:",
      "ja": "新しい通知-理由値のための登録は仕様が必要ポリシー[RFC5226]を実行します。専門家のレビューアは、要求が次の要件を満たしていることを確認します"
    },
    {
      "indent": 3,
      "text": "o An ABNF definition of the Notify-Reason value name that meets \"Notify-Reason-extension\" definition is included.",
      "ja": "満たしている「通知-理由拡張」の定義が含まれている通知、理由値名のABNF定義O。"
    },
    {
      "indent": 3,
      "text": "o A description of which headers shall be included in the request and response, when it should be sent, and any effect it has on the server client state is made clear.",
      "ja": "Oヘッダは、要求と応答に含まれなければならないそれらの説明は、それが送信されるべき場合、サーバクライアント状態で、それが有する任意の効果が明らかになっています。"
    },
    {
      "indent": 3,
      "text": "o A contact person for the registration is listed.",
      "ja": "O登録の担当者が一覧表示されます。"
    },
    {
      "indent": 0,
      "text": "22.8.3. Registered Values",
      "section_title": true,
      "ja": "22.8.3. 登録された値"
    },
    {
      "indent": 3,
      "text": "This specification registers three values defined in the Notify-Reas-val ABNF, Section 20.2.3:",
      "ja": "この仕様は、通知-REAS-VAL ABNF、セクション20.2.3に定義された三つの値を登録します。"
    },
    {
      "indent": 3,
      "text": "end-of-stream: This Notify-Reason value indicates the end of a media stream.",
      "ja": "ストリームの終わり：この通知-理由値は、メディアストリームの終わりを示します。"
    },
    {
      "indent": 3,
      "text": "media-properties-update: This Notify-Reason value allows the server to indicate that the properties of the media have changed during the playout.",
      "ja": "メディアのプロパティ更新：この通知-理由値は、サーバがメディアの特性は、再生中に変更されていることを示すことができます。"
    },
    {
      "indent": 3,
      "text": "scale-change: This Notify-Reason value allows the server to notify the client about a change in the scale of the media.",
      "ja": "スケールの変更：この通知-理由値は、サーバがメディアの規模の変更についてクライアントに通知することができます。"
    },
    {
      "indent": 3,
      "text": "The registry contains the name, description, and reference.",
      "ja": "レジストリは名前、説明、および参照が含まれています。"
    },
    {
      "indent": 0,
      "text": "22.9. Range Header Formats",
      "section_title": true,
      "ja": "22.9. 範囲ヘッダーフォーマット"
    },
    {
      "indent": 0,
      "text": "22.9.1. Description",
      "section_title": true,
      "ja": "22.9.1. 説明"
    },
    {
      "indent": 3,
      "text": "The Range header (Section 18.40) allows for different range formats. These range formats also need an identifier to be used in the Accept-Ranges header (Section 18.5). New range formats may be registered, but moderation should be applied as it makes interoperability more difficult.",
      "ja": "Rangeヘッダ（セクション18.40）は、異なる範囲のフォーマットを可能にします。これらの範囲フォーマットはまた、識別子が受け入れ-範囲ヘッダ（セクション18.5）で使用される必要があります。新しい範囲のフォーマットが登録されている場合があり、それは、相互運用性をより困難にするよう節度を適用する必要があります。"
    },
    {
      "indent": 0,
      "text": "22.9.2. Registration Rules",
      "section_title": true,
      "ja": "22.9.2. 登録ルール"
    },
    {
      "indent": 3,
      "text": "A registration follows the Specification Required policy [RFC5226]. The expert reviewer verifies that the request fulfills the following requirements:",
      "ja": "登録は仕様が必要ポリシー[RFC5226]に従います。専門家のレビューアは、要求が次の要件を満たしていることを確認します"
    },
    {
      "indent": 3,
      "text": "o An ABNF definition of the range format that fulfills the \"range-ext\" definition is included.",
      "ja": "○「範囲-EXT」の定義を満たす範囲形​​式のABNF定義が含まれています。"
    },
    {
      "indent": 3,
      "text": "o The range format identifier used in Accept-Ranges header according to the \"extension-format\" definition is defined.",
      "ja": "Oに使用される範囲形式識別子「拡張フォーマット」の定義が定義されているに応じて、ヘッダを許可は、の範囲です。"
    },
    {
      "indent": 3,
      "text": "o Rules for how one handles the range when using a negative Scale are included.",
      "ja": "O負のスケールを使用する場合いずれかの範囲をどのように処理するかのルールが含まれています。"
    },
    {
      "indent": 3,
      "text": "o A contact person for the registration is listed.",
      "ja": "O登録の担当者が一覧表示されます。"
    },
    {
      "indent": 0,
      "text": "22.9.3. Registered Values",
      "section_title": true,
      "ja": "22.9.3. 登録された値"
    },
    {
      "indent": 3,
      "text": "The registry contains the Range header format identifier, the name of the range format, and the reference. This specification registers the following values.",
      "ja": "レジストリは、Rangeヘッダフォーマット識別子、範囲形式の名前、および参照を含んでいます。この仕様は、以下の値を登録します。"
    },
    {
      "indent": 3,
      "text": "npt: Normal Play Time",
      "ja": "NPT：通常の再生時間"
    },
    {
      "indent": 3,
      "text": "clock: UTC Absolute Time format",
      "ja": "クロック：UTC絶対時間形式"
    },
    {
      "indent": 3,
      "text": "smpte: SMPTE Timestamps",
      "ja": "SMPTE：SMPTEタイムスタンプ"
    },
    {
      "indent": 3,
      "text": "smpte-30-drop: SMPTE Timestamps 29.97 Frames/sec (30 Hz with Drop)",
      "ja": "SMPTE-30ドロップ：SMPTEタイムスタンプ29.97フレーム/秒（ドロップ30ヘルツ）"
    },
    {
      "indent": 3,
      "text": "smpte-25: SMPTE Timestamps 25 Frames/sec",
      "ja": "SMPTE-25：SMPTEタイムスタンプの25フレーム/秒"
    },
    {
      "indent": 0,
      "text": "22.10. Terminate-Reason Header",
      "section_title": true,
      "ja": "22.10. 終了-理由ヘッダー"
    },
    {
      "indent": 3,
      "text": "The Terminate-Reason header (Section 18.52) has two registries for extensions.",
      "ja": "終了理由をヘッダ（セクション18.52）を拡張するための2つのレジストリを有しています。"
    },
    {
      "indent": 0,
      "text": "22.10.1. Redirect Reasons",
      "section_title": true,
      "ja": "22.10.1. 理由をリダイレクト"
    },
    {
      "indent": 3,
      "text": "This registry contains reasons for session termination that can be included in a Terminate-Reason header (Section 18.52). Registrations follow the Expert Review policy [RFC5226]. The expert reviewer verifies that the registration request contains the following information:",
      "ja": "このレジストリは、終了理由をヘッダ（セクション18.52）に含めることができるセッション終了の理由を含んでいます。登録は専門家の審査方針[RFC5226]を実行します。専門家の審査は、登録要求には、以下の情報が含まれていることを確認します"
    },
    {
      "indent": 3,
      "text": "o That the value follows the Terminate-Reason ABNF, i.e., be a token.",
      "ja": "値は、終了理由をABNFに従うことO、すなわち、トークンです。"
    },
    {
      "indent": 3,
      "text": "o That the specification provide a definition of what procedures are to be followed when a client receives this redirect reason.",
      "ja": "その仕様oを手順は、クライアントがこのリダイレクトの理由を受信したときに従うべきであるかの定義を提供しています。"
    },
    {
      "indent": 3,
      "text": "o A contact person",
      "ja": "担当者O"
    },
    {
      "indent": 3,
      "text": "This specification registers three values:",
      "ja": "この仕様は三つの値を登録します。"
    },
    {
      "indent": 3,
      "text": "o Session-Timeout",
      "ja": "Oセッションタイムアウト"
    },
    {
      "indent": 3,
      "text": "o Server-Admin",
      "ja": "Oサーバ、管理"
    },
    {
      "indent": 3,
      "text": "o Internal-Error",
      "ja": "O内部-エラー"
    },
    {
      "indent": 3,
      "text": "The registry contains the name of the Redirect Reason and the reference.",
      "ja": "レジストリは、リダイレクト理由とリファレンスの名前が含まれています。"
    },
    {
      "indent": 0,
      "text": "22.10.2. Terminate-Reason Header Parameters",
      "section_title": true,
      "ja": "22.10.2. 終了-理由ヘッダーパラメータ"
    },
    {
      "indent": 3,
      "text": "This registry contains parameters that may be included in the Terminate-Reason header (Section 18.52) in addition to a reason. Registrations are made under the Specification Required policy [RFC5226]. The expert reviewer verifies that the registration request contains the following:",
      "ja": "このレジストリは、その理由に加えて、終了理由をヘッダ（セクション18.52）に含めることができるパラメータを含みます。登録は仕様が必要ポリシー[RFC5226]の下に作られています。専門家の審査は、登録要求は、以下が含まれていることを確認します"
    },
    {
      "indent": 3,
      "text": "o A parameter name.",
      "ja": "パラメータ名O。"
    },
    {
      "indent": 3,
      "text": "o A parameter following the syntax allowed by the RTSP 2.0 specification.",
      "ja": "RTSP 2.0仕様によって許可された構文以下のパラメータ、O。"
    },
    {
      "indent": 3,
      "text": "o A reference to the specification.",
      "ja": "明細書を参照O。"
    },
    {
      "indent": 3,
      "text": "o A contact person.",
      "ja": "担当者O。"
    },
    {
      "indent": 3,
      "text": "This specification registers:",
      "ja": "この仕様・レジスタ："
    },
    {
      "indent": 3,
      "text": "o time",
      "ja": "チーム"
    },
    {
      "indent": 3,
      "text": "o user-msg",
      "ja": "Oユーザ-MSG"
    },
    {
      "indent": 3,
      "text": "The registry contains the name of the Terminate Reason and the reference.",
      "ja": "レジストリは終了理性の名前と参照が含まれています。"
    },
    {
      "indent": 0,
      "text": "22.11. RTP-Info Header Parameters",
      "section_title": true,
      "ja": "22.11.  RTP-INFOヘッダパラメータ"
    },
    {
      "indent": 0,
      "text": "22.11.1. Description",
      "section_title": true,
      "ja": "22.11.1. 説明"
    },
    {
      "indent": 3,
      "text": "The RTP-Info header (Section 18.45) carries one or more parameter value pairs with information about a particular point in the RTP stream. RTP extensions or new usages may need new types of information. As RTP information that could be needed is likely to be generic enough, and to maximize the interoperability, new registration is made under the Specification Required policy.",
      "ja": "RTP-Infoヘッダ（セクション18.45）は、RTPストリーム内の特定のポイントに関する情報を有する1つまたは複数のパラメータ値の組を運びます。 RTPの拡張や新しい使用法は新しいタイプの情報が必要な場合があります。必要になることができたRTP情報が十分に汎用的であることが、相互運用性を最大限にする可能性があるとして、新規登録は仕様が必要ポリシーの下で行われます。"
    },
    {
      "indent": 0,
      "text": "22.11.2. Registration Rules",
      "section_title": true,
      "ja": "22.11.2. 登録ルール"
    },
    {
      "indent": 3,
      "text": "Registrations for new RTP-Info values follow the policy of Specification Required [RFC5226]. The expert reviewer verifies that the registration request contains the following information.",
      "ja": "新しいRTP-情報値のための登録は仕様が必要である[RFC5226]のポリシーに従ってください。専門家の審査は、登録要求には、以下の情報が含まれていることを確認します。"
    },
    {
      "indent": 3,
      "text": "o An ABNF definition that meets the \"generic-param\" definition.",
      "ja": "「ジェネリック-PARAM」の定義を満たしているABNF定義O。"
    },
    {
      "indent": 3,
      "text": "o A reference to the specification.",
      "ja": "明細書を参照O。"
    },
    {
      "indent": 3,
      "text": "o A contact person for the registration.",
      "ja": "登録の担当者O。"
    },
    {
      "indent": 0,
      "text": "22.11.3. Registered Values",
      "section_title": true,
      "ja": "22.11.3. 登録された値"
    },
    {
      "indent": 3,
      "text": "This specification registers the following parameter value pairs:",
      "ja": "この仕様は、次のパラメータ値のペアを登録します。"
    },
    {
      "indent": 3,
      "text": "o url",
      "ja": "お うｒｌ"
    },
    {
      "indent": 3,
      "text": "o ssrc",
      "ja": "O SSRC"
    },
    {
      "indent": 3,
      "text": "o seq",
      "ja": "Oの配列"
    },
    {
      "indent": 3,
      "text": "o rtptime",
      "ja": "rtptime上"
    },
    {
      "indent": 3,
      "text": "The registry contains the name of the parameter and the reference.",
      "ja": "レジストリは、パラメータの名前と参照が含まれています。"
    },
    {
      "indent": 0,
      "text": "22.12. Seek-Style Policies",
      "section_title": true,
      "ja": "22.12. シークスタイルのポリシー"
    },
    {
      "indent": 0,
      "text": "22.12.1. Description",
      "section_title": true,
      "ja": "22.12.1. 説明"
    },
    {
      "indent": 3,
      "text": "Seek-Style policy defines how the RTSP agent seeks in media content when given a position within the media content. New seek policies may be registered; however, a large number of these will complicate implementation substantially. The impact of unknown policies is that the server will not honor the unknown and will use the server default policy instead.",
      "ja": "シーク・スタイルのポリシーは、メディアコンテンツ内の位置を与えられたとき、RTSPエージェントは、メディアコンテンツに努める方法を定義します。新求める方針を登録することができます。しかし、これらの多くは、実質的に実装が複雑になります。未知の政策の影響は、サーバーが不明を尊重せず、代わりに、サーバーのデフォルトポリシーを使用することです。"
    },
    {
      "indent": 0,
      "text": "22.12.2. Registration Rules",
      "section_title": true,
      "ja": "22.12.2. 登録ルール"
    },
    {
      "indent": 3,
      "text": "Registrations of new Seek-Style policies follow the Specification Required policy [RFC5226]. The expert reviewer verifies that the registration request fulfills the following requirements:",
      "ja": "新しいシークスタイル政策の登録は仕様が必要ポリシー[RFC5226]を実行します。専門家の審査は、登録要求が次の要件を満たしていることを確認します"
    },
    {
      "indent": 3,
      "text": "o Has an ABNF definition of the Seek-Style policy name that meets \"Seek-S-value-ext\" definition.",
      "ja": "oは「シーク-S-値-EXT」の定義を満たしているシークスタイルのポリシー名のABNFの定義を持っています。"
    },
    {
      "indent": 3,
      "text": "o Includes a short description.",
      "ja": "oは簡単な説明が含まれています。"
    },
    {
      "indent": 3,
      "text": "o Lists a contact person for the registration.",
      "ja": "oは、登録のための担当者を一覧表示します。"
    },
    {
      "indent": 3,
      "text": "o Includes a description of which headers shall be included in the request and response, when it should be sent, and any affect it has on the server-client state.",
      "ja": "oはヘッダは、それが送信されるべきとき、要求と応答に含まれるものとし、任意のは、それがサーバー・クライアントの状態に持っている影響を与えているの記述が含まれています。"
    },
    {
      "indent": 0,
      "text": "22.12.3. Registered Values",
      "section_title": true,
      "ja": "22.12.3. 登録された値"
    },
    {
      "indent": 3,
      "text": "This specification registers four values (Name - Short Description):",
      "ja": "この仕様は四つの値（名前 - 簡単な説明）を登録します："
    },
    {
      "indent": 3,
      "text": "o RAP - Using the closest Random Access Point prior to or at the requested start position.",
      "ja": "OのRAP  - 前または要求された開始位置に最も近いランダムアクセスポイントを使用しました。"
    },
    {
      "indent": 3,
      "text": "o CoRAP - Conditional Random Access Point is like RAP, but only if the RAP is closer prior to the requested start position than current pause point.",
      "ja": "O CoRAP  - 条件付きランダム・アクセス・ポイントは、RAPのようなものですが、RAPは現在一時停止点よりも要求された開始位置に近い前の場合のみ。"
    },
    {
      "indent": 3,
      "text": "o First-Prior - The first-prior policy will start delivery with the media unit that has a playout time first prior to the requested start position.",
      "ja": "Oまず、前 - 最初の前のポリシーは、従来要求された開始位置に第一の再生時間を有するメディアユニットに配信を開始します。"
    },
    {
      "indent": 3,
      "text": "o Next - The next media units after the provided start position.",
      "ja": "O次 - 提供開始位置の後の次のメディアユニット。"
    },
    {
      "indent": 3,
      "text": "The registry contains the name of the Seek-Style policy, the description, and the reference.",
      "ja": "レジストリはシークスタイルをポリシー、説明、および参照の名前が含まれています。"
    },
    {
      "indent": 0,
      "text": "22.13. Transport Header Registries",
      "section_title": true,
      "ja": "22.13. 転送ヘッダレジストリ"
    },
    {
      "indent": 3,
      "text": "The transport header (Section 18.54) contains a number of parameters that have possibilities for future extensions. Therefore, registries for these are defined below.",
      "ja": "トランスポートヘッダ（セクション18.54）は、将来の拡張の可能性を有する多数のパラメータを含んでいます。したがって、これらのためのレジストリを以下のように定義されています。"
    },
    {
      "indent": 0,
      "text": "22.13.1. Transport Protocol Identifier",
      "section_title": true,
      "ja": "22.13.1. トランスポートプロトコル識別子"
    },
    {
      "indent": 3,
      "text": "A Transport Protocol specification consists of a transport protocol identifier, representing some combination of transport protocols, and any number of transport header parameters required or optional to use with the identified protocol specification. This registry contains the identifiers used by registered transport protocol identifiers.",
      "ja": "トランスポートプロトコル仕様は、トランスポートプロトコルのいくつかの組合せを表すトランスポート・プロトコル識別子と、識別されたプロトコル仕様で使用するために必要またはオプションのトランスポート・ヘッダ・パラメータの任意の数で構成されています。このレジストリは、登録されたトランスポートプロトコル識別子で使用される識別子が含まれています。"
    },
    {
      "indent": 3,
      "text": "A registration for the parameter transport protocol identifier follows the Specification Required policy [RFC5226]. The expert reviewer verifies that the registration request fulfills the following requirements:",
      "ja": "パラメータ・トランスポート・プロトコル識別子の登録が必要な仕様ポリシー[RFC5226]を以下。専門家の審査は、登録要求が次の要件を満たしていることを確認します"
    },
    {
      "indent": 3,
      "text": "o A contact person or organization with address and email.",
      "ja": "住所、電子メールと連絡先の担当者や組織O。"
    },
    {
      "indent": 3,
      "text": "o A value definition that follows the ABNF syntax definition of \"transport-id\" Section 20.2.3.",
      "ja": "「輸送-ID」のセクション20.2.3のABNF構文の定義に従う値定義O。"
    },
    {
      "indent": 3,
      "text": "o A descriptive text that explains how the registered values are used in RTSP, which underlying transport protocols are used, and any required Transport header parameters.",
      "ja": "O登録された値は、基礎となるトランスポートプロトコルが使用されているRTSPで使用される方法を説明説明テキスト、および任意の必要なトランスポート・ヘッダ・パラメータ。"
    },
    {
      "indent": 3,
      "text": "The registry contains the protocol ID string and the reference.",
      "ja": "レジストリは、プロトコルID文字列と参照が含まれています。"
    },
    {
      "indent": 3,
      "text": "This specification registers the following values:",
      "ja": "この仕様は、以下の値を登録します。"
    },
    {
      "indent": 3,
      "text": "RTP/AVP: Use of the RTP [RFC3550] protocol for media transport in combination with the \"RTP Profile for Audio and Video Conferences with Minimal Control\" [RFC3551] over UDP. The usage is explained in RFC 7826, Appendix C.1.",
      "ja": "RTP / AVP：「最小量のコントロールがあるオーディオとビデオ会議システムのためのRTPプロフィール」と組み合わせて、メディア転送のためにRTP [RFC3550]プロトコルの使用UDP経由[RFC3551]。使用方法は、RFC 7826、付録C.1で説明されています。"
    },
    {
      "indent": 3,
      "text": "RTP/AVP/UDP: the same as RTP/AVP.",
      "ja": "RTP / AVP / UDP：RTP / AVPと同じ。"
    },
    {
      "indent": 3,
      "text": "RTP/AVPF: Use of the RTP [RFC3550] protocol for media transport in combination with the \"Extended RTP Profile for RTCP-based Feedback (RTP/AVPF)\" [RFC4585] over UDP. The usage is explained in RFC 7826, Appendix C.1.",
      "ja": "RTP / AVPF： \"RTCPベースのフィードバックのための拡張RTPプロファイル（RTP / AVPF）\" UDPオーバー[RFC4585]と組み合わせたメディア転送のためにRTP [RFC3550]プロトコルの使用。使用方法は、RFC 7826、付録C.1で説明されています。"
    },
    {
      "indent": 3,
      "text": "RTP/AVPF/UDP: the same as RTP/AVPF.",
      "ja": "RTP / AVPF / UDP：RTP / AVPFと同じです。"
    },
    {
      "indent": 3,
      "text": "RTP/SAVP: Use of the RTP [RFC3550] protocol for media transport in combination with the \"The Secure Real-time Transport Protocol (SRTP)\" [RFC3711] over UDP. The usage is explained in RFC 7826, Appendix C.1.",
      "ja": "RTP / SAVP：RTPの使用[RFC3550] UDP上の「セキュアリアルタイム転送プロトコル（SRTP）」と組み合わせて、メディア転送するためのプロトコル[RFC3711]。使用方法は、RFC 7826、付録C.1で説明されています。"
    },
    {
      "indent": 3,
      "text": "RTP/SAVP/UDP: the same as RTP/SAVP.",
      "ja": "RTP / SAVP / UDP：RTP / SAVPと同じ。"
    },
    {
      "indent": 3,
      "text": "RTP/SAVPF: Use of the RTP [RFC3550] protocol for media transport in combination with the \"Extended Secure RTP Profile for Real-time Transport Control Protocol (RTCP)-Based Feedback (RTP/SAVPF)\" [RFC5124] over UDP. The usage is explained in RFC 7826, Appendix C.1.",
      "ja": "RTP / SAVPF：UDP上の[RFC5124]「リアルタイムトランスポート制御プロトコル（RTCP）ベースのフィードバック（RTP / SAVPF）の拡張セキュアRTPプロファイル」と組み合わせて、メディア転送のためにRTP [RFC3550]プロトコルの使用。使用方法は、RFC 7826、付録C.1で説明されています。"
    },
    {
      "indent": 3,
      "text": "RTP/SAVPF/UDP: the same as RTP/SAVPF.",
      "ja": "RTP / SAVPF / UDP：RTP / SAVPFと同じ。"
    },
    {
      "indent": 3,
      "text": "RTP/AVP/TCP: Use of the RTP [RFC3550] protocol for media transport in combination with the \"RTP profile for audio and video conferences with minimal control\" [RFC3551] over TCP. The usage is explained in RFC 7826, Appendix C.2.2.",
      "ja": "RTP / AVP / TCP：RTPの使用[RFC3550] TCP上の「最小限の制御で、オーディオおよびビデオ会議用RTPプロファイル」[RFC3551]との組み合わせでメディア転送するためのプロトコル。使用方法は、RFC 7826、付録C.2.2で説明されています。"
    },
    {
      "indent": 3,
      "text": "RTP/AVPF/TCP: Use of the RTP [RFC3550] protocol for media transport in combination with the \"Extended RTP Profile for Real-time Transport Control Protocol (RTCP)-Based Feedback (RTP/AVPF)\" [RFC4585] over TCP. The usage is explained in RFC 7826, Appendix C.2.2.",
      "ja": "RTP / AVPF / TCP：TCP経由[RFC4585] \"リアルタイムトランスポート制御プロトコル（RTCP）ベースのフィードバック（RTP / AVPF）の拡張RTPプロファイル\" と組み合わせて、メディア転送のためにRTP [RFC3550]プロトコルの使用。使用方法は、RFC 7826、付録C.2.2で説明されています。"
    },
    {
      "indent": 3,
      "text": "RTP/SAVP/TCP: Use of the RTP [RFC3550] protocol for media transport in combination with the \"The Secure Real-time Transport Protocol (SRTP)\" [RFC3711] over TCP. The usage is explained in RFC 7826, Appendix C.2.2.",
      "ja": "RTP / SAVP / TCP：RTPの使用[RFC3550] TCP上の「セキュアリアルタイム転送プロトコル（SRTP）」と組み合わせて、メディア転送するためのプロトコル[RFC3711]。使用方法は、RFC 7826、付録C.2.2で説明されています。"
    },
    {
      "indent": 3,
      "text": "RTP/SAVPF/TCP: Use of the RTP [RFC3550] protocol for media transport in combination with the \"Extended Secure RTP Profile for Real-time Transport Control Protocol (RTCP)-Based Feedback (RTP/ SAVPF)\" [RFC5124] over TCP. The usage is explained in RFC 7826, Appendix C.2.2.",
      "ja": "RTP / SAVPF / TCP：RTPの使用[RFC3550] TCP上の[RFC5124]「リアルタイムトランスポート制御プロトコル（RTCP）ベースのフィードバック（RTP / SAVPF）の拡張セキュアRTPプロファイル」と組み合わせて、メディア転送するためのプロトコル。使用方法は、RFC 7826、付録C.2.2で説明されています。"
    },
    {
      "indent": 0,
      "text": "22.13.2. Transport Modes",
      "section_title": true,
      "ja": "22.13.2. トランスポートモード"
    },
    {
      "indent": 3,
      "text": "The Transport Mode is a Transport header (Section 18.54) parameter. It is used to identify the general mode of media transport. The PLAY value registered defines a PLAYBACK mode, where media flows from server to client.",
      "ja": "トランスポートモードは、トランスポートヘッダ（セクション18.54）のパラメータです。メディアトランスポートの一般的なモードを識別するために使用されます。登録PLAY値は、メディアがサーバからクライアントに流れる再生モードに、定義しています。"
    },
    {
      "indent": 3,
      "text": "A registration for the transport parameter mode follows the Standards Action policy [RFC5226]. The registration request needs to meet the following requirements:",
      "ja": "トランスポート・パラメータ・モードのための登録は標準アクションポリシー[RFC5226]に従います。登録要求には、次の要件を満たす必要があります："
    },
    {
      "indent": 3,
      "text": "o A value definition that follows the ABNF \"token\" definition Section 20.2.3.",
      "ja": "O ABNF「トークン」の定義20.2.3項を次の値の定義。"
    },
    {
      "indent": 3,
      "text": "o Text that explains how the registered value is used in RTSP.",
      "ja": "登録された値は、RTSPで使用されている方法を説明しますOテキスト。"
    },
    {
      "indent": 3,
      "text": "This specification registers one value:",
      "ja": "この仕様は、一つの値を登録します。"
    },
    {
      "indent": 3,
      "text": "PLAY: See RFC 7826.",
      "ja": "PLAY：RFC 7826を参照してください。"
    },
    {
      "indent": 3,
      "text": "The registry contains the transport mode value and the reference.",
      "ja": "レジストリは、トランスポートモード値と基準が含まれています。"
    },
    {
      "indent": 0,
      "text": "22.13.3. Transport Parameters",
      "section_title": true,
      "ja": "22.13.3. トランスポートパラメータ"
    },
    {
      "indent": 3,
      "text": "Transport Parameters are different parameters used in a Transport header's transport specification (Section 18.54) to provide additional information required beyond the transport protocol identifier to establish a functioning transport.",
      "ja": "トランスポートパラメータが機能トランスポートを確立するために、トランスポート・プロトコル識別子を超えて必要な追加情報を提供するために、トランスポート・ヘッダのトランスポート仕様（セクション18.54）で使用される異なるパラメータです。"
    },
    {
      "indent": 3,
      "text": "A registration for parameters that may be included in the Transport header follows the Specification Required policy [RFC5226]. The expert reviewer verifies that the registration request fulfills the following requirements:",
      "ja": "トランスポートヘッダに含めることができるパラメータの登録は、仕様が必要ポリシー[RFC5226]を以下。専門家の審査は、登録要求が次の要件を満たしていることを確認します"
    },
    {
      "indent": 3,
      "text": "o A Transport Parameter Name following the \"token\" ABNF definition.",
      "ja": "「トークン」ABNFの定義を以下のO交通パラメータ名。"
    },
    {
      "indent": 3,
      "text": "o A value definition, if the parameter takes a value, that follows the ABNF definition of \"trn-par-value\" Section 20.2.3.",
      "ja": "値の定義O、パラメータは「TRN-額面」20.2.3項のABNFの定義を以下の値をとる場合。"
    },
    {
      "indent": 3,
      "text": "o Text that explains how the registered value is used in RTSP.",
      "ja": "登録された値は、RTSPで使用されている方法を説明しますOテキスト。"
    },
    {
      "indent": 3,
      "text": "This specification registers all the transport parameters defined in Section 18.54. This is a copy of that list:",
      "ja": "この仕様は、セクション18.54で定義されているすべてのトランスポートパラメータを登録します。これは、そのリストのコピーであります："
    },
    {
      "indent": 3,
      "text": "o unicast",
      "ja": "Oユニキャスト"
    },
    {
      "indent": 3,
      "text": "o multicast",
      "ja": "Oマルチキャスト"
    },
    {
      "indent": 3,
      "text": "o interleaved",
      "ja": "Oのインターリーブ"
    },
    {
      "indent": 3,
      "text": "o ttl",
      "ja": "お っｔｌ"
    },
    {
      "indent": 3,
      "text": "o layers",
      "ja": "O層"
    },
    {
      "indent": 3,
      "text": "o ssrc",
      "ja": "O SSRC"
    },
    {
      "indent": 3,
      "text": "o mode",
      "ja": "お もで"
    },
    {
      "indent": 3,
      "text": "o dest_addr",
      "ja": "O dest_addrは"
    },
    {
      "indent": 3,
      "text": "o src_addr",
      "ja": "src_addrをO"
    },
    {
      "indent": 3,
      "text": "o setup",
      "ja": "O設定"
    },
    {
      "indent": 3,
      "text": "o connection",
      "ja": "O接続"
    },
    {
      "indent": 3,
      "text": "o RTCP-mux",
      "ja": "お ＲＴＣＰーむｘ"
    },
    {
      "indent": 3,
      "text": "o MIKEY",
      "ja": "O MIKEY"
    },
    {
      "indent": 3,
      "text": "The registry contains the transport parameter name and the reference.",
      "ja": "レジストリは、トランスポート・パラメータの名前と参照が含まれています。"
    },
    {
      "indent": 0,
      "text": "22.14. URI Schemes",
      "section_title": true,
      "ja": "22.14.  URIスキーム"
    },
    {
      "indent": 3,
      "text": "This specification updates two URI schemes: one previously registered, \"rtsp\", and one missing in the registry, \"rtspu\" (previously only defined in RTSP 1.0 [RFC2326]). One new URI scheme, \"rtsps\", is also registered. These URI schemes are registered in an existing registry (\"Uniform Resource Identifier (URI) Schemes\") not created by this memo. Registrations follow [RFC7595].",
      "ja": "この仕様は、2つのURIスキームを更新一予め登録、「RTSP」を、レジストリに欠け一つ「RTSPU」（以前はRTSP 1.0 [RFC2326]で定義されます）。一つの新しいURIスキーム、「RTSPS」も登録されています。これらのURIスキームは、このメモで作成されていない既存のレジストリ（「統一資源識別子（URI）スキーム」）に登録されています。登録は[RFC7595]を実行します。"
    },
    {
      "indent": 0,
      "text": "22.14.1. The \"rtsp\" URI Scheme",
      "section_title": true,
      "ja": "22.14.1.  「RTSP」URIスキーム"
    },
    {
      "indent": 3,
      "text": "URI scheme name: rtsp",
      "ja": "URIのスキーム名：RTSP"
    },
    {
      "indent": 3,
      "text": "Status: Permanent",
      "ja": "ステータス：常設"
    },
    {
      "indent": 3,
      "text": "URI scheme syntax: See Section 20.2.1 of RFC 7826.",
      "ja": "URIスキームの構文：RFC 7826のセクション20.2.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "URI scheme semantics: The rtsp scheme is used to indicate resources accessible through the usage of the Real-Time Streaming Protocol (RTSP). RTSP allows different operations on the resource identified by the URI, but the primary purpose is the streaming delivery of the resource to a client. However, the operations that are currently defined are DESCRIBE, GET_PARAMETER, OPTIONS, PLAY, PLAY_NOTIFY, PAUSE, REDIRECT, SETUP, SET_PARAMETER, and TEARDOWN.",
      "ja": "URIスキームの意味：RTSPスキームは、リアルタイムストリーミングプロトコル（RTSP）の使用を介してアクセス可能なリソースを示すために使用されます。 RTSPは、URIで識別されるリソースに異なる操作を許可しますが、主な目的は、クライアントへのリソースのストリーミング配信です。しかし、現在定義されている操作は、GET_PARAMETER、OPTIONS、PLAY、PLAY_NOTIFY、PAUSE、REDIRECT、SETUP、SET_PARAMETER、およびTEARDOWNの記述です。"
    },
    {
      "indent": 3,
      "text": "Encoding considerations: IRIs in this scheme are defined and need to be encoded as RTSP URIs when used within RTSP. That encoding is done according to RFC 3987.",
      "ja": "エンコードの考慮事項：この方式では虹彩が定義され、RTSP内で使用されるときRTSPのURIとしてエンコードする必要がありますされています。その符号化は、RFC 3987に従って行われます。"
    },
    {
      "indent": 3,
      "text": "Applications/protocols that use this URI scheme name: RTSP 1.0 (RFC 2326), RTSP 2.0 (RFC 7826).",
      "ja": "このURIのスキーム名を使用するアプリケーション/プロトコル：RTSP 1.0（RF​​C 2326）、RTSP 2.0（RF​​C 7826）。"
    },
    {
      "indent": 3,
      "text": "Interoperability considerations: The extensions in the URI syntax performed between RTSP 1.0 and 2.0 can create interoperability issues. The changes are:",
      "ja": "相互運用性に関する注意事項：URI構文の拡張は、相互運用性の問題を作成することができRTSP 1.0と2.0の間で行われます。変更点は次のとおりです。"
    },
    {
      "indent": 12,
      "text": "Support for IPv6 literals in the host part and future IP\nliterals through a mechanism as defined in RFC 3986.",
      "raw": true
    },
    {
      "indent": 12,
      "text": "A new relative format to use in RTSP elements that is not required to start with \"/\".",
      "ja": "「/」で開始する必要はありませんRTSP要素で使用する新しい相対形式。"
    },
    {
      "indent": 9,
      "text": "The above changes should have no impact on interoperability as discussed in detail in Section 4.2 of RFC 7826.",
      "ja": "RFC 7826のセクション4.2で詳細に議論されるように上記の変更は、相​​互運用性に影響を及ぼさないはずです。"
    },
    {
      "indent": 3,
      "text": "Security considerations: All the security threats identified in Section 7 of RFC 3986 also apply to this scheme. They need to be reviewed and considered in any implementation utilizing this scheme.",
      "ja": "セキュリティの考慮事項：RFC 3986のセクション7で識別されたすべてのセキュリティ上の脅威にもこの方式に適用されます。彼らは、この方式を利用し任意の実装に見直し、検討する必要があります。"
    },
    {
      "indent": 3,
      "text": "Contact: Magnus Westerlund, magnus.westerlund@ericsson.com",
      "ja": "連絡先：マグヌスウェスター、magnus.westerlund@ericsson.com"
    },
    {
      "indent": 3,
      "text": "Author/Change controller: IETF",
      "ja": "著者/変更コントローラ：IETF"
    },
    {
      "indent": 3,
      "text": "References: RFC 2326, RFC 3986, RFC 3987, and RFC 7826",
      "ja": "参考文献：RFC 2326、RFC 3986、RFC 3987、およびRFC 7826"
    },
    {
      "indent": 0,
      "text": "22.14.2. The \"rtsps\" URI Scheme",
      "section_title": true,
      "ja": "22.14.2.  「RTSPS」URIスキーム"
    },
    {
      "indent": 3,
      "text": "URI scheme name: rtsps",
      "ja": "URIのスキーム名：RTSPS"
    },
    {
      "indent": 3,
      "text": "Status: Permanent",
      "ja": "ステータス：常設"
    },
    {
      "indent": 3,
      "text": "URI scheme syntax: See Section 20.2.1 of RFC 7826.",
      "ja": "URIスキームの構文：RFC 7826のセクション20.2.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "URI scheme semantics: The rtsps scheme is used to indicate resources accessible through the usage of the Real-Time Streaming Protocol (RTSP) over TLS. RTSP allows different operations on the resource identified by the URI, but the primary purpose is the streaming delivery of the resource to a client. However, the operations that are currently defined are DESCRIBE, GET_PARAMETER, OPTIONS, PLAY, PLAY_NOTIFY, PAUSE, REDIRECT, SETUP, SET_PARAMETER, and TEARDOWN.",
      "ja": "URIスキームの意味：RTSPSスキームはTLSの上にリアルタイムストリーミングプロトコル（RTSP）の使用を介してアクセス可能なリソースを示すために使用されます。 RTSPは、URIで識別されるリソースに異なる操作を許可しますが、主な目的は、クライアントへのリソースのストリーミング配信です。しかし、現在定義されている操作は、GET_PARAMETER、OPTIONS、PLAY、PLAY_NOTIFY、PAUSE、REDIRECT、SETUP、SET_PARAMETER、およびTEARDOWNの記述です。"
    },
    {
      "indent": 3,
      "text": "Encoding considerations: IRIs in this scheme are defined and need to be encoded as RTSP URIs when used within RTSP. That encoding is done according to RFC 3987.",
      "ja": "エンコードの考慮事項：この方式では虹彩が定義され、RTSP内で使用されるときRTSPのURIとしてエンコードする必要がありますされています。その符号化は、RFC 3987に従って行われます。"
    },
    {
      "indent": 3,
      "text": "Applications/protocols that use this URI scheme name: RTSP 1.0 (RFC 2326), RTSP 2.0 (RFC 7826).",
      "ja": "このURIのスキーム名を使用するアプリケーション/プロトコル：RTSP 1.0（RF​​C 2326）、RTSP 2.0（RF​​C 7826）。"
    },
    {
      "indent": 3,
      "text": "Interoperability considerations: The \"rtsps\" scheme was never officially defined for RTSP 1.0; however, it has seen widespread use in actual deployments of RTSP 1.0. Therefore, this section discusses the believed changes between the unspecified RTSP 1.0 \"rtsps\" scheme and RTSP 2.0 definition. The extensions in the URI syntax performed between RTSP 1.0 and 2.0 can create interoperability issues. The changes are:",
      "ja": "相互運用性の考慮事項：「RTSPS」スキームが正式RTSP 1.0で定義されませんでした。しかし、それは、RTSP 1.0の実際の展開で広く使用されてきました。したがって、このセクションでは、不特定のRTSP 1.0「RTSPS」方式とRTSP 2.0定義との間の考えられた変更を説明します。 RTSP 1.0と2.0の間で行われるURI構文の拡張は、相互運用性の問題を作成することができます。変更点は次のとおりです。"
    },
    {
      "indent": 12,
      "text": "Support for IPv6 literals in the host part and future IP\nliterals through a mechanism as defined by RFC 3986.",
      "raw": true
    },
    {
      "indent": 12,
      "text": "A new relative format to use in RTSP elements that is not required to start with \"/\".",
      "ja": "「/」で開始する必要はありませんRTSP要素で使用する新しい相対形式。"
    },
    {
      "indent": 9,
      "text": "The above changes should have no impact on interoperability as discussed in detail in Section 4.2 of RFC 7826.",
      "ja": "RFC 7826のセクション4.2で詳細に議論されるように上記の変更は、相​​互運用性に影響を及ぼさないはずです。"
    },
    {
      "indent": 3,
      "text": "Security considerations: All the security threats identified in Section 7 of RFC 3986 also apply to this scheme. They need to be reviewed and considered in any implementation utilizing this scheme.",
      "ja": "セキュリティの考慮事項：RFC 3986のセクション7で識別されたすべてのセキュリティ上の脅威にもこの方式に適用されます。彼らは、この方式を利用し任意の実装に見直し、検討する必要があります。"
    },
    {
      "indent": 3,
      "text": "Contact: Magnus Westerlund, magnus.westerlund@ericsson.com",
      "ja": "連絡先：マグヌスウェスター、magnus.westerlund@ericsson.com"
    },
    {
      "indent": 3,
      "text": "Author/Change controller: IETF",
      "ja": "著者/変更コントローラ：IETF"
    },
    {
      "indent": 3,
      "text": "References: RFC 2326, RFC 3986, RFC 3987, and RFC 7826",
      "ja": "参考文献：RFC 2326、RFC 3986、RFC 3987、およびRFC 7826"
    },
    {
      "indent": 0,
      "text": "22.14.3. The \"rtspu\" URI Scheme",
      "section_title": true,
      "ja": "22.14.3.  「RTSPU」URIスキーム"
    },
    {
      "indent": 3,
      "text": "URI scheme name: rtspu",
      "ja": "URIのスキーム名：RTSPU"
    },
    {
      "indent": 3,
      "text": "Status: Permanent",
      "ja": "ステータス：常設"
    },
    {
      "indent": 3,
      "text": "URI scheme syntax: See Section 3.2 of RFC 2326.",
      "ja": "URIスキームの構文：RFC 2326のセクション3.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "URI scheme semantics: The rtspu scheme is used to indicate resources accessible through the usage of the Real-Time Streaming Protocol (RTSP) over unreliable datagram transport. RTSP allows different operations on the resource identified by the URI, but the primary purpose is the streaming delivery of the resource to a client. However, the operations that are currently defined are DESCRIBE, GET_PARAMETER, OPTIONS, REDIRECT,PLAY, PLAY_NOTIFY, PAUSE, SETUP, SET_PARAMETER, and TEARDOWN.",
      "ja": "URIスキームの意味：RTSPUスキームは、信頼性のないデータグラムトランスポート上でリアルタイムストリーミングプロトコル（RTSP）の使用を介してアクセス可能なリソースを示すために使用されます。 RTSPは、URIで識別されるリソースに異なる操作を許可しますが、主な目的は、クライアントへのリソースのストリーミング配信です。しかし、現在定義されている操作は、DESCRIBE、GET_PARAMETER、OPTIONS、REDIRECT、PLAY、PLAY_NOTIFY、PAUSE、SETUP、SET_PARAMETER、およびTEARDOWNです。"
    },
    {
      "indent": 3,
      "text": "Encoding considerations: This scheme is not intended to be used with characters outside the US-ASCII repertoire.",
      "ja": "エンコードの考慮事項：このスキームは、US-ASCIIレパートリー外の文字を使用するものではありません。"
    },
    {
      "indent": 3,
      "text": "Applications/protocols that use this URI scheme name: RTSP 1.0 (RFC 2326).",
      "ja": "このURIのスキーム名を使用するアプリケーション/プロトコル：RTSP 1.0（RF​​C 2326）。"
    },
    {
      "indent": 3,
      "text": "Interoperability considerations: The definition of the transport mechanism of RTSP over UDP has interoperability issues. That makes the usage of this scheme problematic.",
      "ja": "相互運用性に関する注意事項：UDP経由RTSPの輸送メカニズムの定義は、相互運用性の問題があります。それは、このスキームの使用が問題になります。"
    },
    {
      "indent": 3,
      "text": "Security considerations: All the security threats identified in Section 7 of RFC 3986 also apply to this scheme. They need to be reviewed and considered in any implementation utilizing this scheme.",
      "ja": "セキュリティの考慮事項：RFC 3986のセクション7で識別されたすべてのセキュリティ上の脅威にもこの方式に適用されます。彼らは、この方式を利用し任意の実装に見直し、検討する必要があります。"
    },
    {
      "indent": 3,
      "text": "Contact: Magnus Westerlund, magnus.westerlund@ericsson.com",
      "ja": "連絡先：マグヌスウェスター、magnus.westerlund@ericsson.com"
    },
    {
      "indent": 3,
      "text": "Author/Change controller: IETF",
      "ja": "著者/変更コントローラ：IETF"
    },
    {
      "indent": 3,
      "text": "References: RFC 2326",
      "ja": "参考文献：RFC 2326"
    },
    {
      "indent": 0,
      "text": "22.15. SDP Attributes",
      "section_title": true,
      "ja": "22.15.  SDP属性"
    },
    {
      "indent": 3,
      "text": "This specification defines three SDP [RFC4566] attributes that have been registered by IANA.",
      "ja": "この仕様は、IANAによって登録されている3 SDP [RFC4566]の属性を定義します。"
    },
    {
      "indent": 3,
      "text": "SDP Attribute (\"att-field\"):",
      "ja": "（「フィールドへ」）SDP属性："
    },
    {
      "indent": 8,
      "text": "Attribute name:     range\nLong form:          Media Range Attribute\nType of name:       att-field\nType of attribute:  both session and media level\nSubject to charset: No\nPurpose:            RFC 7826\nReference:          RFC 2326, RFC 7826\nValues:             See ABNF definition.",
      "raw": true
    },
    {
      "indent": 8,
      "text": "Attribute name: control Long form: RTSP control URI Type of name: att-field Type of attribute: both session and media level Subject to charset: No Purpose: RFC 7826 Reference: RFC 2326, RFC 7826 Values: Absolute or Relative URIs.",
      "ja": "属性名：ロングフォームを制御します。名前のRTSP制御URIタイプ：属性のATT-場の種類：文字セットに従うことを条件として、セッションとメディアレベルの両方：目的なし：RFC 7826参照：RFC 2326、RFC 7826の値：絶対パスまたは相対URIを。"
    },
    {
      "indent": 8,
      "text": "Attribute name: mtag Long form: Message Tag Type of name: att-field Type of attribute: both session and media level Subject to charset: No Purpose: RFC 7826 Reference: RFC 7826 Values: See ABNF definition",
      "ja": "属性名：ロングフォームをMTAG：名前のメッセージタグタイプ：属性のATT-場の種類：文字セットに従うことを条件として、セッションとメディアレベルの両方：いいえ目的：RFC 7826参照：RFC 7826の値：ABNFの定義を参照してください"
    },
    {
      "indent": 0,
      "text": "22.16. Media Type Registration for text/parameters",
      "section_title": true,
      "ja": "22.16. テキスト/パラメータのためのメディアタイプ登録"
    },
    {
      "indent": 3,
      "text": "Type name: text",
      "ja": "型名：テキスト"
    },
    {
      "indent": 3,
      "text": "Subtype name: parameters",
      "ja": "サブタイプ名：パラメータ"
    },
    {
      "indent": 3,
      "text": "Required parameters:",
      "ja": "必須パラメータ："
    },
    {
      "indent": 3,
      "text": "Optional parameters: charset: The charset parameter is applicable to the encoding of the parameter values. The default charset is UTF-8, if the 'charset' parameter is not present.",
      "ja": "オプションのパラメータ：文字セット：charsetパラメータがパラメータ値の符号化に適用されます。 「文字セット」パラメータが存在しない場合、デフォルトの文字セットは、UTF-8です。"
    },
    {
      "indent": 3,
      "text": "Encoding considerations: 8bit",
      "ja": "エンコードの考慮事項：8ビット"
    },
    {
      "indent": 3,
      "text": "Security considerations: This format may carry any type of parameters. Some can have security requirements, like privacy, confidentiality, or integrity requirements. The format has no built-in security protection. For the usage, the transport can be protected between server and client using TLS. However, care must be taken to consider if the proxies are also trusted with the parameters in case hop-by-hop security is used. If stored as a file in a file system, the necessary precautions need to be taken in relation to the parameter requirements including object security such as S/MIME [RFC5751].",
      "ja": "セキュリティの考慮事項：このフォーマットは、パラメータのいずれかのタイプを運ぶことができます。いくつかは、プライバシー、機密性、完全性または要件と同様に、セキュリティ要件を持つことができます。フォーマットには組み込みのセキュリティ保護を持っていません。使用方法については、トランスポートは、TLSを使用して、サーバーとクライアントの間に保護することができます。ただし、注意がプロキシがまたホップバイホップのセキュリティを使用する場合にはパラメータを使用して信頼されている場合を検討するために注意する必要があります。ファイルシステム内のファイルとして格納されている場合、必要な予防措置は、S / MIME [RFC5751]などのオブジェクトのセキュリティを含むパラメータ要件に関連して取られる必要があります。"
    },
    {
      "indent": 3,
      "text": "Interoperability considerations: This media type was mentioned as a fictional example in [RFC2326], but was not formally specified. This has resulted in usage of this media type that may not match its formal definition.",
      "ja": "相互運用性の考慮：このメディアタイプは、[RFC2326]の架空の例として挙げたが、正式に指定されていませんでした。これは、その正式な定義と一致しない場合があり、このメディアタイプの使用をもたらしました。"
    },
    {
      "indent": 3,
      "text": "Published specification: RFC 7826, Appendix F.",
      "ja": "公開された仕様：RFC 7826、付録F."
    },
    {
      "indent": 3,
      "text": "Applications that use this media type: Applications that use RTSP and have additional parameters they like to read and set using the RTSP GET_PARAMETER and SET_PARAMETER methods.",
      "ja": "このメディアタイプを使用するアプリケーション：RTSPを使用して、彼らが読んで、RTSP GET_PARAMETERとSET_PARAMETERメソッドを使用して設定したい追加のパラメータを持つアプリケーション。"
    },
    {
      "indent": 3,
      "text": "Additional information:",
      "ja": "追加情報："
    },
    {
      "indent": 3,
      "text": "Magic number(s): N/A",
      "ja": "マジックナンバー（S）：N / A"
    },
    {
      "indent": 3,
      "text": "File extension(s): N/A",
      "ja": "ファイルの拡張子（S）：N / A"
    },
    {
      "indent": 3,
      "text": "Macintosh file type code(s): N/A",
      "ja": "Macintoshのファイルタイプコード（S）：N / A"
    },
    {
      "indent": 3,
      "text": "Person & email address to contact for further information: Magnus Westerlund (magnus.westerlund@ericsson.com)",
      "ja": "人と詳細のために連絡する電子メールアドレス：マグヌスウェスター（magnus.westerlund@ericsson.com）"
    },
    {
      "indent": 3,
      "text": "Intended usage: Common",
      "ja": "意図している用法：コモン"
    },
    {
      "indent": 3,
      "text": "Restrictions on usage: None",
      "ja": "使用に関する制限：なし"
    },
    {
      "indent": 3,
      "text": "Author: Magnus Westerlund (magnus.westerlund@ericsson.com)",
      "ja": "著者：マグヌスウェスター（magnus.westerlund@ericsson.com）"
    },
    {
      "indent": 3,
      "text": "Change controller: IETF",
      "ja": "変更コントローラ：IETF"
    },
    {
      "indent": 3,
      "text": "Addition Notes:",
      "ja": "追加注："
    },
    {
      "indent": 0,
      "text": "23. References",
      "section_title": true,
      "ja": "23.参考文献"
    },
    {
      "indent": 0,
      "text": "23.1. Normative References",
      "section_title": true,
      "ja": "23.1. 引用規格"
    },
    {
      "indent": 3,
      "text": "[FIPS180-4] National Institute of Standards and Technology (NIST), \"Federal Information Processing Standards Publication: Secure Hash Standard (SHS)\", DOI 10.6028/NIST.FIPS.180-4, August 2015, <http://nvlpubs.nist.gov/nistpubs/FIPS/ NIST.FIPS.180-4.pdf>.",
      "ja": "[FIPS180-4]国立標準技術研究所（NIST）、 \"連邦情報処理規格出版：セキュアハッシュ標準（SHS）\"、DOI 10.6028 / NIST.FIPS.180-4、2015年8月、<のhttp：// nvlpubs .nist.gov / nistpubs / FIPS / NIST.FIPS.180-4.pdf>。"
    },
    {
      "indent": 3,
      "text": "[RFC768] Postel, J., \"User Datagram Protocol\", STD 6, RFC 768, DOI 10.17487/RFC0768, August 1980, <http://www.rfc-editor.org/info/rfc768>.",
      "ja": "[RFC768]ポステル、J.、 \"ユーザ・データグラム・プロトコル\"、STD 6、RFC 768、DOI 10.17487 / RFC0768、1980年8月、<http://www.rfc-editor.org/info/rfc768>。"
    },
    {
      "indent": 3,
      "text": "[RFC793] Postel, J., \"Transmission Control Protocol\", STD 7, RFC 793, DOI 10.17487/RFC0793, September 1981, <http://www.rfc-editor.org/info/rfc793>.",
      "ja": "[RFC793]ポステル、J.、 \"伝送制御プロトコル\"、STD 7、RFC 793、DOI 10.17487 / RFC0793、1981年9月、<http://www.rfc-editor.org/info/rfc793>。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<http://www.rfc-editor.org/info/ RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC2460] Deering, S. and R. Hinden, \"Internet Protocol, Version 6 (IPv6) Specification\", RFC 2460, DOI 10.17487/RFC2460, December 1998, <http://www.rfc-editor.org/info/rfc2460>.",
      "ja": "[RFC2460]デアリング、S.とR. Hindenと \"インターネットプロトコル、バージョン6（IPv6）の仕様\"、RFC 2460、DOI 10.17487 / RFC2460、1998年12月、<http://www.rfc-editor.org/info/ RFC2460>。"
    },
    {
      "indent": 3,
      "text": "[RFC2616] Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P., and T. Berners-Lee, \"Hypertext Transfer Protocol -- HTTP/1.1\", RFC 2616, DOI 10.17487/RFC2616, June 1999, <http://www.rfc-editor.org/info/rfc2616>.",
      "ja": "[RFC2616]フィールディング、R.、ゲティス、J.、モーグル、J.、Frystyk、H.、Masinter、L.、リーチ、P.、およびT.バーナーズ - リー、 \"ハイパーテキスト転送プロトコル -  HTTP / 1.1\" 、RFC 2616、DOI 10.17487 / RFC2616、1999年6月、<http://www.rfc-editor.org/info/rfc2616>。"
    },
    {
      "indent": 3,
      "text": "[RFC2617] Franks, J., Hallam-Baker, P., Hostetler, J., Lawrence, S., Leach, P., Luotonen, A., and L. Stewart, \"HTTP Authentication: Basic and Digest Access Authentication\", RFC 2617, DOI 10.17487/RFC2617, June 1999, <http://www.rfc-editor.org/info/rfc2617>.",
      "ja": "[RFC2617]フランクス、J.、ハラム・ベイカー、P.、Hostetler、J.、ローレンス、S.、リーチ、P.、Luotonen、A.、およびL.スチュワート、 \"HTTP認証：基本とダイジェストアクセス認証\" 、RFC 2617、DOI 10.17487 / RFC2617、1999年6月、<http://www.rfc-editor.org/info/rfc2617>。"
    },
    {
      "indent": 3,
      "text": "[RFC2818] Rescorla, E., \"HTTP Over TLS\", RFC 2818, DOI 10.17487/RFC2818, May 2000, <http://www.rfc-editor.org/info/rfc2818>.",
      "ja": "[RFC2818]レスコラ、E.、 \"TLSオーバーHTTP\"、RFC 2818、DOI 10.17487 / RFC2818、2000年5月、<http://www.rfc-editor.org/info/rfc2818>。"
    },
    {
      "indent": 3,
      "text": "[RFC3550] Schulzrinne, H., Casner, S., Frederick, R., and V. Jacobson, \"RTP: A Transport Protocol for Real-Time Applications\", STD 64, RFC 3550, DOI 10.17487/RFC3550, July 2003, <http://www.rfc-editor.org/info/rfc3550>.",
      "ja": "[RFC3550] Schulzrinneと、H.、Casner、S.、フレデリック、R.、およびV.ヤコブソン、 \"RTP：リアルタイムアプリケーションのためのトランスポートプロトコル\"、STD 64、RFC 3550、DOI 10.17487 / RFC3550、2003年7月、 <http://www.rfc-editor.org/info/rfc3550>。"
    },
    {
      "indent": 3,
      "text": "[RFC3551] Schulzrinne, H. and S. Casner, \"RTP Profile for Audio and Video Conferences with Minimal Control\", STD 65, RFC 3551, DOI 10.17487/RFC3551, July 2003, <http://www.rfc-editor.org/info/rfc3551>.",
      "ja": "[RFC3551] Schulzrinneと、H.とS. Casner、 \"最小量のコントロールがあるオーディオとビデオ会議システムのためのRTPプロフィール\"、STD 65、RFC 3551、DOI 10.17487 / RFC3551、2003年7月、<のhttp：//www.rfc-editor。組織/情報/ RFC3551>。"
    },
    {
      "indent": 3,
      "text": "[RFC3629] Yergeau, F., \"UTF-8, a transformation format of ISO 10646\", STD 63, RFC 3629, DOI 10.17487/RFC3629, November 2003, <http://www.rfc-editor.org/info/rfc3629>.",
      "ja": "[RFC3629] Yergeau、F.、 \"UTF-8、ISO 10646の変換フォーマット\"、STD 63、RFC 3629、DOI 10.17487 / RFC3629、2003年11月、<http://www.rfc-editor.org/info/ RFC3629>。"
    },
    {
      "indent": 3,
      "text": "[RFC3711] Baugher, M., McGrew, D., Naslund, M., Carrara, E., and K. Norrman, \"The Secure Real-time Transport Protocol (SRTP)\", RFC 3711, DOI 10.17487/RFC3711, March 2004, <http://www.rfc-editor.org/info/rfc3711>.",
      "ja": "[RFC3711] Baugher、M.、マグリュー、D.、Naslund、M.、カララ、E.、およびK. Norrman、 \"セキュアリアルタイムトランスポートプロトコル（SRTP）\"、RFC 3711、DOI 10.17487 / RFC3711、マーチ2004年、<http://www.rfc-editor.org/info/rfc3711>。"
    },
    {
      "indent": 3,
      "text": "[RFC3830] Arkko, J., Carrara, E., Lindholm, F., Naslund, M., and K. Norrman, \"MIKEY: Multimedia Internet KEYing\", RFC 3830, DOI 10.17487/RFC3830, August 2004, <http://www.rfc-editor.org/info/rfc3830>.",
      "ja": "[RFC3830] Arkko、J.、カララ、E.、リンドホルム、F.、Naslund、M.、およびK. Norrman、 \"MIKEY：マルチメディアインターネットキーイング\"、RFC 3830、DOI 10.17487 / RFC3830、2004年8月、<HTTP： //www.rfc-editor.org/info/rfc3830>。"
    },
    {
      "indent": 3,
      "text": "[RFC3986] Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform Resource Identifier (URI): Generic Syntax\", STD 66, RFC 3986, DOI 10.17487/RFC3986, January 2005, <http://www.rfc-editor.org/info/rfc3986>.",
      "ja": "[RFC3986]バーナーズ - リー、T.、フィールディング、R.、およびL. Masinter、 \"ユニフォームリソース識別子（URI）：汎用構文\"、STD 66、RFC 3986、DOI 10.17487 / RFC3986、2005年1月<HTTP：/ /www.rfc-editor.org/info/rfc3986>。"
    },
    {
      "indent": 3,
      "text": "[RFC3987] Duerst, M. and M. Suignard, \"Internationalized Resource Identifiers (IRIs)\", RFC 3987, DOI 10.17487/RFC3987, January 2005, <http://www.rfc-editor.org/info/rfc3987>.",
      "ja": "[RFC3987] Duerst、M.およびM. Suignard、 \"国際化リソース識別子（のIRI）\"、RFC 3987、DOI 10.17487 / RFC3987、2005年1月<http://www.rfc-editor.org/info/rfc3987>。"
    },
    {
      "indent": 3,
      "text": "[RFC4086] Eastlake 3rd, D., Schiller, J., and S. Crocker, \"Randomness Requirements for Security\", BCP 106, RFC 4086, DOI 10.17487/RFC4086, June 2005, <http://www.rfc-editor.org/info/rfc4086>.",
      "ja": "[RFC4086]イーストレーク3日、D.、シラー、J.、およびS.クロッカー、 \"セキュリティのためのランダム要件\"、BCP 106、RFC 4086、DOI 10.17487 / RFC4086、2005年6月、<HTTP：//www.rfc-editor .ORG /情報/ RFC4086>。"
    },
    {
      "indent": 3,
      "text": "[RFC4291] Hinden, R. and S. Deering, \"IP Version 6 Addressing Architecture\", RFC 4291, DOI 10.17487/RFC4291, February 2006, <http://www.rfc-editor.org/info/rfc4291>.",
      "ja": "[RFC4291] HindenとR.とS.デアリング、 \"IPバージョン6アドレッシング体系\"、RFC 4291、DOI 10.17487 / RFC4291、2006年2月、<http://www.rfc-editor.org/info/rfc4291>。"
    },
    {
      "indent": 3,
      "text": "[RFC7595] Thaler, D., Ed., Hansen, T., and T. Hardie, \"Guidelines and Registration Procedures for URI Schemes\", BCP 35, RFC 7595, DOI 10.17487/RFC7595, June 2015, <http://www.rfc-editor.org/info/rfc7595>.",
      "ja": "[RFC7595]ターラー、D.、エド、ハンセン、T.、およびT.ハーディ、 \"URIスキームのためのガイドラインと登録手順\"、BCP 35、RFC 7595、DOI 10.17487 / RFC7595、2015年6月、<のhttp：// www.rfc-editor.org/info/rfc7595>。"
    },
    {
      "indent": 3,
      "text": "[RFC4566] Handley, M., Jacobson, V., and C. Perkins, \"SDP: Session Description Protocol\", RFC 4566, DOI 10.17487/RFC4566, July 2006, <http://www.rfc-editor.org/info/rfc4566>.",
      "ja": "[RFC4566]ハンドリー、M.、ヤコブソン、V.、およびC.パーキンス、 \"SDP：セッション記述プロトコル\"、RFC 4566、DOI 10.17487 / RFC4566、2006年7月、<http://www.rfc-editor.org/情報/ RFC4566>。"
    },
    {
      "indent": 3,
      "text": "[RFC4571] Lazzaro, J., \"Framing Real-time Transport Protocol (RTP) and RTP Control Protocol (RTCP) Packets over Connection-Oriented Transport\", RFC 4571, DOI 10.17487/RFC4571, July 2006, <http://www.rfc-editor.org/info/rfc4571>.",
      "ja": "[RFC4571]ラザロ、J.、 \"フレーミングリアルタイム転送プロトコル（RTP）およびRTP制御プロトコル（RTCP）接続指向のトランスポート上でパケット\"、RFC 4571、DOI 10.17487は/ RFC4571、2006年7月、<のhttp：// WWW .rfc-editor.org /情報/ rfc4571>。"
    },
    {
      "indent": 3,
      "text": "[RFC4585] Ott, J., Wenger, S., Sato, N., Burmeister, C., and J. Rey, \"Extended RTP Profile for Real-time Transport Control Protocol (RTCP)-Based Feedback (RTP/AVPF)\", RFC 4585, DOI 10.17487/RFC4585, July 2006, <http://www.rfc-editor.org/info/rfc4585>.",
      "ja": "[RFC4585]オット、J.、ウェンガー、S.、佐藤、N.、Burmeister、C.、およびJ.レイ「ベースのフィードバック（RTP / AVPF）リアルタイムトランスポート制御プロトコル（RTCP）の拡張RTPプロファイル」、RFC 4585、DOI 10.17487 / RFC4585、2006年7月、<http://www.rfc-editor.org/info/rfc4585>。"
    },
    {
      "indent": 3,
      "text": "[RFC4648] Josefsson, S., \"The Base16, Base32, and Base64 Data Encodings\", RFC 4648, DOI 10.17487/RFC4648, October 2006, <http://www.rfc-editor.org/info/rfc4648>.",
      "ja": "[RFC4648] Josefsson氏、S.、 \"Base16、Base32、およびBase64でデータエンコーディング\"、RFC 4648、DOI 10.17487 / RFC4648、2006年10月、<http://www.rfc-editor.org/info/rfc4648>。"
    },
    {
      "indent": 3,
      "text": "[RFC4738] Ignjatic, D., Dondeti, L., Audet, F., and P. Lin, \"MIKEY-RSA-R: An Additional Mode of Key Distribution in Multimedia Internet KEYing (MIKEY)\", RFC 4738, DOI 10.17487/RFC4738, November 2006, <http://www.rfc-editor.org/info/rfc4738>.",
      "ja": "[RFC4738] Ignjatic、D.、Dondeti、L.、Audet、F.、とP.リン、 \"MIKEY-RSA-R：マルチメディアインターネットキーイング（MIKEY）における鍵配布の付加モード\"、RFC 4738、DOI 10.17487 / RFC4738、2006年11月、<http://www.rfc-editor.org/info/rfc4738>。"
    },
    {
      "indent": 3,
      "text": "[RFC5124] Ott, J. and E. Carrara, \"Extended Secure RTP Profile for Real-time Transport Control Protocol (RTCP)-Based Feedback (RTP/SAVPF)\", RFC 5124, DOI 10.17487/RFC5124, February 2008, <http://www.rfc-editor.org/info/rfc5124>.",
      "ja": "[RFC5124]オット、J.およびE.カララ、RFC 5124、DOI 10.17487 / RFC5124、2008年2月、<HTTP \"リアルタイムトランスポート制御プロトコル（RTCP）ベースのフィードバック（RTP / SAVPF）にSecure RTPプロファイル拡張\" ：//www.rfc-editor.org/info/rfc5124>。"
    },
    {
      "indent": 3,
      "text": "[RFC5226] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 5226, DOI 10.17487/RFC5226, May 2008, <http://www.rfc-editor.org/info/rfc5226>.",
      "ja": "[RFC5226] Narten氏、T.とH. Alvestrand、 \"RFCsにIANA問題部に書くためのガイドライン\"、BCP 26、RFC 5226、DOI 10.17487 / RFC5226、2008年5月、<http://www.rfc-editor.org /情報/ RFC5226>。"
    },
    {
      "indent": 3,
      "text": "[RFC5234] Crocker, D., Ed. and P. Overell, \"Augmented BNF for Syntax Specifications: ABNF\", STD 68, RFC 5234, DOI 10.17487/RFC5234, January 2008, <http://www.rfc-editor.org/info/rfc5234>.",
      "ja": "[RFC5234]クロッカー、D.、エド。そして、P. Overell、 \"構文仕様のための増大しているBNF：ABNF\"、STD 68、RFC 5234、DOI 10.17487 / RFC5234、2008年1月、<http://www.rfc-editor.org/info/rfc5234>。"
    },
    {
      "indent": 3,
      "text": "[RFC5246] Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS) Protocol Version 1.2\", RFC 5246, DOI 10.17487/RFC5246, August 2008, <http://www.rfc-editor.org/info/rfc5246>.",
      "ja": "[RFC5246]ダークス、T.およびE.レスコラ、 \"トランスポート層セキュリティ（TLS）プロトコルバージョン1.2\"、RFC 5246、DOI 10.17487 / RFC5246、2008年8月、<http://www.rfc-editor.org/info / RFC5246>。"
    },
    {
      "indent": 3,
      "text": "[RFC5280] Cooper, D., Santesson, S., Farrell, S., Boeyen, S., Housley, R., and W. Polk, \"Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile\", RFC 5280, DOI 10.17487/RFC5280, May 2008, <http://www.rfc-editor.org/info/rfc5280>.",
      "ja": "[RFC5280]クーパー、D.、Santesson、S.、ファレル、S.、Boeyen、S.、Housley氏、R.、およびW.ポーク、「インターネットX.509公開鍵暗号基盤証明書と証明書失効リスト（CRL）のプロフィール」、RFC 5280、DOI 10.17487 / RFC5280、2008年5月、<http://www.rfc-editor.org/info/rfc5280>。"
    },
    {
      "indent": 3,
      "text": "[RFC5322] Resnick, P., Ed., \"Internet Message Format\", RFC 5322, DOI 10.17487/RFC5322, October 2008, <http://www.rfc-editor.org/info/rfc5322>.",
      "ja": "[RFC5322]レズニック、P.、エド。、 \"インターネットメッセージ形式\"、RFC 5322、DOI 10.17487 / RFC5322、2008年10月、<http://www.rfc-editor.org/info/rfc5322>。"
    },
    {
      "indent": 3,
      "text": "[RFC5646] Phillips, A., Ed. and M. Davis, Ed., \"Tags for Identifying Languages\", BCP 47, RFC 5646, DOI 10.17487/RFC5646, September 2009, <http://www.rfc-editor.org/info/rfc5646>.",
      "ja": "[RFC5646]フィリップス、A.編。そして、M.デイヴィス、エド。、 \"言語を識別するためのタグ\"、BCP 47、RFC 5646、DOI 10.17487 / RFC5646、2009年9月、<http://www.rfc-editor.org/info/rfc5646>。"
    },
    {
      "indent": 3,
      "text": "[RFC5751] Ramsdell, B. and S. Turner, \"Secure/Multipurpose Internet Mail Extensions (S/MIME) Version 3.2 Message Specification\", RFC 5751, DOI 10.17487/RFC5751, January 2010, <http://www.rfc-editor.org/info/rfc5751>.",
      "ja": "[RFC5751] Ramsdell、B.とS.ターナーは、 \"セキュア/多目的インターネットメール拡張（S / MIME）バージョン3.2メッセージ仕様\"、RFC 5751、DOI 10.17487 / RFC5751、2010年1月、<のhttp：//www.rfc- editor.org/info/rfc5751>。"
    },
    {
      "indent": 3,
      "text": "[RFC5761] Perkins, C. and M. Westerlund, \"Multiplexing RTP Data and Control Packets on a Single Port\", RFC 5761, DOI 10.17487/RFC5761, April 2010, <http://www.rfc-editor.org/info/rfc5761>.",
      "ja": "[RFC5761]パーキンス、C.とM.ウェスター、 \"シングルポートの多重化RTPデータおよび制御パケット\"、RFC 5761、DOI 10.17487 / RFC5761、2010年4月、<http://www.rfc-editor.org/info / rfc5761>。"
    },
    {
      "indent": 3,
      "text": "[RFC5888] Camarillo, G. and H. Schulzrinne, \"The Session Description Protocol (SDP) Grouping Framework\", RFC 5888, DOI 10.17487/RFC5888, June 2010, <http://www.rfc-editor.org/info/rfc5888>.",
      "ja": "[RFC5888]キャマリロ、G.およびH. Schulzrinneと、 \"セッション記述プロトコル（SDP）グループ化フレームワーク\"、RFC 5888、DOI 10.17487 / RFC5888、2010年6月、<http://www.rfc-editor.org/info/ rfc5888>。"
    },
    {
      "indent": 3,
      "text": "[RFC6838] Freed, N., Klensin, J., and T. Hansen, \"Media Type Specifications and Registration Procedures\", BCP 13, RFC 6838, DOI 10.17487/RFC6838, January 2013, <http://www.rfc-editor.org/info/rfc6838>.",
      "ja": "[RFC6838]解放され、N.、Klensin、J.、およびT.ハンセン、 \"メディアタイプの仕様と登録手順\"、BCP 13、RFC 6838、DOI 10.17487 / RFC6838、2013年1月、<のhttp：//www.rfc- editor.org/info/rfc6838>。"
    },
    {
      "indent": 3,
      "text": "[RFC7230] Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing\", RFC 7230, DOI 10.17487/RFC7230, June 2014, <http://www.rfc-editor.org/info/rfc7230>.",
      "ja": "[RFC7230]フィールディング、R.、エド。及びJ. Reschke、編、 \"ハイパーテキスト転送プロトコル（HTTP / 1.1）：メッセージの構文およびルーティング\"、RFC 7230、DOI 10.17487 / RFC7230、2014年6月、<http://www.rfc-editor.org/info/ rfc7230>。"
    },
    {
      "indent": 3,
      "text": "[RFC7231] Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content\", RFC 7231, DOI 10.17487/RFC7231, June 2014, <http://www.rfc-editor.org/info/rfc7231>.",
      "ja": "[RFC7231]フィールディング、R.、エド。そして、J. Reschke、エド、 \"ハイパーテキスト転送プロトコル（HTTP / 1.1）：セマンティクスおよびコンテンツ\"、RFC 7231、DOI 10.17487 / RFC7231、2014年6月、<http://www.rfc-editor.org/info/rfc7231 >。"
    },
    {
      "indent": 3,
      "text": "[RFC7232] Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests\", RFC 7232, DOI 10.17487/RFC7232, June 2014, <http://www.rfc-editor.org/info/rfc7232>.",
      "ja": "[RFC7232]フィールディング、R.、エド。そして、J. Reschke、エド、 \"ハイパーテキスト転送プロトコル（HTTP / 1.1）：条件付きリクエスト\"、RFC 7232、DOI 10.17487 / RFC7232、2014年6月、<http://www.rfc-editor.org/info/rfc7232> 。"
    },
    {
      "indent": 3,
      "text": "[RFC7233] Fielding, R., Ed., Lafon, Y., Ed., and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Range Requests\", RFC 7233, DOI 10.17487/RFC7233, June 2014, <http://www.rfc-editor.org/info/rfc7233>.",
      "ja": "[RFC7233]フィールディング、R.、エド、ラフォン、Y.、エド、及びJ. Reschke、編、 \"ハイパーテキスト転送プロトコル（HTTP / 1.1）：範囲要求\"。。。、RFC 7233、DOI 10.17487 / RFC7233 6月2014年、<http://www.rfc-editor.org/info/rfc7233>。"
    },
    {
      "indent": 3,
      "text": "[RFC7234] Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Caching\", RFC 7234, DOI 10.17487/RFC7234, June 2014, <http://www.rfc-editor.org/info/rfc7234>.",
      "ja": "[RFC7234]フィールディング、R.、エド、ノッティンガム、M.、エド、及びJ. Reschke、編、 \"ハイパーテキスト転送プロトコル（HTTP / 1.1）：キャッシュ\"。。。、RFC 7234、DOI 10.17487 / RFC7234、2014年6月、<http://www.rfc-editor.org/info/rfc7234>。"
    },
    {
      "indent": 3,
      "text": "[RFC7235] Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Authentication\", RFC 7235, DOI 10.17487/RFC7235, June 2014, <http://www.rfc-editor.org/info/rfc7235>.",
      "ja": "[RFC7235]フィールディング、R.、エド。及びJ. Reschke、編、 \"ハイパーテキスト転送プロトコル（HTTP / 1.1）：認証\"、RFC 7235、DOI 10.17487 / RFC7235、2014年6月、<http://www.rfc-editor.org/info/rfc7235>。"
    },
    {
      "indent": 3,
      "text": "[RFC7615] Reschke, J., \"HTTP Authentication-Info and Proxy-Authentication-Info Response Header Fields\", RFC 7615, DOI 10.17487/RFC7615, September 2015, <http://www.rfc-editor.org/info/rfc7615>.",
      "ja": "[RFC7615] Reschke、J.、 \"HTTP認証-INFOとプロキシ認証-INFO応答ヘッダフィールド\"、RFC 7615、DOI 10.17487 / RFC7615、2015年9月、<http://www.rfc-editor.org/info/ rfc7615>。"
    },
    {
      "indent": 3,
      "text": "[RFC7616] Shekh-Yusef, R., Ed., Ahrens, D., and S. Bremer, \"HTTP Digest Access Authentication\", RFC 7616, DOI 10.17487/RFC7616, September 2015, <http://www.rfc-editor.org/info/rfc7616>.",
      "ja": "[RFC7616] Shekh・ユセフ、R.、エド、アーレンス、D.、およびS.ブレマー、 \"HTTPダイジェストアクセス認証\"、RFC 7616、DOI 10.17487 / RFC7616、2015年9月、<のhttp：。//www.rfc- editor.org/info/rfc7616>。"
    },
    {
      "indent": 3,
      "text": "[RFC7617] Reschke, J., \"The 'Basic' HTTP Authentication Scheme\", RFC 7617, DOI 10.17487/RFC7617, September 2015, <http://www.rfc-editor.org/info/rfc7617>.",
      "ja": "[RFC7617] Reschke、J.、 \" '基本' HTTP認証スキーム\"、RFC 7617、DOI 10.17487 / RFC7617、2015年9月、<http://www.rfc-editor.org/info/rfc7617>。"
    },
    {
      "indent": 3,
      "text": "[RFC7825] Goldberg, J., Westerlund, M., and T. Zeng, \"A Network Address Translator (NAT) Traversal Mechanism for Media Controlled by Real-Time Streaming Protocol (RTSP)\", RFC 7825, DOI 10.17487/RFC7825, December 2016, <http://www.rfc-editor.org/info/rfc7825>.",
      "ja": "[RFC7825]ゴールドバーグ、J.、ウェスター、M.、およびT.曽、RFC 7825、DOI 10.17487 / RFC7825、 \"リアルタイムストリーミングプロトコル（RTSP）によって制御されるメディアのネットワークアドレストランスレータ（NAT）トラバーサル機構\" 2016年12月、<http://www.rfc-editor.org/info/rfc7825>。"
    },
    {
      "indent": 3,
      "text": "[RTP-CIRCUIT-BREAKERS] Perkins, C. and V. Singh, \"Multimedia Congestion Control: Circuit Breakers for Unicast RTP Sessions\", Work in Progress, draft-ietf-avtcore-rtp-circuit-breakers-13, February 2016.",
      "ja": "[RTP-サーキットブレーカ]パーキンス、C.およびV.シン、 \"マルチメディアの輻輳制御：ユニキャストRTPセッションのためのサーキットブレーカー\" が進行中で働いて、ドラフト-IETF-avtcore-RTP-サーキットブレーカ-13、2016年2月。"
    },
    {
      "indent": 3,
      "text": "[SMPTE-TC] Society of Motion Picture and Television Engineers, \"ST 12-1:2008 For Television -- Time and Control Code\", DOI 10.5594/SMPTE.ST12-1.2008, February 2008, <http://ieeexplore.ieee.org/servlet/ opac?punumber=7289818>.",
      "ja": "[SMPTE-TC]映画テレビ技術者協会、 \"ST 12-1：テレビの2008  - 時間と制御コード\"、DOI 10.5594 / SMPTE.ST12-1.2008、2008年2月、<http://ieeexplore.ieee .ORG /サーブレット/ OPAC？punumber = 7289818>。"
    },
    {
      "indent": 3,
      "text": "[TS-26234] 3rd Generation Partnership Project (3GPP), \"Transparent end-to-end Packet-switched Streaming Service (PSS); Protocols and codecs\", Technical Specification 26.234, Release 13, September 2015, <http://www.3gpp.org/DynaReport/26234.htm>.",
      "ja": "[TS-26234]第3世代パートナーシッププロジェクト（3GPP）、 \"透明なエンド・ツー・エンドのストリーミングサービス（PSS）パケットを交換;プロトコルとコーデック\"、技術仕様26.234、13をリリース、2015年9月、<のhttp：// WWWを.3gpp.org / DynaReport / 26234.htm>。"
    },
    {
      "indent": 0,
      "text": "23.2. Informative References",
      "section_title": true,
      "ja": "23.2. 参考文献"
    },
    {
      "indent": 3,
      "text": "[ISO.13818-6.1995] International Organization for Standardization, \"Information technology -- Generic coding of moving pictures and associated audio information - part 6: Extension for DSM-CC\", ISO Draft Standard 13818-6:1998, October 1998, <http://www.iso.org/iso/home/store/catalogue_tc/ catalogue_detail.htm?csnumber=25039>.",
      "ja": "[ISO.13818-6.1995]国際標準化機構、「情報技術 - 動画の一般的な符号化と関連したオーディオ情報 - パート6：DSM-CCのための拡張」、ISOドラフト規格13818-6：1998、1998年10月、< http://www.iso.org/iso/home/store/catalogue_tc/ catalogue_detail.htm？csnumber = 25039>。"
    },
    {
      "indent": 3,
      "text": "[ISO.8601.2000] International Organization for Standardization, \"Data elements and interchange formats - Information interchange - Representation of dates and times\", ISO/IEC Standard 8601, December 2000.",
      "ja": "[ISO.8601.2000]国際標準化機構、「データ要素と交換フォーマット - 情報交換 - 日付と時刻の表現」、ISO / IEC規格8601、2000年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC791] Postel, J., \"Internet Protocol\", STD 5, RFC 791, DOI 10.17487/RFC0791, September 1981, <http://www.rfc-editor.org/info/rfc791>.",
      "ja": "[RFC791]ポステル、J.、 \"インターネットプロトコル\"、STD 5、RFC 791、DOI 10.17487 / RFC0791、1981年9月、<http://www.rfc-editor.org/info/rfc791>。"
    },
    {
      "indent": 3,
      "text": "[RFC1123] Braden, R., Ed., \"Requirements for Internet Hosts - Application and Support\", STD 3, RFC 1123, DOI 10.17487/RFC1123, October 1989, <http://www.rfc-editor.org/info/rfc1123>.",
      "ja": "[RFC1123]ブレーデン、R.、エド、 \"インターネットホストのための要件 - 、アプリケーションとサポート\"。、STD 3、RFC 1123、DOI 10.17487 / RFC1123、1989年10月、<http://www.rfc-editor.org/info / RFC1123>。"
    },
    {
      "indent": 3,
      "text": "[RFC2068] Fielding, R., Gettys, J., Mogul, J., Frystyk, H., and T. Berners-Lee, \"Hypertext Transfer Protocol -- HTTP/1.1\", RFC 2068, DOI 10.17487/RFC2068, January 1997, <http://www.rfc-editor.org/info/rfc2068>.",
      "ja": "[RFC2068]フィールディング、R.、ゲティス、J.、モーグル、J.、Frystyk、H.、およびT.バーナーズ - リー、 \"ハイパーテキスト転送プロトコル -  HTTP / 1.1\"、RFC 2068、DOI 10.17487 / RFC2068 1月1997年、<http://www.rfc-editor.org/info/rfc2068>。"
    },
    {
      "indent": 3,
      "text": "[RFC2326] Schulzrinne, H., Rao, A., and R. Lanphier, \"Real Time Streaming Protocol (RTSP)\", RFC 2326, DOI 10.17487/RFC2326, April 1998, <http://www.rfc-editor.org/info/rfc2326>.",
      "ja": "[RFC2326] SchulzrinneとH.とラオとA.、およびR. Lanphier、 \"リアルタイムのストリーミングプロトコル（RTSP）\"、RFC 2326、DOI 10.17487 / RFC2326、1998年4月、<のhttp：//www.rfc-editor。組織/情報/ RFC2326>。"
    },
    {
      "indent": 3,
      "text": "[RFC2663] Srisuresh, P. and M. Holdrege, \"IP Network Address Translator (NAT) Terminology and Considerations\", RFC 2663, DOI 10.17487/RFC2663, August 1999, <http://www.rfc-editor.org/info/rfc2663>.",
      "ja": "[RFC2663] Srisuresh、P.とM.ホールドレッジ、 \"IPネットワークアドレス変換（NAT）用語と考慮事項\"、RFC 2663、DOI 10.17487 / RFC2663、1999年8月、<http://www.rfc-editor.org/info / RFC2663>。"
    },
    {
      "indent": 3,
      "text": "[RFC2974] Handley, M., Perkins, C., and E. Whelan, \"Session Announcement Protocol\", RFC 2974, DOI 10.17487/RFC2974, October 2000, <http://www.rfc-editor.org/info/rfc2974>.",
      "ja": "[RFC2974]ハンドレー、M.、パーキンス、C.、およびE.ウィーラン、 \"セッション告知プロトコル\"、RFC 2974、DOI 10.17487 / RFC2974、2000年10月<http://www.rfc-editor.org/info/ rfc2974>。"
    },
    {
      "indent": 3,
      "text": "[RFC3261] Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston, A., Peterson, J., Sparks, R., Handley, M., and E. Schooler, \"SIP: Session Initiation Protocol\", RFC 3261, DOI 10.17487/RFC3261, June 2002, <http://www.rfc-editor.org/info/rfc3261>.",
      "ja": "[RFC3261]ローゼンバーグ、J.、Schulzrinneと、H.、カマリロ、G.、ジョンストン、A.、ピーターソン、J.、スパークス、R.、ハンドレー、M.、およびE.学生、 \"SIP：セッション開始プロトコル\" 、RFC 3261、DOI 10.17487 / RFC3261、2002年6月、<http://www.rfc-editor.org/info/rfc3261>。"
    },
    {
      "indent": 3,
      "text": "[RFC3264] Rosenberg, J. and H. Schulzrinne, \"An Offer/Answer Model with Session Description Protocol (SDP)\", RFC 3264, DOI 10.17487/RFC3264, June 2002, <http://www.rfc-editor.org/info/rfc3264>.",
      "ja": "[RFC3264]ローゼンバーグ、J.、およびH. Schulzrinneと、RFC 3264、DOI 10.17487 / RFC3264、2002年6月 \"セッション記述プロトコル（SDP）とのオファー/アンサーモデル\"、<http://www.rfc-editor.org /情報/ RFC3264>。"
    },
    {
      "indent": 3,
      "text": "[RFC3339] Klyne, G. and C. Newman, \"Date and Time on the Internet: Timestamps\", RFC 3339, DOI 10.17487/RFC3339, July 2002, <http://www.rfc-editor.org/info/rfc3339>.",
      "ja": "[RFC3339] Klyne、G.とC.ニューマン、 \"インターネット上の日付と時刻：タイムスタンプ\"、RFC 3339、DOI 10.17487 / RFC3339、2002年7月、<http://www.rfc-editor.org/info/rfc3339 >。"
    },
    {
      "indent": 3,
      "text": "[RFC4145] Yon, D. and G. Camarillo, \"TCP-Based Media Transport in the Session Description Protocol (SDP)\", RFC 4145, DOI 10.17487/RFC4145, September 2005, <http://www.rfc-editor.org/info/rfc4145>.",
      "ja": "[RFC4145]ヨン、D.とG.カマリロ、 \"TCPベースのセッション記述プロトコル（SDP）にメディアトランスポート\"、RFC 4145、DOI 10.17487 / RFC4145、2005年9月、<のhttp：//www.rfc-editor。組織/情報/ rfc4145>。"
    },
    {
      "indent": 3,
      "text": "[RFC4567] Arkko, J., Lindholm, F., Naslund, M., Norrman, K., and E. Carrara, \"Key Management Extensions for Session Description Protocol (SDP) and Real Time Streaming Protocol (RTSP)\", RFC 4567, DOI 10.17487/RFC4567, July 2006, <http://www.rfc-editor.org/info/rfc4567>.",
      "ja": "[RFC4567] Arkko、J.、リンドホルム、F.、Naslund、M.、Norrman、K.、およびE.カララ、 \"鍵管理拡張セッション記述プロトコル（SDP）、リアルタイムストリーミングプロトコル（RTSP）のための\"、RFC 4567、DOI 10.17487 / RFC4567、2006年7月、<http://www.rfc-editor.org/info/rfc4567>。"
    },
    {
      "indent": 3,
      "text": "[RFC4588] Rey, J., Leon, D., Miyazaki, A., Varsa, V., and R. Hakenberg, \"RTP Retransmission Payload Format\", RFC 4588, DOI 10.17487/RFC4588, July 2006, <http://www.rfc-editor.org/info/rfc4588>.",
      "ja": "[RFC4588]レイ、J.、レオン、D.、宮崎、A.、Varsa、V.、およびR. Hakenberg、 \"RTP再送信ペイロードフォーマット\"、RFC 4588、DOI 10.17487 / RFC4588、2006年7月、<のhttp：/ /www.rfc-editor.org/info/rfc4588>。"
    },
    {
      "indent": 3,
      "text": "[RFC4855] Casner, S., \"Media Type Registration of RTP Payload Formats\", RFC 4855, DOI 10.17487/RFC4855, February 2007, <http://www.rfc-editor.org/info/rfc4855>.",
      "ja": "[RFC4855] Casner、S.、 \"RTPペイロード形式のメディアタイプ登録\"、RFC 4855、DOI 10.17487 / RFC4855、2007年2月、<http://www.rfc-editor.org/info/rfc4855>。"
    },
    {
      "indent": 3,
      "text": "[RFC4856] Casner, S., \"Media Type Registration of Payload Formats in the RTP Profile for Audio and Video Conferences\", RFC 4856, DOI 10.17487/RFC4856, February 2007, <http://www.rfc-editor.org/info/rfc4856>.",
      "ja": "[RFC4856] Casner、S.、 \"オーディオおよびビデオ会議用RTPプロファイルにおけるペイロード形式のメディアタイプ登録\"、RFC 4856、DOI 10.17487 / RFC4856、2007年2月、<http://www.rfc-editor.org/情報/ rfc4856>。"
    },
    {
      "indent": 3,
      "text": "[RFC5104] Wenger, S., Chandra, U., Westerlund, M., and B. Burman, \"Codec Control Messages in the RTP Audio-Visual Profile with Feedback (AVPF)\", RFC 5104, DOI 10.17487/RFC5104, February 2008, <http://www.rfc-editor.org/info/rfc5104>.",
      "ja": "[RFC5104]ウェンガー、S.、チャンドラ、U.、ウェスター、M.、およびB.ビルマ、RFC 5104 \"フィードバック（AVPF）とRTPオーディオビジュアルプロファイルにおけるコーデック制御メッセージ\"、DOI 10.17487は/ RFC5104 2月2008年、<http://www.rfc-editor.org/info/rfc5104>。"
    },
    {
      "indent": 3,
      "text": "[RFC5245] Rosenberg, J., \"Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols\", RFC 5245, DOI 10.17487/RFC5245, April 2010, <http://www.rfc-editor.org/info/rfc5245>.",
      "ja": "[RFC5245]ローゼンバーグ、J.、 \"インタラクティブ接続確立（ICE）：オファー/回答プロトコルのためのネットワークアドレス変換器（NAT）トラバーサルのための議定書\"、RFC 5245、DOI 10.17487 / RFC5245、2010年4月、<のhttp：// WWW .rfc-editor.org /情報/ rfc5245>。"
    },
    {
      "indent": 3,
      "text": "[RFC5389] Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, \"Session Traversal Utilities for NAT (STUN)\", RFC 5389, DOI 10.17487/RFC5389, October 2008, <http://www.rfc-editor.org/info/rfc5389>.",
      "ja": "[RFC5389]ローゼンバーグ、J.、マーイ、R.、マシューズ、P.、およびD.翼、 \"NAT（STUN）のセッショントラバーサルユーティリティ\"、RFC 5389、DOI 10.17487 / RFC5389、2008年10月、<のhttp：// www.rfc-editor.org/info/rfc5389>。"
    },
    {
      "indent": 3,
      "text": "[RFC5583] Schierl, T. and S. Wenger, \"Signaling Media Decoding Dependency in the Session Description Protocol (SDP)\", RFC 5583, DOI 10.17487/RFC5583, July 2009, <http://www.rfc-editor.org/info/rfc5583>.",
      "ja": "[RFC5583] Schierl、T.及びS.ウェンガー、 \"メディアシグナリングデコード依存セッション記述プロトコル（SDP）における\"、RFC 5583、DOI 10.17487 / RFC5583、2009年7月、<http://www.rfc-editor.org /情報/ rfc5583>。"
    },
    {
      "indent": 3,
      "text": "[RFC5905] Mills, D., Martin, J., Ed., Burbank, J., and W. Kasch, \"Network Time Protocol Version 4: Protocol and Algorithms Specification\", RFC 5905, DOI 10.17487/RFC5905, June 2010, <http://www.rfc-editor.org/info/rfc5905>.",
      "ja": "[RFC5905]ミルズ、D.、マーティン、J.、エド、バーバンク、J.、およびW. Kasch、 \"ネットワークタイムプロトコルバージョン4：プロトコルとアルゴリズムの仕様\"。、RFC 5905、DOI 10.17487 / RFC5905、2010年6月、 <http://www.rfc-editor.org/info/rfc5905>。"
    },
    {
      "indent": 3,
      "text": "[RFC6298] Paxson, V., Allman, M., Chu, J., and M. Sargent, \"Computing TCP's Retransmission Timer\", RFC 6298, DOI 10.17487/RFC6298, June 2011, <http://www.rfc-editor.org/info/rfc6298>.",
      "ja": "[RFC6298]パクソン、V.、オールマン、M.、チュー、J.、およびM.サージェント、 \"コンピューティングTCPの再送信タイマー\"、RFC 6298、DOI 10.17487 / RFC6298、2011年6月、<のhttp：//www.rfc- editor.org/info/rfc6298>。"
    },
    {
      "indent": 3,
      "text": "[Stevens98] Stevens, W., Fenner, B., and A. Rudoff, \"Unix Networking Programming, Volume 1: The Sockets Networking API (3rd Edition)\", 1998.",
      "ja": "[Stevens98]スティーブンス、W.、フェナー、B.、およびA. Rudoff、 \"UNIXネットワークプログラミング第1巻：ソケットネットワーキングAPI（第3版）\"、1998年。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Examples",
      "ja": "付録A.例"
    },
    {
      "indent": 3,
      "text": "This section contains several different examples trying to illustrate possible ways of using RTSP. The examples can also help with the understanding of how functions of RTSP work. However, remember that these are examples and the normative and syntax descriptions in the other sections take precedence. Please also note that many of the examples have been broken into several lines, where following lines start with whitespace as allowed by the syntax.",
      "ja": "このセクションでは、RTSPを使用しての可能な方法を説明しようとしているいくつかの異なる例が含まれています。実施例はまた、RTSPの仕事の方法の機能の理解を助けることができます。しかし、これらは一例であり、他のセクションでの規範と構文の記述が優先することを覚えておいてください。また、例の多くは、構文によって許可され、次の行が空白で始まる複数の行、に分割されていることに注意してください。"
    },
    {
      "indent": 0,
      "text": "A.1. Media on Demand (Unicast)",
      "ja": "A.1。オンデマンドメディア（ユニキャスト）"
    },
    {
      "indent": 3,
      "text": "This is an example of media-on-demand streaming of media stored in a container file. For the purposes of this example, a container file is a storage entity in which multiple continuous media types pertaining to the same end-user presentation are present. In effect, the container file represents an RTSP presentation, with each of its components being RTSP-controlled media streams. Container files are a widely used means to store such presentations. While the components are transported as independent streams, it is desirable to maintain a common context for those streams at the server end.",
      "ja": "これは、コンテナファイルに格納されたメディアのメディアオンデマンドストリーミングの一例です。この例の目的のために、コンテナファイルは、同一のエンドユーザのプレゼンテーションに関連する複数の連続的なメディアタイプが存在するストレージ・エンティティです。実際には、コンテナファイルは、その構成要素の各々はRTSP制御メディアストリームであると、RTSPプレゼンテーションを表します。コンテナファイルは、このようなプレゼンテーションを保存するために広く使用される手段です。構成要素は独立したストリームとして搬送されるが、サーバ側でそれらのストリームに共通のコンテキストを維持することが望ましいです。"
    },
    {
      "indent": 6,
      "text": "This enables the server to keep a single storage handle open easily. It also allows treating all the streams equally in case of any prioritization of streams by the server.",
      "ja": "これは簡単に開いて単一のストレージハンドルを維持するために、サーバーを可能にします。また、サーバによるストリームのいずれかの優先順位付けの場合にも同様にすべてのストリームを処理することができます。"
    },
    {
      "indent": 3,
      "text": "It is also possible that the presentation author may wish to prevent selective retrieval of the streams by the client in order to preserve the artistic effect of the combined media presentation. Similarly, in such a tightly bound presentation, it is desirable to be able to control all the streams via a single control message using an aggregate URI.",
      "ja": "プレゼンテーションの作成者が複合メディアプレゼンテーションの芸術的効果を維持するために、クライアントがストリームを選択的に検索することを防止したいことも可能です。同様に、強固に結合したプレゼンテーションでは、集約URIを使用して、単一の制御メッセージを介して全てのストリームを制御できることが望ましいです。"
    },
    {
      "indent": 3,
      "text": "The following is an example of using a single RTSP session to control multiple streams. It also illustrates the use of aggregate URIs. In a container file, it is also desirable not to write any URI parts that are not kept when the container is distributed, like the host and most of the path element. Therefore, this example also uses the \"*\" and relative URI in the delivered SDP.",
      "ja": "以下は、複数のストリームを制御するために単一のRTSPセッションを使用する例です。また、集計のURIの使用を示しています。コンテナファイルには、容器が分配されるとき、保持ホストのような、パス素子の最もされていない任意のURI部分を書き込まないことが望ましいです。したがって、この例では、送達されるSDPの「*」と相対URIを使用します。"
    },
    {
      "indent": 3,
      "text": "Also, this presentation description (SDP) is not cacheable, as the Expires header is set to an equal value with date indicating immediate expiration of its validity.",
      "ja": "ヘッダは、その有効性の即時有効期限を示す日付と等しい値に設定されている有効期限としても、このプレゼンテーション記述（SDP）は、キャッシュ可能ではありません。"
    },
    {
      "indent": 3,
      "text": "Client C requests a presentation from media server M. The movie is stored in a container file. The client has obtained an RTSP URI to the container file.",
      "ja": "クライアントCは、ムービーがコンテナファイルに格納されたメディアサーバM.からのプレゼンテーションを要求します。クライアントは、コンテナファイルにRTSP URIを取得しています。"
    },
    {
      "indent": 3,
      "text": "C->M: DESCRIBE rtsp://example.com/twister.3gp RTSP/2.0 CSeq: 1 User-Agent: PhonyClient/1.2",
      "ja": "C-> M：RTSPの記述：1つのUser-Agent：PhonyClient / 1.2 RTSP / 2.0のCSeq //example.com/twister.3gp"
    },
    {
      "indent": 3,
      "text": "M->C: RTSP/2.0 200 OK CSeq: 1 Server: PhonyServer/1.0 Date: Fri, 20 Dec 2013 10:20:32 +0000 Content-Type: application/sdp Content-Length: 271 Content-Base: rtsp://example.com/twister.3gp/ Expires: Fri, 20 Dec 2013 12:20:32 +0000",
      "ja": "M-> C：RTSP / 2.0 200 OKのCSeq：1つのサーバ：PhonyServer / 1.0日付：金、2013年12月20日10時20分32秒0000のContent-Type：アプリケーション/ SDPコンテンツの長さ：271コンテンツベース：RTSP： //example.com/twister.3gp/有効期限：金、2013年12月20日12時20分32秒0000"
    },
    {
      "indent": 9,
      "text": "v=0\no=- 2890844256 2890842807 IN IP4 198.51.100.5\ns=RTSP Session\ni=An Example of RTSP Session Usage\ne=adm@example.com\nc=IN IP4 0.0.0.0\na=control: *\na=range:npt=00:00:00-00:10:34.10\nt=0 0\nm=audio 0 RTP/AVP 0\na=control: trackID=1\nm=video 0 RTP/AVP 26\na=control: trackID=4",
      "raw": true
    },
    {
      "indent": 3,
      "text": "C->M: SETUP rtsp://example.com/twister.3gp/trackID=1 RTSP/2.0 CSeq: 2 User-Agent: PhonyClient/1.2 Require: play.basic Transport: RTP/AVP;unicast;dest_addr=\":8000\"/\":8001\" Accept-Ranges: npt, smpte, clock",
      "ja": "C-> M：SETUPのRTSP：//example.com/twister.3gp/trackID=1 RTSP / 2.0のCSeq：2のUser-Agent：PhonyClient / 1.2が必要：play.basicトランスポート：RTP / AVP;ユニキャスト; dest_addrは=」 ：8000 \"/\"：8001\" にAccept-範囲：NPT、SMPTE、クロック"
    },
    {
      "indent": 3,
      "text": "M->C: RTSP/2.0 200 OK\n      CSeq: 2\n      Server: PhonyServer/1.0\n      Transport: RTP/AVP;unicast; ssrc=93CB001E;\n                 dest_addr=\"192.0.2.53:8000\"/\"192.0.2.53:8001\";\n                 src_addr=\"198.51.100.5:9000\"/\"198.51.100.5:9001\"\n      Session: OccldOFFq23KwjYpAnBbUr\n      Expires: Fri, 20 Dec 2013 12:20:33 +0000\n      Date: Fri, 20 Dec 2013 10:20:33 +0000\n      Accept-Ranges: npt\n      Media-Properties: Random-Access=0.02, Immutable, Unlimited",
      "raw": true
    },
    {
      "indent": 3,
      "text": "C->M: SETUP rtsp://example.com/twister.3gp/trackID=4 RTSP/2.0 CSeq: 3 User-Agent: PhonyClient/1.2 Require: play.basic Transport: RTP/AVP;unicast;dest_addr=\":8002\"/\":8003\" Session: OccldOFFq23KwjYpAnBbUr Accept-Ranges: npt, smpte, clock",
      "ja": "C-> M：SETUPのRTSP：//example.com/twister.3gp/trackID=4 RTSP / 2.0のCSeq：3のUser-Agent：PhonyClient / 1.2が必要：play.basicトランスポート：RTP / AVP;ユニキャスト; dest_addrは=」 ：8002 \"/\"：8003\" セッション：OccldOFFq23KwjYpAnBbUrは受け入れ-範囲：NPT、SMPTE、クロック"
    },
    {
      "indent": 3,
      "text": "M->C: RTSP/2.0 200 OK\n      CSeq: 3\n      Server: PhonyServer/1.0\n      Transport: RTP/AVP;unicast; ssrc=A813FC13;\n                 dest_addr=\"192.0.2.53:8002\"/\"192.0.2.53:8003\";\n                 src_addr=\"198.51.100.5:9002\"/\"198.51.100.5:9003\";",
      "raw": true
    },
    {
      "indent": 9,
      "text": "Session: OccldOFFq23KwjYpAnBbUr\nExpires: Fri, 20 Dec 2013 12:20:33 +0000\nDate: Fri, 20 Dec 2013 10:20:33 +0000\nAccept-Range: NPT\nMedia-Properties: Random-Access=0.8, Immutable, Unlimited",
      "raw": true
    },
    {
      "indent": 3,
      "text": "C->M: PLAY rtsp://example.com/twister.3gp/ RTSP/2.0 CSeq: 4 User-Agent: PhonyClient/1.2 Range: npt=30- Seek-Style: RAP Session: OccldOFFq23KwjYpAnBbUr",
      "ja": "C-> M：PLAYのRTSP：4のUser-Agent：PhonyClient / 1.2範囲：NPT = 30-シークスタイルを：RAPセッション：OccldOFFq23KwjYpAnBbUr RTSP / 2.0のCSeq //example.com/twister.3gp/"
    },
    {
      "indent": 3,
      "text": "M->C: RTSP/2.0 200 OK CSeq: 4 Server: PhonyServer/1.0 Date: Fri, 20 Dec 2013 10:20:34 +0000 Session: OccldOFFq23KwjYpAnBbUr Range: npt=30-634.10 Seek-Style: RAP RTP-Info: url=\"rtsp://example.com/twister.3gp/trackID=4\" ssrc=0D12F123:seq=12345;rtptime=3450012, url=\"rtsp://example.com/twister.3gp/trackID=1\" ssrc=4F312DD8:seq=54321;rtptime=2876889",
      "ja": "M-> C：RTSP / 2.0 200 OKのCSeq：4サーバー：PhonyServer / 1.0日付：金、2013年12月20日10時20分34秒0000セッション：OccldOFFq23KwjYpAnBbUr範囲：NPT = 30から634.10シークスタイル：RAP RTP-情報：URL = \"RTSP：//example.com/twister.3gp/trackID=4\" SSRC = 0D12F123：SEQ = 12345; rtptime = 3450012、URL = \"RTSP：//example.com/twister.3gp/trackID=1 「SSRC = 4F312DD8：SEQ = 54321; rtptime = 2876889"
    },
    {
      "indent": 3,
      "text": "C->M: PAUSE rtsp://example.com/twister.3gp/ RTSP/2.0 CSeq: 5 User-Agent: PhonyClient/1.2 Session: OccldOFFq23KwjYpAnBbUr",
      "ja": "C-> M：PAUSEのRTSP：RTSP / 2.0のCSeq //example.com/twister.3gp/：5のUser-Agent：PhonyClient / 1.2セッション：OccldOFFq23KwjYpAnBbUr"
    },
    {
      "indent": 3,
      "text": "# Pause happens 0.87 seconds after starting to play",
      "ja": "＃一時停止の再生が開始した後、0.87秒で起こります"
    },
    {
      "indent": 3,
      "text": "M->C: RTSP/2.0 200 OK CSeq: 5 Server: PhonyServer/1.0 Date: Fri, 20 Dec 2013 10:20:35 +0000 Session: OccldOFFq23KwjYpAnBbUr Range: npt=30.87-634.10",
      "ja": "M-> C：RTSP / 2.0 200 OKのCSeq：5サーバー：PhonyServer / 1.0日付：金、2013年12月20日10時20分35秒0000セッション：OccldOFFq23KwjYpAnBbUr範囲：NPT = 30.87から634.10"
    },
    {
      "indent": 3,
      "text": "C->M: PLAY rtsp://example.com/twister.3gp/ RTSP/2.0 CSeq: 6 User-Agent: PhonyClient/1.2 Range: npt=30.87-634.10 Seek-Style: Next Session: OccldOFFq23KwjYpAnBbUr",
      "ja": "C-> M：PLAYのRTSP：6のUser-Agent：PhonyClient / 1.2範囲：NPT = 30.87から634.10シークスタイル：次のセッション：RTSP / 2.0のCSeq //example.com/twister.3gp/ OccldOFFq23KwjYpAnBbUr"
    },
    {
      "indent": 3,
      "text": "M->C: RTSP/2.0 200 OK CSeq: 6 Server: PhonyServer/1.0 Date: Fri, 20 Dec 2013 10:22:13 +0000 Session: OccldOFFq23KwjYpAnBbUr Range: npt=30.87-634.10 Seek-Style: Next RTP-Info: url=\"rtsp://example.com/twister.3gp/trackID=4\" ssrc=0D12F123:seq=12555;rtptime=6330012, url=\"rtsp://example.com/twister.3gp/trackID=1\" ssrc=4F312DD8:seq=55021;rtptime=3132889",
      "ja": "M-> C：RTSP / 2.0 200 OKのCSeq：6サーバー：PhonyServer / 1.0日付：金、2013年12月20日午前十時22分13秒0000セッション：OccldOFFq23KwjYpAnBbUr範囲：NPT = 30.87から634.10シークスタイル：次RTP-情報：URL = \"RTSP：//example.com/twister.3gp/trackID=4\" SSRC = 0D12F123：SEQ = 12555; rtptime = 6330012、URL = \"RTSP：//example.com/twister.3gp/trackID=1 「SSRC = 4F312DD8：SEQ = 55021; rtptime = 3132889"
    },
    {
      "indent": 3,
      "text": "C->M: TEARDOWN rtsp://example.com/twister.3gp/ RTSP/2.0 CSeq: 7 User-Agent: PhonyClient/1.2 Session: OccldOFFq23KwjYpAnBbUr",
      "ja": "C-> M：TEARDOWNのRTSP：RTSP / 2.0のCSeq //example.com/twister.3gp/：7のUser-Agent：PhonyClient / 1.2セッション：OccldOFFq23KwjYpAnBbUr"
    },
    {
      "indent": 3,
      "text": "M->C: RTSP/2.0 200 OK CSeq: 7 Server: PhonyServer/1.0 Date: Fri, 20 Dec 2013 10:31:53 +0000",
      "ja": "M-> C：RTSP / 2.0 200 OKのCSeq：7サーバー：PhonyServer / 1.0日付：金、2013年12月20日10時31分53秒0000"
    },
    {
      "indent": 0,
      "text": "A.2. Media on Demand Using Pipelining",
      "ja": "A.2。パイプラインを使用したオンデマンドメディア"
    },
    {
      "indent": 3,
      "text": "This example is basically the example above (Appendix A.1), but now utilizing pipelining to speed up the setup. It requires only two round-trip times until the media starts flowing. First of all, the session description is retrieved to determine what media resources need to be set up. In the second step, one sends the necessary SETUP requests and the PLAY request to initiate media delivery.",
      "ja": "この例では、基本的には（付録A.1）上記の例であるが、今の設定をスピードアップするためにパイプラインを利用します。メディアが流れ始めるまで、それは2つだけのラウンドトリップ時間が必要です。まず、セッション記述は、メディアリソースを設定する必要があるかを決定するために取得されます。第二ステップでは、一方が必要SETUP要求とメディア配信を開始するPLAY要求を送信します。"
    },
    {
      "indent": 3,
      "text": "Client C requests a presentation from media server M. The movie is stored in a container file. The client has obtained an RTSP URI to the container file.",
      "ja": "クライアントCは、ムービーがコンテナファイルに格納されたメディアサーバM.からのプレゼンテーションを要求します。クライアントは、コンテナファイルにRTSP URIを取得しています。"
    },
    {
      "indent": 3,
      "text": "C->M: DESCRIBE rtsp://example.com/twister.3gp RTSP/2.0 CSeq: 1 User-Agent: PhonyClient/1.2",
      "ja": "C-> M：RTSPの記述：1つのUser-Agent：PhonyClient / 1.2 RTSP / 2.0のCSeq //example.com/twister.3gp"
    },
    {
      "indent": 3,
      "text": "M->C: RTSP/2.0 200 OK CSeq: 1 Server: PhonyServer/1.0 Date: Fri, 20 Dec 2013 10:20:32 +0000 Content-Type: application/sdp Content-Length: 271 Content-Base: rtsp://example.com/twister.3gp/ Expires: Fri, 20 Dec 2013 12:20:32 +0000",
      "ja": "M-> C：RTSP / 2.0 200 OKのCSeq：1つのサーバ：PhonyServer / 1.0日付：金、2013年12月20日10時20分32秒0000のContent-Type：アプリケーション/ SDPコンテンツの長さ：271コンテンツベース：RTSP： //example.com/twister.3gp/有効期限：金、2013年12月20日12時20分32秒0000"
    },
    {
      "indent": 9,
      "text": "v=0\no=- 2890844256 2890842807 IN IP4 192.0.2.5\ns=RTSP Session\ni=An Example of RTSP Session Usage\ne=adm@example.com\nc=IN IP4 0.0.0.0\na=control: *\na=range:npt=00:00:00-00:10:34.10\nt=0 0\nm=audio 0 RTP/AVP 0\na=control: trackID=1\nm=video 0 RTP/AVP 26\na=control: trackID=4",
      "raw": true
    },
    {
      "indent": 3,
      "text": "C->M: SETUP rtsp://example.com/twister.3gp/trackID=1 RTSP/2.0 CSeq: 2 User-Agent: PhonyClient/1.2 Require: play.basic Transport: RTP/AVP;unicast;dest_addr=\":8000\"/\":8001\" Accept-Ranges: npt, smpte, clock Pipelined-Requests: 7654",
      "ja": "C-> M：SETUPのRTSP：//example.com/twister.3gp/trackID=1 RTSP / 2.0のCSeq：2のUser-Agent：PhonyClient / 1.2が必要：play.basicトランスポート：RTP / AVP;ユニキャスト; dest_addrは=」 ：8000 \"/\"：8001\" にAccept-範囲：NPT、SMPTE、クロックパイプライン・リクエスト：7654"
    },
    {
      "indent": 3,
      "text": "C->M: SETUP rtsp://example.com/twister.3gp/trackID=4 RTSP/2.0 CSeq: 3 User-Agent: PhonyClient/1.2 Require: play.basic Transport: RTP/AVP;unicast;dest_addr=\":8002\"/\":8003\" Accept-Ranges: npt, smpte, clock Pipelined-Requests: 7654",
      "ja": "C-> M：SETUPのRTSP：//example.com/twister.3gp/trackID=4 RTSP / 2.0のCSeq：3のUser-Agent：PhonyClient / 1.2が必要：play.basicトランスポート：RTP / AVP;ユニキャスト; dest_addrは=」 ：8002 \"/\"：8003\" にAccept-範囲：NPT、SMPTE、クロックパイプライン・リクエスト：7654"
    },
    {
      "indent": 3,
      "text": "C->M: PLAY rtsp://example.com/twister.3gp/ RTSP/2.0 CSeq: 4 User-Agent: PhonyClient/1.2 Range: npt=0- Seek-Style: RAP Pipelined-Requests: 7654",
      "ja": "C-> M：PLAYのRTSP：4のUser-Agent：PhonyClient / 1.2範囲：NPT = 0-シークスタイル：RAPパイプライン-要求：RTSP / 2.0のCSeq //example.com/twister.3gp/ 7654"
    },
    {
      "indent": 3,
      "text": "M->C: RTSP/2.0 200 OK\n      CSeq: 2\n      Server: PhonyServer/1.0\n      Transport: RTP/AVP;unicast;\n                 dest_addr=\"192.0.2.53:8000\"/\"192.0.2.53:8001\";\n                 src_addr=\"198.51.100.5:9000\"/\"198.51.100.5:9001\";\n                 ssrc=93CB001E\n      Session: OccldOFFq23KwjYpAnBbUr\n      Expires: Fri, 20 Dec 2013 12:20:32 +0000\n      Date: Fri, 20 Dec 2013 10:20:32 +0000\n      Accept-Ranges: npt\n      Pipelined-Requests: 7654\n      Media-Properties: Random-Access=0.2, Immutable, Unlimited",
      "raw": true
    },
    {
      "indent": 3,
      "text": "M->C: RTSP/2.0 200 OK\n      CSeq: 3\n      Server: PhonyServer/1.0\n      Transport: RTP/AVP;unicast;\n                 dest_addr=\"192.0.2.53:8002\"/\"192.0.2.53:8003;\n                 src_addr=\"198.51.100.5:9002\"/\"198.51.100.5:9003\";\n                 ssrc=A813FC13\n      Session: OccldOFFq23KwjYpAnBbUr\n      Expires: Sat, 21 Dec 2013 10:20:32 +0000\n      Date: Fri, 20 Dec 2013 10:20:32 +0000\n      Accept-Range: NPT\n      Pipelined-Requests: 7654\n      Media-Properties: Random-Access=0.8, Immutable, Unlimited",
      "raw": true
    },
    {
      "indent": 3,
      "text": "M->C: RTSP/2.0 200 OK CSeq: 4 Server: PhonyServer/1.0 Date: Fri, 20 Dec 2013 10:20:32 +0000 Session: OccldOFFq23KwjYpAnBbUr Range: npt=0-623.10 Seek-Style: RAP RTP-Info: url=\"rtsp://example.com/twister.3gp/trackID=4\" ssrc=0D12F123:seq=12345;rtptime=3450012, url=\"rtsp://example.com/twister.3gp/trackID=1\" ssrc=4F312DD8:seq=54321;rtptime=2876889 Pipelined-Requests: 7654",
      "ja": "M-> C：RTSP / 2.0 200 OKのCSeq：4サーバー：PhonyServer / 1.0日付：金、2013年12月20日10時20分32秒0000セッション：OccldOFFq23KwjYpAnBbUr範囲：NPT = 0から623.10シークスタイル：RAP RTP-情報：URL = \"RTSP：//example.com/twister.3gp/trackID=4\" SSRC = 0D12F123：SEQ = 12345; rtptime = 3450012、URL = \"RTSP：//example.com/twister.3gp/trackID=1 「SSRC = 4F312DD8：SEQ = 54321; rtptime = 2876889パイプライン・リクエスト：7654"
    },
    {
      "indent": 0,
      "text": "A.3. Secured Media Session for On-Demand Content",
      "ja": "A.3。オンデマンドコンテンツのメディアセッションを確保"
    },
    {
      "indent": 3,
      "text": "This example is basically the above example (Appendix A.2), but now including establishment of SRTP crypto contexts to get a secured media delivery. First of all, the client attempts to fetch this insecurely, but the server redirects to a URI indicating a requirement on using a secure connection for the RTSP messages. The client establishes a TCP/TLS connection, and the session description is retrieved to determine what media resources need to be set up. In the this session description, secure media (SRTP) is indicated. In the next step, the client sends the necessary SETUP requests including MIKEY messages. This is pipelined with a PLAY request to initiate media delivery.",
      "ja": "この例では、基本的には上記の例（付録A.2）であるが、現在はセキュアなメディア配信を取得するために、SRTP暗号コンテキストの確立を含みます。まず、クライアントは、安全でない、これを取得しようとしますが、サーバーは、RTSPメッセージのための安全な接続を使用する場合の要件を示すURIにリダイレクトします。クライアントは、TCP / TLS接続を確立し、セッション記述は、メディアリソースを設定する必要があるかを決定するために取得されます。このセッション記述では、セキュアメディア（SRTP）が示されています。次のステップでは、クライアントは、MIKEYメッセージを含む必要なSETUP要求を送信します。これは、メディア配信を開始するPLAY要求にパイプライン化されています。"
    },
    {
      "indent": 3,
      "text": "Client C requests a presentation from media server M. The movie is stored in a container file. The client has obtained an RTSP URI to the container file.",
      "ja": "クライアントCは、ムービーがコンテナファイルに格納されたメディアサーバM.からのプレゼンテーションを要求します。クライアントは、コンテナファイルにRTSP URIを取得しています。"
    },
    {
      "indent": 3,
      "text": "Note: The MIKEY messages below are not valid MIKEY messages and are Base64-encoded random data to represent where the MIKEY messages would go.",
      "ja": "注：以下MIKEYメッセージが有効なMIKEYメッセージではなく、MIKEYメッセージが行く場所を表すために、Base64でエンコードされたランダムデータです。"
    },
    {
      "indent": 3,
      "text": "C->M: DESCRIBE rtsp://example.com/twister.3gp RTSP/2.0 CSeq: 1 User-Agent: PhonyClient/1.2",
      "ja": "C-> M：RTSPの記述：1つのUser-Agent：PhonyClient / 1.2 RTSP / 2.0のCSeq //example.com/twister.3gp"
    },
    {
      "indent": 3,
      "text": "M->C: RTSP/2.0 301 Moved Permanently CSeq: 1 Server: PhonyServer/1.0 Date: Fri, 20 Dec 2013 10:25:32 +0000 Location: rtsps://example.com/twister.3gp",
      "ja": "M-> C：1つのサーバー：PhonyServer / 1.0日付：金、2013年12月20日10時25分32秒+0000場所：RTSPS：//example.com/twister.3gp RTSP / 2.0 301が永久のCSeqを動かし"
    },
    {
      "indent": 3,
      "text": "C->M: Establish TCP/TLS connection and verify server's certificate that represents example.com. Used for all below RTSP messages.",
      "ja": "C-> M：TCP / TLS接続を確立し、example.comを表し、サーバーの証明書を確認してください。 RTSPメッセージの下にあるすべてのために使用されます。"
    },
    {
      "indent": 3,
      "text": "C->M: DESCRIBE rtsps://example.com/twister.3gp RTSP/2.0 CSeq: 2 User-Agent: PhonyClient/1.2",
      "ja": "C-> M：RTSPSの記述：2のUser-Agent：PhonyClient / 1.2 RTSP / 2.0のCSeq //example.com/twister.3gp"
    },
    {
      "indent": 3,
      "text": "M->C: RTSP/2.0 200 OK CSeq: 2 Server: PhonyServer/1.0 Date: Fri, 20 Dec 2013 10:25:33 +0000 Content-Type: application/sdp Content-Length: 271 Content-Base: rtsps://example.com/twister.3gp/ Expires: Fri, 20 Dec 2013 12:25:33 +0000",
      "ja": "M-> C：RTSP / 2.0 200 OKのCSeq：2サーバー：PhonyServer / 1.0日付：金、2013年12月20日午前10時25分33秒0000のContent-Type：アプリケーション/ SDPコンテンツの長さ：271コンテンツベース：RTSPS： //example.com/twister.3gp/有効期限：金、2013年12月20日12時25分33秒0000"
    },
    {
      "indent": 9,
      "text": "v=0\no=- 2890844256 2890842807 IN IP4 192.0.2.5\ns=RTSP Session\ni=An Example of RTSP Session Usage\ne=adm@example.com\nc=IN IP4 0.0.0.0\na=control: *\na=range:npt=00:00:00-00:10:34.10\nt=0 0\nm=audio 0 RTP/SAVP 0\na=control: trackID=1\nm=video 0 RTP/SAVP 26\na=control: trackID=4",
      "raw": true
    },
    {
      "indent": 3,
      "text": "C->M: SETUP rtsps://example.com/twister.3gp/trackID=1 RTSP/2.0 CSeq: 3 User-Agent: PhonyClient/1.2 Require: play.basic Transport: RTP/SAVP;unicast;dest_addr=\":8000\"/\":8001\"; MIKEY=VGhpcyBpcyB0aGUgZmlyc3Qgc3RyZWFtcyBNSUtFWSBtZXNzYWdl Accept-Ranges: npt, smpte, clock Pipelined-Requests: 7654",
      "ja": "C-> M：SETUPのRTSPS：//example.com/twister.3gp/trackID=1 RTSP / 2.0のCSeq：3のUser-Agent：PhonyClient / 1.2が必要：play.basicトランスポート：RTP / SAVPと、ユニキャスト、dest_addrは=」 ：8000 \"/\"：8001\" ; MIKEY = VGhpcyBpcyB0aGUgZmlyc3Qgc3RyZWFtcyBNSUtFWSBtZXNzYWdlは受け入れ-範囲：NPT、SMPTE、クロックパイプライン・リクエスト：7654"
    },
    {
      "indent": 3,
      "text": "C->M: SETUP rtsps://example.com/twister.3gp/trackID=4 RTSP/2.0 CSeq: 4 User-Agent: PhonyClient/1.2 Require: play.basic Transport: RTP/SAVP;unicast;dest_addr=\":8002\"/\":8003\"; MIKEY=TUlLRVkgZm9yIHN0cmVhbSB0d2lzdGVyLjNncC90cmFja0lEPTQ= Accept-Ranges: npt, smpte, clock Pipelined-Requests: 7654",
      "ja": "C-> M：SETUPのRTSPS：//example.com/twister.3gp/trackID=4 RTSP / 2.0のCSeq：4のUser-Agent：PhonyClient / 1.2が必要：play.basicトランスポート：RTP / SAVPと、ユニキャスト、dest_addrは=」 ：8002 \"/\"：8003\" ; MIKEYは= TUlLRVkgZm9yIHN0cmVhbSB0d2lzdGVyLjNncC90cmFja0lEPTQ =-範囲を受け入れ：NPT、SMPTE、クロックパイプライン・リクエスト：7654"
    },
    {
      "indent": 3,
      "text": "C->M: PLAY rtsps://example.com/twister.3gp/ RTSP/2.0 CSeq: 5 User-Agent: PhonyClient/1.2 Range: npt=0- Seek-Style: RAP Pipelined-Requests: 7654",
      "ja": "C-> M：PLAYのRTSPS：5のUser-Agent：PhonyClient / 1.2範囲：NPT = 0-シークスタイル：RAPパイプライン-要求：RTSP / 2.0のCSeq //example.com/twister.3gp/ 7654"
    },
    {
      "indent": 3,
      "text": "M->C: RTSP/2.0 200 OK\n      CSeq: 3\n      Server: PhonyServer/1.0\n      Transport: RTP/SAVP;unicast;\n         dest_addr=\"192.0.2.53:8000\"/\"192.0.2.53:8001\";\n         src_addr=\"198.51.100.5:9000\"/\"198.51.100.5:9001\";\n         ssrc=93CB001E;\n         MIKEY=TUlLRVkgUmVzcG9uc2UgdHdpc3Rlci4zZ3AvdHJhY2tJRD0x\n      Session: OccldOFFq23KwjYpAnBbUr\n      Expires: Fri, 20 Dec 2013 12:25:34 +0000\n      Date: Fri, 20 Dec 2013 10:25:34 +0000\n      Accept-Ranges: npt\n      Pipelined-Requests: 7654\n      Media-Properties: Random-Access=0.2, Immutable, Unlimited",
      "raw": true
    },
    {
      "indent": 3,
      "text": "M->C: RTSP/2.0 200 OK\n      CSeq: 4\n      Server: PhonyServer/1.0\n      Transport: RTP/SAVP;unicast;\n         dest_addr=\"192.0.2.53:8002\"/\"192.0.2.53:8003;\n         src_addr=\"198.51.100.5:9002\"/\"198.51.100.5:9003\";\n         ssrc=A813FC13;\n         MIKEY=TUlLRVkgUmVzcG9uc2UgdHdpc3Rlci4zZ3AvdHJhY2tJRD00\n      Session: OccldOFFq23KwjYpAnBbUr\n      Expires: Fri, 20 Dec 2013 12:25:34 +0000\n      Date: Fri, 20 Dec 2013 10:25:34 +0000\n      Accept-Range: NPT\n      Pipelined-Requests: 7654\n      Media-Properties: Random-Access=0.8, Immutable, Unlimited",
      "raw": true
    },
    {
      "indent": 3,
      "text": "M->C: RTSP/2.0 200 OK CSeq: 5 Server: PhonyServer/1.0 Date: Fri, 20 Dec 2013 10:25:34 +0000 Session: OccldOFFq23KwjYpAnBbUr Range: npt=0-623.10 Seek-Style: RAP RTP-Info: url=\"rtsps://example.com/twister.3gp/trackID=4\" ssrc=0D12F123:seq=12345;rtptime=3450012, url=\"rtsps://example.com/twister.3gp/trackID=1\" ssrc=4F312DD8:seq=54321;rtptime=2876889; Pipelined-Requests: 7654",
      "ja": "M-> C：RTSP / 2.0 200 OKのCSeq：5サーバー：PhonyServer / 1.0日付：金、2013年12月20日午前10時25分34秒0000セッション：OccldOFFq23KwjYpAnBbUr範囲：NPT = 0から623.10シークスタイル：RAP RTP-情報：URL = \"RTSPS：//example.com/twister.3gp/trackID=4\" SSRC = 0D12F123：SEQ = 12345; rtptime = 3450012、URL = \"RTSPS：//example.com/twister.3gp/trackID=1 「SSRC = 4F312DD8：SEQ = 54321; rtptime = 2876889;パイプライン化 - リクエスト：7654"
    },
    {
      "indent": 0,
      "text": "A.4. Media on Demand (Unicast)",
      "ja": "A.4。オンデマンドメディア（ユニキャスト）"
    },
    {
      "indent": 3,
      "text": "An alternative example of media on demand with a few more tweaks is the following. Client C requests a movie distributed from two different media servers A (audio.example.com) and V (video.example.com). The media description is stored on a web server W. The media description contains descriptions of the presentation and all its streams, including the codecs that are available and the protocol stack.",
      "ja": "さらにいくつかの微調整とオンデマンドメディアの代替例は以下の通りです。クライアントCは、二つの異なるメディアサーバーのA（audio.example.com）とV（video.example.com）から配信映画を要求します。メディア記述は、メディアの説明が用意されていコーデックおよびプロトコルスタックを含むプレゼンテーションの説明とそのすべてのストリームを、含まれているウェブサーバWに格納されています。"
    },
    {
      "indent": 3,
      "text": "In this example, the client is only interested in the last part of the movie.",
      "ja": "この例では、クライアントは、映画の最後の部分にのみ関心があります。"
    },
    {
      "indent": 3,
      "text": "C->W: GET /twister.sdp HTTP/1.1 Host: www.example.com Accept: application/sdp",
      "ja": "C-> W：GET /twister.sdp HTTP / 1.1ホスト：www.example.com受け入れ：アプリケーション/ SDP"
    },
    {
      "indent": 3,
      "text": "W->C: HTTP/1.1 200 OK Date: Wed, 23 Jan 2013 15:35:06 GMT Content-Type: application/sdp Content-Length: 278 Expires: Thu, 24 Jan 2013 15:35:06 GMT",
      "ja": "W-> C：HTTP / 1.1 200 OK日：水曜日、2013年1月23日午前15時35分06秒GMTのコンテンツタイプ：アプリケーション/ SDPコンテンツの長さ：278の有効期限：木、2013年1月24日午前15時35分06秒GMTを"
    },
    {
      "indent": 9,
      "text": "v=0\no=- 2890844526 2890842807 IN IP4 198.51.100.5\ns=RTSP Session\ne=adm@example.com\nc=IN IP4 0.0.0.0\na=range:npt=00:00:00-01:49:34\nt=0 0\nm=audio 0 RTP/AVP 0\na=control:rtsp://audio.example.com/twister/audio.en\nm=video 0 RTP/AVP 31\na=control:rtsp://video.example.com/twister/video",
      "raw": true
    },
    {
      "indent": 3,
      "text": "C->A: SETUP rtsp://audio.example.com/twister/audio.en RTSP/2.0 CSeq: 1 User-Agent: PhonyClient/1.2 Transport: RTP/AVP/UDP;unicast;dest_addr=\":3056\"/\":3057\", RTP/AVP/TCP;unicast;interleaved=0-1 Accept-Ranges: npt, smpte, clock",
      "ja": "C-> A：SETUPのRTSP：1のUser-Agent：PhonyClient / 1.2トランスポート：RTSP / 2.0のCSeq //audio.example.com/twister/audio.en RTP / AVP / UDP、ユニキャスト、dest_addrは= \"3056\" / \"：3057\"、RTP / AVP / TCP;ユニキャスト、インターリーブされた= 0-1のAccept-範囲：NPT、SMPTE、クロック"
    },
    {
      "indent": 3,
      "text": "A->C: RTSP/2.0 200 OK\n      CSeq: 1\n      Session: OccldOFFq23KwjYpAnBbUr\n      Transport: RTP/AVP/UDP;unicast;\n                 dest_addr=\"192.0.2.53:3056\"/\"192.0.2.53:3057\";\n                 src_addr=\"198.51.100.5:5000\"/\"198.51.100.5:5001\"\n      Date: Wed, 23 Jan 2013 15:35:12 +0000\n      Server: PhonyServer/1.0\n      Expires: Thu, 24 Jan 2013 15:35:12 +0000\n      Cache-Control: public\n      Accept-Ranges: npt, smpte\n      Media-Properties: Random-Access=0.02, Immutable, Unlimited",
      "raw": true
    },
    {
      "indent": 3,
      "text": "C->V: SETUP rtsp://video.example.com/twister/video RTSP/2.0 CSeq: 1 User-Agent: PhonyClient/1.2 Transport: RTP/AVP/UDP;unicast; dest_addr=\"192.0.2.53:3058\"/\"192.0.2.53:3059\", RTP/AVP/TCP;unicast;interleaved=0-1 Accept-Ranges: npt, smpte, clock",
      "ja": "C-> V：SETUPのRTSP：1つのUser-Agent：PhonyClient / 1.2トランスポート：RTSP / 2.0のCSeq //video.example.com/twister/video RTP / AVP / UDP、ユニキャスト。 dest_addrは= \"192.0.2.53:3058\" / \"192.0.2.53:3059\"、RTP / AVP / TCP;ユニキャスト、インターリーブされた= 0-1のAccept-範囲：NPT、SMPTE、クロック"
    },
    {
      "indent": 3,
      "text": "V->C: RTSP/2.0 200 OK\n      CSeq: 1\n      Session: P5it3pMo6xHkjUcDrNkBjf\n      Transport: RTP/AVP/UDP;unicast;\n         dest_addr=\"192.0.2.53:3058\"/\"192.0.2.53:3059\";\n         src_addr=\"198.51.100.5:5002\"/\"198.51.100.5:5003\"\n      Date: Wed, 23 Jan 2013 15:35:12 +0000\n      Server: PhonyServer/1.0\n      Cache-Control: public\n      Expires: Thu, 24 Jan 2013 15:35:12 +0000\n      Accept-Ranges: npt, smpte\n      Media-Properties: Random-Access=1.2, Immutable, Unlimited",
      "raw": true
    },
    {
      "indent": 3,
      "text": "C->V: PLAY rtsp://video.example.com/twister/video RTSP/2.0 CSeq: 2 User-Agent: PhonyClient/1.2 Session: P5it3pMo6xHkjUcDrNkBjf Range: smpte=0:10:00-",
      "ja": "C-> V：PLAYのRTSP：//video.example.com/twister/video RTSP / 2.0のCSeq：2のUser-Agent：PhonyClient / 1.2セッション：P5it3pMo6xHkjUcDrNkBjf範囲：SMPTE = 0：10：00-"
    },
    {
      "indent": 3,
      "text": "V->C: RTSP/2.0 200 OK CSeq: 2 Session: P5it3pMo6xHkjUcDrNkBjf Range: smpte=0:10:00-1:49:23 Seek-Style: First-Prior RTP-Info: url=\"rtsp://video.example.com/twister/video\" ssrc=A17E189D:seq=12312232;rtptime=78712811 Server: PhonyServer/2.0 Date: Wed, 23 Jan 2013 15:35:13 +0000",
      "ja": "V-> C：RTSP / 2.0 200 OKのCSeq：2セッション：P5it3pMo6xHkjUcDrNkBjf範囲：SMPTE = 0：10：00-1：49：23シークスタイルを：まず、前RTP-情報：URL = \"RTSP：//ビデオ.example.comと/ツイスター/ビデオ」SSRC = A17E189D：SEQ = 12312232; rtptime = 78712811サーバー：PhonyServer / 2.0日付：水曜日、2013年1月23日夜3時35分13秒0000"
    },
    {
      "indent": 3,
      "text": "C->A: PLAY rtsp://audio.example.com/twister/audio.en RTSP/2.0 CSeq: 2 User-Agent: PhonyClient/1.2 Session: OccldOFFq23KwjYpAnBbUr Range: smpte=0:10:00-",
      "ja": "C-> A：PLAYのRTSP：2のUser-Agent：RTSP / 2.0のCSeq //audio.example.com/twister/audio.en PhonyClient / 1.2セッション：OccldOFFq23KwjYpAnBbUr範囲：SMPTE = 0：10：00-"
    },
    {
      "indent": 3,
      "text": "A->C: RTSP/2.0 200 OK CSeq: 2 Session: OccldOFFq23KwjYpAnBbUr Range: smpte=0:10:00-1:49:23 Seek-Style: First-Prior RTP-Info: url=\"rtsp://audio.example.com/twister/audio.en\" ssrc=3D124F01:seq=876655;rtptime=1032181 Server: PhonyServer/1.0 Date: Wed, 23 Jan 2013 15:35:13 +0000",
      "ja": "A-> C：RTSP / 2.0 200 OKのCSeq：2セッション：OccldOFFq23KwjYpAnBbUr範囲：SMPTE = 0：10：00-1：49：23シークスタイルを：まず、前RTP-情報：URL = \"RTSP：//オーディオ.example.comと/ツイスター/ audio.en」SSRC = 3D124F01：SEQ = 876655; rtptime = 1032181サーバー：PhonyServer / 1.0日付：水曜日、2013年1月23日夜3時35分13秒0000"
    },
    {
      "indent": 3,
      "text": "C->A: TEARDOWN rtsp://audio.example.com/twister/audio.en RTSP/2.0 CSeq: 3 User-Agent: PhonyClient/1.2 Session: OccldOFFq23KwjYpAnBbUr",
      "ja": "C-> A：TEARDOWNのRTSP：3のUser-Agent：PhonyClient / 1.2セッション：OccldOFFq23KwjYpAnBbUr RTSP / 2.0のCSeq //audio.example.com/twister/audio.en"
    },
    {
      "indent": 3,
      "text": "A->C: RTSP/2.0 200 OK CSeq: 3 Server: PhonyServer/1.0 Date: Wed, 23 Jan 2013 15:36:52 +0000",
      "ja": "A-> C：RTSP / 2.0 200 OKのCSeq：3サーバー：PhonyServer / 1.0日付：水曜日、2013年1月23日午後03時36分52秒0000"
    },
    {
      "indent": 3,
      "text": "C->V: TEARDOWN rtsp://video.example.com/twister/video RTSP/2.0 CSeq: 3 User-Agent: PhonyClient/1.2 Session: P5it3pMo6xHkjUcDrNkBjf",
      "ja": "C-> V：TEARDOWNのRTSP：RTSP / 2.0のCSeq //video.example.com/twister/video：3のUser-Agent：PhonyClient / 1.2セッション：P5it3pMo6xHkjUcDrNkBjf"
    },
    {
      "indent": 3,
      "text": "V->C: RTSP/2.0 200 OK CSeq: 3 Server: PhonyServer/2.0 Date: Wed, 23 Jan 2013 15:36:52 +0000",
      "ja": "V-> C：RTSP / 2.0 200 OKのCSeq：3サーバー：PhonyServer / 2.0日付：水曜日、2013年1月23日午後03時36分52秒0000"
    },
    {
      "indent": 3,
      "text": "Even though the audio and video track are on two different servers that may start at slightly different times and may drift with respect to each other over time, the client can perform initial synchronization of the two media using RTP-Info and Range received in the PLAY responses. If the two servers are time synchronized, the RTCP packets can also be used to maintain synchronization.",
      "ja": "オーディオとビデオトラックがわずかに異なる時間を開始することができ、時間の経過とともに、互いに対してドリフトすることが2台の異なるサーバー上にあるにもかかわらず、クライアントは、RTP-情報とレンジを使用して、2つのメディアの初期同期を実行することができPLAYで受信反応。 2台のサーバーが時間同期している場合は、RTCPパケットは、同期を維持するために使用することができます。"
    },
    {
      "indent": 0,
      "text": "A.5. Single-Stream Container Files",
      "ja": "A.5。単一ストリームコンテナファイル"
    },
    {
      "indent": 3,
      "text": "Some RTSP servers may treat all files as though they are \"container files\", yet other servers may not support such a concept. Because of this, clients needs to use the rules set forth in the session description for Request-URIs rather than assuming that a consistent URI may always be used throughout. Below is an example of how a multi-stream server might expect a single-stream file to be served:",
      "ja": "彼らは、「コンテナファイル」であるかのように、一部のRTSPサーバは、すべてのファイルを扱うことができ、さらに他のサーバには、このような概念をサポートしていないかもしれません。このため、クライアントではなく、一貫したURIは常に全体にわたって使用されてもよいことが想定以上のRequest-URIのセッション記述に記載されたルールを使用する必要があります。以下は、マルチストリームサーバーが単一ストリームファイルが提供されることを期待するかもしれない方法の例です。"
    },
    {
      "indent": 3,
      "text": "C->S: DESCRIBE rtsp://foo.example.com/test.wav RTSP/2.0 Accept: application/x-rtsp-mh, application/sdp CSeq: 1 User-Agent: PhonyClient/1.2",
      "ja": "C-> S：DESCRIBE RTSP：//foo.example.com/test.wav RTSP / 2.0受け入れ：アプリケーション/ X-RTSP-MH、アプリケーション/ SDPのCSeq：1のUser-Agent：PhonyClient / 1.2"
    },
    {
      "indent": 3,
      "text": "S->C: RTSP/2.0 200 OK CSeq: 1 Content-base: rtsp://foo.example.com/test.wav/ Content-type: application/sdp Content-length: 163 Server: PhonyServer/1.0 Date: Wed, 23 Jan 2013 15:36:52 +0000 Expires: Thu, 24 Jan 2013 15:36:52 +0000",
      "ja": "S-> C：RTSP / 2.0 200 OKのCSeq：1コンテンツベース：RTSP：//foo.example.com/test.wav/コンテンツタイプ：アプリケーション/ sdpのコンテンツ長：163サーバー：PhonyServer / 1.0日付：水曜日、2013年1月23日午前15時36分52秒0000は、有効期限：木、2013年1月24日午前15時36分52秒0000を"
    },
    {
      "indent": 9,
      "text": "v=0\no=- 872653257 872653257 IN IP4 192.0.2.5\ns=mu-law wave file\ni=audio test\nc=IN IP4 0.0.0.0\nt=0 0\na=control: *\nm=audio 0 RTP/AVP 0\na=control:streamid=0",
      "raw": true
    },
    {
      "indent": 3,
      "text": "C->S: SETUP rtsp://foo.example.com/test.wav/streamid=0 RTSP/2.0 Transport: RTP/AVP/UDP;unicast; dest_addr=\":6970\"/\":6971\";mode=\"PLAY\" CSeq: 2 User-Agent: PhonyClient/1.2 Accept-Ranges: npt, smpte, clock",
      "ja": "C-> S：SETUPのRTSP：RTSP / 2.0輸送//foo.example.com/test.wav/streamid=0：RTP / AVP / UDP、ユニキャスト。 dest_addrは= \"：6970\" / \"：6971\";モード= \"PLAY\" のCSeq：2のUser-Agent：PhonyClient / 1.2のAccept-範囲：NPT、SMPTE、クロックを"
    },
    {
      "indent": 3,
      "text": "S->C: RTSP/2.0 200 OK\n      Transport: RTP/AVP/UDP;unicast;\n          dest_addr=\"192.0.2.53:6970\"/\"192.0.2.53:6971\";\n          src_addr=\"198.51.100.5:6970\"/\"198.51.100.5:6971\";\n          mode=\"PLAY\";ssrc=EAB98712\n      CSeq: 2\n      Session: NYkqQYKk0bb12BY3goyoyO\n      Expires: Thu, 24 Jan 2013 15:36:52 +0000\n      Server: PhonyServer/1.0\n      Date: Wed, 23 Jan 2013 15:36:52 +0000\n      Accept-Ranges: npt\n      Media-Properties: Random-Access=0.5, Immutable, Unlimited",
      "raw": true
    },
    {
      "indent": 3,
      "text": "C->S: PLAY rtsp://foo.example.com/test.wav/ RTSP/2.0 CSeq: 3 User-Agent: PhonyClient/1.2 Session: NYkqQYKk0bb12BY3goyoyO",
      "ja": "C-> S：PLAYのRTSP：RTSP / 2.0のCSeq //foo.example.com/test.wav/：3のUser-Agent：PhonyClient / 1.2セッション：NYkqQYKk0bb12BY3goyoyO"
    },
    {
      "indent": 3,
      "text": "S->C: RTSP/2.0 200 OK CSeq: 3 Server: PhonyServer/1.0 Date: Wed, 23 Jan 2013 15:36:52 +0000 Session: NYkqQYKk0bb12BY3goyoyO Range: npt=0-600 Seek-Style: RAP RTP-Info: url=\"rtsp://foo.example.com/test.wav/streamid=0\" ssrc=0D12F123:seq=981888;rtptime=3781123",
      "ja": "S-> C：RTSP / 2.0 200 OKのCSeq：3サーバー：PhonyServer / 1.0日付：水曜日、2013年1月23日午後03時36分52秒0000セッション：NYkqQYKk0bb12BY3goyoyO範囲：NPT = 0-600シークスタイル：RAP RTP-情報：URL = \"RTSP：//foo.example.com/test.wav/streamid=0\" SSRC = 0D12F123：SEQ = 981888; rtptime = 3781123"
    },
    {
      "indent": 3,
      "text": "Note the different URI in the SETUP command and then the switch back to the aggregate URI in the PLAY command. This makes complete sense when there are multiple streams with aggregate control, but it is less than intuitive in the special case where the number of streams is one. However, the server has declared the aggregated control URI in the SDP; therefore, this is legal.",
      "ja": "SETUPコマンドで、その後、スイッチバックPLAYコマンドで集計URIに異なるURIに留意されたいです。集約コントロールで複数のストリームがあるとき、これは完全に理にかなっているが、それはストリームの数が1つの特殊なケースでは、直感的な未満です。しかしながら、サーバは、SDPに集約制御URIを宣言しました。そのため、これは合法です。"
    },
    {
      "indent": 3,
      "text": "In this case, it is also required that servers accept implementations that use the non-aggregated interpretation and use the individual media URI, like this:",
      "ja": "この場合、また、サーバが非凝集の解釈を使用してこのように、個々のメディアURIを使用する実装を受け入れることが必要とされます。"
    },
    {
      "indent": 3,
      "text": "C->S: PLAY rtsp://example.com/test.wav/streamid=0 RTSP/2.0 CSeq: 3 User-Agent: PhonyClient/1.2 Session: NYkqQYKk0bb12BY3goyoyO",
      "ja": "C-> S：PLAYのRTSP：3のUser-Agent：RTSP / 2.0のCSeq //example.com/test.wav/streamid=0 PhonyClient / 1.2セッション：NYkqQYKk0bb12BY3goyoyO"
    },
    {
      "indent": 0,
      "text": "A.6. Live Media Presentation Using Multicast",
      "ja": "A.6。ライブメディアプレゼンテーション使用したマルチキャスト"
    },
    {
      "indent": 3,
      "text": "The media server M chooses the multicast address and port. Here, it is assumed that the web server only contains a pointer to the full description, while the media server M maintains the full description.",
      "ja": "メディアサーバMは、マルチキャストアドレスとポートを選択します。メディアサーバMは、完全な説明を維持しながら、ここでは、ウェブサーバが唯一の完全な説明へのポインタが含まれているものとします。"
    },
    {
      "indent": 3,
      "text": "C->W: GET /sessions.html HTTP/1.1 Host: www.example.com",
      "ja": "C-> W：GET /sessions.html HTTP / 1.1ホスト：www.example.com"
    },
    {
      "indent": 3,
      "text": "W->C: HTTP/1.1 200 OK Content-Type: text/html",
      "ja": "W-> C：HTTP / 1.1 200 OKのContent-Type：text / htmlの"
    },
    {
      "indent": 9,
      "text": "<html>\n  ...\n  <a href \"rtsp://live.example.com/concert/audio\">\n     Streamed Live Music performance </a>\n  ...\n</html>",
      "raw": true
    },
    {
      "indent": 3,
      "text": "C->M: DESCRIBE rtsp://live.example.com/concert/audio RTSP/2.0 CSeq: 1 Supported: play.basic, play.scale User-Agent: PhonyClient/1.2",
      "ja": "C-> M：RTSPの記述：1サポート：play.basic、play.scaleのUser-Agent：PhonyClient / 1.2 RTSP / 2.0のCSeq //live.example.com/concert/audio"
    },
    {
      "indent": 3,
      "text": "M->C: RTSP/2.0 200 OK CSeq: 1 Content-Type: application/sdp Content-Length: 183 Server: PhonyServer/1.0 Date: Wed, 23 Jan 2013 15:36:52 +0000 Supported: play.basic",
      "ja": "M-> C：RTSP / 2.0 200 OKのCSeq：1のContent-Type：アプリケーション/ SDPのContent-Length：183サーバー：PhonyServer / 1.0日付：水曜日、2013年1月23日夜03時36分52秒0000でサポートされている：play.basic"
    },
    {
      "indent": 9,
      "text": "v=0\no=- 2890844526 2890842807 IN IP4 192.0.2.5\ns=RTSP Session\nt=0 0\nm=audio 3456 RTP/AVP 0\nc=IN IP4 233.252.0.54/16\na=control: rtsp://live.example.com/concert/audio\na=range:npt=0-",
      "raw": true
    },
    {
      "indent": 3,
      "text": "C->M: SETUP rtsp://live.example.com/concert/audio RTSP/2.0 CSeq: 2 Transport: RTP/AVP;multicast; dest_addr=\"233.252.0.54:3456\"/\"233.252.0.54:3457\";ttl=16 Accept-Ranges: npt, smpte, clock User-Agent: PhonyClient/1.2",
      "ja": "C-> M：SETUPのRTSP：//live.example.com/concert/audio RTSP / 2.0のCSeq：2トランスポート：RTP / AVP;マルチキャスト。 dest_addrは= \"233.252.0.54:3456\" / \"にAccept-範囲233.252.0.54:3457\";ttl=16：NPT、SMPTE、クロックのUser-Agent：PhonyClient / 1.2"
    },
    {
      "indent": 3,
      "text": "M->C: RTSP/2.0 200 OK CSeq: 2 Server: PhonyServer/1.0 Date: Wed, 23 Jan 2013 15:36:52 +0000 Transport: RTP/AVP;multicast; dest_addr=\"233.252.0.54:3456\"/\"233.252.0.54:3457\";ttl=16 ;ssrc=4D12AB92/0DF876A3 Session: qHj4jidpmF6zy9v9tNbtxr Accept-Ranges: npt, clock Media-Properties: No-Seeking, Time-Progressing, Time-Duration=0",
      "ja": "M-> C：RTSP / 2.0 200 OKのCSeq：2サーバー：PhonyServer / 1.0日付：水曜日、2013年1月23日午後03時36分52秒0000トランスポート：RTP / AVP;マルチキャスト。 dest_addrは= \"233.252.0.54:3456\" / \"233.252.0.54:3457\";ttl=16; SSRC = 4D12AB92 / 0DF876A3セッション：qHj4jidpmF6zy9v9tNbtxrは-範囲受け入れ：NPT、クロックメディア・プロパティ：無シーク、時間が-進み、タイム-duration = 0"
    },
    {
      "indent": 3,
      "text": "C->M: PLAY rtsp://live.example.com/concert/audio RTSP/2.0 CSeq: 3 Session: qHj4jidpmF6zy9v9tNbtxr User-Agent: PhonyClient/1.2",
      "ja": "C-> M：PLAYのRTSP：RTSP / 2.0のCSeq //live.example.com/concert/audio：3セッション：qHj4jidpmF6zy9v9tNbtxrユーザーエージェント：PhonyClient / 1.2"
    },
    {
      "indent": 3,
      "text": "M->C: RTSP/2.0 200 OK CSeq: 3 Server: PhonyServer/1.0 Date: Wed, 23 Jan 2013 15:36:52 +0000 Session: qHj4jidpmF6zy9v9tNbtxr Seek-Style: Next Range:npt=1256- RTP-Info: url=\"rtsp://live.example.com/concert/audio\" ssrc=0D12F123:seq=1473; rtptime=80000",
      "ja": "M-> C：RTSP / 2.0 200 OKのCSeq：3サーバー：PhonyServer / 1.0日付：水曜日、2013年1月23日午後03時36分52秒0000セッション：qHj4jidpmF6zy9v9tNbtxrはシークスタイルを：次の範囲：NPT = 1256- RTP-情報： URL = \"RTSP：//live.example.com/concert/audio\" SSRC = 0D12F123：SEQ = 1473; rtptime = 80000"
    },
    {
      "indent": 0,
      "text": "A.7. Capability Negotiation",
      "ja": "A.7。機能ネゴシエーション"
    },
    {
      "indent": 3,
      "text": "This example illustrates how the client and server determine their capability to support a special feature, in this case, \"play.scale\". The server, through the client request and the included Supported header, learns that the client supports RTSP 2.0 and also supports the playback time scaling feature of RTSP. The server's response contains the following feature-related information to the client; it supports the basic media delivery functions (play.basic), the extended functionality of time scaling of content (play.scale), and one \"example.com\" proprietary feature (com.example.flight). The client also learns the methods supported (Public header) by the server for the indicated resource.",
      "ja": "この例では、クライアントとサーバが、この場合、「play.scale」に、特別な機能をサポートするために彼らの能力を決定する方法を示しています。サーバーは、クライアント要求と含まSupportedヘッダーを通じて、クライアントはRTSP 2.0をサポートし、また、RTSPの機能をスケーリング再生時間をサポートしていることを学習します。サーバの応答がクライアントに次の機能に関連する情報が含まれています。それは、基本的なメディア配信機能（play.basic）、コンテンツ（play.scale）のタイムスケーリングの拡張機能、および1「example.com」の独自機能（com.example.flight）をサポートしています。クライアントは、指定されたリソースのためにサーバによってサポートされている方法（公開ヘッダ）を学習します。"
    },
    {
      "indent": 3,
      "text": "C->S: OPTIONS rtsp://media.example.com/movie/twister.3gp RTSP/2.0 CSeq: 1 Supported: play.basic, play.scale User-Agent: PhonyClient/1.2",
      "ja": "C-> S：OPTIONSのRTSP：1サポート：play.basic、play.scaleのUser-Agent：PhonyClient / 1.2 RTSP / 2.0のCSeq //media.example.com/movie/twister.3gp"
    },
    {
      "indent": 3,
      "text": "S->C: RTSP/2.0 200 OK CSeq: 1 Public:OPTIONS,SETUP,PLAY,PAUSE,TEARDOWN,DESCRIBE,GET_PARAMETER Allow: OPTIONS, SETUP, PLAY, PAUSE, TEARDOWN, DESCRIBE Server: PhonyServer/2.0 Supported: play.basic, play.scale, com.example.flight",
      "ja": "S-> C：RTSP / 2.0 200 OKのCSeq：1公開：OPTIONS、SETUP、PLAY、PAUSE、TEARDOWN、DESCRIBE、GET_PARAMETERが許可：OPTIONS、SETUP、PLAY、PAUSE、TEARDOWN、サーバーについて説明します。PhonyServer / 2.0がサポートされている：遊びを。基本的な、play.scale、com.example.flight"
    },
    {
      "indent": 3,
      "text": "When the client sends its SETUP request, it tells the server that it requires support of the play.scale feature for this session by including the Require header.",
      "ja": "クライアントは、そのSETUP要求を送信すると、それはRequireヘッダーを含めることによって、このセッションのplay.scale機能のサポートを必要とするサーバーに指示します。"
    },
    {
      "indent": 3,
      "text": "C->S: SETUP rtsp://media.example.com/twister.3gp/trackID=1 RTSP/2.0 CSeq: 3 User-Agent: PhonyClient/1.2 Transport: RTP/AVP/UDP;unicast; dest_addr=\"192.0.2.53:3056\"/\"192.0.2.53:3057\", RTP/AVP/TCP;unicast;interleaved=0-1 Require: play.scale Accept-Ranges: npt, smpte, clock User-Agent: PhonyClient/1.2",
      "ja": "C-> S：SETUPのRTSP：//media.example.com/twister.3gp/trackID=1 RTSP / 2.0のCSeq：3のUser-Agent：PhonyClient / 1.2トランスポート：RTP / AVP / UDP;ユニキャスト; dest_addrは= \"192.0.2.53:3056\" / \"192.0.2.53:3057\"、RTP / AVP / TCP;ユニキャスト、インターリーブされた= 0-1が必要：play.scaleは受け入れ-範囲：NPT、SMPTE、クロックのUser-Agent：PhonyClient /1.2"
    },
    {
      "indent": 3,
      "text": "S->C: RTSP/2.0 200 OK\n      CSeq: 3\n      Session: OccldOFFq23KwjYpAnBbUr\n      Transport: RTP/AVP/UDP;unicast;\n         dest_addr=\"192.0.2.53:3056\"/\"192.0.2.53:3057\";\n         src_addr=\"198.51.100.5:5000\"/\"198.51.100.5:5001\"\n      Server: PhonyServer/2.0\n      Accept-Ranges: npt, smpte\n      Media-Properties: Random-Access=0.8, Immutable, Unlimited",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Appendix B. RTSP Protocol State Machine",
      "ja": "付録B. RTSPプロトコルのステートマシン"
    },
    {
      "indent": 3,
      "text": "The RTSP session state machine describes the behavior of the protocol from RTSP session initialization through RTSP session termination. It is probably easiest to think of this as the server's state and then view the client as needing to track what it believes the server's state will be based on sent or received RTSP messages. Thus, in most cases, the state tables below can be read as: if the client does X, and assuming it fulfills any prerequisite(s), the (server) state will move to the new state and the indicated response will returned. However, there are also server-to-client notifications or requests, where the action describes what notification or request will occur, its requisites, what new state will result after the server has received the response, as well as describing the client's response to the action.",
      "ja": "RTSPセッション状態マシンは、RTSPセッション終了を介してRTSPセッション初期化プロトコルからの挙動を記述する。これは、サーバの状態と考えると、それは、サーバーの状態が送信またはRTSPメッセージを受信に基づいています信じているものを追跡する必要があるものとして、クライアントを表示するために、おそらく最も簡単です。したがって、ほとんどの場合、以下の状態テーブルのように読み取ることができます。クライアントは、Xをした場合、それは任意の前提条件（複数可）を満たし仮定し、（サーバー）の状態は、新しい状態に移動し、指示された応答が返されます。ただし、サーバーからクライアントへの通知や要求は、アクションが発生しますどのような通知や要求記述ところ、その前提条件は、サーバが応答を受信した後に新しい何かの状態をなり、同様にクライアントの応答を記述し、またありますアクション。"
    },
    {
      "indent": 3,
      "text": "The State machine is defined on a per-session basis, which is uniquely identified by the RTSP session identifier. The session may contain one or more media streams depending on state. If a single media stream is part of the session, it is in non-aggregated control. If two or more are part of the session, it is in aggregated control.",
      "ja": "ステートマシンを一意RTSPセッション識別子によって識別されるセッションごと、上で定義されています。セッションでは、状態に応じて1つのまたは複数のメディアストリームが含まれていてもよいです。単一のメディアストリームは、セッションの一部である場合、それは非凝集の制御にあります。二つ以上のセッションの一部である場合は、それが集約されたコントロールです。"
    },
    {
      "indent": 3,
      "text": "The below state machine is an informative description of the protocol's behavior. In case of ambiguity with the earlier parts of this specification, the description in the earlier parts take precedence.",
      "ja": "以下のステートマシンは、プロトコルの挙動の有益な記述です。本明細書の以前の部分と曖昧さの場合には、以前の部分の記述が優先されます。"
    },
    {
      "indent": 0,
      "text": "B.1. States",
      "ja": "B.1。アメリカ"
    },
    {
      "indent": 3,
      "text": "The state machine contains three states, described below. For each state, there exists a table that shows which requests and events are allowed and whether they will result in a state change.",
      "ja": "ステートマシンは、以下の3つの状態が、含まれています。各状態について、要求し、イベントが許可されていると、彼らは状態の変化をもたらすかどうかかを示し、テーブルが存在します。"
    },
    {
      "indent": 3,
      "text": "Init: Initial state, no session exists.",
      "ja": "初期化：初期状態では、何のセッションが存在しません。"
    },
    {
      "indent": 3,
      "text": "Ready: Session is ready to start playing.",
      "ja": "レディ：セッションの再生を開始する準備ができています。"
    },
    {
      "indent": 3,
      "text": "Play: Session is playing, i.e., sending media-stream data in the direction S->C.",
      "ja": "プレイ：セッションが再生されている、すなわち、方向にメディア・ストリーム・データを送信し、S-> C。"
    },
    {
      "indent": 0,
      "text": "B.2. State Variables",
      "ja": "B.2。状態変数"
    },
    {
      "indent": 3,
      "text": "This representation of the state machine needs more than its state to work. A small number of variables are also needed, and they are explained below.",
      "ja": "ステートマシンのこの表現は、仕事にその状態以上のものを必要とします。変数の数が少ないにも必要とされており、これらは以下に説明されています。"
    },
    {
      "indent": 3,
      "text": "NRM: The number of media streams that are part of this session.",
      "ja": "NRM：このセッションの一部であるメディアストリームの数。"
    },
    {
      "indent": 3,
      "text": "RP: Resume point, the point in the presentation time line at which a request to continue playing will resume from. A time format for the variable is not mandated.",
      "ja": "RP：レジュームポイント、再生を継続する要求から再開するときのプレゼンテーションタイムラインのポイント。変数の時刻形式が義務付けられていません。"
    },
    {
      "indent": 0,
      "text": "B.3. Abbreviations",
      "ja": "B.3。略語"
    },
    {
      "indent": 3,
      "text": "To make the state tables more compact, a number of abbreviations are used, which are explained below.",
      "ja": "状態テーブルをよりコンパクトにするために、略語の数は、以下に説明され、使用されています。"
    },
    {
      "indent": 3,
      "text": "IFI: IF Implemented.",
      "ja": "IFI：実装されている場合。"
    },
    {
      "indent": 3,
      "text": "md: Media",
      "ja": "MD：メディア"
    },
    {
      "indent": 3,
      "text": "PP: Pause Point, the point in the presentation timeline at which the presentation was paused.",
      "ja": "PP：ポイント、プレゼンテーションが一時停止されたときのプレゼンテーションタイムライン内のポイントを一時停止します。"
    },
    {
      "indent": 3,
      "text": "Prs: Presentation, the complete multimedia presentation.",
      "ja": "PRS：プレゼンテーション、完全なマルチメディアプレゼンテーション。"
    },
    {
      "indent": 3,
      "text": "RedP: Redirect Point, the point in the presentation timeline at which a REDIRECT was specified to occur.",
      "ja": "REDP：ポイント、リダイレクトが発生すると、指定されたときのプレゼンテーションタイムラインでポイントをリダイレクトします。"
    },
    {
      "indent": 3,
      "text": "SES: Session.",
      "ja": "SES：セッション。"
    },
    {
      "indent": 0,
      "text": "B.4. State Tables",
      "ja": "B.4。状態テーブル"
    },
    {
      "indent": 3,
      "text": "This section contains a table for each state. The table contains all the requests and events on which this state is allowed to act. The events that are method names are, unless noted, requests with the given method in the direction client to server (C->S). In some cases, there exists one or more requisites. The response column tells what type of response actions should be performed. Possible actions that are requested for an event include: response codes, e.g., 200, headers that need to be included in the response, setting of state variables, or settings of other session-related parameters. The new state column tells which state the state machine changes to.",
      "ja": "このセクションでは、各状態のテーブルが含まれています。表には、この状態を作用させされているすべての要求とイベントが含まれています。注記がない限り、メソッド名であるイベントは、サーバー（C-> S）への方向クライアントで指定した方法で要求します。いくつかのケースでは、一つ以上の要件が存在します。応答列が実行されるべき応答アクションの種類を伝えます。イベントのために要求される可能なアクションは次のとおり応答コード、例えば、200、応答、状態変数の設定、または他のセッション関連のパラメータの設定に含まれる必要ヘッダを。新しい状態の欄には、ステートマシンの変更を述べているように指示します。"
    },
    {
      "indent": 3,
      "text": "The response to a valid request meeting the requisites is normally a 2xx (SUCCESS) unless otherwise noted in the response column. The exceptions need to be given a response according to the response column. If the request does not meet the requisite, is erroneous, or some other type of error occurs, the appropriate response code is to be sent. If the response code is a 4xx, the session state is unchanged. A response code of 3rr will result in that the session being ended and its state changed to Init. A response code of 304 results in no state change. However, there are restrictions to when a 3rr response may be used. A 5xx response does not result in any change of the session state, except if the error is not possible to recover from. An unrecoverable error results in the ending of the session. In the general case, if it can't be determined whether or not it was an unrecoverable error, the client will be required to test. In the case that the next request after a 5xx is responded to with a 454 (Session Not Found), the client knows that the session has ended. For any request message that cannot be responded to within the time defined in Section 10.4, a 100 response must be sent.",
      "ja": "そうでなければ、応答欄に記載がない限り、有効な要求を満たす要件に応じて、通常の2xx（成功）です。例外は、応答列に応じた応答を与えられる必要があります。要求が要件を満たしていない場合は、誤っている、またはエラーのいくつかの他の種類が発生し、適切な応答コードが送信されます。レスポンスコードが4xxのであれば、セッション状態は変更されません。 3RRの応答コードは、セッションが終了され、その状態が初期に変更されたことになります。状態変化304の結果の応答コード。しかし、3RR応答を使用することができるときに制限があります。 5xxの応答がエラーから回復することが可能でない場合を除いて、セッション状態のいずれかの変化をもたらしません。回復不能なエラーは、セッションの終了になります。エラーしたかどうかを判断することができない場合は一般的なケースでは、クライアントをテストする必要があります。 5xxの後に次の要求が454（セッションが見つかりません）で応答した場合には、クライアントは、セッションが終了したことを知っています。セクション10.4で定義された時間内に応答することはできません任意の要求メッセージの場合、100応答が送信される必要があります。"
    },
    {
      "indent": 3,
      "text": "The server will time out the session after the period of time specified in the SETUP response, if no activity from the client is detected. Therefore, there exists a timeout event for all states except Init.",
      "ja": "クライアントからのアクティビティが検出されない場合、サーバは、SETUP応答に指定された期間後にセッションをタイムアウトします。そのため、初期化を除くすべての状態のタイムアウトイベントが存在します。"
    },
    {
      "indent": 3,
      "text": "In the case that NRM = 1, the presentation URI is equal to the media URI or a specified presentation URI. For NRM > 1, the presentation URI needs to be other than any of the media that are part of the session. This applies to all states.",
      "ja": "NRM = 1の場合には、プレゼンテーションURIは、メディアURIまたは指定されたプレゼンテーションURIに等しいです。 > 1 NRMのために、プレゼンテーションURIはセッションの一部であるメディアのいずれ以外にする必要があります。これは、すべての状態に適用されます。"
    },
    {
      "indent": 3,
      "text": "+---------------+-----------------+---------------------------------+\n| Event         | Prerequisite    | Response                        |\n+---------------+-----------------+---------------------------------+\n| DESCRIBE      | Needs REDIRECT  | 3rr, Redirect                   |\n|               |                 |                                 |\n| DESCRIBE      |                 | 200, Session description        |\n|               |                 |                                 |\n| OPTIONS       | Session ID      | 200, Reset session timeout      |\n|               |                 | timer                           |\n|               |                 |                                 |\n| OPTIONS       |                 | 200                             |\n|               |                 |                                 |\n| SET_PARAMETER | Valid parameter | 200, change value of parameter  |\n|               |                 |                                 |\n| GET_PARAMETER | Valid parameter | 200, return value of parameter  |\n+---------------+-----------------+---------------------------------+",
      "raw": true
    },
    {
      "indent": 16,
      "text": "Table 9: Non-State-Machine Changing Events",
      "ja": "表9：非ステート・マシンの変更イベント"
    },
    {
      "indent": 3,
      "text": "The methods in Table 9 do not have any effect on the state machine or the state variables. However, some methods do change other session-related parameters, for example, SET_PARAMETER, which will set the parameter(s) specified in its body. Also, all of these methods that allow the Session header will also update the keep-alive timer for the session.",
      "ja": "表9の方法は、ステートマシンや状態変数には影響しません。しかし、いくつかの方法は、その本体内に指定されたパラメータ（複数可）を設定し、他のセッション関連パラメータ、例えば、SET_PARAMETERを、変更を行います。また、セッションのヘッダは、セッションのためのキープアライブタイマーを更新することができ、これらの方法のすべて。"
    },
    {
      "indent": 3,
      "text": "+------------------+----------------+-----------+-------------------+\n| Action           | Requisite      | New State | Response          |\n+------------------+----------------+-----------+-------------------+\n| SETUP            |                | Ready     | NRM=1, RP=0.0     |\n|                  |                |           |                   |\n| SETUP            | Needs Redirect | Init      | 3rr Redirect      |\n|                  |                |           |                   |\n| S -> C: REDIRECT | No Session hdr | Init      | Terminate all SES |\n+------------------+----------------+-----------+-------------------+",
      "raw": true
    },
    {
      "indent": 27,
      "text": "Table 10: State: Init",
      "ja": "表10：状態：初期化"
    },
    {
      "indent": 3,
      "text": "The initial state of the state machine (Table 10) can only be left by processing a correct SETUP request. As seen in the table, the two state variables are also set by a correct request. This table also shows that a correct SETUP can in some cases be redirected to another URI or server by a 3rr response.",
      "ja": "ステートマシン（表10）の初期状態は、正しいセットアップ要求を処理することによって残すことができます。表に見られるように、2つの状態変数は、正しい要求によって設定されます。この表はまた、正しい設定がある場合に3RR応答によって別のURIまたはサーバにリダイレクトすることができることを示しています。"
    },
    {
      "indent": 3,
      "text": "+-------------+------------------------+---------+------------------+\n| Action      | Requisite              | New     | Response         |\n|             |                        | State   |                  |\n+-------------+------------------------+---------+------------------+\n| SETUP       | New URI                | Ready   | NRM +=1          |\n|             |                        |         |                  |\n| SETUP       | URI Setup prior        | Ready   | Change transport |\n|             |                        |         | param            |\n|             |                        |         |                  |\n| TEARDOWN    | Prs URI,               | Init    | No session hdr,  |\n|             |                        |         | NRM = 0          |\n|             |                        |         |                  |\n| TEARDOWN    | md URI,NRM=1           | Init    | No Session hdr,  |\n|             |                        |         | NRM = 0          |\n|             |                        |         |                  |\n| TEARDOWN    | md URI,NRM>1           | Ready   | Session hdr, NRM |\n|             |                        |         | -= 1             |\n|             |                        |         |                  |\n| PLAY        | Prs URI, No range      | Play    | Play from RP     |\n|             |                        |         |                  |\n| PLAY        | Prs URI, Range         | Play    | According to     |\n|             |                        |         | range            |\n|             |                        |         |                  |\n| PLAY        | md URI, NRM=1, Range   | Play    | According to     |\n|             |                        |         | range            |\n|             |                        |         |                  |\n| PLAY        | md URI, NRM=1          | Play    | Play from RP     |\n|             |                        |         |                  |\n| PAUSE       | Prs URI                | Ready   | Return PP        |\n|             |                        |         |                  |\n| SC:REDIRECT | Terminate-Reason       | Ready   | Set RedP         |\n|             |                        |         |                  |\n| SC:REDIRECT | No Terminate-Reason    | Init    | Session is       |\n|             | time parameter         |         | removed          |\n|             |                        |         |                  |\n| Timeout     |                        | Init    |                  |\n|             |                        |         |                  |\n| RedP        |                        | Init    | TEARDOWN of      |\n| reached     |                        |         | session          |\n+-------------+------------------------+---------+------------------+",
      "raw": true
    },
    {
      "indent": 26,
      "text": "Table 11: State: Ready",
      "ja": "表11：状態：準備"
    },
    {
      "indent": 3,
      "text": "In the Ready state (Table 11), some of the actions depend on the number of media streams (NRM) in the session, i.e., aggregated or non-aggregated control. A SETUP request in the Ready state can either add one more media stream to the session or, if the media stream (same URI) already is part of the session, change the transport parameters. TEARDOWN depends on both the Request-URI and the number of media streams within the session. If the Request-URI is the presentation URI, the whole session is torn down. If a media URI is used in the TEARDOWN request and more than one media exists in the session, the session will remain and a session header is returned in the response. If only a single media stream remains in the session when performing a TEARDOWN with a media URI, the session is removed. The number of media streams remaining after tearing down a media stream determines the new state.",
      "ja": "レディ状態（表11）、アクションの一部、すなわち、凝集または非凝集制御、セッション内のメディアストリーム（NRM）の数に依存します。レディ状態にSETUP要求は、セッション1つの以上のメディアストリームを追加したり、メディアストリームの（同一のURI）が既にセッションの一部である場合、トランスポートパラメータを変更することができます。 TEARDOWNは、Request-URIおよびセッション内のメディアストリームの数の両方に依存します。リクエスト-URIがプレゼンテーションURIであれば、全体のセッションが切断されます。メディアURIがTEARDOWN要求で使用され、複数のメディアセッションに存在する場合、セッションが残り、セッション・ヘッダは、応答で返されます。メディアURIとTEARDOWNを実行するときにのみ、単一のメディアストリームは、セッション中に残っている場合、セッションは削除されます。メディアストリームを切断した後に残っているメディアストリームの数は、新しい状態を決定します。"
    },
    {
      "indent": 3,
      "text": "+----------------+-----------------------+--------+-----------------+\n| Action         | Requisite             | New    | Response        |\n|                |                       | State  |                 |\n+----------------+-----------------------+--------+-----------------+\n| PAUSE          | Prs URI               | Ready  | Set RP to       |\n|                |                       |        | present point   |\n|                |                       |        |                 |\n| End of media   | All media             | Play   | Set RP = End of |\n|                |                       |        | media           |\n|                |                       |        |                 |\n| End of range   |                       | Play   | Set RP = End of |\n|                |                       |        | range           |\n|                |                       |        |                 |\n| PLAY           | Prs URI, No range     | Play   | Play from       |\n|                |                       |        | present point   |\n|                |                       |        |                 |\n| PLAY           | Prs URI, Range        | Play   | According to    |\n|                |                       |        | range           |\n|                |                       |        |                 |\n| SC:PLAY_NOTIFY |                       | Play   | 200             |\n|                |                       |        |                 |\n| SETUP          | New URI               | Play   | 455             |\n|                |                       |        |                 |\n| SETUP          | md URI                | Play   | 455             |\n|                |                       |        |                 |\n| SETUP          | md URI, IFI           | Play   | Change          |\n|                |                       |        | transport param.|\n|                |                       |        |                 |\n| TEARDOWN       | Prs URI               | Init   | No session hdr  |\n|                |                       |        |                 |\n| TEARDOWN       | md URI,NRM=1          | Init   | No Session hdr, |\n|                |                       |        | NRM=0           |\n|                |                       |        |                 |\n| TEARDOWN       | md URI                | Play   | 455             |\n|                |                       |        |                 |\n| SC:REDIRECT    | Terminate Reason with | Play   | Set RedP        |\n|                | Time parameter        |        |                 |\n|                |                       |        |                 |\n| SC:REDIRECT    |                       | Init   | Session is      |\n|                |                       |        | removed         |\n|                |                       |        |                 |\n| RedP reached   |                       | Init   | TEARDOWN of     |\n|                |                       |        | session         |\n|                |                       |        |                 |\n| Timeout        |                       | Init   | Stop Media      |\n|                |                       |        | playout         |\n+----------------+-----------------------+--------+-----------------+\n                        Table 12: State: Play",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The Play state table (Table 12) contains a number of requests that need a presentation URI (labeled as Prs URI) to work on (i.e., the presentation URI has to be used as the Request-URI). This is due to the exclusion of non-aggregated stream control in sessions with more than one media stream.",
      "ja": "再生状態テーブル（表12）（即ち、プレゼンテーションURIがRequest-URIとして使用しなければならない）上で動作するように（PRS URIとして標識）提示URIを必要とする要求の数を含んでいます。これは、複数のメディア・ストリームとのセッションにおける非凝集ストリーム制御の排除によるものです。"
    },
    {
      "indent": 3,
      "text": "To avoid inconsistencies between the client and server, automatic state transitions are avoided. This can be seen at, for example, an \"End of media\" event when all media has finished playing but the session still remains in Play state. An explicit PAUSE request needs to be sent to change the state to Ready. It may appear that there exist automatic transitions in \"RedP reached\" and \"PP reached\". However, they are requested and acknowledged before they take place. The time at which the transition will happen is known by looking at the Terminate-Reason header's time parameter and Range header, respectively. If the client sends a request close in time to these transitions, it needs to be prepared for receiving error messages, as the state may or may not have changed.",
      "ja": "クライアントとサーバの間の不整合を回避するには、自動状態遷移が回避されます。これは、例えば、イベント「メディアの終焉」すべてのメディアが再生終了時にセッションは、まだプレイ状態のまま、で見ることができます。明示的なPAUSE要求が準備完了の状態を変更するために送信する必要があります。 「REDPに達し」及び「PPに達し」自動遷移が存在することが表示されてもよいです。しかし、彼らが要求され、彼らは場所を取る前に認めています。遷移が発生する時刻は、それぞれ、終了理由をヘッダの時間パラメータとRangeヘッダを見ることで知られています。クライアントは、これらの遷移までの時間のリクエスト近くを送信した場合、それは状態がまたは変更されていない可能性があり得るような、エラーメッセージを受信するために準備する必要があります。"
    },
    {
      "indent": 0,
      "text": "Appendix C. Media-Transport Alternatives",
      "ja": "付録C.メディア、交通の代替"
    },
    {
      "indent": 3,
      "text": "This section defines how certain combinations of protocols, profiles, and lower transports are used. This includes the usage of the Transport header's source and destination address parameters: \"src_addr\" and \"dest_addr\".",
      "ja": "このセクションでは、プロトコル、プロファイル、および下部トランスポートの特定の組み合わせが使用される方法を定義します。 「src_addrを」と「dest_addrは」：これは、トランスポートヘッダの送信元と宛先アドレスパラメータの使用を含んでいます。"
    },
    {
      "indent": 0,
      "text": "C.1. RTP",
      "ja": "C.1。 RTP"
    },
    {
      "indent": 3,
      "text": "This section defines the interaction of RTSP with respect to the RTP protocol [RFC3550]. It also defines any necessary media-transport signaling with regard to RTP.",
      "ja": "このセクションでは、RTPプロトコル[RFC3550]に対してRTSPの相互作用を定義します。また、RTPに関して必要なメディア輸送シグナルを定義します。"
    },
    {
      "indent": 3,
      "text": "The available RTP profiles and lower-layer transports are described below along with rules on signaling the available combinations.",
      "ja": "使用可能なRTPプロファイルと下層のトランスポートは、利用可能な組み合わせをシグナリングに関する規則とともに以下に記載されています。"
    },
    {
      "indent": 0,
      "text": "C.1.1. AVP",
      "ja": "C.1.1。 AVP"
    },
    {
      "indent": 3,
      "text": "The usage of the \"RTP Profile for Audio and Video Conferences with Minimal Control\" [RFC3551] when using RTP for media transport over different lower-layer transport protocols is defined below in regard to RTSP.",
      "ja": "「最小量のコントロールがあるオーディオとビデオ会議システムのためのRTPプロフィール」[RFC3551]の使用異なる下位層トランスポートプロトコルを介してメディアトランスポートのためにRTPを使用してはRTSPに関して以下に定義されます。"
    },
    {
      "indent": 3,
      "text": "One such case is defined within this document: the use of embedded (interleaved) binary data as defined in Section 14. The usage of this method is indicated by including the \"interleaved\" parameter.",
      "ja": "そのような場合は、この文書内で定義される：式（インターリーブ）バイナリデータの使用を「インターリーブ」パラメータを含むことによって示されている第14この方法の使用で定義されています。"
    },
    {
      "indent": 3,
      "text": "When using embedded binary data, \"src_addr\" and \"dest_addr\" MUST NOT be used. This addressing and multiplexing is used as defined with use of channel numbers and the interleaved parameter.",
      "ja": "埋め込まれたバイナリデータを使用する場合は、「src_addrを」と「dest_addrは」は使用してはいけません。チャンネル番号とインターリーブパラメータを用いて定義されたように、このアドレッシング及び多重化が使用されます。"
    },
    {
      "indent": 0,
      "text": "C.1.2. AVP/UDP",
      "ja": "C.1.2。 AVP / UDP"
    },
    {
      "indent": 3,
      "text": "This part describes the sending of RTP [RFC3550] over lower-transport-layer UDP [RFC768] according to the profile \"RTP Profile for Audio and Video Conferences with Minimal Control\" defined in [RFC3551]. Implementations of RTP/AVP/UDP MUST implement RTCP (Appendix C.1.6). This profile requires one or two unidirectional or bidirectional UDP flows per media stream. The first UDP flow is for RTP and the second is for RTCP. Multiplexing of RTP and RTCP (Appendix C.1.6.4) MAY be used, in which case, a single UDP flow is used for both parts. Embedding of RTP data with the RTSP messages, in accordance with Section 14, SHOULD NOT be performed when RTSP messages are transported over unreliable transport protocols, like UDP [RFC768].",
      "ja": "この部分は、下位のトランスポート層の上にRTP [RFC3550]の送信について説明UDP [RFC768] [RFC3551]で定義された「最小量のコントロールがあるオーディオとビデオ会議のためのRTPプロファイル」プロファイルに従って。 RTP / AVP / UDPの実装は、RTCP（付録C.1.6）を実装しなければなりません。このプロファイルは、メディアストリームごとに1つのまたは2つの単方向または双方向のUDPフローが必要です。最初のUDPフローは、RTPのためであり、第二は、RTCPのためです。 RTPおよびRTCP（付録C.1.6.4）の多重化は、その場合には、単一のUDPフローは、両方の部分のために使用され、使用されるかもしれません。 RTSPメッセージが信頼できないトランスポートプロトコルを介して輸送されるときRTSPメッセージとRTPデータの埋め込みは、第14条に従い、UDP [RFC768]のように、実行しないでください。"
    },
    {
      "indent": 3,
      "text": "The RTP/UDP and RTCP/UDP flows can be established using the Transport header's \"src_addr\" and \"dest_addr\" parameters.",
      "ja": "RTP / UDP及びRTCP / UDPフローは、トランスポートヘッダの「src_addrを」と「dest_addrは」パラメータを使用して確立することができます。"
    },
    {
      "indent": 3,
      "text": "In RTSP PLAY mode, the transmission of RTP packets from client to server is unspecified. The behavior in regard to such RTP packets MAY be defined in future.",
      "ja": "RTSPのPLAYモードでは、クライアントからサーバーへのRTPパケットの送信が指定されていません。そのようなRTPパケットに関してでの動作は将来定義されるかもしれません。"
    },
    {
      "indent": 3,
      "text": "The \"src_addr\" and \"dest_addr\" parameters are used in the following way for media delivery and playback mode, i.e., Mode=PLAY:",
      "ja": "「src_addrを」と「dest_addrは」パラメータは、メディア配信及び再生モード、すなわち、モード= PLAYのために、以下のように使用されています。"
    },
    {
      "indent": 3,
      "text": "o The \"src_addr\" and \"dest_addr\" parameters MUST contain either 1 or 2 address specifications. Note that two address specifications MAY be provided even if RTP and RTCP multiplexing is negotiated.",
      "ja": "「src_addrを」と「dest_addrは」パラメータoを1つのまたは2のいずれかのアドレス指定を含まなければなりません。 2つのアドレスの仕様は、RTPとRTCPの多重化がネゴシエートされた場合でも提供されてもよいことに注意してください。"
    },
    {
      "indent": 3,
      "text": "o Each address specification for RTP/AVP/UDP or RTP/AVP/TCP MUST contain either:",
      "ja": "O RTP / AVP / UDPまたはRTP / AVP / TCPのための各アドレスの指定は、どちらかが含まれなければなりません："
    },
    {
      "indent": 6,
      "text": "* both an address and a port number, or",
      "ja": "*アドレスとポート番号、またはその両方"
    },
    {
      "indent": 6,
      "text": "* a port number without an address.",
      "ja": "*アドレスなしのポート番号。"
    },
    {
      "indent": 3,
      "text": "o The first address specification given in either of the parameters applies to the RTP stream. The second specification, if present, applies to the RTCP stream, unless in the case RTP and RTCP multiplexing is negotiated where both RTP and RTCP will use the first specification.",
      "ja": "Oのパラメータのいずれかで与えられた最初のアドレス指定は、RTPストリームに適用されます。ケースのRTPとRTCPの多重化にどこRTPとRTCPの両方が最初の仕様を使用するネゴシエートされていない限り、第2の仕様は、存在する場合、RTCPストリームに適用されます。"
    },
    {
      "indent": 3,
      "text": "o The RTP/UDP packets from the server to the client MUST be sent to the address and port given by the first address specification of the \"dest_addr\" parameter.",
      "ja": "サーバーからクライアントへのRTP / UDPパケットO「dest_addrは」パラメータの最初のアドレス指定によって指定されたアドレスとポートに送らなければなりません。"
    },
    {
      "indent": 3,
      "text": "o The RTCP/UDP packets from the server to the client MUST be sent to the address and port given by the second address specification of the \"dest_addr\" parameter, unless RTP and RTCP multiplexing has been negotiated, in which case RTCP MUST be sent to the first address specification. If no second pair is specified and RTP and RTCP multiplexing has not been negotiated, RTCP MUST NOT be sent.",
      "ja": "RTPとRTCPの多重化がネゴシエートされていない限りoをサーバからクライアントへRTCP / UDPパケットは、RTCPをに送信しなければならない場合には、「dest_addrは」パラメータの第2のアドレス指定によって指定されたアドレスとポートに送信されなければなりません最初のアドレスの指定。何の第二の対が指定されていないとRTPとRTCPの多重化がネゴシエートされていない場合は、RTCPを送ってはいけません。"
    },
    {
      "indent": 3,
      "text": "o The RTCP/UDP packets from the client to the server MUST be sent to the address and port given by the second address specification of the \"src_addr\" parameter, unless RTP and RTCP multiplexing has been negotiated, in which case RTCP MUST be sent to the first address specification. If no second pair is specified and RTP and RTCP multiplexing has not been negotiated, RTCP MUST NOT be sent.",
      "ja": "RTPとRTCPの多重化がネゴシエートされていない限り、クライアントからサーバへのRTCP / UDPパケットO「src_addrを」パラメータの第2のアドレス指定によって指定されたアドレスとポートに送信する必要があり、その場合、RTCPはに送信されなければなりません最初のアドレスの指定。何の第二の対が指定されていないとRTPとRTCPの多重化がネゴシエートされていない場合は、RTCPを送ってはいけません。"
    },
    {
      "indent": 3,
      "text": "o The RTP/UDP packets from the client to the server MUST be sent to the address and port given by the first address specification of the \"src_addr\" parameter.",
      "ja": "OクライアントからサーバーへのRTP / UDPパケットは「src_addrを」パラメータの最初のアドレス指定によって指定されたアドレスとポートに送らなければなりません。"
    },
    {
      "indent": 3,
      "text": "o RTP and RTCP packets SHOULD be sent from the corresponding receiver port, i.e., RTCP packets from the server should be sent from the \"src_addr\" parameters second address port pair, unless RTP and RTCP multiplexing has been negotiated in which case the first address port pair is used.",
      "ja": "O RTPとRTCPパケット、すなわち、対応する受信ポートから送信される必要があり、RTPとRTCPの多重化は、その場合、第1のアドレスポートで交渉されていない場合、サーバからのRTCPパケットは、「src_addrを」パラメータ第2アドレスポート対から送信されるべきですペアが使用されています。"
    },
    {
      "indent": 0,
      "text": "C.1.3. AVPF/UDP",
      "ja": "C.1.3。 AVPF / UDP"
    },
    {
      "indent": 3,
      "text": "The RTP profile \"Extended RTP Profile for RTCP-based Feedback (RTP/ AVPF)\" [RFC4585] MAY be used as RTP profiles in sessions using RTP. All that is defined for AVP MUST also apply for AVPF.",
      "ja": "RTPプロファイル「RTCPベースのフィードバック（RTP / AVPF）の拡張RTPプロファイル」[RFC4585]はRTPを使用して、セッション内のRTPプロファイルとして使用することができます。 AVPのために定義されているすべてのもAVPFを申請しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The usage of AVPF is indicated by the media initialization protocol used. In the case of SDP, it is indicated by media lines (\"m=\") containing the profile RTP/AVPF. That SDP MAY also contain further AVPF-related SDP attributes configuring the AVPF session regarding reporting interval and feedback messages to be used [RFC4585]. This configuration MUST be followed.",
      "ja": "AVPFの使用は、使用されるメディア初期化プロトコルで示されています。 SDPの場合には、（「M =」）を含むプロファイルRTP / AVPFメディア線で示されています。 SDPは、さらにAVPF関連SDPを使用するレポート間隔とフィードバックメッセージに関して[RFC4585]をAVPFセッションを設定する属性をも含むことができること。この構成に従わなければなりません。"
    },
    {
      "indent": 0,
      "text": "C.1.4. SAVP/UDP",
      "ja": "C.1.4。 SAVP / UDP"
    },
    {
      "indent": 3,
      "text": "The RTP profile \"The Secure Real-time Transport Protocol (SRTP)\" [RFC3711] is an RTP profile (SAVP) that MAY be used in RTSP sessions using RTP. All that is defined for AVP MUST also apply for SAVP.",
      "ja": "RTPプロファイル「セキュアリアルタイム転送プロトコル（SRTP）」[RFC3711]はRTPを使用してRTSPセッションで使用されるかもしれRTPプロファイル（SAVP）です。 AVPのために定義されているすべてのもSAVPを申請しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The usage of SRTP requires that a security context be established. The default key-management unless otherwise signaled SHALL be MIKEY in RSA-R mode as defined in Appendix C.1.4.1 and not according to the procedure defined in \"Key Management Extensions for Session Description Protocol (SDP) and Real Time Streaming Protocol (RTSP)\" [RFC4567]. The reason is that RFC 4567 sends the initial MIKEY message in SDP, thus, both requiring the usage of the DESCRIBE method and forcing the server to keep state for clients performing DESCRIBE in anticipation that they might require key management.",
      "ja": "SRTPの使用は、セキュリティコンテキストが確立されている必要があります。セッション記述プロトコル（SDP）とリアルタイムストリーミングプロトコルのためのキー管理の拡張機能」で定義された手順に従って、付録C.1.4.1で定義されていないとして、それ以外の合図をしない限り、デフォルトのキー管理は、（RSA-RモードでMIKEYでなければなりませんRTSP）」[RFC4567]。その理由は、RFC 4567の両方がDESCRIBEメソッドの使用を必要とし、彼らはキー管理を必要とするかもしれないことを見越してDESCRIBEを行うクライアントの状態を維持するために、サーバーを強制的に、このように、SDPに初期マイキーメッセージを送ることです。"
    },
    {
      "indent": 3,
      "text": "MIKEY is selected as the default method for establishing SRTP cryptographic context within an RTSP session as it can be embedded in the RTSP messages while still ensuring confidentiality of content of the keying material, even when using hop-by-hop TLS security for the RTSP messages. This method also supports pipelining of the RTSP messages.",
      "ja": "MIKEYは、RTSPメッセージにホップバイホップTLSセキュリティを使用した場合でも、依然として鍵材料の内容の機密性を確保しつつ、それがRTSPメッセージに埋め込むことができるようにRTSPセッション内SRTP暗号コンテキストを確立するためのデフォルト方法として選択され。また、このメソッドは、RTSPメッセージのパイプライン化をサポートしています。"
    },
    {
      "indent": 0,
      "text": "C.1.4.1. MIKEY Key Establishment",
      "ja": "C.1.4.1。 MIKEY鍵確立"
    },
    {
      "indent": 3,
      "text": "This method for using MIKEY [RFC3830] to establish the SRTP cryptographic context is initiated in the client's SETUP request, and the server's response to the SETUP carries the MIKEY response. This ensures that the crypto context establishment happens simultaneously with the establishment of the media stream being protected. By using MIKEY's RSA-R mode [RFC4738] the client can be the initiator and still allow the server to set the parameters in accordance with the actual media stream.",
      "ja": "SRTP暗号コンテキストを確立するために、MIKEY [RFC3830]を使用するこの方法は、クライアントのSETUP要求で開始され、SETUPに対するサーバの応答はMIKEY応答を運びます。これは、暗号コンテキストの確立が保護されたメディア・ストリームの設立と同時に起こることを保証します。 MIKEYのRSA-Rモード[RFC4738]を使用して、クライアントが開始することと、まだサーバが実際のメディア・ストリームに応じてパラメータを設定することを可能にします。"
    },
    {
      "indent": 3,
      "text": "The SRTP cryptographic context establishment is done according to the following process:",
      "ja": "SRTP暗号コンテキストの確立は、以下の方法に従って行われます。"
    },
    {
      "indent": 3,
      "text": "1. The client determines that SAVP or SAVPF shall be used from the media-description format, e.g., SDP. If no other key-management method is explicitly signaled, then MIKEY SHALL be used as defined herein. The use of SRTP with RTSP is only defined with MIKEY with keys established as defined in this section. Future documents may define how an RTSP implementation treats SDP that indicates some other key mechanism to be used. The need for such specification includes [RFC4567], which is not defined for use in RTSP 2.0 within this document.",
      "ja": "1.クライアントは、SAVP又はSAVPFはメディア記述形式、例えば、SDPから使用されなければならないことを決定します。他のキー管理方法を明示的にシグナリングされていない場合、本明細書に定義されるように、その後、MIKEYを使用しなければなりません。 RTSPとSRTPの使用のみ、このセクションで定義されるように確立されたキーでMIKEYで定義されています。将来の文書は、他のいくつかの重要なメカニズムを示しRTSP実装の扱いSDPを使用する方法を定義することができます。そのような仕様の必要性は、この文書内のRTSP 2.0での使用のために定義されていない[RFC4567]を含みます。"
    },
    {
      "indent": 3,
      "text": "2. The client SHALL establish a TLS connection for RTSP messages, directly or hop-by-hop with the server. If hop-by-hop TLS security is used, the User method SHALL be indicated in the Accept-Credentials header. Note that using hop-by-hop does allow the proxy to insert itself as a man in the middle. This can also occur in the MIKEY exchange by the proxy providing one of its certificates rather than the server's in the Connection-Credentials header. Therefore, the client SHALL validate the server certificate.",
      "ja": "2.クライアントが直接、RTSPメッセージのTLS接続を確立するか、ホップバイホップサーバーでないものとします。ホップバイホップTLSセキュリティが使用される場合、ユーザ方法が受け入れ-資格ヘッダーに表示しなければなりません。ホップバイホップを使用すると、プロキシが途中で男として自分自身を挿入することができないことに注意してください。また、これは、その証明書のいずれかではなく、接続-資格のヘッダ内のサーバーの提供をプロキシによってMIKEY交換で発生する可能性があります。そのため、クライアントはサーバ証明書を検証するものとします。"
    },
    {
      "indent": 3,
      "text": "3. The client retrieves the server's certificate from a direct TLS connection or hop-by-hop from a Connection-Credentials header. The client then checks that the server certificate is valid and belongs to the server.",
      "ja": "3.クライアントは、直接TLS接続またはホップバイホップヘッダ接続-資格からのサーバの証明書を取得します。次に、クライアントは、サーバー証明書が有効であることを確認し、サーバーに属しています。"
    },
    {
      "indent": 3,
      "text": "4. The client forms the MIKEY Initiator message using RSA-R mode in unicast mode as specified in [RFC4738]. The client SHOULD use the same certificate for TLS and MIKEY to enable the server to bind the two together. The client's certificate SHALL be included in the MIKEY message. The client SHALL indicate its SRTP capabilities in the message.",
      "ja": "[RFC4738]で指定されるように前記クライアントは、ユニキャストモードでRSA-Rモードを使用MIKEYイニシエータメッセージを形成します。クライアントは、2つをバインドするためにサーバーを有効にするには、TLSやMIKEYのための同じ証明書を使用すべきです。クライアントの証明書は、マイキーメッセージに含めなければなりません。クライアントは、メッセージ内のSRTP能力を示さなければなりません。"
    },
    {
      "indent": 3,
      "text": "5. The MIKEY message from the previous step is base64-encoded [RFC4648] and becomes the value of the MIKEY parameter that is included in the transport specification(s) that specifies an SRTP-based profile (SAVP, SAVPF) in the SETUP request.",
      "ja": "5.前のステップからMIKEYメッセージは、base64エンコード[RFC4648]であり、SETUP要求にSRTPベースプロファイル（SAVP、SAVPF）を指定するトランスポート仕様（S）に含まれているMIKEYパラメータの値になります。"
    },
    {
      "indent": 3,
      "text": "6. Any proxy encountering the MIKEY parameter SHALL forward it without modification. A proxy that is required to understand the Transport specifications will need to understand SAVP/SAVPF with MIKEY to enable the default keying for SRTP-protected media streams. If such a proxy does not support SAVP/SAVPF with MIKEY, it will discard the whole transport specification. Most types of proxies can easily support SAVP and SAVPF with MIKEY. If a client encounters a proxy not supporting SAVP/SAVPF with MIKEY, the client should attempt bypassing that proxy.",
      "ja": "6. MIKEYパラメータに遭遇した任意のプロキシは変更せずに、それを送付します。トランスポート仕様を理解するために必要とされるプロキシはSRTPで保護されたメディアストリームのためのキーイングデフォルトを有効にするには、MIKEYでSAVP / SAVPFを理解する必要があります。そのようなプロキシがMIKEYでSAVP / SAVPFをサポートしていない場合、それは全体のトランスポート仕様を破棄します。プロキシのほとんどのタイプは、簡単にMIKEYでSAVPとSAVPFをサポートすることができます。クライアントはMIKEYとSAVP / SAVPFをサポートしていないプロキシに遭遇した場合、クライアントはそのプロキシを迂回しようとしなければなりません。"
    },
    {
      "indent": 3,
      "text": "7. The server, upon receiving the SETUP request, will need to decide upon the transport specification to use, if multiple are included by the client. In the determination of which transport specifications are supported and preferred, the server SHOULD decode the MIKEY message to take the embedded SRTP parameters into account. If all transport spec require SRTP but no MIKEY parameter or other supported keying method is included, the server SHALL respond with 403 (Forbidden).",
      "ja": "7.サーバは、SETUP要求を受信すると、複数のクライアントが含まれている場合は、使用するトランスポート仕様に決定する必要があります。トランスポート仕様がサポートされ、好適であるかの決定において、サーバは、アカウントに埋め込まSRTPパラメータを取るMIKEYメッセージを復号するべきです。すべてのトランスポートは、SRTPが、無MIKEYパラメータを必要とする仕様やその他のサポートキーイングメソッドが含まれている場合、サーバは403（禁止）に応答しなければなりません。"
    },
    {
      "indent": 3,
      "text": "8. Upon generating a response, the following outcomes can occur:",
      "section_title": true,
      "ja": "応答を生成すると8.、以下の結果が発生する可能性があります。"
    },
    {
      "indent": 8,
      "text": "*  A transport spec not using SRTP and MIKEY is selected.  Thus,\n   the response will not contain any MIKEY parameters.",
      "raw": true
    },
    {
      "indent": 8,
      "text": "* A transport spec using SRTP and MIKEY is selected but an error is encountered in the MIKEY processing. In this case, an RTSP error response code of 466 (Key Management Error) SHALL be used. A MIKEY message describing the error MAY be included.",
      "ja": "* SRTPとMIKEYを使用して、トランスポート仕様が選択されるが、エラーはMIKEY処理において遭遇します。この場合には、466のRTSPのエラー応答コード（キー管理エラー）を使用しなければなりません。エラーを説明MIKEYメッセージが含まれていてもよいです。"
    },
    {
      "indent": 8,
      "text": "* A transport spec using SRTP and MIKEY is selected and a MIKEY response message can be created. The server SHOULD use the same certificate for TLS and in MIKEY to enable the client to bind the two together. If a different certificate is used, it SHALL be included in the MIKEY message. It is RECOMMENDED that the envelope key-cache type be set to 'Cache' and that a single envelope key is reused for all MIKEY messages to the client. That message is included in the MIKEY parameter part of the single selected transport specification in the SETUP response. The server will set the SRTP parameters as preferred for this media stream within the supported range by the client.",
      "ja": "* SRTPとMIKEYを使用して、トランスポート仕様が選択され、MIKEY応答メッセージを作成することができます。サーバがTLSに同じ証明書を使用する必要があり、MIKEYで一緒に2をバインドするために、クライアントを有効にします。別の証明書が使用されている場合は、マイキーメッセージに含めなければなりません。封筒、キー・キャッシュタイプが「キャッシュ」にして、単一のエンベロープキーはクライアントへのすべてのMIKEYメッセージのために再利用されていることを設定することをお勧めします。そのメッセージは、SETUP応答の単一選択されたトランスポート仕様のMIKEYパラメータ一部に含まれています。クライアントによってサポートされる範囲内で、このメディアストリームのために好ましいとサーバーは、SRTPパラメータを設定します。"
    },
    {
      "indent": 3,
      "text": "9. The server transmits the SETUP response back to the client.",
      "section_title": true,
      "ja": "9.サーバーは、クライアントにSETUP応答を送信します。"
    },
    {
      "indent": 3,
      "text": "10. The client receives the SETUP response and, if the response code indicates a successful request, it decodes the MIKEY message and establishes the SRTP cryptographic context from the parameters in the MIKEY response.",
      "ja": "10.クライアントは、SETUP応答を受信し、応答コードが成功した要求を示す場合、それはMIKEYメッセージを復号し、MIKEY応答のパラメータからSRTP暗号コンテキストを確立します。"
    },
    {
      "indent": 3,
      "text": "In the above method, the client's certificate may be self signed in cases where the client's identity is not necessary to authenticate and the security goal is only to ensure that the RTSP signaling client is the same as the one receiving the SRTP security context.",
      "ja": "上記の方法では、クライアントの証明書は、クライアントのアイデンティティが認証する必要がなく、セキュリティの目標は、唯一のRTSPシグナリングクライアントがSRTPのセキュリティコンテキストを受けたものと同じであることを確実にするためである場合には自己署名かもしれません。"
    },
    {
      "indent": 0,
      "text": "C.1.5. SAVPF/UDP",
      "ja": "C.1.5。 SAVPF / UDP"
    },
    {
      "indent": 3,
      "text": "The RTP profile \"Extended Secure RTP Profile for Real-time Transport Control Protocol (RTCP)-Based Feedback (RTP/SAVPF)\" [RFC5124] is an RTP profile (SAVPF) that MAY be used in RTSP sessions using RTP. All that is defined for AVPF MUST also apply for SAVPF.",
      "ja": "[RFC5124]「リアルタイムトランスポート制御プロトコル（RTCP）ベースのフィードバック（RTP / SAVPF）にSecure RTPプロファイルを拡張」RTPプロファイルは、RTPを使用してRTSPセッションで使用されるかもしれRTPプロファイル（SAVPF）です。 AVPFのために定義されているすべてのもSAVPFを申請しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The usage of SRTP requires that a cryptographic context be established. The default mechanism for establishing that security association is to use MIKEY[RFC3830] with RTSP as defined in Appendix C.1.4.1.",
      "ja": "SRTPの使用は、暗号コンテキストが確立されている必要があります。そのセキュリティ・アソシエーションを確立するためのデフォルトのメカニズムは、付録C.1.4.1で定義されているRTSPとMIKEY [RFC3830]を使用することです。"
    },
    {
      "indent": 0,
      "text": "C.1.6. RTCP Usage with RTSP",
      "ja": "C.1.6。 RTSPとRTCPの使用方法"
    },
    {
      "indent": 3,
      "text": "RTCP has several usages when RTP is implemented for media transport as explained below. Thus, RTCP MUST be supported if an RTSP agent handles RTP.",
      "ja": "RTCPは、以下に説明するようにRTPは、メディア転送のために実装されているいくつかの用途があります。 RTSPエージェントはRTPを処理する場合したがって、RTCPをサポートしなければなりません。"
    },
    {
      "indent": 0,
      "text": "C.1.6.1. Media Synchronization",
      "ja": "C.1.6.1。メディア同期"
    },
    {
      "indent": 3,
      "text": "RTCP provides media synchronization and clock-drift compensation. The initial media synchronization is available from RTP-Info header. However, to be able to handle any clock drift between the media streams, RTCP is needed.",
      "ja": "RTCPは、メディア同期とクロックドリフト補償を提供します。最初のメディア同期は、RTP-Infoヘッダーから入手可能です。しかし、メディアストリーム間のいずれかのクロックドリフトを扱うことができるように、RTCPが必要とされています。"
    },
    {
      "indent": 0,
      "text": "C.1.6.2. RTSP Session Keep-Alive",
      "ja": "C.1.6.2。 RTSPセッションは、キープアライブ"
    },
    {
      "indent": 3,
      "text": "RTCP traffic from the RTSP client to the RTSP server MUST function as keep-alive. This requires an RTSP server supporting RTP to use the received RTCP packets as indications that the client desires the related RTSP session to be kept alive.",
      "ja": "RTSPサーバMUST機能へのRTSPクライアントからのRTCPトラフィックキープアライブとして。これは、RTPは、クライアントが関連するRTSPセッションが生かされることを望む適応症として受信RTCPパケットを使用するようにサポートするRTSPサーバが必要です。"
    },
    {
      "indent": 0,
      "text": "C.1.6.3. Bitrate Adaption",
      "ja": "C.1.6.3。ビットレート適応"
    },
    {
      "indent": 3,
      "text": "RTCP Receiver reports and any additional feedback from the client MUST be used to adapt the bitrate used over the transport for all cases when RTP is sent over UDP. An RTP sender without reserved resources MUST NOT use more than its fair share of the available resources. This can be determined by comparing on short-to-medium terms (some seconds) the used bitrate and adapting it so that the RTP sender sends at a bitrate comparable to what a TCP sender would achieve on average over the same path.",
      "ja": "RTCPレシーバレポートやクライアントからの追加のフィードバックはRTPはUDP経由で送信されるすべてのケースのためのトランスポート上で使用するビットレートを適応させるために使用しなければなりません。予約されたリソースのないRTPの送信者は、利用可能な資源の公正なシェアよりも多くを使用してはなりません。これは、短期・ツー・中期的（数秒）で使用されるビットレートを比較し、RTPの送信者がTCPの送信者が同一の経路を介して平均的に達成するであろうものに匹敵するビットレートで送信するように適合させることによって決定することができます。"
    },
    {
      "indent": 3,
      "text": "To ensure that the implementation's adaptation mechanism has a well-defined outer envelope, all implementations using a non-congestion-controlled unicast transport protocol, like UDP, MUST implement \"Multimedia Congestion Control: Circuit Breakers for Unicast RTP Sessions\" [RTP-CIRCUIT-BREAKERS].",
      "ja": "実装の適応メカニズムが明確に定義された外側エンベロープを持っていることを保証するために、非輻輳制御ユニキャストトランスポートプロトコルを使用してすべての実装は、UDPのように、「マルチメディアの輻輳制御を：ユニキャストRTPセッションのためのサーキットブレーカー」を実施しなければならない[RTP-回路 - BREAKERS]。"
    },
    {
      "indent": 0,
      "text": "C.1.6.4. RTP and RTCP Multiplexing",
      "ja": "C.1.6.4。 RTPとRTCPの多重化"
    },
    {
      "indent": 3,
      "text": "RTSP can be used to negotiate the usage of RTP and RTCP multiplexing as described in [RFC5761]. This allows servers and client to reduce the amount of resources required for the session by only requiring one underlying transport stream per media stream instead of two when using RTP and RTCP. This lessens the server-port consumption and also the necessary state and keep-alive work when operating across NATs [RFC2663].",
      "ja": "RTSPは、[RFC5761]に記載されるようにRTPとRTCPの多重化の使用を交渉するために使用することができます。これは、サーバーとクライアントは、RTPとRTCPを使用している場合のみ、メディアストリームの代わりに2あたり1つの基本となるトランスポートストリームを要求することで、セッションに必要なリソースの量を減らすことができます。これは、サーバーのポートの消費量とも必要な状態を軽減し、キープアライブの仕事をNATを越えて[RFC2663]を操作するとき。"
    },
    {
      "indent": 3,
      "text": "Content must be prepared with some consideration for RTP and RTCP multiplexing, mainly ensuring that the RTP payload types used do not collide with the ones used for RTCP packet types. This option likely needs explicit support from the content unless the RTP payload types can be remapped by the server and that is correctly reflected in the session description. Beyond that, support of this feature should come at little cost and much gain.",
      "ja": "コンテンツは、主に使用されたRTPペイロードタイプは、RTCPパケットタイプのために使用されるものと衝突しないことを保証し、RTPとRTCPの多重化のために、いくつか考慮して準備する必要があります。 RTPペイロードタイプがサーバーによって再マッピングすることができ、それが正しくセッション記述に反映されていない限り、このオプションは、可能性の高いコンテンツから明示的なサポートを必要とします。それ以上に、この機能のサポートはほとんどコストと多くのゲインで来る必要があります。"
    },
    {
      "indent": 3,
      "text": "It is recommended that, if the content and server support RTP and RTCP multiplexing, this is indicated in the session description, for example, using the SDP attribute \"a=rtcp-mux\". If the SDP message contains the \"a=rtcp-mux\" attribute for a media stream, the server MUST support RTP and RTCP multiplexing. If indicated or otherwise desired by the client, it can include the Transport parameter \"RTCP-mux\" in any transport specification where it desires to use \"RTCP-mux\". The server will indicate if it supports \"RTCP-mux\". Servers and Clients SHOULD support RTP and RTCP multiplexing.",
      "ja": "コンテンツとサーバ支持RTPとRTCPの多重化と、これはSDP属性「= RTCP-MUX」を用いて、例えば、セッション記述に示されている、ことをお勧めします。 SDPメッセージは、メディアストリームのための「A = RTCP-MUX」属性が含まれている場合、サーバーはRTPとRTCPの多重化をサポートしなければなりません。示されたまたはそうでなければ、クライアントが所望される場合、それは「RTCP-MUX」を使用することを望む任意のトランスポート仕様のトランスポートパラメータ「RTCP-MUX」を含むことができます。それは、「RTCP-MUX」をサポートしている場合、サーバーが示されます。サーバーとクライアントは、RTPとRTCPの多重化をサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "For capability exchange, an RTSP feature tag for RTP and RTCP multiplexing is defined: \"setup.rtp.rtcp.mux\".",
      "ja": "能力交換のために、RTPとRTCPの多重化のためのRTSPの機能タグが定義されています：「setup.rtp.rtcp.mux」。"
    },
    {
      "indent": 3,
      "text": "To minimize the risk of negotiation failure while using RTP and RTCP multiplexing, some recommendations are here provided. If the session description includes explicit indication of support (\"a=rtcp-mux\" in SDP), then an RTSP agent can safely create a SETUP request with a transport specification with only a single \"dest_addr\" parameter address specification. If no such explicit indication is provided, then even if the feature tag \"setup.rtp.rtcp.mux\" is provided in a Supported header by the RTSP server or the feature tag included in the Required header in the SETUP request, the media resource may not support RTP and RTCP multiplexing. Thus, to maximize the probability of successful negotiation, the RTSP agent is recommended to include two \"dest_addr\" parameter address specifications in the first or first set (if pipelining is used) of SETUP request(s) for any media resource aggregate. That way, the RTSP server can accept RTP and RTCP multiplexing and only use the first address specification or, if not, use both specifications. The RTSP agent, after having received the response for a successful negotiation of the usage of RTP and RTCP multiplexing, can then release the resources associated with the second address specification.",
      "ja": "RTPとRTCPの多重化を使用しながら、交渉の失敗のリスクを最小限に抑えるために、いくつかの推奨事項がここで提供されています。セッション記述は、支持体の明示的な指示（SDPの「A = RTCP-MUX」）を含む場合、次いで、RTSPエージェントは安全にのみ単一の「dest_addrは」パラメータアドレス指定を有するトランスポート仕様のSETUP要求を作成することができます。そのような明示的な指示が提供されない場合、たとえ機能タグ「setup.rtp.rtcp.muxは」RTSPサーバまたはSETUPリクエストで必要ヘッダに含まれる特徴タグ、メディアリソースによってサポートされているヘッダに設けられています。 RTPとRTCPの多重化をサポートしていないかもしれません。このように、成功した交渉の可能性を最大化するために、RTSPエージェントは、任意のメディアリソースの集約のためのSETUP要求（複数可）の最初のまたは最初のセット（パイプラインが使用されている場合）に2つの「dest_addrは」パラメータアドレス指定を含めることをお勧めします。その方法は、RTSPサーバは、RTPとRTCPの多重化を受け入れ、最初のアドレス指定を使用するか、そうでない場合は、両方の仕様を使用することができます。 RTSP剤は、RTPとRTCPの多重化の使用の成功交渉に対する応答を受信した後、第2のアドレス指定に関連付けられたリソースを解放することができます。"
    },
    {
      "indent": 0,
      "text": "C.2. RTP over TCP",
      "ja": "C.2。 TCP上のRTP"
    },
    {
      "indent": 3,
      "text": "Transport of RTP over TCP can be done in two ways: over independent TCP connections using [RFC4571] or interleaved in the RTSP connection. In both cases, the protocol MUST be \"rtp\" and the lower-layer MUST be TCP. The profile may be any of the above specified ones: AVP, AVPF, SAVP, or SAVPF.",
      "ja": "[RFC4571]を使用して独立したTCP接続を介して、またはRTSP接続でインターリーブ：TCP上のRTPの輸送は、2つの方法で行うことができます。両方の場合において、プロトコルは「RTP」と下位層はTCPでなければなりません。 AVP、AVPF、SAVP、又はSAVPF：プロファイルは、上記指定されたもののいずれであってもよいです。"
    },
    {
      "indent": 0,
      "text": "C.2.1. Interleaved RTP over TCP",
      "ja": "C.2.1。 TCP上のインターリーブRTP"
    },
    {
      "indent": 3,
      "text": "The use of embedded (interleaved) binary data transported on the RTSP connection is possible as specified in Section 14. When using this declared combination of interleaved binary data, the RTSP messages MUST be transported over TCP. TLS may or may not be used. If TLS is used, both RTSP messages and the binary data will be protected by TLS.",
      "ja": "インターリーブされたバイナリデータのこの宣言された組み合わせを使用する場合、セクション14で指定され、RTSPメッセージがTCPを介して転送されなければならないように埋め込まれた（インターリーブ）バイナリデータがRTSP接続上で搬送の使用が可能です。 TLSはよく、または使用することはできません。 TLSを使用する場合は、両方のRTSPメッセージとバイナリデータは、TLSで保護されます。"
    },
    {
      "indent": 3,
      "text": "One should, however, consider that this will result in all media streams going through any proxy. Using independent TCP connections can avoid that issue.",
      "ja": "一つは、しかし、これはどのプロキシを経由するすべてのメディアストリームにつながることを考慮すべきです。独立したTCPコネクションを使用すると、その問題を回避することができます。"
    },
    {
      "indent": 0,
      "text": "C.2.2. RTP over Independent TCP",
      "ja": "C.2.2。独立したTCPオーバーRTP"
    },
    {
      "indent": 3,
      "text": "In this section, the sending of RTP [RFC3550] over lower-layer transport TCP [RFC793] according to \"Framing Real-time Transport Protocol (RTP) and RTP Control Protocol (RTCP) Packets over Connection-Oriented Transport\" [RFC4571] is described. This section adapts the guidelines for using RTP over TCP within SIP/SDP [RFC4145] to work with RTSP.",
      "ja": "このセクションでは、[RFC4571]は、「コネクション指向トランスポートを介してリアルタイムトランスポートプロトコル（RTP）とRTP制御プロトコル（RTCP）パケットをフレーミング」に従って、[RFC793]下層輸送TCP上に[RFC3550] RTPの送信説明。このセクションでは、RTSPで動作するSIP / SDP [RFC4145]内のTCP上のRTPを使用するためのガイドラインを適応させます。"
    },
    {
      "indent": 3,
      "text": "A client codes the support of RTP over independent TCP by specifying an RTP/AVP/TCP transport option without an interleaved parameter in the Transport line of a SETUP request. This transport option MUST include the \"unicast\" parameter.",
      "ja": "クライアントコードSETUP要求の搬送ラインでのインターリーブパラメータなしでRTP / AVP / TCPトランスポート・オプションを指定することで、独立したTCPオーバーRTPのサポート。このトランスポート・オプションは、「ユニキャスト」パラメータを含める必要があります。"
    },
    {
      "indent": 3,
      "text": "If the client wishes to use RTP with RTCP, two address specifications need to be included in the \"dest_addr\" parameter. If the client wishes to use RTP without RTCP, one address specification is included in the \"dest_addr\" parameter. If the client wishes to multiplex RTP and RTCP on a single transport flow (see Appendix C.1.6.4), one or two address specifications are included in the \"dest_addr\" parameter in addition to the \"RTCP-mux\" transport parameter. Two address specifications are allowed to facilitate successful negotiation when the server or content can't support RTP and RTCP multiplexing. Ordering rules of dest_addr ports follow the rules for RTP/AVP/UDP.",
      "ja": "クライアントは、RTCPとRTPを使用したい場合は、2つのアドレスの仕様は「dest_addrは、」パラメータに含まれる必要があります。クライアントは、RTCPずにRTPを使用したい場合は、一つのアドレス指定は、「dest_addrは、」パラメータに含まれています。クライアントが（付録C.1.6.4を参照）単一のトランスポートフローにRTPとRTCPを多重化することを希望する場合は、1つのまたは2つのアドレスの仕様は、「RTCP-MUX」トランスポート・パラメータに加えて、「dest_addrは」パラメータに含まれています。サーバやコンテンツはRTPとRTCPの多重化をサポートすることができないときに、2つのアドレスの仕様は、成功した交渉を促進するために許可されています。 dest_addrは、ポートの注文規則は、RTP / AVP / UDPのための規則に従ってください。"
    },
    {
      "indent": 3,
      "text": "If the client wishes to play the active role in initiating the TCP connection, it MAY set the setup parameter (see Section 18.54) on the Transport line to be \"active\", or it MAY omit the setup parameter, as active is the default. If the client signals the active role, the ports in the address specifications in the \"dest_addr\" parameter MUST be set to 9 (the discard port).",
      "ja": "クライアントは、TCP接続を開始する際に積極的な役割を果たしているしたい場合は、「アクティブ」であることを搬送ライン上（項18.54を参照してください）セットアップパラメータを設定したり、アクティブがデフォルトであるとして、それは、セットアップパラメータを省略することができます。クライアントが積極的な役割を知らせる場合は、「dest_addrは」パラメータのアドレス指定のポートは、9（廃棄ポート）に設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the client wishes to play the passive role in TCP connection initiation, it MUST set the setup parameter on the Transport line to be \"passive\". If the client is able to assume the active or the passive role, it MUST set the setup parameter on the Transport line to be \"actpass\". In either case, the \"dest_addr\" parameter's address specification port value for RTP MUST be set to the TCP port number on which the client is expecting to receive the TCP connection for RTP, and the \"dest_addr\" address specification port value for RTCP MUST be set to the TCP port number on which the client is expecting to receive the TCP connection for RTCP. In the case that the client wishes to multiplex RTP and RTCP on a single transport flow, the \"RTCP-mux\" parameter is included and one or two \"dest_addr\" parameter address specifications are included, as mentioned earlier in this section.",
      "ja": "クライアントは、TCP接続の開始に受動的な役割を果たしているしたい場合は、「受動的」であることを搬送ライン上の設定パラメータを設定しなければなりません。クライアントがアクティブまたはパッシブな役割を引き受けることが可能であるならば、それは「actpass」であることを搬送ライン上の設定パラメータを設定しなければなりません。いずれの場合も、RTPのための「dest_addrは」パラメータのアドレス指定ポート値は、クライアントがRTPのためのTCPコネクションを受け取ることを期待されているTCPポート番号に設定しなければならなくて、RTCPのための「dest_addrは」アドレス指定ポート値でなければなりませんクライアントは、RTCPのためのTCPコネクションを受け取ることを期待されているTCPポート番号に設定します。クライアントは、単一のトランスポートフローにRTPとRTCPを多重化することを望む場合には、「RTCP-MUX」パラメータが含まれており、この項で前述したように一つまたは二つ「dest_addrは」パラメータアドレスの仕様が含まれています。"
    },
    {
      "indent": 3,
      "text": "Upon receipt of a non-interleaved RTP/AVP/TCP SETUP request, if a server decides to accept this requested option, the 2xx reply MUST contain a Transport option that specifies RTP/AVP/TCP (without using the interleaved parameter and using the unicast parameter). The \"dest_addr\" parameter value MUST be echoed from the parameter value in the client request unless the destination address (only port) was not provided; in which case, the server MAY include the source address of the RTSP TCP connection with the port number unchanged.",
      "ja": "非インターリーブRTP / AVP / TCPのSETUP要求を受信すると、サーバは、このオプションを要求し受け入れることを決定した場合、インターリーブされたパラメータを使用して、ユニキャストを使用せずに（RTP / AVP / TCPを指定するトランスポートオプションを含まなければならないの2xx応答パラメータ）。宛先アドレス（専用ポート）を設けなかった場合を除き、「dest_addrは」パラメータ値は、クライアント要求内のパラメータ値からエコーされなければなりません。その場合には、サーバはポート番号そのままでRTSP TCP接続の送信元アドレスを含むかもしれません。"
    },
    {
      "indent": 3,
      "text": "In addition, the server reply MUST set the setup parameter on the Transport line, to indicate the role the server will play in the connection setup. Permissible values are \"active\" (if a client set setup to \"passive\" or \"actpass\") and \"passive\" (if a client set setup to \"active\" or \"actpass\").",
      "ja": "また、サーバの応答は、サーバが接続設定で再生されます役割を示すために、搬送ライン上の設定パラメータを設定しなければなりません。 （クライアントが設定を「有効」または「actpass」に設定している場合）、「受動的」（クライアントはセットアップに「受動的」または「actpass」を設定している場合）許容値は「アクティブ」です。"
    },
    {
      "indent": 3,
      "text": "If a server sets setup to \"passive\", the \"src_addr\" in the reply MUST indicate the ports on which the server is willing to receive a TCP connection for RTP and (if the client requested a TCP connection for RTCP by specifying two \"dest_addr\" address specifications) a TCP/ RTCP connection. If a server sets setup to \"active\", the ports specified in \"src_addr\" address specifications MUST be set to 9. The server MAY use the \"ssrc\" parameter, following the guidance in Section 18.54. The server sets only one address specification in the case that the client has indicated only a single address specification or in case RTP and RTCP multiplexing was requested and accepted by the server. Port ordering for \"src_addr\" follows the rules for RTP/AVP/UDP.",
      "ja": "サーバが「パッシブ」、返信に「src_addrを」は、サーバは、クライアントが2を指定することにより、RTCPのためのTCPコネクションを要求された場合（RTPとのTCPコネクションを受け取るために喜んでされているポートを示してしなければならないように設定を設定した場合、「dest_addrは「アドレス指定）TCP / RTCP接続。サーバが「アクティブ」に設定を設定した場合、「src_addrを」に指定されたポートは、アドレスの仕様は、サーバは、セクション18.54のガイダンス以下、「SSRC」パラメータを使用するかもしれ9に設定しなければなりません。サーバは、クライアントが要求され、サーバーによって受け入れられた単一アドレス指定か、ケースのRTPとRTCPの多重化でを示した場合にのみ、一つのアドレス指定を設定します。 「src_addrを」用のポート順序は、RTP / AVP / UDPのための規則に従います。"
    },
    {
      "indent": 3,
      "text": "Servers MUST support taking the passive role and MAY support taking the active role. Servers with a public IP address take the passive role, thus enabling clients behind NATs and firewalls a better chance of successful connect to the server by actively connecting outwards. Therefore, the clients are RECOMMENDED to take the active role.",
      "ja": "サーバは受動的な役割を取ってサポートしなければならないと積極的な役割を取ってサポートしてもよい（MAY）。パブリックIPアドレスを持つサーバは、このようにNATの背後のクライアントを有効にする、受動的な役割を取り、積極的に外向きに接続することにより、サーバーへの接続に成功のよりよいチャンスをファイアウォール。したがって、クライアントが積極的な役割を取ることをお勧めします。"
    },
    {
      "indent": 3,
      "text": "After sending (receiving) a 2xx reply for a SETUP method for a non-interleaved RTP/AVP/TCP media stream, the active party SHOULD initiate the TCP connection as soon as possible. The client MUST NOT send a PLAY request prior to the establishment of all the TCP connections negotiated using SETUP for the session. In case the server receives a PLAY request in a session that has not yet established all the TCP connections, it MUST respond using the 464 (Data Transport Not Ready Yet) (Section 17.4.28) error code.",
      "ja": "非インタリーブRTP / AVP / TCPメディアストリームのセットアップ方法の2xx応答を送信（受信）した後、アクティブパーティできるだけ早くTCP接続を開始すべきです。クライアントは、セッションのセットアップを使用して交渉し、すべてのTCPコネクションの確立に先立ってPLAY要求を送ってはいけません。場合は、サーバーは、まだすべてのTCP接続を確立していないセッションでPLAY要求を受信し、それは464（データ転送ノットレディけれども）（セクション17.4.28）、エラーコードを使用して反応しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Once the PLAY request for a media resource transported over non-interleaved RTP/AVP/TCP occurs, media begins to flow from server to client over the RTP TCP connection, and RTCP packets flow bidirectionally over the RTCP TCP connection. Unless RTP and RTCP multiplexing has been negotiated; in which case, RTP and RTCP will flow over a common TCP connection. As in the RTP/UDP case, client-to-server traffic on an RTP-only TCP session is unspecified by this memo. The packets that travel on these connections MUST be framed using the protocol defined in [RFC4571], not by the framing defined for interleaving RTP over the RTSP connection defined in Section 14.",
      "ja": "非インターリーブRTP / AVP / TCPを介して伝送メディアリソースのためのPLAY要求が発生すると、メディアはRTP TCP接続を介してサーバからクライアントに流れ始めると、RTCPパケットは、RTCP TCP接続を介して双方向に流れること。 RTPとRTCPの多重化が交渉されていない限り、その場合には、RTPとRTCPは、一般的なTCP接続を介して流れます。 RTP / UDPの場合のように、RTPのみのTCPセッションでクライアントからサーバへのトラフィックは、このメモで指定されていません。これらの接続上を移動するパケットは、[RFC4571]でなく、節14に定義されたRTSP接続上でRTPをインタリーブするために定義されたフレーミングによって定義されたプロトコルを使用してフレーム化されなければなりません。"
    },
    {
      "indent": 3,
      "text": "A successful PAUSE request for media being transported over RTP/AVP/ TCP pauses the flow of packets over the connections, without closing the connections. A successful TEARDOWN request signals that the TCP connections for RTP and RTCP are to be closed by the RTSP client as soon as possible.",
      "ja": "RTP / AVP / TCP上で転送されているメディアのための成功PAUSE要求が接続を閉じることなく、接続上のパケットの流れを一時停止します。 RTPとRTCPのためのTCP接続はできるだけ早くRTSPクライアントによって閉じられるようにしている成功したTEARDOWN要求信号。"
    },
    {
      "indent": 3,
      "text": "Subsequent SETUP requests using a URI already set up in an RTSP session using an RTP/AVP/TCP transport specification may be ambiguous in the following way: does the client wish to open up a new TCP connection for RTP or RTCP for the URI, or does the client wish to continue using the existing TCP connections? The client SHOULD use the \"connection\" parameter (defined in Section 18.54) on the Transport line to make its intention clear (by setting \"connection\" to \"new\" if new connections are needed, and by setting \"connection\" to \"existing\" if the existing connections are to be used). After a 2xx reply for a SETUP request for a new connection, parties should close the preexisting connections, after waiting a suitable period for any stray RTP or RTCP packets to arrive.",
      "ja": "クライアントは、URIのためのRTPまたはRTCPのための新しいTCP接続を開きたい場合、または：URIを使用して、後続のSETUP要求は、すでに次のように曖昧かもしれRTP / AVP / TCPトランスポート仕様を使用してRTSPセッションで設定しますクライアントは、既存のTCP接続を使用し続けたいですか？クライアントは、新しい接続が必要な場合は、「新しい」に「接続」を設定することによって、（その意図を明確にし、「既存」に「接​​続」を設定することでする搬送ライン上で（セクション18.54で定義された）「接続」パラメータを使用する必要があります既存の接続が使用される場合）。新しい接続のためのSETUP要求のための2xx応答の後、当事者が到着するの浮遊RTPまたはRTCPパケットのために適切な期間を待った後、既存の接続を閉じる必要があります。"
    },
    {
      "indent": 3,
      "text": "The usage of SRTP, i.e., either SAVP or SAVPF profiles, requires that a security association be established. The default mechanism for establishing that security association is to use MIKEY[RFC3830] with RTSP as defined Appendix C.1.4.1.",
      "ja": "SRTPの使用、すなわち、いずれかSAVPまたはSAVPFプロファイルは、セキュリティアソシエーションが確立されることを要求します。そのセキュリティアソシエーションを確立するためのデフォルトのメカニズムが定義され、付録C.1.4.1としてRTSPでMIKEY [RFC3830]を使用することです。"
    },
    {
      "indent": 3,
      "text": "Below, a rewritten version of the example \"Media on Demand\" (Appendix A.1) shows the use of RTP/AVP/TCP non-interleaved:",
      "ja": "以下は、例の書き換えバージョン「メディアオンデマンド」（付録A.1）RTP / AVP / TCP非インタリーブの使用を示しています。"
    },
    {
      "indent": 6,
      "text": "C->M: DESCRIBE rtsp://example.com/twister.3gp RTSP/2.0 CSeq: 1 User-Agent: PhonyClient/1.2",
      "ja": "C-> M：RTSPの記述：1つのUser-Agent：PhonyClient / 1.2 RTSP / 2.0のCSeq //example.com/twister.3gp"
    },
    {
      "indent": 6,
      "text": "M->C: RTSP/2.0 200 OK CSeq: 1 Server: PhonyServer/1.0 Date: Wed, 23 Jan 2013 15:36:52 +0000 Content-Type: application/sdp Content-Length: 227 Content-Base: rtsp://example.com/twister.3gp/ Expires: Thu, 24 Jan 2013 15:36:52 +0000",
      "ja": "M-> C：RTSP / 2.0 200 OKのCSeq：1つのサーバ：PhonyServer / 1.0日付：水曜日、2013年1月23日午後03時36分52秒0000のContent-Type：アプリケーション/ SDPコンテンツの長さ：227コンテンツベース：RTSP： //example.com/twister.3gp/有効期限：木、2013年1月24日午後3時36分52秒0000"
    },
    {
      "indent": 12,
      "text": "v=0\no=- 2890844256 2890842807 IN IP4 198.51.100.34\ns=RTSP Session\ni=An Example of RTSP Session Usage\ne=adm@example.com\nc=IN IP4 0.0.0.0\na=control: *\na=range:npt=00:00:00-00:10:34.10\nt=0 0\nm=audio 0 RTP/AVP 0\na=control: trackID=1",
      "raw": true
    },
    {
      "indent": 6,
      "text": "C->M: SETUP rtsp://example.com/twister.3gp/trackID=1 RTSP/2.0 CSeq: 2 User-Agent: PhonyClient/1.2 Require: play.basic Transport: RTP/AVP/TCP;unicast;dest_addr=\":9\"/\":9\"; setup=active;connection=new Accept-Ranges: npt, smpte, clock",
      "ja": "C-> M：SETUPのRTSP：//example.com/twister.3gp/trackID=1 RTSP / 2.0のCSeq：2のUser-Agent：PhonyClient / 1.2が必要：play.basicトランスポート：RTP / AVP / TCP、ユニキャスト、dest_addrは= \"9\" / \"9\";セットアップ=アクティブ;接続=新しいのAccept-範囲：NPT、SMPTE、クロック"
    },
    {
      "indent": 6,
      "text": "M->C: RTSP/2.0 200 OK\n      CSeq: 2\n      Server: PhonyServer/1.0\n      Transport: RTP/AVP/TCP;unicast;\n                 dest_addr=\":9\"/\":9\";\n                 src_addr=\"198.51.100.5:53478\"/\"198.51.100:54091\";\n                 setup=passive;connection=new;ssrc=93CB001E\n      Session: OccldOFFq23KwjYpAnBbUr\n      Expires: Thu, 24 Jan 2013 15:36:52 +0000\n      Date: Wed, 23 Jan 2013 15:36:52 +0000\n      Accept-Ranges: npt\n      Media-Properties: Random-Access=0.8, Immutable, Unlimited",
      "raw": true
    },
    {
      "indent": 6,
      "text": "C->M: TCP Connection Establishment x2",
      "ja": "C-> M：TCPコネクションの確立×2"
    },
    {
      "indent": 6,
      "text": "C->M: PLAY rtsp://example.com/twister.3gp/ RTSP/2.0 CSeq: 4 User-Agent: PhonyClient/1.2 Range: npt=30- Session: OccldOFFq23KwjYpAnBbUr",
      "ja": "C-> M：PLAYのRTSP：4のUser-Agent：PhonyClient / 1.2範囲：NPT = 30-セッション：RTSP / 2.0のCSeq //example.com/twister.3gp/ OccldOFFq23KwjYpAnBbUr"
    },
    {
      "indent": 6,
      "text": "M->C: RTSP/2.0 200 OK CSeq: 4 Server: PhonyServer/1.0 Date: Wed, 23 Jan 2013 15:36:54 +0000 Session: OccldOFFq23KwjYpAnBbUr Range: npt=30-623.10 Seek-Style: First-Prior RTP-Info: url=\"rtsp://example.com/twister.3gp/trackID=1\" ssrc=4F312DD8:seq=54321;rtptime=2876889",
      "ja": "M-> C：RTSP / 2.0 200 OKのCSeq：4サーバー：PhonyServer / 1.0日付：水曜日、2013年1月23日15時36分54秒0000セッション：OccldOFFq23KwjYpAnBbUr範囲：NPT = 30から623.10シークスタイルを：まず、前のRTP -info：URL = \"RTSP：//example.com/twister.3gp/trackID=1\" SSRC = 4F312DD8：SEQ = 54321; rtptime = 2876889"
    },
    {
      "indent": 0,
      "text": "C.3. Handling Media-Clock Time Jumps in the RTP Media Layer",
      "ja": "C.3。メディアの取り扱い-時計の時間は、RTPメディアレイヤーにジャンプします"
    },
    {
      "indent": 3,
      "text": "RTSP allows media clients to control selected, non-contiguous sections of media presentations, rendering those streams with an RTP media layer [RFC3550]. Two cases occur, the first is when a new PLAY request replaces an old ongoing request and the new request results in a jump in the media. This should produce continuous media stream at the RTP layer. A client may also immediately follow a completed PLAY request with a new PLAY request. This will result in some gap in the media layer. The below text will look into both cases.",
      "ja": "RTSPは、RTPメディア層[RFC3550]とそれらのストリームをレンダリングする、メディア・クライアントは、メディアプレゼンテーションの選択された、非連続セクションを制御することを可能にします。二つのケースが発生し、最初は新しいPLAY要求がメディアでジャンプの古い継続的な要求と新しい要求の結果を置き換えるときです。これは、RTP層での連続メディアストリームを生成する必要があります。また、クライアントは、すぐに新しいPLAY要求に完成PLAY要求に従うことができます。これは、メディア層におけるいくつかのギャップになります。下のテキストは、両方のケースになります。"
    },
    {
      "indent": 3,
      "text": "A PLAY request that replaces an ongoing PLAY request allows the media layer rendering the RTP stream to do so continuously without being affected by jumps in media-clock time. The RTP timestamps for the new media range are set so that they become continuous with the previous media range in the previous request. The RTP sequence number for the first packet in the new range will be the next following the last packet in the previous range, i.e., monotonically increasing. The goal is to allow the media-rendering layer to work without interruption or reconfiguration across the jumps in media clock. This should be possible in all cases of replaced PLAY requests for media that has random access properties. In this case, care is needed to align frames or similar media-dependent structures.",
      "ja": "現在進行中のPLAY要求を置き換えるPLAY要求は、メディア・クロック時間にジャンプに影響されることなく、継続的にそうするようにRTPストリームをレンダリングするメディア層を可能にします。彼らは以前の要求の前のメディアの範囲で連続になるように、新しいメディアレンジのためのRTPタイムスタンプが設定されています。新しい範囲内の最初のパケットのRTPシーケンス番号が前の範囲内の最後のパケットの次になり、すなわち、単調に増加します。目標は、メディア・レンダリング層がメディアクロックにジャンプ渡って中断または再設定なしで動作できるようにすることです。これは、ランダムアクセス性を有しているメディアの置き換えPLAY要求のすべての場合には可能なはずです。この場合には、注意がフレームまたは類似のメディア依存構造を整列させるために必要とされます。"
    },
    {
      "indent": 3,
      "text": "In cases where jumps in media-clock time are a result of RTSP signaling operations arriving after a completed PLAY operation, the request timing will result in that media becoming non-continuous. The server becomes unable to send the media so that it arrives timely and still carries timestamps to make the media stream continuous. In these situations, the server will produce RTP streams where there are gaps in the RTP timeline for the media. If the media has frame structure, aligning the timestamp for the next frame with the previous structure reduces the burden to render this media. The gap should represent the time the server hasn't been serving media, e.g., the time between the end of the media stream or a PAUSE request and the new PLAY request. In these cases, the RTP sequence number would normally be monotonically increasing across the gap.",
      "ja": "完了再生動作後に到着RTSPシグナリング操作の結果であるメディアの時刻にジャンプする場合には、要求のタイミングは、そのメディアが非連続になることになります。サーバーは、それがタイムリーに到着し、まだメディアは連続ストリームにするためにタイムスタンプを運ぶようにメディアを送信することができなくなります。このような状況では、サーバーは、メディアのためのRTPタイムラインにギャップが存在する場合RTPストリームを生成します。メディアは、フレーム構造を持っている場合は、以前の構造と次のフレームのタイムスタンプを揃えることは、このメディアをレンダリングするための負担を軽減します。ギャップは、サーバがメディア、例えば、メディア・ストリームの終了又は一時停止要求及び新しいPLAY要求の間の時間にサービスを提供していない時間を表すべきです。これらのケースでは、RTPシーケンス番号は、通常、ギャップを横切って単調増加であろう。"
    },
    {
      "indent": 3,
      "text": "For RTSP sessions with media that lacks random access properties, such as live streams, any media-clock jump is commonly the result of a correspondingly long pause of delivery. The RTP timestamp will have increased in direct proportion to the duration of the paused delivery. Note also that in this case the RTP sequence number should be the next packet number. If not, the RTCP packet loss reporting will indicate as loss all packets not received between the point of pausing and later resuming. This may trigger congestion avoidance mechanisms. An allowed exception from the above recommendation on monotonically increasing RTP sequence number is live media streams, likely being relayed. In this case, when the client resumes delivery, it will get the media that is currently being delivered to the server itself. For this type of basic delivery of live streams to multiple users over unicast, individual rewriting of RTP sequence numbers becomes quite a burden. For solutions that already cache media or perform time shifting, the rewriting should impose only a minor burden.",
      "ja": "なライブストリームなどのランダムアクセス性を欠いているメディアとのRTSPセッションでは、任意のメディア・クロックのジャンプは、一般的に配達の相応に長い休止の結果です。 RTPタイムスタンプは一時停止配信の持続時間に正比例して増加しています。注また、この場合にはRTPシーケンス番号は、次のパケット数でなければならないこと。ない場合は、RTCPパケット損失の報告は損失として一時停止し、後で再開の地点間で受信されていないすべてのパケットを示します。これは、輻輳回避メカニズムをトリガすることができます。単調RTPシーケンス番号を増やすことで上記の勧告からの許可例外は、おそらく中継されて、ライブメディアストリームです。クライアントが配信を再開したときに、この場合、それは現在、サーバー自体に配信されているメディアを取得します。ユニキャストを超える複数のユーザーにライブストリームの基本的な配信のこのタイプでは、RTPシーケンス番号の個々の書き換えはかなりの負担になります。すでにメディアをキャッシュするか、タイムシフトを行うソリューションで、書き換えはわずかな負担を課す必要があります。"
    },
    {
      "indent": 3,
      "text": "The goal when handling jumps in media-clock time is that the provided stream is continuous without gaps in RTP timestamp or sequence number. However, when delivery has been halted for some reason, the RTP timestamp, when resuming, MUST represent the duration that the delivery was halted. An RTP sequence number MUST generally be the next number, i.e., monotonically increasing modulo 65536. For media resources with the properties Time-Progressing and Time-Duration=0.0, the server MAY create RTP media streams with RTP sequence number jumps in them due to the client first halting delivery and later resuming it (PAUSE and then later PLAY). However, servers utilizing this exception must take into consideration the resulting RTCP receiver reports that likely contain loss reports for all the packets that were a part of the discontinuity. A client cannot rely on the fact that a server will align when resuming play, even if it is RECOMMENDED. The RTP-Info header will provide information on how the server acts in each case.",
      "ja": "メディア・クロック時間にジャンプを扱う目標は、提供されたストリームは、RTPタイムスタンプやシーケンス番号で隙間なく連続しているということです。配信が何らかの理由で停止されたときしかし、RTPタイムスタンプは、再開するとき、配信が停止された期間を表現しなければなりません。 RTPシーケンス番号は、一般的に時間進むとと時間 - 持続時間= 0.0、RTPシーケンス番号とRTPメディアストリームを作成することができ、サーバーが原因にそれらにジャンプすなわち、単調特性を持つメディア・リソースについてはモジュロ65536を増やす次の番号を、でなければなりませんクライアントは、最初の配信を停止し、後で（PAUSEし、後でPLAY）再開します。ただし、この例外を利用し、サーバを考慮可能性が不連続の一部であったすべてのパケットをロスレポートが含まれていたRTCPレシーバレポートを取る必要があります。クライアントは、プレーを再開するとき、サーバは、それが推奨されている場合でも、整列するという事実に頼ることはできません。 RTP-Infoヘッダは、サーバがそれぞれの場合に作用する方法についての情報を提供します。"
    },
    {
      "indent": 6,
      "text": "One cannot assume that the RTSP client can communicate with the RTP media agent, as the two may be independent processes. If the RTP timestamp shows the same gap as the NPT, the media agent will assume that there is a pause in the presentation. If the jump in NPT is large enough, the RTP timestamp may roll over and the media agent may believe later packets to be duplicates of packets just played out. Having the RTP timestamp jump will also affect the RTCP measurements based on this.",
      "ja": "一つは、2つの独立したプロセスかもしれとしてRTSPクライアントは、RTPメディアエージェントと通信できることを仮定することはできません。 RTPタイムスタンプは、NPTと同じギャップを示している場合、メディアエージェントは、プレゼンテーションの一時停止があると仮定する。 NPTにおけるジャンプが十分に大きい場合、RTPタイムスタンプはロールオーバーすると、メディアエージェントは、後にパケットがちょうど演じたパケットの複製であると信じること。 RTPタイムスタンプジャンプを持つことも、これに基づいてRTCPの測定に影響を与えます。"
    },
    {
      "indent": 3,
      "text": "As an example, assume an RTP timestamp frequency of 8000 Hz, a packetization interval of 100 ms, and an initial sequence number and timestamp of zero.",
      "ja": "一例として、8000ヘルツ、100ミリ秒のパケット化間隔、およびゼロの初期シーケンス番号とタイムスタンプのRTPタイムスタンプの周波数を仮定しています。"
    },
    {
      "indent": 6,
      "text": "C->S: PLAY rtsp://example.com/fizzle RTSP/2.0 CSeq: 4 Session: ymIqLXufHkMHGdtENdblWK Range: npt=10-15 User-Agent: PhonyClient/1.2",
      "ja": "C-> S：PLAYのRTSP：//example.com/fizzle RTSP / 2.0のCSeq：4セッション：ymIqLXufHkMHGdtENdblWK範囲：NPT = 10-15のUser-Agent：PhonyClient / 1.2"
    },
    {
      "indent": 6,
      "text": "S->C: RTSP/2.0 200 OK CSeq: 4 Session: ymIqLXufHkMHGdtENdblWK Range: npt=10-15 RTP-Info: url=\"rtsp://example.com/fizzle/audiotrack\" ssrc=0D12F123:seq=0;rtptime=0",
      "ja": "S-> C：RTSP / 2.0 200 OKのCSeq：4セッション：ymIqLXufHkMHGdtENdblWK範囲：NPT = 10-15 RTP-情報：URL = \"RTSP：//example.com/fizzle/audiotrack\" SSRC = 0D12F123：SEQ = 0; rtptime = 0"
    },
    {
      "indent": 3,
      "text": "The ensuing RTP data stream is depicted below:",
      "ja": "続くRTPデータストリームを以下に示されています。"
    },
    {
      "indent": 6,
      "text": "S -> C: RTP packet - seq = 0, rtptime = 0, NPT time = 10s S -> C: RTP packet - seq = 1, rtptime = 800, NPT time = 10.1s . . . S -> C: RTP packet - seq = 49, rtptime = 39200, NPT time = 14.9s",
      "ja": "S  - > C：RTPパケット -  SEQ = 0、rtptime = 0、NPT時間= 10秒のS  - > C：RTPパケット -  SEQ = 1、rtptime = 800、NPT時間=の10.1s。 。 。 S  - > C：RTPパケット -  SEQ = 49、rtptime = 39200、NPT時間= 14.9s"
    },
    {
      "indent": 3,
      "text": "Upon the completion of the requested delivery, the server sends a PLAY_NOTIFY.",
      "ja": "配達希望が完了すると、サーバーはPLAY_NOTIFYを送信します。"
    },
    {
      "indent": 8,
      "text": "S->C: PLAY_NOTIFY rtsp://example.com/fizzle RTSP/2.0\n      CSeq: 5\n      Notify-Reason: end-of-stream\n      Request-Status: cseq=4 status=200 reason=\"OK\"\n      Range: npt=-15\n      RTP-Info:url=\"rtsp://example.com/fizzle/audiotrack\"\n         ssrc=0D12F123:seq=49;rtptime=39200\n      Session: ymIqLXufHkMHGdtENdblWK",
      "raw": true
    },
    {
      "indent": 8,
      "text": "C->S: RTSP/2.0 200 OK CSeq: 5 User-Agent: PhonyClient/1.2",
      "ja": "C-> S：RTSP / 2.0 200 OKのCSeq：5のUser-Agent：PhonyClient / 1.2"
    },
    {
      "indent": 3,
      "text": "Upon the completion of the play range, the client follows up with a request to PLAY from a new NPT.",
      "ja": "再生範囲が完了すると、クライアントは新しいNPTから再生するように要求してフォローしています。"
    },
    {
      "indent": 3,
      "text": "C->S: PLAY rtsp://example.com/fizzle RTSP/2.0 CSeq: 6 Session: ymIqLXufHkMHGdtENdblWK Range: npt=18-20 User-Agent: PhonyClient/1.2",
      "ja": "C-> S：PLAYのRTSP：//example.com/fizzle RTSP / 2.0のCSeq：6セッション：ymIqLXufHkMHGdtENdblWK範囲：NPT = 18-20のUser-Agent：PhonyClient / 1.2"
    },
    {
      "indent": 3,
      "text": "S->C: RTSP/2.0 200 OK CSeq: 6 Session: ymIqLXufHkMHGdtENdblWK Range: npt=18-20 RTP-Info: url=\"rtsp://example.com/fizzle/audiotrack\" ssrc=0D12F123:seq=50;rtptime=40100",
      "ja": "S-> C：RTSP / 2.0 200 OKのCSeq：6セッション：ymIqLXufHkMHGdtENdblWK範囲：NPT = 18-20 RTP-INFO：URL = \"RTSP：//example.com/fizzle/audiotrack\" SSRC = 0D12F123：SEQ = 50。 rtptime = 40100"
    },
    {
      "indent": 3,
      "text": "The ensuing RTP data stream is depicted below:",
      "ja": "続くRTPデータストリームを以下に示されています。"
    },
    {
      "indent": 6,
      "text": "S->C: RTP packet - seq = 50, rtptime = 40100, NPT time = 18s S->C: RTP packet - seq = 51, rtptime = 40900, NPT time = 18.1s . . . S->C: RTP packet - seq = 69, rtptime = 55300, NPT time = 19.9s",
      "ja": "S-> C：RTPパケット -  SEQ = 50、rtptime = 40100、NPT時間= 18S S-> C：RTPパケット -  SEQ = 51、rtptime = 40900、NPT時間=の18.1s。 。 。 S-> C：RTPパケット -  SEQ = 69、rtptime = 55300、NPT時間= 19.9s"
    },
    {
      "indent": 3,
      "text": "In this example, first, NPT 10 through 15 are played, then the client requests the server to skip ahead and play NPT 18 through 20. The first segment is presented as RTP packets with sequence numbers 0 through 49 and timestamps 0 through 39,200. The second segment consists of RTP packets with sequence numbers 50 through 69, with timestamps 40,100 through 55,200. While there is a gap in the NPT, there is no gap in the sequence-number space of the RTP data stream.",
      "ja": "この例では、まず、15を通じてNPT 10が再生され、その後、クライアントは、最初のセグメントが39200を通じてシーケンス番号0〜49とタイムスタンプをRTPパケットとして提示された20を介してNPT 18をスキップして再生するには、サーバーを要求します。第二セグメントは、55,200を介してタイムスタンプ40100と、シーケンス番号50〜69のRTPパケットから成ります。 NPTの隙間があるが、RTPデータストリームのシーケンス番号空間には隙間が存在しません。"
    },
    {
      "indent": 3,
      "text": "The RTP timestamp gap is present in the above example due to the time it takes to perform the second play request, in this case, 12.5 ms (100/8000).",
      "ja": "RTPタイムスタンプのギャップが原因それは、この場合には、第二再生要求を行う12.5ミリ秒（8000分の100）にかかる時間に上述の例に存在しています。"
    },
    {
      "indent": 0,
      "text": "C.4. Handling RTP Timestamps after PAUSE",
      "ja": "C.4。 PAUSEの後にRTPタイムスタンプの取り扱い"
    },
    {
      "indent": 3,
      "text": "During a PAUSE/PLAY interaction in an RTSP session, the duration of time for which the RTP transmission was halted MUST be reflected in the RTP timestamp of each RTP stream. The duration can be calculated for each RTP stream as the time elapsed from when the last RTP packet was sent before the PAUSE request was received and when the first RTP packet was sent after the subsequent PLAY request was received. The duration includes all latency incurred and processing time required to complete the request.",
      "ja": "RTSPセッションでPAUSE / PLAYの相互作用の間に、RTP送信を停止している時間の持続時間は、各RTPストリームのRTPタイムスタンプに反映されなければなりません。持続時間は、一時停止要求が受信される前およびその後のPLAY要求が受信された後の最初のRTPパケットが送信されたとき、最後のRTPパケットが送信されたときからの経過時間、各RTPストリームに対して計算することができます。期間は、要求を完了するために必要なすべての待ち時間の負担と処理時間が含まれます。"
    },
    {
      "indent": 6,
      "text": "RFC 3550 [RFC3550] states that: \"the RTP timestamp for each unit [packet] would be related to the wallclock time at which the unit becomes current on the virtual presentation timeline\".",
      "ja": "「各ユニットのRTPタイムスタンプ[パケット】ユニットは、仮想プレゼンテーションタイムライン上の電流となるように壁時計時間に関連するであろう」RFC 3550 [RFC 3550]と述べています。"
    },
    {
      "indent": 6,
      "text": "In order to satisfy the requirements of [RFC3550], the RTP timestamp space needs to increase continuously with real time. While this is not optimal for stored media, it is required for RTP and RTCP to function as intended. Using a continuous RTP timestamp space allows the same timestamp model for both stored and live media and allows better opportunity to integrate both types of media under a single control.",
      "ja": "[RFC3550]の要件を満たすためには、RTPタイムスタンプスペースは、リアルタイムで継続的に増加する必要があります。これは、保存されたメディアには最適ではないですが、意図したとおりに機能するようにRTPとRTCPのために必要とされます。連続RTPタイムスタンプのスペースを使用すると、両方の保存やライブメディアのための同じタイムスタンプモデルを可能にし、単一の制御下のメディアの両方のタイプを統合するためのより良い機会を可能にします。"
    },
    {
      "indent": 3,
      "text": "As an example, assume a clock frequency of 8000 Hz, a packetization interval of 100 ms, and an initial sequence number and timestamp of zero.",
      "ja": "一例として、8000ヘルツ、100ミリ秒のパケット化間隔、およびゼロの初期シーケンス番号とタイムスタンプのクロック周波数を仮定する。"
    },
    {
      "indent": 3,
      "text": "C->S: PLAY rtsp://example.com/fizzle RTSP/2.0 CSeq: 4 Session: ymIqLXufHkMHGdtENdblWK Range: npt=10-15",
      "ja": "C-> S：PLAYのRTSP：4セッション：ymIqLXufHkMHGdtENdblWK範囲：RTSP / 2.0のCSeq //example.com/fizzle NPT = 10~15"
    },
    {
      "indent": 9,
      "text": "User-Agent: PhonyClient/1.2",
      "ja": "User-Agent：PhonyClient / 1.2"
    },
    {
      "indent": 3,
      "text": "S->C: RTSP/2.0 200 OK CSeq: 4 Session: ymIqLXufHkMHGdtENdblWK Range: npt=10-15 RTP-Info: url=\"rtsp://example.com/fizzle/audiotrack\" ssrc=0D12F123:seq=0;rtptime=0",
      "ja": "S-> C：RTSP / 2.0 200 OKのCSeq：4セッション：ymIqLXufHkMHGdtENdblWK範囲：NPT = 10-15 RTP-情報：URL = \"RTSP：//example.com/fizzle/audiotrack\" SSRC = 0D12F123：SEQ = 0; rtptime = 0"
    },
    {
      "indent": 3,
      "text": "The ensuing RTP data stream is depicted below:",
      "ja": "続くRTPデータストリームを以下に示されています。"
    },
    {
      "indent": 6,
      "text": "S -> C: RTP packet - seq = 0, rtptime = 0, NPT time = 10s S -> C: RTP packet - seq = 1, rtptime = 800, NPT time = 10.1s S -> C: RTP packet - seq = 2, rtptime = 1600, NPT time = 10.2s S -> C: RTP packet - seq = 3, rtptime = 2400, NPT time = 10.3s",
      "ja": "S  - > C：RTPパケット -  SEQ = 0、rtptime = 0、NPT時間= 10秒のS  - > C：RTPパケット -  SEQ = 1、rtptimeは= 800、NPT時刻= 10.1sのS  - > C：RTPパケット - 配列= 2、rtptime = 1600 NPT時間=の10.2sのS  - > C：RTPパケット -  SEQ = 3、rtptime = 2400 NPT時刻= 10.3s"
    },
    {
      "indent": 3,
      "text": "The client then sends a PAUSE request:",
      "ja": "次に、クライアントは、PAUSE要求を送信します。"
    },
    {
      "indent": 3,
      "text": "C->S: PAUSE rtsp://example.com/fizzle RTSP/2.0 CSeq: 5 Session: ymIqLXufHkMHGdtENdblWK User-Agent: PhonyClient/1.2",
      "ja": "C-> S：PAUSEのRTSP：//example.com/fizzle RTSP / 2.0のCSeq：5セッション：ymIqLXufHkMHGdtENdblWKユーザーエージェント：PhonyClient / 1.2"
    },
    {
      "indent": 3,
      "text": "S->C: RTSP/2.0 200 OK CSeq: 5 Session: ymIqLXufHkMHGdtENdblWK Range: npt=10.4-15",
      "ja": "S-> C：RTSP / 2.0 200 OKのCSeq：5セッション：ymIqLXufHkMHGdtENdblWK範囲：NPT = 10.4から15"
    },
    {
      "indent": 3,
      "text": "20 seconds elapse and then the client sends a PLAY request. In addition, the server requires 15 ms to process the request:",
      "ja": "20秒が経過すると、クライアントはPLAY要求を送信します。また、サーバは要求を処理するために15ミリ秒を必要とします。"
    },
    {
      "indent": 3,
      "text": "C->S: PLAY rtsp://example.com/fizzle RTSP/2.0 CSeq: 6 Session: ymIqLXufHkMHGdtENdblWK User-Agent: PhonyClient/1.2",
      "ja": "C-> S：PLAYのRTSP：//example.com/fizzle RTSP / 2.0のCSeq：6セッション：ymIqLXufHkMHGdtENdblWKユーザーエージェント：PhonyClient / 1.2"
    },
    {
      "indent": 3,
      "text": "S->C: RTSP/2.0 200 OK CSeq: 6 Session: ymIqLXufHkMHGdtENdblWK Range: npt=10.4-15 RTP-Info: url=\"rtsp://example.com/fizzle/audiotrack\" ssrc=0D12F123:seq=4;rtptime=164400",
      "ja": "S-> C：RTSP / 2.0 200 OKのCSeq：6セッション：ymIqLXufHkMHGdtENdblWK範囲：NPT = 10.4から15 RTP-INFO：URL = \"RTSP：//example.com/fizzle/audiotrack\" SSRC = 0D12F123：配列= 4。 rtptime = 164400"
    },
    {
      "indent": 3,
      "text": "The ensuing RTP data stream is depicted below:",
      "ja": "続くRTPデータストリームを以下に示されています。"
    },
    {
      "indent": 6,
      "text": "S -> C: RTP packet - seq = 4, rtptime = 164400, NPT time = 10.4s S -> C: RTP packet - seq = 5, rtptime = 165200, NPT time = 10.5s S -> C: RTP packet - seq = 6, rtptime = 166000, NPT time = 10.6s",
      "ja": "S  - > C：RTPパケット -  SEQ = 4、rtptime = 164400、NPT時間=の10.4sのS  - > C：RTPパケット -  SEQ = 5、rtptime = 165200、NPT時刻= 10.5sのS  - > C：RTPパケット - SEQ = 6、rtptime = 166000、NPT時間= 10.6s"
    },
    {
      "indent": 3,
      "text": "First, NPT 10 through 10.3 is played, then a PAUSE is received by the server. After 20 seconds, a PLAY is received by the server that takes 15 ms to process. The duration of time for which the session was paused is reflected in the RTP timestamp of the RTP packets sent after this PLAY request.",
      "ja": "まず、10.3を通じてNPT 10が再生され、その後、PAUSEは、サーバで受信されます。 20秒後、PLAYはプロセスに15ミリ秒を要するサーバによって受信されます。セッションが一時停止された時間の期間は、このPLAY要求の後に送信されたRTPパケットのRTPタイムスタンプに反映されます。"
    },
    {
      "indent": 3,
      "text": "A client can use the RTSP Range header and RTP-Info header to map NPT time of a presentation with the RTP timestamp.",
      "ja": "クライアントは、RTPタイムスタンプとプレゼンテーションのNPT時間をマッピングするためにRTSP RangeヘッダおよびRTP-Infoヘッダーを使用することができます。"
    },
    {
      "indent": 3,
      "text": "Note: in RFC 2326 [RFC2326], this matter was not clearly defined and was misunderstood commonly. However, for RTSP 2.0, it is expected that this will be handled correctly and no exception handling will be required.",
      "ja": "注意：RFC 2326 [RFC2326]で、この問題は明確に定義されていないと一般的に誤解されました。しかし、RTSP 2.0のために、正しく処理され、例外処理が必要ないことが予想されます。"
    },
    {
      "indent": 3,
      "text": "Note further: it may be required to reset some of the state to ensure the correct media decoding and the usual jitter-buffer handling when issuing a PLAY request.",
      "ja": "さらに注意：PLAY要求を発行するときに、正しいメディア・デコードし、通常のジッタバッファの処理を確実にするために、状態の一部をリセットするために必要とされ得ます。"
    },
    {
      "indent": 0,
      "text": "C.5. RTSP/RTP Integration",
      "ja": "C.5。 RTSP / RTP統合"
    },
    {
      "indent": 3,
      "text": "For certain data types, tight integration between the RTSP layer and the RTP layer will be necessary. This by no means precludes the above restrictions. Combined RTSP/RTP media clients should use the RTP-Info field to determine whether incoming RTP packets were sent before or after a seek or before or after a PAUSE.",
      "ja": "特定のデータ型の場合は、RTSP層とRTP層との間の緊密な統合が必要になります。これは、決して上記の制限を排除します。組み合わせたRTSP / RTPメディアクライアントは、着信RTPパケットが前か模索前または後に一時停止した後に送られたかどうかを判断するためにRTP-Infoフィールドを使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "C.6. Scaling with RTP",
      "ja": "C.6。 RTPとスケーリング"
    },
    {
      "indent": 3,
      "text": "For scaling (see Section 18.46), RTP timestamps should correspond to the rendering timing. For example, when playing video recorded at 30 frames per second at a scale of two and speed (Section 18.50) of one, the server would drop every second frame to maintain and deliver video packets with the normal timestamp spacing of 3,000 per frame, but NPT would increase by 1/15 second for each video frame.",
      "ja": "（セクション18.46を参照）スケーリングのために、RTPタイムスタンプは、描画タイミングに対応しなければなりません。例えば、一つの2つのつと速度（セクション18.50）のスケールで、毎秒30のフレームで記録された映像を再生するとき、サーバが維持し、フレームあたり3,000の通常のタイムスタンプ間隔でビデオパケットを配信するために毎秒フレームをドロップするが、あろうNPTは、各ビデオフレームの1/15秒増加することになります。"
    },
    {
      "indent": 6,
      "text": "Note: the above scaling puts requirements on the media codec or a media stream to support it. For example, motion JPEG or other non-predictive video coding can easier handle the above example.",
      "ja": "注意：上記のスケーリングがそれをサポートするメディアコーデックやメディアストリーム上の要件を置きます。例えば、モーションJPEGまたは他の非予測ビデオ符号化は、より簡単に、上記の例を扱うことができます。"
    },
    {
      "indent": 0,
      "text": "C.7. Maintaining NPT Synchronization with RTP Timestamps",
      "ja": "C.7。 RTPタイムスタンプとNPT同期を維持"
    },
    {
      "indent": 3,
      "text": "The client can maintain a correct display of NPT by noting the RTP timestamp value of the first packet arriving after repositioning. The sequence parameter of the RTP-Info (Section 18.45) header provides the first sequence number of the next segment.",
      "ja": "クライアントは、再配置後に到着最初のパケットのRTPタイムスタンプ値に注目することによってNPTの正しい表示を維持することができます。 RTP-INFO（セクション18.45）ヘッダのシーケンスパラメータは、次のセグメントの最初のシーケンス番号を提供します。"
    },
    {
      "indent": 0,
      "text": "C.8. Continuous Audio",
      "ja": "C.8。連続オーディオ"
    },
    {
      "indent": 3,
      "text": "For continuous audio, the server SHOULD set the RTP marker bit at the beginning of serving a new PLAY request or at jumps in timeline. This allows the client to perform playout delay adaptation.",
      "ja": "連続オーディオの場合、サーバーは新しいPLAY要求にサービスを提供するの先頭またはタイムラインのジャンプでRTPマーカービットを設定する必要があります。これは、クライアントがプレイアウト遅延の適応を実行することができます。"
    },
    {
      "indent": 0,
      "text": "C.9. Multiple Sources in an RTP Session",
      "ja": "C.9。 RTPセッションで複数のソース"
    },
    {
      "indent": 3,
      "text": "Note that more than one SSRC MAY be sent in the media stream. If it happens, all sources are expected to be rendered simultaneously.",
      "ja": "複数のSSRCは、メディアストリームで送信することができることに注意してください。それが発生した場合、すべてのソースを同時にレンダリングされることが期待されます。"
    },
    {
      "indent": 0,
      "text": "C.10. Usage of SSRCs and the RTCP BYE Message during an RTSP Session",
      "ja": "C.10。 RTSPセッション中にSSRCsとRTCP BYEメッセージの使い方"
    },
    {
      "indent": 3,
      "text": "The RTCP BYE message indicates the end of use of a given SSRC. If all sources leave an RTP session, it can, in most cases, be assumed to have ended. Therefore, a client or server MUST NOT send an RTCP",
      "ja": "RTCP BYEメッセージは、所定のSSRCの使用の終了を示します。すべてのソースがRTPセッションを終了した場合、ほとんどの場合、終了したと仮定することができます。そのため、クライアントまたはサーバは、RTCPを送ってはいけません"
    },
    {
      "indent": 3,
      "text": "BYE message until it has finished using a SSRC. A server SHOULD keep using an SSRC until the RTP session is terminated. Prolonging the use of a SSRC allows the established synchronization context associated with that SSRC to be used to synchronize subsequent PLAY requests even if the PLAY response is late.",
      "ja": "それまでBYEメッセージはSSRCを使用して終わりました。 RTPセッションが終了するまで、サーバはSSRCを使用しておく必要があります。 SSRCの使用を延長すると、PLAY応答が遅い場合であっても、その後のPLAY要求を同期するために使用すべきSSRCに関連付け確立同期コンテキストを可能にします。"
    },
    {
      "indent": 3,
      "text": "An SSRC collision with the SSRC that transmits media does also have consequences, as it will normally force the media sender to change its SSRC in accordance with the RTP specification [RFC3550]. However, an RTSP server may wait and see if the client changes and thus resolve the conflict to minimize the impact. As media sender, SSRC change will result in a loss of synchronization context and require any receiver to wait for RTCP sender reports for all media requiring synchronization before being able to play out synchronized. Due to these reasons, a client joining a session should take care not to select the same SSRC(s) as the server indicates in the ssrc Transport header parameter. Any SSRC signaled in the Transport header MUST be avoided. A client detecting a collision prior to sending any RTP or RTCP messages SHALL also select a new SSRC.",
      "ja": "それは通常、RTP仕様[RFC3550]に従ってそのSSRCを変更するメディア送信者を強制するようにメディアを送信SSRCとSSRC衝突はまた、影響を持ちません。しかし、RTSPサーバが待機してかどうかを確認し、クライアントの変化を、したがって、影響を最小限に抑えるために、競合を解決することができます。メディア送信者として、SSRCの変更が​​同期コンテキストの損失をもたらすと同期してプレーできるようになる前に、同期を必要とするすべてのメディアのRTCP送信者レポートを待つために、任意の受信機が必要になります。これらの理由により、セッションに参加するクライアントは、サーバーがSSRCトランスポートヘッダパラメータに示すとおり、同じSSRC（複数可）を選択しないように注意する必要があります。トランスポート・ヘッダにおいてシグナリング任意SSRCは避けなければなりません。任意のRTPまたはRTCPメッセージを送信する前に衝突を検出し、クライアントは、新しいSSRCを選択しなければなりません。"
    },
    {
      "indent": 0,
      "text": "C.11. Future Additions",
      "ja": "C.11。将来の追加"
    },
    {
      "indent": 3,
      "text": "It is the intention that any future protocol or profile regarding media delivery and lower transport should be easy to add to RTSP. This section provides the necessary steps that need to be met.",
      "ja": "これは、メディア配信と低輸送に関するいかなる将来のプロトコルまたはプロファイルは、RTSPに追加するのは簡単であることを意図しています。このセクションでは、満たされる必要がある必要な手順を提供します。"
    },
    {
      "indent": 3,
      "text": "The following things need to be considered when adding a new protocol or profile for use with RTSP:",
      "ja": "次のものがRTSPで使用するための新しいプロトコルまたはプロファイルを追加する際に考慮する必要があります。"
    },
    {
      "indent": 3,
      "text": "o The protocol or profile needs to define a name tag representing it. This tag is required to be an ABNF \"token\" to be possible to use in the Transport header specification.",
      "ja": "Oプロトコルまたはプロファイルは、それを表す名前タグを定義する必要があります。このタグは、トランスポート・ヘッダの仕様で使用することが可能であることがABNF「トークン」であることが必要です。"
    },
    {
      "indent": 3,
      "text": "o The useful combinations of protocol, profiles, and lower-layer transport for this extension need to be defined. For each combination, declare the necessary parameters to use in the Transport header.",
      "ja": "この拡張のためのプロトコル、プロファイル、及び下層輸送の有用な組み合わせoを定義する必要があります。各組合せのために、トランスポート・ヘッダに使用するために必要なパラメータを宣言する。"
    },
    {
      "indent": 3,
      "text": "o For new media protocols, the interaction with RTSP needs to be addressed. One important factor will be the media synchronization. It may be necessary to have new headers similar to RTP info to carry this information.",
      "ja": "新しいメディアプロトコルの場合oは、RTSPとの相互作用が対処する必要があります。 1つの重要な要因は、メディア同期となります。この情報を運ぶためにRTP情報に似た新しいヘッダを持っている必要があります。"
    },
    {
      "indent": 3,
      "text": "o Discussion needs to occur regarding congestion control for media, especially if transport without built-in congestion control is used.",
      "ja": "O議論は、内蔵の輻輳制御なしのトランスポートが使用されている場合は特に、メディアのための輻輳制御に関する発生する必要があります。"
    },
    {
      "indent": 3,
      "text": "See the IANA Considerations section (Section 22) for information on how to register new attributes.",
      "ja": "新しい属性を登録する方法については、IANAの考慮事項のセクション（セクション22）を参照してください。"
    },
    {
      "indent": 0,
      "text": "Appendix D. Use of SDP for RTSP Session Descriptions",
      "ja": "RTSPセッション記述のためのSDPの付録D.使用"
    },
    {
      "indent": 3,
      "text": "The Session Description Protocol (SDP, [RFC4566]) may be used to describe streams or presentations in RTSP. This description is typically returned in reply to a DESCRIBE request on a URI from a server to a client or received via HTTP from a server to a client.",
      "ja": "セッション記述プロトコル（SDP、[RFC4566]）はRTSPでストリームまたはプレゼンテーションを記述するために使用されてもよいです。この説明は、通常、サーバからクライアントにURI上のDESCRIBE要求に対する応答で返されるか、サーバからクライアントへHTTPを介して受信されます。"
    },
    {
      "indent": 3,
      "text": "This appendix describes how an SDP file determines the operation of an RTSP session. Thus, it is worth pointing out that the interpretation of the SDP is done in the context of the SDP receiver, which is the one being configured. This is the same as in SAP [RFC2974]; this differs from SDP Offer/Answer [RFC3264] where each SDP is interpreted in the context of the agent providing it.",
      "ja": "この付録では、SDPファイルは、RTSPセッションの動作を決定する方法を説明します。したがって、SDPの解釈が設定されているものであるSDP受信機の文脈で行われることを指摘する価値があります。これは、SAP [RFC2974]と同じです。これは、各SDPはそれを付与剤との関連で解釈されるSDPオファー/アンサー[RFC3264]とは異なります。"
    },
    {
      "indent": 3,
      "text": "SDP as is provides no mechanism by which a client can distinguish, without human guidance, between several media streams to be rendered simultaneously and a set of alternatives (e.g., two audio streams spoken in different languages). The SDP extension found in \"The Session Description Protocol (SDP) Grouping Framework\" [RFC5888] provides such functionality to some degree. Appendix D.4 describes the usage of SDP media line grouping for RTSP.",
      "ja": "SDPはそのままクライアントは、いくつかのメディアストリームとの間で、人間の指導なしで、見分けることが可能なメカニズムを同時にレンダリングされると（例えば、2つのオーディオストリームは、異なる言語で話す）選択肢のセットを提供しません。 「セッション記述プロトコル（SDP）グループ化フレームワーク」[RFC5888]に見出されるSDPエクステンションは、ある程度そのような機能を提供します。付録D.4は、RTSPのグループ化SDPメディアラインの使用方法を説明します。"
    },
    {
      "indent": 0,
      "text": "D.1. Definitions",
      "ja": "D.1。定義"
    },
    {
      "indent": 3,
      "text": "The terms \"session-level\", \"media-level\", and other key/attribute names and values used in this appendix are to be used as defined in SDP [RFC4566]:",
      "ja": "SDP [RFC4566]で定義されるように、用語「セッションレベル」、「メディアレベル」、およびこの付録で使用される他のキー/属性名と属性値が使用されるべきです。"
    },
    {
      "indent": 0,
      "text": "D.1.1. Control URI",
      "ja": "D.1.1。コントロールURI"
    },
    {
      "indent": 3,
      "text": "The \"a=control\" attribute is used to convey the control URI. This attribute is used both for the session and media descriptions. If used for individual media, it indicates the URI to be used for controlling that particular media stream. If found at the session level, the attribute indicates the URI for aggregate control (presentation URI). The session-level URI MUST be different from any media-level URI. The presence of a session-level control attribute MUST be interpreted as support for aggregated control. The control attribute MUST be present on the media level unless the presentation only contains a single media stream; in which case, the attribute MAY be present on the session level only and then also apply to that single media stream.",
      "ja": "「A =コントロール」属性は、コントロールURIを伝えるために使用されます。この属性は、両方のセッションとメディアの説明のために使用されています。個々のメディアのために使用した場合、その特定のメディアストリームを制御するために使用するURIを示します。セッションレベルで見つかった場合、属性は、集約制御のためのURI（プレゼンテーションURI）を示しています。セッション・レベルのURIは、任意のメディアレベルURIと異なっている必要があります。セッションレベルの制御属性の存在は凝集制御のためのサポートとして解釈されなければなりません。プレゼンテーションは、単一のメディアストリームが含まれていない限り、制御属性は、メディアレベルで存在しなければなりません。その場合には、属性はセッションレベルで存在してもよく、そしてまた、その単一のメディアストリームに適用されます。"
    },
    {
      "indent": 3,
      "text": "ABNF for the attribute is defined in Section 20.3.",
      "ja": "属性のABNFは、セクション20.3で定義されています。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 5,
      "text": "a=control:rtsp://example.com/foo",
      "ja": "=制御：RTSP：//example.com/foo"
    },
    {
      "indent": 3,
      "text": "This attribute MAY contain either relative or absolute URIs, following the rules and conventions set out in RFC 3986 [RFC3986]. Implementations MUST look for a base URI in the following order:",
      "ja": "この属性は、RFC 3986 [RFC3986]で定めたルールや規則次の相対または絶対URIを含んでいてもよいです。実装は次の順序でベースURIのために見なければなりません："
    },
    {
      "indent": 3,
      "text": "1. the RTSP Content-Base field;",
      "section_title": true,
      "ja": "1. RTSPのContent-ベースのフィールドは、"
    },
    {
      "indent": 3,
      "text": "2. the RTSP Content-Location field;",
      "section_title": true,
      "ja": "2. RTSPのContent-Locationフィールドには、"
    },
    {
      "indent": 3,
      "text": "3. the RTSP Request-URI.",
      "section_title": true,
      "ja": "3. RTSPのRequest-URI。"
    },
    {
      "indent": 3,
      "text": "If this attribute contains only an asterisk (*), then the URI MUST be treated as if it were an empty embedded URI; thus, it will inherit the entire base URI.",
      "ja": "この属性にアスタリスク（*）のみが含まれている場合、それは空の埋め込みURIであるかのように、そのURIは、処理されなければなりません。したがって、それは全体のベースURIを継承します。"
    },
    {
      "indent": 6,
      "text": "Note: RFC 2326 was very unclear on the processing of relative URIs and several RTSP 1.0 implementations at the point of publishing this document did not perform RFC 3986 processing to determine the resulting URI; instead, simple concatenation is common. To avoid this issue completely, it is recommended to use absolute URIs in the SDP.",
      "ja": "注：RFC 2326は、相対URIの処理に非常に不明瞭であり、この文書を公開した時点で、いくつかのRTSP 1.0の実装は、結果として得られるURIを決定するために、RFC 3986の処理を実行しませんでした。代わりに、簡単な連結が一般的です。完全にこの問題を回避するために、SDPに絶対URIを使用することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "The URI handling for SDPs from container files needs special consideration. For example, let's assume that a container file has the URI: \"rtsp://example.com/container.mp4\". Let's further assume this URI is the base URI and that there is an absolute media-level URI: \"rtsp://example.com/container.mp4/trackID=2\". A relative media-level URI that resolves in accordance with RFC 3986 [RFC3986] to the above given media URI is \"container.mp4/trackID=2\". It is usually not desirable to need to include or modify the SDP stored within the container file with the server local name of the container file. To avoid this, one can modify the base URI used to include a trailing slash, e.g., \"rtsp://example.com/container.mp4/\". In this case, the relative URI for the media will only need to be \"trackID=2\". However, this will also mean that using \"*\" in the SDP will result in the control URI including the trailing slash, i.e., \"rtsp://example.com/container.mp4/\".",
      "ja": "コンテナファイルからのSDPのためのURIの取り扱いは特別な配慮が必要です。たとえば、のは、コンテナファイルは、URIを持っていると仮定しましょう：「RTSP：//example.com/container.mp4」。 「RTSP：//example.com/container.mp4/trackID=2」のは、さらに、このURIはベースURIであると絶対的なメディアレベルURIがあると仮定しよう。上記メディアURIにRFC 3986 [RFC3986]に従って解決相対メディアレベルURI「はcontainer.mp4 / trackID = 2」です。通常、コンテナファイルのサーバーのローカル名を持つコンテナファイル内に格納されているSDPを含めるか、変更する必要がすることは望ましくありません。これを避けるためには、URIの末尾のスラッシュ、例えば、「：//example.com/container.mp4/ RTSP」を含めるために使用されるベースを変更することができます。この場合には、メディアの相対URIは、「trackID = 2」である必要があります。しかし、これはまた、SDPの「*」を使用すると、後続のスラッシュ、すなわち、「：//example.com/container.mp4/ RTSP」含む制御URIをもたらすであろうことを意味します。"
    },
    {
      "indent": 6,
      "text": "Note: the usage of TrackID in the above is not a standardized form, but one example out of several similar strings such as TrackID, Track_ID, StreamID that is used by different server vendors to indicate a particular piece of media inside a container file.",
      "ja": "注：上記でTrackIDの使用は、標準化された形ではなく、コンテナファイル内のメディアの特定の部分を示すために、別のサーバー・ベンダーによって使用されるようTrackID、Track_ID、streamIDでのようないくつかの類似文字列のうちの一例を示します。"
    },
    {
      "indent": 0,
      "text": "D.1.2. Media Streams",
      "ja": "D.1.2。メディアストリーム"
    },
    {
      "indent": 3,
      "text": "The \"m=\" field is used to enumerate the streams. It is expected that all the specified streams will be rendered with appropriate synchronization. If the session is over multicast, the port number indicated SHOULD be used for reception. The client MAY try to override the destination port, through the Transport header. The servers MAY allow this: the response will indicate whether or not this is allowed. If the session is unicast, the port numbers are the ones RECOMMENDED by the server to the client, about which receiver ports to use; the client MUST still include its receiver ports in its SETUP request. The client MAY ignore this recommendation. If the server has no preference, it SHOULD set the port number value to zero.",
      "ja": "「M =」フィールドは、ストリームを列挙するために使用されます。指定されたすべてのストリームが適切な同期でレンダリングされることが期待されます。セッションは、マルチキャストを超えている場合、示されたポート番号が受信に使用されるべきです。クライアントは、トランスポートヘッダを通じて、宛先ポートを無効にしようとするかもしれません。サーバはこれを許可することがあります。応答は、これが許可されているかどうかを示します。セッションがユニキャストである場合は、ポート番号はレシーバーポートを使用するかについて、クライアントにサーバーが推奨するものです。クライアントはまだそのSETUP要求でその受信ポートを含まなければなりません。クライアントは、この勧告を無視してもよいです。サーバは、問わないを持っていない場合、それはゼロにポート番号の値を設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "The \"m=\" lines contain information about which transport protocol, profile, and possibly lower-layer are to be used for the media stream. The combination of transport, profile, and lower layer, like RTP/AVP/UDP, needs to be defined for how to be used with RTSP. The currently defined combinations are discussed in Appendix C; further combinations MAY be specified.",
      "ja": "「M =」行は、トランスポートプロトコル、プロファイル、およびおそらくは下層は、メディアストリームのために使用されるかに関する情報を含みます。輸送、プロファイル、及び下部層の組み合わせは、RTP / AVP / UDPのように、RTSPで使用する方法のために定義される必要があります。現在定義されている組み合わせは、付録Cに記載されています。さらなる組み合わせを指定することができます。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 5,
      "text": "m=audio 0 RTP/AVP 31",
      "ja": "M = 0オーディオRTP / AVP 31"
    },
    {
      "indent": 0,
      "text": "D.1.3. Payload Type(s)",
      "ja": "D.1.3。ペイロードタイプ（S）"
    },
    {
      "indent": 3,
      "text": "The payload type or types are specified in the \"m=\" line. In case the payload type is a static payload type from RFC 3551 [RFC3551], no other information may be required. In case it is a dynamic payload type, the media attribute \"rtpmap\" is used to specify what the media is. The \"encoding name\" within the \"rtpmap\" attribute may be one of those specified in [RFC4856], a media type registered with IANA according to [RFC4855], or an experimental encoding as specified in SDP [RFC4566]). Codec-specific parameters are not specified in this field, but rather in the \"fmtp\" attribute described below.",
      "ja": "ペイロードタイプ又は種類が「M =」行で指定されています。場合ペイロードタイプは、RFC 3551 [RFC3551]から静的ペイロードタイプであり、他の情報を必要としないことができます。それがダイナミックペイロードタイプである場合には、メディア属性「rtpmapは、」メディアが何であるかを指定するために使用されます。 「rtpmap」属性内「エンコーディング名は」[RFC4856]、[RFC4855]によれば、IANAに登録されたメディアタイプ、またはSDP [RFC4566]で指定されるように実験的エンコーディング）で指定されたものの一つであってもよいです。コーデック固有のパラメータは、この分野ではなく、むしろ後述の「のfmtp」属性で指定されていません。"
    },
    {
      "indent": 3,
      "text": "The selection of the RTP payload type numbers used may be required to consider RTP and RTCP Multiplexing [RFC5761], if that is to be supported by the server.",
      "ja": "それはサーバによってサポートされる場合に使用されるRTPペイロードタイプ番号の選択は、RTP及びRTCP多重[RFC5761]を検討するために必要とされ得ます。"
    },
    {
      "indent": 0,
      "text": "D.1.4. Format-Specific Parameters",
      "ja": "D.1.4。フォーマット固有のパラメータ"
    },
    {
      "indent": 3,
      "text": "Format-specific parameters are conveyed using the \"fmtp\" media attribute. The syntax of the \"fmtp\" attribute is specific to the encoding(s) to which the attribute refers. Note that some of the format-specific parameters may be specified outside of the \"fmtp\" parameters, for example, like the \"ptime\" attribute for most audio encodings.",
      "ja": "フォーマット固有のパラメータは、「のfmtp」メディア属性を使用して搬送されます。 「のfmtp」属性の構文は、属性が参照するエンコーディング（複数可）に特異的です。フォーマット固有のパラメータのいくつかは、ほとんどのオーディオ符号化のための「PTIME」属性のような、例えば、「のfmtp」パラメータの外に指定されてもよいことに留意されたいです。"
    },
    {
      "indent": 0,
      "text": "D.1.5. Directionality of Media Stream",
      "ja": "D.1.5。メディアストリームの方向性"
    },
    {
      "indent": 3,
      "text": "The SDP attributes \"a=sendrecv\", \"a=recvonly\", and \"a=sendonly\" provide instructions about the direction the media streams flow within a session. When using RTSP, the SDP can be delivered to a client using either RTSP DESCRIBE or a number of RTSP external methods, like HTTP, FTP, and email. Based on this, the SDP applies to how the RTSP client will see the complete session. Thus, media streams delivered from the RTSP server to the client would be given the \"a=recvonly\" attribute.",
      "ja": "SDPは、「= recvonlyで」、「A =のsendrecv」を属性、および「Aが= sendonlyの」セッション内のメディアストリームが流れ方向についての指示を提供します。 RTSPを使用している場合、SDPは、RTSPのいずれかを使用してクライアントに配信することができ、HTTP、FTP、および電子メールのように、RTSP外部メソッドの数をDESCRIBEか。これに基づき、SDPは、RTSPクライアントは、完全なセッションが表示されますどのように適用されます。したがって、クライアントへのRTSPサーバから配信メディアストリームは、「= recvonlyで」属性を与えられるであろう。"
    },
    {
      "indent": 3,
      "text": "\"a=recvonly\" in an SDP provided to the RTSP client indicates that media delivery will only occur in the direction from the RTSP server to the client. SDP provided to the RTSP client that lacks any of the directionality attributes (\"a=recvonly\", \"a=sendonly\", \"a=sendrecv\") would be interpreted as having \"a=sendrecv\". At the time of writing, there exists no RTSP mode suitable for media traffic in the direction from the RTSP client to the server. Thus, all RTSP SDP SHOULD have an \"a=recvonly\" attribute when using the PLAY mode defined in this document. If future modes are defined for media in the client-to-server direction, then usage of \"a=sendonly\" or \"a=sendrecv\" may become suitable to indicate intended media directions.",
      "ja": "RTSPクライアントに提供されるSDPの「A = recvonlyでは、」メディア配信のみRTSPサーバからクライアントへの方向に発生することを示しています。 SDPは、指向性のいずれかの属性を欠いているRTSPクライアントに提供される（ \"= sendonlyの\"、 \"A = recvonlyで\"、 \"A =のsendrecv\"）は \"A =のsendrecv\" を有するものとして解釈されます。執筆の時点では、サーバーへのRTSPクライアントからの方向でメディアトラフィックに適したいかなるRTSPモードは存在しません。この文書で定義されてPLAYモードを使用する場合にこのように、すべてのRTSP SDPは、「= recvonlyで」属性を持っているべきです。将来のモードは、クライアントからサーバーへの方向にメディアのために定義されている場合、の使用「Aがsendonlyで=」または「=のsendrecv」が意図メディアの方向を示すために適当になることができます。"
    },
    {
      "indent": 0,
      "text": "D.1.6. Range of Presentation",
      "ja": "D.1.6。プレゼンテーションの範囲"
    },
    {
      "indent": 3,
      "text": "The \"a=range\" attribute defines the total time range of the stored session or an individual media. Live sessions that are not seekable can be indicated as specified below; whereas the length of live sessions can be deduced from the \"t=\" and \"r=\" SDP parameters.",
      "ja": "「A =範囲」属性は、格納されたセッションの合計時間範囲または個々のメディアを定義します。下記に指定されているように示すことができるシークではありませんライブセッション。ライブセッションの長さに対し「T =」と「R =」SDPパラメータから推定することができます。"
    },
    {
      "indent": 3,
      "text": "The attribute is both a session- and a media-level attribute. For presentations that contain media streams of the same duration, the range attribute SHOULD only be used at the session level. In case of different lengths, the range attribute MUST be given at media level for all media and SHOULD NOT be given at the session level. If the attribute is present at both media level and session level, the media-level values MUST be used.",
      "ja": "属性は、セッション - とメディアレベル属性の両方です。同じ期間のメディアストリームを含むプレゼンテーションに、範囲属性はセッションレベルで使用されるべきです。異なる長さの場合には、範囲属性は、すべてのメディアのメディアレベルで指定する必要があり、セッション・レベルで投与してはなりません。属性がメディアレベルとセッションレベルの両方で存在する場合、メディア・レベルの値が使用されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Note: usually one will specify the same length for all media, even if there isn't media available for the full duration on all media. However, that requires that the server accept PLAY requests within that range.",
      "ja": "注：通常、1つは、すべてのメディア上の全期間に利用可能なメディアが存在しない場合でも、すべてのメディアに同じ長さを指定します。しかし、それは、サーバがその範囲内のPLAY要求を受け入れることが必要です。"
    },
    {
      "indent": 3,
      "text": "Servers MUST take care to provide RTSP Range (see Section 18.40) values that are consistent with what is presented in the SDP for the content. There is no reason for non dynamic content, like media clips provided on demand to have inconsistent values. Inconsistent values between the SDP and the actual values for the content handled by the server is likely to generate some failure, like 457 \"Invalid Range\", in case the client uses PLAY requests with a Range header. In case the content is dynamic in length and it is infeasible to provide a correct value in the SDP, the server is recommended to describe this as content that is not seekable (see below). The server MAY override that property in the response to a PLAY request using the correct values in the Range header.",
      "ja": "サーバは、コンテンツのためのSDPに提示されているものと一致しているRTSP範囲（セクション18.40を参照）の値を提供するために、注意しなければなりません。非動的なコンテンツのための理由は、一貫性のない値を持つオンデマンドで提供されたメディアクリップのような、ありません。クライアントがRangeヘッダとPLAY要求を使用した場合に、SDPとサーバが扱うコンテンツの実際の値との間の一貫性のない値は、457「無効な範囲」のように、いくつかの障害を発生する可能性があります。コンテンツの長さが動的であり、SDPに正しい値を提供するために実行不可能である場合には、サーバは、（下記参照）シークないコンテンツとしてこれを記述することが推奨されます。サーバは、Rangeヘッダに正しい値を使用して、PLAY要求に応答して、そのプロパティを無効にすることができます。"
    },
    {
      "indent": 3,
      "text": "The unit is specified first, followed by the value range. The units and their values are as defined in Section 4.4.1, Section 4.4.2, and Section 4.4.3 and MAY be extended with further formats. Any open-ended range (start-), i.e., without stop range, is of unspecified duration and MUST be considered as content that is not seekable unless this property is overridden. Multiple instances carrying different clock formats MAY be included at either session or media level.",
      "ja": "単位は、値の範囲が続く、最初に指定されています。セクション4.4.1、セクション4.4.2および4.4.3で定義され、さらにフォーマットに拡張することができるように単位とその値です。任意のオープンエンド範囲（スタート）は、即ち、停止範囲せず、不特定の期間であり、このプロパティが上書きされない限り、シーク可能でないコンテンツと見なされなければなりません。異なるクロック・フォーマットを運ぶ複数のインスタンスは、いずれかのセッションまたはメディアレベルで含まれるかもしれません。"
    },
    {
      "indent": 3,
      "text": "ABNF for the attribute is defined in Section 20.3.",
      "ja": "属性のABNFは、セクション20.3で定義されています。"
    },
    {
      "indent": 3,
      "text": "Examples:",
      "ja": "例："
    },
    {
      "indent": 5,
      "text": "a=range:npt=0-34.4368 a=range:clock=19971113T211503Z-19971113T220300Z Non-seekable stream of unknown duration: a=range:npt=0-",
      "ja": "=範囲：NPT = 0から34.4368 =範囲：未知の期間のクロック= 19971113T211503Z-19971113T220300Zシーク不可能なストリーム：=範囲：NPT = 0-"
    },
    {
      "indent": 0,
      "text": "D.1.7. Time of Availability",
      "ja": "D.1.7。可用性の時間"
    },
    {
      "indent": 3,
      "text": "The \"t=\" field defines when the SDP is valid. For on-demand content, the server SHOULD indicate a stop time value for which it guarantees the description to be valid and a start time that is equal to or before the time at which the DESCRIBE request was received. It MAY also indicate start and stop times of 0, meaning that the session is always available.",
      "ja": "SDPが有効であるとき、「トン=」フィールドが定義されています。オンデマンドコンテンツの場合、サーバーは、それが有効であるとの記述を保証するための停止時間値およびDESCRIBE要求を受信した時刻にまたはの前に平等である開始時刻を示す必要があります。また、セッションは常に利用可能であることを意味し、0の時の開始と停止を示しているかもしれません。"
    },
    {
      "indent": 3,
      "text": "For sessions that are of live type, i.e., specific start time, unknown stop time, likely not seekable, the \"t=\" and \"r=\" field SHOULD be used to indicate the start time of the event. The stop time SHOULD be given so that the live event will have ended at that time, while still not being unnecessary far into the future.",
      "ja": "おそらく、ライブのタイプ、すなわち、特定の開始時間、未知の停止時間のシーク可能でないセッションでは、「T =」と「R =」フィールドは、イベントの開始時刻を示すために使用されるべきです。まだ遠い将来に不必要ではないが、ライブイベントが、その時点で終了してしまうように、停止時間が与えられるべきです。"
    },
    {
      "indent": 0,
      "text": "D.1.8. Connection Information",
      "ja": "D.1.8。接続情報"
    },
    {
      "indent": 3,
      "text": "In SDP used with RTSP, the \"c=\" field contains the destination address for the media stream. If a multicast address is specified, the client SHOULD use this address in any SETUP request as destination address, including any additional parameters, such as TTL. For on-demand unicast streams and some multicast streams, the destination address MAY be specified by the client via the SETUP request, thus overriding any specified address. To identify streams without a fixed destination address, where the client is required to specify a destination address, the \"c=\" field SHOULD be set to a null value. For addresses of type \"IP4\", this value MUST be \"0.0.0.0\"; and for type \"IP6\", this value MUST be \"0:0:0:0:0:0:0:0\" (can also be written as \"::\"), i.e., the unspecified address according to RFC 4291 [RFC4291].",
      "ja": "RTSPと共に使用SDPにおいて、「C =」フィールドは、メディアストリームの宛先アドレスを含みます。マルチキャストアドレスが指定されている場合、クライアントは、TTLなどの任意の追加のパラメータを含む、宛先アドレスとして任意のSETUPリクエストでこのアドレスを使用すべきです。オンデマンドのユニキャストストリームといくつかのマルチキャストストリームの場合は、送信先アドレスは、このように任意の指定されたアドレスを上書きし、SETUP要求を介してクライアントによって指定することができます。クライアントは、宛先アドレスを指定する必要があり、固定宛先アドレス、なしストリームを識別するために、「C =」フィールドにはヌル値に設定する必要があります。タイプ「IP4」のアドレスの場合、この値は「0.0.0.0」でなければなりません。そしてタイプ \"IP6\" ため、この値がなければなりません \"0：0：0：0：0：0：0：0\"、すなわち、不特定のアドレスは、RFC 4291 [に従って（また、 \"::\" のように書くことができます） RFC4291]。"
    },
    {
      "indent": 0,
      "text": "D.1.9. Message Body Tag",
      "ja": "D.1.9。メッセージ本文タグ"
    },
    {
      "indent": 3,
      "text": "The optional \"a=mtag\" attribute identifies a version of the session description. It is opaque to the client. SETUP requests may include this identifier in the If-Match field (see Section 18.24) to allow session establishment only if this attribute value still corresponds to that of the current description. The attribute value is opaque and may contain any character allowed within SDP attribute values.",
      "ja": "オプションの「= mタグ」属性はセッション記述のバージョンを識別します。これは、クライアントには不透明です。 SETUP要求は、この属性の値は、まだ現在の説明のものに対応する場合にのみ、セッションの確立を許可する（セクション18.24を参照）の場合、Matchフィールドに、この識別子を含むことができます。属性値は不透明であるとSDP属性値内で許可され、任意の文字を含めることができます。"
    },
    {
      "indent": 3,
      "text": "ABNF for the attribute is defined in Section 20.3.",
      "ja": "属性のABNFは、セクション20.3で定義されています。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 5,
      "text": "a=mtag:\"158bb3e7c7fd62ce67f12b533f06b83a\"",
      "ja": "= mタグ： \"158bb3e7c7fd62ce67f12b533f06b83a\""
    },
    {
      "indent": 6,
      "text": "One could argue that the \"o=\" field provides identical functionality. However, it does so in a manner that would put constraints on servers that need to support multiple session description types other than SDP for the same piece of media content.",
      "ja": "一つは、「O =」フィールドは、同一の機能を提供することを主張することができます。しかし、それは、メディアコンテンツの同じ部分のためのSDP以外の複数のセッション記述タイプをサポートする必要があるサーバー上の制約を置くようにしそう。"
    },
    {
      "indent": 0,
      "text": "D.2. Aggregate Control Not Available",
      "ja": "D.2。集計コントロール不可"
    },
    {
      "indent": 3,
      "text": "If a presentation does not support aggregate control, no session-level \"a=control\" attribute is specified. For an SDP with multiple media sections specified, each section will have its own control URI specified via the \"a=control\" attribute.",
      "ja": "プレゼンテーションが集約コントロールをサポートしていない場合、セッションレベルない「=コントロール」属性が指定されています。指定された複数のメディアセクションとSDPのために、各セクションは、URIが「A =コントロール」属性で指定独自の制御を有することになります。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 3,
      "text": "v=0 o=- 2890844256 2890842807 IN IP4 192.0.2.56 s=I came from a web page e=adm@example.com c=IN IP4 0.0.0.0 t=0 0 m=video 8002 RTP/AVP 31 a=control:rtsp://audio.example.com/movie.aud m=audio 8004 RTP/AVP 3 a=control:rtsp://video.example.com/movie.vid",
      "ja": "V = 0 0 =  -  2890844256 2890842807 IP4 192.0.2.56 S IN =私はIP4 0.0.0.0トン= 0 0メートル=ビデオ8002 RTP / AVP 31 A =コントロールでe=adm@example.com C = Webページから来ました：RTSP：//audio.example.com/movie.aud M =オーディオ8004 RTP / AVP 3 A =コントロール：RTSP：//video.example.com/movie.vid"
    },
    {
      "indent": 3,
      "text": "Note that the position of the control URI in the description implies that the client establishes separate RTSP control sessions to the servers audio.example.com and video.example.com.",
      "ja": "説明にコントロールURIの位置は、クライアントがサーバaudio.example.comとvideo.example.comへの個別のRTSPコントロールセッションを確立することを意味することに注意してください。"
    },
    {
      "indent": 3,
      "text": "It is recommended that an SDP file contain the complete media-initialization information even if it is delivered to the media client through non-RTSP means. This is necessary as there is no mechanism to indicate that the client should request more detailed media stream information via DESCRIBE.",
      "ja": "SDPファイルは、それが意味非RTSPを介してメディアクライアントに配信されている場合でも、完全なメディア初期化情報が含まれていることをお勧めします。 DESCRIBEを介してクライアントは、より詳細なメディアストリーム情報を要求すべきであることを示す機構がないよう、これが必要です。"
    },
    {
      "indent": 0,
      "text": "D.3. Aggregate Control Available",
      "ja": "D.3。利用可能な集約コントロール"
    },
    {
      "indent": 3,
      "text": "In this scenario, the server has multiple streams that can be controlled as a whole. In this case, there are both a media-level \"a=control\" attribute, which is used to specify the stream URIs, and a session-level \"a=control\" attribute, which is used as the Request-URI for aggregate control. If the media-level URI is relative, it is resolved to absolute URIs according to Appendix D.1.1 above.",
      "ja": "このシナリオでは、サーバは、全体として制御することができる複数のストリームを有しています。この場合には、メディアレベルストリームのURIを指定するために使用される「=コントロール」属性、および集約制御のためのRequest-URIとして使用されるセッションレベル「=対照」属性の両方が存在します。メディアレベルURIは相対である場合、それは上記付録D.1.1に係る絶対URIに解決されます。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 3,
      "text": "C->M: DESCRIBE rtsp://example.com/movie RTSP/2.0 CSeq: 1 User-Agent: PhonyClient/1.2",
      "ja": "C-> M：RTSPを説明します。//example.com/movie RTSP / 2.0のCSeq：1つのUser-Agent：PhonyClient / 1.2"
    },
    {
      "indent": 3,
      "text": "M->C: RTSP/2.0 200 OK CSeq: 1 Date: Wed, 23 Jan 2013 15:36:52 +0000 Expires: Wed, 23 Jan 2013 16:36:52 +0000 Content-Type: application/sdp Content-Base: rtsp://example.com/movie/ Content-Length: 227",
      "ja": "M-> C：RTSP / 2.0 200 OKのCSeq：1日：水曜日、2013年1月23日午後3時36分52秒0000の有効期限：水を、2013年1月23日16時36分52秒0000のContent-Type：アプリケーション/ SDPのContentベース：RTSP：//example.com/movie/のContent-Length：227"
    },
    {
      "indent": 9,
      "text": "v=0\no=- 2890844256 2890842807 IN IP4 192.0.2.211\ns=I contain\ni=<more info>\ne=adm@example.com\nc=IN IP4 0.0.0.0\na=control:*\nt=0 0\nm=video 8002 RTP/AVP 31\na=control:trackID=1\nm=audio 8004 RTP/AVP 3\na=control:trackID=2",
      "raw": true
    },
    {
      "indent": 3,
      "text": "In this example, the client is recommended to establish a single RTSP session to the server, and it uses the URIs rtsp://example.com/movie/ trackID=1 and rtsp://example.com/movie/trackID=2 to set up the video and audio streams, respectively. The URI rtsp://example.com/movie/, which is resolved from the \"*\", controls the whole presentation (movie).",
      "ja": "この例では、クライアントはサーバーに、単一のRTSPセッションを確立することをお勧めします、そして、それはURIのがRTSPを使用しています。//example.com/movie/ trackID = 1およびRTSP：//example.com/movie/trackID=2それぞれ、ビデオとオーディオストリームを設定します。 URIのRTSP：「*」から解決され//example.com/movie/は、全体のプレゼンテーション（映画）を制御します。"
    },
    {
      "indent": 3,
      "text": "A client is not required to issue SETUP requests for all streams within an aggregate object. Servers should allow the client to ask for only a subset of the streams.",
      "ja": "クライアントは、集約オブジェクト内のすべてのストリームのためのSETUP要求を発行する必要はありません。サーバーは、クライアントがストリームのサブセットのみを求めるようにする必要があります。"
    },
    {
      "indent": 0,
      "text": "D.4. Grouping of Media Lines in SDP",
      "ja": "D.4。 SDPにおけるメディアラインのグループ化"
    },
    {
      "indent": 3,
      "text": "For some types of media, it is desirable to express a relationship between various media components, for instance, for lip synchronization or Scalable Video Codec (SVC) [RFC5583]. This relationship is expressed on the SDP level by grouping of media lines, as described in [RFC5888], and can be exposed to RTSP.",
      "ja": "メディアのいくつかのタイプのためには、リップシンクまたはスケーラブルビデオコーデック（SVC）[RFC5583]のために、例えば、様々なメディア構成要素間の関係を表現することが望ましいです。この関係は、[RFC5888]に記載されているように、メディア・ラインのグループ化によりSDPレベルで発現され、そしてRTSPに露出させることができます。"
    },
    {
      "indent": 3,
      "text": "For RTSP, it is mainly important to know how to handle grouped media received by means of SDP, i.e., if the media are under aggregate control (see Appendix D.3) or if aggregate control is not available (see Appendix D.2).",
      "ja": "RTSPのメディアが集約制御下にある場合、SDPの使用によって得られたグループ化されたメディア、すなわちを処理する方法を知って主に重要である（付録D.3を参照）または集約コントロールが利用できない場合（付録D.2を参照してください） 。"
    },
    {
      "indent": 3,
      "text": "It is RECOMMENDED that grouped media are handled by aggregate control, to give the client the ability to control either the whole presentation or single media.",
      "ja": "メディアをグループ化し、クライアントにプレゼンテーション全体または単一のメディアのいずれかを制御する機能を与えるために、集約コントロールによって処理されることをお勧めします。"
    },
    {
      "indent": 0,
      "text": "D.5. RTSP External SDP Delivery",
      "ja": "D.5。 RTSP外部SDP配信"
    },
    {
      "indent": 3,
      "text": "There are some considerations that need to be made when the session description is delivered to the client outside of RTSP, for example via HTTP or email.",
      "ja": "セッション記述は、HTTPまたは電子メールを介して、たとえば、RTSPの外のクライアントに配信されたときになされる必要があるいくつかの考慮事項があります。"
    },
    {
      "indent": 3,
      "text": "First of all, the SDP needs to contain absolute URIs, since relative will, in most cases, not work as the delivery will not correctly forward the base URI.",
      "ja": "まず第一に、SDPは、配信が正しくベースURIを転送しないので、ほとんどの場合、動作しない、相対的なので、絶対URIを含める必要があります。"
    },
    {
      "indent": 3,
      "text": "The writing of the SDP session availability information, i.e., \"t=\" and \"r=\", needs to be carefully considered. When the SDP is fetched by the DESCRIBE method, the probability that it is valid is very high. However, the same is much less certain for SDPs distributed using other methods. Therefore, the publisher of the SDP should take care to follow the recommendations about availability in the SDP specification [RFC4566] in Section 4.2.",
      "ja": "SDPセッションの可用性情報の書き込み、即ち、「T =」と「R =」は、慎重に検討する必要があります。 SDPは、DESCRIBE法によってフェッチされた場合、それが有効である確率は非常に高いです。しかし、同じことがはるかに少ない特定の他の方法を使用して分散のSDPのためのものです。したがって、SDPの発行者は、4.2節でSDP仕様[RFC4566]で可用性に関する勧告に従うように注意しなければなりません。"
    },
    {
      "indent": 0,
      "text": "Appendix E. RTSP Use Cases",
      "ja": "付録E. RTSPユースケース"
    },
    {
      "indent": 3,
      "text": "This appendix describes the most important and considered use cases for RTSP. They are listed in descending order of importance in regard to ensuring that all necessary functionality is present. This specification only fully supports usage of the two first. Also, in these first two cases, there are special cases or exceptions that are not supported without extensions, e.g., the redirection of media delivery to an address other than the controlling agent's (client's).",
      "ja": "この付録では、RTSPのために最も重要と考えられてユースケースを説明します。これらは、すべての必要な機能が存在することを確保する点で重要度の高い順に記載されています。この仕様は唯一の完全に最初の二つの使用をサポートしています。また、これらの最初の2つのケースで、拡張子なしでサポートされていない特殊なケースや例外がある、例えば、制御エージェントの（クライアント）以外のアドレスへのメディア配信のリダイレクト。"
    },
    {
      "indent": 0,
      "text": "E.1. On-Demand Playback of Stored Content",
      "ja": "E.1。保存されたコンテンツのオンデマンド再生"
    },
    {
      "indent": 3,
      "text": "An RTSP-capable server stores content suitable for being streamed to a client. A client desiring playback of any of the stored content uses RTSP to set up the media transport required to deliver the desired content. RTSP is then used to initiate, halt, and manipulate the actual transmission (playout) of the content. RTSP is also required to provide the necessary description and synchronization information for the content.",
      "ja": "クライアントにストリーミングされるのに適したRTSP対応のサーバーを格納したコンテンツ。保存されたコンテンツのいずれかの再生を希望するクライアントは所望のコンテンツを配信するために必要なメディアトランスポートを設定するためにRTSPを用います。 RTSPは、次に、開始、停止、及びコンテンツの実際の送信（再生）を操作するために使用されます。 RTSPは、コンテンツに必要な説明および同期情報を提供するために必要とされます。"
    },
    {
      "indent": 3,
      "text": "The above high-level description can be broken down into a number of functions of which RTSP needs to be capable.",
      "ja": "上記ハイレベルの記述は、RTSPを可能にする必要があるその機能の数に分けることができます。"
    },
    {
      "indent": 3,
      "text": "Presentation Description: Provide initialization information about the presentation (content); for example, which media codecs are needed for the content. Other information that is important includes the number of media streams the presentation contains, the transport protocols used for the media streams, and identifiers for these media streams. This information is required before setup of the content is possible and to determine if the client is even capable of using the content.",
      "ja": "プレゼンテーション記述：プレゼンテーション（コンテンツ）に関する初期化情報を提供します。例えば、どのメディアコーデックは、コンテンツのために必要とされます。重要である他の情報は、メディアの数がプレゼンテーションは、トランスポート・メディアストリームのために使用されるプロトコル、およびこれらのメディアストリームの識別子が含まれているストリームが含まれます。コンテンツの設定が可能であり、クライアントがコンテンツを利用しても可能であるかどうかを判断する前にこの情報が必要になります。"
    },
    {
      "indent": 9,
      "text": "This information need not be sent using RTSP; other external\nprotocols can be used to transmit the transport presentation\ndescriptions.  Two good examples are the use of HTTP [RFC7230]\nor email to fetch or receive presentation descriptions like SDP\n[RFC4566]",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Setup: Set up some or all of the media streams in a presentation. The setup itself consists of selecting the protocol for media transport and the necessary parameters for the protocol, like addresses and ports.",
      "ja": "セットアップ：プレゼンテーションのメディアストリームの一部またはすべてを設定します。設定自体は、アドレスとポートと同様に、メディアトランスポートプロトコルに必要なパラメータのためのプロトコルを選択することから成ります。"
    },
    {
      "indent": 3,
      "text": "Control of Transmission: After the necessary media streams have been established, the client can request the server to start transmitting the content. The client must be allowed to start or stop the transmission of the content at arbitrary times. The client must also be able to start the transmission at any point in the timeline of the presentation.",
      "ja": "変速機の制御：必要なメディアストリームが確立された後、クライアントはコンテンツの送信を開始するようにサーバに要求することができます。クライアントは、任意のタイミングでコンテンツの送信を開始または停止することが許されなければなりません。また、クライアントは、プレゼンテーションのタイムライン内の任意の時点で送信を開始することができなければなりません。"
    },
    {
      "indent": 3,
      "text": "Synchronization: For media-transport protocols like RTP [RFC3550], it might be beneficial to carry synchronization information within RTSP. This may be due to either the lack of inter-media synchronization within the protocol itself or the potential delay before the synchronization is established (which is the case for RTP when using RTCP).",
      "ja": "同期：RTP [RFC3550]のようなメディア・トランスポート・プロトコルでは、それはRTSP内の同期情報を運ぶために有益であるかもしれません。これは、プロトコル自体又は（RTCPを使用してRTPの場合である）、同期が確立される前に、潜在的な遅延内インターメディア同期の欠如のいずれかに起因し得ます。"
    },
    {
      "indent": 3,
      "text": "Termination: Terminate the established contexts.",
      "ja": "終了：確立したコンテキストを終了します。"
    },
    {
      "indent": 3,
      "text": "For this use case, there are a number of assumptions about how it works. These are:",
      "ja": "このユースケースについて、それがどのように動作するかについての仮定の数があります。これらは："
    },
    {
      "indent": 3,
      "text": "On-Demand content: The content is stored at the server and can be accessed at any time during a time period when it is intended to be available.",
      "ja": "オンデマンドコンテンツ：コンテンツはサーバに格納され、利用可能であることを意図している期間中にいつでもアクセスすることができます。"
    },
    {
      "indent": 3,
      "text": "Independent sessions: A server is capable of serving a number of clients simultaneously, including from the same piece of content at different points in that presentations timeline.",
      "ja": "独立セッション：サーバがそのプレゼンテーションタイムライン内の異なる点でのコンテンツの同じ部分からなど、同時にクライアントの数にサービスを提供することが可能です。"
    },
    {
      "indent": 3,
      "text": "Unicast Transport: Content for each individual client is transmitted to them using unicast traffic.",
      "ja": "ユニキャストトランスポート：個々のクライアントのためのコンテンツは、ユニキャストトラフィックを使用して、それらに送信されます。"
    },
    {
      "indent": 3,
      "text": "It is also possible to redirect the media traffic to a different destination than that of the agent controlling the traffic. However, allowing this without appropriate mechanisms for checking that the destination approves of this allows for Distributed DoS (DDoS).",
      "ja": "トラフィックを制御剤とは異なる宛先へのメディアトラフィックをリダイレクトすることも可能です。しかし、これは分散DoS攻撃（DDoS攻撃）を可能にするの宛先が承認することを確認するための適切なメカニズムなしでこれを可能にします。"
    },
    {
      "indent": 0,
      "text": "E.2. Unicast Distribution of Live Content",
      "ja": "E.2。ライブコンテンツのユニキャスト配信"
    },
    {
      "indent": 3,
      "text": "This use case is similar to the above on-demand content case (see Appendix E.1), the difference is the nature of the content itself. Live content is continuously distributed as it becomes available from a source; i.e., the main difference from on-demand is that one starts distributing content before the end of it has become available to the server.",
      "ja": "このユースケースは、（付録E.1を参照してください）上記のオンデマンドコンテンツの場合と同様で、違いは、コンテンツ自体の性質です。それはソースから利用可能になるようにライブコンテンツを連続的に分布しています。すなわち、オンデマンドからの主な違いは、それの終わりには、サーバに利用可能になる前に1がコンテンツを配信開始することです。"
    },
    {
      "indent": 3,
      "text": "In many cases, the consumer of live content is only interested in consuming what actually happens \"now\"; i.e., very similar to broadcast TV. However, in this case, it is assumed that there exists no broadcast or multicast channel to the users, and instead the server functions as a distribution node, sending the same content to multiple receivers, using unicast traffic between server and client. This unicast traffic and the transport parameters are individually negotiated for each receiving client.",
      "ja": "多くの場合、ライブコンテンツの消費者は実際には「今」何が起こるかを消費するだけに関心があります。つまり、テレビを放送するのは非常に似ています。しかし、この場合、サーバとクライアントの間でユニキャストトラフィックを使用して、複数の受信機に同じコンテンツを送信し、配信ノードとして存在ユーザへのブロードキャストまたはマルチキャストチャネルが存在せず、その代わりにサーバ機能と仮定する。このユニキャストトラフィックおよびトランスポートパラメータは、個別に各受信クライアントのために交渉されています。"
    },
    {
      "indent": 3,
      "text": "Another aspect of live content is that it often has a very limited time of availability, as it is only available for the duration of the event the content covers. An example of such live content could be a music concert that lasts two hours and starts at a predetermined time. Thus, there is a need to announce when and for how long the live content is available.",
      "ja": "ライブコンテンツのもう一つの側面は、コンテンツがカバーするイベントの期間のためにのみ利用可能であるとして、それは多くの場合、可用性の非常に限られた時間を持っていることです。そのようなライブコンテンツの例は、2つの時間持続し、所定の時刻に開始した音楽のコンサートである可能性があります。このように、ライブコンテンツが提供されていますどのくらいのために発表する必要があります。"
    },
    {
      "indent": 3,
      "text": "In some cases, the server providing live content may be saving some or all of the content to allow clients to pause the stream and resume it from the paused point, or to \"rewind\" and play continuously from a point earlier than the live point. Hence, this use case does not necessarily exclude playing from other than the live point of the stream, playing with scales other than 1.0, etc.",
      "ja": "いくつかのケースでは、ライブコンテンツを提供するサーバは、クライアントがストリームを一時停止し、一時停止地点からそれを再開、または「巻き戻し」とライブの点よりも点以前から連続して再生することができるようにするために、コンテンツの一部またはすべてを保存することができます。したがって、このユースケースは、必ずしもなど、1.0以外のスケールで遊んで、ストリームのライブポイント以外からの再生を排除するものではなく、"
    },
    {
      "indent": 0,
      "text": "E.3. On-Demand Playback Using Multicast",
      "ja": "E.3。オンデマンドマルチキャストを使用した再生"
    },
    {
      "indent": 3,
      "text": "It is possible to use RTSP to request that media be delivered to a multicast group. The entity setting up the session (the controller) will then control when and what media is delivered to the group. This use case has some potential for DoS attacks by flooding a multicast group. Therefore, a mechanism is needed to indicate that the group actually accepts the traffic from the RTSP server.",
      "ja": "メディアがマルチキャストグループに配信されることを要求するためにRTSPを使用することが可能です。セッション（コントローラ）を設定するエンティティは、ときにどのようなメディアグループに配信される制御します。このユースケースは、マルチキャストグループをフラッディングすることで、DoS攻撃のためのいくつかの可能性を秘めています。したがって、メカニズムは、グループが実際にRTSPサーバからのトラフィックを受け入れることを示すために必要とされています。"
    },
    {
      "indent": 3,
      "text": "An open issue in this use case is how one ensures that all receivers listening to the multicast or broadcast receives the session presentation configuring the receivers. This specification has to rely on an external solution to solve this issue.",
      "ja": "このユースケースでの未解決の問題は1つがマルチキャストまたはブロードキャストを聞いて、すべての受信機が受信機を構成するセッションプレゼンテーションを受けることを保証する方法です。この仕様は、この問題を解決するために、外部のソリューションに依存する必要があります。"
    },
    {
      "indent": 0,
      "text": "E.4. Inviting an RTSP Server into a Conference",
      "ja": "E.4。会議にRTSPサーバを招待する"
    },
    {
      "indent": 3,
      "text": "If one has an established conference or group session, it is possible to have an RTSP server distribute media to the whole group. Transmission to the group is simplest when controlled by a single participant or leader of the conference. Shared control might be possible, but would require further investigation and possibly extensions.",
      "ja": "1が確立会議やグループセッションを持っている場合、RTSPサーバは、グループ全体にメディアを配布することが可能です。会議の単一の参加者や指導者によって制御されるときに、グループへの送信が最も簡単です。共有制御が可能かもしれませんが、さらなる調査とおそらく拡張が必要となります。"
    },
    {
      "indent": 3,
      "text": "This use case assumes that there exists either a multicast or a conference focus that redistributes media to all participants.",
      "ja": "このユースケースは、マルチキャストまたはすべての参加者にメディアを再配布する会議の焦点のいずれかが存在することを前提としています。"
    },
    {
      "indent": 3,
      "text": "This use case is intended to be able to handle the following scenario: a conference leader or participant (hereafter called the \"controller\") has some pre-stored content on an RTSP server that he wants to share with the group. The controller sets up an RTSP session at the streaming server for this content and retrieves the session description for the content. The destination for the media content is set to the shared multicast group or conference focus. When desired by the controller, he/she can start and stop the transmission of the media to the conference group.",
      "ja": "このユースケースは、次のシナリオ扱うことができるように意図されています。会議のリーダーや参加者（以下、「コントローラ」と呼ばれる）彼はグループと共有したいRTSPサーバ上のいくつかの事前格納されたコンテンツを持っています。コントローラは、このコンテンツのストリーミングサーバにRTSPセッションを設定し、コンテンツのセッション記述を取得します。メディアコンテンツの送信先は、共有マルチキャスト・グループまたは会議フォーカスに設定されています。コントローラが希望する場合には、彼/彼女は会議グループにメディアの送信を開始し、停止することができます。"
    },
    {
      "indent": 3,
      "text": "There are several issues with this use case that are not solved by this core specification for RTSP:",
      "ja": "RTSPは、このコア仕様によって解決されていないこのユースケースにはいくつかの問題があります。"
    },
    {
      "indent": 3,
      "text": "DoS: To avoid an RTSP server from being an unknowing participant in a DoS attack, the server needs to be able to verify the destination's acceptance of the media. Such a mechanism to verify the approval of received media does not yet exist; instead, only policies can be used, which can be made to work in controlled environments.",
      "ja": "DoS攻撃は：DoS攻撃では知らない者であることからRTSPサーバを避けるために、サーバーは、メディアの移動先の受け入れを検証できるようにする必要があります。受信したメディアの承認を検証するような機構はまだ存在していません。代わりに、唯一のポリシーが制御された環境で動作するように作ることができる、使用することができます。"
    },
    {
      "indent": 3,
      "text": "Distributing the presentation description to all participants in the group: To enable a media receiver to correctly decode the content, the media configuration information needs to be distributed reliably to all participants. This will most likely require support from an external protocol.",
      "ja": "グループ内のすべての参加者にプレゼンテーション記述を配布：コンテンツを正しく復号化するために、メディアレシーバーを有効にするには、メディア構成情報は、すべての参加者に確実に配布する必要があります。これは、最も可能性の高い外部プロトコルからのサポートが必要になります。"
    },
    {
      "indent": 6,
      "text": "Passing control of the session: If it is desired to pass control of the RTSP session between the participants, some support will be required by an external protocol to exchange state information and possibly floor control of who is controlling the RTSP session.",
      "ja": "セッションの制御を渡す：参加者の間でRTSPセッションの制御を渡すことが望まれる場合、いくつかのサポートは、状態情報およびRTSPセッションを制御している人の可能性がフロア制御を交換するために外部のプロトコルによって必要とされるであろう。"
    },
    {
      "indent": 0,
      "text": "E.5. Live Content Using Multicast",
      "ja": "E.5。マルチキャストを使用したライブコンテンツ"
    },
    {
      "indent": 3,
      "text": "This use case in its simplest form does not require any use of RTSP at all; this is what multicast conferences being announced with SAP [RFC2974] and SDP are intended to handle. However, in use cases where more advanced features like access control to the multicast session are desired, RTSP could be used for session establishment.",
      "ja": "最も単純な形でこのユースケースは、すべてのRTSPのいずれかを使用する必要はありません。これは、マルチキャスト会議はSAP [RFC2974]で発表されているとSDPが扱うことを意図しているものです。しかし、マルチキャストセッションへのアクセス制御など、より高度な機能が所望されるユースケースでは、RTSPセッションの確立のために使用することができます。"
    },
    {
      "indent": 3,
      "text": "A client desiring to join a live multicasted media session with cryptographic (encryption) access control could use RTSP in the following way. The source of the session announces the session and gives all interested an RTSP URI. The client connects to the server and requests the presentation description, allowing configuration for reception of the media. In this step, it is possible for the client to use secured transport and any desired level of authentication; for example, for billing or access control. An RTSP link also allows for load balancing between multiple servers.",
      "ja": "暗号（暗号化）アクセス制御でライブマルチキャストメディアセッションに参加を希望するクライアントは、次のようにRTSPを使用することができます。セッションのソースは、セッションを発表し、すべての利害RTSP URIを与えます。クライアントがサーバーに接続し、メディアの受信のための構成が可能、プレゼンテーションの説明を要求します。クライアントは、保護されたトランスポートおよび認証の任意の所望のレベルを使用するため、このステップでは、それが可能です。例えば、課金やアクセス制御のため。 RTSPリンクは、複数のサーバー間で負荷分散が可能になります。"
    },
    {
      "indent": 3,
      "text": "If these were the only goals, they could be achieved by simply using HTTP. However, for cases where the sender likes to keep track of each individual receiver of a session, and possibly use the session as a side channel for distributing key-updates or other information on a per-receiver basis, and the full set of receivers is not known prior to the session start, the state establishment that RTSP provides can be beneficial. In this case, a client would establish an RTSP session for this multicast group with the RTSP server. The RTSP server will not transmit any media, but instead will point to the multicast group. The client and server will be able to keep the session alive for as long as the receiver participates in the session thus enabling, for example, the server to push updates to the client.",
      "ja": "これらは唯一の目標であれば、彼らは単にHTTPを使用することによって達成することができました。しかし、送信者は、セッションの各個々の受信機を追跡し、そしておそらく毎レシーバ基づいてキー更新やその他の情報を配布するためのサイドチャネルとしてセッションを使用するのが好き、そして受信機のフルセットである場合の前のセッションの開始に知られていない、RTSPが提供する状態の確立は有益であり得ます。この場合、クライアントは、RTSPサーバと、このマルチキャストグループのRTSPセッションを確立します。 RTSPサーバは、任意のメディアを送信しませんが、代わりにマルチキャストグループを指します。クライアントとサーバは限り受信機は、このように、たとえば、サーバがクライアントに更新をプッシュする、有効セッションに参加するよう生きセッションを維持することができるようになります。"
    },
    {
      "indent": 3,
      "text": "This use case will most likely not be able to be implemented without some extensions to the server-to-client push mechanism. Here the PLAY_NOTIFY method (see Section 13.5) with a suitable extension could provide clear benefits.",
      "ja": "このユースケースは、ほとんどの場合、サーバーからクライアントへのプッシュ機構にいくつかの拡張せずに実装することができなくなります。ここでは、適切な拡張子を持つPLAY_NOTIFY方法は、（13.5節を参照）明確な利点を提供することができます。"
    },
    {
      "indent": 0,
      "text": "Appendix F. Text Format for Parameters",
      "ja": "パラメータの付録F.テキスト形式"
    },
    {
      "indent": 3,
      "text": "A resource of type \"text/parameters\" consists of either 1) a list of parameters (for a query) or 2) a list of parameters and associated values (for a response or setting of the parameter). Each entry of the list is a single line of text. Parameters are separated from values by a colon. The parameter name MUST only use US-ASCII visible characters while the values are UTF-8 text strings. The media type registration form is in Section 22.16.",
      "ja": "「テキスト/パラメータ」タイプのリソースは、クエリのパラメータのいずれか1）リスト（）またはパラメータ及び応答又はパラメータの設定）のために関連付けられた値（2）リストからなります。リストの各エントリは、テキストの一行です。パラメータはコロンで値から分離されています。値はUTF-8のテキスト文字列である一方、パラメータ名はUS-ASCII見える文字を使用しなければなりません。メディアタイプの登録フォームは、セクション22.16です。"
    },
    {
      "indent": 3,
      "text": "There is a potential interoperability issue for this format. It was named in RFC 2326 but never defined, even if used in examples that hint at the syntax. This format matches the purpose and its syntax supports the examples provided. However, it goes further by allowing UTF-8 in the value part; thus, usage of UTF-8 strings may not be supported. However, as individual parameters are not defined, the implementing application needs to have out-of-band agreement or using feature tag anyway to determine if the endpoint supports the parameters.",
      "ja": "この形式の潜在的な相互運用性の問題があります。これは、構文のヒントの例で使用した場合でも、RFC 2326で指定されたが、定義されていませんでした。この形式は、目的と一致し、その構文が提供されている例をサポートしています。しかし、それは価値の一部でUTF-8を可能にすることにより、さらに進んで、このように、UTF-8文字列の使用はサポートされない場合があります。個々のパラメータが定義されていないしかし、実装するアプリケーションは、アウトオブバンドの合意を持っている必要がありますまたはエンドポイントがパラメータをサポートしているかどうかを判断するために、とにかく機能タグを使用して。"
    },
    {
      "indent": 3,
      "text": "The ABNF [RFC5234] grammar for \"text/parameters\" content is:",
      "ja": "「テキスト/パラメータ」コンテンツのABNF [RFC5234]の文法は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "file = *((parameter / parameter-value) CRLF) parameter = 1*visible-except-colon parameter-value = parameter *WSP \":\" value visible-except-colon = %x21-39 / %x3B-7E ; VCHAR - \":\" value = *(TEXT-UTF8char / WSP) TEXT-UTF8char = <as defined in Section 20.1> WSP = <See RFC 5234> ; Space or HTAB VCHAR = <See RFC 5234> CRLF = <See RFC 5234>",
      "ja": "ファイル= *（（パラメータ/パラメータ値）CRLF）パラメータ= 1 *可視以外コロンパラメータ値=パラメーター* WSP \"：\" 可視以外コロン=％x21-39 /％X3B-7E値。 VCHAR  -  \"：\" <セクション20.1で定義されるように>値= *（TEXT-UTF8char / WSP）TEXT-UTF8char = WSP = <RFC 5234を参照>。スペースやHTAB VCHAR = CRLF = <RFC 5234を参照してください>を<RFC 5234を参照してください>"
    },
    {
      "indent": 0,
      "text": "Appendix G. Requirements for Unreliable Transport of RTSP",
      "ja": "RTSPの信頼性の低い輸送のための付録G.要件"
    },
    {
      "indent": 3,
      "text": "This appendix provides guidance for those who want to implement RTSP messages over unreliable transports as has been defined in RTSP 1.0 [RFC2326]. RFC 2326 defined the \"rtspu\" URI scheme and provided some basic information for the transport of RTSP messages over UDP. The information is being provided here as there has been at least one commercial implementation and compatibility with that should be maintained.",
      "ja": "この付録では、RTSP 1.0 [RFC2326]で定義されているように信頼性の低いトランスポート上でRTSPメッセージを実装したい人のためのガイダンスを提供します。 RFC 2326には、「RTSPU」URIスキームを定義し、UDP上でRTSPメッセージの輸送のためのいくつかの基本的な情報を提供しました。それと少なくとも一つの商業的実装と互換性が維持されるべきであったような情報は、ここで提供されています。"
    },
    {
      "indent": 3,
      "text": "The following points should be considered for an interoperable implementation:",
      "ja": "次のポイントは、相互運用可能な実装のために考慮されるべきです。"
    },
    {
      "indent": 3,
      "text": "o Requests shall be acknowledged by the receiver. If there is no acknowledgement, the sender may resend the same message after a timeout of one round-trip time (RTT). Any retransmissions due to lack of acknowledgement must carry the same sequence number as the original request.",
      "ja": "O要求は、受信機によって認められるものとします。肯定応答がない場合、送信者は1ラウンドトリップ時間（RTT）のタイムアウト後に同じメッセージを再送信することができます。確認応答の欠如に起因する任意の再送信は、元の要求と同じシーケンス番号を運ばなければなりません。"
    },
    {
      "indent": 3,
      "text": "o The RTT can be estimated as in TCP (RFC 6298) [RFC6298], with an initial round-trip value of 500 ms. An implementation may cache the last RTT measurement as the initial value for future connections.",
      "ja": "O RTTが500ミリ秒の初期ラウンドトリップ値で、TCP（RFC 6298）[RFC6298]のように推定することができます。実装は将来の接続のための初期値として最後のRTT測定をキャッシュすることができます。"
    },
    {
      "indent": 3,
      "text": "o The Timestamp header (Section 18.53) is used to avoid the retransmission ambiguity problem [Stevens98].",
      "ja": "タイムスタンプ・ヘッダ（セクション18.53）O再送曖昧性の問題[Stevens98]を回避するために使用されます。"
    },
    {
      "indent": 3,
      "text": "o The registered default port for RTSP over UDP for the server is 554.",
      "ja": "OサーバのUDP上でRTSPのための登録されているデフォルトのポートは554です。"
    },
    {
      "indent": 3,
      "text": "o RTSP messages can be carried over any lower-layer transport protocol that is 8-bit clean.",
      "ja": "O RTSPメッセージは、8ビットクリーンである任意の下層のトランスポートプロトコルを介して行うことができます。"
    },
    {
      "indent": 3,
      "text": "o RTSP messages are vulnerable to bit errors and should not be subjected to them.",
      "ja": "O RTSPメッセージは、ビットエラーに対して脆弱であり、それらを受けるべきではありません。"
    },
    {
      "indent": 3,
      "text": "o Source authentication, or at least validation that RTSP messages comes from the same entity becomes extremely important, as session hijacking may be substantially easier for RTSP message transport using an unreliable protocol like UDP than for TCP.",
      "ja": "セッションハイジャックがTCPよりもUDPのような信頼性のないプロトコルを使用してRTSPメッセージ・トランスポートのために、実質的に容易になり得るようなO RTSPメッセージが同じエンティティから来ているソース認証、または少なくとも検証は、非常に重要になります。"
    },
    {
      "indent": 3,
      "text": "There are two RTSP headers that are primarily intended for being used by the unreliable handling of RTSP messages and which will be maintained:",
      "ja": "主に維持され、RTSPメッセージの信頼性のないハンドリングで使用されているために意図されている2つのRTSPヘッダがあります。"
    },
    {
      "indent": 3,
      "text": "o CSeq: See Section 18.20. It should be noted that the CSeq header is also required to match requests and responses independent whether a reliable or unreliable transport is used.",
      "ja": "OのCSeq：セクション18.20を参照してください。のCSeqヘッダはまた、信頼性や信頼性のないトランスポートが使用されているかどうかの独立した要求と応答を一致させるために必要とされることに留意すべきです。"
    },
    {
      "indent": 3,
      "text": "o Timestamp: See Section 18.53",
      "ja": "Oタイムスタンプ：セクション18.53を参照してください。"
    },
    {
      "indent": 0,
      "text": "Appendix H. Backwards-Compatibility Considerations",
      "ja": "付録H.後方互換性に関する注意事項"
    },
    {
      "indent": 3,
      "text": "This section contains notes on issues about backwards compatibility with clients or servers being implemented according to RFC 2326 [RFC2326]. Note that there exists no requirement to implement RTSP 1.0; in fact, this document recommends against it as it is difficult to do in an interoperable way.",
      "ja": "このセクションでは、RFC 2326 [RFC2326]に従って実装されているクライアントまたはサーバとの後方互換性に関する問題についての注意事項が含まれています。 RTSP 1.0を実装するという要件が存在しないことに注意してください。相互運用可能な方法で行うことは困難であるとして、実際には、この文書はそれに対してお勧めします。"
    },
    {
      "indent": 3,
      "text": "A server implementing RTSP 2.0 MUST include an RTSP-Version of \"RTSP/2.0\" in all responses to requests containing RTSP-Version value of \"RTSP/2.0\". If a server receives an RTSP 1.0 request, it MAY respond with an RTSP 1.0 response if it chooses to support RFC 2326. If the server chooses not to support RFC 2326, it MUST respond with a 505 (RTSP Version Not Supported) status code. A server MUST NOT respond to an RTSP 1.0 request with an RTSP 2.0 response.",
      "ja": "RTSP 2.0を実装するサーバは、「RTSP / 2.0」のRTSP-バージョン値を含むリクエストに対するすべての応答で「RTSP / 2.0」のRTSP-バージョンを含まなければなりません。サーバーは、RTSP 1.0リクエストを受信した場合、それはRFC 2326をサポートすることを選択した場合、サーバーがRFC 2326をサポートしないことを選択した場合、それは505（RTSPバージョンサポートされていない）ステータスコードで応じなければなりませんRTSP 1.0応答で応答することができます。サーバは、RTSP 2.0応答でRTSP 1.0の要求に応じてはいけません。"
    },
    {
      "indent": 3,
      "text": "Clients implementing RTSP 2.0 MAY use an OPTIONS request with an RTSP-Version of \"RTSP/2.0\" to determine whether a server supports RTSP 2.0. If the server responds with either an RTSP-Version of \"RTSP/1.0\" or a status code of 505 (RTSP Version Not Supported), the client will have to use RTSP 1.0 requests if it chooses to support RFC 2326.",
      "ja": "RTSP 2.0を実装するクライアントは、サーバーがRTSP 2.0をサポートしているかどうかを判断するために、「RTSP / 2.0」のRTSP-バージョンを要求するオプションを使用するかもしれません。サーバは、「RTSP / 1.0」または505のステータスコード（RTSPバージョンがサポートされていない）のRTSP-バージョンのいずれかで応答した場合、クライアントはRFC 2326をサポートすることを選択した場合RTSP 1.0の要求を使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "H.1. Play Request in Play State",
      "ja": "H.1。再生状態で要求を再生"
    },
    {
      "indent": 3,
      "text": "The behavior in the server when a Play is received in Play state has changed (Section 13.4). In RFC 2326, the new PLAY request would be queued until the current Play completed. Any new PLAY request now takes effect immediately replacing the previous request.",
      "ja": "プレイはプレイ状態で受信されているサーバでの動作は（13.4節）を変更しました。現在のプレイが完了するまで、RFC 2326で、新しいPLAY要求がキューに入れられます。すべての新しいPLAY要求は現在、直前の要求を置き換える有効になります。"
    },
    {
      "indent": 0,
      "text": "H.2. Using Persistent Connections",
      "ja": "H.2。持続的接続を使用"
    },
    {
      "indent": 3,
      "text": "Some server implementations of RFC 2326 maintain a one-to-one relationship between a connection and an RTSP session. Such implementations require clients to use a persistent connection to communicate with the server and when a client closes its connection, the server may remove the RTSP session. This is worth noting if an RTSP 2.0 client also supporting 1.0 connects to a 1.0 server.",
      "ja": "RFC 2326の一部のサーバーの実装は、接続およびRTSPセッションの間に1対1の関係を維持します。このような実装は、サーバとクライアントが接続を閉じたときに、サーバーがRTSPセッションを削除することができると通信するために持続的な接続を使用するようにクライアントを必要としています。また、1.0をサポートするRTSP 2.0クライアントが1.0サーバに接続する場合、これは注目に値します。"
    },
    {
      "indent": 0,
      "text": "Appendix I. Changes",
      "ja": "付録I.変更"
    },
    {
      "indent": 3,
      "text": "This appendix briefly lists the differences between RTSP 1.0 [RFC2326] and RTSP 2.0 for an informational purpose. For implementers of RTSP 2.0, it is recommended to read carefully through this memo and not to rely on the list of changes below to adapt from RTSP 1.0 to RTSP 2.0, as RTSP 2.0 is not intended to be backwards compatible with RTSP 1.0 [RFC2326] other than the version negotiation mechanism.",
      "ja": "この付録では、簡単に情報提供の目的のためにRTSP 1.0 [RFC2326]とRTSP 2.0との違いを示しています。 RTSP 2.0は、RTSP 1.0 [RFC2326]との下位互換性があるように意図されていないとして、RTSP 2.0の実装のためには、このメモを通じて慎重に読み取り、RTSP 2.0にRTSP 1.0から適応するために、次の変更点のリストに依存しないことをお勧めしますバージョン交渉メカニズム以外。"
    },
    {
      "indent": 0,
      "text": "I.1. Brief Overview",
      "ja": "I.1。簡単な概要"
    },
    {
      "indent": 3,
      "text": "The following protocol elements were removed in RTSP 2.0 compared to RTSP 1.0:",
      "ja": "以下のプロトコル要素は、RTSP 1.0に比べRTSP 2.0で除去しました。"
    },
    {
      "indent": 3,
      "text": "o the RECORD and ANNOUNCE methods and all related functionality (including 201 (Created) and 250 (Low On Storage Space) status codes);",
      "ja": "RECORD Oおよび方法（ステータスコード）ストレージ領域が少ない（201（作成される）と250を含む）すべての関連する機能を発表。"
    },
    {
      "indent": 3,
      "text": "o the use of UDP for RTSP message transport (due to missing interest and to broken specification);",
      "ja": "RTSPメッセージトランスポートのためにUDPを使用する（これは欠落関心および仕様を破壊する）O。"
    },
    {
      "indent": 3,
      "text": "o the use of PLAY method for keep-alive in Play state.",
      "ja": "キープアライブプレイ状態のためのPLAYメソッドを使用するO。"
    },
    {
      "indent": 3,
      "text": "The following protocol elements were added or changed in RTSP 2.0 compared to RTSP 1.0:",
      "ja": "以下のプロトコル要素は、RTSP 1.0に比べRTSP 2.0で追加または変更されました。"
    },
    {
      "indent": 3,
      "text": "o RTSP session TEARDOWN from the server to the client;",
      "ja": "OサーバーからクライアントへのRTSPセッションTEARDOWN。"
    },
    {
      "indent": 3,
      "text": "o IPv6 support;",
      "ja": "O IPv6のサポート。"
    },
    {
      "indent": 3,
      "text": "o extended IANA registries (e.g., transport headers parameters, transport-protocol, profile, lower-transport, and mode);",
      "ja": "O拡張IANAレジストリ（例えば、トランスポート・ヘッダパラメータ、トランスポートプロトコル、プロファイル、低い輸送、およびモード）。"
    },
    {
      "indent": 3,
      "text": "o request pipelining for quick session start-up;",
      "ja": "クイック・セッション起動のためのO要求パイプライン;"
    },
    {
      "indent": 3,
      "text": "o fully reworked state machine;",
      "ja": "O完全に書き直さステートマシン。"
    },
    {
      "indent": 3,
      "text": "o RTSP messages now use URIs rather than URLs;",
      "ja": "O RTSPメッセージは現在のURLではなくURIを使用します。"
    },
    {
      "indent": 3,
      "text": "o incorporated much of related HTTP text ([RFC2616]) in this memo, compared to just referencing the sections in HTTP, to avoid ambiguities;",
      "ja": "Oだけあいまいさを避けるために、HTTPのセクションを参照に比べて、このメモの関連HTTPテキスト（[RFC2616]）の多くを取り入れ。"
    },
    {
      "indent": 3,
      "text": "o the REDIRECT method was expanded and diversified for different situations;",
      "ja": "O REDIRECT方法は拡大し、さまざまな状況のために多様化しました。"
    },
    {
      "indent": 3,
      "text": "o Includes a new section about how to set up different media-transport alternatives and their profiles in addition to lower-layer protocols. This caused the appendix on RTP interaction to be moved to the new section instead of being in the part that describes RTP. The section also includes guidelines what to consider when writing usage guidelines for new protocols and profiles;",
      "ja": "oは異なるメディア輸送の代替と下位層プロトコルに加えて、自分のプロファイルを設定する方法についての新しいセクションが含まれています。これは、RTPの相互作用に関する付録ではなく、RTPを記述部分であることの新しいセクションに移動させ。セクションには、新しいプロトコルおよびプロファイルの使用ガイドラインを書くときに考慮すべきどのようなガイドラインを含み;"
    },
    {
      "indent": 3,
      "text": "o Added an asynchronous notification method PLAY_NOTIFY. This method is used by the RTSP server to asynchronously notify clients about session changes while in Play state. To a limited extent, this is comparable with some implementations of ANNOUNCE in RTSP 1.0 not intended for Recording.",
      "ja": "O非同期通知方法PLAY_NOTIFYを追加しました。このメソッドは非同期プレイ状態にしながら、セッションの変更についてクライアントに通知するためにRTSPサーバで使用されています。限られた範囲で、これはRTSP ANNOUNCE 1.0に記録するためのものではないのいくつかの実装に匹敵します。"
    },
    {
      "indent": 0,
      "text": "I.2. Detailed List of Changes",
      "ja": "I.2。変更点の詳細なリスト"
    },
    {
      "indent": 3,
      "text": "The below changes have been made to RTSP 1.0 (RFC 2326) when defining RTSP 2.0. Note that this list does not reflect minor changes in wording or correction of typographical errors.",
      "ja": "RTSP 2.0定義するときに以下の変更は、RTSP 1.0（RF​​C 2326）になされています。このリストは、言葉遣いや誤植の訂正の小さな変化を反映していないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "o The section on minimal implementation was deleted. Instead, the main part of the specification defines the core of RTSP 2.0.",
      "ja": "O最小限の実装上の部分が削除されました。代わりに、仕様の主要部分は、RTSP 2.0のコアを定義します。"
    },
    {
      "indent": 3,
      "text": "o The Transport header has been changed in the following ways:",
      "ja": "Oトランスポートヘッダは、次のように変更されています。"
    },
    {
      "indent": 6,
      "text": "* The ABNF has been changed to define that extensions are possible and that unknown parameters result in servers ignoring the transport specification.",
      "ja": "* ABNFは拡張が可能であることは、未知のパラメータは、トランスポート仕様を無視して、サーバになることを定義するために変更されました。"
    },
    {
      "indent": 6,
      "text": "* To prevent backwards compatibility issues, any extension or new parameter requires the usage of a feature tag combined with the Require header.",
      "ja": "*互換性の問題を後方に防止するために、任意の拡張子または新しいパラメータが必要とヘッダと組み合わされた特徴タグの使用を必要とします。"
    },
    {
      "indent": 6,
      "text": "* Syntax ambiguities with the Mode parameter have been resolved.",
      "ja": "* Modeパラメータと構文の曖昧さが解決されました。"
    },
    {
      "indent": 6,
      "text": "* Syntax error with \";\" for multicast and unicast has been resolved.",
      "ja": "と*構文エラー「;」マルチキャストとユニキャストのために解決されました。"
    },
    {
      "indent": 6,
      "text": "* Two new addressing parameters have been defined: src_addr and dest_addr. These replace the parameters \"port\", \"client_port\", \"server_port\", \"destination\", and \"source\".",
      "ja": "*二つの新しいアドレス指定のパラメータが定義されていますsrc_addrをとdest_addrはを。これらは、パラメータ「ポート」、「CLIENT_PORT」、「SERVER_PORT」、「宛先」、および「ソース」を交換してください。"
    },
    {
      "indent": 6,
      "text": "* Support for IPv6 explicit addresses in all address fields has been included.",
      "ja": "*すべてのアドレスフィールド内のIPv6明示アドレスのサポートが含まれています。"
    },
    {
      "indent": 6,
      "text": "* To handle URI definitions that contain \";\" or \",\", a quoted-URI format has been introduced and is required.",
      "ja": "*含まれているURIの定義を処理するには、「;」または「」、引用され-URIフォーマットが導入されており、必要になります。"
    },
    {
      "indent": 6,
      "text": "* IANA registries for the transport header parameters, transport-protocol, profile, lower-transport, and mode have been defined.",
      "ja": "*転送ヘッダパラメータ、トランスポートプロトコル、プロファイル、低い輸送、およびモードのためのIANAレジストリに定義されています。"
    },
    {
      "indent": 6,
      "text": "* The Transport header's interleaved parameter's text was made more strict and uses formal requirements levels. It was also clarified that the interleaved channels are symmetric and that it is the server that sets the channel numbers.",
      "ja": "*トランスポートヘッダーのインターリーブされたパラメータのテキストは、より厳密に行われ、正式な要件のレベルを使用しました。また、インターリーブされたチャネルが対称であり、それはチャンネル番号を設定し、サーバであることが明らかになりました。"
    },
    {
      "indent": 6,
      "text": "* It has been clarified that the client can't request of the server to use a certain RTP SSRC, using a request with the transport parameter SSRC.",
      "ja": "*クライアントがトランスポート・パラメータSSRCとの要求を使用して、特定のRTP SSRCを使用するようにサーバーを要求しないことを明らかにされています。"
    },
    {
      "indent": 6,
      "text": "* Syntax definition for SSRC has been clarified to require 8HEX. It has also been extended to allow multiple values for clients supporting this version.",
      "ja": "* SSRCのための構文定義は8HEXを必要とするように明らかにされています。また、このバージョンをサポートしているクライアントに対して複数の値を許可するように拡張されました。"
    },
    {
      "indent": 6,
      "text": "* Clarified the text on the Transport header's \"dest_addr\" parameters regarding what security precautions the server is required to perform.",
      "ja": "*セキュリティ対策サーバーを実行するために必要なものについて、トランスポートヘッダの「dest_addrは」パラメータのテキストを明確化。"
    },
    {
      "indent": 3,
      "text": "o The Range formats have been changed in the following way:",
      "ja": "Oレンジフォーマットは次のように変更されました。"
    },
    {
      "indent": 6,
      "text": "* The NPT format has been given an initial NPT identifier that must now be used.",
      "ja": "* NPT形式は現在使用されている必要があり、最初のNPT識別子を与えられています。"
    },
    {
      "indent": 6,
      "text": "* All formats now support initial open-ended formats of type \"npt=-10\" and also format only \"Range: smpte\" ranges for usage with GET_PARAMETER requests.",
      "ja": "*すべてのフォーマットは、今のタイプの最初のオープンエンドフォーマットをサポートし、また、唯一のフォーマット「= -10 NPT」「範囲：SMPTE」GET_PARAMETER要求に使用するための範囲です。"
    },
    {
      "indent": 6,
      "text": "* The npt-hhmmss notation now follows ISO 8601 more strictly.",
      "ja": "* NPT-HHMMSS表記は、今より厳密にISO 8601に従っています。"
    },
    {
      "indent": 3,
      "text": "o RTSP message handling has been changed in the following ways:",
      "ja": "O RTSPメッセージの取り扱いは、次のように変更されました："
    },
    {
      "indent": 6,
      "text": "* RTSP messages now use URIs rather than URLs.",
      "ja": "* RTSPメッセージは現在のURIではなく、URLを使用します。"
    },
    {
      "indent": 6,
      "text": "* It has been clarified that a 4xx message due to a missing CSeq header shall be returned without a CSeq header.",
      "ja": "*行方不明のCSeqヘッダによる4xxのメッセージがのCSeqヘッダーなしで返却されなければならないことが明らかとなりました。"
    },
    {
      "indent": 6,
      "text": "* The 300 (Multiple Choices) response code has been removed.",
      "ja": "* 300（複数の選択肢）応答コードが除去されています。"
    },
    {
      "indent": 6,
      "text": "* Rules for how to handle the timing out RTSP messages have been added.",
      "ja": "* RTSPメッセージをタイミングをどのように扱うかのルールが追加されました。"
    },
    {
      "indent": 6,
      "text": "* Extended Pipelining rules allowing for quick session startup.",
      "ja": "*迅速なセッション起動を可能に拡張パイプラインルール。"
    },
    {
      "indent": 6,
      "text": "* Sequence numbering and proxy handling of sequence numbers have been defined, including cases when responses arrive out of order.",
      "ja": "*シーケンス番号とシーケンス番号のプロキシ処理は応答が順不同で到着した場合を含む、定義されています。"
    },
    {
      "indent": 3,
      "text": "o The HTTP references have been updated to first RFCs 2616 and 2617 and then to RFC 7230-7235. Most of the text has been copied and then altered to fit RTSP into this specification. The Public and the Content-Base headers have also been imported from RFC 2068 so that they are defined in the RTSP specification. Known effects on RTSP due to HTTP clarifications:",
      "ja": "HTTP参照oを最初のRFC 2616および2617にして、RFC 7230から7235に更新されました。テキストの大半がコピーされ、その後、この仕様にRTSPに合うように変更されています。それらはRTSP仕様で定義されているように、公共およびContent-ベースのヘッダはまた、RFC 2068から輸入されています。 HTTPの明確化のためにRTSP上の既知の影響："
    },
    {
      "indent": 6,
      "text": "* Content-Encoding header can include encoding of type \"identity\".",
      "ja": "*のContent-Encodingヘッダは、タイプ「アイデンティティ」のエンコーディングを含めることができます。"
    },
    {
      "indent": 3,
      "text": "o The state machine section has been completely rewritten. It now includes more details and is also more clear about the model used.",
      "ja": "O状態機械部が完全に書き直されています。それは今の詳細を含み、また使用モデルの詳細は明らかです。"
    },
    {
      "indent": 3,
      "text": "o An IANA section has been included that contains a number of registries and their rules. This will allow us to use IANA to keep track of RTSP extensions.",
      "ja": "O IANAのセクションでは、レジストリとそのルールの数が含まれて含まれています。これは、私たちはRTSP拡張を追跡するためにIANAを使用できるようになります。"
    },
    {
      "indent": 3,
      "text": "o The transport of RTSP messages has seen the following changes:",
      "ja": "O RTSPメッセージの輸送には、以下の変更を見ています："
    },
    {
      "indent": 6,
      "text": "* The use of UDP for RTSP message transport has been deprecated due to missing interest and to broken specification.",
      "ja": "* RTSPメッセージトランスポートのためのUDPの使用は、行方不明の関心に廃止され、仕様が壊れします。"
    },
    {
      "indent": 6,
      "text": "* The rules for how TCP connections are to be handled have been clarified. Now it is made clear that servers should not close the TCP connection unless they have been unused for significant time.",
      "ja": "* TCP接続がどのように扱われるかについての規則は明らかにされています。今では、彼らはかなりの時間のために未使用されていない限り、サーバーは、TCP接続を閉じるべきではないことを明らかにしています。"
    },
    {
      "indent": 6,
      "text": "* Strong recommendations why servers and clients should use persistent connections have also been added.",
      "ja": "*サーバーとクライアントが持続的接続を使用する必要がありますなぜ強い推薦も追加されています。"
    },
    {
      "indent": 6,
      "text": "* There is now a requirement on the servers to handle non-persistent connections as this provides fault tolerance.",
      "ja": "*これは、フォールトトレランスを提供するので、非持続的な接続を処理するために、サーバー上の要件が用意されました。"
    },
    {
      "indent": 6,
      "text": "* Added wording on the usage of Connection:Close for RTSP.",
      "ja": "RTSPのためのクローズ：*接続の使用上の文言を追加しました。"
    },
    {
      "indent": 6,
      "text": "* Specified usage of TLS for RTSP messages, including a scheme to approve a proxy's TLS connection to the next hop.",
      "ja": "*次のホップへのプロキシのTLS接続を承認する方式を含むRTSPメッセージ、のためのTLSの指定された使用。"
    },
    {
      "indent": 3,
      "text": "o The following header-related changes have been made:",
      "ja": "O次のヘッダー関連の変更がなされてきました。"
    },
    {
      "indent": 6,
      "text": "* Accept-Ranges response-header has been added. This header clarifies which range formats can be used for a resource.",
      "ja": "*レスポンスヘッダが付加された受け入れ-の範囲です。このヘッダは、範囲フォーマットはリソースのために使用することができる明確。"
    },
    {
      "indent": 6,
      "text": "* Fixed the missing definitions for the Cache-Control header. Also added to the syntax definition the missing delta-seconds for max-stale and min-fresh parameters.",
      "ja": "*のCache-Controlヘッダの欠落の定義を修正しました。また、最大 - 古いと分の新鮮なパラメータの構文定義行方不明デルタ秒に加えます。"
    },
    {
      "indent": 6,
      "text": "* Put requirement on CSeq header that the value is increased by one for each new RTSP request. A recommendation to start at 0 has also been added.",
      "ja": "*値は、それぞれの新しいRTSP要求に対して1だけ増加さのCSeqヘッダに置く要件。 0で開始するための推奨事項も追加されました。"
    },
    {
      "indent": 6,
      "text": "* Added a requirement that the Date header must be used for all messages with a message body and the Server should always include it.",
      "ja": "*日付ヘッダがメッセージ本文とサーバーは常にそれを含めるべきであるとのすべてのメッセージに使用されなければならないという要件を追加しました。"
    },
    {
      "indent": 6,
      "text": "* Removed the possibility of using Range header with Scale header to indicate when it is to be activated, since it can't work as defined. Also, added a rule that lack of Scale header in a response indicates lack of support for the header. feature tags for scaled playback have been defined.",
      "ja": "*が活性化するとき定義されるようにそれが動作することができないので、示すためにスケールヘッダでRangeヘッダを使用する可能性を削除。また、ヘッダのためのサポートの欠如を示す応答におけるスケールヘッダの欠如ルールを追加しました。スケーリングされた再生のための機能のタグが定義されています。"
    },
    {
      "indent": 6,
      "text": "* The Speed header must now be responded to in order to indicate support and the actual speed going to be used. A feature tag is defined. Notes on congestion control were also added.",
      "ja": "*スピードヘッダーは現在サポートして使用されることになる実際の速度を示すためにに対応しなければなりません。フィーチャータグが定義されます。輻輳制御上の注意事項も追加されました。"
    },
    {
      "indent": 6,
      "text": "* The Supported header was borrowed from SIP [RFC3261] to help with the feature negotiation in RTSP.",
      "ja": "*サポートされているヘッダは、RTSPでの特徴交渉を支援するSIP [RFC3261]から借りました。"
    },
    {
      "indent": 6,
      "text": "* Clarified that the Timestamp header can be used to resolve retransmission ambiguities.",
      "ja": "*タイムスタンプヘッダーが再送あいまいさを解決するために使用することができることを明らかにしました。"
    },
    {
      "indent": 6,
      "text": "* The Session header text has been expanded with an explanation on keep-alive and which methods to use. SET_PARAMETER is now recommended to use if only keep-alive within RTSP is desired.",
      "ja": "*セッションヘッダーテキストを使用するためのキープアライブや方法の説明と拡張されました。 SET_PARAMETERは今だけキープアライブRTSP内が所望される場合に使用することをお勧めします。"
    },
    {
      "indent": 6,
      "text": "* It has been clarified how the Range header formats are used to indicate pause points in the PAUSE response.",
      "ja": "* RangeヘッダフォーマットがPAUSE応答に一時停止点を示すために使用される方法を明らかにされています。"
    },
    {
      "indent": 6,
      "text": "* Clarified that RTP-Info URIs that are relative use the Request-URI as base URI. Also clarified that the used URI must be the one that was used in the SETUP request. The URIs are now also",
      "ja": "*ベースURIとしてのRequest-URIを使用して相対的であることRTP-情報のURIことを明らかにしました。また、使用URIがSETUP要求で使用したものでなければならないことを明らかにしました。 URIは今でもあります"
    },
    {
      "indent": 9,
      "text": "required to be quoted. The header also expresses the SSRC for the provided RTP timestamp and sequence number values.",
      "ja": "引用されるために必要。ヘッダも提供RTPタイムスタンプとシーケンス番号値のSSRCを表します。"
    },
    {
      "indent": 6,
      "text": "* Added text that requires the Range to always be present in PLAY responses. Clarified what should be sent in case of live streams.",
      "ja": "*必ずPLAY応答中に存在する範囲を必要とテキストを追加しました。ライブストリームの場合に送信されるべきかを明確にしました。"
    },
    {
      "indent": 6,
      "text": "* The headers table has been updated using a structure borrowed from SIP. Those tables convey much more information and should provide a good overview of the available headers.",
      "ja": "*ヘッダテーブルは、SIPから借りた構造を使用して更新されました。これらのテーブルは、より多くの情報を伝え、可能なヘッダの良い概観を提供する必要があります。"
    },
    {
      "indent": 6,
      "text": "* It has been clarified that any message with a message body is required to have a Content-Length header. This was the case in RFC 2326, but could be misinterpreted.",
      "ja": "*メッセージのボディを持つ任意のメッセージがContent-Lengthヘッダを有することが必要であることが明らかとなりました。これは、RFC 2326でのケースだったが、誤って解釈される可能性があります。"
    },
    {
      "indent": 6,
      "text": "* ETag has changed its name to MTag.",
      "ja": "* ETagのは、MTAGに社名を変更しました。"
    },
    {
      "indent": 6,
      "text": "* To resolve functionality around MTag, the MTag and If-None-Match header have been added from HTTP with necessary clarification in regard to RTSP operation.",
      "ja": "* MTAG、MTAG周りの機能を解決し、If-None-Matchヘッダは、RTSPの動作に関しては、必要な明確化してHTTPから追加されました。"
    },
    {
      "indent": 6,
      "text": "* Imported the Public header from HTTP (RFC 2068 [RFC2068]) since it has been removed from HTTP due to lack of use. Public is used quite frequently in RTSP.",
      "ja": "*これが原因使用の欠如のためにHTTPから除去されているので、HTTP（RFC 2068 [RFC2068]）から公的ヘッダをインポート。公開は、RTSPでかなり頻繁に使用されています。"
    },
    {
      "indent": 6,
      "text": "* Clarified rules for populating the Public header so that it is an intersection of the capabilities of all the RTSP agents in a chain.",
      "ja": "*これは、チェーン内のすべてのRTSPエージェントの能力との交点であるように公開ヘッダを移入するための規則を明らかにしました。"
    },
    {
      "indent": 6,
      "text": "* Added the Media-Range header for listing the current availability of the media range.",
      "ja": "*メディアの範囲の現在の可用性をリストするためのメディア-Rangeヘッダを追加しました。"
    },
    {
      "indent": 6,
      "text": "* Added the Notify-Reason header for giving the reason when sending PLAY_NOTIFY requests.",
      "ja": "* PLAY_NOTIFYリクエストを送信する際に理由を与えるための通知-理由ヘッダを追加しました。"
    },
    {
      "indent": 6,
      "text": "* A new header Seek-Style has been defined to direct and inform how any seek operation should/have been performed.",
      "ja": "*新しいヘッダは、シークスタイル指示し、任意の操作が/実行されている必要があります求める方法を知らせるために定義されています。"
    },
    {
      "indent": 3,
      "text": "o The Protocol Syntax has been changed in the following way:",
      "ja": "Oプロトコルの構文は次のように変更されました："
    },
    {
      "indent": 6,
      "text": "* All ABNF definitions are updated according to the rules defined in RFC 5234 [RFC5234] and have been gathered in a separate section (Section 20).",
      "ja": "*すべてのABNF定義は、RFC 5234 [RFC5234]で定義されており、別のセクション（セクション20）に収集されたルールに従って更新されます。"
    },
    {
      "indent": 6,
      "text": "* The ABNF for the User-Agent and Server headers have been corrected.",
      "ja": "*ユーザー・エージェントおよびサーバーヘッダーのABNFが修正されました。"
    },
    {
      "indent": 6,
      "text": "* Some definitions in the introduction regarding the RTSP session have been changed.",
      "ja": "* RTSPセッションに関する導入のいくつかの定義が変更されました。"
    },
    {
      "indent": 6,
      "text": "* The protocol has been made fully IPv6 capable.",
      "ja": "*プロトコルは完全にIPv6の対応行われています。"
    },
    {
      "indent": 6,
      "text": "* The CHAR rule has been changed to exclude NULL.",
      "ja": "* CHARルールは、NULLを除外するように変更されました。"
    },
    {
      "indent": 3,
      "text": "o The Status codes have been changed in the following ways:",
      "ja": "Oステータスコードは、次のように変更されました。"
    },
    {
      "indent": 6,
      "text": "* The use of status code 303 (See Other) has been deprecated as it does not make sense to use in RTSP.",
      "ja": "それはRTSPで使用しても意味がありませんので*ステータスコード303（その他を参照）の使用が推奨されていません。"
    },
    {
      "indent": 6,
      "text": "* The never-defined status code 411 \"Length Required\" has been completely removed.",
      "ja": "*決して定義されていないステータスコード411「必要な長さは、」完全に削除されました。"
    },
    {
      "indent": 6,
      "text": "* When sending response 451 (Parameter Not Understood) and 458 (Parameter Is Read-Only), the response body should contain the offending parameters.",
      "ja": "応答451を送信する場合は*（パラメータが分からない）と458（パラメータは読み取り専用です）、レスポンスボディは、問題のあるパラメータが含まれている必要があります。"
    },
    {
      "indent": 6,
      "text": "* Clarification on when a 3rr redirect status code can be received has been added. This includes receiving 3rr as a result of a request within an established session. This provides clarification to a previous unspecified behavior.",
      "ja": "*受信可能3RRリダイレクトステータスコードが追加されたときに明確化。これは、確立されたセッション内の要求の結果として3RRを受信することを含みます。これは、前の未指定の動作に明確化を提供します。"
    },
    {
      "indent": 6,
      "text": "* Removed the 201 (Created) and 250 (Low On Storage Space) status codes as they are only relevant to recording, which is deprecated.",
      "ja": "*彼らは廃止されて記録にのみ関連しているように除去（ストレージ容量が少ない）（作成者）201と250ステータスコード。"
    },
    {
      "indent": 6,
      "text": "* Several new status codes have been defined: 464 (Data Transport Not Ready Yet), 465 (Notification Reason Unknown), 470 (Connection Authorization Required), 471 (Connection Credentials Not Accepted), and 472 (Failure to Establish Secure Connection).",
      "ja": "*いくつかの新しいステータスコードが定義されています：464（データ転送不可けれども）、465（不明な通知理由）、470（接続認証が必要）、471（接続資格情報が受け付けられない）、および472（安全な接続を確立するために失敗）。"
    },
    {
      "indent": 3,
      "text": "o The following functionality has been deprecated from the protocol:",
      "ja": "O次の機能は、プロトコルから廃止されました："
    },
    {
      "indent": 6,
      "text": "* The use of Queued Play.",
      "ja": "*キュープレイの使用。"
    },
    {
      "indent": 6,
      "text": "* The use of PLAY method for keep-alive in Play state.",
      "ja": "*キープアライブプレイ状態のためのPLAYメソッドを使用します。"
    },
    {
      "indent": 6,
      "text": "* The RECORD and ANNOUNCE methods and all related functionality. Some of the syntax has been removed.",
      "ja": "* RECORDや方法を発表し、すべての関連する機能。構文の一部が削除されました。"
    },
    {
      "indent": 6,
      "text": "* The possibility to use timed execution of methods with the time parameter in the Range header.",
      "ja": "*可能性は、Rangeヘッダに時間パラメータを有するメソッドの時限実行を使用します。"
    },
    {
      "indent": 6,
      "text": "* The description on how rtspu works is not part of the core specification and will require external description. Only that it exists is mentioned here and some requirements for the transport are provided.",
      "ja": "* RTSPUがどのように機能するかについての説明は、コア仕様の一部ではなく、外部の説明が必要になります。それだけが存在していることをここで言及されており、輸送のためのいくつかの要件が提供されています。"
    },
    {
      "indent": 3,
      "text": "o The following changes have been made in relation to methods:",
      "ja": "以下の変更oをする方法に関連して行われています。"
    },
    {
      "indent": 6,
      "text": "* The OPTIONS method has been clarified with regard to the use of the Public and Allow headers.",
      "ja": "* OPTIONSメソッドは、公共の使用に関して明確にし、ヘッダを許可されています。"
    },
    {
      "indent": 6,
      "text": "* Added text clarifying the usage of SET_PARAMETER for keep-alive and usage without a body.",
      "ja": "*ボディなしでキープアライブと使用のためのSET_PARAMETERの使用を明確に追加されたテキスト。"
    },
    {
      "indent": 6,
      "text": "* PLAY method is now allowed to be pipelined with the pipelining of one or more SETUP requests following the initial that generates the session for aggregated control.",
      "ja": "* PLAY方法について集約制御するためのセッションを生成し、初期以下の一つ以上のSETUPリクエストのパイプラインとパイプライン化することが許されます。"
    },
    {
      "indent": 6,
      "text": "* REDIRECT has been expanded and diversified for different situations.",
      "ja": "* REDIRECTは拡大し、さまざまな状況のために多様化しています。"
    },
    {
      "indent": 6,
      "text": "* Added a new method PLAY_NOTIFY. This method is used by the RTSP server to asynchronously notify clients about session changes.",
      "ja": "*新しい方法PLAY_NOTIFYを追加しました。このメソッドは非同期セッションの変更についてクライアントに通知するためにRTSPサーバで使用されています。"
    },
    {
      "indent": 3,
      "text": "o Wrote a new section about how to set up different media-transport alternatives and their profiles as well as lower-layer protocols. This caused the appendix on RTP interaction to be moved to the new section instead of being in the part that describes RTP. The new section also includes guidelines what to consider when writing usage guidelines for new protocols and profiles.",
      "ja": "O異なるメディア輸送の代替と自分のプロファイルだけでなく、下位層のプロトコルを設定する方法についての新しいセクションを書きました。これは、RTPの相互作用に関する付録ではなく、RTPを記述部分であることの新しいセクションに移動させ。新しいセクションは、新しいプロトコルやプロファイルの使用ガイドラインを書くときに考慮すべきどのようなガイドラインが含まれています。"
    },
    {
      "indent": 3,
      "text": "o Setup and usage of independent TCP connections for transport of RTP has been specified.",
      "ja": "O RTPの輸送のための独立したTCP接続のセットアップと使用法が指定されています。"
    },
    {
      "indent": 3,
      "text": "o Added a new section describing the available mechanisms to determine if functionality is supported, called \"Capability Handling\". Renamed option-tags to feature tags.",
      "ja": "O「機能の処理」と呼ばれる機能がサポートされているかどうかを判断するために利用可能なメカニズムを記述する新しいセクションを追加しました。タグを特徴とするオプションタグの名前を変更しました。"
    },
    {
      "indent": 3,
      "text": "o Added a Contributors section with people who have contributed actual text to the specification.",
      "ja": "O仕様への実際のテキストを貢献した人々と協力者のセクションを追加しました。"
    },
    {
      "indent": 3,
      "text": "o Added a section \"Use Cases\" that describes the major use cases for RTSP.",
      "ja": "O RTSPのための主要なユースケースを説明するセクション「ユースケース」を追加しました。"
    },
    {
      "indent": 3,
      "text": "o Clarified the usage of a=range and how to indicate live content that are not seekable with this header.",
      "ja": "O =範囲の使用を明らかにし、どのようにこのヘッダでシークされていないライブコンテンツを指示します。"
    },
    {
      "indent": 3,
      "text": "o Text specifying the special behavior of PLAY for live content.",
      "ja": "OライブコンテンツのためのPLAYの特殊な動作を指定するテキスト。"
    },
    {
      "indent": 3,
      "text": "o Security features of RTSP have been clarified:",
      "ja": "O RTSPのセキュリティ機能が明らかにされています："
    },
    {
      "indent": 6,
      "text": "* HTTP-based authorization has been clarified requiring both Basic and Digest support",
      "ja": "* HTTPベースの認証には、基本とダイジェストサポートの両方を必要と明らかにされています"
    },
    {
      "indent": 6,
      "text": "* TLS support has been mandated",
      "ja": "* TLSのサポートが義務付けされています"
    },
    {
      "indent": 6,
      "text": "* If one implements RTP, then SRTP and defined MIKEY-based key-exchange must be supported",
      "ja": "* 1はSRTP、その後、RTPを実装し、MIKEYベースのキー交換をサポートしなければならない定義されている場合"
    },
    {
      "indent": 6,
      "text": "* Various minor mitigations discussed or resulted in protocol changes.",
      "ja": "*様々なマイナーな緩和策が議論やプロトコルの変更が生じました。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "This memorandum defines RTSP version 2.0, which is a revision of the Proposed Standard RTSP version 1.0 defined in [RFC2326]. The authors of RFC 2326 are Henning Schulzrinne, Anup Rao, and Robert Lanphier.",
      "ja": "このメモは、[RFC2326]で定義された提案の標準RTSPバージョン1.0の改訂であるRTSPバージョン2.0を定義します。 RFC 2326の作者はヘニングSchulzrinneと、Anupラオ、およびロバートLanphierです。"
    },
    {
      "indent": 3,
      "text": "Both RTSP version 1.0 and RTSP version 2.0 borrow format and descriptions from HTTP/1.1.",
      "ja": "RTSPバージョン1.0およびRTSPバージョン2.0ボローフォーマットとHTTP / 1.1から記述の両方。"
    },
    {
      "indent": 3,
      "text": "Robert Sparks and especially Elwyn Davies provided very valuable and detailed reviews in the IETF Last Call that greatly improved the document and resolved many issues, especially regarding consistency.",
      "ja": "ロバート・スパークス、特にエルウィン・デイヴィスが大幅に文書を改善し、特に一貫性に関して、多くの問題を解決するIETFラストコールでは非常に貴重かつ詳細なレビューを提供します。"
    },
    {
      "indent": 3,
      "text": "This document has benefited greatly from the comments of all those participating in the MMUSIC WG. In addition to those already mentioned, the following individuals have contributed to this specification:",
      "ja": "この文書は、MMUSIC WGに参加するすべての者のコメントから大きな恩恵を受けています。すでに述べたものに加えて、以下の個人はこの仕様に貢献しています："
    },
    {
      "indent": 3,
      "text": "Rahul Agarwal, Claudio Allocchio, Jeff Ayars, Milko Boic, Torsten Braun, Brent Browning, Bruce Butterfield, Steve Casner, Maureen Chesire, Jinhang Choi, Francisco Cortes, Elwyn Davies, Spencer Dawkins, Kelly Djahandari, Martin Dunsmuir, Adrian Farrel, Stephen Farrell, Ross Finlayson, Eric Fleischman, Jay Geagan, Andy Grignon, Christian Groves, V. Guruprasad, Peter Haight, Mark Handley, Brad Hefta-Gaub, Volker Hilt, John K. Ho, Patrick Hoffman, Go Hori, Philipp Hoschka, Anne Jones, Ingemar Johansson, Jae-Hwan Kim, Anders Klemets, Ruth Lang, Barry Leiba, Stephanie Leif, Jonathan Lennox, Eduardo F. Llach, Chris Lonvick, Xavier Marjou, Thomas Marshall, Rob McCool, Martti Mela, David Oran, Joerg Ott, Joe Pallas, Maria Papadopouli, Sujal Patel, Ema Patki, Alagu Periyannan, Colin Perkins, Pekka Pessi, Igor Plotnikov, Pete Resnick, Peter Saint-Andre, Holger Schmidt, Jonathan Sergent, Pinaki Shah, David Singer, Lior Sion, Jeff Smith, Alexander Sokolsky, Dale Stammen, John Francis Stracke, Geetha Srikantan, Scott Taylor, David Walker, Stephan Wenger, Dale R. Worley, and Byungjo Yoon, and especially Flemming Andreasen.",
      "ja": "ラーフルAgarwalさん、クラウディオAllocchio、ジェフAyars、Milko Boic、トルステン・ブラウン、ブレントブラウニング、ブルース・バターフィールド、スティーブCasner、モーリーンChesire、Jinhangチェ、フランシスコ・コルテス、エルウィン・デイヴィス、スペンサードーキンスケリーDjahandari、マーティンダンスミア、エードリアンファレル、スティーブン・ファレル、ロスフィンレイソン、エリックFleischman、ジェイGeagan、アンディGrignon、クリスチャン・グローブス、V.グルプラサード、ピーター・ヘイト、マーク・ハンドリー、ブラッドHefta-Gaub、フォルカー柄、ジョンK.ホー、パトリック・ホフマン、ゴー堀、フィリップHoschka、アン・ジョーンズ、インゲマル・ヨハンソン、在煥キム、アンダースKlemets、ルース・ラング、バリー・レイバ、ステファニーレイフ、ジョナサン・レノックス、エドゥアルド・F. Llach、クリスLonvick、ザビエルMarjou、トーマス・マーシャル、ロブ・マックール、マルッティメラ、デビッド・オラン、イェルク・オット、ジョー・パラス、マリアPapadopouli、Sujal Patelさん、エマPatki、Alagu Periyannan、コリンパーキンス、ペッカPessi、イガー・プロットニーコブ、ピート・レズニック、ピーター・サン・アンドレ、ホルガー・シュミット、ジョナサン・セルジャン、Pinakiシャー、デビッド・シンガー、LIORシオン、ジェフ・スミス、アレクサンダーSokolsky、デイルStammen、ジョン・フランシスStracke、Geeth Srikantan、スコット・テイラー、デビッド・ウォーカー、ステファン・ウェンガー、デイル・R.ウォーリー、およびByungjoユン、特にフレミングアンドレア。"
    },
    {
      "indent": 0,
      "text": "Contributors",
      "ja": "協力者"
    },
    {
      "indent": 3,
      "text": "The following people have made written contributions that were included in the specification:",
      "ja": "次の人は、仕様書に含まれていた書かれた貢献をしました。"
    },
    {
      "indent": 3,
      "text": "o Tom Marshall contributed text on the usage of 3rr status codes.",
      "ja": "Oトム・マーシャルは3RRステータスコードの使用上のテキストを寄付しました。"
    },
    {
      "indent": 3,
      "text": "o Thomas Zheng contributed text on the usage of the Range in PLAY responses and proposed an earlier version of the PLAY_NOTIFY method.",
      "ja": "Oトーマス鄭は、PLAY応答の範囲の使用上のテキストを拠出し、PLAY_NOTIFY方法の以前のバージョンを提案しました。"
    },
    {
      "indent": 3,
      "text": "o Sean Sheedy contributed text on the timeout behavior of RTSP messages and connections, the 463 (Destination Prohibited) status code, and proposed an earlier version of the PLAY_NOTIFY method.",
      "ja": "Oショーンシーディは、RTSPメッセージおよび接続のタイムアウト動作上のテキスト、463（先禁止）状態コードを寄与し、PLAY_NOTIFY法の以前のバージョンを提案しました。"
    },
    {
      "indent": 3,
      "text": "o Greg Sherwood proposed an earlier version of the PLAY_NOTIFY method.",
      "ja": "OグレッグシャーウッドはPLAY_NOTIFY方法の以前のバージョンを提案しました。"
    },
    {
      "indent": 3,
      "text": "o Fredrik Lindholm contributed text about the RTSP security framework.",
      "ja": "Oフレドリックリンドホルムは、RTSPセキュリティフレームワークについてのテキストを寄付しました。"
    },
    {
      "indent": 3,
      "text": "o John Lazzaro contributed the text for RTP over Independent TCP.",
      "ja": "Oジョンラザロは、独立したTCP上のRTPのテキストを拠出しました。"
    },
    {
      "indent": 3,
      "text": "o Aravind Narasimhan contributed by rewriting \"Media-Transport Alternatives\" (Appendix C) and making editorial improvements on a number of places in the specification.",
      "ja": "O Aravind Narasimhanは、「メディア・トランスポート・代替」（付録C）を書き換えると、仕様上のさまざまな場所に編集改善を行うことで貢献しました。"
    },
    {
      "indent": 3,
      "text": "o Torbjorn Einarsson has done some editorial improvements of the text.",
      "ja": "O Torbjorn Einarssonは、テキストの一部の編集の改良を行っています。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Henning Schulzrinne Columbia University 1214 Amsterdam Avenue New York, NY 10027 United States of America",
      "ja": "ヘニングSchulzrinneとコロンビア大学1214アムステルダムアベニュー、ニューヨーク、アメリカのNY 10027米国"
    },
    {
      "indent": 3,
      "text": "Email: schulzrinne@cs.columbia.edu",
      "ja": "メール：schulzrinne@cs.columbia.edu"
    },
    {
      "indent": 3,
      "text": "Anup Rao Cisco United States of America",
      "ja": "アメリカのAnupラオシスコ米国"
    },
    {
      "indent": 3,
      "text": "Email: anrao@cisco.com",
      "ja": "メール：anrao@cisco.com"
    },
    {
      "indent": 3,
      "text": "Rob Lanphier San Francisco, CA United States of America",
      "ja": "ロブLanphierサンフランシスコ、アメリカのカリフォルニア州、米国"
    },
    {
      "indent": 3,
      "text": "Email: robla@robla.net",
      "ja": "メール：robla@robla.net"
    },
    {
      "indent": 3,
      "text": "Magnus Westerlund Ericsson Faeroegatan 2 Stockholm SE-164 80 Sweden",
      "ja": "マグヌスウェスターエリクソンFaeroegatan 2ストックホルムSE-164 80スウェーデン"
    },
    {
      "indent": 3,
      "text": "Email: magnus.westerlund@ericsson.com",
      "ja": "メール：magnus.westerlund@ericsson.com"
    },
    {
      "indent": 3,
      "text": "Martin Stiemerling (editor) University of Applied Sciences Darmstadt Haardtring 100 64295 Darmstadt Germany",
      "ja": "マーティンStiemerling（編集者）大学応用科学のダルムシュタットHaardtring 100 64295ダルムシュタットドイツ"
    },
    {
      "indent": 3,
      "text": "Email: mls.ietf@gmail.com URI: http://www.stiemerling.org",
      "ja": "メール：mls.ietf@gmail.com URI：http://www.stiemerling.org"
    }
  ]
}