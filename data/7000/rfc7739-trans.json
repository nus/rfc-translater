{
  "title": {
    "text": "RFC 7739 - Security Implications of Predictable Fragment Identification Values",
    "ja": "RFC 7739 - 予測可能なフラグメント識別値のセキュリティへの影響"
  },
  "number": 7739,
  "created_at": "2019-11-01 19:48:31.509436+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                           F. Gont\nRequest for Comments: 7739                           Huawei Technologies\nCategory: Informational                                    February 2016\nISSN: 2070-1721",
      "raw": true
    },
    {
      "indent": 2,
      "text": "Security Implications of Predictable Fragment Identification Values",
      "ja": "予測可能なフラグメント識別値のセキュリティへの影響"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "IPv6 specifies the Fragment Header, which is employed for the fragmentation and reassembly mechanisms. The Fragment Header contains an \"Identification\" field that, together with the IPv6 Source Address and the IPv6 Destination Address of a packet, identifies fragments that correspond to the same original datagram, such that they can be reassembled together by the receiving host. The only requirement for setting the Identification field is that the corresponding value must be different than that employed for any other fragmented datagram sent recently with the same Source Address and Destination Address. Some implementations use a simple global counter for setting the Identification field, thus leading to predictable Identification values. This document analyzes the security implications of predictable Identification values, and provides implementation guidance for setting the Identification field of the Fragment Header, such that the aforementioned security implications are mitigated.",
      "ja": "IPv6は、断片化と再アセンブリのメカニズムのために使用されるフラグメントヘッダを指定します。フラグメントヘッダは、一緒にIPv6ソースアドレスとパケットのIPv6宛先アドレスと、それらが受信側ホストによって一緒に再組立てすることができるように、同一のオリジナルのデータグラムに対応するフラグメントを識別する「識別」フィールドを含みます。識別フィールドを設定するための唯一の要件は、対応する値が同じ送信元アドレスと宛先アドレスと、最近送信され、他の断片化されたデータグラムのために使用されるものよりも異なっていなければならないということです。一部の実装では、このように予測可能な識別値につながる、識別フィールドを設定するための簡単なグローバルカウンタを使用しています。この文書では、予測可能な識別値のセキュリティへの影響を解析して、前述のセキュリティへの影響が軽減されるようなフラグメントヘッダーの識別フィールドを、設定するための実装のガイダンスを提供します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "ja": "このドキュメントはインターネット標準化過程仕様ではありません。それは、情報提供の目的のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are a candidate for any level of Internet Standard; see Section 2 of RFC 5741.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。 IESGによって承認されていないすべての文書がインターネットStandardのどんなレベルの候補です。 RFC 5741のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7739.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7739で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2016 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2016 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3\n2.  Terminology . . . . . . . . . . . . . . . . . . . . . . . . .   3\n3.  Security Implications of Predictable Fragment Identification\n    Values  . . . . . . . . . . . . . . . . . . . . . . . . . . .   3\n4.  Constraints for the Selection of Fragment Identification\n    Values  . . . . . . . . . . . . . . . . . . . . . . . . . . .   7\n5.  Algorithms for Selecting Fragment Identification Values . . .   8\n  5.1.  Per-Destination Counter (Initialized to a Random Value) .   8\n  5.2.  Randomized Identification Values  . . . . . . . . . . . .   9\n  5.3.  Hash-Based Fragment Identification Selection Algorithm  .  10\n6.  Security Considerations . . . . . . . . . . . . . . . . . . .  12\n7.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  13\n  7.1.  Normative References  . . . . . . . . . . . . . . . . . .  13\n  7.2.  Informative References  . . . . . . . . . . . . . . . . .  14\nAppendix A.  Information Leakage Produced by Vulnerable\n             Implementations  . . . . . . . . . . . . . . . . . .  16\nAppendix B.  Survey of Fragment Identification Selection\n             Algorithms Employed by Popular IPv6 Implementations   18\nAcknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  20\nAuthor's Address  . . . . . . . . . . . . . . . . . . . . . . . .  20",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "IPv6 specifies the Fragment Header, which is employed for the fragmentation and reassembly mechanisms. The Fragment Header contains an \"Identification\" field that, together with the IPv6 Source Address and the IPv6 Destination Address of a packet, identifies fragments that correspond to the same original datagram, such that they can be reassembled together by the receiving host. The only requirement for setting the Identification field is that its value must be different than that employed for any other fragmented datagram sent recently with the same Source Address and Destination Address.",
      "ja": "IPv6は、断片化と再アセンブリのメカニズムのために使用されるフラグメントヘッダを指定します。フラグメントヘッダは、一緒にIPv6ソースアドレスとパケットのIPv6宛先アドレスと、それらが受信側ホストによって一緒に再組立てすることができるように、同一のオリジナルのデータグラムに対応するフラグメントを識別する「識別」フィールドを含みます。識別フィールドを設定するための唯一の要件は、その値が同じ送信元アドレスと宛先アドレスと、最近送信され、他の断片化されたデータグラムのために使用されるものよりも異なっていなければならないということです。"
    },
    {
      "indent": 3,
      "text": "The most trivial algorithm to avoid reusing Identification values too quickly is to maintain a global counter that is incremented for each fragmented datagram that is transmitted. However, this trivial algorithm leads to predictable Identification values that can be leveraged to perform a variety of attacks.",
      "ja": "あまりにも早く識別値を再利用しないようにする最も些細なアルゴリズムが送信され、各断片化されたデータグラムのために増加されたグローバルカウンタを維持することです。ただし、この些細なアルゴリズムは、さまざまな攻撃を実行するために活用することができ、予測可能な識別値につながります。"
    },
    {
      "indent": 3,
      "text": "Section 3 of this document analyzes the security implications of predictable Identification values. Section 4 discusses constraints in the possible algorithms for selecting Identification values. Section 5 specifies a number of algorithms that could be used for generating Identification values that mitigate the issues discussed in this document. Finally, Appendix B contains a survey of the algorithms employed by popular IPv6 implementations for generating the Identification values.",
      "ja": "このドキュメントのセクション3は、予測可能な識別値のセキュリティへの影響を分析します。セクション4は、識別値を選択するための可能なアルゴリズムに制約を論じています。セクション5は、本文書で説明した問題を軽減識別値を生成するために使用することができるアルゴリズムの数を指定します。最後に、付録Bは識別値を生成するための人気のIPv6実装によって使用されるアルゴリズムの調査を含んでいます。"
    },
    {
      "indent": 0,
      "text": "2. Terminology",
      "section_title": true,
      "ja": "2.用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [RFC2119].",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はRFC 2119 [RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "3. Security Implications of Predictable Fragment Identification Values",
      "section_title": true,
      "ja": "予測可能なフラグメント識別値の3.セキュリティへの影響"
    },
    {
      "indent": 3,
      "text": "Predictable Identification values result in an information leakage that can be exploited in a number of ways. Among others, they may potentially be exploited to:",
      "ja": "予測可能な識別値は、多くの方法で利用することができる情報漏洩につながります。とりわけ、彼らは潜在的に悪用されることがあります。"
    },
    {
      "indent": 3,
      "text": "o determine the packet rate at which a given system is transmitting information",
      "ja": "O所定のシステム情報を送信されたパケットレートを決定します"
    },
    {
      "indent": 3,
      "text": "o perform stealth port scans to a third party",
      "ja": "O第三者にステルスポートスキャンを実行します"
    },
    {
      "indent": 3,
      "text": "o uncover the rules of a number of firewalls",
      "ja": "Oファイアウォールの数のルールを明らかにする"
    },
    {
      "indent": 3,
      "text": "o count the number of systems behind a middle-box o perform Denial-of-Service (DoS) attacks, or",
      "ja": "Oサービス拒否（DoS）攻撃を実行するミドルボックス0の背後にあるシステムの数をカウントし、または"
    },
    {
      "indent": 3,
      "text": "o perform data injection attacks against transport or application protocols",
      "ja": "Oトランスポートやアプリケーションプロトコルに対するデータインジェクション攻撃を実行します"
    },
    {
      "indent": 3,
      "text": "The security implications introduced by predictable Identification values in IPv6 are very similar to those of predictable Identification values in IPv4.",
      "ja": "IPv6における予測可能な識別値によって導入されたセキュリティ上の影響は、IPv4における予測可能な識別値のものと非常に類似しています。"
    },
    {
      "indent": 3,
      "text": "NOTE: [Sanfilippo1998a] originally pointed out how the IPv4 Identification field could be examined to determine the packet rate at which a given system is transmitting information. Later, [Sanfilippo1998b] described how a system with such an implementation could be used to perform a stealth port scan to a third (victim) host. [Sanfilippo1999] explained how to exploit this implementation strategy to uncover the rules of a number of firewalls. [Bellovin2002] explained how the IPv4 Identification field could be exploited to count the number of systems behind a NAT. [Fyodor2004] is an entire paper on most (if not all) the ways to exploit the information provided by the Identification field of the IPv4 header (and these results apply in a similar way to IPv6). [Zalewski2003] originally envisioned the exploitation of IP fragmentation/reassembly for performing data injection attacks against upper-layer protocols. [Herzberg2013] explores the use of IPv4/IPv6 fragmentation and predictable Identification values for performing DNS cache poisoning attacks in great detail. [RFC6274] covers the security implications of the IPv4 case in detail.",
      "ja": "注：[Sanfilippo1998a】本来のIPv4識別フィールドは、特定のシステム情報を送信されたパケットレートを決定するために検査する方法を指摘しました。後、[Sanfilippo1998bこのような実装にシステムがステルスポートは、第三（被害者）ホストにスキャンを実行するために使用することができる方法を説明しました。 【Sanfilippo1999】ファイアウォールの数の規則を発見するために、この実施戦略を利用する方法を説明します。 [Bellovin2002] IPv4の識別フィールドは、NATの背後にあるシステムの数をカウントするために悪用される可能性がどのように説明しました。 【Fyodor2004]ほとんど（全てではない）、IPv4ヘッダ（これらの結果は、IPv6と同様に適用する）の識別フィールドによって提供される情報を利用する方法で全体の紙です。 【Zalewski2003】本来上位層プロトコルに対するデータインジェクション攻撃を実行するためのIP断片化/再アセンブリの利用を想定。 【Herzberg2013】詳細にDNSキャッシュ汚染攻撃を実行するためのIPv4 / IPv6の断片化及び予測可能な識別値の使用を探ります。 [RFC6274]は詳細にはIPv4ケースのセキュリティへの影響をカバーします。"
    },
    {
      "indent": 3,
      "text": "One key difference between the IPv4 case and the IPv6 case is that, in IPv4, the Identification field is part of the fixed IPv4 header (and thus usually set for all packets), while in IPv6 the Identification field is present only in those packets that carry a Fragment Header. As a result, successful exploitation of the Identification field depends on two different factors:",
      "ja": "IPv4のケースとIPv6ケースとの間の1つの重要な違いは、IPv6内の識別フィールドが存在する間はIPv4に、識別フィールドはパケットのみに、固定されたIPv4ヘッダの一部（従って、通常はすべてのパケットに設定される）である、ということですフラグメントヘッダーを運びます。その結果、識別フィールドの悪用は、二つの異なる要因に依存します。"
    },
    {
      "indent": 3,
      "text": "o vulnerable Identification generators, and",
      "ja": "脆弱識別ジェネレータO、及び"
    },
    {
      "indent": 3,
      "text": "o the ability of an attacker to trigger the use of IPv6 fragmentation for packets sent from/to the victim node",
      "ja": "犠牲者ノードへ/から送信されるパケットのIPv6断片の使用をトリガする攻撃者の能力O"
    },
    {
      "indent": 3,
      "text": "The scenarios in which an attacker may successfully perform the aforementioned attacks depend on the specific attack type. For example, in order to perform a DoS attack on communications between two hosts, an attacker would need to know the IPv6 addresses employed by the aforementioned two nodes. Such knowledge may be readily available if the target of the attack is the communication between two specific BGP peers, two specific SMTP servers, or one specific primary DNS server and one of its secondary DNS servers, but may not be easily available if the goal is a DoS attack on all communications between arbitrary IPv6 hosts (e.g., the goal is to perform a DoS attack on all communications involving one specific node with arbitrary/unknown hosts). Other attacks, such as performing stealth port scans to a third party or determining the packet rate at which a given system is transmitting information, only require the attacker to know the IPv6 address of a vulnerable implementation.",
      "ja": "攻撃者が、前述の攻撃を行う可能性のあるシナリオは、特定の攻撃タイプによって異なります。例えば、2つのホスト間の通信にDoS攻撃を行うために、攻撃者は、上述の二つのノードによって使用されるIPv6アドレスを知る必要があるだろう。このような知識は、攻撃のターゲットは2つの特定のBGPピア、2台の特定のSMTPサーバー、または1台の特定のプライマリDNSサーバとセカンダリDNSサーバのいずれかの間の通信であれば容易に利用可能かもしれないが、目標があれば簡単に利用できない場合があります任意のIPv6ホスト間のすべての通信にDoS攻撃（例えば、目標は任意/未知のホストとの1つの特定のノードを含むすべての通信にDoS攻撃を実行することです）。そのような第三者にステルスポートスキャンを実行する、または特定のシステム情報を送信されたパケットレートを決定するなど、他の攻撃は、唯一の脆弱な実装のIPv6アドレスを知っている攻撃者を必要とします。"
    },
    {
      "indent": 3,
      "text": "As noted in Section 1, some implementations have been known to use predictable Identification values. For instance, Appendix B of this document shows that recent versions of a number of popular IPv6 implementations employ predictable values for the Identification field of the Fragment Header.",
      "ja": "第1節で述べたように、いくつかの実装は、予測可能な識別値を使用することが知られています。例えば、本書の付録Bは、人気のIPv6実装の数の最近のバージョンは、フラグメントヘッダーの識別フィールドに予測可能な値を採用することを示しています。"
    },
    {
      "indent": 3,
      "text": "Additionally, we note that [RFC2460] states that when an ICMPv6 Packet Too Big (PTB) error message advertising a Maximum Transfer Unit (MTU) smaller than 1280 bytes is received, the receiving host is not required to reduce the Path-MTU for the corresponding Destination Address, but must simply include a Fragment Header in all subsequent packets sent to that destination. This triggers the use of the so-called IPv6 \"atomic fragments\" [RFC6946]: IPv6 fragments with a Fragment Offset equal to 0, and the \"M\" (\"More fragments\") bit clear. [DEPGEN] documents the motivation of deprecating the generation of IPv6 atomic fragments in [RFC2460].",
      "ja": "また、私たちは[RFC2460]は最大転送単位（MTU）を広告するICMPv6の巨大パケット（PTB）、エラー・メッセージが小さいより1280のバイトを受信したときに、受信ホストがためにパスMTUを低下させるのに必要されていないと述べていることに注意してください宛先アドレスを対応するが、単にその宛先に送信されたすべての後続のパケットにフラグメントヘッダーを含める必要があります。 IPv6は0に等しいオフセット断片を有する断片、及び「M」（「追加断片」）ビットクリア：これは、いわゆるIPv6の「アトミック断片」[RFC6946]の使用をトリガします。 [DEPGEN] [RFC2460]でのIPv6原子断片の生成を非推奨のモチベーションを文書。"
    },
    {
      "indent": 3,
      "text": "Thus, an attacker can usually cause a victim host to \"fragment\" its outgoing packets by sending it a forged ICMPv6 Packet Too Big (PTB) error message that advertises an MTU smaller than 1280 bytes.",
      "ja": "このため、攻撃者は通常、それを1280バイトより小さいMTUを広告鍛造のICMPv6パケット過大（PTB）、エラーメッセージを送信することにより、「フラグメント」その発信パケットに被害者のホストを引き起こす可能性があります。"
    },
    {
      "indent": 3,
      "text": "There are a number of aspects that should be considered, though:",
      "ja": "しかし、考慮すべき点がいくつかあります："
    },
    {
      "indent": 3,
      "text": "o All the implementations the author is aware of record the Path-MTU information on a per-destination basis. Thus, an attacker can only cause the victim to enable fragmentation for those packets sent to the Source Address of IPv6 packet embedded in the payload of the ICMPv6 PTB message. However, we note that Section 5.2 of [RFC1981] notes that an implementation could maintain a single system-wide Path MTU (PMTU) value to be used for all packets sent to that node. Clearly, such implementations would exacerbate the problem of any attacks based on Path MTU Discovery (PMTUD) [RFC5927] or IPv6 fragmentation.",
      "ja": "Oすべての実装は、著者は、宛先単位で記録パスMTU情報を認識しています。このため、攻撃者は被害者がICMPv6のPTBメッセージのペイロードに埋め込まれたIPv6パケットの送信元アドレスに送信され、それらのパケットのフラグメンテーションを有効にすることがあります。しかし、我々は注意してください[RFC1981]のセクション5.2は、実装がそのノードに送信されるすべてのパケットのために使用される単一のシステム全体のパスMTU（PMTU）の値を維持することができると指摘していること。明らかに、そのような実装は、パスMTUディスカバリ（PMTUD）[RFC5927]またはIPv6フラグメンテーションに基づく任意の攻撃の問題を悪化させるであろう。"
    },
    {
      "indent": 3,
      "text": "o If the victim node implements some of the counter-measures for ICMP attacks described in RFC 5927 [RFC5927], it might be difficult for an attacker to cause the victim node to employ fragmentation for its outgoing packets. However, many current implementations fail to enforce these validation checks. For example, Linux 2.6.38-8 does not even require received ICMPv6 error messages to correspond to an ongoing communication instance.",
      "ja": "被害者のノードは、RFC 5927 [RFC5927]で説明したICMP攻撃のための対策の一部を実装している場合、攻撃者は被害者のノードは、その発信パケットのためのフラグメンテーションを採用させるために、O、それは難しいかもしれません。しかし、多くの現在の実装では、これらの検証チェックを強制することはできません。たとえば、Linux 2.6.38-8も進行中の通信のインスタンスに対応して受信されたICMPv6エラーメッセージを必要としません。"
    },
    {
      "indent": 3,
      "text": "o Some implementations (notably Linux) have already been updated according to [DEPGEN] such that ICMPv6 PTB messages do not result in the generation of IPv6 atomic fragments.",
      "ja": "O一部の実装（特にLinux）が、すでに[DEPGEN]などのICMPv6 PTBメッセージがIPv6原子フラグメントの生成をもたらさないことに応じて更新されました。"
    },
    {
      "indent": 3,
      "text": "Implementations that employ predictable Identification values and also fail to enforce validation checks on ICMPv6 error messages become vulnerable to the same type of attacks that can be exploited with IPv4 fragmentation, discussed earlier in this section.",
      "ja": "予測可能な識別値を採用し、また、ICMPv6エラーメッセージの検証チェックを強制できない実装は、このセクションで前述のIPv4断片で利用することができる攻撃の同じタイプに対して脆弱になります。"
    },
    {
      "indent": 3,
      "text": "One possible way in which predictable Identification values could be leveraged for performing a DoS attack is as follows: Let us assume that Host A is communicating with Host B, and that an attacker wants to perform a DoS attack such communication. The attacker would learn the Identification value currently in use by Host A, possibly by sending any packet that would elicit a fragmented response (e.g., an ICPMv6 echo request with a large payload). The attacker would then send a forged ICMPv6 PTB error message to Host A (with the IPv6 Source Address of the embedded IPv6 packet set to the IPv6 address of Host A, and the Destination Address of the embedded IPv6 packet set to the IPv6 address of a Host B), such that any subsequent packets sent by Host A to Host B include a Fragment Header. Finally, the attacker would send forged IPv6 fragments to Host B, with their IPv6 Source Address set to that of Host A, and Identification values that would result in collisions with the Identification values employed for the legitimate traffic sent by Host A to Host B. If Host B discards fragments that result in collisions of Identification values (e.g., such fragments overlap, and the host implements [RFC5722]), the attacker could simply trash the Identification space by sending multiple forged fragments with different Identification values, such that any subsequent packets from Host A to Host B are discarded at Host B as a result of the malicious fragments sent by the attacker.",
      "ja": "攻撃者がDoS攻撃などの通信を行うために望んでいることを私たちはAがHost Bと通信していることをホストに仮定しよう、と：予測可能な識別値は、DoS攻撃を実行するために活用することができた1つの可能な方法は次のとおりです。攻撃者は、おそらく（例えば、大きいペイロードを持つICPMv6エコー要求）断片化された応答を引き出すであろう任意のパケットを送信することによって、ホストAによって現在使用中の識別値を知るであろう。その後、攻撃者は偽造のICMPv6 PTBのエラーメッセージがホストAのIPv6アドレスに設定され埋め込まれたIPv6パケットのIPv6のソースアドレス、およびのIPv6アドレスに設定され埋め込まれたIPv6パケットの宛先アドレスを持つ（ホストへ送信しますBをホストするホストAによって送信された後続のパケットはフラグメントヘッダを含むように、B）ホスト。最後に、攻撃者は、ホストAのものに設定し、そのIPv6送信元アドレスと、ホストBに偽造のIPv6フラグメントを送信し、Bをホスト間Aによって送られた正当なトラフィックのために使用される識別値との衝突につながる識別値ですホストBは、識別値（例えば、そのような断片は重複し、ホスト実装[RFC5722]）の衝突を生じるフラグメントを破棄した場合、攻撃者は単に、異なる識別値を持つ複数の鍛造フラグメントを送ることによって、そのような任意の後続のことを識別空間をゴミ箱ができBをホストするホストAからのパケットが攻撃者によって送信された悪質な断片の結果として、ホストBで廃棄されます。"
    },
    {
      "indent": 3,
      "text": "NOTE: For example, Linux 2.6.38-10 is vulnerable to the aforementioned issue.",
      "ja": "注：たとえば、Linux 2.6.38-10は、前述の問題に対して脆弱です。"
    },
    {
      "indent": 6,
      "text": "[RFC6946] describes an improved processing of these packets that would eliminate this specific attack vector, at least in the case of TCP connections that employ the Path-MTU Discovery mechanism.",
      "ja": "[RFC6946]は、少なくともパスMTU発見メカニズムを使用TCP接続の場合には、この特定の攻撃ベクトルを排除するこれらのパケットの改良された処理を説明します。"
    },
    {
      "indent": 3,
      "text": "The aforementioned attack scenario is simply included to illustrate the problem of employing predictable Identification values. We note that regardless of the attacker's ability to cause a victim host to employ fragmentation when communicating with third parties, use of predictable Identification values makes communication flows that employ fragmentation vulnerable to any fragmentation-based attacks.",
      "ja": "前述の攻撃のシナリオは、単に、予測可能な識別値を使用するという問題を例示するために含まれています。我々は関係なく、第三者との通信時に被害者ホストが断片化を採用させるための攻撃者の能力の、予測可能な識別値の使用は任意の断片化ベースの攻撃に対して脆弱断片化を採用する通信フローを作ることに注意してください。"
    },
    {
      "indent": 0,
      "text": "4. Constraints for the Selection of Fragment Identification Values",
      "section_title": true,
      "ja": "フラグメント識別値の選択4.制約"
    },
    {
      "indent": 3,
      "text": "The Identification field of the Fragment Header is 32-bits long. However, when translators (e.g. [RFC6145]) are employed, the high-order 16 bits of the Identification field are effectively ignored.",
      "ja": "フラグメントヘッダの識別フィールドは32ビット長です。翻訳者（例えば、[RFC6145]）が使用される場合しかし、識別フィールドの上位16ビットは事実上無視されています。"
    },
    {
      "indent": 3,
      "text": "NOTE: [RFC6145] notes that, when translating in the IPv6-to-IPv4 direction, \"if there is a Fragment Header in the IPv6 packet, the last 16 bits of its value MUST be used for the IPv4 identification value\".",
      "ja": "注：[RFC6145]はのIPv6からIPv4方向に変換するときに、「フラグメントヘッダがIPv6パケットであった場合、その値の最後の16ビットがIPv4識別値を使用しなければなりません」、と述べています。"
    },
    {
      "indent": 6,
      "text": "Additionally, Section 3.3 of [RFC6052] encourages operators to use a Network-Specific Prefix (NSP) that maps the IPv4 address space into IPv6. Thus, when an NSP is being used, IPv6 addresses representing IPv4 nodes (reached through a stateless translator) are indistinguishable from native IPv6 addresses.",
      "ja": "また、[RFC6052]のセクション3.3は、IPv6内IPv4アドレス空間をマッピングネットワーク固有のプレフィックス（NSP）を使用するようにオペレータを促します。 NSPが使用されている場合したがって、（ステートレストランスレータを介して到達）のIPv4ノードを表すIPv6アドレスは、ネイティブIPv6アドレスと区別できません。"
    },
    {
      "indent": 3,
      "text": "Thus, when translators are employed, the \"effective\" length of the Identification field is 16 bits and, as a result, at least during the IPv6/IPv4 transition/co-existence phase, it is probably safer to assume that only the low-order 16 bits of the Identification field are of use to the destination system.",
      "ja": "従って、トランスレータが使用される場合、識別フィールドの「有効な」長さは、結果として、少なくともたIPv6 / IPv4の移行/共存相の間、唯一の低をとるように、おそらく安全である、16ビットであり、注文識別フィールドの16ビットは、宛先システムに有用です。"
    },
    {
      "indent": 3,
      "text": "Regarding the selection of Identification values, the only requirement specified in [RFC2460] is that the Identification value must be different than that of any other fragmented packet sent recently with the same Source Address and Destination Address. Failure to comply with this requirement could lead to the interoperability problems discussed in [RFC4963].",
      "ja": "識別値の選択については、[RFC2460]で指定された唯一の要件は、識別値が同じ送信元アドレスと宛先アドレスと最近送信された任意の他の断片化されたパケットとは異なるなければならないことです。この要件に従わない場合は、[RFC4963]で議論相互運用性の問題につながる可能性があります。"
    },
    {
      "indent": 3,
      "text": "From a security standpoint, unpredictable Identification values are desirable. However, this is somewhat at odds with the \"reuse\" requirements specified in [RFC2460], that specifies that an Identification value must be different than that employed for any other fragmented packet sent recently with the same Source Address and Destination Address.",
      "ja": "セキュリティの観点からは、予測不可能な識別値が望ましいです。しかし、これはやや[RFC2460]で指定された「再利用」の要件と対立し、それは識別値が同じ送信元アドレスと宛先アドレスと、最近送信され、他のフラグメントパケットに使用するよりも異なっていなければならないことを指定しています。"
    },
    {
      "indent": 3,
      "text": "Finally, since Identification values need to be selected for each outgoing datagram that requires fragmentation, the performance impact should be considered when choosing an algorithm for the selection of Identification values.",
      "ja": "識別値は、フラグメンテーションを必要とする各発信データグラムのために選択する必要があるため識別値を選択するためのアルゴリズムを選択するときに最後に、パフォーマンスへの影響を考慮すべきです。"
    },
    {
      "indent": 0,
      "text": "5. Algorithms for Selecting Fragment Identification Values",
      "section_title": true,
      "ja": "5.アルゴリズムフラグメント識別値を選択します"
    },
    {
      "indent": 3,
      "text": "There are a number of algorithms that may be used for setting the Identification field such that the security issues discussed in this document are avoided. This section presents three of those.",
      "ja": "この文書で説明されているセキュリティ上の問題が回避されるように、識別フィールドを設定するために使用することができるアルゴリズムがいくつかあります。ここでは、これらのうち3つを提示しています。"
    },
    {
      "indent": 3,
      "text": "The algorithm in Section 5.1 typically leads to a low Identification reuse frequency at the expense of keeping per-destination state; this algorithm only uses a Pseudorandom Number Generator (PNRG) when the host communicates with a new destination. The algorithm in Section 5.2 may result in a higher Identification reuse frequency. It also uses a PRNG for each datagram that needs to be fragmented. Hence, the algorithm in Section 5.1 will likely result in better performance properties. Finally, the algorithm in Section 5.3 achieves a similar Identification reuse frequency to that of the algorithm in Section 5.1 without the need of keeping state, but possibly at the expense of lower per-packet performance.",
      "ja": "セクション5.1におけるアルゴリズムは、典型的には、宛先単位の状態を維持する費用で低い識別の再使用周波数につながります。ホストが新しい宛先と通信するとき、このアルゴリズムは、擬似乱数ジェネレータ（PNRG）を使用しています。セクション5.2におけるアルゴリズムは、より高い識別の再使用周波数をもたらすことができます。また、断片化する必要がある各データグラムのPRNGを使用しています。そこで、5.1節におけるアルゴリズムは、おそらくより優れた性能特性になります。最後に、セクション5.3におけるアルゴリズムは、状態を維持する必要なく、セクション5.1でアルゴリズムと同様の識別の再使用周波数を達成するが、おそらく低いパケットごとの性能を犠牲に。"
    },
    {
      "indent": 3,
      "text": "NOTE: Since the specific algorithm to be employed for the PRNGs in Section 5.1 and Section 5.2, and the specific algorithms to be employed for the hash functions in Section 5.3 have not been specified, it is impossible to provide a quantitative performance comparison of the algorithms described in this section.",
      "ja": "注記：特定のアルゴリズムは、セクション5.1およびセクション5.2でのPRNGのために使用すること、及び特定のアルゴリズムが指定されていないセクション5.3でハッシュ関数のために使用されるので、アルゴリズムの定量的な性能比較を提供することは不可能ですこのセクションで説明します。"
    },
    {
      "indent": 0,
      "text": "5.1. Per-Destination Counter (Initialized to a Random Value)",
      "section_title": true,
      "ja": "5.1.  （ランダム値に初期化）先ごとのカウンター"
    },
    {
      "indent": 3,
      "text": "This algorithm consists of the following steps:",
      "ja": "このアルゴリズムは、以下のステップで構成されています。"
    },
    {
      "indent": 3,
      "text": "1. Whenever a packet must be sent with a Fragment Header, the sending host should look up in the Destination Cache an entry corresponding to the Destination Address of the packet.",
      "ja": "1.パケットがフラグメントヘッダで送られなければならないときはいつでも、送信ホストが宛先キャッシュにパケットの宛先アドレスに対応するエントリを検索する必要があります。"
    },
    {
      "indent": 3,
      "text": "2. If such an entry exists, it contains the last Identification value used for that Destination Address. Therefore, such a value should be incremented by 1 and used for setting the Identification field of the outgoing packet. Additionally, the updated value should be recorded in the corresponding entry of the Destination Cache [RFC4861].",
      "ja": "2.そのようなエントリが存在する場合は、その宛先アドレスのために使用された最後の識別値が含まれています。したがって、そのような値は、1だけインクリメントし、発信パケットの識別フィールドを設定するために使用されるべきです。また、更新された値は、宛先キャッシュ[RFC4861]の対応するエントリに記録されなければなりません。"
    },
    {
      "indent": 3,
      "text": "3. If such an entry does not exist, it should be created, and the Identification value for that destination should be initialized with a random value (e.g., with a Pseudorandom Number Generator), and used for setting the Identification field of the Fragment Header of the outgoing fragmented datagram.",
      "ja": "3.このようなエントリが存在しない場合、それが作成されるべきであり、その宛先の識別値は、（擬似乱数発生器と、例えば、）は、ランダム値で初期化し、フラグメントヘッダの識別フィールドを設定するために使用されるべきです送信断片化したデータグラムの。"
    },
    {
      "indent": 3,
      "text": "The advantages of this algorithm are:",
      "ja": "このアルゴリズムの利点は、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o It is simple to implement, with the only complexity residing in the PRNG used to initialize the Identification value contained in each entry of the Destination Cache.",
      "ja": "O PRNGに存在する唯一の複雑さは、宛先キャッシュの各エントリに含まれる識別値を初期化するために使用して、実装が簡単です。"
    },
    {
      "indent": 3,
      "text": "o The Identification reuse frequency will typically be lower than that achieved by a global counter (when sending traffic to multiple destinations), since this algorithm uses per-destination counters (rather than a single system-wide counter).",
      "ja": "このアルゴリズムは、（むしろ単一システム全体カウンタより）ごとの先のカウンタを使用しているため、（複数の宛先にトラフィックを送信する場合）O識別再利用周波数は、典型的にはグローバルカウンタによって達成されるものよりも低くなります。"
    },
    {
      "indent": 3,
      "text": "o It has good performance properties (once the corresponding entry in the Destination Cache has been created and initialized, each subsequent Identification value simply involves the increment of a counter).",
      "ja": "Oそれは、（宛先キャッシュ内の対応するエントリが作成され、初期化された後、後続の各識別値は、単にカウンタのインクリメントを含む）は、良好な性能特性を有します。"
    },
    {
      "indent": 3,
      "text": "The possible drawbacks of this algorithm are:",
      "ja": "このアルゴリズムの可能な欠点は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "o If, as a result of resource management, an entry of the Destination Cache must be removed, the last Identification value used for that Destination will be lost. Thus, subsequent traffic to that destination would cause that entry to be recreated and reinitialized to random value, thus possibly leading to Identification \"collisions\".",
      "ja": "資源管理の結果として、宛先キャッシュのエントリを削除する必要があり、場合O、その先のために使用された最後の識別値は失われます。したがって、その宛先への後続のトラフィックは、そのエントリは、このように可能性の識別「衝突」につながる、ランダムな値に再作成して再初期化する原因となります。"
    },
    {
      "indent": 3,
      "text": "o Since the Identification values are predictable by the destination host, a vulnerable host might possibly leak to third parties the Identification values used by other hosts to send traffic to it (i.e., Host B could leak to Host C the Identification values that Host A is using to send packets to Host B). Appendix A describes one possible scenario for such leakage in detail.",
      "ja": "識別値は、宛先ホストによって予測可能であるので、O、脆弱なホストは、おそらく、それ（すなわち、ホストBへのトラフィックを送信するために他のホストによって使用される識別値は、C、ホストAは識別値をホストに漏れる可能性が第三者に漏れる可能性があります）ホストBにパケットを送信するために使用しました。付録Aは、詳細に、このような漏れのための1つの可能なシナリオについて説明します。"
    },
    {
      "indent": 0,
      "text": "5.2. Randomized Identification Values",
      "section_title": true,
      "ja": "5.2. ランダム化識別値"
    },
    {
      "indent": 3,
      "text": "Clearly, use of a Pseudorandom Number Generator for selecting the Identification would be desirable from a security standpoint. With such a scheme, the Identification of each fragmented datagram would be selected as:",
      "ja": "明らかに、識別を選択するための擬似乱数ジェネレータを使用すると、セキュリティの観点から望ましいであろう。このような方式で、それぞれの断片化されたデータグラムの同定は、以下のように選択されます。"
    },
    {
      "indent": 18,
      "text": "Identification = random()",
      "ja": "識別=ランダム（）"
    },
    {
      "indent": 3,
      "text": "where \"random()\" is the PRNG.",
      "ja": "ここで、「ランダム（）」PRNGです。"
    },
    {
      "indent": 3,
      "text": "The specific properties of such scheme would clearly depend on the specific PRNG employed. For example, some PRNGs may result in higher Identification reuse frequencies than others, in the same way that some PRNGs may be more expensive (in terms of processing requirements and/or implementation complexity) than others.",
      "ja": "そのような方式の具体的な性質は明らかに用いられる特定のPRNGに依存するであろう。例えば、いくつかのPRNGは、いくつかのPRNGが他よりも（処理要件および/または実装の複雑さの点で）より高価であってもよいのと同様に、他のものよりも高い識別の再使用周波数をもたらすことができます。"
    },
    {
      "indent": 3,
      "text": "Discussion of the properties of possible PRNGs is considered out of the scope of this document. However, we do note that some PRNGs employed in the past by some implementations have been found to be predictable [Klein2007]. Please see [RFC4086] for randomness requirements for security.",
      "ja": "可能性のPRNGの性質についての議論は、この文書の範囲外と考えられています。しかし、我々はいくつかの実装により、過去に採用し、いくつかのPRNGが[Klein2007]予測可能であることが判明していることに注意してください。セキュリティのためのランダム性要件については、[RFC4086]を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.3. Hash-Based Fragment Identification Selection Algorithm",
      "section_title": true,
      "ja": "5.3. ハッシュベースの断片の同定選択アルゴリズム"
    },
    {
      "indent": 3,
      "text": "Another alternative is to implement a hash-based algorithm similar to that specified in [RFC6056] for the selection of transport port numbers. With such a scheme, the Identification value of each fragmented datagram would be selected with the expression:",
      "ja": "別の代替は、トランスポートポート番号の選択のために[RFC6056]で指定されたものと同様のハッシュベースのアルゴリズムを実装することです。このような方式で、それぞれの断片化されたデータグラムの識別値は、式で選択されるであろう。"
    },
    {
      "indent": 3,
      "text": "Identification = F(Src IP, Dst IP, secret1) + counter[G(Src IP, Dst Pref, secret2)]",
      "ja": "識別= F（SRC IP、DstのIP、secret1）+カウンタ[G（SRC IP、Dstの県、secret2）]"
    },
    {
      "indent": 3,
      "text": "where:",
      "ja": "どこ："
    },
    {
      "indent": 3,
      "text": "Identification: Identification value to be used for the fragmented datagram.",
      "ja": "識別：断片化したデータグラムのために使用される識別値。"
    },
    {
      "indent": 3,
      "text": "F(): Hash function.",
      "ja": "F（）：ハッシュ関数。"
    },
    {
      "indent": 3,
      "text": "Src IP: IPv6 Source Address of the datagram to be fragmented.",
      "ja": "SrcのIP：断片化するためのデータグラムのIPv6のソースアドレス。"
    },
    {
      "indent": 3,
      "text": "Dst IP: IPv6 Destination Address of the datagram to be fragmented.",
      "ja": "DstのIP：断片化するためのデータグラムのIPv6宛先アドレス。"
    },
    {
      "indent": 3,
      "text": "secret1: Secret data unknown to the attacker. This value can be initialized to a pseudo-random value during the system bootstrapping sequence. It should remain constant at least while there could be previously sent fragments still in the network or at the fragment reassembly buffer of the corresponding destination system(s).",
      "ja": "secret1：攻撃者に知られていない秘密のデータ。この値は、システムのブートストラップシーケンス中に擬似ランダム値に初期化することができます。ネットワーク内または対応する宛先システム（S）の断片再組み立てバッファに依然として以前に送信されたフラグメントがある可能性があり、少なくともしつつ、一定のままであるべきです。"
    },
    {
      "indent": 3,
      "text": "counter[]: System-wide array of 32-bit counters (e.g. with 8K elements or more). Each counter should be initialized to a pseudo-random value during the system bootstrapping sequence.",
      "ja": "カウンタ[]：システム全体（8K要素または複数と例えば）32ビットカウンタのアレイ。各カウンタは、システムのブートストラップシーケンス中に擬似ランダム値に初期化されなければなりません。"
    },
    {
      "indent": 3,
      "text": "G(): Hash function. It may or may not be the same hash function as that used for F().",
      "ja": "G（）：ハッシュ関数。それはFために使用されるように、それは、同じハッシュ関数であってもなくてもよいです（）。"
    },
    {
      "indent": 3,
      "text": "Dst Pref: IPv6 \"Destination Prefix\" of the datagram to be fragmented (can be assumed to be the first eight bytes of the Destination Address of such packet). Note: the \"Destination Prefix\" (rather than Destination Address) is used, such that the ability of an attacker of searching the \"increments\" space by using multiple addresses of the same subnet is reduced.",
      "ja": "DST県：断片化されるデータグラムのIPv6の「宛先プレフィックス」（例えば、パケットの宛先アドレスの最初の8バイトであると仮定することができます）。注：「宛先プレフィックス」（むしろ宛先アドレスよりも）同じサブネットの複数のアドレスを使用して、「インクリメント」空間を探索するの攻撃の能力が低下するように、使用されています。"
    },
    {
      "indent": 3,
      "text": "secret2: Secret data unknown to the attacker. This value can be initialized to a pseudo-random value during the system bootstrapping sequence. It should remain constant at least while there could be previously sent fragments still in the network or at the fragment reassembly buffer of the corresponding destination system(s).",
      "ja": "secret2：攻撃者に知られていない秘密のデータ。この値は、システムのブートストラップシーケンス中に擬似ランダム値に初期化することができます。ネットワーク内または対応する宛先システム（S）の断片再組み立てバッファに依然として以前に送信されたフラグメントがある可能性があり、少なくともしつつ、一定のままであるべきです。"
    },
    {
      "indent": 3,
      "text": "NOTE: counter[G(src IP, Dst Pref, secret2)] should be incremented by one each time an Identification value is selected.",
      "ja": "注：カウンタ[G（SRC IP、Dstの県は、secret2）]つによって識別値が選択されるたびにインクリメントされるべきです。"
    },
    {
      "indent": 3,
      "text": "The output of F() will be constant for each (Src IP, Dst IP) pair. Similarly, the output of G() will be constant for each (Src IP, Dst Pref) pair. Thus, the resulting Identification value will be the result of a random offset plus a linear function (provided by counter[]), therefore resulting in a monotonically increasing sequence of Identification values for each (src IP, Dst IP) pair.",
      "ja": "F（）の出力は、それぞれ（SRC IP、IP Dstの）ペアのために一定になります。同様に、Gの出力（）はそれぞれ（SRC IP、Dstの県）対に対して一定です。したがって、得られた識別値は、したがって、それぞれ（SRC IP、DstのIP）対に対する識別値の単調に増加するシーケンスで得られた、ランダムオフセットプラス（カウンタによって提供される[]）線形関数の結果であろう。"
    },
    {
      "indent": 3,
      "text": "NOTE: F() essentially provides the unpredictability (by off-path attackers) of the resulting Identification values, while counter[] provides a linear function such that the Identification values are different for each fragmented packet while the Identification reuse frequency is minimized.",
      "ja": "注：カウンタが[]身分再利用頻度を最小限に抑えつつ識別値は、各フラグメントパケットのために異なるように線形関数を提供しながら、F（）は、本質的に、得られた識別値の（オフパス攻撃者によって）予測不可能性を提供します。"
    },
    {
      "indent": 3,
      "text": "The advantages of this algorithm are:",
      "ja": "このアルゴリズムの利点は、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o The Identification reuse frequency will typically be lower than that achieved by a global counter (when sending traffic to multiple destinations), since this algorithm uses multiple system-wide counters (rather than a single system-wide counter). The extent to which the reuse frequency will be lower depends on the number of elements in counter[], and the number of other active flows that result in the same value of G() (and hence cause the same counter to be incremented for each datagram that is fragmented).",
      "ja": "このアルゴリズムは、（むしろ単一システム全体カウンタより）は、複数のシステム全体のカウンタを使用しているため、（複数の宛先にトラフィックを送信する場合）O識別再利用周波数は、典型的にはグローバルカウンタによって達成されるものよりも低くなります。再使用周波数が低くされる程度）がカウンタ[]内の要素の数、及びG（同じ値をもたらす他のアクティブフローの数に依存する（したがって、同じカウンタごとにインクリメントさせます断片化されたデータグラム）。"
    },
    {
      "indent": 3,
      "text": "o It is possible to implement the algorithm such that good performance is achieved. For example, the result of F() could be stored in the Destination Cache (such that it need not be recomputed for each packet that must be sent) along with the computed index/argument for counter[].",
      "ja": "O良い性能が達成されるようなアルゴリズムを実装することが可能です。例えば、F（）の結果は[]カウンタの計算されたインデックス/引数と一緒に（それが送信されなければならないパケット毎に再計算する必要がないように）宛先キャッシュに記憶することができます。"
    },
    {
      "indent": 6,
      "text": "NOTE: If this implementation approach is followed, and an entry of the Destination Cache must be removed as a result of resource management, the last Identification value used for that Destination will *not* be lost. This is an improvement over the algorithm specified in Section 5.1.",
      "ja": "注：この実装アプローチが続いている、と宛先キャッシュのエントリは、資源管理の結果として除去する必要がある場合は、その先のために使用された最後の識別値が* *失われることはありません。これは、セクション5.1で指定されたアルゴリズムの改良です。"
    },
    {
      "indent": 3,
      "text": "The possible drawbacks of this algorithm are:",
      "ja": "このアルゴリズムの可能な欠点は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "o Since the Identification values are predictable by the destination host, a vulnerable host could possibly leak to third parties the Identification values used by other hosts to send traffic to it (i.e., Host B could leak to Host C the Identification values that Host A is using to send packets to Host B). Appendix A describes a possible scenario in which that information leakage could take place. We note, however, that this algorithm makes the aforementioned attack less reliable for the attacker, since each counter could be possibly shared by multiple traffic flows (i.e., packets destined to other destinations might cause the same counter to be incremented).",
      "ja": "識別値は、宛先ホストによって予測可能であるので、O、脆弱なホストは、おそらく、それ（すなわち、ホストBへのトラフィックを送信するために他のホストによって使用される識別値は、C、ホストAは識別値をホストに漏れる可能性が第三者に漏れる可能性が）ホストBにパケットを送信するために使用しました。付録Aは、情報漏洩が起こり得るいる可能なシナリオについて説明します。我々は（すなわち、他の宛先を宛先とするパケットは、同じカウンタがインクリメントされることがあります）、各カウンタは、おそらく複数のトラフィックフローによって共有される可能性があるので、このアルゴリズムは、前述の攻撃信頼性の低い攻撃者のためになること、しかし、注意してください。"
    },
    {
      "indent": 3,
      "text": "This algorithm might be preferable (over the one specified in Section 5.1) in those scenarios in which a node is expected to communicate with a large number of destinations, and thus it is desirable to limit the amount of information to be maintained in memory.",
      "ja": "このアルゴリズムは、ノードは宛先の多数と通信することが期待されているもののシナリオで（セクション5.1で指定された1つの上）が好ましいかもしれないので、メモリ内に維持される情報の量を制限することが望ましいです。"
    },
    {
      "indent": 3,
      "text": "NOTE: In such scenarios, if the algorithm specified in Section 5.1 were implemented, entries from the Destination Cache might need to be pruned frequently, thus increasing the risk of Identification \"collisions\".",
      "ja": "注：セクション5.1で指定されたアルゴリズムが実装された場合、このようなシナリオでは、宛先キャッシュのエントリは、このように識別「の衝突」のリスクを増加、頻繁に剪定する必要がある場合があります。"
    },
    {
      "indent": 0,
      "text": "6. Security Considerations",
      "section_title": true,
      "ja": "6.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document discusses the security implications of predictable Identification values, and provides implementation guidance such that the aforementioned security implications can be mitigated.",
      "ja": "この文書では、予測可能な識別値のセキュリティへの影響について説明し、前述のセキュリティへの影響を軽減することができるような実装ガイダンスを提供します。"
    },
    {
      "indent": 3,
      "text": "A number of possible algorithms are described, to provide some implementation alternatives to implementers. We note that the selection of such an algorithm usually implies a number of trade-offs (security, performance, implementation complexity, interoperability properties, etc.).",
      "ja": "可能なアルゴリズムの数は、実装にはいくつかの実装の選択肢を提供するために、説明されています。私たちは、このようなアルゴリズムの選択は通常、トレードオフ（セキュリティ、パフォーマンス、実装の複雑さ、相互運用性、など）の数を意味することに注意してください。"
    },
    {
      "indent": 0,
      "text": "7. References",
      "section_title": true,
      "ja": "7.参考"
    },
    {
      "indent": 0,
      "text": "7.1. Normative References",
      "section_title": true,
      "ja": "7.1. 引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC1981] McCann, J., Deering, S., and J. Mogul, \"Path MTU Discovery for IP version 6\", RFC 1981, DOI 10.17487/RFC1981, August 1996, <http://www.rfc-editor.org/info/rfc1981>.",
      "ja": "[RFC1981]マッキャン、J.、デアリング、S.、およびJ.ムガール人、RFC 1981 \"IPバージョン6のパスMTUディスカバリー\"、DOI 10.17487 / RFC1981、1996年8月、<のhttp：//www.rfc-editor。組織/情報/ rfc1981>。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<http://www.rfc-editor.org/info/ RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC2460] Deering, S. and R. Hinden, \"Internet Protocol, Version 6 (IPv6) Specification\", RFC 2460, DOI 10.17487/RFC2460, December 1998, <http://www.rfc-editor.org/info/rfc2460>.",
      "ja": "[RFC2460]デアリング、S.とR. Hindenと \"インターネットプロトコル、バージョン6（IPv6）の仕様\"、RFC 2460、DOI 10.17487 / RFC2460、1998年12月、<http://www.rfc-editor.org/info/ RFC2460>。"
    },
    {
      "indent": 3,
      "text": "[RFC4086] Eastlake 3rd, D., Schiller, J., and S. Crocker, \"Randomness Requirements for Security\", BCP 106, RFC 4086, DOI 10.17487/RFC4086, June 2005, <http://www.rfc-editor.org/info/rfc4086>.",
      "ja": "[RFC4086]イーストレーク3日、D.、シラー、J.、およびS.クロッカー、 \"セキュリティのためのランダム要件\"、BCP 106、RFC 4086、DOI 10.17487 / RFC4086、2005年6月、<HTTP：//www.rfc-editor .ORG /情報/ RFC4086>。"
    },
    {
      "indent": 3,
      "text": "[RFC4861] Narten, T., Nordmark, E., Simpson, W., and H. Soliman, \"Neighbor Discovery for IP version 6 (IPv6)\", RFC 4861, DOI 10.17487/RFC4861, September 2007, <http://www.rfc-editor.org/info/rfc4861>.",
      "ja": "[RFC4861] Narten氏、T.、Nordmarkと、E.、シンプソン、W.、およびH.ソリマン、 \"近隣探索IPバージョン6（IPv6）のために\"、RFC 4861、DOI 10.17487 / RFC4861、2007年9月、<のhttp：/ /www.rfc-editor.org/info/rfc4861>。"
    },
    {
      "indent": 3,
      "text": "[RFC5722] Krishnan, S., \"Handling of Overlapping IPv6 Fragments\", RFC 5722, DOI 10.17487/RFC5722, December 2009, <http://www.rfc-editor.org/info/rfc5722>.",
      "ja": "[RFC5722]クリシュナン、S.、 \"重複のIPv6フラグメントの取り扱い\"、RFC 5722、DOI 10.17487 / RFC5722、2009年12月、<http://www.rfc-editor.org/info/rfc5722>。"
    },
    {
      "indent": 3,
      "text": "[RFC6052] Bao, C., Huitema, C., Bagnulo, M., Boucadair, M., and X. Li, \"IPv6 Addressing of IPv4/IPv6 Translators\", RFC 6052, DOI 10.17487/RFC6052, October 2010, <http://www.rfc-editor.org/info/rfc6052>.",
      "ja": "[RFC6052]バオ、C.、のHuitema、C.、Bagnulo、M.、Boucadair、M.、およびX.李、RFC 6052、DOI 10.17487 / RFC6052、2010年10月の \"IPv6は、IPv4 / IPv6の翻訳者のアドレス指定\"、< http://www.rfc-editor.org/info/rfc6052>。"
    },
    {
      "indent": 3,
      "text": "[RFC6056] Larsen, M. and F. Gont, \"Recommendations for Transport-Protocol Port Randomization\", BCP 156, RFC 6056, DOI 10.17487/RFC6056, January 2011, <http://www.rfc-editor.org/info/rfc6056>.",
      "ja": "[RFC6056]ラーセン、M.とF. Gont、 \"トランスポート・プロトコルポートランダム化のための提言\"、BCP 156、RFC 6056、DOI 10.17487 / RFC6056、2011年1月、<http://www.rfc-editor.org/info / rfc6056>。"
    },
    {
      "indent": 3,
      "text": "[RFC6145] Li, X., Bao, C., and F. Baker, \"IP/ICMP Translation Algorithm\", RFC 6145, DOI 10.17487/RFC6145, April 2011, <http://www.rfc-editor.org/info/rfc6145>.",
      "ja": "[RFC6145]のLi、X.、バオ、C.、およびF.ベイカー、 \"IP / ICMP翻訳アルゴリズム\"、RFC 6145、DOI 10.17487 / RFC6145、2011年4月、<http://www.rfc-editor.org/情報/ rfc6145>。"
    },
    {
      "indent": 3,
      "text": "[RFC6946] Gont, F., \"Processing of IPv6 \"Atomic\" Fragments\", RFC 6946, DOI 10.17487/RFC6946, May 2013, <http://www.rfc-editor.org/info/rfc6946>.",
      "ja": "[RFC6946] Gont、F.、 \"処理のIPv6の \"アトミック\" フラグメント\"、RFC 6946、DOI 10.17487 / RFC6946、2013年5月、<http://www.rfc-editor.org/info/rfc6946>。"
    },
    {
      "indent": 0,
      "text": "7.2. Informative References",
      "section_title": true,
      "ja": "7.2. 参考文献"
    },
    {
      "indent": 3,
      "text": "[RFC4963] Heffner, J., Mathis, M., and B. Chandler, \"IPv4 Reassembly Errors at High Data Rates\", RFC 4963, DOI 10.17487/RFC4963, July 2007, <http://www.rfc-editor.org/info/rfc4963>.",
      "ja": "[RFC4963] Heffner、J.、マティス、M.、およびB.チャンドラー、 \"高速データレートでのIPv4の再構築エラー\"、RFC 4963、DOI 10.17487 / RFC4963、2007年7月、<のhttp：//www.rfc-editor。組織/情報/ rfc4963>。"
    },
    {
      "indent": 3,
      "text": "[RFC5927] Gont, F., \"ICMP Attacks against TCP\", RFC 5927, DOI 10.17487/RFC5927, July 2010, <http://www.rfc-editor.org/info/rfc5927>.",
      "ja": "[RFC5927] Gont、F.、 \"TCPに対するICMP攻撃\"、RFC 5927、DOI 10.17487 / RFC5927、2010年7月、<http://www.rfc-editor.org/info/rfc5927>。"
    },
    {
      "indent": 3,
      "text": "[RFC6274] Gont, F., \"Security Assessment of the Internet Protocol Version 4\", RFC 6274, DOI 10.17487/RFC6274, July 2011, <http://www.rfc-editor.org/info/rfc6274>.",
      "ja": "[RFC6274] Gont、F.、 \"インターネットプロトコルバージョン4のセキュリティ評価\"、RFC 6274、DOI 10.17487 / RFC6274、2011年7月、<http://www.rfc-editor.org/info/rfc6274>。"
    },
    {
      "indent": 3,
      "text": "[DEPGEN] Gont, F., Liu, S., and T. Anderson, \"Generation of IPv6 Atomic Fragments Considered Harmful\", Work in Progress, draft-ietf-6man-deprecate-atomfrag-generation-05, January 2016.",
      "ja": "【DEPGEN] Gont、F.、劉、S.、およびT.アンダーソン、 \"有害であると考えられたIPv6の原子断片の生成\"、進行中で働いて、ドラフトIETF-6manは、廃止-atomfrag世代-05、2016年1月。"
    },
    {
      "indent": 3,
      "text": "[Bellovin2002] Bellovin, S., \"A Technique for Counting NATted Hosts\", IMW'02 Nov. 6-8, 2002, Marseille, France, DOI 10.1145/637201.637243, 2002.",
      "ja": "【Bellovin2002] Bellovin氏、S.、 \"NATtedホストをカウントするための技術\"、IMW'02 11月6-8、2002、マルセイユ、フランス、DOI 10.1145 / 637201.637243 2002。"
    },
    {
      "indent": 3,
      "text": "[Fyodor2004] Lyon, G., \"TCP Idle Scan\", from Chapter 5 of \"Nmap Network Scanning\", 2004, <http://www.insecure.org/nmap/idlescan.html>.",
      "ja": "<http://www.insecure.org/nmap/idlescan.html> \"Nmapのネットワークスキャン\"、2004年の第5章から[Fyodor2004]リヨン、G.、 \"TCPアイドルスキャン\"、。"
    },
    {
      "indent": 3,
      "text": "[Herzberg2013] Herzberg, A. and H. Shulman, \"Fragmentation Considered Poisonous\", Technical Report 13-03, March 2013, <http://u.cs.biu.ac.il/~herzbea/security/13-03-frag.pdf>.",
      "ja": "[Herzberg2013]ヘルツベルク、A.およびH.シュルマン、 \"毒考慮フラグメンテーション\"、技術報告書13から03まで、2013年3月、<http://u.cs.biu.ac.il/~herzbea/security/13-03 -frag.pdf>。"
    },
    {
      "indent": 3,
      "text": "[Klein2007] Klein, A., \"OpenBSD DNS Cache Poisoning and Multiple O/S Predictable IP ID Vulnerability\", 2007, <http://www.trusteer.com/files/OpenBSD_DNS_Cache_Poisoning _and_Multiple_OS_Predictable_IP_ID_Vulnerability.pdf>.",
      "ja": "[Klein2007]クライン、A.、 \"OpenBSDのDNSキャッシュポイズニングと複数のO / S予測可能なIP IDの脆弱性\"、2007年、<http://www.trusteer.com/files/OpenBSD_DNS_Cache_Poisoning _and_Multiple_OS_Predictable_IP_ID_Vulnerability.pdf>。"
    },
    {
      "indent": 3,
      "text": "[Sanfilippo1998a] Sanfilippo, S., \"Subject: about the ip header id\", message to Bugtraq mailing list, 14 December 1998, <http://diswww.mit.edu/menelaus.mit.edu/bt/8704>.",
      "ja": "【Sanfilippo1998a]サンフィリポ、S.、 \"件名：IPヘッダIDについて\"、メッセージにBugtraqメーリングリストに、1998年12月14日、<http://diswww.mit.edu/menelaus.mit.edu/bt/8704>。"
    },
    {
      "indent": 3,
      "text": "[Sanfilippo1998b] Sanfilippo, S., \"Subject: new tcp scan method\", message to Bugtraq mailing list, 18 December 1998, <http://diswww.mit.edu/menelaus.mit.edu/bt/8736>.",
      "ja": "[Sanfilippo1998b]サンフィリッポ、S.、 \"件名：新しいTCPスキャン方式\"、メッセージにBugtraqメーリングリストに、1998年12月18日、<http://diswww.mit.edu/menelaus.mit.edu/bt/8736>。"
    },
    {
      "indent": 3,
      "text": "[Sanfilippo1999] Sanfilippo, S., \"Subject: more about IP ID\", message to Bugtraq mailing list, 20 November 1999, <http://diswww.mit.edu/menelaus.mit.edu/bt/12686>.",
      "ja": "[Sanfilippo1999]サンフィリッポ、S.、 \"件名：IP IDの詳細\"、にBugtraqメーリングリストへのメッセージ、1999年11月20日、<http://diswww.mit.edu/menelaus.mit.edu/bt/12686>。"
    },
    {
      "indent": 3,
      "text": "[SI6-IPv6] SI6 Networks, \"SI6 Networks' IPv6 Toolkit\", <http://www.si6networks.com/tools/ipv6toolkit>.",
      "ja": "[SI6-のIPv6] SI6ネットワークス、 \"SI6ネットワークスのIPv6のツールキット\"、<http://www.si6networks.com/tools/ipv6toolkit>。"
    },
    {
      "indent": 3,
      "text": "[Zalewski2003] Zalewski, M., \"Subject: A new TCP/IP blind data injection technique?\", message to Bugtraq mailing list, 11 December 2003, <http://lcamtuf.coredump.cx/ipfrag.txt>.",
      "ja": "[Zalewski2003] Zalewski氏、M.、 \"件名：？新しいTCP / IPブラインドデータ注入技術\"、にBugtraqメーリングリストへのメッセージ、2003年12月11日、<http://lcamt​​uf.coredump.cx/ipfrag.txt>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Information Leakage Produced by Vulnerable Implementations",
      "ja": "付録A.情報漏洩は、脆弱な実装プロデュース"
    },
    {
      "indent": 3,
      "text": "Section 3 provides a number of references describing a number of ways in which a vulnerable implementation may reveal the Identification values to be used in subsequent packets, thus opening the door to a number of attacks. In all of those scenarios, a vulnerable implementation leaks/reveals its own Identification number.",
      "ja": "セクション3は、脆弱な実装では、このような攻撃の数にドアを開け、その後のパケットで使用される識別値を明らかにすることができる多くの方法を説明する参照の数を提供します。これらのシナリオの全てにおいて、脆弱な実装漏れは/自分自身の識別番号を明らかにする。"
    },
    {
      "indent": 3,
      "text": "This section presents a different attack scenario, in which a vulnerable implementation leaks/reveals the Identification number of a non-vulnerable implementation. That is, a vulnerable implementation (Host A) leaks the current Identification value in use by a third-party host (Host B) to send fragmented datagrams from Host B to Host A.",
      "ja": "このセクションでは、脆弱な実装漏れ/非脆弱な実装の識別番号を明らかにした別の攻撃のシナリオを提示します。すなわち、脆弱な実装（ホストA）はAをホストするホストBからの断片化したデータグラムを送信するために、サードパーティのホスト（ホストB）で使用されている現在の識別値をリーク、あります"
    },
    {
      "indent": 3,
      "text": "NOTE: For the most part, this section is included to illustrate how a vulnerable implementation might be leveraged to leak out the Identification value of an otherwise non-vulnerable implementation.",
      "ja": "注：ほとんどの場合、このセクションは、脆弱な実装では、他の非脆弱な実装の識別値を漏出するために利用されるかもしれない方法を例示するために含まれています。"
    },
    {
      "indent": 3,
      "text": "The following scenarios assume:",
      "ja": "次のシナリオが想定しています。"
    },
    {
      "indent": 3,
      "text": "Host A: An IPv6 host that implements the algorithm specified in Section 5.1, implements [RFC5722], but does not implement [RFC6946].",
      "ja": "セクション5.1、実装[RFC5722]で指定されたアルゴリズムを実装していますが、[RFC6946]を実装していないIPv6ホスト：ホスト。"
    },
    {
      "indent": 3,
      "text": "Host B: Victim node. Selects the Identification values from a global counter.",
      "ja": "ホストB：被害者ノード。グローバルカウンタからの識別値を選択します。"
    },
    {
      "indent": 3,
      "text": "Host C: Attacker. Can forge the IPv6 Source Address of his packets at will.",
      "ja": "攻撃：Cをホストします。意志で彼のパケットのIPv6送信元アドレスを偽造することができます。"
    },
    {
      "indent": 3,
      "text": "In the following scenarios, large ICMPv6 Echo Request packets are employed to \"sample\" the Identification value of a host. We note that while the figures show only one packet for the ICMPv6 Echo Request and the ICMPv6 Echo Reply packets, each of those packets will typically comprise two fragments, such that the corresponding unfragmented datagram is larger than the MTU of the networks to which Host B and Host C are attached. Additionally, the following scenarios assume that Host A employs a Fragment Header when sending traffic to Host B (typically the so-called \"IPv6 atomic fragments\" [RFC6946]): this behavior may be triggered by forged ICMPv6 PTB messages that advertise an MTU smaller than 1280 bytes (assuming the victim still generates atomic fragments [DEPGEN]).",
      "ja": "次のシナリオでは、大ICMPv6エコー要求パケットは、「サンプル」ホストの識別値に使用されます。我々は、対応する断片化されていないデータグラムがどのホストBへのネットワークのMTUよりも大きくなるように、図面はICMPv6エコー要求およびICMPv6エコー応答パケット1つだけのパケットを示しているが、これらのパケットの各々は典型的には二つの断片を含むであろうことに注意してくださいそして、ホストCが取り付けられています。この現象は、小さなMTUを広告鍛造のICMPv6 PTBメッセージによってトリガすることができる。また、次のシナリオは、B（典型的には、いわゆる「IPv6の原子断片」[RFC6946]）をホストにトラフィックを送信するとき、ホストAがフラグメントヘッダを使用することを前提としていより1280バイト（被害者は依然としてアトミック断片[DEPGEN]を生成すると仮定して）。"
    },
    {
      "indent": 3,
      "text": "In lines #1-#2 (and lines #7-#8), the attacker samples the current Identification value at Host B. In line #3, the attacker sends a forged TCP SYN segment to Host A. In line 4, the attacker sends a forged TCP segment to Host B as an incomplete IPv6 fragmented datagram (e.g., a single fragment with Fragment Offset=0, More fragments=1). If corresponding TCP port is closed, and the attacker fails when trying to produce a collision of Identification values (see line #4), the following packet exchange might take place:",
      "ja": "回線＃3内のホストBでライン＃1〜＃2（及びライン＃7＃8）、攻撃者はサンプル電流識別値では、攻撃者が、ライン4においてA.をホストするために偽造TCP SYNセグメントを送信します。攻撃者は、不完全なIPv6の断片化されたデータグラムとしてBをホストするために偽造TCPセグメントを送信する（例えば、フラグメントオフセット= 0の単一のフラグメント、複数のフラグメント= 1）。対応するTCPポートが閉じられ、識別値の衝突を生成しようとすると、攻撃者が失敗した場合（ライン＃4を参照）、次のパケット交換が行われることがあります。"
    },
    {
      "indent": 7,
      "text": "A B C",
      "ja": "B C"
    },
    {
      "indent": 3,
      "text": "#1                              <------ Echo Req #1 -----------\n#2                              --- Echo Repl #1, FID=5000 --->\n#3  <------------------- SYN #1, src= B -----------------------\n#4                              <--- SYN/ACK, FID=42 src=A ----\n#5  ---- SYN/ACK, FID=9000 --->\n#6  <----- RST, FID= 5001 -----\n#7                              <-------- Echo Req #2 ---------\n#8                              --- Echo Repl #2, FID=5002 --->",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The RST segment in line #6 is elicited by the SYN/ACK segment from line #5 (illegitimately elicited by the SYN segment from line #3). The packet from line #4, sent as an incomplete IPv6 datagram, eventually times out.",
      "ja": "ライン＃6におけるRSTセグメントは、（不正回線＃3からのSYNセグメントによって誘発される）のライン＃5からのSYN / ACKセグメントにより誘発されます。回線＃4からのパケットは、最終的にタイムアウトし、不完全なIPv6データグラムとして送信されます。"
    },
    {
      "indent": 3,
      "text": "On the other hand, if the attacker succeeds to produce a collision of Identification values, the following packet exchange could take place:",
      "ja": "攻撃者が識別値の衝突を生成するために成功した場合一方、次のパケット交換が起こり得ます。"
    },
    {
      "indent": 7,
      "text": "A B C",
      "ja": "B C"
    },
    {
      "indent": 3,
      "text": "#1                              <------- Echo Req #1 ----------\n#2                              --- Echo Repl #1, FID=5000 --->\n#3  <------------------- SYN #1, src= B -----------------------\n#4                              <-- SYN/ACK, FID=9000 src=A ---\n#5  ---- SYN/ACK, FID=9000 --->\n                        ... (RFC5722) ...\n#6                              <------- Echo Req #2 ----------\n#7                              ---- Echo Repl #2, FID=5001 -->",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Clearly, the Identification value sampled from the second ICMPv6 Echo Reply packet (\"Echo Repl #2\") implicitly indicates whether the Identification value in the forged SYN/ACK (see line #4 in both figures) was the current Identification value in use by Host A.",
      "ja": "明らかに、第二ICMPv6エコー応答パケット（「エコーREPL＃2」）からサンプリングされた識別値は、暗黙的に鍛造SYN / ACKで識別値が（両方の図のライン＃4を参照）によって使用中の現在の識別値であったかどうかを示しますホストA."
    },
    {
      "indent": 3,
      "text": "As a result, the attacker could employ this technique to learn the current Identification value used by host A to send packets to host B, even when Host A itself has a non-vulnerable implementation.",
      "ja": "その結果、攻撃者は、ホストA自体が非脆弱な実装であっても、ホストBにパケットを送信するホストAによって使用される現在の識別値を学習するためにこの技術を採用することができました。"
    },
    {
      "indent": 0,
      "text": "Appendix B. Survey of Fragment Identification Selection Algorithms Employed by Popular IPv6 Implementations",
      "ja": "人気のIPv6の実装で採用断片の同定選択アルゴリズムの付録B.調査"
    },
    {
      "indent": 3,
      "text": "This section includes a survey of the Identification selection algorithms employed by some popular operating systems.",
      "ja": "このセクションでは、いくつかの一般的なオペレーティングシステムで使用される識別選択アルゴリズムの調査を含んでいます。"
    },
    {
      "indent": 3,
      "text": "NOTE: The survey was produced with the SI6 Networks' IPv6 toolkit [SI6-IPv6].",
      "ja": "注：調査はSI6ネットワークスのIPv6のツールキット[SI6-のIPv6]で製造しました。"
    },
    {
      "indent": 3,
      "text": "+------------------------------+------------------------------------+\n|       Operating System       |             Algorithm              |\n+------------------------------+------------------------------------+\n|        Cisco IOS 15.3        |    Predictable (Global Counter,    |\n|                              |          Init=0, Incr=1)           |\n+------------------------------+------------------------------------+\n|         FreeBSD 9.0          |       Unpredictable (Random)       |\n+------------------------------+------------------------------------+\n|        Linux 3.0.0-15        |    Predictable (Global Counter,    |\n|                              |          Init=0, Incr=1)           |\n+------------------------------+------------------------------------+\n|        Linux-current         |  Unpredictable (Per-dest Counter,  |\n|                              |        Init=random, Incr=1)        |\n+------------------------------+------------------------------------+\n|          NetBSD 5.1          |       Unpredictable (Random)       |\n+------------------------------+------------------------------------+\n|       OpenBSD-current        |   Unpredictable (Random, SKIP32)   |\n+------------------------------+------------------------------------+\n|          Solaris 10          |   Predictable (Per-dst Counter,    |\n|                              |          Init=0, Incr=1)           |\n+------------------------------+------------------------------------+\n|        Windows XP SP2        |    Predictable (Global Counter,    |\n|                              |          Init=0, Incr=2)           |\n+------------------------------+------------------------------------+\n|   Windows XP Professional    |    Predictable (Global Counter,    |\n|          32bit, SP3          |          Init=0, Incr=2)           |\n+------------------------------+------------------------------------+\n|  Windows Vista (Build 6000)  |    Predictable (Global Counter,    |\n|                              |          Init=0, Incr=2)           |\n+------------------------------+------------------------------------+\n|    Windows Vista Business    |    Predictable (Global Counter,    |\n|          64bit, SP1          |          Init=0, Incr=2)           |\n+------------------------------+------------------------------------+\n|    Windows 7 Home Premium    |    Predictable (Global Counter,    |\n|                              |          Init=0, Incr=2)           |\n+------------------------------+------------------------------------+\n|    Windows Server 2003 R2    |    Predictable (Global Counter,    |\n|     Standard 64bit, SP2      |          Init=0, Incr=2)           |",
      "raw": true
    },
    {
      "indent": 3,
      "text": "+------------------------------+------------------------------------+\n| Windows Server 2008 Standard |    Predictable (Global Counter,    |\n|          32bit, SP1          |          Init=0, Incr=2)           |\n+------------------------------+------------------------------------+\n|    Windows Server 2008 R2    |    Predictable (Global Counter,    |\n|     Standard 64bit, SP1      |          Init=0, Incr=2)           |\n+------------------------------+------------------------------------+\n| Windows Server 2012 Standard |    Predictable (Global Counter,    |\n|            64bit             |          Init=0, Incr=2)           |\n+------------------------------+------------------------------------+\n|    Windows 7 Home Premium    |    Predictable (Global Counter,    |\n|          32bit, SP1          |          Init=0, Incr=2)           |\n+------------------------------+------------------------------------+\n|  Windows 7 Ultimate 32bit,   |    Predictable (Global Counter,    |\n|             SP1              |          Init=0, Incr=2)           |\n+------------------------------+------------------------------------+\n| Windows 8 Enterprise 32 bit  |  Unpredictable (Alg. from Section  |\n|                              |                5.3)                |\n+------------------------------+------------------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Table 1: Fragment Identification algorithms employed by different OSs",
      "ja": "表1：異なるOSで採用フラグメント識別アルゴリズム"
    },
    {
      "indent": 3,
      "text": "NOTE: In the text above, \"predictable\" should be taken as \"easily guessable by an off-path attacker, by sending a few probe packets\".",
      "ja": "注：上記のテキストでは、「予測可能」は「少数のプローブパケットを送信することによって、オフ・パス攻撃者によって容易に推測」として解釈されるべきです。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "The author would like to thank Ivan Arce for proposing the attack scenario described in Appendix A.",
      "ja": "著者は、付録Aで説明した攻撃のシナリオを提案するためイワンアルセに感謝したいと思います"
    },
    {
      "indent": 3,
      "text": "The author would like to thank Ivan Arce, Stephen Bensley, Ron Bonica, Tassos Chatzithomaoglou, Guillermo Gont, Brian Haberman, Bob Hinden, Sheng Jiang, Tatuya Jinmei, Merike Kaeo, Will Liu, Juan Antonio Matos, Simon Perreault, Hosnieh Rafiee, Meral Shirazipour, Mark Smith, Dave Thaler, and Klaas Wierenga, for providing valuable comments on earlier draft versions of this document.",
      "ja": "著者はイワンアルセ、スティーブンBensley、ロンBonica、Tassos Chatzithomaoglou、ギジェルモGont、ブライアンハーバーマン、ボブHindenとシェン・ジャン、達也神明、Merike Kaeoの、ウィル・リュー、フアン・アントニオ・マトス、サイモン・ペロー、Hosnieh Rafiee、Meralに感謝したいと思いますShirazipour、マーク・スミス、デーブターラー、およびクラースWierenga、このドキュメントの以前のドラフトバージョンに貴重なコメントを提供するため。"
    },
    {
      "indent": 3,
      "text": "This document is based on work performed by Fernando Gont on behalf of the UK Centre for the Protection of National Infrastructure (CPNI).",
      "ja": "この文書は、国家インフラの保護に関する英国センター（CPNI）に代わってフェルナンドGontによって実行される作業に基づいています。"
    },
    {
      "indent": 3,
      "text": "The author would like to thank Buffy for her love and support.",
      "ja": "著者は彼女の愛と支援のためのバフィーに感謝したいと思います。"
    },
    {
      "indent": 0,
      "text": "Author's Address",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Fernando Gont Huawei Technologies Evaristo Carriego 2644 Haedo, Provincia de Buenos Aires 1706 Argentina",
      "ja": "フェルナンドGont華為技術エバリスト・キャリエゴ2644 Haedo、1706ブエノスアイレス州アルゼンチン"
    },
    {
      "indent": 3,
      "text": "Phone: +54 11 4650 8472 Email: fgont@si6networks.com URI: http://www.si6networks.com",
      "ja": "電話：+54 11 4650 8472 Eメール：fgont@si6networks.com URI：http://www.si6networks.com"
    }
  ]
}