{
  "title": {
    "text": "RFC 7765 - TCP and Stream Control Transmission Protocol (SCTP) RTO Restart",
    "ja": "RFC 7765 - TCPおよびストリーム制御伝送プロトコル（SCTP）RTOの再起動"
  },
  "number": 7765,
  "created_at": "2019-11-02 04:41:20.708120+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                         P. Hurtig\nRequest for Comments: 7765                                  A. Brunstrom\nCategory: Experimental                               Karlstad University\nISSN: 2070-1721                                               A. Petlund\n                                           Simula Research Laboratory AS\n                                                                M. Welzl\n                                                      University of Oslo\n                                                           February 2016",
      "raw": true
    },
    {
      "indent": 4,
      "text": "TCP and Stream Control Transmission Protocol (SCTP) RTO Restart",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document describes a modified sender-side algorithm for managing the TCP and Stream Control Transmission Protocol (SCTP) retransmission timers that provides faster loss recovery when there is a small amount of outstanding data for a connection. The modification, RTO Restart (RTOR), allows the transport to restart its retransmission timer using a smaller timeout duration, so that the effective retransmission timeout (RTO) becomes more aggressive in situations where fast retransmit cannot be used. This enables faster loss detection and recovery for connections that are short lived or application limited.",
      "ja": "この文書では、接続のための優れた少量のデータがある場合に速い損失回復を提供してTCPおよびストリーム制御伝送プロトコル（SCTP）再送信タイマーを管理するための改良送信側アルゴリズムを記述しています。変形、RTO再起動（RTOR）は、トランスポートが有効な再送タイムアウト（RTO）が高速再送信を使用することができない状況では、より積極的になるように、より小さいタイムアウト期間を使用して再送タイマーを再起動することを可能にします。これは短命やアプリケーション制限されている接続のためのより高速な損失検出および回復を可能にします。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for examination, experimental implementation, and evaluation.",
      "ja": "このドキュメントはインターネット標準化過程仕様ではありません。それは、検査、実験的な実装、および評価のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document defines an Experimental Protocol for the Internet community. This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are a candidate for any level of Internet Standard; see Section 2 of RFC 5741.",
      "ja": "この文書は、インターネットコミュニティのためにExperimentalプロトコルを定義します。このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。 IESGによって承認されていないすべての文書がインターネットStandardのどんなレベルの候補です。 RFC 5741のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7765.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7765で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2016 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2016 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3\n2.  Terminology . . . . . . . . . . . . . . . . . . . . . . . . .   4\n3.  RTO Overview and Rationale for RTOR . . . . . . . . . . . . .   4\n4.  RTOR Algorithm  . . . . . . . . . . . . . . . . . . . . . . .   6\n5.  Discussion  . . . . . . . . . . . . . . . . . . . . . . . . .   7\n  5.1.  Applicability . . . . . . . . . . . . . . . . . . . . . .   7\n  5.2.  Spurious Timeouts . . . . . . . . . . . . . . . . . . . .   7\n  5.3.  Tracking Outstanding and Previously Unsent Segments . . .   8\n6.  Related Work  . . . . . . . . . . . . . . . . . . . . . . . .   9\n7.  SCTP Socket API Considerations  . . . . . . . . . . . . . . .  10\n  7.1.  Data Types  . . . . . . . . . . . . . . . . . . . . . . .  10\n  7.2.  Socket Option for Controlling the RTO Restart Support\n        (SCTP_RTO_RESTART)  . . . . . . . . . . . . . . . . . . .  10\n8.  Security Considerations . . . . . . . . . . . . . . . . . . .  11\n9.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  11\n  9.1.  Normative References  . . . . . . . . . . . . . . . . . .  11\n  9.2.  Informative References  . . . . . . . . . . . . . . . . .  13\nAcknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  14\nAuthors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  15",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "TCP and SCTP use two almost identical mechanisms to detect and recover from data loss, specified in [RFC6298] and [RFC5681] for TCP and [RFC4960] for SCTP. First, if transmitted data is not acknowledged within a certain amount of time, a retransmission timeout (RTO) occurs and the data is retransmitted. While the RTO is based on measured round-trip times (RTTs) between the sender and receiver, it also has a conservative lower bound of 1 second to ensure that delayed data are not mistaken as lost. Second, when a sender receives duplicate acknowledgments or similar information via selective acknowledgments, the fast retransmit algorithm suspects data loss and can trigger a retransmission. Duplicate (and selective) acknowledgments are generated by a receiver when data arrives out of order. As both data loss and data reordering cause out-of-order arrival, fast retransmit waits for three out-of-order notifications before considering the corresponding data as lost. In some situations, however, the amount of outstanding data is not enough to trigger three such acknowledgments, and the sender must rely on lengthy RTOs for loss recovery.",
      "ja": "TCPとSCTPは、検出およびSCTPのデータ[RFC6298]で指定された損失、及び[RFC5681] TCPおよび[RFC4960]から回復するために、2つの略同一のメカニズムを使用します。送信されたデータは、一定の時間内に確認されない場合、最初に、再送タイムアウト（RTO）が発生し、データが再送されます。 RTOは、送信側と受信側の間で測定された往復時間（のRTT）に基づいている間、それはまた、失われたように、遅延データが間違っていないことを保証するために、1秒の下限同類を有します。送信者が選択的確認応答を経由して、重複確認応答や同様の情報を受信したときに第二に、高速再送アルゴリズムは、データの損失を疑うし、再送をトリガすることができます。複製（及び選択的）データが順不同で到着したときに確認応答が受信機によって生成されます。データの損失やデータの両方がアウトオブオーダー到着原因を並べ替えると、高速再送が失われたとして、対応するデータを検討する前に、3アウトオブオーダーの通知を待ちます。いくつかの状況では、しかし、優れたデータの量は、3つのこのような確認応答を引き起こすのに十分ではない、と送信者が損失回復のために長いのRTOに依存する必要があります。"
    },
    {
      "indent": 3,
      "text": "The amount of outstanding data can be small for several reasons:",
      "ja": "優れたデータの量は、いくつかの理由のために小さいことができます："
    },
    {
      "indent": 3,
      "text": "(1) The connection is limited by congestion control when the path has a low total capacity (bandwidth-delay product) or the connection's share of the capacity is small. It is also limited by congestion control in the first few RTTs of a connection or after an RTO when the available capacity is probed using slow-start.",
      "ja": "（1）接続は、パスが低い総容量（帯域幅遅延積）を有するか、または容量の接続のシェアが小さい場合、輻輳制御により制限されます。また、接続の最初のいくつかのRTTまたは利用可能な容量がスロースタートを用いてプローブされるRTO後の輻輳制御により制限されます。"
    },
    {
      "indent": 3,
      "text": "(2) The connection is limited by the receiver's available buffer space.",
      "ja": "（2）接続は、受信機の利用可能なバッファスペースによって制限されます。"
    },
    {
      "indent": 3,
      "text": "(3) The connection is limited by the application if the available capacity of the path is not fully utilized (e.g., interactive applications) or is at the end of a transfer.",
      "ja": "（3）接続は、パスの利用可能な容量が十分に利用されていない場合（例えば、対話型アプリケーション）アプリケーションによって制限または転送の終了時です。"
    },
    {
      "indent": 3,
      "text": "While the reasons listed above are valid for any flow, the third reason is most common for applications that transmit short flows or use a bursty transmission pattern. A typical example of applications that produce short flows are web-based applications. [RJ10] shows that 70% of all web objects, found at the top 500 sites, are too small for fast retransmit to work. [FDT13] shows that about 77% of all retransmissions sent by a major web service are sent after RTO expiry. Applications with bursty transmission patterns often send data in response to actions or as a reaction to real life events. Typical examples of such applications are stock-trading systems, remote computer operations, online games, and web-based applications using persistent connections. What is special about this class of applications is that they are often time dependent, and extra latency can reduce the application service level [P09].",
      "ja": "上記の理由が任意のフローのために有効であるが、第三の理由は、短いフローを送信又はバースト送信パターンを使用するアプリケーションのために最も一般的です。短い流れを生成するアプリケーションの典型的な例は、ウェブベースのアプリケーションです。 [RJ10]トップ500のサイトで見つかったすべてのWebオブジェクトの70％が、高速再送が機能するためには小さすぎることを示しています。 [FDT13]主要なWebサービスによって送信されたすべての再送信の約77％がRTOの満了後に送信されることを示しています。バースト性送信パターンを持つアプリケーションでは、多くの場合、アクションに応じて、または実際のライフイベントに対する反応としてデータを送信します。このようなアプリケーションの典型的な例は、持続的な接続を使用して株式取引システム、リモートコンピュータの操作、オンラインゲーム、およびWebベースのアプリケーションです。どのようなアプリケーションのこのクラスに関する特別なことは、彼らは多くの場合、時間に依存していることで、余分な待ち時間は、アプリケーション・サービス・レベル[P09]を減らすことができます。"
    },
    {
      "indent": 3,
      "text": "The RTO Restart (RTOR) mechanism described in this document makes the effective RTO slightly more aggressive when the amount of outstanding data is too small for fast retransmit to work, in an attempt to enable faster loss recovery while being robust to reordering. While RTOR still conforms to the requirement for when a segment can be retransmitted, specified in [RFC6298] for TCP and [RFC4960] for SCTP, it could increase the risk of spurious timeouts. To determine whether this modification is safe to deploy and enable by default, further experimentation is required. Section 5 discusses experiments still needed, including evaluations in environments where the risk of spurious retransmissions are increased, e.g., mobile networks with highly varying RTTs.",
      "ja": "優れたデータの量は、並べ替えに堅牢でありながら、より高速な損失回復を可能にするための試みで、高速再送を機能させるには小さすぎる場合、この文書で説明するRTOを再起動します（RTOR）メカニズムはもう少し積極的な効果的なRTOになります。 RTORまだSCTPのためにTCPと[RFC4960]のために[RFC6298]で指定されたセグメントを再送することができる場合の要件に準拠しながら、それがスプリアスタイムアウトのリスクを高める可能性があります。この変更は、展開して、デフォルトで有効化しても安全であるかどうかを判断するには、さらなる実験が必要です。第5節では、例えば、スプリアス再送のリスクが増加している環境での評価、高度のRTTを変化させたモバイルネットワークなど、まだ必要な実験を、説明します。"
    },
    {
      "indent": 3,
      "text": "The remainder of this document describes RTOR and its implementation for TCP only, to make the document easier to read. However, the RTOR algorithm described in Section 4 is applicable also for SCTP. Furthermore, Section 7 details the SCTP socket API needed to control RTOR.",
      "ja": "このドキュメントの残りの部分は読み文書を容易にするために、RTORのみTCPのためにその実装について説明します。しかし、第4節で説明RTORアルゴリズムはSCTPのためにも適用可能です。さらに、第7節はRTORを制御するために必要なSCTPソケットAPIの詳細について説明します。"
    },
    {
      "indent": 0,
      "text": "2. Terminology",
      "section_title": true,
      "ja": "2.用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [RFC2119].",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はRFC 2119 [RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 3,
      "text": "This document introduces the following variables:",
      "ja": "このドキュメントでは、次の変数が導入されています。"
    },
    {
      "indent": 3,
      "text": "o The number of previously unsent segments (prevunsnt): The number of segments that a sender has queued for transmission, but has not yet sent.",
      "ja": "O以前に未送信のセグメント（prevunsnt）の数：送信者が送信のためにキューに入れられたが、まだ送信していないセグメントの数。"
    },
    {
      "indent": 3,
      "text": "o RTO Restart threshold (rrthresh): RTOR is enabled whenever the sum of the number of outstanding and previously unsent segments (prevunsnt) is below this threshold.",
      "ja": "O RTO再起動閾値（rrthresh）：未処理及び以前に未送信のセグメント（prevunsnt）の数の合計がこのしきい値を下回っているときはいつでもRTORが有効になっています。"
    },
    {
      "indent": 0,
      "text": "3. RTO Overview and Rationale for RTOR",
      "section_title": true,
      "ja": "RTOR 3. RTOの概要と理論的根拠"
    },
    {
      "indent": 3,
      "text": "The RTO management algorithm described in [RFC6298] recommends that the retransmission timer be restarted when an acknowledgment (ACK) that acknowledges new data is received and there is still outstanding data. The restart is conducted to guarantee that unacknowledged segments will be retransmitted after approximately RTO seconds. The standardized RTO timer management is illustrated in Figure 1, where a TCP sender transmits three segments to a receiver. The arrival of the first and second segment triggers a delayed ACK (delACK) [RFC1122], which restarts the RTO timer at the sender. The RTO is restarted approximately one RTT after the transmission of the third segment. Thus, if the third segment is lost, as indicated in Figure 1, the effective loss detection time becomes \"RTO + RTT\" seconds. In some situations, the effective loss detection time becomes even longer. Consider a scenario where only two segments are outstanding. If the second segment is lost, the time to expire the delACK timer will also be included in the effective loss detection time.",
      "ja": "[RFC6298]で説明RTO管理アルゴリズムは、新しいデータを肯定応答する肯定応答（ACK）が受信され、未処理のデータが残っている場合、再送タイマーを再起動することをお勧めします。再起動が未確認のセグメントが約RTO秒後に再送信されることを保証するために行われます。標準化されたRTOタイマ管理は、TCPの送信側が受信側に三つのセグメントを送信する図1に示​​されています。第一及び第二のセグメントの到着は、送信側でRTOタイマを再起動遅延ACK（delACK）[RFC1122]を、トリガー。 RTOは、第3のセグメントの送信後およそRTT再開されます。図1に示すように、第3のセグメントは、失われた場合にこのように、効果的な損失の検出時間は、「RTO + RTT」秒となります。いくつかの状況では、効果的な損失の検出時間はさらに長くなります。 2つのだけのセグメントが傑出しているシナリオを考えてみましょう。第二セグメントが失われた場合、delACKタイマーを期限切れにするための時間も有効損失検出時間に含まれます。"
    },
    {
      "indent": 12,
      "text": "Sender                               Receiver\n              ...\nDATA [SEG 1] ----------------------> (ack delayed)\nDATA [SEG 2] ----------------------> (send ack)\nDATA [SEG 3] ----X         /-------- ACK\n(restart RTO)  <----------/\n              ...\n(RTO expiry)\nDATA [SEG 3] ---------------------->",
      "raw": true
    },
    {
      "indent": 23,
      "text": "Figure 1: RTO Restart Example",
      "ja": "図1：RTO再起動例"
    },
    {
      "indent": 3,
      "text": "For bulk traffic, the current approach is beneficial -- it is described in [EL04] to act as a \"safety margin\" that compensates for some of the problems that the authors have identified with the standard RTO calculation. Notably, the authors of [EL04] also state that \"this safety margin does not exist for highly interactive applications where often only a single packet is in flight.\" In general, however, as long as enough segments arrive at a receiver to enable fast retransmit, RTO-based loss recovery should be avoided. RTOs should only be used as a last resort, as they drastically lower the congestion window as compared to fast retransmit.",
      "ja": "バルクトラフィックの場合、現在のアプローチが有益である - 著者は、標準のRTO計算で確認している問題の一部を補償し、「安全マージン」として機能するように[EL04]に記載されています。注目すべきは、[EL04]の著者はまた、「この安全マージンは、多くの場合、単一のパケットが飛行している高度にインタラクティブなアプリケーションのために存在していません。」と述べています一般的に、しかし、十分な長さのセグメントが高速再送信を可能にするために受信機に到着するように、RTOベースの損失回復は避けるべきです。高速再送と比較して、彼らは大幅に輻輳ウィンドウを下げるようなRTOSは、最後の手段として使用されるべきです。"
    },
    {
      "indent": 3,
      "text": "Although fast retransmit is preferable, there are situations where timeouts are appropriate or are the only choice. For example, if the network is severely congested and no segments arrive, RTO-based recovery should be used. In this situation, the time to recover from the loss(es) will not be the performance bottleneck. However, for connections that do not utilize enough capacity to enable fast retransmit, RTO-based loss detection is the only choice, and the time required for this can become a performance bottleneck.",
      "ja": "高速再送が好ましいが、タイムアウトが適切であるか唯一の選択肢である状況があります。ネットワークがひどく輻輳していると何のセグメントが到着しない場合、例えば、RTOベースのリカバリを使用すべきです。このような状況では、損失（ES）から回復する時間は、パフォーマンスのボトルネックになることはありません。しかし、高速再送を可能にするのに十分な容量を利用しない接続のために、RTOベースの損失の検出が唯一の選択肢であり、このために必要な時間は、パフォーマンスのボトルネックになることができます。"
    },
    {
      "indent": 0,
      "text": "4. RTOR Algorithm",
      "section_title": true,
      "ja": "4. RTORアルゴリズム"
    },
    {
      "indent": 3,
      "text": "To enable faster loss recovery for connections that are unable to use fast retransmit, RTOR can be used. This section specifies the modifications required to use RTOR. By resetting the timer to \"RTO - T_earliest\", where T_earliest is the time elapsed since the earliest outstanding segment was transmitted, retransmissions will always occur after exactly RTO seconds.",
      "ja": "高速再送を使用することができない接続のためのより高速な損失回復を有効にするには、RTORを使用することができます。このセクションでは、RTORを使用するために必要な変更を指定します。タイマーリセットすること -  T_earliestが早い優れたセグメントを送信してからの経過時間である「RTO T_earliest」を、再送信は、常に正確にRTO秒後に発生します。"
    },
    {
      "indent": 3,
      "text": "This document specifies an OPTIONAL sender-only modification to TCP and SCTP, which updates step 5.3 in Section 5 of [RFC6298] (and a similar update in Section 6.3.2 of [RFC4960] for SCTP). A sender that implements this method MUST follow the algorithm below:",
      "ja": "この文書では、更新は、[RFC6298]のセクション5で5.3ステップTCPとSCTPのOPTIONAL送信側のみの変更、（およびSCTPのために[RFC4960]のセクション6.3.2に類似更新）を指定します。このメソッドを実装して、送信者は、以下のアルゴリズムに従う必要があります。"
    },
    {
      "indent": 6,
      "text": "When an ACK is received that acknowledges new data:",
      "ja": "ACKが受信されると、それは新しいデータを承認します："
    },
    {
      "indent": 6,
      "text": "(1) Set T_earliest = 0.",
      "ja": "（1）セットT_earliest = 0。"
    },
    {
      "indent": 6,
      "text": "(2) If the sum of the number of outstanding and previously unsent segments (prevunsnt) is less than an RTOR threshold (rrthresh), set T_earliest to the time elapsed since the earliest outstanding segment was sent.",
      "ja": "未処理の数及び以前に未送信のセグメント（prevunsnt）の合計がRTOR閾値（rrthresh）未満である場合（2）、T_earliestは最古未処理のセグメントが送信されてからの経過時間に設定されます。"
    },
    {
      "indent": 6,
      "text": "(3) Restart the retransmission timer so that it will expire after (for the current value of RTO):",
      "ja": "それは（RTOの現在値のため）後に期限切れになるように、（3）再送タイマーを再起動します。"
    },
    {
      "indent": 11,
      "text": "(a) RTO - T_earliest, if RTO - T_earliest > 0.",
      "ja": "（A）RTO  -  T_earliest、RTO場合 -  T_earliest> 0。"
    },
    {
      "indent": 11,
      "text": "(b) RTO, otherwise.",
      "ja": "（B）RTO、さもなければ。"
    },
    {
      "indent": 3,
      "text": "The RECOMMENDED value of rrthresh is four, as this value will ensure that RTOR is only used when fast retransmit cannot be triggered. With this update, TCP implementations MUST track the time elapsed since the transmission of the earliest outstanding segment (T_earliest). As RTOR is only used when the amount of outstanding and previously unsent data is less than rrthresh segments, TCP implementations also need to track whether the amount of outstanding and previously unsent data is more, equal, or less than rrthresh segments. Although some packet-based TCP implementations (e.g., Linux TCP) already track both the transmission times of all segments and also the number of outstanding segments, not all implementations do. Section 5.3 describes how to implement segment tracking for a general TCP implementation. To use RTOR, the calculated expiration time MUST be positive (step 3(a) in the list above); this is required to ensure that RTOR does not trigger retransmissions prematurely when previously retransmitted segments are acknowledged.",
      "ja": "rrthreshの推奨値は、高速再送信をトリガすることができない場合にのみ使用されることRTORを保証します。この値として、4です。この更新で、TCP実装は、最も早い未処理セグメント（T_earliest）の送信からの経過時間を追跡しなければなりません。卓越した以前未送信データの量がrrthreshセグメントよりも小さい場合RTORのみ使用されるように、TCPの実装はまた、未処理の、以前未送信データの量がrrthreshセグメントよりも、より多くの同等、またはそれ以下であるかどうかを追跡する必要があります。いくつかのパケットベースのTCPの実装が（例えば、LinuxのTCP）が既に全てのセグメントの送信時間とも抜群のセグメントの数の両方を追跡し、すべての実装はありません。 5.3節では、一般的なTCPの実装のためのセグメントトラッキングを実装する方法について説明します。 RTORを使用するように、算出された有効期限は正でなければならない（ステップ3（A）上記リスト内）これは、以前に再送されたセグメントが確認された場合RTORが早期再送信をトリガしないことを保証するために必要とされます。"
    },
    {
      "indent": 0,
      "text": "5. Discussion",
      "section_title": true,
      "ja": "5.ディスカッション"
    },
    {
      "indent": 3,
      "text": "Although RTOR conforms to the requirement in [RFC6298] that segments must not be retransmitted earlier than RTO seconds after their original transmission, RTOR makes the effective RTO more aggressive. In this section, we discuss the applicability and the issues related to RTOR.",
      "ja": "RTORはセグメントは、元の送信後、以前のRTO秒以上再送してはならないこと[RFC6298]での要件に準拠しますが、RTORは、効果的なRTOがより積極的になります。このセクションでは、適用性とRTORに関連する問題を議論します。"
    },
    {
      "indent": 0,
      "text": "5.1. Applicability",
      "section_title": true,
      "ja": "5.1。適用性"
    },
    {
      "indent": 3,
      "text": "The currently standardized algorithm has been shown to add at least one RTT to the loss recovery process in TCP [LS00] and SCTP [HB11] [PBP09]. For applications that have strict timing requirements (e.g., interactive web) rather than throughput requirements, using RTOR could be beneficial because the RTT and the delACK timer of receivers are often large components of the effective loss recovery time. Measurements in [HB11] have shown that the total transfer time of a lost segment (including the original transmission time and the loss recovery time) can be reduced by 35% using RTOR. These results match those presented in [PGH06] and [PBP09], where RTOR is shown to significantly reduce retransmission latency.",
      "ja": "現在、標準化されたアルゴリズムは、TCP [LS00]とSCTP [HB11] [PBP09]に損失回復過程に少なくとも一つのRTTを追加することが示されています。 RTTと受信機のdelACKタイマーがしばしば効果的な損失回復時間の大きな部品であるため、厳密なタイミング要件（例えば、インタラクティブウェブ）よりもむしろスループット要件を有する用途のために、RTORを使用することが有益であり得ます。 [HB11]での測定は、（元の送信時間と損失回復時間を含む）失われたセグメントの総転送時間がRTORを使用して35％低減することができることを示しています。これらの結果は、RTORが著しく再送待ち時間を減少させることが示されている。ここで、[PBP09] [PGH06]および提示されたものと一致します。"
    },
    {
      "indent": 3,
      "text": "There are also traffic types that do not benefit from RTOR. One example of such traffic is bulk transmission. The reason why bulk traffic does not benefit from RTOR is that such traffic flows mostly have four or more segments outstanding, allowing loss recovery by fast retransmit. However, there is no harm in using RTOR for such traffic as the algorithm is only active when the amount of outstanding and unsent segments are less than rrthresh (default 4).",
      "ja": "RTORの恩恵を受けないトラフィックタイプもあります。そのようなトラフィックの一例は、バルク送信です。バルクトラフィックがRTORから利益を得ていない理由は、そのようなトラフィックのほとんどは、高速再送による損失の回復を可能にし、優れた4つの以上のセグメントを持って流れていることです。しかし、未処理および未送信のセグメントの量はrrthresh（デフォルト4）未満である場合、アルゴリズムは、唯一の活性であるようなトラフィックのためRTORを使用しても支障はありません。"
    },
    {
      "indent": 3,
      "text": "Given that RTOR is a mostly conservative algorithm, it is suitable for experimentation as a system-wide default for TCP traffic.",
      "ja": "RTORは主に保守的なアルゴリズムであることを考えると、それはTCPトラフィックのためのシステム全体のデフォルトとして実験に適しています。"
    },
    {
      "indent": 0,
      "text": "5.2. Spurious Timeouts",
      "section_title": true,
      "ja": "5.2。スプリアスタイムアウト"
    },
    {
      "indent": 3,
      "text": "RTOR can in some situations reduce the loss detection time and thereby increase the risk of spurious timeouts. In theory, the retransmission timer has a lower bound of 1 second [RFC6298], which limits the risk of having spurious timeouts. However, in practice, most implementations use a significantly lower value. Initial measurements show slight increases in the number of spurious timeouts when such lower values are used [RHB15]. However, further experiments, in different environments and with different types of traffic, are encouraged to quantify such increases more reliably.",
      "ja": "RTORは、いくつかの状況での損失の検出時間を短縮し、それによってスプリアスタイムアウトのリスクを高めることができます。理論的には、再送タイマがスプリアスタイムアウトを有する危険性を制限する1次の[RFC6298]の下限を有します。しかし、実際には、ほとんどの実装が大幅に低い値を使用します。初期測定は、このような低い値は[RHB15】使用されるスプリアスタイムアウトの数のわずかな増加を示しています。しかし、さらなる実験は、異なる環境で、トラフィックの異なるタイプで、より確実な増加を定量化することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "Does a slightly increased risk matter? Generally, spurious timeouts have a negative effect on the network as segments are transmitted needlessly. However, recent experiments do not show a significant increase in network load for a number of realistic scenarios [RHB15]. Another problem with spurious retransmissions is related to the performance of TCP/SCTP, as the congestion window is reduced to one segment when timeouts occur [RFC5681]. This could be a potential problem for applications transmitting multiple bursts of data within a single flow, e.g., web-based HTTP/1.1 and HTTP/2.0 applications. However, results from recent experiments involving persistent web traffic [RHB15] revealed a net gain using RTOR. Other types of flows, e.g., long-lived bulk flows, are not affected as the algorithm is only applied when the amount of outstanding and unsent segments is less than rrthresh. Furthermore, short-lived and application-limited flows are typically not affected as they are too short to experience the effect of congestion control or have a transmission rate that is quickly attainable.",
      "ja": "わずかに増加リスクは重要ですか？セグメントが不伝達されるように、一般的に、スプリアスタイムアウトは、ネットワーク上の負の効果を有しています。しかし、最近の実験は、現実的なシナリオ[RHB15]の数のためのネットワーク負荷の有意な増加を示していません。タイムアウトが[RFC5681]を発生したときに輻輳ウィンドウは、1つのセグメントに低減されるように、スプリアス再送を伴う別の問題は、TCP / SCTPの性能に関連しています。これは、単一のフロー内のデータの複数のバーストを送信するアプリケーションのための潜在的な問題、例えば、ウェブベースのHTTP / 1.1およびHTTP / 2.0アプリケーションであってもよいです。しかし、持続的なWebトラフィック[RHB15]を含む最近の実験からの結果はRTORを使用して純利益を明らかにしました。未処理および未送信のセグメントの量がrrthresh未満である場合、アルゴリズムにのみ適用される流れの他のタイプ、例えば、長寿命のバルクフローは、影響を受けません。彼らは輻輳制御の効果を体験したりすぐに達成可能である伝送速度を持つには短すぎるとしてさらに、短命とアプリケーションが制限されたフローは、一般的に影響を受けません。"
    },
    {
      "indent": 3,
      "text": "While a slight increase in spurious timeouts has been observed using RTOR, it is not clear whether or not the effects of this increase mandate any future algorithmic changes -- especially since most modern operating systems already include mechanisms to detect [RFC3522] [RFC3708] [RFC5682] and resolve [RFC4015] possible problems with spurious retransmissions. Further experimentation is needed to determine this and thereby move this specification from Experimental to the Standards Track. For instance, RTOR has not been evaluated in the context of mobile networks. Mobile networks often incur highly variable RTTs (delay spikes), due to e.g., handovers, and would therefore be a useful scenario for further experimentation.",
      "ja": "最も近代的なオペレーティング・システムが既に[[RFC3522] [RFC3708]を検出するための機構を含む、特に以来 - スプリアスタイムアウトのわずかな増加がRTORを用いて観察してきたが、この増加の任務の効果将来のアルゴリズムの変更かどうかは明らかではありませんRFC5682]とスプリアス再送を伴う[RFC4015]可能性のある問題を解決します。さらに、実験がこれを決定し、それによって標準化過程への実験から、この仕様を移動するために必要とされます。例えば、RTORは、モバイルネットワークのコンテキストで評価されていません。モバイルネットワークは、しばしば、例えば、ハンドオーバに高度に可変のRTT（遅延スパイク）を招くので、さらなる実験のために有用なシナリオであろう。"
    },
    {
      "indent": 0,
      "text": "5.3. Tracking Outstanding and Previously Unsent Segments",
      "section_title": true,
      "ja": "5.3。優れたと以前に未送信セグメントの追跡"
    },
    {
      "indent": 3,
      "text": "The method of tracking outstanding and previously unsent segments will probably differ depending on the actual TCP implementation. For packet-based TCP implementations, tracking outstanding segments is often straightforward and can be implemented using a simple counter. For byte-based TCP stacks, it is a more complex task. Section 3.2 of [RFC5827] outlines a general method of tracking the number of outstanding segments. The same method can be used for RTOR. The implementation will have to track segment boundaries to form an understanding as to how many actual segments have been transmitted but not acknowledged. This can be done by the sender tracking the boundaries of the rrthresh segments on the right side of the current window (which involves tracking rrthresh + 1 sequence numbers in TCP). This could be done by keeping a circular list of the segment boundaries, for instance. Cumulative ACKs that do not fall within this region indicate that at least rrthresh segments are outstanding, and therefore RTOR is not enabled. When the outstanding window becomes small enough that RTOR can be invoked, a full understanding of the number of outstanding segments will be available from the rrthresh + 1 sequence numbers retained. (Note: the implicit sequence number consumed by the TCP FIN bit can also be included in the tracking of segment boundaries.)",
      "ja": "顕著で、以前に未送信のセグメントを追跡する方法は、おそらく実際のTCPの実装によって異なります。パケットベースのTCPの実装のために、未処理のセグメントを追跡することは、多くの場合、簡単であり、単純なカウンタを用いて実現することができます。バイトベースのTCPスタックの場合、それはより複雑な作業です。 [RFC5827]のセクション3.2は、未処理のセグメント数を追跡​​する一般的な方法を概説します。同じ方法がRTORのために使用することができます。実装は、実際のセグメントが送信されなく確認されているどのように多くのとして理解を形成するために、セグメント境界を追跡する必要があります。これは、（TCPにrrthresh + 1つのシーケンス番号を追跡することを含む）現在のウィンドウの右側にrrthreshセグメントの境界を追跡する送信者によって行うことができます。これは、例えば、セグメント境界の循環リストを維持することによって行うことができます。この地域内に入らない累積ACKは、少なくともrrthreshセグメントが優れているので、RTORが有効になっていないことを示しています。未処理のウィンドウがRTORを呼び出すことができるように十分に小さくなると、未処理のセグメントの数の完全な理解を保持rrthresh + 1つのシーケンス番号から利用できるようになります。 （注：TCP FINビットによって消費される暗黙のシーケンス番号は、セグメント境界の追跡に含めることができます。）"
    },
    {
      "indent": 3,
      "text": "Tracking the number of previously unsent segments depends on the segmentation strategy used by the TCP implementation, not whether it is packet based or byte based. In the case where segments are formed directly on socket writes, the process of determining the number of previously unsent segments should be trivial. In the case that unsent data can be segmented (or resegmented) as long as it is still unsent, a straightforward strategy could be to divide the amount of unsent data (in bytes) with the Sender Maximum Segment Size (SMSS) to obtain an estimate. In some cases, such an estimation could be too simplistic, depending on the segmentation strategy of the TCP implementation. However, this estimation is not critical to RTOR. The tracking of prevunsnt is only made to optimize a corner case in which RTOR was unnecessarily disabled. Implementations can use a simplified method by setting prevunsnt to rrthresh whenever previously unsent data is available, and set prevunsnt to zero when no new data is available. This will disable RTOR in the presence of unsent data and only use the number of outstanding segments to enable/disable RTOR.",
      "ja": "以前に未送信のセグメントの数を追跡することは、パケットベースまたはバイトベースであるか否か、TCPの実装によって使用されるセグメント化戦略に依存します。セグメントは、ソケット上に直接形成されている場合には、以前に未送信のセグメントの数を決定するプロセスは自明であるべきで、書き込みます。未送信データがあれば、それはまだ未送信であるとして、セグメント化（または再セグメント化）することができる場合には、単純な戦略は、推定値を得るために送信側最大セグメントサイズ（SMSS）と（バイト）未送信データの量を分割することができ。いくつかのケースでは、このような推定はTCP実装のセグメンテーション戦略に応じて、単純すぎるかもしれません。しかし、この推定はRTORには重要ではありません。 prevunsntの追跡は唯一RTORが不必要に無効にされたコーナーケースを最適化するために行われます。実装は、以前に未送信のデータが利用可能であり、新しいデータが利用可能でない場合、ゼロにprevunsntを設定するたびrrthreshするprevunsntを設定することにより、簡略化された方法を使用することができます。これは、未送信データの存在下でRTORを無効にしてのみ/無効RTORを可能にするために、未処理のセグメント数を使用します。"
    },
    {
      "indent": 0,
      "text": "6. Related Work",
      "section_title": true,
      "ja": "6.関連研究"
    },
    {
      "indent": 3,
      "text": "There are several proposals that address the problem of not having enough ACKs for loss recovery. In what follows, we explain why the mechanism described here is complementary to these approaches:",
      "ja": "損失回復のための十分なACKを持っていないの問題に対処するいくつかの提案があります。ここで説明するメカニズムは、これらのアプローチに相補的である理由を以下では、我々は説明します。"
    },
    {
      "indent": 3,
      "text": "The limited transmit mechanism [RFC3042] allows a TCP sender to transmit a previously unsent segment for each of the first two duplicate acknowledgements (dupACKs). By transmitting new segments, the sender attempts to generate additional dupACKs to enable fast retransmit. However, limited transmit does not help if no previously unsent data is ready for transmission. [RFC5827] specifies an early retransmit algorithm to enable fast loss recovery in such situations. By dynamically lowering the number of dupACKs needed for fast retransmit (dupthresh), based on the number of outstanding segments, a smaller number of dupACKs is needed to trigger a retransmission. In some situations, however, the algorithm is of no use or might not work properly. First, if a single segment is outstanding and lost, it is impossible to use early retransmit. Second, if ACKs are lost, early retransmit cannot help. Third, if the network path reorders segments, the algorithm might cause more spurious retransmissions than fast retransmit. The recommended value of RTOR's rrthresh variable is based on the dupthresh, but it is possible to adapt to allow tighter integration with other experimental algorithms such as early retransmit.",
      "ja": "制限された送信メカニズム[RFC3042]はTCP送信者は、最初の二つの重複確認応答（dupACKs）のそれぞれについて、以前に未送信のセグメントを送信することを可能にします。新しいセグメントを送信することにより、送信者は、高速再送を可能にするために、追加のdupACKsを生成しようとします。何も以前に未送信データが伝送の準備ができていない場合は、制限された送信は役立ちません。 [RFC5827]は、このような状況で高速な損失回復を可能にするために、早期再送アルゴリズムを指定します。ダイナミックに発行済のセグメントの数に基づいて、高速再送信（dupthresh）に必要なdupACKsの数を低下させることによって、dupACKsより少ない数の再送をトリガするために必要とされます。いくつかの状況では、しかし、このアルゴリズムは役に立たないか、正しく動作しない可能性があります。単一のセグメントが顕著で、失われた場合はまず、早期の再送信を使用することは不可能です。第二に、ACKのが失われた場合は、早期の再送信は助けることはできません。ネットワークパスは、セグメントを並べ替えた場合第三に、このアルゴリズムは、高速再送よりも多くの偽の再送信が発生する可能性があります。 RTORのrrthresh変数の推奨値がdupthreshに基づいていますが、このような早期の再送信などの他の実験的なアルゴリズムとの緊密な統合を可能にするために適応させることが可能です。"
    },
    {
      "indent": 3,
      "text": "Tail Loss Probe [TLP] is a proposal to send up to two \"probe segments\" when a timer fires that is set to a value smaller than the RTO. A \"probe segment\" is a new segment if new data is available, else it is a retransmission. The intention is to compensate for sluggish RTO behavior in situations where the RTO greatly exceeds the RTT, which, according to measurements reported in [TLP], is not uncommon. Furthermore, TLP also tries to circumvent the congestion window reset to one segment by instead enabling fast recovery. The probe timeout (PTO) is normally two RTTs, and a spurious PTO is less risky than a spurious RTO because it would not have the same negative effects (clearing the scoreboard and restarting with slow-start). TLP is a more advanced mechanism than RTOR, requiring e.g., SACK to work, and is often able to further reduce loss recovery times. However, it also noticeably increases the amount of spurious retransmissions, as compared to RTOR [RHB15].",
      "ja": "テール損失プローブ[TLPは、2つの「プローブセグメント」RTOよりも小さい値に設定され、タイマーが起動まで送るための提案です。新しいデータが利用可能である場合、「プローブセグメント」は、それが再送信され、他の新しいセグメントです。意図は、RTOが大幅[TLP]で報告された測定値によると、珍しいことではない、RTTを超える状況では緩慢RTOの動作を補償することです。さらに、TLPはまた、代わりに高速リカバリを可能にすることによって、一つのセグメントに輻輳ウィンドウのリセットを回避しようとします。プローブのタイムアウト（PTO）は、通常2つのRTTであり、それは同じマイナスの影響（スコアボードをクリアして、スロースタートで再起動）を持っていないので、スプリアスPTOは、スプリアスRTOよりもリスクが少ないです。 TLPは、例えば必要な、仕事をするSACK RTORより高度な機構であり、多くの場合、さらに損失の回復時間を短縮することができます。しかし、それはまた、顕著RTOR [RHB15]と比較して、スプリアス再送の量を増加させます。"
    },
    {
      "indent": 3,
      "text": "TLP is applicable in situations where RTOR does not apply, and it could overrule (yielding a similar general behavior, but with a lower timeout) RTOR in cases where the number of outstanding segments is smaller than four and no new segments are available for transmission. The PTO has the same inherent problem of restarting the timer on an incoming ACK and could be combined with a strategy similar to RTOR's to offer more consistent timeouts.",
      "ja": "TLPはRTORが適用されない状況に適用可能であり、それは未処理のセグメントの数が4未満であると、新しいセグメントが送信のために利用可能でない場合には（より低いタイムアウトが、同様の一般的な挙動を生じる）RTORを覆すことができました。 PTOは、着信ACKにタイマーを再起動するのと同じ固有の問題があり、より一貫性のタイムアウトを提供するRTORのに似た戦略と組み合わせることができます。"
    },
    {
      "indent": 0,
      "text": "7. SCTP Socket API Considerations",
      "section_title": true,
      "ja": "7. SCTPソケットAPIの考慮事項"
    },
    {
      "indent": 3,
      "text": "This section describes how the socket API for SCTP defined in [RFC6458] is extended to control the usage of RTO restart for SCTP.",
      "ja": "このセクションでは、[RFC6458]で定義されたSCTP用のソケットAPIは、SCTPのためのRTOの再起動の使用を制御するように拡張される方法について説明します。"
    },
    {
      "indent": 3,
      "text": "Please note that this section is informational only.",
      "ja": "このセクションは情報提供のみであることに注意してください。"
    },
    {
      "indent": 0,
      "text": "7.1. Data Types",
      "section_title": true,
      "ja": "7.1。データの種類"
    },
    {
      "indent": 3,
      "text": "This section uses data types from [IEEE.9945]: uintN_t means an unsigned integer of exactly N bits (e.g., uint16_t). This is the same as in [RFC6458].",
      "ja": "このセクションでは、[IEEE.9945]からデータ型を使用：uintN_tは正確にNビットの符号なし整数（例えば、uint16_t）を意味します。これは[RFC6458]と同じです。"
    },
    {
      "indent": 0,
      "text": "7.2. Socket Option for Controlling the RTO Restart Support (SCTP_RTO_RESTART)",
      "ja": "7.2。 RTOの再起動サポートを制御するためのソケットオプション（SCTP_RTO_RESTART）"
    },
    {
      "indent": 3,
      "text": "This socket option allows the enabling or disabling of RTO Restart for SCTP associations.",
      "ja": "このソケットオプションは、SCTPアソシエーションのRTOの再起動の有効化または無効化することができます。"
    },
    {
      "indent": 3,
      "text": "Whether or not RTO restart is enabled per default is implementation specific.",
      "ja": "RTOの再起動がデフォルトごとに有効かどうかは、実装固有のものです。"
    },
    {
      "indent": 3,
      "text": "This socket option uses IPPROTO_SCTP as its level and SCTP_RTO_RESTART as its name. It can be used with getsockopt() and setsockopt(). The socket option value uses the following structure defined in [RFC6458]:",
      "ja": "このソケットオプションは、その名のようにそのレベルとSCTP_RTO_RESTARTとしてIPPROTO_SCTPを使用しています。それはgetsockoptの（）とのsetsockopt（）で使用することができます。ソケットオプションの値は、[RFC6458]で定義され、以下の構造を使用します。"
    },
    {
      "indent": 3,
      "text": "struct sctp_assoc_value {\n  sctp_assoc_t assoc_id;\n  uint32_t assoc_value;\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "assoc_id: This parameter is ignored for one-to-one style sockets. For one-to-many style sockets, this parameter indicates upon which association the user is performing an action. The special sctp_assoc_t SCTP_{FUTURE|CURRENT|ALL}_ASSOC can also be used in assoc_id for setsockopt(). For getsockopt(), the special value SCTP_FUTURE_ASSOC can be used in assoc_id, but it is an error to use SCTP_{CURRENT|ALL}_ASSOC in assoc_id.",
      "ja": "assoc_id：このパラメータは、1対1スタイルソケットでは無視されます。 1対多スタイルソケットの場合、このパラメータは、ユーザーがアクションを実行している際にアソシエーション示します。特別sctp_assoc_tのSCTP_ {FUTURE | CURRENT | ALL} _ASSOCはまた、）（のsetsockoptためassoc_idに使用することができます。 getsockoptのため（）、特別な値SCTP_FUTURE_ASSOCはassoc_idで使用することができ、SCTP_ {CURRENT | ALL}を使用するとエラーにassoc_idで_ASSOCを。"
    },
    {
      "indent": 3,
      "text": "assoc_value: A non-zero value encodes the enabling of RTO restart whereas a value of 0 encodes the disabling of RTO restart.",
      "ja": "assoc_value：非ゼロ値は、0の値は、RTOの再起動の禁止をコードに対し、RTO再始動可能コード。"
    },
    {
      "indent": 3,
      "text": "sctp_opt_info() needs to be extended to support SCTP_RTO_RESTART.",
      "ja": "sctp_opt_infoは（）SCTP_RTO_RESTARTをサポートするように拡張する必要があります。"
    },
    {
      "indent": 0,
      "text": "8. Security Considerations",
      "section_title": true,
      "ja": "8.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document specifies an experimental sender-only modification to TCP and SCTP. The modification introduces a change in how to set the retransmission timer's value when restarted. Therefore, the security considerations found in [RFC6298] apply to this document. No additional security problems have been identified with RTO Restart at this time.",
      "ja": "このドキュメントでは、TCPとSCTPへの実験的な送信者のみの変更を指定します。変更は再起動したときに再送タイマの値を設定する方法の変化を紹介します。したがって、[RFC6298]で見つかったセキュリティ上の考慮事項は、この文書に適用されます。追加のセキュリティ問題は、この時点でRTOの再起動で確認されていません。"
    },
    {
      "indent": 0,
      "text": "9. References",
      "section_title": true,
      "ja": "9.参考文献"
    },
    {
      "indent": 0,
      "text": "9.1. Normative References",
      "section_title": true,
      "ja": "9.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC1122] Braden, R., Ed., \"Requirements for Internet Hosts - Communication Layers\", STD 3, RFC 1122, DOI 10.17487/RFC1122, October 1989, <http://www.rfc-editor.org/info/rfc1122>.",
      "ja": "[RFC1122]ブレーデン、R.、エド、 \"インターネットホストのための要件 - 通信層\"。、STD 3、RFC 1122、DOI 10.17487 / RFC1122、1989年10月、<http://www.rfc-editor.org/info/ RFC1122>。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<http://www.rfc-editor.org/info/ RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC3042] Allman, M., Balakrishnan, H., and S. Floyd, \"Enhancing TCP's Loss Recovery Using Limited Transmit\", RFC 3042, DOI 10.17487/RFC3042, January 2001, <http://www.rfc-editor.org/info/rfc3042>.",
      "ja": "[RFC3042]オールマン、M.、バラクリシュナン、H.、およびS.フロイド、 \"株式会社トランスミットを使用したTCPの損失回復の強化\"、RFC 3042、DOI 10.17487 / RFC3042、2001年1月、<のhttp：//www.rfc-editor。組織/情報/ rfc3042>。"
    },
    {
      "indent": 3,
      "text": "[RFC3522] Ludwig, R. and M. Meyer, \"The Eifel Detection Algorithm for TCP\", RFC 3522, DOI 10.17487/RFC3522, April 2003, <http://www.rfc-editor.org/info/rfc3522>.",
      "ja": "[RFC3522]ルートヴィヒ、R.及びM.マイヤー、 \"TCPのためのアイフェル検出アルゴリズム\"、RFC 3522、DOI 10.17487 / RFC3522、2003年4月、<http://www.rfc-editor.org/info/rfc3522>。"
    },
    {
      "indent": 3,
      "text": "[RFC3708] Blanton, E. and M. Allman, \"Using TCP Duplicate Selective Acknowledgement (DSACKs) and Stream Control Transmission Protocol (SCTP) Duplicate Transmission Sequence Numbers (TSNs) to Detect Spurious Retransmissions\", RFC 3708, DOI 10.17487/RFC3708, February 2004, <http://www.rfc-editor.org/info/rfc3708>.",
      "ja": "[RFC3708] \"スプリアス再送を検出するためにTCP複製選択的確認応答（DSACKs）およびストリーム制御伝送プロトコル（SCTP）重複送信シーケンス番号（TSNを）を使用して\" ブラントン、E.およびM.オールマン、RFC 3708、DOI 10.17487 / RFC3708、 2004年2月、<http://www.rfc-editor.org/info/rfc3708>。"
    },
    {
      "indent": 3,
      "text": "[RFC4015] Ludwig, R. and A. Gurtov, \"The Eifel Response Algorithm for TCP\", RFC 4015, DOI 10.17487/RFC4015, February 2005, <http://www.rfc-editor.org/info/rfc4015>.",
      "ja": "[RFC4015]ルートヴィヒ、R.とA. Gurtov、 \"TCPのためのアイフェルレスポンスアルゴリズム\"、RFC 4015、DOI 10.17487 / RFC4015、2005年2月、<http://www.rfc-editor.org/info/rfc4015>。"
    },
    {
      "indent": 3,
      "text": "[RFC4960] Stewart, R., Ed., \"Stream Control Transmission Protocol\", RFC 4960, DOI 10.17487/RFC4960, September 2007, <http://www.rfc-editor.org/info/rfc4960>.",
      "ja": "[RFC4960]スチュワート、R.、エド。、 \"ストリーム制御伝送プロトコル\"、RFC 4960、DOI 10.17487 / RFC4960、2007年9月、<http://www.rfc-editor.org/info/rfc4960>。"
    },
    {
      "indent": 3,
      "text": "[RFC5681] Allman, M., Paxson, V., and E. Blanton, \"TCP Congestion Control\", RFC 5681, DOI 10.17487/RFC5681, September 2009, <http://www.rfc-editor.org/info/rfc5681>.",
      "ja": "[RFC5681]オールマン、M.、パクソン、V.、およびE.ブラントン、 \"TCP輻輳制御\"、RFC 5681、DOI 10.17487 / RFC5681、2009年9月、<http://www.rfc-editor.org/info/ rfc5681>。"
    },
    {
      "indent": 3,
      "text": "[RFC5682] Sarolahti, P., Kojo, M., Yamamoto, K., and M. Hata, \"Forward RTO-Recovery (F-RTO): An Algorithm for Detecting Spurious Retransmission Timeouts with TCP\", RFC 5682, DOI 10.17487/RFC5682, September 2009, <http://www.rfc-editor.org/info/rfc5682>.",
      "ja": "[RFC5682] Sarolahti、P.、古城、M.、山本、K.、およびM.秦、 \"フォワードRTOリカバリ（F-RTO）：TCPとスプリアス再送タイムアウトを検出するためのアルゴリズム\"、RFC 5682、DOI 10.17487 / RFC5682、2009年9月、<http://www.rfc-editor.org/info/rfc5682>。"
    },
    {
      "indent": 3,
      "text": "[RFC5827] Allman, M., Avrachenkov, K., Ayesta, U., Blanton, J., and P. Hurtig, \"Early Retransmit for TCP and Stream Control Transmission Protocol (SCTP)\", RFC 5827, DOI 10.17487/RFC5827, May 2010, <http://www.rfc-editor.org/info/rfc5827>.",
      "ja": "[RFC5827]オールマン、M.、Avrachenkov、K.、Ayesta、U.、ブラントン、J.、およびP. Hurtig、 \"TCPおよびストリーム制御伝送プロトコル（SCTP）のための初期の再送信\"、RFC 5827、DOI 10.17487 / RFC5827 、2010年5月、<http://www.rfc-editor.org/info/rfc5827>。"
    },
    {
      "indent": 3,
      "text": "[RFC6298] Paxson, V., Allman, M., Chu, J., and M. Sargent, \"Computing TCP's Retransmission Timer\", RFC 6298, DOI 10.17487/RFC6298, June 2011, <http://www.rfc-editor.org/info/rfc6298>.",
      "ja": "[RFC6298]パクソン、V.、オールマン、M.、チュー、J.、およびM.サージェント、 \"コンピューティングTCPの再送信タイマー\"、RFC 6298、DOI 10.17487 / RFC6298、2011年6月、<のhttp：//www.rfc- editor.org/info/rfc6298>。"
    },
    {
      "indent": 0,
      "text": "9.2. Informative References",
      "section_title": true,
      "ja": "9.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[EL04] Ekstroem, H. and R. Ludwig, \"The Peak-Hopper: A New End-to-End Retransmission Timer for Reliable Unicast Transport\", IEEE INFOCOM 2004, DOI 10.1109/INFCOM.2004.1354671, March 2004.",
      "ja": "[EL04] Ekstroem、H.とR.ルートヴィヒ、 \"ピーク・ホッパー：信頼性の高いユニキャスト交通のための新しいエンドツーエンドの再送信タイマー\"、IEEE INFOCOM 2004、DOI 10.1109 / INFCOM.2004.1354671、2004年3月。"
    },
    {
      "indent": 3,
      "text": "[FDT13] Flach, T., Dukkipati, N., Terzis, A., Raghavan, B., Cardwell, N., Cheng, Y., Jain, A., Hao, S., Katz-Bassett, E., and R. Govindan, \"Reducing Web Latency: the Virtue of Gentle Aggression\", Proc. ACM SIGCOMM Conf., DOI 10.1145/2486001.2486014, August 2013.",
      "ja": "【FDT13】フラック、T.、Dukkipati、N.、Terzis、A.、ラガバン、B.、カードウェル、N.、チェン、Y.、ジェイン、A.、ハオ、S.、カッツ・バセット、E.、そして、R.ゴヴィンダン、「ウェブ待ち時間を短縮：ジェントル攻撃の美徳」、PROC。 ACM SIGCOMMコンファレンス。、DOI 10.1145 / 2486001.2486014、2013年8月。"
    },
    {
      "indent": 3,
      "text": "[HB11] Hurtig, P. and A. Brunstrom, \"SCTP: designed for timely message delivery?\", Springer Telecommunication Systems 47 (3-4), DOI 10.1007/s11235-010-9321-3, August 2011.",
      "ja": "[HB11] Hurtig、P.およびA. Brunstrom、 \"SCTP：？タイムリーなメッセージ配信のために設計された\"、スプリンガー通信システム47（3-4）、DOI 10.1007 / s11235-010-9321-3、2011年8月。"
    },
    {
      "indent": 3,
      "text": "[IEEE.9945] IEEE/ISO/IEC, \"International Standard - Information technology Portable Operating System Interface (POSIX) Base Specifications, Issue 7\", IEEE 9945-2009, <http://standards.ieee.org/findstds/ standard/9945-2009.html>.",
      "ja": "[IEEE.9945] IEEE / ISO / IEC、 \"国際規格 - 情報技術ポータブルオペレーティングシステムインタフェース（POSIX）基本仕様、7号\"、IEEE 9945から2009まで、<http://standards.ieee.org/findstds/標準/9945-2009.html>。"
    },
    {
      "indent": 3,
      "text": "[LS00] Ludwig, R. and K. Sklower, \"The Eifel retransmission timer\", ACM SIGCOMM Comput. Commun. Rev., 30(3), DOI 10.1145/382179.383014, July 2000.",
      "ja": "[LS00]ルートヴィヒ、R.及びK. Sklower、 \"アイフェル再送タイマー\"、ACM SIGCOMM Comput。 COMMUN。牧師、30（3）、DOI 10.1145 / 382179.383014、2000年7月。"
    },
    {
      "indent": 3,
      "text": "[P09] Petlund, A., \"Improving latency for interactive, thin-stream applications over reliable transport\", Unipub PhD Thesis, Oct 2009.",
      "ja": "[P09] Petlund、A.、Unipub博士論文、2009年10月、「信頼性の高いトランスポート上でインタラクティブ、薄ストリームアプリケーションのための待ち時間の改善」。"
    },
    {
      "indent": 3,
      "text": "[PBP09] Petlund, A., Beskow, P., Pedersen, J., Paaby, E., Griwodz, C., and P. Halvorsen, \"Improving SCTP retransmission delays for time-dependent thin streams\", Springer Multimedia Tools and Applications, 45(1-3), DOI 10.1007/s11042-009-0286-8, October 2009.",
      "ja": "【PBP09] Petlund、A.、Beskow、P.、ペダーセン、J.、Paaby、E.、Griwodz、C.、およびP. Halvorsenの、 \"時間依存性の薄いストリームのSCTPの再送遅延を改善する\"、スプリンガーマルチメディアツールとアプリケーション、45（1-3）、DOI 10.1007 / s11042-009-0286-8、2009年10月。"
    },
    {
      "indent": 3,
      "text": "[PGH06] Pedersen, J., Griwodz, C., and P. Halvorsen, \"Considerations of SCTP Retransmission Delays for Thin Streams\", IEEE LCN 2006, DOI 10.1109/LCN.2006.322082, November 2006.",
      "ja": "【PGH06】ペダーセン、J.、Griwodz、C.、およびP. Halvorsenの \"シンストリームのSCTP再送遅延の考慮事項\"、IEEE LCN 2006、DOI 10.1109 / LCN.2006.322082 2006年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC6458] Stewart, R., Tuexen, M., Poon, K., Lei, P., and V. Yasevich, \"Sockets API Extensions for the Stream Control Transmission Protocol (SCTP)\", RFC 6458, DOI 10.17487/RFC6458, December 2011, <http://www.rfc-editor.org/info/rfc6458>.",
      "ja": "[RFC6458]スチュワート、R.、Tuexen、M.、プーン、K.、レイ、P.、およびV. Yasevich、DOI 10.17487 / RFC6458、RFC 6458、 \"ストリーム制御伝送プロトコル（SCTP）のためのソケットAPIの拡張機能\" 、2011年12月、<http://www.rfc-editor.org/info/rfc6458>。"
    },
    {
      "indent": 3,
      "text": "[RHB15] Rajiullah, M., Hurtig, P., Brunstrom, A., Petlund, A., and M. Welzl, \"An Evaluation of Tail Loss Recovery Mechanisms for TCP\", ACM SIGCOMM CCR 45 (1), DOI 10.1145/2717646.2717648, January 2015.",
      "ja": "【RHB15] Rajiullah、M.、Hurtig、P.、Brunstrom、A.、Petlund、A.、およびM. Welzl、 \"テール損失TCPの回復メカニズムの評価\"、ACM SIGCOMM CCR 45（1）、DOI 10.1145 /2717646.2717648、2015年1月。"
    },
    {
      "indent": 3,
      "text": "[RJ10] Ramachandran, S., \"Web metrics: Size and number of resources\", May 2010, <https://goo.gl/0a6Q9A>.",
      "ja": "[RJ10]ラマチャンドラン、S.、 \"ウェブメトリックス：サイズやリソースの数\"、2010年5月、<https://goo.gl/0a6Q9A>。"
    },
    {
      "indent": 3,
      "text": "[TLP] Dukkipati, N., Cardwell, N., Cheng, Y., and M. Mathis, \"Tail Loss Probe (TLP): An Algorithm for Fast Recovery of Tail Losses\", Work in Progress, draft-dukkipati-tcpm-tcp-loss-probe-01, February 2013.",
      "ja": "[TLP] Dukkipati、N.、カードウェル、N.、チェン、Y.、およびM.マシス、 \"テール損失プローブ（TLP）：テール損失の高速回復のためのアルゴリズム\" が進行中で働いて、ドラフトdukkipati-tcpm -tcp損失プローブ-01、2013年2月。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "The authors wish to thank Michael Tuexen for contributing the SCTP Socket API considerations and Godred Fairhurst, Yuchung Cheng, Mark Allman, Anantha Ramaiah, Richard Scheffenegger, Nicolas Kuhn, Alexander Zimmermann, and Michael Scharf for commenting on the document and the ideas behind it.",
      "ja": "作者は、ドキュメントとその背後にある考え方にコメントがSCTPソケットAPIの考慮事項とGodred Fairhurst、Yuchungチェン、マーク・オールマン、Anantha Ramaiah、リチャードScheffenegger、ニコラ・クーン、アレクサンダー・ツィンマーマン、そしてマイケル・シャーフに貢献するために、マイケルTuexenに感謝したいです。"
    },
    {
      "indent": 3,
      "text": "All the authors are supported by RITE (http://riteproject.eu/), a research project (ICT-317700) funded by the European Community under its Seventh Framework Program. The views expressed here are those of the author(s) only. The European Commission is not liable for any use that may be made of the information in this document.",
      "ja": "すべての著者は、RITE（http://riteproject.eu/）、第7次フレームワーク計画の下で欧州共同体資金による研究プロジェクト（ICT-317700）によってサポートされています。ここで示された見解は、著者（複数可）のみのものです。欧州委員会は、この文書に記載されている情報を用いることができる任意の使用のための責任を負いません。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Per Hurtig Karlstad University Universitetsgatan 2 Karlstad 651 88 Sweden",
      "ja": "パーHurtigカールスタード大学Universitetsgatan 2カールスタード651 88スウェーデン"
    },
    {
      "indent": 3,
      "text": "Phone: +46 54 700 23 35 Email: per.hurtig@kau.se",
      "ja": "電話：+46 54 700 23 35 Eメール：per.hurtig@kau.se"
    },
    {
      "indent": 3,
      "text": "Anna Brunstrom Karlstad University Universitetsgatan 2 Karlstad 651 88 Sweden",
      "ja": "アンナBrunstromカールスタード大学Universitetsgatan 2カールスタード651 88スウェーデン"
    },
    {
      "indent": 3,
      "text": "Phone: +46 54 700 17 95 Email: anna.brunstrom@kau.se",
      "ja": "電話：+46 54 700 17 95 Eメール：anna.brunstrom@kau.se"
    },
    {
      "indent": 3,
      "text": "Andreas Petlund Simula Research Laboratory AS P.O. Box 134 Lysaker 1325 Norway",
      "ja": "私書箱ASアンドレアスPetlund Simulaの研究所ボックス134リサーカー1325ノルウェー"
    },
    {
      "indent": 3,
      "text": "Phone: +47 67 82 82 00 Email: apetlund@simula.no",
      "ja": "電話：+47 67 82 82 00 Eメール：apetlund@simula.no"
    },
    {
      "indent": 3,
      "text": "Michael Welzl University of Oslo PO Box 1080 Blindern Oslo N-0316 Norway",
      "ja": "オスロ私書箱1080 BlindernオスロN-0316ノルウェーのマイケル・Welzl大学"
    },
    {
      "indent": 3,
      "text": "Phone: +47 22 85 24 20 Email: michawe@ifi.uio.no",
      "ja": "電話：+47 22 85 24 20 Eメール：michawe@ifi.uio.no"
    }
  ]
}