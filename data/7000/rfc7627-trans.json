{
  "title": {
    "text": "RFC 7627 - Transport Layer Security (TLS) Session Hash and Extended Master Secret Extension",
    "ja": "RFC 7627 - トランスポート層セキュリティ（TLS）セッションハッシュおよび拡張マスターシークレット拡張"
  },
  "number": 7627,
  "created_at": "2019-10-31 10:24:09.386276+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                 K. Bhargavan, Ed.\nRequest for Comments: 7627                            A. Delignat-Lavaud\nUpdates: 5246                                                 A. Pironti\nCategory: Standards Track                       Inria Paris-Rocquencourt\nISSN: 2070-1721                                               A. Langley\n                                                             Google Inc.\n                                                                  M. Ray\n                                                         Microsoft Corp.\n                                                          September 2015",
      "raw": true
    },
    {
      "indent": 12,
      "text": "Transport Layer Security (TLS) Session Hash and\n        Extended Master Secret Extension",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "The Transport Layer Security (TLS) master secret is not cryptographically bound to important session parameters such as the server certificate. Consequently, it is possible for an active attacker to set up two sessions, one with a client and another with a server, such that the master secrets on the two sessions are the same. Thereafter, any mechanism that relies on the master secret for authentication, including session resumption, becomes vulnerable to a man-in-the-middle attack, where the attacker can simply forward messages back and forth between the client and server. This specification defines a TLS extension that contextually binds the master secret to a log of the full handshake that computes it, thus preventing such attacks.",
      "ja": "トランスポート層セキュリティ（TLS）マスターシークレットは、暗号など、サーバ証明書などの重要なセッションパラメータにバインドされていません。したがって、それは二つのセッションのマスター秘密が同じであるように、二つのセッション、クライアントとの1とサーバとの別を設定するには、アクティブな攻撃が可能です。その後、セッションの再開を含め、認証のためにマスターシークレットに依存しているいずれかのメカニズムは、前後にクライアントとサーバーの間で、攻撃者がすることができ、単にメッセージを転送man-in-the-middle攻撃に対して脆弱になります。この仕様は、このような攻撃を防ぐ、文脈にそれを計算し、完全な握手のログにマスターシークレットをバインドするTLS拡張を定義します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 5741のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7627.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7627で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2015 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2015 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................3\n2. Requirements Notation ...........................................5\n3. The TLS Session Hash ............................................5\n4. The Extended Master Secret ......................................6\n5. Extension Negotiation ...........................................6\n   5.1. Extension Definition .......................................6\n   5.2. Client and Server Behavior: Full Handshake .................7\n   5.3. Client and Server Behavior: Abbreviated Handshake ..........7\n   5.4. Interoperability Considerations ............................9\n6. Security Considerations .........................................9\n   6.1. Triple Handshake Preconditions and Impact ..................9\n   6.2. Cryptographic Properties of the Hash Function .............11\n   6.3. Handshake Messages Included in the Session Hash ...........11\n   6.4. No SSL 3.0 Support ........................................12\n7. IANA Considerations ............................................12\n8. References .....................................................12\n   8.1. Normative References ......................................12\n   8.2. Informative References ....................................13\nAcknowledgments ...................................................14\nAuthors' Addresses ................................................15",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "In TLS [RFC5246], every session has a \"master_secret\" computed as:",
      "ja": "TLS [RFC5246]では、すべてのセッションは、として計算「でマスター_」を持っています："
    },
    {
      "indent": 3,
      "text": "master_secret = PRF(pre_master_secret, \"master secret\", ClientHello.random + ServerHello.random) [0..47];",
      "ja": "マスター_ = PRF（前_のマスター_秘密、 \"マスタシークレット\"、ClientHello.randomと+ ServerHello.random）[0..47]。"
    },
    {
      "indent": 3,
      "text": "where the \"pre_master_secret\" is the result of some key exchange protocol. For example, when the handshake uses an RSA ciphersuite, this value is generated uniformly at random by the client, whereas for Ephemeral Diffie-Hellman (DHE) ciphersuites, it is the result of a Diffie-Hellman key agreement.",
      "ja": "ここで、「前_のマスター_秘密は、」いくつかの鍵交換プロトコルの結果です。ハンドシェークは、RSAの暗号スイートを使用する場合、エフェメラルディフィー・ヘルマン（DHE）暗号スイートのために、それはディフィー・ヘルマン鍵合意の結果であるのに対し、例えば、この値は、クライアントがランダムに一様に生成されます。"
    },
    {
      "indent": 3,
      "text": "As described in [TRIPLE-HS], in both the RSA and DHE key exchanges, an active attacker can synchronize two TLS sessions so that they share the same \"master_secret\". For an RSA key exchange where the client is unauthenticated, this is achieved as follows. Suppose a client C connects to a server A. C does not realize that A is malicious and that A connects in the background to an honest server S and completes both handshakes. For simplicity, assume that C and S only use RSA ciphersuites.",
      "ja": "[TRIPLE-HS]に記載されているように、それらが同じ「マスター_」を共有するように、RSAおよびDHE鍵交換の両方において、活発な攻撃者は、二つのTLSセッションを同期させることができます。次のようにクライアントが認証されRSA鍵交換のために、これが達成されます。 Cは、サーバA. Cに接続するクライアントは、Aが悪質であり、Aは正直、サーバSにバックグラウンドで接続し、両方のハンドシェイクを完了することをことを認識していないと仮定します。簡単にするために、CとSのみのRSA暗号スイートを使用することを前提としています。"
    },
    {
      "indent": 3,
      "text": "1. C sends a \"ClientHello\" to A, and A forwards it to S.",
      "section_title": true,
      "ja": "1. C「はのClientHello」に、及びSに転送し、それを送信します。"
    },
    {
      "indent": 3,
      "text": "2. S sends a \"ServerHello\" to A, and A forwards it to C.",
      "section_title": true,
      "ja": "2. Sは「ServerHelloメッセージ」に、そしてCに転送し、それを送信します"
    },
    {
      "indent": 3,
      "text": "3. S sends a \"Certificate\", containing its certificate chain, to A. A replaces it with its own certificate chain and sends it to C.",
      "ja": "3. Sは、独自の証明書チェーンに置き換えとCに送信A. Aに、その証明書チェーンを含む、「証明書」を送り、"
    },
    {
      "indent": 3,
      "text": "4. S sends a \"ServerHelloDone\" to A, and A forwards it to C.",
      "section_title": true,
      "ja": "4. Sは「ServerHelloDone」に、そしてCに転送し、それを送信します"
    },
    {
      "indent": 3,
      "text": "5. C sends a \"ClientKeyExchange\" to A, containing the \"pre_master_secret\", encrypted with A's public key. A decrypts the \"pre_master_secret\", re-encrypts it with S's public key, and sends it on to S.",
      "ja": "5. Cは、Aの公開鍵で暗号化された「前_のマスター_秘密を」含む、Aに「ClientKeyExchange」を送信します。 Aは「前_のマスター_秘密」、Sの公開鍵でそれを再暗号化を解読し、Sにそれを送信します"
    },
    {
      "indent": 3,
      "text": "6. C sends a \"Finished\" to A. A computes a \"Finished\" for its connection with S and sends it to S.",
      "ja": "6. CはSとの接続は、「仕上がり」を計算し、S.に送信A. Aに「終了」を送信します"
    },
    {
      "indent": 3,
      "text": "7. S sends a \"Finished\" to A. A computes a \"Finished\" for its connection with C and sends it to C.",
      "ja": "7. SはCとの接続のために、「仕上がり」を計算し、C.に送信A. Aに「終了」を送信します"
    },
    {
      "indent": 3,
      "text": "At this point, both connections (between C and A, and between A and S) have new sessions that share the same \"pre_master_secret\", \"ClientHello.random\", \"ServerHello.random\", as well as other session parameters, including the session identifier and, optionally, the session ticket. Hence, the \"master_secret\" value will be equal for the two sessions and will be associated both at C and S with the same session ID, even though the server identities on the two connections are different. Recall that C only sees A's certificate and is unaware of A's connection with S. Moreover, the record keys on the two connections will also be the same.",
      "ja": "この時点で、（CとAとの間、及びAとSとの間の）両方の接続には、同じ「前_のマスター_秘密」、「ClientHello.randomと」、「ServerHello.randomを共有」新しいセッション、ならびに他のセッションパラメータを有しますセッション識別子と、必要に応じて、セッションチケット。したがって、「マスター_」値は、2つのセッションのために等しくなり、2つの接続上のサーバ識別情報が異なっていても、同じセッションIDとCとSの両方に関連します。 CのみがAの証明書を見て、また、2つの接続上のレコードキーも同じになりますS.とAの接続を認識していないことを思い出してください。"
    },
    {
      "indent": 3,
      "text": "The scenario above shows that TLS does not guarantee that the master secrets and keys used on different connections will be different. Even if client authentication is used, the scenario still works, except that the two sessions now differ on both client and server identities.",
      "ja": "上記のシナリオは、TLSが異なる接続に使用するマスター秘密とキーが異なるものになることを保証するものではないことを示しています。クライアント認証が使用されている場合でも、シナリオはまだ2つのセッションが今クライアントとサーバーの両方のアイデンティティに異なることを除いて、動作します。"
    },
    {
      "indent": 3,
      "text": "A similar scenario can be achieved when the handshake uses a DHE ciphersuite. Note that even if the client or server does not prefer using RSA or DHE, the attacker can force them to use it by offering only RSA or DHE in its hello messages. Handshakes using Ephemeral Elliptic Curve Diffie-Hellman (ECDHE) ciphersuites are also vulnerable if they allow arbitrary explicit curves or use curves with small subgroups. Against more powerful adversaries, other key exchanges, such as Secure Remote Password (SRP) and Pre-Shared Key (PSK), have also been shown to be vulnerable [VERIFIED-BINDINGS].",
      "ja": "ハンドシェークは、DHEの暗号スイートを使用する場合、同様のシナリオを達成することができます。クライアントまたはサーバがRSAまたはDHEを使用して好むていない場合でも、攻撃者はそのhelloメッセージにのみRSAまたはDHEを提供することで、それを使用するためにそれらを強制できることに注意してください。それらは小さなサブグループで任意の明示的な曲線又は使用曲線を許可した場合エフェメラル楕円曲線ディフィ - ヘルマン（ECDHE）暗号化方式を用いてハンドシェイクも脆弱です。より強力な敵、そのようなセキュアリモートパスワード（SRP）のような他の鍵交換、および事前共有鍵（PSK）に対して、また[VERIFIEDバインディング]脆弱であることが示されています。"
    },
    {
      "indent": 3,
      "text": "Once A has synchronized the two connections, since the keys are the same on the two sides, it can step away and transparently forward messages between C and S, reading and modifying when it desires. In the key exchange literature, such occurrences are called unknown key-share attacks, since C and S share a secret but they both think that their secret is shared only with A. In themselves, these attacks do not break integrity or confidentiality between honest parties, but they offer a useful starting point from which to mount impersonation attacks on C and S.",
      "ja": "Aは、2つの接続を同期したら、キーが両側に同じであるので、それは望むとき読み出し、修正、前方離れかつ透過CとSの間でメッセージをステップすることができます。鍵交換の文献では、このような出来事は、CとSは秘密を共有するが、それらの両方が彼らの秘密は自分自身でのみA.と共有されていることを考えているので、これらの攻撃は、正直な当事者間の整合性や機密性を壊さない、未知のキーシェア攻撃と呼ばれていますが、彼らはCとSになりすまし攻撃をマウントするには、そこから有益な出発点を提供します"
    },
    {
      "indent": 3,
      "text": "Suppose C tries to resume its session on a new connection with A. A can then resume its session with S on a new connection and forward the abbreviated handshake messages unchanged between C and S. Since the abbreviated handshake only relies on the master secret for authentication and does not mention client or server identities, both handshakes complete successfully, resulting in the same session keys and the same handshake log. A still knows the connection keys and can send messages to both C and S.",
      "ja": "CはA. Aとの新しい接続上のセッションは、新しい接続でSとのセッションを再開し、簡略ハンドシェイクが唯一の認証のためにマスターシークレットに依存しているため、CとSとの間変わらない簡略ハンドシェイクメッセージを転送することができます再開しようとしたと仮定しそして、同じセッション鍵と同じ握手ログで、その結果、両方のハンドシェイクが正常に完了し、クライアントまたはサーバIDを言及していません。まだ接続キーを知っていて、CおよびS.の両方にメッセージを送ることができます"
    },
    {
      "indent": 3,
      "text": "Critically, at the new connection, even the handshake log is the same on C and S, thus defeating any man-in-the-middle protection scheme that relies on the uniqueness of finished messages, such as the secure renegotiation indication extension [RFC5746] or TLS channel bindings [RFC5929]. [TRIPLE-HS] describes several exploits based on such session synchronization attacks. In particular, it describes a man-in-the-middle attack, called the \"triple handshake\", that circumvents the protections of [RFC5746] to break client-authenticated TLS renegotiation after session resumption. Similar attacks apply to application-level authentication mechanisms that rely on channel bindings [RFC5929] or on key material exported from TLS [RFC5705].",
      "ja": "批判的に、新たな接続であっても、ハンドシェイク・ログは、このように安全な再ネゴシエーション指示拡張[RFC5746]として完成したメッセージの一意性に依存して任意のman-in-the-middle保護スキームを破り、C及びSに同じですまたはTLSチャネルバインディング[RFC5929]。 [TRIPLE-HS】このようなセッションの同期の攻撃に基づいていくつかのエクスプロイトを説明しています。特に、それはman-in-the-middle攻撃を説明し、セッションの再開後にクライアント認証TLSの再交渉を破るために、[RFC5746]の保護を回避する「トリプル握手を」と呼ばれます。同様の攻撃は、チャネルバインディング[RFC5929]またはTLS [RFC5705]からエクスポートされた鍵材料に依存してアプリケーションレベルの認証メカニズムに適用されます。"
    },
    {
      "indent": 3,
      "text": "The underlying protocol issue leading to these attacks is that the TLS master secret is not guaranteed to be unique across sessions, since it is not context-bound to the full handshake that generated it. If we fix this problem in the initial master secret computation, then all these attacks can be prevented. This specification introduces a TLS extension that changes the way the \"master_secret\" value is computed in a full handshake by including the log of the handshake messages, so that different sessions will, by construction, have different master secrets. This prevents the attacks described in [TRIPLE-HS] and documented in Section 2.11 of [RFC7457].",
      "ja": "これらの攻撃につながる基本的なプロトコルの問題は、それがコンテキストバインドそれを生成した完全なハンドシェイクにはないので、TLSマスターシークレットが、セッション間で一意であることが保証されていないということです。我々は最初のマスターシークレットの計算では、この問題を修正する場合は、すべてのこれらの攻撃を防ぐことができます。この仕様は、「マスター_」の値が異なるセッションは、工事によって、異なるマスター秘密を持つことになりますように、ハンドシェイクメッセージのログを含めることにより、完全なハンドシェイクで計算される方法を変更TLS拡張を紹介します。これは、[TRIPLE-HS]に記載の攻撃を防ぎ、[RFC7457]のセクション2.11に記載します。"
    },
    {
      "indent": 0,
      "text": "2. Requirements Notation",
      "section_title": true,
      "ja": "2.要件表記"
    },
    {
      "indent": 3,
      "text": "This document uses the same notation and terminology used in the TLS protocol specification [RFC5246].",
      "ja": "この文書では、TLSプロトコル仕様[RFC5246]で使用したものと同じ表記法及び用語を使用します。"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [RFC2119].",
      "ja": "キーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、 \"SHALL\"、 \"SHOULD\"、 \"ないもの\"、 \"推奨\" \"ない（SHOULD NOT）\"、 \"MAY\"、 \"推奨NOT\"、および「OPTIONAL RFC 2119 [RFC2119]に記載されているように「この文書に解釈されるべきです。"
    },
    {
      "indent": 0,
      "text": "3. The TLS Session Hash",
      "section_title": true,
      "ja": "3. TLSセッションハッシュ"
    },
    {
      "indent": 3,
      "text": "When a full TLS handshake takes place, we define",
      "ja": "完全なTLSハンドシェイクが行われるとき、私たちは定義します"
    },
    {
      "indent": 9,
      "text": "session_hash = Hash(handshake_messages)",
      "ja": "session_hash =ハッシュ（握手）"
    },
    {
      "indent": 3,
      "text": "where \"handshake_messages\" refers to all handshake messages sent or received, starting at the ClientHello up to and including the ClientKeyExchange message, including the type and length fields of the handshake messages. This is the concatenation of all the exchanged Handshake structures, as defined in Section 7.4 of [RFC5246].",
      "ja": "「握手」は、送信またはまでのClientHelloで開始し、ハンドシェイクメッセージのタイプと長さフィールドを含むClientKeyExchangeメッセージを含む、受信したすべてのハンドシェイクメッセージを指します。 [RFC5246]のセクション7.4で定義されるように、これは、すべての交換ハンドシェイク構造の連結です。"
    },
    {
      "indent": 3,
      "text": "For TLS 1.2, the \"Hash\" function is the one defined in Section 7.4.9 of [RFC5246] for the Finished message computation. For all previous versions of TLS, the \"Hash\" function computes the concatenation of MD5 and SHA1.",
      "ja": "TLS 1.2は、「ハッシュ」機能は、Finishedメッセージの計算のために[RFC5246]のセクション7.4.9で定義されたものです。 TLSのすべての以前のバージョンについては、「ハッシュ」関数は、MD5とSHA1の連結を計算します。"
    },
    {
      "indent": 3,
      "text": "There is no \"session_hash\" for resumed handshakes, as they do not lead to the creation of a new session.",
      "ja": "彼らは新しいセッションの作成につながらないように再開ハンドシェイクのための「session_hash」はありません。"
    },
    {
      "indent": 0,
      "text": "4. The Extended Master Secret",
      "section_title": true,
      "ja": "4.拡張マスターシークレット"
    },
    {
      "indent": 3,
      "text": "When the extended master secret extension is negotiated in a full handshake, the \"master_secret\" is computed as",
      "ja": "拡張されたマスターシークレット拡張子がフルハンドシェイクで交渉された場合、「でmaster_secretは」のように計算されます。"
    },
    {
      "indent": 3,
      "text": "master_secret = PRF(pre_master_secret, \"extended master secret\", session_hash) [0..47];",
      "ja": "マスター_ = PRF（前_のマスター_秘密、 \"拡張されたマスタシークレット\"、session_hash）[0..47]。"
    },
    {
      "indent": 3,
      "text": "The extended master secret computation differs from that described in [RFC5246] in the following ways:",
      "ja": "拡張されたマスターシークレットの計算は次のように[RFC5246]に記載されたものとは異なります。"
    },
    {
      "indent": 3,
      "text": "o The \"extended master secret\" label is used instead of \"master secret\".",
      "ja": "O「拡張マスタシークレット」ラベルではなく、「マスター・シークレット」の使用されています。"
    },
    {
      "indent": 3,
      "text": "o The \"session_hash\" is used instead of the \"ClientHello.random\" and \"ServerHello.random\".",
      "ja": "「session_hash」O代わりに「ClientHello.randomと」と「ServerHello.random」を使用します。"
    },
    {
      "indent": 3,
      "text": "The \"session_hash\" depends upon a handshake log that includes \"ClientHello.random\" and \"ServerHello.random\", in addition to ciphersuites, key exchange information, and certificates (if any) from the client and server. Consequently, the extended master secret depends upon the choice of all these session parameters.",
      "ja": "「session_hashは、」暗号スイート、鍵交換情報、およびクライアントとサーバからの証明書（もしあれば）に加えて、「ClientHello.randomと」と「ServerHello.randomを」には、ハンドシェイクログに依存します。したがって、拡張されたマスターシークレットは、これらすべてのセッションパラメータの選択に依存します。"
    },
    {
      "indent": 3,
      "text": "This design reflects the recommendation that keys should be bound to the security contexts that compute them [SP800-108]. The technique of mixing a hash of the key exchange messages into master key derivation is already used in other well-known protocols such as Secure Shell (SSH) [RFC4251].",
      "ja": "このデザインは、キーが[SP800-108]それらを計算するセキュリティコンテキストにバインドする必要があります勧告を反映しています。マスター鍵の導出に鍵交換メッセージのハッシュを混合する技術がすでにセキュアシェル（SSH）[RFC4251]などの他の周知のプロトコルで使用されています。"
    },
    {
      "indent": 3,
      "text": "Clients and servers SHOULD NOT accept handshakes that do not use the extended master secret, especially if they rely on features like compound authentication that fall into the vulnerable cases described in Section 6.1.",
      "ja": "クライアントとサーバーは、6.1節で説明した脆弱性の例に陥る複合認証などの機能に依存している場合は特に、拡張されたマスターシークレットを使用していない握手を受け入れるべきではありません。"
    },
    {
      "indent": 0,
      "text": "5. Extension Negotiation",
      "section_title": true,
      "ja": "5.延長交渉"
    },
    {
      "indent": 0,
      "text": "5.1. Extension Definition",
      "section_title": true,
      "ja": "5.1。拡張定義"
    },
    {
      "indent": 3,
      "text": "This document defines a new TLS extension, \"extended_master_secret\" (with extension type 0x0017), which is used to signal both client and server to use the extended master secret computation. The \"extension_data\" field of this extension is empty. Thus, the entire encoding of the extension is 00 17 00 00 (in hexadecimal.)",
      "ja": "この文書は、新しいTLS拡張、「extended_master_secret」を定義する拡張マスターシークレットの計算を使用するクライアントとサーバーの両方に信号を送るために使用される、（拡張型0x0017で）。この拡張機能の「拡大」フィールドが空です。このように、延長部の全体の符号化は、（16進）00 17 00 00"
    },
    {
      "indent": 3,
      "text": "Although this document refers only to TLS, the extension proposed here can also be used with Datagram TLS (DTLS) [RFC6347].",
      "ja": "この文書のみTLSを指すが、ここで提案された拡張はまた、データグラムTLS（DTLS）[RFC6347]と一緒に使用することができます。"
    },
    {
      "indent": 3,
      "text": "If the client and server agree on this extension and a full handshake takes place, both client and server MUST use the extended master secret derivation algorithm, as defined in Section 4. All other cryptographic computations remain unchanged.",
      "ja": "クライアントとサーバは、この延長線上に同意し、完全なハンドシェイクが行われた場合は第4項に定義されている他のすべての暗号計算は変わらないとして、クライアントとサーバの両方が、拡張されたマスターシークレット導出アルゴリズムを使用しなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.2. Client and Server Behavior: Full Handshake",
      "section_title": true,
      "ja": "5.2。クライアントとサーバーの動作：フルハンドシェイク"
    },
    {
      "indent": 3,
      "text": "In the following, we use the phrase \"abort the handshake\" as shorthand for terminating the handshake by sending a fatal \"handshake_failure\" alert.",
      "ja": "以下では、フレーズ致命的な「握手_」アラートを送信することにより、ハンドシェイクを終了するための省略形として「握手を中止」を使用します。"
    },
    {
      "indent": 3,
      "text": "In all handshakes, a client implementing this document MUST send the \"extended_master_secret\" extension in its ClientHello.",
      "ja": "すべてのハンドシェイクでは、この文書を実装するクライアントは、その中のClientHello「extended_master_secret」の拡張子を送らなければなりません。"
    },
    {
      "indent": 3,
      "text": "If a server implementing this document receives the \"extended_master_secret\" extension, it MUST include the extension in its ServerHello message.",
      "ja": "この文書を実装するサーバは「extended_master_secret」の拡張子を受信した場合、それはそのServerHelloメッセージで拡張子を含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "If both the ClientHello and ServerHello contain the extension, the new session uses the extended master secret computation.",
      "ja": "ClientHelloとのServerHelloの両方が拡張が含まれている場合は、新しいセッションが拡張されたマスターシークレットの計算を使用しています。"
    },
    {
      "indent": 3,
      "text": "If the server receives a ClientHello without the extension, it SHOULD abort the handshake if it does not wish to interoperate with legacy clients. If it chooses to continue the handshake, then it MUST NOT include the extension in the ServerHello.",
      "ja": "サーバが拡張子なしのClientHelloを受信した場合、それがレガシークライアントと相互運用したくない場合は、それは握手を中止すべきです。それは握手を継続することを選択した場合、それはのServerHelloで拡張子を含めることはできません。"
    },
    {
      "indent": 3,
      "text": "If a client receives a ServerHello without the extension, it SHOULD abort the handshake if it does not wish to interoperate with legacy servers.",
      "ja": "クライアントは、拡張子なしのServerHelloを受信した場合、それは従来のサーバーと相互運用したくない場合は、それは握手を中止すべきです。"
    },
    {
      "indent": 3,
      "text": "If the client and server choose to continue a full handshake without the extension, they MUST use the standard master secret derivation for the new session. In this case, the new session is not protected by the mechanisms described in this document. So, implementers should follow the guidelines in Section 5.4 to avoid dangerous usage scenarios. In particular, the master secret derived from the new session should not be used for application-level authentication.",
      "ja": "クライアントとサーバが拡張子のない完全なハンドシェイクを継続することを選択した場合、彼らは新しいセッションのための標準的なマスターシークレット導出を使用しなければなりません。この場合、新しいセッションは、この文書で説明するメカニズムによって保護されていません。だから、実装者は危険な使用シナリオを避けるために、5.4節のガイドラインに従ってください。具体的には、新しいセッションから派生マスターシークレットは、アプリケーションレベルの認証に使用すべきではありません。"
    },
    {
      "indent": 0,
      "text": "5.3. Client and Server Behavior: Abbreviated Handshake",
      "section_title": true,
      "ja": "5.3。クライアントとサーバーの動作：略称ハンドシェイク"
    },
    {
      "indent": 3,
      "text": "The client SHOULD NOT offer an abbreviated handshake to resume a session that does not use an extended master secret. Instead, it SHOULD offer a full handshake.",
      "ja": "クライアントは、拡張されたマスタシークレットを使用していないセッションを再開するために簡略ハンドシェイクを提供すべきではありません。代わりに、それは完全なハンドシェイクを提供する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the client chooses to offer an abbreviated handshake even for such sessions in order to support legacy insecure resumption, then the current connection is not protected by the mechanisms in this document. So, the client should follow the guidelines in Section 5.4",
      "ja": "クライアントは、レガシー不安定な再開をサポートするために、このようなセッションのためにも、簡略ハンドシェイクを提供することを選択した場合は、現在の接続は、この文書に記載されているメカニズムによって保護されていません。だから、クライアントは、5.4節のガイドラインに従ってください"
    },
    {
      "indent": 3,
      "text": "to avoid dangerous usage scenarios. In particular, renegotiation is no longer secure on this connection, even if the client and server support the renegotiation indication extension [RFC5746].",
      "ja": "危険な使用シナリオを避けるために。具体的には、再交渉は、クライアントとサーバーが再交渉表示拡張[RFC5746]をサポートしていても、この接続ではもはや安全ではありません。"
    },
    {
      "indent": 3,
      "text": "When offering an abbreviated handshake, the client MUST send the \"extended_master_secret\" extension in its ClientHello.",
      "ja": "簡略ハンドシェイクを提供する場合、クライアントはそののClientHelloに「extended_master_secret」の拡張子を送らなければなりません。"
    },
    {
      "indent": 3,
      "text": "If a server receives a ClientHello for an abbreviated handshake offering to resume a known previous session, it behaves as follows:",
      "ja": "サーバが知られている前のセッションを再開するために提供簡略ハンドシェイクのためのClientHelloを受信した場合、次のように動作します"
    },
    {
      "indent": 3,
      "text": "o If the original session did not use the \"extended_master_secret\" extension but the new ClientHello contains the extension, then the server MUST NOT perform the abbreviated handshake. Instead, it SHOULD continue with a full handshake (as described in Section 5.2) to negotiate a new session.",
      "ja": "元のセッションは「extended_master_secret」拡張子を使用していませんでしたが、新しいのClientHelloは拡張子が含まれている場合は、O、サーバは簡略ハンドシェイクを実行してはなりません。代わりに、それは新しいセッションを交渉する（5.2節で説明したように）完全なハンドシェイクを継続する必要があります。"
    },
    {
      "indent": 3,
      "text": "o If the original session used the \"extended_master_secret\" extension but the new ClientHello does not contain it, the server MUST abort the abbreviated handshake.",
      "ja": "元のセッションは「extended_master_secret」の拡張子を使用しますが、新しいのClientHelloは、それが含まれていない場合は、O、サーバーは省略握手を中止しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o If neither the original session nor the new ClientHello uses the extension, the server SHOULD abort the handshake. If it continues with an abbreviated handshake in order to support legacy insecure resumption, the connection is no longer protected by the mechanisms in this document, and the server should follow the guidelines in Section 5.4.",
      "ja": "元のセッションも新しいのClientHelloもない拡張子を使用している場合は、O、サーバは握手を中止すべきです。それは従来の安全でない再開をサポートするために簡略ハンドシェイクを続行する場合は、接続はもはやこの文書に記載されているメカニズムにより保護されていない、そしてサーバは5.4節のガイドラインに従ってください。"
    },
    {
      "indent": 3,
      "text": "o If the new ClientHello contains the extension and the server chooses to continue the handshake, then the server MUST include the \"extended_master_secret\" extension in its ServerHello message.",
      "ja": "新しいのClientHello拡張が含まれていて、サーバがハンドシェイクを継続することを選択した場合、O、サーバはそのServerHelloメッセージで「extended_master_secret」拡張子を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "If a client receives a ServerHello that accepts an abbreviated handshake, it behaves as follows:",
      "ja": "クライアントが簡略ハンドシェイクを受け入れるのServerHelloを受信した場合、次のように動作します"
    },
    {
      "indent": 3,
      "text": "o If the original session did not use the \"extended_master_secret\" extension but the new ServerHello contains the extension, the client MUST abort the handshake.",
      "ja": "元のセッションは「extended_master_secret」拡張子を使用していませんでしたが、新しいのServerHelloは拡張子が含まれている場合は、O、クライアントは握手を中止しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o If the original session used the extension but the new ServerHello does not contain the extension, the client MUST abort the handshake.",
      "ja": "元のセッションは、拡張子を使用しますが、新しいのServerHelloは拡張子が含まれていない場合は、O、クライアントは握手を中止しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the client and server continue the abbreviated handshake, they derive the connection keys for the new session as usual from the master secret of the original session.",
      "ja": "クライアントとサーバが簡略ハンドシェイクを続ける場合は、元のセッションのマスターシークレットからいつものように新しいセッションの接続キーを導き出します。"
    },
    {
      "indent": 0,
      "text": "5.4. Interoperability Considerations",
      "section_title": true,
      "ja": "5.4。相互運用性に関する注意事項"
    },
    {
      "indent": 3,
      "text": "To allow interoperability with legacy clients and servers, a TLS peer may decide to accept full handshakes that use the legacy master secret computation. If so, they need to differentiate between sessions that use legacy and extended master secrets by adding a flag to the session state.",
      "ja": "レガシークライアントとサーバとの相互運用性を可能にするには、TLSピアは、従来のマスターシークレットの計算を使用し、完全なハンドシェイクを受け入れることを決定することができます。もしそうなら、彼らは、セッション状態にフラグを追加することによって、レガシーおよび拡張マスター秘密を使用するセッションを区別する必要があります。"
    },
    {
      "indent": 3,
      "text": "If a client or server chooses to continue with a full handshake without the extended master secret extension, then the new session becomes vulnerable to the man-in-the-middle key synchronization attack described in Section 1. Hence, the client or server MUST NOT export any key material based on the new master secret for any subsequent application-level authentication. In particular, it MUST disable [RFC5705] and any Extensible Authentication Protocol (EAP) relying on compound authentication [COMPOUND-AUTH].",
      "ja": "クライアントまたはサーバーが拡張されたマスター秘密拡張子なしの完全なハンドシェイクを続行することを選択した場合、新しいセッションは、このため第1節で説明したのman-in-the-middleキー同期攻撃に対して脆弱になり、クライアントまたはサーバは、NOT MUST後続のアプリケーションレベルの認証のための新しいマスターシークレットに基づいて任意のキーマテリアルをエクスポートします。特に、それは[RFC5705]と化合認証〔化合物-AUTH]に依存する任意の拡張認証プロトコル（EAP）を無効にする必要があります。"
    },
    {
      "indent": 3,
      "text": "If a client or server chooses to continue an abbreviated handshake to resume a session that does not use the extended master secret, then the current connection becomes vulnerable to a man-in-the-middle handshake log synchronization attack as described in Section 1. Hence, the client or server MUST NOT use the current handshake's \"verify_data\" for application-level authentication. In particular, the client MUST disable renegotiation and any use of the \"tls-unique\" channel binding [RFC5929] on the current connection.",
      "ja": "クライアントまたはサーバーが拡張されたマスターシークレットを使用していないセッションを再開するために簡略ハンドシェイクを継続することを選択した場合従って、第1節で説明したように、現在の接続はのman-in-the-middleハンドシェークログ同期攻撃に対して脆弱になり、 、クライアントまたはサーバは、アプリケーションレベルの認証のための現在のハンドシェークの「verify_data」を使用してはなりません。具体的には、クライアントが再交渉し、現在の接続上の結合「TLS-ユニークな」チャンネル[RFC5929]のいずれかの使用を無効にする必要があります。"
    },
    {
      "indent": 3,
      "text": "If the original session uses an extended master secret but the ClientHello or ServerHello in the abbreviated handshake does not include the extension, it MAY be safe to continue the abbreviated handshake since it is protected by the extended master secret of the original session. This scenario may occur, for example, when a server that implements this extension establishes a session but the session is subsequently resumed at a different server that does not support the extension. Since such situations are unusual and likely to be the result of transient or inadvertent misconfigurations, this document recommends that the client and server MUST abort such handshakes.",
      "ja": "元のセッションは、拡張されたマスターシークレットが、拡張子が含まれていません簡略ハンドシェイク中のClientHelloやServerHelloメッセージを使用している場合、元のセッションの延長マスターシークレットで保護されているので、簡略ハンドシェイクを続けるために安全である場合があります。このシナリオが発生する可能性があり、例えば、この拡張を実装するときに、サーバーは、セッションを確立するが、セッションは、その後、拡張をサポートしていない別のサーバで再開されます。このような状況は珍しいと一時的または不注意による設定ミスの結果である可能性が高いので、このドキュメントでは、クライアントとサーバは、このような握手を中止しなければなりませんことをお勧めします。"
    },
    {
      "indent": 0,
      "text": "6. Security Considerations",
      "section_title": true,
      "ja": "6.セキュリティの考慮事項"
    },
    {
      "indent": 0,
      "text": "6.1. Triple Handshake Preconditions and Impact",
      "section_title": true,
      "ja": "6.1。トリプルハンドシェイク前提条件と影響"
    },
    {
      "indent": 3,
      "text": "One way to mount a triple handshake attack is described in Section 1, along with a mention of the security mechanisms that break due to the attack; more in-depth discussion and diagrams can be found in [TRIPLE-HS]. Here, some further discussion is presented about attack preconditions and impact.",
      "ja": "トリプルハンドシェイクの攻撃をマウントする一つの方法は、攻撃のために壊すのセキュリティメカニズムの言及とともに、セクション1に記載されています。より詳細な説明および図は、[TRIPLE-HS]に見出すことができます。ここでは、いくつかのさらなる議論は、攻撃の前提条件と影響について提示されます。"
    },
    {
      "indent": 3,
      "text": "To mount a triple handshake attack, it must be possible to force the same master secret on two different sessions. For this to happen, two preconditions must be met:",
      "ja": "トリプルハンドシェイクの攻撃をマウントするには、2つの異なるセッションで同じマスタシークレットを強制することは可能でなければなりません。これを実現するためには、2つの前提条件が満たされる必要があります。"
    },
    {
      "indent": 3,
      "text": "o The client, C, must be willing to connect to a malicious server, A. In certain contexts, like the web, this can be easily achieved, since a browser can be instructed to load content from an untrusted origin.",
      "ja": "ブラウザが信頼されていない原点からコンテンツをロードするように指示することができるので、クライアントO、Cは、悪意のあるサーバに接続して喜んでなければならない、特定の状況でA.は、ウェブのように、これは簡単に実現することができます。"
    },
    {
      "indent": 3,
      "text": "o The pre-master secret must be synchronized on the two sessions. This is particularly easy to achieve with the RSA and DHE key exchanges, but under some conditions, ECDHE, SRP, and PSK key exchanges can be exploited to this effect as well.",
      "ja": "Oプレマスターシークレットは、二つのセッションに同期させる必要があります。これは、RSAとDHE鍵交換で達成することが特に容易であるが、いくつかの条件下では、ECDHE、SRP、およびPSKキー交換は同様にこの効果を利用することができます。"
    },
    {
      "indent": 3,
      "text": "Once the master secret is synchronized on two sessions, any security property that relies on the uniqueness of the master secret is compromised. For example, a TLS exporter [RFC5705] no longer provides a unique key bound to the current session.",
      "ja": "マスターシークレットは二つのセッションで同期されると、マスターシークレットの一意性に依存しているすべてのセキュリティ特性が損なわれる。例えば、TLSの輸出[RFC5705]は、もはや現在のセッションにバインドされた一意のキーを提供していません。"
    },
    {
      "indent": 3,
      "text": "TLS session resumption also relies on the uniqueness of the master secret to authenticate the resuming peers. Hence, if a synchronized session is resumed, the peers cannot be sure about each other's identities, and the attacker knows the connection keys. Clearly, a precondition to this step of the attack is that both client and server support session resumption (either via session identifier or session tickets [RFC5077]).",
      "ja": "TLSセッション再開も再開ピアを認証するためにマスターシークレットの一意性に依存しています。同期セッションが再開された場合そのため、ピアは互いのアイデンティティについて確認することができず、攻撃者が接続キーを知っています。明らかに、この攻撃ステップに前提条件は、クライアントとサーバーの両方のサポートセッションの再開（いずれかのセッションIDまたはセッションチケット[RFC5077]経由）です。"
    },
    {
      "indent": 3,
      "text": "Additionally, in a synchronized abbreviated handshake, the whole transcript (which includes the \"verify_data\" values) is synchronized. So, after an abbreviated handshake, channel bindings like \"tls-unique\" [RFC5929] will not uniquely identify the connection anymore.",
      "ja": "また、同期略記ハンドシェイクで、（「verify_data」値を含む）全体の転写物が同期されます。だから、略し握手した後、「TLS-ユニークな」[RFC5929]のようなチャネルバインディングを一意にもう接続を識別しません。"
    },
    {
      "indent": 3,
      "text": "Synchronization of the \"verify_data\" in abbreviated handshakes also undermines the security guarantees of the renegotiation indication extension [RFC5746], re-enabling a prefix-injection flaw similar to the renegotiation attack [Ray09]. However, in a triple handshake attack, the client sees the server certificate changing across different full handshakes. Hence, a precondition to mount this stage of the attack is that the client accepts different certificates at each handshake, even if their common names do not match. Before the triple handshake attack was discovered, this used to be widespread behavior, at least among some web browsers; such browsers were hence vulnerable to the attack.",
      "ja": "略記ハンドシェークにおける「verify_data」の同期化はまた、再ネゴシエーション指示拡張のセキュリティを保証[RFC5746]を損なう再交渉攻撃[Ray09]と同様プレフィックス注入欠陥を再度有効。しかし、トリプルハンドシェイクの攻撃では、クライアントが異なる完全なハンドシェイク間で変化するサーバ証明書を見ています。そのため、攻撃のこの段階をマウントする前提条件は、彼らの共通の名前が一致しない場合でも、クライアントは各握手で異なる証明書を受け入れることです。トリプルハンドシェイクの攻撃が発見された前に、これは、少なくとも一部のWebブラウザの中で、広範な振る舞いにするために使用しました。そのようなブラウザは、したがって、攻撃に対して脆弱でした。"
    },
    {
      "indent": 3,
      "text": "The extended master secret extension thwarts triple handshake attacks at their first stage by ensuring that different sessions necessarily end up with different master secret values. Hence, all security properties relying on the uniqueness of the master secret are now expected to hold. In particular, if a TLS session is protected by the extended master secret extension, it is safe to resume it, to use its channel bindings, and to allow for certificate changes across renegotiation, meaning that all certificates are controlled by the same peer. A symbolic cryptographic protocol analysis justifying the extended master secret extension appears in [VERIFIED-BINDINGS].",
      "ja": "拡張されたマスターシークレット拡張子が異なるセッションは必ずしも異なるマスターシークレット値で終わることを確実にすることによって、彼らの最初の段階でのトリプルハンドシェイクの攻撃を阻止し。したがって、マスタシークレットの一意性に依存するすべてのセキュリティ・プロパティは、現在保持することが期待されています。 TLSセッションが拡張されたマスター秘密拡張子によって保護されている場合は特に、そのチャネルバインディングを使用すると、すべての証明書は、同じピアによって制御されていることを意味し、再交渉全体の証明書の変更を可能にし、それを再開しても安全です。拡張マスタシークレット拡張を正当化シンボリック暗号プロトコル分析は、[VERIFIEDバインディング]に表示されます。"
    },
    {
      "indent": 0,
      "text": "6.2. Cryptographic Properties of the Hash Function",
      "section_title": true,
      "ja": "6.2。ハッシュ関数の暗号化のプロパティ"
    },
    {
      "indent": 3,
      "text": "The session hashes of two different sessions need to be distinct; hence, the \"Hash\" function used to compute the \"session_hash\" needs to be collision resistant. As such, hash functions such as MD5 or SHA1 are NOT RECOMMENDED.",
      "ja": "二つの異なるセッションのセッションハッシュは異なることする必要があります。したがって、「session_hash」を計算するために使用される「ハッシュ」関数は、衝突耐性であることが必要です。そのため、このようMD5やSHA1などのハッシュ関数は推奨されません。"
    },
    {
      "indent": 3,
      "text": "We observe that the \"Hash\" function used in the Finished message computation already needs to be collision resistant for the renegotiation indication extension [RFC5746] to work, because a meaningful collision on the handshake messages (and hence on the \"verify_data\") may re-enable the renegotiation attack [Ray09].",
      "ja": "ハンドシェイクメッセージに意味のある衝突が（従って、上に「verify_data」）を再できるので、我々は、Finishedメッセージの計算に使用される「ハッシュ」機能が既に再交渉指示拡張[RFC5746]動作させるために耐衝突する必要があることを確認します[Ray09]再交渉攻撃を-enable。"
    },
    {
      "indent": 3,
      "text": "The hash function used to compute the session hash depends on the TLS protocol version. All current ciphersuites defined for TLS 1.2 use SHA256 or better, and so does the session hash. For earlier versions of the protocol, only MD5 and SHA1 can be assumed to be supported, and this document does not require legacy implementations to add support for new hash functions. In these versions, the session hash uses the concatenation of MD5 and SHA1, as in the Finished message.",
      "ja": "セッションハッシュを計算するために使用されるハッシュ関数は、TLSプロトコルのバージョンに依存します。現在のすべての暗号スイートは、TLS 1.2を使用するSHA256またはよりよいのために定義され、そのセッションハッシュはありません。プロトコルの以前のバージョンでは、MD5とSHA1のみがサポートされると想定することができ、そしてこの文書は、新しいハッシュ関数のサポートを追加するために、従来の実装を必要としません。これらのバージョンでは、セッション・ハッシュは、Finishedメッセージのように、MD5やSHA1の連結を使用します。"
    },
    {
      "indent": 0,
      "text": "6.3. Handshake Messages Included in the Session Hash",
      "section_title": true,
      "ja": "6.3。セッションハッシュに含まれるハンドシェイクメッセージ"
    },
    {
      "indent": 3,
      "text": "The \"session_hash\" is intended to encompass all relevant session information, including ciphersuite negotiation, key exchange messages, and client and server identities. The hash is needed to compute the extended master secret and hence must be available before the Finished messages.",
      "ja": "「session_hashは、」暗号スイートのネゴシエーション、鍵交換メッセージ、およびクライアントとサーバのアイデンティティを含め、関連するすべてのセッション情報を包含することを意図しています。ハッシュはFinishedメッセージの前に利用可能でなければならないので、拡張されたマスターシークレットを計算するために必要とされます。"
    },
    {
      "indent": 3,
      "text": "This document sets the \"session_hash\" to cover all handshake messages up to and including the ClientKeyExchange. For existing TLS ciphersuites, these messages include all the significant contents of the new session -- CertificateVerify does not change the session content. At the same time, this allows the extended master secret to be computed immediately after the pre-master secret, so that implementations can shred the temporary pre-master secret from memory as early as possible.",
      "ja": "この文書では、ClientKeyExchange含めへとまでのすべてのハンドシェイクメッセージをカバーするために、「session_hash」を設定します。 CertificateVerifyがセッションの内容を変更しない - 既存のTLS暗号群の場合、これらのメッセージは、新しいセッションのすべての重要な内容が含まれています。同時に、これは実装ができるだけ早期にメモリから一時的なプレマスターシークレットを細断することができるように拡張されたマスターシークレットは、プレマスターシークレット直後に計算することができます。"
    },
    {
      "indent": 3,
      "text": "It is possible that new ciphersuites or TLS extensions may include additional messages between ClientKeyExchange and Finished that add important session context. In such cases, some of the security guarantees of this specification may no longer apply, and new man-in-the-middle attacks may be possible. For example, if the client and server support the session ticket extension [RFC5077], the session hash does not cover the new session ticket sent by the server. Hence, a man-in-the-middle may be able to cause a client to store a session ticket that was not meant for the current session. Attacks based on this vector are not yet known, but applications that store additional information in session tickets beyond those covered in the session hash require careful analysis.",
      "ja": "新しい暗号スイートまたはTLS拡張が重要なセッションのコンテキストを追加ClientKeyExchangeと完成の間に追加のメッセージが含まれる可能性があります。このような場合には、この仕様のセキュリティ保証のいくつかは、もはや適用されないこと、および新しいman-in-the-middle攻撃が可能です。例えば、クライアントとサーバはセッションチケット拡張[RFC5077]をサポートしている場合は、セッションハッシュは、サーバから送信された新しいセッションチケットをカバーしていません。したがって、のman-in-the-middleは、現在のセッションのために意味されなかったセッションチケットを保存するためにクライアントを引き起こすことができるかもしれません。このベクトルに基づいた攻撃はまだ知られていないが、セッションハッシュでカバーされたもの以外のセッションチケットに追加情報を格納するアプリケーションは、慎重な分析が必要です。"
    },
    {
      "indent": 0,
      "text": "6.4. No SSL 3.0 Support",
      "section_title": true,
      "ja": "6.4。いいえSSL 3.0をサポートしません"
    },
    {
      "indent": 3,
      "text": "The Secure Sockets Layer (SSL) protocol version 3.0 [RFC6101] is a predecessor of the TLS protocol, and it is equally vulnerable to triple handshake attacks, alongside other vulnerabilities stemming from its use of obsolete cryptographic constructions that are now considered weak. SSL 3.0 has been deprecated [RFC7568].",
      "ja": "セキュア・ソケット・レイヤー（SSL）プロトコル・バージョン3.0 [RFC6101]はTLSプロトコルの前身であり、それは現在、弱いと見なされる廃止暗号構造の使用から生じる他の脆弱性と並んで、三重ハンドシェイクの攻撃にも同様に脆弱です。 SSL 3.0は、[RFC7568]を廃止されました。"
    },
    {
      "indent": 3,
      "text": "The countermeasure described in this document relies on a TLS extension and hence cannot be used with SSL 3.0. Clients and servers implementing this document SHOULD refuse SSL 3.0 handshakes. If they choose to support SSL 3.0, the resulting sessions MUST use the legacy master secret computation, and the interoperability considerations of Section 5.4 apply.",
      "ja": "この文書に記載さ対策は、TLS拡張子に依存し、したがって、SSL 3.0と一緒に使用することができません。この文書を実装するクライアントとサーバーは、SSL 3.0ハンドシェークを拒否すべきです。彼らはSSL 3.0をサポートすることを選択した場合、結果のセッションは、従来のマスターシークレットの計算を使用しなければならない、とセクション5.4の相互運用性の考慮事項が適用されます。"
    },
    {
      "indent": 0,
      "text": "7. IANA Considerations",
      "section_title": true,
      "ja": "7. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "IANA has added the extension code point 23 (0x0017), which has been used by prototype implementations, for the \"extended_master_secret\" extension to the \"ExtensionType Values\" registry specified in the TLS specification [RFC5246].",
      "ja": "IANAは、TLS仕様で指定された「ExtensionType値」レジストリに「extended_master_secret」拡張[RFC5246]のために、プロトタイプの実装で使用された拡張コードポイント23（0x0017）を、添加しました。"
    },
    {
      "indent": 0,
      "text": "8. References",
      "section_title": true,
      "ja": "8.参照文献"
    },
    {
      "indent": 0,
      "text": "8.1. Normative References",
      "section_title": true,
      "ja": "8.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<http://www.rfc-editor.org/info/ RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC5246] Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS) Protocol Version 1.2\", RFC 5246, DOI 10.17487/RFC5246, August 2008, <http://www.rfc-editor.org/info/rfc5246>.",
      "ja": "[RFC5246]ダークス、T.およびE.レスコラ、 \"トランスポート層セキュリティ（TLS）プロトコルバージョン1.2\"、RFC 5246、DOI 10.17487 / RFC5246、2008年8月、<http://www.rfc-editor.org/info / RFC5246>。"
    },
    {
      "indent": 0,
      "text": "8.2. Informative References",
      "section_title": true,
      "ja": "8.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[COMPOUND-AUTH] Asokan, N., Valtteri, N., and K. Nyberg, \"Man-in-the-Middle in Tunnelled Authentication Protocols\", Security Protocols, LNCS, Volume 3364, DOI 10.1007/11542322_6, 2005.",
      "ja": "[COMPOUND-AUTH] Asokan、N.、Valtteri、N.、およびK.ニベルグ、 \"のman-in-the-middleトンネル化認証プロトコルで\"、セキュリティプロトコル、LNCS、ボリューム3364、DOI 10.1007 / 11542322_6、2005。"
    },
    {
      "indent": 3,
      "text": "[Ray09] Ray, M., \"Authentication Gap in TLS Renegotiation\", 2009.",
      "ja": "【Ray09]レイ、M.、 \"TLS再ネゴシエーション中に、認証ギャップ\" 2009年。"
    },
    {
      "indent": 3,
      "text": "[RFC4251] Ylonen, T. and C. Lonvick, Ed., \"The Secure Shell (SSH) Protocol Architecture\", RFC 4251, DOI 10.17487/RFC4251, January 2006, <http://www.rfc-editor.org/info/rfc4251>.",
      "ja": "[RFC4251] Ylonenと、T.とC. Lonvick、エド。、 \"セキュアシェル（SSH）プロトコルアーキテクチャ\"、RFC 4251、DOI 10.17487 / RFC4251、2006年1月、<http://www.rfc-editor.org/情報/ rfc4251>。"
    },
    {
      "indent": 3,
      "text": "[RFC5077] Salowey, J., Zhou, H., Eronen, P., and H. Tschofenig, \"Transport Layer Security (TLS) Session Resumption without Server-Side State\", RFC 5077, DOI 10.17487/RFC5077, January 2008, <http://www.rfc-editor.org/info/rfc5077>.",
      "ja": "[RFC5077] Salowey、J.、周、H.、Eronen、P.、およびH. Tschofenig、 \"トランスポート層セキュリティ（TLS）セッション再開サーバ側の状態なし\"、RFC 5077、DOI 10.17487 / RFC5077、2008年1月、 <http://www.rfc-editor.org/info/rfc5077>。"
    },
    {
      "indent": 3,
      "text": "[RFC5705] Rescorla, E., \"Keying Material Exporters for Transport Layer Security (TLS)\", RFC 5705, DOI 10.17487/RFC5705, March 2010, <http://www.rfc-editor.org/info/rfc5705>.",
      "ja": "[RFC5705]レスコラ、E.、RFC 5705、DOI 10.17487 / RFC5705、2010年3月、 \"トランスポート層セキュリティ（TLS）のための鍵材料輸出\" <http://www.rfc-editor.org/info/rfc5705>。"
    },
    {
      "indent": 3,
      "text": "[RFC5746] Rescorla, E., Ray, M., Dispensa, S., and N. Oskov, \"Transport Layer Security (TLS) Renegotiation Indication Extension\", RFC 5746, DOI 10.17487/RFC5746, February 2010, <http://www.rfc-editor.org/info/rfc5746>.",
      "ja": "[RFC5746]レスコラ、E.、レイ、M.、Dispensa、S.、およびN. Oskov、 \"トランスポート層セキュリティ（TLS）再ネゴシエーション表示拡張\"、RFC 5746、DOI 10.17487 / RFC5746、2010年2月、<のhttp：/ /www.rfc-editor.org/info/rfc5746>。"
    },
    {
      "indent": 3,
      "text": "[RFC5929] Altman, J., Williams, N., and L. Zhu, \"Channel Bindings for TLS\", RFC 5929, DOI 10.17487/RFC5929, July 2010, <http://www.rfc-editor.org/info/rfc5929>.",
      "ja": "[RFC5929]アルトマン、J.、ウィリアムズ、N.、およびL.朱、 \"TLSのチャネルバインディング\"、RFC 5929、DOI 10.17487 / RFC5929、2010年7月、<http://www.rfc-editor.org/info / rfc5929>。"
    },
    {
      "indent": 3,
      "text": "[RFC6101] Freier, A., Karlton, P., and P. Kocher, \"The Secure Sockets Layer (SSL) Protocol Version 3.0\", RFC 6101, DOI 10.17487/RFC6101, August 2011, <http://www.rfc-editor.org/info/rfc6101>.",
      "ja": "[RFC6101]フライアー、A.、Karlton、P.、およびP.コッヘル、 \"セキュア・ソケット・レイヤー（SSL）プロトコルバージョン3.0\"、RFC 6101、DOI 10.17487 / RFC6101、2011年8月、<のhttp：//www.rfc -editor.org/info/rfc6101>。"
    },
    {
      "indent": 3,
      "text": "[RFC6347] Rescorla, E. and N. Modadugu, \"Datagram Transport Layer Security Version 1.2\", RFC 6347, DOI 10.17487/RFC6347, January 2012, <http://www.rfc-editor.org/info/rfc6347>.",
      "ja": "[RFC6347]レスコラ、E.およびN. Modadugu、 \"データグラムトランスポート層セキュリティバージョン1.2\"、RFC 6347、DOI 10.17487 / RFC6347、2012年1月、<http://www.rfc-editor.org/info/rfc6347>。"
    },
    {
      "indent": 3,
      "text": "[RFC7457] Sheffer, Y., Holz, R., and P. Saint-Andre, \"Summarizing Known Attacks on Transport Layer Security (TLS) and Datagram TLS (DTLS)\", RFC 7457, DOI 10.17487/RFC7457, February 2015, <http://www.rfc-editor.org/info/rfc7457>.",
      "ja": "[RFC7457]シェファー、Y.、ホルツ、R.、およびP.サンアンドレ、RFC 7457、DOI 10.17487 / RFC7457、2015年2月、 \"トランスポート層セキュリティ（TLS）およびデータグラムTLS（DTLS）上の既知の攻撃をまとめます\" <http://www.rfc-editor.org/info/rfc7457>。"
    },
    {
      "indent": 3,
      "text": "[RFC7568] Barnes, R., Thomson, M., Pironti, A., and A. Langley, \"Deprecating Secure Sockets Layer Version 3.0\", RFC 7568, DOI 10.17487/RFC7568, June 2015, <http://www.rfc-editor.org/info/rfc7568>.",
      "ja": "[RFC7568]バーンズ、R.、トムソン、M.、Pironti、A.、およびA.ラングレー、RFC 7568 \"のSecure Sockets Layerバージョン3.0を非推奨\"、DOI 10.17487 / RFC7568、2015年6月、<のhttp：// WWW。 rfc-editor.org/info/rfc7568>。"
    },
    {
      "indent": 3,
      "text": "[SP800-108] Chen, L., \"Recommendation for Key Derivation Using Pseudorandom Functions (Revised)\", NIST Special Publication 800-108, 2009.",
      "ja": "[SP800-108]チェン、L.、 \"擬似ランダム関数を使用した鍵導出のための勧告（改訂）\"、は、NIST Special Publication 800から108、2009。"
    },
    {
      "indent": 3,
      "text": "[TRIPLE-HS] Bhargavan, K., Delignat-Lavaud, A., Fournet, C., Pironti, A., and P-Y. Strub, \"Triple Handshakes and Cookie Cutters: Breaking and Fixing Authentication over TLS\", IEEE Symposium on Security and Privacy, DOI 10.1109/SP.2014.14, 2014.",
      "ja": "[TRIPLE-HS] Bhargavan、K.、Delignat-Lavaud、A.、フルネ、C.、Pironti、A.、およびP-Y。セキュリティとプライバシー上、IEEEシンポジウム、DOI 10.1109 / SP.2014.14、2014：Strub、「壊すとTLS上で認証を修正トリプル握手やクッキーカッター」。"
    },
    {
      "indent": 3,
      "text": "[VERIFIED-BINDINGS] Bhargavan, K., Delignat-Lavaud, A., and A. Pironti, \"Verified Contributive Channel Bindings for Compound Authentication\", Network and Distributed System Security Symposium (NDSS), 2015.",
      "ja": "[VERIFIED-BINDINGS] Bhargavan、K.、Delignat-Lavaud、A.、およびA. Pironti、 \"化合物認証の確認済み寄与するチャネルバインディング\"、ネットワークと分散システムセキュリティシンポジウム（NDSS）、2015。"
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Triple handshake attacks were originally discovered by Antoine Delignat-Lavaud, Karthikeyan Bhargavan, and Alfredo Pironti. They were further developed by the miTLS team: Cedric Fournet, Pierre-Yves Strub, Markulf Kohlweiss, and Santiago Zanella-Beguelin. Many of the ideas in this document emerged from discussions with Martin Abadi, Ben Laurie, Nikos Mavrogiannopoulos, Manuel Pegourie-Gonnard, Eric Rescorla, Martin Rex, and Brian Smith.",
      "ja": "トリプルハンドシェイクの攻撃は、もともとアントワーヌDelignat-Lavaud、カーティケヤンBhargavan、そしてアルフレドPirontiによって発見されました。彼らはさらにmiTLSチームによって開発されました：セドリック・フルネ、ピエール・イヴ・Strub、Markulf Kohlweiss、サンティアゴZanella-Beguelinを。この文書のアイデアの多くは、マーティン・アバディ、ベン・ローリー、ニコスMavrogiannopoulos、マヌエルPegourie-Gonnard、エリックレスコラ、マーティン・レックス、そしてブライアン・スミスとの議論から生まれました。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Karthikeyan Bhargavan (editor) Inria Paris-Rocquencourt 23, Avenue d'Italie Paris 75214 CEDEX 13 France",
      "ja": "カーティケヤンBhargavan（エディタ）INRIAパリRocquencourt 23アベニューディタリー75214パリセデックス13フランス"
    },
    {
      "indent": 3,
      "text": "Email: karthikeyan.bhargavan@inria.fr",
      "ja": "メール：karthikeyan.bhargavan@inria.fr"
    },
    {
      "indent": 3,
      "text": "Antoine Delignat-Lavaud Inria Paris-Rocquencourt 23, Avenue d'Italie Paris 75214 CEDEX 13 France",
      "ja": "アントワーヌDelignat-Lavaud INRIAパリRocquencourt 23アベニューディタリー75214パリセデックス13フランス"
    },
    {
      "indent": 3,
      "text": "Email: antoine.delignat-lavaud@inria.fr",
      "ja": "メール：antoine.delignat-lavaud@inria.fr"
    },
    {
      "indent": 3,
      "text": "Alfredo Pironti Inria Paris-Rocquencourt 23, Avenue d'Italie Paris 75214 CEDEX 13 France",
      "ja": "アルフレドPironti INRIAパリ -  Rocquencourt 23、アベニューディタリー75214パリセデックス13フランス"
    },
    {
      "indent": 3,
      "text": "Email: alfredo.pironti@inria.fr",
      "ja": "メール：alfredo.pironti@inria.fr"
    },
    {
      "indent": 3,
      "text": "Adam Langley Google Inc. 1600 Amphitheatre Parkway Mountain View, CA 94043 United States",
      "ja": "アダム・ラングレーグーグル株式会社1600アンフィシアターパークウェイマウンテンビュー、CA 94043米国"
    },
    {
      "indent": 3,
      "text": "Email: agl@google.com",
      "ja": "メール：agl@google.com"
    },
    {
      "indent": 3,
      "text": "Marsh Ray Microsoft Corp. 1 Microsoft Way Redmond, WA 98052 United States",
      "ja": "マーシュレイマイクロソフト社1マイクロソフト道レドモンド、WA 98052米国"
    },
    {
      "indent": 3,
      "text": "Email: maray@microsoft.com",
      "ja": "メール：maray@microsoft.com"
    }
  ]
}