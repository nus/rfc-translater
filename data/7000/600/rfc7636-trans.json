{
  "title": {
    "text": "RFC 7636 - Proof Key for Code Exchange by OAuth Public Clients",
    "ja": "RFC 7636 - OAuthの公開クライアントによるコードの交換のための証明キー"
  },
  "number": 7636,
  "created_at": "2019-10-31 12:28:57.472585+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                  N. Sakimura, Ed.\nRequest for Comments: 7636                     Nomura Research Institute\nCategory: Standards Track                                     J. Bradley\nISSN: 2070-1721                                            Ping Identity\n                                                              N. Agarwal\n                                                                  Google\n                                                          September 2015",
      "raw": true
    },
    {
      "indent": 10,
      "text": "Proof Key for Code Exchange by OAuth Public Clients",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "OAuth 2.0 public clients utilizing the Authorization Code Grant are susceptible to the authorization code interception attack. This specification describes the attack as well as a technique to mitigate against the threat through the use of Proof Key for Code Exchange (PKCE, pronounced \"pixy\").",
      "ja": "認証コードグラントを利用OAuth 2.0のパブリッククライアントは、認証コードの傍受攻撃を受けやすいです。この仕様は、攻撃だけでなく、コードの交換（PKCE、発音「PIXY」）のための証明のキーを使用して脅威を軽減する技術が記載されています。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 5741のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7636.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7636で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2015 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2015 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................3\n   1.1. Protocol Flow ..............................................5\n2. Notational Conventions ..........................................6\n3. Terminology .....................................................7\n   3.1. Abbreviations ..............................................7\n4. Protocol ........................................................8\n   4.1. Client Creates a Code Verifier .............................8\n   4.2. Client Creates the Code Challenge ..........................8\n   4.3. Client Sends the Code Challenge with the\n        Authorization Request ......................................9\n   4.4. Server Returns the Code ....................................9\n        4.4.1. Error Response ......................................9\n   4.5. Client Sends the Authorization Code and the Code\n        Verifier to the Token Endpoint ............................10\n   4.6. Server Verifies code_verifier before Returning the\n        Tokens ....................................................10\n5. Compatibility ..................................................11\n6. IANA Considerations ............................................11\n   6.1. OAuth Parameters Registry .................................11\n   6.2. PKCE Code Challenge Method Registry .......................11\n        6.2.1. Registration Template ..............................12\n        6.2.2. Initial Registry Contents ..........................13\n7. Security Considerations ........................................13\n   7.1. Entropy of the code_verifier ..............................13\n   7.2. Protection against Eavesdroppers ..........................13\n   7.3. Salting the code_challenge ................................14\n   7.4. OAuth Security Considerations .............................14\n   7.5. TLS Security Considerations ...............................15\n8. References .....................................................15\n   8.1. Normative References ......................................15\n   8.2. Informative References ....................................16\nAppendix A.  Notes on Implementing Base64url Encoding without\n             Padding  .............................................17\nAppendix B.  Example for the S256 code_challenge_method ...........17\nAcknowledgements ..................................................19\nAuthors' Addresses ................................................20",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "OAuth 2.0 [RFC6749] public clients are susceptible to the authorization code interception attack.",
      "ja": "OAuth 2.0の[RFC6749]パブリッククライアントは、認証コードの傍受攻撃を受けやすいです。"
    },
    {
      "indent": 3,
      "text": "In this attack, the attacker intercepts the authorization code returned from the authorization endpoint within a communication path not protected by Transport Layer Security (TLS), such as inter-application communication within the client's operating system.",
      "ja": "この攻撃では、攻撃者は、このようなクライアントのオペレーティングシステム内のアプリケーション間通信などのトランスポート層セキュリティ（TLS）によって保護されていない通信経路内に認可エンドポイントから返された認証コードを、傍受します。"
    },
    {
      "indent": 3,
      "text": "Once the attacker has gained access to the authorization code, it can use it to obtain the access token.",
      "ja": "攻撃者が認可コードへのアクセスを獲得していたら、それはアクセストークンを取得するためにそれを使用することができます。"
    },
    {
      "indent": 3,
      "text": "Figure 1 shows the attack graphically. In step (1), the native application running on the end device, such as a smartphone, issues an OAuth 2.0 Authorization Request via the browser/operating system. The Redirection Endpoint URI in this case typically uses a custom URI scheme. Step (1) happens through a secure API that cannot be intercepted, though it may potentially be observed in advanced attack scenarios. The request then gets forwarded to the OAuth 2.0 authorization server in step (2). Because OAuth requires the use of TLS, this communication is protected by TLS and cannot be intercepted. The authorization server returns the authorization code in step (3). In step (4), the Authorization Code is returned to the requester via the Redirection Endpoint URI that was provided in step (1).",
      "ja": "図1は、グラフ攻撃を示しています。工程（1）、エンドデバイス上で実行されているネイティブアプリケーションは、スマートフォン等、ブラウザ/オペレーティングシステムを介してOAuth 2.0の承認要求を発行します。この場合、リダイレクトエンドポイントURIは通常、カスタムURIスキームを使用しています。ステップ（1）は、それが潜在的に高度な攻撃シナリオで観察することができるものの、傍受することができない安全なAPIを介して行われます。要求は、ステップ（2）でOAuth 2.0の認証サーバに転送されます。 OAuthのは、TLSを使用する必要があるため、この通信はTLSで保護されており、傍受することはできません。認証サーバは、ステップ（3）中の認証コードを返します。ステップ（4）において、認証コードは、ステップ（1）に設けられたリダイレクトURIエンドポイントを介して要求元に返されます。"
    },
    {
      "indent": 3,
      "text": "Note that it is possible for a malicious app to register itself as a handler for the custom scheme in addition to the legitimate OAuth 2.0 app. Once it does so, the malicious app is now able to intercept the authorization code in step (4). This allows the attacker to request and obtain an access token in steps (5) and (6), respectively.",
      "ja": "悪意のあるアプリが正当なOAuth 2.0のアプリに加えて、カスタムスキームのハンドラとして自身を登録することが可能であることに注意してください。それはそうすると、悪意のあるアプリが今のステップ（4）に認証コードを傍受することができます。これにより、攻撃者は、（5）及び（6）、それぞれのステップでアクセストークンを要求し、取得することを可能にします。"
    },
    {
      "indent": 4,
      "text": "+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+\n| End Device (e.g., Smartphone)  |\n|                                |\n| +-------------+   +----------+ | (6) Access Token  +----------+\n| |Legitimate   |   | Malicious|<--------------------|          |\n| |OAuth 2.0 App|   | App      |-------------------->|          |\n| +-------------+   +----------+ | (5) Authorization |          |\n|        |    ^          ^       |        Grant      |          |\n|        |     \\         |       |                   |          |\n|        |      \\   (4)  |       |                   |          |\n|    (1) |       \\  Authz|       |                   |          |\n|   Authz|        \\ Code |       |                   |  Authz   |\n| Request|         \\     |       |                   |  Server  |\n|        |          \\    |       |                   |          |\n|        |           \\   |       |                   |          |\n|        v            \\  |       |                   |          |\n| +----------------------------+ |                   |          |\n| |                            | | (3) Authz Code    |          |\n| |     Operating System/      |<--------------------|          |\n| |         Browser            |-------------------->|          |\n| |                            | | (2) Authz Request |          |\n| +----------------------------+ |                   +----------+\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+",
      "raw": true
    },
    {
      "indent": 13,
      "text": "Figure 1: Authorization Code Interception Attack",
      "ja": "図1：認証コード傍受攻撃"
    },
    {
      "indent": 3,
      "text": "A number of pre-conditions need to hold for this attack to work:",
      "ja": "事前条件の数は、仕事へのこの攻撃のために保持する必要があります。"
    },
    {
      "indent": 3,
      "text": "1. The attacker manages to register a malicious application on the client device and registers a custom URI scheme that is also used by another application. The operating systems must allow a custom URI scheme to be registered by multiple applications.",
      "ja": "1.攻撃者は、クライアントデバイス上で悪意のあるアプリケーションを登録して管理し、また、別のアプリケーションで使用されるカスタムURIスキームを登録します。オペレーティング・システムは、カスタムURIスキームは、複数のアプリケーションで登録できるようにする必要があります。"
    },
    {
      "indent": 3,
      "text": "2. The OAuth 2.0 authorization code grant is used.",
      "section_title": true,
      "ja": "2. OAuth 2.0の認証コードグラントが使用されます。"
    },
    {
      "indent": 3,
      "text": "3. The attacker has access to the OAuth 2.0 [RFC6749] \"client_id\" and \"client_secret\" (if provisioned). All OAuth 2.0 native app client-instances use the same \"client_id\". Secrets provisioned in client binary applications cannot be considered confidential.",
      "ja": "3.攻撃者は、OAuth 2.0の[RFC6749] \"CLIENT_ID\" および \"client_secret\"（プロビジョニングされている場合）へのアクセスを有します。すべてのOAuth 2.0のネイティブアプリのクライアント・インスタンスは、同じ「CLIENT_ID」を使用します。クライアントバイナリアプリケーションにプロビジョニングさの秘密は、機密とみなすことはできません。"
    },
    {
      "indent": 3,
      "text": "4. Either one of the following condition is met:",
      "section_title": true,
      "ja": "4.いずれかの次の条件が満たされているの1："
    },
    {
      "indent": 6,
      "text": "4a. The attacker (via the installed application) is able to observe only the responses from the authorization endpoint. When \"code_challenge_method\" value is \"plain\", only this attack is mitigated.",
      "ja": "図4（a）。 （インストールされたアプリケーションを介した）攻撃者が認可エンドポイントからのみの応答を観察することができます。 「code_challenge_method」の値が「プレーン」である場合には、これだけの攻撃が緩和されます。"
    },
    {
      "indent": 6,
      "text": "4b. A more sophisticated attack scenario allows the attacker to observe requests (in addition to responses) to the authorization endpoint. The attacker is, however, not able to act as a man in the middle. This was caused by leaking http log information in the OS. To mitigate this, \"code_challenge_method\" value must be set either to \"S256\" or a value defined by a cryptographically secure \"code_challenge_method\" extension.",
      "ja": "図4b。より洗練された攻撃のシナリオでは、攻撃者が認可エンドポイントに（応答に加えて）要求を観察することができます。攻撃者は、しかし、真ん中の男として機能することができません。これは、OSのHTTPログ情報の漏洩によって引き起こされました。これを緩和するために、「code_challenge_method」値が「S256」や暗号化された安全な「code_challenge_method」の拡張子で定義された値のいずれかに設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "While this is a long list of pre-conditions, the described attack has been observed in the wild and has to be considered in OAuth 2.0 deployments. While the OAuth 2.0 threat model (Section 4.4.1 of [RFC6819]) describes mitigation techniques, they are, unfortunately, not applicable since they rely on a per-client instance secret or a per-client instance redirect URI.",
      "ja": "これは前提条件の長いリストですが、説明した攻撃は野生で観察し、OAuth 2.0の展開で考慮しなければならないされています。 OAuth 2.0の脅威モデル（[RFC6819]のセクション4.4.1）が軽減手法について説明しているが、彼らは秘密ごとのクライアントインスタンスに依存しているか、クライアントごとのインスタンスは、URIをリダイレクトするので、彼らは、該当残念ながら、ありません。"
    },
    {
      "indent": 3,
      "text": "To mitigate this attack, this extension utilizes a dynamically created cryptographically random key called \"code verifier\". A unique code verifier is created for every authorization request, and its transformed value, called \"code challenge\", is sent to the authorization server to obtain the authorization code. The authorization code obtained is then sent to the token endpoint with the \"code verifier\", and the server compares it with the previously received request code so that it can perform the proof of possession of the \"code verifier\" by the client. This works as the mitigation since the attacker would not know this one-time key, since it is sent over TLS and cannot be intercepted.",
      "ja": "この攻撃を緩和するために、この拡張機能は、「コード検証」と呼ばれる動的に作成、暗号ランダムキーを利用しています。ユニークなコード検証は、すべての認証要求のために作成され、「コードの挑戦」と呼ばれるその変換値は、認証コードを取得するために、認証サーバーに送信されます。取得した認証コードは、「コード検証」とトークンエンドポイントに送信され、それがクライアントによる「コード検証」を所有していることの証明を行うことができるように、サーバーは、以前に受信した要求コードと比較します。それがTLS上で送信され、傍受することができないため、攻撃者は、このワンタイムキーを知っているだろうから、これは緩和策として動作します。"
    },
    {
      "indent": 0,
      "text": "1.1. Protocol Flow",
      "section_title": true,
      "ja": "1.1。プロトコルフロー"
    },
    {
      "indent": 7,
      "text": "                                          +-------------------+\n                                          |   Authz Server    |\n+--------+                                | +---------------+ |\n|        |--(A)- Authorization Request ---->|               | |\n|        |       + t(code_verifier), t_m  | | Authorization | |\n|        |                                | |    Endpoint   | |\n|        |<-(B)---- Authorization Code -----|               | |\n|        |                                | +---------------+ |\n| Client |                                |                   |\n|        |                                | +---------------+ |\n|        |--(C)-- Access Token Request ---->|               | |\n|        |          + code_verifier       | |    Token      | |\n|        |                                | |   Endpoint    | |\n|        |<-(D)------ Access Token ---------|               | |\n+--------+                                | +---------------+ |\n                                          +-------------------+",
      "raw": true
    },
    {
      "indent": 21,
      "text": "Figure 2: Abstract Protocol Flow",
      "ja": "図2：抽象プロトコルフロー"
    },
    {
      "indent": 3,
      "text": "This specification adds additional parameters to the OAuth 2.0 Authorization and Access Token Requests, shown in abstract form in Figure 2.",
      "ja": "この仕様は、図2に抽象的形式で示さOAuth 2.0の認証とアクセストークンリクエストに追加のパラメータを追加します。"
    },
    {
      "indent": 3,
      "text": "A. The client creates and records a secret named the \"code_verifier\" and derives a transformed version \"t(code_verifier)\" (referred to as the \"code_challenge\"), which is sent in the OAuth 2.0 Authorization Request along with the transformation method \"t_m\".",
      "ja": "A.クライアントが作成され、「code_verifier」という名前の秘密を記録し、形質転換法」と共にOAuth 2.0の認可リクエストで送信され変換されたバージョン（「code_challenge」と呼ばれる）「T（code_verifier）」を導出しますt_m」。"
    },
    {
      "indent": 3,
      "text": "B. The Authorization Endpoint responds as usual but records \"t(code_verifier)\" and the transformation method.",
      "ja": "B.ザ認可エンドポイントは通常どおり応答しますが、レコードの「T（code_verifier）」および変換方法。"
    },
    {
      "indent": 3,
      "text": "C. The client then sends the authorization code in the Access Token Request as usual but includes the \"code_verifier\" secret generated at (A).",
      "ja": "C.次に、クライアントは通常どおりアクセストークンリクエストに認証コードを送信しますが、（A）で生成された「code_verifier」秘密が含まれています。"
    },
    {
      "indent": 3,
      "text": "D. The authorization server transforms \"code_verifier\" and compares it to \"t(code_verifier)\" from (B). Access is denied if they are not equal.",
      "ja": "D.認証サーバは、 \"code_verifier\" を変換し、（B）から、 \"T（code_verifier）\" と比較します。彼らが等しくない場合は、アクセスが拒否されます。"
    },
    {
      "indent": 3,
      "text": "An attacker who intercepts the authorization code at (B) is unable to redeem it for an access token, as they are not in possession of the \"code_verifier\" secret.",
      "ja": "（B）で認証コードをインターセプトし、攻撃者は、彼らが「code_verifier」秘密の保持していないとして、アクセストークンのためにそれを償還することができません。"
    },
    {
      "indent": 0,
      "text": "2. Notational Conventions",
      "section_title": true,
      "ja": "2.表記規則"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in \"Key words for use in RFCs to Indicate Requirement Levels\" [RFC2119]. If these words are used without being spelled in uppercase, then they are to be interpreted with their natural language meanings.",
      "ja": "キーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、 \"SHALL\"、 \"SHOULD\"、 \"ないもの\"、 \"推奨\" \"ない（SHOULD NOT）\"、 \"MAY\"、 \"推奨NOT\"、および「OPTIONAL要求レベルを示すためのRFCsにおける使用のためのキーワード 『[RFC2119]」に記載されているように、この文書で解釈されるべきです』。これらの単語は大文字で指定されずに使用されている場合、彼らは自然言語の意味で解釈されるべきです。"
    },
    {
      "indent": 3,
      "text": "This specification uses the Augmented Backus-Naur Form (ABNF) notation of [RFC5234].",
      "ja": "この仕様は、[RFC5234]の増補バッカス - ナウアフォーム（ABNF）の表記を使用します。"
    },
    {
      "indent": 3,
      "text": "STRING denotes a sequence of zero or more ASCII [RFC20] characters.",
      "ja": "STRINGは、ゼロ個以上のASCII [RFC20]文字の配列を意味します。"
    },
    {
      "indent": 3,
      "text": "OCTETS denotes a sequence of zero or more octets.",
      "ja": "オクテットは、ゼロ以上のオクテットのシーケンスを示しています。"
    },
    {
      "indent": 3,
      "text": "ASCII(STRING) denotes the octets of the ASCII [RFC20] representation of STRING where STRING is a sequence of zero or more ASCII characters.",
      "ja": "ASCII（文字列）文字列は、ゼロ個以上のASCII文字のシーケンスであるSTRINGのASCII [RFC20]表現のオクテットを表します。"
    },
    {
      "indent": 3,
      "text": "BASE64URL-ENCODE(OCTETS) denotes the base64url encoding of OCTETS, per Appendix A, producing a STRING.",
      "ja": "BASE64URL-ENCODE（オクテット）文字列を生成し、付録Aあたり、オクテットのbase64url符号化を示しています。"
    },
    {
      "indent": 3,
      "text": "BASE64URL-DECODE(STRING) denotes the base64url decoding of STRING, per Appendix A, producing a sequence of octets.",
      "ja": "BASE64URLデコード（STRING）オクテットのシーケンスを生成する、付録Aあたり、STRINGのbase64url復号化を表します。"
    },
    {
      "indent": 3,
      "text": "SHA256(OCTETS) denotes a SHA2 256-bit hash [RFC6234] of OCTETS.",
      "ja": "SHA256（オクテット）オクテットのSHA2 256ビットのハッシュ[RFC6234]です。"
    },
    {
      "indent": 0,
      "text": "3. Terminology",
      "section_title": true,
      "ja": "3.用語"
    },
    {
      "indent": 3,
      "text": "In addition to the terms defined in OAuth 2.0 [RFC6749], this specification defines the following terms:",
      "ja": "OAuth 2.0の[RFC6749]で定義された用語に加えて、本明細書では以下の用語を定義します。"
    },
    {
      "indent": 3,
      "text": "code verifier A cryptographically random string that is used to correlate the authorization request to the token request.",
      "ja": "コードは、トークン要求に対する認証要求を相関させるために使用され、暗号ランダムな文字列を検証者。"
    },
    {
      "indent": 3,
      "text": "code challenge A challenge derived from the code verifier that is sent in the authorization request, to be verified against later.",
      "ja": "コードは、後に照合する、認証要求で送信されたコード検証に由来する課題に挑戦します。"
    },
    {
      "indent": 3,
      "text": "code challenge method A method that was used to derive code challenge.",
      "ja": "コードチャレンジ方式コードチャレンジを導出するために使用された方法。"
    },
    {
      "indent": 3,
      "text": "Base64url Encoding Base64 encoding using the URL- and filename-safe character set defined in Section 5 of [RFC4648], with all trailing '=' characters omitted (as permitted by Section 3.2 of [RFC4648]) and without the inclusion of any line breaks, whitespace, or other additional characters. (See Appendix A for notes on implementing base64url encoding without padding.)",
      "ja": "Base64urlエンコードBase64では省略してすべての後続「=」文字（[RFC4648]のセクション3.2により許容されるように）を用いて、任意の改行を含めることなく、URL-と[RFC4648]のセクション5で定義されたファイル名で安全なキャラクタ・セットを使用して符号化します、空白、または他の追加の文字。 （パディングなしbase64urlエンコーディングを実装する上での注意事項については、付録Aを参照してください。）"
    },
    {
      "indent": 0,
      "text": "3.1. Abbreviations",
      "section_title": true,
      "ja": "3.1。略語"
    },
    {
      "indent": 3,
      "text": "ABNF Augmented Backus-Naur Form",
      "ja": "ABNF増補BNF記法"
    },
    {
      "indent": 3,
      "text": "Authz Authorization",
      "ja": "authz認証"
    },
    {
      "indent": 3,
      "text": "PKCE Proof Key for Code Exchange",
      "ja": "コード交換のためのPKCE証明キー"
    },
    {
      "indent": 3,
      "text": "MITM Man-in-the-middle",
      "ja": "MITMのman-in-the-middle"
    },
    {
      "indent": 3,
      "text": "MTI Mandatory To Implement",
      "ja": "実装するには必須のMTI"
    },
    {
      "indent": 0,
      "text": "4. Protocol",
      "section_title": true,
      "ja": "4.プロトコル"
    },
    {
      "indent": 0,
      "text": "4.1. Client Creates a Code Verifier",
      "section_title": true,
      "ja": "4.1。クライアントは、コードの検証を作成します。"
    },
    {
      "indent": 3,
      "text": "The client first creates a code verifier, \"code_verifier\", for each OAuth 2.0 [RFC6749] Authorization Request, in the following manner:",
      "ja": "クライアントは、まず以下のようにして、各OAuth 2.0の[RFC6749]承認要求に対して、コード検証、「code_verifier」を作成します。"
    },
    {
      "indent": 3,
      "text": "code_verifier = high-entropy cryptographic random STRING using the unreserved characters [A-Z] / [a-z] / [0-9] / \"-\" / \".\" / \"_\" / \"~\" from Section 2.3 of [RFC3986], with a minimum length of 43 characters and a maximum length of 128 characters.",
      "ja": "非予約文字を使用してcode_verifier =高エントロピー暗号ランダムSTRING [A-Z] / [-Z] / [0-9] / \" - \" \"\" / /「_」/「〜」43文字の最小長さと最大128文字の長さを有する、[RFC3986]のセクション2.3から。"
    },
    {
      "indent": 3,
      "text": "ABNF for \"code_verifier\" is as follows.",
      "ja": "以下のように「code_verifier」のためのABNFです。"
    },
    {
      "indent": 3,
      "text": "code-verifier = 43*128unreserved unreserved = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\" ALPHA = %x41-5A / %x61-7A DIGIT = %x30-39",
      "ja": "コード検証= 43 * 128unreserved無遠慮= ALPHA / DIGIT / \" - \" / \"\" / \"_\" / \"〜\" ALPHA =％x41-5A /％x61-7A DIGIT =％x30-39"
    },
    {
      "indent": 3,
      "text": "NOTE: The code verifier SHOULD have enough entropy to make it impractical to guess the value. It is RECOMMENDED that the output of a suitable random number generator be used to create a 32-octet sequence. The octet sequence is then base64url-encoded to produce a 43-octet URL safe string to use as the code verifier.",
      "ja": "注：コード検証は、値を推測することは非現実的作るのに十分なエントロピーを持つべきである（SHOULD）。適当な乱数発生器の出力は、32オクテットのシーケンスを作成するために使用することを推奨されています。オクテットシーケンスがbase64urlエンコードコード検証として使用する43オクテットURLの安全な文字列を生成することです。"
    },
    {
      "indent": 0,
      "text": "4.2. Client Creates the Code Challenge",
      "section_title": true,
      "ja": "4.2。クライアントはコードの挑戦を作成します。"
    },
    {
      "indent": 3,
      "text": "The client then creates a code challenge derived from the code verifier by using one of the following transformations on the code verifier:",
      "ja": "クライアントは、次に、コード検証に次の変換のいずれかを使用してコード検証に由来するコードチャレンジを作成します。"
    },
    {
      "indent": 3,
      "text": "plain code_challenge = code_verifier",
      "ja": "平野code_challenge = code_verifier"
    },
    {
      "indent": 3,
      "text": "S256 code_challenge = BASE64URL-ENCODE(SHA256(ASCII(code_verifier)))",
      "ja": "S256のcode_challenge = BASE64URL-ENCODE（SHA256（ASCII（code_verifier）））"
    },
    {
      "indent": 3,
      "text": "If the client is capable of using \"S256\", it MUST use \"S256\", as \"S256\" is Mandatory To Implement (MTI) on the server. Clients are permitted to use \"plain\" only if they cannot support \"S256\" for some technical reason and know via out-of-band configuration that the server supports \"plain\".",
      "ja": "クライアントは「S256」を使用することのできる場合は、「S256」は、サーバ上で（MTI）を実装する必須であるとして、それは、「S256」を使用しなければなりません。クライアントは、彼らはいくつかの技術的な理由で、「S256」をサポートし、サーバは「プレーン」をサポートアウトオブバンド構成を経由して知ることができない場合にのみ、「プレーン」の使用が許可されています。"
    },
    {
      "indent": 3,
      "text": "The plain transformation is for compatibility with existing deployments and for constrained environments that can't use the S256 transformation.",
      "ja": "普通変換は、既存の配備との互換性のため、およびS256の変換を使用することができない制限された環境のためのものです。"
    },
    {
      "indent": 3,
      "text": "ABNF for \"code_challenge\" is as follows.",
      "ja": "以下のように「code_challenge」のためのABNFです。"
    },
    {
      "indent": 3,
      "text": "code-challenge = 43*128unreserved unreserved = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\" ALPHA = %x41-5A / %x61-7A DIGIT = %x30-39",
      "ja": "コード-挑戦= 43 * 128unreserved予約されていない= ALPHA / DIGIT / \" - \" / \"\" / \"_\" / \"〜\" ALPHA =％x41-5A /％x61-7A DIGIT =％x30-39"
    },
    {
      "indent": 0,
      "text": "4.3. Client Sends the Code Challenge with the Authorization Request",
      "section_title": true,
      "ja": "4.3。クライアントが認証要求にコードチャレンジを送信します"
    },
    {
      "indent": 3,
      "text": "The client sends the code challenge as part of the OAuth 2.0 Authorization Request (Section 4.1.1 of [RFC6749]) using the following additional parameters:",
      "ja": "クライアントは、次の追加のパラメータを使用してOAuth 2.0の認可リクエスト（[RFC6749]のセクション4.1.1）の一部としてコードチャレンジを送信します。"
    },
    {
      "indent": 3,
      "text": "code_challenge REQUIRED. Code challenge.",
      "ja": "code_challenge REQUIRED。コード挑戦。"
    },
    {
      "indent": 3,
      "text": "code_challenge_method OPTIONAL, defaults to \"plain\" if not present in the request. Code verifier transformation method is \"S256\" or \"plain\".",
      "ja": "code_challenge_methodオプション、リクエストに存在しない場合は「プレーン」にデフォルト設定されています。コード検証変換方法は、「S256」または「普通」です。"
    },
    {
      "indent": 0,
      "text": "4.4. Server Returns the Code",
      "section_title": true,
      "ja": "4.4。サーバーは、コードを返します。"
    },
    {
      "indent": 3,
      "text": "When the server issues the authorization code in the authorization response, it MUST associate the \"code_challenge\" and \"code_challenge_method\" values with the authorization code so it can be verified later.",
      "ja": "サーバーが認証応答で認証コードを発行した場合、それは後で確認することができるので、それは認証コードを「code_challenge」と「code_challenge_method」の値を関連付ける必要があります。"
    },
    {
      "indent": 3,
      "text": "Typically, the \"code_challenge\" and \"code_challenge_method\" values are stored in encrypted form in the \"code\" itself but could alternatively be stored on the server associated with the code. The server MUST NOT include the \"code_challenge\" value in client requests in a form that other entities can extract.",
      "ja": "典型的には、「code_challenge」および「code_challenge_method」値は、「コード」は、それ自体で暗号化された形で格納されているが、代わりに、コードに関連付けられたサーバ上に格納することができます。サーバーは、他のエンティティを抽出できるという形で、クライアントの要求に「code_challenge」値を含んではいけません。"
    },
    {
      "indent": 3,
      "text": "The exact method that the server uses to associate the \"code_challenge\" with the issued \"code\" is out of scope for this specification.",
      "ja": "サーバが発行した「コード」と「code_challenge」を関連付けるために使用する正確な方法は、この仕様の範囲外です。"
    },
    {
      "indent": 0,
      "text": "4.4.1. Error Response",
      "section_title": true,
      "ja": "4.4.1。エラー応答"
    },
    {
      "indent": 3,
      "text": "If the server requires Proof Key for Code Exchange (PKCE) by OAuth public clients and the client does not send the \"code_challenge\" in the request, the authorization endpoint MUST return the authorization error response with the \"error\" value set to \"invalid_request\". The \"error_description\" or the response of \"error_uri\" SHOULD explain the nature of error, e.g., code challenge required.",
      "ja": "サーバはコードのOAuthパブリッククライアントによる取引所（PKCE）とのリクエストで「code_challenge」を送信しないクライアント用の証明キーを必要とする場合は、認可エンドポイントは「INVALID_REQUEST」に設定し、「エラー」の値を持つ認証エラー応答を返さなければなりません。 「しましたerror_description」または「error_uri」の応答は、例えば、コードの挑戦に必要な、エラーの性質を説明する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the server supporting PKCE does not support the requested transformation, the authorization endpoint MUST return the authorization error response with \"error\" value set to \"invalid_request\". The \"error_description\" or the response of \"error_uri\" SHOULD explain the nature of error, e.g., transform algorithm not supported.",
      "ja": "PKCEをサポートするサーバは、要求された変換をサポートしていない場合、認可エンドポイントは「INVALID_REQUEST」に設定し、「エラー」の値を持つ認証エラー応答を返さなければなりません。 「しましたerror_description」またはエラーの性質を説明しなければならない「error_uri」の応答は、例えば、アルゴリズムがサポートされていない変換します。"
    },
    {
      "indent": 0,
      "text": "4.5. Client Sends the Authorization Code and the Code Verifier to the Token Endpoint",
      "ja": "4.5。クライアントは、トークンエンドポイントへの認証コードとコードの検証を送信します"
    },
    {
      "indent": 3,
      "text": "Upon receipt of the Authorization Code, the client sends the Access Token Request to the token endpoint. In addition to the parameters defined in the OAuth 2.0 Access Token Request (Section 4.1.3 of [RFC6749]), it sends the following parameter:",
      "ja": "認証コードを受信すると、クライアントはトークンエンドポイントへのアクセストークン要求を送信します。 OAuth 2.0のアクセストークン要求（[RFC6749]のセクション4.1.3）で定義されたパラメータに加えて、それは次のパラメータを送信します。"
    },
    {
      "indent": 3,
      "text": "code_verifier REQUIRED. Code verifier",
      "ja": "code_verifier REQUIRED。コード検証"
    },
    {
      "indent": 3,
      "text": "The \"code_challenge_method\" is bound to the Authorization Code when the Authorization Code is issued. That is the method that the token endpoint MUST use to verify the \"code_verifier\".",
      "ja": "認証コードが発行されたときに「code_challenge_methodは」認証コードにバインドされています。これは、トークンエンドポイントが「code_verifier」を検証するために使用しなければならない方法です。"
    },
    {
      "indent": 0,
      "text": "4.6. Server Verifies code_verifier before Returning the Tokens",
      "section_title": true,
      "ja": "4.6。サーバーは、トークンを返す前にcode_verifier確認します"
    },
    {
      "indent": 3,
      "text": "Upon receipt of the request at the token endpoint, the server verifies it by calculating the code challenge from the received \"code_verifier\" and comparing it with the previously associated \"code_challenge\", after first transforming it according to the \"code_challenge_method\" method specified by the client.",
      "ja": "トークンエンドポイントの要求を受信すると、サーバは、最初で指定された「code_challenge_method」方法によれば、それを変換した後、受信した「code_verifier」からコードチャレンジを計算し、以前に関連した「code_challenge」と比較することにより、それを検証しますクライアント。"
    },
    {
      "indent": 3,
      "text": "If the \"code_challenge_method\" from Section 4.3 was \"S256\", the received \"code_verifier\" is hashed by SHA-256, base64url-encoded, and then compared to the \"code_challenge\", i.e.:",
      "ja": "セクション4.3「code_challenge_method」が「S256」であった場合、「code_challenge」、すなわちと比較し、次いで、受信した「code_verifier」は、SHA-256ハッシュさbase64urlエンコード、および.:"
    },
    {
      "indent": 3,
      "text": "BASE64URL-ENCODE(SHA256(ASCII(code_verifier))) == code_challenge",
      "ja": "BASE64URL-ENCODE（SHA256（ASCII（code_verifier）））== code_challenge"
    },
    {
      "indent": 3,
      "text": "If the \"code_challenge_method\" from Section 4.3 was \"plain\", they are compared directly, i.e.:",
      "ja": "4.3節から「code_challenge_methodは」「プレーン」だった場合、それらはすなわち、直接比較されています："
    },
    {
      "indent": 3,
      "text": "code_verifier == code_challenge.",
      "ja": "code_verifier == code_challenge。"
    },
    {
      "indent": 3,
      "text": "If the values are equal, the token endpoint MUST continue processing as normal (as defined by OAuth 2.0 [RFC6749]). If the values are not equal, an error response indicating \"invalid_grant\" as described in Section 5.2 of [RFC6749] MUST be returned.",
      "ja": "値が等しい場合（OAuth 2.0の[RFC6749]で定義されるように）、トークンエンドポイントは通常通り処理を継続しなければなりません。値が等しくない場合は、[RFC6749]のセクション5.2に記載されているように「invalid_grant」を示すエラー応答が返されなければなりません。"
    },
    {
      "indent": 0,
      "text": "5. Compatibility",
      "section_title": true,
      "ja": "5.互換性"
    },
    {
      "indent": 3,
      "text": "Server implementations of this specification MAY accept OAuth2.0 clients that do not implement this extension. If the \"code_verifier\" is not received from the client in the Authorization Request, servers supporting backwards compatibility revert to the OAuth 2.0 [RFC6749] protocol without this extension.",
      "ja": "この仕様のサーバ実装は、この拡張機能を実装していないOAuth2.0クライアントを受け入れることができます。 「code_verifierが」許可要求クライアントから受信されない場合、サーバーは、下位​​互換性この拡張なしのOAuth 2.0 [RFC6749]プロトコルに戻すサポート。"
    },
    {
      "indent": 3,
      "text": "As the OAuth 2.0 [RFC6749] server responses are unchanged by this specification, client implementations of this specification do not need to know if the server has implemented this specification or not and SHOULD send the additional parameters as defined in Section 4 to all servers.",
      "ja": "OAuth 2.0の[RFC6749]サーバ応答はこの仕様により変更されていないように、この仕様のクライアントの実装は、サーバはこの仕様を実装したりしていないかどうかを知る必要がありませんし、すべてのサーバーにセクション4で定義された追加のパラメータを送信すべきです。"
    },
    {
      "indent": 0,
      "text": "6. IANA Considerations",
      "section_title": true,
      "ja": "6. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "IANA has made the following registrations per this document.",
      "ja": "IANAはこのドキュメントごとに以下の登録を行いました。"
    },
    {
      "indent": 0,
      "text": "6.1. OAuth Parameters Registry",
      "section_title": true,
      "ja": "6.1。 OAuthのパラメータのレジストリ"
    },
    {
      "indent": 3,
      "text": "This specification registers the following parameters in the IANA \"OAuth Parameters\" registry defined in OAuth 2.0 [RFC6749].",
      "ja": "この仕様はOAuth 2.0の[RFC6749]で定義されたIANA「OAuthのパラメータ」レジストリに次のパラメータを登録します。"
    },
    {
      "indent": 3,
      "text": "o Parameter name: code_verifier o Parameter usage location: token request o Change controller: IESG o Specification document(s): RFC 7636 (this document)",
      "ja": "Oパラメータ名：code_verifier Oパラメータの使用場所：変更コントローラOトークン要求：IESG O仕様文書（S）：RFC 7636（本書）"
    },
    {
      "indent": 3,
      "text": "o Parameter name: code_challenge o Parameter usage location: authorization request o Change controller: IESG o Specification document(s): RFC 7636 (this document)",
      "ja": "Oパラメータ名：パラメータの使用場所O code_challenge：変更コントローラO許可要求：IESG O仕様文書（S）：RFC 7636（本書）"
    },
    {
      "indent": 3,
      "text": "o Parameter name: code_challenge_method o Parameter usage location: authorization request o Change controller: IESG o Specification document(s): RFC 7636 (this document)",
      "ja": "Oパラメータ名：code_challenge_method Oパラメータの使用場所：変更コントローラO許可要求：IESG O仕様文書（S）：RFC 7636（本書）"
    },
    {
      "indent": 0,
      "text": "6.2. PKCE Code Challenge Method Registry",
      "section_title": true,
      "ja": "6.2。 PKCEコードチャレンジ・メソッドレジストリ"
    },
    {
      "indent": 3,
      "text": "This specification establishes the \"PKCE Code Challenge Methods\" registry. The new registry should be a sub-registry of the \"OAuth Parameters\" registry.",
      "ja": "この仕様は、「PKCEコードチャレンジメソッド」レジストリを確立します。新しいレジストリは、「OAuthのパラメータ」レジストリのサブレジストリにする必要があります。"
    },
    {
      "indent": 3,
      "text": "Additional \"code_challenge_method\" types for use with the authorization endpoint are registered using the Specification Required policy [RFC5226], which includes review of the request by one or more Designated Experts (DEs). The DEs will ensure that there is at least a two-week review of the request on the oauth-ext-review@ietf.org mailing list and that any discussion on that list converges before they respond to the request. To allow for the allocation of values prior to publication, the Designated Expert(s) may approve registration once they are satisfied that an acceptable specification will be published.",
      "ja": "認可エンドポイントで使用するための追加の「code_challenge_method」タイプは、1つ以上の指定された専門家（DES）の要請の検討を含んで仕様が必要ポリシー[RFC5226]を使用して登録されています。 DESはoauth-ext-review@ietf.orgメーリングリストで、彼らは要求に応答する前に、そのリスト上のいずれかの議論が収束し、その要求の2週間の審査が少なくともあることを確認します。先行出版物への値の割り当てを可能にするために、指定された専門家（単数または複数）は、許容される仕様が公開されることを確認したら、登録を承認することができます。"
    },
    {
      "indent": 3,
      "text": "Registration requests and discussion on the oauth-ext-review@ietf.org mailing list should use an appropriate subject, such as \"Request for PKCE code_challenge_method: example\").",
      "ja": "）：登録要求とoauth-ext-review@ietf.orgメーリングリスト上の議論は、このような「例PKCEのcode_challenge_method要求」として、適切な件名を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "The Designated Expert(s) should consider the discussion on the mailing list, as well as the overall security properties of the challenge method when evaluating registration requests. New methods should not disclose the value of the code_verifier in the request to the Authorization endpoint. Denials should include an explanation and, if applicable, suggestions as to how to make the request successful.",
      "ja": "登録要求を評価する際に指定エキスパート（複数可）メーリングリストでの議論だけでなく、チャレンジ方法の全体的なセキュリティの特性を考慮する必要があります。新しいメソッドは、認可エンドポイントへの要求にcode_verifierの値を開示してはなりません。否定は説明と、該当する場合、要求を成功させる方法についての提案を含める必要があります。"
    },
    {
      "indent": 0,
      "text": "6.2.1. Registration Template",
      "section_title": true,
      "ja": "6.2.1。登録テンプレート"
    },
    {
      "indent": 3,
      "text": "Code Challenge Method Parameter Name: The name requested (e.g., \"example\"). Because a core goal of this specification is for the resulting representations to be compact, it is RECOMMENDED that the name be short -- not to exceed 8 characters without a compelling reason to do so. This name is case-sensitive. Names may not match other registered names in a case-insensitive manner unless the Designated Expert(s) states that there is a compelling reason to allow an exception in this particular case.",
      "ja": "コードチャレンジ・メソッドパラメータ名：要求された名前（例えば、「例えば」）。結果の表現はコンパクトにするために、この仕様の中核目標があるので、名前は短くすることが推奨されます - そうする説得力のある理由なしで8つの文字を超えることはありません。この名前は、大文字と小文字が区別されます。指定された専門家（s）は、この特定の場合に例外を可能にする魅力的な理由があることを述べない限り、名前は、大文字と小文字を区別しないようにして他の登録名と一致しない可能性があります。"
    },
    {
      "indent": 3,
      "text": "Change Controller: For Standards Track RFCs, state \"IESG\". For others, give the name of the responsible party. Other details (e.g., postal address, email address, and home page URI) may also be included.",
      "ja": "変更コントローラ：標準化過程のRFCは、状態「IESG」。他の人のために、責任者の名前を与えます。その他の詳細（例えば、住所、メールアドレス、ホームページURI）が含まれてもよいです。"
    },
    {
      "indent": 3,
      "text": "Specification Document(s): Reference to the document(s) that specifies the parameter, preferably including URI(s) that can be used to retrieve copies of the document(s). An indication of the relevant sections may also be included but is not required.",
      "ja": "仕様書（S）：文書（S）のコピーを取得するために使用することができ、好ましくは、URI（複数可）を含む、パラメータを指定する文書（複数可）への参照。関連するセクションの指示が含まれていてもよいが、必須ではありません。"
    },
    {
      "indent": 0,
      "text": "6.2.2. Initial Registry Contents",
      "section_title": true,
      "ja": "6.2.2。初期のレジストリ内容"
    },
    {
      "indent": 3,
      "text": "Per this document, IANA has registered the Code Challenge Method Parameter Names defined in Section 4.2 in this registry.",
      "ja": "このドキュメントごとに、IANAは、このレジストリ内のセクション4.2で定義されたコードのチャレンジ・メソッドパラメータ名を登録しています。"
    },
    {
      "indent": 3,
      "text": "o Code Challenge Method Parameter Name: plain o Change Controller: IESG o Specification Document(s): Section 4.2 of RFC 7636 (this document)",
      "ja": "Oコードチャレンジ・メソッドパラメータ名：平野変更コントローラーO：仕様ドキュメントO IESG（S）：RFC 7636のセクション4.2（本書）"
    },
    {
      "indent": 3,
      "text": "o Code Challenge Method Parameter Name: S256 o Change Controller: IESG o Specification Document(s): Section 4.2 of RFC 7636 (this document)",
      "ja": "Oコードチャレンジ・メソッドパラメータ名：変更コントローラーO S256：仕様ドキュメントO IESG（S）：RFC 7636のセクション4.2（本書）"
    },
    {
      "indent": 0,
      "text": "7. Security Considerations",
      "section_title": true,
      "ja": "7.セキュリティの考慮事項"
    },
    {
      "indent": 0,
      "text": "7.1. Entropy of the code_verifier",
      "section_title": true,
      "ja": "7.1。 code_verifierのエントロピー"
    },
    {
      "indent": 3,
      "text": "The security model relies on the fact that the code verifier is not learned or guessed by the attacker. It is vitally important to adhere to this principle. As such, the code verifier has to be created in such a manner that it is cryptographically random and has high entropy that it is not practical for the attacker to guess.",
      "ja": "セキュリティモデルは、コード検証を学んだか、攻撃者によって推測されていないという事実に依存しています。この原則を遵守することは極めて重要です。このように、コード検証は、暗号的にランダムであり、攻撃者が推測することは現実的ではないこと高いエントロピーを有するように作成されなければなりません。"
    },
    {
      "indent": 3,
      "text": "The client SHOULD create a \"code_verifier\" with a minimum of 256 bits of entropy. This can be done by having a suitable random number generator create a 32-octet sequence. The octet sequence can then be base64url-encoded to produce a 43-octet URL safe string to use as a \"code_challenge\" that has the required entropy.",
      "ja": "クライアントは、エントロピーの256ビットの最小と「code_verifier」を作成する必要があります。これは、適当な乱数発生器は、32オクテットシーケンスを作成有することによって行うことができます。オクテットシーケンスは、必要なエントロピーを有する「code_challenge」として使用する43オクテットURLの安全な文字列を生成するbase64urlエンコードすることができます。"
    },
    {
      "indent": 0,
      "text": "7.2. Protection against Eavesdroppers",
      "section_title": true,
      "ja": "7.2。盗聴者に対する保護"
    },
    {
      "indent": 3,
      "text": "Clients MUST NOT downgrade to \"plain\" after trying the \"S256\" method. Servers that support PKCE are required to support \"S256\", and servers that do not support PKCE will simply ignore the unknown \"code_verifier\". Because of this, an error when \"S256\" is presented can only mean that the server is faulty or that a MITM attacker is trying a downgrade attack.",
      "ja": "クライアントは、「S256」の方法を試した後、「プレーン」にダウングレードしてはなりません。 PKCEをサポートするサーバーは、「S256」をサポートするために必要な、とPKCEをサポートしていないサーバーでは、単に不明「code_verifier」を無視します。このため、「S256」は、提示されたエラーは、サーバーが故障またはMITM攻撃者は、ダウングレード攻撃をしようとしていることであることを意味します。"
    },
    {
      "indent": 3,
      "text": "The \"S256\" method protects against eavesdroppers observing or intercepting the \"code_challenge\", because the challenge cannot be used without the verifier. With the \"plain\" method, there is a chance that \"code_challenge\" will be observed by the attacker on the device or in the http request. Since the code challenge is the same as the code verifier in this case, the \"plain\" method does not protect against the eavesdropping of the initial request.",
      "ja": "課題は、検証せずに使用することはできませんので、「S256」の方法は、「c​​ode_challenge」を観察したり傍受盗聴者から保護します。 「プレーン」方法では、「code_challenge」はデバイス上またはHTTP要求で、攻撃者によって観察される可能性があります。コードの課題は、この場合、コード検証と同じであるので、「プレーン」方法は、最初の要求の盗聴を防ぐことはできません。"
    },
    {
      "indent": 3,
      "text": "The use of \"S256\" protects against disclosure of the \"code_verifier\" value to an attacker.",
      "ja": "「S256」の使用は、攻撃者に「code_verifier」価値の開示から保護します。"
    },
    {
      "indent": 3,
      "text": "Because of this, \"plain\" SHOULD NOT be used and exists only for compatibility with deployed implementations where the request path is already protected. The \"plain\" method SHOULD NOT be used in new implementations, unless they cannot support \"S256\" for some technical reason.",
      "ja": "このため、「プレーン」を使用するべきではなく、唯一の要求パスがすでに保護されて展開実装との互換性のために存在します。彼らはいくつかの技術的な理由で、「S256」をサポートすることができない場合を除き、「プレーン」の方法は、新しい実装では使用しないでください。"
    },
    {
      "indent": 3,
      "text": "The \"S256\" code challenge method or other cryptographically secure code challenge method extension SHOULD be used. The \"plain\" code challenge method relies on the operating system and transport security not to disclose the request to an attacker.",
      "ja": "「S256」のコードの挑戦方法または他の暗号化された安全なコードチャレンジ方式の拡張機能を使用する必要があります。 「プレーン」のコードの挑戦方法は、攻撃者に要求を開示しないオペレーティングシステムとトランスポート・セキュリティに依存しています。"
    },
    {
      "indent": 3,
      "text": "If the code challenge method is \"plain\" and the code challenge is to be returned inside authorization \"code\" to achieve a stateless server, it MUST be encrypted in such a manner that only the server can decrypt and extract it.",
      "ja": "コードの挑戦方法は、「プレーン」であると、コードの挑戦が承認「コード」の内側に返される場合、それはサーバのみが復号化し、それを抽出することができますように暗号化されなければならないステートレスサーバーを実現しています。"
    },
    {
      "indent": 0,
      "text": "7.3. Salting the code_challenge",
      "section_title": true,
      "ja": "7.3。 code_challengeを塩漬け"
    },
    {
      "indent": 3,
      "text": "To reduce implementation complexity, salting is not used in the production of the code challenge, as the code verifier contains sufficient entropy to prevent brute-force attacks. Concatenating a publicly known value to a code verifier (containing 256 bits of entropy) and then hashing it with SHA256 to produce a code challenge would not increase the number of attempts necessary to brute force a valid value for code verifier.",
      "ja": "コード検証は、ブルートフォース攻撃を防止するのに十分なエントロピーが含まれているとして、実装の複雑さを軽減するために、塩漬けは、コードの挑戦の製造に使用されていません。 （エントロピーの256ビットを含む）をコード検証に公知の値を連結した後、コードチャレンジを生成するSHA256とそれをハッシュするコード検証のための有効な値をブルートフォースに必要な試行の数を増加しないであろう。"
    },
    {
      "indent": 3,
      "text": "While the \"S256\" transformation is like hashing a password, there are important differences. Passwords tend to be relatively low-entropy words that can be hashed offline and the hash looked up in a dictionary. By concatenating a unique though public value to each password prior to hashing, the dictionary space that an attacker needs to search is greatly expanded.",
      "ja": "「S256」の変換は、パスワードをハッシュのようなものですが、重要な違いがあります。パスワードは、オフラインでハッシュされ、ハッシュは辞書で調べることができ、比較的低エントロピーの言葉になる傾向があります。ハッシュ前に各パスワードに固有かかわら公開値を連結することにより、攻撃者が検索する必要があると辞書スペースが大幅に拡大されます。"
    },
    {
      "indent": 3,
      "text": "Modern graphics processors now allow attackers to calculate hashes in real time faster than they could be looked up from a disk. This eliminates the value of the salt in increasing the complexity of a brute-force attack for even low-entropy passwords.",
      "ja": "現代のグラフィックス・プロセッサは現在、攻撃者が速く、彼らがディスクから見上げることができるよりも、リアルタイムでハッシュを計算することができます。これは、たとえ低エントロピーパスワードのブルートフォース攻撃の複雑さを増す中で、塩の値を排除します。"
    },
    {
      "indent": 0,
      "text": "7.4. OAuth Security Considerations",
      "section_title": true,
      "ja": "7.4。 OAuthのセキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "All the OAuth security analysis presented in [RFC6819] applies, so readers SHOULD carefully follow it.",
      "ja": "[RFC6819]に提示されたすべてのOAuthセキュリティ分析読者は慎重にそれに従うべきであるので、適用されます。"
    },
    {
      "indent": 0,
      "text": "7.5. TLS Security Considerations",
      "section_title": true,
      "ja": "7.5。 TLSセキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "Current security considerations can be found in \"Recommendations for Secure Use of Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)\" [BCP195]. This supersedes the TLS version recommendations in OAuth 2.0 [RFC6749].",
      "ja": "現在のセキュリティの考慮事項は、「トランスポート層セキュリティ（TLS）およびデータグラムトランスポート層セキュリティ（DTLS）のセキュアな利用のための提言」[BCP195]で見つけることができます。これはOAuth 2.0の[RFC6749]でTLSバージョンの推奨に取って代わります。"
    },
    {
      "indent": 0,
      "text": "8. References",
      "section_title": true,
      "ja": "8.参照文献"
    },
    {
      "indent": 0,
      "text": "8.1. Normative References",
      "section_title": true,
      "ja": "8.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[BCP195] Sheffer, Y., Holz, R., and P. Saint-Andre, \"Recommendations for Secure Use of Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)\", BCP 195, RFC 7525, May 2015, <http://www.rfc-editor.org/info/bcp195>.",
      "ja": "[BCP195]シェファー、Y.、ホルツ、R.、およびP.サンアンドレ、BCP 195、RFC 7525、2015年5月、 \"トランスポート層セキュリティ（TLS）およびデータグラムトランスポート層セキュリティ（DTLS）のセキュアな利用のための提言\" 、<http://www.rfc-editor.org/info/bcp195>。"
    },
    {
      "indent": 3,
      "text": "[RFC20] Cerf, V., \"ASCII format for network interchange\", STD 80, RFC 20, DOI 10.17487/RFC0020, October 1969, <http://www.rfc-editor.org/info/rfc20>.",
      "ja": "[RFC20]サーフ、V.、 \"ネットワークの交換のためのASCIIフォーマット\"、STD 80、RFC 20、DOI 10.17487 / RFC0020、1969年10月、<http://www.rfc-editor.org/info/rfc20>。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<http://www.rfc-editor.org/info/ RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC3986] Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform Resource Identifier (URI): Generic Syntax\", STD 66, RFC 3986, DOI 10.17487/RFC3986, January 2005, <http://www.rfc-editor.org/info/rfc3986>.",
      "ja": "[RFC3986]バーナーズ - リー、T.、フィールディング、R.、およびL. Masinter、 \"ユニフォームリソース識別子（URI）：汎用構文\"、STD 66、RFC 3986、DOI 10.17487 / RFC3986、2005年1月<HTTP：/ /www.rfc-editor.org/info/rfc3986>。"
    },
    {
      "indent": 3,
      "text": "[RFC4648] Josefsson, S., \"The Base16, Base32, and Base64 Data Encodings\", RFC 4648, DOI 10.17487/RFC4648, October 2006, <http://www.rfc-editor.org/info/rfc4648>.",
      "ja": "[RFC4648] Josefsson氏、S.、 \"Base16、Base32、およびBase64でデータエンコーディング\"、RFC 4648、DOI 10.17487 / RFC4648、2006年10月、<http://www.rfc-editor.org/info/rfc4648>。"
    },
    {
      "indent": 3,
      "text": "[RFC5226] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 5226, DOI 10.17487/RFC5226, May 2008, <http://www.rfc-editor.org/info/rfc5226>.",
      "ja": "[RFC5226] Narten氏、T.とH. Alvestrand、 \"RFCsにIANA問題部に書くためのガイドライン\"、BCP 26、RFC 5226、DOI 10.17487 / RFC5226、2008年5月、<http://www.rfc-editor.org /情報/ RFC5226>。"
    },
    {
      "indent": 3,
      "text": "[RFC5234] Crocker, D., Ed. and P. Overell, \"Augmented BNF for Syntax Specifications: ABNF\", STD 68, RFC 5234, DOI 10.17487/RFC5234, January 2008, <http://www.rfc-editor.org/info/rfc5234>.",
      "ja": "[RFC5234]クロッカー、D.、エド。そして、P. Overell、 \"構文仕様のための増大しているBNF：ABNF\"、STD 68、RFC 5234、DOI 10.17487 / RFC5234、2008年1月、<http://www.rfc-editor.org/info/rfc5234>。"
    },
    {
      "indent": 3,
      "text": "[RFC6234] Eastlake 3rd, D. and T. Hansen, \"US Secure Hash Algorithms (SHA and SHA-based HMAC and HKDF)\", RFC 6234, DOI 10.17487/RFC6234, May 2011, <http://www.rfc-editor.org/info/rfc6234>.",
      "ja": "[RFC6234]イーストレイク3日、D.とT.ハンセン、 \"米国のセキュアハッシュアルゴリズム（SHAとHMACとHKDF SHAベース）\"、RFC 6234、DOI 10.17487 / RFC6234、2011年5月、<のhttp：//www.rfc- editor.org/info/rfc6234>。"
    },
    {
      "indent": 3,
      "text": "[RFC6749] Hardt, D., Ed., \"The OAuth 2.0 Authorization Framework\", RFC 6749, DOI 10.17487/RFC6749, October 2012, <http://www.rfc-editor.org/info/rfc6749>.",
      "ja": "[RFC6749]ハルト、D.編、 \"OAuth 2.0の認証フレームワーク\"、RFC 6749、DOI 10.17487 / RFC6749、2012年10月、<http://www.rfc-editor.org/info/rfc6749>。"
    },
    {
      "indent": 0,
      "text": "8.2. Informative References",
      "section_title": true,
      "ja": "8.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[RFC6819] Lodderstedt, T., Ed., McGloin, M., and P. Hunt, \"OAuth 2.0 Threat Model and Security Considerations\", RFC 6819, DOI 10.17487/RFC6819, January 2013, <http://www.rfc-editor.org/info/rfc6819>.",
      "ja": "[RFC6819] Lodderstedt、T.、エド、McGloin、M.、およびP.ハント、 \"OAuth 2.0の脅威モデルおよびセキュリティに関する注意事項\"、RFC 6819、DOI 10.17487 / RFC6819、2013年1月、<のhttp：。//www.rfc -editor.org/info/rfc6819>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Notes on Implementing Base64url Encoding without Padding",
      "ja": "付録A.は、パディングなしの実装Base64urlエンコーディング上の注意します"
    },
    {
      "indent": 3,
      "text": "This appendix describes how to implement a base64url-encoding function without padding, based upon the standard base64-encoding function that uses padding.",
      "ja": "この付録では、パディングを使用して、標準的なbase64でエンコード機能に基づいて、パディングなしbase64urlエンコード機能を実装する方法について説明します。"
    },
    {
      "indent": 3,
      "text": "To be concrete, example C# code implementing these functions is shown below. Similar code could be used in other languages.",
      "ja": "具体的には、これらの機能を実装例C＃コードを以下に示します。同様のコードは、他の言語で使用することができます。"
    },
    {
      "indent": 5,
      "text": "static string base64urlencode(byte [] arg) { string s = Convert.ToBase64String(arg); // Regular base64 encoder s = s.Split('=')[0]; // Remove any trailing '='s s = s.Replace('+', '-'); // 62nd char of encoding s = s.Replace('/', '_'); // 63rd char of encoding return s; }",
      "ja": "静的文字列base64urlencode（バイト[]のarg）{文字列s = Convert.ToBase64String（引数）。 //正規BASE64符号S = s.Split（ '='）[0]; ;  -  //末尾 '='、S、S = s.Replace（ '' '+'）削除//符号S = s.Replace（ '/'、 '_'）の第62回チャー。 //エンコーディングリターンSの第63回はchar。 }"
    },
    {
      "indent": 3,
      "text": "An example correspondence between unencoded and encoded values follows. The octet sequence below encodes into the string below, which when decoded, reproduces the octet sequence.",
      "ja": "符号化されていないとエンコードされた値との間の例示的な対応は以下の通りです。以下オクテットシーケンスは、復号化する際、オクテットシーケンスを再生する、以下の文字列に符号化します。"
    },
    {
      "indent": 3,
      "text": "3 236 255 224 193",
      "ja": "３ ２３６ ２５５ ２２４ １９３"
    },
    {
      "indent": 3,
      "text": "A-z_4ME",
      "ja": "-z_4ME"
    },
    {
      "indent": 0,
      "text": "Appendix B. Example for the S256 code_challenge_method",
      "ja": "S256 code_challenge_method付録B.例"
    },
    {
      "indent": 3,
      "text": "The client uses output of a suitable random number generator to create a 32-octet sequence. The octets representing the value in this example (using JSON array notation) are:",
      "ja": "クライアントは、32オクテットのシーケンスを作成するために、適当な乱数発生器の出力を使用します。 （JSON配列表記を使用して）、この例では値を表すオクテットです。"
    },
    {
      "indent": 6,
      "text": "[116, 24, 223, 180, 151, 153, 224, 37, 79, 250, 96, 125, 216, 173, 187, 186, 22, 212, 37, 77, 105, 214, 191, 240, 91, 88, 5, 88, 83, 132, 141, 121]",
      "ja": "「１１６、 ２４、 ２２３、 １８０、 １５１、 １５３、 ２２４、 ３７、 ７９、 ２５０、 ９６、 １２５、 ２１６、 １７３、 １８７、 １８６、 ２２、 ２１２、 ３７、 ７７、 １０５、 ２１４、 １９１、 ２４０、 ９１、 ８８、 ５、 ８８、 ８３、 １３２、 １４１、 １２１」"
    },
    {
      "indent": 3,
      "text": "Encoding this octet sequence as base64url provides the value of the code_verifier:",
      "ja": "base64urlがcode_verifierの価値を提供し、このオクテット配列をコードします："
    },
    {
      "indent": 7,
      "text": "dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk",
      "ja": "dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk"
    },
    {
      "indent": 3,
      "text": "The code_verifier is then hashed via the SHA256 hash function to produce:",
      "ja": "code_verifierは、その後生成するためにSHA256ハッシュ関数を経由してハッシュ化されています。"
    },
    {
      "indent": 5,
      "text": "[19, 211, 30, 150, 26, 26, 216, 236, 47, 22, 177, 12, 76, 152, 46, 8, 118, 168, 120, 173, 109, 241, 68, 86, 110, 225, 137, 74, 203, 112, 249, 195]",
      "ja": "「１９、 ２１１、 ３０、 １５０、 ２６、 ２６、 ２１６、 ２３６、 ４７、 ２２、 １７７、 １２、 ７６、 １５２、 ４６、 ８、 １１８、 １６８、 １２０、 １７３、 １０９、 ２４１、 ６８、 ８６、 １１０、 ２２５、 １３７、 ７４、 ２０３、 １１２、 ２４９、 １９５」"
    },
    {
      "indent": 3,
      "text": "Encoding this octet sequence as base64url provides the value of the code_challenge:",
      "ja": "base64urlがcode_challengeの価値を提供し、このオクテット配列をコードします："
    },
    {
      "indent": 7,
      "text": "E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw-cM",
      "ja": "E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw-CM"
    },
    {
      "indent": 3,
      "text": "The authorization request includes:",
      "ja": "認証要求が含まれています："
    },
    {
      "indent": 7,
      "text": "code_challenge=E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw-cM\n&code_challenge_method=S256",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The authorization server then records the code_challenge and code_challenge_method along with the code that is granted to the client.",
      "ja": "認証サーバは、クライアントに付与されたコードと一緒にcode_challengeとcode_challenge_methodを記録します。"
    },
    {
      "indent": 3,
      "text": "In the request to the token_endpoint, the client includes the code received in the authorization response as well as the additional parameter:",
      "ja": "token_endpointへの要求では、クライアントは認証応答で受信したコードだけでなく、追加のパラメータが含まれています。"
    },
    {
      "indent": 7,
      "text": "code_verifier=dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk",
      "ja": "code_verifier = dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk"
    },
    {
      "indent": 3,
      "text": "The authorization server retrieves the information for the code grant. Based on the recorded code_challenge_method being S256, it then hashes and base64url-encodes the value of code_verifier:",
      "ja": "認証サーバは、コード付与のための情報を取得します。 S256ある記録code_challenge_methodに基づいて、それが次にハッシュとcode_verifierの値をbase64urlは、コード："
    },
    {
      "indent": 3,
      "text": "BASE64URL-ENCODE(SHA256(ASCII(code_verifier)))",
      "ja": "BASE64URL-ENCODE（SHA256（ASCII（code_verifier）））"
    },
    {
      "indent": 3,
      "text": "The calculated value is then compared with the value of \"code_challenge\":",
      "ja": "計算された値は、次に、「code_challenge」の値と比較されます。"
    },
    {
      "indent": 3,
      "text": "BASE64URL-ENCODE(SHA256(ASCII(code_verifier))) == code_challenge",
      "ja": "BASE64URL-ENCODE（SHA256（ASCII（code_verifier）））== code_challenge"
    },
    {
      "indent": 3,
      "text": "If the two values are equal, then the authorization server can provide the tokens as long as there are no other errors in the request. If the values are not equal, then the request must be rejected, and an error returned.",
      "ja": "二つの値が等しい場合、認証サーバは限りリクエストには他のエラーがないとしてトークンを提供することができます。値が等しくない場合、その要求は拒否され、エラーが返されなければなりません。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "The initial draft version of this specification was created by the OpenID AB/Connect Working Group of the OpenID Foundation.",
      "ja": "この仕様の初期ドラフト版は、OpenIDの財団のOpenIDのAB /接続ワーキンググループによって作成されました。"
    },
    {
      "indent": 3,
      "text": "This specification is the work of the OAuth Working Group, which includes dozens of active and dedicated participants. In particular, the following individuals contributed ideas, feedback, and wording that shaped and formed the final specification:",
      "ja": "この仕様は、アクティブと専用の参加者数十人が含まれてOAuthのワーキンググループの仕事です。具体的には、以下の個人は形のアイデア、フィードバック、および文言に貢献し、最終的な仕様を形成しました："
    },
    {
      "indent": 6,
      "text": "Anthony Nadalin, Microsoft Axel Nenker, Deutsche Telekom Breno de Medeiros, Google Brian Campbell, Ping Identity Chuck Mortimore, Salesforce Dirk Balfanz, Google Eduardo Gueiros, Jive Communications Hannes Tschonfenig, ARM James Manger, Telstra Justin Richer, MIT Kerberos Josh Mandel, Boston Children's Hospital Lewis Adam, Motorola Solutions Madjid Nakhjiri, Samsung Michael B. Jones, Microsoft Paul Madsen, Ping Identity Phil Hunt, Oracle Prateek Mishra, Oracle Ryo Ito, mixi Scott Tomilson, Ping Identity Sergey Beryozkin Takamichi Saito Torsten Lodderstedt, Deutsche Telekom William Denniss, Google",
      "ja": "アンソニーNadalin、マイクロソフトアクセルNenker、ドイツテレコムBreno・デ・メデイロス、Googleのブライアン・キャンベル、ピング・アイデンティティチャックMortimore、SalesforceのディルクBalfanz、GoogleのエドゥアルドGueiros、ジャイブ・コミュニケーションズハンネスTschonfenig、ARMジェームス・マンジェ、テルストラジャスティン・リシェ、MIT Kerberosのジョッシュ・マンデル、ボストン子供病院ルイスアダム、モトローラ・ソリューションズマジドNakhjiri、サムスンマイケルB.ジョーンズ、マイクロソフトポール・マドセン、ピング・アイデンティティーフィル・ハント、オラクルPrateek Mishra氏は、Oracle亮、伊藤、ミクシィスコットTomilson、ピング・アイデンティティセルゲイBeryozkin孝道斎藤トルステンLodderstedt、ドイツテレコムウィリアムDenniss、グーグル"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Nat Sakimura (editor) Nomura Research Institute 1-6-5 Marunouchi, Marunouchi Kitaguchi Bldg. Chiyoda-ku, Tokyo 100-0005 Japan",
      "ja": "なｔ さきむら （えぢとｒ） のむら れせあｒｃｈ いんｓちつて １ー６ー５ まるのうち、 まるのうち きたぐち Ｂｌｄｇ。 ちよだーく、 ときょ １００ー０００５ じゃぱん"
    },
    {
      "indent": 3,
      "text": "Phone: +81-3-5533-2111 Email: n-sakimura@nri.co.jp URI: http://nat.sakimura.org/",
      "ja": "電話：+ 81-3-5533-2111 Eメール：n-sakimura@nri.co.jp URI：http://nat.sakimura.org/"
    },
    {
      "indent": 3,
      "text": "John Bradley Ping Identity Casilla 177, Sucursal Talagante Talagante, RM Chile",
      "ja": "ジョン・ブラッドリーピング・アイデンティティボックス177、Talagante Talagante支店、RMチリ"
    },
    {
      "indent": 3,
      "text": "Phone: +44 20 8133 3718 Email: ve7jtb@ve7jtb.com URI: http://www.thread-safe.com/",
      "ja": "電話：+44 20 8133 3718 Eメール：ve7jtb@ve7jtb.com URI：http://www.thread-safe.com/"
    },
    {
      "indent": 3,
      "text": "Naveen Agarwal Google 1600 Amphitheatre Parkway Mountain View, CA 94043 United States",
      "ja": "Naveen AgarwalさんGoogleの1600アンフィシアターパークウェイマウンテンビュー、CA 94043米国"
    },
    {
      "indent": 3,
      "text": "Phone: +1 650-253-0000 Email: naa@google.com URI: http://google.com/",
      "ja": "電話：+1 650-253-0000電子メール：naa@google.com URI：http://google.com/"
    }
  ]
}