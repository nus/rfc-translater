{
  "title": {
    "text": "RFC 7641 - Observing Resources in the Constrained Application Protocol (CoAP)",
    "ja": "RFC 7641 - 制約アプリケーションプロトコル（CoAP）にリソースを観察します"
  },
  "number": 7641,
  "created_at": "2019-10-31 13:59:39.840095+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                         K. Hartke\nRequest for Comments: 7641                       Universitaet Bremen TZI\nCategory: Standards Track                                 September 2015\nISSN: 2070-1721",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Observing Resources in the Constrained Application Protocol (CoAP)",
      "ja": "制約アプリケーションプロトコル（CoAP）にリソースを観察します"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "The Constrained Application Protocol (CoAP) is a RESTful application protocol for constrained nodes and networks. The state of a resource on a CoAP server can change over time. This document specifies a simple protocol extension for CoAP that enables CoAP clients to \"observe\" resources, i.e., to retrieve a representation of a resource and keep this representation updated by the server over a period of time. The protocol follows a best-effort approach for sending new representations to clients and provides eventual consistency between the state observed by each client and the actual resource state at the server.",
      "ja": "制約アプリケーションプロトコル（CoAP）が制約ノードとネットワークのためのRESTfulアプリケーションプロトコルです。 CoAPサーバー上のリソースの状態は、時間の経過とともに変化することができます。この文書では、リソースの表現を取得し、一定期間にわたってサーバーによって更新この表現を維持するために、すなわち、リソースを「観察」するCoAPクライアントを可能にCoAPするための単純なプロトコル拡張を指定します。プロトコルは、クライアントに新しい表現を送信するためのベストエフォート型のアプローチに従い、各クライアントとサーバの実際のリソース状態で観測された状態の間で最終的な一貫性を提供します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 5741のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7641.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7641で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2015 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2015 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .  4\n  1.1.  Background  . . . . . . . . . . . . . . . . . . . . . . .  4\n  1.2.  Protocol Overview . . . . . . . . . . . . . . . . . . . .  4\n  1.3.  Consistency Model . . . . . . . . . . . . . . . . . . . .  6\n  1.4.  Observable Resources  . . . . . . . . . . . . . . . . . .  7\n  1.5.  Requirements Notation . . . . . . . . . . . . . . . . . .  8\n2.  The Observe Option  . . . . . . . . . . . . . . . . . . . . .  9\n3.  Client-Side Requirements  . . . . . . . . . . . . . . . . . . 10\n  3.1.  Request . . . . . . . . . . . . . . . . . . . . . . . . . 10\n  3.2.  Notifications . . . . . . . . . . . . . . . . . . . . . . 10\n  3.3.  Caching . . . . . . . . . . . . . . . . . . . . . . . . . 11\n  3.4.  Reordering  . . . . . . . . . . . . . . . . . . . . . . . 12\n  3.5.  Transmission  . . . . . . . . . . . . . . . . . . . . . . 13\n  3.6.  Cancellation  . . . . . . . . . . . . . . . . . . . . . . 13\n4.  Server-Side Requirements  . . . . . . . . . . . . . . . . . . 14\n  4.1.  Request . . . . . . . . . . . . . . . . . . . . . . . . . 14\n  4.2.  Notifications . . . . . . . . . . . . . . . . . . . . . . 14\n  4.3.  Caching . . . . . . . . . . . . . . . . . . . . . . . . . 15\n  4.4.  Reordering  . . . . . . . . . . . . . . . . . . . . . . . 16\n  4.5.  Transmission  . . . . . . . . . . . . . . . . . . . . . . 17\n5.  Intermediaries  . . . . . . . . . . . . . . . . . . . . . . . 20\n6.  Web Linking . . . . . . . . . . . . . . . . . . . . . . . . . 20\n7.  Security Considerations . . . . . . . . . . . . . . . . . . . 21\n8.  IANA Considerations . . . . . . . . . . . . . . . . . . . . . 22\n9.  References  . . . . . . . . . . . . . . . . . . . . . . . . . 22\n  9.1.  Normative References  . . . . . . . . . . . . . . . . . . 22\n  9.2.  Informative References  . . . . . . . . . . . . . . . . . 22\nAppendix A.  Examples . . . . . . . . . . . . . . . . . . . . . . 24\n  A.1.  Client/Server Examples  . . . . . . . . . . . . . . . . . 24\n  A.2.  Proxy Examples  . . . . . . . . . . . . . . . . . . . . . 28\nAcknowledgements  . . . . . . . . . . . . . . . . . . . . . . . . 30\nAuthor's Address  . . . . . . . . . . . . . . . . . . . . . . . . 30",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 0,
      "text": "1.1. Background",
      "section_title": true,
      "ja": "1.1。バックグラウンド"
    },
    {
      "indent": 3,
      "text": "The Constrained Application Protocol (CoAP) [RFC7252] is intended to provide RESTful services [REST] not unlike HTTP [RFC7230] while reducing the complexity of implementation as well as the size of packets exchanged in order to make these services useful in a highly constrained network of themselves highly constrained nodes [RFC7228].",
      "ja": "制約アプリケーションプロトコル（CoAP）[RFC7252]はRESTfulなサービスを提供することを目的とする[REST]ではないとは異なり、HTTP [RFC7230]の実装の複雑さを低減するだけでなく、パケットのサイズは非常に制約でこれらのサービスを便利にするために交換しながら自身のネットワーク高度に制約ノード[RFC7228]。"
    },
    {
      "indent": 3,
      "text": "The model of REST is that of a client exchanging representations of resources with a server, where a representation captures the current or intended state of a resource. The server is the authority for representations of the resources in its namespace. A client interested in the state of a resource initiates a request to the server; the server then returns a response with a representation of the resource that is current at the time of the request.",
      "ja": "RESTのモデルは、表現は、リソースの現在のまたは意図の状態をキャプチャし、サーバーとリソースの表現を交換するクライアントのことです。サーバーは、その名前空間内のリソースの表現のための権威です。リソースの状態に興味を持ってクライアントがサーバに要求を開始します。サーバは、要求時の電流であるリソースの表現で応答を返します。"
    },
    {
      "indent": 3,
      "text": "This model does not work well when a client is interested in having a current representation of a resource over a period of time. Existing approaches from HTTP, such as repeated polling or HTTP long polling [RFC6202], generate significant complexity and/or overhead and thus are less applicable in a constrained environment.",
      "ja": "クライアントは、一定期間にわたってリソースの現在の表現を持つことに興味を持っているときに、このモデルはうまく動作しません。このような繰り返しポーリングまたはHTTP長いポーリング[RFC6202]としてHTTPから既存のアプローチは、および/またはオーバーヘッド、したがってかなりの複雑を生成制約環境ではあまり適用可能です。"
    },
    {
      "indent": 3,
      "text": "The protocol specified in this document extends the CoAP core protocol with a mechanism for a CoAP client to \"observe\" a resource on a CoAP server: the client retrieves a representation of the resource and requests this representation be updated by the server as long as the client is interested in the resource.",
      "ja": "この表現は限りサーバーによって更新されたクライアントは、リソースの表現を取得し、要求：この文書で指定されたプロトコルは、CoAPサーバー上のリソースを「観察」するCoAPクライアントのための機構を備えたCoAPコアプロトコルを拡張しますクライアントはリソースに興味があります。"
    },
    {
      "indent": 3,
      "text": "The protocol keeps the architectural properties of REST. It enables high scalability and efficiency through the support of caches and proxies. There is no intention, though, to solve the full set of problems that the existing HTTP solutions solve or to replace publish/subscribe networks that solve a much more general problem [RFC5989].",
      "ja": "プロトコルは、RESTのアーキテクチャの性質を保持します。これは、キャッシュとプロキシのサポートを通じて、高い拡張性と効率性を可能にします。何の意図は、既存のHTTPのソリューションが解決する問題の完全なセットを解決するか、より多くの一般的な問題[RFC5989]を解決するためのネットワークをパブリッシュ/サブスクライブ・交換するために、しかし、ありません。"
    },
    {
      "indent": 0,
      "text": "1.2. Protocol Overview",
      "section_title": true,
      "ja": "1.2。プロトコルの概要"
    },
    {
      "indent": 3,
      "text": "The protocol is based on the well-known observer design pattern [GOF]. In this design pattern, components called \"observers\" register at a specific, known provider called the \"subject\" that they are interested in being notified whenever the subject undergoes a change in state. The subject is responsible for administering its list of registered observers. If multiple subjects are of interest to an observer, the observer must register separately for all of them.",
      "ja": "プロトコルは、周知のオブザーバデザインパターン[GOF]に基づいています。このデザインパターンにおいては、「観察者」と呼ばれるコンポーネントは、対象が状態の変化を受けるたびに通知されることに興味があることを「被験体」と呼ばれる特定の、既知のプロバイダに登録します。対象は、登録されたオブザーバーのリストを管理する責任があります。複数の被験者が観察者に関心がある場合、観察者はそれらのすべてに対して個別に登録する必要があります。"
    },
    {
      "indent": 23,
      "text": "Observer             Subject\n   |                    |\n   |    Registration    |\n   +------------------->|\n   |                    |\n   |    Notification    |\n   |<-------------------+\n   |                    |\n   |    Notification    |\n   |<-------------------+\n   |                    |\n   |    Notification    |\n   |<-------------------+\n   |                    |",
      "raw": true
    },
    {
      "indent": 19,
      "text": "Figure 1: The Observer Design Pattern",
      "ja": "図1：オブザーバーデザインパターン"
    },
    {
      "indent": 3,
      "text": "The observer design pattern is realized in CoAP as follows:",
      "ja": "次のようにオブザーバーデザインパターンは、CoAPで実現されています。"
    },
    {
      "indent": 3,
      "text": "Subject: In the context of CoAP, the subject is a resource in the namespace of a CoAP server. The state of the resource can change over time, ranging from infrequent updates to continuous state transformations.",
      "ja": "件名：CoAPの文脈において、対象はCoAPサーバーの名前空間内のリソースがあります。リソースの状態は、まれな更新から連続状態変換に至るまで、経時的に変化させることができます。"
    },
    {
      "indent": 3,
      "text": "Observer: An observer is a CoAP client that is interested in having a current representation of the resource at any given time.",
      "ja": "オブザーバー：観察者が任意の時点でのリソースの現在の表現を持つことに興味を持っているCoAPクライアントです。"
    },
    {
      "indent": 3,
      "text": "Registration: A client registers its interest in a resource by initiating an extended GET request to the server. In addition to returning a representation of the target resource, this request causes the server to add the client to the list of observers of the resource.",
      "ja": "登録：クライアントがサーバーに拡張されたGETリクエストを開始することによって、リソースでその関心を登録します。ターゲット・リソースの表現を返すことに加えて、この要求は、リソースのオブザーバーのリストにクライアントを追加するには、サーバーが発生します。"
    },
    {
      "indent": 3,
      "text": "Notification: Whenever the state of a resource changes, the server notifies each client in the list of observers of the resource. Each notification is an additional CoAP response sent by the server in reply to the single extended GET request and includes a complete, updated representation of the new resource state.",
      "ja": "通知：リソースの状態が変化したが、サーバはリソースのオブザーバーのリスト内の各クライアントに通知するたびに。各通知は、単一の拡張GETリクエストに応答してサーバから送信された追加のCoAP応答で、新しいリソースの状態の完全な、更新された表現を含みます。"
    },
    {
      "indent": 3,
      "text": "Figure 2 below shows an example of a CoAP client registering its interest in a resource and receiving three notifications: the first with the current state upon registration, and then two upon changes to the resource state. Both the registration request and the notifications are identified as such by the presence of the Observe Option defined in this document. In notifications, the Observe Option additionally provides a sequence number for reordering detection. All notifications carry the token specified by the client, so the client can easily correlate them to the request.",
      "ja": "登録時の現在の状態と第一、及びリソースの状態に変更する際、2つ：図2は、以下CoAPクライアントがリソースにその関心を登録三の通知を受信する例を示しています。登録要求および通知の両方が、この文書で定義された観察オプションの存在によってそのように識別されます。通知では、観察オプションはさらに、検出を並べ替えるためのシーケンス番号を提供します。すべての通知は、クライアントによって指定されたトークンを運ぶので、クライアントは、簡単に要求にそれらを関連付けることができます。"
    },
    {
      "indent": 23,
      "text": "Client                Server\n   |                    |\n   |  GET /temperature  |\n   |    Token: 0x4a     |   Registration\n   |  Observe: 0        |\n   +------------------->|\n   |                    |\n   |    2.05 Content    |\n   |    Token: 0x4a     |   Notification of\n   |  Observe: 12       |   the current state\n   |  Payload: 22.9 Cel |\n   |<-------------------+\n   |                    |\n   |    2.05 Content    |\n   |    Token: 0x4a     |   Notification upon\n   |  Observe: 44       |   a state change\n   |  Payload: 22.8 Cel |\n   |<-------------------+\n   |                    |\n   |    2.05 Content    |\n   |    Token: 0x4a     |   Notification upon\n   |  Observe: 60       |   a state change\n   |  Payload: 23.1 Cel |\n   |<-------------------+\n   |                    |",
      "raw": true
    },
    {
      "indent": 18,
      "text": "Figure 2: Observing a Resource in CoAP",
      "ja": "図2：CoAPでのリソースを観察"
    },
    {
      "indent": 3,
      "text": "Note: In this document, \"Cel\" stands for \"degrees Celsius\".",
      "ja": "注：この文書では、「セル画」を「摂氏温度」の略です。"
    },
    {
      "indent": 3,
      "text": "A client remains on the list of observers as long as the server can determine the client's continued interest in the resource. The server may send a notification in a confirmable CoAP message to request an acknowledgement from the client. When the client deregisters, rejects a notification, or the transmission of a notification times out after several transmission attempts, the client is considered no longer interested in the resource and is removed by the server from the list of observers.",
      "ja": "クライアントがいる限り、サーバーがリソースで、クライアントの継続的な関心を決定することができますようオブザーバーのリストに残っています。サーバは、クライアントからの確認を要求するために確認できるCoAPメッセージで通知を送信することができます。クライアントが登録を解除すると、通知、または複数の送信試行後にタイムアウト通知回の送信を拒否し、クライアントがリソースでもはや興味みなされず、オブザーバーのリストからサーバーによって除去されます。"
    },
    {
      "indent": 0,
      "text": "1.3. Consistency Model",
      "section_title": true,
      "ja": "1.3。一貫性モデル"
    },
    {
      "indent": 3,
      "text": "While a client is in the list of observers of a resource, the goal of the protocol is to keep the resource state observed by the client as closely in sync with the actual state at the server as possible.",
      "ja": "クライアントはリソースのオブザーバーのリストであるが、プロトコルの目標は、可能な限り、サーバーでの実際の状態と同期として密接にクライアントによって観測されたリソースの状態を維持することです。"
    },
    {
      "indent": 3,
      "text": "It cannot be avoided that the client and the server become out of sync at times: First, there is always some latency between the change of the resource state and the receipt of the notification. Second,",
      "ja": "クライアントとサーバーが常時同期しなくなることを避けることができない。まず、リソースの状態の変更と通知の受領の間にいくつかの待ち時間が常にあります。第二に、"
    },
    {
      "indent": 3,
      "text": "CoAP messages with notifications can get lost, which will cause the client to assume an old state until it receives a new notification. And third, the server may erroneously come to the conclusion that the client is no longer interested in the resource, which will cause the server to stop sending notifications and the client to assume an old state until it eventually registers its interest again.",
      "ja": "通知とCoAPメッセージは、それが新しい通知を受信するまで、クライアントが古い状態を仮定する原因となる、迷子になることができます。そして第三に、サーバーが誤って、それが最終的に再び関心を登録するまで、通知の送信を停止するには、サーバーとクライアントが古い状態をとることになります、クライアントはもはや資源に興味があるという結論に来るかもしれません。"
    },
    {
      "indent": 3,
      "text": "The protocol addresses this issue as follows:",
      "ja": "次のようにプロトコルは、この問題に対処します。"
    },
    {
      "indent": 3,
      "text": "o It follows a best-effort approach for sending the current representation to the client after a state change: clients should see the new state after a state change as soon as possible, and they should see as many states as possible. This is limited by congestion control, however, so a client cannot rely on observing every single state that a resource might go through.",
      "ja": "クライアントはできるだけ早く状態の変更後に新しい状態が表示されるはずです、そして、彼らはできるだけ多くの状態を確認する必要があります。o状態変化の後にクライアントに現在の表現を送信するためのベストエフォート型のアプローチに従っています。これは、輻輳制御により制限され、しかし、そのクライアントは、リソースが通過可能性があることを一つ一つの状態を観察するに頼ることはできません。"
    },
    {
      "indent": 3,
      "text": "o It labels notifications with a maximum duration up to which it is acceptable for the observed state and the actual state to be out of sync. When the age of the notification received reaches this limit, the client cannot use the enclosed representation until it receives a new notification.",
      "ja": "Oそれは同期してあることが観察された状態と実際の状態に対して許容される最大期間で通知をラベル。受信した通知の年齢がこの制限に達すると、それは新しい通知を受信するまで、クライアントは、囲まれた表現を使用することはできません。"
    },
    {
      "indent": 3,
      "text": "o It is designed on the principle of eventual consistency: the protocol guarantees that if the resource does not undergo a new change in state, eventually all registered observers will have a current representation of the latest resource state.",
      "ja": "Oそれは結果整合性の原則に基づいて設計されています。このプロトコルは、リソースが状態の新しい変化を受けていない場合、最終的には全ての登録オブザーバーは、最新のリソース状態の現在の表現を持っていることを保証します。"
    },
    {
      "indent": 0,
      "text": "1.4. Observable Resources",
      "section_title": true,
      "ja": "1.4。観測可能なリソース"
    },
    {
      "indent": 3,
      "text": "A CoAP server is the authority for determining under what conditions resources change their state and thus when observers are notified of new resource states. The protocol does not offer explicit means for setting up triggers or thresholds; it is up to the server to expose observable resources that change their state in a way that is useful in the application context.",
      "ja": "CoAPサーバーは、オブザーバーが新しいリソースの状態が通知されたときに条件のリソースは、このように自分の状態を変更し、何の下で決定するための権限です。プロトコルは、トリガーまたはしきい値を設定するための明示的な手段を提供していません。それは、アプリケーションのコンテキストで有用な方法で自分の状態を変更する観察可能なリソースを公開するサーバー次第です。"
    },
    {
      "indent": 3,
      "text": "For example, a CoAP server with an attached temperature sensor could expose one or more of the following resources:",
      "ja": "例えば、取り付けられた温度センサとCoAPサーバは、次のリソースの一つ以上を公開できます。"
    },
    {
      "indent": 3,
      "text": "o <coap://server/temperature>, which changes its state every few seconds to a current reading of the temperature sensor;",
      "ja": "O <coap：//サーバー/温度>、温度センサーの現在の読み取りに数秒ごとにその状態を変化させます。"
    },
    {
      "indent": 3,
      "text": "o <coap://server/temperature/felt>, which changes its state to \"COLD\" whenever the temperature reading drops below a certain pre-configured threshold and to \"WARM\" whenever the reading exceeds a second, slightly higher threshold;",
      "ja": "O <coap：//サーバ/温度/フェルト>、温度測定値が特定の事前設定された閾値を下回ったと「ウォーム」のたびに読み出しが第二、わずかに高い閾値を超えるたびに「COLD」にその状態を変化させます。"
    },
    {
      "indent": 3,
      "text": "o <coap://server/temperature/critical?above=42>, which changes its state based on the client-specified parameter value either every few seconds to the current temperature reading if the temperature exceeds the threshold or to \"OK\" when the reading drops below;",
      "ja": "O：クライアントが指定したパラメータ値のいずれかの温度がしきい値またはに「OK」を超えた場合に読み出し電流の温度に数秒ごとに基づいてその状態を変更する<coap = 42上記//サーバー/温度/クリティカルな？>、読書は、以下に低下します。"
    },
    {
      "indent": 3,
      "text": "o <coap://server/?query=select+avg(temperature)+from+Sensor.window: time(30sec)>, which accepts expressions of arbitrary complexity and changes its state accordingly.",
      "ja": "O <coap：//サーバ/クエリ= + AVG（温度）を選択+ + Sensor.windowから：時間（30秒）>、任意の複雑さの表現を受け入れ、それに応じてその状態を変化させます。"
    },
    {
      "indent": 3,
      "text": "Thus, by designing CoAP resources that change their state on certain conditions, it is possible to update the client only when these conditions occur instead of supplying it continuously with raw sensor data. By parameterizing resources, this is not limited to conditions defined by the server, but can be extended to arbitrarily complex queries specified by the client. The application designer therefore can choose exactly the right level of complexity for the application envisioned and devices involved and is not constrained to a \"one size fits all\" mechanism built into the protocol.",
      "ja": "したがって、特定の条件にその状態を変更CoAPリソースを設計することにより、これらの条件は、生センサデータを連続的に供給するのではなく、発生した場合にのみクライアントを更新することができます。リソースをパラメータ化することで、これは、サーバーで定義された条件に限定されるものではなく、クライアントによって指定された任意の複雑なクエリに拡張することができます。アプリケーション設計者は、したがって、アプリケーションの複雑さの正確に正しいレベルを選択することができ想定し、デバイスが関与しに拘束されていないプロトコルに組み込まれたメカニズム「ワンサイズすべてに適合」。"
    },
    {
      "indent": 0,
      "text": "1.5. Requirements Notation",
      "section_title": true,
      "ja": "1.5。要件表記"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [RFC2119].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はありますRFC 2119 [RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "2. The Observe Option",
      "section_title": true,
      "ja": "2.オプションを守って"
    },
    {
      "indent": 3,
      "text": "The Observe Option has the following properties. Its meaning depends on whether it is included in a GET request or in a response.",
      "ja": "観察オプションは、次のプロパティがあります。その意味は、それがGET要求または応答に含まれているかどうかに依存します。"
    },
    {
      "indent": 7,
      "text": "+-----+---+---+---+---+---------+--------+--------+---------+\n| No. | C | U | N | R | Name    | Format | Length | Default |\n+-----+---+---+---+---+---------+--------+--------+---------+\n|   6 |   | x | - |   | Observe | uint   | 0-3 B  | (none)  |\n+-----+---+---+---+---+---------+--------+--------+---------+",
      "raw": true
    },
    {
      "indent": 12,
      "text": "C=Critical, U=Unsafe, N=No-Cache-Key, R=Repeatable",
      "ja": "C =クリティカル、U =安全でない、N =ノーキャッシュキー、R =再現"
    },
    {
      "indent": 24,
      "text": "Table 1: The Observe Option",
      "ja": "表1：オプションを守って"
    },
    {
      "indent": 3,
      "text": "When included in a GET request, the Observe Option extends the GET method so it does not only retrieve a current representation of the target resource, but also requests the server to add or remove an entry in the list of observers of the resource depending on the option value. The list entry consists of the client endpoint and the token specified by the client in the request. Possible values are:",
      "ja": "GET要求に含まれる場合には、オプションを観察し、それが唯一のターゲットリソースの現在の表現を取得していないので、GETメソッドを拡張するだけでなく、追加またはに応じて、リソースのオブザーバーのリストのエントリを削除するには、サーバーを要求しますオプションの値。リストのエントリには、クライアントのエンドポイントと要求でクライアントによって指定されたトークンで構成されています。可能な値は以下のとおりです。"
    },
    {
      "indent": 6,
      "text": "0 (register) adds the entry to the list, if not present;",
      "ja": "存在しない場合は0（登録）、リストにエントリを追加します。"
    },
    {
      "indent": 6,
      "text": "1 (deregister) removes the entry from the list, if present.",
      "ja": "存在する場合に1（登録解除）、リストからエントリを削除します。"
    },
    {
      "indent": 3,
      "text": "The Observe Option is not critical for processing the request. If the server is unwilling or unable to add a new entry to the list of observers, then the request falls back to a normal GET request and the response does not include the Observe Option.",
      "ja": "観察オプションは、要求を処理するために重要ではありません。サーバは不本意またはオブザーバーのリストに新しいエントリを追加することができない場合、その要求は正常に戻っGETリクエストに低下し、応答が観察オプションが含まれていません。"
    },
    {
      "indent": 3,
      "text": "The Observe Option is not part of the Cache-Key: a cacheable response obtained with an Observe Option in the request can be used to satisfy a request without an Observe Option, and vice versa. When a stored response with an Observe Option is used to satisfy a normal GET request, the option MUST be removed before the response is returned.",
      "ja": "観察オプションは、キャッシュキーの一部ではない：要求における観察オプションを用いて得られたキャッシュ可能な応答その逆観察オプションなしで要求を満たすために使用することができます。観察オプションと格納された応答は通常のGET要求を満たすために使用されたときに応答が返される前に、オプションが除去されなければなりません。"
    },
    {
      "indent": 3,
      "text": "When included in a response, the Observe Option identifies the message as a notification. This implies that a matching entry exists in the list of observers and that the server will notify the client of changes to the resource state. The option value is a sequence number for reordering detection (see Sections 3.4 and 4.4).",
      "ja": "応答に含まれる場合、観察オプション通知としてメッセージを識別する。これは、一致するエントリがオブザーバーのリストに存在することを、サーバーがリソースの状態への変更をクライアントに通知することを意味します。オプションの値は、検出を並べ替えるためのシーケンス番号（セクション3.4および4.4を参照）です。"
    },
    {
      "indent": 3,
      "text": "The value of the Observe Option is encoded as an unsigned integer in network byte order using a variable number of bytes ('uint' option format); see Section 3.2 of RFC 7252 [RFC7252].",
      "ja": "観察オプションの値は、バイトの可変数（「UINT」オプションの形式）を使用して、ネットワークバイト順に符号のない整数として符号化されます。 RFC 7252 [RFC7252]の3.2節を参照してください。"
    },
    {
      "indent": 0,
      "text": "3. Client-Side Requirements",
      "section_title": true,
      "ja": "3.クライアント側の要件"
    },
    {
      "indent": 0,
      "text": "3.1. Request",
      "section_title": true,
      "ja": "3.1。要求"
    },
    {
      "indent": 3,
      "text": "A client registers its interest in a resource by issuing a GET request with an Observe Option set to 0 (register). If the server returns a 2.xx response that includes an Observe Option as well, the server has successfully added an entry with the client endpoint and request token to the list of observers of the target resource, and the client will be notified of changes to the resource state.",
      "ja": "クライアントは、0（レジスタ）に設定守っオプション付きGETリクエストを発行することにより、リソースに対する関心を登録します。サーバは、同様のオプションを守っ含ま2.xxの応答を返した場合、サーバーは、ターゲット・リソースのオブザーバーのリストにクライアントエンドポイントのエントリとリクエストトークンを正常に追加しました、そしてクライアントがへの変更が通知されますリソースの状態。"
    },
    {
      "indent": 3,
      "text": "Like a fresh response can be used to satisfy a request without contacting the server, the stream of updates resulting from one observation request can be used to satisfy another (observation or normal GET) request if the target resource is the same. A client MUST aggregate such requests and MUST NOT register more than once for the same target resource. The target resource is identified by all options in the request that are part of the Cache-Key. This includes, for example, the full request URI and the Accept Option.",
      "ja": "新鮮な応答がサーバに接触することなく、要求を満たすために使用することができるように、ターゲット・リソースが同じであれば、一回の観察要求に起因する更新のストリームが別の（観察又は通常GET）要求を満たすために使用することができます。クライアントは、このような要求を集約しなければならなくて、同じターゲット・リソースに対して複数回登録してはなりません。ターゲット・リソースは、キャッシュキーの一部であるリクエストのすべてのオプションで識別されます。これは、例えば、完全なリクエストURIと受け入れるオプションが含まれています。"
    },
    {
      "indent": 0,
      "text": "3.2. Notifications",
      "section_title": true,
      "ja": "3.2。通知"
    },
    {
      "indent": 3,
      "text": "Notifications are additional responses sent by the server in reply to the single extended GET request that created the registration. Each notification includes the token specified by the client in the request. The only difference between a notification and a normal response is the presence of the Observe Option.",
      "ja": "通知は、登録を作成した単一の拡張GETリクエストに応答してサーバから送信された追加的な応答です。各通知は、要求でクライアントによって指定されたトークンを含んでいます。通知と正常な応答との間の唯一の違いは観察オプションの存在です。"
    },
    {
      "indent": 3,
      "text": "Notifications typically have a 2.05 (Content) response code. They include an Observe Option with a sequence number for reordering detection (see Section 3.4) and a payload in the same Content-Format as the initial response. If the client included one or more ETag Options in the GET request (see Section 3.3), notifications can have a 2.03 (Valid) response code rather than a 2.05 (Content) response code. Such notifications include an Observe Option with a sequence number but no payload.",
      "ja": "通知は通常、2.05（コンテンツ）応答コードを持っています。彼らは、最初の応答と同じ内容・形式で検出（3.4節を参照）、ペイロードを並べ替えるためのシーケンス番号とオプションを確認しています。クライアントが（3.3節を参照）GETリクエスト内の1つまたは複数のETagのオプションが含まれていた場合、通知は2.03（有効）応答コードではなく、2.05（コンテンツ）応答コードを持つことができます。このような通知は、シーケンス番号が、無ペイロードを持つ守っオプションが含まれます。"
    },
    {
      "indent": 3,
      "text": "In the event that the resource changes in a way that would cause a normal GET request at that time to return a non-2.xx response (for example, when the resource is deleted), the server sends a notification with an appropriate response code (such as 4.04 Not Found) and removes the client's entry from the list of observers of the resource. Non-2.xx responses do not include an Observe Option.",
      "ja": "（リソースが削除されると、例えば）その時点で通常のGETリクエストを引き起こす方法で、リソースの変更が非2.xxの応答を返すようにした場合には、サーバが適切な応答コードで通知を送信します（例えば4.04は見つかりません）とリソースのオブザーバーのリストから、クライアントのエントリを削除します。非2.xxの応答が観察オプションが含まれていません。"
    },
    {
      "indent": 0,
      "text": "3.3. Caching",
      "section_title": true,
      "ja": "3.3。キャッシング"
    },
    {
      "indent": 3,
      "text": "As notifications are just additional responses to a GET request, notifications partake in caching as defined in Section 5.6 of RFC 7252 [RFC7252]. Both the freshness model and the validation model are supported.",
      "ja": "通知はGETリクエストにだけ追加の応答であるとしてRFC 7252 [RFC7252]のセクション5.6で定義され、通知がキャッシュに参加します。鮮度モデルと検証モデルの両方がサポートされています。"
    },
    {
      "indent": 0,
      "text": "3.3.1. Freshness",
      "section_title": true,
      "ja": "3.3.1。鮮度"
    },
    {
      "indent": 3,
      "text": "A client MAY store a notification like a response in its cache and use a stored notification that is fresh without contacting the server. Like a response, a notification is considered fresh while its age is not greater than the value indicated by the Max-Age Option (and no newer notification/response has been received).",
      "ja": "クライアントは、キャッシュ内の応答のような通知を保管し、サーバーに接触することなく、新鮮で保存された通知を使用するかもしれません。その年齢が最大年齢オプションによって示される値より大きくない場合（NOの新しい通知/応答が受信されていない）しながら反応と同様に、通知が新鮮であると考えられます。"
    },
    {
      "indent": 3,
      "text": "The server will do its best to keep the resource state observed by the client as closely in sync with the actual state as possible. However, a client cannot rely on observing every single state that a resource might go through. For example, if the network is congested or the state changes more frequently than the network can handle, the server can skip notifications for any number of intermediate states.",
      "ja": "サーバーは、可能な限り実際の状態と同期として密接にクライアントによって観測されたリソースの状態を維持するために最善を尽くします。ただし、クライアントはリソースが通過する可能性があるすべての単一の状態を観察するに頼ることはできません。ネットワークが輻輳しているかの状態がより頻繁にネットワークが処理できるよりも変化した場合、サーバーは、中間状態の任意の数の通知を省略することができます。"
    },
    {
      "indent": 3,
      "text": "The server uses the Max-Age Option to indicate an age up to which it is acceptable that the observed state and the actual state are inconsistent. If the age of the latest notification becomes greater than its indicated Max-Age, then the client MUST NOT assume that the enclosed representation reflects the actual resource state.",
      "ja": "サーバーは、年齢を示すために、マックス・年齢・オプションを使用することが観察状態と実際の状態が矛盾していることを許容されています。最新の通知の年齢が示されたマックス・年齢より大きくなった場合、クライアントは囲まれた表現は、実際のリソースの状態を反映していると仮定してはいけません。"
    },
    {
      "indent": 3,
      "text": "To make sure it has a current representation and/or to re-register its interest in a resource, a client MAY issue a new GET request with the same token as the original at any time. All options MUST be identical to those in the original request except for the set of ETag Options. It is RECOMMENDED that the client does not issue the request while it still has a fresh notification/response for the resource in its cache. Additionally, the client SHOULD at least wait for a random amount of time between 5 and 15 seconds after Max-Age expired to reduce collisions with other clients.",
      "ja": "それは現在の表現を持っていることを確認するために、および/またはリソースに対する持分を再登録するために、クライアントは、いつでもオリジナルと同じトークンを使用して、新たなGETリクエストを発行することができます。すべてのオプションはETagのオプションのセットを除き、元の要求のものと同一でなければなりません。まだそのキャッシュ内のリソースのための新鮮な通知/応答を持っていながら、クライアントが要求を発行しないことが推奨されます。マックス・年齢は他のクライアントとの衝突を減らすために有効期限が切れた後さらに、クライアントは、少なくとも5秒から15秒の間でランダムな時間を待つべき。"
    },
    {
      "indent": 0,
      "text": "3.3.2. Validation",
      "section_title": true,
      "ja": "3.3.2。バリデーション"
    },
    {
      "indent": 3,
      "text": "When a client has one or more notifications stored in its cache for a resource, it can use the ETag Option in the GET request to give the server an opportunity to select a stored notification to be used.",
      "ja": "クライアントがリソースにそのキャッシュに格納された1つの以上の通知を持っている場合は、サーバーに使用する保存された通知を選択する機会を与えるためにGET要求でのETagオプションを使用することができます。"
    },
    {
      "indent": 3,
      "text": "The client MAY include an ETag Option for each stored response that is applicable in the GET request. Whenever the observed resource changes to a representation identified by one of the ETag Options, the server can select a stored response by sending a 2.03 (Valid) notification with an appropriate ETag Option instead of a 2.05 (Content) notification.",
      "ja": "クライアントは、GETリクエストに適用可能である記憶された各応答のためのETagオプションを含むかもしれません。観察されたリソースのETagオプションのいずれかによって識別表現に変更するたびに、サーバは、代わり2.05（コンテンツ）通知の適切なETagをオプションで2.03（有効）通知を送信して記憶された応答を選択することができます。"
    },
    {
      "indent": 3,
      "text": "A client implementation needs to keep all candidate responses in its cache until it is no longer interested in the target resource or it re-registers with a new set of entity tags.",
      "ja": "それはもはやターゲットリソースに興味を持っているか、それはエンティティタグの新しいセットに再登録されるまで、クライアントの実装は、そのキャッシュ内のすべての候補応答を維持する必要はありません。"
    },
    {
      "indent": 0,
      "text": "3.4. Reordering",
      "section_title": true,
      "ja": "3.4。並べ替え"
    },
    {
      "indent": 3,
      "text": "Messages with notifications can arrive in a different order than they were sent. Since the goal is to keep the observed state as closely in sync with the actual state as possible, a client MUST consider the notification that was sent most recently as the freshest, regardless of the order of arrival.",
      "ja": "通知のメッセージは、送信された順序とは異なる順序で到着することができます。目標は、できるだけ実際の状態と同期してように観察状態を維持することですので、クライアントは関係なく、到着順の、新鮮として最近送られた通知を考慮しなければなりません。"
    },
    {
      "indent": 3,
      "text": "To provide an order among notifications for the client, the server sets the value of the Observe Option in each notification to the 24 least significant bits of a strictly increasing sequence number. An incoming notification was sent more recently than the freshest notification so far when one of the following conditions is met:",
      "ja": "クライアントの通知間の順序を提供するために、サーバは、厳密に増加するシーケンス番号の24個の最下位ビットにそれぞれ通知で観察オプションの値を設定します。次のいずれかの条件が満たされたときに着信通知は、これまでより最近では、新鮮な通知より送信されました："
    },
    {
      "indent": 22,
      "text": "(V1 < V2 and V2 - V1 < 2^23) or\n(V1 > V2 and V1 - V2 > 2^23) or\n(T2 > T1 + 128 seconds)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "where V1 is the value of the Observe Option in the freshest notification so far, V2 is the value of the Observe Option in the incoming notification, T1 is a client-local timestamp for the freshest notification so far, and T2 is a client-local timestamp for the incoming notification.",
      "ja": "V1は、これまで新鮮な通知で観察オプションの値であり、V2は、着信通知に観察オプションの値は、T1は、これまで新鮮な通知のクライアントローカルタイムスタンプであり、T2は、クライアントローカルであります着信通知のタイムスタンプ。"
    },
    {
      "indent": 3,
      "text": "Design Note: The first two conditions verify that V1 is less than V2 in 24-bit serial number arithmetic [RFC1982]. The third condition ensures that if the server is generating serial numbers based on a local clock, the time elapsed between the two incoming messages is not so large that the difference between V1 and V2 has become larger than the largest integer that it is meaningful to add to a 24-bit serial number; in other words, after 128 seconds have elapsed without any notification, a client does not need to check the sequence numbers to assume that an incoming notification was sent more recently than the freshest notification it has received so far.",
      "ja": "デザインノート：最初の2つの条件がV1は、24ビットのシリアル番号算術[RFC1982]でV2未満であることを確認してください。第三の条件は、サーバがローカル・クロックに基づいてシリアル番号を生成している場合、2つの入力メッセージ間の経過時間は、V1とV2との差が、追加する意味があることを最大の整数よりも大きくなったほど大きくないことを保証します24ビットのシリアル番号に、 128秒は任意の通知なしで経過した後に、他の言葉で、クライアントは、着信通知が最近になって、それがこれまでに受けた新鮮な通知より送信されたと仮定するシーケンス番号をチェックする必要はありません。"
    },
    {
      "indent": 6,
      "text": "The duration of 128 seconds was chosen as a nice round number greater than MAX_LATENCY (Section 4.8.2 of RFC 7252 [RFC7252]).",
      "ja": "128秒の持続時間はMAX_LATENCYより大きいいいラウンド数（RFC 7252のセクション4.8.2 [RFC7252]）として選択しました。"
    },
    {
      "indent": 0,
      "text": "3.5. Transmission",
      "section_title": true,
      "ja": "3.5。トランスミッション"
    },
    {
      "indent": 3,
      "text": "A notification can be confirmable or non-confirmable, i.e., it can be sent in a confirmable or a non-confirmable message. The message type used for a notification is independent of the type used for the request and of any previous notification.",
      "ja": "通知が確認可能または非確認可能とすることができる、すなわち、それが確認でき、または非確認できるメッセージで送信することができます。通知のために使用されるメッセージタイプが要求するため、任意の以前の通知に使用されるタイプとは無関係です。"
    },
    {
      "indent": 3,
      "text": "If a client does not recognize the token in a confirmable notification, it MUST NOT acknowledge the message and SHOULD reject it with a Reset message; otherwise, the client MUST acknowledge the message as usual. In the case of a non-confirmable notification, rejecting the message with a Reset message is OPTIONAL.",
      "ja": "クライアントが確認できる通知にトークンを認識しない場合は、メッセージを確認してはならないとリセットメッセージでそれを拒否すべきです。そうでない場合、クライアントは通常どおりメッセージを確認しなければなりません。非確認可能通知の場合には、リセットメッセージのメッセージを拒否することは任意です。"
    },
    {
      "indent": 3,
      "text": "An acknowledgement message signals to the server that the client is alive and interested in receiving further notifications; if the server does not receive an acknowledgement in reply to a confirmable notification, it will assume that the client is no longer interested and will eventually remove the associated entry from the list of observers (Section 4.5).",
      "ja": "クライアントが生きていると、さらに通知を受信することに関心があるサーバに確認メッセージ信号;サーバが確認できる通知への応答で確認応答を受信しない場合、クライアントはもはや興味を持っていないことを前提とし、最終的にはオブザーバー（4.5節）のリストから関連するエントリを削除します。"
    },
    {
      "indent": 0,
      "text": "3.6. Cancellation",
      "section_title": true,
      "ja": "3.6。取り消し"
    },
    {
      "indent": 3,
      "text": "A client that is no longer interested in receiving notifications for a resource can simply \"forget\" the observation. When the server then sends the next notification, the client will not recognize the token in the message and thus will return a Reset message. This causes the server to remove the associated entry from the list of observers. The entries in lists of observers are effectively \"garbage collected\" by the server.",
      "ja": "もはやリソースの通知を受信することに関心があるクライアントは、単に観察を「忘れる」ことができます。サーバは、次の通知を送信すると、クライアントは、メッセージにトークンを認識しませんので、リセットメッセージを返します。これは、オブザーバーのリストから関連するエントリを削除するには、サーバーが発生します。オブザーバーのリスト内のエントリは、効果的にサーバによって「ガベージコレクション」です。"
    },
    {
      "indent": 3,
      "text": "Implementation Note: Due to potential message loss, the Reset message may not reach the server. The client may therefore have to reject multiple notifications, each with one Reset message, until the server finally removes the associated entry from the list of observers and stops sending notifications.",
      "ja": "実装上の注意：潜在的なメッセージの損失のため、リセットメッセージがサーバーに到達しない場合があります。サーバーが最終的にオブザーバーのリストから関連するエントリを削除し、通知の送信を停止するまで、クライアントはそのため、複数の通知、1つのリセットメッセージとそれぞれを拒否する必要があります。"
    },
    {
      "indent": 3,
      "text": "In some circumstances, it may be desirable to cancel an observation and release the resources allocated by the server to it more eagerly. In this case, a client MAY explicitly deregister by issuing a GET request that has the Token field set to the token of the observation to be cancelled and includes an Observe Option with the value set to 1 (deregister). All other options MUST be identical to those in the registration request except for the set of ETag Options. When the server receives such a request, it will remove any matching entry from the list of observers and process the GET request as usual.",
      "ja": "いくつかの状況では、観察をキャンセルして、より熱心にそれにサーバによって割り当てられたリソースを解放することが望ましい場合があります。この場合、クライアントは、明示的にキャンセルされる観察のトークンに設定トークンフィールドを有しており、1（登録解除）に設定された値と観察オプションを含むGET要求を発行することにより、登録解除MAY。他のすべてのオプションは、ETagのオプションのセットを除き、登録要求のものと同一でなければなりません。サーバは、このような要求を受信すると、それはオブザーバーのリストから一致するエントリを削除し、いつものようにGETリクエストを処理します。"
    },
    {
      "indent": 0,
      "text": "4. Server-Side Requirements",
      "section_title": true,
      "ja": "4.サーバー側の要件"
    },
    {
      "indent": 0,
      "text": "4.1. Request",
      "section_title": true,
      "ja": "4.1。要求"
    },
    {
      "indent": 3,
      "text": "A GET request with an Observe Option set to 0 (register) requests the server not only to return a current representation of the target resource, but also to add the client to the list of observers of that resource. Upon success, the server returns a current representation of the resource and MUST keep this representation updated (as described in Section 1.3) as long as the client is on the list of observers.",
      "ja": "0（レジスタ）に設定守っオプション付きGETリクエストは、ターゲット・リソースの現在の表現を返すために、だけでなく、そのリソースのオブザーバーのリストにクライアントを追加するだけでなく、サーバに要求します。成功した場合、サーバーはリソースの現在の表現を返し、（セクション1.3で説明したように）限り、クライアントは、オブザーバーのリストにあるように更新この表現を維持しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The entry in the list of observers is keyed by the client endpoint and the token specified by the client in the request. If an entry with a matching endpoint/token pair is already present in the list (which, for example, happens when the client wishes to reinforce its interest in a resource), the server MUST NOT add a new entry but MUST replace or update the existing one.",
      "ja": "オブザーバーのリスト内のエントリは、クライアントのエンドポイントと要求でクライアントによって指定されたトークンをキーとしています。一致するエンドポイント/トークンのペアを持つエントリが（クライアントがリソースに対する関心を強化したい場合例えば、たまたま、）リスト内にすでに存在している場合は、サーバが新しいエントリを追加してはなりませんが、交換または更新しなければなりません。既存のもの。"
    },
    {
      "indent": 3,
      "text": "A server that is unable or unwilling to add a new entry to the list of observers of a resource MAY silently ignore the registration request and process the GET request as usual. The resulting response MUST NOT include an Observe Option, the absence of which signals to the client that it will not be notified of changes to the resource and, e.g., needs to poll the resource for its state instead.",
      "ja": "リソースのオブザーバーのリストに新しいエントリを追加することができないか、不本意であるサーバが静かに登録要求を無視して、いつものようにGETリクエストを処理することができます。得られた応答は、それが例えばリソースと、への変更が通知されないクライアントに信号不在その観察オプションを含んではいけません、代わりに状態のリソースをポーリングする必要があります。"
    },
    {
      "indent": 3,
      "text": "If the Observe Option in a GET request is set to 1 (deregister), then the server MUST remove any existing entry with a matching endpoint/ token pair from the list of observers and process the GET request as usual. The resulting response MUST NOT include an Observe Option.",
      "ja": "GETリクエストに観察オプションが（登録解除）1に設定されている場合、サーバは、観察者のリストから一致するエンドポイント/トークン対の既存のエントリを削除して、いつものようにGET要求を処理しなければなりません。結果の応答は観察オプションを含んではいけません。"
    },
    {
      "indent": 0,
      "text": "4.2. Notifications",
      "section_title": true,
      "ja": "4.2。通知"
    },
    {
      "indent": 3,
      "text": "A client is notified of changes to the resource state by additional responses sent by the server in reply to the GET request. Each such notification response (including the initial response) MUST echo the token specified by the client in the GET request. If there are multiple entries in the list of observers, the order in which the clients are notified is not defined; the server is free to use any method to determine the order.",
      "ja": "クライアントがGET要求に応答してサーバから送信された追加の応答によるリソースの状態への変更が通知されます。 （初期応答を含む）それぞれのそのような通知応答がGET要求でクライアントによって指定されたトークンをエコーし​​なければなりません。複数のエントリは、オブザーバーのリストにある場合は、クライアントに通知される順序は定義されていません。サーバーは、順序を決定するための任意の方法を使用して自由です。"
    },
    {
      "indent": 3,
      "text": "A notification SHOULD have a 2.05 (Content) or 2.03 (Valid) response code. However, in the event that the state of a resource changes in a way that would cause a normal GET request at that time to return a non-2.xx response (for example, when the resource is deleted), the server SHOULD notify the client by sending a notification with an appropriate response code (such as 4.04 Not Found) and subsequently MUST remove the associated entry from the list of observers of the resource.",
      "ja": "通知2.05（コンテンツ）または2.03（有効）レスポンスコードを有しているべきです。しかし、（リソースが削除されると、例えば）その時点で通常のGETリクエストを引き起こす方法で、リソースの状態が変化したが、非2.xxの応答を返すようにした場合には、サーバが通知する必要がある（SHOULD）適切な応答コードで通知を送信することにより、クライアントはリソースのオブザーバーのリストから関連するエントリを削除する必要があり、その後（のような4.04は見つかりません）と。"
    },
    {
      "indent": 3,
      "text": "The Content-Format specified in a 2.xx notification MUST be the same as the one used in the initial response to the GET request. If the server is unable to continue sending notifications in this format, it SHOULD send a notification with a 4.06 (Not Acceptable) response code and subsequently MUST remove the associated entry from the list of observers of the resource.",
      "ja": "2.xxの通知に指定されたコンテンツフォーマットは、GET要求への初期応答で使用したものと同じでなければなりません。サーバーは、この形式で通知を送り続けることができない場合は、4.06（許容できない）応答コードとの通知を送信すべきであり、その後、リソースのオブザーバーのリストから関連するエントリを削除する必要があります。"
    },
    {
      "indent": 3,
      "text": "A 2.xx notification MUST include an Observe Option with a sequence number as specified in Section 4.4 below; a non-2.xx notification MUST NOT include an Observe Option.",
      "ja": "2.xxの通知は、以下のセクション4.4で指定されたシーケンス番号とオプションを確認し含める必要があります。非2.xxの通知が守っオプションを含んではいけません。"
    },
    {
      "indent": 0,
      "text": "4.3. Caching",
      "section_title": true,
      "ja": "4.3。キャッシング"
    },
    {
      "indent": 3,
      "text": "As notifications are just additional responses sent by the server in reply to a GET request, they are subject to caching as defined in Section 5.6 of RFC 7252 [RFC7252].",
      "ja": "通知がGET要求に対する応答でサーバーから送信されただけで、追加の応答であるとしてRFC 7252 [RFC7252]のセクション5.6で定義されているように、彼らは、キャッシングの対象となります。"
    },
    {
      "indent": 0,
      "text": "4.3.1. Freshness",
      "section_title": true,
      "ja": "4.3.1。鮮度"
    },
    {
      "indent": 3,
      "text": "After returning the initial response, the server MUST keep the resource state that is observed by the client as closely in sync with the actual resource state as possible.",
      "ja": "初期応答を返す後、サーバーは、可能な限り実際のリソースの状態と同期してのように密接にクライアントによって観察されたリソースの状態を維持しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Since becoming out of sync at times cannot be avoided, the server MUST indicate for each representation an age up to which it is acceptable that the observed state and the actual state are inconsistent. This age is application dependent and MUST be specified in notifications using the Max-Age Option.",
      "ja": "避けることができない時期に同期していなってきているので、サーバはそれぞれの表現のために年齢を示しているしなければならないことが観察状態と実際の状態が矛盾していることを許容されています。この年齢では、アプリケーションに依存し、マックス・年齢・オプションを使用して、通知で指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "When the resource does not change and the client has a current representation, the server does not need to send a notification. However, if the client does not receive a notification, the client cannot tell if the observed state and the actual state are still in sync. Thus, when the age of the latest notification becomes greater than its indicated Max-Age, the client no longer has a usable representation of the resource state. The server MAY wish to prevent that by sending a new notification with the unchanged representation and a new Max-Age just before the Max-Age indicated earlier expires.",
      "ja": "リソースが変更されないと、クライアントが現在の表現を持っている場合は、サーバが通知を送信する必要はありません。クライアントが通知を受信しない場合に観察状態と実際の状態が同期して残っている場合は、クライアントが言うことができません。最新の通知の年齢が示されたマックス・年齢よりも大きくなったときにこのように、クライアントは、もはやリソース状態の使用可能な表現を持っていません。サーバーはそのまま表現し、前に示したマックス・エイジの有効期限が切れる直前に新しいマックス年齢で新しい通知を送信することによって、それを防ぐために望むことができます。"
    },
    {
      "indent": 0,
      "text": "4.3.2. Validation",
      "section_title": true,
      "ja": "4.3.2。バリデーション"
    },
    {
      "indent": 3,
      "text": "A client can include a set of entity tags in its request using the ETag Option. When an observed resource changes its state and the origin server is about to send a 2.05 (Content) notification, then whenever that notification has an entity tag in the set of entity tags specified by the client, the server MAY send a 2.03 (Valid) response with an appropriate ETag Option instead.",
      "ja": "クライアントは、ETagのオプションを使用して、その要求にエンティティタグのセットを含めることができます。観測されたリソースは、その状態を変更し、オリジンサーバが2.05（コンテンツ）通知を送信しようとするときは、その通知がクライアントによって指定されたエンティティタグのセットでのエンティティタグを持って、その後いつでも、サーバーは、2.03（有効な）を送るかもしれません代わりに、適切なETagのオプションと応答。"
    },
    {
      "indent": 0,
      "text": "4.4. Reordering",
      "section_title": true,
      "ja": "4.4。並べ替え"
    },
    {
      "indent": 3,
      "text": "Because messages can get reordered, the client needs a way to determine if a notification arrived later than a newer notification. For this purpose, the server MUST set the value of the Observe Option of each notification it sends to the 24 least significant bits of a strictly increasing sequence number. The sequence number MAY start at any value and MUST NOT increase so fast that it increases by more than 2^23 within less than 256 seconds.",
      "ja": "メッセージは並べ替えを取得することができるため、クライアントは、通知が後で新しい通知より到着したかどうかを判断する方法が必要です。この目的のために、サーバは、それが厳密に増加するシーケンス番号の24個の最下位ビットに送信する各通知の観察オプションの値を設定しなければなりません。シーケンス番号は、任意の値で開始することと非常に速く、それが未満256秒以内以上2 ^ 23で増加することを増やしてはなりません。"
    },
    {
      "indent": 3,
      "text": "The sequence number selected for a notification MUST be greater than that of any preceding notification sent to the same client with the same token for the same resource. The value of the Observe Option MUST be current at the time of transmission; if a notification is retransmitted, the server MUST update the value of the option to the sequence number that is current at that time before retransmission.",
      "ja": "通知のために選択されたシーケンス番号は、同一のリソースに対して同じトークンで同じクライアントに送信される先行するいずれかの通知のそれよりも大きくなければなりません。観察オプションの値は、送信時の電流でなければなりません。通知が再送信された場合、サーバは再送信する前に、その時点で、現在のシーケンス番号にオプションの値を更新する必要があります。"
    },
    {
      "indent": 3,
      "text": "Implementation Note: A simple implementation that satisfies the requirements is to obtain a timestamp from a local clock. The sequence number then is the timestamp in ticks, where 1 tick = (256 seconds)/(2^23) = 30.52 microseconds. It is not necessary that the clock reflects the current time/date.",
      "ja": "実装上の注意：要件を満たす単純な実装は、ローカルクロックからのタイムスタンプを取得することです。シーケンス番号は、その後、ダニのタイムスタンプであり、ここで、1ティック=（256秒）/（2 ^ 23）= 30.52マイクロ秒。クロックが現在の時刻/日付を反映している必要はありません。"
    },
    {
      "indent": 6,
      "text": "Another valid implementation is to store a 24-bit unsigned integer variable per resource and increment this variable each time the resource undergoes a change of state (provided that the resource changes its state less than 2^23 times in the first 256 seconds after every state change). This removes the need to update the value of the Observe Option on retransmission when the resource state did not change.",
      "ja": "別の有効な実装では、リソースがすべての状態の後の最初の256秒内のリソースの状態が変化すること未満の2 ^ 23回を設けた状態の変化を（受けリソース当たり24ビットの符号なし整数変数を格納し、この変数をインクリメントするたびにあります変化する）。これは、リソースの状態は変化しなかったときの再送に守ってオプションの値を更新する必要がなくなります。"
    },
    {
      "indent": 3,
      "text": "Design Note: The choice of a 24-bit option value and a time span of 256 seconds theoretically allows for a notification rate of up to 65536 notifications per second. Constrained nodes often have rather imprecise clocks, though, and inaccuracies of the client and server side may cancel out or add in effect. Therefore, the maximum notification rate is reduced to 32768 notifications per second. This is still well beyond the highest known design objective of around 1 kHz (most CoAP applications will be several orders of magnitude below that) but allows total clock inaccuracies of up to -50/+100%.",
      "ja": "デザインノート：24ビットのオプション値の選択と256秒の時間間隔は、理論的には最大毎秒65536の通知の通知・レートが可能になります。制約付きのノードは、多くの場合、しかし、かなり不正確なクロックを持っており、クライアント側とサーバー側の不正確さが相殺または効果に追加することができます。したがって、最大通知速度は、毎秒32768の通知に低減されます。これはよく1kHz前後の最高の知られている設計の目的を超えて（ほとんどのCoAPアプリケーションはその下数桁になります）はまだですが、最大で-50 / + 100％不正確総クロックすることができます。"
    },
    {
      "indent": 0,
      "text": "4.5. Transmission",
      "section_title": true,
      "ja": "4.5。トランスミッション"
    },
    {
      "indent": 3,
      "text": "A notification can be sent in a confirmable or a non-confirmable message. The message type used is typically application dependent and may be determined by the server for each notification individually.",
      "ja": "通知が確認可能または非確認できるメッセージで送信することができます。使用されるメッセージのタイプは、典型的には、アプリケーションに依存し、個々の通知のためにサーバーによって決定されてもよいです。"
    },
    {
      "indent": 3,
      "text": "For example, for resources that change in a somewhat predictable or regular fashion, notifications can be sent in non-confirmable messages; for resources that change infrequently, notifications can be sent in confirmable messages. The server can combine these two approaches depending on the frequency of state changes and the importance of individual notifications.",
      "ja": "例えば、多少予測可能または規則的に変化するリソースのために、通知が非確認できるメッセージで送信することができます。あまり変更されないリソースのために、通知が確認できるメッセージで送信することができます。サーバーは、状態変化の頻度と個々の通知の重要性に応じて、これらの二つのアプローチを組み合わせることができます。"
    },
    {
      "indent": 3,
      "text": "A server MAY choose to skip sending a notification if it knows that it will send another notification soon, for example, when the state of a resource is changing frequently. It also MAY choose to send more than one notification for the same resource state. However, above all, the server MUST ensure that a client in the list of observers of a resource eventually observes the latest state if the resource does not undergo a new change in state.",
      "ja": "サーバは、リソースの状態が頻繁に変更されたとき、それは、例えば、すぐに別の通知を送信することを知っている場合に通知を送信スキップすることを選択するかもしれません。また、同じリソースの状態のために複数の通知を送信するために選ぶかもしれません。しかし、すべての上に、サーバーリソースが状態の新しい変化を受けていない場合は、リソースのオブザーバーのリストで、クライアントは最終的に最新の状態を観察していることを確認しなければなりません。"
    },
    {
      "indent": 3,
      "text": "For example, when state changes occur in bursts, the server can skip some notifications, send the notifications in non-confirmable messages, and make sure that the client observes the latest state change by repeating the last notification in a confirmable message when the burst is over.",
      "ja": "状態変化がバースト的に発生した場合たとえば、サーバーは、一部の通知を省略することができます非確認可能なメッセージで通知を送信し、クライアントはバーストがあるときに確認できるメッセージの最後の通知を繰り返すことで、最新の状態変化を観察していることを確認してくださいオーバー。"
    },
    {
      "indent": 3,
      "text": "The client's acknowledgement of a confirmable notification signals that the client is interested in receiving further notifications. If a client rejects a confirmable or non-confirmable notification with a Reset message, or if the last attempt to retransmit a confirmable notification times out, then the client is considered no longer interested and the server MUST remove the associated entry from the list of observers.",
      "ja": "クライアントはさらに、通知を受信することに関心がある確認できる通知信号のクライアントの承認。クライアントは、リセットメッセージで確認でき、非確認できる通知を拒否し、または最後の試みが出て確認できる通知回数を再送信する場合、クライアントはもはや興味とみなされていないと、サーバーがオブザーバーのリストから関連するエントリを削除しなければならない場合。"
    },
    {
      "indent": 3,
      "text": "Implementation Note: To properly process a Reset message that rejects a non-confirmable notification, a server needs to remember the message IDs of the non-confirmable notifications it sends. This may be challenging for a server with constrained resources. However, since Reset messages are transmitted unreliably, the client must be prepared in case the Reset messages are not received by the server. Thus, a server can always pretend that a Reset message rejecting a non-confirmable notification was lost.",
      "ja": "実装上の注意：適切に非確認できる通知を拒否リセットメッセージを処理するには、サーバは送信非確認できる通知のメッセージIDを覚えておく必要があります。これは、制約のリソースを持つサーバーの挑戦かもしれません。リセットメッセージが不確実に送信されているので、クライアントは、リセットのメッセージがサーバによって受信されない場合に準備する必要があります。したがって、サーバーは常に非確認できる通知を拒否するリセットメッセージが失われたことをふりをすることができます。"
    },
    {
      "indent": 6,
      "text": "If a server does this, it could accelerate cancellation by sending the following notifications to that client in confirmable messages.",
      "ja": "サーバーがこれを行う場合は、それが確認できたメッセージにそのクライアントに次の通知を送信することにより、キャンセルを加速することができます。"
    },
    {
      "indent": 3,
      "text": "A server that transmits notifications mostly in non-confirmable messages MUST send a notification in a confirmable message instead of a non-confirmable message at least every 24 hours. This prevents a client that went away or is no longer interested from remaining in the list of observers indefinitely.",
      "ja": "大部分の非確認可能メッセージで通知を送信し、サーバではなく、非確認できるメッセージの確認可能メッセージは、少なくとも24時間ごとに通知を送信しなければなりません。これは離れていったか、もはや無期限オブザーバーのリストに残っているから、興味を持っていないクライアントを防ぎます。"
    },
    {
      "indent": 0,
      "text": "4.5.1. Congestion Control",
      "section_title": true,
      "ja": "4.5.1。輻輳制御"
    },
    {
      "indent": 3,
      "text": "Basic congestion control for CoAP is provided by the exponential back-off mechanism in Section 4.2 of RFC 7252 [RFC7252] and the limitations in Section 4.7 of RFC 7252 [RFC7252]. However, CoAP places the responsibility of congestion control for simple request/ response interactions only on the clients: rate-limiting request transmission implicitly controls the transmission of the responses. When a single request yields a potentially infinite number of notifications, additional responsibility needs to be placed on the server.",
      "ja": "CoAPための基本的な輻輳制御は、RFC 7252 [RFC7252]のセクション4.2に指数関数的なバックオフ機構によって提供され、制限RFC 7252 [RFC7252]のセクション4.7にされます。しかし、CoAPはクライアントだけに単純な要求/応答対話のための輻輳制御の責任を置く：律速リクエスト送信は、暗黙的に応答の送信を制御します。単一の要求は、通知の潜在的に無限の数を生成する場合、追加の責任は、サーバー上に配置する必要があります。"
    },
    {
      "indent": 3,
      "text": "In order not to cause congestion, servers MUST strictly limit the number of simultaneous outstanding notifications/responses that they transmit to a given client to NSTART (1 by default; see Section 4.7 of RFC 7252 [RFC7252]). An outstanding notification/response is either a confirmable message for which an acknowledgement has not yet been received and whose last retransmission attempt has not yet timed out or a non-confirmable message for which the waiting time that results from the following rate-limiting rules has not yet elapsed.",
      "ja": "渋滞を起こさないようにするために、サーバは、厳密に彼らがn始動に与えられたクライアントに送信し、同時に優れた通知/応答（; RFC 7252のセクション4.7 [RFC7252]を参照してくださいデフォルトでは1）の数を制限しなければなりません。抜群の通知/応答が確認応答がまだ受信されていないため確認できたメッセージとその最後の再試行がまだタイムアウトしていないか、以下のレート制限ルールから得られる待ち時間が持っている非確認できるメッセージのいずれかでありますまだ経過していません。"
    },
    {
      "indent": 3,
      "text": "The server SHOULD NOT send more than one non-confirmable notification per round-trip time (RTT) to a client on average. If the server cannot maintain an RTT estimate for a client, it SHOULD NOT send more than one non-confirmable notification every 3 seconds and SHOULD use an even less aggressive rate when possible (see also Section 3.1.2 of RFC 5405 [RFC5405]).",
      "ja": "サーバーは、平均して、クライアントにラウンドトリップ時間（RTT）ごとに複数の非確認できる通知を送るべきではありません。サーバがクライアントのRTT推定値を維持することができない場合は、それが3秒ごとに複数の非確認できる通知を送信すべきではなく、可能な場合でも、あまり積極的でレートを使用すべきである（RFCのセクション3.1.2も参照5405 [RFC5405]） 。"
    },
    {
      "indent": 3,
      "text": "Further congestion control optimizations and considerations are expected in the future with advanced CoAP congestion control mechanisms.",
      "ja": "また、輻輳制御の最適化と考察は、高度なCoAP輻輳制御メカニズムと、将来的に期待されています。"
    },
    {
      "indent": 0,
      "text": "4.5.2. Advanced Transmission",
      "section_title": true,
      "ja": "4.5.2。高度な伝送"
    },
    {
      "indent": 3,
      "text": "The state of an observed resource may change while the number of simultaneous outstanding notifications/responses to a client on the list of observers is greater than or equal to NSTART. In this case, the server cannot notify the client of the new resource state immediately but has to wait for an outstanding notification/response to complete first.",
      "ja": "オブザーバーのリスト上のクライアントへの同時優れ通知/応答の数がより多いまたはn始動に等しい一方で観測されたリソースの状態が変更されることがあります。この場合、サーバはすぐに新しいリソースの状態をクライアントに通知しますが、優れた通知/応答が最初に完了するのを待たなければならないことはできません。"
    },
    {
      "indent": 3,
      "text": "If there exists an outstanding notification/response that the server transmits to the client and that pertains to the changed resource, then it is desirable for the server to stop working towards getting the representation of the old resource state to the client and to start transmitting the current representation to the client instead, so the resource state observed by the client stays closer in sync with the actual state at the server.",
      "ja": "抜群の通知/応答が存在する場合は、サーバーがクライアントに送信し、それが変更されたリソースに関係するサーバーがクライアントに古いリソース状態の表現を取得に向けた作業を停止すると送信を開始するために、それは望ましいこと現在の代わりにクライアントに表現するので、クライアントによって観測されたリソースの状態は、サーバーでの実際の状態と同期して近づいたままになります。"
    },
    {
      "indent": 3,
      "text": "For this purpose, the server MAY optimize the transmission process by aborting the transmission of the old notification (but not before the current transmission attempt is completed) and starting a new transmission for the new notification (but with the retransmission timer and counter of the aborted transmission retained).",
      "ja": "この目的のために、サーバは古い通知（ただし、現在の送信試行が完了する前）の送信を中止し、中止されたの新しい通知（ただし付き再送タイマーとカウンタのための新たな送信を開始することにより、送信処理を最適化することができますトランスミッション保持）。"
    },
    {
      "indent": 3,
      "text": "In more detail, a server MAY supersede an outstanding transmission that pertains to an observation as follows:",
      "ja": "より詳細には、サーバーは、次のように観察に関係する優れた伝送に取って代わる可能性があります。"
    },
    {
      "indent": 3,
      "text": "1. Wait for the current (re)transmission attempt to be acknowledged, rejected, or to time out (confirmable transmission); or, wait for the waiting time to elapse or the transmission to be rejected (non-confirmable transmission).",
      "ja": "現在の（再）送信試行1.待ちは、認め拒否、またはタイムアウト（確認できる伝送）にします。または、経過を待っている時間または拒否される送信（非確認できる伝送）を待ちます。"
    },
    {
      "indent": 3,
      "text": "2. If the transmission is rejected or it was the last attempt to retransmit a notification, remove the associated entry from the list of observers of the observed resource.",
      "ja": "2.送信が拒否されるか、通知を再送する最後の試みであった、観測されたリソースのオブザーバーのリストから関連するエントリを削除した場合。"
    },
    {
      "indent": 3,
      "text": "3. If the entry is still in the list of observers, start to transmit a new notification with a representation of the current resource state. Should the resource have changed its state more than once in the meantime, the notifications for the intermediate states are silently skipped.",
      "ja": "3.エントリはオブザーバーのリストに残っている場合は、現在のリソース状態の表現で新しい通知を送信するために開始します。リソースは一度その間に比べて、その状態がより変更されている必要があり、中間状態の通知は黙ってスキップされます。"
    },
    {
      "indent": 3,
      "text": "4. The new notification is transmitted with a new Message ID and the following transmission parameters: if the previous (re)transmission attempt timed out, retain its transmission parameters, increment the retransmission counter, and double the timeout; otherwise, initialize the transmission parameters as usual (see Section 4.2 of RFC 7252 [RFC7252]).",
      "ja": "前の（再）送信の試行がタイムアウトした場合、その送信パラメータを保持し、再送カウンタをインクリメントし、タイムアウトを倍増; 4.新しい通知が新しいメッセージIDと、次の送信パラメータで送信されますそうでない場合、（RFC 7252のセクション4.2 [RFC7252]を参照）を通常どおり送信パラメータを初期化します。"
    },
    {
      "indent": 3,
      "text": "It is possible that the server later receives an acknowledgement for a confirmable notification that it superseded this way. Even though this does not signal consistency, it is valuable in that it signals the client's further interest in the resource. The server therefore should avoid inadvertently removing the associated entry from the list of observers.",
      "ja": "サーバーが後でそれがこの方法を取っ確認できる通知の確認応答を受け取ることも可能です。これは、一貫性を通知しませんが、それはリソースで、クライアントの更なる関心を知らせることで価値があります。サーバーは、したがって、不注意オブザーバーのリストから関連するエントリを削除することは避けてください。"
    },
    {
      "indent": 0,
      "text": "5. Intermediaries",
      "section_title": true,
      "ja": "5.仲介"
    },
    {
      "indent": 3,
      "text": "A client may be interested in a resource in the namespace of a server that is reached through a chain of one or more CoAP intermediaries. In this case, the client registers its interest with the first intermediary towards the server, acting as if it was communicating with the server itself, as specified in Section 3. It is the task of this intermediary to provide the client with a current representation of the target resource and to keep the representation updated upon changes to the resource state, as specified in Section 4.",
      "ja": "クライアントは、1つまたは複数のCoAP仲介のチェーンを介して到達されているサーバの名前空間内のリソースに興味があるかもしれません。この場合、クライアントは、現在の表現をクライアントに提供するために、この仲介者の役割である第3節で指定され、それは、サーバー自体と通信していたかのように動作し、サーバーへの最初の中間でその関心を登録しますターゲット・リソースおよび第4節で指定されているように、リソースの状態への変更時に更新表現を維持します。"
    },
    {
      "indent": 3,
      "text": "To perform this task, the intermediary SHOULD make use of the protocol specified in this document, taking the role of the client and registering its own interest in the target resource with the next hop towards the server. If the response returned by the next hop doesn't include an Observe Option, the intermediary MAY resort to polling the next hop or MAY itself return a response without an Observe Option.",
      "ja": "このタスクを実行するには、仲介者は、クライアントの役割を取って、サーバーへの次のホップを使用してターゲットリソースで独自の関心を登録し、この文書で指定されたプロトコルを利用するべきです。次のホップから返された応答が観察オプションが含まれていない場合は、仲介者は、次のホップのポーリングに頼るか、あるいは自身が守っオプションなしで応答を返す場合があります。"
    },
    {
      "indent": 3,
      "text": "The communication between each pair of hops is independent; each hop in the server role MUST determine individually how many notifications to send, of which message type, and so on. Each hop MUST generate its own values for the Observe Option in notifications and MUST set the value of the Max-Age Option according to the age of the local current representation.",
      "ja": "ホップの各対の間の通信には無関係です。サーバーの役割の各ホップはように、のメッセージタイプを送信し、ためにどのように多くの通知を個別に判断しなければなりません。各ホップは、通知で観察オプションのために、独自の値を生成しなければならないし、地元の現在の表現の年齢に応じて最大エイジ・オプションの値を設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If two or more clients have registered their interest in a resource with an intermediary, the intermediary MUST register itself only once with the next hop and fan out the notifications it receives to all registered clients. This relieves the next hop from sending the same notifications multiple times and thus enables scalability.",
      "ja": "二つ以上のクライアントが仲介して、リソースへの関心を登録した場合は、仲介者は、それが登録されているすべてのクライアントに受信通知アウトネクストホップとファンとの一度だけ自分自身を登録する必要があります。これは、同じ通知を複数回送信から次のホップを軽減ので、スケーラビリティを可能にします。"
    },
    {
      "indent": 3,
      "text": "An intermediary is not required to act on behalf of a client to observe a resource; an intermediary MAY observe a resource, for example, just to keep its own cache up to date.",
      "ja": "仲介は、リソースを観察するために、クライアントに代わって行動する必要はありません。仲介だけで最新の状態に独自のキャッシュを維持するために、例えば、リソースを観察することができます。"
    },
    {
      "indent": 3,
      "text": "See Appendix A.2 for examples.",
      "ja": "例については、付録A.2を参照してください。"
    },
    {
      "indent": 0,
      "text": "6. Web Linking",
      "section_title": true,
      "ja": "6.ウェブリンク"
    },
    {
      "indent": 3,
      "text": "A web link [RFC5988] to a resource accessible over CoAP (for example, in a link-format document [RFC6690]) MAY include the target attribute \"obs\".",
      "ja": "CoAPを介してアクセス可能なリソースへのウェブリンク[RFC5988]（例えば、リンク形式の文書[RFC6690]で）ターゲット属性「OBS」を含むかもしれません。"
    },
    {
      "indent": 3,
      "text": "The \"obs\" attribute, when present, is a hint indicating that the destination of a link is useful for observation and thus, for example, should have a suitable graphical representation in a user interface. Note that this is only a hint; it is not a promise that the Observe Option can actually be used to perform the observation. A client may need to resort to polling the resource if the Observe Option is not returned in the response to the GET request.",
      "ja": "「OBS」属性は、存在する場合、リンク先が観察のために有用であり、したがって、例えば、ユーザインタフェースにおける適切なグラフィカル表現を持つべきであることを示すヒントです。これは単なるヒントであることに注意してください。それは観察オプションが実際に観察を行うために使用することができます約束ではありません。クライアントは、観察オプションはGETリクエストに応答して返されていない場合、ポーリングにリソースを頼る必要があるかもしれません。"
    },
    {
      "indent": 3,
      "text": "A value MUST NOT be given for the \"obs\" attribute; any present value MUST be ignored by parsers. The \"obs\" attribute MUST NOT appear more than once in a given link-value; occurrences after the first MUST be ignored by parsers.",
      "ja": "値は、「OBS」属性のために与えられてはなりません。任意の現在価値は、パーサによって無視されなければなりません。 「OBS」属性は、一度与えられたリンク値でより多く見えてはいけません。最初の後の出現は、パーサによって無視されなければなりません。"
    },
    {
      "indent": 0,
      "text": "7. Security Considerations",
      "section_title": true,
      "ja": "7.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "The security considerations in Section 11 of [RFC7252], the CoAP specification, apply.",
      "ja": "[RFC7252]のセクション11のセキュリティの考慮事項は、CoAP仕様は、適用されます。"
    },
    {
      "indent": 3,
      "text": "Observing resources can dramatically increase the negative effects of amplification attacks. That is, not only can notifications messages be much larger than the request message, but the nature of the protocol can cause a significant number of notifications to be generated. Without client authentication, a server therefore MUST strictly limit the number of notifications that it sends between receiving acknowledgements that confirm the actual interest of the client in the data; i.e., any notifications sent in non-confirmable messages MUST be interspersed with confirmable messages. Note that an attacker may still spoof the acknowledgements if the confirmable messages are sufficiently predictable.",
      "ja": "観察のリソースが大幅に増幅攻撃の負の効果を高めることができます。それだけでなく、通知メッセージが要求メッセージよりもはるかに大きくなることが、ですが、プロトコルの性質は、通知のかなりの数が生成されることがあります。クライアント認証がなければ、サーバは、したがって、厳密には、データ内のクライアントの実際の関心を確認し、確認応答を受信するまで送信した通知の数を制限しなければなりません。すなわち、非確認できるメッセージで送信された通知が確認できるメッセージが点在しなければなりません。確認可能なメッセージは十分に予測可能である場合、攻撃者がまだ確認応答を偽装することがあります。"
    },
    {
      "indent": 3,
      "text": "The protocol follows a best-effort approach for keeping the state observed by a client and the actual resource state at a server in sync. This may have the client and the server become out of sync at times. Depending on the sensitivity of the observed resource, operating on an old state might be a security threat. The client therefore must be careful not to use a representation after its Max-Age expires, and the server must set the Max-Age Option to a sensible value.",
      "ja": "プロトコルは、同期サーバーで、クライアントと実際のリソース状態で観測された状態を維持するためのベストエフォート型のアプローチに従っています。これは、クライアントとの回で同期しなくなって、サーバを有することができます。観測されたリソースの感度に応じて、古い状態で動作することは、セキュリティ上の脅威であるかもしれません。クライアントは、したがって、その最大エイジの有効期限が切れた後の表現を使用しないように注意しなければならず、サーバが賢明な値にマックス・年齢・オプションを設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "As with any protocol that creates state, attackers may attempt to exhaust the resources that the server has available for maintaining the list of observers for each resource. Servers may want to apply access controls to this creation of state. As degraded behavior, the server can always fall back to processing the request as a normal GET request (without an Observe Option) if it is unwilling or unable to add a client to the list of observers of a resource, including if system resources are exhausted or nearing exhaustion.",
      "ja": "状態を作成し、任意のプロトコルと同様に、攻撃者は、サーバーが各リソースのオブザーバーのリストを維持するために利用できる持っているリソースを使い果たししようとすることができます。サーバはこの状態の創造にアクセス制御を適用することもできます。システムリソースが枯渇している場合を含め、リソースのオブザーバーのリストにクライアントを追加したくないか、できない場合、劣化の挙動として、サーバは常にバック（お守りオプションなし）通常のGET要求として要求を処理する落ちることができますまたは枯渇に近づいて。"
    },
    {
      "indent": 3,
      "text": "Intermediaries must be careful to ensure that notifications cannot be employed to create a loop. A simple way to break any loops is to employ caches for forwarding notifications in intermediaries.",
      "ja": "仲介は、通知がループを作成するために使用することができないことを保証するために注意しなければなりません。すべてのループを切断する簡単な方法は、仲介者に通知を転送するためのキャッシュを使用することです。"
    },
    {
      "indent": 3,
      "text": "Resources can be observed over CoAP that is secured by Datagram Transport Layer Security (DTLS) using any of the security modes described in Section 9 of RFC 7252. The use of DTLS is indicated by the \"coaps\" URI scheme. All notifications resulting from a GET request with an Observe Option MUST be returned within the same epoch of the same connection as the request.",
      "ja": "リソースがRFC 7252. DTLSの使用のセクション9に記載のセキュリティモードのいずれかを使用してデータグラムトランスポート層セキュリティ（DTLS）で固定されているCoAPにわたって観察することができますが、「coaps」URIスキームで示されます。守っオプション付きGETリクエストから生じたすべての通知は要求と同じ接続の同じエポック以内に戻らなければなりません。"
    },
    {
      "indent": 0,
      "text": "8. IANA Considerations",
      "section_title": true,
      "ja": "8. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "The following entry has been added to the CoAP Option Numbers registry:",
      "ja": "次のエントリは、CoAPオプション番号のレジストリに追加されました："
    },
    {
      "indent": 21,
      "text": "+--------+---------+-----------+\n| Number | Name    | Reference |\n+--------+---------+-----------+\n|      6 | Observe | RFC 7641  |\n+--------+---------+-----------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "9. References",
      "section_title": true,
      "ja": "9.参考文献"
    },
    {
      "indent": 0,
      "text": "9.1. Normative References",
      "section_title": true,
      "ja": "9.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<http://www.rfc-editor.org/info/ RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC5988] Nottingham, M., \"Web Linking\", RFC 5988, DOI 10.17487/RFC5988, October 2010, <http://www.rfc-editor.org/info/rfc5988>.",
      "ja": "[RFC5988]ノッティンガム、M.、 \"ウェブリンク\"、RFC 5988、DOI 10.17487 / RFC5988、2010年10月、<http://www.rfc-editor.org/info/rfc5988>。"
    },
    {
      "indent": 3,
      "text": "[RFC7252] Shelby, Z., Hartke, K., and C. Bormann, \"The Constrained Application Protocol (CoAP)\", RFC 7252, DOI 10.17487/RFC7252, June 2014, <http://www.rfc-editor.org/info/rfc7252>.",
      "ja": "[RFC7252]シェルビー、Z.、HARTKE、K.、およびC.ボルマン、 \"制約アプリケーションプロトコル（CoAP）\"、RFC 7252、DOI 10.17487 / RFC7252、2014年6月、<HTTP：//www.rfc-editor。組織/情報/ rfc7252>。"
    },
    {
      "indent": 0,
      "text": "9.2. Informative References",
      "section_title": true,
      "ja": "9.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[GOF] Gamma, E., Helm, R., Johnson, R., and J. Vlissides, \"Design Patterns: Elements of Reusable Object-Oriented Software\", Addison-Wesley Professional Computing Series, 1994.",
      "ja": "[GOF]ガンマ、E.、ヘルム、R.、ジョンソン、R.、およびJ. Vlissides、 \"デザインパターン：オブジェクト指向における再利用のための\"、アディソン・ウェズリープロフェッショナルコンピューティングシリーズ、1994。"
    },
    {
      "indent": 3,
      "text": "[REST] Fielding, R., \"Architectural Styles and the Design of Network-based Software Architectures\", Ph.D. Dissertation, University of California, Irvine, 2000, <http://www.ics.uci.edu/~fielding/pubs/dissertation/ fielding_dissertation.pdf>.",
      "ja": "[REST]フィールディング、R.、「建築スタイルとネットワークベースのソフトウェアアーキテクチャの設計」、博士論文、カリフォルニア大学アーバイン校、2000年、<http://www.ics.uci.edu/~fielding/pubs/dissertation/ fielding_dissertation.pdf>。"
    },
    {
      "indent": 3,
      "text": "[RFC1982] Elz, R. and R. Bush, \"Serial Number Arithmetic\", RFC 1982, DOI 10.17487/RFC1982, August 1996, <http://www.rfc-editor.org/info/rfc1982>.",
      "ja": "[RFC1982]エルツ、R.とR.ブッシュ大統領、 \"シリアル番号演算\"、RFC 1982、DOI 10.17487 / RFC1982、1996年8月、<http://www.rfc-editor.org/info/rfc1982>。"
    },
    {
      "indent": 3,
      "text": "[RFC5405] Eggert, L. and G. Fairhurst, \"Unicast UDP Usage Guidelines for Application Designers\", BCP 145, RFC 5405, DOI 10.17487/RFC5405, November 2008, <http://www.rfc-editor.org/info/rfc5405>.",
      "ja": "[RFC5405]エッゲルト、L.とG. Fairhurst、 \"アプリケーションデザイナーのためのユニキャストUDPの使用上の注意事項\"、BCP 145、RFC 5405、DOI 10.17487 / RFC5405、2008年11月、<http://www.rfc-editor.org/info / rfc5405>。"
    },
    {
      "indent": 3,
      "text": "[RFC5989] Roach, A., \"A SIP Event Package for Subscribing to Changes to an HTTP Resource\", RFC 5989, DOI 10.17487/RFC5989, October 2010, <http://www.rfc-editor.org/info/rfc5989>.",
      "ja": "[RFC5989]ローチ、A.、 \"HTTPリソースへの変更への登録のためのSIPイベントパッケージ\"、RFC 5989、DOI 10.17487 / RFC5989、2010年10月、<http://www.rfc-editor.org/info/rfc5989 >。"
    },
    {
      "indent": 3,
      "text": "[RFC6202] Loreto, S., Saint-Andre, P., Salsano, S., and G. Wilkins, \"Known Issues and Best Practices for the Use of Long Polling and Streaming in Bidirectional HTTP\", RFC 6202, DOI 10.17487/RFC6202, April 2011, <http://www.rfc-editor.org/info/rfc6202>.",
      "ja": "[RFC6202] \"双方向HTTPでの既知の問題とベストプラクティスロングポーリングの使用のためとストリーミング\" ロレート、S.、サン・アンドレ、P.、Salsano、S.、およびG.ウィルキンス、RFC 6202、DOI 10.17487 / RFC6202、2011年4月、<http://www.rfc-editor.org/info/rfc6202>。"
    },
    {
      "indent": 3,
      "text": "[RFC6690] Shelby, Z., \"Constrained RESTful Environments (CoRE) Link Format\", RFC 6690, DOI 10.17487/RFC6690, August 2012, <http://www.rfc-editor.org/info/rfc6690>.",
      "ja": "[RFC6690]シェルビー、Z.、 \"制約RESTfulな環境（コア）リンク・フォーマット\"、RFC 6690、DOI 10.17487 / RFC6690、2012年8月、<http://www.rfc-editor.org/info/rfc6690>。"
    },
    {
      "indent": 3,
      "text": "[RFC7228] Bormann, C., Ersue, M., and A. Keranen, \"Terminology for Constrained-Node Networks\", RFC 7228, DOI 10.17487/RFC7228, May 2014, <http://www.rfc-editor.org/info/rfc7228>.",
      "ja": "[RFC7228]ボルマン、C.、Ersue、M.、およびA. Keranen、 \"制約ノードのネットワークのための用語\"、RFC 7228、DOI 10.17487 / RFC7228、2014年5月、<http://www.rfc-editor.org /情報/ rfc7228>。"
    },
    {
      "indent": 3,
      "text": "[RFC7230] Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing\", RFC 7230, DOI 10.17487/RFC7230, June 2014, <http://www.rfc-editor.org/info/rfc7230>.",
      "ja": "[RFC7230]フィールディング、R.、エド。及びJ. Reschke、編、 \"ハイパーテキスト転送プロトコル（HTTP / 1.1）：メッセージの構文およびルーティング\"、RFC 7230、DOI 10.17487 / RFC7230、2014年6月、<http://www.rfc-editor.org/info/ rfc7230>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Examples",
      "ja": "付録A.例"
    },
    {
      "indent": 0,
      "text": "A.1. Client/Server Examples",
      "ja": "A.1。クライアント/サーバーの例"
    },
    {
      "indent": 4,
      "text": "     Observed   CLIENT  SERVER     Actual\n t   State         |      |         State\n     ____________  |      |  ____________\n 1                 |      |\n 2    unknown      |      |     18.5 Cel\n 3                 +----->|                  Header: GET 0x41011633\n 4                 | GET  |                   Token: 0x4a\n 5                 |      |                Uri-Path: temperature\n 6                 |      |                 Observe: 0 (register)\n 7                 |      |\n 8                 |      |\n 9   ____________  |<-----+                  Header: 2.05 0x61451633\n10                 | 2.05 |                   Token: 0x4a\n11    18.5 Cel     |      |                 Observe: 9\n12                 |      |                 Max-Age: 15\n13                 |      |                 Payload: \"18.5 Cel\"\n14                 |      |\n15                 |      |  ____________\n16   ____________  |<-----+                  Header: 2.05 0x51457b50\n17                 | 2.05 |     19.2 Cel      Token: 0x4a\n18    19.2 Cel     |      |                 Observe: 16\n29                 |      |                 Max-Age: 15\n20                 |      |                 Payload: \"19.2 Cel\"\n21                 |      |",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Figure 3: A Client Registers and Receives One Notification of the Current State and One of a New State upon a State Change",
      "ja": "図3：クライアントのレジスタとは状態変更時にワン現状の通知と新国家のひとつを受け取ります"
    },
    {
      "indent": 4,
      "text": "     Observed   CLIENT  SERVER     Actual\n t   State         |      |         State\n     ____________  |      |  ____________\n22                 |      |\n23    19.2 Cel     |      |     19.2 Cel\n24                 |      |  ____________\n25                 | X----+                  Header: 2.05 0x51457b51\n26                 | 2.05 |     19.7 Cel      Token: 0x4a\n27                 |      |                 Observe: 25\n28                 |      |                 Max-Age: 15\n29                 |      |                 Payload: \"19.7 Cel\"\n30                 |      |\n31   ____________  |      |\n32                 |      |\n33    19.2 Cel     |      |\n34    (stale)      |      |\n35                 |      |\n36                 |      |\n37                 |      |\n38                 +----->|                  Header: GET 0x41011634\n39                 | GET  |                   Token: 0xb2\n40                 |      |                Uri-Path: temperature\n41                 |      |                 Observe: 0 (register)\n42                 |      |\n43                 |      |\n44   ____________  |<-----+                  Header: 2.05 0x61451634\n45                 | 2.05 |                   Token: 0xb2\n46    19.7 Cel     |      |                 Observe: 44\n47                 |      |                 Max-Age: 15\n48                 |      |                    ETag: 0x78797a7a79\n49                 |      |                 Payload: \"19.7 Cel\"\n50                 |      |",
      "raw": true
    },
    {
      "indent": 11,
      "text": "Figure 4: The Client Re-registers after Max-Age Ends",
      "ja": "図4：最大エージング終了後のクライアントの再登録"
    },
    {
      "indent": 4,
      "text": "     Observed   CLIENT  SERVER     Actual\n t   State         |      |         State\n     ____________  |      |  ____________\n51                 |      |\n52    19.7 Cel     |      |     19.7 Cel\n53                 |      |\n54                 |      |  ____________\n55                 |    crash\n56                 |\n57                 |\n58                 |\n59   ____________  |\n60                 |\n61    19.7 Cel     |\n62    (stale)      |\n63                 |   reboot____________\n64                 |      |\n65                 |      |     20.0 Cel\n66                 |      |\n67                 +----->|                  Header: GET 0x41011635\n68                 | GET  |                   Token: 0xf9\n69                 |      |                Uri-Path: temperature\n70                 |      |                 Observe: 0 (register)\n71                 |      |                    ETag: 0x78797a7a79\n72                 |      |\n73                 |      |\n74   ____________  |<-----+                  Header: 2.05 0x61451635\n75                 | 2.05 |                   Token: 0xf9\n76    20.0 Cel     |      |                 Observe: 74\n77                 |      |                 Max-Age: 15\n78                 |      |                 Payload: \"20.0 Cel\"\n79                 |      |\n80                 |      |  ____________\n81   ____________  |<-----+                  Header: 2.03 0x5143aa0c\n82                 | 2.03 |     19.7 Cel      Token: 0xf9\n83    19.7 Cel     |      |                 Observe: 81\n84                 |      |                    ETag: 0x78797a7a79\n85                 |      |                 Max-Age: 15\n86                 |      |",
      "raw": true
    },
    {
      "indent": 8,
      "text": "Figure 5: The Client Re-registers and Gives the Server the\n          Opportunity to Select a Stored Response",
      "raw": true
    },
    {
      "indent": 3,
      "text": "      Observed   CLIENT  SERVER     Actual\n  t   State         |      |         State\n      ____________  |      |  ____________\n 87                 |      |\n 88    19.7 Cel     |      |     19.7 Cel\n 89                 |      |\n 90                 |      |  ____________\n 91   ____________  |<-----+                  Header: 2.05 0x4145aa0f\n 92                 | 2.05 |     19.3 Cel      Token: 0xf9\n 93    19.3 Cel     |      |                 Observe: 91\n 94                 |      |                 Max-Age: 15\n 95                 |      |                 Payload: \"19.3 Cel\"\n 96                 |      |\n 97                 |      |\n 98                 +- - ->|                  Header: 0x7000aa0f\n 99                 |      |\n100                 |      |\n101                 |      |\n102                 |      |  ____________\n103                 |      |\n104                 |      |     19.0 Cel\n105                 |      |\n106   ____________  |      |\n107                 |      |\n108    19.3 Cel     |      |\n109    (stale)      |      |\n110                 |      |",
      "raw": true
    },
    {
      "indent": 4,
      "text": "Figure 6: The Client Rejects a Notification and Thereby Cancels the Observation",
      "ja": "図6：クライアントが通知を拒否し、これにより観察を取り消し"
    },
    {
      "indent": 0,
      "text": "A.2. Proxy Examples",
      "ja": "A.2。プロキシの例"
    },
    {
      "indent": 3,
      "text": "CLIENT  PROXY  SERVER\n   |      |      |\n   |      +----->|     Header: GET 0x41015fb8\n   |      | GET  |      Token: 0x1a\n   |      |      |   Uri-Host: sensor.example\n   |      |      |   Uri-Path: status\n   |      |      |    Observe: 0 (register)\n   |      |      |\n   |      |<-----+     Header: 2.05 0x61455fb8\n   |      | 2.05 |      Token: 0x1a\n   |      |      |    Observe: 42\n   |      |      |    Max-Age: 60\n   |      |      |    Payload: \"ready\"\n   |      |      |\n   +----->|      |     Header: GET 0x41011633\n   | GET  |      |      Token: 0x9a\n   |      |      |  Proxy-Uri: coap://sensor.example/status\n   |      |      |\n   |<-----+      |     Header: 2.05 0x61451633\n   | 2.05 |      |      Token: 0x9a\n   |      |      |    Max-Age: 53\n   |      |      |    Payload: \"ready\"\n   |      |      |\n   |      |<-----+     Header: 2.05 0x514505fc0\n   |      | 2.05 |      Token: 0x1a\n   |      |      |    Observe: 135\n   |      |      |    Max-Age: 60\n   |      |      |    Payload: \"busy\"\n   |      |      |\n   +----->|      |     Header: GET 0x41011634\n   | GET  |      |      Token: 0x9b\n   |      |      |  Proxy-Uri: coap://sensor.example/status\n   |      |      |\n   |<-----+      |     Header: 2.05 0x61451634\n   | 2.05 |      |      Token: 0x9b\n   |      |      |    Max-Age: 49\n   |      |      |    Payload: \"busy\"\n   |      |      |",
      "raw": true
    },
    {
      "indent": 4,
      "text": "Figure 7: A Proxy Observes a Resource to Keep its Cache Up to Date",
      "ja": "図7：プロキシが最新のキャッシュを維持するためにリソースを観察"
    },
    {
      "indent": 3,
      "text": "CLIENT  PROXY  SERVER\n   |      |      |\n   +----->|      |     Header: GET 0x41011635\n   | GET  |      |      Token: 0x6a\n   |      |      |  Proxy-Uri: coap://sensor.example/status\n   |      |      |    Observe: 0 (register)\n   |      |      |\n   |<- - -+      |     Header: 0x60001635\n   |      |      |\n   |      +----->|     Header: GET 0x4101af90\n   |      | GET  |      Token: 0xaa\n   |      |      |   Uri-Host: sensor.example\n   |      |      |   Uri-Path: status\n   |      |      |    Observe: 0 (register)\n   |      |      |\n   |      |<-----+     Header: 2.05 0x6145af90\n   |      | 2.05 |      Token: 0xaa\n   |      |      |    Observe: 67\n   |      |      |    Max-Age: 60\n   |      |      |    Payload: \"ready\"\n   |      |      |\n   |<-----+      |     Header: 2.05 0x4145af94\n   | 2.05 |      |      Token: 0x6a\n   |      |      |    Observe: 17346\n   |      |      |    Max-Age: 60\n   |      |      |    Payload: \"ready\"\n   |      |      |\n   +- - ->|      |     Header: 0x6000af94\n   |      |      |\n   |      |<-----+     Header: 2.05 0x51455a20\n   |      | 2.05 |      Token: 0xaa\n   |      |      |    Observe: 157\n   |      |      |    Max-Age: 60\n   |      |      |    Payload: \"busy\"\n   |      |      |\n   |<-----+      |     Header: 2.05 0x5145af9b\n   | 2.05 |      |      Token: 0x6a\n   |      |      |    Observe: 17436\n   |      |      |    Max-Age: 60\n   |      |      |    Payload: \"busy\"\n   |      |      |",
      "raw": true
    },
    {
      "indent": 10,
      "text": "Figure 8: A Client Observes a Resource through a Proxy",
      "ja": "図8：クライアントがプロキシを通じてリソースを観察"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Carsten Bormann was an original author of this document and is acknowledged for significant contribution to this document.",
      "ja": "カルステンボルマンは、このドキュメントの原作者であり、このドキュメントへの重要な貢献を認められています。"
    },
    {
      "indent": 3,
      "text": "Thanks to Daniele Alessandrelli, Jari Arkko, Peter A. Bigot, Angelo P. Castellani, Gilbert Clark, Esko Dijk, Thomas Fossati, Brian Frank, Bert Greevenbosch, Jeroen Hoebeke, Cullen Jennings, Matthias Kovatsch, Barry Leiba, Salvatore Loreto, Charles Palmer, Akbar Rahman, Zach Shelby, and Floris Van den Abeele for helpful comments and discussions that have shaped the document.",
      "ja": "ダニエルAlessandrelliのおかげで、ヤリArkko、ピーター・A.ビゴ、アンジェロP.カステラーニ、ギルバート・クラーク、エスコダイク、トーマス・フォッサーティ、ブライアン・フランク、バートGreevenbosch、イェルーンHoebeke、カレン・ジェニングス、マティアスKovatsch、バリー・レイバ、サルヴァトーレ・ロレート、チャールズ・パーマー文書を形作ってきた有益なコメントや議論のために、アクバル・ラーマン、ザックシェルビー、およびフロリスヴァンデンAbeele。"
    },
    {
      "indent": 3,
      "text": "This work was supported in part by Klaus Tschira Foundation, Intel, Cisco, and Nokia.",
      "ja": "この作品は、クラウス・ツシラ財団、インテル、シスコ、およびNokiaによって部分的にサポートされていました。"
    },
    {
      "indent": 0,
      "text": "Author's Address",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Klaus Hartke Universitaet Bremen TZI Postfach 330440 Bremen D-28359 Germany",
      "ja": "クラウスHARTKE UniversitaetブレーメンTZI POSTFACH 330440 D-28359ブレーメンドイツ"
    },
    {
      "indent": 3,
      "text": "Phone: +49-421-218-63905 Email: hartke@tzi.org",
      "ja": "電話：+ 49-421-218-63905 Eメール：hartke@tzi.org"
    }
  ]
}