{
  "title": {
    "text": "RFC 7861 - Remote Procedure Call (RPC) Security Version 3",
    "ja": "RFC 7861 - リモートプロシージャコール（RPC）Securityバージョン3"
  },
  "number": 7861,
  "created_at": "2019-11-02 21:05:03.227259+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                        W. Adamson\nRequest for Comments: 7861                                        NetApp\nUpdates: 5403                                                N. Williams\nCategory: Standards Track                                   Cryptonector\nISSN: 2070-1721                                            November 2016",
      "raw": true
    },
    {
      "indent": 13,
      "text": "Remote Procedure Call (RPC) Security Version 3",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document specifies version 3 of the Remote Procedure Call (RPC) security protocol (RPCSEC_GSS). This protocol provides support for multi-principal authentication of client hosts and user principals to a server (constructed by generic composition), security label assertions for multi-level security and type enforcement, structured privilege assertions, and channel bindings. This document updates RFC 5403.",
      "ja": "この文書では、リモートプロシージャコール（RPC）セキュリティプロトコル（RPCSEC_GSS）のバージョン3を指定します。このプロトコルは、（一般的な合成によって構築された）サーバへのクライアントホストとユーザプリンシパルのマルチ主要認証のためにサポートを提供し、マルチレベルのセキュリティとタイプ施行、構造特権アサーション、およびチャネルバインディング用のセキュリティ・ラベル・アサーション。この文書は、RFC 5403に更新します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 7841のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7861.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7861で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2016 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2016 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction and Motivation .....................................2\n   1.1. Requirements Language ......................................3\n   1.2. Added Functionality ........................................4\n   1.3. XDR Code Extraction ........................................5\n2. The RPCSEC_GSSv3 Protocol .......................................6\n   2.1. Compatibility with RPCSEC_GSSv2 ............................6\n   2.2. Version Negotiation ........................................6\n   2.3. New Reply Verifier .........................................7\n   2.4. XDR Code Preliminaries .....................................8\n   2.5. RPCSEC_GSS_BIND_CHANNEL Operation .........................10\n   2.6. New auth_stat Values ......................................10\n   2.7. New Control Procedures ....................................10\n        2.7.1. New Control Procedure - RPCSEC_GSS_CREATE ..........12\n        2.7.2. New Control Procedure - RPCSEC_GSS_LIST ............20\n   2.8. Extensibility .............................................21\n3. Operational Recommendation for Deployment ......................21\n4. Security Considerations ........................................21\n5. IANA Considerations ............................................22\n   5.1. New RPC Authentication Status Numbers .....................22\n   5.2. Structured Privilege Name Definitions .....................23\n        5.2.1. Initial Registry ...................................24\n        5.2.2. Updating Registrations .............................24\n6. References .....................................................25\n   6.1. Normative References ......................................25\n   6.2. Informative References ....................................26\nAcknowledgments ...................................................26\nAuthors' Addresses ................................................26",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction and Motivation",
      "section_title": true,
      "ja": "1.はじめと動機"
    },
    {
      "indent": 3,
      "text": "The original Remote Procedure Call (RPC) security protocol (RPCSEC_GSS) [RFC2203] provided for authentication of RPC clients and servers to each other using the Generic Security Service Application Programming Interface (GSS-API) [RFC2743]. The second version of RPCSEC_GSS [RFC5403] added support for channel bindings [RFC5056].",
      "ja": "一般的なセキュリティサービスアプリケーションプログラミングインターフェイス（GSS-API）[RFC2743]を使用して相互にRPCクライアントとサーバの認証のために提供された元リモートプロシージャコール（RPC）セキュリティプロトコル（RPCSEC_GSS）[RFC2203]。 RPCSEC_GSS [RFC5403]の第2のバージョンは、チャネルバインディング[RFC5056]のサポートを追加しました。"
    },
    {
      "indent": 3,
      "text": "Existing GSS-API mechanisms are insufficient for communicating certain authorization and authentication information to a server. The GSS-API and its mechanisms certainly could be extended to address this shortcoming. However, it is addressed here at the application layer, i.e., in RPCSEC_GSS.",
      "ja": "既存のGSS-API機構は、サーバーに特定の許可および認証情報を通信するために不十分です。 GSS-APIとそのメカニズムは確かに、この欠点に対処するように拡張することができます。しかし、それはRPCSEC_GSSに、すなわち、アプリケーション層で、ここで取り上げています。"
    },
    {
      "indent": 3,
      "text": "A major motivation for version 3 of RPCSEC_GSS (RPCSEC_GSSv3) is to add support for multi-level (labeled) security and server-side copy for NFSv4.",
      "ja": "RPCSEC_GSS（RPCSEC_GSSv3）のバージョン3のための主要な動機はNFSv4のためのマルチレベル（ラベル）セキュリティとサーバー側のコピーのサポートを追加することです。"
    },
    {
      "indent": 3,
      "text": "Multi-Level Security (MLS) is a traditional model where subjects (processes) are given a security level (Unclassified, Secret, Top Secret, etc.) and objects (files) are given security labels that mandate the access of the subject to the object (see Section 9.1 of [RFC7862]).",
      "ja": "マルチレベルセキュリティ（MLS）は、対象のアクセスを義務対象者（プロセス）は、セキュリティラベルを与えられているセキュリティレベル（未分類、秘密、などトップシークレット）とオブジェクト（ファイル）を与えられている伝統的なモデルであり、オブジェクト（[RFC7862]のセクション9.1を参照）。"
    },
    {
      "indent": 3,
      "text": "Labeled NFS (see Section 9 of [RFC7862]) uses an MLS policy with Mandatory Access Control (MAC) systems as defined in [RFC4949]. Labeled NFS stores MAC file object labels on the NFS server and enables client Guest Mode MAC as described in Section 9.5.3 of [RFC7862]. RPCSEC_GSSv3 label assertions assert client MAC process subject labels to enable Full Mode MAC when combined with Labeled NFS as described in Section 9.5.1 of [RFC7862].",
      "ja": "標識NFS [RFC4949]で定義されるように強制アクセス制御（MAC）システムとMLSポリシーを使用する（[RFC7862]はセクション9を参照）。 [RFC7862]のセクション9.5.3で説明したように標識したNFS店MACファイルオブジェクトのNFSサーバ上のラベルとは、クライアントゲストモードMACを可能にします。 RPCSEC_GSSv3ラベルアサーションは[RFC7862]のセクション9.5.1に記載のように標識されたNFSと組み合わせた場合にフルモードMACを可能にするために、クライアントのMAC処理被写体ラベルをアサートします。"
    },
    {
      "indent": 3,
      "text": "A traditional inter-server file copy entails the user gaining access to a file on the source, reading it, and writing it to a file on the destination. In secure NFSv4 inter-server server-side copy (see Section 4 of [RFC7862]), the user first secures access to both source and destination files and then uses NFSv4.2-defined RPCSEC_GSSv3 structured privileges to authorize the destination to copy the file from the source on behalf of the user.",
      "ja": "従来のサーバ間のファイルのコピーは、ソース上のファイルにアクセスするユーザー、それを読んで、そして先のファイルに書き込むを伴います。セキュアなNFSv4サーバ間のサーバ側のコピーに（[RFC7862]のセクション4を参照）、ユーザは、まず両方のソースおよび宛先ファイルへのアクセスを確保し、ファイルをコピーする先を許可するNFSv4.2定義RPCSEC_GSSv3構造権限を使用しユーザーの代わりにソースから。"
    },
    {
      "indent": 3,
      "text": "Multi-principal authentication can be used to address shared cache poisoning attacks (see Section 9 of [AFS-RXGK]) on the client cache by a user. As described in Section 7 of [AFS-RXGK], multi-user machines with a single cache manager can fetch and cache data on a user's behalf and re-display it for another user from the cache without refetching the data from the server. The initial data acquisition is authenticated by the first user's credentials, and if only that user's credentials are used, it may be possible for a malicious user or users to \"poison\" the cache for other users by introducing bogus data into the cache.",
      "ja": "マルチ主要な認証は、ユーザーがクライアントのキャッシュに（[AFS-RXGK]のセクション9を参照）共有キャッシュ汚染攻撃に対処するために使用することができます。 [AFS-RXGK]のセクション7で説明したように、単一のキャッシュマネージャとマルチユーザマシンは、サーバからのデータを再フェッチすることなく、キャッシュから、他のユーザのためにそれをフェッチし、キャッシュデータをユーザの代わりに、再表示することができます。初期データの取得は、最初にユーザーの資格情報によって認証され、そのユーザーの資格情報を使用している場合にのみ、それは「毒」に、悪意のあるユーザーまたはユーザーキャッシュに偽のデータを導入することで、他のユーザーのためのキャッシュのために可能かもしれません。"
    },
    {
      "indent": 3,
      "text": "Another use of the multi-principal assertion is the secure conveyance of privilege information for processes running with more (or even with less) privilege than the user normally would be accorded.",
      "ja": "マルチ主要アサーションの別の使用は、ユーザ通常られるべきであろうよりも多くの（またはそれ以下で）権限で実行中のプロセスの権限情報を安全に搬送します。"
    },
    {
      "indent": 0,
      "text": "1.1. Requirements Language",
      "section_title": true,
      "ja": "1.1。要件言語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [RFC2119].",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はRFC 2119 [RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "1.2. Added Functionality",
      "section_title": true,
      "ja": "1.2。追加された機能"
    },
    {
      "indent": 3,
      "text": "RPCSEC_GSS version 3 (RPCSEC_GSSv3) is the same as RPCSEC_GSSv2 [RFC5403], except that the following assertions of authority have been added:",
      "ja": "RPCSEC_GSSバージョン3（RPCSEC_GSSv3）権限の次のアサーションが追加されていることを除いて、RPCSEC_GSSv2 [RFC5403]と同じです。"
    },
    {
      "indent": 3,
      "text": "o Security labels for Full Mode security type enforcement, and other labeled security models (see Section 9.5.1 of [RFC7862]).",
      "ja": "Oフルモードセキュリティタイプの施行のためのセキュリティラベル、およびその他のラベルされたセキュリティモデル（[RFC7862]のセクション9.5.1を参照してください）。"
    },
    {
      "indent": 3,
      "text": "o Application-specific structured privileges. These allow an RPC application client to pass structured information to the corresponding application code in a server to control the use of the privilege and/or the conditions in which the privilege may be exercised. For an example, see server-side copy as described in [RFC7862].",
      "ja": "Oアプリケーション固有の構造化された権限。これらは、RPCアプリケーション・クライアントは、特権および/または特権を行使することのできる条件の使用を制御するために、サーバに対応するアプリケーションコードに構造化された情報を渡すことを可能にします。 [RFC7862]に記載されているように、例えば、サーバ側のコピーを参照してください。"
    },
    {
      "indent": 3,
      "text": "o Multi-principal authentication of the client host and user to the server, done by binding two RPCSEC_GSS handles.",
      "ja": "Oサーバーへのクライアントホストとユーザのマルチ主要な認証は、2つのRPCSEC_GSSハンドルを結合することによって行わ。"
    },
    {
      "indent": 3,
      "text": "o Simplified channel binding.",
      "ja": "O結合チャネルを簡素化。"
    },
    {
      "indent": 3,
      "text": "Assertions of labels and privileges are evaluated by the server, which may then map the asserted values to other values, all according to server-side policy. See [RFC7862].",
      "ja": "ラベルおよび権限のアサーションは、すべてのサーバー・サイド・ポリシーに応じて、他の値にアサートされた値をマッピングすることができるサーバ、によって評価されます。 [RFC7862]を参照してください。"
    },
    {
      "indent": 3,
      "text": "An option for enumerating server-supported Label Format Specifiers (LFSs) is provided. See Section 9.1 of [RFC7862].",
      "ja": "サーバーでサポートされているラベルフォーマット指定子（LFSs）を列挙するためのオプションが提供されます。 [RFC7862]のセクション9.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "Note that there is no RPCSEC_GSS_CREATE payload that is REQUIRED to implement. RPCSEC_GSSv3 implementations are feature driven. Besides implementing the RPCSEC_GSS_CREATE operation and payloads for the desired features, all RPCSEC_GSSv3 implementations MUST implement:",
      "ja": "実装するために必要とされるいかなるRPCSEC_GSS_CREATEペイロードがないことに注意してください。 RPCSEC_GSSv3実装が機能駆動されます。所望の機能のRPCSEC_GSS_CREATE動作及びペイロードを実現するほか、全RPCSEC_GSSv3実装が実装しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o The new RPCSEC_GSS version number (Section 2.2).",
      "ja": "新しいRPCSEC_GSSのバージョン番号（2.2節）、O。"
    },
    {
      "indent": 3,
      "text": "o The new reply verifier (Section 2.3).",
      "ja": "新しい返信検証O（2.3節）。"
    },
    {
      "indent": 3,
      "text": "o The new auth_stat values (Section 2.6).",
      "ja": "新しいauth_stat値O（2.6節）。"
    },
    {
      "indent": 3,
      "text": "RPCSEC_GSSv3 targets implementing a desired feature MUST also implement the RPCSEC_GSS_LIST operation, and the RPCSEC_GSS_CREATE operation replies for unsupported features as follows:",
      "ja": "所望の機能を実現RPCSEC_GSSv3ターゲットもRPCSEC_GSS_LIST動作を実装しなければなりません、そして次のようにRPCSEC_GSS_CREATE動作がサポートされない機能のために返信。"
    },
    {
      "indent": 3,
      "text": "o For label assertions, the target indicates no support by returning the new RPCSEC_GSS_LABEL_PROBLEM auth_stat value (see Section 2.7.1.3).",
      "ja": "ラベルアサーションについてはO、ターゲットは（セクション2.7.1.3を参照）新しいRPCSEC_GSS_LABEL_PROBLEMのauth_stat値を返すことはサポートがないことを示します。"
    },
    {
      "indent": 3,
      "text": "o For structured privilege assertions, the target indicates no support by returning the new RPCSEC_GSS_UNKNOWN_MESSAGE auth_stat value (see Section 2.7.1.4).",
      "ja": "O構造権限のアサーションのために、ターゲットが新しいRPCSEC_GSS_UNKNOWN_MESSAGEのauth_stat値を（セクション2.7.1.4を参照）を返すことではサポートがないことを示します。"
    },
    {
      "indent": 3,
      "text": "o For multi-principal authentication (Section 2.7.1.1), the target indicates no support by not including an rgss3_gss_mp_auth value in the rgss3_create_res.",
      "ja": "マルチ主要認証（セクション2.7.1.1）についてoは、ターゲットがrgss3_create_resでrgss3_gss_mp_auth値を含めないことではサポートがないことを示します。"
    },
    {
      "indent": 3,
      "text": "o For channel bindings (Section 2.7.1.2), the target indicates no support by not including an rgss3_chan_binding value in the rgss3_create_res.",
      "ja": "チャネルバインディング（セクション2.7.1.2）についてoは、ターゲットがrgss3_create_resでrgss3_chan_binding値を含めないことによってはサポートがないことを示します。"
    },
    {
      "indent": 0,
      "text": "1.3. XDR Code Extraction",
      "section_title": true,
      "ja": "1.3。 XDRコードの抽出"
    },
    {
      "indent": 3,
      "text": "This document contains the External Data Representation (XDR) [RFC4506] definitions for the RPCSEC_GSSv3 protocol. The XDR description is provided in this document in a way that makes it simple for the reader to extract it into a form that is ready to compile. The reader can feed this document in the following shell script to produce the machine-readable XDR description of RPCSEC_GSSv3:",
      "ja": "この文書では、RPCSEC_GSSv3プロトコルのための外部データ表現（XDR）[RFC4506]の定義が含まれています。 XDRの記述は、それが簡単な読者がコンパイルする準備ができているフォームにそれを抽出することを可能にする方法で、このドキュメントで提供されています。読者はRPCSEC_GSSv3の機械可読XDR記述を生成するために、次のシェルスクリプトでこのドキュメントを供給することができます。"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS>",
      "ja": "<CODEが開始されます>"
    },
    {
      "indent": 3,
      "text": "#!/bin/sh grep \"^ *///\" | sed 's?^ */// ??' | sed 's?^ *///$??'",
      "ja": "ます。＃！/ bin / shのはgrep \"^ * ///\" | SEDの？^ * /// ?? ' | SEDの？^ * /// $ ?? '"
    },
    {
      "indent": 3,
      "text": "<CODE ENDS>",
      "ja": "<CODEはENDS>"
    },
    {
      "indent": 3,
      "text": "That is, if the above script is stored in a file called \"extract.sh\" and this document is in a file called \"spec.txt\", then the reader can do:",
      "ja": "これは、上記のスクリプトは、「extract.sh」と呼ばれるファイルに格納されており、この文書は「spec.txt」と呼ばれるファイルである、そして読者が行うことができます場合は、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS>",
      "ja": "<CODEが開始されます>"
    },
    {
      "indent": 4,
      "text": "sh extract.sh < spec.txt > rpcsec_gss_v3.x",
      "ja": "SH extract.sh <spec.txt> rpcsec_gss_v3.x"
    },
    {
      "indent": 3,
      "text": "<CODE ENDS>",
      "ja": "<CODEはENDS>"
    },
    {
      "indent": 3,
      "text": "The effect of the script is to remove leading white space from each line, plus a sentinel sequence of \"///\".",
      "ja": "スクリプトの効果は、主要な白の各ラインからのスペース、プラス「///」のセンチネル配列を除去することです。"
    },
    {
      "indent": 0,
      "text": "2. The RPCSEC_GSSv3 Protocol",
      "section_title": true,
      "ja": "2. RPCSEC_GSSv3プロトコル"
    },
    {
      "indent": 3,
      "text": "RPCSEC_GSS version 3 (RPCSEC_GSSv3) is very similar to RPCSEC_GSS version 2 (RPCSEC_GSSv2) [RFC5403]. The difference is that the new support for assertions and channel bindings is implemented via a different mechanism.",
      "ja": "RPCSEC_GSSバージョン3（RPCSEC_GSSv3）RPCSEC_GSSバージョン2（RPCSEC_GSSv2）[RFC5403]と非常に類似しています。違いは、アサーションと、チャネルバインディングのための新たなサポートは、異なる機構を介して実装されていることです。"
    },
    {
      "indent": 3,
      "text": "The entire RPCSEC_GSSv3 protocol is not presented here. Only the differences between RPCSEC_GSSv3 and RPCSEC_GSSv2 are shown.",
      "ja": "全体RPCSEC_GSSv3プロトコルは、ここで提示されていません。 RPCSEC_GSSv3とRPCSEC_GSSv2間の相違点のみを示しています。"
    },
    {
      "indent": 3,
      "text": "RPCSEC_GSSv3 is implemented as follows:",
      "ja": "次のようにRPCSEC_GSSv3が実装されています。"
    },
    {
      "indent": 3,
      "text": "o A client uses an existing RPCSEC_GSSv3 context handle established in the usual manner (see Section 5.2 of [RFC2203]) to protect RPCSEC_GSSv3 exchanges; this will be termed the \"parent\" handle.",
      "ja": "Oクライアントは、通常の方法で確立された既存のRPCSEC_GSSv3・コンテキスト・ハンドルを使用する（セクション5.2を参照[RFC2203]）RPCSEC_GSSv3交換を保護します。これは、「親」のハンドルと呼ばれます。"
    },
    {
      "indent": 3,
      "text": "o The server issues a \"child\" RPCSEC_GSSv3 handle in the RPCSEC_GSS_CREATE response, which uses the underlying GSS-API security context of the parent handle in all subsequent exchanges that use the child handle.",
      "ja": "Oサーバーは、子のハンドルを使用し、後続のすべての取引所における親ハンドルの基本的なGSS-APIのセキュリティコンテキストを使用していますRPCSEC_GSS_CREATE応答では、「子」RPCSEC_GSSv3ハンドルを発行します。"
    },
    {
      "indent": 3,
      "text": "o An RPCSEC_GSSv3 child handle MUST NOT be used as the parent handle in an RPCSEC_GSS3_CREATE control message.",
      "ja": "O RPCSEC_GSSv3子ハンドルはRPCSEC_GSS3_CREATE制御メッセージ中の親ハンドルとして使用してはいけません。"
    },
    {
      "indent": 0,
      "text": "2.1. Compatibility with RPCSEC_GSSv2",
      "section_title": true,
      "ja": "2.1。 RPCSEC_GSSv2との互換性"
    },
    {
      "indent": 3,
      "text": "The functionality of RPCSEC_GSSv2 [RFC5403] is fully supported by RPCSEC_GSSv3, with the exception of the RPCSEC_GSS_BIND_CHANNEL operation, which is not supported when RPCSEC_GSSv3 is in use (see Section 2.5).",
      "ja": "RPCSEC_GSSv2 [RFC5403]の機能は完全RPCSEC_GSSv3が使用中であるときにサポートされていないRPCSEC_GSS_BIND_CHANNEL動作、（2.5節を参照）を除いて、RPCSEC_GSSv3によって支持されています。"
    },
    {
      "indent": 0,
      "text": "2.2. Version Negotiation",
      "section_title": true,
      "ja": "2.2。バージョンネゴシエーション"
    },
    {
      "indent": 3,
      "text": "An initiator that supports version 3 of RPCSEC_GSS simply issues an RPCSEC_GSS request with the rgc_version field set to RPCSEC_GSS_VERS_3. If the target does not recognize RPCSEC_GSS_VERS_3, the target will return an RPC error per Section 5.1 of [RFC2203].",
      "ja": "RPCSEC_GSSのバージョン3をサポートしていますイニシエータは単にRPCSEC_GSS_VERS_3に設定rgc_versionフィールドとRPCSEC_GSS要求を発行します。ターゲットはRPCSEC_GSS_VERS_3を認識しない場合、ターゲットは[RFC2203]のセクション5.1あたりのRPCエラーを返します。"
    },
    {
      "indent": 3,
      "text": "The initiator MUST NOT attempt to use an RPCSEC_GSS handle returned by version 3 of a target with version 1 or version 2 of the same target. The initiator MUST NOT attempt to use an RPCSEC_GSS handle returned by version 1 or version 2 of a target with version 3 of the same target.",
      "ja": "イニシエータは、バージョン1または同じターゲットのバージョン2を使用してターゲットのバージョン3で返さRPCSEC_GSSハンドルを使用しようとしてはなりません。イニシエータは同じターゲットのバージョン3とバージョン1またはターゲットのバージョン2で返さRPCSEC_GSSハンドルを使用しようとしてはなりません。"
    },
    {
      "indent": 0,
      "text": "2.3. New Reply Verifier",
      "section_title": true,
      "ja": "2.3。新しい返信検証"
    },
    {
      "indent": 3,
      "text": "A new reply verifier is needed for RPCSEC_GSSv3 because of a situation that arises from the use of the same GSS context by child and parent handles. Because the RPCSEC_GSSv3 child handle uses the same GSS context as the parent handle, a child and parent RPCSEC_GSSv3 handle could have the same RPCSEC_GSS sequence numbers. Since the reply verifier of previous versions of RPCSEC_GSS computes a Message Integrity Code (MIC) on just the sequence number, this provides opportunities for man-in-the-middle attacks.",
      "ja": "新しい返信検証があるため、子と親のハンドルによって、同じGSSコンテキストの使用から生じる状況をRPCSEC_GSSv3のために必要とされています。 RPCSEC_GSSv3子ハンドルが親のハンドルと同じGSSコンテキストを使用しているため、子と親RPCSEC_GSSv3ハンドルは同じRPCSEC_GSSのシーケンス番号を持つことができます。 RPCSEC_GSSの以前のバージョンの応答ベリファイアは単にシーケンス番号にメッセージ完全性コード（MIC）を計算するので、これはman-in-the-middle攻撃の機会を提供します。"
    },
    {
      "indent": 3,
      "text": "This issue is addressed in RPCSEC_GSS version 3 by computing the verifier using exactly the same input as the information used to compute the request verifier, except that the mtype is changed from CALL to REPLY. The new reply verifier computes a MIC over the following RPC reply header data:",
      "ja": "この問題は、正確MTYPE返信するCALLから変更されたことを除いて、要求の検証を計算するために使用される情報と同じ入力を使用してベリファイアを計算することによってRPCSEC_GSSバージョン3で対処されます。新しい応答ベリファイアは、以下のRPC応答ヘッダデータに対するMICを計算します。"
    },
    {
      "indent": 5,
      "text": "unsigned int xid;\nmsg_type mtype;    /* set to REPLY */\nunsigned int rpcvers;\nunsigned int prog;\nunsigned int vers;\nunsigned int proc;\nopaque_auth  cred; /* binds the RPCSEC_GSS handle */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "2.4. XDR Code Preliminaries",
      "section_title": true,
      "ja": "2.4。 XDRコード予選"
    },
    {
      "indent": 3,
      "text": "The following code fragment replaces the corresponding preliminary code shown in Figure 1 of [RFC5403]. The values in the code fragment in Section 2.6 are additions to the auth_stat enumeration. Subsequent code fragments are additions to the code for version 2 that support the new procedures defined in version 3.",
      "ja": "次のコードは、[RFC5403]の図1に示された対応する予備コードを置き換えます。 2.6節のコードフラグメントの値はauth_stat列挙への追加です。後続のコードフラグメントは、バージョン3で定義された新たな手順をサポートするバージョン2のコードに追加されています。"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS>",
      "ja": "<CODEが開始されます>"
    },
    {
      "indent": 6,
      "text": "///  /*\n///   * Copyright (c) 2016 IETF Trust and the persons\n///   * identified as the authors.  All rights reserved.\n///   *\n///   * The authors of the code are identified in RFC 2203,\n///   * RFC 5403, and RFC 7861.\n///   *\n///   * Redistribution and use in source and binary forms,\n///   * with or without modification, are permitted\n///   * provided that the following conditions are met:\n///   *\n///   * o Redistributions of source code must retain the above\n///   *   copyright notice, this list of conditions and the\n///   *   following disclaimer.\n///   *\n///   * o Redistributions in binary form must reproduce the\n///   *   above copyright notice, this list of\n///   *   conditions and the following disclaimer in\n///   *   the documentation and/or other materials\n///   *   provided with the distribution.\n///   *\n///   * o Neither the name of Internet Society, IETF or IETF\n///   *   Trust, nor the names of specific contributors, may be\n///   *   used to endorse or promote products derived from this\n///   *   software without specific prior written permission.\n///   *\n///   *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n///   *   AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED\n///   *   WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n///   *   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n///   *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO\n///   *   EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n///   *   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n///   *   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n///   *   NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n///   *   SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n///   *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n///   *   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,",
      "raw": true
    },
    {
      "indent": 6,
      "text": "///   *   OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n///   *   IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n///   *   ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n///   */\n///\n///  /*\n///   * This code was derived from RFC 2203, RFC 5403,\n///   * and RFC 7861.  Please reproduce this note if possible.\n///   */\n///\n///  enum rpc_gss_service_t {\n///          /* Note: The enumerated value for 0 is reserved. */\n///          rpc_gss_svc_none         = 1,\n///          rpc_gss_svc_integrity    = 2,\n///          rpc_gss_svc_privacy      = 3,\n///          rpc_gss_svc_channel_prot = 4\n///  };\n///\n///  enum rpc_gss_proc_t {\n///           RPCSEC_GSS_DATA          = 0,\n///           RPCSEC_GSS_INIT          = 1,\n///           RPCSEC_GSS_CONTINUE_INIT = 2,\n///           RPCSEC_GSS_DESTROY       = 3,\n///           RPCSEC_GSS_BIND_CHANNEL  = 4, /* Not used */\n///           RPCSEC_GSS_CREATE        = 5, /* New */\n///           RPCSEC_GSS_LIST          = 6  /* New */\n///  };\n///\n///  struct rpc_gss_cred_vers_1_t {\n///          rpc_gss_proc_t    gss_proc; /* Control procedure */\n///          unsigned int      seq_num;  /* Sequence number */\n///          rpc_gss_service_t service;  /* Service used */\n///          opaque            handle<>; /* Context handle */\n///  };\n///\n///  const RPCSEC_GSS_VERS_1 = 1;\n///  const RPCSEC_GSS_VERS_2 = 2;\n///  const RPCSEC_GSS_VERS_3 = 3; /* New */\n///\n///  union rpc_gss_cred_t switch (unsigned int rgc_version) {\n///  case RPCSEC_GSS_VERS_1:\n///  case RPCSEC_GSS_VERS_2:\n///  case RPCSEC_GSS_VERS_3: /* New */\n///          rpc_gss_cred_vers_1_t rgc_cred_v1;\n///  };\n///",
      "raw": true
    },
    {
      "indent": 3,
      "text": "<CODE ENDS>",
      "ja": "<CODEはENDS>"
    },
    {
      "indent": 3,
      "text": "As seen above, the RPCSEC_GSSv3 credential has the same format as the RPCSEC_GSSv1 [RFC2203] and RPCSEC_GSSv2 [RFC5403] credential. Setting the rgc_version field to 3 indicates that the initiator and target support the new RPCSEC_GSSv3 control procedures.",
      "ja": "上記から分かるように、RPCSEC_GSSv3クレデンシャルはRPCSEC_GSSv1 [RFC2203]とRPCSEC_GSSv2 [RFC5403]信任状と同じフォーマットを有します。 3にrgc_versionフィールドを設定すると、イニシエータは新しいRPCSEC_GSSv3制御手順をサポートして標的とすることを示しています。"
    },
    {
      "indent": 0,
      "text": "2.5. RPCSEC_GSS_BIND_CHANNEL Operation",
      "section_title": true,
      "ja": "2.5。 RPCSEC_GSS_BIND_CHANNEL操作"
    },
    {
      "indent": 3,
      "text": "RPCSEC_GSSv3 provides a channel-binding assertion that replaces the RPCSEC_GSSv2 RPCSEC_GSS_BIND_CHANNEL operation.",
      "ja": "RPCSEC_GSSv3はRPCSEC_GSSv2 RPCSEC_GSS_BIND_CHANNEL操作を置き換え、チャネル結合アサーションを提供します。"
    },
    {
      "indent": 3,
      "text": "The RPCSEC_GSS_BIND_CHANNEL operation is not supported on RPCSEC_GSS version 3 handles. If a server receives an RPCSEC_GSS_BIND_CHANNEL operation on an RPCSEC_GSSv3 handle, it MUST return a reply status of MSG_ACCEPTED with an accept_stat of PROC_UNAVAIL [RFC5531].",
      "ja": "RPCSEC_GSS_BIND_CHANNEL操作はRPCSEC_GSSバージョン3つのハンドルではサポートされていません。サーバがRPCSEC_GSSv3ハンドルのRPCSEC_GSS_BIND_CHANNEL操作を受信した場合、それはPROC_UNAVAIL [RFC5531]のaccept_statでMSG_ACCEPTEDの返信状況を返さなければなりません。"
    },
    {
      "indent": 0,
      "text": "2.6. New auth_stat Values",
      "section_title": true,
      "ja": "2.6。新auth_stat値"
    },
    {
      "indent": 3,
      "text": "RPCSEC_GSSv3 requires the addition of several values to the auth_stat enumerated type definition. The use of these new auth_stat values is explained throughout this document.",
      "ja": "RPCSEC_GSSv3はauth_stat列挙型の定義には、いくつかの値を追加する必要があります。これらの新しいauth_stat値の使用は、本文書全体で説明されています。"
    },
    {
      "indent": 14,
      "text": "enum auth_stat {\n        ...\n        /*\n         * RPCSEC_GSSv3 errors\n         */\n        RPCSEC_GSS_INNER_CREDPROBLEM = 15,\n        RPCSEC_GSS_LABEL_PROBLEM     = 16,\n        RPCSEC_GSS_PRIVILEGE_PROBLEM = 17,\n        RPCSEC_GSS_UNKNOWN_MESSAGE   = 18\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "2.7. New Control Procedures",
      "section_title": true,
      "ja": "2.7。新しい制御手順"
    },
    {
      "indent": 3,
      "text": "There are two new RPCSEC_GSSv3 control procedures: RPCSEC_GSS_CREATE and RPCSEC_GSS_LIST.",
      "ja": "RPCSEC_GSS_CREATEとRPCSEC_GSS_LIST：二つの新しいRPCSEC_GSSv3制御手順があります。"
    },
    {
      "indent": 3,
      "text": "The RPCSEC_GSS_CREATE procedure binds any combination of assertions -- multi-principal authentication, labels, structured privileges, or channel bindings -- to a new RPCSEC_GSSv3 context returned in the rgss3_create_res rcr_handle field.",
      "ja": "マルチ主要認証、ラベル、構造化された権限、またはチャネルバインディング -   -  rgss3_create_res rcr_handleフィールドに返された新しいRPCSEC_GSSv3コンテキストにRPCSEC_GSS_CREATE手順は、アサーションの任意の組み合わせをバインドします。"
    },
    {
      "indent": 3,
      "text": "The RPCSEC_GSS_LIST procedure queries the target for supported assertions.",
      "ja": "RPCSEC_GSS_LIST手順は、サポートされているアサーションのターゲットを照会します。"
    },
    {
      "indent": 3,
      "text": "RPCSEC_GSS version 3 control messages are similar to the RPCSEC_GSS version 1 and version 2 RPCSEC_GSS_DESTROY control message (see Section 5.4 of [RFC2203]) in that the sequence number in the request must be valid and the header checksum in the verifier must be valid. As in RPCSEC_GSS version 1 and version 2, the RPCSEC_GSS version 3 control messages may contain call data following the verifier in the body of the NULLPROC procedure. In other words, they look a lot like an RPCSEC_GSS data message with the header procedure set to NULLPROC.",
      "ja": "リクエストのシーケンス番号が有効でなければならず、検証中のヘッダチェックサムが有効でなければならないという点で、RPCSEC_GSSバージョン3制御メッセージは、（[RFC2203]のセクション5.4を参照）RPCSEC_GSSバージョン1およびバージョン2 RPCSEC_GSS_DESTROY制御メッセージと同様です。 RPCSEC_GSSバージョン1とバージョン2のように、RPCSEC_GSSバージョン3制御メッセージはNULLPROC手順の体内の検証以下の通話データを含むことができます。言い換えれば、彼らはたくさんNULLPROCに設定されたヘッダの手順でRPCSEC_GSSデータメッセージのように見えます。"
    },
    {
      "indent": 3,
      "text": "The client MUST use one of the following security services to protect the RPCSEC_GSS_CREATE or RPCSEC_GSS_LIST control message:",
      "ja": "クライアントはRPCSEC_GSS_CREATEまたはRPCSEC_GSS_LIST制御メッセージを保護するために、次のセキュリティ・サービスのいずれかを使用しなければなりません："
    },
    {
      "indent": 3,
      "text": "o rpc_gss_svc_integrity",
      "ja": "Oのrpc_gss_svc_integrity"
    },
    {
      "indent": 3,
      "text": "o rpc_gss_svc_privacy",
      "ja": "rpc_gss_svc_privacy O"
    },
    {
      "indent": 3,
      "text": "Specifically, the client MUST NOT use rpc_gss_svc_none.",
      "ja": "具体的には、クライアントがrpc_gss_svc_noneを使用してはなりません。"
    },
    {
      "indent": 3,
      "text": "RPCSEC_GSS_LIST can also use rpc_gss_svc_channel_prot (see RPCSEC_GSSv2 [RFC5403]) if the request is sent using an RPCSEC_GSSv3 child handle with channel bindings enabled as described in Section 2.7.1.2.",
      "ja": "要求は、セクション2.7.1.2に記載されるようにRPCSEC_GSSv3子が有効チャネルバインディングとハンドル用いて送信される場合RPCSEC_GSS_LISTもrpc_gss_svc_channel_protを使用することができ（RPCSEC_GSSv2 [RFC5403]参照）。"
    },
    {
      "indent": 0,
      "text": "2.7.1. New Control Procedure - RPCSEC_GSS_CREATE",
      "section_title": true,
      "ja": "2.7.1。新しい制御手順 -  RPCSEC_GSS_CREATE"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS>",
      "ja": "<CODEが開始されます>"
    },
    {
      "indent": 6,
      "text": "///  struct rgss3_create_args {\n///          rgss3_gss_mp_auth    *rca_mp_auth;\n///          rgss3_chan_binding   *rca_chan_bind_mic;\n///          rgss3_assertion_u    rca_assertions<>;\n///  };\n///\n///  struct rgss3_create_res {\n///          opaque               rcr_handle<>;\n///          rgss3_gss_mp_auth    *rcr_mp_auth;\n///          rgss3_chan_binding   *rcr_chan_bind_mic;\n///          rgss3_assertion_u    rcr_assertions<>;\n///  };\n///\n///  enum rgss3_assertion_type {\n///          LABEL = 0,\n///          PRIVS = 1\n///  };\n///\n///  union rgss3_assertion_u\n///        switch (rgss3_assertion_type atype) {\n///  case LABEL:\n///          rgss3_label  rau_label;\n///  case PRIVS:\n///          rgss3_privs  rau_privs;\n///  default:\n///          opaque       rau_ext<>;\n///  };\n///",
      "raw": true
    },
    {
      "indent": 3,
      "text": "<CODE ENDS>",
      "ja": "<CODEはENDS>"
    },
    {
      "indent": 3,
      "text": "The call data for an RPCSEC_GSS_CREATE request consists of an rgss3_create_args, which binds one or more items of several kinds to the returned rcr_handle RPCSEC_GSSv3 context handle (the child handle):",
      "ja": "RPCSEC_GSS_CREATE要求のためのコールデータが返さrcr_handle RPCSEC_GSSv3・コンテキスト・ハンドル（子ハンドル）へのいくつかの種類の1つ以上の項目を結合しrgss3_create_args、から構成されています。"
    },
    {
      "indent": 3,
      "text": "o Multi-principal authentication: another RPCSEC_GSS context handle",
      "ja": "Oマルチ元本認証：別のRPCSEC_GSSコンテキスト・ハンドル"
    },
    {
      "indent": 3,
      "text": "o A channel binding",
      "ja": "結合チャンネルO"
    },
    {
      "indent": 3,
      "text": "o Authorization assertions: labels and/or privileges",
      "ja": "認証アサーションO：ラベルおよび/または特権"
    },
    {
      "indent": 3,
      "text": "The reply to this message consists of either an error or an rgss3_create_res structure. As noted in Sections 2.7.1.3 and 2.7.1.4, successful rgss3_assertions are enumerated in rcr_assertions and are REQUIRED to be enumerated in the same order as they appeared in the rca_assertions argument.",
      "ja": "このメッセージへの応答は、エラーまたはrgss3_create_res構造のいずれかから成ります。セクション2.7.1.3と2.7.1.4で述べたように、成功したrgss3_assertionsはrcr_assertionsに列挙され、それらがrca_assertions引数に登場と同じ順序で列挙される必要があります。"
    },
    {
      "indent": 3,
      "text": "Upon a successful RPCSEC_GSS_CREATE, both the client and the server need to associate the resultant child rcr_handle context handle with the parent context handle in their GSS context caches so as to be able to reference the parent context given the child context handle.",
      "ja": "成功RPCSEC_GSS_CREATE時には、クライアントとサーバの両方が、子コンテキストのハンドルを指定された親のコンテキストを参照することができるように彼らのGSSコンテキストキャッシュ内の親コンテキスト・ハンドルに生じた子rcr_handleコンテキスト・ハンドルを関連付ける必要があります。"
    },
    {
      "indent": 3,
      "text": "RPCSEC_GSSv3 child handles MUST be destroyed upon the destruction of the associated parent handle.",
      "ja": "RPCSEC_GSSv3子ハンドルが関連付けられている親ハンドルの破壊時に破壊されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Server implementation and policy MAY result in labels, privileges, and identities being mapped to concepts and values that are local to the server. Server policies should take into account the identity of the client and/or user as authenticated via the GSS-API.",
      "ja": "Serverの実装とポリシーは、ラベル、権限、およびサーバーに対してローカルな概念や値にマッピングされたアイデンティティをもたらすことができます。 GSS-API経由で認証としてServerポリシーは、アカウントに、クライアントおよび/またはユーザの身元を取る必要があります。"
    },
    {
      "indent": 0,
      "text": "2.7.1.1. Multi-Principal Authentication",
      "section_title": true,
      "ja": "2.7.1.1。マルチ校長認証"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS>",
      "ja": "<CODEが開始されます>"
    },
    {
      "indent": 6,
      "text": "///\n///  struct rgss3_gss_mp_auth {\n///          opaque          rgmp_handle<>; /* Inner handle */\n///          opaque          rgmp_rpcheader_mic<>;\n///  };\n///",
      "raw": true
    },
    {
      "indent": 3,
      "text": "<CODE ENDS>",
      "ja": "<CODEはENDS>"
    },
    {
      "indent": 3,
      "text": "RPCSEC_GSSv3 clients MAY assert a multi-principal authentication of the RPC client host principal and a user principal. This feature is needed, for example, when an RPC client host wishes to use authority assertions that the server may only grant if a user and an RPC client host are authenticated together to the server. Thus, a server may refuse to grant requested authority to a user acting alone (e.g., via an unprivileged user-space program) or to an RPC client host acting alone (e.g., when an RPC client host is acting on behalf of a user) but may grant requested authority to an RPC client host acting on behalf of a user if the server identifies the user and trusts the RPC client host.",
      "ja": "RPCSEC_GSSv3クライアントは、RPCクライアントのホストプリンシパルとユーザー・プリンシパルのマルチ元本の認証を主張することができます。この機能は、RPCクライアントのホストは、ユーザやRPCのクライアントホストがサーバーに一緒に認証された場合、サーバーにのみ許可することができる権限のアサーションを使用したい場合、例えば、必要とされています。このように、サーバは、（非特権ユーザ空間のプログラム経由など、）単独で作用するユーザーまたは（RPCクライアントホストがユーザーに代わって行動しているなど、）単独で作用RPCクライアントホストに要求された権限を付与することを拒否してサーバがユーザを識別し、RPCクライアントのホストを信頼している場合が、ユーザーに代わって動作するRPCクライアントホストに要求された権限を付与することができます。"
    },
    {
      "indent": 3,
      "text": "It is assumed that an unprivileged user-space program would not have access to RPC client host credentials needed to establish a GSS-API security context authenticating the RPC client host to the server; therefore, an unprivileged user-space program could not create an RPCSEC_GSSv3 RPCSEC_GSS_CREATE message that successfully binds an RPC client host and a user security context.",
      "ja": "非特権ユーザ空間プログラムは、サーバーへのRPCクライアントホストを認証するGSS-APIのセキュリティコンテキストを確立するために必要なRPCクライアントホストの認証情報へのアクセス権を持っていないであろうと想定しています。そのため、非特権ユーザ空間プログラムが正常にRPCクライアントのホストとユーザーのセキュリティコンテキストをバインドしRPCSEC_GSSv3 RPCSEC_GSS_CREATEメッセージを作成できませんでした。"
    },
    {
      "indent": 3,
      "text": "In addition to the parent handle (Section 2), the multi-principal authentication call data has an RPCSEC_GSS version 3 handle referenced via the rgmp_handle field termed the \"inner\" handle. Clients using RPCSEC_GSSv3 multi-principal authentication MUST use an RPCSEC_GSSv3 context handle that corresponds to a GSS-API security context that authenticates the RPC client host for the parent handle. The inner context handle of the multi-principal authentication assertion MUST use an RPCSEC_GSSv3 context handle that corresponds to a GSS-API security context that authenticates the user. The reverse (parent handle authenticates user, inner context handle authenticates an RPC client host) MUST NOT be used. Other multi-principal parent and inner context handle uses might eventually make sense, but they would need to be introduced in a new revision of the RPCSEC_GSS protocol.",
      "ja": "親ハンドル（セクション2）に加えて、マルチ主要認証コールデータはrgmp_handleフィールドによって参照RPCSEC_GSSバージョン3ハンドルは、「内側」ハンドルと呼ばれています。 RPCSEC_GSSv3マルチ元本認証を使用しているクライアントは、親ハンドルのためのRPCクライアントホストを認証GSS-APIのセキュリティコンテキストに対応RPCSEC_GSSv3・コンテキスト・ハンドルを使用しなければなりません。マルチ主要認証アサーションの内部コンテキスト・ハンドルは、ユーザを認証するGSS-APIセキュリティコンテキストに対応RPCSEC_GSSv3・コンテキスト・ハンドルを使用しなければなりません。逆は（親ハンドルは、ユーザーを認証し、内側のコンテキスト・ハンドルは、RPCクライアントのホストを認証します）使用してはいけません。その他のマルチ元本親と内側のコンテキストハンドルの使用は、最終的に意味をなさないかもしれないが、彼らはRPCSEC_GSSプロトコルの新しいリビジョンで導入する必要があろう。"
    },
    {
      "indent": 3,
      "text": "The child context handle returned by a successful multi-principal assertion binds the inner RPCSEC_GSSv3 context handle to the parent RPCSEC_GSS context handle and MUST be treated by servers as authenticating the GSS-API initiator principal authenticated by the inner context handle's GSS-API security context. This principal may be mapped to a server-side notion of user or principal.",
      "ja": "成功したマルチ校長アサーションによって返された子コンテキスト・ハンドルは、親RPCSEC_GSSコンテキスト・ハンドルに内部RPCSEC_GSSv3コンテキスト・ハンドルを結合し、内部コンテキスト・ハンドルのGSS-APIのセキュリティコンテキストによって認証GSS-APIのイニシエータのプリンシパルを認証するよう、サーバによって処理されなければなりません。このプリンシパルは、ユーザーまたはプリンシパルのサーバ側の概念にマッピングすることができます。"
    },
    {
      "indent": 3,
      "text": "Multi-principal binding is done by including an assertion of type rgss3_gss_mp_auth in the RPCSEC_GSS_CREATE rgss3_create_args call data. The inner context handle is placed in the rgmp_handle field. A MIC of the RPC header, up to and including the credential, is computed using the GSS-API security context associated with the inner context handle and is placed in the rgmp_rpcheader_mic field. Note that the rgmp_rpcheader_mic only identifies the client host GSS context by its context handle (the parent context handle) in the RPC header.",
      "ja": "マルチ主要結合はRPCSEC_GSS_CREATE rgss3_create_args通話データにおける型rgss3_gss_mp_authのアサーションを含むことによって行われます。内側のコンテキストハンドルをrgmp_handleフィールドに配置されます。 RPCヘッダのMICは、資格までを含む、内部コンテキスト・ハンドルに関連付けられているGSS-APIのセキュリティコンテキストを使用して計算され、rgmp_rpcheader_micフィールドに配置されます。 rgmp_rpcheader_micのみRPCヘッダーにそのコンテキストハンドル（親コンテキスト・ハンドル）によってクライアントホストGSSコンテキストを識別することに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "An RPCSEC_GSS_CREATE control procedure with a multi-principal authentication payload MUST use the rpc_gss_svc_privacy security service for protection. This prevents an attacker from intercepting the RPCSEC_GSS_CREATE control procedure, reassigning the (parent) context handle, and stealing the user's identity.",
      "ja": "マルチ主要な認証ペイロードを持つRPCSEC_GSS_CREATE制御手順は、保護のためのrpc_gss_svc_privacyセキュリティサービスを使用しなければなりません。これは、RPCSEC_GSS_CREATE制御手順を傍受（親）コンテキストハンドルを再割り当てし、ユーザーのIDを盗むから攻撃を防ぐことができます。"
    },
    {
      "indent": 3,
      "text": "The target verifies the multi-principal authentication by first confirming that the parent context used is an RPC client host context; the target then verifies the rgmp_rpcheader_mic using the GSS-API security context associated with the rgmp_handle field.",
      "ja": "ターゲットは、最初に使用親コンテキストがRPCクライアントホストのコンテキストであることを確認することにより、マルチプリンシパルの認証を検証します。ターゲットは、rgmp_handleフィールドに関連するGSS-APIのセキュリティコンテキストを使用してrgmp_rpcheader_micを検証します。"
    },
    {
      "indent": 3,
      "text": "On successful verification, the rgss3_gss_mp_auth field in the rgss3_create_res reply MUST be filled in with the inner RPCSEC_GSSv3 context handle as the rgmp_handle and a MIC computed over the RPC reply header (see Section 2.3) using the GSS-API security context associated with the inner handle.",
      "ja": "成功した検証に、rgss3_create_resでrgss3_gss_mp_authフィールドが返信内側ハンドルに関連付けられているGSS-APIのセキュリティコンテキストを使用して（セクション2.3を参照）rgmp_handleとRPC応答ヘッダに対して計算MICように、内側RPCSEC_GSSv3・コンテキスト・ハンドルで埋めなければなりません。"
    },
    {
      "indent": 3,
      "text": "On failure, the rgss3_gss_mp_auth field is not sent (rgss3_gss_mp_auth is an optional field). A MSG_DENIED reply to the RPCSEC_GSS_CREATE call is formulated as usual.",
      "ja": "失敗した場合に、rgss3_gss_mp_authフィールドは（rgss3_gss_mp_authはオプションのフィールドで）送信されません。 RPCSEC_GSS_CREATEコールにMSG_DENIED返信はいつものように定式化されます。"
    },
    {
      "indent": 3,
      "text": "As described in Section 5.3.3.3 of [RFC2203], the server maintains a list of contexts for the clients that are currently in session with it. When a client request comes in, there may not be a context corresponding to its handle. When this occurs on an RPCSEC_GSS3_CREATE request processing of the parent handle, the server rejects the request with a reply status of MSG_DENIED with the reject_stat of AUTH_ERROR and with an auth_stat value of RPCSEC_GSS_CREDPROBLEM.",
      "ja": "[RFC2203]のセクション5.3.3.3で説明したように、サーバは、それとのセッションに現在あるクライアントのためのコンテキストのリストを維持します。クライアントの要求が到着すると、そのハンドルに対応するコンテキストがない可能性があります。これは、親ハンドルのRPCSEC_GSS3_CREATE要求処理で発生した場合、サーバはAUTH_ERRORのreject_stat有するとRPCSEC_GSS_CREDPROBLEMのauth_stat値MSG_DENIEDの応答ステータスと、要求を拒否します。"
    },
    {
      "indent": 3,
      "text": "A new value, RPCSEC_GSS_INNER_CREDPROBLEM, has been added to the auth_stat type. With a multi-principal authorization request, the server must also have a context corresponding to the inner context handle. When the server does not have a context handle corresponding to the inner context handle of a multi-principal authorization request, the server sends a reply status of MSG_DENIED with the reject_stat of AUTH_ERROR and with an auth_stat value of RPCSEC_GSS_INNER_CREDPROBLEM.",
      "ja": "新しい値、RPCSEC_GSS_INNER_CREDPROBLEMは、auth_statタイプに追加されました。マルチ主要認可要求を使用すると、サーバーは、内部コンテキスト・ハンドルに対応するコンテキストを持っている必要があります。サーバがマルチ主要認可要求の内側コンテキスト・ハンドルに対応するコンテキスト・ハンドルを持たない場合、サーバはAUTH_ERRORのreject_stat有するとRPCSEC_GSS_INNER_CREDPROBLEMのauth_stat値とMSG_DENIEDの応答ステータスを送信します。"
    },
    {
      "indent": 3,
      "text": "When processing the multi-principal authentication request, if the GSS_VerifyMIC() call on the rgmp_rpcheader_mic fails to return GSS_S_COMPLETE, the server sends a reply status of MSG_DENIED with the reject_stat of AUTH_ERROR and with an auth_stat value of RPCSEC_GSS_INNER_CREDPROBLEM.",
      "ja": "マルチ主要認証要求を処理するとき、rgmp_rpcheader_micにGSS_VerifyMIC（）呼び出しはGSS_S_COMPLETEを返すことに失敗した場合、サーバはAUTH_ERRORのreject_stat有するとRPCSEC_GSS_INNER_CREDPROBLEMのauth_stat値とMSG_DENIEDの応答ステータスを送信します。"
    },
    {
      "indent": 0,
      "text": "2.7.1.2. Channel Binding",
      "section_title": true,
      "ja": "2.7.1.2。チャネルバインディング"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS>",
      "ja": "<CODEが開始されます>"
    },
    {
      "indent": 6,
      "text": "/// /// typedef opaque rgss3_chan_binding<>; ///",
      "ja": "/// ///のtypedef不透明rgss3_chan_binding <>。 ///"
    },
    {
      "indent": 3,
      "text": "<CODE ENDS>",
      "ja": "<CODEはENDS>"
    },
    {
      "indent": 3,
      "text": "RPCSEC_GSSv3 provides a different way to do channel binding than RPCSEC_GSSv2 [RFC5403]. Specifically:",
      "ja": "RPCSEC_GSSv3はRPCSEC_GSSv2 [RFC5403]よりも結合チャネルを行うための別の方法を提供します。具体的に："
    },
    {
      "indent": 3,
      "text": "a. RPCSEC_GSSv3 builds on RPCSEC_GSSv1 by reusing existing, established context handles rather than providing a different RPC security flavor for establishing context handles.",
      "ja": "A。 RPCSEC_GSSv3はハンドル、既存の、確立されたコンテキストを再利用するのではなく、コンテキストハンドルを確立するためのさまざまなRPCセキュリティ風味を提供することにより、RPCSEC_GSSv1に基づいています。"
    },
    {
      "indent": 3,
      "text": "b. Channel-bindings data is not hashed because there is now general agreement that it is the secure channel's responsibility to produce channel-bindings data of manageable size.",
      "ja": "B。扱いやすいサイズのチャネルバインディングデータを生成するために、安全なチャネルの責任であるという一般的な合意は、今があるため、チャネルバインディングデータがハッシュされていません。"
    },
    {
      "indent": 3,
      "text": "(a) is useful in keeping RPCSEC_GSSv3 simple in general, not just for channel binding. (b) is useful in keeping RPCSEC_GSSv3 simple specifically for channel binding.",
      "ja": "（a）は一般的にだけでなく、結合チャネルのための単純なRPCSEC_GSSv3を維持するのに有用です。 （b）はチャネル結合のために特別に簡単RPCSEC_GSSv3を維持するのに有用です。"
    },
    {
      "indent": 3,
      "text": "Channel binding is accomplished as follows. The client prefixes the channel-bindings data octet string with the channel type as described in [RFC5056]; then, the client calls GSS_GetMIC() to get a MIC of the resulting octet string, using the parent RPCSEC_GSSv3 context handle's GSS-API security context. The MIC is then placed in the rca_chan_bind_mic field of RPCSEC_GSS_CREATE arguments (rgss3_create_args).",
      "ja": "次のように結合チャネルが達成されます。 [RFC5056]に記載されているように、クライアントは、チャネルタイプのチャネルバインディングデータオクテット列を接頭辞。そして、クライアントは親RPCSEC_GSSv3コンテキスト・ハンドルのGSS-APIのセキュリティコンテキストを使用して、結果のオクテット文字列のMICを取得するために（）GSS_GetMICを呼び出します。 MICは、次いでRPCSEC_GSS_CREATE引数（rgss3_create_args）のrca_chan_bind_micフィールドに配置されます。"
    },
    {
      "indent": 3,
      "text": "If the rca_chan_bind_mic field of the arguments of an RPCSEC_GSS_CREATE control message is set, then the server MUST verify the client's channel-binding MIC if the server supports this feature. If channel-binding verification succeeds, then the server MUST generate a new MIC of the same channel bindings and place it in the rcr_chan_bind_mic field of the RPCSEC_GSS_CREATE rgss3_create_res results. If channel-binding verification fails or the server doesn't support channel binding, then the server MUST indicate this in its reply by not including an rgss3_chan_binding value in rgss3_create_res (rgss3_chan_binding is an optional field).",
      "ja": "RPCSEC_GSS_CREATE制御メッセージの引数のrca_chan_bind_micフィールドが設定されている場合は、サーバーがこの機能をサポートしている場合、サーバはクライアントのチャネル結合MICを確かめなければなりません。チャネル結合検証が成功した場合、サーバーは、同じチャネルバインディングの新しいMICを生成し、RPCSEC_GSS_CREATEのrgss3_create_res結果のrcr_chan_bind_micフィールドに配置しなければなりません。チャネル結合の検証が失敗した場合、またはサーバが結合チャネルをサポートしていない場合、サーバはrgss3_create_resでrgss3_chan_binding値（rgss3_chan_bindingはオプションのフィールドである）を含まないことにより、その応答でこれを示さなければなりません。"
    },
    {
      "indent": 3,
      "text": "The client MUST verify the result's rcr_chan_bind_mic value by calling GSS_VerifyMIC() with the given MIC and the channel-bindings data (including the channel-type prefix). If client-side channel-binding verification fails, then the client MUST call",
      "ja": "クライアントは、（チャネル型のプレフィックスを含む）指定されたMICとチャネル・バインディングデータをGSS_VerifyMIC（）を呼び出すことにより、結果のrcr_chan_bind_mic値を確かめなければなりません。クライアント側のチャネル結合検証が失敗した場合、クライアントが呼び出す必要があります"
    },
    {
      "indent": 3,
      "text": "RPCSEC_GSS_DESTROY. If the client requested channel binding but the server did not include an rcr_chan_binding_mic field in the results, then the client MAY continue to use the resulting context handle as though channel binding had never been requested. If the client considers channel binding critical, it MUST call RPCSEC_GSS_DESTROY.",
      "ja": "RPCSEC_GSS_DESTROY。クライアント要求されたチャネルバインディングが、サーバーが結果にrcr_chan_binding_micフィールドが含まれていない場合、クライアントはチャンネルが要求されていなかったかのようにバインディング結果のコンテキスト・ハンドルを使用し続けることができます。クライアントが重要な結合チャネルを考慮した場合、それはRPCSEC_GSS_DESTROYを呼び出す必要があります。"
    },
    {
      "indent": 3,
      "text": "As per RPCSEC_GSSv2 [RFC5403]:",
      "ja": "RPCSEC_GSS v2の[RFC5403]あたりのように："
    },
    {
      "indent": 6,
      "text": "Once a successful [channel-binding] procedure has been performed on an [RPCSEC_GSSv3] context handle, the initiator's implementation may map application requests for rpc_gss_svc_none and rpc_gss_svc_integrity to rpc_gss_svc_channel_prot credentials. And if the secure channel has privacy enabled, requests for rpc_gss_svc_privacy can also be mapped to rpc_gss_svc_channel_prot.",
      "ja": "成功した[チャネル結合]手順は[RPCSEC_GSSv3]コンテキスト・ハンドル上で実行された後、イニシエータの実装では、資格情報をrpc_gss_svc_channel_protするrpc_gss_svc_noneとrpc_gss_svc_integrityのためのアプリケーション要求をマッピングすることができます。安全なチャネルはプライバシーが有効になっている場合や、rpc_gss_svc_privacyの要求もrpc_gss_svc_channel_protにマップすることができます。"
    },
    {
      "indent": 3,
      "text": "Any RPCSEC_GSSv3 child context handle that has been bound to a secure channel in this way SHOULD be used only with the rpc_gss_svc_channel_prot and SHOULD NOT be used with rpc_gss_svc_none or rpc_gss_svc_integrity -- if the secure channel does not provide privacy protection, then the client MAY use rpc_gss_svc_privacy where privacy protection is needed or desired.",
      "ja": "このように安全なチャネルにバインドされている任意のRPCSEC_GSSv3の子コンテキスト・ハンドルはrpc_gss_svc_channel_protでのみ使用する必要があり、rpc_gss_svc_noneまたはrpc_gss_svc_integrityには使用しないでください - 安全なチャネルは、プライバシー保護を提供しない場合、クライアントはrpc_gss_svc_privacyを使用するかもしれプライバシーの保護が必要または所望される場合。"
    },
    {
      "indent": 0,
      "text": "2.7.1.3. Label Assertions",
      "section_title": true,
      "ja": "2.7.1.3。ラベルのアサーション"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS>",
      "ja": "<CODEが開始されます>"
    },
    {
      "indent": 6,
      "text": "///  struct rgss3_label {\n///          rgss3_lfs       rl_lfs;\n///          opaque          rl_label<>;\n///  };\n///\n///  struct rgss3_lfs {\n///          unsigned int rlf_lfs_id;\n///          unsigned int rlf_pi_id;\n///  };\n///",
      "raw": true
    },
    {
      "indent": 3,
      "text": "<CODE ENDS>",
      "ja": "<CODEはENDS>"
    },
    {
      "indent": 3,
      "text": "The client discovers, via the RPCSEC_GSS_LIST control message, which LFSs the server supports. Full Mode MAC is enabled when an RPCSEC_GSS version 3 process subject label assertion is combined with a file object label provided by the NFSv4.2 sec_label attribute.",
      "ja": "クライアントは、サーバーがサポートをLFSs RPCSEC_GSS_LIST制御メッセージを介して、検出します。 RPCSEC_GSSのバージョン3つのプロセス対象ラベルアサーションがNFSv4.2 sec_l​​abel属性が提供するファイルオブジェクトのラベルと組み合わせた場合にフルモードMACが有効になっています。"
    },
    {
      "indent": 3,
      "text": "Label encoding is specified to mirror the NFSv4.2 sec_label attribute described in Section 12.2.4 of [RFC7862]. The LFS is an identifier used by the client to establish the syntactic format of the security label and the semantic meaning of its components. The Policy Identifier (PI) is an optional part of the definition of an LFS that allows clients and the server to identify specific security policies. The opaque label field (rgss3_label) is dependent on the MAC model to interpret and enforce.",
      "ja": "ラベルエンコーディングは[RFC7862]のセクション12.2.4に記載NFSv4.2 sec_l​​abel属性を反映するように指定されています。 LFSは、セキュリティラベルの構文形式とそのコンポーネントのセマンティックな意味を確立するためにクライアントによって使用される識別子です。方針識別子（PI）は、クライアントとサーバは、特定のセキュリティポリシーを識別することができますLFSの定義のオプション部分です。不透明なラベルフィールド（rgss3_label）が解釈し、施行するMACモデルに依存しています。"
    },
    {
      "indent": 3,
      "text": "If a label itself requires privacy protection (i.e., requires that the user can assert that the label is a secret), then the client MUST use the rpc_gss_svc_privacy protection service for the RPCSEC_GSS_CREATE request.",
      "ja": "ラベル自体は（つまり、ユーザーはラベルが秘密であることを主張できることが必要です）プライバシー保護を必要とする場合、クライアントはRPCSEC_GSS_CREATE要求に対してrpc_gss_svc_privacy保護サービスを使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "RPCSEC_GSSv3 clients MAY assert a set of subject security labels in some LFS by binding a label assertion to the RPCSEC_GSSv3 child context handle. This is done by including an assertion of type rgss3_label in the RPCSEC_GSS_CREATE rgss3_create_args rca_assertions call data. The label assertion payload is the set of subject labels asserted by the calling NFS client process. The resultant child context is used for NFS requests asserting the client process subject labels. The NFS server process that handles such requests then asserts the (client) process subject label(s) as it attempts to access a file that has associated Labeled NFS object labels.",
      "ja": "RPCSEC_GSSv3クライアントはRPCSEC_GSSv3子コンテキストハンドルにラベルアサーションを結合することによって、いくつかのLFSの被写体のセキュリティラベルのセットをアサートしてもよいです。これはRPCSEC_GSS_CREATEのrgss3_create_args rca_assertions通話データにおける型rgss3_labelのアサーションを含むことによって行われます。ラベルアサーションペイロードは呼び出しNFSクライアント・プロセスによってアサート対象ラベルのセットです。その結果、子コンテキストは、クライアント・プロセスの対象ラベルをアサートするNFS要求に使用されます。それは標識NFSオブジェクトラベルが関連付けられているファイルにアクセスしようとして、そのような要求を処理するNFSサーバプロセスは、（クライアント）処理対象のラベル（複数可）をアサートします。"
    },
    {
      "indent": 3,
      "text": "Servers that support labeling in the requested LFS MAY map the requested subject label to a different subject label as a result of server-side policy evaluation.",
      "ja": "要求されたLFSにラベル付けをサポートするサーバーは、サーバー側の政策評価の結果として、異なる対象ラベルに要求された対象ラベルをマッピングすることができます。"
    },
    {
      "indent": 3,
      "text": "The labels that are accepted by the target and bound to the RPCSEC_GSSv3 context MUST be enumerated in the rcr_assertions field of the rgss3_create_res RPCSEC_GSS_CREATE reply.",
      "ja": "ターゲットによって受け入れられ、RPCSEC_GSSv3コンテキストにバインドされているラベルはrgss3_create_resのRPCSEC_GSS_CREATE応答のrcr_assertionsフィールドに列挙されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Servers that do not support labeling or that do not support the requested LFS reject the label assertion with a reply status of MSG_DENIED, a reject_status of AUTH_ERROR, and an auth_stat of RPCSEC_GSS_LABEL_PROBLEM.",
      "ja": "ラベル付けをサポートしていないか、それが要求されたLFSをサポートしていないサーバーはMSG_DENIEDの返信状況、AUTH_ERRORのreject_status、およびRPCSEC_GSS_LABEL_PROBLEMのauth_statとラベルの主張を拒否します。"
    },
    {
      "indent": 0,
      "text": "2.7.1.4. Structured Privilege Assertions",
      "section_title": true,
      "ja": "2.7.1.4。構造権限のアサーション"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS>",
      "ja": "<CODEが開始されます>"
    },
    {
      "indent": 6,
      "text": "///\n///  typedef opaque utf8string<>;   /* UTF-8 encoding */\n///  typedef utf8string utf8str_cs; /* Case-sensitive UTF-8 */\n///\n///  struct rgss3_privs {\n///          utf8str_cs      rp_name<>;\n///          opaque          rp_privilege<>;\n///  };",
      "raw": true
    },
    {
      "indent": 3,
      "text": "<CODE ENDS>",
      "ja": "<CODEはENDS>"
    },
    {
      "indent": 3,
      "text": "A structured privilege is a capability defined by a specific RPC application. To support the assertion of this privilege, by a client using the application, in a server that also supports the application, the application may define a private data structure that is understood by clients and servers implementing the RPC application.",
      "ja": "構造権限は、特定のRPCアプリケーションによって定義された機能です。この特権の主張をサポートするために、アプリケーションを使用して、クライアントによって、また、アプリケーションをサポートするサーバーでは、アプリケーションがクライアントとRPCアプリケーションを実装したサーバに理解されているプラ​​イベートデータ構造を定義することもできます。"
    },
    {
      "indent": 3,
      "text": "RPCSEC_GSSv3 clients MAY assert a structured privilege by binding the privilege to the RPCSEC_GSSv3 context handle. This is done by including an assertion of type rgss3_privs in the RPCSEC_GSS_CREATE rgss3_create_args rca_assertions call data.",
      "ja": "RPCSEC_GSSv3クライアントはRPCSEC_GSSv3コンテキスト・ハンドルへの権限を結合することによって構造化特権を主張することができます。これはRPCSEC_GSS_CREATEのrgss3_create_args rca_assertions通話データにおける型rgss3_privsのアサーションを含むことによって行われます。"
    },
    {
      "indent": 3,
      "text": "The privilege is identified by the description string that is used by RPCSEC_GSSv3 to identify the privilege and communicate the private data between the relevant RPC application-specific code without needing to be aware of the details of the structure used. Thus, as far as RPCSEC_GSSv3 is concerned, the defined structure is passed between client and server as opaque data encoded in the rpc_gss3_privs rp_privilege field.",
      "ja": "特権が特権を識別し、使用される構造の詳細を意識する必要なく、関連するRPCアプリケーション固有コードとの間のプライベートなデータを通信するためにRPCSEC_GSSv3によって使用される記述文字列によって識別されます。したがって、限りRPCSEC_GSSv3が懸念しているように、定義された構造はrpc_gss3_privs rp_privilegeフィールドに符号化された不透明なデータとして、クライアントとサーバ間で渡されます。"
    },
    {
      "indent": 3,
      "text": "Encoding, server verification, and any server policies for structured privileges are described by the RPC application definition. The rp_name field of rpc_gss3_privs carries the description string used to identify and list the privilege. The utf8str_cs definition is from [RFC7530].",
      "ja": "構造化された権限のエンコード、サーバーの確認、および任意のサーバポリシーは、RPCアプリケーション定義によって記述されています。 rpc_gss3_privsのrp_nameフィールドには、特権を識別し、一覧表示するために使用する説明文字列を運びます。 utf8str_cs定義は[RFC7530]です。"
    },
    {
      "indent": 3,
      "text": "A successful structured privilege assertion MUST be enumerated in the rcr_assertions field of the rgss3_create_res RPCSEC_GSS_CREATE reply.",
      "ja": "成功した構造化特権アサーションはrgss3_create_resのRPCSEC_GSS_CREATE応答のrcr_assertionsフィールドに列挙されなければなりません。"
    },
    {
      "indent": 3,
      "text": "If a server receives a structured privilege assertion that it does not recognize, the assertion is rejected with a reply status of MSG_DENIED, a reject_status of AUTH_ERROR, and an auth_stat of RPCSEC_GSS_UNKNOWN_MESSAGE.",
      "ja": "サーバーが認識していないことを構造化された権限のアサーションを受信した場合、アサーションはMSG_DENIEDの返信状況、AUTH_ERRORのreject_status、およびRPCSEC_GSS_UNKNOWN_MESSAGEのauth_statで拒否されます。"
    },
    {
      "indent": 3,
      "text": "It is assumed that a client asserting more than one structured privilege to be bound to a context handle would not require all the privilege assertions to succeed.",
      "ja": "コンテキストハンドルにバインドするには、複数の構造化特権を主張し、クライアントが成功するためにすべての権限アサーションを必要としないことが想定されます。"
    },
    {
      "indent": 3,
      "text": "The server MUST NOT reject RPCSEC_GSS_CREATE requests containing supported structured privilege assertions, even if some of those assertions are rejected (e.g., for local policy reasons).",
      "ja": "サーバーは、これらのアサーションの一部は、（例えば、ローカルポリシー上の理由で）拒否された場合でも、サポート構造化された権限のアサーションを含むRPCSEC_GSS_CREATE要求を拒否してはなりません。"
    },
    {
      "indent": 3,
      "text": "If a server receives an RPCSEC_GSS_CREATE request containing one or more unsupported structured privilege assertions, the request MUST be rejected with a reply status of MSG_DENIED, a reject_status of AUTH_ERROR, and an auth_stat of RPCSEC_GSS_PRIVILEGE_PROBLEM.",
      "ja": "サーバーが1つまたは複数のサポートされていない構造化された権限のアサーションを含むRPCSEC_GSS_CREATE要求を受信した場合、要求はMSG_DENIEDの返信状況、AUTH_ERRORのreject_status、およびRPCSEC_GSS_PRIVILEGE_PROBLEMのauth_statを拒絶しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Section 4.9.1.1 of [RFC7862] (\"Inter-Server Copy via ONC RPC with RPCSEC_GSSv3\") shows an example of structured privilege definition and use.",
      "ja": "[RFC7862]（「RPCSEC_GSSv3とONC RPC経由でサーバ間コピー」）のセクション4.9.1.1は、構造権限の定義と使用例を示します。"
    },
    {
      "indent": 0,
      "text": "2.7.2. New Control Procedure - RPCSEC_GSS_LIST",
      "section_title": true,
      "ja": "2.7.2。新しい制御手順 -  RPCSEC_GSSのLIST"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS>",
      "ja": "<CODEが開始されます>"
    },
    {
      "indent": 6,
      "text": "///  enum rgss3_list_item {\n///          LABEL = 0,\n///          PRIVS = 1\n///  };\n///\n///  struct rgss3_list_args {\n///          rgss3_list_item      rla_list_what<>;\n///  };\n///\n///  union rgss3_list_item_u\n///        switch (rgss3_list_item itype) {\n///  case LABEL:\n///          rgss3_label          rli_labels<>;\n///  case PRIVS:\n///          rgss3_privs          rli_privs<>;\n///  default:\n///          opaque               rli_ext<>;\n///  };\n///\n///  typedef rgss3_list_item_u rgss3_list_res<>;\n///",
      "raw": true
    },
    {
      "indent": 3,
      "text": "<CODE ENDS>",
      "ja": "<CODEはENDS>"
    },
    {
      "indent": 3,
      "text": "The call data for an RPCSEC_GSS_LIST request consists of a list of integers (rla_list_what) indicating what assertions are to be listed, and the reply consists of an error or the requested list.",
      "ja": "RPCSEC_GSS_LIST要求の呼び出しデータがアサーションがリストされるものを表す整数（rla_list_what）のリストで構成され、応答は、エラーまたは要求されたリストから成ります。"
    },
    {
      "indent": 3,
      "text": "The result of requesting a list of rgss3_list_item LABEL objects is a list of LFSs supported by the server. The client can then use the LFS list to assert labels via the RPCSEC_GSS_CREATE label assertions. See Section 2.7.1.3.",
      "ja": "rgss3_list_item LABELオブジェクトのリストを要求した結果は、サーバでサポートされているLFSsのリストです。次に、クライアントはRPCSEC_GSS_CREATEラベルアサーションを経由してラベルを主張するLFSリストを使用することができます。セクション2.7.1.3を参照してください。"
    },
    {
      "indent": 0,
      "text": "2.8. Extensibility",
      "section_title": true,
      "ja": "2.8。拡張性"
    },
    {
      "indent": 3,
      "text": "Assertion types may be added in the future by adding arms to the \"rgss3_assertion_u\" union (Section 2.7.1) and the \"rgss3_list_item_u\" union (Section 2.7.2). Examples of other potential assertion types include:",
      "ja": "アサーションの種類は「rgss3_assertion_u」組合（セクション2.7.1）と「rgss3_list_item_u」労働組合（第2.7.2項）に武器を追加することにより、将来的に追加することができます。他の潜在的なアサーションタイプの例は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "o Client-side assertions of identity:",
      "ja": "アイデンティティのクライアント側のアサーションO："
    },
    {
      "indent": 6,
      "text": "* Primary client/user identity.",
      "ja": "*主なクライアント/ユーザアイデンティティ。"
    },
    {
      "indent": 6,
      "text": "* Supplementary group memberships of the client/user, including support for specifying deltas to the membership list as seen on the server.",
      "ja": "*サーバー上で見られるように、メンバーシップリストにデルタを指定するためのサポートを含むクライアント/ユーザー、の補足グループメンバーシップ。"
    },
    {
      "indent": 0,
      "text": "3. Operational Recommendation for Deployment",
      "section_title": true,
      "ja": "展開3.運用勧告"
    },
    {
      "indent": 3,
      "text": "RPCSEC_GSSv3 is a superset of RPCSEC_GSSv2 [RFC5403], which in turn is a superset of RPCSEC_GSSv1 [RFC2203], and so can be used in all situations where RPCSEC_GSSv2 is used, or where RPCSEC_GSSv1 is used and channel-bindings functionality is not needed. RPCSEC_GSSv3 should be used when the new functionality is needed.",
      "ja": "RPCSEC_GSSv3は、順番にRPCSEC_GSSv1のスーパーセットである[RFC5403]、[RFC2203] RPCSEC_GSSv2のスーパーセットであるのでRPCSEC_GSSv2が使用されているすべての状況で使用することができ、又はRPCSEC_GSSv1が使用され、チャネル・バインディング機能が必要ない場合。新しい機能が必要な場合RPCSEC_GSSv3を使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "4. Security Considerations",
      "section_title": true,
      "ja": "4.セキュリティについての考慮事項"
    },
    {
      "indent": 3,
      "text": "This entire document deals with security issues.",
      "ja": "この文書全体では、セキュリティ上の問題を扱っています。"
    },
    {
      "indent": 3,
      "text": "The RPCSEC_GSSv3 protocol allows for client-side assertions of data that is relevant to server-side authorization decisions. These assertions must be evaluated by the server in the context of whether the client and/or user are authenticated, whether multi-principal authentication was used, whether the client is trusted, what ranges of assertions are allowed for the client and the user (separately or together), and any relevant server-side policy.",
      "ja": "RPCSEC_GSSv3プロトコルは、サーバー側の許可の決定に関連するデータのクライアント側の主張が可能になります。これらの表明は、クライアントおよび/またはユーザが認証されているかどうかの状況で、サーバーによって評価されなければならないマルチ元本認証は、クライアントが信頼されているかどうか、使用されたかどうか、どのようなアサーションの範囲は、個別に（クライアントとユーザーに許可されていますまたは一緒に）、および関連するサーバ側のポリシー。"
    },
    {
      "indent": 3,
      "text": "The security semantics of assertions carried by RPCSEC_GSSv3 are application protocol-specific.",
      "ja": "RPCSEC_GSSv3によって運ばれるアサーションのセキュリティセマンティクスは、アプリケーションプロトコル固有です。"
    },
    {
      "indent": 3,
      "text": "Note that RPCSEC_GSSv3 is not a complete solution for labeling: it conveys the labels of actors but not the labels of objects. RPC application protocols may require extending in order to carry object label information.",
      "ja": "RPCSEC_GSSv3ラベリングのための完全なソリューションではないことに注意してください：それは俳優のラベルではなく、オブジェクトのラベルを伝えます。 RPCアプリケーションプロトコルは、オブジェクトのラベル情報を運ぶために伸びる必要な場合があります。"
    },
    {
      "indent": 3,
      "text": "There may be interactions with NFSv4's callback security scheme and NFSv4.1's [RFC5661] GSS SSV (Secret State Verifier) mechanisms. Specifically, the NFSv4 callback scheme requires that the server initiate GSS-API security contexts, which does not work well in practice; in the context of client-side processes running as the same user but with different privileges and security labels, the NFSv4 callback security scheme seems particularly unlikely to work well. NFSv4.1 has the server use an existing, client-initiated RPCSEC_GSS context handle to protect server-initiated callback RPCs. The NFSv4.1 callback security scheme lacks all the problems of the NFSv4 scheme; however, it is important that the server pick an appropriate RPCSEC_GSS context handle to protect any callbacks. Specifically, it is important that the server use RPCSEC_GSS context handles that authenticate the client to protect any callbacks related to server state initiated by RPCs protected by RPCSEC_GSSv3 contexts.",
      "ja": "NFSv4のコールバックのセキュリティ方式とNFSv4.1の[RFC5661] GSS SSV（秘密国家検証）のメカニズムとの相互作用があるかもしれません。具体的には、NFSv4のコールバック方式は、サーバが実際にはうまく機能しない、GSS-APIのセキュリティコンテキストを開始することが必要です。同じユーザーとしてではなく別の権限とセキュリティラベルで実行しているクライアント側のプロセスのコンテキストで、NFSv4のコールバックのセキュリティ方式はうまく機能することは特にそうにありません。 NFSv4.1は、サーバ、サーバ起動コールバックRPCを保護するために、既存の、クライアントが開始したRPCSEC_GSSコンテキスト・ハンドルを使用しています。 NFSv4.1コールバックのセキュリティ方式は、NFSv4のスキームのすべての問題を欠い。しかし、サーバがコールバックを保護するために適切なRPCSEC_GSSコンテキスト・ハンドルを選ぶことが重要です。具体的には、サーバーの使用RPCSEC_GSSコンテキストはそれがRPCSEC_GSSv3コンテキストによって保護されたRPCによって開始され、サーバ状態に関連するコールバックを保護するためにクライアントを認証処理することが重要です。"
    },
    {
      "indent": 3,
      "text": "As described in Section 2.10.10 of [RFC5661], the client is permitted to associate multiple RPCSEC_GSS handles with a single SSV GSS context. RPCSEC_GSSv3 handles will work well with SSV in that the man-in-the-middle attacks described in Section 2.10.10 of [RFC5661] are solved by the new reply verifier (Section 2.3). Using an RPCSEC_GSSv3 handle backed by a GSS-SSV mechanism context as a parent handle in an RPCSEC_GSS_CREATE call, while permitted, is complicated by the lifetime rules of SSV contexts and their associated RPCSEC_GSS handles.",
      "ja": "[RFC5661]のセクション2.10.10に記載されているように、クライアントは、複数のRPCSEC_GSSを関連付けるために許可されている単一SSV GSSコンテキストとハンドル。 [RFC5661]のセクション2.10.10に記載のman-in-the-middle攻撃が新たな応答ベリファイア（セクション2.3）によって解決されるという点でRPCSEC_GSSv3ハンドルがSSVとうまくいきます。許容しながら、RPCSEC_GSS_CREATE通話中の親ハンドルとしてGSS-SSV機構コンテキストによって裏付けRPCSEC_GSSv3ハンドルを使用して、SSVコンテキストおよびそれらに関連するRPCSEC_GSSハンドルの寿命規則によって複雑になります。"
    },
    {
      "indent": 0,
      "text": "5. IANA Considerations",
      "section_title": true,
      "ja": "5. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This section uses terms that are defined in [RFC5226].",
      "ja": "このセクションでは、[RFC5226]で定義される用語を使用します。"
    },
    {
      "indent": 0,
      "text": "5.1. New RPC Authentication Status Numbers",
      "section_title": true,
      "ja": "5.1。新しいRPC認証ステータス番号"
    },
    {
      "indent": 3,
      "text": "The following new RPC Authentication Status Numbers have been added to the IANA registry:",
      "ja": "次の新しいRPCの認証ステータス番号は、IANAレジストリに追加されました。"
    },
    {
      "indent": 3,
      "text": "o RPCSEC_GSS_INNER_CREDPROBLEM (15) \"No credentials for multi-principal assertion inner context user\". See Section 2.7.1.1.",
      "ja": "O RPCSEC_GSS_INNER_CREDPROBLEM（15）「マルチ主要アサーションコンテキスト内のユーザーの資格情報」。セクション2.7.1.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "o RPCSEC_GSS_LABEL_PROBLEM (16) \"Problem with label assertion\". See Section 2.7.1.3.",
      "ja": "OのRPCSEC_GSS_LABEL_PROBLEM（16） \"ラベルアサーションを通報します\"。セクション2.7.1.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "o RPCSEC_GSS_PRIVILEGE_PROBLEM (17) \"Problem with structured privilege assertion\". See Section 2.7.1.4.",
      "ja": "O RPCSEC_GSS_PRIVILEGE_PROBLEM（17） \"構造化された権限のアサーションを通報します\"。セクション2.7.1.4を参照してください。"
    },
    {
      "indent": 3,
      "text": "o RPCSEC_GSS_UNKNOWN_MESSAGE (18) \"Unknown structured privilege assertion\". See Section 2.7.1.4.",
      "ja": "O RPCSEC_GSS_UNKNOWN_MESSAGE（18） \"未知の構造特権アサーション\"。セクション2.7.1.4を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.2. Structured Privilege Name Definitions",
      "section_title": true,
      "ja": "5.2。構造権限名の定義"
    },
    {
      "indent": 3,
      "text": "IANA has created a registry called the \"RPCSEC_GSS Structured Privilege Names Registry\".",
      "ja": "IANAは、「RPCSEC_GSS構造特権名レジストリ」と呼ばれるレジストリを作成しました。"
    },
    {
      "indent": 3,
      "text": "Structured privilege assertions (Section 2.7.1.4) are defined by a specific RPC application. The namespace identifiers for these assertions (the rp_name) are defined as string names. The RPCSEC_GSSv3 protocol does not define the specific assignment of the namespace for these structured privilege assertion names. The IANA registry promotes interoperability where common interests exist. While RPC application developers are allowed to define and use structured privileges as needed, they are encouraged to register structured privilege assertion names with IANA.",
      "ja": "構造化特権アサーション（セクション2.7.1.4）は、特定のRPCアプリケーションによって定義されています。これらのアサーション（rp_name）の名前空間識別子は、文字列名として定義されています。 RPCSEC_GSSv3プロトコルは、これらの構造化特権アサーション名の名前空間の特定の割り当てを定義していません。 IANAレジストリは共通の利益が存在し、相互運用性を促進します。 RPCアプリケーション開発者は、必要に応じて構造化された権限を定義し、使用することを許可されているが、それらは、IANAで構造化された権限のアサーション名を登録することが奨励されています。"
    },
    {
      "indent": 3,
      "text": "The registry is to be maintained using the Standards Action policy as defined in Section 4.1 of [RFC5226].",
      "ja": "レジストリは、[RFC5226]のセクション4.1で定義されるように標準アクションポリシーを使用して維持されるべきです。"
    },
    {
      "indent": 3,
      "text": "Under the RPCSEC_GSS version 3 specification, the name of a structured privilege can in theory be up to 2^32 - 1 bytes in length, but in practice RPC application clients and servers will be unable to handle a string that long. IANA should reject any assignment request with a structured privilege name that exceeds 128 UTF-8 characters. To give the IESG the flexibility to set up bases of assignment of Experimental Use, the prefix \"EXPE\" is Reserved. The structured privilege with a zero-length name is Reserved.",
      "ja": "長さは1バイトで、実際には、RPCアプリケーションのクライアントとサーバは長く、その文字列を処理することができません -  RPCSEC_GSSのバージョン3仕様では、構造化特権の名前は、理論的には、最大2 ^ 32することができます。 IANAは128 UTF-8文字を超える構造化された権限名を持つ任意の割り当て要求を拒否しなければなりません。 IESGに実験的な使用の割り当ての拠点を設置するための柔軟性を与えるために、接頭辞「EXPEは、」予約されています。ゼロ長の名を持つ構造権限が予約されています。"
    },
    {
      "indent": 3,
      "text": "The prefix \"PRIV\" is allocated for Private Use. A site that wants to make use of unregistered named attributes without risk of conflicting with an assignment in IANA's registry should use the prefix \"PRIV\" in all of its structured privilege assertion names.",
      "ja": "接頭辞「PRIVは、」私的使用のために割り当てられています。その構造特権アサーション名のすべてに接頭辞「PRIV」を使用する必要がありIANAのレジストリに割り当てと競合する危険なしに未登録の名前の属性を利用することを望んでいるサイト。"
    },
    {
      "indent": 3,
      "text": "Because some RPC application clients and servers have case-insensitive semantics, the fifteen additional lower-case and mixed-case permutations of each of \"EXPE\" and \"PRIV\" are Reserved (e.g., \"expe\", \"expE\", and \"exPe\" are Reserved). Similarly, IANA must not allow two assignments that would conflict if both structured privilege names were converted to a common case.",
      "ja": "いくつかのRPCアプリケーションのクライアントとサーバは、大文字と小文字を区別しない意味を持っているので、「EXPE」と「PRIV」のそれぞれの15追加の小文字と大文字小文字混在の順列（例えば、「EXPE」、「EXPE」、および「EXPEを予約されています\"）に予約されています。同様に、IANAは、両方の構造化された特権名は一般的なケースに変換した場合は競合する2つの割り当てを許可してはいけません。"
    },
    {
      "indent": 3,
      "text": "The registry of structured privilege names is a list of assignments, each containing three fields for each assignment.",
      "ja": "構造化特権名のレジストリは、各割り当てについて、各含む3つのフィールド割り当てのリストです。"
    },
    {
      "indent": 3,
      "text": "1. A US-ASCII string name that is the actual name of the structured privilege. This name must be unique. This string name can be 1 to 128 UTF-8 characters long.",
      "ja": "構造化された権限の実際の名前です。1. A US-ASCII文字列名。この名前は一意である必要があります。この文字列名は1〜128 UTF-8文字の長さにすることができます。"
    },
    {
      "indent": 3,
      "text": "2. A reference to the specification of the RPC-application-defined structured privilege. The reference can consume up to 256 bytes (or more if IANA permits).",
      "ja": "2. RPCアプリケーション定義の構造特権の仕様を参照します。 （IANAが許可されている場合、またはそれ以上）の参照は、256のバイトまで消費することができます。"
    },
    {
      "indent": 3,
      "text": "3. The point of contact of the registrant. The point of contact can consume up to 256 bytes (or more if IANA permits).",
      "ja": "3.登録者の接触点。 （IANAが許可されている場合、またはそれ以上）の接触点は、256のバイトまで消費することができます。"
    },
    {
      "indent": 0,
      "text": "5.2.1. Initial Registry",
      "section_title": true,
      "ja": "5.2.1。初期のレジストリ"
    },
    {
      "indent": 3,
      "text": "The initial registry consists of the three structured privileges defined in [RFC7862].",
      "ja": "初期登録は[RFC7862]で定義された3人の構造の特権で構成されています。"
    },
    {
      "indent": 3,
      "text": "1. NAME: copy_to_auth, REFERENCE: RFC 7862, CONTACT: William A.(Andy) Adamson, andros@netapp.com",
      "ja": "1. NAME：copy_to_auth参照：RFC 7862、CONTACT：ウィリアムA.（アンディ）アダムソン、andros@netapp.com"
    },
    {
      "indent": 3,
      "text": "2. NAME: copy_from_auth, REFERENCE: RFC 7862, CONTACT: William A.(Andy) Adamson, andros@netapp.com",
      "ja": "2. NAME：copy_from_auth参照：RFC 7862、CONTACT：ウィリアムA.（アンディ）アダムソン、andros@netapp.com"
    },
    {
      "indent": 3,
      "text": "3. NAME: copy_confirm_auth, REFERENCE: RFC 7862, CONTACT: William A.(Andy) Adamson, andros@netapp.com",
      "ja": "3. NAME：copy_confirm_auth参照：RFC 7862、CONTACT：ウィリアムA.（アンディ）アダムソン、andros@netapp.com"
    },
    {
      "indent": 0,
      "text": "5.2.2. Updating Registrations",
      "section_title": true,
      "ja": "5.2.2。登録の更新"
    },
    {
      "indent": 3,
      "text": "The registrant is always permitted to update the point of contact field. To make any other change will require Expert Review or IESG Approval.",
      "ja": "登録者は、常に連絡先フィールドのポイントを更新することが許可されています。その他の変更を行うには、専門家のレビューやIESGの承認が必要になります。"
    },
    {
      "indent": 0,
      "text": "6. References",
      "section_title": true,
      "ja": "6.参照"
    },
    {
      "indent": 0,
      "text": "6.1. Normative References",
      "section_title": true,
      "ja": "6.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<http://www.rfc-editor.org/info/ RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC2203] Eisler, M., Chiu, A., and L. Ling, \"RPCSEC_GSS Protocol Specification\", RFC 2203, DOI 10.17487/RFC2203, September 1997, <http://www.rfc-editor.org/info/rfc2203>.",
      "ja": "[RFC2203]アイスラー、M.、チウ、A.、およびL.リン、 \"RPCSEC_GSSプロトコル仕様\"、RFC 2203、DOI 10.17487 / RFC2203、1997年9月、<http://www.rfc-editor.org/info/ rfc2203>。"
    },
    {
      "indent": 3,
      "text": "[RFC2743] Linn, J., \"Generic Security Service Application Program Interface Version 2, Update 1\", RFC 2743, DOI 10.17487/RFC2743, January 2000, <http://www.rfc-editor.org/info/rfc2743>.",
      "ja": "[RFC2743]リン、J.、 \"ジェネリックセキュリティーサービス適用業務プログラムインタフェースバージョン2、アップデート1\"、RFC 2743、DOI 10.17487 / RFC2743、2000年1月、<http://www.rfc-editor.org/info/rfc2743> 。"
    },
    {
      "indent": 3,
      "text": "[RFC4506] Eisler, M., Ed., \"XDR: External Data Representation Standard\", STD 67, RFC 4506, DOI 10.17487/RFC4506, May 2006, <http://www.rfc-editor.org/info/rfc4506>.",
      "ja": "[RFC4506]アイスラー、M.、エド、 \"XDR：外部データ表現標準\"。、STD 67、RFC 4506、DOI 10.17487 / RFC4506、2006年5月、<http://www.rfc-editor.org/info/rfc4506 >。"
    },
    {
      "indent": 3,
      "text": "[RFC5056] Williams, N., \"On the Use of Channel Bindings to Secure Channels\", RFC 5056, DOI 10.17487/RFC5056, November 2007, <http://www.rfc-editor.org/info/rfc5056>.",
      "ja": "\"チャネルを確保するチャネルバインディングの使用について\" [RFC5056]ウィリアムズ、N.、RFC 5056、DOI 10.17487 / RFC5056、2007年11月、<http://www.rfc-editor.org/info/rfc5056>。"
    },
    {
      "indent": 3,
      "text": "[RFC5403] Eisler, M., \"RPCSEC_GSS Version 2\", RFC 5403, DOI 10.17487/RFC5403, February 2009, <http://www.rfc-editor.org/info/rfc5403>.",
      "ja": "[RFC5403]アイスラー、M.、 \"RPCSEC_GSSバージョン2\"、RFC 5403、DOI 10.17487 / RFC5403、2009年2月、<http://www.rfc-editor.org/info/rfc5403>。"
    },
    {
      "indent": 3,
      "text": "[RFC5661] Shepler, S., Ed., Eisler, M., Ed., and D. Noveck, Ed., \"Network File System (NFS) Version 4 Minor Version 1 Protocol\", RFC 5661, DOI 10.17487/RFC5661, January 2010, <http://www.rfc-editor.org/info/rfc5661>.",
      "ja": "[RFC5661] Shepler、S.編、アイスラー、M.、編、及びD. Noveck編、 \"ネットワークファイルシステム（NFS）バージョン4マイナーバージョン1つのプロトコル\"、RFC 5661、DOI 10.17487 / RFC5661、 2010年1月、<http://www.rfc-editor.org/info/rfc5661>。"
    },
    {
      "indent": 3,
      "text": "[RFC7530] Haynes, T., Ed., and D. Noveck, Ed., \"Network File System (NFS) Version 4 Protocol\", RFC 7530, DOI 10.17487/RFC7530, March 2015, <http://www.rfc-editor.org/info/rfc7530>.",
      "ja": "[RFC7530]ヘインズ、T.、エド、およびD. Noveck、エド、 \"ネットワークファイルシステム（NFS）バージョン4プロトコル\"、RFC 7530、DOI 10.17487 / RFC7530、2015年3月、<のhttp：。。//www.rfc -editor.org/info/rfc7530>。"
    },
    {
      "indent": 3,
      "text": "[RFC7862] Haynes, T., \"Network File System (NFS) Version 4 Minor Version 2 Protocol\", RFC 7862, DOI 10.17487/RFC7862, November 2016, <http://www.rfc-editor.org/info/rfc7862>.",
      "ja": "[RFC7862]ヘインズ、T.、 \"ネットワークファイルシステム（NFS）バージョン4マイナーバージョン2プロトコル\"、RFC 7862、DOI 10.17487 / RFC7862、2016年11月、<http://www.rfc-editor.org/info/rfc7862 >。"
    },
    {
      "indent": 0,
      "text": "6.2. Informative References",
      "section_title": true,
      "ja": "6.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[AFS-RXGK] Wilkinson, S. and B. Kaduk, \"Integrating rxgk with AFS\", Work in Progress, draft-wilkinson-afs3-rxgk-afs-08, May 2015.",
      "ja": "\"AFSでrxgk統合\" [AFS-RXGK]ウィルキンソン、S.及びB. Kaduk、進行中で働いて、ドラフト・ウィルキンソン-afs3-rxgk-AFS-08、2015年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC4949] Shirey, R., \"Internet Security Glossary, Version 2\", FYI 36, RFC 4949, DOI 10.17487/RFC4949, August 2007, <http://www.rfc-editor.org/info/rfc4949>.",
      "ja": "[RFC4949] Shirey、R.、 \"インターネットセキュリティ用語集、バージョン2\"、FYI 36、RFC 4949、DOI 10.17487 / RFC4949、2007年8月、<http://www.rfc-editor.org/info/rfc4949>。"
    },
    {
      "indent": 3,
      "text": "[RFC5226] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 5226, DOI 10.17487/RFC5226, May 2008, <http://www.rfc-editor.org/info/rfc5226>.",
      "ja": "[RFC5226] Narten氏、T.とH. Alvestrand、 \"RFCsにIANA問題部に書くためのガイドライン\"、BCP 26、RFC 5226、DOI 10.17487 / RFC5226、2008年5月、<http://www.rfc-editor.org /情報/ RFC5226>。"
    },
    {
      "indent": 3,
      "text": "[RFC5531] Thurlow, R., \"RPC: Remote Procedure Call Protocol Specification Version 2\", RFC 5531, DOI 10.17487/RFC5531, May 2009, <http://www.rfc-editor.org/info/rfc5531>.",
      "ja": "[RFC5531] Thurlow、R.、 \"RPC：リモートプロシージャコールプロトコル仕様バージョン2\"、RFC 5531、DOI 10.17487 / RFC5531、2009年5月、<http://www.rfc-editor.org/info/rfc5531>。"
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Andy Adamson would like to thank NetApp, Inc. for its funding of his time on this project.",
      "ja": "アンディ・アダムソンは、このプロジェクトの自分の時間の資金調達のためのNetApp、Inc.に感謝したいと思います。"
    },
    {
      "indent": 3,
      "text": "We thank Lars Eggert, Mike Eisler, Ben Kaduk, Bruce Fields, Tom Haynes, and Dave Noveck for their most helpful reviews.",
      "ja": "私たちは、彼らの最も参考になったレビューのためにラースエッゲルト、マイク・アイスラー、ベンKaduk、ブルース・フィールド、トム・ヘインズ、とDave Noveckに感謝します。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "William A. (Andy) Adamson NetApp 3629 Wagner Ridge Ct. Ann Arbor, MI 48103 United States of America",
      "ja": "ウィリアムA.（アンディ）アダムソンNetAppの3629ワグナーリッジのCt。アナーバー、ミシガンアメリカの48103米国"
    },
    {
      "indent": 3,
      "text": "Phone: +1 734 665 1204 Email: andros@netapp.com",
      "ja": "電話：+1 734 665 1204 Eメール：andros@netapp.com"
    },
    {
      "indent": 3,
      "text": "Nico Williams cryptonector.com 13115 Tamayo Dr. Austin, TX 78729 United States of America",
      "ja": "ニコ・ウィリアムズcryptonector.com 13115タマヨ博士はテキサス州オースティンアメリカの78729米国"
    },
    {
      "indent": 3,
      "text": "Email: nico@cryptonector.com",
      "ja": "メール：nico@cryptonector.com"
    }
  ]
}