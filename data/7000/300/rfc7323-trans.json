{
  "title": {
    "text": "RFC 7323 - TCP Extensions for High Performance",
    "ja": "RFC 7323 - ハイパフォーマンスのためのTCP拡張機能"
  },
  "number": 7323,
  "created_at": "2019-10-31 17:06:20.915479+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                         D. Borman\nRequest for Comments: 7323                           Quantum Corporation\nObsoletes: 1323                                                B. Braden\nCategory: Standards Track              University of Southern California\nISSN: 2070-1721                                              V. Jacobson\n                                                            Google, Inc.\n                                                   R. Scheffenegger, Ed.\n                                                            NetApp, Inc.\n                                                          September 2014",
      "raw": true
    },
    {
      "indent": 18,
      "text": "TCP Extensions for High Performance",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document specifies a set of TCP extensions to improve performance over paths with a large bandwidth * delay product and to provide reliable operation over very high-speed paths. It defines the TCP Window Scale (WS) option and the TCP Timestamps (TS) option and their semantics. The Window Scale option is used to support larger receive windows, while the Timestamps option can be used for at least two distinct mechanisms, Protection Against Wrapped Sequences (PAWS) and Round-Trip Time Measurement (RTTM), that are also described herein.",
      "ja": "この文書では、大きな帯域幅*遅れ製品でパスを超えるパフォーマンスを向上させるために、非常に高速な経路を介して信頼性の高い動作を提供するために、TCPの拡張機能のセットを指定します。これは、TCPウィンドウスケール（WS）オプションおよびTCPタイムスタンプ（TS）オプションとそれらの意味を定義します。タイムスタンプオプションは、少なくとも2つの別個のメカニズムを使用することができるがウィンドウスケールオプションは、ウィンドウを受け取る大きなサポートするために使用され、また、本明細書に記載されているに対する保護ラップ配列（PAWS）および往復時間測定（RTTM）。"
    },
    {
      "indent": 3,
      "text": "This document obsoletes RFC 1323 and describes changes from it.",
      "ja": "この文書はRFC 1323を廃止し、それからの変更点について説明します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 5741のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7323.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7323で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2014 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2014 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   4\n  1.1.  TCP Performance . . . . . . . . . . . . . . . . . . . . .   4\n  1.2.  TCP Reliability . . . . . . . . . . . . . . . . . . . . .   5\n  1.3.  Using TCP options . . . . . . . . . . . . . . . . . . . .   6\n  1.4.  Terminology . . . . . . . . . . . . . . . . . . . . . . .   7\n2.  TCP Window Scale Option . . . . . . . . . . . . . . . . . . .   8\n  2.1.  Introduction  . . . . . . . . . . . . . . . . . . . . . .   8\n  2.2.  Window Scale Option . . . . . . . . . . . . . . . . . . .   8\n  2.3.  Using the Window Scale Option . . . . . . . . . . . . . .   9\n  2.4.  Addressing Window Retraction  . . . . . . . . . . . . . .  10\n3.  TCP Timestamps Option . . . . . . . . . . . . . . . . . . . .  11\n  3.1.  Introduction  . . . . . . . . . . . . . . . . . . . . . .  11\n  3.2.  Timestamps Option . . . . . . . . . . . . . . . . . . . .  12\n4.  The RTTM Mechanism  . . . . . . . . . . . . . . . . . . . . .  14\n  4.1.  Introduction  . . . . . . . . . . . . . . . . . . . . . .  14\n  4.2.  Updating the RTO Value  . . . . . . . . . . . . . . . . .  15\n  4.3.  Which Timestamp to Echo . . . . . . . . . . . . . . . . .  16\n5.  PAWS - Protection Against Wrapped Sequences . . . . . . . . .  19\n  5.1.  Introduction  . . . . . . . . . . . . . . . . . . . . . .  19\n  5.2.  The PAWS Mechanism  . . . . . . . . . . . . . . . . . . .  19\n  5.3.  Basic PAWS Algorithm  . . . . . . . . . . . . . . . . . .  20\n  5.4.  Timestamp Clock . . . . . . . . . . . . . . . . . . . . .  22\n  5.5.  Outdated Timestamps . . . . . . . . . . . . . . . . . . .  24\n  5.6.  Header Prediction . . . . . . . . . . . . . . . . . . . .  25\n  5.7.  IP Fragmentation  . . . . . . . . . . . . . . . . . . . .  26\n  5.8.  Duplicates from Earlier Incarnations of Connection  . . .  26\n6.  Conclusions and Acknowledgments . . . . . . . . . . . . . . .  27\n7.  Security Considerations . . . . . . . . . . . . . . . . . . .  27\n  7.1.  Privacy Considerations  . . . . . . . . . . . . . . . . .  29\n8.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  29\n9.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  30\n  9.1.  Normative References  . . . . . . . . . . . . . . . . . .  30\n  9.2.  Informative References  . . . . . . . . . . . . . . . . .  30\nAppendix A.  Implementation Suggestions . . . . . . . . . . . . .  34\nAppendix B.  Duplicates from Earlier Connection Incarnations  . .  35\n  B.1.  System Crash with Loss of State . . . . . . . . . . . . .  35\n  B.2.  Closing and Reopening a Connection  . . . . . . . . . . .  35\nAppendix C.  Summary of Notation  . . . . . . . . . . . . . . . .  37\nAppendix D.  Event Processing Summary . . . . . . . . . . . . . .  38\nAppendix E.  Timestamps Edge Cases  . . . . . . . . . . . . . . .  44\nAppendix F.  Window Retraction Example  . . . . . . . . . . . . .  44\nAppendix G.  RTO Calculation Modification . . . . . . . . . . . .  45\nAppendix H.  Changes from RFC 1323  . . . . . . . . . . . . . . .  46",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "The TCP protocol [RFC0793] was designed to operate reliably over almost any transmission medium regardless of transmission rate, delay, corruption, duplication, or reordering of segments. Over the years, advances in networking technology have resulted in ever-higher transmission speeds, and the fastest paths are well beyond the domain for which TCP was originally engineered.",
      "ja": "TCPプロトコル[RFC0793]は、ほぼすべての伝送媒体に関係なく、伝送レート、遅延、破損、複製、またはセグメントの並べ替えの確実にわたって動作するように設計されました。長年にわたり、ネットワーク技術の進歩は、ますます高い伝送速度をもたらしている、と最速のパスは、TCPが最初に設計されたため、ドメインをはるかに超えています。"
    },
    {
      "indent": 3,
      "text": "This document defines a set of modest extensions to TCP to extend the domain of its application to match the increasing network capability. It is an update to and obsoletes [RFC1323], which in turn is based upon and obsoletes [RFC1072] and [RFC1185].",
      "ja": "この文書では、増加ネットワーク機能と一致するように、そのアプリケーションのドメインを拡張するためにTCPにささやかな拡張セットを定義します。それは、順番に基づいている[RFC1323]、および時代遅れ[RFC1072]及び[RFC1185]および時代遅れの更新です。"
    },
    {
      "indent": 3,
      "text": "Changes between [RFC1323] and this document are detailed in Appendix H. These changes are partly due to errata in [RFC1323], and partly due to the improved understanding of how the involved components interact.",
      "ja": "[RFC1323]とこのドキュメント間の変更は、これらの変更は、部分的に[RFC1323]で正誤表に、かつ部分的に関与コンポーネントがどのように相互作用するかの理解向上に起因している付録H.に詳述されています。"
    },
    {
      "indent": 3,
      "text": "For brevity, the full discussions of the merits and history behind the TCP options defined within this document have been omitted. [RFC1323] should be consulted for reference. It is recommended that a modern TCP stack implements and make use of the extensions described in this document.",
      "ja": "簡潔にするために、このドキュメント内で定義されたTCPオプションの後ろのメリットと歴史の完全な議論が省略されています。 [RFC1323]は、参照のために相談すべきです。これは、近代的なTCPスタックを実装することを推奨し、この文書で説明した拡張機能を利用することです。"
    },
    {
      "indent": 0,
      "text": "1.1. TCP Performance",
      "section_title": true,
      "ja": "1.1。 TCPの性能"
    },
    {
      "indent": 3,
      "text": "TCP performance problems arise when the bandwidth * delay product is large. A network having such paths is referred to as a \"long, fat network\" (LFN).",
      "ja": "帯域幅*遅延積が大きい場合、TCPのパフォーマンスの問題が発生します。そのような経路を有するネットワークが「長い、脂肪ネットワーク」（LFN）と呼ばれます。"
    },
    {
      "indent": 3,
      "text": "There are two fundamental performance problems with basic TCP over LFN paths:",
      "ja": "LFNパスを超える基本的なTCPを持つ2つの基本的なパフォーマンスの問題があります。"
    },
    {
      "indent": 3,
      "text": "(1) Window Size Limit",
      "ja": "（1）ウィンドウサイズ制限"
    },
    {
      "indent": 8,
      "text": "The TCP header uses a 16-bit field to report the receive window\nsize to the sender.  Therefore, the largest window that can be\nused is 2^16 = 64 KiB.  For LFN paths where the bandwidth *\ndelay product exceeds 64 KiB, the receive window limits the\nmaximum throughput of the TCP connection over the path, i.e.,\nthe amount of unacknowledged data that TCP can send in order to\nkeep the pipeline full.",
      "raw": true
    },
    {
      "indent": 8,
      "text": "To circumvent this problem, Section 2 of this memo defines a TCP option, \"Window Scale\", to allow windows larger than 2^16. This option defines an implicit scale factor, which is used to multiply the window size value found in a TCP header to obtain the true window size.",
      "ja": "この問題を回避するには、このメモのセクション2は2 ^ 16よりも窓を大きくできるようにするTCPオプション、「ウィンドウスケール」を、定義されています。このオプションは、真のウィンドウサイズを得るために、TCPヘッダに見出されるウィンドウサイズの値を乗算するために使用される暗黙的なスケールファクタを定義します。"
    },
    {
      "indent": 8,
      "text": "It must be noted that the use of large receive windows increases the chance of too quickly wrapping sequence numbers, as described below in Section 1.2, (1).",
      "ja": "大規模の使用は、1.2節で後述するように、あまりにも早く包むシーケンス番号のチャンスを高める窓を受けることに留意しなければならない（1）。"
    },
    {
      "indent": 3,
      "text": "(2) Recovery from Losses",
      "ja": "（2）損失からの回復を"
    },
    {
      "indent": 8,
      "text": "Packet losses in an LFN can have a catastrophic effect on\nthroughput.",
      "raw": true
    },
    {
      "indent": 8,
      "text": "To generalize the Fast Retransmit / Fast Recovery mechanism to handle multiple packets dropped per window, Selective Acknowledgments are required. Unlike the normal cumulative acknowledgments of TCP, Selective Acknowledgments give the sender a complete picture of which segments are queued at the receiver and which have not yet arrived.",
      "ja": "複数のパケットは、ウィンドウごとにドロップ処理するための高速再送/高速リカバリメカニズムを一般化するには、選択的な謝辞が必要とされています。 TCPの正規累積確認応答とは異なり、選択謝辞は、送信者に、セグメントが受信機にキューイングされているのと、まだ到着していないその全体像を与えます。"
    },
    {
      "indent": 8,
      "text": "Selective Acknowledgments and their use are specified in separate documents, \"TCP Selective Acknowledgment Options\" [RFC2018], \"An Extension to the Selective Acknowledgement (SACK) Option for TCP\" [RFC2883], and \"A Conservative Loss Recovery Algorithm Based on Selective Acknowledgment (SACK) for TCP\" [RFC6675], and are not further discussed in this document.",
      "ja": "選択謝辞およびその使用は別の文書で指定されている、「TCP選択確認応答オプション」[RFC2018]、「TCPのための選択確認応答（SACK）オプションの拡張」[RFC2883]、および「保守的な損失回復アルゴリズム選択確認応答に基づいて、 TCP用（SACK）」[RFC6675]、さらに本書では説明しません。"
    },
    {
      "indent": 0,
      "text": "1.2. TCP Reliability",
      "section_title": true,
      "ja": "1.2。 TCPの信頼性"
    },
    {
      "indent": 3,
      "text": "An especially serious kind of error may result from an accidental reuse of TCP sequence numbers in data segments. TCP reliability depends upon the existence of a bound on the lifetime of a segment: the \"Maximum Segment Lifetime\" or MSL.",
      "ja": "エラーの特に深刻な種類は、データセグメント内のTCPシーケンス番号を誤って再利用から生じ得ます。 TCPの信頼性は、セグメントの寿命上の結合の存在に依存：「最大セグメント生涯」やMSLを。"
    },
    {
      "indent": 3,
      "text": "Duplication of sequence numbers might happen in either of two ways:",
      "ja": "シーケンス番号の重複は、2つの方法のいずれかで発生する可能性があります："
    },
    {
      "indent": 3,
      "text": "(1) Sequence number wrap-around on the current connection",
      "ja": "（1）シーケンス番号がラップアラウンド現在の接続に"
    },
    {
      "indent": 8,
      "text": "A TCP sequence number contains 32 bits.  At a high enough\ntransfer rate of large volumes of data (at least 4 GiB in the\nsame session), the 32-bit sequence space may be \"wrapped\"\n(cycled) within the time that a segment is delayed in queues.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "(2) Earlier incarnation of the connection",
      "ja": "（2）接続の以前の化身を"
    },
    {
      "indent": 8,
      "text": "Suppose that a connection terminates, either by a proper close\nsequence or due to a host crash, and the same connection (i.e.,\nusing the same pair of port numbers) is immediately reopened.  A\ndelayed segment from the terminated connection could fall within\nthe current window for the new incarnation and be accepted as\nvalid.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Duplicates from earlier incarnations, case (2), are avoided by enforcing the current fixed MSL of the TCP specification, as explained in Section 5.8 and Appendix B. In addition, the randomizing of ephemeral ports can also help to probabilistically reduce the chances of duplicates from earlier connections. However, case (1), avoiding the reuse of sequence numbers within the same connection, requires an upper bound on MSL that depends upon the transfer rate, and at high enough rates, a dedicated mechanism is required.",
      "ja": "また、5.8節および付録Bで説明したように、以前の化身、ケース（2）からの重複が、TCP仕様の現在の固定MSLを実施することによって回避され、エフェメラルポートのランダム化は、また、確率的重複の可能性を減らすのを助けることができます以前の接続から。しかし、ケース（1）は、同じ接続内のシーケンス番号の再利用を避け、転送レートに依存MSLの上限を必要とし、十分に高い速度で、専用の機構が必要となります。"
    },
    {
      "indent": 3,
      "text": "A possible fix for the problem of cycling the sequence space would be to increase the size of the TCP sequence number field. For example, the sequence number field (and also the acknowledgment field) could be expanded to 64 bits. This could be done either by changing the TCP header or by means of an additional option.",
      "ja": "系列スペースを循環の問題のための可能な修正は、TCPシーケンス番号フィールドのサイズを大きくすることであろう。例えば、シーケンス番号フィールド（および確認応答フィールド）が64ビットに拡張することができます。これは、TCPヘッダを変更するか、追加オプションによってどちらか行うことができます。"
    },
    {
      "indent": 3,
      "text": "Section 5 presents a different mechanism, which we call PAWS, to extend TCP reliability to transfer rates well beyond the foreseeable upper limit of network bandwidths. PAWS uses the TCP Timestamps option defined in Section 3.2 to protect against old duplicates from the same connection.",
      "ja": "第5節では、我々は、PAWSを呼び出すだけでなく、ネットワーク帯域幅の予見可能な上限を超えて速度を転送するためにTCPの信頼性を拡張するために別のメカニズムを提示します。 PAWSは同じ接続からの古い写しから保護するために、3.2節で定義されたTCPタイムスタンプオプションを使用しています。"
    },
    {
      "indent": 0,
      "text": "1.3. Using TCP options",
      "section_title": true,
      "ja": "1.3。 TCPオプションを使用します"
    },
    {
      "indent": 3,
      "text": "The extensions defined in this document all use TCP options.",
      "ja": "すべてこの文書で定義された拡張は、TCPオプションを使用します。"
    },
    {
      "indent": 3,
      "text": "When [RFC1323] was published, there was concern that some buggy TCP implementation might crash on the first appearance of an option on a non-<SYN> segment. However, bugs like that can lead to denial-of-service (DoS) attacks against a TCP. Research has shown that most TCP implementations will properly handle unknown options on non-<SYN> segments ([Medina04], [Medina05]). But it is still prudent to be conservative in what you send, and avoiding buggy TCP implementation is not the only reason for negotiating TCP options on <SYN> segments.",
      "ja": "[RFC1323]が出版されたときに、いくつかのバグのTCP実装は非<SYN>セグメント上のオプションの最初の出現にクラッシュする可能性があります懸念がありました。しかし、そのようなバグは、TCPに対するサービス拒否（DoS）攻撃につながることができます。研究は、ほとんどのTCPの実装が適切に非<SYN>セグメント（[Medina04]、[Medina05]）に未知のオプションを処理することが示されています。しかし、まだあなたが送信するもので保守的であることが賢明である、とバギーTCPの実装を回避することは、<SYN>セグメント上のTCPオプションを交渉するための唯一の理由ではありません。"
    },
    {
      "indent": 3,
      "text": "The Window Scale option negotiates fundamental parameters of the TCP session. Therefore, it is only sent during the initial handshake. Furthermore, the Window Scale option will be sent in a <SYN,ACK> segment only if the corresponding option was received in the initial <SYN> segment.",
      "ja": "ウィンドウスケールオプションは、TCPセッションの基本的なパラメータをネゴシエートします。そのため、それが唯一の初期ハンドシェイク中に送信されます。また、ウィンドウスケールオプションは、対応するオプションが初期<SYN>セグメントで受信された場合にのみ、<SYN、ACK>セグメントで送信されるであろう。"
    },
    {
      "indent": 3,
      "text": "The Timestamps option may appear in any data or <ACK> segment, adding 10 bytes (up to 12 bytes including padding) to the 20-byte TCP header. It is required that this TCP option will be sent on all non-<SYN> segments after an exchange of options on the <SYN> segments has indicated that both sides understand this extension.",
      "ja": "タイムスタンプオプションは、20バイトのTCPヘッダに10バイト（パディングを含む12バイトまで）を添加すること、任意のデータまたは<ACK>セグメントに表示されてもよいです。 <SYN>セグメントのオプションの交換は両側がこの拡張を理解することが示された後に、このTCPオプションは、すべての非<SYN>セグメントで送信されることが必要です。"
    },
    {
      "indent": 3,
      "text": "Research has shown that the use of the Timestamps option to take additional RTT samples within each RTT has little effect on the ultimate retransmission timeout value [Allman99]. However, there are other uses of the Timestamps option, such as the Eifel mechanism ([RFC3522], [RFC4015]) and PAWS (see Section 5), which improve overall TCP security and performance. The extra header bandwidth used by this option should be evaluated for the gains in performance and security in an actual deployment.",
      "ja": "研究では、タイムスタンプオプションを使用すると、各RTT以内に追加のRTTサンプルを取ることが示されている[Allman99]究極の再送タイムアウト値にほとんど影響を与えません。しかし、全体的なTCPのセキュリティとパフォーマンスを向上させるようなアイフェル機構（[RFC3522]、[RFC4015]）とPAWSとしてタイムスタンプ・オプションの他の用途は、（セクション5を参照）があります。このオプションで使用される追加のヘッダーの帯域幅は、実際の展開でのパフォーマンスとセキュリティの利益のために評価されるべきです。"
    },
    {
      "indent": 3,
      "text": "Appendix A contains a recommended layout of the options in TCP headers to achieve reasonable data field alignment.",
      "ja": "付録Aには、合理的なデータフィールドのアラインメントを達成するために、TCPヘッダ内のオプションの推奨レイアウトが含まれています。"
    },
    {
      "indent": 3,
      "text": "Finally, we observe that most of the mechanisms defined in this document are important for LFNs and/or very high-speed networks. For low-speed networks, it might be a performance optimization to NOT use these mechanisms. A TCP vendor concerned about optimal performance over low-speed paths might consider turning these extensions off for low-speed paths, or allow a user or installation manager to disable them.",
      "ja": "最後に、私たちは、この文書で定義されたメカニズムのほとんどはLFNsおよび/または非常に高速ネットワークのために重要であることを確認します。低速ネットワークの場合、これらのメカニズムを使用しないようにパフォーマンスを最適化するかもしれません。低速経路を介して、最適なパフォーマンスを懸念TCPベンダーは、低速パスにこれらの拡張機能をオフにすることを検討し、またはそれらを無効にするユーザーまたはインストールマネージャを許可するかもしれません。"
    },
    {
      "indent": 0,
      "text": "1.4. Terminology",
      "section_title": true,
      "ja": "1.4。用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はあります[RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 3,
      "text": "In this document, these words will appear with that interpretation only when in UPPER CASE. Lower case uses of these words are not to be interpreted as carrying [RFC2119] significance.",
      "ja": "この文書では、これらの言葉はときにのみ大文字でその解釈に表示されます。小文字は、[RFC2119]意味を運ぶものとして解釈されるべきではないこれらの言葉の使用します。"
    },
    {
      "indent": 0,
      "text": "2. TCP Window Scale Option",
      "section_title": true,
      "ja": "2. TCPウィンドウスケールオプション"
    },
    {
      "indent": 0,
      "text": "2.1. Introduction",
      "section_title": true,
      "ja": "2.1。前書き"
    },
    {
      "indent": 3,
      "text": "The window scale extension expands the definition of the TCP window to 30 bits and then uses an implicit scale factor to carry this 30-bit value in the 16-bit window field of the TCP header (SEG.WND in [RFC0793]). The exponent of the scale factor is carried in a TCP option, Window Scale. This option is sent only in a <SYN> segment (a segment with the SYN bit on), hence the window scale is fixed in each direction when a connection is opened.",
      "ja": "ウィンドウスケール拡張は、30ビットにTCPウィンドウの定義を拡張した後、TCPヘッダ（[RFC0793]でSEG.WND）の16ビットのウィンドウフィールドに、この30ビットの値を運ぶために、暗黙のスケールファクタを使用しています。スケール係数の指数は、TCPオプション、ウィンドウスケールで行われます。このオプションは、したがって、ウィンドウスケールは、接続が開かれる各方向に固定されている<SYN>セグメント（上のSYNビットを有するセグメント）で送信されます。"
    },
    {
      "indent": 3,
      "text": "The maximum receive window, and therefore the scale factor, is determined by the maximum receive buffer space. In a typical modern implementation, this maximum buffer space is set by default but can be overridden by a user program before a TCP connection is opened. This determines the scale factor, and therefore no new user interface is needed for window scaling.",
      "ja": "最大ウィンドウ、したがってスケールファクタを受信し、バッファスペースを受け取る最大ことによって決定されます。典型的な近代的な実装では、この最大バッファ・スペースは、デフォルトで設定されていますが、TCP接続が開かれる前に、ユーザプログラムで上書きすることができます。これは、スケールファクタを決定し、したがって、新しいユーザーインターフェイスは、ウィンドウスケーリングのために必要ありません。"
    },
    {
      "indent": 0,
      "text": "2.2. Window Scale Option",
      "section_title": true,
      "ja": "2.2。ウィンドウスケールオプション"
    },
    {
      "indent": 3,
      "text": "The three-byte Window Scale option MAY be sent in a <SYN> segment by a TCP. It has two purposes: (1) indicate that the TCP is prepared to both send and receive window scaling, and (2) communicate the exponent of a scale factor to be applied to its receive window. Thus, a TCP that is prepared to scale windows SHOULD send the option, even if its own scale factor is 1 and the exponent 0. The scale factor is limited to a power of two and encoded logarithmically, so it may be implemented by binary shift operations. The maximum scale exponent is limited to 14 for a maximum permissible receive window size of 1 GiB (2^(14+16)).",
      "ja": "3バイトのウィンドウスケールオプションはTCPで、<SYN>セグメントで送信することができます。 （1）TCPは、送信およびウィンドウスケーリングを受信し、（2）スケール係数の指数は、その受信ウィンドウに適用される通信の両方に用意されていることを示している：それは2つの目的を有しています。したがって、ウィンドウを拡張する準備がTCPは、独自のスケールファクタが1であり、指数0は、スケールファクタが2の累乗に制限され、対数符号化され、それは、バイナリシフトによって実現することができる場合であっても、オプションを送るべきですオペレーション。最大規模の指数は、1ジブの最大許容受信ウィンドウサイズのために14に制限され（2 ^（14 + 16））。"
    },
    {
      "indent": 3,
      "text": "TCP Window Scale option (WSopt):",
      "ja": "TCPウィンドウスケールオプション（WSopt）："
    },
    {
      "indent": 3,
      "text": "Kind: 3",
      "ja": "種類：3"
    },
    {
      "indent": 3,
      "text": "Length: 3 bytes",
      "ja": "長さ：3つのバイト"
    },
    {
      "indent": 10,
      "text": "+---------+---------+---------+\n| Kind=3  |Length=3 |shift.cnt|\n+---------+---------+---------+\n     1         1         1",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This option is an offer, not a promise; both sides MUST send Window Scale options in their <SYN> segments to enable window scaling in either direction. If window scaling is enabled, then the TCP that sent this option will right-shift its true receive-window values by 'shift.cnt' bits for transmission in SEG.WND. The value 'shift.cnt'",
      "ja": "このオプションは提供、ない約束です。両側はいずれの方向にウィンドウスケーリングを可能にするために、それらの<SYN>セグメントにウィンドウスケールオプションを送らなければなりません。ウィンドウスケーリングが有効になっている場合は、このオプションを送られたTCPは、SEG.WNDでの伝送のための「shift.cnt」ビットによって、その真の受信ウィンドウ値を右シフトします。値「shift.cnt」"
    },
    {
      "indent": 3,
      "text": "MAY be zero (offering to scale, while applying a scale factor of 1 to the receive window).",
      "ja": "（受信ウィンドウ1のスケールファクタを適用しながら、一定の縮尺で提供）0であってもよいです。"
    },
    {
      "indent": 3,
      "text": "This option MAY be sent in an initial <SYN> segment (i.e., a segment with the SYN bit on and the ACK bit off). If a Window Scale option was received in the initial <SYN> segment, then this option MAY be sent in the <SYN,ACK> segment. A Window Scale option in a segment without a SYN bit MUST be ignored.",
      "ja": "このオプションは、最初の<SYN>セグメント（すなわち、上のSYNビットとACK有するセグメントがオフビット）で送信することができます。ウィンドウスケールオプションが初期<SYN>セグメント内で受信された場合、このオプションは<SYN、ACK>セグメントで送信することができます。 SYNビットなしのセグメントにウィンドウスケールオプションを無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The window field in a segment where the SYN bit is set (i.e., a <SYN> or <SYN,ACK>) MUST NOT be scaled.",
      "ja": "SYNビットが設定されているセグメント内のウィンドウのフィールド（すなわち、<SYN>または<SYN、ACK>）スケーリングされてはいけません。"
    },
    {
      "indent": 0,
      "text": "2.3. Using the Window Scale Option",
      "section_title": true,
      "ja": "2.3。ウィンドウスケールオプションを使用します"
    },
    {
      "indent": 3,
      "text": "A model implementation of window scaling is as follows, using the notation of [RFC0793]:",
      "ja": "[RFC0793]の表記法を使用して、次のようにウィンドウスケーリングのモデルの実装は、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o The connection state is augmented by two window shift counters, Snd.Wind.Shift and Rcv.Wind.Shift, to be applied to the incoming and outgoing window fields, respectively.",
      "ja": "O接続の状態は、2つのウィンドウのシフトカウンタ、Snd.Wind.ShiftとRcv.Wind.Shift、によって増大され、それぞれ、着信および発信ウィンドウ・フィールドに適用されます。"
    },
    {
      "indent": 3,
      "text": "o If a TCP receives a <SYN> segment containing a Window Scale option, it SHOULD send its own Window Scale option in the <SYN,ACK> segment.",
      "ja": "TCPは、ウィンドウスケールオプションを含む<SYN>セグメントを受信した場合、O、それは<SYN、ACK>セグメントに独自のウィンドウスケールオプションを送るべきです。"
    },
    {
      "indent": 3,
      "text": "o The Window Scale option MUST be sent with shift.cnt = R, where R is the value that the TCP would like to use for its receive window.",
      "ja": "Oウィンドウスケールオプションは、Rは、TCPがその受信ウィンドウに使用したいと値であるshift.cnt = Rで送信されなければなりません。"
    },
    {
      "indent": 3,
      "text": "o Upon receiving a <SYN> segment with a Window Scale option containing shift.cnt = S, a TCP MUST set Snd.Wind.Shift to S and MUST set Rcv.Wind.Shift to R; otherwise, it MUST set both Snd.Wind.Shift and Rcv.Wind.Shift to zero.",
      "ja": "O shift.cnt = Sを含むウィンドウスケールオプションで<SYN>セグメントを受け取ると、TCPは、SにSnd.Wind.Shiftを設定しなければなりません、そして、RにRcv.Wind.Shiftを設定しなければなりません。それ以外の場合は、ゼロにSnd.Wind.ShiftとRcv.Wind.Shiftの両方を設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o The window field (SEG.WND) in the header of every incoming segment, with the exception of <SYN> segments, MUST be left-shifted by Snd.Wind.Shift bits before updating SND.WND:",
      "ja": "Oウィンドウフィールド<SYN>セグメントを除いて、すべての受信セグメントのヘッダに（SET.END）、AND.ENDを更新する前にSnd.Wind.Shiftビットだけ左シフトされなければなりません。"
    },
    {
      "indent": 20,
      "text": "SND.WND = SEG.WND << Snd.Wind.Shift",
      "ja": "SND.WND = SEG.WND << Snd.Wind.Shift"
    },
    {
      "indent": 6,
      "text": "(assuming the other conditions of [RFC0793] are met, and using the \"C\" notation \"<<\" for left-shift).",
      "ja": "（[RFC0793]の他の条件を仮定すると出会い、左シフトのために、「C」の表記を「<<」を使用しています）。"
    },
    {
      "indent": 3,
      "text": "o The window field (SEG.WND) of every outgoing segment, with the exception of <SYN> segments, MUST be right-shifted by Rcv.Wind.Shift bits:",
      "ja": "すべての発信セグメントのウィンドウフィールド（SET.END）O、<SYN>セグメントを除いて、Rcv.Wind.Shiftビットだけ右シフトしなければなりません。"
    },
    {
      "indent": 20,
      "text": "SEG.WND = RCV.WND >> Rcv.Wind.Shift",
      "ja": "SEG.AND = RCV.END >> Rcv.Wind.Shift"
    },
    {
      "indent": 3,
      "text": "TCP determines if a data segment is \"old\" or \"new\" by testing whether its sequence number is within 2^31 bytes of the left edge of the window, and if it is not, discarding the data as \"old\". To insure that new data is never mistakenly considered old and vice versa, the left edge of the sender's window has to be at most 2^31 away from the right edge of the receiver's window. The same is true of the sender's right edge and receiver's left edge. Since the right and left edges of either the sender's or receiver's window differ by the window size, and since the sender and receiver windows can be out of phase by at most the window size, the above constraints imply that two times the maximum window size must be less than 2^31, or",
      "ja": "TCPは、データ・セグメントは、そのシーケンス番号がウィンドウの左端の2 ^ 31バイト以内であるか否かをテストすることによって「古い」または「新規」であるかどうかを判断し、そうでない場合、「古い」としてデータを破棄する。新しいデータが誤って古いとその逆と見なされないことを保証するために、送信者のウィンドウの左端には、最大2 ^ 31離れた受信側のウィンドウの右端からにする必要があります。同じことは、送信者の右端と受信機の左端の事実です。送信者と受信者のウィンドウが最大ウィンドウサイズによって位相がずれすることができるので、送信者や受信者のウィンドウはウィンドウサイズによって異なり、どちらかの左右の端ので、上記の制約を意味するものでは2倍の最大ウィンドウサイズがなければならないこと以下の2 ^ 31ですか、"
    },
    {
      "indent": 29,
      "text": "max window < 2^30",
      "ja": "Maxウィンドウ<2 ^ 30"
    },
    {
      "indent": 3,
      "text": "Since the max window is 2^S (where S is the scaling shift count) times at most 2^16 - 1 (the maximum unscaled window), the maximum window is guaranteed to be < 2^30 if S <= 14. Thus, the shift count MUST be limited to 14 (which allows windows of 2^30 = 1 GiB). If a Window Scale option is received with a shift.cnt value larger than 14, the TCP SHOULD log the error but MUST use 14 instead of the specified value. This is safe as a sender can always choose to only partially use any signaled receive window. If the receiver is scaling by a factor larger than 14 and the sender is only scaling by 14, then the receive window used by the sender will appear smaller than it is in reality.",
      "ja": "最大ウィンドウは2 ^ S（Sはスケーリングシフト・カウントである）回最も2 ^ 16であるので、1  - （最大スケーリングされていないウィンドウ）このようにS <= 14の場合、最大ウィンドウは、<2 ^ 30であることが保証され、シフト数は（2 ^ 30 = 1ジブの窓を可能にする）14に制限されなければなりません。ウィンドウスケールオプションがshift.cnt値よりも大きい14で受信された場合、TCPはエラーをログに記録すべきであるが、指定された値の代わりに14を使用しなければなりません。送信者は、常に部分的にしかに選択した任意のウィンドウを受け取る合図使用することができますので、これは安全です。受信機は、14よりも大きい係数によってスケーリングされ、送信者がわずか14によってスケーリングされている場合、送信者によって使用されるザは受信ウィンドウは、それが実際にあるよりも小さく表示されます。"
    },
    {
      "indent": 3,
      "text": "The scale factor applies only to the window field as transmitted in the TCP header; each TCP using extended windows will maintain the window values locally as 32-bit numbers. For example, the \"congestion window\" computed by slow start and congestion avoidance (see [RFC5681]) is not affected by the scale factor, so window scaling will not introduce quantization into the congestion window.",
      "ja": "スケールファクタは、TCPヘッダで送信されるよう、ウィンドウ・フィールドに適用されます。拡張されたウィンドウを使用して、各TCPは、32ビットの数値としてローカルウィンドウ値を維持します。例えば、スロースタートと輻輳回避によって計算「輻輳ウィンドウは」（[RFC5681]を参照）スケールファクターによって影響されないので、ウィンドウ・スケーリングは、輻輳ウィンドウに量子化を導入しないであろう。"
    },
    {
      "indent": 0,
      "text": "2.4. Addressing Window Retraction",
      "section_title": true,
      "ja": "2.4。ウィンドウの後退に対処"
    },
    {
      "indent": 3,
      "text": "When a non-zero scale factor is in use, there are instances when a retracted window can be offered -- see Appendix F for a detailed example. The end of the window will be on a boundary based on the granularity of the scale factor being used. If the sequence number is then updated by a number of bytes smaller than that granularity, the TCP will have to either advertise a new window that is beyond what it previously advertised (and perhaps beyond the buffer) or will have to advertise a smaller window, which will cause the TCP window to shrink. Implementations MUST ensure that they handle a shrinking window, as specified in Section 4.2.2.16 of [RFC1122].",
      "ja": "詳細な例については、付録Fを参照してください - 非ゼロのスケール係数が使用されている場合、インスタンスは後退ウィンドウを提供することができる場合があります。ウィンドウの端は、使用されるスケールファクタの粒度に基づいて、境界にあろう。シーケンス番号は、その粒度よりも小さいバイト数によって更新された場合、TCPは、それが以前に広告を出し（そしておそらくバッファを越えて）以下のウィンドウを宣伝する必要があります何を超えて新しいウィンドウを宣伝するためのいずれかになりますこれは、TCPウィンドウが縮小するようになります。実装は、[RFC1122]のセクション4.2.2.16に指定されている彼らは、縮小ウインドウを扱う確実にしなければなりません。"
    },
    {
      "indent": 3,
      "text": "For the receiver, this implies that:",
      "ja": "受信機の場合、これはその意味します："
    },
    {
      "indent": 3,
      "text": "1) The receiver MUST honor, as in window, any segment that would have been in window for any <ACK> sent by the receiver.",
      "ja": "1）受信機は、ウィンドウのように、任意の<ACK>受信機によって送信されるための窓であったであろう任意のセグメントを尊重しなければなりません。"
    },
    {
      "indent": 3,
      "text": "2) When window scaling is in effect, the receiver SHOULD track the actual maximum window sequence number (which is likely to be greater than the window announced by the most recent <ACK>, if more than one segment has arrived since the application consumed any data in the receive buffer).",
      "ja": "ウィンドウスケーリングが有効な場合2）、受信機は、<ACK>、複数のセグメントが到着した場合、アプリケーションは、任意の最新の消費のでによって発表されたウィンドウよりも大きくなる可能性がある実際の最大ウィンドウシーケンス番号（トラックSHOULD受信バッファ内のデータ）。"
    },
    {
      "indent": 3,
      "text": "On the sender side:",
      "ja": "送信者側では："
    },
    {
      "indent": 3,
      "text": "3) The initial transmission MUST be within the window announced by the most recent <ACK>.",
      "ja": "3）最初の送信は、<ACK>直近で発表されたウィンドウ内になければなりません。"
    },
    {
      "indent": 3,
      "text": "4) On first retransmission, or if the sequence number is out of window by less than 2^Rcv.Wind.Shift, then do normal retransmission(s) without regard to the receiver window as long as the original segment was in window when it was sent.",
      "ja": "4）最初の再送で、またはシーケンス番号が2未満^ Rcv.Wind.Shiftによってウィンドウの外にある場合、限りときに、元のセグメントがウィンドウにあったように、受信機ウィンドウに関係なく、通常の再送（単数または複数）を行います送信されました。"
    },
    {
      "indent": 3,
      "text": "5) Subsequent retransmissions MAY only be sent if they are within the window announced by the most recent <ACK>.",
      "ja": "彼らは<ACK>直近で発表されたウィンドウ内にある場合5）以降の再送信にのみ送信されるかもしれません。"
    },
    {
      "indent": 0,
      "text": "3. TCP Timestamps Option",
      "section_title": true,
      "ja": "3. TCPタイムスタンプオプション"
    },
    {
      "indent": 0,
      "text": "3.1. Introduction",
      "section_title": true,
      "ja": "3.1。前書き"
    },
    {
      "indent": 3,
      "text": "The Timestamps option is introduced to address some of the issues mentioned in Sections 1.1 and 1.2. The Timestamps option is specified in a symmetrical manner, so that Timestamp Value (TSval) timestamps are carried in both data and <ACK> segments and are echoed in Timestamp Echo Reply (TSecr) fields carried in returning <ACK> or data segments. Originally used primarily for timestamping individual segments, the properties of the Timestamps option allow for taking time measurements (Section 4) as well as additional uses (Section 5).",
      "ja": "タイムスタンプオプションは、セクション1.1と1.2で述べた問題点のいくつかに対処するために導入されます。そのようにタイムスタンプ値タイムスタンプオプションは、対称的に指定されている（TSval）タイムスタンプは、データと<ACK>セグメントの両方で実施さ​​れ、<ACK>またはデータセグメントを返すで運ばタイムスタンプエコー応答（TSecr）フィールドにエコーされます。もともと個々のセグメントをタイムスタンプするために主に使用され、タイムスタンプオプションの特性は、（セクション4）並びに追加の用途（セクション5）時間測定を行うことを可能にします。"
    },
    {
      "indent": 3,
      "text": "It is necessary to remember that there is a distinction between the Timestamps option conveying timestamp information and the use of that information. In particular, the RTTM mechanism must be viewed independently from updating the Retransmission Timeout (RTO) (see Section 4.2). In this case, the sample granularity also needs to be taken into account. Other mechanisms, such as PAWS or Eifel, are not built upon the timestamp information itself but are based on the intrinsic property of monotonically non-decreasing values.",
      "ja": "タイムスタンプ情報とその情報の使用を伝えるタイムスタンプオプションの区別があることを覚えておくことが必要です。特に、RTTM機構再送タイムアウト（RTO）の更新から独立して見なければならない（セクション4.2を参照）。この場合、サンプルの粒度も考慮する必要があります。例えばPAWS又はアイフェルのような他のメカニズムは、タイムスタンプ情報自体に基づいて構築されるのではなく、単調非減少の値の固有の特性に基づいています。"
    },
    {
      "indent": 3,
      "text": "The Timestamps option is important when large receive windows are used to allow the use of the PAWS mechanism (see Section 5).",
      "ja": "大型の窓がPAWSメカニズム（第5節を参照）の使用を可能にするために使用されている受信したときにタイムスタンプオプションが重要です。"
    },
    {
      "indent": 3,
      "text": "Furthermore, the option may be useful for all TCPs, since it simplifies the sender and allows the use of additional optimizations such as Eifel ([RFC3522], [RFC4015]) and others ([RFC6817], [Kuzmanovic03], [Kuehlewind10]).",
      "ja": "それは、送信者が簡素化され、そのようなアイフェル（[RFC3522]、[RFC4015]）とその他（[RFC6817]、[Kuzmanovic03]、[Kuehlewind10]）などの追加の最適化の使用を可能にするので、このオプションは、すべてのTCPのために有用であり得ます。"
    },
    {
      "indent": 0,
      "text": "3.2. Timestamps Option",
      "section_title": true,
      "ja": "3.2。タイムスタンプオプション"
    },
    {
      "indent": 3,
      "text": "TCP is a symmetric protocol, allowing data to be sent at any time in either direction, and therefore timestamp echoing may occur in either direction. For simplicity and symmetry, we specify that timestamps always be sent and echoed in both directions. For efficiency, we combine the timestamp and timestamp reply fields into a single TCP Timestamps option.",
      "ja": "TCPは、データがいずれかの方向に任意の時間に送信できるように、対称的なプロトコルであるため、タイムスタンプ・エコーは、どちらの方向にも起こり得ます。シンプルさと対称性のために、私たちはタイムスタンプが常に両方向に送信され、エコーされるように指定します。効率化のために、我々は、単一のTCPタイムスタンプオプションにタイムスタンプとタイムスタンプ応答フィールドを兼ね備えています。"
    },
    {
      "indent": 3,
      "text": "TCP Timestamps option (TSopt):",
      "ja": "TCPタイムスタンプオプション（TSopt）："
    },
    {
      "indent": 3,
      "text": "Kind: 8",
      "ja": "種類：8"
    },
    {
      "indent": 3,
      "text": "Length: 10 bytes",
      "ja": "長さ：10のバイト"
    },
    {
      "indent": 10,
      "text": "+-------+-------+---------------------+---------------------+\n|Kind=8 |  10   |   TS Value (TSval)  |TS Echo Reply (TSecr)|\n+-------+-------+---------------------+---------------------+\n    1       1              4                     4",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The Timestamps option carries two four-byte timestamp fields. The TSval field contains the current value of the timestamp clock of the TCP sending the option.",
      "ja": "タイムスタンプオプションは、2つの4バイトのタイムスタンプフィールドを運びます。 TSvalフィールドには、オプションを送信するTCPのタイムスタンプクロックの現在の値が含まれています。"
    },
    {
      "indent": 3,
      "text": "The TSecr field is valid if the ACK bit is set in the TCP header. If the ACK bit is not set in the outgoing TCP header, the sender of that segment SHOULD set the TSecr field to zero. When the ACK bit is set in an outgoing segment, the sender MUST echo a recently received TSval sent by the remote TCP in the TSval field of a Timestamps option. The exact rules on which TSval MUST be echoed are given in Section 4.3. When the ACK bit is not set, the receiver MUST ignore the value of the TSecr field.",
      "ja": "ACKビットはTCPヘッダーに設定されている場合TSecrフィールドが有効です。 ACKビットは、発信TCPヘッダーに設定されていない場合は、そのセグメントの送信者がゼロにTSecrフィールドを設定する必要があります。 ACKビットが送信セグメントに設定されている場合、送信者はタイムスタンプオプションのTSvalフィールドにリモートTCPにより送信された最近受信TSvalをエコーし​​なければなりません。 TSvalがエコーされなければならない上、正確な規則は、セクション4.3に記載されています。 ACKビットがセットされていない場合、受信機はTSecrフィールドの値を無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "A TCP MAY send the TSopt in an initial <SYN> segment (i.e., segment containing a SYN bit and no ACK bit), and MAY send a TSopt in <SYN,ACK> only if it received a TSopt in the initial <SYN> segment for the connection.",
      "ja": "TCPは、それが最初にTSoptを受信した場合にのみ、<SYN>初期<SYN>セグメント（すなわち、SYNビットを含むセグメントと無ACKビット）でTSoptを送信すること、及び<SYN、ACK>にTSoptを送信することができます接続用セグメント。"
    },
    {
      "indent": 3,
      "text": "Once TSopt has been successfully negotiated, that is both <SYN> and <SYN,ACK> contain TSopt, the TSopt MUST be sent in every non-<RST> segment for the duration of the connection, and SHOULD be sent in an <RST> segment (see Section 5.2 for details). The TCP SHOULD remember this state by setting a flag, referred to as Snd.TS.OK, to one. If a non-<RST> segment is received without a TSopt, a TCP SHOULD silently drop the segment. A TCP MUST NOT abort a TCP connection because any segment lacks an expected TSopt.",
      "ja": "TSoptが正常にネゴシエートされた後、それは、両方の<SYN>及び<SYN、ACK>はTSoptを含む、TSoptは、接続の期間毎に非<RST>セグメントで送信されなければならない、そしてRST <で送信されてください>セグメント（詳細はセクション5.2を参照）。 TCPは1つに、Snd.TS.OKと呼ばれるフラグを設定することで、この状態を覚えておいてください。非<RST>セグメントTSoptなしで受信された場合、TCPは、サイレントセグメントを削除すべきです。任意のセグメントが期待TSoptがないため、TCPはTCP接続を中止してはいけません。"
    },
    {
      "indent": 3,
      "text": "Implementations are strongly encouraged to follow the above rules for handling a missing Timestamps option and the order of precedence mentioned in Section 5.3 when deciding on the acceptance of a segment.",
      "ja": "実装は強く欠落しているタイムスタンプオプションとセグメントの受け入れを決定する際に、5.3節で述べた優先順位を処理するために上記のルールに従うことを奨励されています。"
    },
    {
      "indent": 3,
      "text": "If a receiver chooses to accept a segment without an expected Timestamps option, it must be clear that undetectable data corruption may occur.",
      "ja": "受信機は、予想されるタイムスタンプオプションを使用せずにセグメントを受け入れることを選択した場合、検出不可能なデータの破損が発生することが明らかでなければなりません。"
    },
    {
      "indent": 3,
      "text": "Such a TCP receiver may experience undetectable wrapped-sequence effects, such as data (payload) corruption or session stalls. In order to maintain the integrity of the payload data, in particular on high-speed networks, it is paramount to follow the described processing rules.",
      "ja": "そのようなTCP受信機は、データ（ペイロード）破損やセッションストールとして検出不可能ラップ配列の効果を経験し得ます。ペイロードデータの整合性を維持するために、高速ネットワーク上の特定には、説明した処理ルールに従うことが最も重要です。"
    },
    {
      "indent": 3,
      "text": "However, it has been mentioned that under some circumstances, the above guidelines are too strict, and some paths sporadically suppress the Timestamps option, while maintaining payload integrity. A path behaving in this manner should be deemed unacceptable, but it has been noted that some implementations relax the acceptance rules as a workaround and allow TCP to run across such paths [RE-1323BIS].",
      "ja": "しかし、いくつかの状況下で、上記のガイドラインは、あまりにも厳格であり、ペイロードの整合性を維持しながら、いくつかの経路が散発的に、タイムスタンプオプションを抑制することが言及されています。このように行動経路は許容できないとみなされるべきであるが、いくつかの実装が回避策として受け入れルールを緩和し、TCPは、パス[RE-1323BIS]横切って実行することを可能にすることが注目されています。"
    },
    {
      "indent": 3,
      "text": "If a TSopt is received on a connection where TSopt was not negotiated in the initial three-way handshake, the TSopt MUST be ignored and the packet processed normally.",
      "ja": "TSoptがTSoptが最初の3ウェイハンドシェイクで交渉されていなかった接続で受信された場合、TSoptを無視しなければなりませんし、パケットが正常に処理されました。"
    },
    {
      "indent": 3,
      "text": "In the case of crossing <SYN> segments where one <SYN> contains a TSopt and the other doesn't, both sides MAY send a TSopt in the <SYN,ACK> segment.",
      "ja": "1 <SYN>はTSoptおよびその他を含んでいる<SYN>セグメントと交差する場合に、両側は、<SYN、ACK>セグメントにTSoptを送信することがありません。"
    },
    {
      "indent": 3,
      "text": "TSopt is required for the two mechanisms described in Sections 4 and 5. There are also other mechanisms that rely on the presence of the TSopt, e.g., [RFC3522]. If a TCP stopped sending TSopt at any time during an established session, it interferes with these mechanisms. This update to [RFC1323] describes explicitly the previous assumption (see Section 5.2) that each TCP segment must have a TSopt, once negotiated.",
      "ja": "TSoptはTSoptの存在に依存する他のメカニズムが[RFC3522]、例えば、もあるセクション4及び5に記載の二つの機構のために必要とされます。 TCPは確立されたセッション中にいつでもTSoptの送信を停止した場合、それはこれらのメカニズムに干渉する。 [RFC1323]は、明示的に以前の仮定を説明するこのアップデートでは、各TCPセグメントがTSopt、一度に交渉を持たなければならないこと（5.2節を参照してください）。"
    },
    {
      "indent": 0,
      "text": "4. The RTTM Mechanism",
      "section_title": true,
      "ja": "4. RTTMメカニズム"
    },
    {
      "indent": 0,
      "text": "4.1. Introduction",
      "section_title": true,
      "ja": "4.1。前書き"
    },
    {
      "indent": 3,
      "text": "One use of the Timestamps option is to measure the round-trip time (RTT) of virtually every packet acknowledged. The RTTM mechanism requires a Timestamps option in every measured segment, with a TSval that is obtained from a (virtual) \"timestamp clock\". Values of this clock MUST be at least approximately proportional to real time, in order to measure actual RTT.",
      "ja": "タイムスタンプオプションの用途の1つは、すべてのパケットが認めた事実上のラウンドトリップ時間（RTT）を測定することです。 RTTM機構は、（仮想）「タイムスタンプクロック」から得られTSvalで、すべての測定されたセグメントのタイムスタンプオプションを必要とします。このクロックの値は、実際のRTTを測定するために、リアルタイムに少なくともほぼ比例しなければなりません。"
    },
    {
      "indent": 3,
      "text": "TCP measures the RTT, primarily for the purpose of arriving at a reasonable value for the RTO timer interval. Accurate and current RTT estimates are necessary to adapt to changing traffic conditions, while a conservative estimate of the RTO interval is necessary to minimize spurious RTOs.",
      "ja": "TCPは、主に、RTOタイマー間隔のための合理的な値に到達するために、RTTを測定します。 RTO間隔の控えめな見積もりは、スプリアスのRTOを最小限に抑えるために必要であるが、正確で現在RTT推定値は、交通状況の変化に適応するために必要です。"
    },
    {
      "indent": 3,
      "text": "These TSval values are echoed in TSecr values in the reverse direction. The difference between a received TSecr value and the current timestamp clock value provides an RTT measurement.",
      "ja": "これらのTSval値は逆方向にTSecr値にエコーされます。受信TSecr値と現在のタイムスタンプクロック値との差がRTT測定値を提供します。"
    },
    {
      "indent": 3,
      "text": "When timestamps are used, every segment that is received will contain a TSecr value. However, these values cannot all be used to update the measured RTT. The following example illustrates why. It shows a one-way data flow with segments arriving in sequence without loss. Here A, B, C... represent data blocks occupying successive blocks of sequence numbers, and ACK(A),... represent the corresponding cumulative acknowledgments. The two timestamp fields of the Timestamps option are shown symbolically as <TSval=x,TSecr=y>. Each TSecr field contains the value most recently received in a TSval field.",
      "ja": "タイムスタンプが使用される場合、受信されたすべてのセグメントがTSecr値を含むであろう。しかし、これらの値は、すべての測定されたRTTを更新するために使用することはできません。次の例では、理由を示しています。これは、損失なしの順序で到着するセグメントを有する一方向のデータフローを示します。ここでA、B、C ...のシーケンス番号の連続したブロックを占有するデータブロックを表し、ACK（A）は、...対応する累積確認応答を表します。タイムスタンプオプションの2つのタイムスタンプフィールドは、<TSval = X、TSecr = Y>として象徴的に示されています。各TSecrフィールドは、最近TSvalフィールドに受信した値が含まれています。"
    },
    {
      "indent": 13,
      "text": "TCP A TCP B",
      "ja": "TCP A TCP B"
    },
    {
      "indent": 29,
      "text": "<A,TSval=1,TSecr=120> ----->",
      "raw": true
    },
    {
      "indent": 18,
      "text": "<---- <ACK(A),TSval=127,TSecr=1>",
      "raw": true
    },
    {
      "indent": 29,
      "text": "<B,TSval=5,TSecr=127> ----->",
      "raw": true
    },
    {
      "indent": 18,
      "text": "<---- <ACK(B),TSval=131,TSecr=5>",
      "raw": true
    },
    {
      "indent": 15,
      "text": ". . . . . . . . . . . . . . . . . . . . . .",
      "raw": true
    },
    {
      "indent": 29,
      "text": "<C,TSval=65,TSecr=131> ---->",
      "raw": true
    },
    {
      "indent": 18,
      "text": "<---- <ACK(C),TSval=191,TSecr=65>",
      "raw": true
    },
    {
      "indent": 33,
      "text": "(etc.)",
      "ja": "（等。）"
    },
    {
      "indent": 3,
      "text": "The dotted line marks a pause (60 time units long) in which A had nothing to send. Note that this pause inflates the RTT, which B could infer from receiving TSecr=131 in data segment C. Thus, in one-way data flows, RTTM in the reverse direction measures a value that is inflated by gaps in sending data. However, the following rule prevents a resulting inflation of the measured RTT:",
      "ja": "点線はAが送信するために何も持っていなかったした一時停止（60時間単位の長い）をマークします。このポーズは、Bは、一方向のデータフローでは、このようにデータ・セグメントCにTSecr = 131を受信することから推論できたRTTを、膨張することに注意し、RTTMは逆方向にデータを送信することでギャップによって膨張される値を測定します。ただし、以下のルールが測定されたRTTの結果としてインフレを防ぎます："
    },
    {
      "indent": 3,
      "text": "RTTM Rule: A TSecr value received in a segment MAY be used to update the averaged RTT measurement only if the segment advances the left edge of the send window, i.e., SND.UNA is increased.",
      "ja": "RTTMルール：セグメントで受信TSecr値は、セグメント、すなわち、SND.UNAを増加させる、送信ウィンドウの左端を進める場合にのみ、平均RTT測定値を更新するために使用され得ます。"
    },
    {
      "indent": 3,
      "text": "Since TCP B is not sending data, the data segment C does not acknowledge any new data when it arrives at B. Thus, the inflated RTTM measurement is not used to update B's RTTM measurement.",
      "ja": "TCP Bがデータを送信していないので、それはこのようにBに到達したとき、データセグメントCは、任意の新たなデータを確認しない、膨張RTTM測定は、BのRTTM測定値を更新するために使用されていません。"
    },
    {
      "indent": 0,
      "text": "4.2. Updating the RTO Value",
      "section_title": true,
      "ja": "4.2。 RTO値を更新"
    },
    {
      "indent": 3,
      "text": "When [RFC1323] was originally written, it was perceived that taking RTT measurements for each segment, and also during retransmissions, would contribute to reduce spurious RTOs, while maintaining the timeliness of necessary RTOs. At the time, RTO was also the only mechanism to make use of the measured RTT. It has been shown that taking more RTT samples has only a very limited effect to optimize RTOs [Allman99].",
      "ja": "[RFC1323]が元々書き込まれたときには、各セグメントのRTTの測定を行うことが知覚された、また、再送時、必要のRTOの適時性を維持しながら、スプリアスのRTOを減少させるために貢献します。当時、RTOは、測定されたRTTを利用する唯一のメカニズムでもありました。より多くのRTTのサンプルを採取するのRTO [Allman99]を最適化するために非常に限られた効果を有することが示されています。"
    },
    {
      "indent": 3,
      "text": "Implementers should note that with timestamps, multiple RTTMs can be taken per RTT. The [RFC6298] RTT estimator has weighting factors, alpha and beta, based on an implicit assumption that at most one RTTM will be sampled per RTT. When multiple RTTMs per RTT are available to update the RTT estimator, an implementation SHOULD try to adhere to the spirit of the history specified in [RFC6298]. An implementation suggestion is detailed in Appendix G.",
      "ja": "実装者は、タイムスタンプと、複数のRTTMsはRTTごとに撮影することができますことに注意してください。 [RFC6298] RTT推定器は、多くても1つのRTTMはRTTごとにサンプリングされるという暗黙の仮定に基づいて、重み係数、α及びβを有します。 RTTごとに複数のRTTMsはRTT推定を更新するために利用されている場合は、実装は、[RFC6298]で指定された歴史の精神を遵守してみてください。実装の提案は、付録Gに詳述されています"
    },
    {
      "indent": 3,
      "text": "[Ludwig00] and [Floyd05] have highlighted the problem that an unmodified RTO calculation, which is updated with per-packet RTT samples, will truncate the path history too soon. This can lead to an increase in spurious retransmissions, when the path properties vary in the order of a few RTTs, but a high number of RTT samples are taken on a much shorter timescale.",
      "ja": "[Ludwig00]と[Floyd05]パケットごとのRTTサンプルで更新された未修正のRTO計算は、あまりにも早くパス履歴を切り捨てるという問題を強調しています。これは、パスのプロパティがいくつかのRTTのために、異なるスプリアス再送の増加につながることができますが、RTTサンプルの数が多いと、はるかに短い時間スケールで撮影されています。"
    },
    {
      "indent": 0,
      "text": "4.3. Which Timestamp to Echo",
      "section_title": true,
      "ja": "4.3。これはタイムスタンプエコー"
    },
    {
      "indent": 3,
      "text": "If more than one Timestamps option is received before a reply segment is sent, the TCP must choose only one of the TSvals to echo, ignoring the others. To minimize the state kept in the receiver (i.e., the number of unprocessed TSvals), the receiver should be required to retain at most one timestamp in the connection control block.",
      "ja": "返信セグメントが送信される前に、複数のタイムスタンプオプションを受信した場合、TCPは、他の人を無視して、エコーTSvalsの一つだけを選択する必要があります。受信機に保持状態を最小限にするために（すなわち、未処理TSvalsの数）は、受信機は、接続制御ブロックに最も1つのタイムスタンプに保持するために必要とされるべきです。"
    },
    {
      "indent": 3,
      "text": "There are three situations to consider:",
      "ja": "考慮すべき3つの状況があります。"
    },
    {
      "indent": 3,
      "text": "(A) Delayed ACKs.",
      "ja": "（A）ACKを遅延。"
    },
    {
      "indent": 8,
      "text": "Many TCPs acknowledge only every second segment out of a group\nof segments arriving within a short time interval; this policy\nis known generally as \"delayed ACKs\".  The data-sender TCP must\nmeasure the effective RTT, including the additional time due to\ndelayed ACKs, or else it will retransmit unnecessarily.  Thus,\nwhen delayed ACKs are in use, the receiver SHOULD reply with the\nTSval field from the earliest unacknowledged segment.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "(B) A hole in the sequence space (segment(s) has been lost).",
      "ja": "（B）配列空間の穴（セグメント（単数または複数）が失われています）。"
    },
    {
      "indent": 8,
      "text": "The sender will continue sending until the window is filled, and\nthe receiver may be generating <ACK>s as these out-of-order\nsegments arrive (e.g., to aid \"Fast Retransmit\").",
      "raw": true
    },
    {
      "indent": 8,
      "text": "The lost segment is probably a sign of congestion, and in that situation the sender should be conservative about retransmission. Furthermore, it is better to overestimate than underestimate the RTT. An <ACK> for an out-of-order segment SHOULD, therefore, contain the timestamp from the most recent segment that advanced RCV.NXT.",
      "ja": "失われたセグメントは、おそらく輻輳の兆候であり、そのような状況で、送信者は、再送信について保守的でなければなりません。また、RTTを過小評価よりも過大評価することをお勧めします。 <ACK>アウト・オブ・オーダーセグメントのために、したがって、RCV.NXTを進めた最新のセグメントからのタイムスタンプを含むべきです。"
    },
    {
      "indent": 8,
      "text": "The same situation occurs if segments are reordered by the network.",
      "ja": "セグメントがネットワークによって並べ替えされている場合、同じような状況が発生します。"
    },
    {
      "indent": 3,
      "text": "(C) A filled hole in the sequence space.",
      "ja": "配列空間における（C）A充填穴。"
    },
    {
      "indent": 8,
      "text": "The segment that fills the hole and advances the window\nrepresents the most recent measurement of the network\ncharacteristics.  An RTT computed from an earlier segment would\nprobably include the sender's retransmit timeout, badly biasing\nthe sender's average RTT estimate.  Thus, the timestamp from the\nlatest segment (which filled the hole) MUST be echoed.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "An algorithm that covers all three cases is described in the following rules for Timestamps option processing on a synchronized connection:",
      "ja": "すべての3つのケースをカバーするアルゴリズムは、同期接続でのタイムスタンプオプションの処理のために、以下の規則に記述されています。"
    },
    {
      "indent": 3,
      "text": "(1) The connection state is augmented with two 32-bit slots:",
      "ja": "（1）接続状態が2つの32ビットスロットで拡張されます。"
    },
    {
      "indent": 8,
      "text": "TS.Recent holds a timestamp to be echoed in TSecr whenever a\nsegment is sent, and Last.ACK.sent holds the ACK field from the\nlast segment sent.  Last.ACK.sent will equal RCV.NXT except when\n<ACK>s have been delayed.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "(2) If:",
      "ja": "（2）の場合："
    },
    {
      "indent": 12,
      "text": "SEG.TSval >= TS.Recent and SEG.SEQ <= Last.ACK.sent",
      "ja": "SEG.TSval> = TS.RecentとSEG.SEQ <= Last.ACK.sent"
    },
    {
      "indent": 8,
      "text": "then SEG.TSval is copied to TS.Recent; otherwise, it is ignored.",
      "ja": "その後、SEG.TSvalはTS.Recentにコピーされます。それ以外の場合は無視されます。"
    },
    {
      "indent": 3,
      "text": "(3) When a TSopt is sent, its TSecr field is set to the current TS.Recent value.",
      "ja": "TSoptが送信されると（3）、そのTSecrフィールドが現在TS.Recent値に設定されています。"
    },
    {
      "indent": 3,
      "text": "The following examples illustrate these rules. Here A, B, C... represent data segments occupying successive blocks of sequence numbers, and ACK(A),... represent the corresponding acknowledgment segments. Note that ACK(A) has the same sequence number as B. We show only one direction of timestamp echoing, for clarity.",
      "ja": "次の例では、これらのルールを説明します。ここでA、B、C ...のシーケンス番号の連続したブロックを占有するデータ・セグメントを表し、ACK（A）は、...対応する肯定応答セグメントを表します。 ACK（A）は、我々は明確にするために、エコータイムスタンプの一方向のみを示しBと同じシーケンス番号を有することに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "o Segments arrive in sequence, and some of the <ACK>s are delayed.",
      "ja": "Oセグメントが順次到着し、<ACK> Sの一部が遅延されます。"
    },
    {
      "indent": 6,
      "text": "By case (A), the timestamp from the oldest unacknowledged segment is echoed.",
      "ja": "ケース（A）によって、最も古い不承認のセグメントからのタイムスタンプをエコーし​​ます。"
    },
    {
      "indent": 16,
      "text": "                                  TS.Recent\n<A, TSval=1> ------------------->\n                                      1\n<B, TSval=2> ------------------->\n                                      1\n<C, TSval=3> ------------------->\n                                      1\n         <---- <ACK(C), TSecr=1>\n(etc.)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "o Segments arrive out of order, and every segment is acknowledged.",
      "ja": "Oセグメントは、順不同で到着し、すべてのセグメントが認められています。"
    },
    {
      "indent": 6,
      "text": "By case (B), the timestamp from the last segment that advanced the left window edge is echoed until the missing segment arrives; it is echoed according to case (C). The same sequence would occur if segments B and D were lost and retransmitted.",
      "ja": "ケース（B）によって、欠落セグメントが到着するまで左ウィンドウエッジがエコーされて前進最後のセグメントからのタイムスタンプ。それはケース（C）に係るエコーれます。セグメントB及びDは、失われたと再送信された場合、同じシーケンスが起こります。"
    },
    {
      "indent": 16,
      "text": "                                  TS.Recent\n<A, TSval=1> ------------------->\n                                      1\n         <---- <ACK(A), TSecr=1>\n                                      1\n<C, TSval=3> ------------------->\n                                      1\n         <---- <ACK(A), TSecr=1>\n                                      1\n<B, TSval=2> ------------------->\n                                      2\n         <---- <ACK(C), TSecr=2>\n                                      2\n<E, TSval=5> ------------------->\n                                      2\n         <---- <ACK(C), TSecr=2>\n                                      2\n<D, TSval=4> ------------------->\n                                      4\n         <---- <ACK(E), TSecr=4>\n(etc.)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "5. PAWS - Protection Against Wrapped Sequences",
      "section_title": true,
      "ja": "5. PAWS  - に対する保護ラップシーケンス"
    },
    {
      "indent": 0,
      "text": "5.1. Introduction",
      "section_title": true,
      "ja": "5.1。前書き"
    },
    {
      "indent": 3,
      "text": "Another use for the Timestamps option is the PAWS mechanism. Section 5.2 describes a simple mechanism to reject old duplicate segments that might corrupt an open TCP connection. PAWS operates within a single TCP connection, using state that is saved in the connection control block. Section 5.8 and Appendix H discuss the implications of the PAWS mechanism for avoiding old duplicates from previous incarnations of the same connection.",
      "ja": "タイムスタンプオプションの別の使用は、PAWSメカニズムです。 5.2節ではその可能性があります破損しているオープンTCPコネクション古い重複セグメントを拒否するための簡単なメカニズムについて説明します。 PAWSは、接続制御ブロックに保存された状態を使用して、単一のTCP接続内で動作します。セクション5.8および付録Hは、同じ接続の以前の肉体化からの古い重複を避けるためPAWSメカニズムの影響を議論します。"
    },
    {
      "indent": 0,
      "text": "5.2. The PAWS Mechanism",
      "section_title": true,
      "ja": "5.2。 PAWSメカニズム"
    },
    {
      "indent": 3,
      "text": "PAWS uses the TCP Timestamps option described earlier and assumes that every received TCP segment (including data and <ACK> segments) contains a timestamp SEG.TSval whose values are monotonically non-decreasing in time. The basic idea is that a segment can be discarded as an old duplicate if it is received with a timestamp SEG.TSval less than some timestamps recently received on this connection.",
      "ja": "PAWSは、前述のTCPタイムスタンプオプションを使用し、すべてが（データおよび<ACK>セグメントを含む）、TCPセグメントを受信したと仮定し、その値が時間的に単調非減少であるタイムスタンプSEG.TSvalを含んでいます。基本的な考え方は、それが最近、この接続で受信されたいくつかのタイムスタンプより小さいタイムスタンプSEG.TSvalで受信された場合、セグメントが古い重複として廃棄することができるということです。"
    },
    {
      "indent": 3,
      "text": "In the PAWS mechanism, the \"timestamps\" are 32-bit unsigned integers in a modular 32-bit space. Thus, \"less than\" is defined the same way it is for TCP sequence numbers, and the same implementation techniques apply. If s and t are timestamp values,",
      "ja": "PAWS機構において、「タイムスタンプ」とは、モジュラー32ビット空間で32ビットの符号なし整数です。このように、「未満」とは、TCPシーケンス番号のためであるのと同じ方法で定義されており、同じ実装技術が適用されます。 sおよびtは、タイムスタンプ値がある場合は、"
    },
    {
      "indent": 23,
      "text": "s < t if 0 < (t - s) < 2^31,",
      "ja": "<2 ^ 31、 -  S <T <（S t）が0の場合"
    },
    {
      "indent": 3,
      "text": "computed in unsigned 32-bit arithmetic.",
      "ja": "符号なし32ビット演算で計算。"
    },
    {
      "indent": 3,
      "text": "The choice of incoming timestamps to be saved for this comparison MUST guarantee a value that is monotonically non-decreasing. For example, an implementation might save the timestamp from the segment that last advanced the left edge of the receive window, i.e., the most recent in-sequence segment. For simplicity, the value TS.Recent introduced in Section 4.3 is used instead, as using a common value for both PAWS and RTTM simplifies the implementation. As Section 4.3 explained, TS.Recent differs from the timestamp from the last in-sequence segment only in the case of delayed <ACK>s, and therefore by less than one window. Either choice will, therefore, protect against sequence number wrap-around.",
      "ja": "この比較のために保存する、着信タイムスタンプの選択は単調非減少されている値を保証しなければなりません。例えば、実装は、最後の受信ウィンドウ、即ち、最も最近に配列セグメントの左端を前進セグメントからのタイムスタンプを保存するかもしれません。簡単にするために、4.3節で導入値TS.RecentはPAWSとRTTM実装を簡素化の両方のための共通の値を使用するなど、代わりに使用されます。セクション4.3で説明したように、TS.Recentのみ<ACK> S、したがって未満のウィンドウだけ遅延した場合に最後に、配列セグメントからのタイムスタンプとは異なります。どちらの選択は、そのため、シーケンス番号のラップアラウンドに対する保護します。"
    },
    {
      "indent": 3,
      "text": "PAWS submits all incoming segments to the same test, and therefore protects against duplicate <ACK> segments as well as data segments. (An alternative non-symmetric algorithm would protect against old duplicate <ACK>s: the sender of data would reject incoming <ACK> segments whose TSecr values were less than the TSecr saved from the last segment whose ACK field advanced the left edge of the send window. This algorithm was deemed to lack economy of mechanism and symmetry.)",
      "ja": "PAWSは同じ試験にすべての受信セグメントを送信し、したがって重複<ACK>セグメントとデータ・セグメントから保護します。 （代替の非対称アルゴリズムは、古い重複に対して保護する<ACK> S：データの送信者は、そのTSecr値TSecrは、そのACKフィールドの左端を前進最後のセグメントから保存されたよりも低かった着信<ACK>セグメントを拒否するウィンドウを送信する。このアルゴリズムは、メカニズムと対称性の経済を欠いていると考えられました。）"
    },
    {
      "indent": 3,
      "text": "TSval timestamps sent on <SYN> and <SYN,ACK> segments are used to initialize PAWS. PAWS protects against old duplicate non-<SYN> segments and duplicate <SYN> segments received while there is a synchronized connection. Duplicate <SYN> and <SYN,ACK> segments received when there is no connection will be discarded by the normal 3-way handshake and sequence number checks of TCP.",
      "ja": "上で送信TSvalタイムスタンプ<SYN>及び<SYN、ACK>セグメントはPAWSを初期化するために使用されます。 PAWSは、古い重複に対して非<SYN>セグメントを保護し、同期接続があるが重複<SYN>セグメントが受信されました。 <SYN>及び<SYN、ACK>セグメント重複しない接続は、TCPの通常の3ウェイハンドシェイクおよびシーケンス番号チェックにより存在破棄されませんされたときに受信しました。"
    },
    {
      "indent": 3,
      "text": "[RFC1323] recommended that <RST> segments NOT carry timestamps and that they be acceptable regardless of their timestamp. At that time, the thinking was that old duplicate <RST> segments should be exceedingly unlikely, and their cleanup function should take precedence over timestamps. More recently, discussions about various blind attacks on TCP connections have raised the suggestion that if the Timestamps option is present, SEG.TSecr could be used to provide stricter acceptance tests for <RST> segments.",
      "ja": "[RFC1323]は<RST>セグメントがタイムスタンプを運ばないことを、彼らは関係なく、タイムスタンプの許容されることをお勧め。当時、考え方は古い重複<RST>セグメントは非常にそうであるべきであり、彼らのクリーンアップ機能は、タイムスタンプよりも優先すべきであるということでした。さらに最近では、TCPコネクション上の様々な盲目の攻撃に関する議論はタイムスタンプオプションが存在する場合、SEG.TSecrは<RST>セグメントのための厳格な受け入れテストを提供するために使用することができることを示唆し調達しています。"
    },
    {
      "indent": 3,
      "text": "While still under discussion, to enable research into this area it is now RECOMMENDED that when generating an <RST>, if the segment causing the <RST> to be generated contains a Timestamps option, the <RST> should also contain a Timestamps option. In the <RST> segment, SEG.TSecr SHOULD be set to SEG.TSval from the incoming segment and SEG.TSval SHOULD be set to zero. If an <RST> is being generated because of a user abort, and Snd.TS.OK is set, then a Timestamps option SHOULD be included in the <RST>. When an <RST> segment is received, it MUST NOT be subjected to the PAWS check by verifying an acceptable value in SEG.TSval, and information from the Timestamps option MUST NOT be used to update connection state information. SEG.TSecr MAY be used to provide stricter <RST> acceptance checks.",
      "ja": "まだ議論の下で、この分野の研究を可能にする一方で、今の生成時に、<RST>生成させるセグメントがタイムスタンプオプションが含まれている場合は、<RST>、、<RST>また、タイムスタンプオプションを含めることをお勧めします。 <RST>セグメントにおいて、SEG.TSecr着信セグメントからSEG.TSvalに設定されるべきであり、SEG.TSvalはゼロに設定されるべきです。 <RST>ので、ユーザアボートの生成され、そしてSnd.TS.OKが設定されている場合、タイムスタンプオプションが<RST>に含まれるべきです。 <RST>セグメントが受信されると、それはSEG.TSvalで許容値を検証することによってPAWSチェックに供してはいけません、およびタイムスタンプオプションからの情報は、接続状態情報を更新するために使用してはいけません。 SEG.TSecrは厳しい<RST>受入検査を提供するために用いることができます。"
    },
    {
      "indent": 0,
      "text": "5.3. Basic PAWS Algorithm",
      "section_title": true,
      "ja": "5.3。基本PAWSアルゴリズム"
    },
    {
      "indent": 3,
      "text": "If the PAWS algorithm is used, the following processing MUST be performed on all incoming segments for a synchronized connection. Also, PAWS processing MUST take precedence over the regular TCP acceptability check (Section 3.3 in [RFC0793]), which is performed after verification of the received Timestamps option:",
      "ja": "PAWSアルゴリズムが使用される場合、以下の処理が同期接続のためにすべての着信セグメント上で実行されなければなりません。また、PAWS処理は、受信タイムスタンプ・オプションの検証後に行われる定期的なTCPの良否検査（[RFC0793]セクション3.3）、優先しなければなりません。"
    },
    {
      "indent": 3,
      "text": "R1) If there is a Timestamps option in the arriving segment, SEG.TSval < TS.Recent, TS.Recent is valid (see later discussion), and if the RST bit is not set, then treat the arriving segment as not acceptable:",
      "ja": "到着セグメントのタイムスタンプオプションがある場合は、SEG.TSval <TS.Recentは、TS.Recent（）は、後で説明を参照してください、とRSTビットが設定されていない場合は、受け入れられないとして到着したセグメントを扱う有効であるR1）："
    },
    {
      "indent": 11,
      "text": "Send an acknowledgment in reply as specified in Section 3.9\nof [RFC0793], page 69, and drop the segment.",
      "raw": true
    },
    {
      "indent": 11,
      "text": "Note: it is necessary to send an <ACK> segment in order to retain TCP's mechanisms for detecting and recovering from half-open connections. For an example, see Figure 10 of [RFC0793].",
      "ja": "注意：検出して、ハーフオープン接続から回復するためのTCPのメカニズムを保持するために、<ACK>セグメントを送信する必要があります。例えば、[RFC0793]の図10を参照してください。"
    },
    {
      "indent": 3,
      "text": "R2) If the segment is outside the window, reject it (normal TCP processing).",
      "ja": "R2）は、セグメントが窓の外にある場合、）（通常のTCP処理を、それを拒否します。"
    },
    {
      "indent": 3,
      "text": "R3) If an arriving segment satisfies SEG.TSval >= TS.Recent and SEG.SEQ <= Last.ACK.sent (see Section 4.3), then record its timestamp in TS.Recent.",
      "ja": "R3）到着セグメント満たすSEG.TSval> = TS.RecentとSEG.SEQ <= Last.ACK.sent場合（4.3節を参照）、次いでTS.Recentにタイムスタンプを記録します。"
    },
    {
      "indent": 3,
      "text": "R4) If an arriving segment is in sequence (i.e., at the left window edge), then accept it normally.",
      "ja": "到着セグメント（すなわち、）左ウィンドウエッジでシーケンスである場合R4）は、次いで、通常はそれを受け入れます。"
    },
    {
      "indent": 3,
      "text": "R5) Otherwise, treat the segment as a normal in-window, out-of-sequence TCP segment (e.g., queue it for later delivery to the user).",
      "ja": "R5）そうでなければ、正常にウィンドウ、アウトオブシーケンスTCPセグメント（例えば、ユーザへの後の送達のためにそれをキュー）としてセグメントを扱います。"
    },
    {
      "indent": 3,
      "text": "Steps R2, R4, and R5 are the normal TCP processing steps specified by [RFC0793].",
      "ja": "ステップR2、R4、及びR5は、[RFC0793]で指定された通常のTCP処理ステップです。"
    },
    {
      "indent": 3,
      "text": "It is important to note that the timestamp MUST be checked only when a segment first arrives at the receiver, regardless of whether it is in sequence or it must be queued for later delivery.",
      "ja": "セグメントが最初にかかわらず、それが配列であるか、それは後で配信のためにキューイングされなければならないかどうかの、受信機に到達した場合にのみ、タイムスタンプをチェックしなければなりませんことに注意することが重要です。"
    },
    {
      "indent": 3,
      "text": "Consider the following example.",
      "ja": "次の例を考えてみましょう。"
    },
    {
      "indent": 6,
      "text": "Suppose the segment sequence: A.1, B.1, C.1, ..., Z.1 has been sent, where the letter indicates the sequence number and the digit represents the timestamp. Suppose also that segment B.1 has been lost. The timestamp in TS.Recent is 1 (from A.1), so C.1, ..., Z.1 are considered acceptable and are queued. When B is retransmitted as segment B.2 (using the latest timestamp), it fills the hole and causes all the segments through Z to be acknowledged and passed to the user. The timestamps of the queued segments are *not* inspected again at this time, since they have already been accepted. When B.2 is accepted, TS.Recent is set to 2.",
      "ja": "セグメントのシーケンスとします文字は、シーケンス番号と桁はタイムスタンプを表し示し、A.1、B.1、C.1を...、Z.1は、送信されています。セグメントB.1が失われたこともあるとします。 TS.Recentのタイムスタンプは、（A.1）1、C.1ので、...、Z.1許容されると考えられるし、キューイングされています。 Bが（最新のタイムスタンプを使用して）セグメントB.2として再送される場合には、穴を充填してユーザに確認され、渡されるZを介してすべてのセグメントを引き起こします。彼らはすでに承認されているので、キューイングされたセグメントのタイムスタンプは*、この時点で再度検査されていません。 B.2が受け入れられると、TS.Recentは2に設定されています。"
    },
    {
      "indent": 3,
      "text": "This rule allows reasonable performance under loss. A full window of data is in transit at all times, and after a loss a full window less one segment will show up out of sequence to be queued at the receiver (e.g., up to ~2^30 bytes of data); the Timestamps option must not result in discarding this data.",
      "ja": "この規則は、損失の下で合理的なパフォーマンスを可能にします。データの完全なウィンドウは常にトランジットであり、損失の後に完全なウィンドウ以下つのセグメントは、（例えば、データの〜2 ^ 30バイトまで）受信機でキューイングされるべき配列のうちの表示されます。タイムスタンプオプションは、このデータを破棄するにはなりませしなければなりません。"
    },
    {
      "indent": 3,
      "text": "In certain unlikely circumstances, the algorithm of rules R1-R5 could lead to discarding some segments unnecessarily, as shown in the following example:",
      "ja": "次の例に示すように、一定の低い状況では、ルールR1-R5のアルゴリズムは、不必要にいくつかのセグメントを廃棄につながります。"
    },
    {
      "indent": 6,
      "text": "Suppose again that segments: A.1, B.1, C.1, ..., Z.1 have been sent in sequence and that segment B.1 has been lost. Furthermore, suppose delivery of some of C.1, ... Z.1 is delayed until *after* the retransmission B.2 arrives at the receiver. These delayed segments will be discarded unnecessarily when they do arrive, since their timestamps are now out of date.",
      "ja": "A.1、B.1、C.1、...、Z.1シーケンスで送信されてきたし、そのセグメントB.1が失われた：セグメントがあることを再びとします。さらに、C.1のいくつかの仮定する配信は、... Z.1は再送B.2が受信機に到着* *後まで延期されます。彼らが到着しないとき、そのタイムスタンプが古くなりましたので、これらの遅れのセグメントは、不必要に破棄されます。"
    },
    {
      "indent": 3,
      "text": "This case is very unlikely to occur. If the retransmission was triggered by a timeout, some of the segments C.1, ... Z.1 must have been delayed longer than the RTO time. This is presumably an unlikely event, or there would be many spurious timeouts and retransmissions. If B's retransmission was triggered by the \"Fast Retransmit\" algorithm, i.e., by duplicate <ACK>s, then the queued segments that caused these <ACK>s must have been received already.",
      "ja": "このケースが発生するのは非常に低いです。再送がタイムアウトによってトリガーされた場合は、セグメントC.1の一部は、... Z.1は長いRTO時間よりも遅れている必要があります。これはおそらく、万が一の場合、または多くの偽のタイムアウトおよび再送信が存在することになります。 Bの再送が「高速再送信」アルゴリズム、すなわちによってトリガされた場合は、重複した<ACK> Sにより、これらの<ACK>の原因とキューに入れられたセグメントが既に受信されている必要があります。"
    },
    {
      "indent": 3,
      "text": "Even if a segment were delayed past the RTO, the Fast Retransmit mechanism [Jacobson90c] will cause the delayed segments to be retransmitted at the same time as B.2, avoiding an extra RTT and, therefore, causing a very small performance penalty.",
      "ja": "セグメントはRTOを越えて遅延した場合でも、高速再送信機構は、[Jacobson90c】遅延セグメントは、非常に小さなパフォーマンスの低下を引き起こし、従って、余分なRTTを回避し、B.2と同時に再送信することになります。"
    },
    {
      "indent": 3,
      "text": "We know of no case with a significant probability of occurrence in which timestamps will cause performance degradation by unnecessarily discarding segments.",
      "ja": "私たちは、タイムスタンプが不必要にセグメントを破棄することにより、パフォーマンスの低下の原因となるで発生重要な確率で、いかなる場合を知っています。"
    },
    {
      "indent": 0,
      "text": "5.4. Timestamp Clock",
      "section_title": true,
      "ja": "5.4。タイムスタンプ時計"
    },
    {
      "indent": 3,
      "text": "It is important to understand that the PAWS algorithm does not require clock synchronization between the sender and receiver. The sender's timestamp clock is used as a source of monotonic non-decreasing values to stamp the segments. The receiver treats the timestamp value as simply a monotonically non-decreasing serial number, without any connection to time. From the receiver's viewpoint, the timestamp is acting as a logical extension of the high-order bits of the sequence number.",
      "ja": "PAWSアルゴリズムは、送信者と受信者の間のクロック同期を必要としないことを理解することが重要です。送信者のタイムスタンプクロックは、セグメントをスタンプする単調非減少の値のソースとして使用されます。受信機は、時間への接続なしで、単に単調非減少シリアル番号としてタイムスタンプ値を処理します。受信機の観点から、タイムスタンプ、シーケンス番号の上位ビットの論理的な拡張として機能しています。"
    },
    {
      "indent": 3,
      "text": "The receiver algorithm does place some requirements on the frequency of the timestamp clock.",
      "ja": "受信機アルゴリズムは、タイムスタンプクロックの周波数にいくつかの要件を置くありません。"
    },
    {
      "indent": 3,
      "text": "(a) The timestamp clock must not be \"too slow\".",
      "ja": "（a）は、タイムスタンプのクロックは「遅すぎる」であってはなりません。"
    },
    {
      "indent": 8,
      "text": "It MUST tick at least once for each 2^31 bytes sent.  In fact,\nin order to be useful to the sender for round-trip timing, the\nclock SHOULD tick at least once per window's worth of data, and\neven with the window extension defined in Section 2.2, 2^31\nbytes must be at least two windows.",
      "raw": true
    },
    {
      "indent": 8,
      "text": "To make this more quantitative, any clock faster than 1 tick/sec will reject old duplicate segments for link speeds of ~8 Gbps. A 1 ms timestamp clock will work at link speeds up to 8 Tbps (8*10^12) bps!",
      "ja": "これは、より定量的にするために、1チック/秒より速い任意のクロックは〜8 Gbpsののリンク速度の古い重複セグメントを拒否します。リンクで動作する1ミリ秒のタイムスタンプクロックは8 Tbpsの（8 * 10 ^ 12）bpsにスピードアップ！"
    },
    {
      "indent": 3,
      "text": "(b) The timestamp clock must not be \"too fast\".",
      "ja": "（b）は、タイムスタンプのクロックは、「速すぎる」であってはなりません。"
    },
    {
      "indent": 8,
      "text": "The recycling time of the timestamp clock MUST be greater than\nMSL seconds.  Since the clock (timestamp) is 32 bits and the\nworst-case MSL is 255 seconds, the maximum acceptable clock\nfrequency is one tick every 59 ns.",
      "raw": true
    },
    {
      "indent": 8,
      "text": "However, it is desirable to establish a much longer recycle period, in order to handle outdated timestamps on idle connections (see Section 5.5), and to relax the MSL requirement for preventing sequence number wrap-around. With a 1 ms timestamp clock, the 32-bit timestamp will wrap its sign bit in 24.8 days. Thus, it will reject old duplicates on the same connection if MSL is 24.8 days or less. This appears to be a very safe figure; an MSL of 24.8 days or longer can probably be assumed in the Internet without requiring precise MSL enforcement.",
      "ja": "しかし、アイドル状態の接続（5.5節を参照）に時代遅れのタイムスタンプを処理するために、はるかに長い再利用期間を確立すること、およびラップアラウンドシーケンス番号を防ぐためのMSLの要件を緩和することが望ましいです。 1ミリ秒のタイムスタンプクロックで、32ビットのタイムスタンプは24.8日でその符号ビットをラップします。 MSLは24.8日以下であればこのように、それは同じ接続で古い写しを拒否します。これは非常に安全な数字であるように思われます。 24.8日以上のMSLは、おそらく正確なMSLの施行を必要とせずにインターネットで想定することができます。"
    },
    {
      "indent": 3,
      "text": "Based upon these considerations, we choose a timestamp clock frequency in the range 1 ms to 1 sec per tick. This range also matches the requirements of the RTTM mechanism, which does not need much more resolution than the granularity of the retransmit timer, e.g., tens or hundreds of milliseconds.",
      "ja": "これらの考察に基づいて、我々は、ダニあたり1秒の範囲で1ミリ秒のタイムスタンプのクロック周波数を選択します。この範囲はまた、再送信タイマーの細かさよりもはるかに解像度を必要としないRTTMメカニズムの要件を、一致して、例えば、数十または数百ミリ秒。"
    },
    {
      "indent": 3,
      "text": "The PAWS mechanism also puts a strong monotonicity requirement on the sender's timestamp clock. The method of implementation of the timestamp clock to meet this requirement depends upon the system hardware and software.",
      "ja": "PAWSメカニズムはまた、送信者のタイムスタンプ時計に強い単調性要件を置きます。この要件を満たすためにタイムスタンプクロックの実装方法は、システムのハードウェアとソフトウェアに依存します。"
    },
    {
      "indent": 3,
      "text": "o Some hosts have a hardware clock that is guaranteed to be monotonic between hardware resets.",
      "ja": "O一部のホストは、ハードウェアのリセットの間で単調であることが保証されているハードウェアクロックを持っています。"
    },
    {
      "indent": 3,
      "text": "o A clock interrupt may be used to simply increment a binary integer by 1 periodically.",
      "ja": "Oクロック割り込みが単に定期1進整数をインクリメントするために使用することができます。"
    },
    {
      "indent": 3,
      "text": "o The timestamp clock may be derived from a system clock that is subject to being abruptly changed by adding a variable offset value. This offset is initialized to zero. When a new timestamp clock value is needed, the offset can be adjusted as necessary to make the new value equal to or larger than the previous value (which was saved for this purpose).",
      "ja": "Oタイムスタンプクロックが急激に可変のオフセット値を加算することによって変更される対象であるシステムクロックから導出することができます。このオフセットはゼロに初期化されます。新しいタイムスタンプクロック値が必要とされる場合、オフセットに等しいか（この目的のために保存した）前の値よりも大きい新しい値を作るために必要に応じて調整することができます。"
    },
    {
      "indent": 3,
      "text": "o A random offset may be added to the timestamp clock on a per-connection basis. See [RFC6528], Section 3, on randomizing the initial sequence number (ISN). The same function with a different secret key can be used to generate the per-connection timestamp offset.",
      "ja": "Oランダムは、接続ごとにタイムスタンプクロックに添加することができるオフセット。初期シーケンス番号（ISN）をランダムに、[RFC6528]、セクション3を参照。異なる秘密鍵で同じ機能は、オフセット、接続ごとのタイムスタンプを生成するために使用することができます。"
    },
    {
      "indent": 0,
      "text": "5.5. Outdated Timestamps",
      "section_title": true,
      "ja": "5.5。古いタイムスタンプ"
    },
    {
      "indent": 3,
      "text": "If a connection remains idle long enough for the timestamp clock of the other TCP to wrap its sign bit, then the value saved in TS.Recent will become too old; as a result, the PAWS mechanism will cause all subsequent segments to be rejected, freezing the connection (until the timestamp clock wraps its sign bit again).",
      "ja": "接続はその符号ビットをラップするために他のTCPのタイムスタンプクロックのために十分に長いアイドル状態のままであれば、TS.Recentに保存された値があまりにも古いとなります。結果として、PAWSメカニズムは、接続を（タイムスタンプクロックが再びその符号ビットをラップするまで）凍結、後続のすべてのセグメントが拒否されます。"
    },
    {
      "indent": 3,
      "text": "With the chosen range of timestamp clock frequencies (1 sec to 1 ms), the time to wrap the sign bit will be between 24.8 days and 24800 days. A TCP connection that is idle for more than 24 days and then comes to life is exceedingly unusual. However, it is undesirable in principle to place any limitation on TCP connection lifetimes.",
      "ja": "タイムスタンプクロック周波数（1ミリ秒〜1秒）の選択された範囲で、符号ビットをラップする時間が24.8日24800日の間であろう。以上24日間アイドル状態で、その後の人生に来るTCP接続は非常に珍しいです。しかし、それはTCPコネクションの寿命に何らかの制限を配置するために、原則的には望ましくありません。"
    },
    {
      "indent": 3,
      "text": "We therefore require that an implementation of PAWS include a mechanism to \"invalidate\" the TS.Recent value when a connection is idle for more than 24 days. (An alternative solution to the problem of outdated timestamps would be to send keep-alive segments at a very low rate, but still more often than the wrap-around time for timestamps, e.g., once a day. This would impose negligible overhead. However, the TCP specification has never included keep-alives, so the solution based upon invalidation was chosen.)",
      "ja": "したがって、我々は、PAWSの実装は接続が24以上の日のためにアイドル状態のときTS.Recent値を「無効」にする機構を備えている必要があります。 （時代遅れのタイムスタンプの問題に対する別の解決策は、非常に低いレートでキープアライブのセグメントを送ることであろうが、それでも多くの場合例えば、タイムスタンプ、用ラップアラウンド時間よりも、一日一回。これは無視できるオーバーヘッドを課す。しかし、 、TCP仕様はキープアライブを、無効化に基づくソリューションを選択したので、含まれていませんでした。）"
    },
    {
      "indent": 3,
      "text": "Note that a TCP does not know the frequency, and therefore the wrap-around time, of the other TCP, so it must assume the worst. The validity of TS.Recent needs to be checked only if the basic PAWS timestamp check fails, i.e., only if SEG.TSval < TS.Recent. If TS.Recent is found to be invalid, then the segment is accepted, regardless of the failure of the timestamp check, and rule R3 updates TS.Recent with the TSval from the new segment.",
      "ja": "TCPは、周波数を知らないことに注意してくださいので、ラップアラウンドタイム、他のTCPの、それは最悪の事態を想定する必要があります。 TS.Recentの妥当性は、唯一SEG.TSval <TS.Recent場合、すなわち、基本的なPAWSのタイムスタンプチェックが失敗した場合にのみチェックする必要があります。 TS.Recentが無効であることが判明した場合、そのセグメントに関係なく、タイムスタンプチェックの失敗の、受け入れ、そして新しいセグメントからTSvalとR3アップデートTS.Recentを支配されます。"
    },
    {
      "indent": 3,
      "text": "To detect how long the connection has been idle, the TCP MAY update a clock or timestamp value associated with the connection whenever TS.Recent is updated, for example. The details will be implementation dependent.",
      "ja": "TS.Recentが更新されるたびに、接続がアイドル状態になっている時間の長さを検出するために、TCPは、例えば、接続に関連したクロックやタイムスタンプ値を更新することができます。詳細は、実装依存することになります。"
    },
    {
      "indent": 0,
      "text": "5.6. Header Prediction",
      "section_title": true,
      "ja": "5.6。ヘッダー予測"
    },
    {
      "indent": 3,
      "text": "\"Header prediction\" [Jacobson90a] is a high-performance transport protocol implementation technique that is most important for high-speed links. This technique optimizes the code for the most common case, receiving a segment correctly and in order. Using header prediction, the receiver asks the question, \"Is this segment the next in sequence?\" This question can be answered in fewer machine instructions than the question, \"Is this segment within the window?\"",
      "ja": "「ヘッダ予測は、」[Jacobson90a]高速リンクのために最も重要である高性能なトランスポートプロトコルの実装技術です。この技術は、正しく順序でセグメントを受信し、最も一般的なケースのためのコードを最適化します。ヘッダー予測を使用して、受信機は質問を、「このセグメントは、シーケンス内の次のですか？」この質問は、「ウィンドウ内のこのセグメントはありますか？」、質問よりも少ない機械語命令に答えることができます"
    },
    {
      "indent": 3,
      "text": "Adding header prediction to our timestamp procedure leads to the following recommended sequence for processing an arriving TCP segment:",
      "ja": "私たちのタイムスタンププロシージャにヘッダー予測を追加すると、到着したTCPセグメントを処理するために、次の推奨手順につながります："
    },
    {
      "indent": 3,
      "text": "H1) Check timestamp (same as step R1 above).",
      "ja": "上記ステップR1と同じH1）空タイムスタンプ（）。"
    },
    {
      "indent": 3,
      "text": "H2) Do header prediction: if the segment is next in sequence and if there are no special conditions requiring additional processing, accept the segment, record its timestamp, and skip H3.",
      "ja": "H2）ヘッダ予測を行います。セグメントはシーケンス内の次であれば追加の処理を必要とする特別な条件がない場合、セグメントを受け入れて、そのタイムスタンプを記録し、及びH3をスキップします。"
    },
    {
      "indent": 3,
      "text": "H3) Process the segment normally, as specified in RFC 793. This includes dropping segments that are outside the window and possibly sending acknowledgments, and queuing in-window, out-of-sequence segments.",
      "ja": "H3）は、RFC 793で指定されるように、通常、セグメントを処理し、このウィンドウ外にあるセグメントをドロップし、おそらくは、肯定応答を送信し、そしてインキューイングウィンドウ外の配列セグメントを含みます。"
    },
    {
      "indent": 3,
      "text": "Another possibility would be to interchange steps H1 and H2, i.e., to perform the header prediction step H2 *first*, and perform H1 and H3 only when header prediction fails. This could be a performance improvement, since the timestamp check in step H1 is very unlikely to fail, and it requires unsigned modulo arithmetic. To perform this check on every single segment is contrary to the philosophy of header prediction. We believe that this change might produce a measurable reduction in CPU time for TCP protocol processing on high-speed networks.",
      "ja": "別の可能性は、最初*ヘッダ予測ステップH2を実行するために、即ちステップH1及びH2を、交換、及びヘッダ予測が失敗した場合にのみ、H1とH3を実行することであろう。ステップH1でのタイムスタンプのチェックが失敗するのは非常にそうです、そして、それは符号なしのモジュロ演算を必要とするので、これは、パフォーマンスの向上である可能性があります。すべての単一のセグメントでこのチェックを実行すると、ヘッダ予測の哲学とは対照的です。私たちは、この変更は、高速ネットワーク上のTCPプロトコル処理のためのCPU時間の測定可能な減少をもたらす可能性があると信じています。"
    },
    {
      "indent": 3,
      "text": "However, putting H2 first would create a hazard: a segment from 2^32 bytes in the past might arrive at exactly the wrong time and be accepted mistakenly by the header-prediction step. The following reasoning has been introduced in [RFC1185] to show that the probability of this failure is negligible.",
      "ja": "しかし、パッティングH2は、第危険を作成します。過去に2 ^ 32バイトのセグメントが正確に間違った時刻に到着する可能性があり、ヘッダ予測ステップによって誤って受け入れられます。次の理由は、この失敗の確率が無視できることを示すために、[RFC1185]に導入されています。"
    },
    {
      "indent": 6,
      "text": "If all segments are equally likely to show up as old duplicates, then the probability of an old duplicate exactly matching the left window edge is the maximum segment size (MSS) divided by the size of the sequence space. This ratio must be less than 2^-16, since MSS must be < 2^16; for example, it will be (2^12)/(2^32) = 2^-20 for [a 100 Mbit/s] link. However, the older a segment is, the less likely it is to be retained in the Internet, and under any reasonable model of segment lifetime the probability of an old duplicate exactly at the left window edge must be much smaller than 2^-16.",
      "ja": "すべてのセグメントが同じくらい古い重複を表示することも同様に可能性がある場合、正確左ウィンドウエッジをマッチング古い重複の確率は、配列空間のサイズで割った最大セグメントサイズ（MSS）です。 MSSは<^ 16 2でなければならないので、この比率は、2 ^ -16未満でなければなりません。例えば、それは、（2 ^ 12）/（2 ^ 32）= 100メガビット/ s]のリンクのための2 ^ -20となります。しかし、古いセグメントは、可能性が低いことは、インターネット内に保持されるようになっている、セグメント生涯のいずれかの合理的なモデルで正確に左のウィンドウの端にある古い重複の確率は2 ^ -16よりもはるかに小さくなければなりません。"
    },
    {
      "indent": 6,
      "text": "The 16 bit TCP checksum also allows a basic unreliability of one part in 2^16. A protocol mechanism whose reliability exceeds the reliability of the TCP checksum should be considered \"good enough\", i.e., it won't contribute significantly to the overall error rate. We therefore believe we can ignore the problem of an old duplicate being accepted by doing header prediction before checking the timestamp. [Note: the notation for exponentiation has been changed from how it appeared in RFC 1185.]",
      "ja": "16ビットのTCPチェックサムも2 ^ 16分の1の基本的な信頼性の欠如することができます。その信頼性TCPチェックサムの信頼性を超えたプロトコルメカニズムは、すなわち、それは全体の誤差率に大きく貢献していないだろう、「十分に良い」と考えるべきです。そこで我々は、我々は、タイムスタンプをチェックする前に、ヘッダー予測を行うことによって受け入れられている古い重複の問題を無視することができると信じています。 [注：べき乗のための表記法は、それがRFC 1185に現れ方法から変更されています]"
    },
    {
      "indent": 3,
      "text": "However, this probabilistic argument is not universally accepted, and the consensus at present is that the performance gain does not justify the hazard in the general case. It is therefore recommended that H2 follow H1.",
      "ja": "しかし、この確率論引数が普遍的に受け入れていない、そして現在のコンセンサスは、パフォーマンスの向上は、一般的なケースでは危険を正当化しないということです。したがって、H2はH1に従うことをお勧めします。"
    },
    {
      "indent": 0,
      "text": "5.7. IP Fragmentation",
      "section_title": true,
      "ja": "5.7。 IPフラグメンテーション"
    },
    {
      "indent": 3,
      "text": "At high data rates, the protection against old segments provided by PAWS can be circumvented by errors in IP fragment reassembly (see [RFC4963]). The only way to protect against incorrect IP fragment reassembly is to not allow the segments to be fragmented. This is done by setting the Don't Fragment (DF) bit in the IP header.",
      "ja": "高いデータレートでは、PAWSが提供する古いセグメントに対する保護は、（[RFC4963]を参照）IPフラグメント再構成中にエラーが発生することによって回避することができます。間違ったIPフラグメント再構成から保護する唯一の方法は、セグメントを細分化することを許可しないことです。これは、IPヘッダにDo not Fragment（DF）ビットを設定することによって行われます。"
    },
    {
      "indent": 3,
      "text": "Setting the DF bit implies the use of Path MTU Discovery as described in [RFC1191], [RFC1981], and [RFC4821]; thus, any TCP implementation that implements PAWS MUST also implement Path MTU Discovery.",
      "ja": "[RFC1191]、[RFC1981]及び[RFC4821]に記載されているようにDFビットを設定すると、パスMTU探索の使用を意味します。したがって、PAWSを実装する任意のTCPの実装はまた、パスMTUディスカバリを実装しなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.8. Duplicates from Earlier Incarnations of Connection",
      "section_title": true,
      "ja": "5.8。接続の以前のインカネーションからの重複"
    },
    {
      "indent": 3,
      "text": "The PAWS mechanism protects against errors due to sequence number wrap-around on high-speed connections. Segments from an earlier incarnation of the same connection are also a potential cause of old duplicate errors. In both cases, the TCP mechanisms to prevent such errors depend upon the enforcement of an MSL by the Internet (IP) layer (see the Appendix of RFC 1185 for a detailed discussion). Unlike the case of sequence space wrap-around, the MSL required to prevent old duplicate errors from earlier incarnations does not depend upon the transfer rate. If the IP layer enforces the recommended 2-minute MSL of TCP, and if the TCP rules are followed, TCP connections will be safe from earlier incarnations, no matter how high the network speed. Thus, the PAWS mechanism is not required for this case.",
      "ja": "PAWSメカニズムは、高速接続のシーケンス番号ラップアラウンドによる誤差を防ぎます。同じ接続の以前の化身からのセグメントは、古い重複エラーの潜在的な原因です。両方の場合において、このようなエラーを防止するために、TCPメカニズムはインターネット（IP）層（詳細な議論のためにRFC 1185の付録を参照）MSLの施行に依存します。シーケンス空間の場合とは異なり、ラップアラウンド、以前の化身から古い重複エラーを防止するために必要なMSLは、転送速度に依存しません。 IP層は、TCPの推奨2分MSLを強制する場合は、TCPのルールに従っている場合、および、TCP接続がどんなに高いネットワーク速度、以前の化身から安全ではないでしょう。このように、PAWSメカニズムはこの場合には必要ありません。"
    },
    {
      "indent": 3,
      "text": "We may still ask whether the PAWS mechanism can provide additional security against old duplicates from earlier connections, allowing us to relax the enforcement of MSL by the IP layer. Appendix B explores this question, showing that further assumptions and/or mechanisms are required, beyond those of PAWS. This is not part of the current extension.",
      "ja": "我々はまだPAWSメカニズムは、私たちは、IP層でMSLの施行を緩和することができ、以前の接続から古い写しに対して追加のセキュリティを提供できるかどうかを尋ねることができます。付録Bは、さらに仮定および/または機構は、PAWSのそれを超えて、必要とされていることを示し、この質問を探ります。これは、現在の拡張機能の一部ではありません。"
    },
    {
      "indent": 0,
      "text": "6. Conclusions and Acknowledgments",
      "section_title": true,
      "ja": "6.結論と謝辞"
    },
    {
      "indent": 3,
      "text": "This memo presented a set of extensions to TCP to provide efficient operation over large bandwidth * delay product paths and reliable operation over very high-speed paths. These extensions are designed to provide compatible interworking with TCP stacks that do not implement the extensions.",
      "ja": "このメモは、大きな帯域幅にわたって効率的な動作を提供するために、TCPの拡張セットを提示*遅延製品のパスと非常に高速な経路を介して信頼性の高い動作。これらの拡張機能は、拡張機能を実装していないTCPスタックとの互換性のインターワーキングを提供するように設計されています。"
    },
    {
      "indent": 3,
      "text": "These mechanisms are implemented using TCP options for scaled windows and timestamps. The timestamps are used for two distinct mechanisms: RTTM and PAWS.",
      "ja": "これらのメカニズムは、スケールの窓やタイムスタンプのためのTCPオプションを使用して実装されています。 RTTMとPAWS：タイムスタンプは、2つの別個の機構のために使用されます。"
    },
    {
      "indent": 3,
      "text": "The Window Scale option was originally suggested by Mike St. Johns of USAF/DCA. The present form of the option was suggested by Mike Karels of UC Berkeley in response to a more cumbersome scheme defined by Van Jacobson. Lixia Zhang helped formulate the PAWS mechanism description in [RFC1185].",
      "ja": "ウィンドウスケールオプションはもともとUSAF / DCAのマイク・セントジョンズによって示唆されました。オプションの現在の形は、バン・ジェイコブソンによって定義され、より面倒なスキームに応じて、UCバークレー校のマイク・Karelsによって示唆されました。 Lixiaチャンは、[RFC1185]でPAWSメカニズムの説明を策定助けました。"
    },
    {
      "indent": 3,
      "text": "Finally, much of this work originated as the result of discussions within the End-to-End Task Force on the theoretical limitations of transport protocols in general and TCP in particular. Task force members and others on the end2end-interest list have made valuable contributions by pointing out flaws in the algorithms and the documentation. Continued discussion and development since the publication of [RFC1323] originally occurred in the IETF TCP Large Windows Working Group, later on in the End-to-End Task Force, and most recently in the IETF TCP Maintenance Working Group. The authors are grateful for all these contributions.",
      "ja": "最後に、この作業の多くは、一般、特にTCPでのトランスポートプロトコルの理論的な限界にエンドツーエンドのタスクフォース内での議論の結果として始まりました。 end2end金利リスト上のタスクフォースのメンバーや他の人はアルゴリズムやドキュメントの不備を指摘することで、貴重な貢献をしました。 [RFC1323]の出版以来、議論と開発を続け、もともとIETF TCPメンテナンス作業部会の中で最も最近のエンドツーエンドのタスクフォースでは、後に、IETF TCP大Windowsのワーキンググループで発生した、と。著者は、これらすべての貢献に感謝しています。"
    },
    {
      "indent": 0,
      "text": "7. Security Considerations",
      "section_title": true,
      "ja": "7.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "The TCP sequence space is a fixed size, and as the window becomes larger, it becomes easier for an attacker to generate forged packets that can fall within the TCP window and be accepted as valid segments. While use of timestamps and PAWS can help to mitigate this, when using PAWS, if an attacker is able to forge a packet that is acceptable to the TCP connection, a timestamp that is in the future would cause valid segments to be dropped due to PAWS checks. Hence, implementers should take care to not open the TCP window drastically beyond the requirements of the connection.",
      "ja": "TCPシーケンススペースは、固定サイズであり、ウィンドウが大きいほど、それはTCPウィンドウ内に入ることができ、有効なセグメントとして受け入れられる偽造パケットを生成するために、攻撃者が容易になります。タイムスタンプとPAWSの使用は、攻撃者がTCP接続に許容されるパケットを偽造することができる場合、PAWSを使用した場合、これを緩和するのに役立ちますが、将来的にあるタイムスタンプはPAWSのためにドロップされる、有効なセグメントを引き起こしますチェック。したがって、実装者は、接続の要件を超えて大幅にTCPウィンドウを開かないように注意しなければなりません。"
    },
    {
      "indent": 3,
      "text": "See [RFC5961] for mitigation strategies to blind in-window attacks.",
      "ja": "で、窓の攻撃を盲目にする緩和戦略のために[RFC5961]を参照してください。"
    },
    {
      "indent": 3,
      "text": "A naive implementation that derives the timestamp clock value directly from a system uptime clock may unintentionally leak this information to an attacker. This does not directly compromise any of the mechanisms described in this document. However, this may be valuable information to a potential attacker. It is therefore RECOMMENDED to generate a random, per-connection offset to be used with the clock source when generating the Timestamps option value (see Section 5.4). By carefully choosing this random offset, further improvements as described in [RFC6191] are possible.",
      "ja": "システム稼働時間クロックから直接タイムスタンプクロック値を導出する単純な実装は、意図せずに攻撃者にこの情報を漏洩してもよいです。これは、直接、この文書で説明するメカニズムのいずれかを妥協しません。しかし、これは潜在的な攻撃者に貴重な情報であってもよいです。したがって、（5.4節を参照）タイムスタンプ・オプション値を生成するときに、クロック・ソースで使用するオフセットごとの接続、ランダムに生成することが推奨されます。 [RFC6191]で説明されるように慎重にこのランダムオフセット、さらなる改善を選択することによって可能です。"
    },
    {
      "indent": 3,
      "text": "Expanding the TCP window beyond 64 KiB for IPv6 allows Jumbograms [RFC2675] to be used when the local network supports packets larger than 64 KiB. When larger TCP segments are used, the TCP checksum becomes weaker.",
      "ja": "IPv6の64 KiBのを超えてTCPウィンドウを展開すると、ローカルネットワークが64 KiBのより大きなパケットをサポートしているときジャンボグラム[RFC2675]を使用することができます。大きなTCPセグメントが使用される場合、TCPチェックサムが弱くなります。"
    },
    {
      "indent": 3,
      "text": "Mechanisms to protect the TCP header from modification should also protect the TCP options.",
      "ja": "修正からTCPヘッダを保護するためのメカニズムも、TCPオプションを保護する必要があります。"
    },
    {
      "indent": 3,
      "text": "Middleboxes and TCP options:",
      "ja": "MiddleboxesとTCPオプション："
    },
    {
      "indent": 6,
      "text": "Some middleboxes have been known to remove the TCP options described in this document from TCP segments [Honda11]. Middleboxes that remove TCP options described in this document from the <SYN> segment interfere with the selection of parameters appropriate for the session. Removing any of these options in a <SYN,ACK> segment will leave the end hosts in a state that destroys the proper operation of the protocol.",
      "ja": "いくつかのミドルボックスは、TCPセグメント[Honda11]からこの文書で説明したTCPオプションを削除することが知られています。 <SYN>セグメントからこの文書に記載されたTCPオプションを削除する中間装置は、セッションのための適切なパラメータの選択を妨害します。 <SYN、ACK>セグメントにおけるこれらのオプションのいずれかを削除すると、プロトコルの適切な動作を破壊状態でエンドホストを残します。"
    },
    {
      "indent": 6,
      "text": "* If a Window Scale option is removed from a <SYN,ACK> segment, the end hosts will not negotiate the window scaling factor correctly. Middleboxes must not remove or modify the Window Scale option from <SYN,ACK> segments.",
      "ja": "*ウィンドウスケールオプションは、<SYN、ACK>セグメントから削除された場合、エンドホストが正しくウィンドウ倍率を交渉しません。 Middleboxesは<SYN、ACK>セグメントからウィンドウスケールオプションを削除または修正してはいけません。"
    },
    {
      "indent": 6,
      "text": "* If a stateful firewall uses the window field to detect whether a received segment is inside the current window, and does not support the Window Scale option, it will not be able to correctly determine whether or not a packet is in the window. These middle boxes must also support the Window Scale option and apply the scale factor when processing segments. If the window scale factor cannot be determined, it must not do window-based processing.",
      "ja": "*ステートフルファイアウォールは、受信したセグメントは、現在のウィンドウ内で、ウィンドウスケールオプションをサポートしていないかどうかを検出するウィンドウフィールドを使用している場合、それは正しくパケットがウィンドウ内にあるかどうかを判断することはできません。これらの中間のボックスはまた、ウィンドウスケールオプションをサポートし、セグメントを処理するときにスケールファクタを適用する必要があります。ウィンドウスケールファクタを決定することができない場合は、ウィンドウ・ベースの処理をしない必要があります。"
    },
    {
      "indent": 6,
      "text": "* If the Timestamps option is removed from the <SYN> or <SYN,ACK> segments, high speed connections that need PAWS would not have that protection. Successful negotiation of the Timestamps option enforces a stricter verification of incoming segments at the receiver. If the Timestamps option was removed from a subsequent data segment after a successful negotiation (e.g., as part of resegmentation), the segment is discarded by the receiver without further processing. Middleboxes should not remove the Timestamps option.",
      "ja": "タイムスタンプオプションは、<SYN>または<SYN、ACK>セグメントから削除された場合*、PAWSを必要とする高速接続は、その保護を持っていないでしょう。タイムスタンプオプションのネゴシエーション成功は、受信機で受信したセグメントの厳格な検証を実施します。タイムスタンプオプションが成功した交渉の後に後続のデータセグメントから削除された場合（例えば、再セグメンテーションの一部として）、セグメントがさらなる処理なしに受信機によって破棄されます。ミドルボックスは、タイムスタンプオプションを削除してはいけません。"
    },
    {
      "indent": 6,
      "text": "* It must be noted that [RFC1323] doesn't address the case of the Timestamps option being dropped or selectively omitted after being negotiated, and that the update in this document may cause some broken middlebox behavior to be detected (potentially unresponsive TCP sessions).",
      "ja": "* [RFC1323]は、ネゴシエートされた後に廃棄されるか、または選択的に省略されているタイムスタンプオプションのケースに対処していないこと、およびこのドキュメントの更新は、いくつかの壊れたミドルの挙動を検出することが原因となる場合があることに留意しなければならない（潜在的に応答しなくTCPセッション） 。"
    },
    {
      "indent": 3,
      "text": "Implementations that depend on PAWS could provide a mechanism for the application to determine whether or not PAWS is in use on the connection and choose to terminate the connection if that protection doesn't exist. This is not just to protect the connection against middleboxes that might remove the Timestamps option, but also against remote hosts that do not have Timestamp support.",
      "ja": "PAWSに依存実装は、PAWSは、接続に使用されているかどうかを判断し、その保護が存在しない場合は接続を終了することを選択するためのアプリケーションのためのメカニズムを提供することができます。これは、単にタイムスタンプオプションを削除可能性があるミドルボックスに対して、だけでなく、タイムスタンプをサポートしていないリモートホストに対する接続を保護することではありません。"
    },
    {
      "indent": 0,
      "text": "7.1. Privacy Considerations",
      "section_title": true,
      "ja": "7.1。プライバシーの考慮事項"
    },
    {
      "indent": 3,
      "text": "The TCP options described in this document do not expose individual user's data. However, a naive implementation simply using the system clock as a source for the Timestamps option will reveal characteristics of the TCP, potentially allowing more targeted attacks. It is therefore RECOMMENDED to generate a random, per-connection offset to be used with the clock source when generating the Timestamps option value (see Section 5.4).",
      "ja": "この文書で説明したTCPオプションは、個々のユーザーのデータが公開されていません。しかし、単純にタイムスタンプオプションのソースとしてシステムクロックを使用した素朴な実装は、潜在的によりターゲットを絞った攻撃が可能、TCPの特性を明らかにします。したがって、（5.4節を参照）タイムスタンプ・オプション値を生成するときに、クロック・ソースで使用するオフセットごとの接続、ランダムに生成することが推奨されます。"
    },
    {
      "indent": 3,
      "text": "Furthermore, the combination, relative ordering, and padding of the TCP options described in Sections 2.2 and 3.2 will reveal additional clues to allow the fingerprinting of the system.",
      "ja": "さらに、セクション2.2と3.2で説明したTCPオプションの組み合わせ、相対的な順序、およびパディングは、システムのフィンガープリントを可能にするために、追加の手がかりを明らかにします。"
    },
    {
      "indent": 0,
      "text": "8. IANA Considerations",
      "section_title": true,
      "ja": "8. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "The described TCP options are well known from the superceded [RFC1323]. IANA has updated the \"TCP Option Kind Numbers\" table under \"TCP Parameters\" to list this document (RFC 7323) as the reference for \"Window Scale\" and \"Timestamps\".",
      "ja": "説明TCPオプションはよく取って代わら[RFC1323]から知られています。 IANAは、「ウィンドウスケール」と「タイムスタンプ」の基準として、この文書（RFC 7323）を一覧表示するには、「TCPパラメータ」の下に「TCPオプション種類番号」テーブルを更新しました。"
    },
    {
      "indent": 0,
      "text": "9. References",
      "section_title": true,
      "ja": "9.参考文献"
    },
    {
      "indent": 0,
      "text": "9.1. Normative References",
      "section_title": true,
      "ja": "9.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC793] Postel, J., \"Transmission Control Protocol\", STD 7, RFC 793, September 1981.",
      "ja": "[RFC793]ポステル、J.、 \"伝送制御プロトコル\"、STD 7、RFC 793、1981年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC1191] Mogul, J. and S. Deering, \"Path MTU discovery\", RFC 1191, November 1990.",
      "ja": "[RFC1191]ムガール人、J.とS.デアリング、 \"パスMTUディスカバリ\"、RFC 1191、1990年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 0,
      "text": "9.2. Informative References",
      "section_title": true,
      "ja": "9.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[Allman99] Allman, M. and V. Paxson, \"On Estimating End-to-End Network Path Properties\", Proceedings of the ACM SIGCOMM Technical Symposium, Cambridge, MA, September 1999, <http://aciri.org/mallman/papers/estimation-la.pdf>.",
      "ja": "[Allman99]オールマン、M.およびV.パクソン、「推定エンドツーエンドのネットワークパスの性質について」、ACM SIGCOMM技術シンポジウム、ケンブリッジ、MA、1999年9月、<http://aciri.org/mallmanの議事録/papers/estimation-la.pdf>。"
    },
    {
      "indent": 3,
      "text": "[Floyd05] Floyd, S., \"Subject: Re: [tcpm] RFC 1323: Timestamps option\", message to the TCPM mailing list, 26 January 2007, <http://www.ietf.org/mail-archive/web/tcpm/current/ msg02508.html>.",
      "ja": "[Floyd05]フロイド、S.、 \"件名：再：[tcpm] RFC 1323：タイムスタンプオプション\"、TCPMメーリングリストへのメッセージ、2007年1月26日、<http://www.ietf.org/mail-archive/web / tcpm /現在/ msg02508.html>。"
    },
    {
      "indent": 3,
      "text": "[Garlick77] Garlick, L., Rom, R., and J. Postel, \"Issues in Reliable Host-to-Host Protocols\", Proceedings of the Second Berkeley Workshop on Distributed Data Management and Computer Networks, March 1977, <http://www.rfc-editor.org/ien/ien12.txt>.",
      "ja": "[Garlick77]ガーリック、L.、ROM、R.、およびJ.ポステル、「信頼性の高いホスト間のプロトコルでの問題」、分散データ管理およびコンピュータネットワーク上の第二バークレーワークショップの議事録、1977年3月、<のhttp： //www.rfc-editor.org/ien/ien12.txt>。"
    },
    {
      "indent": 3,
      "text": "[Honda11] Honda, M., Nishida, Y., Raiciu, C., Greenhalgh, A., Handley, M., and H. Tokuda, \"Is it Still Possible to Extend TCP?\", Proceedings of the ACM Internet Measurement Conference (IMC) '11, November 2011.",
      "ja": "[Honda11]ホンダ、M.、西田、Y.、Raiciu、C.、グリーンハル、A.は、ハンドリー、M.、およびH.徳田は、 \"TCPを拡張することは可能ですか？\"、ACMインターネット計測の議事録会議（IMC）'11、2011年11月。"
    },
    {
      "indent": 3,
      "text": "[Jacobson88a] Jacobson, V., \"Congestion Avoidance and Control\", SIGCOMM '88, Stanford, CA, August 1988, <http://ee.lbl.gov/papers/congavoid.pdf>.",
      "ja": "[Jacobson88a]ジェーコブソン、V.、 \"輻輳回避とコントロール\"、SIGCOMM '88、スタンフォード大学、カリフォルニア州、1988年8月、<http://ee.lbl.gov/papers/congavoid.pdf>。"
    },
    {
      "indent": 3,
      "text": "[Jacobson90a] Jacobson, V., \"4BSD Header Prediction\", ACM Computer Communication Review, April 1990.",
      "ja": "[Jacobson90a]ジェーコブソン、V.、 \"4BSDヘッダー予測\"、ACMコンピュータコミュニケーションレビュー、1990年4月。"
    },
    {
      "indent": 3,
      "text": "[Jacobson90c] Jacobson, V., \"Subject: modified TCP congestion avoidance algorithm\", message to the End2End-Interest mailing list, 30 April 1990, <ftp://ftp.isi.edu/end2end/ end2end-interest-1990.mail>.",
      "ja": "[Jacobson90c]ジェーコブソン、V.、 \"件名：変更されたTCP輻輳回避アルゴリズム\"、End2End・インタレストメーリングリストへのメッセージ、1990年4月30日、<ftp://ftp.isi.edu/end2end/ end2end金利-1990。メール>。"
    },
    {
      "indent": 3,
      "text": "[Karn87] Karn, P. and C. Partridge, \"Estimating Round-Trip Times in Reliable Transport Protocols\", Proceedings of SIGCOMM '87, August 1987.",
      "ja": "[Karn87]カーン、P.とC.ヤマウズラ、「信頼性の高いトランスポートプロトコルに往復タイムズの推定」、SIGCOMM '87の議事録、1987年8月。"
    },
    {
      "indent": 3,
      "text": "[Kuehlewind10] Kuehlewind, M. and B. Briscoe, \"Chirping for Congestion Control - Implementation Feasibility\", November 2010, <http://bobbriscoe.net/projects/netsvc_i-f/ chirp_pfldnet10.pdf>.",
      "ja": "【Kuehlewind10] Kuehlewind、M.及びB.ブリスコウ、 \"輻輳制御のためのチャープ - 実装の可能性\"、2010年11月、<http://bobbriscoe.net/projects/netsvc_i-f/ chirp_pfldnet10.pdf>。"
    },
    {
      "indent": 3,
      "text": "[Kuzmanovic03] Kuzmanovic, A. and E. Knightly, \"TCP-LP: Low-Priority Service via End-Point Congestion Control\", 2003, <www.cs.northwestern.edu/~akuzma/doc/TCP-LP-ToN.pdf>.",
      "ja": "[Kuzmanovic03] Kuzmanovic、A.とE.騎士、 \"TCP-LP：エンドポイントの輻輳制御を経由して、優先度の低いサービス\"、2003年、<www.cs.northwestern.edu/~akuzma/doc/TCP-LP-ToN .PDF>。"
    },
    {
      "indent": 3,
      "text": "[Ludwig00] Ludwig, R. and K. Sklower, \"The Eifel Retransmission Timer\", ACM SIGCOMM Computer Communication Review Volume 30 Issue 3, July 2000, <http://ccr.sigcomm.org/archive/2000/july00/ LudwigFinal.pdf>.",
      "ja": "[Ludwig00]ルートヴィヒ、R.とK. Sklower、 \"アイフェル再送信タイマー\"、ACM SIGCOMMコンピュータコミュニケーションレビュー30巻3号、2000年7月、<http://ccr.sigcomm.org/archive/2000/july00/ LudwigFinal .PDF>。"
    },
    {
      "indent": 3,
      "text": "[Martin03] Martin, D., \"Subject: [Tsvwg] RFC 1323.bis\", message to the TSVWG mailing list, 30 September 2003, <http://www.ietf.org/mail-archive/web/tsvwg/current/ msg04435.html>.",
      "ja": "[Martin03]マーティン、D.は、：、TSVWGメーリングリストへのメッセージ、2003年9月30日、<http://www.ietf.org/mail-archive/web/tsvwg/を \"件名[TSVWG] RFCは1323.bis\"現在/ msg04435.html>。"
    },
    {
      "indent": 3,
      "text": "[Medina04] Medina, A., Allman, M., and S. Floyd, \"Measuring Interactions Between Transport Protocols and Middleboxes\", Proceedings of the ACM SIGCOMM/USENIX Internet Measurement Conference, October 2004, <http://www.icir.net/tbit/tbit-Aug2004.pdf>.",
      "ja": "[Medina04]メディナ、A.、オールマン、M.、およびS.フロイド、 \"トランスポートプロトコルとのMiddleboxes間の相互作用を測定する\"、ACM SIGCOMM / USENIXインターネット測定コンファレンス、2004年10月の議事録、<のhttp：//www.icir .NET / TBIT / TBIT-Aug2004.pdf>。"
    },
    {
      "indent": 3,
      "text": "[Medina05] Medina, A., Allman, M., and S. Floyd, \"Measuring the Evolution of Transport Protocols in the Internet\", ACM Computer Communication Review Volume 35, No. 2, April 2005, <http://icir.net/floyd/papers/TCPevolution-Mar2005.pdf>.",
      "ja": "[Medina05]メディナ、A.、オールマン、M.、およびS.フロイド、 \"インターネットにおけるトランスポートプロトコルの進化を測定する\"、ACMコンピュータコミュニケーションレビュー35巻、第2号、2005年4月、<のhttp：// icir .NET /フロイド/論文/ TCPevolution-Mar2005.pdf>。"
    },
    {
      "indent": 3,
      "text": "[RE-1323BIS] Oppermann, A., \"Subject: Re: [tcpm] I-D Action: draft-ietf.tcpm-1323bis-13.txt\", message to the TCPM mailing list, 01 June 2013, <http://www.ietf.org/ mail-archive/web/tcpm/current/msg08001.html>.",
      "ja": "[RE-1323BIS] Oppermannの、A.、 \"件名：再：[tcpm] IDアクション：ドラフト-ietf.tcpm-1323bis-13.txt\"、TCPMメーリングリストへのメッセージ、2013年6月1日、<のhttp：// www.ietf.org/メールアーカイブ/ウェブ/ tcpm /現在/ msg08001.html>。"
    },
    {
      "indent": 3,
      "text": "[RFC1072] Jacobson, V. and R. Braden, \"TCP extensions for long-delay paths\", RFC 1072, October 1988.",
      "ja": "[RFC1072]ジェーコブソン、V.およびR.ブレーデン、 \"長時間の遅延経路のためのTCP拡張\"、RFC 1072、1988年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC1122] Braden, R., \"Requirements for Internet Hosts - Communication Layers\", STD 3, RFC 1122, October 1989.",
      "ja": "[RFC1122]ブレーデン、R.、 \"インターネットホストのための要件 - 通信層\"、STD 3、RFC 1122、1989年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC1185] Jacobson, V., Braden, B., and L. Zhang, \"TCP Extension for High-Speed Paths\", RFC 1185, October 1990.",
      "ja": "[RFC1185]ジェーコブソン、V.、ブレーデン、B.、およびL.チャン、 \"高速パスのTCP拡張\"、RFC 1185、1990年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC1323] Jacobson, V., Braden, B., and D. Borman, \"TCP Extensions for High Performance\", RFC 1323, May 1992.",
      "ja": "[RFC1323]ジェーコブソン、V.、ブレーデン、B.、およびD.ボーマン、 \"ハイパフォーマンスのためのTCP拡張\"、RFC 1323、1992年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC1981] McCann, J., Deering, S., and J. Mogul, \"Path MTU Discovery for IP version 6\", RFC 1981, August 1996.",
      "ja": "[RFC1981]マッキャン、J.、デアリング、S.、およびJ.ムガール人、RFC 1981、1996年8月 \"IPバージョン6のパスMTUディスカバリー\"。"
    },
    {
      "indent": 3,
      "text": "[RFC2018] Mathis, M., Mahdavi, J., Floyd, S., and A. Romanow, \"TCP Selective Acknowledgment Options\", RFC 2018, October 1996.",
      "ja": "[RFC2018]マティス、M.、Mahdavi、J.、フロイド、S.、とA. Romanow、 \"TCPの選択確認応答オプション\"、RFC 2018、1996年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC2675] Borman, D., Deering, S., and R. Hinden, \"IPv6 Jumbograms\", RFC 2675, August 1999.",
      "ja": "[RFC2675]ボーマン、D.、デアリング、S.、およびR. Hindenと \"IPv6のジャンボグラム\"、RFC 2675、1999年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC2883] Floyd, S., Mahdavi, J., Mathis, M., and M. Podolsky, \"An Extension to the Selective Acknowledgement (SACK) Option for TCP\", RFC 2883, July 2000.",
      "ja": "[RFC2883]フロイド、S.、Mahdavi、J.、マティス、M.、およびM.ポドルスキー、 \"TCPのための選択的確認応答（SACK）オプションの拡張\"、RFC 2883、2000年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC3522] Ludwig, R. and M. Meyer, \"The Eifel Detection Algorithm for TCP\", RFC 3522, April 2003.",
      "ja": "[RFC3522]ルートヴィヒ、R.及びM.マイヤー、 \"TCPのためのアイフェル検出アルゴリズム\"、RFC 3522、2003年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC4015] Ludwig, R. and A. Gurtov, \"The Eifel Response Algorithm for TCP\", RFC 4015, February 2005.",
      "ja": "[RFC4015]ルートヴィヒ、R.とA. Gurtov、 \"TCPのためのアイフェルレスポンスアルゴリズム\"、RFC 4015、2005年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC4821] Mathis, M. and J. Heffner, \"Packetization Layer Path MTU Discovery\", RFC 4821, March 2007.",
      "ja": "[RFC4821]マシス、M.とJ. Heffner、 \"パケット化レイヤのパスMTUディスカバリ\"、RFC 4821、2007年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC4963] Heffner, J., Mathis, M., and B. Chandler, \"IPv4 Reassembly Errors at High Data Rates\", RFC 4963, July 2007.",
      "ja": "[RFC4963] Heffner、J.、マティス、M.、およびB.チャンドラー、 \"高速データレートでのIPv4の再構築エラー\"、RFC 4963、2007年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC5681] Allman, M., Paxson, V., and E. Blanton, \"TCP Congestion Control\", RFC 5681, September 2009.",
      "ja": "[RFC5681]オールマン、M.、パクソン、V.、およびE.ブラントン、 \"TCP輻輳制御\"、RFC 5681、2009年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC5961] Ramaiah, A., Stewart, R., and M. Dalal, \"Improving TCP's Robustness to Blind In-Window Attacks\", RFC 5961, August 2010.",
      "ja": "[RFC5961] Ramaiah、A.、スチュワート、R.、およびM. Dalal、RFC 5961、2010年8月 \"ブラインドウィンドウ攻撃に対してTCPのロバスト性を向上させます\"。"
    },
    {
      "indent": 3,
      "text": "[RFC6191] Gont, F., \"Reducing the TIME-WAIT State Using TCP Timestamps\", BCP 159, RFC 6191, April 2011.",
      "ja": "[RFC6191] Gont、F.、 \"TCPタイムスタンプを使用してTIME-WAIT状態の削減\"、BCP 159、RFC 6191、2011年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC6298] Paxson, V., Allman, M., Chu, J., and M. Sargent, \"Computing TCP's Retransmission Timer\", RFC 6298, June 2011.",
      "ja": "[RFC6298]パクソン、V.、オールマン、M.、チュー、J.、およびM.サージェント、 \"コンピューティングTCPの再送信タイマー\"、RFC 6298、2011年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC6528] Gont, F. and S. Bellovin, \"Defending against Sequence Number Attacks\", RFC 6528, February 2012.",
      "ja": "[RFC6528] Gont、F.およびS. Bellovin氏、 \"シーケンス番号攻撃からの保護\"、RFC 6528、2012年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC6675] Blanton, E., Allman, M., Wang, L., Jarvinen, I., Kojo, M., and Y. Nishida, \"A Conservative Loss Recovery Algorithm Based on Selective Acknowledgment (SACK) for TCP\", RFC 6675, August 2012.",
      "ja": "[RFC6675]ブラントン、E.、オールマン、M.、王、L.、Jarvinen、I.、古城、M.、およびY.西田、 \"TCPのための選択的確認応答（SACK）に基づいて、保存的損失回復アルゴリズム\"、 RFC 6675、2012年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC6691] Borman, D., \"TCP Options and Maximum Segment Size (MSS)\", RFC 6691, July 2012.",
      "ja": "[RFC6691]ボーマン、D.、 \"TCPオプションと最大セグメントサイズ（MSS）\"、RFC 6691、2012年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC6817] Shalunov, S., Hazel, G., Iyengar, J., and M. Kuehlewind, \"Low Extra Delay Background Transport (LEDBAT)\", RFC 6817, December 2012.",
      "ja": "[RFC6817] Shalunov、S.、ヘーゼル、G.、アイアンガー、J.、およびM. Kuehlewind、 \"低余分な遅延の背景トランスポート（LEDBAT）\"、RFC 6817、2012年12月。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Implementation Suggestions",
      "ja": "付録A.実装の提案"
    },
    {
      "indent": 3,
      "text": "TCP Option Layout",
      "ja": "TCPオプションのレイアウト"
    },
    {
      "indent": 6,
      "text": "The following layout is recommended for sending options on non-<SYN> segments to achieve maximum feasible alignment of 32-bit and 64-bit machines.",
      "ja": "以下のレイアウトは、32ビットおよび64ビットマシンの最大可能アラインメントを達成するために、非<SYN>セグメントのオプションを送信するために推奨されます。"
    },
    {
      "indent": 19,
      "text": "+--------+--------+--------+--------+\n|   NOP  |  NOP   |  TSopt |   10   |\n+--------+--------+--------+--------+\n|          TSval timestamp          |\n+--------+--------+--------+--------+\n|          TSecr timestamp          |\n+--------+--------+--------+--------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Interaction with the TCP Urgent Pointer",
      "ja": "TCP緊急ポインタとの相互作用"
    },
    {
      "indent": 6,
      "text": "The TCP Urgent Pointer, like the TCP window, is a 16-bit value. Some of the original discussion for the TCP Window Scale option included proposals to increase the Urgent Pointer to 32 bits. As it turns out, this is unnecessary. There are two observations that should be made:",
      "ja": "TCP緊急ポインタは、TCPウィンドウのように、16ビット値です。 TCPウィンドウスケールオプションの元の議論の中には、32ビットに緊急ポインタを増加させるための提案が含まれています。結局のところ、これは不要です。なされるべきである2つの観測があります。"
    },
    {
      "indent": 6,
      "text": "(1) With IP version 4, the largest amount of TCP data that can be sent in a single packet is 65495 bytes (64 KiB - 1 - size of fixed IP and TCP headers).",
      "ja": "（1）IPバージョン4では、単一のパケットで送信できるTCPデータの最大量は65495バイト（ -  1  - 固定IPおよびTCPヘッダのサイズ64 KiBの）です。"
    },
    {
      "indent": 6,
      "text": "(2) Updates to the Urgent Pointer while the user is in \"urgent mode\" are invisible to the user.",
      "ja": "（2）緊急ポインタの更新、ユーザが「緊急モード」であるときに、ユーザーには見えません。"
    },
    {
      "indent": 6,
      "text": "This means that if the Urgent Pointer points beyond the end of the TCP data in the current segment, then the user will remain in urgent mode until the next TCP segment arrives. That segment will update the Urgent Pointer to a new offset, and the user will never have left urgent mode.",
      "ja": "これは緊急ポインタが現在のセグメントにおけるTCPデータの終わりを超えて指す場合には、次のTCPセグメントが到着するまで、ユーザは緊急モードのままにすることを意味します。そのセグメントは、新しいオフセットに緊急ポインタが更新され、ユーザーは緊急モードを残したことがないだろう。"
    },
    {
      "indent": 6,
      "text": "Thus, to properly implement the Urgent Pointer, the sending TCP only has to check for overflow of the 16-bit Urgent Pointer field before filling it in. If it does overflow, than a value of 65535 should be inserted into the Urgent Pointer.",
      "ja": "したがって、適切に緊急ポインタを実装するために、送信側TCPのみでそれを充填する前に16ビット緊急ポインタフィールドのオーバーフローをチェックする。それはオーバーフローした場合は、緊急ポインタに挿入されるべきである65535の値よりも有しています。"
    },
    {
      "indent": 6,
      "text": "The same technique applies to IP version 6, except in the case of IPv6 Jumbograms. When IPv6 Jumbograms are supported, [RFC2675] requires additional steps for dealing with the Urgent Pointer; these steps are described in Section 5.2 of [RFC2675].",
      "ja": "同じ技術は、IPv6ジャンボグラムの場合を除いて、IPバージョン6に適用されます。 IPv6のジャンボグラムがサポートされている場合は、[RFC2675]は緊急ポインタに対処するための追加の手順が必要です。これらの手順は、[RFC2675]のセクション5.2に記載されています。"
    },
    {
      "indent": 0,
      "text": "Appendix B. Duplicates from Earlier Connection Incarnations",
      "ja": "付録B.重複以前の接続のインカネーションから"
    },
    {
      "indent": 3,
      "text": "There are two cases to be considered: (1) a system crashing (and losing connection state) and restarting, and (2) the same connection being closed and reopened without a loss of host state. These will be described in the following two sections.",
      "ja": "考慮すべき2つのケースがある：（1）システムがクラッシュ（および接続状態を失う）と再起動、及び（2）のホスト状態を失うことなく、同じ接続を閉じて再び開いています。これらは、以下の2つのセクションで説明します。"
    },
    {
      "indent": 0,
      "text": "B.1. System Crash with Loss of State",
      "ja": "B.1。国家の損失でシステムクラッシュ"
    },
    {
      "indent": 3,
      "text": "TCP's quiet time of one MSL upon system startup handles the loss of connection state in a system crash/restart. For an explanation, see, for example, \"Knowing When to Keep Quiet\" in the TCP protocol specification [RFC0793]. The MSL that is required here does not depend upon the transfer speed. The current TCP MSL of 2 minutes seemed acceptable as an operational compromise, when many host systems used to take this long to boot after a crash. Current host systems can boot considerably faster.",
      "ja": "システムの起動時に1 MSLのTCPの静かな時間は、システムクラッシュ/再起動で接続状態の損失を処理します。説明については、例えば、TCPプロトコル仕様[RFC0793]で「静かにするときに知って」を参照してください。ここで必要とされるMSLは、転送速度に依存しません。多くのホストシステムがクラッシュした後に起動するために、この長いを取るために使用された場合2分の現在のTCP MSLは、運用の妥協として許容可能なように見えました。現在のホストシステムがかなり速く起動することができます。"
    },
    {
      "indent": 3,
      "text": "The Timestamps option may be used to ease the MSL requirements (or to provide additional security against data corruption). If timestamps are being used and if the timestamp clock can be guaranteed to be monotonic over a system crash/restart, i.e., if the first value of the sender's timestamp clock after a crash/restart can be guaranteed to be greater than the last value before the restart, then a quiet time is unnecessary.",
      "ja": "タイムスタンプオプションは、MSLの要件を緩和するために（またはデータ破損に対する追加のセキュリティを提供するために）使用することができます。タイムスタンプが使用されている場合は、クラッシュ/再起動前の最後の値よりも大きくなるように、送信者のタイムスタンプクロックの最初の値が保証することができた後ならば、タイムスタンプのクロックは、すなわち、システムクラッシュ/再起動で単調であることが保証できるのであれば再起動は、その後、静かな時間が不要です。"
    },
    {
      "indent": 3,
      "text": "To dispense totally with the quiet time would require that the host clock be synchronized to a time source that is stable over the crash/ restart period, with an accuracy of one timestamp clock tick or better. We can back off from this strict requirement to take advantage of approximate clock synchronization. Suppose that the clock is always resynchronized to within N timestamp clock ticks and that booting (extended with a quiet time, if necessary) takes more than N ticks. This will guarantee monotonicity of the timestamps, which can then be used to reject old duplicates even without an enforced MSL.",
      "ja": "ホストクロックが1つのタイムスタンプのクロックティック以上の精度で、クラッシュ/再起動にわたって安定したタイムソースに同期させることが必要となる静かな時間で完全に不要にします。私たちは、おおよそのクロック同期を活用するために、この厳格な要件から後退することができます。クロックは常にNのタイムスタンプクロックティックと（必要に応じて、静かな時間を延長）は、そのブートがNティック以上かかる以内に再同期されていることとします。これは、その後も、強制MSLせずに古い写しを拒絶するために使用することができ、タイムスタンプ、の単調性が保証されます。"
    },
    {
      "indent": 0,
      "text": "B.2. Closing and Reopening a Connection",
      "ja": "B.2。接続を閉じると再オープン"
    },
    {
      "indent": 3,
      "text": "When a TCP connection is closed, a delay of 2*MSL in TIME-WAIT state ties up the socket pair for 4 minutes (see Section 3.5 of [RFC0793]). Applications built upon TCP that close one connection and open a new one (e.g., an FTP data transfer connection using Stream mode) must choose a new socket pair each time. The TIME-WAIT delay serves two different purposes: (a) Implement the full-duplex reliable close handshake of TCP.",
      "ja": "場合TCP接続が（[RFC0793]のセクション3.5を参照）、TIME-WAIT状態の関係において2 * MSL最大4分間ソケットペアの遅延を閉じています。一つの接続を閉じ、新しいもの（例えば、ストリームモードを使用してFTPのデータ転送接続）を開き、TCP上に構築されたアプリケーションは、新しいソケットペアを毎回選択する必要があります。 TIME-WAIT遅延は二つの異なる目的を果たす：（a）は、TCPの全二重信頼近いハンドシェイクを実装します。"
    },
    {
      "indent": 8,
      "text": "The proper time to delay the final close step is not really\nrelated to the MSL; it depends instead upon the RTO for the FIN\nsegments and, therefore, upon the RTT of the path.  (It could be\nargued that the side that is sending a FIN knows what degree of\nreliability it needs, and therefore it should be able to\ndetermine the length of the TIME-WAIT delay for the FIN's\nrecipient.  This could be accomplished with an appropriate TCP\noption in FIN segments.)",
      "raw": true
    },
    {
      "indent": 8,
      "text": "Although there is no formal upper bound on RTT, common network engineering practice makes an RTT greater than 1 minute very unlikely. Thus, the 4-minute delay in TIME-WAIT state works satisfactorily to provide a reliable full-duplex TCP close. Note again that this is independent of MSL enforcement and network speed.",
      "ja": "RTT上の正式な上限はありませんが、一般的なネットワークエンジニアリングの実践は、RTTよりも大きい1分が非常に低くなります。このように、TIME-WAIT状態で4分の遅延が信頼性の高い全二重TCPクローズを提供するために、満足に動作します。これは、MSLの施行とネットワーク速度とは無関係であることを再度注意してください。"
    },
    {
      "indent": 8,
      "text": "The TIME-WAIT state could cause an indirect performance problem if an application needed to repeatedly close one connection and open another at a very high frequency, since the number of available TCP ports on a host is less than 2^16. However, high network speeds are not the major contributor to this problem; the RTT is the limiting factor in how quickly connections can be opened and closed. Therefore, this problem will be no worse at high transfer speeds.",
      "ja": "ホストで使用可能なTCPポートの数が2未満^ 16であるため、アプリケーションは、繰り返し近い一つの接続に必要な、非常に高い周波数で別のを開くと、TIME-WAIT状態は、間接的なパフォーマンス上の問題を引き起こす可能性があります。しかし、高いネットワーク速度は、この問題に対する主要な貢献者ではありません。 RTTは、開閉することができるどのように迅速な接続の制限要因です。したがって、この問題は、高い転送速度で悪くないことはないだろう。"
    },
    {
      "indent": 3,
      "text": "(b) Allow old duplicate segments to expire.",
      "ja": "（b）は、古い重複セグメントが失効することを許可します。"
    },
    {
      "indent": 8,
      "text": "To replace this function of TIME-WAIT state, a mechanism would\nhave to operate across connections.  PAWS is defined strictly\nwithin a single connection; the last timestamp (TS.Recent) is\nkept in the connection control block and discarded when a\nconnection is closed.",
      "raw": true
    },
    {
      "indent": 8,
      "text": "An additional mechanism could be added to the TCP, a per-host cache of the last timestamp received from any connection. This value could then be used in the PAWS mechanism to reject old duplicate segments from earlier incarnations of the connection, if the timestamp clock can be guaranteed to have ticked at least once since the old connection was open. This would require that the TIME-WAIT delay plus the RTT together must be at least one tick of the sender's timestamp clock. Such an extension is not part of the proposal of this RFC.",
      "ja": "追加のメカニズムはTCP、任意の接続から受信した最後のタイムスタンプのホストごとのキャッシュに追加することができます。タイムスタンプのクロックは、古い接続がオープンして以来、少なくとも一度はチェックが入っていることを保証することができた場合、この値は、接続の以前の化身から古い重複セグメントを拒絶するようにPAWSメカニズムで使用することができます。これは、RTTプラスTIME-WAIT遅延が一緒に送信者のタイムスタンプクロックの少なくとも1つの目盛りでなければならないことを必要とするであろう。このような拡張は、このRFCの提案の一部ではありません。"
    },
    {
      "indent": 8,
      "text": "Note that this is a variant on the mechanism proposed by Garlick, Rom, and Postel [Garlick77], which required each host to maintain connection records containing the highest sequence numbers on every connection. Using timestamps instead, it is only necessary to keep one quantity per remote host, regardless of the number of simultaneous connections to that host.",
      "ja": "これは、すべての接続上の最高のシーケンス番号を含む接続レコードを維持するために、各ホストが必要ガーリック、ROM、およびポステル[Garlick77]によって提案された機構、オン変異体であることに留意されたいです。代わりにタイムスタンプを使用して、関係なく、そのホストへの同時接続数の、リモートホストごとに1つの量を維持するために必要なだけです。"
    },
    {
      "indent": 0,
      "text": "Appendix C. Summary of Notation",
      "ja": "表記の付録C.まとめ"
    },
    {
      "indent": 3,
      "text": "The following notation has been used in this document.",
      "ja": "以下の表記は、このドキュメントで使用されてきました。"
    },
    {
      "indent": 3,
      "text": "Options",
      "ja": "オプション"
    },
    {
      "indent": 6,
      "text": "WSopt: TCP Window Scale option TSopt: TCP Timestamps option",
      "ja": "WSopt：TCPウィンドウスケールオプションのTSopt：TCPタイムスタンプオプション"
    },
    {
      "indent": 3,
      "text": "Option Fields",
      "ja": "オプションフィールド"
    },
    {
      "indent": 6,
      "text": "shift.cnt: Window scale byte in WSopt TSval: 32-bit Timestamp Value field in TSopt TSecr: 32-bit Timestamp Reply field in TSopt",
      "ja": "TSopt TSecr 32ビットタイムスタンプ値フィールド：shift.cnt：WSopt TSvalにおけるウィンドウスケールバイトは32ビットタイムスタンプTSoptのフィールドを返信"
    },
    {
      "indent": 3,
      "text": "Option Fields in Current Segment",
      "ja": "現在のセグメントにおけるオプションフィールド"
    },
    {
      "indent": 6,
      "text": "SEG.TSval: TSval field from TSopt in current segment SEG.TSecr: TSecr field from TSopt in current segment SEG.WSopt: 8-bit value in WSopt",
      "ja": "SEG.TSval：現在のセグメントSEG.TSecrでTSoptからTSvalフィールド：現在のセグメントSEG.WSoptでTSoptからTSecrフィールド：WSopt 8ビット値"
    },
    {
      "indent": 3,
      "text": "Clock Values",
      "ja": "クロック値"
    },
    {
      "indent": 6,
      "text": "my.TSclock: System-wide source of 32-bit timestamp values my.TSclock.rate: Period of my.TSclock (1 ms to 1 sec) Snd.TSoffset: An offset for randomizing Snd.TSclock Snd.TSclock: my.TSclock + Snd.TSoffset",
      "ja": "my.TSclock：32ビットのタイムスタンプ値my.TSclock.rateのシステム全体源：my.TSclockの期間（1秒に1ミリ秒）Snd.TSoffset：Snd.TSclock Snd.TSclockをランダム化するためのオフセットmy.TSclock + Snd.TSoffset"
    },
    {
      "indent": 3,
      "text": "Per-Connection State Variables",
      "ja": "接続ごとの状態変数"
    },
    {
      "indent": 6,
      "text": "TS.Recent: Latest received Timestamp Last.ACK.sent: Last ACK field sent Snd.TS.OK: 1-bit flag Snd.WS.OK: 1-bit flag Rcv.Wind.Shift: Receive window scale exponent Snd.Wind.Shift: Send window scale exponent Start.Time: Snd.TSclock value when the segment being timed was sent (used by code from before RFC 1323).",
      "ja": "TS.Recent：最新のタイムスタンプLast.ACK.sentを受けた：最後のACKフィールドがSnd.TS.OKを送った：1ビットのフラグSnd.WS.OK：1ビットのフラグRcv.Wind.Shift：ウィンドウスケール指数Snd.Windを受信.Shift：ウィンドウスケール指数Start.Timeを送る：Snd.TSclock値をセグメントが送信されたタイミングされたときに（RFC 1323の前のコードによって使用されます）。"
    },
    {
      "indent": 3,
      "text": "Procedure",
      "ja": "手順"
    },
    {
      "indent": 6,
      "text": "Update_SRTT(m) Procedure to update the smoothed RTT and RTT variance estimates, using the rules of [Jacobson88a], given m, a new RTT measurement",
      "ja": "Update_SRTT（M）手順[Jacobson88a]、与えられたM、新たなRTT測定のルールを使用して、平滑化RTTとRTT分散の推定値を更新します"
    },
    {
      "indent": 3,
      "text": "Send Sequence Variables",
      "ja": "シーケンス変数を送信"
    },
    {
      "indent": 6,
      "text": "SND.UNA: Send unacknowledged SND.NXT: Send next SND.WND: Send window ISS: Initial send sequence number",
      "ja": "SND.UNA：未確認SND.NXTを送信：次のSND.ANDを送信：ウィンドウISSを送る：初期送信シーケンス番号を"
    },
    {
      "indent": 3,
      "text": "Receive Sequence Variables",
      "ja": "シーケンス変数を受け取ります"
    },
    {
      "indent": 6,
      "text": "RCV.NXT: Receive next RCV.WND: Receive window IRS: Initial receive sequence number",
      "ja": "RCV.NXT：次RCV.AND：受信ウィンドウIRSを受信：初期シーケンス番号を受け取ります"
    },
    {
      "indent": 0,
      "text": "Appendix D. Event Processing Summary",
      "ja": "付録D.イベント処理の概要"
    },
    {
      "indent": 3,
      "text": "This appendix attempts to specify the algorithms unambiguously by presenting modifications to the Event Processing rules in Section 3.9 of RFC 793. The change bars (\"|\") indicate lines that are different from RFC 793.",
      "ja": "この付録では、RFC 793のセクション3.9にイベント処理ルールに変更を提示することによって明確に変更バーをアルゴリズムを指定しようとします（「|」）RFC 793と異なっている行を示しています。"
    },
    {
      "indent": 3,
      "text": "OPEN Call",
      "ja": "OPENコール"
    },
    {
      "indent": 6,
      "text": "...",
      "ja": "。。。"
    },
    {
      "indent": 1,
      "text": " An initial send sequence number (ISS) is selected. Send a <SYN> | segment of the form: | | <SEQ=ISS><CTL=SYN><TSval=Snd.TSclock><WSopt=Rcv.Wind.Shift>",
      "ja": "初期送信シーケンス番号（ISS）が選択されています。送信<SYN> |フォームのセグメント：| | <SEQ = ISS> <CTL = SYN> <TSval = Snd.TSclock> <WSopt = Rcv.Wind.Shift>"
    },
    {
      "indent": 6,
      "text": "...",
      "ja": "。。。"
    },
    {
      "indent": 3,
      "text": "SEND Call",
      "ja": "コールを送信"
    },
    {
      "indent": 6,
      "text": "CLOSED STATE (i.e., TCB does not exist)",
      "ja": "CLOSED状態（すなわちTCBが存在しません）"
    },
    {
      "indent": 9,
      "text": "...",
      "ja": "。。。"
    },
    {
      "indent": 6,
      "text": "LISTEN STATE",
      "ja": "LISTEN状態"
    },
    {
      "indent": 1,
      "text": " If active and the foreign socket is specified, then change the connection from passive to active, select an ISS. Send a SYN | segment containing the options: <TSval=Snd.TSclock> and | <WSopt=Rcv.Wind.Shift>. Set SND.UNA to ISS, SND.NXT to ISS+1. Enter SYN-SENT state. ...",
      "ja": "アクティブおよび外部ソケットが指定されている場合、ISSを選択し、アクティブにパッシブからの接続を変更します。 SYNを送ります|オプションを含むセグメント：<TSval = Snd.TSclock>と| <WSopt = Rcv.Wind.Shift>。 ISS、ISS + 1にSND.NXTにSND.UNAを設定します。 SYN-SENT状態を入力します。 ..."
    },
    {
      "indent": 6,
      "text": "SYN-SENT STATE\nSYN-RECEIVED STATE",
      "raw": true
    },
    {
      "indent": 9,
      "text": "...",
      "ja": "。。。"
    },
    {
      "indent": 6,
      "text": "ESTABLISHED STATE CLOSE-WAIT STATE",
      "ja": "ESTABLISHED状態CLOSE-WAIT状態"
    },
    {
      "indent": 9,
      "text": "Segmentize the buffer and send it with a piggybacked acknowledgment (acknowledgment value = RCV.NXT). ...",
      "ja": "バッファをSegmentizeとピギーバック肯定応答（アクノレッジメント値= RCV.NXT）でそれを送ります。 ..."
    },
    {
      "indent": 9,
      "text": "If the urgent flag is set ...",
      "ja": "緊急フラグが設定されている場合..."
    },
    {
      "indent": 1,
      "text": "| If the Snd.TS.OK flag is set, then include the TCP Timestamps | option <TSval=Snd.TSclock,TSecr=TS.Recent> in each data | segment. | | Scale the receive window for transmission in the segment | header: | | SEG.WND = (RCV.WND >> Rcv.Wind.Shift).",
      "ja": "| Snd.TS.OKフラグが設定されている場合、TCPタイムスタンプを含めます|各データ内のオプション<TSval = Snd.TSclock、TSecr = TS.Recent> |セグメント。 | |セグメント内の伝送のための受信ウィンドウを拡大縮小|ヘッダ：| | SEG.WND =（RCV.WND >> Rcv.Wind.Shift）。"
    },
    {
      "indent": 3,
      "text": "SEGMENT ARRIVES",
      "ja": "セグメントが到着します"
    },
    {
      "indent": 6,
      "text": "...",
      "ja": "。。。"
    },
    {
      "indent": 6,
      "text": "If the state is LISTEN then",
      "ja": "状態である場合、LISTEN"
    },
    {
      "indent": 9,
      "text": "first check for an RST",
      "ja": "RSTのための最初のチェック"
    },
    {
      "indent": 12,
      "text": "...",
      "ja": "。。。"
    },
    {
      "indent": 9,
      "text": "second check for an ACK",
      "ja": "ACKのための第2のチェック"
    },
    {
      "indent": 12,
      "text": "...",
      "ja": "。。。"
    },
    {
      "indent": 9,
      "text": "third check for a SYN",
      "ja": "SYNのための第三のチェック"
    },
    {
      "indent": 12,
      "text": "If the SYN bit is set, check the security. If the ...",
      "ja": "SYNビットがセットされている場合は、セキュリティを確認してください。もし..."
    },
    {
      "indent": 15,
      "text": "...",
      "ja": "。。。"
    },
    {
      "indent": 12,
      "text": "If the SEG.PRC is less than the TCB.PRC then continue.",
      "ja": "SEG.PRCがTCB.PRC未満であれば、続けています。"
    },
    {
      "indent": 1,
      "text": "| Check for a Window Scale option (WSopt); if one is found, | save SEG.WSopt in Snd.Wind.Shift and set Snd.WS.OK flag on. | Otherwise, set both Snd.Wind.Shift and Rcv.Wind.Shift to | zero and clear Snd.WS.OK flag. | | Check for a TSopt option; if one is found, save SEG.TSval in | the variable TS.Recent and turn on the Snd.TS.OK bit.",
      "ja": "|ウィンドウスケールオプション（WSopt）をチェックしてください。 1が発見された場合、| Snd.Wind.ShiftでSEG.WSoptを保存し、上Snd.WS.OKフラグを設定します。 |それ以外の場合は、Snd.Wind.ShiftとRcv.Wind.Shiftの両方を設定します|ゼロクリアSnd.WS.OKフラグ。 | | TSoptオプションをチェックします。 1が見つかった場合、中SEG.TSvalを保存|変数TS.RecentとSnd.TS.OKビットをオンにします。"
    },
    {
      "indent": 12,
      "text": "Set RCV.NXT to SEG.SEQ+1, IRS is set to SEG.SEQ and any\nother control or text should be queued for processing later.\nISS should be selected and a SYN segment sent of the form:",
      "raw": true
    },
    {
      "indent": 20,
      "text": "<SEQ=ISS><ACK=RCV.NXT><CTL=SYN,ACK>",
      "ja": "<SEQ = ISS> <ACK = RCV.NXT> <CTL = SYN、ACK>"
    },
    {
      "indent": 1,
      "text": "| If the Snd.WS.OK bit is on, include a WSopt | <WSopt=Rcv.Wind.Shift> in this segment. If the Snd.TS.OK | bit is on, include a TSopt <TSval=Snd.TSclock, | TSecr=TS.Recent> in this segment. Last.ACK.sent is set to | RCV.NXT.",
      "ja": "| | Snd.WS.OKビットがオンになっている場合は、WSoptが含まれます<WSopt = Rcv.Wind.Shift>このセグメントです。 Snd.TS.OKもし|ビットはTSoptが含まれ、オンになっている<TSval = Snd.TSclock、| TSecr = TS.Recent>このセグメントです。 Last.ACK.sentに設定します| RCV.NXT。"
    },
    {
      "indent": 12,
      "text": "SND.NXT is set to ISS+1 and SND.UNA to ISS.  The connection\nstate should be changed to SYN-RECEIVED.  Note that any\nother incoming control or data (combined with SYN) will be\nprocessed in the SYN-RECEIVED state, but processing of SYN\nand ACK should not be repeated.  If the listen was not fully\nspecified (i.e., the foreign socket was not fully\nspecified), then the unspecified fields should be filled in\nnow.",
      "raw": true
    },
    {
      "indent": 9,
      "text": "fourth other text or control",
      "ja": "第四他のテキストまたはコントロール"
    },
    {
      "indent": 12,
      "text": "...",
      "ja": "。。。"
    },
    {
      "indent": 6,
      "text": "If the state is SYN-SENT then",
      "ja": "状態は、SYN-SENTである場合"
    },
    {
      "indent": 9,
      "text": "first check the ACK bit",
      "ja": "最初のACKビットをチェック"
    },
    {
      "indent": 12,
      "text": "...",
      "ja": "。。。"
    },
    {
      "indent": 9,
      "text": "...",
      "ja": "。。。"
    },
    {
      "indent": 9,
      "text": "fourth check the SYN bit",
      "ja": "第四SYNビットをチェック"
    },
    {
      "indent": 12,
      "text": "...",
      "ja": "。。。"
    },
    {
      "indent": 12,
      "text": "If the SYN bit is on and the security/compartment and precedence are acceptable then, RCV.NXT is set to SEG.SEQ+1, IRS is set to SEG.SEQ. SND.UNA should be advanced to equal SEG.ACK (if there is an ACK), and any segments on the retransmission queue which are thereby acknowledged should be removed.",
      "ja": "SYNビットがオンで、セキュリティ/コンパートメントと優先順位は、次に許容可能である場合、RCV.NXTにSEG.SEQ + 1に設定され、IRSはSEG.SEQに設定されています。 SND.UNAは（ACKがある場合）に等しいSEG.ACKに進めなければならない、それによって認められている再送キュー上の任意のセグメントが除去されるべきです。"
    },
    {
      "indent": 1,
      "text": "| Check for a Window Scale option (WSopt); if it is found, | save SEG.WSopt in Snd.Wind.Shift; otherwise, set both | Snd.Wind.Shift and Rcv.Wind.Shift to zero. |",
      "ja": "|ウィンドウスケールオプション（WSopt）をチェックしてください。それが発見された場合、| Snd.Wind.ShiftでSEG.WSoptを保存します。それ以外の場合は、両方を設定します|ゼロにSnd.Wind.ShiftとRcv.Wind.Shift。 |"
    },
    {
      "indent": 1,
      "text": "| Check for a TSopt option; if one is found, save SEG.TSval in | variable TS.Recent and turn on the Snd.TS.OK bit in the | connection control block. If the ACK bit is set, use | Snd.TSclock - SEG.TSecr as the initial RTT estimate.",
      "ja": "| TSoptオプションをチェックします。 1が見つかった場合、中SEG.TSvalを保存|変数TS.RecentとでSnd.TS.OKビットをオンにします|接続制御ブロック。 ACKビットがセットされている場合は、使用し| Snd.TSclock  - 初期RTT推定値としてSEG.TSecr。"
    },
    {
      "indent": 12,
      "text": "If SND.UNA > ISS (our SYN has been ACKed), change the\nconnection state to ESTABLISHED, form an <ACK> segment:",
      "raw": true
    },
    {
      "indent": 20,
      "text": "<SEQ=SND.NXT><ACK=RCV.NXT><CTL=ACK>",
      "ja": "<SEQ = SND.NXT> <ACK = RCV.NXT> <CTL = ACK>"
    },
    {
      "indent": 1,
      "text": "| and send it. If the Snd.TS.OK bit is on, include a TSopt | option <TSval=Snd.TSclock,TSecr=TS.Recent> in this <ACK> | segment. Last.ACK.sent is set to RCV.NXT.",
      "ja": "|そしてそれを送ります。 | Snd.TS.OKビットがオンになっている場合は、TSoptが含まれますオプション<TSval = Snd.TSclock、TSecr = TS.Recent>この中に<ACK> |セグメント。 Last.ACK.sentはRCV.NXTに設定されています。"
    },
    {
      "indent": 12,
      "text": "Data or controls that were queued for transmission may be\nincluded.  If there are other controls or text in the\nsegment, then continue processing at the sixth step below\nwhere the URG bit is checked; otherwise, return.",
      "raw": true
    },
    {
      "indent": 12,
      "text": "Otherwise, enter SYN-RECEIVED, form a <SYN,ACK> segment:",
      "ja": "そうでない場合は、SYN-RECEIVED入力し、<SYN、ACK>セグメントを形成します。"
    },
    {
      "indent": 20,
      "text": "<SEQ=ISS><ACK=RCV.NXT><CTL=SYN,ACK>",
      "ja": "<SEQ = ISS> <ACK = RCV.NXT> <CTL = SYN、ACK>"
    },
    {
      "indent": 1,
      "text": "| and send it. If the Snd.TS.OK bit is on, include a TSopt | option <TSval=Snd.TSclock,TSecr=TS.Recent> in this segment. | If the Snd.WS.OK bit is on, include a WSopt option | <WSopt=Rcv.Wind.Shift> in this segment. Last.ACK.sent is | set to RCV.NXT.",
      "ja": "|そしてそれを送ります。 | Snd.TS.OKビットがオンになっている場合は、TSoptが含まれますこのセグメントにおけるオプション<TSval = Snd.TSclock、TSecr = TS.Recent>。 | | Snd.WS.OKビットがオンの場合、WSoptオプションを含めます<WSopt = Rcv.Wind.Shift>このセグメントです。 Last.ACK.sentされます| RCV.NXTに設定します。"
    },
    {
      "indent": 12,
      "text": "If there are other controls or text in the segment, queue\nthem for processing after the ESTABLISHED state has been\nreached, return.",
      "raw": true
    },
    {
      "indent": 9,
      "text": "fifth, if neither of the SYN or RST bits is set then drop the segment and return.",
      "ja": "SYNまたはRSTビットのどちらが設定されている場合に第五のは、セグメントを削除し返します。"
    },
    {
      "indent": 6,
      "text": "Otherwise",
      "ja": "そうでなければ"
    },
    {
      "indent": 6,
      "text": "first check the sequence number",
      "ja": "最初のシーケンス番号をチェック"
    },
    {
      "indent": 9,
      "text": "SYN-RECEIVED STATE ESTABLISHED STATE FIN-WAIT-1 STATE FIN-WAIT-2 STATE CLOSE-WAIT STATE CLOSING STATE LAST-ACK STATE TIME-WAIT STATE",
      "ja": "STATE ESTABLISHED状態FIN-WAIT-1状態FIN-WAIT-2状態CLOSE-WAIT状態閉状態をSYN-RECEIVED LAST-ACK状態TIME-WAIT状態"
    },
    {
      "indent": 12,
      "text": "Segments are processed in sequence. Initial tests on arrival are used to discard old duplicates, but further processing is done in SEG.SEQ order. If a segment's contents straddle the boundary between old and new, only the new parts should be processed.",
      "ja": "セグメントは順番に処理されます。到着時に最初のテストは古い写しを破棄するために使用されているが、更なる処理はSEG.SEQの順序で行われます。セグメントの内容は、新旧の間の境界をまたぐ場合は、新しい部分だけが処理されるべきです。"
    },
    {
      "indent": 1,
      "text": "| Rescale the received window field: | | TrueWindow = SEG.WND << Snd.Wind.Shift, | | and use \"TrueWindow\" in place of SEG.WND in the following | steps. | | Check whether the segment contains a Timestamps option and | if bit Snd.TS.OK is on. If so: | | If SEG.TSval < TS.Recent and the RST bit is off: | | If the connection has been idle more than 24 days, | save SEG.TSval in variable TS.Recent, else the segment | is not acceptable; follow the steps below for an | unacceptable segment. | | If SEG.TSval >= TS.Recent and SEG.SEQ <= Last.ACK.sent, | then save SEG.TSval in variable TS.Recent.",
      "ja": "|受信ウィンドウのフィールドを再スケール：| | TrueWindow = SEG.WND << Snd.Wind.Shift、| |そして次にSEG.WNDの代わりに「TrueWindow」を使用|手順。 | |セグメントは、タイムスタンプオプションが含まれているかどうかを確認し、|ビットSnd.TS.OKがオンになっている場合。その場合：| | SEG.TSval <TS.RecentとRSTビットがオフの場合：| |接続は、24以上の日アイドル状態になっている場合は、|他のセグメント変数TS.Recent、中SEG.TSvalを保存|許容ではありません。以下の手順に従ってください|容認できないセグメント。 | |もしSEG.TSval> = TS.RecentとSEG.SEQ <= Last.ACK.sent、|その後、変数TS.RecentでSEG.TSvalを保存します。"
    },
    {
      "indent": 12,
      "text": "There are four cases for the acceptability test for an\nincoming segment:",
      "raw": true
    },
    {
      "indent": 15,
      "text": "...",
      "ja": "。。。"
    },
    {
      "indent": 12,
      "text": "If an incoming segment is not acceptable, an acknowledgment should be sent in reply (unless the RST bit is set; if so drop the segment and return):",
      "ja": "着信セグメントが受け入れられない場合（RSTビットが設定されていない限り、そうセグメントをドロップして戻す場合）、確認応答が応答で送信されるべきです。"
    },
    {
      "indent": 20,
      "text": "<SEQ=SND.NXT><ACK=RCV.NXT><CTL=ACK>",
      "ja": "<SEQ = SND.NXT> <ACK = RCV.NXT> <CTL = ACK>"
    },
    {
      "indent": 1,
      "text": "| Last.ACK.sent is set to SEG.ACK of the acknowledgment. If | the Snd.TS.OK bit is on, include the Timestamps option | <TSval=Snd.TSclock,TSecr=TS.Recent> in this <ACK> segment. Set Last.ACK.sent to SEG.ACK and send the <ACK> segment. After sending the acknowledgment, drop the unacceptable segment and return.",
      "ja": "| Last.ACK.sentは確認のSEG.ACKに設定されています。もし| | Snd.TS.OKビットは、上でタイムスタンプオプションを含めます<TSval = Snd.TSclock、TSecr = TS.Recent>この<ACK>セグメントです。 SEG.ACKと<ACK>セグメントを送信するためにLast.ACK.sentを設定します。肯定応答を送信した後、容認できないセグメントとリターンをドロップ。"
    },
    {
      "indent": 6,
      "text": "...",
      "ja": "。。。"
    },
    {
      "indent": 6,
      "text": "fifth check the ACK field,",
      "ja": "第五ACKフィールドをチェックし、"
    },
    {
      "indent": 9,
      "text": "if the ACK bit is off drop the segment and return",
      "ja": "ACKビットは、セグメントとリターンをドロップオフの場合"
    },
    {
      "indent": 9,
      "text": "if the ACK bit is on",
      "ja": "ACKビットがオンの場合"
    },
    {
      "indent": 12,
      "text": "...",
      "ja": "。。。"
    },
    {
      "indent": 12,
      "text": "ESTABLISHED STATE",
      "ja": "ESTABLISHED状態"
    },
    {
      "indent": 1,
      "text": " If SND.UNA < SEG.ACK <= SND.NXT then, set SND.UNA <- | SEG.ACK. Also compute a new estimate of round-trip time. | If Snd.TS.OK bit is on, use Snd.TSclock - SEG.TSecr; | otherwise, use the elapsed time since the first segment | in the retransmission queue was sent. Any segments on the retransmission queue that are thereby entirely acknowledged...",
      "ja": "SND.UNA <SEG.ACK <= SND.NXTはその後、SND.UNA <設定されている場合 - を| SEG.ACK。また、ラウンドトリップ時間の新しい推定値を計算します。 | Snd.TS.OKビットがオンになっている場合は、Snd.TSclockを使用する -  SEG.TSecrを。 |それ以外の場合は、最初のセグメントからの経過時間を使います|再送キューに送信されました。これにより、完全に承認される再送キュー上の任意のセグメント..."
    },
    {
      "indent": 6,
      "text": "...",
      "ja": "。。。"
    },
    {
      "indent": 6,
      "text": "seventh, process the segment text,",
      "ja": "第七、プロセスセグメントテキスト、"
    },
    {
      "indent": 9,
      "text": "ESTABLISHED STATE FIN-WAIT-1 STATE FIN-WAIT-2 STATE",
      "ja": "ESTABLISHED状態FIN-WAIT-1状態FIN-WAIT-2 STATE"
    },
    {
      "indent": 12,
      "text": "...",
      "ja": "。。。"
    },
    {
      "indent": 12,
      "text": "Send an acknowledgment of the form:",
      "ja": "フォームの確認応答を送信します。"
    },
    {
      "indent": 20,
      "text": "<SEQ=SND.NXT><ACK=RCV.NXT><CTL=ACK>",
      "ja": "<SEQ = SND.NXT> <ACK = RCV.NXT> <CTL = ACK>"
    },
    {
      "indent": 1,
      "text": "| If the Snd.TS.OK bit is on, include the Timestamps option | <TSval=Snd.TSclock,TSecr=TS.Recent> in this <ACK> segment. | Set Last.ACK.sent to SEG.ACK of the acknowledgment, and send | it. This acknowledgment should be piggybacked on a segment being transmitted if possible without incurring undue delay.",
      "ja": "| | Snd.TS.OKビットがオンの場合、タイムスタンプオプションを含めます<TSval = Snd.TSclock、TSecr = TS.Recent>この<ACK>セグメントです。 |確認のSEG.ACKにLast.ACK.sentを設定し、送信|それ。この肯定応答は過度の遅延を招くことなく、可能な場合に送信されるセグメント上にピギーバックされるべきです。"
    },
    {
      "indent": 12,
      "text": "...",
      "ja": "。。。"
    },
    {
      "indent": 0,
      "text": "Appendix E. Timestamps Edge Cases",
      "ja": "付録E.タイムスタンプのエッジケース"
    },
    {
      "indent": 3,
      "text": "While the rules laid out for when to calculate RTTM produce the correct results most of the time, there are some edge cases where an incorrect RTTM can be calculated. All of these situations involve the loss of segments. It is felt that these scenarios are rare, and that if they should happen, they will cause a single RTTM measurement to be inflated, which mitigates its effects on RTO calculations.",
      "ja": "ルールはRTTMは、ほとんどの時間正しい結果を生成する計算する場合のレイアウトが、誤っRTTMを計算することができるいくつかのエッジ場合があります。これらの状況のすべては、セグメントの損失を伴います。これらのシナリオは稀であると感じている、と彼らは起こる必要がある場合、彼らはRTOの計算に及ぼす影響を軽減され、単一RTTM測定を膨張させることになるという。"
    },
    {
      "indent": 3,
      "text": "[Martin03] cites two similar cases when the returning <ACK> is lost, and before the retransmission timer fires, another returning <ACK> segment arrives, which acknowledges the data. In this case, the RTTM calculated will be inflated:",
      "ja": "【Martin03]復帰<ACK>が失われ、再送タイマーが起動する前に、別の戻り<ACK>セグメントがデータを承認れ、到達されたときに、2つの類似事例を引用。この場合、計算RTTMが膨張されます。"
    },
    {
      "indent": 10,
      "text": "clock\n  tc=1   <A, TSval=1> ------------------->",
      "raw": true
    },
    {
      "indent": 12,
      "text": "tc=2   (lost) <---- <ACK(A), TSecr=1, win=n>\n    (RTTM would have been 1)",
      "raw": true
    },
    {
      "indent": 12,
      "text": "       (receive window opens, window update is sent)\ntc=5        <---- <ACK(A), TSecr=1, win=m>\n       (RTTM is calculated at 4)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "One thing to note about this situation is that it is somewhat bounded by RTO + RTT, limiting how far off the RTTM calculation will be. While more complex scenarios can be constructed that produce larger inflations (e.g., retransmissions are lost), those scenarios involve multiple segment losses, and the connection will have other more serious operational problems than using an inflated RTTM in the RTO calculation.",
      "ja": "このような状況で1つ注意することは、それが多少RTTM計算がされるか遠く制限、RTO + RTTで囲まれていることです。より複雑なシナリオ（例えば、再送信が失われている）が大きくinflationsを生成するように構築することができるが、これらのシナリオは、複数のセグメントの損失を伴う、および接続はRTOの計算に膨張RTTMを使用するよりも他のより深刻な操作上の問題を有することになります。"
    },
    {
      "indent": 0,
      "text": "Appendix F. Window Retraction Example",
      "ja": "付録F.ウィンドウ撤回例"
    },
    {
      "indent": 3,
      "text": "Consider an established TCP connection using a scale factor of 128, Snd.Wind.Shift=7 and Rcv.Wind.Shift=7, that is running with a very small window because the receiver is bottlenecked and both ends are doing small reads and writes.",
      "ja": "受信機がボトルネックされ、両端がやっている小さな読み取りおよび書き込むため、それは非常に小さなウィンドウで実行されて、128のスケールファクタを使用して確立されたTCP接続、Snd.Wind.Shift = 7とRcv.Wind.Shift = 7を検討。"
    },
    {
      "indent": 3,
      "text": "Consider the ACKs coming back:",
      "ja": "戻ってくるACKを考えてみましょう："
    },
    {
      "indent": 3,
      "text": "SEG.ACK SEG.WIN computed SND.WIN receiver's actual window 1000 2 1256 1300",
      "ja": "SEG.ACK SEG.WINはSND.WIN受信機の実際のウィンドウ2 1256 1300 1000計算しました"
    },
    {
      "indent": 3,
      "text": "The sender writes 40 bytes and receiver ACKs:",
      "ja": "送信者は40のバイトと受信ACKを書き込みます。"
    },
    {
      "indent": 3,
      "text": "1040 2 1296 1300",
      "ja": "１０４０ ２ １２９６ １３００"
    },
    {
      "indent": 3,
      "text": "The sender writes 5 additional bytes and the receiver has a problem. Two choices:",
      "ja": "送信者は、5つの追加のバイトを書き込み、受信機に問題があります。二つの選択肢："
    },
    {
      "indent": 3,
      "text": "1045 2 1301 1300 - BEYOND BUFFER",
      "ja": "1045 2 1301 1300  -  BEYOND BUFFER"
    },
    {
      "indent": 3,
      "text": "1045 1 1173 1300 - RETRACTED WINDOW",
      "ja": "1 1173 1300 1045  - 引っ込めWINDOW"
    },
    {
      "indent": 3,
      "text": "This is a general problem and can happen any time the sender does a write, which is smaller than the window scale factor.",
      "ja": "これは、一般的な問題であり、送信側がウィンドウスケールファクタよりも小さい書き込みを行い、いつでも起こることができます。"
    },
    {
      "indent": 3,
      "text": "In most stacks, it is at least partially obscured when the window size is larger than some small number of segments because the stacks prefer to announce windows that are an integral number of segments, rounded up to the next scale factor. This plus silly window suppression tends to cause less frequent, larger window updates. If the window was rounded down to a segment size, there is more opportunity to advance the window, the BEYOND BUFFER case above, rather than retracting it.",
      "ja": "ほとんどのスタックでは、スタックはセグメントの整数であるウィンドウをアナウンスすることを好むので、ウィンドウサイズはセグメントのいくつかの小さな数よりも大きい場合、それは、少なくとも部分的に隠されて、次のスケールファクタに切り上げ。このプラス愚かな窓の抑制はそれほど頻繁に、より大きなウィンドウの更新を引き起こす傾向があります。ウィンドウは、セグメントサイズに切り捨てた場合、むしろそれを後退させるよりも、窓、上記BEYONDバッファケースを進めるより機会があります。"
    },
    {
      "indent": 0,
      "text": "Appendix G. RTO Calculation Modification",
      "ja": "付録G. RTO計算修正"
    },
    {
      "indent": 3,
      "text": "Taking multiple RTT samples per window would shorten the history calculated by the RTO mechanism in [RFC6298], and the below algorithm aims to maintain a similar history as originally intended by [RFC6298].",
      "ja": "ウィンドウごとに複数のRTTのサンプルを採取して、[RFC6298]でRTO機構によって算出履歴を短縮し、以下のアルゴリズムは、もともと[RFC6298]で意図したとおりに同様の履歴を維持することを目的とするであろう。"
    },
    {
      "indent": 3,
      "text": "It is roughly known how many samples a congestion window worth of data will yield, not accounting for ACK compression, and ACK losses. Such events will result in more history of the path being reflected in the final value for RTO, and are uncritical. This modification will ensure that a similar amount of time is taken into account for the RTO estimation, regardless of how many samples are taken per window:",
      "ja": "大体ACK圧縮を占め、およびACK損失ではない、データの輻輳ウィンドウの価値が得られますどのように多くのサンプルが知られています。経路のより歴史になり、このようなイベントは、RTOの最終値に反映され、無批判されています。この変更は、時間の同様の量にかかわらず、ウィンドウごとに取得されますどのように多くのサンプルを、RTO推定に考慮されていることを確認します。"
    },
    {
      "indent": 6,
      "text": "ExpectedSamples = ceiling(FlightSize / (SMSS * 2))",
      "ja": "ExpectedSamples =天井（FlightSize /（SMSS * 2））"
    },
    {
      "indent": 6,
      "text": "alpha' = alpha / ExpectedSamples",
      "ja": "アルファ」=アルファ/ ExpectedSamples"
    },
    {
      "indent": 6,
      "text": "beta' = beta / ExpectedSamples",
      "ja": "ベータ」=ベータ/ ExpectedSamples"
    },
    {
      "indent": 3,
      "text": "Note that the factor 2 in ExpectedSamples is due to \"Delayed ACKs\".",
      "ja": "ExpectedSamplesの要因2が「遅延ACK」によるものであることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Instead of using alpha and beta in the algorithm of [RFC6298], use alpha' and beta' instead:",
      "ja": "代わりに、[RFC6298]のアルゴリズムにアルファおよびベータを使用するのではなく、代わりに、α「およびβ」を使用："
    },
    {
      "indent": 6,
      "text": "RTTVAR <- (1 - beta') * RTTVAR + beta' * |SRTT - R'|",
      "ja": "RTTVAR < - （1  - ベータ '）* RTTVAR +ベータ' * | SRTT  -  R '|"
    },
    {
      "indent": 6,
      "text": "SRTT <- (1 - alpha') * SRTT + alpha' * R'",
      "ja": "SRTT < - （1  - アルファ '）* SRTT +アルファ' * R」"
    },
    {
      "indent": 6,
      "text": "(for each sample R')",
      "ja": "（各サンプルR '用）"
    },
    {
      "indent": 1,
      "text": "Appendix H. Changes from",
      "ja": "付録H.変更から"
    },
    {
      "indent": 3,
      "text": "Several important updates and clarifications to the specification in RFC 1323 are made in this document. The technical changes are summarized below:",
      "ja": "RFC 1323での仕様にいくつかの重要な更新と説明は、このドキュメントで作られています。技術的な変更は以下のとおりであります："
    },
    {
      "indent": 3,
      "text": "(a) A wrong reference to SND.WND was corrected to SEG.WND in Section 2.3.",
      "ja": "（a）はAND.ENDへの誤った参照は、2.3節でSET.ENDに修正されました。"
    },
    {
      "indent": 3,
      "text": "(b) Section 2.4 was added describing the unavoidable window retraction issue and explicitly describing the mitigation steps necessary.",
      "ja": "（b）は2.4節は避けられない窓後退の問題を説明し、明示的に必要な軽減ステップを説明する追加されました。"
    },
    {
      "indent": 3,
      "text": "(c) In Section 3.2, the wording how the Timestamps option negotiation is to be performed was updated with RFC2119 wording. Further, a number of paragraphs were added to clarify the expected behavior with a compliant implementation using TSopt, as RFC 1323 left room for interpretation -- e.g., potential late enablement of TSopt.",
      "ja": "（c）は3.2節では、タイムスタンプオプションのネゴシエーションが実行される方法文言は、RFC2119文言を更新しました。 TSoptの例えば、潜在的な遅い有効化を -  RFC 1323の解釈のために部屋を出ようさらに、段落の数は、TSoptを使用して準拠した実装と予想される動作を明確にするために添加しました。"
    },
    {
      "indent": 3,
      "text": "(d) The description of which TSecr values can be used to update the measured RTT has been clarified. Specifically, with timestamps, the Karn algorithm [Karn87] is disabled. The Karn algorithm disables all RTT measurements during retransmission, since it is ambiguous whether the <ACK> is for the original segment, or the retransmitted segment. With timestamps, that ambiguity is removed since the TSecr in the <ACK> will contain the TSval from whichever data segment made it to the destination.",
      "ja": "（D）TSecr値が測定されたRTTを更新するために使用することができるの説明が明らかにされています。具体的には、タイムスタンプと、カーンアルゴリズム[Karn87]は無効になっています。 <ACK>オリジナルのセグメント、または再送セグメントのためのものであるか否か曖昧であるため、カーンアルゴリズムは、再送時にすべてのRTT測定値を無効にします。タイムスタンプと、その曖昧さは、<ACK>にTSecrは、いずれのデータセグメントからTSvalを含有するので、削除された宛先にそれを作りました。"
    },
    {
      "indent": 3,
      "text": "(e) RTTM update processing explicitly excludes segments not updating SND.UNA. The original text could be interpreted to allow taking RTT samples when SACK acknowledges some new, non-continuous data.",
      "ja": "（E）RTTM更新処理を明示的にセグメントがSND.UNAを更新しない除外する。元のテキストは、SACKはいくつかの新しい、非連続的なデータを認識したときにRTTのサンプルを採取できるように解釈できます。"
    },
    {
      "indent": 3,
      "text": "(f) In RFC 1323, Section 3.4, step (2) of the algorithm to control which timestamp is echoed was incorrect in two regards:",
      "ja": "（F）RFC 1323で、第3.4項、タイムスタンプはエコーさを制御するためのアルゴリズムのステップ（2）は、2つの点で正しくありませんでした。"
    },
    {
      "indent": 8,
      "text": "(1)  It failed to update TS.Recent for a retransmitted segment\n     that resulted from a lost <ACK>.",
      "raw": true
    },
    {
      "indent": 8,
      "text": "(2) It failed if SEG.LEN = 0.",
      "ja": "SEG.LEN = 0の場合（2）が失敗しました。"
    },
    {
      "indent": 8,
      "text": "In the new algorithm, the case of SEG.TSval >= TS.Recent is included for consistency with the PAWS test.",
      "ja": "新しいアルゴリズムでは、SEG.TSval> = TS.Recentの場合は、PAWSテストとの整合性のために含まれています。"
    },
    {
      "indent": 3,
      "text": "(g) It is now recommended that the Timestamps option is included in <RST> segments if the incoming segment contained a Timestamps option.",
      "ja": "（G）現在の着信セグメントがタイムスタンプオプションが含まれている場合、タイムスタンプオプションが<RST>セグメントに含まれていることが推奨されます。"
    },
    {
      "indent": 3,
      "text": "(h) <RST> segments are explicitly excluded from PAWS processing.",
      "ja": "（H）<RST>セグメントが明示的PAWS処理から除外されます。"
    },
    {
      "indent": 3,
      "text": "(i) Added text to clarify the precedence between regular TCP [RFC0793] and this document's Timestamps option / PAWS processing. Discussion about combined acceptability checks are ongoing.",
      "ja": "（i）は、通常のTCP [RFC0793]とこのドキュメントのタイムスタンプオプション/ PAWS処理間の優先順位を明確にするために、テキストを追加しました。組み合わせ受容性チェックについての議論が進行中です。"
    },
    {
      "indent": 3,
      "text": "(j) Snd.TSoffset and Snd.TSclock variables have been added. Snd.TSclock is the sum of my.TSclock and Snd.TSoffset. This allows the starting points for timestamp values to be randomized on a per-connection basis. Setting Snd.TSoffset to zero yields the same results as [RFC1323]. Text was added to guide implementers to the proper selection of these offsets, as entirely random offsets for each new connection will conflict with PAWS.",
      "ja": "（J）Snd.TSoffsetとSnd.TSclock変数が追加されました。 Snd.TSclockはmy.TSclockとSnd.TSoffsetの合計です。これは、タイムスタンプ値の出発点は、接続ごとにランダム化することを可能にします。ゼロにSnd.TSoffsetを設定すると、[RFC1323]と同じ結果が得られます。テキストはPAWSと競合するそれぞれの新しい接続のための完全にランダムなオフセットとして、これらのオフセットの適切な選択に実装を導くために追加されました。"
    },
    {
      "indent": 3,
      "text": "(k) Appendix A has been expanded with information about the TCP Urgent Pointer. An earlier revision contained text around the TCP MSS option, which was split off into [RFC6691].",
      "ja": "（k）は、付録AはTCP緊急ポインタについての情報が拡張されました。 [RFC6691]にオフに分割されたTCP MSSオプション、周りの以前のリビジョン含まれるテキスト。"
    },
    {
      "indent": 3,
      "text": "(l) One correction was made to the Event Processing Summary in Appendix D. In SEND CALL/ESTABLISHED STATE, RCV.WND is used to fill in the SEG.WND value, not SND.WND.",
      "ja": "（L）一点の補正が送信呼び出しの付録Dのイベント処理の概要/ ESTABLISHED状態になされたもので、RCV.WNDはSND.WND、SEG.WND値でない埋めるために使用されます。"
    },
    {
      "indent": 3,
      "text": "(m) Appendix G was added to exemplify how an RTO calculation might be updated to properly take the much higher RTT sampling frequency enabled by the Timestamps option into account.",
      "ja": "（m）の付録Gは、RTOの計算が適切に考慮にタイムスタンプオプションで有効になってはるかに高いRTTのサンプリング周波数を取るために更新されるかもしれない方法を例示するために追加されました。"
    },
    {
      "indent": 3,
      "text": "Editorial changes to the document, that don't impact the implementation or function of the mechanisms described in this document, include:",
      "ja": "本書で説明されたメカニズムの実装や機能に影響を与えていないドキュメントに編集上の変更は、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "(a) Removed much of the discussion in Section 1 to streamline the document. However, detailed examples and discussions in Sections 2, 3, and 5 are kept as guidelines for implementers.",
      "ja": "（a）の文書を合理化するための第1節での議論の多くを削除しました。しかし、詳細な例及びセクション2、3、及び5での議論は、実装のためのガイドラインとして保持されます。"
    },
    {
      "indent": 3,
      "text": "(b) Added short text that the use of WS increases the chances of sequence number wrap, thus the PAWS mechanism is required in certain environments.",
      "ja": "（b）は、WSの使用は、このようPAWS機構は、特定の環境で必要とされるシーケンス番号ラップの機会を増加させる短いテキストを追加しました。"
    },
    {
      "indent": 3,
      "text": "(c) Removed references to \"new\" options, as the options were introduced in [RFC1323] already. Changed the text in Section 1.3 to specifically address TS and WS options.",
      "ja": "（C）オプションが既に[RFC1323]で導入されたように、「新たな」オプションへの参照を削除。特にTSおよびWSオプションに対処するために、セクション1.3にテキストを変更しました。"
    },
    {
      "indent": 3,
      "text": "(d) Section 1.4 was added for [RFC2119] wording. Normative text was updated with the appropriate phrases.",
      "ja": "（d）の1.4節は、[RFC2119]表現のために添加しました。規範的テキストは、適切なフレーズで更新されました。"
    },
    {
      "indent": 3,
      "text": "(e) Added < > brackets to mark specific types of segments, and replaced most occurrences of \"packet\" with \"segment\", where TCP segments are referred to.",
      "ja": "（E）を添加し、<>括弧は、セグメントの特定のタイプをマークし、TCPセグメントが参照される「セグメント」と「パケット」の最も出現を置換します。"
    },
    {
      "indent": 3,
      "text": "(f) Updated the text in Section 3 to take into account what has been learned since [RFC1323].",
      "ja": "（f）は、[RFC1323]以来、学習されたものを考慮に入れるために、セクション3のテキストを更新しました。"
    },
    {
      "indent": 3,
      "text": "(g) Removed some unused references.",
      "ja": "（g）は、いくつかの未使用の参照を削除します。"
    },
    {
      "indent": 3,
      "text": "(h) Removed the list of changes between [RFC1323] and prior versions. These changes are mentioned in Appendix C of [RFC1323].",
      "ja": "（h）は[RFC1323]と以前のバージョン間の変更のリストを削除しました。これらの変更は、[RFC1323]の付録Cに記載されています。"
    },
    {
      "indent": 3,
      "text": "(i) Moved \"Changes from RFC 1323\" to the end of the appendices for easier lookup. In addition, the entries were split into a technical and an editorial part, and sorted to roughly correspond with the sections in the text where they apply.",
      "ja": "（i）は、簡単に検索のための付録の末尾に「RFC 1323からの変更点」を移動しました。また、エントリが技術的および編集部分に分け、それらが適用されたテキストのセクションと概ね一致するように選別しました。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "David Borman Quantum Corporation Mendota Heights, MN 55120 USA",
      "ja": "デビッド・ボーマンQuantum社メンドタハイツ、ミネソタ55120 USA"
    },
    {
      "indent": 3,
      "text": "EMail: david.borman@quantum.com",
      "ja": "メールアドレス：david.borman@quantum.com"
    },
    {
      "indent": 3,
      "text": "Bob Braden University of Southern California 4676 Admiralty Way Marina del Rey, CA 90292 USA",
      "ja": "南カリフォルニアのボブブレーデン大学4676アドミラルティWayマリナデルレイ、CA 90292 USA"
    },
    {
      "indent": 3,
      "text": "EMail: braden@isi.edu",
      "ja": "メールアドレス：braden@isi.edu"
    },
    {
      "indent": 3,
      "text": "Van Jacobson Google, Inc. 1600 Amphitheatre Parkway Mountain View, CA 94043 USA",
      "ja": "ヴァンヤコブソングーグル株式会社1600アンフィシアターパークウェイマウンテンビュー、CA 94043 USA"
    },
    {
      "indent": 3,
      "text": "EMail: vanj@google.com",
      "ja": "メールアドレス：vanj@google.com"
    },
    {
      "indent": 3,
      "text": "Richard Scheffenegger (editor) NetApp, Inc. Am Euro Platz 2 Vienna, 1120 Austria",
      "ja": "リチャードScheffenegger（編集者）のNetApp、Inc.のEUR場所2ウィーン、オーストリア1120年には"
    },
    {
      "indent": 3,
      "text": "EMail: rs@netapp.com",
      "ja": "メールアドレス：rs@netapp.com"
    }
  ]
}