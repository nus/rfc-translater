{
  "title": {
    "text": "RFC 7831 - Application Bridging for Federated Access Beyond Web (ABFAB) Architecture",
    "ja": "RFC 7831 - フェデレーションアクセスを超えたWeb（ABFAB）アーキテクチャのアプリケーションブリッジング"
  },
  "number": 7831,
  "created_at": "2019-11-02 11:27:33.536000+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                        J. Howlett\nRequest for Comments: 7831                                          Jisc\nCategory: Informational                                       S. Hartman\nISSN: 2070-1721                                        Painless Security\n                                                           H. Tschofenig\n                                                                ARM Ltd.\n                                                               J. Schaad\n                                                          August Cellars\n                                                                May 2016",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Application Bridging for Federated Access Beyond Web (ABFAB)\n                        Architecture",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "Over the last decade, a substantial amount of work has occurred in the space of federated access management. Most of this effort has focused on two use cases: network access and web-based access. However, the solutions to these use cases that have been proposed and deployed tend to have few building blocks in common.",
      "ja": "過去10年間、仕事のかなりの量は、フェデレーションアクセス管理の空間で発生しています。ネットワークアクセスとWebベースのアクセス：この努力のほとんどは、2つの使用例に焦点を当てています。しかし、提案、展開されているこれらのユースケースの解決策は、共通のいくつかのビルディング・ブロックを持っている傾向があります。"
    },
    {
      "indent": 3,
      "text": "This memo describes an architecture that makes use of extensions to the commonly used security mechanisms for both federated and non-federated access management, including the Remote Authentication Dial-In User Service (RADIUS), the Generic Security Service Application Program Interface (GSS-API), the Extensible Authentication Protocol (EAP), and the Security Assertion Markup Language (SAML). The architecture addresses the problem of federated access management to primarily non-web-based services, in a manner that will scale to large numbers of Identity Providers, Relying Parties, and federations.",
      "ja": "このメモは、リモート認証ダイヤルインユーザーサービス（RADIUS）を含む連合と非フェデレーションの両方のアクセス管理のために一般的に使用されるセキュリティメカニズムの拡張機能を利用しますアーキテクチャについて説明し、一般的なセキュリティサービスアプリケーションプログラムインタフェース（GSS-API ）、拡張認証プロトコル（EAP）、およびのSAML（Security Assertion Markup Language）。アーキテクチャは、IDプロバイダの多く、依拠当事者、および連盟にスケールします方法で、主に非Webベースのサービスへのフェデレーションアクセス管理の問題に対処します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "ja": "このドキュメントはインターネット標準化過程仕様ではありません。それは、情報提供の目的のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are a candidate for any level of Internet Standard; see Section 2 of RFC 5741.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。 IESGによって承認されていないすべての文書がインターネットStandardのどんなレベルの候補です。 RFC 5741のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7831.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7831で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2016 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2016 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................4\n   1.1. Terminology ................................................5\n        1.1.1. Channel Binding .....................................6\n   1.2. An Overview of Federation ..................................8\n   1.3. Challenges for Contemporary Federation ....................11\n   1.4. An Overview of ABFAB-Based Federation .....................11\n   1.5. Design Goals ..............................................14\n2. Architecture ...................................................15\n   2.1. Relying Party to Identity Provider ........................16\n        2.1.1. AAA, RADIUS, and Diameter ..........................17\n        2.1.2. Discovery and Rules Determination ..................19\n        2.1.3. Routing and Technical Trust ........................20\n        2.1.4. AAA Security .......................................21\n        2.1.5. SAML Assertions ....................................22\n   2.2. Client to Identity Provider ...............................24\n        2.2.1. Extensible Authentication Protocol (EAP) ...........24\n        2.2.2. EAP Channel Binding ................................26\n   2.3. Client to Relying Party ...................................26\n        2.3.1. GSS-API ............................................27\n        2.3.2. Protocol Transport .................................28\n        2.3.3. Re-authentication ..................................29\n3. Application Security Services ..................................29\n   3.1. Authentication ............................................29\n   3.2. GSS-API Channel Binding ...................................31\n   3.3. Host-Based Service Names ..................................32\n   3.4. Additional GSS-API Services ...............................33\n4. Privacy Considerations .........................................34\n   4.1. Entities and Their Roles ..................................35\n   4.2. Privacy Aspects of ABFAB Communication Flows ..............36\n        4.2.1. Client to RP .......................................36\n        4.2.2. Client to IdP (via Federation Substrate) ...........37\n        4.2.3. IdP to RP (via Federation Substrate) ...............38\n   4.3. Relationship between User and Entities ....................39\n   4.4. Accounting Information ....................................39\n   4.5. Collection and Retention of Data and Identifiers ..........39\n   4.6. User Participation ........................................40\n5. Security Considerations ........................................40\n6. References .....................................................41\n   6.1. Normative References ......................................41\n   6.2. Informative References ....................................42\nAcknowledgments ...................................................46\nAuthors' Addresses ................................................46",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "Numerous security mechanisms have been deployed on the Internet to manage access to various resources. These mechanisms have been generalized and scaled over the last decade through mechanisms such as the Simple Authentication and Security Layer (SASL) with the Generic Security Server Application Program Interface (GSS-API) (known as the GS2 family) [RFC5801]; the Security Assertion Markup Language (SAML) [OASIS.saml-core-2.0-os]; and the Authentication, Authorization, and Accounting (AAA) architecture as embodied in RADIUS [RFC2865] and Diameter [RFC6733].",
      "ja": "多くのセキュリティメカニズムは、さまざまなリソースへのアクセスを管理するために、インターネット上に展開されています。これらのメカニズムは、そのような（GS2ファミリーとして知られている）一般的なセキュリティサーバアプリケーションプログラムインタフェース（GSS-API）[RFC5801]で簡易認証セキュリティー層（SASL）などのメカニズムを通じて過去10年間に一般化し、拡大縮小されています。セキュリティアサーションマークアップ言語（SAML）[OASIS.samlコア-2.0-OS]。そしてRADIUS [RFC2865]とDiameter [RFC6733]に具現化認証、許可、アカウンティング（AAA）アーキテクチャ。"
    },
    {
      "indent": 3,
      "text": "A Relying Party (RP) is the entity that manages access to some resource. The entity that is requesting access to that resource is often described as the client. Many security mechanisms are manifested as an exchange of information between these entities. The RP is therefore able to decide whether the client is authorized or not.",
      "ja": "証明書利用者（RP）は、いくつかのリソースへのアクセスを管理するエンティティです。そのリソースへのアクセスを要求しているエンティティは、多くの場合、クライアントとして記載されています。多くのセキュリティメカニズムは、これらのエンティティ間の情報交換として明示されています。 RPは、したがって、クライアントが許可されているかどうかを判断することができます。"
    },
    {
      "indent": 3,
      "text": "Some security mechanisms allow the RP to delegate aspects of the access management decision to an entity called the Identity Provider (IdP). This delegation requires technical signaling, trust, and a common understanding of semantics between the RP and IdP. These aspects are generally managed within a relationship known as a \"federation\". This style of access management is accordingly described as \"federated access management\".",
      "ja": "いくつかのセキュリティメカニズムは、RPがアイデンティティプロバイダ（IDP）と呼ばれるエンティティへのアクセス管理意思決定の側面を委任することができます。この代表団は、技術的なシグナリング、信頼、そしてRPとIdPの間の意味の共通理解が必要です。これらの態様は、一般的に、「フェデレーション」として知られている関係の中で管理されています。アクセス管理のこのスタイルは、それに応じて「連合アクセス管理」と記載されています。"
    },
    {
      "indent": 3,
      "text": "Federated access management has evolved over the last decade through specifications like SAML [OASIS.saml-core-2.0-os], OpenID (http://www.openid.net), OAuth [RFC6749], and WS-Trust [WS-TRUST]. The benefits of federated access management include:",
      "ja": "フェデレーテッド・アクセス管理は、SAML [OASIS.samlコア-2.0-OS]、OpenIDの（http://www.openid.net）、OAuthの[RFC6749]、およびWS-Trustの[WS-様仕様を通じて過去10年間に進化してきました信頼]。フェデレーションアクセス管理の利点は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Single or simplified sign-on:",
      "ja": "シングルまたは簡略サインオン："
    },
    {
      "indent": 6,
      "text": "An Internet service can delegate access management, and the associated responsibilities such as identity management and credentialing, to an organization that already has a long-term relationship with the client. This is often attractive, as RPs frequently do not want these responsibilities. The client also requires fewer credentials, which is also desirable.",
      "ja": "インターネットサービスは、すでにクライアントとの長期的な関係を持っている組織に、アクセス管理を委任し、そのようなID管理と資格認定などの関連責任することができます。 RPは頻繁にこれらの責任を望んでいないので、これは、多くの場合、魅力的です。クライアントはまた、望まれる、少数の資格情報が必要です。"
    },
    {
      "indent": 3,
      "text": "Data minimization and user participation:",
      "ja": "データの最小化とユーザーの参加："
    },
    {
      "indent": 6,
      "text": "Often, an RP does not need to know the identity of a client to reach an access management decision. It is frequently only necessary for the RP to know specific attributes about the client -- for example, that the client is affiliated with a particular organization or has a certain role or entitlement. Sometimes, the RP only needs to know a pseudonym of the client.",
      "ja": "多くの場合、RPは、アクセス管理の決定に到達するために、クライアントの身元を知る必要はありません。例えば、クライアントが特定の組織に所属したり、特定の役割または資格を持っていること -  RPは、クライアントに関する特定の属性を知ることが頻繁に必要なだけです。時には、RPは、クライアントの仮名を知っている必要があります。"
    },
    {
      "indent": 6,
      "text": "Prior to the release of attributes to the RP from the IdP, the IdP will check configuration and policy to determine if the attributes are to be released. There is currently no direct client participation in this decision.",
      "ja": "前のIdPからRPへの属性のリリースに、IdPが属性を解除するかどうかを判断するために設定とポリシーをチェックします。この決定には直接クライアントの参加は現在ありません。"
    },
    {
      "indent": 3,
      "text": "Provisioning:",
      "ja": "プロビジョニング："
    },
    {
      "indent": 6,
      "text": "Sometimes, an RP needs, or would like, to know more about a client than an affiliation or a pseudonym. For example, an RP may want the client's email address or name. Some federated access management technologies provide the ability for the IdP to supply this information, either on request by the RP or unsolicited.",
      "ja": "時には、RPのニーズ、または所属または仮名よりもクライアントについての詳細を知るために、したいと思います。例えば、RPは、クライアントの電子メールアドレスや名前をしたいことがあります。いくつかのフェデレーションアクセス管理技術は、IDPはRPまたは未承諾の要求のいずれかで、この情報を提供するための機能を提供します。"
    },
    {
      "indent": 3,
      "text": "This memo describes the Application Bridging for Federated Access Beyond web (ABFAB) architecture. This architecture addresses the problem of federated access management primarily for non-web-based services. This architecture makes use of extensions to the commonly used security mechanisms for both federated and non-federated access management, including RADIUS, the Generic Security Service (GSS), the Extensible Authentication Protocol (EAP), and SAML. The architecture should be extended to use Diameter in the future. It does so in a manner that is designed to scale to large numbers of IdPs, RPs, and federations.",
      "ja": "このメモは、フェデレーションアクセスを超えウェブ（ABFAB）アーキテクチャ用のブリッジングアプリケーションを記述しています。このアーキテクチャは、主に非Webベースのサービスのための統合アクセス管理の問題に対処します。このアーキテクチャは、RADIUS、ジェネリックセキュリティサービス（GSS）、拡張認証プロトコル（EAP）、およびSAMLなどの連合と非フェデレーションの両方のアクセス管理のために一般的に使用されるセキュリティメカニズムへの拡張機能を利用します。アーキテクチャは、将来的には直径を使用するように拡張されなければなりません。これは、大規模のIdPの番号、RPは、と連盟に拡張できるように設計された方法でそうします。"
    },
    {
      "indent": 0,
      "text": "1.1. Terminology",
      "section_title": true,
      "ja": "1.1。用語"
    },
    {
      "indent": 3,
      "text": "This document uses identity management and privacy terminology from [RFC6973]. In particular, this document uses the terms \"identity provider\", \"relying party\", \"identifier\", \"pseudonymity\", \"unlinkability\", and \"anonymity\".",
      "ja": "この文書では、[RFC6973]からアイデンティティ管理とプライバシーの用語を使用しています。特に、この文書では、用語「アイデンティティプロバイダ」、「依拠当事者」、「識別子」、「偽名」、「リンク不能」、および「匿名」を使用しています。"
    },
    {
      "indent": 3,
      "text": "In this architecture, the IdP consists of the following components: an EAP server, a RADIUS server, and, optionally, a SAML Assertion service.",
      "ja": "EAPサーバ、RADIUSサーバ、および、任意に、SAMLアサーションサービス：このアーキテクチャでは、IdPが以下の成分から成ります。"
    },
    {
      "indent": 3,
      "text": "This document uses the term \"Network Access Identifier\" (NAI) as defined in [RFC7542]. An NAI consists of a realm identifier, which is associated with a AAA server, and thus an IdP and a username, that are associated with a specific client of the IdP.",
      "ja": "[RFC7542]で定義されるように、この文書は、用語「ネットワークアクセス識別子」（NAI）を使用します。 NAIは、このようにIdPが特定のクライアントに関連付けられたIdPとユーザー名を、AAAサーバに関連付けられており、領域識別子から成ります。"
    },
    {
      "indent": 3,
      "text": "One of the problems some people have found with reading this document is that the terminology sometimes appears to be inconsistent. This is because the various standards that we refer to use different terms for the same concept. In general, this document uses either the ABFAB term or the term associated with the standard under discussion, as appropriate. For reference, we include Table 1 below, which provides a mapping for these different terms. (Note that items marked \"N/A\" (not applicable) indicate that there is no name that represents the entity.)",
      "ja": "一部の人々は、この文書を読んで発見した問題の一つは、専門用語は時々矛盾す​​るように見えるということです。私たちが参照して様々な規格が同じ概念に対して異なる用語を使用するためです。一般に、この文書はABFAB用語または必要に応じて、検討中の標準に関連した用語のいずれかを使用します。参考のために、我々は、これらの異なる用語のマッピングを提供し、以下の表1を含みます。 （項目が「N / A」（該当せず）エンティティを表す名前がないことを示すマークされていることに注意してください。）"
    },
    {
      "indent": 3,
      "text": "+----------+-----------+--------------------+-----------------------+\n| Protocol | Client    | Relying Party      | Identity Provider     |\n+----------+-----------+--------------------+-----------------------+\n| ABFAB    | N/A       | Relying Party (RP) | Identity Provider     |\n|          |           |                    | (IdP)                 |\n|          |           |                    |                       |\n|          | Initiator | Acceptor           | N/A                   |\n|          |           |                    |                       |\n|          | Client    | Server             | N/A                   |\n|          |           |                    |                       |\n| SAML     | Subject   | Service provider   | Issuer                |\n|          |           |                    |                       |\n| GSS-API  | Initiator | Acceptor           | N/A                   |\n|          |           |                    |                       |\n| EAP      | EAP peer  | EAP authenticator  | EAP server            |\n|          |           |                    |                       |\n| AAA      | N/A       | AAA client         | AAA server            |\n|          |           |                    |                       |\n| RADIUS   | user      | NAS                | N/A                   |\n|          |           |                    |                       |\n|          | N/A       | RADIUS client      | RADIUS server         |\n+----------+-----------+--------------------+-----------------------+",
      "raw": true
    },
    {
      "indent": 27,
      "text": "Table 1: Terminology",
      "ja": "表1：用語"
    },
    {
      "indent": 0,
      "text": "1.1.1. Channel Binding",
      "section_title": true,
      "ja": "1.1.1。チャネルバインディング"
    },
    {
      "indent": 3,
      "text": "This document uses the term \"channel binding\" in two different contexts; this term has a different meaning in each of these contexts.",
      "ja": "この文書では、二つの異なる文脈で用語「結合チャネル」を使用しています。この用語は、これらのコンテキストのそれぞれに異なる意味を持ちます。"
    },
    {
      "indent": 3,
      "text": "EAP channel binding is used to implement GSS-API naming semantics. EAP channel binding sends a set of attributes from the peer to the EAP server either as part of the EAP conversation or as part of a secure association protocol. In addition, attributes are sent in the back-end protocol from the EAP authenticator to the EAP server. The",
      "ja": "EAPチャネル結合は、GSS-APIのネーミングセマンティクスを実装するために使用されます。結合EAPチャネルは、EAPの会話の一部として、またはセキュアアソシエーションプロトコルの一部としてのいずれかEAPサーバにピアから属性のセットを送信します。また、属性は、EAPサーバへのEAP認証からバックエンドプロトコルで送信されます。ザ・"
    },
    {
      "indent": 3,
      "text": "EAP server confirms the consistency of these attributes and provides the confirmation back to the peer. In this document, channel binding without qualification refers to EAP channel binding.",
      "ja": "EAPサーバは、これらの属性の一貫性を確認し、バックピアに確認を提供します。この文書では、修飾なしで結合チャネルが結合EAPチャネルを指します。"
    },
    {
      "indent": 3,
      "text": "GSS-API channel binding provides protection against man-in-the-middle attacks when GSS-API is used for authentication inside of some tunnel; it is similar to a facility called \"cryptographic binding\" in EAP. The binding works by each side deriving a cryptographic value from the tunnel itself and then using that cryptographic value to prove to the other side that it knows the value.",
      "ja": "GSS-APIは、いくつかのトンネルの内部で認証に使用されたときに結合GSS-APIのチャンネルは、man-in-the-middle攻撃に対する保護を提供します。それは、EAPに「暗号の結合」と呼ばれる施設に似ています。各側面によって結合作品トンネル自体から暗号値を導出し、それが値を知っていることを他の側に証明するために、その暗号値を使用。"
    },
    {
      "indent": 3,
      "text": "See [RFC5056] for a discussion of the differences between these two facilities. These differences can be summarized as follows:",
      "ja": "これら2つの機能の相違点については、[RFC5056]を参照してください。次のようにこれらの違いをまとめることができます。"
    },
    {
      "indent": 3,
      "text": "o GSS-API channel binding specifies that there is nobody between the client and the EAP authenticator.",
      "ja": "結合O GSS-APIのチャンネルは、クライアントとEAP認証の間に誰もが存在しないことを指定します。"
    },
    {
      "indent": 3,
      "text": "o EAP channel binding allows the client to have knowledge of such EAP authenticator attributes as the EAP authenticator's name.",
      "ja": "O EAPチャネルバインディングは、クライアントが、そのようなEAP認証の知識EAP認証者の名前などの属性を持つことができます。"
    },
    {
      "indent": 3,
      "text": "Typically, when considering both EAP and GSS-API channel binding, people think of channel binding in combination with mutual authentication. This is sufficiently common that, without additional qualification, channel binding should be assumed to imply mutual authentication. In GSS-API, without mutual authentication, only the acceptor has authenticated the initiator. Similarly, in EAP, only the EAP server has authenticated the peer. Sometimes, one-way authentication is useful. Consider, for example, a user who wishes to access a protected resource for a shared whiteboard in a conference room. The whiteboard is the acceptor; it knows that the initiator is authorized to give it a presentation, and the user can validate that the whiteboard got the correct presentation by visual means. (The presentation should not be confidential in this case.) If channel binding is used without mutual authentication, it is effectively a request to disclose the resource in the context of a particular channel. Such an authentication would be similar in concept to a holder-of-key SAML Assertion. However, note also that although it is not happening in the protocol, mutual authentication is happening in the overall system: the user is able to visually authenticate the content. This is consistent with all uses of channel binding without protocol-level mutual authentication found so far.",
      "ja": "EAPとGSS-APIチャネル結合の両方を考慮する際に一般的に、人々は相互認証と組み合わせて結合チャネルを考えます。これは、追加の資格なしに、結合チャネルは、相互認証を意味すると仮定しなければならない、ということに十分一般的です。 GSS-APIでは、相互認証なしで、唯一のアクセプターは、イニシエータを認証しました。同様に、EAPにのみEAPサーバはピアを認証しました。時には、一方向の認証が有効です。例えば、会議室での共有、ホワイトボードのための保護されたリソースにアクセスしたいユーザーを考えてみましょう。ホワイトボードには、アクセプターです。それは、イニシエータがそれにプレゼンテーションを与えることを許可されていることを知っており、利用者は、ホワイトボードが視覚的手段によって正しいプレゼンテーションを得たことを検証することができます。 （プレゼンテーションは、この場合には秘匿すべきではない。）チャネル結合は、相互認証なしで使用される場合、効果的に、特定のチャネルのコンテキスト内のリソースを開示するための要求です。このような認証は、ホルダのキーSAMLアサーションの概念と同様であろう。しかし、それはプロトコルで何が起こっていないが、相互認証がシステム全体で起こっていることにも注意してください。ユーザーが視覚的にコンテンツを認証することができます。これは、これまでに見つかったプロトコルレベルの相互認証なしに結合チャネルのすべての使用と一致しています。"
    },
    {
      "indent": 0,
      "text": "1.2. An Overview of Federation",
      "section_title": true,
      "ja": "1.2。連盟の概要"
    },
    {
      "indent": 3,
      "text": "In the previous section, we introduced the following entities:",
      "ja": "前のセクションでは、次のエンティティを導入しました："
    },
    {
      "indent": 3,
      "text": "o the client,",
      "ja": "クライアントO、"
    },
    {
      "indent": 3,
      "text": "o the IdP, and",
      "ja": "IdPのO、および"
    },
    {
      "indent": 3,
      "text": "o the RP.",
      "ja": "RP O。"
    },
    {
      "indent": 3,
      "text": "The final entity that needs to be introduced is the Individual. An Individual is a human being that is using the client. In any given situation, an Individual may or may not exist. Clients can act as front ends for Individuals, or clients may be independent entities that are set up and allowed to run autonomously. An example of such an independent entity can be found in the Trust Router Protocol (https://www.ietf.org/proceedings/86/slides/slides-86-rtgarea-0.pdf), where the routers use ABFAB to authenticate to each other.",
      "ja": "導入する必要があり、最終的な実体は個人です。個々のクライアントを使用している人間です。任意の与えられた状況では、個体は、または存在してもしなくてもよいです。フロントは個人のために終わるとクライアントが機能することができ、またはクライアントを設定し、自律的に実行するために許可されている独立した構成要素であってもよいです。そのような独立したエンティティの例は、ルータが認証にABFABを使用トラストルータプロトコル（https://www.ietf.org/proceedings/86/slides/slides-86-rtgarea-0.pdf）、に見出すことができますお互いに。"
    },
    {
      "indent": 3,
      "text": "These entities and their relationships are illustrated graphically in Figure 1.",
      "ja": "これらのエンティティおよびそれらの関係を図1にグラフで示されています。"
    },
    {
      "indent": 13,
      "text": ",----------\\                        ,---------\\\n| Identity |       Federation       | Relying |\n| Provider + <--------------------> + Party   |\n`----------'                        '---------'\n       <\n        \\\n         \\ Authentication\n          \\\n           \\\n            \\\n             \\\n              \\  +---------+\n               \\ |         |  O\n                v| Client  | \\|/ Individual\n                 |         |  |\n                 +---------+ / \\",
      "raw": true
    },
    {
      "indent": 16,
      "text": "Figure 1: Entities and Their Relationships",
      "ja": "図1：エンティティとそれらの関係"
    },
    {
      "indent": 3,
      "text": "The relationships between the entities in Figure 1 are as follows:",
      "ja": "次のように図1のエンティティ間の関係は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "Federation",
      "ja": "フェデレーション"
    },
    {
      "indent": 6,
      "text": "The IdP and the RPs are part of a federation. The relationship may be direct (they have an explicit trust relationship) or transitive (the trust relationship is mediated by one or more entities). The federation relationship is governed by a federation agreement. Within a single federation, there may be multiple IdPs as well as multiple RPs.",
      "ja": "IdPとRPは連邦の一部です。関係がまたは推移（信頼関係は、1つまたは複数のエンティティによって媒介される）（彼らは明示的な信頼関係を持っている）直接のかもしれません。フェデレーション関係は、フェデレーション契約によって支配されています。単一フェデレーション内で、複数のIdPと同様に複数のRPが存在してもよいです。"
    },
    {
      "indent": 3,
      "text": "Authentication",
      "ja": "認証"
    },
    {
      "indent": 6,
      "text": "There is a direct relationship between the client and the IdP. This relationship provides the means by which they trust each other and can securely authenticate each other.",
      "ja": "クライアントとIdPの間に直接の関係があります。この関係は、彼らがお互いを信頼し、安全に互いを認証することができる手段を提供します。"
    },
    {
      "indent": 3,
      "text": "A federation agreement typically encompasses operational specifications and legal rules:",
      "ja": "フェデレーション契約は、通常動作仕様や法的ルールを包含する。"
    },
    {
      "indent": 3,
      "text": "Operational Specifications:",
      "ja": "動作仕様："
    },
    {
      "indent": 6,
      "text": "The goal of operational specifications is to provide enough definition that the system works and interoperability is possible. These include the technical specifications (e.g., protocols used to communicate between the three parties), process standards, policies, identity proofing, credential and authentication algorithm requirements, performance requirements, assessment and audit criteria, etc.",
      "ja": "動作仕様の目標は、システムが動作し、相互運用が可能な十分な定義を提供することです。これらは、などの技術仕様（例えば、三者間の通信に使用されるプロトコル）、プロセス標準、ポリシー、身元識別情報の検証、資格及び認証アルゴリズムの要件、性能要件、評価及び監査の基準を含み、"
    },
    {
      "indent": 3,
      "text": "Legal Rules:",
      "ja": "法的ルール："
    },
    {
      "indent": 6,
      "text": "The legal rules take the legal framework into consideration and provide contractual obligations for each entity. The rules define the responsibilities of each party and provide further clarification of the operational specifications. These legal rules regulate the operational specifications, make operational specifications legally binding to the participants, and define and govern the rights and responsibilities of the participants. The legal rules may, for example, describe liability for losses, termination rights, enforcement mechanisms, measures of damage, dispute resolution, warranties, etc.",
      "ja": "法的ルールを考慮に法的枠組みを取り、各エンティティのための契約上の義務を提供しています。ルールは、各当事者の責任を定義し、動作仕様のさらなる明確化を提供します。これらの法的なルールは、動作仕様を調整、動作仕様が合法的に参加者への結合を行い、参加者の権利と責任を定義し、管理します。法的ルールは、例えば、などの損失、終了権、執行メカニズム、被害の対策、紛争解決、保証、責任を記述することができます"
    },
    {
      "indent": 3,
      "text": "The operational specifications can demand the usage of a specific technical infrastructure, including requirements on the message routing intermediaries, to offer the required technical functionality. In other environments, the operational specifications require fewer technical components in order to meet the required technical functionality.",
      "ja": "動作仕様は、必要な技術的な機能を提供するために、メッセージのルーティング仲介上の要件を含む、特定の技術的なインフラストラクチャの使用を要求することができます。他の環境では、動作仕様は、必要な技術的な機能を満たすために、少数の技術的なコンポーネントを必要とします。"
    },
    {
      "indent": 3,
      "text": "The legal rules include many non-technical aspects of federation, such as business practices and legal arrangements, which are outside the scope of the IETF. The legal rules can still have an impact on the architectural setup or on how to ensure the dynamic establishment of trust.",
      "ja": "法的ルールは、このようなビジネス慣行やIETFの範囲外である法的取り決めとして、フェデレーションの多くの非技術的な側面を、含まれています。法的ルールはまだ建築の設定上、または信頼の動的な確立を確保する方法に影響を与えることができます。"
    },
    {
      "indent": 3,
      "text": "While a federation agreement is often discussed within the context of formal relationships, such as between an enterprise and an employee or between a government and a citizen, a federation agreement does not have to require any particular level of formality. For an IdP and a client, it is sufficient for a relationship to be established by something as simple as using a web form and confirmation email. For an IdP and an RP, it is sufficient for the IdP to publish contact information along with a public key and for the RP to use that data. Within the framework of ABFAB, it will generally be required that a mechanism exist for the IdP to be able to trust the identity of the RP; if this is not present, then the IdP cannot provide the assurances to the client that the identity of the RP has been established.",
      "ja": "フェデレーション契約は、多くの場合、企業と従業員の間や政府と市民の間のような形式的な関係の文脈の中で議論されている間、フェデレーション契約は形式のいずれかの特定のレベルを必要とする必要はありません。 IdPのクライアントの場合は、Webフォームと確認メールを使用してのような単純なものによって確立される関係で十分です。 IDPは、公開鍵と一緒に、そのデータを使用するRPの連絡先情報を公開するためのIdPとRPのために、それは十分です。 ABFABの枠組みの中で、一般IDPはRPのアイデンティティを信頼できるようにするためのメカニズムが存在することが必要であろう。これが存在しない場合は、IdPがRPのアイデンティティが確立されたクライアントへの保証を提供することはできません。"
    },
    {
      "indent": 3,
      "text": "The nature of federation dictates that there exists some form of relationship between the IdP and the RP. This is particularly important when the RP wants to use information obtained from the IdP for access management decisions and when the IdP does not want to release information to every RP (or only under certain conditions).",
      "ja": "フェデレーションの性質は、IdPのとRPとの間の関係のいくつかのフォームが存在することを指示します。 RPは、アクセス管理の決定のためにとIDPはすべてのRPに情報を公開したくない場合（または、特定の条件下でのみ）のIdPから得られた情報を使用したいとき、これは特に重要です。"
    },
    {
      "indent": 3,
      "text": "While it is possible to have a bilateral agreement between every IdP and every RP, on an Internet scale, this setup requires the introduction of the multilateral federation concept, as the management of such pair-wise relationships would otherwise prove burdensome.",
      "ja": "それは、すべてのIdPとすべてのRP間の二国間協定を持っていることは可能であるが、このようなペアワイズ関係の管理は、それ以外の場合は負担証明するように、インターネットの規模で、この設定は、多国間連携の概念の導入が必要です。"
    },
    {
      "indent": 3,
      "text": "The IdP will typically have a long-term relationship with the client. This relationship typically involves the IdP positively identifying and credentialing the client (for example, at the time of employment within an organization). When dealing with Individuals, this process is called \"identity proofing\" [NIST-SP.800-63-2]. The relationship will often be instantiated within an agreement between the IdP and the client (for example, within an employment contract or terms of use that stipulate the appropriate use of credentials and so forth).",
      "ja": "IdPが、通常、クライアントとの長期的な関係を持つことになります。この関係は、典型的には、正（例えば、組織内の雇用時）クライアントを識別し、資格認定のIdPを含みます。個人を扱う場合、このプロセスは、「アイデンティティープルーフィング」[NIST-SP.800-63-2]と呼ばれています。関係は、多くの場合（例えば、資格情報の適切な使用を規定など雇用契約または使用条件の範囲内）のIdPとクライアントの間の合意の中でインスタンス化されます。"
    },
    {
      "indent": 3,
      "text": "The nature and quality of the relationship between the client and the IdP are important contributors to the level of trust that an RP may assign to an assertion describing a client made by an IdP. This is sometimes described as the level of assurance [NIST-SP.800-63-2].",
      "ja": "クライアントとIdPの間の関係の性質と品質はRPがIdPが作成されたクライアントを記述したアサーションに割り当てることが信頼のレベルに重要な貢献者です。これは時々保証のレベル[NIST-SP.800-63-2]として記載されています。"
    },
    {
      "indent": 3,
      "text": "Federation does not require an a priori relationship or a long-term relationship between the RP and the client; it is this property of federation that yields many of its benefits. However, federation does not preclude the possibility of a pre-existing relationship between the RP and the client or the possibility that the RP and client may use the introduction to create a new long-term relationship independent of the federation.",
      "ja": "連盟は、先験的関係やRPとクライアントの間の長期的な関係を必要としません。それは、その利点の多くをもたらし連合のこの特性です。しかし、フェデレーションは、RPおよびクライアントまたはRPとクライアントがフェデレーションとは無関係に、新たな長期的な関係を作成するために導入を使用する可能性の間の既存の関係の可能性を排除するものではありません。"
    },
    {
      "indent": 3,
      "text": "Finally, it is important to reiterate that in some scenarios there might indeed be an Individual behind the client and in other cases the client may be autonomous.",
      "ja": "最後に、いくつかのシナリオでは、実際のクライアントの背後にある個々のがあるかもしれませんし、他の例では、クライアントは自律的であり得ることを改めて表明することが重要です。"
    },
    {
      "indent": 0,
      "text": "1.3. Challenges for Contemporary Federation",
      "section_title": true,
      "ja": "1.3。現代連盟の課題"
    },
    {
      "indent": 3,
      "text": "As federated IdPs and RPs (services) proliferate, the role of an Individual can become ambiguous in certain circumstances. For example, a school might provide online access for a student's grades to their parents for review and to the student's teacher for modification. A teacher who is also a parent must clearly distinguish their role upon access.",
      "ja": "フェデレーションのIdPとのRP（サービス）は、個々の役割は、特定の状況においてあいまいになることができ、増殖します。例えば、学校はレビューのために、変更のための学生の先生に自分の両親に生徒の成績のためのオンラインアクセスを提供するかもしれません。また、親である教師は明らかにアクセスすると自分の役割を区別する必要があります。"
    },
    {
      "indent": 3,
      "text": "Similarly, as federations proliferate, it becomes increasingly difficult to discover which IdP(s) a user is associated with. This is true for both the web and non-web case but is particularly acute for the latter, as many non-web authentication systems are not semantically rich enough on their own to allow for such ambiguities. For instance, in the case of an email provider, SMTP and IMAP do not have the ability for the server to request information from the client, beyond the client NAI, that the server would then use to decide between the multiple federations it is associated with. However, the building blocks do exist to add this functionality.",
      "ja": "フェデレーションが増殖と同様に、それはユーザが関連付けられているのIdP（単数または複数）を発見することがますます困難になります。これは、Webおよび非Webの場合の両方に当てはまりますが、多くの非Web認証システムは、このようなあいまいさを可能にするために自分自身に十分な意味的に豊かでないとして、後者のために特に深刻です。例えば、電子メールプロバイダの場合は、SMTPやIMAPサーバは、それが関連付けられている複数の連盟との間で決定するために使用することを、クライアントNAIを超えて、クライアントからの情報を要求するサーバーの能力を持っていません。しかし、ビルディングブロックは、この機能を追加するために存在します。"
    },
    {
      "indent": 0,
      "text": "1.4. An Overview of ABFAB-Based Federation",
      "section_title": true,
      "ja": "1.4。 ABFABベース連盟の概要"
    },
    {
      "indent": 3,
      "text": "The previous section described the general model of federation and the application of access management within the federation. This section provides a brief overview of ABFAB in the context of this model.",
      "ja": "前のセクションでは、フェデレーションの一般的なモデルとフェデレーション内のアクセス管理のアプリケーションを記載しました。このセクションでは、このモデルの文脈でABFABの概要を説明します。"
    },
    {
      "indent": 3,
      "text": "In this example, a client is attempting to connect to a server in order to either get access to some data or perform some type of transaction. In order for the client to mutually authenticate with the server, the following steps are taken in an ABFAB architecture (a graphical view of the steps can be found in Figure 2):",
      "ja": "この例では、クライアントは、いくつかのデータへのアクセスを取得したり、取引のいくつかの種類を実行するためにどちらかのために、サーバーに接続しようとしています。相互サーバで認証するクライアントのために、以下のステップは（ステップのグラフィカルな表示は、図2に見出すことができる）ABFABアーキテクチャに取り込まれます。"
    },
    {
      "indent": 3,
      "text": "1. Client configuration: The client is configured with an NAI assigned by the IdP. It is also configured with any keys, certificates, passwords, or other secret and public information needed to run the EAP protocols between it and the IdP.",
      "ja": "1.クライアントの設定：クライアントは、IdPので割り当てられたNAIで構成されています。また、任意の鍵、証明書、パスワード、またはその他の秘密、それとIdPの間のEAPプロトコルを実行するために必要な公開情報で構成されています。"
    },
    {
      "indent": 3,
      "text": "2. Authentication mechanism selection: The client is configured to use the GSS-EAP GSS-API mechanism for authentication/ authorization.",
      "ja": "2.認証メカニズムの選択：クライアントが認証/認可のためのGSS-EAP GSS-APIメカニズムを使用するように設定されています。"
    },
    {
      "indent": 3,
      "text": "3. Client provides an NAI to RP: The client sets up a transport to the RP and begins GSS-EAP authentication. In response, the RP sends an EAP request message (nested in GSS-EAP) asking for the client's name. The client sends an EAP response with an NAI name form that, at a minimum, contains the realm portion of its full NAI.",
      "ja": "3.クライアントは、RPにNAIを提供します。クライアントは、RPへの輸送を設定し、GSS-EAP認証を開始します。応答では、RPは、クライアントの名前を尋ねる（GSS-EAPにネスト）EAP要求メッセージを送信します。クライアントは、最低でも、その完全なNAIの分野の部分が含まれている、NAI名形式でEAP応答を送信します。"
    },
    {
      "indent": 3,
      "text": "4. Discovery of federated IdP: The RP uses preconfigured information or a federation proxy to determine what IdP to use, based on policy and the realm portion of the provided client NAI. This is discussed in detail below (Section 2.1.2).",
      "ja": "フェデレーションのIdPの4ディスカバリー：RPは、ポリシーおよび提供されるクライアントNAIの分野の部分に基づいて、使用することを何のIdPを決定するために事前設定された情報またはフェデレーションプロキシを使用しています。これは、（2.1.2）以下に詳細に説明されています。"
    },
    {
      "indent": 3,
      "text": "5. Request from RP to IdP: Once the RP knows who the IdP is, it (or its agent) will send a RADIUS request to the IdP. The RADIUS Access-Request encapsulates the EAP response. At this stage, the RP will likely have no idea who the client is. The RP sends its identity to the IdP in AAA attributes, and it may send a SAML request in a AAA attribute. The AAA network checks to see that the identity claimed by the RP is valid.",
      "ja": "RPからのIdPへ5.要求：RPがIdPのが誰であるか知ってたら、それ（またはその代理人）がIdPのにRADIUS要求を送信します。 RADIUSアクセス要求は、EAP応答をカプセル化します。この段階では、RPは、クライアントがある見当がつかないする可能性があります。 RPは、属性のAAAでのIdPにその識別情報を送信し、それがAAA属性でSAML要求を送信することができます。 AAAネットワークのチェックはRPによって要求されたアイデンティティが有効であることを確認してください。"
    },
    {
      "indent": 3,
      "text": "6. IdP begins EAP with the client: The IdP sends an EAP message to the client with an EAP method to be used. The IdP should not re-request the client's name in this message, but clients need to be able to handle it. In this case, the IdP must accept a realm only in order to protect the client's name from the RP. The available and appropriate methods are discussed below (Section 2.2.1).",
      "ja": "6. IdPがクライアントとEAPを開始：IdPが使用するEAP方式でクライアントにEAPメッセージを送信します。 IdPがこのメッセージでは、クライアントの名前を要求し、再べきではありませんが、クライアントはそれを処理できるようにする必要があります。この場合、IdPが唯一のRPからクライアントの名前を保護するためにレルムを受け入れる必要があります。入手可能であり、適切な方法は、（セクション2.2.1）以下に説明します。"
    },
    {
      "indent": 3,
      "text": "7. EAP is run: A bunch of EAP messages are passed between the client (EAP peer) and the IdP (EAP server), until the result of the authentication protocol is determined. The number and content of those messages depend on the EAP method selected. If the IdP is unable to authenticate the client, the IdP sends an",
      "ja": "7. EAPが実行される：認証プロトコルの結果が決定されるまでのEAPメッセージの束は、クライアント（EAPピア）とのIdP（EAPサーバ）間で受け渡されます。これらのメッセージの数と内容は、選択したEAP方式に依存します。 IDPはクライアントを認証できない場合、IdPが送信します"
    },
    {
      "indent": 8,
      "text": "EAP failure message to the RP.  As part of the EAP method, the\nclient sends an EAP channel-binding message to the IdP\n(Section 2.2.2).  In the channel-binding message, the client\nidentifies, among other things, the RP to which it is attempting\nto authenticate.  The IdP checks the channel-binding data from\nthe client against the data provided by the RP via the AAA\nprotocol.  If the bindings do not match, the IdP sends an EAP\nfailure message to the RP.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "8. Successful EAP authentication: At this point, the IdP (EAP server) and client (EAP peer) have mutually authenticated each other. As a result, the client and the IdP hold two cryptographic keys: a Master Session Key (MSK) and an Extended MSK (EMSK). At this point, the client has a level of assurance regarding the identity of the RP, based on the name checking the IdP has done, using the RP naming information from the AAA framework and from the client (by the channel-binding data).",
      "ja": "8.成功したEAP認証：この時点で、IdPの（EAPサーバ）とクライアント（EAPピア）が相互に認証しました。マスターセッションキー（MSK）とExtended MSK（EMSK）：結果として、クライアントとIdPが2つの暗号鍵を保持します。この時点で、クライアントは、AAAフレームワークからと（チャネル結合データによる）クライアントからの情報を命名RPを使用して、行っているのIdPをチェックする名前に基づいてRPのアイデンティティに関する保証レベルを持っています。"
    },
    {
      "indent": 3,
      "text": "9. Local IdP policy check: At this stage, the IdP checks local policy to determine whether the RP and client are authorized for a given transaction/service and, if so, what attributes, if any, will be released to the RP. If the IdP gets a policy failure, it sends an EAP failure message to the RP and client. (The RP will have done its policy checks during the discovery process.)",
      "ja": "9.ローカルのIdPのポリシーチェック：この段階では、IDPはそう、どの属性があれば、RPにリリースされる場合はRPと、クライアントは、特定のトランザクション/サービスの認可とされているかどうかを判断するためにローカルポリシーをチェックします。 IDPは政策の失敗を取得した場合、それはRPとクライアントにEAP失敗メッセージを送信します。 （RPは、検出プロセスの間、そのポリシーのチェックを行っているでしょう。）"
    },
    {
      "indent": 3,
      "text": "10. IdP provides the RP with the MSK: The IdP sends a success result EAP to the RP, along with an optional set of AAA attributes associated with the client (usually as one or more SAML Assertions). In addition, the EAP MSK is returned to the RP.",
      "ja": "10. IdPがMSKとRPを提供する：IdPがクライアント（通常、1つのまたは複数のSAMLアサーションなど）に関連付けられた属性AAAの任意のセットと共に、RPに成功結果EAPを送信します。また、EAP MSKはRPに返されます。"
    },
    {
      "indent": 3,
      "text": "11. RP processes results: When the RP receives the result from the IdP, it should have enough information to either grant or refuse a resource Access-Request. It may have information that associates the client with specific authorization identities. If additional attributes are needed from the IdP, the RP may make a new SAML request to the IdP. It will apply these results in an application-specific way.",
      "ja": "11. RPプロセスの結果：RPは、IdPのから結果を受信すると、それはどちらかの補助金への十分な情報を持っているか、リソースアクセス要求を拒否すべきです。これは、特定の許可のアイデンティティをクライアントに関連付ける情報を有することができます。追加の属性がIdPのから必要とされている場合は、RPは、IdPのに新しいSAML要求を行うことができます。これは、アプリケーション固有の方法で、これらの結果を適用します。"
    },
    {
      "indent": 3,
      "text": "12. RP returns results to client: Once the RP has a response, it must inform the client of the result. If all has gone well, all are authenticated, and the application proceeds with appropriate authorization levels. The client can now complete the authentication of the RP by using the EAP MSK value.",
      "ja": "12. RPリターンクライアントに結果：RPが応答を持っていると、それは結果をクライアントに通知しなければなりません。すべてがうまく行っている場合は、すべてが認証され、適切な権限レベルを持つアプリケーションが進行しています。クライアントは現在、EAP MSK値を使用してRPの認証を完了することができます。"
    },
    {
      "indent": 8,
      "text": "Relying         Client         Identity\nParty                          Provider",
      "raw": true
    },
    {
      "indent": 6,
      "text": "  |              (1)             | Client configuration\n  |               |              |\n  |<-----(2)----->|              | Mechanism selection\n  |               |              |\n  |<-----(3)-----<|              | NAI transmitted to RP\n  |               |              |\n  |<=====(4)====================>| IdP Discovery\n  |               |              |\n  |>=====(5)====================>| Access-Request from RP to IdP\n  |               |              |\n  |               |< - - (6) - -<| EAP method to client\n  |               |              |\n  |               |< - - (7) - ->| EAP exchange to authenticate\n  |               |              | client\n  |               |              |\n  |               |           (8 & 9) Local policy check\n  |               |              |\n  |<====(10)====================<| Results to RP\n  |               |              |\n(11)              |              | RP processes results\n  |               |              |\n  |>----(12)----->|              | Results to client",
      "raw": true
    },
    {
      "indent": 8,
      "text": "Legend:",
      "ja": "伝説："
    },
    {
      "indent": 10,
      "text": "-----: Between client and RP\n=====: Between RP and IdP\n- - -: Between client and IdP (via RP)",
      "raw": true
    },
    {
      "indent": 19,
      "text": "Figure 2: ABFAB Authentication Steps",
      "ja": "図2：ABFAB認証手順"
    },
    {
      "indent": 0,
      "text": "1.5. Design Goals",
      "section_title": true,
      "ja": "1.5。設計目標"
    },
    {
      "indent": 3,
      "text": "Our key design goals are as follows:",
      "ja": "次のように当社の主要な設計目標は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "o Each party in a transaction will be authenticated, although perhaps not identified, and the client will be authorized for access to a specific resource.",
      "ja": "Oおそらく特定されていないが、取引における各当事者は、認証され、クライアントが特定のリソースへのアクセスを許可されます。"
    },
    {
      "indent": 3,
      "text": "o The means of authentication is decoupled from the application protocol so as to allow for multiple authentication methods with minimal changes to the application.",
      "ja": "アプリケーションへの最小の変更で、複数の認証方法を可能にするようにO認証手段は、アプリケーションプロトコルから切り離されます。"
    },
    {
      "indent": 3,
      "text": "o The architecture requires no sharing of long-term private keys between clients and RPs.",
      "ja": "Oアーキテクチャは、クライアントとRP間の長期秘密鍵のない共有を必要としません。"
    },
    {
      "indent": 3,
      "text": "o The system will scale to large numbers of IdPs, RPs, and users.",
      "ja": "OシステムはのIdP、RPは、および多数のユーザーにスケールします。"
    },
    {
      "indent": 3,
      "text": "o The system will be designed primarily for non-web-based authentication.",
      "ja": "Oシステムは、非Webベースの認証のために主に設計されます。"
    },
    {
      "indent": 3,
      "text": "o The system will build upon existing standards, components, and operational practices.",
      "ja": "Oシステムは、既存の規格、コンポーネント、および運用プラクティスの上に構築されます。"
    },
    {
      "indent": 3,
      "text": "Designing new three-party authentication and authorization protocols is difficult and fraught with the risk of cryptographic flaws. Achieving widespread deployment is even more difficult. A lot of attention on federated access has been devoted to the web. This document instead focuses on a non-web-based environment and focuses on those protocols where HTTP is not used. Despite the growing trend to layer every protocol on top of HTTP, there are still a number of protocols available that do not use HTTP-based transports. Many of these protocols are lacking a native authentication and authorization framework of the style shown in Figure 1.",
      "ja": "新三者の認証と認可プロトコルを設計することは難しいと暗号欠陥の危険性をはらんでいます。広範囲の展開を達成することはさらに困難です。フェデレーションアクセスに多くの注目がウェブに専念してきました。このドキュメントではなく、非Webベースの環境に焦点を当て、HTTPが使用されていないそれらのプロトコルに焦点を当てています。 HTTPの上にすべてのプロトコルを層に増加傾向にもかかわらず、HTTPベースのトランスポートを使用していない使用可能なプロトコルの数が残っています。これらのプロトコルの多くは、図1に示したスタイルのネイティブ認証と承認の枠組みを欠いています。"
    },
    {
      "indent": 0,
      "text": "2. Architecture",
      "section_title": true,
      "ja": "2.アーキテクチャ"
    },
    {
      "indent": 3,
      "text": "We have already introduced the federated access architecture, with the illustration of the different actors that need to interact. This section expands on the specifics of providing support for non-web-based applications and provides motivations for design decisions. The main theme of the work described in this document is focused on reusing existing building blocks that have been deployed already and to rearrange them in a novel way.",
      "ja": "我々はすでに対話する必要が異なる俳優のイラストで、フェデレーションアクセスアーキテクチャを導入しました。このセクションでは、非Webベースのアプリケーションのサポートを提供するという仕様に拡張し、設計上の決定のための動機を提供します。このドキュメントで説明する作業の主なテーマは、すでに展開されていると斬新な方法でそれらを再配置するために、既存のビルディング・ブロックを再利用に焦点を当てています。"
    },
    {
      "indent": 3,
      "text": "Although this architecture assumes updates to the RP, the client, and the IdP, those changes are kept at a minimum. A mechanism that can demonstrate deployment benefits (based on ease of updates to existing software, low implementation effort, etc.) is preferred, and there may be a need to specify multiple mechanisms to support the range of different deployment scenarios.",
      "ja": "このアーキテクチャは、RP、クライアント、およびIdPのに更新を前提としていますが、これらの変更は最小限に保たれています。 （既存のソフトウェア、低い実装作業等への更新の容易さに基づいて）配置の利点を実証することができるメカニズムが好ましく、異なる展開シナリオの範囲をサポートするために複数のメカニズムを指定する必要があるかもしれません。"
    },
    {
      "indent": 3,
      "text": "There are a number of ways to encapsulate EAP into an application protocol. For ease of integration with a wide range of non-web-based application protocols, GSS-API was chosen. The technical specification of GSS-EAP can be found in [RFC7055].",
      "ja": "アプリケーションプロトコルにEAPをカプセル化する方法はいくつかあります。非Webベースのアプリケーションプロトコルの広い範囲との統合を容易にするため、GSS-APIが選択されました。 GSS-EAPの技術仕様は、[RFC7055]に見出すことができます。"
    },
    {
      "indent": 3,
      "text": "The architecture consists of several building blocks, as shown graphically in Figure 3. In the following sections, we discuss the data flow between each of the entities, the protocols used for that data flow, and some of the trade-offs made in choosing the protocols.",
      "ja": "選択する際に作られたトレードオフのいくつかを以下のセクションでは、我々は、エンティティ、そのデータフローに使用されるプロトコルのそれぞれとの間のデータフローを論じる図3にグラフで示し、そしてようなアーキテクチャは、いくつかのビルディングブロックで構成されていプロトコル。"
    },
    {
      "indent": 3,
      "text": "                                 +--------------+\n                                 |   Identity   |\n                                 |   Provider   |\n                                 |    (IdP)     |\n                                 +-^----------^-+\n                                   * EAP      o RADIUS\n                                   *          o\n                                 --v----------v--\n                              ///                \\\\\\\n                            //                      \\\\\n                           |        Federation        |\n                           |        Substrate         |\n                            \\\\                      //\n                              \\\\\\                ///\n                                 --^----------^--\n                                   * EAP      o RADIUS\n                                   *          o\n+-------------+                  +-v----------v--+\n|             |                  |               |\n| Client      |  EAP/EAP Method  | Relying Party |\n| Application |<****************>|     (RP)      |\n|             |  GSS-API         |               |\n|             |<---------------->|               |\n|             |  Application     |               |\n|             |  Protocol        |               |\n|             |<================>|               |\n+-------------+                  +---------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Legend:",
      "ja": "伝説："
    },
    {
      "indent": 5,
      "text": "<****>: Client-to-IdP Exchange\n<---->: Client-to-RP Exchange\n<oooo>: RP-to-IdP Exchange\n<====>: Protocol through which GSS-API/GS2 exchanges are tunneled",
      "raw": true
    },
    {
      "indent": 18,
      "text": "Figure 3: ABFAB Protocol Instantiation",
      "ja": "図3：ABFABプロトコルインスタンス化"
    },
    {
      "indent": 0,
      "text": "2.1. Relying Party to Identity Provider",
      "section_title": true,
      "ja": "2.1。 IDプロバイダにパーティーを頼ります"
    },
    {
      "indent": 3,
      "text": "Communication between the RP and the IdP is done by the Federation Substrate. This communication channel is responsible for:",
      "ja": "RPとIdPの間の通信は、連盟基板によって行われます。この通信チャネルは責任があります："
    },
    {
      "indent": 3,
      "text": "o Establishing the trust relationship between the RP and the IdP.",
      "ja": "RPとIdPの間の信頼関係の確立、O。"
    },
    {
      "indent": 3,
      "text": "o Determining the rules governing the relationship.",
      "ja": "関係を管理する規則を決定するO。"
    },
    {
      "indent": 3,
      "text": "o Conveying authentication packets from the client to the IdP and back.",
      "ja": "IdPのバックに、クライアントから認証パケットを伝えるO。"
    },
    {
      "indent": 3,
      "text": "o Providing the means of establishing a trust relationship between the RP and the client.",
      "ja": "RPとクライアント間の信頼関係を確立する手段を提供するO。"
    },
    {
      "indent": 3,
      "text": "o Providing a means for the RP to obtain attributes about the client from the IdP.",
      "ja": "IdPからクライアントに関する属性を取得するためにRPのための手段を提供するO。"
    },
    {
      "indent": 3,
      "text": "The ABFAB working group has chosen the AAA framework for the messages transported between the RP and IdP. The AAA framework supports the requirements stated above, as follows:",
      "ja": "ABFABワーキンググループは、RPとIdPの間で輸送メッセージのAAAフレームワークを選択しました。次のようにAAAフレームワークでは、上記の要件をサポートしています。"
    },
    {
      "indent": 3,
      "text": "o The AAA backbone supplies the trust relationship between the RP and the IdP.",
      "ja": "O AAAバックボーンはRPとIdPの間の信頼関係を提供します。"
    },
    {
      "indent": 3,
      "text": "o The agreements governing a specific AAA backbone contain the rules governing the relationships within the AAA federation.",
      "ja": "O特定のAAAのバックボーンを支配する契約はAAAフェデレーション内の関係を管理する規則が含まれています。"
    },
    {
      "indent": 3,
      "text": "o A method exists for carrying EAP packets within RADIUS [RFC3579] and Diameter [RFC4072].",
      "ja": "方法O RADIUS [RFC3579]とDiameter [RFC4072]内でEAPパケットを搬送するために存在します。"
    },
    {
      "indent": 3,
      "text": "o The use of EAP channel binding [RFC6677] along with the core ABFAB protocol provide the pieces necessary to establish the identities of the RP and the client, while EAP provides the cryptographic methods for the RP and the client to validate that they are talking to each other.",
      "ja": "EAPは、RPと彼らが話していることを検証するために、クライアントの暗号化の方法を提供しながら、EAPチャネルの使用は、コアABFABプロトコルと共に[RFC6677]を結合、O、RPとクライアントのアイデンティティを確立するために必要な部品を提供お互い。"
    },
    {
      "indent": 3,
      "text": "o A method exists for carrying SAML packets within RADIUS [RFC7833]; this method allows the RP to query attributes about the client from the IdP.",
      "ja": "O方法は、RADIUS [RFC7833]内SAMLパケットを搬送するために存在します。この方法は、RPがIdPのからクライアントに関する属性を照会することができます。"
    },
    {
      "indent": 3,
      "text": "Protocols that support the same framework but do different routing are expected to be defined and used in the future. One such effort, called the Trust Router, is to set up a framework that creates a trusted point-to-point channel on the fly (https://www.ietf.org/proceedings/86/slides/slides-86-rtgarea-0.pdf).",
      "ja": "同じフレームワークをサポートするが、異なるルーティングを行うプロトコルは、将来的に定義して使用することが期待されています。そのような努力は、オンザフライで信頼できるポイント・ツー・ポイントのチャネルを作成するフレームワーク（https://www.ietf.org/proceedings/86/slides/slides-86-rtgareaを設定することで、信頼のルーターと呼ばれます-0.pdf）。"
    },
    {
      "indent": 0,
      "text": "2.1.1. AAA, RADIUS, and Diameter",
      "section_title": true,
      "ja": "2.1.1。 AAA、RADIUS、および直径"
    },
    {
      "indent": 3,
      "text": "The usage of the AAA framework with RADIUS [RFC2865] and Diameter [RFC6733] for network access authentication has been successful from a deployment point of view. To map the terminology used in Figure 1 to the AAA framework, the IdP corresponds to the AAA server; the RP corresponds to the AAA client; and the technical building blocks of a federation are AAA proxies, relays, and redirect agents (particularly if they are operated by third parties, such as AAA brokers and clearinghouses). In the case of network access authentication, the front end, i.e., the communication path between the end host and the AAA client, is offered by link-layer protocols that forward authentication protocol exchanges back and forth. An example of a large-scale RADIUS-based federation is eduroam (https://www.eduroam.org).",
      "ja": "ネットワークアクセス認証のためのRADIUSとAAAフレームワーク[RFC2865]とDiameter [RFC6733]の使用は、ビューの展開ポイントから成功しています。 AAAフレームワークに、図1で使用される用語をマッピングするために、IdPがAAAサーバに対応します。 RPは、AAAクライアントに対応します。連邦の技術的なビルディングブロックは、（それらがそのようなAAAブローカーとクリアリングハウスなどの第三者によって操作される場合は特に）AAAプロキシ、リレーであり、そして薬剤をリダイレクトします。ネットワークアクセス認証の場合には、フロントエンド、すなわち、エンドホスト間の通信経路とAAAクライアントは、前後認証プロトコル交換を転送リンク層プロトコルによって提供されます。大規模RADIUSベースのフェデレーションの例はeduroam（https://www.eduroam.org）です。"
    },
    {
      "indent": 3,
      "text": "By using the AAA framework, ABFAB can be built on the federation agreements that already exist; the agreements can then merely be expanded to cover the ABFAB architecture. The AAA framework has already addressed some of the problems outlined above. For example,",
      "ja": "AAAフレームワークを使用することにより、ABFABは既に存在してフェデレーション契約上に構築することができます。契約はその後、単にABFABアーキテクチャをカバーするために拡張することができます。 AAAフレームワークは、すでに上記で概説した問題のいくつかを取り上げています。例えば、"
    },
    {
      "indent": 3,
      "text": "o It already has a method for routing requests based on a domain.",
      "ja": "Oそれは既にドメインに基づいて要求をルーティングするための方法があります。"
    },
    {
      "indent": 3,
      "text": "o It already has an extensible architecture allowing for new attributes to be defined and transported.",
      "ja": "Oそれはすでに新しい属性を定義して搬送することを可能に拡張可能なアーキテクチャを採用しています。"
    },
    {
      "indent": 3,
      "text": "o Pre-existing relationships can be reused.",
      "ja": "O既存の関係を再利用することができます。"
    },
    {
      "indent": 3,
      "text": "The astute reader will notice that RADIUS and Diameter have substantially similar characteristics. Why not pick one? RADIUS and Diameter are deployed in different environments. RADIUS can often be found in enterprise and university networks; RADIUS is also used by operators of fixed networks. Diameter, on the other hand, is deployed by operators of mobile networks. Another key difference is that today RADIUS is largely transported over UDP. The decision regarding which protocol will be appropriate to deploy is left to implementers. The protocol defines all the necessary new AAA attributes as RADIUS attributes. A future document could define the same AAA attributes for a Diameter environment. We also note that there exist proxies that convert from RADIUS to Diameter and back. This makes it possible for both to be deployed in a single Federation Substrate.",
      "ja": "抜け目のない読者は、RADIUSと直径が実質的に同様の特性を有することに気づくであろう。なぜないものを選びますか？ RADIUSと直径が異なる環境で展開されています。 RADIUSは、多くの場合、企業や大学のネットワークで見つけることができます。 RADIUSは、固定ネットワークのオペレータによって使用されます。直径は、一方で、モバイルネットワークのオペレータによって配備されます。もう一つの重要な違いは、今日RADIUSは、主にUDP上で転送されていることです。プロトコルが展開するのが適切でしょうかに関する決定は、実装者に任されています。プロトコルは、RADIUS属性として必要なすべての新しいAAA属性を定義します。将来の文書は、Diameter環境の同じAAAの属性を定義することができます。また、RADIUSからの直径とバックに変換プロキシが存在することに注意してください。これにより、両方を単一連盟基質で展開することができるようになります。"
    },
    {
      "indent": 3,
      "text": "Through the integrity-protection mechanisms in the AAA framework, the IdP can establish technical trust that messages are being sent by the appropriate RP. Any given interaction will be associated with one federation at the policy level. The legal or business relationship defines what statements the IdP is trusted to make and how these statements are interpreted by the RP. The AAA framework also permits the RP or elements between the RP and IdP to make statements about the RP.",
      "ja": "AAAの枠組みの中で整合性保護メカニズムを通じて、IdPがメッセージを適切なRPによって送信されている技術的な信頼関係を確立することができます。任意の相互作用は、ポリシーレベルで1つのフェデレーションに関連付けられます。法的またはビジネスの関係は、これらのステートメントは、RPによってどのように解釈されるかIDPが信頼されている文が作るとするかを定義します。 AAAフレームワークはまた、RPについての声明をするためにRPとのIdP間のRPまたは要素を可能にします。"
    },
    {
      "indent": 3,
      "text": "The AAA framework provides transport for attributes. Statements made about the client by the IdP, statements made about the RP, and other information are transported as attributes.",
      "ja": "AAAフレームワークでは、属性のトランスポートを提供します。 IdPによるクライアントについての発言は、RP、およびその他の情報について発言を属性として輸送されます。"
    },
    {
      "indent": 3,
      "text": "One demand that the AAA substrate makes of the upper layers is that they must properly identify the endpoints of the communication. It must be possible for the AAA client at the RP to determine where to send each RADIUS or Diameter message. Without this requirement, it would be the RP's responsibility to determine the identity of the client on its own, without the assistance of an IdP. This architecture makes use of the Network Access Identifier (NAI), where the IdP is indicated by the realm component [RFC7542]. The NAI is represented and consumed by the GSS-API layer as GSS_C_NT_USER_NAME, as specified in [RFC2743]. The GSS-API EAP mechanism includes the NAI in the EAP Response/Identity message.",
      "ja": "AAA基板は、上位層から作る一つの需要は、彼らが正常に通信のエンドポイントを識別しなければならないということです。 RPでのAAAクライアントがどこ各RADIUSまたはDIAMETERメッセージを送信するかを決定することが可能でなければなりません。この要件がなければ、IdPのの支援なしで、独自にクライアントのアイデンティティを決定するために、RPの責任になります。このアーキテクチャは、IdPのがレルム成分[RFC7542]で示されているネットワークアクセス識別子（NAI）を利用します。 NAIは、[RFC2743]で指定されるように、GSS_C_NT_USER_NAMEとしてGSS-API層で表され、消費されます。 GSS-API EAPメカニズムは、EAP応答/アイデンティティメッセージにNAIを含んでいます。"
    },
    {
      "indent": 3,
      "text": "At the time of this writing, no profiles for the use of Diameter have been created.",
      "ja": "この記事の執筆時点では、直径の使用のためのプロファイルが作成されていません。"
    },
    {
      "indent": 0,
      "text": "2.1.2. Discovery and Rules Determination",
      "section_title": true,
      "ja": "2.1.2。ディスカバリーとルールの決定"
    },
    {
      "indent": 3,
      "text": "While we are using the AAA protocols to communicate with the IdP, the RP may have multiple Federation Substrates to select from. The RP has a number of criteria that it will use in selecting which of the different federations to use. The federation selected must",
      "ja": "我々はIdPのと通信するためにAAAプロトコルを使用している一方で、RPから選択するために、複数の連盟基板を有することができます。 RPは、それが使用する別の連盟の選択に使用する基準の数を持っています。フェデレーション選択必須"
    },
    {
      "indent": 3,
      "text": "o be able to communicate with the IdP.",
      "ja": "OのIdPと通信することができます。"
    },
    {
      "indent": 3,
      "text": "o match the business rules and technical policies required for the RP security requirements.",
      "ja": "O RPセキュリティ要件に必要なビジネスルールや技術的なポリシーに一致します。"
    },
    {
      "indent": 3,
      "text": "The RP needs to discover which federation will be used to contact the IdP. The first selection criterion used during discovery is going to be the name of the IdP to be contacted. The second selection criterion used during discovery is going to be the set of business rules and technical policies governing the relationship; this is called \"rules determination\". The RP also needs to establish technical trust in the communications with the IdP.",
      "ja": "RPは、IdPのに連絡するために使用されるフェデレーション発見する必要があります。発見時に使用される第1の選択基準は、連絡するのIdPの名前になるだろう。発見時に使用される第2の選択基準は、ビジネスルールとの関係を管理する技術的なポリシーのセットになるだろう。これは、「ルールの決定」と呼ばれています。 RPものIdPとの通信には技術的な信頼関係を確立する必要があります。"
    },
    {
      "indent": 3,
      "text": "Rules determination covers a broad range of decisions about the exchange. One of these is whether the given RP is permitted to talk to the IdP using a given federation at all, so rules determination encompasses the basic authorization decision. Other factors are included, such as what policies govern release of information about the client to the RP and what policies govern the RP's use of this information. While rules determination is ultimately a business function, it has a significant impact on the technical exchanges. The protocols need to communicate the result of authorization. When multiple sets of rules are possible, the protocol must disambiguate which set of rules are in play. Some rules have technical enforcement mechanisms; for example, in some federations, intermediaries validate information that is being communicated within the federation.",
      "ja": "ルールの決定は、為替に関する決定の広い範囲をカバーしています。これらの一つは、ルールの決意は、基本的な承認決定を包含して与えられたRPは、全く与えられたフェデレーションを使用してのIdPに話をすることが許可されているかどうかです。その他の要因は、そのような政策はRPとどのような政策はこの情報のRPの使用を管理するクライアントに関する情報のリリースを支配するものとして、含まれています。ルールの決意は、最終的にビジネス機能であるが、それは技術的な交流に大きな影響を有します。プロトコルは認証の結果を通信する必要があります。ルールの複数のセットが可能な場合、プロトコルは、劇中である一連のルール明確にしなければなりません。いくつかのルールは、技術的な実施メカニズムを持っています。例えば、いくつかの連合では、仲介者は、フェデレーション内で通信される情報を検証します。"
    },
    {
      "indent": 3,
      "text": "At the time of this writing, no protocol mechanism has been specified to allow a AAA client to determine whether a AAA proxy will indeed be able to route AAA requests to a specific IdP. The AAA routing is impacted by business rules and technical policies that may be quite complex; at the present time, the route selection is based on manual configuration.",
      "ja": "これを書いている時点では、プロトコルメカニズムは、AAAクライアントは、AAAプロキシが実際に特定のIdPへのルートのAAA要求にできるようになるかどうかを判断できるようにするために指定されていません。 AAAルーティングは、ビジネスルールとはかなり複雑である技術的な政策の影響を受けています。現時点では、経路選択は、手動設定に基づいています。"
    },
    {
      "indent": 0,
      "text": "2.1.3. Routing and Technical Trust",
      "section_title": true,
      "ja": "2.1.3。ルーティングと技術トラスト"
    },
    {
      "indent": 3,
      "text": "Several approaches to having messages routed through the Federation Substrate are possible. These routing methods can most easily be classified based on the mechanism for technical trust that is used. The choice of technical trust mechanism constrains how rules determination is implemented. Regardless of what deployment strategy is chosen, it is important that the technical trust mechanism be able to validate the identities of both parties to the exchange. The trust mechanism must ensure that the entity acting as the IdP for a given NAI is permitted to be the IdP for that realm and that any service name claimed by the RP is permitted to be claimed by that entity. Here are the categories of technical trust determination:",
      "ja": "連盟基板を介してルーティングされたメッセージを持つには、いくつかのアプローチが可能です。これらのルーティング方法が最も簡単に使用されている技術的な信頼のメカニズムに基づいて分類することができます。技術的な信頼メカニズムの選択は、ルールの決定が実装されている方法を制限します。かかわらず、展開戦略が選択されているものの、技術的な信頼メカニズムは、交換機に、両当事者の身元を確認できることが重要です。信頼メカニズムは実体が与えられたNAIのためのIdPとして動作することを確認する必要がありますが、そのレルムのためにとRPが主張する任意のサービス名は、そのエンティティによって要求されるように許可されていることのIdPが許可されています。ここでは技術的な信頼決定のカテゴリは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "AAA Proxy: The simplest model is that an RP is a AAA client and can send the request directly to a AAA proxy. The hop-by-hop integrity protection of the AAA fabric provides technical trust. An RP can submit a request directly to the correct federation. Alternatively, a federation disambiguation fabric can be used. Such a fabric takes information about what federations the RP is part of and what federations the IdP is part of, and it routes a message to the appropriate federation. The routing of messages across the fabric, plus attributes added to requests and responses, together provide rules determination. For example, when a disambiguation fabric routes a message to a given federation, that federation's rules are chosen. Name validation is enforced as messages travel across the fabric. The entities near the RP confirm its identity and validate names it claims. The fabric routes the message towards the appropriate IdP, validating the name of the IdP in the process. The routing can be statically configured. Alternatively, a routing protocol could be developed to exchange reachability information about a given IdP and to apply policy across the AAA fabric. Such a routing protocol could flood naming constraints to the appropriate points in the fabric.",
      "ja": "AAAプロキシ：最も単純なモデルは、RPは、AAAクライアントであり、AAAプロキシに直接リクエストを送ることができるということです。 AAA生地のホップバイホップ完全性保護は、技術的な信頼を提供します。 RPは、正しいフェデレーションに直接リクエストを送信することができます。あるいは、フェデレーション一義化生地を使用することができます。そのようなファブリックは、RPがその一部である連盟と何のIdPを連合するの一部であり、ルート適切なフェデレーションへのメッセージについての情報を要します。ファブリック全体メッセージのルーティング、プラスの属性は、ルール決意を提供すると共に、要求と応答に加えました。例えば、所与のフェデレーションに曖昧さ回避ファブリックルートメッセージは、その連盟のルールが選択される場合。メッセージがファブリック全体旅行として名前の検証が実施されます。 RP近くの実体は、その身元を確認し、それが主張名を検証します。ファブリックルートプロセスでのIdPの名前を検証する適切なのIdPに向かってメッセージ。ルーティングは、静的に設定することができます。代替的に、ルーティングプロトコルは、所与のIdPに関する到達可能性情報を交換し、AAAファブリック全体ポリシーを適用するために開発され得ます。このようなルーティングプロトコルは、ファブリック内の適切なポイントに制約を命名あふれことができます。"
    },
    {
      "indent": 3,
      "text": "Trust Broker: Instead of routing messages through AAA proxies, some trust broker could establish keys between entities near the RP and entities near the IdP. The advantage of this approach is efficiency of message handling. Fewer entities are needed to be involved for each message. Security may be improved by sending individual messages over fewer hops. Rules determination involves decisions made by trust brokers about what keys to grant. Also, associated with each credential is context about rules and about other aspects of technical trust, including names that may be claimed. A routing protocol similar to the one for AAA proxies is likely to be useful to trust brokers in flooding rules and naming constraints.",
      "ja": "トラストブローカー：代わりにAAAプロキシを介してメッセージをルーティングするの、いくつかの信頼ブローカーはIdPの近くRP近くエンティティとエンティティ間のキーを確立することができます。このアプローチの利点は、メッセージ処理の効率です。少数のエンティティは、各メッセージのために関与していることが必要とされています。セキュリティが少ないホップの上に個々のメッセージを送信することによって改善することができます。ルールの決意は、キーを付与するかについての信頼ブローカーによる判断を必要とします。また、各資格に関連したルールについて、主張することができる名前などの技術的な信頼関係の他の側面に関する状況です。 AAAプロキシの1に似たルーティングプロトコルは、洪水のルールと命名制約にブローカーを信頼することが有用である可能性があります。"
    },
    {
      "indent": 3,
      "text": "Global Credential: A global credential such as a public key and certificate in a public key infrastructure can be used to establish technical trust. A directory or distributed database such as the Domain Name System is used by the RP to discover the endpoint to contact for a given NAI. Either the database or certificates can provide a place to store information about rules determination and naming constraints. Provided that no intermediates are required (or appear to be required) and that the RP and IdP are sufficient to enforce and determine rules, rules determination is reasonably simple. However, applying certain rules is likely to be quite complex. For example, if multiple sets of rules are possible between an IdP and RP, confirming that the correct set is used may be difficult. This is particularly true if intermediates are involved in making the decision. Also, to the extent that directory information needs to be trusted, rules determination may be more complex.",
      "ja": "グローバル資格：公開鍵インフラストラクチャにおける公開鍵と証明書などのグローバル資格情報は、技術的な信頼関係を確立するために使用することができます。そのようなドメインネームシステムなどのディレクトリまたは分散データベースは、指定されたNAIのために連絡するエンドポイントを発見するためにRPによって使用されます。データベースまたは証明書のどちらかがルールの決定と命名制約に関する情報を格納する場所を提供することができます。いかなる中間体が必要とされないことを条件とする（または必要であると思われる）とRPとIDPがルールを適用し、決定するのに十分であることを、判定が合理単純で規則。しかし、一定のルールを適用することは非常に複雑である可能性が高いです。ルールの複数のセットは、IdPのとRPとの間で可能である場合、例えば、正しいセットが使用されていることを確認することは難しいかもしれません。中間体は意思決定に関与している場合、これは特にそうです。また、ディレクトリ情報が信頼される必要程度まで、ルールの決定は、より複雑であってもよいです。"
    },
    {
      "indent": 3,
      "text": "Real-world deployments are likely to be mixtures of these basic approaches. For example, it will be quite common for an RP to route traffic to a AAA proxy within an organization. That proxy could then use any of the above three methods to get closer to the IdP. It is also likely that, rather than being directly reachable, the IdP may have a proxy on the edge of its organization. Federations will likely provide a traditional AAA proxy interface even if they also provide another mechanism for increased efficiency or security.",
      "ja": "実世界の展開では、これらの基本的なアプローチの混合物である可能性が高いです。例えば、それは、組織内のAAAプロキシにトラフィックをルーティングするRPのための非常に一般的になります。そのプロキシは、その後のIdPに近づくために、上記の3つの方法のいずれかを使用することができます。直接到達可能であることではなく、IDPはその組織の端にプロキシを有することができる、ということもありそうです。連盟はおそらく、彼らはまた、高効率化やセキュリティのために別のメカニズムを提供した場合でも、従来のAAAプロキシインタフェースを提供します。"
    },
    {
      "indent": 0,
      "text": "2.1.4. AAA Security",
      "section_title": true,
      "ja": "2.1.4。 AAAセキュリティ"
    },
    {
      "indent": 3,
      "text": "For the AAA framework, there are two different places where security needs to be examined. The first is the security that is in place for the links in the AAA backbone being used. The second are the nodes that form the AAA backbone.",
      "ja": "AAAフレームワークのために、セキュリティを検査する必要がある2つの異なる場所があります。最初は、使用しているAAAのバックボーン内のリンクのための場所にあるセキュリティです。第二は、AAAの骨格を形成するノードです。"
    },
    {
      "indent": 3,
      "text": "The default link security for RADIUS is showing its age, as it uses MD5 and a shared secret to both obfuscate passwords and provide integrity on the RADIUS messages. While some EAP methods include the ability to protect the client authentication credentials, the MSK returned from the IdP to the RP is protected only by RADIUS security. In many environments, this is considered to be insufficient, especially as not all attributes are obfuscated and can thus leak information to a passive eavesdropper. The use of RADIUS with Transport Layer Security (TLS) [RFC6614] and/or Datagram Transport Layer Security (DTLS) [RFC7360] addresses these attacks. The same level of security is included in the base Diameter specifications.",
      "ja": "それは、パスワードを難読化し、RADIUSメッセージに整合性を提供し、両方にMD5と共有秘密を使用してRADIUSのデフォルトのリンクのセキュリティは、その年齢を示しています。いくつかのEAPメソッドは、クライアント認証の資格情報を保護する機能が含まれますが、MSKはRPへのIdPから返されるだけRADIUSセキュリティで保護されています。多くの環境では、これがすべてではない属性が難読化され、したがって受動盗聴者に情報を漏洩することができ、特にとして、不十分であると考えられます。トランスポート層セキュリティ（TLS）[RFC6614]および/またはデータグラムトランスポート層セキュリティ（DTLS）[RFC7360]でRADIUSを使用すると、これらの攻撃に対処しています。同じレベルのセキュリティは、ベース直径仕様に含まれています。"
    },
    {
      "indent": 0,
      "text": "2.1.5. SAML Assertions",
      "section_title": true,
      "ja": "2.1.5。 SAMLアサーション"
    },
    {
      "indent": 3,
      "text": "For the traditional use of AAA frameworks, i.e., granting access to a network, an affirmative response from the IdP is sufficient. In the ABFAB world, the RP may need to get significantly more additional information about the client before granting access. ABFAB therefore has a requirement that it can transport an arbitrary set of attributes about the client from the IdP to the RP.",
      "ja": "AAAフレームワークの伝統的な使用のために、即ち、ネットワークへのアクセスを許可する、のIdPからの肯定応答が十分です。 ABFABの世界では、RPは、アクセスを許可する前に、クライアントについてかなり多くの追加情報を取得する必要があるかもしれません。 ABFABしたがって、それはRPへのIdPからクライアントに関する属性の任意のセットを輸送することができる要件があります。"
    },
    {
      "indent": 3,
      "text": "The Security Assertion Markup Language (SAML) [OASIS.saml-core-2.0-os] was designed in order to carry an extensible set of attributes about a subject. Since SAML is extensible in the attribute space, ABFAB has no immediate needs to update the core SAML specifications for our work. It will be necessary to update IdPs that need to return SAML Assertions to RPs and for both the IdP and the RP to implement a new SAML profile designed to carry SAML Assertions in AAA. The new profile can be found in [RFC7833]. As SAML statements will frequently be large, RADIUS servers and clients that deal with SAML statements will need to implement [RFC7499].",
      "ja": "セキュリティアサーションマークアップ言語（SAML）[OASIS.samlコア-2.0-OSは、主題に関する属性の拡張可能なセットを実行するために設計しました。 SAMLは、属性空間で拡張可能であるので、ABFABは、私たちの仕事のためのコアSAML仕様を更新する当面のニーズを持っていません。のRPにとのIdPとAAAでSAMLアサーションを運ぶために設計された新しいSAMLプロファイルを実装するためのRPの両方のためのSAMLアサーションを返す必要のIdPを更新する必要があります。新しいプロファイルが[RFC7833]で見つけることができます。 SAML文が頻繁に大きくなるように、SAML文を扱うRADIUSサーバとクライアントは[RFC7499]を実装する必要があります。"
    },
    {
      "indent": 3,
      "text": "There are several issues that need to be highlighted:",
      "ja": "強調表示する必要があるいくつかの問題があります。"
    },
    {
      "indent": 3,
      "text": "o The security of SAML Assertions.",
      "ja": "SAMLアサーションのセキュリティO。"
    },
    {
      "indent": 3,
      "text": "o Namespaces and mapping of SAML attributes.",
      "ja": "OネームスペースとSAMLのマッピング属性。"
    },
    {
      "indent": 3,
      "text": "o Subject naming of entities.",
      "ja": "エンティティのO件名の命名。"
    },
    {
      "indent": 3,
      "text": "o Making multiple queries about the subject(s).",
      "ja": "被験体（複数可）に関する複数のクエリを作るO。"
    },
    {
      "indent": 3,
      "text": "o Level of assurance for authentication.",
      "ja": "認証のための保証のOレベル。"
    },
    {
      "indent": 3,
      "text": "SAML Assertions have an optional signature that can be used to protect and provide the origination of the assertion. These signatures are normally based on asymmetric key operations and require that the verifier be able to check not only the cryptographic operation but also the binding of the originator's name and the public key. In a federated environment, it will not always be possible for the RP to validate the binding; for this reason, the technical trust established in the federation is used as an alternate method of validating the origination and integrity of the SAML Assertion.",
      "ja": "SAMLアサーションは、アサーションの発信を保護し、提供するために使用され得る任意の署名を持っています。これらの署名は、通常、非対称キー操作に基づいており、検証が暗号操作だけでなく、発信者の名前と公開鍵の結合だけでなくチェックすることができることを要求されています。 RPは、バインディングを検証するためにフェデレーテッド環境では、それは常に可能ではないだろう。このような理由のために、フェデレーションに設立された技術的信頼はSAMLアサーションの発信と整合性を検証する別の方法として使用されています。"
    },
    {
      "indent": 3,
      "text": "Attributes in a SAML Assertion are identified by a name string. The name string is either assigned by the SAML issuer context or scoped by a namespace (for example, a URI or object identifier (OID)). This means that the same attribute can have different name strings used to identify it. In many cases, but not all, the federation agreements will determine what attributes and names can be used in a SAML statement. This means that the RP needs to map from the SAML issuer or federation name, type, and semantic to the name, type, and semantics that the policies of the RP are written in. In other cases, the Federation Substrate, in the form of proxies, will modify the SAML Assertions in transit to do the necessary name, type, and value mappings as the assertion crosses boundaries in the federation. If the proxies are modifying the SAML Assertion, then they will remove any signatures on the SAML Assertion, as changing the content of the SAML Assertion would invalidate the signature. In this case, the technical trust is the required mechanism for validating the integrity of the assertion. (The proxy could re-sign the SAML Assertion, but the same issues of establishing trust in the proxy would still exist.) Finally, the attributes may still be in the namespace of the originating IdP. When this occurs, the RP will need to get the required mapping operations from the federation agreements and do the appropriate mappings itself.",
      "ja": "SAMLアサーションの属性は、名前の文字列によって識別されます。名前ストリングは、名前空間によってSAML発行者コンテキストによって割り当てまたはスコープされるか（例えば、URIまたはオブジェクト識別子（OID））。これは、同じ属性は、それを識別するために使用される別の名前の文字列を持つことができることを意味します。多くの場合、すべてではないが、フェデレーション契約はSAML文で使用することができますどのような属性と名前を決定します。これはRPが、SAML発行者またはフェデレーション名からマップのタイプ、および名前の意味的な、タイプ、およびRPのポリシーがで書かれていることの意味する必要があることを意味する。それ以外の場合は、連盟基板を、の形でプロキシは、アサーションがフェデレーションに境界線を横切るように必要な名前、タイプ、および値のマッピングを行うために輸送中のSAMLアサーションを変更します。プロキシはSAMLアサーションを修正している場合、それらは、署名を無効になるSAMLアサーションの内容を変更するように、SAMLアサーションの任意の署名を削除します。この場合、技術的な信頼は、アサーションの整合性を検証するために必要なメカニズムです。 （プロキシはSAMLアサーションを再署名することができますが、プロキシの信頼を確立するのと同じ問題がまだ存在することになる。）最後に、属性がまだ発信元のIdPの名前空間にあってもよいです。これが発生すると、RPは、フェデレーション契約から必要なマッピング操作を取得し、適切なマッピング自体を行う必要があります。"
    },
    {
      "indent": 3,
      "text": "[RFC7833] has defined a new SAML name format that corresponds to the NAI name form defined by [RFC7542]. This allows for easy name matching in many cases, as the name form in the SAML statement and the name form used in RADIUS or Diameter will be the same. In addition to the NAI name form, [RFC7833] also defines a pair of implicit name forms corresponding to the client and the client's machine. These implicit name forms are based on the Identity-Type enumeration defined in the Tunnel Extensible Authentication Protocol (TEAP) specification [RFC7170]. If the name form returned in a SAML statement is not based on the NAI, then it is a requirement on the EAP server that it validate that the subject of the SAML Assertion, if any, is equivalent to the subject identified by the NAI used in the RADIUS or Diameter session.",
      "ja": "[RFC7833]は[RFC7542]で定義されたNAI名形式に対応する新しいSAML名フォーマットを定義しています。これは、SAML文で名形式として、多くの場合、簡単な名前の一致を可能にし、RADIUSまたは直径で使用される名前の形式は同じになります。 NAI名形式に加えて、[RFC7833]は、クライアントとクライアントのマシンに対応する暗黙の名前形式の対を画定します。これらの暗黙の名前形式は、トンネル拡張認証プロトコル（TEAP）仕様[RFC7170]で定義されたアイデンティティ型の列挙に基づいています。名前のフォームは、NAIに基づいていないSAML文で返された場合、それはそれはSAMLアサーションの主題は、もしあれば、中に使用NAIで識別対象と等価であることを検証するEAPサーバ上の要件は、 RADIUSまたはDIAMETERセッション。"
    },
    {
      "indent": 3,
      "text": "RADIUS has the ability to deal with multiple SAML queries for those EAP servers that follow [RFC5080]. In this case, a State attribute will always be returned with the Access-Accept. The EAP client can then send a new Access-Request with the State attribute and the new",
      "ja": "RADIUSは、[RFC5080]を従って、これらのEAPサーバに対して複数のSAMLクエリに対処する能力を持っています。この場合、State属性は常にアクセス - 受け入れで返されます。 EAPクライアントは、State属性と新しいで新しいアクセス要求を送信することができます"
    },
    {
      "indent": 3,
      "text": "SAML request. Multiple SAML queries can then be done by making a new Access-Request, using the State attribute returned in the last Access-Accept to link together the different RADIUS sessions.",
      "ja": "SAML要求。複数のSAMLクエリは、最後に返されたState属性使用して、新しいアクセス要求を行うことによって行うことができます異なるRADIUSセッションを一緒にリンクするためにアクセスし、受け入れます。"
    },
    {
      "indent": 3,
      "text": "Some RPs need to ensure that specific criteria are met during the authentication process. This need is met by using levels of assurance. A level of assurance is communicated to the RP from the EAP server by using a SAML Authentication Request, using the Authentication Profile described in [RFC7833]. When crossing boundaries between different federations, (1) the policy specified will need to be shared between the two federations, (2) the policy will need to be mapped by the proxy server on the boundary, or (3) the proxy server on the boundary will need to supply information to the EAP server so that the EAP server can do the required mapping. If this mapping is not done, then the EAP server will not be able to enforce the desired level of assurance, as it will not understand the policy requirements.",
      "ja": "いくつかのRPは、特定の基準は、認証プロセス中に満たされていることを確認する必要があります。この必要性は、保証のレベルを使用することによって満たされます。保証のレベルは、[RFC7833]に記載の認証プロファイルを使用して、SAML認証要求を使用してEAPサーバからRPに伝達されます。異なるフェデレーションの境界を横断するとき、（1）指定されたポリシーは、2つの連合の間で共有される必要がある、（2）ポリシーは、上の境界上のプロキシサーバ、または（3）プロキシサーバーによってマッピングされる必要があります境界は、EAPサーバが必要なマッピングを行うことができますように、EAPサーバに情報を提供する必要があります。このマッピングが行われていない場合、それはポリシー要件を理解していないだろうとして、その後、EAPサーバは、保証の所望のレベルを強制することはできません。"
    },
    {
      "indent": 0,
      "text": "2.2. Client to Identity Provider",
      "section_title": true,
      "ja": "2.2。アイデンティティプロバイダへのクライアント"
    },
    {
      "indent": 3,
      "text": "Looking at the communications between the client and the IdP, the following items need to be dealt with:",
      "ja": "クライアントとIdPの間の通信を見てみると、以下の項目がに対処する必要があります"
    },
    {
      "indent": 3,
      "text": "o The client and the IdP need to mutually authenticate each other.",
      "ja": "クライアントとのIdP oを相互に認証する必要があります。"
    },
    {
      "indent": 3,
      "text": "o The client and the IdP need to mutually agree on the identity of the RP.",
      "ja": "OクライアントとIdPが相互にRPのアイデンティティに同意する必要があります。"
    },
    {
      "indent": 3,
      "text": "ABFAB selected EAP for the purposes of mutual authentication and assisted in creating some new EAP channel-binding documents for dealing with determining the identity of the RP. A framework for the channel-binding mechanism has been defined in [RFC6677] that allows the IdP to check the identity of the RP provided by the AAA framework against the identity provided by the client.",
      "ja": "ABFABは、相互認証のためにEAPを選択し、RPの同一性を決定するに対処するためのいくつかの新しいEAPチャネル結合の文書を作成する際に支援しました。チャネル結合機構のためのフレームワークは、IDPは、クライアントによって提供されたIDに対してAAAフレームワークによって提供されるRPの身元を確認することを可能にする[RFC6677]で定義されています。"
    },
    {
      "indent": 0,
      "text": "2.2.1. Extensible Authentication Protocol (EAP)",
      "section_title": true,
      "ja": "2.2.1。拡張認証プロトコル（EAP）"
    },
    {
      "indent": 3,
      "text": "Traditional web federation does not describe how a client interacts with an IdP for authentication. As a result, this communication is not standardized. There are several disadvantages to this approach. Since the communication is not standardized, it is difficult for machines to recognize which entity is going to do the authentication, and thus which credentials to use and where in the authentication form the credentials are to be entered. It is much easier for humans to correctly deal with these problems. The use of browsers for authentication restricts the deployment of more secure forms of authentication beyond plaintext usernames and passwords known by the server. In a number of cases, the authentication interface may be presented before the client has adequately validated that they are talking to the intended server. By giving control of the authentication interface to a potential attacker, the security of the system may be reduced, and opportunities for phishing may be introduced.",
      "ja": "従来のWeb連盟は、クライアントが認証のためのIdPと対話する方法については説明しません。その結果、この通信は標準化されていません。このアプローチにはいくつかの欠点があります。通信は標準化されていないので、マシンが認証をするつもりので、使用する資格情報と場所の認証に資格情報を入力するようにしている形成されたエンティティを認識することは困難です。人間が正しく、これらの問題に対処するためにはるかに簡単です。認証用のブラウザを使用することは、サーバによって知られている平文のユーザ名とパスワードを越えてさらに安全な認証形式の展開を制限します。多くの場合、認証インターフェースは、クライアントが適切に彼らが意図したサーバーに話していることを検証した前に提示することができます。潜在的な攻撃者に認証インターフェースの制御を与えることによって、システムのセキュリティを低減することができる、及びフィッシングの機会を導入してもよいです。"
    },
    {
      "indent": 3,
      "text": "As a result, it is desirable to choose some standardized approach for communication between the client's end host and the IdP. There are a number of requirements this approach must meet, as noted below.",
      "ja": "その結果、クライアントのエンドホストとIdPの間の通信のためのいくつかの標準化されたアプローチを選択することが望ましいです。後述のように、このアプローチは、満たさなければならない要件がいくつかあります。"
    },
    {
      "indent": 3,
      "text": "Experience has taught us one key security and scalability requirement: it is important that the RP not get possession of the long-term secret of the client. Aside from a valuable secret being exposed, a synchronization problem can develop when the client changes keys with the IdP.",
      "ja": "経験は私たちに一つのキーセキュリティやスケーラビリティ要件を教えています：RPは、クライアントの長期的な秘密の所有権を取得しないことが重要です。貴重な秘密が暴露されているから別に、同期の問題は、クライアントがIdPのでキーを変更したときに開発することができます。"
    },
    {
      "indent": 3,
      "text": "Since there is no single authentication mechanism that will be used everywhere, another associated requirement is that the authentication framework must allow for the flexible integration of authentication mechanisms. For instance, some IdPs require hardware tokens, while others use passwords. A service provider wants to provide support for both authentication methods and also for other methods from IdPs not yet seen.",
      "ja": "どこでも使用される単一の認証メカニズムが存在しないので、別の関連する要件は、認証フレームワークは、認証メカニズムの柔軟な統合を可能にしなければならないということです。他の人がパスワードを使用しながら、例えば、いくつかのIdPは、ハードウェア・トークンを必要とします。サービスプロバイダは、まだ見ていないのIdPから他のメソッドのための認証方法とも両方のサポートを提供したいと考えています。"
    },
    {
      "indent": 3,
      "text": "These requirements can be met by utilizing standardized and successfully deployed technology, namely the EAP framework [RFC3748]. Figure 3 illustrates the integration graphically.",
      "ja": "これらの要件は、標準化と正常に展開技術、すなわち、EAPフレームワーク[RFC3748]を利用することによって満たすことができます。図3は、グラフの統合を示します。"
    },
    {
      "indent": 3,
      "text": "EAP is an end-to-end framework; it provides for two-way communication between a peer (i.e., client or Individual) through the EAP authenticator (i.e., RP) to the back end (i.e., IdP). This is precisely -- and conveniently -- the communication path that is needed for federated identity. Although EAP support is already integrated in AAA systems (see [RFC3579] and [RFC4072]), several challenges remain:",
      "ja": "EAPは、エンドツーエンドのフレームワークです。それは、バックエンド（すなわち、IDP）にEAP認証（すなわち、RP）を介して、ピア（すなわち、クライアントまたは個人）との間の双方向通信を提供します。便利と -   - これは正確で連携アイデンティティのために必要とされる通信パス。 EAPサポートがすでにAAAシステムに統合されているが（[RFC3579]と[RFC4072]を参照）、いくつかの課題が残っています："
    },
    {
      "indent": 3,
      "text": "o The first is how to carry EAP payloads from the end host to the RP.",
      "ja": "最初のoをRPにエンドホストからのEAPペイロードを運ぶ方法です。"
    },
    {
      "indent": 3,
      "text": "o Another is to verify statements the RP has made to the client, confirm that these statements are consistent with statements made to the IdP, and confirm that all of the above are consistent with the federation and any federation-specific policy or configuration.",
      "ja": "Oもう一つは、RPがクライアントに作られたステートメントを確認するこれらの記述は、IdPのに発言と一致していることを確認し、上記のすべてのフェデレーションと任意のフェデレーション固有のポリシーや設定と一致していることを確認することです。"
    },
    {
      "indent": 3,
      "text": "o Another challenge is choosing which IdP to use for which service.",
      "ja": "Oもう一つの課題は、IDPがどのサービスに使用する選択されています。"
    },
    {
      "indent": 3,
      "text": "The EAP method used for ABFAB needs to meet the following requirements:",
      "ja": "ABFABに使用するEAPメソッドは、次の要件を満たす必要があります："
    },
    {
      "indent": 3,
      "text": "o It needs to provide mutual authentication of the client and IdP.",
      "ja": "Oこれは、クライアントとのIdPの相互認証を提供する必要があります。"
    },
    {
      "indent": 3,
      "text": "o It needs to support channel binding.",
      "ja": "Oそれは結合チャネルをサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "As of this writing, the only EAP method that meets these criteria is TEAP [RFC7170], either alone (if client certificates are used) or with an inner EAP method that does mutual authentication.",
      "ja": "これを書いているように、これらの基準を満たす唯一のEAPメソッドは、（クライアント証明書が使用される場合）、または相互認証を行い内部EAPメソッドを用いて単独で、TEAP [RFC7170]です。"
    },
    {
      "indent": 0,
      "text": "2.2.2. EAP Channel Binding",
      "section_title": true,
      "ja": "2.2.2。バインディングEAPチャンネル"
    },
    {
      "indent": 3,
      "text": "EAP channel binding is easily confused with a facility in GSS-API that is also called \"channel binding\". GSS-API channel binding provides protection against man-in-the-middle attacks when GSS-API is used for authentication inside of some tunnel; it is similar to a facility called \"cryptographic binding\" in EAP. See [RFC5056] for a discussion of the differences between these two facilities.",
      "ja": "結合EAPチャネルはまた、「チャネル結合」と呼ばれているGSS-APIの機能と簡単に混乱しています。 GSS-APIは、いくつかのトンネルの内部で認証に使用されたときに結合GSS-APIのチャンネルは、man-in-the-middle攻撃に対する保護を提供します。それは、EAPに「暗号の結合」と呼ばれる施設に似ています。これら2つの機能の相違点については、[RFC5056]を参照してください。"
    },
    {
      "indent": 3,
      "text": "The client knows, in theory, the name of the RP that it attempted to connect to; however, in the event that an attacker has intercepted the protocol, the client and the IdP need to be able to detect this situation. A general overview of the problem, along with a recommended way to deal with the channel-binding issues, can be found in [RFC6677].",
      "ja": "クライアントは、理論的には、それが接続しようとしたRPの名前を知っています。しかし、攻撃者がプロトコルを傍受している場合には、クライアントとIdPがこの状況を検出できるようにする必要があります。問題の一般的な概要は、チャネル結合の問題に対処するために推奨される方法とともに、[RFC6677]で見つけることができます。"
    },
    {
      "indent": 3,
      "text": "Since the time that [RFC6677] was published, a number of possible attacks were found. Methods to address these attacks have been outlined in [RFC7029].",
      "ja": "[RFC6677]が発表されたその時以来、攻撃の可能性の数が見つかりました。これらの攻撃に対処するための方法は、[RFC7029]に概説されています。"
    },
    {
      "indent": 0,
      "text": "2.3. Client to Relying Party",
      "section_title": true,
      "ja": "2.3。依拠当事者へのクライアント"
    },
    {
      "indent": 3,
      "text": "The final set of interactions between the parties to consider are those between the client and the RP. In some ways, this is the most complex set, since at least part of it is outside the scope of the ABFAB work. The interactions between these parties include:",
      "ja": "考慮すべき当事者間の相互作用の最終セットは、クライアントとRPの間のものです。それの少なくとも一部がABFABの仕事の範囲外であるため、いくつかの点では、これは、最も複雑なセットです。これらの当事者間の相互作用は、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o Running the protocol that implements the service that is provided by the RP and desired by the client.",
      "ja": "RPによって提供され、クライアントが希望されるサービスを実装したプロトコルを実行しているO。"
    },
    {
      "indent": 3,
      "text": "o Authenticating the client to the RP and the RP to the client.",
      "ja": "RPおよびクライアントへのRPにクライアントを認証O。"
    },
    {
      "indent": 3,
      "text": "o Providing the necessary security services to the service protocol that it needs, beyond authentication.",
      "ja": "認証を超えて、それが必要とするサービスプロトコルに必要なセキュリティサービスを提供し、O。"
    },
    {
      "indent": 3,
      "text": "o Dealing with client re-authentication where desired.",
      "ja": "目的のクライアントの再認証への対応、O。"
    },
    {
      "indent": 0,
      "text": "2.3.1. GSS-API",
      "section_title": true,
      "ja": "2.3.1。 GSS-API"
    },
    {
      "indent": 3,
      "text": "One of the remaining layers is responsible for integration of federated authentication with the application. Applications have adopted a number of approaches for providing security, so multiple strategies for integration of federated authentication with applications may be needed. To this end, we start with a strategy that provides integration with a large number of application protocols.",
      "ja": "残りの層の一つは、アプリケーションとの連携認証の統合のための責任があります。アプリケーションは、セキュリティを提供するための多数のアプローチを採用しているので、アプリケーションとの連携認証を統合するための複数の戦略が必要になることがあります。この目的のために、我々はアプリケーションプロトコルの数が多いとの統合を提供して戦略を開始します。"
    },
    {
      "indent": 3,
      "text": "Many applications, such as Secure Shell (SSH) [RFC4462], NFS [RFC7530], DNS [RFC3645], and several non-IETF applications, support GSS-API [RFC2743]. Many applications, such as IMAP, SMTP, the Extensible Messaging and Presence Protocol (XMPP), and the Lightweight Directory Access Protocol (LDAP), support the Simple Authentication and Security Layer (SASL) [RFC4422] framework. These two approaches work together nicely: by creating a GSS-API mechanism, SASL integration is also addressed. In effect, using a GSS-API mechanism with SASL simply requires placing some headers before the mechanism's messages and constraining certain GSS-API options.",
      "ja": "そのようなセキュアシェル（SSH）[RFC4462]、NFS [RFC7530]、DNS [RFC3645]、およびいくつかの非IETFアプリケーション、GSS-APIをサポート[RFC2743]などの多くの用途。このようIMAP、SMTP、拡張メッセージングおよびプレゼンスプロトコル（XMPP）、およびLDAP（Lightweight Directory Access Protocol）のような多くのアプリケーションでは、簡易認証セキュリティー層（SASL）[RFC4422]のフレームワークをサポートしています。これらの2つのアプローチがうまく一緒に仕事：GSS-APIメカニズムを作成することによって、SASLの統合も対処されます。実際には、SASLとGSS-APIメカニズムを使用すると、単にメカニズムのメッセージの前にいくつかのヘッダを配置し、特定のGSS-APIのオプションを制約が必要です。"
    },
    {
      "indent": 3,
      "text": "GSS-API is specified in terms of an abstract set of operations that can be mapped into a programming language to form an API. When people are first introduced to GSS-API, they focus on it as an API. However, from the perspective of authentication for non-web applications, GSS-API should be thought of as a protocol as well as an API. When looked at as a protocol, it consists of abstract operations such as the initial context exchange, which includes two sub-operations (GSS_Init_sec_context and GSS_Accept_sec_context) [RFC2743]. An application defines which abstract operations it is going to use and where messages produced by these operations fit into the application architecture. A GSS-API mechanism will define what actual protocol messages result from that abstract message for a given abstract operation. So, since this work is focusing on a particular GSS-API mechanism, we generally focus on protocol elements rather than the API view of GSS-API.",
      "ja": "GSS-APIは、APIを形成するために、プログラミング言語にマッピングすることができる操作の抽象セットに関して指定されています。人々は最初のGSS-APIに導入されたとき、彼らはAPIとしてそれに焦点を当てます。しかし、非Webアプリケーションの認証の観点から、GSS-APIは、プロトコルだけでなく、APIとして考えるべきです。プロトコルとして見た場合、このような二つのサブ操作（もしGSS_Init_sec_context及び場合gss_accept_sec_context）を含む初期コンテキスト交換、[RFC2743]として抽象的操作から成ります。アプリケーションは、使用しようとどここれらの操作によって生成されるメッセージは、アプリケーションアーキテクチャに適合され、抽象どの操作を定義します。 GSS-API機構は、実際のプロトコルメッセージは、所与の抽象操作のために、その抽象メッセージから生じるものを定義します。だから、この作品は、特定のGSS-APIメカニズムに焦点を当てているため、我々は一般的にプロトコル要素ではなく、GSS-APIのAPIの観点に焦点を当てます。"
    },
    {
      "indent": 3,
      "text": "The API view of GSS-API does have significant value as well; since the abstract operations are well defined, the information that a mechanism gets from the application is well defined. Also, the set of assumptions the application is permitted to make is generally well defined. As a result, an application protocol that supports GSS-API or SASL is very likely to be usable with a new approach to authentication, including the authentication mechanism defined in this document, with no required modifications. In some cases, support for a new authentication mechanism has been added using plugin interfaces to applications without the application being modified at all. Even when modifications are required, they can often be limited to supporting a new naming and authorization model. For example, this work focuses on privacy; an application that assumes that it will always obtain an identifier for the client will need to be modified to support anonymity, unlinkability, or pseudonymity.",
      "ja": "GSS-APIのAPIビューは、同様に重要な価値を持っています。抽象操作が明確に定義されているので、機構は、アプリケーションから取得した情報は明確に定義されています。また、アプリケーションを作ることが許可された仮定のセットは、一般的によく定義されます。その結果、GSS-APIをサポートするか、SASLなし必要な変更と共に本文書で定義された認証機構を含む認証するための新しいアプローチに使用できる可能性が非常に高いアプリケーションプロトコルとして。いくつかのケースでは、新たな認証メカニズムのサポートは、アプリケーションが全く変更されずにアプリケーションにプラグイン・インターフェースを使用して追加されています。修正が必要な場合でも、彼らはしばしば、新しいネーミングおよび認証モデルをサポートに制限することができます。たとえば、この作品は、プライバシーに焦点を当てて。それは常にクライアントの識別子を取得することを前提としていたアプリケーションは、匿名性、リンク不能、または偽名をサポートするように変更する必要があります。"
    },
    {
      "indent": 3,
      "text": "So, we use GSS-API and SASL because a number of the application protocols we wish to federate support these strategies for security integration. What does this mean from a protocol standpoint, and how does this relate to other layers? This means that we need to design a concrete GSS-API mechanism. We have chosen to use a GSS-API mechanism that encapsulates EAP authentication. So, GSS-API (and SASL) encapsulates EAP between the end host and the service. The AAA framework encapsulates EAP between the RP and the IdP. The GSS-API mechanism includes rules about how initiators and services are named as well as per-message security and other facilities required by the applications we wish to support.",
      "ja": "アプリケーションプロトコルの数は、我々は、セキュリティの統合のためにこれらの戦略を支える連携したいので、そこで、我々は、GSS-APIおよびSASLを使用しています。何をこれは、プロトコルの観点から意味し、そしてどのようにこれは、他の層に関連していますか？これは、我々は具体的なGSS-APIメカニズムを設計する必要があることを意味します。私たちは、EAP認証をカプセル化するGSS-APIメカニズムを使用することを選択しました。だから、GSS-API（およびSASL）は、エンドホストとサービスの間でEAPをカプセル化します。 AAAフレームワークは、RPとIdPの間でEAPをカプセル化します。 GSS-APIメカニズムは、イニシエータやサービスの名前の付け方のルールだけでなく、メッセージごとのセキュリティと私たちがサポートしたいアプリケーションが必要とする他の機能が含まれています。"
    },
    {
      "indent": 0,
      "text": "2.3.2. Protocol Transport",
      "section_title": true,
      "ja": "2.3.2。プロトコルトランスポート"
    },
    {
      "indent": 3,
      "text": "The transport of data between the client and the RP is not provided by GSS-API. GSS-API creates and consumes messages, but it does not provide the transport itself; instead, the protocol using GSS-API needs to provide the transport. In many cases, HTTP or HTTPS is used for this transport, but other transports are perfectly acceptable. The core GSS-API document [RFC2743] provides some details on what requirements exist.",
      "ja": "クライアントとRP間のデータの輸送はGSS-APIによって提供されていません。 GSS-APIは、作成したメッセージを消費しますが、それは輸送自体を提供していません。代わりに、GSS-APIを使用してプロトコルは、トランスポートを提供する必要があります。多くの場合、HTTPまたはHTTPSは、この輸送に使用されますが、他のトランスポートは、完全に許容されています。コアGSS-APIドキュメント[RFC2743]は要件が存在するものにいくつかの詳細を提供します。"
    },
    {
      "indent": 3,
      "text": "In addition, we highlight the following:",
      "ja": "加えて、我々は次のように強調表示します："
    },
    {
      "indent": 3,
      "text": "o The transport does not need to provide either confidentiality or integrity. After GSS-EAP has finished negotiation, GSS-API can be used to provide both services. If the negotiation process itself needs protection from eavesdroppers, then the transport would need to provide the necessary services.",
      "ja": "Oの輸送は、機密性や完全性のいずれかを提供する必要はありません。 GSS-EAPは交渉を終えた後は、GSS-APIは、両方のサービスを提供するために使用することができます。交渉プロセス自体は盗聴者からの保護を必要とする場合には、輸送は必要なサービスを提供する必要があります。"
    },
    {
      "indent": 3,
      "text": "o The transport needs to provide reliable transport of the messages.",
      "ja": "Oトランスポートは、メッセージの信頼性の高いトランスポートを提供する必要があります。"
    },
    {
      "indent": 3,
      "text": "o The transport needs to ensure that tokens are delivered in order during the negotiation process.",
      "ja": "Oトランスポートは、トークンが交渉プロセスの間に順に配信されていることを確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "o GSS-API messages need to be delivered atomically. If the transport breaks up a message, it must also reassemble the message before delivery.",
      "ja": "O GSS-APIメッセージがアトミックに配信する必要があります。トランスポートがメッセージを分割した場合、それはまた、配信前にメッセージを再構築しなければなりません。"
    },
    {
      "indent": 0,
      "text": "2.3.3. Re-authentication",
      "section_title": true,
      "ja": "2.3.3。再認証"
    },
    {
      "indent": 3,
      "text": "There are circumstances where the RP will want to have the client re-authenticate itself. These include very long sessions, where the original authentication is time limited or cases where in order to complete an operation a different authentication is required. GSS-EAP does not have any mechanism for the server to initiate a re-authentication, as all authentication operations start from the client. If a protocol using GSS-EAP needs to support re-authentication that is initiated by the server, then a request from the server to the client for the re-authentication to start needs to be placed in the protocol.",
      "ja": "RPは、クライアントの再認証自体を持っていることになるでしょう事情があります。これらは、元の認証がどこ異なる認証が必要な操作を完了するために、時間制限されたかのケースで非常に長いセッションが含まれます。すべての認証操作はクライアントからのスタートとしてGSS-EAPは、再認証を開始するサーバーのいずれかのメカニズムを持っていません。 GSS-EAPを使用したプロトコルは、サーバによって開始された再認証をサポートする必要がある場合は、再認証のために、サーバーからクライアントへの要求は、プロトコルに配置する必要を開始します。"
    },
    {
      "indent": 3,
      "text": "Clients can reuse the existing secure connection established by GSS-API, and run the new authentication in that connection, by calling GSS_Init_sec_context. At this point, a full re-authentication will be done.",
      "ja": "クライアントは、GSS-APIによって確立された既存の安全な接続を再利用し、もしGSS_Init_sec_contextを呼び出すことによって、その接続で新しい認証を実行することができます。この時点で、完全な再認証が行われます。"
    },
    {
      "indent": 0,
      "text": "3. Application Security Services",
      "section_title": true,
      "ja": "3.アプリケーションセキュリティサービス"
    },
    {
      "indent": 3,
      "text": "One of the key goals is to integrate federated authentication with existing application protocols and, where possible, existing implementations of these protocols. Another goal is to perform this integration while meeting the best security practices of the technologies used to perform the integration. This section describes security services and properties required by the EAP GSS-API mechanism in order to meet these goals. This information could be viewed as specific to that mechanism. However, other future application integration strategies are very likely to need similar services. So, it is likely that these services will be expanded across application integration strategies if new application integration strategies are adopted.",
      "ja": "主要な目標の一つは、既存のアプリケーションプロトコルと、これらのプロトコルの可能性、既存の実装とのフェデレーション認証を統合することです。もう一つの目標は、統合を実行するために使用される技術のセキュリティのベストプラクティスを満たしながら、この統合を実行することです。このセクションでは、これらの目標を達成するために、EAP GSS-APIメカニズムで必要とされるセキュリティサービスとプロパティについて説明します。この情報は、そのメカニズムに固有と見なすことができます。しかし、他の将来のアプリケーション統合戦略は、同様のサービスを必要とする可能性が非常に高いです。だから、新しいアプリケーションの統合戦略が採用されている場合、これらのサービスは、アプリケーション統合戦略全体に拡大される可能性があります。"
    },
    {
      "indent": 0,
      "text": "3.1. Authentication",
      "section_title": true,
      "ja": "3.1。認証"
    },
    {
      "indent": 3,
      "text": "GSS-API provides an optional security service called \"mutual authentication\". This service means that in addition to the initiator providing (potentially anonymous or pseudonymous) identity to the acceptor, the acceptor confirms its identity to the initiator. In the context of ABFAB in particular, the naming of this service is confusing. We still say that mutual authentication is provided when the identity of an acceptor is strongly authenticated to an anonymous initiator.",
      "ja": "GSS-APIは、「相互認証」と呼ばれるオプションのセキュリティサービスを提供しています。このサービスは、アクセプターへの（潜在的に匿名または変名）のアイデンティティを提供するイニシエータに加えて、アクセプターはイニシエータにその身元を確認したことを意味します。特にABFABの文脈では、このサービスの命名は紛らわしいです。我々はまだアクセプターのアイデンティティが強く匿名イニシエータに認証されたときに、相互認証が提供されていることを言います。"
    },
    {
      "indent": 3,
      "text": "Unfortunately, [RFC2743] does not explicitly talk about what mutual authentication means. Within this document, we therefore define mutual authentication as follows:",
      "ja": "残念ながら、[RFC2743]は、明示的に相互認証が何を意味するのかについて話しません。次のように、この文書の中で、我々はそのための相互認証を定義します。"
    },
    {
      "indent": 3,
      "text": "o If a target name is configured for the initiator, then the initiator trusts that the supplied target name describes the acceptor. This implies that (1) appropriate cryptographic exchanges took place for the initiator to make such a trust decision and (2) after evaluating the results of these exchanges, the initiator's policy trusts that the target name is accurate.",
      "ja": "ターゲット名をイニシエータに設定されている場合、O、その後、イニシエータは、供給されたターゲット名は、アクセプターを記述していることを信頼します。これは、（1）適切な暗号交換がターゲット名が正確であること、これらの交換の結果を評価した後、このような信頼の決定及び（2）を作るためにイニシエータのイニシエータの政策信託を行われたことを意味します。"
    },
    {
      "indent": 3,
      "text": "o If no target name is configured for the initiator, then the initiator trusts that the acceptor name, supplied by the acceptor, correctly names the entity it is communicating with.",
      "ja": "正しくアクセプターによって供給されたアクセプター名、次にイニシエータ信託、名前、それが通信しているエンティティ、いかなるターゲット名をイニシエータ用に構成されていない場合、O。"
    },
    {
      "indent": 3,
      "text": "o Both the initiator and acceptor have the same key material for per-message keys, and both parties have confirmed that they actually have the key material. In EAP terms, there is a protected indication of success.",
      "ja": "Oイニシエータとアクセプタの両方が、メッセージごとのキーに同じ鍵材料を持っており、両当事者は、彼らが実際にキーマテリアルを持っていることを確認しました。 EAPの用語では、成功の保護された兆候があります。"
    },
    {
      "indent": 3,
      "text": "Mutual authentication is an important defense against certain aspects of phishing. Intuitively, clients would like to assume that if some party asks for their credentials as part of authentication, successfully gaining access to the resource means that they are talking to the expected party. Without mutual authentication, the server could \"grant access\" regardless of what credentials are supplied. Mutual authentication better matches this user intuition.",
      "ja": "相互認証はフィッシングの特定の側面に対する重要な防御です。直感的に、クライアントはいくつかの当事者が認証の一環として、資格情報を要求する場合のことを想定したい、成功したリソースへのアクセスを獲得することは、彼らが期待されるパーティーに話していることを意味します。相互認証がなければ、サーバーは関係なく、資格情報が供給されているものの「アクセスを許可する」ことができます。相互認証は、より良い、このユーザーの直感に合致しました。"
    },
    {
      "indent": 3,
      "text": "It is important, therefore, that the GSS-EAP mechanism implement mutual authentication. That is, an initiator needs to be able to request mutual authentication. When mutual authentication is requested, only EAP methods capable of providing the necessary service can be used, and appropriate steps need to be taken to provide mutual authentication. While a broader set of EAP methods could be supported by not requiring mutual authentication, it was decided that the client needs to always have the ability to request it. In some cases, the IdP and the RP will not support mutual authentication; however, the client will always be able to detect this and make an appropriate security decision.",
      "ja": "これは、GSS-EAPメカニズムが相互認証を実装することが重要です。それは、イニシエータが相互認証を要求できるようにする必要があり、です。相互認証が要求されると、必要なサービスを提供できるだけEAPメソッドを使用することができ、適切なステップは、相互認証を提供するために取られる必要があります。 EAPメソッドのより広範なセットが相互認証を必要としないことにより、サポートすることができますが、それは、クライアントが常にそれを要求する能力を持っている必要があることを決定しました。いくつかのケースでは、IdPのとRPは、相互認証をサポートしていません。ただし、クライアントは常にこれを検出し、適切なセキュリティ決定を行うことができるようになります。"
    },
    {
      "indent": 3,
      "text": "The AAA infrastructure may hide the initiator's identity from the GSS-API acceptor, providing anonymity between the initiator and the acceptor. At this time, whether the identity is disclosed is determined by EAP server policy rather than by an indication from the initiator. Also, initiators are unlikely to be able to determine whether anonymous communication will be provided. For this reason, initiators are unlikely to set the anonymous return flag from GSS_Init_sec_context (Section 2.2.1 of [RFC2743]).",
      "ja": "AAAインフラストラクチャは、イニシエータとアクセプターの間の匿名性を提供し、GSS-APIアクセプターからイニシエータの身元を隠すことがあります。このとき、識別が開示されているか否かEAPサーバポリシーではなく、イニシエータからの指示により決定されます。また、開始剤は、匿名の通信が提供されるかどうかを決定することができることはほとんどありません。このため、開始剤は、もしGSS_Init_sec_context（[RFC2743]のセクション2.2.1）からの匿名の復帰フラグを設定することはほとんどありません。"
    },
    {
      "indent": 0,
      "text": "3.2. GSS-API Channel Binding",
      "section_title": true,
      "ja": "3.2。バインディングGSS-APIチャンネル"
    },
    {
      "indent": 3,
      "text": "[RFC5056] defines a concept of channel binding that is used to prevent man-in-the-middle attacks. This type of channel binding works by taking a cryptographic value from the transport security layer and checks to see that both sides of the GSS-API conversation know this value. Transport Layer Security (TLS) [RFC5246] is the most common transport security layer used for this purpose.",
      "ja": "[RFC5056]はそれがman-in-the-middle攻撃を防止するために使用されている結合チャネルの概念を定義します。 GSS-APIの会話の両側には、この値を知っていることを確認するために、トランスポートセキュリティ層とチェックから暗号値をとることにより、チャネル結合の作品のこのタイプ。トランスポート層セキュリティ（TLS）[RFC5246]は、この目的のために使用される最も一般的なトランスポート・セキュリティ層です。"
    },
    {
      "indent": 3,
      "text": "It needs to be stressed that channel binding as described in [RFC5056] (also called \"GSS-API channel binding\" when GSS-API is involved) is not the same thing as EAP channel binding. GSS-API channel binding is used for detecting man-in-the-middle attacks. EAP channel binding is used for mutual authentication and acceptor naming checks. See [RFC7055] for details. A more detailed description of the differences between the facilities can be found in [RFC5056].",
      "ja": "これは、[RFC5056]に記載の結合EAPチャネルと同じものではありません（また、GSS-APIが含まれているとき、「結合GSS-APIチャンネル」と呼ばれる）として、チャネルが結合することを強調する必要があります。結合GSS-APIチャネルはman-in-the-middle攻撃を検出するために使用されます。 EAPチャネル結合は、相互認証とアクセプタ命名チェックに使用されます。詳細については、[RFC7055]を参照してください。施設間の差のより詳細な説明は、[RFC5056]に見出すことができます。"
    },
    {
      "indent": 3,
      "text": "The use of TLS can provide both encryption and integrity on the channel. It is common to provide SASL and GSS-API with these other security services.",
      "ja": "TLSの使用は、チャネル上の暗号化と整合性の両方を提供することができます。これらの他のセキュリティサービスでSASLとGSS-APIを提供するのが一般的です。"
    },
    {
      "indent": 3,
      "text": "One of the benefits that the use of TLS provides is that a client has the ability to validate the name of the server. However, this validation is predicated on a couple of things. The TLS session needs to be using certificates and not be an anonymous session. The client and the TLS server need to share a common trust point for the certificate used in validating the server. TLS provides its own server authentication. However, there are a variety of situations where, for policy or usability reasons, this authentication is not checked. When the TLS authentication is checked, if the trust infrastructure behind the TLS authentication is different from the trust infrastructure behind the GSS-API mutual authentication, then confirming the endpoints using both trust infrastructures is likely to enhance security. If the endpoints of the GSS-API authentication are different than the endpoints of the lower layer, this is a strong indication of a problem, such as a man-in-the-middle attack. Channel binding provides a facility to determine whether these endpoints are the same.",
      "ja": "TLSの使用が提供する利点の一つは、クライアントがサーバーの名前を検証する能力を有することです。しかし、この検証は、物事のカップルを前提としています。 TLSセッションは、証明書を使用して、匿名のセッションではないことが必要です。クライアントおよびTLSサーバーでは、サーバーの検証に使用する証明書の共通トラスト・ポイントを共有する必要があります。 TLSは、独自のサーバー認証を提供します。しかし、政策や使い勝手の理由から、この認証がチェックされていない、さまざまな状況があります。 TLS認証がチェックされている場合はTLS認証の背後に信頼インフラストラクチャはGSS-APIの相互認証の背後に信頼基盤と異なる場合、両方の信頼インフラストラクチャを使用してエンドポイントを確認すると、セキュリティを強化する可能性があります。 GSS-API認証のエンドポイントは、下位層のエンドポイントと異なる場合は、これは、man-in-the-middle攻撃として、問題の強力な指標です。チャネル結合は、これらのエンドポイントが同じであるかどうかを判断するための機能を提供します。"
    },
    {
      "indent": 3,
      "text": "The GSS-EAP mechanism needs to support channel binding. When an application provides channel-binding data, the mechanism needs to confirm that this is the same on both sides, consistent with the GSS-API specification.",
      "ja": "GSS-EAPメカニズムがチャネルバインディングをサポートする必要があります。アプリケーションがチャネル結合データを提供する場合、機構は、これはGSS-API仕様と一致し、両側で同じであることを確認する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.3. Host-Based Service Names",
      "section_title": true,
      "ja": "3.3。ホストベースのサービス名を"
    },
    {
      "indent": 3,
      "text": "IETF security mechanisms typically take a host name and perhaps a service, entered by a user, and make some trust decision about whether the remote party in the interaction is the intended party. This decision can be made via the use of certificates, preconfigured key information, or a previous leap of trust. GSS-API has defined a relatively flexible naming convention; however, most of the IETF applications that use GSS-API (including SSH, NFS, IMAP, LDAP, and XMPP) have chosen to use a more restricted naming convention based on the host name. The GSS-EAP mechanism needs to support host-based service names in order to work with existing IETF protocols.",
      "ja": "IETFのセキュリティメカニズムは、典型的には、ユーザが入力したホスト名とおそらくサービスを、取る、との相互作用で相手が通話相手であるかどうかについて、いくつかの信頼の決定を行います。この決定は、証明書、事前設定されたキー情報、または信頼の以前の飛躍の使用を介して行うことができます。 GSS-APIは、比較的柔軟な命名規則を定義しています。しかし、（SSH、NFS、IMAP、LDAP、およびXMPPを含む）GSS-APIを使用するIETFアプリケーションのほとんどは、ホスト名に基づいて、より制限された命名規則を使用することを選択しました。 GSS-EAPメカニズムは、既存のIETFプロトコルを使用するために、ホストベースのサービス名をサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "The use of host-based service names leads to a challenging trust delegation problem. Who is allowed to decide whether a particular host name maps to a specific entity? Possible solutions to this problem have been looked at.",
      "ja": "ホストベースのサービス名を使用することは、挑戦的な信頼の委任の問題につながります。誰が特定のホスト名が特定のエンティティにマップするかどうかを決定することが許可されていますか？この問題の解決策が見てきました。"
    },
    {
      "indent": 3,
      "text": "o The Public Key Infrastructure (PKI) used by the web has chosen to have a number of trust anchors (root certificate authorities), each of which can map any host name to a public key.",
      "ja": "Oウェブで使用する公開鍵インフラストラクチャ（PKI）は、公開鍵に任意のホスト名をマッピングすることができますそれぞれのトラストアンカー（ルート証明機関）の数を持っていることを選択しました。"
    },
    {
      "indent": 3,
      "text": "o A number of GSS-API mechanisms, such as Kerberos [RFC1964], have split the problem into two parts. [RFC1964] introduced a new concept called a realm; the realm is responsible for host mapping within itself. The mechanism then decides what realm is responsible for a given name. This is the approach adopted by ABFAB.",
      "ja": "Oのようなケルベロス[RFC1964]などのGSS-API機構の数は、二つの部分に問題を分割しています。 [RFC1964]は、レルムと呼ばれる新しい概念を導入しました。レルムは、自身の中のホストマッピングを担当しています。メカニズムは、レルムが与えられた名前の責任が何であるかを決定します。これはABFABによって採用されたアプローチです。"
    },
    {
      "indent": 3,
      "text": "GSS-EAP defines a host naming convention that takes into account the host name, the realm, the service, and the service parameters. An example of a GSS-API service name is \"xmpp/foo@example.com\". This identifies the XMPP service on the host foo in the realm example.com. Any of the components, except for the service name, may be omitted from a name. When omitted, a local default would be used for that component of the name.",
      "ja": "GSS-EAPを考慮にホスト名を受け取り、ホスト命名規則、分野、サービス、およびサービスパラメータを定義します。 GSS-APIサービス名の例は、「xmpp/foo@example.com」です。これは、レルムexample.comでホストFOO上のXMPPサービスを識別します。コンポーネントのいずれかは、サービス名を除いて、名前から省略されてもよいです。省略した場合、ローカルのデフォルトは、名前のそのコンポーネントのために使用されます。"
    },
    {
      "indent": 3,
      "text": "While there is no requirement that realm names map to Fully Qualified Domain Names (FQDNs) within DNS, in practice this is normally true. Doing so allows the realm portion of service names and the portion of NAIs to be the same. It also allows for the use of DNS in locating the host of a service while establishing the transport channel between the client and the RP.",
      "ja": "レルム名は、DNS内の完全修飾ドメイン名（FQDN）をマップは要求されないが、実際には、これは通常、本当です。そうすることで、サービス名のレルム部分とのNAIの部分は同じにすることができます。また、クライアントとRP間のトランスポート・チャネルを確立しながら、サービスのホストを見つけるにおけるDNSの使用が可能になります。"
    },
    {
      "indent": 3,
      "text": "It is the responsibility of the application to determine the server that it is going to communicate with; GSS-API has the ability to help confirm that the server is the desired server but not to determine the name of the server to use. It is also the responsibility of the application to determine how much of the information identifying the service needs to be validated by the ABFAB system. The information that needs to be validated is used to construct the service name passed into the GSS-EAP mechanism. What information is to be validated will depend on (1) what information was provided by the client and (2) what information is considered significant. If the client only cares about getting a specific service, then it does not need to validate the host and realm that provides the service.",
      "ja": "と通信しようとしているサーバーを決定するために、アプリケーションの責任です。 GSS-APIは、サーバーが目的のサーバーであるが、使用するサーバーの名前を決定していないことを確認するのに役立つ能力を持っています。 ABFABシステムによって検証する必要がありますどのくらいのサービスを識別する情報を決定するためにも、アプリケーションの責任です。検証する必要のある情報は、GSS-EAPメカニズムに渡されるサービス名を構築するために使用されます。どのような情報が検証される（1）クライアントから提供されたものの情報に依存し、（2）重要と考えられるものの情報。クライアントは、特定のサービスを得ることについて気にした場合、それはサービスを提供するホストおよびレルムを検証する必要はありません。"
    },
    {
      "indent": 3,
      "text": "Applications may retrieve information about providers of services from DNS. Service Records (SRVs) [RFC2782] and Naming Authority Pointer (NAPTR) [RFC3401] records are used to help find a host that provides a service; however, the necessity of having DNSSEC on the queries depends on how the information is going to be used. If the host name returned is not going to be validated by EAP channel binding because only the service is being validated, then DNSSEC [RFC4033] is not required. However, if the host name is going to be validated by EAP channel binding, then DNSSEC needs to be used to ensure that the correct host name is validated. In general, if the information that is returned from the DNS query is to be validated, then it needs to be obtained in a secure manner.",
      "ja": "アプリケーションは、DNSからのサービスの提供についての情報を検索することができます。サービスレコード（のSRV）[RFC2782]と権限ポインタ（NAPTR）の命名[RFC3401]のレコードは、サービスを提供するホストを見つけるために使用されています。ただし、クエリにDNSSECを持つことの必要性は、情報が使用されようとしている方法によって異なります。返されるホスト名は、バインディングEAPチャネルによって検証する予定がない場合にのみ、サービスが検証されているため、その後、DNSSEC [RFC4033]は必要ありません。ホスト名は、EAPチャネル結合によって検証されようとしている場合は、その後、DNSSECは、正しいホスト名が検証されることを保証するために使用する必要があります。 DNSクエリから返された情報が検証される場合、一般的には、それは安全な方法で取得する必要があります。"
    },
    {
      "indent": 3,
      "text": "Another issue that needs to be addressed for host-based service names is that they do not work ideally when different instances of a service are running on different ports. If the services are equivalent, then it does not matter. However, if there are substantial differences in the quality of the service, that information needs to be part of the validation process. If one has just a host name and not a port in the information being validated, then this is not going to be a successful strategy.",
      "ja": "ホストベースのサービス名のために対処する必要があるもう一つの問題は、サービスの異なるインスタンスが異なるポート上で実行されている場合、彼らは理想的に動作しないということです。サービスが同等であれば、それは問題ではありません。サービスの品質の実質的な違いがある場合は、その情報が検証プロセスの一部である必要があります。 1は、単にホスト名および検証されている情報ではないポートがある場合、これは成功した戦略であることを行っていません。"
    },
    {
      "indent": 0,
      "text": "3.4. Additional GSS-API Services",
      "section_title": true,
      "ja": "3.4。追加のGSS-APIサービス"
    },
    {
      "indent": 3,
      "text": "GSS-API provides per-message security services that can provide confidentiality and/or integrity. Some IETF protocols, such as NFS and SSH, take advantage of these services. As a result, GSS-EAP needs to support these services. As with mutual authentication, per-message security services will limit the set of EAP methods that can be used to those that generate a Master Session Key (MSK). Any EAP method that produces an MSK is able to support per-message security services as described in [RFC2743].",
      "ja": "GSS-APIは、機密性および/または完全性を提供することができ、メッセージごとのセキュリティサービスを提供します。 NFSやSSHなどの一部のIETFプロトコルは、これらのサービスを利用します。その結果、GSS-EAPは、これらのサービスをサポートする必要があります。相互認証と同様に、メッセージごとのセキュリティサービスは、マスターセッションキー（MSK）を生成するものに使用することができEAPメソッドのセットを制限します。 MSKを生成する任意のEAPメソッドは、[RFC2743]に記載されているように、メッセージごとのセキュリティ・サービスをサポートすることができます。"
    },
    {
      "indent": 3,
      "text": "GSS-API provides a pseudorandom function. This function generates a pseudorandom sequence using the shared session key as the seed for the bytes generated. This provides an algorithm that both the initiator and acceptor can run in order to arrive at the same key value. The use of this feature allows an application to generate keys or other shared secrets for use in other places in the protocol.",
      "ja": "GSS-APIは、擬似ランダム機能を提供します。この関数は、生成されたバイトのシードとして共有セッション鍵を使用して擬似ランダムシーケンスを生成します。これは、イニシエータとアクセプタの両方が同じキー値に到達するために実行可能なアルゴリズムを提供します。この機能を使用すると、アプリケーションがプロトコルの他の場所で使用するためのキーまたは他の共有秘密を生成することができます。"
    },
    {
      "indent": 3,
      "text": "In this regard, it is similar in concept to the mechanism (formerly known as \"TLS Extractors\") described in [RFC5705]. While no current IETF protocols require this feature, non-IETF protocols are expected to take advantage of it in the near future. Additionally, a number of protocols have found the mechanism described in [RFC5705] to be useful in this regard, so it is highly probable that IETF protocols may also start using this feature.",
      "ja": "この点で、それは、[RFC5705]に記載の（以前は「TLS抽出機能」として知られている）機構の概念に類似しています。何の現在のIETFプロトコルがこの機能を必要としませんが、非IETFプロトコルは、近い将来にそれを活用することが期待されています。また、プロトコルの数は、[RFC5705]で説明されたメカニズムは、この点で有用であることが分かっているので、IETFプロトコルもこの機能を使用して開始することができる可能性が高いです。"
    },
    {
      "indent": 0,
      "text": "4. Privacy Considerations",
      "section_title": true,
      "ja": "4.個人情報保護に関する注意事項"
    },
    {
      "indent": 3,
      "text": "As an architecture designed to enable federated authentication and allow for the secure transmission of identity information between entities, ABFAB obviously requires careful consideration regarding privacy and the potential for privacy violations.",
      "ja": "フェデレーション認証を有効にし、エンティティ間のアイデンティティ情報を安全に送信できるように設計アーキテクチャとして、ABFABは明らかに、プライバシーおよびプライバシー違反の可能性について慎重に検討する必要があります。"
    },
    {
      "indent": 3,
      "text": "This section examines the privacy-related information presented in this document, summarizing the entities that are involved in ABFAB communications and what exposure they have to identity information. In discussing these privacy considerations in this section, we use terminology and ideas from [RFC6973].",
      "ja": "このセクションでは、ABFAB通信に関与し、ID情報にどのような暴露彼らが持っているエンティティをまとめたこの文書のプライバシー関連の情報を、調べます。このセクションでは、これらのプライバシーの考慮事項を議論では、我々は[RFC6973]から用語やアイデアを使用します。"
    },
    {
      "indent": 3,
      "text": "Note that the ABFAB architecture uses at its core several existing technologies and protocols; detailed privacy discussion regarding these topics is not examined. This section instead focuses on privacy considerations specifically related to the overall architecture and usage of ABFAB.",
      "ja": "ABFABアーキテクチャはその中核いくつかの既存の技術とプロトコルで使用していることに注意してください。これらのトピックに関する詳細なプライバシーの議論が検討されていません。このセクションではなく、具体的ABFABの全体的なアーキテクチャと使用に関連するプライバシーの考慮事項に焦点を当てています。"
    },
    {
      "indent": 6,
      "text": "+--------+       +---------------+       +--------------+\n| Client | <---> |      RP       | <---> | AAA Client   |\n+--------+       +---------------+       +--------------+\n                                               ^\n                                               |\n                                               v\n                 +---------------+       +----------------+\n                 | SAML Server   |       | AAA Proxy      |\n                 +---------------+       | (or Proxies)   |\n                          ^              +----------------+\n                          |                       ^\n                          |                       |\n                          v                       v\n+------------+       +---------------+       +--------------+\n| EAP Server | <---> |   IdP         | <---> | AAA Server   |\n+------------+       +---------------+       +--------------+",
      "raw": true
    },
    {
      "indent": 21,
      "text": "Figure 4: Entities and Data Flow",
      "ja": "図4：エンティティとデータフロー"
    },
    {
      "indent": 0,
      "text": "4.1. Entities and Their Roles",
      "section_title": true,
      "ja": "4.1。エンティティとその役割"
    },
    {
      "indent": 3,
      "text": "Categorizing the ABFAB entities shown in Figure 4 according to the taxonomy of terms from [RFC6973] is somewhat complicated, as the roles of each entity will change during the various phases of ABFAB communications. The three main phases of relevance are the client-to-RP communication phase, the client-to-IdP (via the Federation Substrate) communication phase, and the IdP-to-RP (via the Federation Substrate) communication phase.",
      "ja": "各エンティティの役割はABFAB通信の様々な段階で変化するように[RFC6973]から用語の分類によれば、図4に示すABFABエンティティを分類することは、多少複雑です。関連の三つの主要な相は、クライアント・ツー・RP通信フェーズ、クライアントとのIdP（連邦基板を介して）通信相、IdPの対RP通信フェーズ（連邦基板を介して）です。"
    },
    {
      "indent": 3,
      "text": "In the client-to-RP communication phase, we have:",
      "ja": "クライアントツーRP通信フェーズでは、我々は持っています："
    },
    {
      "indent": 3,
      "text": "Initiator: Client.",
      "ja": "イニシエータ：クライアント。"
    },
    {
      "indent": 3,
      "text": "Observers: Client, RP.",
      "ja": "オブザーバー：クライアント、RP。"
    },
    {
      "indent": 3,
      "text": "Recipient: RP.",
      "ja": "受信者：RP。"
    },
    {
      "indent": 3,
      "text": "In the client-to-IdP (via the Federation Substrate) communication phase, we have:",
      "ja": "クライアントからのIdP（連合基板を介し）通信フェーズでは、我々は持っています："
    },
    {
      "indent": 3,
      "text": "Initiator: Client.",
      "ja": "イニシエータ：クライアント。"
    },
    {
      "indent": 3,
      "text": "Observers: Client, RP, AAA Client, AAA Proxy (or Proxies), AAA Server, IdP.",
      "ja": "オブザーバー：クライアント、RP、AAAクライアント、AAAプロキシ（またはプロキシ）、AAAサーバ、IdPが。"
    },
    {
      "indent": 3,
      "text": "Recipient: IdP",
      "ja": "受信者：IdPが"
    },
    {
      "indent": 3,
      "text": "In the IdP-to-RP (via the Federation Substrate) communication phase, we have:",
      "ja": "IdPのツーRP通信フェーズ（連盟基板を介し）において、我々は持っています："
    },
    {
      "indent": 3,
      "text": "Initiator: RP.",
      "ja": "イニシエータ：RP。"
    },
    {
      "indent": 3,
      "text": "Observers: IdP, AAA Server, AAA Proxy (or Proxies), AAA Client, RP.",
      "ja": "オブザーバー：IdPが、AAAサーバ、AAAプロキシ（またはプロキシ）、AAAクライアント、RP。"
    },
    {
      "indent": 3,
      "text": "Recipient: IdP",
      "ja": "受信者：IdPが"
    },
    {
      "indent": 3,
      "text": "Eavesdroppers and attackers can reside on any or all communication links between the entities shown in Figure 4.",
      "ja": "盗聴者と攻撃者は、図4に示すエンティティ間のいずれかまたはすべての通信リンク上に存在することができます。"
    },
    {
      "indent": 3,
      "text": "The various entities in the system might also collude or be coerced into colluding. Some of the significant collusions to look at are as follows:",
      "ja": "システム内のさまざまなエンティティはまた、共謀したり、共謀に強制すること。次のように見て重要なcollusionsのいくつかは以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "o If two RPs are colluding, they have the information available to both nodes. This can be analyzed as if a single RP were offering multiple services.",
      "ja": "2つのRPが共謀している場合は、O、彼らは両方のノードに利用可能な情報を持っています。単一RPは、複数のサービスを提供しているかのようにこれを解析することができます。"
    },
    {
      "indent": 3,
      "text": "o If an RP and a AAA proxy are colluding, then the trust of the system is broken, as the RP would be able to lie about its own identity to the IdP. There is no known way to deal with this situation.",
      "ja": "RPおよびAAAプロキシが共謀している場合は、O RPがIdPのに独自のアイデンティティ偽ることができるだろうとして、システムの信頼は、壊れています。このような状況に対処するための既知の方法はありません。"
    },
    {
      "indent": 3,
      "text": "o If multiple AAA proxies are colluding, they can be treated as a single node for analysis.",
      "ja": "複数のAAAプロキシが共謀している場合は、O、それらを分析のために単一のノードとして扱うことができます。"
    },
    {
      "indent": 3,
      "text": "The Federation Substrate consists of all of the AAA entities. In some cases, the AAA proxies may not exist, as the AAA client can talk directly to the AAA server. Specifications such as the Trust Router Protocol (https://www.ietf.org/proceedings/86/slides/ slides-86-rtgarea-0.pdf) and RADIUS dynamic discovery [RFC7585] can be used to shorten the path between the AAA client and the AAA server (and thus stop these AAA proxies from being observers); however, even in these circumstances, there may be AAA proxies in the path.",
      "ja": "連盟基板は、AAAエンティティのすべてで構成されています。 AAAクライアントは、AAAサーバに直接話すことができるよう、いくつかのケースでは、AAAプロキシは、存在しないかもしれません。そのような信頼ルータプロトコル（https://www.ietf.org/proceedings/86/slides/スライド-86-rtgarea-0.pdf）などの仕様、およびRADIUS動的発見[RFC7585]はとの間の経路を短くするために使用することができますAAAクライアントとAAAサーバ（したがって、オブザーバーであることから、これらのAAAプロキシを停止します）。しかし、このような状況では、パス内のAAAプロキシが存在してもよいです。"
    },
    {
      "indent": 3,
      "text": "In Figure 4, the IdP has been divided into multiple logical pieces;\nin actual implementations, these pieces will frequently be tightly\ncoupled.  The links between these pieces provide the greatest\nopportunity for attackers and eavesdroppers to acquire information;\nhowever, as they are all under the control of a single entity, they\nare also the easiest to have tightly secured.",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.2. Privacy Aspects of ABFAB Communication Flows",
      "section_title": true,
      "ja": "4.2。 ABFABコミュニケーションのプライバシー態様はフロー"
    },
    {
      "indent": 3,
      "text": "In the ABFAB architecture, there are a few different types of data and identifiers in use. The best way to understand them, and their potential privacy impacts, is to look at each phase of communication in ABFAB.",
      "ja": "ABFABアーキテクチャでは、使用中のデータと識別子のいくつかの異なるタイプがあります。彼ら、そして彼らの潜在的なプライバシーへの影響を理解するための最良の方法は、ABFABにおける通信の各フェーズを見ることです。"
    },
    {
      "indent": 0,
      "text": "4.2.1. Client to RP",
      "section_title": true,
      "ja": "4.2.1。 RPへのクライアント"
    },
    {
      "indent": 3,
      "text": "The flow of data between the client and the RP is divided into two parts. The first part consists of all of the data exchanged as part of the ABFAB authentication process. The second part consists of all of the data exchanged after the authentication process has been finished.",
      "ja": "クライアントとRP間のデータの流れは2つの部分に分けられます。最初の部分はABFAB認証プロセスの一部として交換されるデータの全てから成ります。第二部は、認証処理が終了した後に交換されるデータのすべてで構成されています。"
    },
    {
      "indent": 3,
      "text": "During the initial communication phase, the client sends an NAI (see [RFC7542]) to the RP. Many EAP methods (but not all) allow the client to disclose an NAI to the RP in a form that includes only a realm component during this communication phase. This is the minimum amount of identity information necessary for ABFAB to work -- it indicates an IdP that the principal has a relationship with. EAP methods that do not allow this will necessarily also reveal an identifier for the principal in the IdP realm (e.g., a username).",
      "ja": "最初の通信フェーズでは、クライアントは、RPに（[RFC7542]を参照）NAIを送信します。多くのEAPメソッド（全てではない）クライアントがこの通信フェーズの間のみレルム成分を含む形でRPにNAIを開示することを可能にします。これはABFABが機能するために必要な識別情報の最小量である - それは主にとの関係を持っていることのIdPを示しています。これは必然的にIdPの領域（例えば、ユーザ名）にプリンシパルの識別子を明らかにすることができないEAPメソッド。"
    },
    {
      "indent": 3,
      "text": "The data shared during the initial communication phase may be protected by a channel protocol such as TLS. This will prevent the leakage of information to passive eavesdroppers; however, an active attacker may still be able to set itself up as a man-in-the-middle. The client may not be able to validate the certificates (if any) provided by the service, deferring the check of the identity of the RP until the completion of the ABFAB authentication protocol (using EAP channel binding rather than certificates).",
      "ja": "初期通信フェーズ中に共有データは、TLSとしてチャネルプロトコルによって保護されていてもよいです。これは、受動的な盗聴者への情報の漏洩を防止します。しかし、活発な攻撃者は依然としてのman-in-the-middleとして自身を設定することができるかもしれません。クライアントは、サービスによって提供される証明書（もしあれば）、（EAPチャネル結合ではなく、証明書を使用して）ABFAB認証プロトコルが完了するまでRPの同一性のチェックを延期を検証することができないかもしれません。"
    },
    {
      "indent": 3,
      "text": "The data exchanged after the authentication process can have privacy and authentication using the GSS-API services. If the overall application protocol allows for the process of re-authentication, then the same privacy implications as those discussed in previous paragraphs apply.",
      "ja": "認証プロセスの後に交換されるデータは、GSS-APIサービスを使用して、プライバシーと認証を持つことができます。全体的なアプリケーション・プロトコルが再認証のプロセスを可能にする場合は、前の段落で説明したものと同一のプライバシーへの影響が適用されます。"
    },
    {
      "indent": 0,
      "text": "4.2.2. Client to IdP (via Federation Substrate)",
      "section_title": true,
      "ja": "4.2.2。 （連盟基板を介し）のIdPへのクライアント"
    },
    {
      "indent": 3,
      "text": "This phase includes a secure TLS tunnel set up between the client and the IdP via the RP and Federation Substrate. The process is initiated by the RP using the realm information given to it by the client. Once set up, the tunnel is used to send credentials to the IdP to authenticate.",
      "ja": "このフェーズでは、RP、連邦基板を介してクライアントとIdPの間に設定セキュアなTLSトンネルを含んでいます。プロセスは、クライアントによってそれに与えられたレルム情報を使用してRPによって開始されます。一度設定し、トンネルを認証するためのIdPに証明書を送信するために使用されています。"
    },
    {
      "indent": 3,
      "text": "Various operational information is transported between the RP and the IdP over the AAA infrastructure -- for example, using RADIUS headers. As no end-to-end security is provided by AAA, all AAA entities on the path between the RP and IdP have the ability to eavesdrop on this information. Some of this information may form identifiers or explicit identity information:",
      "ja": "例えば、RADIUSヘッダを使用して - 様々な動作情報は、AAAインフラストラクチャを介してRPとIdPの間に搬送されます。何のエンドツーエンドのセキュリティは、AAAによって提供されていないとして、RPとIdPの間のパス上のすべてのAAAエンティティは、この情報を盗聴する能力を持っています。この情報の一部は、識別子または明示的な識別情報を形成することができます。"
    },
    {
      "indent": 3,
      "text": "o The RP knows the IP address of the client. It is possible that the RP could choose to expose this IP address by including it in a RADIUS header (e.g., using the Calling-Station-Id). This is a privacy consideration to take into account for the application protocol.",
      "ja": "O RPは、クライアントのIPアドレスを知っています。 RP（例えば、通話-駅-IDを使用して）RADIUSヘッダに含めて、このIPアドレスを公開することを選択する可能性があります。これは、アプリケーションプロトコルのために考慮すべきプライバシーの配慮です。"
    },
    {
      "indent": 3,
      "text": "o The EAP MSK is transported between the IdP and the RP over the AAA infrastructure -- for example, through RADIUS headers. This is a particularly important privacy consideration, as any AAA proxy that has access to the EAP MSK is able to decrypt and eavesdrop on any traffic encrypted using that EAP MSK (i.e., all communications between the client and RP). This problem can be mitigated if the application protocol sets up a secure tunnel between the client and the RP and performs a cryptographic binding between the tunnel and EAP MSK.",
      "ja": "oをEAP MSKは、AAAインフラストラクチャを介してのIdPとRPとの間に搬送される - 例えば、RADIUSヘッダーを介し。 EAP MSKへのアクセス権を持つすべてのAAAプロキシは、解読し、EAP MSK（クライアントとRPの間、すなわち、すべての通信）することを使用して暗号化されたすべてのトラフィックを盗聴することができ、これは、特に重要なプライバシーの考慮事項です。アプリケーションプロトコルは、クライアントとRPとの間の安全なトンネルを設定し、トンネルとEAP MSKとの間の結合暗号化を行う場合、この問題を軽減することができます。"
    },
    {
      "indent": 3,
      "text": "o Related to the bullet point above, the AAA server has access to the material necessary to derive the session key; thus, the AAA server can observe any traffic encrypted between the client and RP. This \"feature\" was chosen as a simplification and to make performance faster; if it was decided that this trade-off was not desirable for privacy and security reasons, then extensions to ABFAB that make use of techniques such as Diffie-Hellman key exchange would mitigate this.",
      "ja": "O上記の箇条書きに関連して、AAAサーバは、セッション鍵を導出するのに必要な材料へのアクセスを有します。このように、AAAサーバは、クライアントとRPの間で暗号化されたすべてのトラフィックを監視することができます。この「機能は、」簡素化として選ばれたと高速なパフォーマンスをするために、それは、このトレードオフは、プライバシーとセキュリティ上の理由のために望ましくなかったことが決定された場合には、そのようなのDiffie-Hellman鍵交換などの手法を活用しABFABの拡張機能は、これを緩和します。"
    },
    {
      "indent": 3,
      "text": "The choice of EAP method used has other potential privacy implications. For example, if the EAP method in use does not support mutual authentication, then there are no guarantees that the IdP is who it claims to be, and thus the full NAI, including a username and a realm, might be sent to any entity masquerading as a particular IdP.",
      "ja": "使用EAP方式の選択は、他の潜在的なプライバシーの意味を持ちます。使用中のEAPメソッドは、相互認証をサポートしていない場合たとえば、その後、ユーザ名とレルムを含むIDPは、それがあることを主張する人であることを保証し、したがって完全なNAIは、存在しない、任意のエンティティに送信される可能性がありますマスカレード特定のIdPとして。"
    },
    {
      "indent": 3,
      "text": "Note that ABFAB has not specified any AAA accounting requirements. Implementations that use the accounting portion of AAA should consider privacy appropriately when designing this aspect.",
      "ja": "ABFABは、任意のAAAアカウンティングの要件を指定していないことに注意してください。この側面を設計する際に、適切にプライバシーを考慮すべきであるAAAの会計上の部分を使用して実装。"
    },
    {
      "indent": 0,
      "text": "4.2.3. IdP to RP (via Federation Substrate)",
      "section_title": true,
      "ja": "4.2.3。 RPへのIdP（連盟基板を介し）"
    },
    {
      "indent": 3,
      "text": "In this phase, the IdP communicates with the RP, informing it as to the success or failure of authentication of the user and, optionally, the sending of identity information about the principal.",
      "ja": "この段階では、IdPが主に関する識別情報の送信を、必要に応じて、ユーザの認証の成功または失敗のようにそれを通知すると、RPと通信します。"
    },
    {
      "indent": 3,
      "text": "As in the previous flow (client to IdP), various operation information is transported between the IdP and RP over the AAA infrastructure, and the same privacy considerations apply. However, in this flow, explicit identity information about the authenticated principal can be sent from the IdP to the RP. This information can be sent through RADIUS headers, or using SAML [RFC7833]. This can include protocol-specific identifiers, such as SAML NameIDs, as well as arbitrary attribute information about the principal. What information will be released is controlled by policy on the IdP. As before, when sending this information through RADIUS headers, all AAA entities on the path between the RP and IdP have the ability to eavesdrop, unless additional security measures are taken (such as the use of TLS for RADIUS [RFC6614]). However, when sending this",
      "ja": "先行フロー（IDPにクライアント）のように、各種の操作情報は、AAAインフラストラクチャを介してのIdPとRPとの間に搬送され、同一のプライバシーの考慮事項が適用されます。しかし、この流れの中で、認証されたプリンシパルについての明確なアイデンティティ情報は、RPへのIdPから送信することができます。この情報は、RADIUSヘッダーを介して送信される、またはSAML [RFC7833]を使用することができます。これは、SAML名前IDなどのプロトコル固有の識別子、ならびに主要約任意の属性情報を含むことができます。どのような情報がリリースされる予定のIdP上のポリシーによって制御されます。 RADIUSヘッダーを介してこの情報を送信するときに、追加のセキュリティ対策が取られない限り、以前のように、RPとIdPの間のパス上のすべてのAAAエンティティは、盗聴する能力を有する（例えばRADIUS [RFC6614]のためのTLSの使用など）。しかし、これを送信するとき"
    },
    {
      "indent": 3,
      "text": "information using SAML as specified in [RFC7833], confidentiality of the information should be guaranteed, as [RFC7833] requires the use of TLS for RADIUS.",
      "ja": "[RFC7833]はRADIUSのためにTLSを使用する必要があるとして、[RFC7833]で指定されたSAMLを使用した情報は、情報の機密性が保証されなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.3. Relationship between User and Entities",
      "section_title": true,
      "ja": "4.3。ユーザーとエンティティの関係"
    },
    {
      "indent": 3,
      "text": "o Between user and IdP - The IdP is an entity the user will have a direct relationship with, created when the organization that operates the entity provisioned and exchanged the user's credentials. Privacy and data protection guarantees may form a part of this relationship.",
      "ja": "ユーザーとのIdP間○ -  IdPが、ユーザーがエンティティを運営する組織は、ユーザーの資格情報をプロビジョニングし、交換したときに作成されたとの直接的な関係を持っていますエンティティです。プライバシーとデータ保護の保証は、この関係の一部を形成してもよいです。"
    },
    {
      "indent": 3,
      "text": "o Between user and RP - The RP is an entity the user may or may not have a direct relationship with, depending on the service in question. Some services may only be offered to those users where such a direct relationship exists (for particularly sensitive services, for example), while some may not require this and would instead be satisfied with basic federation trust guarantees between themselves and the IdP. This may well include the option that the user stays anonymous with respect to the RP (though, obviously, never anonymous to the IdP). If attempting to preserve privacy via data minimization (Section 1), then the only attribute information about Individuals exposed to the RP should be attribute information that is strictly necessary for the operation of the service.",
      "ja": "ユーザーとRP間○ -  RPは、ユーザーがまたは当該サービスに応じて、との直接的な関係があってもなくてもよいエンティティです。いくつかは、これを必要とせず、代わりに自分自身とIdPの間の基本的なフェデレーションの信頼の保証に満足するでしょうしながら、一部のサービスは、そのような直接的な関係は、（例えば、特に敏感なサービスのために）存在するものをユーザに提供することができます。これはよく、ユーザーがRP（IDPにかかわらず、明らかに、決して匿名）に対する匿名のままのオプションを含むことができます。データの最小化（第1節）を経由してプライバシーを保護しようとする場合は、RPにさらされる個人に関する属性情報のみがサービスの動作に厳密に必要な属性情報をする必要があります。"
    },
    {
      "indent": 3,
      "text": "o Between user and Federation Substrate - The user is highly likely to have no knowledge of, or relationship with, any entities involved with the Federation Substrate (not that the IdP and/or RP may, however). Knowledge of attribute information about Individuals for these entities is not necessary, and thus such information should be protected in such a way as to prevent the possibility of access to this information.",
      "ja": "ユーザー連邦基板との間に○ - ユーザーは連盟基板に関わるすべてのエンティティ（ないことのIdPおよび/またはRPの月は、しかし）、何の知識、またはと関係を持っていない可能性が高いです。これらのエンティティのための個人に関する属性情報の知識は必要ありませんので、そのような情報は、この情報へのアクセスの可能性を防止するような方法で保護する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.4. Accounting Information",
      "section_title": true,
      "ja": "4.4。会計情報"
    },
    {
      "indent": 3,
      "text": "Alongside the core authentication and authorization that occur in AAA communications, accounting information about resource consumption may be delivered as part of the accounting exchange during the lifetime of the granted application session.",
      "ja": "リソース消費に関する課金情報をAAA通信で発生するコア認証および許可、一緒に付与されたアプリケーションセッションの寿命の間会計交換の一部として提供されてもよいです。"
    },
    {
      "indent": 0,
      "text": "4.5. Collection and Retention of Data and Identifiers",
      "section_title": true,
      "ja": "4.5。データと識別子の収集と保存"
    },
    {
      "indent": 3,
      "text": "In cases where RPs are not required to identify a particular Individual when an Individual wishes to make use of their service, the ABFAB architecture enables anonymous or pseudonymous access. Thus, data and identifiers other than pseudonyms and unlinkable attribute information need not be stored and retained.",
      "ja": "RPは個人が彼らのサービスを利用したいときに、特定の個人を識別するために必要とされていない場合には、ABFABアーキテクチャは、匿名または変名のアクセスを可能にします。このように、データと仮名とリンク不可能な属性情報以外の識別子が記憶保持する必要はありません。"
    },
    {
      "indent": 3,
      "text": "However, in cases where RPs require the ability to identify a particular Individual (e.g., so they can link this identity information to a particular account in their service, or where identity information is required for audit purposes), the service will need to collect and store such information, and to retain it for as long as they require. The de-provisioning of such accounts and information is out of scope for ABFAB, but for privacy protection, it is obvious that any identifiers collected should be deleted when they are no longer needed.",
      "ja": "（身元情報は監査の目的のために必要な場合など、そう、彼らは彼らのサービスで特定のアカウントに、この識別情報をリンクすることができ、または）ただし、RPは特定の個人を識別できる能力が必要な場合には、サービスを収集する必要がありますし、そのような情報を格納し、限り、彼らが必要とするためにそれを保持します。このようなアカウント情報のデプロビジョニングはABFABの範囲外ですが、プライバシー保護のために、彼らがもはや必要とされたときに収集したすべての識別子は削除すべきではないことは明らかです。"
    },
    {
      "indent": 0,
      "text": "4.6. User Participation",
      "section_title": true,
      "ja": "4.6。ユーザー参加"
    },
    {
      "indent": 3,
      "text": "In the ABFAB architecture, by its very nature users are active participants in the sharing of their identifiers, as they initiate the communications exchange every time they wish to access a server. They are, however, not involved in the control of information related to them that is transmitted from the IdP to the RP for authorization purposes; rather, this is under the control of policy on the IdP. Due to the nature of the AAA communication flows, with the current ABFAB architecture there is no place for a process of gaining user consent for the information to be released from the IdP to the RP.",
      "ja": "ABFABアーキテクチャでは、その性質上のユーザーが、彼らはすべての時間を通信交換を開始として、彼らは、サーバーにアクセスしたい、その識別子の共有に積極的に参加しています。彼らは、しかし、認証目的のためにRPへのIdPから送信されたそれらに関連した情報の制御に関与していません。むしろ、これは、IdPの上のポリシーの制御下にあります。 AAAの通信フローの性質のために、現在のABFABアーキテクチャとRPへのIdPから解放される情報についてユーザーの同意を得るプロセスのための場所がありません。"
    },
    {
      "indent": 0,
      "text": "5. Security Considerations",
      "section_title": true,
      "ja": "5.セキュリティについての考慮事項"
    },
    {
      "indent": 3,
      "text": "This document describes the architecture for Application Bridging for Federated Access Beyond web (ABFAB), and security is therefore the main focus. Many of the items that are security considerations have already been discussed in Section 4 (\"Privacy Considerations\"). Readers should be sure to read that section as well.",
      "ja": "この文書は、ウェブを越えてフェデレーションアクセス（ABFAB）のためのブリッジングアプリケーションのアーキテクチャについて説明し、セキュリティがゆえ主な焦点です。セキュリティの考慮されている項目の多くは、すでに第4節（「プライバシーの考慮事項」）で議論されています。読者は、同様にそのセクションをお読みくださいする必要があります。"
    },
    {
      "indent": 3,
      "text": "There are many places in this document where TLS is used. While in some places (e.g., client to RP) anonymous connections can be used, it is very important that TLS connections within the AAA infrastructure and between the client and the IdP be fully authenticated and, if using certificates, that revocation be checked as well. When using anonymous connections between the client and the RP, all messages and data exchanged between those two entities will be visible to an active attacker. In situations where the client is not yet on the network, the status_request extension [RFC6066] can be used to obtain revocation-checking data inside of the TLS protocol. Clients also need to get the trust anchor for the IdP configured correctly in order to prevent attacks; this is a difficult problem in general and is going to be even more difficult for kiosk environments.",
      "ja": "TLSが使用されているこの文書に記載されている多くの場所があります。いくつかの場所（RPに例えば、クライアント）に匿名接続を使用することができますが、AAAインフラストラクチャ内やクライアントとのIdP間のTLS接続が完全に認証することや、証明書を使用している場合、その取消しも同様にチェックすることが非常に重要です。クライアントとRP間の匿名接続を使用する場合は、これら2つのエンティティ間で交換されるすべてのメッセージおよびデータは、アクティブな攻撃者に表示されます。クライアントがネットワーク上にまだない状況では、status_request拡張[RFC6066]はTLSプロトコルの内部失効チェックデータを取得するために使用することができます。また、クライアントは攻撃を防ぐために正しく構成されたIdPの信頼アンカーを取得する必要があります。これは一般的に困難な問題であり、さらに困難キオスク環境のためになるだろう。"
    },
    {
      "indent": 3,
      "text": "Selection of the EAP methods to be permitted by clients and IdPs is important. The use of a tunneling method such as TEAP [RFC7170] allows other EAP methods to be used while hiding the contents of those EAP exchanges from the RP and the AAA framework. When considering inner EAP methods, the considerations outlined in [RFC7029] about binding the inner and outer EAP methods need to be taken into account. Finally, one wants to have the ability to support channel binding in those cases where the client needs to validate that it is talking to the correct RP.",
      "ja": "クライアントとのIdPによって許可されるEAP方式の選択が重要です。例えばTEAP [RFC7170]などのトンネリング方法を使用することは、RPとAAAフレームワークからのものEAP交換の内容を隠しながら、他のEAPメソッドを使用することを可能にします。内部EAPメソッドを考慮すると、内側と外側のEAPメソッドを結合について[RFC7029]に概説の考察は考慮に入れる必要があります。最後に、1は、クライアントが、それが正しいRPに話していることを検証するために必要な場合には結合チャネルをサポートする能力を持って望んでいます。"
    },
    {
      "indent": 3,
      "text": "In those places where SAML statements are used, RPs will generally be unable to validate signatures on the SAML statement, either because the signature has been stripped off by the IdP or because the RP is unable to validate the binding between the signer, the key used to sign, and the realm represented by the IdP. For these reasons, it is required that IdPs do the necessary trust checking on the SAML statements and that RPs can trust the AAA infrastructure to keep the SAML statements valid.",
      "ja": "署名は、IdPのにより剥離されたまたはRPは署名者との間の結合を確認することができないため、鍵が使用ので、SAMLステートメントが使用されているそれらの場所では、RPは一般のいずれか、SAMLステートメントに署名を検証することができませんサインインしてのIdPに代表されるレルムに。これらの理由から、のIdPが必要な信頼がSAML文にチェックし、RPが有効なSAML文を維持するために、AAAインフラストラクチャを信頼できることを行うことが必要とされます。"
    },
    {
      "indent": 3,
      "text": "When a pseudonym is generated as a unique long-term identifier for a client by an IdP, care must be taken in the algorithm that it cannot easily be reverse-engineered by the service provider. If it can be reverse-engineered, then the service provider can consult an oracle to determine if a given unique long-term identifier is associated with a different known identifier.",
      "ja": "仮名がIdPのことで、クライアントのためのユニークな長期的な識別子として生成されると、ケアは、それが簡単にサービスプロバイダによってリバースエンジニアリングすることができないアルゴリズムで撮影しなければなりません。これはリバースエンジニアリングすることができる場合、サービスプロバイダは、指定されたユニークな長期的識別子は、異なる既知の識別子に関連付けられているかどうかを決定するために、Oracleに相談することができます。"
    },
    {
      "indent": 0,
      "text": "6. References",
      "section_title": true,
      "ja": "6.参照"
    },
    {
      "indent": 0,
      "text": "6.1. Normative References",
      "section_title": true,
      "ja": "6.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC2743] Linn, J., \"Generic Security Service Application Program Interface Version 2, Update 1\", RFC 2743, DOI 10.17487/RFC2743, January 2000, <http://www.rfc-editor.org/info/rfc2743>.",
      "ja": "[RFC2743]リン、J.、 \"ジェネリックセキュリティーサービス適用業務プログラムインタフェースバージョン2、アップデート1\"、RFC 2743、DOI 10.17487 / RFC2743、2000年1月、<http://www.rfc-editor.org/info/rfc2743> 。"
    },
    {
      "indent": 3,
      "text": "[RFC2865] Rigney, C., Willens, S., Rubens, A., and W. Simpson, \"Remote Authentication Dial In User Service (RADIUS)\", RFC 2865, DOI 10.17487/RFC2865, June 2000, <http://www.rfc-editor.org/info/rfc2865>.",
      "ja": "[RFC2865] Rigney、C.、ウィレンス、S.、ルーベン、A.、およびW.シンプソン、RFC 2865 \"ユーザーサービス（RADIUS）でリモート認証ダイヤル\"、DOI 10.17487 / RFC2865、2000年6月、<のhttp：/ /www.rfc-editor.org/info/rfc2865>。"
    },
    {
      "indent": 3,
      "text": "[RFC3579] Aboba, B. and P. Calhoun, \"RADIUS (Remote Authentication Dial In User Service) Support For Extensible Authentication Protocol (EAP)\", RFC 3579, DOI 10.17487/RFC3579, September 2003, <http://www.rfc-editor.org/info/rfc3579>.",
      "ja": "[RFC3579] Aboba、B.およびP.カルフーン、 \"拡張認証プロトコル（EAP）のためにRADIUS（ユーザサービスにおけるリモート認証ダイヤル）サポート\"、RFC 3579、DOI 10.17487 / RFC3579、2003年9月、<のhttp：// WWW。 rfc-editor.org/info/rfc3579>。"
    },
    {
      "indent": 3,
      "text": "[RFC3748] Aboba, B., Blunk, L., Vollbrecht, J., Carlson, J., and H. Levkowetz, Ed., \"Extensible Authentication Protocol (EAP)\", RFC 3748, DOI 10.17487/RFC3748, June 2004, <http://www.rfc-editor.org/info/rfc3748>.",
      "ja": "[RFC3748] Aboba、B.、ブルンク、L.、Vollbrecht、J.、カールソン、J.、およびH. Levkowetz、編、 \"拡張認証プロトコル（EAP）\"、RFC 3748、DOI 10.17487 / RFC3748、2004年6月、<http://www.rfc-editor.org/info/rfc3748>。"
    },
    {
      "indent": 3,
      "text": "[RFC4072] Eronen, P., Ed., Hiller, T., and G. Zorn, \"Diameter Extensible Authentication Protocol (EAP) Application\", RFC 4072, DOI 10.17487/RFC4072, August 2005, <http://www.rfc-editor.org/info/rfc4072>.",
      "ja": "[RFC4072] Eronen、P.、エド、ヒラー、T.、およびG.ゾルン、 \"直径拡張認証プロトコル（EAP）アプリケーション\"、RFC 4072、DOI 10.17487 / RFC4072、2005年8月、<HTTP：// WWW。 rfc-editor.org/info/rfc4072>。"
    },
    {
      "indent": 3,
      "text": "[RFC6677] Hartman, S., Ed., Clancy, T., and K. Hoeper, \"Channel-Binding Support for Extensible Authentication Protocol (EAP) Methods\", RFC 6677, DOI 10.17487/RFC6677, July 2012, <http://www.rfc-editor.org/info/rfc6677>.",
      "ja": "[RFC6677]ハートマン、S.、エド、クランシー、T.、およびK. Hoeper、RFC 6677、DOI 10.17487 / RFC6677、2012年7月、<HTTP \"拡張認証プロトコル（EAP）メソッドのチャンネル・バインディングのサポート\"： //www.rfc-editor.org/info/rfc6677>。"
    },
    {
      "indent": 3,
      "text": "[RFC7055] Hartman, S., Ed., and J. Howlett, \"A GSS-API Mechanism for the Extensible Authentication Protocol\", RFC 7055, DOI 10.17487/RFC7055, December 2013, <http://www.rfc-editor.org/info/rfc7055>.",
      "ja": "[RFC7055]ハートマン、S.、エド、及びJ.ハウレット、 \"拡張認証プロトコルのためのGSS-API機構\"、RFC 7055、DOI 10.17487 / RFC7055、2013年12月、<HTTP：//www.rfc-editor .ORG /情報/ rfc7055>。"
    },
    {
      "indent": 3,
      "text": "[RFC7542] DeKok, A., \"The Network Access Identifier\", RFC 7542, DOI 10.17487/RFC7542, May 2015, <http://www.rfc-editor.org/info/rfc7542>.",
      "ja": "[RFC7542] DeKok、A.、 \"ネットワークアクセス識別子\"、RFC 7542、DOI 10.17487 / RFC7542、2015年5月、<http://www.rfc-editor.org/info/rfc7542>。"
    },
    {
      "indent": 3,
      "text": "[RFC7833] Howlett, J., Hartman, S., and A. Perez-Mendez, Ed., \"A RADIUS Attribute, Binding, Profiles, Name Identifier Format, and Confirmation Methods for the Security Assertion Markup Language (SAML)\", RFC 7833, DOI 10.17487/RFC7833, May 2016, <http://www.rfc-editor.org/info/rfc7833>.",
      "ja": "[RFC7833]ハウレット、J.、ハルトマン、S.、およびA.ペレス - メンデス、編、「RADIUS属性、結合、プロフィール、名前識別子フォーマット、およびセキュリティアサーションマークアップ言語（SAML）の確認方法」、 RFC 7833、DOI 10.17487 / RFC7833、2016年5月、<http://www.rfc-editor.org/info/rfc7833>。"
    },
    {
      "indent": 0,
      "text": "6.2. Informative References",
      "section_title": true,
      "ja": "6.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[NIST-SP.800-63-2] Burr, W., Dodson, D., Newton, E., Perlner, R., Polk, W., Gupta, S., and E. Nabbus, \"Electronic Authentication Guideline\", NIST Special Publication 800-63-2, August 2013, <http://dx.doi.org/10.6028/NIST.SP.800-63-2>.",
      "ja": "[NIST-SP.800-63-2]バリ、W.、ドッドソン、D.、ニュートン、E.、Perlner、R.、ポーク、W.、グプタ、S.、およびE. Nabbus、「電子認証ガイドライン」、は、NIST Special Publication 800-63-2、2013年8月、<http://dx.doi.org/10.6028/NIST.SP.800-63-2>。"
    },
    {
      "indent": 3,
      "text": "[OASIS.saml-core-2.0-os] Cantor, S., Kemp, J., Philpott, R., and E. Maler, \"Assertions and Protocols for the OASIS Security Assertion Markup Language (SAML) V2.0\", OASIS Standard saml-core-2.0-os, March 2005, <http://docs.oasis-open.org/security/saml/v2.0/ saml-core-2.0-os.pdf>.",
      "ja": "[OASIS.samlコア-2.0-OS]カントール、S.、ケンプ、J.、フィルポット、R.、およびE. MALER、 \"OASISセキュリティアサーションマークアップ言語（SAML）V2.0のためのアサーションとプロトコル\"、 OASIS標準のSAML-コア-2.0-OS、2005年3月、<http://docs.oasis-open.org/security/saml/v2.0/ SAML-コア-2.0-os.pdf>。"
    },
    {
      "indent": 3,
      "text": "[RFC1964] Linn, J., \"The Kerberos Version 5 GSS-API Mechanism\", RFC 1964, DOI 10.17487/RFC1964, June 1996, <http://www.rfc-editor.org/info/rfc1964>.",
      "ja": "[RFC1964]リン、J.、 \"ケルベロスバージョン5 GSS-API機構\"、RFC 1964、DOI 10.17487 / RFC1964、1996年6月、<http://www.rfc-editor.org/info/rfc1964>。"
    },
    {
      "indent": 3,
      "text": "[RFC2782] Gulbrandsen, A., Vixie, P., and L. Esibov, \"A DNS RR for specifying the location of services (DNS SRV)\", RFC 2782, DOI 10.17487/RFC2782, February 2000, <http://www.rfc-editor.org/info/rfc2782>.",
      "ja": "[RFC2782] Gulbrandsenの、A.、いるVixie、P.、およびL. Esibov、 \"サービスの場所を特定するためのDNS RR（DNSのSRV）\"、RFC 2782、DOI 10.17487 / RFC2782、2000年2月、<HTTP：// www.rfc-editor.org/info/rfc2782>。"
    },
    {
      "indent": 3,
      "text": "[RFC3401] Mealling, M., \"Dynamic Delegation Discovery System (DDDS) Part One: The Comprehensive DDDS\", RFC 3401, DOI 10.17487/RFC3401, October 2002, <http://www.rfc-editor.org/info/rfc3401>.",
      "ja": "[RFC3401] Mealling、M.、 \"ダイナミックな委譲発見システム（DDDS）第一部：総合DDDS\"、RFC 3401、DOI 10.17487 / RFC3401、2002年10月、<http://www.rfc-editor.org/info/ rfc3401>。"
    },
    {
      "indent": 3,
      "text": "[RFC3645] Kwan, S., Garg, P., Gilroy, J., Esibov, L., Westhead, J., and R. Hall, \"Generic Security Service Algorithm for Secret Key Transaction Authentication for DNS (GSS-TSIG)\", RFC 3645, DOI 10.17487/RFC3645, October 2003, <http://www.rfc-editor.org/info/rfc3645>.",
      "ja": "[RFC3645]クワン、S.、ガーグ、P.、ギルロイ、J.、Esibov、L.、Westhead、J.、およびR.ホール、DNS（GSS-TSIG）用の秘密鍵取引認証のための「一般的なセキュリティサービスアルゴリズム」、RFC 3645、DOI 10.17487 / RFC3645、2003年10月、<http://www.rfc-editor.org/info/rfc3645>。"
    },
    {
      "indent": 3,
      "text": "[RFC4033] Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, \"DNS Security Introduction and Requirements\", RFC 4033, DOI 10.17487/RFC4033, March 2005, <http://www.rfc-editor.org/info/rfc4033>.",
      "ja": "[RFC4033]アレンズ、R.、Austeinと、R.、ラーソン、M.、マッシー、D.、およびS.ローズ、 \"DNSセキュリティ序論と要件\"、RFC 4033、DOI 10.17487 / RFC4033、2005年3月、<のhttp： //www.rfc-editor.org/info/rfc4033>。"
    },
    {
      "indent": 3,
      "text": "[RFC4422] Melnikov, A., Ed., and K. Zeilenga, Ed., \"Simple Authentication and Security Layer (SASL)\", RFC 4422, DOI 10.17487/RFC4422, June 2006, <http://www.rfc-editor.org/info/rfc4422>.",
      "ja": "[RFC4422]メルニコフ、A.、エド、およびK. Zeilenga、エド、 \"簡易認証セキュリティー層（SASL）\"、RFC 4422、DOI 10.17487 / RFC4422、2006年6月、<のhttp：。。//www.rfc- editor.org/info/rfc4422>。"
    },
    {
      "indent": 3,
      "text": "[RFC4462] Hutzelman, J., Salowey, J., Galbraith, J., and V. Welch, \"Generic Security Service Application Program Interface (GSS-API) Authentication and Key Exchange for the Secure Shell (SSH) Protocol\", RFC 4462, DOI 10.17487/RFC4462, May 2006, <http://www.rfc-editor.org/info/rfc4462>.",
      "ja": "[RFC4462] Hutzelman、J.、Salowey、J.、ガルブレイス、J.、およびV.ウェルチ、 \"ジェネリックセキュリティーサービス適用業務プログラムインタフェース（GSS-API）の認証とセキュアシェル（SSH）プロトコルのための鍵交換\"、RFC 4462、DOI 10.17487 / RFC4462、2006年5月、<http://www.rfc-editor.org/info/rfc4462>。"
    },
    {
      "indent": 3,
      "text": "[RFC5056] Williams, N., \"On the Use of Channel Bindings to Secure Channels\", RFC 5056, DOI 10.17487/RFC5056, November 2007, <http://www.rfc-editor.org/info/rfc5056>.",
      "ja": "\"チャネルを確保するチャネルバインディングの使用について\" [RFC5056]ウィリアムズ、N.、RFC 5056、DOI 10.17487 / RFC5056、2007年11月、<http://www.rfc-editor.org/info/rfc5056>。"
    },
    {
      "indent": 3,
      "text": "[RFC5080] Nelson, D. and A. DeKok, \"Common Remote Authentication Dial In User Service (RADIUS) Implementation Issues and Suggested Fixes\", RFC 5080, DOI 10.17487/RFC5080, December 2007, <http://www.rfc-editor.org/info/rfc5080>.",
      "ja": "[RFC5080]ネルソン、D.とA. DeKok、 \"修正案の共通リモート認証ユーザーサービス（RADIUS）実装の問題でダイヤルと\"、RFC 5080、DOI 10.17487 / RFC5080、2007年12月、<のhttp：//www.rfc- editor.org/info/rfc5080>。"
    },
    {
      "indent": 3,
      "text": "[RFC5246] Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS) Protocol Version 1.2\", RFC 5246, DOI 10.17487/RFC5246, August 2008, <http://www.rfc-editor.org/info/rfc5246>.",
      "ja": "[RFC5246]ダークス、T.およびE.レスコラ、 \"トランスポート層セキュリティ（TLS）プロトコルバージョン1.2\"、RFC 5246、DOI 10.17487 / RFC5246、2008年8月、<http://www.rfc-editor.org/info / RFC5246>。"
    },
    {
      "indent": 3,
      "text": "[RFC5705] Rescorla, E., \"Keying Material Exporters for Transport Layer Security (TLS)\", RFC 5705, DOI 10.17487/RFC5705, March 2010, <http://www.rfc-editor.org/info/rfc5705>.",
      "ja": "[RFC5705]レスコラ、E.、RFC 5705、DOI 10.17487 / RFC5705、2010年3月、 \"トランスポート層セキュリティ（TLS）のための鍵材料輸出\" <http://www.rfc-editor.org/info/rfc5705>。"
    },
    {
      "indent": 3,
      "text": "[RFC5801] Josefsson, S. and N. Williams, \"Using Generic Security Service Application Program Interface (GSS-API) Mechanisms in Simple Authentication and Security Layer (SASL): The GS2 Mechanism Family\", RFC 5801, DOI 10.17487/RFC5801, July 2010, <http://www.rfc-editor.org/info/rfc5801>.",
      "ja": "[RFC5801] Josefsson氏、S.およびN.ウィリアムズ、 \"ジェネリックセキュリティーサービス適用業務プログラムインタフェース（GSS-API）を使用した簡易認証セキュリティー層（SASL）でのメカニズム：GS2メカニズムファミリー\"、RFC 5801、DOI 10.17487 / RFC5801、 2010年7月、<http://www.rfc-editor.org/info/rfc5801>。"
    },
    {
      "indent": 3,
      "text": "[RFC6066] Eastlake 3rd, D., \"Transport Layer Security (TLS) Extensions: Extension Definitions\", RFC 6066, DOI 10.17487/RFC6066, January 2011, <http://www.rfc-editor.org/info/rfc6066>.",
      "ja": "[RFC6066]イーストレイク3日、D.、 \"トランスポート層セキュリティ（TLS）拡張機能：拡張定義\"、RFC 6066、DOI 10.17487 / RFC6066、2011年1月、<http://www.rfc-editor.org/info/rfc6066> 。"
    },
    {
      "indent": 3,
      "text": "[RFC6614] Winter, S., McCauley, M., Venaas, S., and K. Wierenga, \"Transport Layer Security (TLS) Encryption for RADIUS\", RFC 6614, DOI 10.17487/RFC6614, May 2012, <http://www.rfc-editor.org/info/rfc6614>.",
      "ja": "[RFC6614]冬、S.、マッコーリー、M.、Venaas、S.、およびK. Wierenga、 \"RADIUSのためのトランスポート層セキュリティ（TLS）暗号化\"、RFC 6614、DOI 10.17487 / RFC6614、2012年5月、<のhttp：/ /www.rfc-editor.org/info/rfc6614>。"
    },
    {
      "indent": 3,
      "text": "[RFC6733] Fajardo, V., Ed., Arkko, J., Loughney, J., and G. Zorn, Ed., \"Diameter Base Protocol\", RFC 6733, DOI 10.17487/RFC6733, October 2012, <http://www.rfc-editor.org/info/rfc6733>.",
      "ja": "[RFC6733]ファハルド、V.、エド、Arkko、J.、Loughney、J.、およびG.ゾルン、編、 \"直径ベースプロトコル\"、RFC 6733、DOI 10.17487 / RFC6733、2012年10月、<HTTP：/ /www.rfc-editor.org/info/rfc6733>。"
    },
    {
      "indent": 3,
      "text": "[RFC6749] Hardt, D., Ed., \"The OAuth 2.0 Authorization Framework\", RFC 6749, DOI 10.17487/RFC6749, October 2012, <http://www.rfc-editor.org/info/rfc6749>.",
      "ja": "[RFC6749]ハルト、D.編、 \"OAuth 2.0の認証フレームワーク\"、RFC 6749、DOI 10.17487 / RFC6749、2012年10月、<http://www.rfc-editor.org/info/rfc6749>。"
    },
    {
      "indent": 3,
      "text": "[RFC6973] Cooper, A., Tschofenig, H., Aboba, B., Peterson, J., Morris, J., Hansen, M., and R. Smith, \"Privacy Considerations for Internet Protocols\", RFC 6973, DOI 10.17487/RFC6973, July 2013, <http://www.rfc-editor.org/info/rfc6973>.",
      "ja": "[RFC6973]クーパー、A.、Tschofenig、H.、Aboba、B.、ピーターソン、J.、モリス、J.、ハンセン、M.、およびR.スミス、 \"インターネットプロトコルのためのプライバシーの考慮事項\"、RFC 6973、DOI 10.17487 / RFC6973、2013年7月、<http://www.rfc-editor.org/info/rfc6973>。"
    },
    {
      "indent": 3,
      "text": "[RFC7029] Hartman, S., Wasserman, M., and D. Zhang, \"Extensible Authentication Protocol (EAP) Mutual Cryptographic Binding\", RFC 7029, DOI 10.17487/RFC7029, October 2013, <http://www.rfc-editor.org/info/rfc7029>.",
      "ja": "[RFC7029]ハートマン、S.、ワッサーマン、M.、およびD.チャン、 \"拡張認証プロトコル（EAP）結合相互暗号\"、RFC 7029、DOI 10.17487 / RFC7029、2013年10月、<HTTP：//www.rfc- editor.org/info/rfc7029>。"
    },
    {
      "indent": 3,
      "text": "[RFC7170] Zhou, H., Cam-Winget, N., Salowey, J., and S. Hanna, \"Tunnel Extensible Authentication Protocol (TEAP) Version 1\", RFC 7170, DOI 10.17487/RFC7170, May 2014, <http://www.rfc-editor.org/info/rfc7170>.",
      "ja": "[RFC7170]周、H.、カムウィンゲット、N.、Salowey、J.、およびS.ハンナ、 \"トンネル拡張認証プロトコル（TEAP）バージョン1\"、RFC 7170、DOI 10.17487 / RFC7170、2014年5月、<HTTP ：//www.rfc-editor.org/info/rfc7170>。"
    },
    {
      "indent": 3,
      "text": "[RFC7360] DeKok, A., \"Datagram Transport Layer Security (DTLS) as a Transport Layer for RADIUS\", RFC 7360, DOI 10.17487/RFC7360, September 2014, <http://www.rfc-editor.org/info/rfc7360>.",
      "ja": "[RFC7360] DeKok、A.、 \"RADIUSのためのトランスポート層としてデータグラムトランスポート層セキュリティ（DTLS）\"、RFC 7360、DOI 10.17487 / RFC7360、2014年9月、<http://www.rfc-editor.org/info/ rfc7360>。"
    },
    {
      "indent": 3,
      "text": "[RFC7499] Perez-Mendez, A., Ed., Marin-Lopez, R., Pereniguez-Garcia, F., Lopez-Millan, G., Lopez, D., and A. DeKok, \"Support of Fragmentation of RADIUS Packets\", RFC 7499, DOI 10.17487/RFC7499, April 2015, <http://www.rfc-editor.org/info/rfc7499>.",
      "ja": "[RFC7499]ペレス - メンデス、A.編、マリン - ロペス、R.、Pereniguez・ガルシア、F.、ロペス・ミラン、G.、ロペス、D.、およびA. DeKok、「RADIUSの断片化のサポートパケット」、RFC 7499、DOI 10.17487 / RFC7499、2015年4月、<http://www.rfc-editor.org/info/rfc7499>。"
    },
    {
      "indent": 3,
      "text": "[RFC7530] Haynes, T., Ed., and D. Noveck, Ed., \"Network File System (NFS) Version 4 Protocol\", RFC 7530, DOI 10.17487/RFC7530, March 2015, <http://www.rfc-editor.org/info/rfc7530>.",
      "ja": "[RFC7530]ヘインズ、T.、エド、およびD. Noveck、エド、 \"ネットワークファイルシステム（NFS）バージョン4プロトコル\"、RFC 7530、DOI 10.17487 / RFC7530、2015年3月、<のhttp：。。//www.rfc -editor.org/info/rfc7530>。"
    },
    {
      "indent": 3,
      "text": "[RFC7585] Winter, S. and M. McCauley, \"Dynamic Peer Discovery for RADIUS/TLS and RADIUS/DTLS Based on the Network Access Identifier (NAI)\", RFC 7585, DOI 10.17487/RFC7585, October 2015, <http://www.rfc-editor.org/info/rfc7585>.",
      "ja": "[RFC7585]冬、S.及びM.マッコーリー、 \"ネットワークアクセス識別子（NAI）に基づいて、RADIUS / TLSとRADIUS / DTLSの動的ピア発見\"、RFC 7585、DOI 10.17487 / RFC7585、2015年10月、<HTTP：/ /www.rfc-editor.org/info/rfc7585>。"
    },
    {
      "indent": 3,
      "text": "[WS-TRUST] Lawrence, K., Kaler, C., Nadalin, A., Goodner, M., Gudgin, M., Turner, D., Barbir, A., and H. Granqvist, \"WS-Trust 1.4\", OASIS Standard ws-trust-2012-04, April 2012, <http://docs.oasis-open.org/ws-sx/ws-trust/ v1.4/ws-trust.html>.",
      "ja": "[WS-TRUST]ローレンス、K.、Kaler、C.、Nadalin、A.、Goodner、M.、Gudgin、M.、ターナー、D.、Barbir、A.、およびH. Granqvist、「WS-Trustの1.4 」、OASIS標準のWS-信頼-2012から04、2012年4月、<http://docs.oasis-open.org/ws-sx/ws-trust/ V1.4 / WS-trust.html>。"
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "We would like to thank Mayutan Arumaithurai, Klaas Wierenga, and Rhys Smith for their feedback. Additionally, we would like to thank Eve Maler, Nicolas Williams, Bob Morgan, Scott Cantor, Jim Fenton, Paul Leach, and Luke Howard for their feedback on the federation terminology question.",
      "ja": "私たちは、彼らのフィードバックをMayutan Arumaithurai、クラースWierenga、およびリース・スミスに感謝したいと思います。さらに、当社は、フェデレーションの用語疑問に彼らのフィードバックのためにイブMALER、ニコラス・ウィリアムズ、ボブ・モーガン、スコット・カンター、ジム・フェントン、ポールリーチ、とルークハワードに感謝したいと思います。"
    },
    {
      "indent": 3,
      "text": "Furthermore, we would like to thank Klaas Wierenga for his review of the first draft version of this document. We also thank Eliot Lear for his work on early draft versions of this document.",
      "ja": "さらに、我々は、この文書の最初のドラフト版の彼のレビューのためにクラースWierengaに感謝したいと思います。また、このドキュメントの初期の草案に彼の仕事のためのエリオット・リアに感謝します。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Josh Howlett Jisc Lumen House, Library Avenue, Harwell Oxford OX11 0SG United Kingdom",
      "ja": "ジョシュ・ハウレットJISCルーメンハウス、図書館アベニュー、ハーウェルオックスフォードOX11 0SGイギリス"
    },
    {
      "indent": 3,
      "text": "Phone: +44 1235 822363 Email: Josh.Howlett@ja.net",
      "ja": "電話：+44 1235 822363 Eメール：Josh.Howlett@ja.net"
    },
    {
      "indent": 3,
      "text": "Sam Hartman Painless Security",
      "ja": "サム・ハートマン無痛セキュリティ"
    },
    {
      "indent": 3,
      "text": "Email: hartmans-ietf@mit.edu",
      "ja": "メール：hartmans-ietf@mit.edu"
    },
    {
      "indent": 3,
      "text": "Hannes Tschofenig ARM Ltd. 110 Fulbourn Road Cambridge CB1 9NJ United Kingdom",
      "ja": "ハンネスTschofenig ARM社110 Fulbourn道路ケンブリッジCB1 9NJイギリス"
    },
    {
      "indent": 3,
      "text": "Email: Hannes.tschofenig@gmx.net URI: http://www.tschofenig.priv.at",
      "ja": "メール：Hannes.tschofenig@gmx.net URI：http://www.tschofenig.priv.at"
    },
    {
      "indent": 3,
      "text": "Jim Schaad August Cellars",
      "ja": "ジムSchaad 8月セラーズ"
    },
    {
      "indent": 3,
      "text": "Email: ietf@augustcellars.com",
      "ja": "メール：ietf@augustcellars.com"
    }
  ]
}