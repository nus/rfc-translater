{
  "title": {
    "text": "RFC 7409 - Forwarding and Control Element Separation (ForCES) Packet Parallelization",
    "ja": "RFC 7409 - 転送と制御素子分離（のForCES）パケット並列"
  },
  "number": 7409,
  "created_at": "2019-11-01 18:27:51.756408+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                     E. Haleplidis\nRequest for Comments: 7409                          University of Patras\nCategory: Experimental                                        J. Halpern\nISSN: 2070-1721                                                 Ericsson\n                                                           November 2014",
      "raw": true
    },
    {
      "indent": 11,
      "text": "Forwarding and Control Element Separation (ForCES)\n              Packet Parallelization",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "Many network devices support parallel packet processing. This document describes how Forwarding and Control Element Separation (ForCES) can model a network device's parallelization datapath using constructs defined by the ForCES model (RFC 5812) and controlled via the ForCES protocol (RFC 5810).",
      "ja": "多くのネットワークデバイスは、パラレルパケット処理をサポートしています。この文書は、転送と制御素子分離（力が）構築物のForCESモデル（RFC 5812）で定義され、強制的プロトコル（RFC 5810）を介して制御を使用して、ネットワークデバイスの並列データ経路をモデル化する方法について説明します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for examination, experimental implementation, and evaluation.",
      "ja": "このドキュメントはインターネット標準化過程仕様ではありません。それは、検査、実験的な実装、および評価のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document defines an Experimental Protocol for the Internet community. This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are a candidate for any level of Internet Standard; see Section 2 of RFC 5741.",
      "ja": "この文書は、インターネットコミュニティのためにExperimentalプロトコルを定義します。このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。 IESGによって承認されていないすべての文書がインターネットStandardのどんなレベルの候補です。 RFC 5741のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7409.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7409で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2014 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2014 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   4\n  1.1.  Requirements Language . . . . . . . . . . . . . . . . . .   4\n  1.2.  Definitions . . . . . . . . . . . . . . . . . . . . . . .   4\n2.  Packet Parallelization  . . . . . . . . . . . . . . . . . . .   5\n  2.1.  CoreParallelization LFB . . . . . . . . . . . . . . . . .   7\n  2.2.  Parallelization Metadata  . . . . . . . . . . . . . . . .  10\n3.  Parallel Base Types . . . . . . . . . . . . . . . . . . . . .  11\n  3.1.  Frame Types . . . . . . . . . . . . . . . . . . . . . . .  11\n  3.2.  Data Types  . . . . . . . . . . . . . . . . . . . . . . .  11\n  3.3.  Metadata Types  . . . . . . . . . . . . . . . . . . . . .  12\n4.  Parallel LFBs . . . . . . . . . . . . . . . . . . . . . . . .  12\n  4.1.  Splitter  . . . . . . . . . . . . . . . . . . . . . . . .  12\n    4.1.1.  Data Handling . . . . . . . . . . . . . . . . . . . .  13\n    4.1.2.  Components  . . . . . . . . . . . . . . . . . . . . .  13\n    4.1.3.  Capabilities  . . . . . . . . . . . . . . . . . . . .  13\n    4.1.4.  Events  . . . . . . . . . . . . . . . . . . . . . . .  13\n  4.2.  Merger  . . . . . . . . . . . . . . . . . . . . . . . . .  14\n    4.2.1.  Data Handling . . . . . . . . . . . . . . . . . . . .  14\n    4.2.2.  Components  . . . . . . . . . . . . . . . . . . . . .  15\n    4.2.3.  Capabilities  . . . . . . . . . . . . . . . . . . . .  15\n    4.2.4.  Events  . . . . . . . . . . . . . . . . . . . . . . .  16\n  4.3.  CoreParallelization . . . . . . . . . . . . . . . . . . .  16\n    4.3.1.  Data Handling . . . . . . . . . . . . . . . . . . . .  16\n    4.3.2.  Components  . . . . . . . . . . . . . . . . . . . . .  16\n    4.3.3.  Capabilities  . . . . . . . . . . . . . . . . . . . .  16\n    4.3.4.  Events  . . . . . . . . . . . . . . . . . . . . . . .  17\n5.  XML for Parallel LFB Library  . . . . . . . . . . . . . . . .  17\n6.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  25\n  6.1.  LFB Class Names and LFB Class Identifiers . . . . . . . .  25\n  6.2.  Metadata ID . . . . . . . . . . . . . . . . . . . . . . .  26\n7.  Security Considerations . . . . . . . . . . . . . . . . . . .  26\n8.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  26\n  8.1.  Normative References  . . . . . . . . . . . . . . . . . .  26\n  8.2.  Informative References  . . . . . . . . . . . . . . . . .  27\nAcknowledgments   . . . . . . . . . . . . . . . . . . . . . . . .  27\nAuthors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  27",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "A lot of network devices can process packets in a parallel manner. The Forwarding and Control Element Separation (ForCES) model [RFC5812] presents a formal way to describe the Forwarding Plane's datapath with Logical Function Blocks (LFBs) using XML. This document describes how packet parallelization can be described with the ForCES model.",
      "ja": "ネットワークデバイスの多くは、並行してパケットを処理することができます。転送と制御素子分離（のForCES）モデル[RFC5812]はXMLを使用して、論理機能ブロック（LFBs）とフォワーディングプレーンのデータパスを記述するための正式な方法を提示しています。この文書では、パケットの並列化がのForCESモデルで記述できる方法を説明します。"
    },
    {
      "indent": 3,
      "text": "The modeling concept has been influenced by Cilk [Cilk]. Cilk is a programming language that has been in development since 1994 at the Massachusetts Institute of Technology (MIT) Laboratory. Cilk allows programmers to identify elements that can be executed in parallel. The two Cilk concepts used in this document are \"spawn\" and \"sync\": spawn being the place where parallel tasks can start and sync being the place where the parallel task finishes and must collect all parallel output (see Section 1.2 for the definitions of both \"task\" and \"task correclator\").",
      "ja": "モデリングの概念は[のCilk]のCilkの影響を受けてきました。インテル®Cilk™は、マサチューセッツ工科大学（MIT）研究所で1994年から開発が続けられているプログラミング言語です。 Cilkは、プログラマが並列に実行することができる要素を特定することを可能にします。この文書で使用される2つのCilkコンセプトは「卵」と「同期」している：卵は（の定義については、セクション1.2を参照してください並列タスクを開始することができますし、同期が並列タスクの終了場所であることと、すべてのパラレル出力を収集する必要があります場所であること「タスク」と「タスクcorreclator」）の両方。"
    },
    {
      "indent": 3,
      "text": "This document is Experimental; thus, the LFB Class IDs will not be included in the Standard Action's values. Therefore, the LFB Class IDs must have a value larger than 65535, and the LFB names must begin with the prefix 'Ext-'. However, for brevity, when we refer to the LFB Class names in the text of this document (not the formal definitions), the 'Ext-' prefix will be omitted.",
      "ja": "この文書では、実験的です。したがって、LFBクラスIDは、標準アクションの値に含まれません。したがって、LFBクラスIDは65535より大きい値を持たなければならない、とLFB名は、接頭辞「EXT-」で始まる必要があります。私たちは、この文書のテキスト内のLFBクラス名（ない正式な定義）を参照してくださいしかし、簡潔にするために、「EXT-」プレフィックスは省略されます。"
    },
    {
      "indent": 0,
      "text": "1.1. Requirements Language",
      "section_title": true,
      "ja": "1.1. 要件言語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はあります[RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "1.2. Definitions",
      "section_title": true,
      "ja": "1.2. 定義"
    },
    {
      "indent": 3,
      "text": "This document follows the terminology defined by the ForCES model in [RFC5812]. In particular, the reader is expected to be familiar with the following terms:",
      "ja": "この文書では、[RFC5812]の力モデルによって定義された用語を次の。具体的には、読者は以下の用語に精通していることが予想されます。"
    },
    {
      "indent": 6,
      "text": "FE",
      "ja": "で"
    },
    {
      "indent": 6,
      "text": "CE",
      "ja": "EC"
    },
    {
      "indent": 6,
      "text": "FE Model",
      "ja": "モデルでは"
    },
    {
      "indent": 6,
      "text": "LFB Class (or type)",
      "ja": "LFBクラス（またはタイプ）"
    },
    {
      "indent": 6,
      "text": "LFB Instance",
      "ja": "LFBインスタンス"
    },
    {
      "indent": 6,
      "text": "LFB Model",
      "ja": "LFBモデル"
    },
    {
      "indent": 6,
      "text": "Element",
      "ja": "素子"
    },
    {
      "indent": 6,
      "text": "Attribute",
      "ja": "属性"
    },
    {
      "indent": 6,
      "text": "LFB Metadata",
      "ja": "LFBメタデータ"
    },
    {
      "indent": 6,
      "text": "ForCES Component",
      "ja": "ForCESコンポーネント"
    },
    {
      "indent": 6,
      "text": "LFB Class Library",
      "ja": "LFBクラスライブラリ"
    },
    {
      "indent": 3,
      "text": "This document also introduces the following terms:",
      "ja": "また、このドキュメントでは、次の用語が導入されています。"
    },
    {
      "indent": 3,
      "text": "Chunk: Pieces of a packet.",
      "ja": "チャンク：パケットの小品。"
    },
    {
      "indent": 3,
      "text": "Task: Grouping of packets or chunks belonging to the same packet that are processed in parallel.",
      "ja": "タスク並列に処理される同じパケットに属するパケット又はチャンクのグループ化。"
    },
    {
      "indent": 3,
      "text": "Task Correlator: A 32-bit identifier that uniquely distinguishes tasks.",
      "ja": "タスク相関一意のタスクを識別する32ビットの識別子。"
    },
    {
      "indent": 3,
      "text": "Split Type: A parallel type where the packets are split into chunks to be processed in parallel. Each task in a split type is composed only of chunks.",
      "ja": "スプリット型：パケットが並列に処理されるチャンクに分割される並列型。分割型の各タスクは、唯一の塊で構成されています。"
    },
    {
      "indent": 3,
      "text": "Flood Type: A parallel type where the packets are copied as-is to downstream LFBs to be processed in parallel. Each task in a flood type is composed only of packets.",
      "ja": "フラッド型：並行して処理される下流LFBsにそのままパケットがコピーされる並列型。洪水のタイプの各タスクは、パケットのみで構成されています。"
    },
    {
      "indent": 0,
      "text": "2. Packet Parallelization",
      "section_title": true,
      "ja": "2.パケット並列化"
    },
    {
      "indent": 3,
      "text": "This document addresses the following two types of packet parallelization:",
      "ja": "この文書では、パケットの並列化には、次の2種類に対処します。"
    },
    {
      "indent": 3,
      "text": "1. Flood: Where a copy of a packet is sent to multiple LFBs to be processed in parallel.",
      "ja": "1.洪水：パケットのコピーを並列に処理されるように、複数のLFBsに送信されます。"
    },
    {
      "indent": 3,
      "text": "2. Split: Where the packet will be split into chunks of equal size specified by the CE and sent to multiple LFB instances, probably of the same LFB class, to be processed in parallel.",
      "ja": "2.スプリット：パケットはCEによって指定された、複数のLFBインスタンスに送信された同じサイズのチャンクに分割され、おそらく同じLFBクラスの、並列に処理されます。"
    },
    {
      "indent": 3,
      "text": "It must be noted that the process of copying the packet in the flood parallel type is implementation dependent and is loosely defined here. An implementer may either decide to physically copy the packet and send all packets on the parallel paths or decide to logically copy the packet by simply sending, for example, pointers to the same packet provided that the necessary interlocks are taken into account. The implementer has to take into account the device's characteristics to decide which approach fits best to the device.",
      "ja": "洪水並列型にパケットをコピーする処理は実装依存であると緩くここで定義されていることに留意しなければなりません。実装者は、物理的にパケットをコピーして、並列経路上のすべてのパケットを送信したり、論理的に単純例えば、送信することにより、パケットをコピーすることを決定するように決定することができるのいずれか、同じパケットへのポインタが必要なインターロックが考慮されていることを条件とします。実装者は、デバイスに最もフィットするアプローチを決定するために考慮に入れ、デバイスの特性を取ることがあります。"
    },
    {
      "indent": 3,
      "text": "In the split parallel type, while harder, the implementer may also decide to logically split the packet and send, for example, pointers to parts of the packet, provided that the necessary interlocks are managed. In addition, how chunks are distributed to the LFBs (e.g., which chunk to which LFB) is implementation dependent. For example, while usually chunks are sent to the same LFB class, the number of LFB instances may not be equal to the number of chunks. It is up to the implementer to decide how these chunks will be sent, for example, in a round-robin fashion.",
      "ja": "分割並列型では、硬い、実装はまた、論理的にパケットを分割して送信することを決定することができるが、例えば、パケットの部分へのポインタは、必要に応じてインターロックが管理されていることを条件とします。加えて、どのチャンクが（例えば、チャンクLFBに）LFBsに配布されることは実装依存です。通常チャンクが同じLFBクラスに送られている間、例えば、LFBインスタンスの数はチャンクの数に等しくなくてもよいです。これは、これらのチャンクはラウンドロビン方式で、例えば、送信されます方法を決定するために実装次第です。"
    },
    {
      "indent": 3,
      "text": "This document introduces two LFBs that are used before and after the parallelization occurs:",
      "ja": "この文書では、並列化が発生する前と後に使用される2つのLFBsが導入されています。"
    },
    {
      "indent": 3,
      "text": "1. Splitter: Similar to Cilk's spawn, a splitter is an LFB that will split the path of a packet that will be sent to multiple downstream LFBs to be processed in parallel.",
      "ja": "1.スプリッタ：のCilkの産卵と同様に、スプリッタを並列に処理する複数の下流LFBsに送信されるパケットの経路を分割しますLFBあります。"
    },
    {
      "indent": 3,
      "text": "2. Merger: Similar to Cilk's sync, a merger is an LFB that will receive packets or chunks of the same initial packet and merge them and the results into one packet.",
      "ja": "2.合併：インテル®Cilk™の同期と同様に、合併は、同じ初期パケットのパケットまたはチャンクを受信して​​1つのパケットにそれらと結果をマージしますLFBです。"
    },
    {
      "indent": 3,
      "text": "Both parallel packet distribution types can currently be achieved with the ForCES model. The Splitter LFB has one group output that produces either chunks or packets to be sent to LFBs for processing, and the Merger LFB has one group input that expects either packets or chunks to aggregate all the parallel packets or chunks and produce a single packet.",
      "ja": "両方のパラレルパケット配布タイプは、現在のForCESモデルで達成することができます。スプリッタLFBは、処理のためLFBsに送信されるチャンク又はパケットのいずれかを生成し、合併LFBパケット又はチャンクのいずれかがすべて平行パケット又はチャンクを集約し、単一のパケットを生成することを期待1つのグループの入力を有する1つのグループの出力を有します。"
    },
    {
      "indent": 3,
      "text": "Figure 1 shows a simple example of a split parallel datapath along with the Splitter and Merger LFB. The example in Figure 1 depicts multiple regular expression (regex) match LFBs that perform match operations on parts of the original packet. Figure 2 shows an example of a flood parallel datapath along with the Splitter and Merger LFB. The example in Figure 2 depicts a path that will classify an IPv4 packet while also performing metering; on the other path, the IPv4 Time to Live (TTL) field will be decremented.",
      "ja": "図1は、スプリッタと合併LFBと共に分割並列データ経路の簡単な例を示しています。図1の例では、元のパケットの部分にマッチ操作を実行する複数の正規表現（regex）マッチLFBsを示します。図2は、スプリッタと合併LFBと共に洪水パラレルデータパスの一例を示しています。図2の例では、計量を行いながら、IPv4パケットを分類するパスを示す図です。他のパスで、ライブするIPv4の時間（TTL）フィールドがデクリメントされます。"
    },
    {
      "indent": 4,
      "text": "                  C1+M   +------------+  C1+M\n                   +---->| Regex LFB  |----+\n    +----------+   |     +------------+    |       +----------+\n    |          |---+                       +------>|          |\n P  |          |  C2+M   +------------+  C2+M      |          | P\n--->| Splitter |-------->| Regex LFB  |----------->|  Merger  |--->\n    |   LFB    |  CN+M   +------------+  CN+M      |   LFB    |\n    |          |---+                       +------>|          |\n    +----------+   |     +------------+    |       +----------+\n                   +---->| Regex LFB  |----+\n                         +------------+",
      "raw": true
    },
    {
      "indent": 16,
      "text": "Figure 1: Simple Split Parallel Processing",
      "ja": "図1：単純な分割並列処理"
    },
    {
      "indent": 4,
      "text": "    +----------+    +------------+    +-------+    +----------+\n    |          |P+M | Classifier |P+M | Meter |P+M |          |\n P  |          |--->|     LFB    |--->|  LFB  |--->|          | P\n--->| Splitter |    +------------+    +-------+    |  Merger  |--->\n    |   LFB    |                                   |   LFB    |\n    |          |P+M       +------------+       P+M |          |\n    |          |--------->|  IPv4 TTL  |---------->|          |\n    +----------+          |  Decrement |           +----------+\n                          |    LFB     |\n                          +------------+",
      "raw": true
    },
    {
      "indent": 16,
      "text": "Figure 2: Simple Flood Parallel Processing",
      "ja": "図2：シンプルな洪水並列処理"
    },
    {
      "indent": 3,
      "text": "This version of the modeling framework does not allow for nested parallel datapath topologies. This decision was reached by the authors and the ForCES working group, as there was no strong use case or need at decision time. This led to a simpler metadata definition, which is required to be transported between the splitter and the corresponding merger. If there is a need for nested parallel datapaths, a new version of a splitter and merger will need to be defined, as well as an augmentation to the defined metadata.",
      "ja": "モデリングフレームワークのこのバージョンは、ネストされた並列データパストポロジを許可しません。意思決定時に強いユースケースや必要性がなかったため、この決定は、著者とワーキンググループの力によって達成されました。これは、スプリッタと、対応する合併間で輸送する必要がある単純なメタデータの定義、につながりました。ネストされたパラレルデータパスの必要がある場合、スプリッタと合併の新しいバージョンを定義する必要があるだけでなく、定義されたメタデータへの増強されます。"
    },
    {
      "indent": 0,
      "text": "2.1. CoreParallelization LFB",
      "section_title": true,
      "ja": "2.1.  CoreParallelization LFB"
    },
    {
      "indent": 3,
      "text": "One important element to a developer is the ability to define which LFBs can be used in a parallel mode, which LFBs can be parallelized with which, as well as the order in which parallel LFBs can be assembled.",
      "ja": "開発者に一つの重要な要素はLFBsはれる並列化できるパラレルモード、ならびに平行LFBsを組み立てることができる順序で使用することができるLFBs定義する能力です。"
    },
    {
      "indent": 3,
      "text": "To access the parallelization details, we opted for defining a new LFB class: the CoreParallelization LFB. This choice was an alternative to making another change to the core FEObject LFB. The CoreParallelization exists merely to define the capabilities for an FE's LFB parallelization. A CE using the ForCES protocol [RFC5810]",
      "ja": "CoreParallelization LFBを：並列化の詳細にアクセスするために、我々は新しいLFBクラスを定義するために選びました。この選択は、コアFEObject LFBに別の変更を行うに代わるものでした。 CoreParallelizationは、FEのLFBの並列化のための機能を定義するためだけに存在します。 ForCESプロトコル[RFC5810]を使用して、CE"
    },
    {
      "indent": 3,
      "text": "can check the existence of this LFB class in the FEObject's SupportedLFBs component. The existence of the CoreParallelization LFB will indicate to the CE that the specific FE supports parallelization. There MUST be only one instance of the CoreParallelization LFB per FE.",
      "ja": "FEObjectのSupportedLFBsコンポーネントでこのLFBクラスの存在を確認することができます。 CoreParallelization LFBの存在は、特定のFEは、並列化をサポートしてCEに指示します。 CoreParallelization LFBあたりFEのインスタンスは1つだけでなければなりません。"
    },
    {
      "indent": 3,
      "text": "The topology of the parallel datapath can be deferred and manipulated from the FEObject LFB's LFBTopology.",
      "ja": "並列データ経路のトポロジーは延期とFEObject LFBのLFBTopologyから操作することができます。"
    },
    {
      "indent": 3,
      "text": "The CoreParallelization requires only one capability in order to specify each LFB that can be used in a parallel mode:",
      "ja": "CoreParallelizationはパラレルモードで使用することができ、各LFBを指定するために一つだけの能力を必要とします。"
    },
    {
      "indent": 3,
      "text": "o The Name of the LFB.",
      "ja": "LFBの名前O。"
    },
    {
      "indent": 3,
      "text": "o The Class ID of the LFB.",
      "ja": "LFBのクラスID、O。"
    },
    {
      "indent": 3,
      "text": "o The Version of the LFB.",
      "ja": "LFBのバージョンO。"
    },
    {
      "indent": 3,
      "text": "o The number of instances that class can support in parallel.",
      "ja": "クラスが並列にサポートすることができるインスタンスの数、O。"
    },
    {
      "indent": 3,
      "text": "o A list of LFB classes that can follow this LFB class in a pipeline for a parallel path.",
      "ja": "パラレルパスのパイプラインでこのLFBクラスに従うことができるLFBクラスのリストO。"
    },
    {
      "indent": 3,
      "text": "o A list of LFB classes that can exist before this LFB class in a pipeline for a parallel path.",
      "ja": "パラレルパスのためにパイプラインでこのLFBクラスの前に存在することができるLFBクラスのリストO。"
    },
    {
      "indent": 3,
      "text": "o A list of LFB classes that can process packets or chunks in parallel with this LFB class.",
      "ja": "このLFBクラスと並行してパケット又はチャンクを処理することができるLFBクラスのリストO。"
    },
    {
      "indent": 6,
      "text": "<!-- Datatype --> <dataTypeDef> <name>ParallelLFBType</name> <synopsis>Table entry for parallel LFBs</synopsis> <struct> <component componentID=\"1\"> <name>LFBName</name> <synopsis>The name of an LFB Class</synopsis> <typeRef>string</typeRef> </component> <component componentID=\"2\"> <name>LFBClassID</name> <synopsis>The id of the LFB Class</synopsis> <typeRef>uint32</typeRef> </component> <component componentID=\"3\"> <name>LFBVersion</name> <synopsis>The version of the LFB Class used by this FE </synopsis>",
      "ja": "<！ - データ型 - > <dataTypeDef> <名前> ParallelLFBType </名前> <概要>平行LFBs表エントリ</シノプシス> <構造体> <コンポーネントのComponentID = \"1\"> <名前> LFBName </名前> <概要> LFBクラスの名前</シノプシス> <typeRef>列</ typeRef> </コンポーネント> <コンポーネントのComponentID = \"2\"> <名前> LFBClassID </名前> <概要> LFBクラスのID </シノプシス> <typeRef> UINT32 </ typeRef> </コンポーネント> <コンポーネントのComponentID = \"3\"> <名前> LFBVersion </名前> <概要>このFE </概要>で使用LFBクラスのバージョン"
    },
    {
      "indent": 6,
      "text": " <typeRef>string</typeRef> </component> <component componentID=\"4\"> <name>LFBParallelOccurrenceLimit</name> <synopsis>The upper limit of instances of the same parallel LFBs of this class</synopsis> <optional /> <typeRef>uint32</typeRef> </component> <component componentID=\"5\"> <name>AllowedParallelAfters</name> <synopsis>List of LFB Classes that can follow this LFB in a parallel pipeline</synopsis> <optional /> <array> <typeRef>uint32</typeRef> </array> </component> <component componentID=\"6\"> <name>AllowedParallelBefores</name> <synopsis>List of LFB Classes that this LFB class can follow in a parallel pipeline</synopsis> <optional /> <array> <typeRef>uint32</typeRef> </array> </component> <component componentID=\"7\"> <name>AllowedParallel</name> <synopsis>List of LFB Classes that this LFB class can run in parallel with</synopsis> <array> <typeRef>uint32</typeRef> </array> </component> </struct> </dataTypeDef>",
      "ja": "<typeRef>列</ typeRef> </コンポーネント> <コンポーネントのComponentID = \"4\"> <名前> LFBParallelOccurrenceLimit </名前> <概要>このクラスの同じ平行LFBs </シノプシス> <任意のインスタンスの上限/> <typeRef> UINT32 </ typeRef> </コンポーネント> <コンポーネントのComponentID = \"5\"> <名前> AllowedParallelAfters </名前> <概要>並列パイプラインでこのLFBに従うことができるLFBクラスの一覧</概要> <オプション/> <配列> <typeRef> UINT32 </ typeRef> </アレイ> </コンポーネント> <コンポーネントのComponentID = \"6\"> <名前> AllowedParallelBefores </名前> <概要> LFBクラスのリスト、このLFBクラス並列パイプラインに追従することができる</シノプシス> <オプション/> <配列> <typeRef> UINT32 </ typeRef> </アレイ> </コンポーネント> <コンポーネントのComponentID = \"7\"> <名前> AllowedParallel </名前> <このLFBクラスが</概要> <配列> <typeRef> UINT32 </ typeRef> </アレイ> </成分> </構造体> </ dataTypeDefと並行して実行することができLFBクラスの概要>一覧>"
    },
    {
      "indent": 6,
      "text": "<!-- Capability --> <capability componentID=\"32\"> <name>ParallelLFBs</name> <synopsis>List of all supported parallel LFBs</synopsis> <array type=\"Variable-size\"> <typeRef>ParallelLFBType</typeRef> </array> </capability>",
      "ja": "<！ - 能力 - > <機能COMPONENTID = \"32\"> <名前> ParallelLFBs </名前> <概要>サポートされているすべての並列LFBsの一覧</概要> <配列タイプ= \"可変サイズ\"> <typeRef> ParallelLFBType </ typeRef> </配列> </機能>"
    },
    {
      "indent": 11,
      "text": "Figure 3: XML Definitions for CoreParallelization LFB",
      "ja": "図3：CoreParallelization LFBのためのXML定義"
    },
    {
      "indent": 0,
      "text": "2.2. Parallelization Metadata",
      "section_title": true,
      "ja": "2.2. 並列化メタデータ"
    },
    {
      "indent": 3,
      "text": "It is expected that the splitting and merging mechanisms are an implementation issue. This document plays the role of defining the operational parameters for the splitting and merging: namely, the size of the chunks, what happens if a packet or chunk has been marked as invalid, and whether the merge LFB should wait for all packets or chunks to arrive. The following metadata set is defined as a struct:",
      "ja": "分割とマージのメカニズムは、実装の問題であることを期待されています。この文書では、分割のための動作パラメータを定義し、マージの役割を果たしている。すなわち、パケットまたはチャンクは無効としてマークされている場合、およびマージLFBは、すべてのパケットまたはチャンクのを待つべきか、何が起こるかチャンクの大きさ、到着しました。次のメタデータセットは、構造体として定義されます。"
    },
    {
      "indent": 3,
      "text": "1. ParallelType - Flood or split",
      "section_title": true,
      "ja": "1. ParallelType  - 洪水または分割"
    },
    {
      "indent": 3,
      "text": "2. TaskCorrelator - Identify packets or chunks that belonged to the initial packet that entered the Splitter LFB",
      "ja": "2. TaskCorrelator  - スプリッタLFBに入った最初のパケットに属していたパケットまたはチャンクを特定します"
    },
    {
      "indent": 3,
      "text": "3. ParallelNum - Sequence number of the packet or the chunk for a specific task",
      "ja": "3. ParallelNum  - シーケンスパケットの数や特定のタスクのためのチャンク"
    },
    {
      "indent": 3,
      "text": "4. ParallelPartsCount - Total number of packets or chunks for a specific task",
      "ja": "4. ParallelPartsCount  - 特定のタスクのためのパケットまたはチャンクの総数"
    },
    {
      "indent": 3,
      "text": "This metadata is produced from the Splitter LFB, is opaque to LFBs in parallel paths, and is passed along to the Merger LFB without being consumed.",
      "ja": "このメタデータは、スプリッタLFBから製造され、並列経路におけるLFBsに対して不透明であり、そして消費されず合併LFBに渡されます。"
    },
    {
      "indent": 3,
      "text": "In the case in which an LFB decides that a packet/chunk has to be dropped, the LFB MAY drop the packet/chunk, but the metadata MUST be sent to the Merger LFB's InvalidIn input port for merging purposes.",
      "ja": "LFBは、パケット/チャンクがドロップする必要があると判断した場合には、LFBは、パケット/チャンクを落とすかもしれないが、メタデータは目的をマージするための合併LFBのInvalidIn入力ポートに送らなければなりません。"
    },
    {
      "indent": 3,
      "text": "Additional metadata produced by LFBs inside a datapath MAY be aggregated within the Merger LFB and sent on after the merging process. In case of receiving the same metadata definition with multiple values, the Merger LFB MUST keep the first received from a valid packet or chunk.",
      "ja": "データパス内のLFBsによって産生さ追加のメタデータは、合併LFB内凝集とマージ処理の後で送信されても​​よいです。複数の値を持つ同一のメタデータ定義を受信した場合に、合併LFBは、有効なパケットまたはチャンクから受信した第一保持しなければなりません。"
    },
    {
      "indent": 0,
      "text": "3. Parallel Base Types",
      "section_title": true,
      "ja": "3.パラレル基本型"
    },
    {
      "indent": 0,
      "text": "3.1. Frame Types",
      "section_title": true,
      "ja": "3.1. フレームタイプ"
    },
    {
      "indent": 3,
      "text": "One frame type has been defined in this library.",
      "ja": "一つのフレームタイプは、このライブラリで定義されています。"
    },
    {
      "indent": 3,
      "text": "+-----------+-------------------------------------------------------+\n| Frame     | Synopsis                                              |\n| Name      |                                                       |\n+-----------+-------------------------------------------------------+\n| Chunk     | A chunk is a frame that is part of an original larger |\n|           | frame.                                                |\n+-----------+-------------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 27,
      "text": "Parallel Frame Types",
      "ja": "パラレルフレームタイプ"
    },
    {
      "indent": 0,
      "text": "3.2. Data Types",
      "section_title": true,
      "ja": "3.2. データの種類"
    },
    {
      "indent": 3,
      "text": "One data type has been defined in this library.",
      "ja": "一つのデータ型は、このライブラリで定義されています。"
    },
    {
      "indent": 3,
      "text": "+---------------+------------------------+--------------------------+\n| DataType Name | Type                   | Synopsis                 |\n+---------------+------------------------+--------------------------+\n| ParallelTypes | Atomic uchar.  Special | The type of              |\n|               | Values Flood (0),      | parallelization this     |\n|               | Split (1).             | packet will go through.  |\n+---------------+------------------------+--------------------------+",
      "raw": true
    },
    {
      "indent": 28,
      "text": "Parallel Data Types",
      "ja": "パラレル・データ・タイプ"
    },
    {
      "indent": 0,
      "text": "3.3. Metadata Types",
      "section_title": true,
      "ja": "3.3. メタデータの種類"
    },
    {
      "indent": 3,
      "text": "The following metadata structure with ID 16, using the ForCES model extension [RFC7408], is defined for the parallelization library:",
      "ja": "ForCESモデル拡張[RFC7408]を使用して、ID 16と次のメタデータ構造が、並列化ライブラリーのために定義されます。"
    },
    {
      "indent": 3,
      "text": "+--------------------+--------+----+--------------------------------+\n|   Metadata Name    |  Type  | ID |            Synopsis            |\n+--------------------+--------+----+--------------------------------+\n|    ParallelType    | uchar  | 1  |  The type of parallelization   |\n|                    |        |    | this packet will go through. 0 |\n|                    |        |    |    for flood, 1 for split.     |\n|                    |        |    |                                |\n|   TaskCorrelator   | uint32 | 2  |  An identification number to   |\n|                    |        |    |   specify that a packet or a   |\n|                    |        |    |   chunk belongs to the same    |\n|                    |        |    |         parallel task.         |\n|                    |        |    |                                |\n|    ParallelNum     | uint32 | 3  |    Defines the number of a     |\n|                    |        |    | specific packet or chunk of a  |\n|                    |        |    |         specific task.         |\n|                    |        |    |                                |\n| ParallelPartsCount | uint32 | 4  |  Defines the total number of   |\n|                    |        |    |    packets or chunks for a     |\n|                    |        |    |         specific task.         |\n+--------------------+--------+----+--------------------------------+",
      "raw": true
    },
    {
      "indent": 22,
      "text": "Metadata Structure for Merging",
      "ja": "マージのためのメタデータ構造"
    },
    {
      "indent": 0,
      "text": "4. Parallel LFBs",
      "section_title": true,
      "ja": "4.パラレルLFBs"
    },
    {
      "indent": 0,
      "text": "4.1. Splitter",
      "section_title": true,
      "ja": "4.1. スプリッタ"
    },
    {
      "indent": 3,
      "text": "The Splitter LFB takes part in parallelizing the processing datapath by sending either the same packet (Figure 2) or chunks (Figure 1) of the same packet to multiple LFBs.",
      "ja": "スプリッタLFBは複数LFBsに同一のパケット（図2）または同じパケットのチャンク（図1）のいずれかを送信することによって、処理データパスを並列に関与します。"
    },
    {
      "indent": 18,
      "text": "           +---------------+\nSplitterIn |               | SplitterOut\n---------->| Splitter LFB  |------------->\n           |               |\n           +---------------+",
      "raw": true
    },
    {
      "indent": 26,
      "text": "Figure 4: Splitter LFB",
      "ja": "図4：スプリッタLFB"
    },
    {
      "indent": 0,
      "text": "4.1.1. Data Handling",
      "section_title": true,
      "ja": "4.1.1. データ処理"
    },
    {
      "indent": 3,
      "text": "The Splitter LFB receives any kind of packet via the singleton input, Input. Depending upon the CE's configuration of the ParallelType component, if the parallel type is of type flood (0), the same packet MUST be sent through all instances of the group output \"SplitterOut\". If the parallel type is of type split (1), then the packet will be split into same size chunks except for the last, which MAY be smaller, with the max size being defined by the ChunkSize component. Chunks MAY be sent out in a round-robin fashion through instances of the group output \"ParallelOut\" or in any other way defined by the implementer. Each packet or chunk will be accompanied by the following metadata set as a struct:",
      "ja": "スプリッタLFBはシングルトンの入力、入力を介してパケットのいずれかの種類を受けます。平行型が型洪水（0）である場合、ParallelType成分のCEの構成に応じて、同じパケットは、グループ出力「SplitterOut」のすべてのインスタンスを介して送信されなければなりません。平行型が型スプリット（1）である場合、パケットは、最大サイズはチャンク・サイズ・コンポーネントによって定義された状態で、小さくてもよい最後を除いて同じサイズのチャンクに分割されます。チャンクはグループ出力「ParallelOut」のインスタンスを介して、または実装で定義された他の方法でラウンドロビン方式で送信されるかもしれません。各パケットまたはチャンクは、構造体として設定し、次のメタデータが添付されます。"
    },
    {
      "indent": 3,
      "text": "o ParallelType - The parallel type: split or flood.",
      "ja": "O ParallelType  - パラレルタイプ：スプリットや洪水。"
    },
    {
      "indent": 3,
      "text": "o ParallelID - Generated by the Splitter LFB to identify which chunks or packets belong to the same parallel task.",
      "ja": "ParallelID o  - で同じパラレルタスクに属するチャンクまたはパケット識別するためにスプリッタLFBによって生成。"
    },
    {
      "indent": 3,
      "text": "o ParallelNum - Each chunk or packet of a parallel ID will be assigned a number in order for the Merger LFB to know when it has gathered them all along with the ParallelPartsCount metadata.",
      "ja": "O ParallelNum  - 並列IDの各チャンクまたはパケットは、それがParallelPartsCountメタデータと一緒にそれらをすべて集めたとき、合併LFBが知っているようにするために番号が割り当てられます。"
    },
    {
      "indent": 3,
      "text": "o ParallelPartsCount - The number of chunks or packets for the specific task.",
      "ja": "O ParallelPartsCount  - 特定のタスクのためのチャンクまたはパケットの数。"
    },
    {
      "indent": 0,
      "text": "4.1.2. Components",
      "section_title": true,
      "ja": "4.1.2. コンポーネント"
    },
    {
      "indent": 3,
      "text": "The Splitter LFB has only two components. The first is the ParallelType, a uint32 that defines how the packet will be processed by the Splitter LFB. The second is the ChunkSize, a uint32 that specifies the size of each chunk when a packet is split into multiple same-size chunks. The last chunk MAY be smaller than the value of the ChunkSize.",
      "ja": "スプリッタLFBは、2つの成分のみを持っています。最初はParallelType、パケットをスプリッタLFBによって処理される方法を定義UINT32です。第二は、チャンク・サイズ、パケットが複数の同じサイズのチャンクに分割され、各チャンクのサイズを指定UINT32です。最後のチャンクは、チャンク・サイズの値よりも小さくてもよいです。"
    },
    {
      "indent": 0,
      "text": "4.1.3. Capabilities",
      "section_title": true,
      "ja": "4.1.3. 機能"
    },
    {
      "indent": 3,
      "text": "This LFB has only one capability specified; the MinMaxChunkSize is a struct of two uint32s to specify the minimum and maximum chunk size.",
      "ja": "このLFBは、指定された一つだけの能力を持っています。 MinMaxChunkSize最小及び最大チャンクサイズを指定するための2つのuint32sの構造体です。"
    },
    {
      "indent": 0,
      "text": "4.1.4. Events",
      "section_title": true,
      "ja": "4.1.4. イベント"
    },
    {
      "indent": 3,
      "text": "This LFB has no events specified.",
      "ja": "このLFBは、指定したイベントがありません。"
    },
    {
      "indent": 0,
      "text": "4.2. Merger",
      "section_title": true,
      "ja": "4.2. 合併"
    },
    {
      "indent": 3,
      "text": "The Merger LFB is the synchronization point for multiple packets or packet chunks of the same task emanating out of the parallel path, as illustrated in Figure 1 and Figure 2.",
      "ja": "図1および図2に示すように合併LFBは、複数のパケットまたは並列経路から発せられる同じタスクのパケットチャンクの同期点です。"
    },
    {
      "indent": 21,
      "text": "          +-------------+\n MergerIn |             |\n--------->|             | MergerOut\n          | Merger LFB  |----------->\nInvalidIn |             |\n--------->|             |\n          +-------------+",
      "raw": true
    },
    {
      "indent": 27,
      "text": "Figure 5: Merger LFB",
      "ja": "図5：合併LFB"
    },
    {
      "indent": 0,
      "text": "4.2.1. Data Handling",
      "section_title": true,
      "ja": "4.2.1. データ処理"
    },
    {
      "indent": 3,
      "text": "The Merger LFB receives either a packet or a chunk via the group input ParallelIn, along with the ParallelType metadata, the TaskCorrelator, the ParallelNum, and the ParallelPartsCount.",
      "ja": "合併LFBはParallelTypeメタデータ、TaskCorrelator、ParallelNum、及びParallelPartsCountと共に、グループ入力ParallelIn介してパケット又はチャンクのいずれかを受信します。"
    },
    {
      "indent": 3,
      "text": "In the case in which an upstream LFB has dropped a packet or a chunk, the Merger LFB MAY receive only the metadata, both the metadata and the packet, or the chunk through the InvalidIn group input port. It SHOULD receive a metadata specifying the error code. Currently defined metadata in the Base LFB Library [RFC6956] are the ExceptionID and the ValidateErrorID.",
      "ja": "上流LFBパケット又はチャンクを落とした場合には、合併LFBはInvalidIn基入力ポートを介して両方のメタデータとパケット、またはチャンク、メタデータのみを受信することができます。これは、エラーコードを指定するメタデータを受信する必要があります。ベースLFB図書館[RFC6956]で現在定義されているメタデータはExceptionIDとValidateErrorIDです。"
    },
    {
      "indent": 3,
      "text": "If the MergeWaitType is set to false, the Merger LFB will initiate the merge process upon receiving the first packet. If false, for each task identified by the task correlator, it will wait for all packets/chunks to arrive unless the MergeWaitTimeoutTimer timer expires. If the MergeWaitTimeoutTimer has expired, the Merger MUST consider the rest of the packets/chunks that have not been received as invalid, and it MUST handle the packets according to the InvalidAction value.",
      "ja": "MergeWaitTypeがfalseに設定されている場合は、合併LFBは、最初のパケットを受信すると、マージプロセスを開始します。 falseの場合、タスクの相関器によって識別された各タスクのために、それはMergeWaitTimeoutTimerタイマーが満了しない限り、到着するすべてのパケット/チャンクを待ちます。 MergeWaitTimeoutTimerの有効期限が切れている場合は、合併は無効として受信されていないパケット/チャンクの残りの部分を考慮しなければならない、そしてそれはInvalidAction値に従ってパケットを処理する必要があります。"
    },
    {
      "indent": 3,
      "text": "If one packet or chunk has been received through the InvalidIn port, then the merging procedure will handle the packets/chunks according to the InvalidAction value. If the InvalidAction component has been set to 0, then if one packet or chunk is not valid, all will be dropped or else the process will initiate. Once the merging process has been completed, the resulting packet will be sent via the singleton output port MergerOut.",
      "ja": "一つのパケット又はチャンクがInvalidInポートを介して受信された場合、マージ手順はInvalidAction値に従ってパケット/チャンクを処理します。 InvalidActionコンポーネントが0に設定されている場合は、1つのパケットまたはチャンクが有効でない場合、すべてが削除されますか、他のプロセスが開始されます。マージ処理が完了すると、結果のパケットは、シングルトン出力ポートMergerOutを経由して送信されます。"
    },
    {
      "indent": 3,
      "text": "If the Merger LFB receives different values for the same metadata from different packets or chunks that have the same task correlator, then the Merger LFB will use the first metadata from a packet or chunk that entered the LFB through the MergerIn input port.",
      "ja": "合併LFBが同じタスク相関を有する異なるパケット又はチャンクからの同じメタデータのための異なる値を受信した場合、その後の合併LFBはMergerIn入力ポートを介してLFBに入ったパケット又はチャンクから第1のメタデータを使用します。"
    },
    {
      "indent": 0,
      "text": "4.2.2. Components",
      "section_title": true,
      "ja": "4.2.2. コンポーネント"
    },
    {
      "indent": 3,
      "text": "This LFB has the following components specified:",
      "ja": "このLFBは、指定された次のコンポーネントがあります。"
    },
    {
      "indent": 3,
      "text": "1. InvalidAction: A uchar defining what the Merge LFB will do if an invalid chunk or packet is received. If set to 0 (DropAll), the merge will be considered invalid and all chunks or packets will be dropped. If set to 1 (Continue), the merge will continue.",
      "ja": "1. InvalidAction：無効なチャンクまたはパケットを受信した場合、マージLFBが何をするかを定義UCHAR。 0（DropAll）に設定した場合、マージは無効とみなされ、すべてのチャンクまたはパケットはドロップされます。 1（続行）に設定した場合、マージは継続されます。"
    },
    {
      "indent": 3,
      "text": "2. MergeWaitTimeoutTimer: A uint32 defining the amount of time, in milliseconds, that the Merger will wait for all packets or chunks within the same task to arrive before considering them invalid. The MergeWaitTimeoutTimer starts as soon as the first chunk or packet of a parallel task arrives.",
      "ja": "2. MergeWaitTimeoutTimer：合併がそれらを無効検討する前に到着するために、同じタスク内のすべてのパケットまたはチャンクを待機する時間をミリ秒単位で定義するUINT32。 MergeWaitTimeoutTimerはすぐ並列タスクの最初のチャンクまたはパケットが到着すると起動します。"
    },
    {
      "indent": 3,
      "text": "3. MergeWaitType: A boolean. If true, the Merger LFB will wait for all packets or chunks to be received prior to performing the merge. If false, when one packet or a chunk with a response is received by the merge LFB, it will start with the merge process.",
      "ja": "3. MergeWaitType：ブール。 trueの場合、すべてのパケットまたはチャンクがマージを実行する前に受信されるため、合併LFBをお待ちしております。 falseの場合、1つのパケットまたは応答でチャンクがマージLFBによって受信されたとき、それはマージプロセスを開始します。"
    },
    {
      "indent": 3,
      "text": "4. InvalidMergesCounter: A uint32 that counts the number of merges where there is at least one packet or chunk that entered the Merger LFB through the InvalidIn input port.",
      "ja": "4. InvalidMergesCounter：InvalidIn入力ポートを介して合併LFBに入った少なくとも1つのパケット又はチャンクが存在するマージの数をカウントUINT32。"
    },
    {
      "indent": 3,
      "text": "5. InvalidTotalCounter: A uint32 that counts the number of merges where all packets/chunks entered the Merger LFB through the InvalidIn input port.",
      "ja": "5. InvalidTotalCounter：すべてのパケット/チャンクがInvalidIn入力ポートを介して合併LFBに入ったマージの数をカウントUINT32。"
    },
    {
      "indent": 3,
      "text": "6. InvalidIDCounters: A struct of two arrays. Each array has a uint32 per row. Each array counts the number of invalid merges where at least one packet or chunk entered through InvalidID per error ID. The first array is the InvalidExceptionID and the second is the InvalidValidateErrorID.",
      "ja": "6. InvalidIDCounters：2つの配列の構造体。各アレイは、行ごとにUINT32を有しています。各アレイは、少なくとも1つのパケットまたはチャンクがエラーIDごとInvalidIDから入力された無効なマージの数をカウントします。最初の配列はInvalidExceptionIDであり、第二はInvalidValidateErrorIDあります。"
    },
    {
      "indent": 0,
      "text": "4.2.3. Capabilities",
      "section_title": true,
      "ja": "4.2.3. 機能"
    },
    {
      "indent": 3,
      "text": "This LFB has no capabilities specified.",
      "ja": "このLFBは指定されていない機能を持っていません。"
    },
    {
      "indent": 0,
      "text": "4.2.4. Events",
      "section_title": true,
      "ja": "4.2.4. イベント"
    },
    {
      "indent": 3,
      "text": "This LFB specifies only two events. The first detects whether the InvalidMergesCounter has exceeded a specific value, and the second detects whether the InvalidAllCounter has exceeded a specific value. Both error reports will send the respective counter value. Event Filters can be used to limit the number of messages",
      "ja": "このLFBは2つだけのイベントを指定します。最初はInvalidMergesCounterが特定の値を超えているか否かを検出し、第二はInvalidAllCounterが特定の値を超えたか否かを検出します。どちらのエラーレポートは、それぞれのカウンタ値を送信します。イベントフィルタは、メッセージの数を制限するために使用することができます"
    },
    {
      "indent": 0,
      "text": "4.3. CoreParallelization",
      "section_title": true,
      "ja": "4.3.  CoreParallelization"
    },
    {
      "indent": 3,
      "text": "A core LFB that specifies that the FE supports parallelization instead of updating the FEObject LFB",
      "ja": "FEはFEObject LFBを更新するのではなく、並列化をサポートすることを指定するコアLFB"
    },
    {
      "indent": 0,
      "text": "4.3.1. Data Handling",
      "section_title": true,
      "ja": "4.3.1. データ処理"
    },
    {
      "indent": 3,
      "text": "The CoreParallelization does not handle data.",
      "ja": "CoreParallelizationは、データを処理しません。"
    },
    {
      "indent": 0,
      "text": "4.3.2. Components",
      "section_title": true,
      "ja": "4.3.2. コンポーネント"
    },
    {
      "indent": 3,
      "text": "This LFB has no components specified.",
      "ja": "このLFBは、指定した要素を持ちません。"
    },
    {
      "indent": 0,
      "text": "4.3.3. Capabilities",
      "section_title": true,
      "ja": "4.3.3. 機能"
    },
    {
      "indent": 3,
      "text": "This LFB has only one capability specified. The ParallelLFBs is a table which lists all the LFBs that can be parallelized. Each row of the table contains:",
      "ja": "このLFBは、指定された一つだけの能力を持っています。 ParallelLFBsを並列化することができ、すべてのLFBsを示す表です。テーブルの各行は含まれています。"
    },
    {
      "indent": 3,
      "text": "1. LFBName: A string. The Name of the parallel LFB.",
      "section_title": true,
      "ja": "1. LFBName：文字列。並列LFBの名前。"
    },
    {
      "indent": 3,
      "text": "2. LFBClassID: A uint32. The Class ID of the parallel LFB.",
      "section_title": true,
      "ja": "2. LFBClassID：UINT32。並列LFBのクラスID。"
    },
    {
      "indent": 3,
      "text": "3. LFBVersion: A string. The Version of the parallel LFB.",
      "section_title": true,
      "ja": "3. LFBVersion：文字列。並列LFBのバージョン。"
    },
    {
      "indent": 3,
      "text": "4. LFBParallelOccurrenceLimit: A uint32. The upper limit of instances of the same parallel LFBs of this class.",
      "ja": "4. LFBParallelOccurrenceLimit：UINT32。このクラスの同じ平行LFBsのインスタンスの上限。"
    },
    {
      "indent": 3,
      "text": "5. AllowedParallelAfters: A table of uint32s (LFB Class IDs). A list of LFB classes that can follow this LFB class in a pipeline for a parallel path.",
      "ja": "5. AllowedParallelAfters：INT32のテーブル（LFBクラスです）。パラレルパスのためのパイプラインで、このLFBクラスに従うことができLFBクラスのリスト。"
    },
    {
      "indent": 3,
      "text": "6. AllowedParallelBefores: A table of uint32s (LFB Class IDs). A list of LFB classes that can exist before this LFB class in a pipeline for a parallel path.",
      "ja": "6. AllowedParallelBefores：INT32のテーブル（LFBクラスです）。パラレルパスのためのパイプラインで、このLFBクラスの前に存在することができLFBクラスのリスト。"
    },
    {
      "indent": 3,
      "text": "7. AllowedParallel: A table of uint32s (LFB Class IDs). A list of LFB classes that can process packets or chunks in parallel with this LFB class.",
      "ja": "7.可パラレル：INT32のテーブル（LFBクラスです）。このLFBクラスと並行してパケット又はチャンクを処理することができるLFBクラスのリスト。"
    },
    {
      "indent": 0,
      "text": "4.3.4. Events",
      "section_title": true,
      "ja": "4.3.4. イベント"
    },
    {
      "indent": 3,
      "text": "This LFB specifies no events.",
      "ja": "このLFBには、イベントを指定します。"
    },
    {
      "indent": 0,
      "text": "5. XML for Parallel LFB Library",
      "section_title": true,
      "ja": "パラレルLFBライブラリ5. XML"
    },
    {
      "indent": 2,
      "text": "<?xml version=\"1.0\" encoding=\"UTF-8\"?> <LFBLibrary xmlns=\"urn:ietf:params:xml:ns:forces:lfbmodel:1.1\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"urn:ietf:params:xml:ns:forces:lfbmodel:1.1\" provides=\"Parallel\"> <load library=\"BaseTypeLibrary\" location=\"BaseTypeLibrary.LFB\"/> <frameDefs> <frameDef> <name>Chunk</name> <synopsis>A chunk is a frame that is part of an original larger frame</synopsis> </frameDef> </frameDefs> <dataTypeDefs> <dataTypeDef> <name>ParallelTypes</name> <synopsis>The type of parallelization this packet will go through</synopsis> <atomic> <baseType>uchar</baseType> <specialValues> <specialValue value=\"0\"> <name>Flood</name> <synopsis>The packet/chunk has been sent as a whole to multiple recipients</synopsis> </specialValue> <specialValue value=\"1\"> <name>Split</name> <synopsis>The packet/chunk has been split into multiple chunks and sent to recipients</synopsis> </specialValue> </specialValues> </atomic> </dataTypeDef> <dataTypeDef> <name>ParallelLFBType</name> <synopsis>Table entry for parallel LFBs</synopsis> <struct> <component componentID=\"1\"> <name>LFBName</name> <synopsis>The name of an LFB Class</synopsis> <typeRef>string</typeRef>",
      "ja": "<？xml version = \"1.0\" エンコード= \"UTF-8\"？> <LFBLibrary =のxmlns \"壷：IETF：のparams：XML：NS：力：lfbmodel：1.1\" のxmlns：XSI = \"のhttp：//www.w3 .ORG / 2001 / XMLスキーマ・インスタンス」のxsi：のschemaLocation = \"URN：IETF：paramsは：XML：NS：力：lfbmodel：1.1パラレル \"> <ロードライブラリ= \"BaseTypeLibrary\" 位置= \"BaseTypeLibrary.LFB\" =提供します\"\" /> <frameDefs> <frameDef> <名前>チャンク</名前> <概要>チャンクは、元の大きいフレーム</概要> </ frameDef> </ frameDefs> <dataTypeDefs> <dataTypeDef>の一部であるフレームであります<名前> ParallelTypes </名前> <概要>並列化の種類は、このパケットは、</概要> <原子> <baseType> UCHAR </ baseType> <specialValues> <specialValue値= \"0\"> <名前>洪水を通過します</名前> <概要>パケット/チャンクが複数の受信者に、全体として送信された</概要> </ specialValue> <specialValue値= \"1\"> <名前>スプリット</名前> <概要>パケット/チャンクは、複数のチャンクに分割され、受信者に送信された</概要> </ specialValue> </ specialValues> </原子> </ dataTypeDef> <dataTypeDef> <N AME> ParallelLFBType </名前> <概要>平行LFBs表エントリ</シノプシス> <構造体> <コンポーネントのComponentID = \"1\"> <名前> LFBName </名前> <概要> LFBクラスの名前</シノプシス> <typeRef>文字列</ typeRef>"
    },
    {
      "indent": 4,
      "text": " </component> <component componentID=\"2\"> <name>LFBClassID</name> <synopsis>The ID of the LFB Class</synopsis> <typeRef>uint32</typeRef> </component> <component componentID=\"3\"> <name>LFBVersion</name> <synopsis>The version of the LFB Class used by this FE </synopsis> <typeRef>string</typeRef> </component> <component componentID=\"4\"> <name>LFBParallelOccurrenceLimit</name> <synopsis>The upper limit of instances of the same parallel LFBs of this class</synopsis> <optional/> <typeRef>uint32</typeRef> </component> <component componentID=\"5\"> <name>AllowedParallelAfters</name> <synopsis>List of LFB Classes that can follow this LFB in a parallel pipeline</synopsis> <optional/> <array> <typeRef>uint32</typeRef> </array> </component> <component componentID=\"6\"> <name>AllowedParallelBefores</name> <synopsis>List of LFB Classes that this LFB Class can follow in a parallel pipeline</synopsis> <optional/> <array> <typeRef>uint32</typeRef> </array> </component> <component componentID=\"7\"> <name>AllowedParallel</name> <synopsis>List of LFB Classes that this LFB Class can be run in parallel with</synopsis> <array> <typeRef>uint32</typeRef> </array> </component> </struct> </dataTypeDef> </dataTypeDefs>",
      "ja": "</コンポーネント> <コンポーネントのComponentID = \"2\"> <名前> LFBClassID </名前> <概要> LFBクラス</シノプシス> <typeRef> UINT32 </ typeRef> </コンポーネント> <コンポーネントのComponentIDのID =」 3 \"> <名前> LFBVersion </名前> <概要>このFE </シノプシス> <typeRef>列</ typeRef> </コンポーネント> <コンポーネントによって使用されるLFBクラスのバージョンのComponentID =\" 4\" > <名前> LFBParallelOccurrenceLimit </名前> <概要>このクラスの同じ平行LFBsのインスタンスの上限</シノプシス> <オプション/> <typeRef> UINT32 </ typeRef> </コンポーネント> <コンポーネントのComponentID = \"5\"> <名前> AllowedParallelAfters </名前> <概要>並列パイプラインでこのLFBに従うことができるLFBクラスの一覧</シノプシス> <オプション/> <配列> <typeRef> UINT32 </ typeRef> </アレイ> </成分> <コンポーネントのComponentID = \"6\"> <名前> AllowedParallelBefores </名前> <概要>このLFBクラス並列パイプラインに従うことができるLFBクラスの一覧</シノプシス> <オプション/> <配列> <typeRef> UINT32 < / typeRef> </アレイ> </コンポーネント> <コンポーネントのComponentID = \"7\"> <名前>すべてowedParallel </名前> <概要>このLFBクラスは、</概要> <配列> <typeRef> UINT32 </ typeRef> </配列> </部品>と並行して実行することができますLFBクラスの一覧</構造体> < / dataTypeDef> </ dataTypeDefs>"
    },
    {
      "indent": 4,
      "text": "<metadataDefs> <metadataDef> <name>ParallelMetadataSet</name> <synopsis>A metadata set for parallelization-related LFBs </synopsis> <metadataID>32</metadataID> <struct> <component componentID=\"1\"> <name>ParallelType</name> <synopsis>The type of parallelization this packet/chunk has gone through</synopsis> <typeRef>ParallelTypes</typeRef> </component> <component componentID=\"2\"> <name>TaskCorrelator</name> <synopsis>An identification number to specify that packets or chunks originate from the same packet. </synopsis> <typeRef>uint32</typeRef> </component> <component componentID=\"3\"> <name>ParallelNum</name> <synopsis>Defines the number of the specific packet or chunk of the specific parallel ID.</synopsis> <typeRef>uint32</typeRef> </component> <component componentID=\"4\"> <name>ParallelPartsCount</name> <synopsis>Defines the total number of packets or chunks for the specific parallel ID.</synopsis> <typeRef>uint32</typeRef> </component> </struct> </metadataDef> </metadataDefs> <LFBClassDefs> <LFBClassDef LFBClassID=\"65537\"> <name>Ext-Splitter</name> <synopsis>A Splitter LFB takes part in parallelizing the processing datapath. It will either send the same packet or chunks of one packet to multiple LFBs</synopsis> <version>1.0</version> <inputPorts> <inputPort> <name>SplitterIn</name> <synopsis>An input port expecting any kind of frame </synopsis> <expectation>",
      "ja": "<metadataDefs> <metadataDef> <名前> ParallelMetadataSet </名前> <概要>並列関連LFBsのメタデータ・セット</シノプシス> <metadataID> 32 </ metadataID> <構造体> <コンポーネントのComponentID = \"1\"> <名前> ParallelType </名前> <概要>並列の種類このパケット/チャンク/ </シノプシス> <typeRef> ParallelTypes </ typeRef> </コンポーネント> <コンポーネントのComponentID = \"2\"> <名前> TaskCorrelator <経ました> <概要>識別番号パケット又はチャンクが同じパケットに由来するように指定する名前。 </シノプシス> <typeRef> UINT32 </ typeRef> </コンポーネント> <コンポーネントのComponentID = \"3\"> <名前> ParallelNum </名前> <概要>特定平行IDの特定のパケット又はチャンクの数を定義します。 </シノプシス> <typeRef> UINT32 </ typeRef> </コンポーネント> <コンポーネントのComponentID = \"4\"> <名前> ParallelPartsCount </名前> <概要>特定平行IDのためのパケット又はチャンクの総数を定義します。< /シノプシス> <typeRef> UINT32 </ typeRef> </成分> </構造体> </ metadataDef> </ metadataDefs> <LFBClassDefs> <LFBClassDef LFBClassID = \"65537\"> <名前> EXT-スプリッタ</名前> <概要>スプリッタLFBは、処理データパスを並列に関与します。いずれかの種類を期待してそれするか、複数のLFBsに1つのパケットの同じパケットまたはチャンクを送信</概要> <バージョン> 1.0 </ version>の<inputPorts> <inputPort> <名前> SplitterIn </名前> <概要>入力ポートフレームの</概要> <期待>"
    },
    {
      "indent": 8,
      "text": "      <frameExpected>\n        <ref>Arbitrary</ref>\n      </frameExpected>\n    </expectation>\n  </inputPort>\n</inputPorts>\n<outputPorts>\n  <outputPort group=\"true\">\n    <name>SplitterOut</name>\n    <synopsis>A parallel output port that sends the same\n            packet to all output instances or chunks of the same\n            packet to output instances.  Each chunk is sent only\n            once by the LFB.</synopsis>\n    <product>\n      <frameProduced>\n        <ref>Arbitrary</ref>\n        <ref>Chunk</ref>\n      </frameProduced>\n      <metadataProduced>\n        <ref>ParallelMetadataSet</ref>\n      </metadataProduced>\n    </product>\n  </outputPort>\n</outputPorts>\n<components>\n  <component componentID=\"1\" access=\"read-write\">\n    <name>ParallelType</name>\n    <synopsis>The type of parallelization this packet will\n            go through</synopsis>\n    <typeRef>ParallelTypes</typeRef>\n  </component>\n  <component componentID=\"2\" access=\"read-write\">\n    <name>ChunkSize</name>\n    <synopsis>The size of a chunk when a packet is split\n            into multiple chunks of the same size</synopsis>\n    <typeRef>uint32</typeRef>\n  </component>\n</components>\n<capabilities>\n  <capability componentID=\"31\">\n    <name>MinMaxChunkSize</name>\n    <synopsis>The minimum and maximum size of a chunk\n            capable of split by this LFB</synopsis>\n    <struct>\n      <component componentID=\"1\">\n        <name>MinChunkSize</name>\n        <synopsis>Minimum chunk size</synopsis>\n        <optional/>",
      "raw": true
    },
    {
      "indent": 6,
      "text": " <typeRef>uint32</typeRef> </component> <component componentID=\"2\"> <name>MaxChunkSize</name> <synopsis>Maximum chunk size</synopsis> <typeRef>uint32</typeRef> </component> </struct> </capability> </capabilities> </LFBClassDef> <LFBClassDef LFBClassID=\"65538\"> <name>Ext-Merger</name> <synopsis>A Merger LFB receives multiple packets or multiple chunks of the same packet and merge them into one merged packet</synopsis> <version>1.0</version> <inputPorts> <inputPort group=\"true\"> <name>MergerIn</name> <synopsis>A parallel input port that accepts packets or chunks from all output instances</synopsis> <expectation> <frameExpected> <ref>Arbitrary</ref> <ref>Chunk</ref> </frameExpected> <metadataExpected> <ref>ParallelMetadataSet</ref> </metadataExpected> </expectation> </inputPort> <inputPort group=\"true\"> <name>InvalidIn</name> <synopsis>When a packet is sent out of an error port of an LFB in a parallel path, it will be sent to this output port in the Merger LFB</synopsis> <expectation> <frameExpected> <ref>Arbitrary</ref> <ref>Chunk</ref> </frameExpected> <metadataExpected> <one-of> <ref>ExceptionID</ref> <ref>ValidateErrorID</ref> </one-of> </metadataExpected>",
      "ja": "<typeRef> UINT32 </ typeRef> </コンポーネント> <コンポーネントのComponentID = \"2\"> <名前> MaxChunkSize </名前> <概要>最大チャンクサイズ</シノプシス> <typeRef> UINT32 </ typeRef> </成分> </構造体> </機能> </機能> </ LFBClassDef> <LFBClassDef LFBClassID = \"65538\"> <名前> EXT-合併</名前> <概要>合併LFBは、複数のパケットまたは同じパケットの複数のチャンクを受信します一つにマージマージパケット</シノプシス>の<version> 1.0 </バージョン> <inputPorts> <inputPort基= \"真\"> <名前> MergerIn </名前> <概要>パケット又はチャンクを受け付ける並列入力ポートすべての出力例</シノプシス> <期待> <frameExpected> <参考文献>任意</ REF> <参考文献>チャンク</ ref>を</ frameExpected> <metadataExpected> <参考文献> ParallelMetadataSet </ ref>を</ metadataExpected> <から/期待> </ inputPort> <inputPort基=「真」> <名前> InvalidIn </名前> <概要>パケットが並列パスにLFBのエラーポートから送信される場合には、これに送られます合併LFB </概要> <期待> <FRAでの出力ポートmeExpected> <参考文献>任意</ REF> <参考文献>チャンク</ ref>を</ frameExpected> <metadataExpected> <> <参考文献> ExceptionID </ REF一の> <参考文献> ValidateErrorID </ ref>を</ワン> </ metadataExpected>"
    },
    {
      "indent": 8,
      "text": " </expectation> </inputPort> </inputPorts> <outputPorts> <outputPort> <name>MergerOut</name> <synopsis>An output port expecting any kind of frame </synopsis> <product> <frameProduced> <ref>Arbitrary</ref> </frameProduced> </product> </outputPort> </outputPorts> <components> <component componentID=\"1\" access=\"read-write\"> <name>InvalidAction</name> <synopsis>What the Merge LFB will do if an invalid chunk or packet is received</synopsis> <atomic> <baseType>uchar</baseType> <specialValues> <specialValue value=\"0\"> <name>DropAll</name> <synopsis>Drop all packets or chunks </synopsis> </specialValue> <specialValue value=\"1\"> <name>Continue</name> <synopsis>Continue with the merge</synopsis> </specialValue> </specialValues> </atomic> </component> <component componentID=\"2\" access=\"read-write\"> <name>MergeWaitType</name> <synopsis>Whether the Merge LFB will wait for all packets or chunks to be received prior to sending out a response</synopsis> <typeRef>boolean</typeRef> </component> <component componentID=\"3\" access=\"read-write\"> <name>MergeWaitTimeoutTimer</name> <synopsis>The time that the Merger will wait for all packets or chunks within the same task to arrive before considering them invalid.</synopsis> <typeRef>uint32</typeRef>",
      "ja": "</期待> </ inputPort> </ inputPorts> <outputPorts> <出力ポート> <名前> MergerOut </名前> <概要>フレームの任意の種類を期待出力ポート</シノプシス> <製品> <frameProduced> <参考文献>任意の</ ref>を</ frameProduced> </製品> </出力ポート> </ outputPorts> <成分> <コンポーネントのComponentID = \"1\" アクセス= \"読み書き\"> <名前> InvalidAction </名前> <概要>無効なチャンクまたはパケットを受信した場合、マージLFBは</概要> <原子> <baseType> UCHAR </ baseType> <specialValues> <specialValue値= \"0\"> <名前> DropAll </名前> <概要何をしますか>ドロップすべてのパケットまたはチャンク</概要> </ specialValue> <specialValue値= \"1\"> <名前> </名前> <概要続行>マージ</概要> </ specialValue> </ specialValues> <を続行原子/> </コンポーネント> <コンポーネントのComponentID =「2」アクセス=「読み書き」> <名前> MergeWaitType </名前> <概要>マージLFBは、送信前に受信する全てのパケット又はチャンクを待機するかどうかアウト応答</シノプシス> <typeRef>ブール</ typeRef> </成分> <componenトンCOMPONENTID =「3」アクセス=「読み書き」> <名前> MergeWaitTimeoutTimer </名前> <概要>合併がそれらを無効検討する前に到着するために、同じタスク内のすべてのパケットまたはチャンクを待つ時間。</概要> <typeRef> UINT32 </ typeRef>"
    },
    {
      "indent": 8,
      "text": " </component> <component componentID=\"4\" access=\"read-reset\"> <name>InvalidMergesCounter</name> <synopsis>Counts the number of merges where there is at least one packet/chunk that entered the Merger LFB through the InvalidIn input port</synopsis> <typeRef>uint32</typeRef> </component> <component componentID=\"5\" access=\"read-reset\"> <name>InvalidTotalCounter</name> <synopsis>Counts the number of merges where all packets/chunks entered the Merger LFB through the InvalidIn input port</synopsis> <typeRef>uint32</typeRef> </component> <component componentID=\"6\" access=\"read-reset\"> <name>InvalidIDCounters</name> <synopsis>Counts the number of invalid merges where at least one packet/chunk entered through InvalidID per error ID</synopsis> <struct> <component componentID=\"1\"> <name>InvalidExceptionID</name> <synopsis>Per Exception ID</synopsis> <array> <typeRef>uint32</typeRef> </array> </component> <component componentID=\"2\"> <name>InvalidValidateErrorID</name> <synopsis>Per Validate Error ID</synopsis> <array> <typeRef>uint32</typeRef> </array> </component> </struct> </component> </components> <events baseID=\"30\"> <event eventID=\"1\"> <name>ManyInvalids</name> <synopsis>An event that specifies if there are too many invalids</synopsis> <eventTarget> <eventField>InvalidCounter</eventField> </eventTarget> <eventGreaterThan/> <eventReports>",
      "ja": "</コンポーネント> <コンポーネントのComponentID =「4」のアクセス=「読み取りリセット」> <名前> InvalidMergesCounter </名前> <概要>を介して合併LFBに入った少なくとも1つのパケット/チャンクがあるマージの数をカウントInvalidIn入力ポート</シノプシス> <typeRef> UINT32 </ typeRef> </コンポーネント> <コンポーネントのComponentID = \"5\" アクセス= \"読み取りリセット\"> <名前> InvalidTotalCounter </名前> <概要>の数をカウントすべてのパケット/チャンクが<コンポーネントのComponentID = \"6\" アクセス= \"読み取りリセット\"> </シノプシス> <typeRef> UINT32 </ typeRef> </成分> InvalidIn入力ポートを介して合併LFBに入った場合にマージし、<名前> InvalidIDCounters </名前> <概要>カウント少なくとも1つのパケット/チャンクがエラーIDごとInvalidID介して入力された無効なマージの数</概要> <構造体> <コンポーネントのComponentID = \"1\"> <名前> InvalidExceptionID </名前> <例外IDごとの概要> </シノプシス> <配列> <typeRef> UINT32 </ typeRef> </アレイ> </コンポーネント> <コンポーネントのComponentID = \"2\"> <名前> InvalidValidateErrorID </名前> <概要>当たり検証エラーID </シノプシス> <配列> <typeRef> UINT32 </ typeRef> </アレイ> </成分> </構造体> </成分> </部品> <イベントbaseID = \"30\"> <イベントのeventID = \"1\" > <名前> ManyInvalids </名前> <概要>あまりにも多くの病人</概要> <のEventTarget> <eventField> InvalidCounter </ eventField> </のEventTarget> <eventGreaterThan /> <eventReports>がある場合に指定したイベント"
    },
    {
      "indent": 2,
      "text": " <eventReport> <eventField>InvalidMergesCounter</eventField> </eventReport> </eventReports> </event> <event eventID=\"2\"> <name>ManyTotalInvalids</name> <synopsis>An event that specifies if there are too many invalids</synopsis> <eventTarget> <eventField>InvalidTotalCounter</eventField> </eventTarget> <eventGreaterThan/> <eventReports> <eventReport> <eventField>InvalidTotalCounter</eventField> </eventReport> </eventReports> </event> </events> </LFBClassDef> <LFBClassDef LFBClassID=\"65539\"> <name>Ext-CoreParallelization</name> <synopsis>A core LFB that specifies that the FE supports parallelization instead of updating the FEObject LFB</synopsis> <version>1.0</version> <capabilities> <capability componentID=\"10\"> <name>ParallelLFBs</name> <synopsis>A table that lists all the LFBs that can be parallelized</synopsis> <array> <typeRef>ParallelLFBType</typeRef> </array> </capability> </capabilities> </LFBClassDef> </LFBClassDefs> </LFBLibrary>",
      "ja": "<eventReport> <eventField> InvalidMergesCounter </ eventField> </ eventReport> </ eventReports> </イベント> <イベントのeventID = \"2\"> <名前> ManyTotalInvalids </名前> <概要>あまりがある場合に指定したイベント多くの病人</概要> <のEventTarget> <eventField> InvalidTotalCounter </ eventField> </のEventTarget> <eventGreaterThan /> <eventReports> <eventReport> <eventField> InvalidTotalCounter </ eventField> </ eventReport> </ eventReports> </イベント> </イベント> </ LFBClassDef> <LFBClassDef LFBClassID = \"65539\"> <名前> EXT-CoreParallelization </名前> <概要> FEの代わりにFEObject LFBの更新の並列化をサポートすることを指定するコアLFB </概要> <バージョン> 1.0 </ version>は<機能> <機能COMPONENTID = \"10\"> <名前> ParallelLFBs </名前> <概要> </概要> <配列> <typeRef並列化できるすべてのLFBsを示す表> ParallelLFBType </ typeRef> </アレイ> </機能> </機能> </ LFBClassDef> </ LFBClassDefs> </ LFBLibrary>"
    },
    {
      "indent": 22,
      "text": "Figure 6: Parallel LFB Library",
      "ja": "図6：パラレルLFBライブラリ"
    },
    {
      "indent": 0,
      "text": "6. IANA Considerations",
      "section_title": true,
      "ja": "6. IANAの考慮事項"
    },
    {
      "indent": 0,
      "text": "6.1. LFB Class Names and LFB Class Identifiers",
      "section_title": true,
      "ja": "6.1.  LFBクラス名とLFBクラス識別子"
    },
    {
      "indent": 3,
      "text": "LFB classes defined by this document do not belong to LFBs defined by Standards Action. As such, the corresponding values assigned in the \"Logical Functional Block (LFB) Class Names and Class Identifiers\" registry at <http://www.iana.org/assignments/forces> are above 65535.",
      "ja": "この文書で定義されたLFBクラスは、標準アクションで定義されたLFBsに属していません。このように、<http://www.iana.org/assignments/forces>の「論理的な機能ブロック（LFB）クラス名およびクラス識別子」レジストリに割り当てられた対応する値は65535以上です。"
    },
    {
      "indent": 3,
      "text": "This specification includes the following LFB class names and LFB class identifiers:",
      "ja": "この仕様は、次のLFBクラス名とLFBクラス識別子が含まれています。"
    },
    {
      "indent": 3,
      "text": "+-------+---------------------+-------+-----------------+---------+\n| LFB   |  LFB Class Name     |  LFB  |  Description    |   Ref   |\n| Class |                     |Version|                 |         |\n| ID    |                     |       |                 |         |\n+-------+---------------------+-------+-----------------+---------+\n| 65537 |   Ext-Splitter      |  1.0  | A Splitter LFB  |   RFC   |\n|       |                     |       |  will send      |   7409  |\n|       |                     |       |either the same  |         |\n|       |                     |       |   packet or     |         |\n|       |                     |       | chunks of one   |         |\n|       |                     |       |   packet to     |         |\n|       |                     |       | multiple LFBs.  |         |\n+-------+---------------------+-------+-----------------+---------+\n| 65538 |    Ext-Merger       |   1.0 |  A Merger LFB   |   RFC   |\n|       |                     |       |    receives     |   7409  |\n|       |                     |       |    multiple     |         |\n|       |                     |       |   packets or    |         |\n|       |                     |       |    multiple     |         |\n|       |                     |       | chunks of the   |         |\n|       |                     |       |  same packet    |         |\n|       |                     |       |   and merges    |         |\n|       |                     |       | them into one.  |         |\n+-------+---------------------+-------+-----------------+---------+\n| 65539 | Ext-                |   1.0 | A core LFB to   |   RFC   |\n|       | CoreParallelization |       | signify the     |   7409  |\n|       |                     |       | parallelization |         |\n|       |                     |       |   capability    |         |\n+-------+---------------------+-------+-----------------+---------+",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Logical Functional Block (LFB) Class Names and Class Identifiers",
      "ja": "論理機能ブロック（LFB）クラス名とクラス識別子"
    },
    {
      "indent": 0,
      "text": "6.2. Metadata ID",
      "section_title": true,
      "ja": "6.2. メタデータのID"
    },
    {
      "indent": 3,
      "text": "The Metadata ID namespace is 32-bits long. Values assigned by this specification are:",
      "ja": "メタデータID名前空間は32ビット長です。この仕様によって割り当てられた値は以下のとおりです。"
    },
    {
      "indent": 13,
      "text": "+------------+---------------------+-----------+\n|   Value    |         Name        | Reference |\n+------------+---------------------+-----------+\n| 0x00000010 | ParallelMetadataSet |  RFC 7409 |\n+------------+---------------------+-----------+",
      "raw": true
    },
    {
      "indent": 16,
      "text": "Metadata ID Assigned by this Specification",
      "ja": "メタデータIDは、この仕様で割り当て"
    },
    {
      "indent": 0,
      "text": "7. Security Considerations",
      "section_title": true,
      "ja": "7.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document does not alter either the ForCES model [RFC5812] or the ForCES protocol [RFC5810]. As such, it has no impact on their security considerations. This document simply defines the operational parameters and capabilities of LFBs that perform parallelization and not how parallelization is implemented. Finally, this document does not attempt to analyze the presence or possibility of security interactions created by allowing parallel operations on packets. Any such issues, if they exist, are for the designers of the particular data path, not the general mechanism.",
      "ja": "この文書では、いずれかのForCESモデル[RFC5812]かのForCESプロトコル[RFC5810]を変化させません。このように、それは彼らのセキュリティに関する考慮事項には影響を与えません。この文書では、単に並列化がどのように実装されるか並列化ではなくを行うLFBsの動作パラメータと機能を定義します。最後に、この文書では、パケット上で並列処理を可能にすることにより、作成したセキュリティの相互作用の存在または可能性を分析しようとしません。任意のそのような問題は、彼らが存在する場合、特定のデータ・パスではなく、一般的な機構の設計者のためのものです。"
    },
    {
      "indent": 0,
      "text": "8. References",
      "section_title": true,
      "ja": "8.参照文献"
    },
    {
      "indent": 0,
      "text": "8.1. Normative References",
      "section_title": true,
      "ja": "8.1. 引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月、<http://www.rfc-editor.org/info/rfc2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC5810] Doria, A., Hadi Salim, J., Haas, R., Khosravi, H., Wang, W., Dong, L., Gopal, R., and J. Halpern, \"Forwarding and Control Element Separation (ForCES) Protocol Specification\", RFC 5810, March 2010, <http://www.rfc-editor.org/info/rfc5810>.",
      "ja": "[RFC5810]ドリア、A.、ハディサリム、J.、ハース、R.、Khosravi、H.、王、W.、ドン、L.、ゴパル、R.、およびJ.アルペルン、「転送および制御素子分離（のForCES）プロトコル仕様」、RFC 5810、2010年3月、<http://www.rfc-editor.org/info/rfc5810>。"
    },
    {
      "indent": 3,
      "text": "[RFC5812] Halpern, J. and J. Hadi Salim, \"Forwarding and Control Element Separation (ForCES) Forwarding Element Model\", RFC 5812, March 2010, <http://www.rfc-editor.org/info/rfc5812>.",
      "ja": "[RFC5812]アルペルン、J.およびJ.ハディサリム、 \"転送および制御素子分離（のForCES）転送要素モデル\"、RFC 5812、2010年3月<http://www.rfc-editor.org/info/rfc5812> 。"
    },
    {
      "indent": 3,
      "text": "[RFC6956] Wang, W., Haleplidis, E., Ogawa, K., Li, C., and J. Halpern, \"Forwarding and Control Element Separation (ForCES) Logical Function Block (LFB) Library\", RFC 6956, June 2013, <http://www.rfc-editor.org/info/rfc6956>.",
      "ja": "[RFC6956]王、W.、Haleplidis、E.、小川、K.、リチウム、C.、およびJ.アルペルン、 \"転送および制御素子分離（のForCES）論理機能ブロック（LFB）ライブラリー\"、RFC 6956年6月2013年、<http://www.rfc-editor.org/info/rfc6956>。"
    },
    {
      "indent": 3,
      "text": "[RFC7408] Haleplidis, E., \"Forwarding and Control Element Separation (ForCES) Model Extension\", RFC 7408, November 2014, <http://www.rfc-editor.org/info/rfc7408>.",
      "ja": "[RFC7408] Haleplidis、E.、 \"転送および制御素子分離（のForCES）モデルの拡張\"、RFC 7408、2014年11月、<http://www.rfc-editor.org/info/rfc7408>。"
    },
    {
      "indent": 0,
      "text": "8.2. Informative References",
      "section_title": true,
      "ja": "8.2. 参考文献"
    },
    {
      "indent": 3,
      "text": "[Cilk] Massachusetts Institute of Technology, \"The Cilk Project\", <http://supertech.csail.mit.edu/cilk/>.",
      "ja": "テクノロジーの[のCilk]マサチューセッツ工科大学、 \"インテル®Cilk™プロジェクト\"、<http://supertech.csail.mit.edu/cilk/>。"
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "The authors would like to thank Edward Crabbe for the initial discussion that led to the creation of this document. They also thank Jamal Hadi Salim and Dave Hood for comments and discussions and Adrian Farrel for his AD review that made this document better. Finally, the authors thank Francis Dupont for his Gen-Art review and Magnus Nystroem for his security review both of which refined this document to its final shape.",
      "ja": "著者は、この文書の作成につながった初期の議論のためのエドワード・クラッブに感謝したいと思います。彼らはまた、この文書良く作られた彼のADのレビューのためにジャマル・ハディサリムとコメントや議論のためのデイブ・フッドとエードリアンファレルに感謝します。最後に、著者はその最終形状にこの文書を洗練どちらも彼のセキュリティレビューのための彼のジェン・アートレビューのためフランシスデュポンとマグナスNystroemに感謝します。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Evangelos Haleplidis University of Patras Department of Electrical and Computer Engineering Patras 26500 Greece",
      "ja": "電気のパトラス専攻コンピュータ工学パトラス26500ギリシャのEvangelos Haleplidis大学"
    },
    {
      "indent": 3,
      "text": "EMail: ehalep@ece.upatras.gr",
      "ja": "メールアドレス：ehalep@ece.upatras.gr"
    },
    {
      "indent": 3,
      "text": "Joel Halpern Ericsson P.O. Box 6049 Leesburg, VA 20178 United States",
      "ja": "ジョエルハルパーンエリクソン私書箱ボックス6049リーズバーグ、バージニア州20178米国"
    },
    {
      "indent": 3,
      "text": "Phone: +1 703 371 3043 EMail: joel.halpern@ericsson.com",
      "ja": "電話：+1 703 371 3043 Eメール：joel.halpern@ericsson.com"
    }
  ]
}