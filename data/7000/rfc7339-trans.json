{
  "title": {
    "text": "RFC 7339 - Session Initiation Protocol (SIP) Overload Control",
    "ja": "RFC 7339 - セッション開始プロトコル（SIP）過負荷制御"
  },
  "number": 7339,
  "created_at": "2019-10-31 22:23:27.079509+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                   V. Gurbani, Ed.\nRequest for Comments: 7339                                       V. Hilt\nCategory: Standards Track                      Bell Labs, Alcatel-Lucent\nISSN: 2070-1721                                           H. Schulzrinne\n                                                     Columbia University\n                                                          September 2014",
      "raw": true
    },
    {
      "indent": 11,
      "text": "Session Initiation Protocol (SIP) Overload Control",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "Overload occurs in Session Initiation Protocol (SIP) networks when SIP servers have insufficient resources to handle all the SIP messages they receive. Even though the SIP protocol provides a limited overload control mechanism through its 503 (Service Unavailable) response code, SIP servers are still vulnerable to overload. This document defines the behavior of SIP servers involved in overload control and also specifies a loss-based overload scheme for SIP.",
      "ja": "過負荷は、SIPサーバは、彼らが受信するすべてのSIPメッセージを処理するための十分なリソースを持っているセッション開始プロトコル（SIP）ネットワークで発生します。 SIPプロトコルは、その503（サービス利用不可）応答コードを介して制限された過負荷制御機構を提供するにもかかわらず、SIPサーバは、依然として過負荷に対して脆弱です。この文書では、過負荷制御に関与するSIPサーバの動作を定義し、また、SIPのための損失ベースの過負荷スキームを指定します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 5741のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7339.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7339で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2014 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2014 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................4\n2. Terminology .....................................................5\n3. Overview of Operations ..........................................6\n4. Via Header Parameters for Overload Control ......................6\n   4.1. The \"oc\" Parameter .........................................6\n   4.2. The \"oc-algo\" Parameter ....................................7\n   4.3. The \"oc-validity\" Parameter ................................8\n   4.4. The \"oc-seq\" Parameter .....................................8\n5. General Behavior ................................................9\n   5.1. Determining Support for Overload Control ..................10\n   5.2. Creating and Updating the Overload Control Parameters .....10\n   5.3. Determining the \"oc\" Parameter Value ......................12\n   5.4. Processing the Overload Control Parameters ................12\n   5.5. Using the Overload Control Parameter Values ...............13\n   5.6. Forwarding the Overload Control Parameters ................14\n   5.7. Terminating Overload Control ..............................14\n   5.8. Stabilizing Overload Algorithm Selection ..................15\n   5.9. Self-Limiting .............................................15\n   5.10. Responding to an Overload Indication .....................16\n        5.10.1. Message Prioritization at the Hop before\n                the Overloaded Server .............................16\n        5.10.2. Rejecting Requests at an Overloaded Server ........17\n   5.11. 100 Trying Provisional Response and Overload\n         Control Parameters .......................................17\n6. Example ........................................................18\n7. The Loss-Based Overload Control Scheme .........................19\n   7.1. Special Parameter Values for Loss-Based Overload Control ..19\n   7.2. Default Algorithm for Loss-Based Overload Control .........20\n8. Relationship with Other IETF SIP Load Control Efforts ..........23\n9. Syntax .........................................................24\n10. Design Considerations .........................................24\n   10.1. SIP Mechanism ............................................24\n        10.1.1. SIP Response Header ...............................24\n        10.1.2. SIP Event Package .................................25\n   10.2. Backwards Compatibility ..................................26\n11. Security Considerations .......................................27\n12. IANA Considerations ...........................................29\n13. References ....................................................29\n   13.1. Normative References .....................................29\n   13.2. Informative References ...................................30\nAppendix A. Acknowledgements ......................................31\nAppendix B. RFC 5390 Requirements .................................31",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "As with any network element, a Session Initiation Protocol (SIP) [RFC3261] server can suffer from overload when the number of SIP messages it receives exceeds the number of messages it can process. Overload can pose a serious problem for a network of SIP servers. During periods of overload, the throughput of a network of SIP servers can be significantly degraded. In fact, overload may lead to a situation where the retransmissions of dropped SIP messages may overwhelm the capacity of the network. This is often called \"congestion collapse\".",
      "ja": "それは受信SIPメッセージの数は、それが処理できるメッセージの数を超えた場合に、任意のネットワーク構成要素と同様に、セッション開始プロトコル（SIP）[RFC3261]サーバーが過負荷に苦しむことができます。過負荷は、SIPサーバのネットワークのための深刻な問題を提起することができます。過負荷の期間中に、SIPサーバのネットワークのスループットを大幅に低下させることができます。実際には、過負荷が低下したSIPメッセージの再送信は、ネットワークのキャパシティを圧倒するような状況につながる可能性があります。これは、しばしば「輻輳崩壊」と呼ばれています。"
    },
    {
      "indent": 3,
      "text": "Overload is said to occur if a SIP server does not have sufficient resources to process all incoming SIP messages. These resources may include CPU processing capacity, memory, input/output, or disk resources.",
      "ja": "過負荷は、SIPサーバは、すべての着信SIPメッセージを処理するのに十分なリソースを持っていない場合に発生すると言われています。これらのリソースは、CPU処理能力、メモリ、入力/出力、またはディスク・リソースを含むことができます。"
    },
    {
      "indent": 3,
      "text": "For overload control, this document only addresses failure cases where SIP servers are unable to process all SIP requests due to resource constraints. There are other cases where a SIP server can successfully process incoming requests but has to reject them due to failure conditions unrelated to the SIP server being overloaded. For example, a Public Switched Telephone Network (PSTN) gateway that runs out of trunks but still has plenty of capacity to process SIP messages should reject incoming INVITEs using a 488 (Not Acceptable Here) response [RFC4412]. Similarly, a SIP registrar that has lost connectivity to its registration database but is still capable of processing SIP requests should reject REGISTER requests with a 500 (Server Error) response [RFC3261]. Overload control does not apply to these cases, and SIP provides appropriate response codes for them.",
      "ja": "過負荷制御のために、このドキュメントでは、SIPサーバは、リソースの制約のために、すべてのSIPリクエストを処理することができません失敗例に対応しています。 SIPサーバが正常に着信要求を処理するが、原因オーバーロードされているSIPサーバとは無関係の障害状態にそれらを拒否するために持っていることができ、他の例があります。例えば、公衆交換電話網（PSTN）トランクを使い果たしたが、それでも488（ここでは許容できない）応答[RFC4412]を使用して、着信のINVITEを拒否すべきであるSIPメッセージを処理する能力をたくさん持っているゲートウェイを交換しました。同様に、その登録データベースへの接続を失ったが、それでも500（サーバーエラー）応答[RFC3261]に登録要求を拒否すべきであるSIPリクエストを処理することができるしているSIPレジストラ。過負荷制御は、このような場合には適用されません、およびSIPは彼らのために適切な応答コードを提供します。"
    },
    {
      "indent": 3,
      "text": "The SIP protocol provides a limited mechanism for overload control through its 503 (Service Unavailable) response code. However, this mechanism cannot prevent overload of a SIP server, and it cannot prevent congestion collapse. In fact, the use of the 503 (Service Unavailable) response code may cause traffic to oscillate and shift between SIP servers, thereby worsening an overload condition. A detailed discussion of the SIP overload problem, the problems with the 503 (Service Unavailable) response code, and the requirements for a SIP overload control mechanism can be found in [RFC5390].",
      "ja": "SIPプロトコルは、503（サービス利用不可）応答コードを介して、過負荷制御のための限られたメカニズムを提供します。しかし、このメカニズムは、SIPサーバの過負荷を防ぐことができない、それは輻輳崩壊を防ぐことはできません。実際には、503（サービス使用不可）応答コードを使用すると、トラフィックが振動することにより、過負荷状態を悪化させる、SIPサーバ間でシフトする可能性があります。 SIP過負荷の問題の詳細な説明、503（サービス利用不可）応答コードの問題、およびSIP過負荷制御機構のための要件は、[RFC5390]に見出すことができます。"
    },
    {
      "indent": 3,
      "text": "This document defines the protocol for communicating overload information between SIP servers and clients so that clients can reduce the volume of traffic sent to overloaded servers, avoiding congestion collapse and increasing useful throughput. Section 4 describes the Via header parameters used for this communication. The general behavior of SIP servers and clients involved in overload control is described in Section 5. In addition, Section 7 specifies a loss-based overload control scheme.",
      "ja": "この文書は、クライアントが過負荷サーバに送信されるトラフィックの量を減らすことができるように、SIPサーバとクライアントとの間の過負荷情報を通信輻輳崩壊を回避し、有用なスループットを増加させるためのプロトコルを定義します。セクション4は、この通信のために使用されるViaヘッダパラメータを記述する。過負荷制御に関与するSIPサーバとクライアントの一般的な動作は、さらに第5節で説明され、第7節は損失ベースの過負荷制御方式を指定します。"
    },
    {
      "indent": 3,
      "text": "This document specifies the loss-based overload control scheme (Section 7), which is mandatory to implement for this specification. In addition, this document allows other overload control schemes to be supported as well. To do so effectively, the expectations and primitive protocol parameters common to all classes of overload control schemes are specified in this document.",
      "ja": "この文書は、この仕様の実装が必須である損失ベースの過負荷制御方式（セクション7）を、指定します。また、この文書は、他の過負荷制御方式もサポートすることができます。その効果的に行うには、期待と過負荷制御方式のすべてのクラスに共通のプリミティブプロトコルパラメータは、この文書で指定されています。"
    },
    {
      "indent": 0,
      "text": "2. Terminology",
      "section_title": true,
      "ja": "2.用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [RFC2119].",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はRFC 2119 [RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 3,
      "text": "In this document, the terms \"SIP client\" and \"SIP server\" are used in their generic forms. Thus, a \"SIP client\" could refer to the client transaction state machine in a SIP proxy, or it could refer to a user agent client (UAC). Similarly, a \"SIP server\" could be a user agent server (UAS) or the server transaction state machine in a proxy. Various permutations of this are also possible, for instance, SIP clients and servers could also be part of back-to-back user agents (B2BUAs).",
      "ja": "この文書では、用語「SIPクライアント」と「SIPサーバは、」彼らの一般的な形態で使用されています。このように、「SIPクライアントは、」SIPプロキシにクライアントトランザクションのステートマシンを参照することができ、またはそれは、ユーザエージェントクライアント（UAC）を参照することができます。同様に、「SIPサーバは、」プロキシユーザエージェントサーバ（UAS）またはサーバートランザクションステートマシンであってもよいです。この種々の順列も可能で、例えば、SIPクライアントとサーバは、また、バックツーバックユーザエージェント（型B2BUA）の一部とすることができます。"
    },
    {
      "indent": 3,
      "text": "However, irrespective of the context these terms are used in (i.e., proxy, B2BUA, UAS, UAC), \"SIP client\" applies to any SIP entity that provides overload control to traffic destined downstream. Similarly, \"SIP server\" applies to any SIP entity that is experiencing overload and would like its upstream neighbor to throttle incoming traffic.",
      "ja": "しかしながら、これらの用語は（すなわち、プロキシ、B2BUA、UAS、UAC）で使用されているにかかわらず、コンテキストの「SIPクライアントは、」下流向かうトラフィックに過負荷制御を提供する任意のSIPエンティティに適用されます。同様に、「SIPサーバは、」過剰を経験され、着信トラフィックを絞るために、その上流の隣人をご希望の任意のSIPエンティティに適用されます。"
    },
    {
      "indent": 3,
      "text": "Unless otherwise specified, all SIP entities described in this document are assumed to support this specification.",
      "ja": "特に指定しない限り、この文書に記載されているすべてのSIPエンティティは、この仕様をサポートすることを想定しています。"
    },
    {
      "indent": 3,
      "text": "The normative statements in this specification as they apply to SIP clients and SIP servers assume that both the SIP clients and SIP servers support this specification. If, for instance, only a SIP client supports this specification and not the SIP server, then the normative statements in this specification pertinent to the behavior of a SIP server do not apply to the server that does not support this specification.",
      "ja": "彼らは、クライアントとSIPサーバをSIPに適用される本明細書における規範的ステートメントは、SIPクライアントとSIPサーバーの両方がこの仕様をサポートしていることを前提としています。例えば、唯一のSIPクライアントがこの仕様ではなくSIPサーバをサポートしている場合は、SIPサーバの動作に関連する本明細書における規範的な文は、この仕様をサポートしていないサーバーには適用されません。"
    },
    {
      "indent": 0,
      "text": "3. Overview of Operations",
      "section_title": true,
      "ja": "事業の概要3。"
    },
    {
      "indent": 3,
      "text": "This section provides an overview of how the overload control mechanism operates by introducing the overload control parameters. Section 4 provides more details and normative behavior on the parameters listed below.",
      "ja": "このセクションでは、過負荷制御機構は、過負荷制御パラメータを導入することによって、どのように動作するかの概要を提供します。第4節では、下記のパラメータの詳細および規範的動作を提供します。"
    },
    {
      "indent": 3,
      "text": "Because overload control is performed hop-by-hop, the Via header parameter is attractive since it allows two adjacent SIP entities to indicate support for, and exchange information associated with, overload control [RFC6357]. Additional advantages of this choice are discussed in Section 10.1.1. An alternative mechanism using SIP event packages was also considered, and the characteristics of that choice are further outlined in Section 10.1.2.",
      "ja": "過負荷制御は、ホップバイホップを行うため、2つの隣接するSIPエンティティがサポート、および関連付けられた情報交換、過負荷制御[RFC6357]を示すことを可能にするため、Viaヘッダパラメータが魅力的です。この選択のさらなる利点は、10.1.1項で説明されています。 SIPイベントパッケージを使用して代替メカニズムも考慮して、その選択の特徴は、さらに、セクション10.1.2に概説されています。"
    },
    {
      "indent": 3,
      "text": "This document defines four new parameters for the SIP Via header for overload control. These parameters provide a mechanism for conveying overload control information between adjacent SIP entities. The \"oc\" parameter is used by a SIP server to indicate a reduction in the number of requests arriving at the server. The \"oc-algo\" parameter contains a token or a list of tokens corresponding to the class of overload control algorithms supported by the client. The server chooses one algorithm from this list. The \"oc-validity\" parameter establishes a time limit for which overload control is in effect, and the \"oc-seq\" parameter aids in sequencing the responses at the client. These parameters are discussed in detail in the next section.",
      "ja": "この文書では、過負荷制御のためのSIP Viaヘッダーのための4つの新しいパラメータを定義します。これらのパラメータは、隣接するSIPエンティティ間の過負荷制御情報を伝達するための機構を提供します。 「OC」パラメータは、サーバに到着した要求の数の減少を示すために、SIPサーバで使用されています。 「OC-アルゴ」パラメータは、トークンまたはクライアントでサポートされている過負荷制御アルゴリズムのクラスに対応するトークンのリストが含まれています。サーバーは、このリストから1つのアルゴリズムを選択します。 「OC-妥当性」パラメータはコントロール効果であり、クライアントに応答を配列決定することで、「OC-seqの」パラメータの補助をオーバーロードする時間の上限を設定します。これらのパラメータは、次のセクションで詳細に説明します。"
    },
    {
      "indent": 0,
      "text": "4. Via Header Parameters for Overload Control",
      "section_title": true,
      "ja": "過負荷制御のための4を介してヘッダパラメータ"
    },
    {
      "indent": 3,
      "text": "The four Via header parameters are introduced below. Further context about how to interpret these under various conditions is provided in Section 5.",
      "ja": "4つのViaヘッダパラメータは、以下に紹介されています。様々な条件の下でこれらを解釈する方法についての更なるコンテキストは、第5節で提供されています。"
    },
    {
      "indent": 0,
      "text": "4.1. The \"oc\" Parameter",
      "section_title": true,
      "ja": "4.1。 「OC」のパラメータ"
    },
    {
      "indent": 3,
      "text": "This parameter is inserted by the SIP client and updated by the SIP server.",
      "ja": "このパラメータは、SIPクライアントによって挿入され、SIPサーバーによって更新されます。"
    },
    {
      "indent": 3,
      "text": "A SIP client MUST add an \"oc\" parameter to the topmost Via header it inserts into every SIP request. This provides an indication to downstream neighbors that the client supports overload control. There MUST NOT be a value associated with the parameter (the value will be added by the server).",
      "ja": "SIPクライアントはそれがすべてのSIPリクエストに挿入するViaヘッダー一番上に「OC」パラメータを追加する必要があります。これは、クライアントが過負荷制御をサポートしていることを下流の隣人に指示を与えます。 （値は、サーバーによって追加される）パラメータに関連付けられた値があってはなりません。"
    },
    {
      "indent": 3,
      "text": "The downstream server MUST add a value to the \"oc\" parameter in the response going upstream to a client that included the \"oc\" parameter in the request. Inclusion of a value to the parameter represents two things. First, upon the first contact (see Section 5.1), addition of a value by the server to this parameter indicates (to the client) that the downstream server supports overload control as defined in this document. Second, if overload control is active, then it indicates the level of control to be applied.",
      "ja": "ダウンストリームサーバーは、要求に「OC」パラメータを含め、クライアントに上流行く応じて「OC」パラメータに値を追加する必要があります。パラメータに値を含めることは、二つのことを表しています。まず、最初に接触した際に、このパラメータにサーバによって値の加算は、このドキュメントで定義されているダウンストリームサーバーが過負荷制御をサポートしていること（クライアントに）を示している（5.1節を参照してください）。過負荷制御がアクティブである場合には、第2、それが適用される制御のレベルを示しています。"
    },
    {
      "indent": 3,
      "text": "When a SIP client receives a response with the value in the \"oc\" parameter filled in, it MUST reduce, as indicated by the \"oc\" and \"oc-algo\" parameters, the number of requests going downstream to the SIP server from which it received the response (see Section 5.10 for pertinent discussion on traffic reduction).",
      "ja": "SIPクライアントが記入「OC」パラメータの値との応答を受信すると、「OC」と「OC-ALGO」パラメータ、SIPサーバにダウンストリーム要求の数によって示されるように、それは、低減しなければならないからそれは、応答を（トラフィックの減少に関係する議論については、セクション5.10を参照）を受けました。"
    },
    {
      "indent": 0,
      "text": "4.2. The \"oc-algo\" Parameter",
      "section_title": true,
      "ja": "4.2。 「C-何か」パラメータ"
    },
    {
      "indent": 3,
      "text": "This parameter is inserted by the SIP client and updated by the SIP server.",
      "ja": "このパラメータは、SIPクライアントによって挿入され、SIPサーバーによって更新されます。"
    },
    {
      "indent": 3,
      "text": "A SIP client MUST add an \"oc-algo\" parameter to the topmost Via header it inserts into every SIP request, with a default value of \"loss\".",
      "ja": "SIPクライアントは「損失」のデフォルト値と、それはすべてのSIPリクエストに挿入するViaヘッダー一番上に「OC-アルゴ」パラメータを追加する必要があります。"
    },
    {
      "indent": 3,
      "text": "This parameter contains names of one or more classes of overload control algorithms. A SIP client MUST support the loss-based overload control scheme and MUST insert at least the token \"loss\" as one of the \"oc-algo\" parameter values. In addition, the SIP client MAY insert other tokens, separated by a comma, in the \"oc-algo\" parameter if it supports other overload control schemes such as a rate-based scheme [RATE-CONTROL]. Each element in the comma-separated list corresponds to the class of overload control algorithms supported by the SIP client. When more than one class of overload control algorithms is present in the \"oc-algo\" parameter, the client may indicate algorithm preference by ordering the list in a decreasing order of preference. However, the client cannot assume that the server will pick the most preferred algorithm.",
      "ja": "このパラメータは、過負荷制御アルゴリズムの1つ以上のクラスの名前が含まれています。 SIPクライアントは、損失ベースの過負荷制御方式をサポートしなければならないと「OC-アルゴ」パラメータ値の一つとして少なくともトークン「損失」を挿入する必要があります。そのようなレートベースのスキーム[レート制御]などの他の過負荷制御方式をサポートしている場合に加えて、SIPクライアントは、「OC-アルゴ」パラメータでカンマで区切られた他のトークンを、挿入してもよいです。カンマで区切られたリスト内の各要素は、SIPクライアントでサポートされている過負荷制御アルゴリズムのクラスに対応します。過負荷制御アルゴリズムの複数のクラスは、「OC-アルゴ」パラメータに存在する場合、クライアントは、優先の降順でリストを順序付けることにより、アルゴリズム嗜好を示すことができます。ただし、クライアントは、サーバが最も好ましいアルゴリズムを選択すると仮定することはできません。"
    },
    {
      "indent": 3,
      "text": "When a downstream SIP server receives a request with multiple overload control algorithms specified in the \"oc-algo\" parameter (optionally sorted by decreasing order of preference), it chooses one algorithm from the list and MUST return the single selected algorithm to the client.",
      "ja": "下流SIPサーバは、（必要に応じて優先順位を減少させることによってソート）「OC-アルゴ」パラメータで指定された複数の過負荷制御アルゴリズムで要求を受信すると、リストから1つのアルゴリズムを選択し、クライアントに単一の選択されたアルゴリズムを返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "Once the SIP server has chosen a mutually agreeable class of overload control algorithms and communicated it to the client, the selection stays in effect until the algorithm is changed by the server. Furthermore, the client MUST continue to include all the supported algorithms in subsequent requests; the server MUST respond with the agreed-to algorithm until the algorithm is changed by the server.",
      "ja": "SIPサーバは、過負荷制御アルゴリズムの互いに快いクラスを選択し、それをクライアントに伝えた後、アルゴリズムがサーバによって変更されるまで、選択が有効に留まります。さらに、クライアントは、後続の要求でサポートされているすべてのアルゴリズムを含むし続けなければなりません。アルゴリズムは、サーバーによって変更されるまで、サーバーは合意にアルゴリズムで応じなければなりません。"
    },
    {
      "indent": 3,
      "text": "The selection SHOULD stay the same for a non-trivial duration of time to allow the overload control algorithm to stabilize its behavior (see Section 5.8).",
      "ja": "選択は（セクション5.8を参照）、過負荷制御アルゴリズムは、その動作を安定させるために、時間の非自明な期間、同じ滞在する必要があります。"
    },
    {
      "indent": 3,
      "text": "The \"oc-algo\" parameter does not define the exact algorithm to be used for traffic reduction; rather, the intent is to use any algorithm from a specific class of algorithms that affect traffic reduction similarly. For example, the reference algorithm in Section 7.2 can be used as a loss-based algorithm, or it can be substituted by any other loss-based algorithm that results in equivalent traffic reduction.",
      "ja": "「OC-アルゴ」パラメータは、トラフィックの低減のために使用される正確なアルゴリズムを定義していません。むしろ、意図は、同様に、トラフィックの減少に影響を与えるアルゴリズムの特定のクラスから任意のアルゴリズムを使用することです。例えば、セクション7.2で参照アルゴリズムは、損失ベースのアルゴリズムとして使用することができ、またはそれは同等のトラフィックの減少をもたらす任意の他の損失ベースのアルゴリズムにより置換することができます。"
    },
    {
      "indent": 0,
      "text": "4.3. The \"oc-validity\" Parameter",
      "section_title": true,
      "ja": "4.3。 「OC-妥当性」のパラメータ"
    },
    {
      "indent": 3,
      "text": "This parameter MAY be inserted by the SIP server in a response; it MUST NOT be inserted by the SIP client in a request.",
      "ja": "このパラメータは、応答してSIPサーバによって挿入することができます。それは、リクエストにSIPクライアントによって挿入されてはなりません。"
    },
    {
      "indent": 3,
      "text": "This parameter contains a value that indicates an interval of time (measured in milliseconds) that the load reduction specified in the value of the \"oc\" parameter should be in effect. The default value of the \"oc-validity\" parameter is 500 (milliseconds). If the client receives a response with the \"oc\" and \"oc-algo\" parameters suitably filled in, but no \"oc-validity\" parameter, the SIP client should behave as if it had received \"oc-validity=500\".",
      "ja": "このパラメータは、「OC」パラメータの値に指定された負荷の低減が有効でなければならないこと（ミリ秒で測定）時間の間隔を示す値を含みます。 「OC-妥当性」パラメータのデフォルト値は500（ミリ秒）です。クライアントは「OC」や「OC-アルゴ」適切に満たされたパラメータ、ない「OC-妥当性」パラメータを使用して応答を受信した場合、SIPクライアントは、それが「OC-妥当性= 500」受け取っていたかのように振る舞うべきです。"
    },
    {
      "indent": 3,
      "text": "A value of 0 in the \"oc-validity\" parameter is reserved to denote the event that the server wishes to stop overload control or to indicate that it supports overload control but is not currently requesting any reduction in traffic (see Section 5.7).",
      "ja": "「OC-妥当性」パラメータに0の値は、サーバーが過負荷制御を停止するか、過負荷制御をサポートしていますが、現在は、トラフィックの減少を（5.7節を参照）を要求していないことを示すために望んでいることを、イベントを示すために予約されています。"
    },
    {
      "indent": 3,
      "text": "A non-zero value for the \"oc-validity\" parameter MUST only be present in conjunction with an \"oc\" parameter. A SIP client MUST discard a non-zero value of the \"oc-validity\" parameter if the client receives it in a response without the corresponding \"oc\" parameter being present as well.",
      "ja": "「OC-有効」パラメータの非ゼロ値は、「OC」パラメータと組み合わせ中に存在しなければなりません。クライアントは、対応する「OC」パラメータが同様に存在することなく、応答を受信した場合、SIPクライアントは、「OC-有効」パラメータの非ゼロ値を破棄しなければなりません。"
    },
    {
      "indent": 3,
      "text": "After the value specified in the \"oc-validity\" parameter expires and until the SIP client receives an updated set of overload control parameters from the SIP server, overload control is not in effect between the client and the downstream SIP server.",
      "ja": "「OC-有効」パラメータで指定した値が満了した後にSIPクライアントがSIPサーバからの過負荷制御パラメータの更新されたセットを受信するまで、過負荷制御は、クライアントと下流SIPサーバとの間の効果ではありません。"
    },
    {
      "indent": 0,
      "text": "4.4. The \"oc-seq\" Parameter",
      "section_title": true,
      "ja": "4.4。 \"OC-seqの\" パラメータ"
    },
    {
      "indent": 3,
      "text": "This parameter MUST be inserted by the SIP server in a response; it MUST NOT be inserted by the SIP client in a request.",
      "ja": "このパラメータは、応答してSIPサーバによって挿入されなければなりません。それは、リクエストにSIPクライアントによって挿入されてはなりません。"
    },
    {
      "indent": 3,
      "text": "This parameter contains an unsigned integer value that indicates the sequence number associated with the \"oc\" parameter. This sequence number is used to differentiate two \"oc\" parameter values generated by an overload control algorithm at two different instants in time. \"oc\" parameter values generated by an overload control algorithm at time t and t+1 MUST have an increasing value in the \"oc-seq\" parameter. This allows the upstream SIP client to properly collate out-of-order responses.",
      "ja": "このパラメータは、「OC」パラメータに関連付けられたシーケンス番号を示す符号なし整数値を含みます。このシーケンス番号は、時間内の2つの異なる時点で過負荷制御アルゴリズムによって生成された2つの「OC」のパラメータ値を区別するために使用されます。時刻tとt + 1における過負荷制御アルゴリズムによって生成された「OC」パラメータ値は、「OC-配列」パラメータで増加する値を持たなければなりません。これは、上流のSIPクライアントが適切にアウト・オブ・オーダー応答を照合することができます。"
    },
    {
      "indent": 6,
      "text": "Note: A timestamp can be used as a value of the \"oc-seq\" parameter.",
      "ja": "注：タイムスタンプは、「OC-配列」パラメータの値として使用することができます。"
    },
    {
      "indent": 3,
      "text": "If the value contained in the \"oc-seq\" parameter overflows during the period in which the load reduction is in effect, then the \"oc-seq\" parameter MUST be reset to the current timestamp or an appropriate base value.",
      "ja": "「OC-配列」パラメータに含まれる値が負荷の低減が有効である期間においてオーバーフローした場合は、「OC-配列」パラメータは、現在のタイムスタンプ、または適切なベース値にリセットされなければなりません。"
    },
    {
      "indent": 6,
      "text": "Note: A client implementation can recognize that an overflow has occurred when it receives an \"oc-seq\" parameter whose value is significantly less than several previous values. (Note that an \"oc-seq\" parameter whose value does not deviate significantly from the last several previous values is symptomatic of a tardy packet. However, overflow will cause the \"oc-seq\" parameter value to be significantly less than the last several values.) If an overflow is detected, then the client should use the overload parameters in the new message, even though the sequence number is lower. The client should also reset any internal state to reflect the overflow so that future messages (following the overflow) will be accepted.",
      "ja": "注意：クライアントの実装は、その値は、いくつかの以前の値よりも有意に低い「OC-seqの」パラメータを受信したときにオーバーフローが発生したことを認識することができます。 （その値は、最後のいくつか前の値から大きく外れていない「OC-seqの」パラメータが遅刻パケットの対症療法であることに注意してください。ただし、オーバーフローは「OC-seqの」パラメータ値は最後の数よりも大幅に少ないことが原因となりますオーバーフローが検出された場合の値。）、クライアントは、シーケンス番号が低い場合であっても、新しいメッセージで過負荷パラメータを使用すべきです。また、クライアントは、（オーバーフロー以下）将来のメッセージが受け入れられるように、オーバーフローを反映するために、任意の内部状態をリセットする必要があります。"
    },
    {
      "indent": 0,
      "text": "5. General Behavior",
      "section_title": true,
      "ja": "5.一般的な動作"
    },
    {
      "indent": 3,
      "text": "When forwarding a SIP request, a SIP client uses the SIP procedures of [RFC3263] to determine the next-hop SIP server. The procedures of [RFC3263] take a SIP URI as input, extract the domain portion of that URI for use as a lookup key, query the Domain Name Service (DNS) to obtain an ordered set of one or more IP addresses with a port number and transport corresponding to each IP address in this set (the \"Expected Output\").",
      "ja": "SIPリクエストを転送するとき、SIPクライアントは、ネクストホップSIPサーバを決定するために、[RFC3263]のSIPの手順を使用します。 [RFC3263]の手順は、入力としてSIP URIを取るルックアップキーとして使用するためにそのURIのドメイン部分を抽出し、ポート番号を1つまたは複数のIPアドレスの順序付けられた集合を取得するためにドメインネームサービス（DNS）を照会しますそして輸送は、このセット内の各IPアドレス（「予想される出力」）に対応します。"
    },
    {
      "indent": 3,
      "text": "After selecting a specific SIP server from the Expected Output, a SIP client determines whether overload controls are currently active with that server. If overload controls are currently active (and the \"oc-validity\" period has not yet expired), the client applies the relevant algorithm to determine whether or not to send the SIP request to the server. If overload controls are not currently active with this server (which will be the case if this is the initial contact with the server, the last response from this server had",
      "ja": "予想される出力から特定のSIPサーバを選択した後、SIPクライアントは、過負荷コントロールが現在そのサーバーでアクティブであるかどうかを決定します。過負荷制御は、現在アクティブな（そして、「OC-妥当性」期間がまだ満了していない）、クライアントはサーバーにSIPリクエストを送信するかどうかを判断するために、関連するアルゴリズムを適用した場合。過負荷コントロールは、これは、サーバーとの最初の接触であればケースになる（このサーバで現在アクティブでない場合は、このサーバからの最後の応答がなかったです"
    },
    {
      "indent": 3,
      "text": "\"oc-validity=0\", or the time period indicated by the \"oc-validity\" parameter has expired), the SIP client sends the SIP message to the server without invoking any overload control algorithm.",
      "ja": "「OC-有効= 0」、または「OC-有効」パラメータによって示される期間が満了した）、SIPクライアントは、任意の過負荷制御アルゴリズムを呼び出すことなく、サーバにSIPメッセージを送信します。"
    },
    {
      "indent": 0,
      "text": "5.1. Determining Support for Overload Control",
      "section_title": true,
      "ja": "5.1。過負荷制御のための支援を決定"
    },
    {
      "indent": 3,
      "text": "If a client determines that this is the first contact with a server, the client MUST insert the \"oc\" parameter without any value and MUST insert the \"oc-algo\" parameter with a list of algorithms it supports. This list MUST include \"loss\" and MAY include other algorithm names approved by IANA and described in corresponding documents. The client transmits the request to the chosen server.",
      "ja": "クライアントは、これは、サーバーとの最初の接触であると判断した場合、クライアントは任意の値なしで「OC」のパラメータを挿入しなければなりませんし、それがサポートするアルゴリズムのリストで、「OC-アルゴ」パラメータを挿入しなければなりません。このリストは、「損失」を含まなければならないと他のアルゴリズム名IANAによって承認され、対応する文書に記載を含むかもしれません。クライアントは、選択されたサーバに要求を送信します。"
    },
    {
      "indent": 3,
      "text": "If a server receives a SIP request containing the \"oc\" and \"oc-algo\" parameters, the server MUST determine if it has already selected the overload control algorithm class with this client. If it has, the server SHOULD use the previously selected algorithm class in its response to the message. If the server determines that the message is from a new client or a client the server has not heard from in a long time, the server MUST choose one algorithm from the list of algorithms in the \"oc-algo\" parameter. It MUST put the chosen algorithm as the sole parameter value in the \"oc-algo\" parameter of the response it sends to the client. In addition, if the server is currently not in an overload condition, it MUST set the value of the \"oc\" parameter to be 0 and MAY insert an \"oc-validity=0\" parameter in the response to further qualify the value in the \"oc\" parameter. If the server is currently overloaded, it MUST follow the procedures in Section 5.2.",
      "ja": "サーバは「OC」や「OC-アルゴ」パラメータを含むSIP要求を受信した場合、それはこのクライアントにすでに過負荷制御アルゴリズムのクラスを選択した場合、サーバが判断しなければなりません。それが持っている場合、サーバーは、メッセージへの応答では、以前に選択したアルゴリズムのクラスを使用する必要があります。サーバは、メッセージが新しいクライアントまたはクライアントからあると判断した場合、サーバーが長時間にから聞いていない、サーバーは、「OC-アルゴ」パラメータにアルゴリズムのリストから1つのアルゴリズムを選択する必要があります。それがクライアントに送信するレスポンスの「OC-アルゴ」パラメータで唯一のパラメータ値として選択されたアルゴリズムを置く必要があります。サーバが過負荷状態に現在ない場合に加えて、それが0であることを「OC」パラメータの値を設定しなければなりませんし、さらに内の値を修飾するために応答して、「OC-妥当性= 0」パラメータを挿入することができます\"OC\" のパラメータ。サーバーが現在過負荷になっている場合は、5.2節の手順に従わなければなりません。"
    },
    {
      "indent": 6,
      "text": "Note: A client that supports the rate-based overload control scheme [RATE-CONTROL] will consider \"oc=0\" as an indication not to send any requests downstream at all. Thus, when the server inserts \"oc-validity=0\" as well, it is indicating that it does support overload control, but it is not under overload mode right now (see Section 5.7).",
      "ja": "注意：検討するレートベースの過負荷制御方式[RATE-CONTROL]をサポートするクライアントを「OC = 0」下流まったく要求を送信しないように指示として。したがって、サーバインサート「OC-有効= 0」も、過負荷制御をサポートすることを示しているが、それは（セクション5.7を参照）今、過負荷モードではない場合。"
    },
    {
      "indent": 0,
      "text": "5.2. Creating and Updating the Overload Control Parameters",
      "section_title": true,
      "ja": "5.2。過負荷制御パラメータを作成および更新"
    },
    {
      "indent": 3,
      "text": "A SIP server provides overload control feedback to its upstream clients by providing a value for the \"oc\" parameter to the topmost Via header field of a SIP response, that is, the Via header added by the client before it sent the request to the server.",
      "ja": "SIPサーバは、SIPレスポンスのヘッダフィールドを介して最上位に「OC」パラメータの値を提供することによって、その上流クライアントに過負荷制御フィードバックを提供し、それがサーバにリクエストを送信する前に、即ち、Viaヘッダは、クライアントが追加します。"
    },
    {
      "indent": 3,
      "text": "Since the topmost Via header of a response will be removed by an upstream client after processing it, overload control feedback contained in the \"oc\" parameter will not travel beyond the upstream",
      "ja": "応答のViaヘッダー最上がそれを処理した後、上流側クライアントによって除去されるので、「OC」パラメータに含まれる過負荷制御フィードバックは、上流超えて移動しないであろう"
    },
    {
      "indent": 3,
      "text": "SIP client. A Via header parameter therefore provides hop-by-hop semantics for overload control feedback (see [RFC6357]) even if the next-hop neighbor does not support this specification.",
      "ja": "SIPクライアント。 Viaヘッダパラメータは、したがって、ネクストホップネイバーがこの仕様をサポートしていない場合であっても（[RFC6357]を参照）過負荷制御フィードバックのためのホップ・バイ・ホップのセマンティクスを提供します。"
    },
    {
      "indent": 3,
      "text": "The \"oc\" parameter can be used in all response types, including provisional, success, and failure responses (please see Section 5.11 for special consideration on transporting overload control parameters in a 100 Trying response). A SIP server can update the \"oc\" parameter in a response, asking the client to increase or decrease the number of requests destined to the server or to stop performing overload control altogether.",
      "ja": "「OC」パラメータは（100 Trying応答で過負荷制御パラメータの輸送に特別な配慮については、セクション5.11を参照してください）すべての仮、成功を含む応答の種類、および障害応答で使用することができます。 SIPサーバは、増減のサーバ宛ての要求の数をか、完全に過負荷制御の実行を停止するために、クライアントを求め、応じて「OC」のパラメータを更新することができます。"
    },
    {
      "indent": 3,
      "text": "A SIP server that has updated the \"oc\" parameter SHOULD also add a \"oc-validity\" parameter. The \"oc-validity\" parameter defines the time in milliseconds during which the overload control feedback specified in the \"oc\" parameter is valid. The default value of the \"oc-validity\" parameter is 500 (milliseconds).",
      "ja": "「OC」のパラメータを更新したSIPサーバはまた、「OC-妥当性」パラメータを追加する必要があります。 「OC-妥当性」パラメータは「OC」パラメータで指定された過負荷制御のフィードバックが有効である間の時間をミリ秒単位で定義します。 「OC-妥当性」パラメータのデフォルト値は500（ミリ秒）です。"
    },
    {
      "indent": 3,
      "text": "When a SIP server retransmits a response, it SHOULD use the \"oc\" and \"oc-validity\" parameter values consistent with the overload state at the time the retransmitted response was sent. This implies that the values in the \"oc\" and \"oc-validity\" parameters may be different than the ones used in previous retransmissions of the response. Due to the fact that responses sent over UDP may be subject to delays in the network and arrive out of order, the \"oc-seq\" parameter aids in detecting a stale \"oc\" parameter value.",
      "ja": "SIPサーバが応答を再送信すると、それが再送され、応答が送信された時点での過負荷状態と一致し、「OC」や「OC-妥当性」のパラメータ値を使用すべきです。これは、「OC」の値と「OC-妥当性」のパラメータは、応答の前の再送信に使用されているものとは異なる可能性があることを意味しています。 UDPを介して送信される応答が古く「OC」パラメータの値を検出することで、ネットワークの遅延を受けることと順不同で到着する、「OC-配列」パラメータエイズできるという事実によります。"
    },
    {
      "indent": 3,
      "text": "Implementations that are capable of updating the \"oc\" and \"oc-validity\" parameter values during retransmissions MUST insert the \"oc-seq\" parameter. The value of this parameter MUST be a set of numbers drawn from an increasing sequence.",
      "ja": "再送信の際に「OC」や「OC-妥当性」のパラメータ値を更新することができる実装は、「OC-seqの」パラメータを挿入しなければなりません。このパラメータの値が増加するシーケンスから引き出された番号の設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Implementations that are not capable of updating the \"oc\" and \"oc-validity\" parameter values during retransmissions -- or implementations that do not want to do so because they will have to regenerate the message to be retransmitted -- MUST still insert a \"oc-seq\" parameter in the first response associated with a transaction; however, they do not have to update the value in subsequent retransmissions.",
      "ja": "彼らは再送信するメッセージを再生成する必要がありますので、そうしたくないか、実装 -   - 再送信の際に「OC」や「OC-妥当性」のパラメータ値を更新することができない実装はまだ \"を挿入しなければなりませんトランザクションに関連付けられた最初の応答のOC-seqの」パラメータ。しかし、彼らは、その後の再送信の値を更新する必要はありません。"
    },
    {
      "indent": 3,
      "text": "The \"oc-validity\" and \"oc-seq\" Via header parameters are only defined in SIP responses and MUST NOT be used in SIP requests. These parameters are only useful to the upstream neighbor of a SIP server (i.e., the entity that is sending requests to the SIP server) since the client is the entity that can offload traffic by redirecting or rejecting new requests. If requests are forwarded in both directions between two SIP servers (i.e., the roles of upstream/downstream neighbors change), there are also responses flowing in both directions. Thus, both SIP servers can exchange overload information.",
      "ja": "ヘッダパラメータで、「OC-妥当性」と「OC-seqのは、」のみSIP応答で定義され、SIPリクエストに使用してはいけません。クライアントが新しい要求をリダイレクトするか、拒否することによって、トラフィックをオフロードすることができますエンティティであるため、これらのパラメータは、SIPサーバ（SIPサーバに要求を送信している、すなわち、実体）の上流の隣人にのみ有用です。要求は2台のSIPサーバ（すなわち、上流/下流の近隣の役割が変更）との間の両方向に転送される場合、両方向に流れる応答もあります。このように、両方のSIPサーバは、過負荷情報を交換することができます。"
    },
    {
      "indent": 3,
      "text": "This specification provides a good overload control mechanism that can protect a SIP server from overload. However, if a SIP server wants to limit advertisements of overload control capability for privacy reasons, it might decide to perform overload control only for requests that are received on a secure transport, such as Transport Layer Security (TLS). Indicating support for overload control on a request received on an untrusted link can leak privacy in the form of capabilities supported by the server. To limit the knowledge that the server supports overload control, a server can adopt a policy of inserting overload control parameters in only those requests received over trusted links such that these parameters are only visible to trusted neighbors.",
      "ja": "この仕様は、過負荷からSIPサーバを保護することができ、良好な過負荷制御メカニズムを提供します。 SIPサーバは、プライバシー上の理由から、過負荷制御機能の広告を制限したい場合は、それだけで、このようなトランスポート層セキュリティ（TLS）などの安全な輸送に受信された要求のために過負荷制御を行うことにしたかもしれません。サーバーでサポートされている機能の形でプライバシーを漏洩することができ、信頼できないリンクで受信した要求の過負荷制御のためのサポートを示します。サーバが過負荷制御をサポートしているという知識を制限するには、サーバーは、これらのパラメータは、信頼できる隣人にのみ表示されるように、信頼できるリンクを介して受信した要求のみで過負荷制御パラメータを挿入する方針を採用することができます。"
    },
    {
      "indent": 0,
      "text": "5.3. Determining the \"oc\" Parameter Value",
      "section_title": true,
      "ja": "5.3。 「OC」パラメータ値の決定"
    },
    {
      "indent": 3,
      "text": "The value of the \"oc\" parameter is determined by the overloaded server using any pertinent information at its disposal. The only constraint imposed by this document is that the server control algorithm MUST produce a value for the \"oc\" parameter that it expects the receiving SIP clients to apply to all downstream SIP requests (dialogue forming as well as in-dialogue) to this SIP server. Beyond this stipulation, the process by which an overloaded server determines the value of the \"oc\" parameter is considered out of the scope of this document.",
      "ja": "「OC」パラメータの値は、その処分で任意の適切な情報を使用して過負荷のサーバーによって決定されます。この文書によって課される唯一の制約は、サーバ制御アルゴリズムは、それが受信SIPクライアントは、このSIPにすべての下流SIPリクエスト（対話形成ならびにイン対話）に適用することを期待「OC」パラメータの値を生成しなければならないということですサーバ。この規定を超えて、過負荷サーバは「OC」パラメータの値を決定するプロセスは、この文書の範囲外であると考えられます。"
    },
    {
      "indent": 6,
      "text": "Note: This stipulation is required so that both the client and server have a common view of which messages the overload control applies to. With this stipulation in place, the client can prioritize messages as discussed in Section 5.10.1.",
      "ja": "注意：クライアントとサーバーの両方が過負荷制御が適用されたメッセージの一般的な見解を持っているように、この規定が必要です。セクション5.10.1で述べたような場所では、この規定では、クライアントは、メッセージに優先順位をつけることができます。"
    },
    {
      "indent": 3,
      "text": "As an example, a value of \"oc=10\" when the loss-based algorithm is used implies that 10% of the total number of SIP requests (dialogue forming as well as in-dialogue) are subject to reduction at the client. Analogously, a value of \"oc=10\" when the rate-based algorithm [RATE-CONTROL] is used indicates that the client should send SIP requests at a rate of 10 SIP requests or fewer per second.",
      "ja": "一例として、損失ベースのアルゴリズムが使用されている「OC = 10」の値は、SIPリクエスト（対話形成同様に、対話など）の総数の10％がクライアントに還元を受けやすいことを意味します。同様に、「OC = 10」の値が使用されるレートに基づくアルゴリズム[レート制御]は、クライアントが毎秒10のSIPリクエストまたはそれ以下の速度で、SIPリクエストを送信する必要があることを示す場合。"
    },
    {
      "indent": 0,
      "text": "5.4. Processing the Overload Control Parameters",
      "section_title": true,
      "ja": "5.4。過負荷制御パラメータを処理"
    },
    {
      "indent": 3,
      "text": "A SIP client SHOULD remove the \"oc\", \"oc-validity\", and \"oc-seq\" parameters from all Via headers of a response received, except for the topmost Via header. This prevents overload control parameters that were accidentally or maliciously inserted into Via headers by a downstream SIP server from traveling upstream.",
      "ja": "SIPクライアントは、Viaヘッダー最上部を除いて、受信した応答の全てのViaヘッダから「OC」、「OC-妥当性」、および「OC-配列」パラメータを削除してください。これは、偶然または故意の上流から下流に走行SIPサーバでのViaヘッダに挿入された過負荷制御パラメータを防止します。"
    },
    {
      "indent": 3,
      "text": "The scope of overload control applies to unique combinations of IP and port values. A SIP client maintains the overload control values received (along with the address and port number of the SIP servers from which they were received) for the duration specified in the \"oc-validity\" parameter or the default duration. Each time a SIP client receives a response with an overload control parameter from a downstream SIP server, it compares the \"oc-seq\" value extracted from the Via header with the \"oc-seq\" value stored for this server. If these values match, the response does not update the overload control parameters related to this server, and the client continues to provide overload control as previously negotiated. If the \"oc-seq\" value extracted from the Via header is larger than the stored value, the client updates the stored values by copying the new values of the \"oc\", \"oc-algo\", and \"oc-seq\" parameters from the Via header to the stored values. Upon such an update of the overload control parameters, the client restarts the validity period of the new overload control parameters. The overload control parameters now remain in effect until the validity period expires or the parameters are updated in a new response. Stored overload control parameters MUST be reset to default values once the validity period has expired (see Section 5.7 for the detailed steps on terminating overload control).",
      "ja": "過負荷制御の範囲は、IPとポートの値のユニークな組み合わせに適用されます。 SIPクライアントは、過負荷制御値は、「OC-妥当性」パラメータまたはデフォルトの期間で指定された期間（それらが受信されたからSIPサーバのアドレスとポート番号と一緒に）受け取っ維持しています。 SIPクライアントが下流SIPサーバからの過負荷制御パラメータを使用して応答を受信するたびに、このサーバーに格納されている「OC-配列」値とViaヘッダから抽出された「OC-配列」の値とを比較します。これらの値が一致した場合、応答は、このサーバーに関連した過負荷制御パラメータを更新しないと、クライアントは以前に交渉して過負荷制御を提供し続けています。 Viaヘッダから抽出された「OC-配列」値が格納された値よりも大きい場合、クライアントは、「OC」の新しい値をコピーすることによって、「OC-ALGO」、および「OC-配列」パラメータが格納された値を更新しますViaヘッダから記憶された値です。過負荷制御パラメータのように更新されると、クライアントは、新たな過負荷制御パラメータの有効期間を再起動します。過負荷制御パラメータは現在、有効期間が満了するまで有効またはパラメータは、新しい応じて更新されます。保存された過負荷制御パラメータは、（過負荷制御を終了に関する詳細な手順については、セクション5.7を参照）有効期間が満了した後の値をデフォルトにリセットする必要があります。"
    },
    {
      "indent": 0,
      "text": "5.5. Using the Overload Control Parameter Values",
      "section_title": true,
      "ja": "5.5。過負荷制御パラメータ値を使用して"
    },
    {
      "indent": 3,
      "text": "A SIP client MUST honor overload control values it receives from downstream neighbors. The SIP client MUST NOT forward more requests to a SIP server than allowed by the current \"oc\" and \"oc-algo\" parameter values from that particular downstream server.",
      "ja": "SIPクライアントはそれが下流のネイバーから受信した過負荷制御値を尊重しなければなりません。 SIPクライアントは順方向電流「OC」とその特定のダウンストリームサーバーから「OC-アルゴ」のパラメータ値によって許可さよりも、SIPサーバへの多くの要求をしてはなりません。"
    },
    {
      "indent": 3,
      "text": "When forwarding a SIP request, a SIP client uses the SIP procedures of [RFC3263] to determine the next-hop SIP server. The procedures of [RFC3263] take a SIP URI as input, extract the domain portion of that URI for use as a lookup key, query the DNS to obtain an ordered set of one or more IP addresses with a port number and transport corresponding to each IP address in this set (the Expected Output).",
      "ja": "SIPリクエストを転送するとき、SIPクライアントは、ネクストホップSIPサーバを決定するために、[RFC3263]のSIPの手順を使用します。 [RFC3263]の手順は、入力としてSIP URIを取るルックアップキーとして使用するためにそのURIのドメイン部分を抽出し、ポート番号、トランスポートはそれぞれに対応する1つ以上のIPアドレスの順序付けられた集合を取得するためにDNSに照会しこのセットのIPアドレス（期待される出力）。"
    },
    {
      "indent": 3,
      "text": "After selecting a specific SIP server from the Expected Output, the SIP client determines if it already has overload control parameter values for the server chosen from the Expected Output. If the SIP client has a non-expired \"oc\" parameter value for the server chosen from the Expected Output, then this chosen server is operating in overload control mode. Thus, the SIP client determines if it can or cannot forward the current request to the SIP server based on the \"oc\" and \"oc-algo\" parameters and any relevant local policy.",
      "ja": "それはすでに予想される出力から選ばれたサーバの過負荷制御パラメータの値を持っている場合に予想される出力から特定のSIPサーバを選択した後、SIPクライアントが決定します。 SIPクライアントが予想される出力から選択するサーバの非期限切れの「OC」パラメータの値を持っている場合、この選択したサーバが過負荷制御モードで動作しています。それはまたは「OC」や「OC-アルゴ」のパラメータおよび関連するローカルポリシーに基づいてSIPサーバへの現在の要求を転送することができないことができればこのように、SIPクライアントが決定します。"
    },
    {
      "indent": 3,
      "text": "The particular algorithm used to determine whether or not to forward a particular SIP request is a matter of local policy and may take into account a variety of prioritization factors. However, this local policy SHOULD transmit the same number of SIP requests as the sample algorithm defined by the overload control scheme being used. (See Section 7.2 for the default loss-based overload control algorithm.)",
      "ja": "特定のSIPリクエストを転送するか否かを決定するために使用される特定のアルゴリズムは、ローカルポリシーの問題であり、アカウントに優先順位付け様々な要因を取ることができます。しかし、このローカルポリシーは、使用される過負荷制御方式によって定義されるサンプルアルゴリズムとしてSIPリクエストの同じ番号を送信しなければなりません。 （デフォルト損失に基づく過負荷制御アルゴリズムについては、セクション7.2を参照してください。）"
    },
    {
      "indent": 0,
      "text": "5.6. Forwarding the Overload Control Parameters",
      "section_title": true,
      "ja": "5.6。過負荷制御パラメータを転送"
    },
    {
      "indent": 3,
      "text": "Overload control is defined in a hop-by-hop manner. Therefore, forwarding the contents of the overload control parameters is generally NOT RECOMMENDED and should only be performed if permitted by the configuration of SIP servers. This means that a SIP proxy SHOULD strip the overload control parameters inserted by the client before proxying the request further downstream. Of course, when the proxy acts as a client and proxies the request downstream, it is free to add overload control parameters pertinent to itself in the Via header it inserted in the request.",
      "ja": "過負荷制御は、ホップバイホップのように定義されています。したがって、過負荷制御パラメータの内容を転送することは一般に推奨されておらず、SIPサーバの設定によって許可されている場合のみ実行されるべきです。これは、SIPプロキシが、さらに下流の要求をプロキシする前に、クライアントによって挿入された過負荷制御パラメータを削除すべきであることを意味します。プロキシは、クライアントとプロキシ下流要求として働く場合もちろん、リクエストに挿入Viaヘッダに自身に関連する過負荷制御パラメータを追加して自由です。"
    },
    {
      "indent": 0,
      "text": "5.7. Terminating Overload Control",
      "section_title": true,
      "ja": "5.7。過負荷制御を終了"
    },
    {
      "indent": 3,
      "text": "A SIP client removes overload control if one of the following events occur:",
      "ja": "次のいずれかのイベントが発生した場合、SIPクライアントは、過負荷制御を削除します。"
    },
    {
      "indent": 3,
      "text": "1. The \"oc-validity\" period previously received by the client from this server (or the default value of 500 ms if the server did not previously specify an \"oc-validity\" parameter) expires.",
      "ja": "1.（サーバは以前、「OC-妥当性」パラメータを指定しなかった場合は500ミリ秒のデフォルト値）以前にこのサーバーからクライアントが受信した「OC-妥当性」期間が満了します。"
    },
    {
      "indent": 3,
      "text": "2. The client is explicitly told by the server to stop performing overload control using the \"oc-validity=0\" parameter.",
      "ja": "2.クライアントは、明示的に「OC-妥当性= 0」パラメータを使用して過負荷制御の実行を停止するためにサーバによって語られています。"
    },
    {
      "indent": 3,
      "text": "A SIP server can decide to terminate overload control by explicitly signaling the client. To do so, the SIP server MUST set the value of the \"oc-validity\" parameter to 0. The SIP server MUST increment the value of \"oc-seq\" and SHOULD set the value of the \"oc\" parameter to 0.",
      "ja": "SIPサーバは、明示的にクライアントに信号を送ることにより、過負荷制御を終了することを決定することができます。そのためには、SIPサーバは、SIPサーバは、「OC-seqの」の値をインクリメントしなければならなくて、0に「OC」パラメータの値を設定する必要が0に「OC-妥当性」パラメータの値を設定しなければなりません。"
    },
    {
      "indent": 6,
      "text": "Note that the loss-based overload control scheme (Section 7) can effectively stop overload control by setting the value of the \"oc\" parameter to 0. However, the rate-based scheme [RATE-CONTROL] needs an additional piece of information in the form of \"oc-validity=0\".",
      "ja": "損失ベースの過負荷制御方式（第7章）が効果的に0に「OC」パラメータの値を設定することにより、過負荷制御を停止することができることに注意してくださいしかし、レートベースのスキーム[レート制御]は、情報の追加部分を必要と\"OC-妥当性= 0\" の形。"
    },
    {
      "indent": 3,
      "text": "When the client receives a response with a higher \"oc-seq\" number than the one it most recently processed, it checks the \"oc-validity\" parameter. If the value of the \"oc-validity\" parameter is 0, this indicates to the client that overload control of messages destined to the server is no longer necessary and the traffic can flow without any reduction. Furthermore, when the value of the \"oc-validity\" parameter is 0, the client SHOULD disregard the value in the \"oc\" parameter.",
      "ja": "クライアントは、それが処理された最新のものより高い「OC-seqの」数のレスポンスを受信すると、それは「OC-妥当性」パラメータをチェックします。 「OC-妥当性」パラメータの値が0の場合、これはもはや必要であり、トラフィックは任意の削減なしに流れることができるサーバに送信されるメッセージの制御をオーバーロードクライアントに示します。 「OC-妥当性」パラメータの値が0であるとき、また、クライアントは「OC」のパラメータの値を無視すべきです。"
    },
    {
      "indent": 0,
      "text": "5.8. Stabilizing Overload Algorithm Selection",
      "section_title": true,
      "ja": "5.8。過負荷アルゴリズムの選択を安定させます"
    },
    {
      "indent": 3,
      "text": "Realities of deployments of SIP necessitate that the overload control algorithm may be changed upon a system reboot or a software upgrade. However, frequent changes of the overload control algorithm must be avoided. Frequent changes of the overload control algorithm will not benefit the client or the server as such flapping does not allow the chosen algorithm to stabilize. An algorithm change, when desired, is simply accomplished by the SIP server choosing a new algorithm from the list in the client's \"oc-algo\" parameter and sending it back to the client in a response.",
      "ja": "SIPの展開の現実は、過負荷制御アルゴリズムは、システムの再起動やソフトウェアのアップグレード時に変更されることが必要。しかし、過負荷制御アルゴリズムの頻繁な変更は避けなければなりません。そのようなフラッピングが選択されたアルゴリズムが安定することはできませんので、過負荷制御アルゴリズムの頻繁な変更は、クライアントまたはサーバのメリットはありません。アルゴリズムの変更は、必要なときには、単にSIPサーバ、クライアントの「OC-アルゴ」パラメータのリストから新しいアルゴリズムを選択し、それに応答して、それをクライアントに送り返すことによって達成されます。"
    },
    {
      "indent": 3,
      "text": "The client associates a specific algorithm with each server it sends traffic to, and when the server changes the algorithm, the client must change its behavior accordingly.",
      "ja": "クライアントは、それがにトラフィックを送信する各サーバーに特定のアルゴリズムを関連付けて、サーバは、アルゴリズムを変更した場合、クライアントはそれに応じてその動作を変更する必要があります。"
    },
    {
      "indent": 3,
      "text": "Once the server selects a specific overload control algorithm for a given client, the algorithm SHOULD NOT change the algorithm associated with that client for at least 3600 seconds (1 hour). This period may involve one or more cycles of overload control being in effect and then being stopped depending on the traffic and resources at the server.",
      "ja": "サーバが特定のクライアントのための具体的な過負荷制御アルゴリズムを選択すると、このアルゴリズムは、少なくとも3600秒（1時間）のために、そのクライアントに関連したアルゴリズムを変更しないでください。この期間は有効であること、過負荷制御の1サイクル以上を含むことができるし、サーバーのトラフィックやリソースに応じて停止されます。"
    },
    {
      "indent": 6,
      "text": "Note: One way to accomplish this involves the server saving the time of the last algorithm change in a lookup table, indexed by the client's network identifiers. The server only changes the \"oc-algo\" parameter when the time since the last change has surpassed 3600 seconds.",
      "ja": "注意：これを実現する一つの方法は、クライアントのネットワーク識別子によってインデックス付けたルックアップテーブル内の最後のアルゴリズムの変更、時間を節約するサーバーを必要とします。サーバーは、最後の変更からの時間が3600秒を超えている「OC-アルゴ」パラメータを変更します。"
    },
    {
      "indent": 0,
      "text": "5.9. Self-Limiting",
      "section_title": true,
      "ja": "5.9。自己制限"
    },
    {
      "indent": 3,
      "text": "In some cases, a SIP client may not receive a response from a server after sending a request. RFC 3261 [RFC3261] states:",
      "ja": "いくつかのケースでは、SIPクライアントが要求を送信した後、サーバーからの応答を受信しないことがあります。 RFC 3261 [RFC3261]は述べています："
    },
    {
      "indent": 6,
      "text": "Note: When a timeout error is received from the transaction layer, it MUST be treated as if a 408 (Request Timeout) status code has been received. If a fatal transport error is reported by the transport layer ..., the condition MUST be treated as a 503 (Service Unavailable) status code.",
      "ja": "注：タイムアウトエラーがトランザクション層から受信された場合408（要求タイムアウト）ステータスコードが受信されたかのように扱われなければなりません。致命的なトランスポート・エラーがトランスポート層...によって報告された場合、条件は503（サービス利用不可）ステータスコードとして扱わなければなりません。"
    },
    {
      "indent": 3,
      "text": "In the event of repeated timeouts or fatal transport errors, the SIP client MUST stop sending requests to this server. The SIP client SHOULD periodically probe if the downstream server is alive using any mechanism at its disposal. Clients should be conservative in their probing (e.g., using an exponential back-off) so that their liveness probes do not exacerbate an overload situation. Once a SIP client has successfully received a normal response for a request sent to the downstream server, the SIP client can resume sending SIP requests. It should, of course, honor any overload control parameters it may receive in the initial, or later, responses.",
      "ja": "繰り返しタイムアウトや致命的なトランスポートエラーが発生した場合は、SIPクライアントは、このサーバへのリクエストの送信を停止しなければなりません。ダウンストリームサーバーは、その処分で任意のメカニズムを使用して生きている場合は、SIPクライアントは、定期的に精査すべきです。彼らの生存性プローブは、過負荷状況を悪化させないように、クライアントは、プローブ（例えば、指数バックオフを使用して）に保守的であるべきです。 SIPクライアントが正常にダウンストリームサーバーに送信された要求に対する正常な応答を受信すると、SIPクライアントは、SIPリクエストの送信を再開することができます。それは、もちろん、それは、最初の、以降の応答で受け取ることができる任意の過負荷制御パラメータを尊重すべきです。"
    },
    {
      "indent": 0,
      "text": "5.10. Responding to an Overload Indication",
      "section_title": true,
      "ja": "5.10。過負荷表示への対応"
    },
    {
      "indent": 3,
      "text": "A SIP client can receive overload control feedback indicating that it needs to reduce the traffic it sends to its downstream server. The client can accomplish this task by sending some of the requests that would have gone to the overloaded element to a different destination.",
      "ja": "SIPクライアントは、それがその下流のサーバに送信するトラフィックを軽減する必要があることを示す過負荷制御のフィードバックを受けることができます。クライアントは、異なる宛先への過負荷の要素に行っていた要求の一部を送信することで、このタスクを達成することができます。"
    },
    {
      "indent": 3,
      "text": "It needs to ensure, however, that this destination is not in overload and is capable of processing the extra load. A client can also buffer requests in the hope that the overload condition will resolve quickly and the requests can still be forwarded in time. In many cases, however, it will need to reject these requests with a \"503 (Service Unavailable)\" response without the Retry-After header.",
      "ja": "それはこの先が過負荷ではなく、余分な負荷を処理することが可能であること、しかし、確認する必要があります。また、クライアントは、過負荷状態が急速に解決されると、要求はまだ時間で転送することができることを期待して要求をバッファリングすることができます。しかし、多くの場合、それは再試行-Afterヘッダなしの「503（サービス利用不可）」応答でこれらの要求を拒否する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.10.1. Message Prioritization at the Hop before the Overloaded Server",
      "section_title": true,
      "ja": "5.10.1。オーバーロードServerの前のホップでのメッセージの優先順位付け"
    },
    {
      "indent": 3,
      "text": "During an overload condition, a SIP client needs to prioritize requests and select those requests that need to be rejected or redirected. This selection is largely a matter of local policy. It is expected that a SIP client will follow local policy as long as the result in reduction of traffic is consistent with the overload algorithm in effect at that node. Accordingly, the normative behavior in the next three paragraphs should be interpreted with the understanding that the SIP client will aim to preserve local policy to the fullest extent possible.",
      "ja": "過負荷状態の間に、SIPクライアントは、要求に優先順位を付け、拒否またはリダイレクトする必要がこれらの要求を選択する必要があります。この選択は、主にローカルポリシーの問題です。 SIPクライアントがいる限り、そのノードで有効な過負荷アルゴリズムと一致しているトラフィックの低減に結果としてローカルポリシーに従うことが期待されます。したがって、次の3つのパラグラフで規範的な行動は、SIPクライアントが可能最大限にローカルポリシーを維持することを目指すことを理解して解釈されるべきです。"
    },
    {
      "indent": 3,
      "text": "A SIP client SHOULD honor the local policy for prioritizing SIP requests such as policies based on message type, e.g., INVITEs versus requests associated with existing sessions.",
      "ja": "SIPクライアントがそのようなメッセージタイプに基づいてポリシーとしてSIPリクエストに優先順位を付けるためのローカルポリシーを尊重すべきである、例えば、既存のセッションに関連付けられた要求に対して誘います。"
    },
    {
      "indent": 3,
      "text": "A SIP client SHOULD honor the local policy for prioritizing SIP requests based on the content of the Resource-Priority header (RPH) [RFC4412]. Specific (namespace.value) RPH contents may indicate high-priority requests that should be preserved as much as possible during overload. The RPH contents can also indicate a low-priority request that is eligible to be dropped during times of overload.",
      "ja": "SIPクライアントは、リソース優先順位ヘッダ（RPH）[RFC4412]の内容に基づいてSIP要求を優先順位付けするためのローカルポリシーを尊重すべきです。特定（namespace.value）RPH内容は、過負荷時にできるだけ保存されるべき優先度の高い要求を示してもよいです。 RPHの内容も、過負荷の時間中に削除の対象である低優先度の要求を示すことができます。"
    },
    {
      "indent": 3,
      "text": "A SIP client SHOULD honor the local policy for prioritizing SIP requests relating to emergency calls as identified by the SOS URN [RFC5031] indicating an emergency request. This policy ensures that",
      "ja": "SIPクライアントは緊急要求を示すSOS URN [RFC5031]によって識別されるように、緊急呼に関連するSIPリクエストに優先順位を付けるためのローカルポリシーを尊重すべきです。このポリシーは、ことを保証します"
    },
    {
      "indent": 3,
      "text": "when a server is overloaded and non-emergency calls outnumber emergency calls in the traffic arriving at the client, the few emergency calls will be given preference. If, on the other hand, the server is overloaded and the majority of calls arriving at the client are emergency in nature, then no amount of message prioritization will ensure the delivery of all emergency calls if the client is to reduce the amount of traffic as requested by the server.",
      "ja": "サーバが過負荷になっていると、非緊急呼び出しがクライアントに到着するトラフィックに緊急コールを上回ったときに、いくつかの緊急コールが優先されます。一方、サーバーが過負荷とクライアントに到着する通話の大半は自然の中で緊急事態ですされている場合は、クライアントのように、トラフィックの量を減少させることであるならば、そのメッセージの優先順位付けのない量は、すべての緊急コールの配信を保証しませんサーバーによって要求されました。"
    },
    {
      "indent": 3,
      "text": "A local policy can be expected to combine both the SIP request type and the prioritization markings, and it SHOULD be honored when overload conditions prevail.",
      "ja": "ローカルポリシーは、SIPリクエストの種類と優先順位付けのマーキングの両方を組み合わせることが期待でき、かつ過負荷条件が優先するとき、それは光栄れるべきです。"
    },
    {
      "indent": 0,
      "text": "5.10.2. Rejecting Requests at an Overloaded Server",
      "section_title": true,
      "ja": "5.10.2。オーバーロードされたサーバーに要求を拒否"
    },
    {
      "indent": 3,
      "text": "If the upstream SIP client to the overloaded server does not support overload control, it will continue to direct requests to the overloaded server. Thus, for the non-participating client, the overloaded server must bear the cost of rejecting some requests from the client as well as the cost of processing the non-rejected requests to completion. It would be fair to devote the same amount of processing at the overloaded server to the combination of rejection and processing from a non-participating client as the overloaded server would devote to processing requests from a participating client. This is to ensure that SIP clients that do not support this specification don't receive an unfair advantage over those that do.",
      "ja": "オーバーロードされたサーバーへのアップストリームSIPクライアントは、過負荷制御をサポートしていない場合、それはオーバーロードされたサーバに要求を指示していきます。このように、非参加するクライアントのために、オーバーロードされたサーバは、クライアントからのいくつかの要求を拒否するコストだけでなく、完了までの非拒否した要求を処理するコストを負担しなければなりません。オーバーロードされたサーバが参加し、クライアントからの処理要求に捧げるように、非参加クライアントからの拒絶反応および処理の組み合わせに過負荷のサーバーでの処理と同じ量を捧げるために公平だろう。これは、この仕様をサポートしていないSIPクライアントが行うものの上に不当な優位性を受け取らないようにすることです。"
    },
    {
      "indent": 3,
      "text": "A SIP server that is in overload and has started to throttle incoming traffic MUST reject some requests from non-participating clients with a 503 (Service Unavailable) response without the Retry-After header.",
      "ja": "過負荷であると着信トラフィックを絞るために開始したSIPサーバは再試行-Afterヘッダなしの503（サービス使用不可）レスポンスと非参加クライアントからいくつかの要求を拒絶しなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.11. 100 Trying Provisional Response and Overload Control Parameters",
      "section_title": true,
      "ja": "5.11。 100個のしようと暫定応答および過負荷制御パラメータ"
    },
    {
      "indent": 3,
      "text": "The overload control information sent from a SIP server to a client is transported in the responses. While implementations can insert overload control information in any response, special attention should be accorded to overload control information transported in a 100 Trying response.",
      "ja": "クライアントにSIPサーバから送信された過負荷制御情報が応答に搬送されます。実装は任意の応答で過負荷制御情報を挿入することができますが、特別な注意は、100 Trying応答で搬送制御情報をオーバーロードするために与えられるべきです。"
    },
    {
      "indent": 3,
      "text": "Traditionally, the 100 Trying response has been used in SIP to quench retransmissions. In some implementations, the 100 Trying message may not be generated by the transaction user (TU) nor consumed by the TU. In these implementations, the 100 Trying response is generated at the transaction layer and sent to the upstream SIP client. At the receiving SIP client, the 100 Trying is consumed at the transaction layer by inhibiting the retransmission of the corresponding request. Consequently, implementations that insert overload control information in the 100 Trying cannot assume that the upstream SIP client passed the overload control information in the 100 Trying to their corresponding TU. For this reason, implementations that insert overload control information in the 100 Trying MUST re-insert the same (or updated) overload control information in the first non-100 Trying response being sent to the upstream SIP client.",
      "ja": "伝統的に、100 Trying応答は、再送を急冷するためにSIPで使用されてきました。いくつかの実装形態では、100試行メッセージは、トランザクションユーザー（TU）によって生成されないこともTUによって消費されます。これらの実装では、100 Trying応答は、トランザクション層で生成され、上流側のSIPクライアントに送信されます。受信SIPクライアントにおいて、100は、対応する要求の再送を阻害することにより、トランザクション層で消費されてしよう。したがって、試行100に過負荷制御情報を挿入する実装は、上流のSIPクライアントがそれらの対応するTUしようと100で過負荷制御情報を渡すことを想定することができません。このため、第一の非100 Trying応答において同じ（又は更新）過負荷制御情報を再挿入しなければならないしようと100における過負荷制御情報を挿入して実装するための上流のSIPクライアントに送信されます。"
    },
    {
      "indent": 0,
      "text": "6. Example",
      "section_title": true,
      "ja": "6.例"
    },
    {
      "indent": 3,
      "text": "Consider a SIP client, P1, which is sending requests to another downstream SIP server, P2. The following snippets of SIP messages demonstrate how the overload control parameters work.",
      "ja": "別の下流のSIPサーバ、P2に要求を送信しているSIPクライアント、P1を、考えてみましょう。 SIPメッセージの以下のスニペットは、過負荷制御パラメータがどのように働くかを示しています。"
    },
    {
      "indent": 11,
      "text": "INVITE sips:user@example.com SIP/2.0\nVia: SIP/2.0/TLS p1.example.net;\n  branch=z9hG4bK2d4790.1;oc;oc-algo=\"loss,A\"\n...",
      "raw": true
    },
    {
      "indent": 11,
      "text": "SIP/2.0 100 Trying\nVia: SIP/2.0/TLS p1.example.net;\n  branch=z9hG4bK2d4790.1;received=192.0.2.111;\n  oc=0;oc-algo=\"loss\";oc-validity=0\n...",
      "raw": true
    },
    {
      "indent": 3,
      "text": "In the messages above, the first line is sent by P1 to P2. This line is a SIP request; because P1 supports overload control, it inserts the \"oc\" parameter in the topmost Via header that it created. P1 supports two overload control algorithms: \"loss\" and an algorithm called \"A\".",
      "ja": "上記メッセージは、最初の行は、P2にP1によって送られます。この行は、SIP要求です。 P1は、過負荷制御をサポートしているので、それが作成した最上位のViaヘッダに「OC」のパラメータを挿入します。 「損失」と「A」と呼ばれるアルゴリズム：P1は、二つの過負荷制御アルゴリズムをサポートしています。"
    },
    {
      "indent": 3,
      "text": "The second line -- a SIP response -- shows the topmost Via header amended by P2 according to this specification and sent to P1. Because P2 also supports overload control and chooses the loss-based scheme, it sends \"loss\" back to P1 in the \"oc-algo\" parameter. It also sets the value of the \"oc\" and \"oc-validity\" parameters to 0 because it is not currently requesting overload control activation.",
      "ja": "第二行 -  SIP応答 - この仕様に従ってP2により修正及びP1に送らViaヘッダー最上示します。 P2はまた、過負荷制御をサポートし、損失ベースのスキームを選択しますので、「OC-アルゴ」パラメータに戻っP1に「損失」を送信します。それは現在、過負荷制御の活性化を要求していないので、それはまた0に「OC」や「OC-妥当性」のパラメータの値を設定します。"
    },
    {
      "indent": 3,
      "text": "Had P2 not supported overload control, it would have left the \"oc\" and \"oc-algo\" parameters unchanged, thus allowing the client to know that it did not support overload control.",
      "ja": "P2は、過負荷制御をサポートしていなかった、それはこのように、クライアントは、それが過負荷制御をサポートしていませんでしたことを知ってできるように、「OC」や「OC-アルゴ」のパラメータ変わらずに残っているだろう。"
    },
    {
      "indent": 3,
      "text": "At some later time, P2 starts to experience overload. It sends the following SIP message indicating that P1 should decrease the messages arriving to P2 by 20% for 0.5 seconds.",
      "ja": "しばらくして、P2は、過負荷を体験して開始します。これは、P1が0.5秒間、20％P2に到達メッセージを減少させるべきであることを示す、次のSIPメッセージを送信します。"
    },
    {
      "indent": 3,
      "text": "       SIP/2.0 180 Ringing\n       Via: SIP/2.0/TLS p1.example.net;\n         branch=z9hG4bK2d4790.3;received=192.0.2.111;\n         oc=20;oc-algo=\"loss\";oc-validity=500;\n         oc-seq=1282321615.782\n       ...\nAfter some time, the overload condition at P2 subsides.  It then\nchanges the parameter values in the response it sends to P1 to allow\nP1 to send all messages destined to P2.",
      "raw": true
    },
    {
      "indent": 10,
      "text": "SIP/2.0 183 Queued\nVia: SIP/2.0/TLS p1.example.net;\n  branch=z9hG4bK2d4790.4;received=192.0.2.111;\n  oc=0;oc-algo=\"loss\";oc-validity=0;oc-seq=1282321892.439\n...",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7. The Loss-Based Overload Control Scheme",
      "section_title": true,
      "ja": "7.損失に基づく過負荷制御方式"
    },
    {
      "indent": 3,
      "text": "Under a loss-based approach, a SIP server asks an upstream neighbor to reduce the number of requests it would normally forward to this server by a certain percentage. For example, a SIP server can ask an upstream neighbor to reduce the number of requests this neighbor would normally send by 10%. The upstream neighbor then redirects or rejects 10% of the traffic originally destined for that server.",
      "ja": "損失ベースのアプローチの下では、SIPサーバは、通常、一定の割合で、このサーバーに転送しますリクエストの数を減らすために、上流の隣人を要求します。例えば、SIPサーバは、この隣人は通常10％で送信した要求の数を減らすために、上流の隣人を求めることができます。上流の隣人は、その後、本来そのサーバ宛のトラフィックの10％をリダイレクトまたは拒否する。"
    },
    {
      "indent": 3,
      "text": "This section specifies the semantics of the overload control parameters associated with the loss-based overload control scheme. The general behavior of SIP clients and servers is specified in Section 5 and is applicable to SIP clients and servers that implement loss-based overload control.",
      "ja": "このセクションでは、損失ベースの過負荷制御方式に関連した過負荷制御パラメータのセマンティクスを指定します。 SIPクライアントとサーバの一般的な動作は、第5節で指定し、損失ベースの過負荷制御を実現するSIPクライアントとサーバに適用されています。"
    },
    {
      "indent": 0,
      "text": "7.1. Special Parameter Values for Loss-Based Overload Control",
      "section_title": true,
      "ja": "7.1。損失ベースの過負荷制御のための特別なパラメータ値"
    },
    {
      "indent": 3,
      "text": "The loss-based overload control scheme is identified using the token \"loss\". This token appears in the \"oc-algo\" parameter list sent by the SIP client.",
      "ja": "損失ベースの過負荷制御方式は、トークン「損失」を使用して識別されます。このトークンは、SIPクライアントから送信された「OC-アルゴ」パラメータリストに表示されます。"
    },
    {
      "indent": 3,
      "text": "Upon entering the overload state, a SIP server that has selected the loss-based algorithm will assign a value to the \"oc\" parameter. This value MUST be in the range of [0, 100], inclusive. This value indicates to the client the percentage by which the client is to reduce the number of requests being forwarded to the overloaded server. The SIP client may use any algorithm that reduces the traffic it sends to the overloaded server by the amount indicated.",
      "ja": "過負荷状態に入ると、損失ベースのアルゴリズムを選択したSIPサーバは、「OC」パラメータに値を割り当てます。この値は[0、100]、以下の範囲になければなりません。この値は、クライアントにクライアントが過負荷状態のサーバに転送される要求の数を減らすことであることで割合を示します。 SIPクライアントはそれが示された量によって過負荷状態のサーバに送信するトラフィックを減少させる任意のアルゴリズムを使用することができます。"
    },
    {
      "indent": 3,
      "text": "Such an algorithm should honor the message prioritization discussion in Section 5.10.1. While a particular algorithm is not subject to standardization, for completeness, a default algorithm for loss-based overload control is provided in Section 7.2.",
      "ja": "このようなアルゴリズムは、セクション5.10.1でのメッセージの優先順位付けの議論を尊重すべきです。特定のアルゴリズムは、標準化の対象ではないが、完全を期すために、損失ベースの過負荷制御のためのデフォルトのアルゴリズムは、セクション7.2に提供されます。"
    },
    {
      "indent": 0,
      "text": "7.2. Default Algorithm for Loss-Based Overload Control",
      "section_title": true,
      "ja": "7.2。損失ベースの過負荷制御のデフォルトアルゴリズム"
    },
    {
      "indent": 3,
      "text": "This section describes a default algorithm that a SIP client can use to throttle SIP traffic going downstream by the percentage loss value specified in the \"oc\" parameter.",
      "ja": "このセクションでは、SIPクライアントが「OC」パラメータで指定されたパーセント損失値によって下流に行くSIPトラフィックを絞るために使用できるデフォルトのアルゴリズムを説明します。"
    },
    {
      "indent": 3,
      "text": "The client maintains two categories of requests. The first category will include requests that are candidates for reduction, and the second category will include requests that are not subject to reduction except when all messages in the first category have been rejected and further reduction is still needed. Section 5.10.1 contains directives on identifying messages for inclusion in the second category. The remaining messages are allocated to the first category.",
      "ja": "クライアントは、要求の二つのカテゴリーを維持します。最初のカテゴリは、削減のための候補であるリクエストが含まれ、第二のカテゴリーは、最初のカテゴリ内のすべてのメッセージが拒否され、更なる削減がまだ必要とされている場合を除き、削減の対象とならない要求が含まれます。セクション5.10.1は、第二のカテゴリーに含めるためのメッセージを特定のディレクティブが含まれています。残りのメッセージは、最初のカテゴリに割り当てられています。"
    },
    {
      "indent": 3,
      "text": "Under overload condition, the client converts the value of the \"oc\" parameter to a value that it applies to requests in the first category. As a simple example, if \"oc=10\" and 40% of the requests should be included in the first category, then:",
      "ja": "過負荷状態の下では、クライアントは、それが第一のカテゴリー内の要求に適用される値に「OC」パラメータの値に変換します。簡単な例として、もし「OC = 10」と要求の40％は、その後、最初の範疇に含まれるべきです。"
    },
    {
      "indent": 6,
      "text": "10 / 40 * 100 = 25",
      "ja": "１０ ／ ４０ ＊ １００ ＝ ２５"
    },
    {
      "indent": 3,
      "text": "Or, 25% of the requests in the first category can be reduced to get an overall reduction of 10%. The client uses random discard to achieve the 25% reduction of messages in the first category. Messages in the second category proceed downstream unscathed. To affect the 25% reduction rate from the first category, the client draws a random number between 1 and 100 for the request picked from the first category. If the random number is less than or equal to the converted value of the \"oc\" parameter, the request is not forwarded; otherwise, the request is forwarded.",
      "ja": "あるいは、最初のカテゴリ内の要求の25％が10％の全体的な減少を得るために減少させることができます。クライアントは、最初のカテゴリ内のメッセージの25％削減を達成するために、ランダムな廃棄を使用しています。第二のカテゴリー内のメッセージは、下流無傷進みます。最初のカテゴリから25％の削減率に影響を与えるために、クライアントは最初のカテゴリから選んだリクエストのための1から100までの間の乱数を描画します。乱数は、以下「OC」パラメータの換算値に等しい場合、要求は転送されません。そうでない場合は、要求が転送されます。"
    },
    {
      "indent": 3,
      "text": "A reference algorithm is shown below.",
      "ja": "基準アルゴリズムを以下に示します。"
    },
    {
      "indent": 0,
      "text": "cat1 := 80.0 // Category 1 -- Subject to reduction cat2 := 100.0 - cat1 // Category 2 -- Under normal operations, // only subject to reduction after category 1 is exhausted. // Note that the above ratio is simply a reasonable default. // The actual values will change through periodic sampling // as the traffic mix changes over time.",
      "ja": "CAT1：= 80.0 //カテゴリー1  - 削減CAT2の件名：= 100.0  -  CAT1 //カテゴリー2  - 通常の操作の下では、カテゴリー1が排出された後、削減に//のみ対象。 //上記の比率は、単に適切なデフォルトであることに注意してください。 //実際の値は、時間の経過とともに、トラフィックミックスの変化に応じて定期的にサンプリング//によって変化します。"
    },
    {
      "indent": 0,
      "text": "while (true) { // We're modeling message processing as a single work // queue that contains both incoming and outgoing messages. sip_msg := get_next_message_from_work_queue()",
      "ja": "（真）{//我々は両方の受信および送信メッセージを含む単一の作業//キューとしてメッセージ処理をモデル化している間。 sip_msg：= get_next_message_from_work_queue（）"
    },
    {
      "indent": 2,
      "text": "update_mix(cat1, cat2) // See Note below",
      "ja": "update_mix（CAT1、CAT2）//以下の注記を参照してください。"
    },
    {
      "indent": 2,
      "text": "switch (sip_msg.type) {",
      "ja": "スイッチ（sip_msg.type）{"
    },
    {
      "indent": 4,
      "text": "case outbound request: destination := get_next_hop(sip_msg) oc_context := get_oc_context(destination)",
      "ja": "ケース発信要求：先：= get_next_hop（sip_msg）oc_context：= get_oc_context（宛先）"
    },
    {
      "indent": 6,
      "text": "if (oc_context == null) { send_to_network(sip_msg) // Process it normally by // sending the request to the next hop since this // particular destination is not subject to overload. } else { // Determine if server wants to enter in overload or is in // overload. in_oc := extract_in_oc(oc_context) oc_value := extract_oc(oc_context) oc_validity := extract_oc_validity(oc_context)",
      "ja": "IF（oc_context == NULL）{send_to_network（sip_msg）//プロセスそれ通常この//特定の宛先が過負荷を受けないので、次のホップに要求を送信することによって//。 }他{//サーバが過負荷に入りたいか//過負荷であるかどうかを判断します。 in_oc：= extract_in_oc（oc_context）oc_value：= extract_oc（oc_context）oc_validity：= extract_oc_validity（oc_context）"
    },
    {
      "indent": 9,
      "text": "if (in_oc == false or oc_validity is not in effect) { send_to_network(sip_msg) // Process it normally by sending // the request to the next hop since this particular // destination is not subject to overload. Optionally, // clear the oc context for this server (not shown). } else { // Begin performing overload control. r := random() drop_msg := false",
      "ja": "IF（in_ocが==偽またはoc_validity有効でない）{send_to_network（sip_msg）//プロセスそれ通常この//特定の宛先が過負荷を受けないので、次のホップにリクエストを送信することによって//。必要に応じて、このサーバーのOCコンテキストをクリアする//（図示せず）。 }他{//は、過負荷制御を実行開始します。 R：=ランダム（）drop_msg：=偽"
    },
    {
      "indent": 12,
      "text": "category := assign_msg_to_category(sip_msg)",
      "ja": "カテゴリ：= assign_msg_to_category（sip_msg）"
    },
    {
      "indent": 12,
      "text": "pct_to_reduce_cat1 = oc_value / cat1 * 100 if (oc_value <= cat1) { // Reduce all msgs from category 1 if (r <= pct_to_reduce_cat1 && category == cat1) { drop_msg := true } } else { // oc_value > category 1. Reduce 100% of msgs from // category 1 and remaining from category 2. pct_to_reduce_cat2 = (oc_value - cat1) / cat2 * 100 if (category == cat1) { drop_msg := true } else { if (r <= pct_to_reduce_cat2) { drop_msg := true; } } }",
      "ja": "pct_to_reduce_cat1 = oc_value / CAT1 * 100 IF（oc_value <= CAT1）{//場合、カテゴリ1から全てのMSGを減らし（R <= pct_to_reduce_cat1 &&カテゴリ== CAT1）{drop_msg：= TRUE}}他{// oc_value>カテゴリ1 。他{IF（R <= pct_to_reduce_cat2）：場合/ CAT2 * 100（カテゴリ== CAT1）{=真drop_msg}  -  //カテゴリ1と残りのカテゴリから2 pct_to_reduce_cat2 =（CAT1 oc_value）からMSGの100％削減{drop_msg：= TRUE; }}}"
    },
    {
      "indent": 12,
      "text": "if (drop_msg == false) { send_to_network(sip_msg) // Process it normally by // sending the request to the next hop. } else { // Do not send request downstream; handle it locally by // generating response (if a proxy) or treating it as // an error (if a user agent). }",
      "ja": "IF（drop_msg ==偽）{send_to_network（sip_msg）//プロセスそれ通常次のホップに要求を送信することによって//。 }他{//下流のリクエストを送信しないでください。 //生成応答（プロキシ場合）または//エラー（ユーザエージェント場合）としてそれを処理することにより、ローカルに取り扱います。 }"
    },
    {
      "indent": 6,
      "text": " } // End perform overload control. }",
      "ja": "} //エンドは、過負荷制御を行います。 }"
    },
    {
      "indent": 4,
      "text": "end case // outbound request",
      "ja": "エンドケース//アウトバウンド要求"
    },
    {
      "indent": 4,
      "text": "case outbound response: if (we are in overload) { add_overload_parameters(sip_msg) } send_to_network(sip_msg)",
      "ja": "ケースアウトバウンド応答：IF（我々が過負荷である）{add_overload_parameters（sip_msg）} send_to_network（sip_msg）"
    },
    {
      "indent": 4,
      "text": "end case // outbound response",
      "ja": "エンドケース//発信応答"
    },
    {
      "indent": 4,
      "text": "case inbound response:",
      "ja": "ケース着信応答："
    },
    {
      "indent": 7,
      "text": "if (sip_msg has oc parameter values) { create_or_update_oc_context() // For the specific server // that sent the response, create or update the oc context, // i.e., extract the values of the oc-related parameters // and store them for later use.",
      "ja": "（sip_msgがOCパラメータ値を有する）場合、応答を送信した特定サーバは//、OCコンテキストを作成または更新のために{create_or_update_oc_context（）// //すなわち、OC関連パラメータの値を抽出//それらを格納します後で使用するために。"
    },
    {
      "indent": 7,
      "text": "} process_msg(sip_msg)",
      "ja": "} process_msg（sip_msg）"
    },
    {
      "indent": 4,
      "text": "end case // inbound response case inbound request:",
      "ja": "エンドケース//着信応答の場合、インバウンド要求："
    },
    {
      "indent": 0,
      "text": " if (we are not in overload) { process_msg(sip_msg) } else { // We are in overload. if (sip_msg has oc parameters) { // Upstream client supports process_msg(sip_msg) // oc; only sends important requests. } else { // Upstream client does not support oc if (local_policy(sip_msg) says process message) { process_msg(sip_msg) } else { send_response(sip_msg, 503) } } } end case // inbound request } }",
      "ja": "（私たちが過負荷になっていない）場合は{process_msg（sip_msg）}他{//私たちは、過負荷です。 （sip_msgはOCパラメータを持っている）場合は{//上流クライアントがprocess_msg（sip_msg）// OCをサポートしています。唯一の重要な要求を送信します。 }他{//場合は、OCをサポートしていない上流のクライアント（local_policyは（sip_msg）は言うプロセスメッセージ）{process_msg（sip_msg）}他{SEND_RESPONSE（sip_msg、503）}}}エンドケース//インバウンド要求}}"
    },
    {
      "indent": 3,
      "text": "Note: A simple way to sample the traffic mix for category 1 and category 2 is to associate a counter with each category of message. Periodically (every 5-10 seconds), get the value of the counters, and calculate the ratio of category 1 messages to category 2 messages since the last calculation.",
      "ja": "注意：カテゴリ1とカテゴリ2のトラフィックミックスをサンプリングするための簡単な方法は、メッセージのカテゴリごとにカウンタを関連付けることです。定期的に（各5〜10秒）、カウンタの値を取得し、カテゴリに区分1つのメッセージの最後の計算から2つのメッセージの比率を計算します。"
    },
    {
      "indent": 3,
      "text": "Example: In the last 5 seconds, a total of 500 requests arrived at the queue. 450 out of the 500 were messages subject to reduction, and 50 out of 500 were classified as requests not subject to reduction. Based on this ratio, cat1 := 90 and cat2 := 10, so a 90/10 mix will be used in overload calculations.",
      "ja": "例：最後の5秒で、500の要求の合計は、キューに到着しました。 500のうち450は、削減対象のメッセージだった、と500のうち50は、削減の対象とならない要求として分類されました。この比に基づいて、CAT1：= 90およびCAT2：= 10、したがって90/10混合物は、過負荷の計算に使用されます。"
    },
    {
      "indent": 0,
      "text": "8. Relationship with Other IETF SIP Load Control Efforts",
      "section_title": true,
      "ja": "他のIETF SIP負荷制御の取り組み8.関係"
    },
    {
      "indent": 3,
      "text": "The overload control mechanism described in this document is reactive in nature, and apart from the message prioritization directives listed in Section 5.10.1, the mechanisms described in this document will not discriminate requests based on user identity, filtering action, and arrival time. SIP networks that require pro-active overload control mechanisms can upload user-level load control filters as described in [RFC7200]. Local policy will also dictate the precedence of different overload control mechanisms applied to the traffic. Specifically, in a scenario where load control filters are installed by signaling neighbors [RFC7200] and the same traffic can also be throttled using the overload control mechanism, local policy will dictate which of these schemes shall be given precedence. Interactions between the two schemes are out of the scope of this document.",
      "ja": "この文書に記載された過負荷制御機構は、本質的に反応性であり、離れたセクション5.10.1に記載されているメッセージの優先順位付けディレクティブから、本書で説明されたメカニズムは、ユーザーID、フィルタリング動作、及び到着時間に基づいて要求を区別しないであろう。 [RFC7200]で説明されるように積極的な過負荷制御機構を必要とするSIPネットワークは、ユーザ・レベルの負荷制御フィルタをアップロードすることができます。ローカルポリシーは、トラフィックに適用されるさまざまな過負荷制御メカニズムの優先順位を決定します。具体的には、負荷制御フィルタはネイバー[RFC7200]と同じトラフィックシグナリングによってインストールされているシナリオでも、過負荷制御機構を使用して絞ることができ、ローカルポリシーが優先されなければならないこれらのスキームのどれ決定するであろう。 2つの制度間の相互作用は、この文書の範囲外です。"
    },
    {
      "indent": 0,
      "text": "9. Syntax",
      "section_title": true,
      "ja": "9.構文"
    },
    {
      "indent": 3,
      "text": "This specification extends the existing definition of the Via header field parameters of [RFC3261]. The ABNF [RFC5234] syntax is as follows:",
      "ja": "この仕様は、[RFC3261]のViaヘッダフィールドパラメータの既存の定義を拡張します。 ABNF [RFC5234]の構文は次のとおりです。"
    },
    {
      "indent": 7,
      "text": "via-params  =/ oc / oc-validity / oc-seq / oc-algo\noc          = \"oc\" [EQUAL oc-num]\noc-num      = 1*DIGIT\noc-validity = \"oc-validity\" [EQUAL delta-ms]\noc-seq      = \"oc-seq\" EQUAL 1*12DIGIT \".\" 1*5DIGIT\noc-algo     = \"oc-algo\" EQUAL DQUOTE algo-list *(COMMA algo-list)\n              DQUOTE\nalgo-list   = \"loss\" / *(other-algo)\nother-algo  = %x41-5A / %x61-7A / %x30-39\ndelta-ms    = 1*DIGIT",
      "raw": true
    },
    {
      "indent": 0,
      "text": "10. Design Considerations",
      "section_title": true,
      "ja": "10.設計上の考慮事項"
    },
    {
      "indent": 3,
      "text": "This section discusses specific design considerations for the mechanism described in this document. General design considerations for SIP overload control can be found in [RFC6357].",
      "ja": "このセクションでは、この文書で説明したメカニズムのための具体的な設計上の考慮事項について説明します。 SIP過負荷制御のための一般的な設計上の考慮事項は、[RFC6357]で見つけることができます。"
    },
    {
      "indent": 0,
      "text": "10.1. SIP Mechanism",
      "section_title": true,
      "ja": "10.1。 SIPメカニズム"
    },
    {
      "indent": 3,
      "text": "A SIP mechanism is needed to convey overload feedback from the receiving to the sending SIP entity. A number of different alternatives exist to implement such a mechanism.",
      "ja": "SIP機構は、送信SIPエンティティに受信から過負荷フィードバックを伝えるために必要とされます。異なる選択肢の数は、このような機構を実装するために存在します。"
    },
    {
      "indent": 0,
      "text": "10.1.1. SIP Response Header",
      "section_title": true,
      "ja": "10.1.1。 SIPレスポンスヘッダー"
    },
    {
      "indent": 3,
      "text": "Overload control information can be transmitted using a new Via header field parameter for overload control. A SIP server can add this header parameter to the responses it is sending upstream to provide overload control feedback to its upstream neighbors. This approach has the following characteristics:",
      "ja": "過負荷制御情報は、過負荷制御のための新たなViaヘッダフィールドパラメータを使用して送信することができます。 SIPサーバは、その上流の近隣に過負荷制御フィードバックを提供するために、上流の送信された応答に、このヘッダパラメータを追加することができます。このアプローチは、次の特徴があります。"
    },
    {
      "indent": 3,
      "text": "o A Via header parameter is light-weight and creates very little overhead. It does not require the transmission of additional messages for overload control and does not increase traffic or processing burdens in an overload situation.",
      "ja": "O Viaヘッダパラメータは、軽量であり、非常に少ないオーバーヘッドを作成します。これは、過負荷制御のための追加のメッセージの伝送を必要とせず、過負荷状態でのトラフィックや処理負担を増加させません。"
    },
    {
      "indent": 3,
      "text": "o Overload control status can frequently be reported to upstream neighbors since it is a part of a SIP response. This enables the use of this mechanism in scenarios where the overload status needs to be adjusted frequently. It also enables the use of overload control mechanisms that use regular feedback, such as window-based overload control.",
      "ja": "それはSIP応答の一部であるので、O過負荷制御状態が頻繁ネイバーを上流側に報告することができます。これは、過負荷状態が頻繁に調整する必要があるシナリオで、このメカニズムを使用することができます。また、そのようなウィンドウベースの過負荷制御のような規則的なフィードバックを、使用する過負荷制御メカニズムの使用を可能にします。"
    },
    {
      "indent": 3,
      "text": "o With a Via header parameter, overload control status is inherent in SIP signaling and is automatically conveyed to all relevant upstream neighbors, i.e., neighbors that are currently contributing traffic. There is no need for a SIP server to specifically track and manage the set of current upstream or downstream neighbors with which it should exchange overload feedback.",
      "ja": "ViaヘッダパラメータでO、制御状態がSIPシグナリングに固有であり、自動的に現在のトラフィックに貢献しているすべての関連する上流の近隣、すなわち、近隣に搬送される過負荷。具体的には、過負荷フィードバックを交換するべきで、現在の上流または下流の隣人のセットを追跡し、管理するためのSIPサーバは必要ありません。"
    },
    {
      "indent": 3,
      "text": "o Overload status is not conveyed to inactive senders. This avoids the transmission of overload feedback to inactive senders, which do not contribute traffic. If an inactive sender starts to transmit while the receiver is in overload, it will receive overload feedback in the first response and can adjust the amount of traffic forwarded accordingly.",
      "ja": "O過負荷状態が非アクティブの送信者に伝達されていません。これは、トラフィックを寄与しない非アクティブな送信者への過負荷フィードバックの送信を回避することができます。非アクティブな送信者は受信機が過負荷状態にある間に送信を開始する場合は、最初の応答で過負荷フィードバックを受け取り、それに応じて転送されたトラフィックの量を調整することができます。"
    },
    {
      "indent": 3,
      "text": "o A SIP server can limit the distribution of overload control information by only inserting it into responses to known upstream neighbors. A SIP server can use transport-level authentication (e.g., via TLS) with its upstream neighbors.",
      "ja": "O SIPサーバは、既知の上流の近隣への応答中にそれを挿入することにより、過負荷制御情報の配布を制限することができます。 SIPサーバは、その上流の近隣で（TLSを介して例えば、）トランスポートレベルの認証を使用することができます。"
    },
    {
      "indent": 0,
      "text": "10.1.2. SIP Event Package",
      "section_title": true,
      "ja": "10.1.2。 SIPイベントパッケージ"
    },
    {
      "indent": 3,
      "text": "Overload control information can also be conveyed from a receiver to a sender using a new event package. Such an event package enables a sending entity to subscribe to the overload status of its downstream neighbors and receive notifications of overload control status changes in NOTIFY requests. This approach has the following characteristics:",
      "ja": "過負荷制御情報は、新たなイベントパッケージを使用して、受信側から送信側へ搬送することができます。このようなイベントパッケージは、その下流の隣人の過負荷状態に加入し、NOTIFY要求における過負荷制御ステータス変更の通知を受信するために送信エンティティを可能にします。このアプローチは、次の特徴があります。"
    },
    {
      "indent": 3,
      "text": "o Overload control information is conveyed decoupled from SIP signaling. It enables an overload control manager, which is a separate entity, to monitor the load on other servers and provide overload control feedback to all SIP servers that have set up subscriptions with the controller.",
      "ja": "O過負荷制御情報は、SIPシグナリングから分離搬送されます。これは、他のサーバの負荷を監視し、コントローラとサブスクリプションを設定しているすべてのSIPサーバに過負荷制御フィードバックを提供するために、別個のエンティティである過負荷制御管理を可能にします。"
    },
    {
      "indent": 3,
      "text": "o With an event package, a receiver can send updates to senders that are currently inactive. Inactive senders will receive a notification about the overload and can refrain from sending traffic to this neighbor until the overload condition is resolved.",
      "ja": "イベントパッケージではO、受信機は、現在アクティブでない送信者に更新を送信することができます。非アクティブな送信者は、過負荷に関する通知を受信すると、過負荷状態が解消されるまで、この隣人にトラフィックを送信を控えることができます。"
    },
    {
      "indent": 6,
      "text": "The receiver can also notify all potential senders once they are permitted to send traffic again. However, these notifications do generate additional traffic, which adds to the overall load.",
      "ja": "彼らは再びトラフィックを送信することが許可されると受信機はまた、すべての潜在的な送信者に通知することができます。しかし、これらの通知は、全体の負荷に加え、追加のトラフィックを生成します。"
    },
    {
      "indent": 3,
      "text": "o A SIP entity needs to set up and maintain overload control subscriptions with all upstream and downstream neighbors. A new subscription needs to be set up before/while a request is transmitted to a new downstream neighbor. Servers can be configured to subscribe at boot time. However, this would require additional protection to avoid the avalanche restart problem for overload control. Subscriptions need to be terminated when they are not needed any more, which can be done, for example, using a timeout mechanism.",
      "ja": "O SIPエンティティは、すべての上流および下流の隣人と過負荷制御サブスクリプションをセットアップし、維持する必要があります。新しいサブスクリプション要求は、新たな下流の隣人に送られている間/前に設定する必要があります。サーバは、ブート時にサブスクライブするように構成することができます。しかし、これは、過負荷制御のための雪崩の再起動の問題を回避するために、追加の保護を必要とします。サブスクリプションは、タイムアウトメカニズムを使用して、例えば、行うことができ、それらはもはや必要でないときに終了する必要があります。"
    },
    {
      "indent": 3,
      "text": "o A receiver needs to send NOTIFY messages to all subscribed upstream neighbors in a timely manner when the control algorithm requires a change in the control variable (e.g., when a SIP server is in an overload condition). This includes active as well as inactive neighbors. These NOTIFYs add to the amount of traffic that needs to be processed. To ensure that these requests will not be dropped due to overload, a priority mechanism needs to be implemented in all servers these requests will pass through.",
      "ja": "O受信機は、制御アルゴリズムは、制御変数における変化を必要とする場合に適時にすべての加入上流の近隣にNOTIFYメッセージを送信する必要がある（例えば、SIPサーバが過負荷状態にある場合）。これは、アクティブなだけでなく、アクティブでない隣人を含んでいます。これらのNOTIFYは、処理する必要のあるトラフィックの量に追加します。これらの要求は、過負荷によるドロップされないことを保証するために、優先順位メカニズムは、これらの要求が通過するすべてのサーバーに実装する必要があります。"
    },
    {
      "indent": 3,
      "text": "o As overload feedback is sent to all senders in separate messages, this mechanism is not suitable when frequent overload control feedback is needed.",
      "ja": "頻繁に過負荷制御のフィードバックが必要とされる場合、過負荷フィードバックが別個のメッセージ内のすべての送信者に送信されるように、O、このメカニズムは適していません。"
    },
    {
      "indent": 3,
      "text": "o A SIP server can limit the set of senders that can receive overload control information by authenticating subscriptions to this event package.",
      "ja": "O SIPサーバは、このイベント・パッケージにサブスクリプションを認証することにより、過負荷制御情報を受信することができる送信者のセットを制限することができます。"
    },
    {
      "indent": 3,
      "text": "o This approach requires each proxy to implement user agent functionality (UAS and UAC) to manage the subscriptions.",
      "ja": "Oこのアプローチは、サブスクリプションを管理するためのユーザエージェント機能（UASとUAC）を実装する各プロキシを必要とします。"
    },
    {
      "indent": 0,
      "text": "10.2. Backwards Compatibility",
      "section_title": true,
      "ja": "10.2。後方互換性"
    },
    {
      "indent": 3,
      "text": "A new overload control mechanism needs to be backwards compatible so that it can be gradually introduced into a network and function properly if only a fraction of the servers support it.",
      "ja": "新しい過負荷制御機構は、それが徐々にネットワークに導入し、サーバの一部のみがそれをサポートしている場合、正しく機能することができるように後方互換性である必要があります。"
    },
    {
      "indent": 3,
      "text": "Hop-by-hop overload control (see [RFC6357]) has the advantage that it does not require that all SIP entities in a network support it. It can be used effectively between two adjacent SIP servers if both servers support overload control and does not depend on the support from any other server or user agent. The more SIP servers in a network support hop-by-hop overload control, the better protected the network is against occurrences of overload.",
      "ja": "ホップバイホップ過負荷制御（[RFC6357]を参照）、それはネットワークサポートその中のすべてのSIPエンティティことを必要としないという利点があります。両方のサーバーが過負荷制御をサポートし、他のサーバやユーザエージェントからの支援に依存していない場合には、隣接する2台のSIPサーバ間で効果的に使用することができます。ネットワークサポートホップバイホップ過負荷制御で複数のSIPサーバは、より良い保護されたネットワークは、過負荷の発生に反しています。"
    },
    {
      "indent": 3,
      "text": "A SIP server may have multiple upstream neighbors from which only some may support overload control. If a server would simply use this overload control mechanism, only those that support it would reduce traffic. Others would keep sending at the full rate and benefit from the throttling by the servers that support overload control. In other words, upstream neighbors that do not support overload control would be better off than those that do.",
      "ja": "SIPサーバは、一部のみが過負荷制御をサポートすることができる、そこから複数の上流の近隣を有していてもよいです。サーバは単に、この過負荷制御メカニズムを使用する場合は、それをサポートする唯一のものは、トラフィックを減少させるであろう。その他には、過負荷制御をサポートするサーバーによってスロットルからフルレートと利益で送り続けるでしょう。言い換えれば、過負荷制御をサポートしていない上流の隣人が行うものよりもしたほうが良いでしょう。"
    },
    {
      "indent": 3,
      "text": "A SIP server should therefore follow the behavior outlined in Section 5.10.2 to handle clients that do not support overload control.",
      "ja": "SIPサーバは、したがって、過負荷制御をサポートしないクライアントを処理するために、5.10.2項で概説した動作に従ってください。"
    },
    {
      "indent": 0,
      "text": "11. Security Considerations",
      "section_title": true,
      "ja": "11.セキュリティについての考慮事項"
    },
    {
      "indent": 3,
      "text": "Overload control mechanisms can be used by an attacker to conduct a denial-of-service attack on a SIP entity if the attacker can pretend that the SIP entity is overloaded. When such a forged overload indication is received by an upstream SIP client, it will stop sending traffic to the victim. Thus, the victim is subject to a denial-of-service attack.",
      "ja": "過負荷制御機構は、攻撃者がSIPエンティティが過負荷であることをふりをすることができた場合、SIPエンティティに対するサービス拒否攻撃を行うために攻撃者によって使用することができます。こうした偽造過負荷表示は上流のSIPクライアントによって受信されると、それは、被害者へのトラフィックの送信を停止します。このように、被害者は、サービス拒否攻撃の対象となります。"
    },
    {
      "indent": 3,
      "text": "To better understand the threat model, consider the following diagram:",
      "ja": "優れた脅威モデルを理解するには、次の図を考慮してください。"
    },
    {
      "indent": 9,
      "text": "Pa -------                    ------ Pb\n          \\                  /\n:  ------ +-------- P1 ------+------ :\n          /    L1        L2  \\\n:  -------                    ------ :",
      "raw": true
    },
    {
      "indent": 9,
      "text": "-----> Downstream (requests)\n<----- Upstream (responses)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Here, requests travel downstream from the left-hand side, through Proxy P1, towards the right-hand side; responses travel upstream from the right-hand side, through P1, towards the left-hand side. Proxies Pa, Pb, and P1 support overload control. L1 and L2 are labels for the links connecting P1 to the upstream clients and downstream servers.",
      "ja": "ここで、要求は、右側に向かって、プロキシP1を介して、左側から下流に移動します。応答は、左側に向かって、P1を介して、右側から上流に移動します。プロキシPA、PB、及びP1支持過負荷制御。 L1とL2は、上流側クライアントと下流サーバにP1を接続するリンクのラベルです。"
    },
    {
      "indent": 3,
      "text": "If an attacker is able to modify traffic between Pa and P1 on link L1, it can cause a denial-of-service attack on P1 by having Pa not send any traffic to P1. Such an attack can proceed by the attacker modifying the response from P1 to Pa such that Pa's Via header is changed to indicate that all requests destined towards P1 should be dropped. Conversely, the attacker can simply remove any \"oc\", \"oc-validity\", and \"oc-seq\" markings added by P1 in a response to Pa. In such a case, the attacker will force P1 into overload by denying request quenching at Pa even though Pa is capable of performing overload control.",
      "ja": "攻撃者は、リンクL1にPaとP1間のトラフィックを変更できる場合、それはPaがP1にトラフィックを送信しないことによってP1にDoS攻撃を引き起こす可能性があります。このような攻撃は、P1からPaとPaとのViaヘッダがP1に向かっ宛のすべての要求がドロップされるべきであることを示すように変更されるように応答を変更する攻撃者によって進めることができます。逆に、攻撃者は単に任意の「OC」、「OC-妥当性」、及びPaのに応答してP1によって追加された「OC-配列」マーキングを除去することができる。このような場合、攻撃者は要求消光を拒否することによって過負荷にP1を強制しますPaにPaが過負荷制御を行うことが可能であるにもかかわらず。"
    },
    {
      "indent": 3,
      "text": "Similarly, if an attacker is able to modify traffic between P1 and Pb on link L2, it can change the Via header associated with P1 in a response from Pb to P1 such that all subsequent requests destined towards Pb from P1 are dropped. In essence, the attacker mounts a denial-of-service attack on Pb by indicating false overload control. Note that it is immaterial whether Pb supports overload control or not; the attack will succeed as long as the attacker is able to control L2. Conversely, an attacker can suppress a genuine overload condition at Pb by simply removing any \"oc\", \"oc-validity\", and \"oc-seq\" markings added by Pb in a response to P1. In such a case, the attacker will force P1 into sending requests to Pb even under overload conditions because P1 would not be aware that Pb supports overload control.",
      "ja": "攻撃者は、リンクL2上P1及びPb間のトラフィックを変更することができる場合も同様に、それはP1から鉛向かっ宛てのすべての後続の要求がドロップされるように、P1に鉛から応答P1に関連付けられたViaヘッダを変更することができます。本質的には、攻撃者が偽の過負荷制御を指示することにより、鉛にDoS攻撃をマウントします。 Pbが過負荷制御をサポートしているかいないかどうかは重要ではないことに注意してください。攻撃では、攻撃者がL2を制御することが可能である限り、成功します。逆に、攻撃者は単にP1に応答して、PBで追加された「OC」、「OC-妥当性」、および「OC-配列」マーキングを除去することによって、PBの本物の過負荷状態を抑制することができます。そのような場合には、攻撃者は、P1は、Pbが過負荷制御をサポートしていることを認識してないためにも、過負荷条件でPBにリクエストを送信するにP1を強制します。"
    },
    {
      "indent": 3,
      "text": "Attacks that indicate false overload control are best mitigated by using TLS in conjunction with applying BCP 38 [RFC2827]. Attacks that are mounted to suppress genuine overload conditions can be similarly avoided by using TLS on the connection. Generally, TCP or WebSockets [RFC6455] in conjunction with BCP 38 makes it more difficult for an attacker to insert or modify messages but may still prove inadequate against an adversary that controls links L1 and L2. TLS provides the best protection from an attacker with access to the network links.",
      "ja": "偽の過負荷制御を示している攻撃は最良のBCP 38 [RFC2827]を適用すると一緒にTLSを使用することによって軽減されます。本物の過負荷状態を抑制するために実装されている攻撃は、同様に、接続にTLSを使用することによって回避することができます。一般的には、BCP 38と一緒にTCPやWebSocketを[RFC6455]は、メッセージを挿入または変更する攻撃者にとってより困難になりますが、まだ、リンクL1およびL2を制御し、敵に対して適応できない場合があります。 TLSは、ネットワーク・リンクにアクセスして、攻撃者からの最高の保護を提供します。"
    },
    {
      "indent": 3,
      "text": "Another way to conduct an attack is to send a message containing a high overload feedback value through a proxy that does not support this extension. If this feedback is added to the second Via header (or all Via headers), it will reach the next upstream proxy. If the attacker can make the recipient believe that the overload status was created by its direct downstream neighbor (and not by the attacker further downstream), the recipient stops sending traffic to the victim. A precondition for this attack is that the victim proxy does not support this extension since it would not pass through overload control feedback otherwise.",
      "ja": "攻撃を実施する別の方法は、この拡張機能をサポートしていないプロキシを介して、高過負荷フィードバック値を含むメッセージを送信することです。このフィードバックは、ヘッダを介して第二（または全てのViaヘッダ）に追加された場合、それは次の上流プロキシに到達します。攻撃者は受信者が（さらに下流ではなく、攻撃者によって）、過負荷状態がその直接下流の隣人によって作成されたことを信じさせることができた場合、受信者は、被害者へのトラフィックの送信を停止します。この攻撃のための前提条件は、それがそうでない場合は、過負荷制御フィードバックを通過しないため、被害者のプロキシは、この拡張機能をサポートしていないということです。"
    },
    {
      "indent": 3,
      "text": "A malicious SIP entity could gain an advantage by pretending to support this specification but never reducing the amount of traffic it forwards to the downstream neighbor. If its downstream neighbor receives traffic from multiple sources that correctly implement overload control, the malicious SIP entity would benefit since all other sources to its downstream neighbor would reduce load.",
      "ja": "悪質なSIPエンティティは、この仕様をサポートするために、ふりが、それは下流の隣人に転送するトラフィックの量を減らすことはありませんでの優位性を得ることができました。その下流の隣人が正しく過負荷制御を実装し、複数のソースからのトラフィックを受信した場合、悪意のあるSIPエンティティは、その下流の隣に他のすべてのソースは負荷を低減するから利益を得るであろう。"
    },
    {
      "indent": 6,
      "text": "Note: The solution to this problem depends on the overload control method. With rate-based, window-based, and other similar overload control algorithms that promise to produce no more than a specified number of requests per unit time, the overloaded server can regulate the traffic arriving to it. However, when using loss-based overload control, such policing is not always obvious since the load forwarded depends on the load received by the client.",
      "ja": "注：この問題を解決するには、過負荷制御方法に依存します。レートベース、ウィンドウベース、単位時間当たりのリクエストの指定された数よりも多くを生成しないことを約束し、他の同様の過負荷制御アルゴリズムでは、過負荷状態のサーバがそれに到着したトラフィックを制御することができます。損失ベースの過負荷制御を使用した場合、転送負荷がクライアントによって受信された負荷に依存しているためしかし、このようなポリシングは必ずしも明確ではありません。"
    },
    {
      "indent": 3,
      "text": "To prevent such attacks, servers should monitor client behavior to determine whether they are complying with overload control policies. If a client is not conforming to such policies, then the server should treat it as a non-supporting client (see Section 5.10.2).",
      "ja": "このような攻撃を防ぐために、サーバーは、過負荷制御ポリシーを遵守しているかどうかを判断するために、クライアントの動作を監視する必要があります。クライアントは、このようなポリシーに準拠していない場合、サーバーは非サポートクライアント（5.10.2項を参照）として扱う必要があります。"
    },
    {
      "indent": 3,
      "text": "Finally, a distributed denial-of-service (DDoS) attack could cause an honest server to start signaling an overload condition. Such a DDoS attack could be mounted without controlling the communications links since the attack simply depends on the attacker injecting a large volume of packets on the communication links. If the honest server attacked by a DDoS attack has a long \"oc-validity\" interval and the attacker can guess this interval, the attacker can keep the server overloaded by synchronizing the DDoS traffic with the validity period. While such an attack may be relatively easy to spot, mechanisms for combating it are outside the scope of this document and, of course, since attackers can invent new variations, the appropriate mechanisms are likely to change over time.",
      "ja": "最後に、分散型サービス拒否（DDoS）攻撃は正直、サーバが過負荷状態を知らせる開始する可能性があります。そのようなDDoS攻撃は、攻撃は、単に通信リンク上のパケットを大量に注入する攻撃者に依存するための通信リンクを制御することなく取り付けることができます。 DDoS攻撃に襲わ正直なサーバが長い「OC-妥当性」の間隔があり、攻撃者がこの間隔を推測することができた場合、攻撃者は、有効期間とDDoS攻撃トラフィックを同期させることによって過負荷にサーバーを維持することができます。このような攻撃を発見することは比較的容易であるかもしれないが、それに対処するためのメカニズムはこの文書の範囲外であり、攻撃者が新しいバリエーションを発明することができるので、当然のことながら、適切なメカニズムは、時間の経過とともに変化する可能性があります。"
    },
    {
      "indent": 0,
      "text": "12. IANA Considerations",
      "section_title": true,
      "ja": "12. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This specification defines four new Via header parameters as detailed below in the \"Header Field Parameter and Parameter Values\" sub-registry as per the registry created by [RFC3968]. The required information is:",
      "ja": "[RFC3968]で作成されたレジストリ通り「ヘッダフィールドパラメータおよびパラメータ値」サブレジストリに以下に詳述するように、この仕様は、4つの新たなViaヘッダパラメータを定義します。必要な情報は以下のとおりです。"
    },
    {
      "indent": 7,
      "text": "Header Field  Parameter Name  Predefined Values  Reference\n__________________________________________________________\nVia           oc                 Yes             [RFC7339]\nVia           oc-validity        Yes             [RFC7339]\nVia           oc-seq             Yes             [RFC7339]\nVia           oc-algo            Yes             [RFC7339]",
      "raw": true
    },
    {
      "indent": 0,
      "text": "13. References",
      "section_title": true,
      "ja": "13.参考文献"
    },
    {
      "indent": 0,
      "text": "13.1. Normative References",
      "section_title": true,
      "ja": "13.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC3261] Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston, A., Peterson, J., Sparks, R., Handley, M., and E. Schooler, \"SIP: Session Initiation Protocol\", RFC 3261, June 2002.",
      "ja": "[RFC3261]ローゼンバーグ、J.、Schulzrinneと、H.、カマリロ、G.、ジョンストン、A.、ピーターソン、J.、スパークス、R.、ハンドレー、M.、およびE.学生、 \"SIP：セッション開始プロトコル\" 、RFC 3261、2002年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC3263] Rosenberg, J. and H. Schulzrinne, \"Session Initiation Protocol (SIP): Locating SIP Servers\", RFC 3263, June 2002.",
      "ja": "[RFC3263]ローゼンバーグ、J.とH. Schulzrinneと、 \"セッション開始プロトコル（SIP）：SIPサーバの検索\"、RFC 3263、2002年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC3968] Camarillo, G., \"The Internet Assigned Number Authority (IANA) Header Field Parameter Registry for the Session Initiation Protocol (SIP)\", BCP 98, RFC 3968, December 2004.",
      "ja": "[RFC3968]キャマリロ、G.、BCP 98、RFC 3968、2004年12月 \"インターネットは、セッション開始プロトコル（SIP）のための番号機関（IANA）ヘッダーフィールドパラメータレジストリを割り当てられました\"。"
    },
    {
      "indent": 3,
      "text": "[RFC4412] Schulzrinne, H. and J. Polk, \"Communications Resource Priority for the Session Initiation Protocol (SIP)\", RFC 4412, February 2006.",
      "ja": "[RFC4412] Schulzrinneと、H.とJ.ポーク、 \"セッション開始プロトコル（SIP）のための通信リソースプライオリティ\"、RFC 4412、2006年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC5234] Crocker, D. and P. Overell, \"Augmented BNF for Syntax Specifications: ABNF\", STD 68, RFC 5234, January 2008.",
      "ja": "[RFC5234]クロッカー、D.、およびP. Overell、 \"構文仕様のための増大しているBNF：ABNF\"、STD 68、RFC 5234、2008年1月。"
    },
    {
      "indent": 0,
      "text": "13.2. Informative References",
      "section_title": true,
      "ja": "13.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[RATE-CONTROL] Noel, E. and P. Williams, \"Session Initiation Protocol (SIP) Rate Control\", Work in Progress, July 2014.",
      "ja": "[RATE-CONTROL]ノエル、E.およびP.ウィリアムス、 \"セッション開始プロトコル（SIP）レート制御\"、進歩、2014年7月での作業。"
    },
    {
      "indent": 3,
      "text": "[RFC2827] Ferguson, P. and D. Senie, \"Network Ingress Filtering: Defeating Denial of Service Attacks which employ IP Source Address Spoofing\", BCP 38, RFC 2827, May 2000.",
      "ja": "[RFC2827]ファーガソン、P.およびD. Senie、 \"ネットワーク入力フィルタリング：IP Source Address Spoofingを使うサービス攻撃の敗北拒否\"、BCP 38、RFC 2827、2000年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC5031] Schulzrinne, H., \"A Uniform Resource Name (URN) for Emergency and Other Well-Known Services\", RFC 5031, January 2008.",
      "ja": "[RFC5031] Schulzrinneと、H.、 \"ユニフォームリソース名救急およびその他のよく知られているサービスのための（URN）\"、RFC 5031、2008年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC5390] Rosenberg, J., \"Requirements for Management of Overload in the Session Initiation Protocol\", RFC 5390, December 2008.",
      "ja": "[RFC5390]ローゼンバーグ、J.、「セッション開始プロトコルにおける過負荷の管理のための要件」、RFC 5390、2008年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC6357] Hilt, V., Noel, E., Shen, C., and A. Abdelal, \"Design Considerations for Session Initiation Protocol (SIP) Overload Control\", RFC 6357, August 2011.",
      "ja": "[RFC6357]柄、V.、ノエル、E.、シェン、C.、およびA. Abdelal、RFC 6357、2011年8月 \"セッション開始プロトコル（SIP）過負荷制御のための設計上の考慮事項\"。"
    },
    {
      "indent": 3,
      "text": "[RFC6455] Fette, I. and A. Melnikov, \"The WebSocket Protocol\", RFC 6455, December 2011.",
      "ja": "[RFC6455]たFette、I.およびA.メルニコフ、 \"WebSocketのプロトコル\"、RFC 6455、2011年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC7200] Shen, C., Schulzrinne, H., and A. Koike, \"A Session Initiation Protocol (SIP) Load-Control Event Package\", RFC 7200, April 2014.",
      "ja": "[RFC7200]シェン、C.、Schulzrinneと、H.、およびA.小池、 \"Aセッション開始プロトコル（SIP）負荷コントロールイベントパッケージ\"、RFC 7200、2014年4月。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Acknowledgements",
      "ja": "付録A.謝辞"
    },
    {
      "indent": 3,
      "text": "The authors acknowledge the contributions of Bruno Chatras, Keith Drage, Janet Gunn, Rich Terpstra, Daryl Malas, Eric Noel, R. Parthasarathi, Antoine Roly, Jonathan Rosenberg, Charles Shen, Rahul Srivastava, Padma Valluri, Shaun Bharrat, Paul Kyzivat, and Jeroen Van Bemmel to this document.",
      "ja": "著者はブルーノChatras、キース糖剤、ジャネット・ガン、リッチテルプストラ、ダリル・マラス、エリック・ノエル、R. Parthasarathi、アントワーヌ・ロリー、ジョナサン・ローゼンバーグ、チャールズ・シェン、ラーフルSrivastava氏、パドマValluri、ショーンBharrat、ポールKyzivatの貢献を認め、そしてこのドキュメントへのJeroenヴァンBemmel。"
    },
    {
      "indent": 3,
      "text": "Adam Roach and Eric McMurry helped flesh out the different cases for handling SIP messages described in the algorithm in Section 7.2. Janet Gunn reviewed the algorithm and suggested changes that led to simpler processing for the case where \"oc_value > cat1\".",
      "ja": "アダム・ローチとエリック・マクマリーは、7.2節におけるアルゴリズムで説明したSIPメッセージを処理するための別の例を肉付け助けました。ジャネット・ガンは、アルゴリズムを見直し、ケース「oc_value> CAT1」のための単純な処理につながった変更を示唆しました。"
    },
    {
      "indent": 3,
      "text": "Richard Barnes provided invaluable comments as a part of the Area Director review of the document.",
      "ja": "リチャード・バーンズは、ドキュメントのエリアディレクターの見直しの一環として、非常に貴重なコメントを提供しました。"
    },
    {
      "indent": 0,
      "text": "Appendix B. Requirements",
      "ja": "付録B.要件"
    },
    {
      "indent": 3,
      "text": "Table 1 provides a summary of how this specification fulfills the requirements of [RFC5390]. A more detailed view on how each requirements is fulfilled is provided after the table.",
      "ja": "表1は、この仕様は[RFC5390]の要件を満たす方法の概要を提供します。各要件が満たされている方法についてのより詳細な図は、表の後に提供されます。"
    },
    {
      "indent": 20,
      "text": "+-------------+-------------------+\n| Requirement | Meets requirement |\n+-------------+-------------------+\n| REQ 1       | Yes               |\n| REQ 2       | Yes               |\n| REQ 3       | Partially         |\n| REQ 4       | Yes               |\n| REQ 5       | Partially         |\n| REQ 6       | Not applicable    |\n| REQ 7       | Yes               |\n| REQ 8       | Partially         |\n| REQ 9       | Yes               |\n| REQ 10      | Yes               |\n| REQ 11      | Yes               |\n| REQ 12      | Yes               |\n| REQ 13      | Yes               |\n| REQ 14      | Yes               |\n| REQ 15      | Yes               |\n| REQ 16      | Yes               |\n| REQ 17      | Partially         |\n| REQ 18      | Yes               |\n| REQ 19      | Yes               |\n| REQ 20      | Yes               |\n| REQ 21      | Yes               |\n| REQ 22      | Yes               |\n| REQ 23      | Yes               |\n+-------------+-------------------+",
      "raw": true
    },
    {
      "indent": 11,
      "text": "Table 1: Summary of Meeting Requirements in RFC 5390",
      "ja": "表1：RFC 5390での会議の要件の概要"
    },
    {
      "indent": 3,
      "text": "REQ 1: The overload mechanism shall strive to maintain the overall useful throughput (taking into consideration the quality-of-service needs of the using applications) of a SIP server at reasonable levels, even when the incoming load on the network is far in excess of its capacity. The overall throughput under load is the ultimate measure of the value of an overload control mechanism.",
      "ja": "REQ 1：過負荷機構は、ネットワーク上の着信負荷がはるかに過剰であっても、合理的なレベルでのSIPサーバの全体的な有用なスループット（考慮使用してアプリケーションのサービス品質ニーズを取る）を維持するように努めますその容量の。荷重下での全体的なスループットは、過負荷制御機構の値の最終的な尺度です。"
    },
    {
      "indent": 6,
      "text": "Meets REQ 1: Yes. The overload control mechanism allows an overloaded SIP server to maintain a reasonable level of throughput as it enters into congestion mode by requesting the upstream clients to reduce traffic destined downstream.",
      "ja": "REQ 1を満たしている：はい。過負荷制御機構は、それが下流宛てのトラフィックを低減するために上流のクライアントに要求することによって、輻輳モードに入るように過負荷SIPサーバは、スループットの合理的なレベルを維持することができます。"
    },
    {
      "indent": 3,
      "text": "REQ 2: When a single network element fails, goes into overload, or suffers from reduced processing capacity, the mechanism should strive to limit the impact of this on other elements in the network. This helps to prevent a small-scale failure from becoming a widespread outage.",
      "ja": "REQ 2：単一のネットワーク要素は、失敗した過負荷になり、又は低減処理能力を患っている場合、機構は、ネットワーク内の他の要素に対するこの影響を制限するために努力すべきです。これは、広範囲の停電になることから、小規模な失敗を防ぐことができます。"
    },
    {
      "indent": 6,
      "text": "Meets REQ 2: Yes. When a SIP server enters overload mode, it will request the upstream clients to throttle the traffic destined to it. As a consequence of this, the overloaded SIP server will itself generate proportionally less downstream traffic, thereby limiting the impact on other elements in the network.",
      "ja": "REQ 2を満たしている：はい。 SIPサーバが過負荷モードに入ると、それに向かうトラフィックを絞るために、上流のクライアントを要求します。この結果として、過負荷SIPサーバ自体がそれによってネットワーク内の他の要素の影響を制限する、比例少ないダウンストリームトラフィックを生成します。"
    },
    {
      "indent": 3,
      "text": "REQ 3: The mechanism should seek to minimize the amount of configuration required in order to work. For example, it is better to avoid needing to configure a server with its SIP message throughput, as these kinds of quantities are hard to determine.",
      "ja": "REQ 3：メカニズムが機能するために必要な構成の量を最小限にするために努めるべきです。量のこれらの種類を判別しにくいように、例えば、そのSIPメッセージ・スループットとサーバーを設定する必要を回避することをお勧めします。"
    },
    {
      "indent": 6,
      "text": "Meets REQ 3: Partially. On the server side, the overload condition is determined monitoring \"S\" (cf., Section 4 of [RFC6357]) and reporting a load feedback \"F\" as a value to the \"oc\" parameter. On the client side, a throttle \"T\" is applied to requests going downstream based on \"F\". This specification does not prescribe any value for \"S\" nor a particular value for \"F\". The \"oc-algo\" parameter allows for automatic convergence to a particular class of overload control algorithm. There are suggested default values for the \"oc-validity\" parameter.",
      "ja": "REQ 3を満たしている：一部。サーバー側では、過負荷状態を監視「S」（参照、[RFC6357]のセクション4）決定され、「OC」パラメータの値として、負荷フィードバック「F」を報告します。クライアント側では、スロットル「T」は「F」に基づいて、下流に行くの要求に適用されます。この仕様は、「S」や「F」のための特定の値に任意の値を規定していません。 「OC-ALGO」パラメータは、過負荷制御アルゴリズムの特定のクラスに自動的に収束することを可能にします。 「OC-妥当性」パラメータの推奨デフォルト値があります。"
    },
    {
      "indent": 3,
      "text": "REQ 4: The mechanism must be capable of dealing with elements that do not support it so that a network can consist of a mix of elements that do and don't support it. In other words, the mechanism should not work only in environments where all elements support it. It is reasonable to assume that it works better in such environments, of course. Ideally, there should be incremental improvements in overall network throughput as increasing numbers of elements in the network support the mechanism.",
      "ja": "REQ 4：メカニズムは、ネットワークが行うと、それをサポートしていない要素の組み合わせで構成することができるように、それをサポートしていない要素を扱うことが可能でなければなりません。言い換えれば、メカニズムは、すべての要素がそれをサポートする環境でのみ動作してはなりません。当然のことながら、このような環境ではうまく機能することを前提とするのが妥当です。理想的には、増分ネットワーク内の要素の数を増加させるなど、全体的なネットワークスループットの向上メカニズムをサポートがあるべきです。"
    },
    {
      "indent": 6,
      "text": "Meets REQ 4: Yes. The mechanism is designed to reduce congestion when a pair of communicating entities support it. If a downstream overloaded SIP server does not respond to a request in time, a SIP client will attempt to reduce traffic destined towards the non-responsive server as outlined in Section 5.9.",
      "ja": "REQ 4を満たしている：はい。メカニズムは、通信エンティティのペアがそれをサポートするときの輻輳を軽減するために設計されています。下流のオーバーロードされたSIPサーバが時間内に要求に応答しない場合、SIPクライアントは、5.9節で概説したように、非応答サーバーの方に向かうトラフィックを削減しようとします。"
    },
    {
      "indent": 3,
      "text": "REQ 5: The mechanism should not assume that it will only be deployed in environments with completely trusted elements. It should seek to operate as effectively as possible in environments where other elements are malicious; this includes preventing malicious elements from obtaining more than a fair share of service.",
      "ja": "REQ 5：メカニズムは、それが唯一の完全に信頼された要素を持つ環境に展開されることを仮定するべきではありません。これは、他の要素が悪意のある環境でできるだけ有効に作動するように努めるべきです。これはサービスの公正な取り分より多くを得ることから、悪質な要素を防止することが含まれます。"
    },
    {
      "indent": 6,
      "text": "Meets REQ 5: Partially. Since overload control information is shared between a pair of communicating entities, a confidential and authenticated channel can be used for this communication. However, if such a channel is not available, then the security ramifications outlined in Section 11 apply.",
      "ja": "REQ 5を満たしている：一部。過負荷制御情報を通信エンティティの対の間で共有されるので、機密と認証されたチャネルは、この通信のために使用することができます。このようなチャネルが利用できない場合は、その後、第11節で概説したセキュリティ波及効果が適用されます。"
    },
    {
      "indent": 3,
      "text": "REQ 6: When overload is signaled by means of a specific message, the message must clearly indicate that it is being sent because of overload, as opposed to other, non-overload-based failure conditions. This requirement is meant to avoid some of the problems that have arisen from the reuse of the 503 response code for multiple purposes. Of course, overload is also signaled by lack of response to requests. This requirement applies only to explicit overload signals.",
      "ja": "REQ 6：過負荷が特定のメッセージによって通知された場合、メッセージは、明らかに他の非過負荷に基づく障害状態とは対照的に、それが原因で過負荷により送信されていることを示さなければなりません。この要件は、複数の目的のために503応答コードの再利用から生じた問題のいくつかを回避するためのものです。もちろん、過負荷も要求への応答の欠如によって通知されます。この要件は、明示的な過負荷信号に適用されます。"
    },
    {
      "indent": 6,
      "text": "Meets REQ 6: Not applicable. Overload control information is signaled as part of the Via header and not in a new header.",
      "ja": "REQ 6を満たしている：該当事項はありません。過負荷制御情報は、Viaヘッダの一部としてではなく、新しいヘッダでシグナリングされます。"
    },
    {
      "indent": 3,
      "text": "REQ 7: The mechanism shall provide a way for an element to throttle the amount of traffic it receives from an upstream element. This throttling shall be graded so that it is not \"all or nothing\" as with the current 503 mechanism. This recognizes the fact that overload is not a binary state and that there are degrees of overload.",
      "ja": "REQ 7：機構は、上流要素から受信したトラフィックの量を絞るための要素のための方法を提供しなければなりません。それは現在の503メカニズムと同様に、「全か無か」ではないように、このスロットリングは、傾斜されなければなりません。これは、過負荷がバイナリ状態ではないと、過負荷の度合いがあるという事実を認識しています。"
    },
    {
      "indent": 6,
      "text": "Meets REQ 7: Yes. Please see Sections 5.5 and 5.10.",
      "ja": "REQ 7を満たしている：はい。セクション5.5と5.10を参照してください。"
    },
    {
      "indent": 3,
      "text": "REQ 8: The mechanism shall ensure that, when a request was not processed successfully due to overload (or failure) of a downstream element, the request will not be retried on another element that is also overloaded or whose status is unknown. This requirement derives from REQ 1.",
      "ja": "REQ 8：そのステータス要求は過負荷（または失敗）下流要素のに正常に処理されなかったことを保証しなければならないメカニズムは、要求もオーバーロードされた別の要素上に再試行されないかは不明です。この要件は、REQ 1に由来します。"
    },
    {
      "indent": 6,
      "text": "Meets REQ 8: Partially. A SIP client that has overload information from multiple downstream servers will not retry the request on another element. However, if a SIP client does not know the overload status of a downstream server, it may send the request to that server.",
      "ja": "REQ 8を満たしている：一部。複数のダウンストリームサーバーからの情報をオーバーロードしているSIPクライアントは、別の要素に要求を再試行しません。 SIPクライアントがダウンストリームサーバーの過負荷状態を把握していない場合は、そのサーバに要求を送信することができます。"
    },
    {
      "indent": 3,
      "text": "REQ 9: That a request has been rejected from an overloaded element shall not unduly restrict the ability of that request to be submitted to and processed by an element that is not overloaded. This requirement derives from REQ 1.",
      "ja": "REQ 9：要求が過負荷要素不当に提出し、過負荷にならない要素によって処理されるという要求の能力を制限してはならないから拒否されたこと。この要件は、REQ 1に由来します。"
    },
    {
      "indent": 6,
      "text": "Meets REQ 9: Yes. A SIP client conformant to this specification will send the request to a different element.",
      "ja": "REQ 9を満たしている：はい。この仕様に準拠SIPクライアントは、異なる要素に要求を送信します。"
    },
    {
      "indent": 3,
      "text": "REQ 10: The mechanism should support servers that receive requests from a large number of different upstream elements, where the set of upstream elements is not enumerable.",
      "ja": "REQ 10：機構は、上流要素のセットが列挙でない異なる上流の要素の多数からの要求を受信するサーバをサポートすべきです。"
    },
    {
      "indent": 6,
      "text": "Meets REQ 10: Yes. There are no constraints on the number of upstream clients.",
      "ja": "REQ 10を満たしている：はい。上流のクライアントの数には制約がありません。"
    },
    {
      "indent": 3,
      "text": "REQ 11: The mechanism should support servers that receive requests from a finite set of upstream elements, where the set of upstream elements is enumerable.",
      "ja": "REQ 11：メカニズムは、上流の要素の集合が可算である上流要素の有限集合からの要求を受け取るサーバーをサポートする必要があります。"
    },
    {
      "indent": 6,
      "text": "Meets REQ 11: Yes. There are no constraints on the number of upstream clients.",
      "ja": "REQ 11を満たしている：はい。上流のクライアントの数には制約がありません。"
    },
    {
      "indent": 3,
      "text": "REQ 12: The mechanism should work between servers in different domains.",
      "ja": "REQ 12：メカニズムが異なるドメイン内のサーバー間で動作するはずです。"
    },
    {
      "indent": 6,
      "text": "Meets REQ 12: Yes. There are no inherent limitations on using overload control between domains. However, interconnections points that engage in overload control between domains will have to populate and maintain the overload control parameters as requests cross domains.",
      "ja": "REQ 12を満たしている：はい。ドメイン間の過負荷制御を使用してには固有の制限はありません。ただし、ドメイン間の過負荷制御に関与相互接続点は、要求がドメインを横切るように、過負荷制御パラメータを移入し、維持しなければなりません。"
    },
    {
      "indent": 3,
      "text": "REQ 13: The mechanism must not dictate a specific algorithm for prioritizing the processing of work within a proxy during times of overload. It must permit a proxy to prioritize requests based on any local policy so that certain ones (such as a call for emergency services or a call with a specific value of the Resource-Priority header field [RFC4412]) are given preferential treatment, such as not being dropped, being given additional retransmission, or being processed ahead of others.",
      "ja": "REQ 13：メカニズムは、過負荷の時間中に、プロキシ内の作業の処理を優先するために特定のアルゴリズムを規定してはなりません。 （例えば緊急サービスのための呼またはリソース優先ヘッダフィールドの特定の値を持つコール[RFC4412]のような）特定のものを優遇が与えられるように、それのような、任意のローカルポリシーに基づいて要求を優先順位付けするためにプロキシを許可する必要があります追加の再送を与えられている、または先に他人の処理され、ドロップされません。"
    },
    {
      "indent": 6,
      "text": "Meets REQ 13: Yes. Please see Section 5.10.",
      "ja": "REQ 13を満たしている：はい。セクション5.10を参照してください。"
    },
    {
      "indent": 3,
      "text": "REQ 14: The mechanism should provide unambiguous directions to clients on when they should retry a request and when they should not. This especially applies to TCP connection establishment and SIP registrations in order to mitigate against an avalanche restart.",
      "ja": "REQ 14：彼らはいけないメカニズムは、彼らが要求を再試行する必要があるときに、クライアントに明確な方向性を提供しなければなりません。これは特に、雪崩の再起動を軽減するために、TCPコネクションの確立とSIPの登録に適用されます。"
    },
    {
      "indent": 6,
      "text": "Meets REQ 14: Yes. Section 5.9 provides normative behavior on when to retry a request after repeated timeouts and fatal transport errors resulting from communications with a non-responsive downstream SIP server.",
      "ja": "REQ 14を満たしている：はい。 5.9節を繰り返しタイムアウトと非応答下流SIPサーバとの通信に起因する致命的なトランスポートエラーの後、要求を再試行する際の規範的な動作を提供します。"
    },
    {
      "indent": 3,
      "text": "REQ 15: In cases where a network element fails, is so overloaded that it cannot process messages, or cannot communicate due to a network failure or network partition, it will not be able to provide explicit indications of the nature of the failure or its levels of congestion. The mechanism must properly function in these cases.",
      "ja": "REQ 15：ネットワーク要素が故障した場合において、それは、メッセージを処理できない、またはネットワーク障害またはネットワークパーティションが原因で通信できないことがオーバーロードされて、故障またはそのレベルの性質の明確な表示を提供することができません混雑。メカニズムが適切にこれらのケースで機能しなければなりません。"
    },
    {
      "indent": 6,
      "text": "Meets REQ 15: Yes. Section 5.9 provides normative behavior on when to retry a request after repeated timeouts and fatal transport errors resulting from communications with a non-responsive downstream SIP server.",
      "ja": "REQ 15を満たしている：はい。 5.9節を繰り返しタイムアウトと非応答下流SIPサーバとの通信に起因する致命的なトランスポートエラーの後、要求を再試行する際の規範的な動作を提供します。"
    },
    {
      "indent": 3,
      "text": "REQ 16: The mechanism should attempt to minimize the overhead of the overload control messaging.",
      "ja": "REQ 16：メカニズムは、過負荷制御メッセージのオーバーヘッドを最小化しようとしなければなりません。"
    },
    {
      "indent": 6,
      "text": "Meets REQ 16: Yes. Overload control messages are sent in the topmost Via header, which is always processed by the SIP elements.",
      "ja": "REQ 16を満たしている：はい。過負荷制御メッセージを常にSIP要素によって処理される最上位のViaヘッダに送られます。"
    },
    {
      "indent": 3,
      "text": "REQ 17: The overload mechanism must not provide an avenue for malicious attack, including DoS and DDoS attacks.",
      "ja": "REQ 17：オーバーロードメカニズムは、DoS攻撃やDDoS攻撃の攻撃など、悪意のある攻撃のための道を提供してはなりません。"
    },
    {
      "indent": 6,
      "text": "Meets REQ 17: Partially. Since overload control information is shared between a pair of communicating entities, a confidential and authenticated channel can be used for this communication. However, if such a channel is not available, then the security ramifications outlined in Section 11 apply.",
      "ja": "REQ 17を満たしている：一部。過負荷制御情報を通信エンティティの対の間で共有されるので、機密と認証されたチャネルは、この通信のために使用することができます。このようなチャネルが利用できない場合は、その後、第11節で概説したセキュリティ波及効果が適用されます。"
    },
    {
      "indent": 3,
      "text": "REQ 18: The overload mechanism should be unambiguous about whether a load indication applies to a specific IP address, host, or URI so that an upstream element can determine the load of the entity to which a request is to be sent.",
      "ja": "REQ 18：過負荷機構は、上流要素は、要求が送信されるまでエンティティの負荷を決定することができるように、負荷指示は、特定のIPアドレス、ホスト、またはURIに適用されるかどうかについて明白であるべきです。"
    },
    {
      "indent": 6,
      "text": "Meets REQ 18: Yes. Please see discussion in Section 5.5.",
      "ja": "REQ 18を満たしている：はい。 5.5節での議論を参照してください。"
    },
    {
      "indent": 3,
      "text": "REQ 19: The specification for the overload mechanism should give guidance on which message types might be desirable to process over others during times of overload, based on SIP-specific considerations. For example, it may be more beneficial to process a SUBSCRIBE refresh with Expires of zero than a SUBSCRIBE refresh with a non-zero expiration (since the former reduces the overall amount of load on the element) or to process re-INVITEs over new INVITEs.",
      "ja": "REQ 19：過負荷機構の仕様は、メッセージタイプはSIP固有の考慮事項に基づいて、過負荷の時間中に他のものよりも処理することが望ましいかもしれないれたガイダンスを与えるべきです。例えば、SUBSCRIBEと更新処理がより有益であり得る非ゼロの有効期限と更新SUBSCRIBE（前者は要素の負荷の全体量を減少させるため）、または新規のINVITEにわたって再招待処理するゼロより有効期限。"
    },
    {
      "indent": 6,
      "text": "Meets REQ 19: Yes. Please see Section 5.10.",
      "ja": "REQ 19を満たしている：はい。セクション5.10を参照してください。"
    },
    {
      "indent": 3,
      "text": "REQ 20: In a mixed environment of elements that do and do not implement the overload mechanism, no disproportionate benefit shall accrue to the users or operators of the elements that do not implement the mechanism.",
      "ja": "REQ 20：行うと過負荷メカニズムを実装していない要素が混在する環境では、何の不均衡な利点は、メカニズムを実装していない要素のユーザーまたはオペレータに計上してはなりません。"
    },
    {
      "indent": 6,
      "text": "Meets REQ 20: Yes. An element that does not implement overload control does not receive any measure of extra benefit.",
      "ja": "REQ 20を満たしている：はい。過負荷制御を実装していない要素が余分な利益のいずれかの措置を受けていません。"
    },
    {
      "indent": 3,
      "text": "REQ 21: The overload mechanism should ensure that the system remains stable. When the offered load drops from above the overall capacity of the network to below the overall capacity, the throughput should stabilize and become equal to the offered load.",
      "ja": "REQ 21：オーバーロードメカニズムは、システムが安定していることを確認する必要があります。提供された負荷が全体的な容量以下にネットワークの全体的な容量を上方から低下すると、スループットが安定化し、提供された負荷に等しくなるべきです。"
    },
    {
      "indent": 6,
      "text": "Meets REQ 21: Yes. The overload control mechanism described in this document ensures the stability of the system.",
      "ja": "REQ 21を満たしている：はい。この文書に記載された過負荷制御機構は、システムの安定性を確実にします。"
    },
    {
      "indent": 3,
      "text": "REQ 22: It must be possible to disable the reporting of load information towards upstream targets based on the identity of those targets. This allows a domain administrator who considers the load of their elements to be sensitive information to restrict access to that information. Of course, in such cases, there is no expectation that the overload mechanism itself will help prevent overload from that upstream target.",
      "ja": "REQ 22：それは、これらのターゲットのIDに基づいて、上流のターゲットに向けた負荷情報の報告を無効にすることが可能でなければなりません。これは、その要素の負荷は、その情報へのアクセスを制限する機密情報であると考えて、ドメイン管理者を可能にします。もちろん、このような場合には、過負荷メカニズム自体は、その上流のターゲットからの過負荷を防ぐことができますという期待がありません。"
    },
    {
      "indent": 6,
      "text": "Meets REQ 22: Yes. An operator of a SIP server can configure the SIP server to only report overload control information for requests received over a confidential channel, for example. However, note that this requirement is in conflict with REQ 3 as it introduces a modicum of extra configuration.",
      "ja": "REQ 22を満たしている：はい。 SIPサーバのオペレータは、例えば、機密チャネルを介して受信要求のためにのみレポート過負荷制御情報にSIPサーバを設定することができます。しかし、それは余分な構成のささやかを紹介し、この要件はREQ 3と競合していることに注意してください。"
    },
    {
      "indent": 3,
      "text": "REQ 23: It must be possible for the overload mechanism to work in cases where there is a load balancer in front of a farm of proxies.",
      "ja": "REQ 23：オーバーロードメカニズムは、プロキシの農場の前にロードバランサがある場合に作業することが可能でなければなりません。"
    },
    {
      "indent": 6,
      "text": "Meets REQ 23: Yes. Depending on the type of load balancer, this requirement is met. A load balancer fronting a farm of SIP proxies could be a SIP-aware load balancer or one that is not SIP-aware. If the load balancer is SIP-aware, it can make conscious decisions on throttling outgoing traffic towards the individual server in the farm based on the overload control parameters returned by the server. On the other hand, if the load balancer is not SIP-aware, then there are other strategies to perform overload control. Section 6 of [RFC6357] documents some of these strategies in more detail (see discussion related to Figure 3(a) of that document).",
      "ja": "REQ 23を満たしている：はい。ロードバランサの種類に応じて、この要件が満たされています。 SIPプロキシのファームに面しロードバランサは、SIP対応ロードバランサまたはSIP対応のないものであってもよいです。ロードバランサは、SIP対応の場合、それは、サーバによって返された過負荷制御パラメータに基づいて、ファーム内の個々のサーバーに向けて発信トラフィックを絞る上で意識的な決定を行うことができます。ロードバランサは、SIPに対応していない場合一方、その後、過負荷制御を実行するための他の戦略があります。 [RFC6357]のセクション6は、より詳細にこれらの戦略のいくつかを説明します（図に関連する説明を参照してください3（a）はその文書の）。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Vijay K. Gurbani (editor) Bell Labs, Alcatel-Lucent 1960 Lucent Lane, Rm 9C-533 Naperville, IL 60563 USA",
      "ja": "ビジェイK. Gurbani（エディタ）ベル研究所、アルカテル・ルーセント1960ルーセントレーン、Rmの9C-533ネーパーヴィル、IL 60563 USA"
    },
    {
      "indent": 3,
      "text": "EMail: vkg@bell-labs.com",
      "ja": "メールアドレス：vkg@bell-labs.com"
    },
    {
      "indent": 3,
      "text": "Volker Hilt Bell Labs, Alcatel-Lucent Lorenzstrasse 10 70435 Stuttgart Germany",
      "ja": "フォルカー柄ベル研究所、アルカテル・ルーセントLorenzstrasse 10 70435シュトゥットガルトドイツ"
    },
    {
      "indent": 3,
      "text": "EMail: volker.hilt@bell-labs.com",
      "ja": "メールアドレス：volker.hilt@bell-labs.com"
    },
    {
      "indent": 3,
      "text": "Henning Schulzrinne Columbia University/Department of Computer Science 450 Computer Science Building New York, NY 10027 USA",
      "ja": "コンピュータサイエンス450コンピュータサイエンスビル、ニューヨーク、NY 10027 USAのヘニングSchulzrinneとコロンビア大学/学部"
    },
    {
      "indent": 3,
      "text": "Phone: +1 212 939 7004 EMail: hgs@cs.columbia.edu URI: http://www.cs.columbia.edu",
      "ja": "電話：+1 212 939 7004 Eメール：hgs@cs.columbia.edu URI：http://www.cs.columbia.edu"
    }
  ]
}