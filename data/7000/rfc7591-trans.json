{
  "title": {
    "text": "RFC 7591 - OAuth 2.0 Dynamic Client Registration Protocol",
    "ja": "RFC 7591 - OAuth 2.0の動的クライアント登録プロトコル"
  },
  "number": 7591,
  "created_at": "2019-10-30 20:34:14.348158+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                    J. Richer, Ed.\nRequest for Comments: 7591\nCategory: Standards Track                                       M. Jones\nISSN: 2070-1721                                                Microsoft\n                                                              J. Bradley\n                                                           Ping Identity\n                                                             M. Machulak\n                                                    Newcastle University\n                                                                 P. Hunt\n                                                      Oracle Corporation\n                                                               July 2015",
      "raw": true
    },
    {
      "indent": 13,
      "text": "OAuth 2.0 Dynamic Client Registration Protocol",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This specification defines mechanisms for dynamically registering OAuth 2.0 clients with authorization servers. Registration requests send a set of desired client metadata values to the authorization server. The resulting registration responses return a client identifier to use at the authorization server and the client metadata values registered for the client. The client can then use this registration information to communicate with the authorization server using the OAuth 2.0 protocol. This specification also defines a set of common client metadata fields and values for clients to use during registration.",
      "ja": "この仕様は、動的認証サーバとのOAuth 2.0のクライアントを登録するためのメカニズムを定義します。登録要求は、認証サーバに必要なクライアントメタデータ値のセットを送信します。その結果、登録応答は、認証サーバーとクライアントのために登録されたクライアントのメタデータの値で使用するようにクライアント識別子を返します。次に、クライアントは、OAuth 2.0のプロトコルを使用して認証サーバとの通信に、この登録情報を使用することができます。また、この仕様は、クライアントが登録中に使用するための一般的なクライアントメタデータフィールドと値のセットを定義します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 5741のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7591.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7591で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2015 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2015 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   4\n  1.1.  Notational Conventions  . . . . . . . . . . . . . . . . .   4\n  1.2.  Terminology . . . . . . . . . . . . . . . . . . . . . . .   4\n  1.3.  Protocol Flow . . . . . . . . . . . . . . . . . . . . . .   7\n2.  Client Metadata . . . . . . . . . . . . . . . . . . . . . . .   8\n  2.1.  Relationship between Grant Types and Response Types . . .  12\n  2.2.  Human-Readable Client Metadata  . . . . . . . . . . . . .  13\n  2.3.  Software Statement  . . . . . . . . . . . . . . . . . . .  14\n3.  Client Registration Endpoint  . . . . . . . . . . . . . . . .  15\n  3.1.  Client Registration Request . . . . . . . . . . . . . . .  16\n    3.1.1.  Client Registration Request Using a Software\n            Statement . . . . . . . . . . . . . . . . . . . . . .  18\n  3.2.  Responses . . . . . . . . . . . . . . . . . . . . . . . .  19\n    3.2.1.  Client Information Response . . . . . . . . . . . . .  19\n    3.2.2.  Client Registration Error Response  . . . . . . . . .  21\n4.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  23\n  4.1.  OAuth Dynamic Client Registration Metadata Registry . . .  22\n    4.1.1.  Registration Template . . . . . . . . . . . . . . . .  24\n    4.1.2.  Initial Registry Contents . . . . . . . . . . . . . .  24\n  4.2.  OAuth Token Endpoint Authentication Methods Registry  . .  27\n    4.2.1.  Registration Template . . . . . . . . . . . . . . . .  28\n    4.2.2.  Initial Registry Contents . . . . . . . . . . . . . .  28\n5.  Security Considerations . . . . . . . . . . . . . . . . . . .  28\n6.  Privacy Considerations  . . . . . . . . . . . . . . . . . . .  32\n7.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  33\n  7.1.  Normative References  . . . . . . . . . . . . . . . . . .  33\n  7.2.  Informative References  . . . . . . . . . . . . . . . . .  35\nAppendix A.  Use Cases  . . . . . . . . . . . . . . . . . . . . .  33\n  A.1.  Open versus Protected Dynamic Client Registration . . . .  34\n    A.1.1.  Open Dynamic Client Registration  . . . . . . . . . .  34\n    A.1.2.  Protected Dynamic Client Registration . . . . . . . .  34\n  A.2.  Registration without or with Software Statements  . . . .  34\n    A.2.1.  Registration without a Software Statement . . . . . .  34\n    A.2.2.  Registration with a Software Statement  . . . . . . .  34\n  A.3.  Registration by the Client or Developer . . . . . . . . .  34\n    A.3.1.  Registration by the Client  . . . . . . . . . . . . .  35\n    A.3.2.  Registration by the Developer . . . . . . . . . . . .  35\n  A.4.  Client ID per Client Instance or per Client Software  . .  35\n    A.4.1.  Client ID per Client Software Instance  . . . . . . .  35\n    A.4.2.  Client ID Shared among All Instances of Client\n            Software  . . . . . . . . . . . . . . . . . . . . . .  35\n  A.5.  Stateful or Stateless Registration  . . . . . . . . . . .  35\n    A.5.1.  Stateful Client Registration  . . . . . . . . . . . .  36\n    A.5.2.  Stateless Client Registration . . . . . . . . . . . .  36\nAcknowledgments . . . . . . . . . . . . . . . . . . . . . . . . .  36\nAuthors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  36",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "In order for an OAuth 2.0 [RFC6749] client to utilize an OAuth 2.0 authorization server, the client needs specific information to interact with the server, including an OAuth 2.0 client identifier to use at that server. This specification describes how an OAuth 2.0 client can be dynamically registered with an authorization server to obtain this information.",
      "ja": "OAuth 2.0の認証サーバを利用するOAuth 2.0の[RFC6749]クライアントのために、クライアントは、そのサーバで使用するOAuth 2.0のクライアント識別子を含む、サーバと相互作用する特定の情報を必要とします。この仕様はOAuth 2.0のクライアントは、この情報を動的に取得するために、認証サーバに登録する方法について説明します。"
    },
    {
      "indent": 3,
      "text": "As part of the registration process, this specification also defines a mechanism for the client to present the authorization server with a set of metadata, such as a set of valid redirection URIs. This metadata can either be communicated in a self-asserted fashion or as a set of metadata called a software statement, which is digitally signed or protected with a Message Authentication Code (MAC); in the case of a software statement, the issuer is vouching for the validity of the data about the client.",
      "ja": "登録プロセスの一部として、本明細書はまた、クライアントは、有効なリダイレクトURIのセットとしてメタデータのセットと認証サーバを提示するためのメカニズムを定義します。このメタデータは、いずれかの自己アサート様式で又はデジタルメッセージ認証コード（MAC）で署名されたまたは保護されたソフトウェア命令と呼ばれるメタデータのセットとして通信することができます。ソフトウェア文の場合には、発行者は、クライアントに関するデータの有効性のためにバウチングされます。"
    },
    {
      "indent": 3,
      "text": "Traditionally, registration of a client with an authorization server is performed manually. The mechanisms defined in this specification can be used either for a client to dynamically register itself with authorization servers or for a client developer to programmatically register the client with authorization servers. Multiple applications using OAuth 2.0 have previously developed mechanisms for accomplishing such registrations. This specification generalizes the registration mechanisms defined by \"OpenID Connect Dynamic Client Registration 1.0\" [OpenID.Registration] and used by \"User Managed Access (UMA) Profile of OAuth 2.0\" [UMA-Core] in a way that is compatible with both, while being applicable to a wider set of OAuth 2.0 use cases.",
      "ja": "伝統的に、認証サーバとクライアントの登録は手動で行われます。この仕様で定義されたメカニズムは、動的認可サーバに自身を登録するためのクライアントのためか、プログラムの認証サーバとクライアントを登録するには、クライアント開発者のためにも使用することができます。 OAuth 2.0のを使用して複数のアプリケーションは、以前、このような登録を達成するための仕組みを開発しました。この仕様は、「OpenIDの接続ダイナミッククライアント登録1.0」[OpenID.Registration]によって定義され、「OAuth 2.0のユーザ管理アクセス（UMA）プロファイル」で使用される登録メカニズムを一般の両方と互換性のある方法で、[UMAコア] OAuth 2.0のユースケースより広いセットに適用されつつ。"
    },
    {
      "indent": 0,
      "text": "1.1. Notational Conventions",
      "section_title": true,
      "ja": "1.1. 表記規則"
    },
    {
      "indent": 3,
      "text": "The key words 'MUST', 'MUST NOT', 'REQUIRED', 'SHALL', 'SHALL NOT', 'SHOULD', 'SHOULD NOT', 'RECOMMENDED', 'MAY', and 'OPTIONAL' in this document are to be interpreted as described in [RFC2119].",
      "ja": "キーワード 'MUST'、 'REQUIRED'、、、、 'べきではない' 'べきです' 'ないもの' '（SHALL）' 'てはならない'、 '推奨'、 'MAY'、および 'OPTIONAL' この文書に記載されています[RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 3,
      "text": "Unless otherwise noted, all the protocol parameter names and values are case sensitive.",
      "ja": "特に断りのない限り、すべてのプロトコルのパラメータ名と値は、大文字と小文字が区別されます。"
    },
    {
      "indent": 0,
      "text": "1.2. Terminology",
      "section_title": true,
      "ja": "1.2. 用語"
    },
    {
      "indent": 3,
      "text": "This specification uses the terms \"access token\", \"authorization code\", \"authorization endpoint\", \"authorization grant\", \"authorization server\", \"client\", \"client identifier\", \"client secret\", \"grant type\", \"protected resource\", \"redirection URI\",",
      "ja": "この仕様は、用語を使用しています「アクセストークン」、「認証コード」、「認可エンドポイント」、「承認助成金」、「認証サーバ」、「クライアント」、「クライアント識別子」、「クライアントシークレット」、「許可タイプ」、 \"保護されたリソース」、 『リダイレクトURI』、"
    },
    {
      "indent": 3,
      "text": "\"refresh token\", \"resource owner\", \"resource server\", \"response type\", and \"token endpoint\" defined by OAuth 2.0 [RFC6749] and uses the term \"Claim\" defined by JSON Web Token (JWT) [RFC7519].",
      "ja": "「リフレッシュトークン」、「リソース所有者」、「リソースサーバ」、「応答タイプ」、および「トークンエンドポイント」のOAuth 2.0 [RFC6749]で定義され、JSONウェブトークン（JWT）[RFC7519]で定義された用語「クレーム」を使用。"
    },
    {
      "indent": 3,
      "text": "This specification defines the following terms:",
      "ja": "この仕様は、次の用語を定義しています。"
    },
    {
      "indent": 3,
      "text": "Client Software Software implementing an OAuth 2.0 client.",
      "ja": "OAuth 2.0のクライアントを実装するクライアントソフトウェアソフトウェア。"
    },
    {
      "indent": 3,
      "text": "Client Instance A deployed instance of a piece of client software.",
      "ja": "クライアントインスタンスAは、クライアントソフトウェアの一部のインスタンスを展開しました。"
    },
    {
      "indent": 3,
      "text": "Client Developer The person or organization that builds a client software package and prepares it for distribution. At the time the client is built, the developer is often not aware of who the deploying service provider organizations will be. Client developers will need to use dynamic registration when they are unable to predict aspects of the software, such as the deployment URLs, at compile time. For instance, this can occur when the software API publisher and the deploying organization are not the same.",
      "ja": "クライアント開発者クライアント・ソフトウェア・パッケージを構築し、配布のためにそれを準備する個人または組織。クライアントが構築された時点で、開発者は多くの場合、展開サービスプロバイダ組織がなる誰を認識しません。クライアント開発者はソフトウェアの側面を予測することができない場合、コンパイル時には、そのような展開のURLなど、動的登録を使用する必要があります。例えば、これは、ソフトウェアAPIの出版社と展開組織が同じでないときに発生することができます。"
    },
    {
      "indent": 3,
      "text": "Client Registration Endpoint OAuth 2.0 endpoint through which a client can be registered at an authorization server. The means by which the URL for this endpoint is obtained are out of scope for this specification.",
      "ja": "クライアント登録エンドポイントのOAuth 2.0エンドポイントは、それを通して、クライアントは認証サーバに登録することができます。このエンドポイントのURLを取得する手段は、本明細書の範囲外です。"
    },
    {
      "indent": 3,
      "text": "Initial Access Token OAuth 2.0 access token optionally issued by an authorization server to a developer or client and used to authorize calls to the client registration endpoint. The type and format of this token are likely service specific and are out of scope for this specification. The means by which the authorization server issues this token as well as the means by which the registration endpoint validates this token are out of scope for this specification. Use of an initial access token is required when the authorization server limits the parties that can register a client.",
      "ja": "初期アクセストークンのOAuth 2.0アクセストークン、必要に応じて、開発者やクライアントに認証サーバによって発行され、クライアント登録エンドポイントへの呼び出しを許可するために使用しました。このトークンの種類や形式は、特定のサービス可能性があり、この仕様の範囲外です。手段は、それによって認証サーバの問題このトークンだけでなく、登録エンドポイントは、このトークンを検証する手段は、この仕様の範囲外です。認証サーバはクライアントを登録することができ、当事者が制限されたときに、最初のアクセストークンの使用が必要とされます。"
    },
    {
      "indent": 3,
      "text": "Deployment Organization An administrative security domain under which a software API (service) is deployed and protected by an OAuth 2.0 framework. In some OAuth scenarios, the deployment organization and the software API publisher are the same. In these cases, the deploying organization will often have a close relationship with client software developers. In many other cases, the definer of the service may be an independent third-party publisher or a standards organization. When working to a published specification for an",
      "ja": "展開組織のソフトウェアAPI（サービス）を展開し、OAuth 2.0のフレームワークによって保護されている下アン管理セキュリティドメイン。いくつかのOAuthシナリオでは、展開組織とソフトウェアのAPI発行者は同じです。これらのケースでは、展開組織は、多くの場合、クライアントのソフトウェア開発者と密接な関係を持つことになります。他の多くの例では、サービスの定義は、独立した第三者の出版社や標準化団体です。以下のために公開された仕様に作業している場合"
    },
    {
      "indent": 6,
      "text": "API, the client software developer is unable to have a prior relationship with the potentially many deployment organizations deploying the software API (service).",
      "ja": "APIは、クライアント・ソフトウェアの開発者は、ソフトウェアのAPI（サービス）を展開潜在的に多くの展開団体との事前の関係を持つことができません。"
    },
    {
      "indent": 3,
      "text": "Software API Deployment A deployed instance of a software API that is protected by OAuth 2.0 (a protected resource) in a particular deployment organization domain. For any particular software API, there may be one or more deployments. A software API deployment typically has an associated OAuth 2.0 authorization server as well as a client registration endpoint. The means by which endpoints are obtained are out of scope for this specification.",
      "ja": "ソフトウェアのAPI展開Aは、特定のデプロイメントの組織ドメインにはOAuth 2.0（保護されたリソース）によって保護されたソフトウェアAPIのインスタンスを展開しました。任意の特定のソフトウェアAPIについては、一話の以上の展開があるかもしれません。ソフトウェアのAPIの導入は、一般的に関連付けられたOAuth 2.0の認証サーバだけでなく、クライアントの登録エンドポイントを持っています。エンドポイントが取得される手段は、本明細書の範囲外です。"
    },
    {
      "indent": 3,
      "text": "Software API Publisher The organization that defines a particular web-accessible API that may be deployed in one or more deployment environments. A publisher may be any standards body, commercial, public, private, or open source organization that is responsible for publishing and distributing software and API specifications that may be protected via OAuth 2.0. In some cases, a software API publisher and a client developer may be the same organization. At the time of publication of a web-accessible API, the software publisher often does not have a prior relationship with the deploying organizations.",
      "ja": "ソフトウェアのAPI出版社一つ以上のデプロイメント環境に展開することができる特定のウェブアクセス可能なAPIを定義する組織。出版社は、商用パブリック、プライベート、または出版を担当するとのOAuth 2.0を経由して保護することができるソフトウェアおよびAPIの仕様を配布されたオープンソース団体、任意の標準化体であってもよいです。いくつかのケースでは、ソフトウェアのAPI発行者およびクライアント開発者は、同じ組織かもしれません。ウェブアクセス可能なAPIの公開時点で、ソフトウェアの発行者は、多くの場合、展開団体との事前の関係はありません。"
    },
    {
      "indent": 3,
      "text": "Software Statement A digitally signed or MACed JSON Web Token (JWT) [RFC7519] that asserts metadata values about the client software. In some cases, a software statement will be issued directly by the client developer. In other cases, a software statement will be issued by a third-party organization for use by the client developer. In both cases, the trust relationship the authorization server has with the issuer of the software statement is intended to be used as an input to the evaluation of whether the registration request is accepted. A software statement can be presented to an authorization server as part of a client registration request.",
      "ja": "ソフトウェアに関する声明クライアントソフトウェアに関するメタデータの値をアサートデジタル署名またはMACed JSONウェブトークン（JWT）[RFC7519]。いくつかのケースでは、ソフトウェアのステートメントは、クライアント開発者によって直接発行されます。他の例では、ソフトウェアのステートメントは、クライアント開発者が使用するための第三者機関によって発行されます。どちらの場合も、ソフトウェア文の発行者と認証サーバが持つ信頼関係は、登録要求が受け入れられるかどうかの評価への入力として使用されることを意図しています。ソフトウェア文は、クライアント登録要求の一部として認証サーバに提示することができます。"
    },
    {
      "indent": 0,
      "text": "1.3. Protocol Flow",
      "section_title": true,
      "ja": "1.3. プロトコルフロー"
    },
    {
      "indent": 4,
      "text": "    +--------(A)- Initial Access Token (OPTIONAL)\n    |\n    |   +----(B)- Software Statement (OPTIONAL)\n    |   |\n    v   v\n+-----------+                                      +---------------+\n|           |--(C)- Client Registration Request -->|    Client     |\n| Client or |                                      | Registration  |\n| Developer |<-(D)- Client Information Response ---|   Endpoint    |\n|           |        or Client Error Response      +---------------+\n+-----------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Figure 1: Abstract Dynamic Client Registration Flow",
      "ja": "図1：抽象動的クライアント登録の流れ"
    },
    {
      "indent": 3,
      "text": "The abstract OAuth 2.0 client dynamic registration flow illustrated in Figure 1 describes the interaction between the client or developer and the endpoint defined in this specification. This figure does not demonstrate error conditions. This flow includes the following steps:",
      "ja": "図1に示す抽象OAuth 2.0のクライアントの動的登録フローは、クライアントまたは現像剤と本明細書で定義されたエンドポイントとの間の相互作用を記載します。この図は、エラー状態を示すものではありません。この流れは、以下のステップを含みます。"
    },
    {
      "indent": 3,
      "text": "(A) Optionally, the client or developer is issued an initial access token giving access to the client registration endpoint. The method by which the initial access token is issued to the client or developer is out of scope for this specification.",
      "ja": "（A）オプションでは、クライアントや開発者は、クライアント登録エンドポイントへのアクセスを与える最初のアクセストークンを発行しています。初期アクセストークンは、クライアントや開発者に発行される方法は、この仕様の範囲外です。"
    },
    {
      "indent": 3,
      "text": "(B) Optionally, the client or developer is issued a software statement for use with the client registration endpoint. The method by which the software statement is issued to the client or developer is out of scope for this specification.",
      "ja": "（B）オプションは、クライアントや開発者は、クライアント登録のエンドポイントで使用するためのソフトウェアの声明を発表しています。ソフトウェア文がクライアントや開発者に発行される方法は、この仕様の範囲外です。"
    },
    {
      "indent": 3,
      "text": "(C) The client or developer calls the client registration endpoint with the client's desired registration metadata, optionally including the initial access token from (A) if one is required by the authorization server.",
      "ja": "一つは、認可サーバによって必要とされる場合（C）は、クライアントまたは開発者は、必要に応じて（A）からの初期アクセストークンを含む、クライアントの所望の登録メタデータとクライアントの登録エンドポイントを呼び出します。"
    },
    {
      "indent": 3,
      "text": "(D) The authorization server registers the client and returns:",
      "ja": "（D）、認可サーバは、クライアントとリターンを登録します。"
    },
    {
      "indent": 9,
      "text": "* the client's registered metadata,",
      "ja": "*クライアントの登録メタデータ、"
    },
    {
      "indent": 9,
      "text": "* a client identifier that is unique at the server, and",
      "ja": "*クライアント・サーバでユニークな識別子であり、"
    },
    {
      "indent": 9,
      "text": "* a set of client credentials such as a client secret, if applicable for this client.",
      "ja": "*、クライアントの秘密など、クライアントの資格情報のセットを、このクライアントのために該当する場合。"
    },
    {
      "indent": 3,
      "text": "Examples of different configurations and usages are included in Appendix A.",
      "ja": "異なる構成と使用の例は、付録Aに含まれています"
    },
    {
      "indent": 0,
      "text": "2. Client Metadata",
      "section_title": true,
      "ja": "2.クライアントのメタデータ"
    },
    {
      "indent": 3,
      "text": "Registered clients have a set of metadata values associated with their client identifier at an authorization server, such as the list of valid redirection URIs or a display name.",
      "ja": "登録されたクライアントは、このような有効なリダイレクトURIのリストまたは表示名として、認証サーバで彼らのクライアント識別子に関連付けられたメタデータ値のセットを持っています。"
    },
    {
      "indent": 3,
      "text": "These client metadata values are used in two ways:",
      "ja": "これらのクライアントメタデータの値は、次の2つの方法で使用されます。"
    },
    {
      "indent": 3,
      "text": "o as input values to registration requests, and",
      "ja": "登録要求への入力値としてO、及び"
    },
    {
      "indent": 3,
      "text": "o as output values in registration responses.",
      "ja": "登録応答の出力値として、O。"
    },
    {
      "indent": 3,
      "text": "The following client metadata fields are defined by this specification. The implementation and use of all client metadata fields is OPTIONAL, unless stated otherwise. All data member types (strings, arrays, numbers) are defined in terms of their JSON [RFC7159] representations.",
      "ja": "次のクライアントメタデータフィールドは、この仕様で定義されています。特に断りのない限り、すべてのクライアントのメタデータフィールドの実装と使用は、任意です。すべてのデータ・メンバー・タイプ（文字列、アレイ、数字）は、それらのJSON [RFC7159]表現の観点で定義されています。"
    },
    {
      "indent": 3,
      "text": "redirect_uris Array of redirection URI strings for use in redirect-based flows such as the authorization code and implicit flows. As required by Section 2 of OAuth 2.0 [RFC6749], clients using flows with redirection MUST register their redirection URI values. Authorization servers that support dynamic registration for redirect-based flows MUST implement support for this metadata value.",
      "ja": "このような認証コードと暗黙的な流れとしてリダイレクト・ベースのフローで使用するためのリダイレクトURIストリングのredirect_urisアレイ。 OAuth 2.0の[RFC6749]のセクション2によって要求されるように、リダイレクションとフローを用いてクライアントはリダイレクトURI値を登録しなければなりません。リダイレクトベースのフローの動的登録をサポートする認証サーバは、このメタデータ値のサポートを実装しなければなりません。"
    },
    {
      "indent": 3,
      "text": "token_endpoint_auth_method String indicator of the requested authentication method for the token endpoint. Values defined by this specification are:",
      "ja": "トークンエンドポイントの要求された認証方法のtoken_endpoint_auth_method文字列インジケータ。この仕様で定義された値は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "* \"none\": The client is a public client as defined in OAuth 2.0, Section 2.1, and does not have a client secret.",
      "ja": "*「なし」：クライアントがOAuth 2.0の、2.1節で定義されたパブリッククライアントではなく、クライアントの秘密を持っていません。"
    },
    {
      "indent": 6,
      "text": "* \"client_secret_post\": The client uses the HTTP POST parameters as defined in OAuth 2.0, Section 2.3.1.",
      "ja": "* \"client_secret_postは\"：クライアントがOAuth 2.0の、セクション2.3.1で定義されたHTTPのPOSTパラメータを使用しています。"
    },
    {
      "indent": 6,
      "text": "* \"client_secret_basic\": The client uses HTTP Basic as defined in OAuth 2.0, Section 2.3.1.",
      "ja": "* \"client_secret_basic\"：OAuth 2.0の、セクション2.3.1で定義されているクライアントは、HTTP Basicを使用しています。"
    },
    {
      "indent": 6,
      "text": "Additional values can be defined via the IANA \"OAuth Token Endpoint Authentication Methods\" registry established in Section 4.2. Absolute URIs can also be used as values for this parameter without being registered. If unspecified or omitted, the default is \"client_secret_basic\", denoting the HTTP Basic authentication scheme as specified in Section 2.3.1 of OAuth 2.0.",
      "ja": "追加の値は、4.2節に設立IANA「OAuthのトーク​​ンエンドポイント認証方式」のレジストリを介して定義することができます。絶対URIが登録されずにこのパラメータの値としても使用することができます。未指定または省略した場合、デフォルトではOAuth 2.0のセクション2.3.1に指定されているHTTP基本認証スキームを表す、「client_secret_basic」です。"
    },
    {
      "indent": 3,
      "text": "grant_types Array of OAuth 2.0 grant type strings that the client can use at the token endpoint. These grant types are defined as follows:",
      "ja": "クライアントはトークンエンドポイントで使用することができOAuth 2.0の許可タイプの文字列の配列をgrant_types。次のようにこれらの助成金の種類が定義されています。"
    },
    {
      "indent": 6,
      "text": "* \"authorization_code\": The authorization code grant type defined in OAuth 2.0, Section 4.1.",
      "ja": "*「authorization_code」：OAuth 2.0の、セクション4.1で定義された認可コードグラントタイプ。"
    },
    {
      "indent": 6,
      "text": "* \"implicit\": The implicit grant type defined in OAuth 2.0, Section 4.2.",
      "ja": "*「暗黙」：OAuth 2.0の中で定義された暗黙的な許可タイプ、セクション4.2。"
    },
    {
      "indent": 6,
      "text": "* \"password\": The resource owner password credentials grant type defined in OAuth 2.0, Section 4.3.",
      "ja": "*「パスワード」：リソースの所有者のパスワードの認証情報は、OAuth 2.0の中で定義された型、4.3節を付与します。"
    },
    {
      "indent": 6,
      "text": "* \"client_credentials\": The client credentials grant type defined in OAuth 2.0, Section 4.4.",
      "ja": "*「client_credentials」：クライアントの資格情報はOAuth 2.0の、セクション4.4で定義された型を付与します。"
    },
    {
      "indent": 6,
      "text": "* \"refresh_token\": The refresh token grant type defined in OAuth 2.0, Section 6.",
      "ja": "*「refresh_token」：OAuth 2.0の、第6節で定義されたリフレッシュトークン許可タイプ。"
    },
    {
      "indent": 6,
      "text": "* \"urn:ietf:params:oauth:grant-type:jwt-bearer\": The JWT Bearer Token Grant Type defined in OAuth JWT Bearer Token Profiles [RFC7523].",
      "ja": "* \"URN：IETF：paramsは：のOAuth：助成金型：JWTベアラ\"：OAuthのJWTベアラトークンプロファイル[RFC7523]で定義されたJWTベアラトークングラントタイプ。"
    },
    {
      "indent": 6,
      "text": "* \"urn:ietf:params:oauth:grant-type:saml2-bearer\": The SAML 2.0 Bearer Assertion Grant defined in OAuth SAML 2 Bearer Token Profiles [RFC7522].",
      "ja": "* \"URN：IETF：paramsは：のOAuth：助成金型：SAML2ベアラ\"：OAuthのSAML 2つのベアラトークンプロファイル[RFC7522]で定義されたSAML 2.0ベアラーアサーショングラント。"
    },
    {
      "indent": 6,
      "text": "If the token endpoint is used in the grant type, the value of this parameter MUST be the same as the value of the \"grant_type\" parameter passed to the token endpoint defined in the grant type definition. Authorization servers MAY allow for other values as defined in the grant type extension process described in OAuth 2.0, Section 4.5. If omitted, the default behavior is that the client will use only the \"authorization_code\" Grant Type.",
      "ja": "トークンエンドポイントが付与型で使用される場合、このパラメータの値は、付与型定義で定義されたトークンエンドポイントに渡される「grant_type」パラメータの値と同じでなければなりません。 OAuth 2.0の、4.5節で説明したグラント型エクステンションプロセスで定義されている認可サーバは、他の値を可能にすることができます。省略した場合、デフォルトの動作は、クライアントが唯一の「authorization_code」グラントタイプを使用することです。"
    },
    {
      "indent": 3,
      "text": "response_types Array of the OAuth 2.0 response type strings that the client can use at the authorization endpoint. These response types are defined as follows:",
      "ja": "クライアントが認可エンドポイントで使用することができOAuth 2.0のレスポンス型の文字列の配列をresponse_types。次のようにこれらの応答タイプが定義されています。"
    },
    {
      "indent": 6,
      "text": "* \"code\": The authorization code response type defined in OAuth 2.0, Section 4.1.",
      "ja": "*「コード」：OAuth 2.0の、セクション4.1で定義された認証コード応答タイプ。"
    },
    {
      "indent": 6,
      "text": "* \"token\": The implicit response type defined in OAuth 2.0, Section 4.2.",
      "ja": "*「トークン」のOAuth 2.0、4.2節で定義された暗黙的な応答タイプ。"
    },
    {
      "indent": 6,
      "text": "If the authorization endpoint is used by the grant type, the value of this parameter MUST be the same as the value of the \"response_type\" parameter passed to the authorization endpoint defined in the grant type definition. Authorization servers MAY allow for other values as defined in the grant type extension process is described in OAuth 2.0, Section 4.5. If omitted, the default is that the client will use only the \"code\" response type.",
      "ja": "許可エンドポイントが付与タイプによって使用されている場合、このパラメータの値は、付与型定義で定義された認可エンドポイントに渡される「response_type」パラメータの値と同じでなければなりません。 OAuth 2.0の、4.5節に記載されているグラント型エクステンションプロセスで定義されている認可サーバは、他の値を可能にすることができます。省略した場合、デフォルトでは、クライアントが唯一の「コード」応答タイプを使用することです。"
    },
    {
      "indent": 3,
      "text": "client_name Human-readable string name of the client to be presented to the end-user during authorization. If omitted, the authorization server MAY display the raw \"client_id\" value to the end-user instead. It is RECOMMENDED that clients always send this field. The value of this field MAY be internationalized, as described in Section 2.2.",
      "ja": "認証時にエンドユーザーに提示するためのクライアントの判読できる文字列の名前をCLIENT_NAME。省略した場合、認証サーバではなく、エンドユーザに生「のclient_id」の値を表示することがあります。クライアントは常にこのフィールドを送信することが推奨されます。 2.2節で説明したように、このフィールドの値は、国際化されるかもしれません。"
    },
    {
      "indent": 3,
      "text": "client_uri URL string of a web page providing information about the client. If present, the server SHOULD display this URL to the end-user in a clickable fashion. It is RECOMMENDED that clients always send this field. The value of this field MUST point to a valid web page. The value of this field MAY be internationalized, as described in Section 2.2.",
      "ja": "クライアントに関する情報を提供するウェブページのclient_uri URL文字列。存在する場合、サーバは、クリック可能な形でエンドユーザーにこのURLが表示されます。クライアントは常にこのフィールドを送信することが推奨されます。このフィールドの値が有効なWebページを指している必要があります。 2.2節で説明したように、このフィールドの値は、国際化されるかもしれません。"
    },
    {
      "indent": 3,
      "text": "logo_uri URL string that references a logo for the client. If present, the server SHOULD display this image to the end-user during approval. The value of this field MUST point to a valid image file. The value of this field MAY be internationalized, as described in Section 2.2.",
      "ja": "クライアントのロゴを参照するlogo_uri URL文字列。存在する場合、サーバーは、承認時にエンドユーザーにこの画像が表示されます。このフィールドの値が有効なイメージファイルを指している必要があります。 2.2節で説明したように、このフィールドの値は、国際化されるかもしれません。"
    },
    {
      "indent": 3,
      "text": "scope String containing a space-separated list of scope values (as described in Section 3.3 of OAuth 2.0 [RFC6749]) that the client can use when requesting access tokens. The semantics of values in this list are service specific. If omitted, an authorization server MAY register a client with a default set of scopes.",
      "ja": "アクセストークンを要求するときにクライアントが使用できるスコープ値（OAuth 2.0のセクション3.3に記載されているように[RFC6749]）のスペースで区切られたリストを含む範囲文字列。このリスト内の値の意味は、サービス固有のものです。省略した場合、認証サーバは、スコープのデフォルトセットを使用してクライアントを登録することもできます。"
    },
    {
      "indent": 3,
      "text": "contacts Array of strings representing ways to contact people responsible for this client, typically email addresses. The authorization server MAY make these contact addresses available to end-users for support requests for the client. See Section 6 for information on Privacy Considerations.",
      "ja": "このクライアント、通常、メールアドレスの担当者に連絡する方法を表す文字列の接点配列。認証サーバは、クライアントのサポート要求のためのエンドユーザーにこれらの連絡先が利用可能にすることができます。プライバシーの考慮事項については、第6章を参照してください。"
    },
    {
      "indent": 3,
      "text": "tos_uri URL string that points to a human-readable terms of service document for the client that describes a contractual relationship between the end-user and the client that the end-user accepts when authorizing the client. The authorization server SHOULD display this URL to the end-user if it is provided. The value of this field MUST point to a valid web page. The value of this field MAY be internationalized, as described in Section 2.2.",
      "ja": "クライアントを認証する場合、エンドユーザーが受け入れることを、エンドユーザーとクライアントの間の契約関係を説明し、クライアントのためのサービスドキュメントの人間が読める用語を指すtos_uri URL文字列。それが提供されている場合、認証サーバは、エンドユーザにこのURLが表示されます。このフィールドの値が有効なWebページを指している必要があります。 2.2節で説明したように、このフィールドの値は、国際化されるかもしれません。"
    },
    {
      "indent": 3,
      "text": "policy_uri URL string that points to a human-readable privacy policy document that describes how the deployment organization collects, uses, retains, and discloses personal data. The authorization server SHOULD display this URL to the end-user if it is provided. The value of this field MUST point to a valid web page. The value of this field MAY be internationalized, as described in Section 2.2.",
      "ja": "展開組織は、収集し使用し、保持しており、個人データを開示している方法について説明し、人間が読めるプライバシーポリシー文書を指すpolicy_uri URL文字列。それが提供されている場合、認証サーバは、エンドユーザにこのURLが表示されます。このフィールドの値が有効なWebページを指している必要があります。 2.2節で説明したように、このフィールドの値は、国際化されるかもしれません。"
    },
    {
      "indent": 3,
      "text": "jwks_uri URL string referencing the client's JSON Web Key (JWK) Set [RFC7517] document, which contains the client's public keys. The value of this field MUST point to a valid JWK Set document. These keys can be used by higher-level protocols that use signing or encryption. For instance, these keys might be used by some applications for validating signed requests made to the token endpoint when using JWTs for client authentication [RFC7523]. Use of this parameter is preferred over the \"jwks\" parameter, as it allows for easier key rotation. The \"jwks_uri\" and \"jwks\" parameters MUST NOT both be present in the same request or response.",
      "ja": "クライアントの公開鍵を含むクライアントのJSONのWebキー（JWK）セット[RFC7517]の文書を、参照jwks_uri URL文字列。このフィールドの値は、有効なJWKセット文書を指している必要があります。これらのキーは、署名や暗号化を使用する高レベルプロトコルで使用することができます。例えば、これらのキーは、クライアント認証[RFC7523]のためのJWTsを使用したときに、トークンエンドポイントに作られた署名要求を検証するためのいくつかのアプリケーションで使用される可能性があります。それが簡単にキーローテーションが可能になりますように、このパラメータを使用するには、「jwks」パラメータよりも好ましいです。 「jwks_uri」および「jwks」パラメータは、両方が同じ要求または応答に存在してはなりません。"
    },
    {
      "indent": 3,
      "text": "jwks Client's JSON Web Key Set [RFC7517] document value, which contains the client's public keys. The value of this field MUST be a JSON object containing a valid JWK Set. These keys can be used by higher-level protocols that use signing or encryption. This parameter is intended to be used by clients that cannot use the \"jwks_uri\" parameter, such as native clients that cannot host public URLs. The \"jwks_uri\" and \"jwks\" parameters MUST NOT both be present in the same request or response.",
      "ja": "クライアントの公開鍵が含まれていjwksクライアントのJSONのWebキーセット[RFC7517]ドキュメント値、。このフィールドの値は、有効なJWKセットを含むJSONオブジェクトでなければなりません。これらのキーは、署名や暗号化を使用する高レベルプロトコルで使用することができます。このパラメータは、このようなパブリックURLをホストすることはできませんネイティブクライアントとして、「jwks_uri」パラメータを使用できないクライアントが使用することを意図しています。 「jwks_uri」および「jwks」パラメータは、両方が同じ要求または応答に存在してはなりません。"
    },
    {
      "indent": 3,
      "text": "software_id A unique identifier string (e.g., a Universally Unique Identifier (UUID)) assigned by the client developer or software publisher used by registration endpoints to identify the client software to be dynamically registered. Unlike \"client_id\", which is issued by the authorization server and SHOULD vary between instances, the \"software_id\" SHOULD remain the same for all instances of the client software. The \"software_id\" SHOULD remain the same across multiple updates or versions of the same piece of software. The value of this field is not intended to be human readable and is usually opaque to the client and authorization server.",
      "ja": "動的に登録されるクライアントソフトウェアを識別するための登録エンドポイントが使用するクライアントの開発者またはソフトウェア発行者によって割り当てられた一意の識別子文字列（例えば、汎用一意識別子（UUID））をsoftware_id。認証サーバによって発行され、インスタンス間で変化すべきである「のclient_id」とは異なり、「software_id」クライアントソフトウェアのすべてのインスタンスに対して同じである必要があります。 「software_idは、」複数の更新やソフトウェアの同じ部分のバージョン間で同じである必要があります。このフィールドの値は、人間が読めることを意図し、通常、クライアントと認証サーバに対して不透明ではありません。"
    },
    {
      "indent": 3,
      "text": "software_version A version identifier string for the client software identified by \"software_id\". The value of the \"software_version\" SHOULD change on any update to the client software identified by the same \"software_id\". The value of this field is intended to be compared using string equality matching and no other comparison semantics are defined by this specification. The value of this field is outside the scope of this specification, but it is not intended to be human readable and is usually opaque to the client and authorization server. The definition of what constitutes an update to client software that would trigger a change to this value is specific to the software itself and is outside the scope of this specification.",
      "ja": "「software_id」で識別されるクライアントソフトウェアのバージョン識別子の文字列をSOFTWARE_VERSION。 「SOFTWARE_VERSION」の値が同じ「software_id」で識別されるクライアントソフトウェアへの更新時に変更する必要があります。このフィールドの値は、文字列等価マッチングを用いて比較されることが意図されており、他の比較セマンティクスは、この仕様で定義されていません。このフィールドの値は、この仕様の範囲外であるが、それは人間が読めることを意図するものではなく、通常、クライアントと認証サーバに不透明です。この値への変更をトリガするクライアント・ソフトウェアへの更新を構成するものの定義は、ソフトウェア自体に固有のものであり、本明細書の範囲外です。"
    },
    {
      "indent": 3,
      "text": "Extensions and profiles of this specification can expand this list with metadata names and descriptions registered in accordance with the IANA Considerations in Section 4 of this document. The authorization server MUST ignore any client metadata sent by the client that it does not understand (for instance, by silently removing unknown metadata from the client's registration record during processing). The authorization server MAY reject any requested client metadata values by replacing requested values with suitable defaults as described in Section 3.2.1 or by returning an error response as described in Section 3.2.2.",
      "ja": "この仕様の拡張とプロファイルは、このドキュメントのセクション4でIANAの考慮事項に基づいて登録されたメタデータの名前と説明して、このリストを展開することができます。認証サーバは、それが（例えば、黙っ処理中にクライアントの登録レコードから未知のメタデータを削除することで）理解していないことをクライアントによって送信されたすべてのクライアントメタデータを無視しなければなりません。認証サーバは、3.2.1または3.2.2項で説明したようにエラー応答を返すことによって説明されるよう、適切なデフォルト値を使用して要求された値を置き換えることにより、任意の要求したクライアントのメタデータ値を拒否することがあります。"
    },
    {
      "indent": 3,
      "text": "Client metadata values can be either communicated directly in the body of a registration request, as described in Section 3.1, or included as claims in a software statement, as described in Section 2.3; a mixture of both is also possible. If the same client metadata name is present in both locations and the software statement is trusted by the authorization server, the value of a claim in the software statement MUST take precedence.",
      "ja": "クライアントメタデータの値は、いずれかのセクション3.1で説明したように、登録要求の本体に直接通信、またはセクション2.3に記載されているように、ソフトウエア文の請求項として含めることができます。両方の混合物も可能です。同じクライアントメタデータ名が両方の場所に存在し、ソフトウェア文が認証サーバによって信頼されている場合、ソフトウェアの文の主張の値が優先されなければなりません。"
    },
    {
      "indent": 0,
      "text": "2.1. Relationship between Grant Types and Response Types",
      "section_title": true,
      "ja": "2.1. グラントの種類と応答タイプの関係"
    },
    {
      "indent": 3,
      "text": "The \"grant_types\" and \"response_types\" values described above are partially orthogonal, as they refer to arguments passed to different endpoints in the OAuth protocol. However, they are related in that the \"grant_types\" available to a client influence the \"response_types\" that the client is allowed to use, and vice versa. For instance, a \"grant_types\" value that includes \"authorization_code\" implies a \"response_types\" value that includes \"code\", as both values are defined as part of the OAuth 2.0 authorization code grant. As such, a server supporting these fields",
      "ja": "それらはOAuthプロトコルに異なるエンドポイントに渡される引数を参照する「grant_types」と上記「response_types」の値は、部分的に直交しています。しかし、彼らは、クライアントが利用可能な「grant_typesは、」クライアントが使用を許可されていることを「response_types」、およびその逆に影響を与えるという点で関連しています。例えば、「authorization_code」を含む「grant_types」値は、両方の値がOAuth 2.0の認証コードグラントの一部として定義されているように、「コード」を含む「response_types」値を意味しています。そのため、サーバーは、これらのフィールドをサポートします"
    },
    {
      "indent": 3,
      "text": "SHOULD take steps to ensure that a client cannot register itself into an inconsistent state, for example, by returning an \"invalid_client_metadata\" error response to an inconsistent registration request.",
      "ja": "クライアントは、一貫性のない登録要求に「invalid_client_metadata」エラー応答を返すことによって、例えば、一貫性のない状態に自身を登録することができないことを保証するための措置をとるべきです。"
    },
    {
      "indent": 3,
      "text": "The correlation between the two fields is listed in the table below.",
      "ja": "2つのフィールド間の相関を以下の表に記載されています。"
    },
    {
      "indent": 3,
      "text": "+-----------------------------------------------+-------------------+\n| grant_types value includes:                   | response_types    |\n|                                               | value includes:   |\n+-----------------------------------------------+-------------------+\n| authorization_code                            | code              |\n| implicit                                      | token             |\n| password                                      | (none)            |\n| client_credentials                            | (none)            |\n| refresh_token                                 | (none)            |\n| urn:ietf:params:oauth:grant-type:jwt-bearer   | (none)            |\n| urn:ietf:params:oauth:grant-type:saml2-bearer | (none)            |\n+-----------------------------------------------+-------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Extensions and profiles of this document that introduce new values to either the \"grant_types\" or \"response_types\" parameter MUST document all correspondences between these two parameter types.",
      "ja": "「grant_types」または「response_types」パラメータのいずれかに新しい値を導入し、この文書の拡張とプロファイルは、これら2つのパラメータの型との間のすべての対応を文書化しなければなりません。"
    },
    {
      "indent": 0,
      "text": "2.2. Human-Readable Client Metadata",
      "section_title": true,
      "ja": "2.2. 人間が読める形式のクライアントのメタデータ"
    },
    {
      "indent": 3,
      "text": "Human-readable client metadata values and client metadata values that reference human-readable values MAY be represented in multiple languages and scripts. For example, the values of fields such as \"client_name\", \"tos_uri\", \"policy_uri\", \"logo_uri\", and \"client_uri\" might have multiple locale-specific values in some client registrations to facilitate use in different locations.",
      "ja": "人間が読み取り可能なクライアントメタデータの値と、人間が読み取り可能な値を参照するクライアントのメタデータの値は、複数の言語やスクリプトで表現することができます。たとえば、「クライアント名」、「tos_uri」、「policy_uri」、「logo_uri」、および「client_uri」などのフィールドの値は、異なる場所での使用を容易にするために、いくつかのクライアントの登録で複数のロケール固有の値を持っているかもしれません。"
    },
    {
      "indent": 3,
      "text": "To specify the languages and scripts, BCP 47 [RFC5646] language tags are added to client metadata member names, delimited by a \"#\" character. Since JSON [RFC7159] member names are case sensitive, it is RECOMMENDED that language tag values used in Claim Names be spelled using the character case with which they are registered in the \"IANA Language Subtag\" registry [IANA.Language]. In particular, normally language names are spelled with lowercase characters, region names are spelled with uppercase characters, and languages are spelled with mixed-case characters. However, since BCP 47 language tag values are case-insensitive, implementations SHOULD interpret the language tag values supplied in a case insensitive manner. Per the recommendations in BCP 47, language tag values used in metadata member names should only be as specific as necessary. For instance, using \"fr\" might be sufficient in many contexts, rather than \"fr-CA\" or \"fr-FR\".",
      "ja": "言語やスクリプトを指定するには、BCP 47 [RFC5646]言語タグは「＃」文字で区切られたクライアントのメタデータメンバー名に追加されます。 JSON [RFC7159]のメンバー名は、大文字と小文字が区別されているので、請求項名に使用される言語タグ値は[IANA.Language]それらは「IANA言語サブタグ」レジストリに登録される文字のケースを使用して綴られることが推奨されます。具体的には、通常、言語名は小文字で綴られている、領域名は大文字で綴られており、言語は混在ケース文字で綴られています。しかし、BCP 47言語タグ値は大文字と小文字を区別しないので、実装は大文字と小文字を区別しないようにして供給される言語タグ値を解釈すべきです。 BCP 47の推奨事項ごとに、メタデータ・メンバー名で使用される言語タグ値は、必要な限り特異的であるべきです。例えば、「FR」を使用すると、むしろ「FR-CA」または「FR-FR」よりも、多くの状況で十分かもしれません。"
    },
    {
      "indent": 3,
      "text": "For example, a client could represent its name in English as\n\"client_name#en\": \"My Client\" and its name in Japanese as\n\"client_name#ja-Jpan-JP\":\n\"\\u30AF\\u30E9\\u30A4\\u30A2\\u30F3\\u30C8\\u540D\" within the same\nregistration request.  The authorization server MAY display any or\nall of these names to the resource owner during the authorization\nstep, choosing which name to display based on system configuration,\nuser preferences or other factors.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "If any human-readable field is sent without a language tag, parties using it MUST NOT make any assumptions about the language, character set, or script of the string value, and the string value MUST be used as is wherever it is presented in a user interface. To facilitate interoperability, it is RECOMMENDED that clients and servers use a human-readable field without any language tags in addition to any language-specific fields, and it is RECOMMENDED that any human-readable fields sent without language tags contain values suitable for display on a wide variety of systems.",
      "ja": "すべての人間が読み取り可能なフィールドは、文字列値の言語、文字セット、またはスクリプトについての仮定をしてはならない、それを使用して、言語タグなしでパーティーを送信され、文字列値を使用しなければならない場合には、それが中に提示されている場所であるとしてユーザーインターフェース。相互運用性を容易にするためには、クライアントとサーバは、任意の言語固有のフィールドに加えて、任意の言語タグなしで、人間が読み取り可能なフィールドを使用することをお勧めします、言語タグなしで送信されたすべての人間が読める形式のフィールドが上に表示するために適切な値が含まれていることが推奨されます多種多様なシステム。"
    },
    {
      "indent": 3,
      "text": "Implementer's Note: Many JSON libraries make it possible to reference members of a JSON object as members of an object construct in the native programming environment of the library. However, while the \"#\" character is a valid character inside of a JSON object's member names, it is not a valid character for use in an object member name in many programming environments. Therefore, implementations will need to use alternative access forms for these claims. For instance, in JavaScript, if one parses the JSON as follows, \"var j = JSON.parse(json);\", then as a workaround the member \"client_name#en-us\" can be accessed using the JavaScript syntax \"j[\"client_name#en-us\"]\".",
      "ja": "実装者の注：多くのJSONライブラリは、それが可能なライブラリのネイティブプログラミング環境内のオブジェクト構造体のメンバーとしてJSONオブジェクトのメンバを参照してください。 「＃」の文字がJSONオブジェクトのメンバー名の内側で有効な文字である一方、しかし、それは多くのプログラミング環境でのオブジェクトのメンバー名で使用するための有効な文字ではありません。そのため、実装はこれらの請求のための代替アクセス・フォームを使用する必要があります。例えば、JavaScriptを、次のように一つのJSONを解析する場合に \"するvar J = JSON.parse（JSON）;\" は、回避策として部材 \"CLIENT_NAME＃EN-US\" は、[JavaScriptシンタックス」Jを使用してアクセスすることができます\"クライアント名＃EN-US\"]」。"
    },
    {
      "indent": 0,
      "text": "2.3. Software Statement",
      "section_title": true,
      "ja": "2.3. ソフトウェアに関する声明"
    },
    {
      "indent": 3,
      "text": "A software statement is a JSON Web Token (JWT) [RFC7519] that asserts metadata values about the client software as a bundle. A set of claims that can be used in a software statement are defined in Section 2. When presented to the authorization server as part of a client registration request, the software statement MUST be digitally signed or MACed using JSON Web Signature (JWS) [RFC7515] and MUST contain an \"iss\" (issuer) claim denoting the party attesting to the claims in the software statement. It is RECOMMENDED that software statements be digitally signed using the \"RS256\" signature algorithm, although particular applications MAY specify the use of different algorithms. It is RECOMMENDED that software statements contain the \"software_id\" claim to allow authorization servers to correlate different instances of software using the same software statement.",
      "ja": "ソフトウェア文は、バンドルとして、クライアントソフトウェアに関するメタデータ値をアサートJSONウェブトークン（JWT）[RFC7519]です。クライアント登録要求の一部として、認証サーバに提供する場合、ソフトウェア文で使用することができる請求項のセットが、ソフトウェア命令がデジタル署名またはJSONウェブ署名（JWS）を使用してMACedなければならないセクション2で定義されている[RFC7515 ]およびソフトウェア文の主張を証明するパーティを表す「ISS」（発行者）の主張を含まなければなりません。特定のアプリケーションは、異なるアルゴリズムの使用を指定することができるが、ソフトウエア文がデジタル「RS256」署名アルゴリズムを使用して署名することが推奨されます。ソフトウェアの文は、認可サーバは、同じソフトウェアのステートメントを使用してソフトウェアの異なるインスタンスを相関させることを可能にする「software_id」主張が含まれていることが推奨されます。"
    },
    {
      "indent": 3,
      "text": "For example, a software statement could contain the following claims:",
      "ja": "例えば、ソフトウェアのステートメントは、以下の特許請求の範囲を含めることができます："
    },
    {
      "indent": 5,
      "text": "{\n \"software_id\": \"4NRB1-0XZABZI9E6-5SM3R\",\n \"client_name\": \"Example Statement-based Client\",\n \"client_uri\": \"https://client.example.net/\"\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The following non-normative example JWT includes these claims and has been asymmetrically signed using \"RS256\" (with line breaks for display purposes only):",
      "ja": "以下の非規範的な例JWTは、これらの特許請求の範囲を含み、非対称（のみ表示目的のために改行して）「RS256」を用いて署名されています。"
    },
    {
      "indent": 5,
      "text": "eyJhbGciOiJSUzI1NiJ9. eyJzb2Z0d2FyZV9pZCI6IjROUkIxLTBYWkFCWkk5RTYtNVNNM1IiLCJjbGll bnRfbmFtZSI6IkV4YW1wbGUgU3RhdGVtZW50LWJhc2VkIENsaWVudCIsImNs aWVudF91cmkiOiJodHRwczovL2NsaWVudC5leGFtcGxlLm5ldC8ifQ. GHfL4QNIrQwL18BSRdE595T9jbzqa06R9BT8w409x9oIcKaZo_mt15riEXHa zdISUvDIZhtiyNrSHQ8K4TvqWxH6uJgcmoodZdPwmWRIEYbQDLqPNxREtYn0 5X3AR7ia4FRjQ2ojZjk5fJqJdQ-JcfxyhK-P8BAWBd6I2LLA77IG32xtbhxY fHX7VhuU5ProJO8uvu3Ayv4XRhLZJY4yKfmyjiiKiPNe-Ia4SMy_d_QSWxsk U5XIQl5Sa2YRPMbDRXttm2TfnZM1xx70DoYi8g6czz-CPGRi4SW_S2RKHIJf IjoI3zTJ0Y2oe0_EJAiXbL6OyF9S5tKxDXV8JIndSA",
      "ja": "eyJhbGciOiJSUzI1NiJ9。 eyJzb2Z0d2FyZV9pZCI6IjROUkIxLTBYWkFCWkk5RTYtNVNNM1IiLCJjbGll bnRfbmFtZSI6IkV4YW1wbGUgU3RhdGVtZW50LWJhc2VkIENsaWVudCIsImNs aWVudF91cmkiOiJodHRwczovL2NsaWVudC5leGFtcGxlLm5ldC8ifQ。 GHfL4QNIrQwL18BSRdE595T9jbzqa06R9BT8w409x9oIcKaZo_mt15riEXHa zdISUvDIZhtiyNrSHQ8K4TvqWxH6uJgcmoodZdPwmWRIEYbQDLqPNxREtYn0 5X3AR7ia4FRjQ2ojZjk5fJqJdQ-JcfxyhK-P8BAWBd6I2LLA77IG32xtbhxY fHX7VhuU5ProJO8uvu3Ayv4XRhLZJY4yKfmyjiiKiPNe-Ia4SMy_d_QSWxsk U5XIQl5Sa2YRPMbDRXttm2TfnZM1xx70DoYi8g6czz-CPGRi4SW_S2RKHIJf IjoI3zTJ0Y2oe0_EJAiXbL6OyF9S5tKxDXV8JIndSA"
    },
    {
      "indent": 3,
      "text": "The software statement is typically distributed with all instances of a client application. The means by which a client or developer obtains a software statement are outside the scope of this specification. Some common methods could include a client developer generating a client-specific JWT by registering with a software API publisher to obtain a software statement for a class of clients.",
      "ja": "ソフトウェア文は一般的に、クライアントアプリケーションのすべてのインスタンスと一緒に配布されます。クライアントや開発者がソフトウェアのステートメントを取得する手段は、この仕様の範囲外です。いくつかの一般的な方法は、クライアントのクラスのソフトウェア文を取得するために、ソフトウェアAPIの出版社に登録することにより、クライアント固有のJWTを生成するクライアント開発者を含めることができます。"
    },
    {
      "indent": 3,
      "text": "The criteria by which authorization servers determine whether to trust and utilize the information in a software statement are outside the scope of this specification.",
      "ja": "認証サーバが信頼するかどうかを判断し、ソフトウェアの文の情報を利用することにより、基準は、この仕様の範囲外です。"
    },
    {
      "indent": 3,
      "text": "In some cases, authorization servers MAY choose to accept a software statement value directly as a client identifier in an authorization request, without a prior dynamic client registration having been performed. The circumstances under which an authorization server would do so, and the specific software statement characteristics required in this case, are outside the scope of this specification.",
      "ja": "いくつかのケースでは、認証サーバが実行された前の動的クライアント登録せずに、直接、認可リクエストでクライアント識別子としてのソフトウェア文の値を受け入れることを選ぶかもしれません。認証サーバがそうでしょうれる状況、およびこの場合に必要な特定のソフトウェアの文特性は、この仕様の範囲外です。"
    },
    {
      "indent": 0,
      "text": "3. Client Registration Endpoint",
      "section_title": true,
      "ja": "3.クライアント登録エンドポイント"
    },
    {
      "indent": 3,
      "text": "The client registration endpoint is an OAuth 2.0 endpoint defined in this document that is designed to allow a client to be registered with the authorization server. The client registration endpoint MUST accept HTTP POST messages with request parameters encoded in the entity body using the \"application/json\" format. The client registration endpoint MUST be protected by a transport-layer security mechanism, as described in Section 5.",
      "ja": "クライアント登録エンドポイントは、クライアントが認証サーバに登録することができるように設計されたこの文書で定義されたOAuth 2.0のエンドポイントです。クライアント登録エンドポイントは、「アプリケーション/ JSON」の形式を使用してエンティティボディでエンコードされたリクエスト・パラメータを使用してHTTP POSTメッセージを受け入れなければなりません。セクション5で説明したようにクライアント登録エンドポイントは、トランスポート層セキュリティメカニズムによって保護されなければなりません。"
    },
    {
      "indent": 3,
      "text": "The client registration endpoint MAY be an OAuth 2.0 [RFC6749] protected resource and it MAY accept an initial access token in the form of an OAuth 2.0 access token to limit registration to only previously authorized parties. The method by which the initial access token is obtained by the client or developer is generally out of band and is out of scope for this specification. The method by which the initial access token is verified and validated by the client registration endpoint is out of scope for this specification.",
      "ja": "クライアント登録エンドポイントはOAuth 2.0の[RFC6749]保護されたリソースとすることができ、それだけで以前に認可者に登録を制限するために、OAuth 2.0のアクセストークンの形で最初のアクセストークンを受け入れることができます。初期アクセストークンがクライアントまたは開発者が得られることにより、この方法は、帯域外一般的であり、この仕様の範囲外です。初期アクセストークンがクライアント登録エンドポイントによって検証し、検証される方法は、この仕様の範囲外です。"
    },
    {
      "indent": 3,
      "text": "To support open registration and facilitate wider interoperability, the client registration endpoint SHOULD allow registration requests with no authorization (which is to say, with no initial access token in the request). These requests MAY be rate-limited or otherwise limited to prevent a denial-of-service attack on the client registration endpoint.",
      "ja": "オープン登録をサポートし、より幅広い相互運用性を容易にするために、クライアント登録エンドポイントは、（要求ではありません最初のアクセストークンを使用して、と言うことです）無権限を持つ登録要求を許可する必要があります。これらの要求は、レート制限またはその他のクライアント登録エンドポイント上のサービス拒否攻撃を防ぐために制限することができます。"
    },
    {
      "indent": 0,
      "text": "3.1. Client Registration Request",
      "section_title": true,
      "ja": "3.1. クライアントの登録要求"
    },
    {
      "indent": 3,
      "text": "This operation registers a client with the authorization server. The authorization server assigns this client a unique client identifier, optionally assigns a client secret, and associates the metadata provided in the request with the issued client identifier. The request includes any client metadata parameters being specified for the client during the registration. The authorization server MAY provision default values for any items omitted in the client metadata.",
      "ja": "この操作は、認証サーバとクライアントを登録します。認証サーバは、必要に応じて、このクライアントに固有のクライアント識別子を割り当て、クライアントシークレットを割り当て、発行されたクライアント識別子を持つ要求で提供されるメタデータを関連付けます。リクエストは、登録時に、クライアント用に指定されている任意のクライアントメタデータのパラメータを含んでいます。クライアントのメタデータでは省略任意の項目の認可サーバーMAY提供のデフォルト値。"
    },
    {
      "indent": 3,
      "text": "To register, the client or developer sends an HTTP POST to the client registration endpoint with a content type of \"application/json\". The HTTP Entity Payload is a JSON [RFC7159] document consisting of a JSON object and all requested client metadata values as top-level members of that JSON object.",
      "ja": "登録するには、クライアントや開発者は、「アプリケーション/ JSON」のコンテンツタイプにクライアント登録エンドポイントにHTTP POSTを送信します。 HTTPエンティティペイロードは、JSONオブジェクトの最上位のメンバーとしてJSONオブジェクトとすべての要求されたクライアントメタデータ値からなるJSON [RFC7159]ドキュメントです。"
    },
    {
      "indent": 3,
      "text": "For example, if the server supports open registration (with no initial access token), the client could send the following registration request to the client registration endpoint.",
      "ja": "サーバは（なし初期アクセストークンを使用して）オープン登録をサポートしている場合たとえば、クライアントは、クライアントの登録エンドポイントに以下の登録リクエストを送信することができます。"
    },
    {
      "indent": 3,
      "text": "The following is a non-normative example request not using an initial access token:",
      "ja": "以下は、最初のアクセストークンを使用していない非規範的な例要求であります："
    },
    {
      "indent": 5,
      "text": "POST /register HTTP/1.1 Content-Type: application/json Accept: application/json Host: server.example.com",
      "ja": "POST /登録HTTP / 1.1のContent-Type：アプリケーション/ JSON受け入れ：アプリケーション/ JSONホスト：server.example.com"
    },
    {
      "indent": 5,
      "text": "{\n \"redirect_uris\": [\n   \"https://client.example.org/callback\",\n   \"https://client.example.org/callback2\"],\n \"client_name\": \"My Example Client\",\n \"client_name#ja-Jpan-JP\":\n    \"\\u30AF\\u30E9\\u30A4\\u30A2\\u30F3\\u30C8\\u540D\",\n \"token_endpoint_auth_method\": \"client_secret_basic\",\n \"logo_uri\": \"https://client.example.org/logo.png\",\n \"jwks_uri\": \"https://client.example.org/my_public_keys.jwks\",\n \"example_extension_parameter\": \"example_value\"\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Alternatively, if the server supports authorized registration, the developer or the client will be provisioned with an initial access token. (The method by which the initial access token is obtained is out of scope for this specification.) The developer or client sends the following authorized registration request to the client registration endpoint. Note that the initial access token sent in this example as an OAuth 2.0 Bearer Token [RFC6750], but any OAuth 2.0 token type could be used by an authorization server.",
      "ja": "サーバーが正規の登録をサポートしている場合あるいは、開発者やクライアントは、最初のアクセストークンでプロビジョニングされます。 （初期アクセストークンが取得される方法は、本仕様の範囲外である。）開発者やクライアントは、クライアントの登録エンドポイントに次の許可登録要求を送信します。 OAuth 2.0のベアラトークン[RFC6750]が、任意のOAuth 2.0トークンタイプとして、この例では送信された最初のアクセストークンは、認証サーバによって使用され得ることに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "The following is a non-normative example request using an initial access token and registering a JWK Set by value (with line breaks within values for display purposes only):",
      "ja": "以下は、トークン初期アクセスを使用して値によってJWKセットを登録する非規範例要求である（表示用の値内改行でのみ）。"
    },
    {
      "indent": 5,
      "text": "POST /register HTTP/1.1 Content-Type: application/json Accept: application/json Authorization: Bearer ey23f2.adfj230.af32-developer321 Host: server.example.com",
      "ja": "POST /登録HTTP / 1.1のContent-Type：アプリケーション/ JSON受け入れ：アプリケーション/ JSON許可：ベアラey23f2.adfj230.af32-developer321ホスト：server.example.com"
    },
    {
      "indent": 3,
      "text": "  {\n   \"redirect_uris\": [\"https://client.example.org/callback\",\n      \"https://client.example.org/callback2\"],\n   \"client_name\": \"My Example Client\",\n   \"client_name#ja-Jpan-JP\":\n      \"\\u30AF\\u30E9\\u30A4\\u30A2\\u30F3\\u30C8\\u540D\",\n   \"token_endpoint_auth_method\": \"client_secret_basic\",\n   \"policy_uri\": \"https://client.example.org/policy.html\",\n   \"jwks\": {\"keys\": [{\n      \"e\": \"AQAB\",\n      \"n\": \"nj3YJwsLUFl9BmpAbkOswCNVx17Eh9wMO-_AReZwBqfaWFcfG\nHrZXsIV2VMCNVNU8Tpb4obUaSXcRcQ-VMsfQPJm9IzgtRdAY8NN8Xb7PEcYyk\nlBjvTtuPbpzIaqyiUepzUXNDFuAOOkrIol3WmflPUUgMKULBN0EUd1fpOD70p\nRM0rlp_gg_WNUKoW1V-3keYUJoXH9NztEDm_D2MQXj9eGOJJ8yPgGL8PAZMLe\n2R7jb9TxOCPDED7tY_TU4nFPlxptw59A42mldEmViXsKQt60s1SLboazxFKve\nqXC_jpLUt22OC6GUG63p-REw-ZOr3r845z50wMuzifQrMI9bQ\",\n      \"kty\": \"RSA\"\n   }]},\n   \"example_extension_parameter\": \"example_value\"\n  }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.1.1. Client Registration Request Using a Software Statement",
      "section_title": true,
      "ja": "3.1.1. ソフトウェアステートメントを使用したクライアントの登録要求"
    },
    {
      "indent": 3,
      "text": "In addition to JSON elements, client metadata values MAY also be provided in a software statement, as described in Section 2.3. The authorization server MAY ignore the software statement if it does not support this feature. If the server supports software statements, client metadata values conveyed in the software statement MUST take precedence over those conveyed using plain JSON elements.",
      "ja": "2.3節で説明したようにJSON要素に加えて、クライアントのメタデータの値はまた、ソフトウェア文で提供することができます。それは、この機能をサポートしていない場合、認可サーバーは、ソフトウェア文を無視してもよいです。サーバーは、ソフトウェア・ステートメントをサポートしている場合、ソフトウェアの声明に搬送クライアントメタデータ値は、プレーンJSON要素を使用して伝えたものよりも優先されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Software statements are included in the requesting JSON object using this OPTIONAL member:",
      "ja": "ソフトウェアの文は、このオプション部材を使用して要求してJSONオブジェクトに含まれています。"
    },
    {
      "indent": 3,
      "text": "software_statement A software statement containing client metadata values about the client software as claims. This is a string value containing the entire signed JWT.",
      "ja": "クレームなどのクライアントソフトウェアに関するクライアントのメタデータ値を含むソフトウェア・ステートメントをsoftware_statement。これは、全体の署名JWTを含む文字列値です。"
    },
    {
      "indent": 3,
      "text": "In the following example, some registration parameters are conveyed as claims in a software statement from the example in Section 2.3, while some values specific to the client instance are conveyed as regular parameters (with line breaks within values for display purposes only):",
      "ja": "クライアント・インスタンスに固有のいくつかの値は、（表示のみの目的のために値内改行で）定期的なパラメータとして搬送されるときには、次の例では、いくつかの登録パラメータは、セクション2.3中の実施例からソフトウェア文の特許請求の範囲のように搬送されます。"
    },
    {
      "indent": 5,
      "text": "POST /register HTTP/1.1 Content-Type: application/json Accept: application/json Host: server.example.com",
      "ja": "POST /登録HTTP / 1.1のContent-Type：アプリケーション/ JSON受け入れ：アプリケーション/ JSONホスト：server.example.com"
    },
    {
      "indent": 3,
      "text": "  {\n    \"redirect_uris\": [\n      \"https://client.example.org/callback\",\n      \"https://client.example.org/callback2\"\n    ],\n    \"software_statement\": \"eyJhbGciOiJSUzI1NiJ9.\neyJzb2Z0d2FyZV9pZCI6IjROUkIxLTBYWkFCWkk5RTYtNVNNM1IiLCJjbGll\nbnRfbmFtZSI6IkV4YW1wbGUgU3RhdGVtZW50LWJhc2VkIENsaWVudCIsImNs\naWVudF91cmkiOiJodHRwczovL2NsaWVudC5leGFtcGxlLm5ldC8ifQ.\nGHfL4QNIrQwL18BSRdE595T9jbzqa06R9BT8w409x9oIcKaZo_mt15riEXHa\nzdISUvDIZhtiyNrSHQ8K4TvqWxH6uJgcmoodZdPwmWRIEYbQDLqPNxREtYn0\n5X3AR7ia4FRjQ2ojZjk5fJqJdQ-JcfxyhK-P8BAWBd6I2LLA77IG32xtbhxY\nfHX7VhuU5ProJO8uvu3Ayv4XRhLZJY4yKfmyjiiKiPNe-Ia4SMy_d_QSWxsk\nU5XIQl5Sa2YRPMbDRXttm2TfnZM1xx70DoYi8g6czz-CPGRi4SW_S2RKHIJf\nIjoI3zTJ0Y2oe0_EJAiXbL6OyF9S5tKxDXV8JIndSA\",\n    \"scope\": \"read write\",\n    \"example_extension_parameter\": \"example_value\"\n  }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.2. Responses",
      "section_title": true,
      "ja": "3.2. 反応"
    },
    {
      "indent": 3,
      "text": "Upon a successful registration request, the authorization server returns a client identifier for the client. The server responds with an HTTP 201 Created status code and a body of type \"application/json\" with content as described in Section 3.2.1.",
      "ja": "成功した登録要求の際に、認証サーバは、クライアントのクライアント識別子を返します。サーバは、セクション3.2.1に記載したように、ステータスコードとコンテンツを有するタイプ「アプリケーション/ JSON」のボディを作成したHTTP 201で応答します。"
    },
    {
      "indent": 3,
      "text": "Upon an unsuccessful registration request, the authorization server responds with an error, as described in Section 3.2.2.",
      "ja": "3.2.2項で説明したように失敗した登録要求の際に、認証サーバは、エラーで応答します。"
    },
    {
      "indent": 0,
      "text": "3.2.1. Client Information Response",
      "section_title": true,
      "ja": "3.2.1. クライアント情報応答"
    },
    {
      "indent": 3,
      "text": "The response contains the client identifier as well as the client secret, if the client is a confidential client. The response MAY contain additional fields as specified by extensions to this specification.",
      "ja": "クライアントが機密クライアントである場合、応答は、クライアント識別子だけでなく、クライアントの秘密が含まれています。この仕様への拡張で指定された応答は、追加のフィールドを含めることができます。"
    },
    {
      "indent": 3,
      "text": "client_id REQUIRED. OAuth 2.0 client identifier string. It SHOULD NOT be currently valid for any other registered client, though an authorization server MAY issue the same client identifier to multiple instances of a registered client at its discretion.",
      "ja": "CLIENT_ID REQUIRED。 OAuth 2.0のクライアント識別子の文字列。認証サーバは、その裁量で登録されたクライアントの複数のインスタンスに同じクライアント識別子を発行するかもしれませんが、それは、他の登録済みのクライアントのために現在有効すべきではありません。"
    },
    {
      "indent": 3,
      "text": "client_secret OPTIONAL. OAuth 2.0 client secret string. If issued, this MUST be unique for each \"client_id\" and SHOULD be unique for multiple instances of a client using the same \"client_id\". This value is used by confidential clients to authenticate to the token endpoint, as described in OAuth 2.0 [RFC6749], Section 2.3.1.",
      "ja": "オプションclient_secret。 OAuth 2.0のクライアント秘密の文字列。発行された場合、これはそれぞれ「CLIENT_ID」のためのユニークでなければならないと同じ「CLIENT_ID」を使用して、クライアントの複数のインスタンスに対して一意である必要があります。 OAuth 2.0の[RFC6749]、セクション2.3.1に記載したように、この値は、トークンエンドポイントに認証するために機密クライアントによって使用されます。"
    },
    {
      "indent": 3,
      "text": "client_id_issued_at OPTIONAL. Time at which the client identifier was issued. The time is represented as the number of seconds from 1970-01-01T00:00:00Z as measured in UTC until the date/time of issuance.",
      "ja": "オプションclient_id_issued_at。クライアント識別子が発行された時刻。発行日/時間までUTCに測定されるよう00Z：00：時間は1970-01-01T00からの秒数で表されます。"
    },
    {
      "indent": 3,
      "text": "client_secret_expires_at REQUIRED if \"client_secret\" is issued. Time at which the client secret will expire or 0 if it will not expire. The time is represented as the number of seconds from 1970-01-01T00:00:00Z as measured in UTC until the date/time of expiration.",
      "ja": "「client_secret」が発行されている場合は必須client_secret_expires_at。それは有効期限が切れない場合は、クライアントの秘密が期限切れまたは0する時刻。有効期限の日付/時刻までUTCに測定されるよう00Z：00：時間は1970-01-01T00からの秒数で表されます。"
    },
    {
      "indent": 3,
      "text": "Additionally, the authorization server MUST return all registered metadata about this client, including any fields provisioned by the authorization server itself. The authorization server MAY reject or replace any of the client's requested metadata values submitted during the registration and substitute them with suitable values. The client or developer can check the values in the response to determine if the registration is sufficient for use (e.g., the registered \"token_endpoint_auth_method\" is supported by the client software) and determine a course of action appropriate for the client software. The response to such a situation is out of scope for this specification but could include filing a report with the application developer or authorization server provider, attempted re-registration with different metadata values, or various other methods. For instance, if the server also supports a registration management mechanism such as that defined in [RFC7592], the client or developer could attempt to update the registration with different metadata values. This process could also be aided by a service discovery protocol, such as [OpenID.Discovery], which can list a server's capabilities, allowing a client to make a more informed registration request. The use of any such management or discovery system is optional and outside the scope of this specification.",
      "ja": "また、認証サーバは、認証サーバ自体によってプロビジョニング任意のフィールドを含め、このクライアントに関するすべての登録済みのメタデータを返さなければなりません。認証サーバは、拒否または登録時に提出され、クライアントの要求されたメタデータの値のいずれかを交換し、適切な値でそれらを置換してもよいです。クライアントまたは開発者は、登録が使用するのに十分であるかどうかを決定するために応じて値を確認し（例えば、登録された「token_endpoint_auth_methodは、」クライアントソフトウェアによってサポートされている）およびクライアントソフトウェアに適切なアクションのコースを決定することができます。このような状況への応答は、この仕様の範囲外であるが、アプリケーション開発者または認証サーバプロバイダとの報告書を提出含めることができ、異なるメタデータの値、または様々な他の方法で再登録を試みました。サーバはまた、[RFC7592]で定義されるような登録管理機構をサポートしている場合、例えば、クライアントや開発者は、異なるメタデータの値の登録を更新しようとする可能性があります。このプロセスは、クライアントがより多くの情報の登録要求を行うことができるように、サーバーの機能を一覧表示することができ、このような[OpenID.Discovery]としてサービス発見プロトコル、によって支援することができます。このような管理または検出システムの使用は任意で、本明細書の範囲外です。"
    },
    {
      "indent": 3,
      "text": "The successful registration response uses an HTTP 201 Created status code with a body of type \"application/json\" consisting of a single JSON object [RFC7159] with all parameters as top-level members of the object.",
      "ja": "成功した登録応答は、オブジェクトの最上位のメンバーとして、すべてのパラメータを持つ単一のJSONオブジェクト[RFC7159]からなるタイプ「アプリケーション/ JSON」の本体でHTTP 201作成ステータスコードを使用します。"
    },
    {
      "indent": 3,
      "text": "If a software statement was used as part of the registration, its value MUST be returned unmodified in the response along with other metadata using the \"software_statement\" member name. Client metadata elements used from the software statement MUST also be returned directly as top-level client metadata values in the registration response (possibly with different values, since the values requested and the values used may differ).",
      "ja": "ソフトウェア文が登録の一部として使用された場合、その値は「software_statement」メンバー名を使用して他のメタデータと一緒に応答してそのまま返されなければなりません。 （要求された値と使用される値が異なる可能性があるので、おそらく異なる値で）ソフトウェアステートメントから使用するクライアントメタデータ要素はまた、登録応答の最上位のクライアントメタデータ値として直接返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "The following is a non-normative example response of a successful registration:",
      "ja": "以下は、登録が成功の非規範的な例応答であります："
    },
    {
      "indent": 5,
      "text": "HTTP/1.1 201 Created Content-Type: application/json Cache-Control: no-store Pragma: no-cache",
      "ja": "HTTP / 1.1 201作成されたコンテンツの種類：アプリケーション/ JSONののCache-Control：無店舗プラグマ：キャッシュなし"
    },
    {
      "indent": 5,
      "text": "{\n \"client_id\": \"s6BhdRkqt3\",\n \"client_secret\": \"cf136dc3c1fc93f31185e5885805d\",\n \"client_id_issued_at\": 2893256800,\n \"client_secret_expires_at\": 2893276800,\n \"redirect_uris\": [\n   \"https://client.example.org/callback\",\n   \"https://client.example.org/callback2\"],\n \"grant_types\": [\"authorization_code\", \"refresh_token\"],\n \"client_name\": \"My Example Client\",\n \"client_name#ja-Jpan-JP\":\n    \"\\u30AF\\u30E9\\u30A4\\u30A2\\u30F3\\u30C8\\u540D\",\n \"token_endpoint_auth_method\": \"client_secret_basic\",\n \"logo_uri\": \"https://client.example.org/logo.png\",\n \"jwks_uri\": \"https://client.example.org/my_public_keys.jwks\",\n \"example_extension_parameter\": \"example_value\"\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.2.2. Client Registration Error Response",
      "section_title": true,
      "ja": "3.2.2. クライアント登録エラー応答"
    },
    {
      "indent": 3,
      "text": "When an OAuth 2.0 error condition occurs, such as the client presenting an invalid initial access token, the authorization server returns an error response appropriate to the OAuth 2.0 token type.",
      "ja": "OAuth 2.0のエラー状態は、クライアントが無効な初期アクセストークンを提示すると、発生した場合、認証サーバは、OAuth 2.0のトークン・タイプに適切なエラー応答を返します。"
    },
    {
      "indent": 3,
      "text": "When a registration error condition occurs, the authorization server returns an HTTP 400 status code (unless otherwise specified) with content type \"application/json\" consisting of a JSON object [RFC7159] describing the error in the response body.",
      "ja": "登録エラー状態が発生した場合、認証サーバは、応答本体に誤差を記述するJSONオブジェクトからなるコンテンツ・タイプ「アプリケーション/ JSON」のHTTP 400ステータスコード（特に断らない限り）[RFC7159]を返します。"
    },
    {
      "indent": 3,
      "text": "Two members are defined for inclusion in the JSON object:",
      "ja": "二つのメンバーは、JSONオブジェクトに含めるために定義されています。"
    },
    {
      "indent": 3,
      "text": "error REQUIRED. Single ASCII error code string.",
      "ja": "エラーREQUIRED。シングルASCIIエラーコード文字列。"
    },
    {
      "indent": 3,
      "text": "error_description OPTIONAL. Human-readable ASCII text description of the error used for debugging.",
      "ja": "しましたerror_descriptionオプション。デバッグのために使用されるエラーの人間が読めるASCIIテキスト記述。"
    },
    {
      "indent": 3,
      "text": "Other members MAY also be included and, if they are not understood, they MUST be ignored.",
      "ja": "他のメンバーはまた、彼らは無視しなければなりません、彼らは理解されていない場合は、含まれてもよいです。"
    },
    {
      "indent": 3,
      "text": "This specification defines the following error codes:",
      "ja": "この仕様は、次のエラーコードを定義します。"
    },
    {
      "indent": 3,
      "text": "invalid_redirect_uri The value of one or more redirection URIs is invalid.",
      "ja": "一の以上のリダイレクションの値invalid_redirect_uri URIが無効です。"
    },
    {
      "indent": 3,
      "text": "invalid_client_metadata The value of one of the client metadata fields is invalid and the server has rejected this request. Note that an authorization server MAY choose to substitute a valid value for any requested parameter of a client's metadata.",
      "ja": "クライアントのメタデータフィールドのいずれかの値invalid_client_metadata無効であり、サーバはこの要求を拒否しました。認証サーバはクライアントのメタデータのいずれかの要求されたパラメータに有効な値を代入することを選択するかもしれないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "invalid_software_statement The software statement presented is invalid.",
      "ja": "提示ソフトウェアのステートメントが無効ですinvalid_software_statement。"
    },
    {
      "indent": 3,
      "text": "unapproved_software_statement The software statement presented is not approved for use by this authorization server.",
      "ja": "この認証サーバによって使用が承認されていません提示ソフトウェア文をunapproved_software_statement。"
    },
    {
      "indent": 3,
      "text": "The following is a non-normative example of an error response resulting from a redirection URI that has been blacklisted by the authorization server (with line breaks within values for display purposes only):",
      "ja": "以下に、（表示目的のみの値内改行で）認証サーバによってブラックリストされたリダイレクトURIから生じるエラー応答の非規範的な例です。"
    },
    {
      "indent": 5,
      "text": "HTTP/1.1 400 Bad Request Content-Type: application/json Cache-Control: no-store Pragma: no-cache",
      "ja": "HTTP / 1.1 400不正なリクエストのContent-Type：アプリケーション/ JSONののCache-Control：無店舗プラグマ：キャッシュなし"
    },
    {
      "indent": 5,
      "text": "{\n \"error\": \"invalid_redirect_uri\",\n \"error_description\": \"The redirection URI\n   http://sketchy.example.com is not allowed by this server.\"\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The following is a non-normative example of an error response resulting from an inconsistent combination of \"response_types\" and \"grant_types\" values (with line breaks within values for display purposes only):",
      "ja": "以下は、（表示目的のみの値内改行付き）「response_types」および「grant_types」値の矛盾する組み合わせに起因するエラー応答の非規範的な例です。"
    },
    {
      "indent": 5,
      "text": "HTTP/1.1 400 Bad Request Content-Type: application/json Cache-Control: no-store Pragma: no-cache",
      "ja": "HTTP / 1.1 400不正なリクエストのContent-Type：アプリケーション/ JSONののCache-Control：無店舗プラグマ：キャッシュなし"
    },
    {
      "indent": 5,
      "text": "{\n \"error\": \"invalid_client_metadata\",\n \"error_description\": \"The grant type 'authorization_code' must be\n   registered along with the response type 'code' but found only\n  'implicit' instead.\"\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4. IANA Considerations",
      "section_title": true,
      "ja": "4. IANAの考慮事項"
    },
    {
      "indent": 0,
      "text": "4.1. OAuth Dynamic Client Registration Metadata Registry",
      "section_title": true,
      "ja": "4.1.  OAuthの動的クライアントの登録メタデータ・レジストリー"
    },
    {
      "indent": 3,
      "text": "This specification establishes the \"OAuth Dynamic Client Registration Metadata\" registry.",
      "ja": "この仕様は、「OAuthの動的クライアントの登録メタデータの」レジストリを確立します。"
    },
    {
      "indent": 3,
      "text": "OAuth registration client metadata names and descriptions are registered with a Specification Required ([RFC5226]) after a two-week review period on the oauth-ext-review@ietf.org mailing list, on the advice of one or more Designated Experts. However, to allow for the allocation of names prior to publication, the Designated Experts may approve registration once they are satisfied that such a specification will be published, per [RFC7120].",
      "ja": "OAuthの登録クライアントのメタデータの名前と説明は、1つ以上の指定された専門家の助言に、oauth-ext-review@ietf.orgメーリングリストに2週間の審査期間後に仕様が必要である（[RFC5226]）に登録されています。彼らはそのような仕様は[RFC7120]あたり、公開されることを確認したらしかし、従来の出版物への名前の割り当てを可能にするために、指定専門家は、登録を承認することができます。"
    },
    {
      "indent": 3,
      "text": "Registration requests sent to the mailing list for review should use an appropriate subject (e.g., \"Request to register OAuth Dynamic Client Registration Metadata name: example\").",
      "ja": "レビューのためのメーリングリストに送信された登録要求を適切な対象（例えば、「例えば：OAuthの動的クライアントの登録メタデータ名を登録するための要求を」）を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "Within the review period, the Designated Experts will either approve or deny the registration request, communicating this decision to the review list and IANA. Denials should include an explanation and, if applicable, suggestions as to how to make the request successful.",
      "ja": "審査期間内に、指定専門家は、レビューリストとIANAにこの決定を伝える、登録要求を承認または拒否しますか。否定は説明と、該当する場合、要求を成功させる方法についての提案を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "IANA must only accept registry updates from the Designated Experts and should direct all requests for registration to the review mailing list.",
      "ja": "IANAは唯一の指定専門家からのレジストリの更新を受け入れなければなりませんし、レビューのメーリングリストへの登録のためのすべての要求を指示する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.1.1. Registration Template",
      "section_title": true,
      "ja": "4.1.1. 登録テンプレート"
    },
    {
      "indent": 3,
      "text": "Client Metadata Name: The name requested (e.g., \"example\"). This name is case sensitive. Names that match other registered names in a case-insensitive manner SHOULD NOT be accepted.",
      "ja": "クライアントのメタデータ名：要求された名前（例えば、「例」）。この名前は、大文字と小文字が区別されます。大文字と小文字を区別しないようにし、他の登録名と一致する名前は受け入れられない（SHOULD NOT）。"
    },
    {
      "indent": 3,
      "text": "Client Metadata Description: Brief description of the metadata value (e.g., \"Example description\").",
      "ja": "クライアントメタデータ説明：メタデータの値の簡単な説明（例えば、「例の説明」）。"
    },
    {
      "indent": 3,
      "text": "Change Controller: For Standards Track RFCs, list \"IESG\". For others, give the name of the responsible party. Other details (e.g., postal address, email address, home page URI) may also be included.",
      "ja": "変更コントローラ：標準化過程のRFCについては、リスト「IESG」。他の人のために、責任者の名前を与えます。その他の詳細（例えば、住所、電子メールアドレス、ホームページURI）が含まれてもよいです。"
    },
    {
      "indent": 3,
      "text": "Specification Document(s): Reference to the document or documents that specify the client metadata definition, preferably including a URI that can be used to retrieve a copy of the documents. An indication of the relevant sections may also be included but is not required.",
      "ja": "仕様書（S）：好ましくは、文書のコピーを取得するために使用することができURIを含む、クライアントのメタデータ定義を指定する文書または文書への参照。関連するセクションの指示が含まれていてもよいが、必須ではありません。"
    },
    {
      "indent": 0,
      "text": "4.1.2. Initial Registry Contents",
      "section_title": true,
      "ja": "4.1.2. 初期のレジストリ内容"
    },
    {
      "indent": 3,
      "text": "The initial contents of the \"OAuth Dynamic Client Registration Metadata\" registry are:",
      "ja": "「OAuthの動的クライアントの登録メタデータ」レジストリの初期の内容は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "o Client Metadata Name: \"redirect_uris\" o Client Metadata Description: Array of redirection URIs for use in redirect-based flows o Change Controller: IESG o Specification Document(s): RFC 7591",
      "ja": "Oクライアントメタデータ名：クライアントメタデータ記述O「redirect_uris」：変更コントローラOリダイレクト・ベースのフローで使用するためのリダイレクトURIの配列：仕様文書（S）O IESG：RFC 7591"
    },
    {
      "indent": 3,
      "text": "o Client Metadata Name: \"token_endpoint_auth_method\" o Client Metadata Description: Requested authentication method for the token endpoint o Change Controller: IESG o Specification Document(s): RFC 7591",
      "ja": "Oクライアントメタデータ名前：仕様書（s）はO IESG変更：コントローラーOトークンエンドポイントに対する要求された認証方式：RFC 7591クライアントのメタデータの説明o「はtoken_endpoint_auth_method」"
    },
    {
      "indent": 3,
      "text": "o Client Metadata Name: \"grant_types\" o Client Metadata Description: Array of OAuth 2.0 grant types that the client may use o Change Controller: IESG o Specification Document(s): RFC 7591",
      "ja": "Oクライアントメタデータ名：クライアントメタデータ記述O「grant_types」：クライアントは変更コントローラoを使用することができるのOAuthの配列2.0グラントタイプ：仕様文書（S）O IESG：RFC 7591"
    },
    {
      "indent": 3,
      "text": "o Client Metadata Name: \"response_types\" o Client Metadata Description: Array of the OAuth 2.0 response types that the client may use o Change Controller: IESG o Specification Document(s): RFC 7591",
      "ja": "クライアントメタデータ記述O「response_types」：仕様文書O IESG（S）：クライアントは変更コントローラoを使用することができるOAuth 2.0の応答タイプの配列クライアントメタデータ名前O RFC 7591"
    },
    {
      "indent": 3,
      "text": "o Client Metadata Name: \"client_name\" o Client Metadata Description: Human-readable name of the client to be presented to the user o Change Controller: IESG o Specification Document(s): RFC 7591",
      "ja": "Oクライアントメタデータ名：クライアントのメタデータの説明o「はクライアント名」：変更コントローラーOユーザに提示するためのクライアントの人間が読める名前：仕様書（s）はO IESG：RFC 7591"
    },
    {
      "indent": 3,
      "text": "o Client Metadata Name: \"client_uri\" o Client Metadata Description: URL of a web page providing information about the client o Change Controller: IESG o Specification Document(s): RFC 7591",
      "ja": "Oクライアントメタデータ名：クライアントのメタデータの説明o「はclient_uri」：変更コントローラーOクライアントに関する情報を提供するウェブページのURL：仕様書（s）はO IESG：RFC 7591"
    },
    {
      "indent": 3,
      "text": "o Client Metadata Name: \"logo_uri\" o Client Metadata Description: URL that references a logo for the client o Change Controller: IESG o Specification Document(s): RFC 7591",
      "ja": "クライアントのメタデータ名O：「logo_uri」クライアントのメタデータの説明O：仕様ドキュメントO IESG（S）：変更コントローラーOクライアントのロゴを参照するURL RFC 7591"
    },
    {
      "indent": 3,
      "text": "o Client Metadata Name: \"scope\" o Client Metadata Description: Space-separated list of OAuth 2.0 scope values o Change Controller: IESG o Specification Document(s): RFC 7591",
      "ja": "Oクライアントメタデータ名：変更コントローラO OAuth 2.0の範囲の値のスペース区切りリスト：仕様文書（S）O IESG：RFC 7591クライアントメタデータ記述O「範囲」"
    },
    {
      "indent": 3,
      "text": "o Client Metadata Name: \"contacts\" o Client Metadata Description: Array of strings representing ways to contact people responsible for this client, typically email addresses o Change Controller: IESG o Specification Document(s): RFC 7591",
      "ja": "Oクライアントメタデータ名：クライアントのメタデータの説明O「連絡先」：このクライアントの担当者に連絡する方法を表す文字列の配列、変更コントローラO、通常の電子メールアドレス：仕様書（s）はO IESG：RFC 7591"
    },
    {
      "indent": 3,
      "text": "o Client Metadata Name: \"tos_uri\" o Client Metadata Description: URL that points to a human-readable terms of service document for the client o Change Controller: IESG o Specification Document(s): RFC 7591",
      "ja": "クライアントのメタデータ名O：「tos_uri」クライアントのメタデータの説明O：仕様ドキュメントO IESG（S）：変更コントローラーOクライアントのためのサービス文書の人間が読める用語を指すURL RFC 7591"
    },
    {
      "indent": 3,
      "text": "o Client Metadata Name: \"policy_uri\" o Client Metadata Description: URL that points to a human-readable policy document for the client o Change Controller: IESG o Specification Document(s): RFC 7591",
      "ja": "クライアントのメタデータ名O：「policy_uri」クライアントのメタデータ記述○：変更コントローラーOクライアントのために人間が読めるポリシー文書を指すURL：IESG仕様ドキュメント（複数可）○：RFC 7591"
    },
    {
      "indent": 3,
      "text": "o Client Metadata Name: \"jwks_uri\" o Client Metadata Description: URL referencing the client's JSON Web Key Set [RFC7517] document representing the client's public keys o Change Controller: IESG o Specification Document(s): RFC 7591",
      "ja": "クライアントのメタデータ名O：「jwks_uri」クライアントのメタデータ記述○：変更コントローラーOクライアントの公開鍵を表すクライアントのJSONのWebキーセット[RFC7517]ドキュメントを参照するURL：IESG仕様ドキュメント（複数可）○：RFC 7591"
    },
    {
      "indent": 3,
      "text": "o Client Metadata Name: \"jwks\" o Client Metadata Description: Client's JSON Web Key Set [RFC7517] document representing the client's public keys o Change Controller: IESG o Specification Document(s): RFC 7591",
      "ja": "Oクライアントメタデータ名：O「jwks」クライアントメタデータの説明：クライアントのJSONのWebキーセット[RFC7517]の変更コントローラーOクライアントの公開鍵を表す文書：IESG仕様ドキュメント（複数可）○：RFC 7591"
    },
    {
      "indent": 3,
      "text": "o Client Metadata Name: \"software_id\" o Client Metadata Description: Identifier for the software that comprises a client o Change Controller: IESG o Specification Document(s): RFC 7591",
      "ja": "Oクライアントメタデータ名：仕様ドキュメントO IESG（S）：変更コントローラーOクライアントを構成するソフトウェアのための識別子：クライアントメタデータの説明o「はsoftware_id」RFC 7591"
    },
    {
      "indent": 3,
      "text": "o Client Metadata Name: \"software_version\" o Client Metadata Description: Version identifier for the software that comprises a client o Change Controller: IESG o Specification Document(s): RFC 7591",
      "ja": "Oクライアントメタデータ名：クライアントのメタデータの説明o「はSOFTWARE_VERSION」：変更コントローラーOクライアントを構成するソフトウェアのバージョン識別子：IESG仕様ドキュメント（複数可）○：RFC 7591"
    },
    {
      "indent": 3,
      "text": "o Client Metadata Name: \"client_id\" o Client Metadata Description: Client identifier o Change Controller: IESG o Specification Document(s): RFC 7591",
      "ja": "Oクライアントメタデータ名：クライアントのメタデータの説明O \"のclient_id\"：変更コントローラーOクライアント識別子：仕様ドキュメントO IESG（S）：RFC 7591"
    },
    {
      "indent": 3,
      "text": "o Client Metadata Name: \"client_secret\" o Client Metadata Description: Client secret o Change Controller: IESG o Specification Document(s): RFC 7591",
      "ja": "Oクライアントメタデータ名：クライアントのメタデータの説明o \"はclient_secretは\"：変更コントローラーOクライアントの秘密：仕様書（s）はO IESG：RFC 7591"
    },
    {
      "indent": 3,
      "text": "o Client Metadata Name: \"client_id_issued_at\" o Client Metadata Description: Time at which the client identifier was issued o Change Controller: IESG o Specification Document(s): RFC 7591",
      "ja": "Oクライアントメタデータ名：クライアントのメタデータの説明o「はclient_id_issued_at」：クライアント識別子が変更コントローラーoを発行された時刻：仕様書（s）はO IESG：RFC 7591"
    },
    {
      "indent": 3,
      "text": "o Client Metadata Name: \"client_secret_expires_at\" o Client Metadata Description: Time at which the client secret will expire o Change Controller: IESG o Specification Document(s): RFC 7591",
      "ja": "Oクライアントメタデータ名：クライアントのメタデータの説明o「はclient_secret_expires_at」：クライアントシークレットが変更コントローラーoを期限切れにする時間：仕様書（s）はO IESG：RFC 7591"
    },
    {
      "indent": 0,
      "text": "4.2. OAuth Token Endpoint Authentication Methods Registry",
      "section_title": true,
      "ja": "4.2.  OAuthのトーク​​ンエンドポイントの認証方法レジストリ"
    },
    {
      "indent": 3,
      "text": "This specification establishes the \"OAuth Token Endpoint Authentication Methods\" registry.",
      "ja": "この仕様は、「OAuthのトーク​​ンエンドポイント認証方式」のレジストリを確立します。"
    },
    {
      "indent": 3,
      "text": "Additional values for use as \"token_endpoint_auth_method\" values are registered with a Specification Required ([RFC5226]) after a two-week review period on the oauth-ext-review@ietf.org mailing list, on the advice of one or more Designated Experts. However, to allow for the allocation of values prior to publication, the Designated Experts may approve registration once they are satisfied that such a specification will be published, per [RFC7120].",
      "ja": "「token_endpoint_auth_method」の値として使用するための追加の値が1の助言または複数の指定の専門家に、oauth-ext-review@ietf.orgメーリングリストに2週間の審査期間後に仕様が必要である（[RFC5226]）に登録されています。彼らはそのような仕様は[RFC7120]あたり、公開されることを確認したらしかし、従来の出版物への値の割り当てを可能にするために、指定専門家は、登録を承認することができます。"
    },
    {
      "indent": 3,
      "text": "Registration requests must be sent to the oauth-ext-review@ietf.org mailing list for review and comment, with an appropriate subject (e.g., \"Request to register token_endpoint_auth_method value: example\").",
      "ja": "登録要求は、適切な対象（例えば、「例：token_endpoint_auth_method値を登録するための要求」）と、レビューとコメントをoauth-ext-review@ietf.orgメーリングリストに送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "Within the review period, the Designated Experts will either approve or deny the registration request, communicating this decision to the review list and IANA. Denials should include an explanation and, if applicable, suggestions as to how to make the request successful.",
      "ja": "審査期間内に、指定専門家は、レビューリストとIANAにこの決定を伝える、登録要求を承認または拒否しますか。否定は説明と、該当する場合、要求を成功させる方法についての提案を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "IANA must only accept registry updates from the Designated Experts and should direct all requests for registration to the review mailing list.",
      "ja": "IANAは唯一の指定専門家からのレジストリの更新を受け入れなければなりませんし、レビューのメーリングリストへの登録のためのすべての要求を指示する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.2.1. Registration Template",
      "section_title": true,
      "ja": "4.2.1. 登録テンプレート"
    },
    {
      "indent": 3,
      "text": "Token Endpoint Authentication Method Name: The name requested (e.g., \"example\"). This name is case sensitive. Names that match other registered names in a case-insensitive manner SHOULD NOT be accepted.",
      "ja": "トークンエンドポイント認証メソッド名：要求された名前（例えば、「例えば」）。この名前は、大文字と小文字が区別されます。大文字と小文字を区別しないようにし、他の登録名と一致する名前は受け入れられない（SHOULD NOT）。"
    },
    {
      "indent": 3,
      "text": "Change Controller: For Standards Track RFCs, list \"IESG\". For others, give the name of the responsible party. Other details (e.g., postal address, email address, home page URI) may also be included.",
      "ja": "変更コントローラ：標準化過程のRFCについては、リスト「IESG」。他の人のために、責任者の名前を与えます。その他の詳細（例えば、住所、電子メールアドレス、ホームページURI）が含まれてもよいです。"
    },
    {
      "indent": 3,
      "text": "Specification Document(s): Reference to the document or documents that specify the token endpoint authentication method, preferably including a URI that can be used to retrieve a copy of the document or documents. An indication of the relevant sections may also be included but is not required.",
      "ja": "仕様書（S）：好ましくは、文書や文書のコピーを取得するために使用することができURIを含め、トークンエンドポイントの認証方法を指定するドキュメントまたはドキュメントへの参照。関連するセクションの指示が含まれていてもよいが、必須ではありません。"
    },
    {
      "indent": 0,
      "text": "4.2.2. Initial Registry Contents",
      "section_title": true,
      "ja": "4.2.2. 初期のレジストリ内容"
    },
    {
      "indent": 3,
      "text": "The initial contents of the \"OAuth Token Endpoint Authentication Methods\" registry are:",
      "ja": "「OAuthのトーク​​ンエンドポイント認証方式」レジストリの初期の内容は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "o Token Endpoint Authentication Method Name: \"none\" o Change Controller: IESG o Specification Document(s): RFC 7591",
      "ja": "Oトークンエンドポイント認証メソッド名：変更コントローラーO \"なし\"：仕様ドキュメント（S）O IESG：RFC 7591"
    },
    {
      "indent": 3,
      "text": "o Token Endpoint Authentication Method Name: \"client_secret_post\" o Change Controller: IESG o Specification Document(s): RFC 7591",
      "ja": "トークンエンドポイント認証メソッド名O： \"client_secret_post\" 変更コントローラーO：仕様ドキュメントO IESG（S）：RFC 7591"
    },
    {
      "indent": 3,
      "text": "o Token Endpoint Authentication Method Name: \"client_secret_basic\" o Change Controller: IESG o Specification Document(s): RFC 7591",
      "ja": "トークンエンドポイント認証メソッド名O： \"client_secret_basic\" 変更コントローラーO：仕様書（s）はO IESG：RFC 7591"
    },
    {
      "indent": 0,
      "text": "5. Security Considerations",
      "section_title": true,
      "ja": "5.セキュリティについての考慮事項"
    },
    {
      "indent": 3,
      "text": "Since requests to the client registration endpoint result in the transmission of clear-text credentials (in the HTTP request and response), the authorization server MUST require the use of a transport-layer security mechanism when sending requests to the registration endpoint. The server MUST support TLS 1.2 [RFC5246] and MAY support additional transport-layer security mechanisms meeting its security requirements. When using TLS, the client MUST perform a TLS/SSL server certificate check, per RFC 6125 [RFC6125]. Implementation security considerations can be found in Recommendations for Secure Use of TLS and DTLS [BCP195].",
      "ja": "登録エンドポイントへのリクエストを送信する場合（HTTPリクエストとレスポンスで）クリアテキストの資格情報の伝送におけるクライアント登録エンドポイントの結果に要求するので、認証サーバは、トランスポート・レイヤ・セキュリティ・メカニズムの使用を必要としなければなりません。サーバはTLS 1.2 [RFC5246]をサポートしなければならないし、そのセキュリティ要件を満たす追加のトランスポート・レイヤ・セキュリティ・メカニズムをサポートするかもしれません。 TLSを使用する場合、クライアントは、RFC 6125 [RFC6125]ごとに、TLS / SSLサーバ証明書のチェックを実行しなければなりません。実装のセキュリティの考慮事項は、TLSとDTLS [BCP195]のセキュアな利用のための推奨事項に記載されています。"
    },
    {
      "indent": 3,
      "text": "For clients that use redirect-based grant types such as \"authorization_code\" and \"implicit\", authorization servers MUST require clients to register their redirection URI values. This can help mitigate attacks where rogue actors inject and impersonate a validly registered client and intercept its authorization code or tokens through an invalid redirection URI or open redirector. Additionally, in order to prevent hijacking of the return values of the redirection, registered redirection URI values MUST be one of:",
      "ja": "こうした「authorization_code」と「暗黙の」などのリダイレクトベースの助成金型を使用するクライアントの場合、認証サーバは、そのリダイレクトURI値を登録するには、クライアントが要求する必要があります。これは、不正な俳優が注入攻撃を軽減し、有効に登録されたクライアントを偽装して不正なリダイレクトURIまたはオープンリダイレクタを通じて認証コードまたはトークンを傍受することができます。また、リダイレクトの戻り値のハイジャックを防ぐために、登録されたリダイレクトURI値は、のいずれかである必要があります"
    },
    {
      "indent": 3,
      "text": "o A remote web site protected by TLS (e.g., https://client.example.com/oauth_redirect) o A web site hosted on the local machine using an HTTP URI (e.g., http://localhost:8080/oauth_redirect) o A non-HTTP application-specific URL that is available only to the client application (e.g., exampleapp://oauth_redirect)",
      "ja": "O HTTP URIを使用して、ローカルマシン上でホストされているウェブサイトoをTLS（例えば、https://client.example.com/oauth_redirect）によって保護されたリモートWebサイト（たとえば、にhttp：// localhost：8080 / oauth_redirect）O唯一のクライアントアプリケーションに利用可能である非HTTPアプリケーション固有のURL（例えば、ExampleAppに：// oauth_redirect）"
    },
    {
      "indent": 3,
      "text": "Public clients MAY register with an authorization server using this protocol, if the authorization server's policy allows them. Public clients use a \"none\" value for the \"token_endpoint_auth_method\" metadata field and are generally used with the \"implicit\" grant type. Often these clients will be short-lived in-browser applications requesting access to a user's resources and access is tied to a user's active session at the authorization server. Since such clients often do not have long-term storage, it is possible that such clients would need to re-register every time the browser application is loaded. To avoid the resulting proliferation of dead client identifiers, an authorization server MAY decide to expire registrations for existing clients meeting certain criteria after a period of time has elapsed. Alternatively, such clients could be registered on the server where the in-browser application's code is served from, and the client's configuration could be pushed to the browser alongside the code.",
      "ja": "認証サーバのポリシーがそれらを許可する場合の公共のクライアントは、このプロトコルを使用して認証サーバに登録することができます。公共のクライアントが「token_endpoint_auth_method」メタデータフィールドに「なし」の値を使用し、一般的に「暗黙の」許可タイプで使用されています。多くの場合、これらのクライアントは、ユーザーのリソースとアクセスへのアクセスを要求するアプリケーションは、認証サーバーでユーザーのアクティブなセッションに結び付けられている中で、ブラウザ短命になります。このようなクライアントは、多くの場合、長期保存を持っていないので、そのようなクライアントはブラウザアプリケーションがロードされるたびに再登録する必要があることも可能です。死んだクライアント識別子の結果の増殖を避けるために、認証サーバは、一定の期間が経過した後に一定の基準を満たす既存のクライアントのための登録を期限切れにすることもできます。あるいは、このようなクライアントはブラウザ内のアプリケーションのコードをから提供されたサーバに登録することができ、クライアントの設定は、コードと一緒に、ブラウザにプッシュすることができます。"
    },
    {
      "indent": 3,
      "text": "Since different OAuth 2.0 grant types have different security and usage properties, an authorization server MAY require separate registrations for a piece of software to support multiple grant types. For instance, an authorization server might require that all clients using the \"authorization_code\" grant type make use of a client secret for the \"token_endpoint_auth_method\" but any clients using the \"implicit\" grant type not use any authentication at the token endpoint. In such a situation, a server MAY disallow clients from registering for both the \"authorization_code\" and \"implicit\" grant types simultaneously. Similarly, the \"authorization_code\" grant type is used to represent access on behalf of an end-user, but the \"client_credentials\" grant type represents access on behalf of the client itself. For security reasons, an authorization server could require that different scopes be used for these different use cases, and, as a consequence, it MAY disallow these two grant types from being registered together by the same client. In all of these cases, the authorization server would respond with an \"invalid_client_metadata\" error response.",
      "ja": "別のOAuth 2.0の助成金の種類が異なるセキュリティと使用特性を有しているため、認証サーバは、複数の助成金の種類をサポートするために、ソフトウェアの一部のための個別の登録が必要な場合があります。例えば、認証サーバは、「authorization_code」助成金型を使用して、すべてのクライアントが「token_endpoint_auth_method」用クライアントシークレットを利用することを必要とするかもしれませんが、「暗黙の」助成金型を使用して、任意のクライアントは、トークンエンドポイントで任意の認証を使用しません。このような状況では、サーバーは、同時に「authorization_code」と「暗黙の」助成金型の両方の登録からクライアントを許可しない場合があります。同様に、「authorization_code」グラントタイプは、エンドユーザに代わってアクセスを表すために使用されるが、「client_credentials」グラントタイプは、クライアント自身に代わってアクセスを表しています。セキュリティ上の理由から、認証サーバは、さまざまなスコープは、これらの異なるユースケースのために使用すること、および、結果として、それが同じクライアントによって一緒に登録されてからこれらの二つの助成金の種類を許可しないかもしれないことを必要とする可能性があります。これらすべての場合には、認証サーバは、「invalid_client_metadata」エラー応答で応答することになります。"
    },
    {
      "indent": 3,
      "text": "Unless used as a claim in a software statement, the authorization server MUST treat all client metadata as self-asserted. For instance, a rogue client might use the name and logo of a legitimate client that it is trying to impersonate. Additionally, a rogue client might try to use the software identifier or software version of a legitimate client to attempt to associate itself on the authorization server with instances of the legitimate client. To counteract this, an authorization server MUST take appropriate steps to mitigate this risk by looking at the entire registration request and client configuration. For instance, an authorization server could issue a warning if the domain/site of the logo doesn't match the domain/site of redirection URIs. An authorization server could also refuse registration requests from a known software identifier that is requesting different redirection URIs or a different client URI. An authorization server can also present warning messages to end-users about dynamically registered clients in all cases, especially if such clients have been recently registered or have not been trusted by any users at the authorization server before.",
      "ja": "ソフトウェア文の主張として使用していない限り、認証サーバーは、自己表明など、すべてのクライアントメタデータを扱わなければなりません。たとえば、不正なクライアントはそれを偽装しようとしている正当なクライアントの名前とロゴを使用する場合があります。また、不正なクライアントは、正当なクライアントのインスタンスと認証サーバ上で自分自身を関連付けしようとする正当なクライアントのソフトウェア識別子、またはソフトウェアのバージョンを使用しようとすることがあります。これに対抗するために、認証サーバは、全体の登録要求とクライアントの設定を見ることで、このリスクを軽減するために適切な措置を取らなければなりません。ロゴのドメイン/サイトがリダイレクトURIのドメイン/サイトと一致しない場合例えば、認証サーバは警告を発行することができます。認証サーバは、異なるリダイレクションのURIまたは異なるクライアントURIを要求している既知のソフトウェア識別子からの登録要求を拒否することができます。認証サーバも、本警告メッセージは、このようなクライアントは、最近登録されているか、前に認証サーバーですべてのユーザーから信頼されていない場合は特に、すべてのケースでは、動的に登録されたクライアントに関するエンドユーザーにすることができます。"
    },
    {
      "indent": 3,
      "text": "In a situation where the authorization server is supporting open client registration, it must be extremely careful with any URL provided by the client that will be displayed to the user (e.g., \"logo_uri\", \"tos_uri\", \"client_uri\", and \"policy_uri\"). For instance, a rogue client could specify a registration request with a reference to a drive-by download in the \"policy_uri\", enticing the user to click on it during the authorization. The authorization server SHOULD check to see if the \"logo_uri\", \"tos_uri\", \"client_uri\", and \"policy_uri\" have the same host and scheme as the those defined in the array of \"redirect_uris\" and that all of these URIs resolve to valid web pages. Since these URI values that are intended to be displayed to the user at the authorization page, the authorization server SHOULD protect the user from malicious content hosted at the URLs where possible. For instance, before presenting the URLs to the user at the authorization page, the authorization server could download the content hosted at the URLs, check the content against a malware scanner and blacklist filter, determine whether or not there is mixed secure and non-secure content at the URL, and other possible server-side mitigations. Note that the content in these URLs can change at any time and the authorization server cannot provide complete confidence in the safety of the URLs, but these practices could help. To further mitigate this kind of threat, the authorization server can also warn the user that the URL links have been provided by a third party, should be treated with caution, and are not hosted by the authorization server itself. For instance, instead of providing the links directly in an HTML anchor, the authorization server can direct the user to an interstitial warning page before allowing the user to continue to the target URL.",
      "ja": "認証サーバは、Open Clientの登録を支援している状況では、ユーザー（例えば、「logo_uri」、「tos_uri」、「client_uri」、および「policy_uriに表示されるクライアントによって提供される任意のURLに非常に注意しなければなりません「）。たとえば、不正なクライアントは、認証時に、それをクリックするようにユーザを誘導する、「policy_uri」でドライブバイダウンロードを参照して、登録要求を指定することができます。認証サーバは、「logo_uri」、「tos_uri」、「client_uri」、および「policy_uriは」「redirect_uris」の配列にし、これらのURIのすべてがに解決することを定義したものと同じホストおよびスキームを持っているかどうかを確認するためにチェックする必要があります有効なWebページ。認証ページでユーザーに表示されることが意図されているこれらのURI値ので、認証サーバは、可能な限りのURLでホストされている悪意のあるコンテンツからユーザーを保護する必要があります。例えば、認証ページでユーザーにURLを提示する前に、認証サーバは、マルウェアスキャナとブラックリストフィルタに対する内容を確認し、のURLでホストされているコンテンツをダウンロードすることができ、そこに混合されているかどうかを判断セキュアで非セキュアURLのコンテンツ、および他の可能なサーバー側の緩和策。これらのURLの内容はいつでも変更することができますし、認証サーバは、URLの安全で安心を提供することはできませんが、これらの慣行が助けることができることに注意してください。さらに脅威のこの種を軽減するために、認証サーバは、URLリンクが第三者によって提供されているユーザーに警告することができる、慎重に扱われるべきである、と認証サーバ自体によってホストされていません。たとえば、代わりにHTMLアンカーに直接リンクを提供する、認証サーバは、ユーザがターゲットURLに継続を許可する前に、間質警告ページにユーザーを誘導することができます。"
    },
    {
      "indent": 3,
      "text": "Clients MAY use both the direct JSON object and the JWT-encoded software statement to present client metadata to the authorization server as part of the registration request. A software statement is cryptographically protected and represents claims made by the issuer of the statement, while the JSON object represents the self-asserted claims made by the client or developer directly. If the software statement is valid and signed by an acceptable authority (such as the software API publisher), the values of client metadata within the software statement MUST take precedence over those metadata values presented in the plain JSON object, which could have been intercepted and modified.",
      "ja": "クライアントは、登録要求の一部として、認証サーバへのクライアントのメタデータを提示するために、直接JSONオブジェクトとJWTでエンコードされたソフトウェアのステートメントの両方を使用するかもしれません。ソフトウェア文は暗号で保護し、JSONオブジェクトがクライアントまたは直接開発者によって作られた自己主張クレームを表しながら、文の発行者によって行われた主張を表しています。ソフトウェアの文が有効で、（そのようなソフトウェアAPIの出版社など）許容できる機関によって署名されている場合、ソフトウェアのステートメント内のクライアントメタデータの値が傍受されている可能性がある、プレーンなJSONオブジェクトに提示されたものメタデータの値よりも優先されなければならないし、修正しました。"
    },
    {
      "indent": 3,
      "text": "Like all metadata values, the software statement is an item that is self-asserted by the client, even though its contents have been digitally signed or MACed by the issuer of the software statement. As such, presentation of the software statement is not sufficient in most cases to fully identify a piece of client software. An initial access token, in contrast, does not necessarily contain information about a particular piece of client software but instead represents authorization to use the registration endpoint. An authorization server MUST consider the full registration request, including the software statement, initial access token, and JSON client metadata values, when deciding whether to honor a given registration request.",
      "ja": "すべてのメタデータ値と同様に、ソフトウェアのステートメントは、自己表明、その内容がデジタル署名されていても、クライアントまたはソフトウェア文の発行者によってMACedあるアイテムです。そのため、ソフトウェアの声明の発表は、完全にクライアントソフトウェアの一部を識別するために、ほとんどのケースでは十分ではありません。最初のアクセストークンは、対照的に、必ずしもクライアントソフトウェアの特定の部分についての情報が含まれているが、代わりに登録エンドポイントを使用する権限を表していません。与えられた登録要求を尊重するかどうかを決定する際の認証サーバは、ソフトウェアの声明、最初のアクセストークン、およびJSONクライアントのメタデータ値を含む、完全な登録要求を考慮する必要があります。"
    },
    {
      "indent": 3,
      "text": "If an authorization server receives a registration request for a client that is not intended to have multiple instances registered simultaneously and the authorization server can infer a duplication of registration (e.g., it uses the same \"software_id\" and \"software_version\" values as another existing client), the server SHOULD treat the new registration as being suspect and reject the registration. It is possible that the new client is trying to impersonate the existing client in order to trick users into authorizing it, or that the original registration is no longer valid. The details of managing this situation are specific to the authorization server deployment and outside the scope of this specification.",
      "ja": "認証サーバは、複数のインスタンスを同時に登録し、認証サーバは、登録の重複を推測することができます有することが意図されていないクライアントの登録要求を受信した場合（例えば、それは別の既存のクライアントと同じ「software_id」と「SOFTWARE_VERSION」の値を使用しています）、サーバはいる容疑者として新規登録を治療し、登録を拒否すべきです。新しいクライアントがそれを承認するユーザをだまし、または元の登録は、もはや有効であるために、既存のクライアントを偽装しようとしている可能性があります。このような状況の管理の詳細については、認証サーバの展開へとこの仕様の範囲外に固有のものです。"
    },
    {
      "indent": 3,
      "text": "Since a client identifier is a public value that can be used to impersonate a client at the authorization endpoint, an authorization server that decides to issue the same client identifier to multiple instances of a registered client needs to be very particular about the circumstances under which this occurs. For instance, the authorization server can limit a given client identifier to clients using the same redirect-based flow and the same redirection URIs. An authorization server SHOULD NOT issue the same client secret to multiple instances of a registered client, even if they are issued the same client identifier, or else the client secret could be leaked, allowing malicious impostors to impersonate a confidential client.",
      "ja": "クライアント識別子が認可エンドポイントにクライアントを偽装するために使用することができます公開値であるので、登録したクライアントの複数のインスタンスに同じクライアント識別子を発行することを決定した認証サーバは、下にこのような状況について非常に特定する必要があります発生しました。例えば、認証サーバは、同一のリダイレクトベースのフローと同一のリダイレクトURIを使用して、クライアントに与えられたクライアント識別子を制限することができます。認証サーバは、それらが同じクライアント識別子、または他のクライアントの秘密は、悪質な詐欺師が機密クライアントを偽装することができ、漏洩する可能性が発行されていても、登録したクライアントの複数のインスタンスに同じクライアントシークレットを発行するべきではありません。"
    },
    {
      "indent": 0,
      "text": "6. Privacy Considerations",
      "section_title": true,
      "ja": "6.個人情報保護に関する注意事項"
    },
    {
      "indent": 3,
      "text": "As the protocol described in this specification deals almost exclusively with information about software and not people, there are very few privacy concerns for its use. The notable exception is the \"contacts\" field as defined in Section 2, which contains contact information for the developers or other parties responsible for the client software. These values are intended to be displayed to end-users and will be available to the administrators of the authorization server. As such, the developer may wish to provide an email address or other contact information expressly dedicated to the purpose of supporting the client instead of using their personal or professional addresses. Alternatively, the developer may wish to provide a collective email address for the client to allow for continuing contact and support of the client software after the developer moves on and someone else takes over that responsibility.",
      "ja": "プロトコルは、ソフトウェアおよびない人々についての情報をほぼ独占的にこの仕様のお得な情報で説明したように、その使用のための非常に少数のプライバシーの問題があります。注目すべき例外は、クライアントソフトウェアを担当する開発者や他の関係者の連絡先情報が含まれている第2節で定義される「連絡先」フィールドです。これらの値は、エンドユーザーにし、認証サーバの管理者に利用できるようになります表示されることが意図されています。そのため、開発者はクライアントをサポートする代わりに、彼らの個人的または専門的なアドレスを使用する目的に明示専用の電子メールアドレスまたはその他の連絡先情報を提供することを望むかもしれません。また、開発者は、開発者が上に移動し、他の誰かがその責任を引き継ぎ後、クライアントは、クライアントソフトウェアの継続的な接触やサポートを可能にするための集合Eメールアドレスを提供することを望むかもしれません。"
    },
    {
      "indent": 3,
      "text": "In general, the metadata for a client, such as the client name and software identifier, are common across all instances of a piece of client software and therefore pose no privacy issues for end-users. Client identifiers, on the other hand, are often unique to a specific instance of a client. For clients such as web sites that are used by many users, there may not be significant privacy concerns regarding the client identifier, but for clients such as native applications that are installed on a single end-user's device, the client identifier could be uniquely tracked during OAuth 2.0 transactions and its use tied to that single end-user. However, as the client software still needs to be authorized by a resource owner through an OAuth 2.0 authorization grant, this type of tracking can occur whether or not the client identifier is unique by correlating the authenticated resource owner with the requesting client identifier.",
      "ja": "一般的には、クライアントのためのメタデータは、クライアント名およびソフトウェアの識別子として、クライアントソフトウェアの一部のすべてのインスタンス間で共通であるため、エンドユーザーにはプライバシーの問題を提起しません。クライアント識別子は、他の一方で、多くの場合、クライアントの特定のインスタンスに固有のものです。多くのユーザーによって使用されている、そのようなウェブサイトなどのクライアントでは、クライアント識別子に関する重大なプライバシーの問題がないかもしれないが、そのようなシングルエンド・ユーザーのデバイスにインストールされているネイティブアプリケーションなどのクライアントのために、クライアント識別子が一意に追跡することができそのシングルエンド・ユーザーに関連付けられてOAuth 2.0の取引とその使用中。クライアントソフトウェアがまだOAuth 2.0の承認助成を通じて資源の所有者によって承認される必要があるしかし、追跡のこのタイプは、クライアント識別子は、要求元のクライアント識別子を持つ認証されたリソースの所有者を関連付けることにより、ユニークであるか否かが発生する可能性があります。"
    },
    {
      "indent": 3,
      "text": "Note that clients are forbidden by this specification from creating their own client identifier. If the client were able to do so, an individual client instance could be tracked across multiple colluding authorization servers, leading to privacy and security issues. Additionally, client identifiers are generally issued uniquely per registration request, even for the same instance of software. In this way, an application could marginally improve privacy by registering multiple times and appearing to be completely separate applications. However, this technique does incur significant usability cost in the form of requiring multiple authorizations per resource owner and is therefore unlikely to be used in practice.",
      "ja": "クライアントは、独自のクライアント識別子を作成するから、この仕様によって禁止されていることに注意してください。クライアントがそうすることができました場合は、個々のクライアントのインスタンスは、プライバシーとセキュリティの問題につながる、複数の結託認証サーバー間で追跡することができます。さらに、クライアント識別子は、一般的にも、ソフトウェアの同じインスタンスのために、登録要求ごとに一意に発行されます。このように、アプリケーションがわずかに複数回登録すると、完全に独立したアプリケーションであることを表示されることで、プライバシーを向上させることができます。しかし、この技術は、リソースの所有者ごとに複数の権限を必要とするため、実際に使用されにくいの形で大幅なユーザビリティのコストが発生しません。"
    },
    {
      "indent": 0,
      "text": "7. References",
      "section_title": true,
      "ja": "7.参考"
    },
    {
      "indent": 0,
      "text": "7.1. Normative References",
      "section_title": true,
      "ja": "7.1. 引用規格"
    },
    {
      "indent": 3,
      "text": "[BCP195] Sheffer, Y., Holz, R., and P. Saint-Andre, \"Recommendations for Secure Use of Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)\", BCP 195, RFC 7525, May 2015, <http://www.rfc-editor.org/info/bcp195>.",
      "ja": "[BCP195]シェファー、Y.、ホルツ、R.、およびP.サンアンドレ、BCP 195、RFC 7525、2015年5月、 \"トランスポート層セキュリティ（TLS）およびデータグラムトランスポート層セキュリティ（DTLS）のセキュアな利用のための提言\" 、<http://www.rfc-editor.org/info/bcp195>。"
    },
    {
      "indent": 3,
      "text": "[IANA.Language] IANA, \"Language Subtag Registry\", <http://www.iana.org/assignments/ language-subtag-registry>.",
      "ja": "[IANA.Language] IANA、 \"言語サブタグレジストリ\"、<http://www.iana.org/assignments/言語サブタグ-レジストリ>。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<http://www.rfc-editor.org/info/ RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC5226] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 5226, DOI 10.17487/RFC5226, May 2008, <http://www.rfc-editor.org/info/rfc5226>.",
      "ja": "[RFC5226] Narten氏、T.とH. Alvestrand、 \"RFCsにIANA問題部に書くためのガイドライン\"、BCP 26、RFC 5226、DOI 10.17487 / RFC5226、2008年5月、<http://www.rfc-editor.org /情報/ RFC5226>。"
    },
    {
      "indent": 3,
      "text": "[RFC5246] Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS) Protocol Version 1.2\", RFC 5246, DOI 10.17487/RFC5246, August 2008, <http://www.rfc-editor.org/info/rfc5246>.",
      "ja": "[RFC5246]ダークス、T.およびE.レスコラ、 \"トランスポート層セキュリティ（TLS）プロトコルバージョン1.2\"、RFC 5246、DOI 10.17487 / RFC5246、2008年8月、<http://www.rfc-editor.org/info / RFC5246>。"
    },
    {
      "indent": 3,
      "text": "[RFC5646] Phillips, A., Ed. and M. Davis, Ed., \"Tags for Identifying Languages\", BCP 47, RFC 5646, DOI 10.17487/RFC5646, September 2009, <http://www.rfc-editor.org/info/rfc5646>.",
      "ja": "[RFC5646]フィリップス、A.編。そして、M.デイヴィス、エド。、 \"言語を識別するためのタグ\"、BCP 47、RFC 5646、DOI 10.17487 / RFC5646、2009年9月、<http://www.rfc-editor.org/info/rfc5646>。"
    },
    {
      "indent": 3,
      "text": "[RFC6125] Saint-Andre, P. and J. Hodges, \"Representation and Verification of Domain-Based Application Service Identity within Internet Public Key Infrastructure Using X.509 (PKIX) Certificates in the Context of Transport Layer Security (TLS)\", RFC 6125, DOI 10.17487/RFC6125, March 2011, <http://www.rfc-editor.org/info/rfc6125>.",
      "ja": "[RFC6125]サンアンドレ、P.およびJ.ホッジス、「表現およびTransport Layer Security（TLS）の文脈でインターネット公開鍵インフラストラクチャの使用X.509内のドメインベースのアプリケーションサービスのアイデンティティの検証（PKIX）証明書」、 RFC 6125、DOI 10.17487 / RFC6125、2011年3月、<http://www.rfc-editor.org/info/rfc6125>。"
    },
    {
      "indent": 3,
      "text": "[RFC6749] Hardt, D., Ed., \"The OAuth 2.0 Authorization Framework\", RFC 6749, DOI 10.17487/RFC6749, October 2012, <http://www.rfc-editor.org/info/rfc6749>.",
      "ja": "[RFC6749]ハルト、D.編、 \"OAuth 2.0の認証フレームワーク\"、RFC 6749、DOI 10.17487 / RFC6749、2012年10月、<http://www.rfc-editor.org/info/rfc6749>。"
    },
    {
      "indent": 3,
      "text": "[RFC6750] Jones, M. and D. Hardt, \"The OAuth 2.0 Authorization Framework: Bearer Token Usage\", RFC 6750, DOI 10.17487/RFC6750, October 2012, <http://www.rfc-editor.org/info/rfc6750>.",
      "ja": "[RFC6750]ジョーンズ、M.とD.ハルト、 \"OAuth 2.0の認証フレームワーク：ベアラトークンの使用\"、RFC 6750、DOI 10.17487 / RFC6750、2012年10月、<http://www.rfc-editor.org/info/ rfc6750>。"
    },
    {
      "indent": 3,
      "text": "[RFC7120] Cotton, M., \"Early IANA Allocation of Standards Track Code Points\", BCP 100, RFC 7120, DOI 10.17487/RFC7120, January 2014, <http://www.rfc-editor.org/info/rfc7120>.",
      "ja": "[RFC7120]コットン、M.、 \"標準化過程のコードポイントの初期のIANA配分\"、BCP 100、RFC 7120、DOI 10.17487 / RFC7120、2014年1月、<http://www.rfc-editor.org/info/rfc7120> 。"
    },
    {
      "indent": 3,
      "text": "[RFC7159] Bray, T., Ed., \"The JavaScript Object Notation (JSON) Data Interchange Format\", RFC 7159, DOI 10.17487/RFC7159, March 2014, <http://www.rfc-editor.org/info/rfc7159>.",
      "ja": "[RFC7159]ブレイ、T.、エド。、 \"JavaScriptのObject Notation（JSON）形式のデータ交換フォーマット\"、RFC 7159、DOI 10.17487 / RFC7159、2014年3月、<http://www.rfc-editor.org/info/ rfc7159>。"
    },
    {
      "indent": 3,
      "text": "[RFC7515] Jones, M., Bradley, J., and N. Sakimura, \"JSON Web Signature (JWS)\", RFC 7515, DOI 10.17487/RFC7515, May 2015, <http://www.rfc-editor.org/info/rfc7515>.",
      "ja": "[RFC7515]ジョーンズ、M.、ブラッドリー、J。、およびN. Sakimura、 \"JSONウェブ署名（JWS）\"、RFC 7515、DOI 10.17487 / RFC7515、2015年5月、<http://www.rfc-editor.org /情報/ rfc7515>。"
    },
    {
      "indent": 3,
      "text": "[RFC7517] Jones, M., \"JSON Web Key (JWK)\", RFC 7517, DOI 10.17487/RFC7517, May 2015, <http://www.rfc-editor.org/info/rfc7517>.",
      "ja": "[RFC7517]ジョーンズ、M.、 \"JSONのWebキー（JWK）\"、RFC 7517、DOI 10.17487 / RFC7517、2015年5月、<http://www.rfc-editor.org/info/rfc7517>。"
    },
    {
      "indent": 3,
      "text": "[RFC7519] Jones, M., Bradley, J., and N. Sakimura, \"JSON Web Token (JWT)\", RFC 7519, DOI 10.17487/RFC7519, May 2015, <http://www.rfc-editor.org/info/rfc7519>.",
      "ja": "[RFC7519]ジョーンズ、M.、ブラッドリー、J。、およびN. Sakimura、 \"JSONウェブトークン（JWT）\"、RFC 7519、DOI 10.17487 / RFC7519、2015年5月、<http://www.rfc-editor.org /情報/ rfc7519>。"
    },
    {
      "indent": 3,
      "text": "[RFC7522] Campbell, B., Mortimore, C., and M. Jones, \"Security Assertion Markup Language (SAML) 2.0 Profile for OAuth 2.0 Client Authentication and Authorization Grants\", RFC 7522, DOI 10.17487/RFC7522, May 2015, <http://www.rfc-editor.org/info/rfc7522>.",
      "ja": "[RFC7522]キャンベル、B.、Mortimore、C.、およびM.ジョーンズ、 \"セキュリティアサーションマークアップ言語（SAML）OAuth 2.0のクライアント認証と認可グラント2.0プロファイル\"、RFC 7522、DOI 10.17487 / RFC7522、2015年5月、< http://www.rfc-editor.org/info/rfc7522>。"
    },
    {
      "indent": 3,
      "text": "[RFC7523] Jones, M., Campbell, B., and C. Mortimore, \"JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization Grants\", RFC 7523, DOI 10.17487/RFC7523, May 2015, <http://www.rfc-editor.org/info/rfc7523>.",
      "ja": "[RFC7523]ジョーンズ、M.、キャンベル、B.、およびC. Mortimore、RFC 7523 \"OAuth 2.0のクライアント認証と認可グラントのためのJSONウェブトークン（JWT）プロファイル\"、DOI 10.17487 / RFC7523、2015年5月、<HTTP： //www.rfc-editor.org/info/rfc7523>。"
    },
    {
      "indent": 0,
      "text": "7.2. Informative References",
      "section_title": true,
      "ja": "7.2. 参考文献"
    },
    {
      "indent": 3,
      "text": "[OpenID.Discovery] Sakimura, N., Bradley, J., Jones, M., and E. Jay, \"OpenID Connect Discovery 1.0\", November 2014, <http://openid.net/specs/ openid-connect-discovery-1_0.html>.",
      "ja": "【OpenID.Discovery] Sakimura、N.、ブラッドリー、J.、ジョーンズ、M.、およびE.ジェイ、 \"OpenIDの接続ディスカバリー1.0\"、2014年11月、<http://openid.net/specs/ OpenIDの-connect-発見-1_0.html>。"
    },
    {
      "indent": 3,
      "text": "[OpenID.Registration] Sakimura, N., Bradley, J., and M. Jones, \"OpenID Connect Dynamic Client Registration 1.0\", November 2014, <http://openid.net/specs/ openid-connect-registration-1_0.html>.",
      "ja": "【OpenID.Registration] Sakimura、N.、ブラッドリー、J.、およびM.ジョーンズ、 \"OpenIDの接続ダイナミッククライアント登録1.0\"、2014年11月、<http://openid.net/specs/ OpenIDのコネクト登録-1_0 .htmlを>。"
    },
    {
      "indent": 3,
      "text": "[RFC7592] Richer, J., Jones, M., Bradley, J., and M. Machulak, \"OAuth 2.0 Dynamic Client Registration Management Protocol\", RFC 7592, DOI 10.17487/RFC7592, July 2015, <http://www.rfc-editor.org/info/rfc7592>.",
      "ja": "[RFC7592]より豊かな、J.、ジョーンズ、M.、ブラッドリー、J.、およびM. Machulak、 \"OAuth 2.0の動的クライアントの登録管理プロトコル\"、RFC 7592、DOI 10.17487は/ RFC7592、2015年7月、<のhttp：// WWW .rfc-editor.org /情報/ rfc7592>。"
    },
    {
      "indent": 3,
      "text": "[UMA-Core] Hardjono, T., Maler, E., Machulak, M., and D. Catalano, \"User-Managed Access (UMA) Profile of OAuth 2.0\", Work in Progress, draft-hardjono-oauth-umacore-13, April 2015.",
      "ja": "[UMAコア] Hardjono、T.、MALER、E.、Machulak、M.、およびD. Catalanoの、 \"のOAuth 2.0のユーザー管理アクセス（UMA）プロフィール\"、進行中で働いて、ドラフトhardjono-のOAuth-umacore -13、2015年4月。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Use Cases",
      "ja": "付録A.ユースケース"
    },
    {
      "indent": 3,
      "text": "This appendix describes different ways that this specification can be utilized, including describing some of the choices that may need to be made. Some of the choices are independent and can be used in combination, whereas some of the choices are interrelated.",
      "ja": "この付録では行わする必要があるかもしれないいくつかの選択肢を記述するなど、この仕様を利用することができるさまざまな方法について説明します。選択肢の中には、独立しており、いくつかの選択肢が相互しているのに対し、組み合わせて使用​​することができます。"
    },
    {
      "indent": 0,
      "text": "A.1. Open versus Protected Dynamic Client Registration",
      "ja": "A.1。保護された動的なクライアント登録対オープン"
    },
    {
      "indent": 0,
      "text": "A.1.1. Open Dynamic Client Registration",
      "ja": "A.1.1。動的クライアントの登録を開きます。"
    },
    {
      "indent": 3,
      "text": "Authorization servers that support open registration allow registrations to be made with no initial access token. This allows all client software to register with the authorization server.",
      "ja": "オープン登録をサポートする認証サーバには登録がありません最初のアクセストークンで行うことを可能にします。これは、認証サーバに登録するすべてのクライアントソフトウェアを可能にします。"
    },
    {
      "indent": 0,
      "text": "A.1.2. Protected Dynamic Client Registration",
      "ja": "A.1.2。保護された動的なクライアント登録"
    },
    {
      "indent": 3,
      "text": "Authorization servers that support protected registration require that an initial access token be used when making registration requests. While the method by which a client or developer receives this initial access token and the method by which the authorization server validates this initial access token are out of scope for this specification, a common approach is for the developer to use a manual preregistration portal at the authorization server that issues an initial access token to the developer.",
      "ja": "保護された登録をサポートする認証サーバは、登録要求を行うときに、最初のアクセストークンを使用する必要があります。クライアントや開発者は、この最初のアクセストークンと認証サーバは、この最初のアクセストークンを検証する方法を受信する方法は、この仕様の範囲外ですが、一般的なアプローチは、で手動の事前登録ポータルを使用する開発者のためであります開発者への最初のアクセストークンを発行する認証サーバ。"
    },
    {
      "indent": 0,
      "text": "A.2. Registration without or with Software Statements",
      "ja": "A.2。なしまたはソフトウェアのステートメントで登録"
    },
    {
      "indent": 0,
      "text": "A.2.1. Registration without a Software Statement",
      "ja": "A.2.1。ソフトウェアの声明なし登録"
    },
    {
      "indent": 3,
      "text": "When a software statement is not used in the registration request, the authorization server must be willing to use client metadata values without them being digitally signed or MACed (and thereby attested to) by any authority. (Note that this choice is independent of the Open versus Protected choice, and that an initial access token is another possible form of attestation.)",
      "ja": "ソフトウェア文が登録要求で使用されていない場合、認証サーバは、任意の機関によってデジタル署名されたかMACed（およびそれによってに証明）されているそれらなしでクライアントのメタデータの値を使用して喜んでなければなりません。 （この選択は保護された選択肢に対してオープンとは無関係であることに注意してください、と最初のアクセストークンは、認証の別の可能な形式であること。）"
    },
    {
      "indent": 0,
      "text": "A.2.2. Registration with a Software Statement",
      "ja": "A.2.2。ソフトウェアの声明への登録"
    },
    {
      "indent": 3,
      "text": "A software statement can be used in a registration request to provide attestation by an authority for a set of client metadata values. This can be useful when the authorization server wants to restrict registration to client software attested to by a set of authorities or when it wants to know that multiple registration requests refer to the same piece of client software.",
      "ja": "ソフトウェア文は、クライアントメタデータ値のセットのための機関によって認証を提供するために、登録要求に使用することができます。認証サーバは、当局のセットまたはときには、複数の登録要求は、クライアントソフトウェアの同じ部分を指していることを知りたいによって証明クライアントソフトウェアへの登録を制限したい場合に便利です。"
    },
    {
      "indent": 0,
      "text": "A.3. Registration by the Client or Developer",
      "ja": "A.3。クライアントまたは開発者登録"
    },
    {
      "indent": 0,
      "text": "A.3.1. Registration by the Client",
      "ja": "A.3.1。クライアントによって登録"
    },
    {
      "indent": 3,
      "text": "In some use cases, client software will dynamically register itself with an authorization server to obtain a client identifier and other information needed to interact with the authorization server. In this case, no client identifier for the authorization server is packaged with the client software.",
      "ja": "いくつかのユースケースでは、クライアント・ソフトウェアは、動的にクライアント識別子と認証サーバとの対話に必要なその他の情報を取得するために認証サーバに自身を登録します。この場合、認証サーバのためのクライアント識別子は、クライアントソフトウェアが付属していません。"
    },
    {
      "indent": 0,
      "text": "A.3.2. Registration by the Developer",
      "ja": "A.3.2。開発者登録"
    },
    {
      "indent": 3,
      "text": "In some cases, the developer (or development software being used by the developer) will preregister the client software with the authorization server or a set of authorization servers. In this case, the client identifier value(s) for the authorization server(s) can be packaged with the client software.",
      "ja": "いくつかのケースでは、開発者（または開発者によって使用されている開発ソフトウェア）は、認証サーバまたは認可サーバのセットでクライアントソフトウェアを事前登録します。この場合、認証サーバ（複数可）のクライアント識別子の値（複数可）、クライアントソフトウェアをパッケージ化することができます。"
    },
    {
      "indent": 0,
      "text": "A.4. Client ID per Client Instance or per Client Software",
      "ja": "A.4。クライアントインスタンスごとまたはクライアントソフトウェアごとのクライアントID"
    },
    {
      "indent": 0,
      "text": "A.4.1. Client ID per Client Software Instance",
      "ja": "A.4.1。クライアントソフトウェアのインスタンスごとにクライアントID"
    },
    {
      "indent": 3,
      "text": "In some cases, each deployed instance of a piece of client software will dynamically register and obtain distinct client identifier values. This can be advantageous, for instance, if the code flow is being used, as it also enables each client instance to have its own client secret. This can be useful for native clients, which cannot maintain the secrecy of a client secret value packaged with the software, but which may be able to maintain the secrecy of a per-instance client secret.",
      "ja": "いくつかのケースでは、クライアントソフトウェアのピースの各展開インスタンスを動的に登録し、異なるクライアントの識別子の値を取得します。それはまた、独自のクライアントシークレットを持つように、各クライアントのインスタンスを可能にするので、コードの流れが、使用されている場合、これは、例えば、有利となり得ます。これは、ソフトウェアが付属していたクライアント秘密値の機密性を維持することはできませんが、インスタンスごとのクライアントシークレットの機密性を維持することができる可能性があるネイティブクライアントのために有用であることができます。"
    },
    {
      "indent": 0,
      "text": "A.4.2. Client ID Shared among All Instances of Client Software",
      "ja": "A.4.2。クライアントIDは、クライアントソフトウェアのすべてのインスタンス間で共有します"
    },
    {
      "indent": 3,
      "text": "In some cases, each deployed instance of a piece of client software will share a common client identifier value. For instance, this is often the case for in-browser clients using the implicit flow, when no client secret is involved. Particular authorization servers might choose, for instance, to maintain a mapping between software statement values and client identifier values, and return the same client identifier value for all registration requests for a particular piece of software. The circumstances under which an authorization server would do so, and the specific software statement characteristics required in this case, are beyond the scope of this specification.",
      "ja": "いくつかのケースでは、クライアントソフトウェアの一部の各展開インスタンスは、共通のクライアント識別子の値を共有します。例えば、これは多くの場合、何もクライアントシークレットが関与していないときに、ブラウザクライアント、暗黙のフローを使用するためのケースです。特定の認可サーバは、ソフトウェア文の値とクライアントの識別子の値との間のマッピングを維持するために、例えば、選択、およびソフトウェアの特定の部分のためのすべての登録要求のための同じクライアント識別子の値を返すことがあります。認証サーバがそうでしょうれる状況、およびこの場合に必要な特定のソフトウェアの文特性は、この仕様の範囲を超えています。"
    },
    {
      "indent": 0,
      "text": "A.5. Stateful or Stateless Registration",
      "ja": "A.5。ステートフルまたはステートレス登録"
    },
    {
      "indent": 0,
      "text": "A.5.1. Stateful Client Registration",
      "ja": "A.5.1。ステートフルクライアント登録"
    },
    {
      "indent": 3,
      "text": "In some cases, authorization servers will maintain state about registered clients, typically indexing this state using the client identifier value. This state would typically include the client metadata values associated with the client registration, and possibly other state specific to the authorization server's implementation. When stateful registration is used, operations to support retrieving and/or updating this state may be supported. One possible set of operations upon stateful registrations is described in [RFC7592].",
      "ja": "いくつかのケースでは、認可サーバは通常、クライアント識別子の値を使用して、この状態のインデックスを作成、登録されているクライアントについての状態を維持します。この状態は、通常、認証サーバの実装に固有のクライアントメタデータクライアント登録に関連する値、およびおそらく他の状態が含まれます。ステートフル登録を使用する場合は、取得および/またはその状態を更新をサポートするための操作をサポートすることができます。ステートフル登録時の動作の一つの可能​​なセットは、[RFC7592]に記載されています。"
    },
    {
      "indent": 0,
      "text": "A.5.2. Stateless Client Registration",
      "ja": "A.5.2。ステートレスクライアント登録"
    },
    {
      "indent": 3,
      "text": "In some cases, authorization servers will be implemented in a manner the enables them to not maintain any local state about registered clients. One means of doing this is to encode all the registration state in the returned client identifier value, and possibly encrypting the state to the authorization server to maintain the confidentiality and integrity of the state.",
      "ja": "いくつかのケースでは、認証サーバは、インクルードが登録されているクライアントについてのローカルな状態を維持しないためにそれらを可能にした方法で実装されます。これを行う1つの手段は、返されたクライアント識別子値内のすべての登録状態を符号化し、そしておそらく国家の機密性と完全性を維持するために、認証サーバの状態を暗号化することです。"
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "The authors thank the OAuth Working Group, the User-Managed Access Working Group, and the OpenID Connect Working Group participants for their input to this document. In particular, the following individuals have been instrumental in their review and contribution to various draft versions of this document: Amanda Anganes, Derek Atkins, Tim Bray, Domenico Catalano, Donald Coffin, Vladimir Dzhuvinov, George Fletcher, Thomas Hardjono, William Kim, Torsten Lodderstedt, Eve Maler, Josh Mandel, Nov Matake, Tony Nadalin, Nat Sakimura, Christian Scholz, and Hannes Tschofenig.",
      "ja": "作者はこのドキュメントへの入力のためのOAuthワーキンググループ、ユーザー管理のアクセスワーキンググループ、およびOpenIDの接続作業部会の参加者に感謝します。具体的には、以下の個人は彼らのレビューと、この文書の様々なドラフト版への貢献に尽力してきている：アマンダAnganes、デレク・アトキンス、ティム・ブレイ、ドメニコCatalanoの、ドナルド棺、ウラジミールDzhuvinov、ジョージ・フレッチャー、トーマスHardjono、ウィリアム・キム、トルステンLodderstedt、イブMALER、ジョッシュ・マンデル、11月Matake、トニーNadalin、ナットSakimura、キリスト教のショルツ、およびハンネスTschofenig。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Justin Richer (editor)",
      "ja": "ジャスティン・リシェ（編集者）"
    },
    {
      "indent": 3,
      "text": "Email: ietf@justin.richer.org",
      "ja": "メール：ietf@justin.richer.org"
    },
    {
      "indent": 3,
      "text": "Michael B. Jones Microsoft",
      "ja": "マイケルB.ジョーンズマイクロソフト"
    },
    {
      "indent": 3,
      "text": "Email: mbj@microsoft.com URI: http://self-issued.info/",
      "ja": "メール：mbj@microsoft.com URI：http://self-issued.info/"
    },
    {
      "indent": 3,
      "text": "John Bradley Ping Identity",
      "ja": "ジョン・ブラッドリーピング・アイデンティティ"
    },
    {
      "indent": 3,
      "text": "Email: ve7jtb@ve7jtb.com",
      "ja": "メール：ve7jtb@ve7jtb.com"
    },
    {
      "indent": 3,
      "text": "Maciej Machulak Newcastle University",
      "ja": "マチェイMachulakニューカッスル大学"
    },
    {
      "indent": 3,
      "text": "Email: maciej.machulak@gmail.com",
      "ja": "メール：maciej.machulak@gmail.com"
    },
    {
      "indent": 3,
      "text": "Phil Hunt Oracle Corporation",
      "ja": "フィル・ハントオラクル・コーポレーション"
    },
    {
      "indent": 3,
      "text": "Email: phil.hunt@yahoo.com",
      "ja": "メール：phil.hunt@yahoo.com"
    }
  ]
}