{
  "title": {
    "text": "RFC 7204 - Requirements for Labeled NFS",
    "ja": "RFC 7204 - 標識NFSの要件"
  },
  "number": 7204,
  "created_at": "2019-10-30 02:22:22.424070+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                         T. Haynes\nRequest for Comments: 7204                                        NetApp\nCategory: Informational                                       April 2014\nISSN: 2070-1721",
      "raw": true
    },
    {
      "indent": 22,
      "text": "Requirements for Labeled NFS",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This memo outlines high-level requirements for the integration of flexible Mandatory Access Control (MAC) functionality into the Network File System (NFS) version 4.2 (NFSv4.2). It describes the level of protections that should be provided over protocol components and the basic structure of the proposed system. The intent here is not to present the protocol changes but to describe the environment in which they reside.",
      "ja": "このメモは、ネットワークファイルシステム（NFS）バージョン4.2（NFSv4.2）にフレキシブル必須アクセス制御（MAC）機能の統合のための高レベルの要件を概説しています。これは、プロトコルコンポーネントおよび本システムの基本的な構造の上に提供されるべき保護のレベルを記述する。ここでの意図は、プロトコルの変更を提示するが、それらが存在する環境を記述することではありません。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "ja": "このドキュメントはインターネット標準化過程仕様ではありません。それは、情報提供の目的のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are a candidate for any level of Internet Standard; see Section 2 of RFC 5741.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。 IESGによって承認されていないすべての文書がインターネットStandardのどんなレベルの候補です。 RFC 5741のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7204.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7204で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2014 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2014 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................3\n2. Definitions .....................................................3\n   2.1. Requirements Language ......................................4\n3. Requirements ....................................................4\n   3.1. General ....................................................4\n   3.2. Security Services ..........................................5\n   3.3. Label Encoding, Label Format Specifiers, and Label\n        Checking Authorities .......................................5\n   3.4. Labeling ...................................................6\n        3.4.1. Client Labeling .....................................6\n        3.4.2. Server Labeling .....................................7\n   3.5. Policy Enforcement .........................................7\n        3.5.1. Client Enforcement ..................................7\n        3.5.2. Server Enforcement ..................................8\n   3.6. Namespace Access ...........................................8\n   3.7. Upgrading Existing Server ..................................9\n4. Modes of Operation ..............................................9\n   4.1. Full Mode ..................................................9\n   4.2. Limited Server Mode .......................................10\n   4.3. Guest Mode ................................................10\n5. Use Cases ......................................................11\n   5.1. Full MAC Labeling Support for Remotely Mounted\n        File Systems ..............................................11\n   5.2. MAC Labeling of Virtual Machine Images Stored on\n        the Network ...............................................11\n   5.3. Simple Security Label Storage .............................12\n   5.4. Diskless Linux ............................................12\n   5.5. Multi-Level Security ......................................13\n        5.5.1. Full Mode - MAC-Functional Client and Server .......13\n        5.5.2. MAC-Functional Client ..............................14\n        5.5.3. MAC-Functional Server ..............................15\n6. Security Considerations ........................................15\n   6.1. Trust Needed for a Community ..............................15\n   6.2. Guest Mode ................................................15\n   6.3. MAC-Functional Client Configuration .......................16\n7. References .....................................................16\n   7.1. Normative References ......................................16\n   7.2. Informative References ....................................16\nAppendix A. Acknowledgments .......................................18",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "Mandatory Access Control (MAC) systems (as defined in [RFC4949]) have been mainstreamed in modern operating systems such as Linux, FreeBSD, and Solaris. MAC systems bind security attributes to subjects (processes) and objects within a system. These attributes are used with other information in the system to make access control decisions.",
      "ja": "強制アクセス制御（MAC）システム（[RFC4949]で定義されているが）などのLinux、FreeBSDの、およびSolarisなどの近代的なオペレーティングシステムで主流化されています。 MACシステムは、システム内のセキュリティ科目（プロセス）に属性とオブジェクトをバインドします。これらの属性は、アクセス制御の決定を行うために、システム内の他の情報と一緒に使用されています。"
    },
    {
      "indent": 3,
      "text": "Access control models such as Unix permissions or Access Control Lists (ACLs) are commonly referred to as Discretionary Access Control (DAC) models. These systems base their access decisions on user identity and resource ownership. In contrast, MAC models base their access control decisions on the label on the subject (usually a process) and the object it wishes to access. These labels may contain user identity information but usually contain additional information. In DAC systems, users are free to specify the access rules for resources that they own. MAC models base their security decisions on a system-wide policy established by an administrator or organization that the users do not have the ability to override. DAC systems offer some protection against unauthorized users running malicious software. However, even an authorized user can execute malicious or flawed software with those programs running with the full permissions of the user executing it. Inversely, MAC models can confine malicious or flawed software and usually act at a finer granularity than their DAC counterparts.",
      "ja": "そのようなUNIX許可またはアクセス制御リスト（ACL）などのアクセス制御モデルは、一般的に随意アクセス制御（DAC）モデルと呼ばれます。これらのシステムは、ユーザーIDおよびリソースの所有権上のアクセスの決定をベースにします。対照的に、MACモデルは、対象（通常処理）と、それがアクセスしたいオブジェクトのラベルにそのアクセス制御決定の基礎。これらのラベルは、ユーザーID情報が含まれていますが、通常は、追加情報が含まれていてもよいです。 DACシステムでは、ユーザーが所有するリソースに対するアクセスルールを指定するのは自由です。 MACモデルは、ユーザーが上書きする能力を持っていない管理者または組織によって確立されたシステム全体のポリシーに、セキュリティ上の決定を基づか。 DACシステムは、悪意のあるソフトウェアを実行している権限のないユーザーに対して、ある程度の保護を提供します。しかし、許可されたユーザは、それを実行するユーザーの完全な権限で実行されているこれらのプログラムで、悪意のあるまたは欠陥のあるソフトウェアを実行することができます。逆に、MACモデルは、悪意のあるまたは欠陥のあるソフトウェアを閉じ込めることができ、通常、そのDACの対応よりも細かい粒度で動作します。"
    },
    {
      "indent": 3,
      "text": "Besides describing the requirements, this document records the functional requirements for the client imposed by the preexisting security models on the client. This document may help those outside the NFS community understand those issues.",
      "ja": "要件を記述したほか、このドキュメントでは、クライアント上の既存のセキュリティモデルによって課されるクライアントの機能要件を記録します。この文書では、NFSコミュニティ外のものは、それらの問題を理解するのに役立つことがあります。"
    },
    {
      "indent": 0,
      "text": "2. Definitions",
      "section_title": true,
      "ja": "2.定義"
    },
    {
      "indent": 3,
      "text": "Foreign Label: a label in a format other than the format that a MAC implementation uses for encoding.",
      "ja": "外国レーベル：MACの実装は、エンコードに使用する形式以外の形式でのラベル。"
    },
    {
      "indent": 3,
      "text": "Label Format Specifier (LFS): an identifier used by the client to establish the syntactic format of the security label and the semantic meaning of its components.",
      "ja": "ラベルフォーマット指定子（LFS）：セキュリティラベルの構文形式とそのコンポーネントのセマンティックな意味を確立するためにクライアントが使用する識別子。"
    },
    {
      "indent": 3,
      "text": "MAC-Aware: a server that can transmit and store object labels.",
      "ja": "MAC-Awareの：送信することができ、サーバとストアオブジェクトのラベル。"
    },
    {
      "indent": 3,
      "text": "MAC-Functional: a client or server that is Labeled NFS enabled. Such a system can interpret labels and apply policies based on the security system.",
      "ja": "MAC-機能：NFSを有効に標識されたクライアントまたはサーバ。このようなシステムは、ラベルを解釈し、セキュリティシステムに基づいてポリシーを適用することができます。"
    },
    {
      "indent": 3,
      "text": "Multi-Level Security (MLS): a traditional model where objects are given a sensitivity level (Unclassified, Secret, Top Secret, etc.) and a category set [RH_MLS].",
      "ja": "マルチレベルセキュリティ（MLS）：オブジェクトは感度レベル（未分類、シークレット、トップシークレット、など）と[RH_MLS]カテゴリセットを与えられている伝統的なモデル。"
    },
    {
      "indent": 3,
      "text": "Object: a passive resource within the system that we wish to protect. Objects can be entities such as files, directories, pipes, sockets, and many other system resources relevant to the protection of the system state.",
      "ja": "オブジェクト：私たちは保護したいシステム内の受動的な資源。オブジェクトは、ファイル、ディレクトリ、パイプ、ソケット、およびシステム状態の保護に関連する他の多くのシステムリソースなどのエンティティすることができます。"
    },
    {
      "indent": 3,
      "text": "Policy Identifier (PI): an optional part of the definition of a Label Format Specifier. The PI allows clients and servers to identify specific security policies.",
      "ja": "方針識別子（PI）：ラベルの書式指定子の定義のオプション部分。 PIは、クライアントとサーバは、特定のセキュリティポリシーを識別することができます。"
    },
    {
      "indent": 3,
      "text": "Subject: an active entity, usually a process, that is requesting access to an object.",
      "ja": "被験者：オブジェクトへのアクセスを要求しているアクティブなエンティティ、通常の方法。"
    },
    {
      "indent": 0,
      "text": "2.1. Requirements Language",
      "section_title": true,
      "ja": "2.1. 要件言語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はあります[RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "3. Requirements",
      "section_title": true,
      "ja": "3条件"
    },
    {
      "indent": 3,
      "text": "The following initial requirements have been gathered from users and developers, and from previous development efforts in this area such as the Distributed Trusted Operating System [DTOS] and the NSA's experimental NFSv3 enhancements [SENFSv3].",
      "ja": "以下の初期の要件は、ユーザーや開発者から、そのような分散信頼できるオペレーティングシステム[DTOS]とNSAの実験的なNFSv3の強化[SENFSv3]として、この領域における以前の開発努力から収集されています。"
    },
    {
      "indent": 0,
      "text": "3.1. General",
      "section_title": true,
      "ja": "3.1. 一般的な"
    },
    {
      "indent": 3,
      "text": "A mechanism is required to provide security attribute information to NFSv4 clients and servers. This mechanism has the following requirements:",
      "ja": "メカニズムは、NFSv4のクライアントおよびサーバへのセキュリティ属性情報を提供するために必要とされます。このメカニズムは、次の要件があります。"
    },
    {
      "indent": 3,
      "text": "(1) Clients MUST be able to convey to the server the client's privileges, i.e., the subject, for making the access request. The server may provide a mechanism to enforce MAC policy based on the requesting client's privileges.",
      "ja": "（1）クライアントがアクセス要求を行うために、すなわち、対象のサーバーにクライアントの権限を伝えることができなければなりません。サーバは、要求元クライアントの権限に基づいてMACポリシーを実施するためのメカニズムを提供することができます。"
    },
    {
      "indent": 3,
      "text": "(2) Servers MUST be able to store and retrieve the security attribute of exported files as requested by the client.",
      "ja": "（2）サーバは、クライアントから要求されたとしてエクスポートされたファイルのセキュリティ属性を格納および取得できなければなりません。"
    },
    {
      "indent": 3,
      "text": "(3) Servers MUST provide a mechanism for notifying clients of attribute changes of files on the server.",
      "ja": "（3）サーバーは、サーバー上のファイルの属性の変更をクライアントに通知するためのメカニズムを提供しなければなりません。"
    },
    {
      "indent": 3,
      "text": "(4) Clients and Servers MUST be able to negotiate Label Formats and provide a mechanism to translate between them as needed.",
      "ja": "（4）クライアントとサーバーは、ラベルフォーマットを交渉し、必要に応じてそれらの間で変換するメカニズムを提供できなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.2. Security Services",
      "section_title": true,
      "ja": "3.2. セキュリティサービス"
    },
    {
      "indent": 3,
      "text": "Labeled NFS or the underlying system on which the Labeled NFS operates MUST provide the following security services for all NFSv4.2 messaging:",
      "ja": "標識NFSまたは標識NFSが動作する上で基礎となるシステムは、すべてのNFSv4.2メッセージングのための、次のセキュリティサービスを提供する必要があります。"
    },
    {
      "indent": 3,
      "text": "o Authentication",
      "ja": "認証O"
    },
    {
      "indent": 3,
      "text": "o Integrity",
      "ja": "整合性O"
    },
    {
      "indent": 3,
      "text": "o Privacy",
      "ja": "ああプライバシー"
    },
    {
      "indent": 3,
      "text": "Mechanisms and algorithms used in the provision of security services MUST be configurable so that appropriate levels of protection may be flexibly specified per mandatory security policy.",
      "ja": "保護の適切なレベルを柔軟に必須のセキュリティポリシーごとに指定することができるように、セキュリティサービスの提供に使用されるメカニズムとアルゴリズムが構成可能でなければなりません。"
    },
    {
      "indent": 3,
      "text": "Strong mutual authentication is required between the server and the client for Full Mode operation (Section 4.1).",
      "ja": "強力な相互認証がフルモードの操作（4.1節）のために、サーバーとクライアントとの間に必要とされます。"
    },
    {
      "indent": 3,
      "text": "MAC security labels and any related security state MUST always be protected by these security services when transferred over the network, as MUST the binding of labels and state to associated objects and subjects.",
      "ja": "ネットワーク上で転送する際、関連するオブジェクトやサブジェクトにラベルと状態の結合しなければならないとして、MACのセキュリティラベルおよび関連するセキュリティ状態は常に、これらのセキュリティサービスによって保護されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Labeled NFS SHOULD support authentication on a context granularity so that different contexts running on a client can use different cryptographic keys and facilities.",
      "ja": "クライアント上で実行されている異なるコンテキストが異なる暗号鍵や施設を使用できるように標識したNFSは、文脈の粒度に認証をサポートする必要があります。"
    },
    {
      "indent": 0,
      "text": "3.3. Label Encoding, Label Format Specifiers, and Label Checking Authorities",
      "ja": "3.3. ラベルエンコーディング、ラベルフォーマット指定子、およびラベルチェック当局"
    },
    {
      "indent": 3,
      "text": "Encoding of MAC labels and attributes passed over the network MUST be specified in a complete and unambiguous manner while maintaining the flexibility of MAC implementations. To accomplish this, the labels MUST consist of a format-specific component bound with a Label Format Specifier (LFS). The LFS component provides a mechanism for identifying the structure and semantics of the opaque component. Meanwhile, the opaque component is the security label that will be interpreted by the MAC models.",
      "ja": "MAC実装の柔軟性を維持しながらネットワーク上を通過MACラベルおよび属性のエンコーディングは、完全かつ明確な方法で指定する必要があります。これを達成するために、ラベルは、ラベル形式指定子（LFS）と結合形式固有のコンポーネントで構成されなければなりません。 LFS成分は不透明成分の構造およびセマンティクスを識別するためのメカニズムを提供します。一方、不透明なコンポーネントは、MACモデルによって解釈されるセキュリティラベルです。"
    },
    {
      "indent": 3,
      "text": "MAC models base access decisions on security attribute privileges bound to subjects and objects, respectively. With a given MAC model, all systems have semantically coherent labeling -- a security label MUST always mean exactly the same thing on every system. While this may not be necessary for simple MAC models, it is recommended that most Label Formats assigned an LFS incorporate semantically coherent labeling into their Label Format.",
      "ja": "それぞれ、サブジェクトとオブジェクトにバインドされたセキュリティ属性権限のMACモデルベースのアクセス決定。与えられたMACモデルでは、すべてのシステムは、意味的に一貫したラベルを持っている - セキュリティラベルは、常にすべてのシステムでまったく同じことを意味する必要があります。これは単純なMACモデルのために必要ではないかもしれないが、LFS割り当てられ、ほとんどのラベルフォーマットは、そのラベルフォーマットに意味的に一貫したラベルを組み込むことをお勧めします。"
    },
    {
      "indent": 3,
      "text": "Labeled NFS SHOULD define an initial negotiation scheme with the primary aims of simplicity and completeness. This is to facilitate practical deployment of systems without being weighed down by complex and overgeneralized global schemes. Future extensibility SHOULD also be taken into consideration.",
      "ja": "標識NFSは、シンプルさと完成度の主な目的を持つ最初のネゴシエーションスキームを定義する必要があります。これは、複雑でovergeneralizedグローバルスキームによって圧迫されることなく、システムの実用的な展開を容易にすることです。将来の拡張性も考慮すべきです。"
    },
    {
      "indent": 3,
      "text": "Labeled NFS MUST provide a means for servers and clients to identify their LFSs for the purposes of authorization, security service selection, and security label interpretation.",
      "ja": "標識NFSは、認可、セキュリティサービスの選択、およびセキュリティラベルの解釈のために彼らのLFSsを識別するために、サーバーとクライアントのための手段を提供しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Labeled NFS MUST provide a means for servers and clients to identify their mode of operation (see Section 4).",
      "ja": "標識NFSは、サーバとクライアントがそれらの動作モードを識別するための手段を提供しなければならない（第4章を参照してください）。"
    },
    {
      "indent": 3,
      "text": "A negotiation scheme SHOULD be provided, allowing systems from different Label Formats to agree on how they will interpret or translate each other's foreign labels. Multiple concurrent agreements may be current between a server and a client.",
      "ja": "交渉方式が異なるラベルフォーマットのシステムは、彼らがお互いの外国のラベルを解釈または変換する方法に同意することができ、提供されるべきです。複数の同時契約は、サーバとクライアントの間で現在のかもしれません。"
    },
    {
      "indent": 3,
      "text": "All security labels and related security state transferred across the network MUST be tagged with a valid LFS.",
      "ja": "ネットワーク経由で転送されるすべてのセキュリティラベルと関連するセキュリティ状態が有効なLFSでタグ付けされなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the LFS supported on a system changes, the system SHOULD renegotiate agreements to reflect these changes.",
      "ja": "LFSは、システムの変更にサポートされている場合、システムは、これらの変更を反映するために契約を再交渉すべきです。"
    },
    {
      "indent": 3,
      "text": "If a system receives any security label or security state tagged with an LFS it does not recognize or cannot interpret, it MUST reject that label or state.",
      "ja": "システムはLFSでタグ付けされたすべてのセキュリティラベルやセキュリティ状態を受信した場合、それは認識していないか、解釈できない、それはそのラベルや状態を拒絶しなければなりません。"
    },
    {
      "indent": 3,
      "text": "NFSv4.2 includes features that may cause a client to cross an LFS boundary when accessing what appears to be a single file system. If LFS negotiation is supported by the client and the server, the server SHOULD negotiate a new, concurrent agreement with the client, acting on behalf of the externally located source of the files.",
      "ja": "NFSv4.2は、単一のファイルシステムと思われるものをアクセスするとき、クライアントはLFSの境界を横断する可能性があり機能が含まれています。 LFSのネゴシエーションが、クライアントとサーバーによってサポートされている場合、サーバーは、ファイルの外部にあるソースのために行動する、クライアントとの新しい、同時契約を交渉すべきです。"
    },
    {
      "indent": 0,
      "text": "3.4. Labeling",
      "section_title": true,
      "ja": "3.4. ラベリング"
    },
    {
      "indent": 3,
      "text": "Implementations MUST validate security labels supplied over the network to ensure that they are within a set of labels permitted from a specific peer and, if not, reject them. Note that a system may permit a different set of labels to be accepted from each peer.",
      "ja": "実装は、彼らが特定のピアから許可されたラベルのセット内にあることを確実にするために、ネットワークを介して供給セキュリティラベルを検証し、そうでない場合は、それらを拒絶しなければなりません。システムは、各ピアから受け付けされる標識の異なるセットを可能にすることができることに留意されたいです。"
    },
    {
      "indent": 0,
      "text": "3.4.1. Client Labeling",
      "section_title": true,
      "ja": "3.4.1. クライアントラベリング"
    },
    {
      "indent": 3,
      "text": "At the client, labeling semantics for NFS mounted file systems MUST remain consistent with those for locally mounted file systems. In particular, user-level labeling operations local to the client MUST be enacted locally via existing APIs, to ensure compatibility and consistency for applications and libraries.",
      "ja": "クライアントでは、NFSのためのラベリングセマンティクスはファイルシステムをローカルにマウントされたファイルシステムのためのものと一貫性を維持しなければならないマウント。具体的には、クライアントにローカルユーザレベルのラベル付け操作はアプリケーションやライブラリの互換性と一貫性を確保するために、既存のAPIを経由してローカルに制定されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Note that this does not imply any specific mechanism for conveying labels over the network.",
      "ja": "これは、ネットワーク上でラベルを搬送するための任意の特定のメカニズムを意味するものではないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "When an object is newly created by the client, it will calculate the label for the object based on its policy. Once that is done, it will send the request to the server, which has the ability to deny the creation of the object with that label based on the server's policy. In creating the file, the server MUST ensure that the label is bound to the object before the object becomes visible to the rest of the system. This ensures that any access control or further labeling decisions are correct for the object.",
      "ja": "オブジェクトが新たにクライアントによって作成された場合、それはその方針に基づいてオブジェクトのラベルを計算します。それが完了したら、それはサーバのポリシーに基づいて、そのラベルを持つオブジェクトの作成を拒否する能力を持っているサーバーに要求を送信します。ファイルを作成するには、サーバーは、オブジェクトがシステムの他の部分に見えるようになる前に、ラベルがオブジェクトにバインドされていることを確認しなければなりません。これは、任意のアクセス制御や、標識の決定は、オブジェクトのために正しいことを保証します。"
    },
    {
      "indent": 0,
      "text": "3.4.2. Server Labeling",
      "section_title": true,
      "ja": "3.4.2. サーバーのラベリング"
    },
    {
      "indent": 3,
      "text": "The server MUST provide the capability for clients to retrieve security labels on all exported file system objects where possible. This includes cases where only in-core and/or read-only security labels are available at the server for any of its exported file systems.",
      "ja": "サーバーは、可能な限り、すべてのエクスポートされたファイルシステムオブジェクトのセキュリティラベルを取得するために、クライアントのための能力を提供しなければなりません。これは、コアおよび/または読み取り専用のセキュリティラベルのみがエクスポートされたファイルシステムのいずれかのために、サーバで使用可能な場合を含みます。"
    },
    {
      "indent": 3,
      "text": "The server MUST honor the ability for a client to specify the label of an object on creation. If the server is MAC enabled, it may choose to reject the label specified by the client, due to restrictions in the server policy. The server SHOULD NOT attempt to find a suitable label for an object in the event of different labeling rules on its end. The server is allowed to translate the label but MUST NOT change the semantic meaning of the label.",
      "ja": "サーバーは、作成上のオブジェクトのラベルを指定するには、クライアントのための能力を尊重しなければなりません。サーバはMACが有効になっている場合、それが原因サーバーポリシーの制限のために、クライアントによって指定されたラベルを拒否することもできます。サーバーは、その端に異なる標識ルールのイベントにオブジェクトに適したラベルを見つけるために試みるべきではありません。サーバーは、ラベルを変換するために許可されますが、ラベルの意味論的な意味を変更しないでください。"
    },
    {
      "indent": 0,
      "text": "3.5. Policy Enforcement",
      "section_title": true,
      "ja": "3.5. ポリシー施行"
    },
    {
      "indent": 3,
      "text": "The MAC-Functional client determines if a process request is sent to the remote server. Upon a successful response from the server, it must use its own policies on the object's security labels to determine if the process can be given access. The client SHOULD NOT need to be cognizant of whether the server is a Limited Server or is fully MAC-Functional.",
      "ja": "処理要求をリモートサーバーに送信されている場合、MAC-機能クライアントが決定します。サーバーからの正常な応答時には、それはプロセスがアクセス権を与えることができるかどうかを判断するために、オブジェクトのセキュリティラベルに独自のポリシーを使用する必要があります。クライアントは、サーバーが限定サーバーであるか、完全にMAC-機能しているかどうかを認識する必要はありません。"
    },
    {
      "indent": 0,
      "text": "3.5.1. Client Enforcement",
      "section_title": true,
      "ja": "3.5.1. クライアントの施行"
    },
    {
      "indent": 3,
      "text": "The client MUST apply its own policy to remotely located objects, using security labels for the objects obtained from the server. It MUST be possible to configure the maximum length of time a client may cache state regarding remote labels before revalidating that state with the server.",
      "ja": "クライアントは、サーバから取得したオブジェクトのセキュリティラベルを使用して、独自のポリシー遠隔地に位置するオブジェクトを適用しなければなりません。クライアントがサーバーとその状態を再検証する前に、リモートのラベルに関する状態をキャッシュする時間の最大長を設定することは可能でなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the server's policy changes, the client MUST flush all object state back to the server. The server MUST ensure that any flushed state received is consistent with current policy before committing it to stable storage.",
      "ja": "サーバーのポリシーが変更された場合、クライアントはサーバーに戻し、すべてのオブジェクトの状態をフラッシュする必要があります。サーバは、受信したすべてのフラッシュの状態が安定したストレージにコミットする前に、現在の政策と一致していることを確認しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Any local security state associated with cached or delegated objects MUST also be flushed back to the server when any other state of the objects is required to be flushed back.",
      "ja": "キャッシュされたまたは委任オブジェクトに関連付けられた任意のローカルセキュリティ状態もバックオブジェクトの他の状態をバックフラッシュする必要があるサーバーにフラッシュする必要があります。"
    },
    {
      "indent": 3,
      "text": "The implication here is that if the client holds a delegation on an object, then it enforces policy to local changes based on the object label it got from the server. When it tries to commit those changes to the server, it SHOULD be prepared for the server to reject those changes based on the policies of the server.",
      "ja": "ここでの意味は、クライアントがオブジェクト上の委任を保持している場合、それはそれは、サーバから得たオブジェクトのラベルに基づいて、ローカルの変更にポリシーを適用していることです。それはサーバにそれらの変更をコミットしようとすると、サーバーのポリシーに基づいてそれらの変更を拒絶するようにサーバのために準備する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.5.2. Server Enforcement",
      "section_title": true,
      "ja": "3.5.2. サーバーの施行"
    },
    {
      "indent": 3,
      "text": "A MAC-Functional server MUST enforce its security policy over all exported objects, for operations that originate both locally and remotely.",
      "ja": "MAC-機能サーバーは、ローカルとリモートの両方で発信操作のために、エクスポートされたすべてのオブジェクトの上にそのセキュリティポリシーを実施しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Requests from authenticated clients MUST be processed using security labels and credentials supplied by the client as if they originated locally.",
      "ja": "認証されたクライアントからの要求は、彼らがローカルに発信された場合、クライアントによって提供されるセキュリティラベルや資格情報を使用して処理しなければなりません。"
    },
    {
      "indent": 3,
      "text": "As with labeling, the system MUST also take into account any other volatile client security state, such as a change in process security context via dynamic transition. Access decisions SHOULD also be made based upon the current client security label accessing the object, rather than the security label that opened it, if different.",
      "ja": "標識と同様に、システムはまた、動的遷移を介して、プロセスのセキュリティコンテキストの変化として、アカウントに任意の他の揮発性のクライアントのセキュリティ状態を取らなければなりません。アクセス決定は、オブジェクトではなく、異なる場合は、それを開いたセキュリティラベルにアクセスして、現在のクライアントのセキュリティラベルに基づいてなされるべきです。"
    },
    {
      "indent": 3,
      "text": "The server SHOULD recall delegation of an object if the object's security label changes.",
      "ja": "サーバは、オブジェクトのセキュリティ・ラベルが変更された場合、オブジェクトの委任を思い出すべきです。"
    },
    {
      "indent": 0,
      "text": "3.6. Namespace Access",
      "section_title": true,
      "ja": "3.6. 名前空間へのアクセス"
    },
    {
      "indent": 3,
      "text": "The server SHOULD provide a means to authorize selective access to the exported file system namespace based upon client credentials and according to security policy.",
      "ja": "サーバーは、クライアントの資格情報に基づいており、セキュリティポリシーに従ってエクスポートされたファイルシステムの名前空間への選択的なアクセスを許可するための手段を提供する必要があります。"
    },
    {
      "indent": 3,
      "text": "This is a common requirement of MLS-enabled systems, which often need to present selective views of namespaces based upon the clearances of the subjects.",
      "ja": "これは、多くの場合、被験者のクリアランスに基づいて名前空間を選択的に意見を提示する必要がありMLS対応システムの一般的な要件です。"
    },
    {
      "indent": 0,
      "text": "3.7. Upgrading Existing Server",
      "section_title": true,
      "ja": "3.7. 既存のサーバーをアップグレードします"
    },
    {
      "indent": 3,
      "text": "Note that under the MAC model, all objects MUST have labels. Therefore, if an existing server is upgraded to include Labeled NFS support, then it is the responsibility of the security system to define the behavior for existing objects.",
      "ja": "MACモデルで、すべてのオブジェクトがラベルを持たなければならないことに注意してください。既存のサーバーが標識NFSサポートを含めるようにアップグレードされている場合ので、それは、既存のオブジェクトの動作を定義するためのセキュリティシステムの責任です。"
    },
    {
      "indent": 0,
      "text": "4. Modes of Operation",
      "section_title": true,
      "ja": "操作の4モード"
    },
    {
      "indent": 3,
      "text": "In a Labeled NFS client and server interaction, we can describe three modes of operation:",
      "ja": "標識NFSクライアントとサーバとの対話では、我々は3つの動作モードを記述することができます。"
    },
    {
      "indent": 3,
      "text": "1. Full",
      "section_title": true,
      "ja": "1.フル・"
    },
    {
      "indent": 3,
      "text": "2. Limited Server",
      "section_title": true,
      "ja": "2.リミテッドサーバー"
    },
    {
      "indent": 3,
      "text": "3. Guest",
      "section_title": true,
      "ja": "3.ユーザーレビュー"
    },
    {
      "indent": 3,
      "text": "These modes arise from the level of MAC functionality in the clients and servers. The clients can be non-MAC-Functional and MAC-Functional. The servers can be non-MAC-Functional, MAC-Aware, and MAC-Functional.",
      "ja": "これらのモードは、クライアントとサーバでMAC機能のレベルから生じます。クライアントは、非MAC-機能とMAC-機能することができます。サーバは、非MAC-機能MAC-Awareの、およびMAC-機能することができます。"
    },
    {
      "indent": 3,
      "text": "A MAC-Functional client MUST be able to determine the level of MAC functionality in the server. Likewise, a MAC-Functional server MUST be able to determine whether or not a client is MAC-Functional. As discussed in Section 3.3, the protocol MUST provide for the client and server to make those determinations.",
      "ja": "MAC-機能クライアントは、サーバ内のMAC機能のレベルを決定できなければなりません。同様に、MAC-機能サーバーは、クライアントがMAC-機能しているかどうかを決定できなければなりません。セクション3.3で議論するように、プロトコルは、これらの決定を行うために、クライアントとサーバを提供しなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.1. Full Mode",
      "section_title": true,
      "ja": "4.1. フルモード"
    },
    {
      "indent": 3,
      "text": "The server and the client have mutually recognized MAC functionality enabled, and full Labeled NFS functionality is extended over the network between both client and server.",
      "ja": "サーバーとクライアントが相互にMAC機能が有効になって認識しており、完全な標識NFS機能は、クライアントとサーバの両方の間で、ネットワークを介して拡張されます。"
    },
    {
      "indent": 3,
      "text": "An example of an operation in Full Mode is as follows. On the initial lookup, the client requests access to an object on the server. It sends its process security context over to the server. The server checks all relevant policies to determine if that process context from that client is allowed to access the resource. Once this has succeeded, the object, with its associated security information, is released to the client. Once the client receives the object, it determines if its policies allow the process running on the client access to the object.",
      "ja": "次のようにフルモードにおける動作の一例です。最初の検索では、クライアントは、サーバ上のオブジェクトへのアクセスを要求します。これは、サーバーにそのプロセスのセキュリティコンテキストを超える送信します。サーバは、そのクライアントからそのプロセスのコンテキストがリソースにアクセスすることを許可されているかどうかを判断するために、すべての関連するポリシーをチェックします。これが成功したら、オブジェクトは、それに関連するセキュリティ情報を、クライアントに放出されます。クライアントがオブジェクトを受信すると、そのポリシーは、プロセスがオブジェクトにアクセスするクライアント上で実行されている許可した場合、それが決定されます。"
    },
    {
      "indent": 3,
      "text": "On subsequent operations where the client already has a handle for the file, the order of enforcement is reversed. Since the client already has the security context, it may make an access decision against its policy first. This enables the client to avoid sending requests to the server that it knows will fail, regardless of the server's policy. If the client passes its policy checks, then it sends the request to the server, where the client's process context is used to determine if the server will release that resource to the client. If both checks pass, the client is given the resource and everything succeeds.",
      "ja": "クライアントがすでにファイルのハンドルを持って、その後の操作では、執行の順番が逆になります。クライアントがすでにセキュリティコンテキストを持っているので、それは最初にその政策に対するアクセス決定を行うことができます。これは関係なく、サーバの政策の失敗し、知っているサーバーに要求を送信することを回避するためにクライアントを可能にします。クライアントがそのポリシーチェックを通過した場合、それは、クライアントのプロセスコンテキストは、サーバーがクライアントにそのリソースを解放するかどうかを判断するために使用されているサーバに要求を送信します。両方のチェックが合格した場合、クライアントはリソースを与えられ、すべてが成功します。"
    },
    {
      "indent": 3,
      "text": "In the event that the client does not trust the server, it may opt to use an alternate labeling mechanism, regardless of the server's ability to return security information.",
      "ja": "クライアントがサーバーを信頼しない場合には、それは関係なく、セキュリティ情報を返すために、サーバーの能力の、別のラベル付け機構を使用することを選ぶことができます。"
    },
    {
      "indent": 0,
      "text": "4.2. Limited Server Mode",
      "section_title": true,
      "ja": "4.2. リミテッドサーバモード"
    },
    {
      "indent": 3,
      "text": "The server is MAC-Aware, and the clients are MAC-Functional. The server can store and transmit labels. It cannot enforce labels. The server MUST inform clients when an object label changes for a file the client has open.",
      "ja": "サーバは、MAC-認識し、クライアントがMAC-機能です。サーバーは、ラベルを保存して送信することができます。これは、ラベルを強制することはできません。オブジェクトのラベルは、クライアントが開いているファイルに対して変更したときにサーバがクライアントに通知しなければなりません。"
    },
    {
      "indent": 3,
      "text": "In this mode, the server may not be aware of the format of any of its object labels. Indeed, it may service several different security models at the same time. A client MUST process foreign labels as discussed in Section 3.3. As with the Guest Mode, this mode's level of trust can be degraded if non-MAC-Functional clients have access to the server.",
      "ja": "このモードでは、サーバーは、そのオブジェクトのラベルのいずれかの形式を認識できない場合があります。確かに、それは同時に、いくつかの異なるセキュリティモデルにサービスを提供することがあります。 3.3節で述べたように、クライアントは、外国のラベルを処理しなければなりません。非MAC-機能のクライアントは、サーバーへのアクセス権を持っている場合はゲストモードと同じように、信頼のこのモードのレベルが低下する可能性があります。"
    },
    {
      "indent": 0,
      "text": "4.3. Guest Mode",
      "section_title": true,
      "ja": "4.3. ゲストモード"
    },
    {
      "indent": 3,
      "text": "Only one of the server or client is MAC-Functional enabled.",
      "ja": "一つだけのサーバまたはクライアントのは、MAC-機能が有効になっています。"
    },
    {
      "indent": 3,
      "text": "In the case of the server only being MAC-Functional, the server enforces its policy and may selectively provide standard NFS services to clients based on their authentication credentials and/or associated network attributes (e.g., IP address, network interface) according to security policy. The level of trust and access extended to a client in this mode is configuration-specific.",
      "ja": "唯一のMAC-機能するサーバーの場合、サーバーは、そのポリシーを実施し、選択的に認証資格情報および/または関連するネットワーク属性（例えば、IPアドレス、ネットワーク・インターフェース）に基づいてクライアントに標準NFSサービスを提供することができるセキュリティポリシーに従って。このモードでは、クライアントに拡張信頼とアクセスのレベルは、構成固有のものです。"
    },
    {
      "indent": 3,
      "text": "In the case of the client only being MAC-Functional, the client MUST operate as a standard NFSv4.2 (see [NFSv4_2]) client and SHOULD selectively provide processes access to servers based upon the security attributes of the local process, and network attributes of the server, according to policy. The client may also override default labeling of the remote file system based upon these security attributes or other labeling methods such as mount point labeling.",
      "ja": "クライアントの場合にのみMAC-機能であり、クライアントは標準NFSv4.2（参照[NFSv4_2]）クライアントとして動作しなければならないと選択のプロセスをローカルプロセスのセキュリティ属性に基づいて、サーバ、およびネットワーク属性へのアクセスを提供すべきですポリシーに従って、サーバーの。また、クライアントは、このようなマウントポイントのラベルとしてこれらのセキュリティ属性、または他の標識方法に基づいてリモートファイルシステムのデフォルトのラベル表示を無効にすることができます。"
    },
    {
      "indent": 3,
      "text": "In other words, the Guest Mode is standard NFSv4.2 over the wire, with the MAC-Functional system mapping the non-MAC-Functional system's processes or objects to security labels based on other characteristics in order to preserve its MAC guarantees.",
      "ja": "言い換えれば、ゲストモードは、MAC-機能、システムがそのMAC保証を維持するために、他の特性に基づいて、セキュリティラベルに非MAC-機能、システムのプロセスやオブジェクトをマッピングすると、ワイヤ上の標準NFSv4.2です。"
    },
    {
      "indent": 0,
      "text": "5. Use Cases",
      "section_title": true,
      "ja": "5.ユースケース"
    },
    {
      "indent": 3,
      "text": "MAC labeling is meant to allow NFSv4.2 to be deployed in site-configurable security schemes. The LFS and opaque data scheme allows for flexibility to meet these different implementations. In this section, we provide some examples of how NFSv4.2 could be deployed to meet existing needs. This is not an exhaustive listing.",
      "ja": "MACの標識はNFSv4.2は、サイト構成可能なセキュリティ方式で展開することを可能にするためのものです。 LFSと不透明なデータスキームは、これらの異なる実装を満たすための柔軟性を実現しています。このセクションでは、NFSv4.2は、既存のニーズを満たすために展開することができる方法のいくつかの例を提供しています。これは完全なリストではありません。"
    },
    {
      "indent": 0,
      "text": "5.1. Full MAC Labeling Support for Remotely Mounted File Systems",
      "section_title": true,
      "ja": "5.1. リモートでマウントされたファイルシステムのフルMACラベル表示のサポート"
    },
    {
      "indent": 3,
      "text": "In this case, we assume a local networked environment where the servers and clients are under common administrative control. All systems in this network have the same MAC implementation and semantically identical MAC security labels for objects (i.e., labels mean the same thing on different systems, even if the policies on each system may differ to some extent). Clients will be able to apply fine-grained MAC policy to objects accessed via NFS mounts and thus improve the overall consistency of MAC policy application within this environment.",
      "ja": "この場合、我々は、サーバとクライアントが共通の管理制御下にあるローカルネットワーク接続環境を前提としています。このネットワーク内のすべてのシステム（すなわち、ラベルは、各システム上のポリシーがある程度異なる場合があっても、異なるシステムで同じことを意味する）同じMAC実装とオブジェクトの意味的に同一のMACセキュリティ・ラベルを有します。クライアントは、NFSマウントを介してアクセスするオブジェクトへのきめ細かなMACポリシーを適用するため、この環境内のMACポリシーアプリケーションの全体的な一貫性を向上させることができるようになります。"
    },
    {
      "indent": 3,
      "text": "An example of this case would be where user home directories are remotely mounted, and fine-grained MAC policy is implemented to protect, for example, private user data from being read by malicious web scripts running in the user's browser. With Labeled NFS, fine-grained MAC labeling of the user's files will allow the MAC policy to be implemented and provide the desired protection.",
      "ja": "この場合の例は、ユーザのホームディレクトリをリモートでマウントされ、かつきめ細かいMACポリシーは、例えば、よりプライベートなユーザデータは、ユーザーのブラウザで実行されている悪意のあるWebスクリプトによって読み取られて、保護するために実装されているところだろう。標識NFSでは、ユーザのファイルのきめ細かいMAC標識がMACポリシーを実装することが可能となり、所望の保護を提供します。"
    },
    {
      "indent": 0,
      "text": "5.2. MAC Labeling of Virtual Machine Images Stored on the Network",
      "section_title": true,
      "ja": "5.2. ネットワーク上に保存されている仮想マシン・イメージのMACラベル付け"
    },
    {
      "indent": 3,
      "text": "Virtualization is now a commonly implemented feature of modern operating systems, and there is a need to ensure that MAC security policy is able to protect virtualized resources. A common implementation scheme involves storing virtualized guest file systems on a networked server; these file systems are then mounted remotely by guests upon instantiation. In this case, there is a need to ensure that the local guest kernel is able to access fine-grained MAC labels on the remotely mounted file system so that its MAC security policy can be applied.",
      "ja": "仮想化は今や現代のオペレーティングシステムの一般的な実装機能であり、MACのセキュリティポリシーは、仮想化されたリソースを保護することが可能であることを確認する必要があります。一般的な実装方式は、ネットワーク上のサーバー仮想化ゲストのファイルシステムを保存する必要。これらのファイルシステムは、インスタンス化時にゲストがリモートでマウントされています。この場合、ローカルゲストカーネルはそのMACセキュリティポリシーを適用できるように、リモートでマウントされたファイルシステム上できめ細かいMACラベルにアクセスすることが可能であることを確認する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.3. Simple Security Label Storage",
      "section_title": true,
      "ja": "5.3. 簡単なセキュリティ・ラベルストレージ"
    },
    {
      "indent": 3,
      "text": "In this case, a mixed and loosely administered network is assumed, where nodes may be running a variety of operating systems with different security mechanisms and security policies. It is desired that network file servers be simply capable of storing and retrieving MAC security labels for clients that use such labels. The Labeled NFS protocol would be implemented here solely to enable transport of MAC security labels across the network. It should be noted that in such an environment, overall security cannot be as strongly enforced as when the server is also enforcing and that this scheme is aimed at allowing MAC-capable clients to function with its MAC security policy enabled rather than perhaps disabling it entirely.",
      "ja": "ノードが異なるセキュリティ・メカニズムとセキュリティポリシーにオペレーティングシステムのさまざまを実行することができる場合、この場合、混合し、緩く投与ネットワークが、想定されます。ネットワーク・ファイル・サーバは、このようなラベルを使用するクライアントのMACセキュリティラベルを格納および取得するだけで可能であることが望ましいです。標識NFSプロトコルは、ネットワークを介してMACのセキュリティラベルの輸送を可能にするためだけに、ここで実施されます。このような環境の中で、全体的なセキュリティがそれほど強くサーバーでも、おそらくそれを完全に無効に施行し、この方式は、MAC-対応クライアントではなく有効にそのMACセキュリティポリシーに機能させることを目的としている点であるときのように強制することはできないことに留意すべきです。"
    },
    {
      "indent": 0,
      "text": "5.4. Diskless Linux",
      "section_title": true,
      "ja": "5.4. ディスクレスのLinux"
    },
    {
      "indent": 3,
      "text": "A number of popular operating system distributions depend on a Mandatory Access Control (MAC) model to implement a kernel-enforced security policy. Typically, such models assign particular roles to individual processes, which limit or permit performing certain operations on a set of files, directories, sockets, or other objects. While the enforcing of the policy is typically a matter for the diskless NFS client itself, the file system objects in such models will typically carry MAC labels that are used to define policy on access. These policies may, for instance, describe privilege transitions that cannot be replicated using standard NFS ACL-based models.",
      "ja": "一般的なオペレーティングシステムのディストリビューションの数は、カーネル強制セキュリティポリシーを実装するために強制アクセス制御（MAC）モデルによって異なります。典型的には、このようなモデルは、制限またはファイル、ディレクトリ、ソケット、または他のオブジェクトのセットの特定の操作を実行可能に個々のプロセスに特定の役割を割り当てます。ポリシーの施行は通常、ディスクレスNFSクライアント自体の問題でありますが、そのようなモデルでは、ファイルシステムオブジェクトは、通常のアクセスでポリシーを定義するために使用されているMACラベルを運ぶでしょう。これらのポリシーは、例えば、標準NFS ACLベースのモデルを使用して複製することができない特権遷移を記述することができます。"
    },
    {
      "indent": 3,
      "text": "For instance, on a SYSV-compatible system (see [SYSV]), if the 'init' process spawns a process that attempts to start the 'NetworkManager' executable, there may be a policy that sets up a role transition if the 'init' process and 'NetworkManager' file labels match a particular rule. Without this role transition, the process may find itself having insufficient privileges to perform its primary job of configuring network interfaces.",
      "ja": "「初期化」プロセスが「NetworkManagerの」実行可能ファイルを起動しようとするプロセスを生成する場合、例えば、SYSV互換システム（[SYSV]を参照）に、「INIT場合にロールの推移を設定するポリシーが存在してもよいです「プロセスと 『NetworkManagerの』ファイルラベルは、特定のルールに一致します。この役割遷移せず、プロセスは、それ自体がネットワークインタフェースを構成するその主な仕事を実行するために十分な権限を有するかもしれません。"
    },
    {
      "indent": 3,
      "text": "In setups of this type, a lot of the policy targets (such as sockets or privileged system calls) are entirely local to the client. The use of RPCSEC_GSSv3 ([RPC_SEC]) for enforcing compliance at the server level is therefore of limited value. The ability to permanently label files and have those labels read back by the client is, however, crucial to the ability to enforce that policy.",
      "ja": "このタイプのセットアップでは、（例えばソケットまたは特権システムコールのような）政策目標の多くは、クライアントに完全にローカルです。サーバレベルでの準拠を強制するRPCSEC_GSSv3（[RPC_SEC]）の使用は、したがって、限られた値です。永久ファイルにラベルを付け、これらのラベルはバッククライアントによって読み取ら持っている能力は、しかし、そのポリシーを施行する能力に非常に重要です。"
    },
    {
      "indent": 0,
      "text": "5.5. Multi-Level Security",
      "section_title": true,
      "ja": "5.5. マルチレベルのセキュリティ"
    },
    {
      "indent": 3,
      "text": "In an MLS system, objects are generally assigned a sensitivity level and a set of compartments. The sensitivity levels within the system are given an order ranging from lowest to highest classification level. Read access to an object is allowed when the sensitivity level of the subject \"dominates\" the object it wants to access. This means that the sensitivity level of the subject is higher than that of the object it wishes to access and that its set of compartments is a superset of the compartments on the object.",
      "ja": "MLSシステムでは、オブジェクトは、一般に、感度レベルとコンパートメントのセットが割り当てられます。システム内の感度レベルは、最低から最高分類レベルの範囲のために与えられています。オブジェクトへのアクセスを読む対象の感度レベルは、それがアクセスしたいオブジェクトを「支配」するときに許容されます。これは、被験者の感度レベルは、それがアクセスし、コンパートメントのセットは、物体上の区画のスーパーセットであることを希望するオブジェクトのそれよりも高いことを意味します。"
    },
    {
      "indent": 3,
      "text": "The rest of this section will just use sensitivity levels. In general, the example is a client that wishes to list the contents of a directory. The system defines the sensitivity levels as Unclassified (U), Secret (S), and Top Secret (TS). The directory to be searched is labeled Top Secret, which means access to read the directory will only be granted if the subject making the request is also labeled Top Secret.",
      "ja": "このセクションの残りの部分は、単に感度レベルを使用します。一般的には、一例では、ディレクトリの内容を一覧表示することを希望するクライアントです。システムは、未分類（U）、秘密（S）、及びトップシークレット（TS）としての感度レベルを定義します。検索するディレクトリは、要求を行う対象は、トップシークレットをも標識されている場合、ディレクトリを読み取るためのアクセスを意味トップシークレットが、唯一許可される標識されています。"
    },
    {
      "indent": 0,
      "text": "5.5.1. Full Mode - MAC-Functional Client and Server",
      "section_title": true,
      "ja": "5.5.1. フルモード -  MAC-機能クライアントおよびサーバー"
    },
    {
      "indent": 3,
      "text": "In the first part of this example, a process on the client is running at the Secret level. The process issues a readdir() system call, which enters the kernel. Before translating the readdir() system call into a request to the NFSv4.2 server, the host operating system will consult the MAC module to see if the operation is allowed. Since the process is operating at Secret and the directory to be accessed is labeled Top Secret, the MAC module will deny the request and an error code is returned to user space.",
      "ja": "この例の最初の部分では、クライアント上のプロセスは、秘密のレベルで実行されています。プロセスがカーネルに入るのreaddir（）システムコールを発行します。 NFSv4.2サーバーに要求へのreaddir（）システムコールを翻訳する前に、ホストオペレーティングシステムは、操作が許可されているかどうかを確認するためにMACモジュールを協議します。プロセスは秘密とトップシークレットをラベル付けされ、アクセスするディレクトリで動作しているので、MACモジュールは、要求を拒否し、エラーコードがユーザ空間に戻されます。"
    },
    {
      "indent": 3,
      "text": "Consider a second case where instead of running at Secret the process is running at Top Secret. In this case, the sensitivity of the process is equal to or greater than that of the directory, so the MAC module will allow the request. Now the readdir() is translated into the necessary NFSv4.2 call to the server. For the remote procedure call (RPC) request, the client is using the proper credential to assert to the server that the process is running at Top Secret.",
      "ja": "トップシークレットで実行されている代わりに秘密でプロセスを実行している第二のケースを考えてみましょう。 MACモジュールが要求を可能にするので、この場合には、プロセスの感度は、ディレクトリのそれ以上です。今のreaddir（）は、サーバーに必要なNFSv4.2コールに変換されます。リモートプロシージャコール（RPC）要求の場合、クライアントはプロセスはトップシークレットで実行しているサーバーに主張するための適切な資格情報を使用しています。"
    },
    {
      "indent": 3,
      "text": "When the server receives the request, it extracts the security label from the RPC session and retrieves the label on the directory. The server then checks with its MAC module to see if a Top Secret process is allowed to read the contents of the Top Secret directory. Since this is allowed by the policy, then the server will return the appropriate information back to the client.",
      "ja": "サーバーが要求を受信すると、RPCセッションからセキュリティラベルを抽出し、ディレクトリのラベルを取得します。その後、サーバは、トップシークレットプロセスはトップシークレットのディレクトリの内容を読み取ることが許可されているかどうかを確認するためにそのMACモジュールをチェックします。これは、ポリシーで許可されているので、サーバは、クライアントに適切な情報を返します。"
    },
    {
      "indent": 3,
      "text": "In this example, the policy on both the client and server is the same. In the event that they were running different policies, a translation of the labels might be needed. In this case, it could be possible for a check to pass on the client and fail on the server. The server may consider additional information when making its policy decisions. For example, the server could determine that a certain subnet is only cleared for data up to Secret classification. If that constraint was in place for the example above, the client would still succeed, but the server would fail, since the client is asserting a label that it is not able to use (Top Secret on a Secret network).",
      "ja": "この例では、クライアントとサーバーの両方でポリシーが同じです。彼らは異なるポリシーを実行していた場合には、ラベルの翻訳が必要になる可能性があります。チェックは、クライアントを渡すと、サーバー上で失敗するため、この場合には、それが可能である可能性があります。その政策を決定する際、サーバーは、追加の情報を考慮することができます。例えば、サーバは特定のサブネットだけの秘密分類までのデータのためにクリアされていることを決定することができます。その制約は、上記の例のための場所にあった場合、クライアントはまだ成功するだろうが、クライアントは（シークレットネットワーク上のトップシークレット）を使用することはできないラベルをアサートされているため、サーバーは、失敗するでしょう。"
    },
    {
      "indent": 0,
      "text": "5.5.2. MAC-Functional Client",
      "section_title": true,
      "ja": "5.5.2.  MAC-機能クライアント"
    },
    {
      "indent": 3,
      "text": "In these scenarios, the server is either non-MAC-Aware or MAC-Aware. The actions of the client will depend on whether it is configured to treat the MAC-Aware server in the same manner as the non-MAC-Aware one. That is, does it utilize the approach presented in Section 4.3, or does it allow the MAC-Aware server to return labels?",
      "ja": "これらのシナリオでは、サーバーは非MAC-Awareのか、MAC-Awareのいずれかです。クライアントの行動は、非MAC-Awareの1と同様にMAC-Awareのサーバーを処理するように構成されているかどうかに依存します。つまり、4.3節で提示したアプローチを使用しない、またはそれはMAC-Awareのサーバがラベルを返すことができない、でしょうか？"
    },
    {
      "indent": 3,
      "text": "With a client that is MAC-Functional and using the example in the previous section, the result should be the same. The one difference is that all decisions are made on the client.",
      "ja": "MAC-機能と、前のセクションの例を使用しているクライアントでは、結果は同じでなければなりません。 1つの違いは、すべての決定は、クライアント上で行われていることです。"
    },
    {
      "indent": 0,
      "text": "5.5.2.1. MAC-Aware Server",
      "section_title": true,
      "ja": "5.5.2.1。 MAC-Awareのサーバー"
    },
    {
      "indent": 3,
      "text": "A process on the client labeled Secret wishes to access a directory labeled Top Secret on the server. This is denied, since Secret does not dominate Top Secret. Note that there will be NFSv4.2 operations issued that return an object label for the client to process.",
      "ja": "シークレットラベルされたクライアント上のプロセスは、サーバー上のトップシークレットラベルディレクトリにアクセスしたいです。シークレットは、トップシークレットを支配していないので、これは、拒否されます。プロセスへのクライアントのためのオブジェクトのラベルを返す発行NFSv4.2の操作があることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Note that in this scenario, all of the clients must be MAC-Functional. A single client that does not do its access control checks would violate the model.",
      "ja": "このシナリオでは、すべてのクライアントがMAC-機能でなければならないことに注意してください。そのアクセス制御チェックを行いません単一のクライアントは、モデルに違反します。"
    },
    {
      "indent": 0,
      "text": "5.5.2.2. Non-MAC-Aware Server",
      "section_title": true,
      "ja": "5.5.2.2。非MAC-Awareのサーバー"
    },
    {
      "indent": 3,
      "text": "A process on the client labeled Secret wishes to access a directory that the client's policies label as Top Secret on the server. This is denied, since Secret does not dominate Top Secret. Note that there will not be NFSv4.2 operations issued. If the process had a Top Secret process label instead of Secret, the client would issue NFSv4.2 operations to access the directory on the server.",
      "ja": "シークレットラベルされたクライアント上のプロセスは、ディレクトリにアクセスしたい、そのサーバー上のトップシークレットとして、クライアントのポリシーのラベル。シークレットは、トップシークレットを支配していないので、これは、拒否されます。発行NFSv4.2操作がないことに注意してください。プロセスではなく、秘密のトップシークレットプロセスラベルを持っていた場合、クライアントは、サーバ上のディレクトリにアクセスするNFSv4.2オペレーションを発行します。"
    },
    {
      "indent": 0,
      "text": "5.5.3. MAC-Functional Server",
      "section_title": true,
      "ja": "5.5.3.  MAC-機能サーバー"
    },
    {
      "indent": 3,
      "text": "With a MAC-Functional server and a client that is not, the client behaves as if it were in a normal NFSv4.2 environment. Since the process on the client does not provide a security attribute, the server must define a mechanism for labeling all requests from a client. Assume that the server is using the same criteria used in the first example. The server sees the request as coming from a subnet that is a Secret network. The server determines that all clients on that subnet will have their requests labeled with Secret. Since the directory on the server is labeled Top Secret and Secret does not dominate Top Secret, the server would fail the request with NFS4ERR_ACCESS.",
      "ja": "それは通常のNFSv4.2環境にあったかのようではありませんMAC-機能、サーバーとクライアントでは、クライアントが動作します。クライアント上のプロセスがセキュリティ属性を提供していないので、サーバは、クライアントからのすべての要求を標識するためのメカニズムを定義する必要があります。サーバは、実施例1で使用したのと同じ基準を使用していると仮定する。サーバーは秘密のネットワークであるサブネットから来るとして要求を見ています。サーバーは、そのサブネット上のすべてのクライアントがシークレットで標識した彼らの要求を持っているだろうことを決定します。サーバー上のディレクトリがトップシークレットを支配していないトップシークレットとシークレットをラベル付けされているので、サーバはNFS4ERR_ACCESSで要求を失敗していました。"
    },
    {
      "indent": 0,
      "text": "6. Security Considerations",
      "section_title": true,
      "ja": "6.セキュリティの考慮事項"
    },
    {
      "indent": 0,
      "text": "6.1. Trust Needed for a Community",
      "section_title": true,
      "ja": "6.1. コミュニティのために必要なトラスト"
    },
    {
      "indent": 3,
      "text": "Labeled NFS is a transport mechanism for labels, a storage requirement for labels, and a definition of how to interpret labels. It defines the responsibilities of the client and the server in the various permutations of being MAC-Functional. It does not, however, dictate in any manner whether assumptions can be made about other entities in the relationship. For example, it does not define whether a MAC-Functional client can demand that a MAC-Aware server only accept requests from other MAC-Functional clients. That is a policy based on a MAC model, and this document does not impose policies on systems.",
      "ja": "標識NFSは、ラベル用のトランスポートメカニズム、ラベルのストレージ要件、およびラベルを解釈する方法の定義です。これは、MAC-機能であることの様々な順列で、クライアントとサーバーの責任を定義します。しかし、前提は関係の他のエンティティについて行うことができるかどうかをどのような方法で規定していません。例えば、それは、MAC-機能クライアントがMAC-Awareのサーバが唯一の他のMAC-機能クライアントからの要求を受け入れることを要求できるかどうかを定義していません。これは、MACモデルに基づいたポリシーであり、この文書では、システム上でポリシーを課しません。"
    },
    {
      "indent": 3,
      "text": "As the requirement is a policy, it can be met with the use of a MAC model. Let L be an LFS that implements the Limited Server mode, i.e., a MAC-Aware server connected to MAC-Functional clients. Then a new LFS, L', can be created that has the additional policy that the MAC-Aware server MUST NOT accept any requests from a non-MAC-Functional client.",
      "ja": "要件がポリシーであるとして、それはMACモデルを使用して満たすことができます。 Lリミテッドサーバーモードを実装してLFS、すなわち、MAC-機能のクライアントに接続されているMAC-Awareのサーバーとします。次に、新しいLFS、L」は、MAC-Awareのサーバが非MAC-機能クライアントからの要求を受け入れてはいけません追加のポリシーを持っているように作成することができます。"
    },
    {
      "indent": 0,
      "text": "6.2. Guest Mode",
      "section_title": true,
      "ja": "6.2. ゲストモード"
    },
    {
      "indent": 3,
      "text": "When either the client or server is operating in Guest Mode, it is important to realize that one side is not enforcing MAC protections. Alternate methods are being used to handle the lack of MAC support, and care should be taken to identify and mitigate threats from possible tampering outside of these methods.",
      "ja": "クライアントまたはサーバのどちらかがゲストモードで動作しているときは、1辺がMAC保護を強制されていないことを認識することが重要です。別の方法は、MACのサポートの欠如を処理するために使用されている、とケアは、これらの方法の可能性改ざん外部からの脅威を識別し、緩和するために取られるべきです。"
    },
    {
      "indent": 0,
      "text": "6.3. MAC-Functional Client Configuration",
      "section_title": true,
      "ja": "6.3.  MAC-機能クライアントの設定"
    },
    {
      "indent": 3,
      "text": "We defined a MAC model as an access control decision made on a system in which normal users do not have the ability to override policies (see Section 1). If the process labels are created solely on the client, then if a malicious user has sufficient access on that client, the Labeled NFS model is compromised. Note that this is no different from:",
      "ja": "私たちは通常、ユーザーがポリシー（セクション1を参照）をオーバーライドする能力を持っていないようなシステムで作られたアクセス制御決定としてMACモデルを定義しました。プロセスのラベルは、クライアントにのみ作成されている場合、悪意のあるユーザーがそのクライアントに十分なアクセス権を持っている場合、その後、標識NFSモデルが危険にさらされています。これは違いはありませんことに注意してください："
    },
    {
      "indent": 3,
      "text": "o current implementations in which the server uses policies to effectively determine the object label for requests from the client, or",
      "ja": "サーバーが効果的にクライアントからの要求のためのオブジェクトのラベルを決定するためのポリシーを使用している現在の実装で、O、または"
    },
    {
      "indent": 3,
      "text": "o local decisions made on the client by the MAC security system.",
      "ja": "MACセキュリティシステムにより、クライアント上で作られたOローカル決定。"
    },
    {
      "indent": 3,
      "text": "Either the server must explicitly trust the client (as in [SENFSv3]) or the MAC model should enforce that users cannot override policies, perhaps via an externally managed source.",
      "ja": "どちらのサーバーは、明示的に（[SENFSv3]のように）クライアントを信頼しなければならないか、MACモデルでは、ユーザーは、おそらく外部管理ソースを経由して、ポリシーを上書きすることはできませんことを強制すべきです。"
    },
    {
      "indent": 3,
      "text": "Once the labels leave the client, they can be protected by the transport mechanism as described in Section 3.2.",
      "ja": "ラベルは、クライアントを離れたら、セクション3.2で説明したように、彼らは、トランスポートメカニズムによって保護することができます。"
    },
    {
      "indent": 0,
      "text": "7. References",
      "section_title": true,
      "ja": "7.参考"
    },
    {
      "indent": 0,
      "text": "7.1. Normative References",
      "section_title": true,
      "ja": "7.1. 引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 0,
      "text": "7.2. Informative References",
      "section_title": true,
      "ja": "7.2. 参考文献"
    },
    {
      "indent": 3,
      "text": "[DTOS] Smalley, S., \"The Distributed Trusted Operating System (DTOS) Home Page\", December 2000, <http://www.cs.utah.edu/ flux/fluke/html/dtos/HTML/dtos.html>.",
      "ja": "[DTOS]スモーリー、S.、 \"分散信頼できるオペレーティングシステム（DTOS）ホームページ\"、2000年12月、<http://www.cs.utah.edu/フラックス/まぐれ/ HTML / DTOS / HTML / dtos.html >。"
    },
    {
      "indent": 3,
      "text": "[NFSv4_2] Haynes, T., \"NFS Version 4 Minor Version 2\", Work in Progress, February 2014.",
      "ja": "[NFSv4_2]ヘインズ、T.、 \"NFSバージョン4のマイナーバージョン2\"、進歩、2014年2月での作業。"
    },
    {
      "indent": 3,
      "text": "[RFC4949] Shirey, R., \"Internet Security Glossary, Version 2\", RFC 4949, August 2007.",
      "ja": "[RFC4949] Shirey、R.、 \"インターネットセキュリティ用語集、バージョン2\"、RFC 4949、2007年8月。"
    },
    {
      "indent": 3,
      "text": "[RH_MLS] \"Multi-Level Security (MLS)\", \"Deployment, configuration and administration of Red Hat Enterprise Linux 5, Edition 10\", Section 49.6, 2014, <http://docs.redhat.com/docs/ en-US/Red_Hat_Enterprise_Linux/5/html/Deployment_Guide/ sec-mls-ov.html>.",
      "ja": "[RH_MLS] \"マルチレベルセキュリティ（MLS）\"、 \"Red Hat Enterprise Linuxに5の導入、設定、管理、版10\"、第49.6、2014年、<http://docs.redhat.com/docs/エン米国/ Red_Hat_Enterprise_Linux / 5 / HTML / Deployment_Guide /秒-MLS-ov.html>。"
    },
    {
      "indent": 3,
      "text": "[RPC_SEC] Adamson, W. and N. Williams, \"Remote Procedure Call (RPC) Security Version 3\", Work in Progress, February 2014.",
      "ja": "[RPC_SEC]アダムソン、W.およびN.ウィリアムズ、 \"リモートプロシージャコール（RPC）Securityバージョン3\"、進歩、2014年2月での作業。"
    },
    {
      "indent": 3,
      "text": "[SENFSv3] Carter, J., \"Implementing SELinux Support for NFS\", <http://www.nsa.gov/research/_files/selinux/papers/ nfsv3.pdf>.",
      "ja": "【SENFSv3】カーター、J.、 \"NFSのためのSELinuxサポートの実装\"、<http://www.nsa.gov/research/_files/selinux/papers/ nfsv3.pdf>。"
    },
    {
      "indent": 3,
      "text": "[SYSV] AT&T, \"System V Interface Definition (SVID)\", Third Edition, Addison-Wesley, Reading, MA, 1989.",
      "ja": "[SYSV] AT＆T、 \"システムVインタフェース定義（SVID）\"、第3版、アディソン・ウェズリー、読書、MA、1989。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Acknowledgments",
      "ja": "付録A.謝辞"
    },
    {
      "indent": 3,
      "text": "David Quigley was the early energy in motivating the entire Labeled NFS effort.",
      "ja": "デビッド・クイグリーは、全体の標識NFSの努力をやる気に早期のエネルギーでした。"
    },
    {
      "indent": 3,
      "text": "James Morris, Jarrett Lu, and Stephen Smalley all were key contributors to both early versions of this document and to many conference calls.",
      "ja": "ジェームズ・モリス、ジャレット呂、そしてスティーブン・スモーリーすべては、この文書の両方の初期バージョンに、多くの電話会議への鍵貢献しました。"
    },
    {
      "indent": 3,
      "text": "Kathleen Moriarty provided use cases for earlier versions of the document.",
      "ja": "キャスリーン・モリアーティは、ドキュメントの以前のバージョンのためのユースケースを提供します。"
    },
    {
      "indent": 3,
      "text": "Dan Walsh provided use cases for Secure Virtualization, Sandboxing, and NFS homedir labeling to handle process separation.",
      "ja": "ダン・ウォルシュは、プロセスの分離を処理するためのセキュアな仮想化、サンドボックス、およびNFSのHOMEDIR標識のためのユースケースを提供します。"
    },
    {
      "indent": 3,
      "text": "Trond Myklebust provided use cases for secure diskless NFS clients.",
      "ja": "トロンMyklebustは、安全なディスクレスNFSクライアントのためにユースケースを提供します。"
    },
    {
      "indent": 3,
      "text": "Both Nico Williams and Bryce Nordgren challenged assumptions during the review processes.",
      "ja": "ニコ・ウィリアムズとブライスNordgrenどちらも、レビュープロセスの間に仮定に挑戦しました。"
    },
    {
      "indent": 0,
      "text": "Author's Address",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Thomas Haynes NetApp 495 East Java Dr. Sunnyvale, CA 94089 USA",
      "ja": "トーマス・ヘインズNetAppの495東ジャワ博士はカリフォルニア州サニーベール94089 USA"
    },
    {
      "indent": 3,
      "text": "Phone: +1 408 215 1519 EMail: tdh@excfb.com",
      "ja": "電話：+1 408 215 1519 Eメール：tdh@excfb.com"
    }
  ]
}