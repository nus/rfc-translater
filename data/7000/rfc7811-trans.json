{
  "title": {
    "text": "RFC 7811 - An Algorithm for Computing IP/LDP Fast Reroute Using Maximally Redundant Trees (MRT-FRR)",
    "ja": "RFC 7811 - 最大限の冗長木を使用したコンピューティングIP / LDP高速リルートのためのアルゴリズム（MRT-FRR）"
  },
  "number": 7811,
  "created_at": "2019-11-02 00:56:46.851173+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                         G. Enyedi\nRequest for Comments: 7811                                    A. Csaszar\nCategory: Standards Track                                       Ericsson\nISSN: 2070-1721                                                 A. Atlas\n                                                               C. Bowers\n                                                        Juniper Networks\n                                                              A. Gopalan\n                                                   University of Arizona\n                                                               June 2016",
      "raw": true
    },
    {
      "indent": 13,
      "text": "An Algorithm for Computing IP/LDP Fast Reroute\n  Using Maximally Redundant Trees (MRT-FRR)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document supports the solution put forth in \"An Architecture for IP/LDP Fast Reroute Using Maximally Redundant Trees (MRT-FRR)\" (RFC 7812) by defining the associated MRT Lowpoint algorithm that is used in the Default MRT Profile to compute both the necessary Maximally Redundant Trees with their associated next hops and the alternates to select for MRT-FRR.",
      "ja": "この文書では、両方を計算するためにデフォルトMRTプロファイルで使用され、関連するMRT Lowpointアルゴリズムを定義することにより、（RFC 7812）、「最大限の冗長木（MRT-FRR）を使用して、IP / LDP高速リルートのためのアーキテクチャ」に出すソリューションをサポートしていますそれらに関連する次のホップと交互で必要な最大限の冗長木はMRT-FRRを選択します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 7841のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7811.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7811で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2016 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2016 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3\n2.  Requirements Language . . . . . . . . . . . . . . . . . . . .   5\n3.  Terminology and Definitions . . . . . . . . . . . . . . . . .   5\n4.  Algorithm Key Concepts  . . . . . . . . . . . . . . . . . . .   6\n  4.1.  Partial Ordering for Disjoint Paths . . . . . . . . . . .   7\n  4.2.  Finding an Ear and the Correct Direction  . . . . . . . .   8\n  4.3.  Lowpoint Values and Their Uses  . . . . . . . . . . . . .  11\n  4.4.  Blocks in a Graph . . . . . . . . . . . . . . . . . . . .  14\n  4.5.  Determining Localroot and Assigning Block-ID  . . . . . .  16\n5.  MRT Lowpoint Algorithm Specification  . . . . . . . . . . . .  18\n  5.1.  Interface Ordering  . . . . . . . . . . . . . . . . . . .  18\n  5.2.  MRT Island Identification . . . . . . . . . . . . . . . .  21\n  5.3.  GADAG Root Selection  . . . . . . . . . . . . . . . . . .  21\n  5.4.  Initialization  . . . . . . . . . . . . . . . . . . . . .  22\n  5.5.  Constructing the GADAG Using Lowpoint Inheritance . . . .  23\n  5.6.  Augmenting the GADAG by Directing All Links . . . . . . .  25\n  5.7.  Compute MRT Next Hops . . . . . . . . . . . . . . . . . .  29\n    5.7.1.  MRT Next Hops to All Nodes Ordered with Respect to\n            the Computing Node  . . . . . . . . . . . . . . . . .  29\n    5.7.2.  MRT Next Hops to All Nodes Not Ordered with Respect\n            to the Computing Node . . . . . . . . . . . . . . . .  30\n    5.7.3.  Computing Redundant Tree Next Hops in a 2-Connected\n            Graph . . . . . . . . . . . . . . . . . . . . . . . .  31\n    5.7.4.  Generalizing for a Graph That Isn't 2-Connected . . .  33\n    5.7.5.  Complete Algorithm to Compute MRT Next Hops . . . . .  34\n  5.8.  Identify MRT Alternates . . . . . . . . . . . . . . . . .  36\n  5.9.  Named Proxy-Nodes . . . . . . . . . . . . . . . . . . . .  44\n    5.9.1.  Determining Proxy-Node Attachment Routers . . . . . .  45\n    5.9.2.  Computing If an Island Neighbor (IN) Is Loop-Free . .  45\n    5.9.3.  Computing MRT Next Hops for Proxy-Nodes . . . . . . .  47\n    5.9.4.  Computing MRT Alternates for Proxy-Nodes  . . . . . .  53",
      "raw": true
    },
    {
      "indent": 3,
      "text": "6.  MRT Lowpoint Algorithm: Next-Hop Conformance  . . . . . . . .  61\n7.  Broadcast Interfaces  . . . . . . . . . . . . . . . . . . . .  61\n  7.1.  Computing MRT Next Hops on Broadcast Networks . . . . . .  62\n  7.2.  Using MRT Next Hops as Alternates in the Event of\n        Failures on Broadcast Networks  . . . . . . . . . . . . .  63\n8.  Evaluation of Alternative Methods for Constructing GADAGs . .  64\n9.  Operational Considerations  . . . . . . . . . . . . . . . . .  66\n  9.1.  GADAG Root Selection  . . . . . . . . . . . . . . . . . .  67\n  9.2.  Destination-Rooted GADAGs . . . . . . . . . . . . . . . .  67\n10. Security Considerations . . . . . . . . . . . . . . . . . . .  67\n11. References  . . . . . . . . . . . . . . . . . . . . . . . . .  68\n  11.1.  Normative References . . . . . . . . . . . . . . . . . .  68\n  11.2.  Informative References . . . . . . . . . . . . . . . . .  68\nAppendix A.  Python Implementation of MRT Lowpoint Algorithm  . .  70\nAppendix B.  Constructing a GADAG Using SPFs  . . . . . . . . . . 110\nAppendix C.  Constructing a GADAG Using a Hybrid Method . . . . . 115\nAcknowledgements  . . . . . . . . . . . . . . . . . . . . . . . . 117\nAuthors' Addresses  . . . . . . . . . . . . . . . . . . . . . . . 118",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "MRT Fast Reroute requires that packets can be forwarded not only on the shortest-path tree, but also on two Maximally Redundant Trees (MRTs), referred to as the MRT-Blue and the MRT-Red. A router that experiences a local failure must also have predetermined which alternate to use. This document defines how to compute these three things for use in MRT-FRR and describes the algorithm design decisions and rationale. The algorithm is based on those presented in [MRTLinear] and expanded in [EnyediThesis]. The MRT Lowpoint algorithm is required for implementation when the Default MRT Profile is implemented.",
      "ja": "MRTは、高速リルートパケットが最短パス木ではなく、二つ最大限の冗長木（のMRT）だけでなく転送することができることを必要とする、MRTブルー及びMRT赤と呼びます。地元の障害が発生したルータはまた、使用する別の所定ている必要があります。この文書では、MRT-FRRで使用するためにこれらの3つのことを計算する方法を定義し、アルゴリズムの設計上の決定や根拠を説明しています。アルゴリズムは[MRTLinear]と[EnyediThesis]に展開に提示されたものに基づいています。デフォルトMRTプロファイルが実装されている場合MRT Lowpointアルゴリズムが実装に必要です。"
    },
    {
      "indent": 3,
      "text": "The MRT Lowpoint Algorithm defined in this document, when used for MRT Fast-Reroute as described in [RFC7812], guarantees 100% recovery for single failures when the network is 2-connected. This guaranteed coverage does not depend on the link metrics, which an operator may be using to traffic-engineer the IP network. Thus, the link metrics and general network topology are largely decoupled from the guaranteed coverage.",
      "ja": "[RFC7812]で説明されるようにMRT高速再ルーティングのために使用される場合、ネットワーク2に接続されている場合は、この文書で定義されたMRT Lowpointアルゴリズムは、単一障害に対する100％の回収率を保証します。この保証範囲は、オペレータは、トラフィックエンジニアリングIPネットワークを使用してにすることができるリンクメトリックに依存しません。このように、リンクメトリックと一般的なネットワークトポロジは、主に保証カバレッジから分離されています。"
    },
    {
      "indent": 3,
      "text": "Just as packets routed on a hop-by-hop basis require that each router compute a shortest-path tree that is consistent, it is necessary for each router to compute the MRT-Blue next hops and MRT-Red next hops in a consistent fashion. This document defines the MRT Lowpoint algorithm to be used as a standard in the Default MRT Profile for MRT-FRR.",
      "ja": "ホップ単位でルーティングされたパケットが一致していること、各ルータの計算A最短パスツリーを必要とするのと同じように、各ルータは一貫した方法でMRTブルーネクストホップとMRT-レッドネクストホップを計算することが必要です。この文書では、MRT-FRRのデフォルトMRTプロファイルにおける標準として使用するMRT Lowpointアルゴリズムを定義します。"
    },
    {
      "indent": 3,
      "text": "A router's Forwarding Information Base (FIB) will continue to contain primary next hops for the current shortest-path tree for forwarding traffic. In addition, a router's FIB will contain primary next hops for the MRT-Blue for forwarding received traffic on the MRT-Blue and primary next hops for the MRT-Red for forwarding received traffic on the MRT-Red.",
      "ja": "ルータの転送情報ベース（FIB）は、トラフィックを転送するために、現在の最短経路木の主なネクストホップを含有し続けるだろう。また、ルータのFIBは転送のためにMRTブルーの主な次のホップが含まれていますMRTブルーのトラフィックを受信し、転送のためのMRTレッドの主なネクストホップは、MRT-レッド上のトラフィックを受けました。"
    },
    {
      "indent": 3,
      "text": "What alternate next hops a Point of Local Repair (PLR) selects need not be consistent -- but loops must be prevented. To reduce congestion, it is possible for multiple alternate next hops to be selected; in the context of MRT alternates, each of those alternate next hops would be equal-cost paths.",
      "ja": "次のローカル修理のポイントをホップは何の代替（PLR）選択は一貫している必要はない - しかし、ループを防止しなければなりません。複数の代替次のホップを選択するための輻輳を低減するために、それが可能です。 MRTの交互の文脈において、これらの代替の次のホップのそれぞれは、等コストパスであろう。"
    },
    {
      "indent": 3,
      "text": "This document defines an algorithm for selecting an appropriate MRT alternate for consideration. Other alternates, e.g., Loop-Free Alternates (LFAs) that are downstream paths, may be preferred when available. See the \"Operational Considerations\" section of [RFC7812] for a more detailed discussion of combining MRT alternates with those produced by other FRR technologies.",
      "ja": "この文書は、検討のために適切なMRTの代替を選択するためのアルゴリズムを定義します。他の代替案は、例えば、下流経路であるループフリーのAlternates（LFAs）は、利用可能な場合に好ましいことができます。他のFRRの技術によって製造されたものとMRTの交互の組み合わせのより詳細な議論については[RFC7812]の「動作の考慮事項」の項を参照してください。"
    },
    {
      "indent": 3,
      "text": "[E]---[D]---|           [E]<--[D]<--|                [E]-->[D]---|\n |     |    |            |     ^    |                       |    |\n |     |    |            V     |    |                       V    V\n[R]   [F]  [C]          [R]   [F]  [C]               [R]   [F]  [C]\n |     |    |                  ^    ^                 ^     |    |\n |     |    |                  |    |                 |     V    |\n[A]---[B]---|           [A]-->[B]---|                [A]<--[B]<--|",
      "raw": true
    },
    {
      "indent": 3,
      "text": " (a) (b) (c) A 2-connected graph MRT-Blue towards R MRT-Red towards R",
      "ja": "（A）（B）（C）A 2に接続されたグラフRに向かってR MRTレッド向かっMRTブルー"
    },
    {
      "indent": 33,
      "text": "Figure 1",
      "ja": "図1"
    },
    {
      "indent": 3,
      "text": "The MRT Lowpoint algorithm can handle arbitrary network topologies where the whole network graph is not 2-connected, as in Figure 2, as well as the easier case where the network graph is 2-connected (Figure 1). Each MRT is a spanning tree. The pair of MRTs provide two paths from every node X to the root of the MRTs. Those paths share the minimum number of nodes and the minimum number of links. Each such shared node is a cut-vertex. Any shared links are cut-links.",
      "ja": "MRT Lowpointアルゴリズムは、ネットワーク全体のグラフは、図2のように、2-接続されていないだけでなく、ネットワークグラフが2接続されている簡単場合（図1）は、任意のネットワークトポロジを扱うことができます。各MRTは、スパニングツリーです。 MRTの一対のMRTのルートにすべてのノードXからの二つの経路を提供します。これらのパスは、ノードの最小数とリンクの最小数を共有します。このような各共有ノードは、カット頂点です。任意の共有リンクは、リンクを切断します。"
    },
    {
      "indent": 24,
      "text": "[E]---[D]---|     |---[J]\n |     |    |     |    |\n |     |    |     |    |\n[R]   [F]  [C]---[G]   |\n |     |    |     |    |\n |     |    |     |    |\n[A]---[B]---|     |---[H]",
      "raw": true
    },
    {
      "indent": 23,
      "text": "(a) a graph that is not 2-connected",
      "ja": "（A）2が接続されていないグラフ"
    },
    {
      "indent": 9,
      "text": "[E]<--[D]<--|         [J]        [E]-->[D]---|     |---[J]\n |     ^    |          |                |    |     |    ^\n V     |    |          |                V    V     V    |\n[R]   [F]  [C]<--[G]   |         [R]   [F]  [C]<--[G]   |\n       ^    ^     ^    |          ^     |    |          |\n       |    |     |    V          |     V    |          |\n[A]-->[B]---|     |---[H]        [A]<--[B]<--|         [H]",
      "raw": true
    },
    {
      "indent": 10,
      "text": "(b) MRT-Blue towards R (c) MRT-Red towards R",
      "ja": "（B）Rに向かってR（C）に向かってMRTブルーMRT赤"
    },
    {
      "indent": 16,
      "text": "Figure 2: A Network That Is Not 2-Connected",
      "ja": "図2：2に接続されていないネットワーク"
    },
    {
      "indent": 0,
      "text": "2. Requirements Language",
      "section_title": true,
      "ja": "2.必要な言語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はあります[RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "3. Terminology and Definitions",
      "section_title": true,
      "ja": "3.用語と定義"
    },
    {
      "indent": 3,
      "text": "Please see the Terminology section of [RFC7812] for a complete list of terminology relevant to this document. The list below does not repeat terminology introduced in that RFC.",
      "ja": "このドキュメントに関連する用語の完全なリストについては、[RFC7812]の用語のセクションを参照してください。以下のリストは、RFCで導入された用語を繰り返しません。"
    },
    {
      "indent": 3,
      "text": "spanning tree: A tree that contains links and that connects all nodes in the network graph.",
      "ja": "スパニングツリー：リンクが含まれ、それがネットワークグラフ内のすべてのノードを接続する木。"
    },
    {
      "indent": 3,
      "text": "back-edge: In the context of a spanning tree computed via a depth-first search, a back-edge is a link that connects a descendant of a node x with an ancestor of x.",
      "ja": "バックエッジは：深さ優先探索を介して計算されたスパニングツリーのコンテキストでは、バックエッジは、xの祖先とノードXの子孫を接続するリンクです。"
    },
    {
      "indent": 3,
      "text": "partial ADAG: A subset of an Almost Directed Acyclic Graph (ADAG) that doesn't yet contain all the nodes in the block. A partial ADAG is created during the MRT Lowpoint algorithm and then expanded until all nodes in the block are included and it becomes an ADAG.",
      "ja": "部分ADAG：まだブロック内のすべてのノードが含まれていないほとんど有向非循環グラフ（ADAG）のサブセット。部分ADAGは、MRT Lowpointアルゴリズム中に作成され、次いで拡張ブロック内のすべてのノードが含まれるまで、それはADAGなります。"
    },
    {
      "indent": 3,
      "text": "DFS: Depth-First Search",
      "ja": "DFS：深さ優先探索"
    },
    {
      "indent": 3,
      "text": "DFS ancestor: A node n is a DFS ancestor of x if n is on the DFS-tree path from the DFS root to x.",
      "ja": "DFSの祖先：ノードnはxにDFSルートからDFSツリー経路上にある場合は、XのDFSの祖先です。"
    },
    {
      "indent": 3,
      "text": "DFS descendant: A node n is a DFS descendant of x if x is on the DFS-tree path from the DFS root to n.",
      "ja": "DFSの子孫：XはNにDFSルートからDFSツリー経路上にある場合、ノードnはXのDFSの子孫です。"
    },
    {
      "indent": 3,
      "text": "ear: A path along nodes that are not yet included in the Generalized ADAG (GADAG) that starts at a node that is already included in the GADAG and that ends at a node that is already included in the GADAG. The starting and ending nodes may be the same node if it is a cut-vertex.",
      "ja": "耳：既にGADAGに含まれているノードで開始し、それは既にGADAGに含まれるノードで終了まだ一般ADAG（GADAG）に含まれていないノードに沿った経路。それはカット頂点である場合に開始および終了ノードが同じノードであってもよいです。"
    },
    {
      "indent": 3,
      "text": "X>>Y or Y<<X: Indicates the relationship between X and Y in a partial order, such as found in a GADAG. X>>Y means that X is higher in the partial order than Y. Y<<X means that Y is lower in the partial order than X.",
      "ja": "X >> Y又はY << X：GADAGに見られるような、半順序にXとYとの関係を示します。 X >> Yは、XがYとYより半順序に高いことを意味する<< Xは、YがXより半順序に低いことを意味します"
    },
    {
      "indent": 3,
      "text": "X>Y or Y<X: Indicates the relationship between X and Y in the total order, such as found via a topological sort. X>Y means that X is higher in the total order than Y. Y<X means that Y is lower in the total order than X.",
      "ja": "X> Y又はY <X：そのようなトポロジカルソートを介して見られるように、全順序にXとYとの関係を示します。 Xは、Yは、XがYのYよりも全順序に高いことを意味する<Xは、YがXより全順序に低いことを意味します>"
    },
    {
      "indent": 3,
      "text": "X ?? Y: Indicates that X is unordered with respect to Y in the partial order.",
      "ja": "バツ ？？ Y：Xは半順序でYに関して順不同であることを示します。"
    },
    {
      "indent": 3,
      "text": "UNDIRECTED: In the GADAG, each link is marked as OUTGOING, INCOMING, or both. Until the directionality of the link is determined, the link is marked as UNDIRECTED to indicate that its direction hasn't been determined.",
      "ja": "無向：GADAGでは、各リンクは、OUTGOING INCOMING、またはその両方としてマークされています。リンクの方向性が決定されるまで、リンクはその方向が決定されていないことを示すために無向としてマークされています。"
    },
    {
      "indent": 3,
      "text": "OUTGOING: A link marked as OUTGOING has direction in the GADAG from the interface's router to the remote end.",
      "ja": "OUTGOING：OUTGOINGがリモートエンドへのインターフェイスのルータからGADAG方向を持っているとしてマークされたリンク。"
    },
    {
      "indent": 3,
      "text": "INCOMING: A link marked as INCOMING has direction in the GADAG from the remote end to the interface's router.",
      "ja": "INCOMING：受信インターフェイスのルータへのリモートエンドからGADAG方向を持っているとしてマークされたリンク。"
    },
    {
      "indent": 0,
      "text": "4. Algorithm Key Concepts",
      "section_title": true,
      "ja": "4.アルゴリズムキーコンセプト"
    },
    {
      "indent": 3,
      "text": "There are five key concepts that are critical for understanding the MRT Lowpoint algorithm. The first is the idea of partially ordering the nodes in a network graph with regard to each other and to the GADAG root. The second is the idea of finding an ear of nodes and adding them in the correct direction. The third is the idea of a Lowpoint value and how it can be used to identify cut-vertices and to find a second path towards the root. The fourth is the idea that a non-2-connected graph is made up of blocks, where a block is a",
      "ja": "MRT Lowpointアルゴリズムを理解するために重要な5つの重要な概念があります。最初は互いに部分的に及びGADAGルートに関してネットワークグラフ内のノードを注文するという考えです。第二は、ノードの耳を発見し、正しい方向でそれらを追加するという考えです。第三は、Lowpoint値とどのようにカット頂点を識別するために、ルートに向かって第二の経路を見つけるために使用することができるという考え方です。第四は、非2接続グラフがブロックであり、ブロックで構成されているという考えであります"
    },
    {
      "indent": 3,
      "text": "2-connected cluster, a cut-link or an isolated node. The fifth is the idea of a localroot for each node; this is used to compute ADAGs in each block.",
      "ja": "2-接続されたクラスタ、カットリンク又は孤立ノード。第五は、各ノードのlocalrootの考えです。これは、各ブロック内ADAGsを計算するために使用されます。"
    },
    {
      "indent": 0,
      "text": "4.1. Partial Ordering for Disjoint Paths",
      "section_title": true,
      "ja": "4.1. ディスジョイントパスの半順序"
    },
    {
      "indent": 3,
      "text": "Given any two nodes X and Y in a graph, a particular total order means that either X<Y or X>Y in that total order. An example would be a graph where the nodes are ranked based upon their unique IP loopback addresses. In a partial order, there may be some nodes for which it can't be determined whether X<<Y or X>>Y. A partial order can be captured in a directed graph, as shown in Figure 3. In a graphical representation, a link directed from X to Y indicates that X is a neighbor of Y in the network graph and X<<Y.",
      "ja": "グラフ内の任意の2つのノードXとYが与えられると、特定の全順序は、その総ためにそのX <YまたはX> Yのいずれかを意味します。一例では、ノードは、その固有のIPループバックアドレスに基づいてランク付けされているグラフになります。部分的ためには、X << YまたはX >> Yか否かを判断することができないため、いくつかのノードが存在してもよいです。グラフ表示では、図3に示すように、部分的な順序は、有向グラフに捕捉することができ、YをXから有向リンクは、Xは、ネットワークグラフとX << YにおけるYの近隣であることを示しています。"
    },
    {
      "indent": 9,
      "text": "[A]<---[R]    [E]       R << A << B << C << D << E\n |             ^        R << A << B << F << G << H << D << E\n |             |\n V             |        Unspecified Relationships:\n[B]--->[C]--->[D]             C and F\n |             ^              C and G\n |             |              C and H\n V             |\n[F]--->[G]--->[H]",
      "raw": true
    },
    {
      "indent": 13,
      "text": "Figure 3: Directed Graph Showing a Partial Order",
      "ja": "図3：部分的な手順を示す有向グラフ"
    },
    {
      "indent": 3,
      "text": "To compute MRTs, the root of the MRTs is at both the very bottom and the very top of the partial ordering. This means that from any node X, one can pick nodes higher in the order until the root is reached. Similarly, from any node X, one can pick nodes lower in the order until the root is reached. For instance, in Figure 4, from G the higher nodes picked can be traced by following the directed links and are H, D, E, and R. Similarly, from G the lower nodes picked can be traced by reversing the directed links and are F, B, A, and R. A graph that represents this modified partial order is no longer a DAG; it is termed an Almost DAG (ADAG) because if the links directed to the root were removed, it would be a DAG.",
      "ja": "MRTを計算するには、MRTをのルートは一番下と半順序の最上部の両方です。これは、ルートに到達するまでの任意のノードXから、一方がために、より高いノードを選ぶことができることを意味します。根に到達するまで同様に、任意のノードXから、一つは順に下位ノードを選択することができます。例えば、図4では、Gより高いノードは、有向リンクを追跡することによって追跡することができる採取し、下位ノードは、有向リンクを逆に辿ることができる採取Gから、同様にH、D、E、及びR.であるとされていますF、B、A、およびR.これを表すグラフは、半順序を変更し、もはやDAGではありません。ルートに向けたリンクが削除された場合、それはDAGになるので、それはほとんどDAG（ADAG）と呼ばれています。"
    },
    {
      "indent": 5,
      "text": "[A]<---[R]<---[E]      R << A << B << C << R\n |      ^      ^       R << A << B << C << D << E << R\n |      |      |       R << A << B << F << G << H << D << E << R\n V      |      |\n[B]--->[C]--->[D]      Unspecified Relationships:\n |             ^              C and F\n |             |              C and G\n V             |              C and H\n[F]--->[G]--->[H]",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Figure 4: ADAG Showing a Partial Order with R Lowest and Highest",
      "ja": "図4：ADAGはRの最大値と最小値との半順序を表示します"
    },
    {
      "indent": 3,
      "text": "Most importantly, if a node Y>>X, then Y can only appear on the increasing path from X to the root and never on the decreasing path. Similarly, if a node Z<<X, then Z can only appear on the decreasing path from X to the root and never on the increasing path.",
      "ja": "最も重要なのは、ノードY >> X場合、YはrootのみにXから増加パスに、決して減少パス上に表示されます。同様に、ノードZ << Xは、次にZはrootのみに決して増加経路にXから減少する経路上に現れることができるかどうか。"
    },
    {
      "indent": 3,
      "text": "When following the increasing paths, it is possible to pick multiple higher nodes and still have the certainty that those paths will be disjoint from the decreasing paths. For example, in the previous example, node B has multiple possibilities to forward packets along an increasing path: it can either forward packets to C or F.",
      "ja": "増加パスを以下の場合には、より高い複数のノードを選択し、依然としてそれらのパスが低下経路からばらばらになることを確信を持つことが可能です。例えば、前の例では、ノードBは、増加の経路に沿ってパケットを転送するために複数の可能性を有している：それは、CまたはFにパケットを転送することができるいずれか"
    },
    {
      "indent": 0,
      "text": "4.2. Finding an Ear and the Correct Direction",
      "section_title": true,
      "ja": "4.2. 耳と正しい向きを検索"
    },
    {
      "indent": 3,
      "text": "For simplicity, the basic idea of creating a GADAG by adding ears is described assuming that the network graph is a single 2-connected cluster so that an ADAG is sufficient. Generalizing to multiple blocks is done by considering the block-roots instead of the GADAG root -- and the actual algorithm is given in Section 5.5.",
      "ja": "簡単にするために、耳を追加することによってGADAGを作成するための基本的な考え方は、ADAGが十分であるように、ネットワークグラフは単2接続クラスタであると仮定して説明します。複数のブロックに一般化は、ブロック・ルーツの代わりGADAGルートを考慮して行われる - と実際のアルゴリズムは、セクション5.5で与えられています。"
    },
    {
      "indent": 3,
      "text": "In order to understand the basic idea of finding an ADAG, first suppose that we have already a partial ADAG, which doesn't contain all the nodes in the block yet, and we want to extend it to cover all the nodes. Suppose that we find a path from a node X to Y such that X and Y are already contained by our partial ADAG, but all the remaining nodes along the path are not added to the ADAG yet. We refer to such a path as an \"ear\".",
      "ja": "まず、我々はすでに、まだブロック内のすべてのノードが含まれていない部分ADAGを、持っている、と我々はそれがすべてのノードをカバーするために拡張したいと仮定し、ADAGを見つけることの基本的な考え方を理解するために。我々はYにノードXからのパスを見つけると仮定し、XとYは、すでに私たちの部分ADAGに含まれているが、パスに沿った残りのすべてのノードがまだADAGに追加されないように。私たちは、「耳」のようなパスを参照してください。"
    },
    {
      "indent": 3,
      "text": "Recall that our ADAG is closely related to a partial order. More precisely, if we remove root R, the remaining DAG describes a partial order of the nodes. If we suppose that neither X nor Y is the root, we may be able to compare them. If one of them is definitely lesser with respect to our partial order (say X<<Y), we can add the new path to the ADAG in a direction from X to Y. As an example, consider Figure 5.",
      "ja": "私たちのADAGが半順序に密接に関連していることを思い出してください。より正確には、我々はルートRを削除する場合、残りのDAGノードの半順序を記述する。我々はXもYもないがルートであると仮定した場合、我々はそれらを比較することができるかもしれません。そのうちの一つは間違いなく低い私たちの半順序（たとえばX << Y）に関してであるならば、我々は一例としてXからYに方向ADAGに新しいパスを追加することができ、図5を検討してください。"
    },
    {
      "indent": 11,
      "text": "E---D---|              E<--D---|           E<--D<--|\n|   |   |              |   ^   |           |   ^   |\n|   |   |              V   |   |           V   |   |\nR   F   C              R   F   C           R   F   C\n|   |   |              |   ^   |           |   ^   ^\n|   |   |              V   |   |           V   |   |\nA---B---|              A-->B---|           A-->B---|",
      "raw": true
    },
    {
      "indent": 14,
      "text": "(a) (b) (c)",
      "ja": "（A）（B）（C）"
    },
    {
      "indent": 11,
      "text": "(a) A 2-connected graph (b) Partial ADAG (C is not included) (c) Resulting ADAG after adding path (or ear) B-C-D",
      "ja": "（A）2に接続されたグラフは、（b）は、部分的ADAG（Cが含まれていない）（c）のパス（または耳）B-C-Dを添加した後ADAGが得られました"
    },
    {
      "indent": 33,
      "text": "Figure 5",
      "ja": "図5"
    },
    {
      "indent": 3,
      "text": "In this partial ADAG, node C is not yet included. However, we can find path B-C-D, where both endpoints are contained by this partial ADAG (we say those nodes are \"ready\" in the following text), and the remaining node (node C) is not contained yet. If we remove R, the remaining DAG defines a partial order, and with respect to this partial order, we can say that B<<D; so, we can add the path to the ADAG in the direction from B to D (arcs B->C and C->D are added). If B>>D, we would add the same path in reverse direction.",
      "ja": "この部分ADAGでは、ノードCは、まだ含まれていません。しかし、我々は、両方のエンドポイントが（私たちはこれらのノードは、次のテキストに「準備完了」と言う）は、この部分ADAGに含まれており、残りのノード（ノードC）はまだ含まれていないパスB-C-Dを、見つけることができます。我々はRを削除した場合、残りのDAGは、半順序を定義し、この半順序に関して、我々は、B << Dを言うことができます。そこで、BからDへの方向にADAGへのパスを追加することができ（弧B-> C及びC-> D追加されます）。 B >> Dならば、我々は逆方向に同じパスを追加します。"
    },
    {
      "indent": 3,
      "text": "If, in the partial order where an ear's two ends are X and Y, X<<Y, then there must already be a directed path from X to Y in the ADAG. The ear must be added in a direction such that it doesn't create a cycle; therefore, the ear must go from X to Y.",
      "ja": "部分的ために耳の両端部がXとY、X << Yである場合、場合、既にADAGでXからYへの有向パスが存在しなければなりません。耳は、サイクルを作成しないような方向に加えなければなりません。そのため、耳がYにXから行かなければなりません"
    },
    {
      "indent": 3,
      "text": "In the case when X and Y are not ordered with each other, we can select either direction for the ear. We have no restriction since neither of the directions can result in a cycle. In the corner case when one of the endpoints of an ear, say X, is the root (recall that the two endpoints must be different), we could use both directions again for the ear because the root can be considered both as smaller and as greater than Y. However, we strictly pick that direction in which the root is lower than Y. The logic for this decision is explained in Section 5.7",
      "ja": "XとYが互いに一緒に注文されていない場合には、我々は、耳のために、いずれかの方向を選択することができます。私たちは、方向のいずれもサイクルにつながることができますので、制限がありません。ルートが小さくとして、およびとしても考えることができるので、耳のエンドポイントの1つは、Xは、ルートであると言うコーナーケース（2つのエンドポイントが異なっていなければならないことを思い出してください）では、私たちは耳のために再び両方の方向を使用することができますY.より大きいしかし、我々は厳密には根が、この決定のためのロジックは、セクション5.7で説明されているY.よりも低くなっているその方向を選びます"
    },
    {
      "indent": 3,
      "text": "A partial ADAG is started by finding a cycle from the root R back to itself. This can be done by selecting a non-ready neighbor N of R and then finding a path from N to R that doesn't use any links between R and N. The direction of the cycle can be assigned either way since it is starting the ordering.",
      "ja": "部分的ADAGはバック自体にルートRからのサイクルを見つけることによって開始されます。これは、Rの非レディ近隣Nを選択し、Nから、それが起動されているので、サイクルの方向がいずれかの方法で割り当てることができるRとNとの間のリンクを使用していないRへのパスを見つけることによって行うことができます発注。"
    },
    {
      "indent": 3,
      "text": "Once a partial ADAG is already present, it will always have a node that is not the root R in it. The following is a brief proof that a partial ADAG can always have ears added to it: just select a non-ready neighbor N of a ready node Q, such that Q is not the root R, find a path from N to the root R in the graph with Q removed. This path is an ear where the first node of the ear is Q, the next is N, then the path until the first ready node the path reached (that ready node is the other endpoint of the path). Since the graph is 2-connected, there must be a path from N to R without Q.",
      "ja": "部分的ADAGがすでに存在していると、それは常にそれのルートRではないノードを持つことになります。部分的ADAGはいつも耳がそれに追加したことを簡単に証明され、次のちょうどQがルートRがないように、準備ができてノードQの非準備隣人Nを選択するには、ルートRへのNからのパスを見つけますQとグラフで除去しました。この経路は、耳の最初のノードは、パスが最初readyノードまでの経路が（readyノードが経路の他のエンドポイントであること）Q、次がNに達した耳です。グラフは、2-接続されているので、Q.なしRのNからパスが存在しなければなりません"
    },
    {
      "indent": 3,
      "text": "It is always possible to select a non-ready neighbor N of a ready node Q so that Q is not the root R. Because the network is 2-connected, N must be connected to two different nodes and only one can be R. Because the initial cycle has already been added to the ADAG, there are ready nodes that are not R. Since the graph is 2-connected, while there are non-ready nodes, there must be a non-ready neighbor N of a ready node that is not R.",
      "ja": "このネットワークは2-接続されているのでQがルートR.ならないように準備ができてノードQの非準備隣人Nを選択することが常に可能である、Nは、2つの異なるノードに接続する必要があり、一方だけがR.場合があるので、最初のサイクルは、既に非対応ノードがあるが、その準備ノードの非レディ近隣Nが存在する必要があり、グラフが2に接続されているのでR.ないレディノードがある、ADAGに追加されていますR.ではありません"
    },
    {
      "indent": 4,
      "text": "Generic_Find_Ears_ADAG(root) Create an empty ADAG. Add root to the ADAG. Mark root as IN_GADAG. Select an arbitrary cycle containing root. Add the arbitrary cycle to the ADAG. Mark cycle's nodes as IN_GADAG. Add cycle's non-root nodes to process_list. While there exist connected nodes in graph that are not IN_GADAG Select a new ear. Let its endpoints be X and Y. If Y is root or (Y<<X) Add the ear towards X to the ADAG Else // (a) X is root, or (b) X<<Y, or (c) X, Y not ordered Add the ear towards Y to the ADAG",
      "ja": "Generic_Find_Ears_ADAG（ルート）空ADAGを作成します。 ADAGにルートを追加します。 IN_GADAGとしてマークするルート。ルートを含む任意の周期を選択します。 ADAGに任意の周期を追加します。 IN_GADAGとしてマークサイクルのノード。 process_listにサイクルの非ルート・ノードを追加します。グラフに接続されたノードが存在するがIN_GADAG新耳を選択されません。そのエンドポイントがあるとするXとYの場合はYがルートであるか（Y << X）エルスADAG //にXへの耳を追加（A）Xがルートである、または（b）のX << Y、または（c） X、YはADAGにY方向に耳を追加注文していません"
    },
    {
      "indent": 6,
      "text": "Figure 6: Generic Algorithm to Find Ears and Their Direction in 2-Connected Graph",
      "ja": "図6：一般的なアルゴリズム2  - 連結グラフに耳とその方向性を見つけるために、"
    },
    {
      "indent": 3,
      "text": "The algorithm in Figure 6 merely requires that a cycle or ear be selected without specifying how. Regardless of the method for selecting the path, we will get an ADAG. The method used for finding and selecting the ears is important; shorter ears result in shorter paths along the MRTs. The MRT Lowpoint algorithm uses the Lowpoint Inheritance method for constructing an ADAG (and ultimately a GADAG). This method is defined in Section 5.5. Other methods for constructing GADAGs are described in Appendices B and C. An evaluation of these different methods is given in Section 8.",
      "ja": "図6のアルゴリズムは、単にサイクルまたは耳がどのように指定せずに選択されることを要求します。かかわらず、パスを選択するための方法の、我々はADAGを取得します。耳を見つけ、選択するために使用される方法が重要です。短い耳のMRTに沿って短いパスにつながります。 MRT LowpointアルゴリズムはADAG（最終的GADAG）を構築するためLowpoint継承メソッドを使用します。この方法は、5.5節で定義されています。 GADAGsを構築するための他の方法は、これらの異なる方法の評価は、セクション8に記載されている付録BおよびCに記載されています。"
    },
    {
      "indent": 3,
      "text": "As an example, consider Figure 5 again. First, we select the shortest cycle containing R, which can be R-A-B-F-D-E (uniform link costs were assumed), so we get to the situation depicted in",
      "ja": "例として、再び図5を検討してください。まず、R-A-B-F-D-E（均一なリンクコストを仮定した）であることができるRを含む最短サイクルを選択し、私たちはに示されている状況に取得します"
    },
    {
      "indent": 3,
      "text": "Figure 5(b). Finally, we find a node next to a ready node; that must be node C and assume we reached it from ready node B. We search a path from C to R without B in the original graph. The first ready node along this is node D, so the open ear is B-C-D. Since B<<D, we add arc B->C and C->D to the ADAG. Since all the nodes are ready, we stop at this point.",
      "ja": "図5（B）。最後に、我々は準備ができてノードの次のノードを見つけます。それは、ノードCであると我々は、元のグラフにBずにRのCからのパスを検索する準備ができてノードBからそれを達すると仮定しなければなりません。これに沿った第1のreadyノードは、ノードDであるので、オープン耳B-C-Dです。 B << Dので、我々はADAGにD>アークB-> CおよびCを追加します。すべてのノードが準備ができているので、我々はこの時点で停止します。"
    },
    {
      "indent": 0,
      "text": "4.3. Lowpoint Values and Their Uses",
      "section_title": true,
      "ja": "4.3.  Lowpoint値とその使用方法"
    },
    {
      "indent": 3,
      "text": "A basic way of computing a spanning tree on a network graph is to run a DFS, such as given in Figure 7. This tree has the important property that if there is a link (x, n), then either n is a DFS ancestor of x or n is a DFS descendant of x. In other words, either n is on the path from the root to x or x is on the path from the root to n.",
      "ja": "ネットワークグラフのスパニングツリーを計算する基本的な方法は、DFSを実行することで、図7に示すようなこのツリーは、重要な特性を有しているが、その後、リンク（X、N）のいずれかのN DFSの先祖である場合XまたはNのXのDFSの子孫です。換言すれば、いずれかのn XまたはXへのルートからのパス上にあるが、nのルートからのパス上にあります。"
    },
    {
      "indent": 24,
      "text": "global_variable: dfs_number",
      "ja": "global_variable：dfs_number"
    },
    {
      "indent": 24,
      "text": "DFS_Visit(node x, node parent) D(x) = dfs_number dfs_number += 1 x.dfs_parent = parent for each link (x, w) if D(w) is not set DFS_Visit(w, x)",
      "ja": "DFS_Visit（ノードX、ノードの親）D（W X）各リンクについて（X）= dfs_number dfs_number + = 1 x.dfs_parent =親D（W）がDFS_Visit（X、W）に設定されていない場合"
    },
    {
      "indent": 24,
      "text": "Run_DFS(node gadag_root) dfs_number = 0 DFS_Visit(gadag_root, NONE)",
      "ja": "Run_DFS（ノードgadag_root）dfs_number = 0 DFS_Visit（gadag_root、NONE）"
    },
    {
      "indent": 23,
      "text": "Figure 7: Basic DFS Algorithm",
      "ja": "図7：基本的なDFSアルゴリズム"
    },
    {
      "indent": 3,
      "text": "Given a node x, one can compute the minimal DFS number of the neighbors of x, i.e., min( D(w) if (x,w) is a link). This gives the earliest attachment point neighboring x. What is interesting, though, is the earliest attachment point from x and x's descendants. This is what is determined by computing the Lowpoint value.",
      "ja": "ノードx与えられ、一つはすなわち、分（D（W）が（X、W）リンクである場合）、xの近傍の最小DFS数を計算することができます。これは、xを隣接最古の取り付け点を与えます。興味深いのは何ですか、しかし、XおよびXの子孫から早いアタッチメントポイントです。これはLowpoint値を計算することによって決定されるものです。"
    },
    {
      "indent": 3,
      "text": "In order to compute the low point value, the network is traversed using DFS and the vertices are numbered based on the DFS walk. Let this number be represented as DFS(x). All the edges that lead to already-visited nodes during DFS walk are back-edges. The back-edges are important because they give information about reachability of a node via another path.",
      "ja": "低いポイント値を計算するために、ネットワークは、DFSを使用してトラバースされ、頂点はDFS徒歩に基づいて番号が付けられています。この数は、DFS（x）のように表すことがしてみましょう。 DFSウォーク中に、既に訪問されたためにノードを導くすべてのエッジはバックエッジです。それらは別の経路を介してノードの到達可能性に関する情報を与えるためのバックエッジが重要です。"
    },
    {
      "indent": 3,
      "text": "The low point number is calculated by finding:",
      "ja": "低ポイント数を見つけることによって計算されます。"
    },
    {
      "indent": 3,
      "text": "Low(x) = Minimum of ( (DFS(x), Lowest DFS(n, x->n is a back-edge), Lowest Low(n, x->n is tree edge in DFS walk) ).",
      "ja": "（N、X-> N最低低い低い（X）=（（DFS（x）は、最低DFS（N、X-> nは、バックエッジの最小値）は、DFS徒歩でツリーエッジ））です。"
    },
    {
      "indent": 3,
      "text": "A detailed algorithm for computing the lowpoint value is given in Figure 8. Figure 9 illustrates how the Lowpoint algorithm applies to an example graph.",
      "ja": "lowpoint値を計算するための詳細なアルゴリズムは図8に示されている図9はLowpointアルゴリズムは、例えば、グラフに適用される様子を示します。"
    },
    {
      "indent": 12,
      "text": "global_variable: dfs_number",
      "ja": "global_variable：dfs_number"
    },
    {
      "indent": 12,
      "text": "Lowpoint_Visit(node x, node parent, interface p_to_x) D(x) = dfs_number L(x) = D(x) dfs_number += 1 x.dfs_parent = parent x.dfs_parent_intf = p_to_x.remote_intf x.lowpoint_parent = NONE for each ordered_interface intf of x if D(intf.remote_node) is not set Lowpoint_Visit(intf.remote_node, x, intf) if L(intf.remote_node) < L(x) L(x) = L(intf.remote_node) x.lowpoint_parent = intf.remote_node x.lowpoint_parent_intf = intf else if intf.remote_node is not parent if D(intf.remote_node) < L(x) L(x) = D(intf.remote_node) x.lowpoint_parent = intf.remote_node x.lowpoint_parent_intf = intf",
      "ja": "Lowpoint_Visit各ordered_interfaceため（ノードX、ノードの親、インタフェースp_to_x）D（X）= dfs_number L（X）= D（X）dfs_number + = 1 x.dfs_parent =親x.dfs_parent_intf = p_to_x.remote_intf x.lowpoint_parent = NONE XのINTF D（intf.remote_node）がLowpoint_Visit（intf.remote_node、X、INTF）L IF（intf.remote_node）<L（x）は、L（X）= L（intf.remote_node）x.lowpoint_parent =に設定されていない場合intf.remote_node x.lowpoint_parent_intf = INTF他intf.remote_nodeが親でない場合であればD（intf.remote_node）<L（x）は、L（X）= D（intf.remote_node）x.lowpoint_parent = intf.remote_node x.lowpoint_parent_intf = INTF"
    },
    {
      "indent": 12,
      "text": "Run_Lowpoint(node gadag_root) dfs_number = 0 Lowpoint_Visit(gadag_root, NONE, NONE)",
      "ja": "Run_Lowpoint（ノードgadag_root）dfs_number = 0 Lowpoint_Visit（gadag_root、NONE、NONE）"
    },
    {
      "indent": 20,
      "text": "Figure 8: Computing Lowpoint Value",
      "ja": "図8：Lowpoint値を計算します"
    },
    {
      "indent": 12,
      "text": "[E]---|    [J]-------[I]   [P]---[O]\n |    |     |         |     |     |\n |    |     |         |     |     |\n[R]  [D]---[C]--[F]  [H]---[K]   [N]\n |          |    |    |     |     |\n |          |    |    |     |     |\n[A]--------[B]  [G]---|    [L]---[M]",
      "raw": true
    },
    {
      "indent": 15,
      "text": "(a) a non-2-connected graph",
      "ja": "（A）非2接続グラフ"
    },
    {
      "indent": 12,
      "text": " [E]----|    [J]---------[I]    [P]------[O]\n(5, )   |  (10, )       (9, ) (16,  ) (15,  )\n  |     |     |           |      |        |\n  |     |     |           |      |        |\n [R]   [D]---[C]---[F]   [H]----[K]      [N]\n(0, ) (4, ) (3, ) (6, ) (8, ) (11, )  (14, )\n  |           |     |     |      |        |\n  |           |     |     |      |        |\n [A]---------[B]   [G]----|     [L]------[M]\n(1, )       (2, ) (7, )       (12,  )  (13,  )",
      "raw": true
    },
    {
      "indent": 15,
      "text": "(b) with DFS values assigned (D(x), L(x))",
      "ja": "（b）は、DFS値が割り当てられたと（D（x）は、L（x））を"
    },
    {
      "indent": 12,
      "text": " [E]----|    [J]---------[I]    [P]------[O]\n(5,0)   |  (10,3)       (9,3) (16,11) (15,11)\n  |     |     |           |      |        |\n  |     |     |           |      |        |\n [R]   [D]---[C]---[F]   [H]----[K]      [N]\n(0,0) (4,0) (3,0) (6,3) (8,3) (11,11) (14,11)\n  |           |     |     |      |        |\n  |           |     |     |      |        |\n [A]---------[B]   [G]----|     [L]------[M]\n(1,0)       (2,0) (7,3)       (12,11)  (13,11)",
      "raw": true
    },
    {
      "indent": 16,
      "text": "(c) with lowpoint values assigned (D(x), L(x))",
      "ja": "（C）（D（x）は、L（x））を割り当てlowpoint値を持ちます"
    },
    {
      "indent": 15,
      "text": "Figure 9: Example Lowpoint Value Computation",
      "ja": "図9：実施例Lowpoint値計算"
    },
    {
      "indent": 3,
      "text": "From the lowpoint value and lowpoint parent, there are three very useful things that motivate our computation.",
      "ja": "lowpoint値とlowpoint親から、私たちの計算のやる気を引き出す3つの非常に便利なものがあります。"
    },
    {
      "indent": 3,
      "text": "First, if there is a child c of x such that L(c) >= D(x), then there are no paths in the network graph that go from c or its descendants to an ancestor of x; therefore, x is a cut-vertex. In Figure 9, this can be seen by looking at the DFS children of C. C has two children, D and F and L(F) = 3 = D(C); so, it is clear that C is a cut-vertex and F is in a block where C is the block's root. L(D) = 0<3 = D(C), so D has a path to the ancestors of C; in this case, D can go via E to reach R. Comparing the lowpoint values of all a node's DFS-children with the node's DFS-value is very useful because it allows identification of the cut-vertices and thus the blocks.",
      "ja": "まず、xの子Cがある場合、その結果L（C）> = D（x）は、次にxの祖先にCまたはその子孫から行くネットワークグラフにはパスが存在しません。したがって、Xは、カット頂点です。図9に、これは二人の子供、DおよびFとL（F）= 3 = D（C）を有するC. CのDFSの子供を見て見ることができます。したがって、Cがカット頂点であり、Fは、Cブロックのルートであるブロックであることは明らかです。 L（D）= 0 <3 = D（C）、DはCの祖先へのパスを持つように、この場合、Dは、Rは、ノードのDFS値を持つすべてのノードのDFS-子供のlowpoint値を比較到達するためにEを経由して行くことができ、それはカットの頂点、したがって、ブロックの識別を可能にするために非常に有用です。"
    },
    {
      "indent": 3,
      "text": "Second, by repeatedly following the path given by lowpoint_parent, there is a path from x back to an ancestor of x that does not use the link [x, x.dfs_parent] in either direction. The full path need not be taken, but this gives a way of finding an initial cycle and then ears.",
      "ja": "第二に、繰り返しlowpoint_parentによって与えられたパスに従うことによって、バックいずれかの方向に[X、x.dfs_parent]リンクを使用しないXの祖先にXからのパスがあります。完全なパスが取られる必要はありませんが、これは、最初のサイクル、その後、耳を見つける方法を提供します。"
    },
    {
      "indent": 3,
      "text": "Third, as seen in Figure 9, even if L(x)<D(x), there may be a block that contains both the root and a DFS-child of a node while other DFS-children might be in different blocks. In this example, C's child D is in the same block as R while F is not. It is important to realize that the root of a block may also be the root of another block.",
      "ja": "第三に、（X）<D（X）もL場合、図9に見られるように、他のDFS-子供が異なるブロックにあるかもしれないしながら、ノードのルートとDFSと子の両方を含むブロックが存在してもよいです。 Fはないが、この例では、Cの子DはRと同じブロックです。ブロックのルートはまた別のブロックのルートであってもよいことを認識することが重要です。"
    },
    {
      "indent": 0,
      "text": "4.4. Blocks in a Graph",
      "section_title": true,
      "ja": "4.4. グラフ内のブロック"
    },
    {
      "indent": 3,
      "text": "A key idea for the MRT Lowpoint algorithm is that any non-2-connected graph is made up by blocks (e.g., 2-connected clusters, cut-links, and/or isolated nodes). To compute GADAGs and thus MRTs, computation is done in each block to compute ADAGs or Redundant Trees and then those ADAGs or Redundant Trees are combined into a GADAG or MRT.",
      "ja": "MRT Lowpointアルゴリズムのキーアイデアは、任意の非2接続グラフがブロック（例えば、2-接続されたクラスタ、カットリンク、及び/又は単離されたノード）によって構成されていることです。 GADAGsひいてはのMRTを計算するため、計算がADAGsまたは冗長木及びそれらADAGsまたは冗長木がGADAGまたはMRTに結合さを計算するために、各ブロックで行われます。"
    },
    {
      "indent": 18,
      "text": "[E]---|    [J]-------[I]   [P]---[O]\n |    |     |         |     |     |\n |    |     |         |     |     |\n[R]  [D]---[C]--[F]  [H]---[K]   [N]\n |          |    |    |     |     |\n |          |    |    |     |     |\n[A]--------[B]  [G]---|    [L]---[M]",
      "raw": true
    },
    {
      "indent": 18,
      "text": "(a) A graph with four blocks: three 2-connected clusters and one cut-link",
      "ja": "3 2に接続されたクラスタと1つの切断リンク：4つのブロックを有する（a）のグラフ"
    },
    {
      "indent": 18,
      "text": "[E]<--|    [J]<------[I]   [P]<--[O]\n |    |     |         ^     |     ^\n V    |     V         |     V     |\n[R]  [D]<--[C]  [F]  [H]<---[K]  [N]\n            ^    |    ^           ^\n            |    V    |           |\n[A]------->[B]  [G]---|     [L]-->[M]",
      "raw": true
    },
    {
      "indent": 20,
      "text": "(b) MRT-Blue for destination R",
      "ja": "（B）先R用MRTブルー"
    },
    {
      "indent": 18,
      "text": "[E]---|    [J]-------->[I]    [P]-->[O]\n      |                 |            |\n      V                 V            V\n[R]  [D]-->[C]<---[F]  [H]<---[K]   [N]\n ^          |      ^    |      ^     |\n |          V      |    |      |     V\n[A]<-------[B]    [G]<--|     [L]<--[M]",
      "raw": true
    },
    {
      "indent": 21,
      "text": "(c) MRT-Red for destination R",
      "ja": "宛先Rの（c）のMRTレッド"
    },
    {
      "indent": 33,
      "text": "Figure 10",
      "ja": "図10"
    },
    {
      "indent": 3,
      "text": "Consider the example depicted in Figure 10 (a). In this figure, a special graph is presented, showing us all the ways 2-connected clusters can be connected. It has four blocks: block 1 contains R, A, B, C, D, E; block 2 contains C, F, G, H, I, J; block 3 contains K, L, M, N, O, P; and block 4 is a cut-link containing H and K. As can be observed, the first two blocks have one common node (node C) and blocks 2 and 3 do not have any common node, but they are connected through a cut-link that is block 4. No two blocks can have more than one common node, since two blocks with at least two common nodes would qualify as a single 2-connected cluster.",
      "ja": "図10（A）に示されている例を考えます。この図では、特殊なグラフは私たち2接続のクラスタを接続することができるすべての方法を示し、提示されます。これは、4つのブロックを有する：ブロック1は、R、A、B、C、D、Eを含有します。ブロック2は、C、F、G、H、I、Jを含んでいます。ブロック3は、K、L、M、N、O、Pを含有します。及び4ブロックH及びK. Asを含むカットリンクを観察することができ、最初の2つのブロックが一つの共通のノード（ノードC）を有していると、ブロック2及び3は、任意の共通のノードを持っていないが、それらはカット - を介して接続されています少なくとも2つの共通のノードを有する2つのブロック以降の複数の共通ノードを有することができる。4.どの2つのブロックをブロックであるリンクは、単2に接続されたクラスタとして適格であろう。"
    },
    {
      "indent": 3,
      "text": "Moreover, observe that if we want to get from one block to another, we must use a cut-vertex (the cut-vertices in this graph are C, H, K), regardless of the path selected, so we can say that all the paths from block 3 along the MRTs rooted at R will cross K first. This observation means that if we want to find a pair of MRTs rooted at R, then we need to build up a pair of RTs in block 3 with K as a root. Similarly, we need to find another pair of RTs in block 2 with C as a root, and finally, we need the last pair of RTs in block 1 with R as a root. When all the trees are selected, we can simply combine them; when a block is a cut-link (as in block 4), that cut-link is added in the same direction to both of the trees. The resulting trees are depicted in Figure 10 (b) and (c).",
      "ja": "また、我々は別のブロックから取得したい場合、我々はカット頂点を使用しなければならないことを確認かかわらず、選択されたパスの、（このグラフでカット頂点はC、H、Kである）ので、我々は、すべての言うことができますRをルートのMRTに沿ってブロック3からのパスは、第Kを横切ることになります。この観察は、我々はRをルートのMRTのペアを検索したい場合は、その後、我々はルートとしてKとブロック3におけるRTのペアを構築する必要があることを意味します。同様に、我々は、ルートとしてCとブロック2におけるRTの別のペアを見つける必要があり、最終的に、我々は、ルートとしてRとブロック1にRTの最後のペアを必要とします。すべての木が選択されている場合、我々は単にそれらを組み合わせることができます。ブロック（ブロック4のように）カットリンクである場合、そのカットリンクは木の両方に同じ方向に付加されます。得られた木は、図10（b）及び（c）に示されています。"
    },
    {
      "indent": 3,
      "text": "Similarly, to create a GADAG it is sufficient to compute ADAGs in each block and connect them.",
      "ja": "同様に、GADAGを作成するために、各ブロック内ADAGsを計算し、それらを接続するのに十分です。"
    },
    {
      "indent": 3,
      "text": "It is necessary, therefore, to identify the cut-vertices, the blocks and identify the appropriate localroot to use for each block.",
      "ja": "これは、カットの頂点、ブロックを識別し、各ブロックに使用する適切なlocalrootを識別するために、従って、必要です。"
    },
    {
      "indent": 0,
      "text": "4.5. Determining Localroot and Assigning Block-ID",
      "section_title": true,
      "ja": "4.5.  Localrootと割り当てブロック-IDの決定"
    },
    {
      "indent": 3,
      "text": "Each node in a network graph has a localroot, which is the cut-vertex (or root) in the same block that is closest to the root. The localroot is used to determine whether two nodes share a common block.",
      "ja": "ネットワークグラフ内の各ノードは、ルートに最も近い同じブロックにカット頂点（またはルート）であるlocalrootを有しています。 localrootは、2つのノードが共通ブロックを共有するかどうかを決定するために使用されます。"
    },
    {
      "indent": 15,
      "text": "Compute_Localroot(node x, node localroot)\n    x.localroot = localroot\n    for each DFS child node c of x\n        if L(c) < D(x)   //x is not a cut-vertex\n            Compute_Localroot(c, x.localroot)\n        else\n            mark x as cut-vertex\n            Compute_Localroot(c, x)",
      "raw": true
    },
    {
      "indent": 15,
      "text": "Compute_Localroot(gadag_root, gadag_root)",
      "ja": "Compute_Localroot（gadag_root、gadag_root）"
    },
    {
      "indent": 15,
      "text": "Figure 11: A Method for Computing Localroots",
      "ja": "図11：コンピューティングLocalroots方法"
    },
    {
      "indent": 3,
      "text": "There are two different ways of computing the localroot for each node. The stand-alone method is given in Figure 11 and better illustrates the concept; it is used by the GADAG construction methods given in Appendices B and C. The MRT Lowpoint algorithm computes the localroot for a block as part of computing the GADAG using lowpoint inheritance; the essence of this computation is given in Figure 12. Both methods for computing the localroot produce the same results.",
      "ja": "各ノードのlocalrootを計算する2つの方法があります。スタンドアロンの方法は、図11と良好に示す概念を示しています。それは付録Bに示さGADAG構築方法によって使用され、C.ザMRT Lowpointアルゴリズムはlowpoint継承を使用GADAGを計算の一部として、ブロックのlocalrootを計算します。この計算の本質はlocalrootを計算するための両方の方法は、同じ結果をもたらす図12に示されています。"
    },
    {
      "indent": 12,
      "text": "Get the current node, s.\nCompute an ear (either through lowpoint inheritance\nor by following dfs parents) from s to a ready node e.\n(Thus, s is not e, if there is such ear.)\nif s is e\n   for each node x in the ear that is not s\n       x.localroot = s\nelse\n   for each node x in the ear that is not s or e\n       x.localroot = e.localroot",
      "raw": true
    },
    {
      "indent": 11,
      "text": "Figure 12: Ear-Based Method for Computing Localroots",
      "ja": "図12：コンピューティングのためのLocalroots耳ベースの方法"
    },
    {
      "indent": 3,
      "text": "Once the localroots are known, two nodes X and Y are in a common block if and only if one of the following three conditions apply.",
      "ja": "localrootsが知られると、次の三つの条件の場合にのみ1が適用される場合、2つのノードX及びYは、共通ブロックです。"
    },
    {
      "indent": 3,
      "text": "o Y's localroot is X's localroot : They are in the same block and neither is the cut-vertex closest to the root.",
      "ja": "彼らは、同じブロックにあり、どちらもルートに最も近いカットの頂点ではありません：O Yさんlocalrootは、Xのlocalrootです。"
    },
    {
      "indent": 3,
      "text": "o Y's localroot is X: X is the cut-vertex closest to the root for Y's block",
      "ja": "O YのlocalrootはXであり、XはYのブロックのためのルートにカット頂点最も近いです"
    },
    {
      "indent": 3,
      "text": "o Y is X's localroot: Y is the cut-vertex closest to the root for X's block",
      "ja": "O Yは、Xのlocalrootある：Yは、Xのブロックのためのルートにカット頂点最も近いです"
    },
    {
      "indent": 3,
      "text": "Once we have computed the localroot for each node in the network graph, we can assign for each node, a Block-ID that represents the block in which the node is present. This computation is shown in Figure 13.",
      "ja": "我々はネットワークグラフ内の各ノードのlocalrootを計算した後、我々は、各ノード、ノードが存在するブロックを表すブロック-IDのために割り当てることができます。この計算は、図13に示されています。"
    },
    {
      "indent": 17,
      "text": "global_var: max_block_id",
      "ja": "global_var：max_block_id"
    },
    {
      "indent": 17,
      "text": "Assign_Block_ID(x, cur_block_id) x.block_id = cur_block_id foreach DFS child c of x if (c.local_root is x) max_block_id += 1 Assign_Block_ID(c, max_block_id) else Assign_Block_ID(c, cur_block_id)",
      "ja": "xのAssign_Block_ID（X、cur_block_id）x.block_id = cur_block_id foreachのDFS子C（c.local_rootがXである）場合max_block_id + = 1 Assign_Block_ID（C、max_block_id）他Assign_Block_ID（C、cur_block_id）"
    },
    {
      "indent": 17,
      "text": "max_block_id = 0 Assign_Block_ID(gadag_root, max_block_id)",
      "ja": "max_block_id = 0 Assign_Block_ID（gadag_root、max_block_id）"
    },
    {
      "indent": 13,
      "text": "Figure 13: Assigning Block-ID to Identify Blocks",
      "ja": "図13：ブロックを識別するためにブロック-IDを割り当てます"
    },
    {
      "indent": 0,
      "text": "5. MRT Lowpoint Algorithm Specification",
      "section_title": true,
      "ja": "5. MRT Lowpointアルゴリズムの仕様"
    },
    {
      "indent": 3,
      "text": "The MRT Lowpoint algorithm computes one GADAG that is then used by a router to determine its MRT-Blue and MRT-Red next hops to all destinations. Finally, based upon that information, alternates are selected for each next hop to each destination. The different parts of this algorithm are described below.",
      "ja": "MRT Lowpointアルゴリズムは、すべての宛先へのMRTブルーとMRT-レッドネクストホップを決定するためにルータが使用される1 GADAGを計算します。最後に、その情報に基づいて、交互には、各宛先への各次のホップのために選択されます。このアルゴリズムの異なる部分は、以下に記載されています。"
    },
    {
      "indent": 3,
      "text": "o Order the interfaces in the network graph. See Section 5.1.",
      "ja": "Oネットワークグラフのインターフェースを購入します。セクション5.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "o Compute the local MRT Island for the particular MRT Profile. See Section 5.2.",
      "ja": "O特定のMRTプロファイルのローカルMRT島を計算します。 5.2節を参照してください。"
    },
    {
      "indent": 3,
      "text": "o Select the root to use for the GADAG. See Section 5.3.",
      "ja": "O GADAGに使用するルートを選択します。 5.3節を参照してください。"
    },
    {
      "indent": 3,
      "text": "o Initialize all interfaces to UNDIRECTED. See Section 5.4.",
      "ja": "O無向にすべてのインターフェイスを初期化します。 5.4節を参照してください。"
    },
    {
      "indent": 3,
      "text": "o Compute the DFS value, e.g., D(x), and lowpoint value, L(x). See Figure 8.",
      "ja": "O DFS値、例えば、D（X）、及びlowpoint値、L（X）を計算します。図8を参照してください。"
    },
    {
      "indent": 3,
      "text": "o Construct the GADAG. See Section 5.5.",
      "ja": "O GADAGを構築します。 5.5節を参照してください。"
    },
    {
      "indent": 3,
      "text": "o Assign directions to all interfaces that are still UNDIRECTED. See Section 5.6.",
      "ja": "Oまだ無向ているすべてのインターフェイスに方向を割り当てます。 5.6節を参照してください。"
    },
    {
      "indent": 3,
      "text": "o From the computing router x, compute the next hops for the MRT-Blue and MRT-Red. See Section 5.7.",
      "ja": "Oコンピューティング・ルータXから、MRTブルーとMRT-レッドための次のホップを計算します。 5.7節を参照してください。"
    },
    {
      "indent": 3,
      "text": "o Identify alternates for each next hop to each destination by determining which one of the MRT-Blue and the MRT-Red the computing router x should select. See Section 5.8.",
      "ja": "O MRTブルーコンピューティングルータXは選択すべきであるMRTレッドのどちらを決定することにより、各宛先への各次のホップのために交互に識別する。 5.8節を参照してください。"
    },
    {
      "indent": 3,
      "text": "A Python implementation of this algorithm is given in Appendix A.",
      "ja": "このアルゴリズムのPython実装は、付録Aに記載されています"
    },
    {
      "indent": 0,
      "text": "5.1. Interface Ordering",
      "section_title": true,
      "ja": "5.1. インターフェイスの注文"
    },
    {
      "indent": 3,
      "text": "To ensure consistency in computation, all routers MUST order interfaces identically down to the set of links with the same metric to the same neighboring node. This is necessary for the DFS in Lowpoint_Visit in Section 4.3, where the selection order of the interfaces to explore results in different trees. Consistent interface ordering is also necessary for computing the GADAG, where the selection order of the interfaces to use to form ears can result in different GADAGs. It is also necessary for the topological sort described in Section 5.8, where different topological sort orderings can result in undirected links being added to the GADAG in different directions.",
      "ja": "計算の一貫性を確保するために、すべてのルータが同じ隣接ノードに同じメトリックとのリンクのセットに同じダウンインターフェースを注文しなければなりません。これは、インタフェースの選択順序が異なるツリーに結果を探索するセクション4.3でLowpoint_VisitでDFSのために必要です。一貫性のあるインタフェースの順序は、耳を形成するために使用するインターフェースの選択順序が異なるGADAGs生じ得るGADAGを計算するためにも必要です。これは、異なるトポロジカルソート順序が異なる方向にGADAGに追加される無向リンクをもたらすことができる、セクション5.8で説明トポロジカルソートのためにも必要です。"
    },
    {
      "indent": 3,
      "text": "The required ordering between two interfaces from the same router x is given in Figure 14.",
      "ja": "同じルータXからの二つのインタフェース間に必要な順序は、図14に示されています。"
    },
    {
      "indent": 6,
      "text": "Interface_Compare(interface a, interface b) if a.metric < b.metric return A_LESS_THAN_B if b.metric < a.metric return B_LESS_THAN_A if a.neighbor.mrt_node_id < b.neighbor.mrt_node_id return A_LESS_THAN_B if b.neighbor.mrt_node_id < a.neighbor.mrt_node_id return B_LESS_THAN_A // Same metric to same node, so the order doesn't matter for // interoperability. return A_EQUAL_TO_B",
      "ja": "a.metric <b.metric戻りA_LESS_THAN_B場合a.neighbor.mrt_node_id場合Interface_Compare b.neighbor.mrt_node_id <Aの場合<A_LESS_THAN_Bを返すb.neighbor.mrt_node_id b.metric <a.metric戻りB_LESS_THAN_A場合（インターフェースBをインタフェース）同じノードに//同じメトリックB_LESS_THAN_Aを返す.neighbor.mrt_node_id、そのためには、//相互運用性のために重要ではありません。 A_EQUAL_TO_B戻ります"
    },
    {
      "indent": 4,
      "text": "Figure 14: Rules for Ranking Multiple Interfaces (Order Is from Low to High)",
      "ja": "図14：複数のインターフェイスをランク付けするためのルール（注文がLowからHighにです）"
    },
    {
      "indent": 3,
      "text": "In Figure 14, if two interfaces on a router connect to the same remote router with the same metric, the Interface_Compare function returns A_EQUAL_TO_B. This is because the order in which those interfaces are initially explored does not affect the final GADAG produced by the algorithm described here. While only one of the links will be added to the GADAG in the initial traversal, the other parallel links will be added to the GADAG with the same direction assigned during the procedure for assigning direction to UNDIRECTED links described in Section 5.6. An implementation is free to apply some additional criteria to break ties in interface ordering in this situation, but those criteria are not specified here since they will not affect the final GADAG produced by the algorithm.",
      "ja": "ルータ上の2つのインターフェイスが同じメトリックと同一のリモートルータに接続する場合、図14に、Interface_Compare関数はA_EQUAL_TO_Bを返します。これらのインタフェースが最初に探索される順序は、ここに説明されたアルゴリズムによって生成される最終的なGADAGに影響を及ぼさないためです。リンクの一方のみが最初のトラバーサルにGADAGに追加されるが、他の平行リンクは、セクション5.6で説明無向リンクに方向を割り当てるための手順の間に割り当てられた同じ方向でGADAGに追加されます。実装は、このような状況ではインターフェイスの順序でネクタイを破るためにいくつかの追加の基準を適用することは自由ですが、彼らはアルゴリズムによって生成される最終GADAGには影響しませんので、これらの基準は、ここで指定されていません。"
    },
    {
      "indent": 3,
      "text": "The Interface_Compare function in Figure 14 relies on the interface.metric and the interface.neighbor.mrt_node_id values to order interfaces. The exact source of these values for different IGPs and applications is specified in Figure 15. The metric and mrt_node_id values for OSPFv2, OSPFv3, and IS-IS provided here is normative. The metric and mrt_node_id values for IS-IS Path Control and Reservation (PCR) in this table should be considered informational. The normative values are specified in [IEEE8021Qca].",
      "ja": "図14のInterface_Compare関数はインターフェースを注文するinterface.metricとinterface.neighbor.mrt_node_id値に依存しています。別のIGPとアプリケーションのためのこれらの値の正確なソースが図15のOSPFv2、OSPFv3のためのメトリックとmrt_node_id値で指定され、IS-ISここで提供規範的です。この表のIS-IS経路制御と予約（PCR）のメトリックとmrt_node_id値は情報を考慮すべきです。規範的な値は、[IEEE8021Qca]で指定されています。"
    },
    {
      "indent": 2,
      "text": "+--------------+-----------------------+-----------------------------+\n| IGP/flooding | mrt_node_id           | metric of                   |\n| protocol     | of neighbor           | interface                   |\n| and          | on interface          |                             |\n| application  |                       |                             |\n+--------------+-----------------------+-----------------------------+\n| OSPFv2 for   | 4-octet Neighbor      | 2-octet Metric field        |\n| IP/LDP FRR   | Router ID in          | for corresponding           |\n|              | Link ID field for     | point-to-point link         |\n|              | corresponding         | in Router-LSA               |\n|              | point-to-point link   |                             |\n|              | in Router-LSA         |                             |\n+--------------+-----------------------+-----------------------------+\n| OSPFv3 for   | 4-octet Neighbor      | 2-octet Metric field        |\n| IP/LDP FRR   | Router ID field       | for corresponding           |\n|              | for corresponding     | point-to-point link         |\n|              | point-to-point link   | in Router-LSA               |\n|              | in Router-LSA         |                             |\n+--------------+-----------------------+-----------------------------+\n| IS-IS for    | 7-octet neighbor      | 3-octet metric field        |\n| IP/LDP FRR   | system ID and         | in Extended IS              |\n|              | pseudonode number     | Reachability TLV (type 22)  |\n|              | in Extended IS        | or Multi-Topology           |\n|              | Reachability TLV (type| IS Neighbor TLV (type 222)  |\n|              | 22) or Multi-Topology |                             |\n|              | IS Neighbor TLV (type |                             |\n|              | 222)                  |                             |\n+--------------+-----------------------+-----------------------------+\n| IS-IS PCR for| 8-octet Bridge ID     | 3-octet SPB-LINK-METRIC in  |\n| protection   | created from  2-octet | SPB-Metric sub-TLV (type 29)|\n| of traffic   | Bridge Priority in    | in Extended IS Reachability |\n| in bridged   | Shortest Path Bridging| TLV (type 22) or            |\n|              |SPB Instance sub-TLV   | Multi-Topology              |\n| networks     | (type 1) carried in   | Intermediate Systems        |\n|              | MT-Capability TLV     | TLV (type 222).  In the case|\n|              | (type 144) and 6-octet| of asymmetric link metrics, |\n|              | neighbor system ID in | the larger link metric      |\n|              | Extended IS           | is used for both link       |\n|              | Reachability TLV (type| directions.                 |\n|              | 22) or Multi-Topology | (informational)             |\n|              | Intermediate Systems  |                             |\n|              | TLV (type 222)        |                             |\n|              | (informational)       |                             |\n+--------------+-----------------------+-----------------------------+",
      "raw": true
    },
    {
      "indent": 5,
      "text": " Figure 15: Value of interface.neighbor.mrt_node_id and interface.metric to Be Used for Ranking Interfaces, for Different Flooding Protocols and Applications",
      "ja": "図15：interface.neighbor.mrt_node_idの値と順位のインタフェースに使用するinterface.metric、さまざまなフラッディングプロトコルおよびアプリケーションのための"
    },
    {
      "indent": 3,
      "text": "The metrics are unsigned integers and MUST be compared as unsigned integers. The results of mrt_node_id comparisons MUST be the same as would be obtained by converting the mrt_node_ids to unsigned integers using network byte order and performing the comparison as unsigned integers. In the case of IS-IS for IP/LDP FRR with point-to-point links, the pseudonode number (the 7th octet) is zero. Broadcast interfaces will be discussed in Section 7.",
      "ja": "メトリックは、符号なし整数であり、符号なし整数として比較されなければなりません。 mrt_node_id比較の結果は、ネットワークバイト順を使用して符号なし整数にmrt_node_idsを変換し、符号なし整数として比較を行うことによって得られるであろうと同じでなければなりません。ポイントツーポイントリンクとIP / LDP FRR用のIS-ISの場合には、擬似番号（7オクテット）がゼロです。ブロードキャストインターフェースは、セクション7で説明します。"
    },
    {
      "indent": 0,
      "text": "5.2. MRT Island Identification",
      "section_title": true,
      "ja": "5.2.  MRT島の識別"
    },
    {
      "indent": 3,
      "text": "The local MRT Island for a particular MRT profile can be determined by starting from the computing router in the network graph and doing a breadth-first-search (BFS). The BFS explores only links that are in the same area/level, are not IGP-excluded, and are not MRT-ineligible. The BFS explores only nodes that support the particular MRT profile. See Section 7 of [RFC7812] for more-precise definitions of these criteria.",
      "ja": "特定のMRTプロファイルのローカルMRTアイランドは、ネットワークグラフ内のコンピューティング・ルータから開始し、幅優先探索（BFS）を行うことによって決定することができます。 BFSは、同じ領域/レベルにあるIGP-除外されていない、とMRT-不適格でないリンクのみを探ります。 BFSは、特定のMRTプロファイルをサポートするノードのみを探ります。これらの基準のより正確な定義のための[RFC7812]のセクション7を参照してください。"
    },
    {
      "indent": 3,
      "text": "MRT_Island_Identification(topology, computing_rtr, profile_id, area) for all routers in topology rtr.IN_MRT_ISLAND = FALSE computing_rtr.IN_MRT_ISLAND = TRUE explore_list = { computing_rtr } while (explore_list is not empty) next_rtr = remove_head(explore_list) for each intf in next_rtr if (not intf.IN_MRT_ISLAND and not intf.MRT-ineligible and not intf.remote_intf.MRT-ineligible and not intf.IGP-excluded and (intf in area) and (intf.remote_node supports profile_id) ) intf.IN_MRT_ISLAND = TRUE intf.remote_intf.IN_MRT_ISLAND = TRUE if (not intf.remote_node.IN_MRT_ISLAND)) intf.remote_node.IN_MRT_ISLAND = TRUE add_to_tail(explore_list, intf.remote_node)",
      "ja": "MRT_Island_Identificationでnext_rtr場合は、各INTFのトポロジrtr.IN_MRT_ISLAND = FALSE computing_rtr.IN_MRT_ISLAND（explore_listが空でない）しながら= TRUE explore_list = {computing_rtr} next_rtr = remove_head（explore_list）内のすべてのルータのための（トポロジー、computing_rtr、PROFILE_ID、面積）（ないとintf.remote_intf.MRT不適格ではないとintf.IGP除外しないと（面積でINTF）とintf.IN_MRT_ISLANDとしない不適格intf.MRT）はintf.IN_MRT_ISLAND = TRUE intf.remote_intf（intf.remote_nodeはPROFILE_ID対応します） .IN_MRT_ISLAND = TRUEであれば（ないintf.remote_node.IN_MRT_ISLAND））intf.remote_node.IN_MRT_ISLAND = TRUE add_to_tail（explore_list、intf.remote_node）"
    },
    {
      "indent": 19,
      "text": "Figure 16: MRT Island Identification",
      "ja": "図16：MRT島の同定"
    },
    {
      "indent": 0,
      "text": "5.3. GADAG Root Selection",
      "section_title": true,
      "ja": "5.3.  GADAGルートの選択"
    },
    {
      "indent": 3,
      "text": "In Section 8.3 of [RFC7812], the GADAG Root Selection Policy is described for the Default MRT Profile. This selection policy allows routers to consistently select a common GADAG Root inside the local MRT Island, based on advertised priority values. The MRT Lowpoint algorithm simply requires that all routers in the MRT Island MUST select the same GADAG Root; the mechanism can vary based upon the MRT profile description. Before beginning computation, the network graph is reduced to contain only the set of routers that support the specific MRT profile whose MRTs are being computed.",
      "ja": "[RFC7812]のセクション8.3では、GADAGルート選択ポリシーは、デフォルトのMRTのプロフィールに記載されています。この選択ポリシーは、ルータが一貫して広告を出して優先順位の値に基づいて、ローカルMRT島の内部で共通GADAGルートを選択することができます。 MRT Lowpointアルゴリズムは、単にMRT島のすべてのルータが同じGADAGルートを選択しなければならないことが必要です。機構は、MRTのプロファイルの説明に基づいて変化することができます。計算を開始する前に、ネットワークグラフは、MRTを計算されている特定のMRTプロファイルをサポートするルータのセットのみを含むように減少しています。"
    },
    {
      "indent": 3,
      "text": "As noted in Section 7, pseudonodes MUST NOT be considered for GADAG root selection.",
      "ja": "第7節で述べたように、擬似ノードはGADAGルート選択のために考慮されてはなりません。"
    },
    {
      "indent": 3,
      "text": "It is expected that an operator will designate a set of routers as good choices for selection as GADAG root by setting the GADAG Root Selection Priority for that set of routers to lower (more preferred) numerical values. For guidance on setting the GADAG Root Selection Priority values, refer to Section 9.1.",
      "ja": "オペレータが低い（より好ましい）の数値へのルータのセットについてGADAGルート選択の優先順位を設定することによりGADAGルートとして選択するための良好な選択肢としてルータのセットを指定することが期待されます。 GADAGルート選択の優先順位値の設定に関するガイダンスについては、9.1節を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.4. Initialization",
      "section_title": true,
      "ja": "5.4. 初期化"
    },
    {
      "indent": 3,
      "text": "Before running the algorithm, there is the standard type of initialization to be done, such as clearing any computed DFS-values, lowpoint-values, DFS parents, lowpoint-parents, any MRT-computed next hops, and flags associated with algorithm.",
      "ja": "アルゴリズムを実行する前に、そのような任意の計算されたDFS値をクリアするように、行われるべき初期の標準タイプがあり、lowpoint値は、DFSの親、lowpoint-親、任意MRT計算ネクストホップ、およびフラグは、アルゴリズムと関連します。"
    },
    {
      "indent": 3,
      "text": "It is assumed that a regular SPF computation has been run so that the primary next hops from the computing router to each destination are known. This is required for determining alternates at the last step.",
      "ja": "各宛先へのコンピューティング・ルータからの主なネクストホップが知られているように、通常のSPF計算が実行されているものとします。これが最後のステップで交互に決定するために必要とされます。"
    },
    {
      "indent": 3,
      "text": "Initially, all interfaces MUST be initialized to UNDIRECTED. Whether they are OUTGOING, INCOMING, or both is determined when the GADAG is constructed and augmented.",
      "ja": "最初は、すべてのインターフェイスは、無向に初期化する必要があります。彼らは、着信、OUTGOINGある、またはGADAGが構築され、拡張されたときの両方が決定されているかどうか。"
    },
    {
      "indent": 3,
      "text": "It is possible that some links and nodes will be marked using standard IGP mechanisms to discourage or prevent transit traffic. Section 7.3.1 of [RFC7812] describes how those links and nodes are excluded from MRT Island formation.",
      "ja": "いくつかのリンクやノードがトランジットトラフィックを阻止または予防するために、標準のIGPのメカニズムを使用してマークされる可能性があります。 [RFC7812]のセクション7.3.1には、これらのリンクやノードがMRT島の形成から除外されている方法を説明します。"
    },
    {
      "indent": 3,
      "text": "MRT-FRR also has the ability to advertise links MRT-Ineligible, as described in Section 7.3.2 of [RFC7812]. These links are excluded from the MRT Island and the GADAG. Computation of MRT next hops will therefore not use any MRT-ineligible links. The MRT Lowpoint algorithm does still need to consider MRT-ineligible links when computing FRR alternates, because an MRT-ineligible link can still be the shortest-path next hop to reach a destination.",
      "ja": "[RFC7812]のセクション7.3.2で説明したようにMRT-FRRはまた、リンクMRT-不適格を宣伝する能力を持っています。これらのリンクは、MRT島とGADAGから除外されています。 MRTの次のホップの計算は、したがって、すべてのMRT-不適格のリンクを使用しません。 FRR交互を計算するときにMRT-不適格リンクはまだ先に到達するためのネクストホップ最短パスすることができので、MRT Lowpointアルゴリズムは、まだ、MRT-不適格のリンクを考慮する必要がありません。"
    },
    {
      "indent": 3,
      "text": "When a broadcast interface is advertised as MRT-ineligible, then the pseudonode representing the entire broadcast network MUST NOT be included in the MRT Island. This is equivalent to excluding all of the broadcast interfaces on that broadcast network from the MRT Island.",
      "ja": "ブロードキャストインターフェースはMRT不適格として宣伝されている場合、次に全体ブロードキャストネットワークを表す擬似はMRT島に含まれてはいけません。これは、MRT島からのブロードキャストネットワーク上のブロードキャストインタフェースのすべてを除くと同等です。"
    },
    {
      "indent": 0,
      "text": "5.5. Constructing the GADAG Using Lowpoint Inheritance",
      "section_title": true,
      "ja": "5.5.  Lowpoint継承の使用GADAGの構築"
    },
    {
      "indent": 3,
      "text": "As discussed in Section 4.2, it is necessary to find ears from a node x that is already in the GADAG (known as IN_GADAG). Two different methods are used to find ears in the algorithm. The first is by going to a DFS-child that is not IN_GADAG and then following the chain of lowpoint parents until an IN_GADAG node is found. The second is by going to a neighbor that is not IN_GADAG and then following the chain of DFS parents until an IN_GADAG node is found. As an ear is found, the associated interfaces are marked based on the direction taken. The nodes in the ear are marked as IN_GADAG. In the algorithm, first the ears via DFS-children are found and then the ears via DFS-neighbors are found.",
      "ja": "セクション4.2で議論するように、GADAG（IN_GADAGとして知られる）に既にあるノードXから耳を見つける必要があります。二つの異なる方法は、アルゴリズムに耳を見つけるために使用されています。最初はIN_GADAG、その後IN_GADAGノードが見つかるまでlowpoint親のチェーンを次されていないDFS-子に行くことによってです。第二は、IN_GADAG、その後IN_GADAGノードが発見されるまで、DFSの親のチェーンを次されていない隣人に行くことによってです。耳が発見されたように、関連するインターフェースがとら方向に基づいて、マークされています。耳の中のノードはIN_GADAGとしてマークされています。このアルゴリズムでは、DFS-子供を介して第1の耳が発見され、その後、DFS-隣人を介した耳が発見されました。"
    },
    {
      "indent": 3,
      "text": "By adding both types of ears when an IN_GADAG node is processed, all ears that connect to that node are found. The order in which the IN_GADAG nodes are processed is, of course, key to the algorithm. The order is a stack of ears so the most recent ear is found at the top of the stack. Of course, the stack stores nodes and not ears, so an ordered list of nodes, from the first node in the ear to the last node in the ear, is created as the ear is explored and then that list is pushed onto the stack.",
      "ja": "IN_GADAGノードが処理される耳の両方のタイプを追加することにより、そのノードに接続するすべての耳が見出されます。 IN_GADAGノードが処理される順序は、もちろん、アルゴリズムの鍵です。最新の耳は、スタックの最上部で発見されるように順序は耳のスタックです。もちろん、スタックは、耳が探求されていると、そのリストがスタック上にプッシュされるように、耳内の最後のノードに耳の最初のノードから、作成され、ノードではなく、耳、ノードのように順序付けられたリストを記憶します。"
    },
    {
      "indent": 3,
      "text": "Each ear represents a partial order (see Figure 4) and processing the nodes in order along each ear ensures that all ears connecting to a node are found before a node higher in the partial order has its ears explored. This means that the direction of the links in the ear is always from the node x being processed towards the other end of the ear. Additionally, by using a stack of ears, this means that any unprocessed nodes in previous ears can only be ordered higher than nodes in the ears below it on the stack.",
      "ja": "各耳は、半順序（図4参照）、各耳がノードに接続する全ての耳は、その耳が探求しているより高い半順序ノードの前に発見されたことを確実に沿って順にノードの処理を表します。これは、耳内のリンクの方向は、耳の他方の端部に向かって処理されているノードXから常にあることを意味します。また、耳のスタックを使用することによって、これは前耳に未処理のノードが唯一のスタック上のその下の耳のノードよりも注文することができることを意味します。"
    },
    {
      "indent": 3,
      "text": "In this algorithm that depends upon Lowpoint inheritance, it is necessary that every node has a lowpoint parent that is not itself. If a node is a cut-vertex, that may not yet be the case. Therefore, any nodes without a lowpoint parent will have their lowpoint parent set to their DFS parent and their lowpoint value set to the DFS-value of their parent. This assignment also properly allows an ear between two cut-vertices.",
      "ja": "Lowpoint継承に依存し、このアルゴリズムでは、すべてのノードは、それ自体ではないlowpoint親を持っていることが必要です。ノードがカット頂点である場合、それはまだそうでなくてもよいです。したがって、lowpoint親なしの任意のノードが、それらのlowpoint親が彼らのDFSの親とその親のDFS値に設定され、そのlowpoint値に設定されます。この割り当ては、また、適切に2つの切断、頂点間耳を可能にします。"
    },
    {
      "indent": 3,
      "text": "Finally, the algorithm simultaneously computes each node's localroot, as described in Figure 12. This is further elaborated as follows. The localroot can be inherited from the node at the end of the ear unless the end of the ear is x itself, in which case the localroot for all the nodes in the ear would be x. This is because whenever the first cycle is found in a block, or an ear involving a bridge is computed, the cut-vertex closest to the root would be x itself. In all other scenarios, the properties of lowpoint/dfs parents ensure that the end of the ear will be in the same block, and thus inheriting its localroot would be the correct localroot for all newly added nodes.",
      "ja": "次のようにこれをさらに詳述される図12で説明したように最後に、アルゴリズムは、同時に、各ノードのlocalrootを計算します。耳の端部が耳内のすべてのノードのlocalrootがXであると思われる場合には、X自身でない限りlocalrootは、耳の端のノードから継承することができます。最初のサイクルは、ブロックに見出される、またはブリッジを伴う耳が計算されるたびに、ルートに最も近いカット頂点はx自身であろうからです。他のすべてのシナリオで、lowpoint / DFSの親の特性は、耳の端部が同じブロックになり、したがってそのlocalrootを継承すると、すべての新しく追加されたノードの正しいlocalrootであろうことを保証します。"
    },
    {
      "indent": 3,
      "text": "The pseudocode for the GADAG algorithm (assuming that the adjustment of lowpoint for cut-vertices has been made) is shown in Figure 17.",
      "ja": "（カット頂点のlowpointの調整がなされたと仮定して）GADAGアルゴリズムの擬似コードは、図17に示されています。"
    },
    {
      "indent": 11,
      "text": "Construct_Ear(x, Stack, intf, ear_type)\n   ear_list = empty\n   cur_node = intf.remote_node\n   cur_intf = intf\n   not_done = true",
      "raw": true
    },
    {
      "indent": 14,
      "text": "while not_done cur_intf.UNDIRECTED = false cur_intf.OUTGOING = true cur_intf.remote_intf.UNDIRECTED = false cur_intf.remote_intf.INCOMING = true",
      "ja": "cur_intf.UNDIRECTED = falseをcur_intf.OUTGOING =真cur_intf.remote_intf.UNDIRECTED = falseのcur_intf.remote_intf.INCOMING not_done =真しばらく"
    },
    {
      "indent": 17,
      "text": "if cur_node.IN_GADAG is false cur_node.IN_GADAG = true add_to_list_end(ear_list, cur_node) if ear_type is CHILD cur_intf = cur_node.lowpoint_parent_intf cur_node = cur_node.lowpoint_parent else // ear_type must be NEIGHBOR cur_intf = cur_node.dfs_parent_intf cur_node = cur_node.dfs_parent else not_done = false",
      "ja": "cur_node.IN_GADAGが偽cur_node.IN_GADAG =真add_to_list_end（ear_list、cur_node）であればear_typeが子供である場合cur_intf = cur_node.lowpoint_parent_intf cur_node = cur_node.lowpoint_parent他に// ear_typeはNEIGHBOR cur_intf = cur_node.dfs_parent_intf cur_node = cur_node.dfs_parent他not_doneでなければなりません=偽"
    },
    {
      "indent": 14,
      "text": "if (ear_type is CHILD) and (cur_node is x) // x is a cut-vertex and the local root for // the block in which the ear is computed x.IS_CUT_VERTEX = true localroot = x else // Inherit localroot from the end of the ear localroot = cur_node.localroot while ear_list is not empty y = remove_end_item_from_list(ear_list) y.localroot = localroot push(Stack, y)",
      "ja": "（ear_typeが子供である）、および場合（cur_nodeであるX）// Xカット頂点と耳をx.IS_CUT_VERTEX =真localrootを計算したブロック= X他//継承localrootから//のローカルルートであります耳localrootの端= cur_node.localroot ear_listが空でない間Y = remove_end_item_from_list（ear_list）y.localroot = localrootプッシュ（スタック、Y）"
    },
    {
      "indent": 11,
      "text": "Construct_GADAG_via_Lowpoint(topology, gadag_root) gadag_root.IN_GADAG = true gadag_root.localroot = None Initialize Stack to empty push gadag_root onto Stack while (Stack is not empty) x = pop(Stack) foreach ordered_interface intf of x if ((intf.remote_node.IN_GADAG == false) and (intf.remote_node.dfs_parent is x)) Construct_Ear(x, Stack, intf, CHILD) foreach ordered_interface intf of x if ((intf.remote_node.IN_GADAG == false) and (intf.remote_node.dfs_parent is not x)) Construct_Ear(x, Stack, intf, NEIGHBOR)",
      "ja": "Construct_GADAG_via_Lowpoint（（intf.remote_node.IN_GADAG場合、XのINTF（スタックが空ではない）、X = POP（スタック）のforeach ordered_interfaceながらスタック上にプッシュgadag_rootを空に（トポロジー、gadag_root）gadag_root.IN_GADAG =真gadag_root.localroot =なし初期化スタック==偽）および（偽（（intf.remote_node.IN_GADAG ==場合intf.remote_node.dfs_parentはxのx））をConstruct_Ear（X、スタック、INTF、CHILD）のforeach ordered_interfaceのINTFである）および（intf.remote_node.dfs_parentでありますないx））をConstruct_Ear（X、スタック、INTF、NEIGHBOR）"
    },
    {
      "indent": 11,
      "text": "Construct_GADAG_via_Lowpoint(topology, gadag_root)",
      "ja": "Construct_GADAG_via_Lowpoint（トポロジー、gadag_root）"
    },
    {
      "indent": 14,
      "text": "Figure 17: Lowpoint Inheritance GADAG Algorithm",
      "ja": "図17：Lowpoint継承GADAGアルゴリズム"
    },
    {
      "indent": 0,
      "text": "5.6. Augmenting the GADAG by Directing All Links",
      "section_title": true,
      "ja": "5.6. すべてのリンクを向けることによってGADAGの拡張"
    },
    {
      "indent": 3,
      "text": "The GADAG, regardless of the method used to construct it, at this point could be used to find MRTs, but the topology does not include all links in the network graph. That has two impacts. First, there might be shorter paths that respect the GADAG partial ordering and so the alternate paths would not be as short as possible. Second, there may be additional paths between a router x and the root that are not included in the GADAG. Including those provides potentially more bandwidth to traffic flowing on the alternates and may reduce congestion compared to just using the GADAG as currently constructed.",
      "ja": "GADAGは、関係なく、それを構築するために使用される方法の、この時点でのMRTを見つけるために使用することができますが、トポロジーは、ネットワークグラフ内のすべてのリンクが含まれていません。すなわち、2つの影響があります。まず、GADAG半順序を尊重短いパスがあるかもしれないので、代替パスはできるだけ短くしないでしょう。第二に、ルータXとGADAGに含まれていないルートの間に追加の経路が存在してもよいです。それらが交互に流れるトラフィックに対して潜在的に多くの帯域幅を提供し、現在のように構成されたばかりGADAGを使用する場合と比較して渋滞を減らすことを含みます。"
    },
    {
      "indent": 3,
      "text": "The goal is thus to assign direction to every remaining link marked as UNDIRECTED to improve the paths and number of paths found when the MRTs are computed.",
      "ja": "目標は、パスとのMRTが計算されるときに見つかったパスの数を向上させるために無向としてマークされたすべての残りのリンクの方向を割り当てることです。"
    },
    {
      "indent": 3,
      "text": "To do this, we need to establish a total order that respects the partial order described by the GADAG. This can be done using Kahn's topological sort [Kahn_1962_topo_sort], which essentially assigns a number to a node x only after all nodes before it (e.g., with a link incoming to x) have had their numbers assigned. The only issue with the topological sort is that it works on DAGs and not ADAGs or GADAGs.",
      "ja": "これを行うために、我々はGADAGによって記述部分的順序を尊重全順序を確立する必要があります。これは、それらの番号が割り当てあった本質的に（xに到来リンクと、例えば）だけ前に、すべてのノードの後のノードxに番号を割り当て、カーンのトポロジカルソート[Kahn_1962_topo_sort]を用いて行うことができます。トポロジカルソートの唯一の問題は、それがDAGはなくADAGsまたはGADAGs上で動作することです。"
    },
    {
      "indent": 3,
      "text": "To convert a GADAG to a DAG, it is necessary to remove all links that point to a root of block from within that block. That provides the necessary conversion to a DAG and then a topological sort can be done. When adding undirected links to the GADAG, links connecting the block root to other nodes in that block need special handling because the topological order will not always give the right answer for those links. There are three cases to consider. If the undirected link in question has another parallel link between the same two nodes that is already directed, then the direction of the undirected link can be inherited from the previously directed link. In the case of parallel cut links, we set all of the parallel links to both INCOMING and OUTGOING. Otherwise, the undirected link in question is set to OUTGOING from the block root node. A cut-link can then be identified by the fact that it will be directed both INCOMING and OUTGOING in the GADAG. The exact details of this whole process are captured in Figure 18.",
      "ja": "DAGにGADAGを変換するには、そのブロック内からのブロックのルートを指すすべてのリンクを削除する必要があります。すなわち、DAGへの必要な変換を提供し、その後、トポロジカルソートを行うことができます。 GADAGへの無向リンクを追加するとトポロジカル順序は、常にこれらのリンクのために正しい答えを与えることはありませんので、そのブロック内の他のノードへのブロックのルートを接続するリンクは、特別な処理を必要とします。考慮すべき3つのケースがあります。問題の無向リンクが既に向けられている同じ2つのノード間の別の平行リンクがある場合、無向リンクの方向が以前に有向リンクから継承することができます。パラレルカットリンクのケースでは、着信と発信の両方に平行なすべてのリンクを設定します。そうでない場合は、問題の無向リンクはブロックルートノードからの発信に設定されています。カットリンクは、それがGADAGに着信と発信の両方向けられるであろうという事実によって識別することができます。このプロセス全体の正確な詳細は、図18に捕捉されます。"
    },
    {
      "indent": 5,
      "text": "Add_Undirected_Block_Root_Links(topo, gadag_root) foreach node x in topo if x.IS_CUT_VERTEX or x is gadag_root foreach interface i of x if (i.remote_node.localroot is not x or i.PROCESSED ) continue Initialize bundle_list to empty bundle.UNDIRECTED = true bundle.OUTGOING = false bundle.INCOMING = false foreach interface i2 in x if i2.remote_node is i.remote_node add_to_list_end(bundle_list, i2) if not i2.UNDIRECTED: bundle.UNDIRECTED = false if i2.INCOMING: bundle.INCOMING = true if i2.OUTGOING: bundle.OUTGOING = true if bundle.UNDIRECTED foreach interface i3 in bundle_list i3.UNDIRECTED = false i3.remote_intf.UNDIRECTED = false i3.PROCESSED = true i3.remote_intf.PROCESSED = true i3.OUTGOING = true i3.remote_intf.INCOMING = true else if (bundle.OUTGOING and bundle.INCOMING) foreach interface i3 in bundle_list i3.UNDIRECTED = false i3.remote_intf.UNDIRECTED = false i3.PROCESSED = true i3.remote_intf.PROCESSED = true i3.OUTGOING = true i3.INCOMING = true i3.remote_intf.INCOMING = true i3.remote_intf.OUTGOING = true",
      "ja": "TOPOにAdd_Undirected_Block_Root_Links（TOPO、gadag_root）foreachのノードX（i.remote_node.localrootがxまたはi.PROCESSEDない）場合x.IS_CUT_VERTEXまたはxがxのI gadag_root foreachのインタフェースである場合bundle.UNDIRECTED =真束を空に初期化bundle_listを続行.OUTGOING Xの=偽bundle.INCOMING =偽のforeachインターフェースI2 i2.remote_nodeがi2.UNDIRECTEDない場合i.remote_node add_to_list_end（bundle_list、I2）の場合：bundle.UNDIRECTED = FALSE i2.INCOMING場合：bundle.INCOMING = trueの場合i2.OUTGOING：bundle.OUTGOING = trueの場合bundle_listでbundle.UNDIRECTEDのforeachのインタフェースi3はi3.UNDIRECTED = falseをi3.remote_intf.UNDIRECTED = falseをi3.PROCESSED =真i3.remote_intf.PROCESSED =真i3.OUTGOING =真i3.remote_intf .INCOMING =それ以外の場合はtrue（bundle.OUTGOINGとbundle.INCOMING）bundle_listでforeachのインタフェースi3はi3.UNDIRECTED = falseをi3.remote_intf.UNDIRECTED = falseをi3.PROCESSED =真i3.remote_intf.PROCESSED =真i3.OUTGOING =真I3 .INCOMING =真i3.remote_intf.INCOMING =真I3 .remote_intf.OUTGOING =真"
    },
    {
      "indent": 25,
      "text": "else if bundle.OUTGOING\n    foreach interface i3 in bundle_list\n        i3.UNDIRECTED = false\n        i3.remote_intf.UNDIRECTED = false\n        i3.PROCESSED = true\n        i3.remote_intf.PROCESSED = true\n        i3.OUTGOING = true\n        i3.remote_intf.INCOMING = true\nelse if bundle.INCOMING\n    foreach interface i3 in bundle_list\n        i3.UNDIRECTED = false\n        i3.remote_intf.UNDIRECTED = false\n        i3.PROCESSED = true\n        i3.remote_intf.PROCESSED = true\n        i3.INCOMING = true\n        i3.remote_intf.OUTGOING = true",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Modify_Block_Root_Incoming_Links(topo, gadag_root) foreach node x in topo if x.IS_CUT_VERTEX or x is gadag_root foreach interface i of x if i.remote_node.localroot is x if i.INCOMING: i.INCOMING = false i.INCOMING_STORED = true i.remote_intf.OUTGOING = false i.remote_intf.OUTGOING_STORED = true",
      "ja": "TOPOにModify_Block_Root_Incoming_Links（TOPO、gadag_root）foreachのノードX i.INCOMING場合i.remote_node.localrootがXである場合x.IS_CUT_VERTEXまたはxがxのI gadag_root foreachのインタフェースである場合：i.INCOMING = FALSE i.INCOMING_STORED = TRUE i.remote_intf .OUTGOING = falseをi.remote_intf.OUTGOING_STORED =真"
    },
    {
      "indent": 5,
      "text": "Revert_Block_Root_Incoming_Links(topo, gadag_root) foreach node x in topo if x.IS_CUT_VERTEX or x is gadag_root foreach interface i of x if i.remote_node.localroot is x if i.INCOMING_STORED i.INCOMING = true i.remote_intf.OUTGOING = true i.INCOMING_STORED = false i.remote_intf.OUTGOING_STORED = false",
      "ja": "TOPOにRevert_Block_Root_Incoming_Links（TOPO、gadag_root）foreachのノードX i.INCOMING_STORED i.INCOMING = trueをi.remote_intf.OUTGOING = trueの場合i.remote_node.localroot iはXである場合x.IS_CUT_VERTEXまたはxがxのI gadag_root foreachのインタフェースである場合。 INCOMING_STORED = falseをi.remote_intf.OUTGOING_STORED =偽"
    },
    {
      "indent": 5,
      "text": "Run_Topological_Sort_GADAG(topo, gadag_root) Modify_Block_Root_Incoming_Links(topo, gadag_root) foreach node x in topo node.unvisited = 0 foreach interface i of x if (i.INCOMING) node.unvisited += 1 Initialize working_list to empty Initialize topo_order_list to empty add_to_list_end(working_list, gadag_root) while working_list is not empty y = remove_start_item_from_list(working_list) add_to_list_end(topo_order_list, y) foreach ordered_interface i of y if intf.OUTGOING i.remote_node.unvisited -= 1 if i.remote_node.unvisited is 0 add_to_list_end(working_list, i.remote_node) next_topo_order = 1 while topo_order_list is not empty y = remove_start_item_from_list(topo_order_list) y.topo_order = next_topo_order next_topo_order += 1 Revert_Block_Root_Incoming_Links(topo, gadag_root)",
      "ja": "Run_Topological_Sort_GADAG（TOPO、gadag_root）Modify_Block_Root_Incoming_Links（TOPO、gadag_root）xのforeachのノードXにおけるトポnode.unvisited = 0のforeachインターフェースiは（i.INCOMING）が空add_to_list_endにtopo_order_listを初期化空にする+ = 1初期化working_listをnode.unvisited場合（working_list 、gadag_root）intf.OUTGOINGがi.remote_node.unvisited場合working_listはYのI空Y = remove_start_item_from_list（working_list）add_to_list_end（topo_order_list、Y）のforeach ordered_interfaceないが -  = 1 i.remote_node.unvisited場合は0 add_to_list_end（working_list、iは.remote_node）next_topo_order = 1 topo_order_listが空でない間Y = remove_start_item_from_list（topo_order_list）y.topo_order = next_topo_order next_topo_order + = 1 Revert_Block_Root_Incoming_Links（TOPO、gadag_root）"
    },
    {
      "indent": 5,
      "text": "def Set_Other_Undirected_Links_Based_On_Topo_Order(topo) foreach node x in topo foreach interface i of x if i.UNDIRECTED: if x.topo_order < i.remote_node.topo_order i.OUTGOING = true i.UNDIRECTED = false i.remote_intf.INCOMING = true i.remote_intf.UNDIRECTED = false else i.INCOMING = true i.UNDIRECTED = false i.remote_intf.OUTGOING = true i.remote_intf.UNDIRECTED = false",
      "ja": "デフSet_Other_Undirected_Links_Based_On_Topo_Order（TOPO）foreachのノードxのトポforeachのインターフェースI Xの場合i.UNDIRECTED：もしx.topo_order <i.remote_node.topo_order i.OUTGOING =真i.UNDIRECTED = FALSE i.remote_intf.INCOMING = TRUE i.remote_intf .UNDIRECTED = falseの他i.INCOMING =真i.UNDIRECTED = falseをi.remote_intf.OUTGOING =真i.remote_intf.UNDIRECTED =偽"
    },
    {
      "indent": 5,
      "text": "Add_Undirected_Links(topo, gadag_root) Add_Undirected_Block_Root_Links(topo, gadag_root) Run_Topological_Sort_GADAG(topo, gadag_root) Set_Other_Undirected_Links_Based_On_Topo_Order(topo)",
      "ja": "Add_Undirected_Links（TOPO、gadag_root）Add_Undirected_Block_Root_Links（TOPO、gadag_root）Run_Topological_Sort_GADAG（TOPO、gadag_root）Set_Other_Undirected_Links_Based_On_Topo_Order（TOPO）"
    },
    {
      "indent": 5,
      "text": "Add_Undirected_Links(topo, gadag_root)",
      "ja": "Adundirektdlinks（帽子、gadagrut）"
    },
    {
      "indent": 12,
      "text": "Figure 18: Assigning Direction to UNDIRECTED Links",
      "ja": "図18：無向リンクに割り当てる方向"
    },
    {
      "indent": 3,
      "text": "Proxy-nodes do not need to be added to the network graph. They cannot be transited and do not affect the MRTs that are computed. The details of how the MRT-Blue and MRT-Red next hops are computed for proxy-nodes and how the appropriate alternate next hops are selected is given in Section 5.9.",
      "ja": "プロキシノードは、ネットワークグラフに追加する必要はありません。彼らは、遷移することができないと計算されているのMRTに影響を与えません。 MRTブルー及びMRTレッド次のホップがプロキシノードとどのように適切な代替の次のホップを選択し、セクション5.9に記載されているために計算される方法の詳細。"
    },
    {
      "indent": 0,
      "text": "5.7. Compute MRT Next Hops",
      "section_title": true,
      "ja": "5.7. 計算MRTネクストホップ"
    },
    {
      "indent": 3,
      "text": "As was discussed in Section 4.1, once an ADAG is found, it is straightforward to find the next hops from any node X to the ADAG root. However, in this algorithm, we will reuse the common GADAG and find not only the one pair of MRTs rooted at the GADAG root with it, but find a pair rooted at each node. This is useful since it is significantly faster to compute.",
      "ja": "4.1節で説明したようにADAGが発見されると、ADAGルートに任意のノードXからの次のホップを見つけることは簡単です。しかし、このアルゴリズムでは、我々は共通GADAGを再利用していないだけで、それをGADAGルートをルートのMRTの1ペアを見つけるが、各ノードをルートペアを見つけるでしょう。計算が非常に高速であるので、これは便利です。"
    },
    {
      "indent": 3,
      "text": "The method for computing differently rooted MRTs from the common GADAG is based on two ideas. First, if two nodes X and Y are ordered with respect to each other in the partial order, then an SPF along OUTGOING links (an increasing-SPF) and an SPF along INCOMING links (a decreasing-SPF) can be used to find the increasing and decreasing paths. Second, if two nodes X and Y aren't ordered with respect to each other in the partial order, then intermediary nodes can be used to create the paths by increasing/decreasing to the intermediary and then decreasing/increasing to reach Y.",
      "ja": "共通GADAGは異なる根付いのMRTを計算するための方法は、二つの考え方に基づいています。最初の2つのノードX及びYは、発信リンクに沿ってSPF（増加-SPF）を、半順序で互いに対して順序付けされ、着信リンク（減少-SPF）に沿ったSPFは見つけるために使用することができ、場合にパスを増減。二つのノードX及びYは、半順序で互いに対して順序付けされていない場合には、第2、次いで中間ノードは、Yに到達するために増加/中間に減少/増加し、その後減少させることによって、パスを作成するために使用することができ"
    },
    {
      "indent": 3,
      "text": "As usual, the two basic ideas will be discussed assuming the network is 2-connected. The generalization to multiple blocks is discussed in Section 5.7.4. The full algorithm is given in Section 5.7.5.",
      "ja": "いつものように、2つの基本的なアイデアは、ネットワーク2に接続されていると仮定して説明します。複数のブロックへの一般化は、セクション5.7.4で説明されています。完全なアルゴリズムは、セクション5.7.5に記載されています。"
    },
    {
      "indent": 0,
      "text": "5.7.1. MRT Next Hops to All Nodes Ordered with Respect to the Computing Node",
      "ja": "5.7.1.  MRT次は、計算ノードに対して順序付けすべてのノードまでのホップ"
    },
    {
      "indent": 3,
      "text": "Finding two node-disjoint paths from the computing router X to any node Y depends upon whether Y>>X or Y<<X. As shown in Figure 19, if Y>>X, then there is an increasing path that goes from X to Y without crossing R; this contains nodes in the interval [X,Y]. There is also a decreasing path that decreases towards R and then decreases from R to Y; this contains nodes in the interval [X,R-small] or [R-great,Y]. The two paths cannot have common nodes other than X and Y.",
      "ja": "Yは、Y >> XまたはYか<< Xに依存する任意のノードに計算ルータXからの二つのノードディスジョイントパスを見つけます。図19に示すように、Y >> X場合、次にRと交差することなく、XからYへ移行増加パスがあります。これは、区間[X、Y]のノードを含んでいます。 Rに向かって減少し、次いでRからYに低下減少パスもあります。これは、[X、R小]または[R-大きな、Y]間隔でノードを含みます。 2つの経路がXおよびY以外の共通のノードを持つことができません"
    },
    {
      "indent": 19,
      "text": "  [Y]<---(Cloud 2)<--- [X]\n   |                    ^\n   |                    |\n   V                    |\n(Cloud 3)--->[R]--->(Cloud 1)",
      "raw": true
    },
    {
      "indent": 18,
      "text": "MRT-Blue path: X->Cloud 2->Y MRT-Red path: X->Cloud 1->R->Cloud 3->Y",
      "ja": "MRTブルーパス：X->クラウド2-> Y MRTレッドパス：X->クラウド1-> R->クラウド3-> Y"
    },
    {
      "indent": 30,
      "text": "Figure 19: Y>>X",
      "ja": "図19：Y >> X"
    },
    {
      "indent": 3,
      "text": "Similar logic applies if Y<<X, as shown in Figure 20. In this case, the increasing path from X increases to R and then increases from R to Y to use nodes in the intervals [X,R-great] and [R-small, Y]. The decreasing path from X reaches Y without crossing R and uses nodes in the interval [Y,X].",
      "ja": "Y次いで<< X、この場合、図20に示すように、RのX増加から増加経路及び間隔でノードを使用するYとRから増加する[X、R-大きな]及び[R場合にも、同様の論理が適用されます-small、Y]。 Xから減少経路はRと交差することなく、Yに達し、区間[Y、X]内のノードを使用します。"
    },
    {
      "indent": 18,
      "text": "  [X]<---(Cloud 2)<--- [Y]\n   |                    ^\n   |                    |\n   V                    |\n(Cloud 3)--->[R]--->(Cloud 1)",
      "raw": true
    },
    {
      "indent": 17,
      "text": "MRT-Blue path: X->Cloud 3->R->Cloud 1->Y MRT-Red path: X->Cloud 2->Y",
      "ja": "MRTブルー経路：3-> R->クラウド1- X->クラウド> Y MRTレッドパス：X->クラウド2-> Y"
    },
    {
      "indent": 30,
      "text": "Figure 20: Y<<X",
      "ja": "図20：Y << X"
    },
    {
      "indent": 0,
      "text": "5.7.2. MRT Next Hops to All Nodes Not Ordered with Respect to the Computing Node",
      "ja": "5.7.2.  MRT次は、計算ノードに対して順序付けされないすべてのノードまでのホップ"
    },
    {
      "indent": 3,
      "text": "When X and Y are not ordered, the first path should increase until we get to a node G, where G>>Y. At G, we need to decrease to Y. The other path should be just the opposite: we must decrease until we get to a node H, where H<<Y, and then increase. Since R is smaller and greater than Y, such G and H must exist. It is also easy to see that these two paths must be node disjoint: the first path contains nodes in interval [X,G] and [Y,G], while the second path contains nodes in interval [H,X] and [H,Y]. This is illustrated in Figure 21. It is necessary to decrease and then increase for the MRT-Blue and increase and then decrease for the MRT-Red; if one simply increased for one and decreased for the other, then both paths would go through the root R.",
      "ja": "XとYが発注されていない場合は、我々はノードG、G >> Yに到達するまで、最初のパスが増加するはずです。 Gで、我々は他のパスはちょうど反対のことをする必要がありYに減少する必要があります：私たちはH << Yが、その後増加ノードH、に到達するまで、我々は減少しなければなりません。 RはYより小さいと大きいので、そのようなGおよびHが存在しなければなりません。最初の経路は区間[X、G]のノードが含まれており、[Y、G]、第二の経路は区間[H、X]及び[Hのノードを含むが：これらの2つのパスがノード互いに素でなければならないことを確認することも容易です、Y]。これは、減少した後、MRTブルーため増加し、増加した後、MRT-赤小さくする必要がある図21に示されています。 1は、単にいずれかに増加し、他のために減少した場合には、両方のパスはルートRを介して行くだろう"
    },
    {
      "indent": 17,
      "text": "(Cloud 6)<---[Y]<---(Cloud 5)<------------|\n  |                                       |\n  |                                       |\n  V                                       |\n [G]--->(Cloud 4)--->[R]--->(Cloud 1)--->[H]\n  ^                                       |\n  |                                       |\n  |                                       |\n (Cloud 3)<---[X]<---(Cloud 2)<-----------|",
      "raw": true
    },
    {
      "indent": 14,
      "text": "MRT-Blue path: decrease to H and increase to Y X->Cloud 2->H->Cloud 5->Y MRT-Red path: increase to G and decrease to Y X->Cloud 3->G->Cloud 6->Y",
      "ja": "MRTブルーパス：Hに減少し、2-> H->クラウド5> Y MRTレッドパスY X->クラウドへの増加：Gの増加及びY X->クラウド3-> G->クラウドへ減少6-> Y"
    },
    {
      "indent": 23,
      "text": "Figure 21: X and Y Unordered",
      "ja": "図21：XとY順不同"
    },
    {
      "indent": 3,
      "text": "This gives disjoint paths as long as G and H are not the same node. Since G>>Y and H<<Y, if G and H could be the same node, that would have to be the root R. This is not possible because there is only one incoming interface to the root R that is created when the initial cycle is found. Recall from Figure 6 that whenever an ear was found to have an end that was the root R, the ear was directed from R so that the associated interface on R is outgoing and not incoming. Therefore, there must be exactly one node M that is the largest one before R, so the MRT-Red path will never reach R; it will turn at M and decrease to Y.",
      "ja": "これは、長いG及びHは、同じノードでないようにばらばらの経路を与えます。 G及びHは、同じノードであることができればG >> Y及びH << Yので、それをルートR.でなければならないであろう作成されたルートRにのみ1つの着信インタフェースがあるので、これは不可能です最初のサイクルが発見されました。耳がルートRであった端部を有することが判明したときはいつでもRに関連したインタフェースは、発信及び着信ないように、耳がRから指示されたことが図6からリコール。したがって、Rの前に最大のものであるので、MRTレッドパスがRに到達することはありません正確に一つのノードMが存在しなければなりません。それはMで回転し、Yに減少します"
    },
    {
      "indent": 0,
      "text": "5.7.3. Computing Redundant Tree Next Hops in a 2-Connected Graph",
      "section_title": true,
      "ja": "5.7.3.  2  - 連結グラフで冗長ツリーネクストホップを計算"
    },
    {
      "indent": 3,
      "text": "The basic ideas for computing RT next hops in a 2-connected graph were given in Sections 5.7.1 and 5.7.2. Given these two ideas, how can we find the trees?",
      "ja": "RT 2  - 連結グラフ内の次のホップを計算するための基本的な考え方は、セクション5.7.1及び5.7.2で与えました。これら二つのアイデアを考えると、どのように私たちは木を見つけることができますか？"
    },
    {
      "indent": 3,
      "text": "If some node X only wants to find the next hops (which is usually the case for IP networks), it is enough to find which nodes are greater and less than X, and which are not ordered; this can be done by running an increasing-SPF and a decreasing-SPF rooted at X and not exploring any links from the ADAG root.",
      "ja": "いくつかのノードはXのみ（通常、IPネットワーク用のケースです）、次のホップを見つけたい場合は、ノードがXより大きく、小さく、そしてどのが注文されていない見つけるために十分です。これは増加-SPFおよびXを根減少-SPFを実行し、ADAGのルートからのリンクを探索しないことによって行うことができます。"
    },
    {
      "indent": 3,
      "text": "In principle, a traversal method other than SPF could be used to traverse the GADAG in the process of determining blue and red next hops that result in maximally redundant trees. This will be the case as long as one traversal uses the links in the direction specified by the GADAG and the other traversal uses the links in the direction opposite of that specified by the GADAG. However, a different traversal algorithm will generally result in different blue and red next hops. Therefore, the algorithm specified here requires the use of SPF to traverse the GADAG to generate MRT blue and red next hops, as described below.",
      "ja": "原則的に、SPF以外のトラバーサル方法は、最大限の冗長木をもたらす青と赤の次のホップを決定する過程でGADAGを横断するために使用することができます。これは、長いものトラバーサルがGADAGによって指定された方向のリンクを使用し、他のトラバーサルがGADAGによって指定された方向と反対のリンクを使用するようにする場合であろう。しかし、異なるトラバーサルアルゴリズムは、一般に、異なる青と赤の次のホップをもたらすであろう。したがって、ここで指定されたアルゴリズムは、以下に説明するように、MRT青と赤の次のホップを生成するGADAGを横断するSPFの使用を必要とします。"
    },
    {
      "indent": 3,
      "text": "An increasing-SPF rooted at X and not exploring links from the root will find the increasing next hops to all Y>>X. Those increasing next hops are X's next hops on the MRT-Blue to reach Y. A decreasing-SPF rooted at X and not exploring links from the root will find the decreasing next hops to all Z<<X. Those decreasing next hops are X's next hops on the MRT-Red to reach Z. Since the root R is both greater than and less than X, after this increasing-SPF and decreasing-SPF, X's next hops on the MRT-Blue and on the MRT-Red to reach R are known. For every node Y>>X, X's next hops on the MRT-Red to reach Y are set to those on the MRT-Red to reach R. For every node Z<<X, X's next hops on the MRT-Blue to reach Z are set to those on the MRT-Blue to reach R.",
      "ja": "増加-SPFは、Xを根と根からのリンクを探索していないが、すべてのY >> Xに増加し、次のホップを見つけます。次のホップを増やすものがY. Aの減少-SPFは、Xを根と根からのリンクを探索しませ到達するMRTブルーのXの次のホップであるすべてのZ << Xに減少し、次のホップを見つけます。ルートRが、これは、SPFを高め、-SPFを減少した後に、より大きく、X未満でもあるので、次のホップを下げるものは、Z.に到達するためにXの次のホップMRTブルーおよびオンMRTレッドのXの次のホップですMRT-赤Rに到達することが知られています。すべてのノードY >> Xの場合は、MRT-赤のXの次のホップは、すべてのノードZ << XについてR.に到達するためにMRTレッド上のものに設定されているYに到達するために、MRTブルーのXの次のホップが到達しますZはR.に到達するためにMRTブルー上のものに設定されています"
    },
    {
      "indent": 3,
      "text": "For those nodes that were not reached by either the increasing-SPF or the decreasing-SPF, we can determine the next hops as well. The increasing MRT-Blue next hop for a node that is not ordered with respect to X is the next hop along the decreasing MRT-Red towards R, and the decreasing MRT-Red next hop is the next hop along the increasing MRT-Blue towards R. Naturally, since R is ordered with respect to all the nodes, there will always be an increasing and a decreasing path towards it. This algorithm does not provide the complete specific path taken but just the appropriate next hops to use. The identities of G and H are not determined by the computing node X.",
      "ja": "増加-SPFまたは減少-SPFのいずれかによって到達しなかったそれらのノードのために、我々としても、次のホップを決定することができます。 Xに対して順序付けされていないノードの増加MRTブルーネクストホップは、Rに向かって減少MRTレッドに沿った次のホップであり、減少MRTレッドネクストホップは、向かって増加MRTブルーに沿った次のホップでありますRがすべてのノードに対して順序付けされるのでR.当然、常に増加し、それに向かって減少する経路が存在することになります。このアルゴリズムは、撮影した完全な特定のパスが、使用するだけで、適切な次のホップを提供していません。 G及びHの同一性は、コンピューティング・ノードXによって決定されていません"
    },
    {
      "indent": 3,
      "text": "The final case to consider is when the GADAG root R computes its own next hops. Since the GADAG root R is << all other nodes, running an increasing-SPF rooted at R will reach all other nodes; the MRT-Blue next hops are those found with this increasing-SPF. Similarly, since the GADAG root R is >> all other nodes, running a decreasing-SPF rooted at R will reach all other nodes; the MRT-Red next hops are those found with this decreasing-SPF.",
      "ja": "GADAGルートRが自身の次のホップを計算する際に考慮すべき最終的な場合です。 GADAGルートRが<<他のすべてのノードであるため、Rをルート増加-SPFを実行すると、他のすべてのノードに到達します。 MRTブルーネクストホップは、この増加-SPFで見られるものです。同様に、GADAGルートRは>>他のすべてのノードであるため、Rをルート減少-SPFを実行すると、他のすべてのノードに到達します。 MRTレッドネクストホップは、この減少-SPFで見られるものです。"
    },
    {
      "indent": 17,
      "text": "E---D---|              E<--D<--|\n|   |   |              |   ^   |\n|   |   |              V   |   |\nR   F   C              R   F   C\n|   |   |              |   ^   ^\n|   |   |              V   |   |\nA---B---|              A-->B---|",
      "raw": true
    },
    {
      "indent": 12,
      "text": " (a) (b) A 2-connected graph A spanning ADAG rooted at R",
      "ja": "（A）（B）2に接続されたグラフのスパニングADAG Rをルート"
    },
    {
      "indent": 33,
      "text": "Figure 22",
      "ja": "図22"
    },
    {
      "indent": 3,
      "text": "As an example, consider the situation depicted in Figure 22. Node C runs an increasing-SPF and a decreasing-SPF on the ADAG. The increasing-SPF reaches D, E, and R; the decreasing-SPF reaches B, A, and R. E>>C. So, towards E the MRT-Blue next hop is D, since E was reached on the increasing path through D. The MRT-Red next hop towards E is B, since R was reached on the decreasing path through B. Since E>>D, D will similarly compute its MRT-Blue next hop to be E, ensuring that a packet on MRT-Blue will use path C-D-E. B, A, and R will similarly compute the MRT-Red next hops towards E (which is ordered less than B, A and R), ensuring that a packet on MRT-Red will use path C-B-A-R-E.",
      "ja": "一例として、図22のノードCに示される状況が増加-SPF及びADAGに減少-SPFを実行考えます。増加-SPFはD、E、およびRに到達します。減少-SPFはB、A、およびR. E >> Cに到達します。 Rは、EのでB.を通して減少路上に達したのでEは、EはBに向かって次のホップD.ザMRTレッドを通して増加経路上に到達したのでそう、E向かっMRTブルーネクストホップは>> DでありますD、Dは、同様MRTブルー上のパケットはパスCDEを使用することを確実にする、Eであるために、そのMRTブルーネクストホップを計算します。 B、A、およびRは、同様MRTレッドを計算するには、次MRTレッド上のパケットは、パスC-B-A-R-Eを使用することを保証する、（B、A及びR未満順序付けされる）Eに向かってホップ。"
    },
    {
      "indent": 3,
      "text": "C can determine the next hops towards F as well. Since F is not ordered with respect to C, the MRT-Blue next hop is the decreasing one towards R (which is B) and the MRT-Red next hop is the increasing one towards R (which is D). Since F>>B, for its MRT-Blue next hop towards F, B will use the real increasing next hop towards F. So a packet forwarded to B on MRT-Blue will get to F on path C-B-F. Similarly, D will use the real decreasing next hop towards F as its MRT-Red next hop, a packet on MRT-Red will use path C-D-F.",
      "ja": "Cは、同様にFに向かって次のホップを決定することができます。 Fは、Cに対して順序付けられていないので、MRTブルーネクストホップは（B）とRに向かって減少一つであり、MRTレッド次ホップは（D）でRに向かって増加するものです。そのMRTブルーのためのF >> Bは、次のFに向けてホップするので、BだからMRTブルーにBに転送されたパケットは、パスC-B-FにFに取得することF.に向けて本当の増加次のホップを使用します。同様に、Dは、MRTレッド上のパケットは、パスC-D-Fが使用され、そのMRTレッドネクストホップとしてFに向かって実際の減少次のホップを使用します。"
    },
    {
      "indent": 0,
      "text": "5.7.4. Generalizing for a Graph That Isn't 2-Connected",
      "section_title": true,
      "ja": "5.7.4.  2-接続されていないグラフの一般化"
    },
    {
      "indent": 3,
      "text": "If a graph isn't 2-connected, then the basic approach given in Section 5.7.3 needs some extensions to determine the appropriate MRT next hops to use for destinations outside the computing router X's blocks. In order to find a pair of maximally redundant trees in that graph, we need to find a pair of RTs in each of the blocks (the root of these trees will be discussed later) and combine them.",
      "ja": "グラフは2-接続されていない場合は、5.7.3項で与えられた基本的な考え方は次のコンピューティング・ルータXのブロック外の宛先に使用するホップ適切なMRTを決定するために、いくつかの拡張機能を必要とします。そのグラフにおける最大限の冗長木のペアを見つけるために、我々は、各ブロックにおけるRTの対（これらのツリーのルートは後述する）を検索し、それらを結合する必要があります。"
    },
    {
      "indent": 3,
      "text": "When computing the MRT next hops from a router X, there are three basic differences:",
      "ja": "ルータXからMRTの次のホップを計算する場合、三つの基本的な違いがあります。"
    },
    {
      "indent": 3,
      "text": "1. Only nodes in a common block with X should be explored in the increasing-SPF and decreasing-SPF.",
      "ja": "1.だけ増加-SPFで検討と-SPFを減少すべきであるXと共通ブロック内のノード。"
    },
    {
      "indent": 3,
      "text": "2. Instead of using the GADAG root, X's localroot should be used. This has the following implications:",
      "ja": "代わりにGADAGのルートを使用しての2、Xのlocalrootを使用する必要があります。これは、次のような意味があります。"
    },
    {
      "indent": 7,
      "text": "A. The links from X's localroot should not be explored.",
      "ja": "A. Xのlocalrootからのリンクが検討されるべきではありません。"
    },
    {
      "indent": 7,
      "text": "B. If a node is explored in the outgoing SPF so Y>>X, then X's MRT-Red next hops to reach Y uses X's MRT-Red next hops to reach X's localroot and if Z<<X, then X's MRT-Blue next hops to reach Z uses X's MRT-Blue next hops to reach X's localroot.",
      "ja": "B. Y >> Xは、XのMRTレッドは次のYは、XのMRTレッドを使用して到達するホップので、ノードが出SPFで検討されている場合は、次のXのlocalrootに到達するためにホップとZ << Xは、XのMRTブルー場合次のZは、次のXのMRTブルーを使用してXのlocalrootに到達するためにホップ到達するためにホップ。"
    },
    {
      "indent": 7,
      "text": "C. If a node W in a common block with X was not reached in the increasing-SPF or decreasing-SPF, then W is unordered with respect to X. X's MRT-Blue next hops to W are X's decreasing (aka MRT-Red) next hops to X's localroot. X's MRT-Red next hops to W are X's increasing (aka MRT-Blue) next hops to X's localroot.",
      "ja": "C.は、Xと共通ブロック内のノードWが増加-SPFまたは減少-SPFに達しなかった場合、Wは、XをXのMRTブルーに関して順不同であり、次のWへのホップXの減少（別名MRT-赤Xのlocalrootに）次のホップ。 XのMRTレッドは次のWへのホップXのlocalrootにXの増加（別名MRT-ブルー）のネクストホップです。"
    },
    {
      "indent": 3,
      "text": "3. For nodes in different blocks, the next hops must be inherited via the relevant cut-vertex.",
      "ja": "異なるブロック内のノードの3、次のホップは、当該カット頂点を介して継承されなければなりません。"
    },
    {
      "indent": 3,
      "text": "These are all captured in the detailed algorithm given in Section 5.7.5.",
      "ja": "これらはすべて、セクション5.7.5で与えられた詳細なアルゴリズムで捕獲されています。"
    },
    {
      "indent": 0,
      "text": "5.7.5. Complete Algorithm to Compute MRT Next Hops",
      "section_title": true,
      "ja": "5.7.5. 計算MRTネクストホップへの完全なアルゴリズム"
    },
    {
      "indent": 3,
      "text": "The complete algorithm to compute MRT Next Hops for a particular router X is given in Figure 23. In addition to computing the MRT-Blue next hops and MRT-Red next hops used by X to reach each node Y, the algorithm also stores an \"order_proxy\", which is the proper cut-vertex to reach Y if it is outside the block, and which is used later in deciding whether the MRT-Blue or the MRT-Red can provide an acceptable alternate for a particular primary next hop.",
      "ja": "特定のルータXのためにMRTへ次ホップを計算するための完全なアルゴリズムはYの各ノードに到達するためにXによって使用されるMRTブルーネクストホップ及びMRTレッド次のホップを計算することに加えて、図23に与えられ、アルゴリズムは、「記憶しますそれがブロックの外側で、かつMRTブルーまたはMRT赤特定の一次次ホップのために許容可能な代替を提供することができるかどうかを決定する際に後で使用される場合、Yに到達するために適切なカット頂点であるorder_proxy」、。"
    },
    {
      "indent": 3,
      "text": "In_Common_Block(x, y) if ( (x.block_id is y.block_id) or (x is y.localroot) or (y is x.localroot) ) return true return false",
      "ja": "In_Common_Block（x、y）は（（x.block_idがy.block_idである）、または（x）はy.localrootであるか、または（yはx.localrootある））場合に真を返しがfalseを返します"
    },
    {
      "indent": 3,
      "text": "Store_Results(y, direction) if direction is FORWARD y.higher = true y.blue_next_hops = y.next_hops if direction is REVERSE y.lower = true y.red_next_hops = y.next_hops",
      "ja": "Store_Results（Y方向）の方向が逆y.lower =真y.red_next_hopsの=のy.next_hopsある場合方向y.higher =真y.blue_next_hopsの=のy.next_hops FORWARDある場合"
    },
    {
      "indent": 3,
      "text": "SPF_No_Traverse_Block_Root(spf_root, block_root, direction) Initialize spf_heap to empty Initialize nodes' spf_metric to infinity and next_hops to empty spf_root.spf_metric = 0 insert(spf_heap, spf_root) while (spf_heap is not empty) min_node = remove_lowest(spf_heap) Store_Results(min_node, direction) if ((min_node is spf_root) or (min_node is not block_root)) foreach interface intf of min_node if ( ( ((direction is FORWARD) and intf.OUTGOING) or ((direction is REVERSE) and intf.INCOMING) ) and In_Common_Block(spf_root, intf.remote_node) ) path_metric = min_node.spf_metric + intf.metric if path_metric < intf.remote_node.spf_metric intf.remote_node.spf_metric = path_metric if min_node is spf_root intf.remote_node.next_hops = make_list(intf) else intf.remote_node.next_hops = min_node.next_hops insert_or_update(spf_heap, intf.remote_node) else if path_metric == intf.remote_node.spf_metric if min_node is spf_root add_to_list(intf.remote_node.next_hops, intf) else add_list_to_list(intf.remote_node.next_hops, min_node.next_hops)",
      "ja": "SPF_No_Traverse_Block_Root（spf_root、block_root、方向）0 = spf_root.spf_metricインサート（spf_heap、spf_root）しばらく空に無限大とnext_hopsに初期ノードのspf_metricを空にspf_heapを初期化（spf_heapが空ではない）min_node = remove_lowest（spf_heap）Store_Results（min_node、方向min_nodeの）IF（（min_nodeあるspf_root）または（min_nodeがblock_rootされない））のforeachインタフェースintf IF（（（（方向が順方向である）とintf.OUTGOING）または（（方向）が逆方向）とintf.INCOMINGである）とIn_Common_Block（spf_root、intf.remote_node））path_metric = min_node.spf_metric + intf.metric <intf.remote_node.spf_metric intf.remote_node.spf_metric = path_metric path_metric場合min_nodeはspf_root intf.remote_node.next_hops = make_list（INTF）INTF他のであれば。他remote_node.next_hops = min_node.next_hops insert_or_update（spf_heap、intf.remote_node）path_metric場合== intf.remote_node.spf_metric min_nodeはspf_root add_to_list（intf.remote_node.next_hops、INTF）であれば、他のadd_list_to_list（intf.rem ote_node.next_hops、min_node.next_hops）"
    },
    {
      "indent": 3,
      "text": "SetEdge(y) if y.blue_next_hops is empty and y.red_next_hops is empty SetEdge(y.localroot) y.blue_next_hops = y.localroot.blue_next_hops y.red_next_hops = y.localroot.red_next_hops y.order_proxy = y.localroot.order_proxy",
      "ja": "y.blue_next_hops場合SetEdge（y）は空であり、y.red_next_hops空SetEdge（y.localroot）であるy.blue_next_hops = y.localroot.blue_next_hops y.red_next_hops = y.localroot.red_next_hops y.order_proxy = y.localroot.order_proxy"
    },
    {
      "indent": 3,
      "text": "Compute_MRT_NextHops(x, gadag_root) foreach node y y.higher = y.lower = false clear y.red_next_hops and y.blue_next_hops y.order_proxy = y SPF_No_Traverse_Block_Root(x, x.localroot, FORWARD) SPF_No_Traverse_Block_Root(x, x.localroot, REVERSE)",
      "ja": "Compute_MRT_NextHops（X、gadag_root）foreachのノードy y.higher = y.lower = falseをクリアy.red_next_hopsとy.blue_next_hops y.order_proxy = YのSPF_No_Traverse_Block_Root（X、x.localroot、FORWARD）SPF_No_Traverse_Block_Root（X、x.localroot、REVERSE ）"
    },
    {
      "indent": 6,
      "text": "// red and blue next hops are stored to x.localroot as different // paths are found via the SPF and reverse-SPF. // Similarly, any node whose localroot is x will have its // red_next_hops and blue_next_hops already set.",
      "ja": "//赤と青の次のホップは、SPFを介して発見され、逆SPFをしているような異なる//パスをx.localrootするために格納されています。 //同様に、そのlocalroot xは任意のノードは、その// red_next_hopsとblue_next_hopsが既に設定されます。"
    },
    {
      "indent": 6,
      "text": "// Handle nodes in the same block that aren't the localroot foreach node y if (y.IN_MRT_ISLAND and (y is not x) and (y.block_id is x.block_id) ) if y.higher y.red_next_hops = x.localroot.red_next_hops else if y.lower y.blue_next_hops = x.localroot.blue_next_hops else y.blue_next_hops = x.localroot.red_next_hops y.red_next_hops = x.localroot.blue_next_hops",
      "ja": "// y.higher y.red_next_hops = xであればlocalrootのforeachのノードyのIF（y.IN_MRT_ISLAND及び（YはXではない）と（y.block_idがx.block_idである））ではない、同じブロック内のノードを扱います。 y.lower y.blue_next_hops = x.localroot.blue_next_hops他y.blue_next_hops = x.localroot.red_next_hops y.red_next_hops = x.localroot.blue_next_hops場合は、他のlocalroot.red_next_hops"
    },
    {
      "indent": 6,
      "text": "// Inherit next hops and order_proxies to other components if (x is not gadag_root) and (x.localroot is not gadag_root) gadag_root.blue_next_hops = x.localroot.blue_next_hops gadag_root.red_next_hops = x.localroot.red_next_hops gadag_root.order_proxy = x.localroot foreach node y if (y is not gadag_root) and (y is not x) and y.IN_MRT_ISLAND SetEdge(y)",
      "ja": "//継承他のコンポーネントへのネクストホップ及びorder_proxies（xはgadag_rootない）場合（x.localrootがgadag_rootされていない）gadag_root.blue_next_hops = x.localroot.blue_next_hops gadag_root.red_next_hops = x.localroot.red_next_hops gadag_root.order_proxy = X。 localroot foreachのノードY（YはXではない）とy.IN_MRT_ISLAND SetEdge（Y）であれば（yがgadag_rootない）と"
    },
    {
      "indent": 3,
      "text": "max_block_id = 0 Assign_Block_ID(gadag_root, max_block_id) Compute_MRT_NextHops(x, gadag_root)",
      "ja": "max_block_id = 0 Assign_Block_ID（gadag_root、max_block_id）Compute_MRT_NextHops（X、gadag_root）"
    },
    {
      "indent": 10,
      "text": "Figure 23: Complete Algorithm to Compute MRT Next Hops",
      "ja": "図23：計算MRTネクストホップへの完全なアルゴリズム"
    },
    {
      "indent": 0,
      "text": "5.8. Identify MRT Alternates",
      "section_title": true,
      "ja": "5.8.  MRT交互に識別する"
    },
    {
      "indent": 3,
      "text": "At this point, a computing router S knows its MRT-Blue next hops and MRT-Red next hops for each destination in the MRT Island. The primary next hops along the SPT are also known. It remains to determine for each primary next hop to a destination D, which MRT avoids the primary next-hop node F. This computation depends upon data set in Compute_MRT_NextHops such as each node y's y.blue_next_hops, y.red_next_hops, y.order_proxy, y.higher, y.lower, and topo_orders. Recall that any router knows only which are the nodes greater and lesser than itself, but it cannot decide the relation between any two given nodes easily; that is why we need topological ordering.",
      "ja": "この時点では、コンピューティング・ルータSは、MRTブルーネクストホップとMRT-レッドMRT島の宛先ごとに次のホップを知っています。 SPTに沿って主要なネクストホップも知られています。これは、MRTはこの計算はy.order_proxy、y.red_next_hops、このような各ノードyのy.blue_next_hopsとしてCompute_MRT_NextHopsに設定されたデータに依存する一次次ホップノードF.を回避宛先Dに各一次次のホップのために決定するために残っていますy.higher、y.lower、およびtopo_orders。任意のルータが自体より大きく、小さいノードであるだけ知っているが、それは簡単に任意の二つの所与のノード間の関係を決定することができないことを思い出してください。我々はトポロジカル順序を必要とする理由です。"
    },
    {
      "indent": 3,
      "text": "For each primary next-hop node F to each destination D, S can call Select_Alternates(S, D, F, primary_intf) to determine whether to use the MRT-Blue or MRT-Red next hops as the alternate next hop(s) for that primary next hop. The algorithm is given in Figure 24 and discussed afterwards.",
      "ja": "各宛先Dへの各プライマリ次ホップノードFため、Sは、代替のネクストホップ（複数可）用としてMRTブルーまたはMRT赤次のホップを使用するかどうかを決定するためにSelect_Alternates（S、D、F、primary_intf）を呼び出すことができその主なネクストホップ。このアルゴリズムは、図24に与えられ、その後、議論されています。"
    },
    {
      "indent": 2,
      "text": "Select_Alternates_Internal(D, F, primary_intf, D_lower, D_higher, D_topo_order): if D_higher and D_lower if F.HIGHER and F.LOWER if F.topo_order < D_topo_order return USE_RED else return USE_BLUE if F.HIGHER return USE_RED if F.LOWER return USE_BLUE //F unordered wrt S return USE_RED_OR_BLUE",
      "ja": "Select_Alternates_Internal（D、F、primary_intf、D_lower、D_higher、D_topo_order）：D_higherとD_lowerはF.HIGHERとF.LOWER場合F.topo_order <D_topo_orderリターン他戻りUSE_BLUE USE_RED場合場合F.HIGHERはUSE_REDを返す場合ならF.LOWERリターンUSE_BLUE // F順不同WRT SリターンUSE_RED_OR_BLUE"
    },
    {
      "indent": 6,
      "text": "else if D_higher\n    if F.HIGHER and F.LOWER\n        return USE_BLUE\n    if F.LOWER\n        return USE_BLUE\n    if F.HIGHER\n        if (F.topo_order > D_topo_order)\n            return USE_BLUE\n        if (F.topo_order < D_topo_order)\n            return USE_RED\n    //F unordered wrt S\n    return USE_RED_OR_BLUE",
      "raw": true
    },
    {
      "indent": 6,
      "text": "else if D_lower if F.HIGHER and F.LOWER return USE_RED if F.HIGHER return USE_RED if F.LOWER if F.topo_order > D_topo_order return USE_BLUE",
      "ja": "それ以外の場合D_lower F.HIGHERリターンがF.topo_order>であれば、戻りUSE_BLUE D_topo_order F.LOWER場合USE_RED場合F.HIGHERとF.LOWERはUSE_REDを返す場合"
    },
    {
      "indent": 10,
      "text": "    if F.topo_order < D_topo_order\n        return USE_RED\n//F unordered wrt S\nreturn USE_RED_OR_BLUE",
      "raw": true
    },
    {
      "indent": 6,
      "text": "else //D is unordered wrt S if F.HIGHER and F.LOWER if primary_intf.OUTGOING and primary_intf.INCOMING return USE_RED_OR_BLUE if primary_intf.OUTGOING return USE_BLUE if primary_intf.INCOMING return USE_RED //primary_intf not in GADAG return USE_RED if F.LOWER return USE_RED if F.HIGHER return USE_BLUE //F unordered wrt S if F.topo_order > D_topo_order: return USE_BLUE else: return USE_RED",
      "ja": "primary_intf.OUTGOINGとprimary_intf.INCOMING戻りUSE_RED_OR_BLUE場合primary_intf.INCOMINGがF.LOWER場合USE_REDを返すGADAGにUSE_RED // primary_intfを返していない場合は、他// Dはprimary_intf.OUTGOINGリターンUSE_BLUE場合F.HIGHERとF.LOWER場合順不同WRTのSですF.topo_order> D_topo_order場合F.HIGHERリターンUSE_BLUE // F順不同WRT S場合USE_REDを返します。それ以外のUSE_BLUE戻る：リターンをUSE_RED"
    },
    {
      "indent": 2,
      "text": "Select_Alternates(D, F, primary_intf) if not In_Common_Block(F, S) return PRIM_NH_IN_DIFFERENT_BLOCK if (D is F) or (D.order_proxy is F) return PRIM_NH_IS_D_OR_OP_FOR_D D_lower = D.order_proxy.LOWER D_higher = D.order_proxy.HIGHER D_topo_order = D.order_proxy.topo_order return Select_Alternates_Internal(D, F, primary_intf, D_lower, D_higher, D_topo_order)",
      "ja": "Select_Alternates（D、F、primary_intf）でない場合In_Common_Block（F、S）（DはFである）場合、戻りPRIM_NH_IN_DIFFERENT_BLOCKまたは（D.order_proxyがFである）を返すPRIM_NH_IS_D_OR_OP_FOR_D D_lower = D.order_proxy.LOWER D_higher = D.order_proxy.HIGHER D_topo_order = Select_Alternates_Internal（D、F、primary_intf、D_lower、D_higher、D_topo_order）を返すD.order_proxy.topo_order"
    },
    {
      "indent": 6,
      "text": "Figure 24: Select_Alternates() and Select_Alternates_Internal()",
      "ja": "図24：Select_Alternates（）およびSelect_Alternates_Internal（）"
    },
    {
      "indent": 3,
      "text": "It is useful to first handle the case where F is also D, or F is the order proxy for D. In this case, only link protection is possible. The MRT that doesn't use the failed primary next hop is used. If both MRTs use the primary next hop, then the primary next hop must be a cut-link, so either MRT could be used but the set of MRT next hops must be pruned to avoid the failed primary next-hop interface. To indicate this case, Select_Alternates returns PRIM_NH_IS_D_OR_OP_FOR_D. Explicit pseudocode to handle the three sub-cases above is not provided.",
      "ja": "最初のFもDである場合を扱うために有用である、またはFはこの場合、Dの順プロキシで、リンクのみの保護が可能です。障害が発生したプライマリ次のホップを使用していませんMRTが使用されています。両方のMRTがプライマリ次のホップを使用している場合はMRTのいずれかを使用することができるが、MRTの次のホップのセットが失敗した主なネクストホップインターフェイスを避けるために剪定されなければならないので、一次ネクストホップは、カットリンクでなければなりません。このような場合を示すために、Select_AlternatesはPRIM_NH_IS_D_OR_OP_FOR_Dを返します。上記の3つのサブケースを処理するための明示的な擬似コードが提供されていません。"
    },
    {
      "indent": 3,
      "text": "The logic behind Select_Alternates_Internal() is described in Figure 25. As an example, consider the first case described in the table, where the D>>S and D<<S. If this is true, then either S or D must be the block root, R. If F>>S and F<<S, then S is the block root. So the blue path from S to D is the increasing path to D, and the red path S to D is the decreasing path to D. If the F.topo_order>D.topo_order, then either F is ordered higher than D or F is unordered with respect to D. Therefore, F is either on a decreasing path from S to D, or it is on neither an increasing nor a decreasing path from S to D. In either case, it is safe to take an increasing path from S to D to avoid F. We know that when S is R, the increasing path is the blue path, so it is safe to use the blue path to avoid F.",
      "ja": "Select_Alternates_Internal背後にあるロジックは、（）表、D >> SとD << Sで説明した第1のケースを、例として図25で説明した検討されています。これが真である場合、SまたはDのいずれかが、ブロックルートである必要があり、RはF >> SとF << S場合、Sはブロックルートです。そうSからDへの青いパスはDの増加パスであり、そしてD赤経路SはDに減少パスでF.topo_order> D.topo_order場合、Fのいずれかは、D又はFであるよりも高く順序付けされますしたがってD.に関して順不同、Fのいずれか減少経路上のSからDにある、またはそれがどちらも増加もいずれの場合にもD.へSから減少する経路上にあり、Sから増加パスを取ることは安全ですDにはF.を避けるために、青色のパスを使用しても安全であるように、我々は、SがRであるとき、増加パスはブルーパスであることを知っているF.を避けるために、"
    },
    {
      "indent": 3,
      "text": "If instead F.topo_order<D.topo_order, then either F is ordered lower than D, or F is unordered with respect to D. Therefore, F is either on an increasing path from S to D, or it is on neither an increasing nor a decreasing path from S to D. In either case, it is safe to take a decreasing path from S to D to avoid F. We know that when S is R, the decreasing path is the red path, so it is safe to use the red path to avoid F.",
      "ja": "代わりF.topo_order <D.topo_order、その後、いずれかのFはDよりも低く順序付けられている場合、またはFはしたがってD.に関して順不同であり、FはDにSから増加パス上のいずれかである、またはそれはどちらも増加でありますAいずれの場合においてもDにSからのパスを減少させること、使用しても安全であるので、我々は、SがRである場合、減少パスが赤の経路であることを知っているF.を回避するためにDにSから減少パスを取ることは安全ですF.を避けるために赤いパス"
    },
    {
      "indent": 3,
      "text": "If F>>S or F<<S (but not both), then D is the block root. We then know that the blue path from S to D is the increasing path to R, and the red path is the decreasing path to R. When F>>S, we deduce that F is on an increasing path from S to R. So in order to avoid F, we use a decreasing path from S to R, which is the red path. Instead, when F<<S, we deduce that F is on a decreasing path from S to R. So in order to avoid F, we use an increasing path from S to R, which is the blue path.",
      "ja": "F >> SまたはF << S（両方ではない）場合、Dはブロックルートです。我々はFだからRにSから増加パス上にあることを推測する、私たちはその後、DにSからの青色パスがRに増加パスであることを知っている、と赤のパスはR.ときF >> Sに減少パスです。 Fを回避するために、我々は、Sから赤経路であるRに減少パスを使用します。代わりに、場合F << S、我々は、Fは、我々は、青色パスであるR、Sへの増加パスを使用し、Fを避けるために、したがってSからRに減少パス上にあることを推論します。"
    },
    {
      "indent": 3,
      "text": "All possible cases are systematically described in the same manner in the rest of the table.",
      "ja": "すべての可能な場合は、体系的にテーブルの残りの部分で同じように記述されています。"
    },
    {
      "indent": 0,
      "text": "+------+------------+------+------------------------------+------------+\n| D    | MRT blue   | F    | additional      | F          | Alternate  |\n| wrt  | and red    | wrt  | criteria        | wrt        |            |\n| S    | path       | S    |                 | MRT        |            |\n|      | properties |      |                 | (deduced)  |            |\n+------+------------+------+-----------------+------------+------------+\n| D>>S | Blue path: | F>>S | additional      | F on an    | Use Red    |\n| and  | Increasing | only | criteria        | increasing | to avoid   |\n| D<<S,| path to R. |      | not needed      | path from  | F          |\n| D is | Red path:  |      |                 | S to R     |            |\n| R,   | Decreasing +------+-----------------+------------+------------+\n|      | path to R. | F<<S | additional      | F on a     | Use Blue   |\n|      |            | only | criteria        | decreasing | to avoid   |\n|      |            |      | not needed      | path from  | F          |\n| or   |            |      |                 | S to R     |            |\n|      |            +------+-----------------+------------+------------+\n|      |            | F>>S | topo(F)>topo(D) | F on a     | Use Blue   |\n| S is | Blue path: | and  | implies that    | decreasing | to avoid   |\n| R    | Increasing | F<<S,| F>>D or F??D    | path from  | F          |\n|      | path to D. |      |                 | S to D or  |            |\n|      | Red path:  |      |                 | neither    |            |\n|      | Decreasing |      +-----------------+------------+------------+\n|      | path to D. |      | topo(F)<topo(D) | F on an    | Use Red    |\n|      |            |      | implies that    | increasing | to avoid   |\n|      |            |      | F<<D or F??D    | path from  | F          |\n|      |            |      |                 | S to D or  |            |\n|      |            |      |                 | neither    |            |\n|      |            +------+-----------------+------------+------------+\n|      |            | F??S | Can only occur  | F is on    | Use Red    |\n|      |            |      | when link       | neither    | or Blue    |\n|      |            |      | between         | increasing | to avoid   |\n|      |            |      | F and S         | nor decr.  | F          |\n|      |            |      | is marked       | path from  |            |\n|      |            |      | MRT_INELIGIBLE  | S to D or R|            |",
      "raw": true
    },
    {
      "indent": 0,
      "text": "+------+------------+------+-----------------+------------+------------+\n| D>>S | Blue path: | F<<S | additional      | F on       | Use Blue   |\n| only | Increasing | only | criteria        | decreasing | to avoid   |\n|      | shortest   |      | not needed      | path from  | F          |\n|      | path from  |      |                 | S to R     |            |\n|      | S to D.    +------+-----------------+------------+------------+\n|      | Red path:  | F>>S | topo(F)>topo(D) | F on       | Use Blue   |\n|      | Decreasing | only | implies that    | decreasing | to avoid   |\n|      | shortest   |      | F>>D or F??D    | path from  | F          |\n|      | path from  |      |                 | R to D     |            |\n|      | S to R,    |      |                 | or         |            |\n|      | then       |      |                 | neither    |            |\n|      | decreasing |      +-----------------+------------+------------+\n|      | shortest   |      | topo(F)<topo(D) | F on       | Use Red    |\n|      | path from  |      | implies that    | increasing | to avoid   |\n|      | R to D.    |      | F<<D or F??D    | path from  | F          |\n|      |            |      |                 | S to D     |            |\n|      |            |      |                 | or         |            |\n|      |            |      |                 | neither    |            |\n|      |            +------+-----------------+------------+------------+\n|      |            | F>>S | additional      | F on Red   | Use Blue   |\n|      |            | and  | criteria        |            | to avoid   |\n|      |            | F<<S,| not needed      |            | F          |\n|      |            | F is |                 |            |            |\n|      |            | R    |                 |            |            |\n|      |            +------+-----------------+------------+------------+\n|      |            | F??S | Can only occur  | F is on    | Use Red    |\n|      |            |      | when link       | neither    | or Blue    |\n|      |            |      | between         | increasing | to avoid   |\n|      |            |      | F and S         | nor decr.  | F          |\n|      |            |      | is marked       | path from  |            |\n|      |            |      | MRT_INELIGIBLE  | S to D or R|            |",
      "raw": true
    },
    {
      "indent": 0,
      "text": "+------+------------+------+-----------------+------------+------------+\n| D<<S | Blue path: | F>>S | additional      | F on       | Use Red    |\n| only | Increasing | only | criteria        | increasing | to avoid   |\n|      | shortest   |      | not needed      | path from  | F          |\n|      | path from  |      |                 | S to R     |            |\n|      | S to R,    +------+-----------------+------------+------------+\n|      | then       | F<<S | topo(F)>topo(D) | F on       | Use Blue   |\n|      | increasing | only | implies that    | decreasing | to avoid   |\n|      | shortest   |      | F>>D or F??D    | path from  | F          |\n|      | path from  |      |                 | R to D     |            |\n|      | R to D.    |      |                 | or         |            |\n|      | Red path:  |      |                 | neither    |            |\n|      | Decreasing |      +-----------------+------------+------------+\n|      | shortest   |      | topo(F)<topo(D) | F on       | Use Red    |\n|      | path from  |      | implies that    | increasing | to avoid   |\n|      | S to D.    |      | F<<D or F??D    | path from  | F          |\n|      |            |      |                 | S to D     |            |\n|      |            |      |                 | or         |            |\n|      |            |      |                 | neither    |            |\n|      |            +------+-----------------+------------+------------+\n|      |            | F>>S | additional      | F on Blue  | Use Red    |\n|      |            | and  | criteria        |            | to avoid   |\n|      |            | F<<S,| not             |            | F          |\n|      |            | F is | needed          |            |            |\n|      |            | R    |                 |            |            |\n|      |            +------+-----------------+------------+------------+\n|      |            | F??S | Can only occur  | F is on    | Use Red    |\n|      |            |      | when link       | neither    | or Blue    |\n|      |            |      | between         | increasing | to avoid   |\n|      |            |      | F and S         | nor decr.  | F          |\n|      |            |      | is marked       | path from  |            |\n|      |            |      | MRT_INELIGIBLE  | S to D or R|            |\n+------+------------+------+-----------------+------------+------------+\n| D??S | Blue path: | F<<S | additional      | F on a     | Use Red    |\n|      | Decr. from | only | criteria        | decreasing | to avoid   |\n|      | S to first |      | not needed      | path from  | F          |\n|      | node K<<D, |      |                 | S to K.    |            |\n|      | then incr. +------+-----------------+------------+------------+\n|      | to D.      | F>>S | additional      | F on an    | Use Blue   |\n|      | Red path:  | only | criteria        | increasing | to avoid   |\n|      | Incr. from |      | not needed      | path from  | F          |\n|      | S to first |      |                 | S to L     |            |\n|      | node L>>D, |      |                 |            |            |\n|      | then decr. |      |                 |            |            |",
      "raw": true
    },
    {
      "indent": 0,
      "text": "|      |            +------+-----------------+------------+------------+\n|      |            | F??S | topo(F)>topo(D) | F on decr. | Use Blue   |\n|      |            |      | implies that    | path from  | to avoid   |\n|      |            |      | F>>D or F??D    | L to D or  | F          |\n|      |            |      |                 | neither    |            |\n|      |            |      +-----------------+------------+------------+\n|      |            |      | topo(F)<topo(D) | F on incr. | Use Red    |\n|      |            |      | implies that    | path from  | to avoid   |\n|      |            |      | F<<D or F??D    | K to D or  | F          |\n|      |            |      |                 | neither    |            |\n|      |            +------+-----------------+------------+------------+\n|      |            | F>>S | GADAG link      | F on an    | Use Blue   |\n|      |            | and  | direction       | incr. path | to avoid   |\n|      |            | F<<S,| S->F            | from S     | F          |\n|      |            | F is +-----------------+------------+------------+\n|      |            | R    | GADAG link      | F on a     | Use Red    |\n|      |            |      | direction       | decr. path | to avoid   |\n|      |            |      | S<-F            | from S     | F          |\n|      |            |      +-----------------+------------+------------+\n|      |            |      | GADAG link      | Either F is the order   |\n|      |            |      | direction       | proxy for D (case       |\n|      |            |      | S<-->F          | already handled) or D   |\n|      |            |      |                 | is in a different block |\n|      |            |      |                 | from F, in which case   |\n|      |            |      |                 | Red or Blue avoids F    |\n|      |            |      +-----------------+-------------------------+\n|      |            |      | S-F link not    | Relies on special       |\n|      |            |      | in GADAG,       | construction of GADAG   |\n|      |            |      | only when       | to demonstrate that     |\n|      |            |      | S-F link is     | using Red avoids F      |\n|      |            |      | MRT_INELIGIBLE  | (see text)              |\n+------+------------+------+-----------------+-------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": " Determining MRT next hops and alternates based on the partial order and topological sort relationships between the source(S), destination(D), primary next hop(F), and block root(R). topo(N) indicates the topological sort value of node N. X??Y indicates that node X is unordered with respect to node Y. It is assumed that the case where F is D, or where F is the order proxy for D, has already been handled.",
      "ja": "MRTをソース（S）、宛先（D）、原発ネクストホップ（F）、及びブロック根（R）との間の半順序とトポロジカルソートの関係に基づいて、次ホップと交互を決定します。 TOPO（N）は、ノードNのX？Yのトポロジカルソート値は、ノードXは、それがFがDである場合と仮定されるノードY.に関して順不同であることを示し、又はここでFは、Dためのプロキシであることを示しすでに処理されています。"
    },
    {
      "indent": 12,
      "text": "Figure 25: Determining MRT Next Hops and Alternates",
      "ja": "図25：MRTネクストホップと交互に決定"
    },
    {
      "indent": 3,
      "text": "The last case in Figure 25 requires additional explanation. The fact that the red path from S to D in this case avoids F relies on a special property of the GADAGs that we have constructed in this algorithm, a property not shared by all GADAGs in general. When D is unordered with respect to S, and F is the localroot for S, it can occur that the link between S and F is not in the GADAG only when that link has been marked MRT_INELIGIBLE. For an arbitrary GADAG, S doesn't have enough information based on the computed order relationships to determine if the red path or blue path will hit F (which is also the localroot) before hitting K or L, and making it safely to D. However, the GADAGs that we construct using the algorithm in this document are not arbitrary GADAGs. They have the additional property that incoming links to a localroot come from only one other node in the same block. This is a result of the method of construction. This additional property guarantees that the red path from S to D will never pass through the localroot of S. (That would require the localroot to play the role of L, the first node in the path ordered higher than D, which would in turn require the localroot to have two incoming links in the GADAG, which cannot happen.) Therefore, it is safe to use the red path to avoid F with these specially constructed GADAGs.",
      "ja": "図25の最後の場合は、追加の説明が必要です。この場合、DにSから赤いパスがF避けるという事実は、我々は、このアルゴリズムで構築されていGADAGs、ではない一般的にはすべてのGADAGsが共有する財産の特殊な性質に依存しています。 DがSに関して順不同であり、そしてFはSのためlocalrootである場合、SとFとの間のリンクは、そのリンクがMRT_INELIGIBLEをマークされている場合にのみGADAGでないことが発生することができます。任意GADAGため、Sは、赤色パスまたは青色パスはK又はL打撃、及びDに安全にそれを作る前に（またlocalrootである）Fをヒットするかどうかを決定するために計算された順序関係に基づいて、十分な情報を持っていませんしかし、我々はこの文書のアルゴリズムを使用して構築GADAGsは任意GADAGsではありません。彼らはlocalrootへの着信リンクが同じブロック内でのみ1つの他のノードから来る追加のプロパティを持っています。これは、構築の方法の結果です。 SからDへの赤いパスがS.のlocalrootを通過しないことをこの追加のプロパティを保証（これはLの役割を果たしてlocalrootが必要になり、パス内の最初のノードは、順番に必要となるD、より高次localrootが起こることはできませんGADAG、2つの着信リンクを持っている。）ので、これらの特別に構築GADAGsでFを避けるために、赤のパスを使用しても安全です。"
    },
    {
      "indent": 3,
      "text": "As an example of how Select_Alternates_Internal() operates, consider the ADAG depicted in Figure 26 and first suppose that G is the source, D is the destination, and H is the failed next hop. Since D>>G, we need to compare H.topo_order and D.topo_order. Since D.topo_order>H.topo_order, D must be either higher than H or unordered with respect to H, so we should select the decreasing path towards the root. If, however, the destination were instead J, we must find that H.topo_order>J.topo_order, so we must choose the increasing Blue next hop to J, which is I. In the case, when instead the destination is C, we find that we need to first decrease to avoid using H, so the Blue, first decreasing then increasing, path is selected.",
      "ja": "Select_Alternates_Internal（）が動作し、ADAGは、図26に示され、最初のGがソースであると仮定する考える方法の一例として、Dは宛先であり、Hは失敗し、次のホップです。 D >> G以来、私たちはH.topo_orderとD.topo_orderを比較する必要があります。 D.topo_order> H.topo_orderので、Dは、Hよりも高いかHに関して順不同のいずれかでなければならないので、我々は、ルートに向かって減少する経路を選択すべきです。しかし、先の代わりにJだったら、我々はそのH.topo_order> J.topo_orderを見つけなければならないので、我々は、我々は、代わりに先がCであるとき、場合にはIであるJに増加ブルーネクストホップを選択する必要があります私たちが最初に増加し、その後減少し、青ので、Hを使用しないように最初の減少に必要なことがわかり、パスが選択されています。"
    },
    {
      "indent": 29,
      "text": "[E]<-[D]<-[H]<-[J]\n |    ^    ^    ^\n V    |    |    |\n[R]  [C]  [G]->[I]\n |    ^    ^    ^\n V    |    |    |\n[A]->[B]->[F]---|",
      "raw": true
    },
    {
      "indent": 12,
      "text": "Figure 26: ADAG Rooted at R for a 2-Connected Graph",
      "ja": "図26：ADAG 2接続グラフのRをルート"
    },
    {
      "indent": 0,
      "text": "5.9. Named Proxy-Nodes",
      "section_title": true,
      "ja": "5.9. 名前付きプロキシノード"
    },
    {
      "indent": 3,
      "text": "As discussed in Section 11.2 of [RFC7812], it is necessary to find MRT-Blue and MRT-Red next hops and MRT-FRR alternates for named proxy-nodes. An example use case is for a router that is not part of that local MRT Island, when there is only partial MRT support in the domain.",
      "ja": "[RFC7812]のセクション11.2で説明したように、名前プロキシノードに対してMRTブルー及びMRT赤ネクストホップ及びMRT-FRRを交互に求める必要があります。例のユースケースは、ドメイン内の一部だけMRTのサポートがある場合に、そのローカルMRT島の一部ではないルータです。"
    },
    {
      "indent": 0,
      "text": "5.9.1. Determining Proxy-Node Attachment Routers",
      "section_title": true,
      "ja": "5.9.1. プロキシノードアタッチメントルーターの決定"
    },
    {
      "indent": 3,
      "text": "Section 11.2 of [RFC7812] discusses general considerations for determining the two proxy-node attachment routers for a given proxy-node, corresponding to a prefix. A router in the MRT Island that advertises the prefix is a candidate for being a proxy-node attachment router, with the associated named-proxy-cost equal to the advertised cost to the prefix.",
      "ja": "[RFC7812]のセクション11.2は、プレフィックスに対応する、所定のプロキシノードのための2つのプロキシノードアタッチメントルータを決定するための一般的な考慮事項について説明します。プレフィックスをアドバタイズMRT島のルータは、プレフィックスにアドバタイズコストに等しい関連する名前付きプロキシコストで、プロキシノード取付ルータであるための候補です。"
    },
    {
      "indent": 3,
      "text": "An Island Border Router (IBR) is a router in the MRT Island that is connected to an Island Neighbor (IN), which is a router not in the MRT Island but in the same area/level. An (IBR,IN) pair is a candidate for being a proxy-node attachment router, if the shortest path from the IN to the prefix does not enter the MRT Island. A method for identifying such Loop-Free Island Neighbors (LFINs) is given below. The named-proxy-cost assigned to each (IBR, IN) pair is cost(IBR, IN) + D_opt(IN, prefix).",
      "ja": "アイランド境界ルータ（IBR）は、MRTの島ではなく、同じ領域/レベルルータない島ネイバー（IN）に接続されているMRT島ルータです。 （IBR、IN）ペアは、プレフィックスにからの最短経路はMRT島を入力しない場合、プロキシノード取付ルータであるための候補です。そのようなループのない島ネイバー（LFINs）を識別するための方法を以下に示します。各（IBR、IN）ペアに割り当てられた名前のプロキシ・コストはコスト（IBR、IN）+ D_opt（IN、接頭辞）です。"
    },
    {
      "indent": 3,
      "text": "From the set of prefix-advertising routers and the set of IBRs with at least one LFIN, the two routers with the lowest named-proxy-cost are selected. Ties are broken based upon the lowest Router ID. For ease of discussion, the two selected routers will be referred to as proxy-node attachment routers.",
      "ja": "プレフィックス広告ルータのセットと、少なくとも1 LFINとのIBRのセットから、最低という名前のプロキシ・コストを持つ2つのルータが選択されています。ネクタイは最低のルータIDに基づいて分割されます。議論を容易にするために、選択した2つのルータがプロキシノード取付ルータと呼ぶことにします。"
    },
    {
      "indent": 0,
      "text": "5.9.2. Computing If an Island Neighbor (IN) Is Loop-Free",
      "section_title": true,
      "ja": "5.9.2. コンピューティング島ネイバー（IN）は、ループフリーである場合に"
    },
    {
      "indent": 3,
      "text": "As discussed above, the IN needs to be loop-free with respect to the whole MRT Island for the destination. This can be accomplished by running the usual SPF algorithm while keeping track of which shortest paths have passed through the MRT island. Pseudocode for this is shown in Figure 27. The Island_Marking_SPF() is run for each IN that needs to be evaluated for the loop-free condition, with the IN as the spf_root. Whether or not an IN is loop-free with respect to the MRT island can then be determined by evaluating node.PATH_HITS_ISLAND for each destination of interest.",
      "ja": "上述したように、INは、宛先の全体MRTアイランドに対してループフリーである必要があります。これは、最短経路はMRTの島を通過しているのトラックを維持しながら、通常のSPFアルゴリズムを実行することによって達成することができます。このための擬似コード（図27. Island_Marking_SPFに示されている）がspf_rootとしてINと、ループフリー条件に対して評価される必要がある各INに対して実行されます。 INはMRT島に対するループフリーであるかどうかは、その後、対象の各宛先にnode.PATH_HITS_ISLANDを評価することによって決定することができます。"
    },
    {
      "indent": 4,
      "text": "Island_Marking_SPF(spf_root) Initialize spf_heap to empty Initialize nodes' spf_metric to infinity and next_hops to empty and PATH_HITS_ISLAND to false spf_root.spf_metric = 0 insert(spf_heap, spf_root) while (spf_heap is not empty) min_node = remove_lowest(spf_heap) foreach interface intf of min_node path_metric = min_node.spf_metric + intf.metric if path_metric < intf.remote_node.spf_metric intf.remote_node.spf_metric = path_metric if min_node is spf_root intf.remote_node.next_hops = make_list(intf) else intf.remote_node.next_hops = min_node.next_hops if intf.remote_node.IN_MRT_ISLAND intf.remote_node.PATH_HITS_ISLAND = true else intf.remote_node.PATH_HITS_ISLAND = min_node.PATH_HITS_ISLAND insert_or_update(spf_heap, intf.remote_node) else if path_metric == intf.remote_node.spf_metric if min_node is spf_root add_to_list(intf.remote_node.next_hops, intf) else add_list_to_list(intf.remote_node.next_hops, min_node.next_hops) if intf.remote_node.IN_MRT_ISLAND intf.remote_node.PATH_HITS_ISLAND = true else intf.remote_node.PATH_HITS_ISLAND = min_node.PATH_HITS_ISLAND",
      "ja": "Island_Marking_SPF（spf_rootは）のINTF（spf_heapが空ではない）min_node = remove_lowest（spf_heap）foreachのインターフェイスながら偽spf_root.spf_metric = 0挿入（spf_heap、spf_root）に初期化ノードの無限大にspf_metricと空にnext_hopsとPATH_HITS_ISLANDを空にspf_heapを初期化min_node path_metric = min_node.spf_metric + intf.metric場合path_metric <intf.remote_node.spf_metric intf.remote_node.spf_metric = path_metric min_nodeがある場合spf_root intf.remote_node.next_hops = make_list（INTF）他intf.remote_node.next_hopsの=のmin_node.next_hops場合他intf.remote_node.IN_MRT_ISLAND intf.remote_node.PATH_HITS_ISLAND =他の真intf.remote_node.PATH_HITS_ISLAND = min_node.PATH_HITS_ISLAND insert_or_update（spf_heap、intf.remote_node）path_metric場合== intf.remote_node.spf_metric min_nodeはspf_root add_to_list（intf.remote_nodeある場合。 next_hops、INTF）他add_list_to_list（intf.remote_node.next_hops、min_node.next_hops）であればintf.remote_node.IN_MRT_ISLAND intf.remote_node.PATH_HITS_I SLAND =他の真intf.remote_node.PATH_HITS_ISLAND = min_node.PATH_HITS_ISLAND"
    },
    {
      "indent": 3,
      "text": "Figure 27: Island_Marking_SPF() for Determining If an Island Neighbor Is Loop-Free",
      "ja": "図27：Island_Marking_SPF（）島ネイバーがループフリーであるかどうかを決定するために"
    },
    {
      "indent": 3,
      "text": "It is also possible that a given prefix is originated by a combination of non-island routers and island routers. The results of the Island_Marking_SPF() computation can be used to determine if the shortest path from an IN to reach that prefix hits the MRT Island. The shortest path for the IN to reach prefix P is determined by the total cost to reach prefix P, which is the sum of the cost for the IN to reach a prefix-advertising node and the cost with which that node advertises the prefix. The path with the minimum total cost to prefix P is chosen. If the prefix-advertising node for that minimum total cost path has PATH_HITS_ISLAND set to True, then the IN is not loop-free with respect to the MRT Island for reaching prefix P. If there are multiple minimum total cost paths to reach prefix P, then all of the prefix-advertising routers involved in the minimum total cost paths MUST have PATH_HITS_ISLAND set to False for the IN to be considered loop-free to reach P.",
      "ja": "指定された接頭辞が非島ルータと島ルーターの組み合わせによって発信することも可能です。その接頭辞に到達するためのINからの最短経路はMRT島に当たる場合Island_Marking_SPF（）の計算の結果が決定するために使用することができます。 INプレフィックスPに到達するための最短経路は、プレフィックス広告ノードと、そのノードがプレフィックスをアドバタイズれるコストに到達するINのコストの合計であるプレフィックスPに到達する総コストによって決定されます。 Pを付けるための最小合計コストを有する経路が選択されます。その最小総コストパスのプレフィックス - 広告ノードはPATH_HITS_ISLAND Trueに設定している場合は、プレフィックスPに到達するために複数の合計が最小コストパスがある場合、INは、接頭辞P.に到達するためMRT島に対するループフリーではありませんその後、最小の総コストパスに関与プレフィックス広告のすべてのルータはPATH_HITS_ISLANDはP.に到達するためにループフリーとみなされるにするためにFalseに設定されていなければなりません。"
    },
    {
      "indent": 3,
      "text": "Note that there are other computations that could be used to determine if paths from a given IN _might_ pass through the MRT Island for a given prefix or destination. For example, a previous draft version of this document specified running the SPF algorithm on modified topology that treats the MRT Island as a single node (with intra-island links set to zero cost) in order to provide input to computations to determine if the path from IN to non-island destination hits the MRT Island in this modified topology. This computation is enough to guarantee that a path will not hit the MRT Island in the original topology. However, it is possible that a path that is disqualified for hitting the MRT Island in the modified topology will not actually hit the MRT Island in the original topology. The algorithm described in Island_Marking_SPF() above does not modify the original topology, and will only disqualify a path if the actual path does in fact hit the MRT Island.",
      "ja": "IN所与のパスが指定されたプレフィックスまたは宛先に対するMRT島通過_might_かどうかを決定するために使用することができる他の計算があることに注意してください。例えば、この文書の以前のドラフトバージョンがパスするかどうかを決定するための計算への入力を提供するために、（ゼロコストに設定イントラアイランドリンクを持つ）単一のノードとしてMRT島を扱う変性トポロジにSPFアルゴリズムを実行し、指定しましたINから非島の先には、この修正トポロジでMRT島に当たります。この計算は、パスは、元のトポロジでMRT島にヒットしないことを保証するのに十分です。しかし、修正トポロジでMRT島を打つために失格とされているパスが実際にオリジナルのトポロジでMRT島にヒットしない可能性があります。上記Island_Marking_SPFに記載されたアルゴリズムは、（）、元のトポロジを変更しないと、実際のパスは、実際にはMRT島を襲っない場合にのみ、パスを失格になります。"
    },
    {
      "indent": 3,
      "text": "Since all routers need to come to the same conclusion about which routers qualify as LFINs, this specification requires that all routers computing LFINs MUST use an algorithm whose result is identical to that of the Island_Marking_SPF() in Figure 27.",
      "ja": "すべてのルータがルータがLFINsとして適格かについて同じ結論に達する必要があるので、この仕様はLFINsを計算するすべてのルータは、その結果、図27にIsland_Marking_SPF（）のものと同一であるアルゴリズムを使用しなければならないことを要求します。"
    },
    {
      "indent": 0,
      "text": "5.9.3. Computing MRT Next Hops for Proxy-Nodes",
      "section_title": true,
      "ja": "5.9.3. プロキシノードのMRTネクストホップを計算"
    },
    {
      "indent": 3,
      "text": "Determining the MRT next hops for a proxy-node in the degenerate case where the proxy-node is attached to only one node in the GADAG is trivial, as all needed information can be derived from that proxy-node attachment router. If there are multiple interfaces connecting the proxy-node to the single proxy-node attachment router, then some can be assigned to MRT-Red and others to MRT_Blue.",
      "ja": "すべての必要な情報をそのプロキシノード取付ルータから誘導することができるようにプロキシノードはGADAGに1つのノードにだけ取り付けられている縮退場合にプロキシノードについてMRT次のホップを決定することは、自明です。単一のプロキシノードアタッチメントルータにプロキシノードを接続する複数のインタフェースがある場合、いくつかMRT_BlueにMRTレッド等に割り当てることができます。"
    },
    {
      "indent": 3,
      "text": "Now, consider the proxy-node P that is attached to two proxy-node attachment routers. The pseudocode for Select_Proxy_Node_NHs(P,S) in Figure 28 specifies how a computing-router S MUST compute the MRT red and blue next hops to reach proxy-node P. The proxy-node attachment router with the lower value of mrt_node_id (as defined in Figure 15) is assigned to X, and the other proxy-node attachment router is assigned to Y. We will be using the relative order of X,Y, and S in the partial order defined by the GADAG to determine the MRT red and blue next hops to reach P, so we also define A and B as the order proxies for X and Y, respectively, with respect to S. The order proxies for all nodes with respect to S were already computed in Compute_MRT_NextHops().",
      "ja": "さて、2プロキシノード接続ルータに接続されているプロキシノードPを考えます。次の定義されたようmrt_node_id（のより低い価値の代理ノードP.プロキシノード取付ルータに到達するためにホップ図28のSelect_Proxy_Node_NHs（P、S）のための擬似コードは、コンピューティング・ルータSは、MRT赤と青を計算しなければならない方法を指定します図15）においてXに割り当てられ、他のプロキシノードアタッチメントルータは、我々がMRT赤色を決定するGADAGによって定義された部分の順序でX、Y、およびSの相対的な順序を使用するYに割り当てられ、且つ青色次Pに到達するホップので、我々はまた、）Sに対するすべてのノードのためのプロキシが既に（Compute_MRT_NextHopsで計算されたSに対して、それぞれ、XおよびYためのプロキシとしてA及びBを定義します。"
    },
    {
      "indent": 1,
      "text": "def Select_Proxy_Node_NHs(P,S): if P.pnar1.node.node_id < P.pnar2.node.node_id: X = P.pnar1.node Y = P.pnar2.node else: X = P.pnar2.node Y = P.pnar1.node P.pnar_X = X P.pnar_Y = Y A = X.order_proxy B = Y.order_proxy if (A is S.localroot and B is S.localroot): // case 1.0 Copy_List_Items(P.blue_next_hops, X.blue_next_hops) Copy_List_Items(P.red_next_hops, Y.red_next_hops) return if (A is S.localroot and B is not S.localroot): // case 2.0 if B.LOWER: // case 2.1 Copy_List_Items(P.blue_next_hops, X.blue_next_hops) Copy_List_Items(P.red_next_hops, Y.red_next_hops) return if B.HIGHER: // case 2.2 Copy_List_Items(P.blue_next_hops, X.red_next_hops) Copy_List_Items(P.red_next_hops, Y.blue_next_hops) return else: // case 2.3 Copy_List_Items(P.blue_next_hops, X.red_next_hops) Copy_List_Items(P.red_next_hops, Y.red_next_hops) return if (A is not S.localroot and B is S.localroot): // case 3.0 if A.LOWER: // case 3.1 Copy_List_Items(P.blue_next_hops, X.red_next_hops) Copy_List_Items(P.red_next_hops, Y.blue_next_hops) return if A.HIGHER: // case 3.2 Copy_List_Items(P.blue_next_hops, X.blue_next_hops) Copy_List_Items(P.red_next_hops, Y.red_next_hops) return",
      "ja": "DEF Select_Proxy_Node_NHs（P、S）：他X = Y = P.pnar1.node P.pnar2.node：X = Y = P.pnar2.node P.pnar1.node.node_id <P.pnar2.node.node_id場合P.pnar1.nodeのP.pnar_X = X P.pnar_Y = YA = X.order_proxy B = Y.order_proxy場合（AがS.localrootであり、BはS.localrootある）：//場合1.0 Copy_List_Items（P.blue_next_hops、X .blue_next_hops）Copy_List_Items（P.red_next_hops、Y.red_next_hops）（A）はS.localroot S.localroot及びB戻った場合はされないで：//場合2.0 B.LOWER場合：//場合2.1 Copy_List_Items（P.blue_next_hops、X .blue_next_hops）Copy_List_Items（P.red_next_hops、Y.red_next_hops）リターンB.HIGHER場合：//ケース2.2 Copy_List_Items（P.blue_next_hops、X.red_next_hops）Copy_List_Items（P.red_next_hops、Y.blue_next_hopsは）他の返却：//ケース2.3 Copy_List_Items（P.blue_next_hops、X.red_next_hops）Copy_List_Items（P.red_next_hops、Y.red_next_hops）リターン場合（AがS.localrootではなく、BはS.localrootある）：//場合3.0 A.LOWER場合：//場合3.1 Copy_List_Items（P.blue_next_hops、X.red_next_hops）Copy_List_Items（P.red_next_hops 、Y.blue_next_hops）リターンA.HIGHER場合：//ケース3.2 Copy_List_Items（P.blue_next_hops、X.blue_next_hops）Copy_List_Items（P.red_next_hops、Y.red_next_hops）リターン"
    },
    {
      "indent": 5,
      "text": "    else:\n        // case 3.3\n        Copy_List_Items(P.blue_next_hops, X.red_next_hops)\n        Copy_List_Items(P.red_next_hops, Y.red_next_hops)\n        return\nif (A is not S.localroot\n    and B is not S.localroot):\n    // case 4.0\n    if (S is A.localroot or S is B.localroot):\n        // case 4.05\n        if A.topo_order < B.topo_order:\n            // case 4.05.1\n            Copy_List_Items(P.blue_next_hops, X.blue_next_hops)\n            Copy_List_Items(P.red_next_hops, Y.red_next_hops)\n            return\n        else:\n            // case 4.05.2\n            Copy_List_Items(P.blue_next_hops, X.red_next_hops)\n            Copy_List_Items(P.red_next_hops, Y.blue_next_hops)\n            return\n    if A.LOWER:\n        // case 4.1\n        if B.HIGHER:\n            // case 4.1.1\n            Copy_List_Items(P.blue_next_hops, X.red_next_hops)\n            Copy_List_Items(P.red_next_hops, Y.blue_next_hops)\n            return\n        if B.LOWER:\n            // case 4.1.2\n            if A.topo_order < B.topo_order:\n                // case 4.1.2.1\n                Copy_List_Items(P.blue_next_hops, X.blue_next_hops)\n                Copy_List_Items(P.red_next_hops, Y.red_next_hops)\n                return\n            else:\n                // case 4.1.2.2\n                Copy_List_Items(P.blue_next_hops, X.red_next_hops)\n                Copy_List_Items(P.red_next_hops, Y.blue_next_hops)\n                return\n        else:\n            // case 4.1.3\n            Copy_List_Items(P.blue_next_hops, X.red_next_hops)\n            Copy_List_Items(P.red_next_hops, Y.red_next_hops)\n            return\n    if A.HIGHER:\n        // case 4.2 if B.HIGHER:\n            // case 4.2.1\n            if A.topo_order < B.topo_order:\n                // case 4.2.1.1\n                Copy_List_Items(P.blue_next_hops, X.blue_next_hops)\n                Copy_List_Items(P.red_next_hops, Y.red_next_hops)\n                return\n            else:\n                // case 4.2.1.2\n                Copy_List_Items(P.blue_next_hops, X.red_next_hops)\n                Copy_List_Items(P.red_next_hops, Y.blue_next_hops)\n                return\n        if B.LOWER:\n            // case 4.2.2\n            Copy_List_Items(P.blue_next_hops, X.blue_next_hops)\n            Copy_List_Items(P.red_next_hops, Y.red_next_hops)\n            return\n        else:\n            // case 4.2.3\n            Copy_List_Items(P.blue_next_hops, X.blue_next_hops)\n            Copy_List_Items(P.red_next_hops, Y.blue_next_hops)\n            return\n    else:\n        // case 4.3\n        if B.LOWER:\n            // case 4.3.1\n            Copy_List_Items(P.blue_next_hops, X.red_next_hops)\n            Copy_List_Items(P.red_next_hops, Y.red_next_hops)\n            return\n        if B.HIGHER:\n            // case 4.3.2\n            Copy_List_Items(P.blue_next_hops, X.blue_next_hops)\n            Copy_List_Items(P.red_next_hops, Y.blue_next_hops)\n            return\n        else:\n            // case 4.3.3\n            if A.topo_order < B.topo_order:\n                // case 4.3.3.1\n                Copy_List_Items(P.blue_next_hops, X.blue_next_hops)\n                Copy_List_Items(P.red_next_hops, Y.red_next_hops)\n                return",
      "raw": true
    },
    {
      "indent": 5,
      "text": " else: // case 4.3.3.2 Copy_List_Items(P.blue_next_hops, X.red_next_hops) Copy_List_Items(P.red_next_hops, Y.blue_next_hops) return assert(False)",
      "ja": "他：//ケース4.3.3.2 Copy_List_Items（P.blue_next_hops、X.red_next_hops）Copy_List_Items（P.red_next_hops、Y.blue_next_hops）リターンのassert（偽）"
    },
    {
      "indent": 20,
      "text": "Figure 28: Select_Proxy_Node_NHs()",
      "ja": "図28：Select_Proxy_Node_NHs（）"
    },
    {
      "indent": 3,
      "text": "It is useful to understand up front that the blue next hops to reach proxy-node P produced by Select_Proxy_Node_NHs() will always be the next hops that reach proxy-node attachment router X, while the red next hops to reach proxy-node P will always be the next hops that reach proxy-node attachment router Y. This is different from the red and blue next hops produced by Compute_MRT_NextHops() where, for example, blue next hops to a destination that is ordered with respect to the source will always correspond to an INCREASING next hop on the GADAG. The exact choice of which next hops chosen by Select_Proxy_Node_NHs() as the blue next hops to reach P (which will necessarily go through X on its way to P) does depend on the GADAG, but the relationship is more complex than was the case with Compute_MRT_NextHops().",
      "ja": "青色次常にプロキシノードアタッチメントルータXに達し、次のホップであろう）（Select_Proxy_Node_NHsによって生成プロキシノードPに到達するホップこと赤色次代理ノードPに到達するためにホップしながら、前もって理解することは有用であるだろう常にこれはCompute_MRT_NextHops（によって生成赤と青の次のホップは異なる代理ノードアタッチメントルータY.に到達次ホップ）源に対して順序付けされた宛先に、例えば、青色の次ホップは常にあろうことGADAGにますます次ホップに対応します。正確な（必ずしもPへ向かう途中でXを通過します）Pに到達する青色の次ホップとして、次のホップがSelect_Proxy_Node_NHsによって選択された選択肢（）GADAGに依存しないが、関係の場合であったよりも複雑ですCompute_MRT_NextHops（）。"
    },
    {
      "indent": 3,
      "text": "There are 21 different relative order relationships between A, B, and S that Select_Proxy_Node_NHs() uses to determine red and blue next hops to P. This document does not attempt to provide an exhaustive description of each case considered in Select_Proxy_Node_NHs(). Instead, we provide a high-level overview of the different cases, and we consider a few cases in detail to give an example of the reasoning that can be used to understand each case.",
      "ja": "この文書はSelect_Proxy_Node_NHsで考慮各ケース（）の網羅的な説明を提供しようとしないSelect_Proxy_Node_NHs（）はP.に赤と青の次のホップを決定するために使用する21人の異なる相対順序A、B間の関係、およびSがあります。代わりに、我々は異なる例高レベルの概要を提供し、私たちは、それぞれのケースを理解するために使用することができます推論の例を与えることを詳細にいくつかの例を考えてみましょう。"
    },
    {
      "indent": 3,
      "text": "At the highest level, Select_Proxy_Node_NHs() distinguishes between four different cases depending on whether or not A or B is the localroot for S. For example, for case 4.0, neither A nor B is the localroot for S. Case 4.05 addresses the case where S is the localroot for either A or B, while cases 4.1, 4.2, and 4.3 address the cases where A is ordered lower than S, A is ordered higher than S, or A is unordered with respect to S on the GADAG. In general, each of these cases is then further subdivided into whether or not B is ordered lower than S, B is ordered higher than S, or B is unordered with respect to S. In some cases, we also need a further level of discrimination, where we use the topological sort order of A with respect to B.",
      "ja": "最高レベルでは、Select_Proxy_Node_NHs（）はAまたはBは、例えばS.ためlocalrootであるか否かに応じて、四つの異なるケースを区別し、ケース4.0、AもBもがS.場合のlocalroot 4.05アドレス場合でありますSは、AまたはBのいずれかのためにlocalrootであり、ケース4.1、4.2、および4.3アドレスAがSよりも低く順序付けされる場合ながら、Aは、Sよりも高くを命じ、又はAはGADAGにSに対して順不同です。一般に、これらのケースのそれぞれは、その後さらにSよりも低く順序付けられたか否かBに細分され、BがSより高く順序付けされるか、またはBは、いくつかの場合においてSに対して順不同であり、我々はまた、差別のさらなるレベルを必要とします、我々は、Bに対するAのトポロジカルソート順を使用します。ここで、"
    },
    {
      "indent": 3,
      "text": "As a detailed example, let's consider case 4.1 and all of its sub-cases, and explain why the red and blue next hops to reach P are chosen as they are in Select_Proxy_Node_NHs(). In case 4.1, neither A nor B is the localroot for S, S is not the localroot for A or B, and A is ordered lower than S on the GADAG. In this situation, we know that the red path to reach X (as computed in Compute_MRT_NextHops()) will follow DECREASING next hops towards A, while the blue path to reach X will follow INCREASING next hops to the localroot, and then INCREASING next hops to A.",
      "ja": "具体的な例として、のは、ケース4.1およびそのサブ例すべてを考えてみましょう、と彼らはSelect_Proxy_Node_NHsであるとして、赤と青の次のホップが（）選択されているPに到達するために理由を説明します。ケース4.1では、AもBもがSためlocalrootであり、Sは、AまたはBのためlocalrootなく、AはGADAGにSよりも低くなっております。この状況では、我々はXに到達する青色パスはlocalrootに次のホップを増加し、次のホップを増加続くながら、Aに向かって次のホップを減少続く赤色パスは（Compute_MRT_NextHops（で計算されるように））Xに到達することを知っていますA.へ"
    },
    {
      "indent": 3,
      "text": "Now consider sub-case 4.1.1 where B is ordered higher than S. In this situation, we know that the blue path to reach Y will follow INCREASING next hops towards B, while the red next hops to reach Y will follow DECREASING next hops to the localroot, and then DECREASING next hops to B. So, to reach X and Y by two disjoint paths, we can choose the red next hops to X and the blue next hops to Y. We have chosen the convention that blue next hops to P are those that pass through X, and red next hops to P are those that pass through Y, so we can see that case 4.1.1 produces the desired result. Choosing blue to X and red to Y does not produce disjoint paths because the paths intersect at least at the localroot.",
      "ja": "今、Bがこのような状況では、Sよりも高い注文されるサブケース4.1.1を考え、私たちは、次の赤はYは次のホップを減少続く到達するためにホップしながら、Yに到達する青色のパスは、Bに向けて次のホップを増やす続くことを知っていますlocalrootに、そして2つの互いに素の経路によって、XとYに到達するために、だから、Bに次のホップを下げ、私たちは青いネクストホップという慣例を選択したYにXと青の次のホップに赤い次のホップを選択することができますPにXを通過するものであり、そしてPに赤色次ホップはYを通過するものであるので、我々はその場合4.1.1は、所望の結果を生成見ることができます。 YのX及び赤青選択パスが少なくともlocalrootで交差するため、ばらばらの経路を生成しません。"
    },
    {
      "indent": 3,
      "text": "Now consider sub-case 4.1.2 where B is ordered lower than S. In this situation, we know that the red path to reach Y will follow DECREASING next hops towards B, while the BLUE next hops to reach Y will follow INCREASING next hops to the localroot, and then INCREASING next hops to A. The choice here is more difficult than in 4.1.1 because A and B are both on the DECREASING path from S towards the localroot. We want to use the direct DECREASING(red) path to the one that is nearer to S on the GADAG. We get this extra information by comparing the topological sort order of A and B. If A.topo_order<B.topo_order, then we use red to Y and blue to X, since the red path to Y will DECREASE to B without hitting A, and the blue path to X will INCREASE to A without hitting B. Instead, if A.topo_order>B.topo_order, then we use red to X and blue to Y.",
      "ja": "今、Bがこのような状況では、Sよりも低く注文されるサブケース4.1.2を考え、私たちはBLUEは、次のYは、次のホップを増やす従います到達するためにホップしながら、Yに到達するための赤いパスは、Bに向けて次のホップを減少続くことを知っていますlocalrootに、そして次にAとBの両方がlocalroot向かっSから減少する経路上にあるので、選択はここ4.1.1よりも困難であるAに次のホップを増加させます。私たちは、近いGADAG上のSにあるものに直接減少（赤）のパスを使用します。私たちは、Yへの赤いパスがAを押すことなくBに減少しますので、我々は、Yに赤とXに青を使用、AとBの場合A.topo_order <B.topo_orderのトポロジカルソート順を比較することによって、この追加情報を取得します、その後、我々はYにXに赤と青を使用A.topo_order> B.topo_order場合とXへの青のパスは、代わりにBを押すことなくに増加します"
    },
    {
      "indent": 3,
      "text": "Note that when A is unordered with respect to B, the result of comparing A.topo_order with B.topo_order could be greater than or less than. In this case, the result doesn't matter because either choice (red to Y and blue to X or red to X and blue to Y) would work. What is required is that all nodes in the network give the same result when comparing A.topo_order with B.topo_order. This is guaranteed by having all nodes run the same algorithm (Run_Topological_Sort_GADAG()) to compute the topological sort order.",
      "ja": "AがBに対して順序付けられていないとき、B.topo_orderとA.topo_orderを比較した結果がより大きいかまたはより小さくなることに留意されたいです。選択肢（赤YへとYとXに青やXに赤と青）のいずれかが動作しますので、この場合、結果は重要ではありません。必要なのは、ネットワーク内のすべてのノードがB.topo_orderでA.topo_orderを比較し、同じ結果を与えるということです。これは、トポロジカルソート順を計算するために、すべてのノードが同じアルゴリズム（Run_Topological_Sort_GADAGを（））を実行することによって保証されています。"
    },
    {
      "indent": 3,
      "text": "Finally, we consider case 4.1.3, where B is unordered with respect to S. In this case, the blue path to reach Y will follow the DECREASING next hops towards the localroot until it reaches some node (K) which is ordered less than B, after which it will take INCREASING next hops to B. The red path to reach Y will follow the INCREASING next hops towards the localroot until it reaches some node (L) which is ordered greater than B, after which it will take DECREASING next hops to B.",
      "ja": "最後に、我々は、Bは、この場合、S.に関して順不同である場合4.1.3を考えることがより少ない順序付けされ、いくつかのノード（K）に達するまで、青色の経路は、Yがlocalrootに向かって減少次のホップに従う到達しますそれがBより大きい順序付けされるいくつかのノード（L）に達するまで、それがYに到達するためにB.赤色パスを増加次ホップを取るその後Bは、localroot向かっINCREASING次ホップに従う、それは次の低下になりますその後B.までのホップ"
    },
    {
      "indent": 3,
      "text": "Both K and A are reached by DECREASING from S, but we don't have information about whether or not that DECREASING path will hit K or A first. Instead, we do know that the INCREASING path from S will hit L before reaching A. Therefore, we use the red path to reach Y and the red path to reach X.",
      "ja": "KとAの両方がSから減少させることによって到達されているが、我々はパスを減少させるとKまたは最初にヒットするものかどうかについての情報を持っていません。代わりに、我々はXに到達するためにYと赤のパスに到達するために赤のパスを使用し、SからINCREASINGパスは、そのためAに到達する前にLをヒットすることを知っています"
    },
    {
      "indent": 3,
      "text": "Similar reasoning can be applied to understand the other 17 cases used in Select_Proxy_Node_NHs(). However, cases 2.3 and 3.3 deserve special attention because the correctness of the solution for these two cases relies on a special property of the GADAGs that we have constructed in this algorithm, a property not shared by all GADAGs in general. Focusing on case 2.3, we consider the case where A is the localroot for S, while B is not, and B is unordered with respect to S. The red path to X DECREASES from S to the localroot A, while the blue path to X INCREASES from S to the localroot A. The blue path to Y DECREASES towards the localroot A until it reaches some node (K) which is ordered less than B, after which the path INCREASES to B. The red path to Y INCREASES towards the localroot A until it reaches some node (L) which is ordered greater than B, after which the path DECREASES to B. It can be shown that for an arbitrary GADAG, with only the ordering relationships computed so far, we don't have enough information to choose a pair of paths to reach X and Y that are guaranteed to be disjoint. In some topologies, A will play the role of K, the first node ordered less than B on the blue path to Y. In other topologies, A will play the role of L, the first node ordered greater than B on the red path to Y. The basic problem is that we cannot distinguish between these two cases based on the ordering relationships.",
      "ja": "同様の推論）は（Select_Proxy_Node_NHsに使用される他の17例を理解するために適用することができます。これらの2つの場合のためのソリューションの正しさは、我々は、このアルゴリズムで構築されているGADAGsの特殊な性質、一般的にはすべてのGADAGsによって共有されていない性質に依存しているのでしかし、例2.3および3.3には、特別な注意に値します。 Bはなく、BがSに対して順不同である場合2.3に焦点を当て、我々は、Aは、Sのためにlocalrootである場合を考慮し、X赤パスはX青色パスしながら、Sからlocalroot Aに減少しますそれがB未満を命じているいくつかのノード（K）に達するまでSからlocalroot Aに増加しY青色パスはlocalrootのAに向かって減少する、パスはBに増加する後Yに赤色のパスはlocalrootに向かって増大しますそれはBより大きい注文されるいくつかのノード（L）に達するまで、パスがBに減少した後任意GADAGのために、これまでに計算された唯一の順序関係で、私たちは十分な情報を持っていないことを示すことができます互いに素であることが保証されているXとYに到達するためのパスのペアを選択します。一部のトポロジでは、Aは、Kの役割を担う、最初のノードが、他のトポロジでYに青色の経路上B未満を命じ、Aは、Lの役割を担う、最初のノードは赤の経路上にBより大きい順序付けY.は、基本的な問題は、我々は順序関係に基づいて、この2つのケースを区別することができないということです。"
    },
    {
      "indent": 3,
      "text": "As discussed Section 5.8, the GADAGs that we construct using the algorithm in this document are not arbitrary GADAGs. They have the additional property that incoming links to a localroot come from only one other node in the same block. This is a result of the method of construction. This additional property guarantees that localroot A will never play the role of L in the red path to Y, since L must have at least two incoming links from different nodes in the same block in the GADAG. This, in turn, allows Select_Proxy_Node_NHs() to choose the red path to Y and the red path to X as the disjoint MRT paths to reach P.",
      "ja": "議論のセクション5.8のように、我々は、この文書に記載されているアルゴリズムを使用して構築GADAGsは任意GADAGsではありません。彼らはlocalrootへの着信リンクが同じブロック内でのみ1つの他のノードから来る追加のプロパティを持っています。これは、構築の方法の結果です。 LはGADAGの同じブロック内の各ノードから少なくとも2つの入力リンクを持たなければならないので、Aは、Yに赤のパスにLの役割を果たしていることはありませんlocalrootこの追加のプロパティを保証します。これは、順番に、Select_Proxy_Node_NHs（）はYに赤色パスおよびP.に到達する互いに素MRTパスとしてX赤色パスを選択することを可能にします"
    },
    {
      "indent": 0,
      "text": "5.9.4. Computing MRT Alternates for Proxy-Nodes",
      "section_title": true,
      "ja": "5.9.4. プロキシノードのコンピューティングMRTのAlternates"
    },
    {
      "indent": 3,
      "text": "After finding the red and the blue next hops for a given proxy-node P, it is necessary to know which one of these to use in the case of failure. This can be done by Select_Alternates_Proxy_Node(), as shown in the pseudocode in Figure 29.",
      "ja": "指定されたプロキシノードPのための赤と青の次のホップを発見した後、これらのいずれかが故障した場合に使用するかを知る必要があります。図29の擬似コードに示すように、これは、Select_Alternates_Proxy_Node（）によって行うことができます。"
    },
    {
      "indent": 2,
      "text": "def Select_Alternates_Proxy_Node(P,F,primary_intf): S = primary_intf.local_node X = P.pnar_X Y = P.pnar_Y A = X.order_proxy B = Y.order_proxy if F is A and F is B: return 'PRIM_NH_IS_OP_FOR_BOTH_X_AND_Y' if F is A: return 'USE_RED' if F is B: return 'USE_BLUE'",
      "ja": "DEF Select_Alternates_Proxy_Node（P、F、primary_intf）：S = primary_intf.local_node X = Y = P.pnar_X P.pnar_Y A = B = X.order_proxy Y.order_proxy Fである場合、A及びFはBである：復帰 'PRIM_NH_IS_OP_FOR_BOTH_X_AND_Y' Fもしリターン「USE_RED」FがBがある場合：リターン「USE_BLUE」です"
    },
    {
      "indent": 6,
      "text": "if not In_Common_Block(A, B):\n    if In_Common_Block(F, A):\n        return 'USE_RED'\n    elif In_Common_Block(F, B):\n        return 'USE_BLUE'\n    else:\n        return 'USE_RED_OR_BLUE'\nif (not In_Common_Block(F, A)\n    and not In_Common_Block(F, A) ):\n    return 'USE_RED_OR_BLUE'",
      "raw": true
    },
    {
      "indent": 6,
      "text": "alt_to_X = Select_Alternates(X, F, primary_intf) alt_to_Y = Select_Alternates(Y, F, primary_intf)",
      "ja": "alt_to_X = Select_Alternates（X、F、primary_intf）alt_to_Y = Select_Alternates（Y、F、primary_intf）"
    },
    {
      "indent": 6,
      "text": "if (alt_to_X == 'USE_RED_OR_BLUE' and alt_to_Y == 'USE_RED_OR_BLUE'): return 'USE_RED_OR_BLUE' if alt_to_X == 'USE_RED_OR_BLUE': return 'USE_BLUE' if alt_to_Y == 'USE_RED_OR_BLUE': return 'USE_RED'",
      "ja": "もし（alt_to_X == 'USE_RED_OR_BLUE' とalt_to_Y == 'USE_RED_OR_BLUE'）：リターン 'USE_RED_OR_BLUE' もしalt_to_X == 'USE_RED_OR_BLUE'：リターン 'USE_BLUE' もしalt_to_Y == 'USE_RED_OR_BLUE'：リターン 'USE_RED'"
    },
    {
      "indent": 6,
      "text": "if (A is S.localroot and B is S.localroot): // case 1.0 if (alt_to_X == 'USE_BLUE' and alt_to_Y == 'USE_RED'): return 'USE_RED_OR_BLUE' if alt_to_X == 'USE_BLUE': return 'USE_BLUE' if alt_to_Y == 'USE_RED': return 'USE_RED' assert(False) if (A is S.localroot and B is not S.localroot): // case 2.0 if B.LOWER: // case 2.1 if (alt_to_X == 'USE_BLUE' and alt_to_Y == 'USE_RED'): return 'USE_RED_OR_BLUE' if alt_to_X == 'USE_BLUE': return 'USE_BLUE' if alt_to_Y == 'USE_RED': return 'USE_RED' assert(False) if B.HIGHER: // case 2.2 if (alt_to_X == 'USE_RED' and alt_to_Y == 'USE_BLUE'): return 'USE_RED_OR_BLUE' if alt_to_X == 'USE_RED': return 'USE_BLUE' if alt_to_Y == 'USE_BLUE': return 'USE_RED' assert(False) else: // case 2.3 if (alt_to_X == 'USE_RED' and alt_to_Y == 'USE_RED'): return 'USE_RED_OR_BLUE' if alt_to_X == 'USE_RED': return 'USE_BLUE' if alt_to_Y == 'USE_RED': return 'USE_RED' assert(False) if (A is not S.localroot and B is S.localroot): // case 3.0 if A.LOWER: // case 3.1 if (alt_to_X == 'USE_RED' and alt_to_Y == 'USE_BLUE'): return 'USE_RED_OR_BLUE' if alt_to_X == 'USE_RED': return 'USE_BLUE' if alt_to_Y == 'USE_BLUE': return 'USE_RED' assert(False) if A.HIGHER: // case 3.2 if (alt_to_X == 'USE_BLUE' and alt_to_Y == 'USE_RED'): return 'USE_RED_OR_BLUE' if alt_to_X == 'USE_BLUE': return 'USE_BLUE' if alt_to_Y == 'USE_RED': return 'USE_RED' assert(False)",
      "ja": "（AはS.localrootであり、BはS.localrootある）場合：//場合1.0であれば（alt_to_X == 'USE_BLUE' とalt_to_Y == 'USE_RED'）：リターン 'USE_RED_OR_BLUE' もしalt_to_X == 'USE_BLUE'：リターン ' USE_BLUE」もしalt_to_Y == 'USE_RED'：リターン '（AはS.localrootであり、BはS.localrootない）場合USE_RED' アサート（偽）：//場合2.0場合B.LOWER：//場合2.1であれば（alt_to_X == 'USE_BLUE' とalt_to_Y == 'USE_RED'）：リターン 'USE_RED_OR_BLUE' もしalt_to_X == 'USE_BLUE'：リターン 'USE_BLUE' もしalt_to_Y == 'USE_RED'：リターン 'USE_RED' アサート（偽）の場合B.HIGHER ：//ケース2.2場合（alt_to_X == 'USE_RED' とalt_to_Y == 'USE_BLUE'）：リターン 'USE_RED_OR_BLUE' もしalt_to_X == 'USE_RED'：リターン 'USE_BLUE' もしalt_to_Y == 'USE_BLUE'：リターン 'USE_RED'それ以外（偽）をアサート：//ケース2.3の場合（alt_to_X == 'USE_RED' とalt_to_Y == 'USE_RED'）：リターン 'USE_RED_OR_BLUE' もしalt_to_X == 'USE_RED'：リターン 'USE_BLUE' もしalt_to_Y == 'USE_RED' ：リターン 'USE_RED' アサート（偽）（AはS.localrootではなく、BがS.localrootある）場合：//ケース3.0場合A.LOWER：//ケース3.1（ALT場合_to_X == 'USE_RED' とalt_to_Y == 'USE_BLUE'）：リターン 'USE_RED_OR_BLUE' もしalt_to_X == 'USE_RED'：A.もし復帰 'USE_RED' アサート（偽）：リターン 'USE_BLUE' もしalt_to_Y == 'USE_BLUE' HIGHER：//ケース3.2の場合（alt_to_X == 'USE_BLUE' とalt_to_Y == 'USE_RED'）：リターン 'USE_RED_OR_BLUE' もしalt_to_X == 'USE_BLUE'：リターン 'USE_BLUE' もしalt_to_Y == 'USE_RED'：リターン「USE_RED 「アサート（偽）"
    },
    {
      "indent": 6,
      "text": " else: // case 3.3 if (alt_to_X == 'USE_RED' and alt_to_Y == 'USE_RED'): return 'USE_RED_OR_BLUE' if alt_to_X == 'USE_RED': return 'USE_BLUE' if alt_to_Y == 'USE_RED': return 'USE_RED' assert(False) if (A is not S.localroot and B is not S.localroot): // case 4.0 if (S is A.localroot or S is B.localroot): // case 4.05 if A.topo_order < B.topo_order: // case 4.05.1 if (alt_to_X == 'USE_BLUE' and alt_to_Y == 'USE_RED'): return 'USE_RED_OR_BLUE' if alt_to_X == 'USE_BLUE': return 'USE_BLUE' if alt_to_Y == 'USE_RED': return 'USE_RED' assert(False) else: // case 4.05.2 if (alt_to_X == 'USE_RED' and alt_to_Y == 'USE_BLUE'): return 'USE_RED_OR_BLUE' if alt_to_X == 'USE_RED': return 'USE_BLUE' if alt_to_Y == 'USE_BLUE': return 'USE_RED' assert(False) if A.LOWER: // case 4.1 if B.HIGHER: // case 4.1.1 if (alt_to_X == 'USE_RED' and alt_to_Y == 'USE_BLUE'): return 'USE_RED_OR_BLUE' if alt_to_X == 'USE_RED': return 'USE_BLUE' if alt_to_Y == 'USE_BLUE': return 'USE_RED' assert(False) if B.LOWER: // case 4.1.2 if A.topo_order < B.topo_order: // case 4.1.2.1 if (alt_to_X == 'USE_BLUE'",
      "ja": "他：//ケース3.3の場合（alt_to_X == 'USE_RED' とalt_to_Y == 'USE_RED'）：リターン 'USE_RED_OR_BLUE' もしalt_to_X == 'USE_RED'：リターン 'USE_BLUE' もしalt_to_Y == 'USE_RED'：リターン「USE_RED '（AはS.localrootではなく、BがS.localrootない）場合（False）がアサート：//場合4.0場合（SはA.localroot又はSであるがB.localrootある）：//ケース4.05場合A.topo_order < B.topo_order：//ケース4.05.1もし（alt_to_X == 'USE_BLUE' とalt_to_Y == 'USE_RED'）：リターン 'USE_RED_OR_BLUE' もしalt_to_X == 'USE_BLUE'：リターン 'USE_BLUE' もしalt_to_Y == 'USE_RED' ：リターン他に 'USE_RED' アサート（偽）：//ケース4.05.2もし（alt_to_X == 'USE_RED' とalt_to_Y == 'USE_BLUE'）：リターン 'USE_RED_OR_BLUE' alt_to_X == 'USE_RED' の場合：リターン 'USE_BLUE' alt_to_Y == 'USE_BLUE' の場合：もし（偽）リターン 'USE_RED' アサートA.LOWER：//ケース4.1 B.HIGHERの場合：//ケース4.1.1であれば（alt_to_X == 'USE_RED' とalt_to_Y ==「USE_BLUE 「）：リターン 'USE_RED_OR_BLUE' もしalt_to_X == 'USE_RED'：リターン 'USE_BLUE' もしalt_to_Y == 'USE_BLUE'：リターン 'USE_RED' アサート）（偽B.LOWER場合：// CA SE 4.1.2 A.topo_order <B.topo_order場合：//ケース4.1.2.1であれば（alt_to_X == 'USE_BLUE'"
    },
    {
      "indent": 10,
      "text": "                and alt_to_Y == 'USE_RED'):\n                return 'USE_RED_OR_BLUE'\n            if alt_to_X == 'USE_BLUE':\n                return 'USE_BLUE'\n            if alt_to_Y == 'USE_RED':\n                return 'USE_RED'\n            assert(False)\n        else:\n            // case 4.1.2.2\n            if (alt_to_X == 'USE_RED'\n                and alt_to_Y == 'USE_BLUE'):\n                return 'USE_RED_OR_BLUE'\n            if alt_to_X == 'USE_RED':\n                return 'USE_BLUE'\n            if alt_to_Y == 'USE_BLUE':\n                return 'USE_RED'\n            assert(False)\n    else:\n        // case 4.1.3\n        if (F.LOWER and not F.HIGHER\n            and F.topo_order > A.topo_order):\n            // case 4.1.3.1\n            return 'USE_RED'\n        else:\n            // case 4.1.3.2\n            return 'USE_BLUE'\nif A.HIGHER:\n    // case 4.2\n    if B.HIGHER:\n        // case 4.2.1\n        if A.topo_order < B.topo_order:\n            // case 4.2.1.1\n            if (alt_to_X == 'USE_BLUE'\n                and alt_to_Y == 'USE_RED'):\n                return 'USE_RED_OR_BLUE'\n            if alt_to_X == 'USE_BLUE':\n                return 'USE_BLUE'\n            if alt_to_Y == 'USE_RED':\n                return 'USE_RED'\n            assert(False)\n        else:\n            // case 4.2.1.2\n            if (alt_to_X == 'USE_RED'\n                and alt_to_Y == 'USE_BLUE'):\n                return 'USE_RED_OR_BLUE'\n            if alt_to_X == 'USE_RED':\n                return 'USE_BLUE'\n            if alt_to_Y == 'USE_BLUE':",
      "raw": true
    },
    {
      "indent": 10,
      "text": " return 'USE_RED' assert(False) if B.LOWER: // case 4.2.2 if (alt_to_X == 'USE_BLUE' and alt_to_Y == 'USE_RED'): return 'USE_RED_OR_BLUE' if alt_to_X == 'USE_BLUE': return 'USE_BLUE' if alt_to_Y == 'USE_RED': return 'USE_RED' assert(False) else: // case 4.2.3 if (F.HIGHER and not F.LOWER and F.topo_order < A.topo_order): return 'USE_RED' else: return 'USE_BLUE' else: // case 4.3 if B.LOWER: // case 4.3.1 if (F.LOWER and not F.HIGHER and F.topo_order > B.topo_order): return 'USE_BLUE' else: return 'USE_RED' if B.HIGHER: // case 4.3.2 if (F.HIGHER and not F.LOWER and F.topo_order < B.topo_order): return 'USE_BLUE' else: return 'USE_RED' else: // case 4.3.3 if A.topo_order < B.topo_order: // case 4.3.3.1 if (alt_to_X == 'USE_BLUE' and alt_to_Y == 'USE_RED'): return 'USE_RED_OR_BLUE' if alt_to_X == 'USE_BLUE': return 'USE_BLUE' if alt_to_Y == 'USE_RED': return 'USE_RED' assert(False)",
      "ja": "リターン 'USE_RED' アサート（偽）の場合B.LOWER：//ケース4.2.2であれば（alt_to_X == 'USE_BLUE' とalt_to_Y == 'USE_RED'）：リターン 'USE_RED_OR_BLUE' もしalt_to_X == 'USE_BLUE'：リターン \" USE_BLUE」もしalt_to_Y == 'USE_RED'：リターン 'USE_RED' 他のassert（偽）：//ケース4.2.3であれば（F.HIGHERなくF.LOWERとF.topo_order <A.topo_order）：リターン 'USE_RED'他：他のリターン 'USE_BLUE'：//ケース4.3 B.LOWERの場合：//ケース4.3.1（F.LOWERなくF.HIGHERとF.topo_order> B.topo_order）の場合：戻り 'USE_BLUE' 他：リターンB.HIGHER場合は、 'USE_RED'：//ケース4.3.2であれば（F.HIGHERなくF.LOWERとF.topo_order <B.topo_order）：他のリターン 'USE_BLUE'：リターン 'USE_RED' 他：//ケース4.3 0.3の場合A.topo_order <B.topo_order：//ケース4.3.3.1であれば（alt_to_X == 'USE_BLUE' とalt_to_Y == 'USE_RED'）：リターン 'USE_RED_OR_BLUE' もしalt_to_X == 'USE_BLUE'：リターン 'USE_BLUE' alt_to_Y == 'USE_RED' の場合：リターン 'USE_RED' アサート（偽）"
    },
    {
      "indent": 6,
      "text": " else: // case 4.3.3.2 if (alt_to_X == 'USE_RED' and alt_to_Y == 'USE_BLUE'): return 'USE_RED_OR_BLUE' if alt_to_X == 'USE_RED': return 'USE_BLUE' if alt_to_Y == 'USE_BLUE': return 'USE_RED' assert(False) assert(False)",
      "ja": "他：//ケース4.3.3.2であれば（alt_to_X == 'USE_RED' とalt_to_Y == 'USE_BLUE'）：リターン 'USE_RED_OR_BLUE' もしalt_to_X == 'USE_RED'：リターン 'USE_BLUE' もしalt_to_Y == 'USE_BLUE'：リターン'USE_RED' アサート（False）がアサート（偽）"
    },
    {
      "indent": 17,
      "text": "Figure 29: Select_Alternates_Proxy_Node()",
      "ja": "図29：Select_Alternates_Proxy_Node（）"
    },
    {
      "indent": 3,
      "text": "Select_Alternates_Proxy_Node(P,F,primary_intf) determines whether it is safe to use the blue path to P (which goes through X), the red path to P (which goes through Y), or either, when the primary_intf to node F (and possibly node F) fails. The basic approach is to run Select_Alternates(X,F,primary_intf) and Select_Alternates(Y,F,primary_intf) to determine which of the two MRT paths to X and which of the two MRT paths to Y is safe to use in the event of the failure of F. In general, we will find that if it is safe to use a particular path to X or Y when F fails, and Select_Proxy_Node_NHs() used that path when constructing the red or blue path to reach P, then it will also be safe to use that path to reach P when F fails. This rule has one exception which is covered below. First, we give a concrete example of how Select_Alternates_Proxy_Node() works in the common case.",
      "ja": "Select_Alternates_Proxy_Nodeは（Pは、F、primary_intf）は、primary_intfはFをノードに（X通過する）P（Y通過する）P、又はいずれかの赤パス、青色パスを使用しても安全であるか否かを判断する（及びおそらくノードF）が失敗します。基本的なアプローチは、の場合に使用しても安全であるXへの2つのMRT経路のどのとYへの2つのMRT経路のかを決定するためにSelect_Alternates（X、F、primary_intf）及びSelect_Alternates（Y、F、primary_intf）を実行することですPに到達するために赤や青のパスを構築する際に一般的にFの故障、我々はFが失敗したときにXまたはYへの特定のパスを使用しても安全である場合がわかります、そしてSelect_Proxy_Node_NHs（）は、そのパスを使用する、それは意志また、Fが失敗したときにPに到達するためにそのパスを使用して安全です。この規則は、以下覆われている一つの例外があります。まず、我々はSelect_Alternates_Proxy_Node（）は、一般的なケースでどのように機能するかの具体的な例を与えます。"
    },
    {
      "indent": 3,
      "text": "The 21 ordering relationships used in Select_Proxy_Node_NHs() are repeated in Select_Alternates_Proxy_Node(). We focus on case 4.1.1 to give a detailed example of the reasoning used in Select_Alternates_Proxy_Node(). In Select_Proxy_Node_NHs(), we determined for case 4.1.1 that the red next hops to X and the blue next hops to Y allow us to reach X and Y by disjoint paths, and are thus the blue and red next hops to reach P. Therefore, if Select_Alternates(X, F, primary_intf) is run and we find that it is safe to USE_RED to reach X, then we also conclude that it is safe to use the MRT path through X to reach P (the blue path to P) when F fails. Similarly, if we run Select_Alternates(Y, F, primary_intf) and we find that it is safe to USE_BLUE to reach Y, then we also conclude that it is safe to use the MRT path through Y to reach P (the red path to P) when F fails. If both of the paths that were used in Select_Proxy_Node_NHs() to construct the blue and red paths to P are found to be safe to use to use to reach X and Y, t then we conclude that we can use either the red or the blue path to P.",
      "ja": "Select_Proxy_Node_NHsで使用される21人の順序関係は、（））（Select_Alternates_Proxy_Nodeで繰り返されています。我々はSelect_Alternates_Proxy_Nodeで使用される推論（）の具体例を与える場合4.1.1に焦点を当てます。 Select_Proxy_Node_NHs（）において、我々は、ケースのために決定された次P.に到達するホップたちがばらばらパスによってX及びYに到達することを可能にするYとXと青次のホップへの赤次ホップ4.1.1ので、青と赤Select_Alternates（X、F、primary_intf）を実行し、我々はXに到達するためにUSE_REDに安全であることを発見した場合ので、我々はまた、Pに到達するためにXを通じてMRTパスを使用しても安全であると結論付け（Pへの青のパス）Fが失敗したとき。同様に、我々はSelect_Alternates（Y、F、primary_intf）を実行し、我々は我々はまた、P（Pへの赤いパスに到達するためにYを通じてMRTパスを使用しても安全であると結論付けて、Yに到達するためにUSE_BLUEしても安全であることを発見した場合）Fが失敗したとき。 Select_Proxy_Node_NHs（に使用したパスの両方）Pに青と赤の経路を構築するためには、XとYに到達するために使用するために使用しても安全であることが判明している場合、Tは、その後、我々は赤または青のいずれかを使用することができると結論しますP.へのパス"
    },
    {
      "indent": 3,
      "text": "This simple reasoning gives the correct answer in most of the cases. However, additional logic is needed when either A or B (but not both A and B) is unordered with respect to S. This applies to cases 4.1.3, 4.2.3, 4.3.1, and 4.3.2. Looking at case 4.1.3 in more detail, A is ordered less than S, but B is unordered with respect to S. In the discussion of case 4.1.3 above, we saw that Select_Proxy_Node_NHs() chose the red path to reach Y and the red path to reach X. We also saw that the red path to reach Y will follow the INCREASING next hops towards the localroot until it reaches some node (L) which is ordered greater than B, after which it will take DECREASING next hops to B. The problem is that the red path to reach P (the one that goes through Y) won't necessarily be the same as the red path to reach Y. This is because the next hop that node L computes for its red next hop to reach P may be different from the next hop it computes for its red next hop to reach Y. This is because B is ordered lower than L, so L applies case 4.1.2 of Select_Proxy_Node_NHs() in order to determine its next hops to reach P. If A.topo_order<B.topo_order (case 4.1.2.1), then L will choose DECREASING next hops directly to B, which is the same result that L computes in Compute_MRT_NextHops() to reach Y. However, if A.topo_order>B.topo_order (case 4.1.2.2), then L will choose INCREASING next hops to reach B, which is different from what L computes in Compute_MRT_NextHops() to reach Y. So, testing the safety of the path for S to reach Y on failure of F as a surrogate for the safety of using the red path to reach P is not reliable in this case. It is possible construct topologies where the red path to P hits F even though the red path to Y does not hit F.",
      "ja": "この単純な理由はほとんどの場合、正しい答えを与えます。 AまたはB（両方ではないA及びB）のいずれかこれは場合4.1.3、4.2.3、4.3.1および4.3.2に適用S.に対して順不同である場合しかし、追加のロジックが必要とされます。より詳細にケース4.1.3を見て、AがS未満を命じているが、Bは上記ケース4.1.3の議論においてS.に関して順不同であり、我々はSelect_Proxy_Node_NHs（）がYに到達する赤パスを選択したことを見て、それが次のホップ減少なりますそのあと赤いパスそれがBより大きい注文されるいくつかのノード（L）に達するまで、我々はまた、赤のパスがYに到達することを見たX.がlocalrootに向けてINCREASING次のホップに従います到達するために、 B.問題が赤色パスがP（Y通過するもの）に到達するために必ずしもY.に到達する赤色パスと同じではないということであるこれは、ノードLは、その赤次のホップのために計算したネクストホップPは、次それはBがLよりも低く順序付けされるからであるYを達するために、その赤色次のホップのために計算ホップ異なっていてもよい到達するので、Lは、（Select_Proxy_Node_NHsの場合4.1.2を適用）への次のホップを決定するためにA.topo_order <B.topo_order（ケース4.1.2.1）は、その後、LはBに直接次のホップを減少させる選択する場合はPに到達Compute_MRT_NextHopsに計算何L異なるLはA.topo_order> B.topo_order（ケース4.1.2.2）は、その後、LはBに到達するための次のホップを増加選択する場合、しかし、Y.に到達する）（Compute_MRT_NextHopsに計算するのと同じ結果（）Pに到達する赤パスを使用することの安全性のための代用としてFの故障にYに到達するためにSのパスの安全性を試験、Y.そうに到達するためには、この場合に信頼できません。これは、Pへの赤いパスがYに赤いパスがFに当たらないにもかかわらず、Fを打つ可能構造トポロジーであります"
    },
    {
      "indent": 3,
      "text": "Fortunately, there is enough information in the order relationships that we have already computed to still figure out which alternate to choose in these four cases. The basic idea is to always choose the path involving the ordered node, unless that path would hit F. Returning to case 4.1.3, we see that since A is ordered lower than S, the only way for S to hit F using a simple DECREASING path to A is for F to lie between A and S on the GADAG. This scenario is covered by requiring that F be lower than S (but not also higher than S) and that F.topo_order>A.topo_order in case 4.1.3.1.",
      "ja": "幸いなことに、我々はすでに、まだこれらの4例で選択した代替把握するために計算しているためとの関係で十分な情報があります。基本的な考え方は、そのパスがFでケース4.1.3に戻ってヒットしない限り、我々はAは、単純なを使用してFを打つために、Sのための唯一の方法はSよりも低く順序付けられているので、ことがわかり、必ず注文ノードを含むパスを選択することですFはGADAGにAとSとの間に位置するAへのパスを減少させることです。このシナリオは、場合4.1.3.1にF.topo_order> A.topo_order Fは（Sよりもなく、より高い）Sよりも低いことを要求することによって、その覆われています。"
    },
    {
      "indent": 3,
      "text": "We just need to confirm that it is safe to use the path involving B in this scenario. In case 4.1.3.1, either F is between A and S on the GADAG, or F is unordered with respect to A and lies on the DECREASING path from S to the localroot. When F is between A and S on the GADAG, then the path through B chosen to avoid A in Select_Proxy_Node_NHs() will also avoid F. When F is unordered with respect to A and lies on the DECREASING path from S to the localroot, then we consider two cases. Either F.topo_order<B.topo_order or F.topo_order>B.topo_order. In the first case, since F.topo_order<B.topo_order and F.topo_order>A.topo_order, it must be the case that A.topo_order<B.topo_order. Therefore, L will choose DECREASING next hops directly to B (case 4.1.2.1), which cannot hit F since F.topo_order<B.topo_order. In the second case, where F.topo_order>B.topo_order, the only way for the path involving B to hit F is if it DECREASES from L to B through F, i.e., it must be that L>>F>>B. However, since S>>F, this would imply that S>>B. However, we know that S is unordered with respect to B, so the second case cannot occur. So we have demonstrated that the red path to P (which goes via B and Y) is safe to use under the conditions of 4.1.3.1. Similar reasoning can be applied to the other three special cases where either A or B is unordered with respect to S.",
      "ja": "私達はちょうどこのシナリオでBを含むパスを使用しても安全であることを確認する必要があります。場合4.1.3.1において、いずれかのFはGADAGにAとSとの間にある、又はFはAに対して順不同でありlocalrootへSから減少する経路上にあります。 FはGADAGにAとSとの間にあるとき、Bを通るパスは、Fは、Aに対して順不同でありlocalrootにSから減少する経路上にあるときに、またF.を回避するであろうSelect_Proxy_Node_NHsにおけるA（）を避けるように選択します我々は2例を考えます。 F.topo_order <B.topo_orderまたはF.topo_order> B.topo_orderどちらか。最初のケースでは、F.topo_order <B.topo_orderとF.topo_order> A.topo_orderので、ケースA.topo_order <B.topo_orderなければなりません。したがって、LはF.topo_order <B.topo_orderのでFを打つことができないB（ケース4.1.2.1）、直接次のホップを減少させる選択します。後者の場合、F.topo_order> B.topo_orderにおいて、Fを打つためにBを含む経路のための唯一の方法は、それがFを介してBにLから減少した場合、即ち、それはL >> F >> Bでなければならないです。しかし、S >> Fいるので、これはそのS >> Bを含意するでしょう。しかし、我々は、SがBに関して順不同であることを知っているので、後者の場合は発生しません。だから我々は（BとYを経由する）Pへの赤いパスが4.1.3.1の条件の下で使用しても安全であることを証明しました。同様の推論は、A又はBのいずれかがSに対して順不同である他の3つの特殊なケースに適用することができます"
    },
    {
      "indent": 0,
      "text": "6. MRT Lowpoint Algorithm: Next-Hop Conformance",
      "section_title": true,
      "ja": "6. MRT Lowpointアルゴリズム：ネクストホップの適合性"
    },
    {
      "indent": 3,
      "text": "This specification defines the MRT Lowpoint algorithm, which includes the construction of a common GADAG and the computation of MRT-Red and MRT-Blue next hops to each node in the graph. An implementation MAY select any subset of next hops for MRT-Red and MRT-Blue that respect the available nodes that are described in Section 5.7 for each of the MRT-Red and MRT-Blue and the selected next hops are further along in the interval of allowed nodes towards the destination.",
      "ja": "この仕様は、一般的GADAGの構造及びグラフ内の各ノードにMRTレッドおよびMRTブルーネクストホップの計算を含むMRT Lowpointアルゴリズムを定義します。実装間隔にさらに沿っているMRTレッドおよびMRTブルー、選択された次のホップのそれぞれについては、セクション5.7に記載されている利用可能なノードを尊重MRTレッドおよびMRTブルーのための次のホップの任意のサブセットを選択することができます。目的地への許可されたノードの。"
    },
    {
      "indent": 3,
      "text": "For example, the MRT-Blue next hops used when the destination Y >> X, the computing router, MUST be one or more nodes, T, whose topo_order is in the interval [X.topo_order, Y.topo_order] and where Y >> T or Y is T. Similarly, the MRT-Red next hops MUST be have a topo_order in the interval [R-small.topo_order, X.topo_order] or [Y.topo_order, R-big.topo_order].",
      "ja": "例えば先Y >> X、コンピューティング・ルータは、1つ以上のノードなければならない場合に使用される、MRTブルーネクストホップ、そのtopo_order間隔であるT、[X.topo_order、Y.topo_order]とここでY> > TまたはYは同様にTである、MRTレッド次ホップ間隔でtopo_orderを持っている必要があり、[R-small.topo_order、X.topo_order]または[Y.topo_order、R-big.topo_order]。"
    },
    {
      "indent": 3,
      "text": "Implementations SHOULD implement the Select_Alternates() function to pick an MRT-FRR alternate.",
      "ja": "実装は、MRT-FRRの代替を選択するSelect_Alternates（）関数を実装する必要があります。"
    },
    {
      "indent": 0,
      "text": "7. Broadcast Interfaces",
      "section_title": true,
      "ja": "7.ブロードキャストインタフェース"
    },
    {
      "indent": 3,
      "text": "When broadcast interfaces are used to connect nodes, the broadcast network MUST be represented as a pseudonode, where each real node connects to the pseudonode. The interface metric in the direction from real node to pseudonode is the non-zero interface metric, while the interface metric in the direction from the pseudonode to the real node is set to zero. This is consistent with the way that broadcast interfaces are represented as pseudonodes in IS-IS and OSPF.",
      "ja": "放送インタフェースはノードを接続するために使用される場合、ブロードキャストネットワークは、各実ノードが擬似ノードに接続擬似として表現されなければなりません。実際のノードへ擬似から方向におけるインタフェースメトリックはゼロに設定される擬似に実ノードから方向におけるインタフェースメトリックは、非ゼロのインターフェイスメトリックです。これは、放送インタフェースはIS-ISおよびOSPFにおける擬似ノードとして表現される方法と一致しています。"
    },
    {
      "indent": 3,
      "text": "Pseudonodes MUST be treated as equivalent to real nodes in the network graph used in the MRT Lowpoint algorithm with a few exceptions detailed below.",
      "ja": "擬似ノードは、以下に詳述するいくつかの例外を除いてMRT Lowpointアルゴリズムで使用されるネットワークグラフ内の実ノードと同等に扱われなければなりません。"
    },
    {
      "indent": 3,
      "text": "The pseudonodes MUST be included in the computation of the GADAG. The neighbors of the pseudonode need to know the mrt_node_id of the pseudonode in order to consistently order interfaces, which is needed to compute the GADAG. The mrt_node_id for IS-IS is the 7-octet neighbor system ID and pseudonode number in TLV 22 or TLV 222. The mrt_node_id for OSPFv2 is the 4-octet interface address of the Designated Router found in the Link ID field for the link type 2 (transit network) in the Router-LSA. The mrt_node_id for OSPFv3 is the 4 octet interface address of the Designated Router found in the Neighbor Interface ID field for the link type 2 (transit network) in the Router-LSA. Note that this is different from the Neighbor Router ID field used for the mrt_node_id for point-to-point links in OSPFv3 Router-LSAs given in Figure 15.",
      "ja": "擬似ノードはGADAGの計算に含まれなければなりません。擬似ノードの隣人は、一貫GADAGを計算するために必要なインターフェースを注文するために、擬似のmrt_node_idを知っておく必要があります。 IS-ISのためmrt_node_idはOSPFv2のためmrt_node_idは、リンクタイプ2のリンクIDフィールドに見つかった指定ルータの4オクテットのインタフェースアドレスであるTLV 22またはTLV 222の7オクテット隣接システムIDと擬似番号ルータ -  LSAに（トランジットネットワーク）。 OSPFv3のためmrt_node_idルータ-LSAのリンクタイプ2（トランジットネットワーク）のための近隣インタフェースIDフィールドに見つかった指定ルータの4オクテットのインタフェースアドレスです。これは図15に与えられたのOSPFv3ルータのLSA-におけるポイントツーポイントリンクのmrt_node_idために使用される近隣のルータIDフィールドとは異なることに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "Pseudonodes MUST NOT be considered candidates for selection as GADAG root. This rule is intended to result in a more stable network-wide selection of GADAG root by removing the possibility that the change of Designated Router or Designated Intermediate System on a broadcast network can result in a change of GADAG root.",
      "ja": "擬似ノードはGADAGルートとして選択候補とみなされてはなりません。この規則は、ブロードキャストネットワーク上の指定ルータまたは指定中間システムの変更がGADAGルートの変化をもたらすことができる可能性を除去することにより、GADAGルートのより安定したネットワーク全体の選択をもたらすことを意図しています。"
    },
    {
      "indent": 0,
      "text": "7.1. Computing MRT Next Hops on Broadcast Networks",
      "section_title": true,
      "ja": "7.1. ブロードキャストネットワーク上のMRTネクストホップを計算"
    },
    {
      "indent": 3,
      "text": "The pseudonode does not correspond to a real node, so it is not actually involved in forwarding. A real node on a broadcast network cannot simply forward traffic to the broadcast network. It must specify another real node on the broadcast network as the next hop. On a network graph where a broadcast network is represented by a pseudonode, this means that if a real node determines that the next hop to reach a given destination is a pseudonode, it must also determine the next-next-hop for that destination in the network graph, which corresponds to a real node attached to the broadcast network.",
      "ja": "擬似は、実際のノードに対応していないので、実際の転送に関与しません。ブロードキャストネットワーク上の実際のノードは、ブロードキャストネットワークにはない、単にトラフィックを転送することができます。これは、ネクストホップとして放送ネットワーク上の別の実のノードを指定する必要があります。ブロードキャストネットワークを擬似表されるネットワークグラフ上で、これは実際のノードが所定の宛先に到達するための次のホップが擬似であると判断した場合、それはまたでその宛先に次の次のホップを決定しなければならないことを意味しますブロードキャストネットワークに接続実際のノードに対応するネットワークグラフ。"
    },
    {
      "indent": 3,
      "text": "It is interesting to note that this issue is not unique to the MRT algorithm, but is also encountered in normal SPF computations for IGPs. Section 16.1.1 of [RFC2328] describes how this is done for OSPF. When OSPF runs its shortest-path tree calculation, it deals with pseudonodes in the following manner. Whenever the calculating router finds a shorter path to reach a real destination node and the shorter path to the destination is a single pseudonode hop, then the next hop for that destination is taken from the interface IP address in the Router-LSA correspond to the link to the real destination node.",
      "ja": "この問題はMRTのアルゴリズムに特有のものではないことに注意することは興味深いですが、またのIGPのための通常のSPF計算に遭遇しました。 [RFC2328]のセクション16.1.1は、これはOSPFのために行われている方法を説明します。 OSPFは、その最短パスツリーの計算を実行すると、次のように擬似ノードを扱っています。計算のルータは、実際の宛先ノードに到達するために、より短いパスを検出し、宛先へのより短い経路は、単一の擬似ホップであるときはいつでも、その宛先のネクストホップは、ルータ -  LSAでインターフェイスIPアドレスから取得されたリンクに対応実際の宛先ノードへ。"
    },
    {
      "indent": 3,
      "text": "For IS-IS, in the example pseudocode implementation of Dijkstra's algorithm in Annex C of [ISO10589-Second-Edition], whenever the algorithm encounters an adjacency from a real node to a pseudonode, it gets converted to a set of adjacencies from the real node to the neighbors of the pseudonode. In this way, the computed next hops point all the way to the real node, and not the pseudonode.",
      "ja": "IS-ISのために、アルゴリズムは擬似に実際のノードから隣接関係に遭遇するたびに[ISO10589-第二版]、の附属書Cにダイクストラのアルゴリズムの一例を擬似コード実装では、それが本当のから隣接のセットに変換されます疑似ノードの隣人へのノード。このように、計算された次のホップはすべての方法、実際のノードではなく、擬似ノードを指します。"
    },
    {
      "indent": 3,
      "text": "We could avoid the problem of determining next hops across pseudonodes in MRT by converting the pseudonode representation of broadcast networks to a full mesh of links between real nodes on the same network. However, if we make that conversion before computing the GADAG, we lose information about which links actually correspond to a single physical interface into the broadcast network. This could result computing red and blue next hops that use the same broadcast interface, in which case neither the red nor the blue next hop would be usable as an alternate on failure of the broadcast interface.",
      "ja": "私たちは、同じネットワーク上の実際のノード間のリンクのフルメッシュに放送ネットワークの擬似表現を変換することにより、MRTで擬似ノード間の次のホップを決定する問題を避けることができます。我々はGADAGを計算する前にその変換を行う場合は、我々は実際に放送ネットワークへの単一の物理インターフェースに対応してリンクする情報を失います。これは、赤や青の次のホップのいずれもブロードキャストインターフェースの故障に代替として使用可能になり、その場合、同一のブロードキャストインターフェースを使用して赤と青の次のホップを計算する可能性があります。"
    },
    {
      "indent": 3,
      "text": "Instead, we take the following approach, which maintains the property that either the red and blue next hop will avoid the broadcast network, if topologically allowed. We run the MRT Lowpoint algorithm treating the pseudonodes as equivalent to real nodes in the network graph, with the exceptions noted above. In addition to running the MRT Lowpoint algorithm from the point of view of itself, a computing router connected to a pseudonode MUST also run the MRT Lowpoint algorithm from the point of view of each of its pseudonode neighbors. For example, if a computing router S determines that its MRT red next hop to reach a destination D is a pseudonode P, S looks at its MRT Lowpoint algorithm computation from P's point of view to determine P's red next hop to reach D, say interface 1 on node X. S now knows that its real red next hop to reach D is interface 1 on node X on the broadcast network represented by P, and it can install the corresponding entry in its FIB.",
      "ja": "代わりに、私たちは、位相的に許可されている場合、赤と青の次のホップは、放送網を避けることができますいずれかのプロパティを保持し、次のアプローチを取ります。私たちは、MRT Lowpointアルゴリズムは、上記の例外を除いて、ネットワークグラフ内の実際のノードと同等に擬似ノードを処理する実行します。自体の観点からMRT Lowpointアルゴリズムを実行することに加えて、擬似ノードに接続されたコンピューティング・ルータは、その擬似隣人の各々の観点からMRT Lowpointアルゴリズムを実行する必要があります。コンピューティング・ルータSが宛先Dに到達するそのMRT赤次ホップが擬似のPであると判定した場合、例えば、SがDに到達するPの赤の次のホップを決定するために、図のPの点から、そのMRT Lowpointアルゴリズム計算を見、インターフェースを言いますノードXがSで1について、その真の赤次ホップがDは、Pで表される放送ネットワーク上のノードX上のインタフェース1で到達するように、それはそのFIB内の対応するエントリをインストールすることができることを知っています。"
    },
    {
      "indent": 0,
      "text": "7.2. Using MRT Next Hops as Alternates in the Event of Failures on Broadcast Networks",
      "ja": "7.2. ブロードキャストネットワーク上の障害時の代替デバイスとしてMRT次のホップを使用"
    },
    {
      "indent": 3,
      "text": "In the previous section, we specified how to compute MRT next hops when broadcast networks are involved. In this section, we discuss how a PLR can use those MRT next hops in the event of failures involving broadcast networks.",
      "ja": "前のセクションでは、ブロードキャストネットワークが関与しているとき、次のホップMRTの計算方法を指定しました。このセクションでは、PLRは、放送ネットワークを含む障害が発生した場合には、それらのMRTの次のホップを使用する方法について説明します。"
    },
    {
      "indent": 3,
      "text": "A PLR attached to a broadcast network running only OSPF or IS-IS with large Hello intervals has limited ability to quickly detect failures on a broadcast network. The only failure mode that can be quickly detected is the failure of the physical interface connecting the PLR to the broadcast network. For the failure of the interface connecting the PLR to the broadcast network, the alternate that avoids the broadcast network can be computed by using the broadcast network pseudonode as F, the primary next-hop node, in Select_Alternates(). This will choose an alternate path that avoids the broadcast network. However, the alternate path will not necessarily avoid all of the real nodes connected to the broadcast network. This is because we have used the pseudonode to represent the broadcast network. And we have enforced the node-protecting property of MRT on the pseudonode to provide protection against failure of the broadcast network, not the real next-hop nodes on the broadcast network. This is the best that we can hope to do if failure of the broadcast interface is the only failure mode that the PLR can respond to.",
      "ja": "PLRはOSPFを実行しているブロードキャストネットワークに接続またはIS-IS大型のHello間隔で素早くブロードキャストネットワーク上の障害を検出する能力が制限されています。迅速に検出することができる唯一の故障モードは、放送ネットワークにPLRを接続する物理インターフェイスの障害です。ブロードキャストネットワークにPLRを接続するインタフェースの故障のために、ブロードキャストネットワークを回避する代替がSelect_Alternatesに、F、一次次ホップノードとしてブロードキャストネットワーク擬似を使用して計算することができます（）。これは、ブロードキャストネットワークを回避し、代替パスを選択します。しかし、代替パスは、必ずしもブロードキャストネットワークに接続された実際のノードのすべてを避けられないであろう。私たちは、ブロードキャストネットワークを表現するために擬似ノードを使用しているためです。そして、我々は放送ネットワークの故障、ブロードキャストネットワーク上ではない本当の次ホップノードに対する保護を提供するために、疑似ノード上でMRTのノード保護プロパティを施行しています。これは、私たちがブロードキャストインターフェイスの障害がPLRが応答できる唯一の故障モードである場合に行うことを期待できる最善の方法です。"
    },
    {
      "indent": 3,
      "text": "We can improve on this if the PLR also has the ability to quickly detect a lack of connectivity across the broadcast network to a given IP-layer node. This can be accomplished by running BFD between all pairs of IGP neighbors on the broadcast network. Note that in the case of OSPF, this would require establishing BFD sessions between all pairs of neighbors in the 2-WAY state. When the PLR can quickly detect the failure of a particular next hop across a broadcast network, the PLR can be more selective in its choice of alternates. For example, when the PLR observes that connectivity to an IP-layer node on a broadcast network has failed, the PLR may choose to still use the broadcast network to reach other IP-layer nodes that are still reachable. Or, if the PLR observes that connectivity has failed to several IP-layer nodes on the same broadcast network, it may choose to treat the entire broadcast network as failed. The choice of MRT alternates by a PLR for a particular set of failure conditions is a local decision, since it does not require coordination with other nodes.",
      "ja": "PLRもすぐに与えられたIPレイヤのノードにブロードキャストネットワークを介して接続の欠如を検出する能力を持っている場合我々は、この上で改善することができます。これは、ブロードキャストネットワーク上のIGPネイバーのすべてのペア間でBFDを実行することによって達成することができます。 OSPFの場合には、これは2-WAY状態にあるネイバーのすべてのペア間のBFDセッションの確立が必要となることに注意してください。 PLRはすぐにブロードキャストネットワークを介して特定のネクストホップの障害を検出することができたとき、PLRは、交互のその選択により選択することができます。 PLRは、放送ネットワーク上のIP層のノードへの接続が失敗したことを観察した場合例えば、PLRはまだ依然として到達可能な他のIPレイヤのノードに到達するブロードキャストネットワークを使用することを選択することができます。 PLRは接続が同じブロードキャストネットワーク上の複数のIPレイヤのノードに障害が発生したことを観察した場合や、それが失敗したとして、全体の放送網を治療することもできます。それは他のノードとの調整を必要としないため、障害状態の特定のセットのためにPLRにより、MRTの交互の選択は、地元の決定です。"
    },
    {
      "indent": 0,
      "text": "8. Evaluation of Alternative Methods for Constructing GADAGs",
      "section_title": true,
      "ja": "GADAGsを構築するための代替法8.評価"
    },
    {
      "indent": 3,
      "text": "This document specifies the MRT Lowpoint algorithm. One component of the algorithm involves constructing a common GADAG based on the network topology. The MRT Lowpoint algorithm computes the GADAG using the method described in Section 5.5. This method aims to minimize the amount of computation required to compute the GADAG. In the process of developing the MRT Lowpoint algorithm, two alternative methods for constructing GADAGs were also considered. These alternative methods are described in Appendices B and C. In general, these other two methods require more computation to compute the GADAG. The analysis below was performed to determine if the alternative GADAG construction methods produce shorter MRT alternate paths in real network topologies, and if so, to what extent.",
      "ja": "この文書では、MRT Lowpointアルゴリズムを指定します。アルゴリズムの1つの構成要素は、ネットワークトポロジに基づいて共通GADAGを構築することを伴います。 MRT Lowpointアルゴリズムは、セクション5.5に記載の方法を用いてGADAGを計算します。この方法は、GADAGを計算するために必要な計算量を最小限にすることを目指しています。 MRT Lowpointアルゴリズムを開発する過程で、GADAGsを構築するための2つの代替の方法も検討されました。一般に、付録BおよびCに記載されているこれらの代替方法は、これらの他の2つの方法は、GADAGを計算するために多くの計算を必要とします。以下の分析は、代替GADAG構築方法は、実際のネットワークトポロジーで短いMRT代替経路を生成するかどうかを決定するために行われ、もしそうなら、どの程度でした。"
    },
    {
      "indent": 3,
      "text": "Figure 30 compares results obtained using the three different methods for constructing GADAGs on five different service provider network topologies. MRT_LOWPOINT indicates the method specified in Section 5.5, while MRT_SPF and MRT_HYBRID indicate the methods specified in Appendices B and C, respectively. The columns on the right present the distribution of alternate path lengths for each GADAG construction method. Each MRT computation was performed using a same GADAG root chosen based on centrality.",
      "ja": "図30は、5つの異なるサービスプロバイダのネットワークトポロジ上GADAGsを構築するための3つの異なる方法を用いて得られた結果を比較します。 MRT_SPFとMRT_HYBRIDはそれぞれ、付録BおよびCで指定された方法を示しながらMRT_LOWPOINTは、セクション5.5で指定された方法を示しています。右側の列は、代替パスの分布が各GADAG工法のための長提示します。各MRT計算は中心性に基づいて選択された同じGADAGルートを用いて行きました。"
    },
    {
      "indent": 3,
      "text": "For three of the topologies analyzed (T201, T206, and T211), the use of MRT_SPF or MRT_HYBRID methods does not appear to provide a significantly shorter alternate path lengths compared to the MRT_LOWPOINT method. However, for two of the topologies (T216 and T219), the use of the MRT_SPF method resulted in noticeably shorter alternate path lengths than the use of the MRT_LOWPOINT or MRT_HYBRID methods.",
      "ja": "（T201、T206、およびT211）分析トポロジーの三ため、MRT_SPF又はMRT_HYBRID方法の使用はMRT_LOWPOINT方法と比較して有意に短い代替経路長を提供するように思われません。しかし、トポロジ（T216およびT219）二ため、MRT_SPF法の使用はMRT_LOWPOINT又はMRT_HYBRID方法の使用よりも著しく短い代替経路長をもたらしました。"
    },
    {
      "indent": 3,
      "text": "It was decided to use the MRT_LOWPOINT method to construct the GADAG in the algorithm specified in this document, in order to initially offer an algorithm with lower computational requirements. These results indicate that in the future it may be useful to evaluate and potentially specify other MRT Lowpoint algorithm variants that use different GADAG construction methods.",
      "ja": "当初は低い計算要件とアルゴリズムを提供するために、この文書で指定されたアルゴリズムでGADAGを構築するためにMRT_LOWPOINTメソッドを使用することを決めました。これらの結果は、将来的にそれを評価し、潜在的に異なるGADAG工法を使用する他のMRT Lowpointアルゴリズムバリアントを指定するために有用である可能性があることを示しています。"
    },
    {
      "indent": 3,
      "text": "+-------------------------------------------------------------------+\n|        Topology name         |   percentage of failure scenarios  |\n|                              |  protected by an alternate N hops  |\n|      GADAG construction      |   longer than the primary path     |\n|            method            +------------------------------------+\n|                              |   |   |   |   |   |   |   |   | no |\n|                              |   |   |   |   |   |10 |12 |14 | alt|\n|                              |0-1|2-3|4-5|6-7|8-9|-11|-13|-15| <16|\n+------------------------------+---+---+---+---+---+---+---+---+----+\n|  T201(avg primary hops=3.5)  |   |   |   |   |   |   |   |   |    |\n|  MRT_HYBRID                  | 33| 26| 23|  6|  3|   |   |   |    |\n|  MRT_SPF                     | 33| 36| 23|  6|  3|   |   |   |    |\n|  MRT_LOWPOINT                | 33| 36| 23|  6|  3|   |   |   |    |\n+------------------------------+---+---+---+---+---+---+---+---+----+\n|  T206(avg primary hops=3.7)  |   |   |   |   |   |   |   |   |    |\n|  MRT_HYBRID                  | 50| 35| 13|  2|   |   |   |   |    |\n|  MRT_SPF                     | 50| 35| 13|  2|   |   |   |   |    |\n|  MRT_LOWPOINT                | 55| 32| 13|   |   |   |   |   |    |\n+------------------------------+---+---+---+---+---+---+---+---+----+\n|  T211(avg primary hops=3.3)  |   |   |   |   |   |   |   |   |    |\n|  MRT_HYBRID                  | 86| 14|   |   |   |   |   |   |    |\n|  MRT_SPF                     | 86| 14|   |   |   |   |   |   |    |\n|  MRT_LOWPOINT                | 85| 15|  1|   |   |   |   |   |    |\n+------------------------------+---+---+---+---+---+---+---+---+----+\n|  T216(avg primary hops=5.2)  |   |   |   |   |   |   |   |   |    |\n|  MRT_HYBRID                  | 23| 22| 18| 13| 10|  7|  4|  2|   2|\n|  MRT_SPF                     | 35| 32| 19|  9|  3|  1|   |   |    |\n|  MRT_LOWPOINT                | 28| 25| 18| 11|  7|  6|  3|  2|   1|\n+------------------------------+---+---+---+---+---+---+---+---+----+\n|  T219(avg primary hops=7.7)  |   |   |   |   |   |   |   |   |    |\n|  MRT_HYBRID                  | 20| 16| 13| 10|  7|  5|  5|  5|   3|\n|  MRT_SPF                     | 31| 23| 19| 12|  7|  4|  2|  1|    |\n|  MRT_LOWPOINT                | 19| 14| 15| 12| 10|  8|  7|  6|  10|\n+------------------------------+---+---+---+---+---+---+---+---+----+",
      "raw": true
    },
    {
      "indent": 8,
      "text": "Figure 30: The Length of Alternate Paths for Various GADAG\n                   Construction Methods",
      "raw": true
    },
    {
      "indent": 0,
      "text": "9. Operational Considerations",
      "section_title": true,
      "ja": "9.運用に関する注意事項"
    },
    {
      "indent": 3,
      "text": "This section discusses operational considerations related to the MRT Lowpoint algorithm and other potential MRT algorithm variants. For a discussion of operational considerations related to MRT-FRR in general, see the \"Operational Considerations\" section of [RFC7812].",
      "ja": "このセクションでは、MRT Lowpointアルゴリズムや他の潜在的なMRTのアルゴリズムバリアントに関連する運用考慮事項について説明します。一般的にはMRT-FRRに関連する業務の配慮の議論に関しては、[RFC7812]の「運用の考慮事項」を参照してください。"
    },
    {
      "indent": 0,
      "text": "9.1. GADAG Root Selection",
      "section_title": true,
      "ja": "9.1.  GADAGルートの選択"
    },
    {
      "indent": 3,
      "text": "The Default MRT Profile uses the GADAG Root Selection Priority advertised by routers as the primary criterion for selecting the GADAG root. It is RECOMMENDED that an operator designate a set of routers as good choices for selection as GADAG root by setting the GADAG Root Selection Priority for that set of routers to lower (more preferred) numerical values. Criteria for making this designation are discussed below.",
      "ja": "デフォルトMRTプロファイルはGADAGのルートを選択するための主な基準として、ルータによってアドバタイズGADAGルート選択の優先順位を使用しています。オペレータが低い（より好ましい）の数値へのルータのセットについてGADAGルート選択の優先順位を設定することによりGADAGルートとして選択するための良好な選択肢としてルータのセットを指定することが推奨されます。この指定を行うための基準は以下で議論されています。"
    },
    {
      "indent": 3,
      "text": "Analysis has shown that the centrality of a router can have a significant impact on the lengths of the alternate paths computed. Therefore, it is RECOMMENDED that off-line analysis that considers the centrality of a router be used to help determine how good a choice a particular router is for the role of GADAG root.",
      "ja": "分析は、ルータの中心性を計算代替パスの長さに大きな影響を与えることができることを示しています。したがって、ルータの中心性を考慮したオフライン分析は、特定のルータがGADAGルートの役割のためにどのように良い選択決定を支援するために使用することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "If the router currently selected as GADAG root becomes unreachable in the IGP topology, then a new GADAG root will be selected. Changing the GADAG root can change the overall structure of the GADAG as well the paths of the red and MRT-Blue trees built using that GADAG. In order to minimize change in the associated red and MRT-Blue forwarding entries that can result from changing the GADAG root, it is RECOMMENDED that operators prioritize for selection as GADAG root those routers that are expected to consistently remain part of the IGP topology.",
      "ja": "現在GADAGルートとして選択されたルータはIGPトポロジにおける到達不能になった場合、新しいGADAGルートが選択されます。 GADAGルートを変更すると、GADAGの全体的な構造だけでなくそのGADAGを使用して構築された、赤とMRTブルー木のパスを変更することができます。 GADAGルートを変更することから生じ得る関連赤色及びMRTブルー転送エントリの変更を最小限にするためには、オペレータがGADAGルートとして選択するために一貫してIGPトポロジの一部残ることが期待されるそれらのルータに優先順位を付けることが推奨されます。"
    },
    {
      "indent": 0,
      "text": "9.2. Destination-Rooted GADAGs",
      "section_title": true,
      "ja": "9.2. 宛先根ざしGADAGs"
    },
    {
      "indent": 3,
      "text": "The MRT Lowpoint algorithm constructs a single GADAG rooted at a single node selected as the GADAG root. It is also possible to construct a different GADAG for each destination, with the GADAG rooted at the destination. A router can compute the MRT-Red and MRT-Blue next hops for that destination based on the GADAG rooted at that destination. Building a different GADAG for each destination is computationally more expensive, but it may give somewhat shorter alternate paths. Using destination-rooted GADAGs would require a new MRT profile to be created with a new MRT algorithm specification, since all routers in the MRT Island would need to use destination-rooted GADAGs.",
      "ja": "MRT LowpointアルゴリズムはGADAGルートとして選択された単一のノードをルート単一GADAGを構築します。目的地をルートGADAGと、宛先ごとに異なるGADAGを構成することも可能です。ルータはその先をルートGADAGに基づいて、その送信先のMRT-赤とMRTブルーネクストホップを計算することができます。宛先ごとに異なるGADAGを構築する計算上高価であるが、それは幾分短い代替パスを与えることができます。 MRT島のすべてのルータが宛先根ざしGADAGsを使用する必要がありますので、先-根ざしGADAGsを使用すると、新しいMRTアルゴリズムの仕様で作成される新しいMRTプロファイルを必要とします。"
    },
    {
      "indent": 0,
      "text": "10. Security Considerations",
      "section_title": true,
      "ja": "10.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "The algorithm described in this document does not introduce new security concerns beyond those already discussed in the document describing the MRT FRR architecture [RFC7812].",
      "ja": "この文書に記載されたアルゴリズムは、すでにMRT FRRアーキテクチャ[RFC7812]を記述した文書で説明したものを超えて、新たなセキュリティ上の懸念を導入しません。"
    },
    {
      "indent": 0,
      "text": "11. References",
      "section_title": true,
      "ja": "11.参考文献"
    },
    {
      "indent": 0,
      "text": "11.1. Normative References",
      "section_title": true,
      "ja": "11.1. 引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<http://www.rfc-editor.org/info/ RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC7812] Atlas, A., Bowers, C., and G. Enyedi, \"An Architecture for IP/LDP Fast Reroute Using Maximally Redundant Trees (MRT-FRR)\", RFC 7812, DOI 10.17487/RFC7812, June 2016, <http://www.rfc-editor.org/info/rfc7812>.",
      "ja": "[RFC7812]アトラス、A.、バウアーズ、C.、およびG. Enyedi、 \"最大限の冗長木（MRT-FRR）を使用してIP / LDP高速リルートするためのアーキテクチャ\"、RFC 7812、DOI 10.17487は/ RFC7812、2016年6月、< http://www.rfc-editor.org/info/rfc7812>。"
    },
    {
      "indent": 0,
      "text": "11.2. Informative References",
      "section_title": true,
      "ja": "11.2. 参考文献"
    },
    {
      "indent": 3,
      "text": "[EnyediThesis] Enyedi, G., \"Novel Algorithms for IP Fast Reroute\", Department of Telecommunications and Media Informatics, Budapest University of Technology and Economics Ph.D. Thesis, February 2011, <https://repozitorium.omikk.bme.hu/bitstream/ handle/10890/1040/ertekezes.pdf>.",
      "ja": "[EnyediThesis] Enyedi、G.、「IP高速リルートのための新規アルゴリズム」、電気通信およびメディア情報、ブダペスト工科経済大学博士課程の学科論文、2011年2月、<https://repozitorium.omikk.bme.hu/bitstream/ハンドル/ 1040分の10890 / ertekezes.pdf>。"
    },
    {
      "indent": 3,
      "text": "[IEEE8021Qca] IEEE, \"IEEE Standard for Local and metropolitan area networks - Bridges and Bridged Networks - Amendment 24: Path Control and Reservation\", IEEE 802.1Qca-2015, DOI 10.1109/IEEESTD.2016.7434544, 2016, <https://standards.ieee.org/findstds/ standard/802.1Qca-2015.html>.",
      "ja": "[IEEE8021Qca] IEEE、 \"地方とメトロポリタンエリアネットワークのためのIEEE規格 - 橋とブリッジネットワーク - 修正24：パス制御と予約\"、IEEE 802.1Qca-2015、DOI 10.1109 / IEEESTD.2016.7434544、2016年、<https：//での規格.ieee.org / findstds /標準/ 802.1Qca-2015.html>。"
    },
    {
      "indent": 3,
      "text": "[ISO10589-Second-Edition] International Organization for Standardization, \"Intermediate system to Intermediate system intra-domain routeing information exchange protocol for use in conjunction with the protocol for providing the connectionless-mode Network Service (ISO 8473)\", ISO/ IEC 10589:2002, Second Edition, November 2002.",
      "ja": "[ISO10589-第二版]国際標準化機構、「中間システムイントラドメインへの中間システム（ISO 8473）接続モード・ネットワーク・サービスを提供するためのプロトコルと組み合わせて使用​​するための情報交換プロトコルをrouteingする」、ISO / IEC 10589 ：2002年、第2版、2002年11月。"
    },
    {
      "indent": 3,
      "text": "[Kahn_1962_topo_sort] Kahn, A., \"Topological sorting of large networks\", Communications of the ACM, Volume 5, Issue 11 DOI 10.1145/368996.369025, November 1962, <http://dl.acm.org/citation.cfm?doid=368996.369025>.",
      "ja": "【Kahn_1962_topo_sort]カーン、A.、 \"大規模なネットワークのトポロジーソート\"、ACMの通信、5巻、11号DOI 10.1145 / 368996.369025、1962年11月、<http://dl.acm.org/citation.cfm?doid = 368996.369025>。"
    },
    {
      "indent": 3,
      "text": "[MRTLinear] Enyedi, G., Retvari, G., and A. Csaszar, \"On Finding Maximally Redundant Trees in Strictly Linear Time\", IEEE Symposium on Computers and Communications (ISCC), 2009, <http://opti.tmit.bme.hu/~enyedi/ipfrr/ distMaxRedTree.pdf>.",
      "ja": "\"厳密に線形時間で見つける最大限の冗長木に\" [MRTLinear] Enyedi、G.、Retvari、G.、およびA. Csaszar、コンピュータと通信に関するIEEEシンポジウム（ISCC）、2009年、<のhttp：//opti.tmit .bme.hu /〜enyedi / ipfrr / distMaxRedTree.pdf>。"
    },
    {
      "indent": 3,
      "text": "[RFC2328] Moy, J., \"OSPF Version 2\", STD 54, RFC 2328, DOI 10.17487/RFC2328, April 1998, <http://www.rfc-editor.org/info/rfc2328>.",
      "ja": "[RFC2328]モイ、J.、 \"OSPFバージョン2\"、STD 54、RFC 2328、DOI 10.17487 / RFC2328、1998年4月、<http://www.rfc-editor.org/info/rfc2328>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Python Implementation of MRT Lowpoint Algorithm",
      "ja": "MRT Lowpointアルゴリズムの付録A. Python実装"
    },
    {
      "indent": 3,
      "text": "Below is Python code implementing the MRT Lowpoint algorithm specified in this document. The code is also posted on GitHub <https://github.com/cbowers/draft-ietf-rtgwg-mrt-frr-algorithm/blob/python_code_RFC7811/src/mrt_lowpoint_draft_text.py>.",
      "ja": "以下は、この文書で指定されたMRT Lowpointアルゴリズムを実装したPythonコードです。コードはGitHubの<https://github.com/cbowers/draft-ietf-rtgwg-mrt-frr-algorithm/blob/python_code_RFC7811/src/mrt_lowpoint_draft_text.py>に掲載されています。"
    },
    {
      "indent": 3,
      "text": "While this Python code is believed to correctly implement the pseudocode description of the algorithm, in the event of a difference, the pseudocode description should be considered normative.",
      "ja": "このPythonコードが正しくアルゴリズムの擬似コード記述を実装するために考えられているが、違いが発生した場合に、擬似コード記述は規範的考慮されるべきです。"
    },
    {
      "indent": 0,
      "text": "<CODE BEGINS> # This program has been tested to run on Python 2.6 and 2.7 # (specifically Python 2.6.6 and 2.7.8 were tested). # The program has known incompatibilities with Python 3.X.",
      "ja": "このプログラムはPythonの2.6および2.7＃上で実行するためにテストされています＃<CODEが始まる>（具体的にはPython 2.6.6と2.7.8を試験しました）。 ＃プログラムは、Python 3.xでは非互換性を知られています"
    },
    {
      "indent": 0,
      "text": "# When executed, this program will generate a text file describing # an example topology. It then reads that text file back in as input # to create the example topology, and runs the MRT Lowpoint algorithm. # This was done to simplify the inclusion of the program as a single # text file that can be extracted from the RFC.",
      "ja": "＃実行すると、このプログラムは＃トポロジの例を記述したテキストファイルを生成します。その後、例のトポロジを作成するために、入力＃とバックでそのテキストファイルを読み込み、MRT Lowpointアルゴリズムを実行します。 ＃これは、RFCから抽出することができる単一＃テキストファイルなどのプログラムの包含を単純化するために行われました。"
    },
    {
      "indent": 0,
      "text": "# The output of the program is four text files containing a description # of the GADAG, the blue and MRT-Reds for all destinations, and the # MRT alternates for all failures.",
      "ja": "＃プログラムの出力はGADAG、すべての宛先のための青とMRT-レッズ、およびすべての障害のために＃MRT交互の説明＃を含む4つのテキストファイルです。"
    },
    {
      "indent": 0,
      "text": "import random import os.path import heapq",
      "ja": "輸入ランダム輸入はos.pathインポートheapq"
    },
    {
      "indent": 0,
      "text": "# simple Class definitions allow structure-like dot notation for # variables and a convenient place to initialize those variables. class Topology: def __init__(self): self.gadag_root = None self.node_list = [] self.node_dict = {} self.test_gr = None self.island_node_list_for_test_gr = [] self.stored_named_proxy_dict = {} self.init_new_computing_router() def init_new_computing_router(self): self.island_node_list = [] self.named_proxy_dict = {}",
      "ja": "＃簡単なクラス定義は＃変数およびこれらの変数を初期化するための便利な場所のための構造のようなドット表記を可能にします。クラストポロジー：DEF __init __（自己）：self.gadag_root =なしself.node_list = [] self.node_dict = {} self.test_gr = [] self.stored_named_proxy_dict = {} self.init_new_computing_routerを= self.island_node_list_for_test_grなし（）DEF init_new_computing_router （自己）：self.island_node_list = [] self.named_proxy_dict = {}"
    },
    {
      "indent": 0,
      "text": "class Node: def __init__(self): self.node_id = None self.intf_list = [] self.profile_id_list = [0] self.GR_sel_priority = 128 self.blue_next_hops_dict = {} self.red_next_hops_dict = {} self.blue_to_green_nh_dict = {} self.red_to_green_nh_dict = {} self.prefix_cost_dict = {} self.pnh_dict = {} self.alt_dict = {} self.init_new_computing_router() def init_new_computing_router(self): self.island_intf_list = [] self.IN_MRT_ISLAND = False self.IN_GADAG = False self.dfs_number = None self.dfs_parent = None self.dfs_parent_intf = None self.dfs_child_list = [] self.lowpoint_number = None self.lowpoint_parent = None self.lowpoint_parent_intf = None self.localroot = None self.block_id = None self.IS_CUT_VERTEX = False self.blue_next_hops = [] self.red_next_hops = [] self.primary_next_hops = [] self.alt_list = []",
      "ja": "クラスノード：DEF __init __（自己）：self.node_id =なしself.intf_list = [] self.profile_id_list = [0] self.GR_sel_priority = 128 self.blue_next_hops_dict = {} self.red_next_hops_dict = {} self.blue_to_green_nh_dict = {} self.red_to_green_nh_dict = {} self.prefix_cost_dict = {} self.pnh_dict = {} self.alt_dict = {} self.init_new_computing_router（）DEF init_new_computing_router（自己）：self.island_intf_list = [] self.IN_MRT_ISLAND = Falseのself.IN_GADAG =偽self.dfs_number =なしself.dfs_parent =なしself.dfs_parent_intf =なしself.dfs_child_list = [] self.lowpoint_number =なしself.lowpoint_parent =なしself.lowpoint_parent_intf =なしself.localroot =なしself.block_id =なしself.IS_CUT_VERTEX = Falseのself.blue_next_hops = [] self.red_next_hops = [] self.primary_next_hops = [] self.alt_list = []"
    },
    {
      "indent": 0,
      "text": "class Interface: def __init__(self): self.metric = None self.area = None self.MRT_INELIGIBLE = False self.IGP_EXCLUDED = False self.SIMULATION_OUTGOING = False self.init_new_computing_router() def init_new_computing_router(self): self.UNDIRECTED = True self.INCOMING = False self.OUTGOING = False self.INCOMING_STORED = False self.OUTGOING_STORED = False self.IN_MRT_ISLAND = False self.PROCESSED = False",
      "ja": "クラスインタフェース：デフ__init __（自己）：self.metric =なしself.area =なしself.MRT_INELIGIBLE = Falseのself.IGP_EXCLUDED = Falseのself.SIMULATION_OUTGOING = Falseのself.init_new_computing_router（）デフinit_new_computing_router（自己）：self.UNDIRECTED =真self.INCOMING = Falseのself.OUTGOING = Falseのself.INCOMING_STORED = Falseのself.OUTGOING_STORED = Falseのself.IN_MRT_ISLAND = Falseのself.PROCESSED =偽"
    },
    {
      "indent": 0,
      "text": "class Bundle: def __init__(self): self.UNDIRECTED = True self.OUTGOING = False self.INCOMING = False",
      "ja": "クラスバンドルます：def __init __（自己）：self.UNDIRECTED = Trueのself.OUTGOING = Falseのself.INCOMING =偽"
    },
    {
      "indent": 0,
      "text": "class Alternate: def __init__(self): self.failed_intf = None self.red_or_blue = None self.nh_list = [] self.fec = 'NO_ALTERNATE' self.prot = 'NO_PROTECTION' self.info = 'NONE'",
      "ja": "クラス別ます。def __init __（自己）：self.failed_intf =なしself.red_or_blue =なしself.nh_list = [] self.fec = 'NO_ALTERNATE' self.prot = 'NO_PROTECTION' self.info = 'NONE'"
    },
    {
      "indent": 0,
      "text": "class Proxy_Node_Attachment_Router: def __init__(self): self.prefix = None self.node = None self.named_proxy_cost = None self.min_lfin = None self.nh_intf_list = []",
      "ja": "クラスProxy_Node_Attachment_Routerます。def __init __（自己）：self.prefix =なしself.node =なしself.named_proxy_cost =なしself.min_lfin =なしself.nh_intf_list = []"
    },
    {
      "indent": 0,
      "text": "class Named_Proxy_Node: def __init__(self): self.node_id = None #this is the prefix_id self.node_prefix_cost_list = [] self.lfin_list = [] self.pnar1 = None self.pnar2 = None self.pnar_X = None self.pnar_Y = None self.blue_next_hops = [] self.red_next_hops = [] self.primary_next_hops = [] self.blue_next_hops_dict = {} self.red_next_hops_dict = {} self.pnh_dict = {} self.alt_dict = {}",
      "ja": "クラスNamed_Proxy_Node：DEF __init __（自己）：なしself.pnar_X =なしself.pnar_Y =を= self.pnar2 self.node_id =なし＃これないがprefix_id self.node_prefix_cost_listある= [] self.lfin_list = [] self.pnar1 =なしなしself.blue_next_hopsない= [] self.red_next_hops = [] self.primary_next_hops = [] self.blue_next_hops_dict = {} self.red_next_hops_dict = {} self.pnh_dict = {} self.alt_dict = {}"
    },
    {
      "indent": 0,
      "text": "def Interface_Compare(intf_a, intf_b): if intf_a.metric < intf_b.metric: return -1 if intf_b.metric < intf_a.metric: return 1 if intf_a.remote_node.node_id < intf_b.remote_node.node_id:",
      "ja": "DEF Interface_Compare（intf_a、intf_b）：もしintf_a.metric <intf_b.metric：戻り-1 intf_b.metric <intf_a.metric場合：1を返す場合intf_a.remote_node.node_id <intf_b.remote_node.node_id。"
    },
    {
      "indent": 4,
      "text": "    return -1\nif intf_b.remote_node.node_id < intf_a.remote_node.node_id:\n    return 1\nreturn 0",
      "raw": true
    },
    {
      "indent": 0,
      "text": "def Sort_Interfaces(topo): for node in topo.island_node_list: node.island_intf_list.sort(Interface_Compare)",
      "ja": "DEF Sort_Interfaces（TOPO）：topo.island_node_listにおけるノードの：node.island_intf_list.sort（Interface_Compare）"
    },
    {
      "indent": 0,
      "text": "def Reset_Computed_Node_and_Intf_Values(topo): topo.init_new_computing_router() for node in topo.node_list: node.init_new_computing_router() for intf in node.intf_list: intf.init_new_computing_router()",
      "ja": "DEF Reset_Computed_Node_and_Intf_Values（TOPO）：topo.init_new_computing_router（）topo.node_listにおけるノードの：node.init_new_computing_router（）node.intf_listでINTF用：intf.init_new_computing_router（）"
    },
    {
      "indent": 0,
      "text": "# This function takes a file with links represented by 2-digit # numbers in the format: # 01,05,10 # 05,02,30 # 02,01,15 # which represents a triangle topology with nodes 01, 05, and 02 # and symmetric metrics of 10, 30, and 15.",
      "ja": "＃この関数は、の形式で2桁の＃番号で表されるリンクを有するファイルかかり＃01,05,10＃05,02,30＃02,01,15＃ノード01、05を有する三角形のトポロジを表し、そして02＃及び10、30、及び15の対称メトリクス。"
    },
    {
      "indent": 0,
      "text": "# Inclusion of a fourth column makes the metrics for the link # asymmetric. An entry of: # 02,07,10,15 # creates a link from node 02 to 07 with metrics 10 and 15. def Create_Topology_From_File(filename): topo = Topology() node_id_set= set() cols_list = [] # on first pass just create nodes with open(filename + '.csv') as topo_file: for line in topo_file: line = line.rstrip('\\r\\n') cols=line.split(',') cols_list.append(cols) nodea_node_id = int(cols[0]) nodeb_node_id = int(cols[1]) if (nodea_node_id > 999 or nodeb_node_id > 999): print(\"node_id must be between 0 and 999.\") print(\"exiting.\") exit() node_id_set.add(nodea_node_id) node_id_set.add(nodeb_node_id) for node_id in node_id_set: node = Node() node.node_id = node_id topo.node_list.append(node) topo.node_dict[node_id] = node # on second pass create interfaces for cols in cols_list: nodea_node_id = int(cols[0]) nodeb_node_id = int(cols[1]) metric = int(cols[2]) reverse_metric = int(cols[2]) if len(cols) > 3: reverse_metric=int(cols[3]) nodea = topo.node_dict[nodea_node_id] nodeb = topo.node_dict[nodeb_node_id] nodea_intf = Interface() nodea_intf.metric = metric nodea_intf.area = 0 nodeb_intf = Interface() nodeb_intf.metric = reverse_metric nodeb_intf.area = 0 nodea_intf.remote_intf = nodeb_intf nodeb_intf.remote_intf = nodea_intf nodea_intf.remote_node = nodeb nodeb_intf.remote_node = nodea nodea_intf.local_node = nodea nodeb_intf.local_node = nodeb nodea_intf.link_data = len(nodea.intf_list) nodeb_intf.link_data = len(nodeb.intf_list) nodea.intf_list.append(nodea_intf) nodeb.intf_list.append(nodeb_intf) return topo",
      "ja": "4列目の＃を含めると、リンク＃のメトリックが非対称になります。 ＃02,07,10,15＃はデフCreate_Topology_From_File（ファイル名）メトリック10および15を有するノード02から07へのリンクを作成する：第一にTOPO =トポロジ（）node_id_set =セット（）cols_list = []位のエントリちょうどtopo_fileオープン（ファイル名+ 'の.csv '）を用いてノードを作成通過：topo_fileの行のために：行= line.rstrip（' の\\ r \\ n '）COLS = line.split（''）cols_list.append（COLSを）nodea_node_id = INT（COLS [0]）nodeb_node_id = INT（COLS [1]）（nodea_node_id> 999又はnodeb_node_id> 999）場合：プリント（ \"NODE_IDは、0と999の間でなければならない\"）、印刷（ \"出\"）出口（）node_id_set.add（nodea_node_id）node_id_set.add（nodeb_node_id）NODE_IDためnode_id_setで：第二のパス上のノード=ノード（）node.node_id = NODE_ID topo.node_list.append（ノード）topo.node_dict [NODE_ID] =ノード＃ cols_listでCOLSのインターフェースを作成する：nodea_node_id = INT（COLS [0]）nodeb_node_id = INT（COLS [1]）メトリック= INT（COLS [2]）reverse_metric = INT（COLS [2]）、LEN（COLS）> 3の場合：reverse_metric = INT（COLS [3]）NODEA = topo.node_dict [nodea_node_id】ノードB = topo.node_dict [nodeb_node_i D] nodea_intf =インタフェース（）nodea_intf.metric =メトリックnodea_intf.area = 0 nodeb_intf =インタフェース（）nodeb_intf.metric = reverse_metric nodeb_intf.area = 0 nodea_intf.remote_intf = nodeb_intf nodeb_intf.remote_intf = nodea_intf nodea_intf.remote_node =ノードB nodeb_intf.remote_node = NODEA nodea_intf.local_node = NODEA nodeb_intf.local_node =ノードB nodea_intf.link_data = LEN（nodea.intf_list）nodeb_intf.link_data = LEN（nodeb.intf_list）nodea.intf_list.append（nodea_intf）nodeb.intf_list.append（nodeb_intf）戻りTOPO"
    },
    {
      "indent": 0,
      "text": "def MRT_Island_Identification(topo, computing_rtr, profile_id, area): if profile_id in computing_rtr.profile_id_list: computing_rtr.IN_MRT_ISLAND = True explore_list = [computing_rtr] else: return while explore_list != []: next_rtr = explore_list.pop() for intf in next_rtr.intf_list: if ( (not intf.IN_MRT_ISLAND) and (not intf.MRT_INELIGIBLE) and (not intf.remote_intf.MRT_INELIGIBLE) and (not intf.IGP_EXCLUDED) and intf.area == area and (profile_id in intf.remote_node.profile_id_list)): intf.IN_MRT_ISLAND = True intf.remote_intf.IN_MRT_ISLAND = True if (not intf.remote_node.IN_MRT_ISLAND):",
      "ja": "デフMRT_Island_Identification（TOPO、computing_rtr、PROFILE_ID、エリア）：computing_rtr.profile_id_listに説明profile_id場合：computing_rtr.IN_MRT_ISLAND = Trueのexplore_list = [computing_rtr]他：しばらく復帰explore_list = []：！next_rtr = explore_list.pop（）next_rtrでINTFのため.intf_list：（（ないintf.IN_MRT_ISLAND）IFおよび（intf.MRT_INELIGIBLEず）および（intf.remote_intf.MRT_INELIGIBLEず）および（intf.IGP_EXCLUDEDず）とintf.remote_node.profile_id_listでintf.area ==領域と（PROFILE_ID ））：intf.IN_MRT_ISLAND = Trueのintf.remote_intf.IN_MRT_ISLAND =真（ないintf.remote_node.IN_MRT_ISLAND）の場合："
    },
    {
      "indent": 20,
      "text": "intf.remote_INTF.IN_MRT_ISLAND = True\nexplore_list.append(intf.remote_node)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "def Compute_Island_Node_List_For_Test_GR(topo, test_gr): Reset_Computed_Node_and_Intf_Values(topo) topo.test_gr = topo.node_dict[test_gr] MRT_Island_Identification(topo, topo.test_gr, 0, 0) for node in topo.node_list: if node.IN_MRT_ISLAND: topo.island_node_list_for_test_gr.append(node)",
      "ja": "DEF Compute_Island_Node_List_For_Test_GR（TOPO、test_gr）：topo.node_listにおけるノードのReset_Computed_Node_and_Intf_Values（TOPO）topo.test_gr = topo.node_dict [test_gr] MRT_Island_Identification（TOPO、topo.test_gr、0、0）：node.IN_MRT_ISLAND場合：topo.island_node_list_for_test_gr。追加（ノード）"
    },
    {
      "indent": 0,
      "text": "def Set_Island_Intf_and_Node_Lists(topo): for node in topo.node_list: if node.IN_MRT_ISLAND: topo.island_node_list.append(node) for intf in node.intf_list: if intf.IN_MRT_ISLAND: node.island_intf_list.append(intf)",
      "ja": "DEF Set_Island_Intf_and_Node_Lists（TOPO）：topo.node_listにおけるノードの：node.IN_MRT_ISLAND場合：node.intf_listでINTFためtopo.island_node_list.append（ノード）：intf.IN_MRT_ISLAND場合：node.island_intf_list.append（INTF）"
    },
    {
      "indent": 0,
      "text": "global_dfs_number = None",
      "ja": "global_dfs_number =なし"
    },
    {
      "indent": 0,
      "text": "def Lowpoint_Visit(x, parent, intf_p_to_x): global global_dfs_number x.dfs_number = global_dfs_number x.lowpoint_number = x.dfs_number global_dfs_number += 1 x.dfs_parent = parent if intf_p_to_x == None: x.dfs_parent_intf = None else: x.dfs_parent_intf = intf_p_to_x.remote_intf x.lowpoint_parent = None if parent != None: parent.dfs_child_list.append(x) for intf in x.island_intf_list: if intf.remote_node.dfs_number == None: Lowpoint_Visit(intf.remote_node, x, intf) if intf.remote_node.lowpoint_number < x.lowpoint_number: x.lowpoint_number = intf.remote_node.lowpoint_number x.lowpoint_parent = intf.remote_node x.lowpoint_parent_intf = intf else: if intf.remote_node is not parent: if intf.remote_node.dfs_number < x.lowpoint_number: x.lowpoint_number = intf.remote_node.dfs_number x.lowpoint_parent = intf.remote_node x.lowpoint_parent_intf = intf",
      "ja": "デフLowpoint_Visit（X、親、intf_p_to_x）：グローバルglobal_dfs_number x.dfs_number = global_dfs_number x.lowpoint_number = x.dfs_number global_dfs_number + = 1 x.dfs_parent =親であればintf_p_to_x ==なし：x.dfs_parent_intf =他なし：x.dfs_parent_intf = intf_p_to_x.remote_intf x.lowpoint_parent =なしの場合、親=なし：！x.island_intf_listでINTFためparent.dfs_child_list.append（X）：Lowpoint_Visit（intf.remote_node、X、INTF）の場合：intf.remote_node.dfs_numberは==なしの場合intf.remote_node.lowpoint_number <x.lowpoint_number：x.lowpoint_number = intf.remote_node.lowpoint_number x.lowpoint_parent = intf.remote_node x.lowpoint_parent_intf = INTF他：intf.remote_node.dfs_number <Xの場合：intf.remote_nodeが親でない場合。 lowpoint_number：x.lowpoint_number = intf.remote_node.dfs_number x.lowpoint_parent = intf.remote_node x.lowpoint_parent_intf = INTF"
    },
    {
      "indent": 0,
      "text": "def Run_Lowpoint(topo): global global_dfs_number global_dfs_number = 0 Lowpoint_Visit(topo.gadag_root, None, None)",
      "ja": "デフRun_Lowpoint（トポ）：グローバルglobal_dfs_number global_dfs_number = 0 Lowpoint_Visit（topo.gadag_root、なし、なし）"
    },
    {
      "indent": 0,
      "text": "max_block_id = None",
      "ja": "max_block_id =なし"
    },
    {
      "indent": 0,
      "text": "def Assign_Block_ID(x, cur_block_id): global max_block_id x.block_id = cur_block_id for c in x.dfs_child_list: if (c.localroot is x): max_block_id += 1 Assign_Block_ID(c, max_block_id) else: Assign_Block_ID(c, cur_block_id)",
      "ja": "DEF Assign_Block_ID（X、cur_block_id）：x.dfs_child_listにおけるcためmax_block_id x.block_id = cur_block_idグローバル：他max_block_id + = 1 Assign_Block_ID（C、max_block_id）：（c.localrootはXである）場合Assign_Block_ID（C、cur_block_id）"
    },
    {
      "indent": 0,
      "text": "def Run_Assign_Block_ID(topo): global max_block_id max_block_id = 0 Assign_Block_ID(topo.gadag_root, max_block_id)",
      "ja": "DEF Run_Assign_Block_ID（TOPO）：グローバルmax_block_id max_block_id = 0 Assign_Block_ID（topo.gadag_root、max_block_id）"
    },
    {
      "indent": 0,
      "text": "def Construct_Ear(x, stack, intf, ear_type): ear_list = [] cur_intf = intf not_done = True while not_done: cur_intf.UNDIRECTED = False cur_intf.OUTGOING = True cur_intf.remote_intf.UNDIRECTED = False cur_intf.remote_intf.INCOMING = True if cur_intf.remote_node.IN_GADAG == False: cur_intf.remote_node.IN_GADAG = True ear_list.append(cur_intf.remote_node) if ear_type == 'CHILD': cur_intf = cur_intf.remote_node.lowpoint_parent_intf else: assert ear_type == 'NEIGHBOR' cur_intf = cur_intf.remote_node.dfs_parent_intf else: not_done = False",
      "ja": "DEF Construct_Ear（X、スタック、INTF、ear_type）：ear_list = [] cur_intf = INTF not_done =真not_doneつつ：もしcur_intf.UNDIRECTED = Falseのcur_intf.OUTGOING =真cur_intf.remote_intf.UNDIRECTED = Falseのcur_intf.remote_intf.INCOMING =真cur_intf.remote_node.IN_GADAG == FALSE：cur_intf.remote_node.IN_GADAG = Trueのear_list.append（cur_intf.remote_node）の場合ear_type == 'CHILD'：cur_intf = cur_intf.remote_node.lowpoint_parent_intf他：主張ear_type == '隣人cur_intf =他cur_intf.remote_node.dfs_parent_intf：not_done =偽"
    },
    {
      "indent": 4,
      "text": "if ear_type == 'CHILD' and cur_intf.remote_node is x:\n    # x is a cut-vertex and the local root for the block\n    # in which the ear is computed\n    x.IS_CUT_VERTEX = True\n    localroot = x\nelse:",
      "raw": true
    },
    {
      "indent": 8,
      "text": "# inherit local root from the end of the ear\nlocalroot = cur_intf.remote_node.localroot",
      "raw": true
    },
    {
      "indent": 4,
      "text": "while ear_list != []: y = ear_list.pop() y.localroot = localroot stack.append(y)",
      "ja": "ear_listながら= []：Y = ear_list.pop（）y.localroot = localroot stack.append（Y）"
    },
    {
      "indent": 0,
      "text": "def Construct_GADAG_via_Lowpoint(topo): gadag_root = topo.gadag_root gadag_root.IN_GADAG = True gadag_root.localroot = None stack = [] stack.append(gadag_root) while stack != []: x = stack.pop() for intf in x.island_intf_list: if ( intf.remote_node.IN_GADAG == False and intf.remote_node.dfs_parent is x ): Construct_Ear(x, stack, intf, 'CHILD' ) for intf in x.island_intf_list: if (intf.remote_node.IN_GADAG == False and intf.remote_node.dfs_parent is not x): Construct_Ear(x, stack, intf, 'NEIGHBOR')",
      "ja": "デフConstruct_GADAG_via_Lowpoint（トポ）：gadag_root = topo.gadag_root gadag_root.IN_GADAG = Trueのgadag_root.localroot =なしスタック= [] stack.append（gadag_root）スタックながら= []：！xのINTFのためのx = stack.pop（）。 island_intf_list：x.island_intf_listでINTFためConstruct_Ear（X、スタック、INTF、 '子'）：IF（intf.remote_node.IN_GADAG ==偽とintf.remote_node.dfs_parentはXである）（intf.remote_node.IN_GADAG ==場合偽とintf.remote_node.dfs_parentは、x）ではありません。Construct_Ear（X、スタック、INTF、 'NEIGHBOR'）"
    },
    {
      "indent": 0,
      "text": "def Assign_Remaining_Lowpoint_Parents(topo): for node in topo.island_node_list: if ( node is not topo.gadag_root and node.lowpoint_parent == None ): node.lowpoint_parent = node.dfs_parent node.lowpoint_parent_intf = node.dfs_parent_intf node.lowpoint_number = node.dfs_parent.dfs_number",
      "ja": "DEF Assign_Remaining_Lowpoint_Parents（TOPO）：topo.island_node_listにおけるノードの：node.lowpoint_parent = node.dfs_parent node.lowpoint_parent_intf = node.dfs_parent_intf node.lowpoint_number =ノード（ノードではないtopo.gadag_rootとnode.lowpoint_parent ==なし）であれば。 dfs_parent.dfs_number"
    },
    {
      "indent": 0,
      "text": "def Add_Undirected_Block_Root_Links(topo): for node in topo.island_node_list: if node.IS_CUT_VERTEX or node is topo.gadag_root: for intf in node.island_intf_list: if ( intf.remote_node.localroot is not node or intf.PROCESSED ): continue bundle_list = [] bundle = Bundle() for intf2 in node.island_intf_list: if intf2.remote_node is intf.remote_node: bundle_list.append(intf2) if not intf2.UNDIRECTED: bundle.UNDIRECTED = False if intf2.INCOMING:",
      "ja": "DEF Add_Undirected_Block_Root_Links（TOPO）：topo.island_node_listにおけるノードの：node.island_intf_listでINTF用：node.IS_CUT_VERTEXまたはノードtopo.gadag_rootである場合（intf.remote_node.localrootノード又はintf.PROCESSEDない）場合：続けるbundle_list = [] node.island_intf_listでINTF2ため）=バンドル（バンドル：intf2.remote_nodeがintf.remote_nodeある場合：intf2.UNDIRECTEDない場合bundle_list.append（INTF2）：bundle.UNDIRECTED = Falseのintf2.INCOMING場合："
    },
    {
      "indent": 16,
      "text": "                bundle.INCOMING = True\n            if intf2.OUTGOING:\n                bundle.OUTGOING = True\nif bundle.UNDIRECTED:\n    for intf3 in bundle_list:\n        intf3.UNDIRECTED = False\n        intf3.remote_intf.UNDIRECTED = False\n        intf3.PROCESSED = True\n        intf3.remote_intf.PROCESSED = True\n        intf3.OUTGOING = True\n        intf3.remote_intf.INCOMING = True\nelse:\n    if (bundle.OUTGOING and bundle.INCOMING):\n        for intf3 in bundle_list:\n            intf3.UNDIRECTED = False\n            intf3.remote_intf.UNDIRECTED = False\n            intf3.PROCESSED = True\n            intf3.remote_intf.PROCESSED = True\n            intf3.OUTGOING = True\n            intf3.INCOMING = True\n            intf3.remote_intf.INCOMING = True\n            intf3.remote_intf.OUTGOING = True\n    elif bundle.OUTGOING:\n        for intf3 in bundle_list:\n            intf3.UNDIRECTED = False\n            intf3.remote_intf.UNDIRECTED = False\n            intf3.PROCESSED = True\n            intf3.remote_intf.PROCESSED = True\n            intf3.OUTGOING = True\n            intf3.remote_intf.INCOMING = True\n    elif bundle.INCOMING:\n        for intf3 in bundle_list:\n            intf3.UNDIRECTED = False\n            intf3.remote_intf.UNDIRECTED = False\n            intf3.PROCESSED = True\n            intf3.remote_intf.PROCESSED = True\n            intf3.INCOMING = True\n            intf3.remote_intf.OUTGOING = True",
      "raw": true
    },
    {
      "indent": 0,
      "text": "def Modify_Block_Root_Incoming_Links(topo): for node in topo.island_node_list: if ( node.IS_CUT_VERTEX == True or node is topo.gadag_root ): for intf in node.island_intf_list: if intf.remote_node.localroot is node: if intf.INCOMING: intf.INCOMING = False intf.INCOMING_STORED = True intf.remote_intf.OUTGOING = False intf.remote_intf.OUTGOING_STORED = True",
      "ja": "DEF Modify_Block_Root_Incoming_Links（TOPO）：topo.island_node_listにおけるノードの：（node.IS_CUT_VERTEX == trueまたはノードtopo.gadag_rootある）場合：node.island_intf_listでINTF用：intf.remote_node.localrootノードである場合：intf.INCOMING場合： intf.INCOMING = Falseのintf.INCOMING_STORED = Trueのintf.remote_intf.OUTGOING = Falseのintf.remote_intf.OUTGOING_STORED =真"
    },
    {
      "indent": 0,
      "text": "def Revert_Block_Root_Incoming_Links(topo): for node in topo.island_node_list: if ( node.IS_CUT_VERTEX == True or node is topo.gadag_root ): for intf in node.island_intf_list: if intf.remote_node.localroot is node: if intf.INCOMING_STORED: intf.INCOMING = True intf.remote_intf.OUTGOING = True intf.INCOMING_STORED = False intf.remote_intf.OUTGOING_STORED = False",
      "ja": "DEF Revert_Block_Root_Incoming_Links（TOPO）：topo.island_node_listにおけるノードの：（node.IS_CUT_VERTEX == trueまたはノードtopo.gadag_rootある）場合：node.island_intf_listでINTF用：intf.remote_node.localrootノードである場合：intf.INCOMING_STORED場合： intf.INCOMING =真intf.remote_intf.OUTGOING =真intf.INCOMING_STORED = Falseのintf.remote_intf.OUTGOING_STORED =偽"
    },
    {
      "indent": 0,
      "text": "def Run_Topological_Sort_GADAG(topo): Modify_Block_Root_Incoming_Links(topo) for node in topo.island_node_list: node.unvisited = 0 for intf in node.island_intf_list: if (intf.INCOMING == True): node.unvisited += 1 working_list = [] topo_order_list = [] working_list.append(topo.gadag_root) while working_list != []: y = working_list.pop(0) topo_order_list.append(y) for intf in y.island_intf_list: if ( intf.OUTGOING == True): intf.remote_node.unvisited -= 1 if intf.remote_node.unvisited == 0: working_list.append(intf.remote_node) next_topo_order = 1 while topo_order_list != []: y = topo_order_list.pop(0) y.topo_order = next_topo_order next_topo_order += 1 Revert_Block_Root_Incoming_Links(topo)",
      "ja": "DEF Run_Topological_Sort_GADAG（TOPO）：topo.island_node_listにおけるノードのModify_Block_Root_Incoming_Links（TOPO）：node.island_intf_listにINTFため= 0 node.unvisited：（intf.INCOMING == TRUE）であれば：node.unvisited + = 1 working_list = [] topo_order_list = [] working_list.append（topo.gadag_root）working_list = []しばらく：Y = working_list.pop（0）topo_order_list.append y.island_intf_listでINTF用（Y）：IF（intf.OUTGOING == TRUE）：INTF .remote_node.unvisited  -  = 1 intf.remote_node.unvisited == 0の場合：working_list.append（intf.remote_node）next_topo_order = 1一方topo_order_list = []：Y = topo_order_list.pop（0）y.topo_order = next_topo_order next_topo_order +！ = 1 Revert_Block_Root_Incoming_Links（TOPO）"
    },
    {
      "indent": 0,
      "text": "def Set_Other_Undirected_Links_Based_On_Topo_Order(topo): for node in topo.island_node_list: for intf in node.island_intf_list: if intf.UNDIRECTED: if node.topo_order < intf.remote_node.topo_order: intf.OUTGOING = True intf.UNDIRECTED = False intf.remote_intf.INCOMING = True intf.remote_intf.UNDIRECTED = False else:",
      "ja": "デフSet_Other_Undirected_Links_Based_On_Topo_Order（トポ）：topo.island_node_list内のノードのために：node.island_intf_listでINTF用：intf.UNDIRECTEDの場合：intf.OUTGOING = Trueのintf.UNDIRECTED = Falseのintf.remote_intf：node.topo_order <intf.remote_node.topo_order場合。 INCOMING = Trueのintf.remote_intf.UNDIRECTEDそうでない=偽："
    },
    {
      "indent": 20,
      "text": "intf.INCOMING = True\nintf.UNDIRECTED = False\nintf.remote_intf.OUTGOING = True\nintf.remote_intf.UNDIRECTED = False",
      "raw": true
    },
    {
      "indent": 0,
      "text": "def Initialize_Temporary_Interface_Flags(topo): for node in topo.island_node_list: for intf in node.island_intf_list: intf.PROCESSED = False intf.INCOMING_STORED = False intf.OUTGOING_STORED = False",
      "ja": "node.island_intf_listでINTF用：デフInitialize_Temporary_Interface_Flags（TOPO）：topo.island_node_listにおけるノードのintf.PROCESSED =偽intf.INCOMING_STORED =偽intf.OUTGOING_STORED =偽"
    },
    {
      "indent": 0,
      "text": "def Add_Undirected_Links(topo): Initialize_Temporary_Interface_Flags(topo) Add_Undirected_Block_Root_Links(topo) Run_Topological_Sort_GADAG(topo) Set_Other_Undirected_Links_Based_On_Topo_Order(topo)",
      "ja": "デフAdd_Undirected_Links（トポ）：Initialize_Temporary_Interface_Flags（トポ）Add_Undirected_Block_Root_Links（トポ）Run_Topological_Sort_GADAG（トポ）Set_Other_Undirected_Links_Based_On_Topo_Order（トポ）"
    },
    {
      "indent": 0,
      "text": "def In_Common_Block(x,y): if ( (x.block_id == y.block_id) or ( x is y.localroot) or (y is x.localroot) ): return True return False",
      "ja": "DEF In_Common_Block（X、Y）：（（x.block_id == y.block_id）または（Xはy.localrootである）、または（y）がx.localrootある）場合：trueを返すのにFALSEを返します"
    },
    {
      "indent": 0,
      "text": "def Copy_List_Items(target_list, source_list): del target_list[:] # Python idiom to remove all elements of a list for element in source_list: target_list.append(element)",
      "ja": "DEF Copy_List_Items（target_list、source_list）：デルtarget_listの[：] source_listに要素のリストのすべての要素を除去するため＃のPythonのイディオム：target_list.append（要素）"
    },
    {
      "indent": 0,
      "text": "def Add_Item_To_List_If_New(target_list, item): if item not in target_list: target_list.append(item)",
      "ja": "DEF Add_Item_To_List_If_New（target_list、項目）：アイテムないtarget_listであれば：target_list.append（アイテム）"
    },
    {
      "indent": 0,
      "text": "def Store_Results(y, direction): if direction == 'INCREASING': y.HIGHER = True Copy_List_Items(y.blue_next_hops, y.next_hops) if direction == 'DECREASING': y.LOWER = True Copy_List_Items(y.red_next_hops, y.next_hops) if direction == 'NORMAL_SPF': y.primary_spf_metric = y.spf_metric Copy_List_Items(y.primary_next_hops, y.next_hops) if direction == 'MRT_ISLAND_SPF': Copy_List_Items(y.mrt_island_next_hops, y.next_hops) if direction == 'COLLAPSED_SPF': y.collapsed_metric = y.spf_metric Copy_List_Items(y.collapsed_next_hops, y.next_hops)",
      "ja": "DEF Store_Results（Y方向）方向== 'INCREASING' の場合：場合（y.blue_next_hops、y.next_hops）y.HIGHER =真Copy_List_Itemsを方向== '減少'：y.LOWER =真Copy_List_Itemsを（y.red_next_hops、 y.next_hops）方向場合== 'NORMAL_SPF'：y.primary_spf_metric = y.spf_metric Copy_List_Items（y.primary_next_hops、y.next_hops）方向== 'MRT_ISLAND_SPF' 場合：Copy_List_Items（y.mrt_island_next_hops、y.next_hops）方向なら= = 'COLLAPSED_SPF'：y.collapsed_metric = y.spf_metric Copy_List_Items（y.collapsed_next_hops、y.next_hops）"
    },
    {
      "indent": 0,
      "text": "# Note that the Python heapq function allows for duplicate items, # so we use the 'spf_visited' property to only consider a node # as min_node the first time it gets removed from the heap. def SPF_No_Traverse_Block_Root(topo, spf_root, block_root, direction): spf_heap = [] for y in topo.island_node_list: y.spf_metric = 2147483647 # 2^31-1 y.next_hops = [] y.spf_visited = False spf_root.spf_metric = 0 heapq.heappush(spf_heap, (spf_root.spf_metric, spf_root.node_id, spf_root) ) while spf_heap != []: #extract third element of tuple popped from heap min_node = heapq.heappop(spf_heap)[2] if min_node.spf_visited: continue min_node.spf_visited = True Store_Results(min_node, direction) if ( (min_node is spf_root) or (min_node is not block_root) ): for intf in min_node.island_intf_list: if ( ( (direction == 'INCREASING' and intf.OUTGOING ) or (direction == 'DECREASING' and intf.INCOMING ) ) and In_Common_Block(spf_root, intf.remote_node) ) : path_metric = min_node.spf_metric + intf.metric if path_metric < intf.remote_node.spf_metric: intf.remote_node.spf_metric = path_metric if min_node is spf_root: intf.remote_node.next_hops = [intf] else: Copy_List_Items(intf.remote_node.next_hops, min_node.next_hops) heapq.heappush(spf_heap, ( intf.remote_node.spf_metric, intf.remote_node.node_id, intf.remote_node ) ) elif path_metric == intf.remote_node.spf_metric: if min_node is spf_root: Add_Item_To_List_If_New( intf.remote_node.next_hops,intf) else: for nh_intf in min_node.next_hops: Add_Item_To_List_If_New( intf.remote_node.next_hops,nh_intf)",
      "ja": "Pythonのheapq機能が重複するアイテムを可能にすること＃（注）、＃ので、我々は唯一のmin_nodeとしてノード＃それがヒープから削除される最初の時間を考慮に「spf_visited」プロパティを使用します。 DEF SPF_No_Traverse_Block_Root（TOPO、spf_root、block_root、方向）spf_heap = [] topo.island_node_listにおけるYについて：y.spf_metric = 2147483647＃2 ^ 31-1 y.next_hops = [] y.spf_visited =偽spf_root.spf_metric = 0 heapq.heappush（spf_heap、（spf_root.spf_metric、spf_root.node_id、spf_root））spf_heapながら= []：ヒープmin_node = heapq.heappop（spf_heap）からポップタプルの#extract第三の要素[2] min_node.spf_visited場合： min_node.island_intf_listにINTF用：min_node.spf_visited =真Store_Results（min_node、方向）と（（min_nodeがspf_rootである）または（min_node）がblock_rootない）続ける（（（方向== 'INCREASING' とintf.OUTGOING）場合または（方向== '減少' とintf.INCOMING））とIn_Common_Block（spf_root、intf.remote_node））：path_metric = min_node.spf_metric + intf.metric場合path_metric <intf.remote_node.spf_metric：intf.remote_node.spf_metric = path_metric min_nodeがspf_rootの場合：intf.remote_node.next_hops = [INTF]他：Copy_List_Items（intf.remote_node.next_h OPS、min_node.next_hops）heapq.heappush（spf_heap、（intf.remote_node.spf_metric、intf.remote_node.node_id、intf.remote_node））のelifのpath_metric == intf.remote_node.spf_metric：min_nodeがspf_rootの場合：Add_Item_To_List_If_New（intf.remote_node .next_hops、INTF）他：min_node.next_hopsでnh_intf用：Add_Item_To_List_If_New（intf.remote_node.next_hops、nh_intf）"
    },
    {
      "indent": 0,
      "text": "def Normal_SPF(topo, spf_root): spf_heap = [] for y in topo.node_list:",
      "ja": "DEF Normal_SPF（TOPO、spf_root）：spf_heap = [] topo.node_listでYの場合："
    },
    {
      "indent": 4,
      "text": "    y.spf_metric = 2147483647 # 2^31-1 as max metric\n    y.next_hops = []\n    y.primary_spf_metric = 2147483647\n    y.primary_next_hops = []\n    y.spf_visited = False\nspf_root.spf_metric = 0\nheapq.heappush(spf_heap,\n               (spf_root.spf_metric,spf_root.node_id,spf_root) )\nwhile spf_heap != []:\n    #extract third element of tuple popped from heap\n    min_node = heapq.heappop(spf_heap)[2]\n    if min_node.spf_visited:\n        continue\n    min_node.spf_visited = True\n    Store_Results(min_node, 'NORMAL_SPF')\n    for intf in min_node.intf_list:\n        path_metric = min_node.spf_metric + intf.metric\n        if path_metric < intf.remote_node.spf_metric:\n            intf.remote_node.spf_metric = path_metric\n            if min_node is spf_root:\n                intf.remote_node.next_hops = [intf]\n            else:\n                Copy_List_Items(intf.remote_node.next_hops,\n                                min_node.next_hops)\n            heapq.heappush(spf_heap,\n                           ( intf.remote_node.spf_metric,\n                             intf.remote_node.node_id,\n                             intf.remote_node ) )\n        elif path_metric == intf.remote_node.spf_metric:\n            if min_node is spf_root:\n                Add_Item_To_List_If_New(\n                    intf.remote_node.next_hops,intf)\n            else:\n                for nh_intf in min_node.next_hops:\n                    Add_Item_To_List_If_New(\n                        intf.remote_node.next_hops,nh_intf)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "def Set_Edge(y): if (y.blue_next_hops == [] and y.red_next_hops == []): Set_Edge(y.localroot) Copy_List_Items(y.blue_next_hops,y.localroot.blue_next_hops) Copy_List_Items(y.red_next_hops ,y.localroot.red_next_hops) y.order_proxy = y.localroot.order_proxy",
      "ja": "DEF Set_Edge（Y）：IF（y.blue_next_hops == []とy.red_next_hops == []）：Set_Edge（y.localroot）Copy_List_Items（y.blue_next_hops、y.localroot.blue_next_hops）Copy_List_Items（y.red_next_hops、Y .localroot.red_next_hops）y.order_proxy = y.localroot.order_proxy"
    },
    {
      "indent": 0,
      "text": "def Compute_MRT_NH_For_One_Src_To_Island_Dests(topo,x): for y in topo.island_node_list: y.HIGHER = False y.LOWER = False y.red_next_hops = [] y.blue_next_hops = [] y.order_proxy = y SPF_No_Traverse_Block_Root(topo, x, x.localroot, 'INCREASING') SPF_No_Traverse_Block_Root(topo, x, x.localroot, 'DECREASING') for y in topo.island_node_list: if ( y is not x and (y.block_id == x.block_id) ): assert (not ( y is x.localroot or x is y.localroot) ) assert(not (y.HIGHER and y.LOWER) ) if y.HIGHER == True: Copy_List_Items(y.red_next_hops, x.localroot.red_next_hops) elif y.LOWER == True: Copy_List_Items(y.blue_next_hops, x.localroot.blue_next_hops) else: Copy_List_Items(y.blue_next_hops, x.localroot.red_next_hops) Copy_List_Items(y.red_next_hops, x.localroot.blue_next_hops)",
      "ja": "DEF Compute_MRT_NH_For_One_Src_To_Island_Dests（TOPO、X）：topo.island_node_listにおけるY用：y.HIGHERは=偽y.LOWER =偽y.red_next_hops = [] y.blue_next_hops = [] y.order_proxy = Y SPF_No_Traverse_Block_Root（TOPO、X、X。 localroot、（topo.island_node_listでyについてTOPO、X、x.localroot、 '減少'）：（YはXと（y.block_id == x.block_idない場合））SPF_No_Traverse_Block_Root '増やすと'）：（アサート（ありませんCopy_List_Items（y.red_next_hops、x.localroot.red_next_hops）ELIF y.LOWER：yはx.localrootまたはxがy.HIGHER ==真ならy.localroot））をアサート（ない（y.HIGHERとy.LOWER））であります==真：他Copy_List_Items（y.blue_next_hops、x.localroot.blue_next_hops）：Copy_List_Items（y.blue_next_hops、x.localroot.red_next_hops）Copy_List_Items（y.red_next_hops、x.localroot.blue_next_hops）"
    },
    {
      "indent": 4,
      "text": "# Inherit x's MRT next hops to reach the GADAG root\n# from x's MRT next hops to reach its local root,\n# but first check if x is the gadag_root (in which case\n# x does not have a local root) or if x's local root\n# is the gadag root (in which case we already have the\n# x's MRT next hops to reach the gadag root)\nif x is not topo.gadag_root and x.localroot is not topo.gadag_root:\n    Copy_List_Items(topo.gadag_root.blue_next_hops,\n                    x.localroot.blue_next_hops)\n    Copy_List_Items(topo.gadag_root.red_next_hops,\n                    x.localroot.red_next_hops)\n    topo.gadag_root.order_proxy = x.localroot",
      "raw": true
    },
    {
      "indent": 4,
      "text": "# Inherit next hops and order_proxies to other blocks for y in topo.island_node_list: if (y is not topo.gadag_root and y is not x ): Set_Edge(y)",
      "ja": "＃継承topo.island_node_listにおけるYの他のブロックへの次ホップとorder_proxies：（Yはtopo.gadag_rootず、yはxはない）場合：Set_Edge（Y）"
    },
    {
      "indent": 0,
      "text": "def Store_MRT_Nexthops_For_One_Src_To_Island_Dests(topo,x): for y in topo.island_node_list: if y is x: continue x.blue_next_hops_dict[y.node_id] = [] x.red_next_hops_dict[y.node_id] = [] Copy_List_Items(x.blue_next_hops_dict[y.node_id], y.blue_next_hops)",
      "ja": "DEF Store_MRT_Nexthops_For_One_Src_To_Island_Dests（TOPO、X）：topo.island_node_listにおけるYのYはXである場合：続けるx.blue_next_hops_dict [y.node_id] = [] x.red_next_hops_dict [y.node_id] = [] Copy_List_Items（x.blue_next_hops_dict [Y .node_id]、y.blue_next_hops）"
    },
    {
      "indent": 8,
      "text": "Copy_List_Items(x.red_next_hops_dict[y.node_id],\n                y.red_next_hops)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "def Store_Primary_and_Alts_For_One_Src_To_Island_Dests(topo,x): for y in topo.island_node_list: x.pnh_dict[y.node_id] = [] Copy_List_Items(x.pnh_dict[y.node_id], y.primary_next_hops) x.alt_dict[y.node_id] = [] Copy_List_Items(x.alt_dict[y.node_id], y.alt_list)",
      "ja": "DEF Store_Primary_and_Alts_For_One_Src_To_Island_Dests（TOPO、X）：yのtopo.island_node_listで：x.pnh_dict [y.node_id] = [] Copy_List_Items（x.pnh_dict [y.node_id]、y.primary_next_hops）x.alt_dict [y.node_id] = [] Copy_List_Items（x.alt_dict [y.node_id]、y.alt_list）"
    },
    {
      "indent": 0,
      "text": "def Store_Primary_NHs_For_One_Source_To_Nodes(topo,x): for y in topo.node_list: x.pnh_dict[y.node_id] = [] Copy_List_Items(x.pnh_dict[y.node_id], y.primary_next_hops)",
      "ja": "topo.node_listにおけるyの：DEF Store_Primary_NHs_For_One_Source_To_Nodes（TOPO、X）x.pnh_dict [y.node_id] = [] Copy_List_Items（x.pnh_dict [y.node_id]、y.primary_next_hops）"
    },
    {
      "indent": 0,
      "text": "def Store_MRT_NHs_For_One_Src_To_Named_Proxy_Nodes(topo,x): for prefix in topo.named_proxy_dict: P = topo.named_proxy_dict[prefix] x.blue_next_hops_dict[P.node_id] = [] x.red_next_hops_dict[P.node_id] = [] Copy_List_Items(x.blue_next_hops_dict[P.node_id], P.blue_next_hops) Copy_List_Items(x.red_next_hops_dict[P.node_id], P.red_next_hops)",
      "ja": "DEF Store_MRT_NHs_For_One_Src_To_Named_Proxy_Nodes（TOPO、X）：プレフィックスのtopo.named_proxy_dictで：P = topo.named_proxy_dict [プレフィックス] x.blue_next_hops_dict [P.node_id] = [] x.red_next_hops_dict [P.node_id] = [] Copy_List_Items（x.blue_next_hops_dict [P.node_id]、P.blue_next_hops）Copy_List_Items（x.red_next_hops_dict [P.node_id]、P.red_next_hops）"
    },
    {
      "indent": 0,
      "text": "def Store_Alts_For_One_Src_To_Named_Proxy_Nodes(topo,x): for prefix in topo.named_proxy_dict: P = topo.named_proxy_dict[prefix] x.alt_dict[P.node_id] = [] Copy_List_Items(x.alt_dict[P.node_id], P.alt_list)",
      "ja": "DEF Store_Alts_For_One_Src_To_Named_Proxy_Nodes（TOPO、X）：プレフィックスのtopo.named_proxy_dictで：P = topo.named_proxy_dict [プレフィックス] x.alt_dict [P.node_id] = [] Copy_List_Items（x.alt_dict [P.node_id]、P.alt_list）"
    },
    {
      "indent": 0,
      "text": "def Store_Primary_NHs_For_One_Src_To_Named_Proxy_Nodes(topo,x): for prefix in topo.named_proxy_dict: P = topo.named_proxy_dict[prefix] x.pnh_dict[P.node_id] = [] Copy_List_Items(x.pnh_dict[P.node_id], P.primary_next_hops)",
      "ja": "DEF Store_Primary_NHs_For_One_Src_To_Named_Proxy_Nodes（TOPO、X）：プレフィックスのtopo.named_proxy_dictで：P = topo.named_proxy_dict [プレフィックス] x.pnh_dict [P.node_id] = [] Copy_List_Items（x.pnh_dict [P.node_id]、P.primary_next_hops）"
    },
    {
      "indent": 0,
      "text": "def Select_Alternates_Internal(D, F, primary_intf, D_lower, D_higher, D_topo_order): if D_higher and D_lower: if F.HIGHER and F.LOWER: if F.topo_order > D_topo_order: return 'USE_BLUE' else: return 'USE_RED' if F.HIGHER:",
      "ja": "DEF Select_Alternates_Internal（D、F、primary_intf、D_lower、D_higher、D_topo_order）：もしD_higherとD_lower：もしF.HIGHERとF.LOWER：もしF.topo_order> D_topo_order：リターン 'USE_BLUE' 他：戻り 'USE_RED' もしF. HIGHER："
    },
    {
      "indent": 4,
      "text": "        return 'USE_RED'\n    if F.LOWER:\n        return 'USE_BLUE'\n    assert(primary_intf.MRT_INELIGIBLE\n           or primary_intf.remote_intf.MRT_INELIGIBLE)\n    return 'USE_RED_OR_BLUE'\nif D_higher:\n    if F.HIGHER and F.LOWER:\n        return 'USE_BLUE'\n    if F.LOWER:\n        return 'USE_BLUE'\n    if F.HIGHER:\n        if (F.topo_order > D_topo_order):\n            return 'USE_BLUE'\n        if (F.topo_order < D_topo_order):\n            return 'USE_RED'\n        assert(False)\n    assert(primary_intf.MRT_INELIGIBLE\n           or primary_intf.remote_intf.MRT_INELIGIBLE)\n    return 'USE_RED_OR_BLUE'\nif D_lower:\n    if F.HIGHER and F.LOWER:\n        return 'USE_RED'\n    if F.HIGHER:\n        return 'USE_RED'\n    if F.LOWER:\n        if F.topo_order > D_topo_order:\n            return 'USE_BLUE'\n        if F.topo_order < D_topo_order:\n            return 'USE_RED'\n        assert(False)\n    assert(primary_intf.MRT_INELIGIBLE\n           or primary_intf.remote_intf.MRT_INELIGIBLE)\n    return 'USE_RED_OR_BLUE'\nelse: # D is unordered wrt S\n    if F.HIGHER and F.LOWER:\n        if primary_intf.OUTGOING and primary_intf.INCOMING:\n            # This can happen when F and D are in different blocks\n            return 'USE_RED_OR_BLUE'\n        if primary_intf.OUTGOING:\n            return 'USE_BLUE'\n        if primary_intf.INCOMING:\n            return 'USE_RED'\n        #This can occur when primary_intf is MRT_INELIGIBLE.\n        #This appears to be a case where the special\n        #construction of the GADAG allows us to choose red,\n        #whereas with an arbitrary GADAG, neither red nor blue\n        #is guaranteed to work.",
      "raw": true
    },
    {
      "indent": 8,
      "text": "    assert(primary_intf.MRT_INELIGIBLE\n           or primary_intf.remote_intf.MRT_INELIGIBLE)\n    return 'USE_RED'\nif F.LOWER:\n    return 'USE_RED'\nif F.HIGHER:\n    return 'USE_BLUE'\nassert(primary_intf.MRT_INELIGIBLE\n       or primary_intf.remote_intf.MRT_INELIGIBLE)\nif F.topo_order > D_topo_order:\n    return 'USE_BLUE'\nelse:\n    return 'USE_RED'",
      "raw": true
    },
    {
      "indent": 0,
      "text": "def Select_Alternates(D, F, primary_intf): S = primary_intf.local_node if not In_Common_Block(F, S): return 'PRIM_NH_IN_DIFFERENT_BLOCK' if (D is F) or (D.order_proxy is F): return 'PRIM_NH_IS_D_OR_OP_FOR_D' D_lower = D.order_proxy.LOWER D_higher = D.order_proxy.HIGHER D_topo_order = D.order_proxy.topo_order return Select_Alternates_Internal(D, F, primary_intf, D_lower, D_higher, D_topo_order)",
      "ja": "DEF Select_Alternates（D、F、primary_intf）：S = primary_intf.local_nodeない場合In_Common_Block（F、S）：リターン 'PRIM_NH_IN_DIFFERENT_BLOCK' IF（DがFである）または（D.order_proxyがFである）：リターン 'PRIM_NH_IS_D_OR_OP_FOR_D' D_lower = D .order_proxy.LOWER D_higher = D.order_proxy.HIGHER D_topo_order = D.order_proxy.topo_order Select_Alternates_Internal（D、F、primary_intf、D_lower、D_higher、D_topo_order）を返します"
    },
    {
      "indent": 0,
      "text": "def Is_Remote_Node_In_NH_List(node, intf_list): for intf in intf_list: if node is intf.remote_node: return True return False",
      "ja": "デフIs_Remote_Node_In_NH_List（ノード、intf_list）：ノードがある場合intf.remote_nodeは：intf_listでINTFのためには、trueを返しますFalseを返します"
    },
    {
      "indent": 0,
      "text": "def Select_Alts_For_One_Src_To_Island_Dests(topo,x): Normal_SPF(topo, x) for D in topo.island_node_list: D.alt_list = [] if D is x: continue for failed_intf in D.primary_next_hops: alt = Alternate() alt.failed_intf = failed_intf cand_alt_list = [] F = failed_intf.remote_node #We need to test if F is in the island, as opposed #to just testing if failed_intf is in island_intf_list, #because failed_intf could be marked as MRT_INELIGIBLE. if F in topo.island_node_list:",
      "ja": "DEF Select_Alts_For_One_Src_To_Island_Dests（TOPO、X）：Normal_SPF（TOPO、X）topo.island_node_listにおけるDのために：D.alt_list = [] Dである場合、X：D.primary_next_hopsでfailed_intf継続：ALT =代替（）alt.failed_intf = failed_intf cand_alt_list = [] F = failed_intf.remote_node #WE failed_intfがMRT_INELIGIBLEとしてマークすることができ#because failed_intfは、island_intf_listである場合にだけテスト#toとは対照的にFが、島にあるかどうかをテストする必要があります。 topo.island_node_listでのFの場合："
    },
    {
      "indent": 12,
      "text": "    alt.info = Select_Alternates(D, F, failed_intf)\nelse:\n    #The primary next hop is not in the MRT Island.\n    #Either red or blue will avoid the primary next hop,\n    #because the primary next hop is not even in the\n    #GADAG.\n    alt.info = 'USE_RED_OR_BLUE'",
      "raw": true
    },
    {
      "indent": 12,
      "text": "if (alt.info == 'USE_RED_OR_BLUE'): alt.red_or_blue = random.choice(['USE_RED','USE_BLUE']) if (alt.info == 'USE_BLUE' or alt.red_or_blue == 'USE_BLUE'): Copy_List_Items(alt.nh_list, D.blue_next_hops) alt.fec = 'BLUE' alt.prot = 'NODE_PROTECTION' if (alt.info == 'USE_RED' or alt.red_or_blue == 'USE_RED'): Copy_List_Items(alt.nh_list, D.red_next_hops) alt.fec = 'RED' alt.prot = 'NODE_PROTECTION' if (alt.info == 'PRIM_NH_IN_DIFFERENT_BLOCK'): alt.fec = 'NO_ALTERNATE' alt.prot = 'NO_PROTECTION' if (alt.info == 'PRIM_NH_IS_D_OR_OP_FOR_D'): if failed_intf.OUTGOING and failed_intf.INCOMING: # cut-link: if there are parallel cut links, use # the link(s) with lowest metric that are not # primary intf or None cand_alt_list = [None] min_metric = 2147483647 for intf in x.island_intf_list: if ( intf is not failed_intf and (intf.remote_node is failed_intf.remote_node)): if intf.metric < min_metric: cand_alt_list = [intf] min_metric = intf.metric elif intf.metric == min_metric: cand_alt_list.append(intf) if cand_alt_list != [None]: alt.fec = 'GREEN' alt.prot = 'PARALLEL_CUTLINK' else: alt.fec = 'NO_ALTERNATE' alt.prot = 'NO_PROTECTION' Copy_List_Items(alt.nh_list, cand_alt_list)",
      "ja": "IF（alt.info == 'USE_RED_OR_BLUE'）：alt.red_or_blue = random.choice（[ 'USE_RED'、 'USE_BLUE']）IF（alt.info == 'USE_BLUE' またはalt.red_or_blue == 'USE_BLUE'） ：Copy_List_Items（alt.nh_list、D.blue_next_hops）alt.fec = 'BLUE' alt.prot = 'NODE_PROTECTION' をIF（alt.info == 'USE_RED' またはalt.red_or_blue == 'USE_RED'）：Copy_List_Items（ALT。 nh_list、D.red_next_hops）alt.fec = 'RED' alt.prot = 'NODE_PROTECTION' IF（）== 'PRIM_NH_IN_DIFFERENT_BLOCK' alt.info：alt.fec = 'NO_ALTERNATE' alt.prot = 'NO_PROTECTION'（ALT場合。情報==「PRIM_NH_IS_D_OR_OP_FOR_D」）：failed_intf.OUTGOINGとfailed_intf.INCOMING場合：＃カットリンク：パラレルカットリンクが存在する場合は、cand_alt_list =＃主INTFまたはNoneでない最小のメトリックを持つ＃リンク（複数可）を使用して[ x.island_intf_listでINTFため2147483647 = min_metricなし]：IF（INTFはfailed_intfしないし、（intf.remote_nodeがfailed_intf.remote_nodeある））：cand_alt_list = [INTF] min_metric = intf.metricのelif INTF：intf.metric <min_metric場合。メトリック==のmin_metric：cand_alt_list.append（ INTF）cand_alt_list場合= [なし]：！alt.fec =他の 'グリーン' alt.prot = 'PARALLEL_CUTLINK'：alt.fec = 'NO_ALTERNATE' alt.prot = 'NO_PROTECTION' Copy_List_Items（alt.nh_list、cand_alt_list）"
    },
    {
      "indent": 16,
      "text": "# Is_Remote_Node_In_NH_List() is used, as opposed\n# to just checking if failed_intf is in D.red_next_hops,",
      "raw": true
    },
    {
      "indent": 16,
      "text": "# because failed_intf could be marked as MRT_INELIGIBLE. elif Is_Remote_Node_In_NH_List(F, D.red_next_hops): Copy_List_Items(alt.nh_list, D.blue_next_hops) alt.fec = 'BLUE' alt.prot = 'LINK_PROTECTION' elif Is_Remote_Node_In_NH_List(F, D.blue_next_hops): Copy_List_Items(alt.nh_list, D.red_next_hops) alt.fec = 'RED' alt.prot = 'LINK_PROTECTION' else: alt.fec = random.choice(['RED','BLUE']) alt.prot = 'LINK_PROTECTION'",
      "ja": "＃failed_intfはMRT_INELIGIBLEとしてマークされる可能性があるため。 ELIF Is_Remote_Node_In_NH_List（F、D.red_next_hops）：Copy_List_Items（alt.nh_list、D.blue_next_hops）alt.fec = 'BLUE' alt.prot = 'LINK_PROTECTION' のelif Is_Remote_Node_In_NH_List（F、D.blue_next_hops）：Copy_List_Items（alt.nh_list、 D.red_next_hops）alt.fec = 'RED' alt.prot = 'LINK_PROTECTION' さもなければ：alt.fec = random.choice（[ '赤'、 '青']）alt.prot = 'LINK_PROTECTION'"
    },
    {
      "indent": 12,
      "text": "D.alt_list.append(alt)",
      "ja": "D.alt_list.append（合計）"
    },
    {
      "indent": 0,
      "text": "def Write_GADAG_To_File(topo, file_prefix):\n    gadag_edge_list = []\n    for node in topo.node_list:\n        for intf in node.intf_list:\n            if intf.SIMULATION_OUTGOING:\n                local_node =  \"%04d\" % (intf.local_node.node_id)\n                remote_node = \"%04d\" % (intf.remote_node.node_id)\n                intf_data = \"%03d\" % (intf.link_data)\n                edge_string=(local_node+','+remote_node+','+\n                             intf_data+'\\n')\n                gadag_edge_list.append(edge_string)\n    gadag_edge_list.sort();\n    filename = file_prefix + '_gadag.csv'\n    with open(filename, 'w') as gadag_file:\n        gadag_file.write('local_node,'\\\n                         'remote_node,local_intf_link_data\\n')\n        for edge_string in gadag_edge_list:\n            gadag_file.write(edge_string);",
      "raw": true
    },
    {
      "indent": 0,
      "text": "def Write_MRTs_For_All_Dests_To_File(topo, color, file_prefix): edge_list = [] for node in topo.island_node_list_for_test_gr: if color == 'blue': node_next_hops_dict = node.blue_next_hops_dict elif color == 'red': node_next_hops_dict = node.red_next_hops_dict for dest_node_id in node_next_hops_dict: for intf in node_next_hops_dict[dest_node_id]: gadag_root = \"%04d\" % (topo.gadag_root.node_id) dest_node = \"%04d\" % (dest_node_id) local_node = \"%04d\" % (intf.local_node.node_id) remote_node = \"%04d\" % (intf.remote_node.node_id) intf_data = \"%03d\" % (intf.link_data) edge_string=(gadag_root+','+dest_node+','+local_node+ ','+remote_node+','+intf_data+'\\n') edge_list.append(edge_string) edge_list.sort() filename = file_prefix + '_' + color + '_to_all.csv' with open(filename, 'w') as mrt_file: mrt_file.write('gadag_root,dest,'\\ 'local_node,remote_node,link_data\\n') for edge_string in edge_list: mrt_file.write(edge_string);",
      "ja": "DEF Write_MRTs_For_All_Dests_To_File（TOPO、色、FILE_PREFIX）：edge_list = [] topo.island_node_list_for_test_grにおけるノードの：node_next_hops_dict = node.blue_next_hops_dictのelif色== '赤'：色== '青' であればnode_next_hops_dict = node.red_next_hops_dict dest_node_idためにnode_next_hops_dict：node_next_hops_dictでINTFため[dest_node_id]：gadag_root = \"％04D\" ％（topo.gadag_root.node_id）dest_node = \"％04D\" ％（dest_node_id）LOCAL_NODE = \"％04D\" ％（intf.local_node.node_id）remote_node = \"％04D\" ％（intf.remote_node.node_id）intf_data = \"％03D\" ％（intf.link_data）edge_string =（gadag_root +」、 '+ dest_node +'、 '+ LOCAL_NODE +'、 '+ remote_node +'、 '+ intf_data +' \\ N '）edge_list.append（edge_string）edge_list.sort（）ファイル名= FILE_PREFIX + '_' +色+ '_to_all.csv' オープン（ファイル名で、 'W'）mrt_fileとして：mrt_file.write（' gadag_root、DEST、 edge_listにedge_stringための「\\ 'LOCAL_NODE、remote_node、link_dataする\\ n'）：mrt_file.write（edge_string）。"
    },
    {
      "indent": 0,
      "text": "def Write_Both_MRTs_For_All_Dests_To_File(topo, file_prefix): Write_MRTs_For_All_Dests_To_File(topo, 'blue', file_prefix) Write_MRTs_For_All_Dests_To_File(topo, 'red', file_prefix)",
      "ja": "DEF Write_Both_MRTs_For_All_Dests_To_File（TOPO、FILE_PREFIX）：Write_MRTs_For_All_Dests_To_File（TOPO、 '青'、FILE_PREFIX）Write_MRTs_For_All_Dests_To_File（TOPO、 '赤'、FILE_PREFIX）"
    },
    {
      "indent": 0,
      "text": "def Write_Alternates_For_All_Dests_To_File(topo, file_prefix): edge_list = [] for x in topo.island_node_list_for_test_gr: for dest_node_id in x.alt_dict: alt_list = x.alt_dict[dest_node_id] for alt in alt_list: for alt_intf in alt.nh_list: gadag_root = \"%04d\" % (topo.gadag_root.node_id) dest_node = \"%04d\" % (dest_node_id) prim_local_node = \\ \"%04d\" % (alt.failed_intf.local_node.node_id) prim_remote_node = \\ \"%04d\" % (alt.failed_intf.remote_node.node_id) prim_intf_data = \\ \"%03d\" % (alt.failed_intf.link_data) if alt_intf == None: alt_local_node = \"None\" alt_remote_node = \"None\" alt_intf_data = \"None\" else: alt_local_node = \\ \"%04d\" % (alt_intf.local_node.node_id) alt_remote_node = \\ \"%04d\" % (alt_intf.remote_node.node_id) alt_intf_data = \\ \"%03d\" % (alt_intf.link_data) edge_string = (gadag_root+','+dest_node+','+ prim_local_node+','+prim_remote_node+','+ prim_intf_data+','+alt_local_node+','+ alt_remote_node+','+alt_intf_data+','+ alt.fec +'\\n') edge_list.append(edge_string) edge_list.sort() filename = file_prefix + '_alts_to_all.csv' with open(filename, 'w') as alt_file: alt_file.write('gadag_root,dest,'\\ 'prim_nh.local_node,prim_nh.remote_node,'\\ 'prim_nh.link_data,alt_nh.local_node,'\\ 'alt_nh.remote_node,alt_nh.link_data,'\\ 'alt_nh.fec\\n') for edge_string in edge_list: alt_file.write(edge_string);",
      "ja": "DEF Write_Alternates_For_All_Dests_To_File（TOPO、FILE_PREFIX）：edge_list = [] xのtopo.island_node_list_for_test_grで：x.alt_dictでdest_node_id用：alt.nh_listでalt_intf用：gadag_root =「％alt_list = x.alt_dict [dest_node_id] alt_listにおけるALTのために04D」％（topo.gadag_root.node_id）dest_node = \"％04D\" ％（dest_node_id）prim_local_node = \\ \"％04D\" ％（alt.failed_intf.local_node.node_id）prim_remote_node = \\ \"％04D\" ％（alt.failed_intf。 remote_node.node_id）prim_intf_data = \\ \"％03D\" ％（alt.failed_intf.link_data）alt_intf ==なしの場合：alt_local_node = \"なし\" alt_remote_node = \"なし\" alt_intf_data = \"なし\" 他：alt_local_node = \\ \"％04D\" ％ \\（alt_intf.local_node.node_id）alt_remote_node = \\ \"％04D\" ％（alt_intf.remote_node.node_id）alt_intf_data = \"％03D\" ％（alt_intf.link_data）edge_string =（gadag_root +」、 '+ dest_node +'、 '+ prim_local_node +' 、 '+ prim_remote_node +'、 '+ prim_intf_data +'、 '+ alt_local_node +'、 '+ alt_remote_node +'、 '+ alt_intf_data +'、 '+ alt.fec +' \\ n '）edge_list.append（edge_string）edge_list.s ORT開く（）ファイル名= FILE_PREFIX + '_alts_to_all.csv'（ファイル名、 'W'）alt_fileとして：alt_file.write（ 'gadag_root、DEST、' \\ 'prim_nh.local_node、prim_nh.remote_node、' \\「prim_nh.link_data edge_listにedge_stringため、alt_nh.local_node、 '\\ 'alt_nh.remote_node、alt_nh.link_data、' \\ 'alt_nh.fecする\\ n'）：alt_file.write（edge_string）。"
    },
    {
      "indent": 0,
      "text": "def Raise_GADAG_Root_Selection_Priority(topo,node_id): node = topo.node_dict[node_id] node.GR_sel_priority = 255",
      "ja": "DEF Raise_GADAG_Root_Selection_Priority（TOPO、NODE_ID）：ノード= topo.node_dict [NODE_ID] node.GR_sel_priority = 255"
    },
    {
      "indent": 0,
      "text": "def Lower_GADAG_Root_Selection_Priority(topo,node_id): node = topo.node_dict[node_id] node.GR_sel_priority = 128",
      "ja": "DEF Lower_GADAG_Root_Selection_Priority（TOPO、NODE_ID）：ノード= topo.node_dict [NODE_ID] node.GR_sel_priority = 128"
    },
    {
      "indent": 0,
      "text": "def GADAG_Root_Compare(node_a, node_b): if (node_a.GR_sel_priority > node_b.GR_sel_priority): return 1 elif (node_a.GR_sel_priority < node_b.GR_sel_priority): return -1 else: if node_a.node_id > node_b.node_id: return 1 elif node_a.node_id < node_b.node_id: return -1",
      "ja": "デフGADAG_Root_Compare（ノードA、ノードB）：（node_a.GR_sel_priority> node_b.GR_sel_priority）の場合：リターン1つのelif（node_a.GR_sel_priority <node_b.GR_sel_priority）：-1を返し、他：リターン1 ELIFのノードA：node_a.node_id> node_b.node_id場合.node_id <node_b.node_id：-1を返します"
    },
    {
      "indent": 0,
      "text": "def Set_GADAG_Root(topo,computing_router): gadag_root_list = [] for node in topo.island_node_list: gadag_root_list.append(node) gadag_root_list.sort(GADAG_Root_Compare) topo.gadag_root = gadag_root_list.pop()",
      "ja": "DEF Set_GADAG_Root（TOPO、computing_router）：gadag_root_list = [] topo.island_node_listにおけるノードのための：gadag_root_list.append（ノード）gadag_root_list.sort（GADAG_Root_Compare）topo.gadag_root = gadag_root_list.pop（）"
    },
    {
      "indent": 0,
      "text": "def Add_Prefix_Advertisements_From_File(topo, filename): prefix_filename = filename + '.prefix' cols_list = [] if not os.path.exists(prefix_filename): return with open(prefix_filename) as prefix_file: for line in prefix_file: line = line.rstrip('\\r\\n') cols=line.split(',') cols_list.append(cols) prefix_id = int(cols[0]) if prefix_id < 2000 or prefix_id >2999:",
      "ja": "DEF Add_Prefix_Advertisements_From_File（TOPO、ファイル名）：prefix_filename =ファイル名+ '.prefix' cols_list = []でない場合os.path.exists（prefix_filename）：prefix_fileとしてオープン（prefix_filename）とリターン：ラインのprefix_fileで：ライン= line.rstrip （ '\\ R \\ n'）COLS = line.split（ ''）cols_list.append（COLS）prefix_id = INT（COLS [0]）<2000またはprefix_id> 2999 prefix_id場合："
    },
    {
      "indent": 12,
      "text": "    print('skipping the following line of prefix file')\n    print('prefix id should be between 2000 and 2999')\n    print(line)\n    continue\nprefix_node_id = int(cols[1])\nprefix_cost = int(cols[2])\nadvertising_node = topo.node_dict[prefix_node_id]\nadvertising_node.prefix_cost_dict[prefix_id] = prefix_cost",
      "raw": true
    },
    {
      "indent": 0,
      "text": "def Add_Prefixes_for_Non_Island_Nodes(topo): for node in topo.node_list: if node.IN_MRT_ISLAND: continue prefix_id = node.node_id + 1000 node.prefix_cost_dict[prefix_id] = 0",
      "ja": "DEF Add_Prefixes_for_Non_Island_Nodes（TOPO）：topo.node_listにおけるノードの：node.IN_MRT_ISLANDの場合：prefix_id = node.node_id + 1000年node.prefix_cost_dict [prefix_id] = 0を続行"
    },
    {
      "indent": 0,
      "text": "def Add_Profile_IDs_from_File(topo, filename): profile_filename = filename + '.profile' for node in topo.node_list: node.profile_id_list = [] cols_list = [] if os.path.exists(profile_filename): with open(profile_filename) as profile_file: for line in profile_file: line = line.rstrip('\\r\\n') cols=line.split(',') cols_list.append(cols) node_id = int(cols[0]) profile_id = int(cols[1]) this_node = topo.node_dict[node_id] this_node.profile_id_list.append(profile_id) else: for node in topo.node_list: node.profile_id_list = [0]",
      "ja": "DEF Add_Profile_IDs_from_File（TOPO、ファイル名）：topo.node_listにおけるノードのprofile_filename =ファイル名+ 'の.profile'：node.profile_id_list = [] cols_list = []もしos.path.exists（profile_filename）：オープン（profile_filename）とprofile_fileとして：ラインのprofile_fileで：行= line.rstrip（ '\\ R \\ n'）COLS = line.split（ ''）cols_list.append（COLS）NODE_ID = INT（COLS [0]）PROFILE_ID = INT（COLS [ 1]）this_node = topo.node_dict他[NODE_ID] this_node.profile_id_list.append（PROFILE_ID）：ノードのtopo.node_listで：node.profile_id_list = [0]"
    },
    {
      "indent": 0,
      "text": "def Island_Marking_SPF(topo,spf_root): spf_root.isl_marking_spf_dict = {} for y in topo.node_list: y.spf_metric = 2147483647 # 2^31-1 as max metric y.PATH_HITS_ISLAND = False y.next_hops = [] y.spf_visited = False spf_root.spf_metric = 0 spf_heap = [] heapq.heappush(spf_heap, (spf_root.spf_metric,spf_root.node_id,spf_root) ) while spf_heap != []: #extract third element of tuple popped from heap min_node = heapq.heappop(spf_heap)[2] if min_node.spf_visited: continue min_node.spf_visited = True spf_root.isl_marking_spf_dict[min_node.node_id] = \\ (min_node.spf_metric, min_node.PATH_HITS_ISLAND) for intf in min_node.intf_list: path_metric = min_node.spf_metric + intf.metric if path_metric < intf.remote_node.spf_metric: intf.remote_node.spf_metric = path_metric if min_node is spf_root: intf.remote_node.next_hops = [intf] else: Copy_List_Items(intf.remote_node.next_hops, min_node.next_hops) if (intf.remote_node.IN_MRT_ISLAND): intf.remote_node.PATH_HITS_ISLAND = True else: intf.remote_node.PATH_HITS_ISLAND = \\ min_node.PATH_HITS_ISLAND heapq.heappush(spf_heap, ( intf.remote_node.spf_metric, intf.remote_node.node_id, intf.remote_node ) ) elif path_metric == intf.remote_node.spf_metric: if min_node is spf_root: Add_Item_To_List_If_New( intf.remote_node.next_hops,intf) else: for nh_intf in min_node.next_hops: Add_Item_To_List_If_New( intf.remote_node.next_hops,nh_intf) if (intf.remote_node.IN_MRT_ISLAND): intf.remote_node.PATH_HITS_ISLAND = True else: if (intf.remote_node.PATH_HITS_ISLAND or min_node.PATH_HITS_ISLAND): intf.remote_node.PATH_HITS_ISLAND = True",
      "ja": "DEF Island_Marking_SPF（TOPO、spf_root）：topo.node_listにおけるyのspf_root.isl_marking_spf_dict = {}：y.spf_metric = 2147483647＃2 ^ 31-1として最大メトリックy.PATH_HITS_ISLAND = Falseのy.next_hopsは= [] = y.spf_visited偽spf_root.spf_metric = 0 spf_heap = [] heapq.heappush（spf_heap、（spf_root.spf_metric、spf_root.node_id、spf_root））、一方spf_heap = []：ヒープmin_node = heapq.heappopからポップタプルの#extract第三の要素（ spf_heap）min_node.spf_visited場合[2]：= min_node.spf_visited続ける真spf_root.isl_marking_spf_dict [min_node.node_id] min_node.intf_listでINTFため= \\（min_node.spf_metric、min_node.PATH_HITS_ISLAND）：path_metric = min_node.spf_metric + INTF。 intf.remote_node.spf_metric = path_metric min_nodeがspf_rootある場合：intf.remote_node.next_hops = [INTF]他：Copy_List_Items（intf.remote_node.next_hops、min_node.next_hops）（intf.remote_node場合path_metric <intf.remote_node.spf_metricもしメトリック.IN_MRT_ISLAND）：intf.remote_node.PATH_HITS_ISLAND =他の真：intf.remote_node.P ATH_HITS_ISLAND = \\ min_node.PATH_HITS_ISLAND heapq.heappush（spf_heap、（intf.remote_node.spf_metric、intf.remote_node.node_id、intf.remote_node））のelifのpath_metric == intf.remote_node.spf_metric：min_nodeがある場合spf_root：Add_Item_To_List_If_New（intf.remote_node他.next_hops、INTF）：min_node.next_hopsでnh_intf用：Add_Item_To_List_If_New（intf.remote_node.next_hops、nh_intf）であれば（intf.remote_node.IN_MRT_ISLAND）：intf.remote_node.PATH_HITS_ISLAND =他の真：もし（intf.remote_node.PATH_HITS_ISLANDかmin_node.PATH_HITS_ISLAND）：intf.remote_node.PATH_HITS_ISLAND =真"
    },
    {
      "indent": 0,
      "text": "def Create_Basic_Named_Proxy_Nodes(topo): for node in topo.node_list: for prefix in node.prefix_cost_dict: prefix_cost = node.prefix_cost_dict[prefix] if prefix in topo.named_proxy_dict: P = topo.named_proxy_dict[prefix] P.node_prefix_cost_list.append((node,prefix_cost)) else: P = Named_Proxy_Node() topo.named_proxy_dict[prefix] = P P.node_id = prefix P.node_prefix_cost_list = [(node,prefix_cost)]",
      "ja": "node.prefix_cost_dictでプレフィックスの：DEF Create_Basic_Named_Proxy_Nodes（TOPO）：topo.node_listにおけるノードのprefix_cost = node.prefix_cost_dict [プレフィックス]場合topo.named_proxy_dictにおける接頭：P = topo.named_proxy_dict [プレフィックス] P.node_prefix_cost_list.append（（ノード、他prefix_cost））：P = Named_Proxy_Node（）topo.named_proxy_dict [プレフィックス] = P P.node_id =プレフィックスP.node_prefix_cost_list = [（ノード、prefix_cost）]"
    },
    {
      "indent": 0,
      "text": "def Compute_Loop_Free_Island_Neighbors_For_Each_Prefix(topo): topo.island_nbr_set = set() topo.island_border_set = set() for node in topo.node_list: if node.IN_MRT_ISLAND: continue for intf in node.intf_list: if intf.remote_node.IN_MRT_ISLAND: topo.island_nbr_set.add(node) topo.island_border_set.add(intf.remote_node)",
      "ja": "DEF Compute_Loop_Free_Island_Neighbors_For_Each_Prefix（TOPO）：topo.island_nbr_set =セット（）topo.island_border_set =セット（）topo.node_listにおけるノードの：node.IN_MRT_ISLANDの場合：node.intf_listにINTF継続：intf.remote_node.IN_MRT_ISLAND場合：topo.island_nbr_set .add（ノード）topo.island_border_set.add（intf.remote_node）"
    },
    {
      "indent": 4,
      "text": "for island_nbr in topo.island_nbr_set:\n    Island_Marking_SPF(topo,island_nbr)",
      "raw": true
    },
    {
      "indent": 4,
      "text": "for prefix in topo.named_proxy_dict: P = topo.named_proxy_dict[prefix] P.lfin_list = [] for island_nbr in topo.island_nbr_set: min_isl_nbr_to_pref_cost = 2147483647 for (adv_node, prefix_cost) in P.node_prefix_cost_list: (adv_node_cost, path_hits_island) = \\ island_nbr.isl_marking_spf_dict[adv_node.node_id] isl_nbr_to_pref_cost = adv_node_cost + prefix_cost if isl_nbr_to_pref_cost < min_isl_nbr_to_pref_cost: min_isl_nbr_to_pref_cost = isl_nbr_to_pref_cost min_path_hits_island = path_hits_island elif isl_nbr_to_pref_cost == min_isl_nbr_to_pref_cost: if min_path_hits_island or path_hits_island: min_path_hits_island = True if not min_path_hits_island: P.lfin_list.append( (island_nbr, min_isl_nbr_to_pref_cost) )",
      "ja": "P = topo.named_proxy_dict [プレフィックス] P.lfin_list = [] topo.island_nbr_setでisland_nbr用：topo.named_proxy_dictにおけるプレフィックスのP.node_prefix_cost_listに（adv_node、prefix_cost）用min_isl_nbr_to_pref_cost = 2147483647（adv_node_cost、path_hits_island）= \\ island_nbr .isl_marking_spf_dict [adv_node.node_id] isl_nbr_to_pref_cost = adv_node_cost + prefix_cost場合isl_nbr_to_pref_cost <min_isl_nbr_to_pref_cost：min_isl_nbr_to_pref_cost = isl_nbr_to_pref_cost min_path_hits_island = path_hits_islandのelif isl_nbr_to_pref_cost == min_isl_nbr_to_pref_cost：min_path_hits_islandない場合min_path_hits_island =真：min_path_hits_island又はpath_hits_island場合P.lfin_list.append（（island_nbr、 min_isl_nbr_to_pref_cost））"
    },
    {
      "indent": 0,
      "text": "def Compute_Island_Border_Router_LFIN_Pairs_For_Each_Prefix(topo): for ibr in topo.island_border_set: ibr.prefix_lfin_dict = {} ibr.min_intf_metric_dict = {} ibr.min_intf_list_dict = {} ibr.min_intf_list_dict[None] = None for intf in ibr.intf_list: if not intf.remote_node in topo.island_nbr_set: continue if not intf.remote_node in ibr.min_intf_metric_dict:",
      "ja": "DEF Compute_Island_Border_Router_LFIN_Pairs_For_Each_Prefix（TOPO）：ibr.prefix_lfin_dict = {} ibr.min_intf_metric_dict = {} ibr.min_intf_list_dict = {} ibr.min_intf_list_dict [なし] = ibr.intf_listでINTFためなし：INTFない場合topo.island_border_setにおけるIBRため。 topo.island_nbr_setでremote_node：ibr.min_intf_metric_dictにintf.remote_nodeない場合は続行します。"
    },
    {
      "indent": 12,
      "text": "    ibr.min_intf_metric_dict[intf.remote_node] = \\\n        intf.metric\n    ibr.min_intf_list_dict[intf.remote_node] = [intf]\nelse:\n    if (intf.metric\n        < ibr.min_intf_metric_dict[intf.remote_node]):\n        ibr.min_intf_metric_dict[intf.remote_node] = \\\n             intf.metric\n        ibr.min_intf_list_dict[intf.remote_node] = [intf]\n    elif (intf.metric\n          < ibr.min_intf_metric_dict[intf.remote_node]):\n        ibr.min_intf_list_dict[intf.remote_node].\\\n            append(intf)",
      "raw": true
    },
    {
      "indent": 4,
      "text": "for prefix in topo.named_proxy_dict: P = topo.named_proxy_dict[prefix] for ibr in topo.island_border_set: min_ibr_lfin_pref_cost = 2147483647 min_lfin = None for (lfin, lfin_to_pref_cost) in P.lfin_list: if not lfin in ibr.min_intf_metric_dict: continue ibr_lfin_pref_cost = \\ ibr.min_intf_metric_dict[lfin] + lfin_to_pref_cost if ibr_lfin_pref_cost < min_ibr_lfin_pref_cost: min_ibr_lfin_pref_cost = ibr_lfin_pref_cost min_lfin = lfin ibr.prefix_lfin_dict[prefix] = (min_lfin, min_ibr_lfin_pref_cost, ibr.min_intf_list_dict[min_lfin])",
      "ja": "接頭辞topo.named_proxy_dictで：topo.island_border_setにおけるIBR用P = topo.named_proxy_dict [接頭辞]：P.lfin_listで（lfin、lfin_to_pref_cost）用min_ibr_lfin_pref_cost = 2147483647 min_lfin =なし：ibr.min_intf_metric_dictにlfinない場合は：ibr_lfin_pref_cost =を続行しますmin_ibr_lfin_pref_cost = ibr_lfin_pref_cost min_lfin = lfin ibr.prefix_lfin_dict [プレフィックス] =（min_lfin、min_ibr_lfin_pref_cost、ibr.min_intf_list_dict [min_lfin]）：ibr_lfin_pref_cost <min_ibr_lfin_pref_cost場合\\ ibr.min_intf_metric_dict [lfin] + lfin_to_pref_cost"
    },
    {
      "indent": 0,
      "text": "def Proxy_Node_Att_Router_Compare(pnar_a, pnar_b): if pnar_a.named_proxy_cost < pnar_b.named_proxy_cost: return -1 if pnar_b.named_proxy_cost < pnar_a.named_proxy_cost: return 1 if pnar_a.node.node_id < pnar_b.node.node_id: return -1 if pnar_b.node.node_id < pnar_a.node.node_id: return 1 if pnar_a.min_lfin == None: return -1 if pnar_b.min_lfin == None: return 1",
      "ja": "DEF Proxy_Node_Att_Router_Compare（pnar_a、pnar_b）：pnar_a.named_proxy_cost <pnar_b.named_proxy_cost場合：戻り-1 pnar_b.named_proxy_cost <pnar_a.named_proxy_cost場合：1を返す場合pnar_a.node.node_id <pnar_b.node.node_id：戻り-1 pnar_b場合。 node.node_id <pnar_a.node.node_id：リターン1 pnar_a.min_lfin ==なし場合：返さない-1場合pnar_b.min_lfin ==なし：リターン1"
    },
    {
      "indent": 0,
      "text": "def Choose_Proxy_Node_Attachment_Routers(topo): for prefix in topo.named_proxy_dict: P = topo.named_proxy_dict[prefix] pnar_candidate_list = [] for (node, prefix_cost) in P.node_prefix_cost_list: if not node.IN_MRT_ISLAND: continue pnar = Proxy_Node_Attachment_Router() pnar.prefix = prefix pnar.named_proxy_cost = prefix_cost pnar.node = node pnar_candidate_list.append(pnar) for ibr in topo.island_border_set: (min_lfin, prefix_cost, min_intf_list) = \\ ibr.prefix_lfin_dict[prefix] if min_lfin == None: continue pnar = Proxy_Node_Attachment_Router() pnar.named_proxy_cost = prefix_cost pnar.node = ibr pnar.min_lfin = min_lfin pnar.nh_intf_list = min_intf_list pnar_candidate_list.append(pnar) pnar_candidate_list.sort(cmp=Proxy_Node_Att_Router_Compare) #pop first element from list first_pnar = pnar_candidate_list.pop(0) second_pnar = None for next_pnar in pnar_candidate_list: if next_pnar.node is first_pnar.node: continue second_pnar = next_pnar break",
      "ja": "DEF Choose_Proxy_Node_Attachment_Routers（TOPO）：プレフィックスのtopo.named_proxy_dictで：P = topo.named_proxy_dict [プレフィックス] pnar_candidate_list = []のためP.node_prefix_cost_listにおける（ノード、prefix_cost）：いない場合node.IN_MRT_ISLAND：続けるpnar = Proxy_Node_Attachment_Router（）pnar。 topo.island_border_setにおけるIBRのプレフィックス=接頭pnar.named_proxy_cost = prefix_cost pnar.node =ノードpnar_candidate_list.append（pnar）：（min_lfin、prefix_cost、min_intf_list）= \\ ibr.prefix_lfin_dict [プレフィックス]場合min_lfin ==なし：続けるpnar = Proxy_Node_Attachment_Router（）pnar.named_proxy_cost = prefix_cost pnar.node = IBR pnar.min_lfin = min_lfin pnar.nh_intf_list = min_intf_list pnar_candidate_list.append（pnar）pnar_candidate_list.sort（CMP = Proxy_Node_Att_Router_Compare）リストfirst_pnar = pnar_candidate_list.popから最初の要素を#pop（0 next_pnar.nodeがある場合first_pnar.node：：）second_pnar = pnar_candidate_listでnext_pnar用なしsecond_pnar = next_pnar休憩を続けません"
    },
    {
      "indent": 8,
      "text": "P.pnar1 = first_pnar\nP.pnar2 = second_pnar",
      "raw": true
    },
    {
      "indent": 0,
      "text": "def Attach_Named_Proxy_Nodes(topo): Compute_Loop_Free_Island_Neighbors_For_Each_Prefix(topo) Compute_Island_Border_Router_LFIN_Pairs_For_Each_Prefix(topo) Choose_Proxy_Node_Attachment_Routers(topo)",
      "ja": "デフAttach_Named_Proxy_Nodes（トポ）：Compute_Loop_Free_Island_Neighbors_For_Each_Prefix（トポ）Compute_Island_Border_Router_LFIN_Pairs_For_Each_Prefix（トポ）Choose_Proxy_Node_Attachment_Routers（トポ）"
    },
    {
      "indent": 0,
      "text": "def Select_Proxy_Node_NHs(P,S): if P.pnar1.node.node_id < P.pnar2.node.node_id: X = P.pnar1.node Y = P.pnar2.node else: X = P.pnar2.node Y = P.pnar1.node P.pnar_X = X P.pnar_Y = Y A = X.order_proxy",
      "ja": "DEF Select_Proxy_Node_NHs（P、S）：他X = Y = P.pnar1.node P.pnar2.node：X = Y = P.pnar2.node P.pnar1.node.node_id <P.pnar2.node.node_id場合P.pnar1.nodeのP.pnar_X = X P.pnar_Y = YA = X.order_proxy"
    },
    {
      "indent": 4,
      "text": "B = Y.order_proxy\nif (A is S.localroot\n    and B is S.localroot):\n    #print(\"1.0\")\n    Copy_List_Items(P.blue_next_hops, X.blue_next_hops)\n    Copy_List_Items(P.red_next_hops, Y.red_next_hops)\n    return\nif (A is S.localroot\n    and B is not S.localroot):\n    #print(\"2.0\")\n    if B.LOWER:\n        #print(\"2.1\")\n        Copy_List_Items(P.blue_next_hops, X.blue_next_hops)\n        Copy_List_Items(P.red_next_hops, Y.red_next_hops)\n        return\n    if B.HIGHER:\n        #print(\"2.2\")\n        Copy_List_Items(P.blue_next_hops, X.red_next_hops)\n        Copy_List_Items(P.red_next_hops, Y.blue_next_hops)\n        return\n    else:\n        #print(\"2.3\")\n        Copy_List_Items(P.blue_next_hops, X.red_next_hops)\n        Copy_List_Items(P.red_next_hops, Y.red_next_hops)\n        return\nif (A is not S.localroot\n    and B is S.localroot):\n    #print(\"3.0\")\n    if A.LOWER:\n        #print(\"3.1\")\n        Copy_List_Items(P.blue_next_hops, X.red_next_hops)\n        Copy_List_Items(P.red_next_hops, Y.blue_next_hops)\n        return\n    if A.HIGHER:\n        #print(\"3.2\")\n        Copy_List_Items(P.blue_next_hops, X.blue_next_hops)\n        Copy_List_Items(P.red_next_hops, Y.red_next_hops)\n        return\n    else:\n        #print(\"3.3\")\n        Copy_List_Items(P.blue_next_hops, X.red_next_hops)\n        Copy_List_Items(P.red_next_hops, Y.red_next_hops)\n        return\nif (A is not S.localroot\n    and B is not S.localroot):\n    #print(\"4.0\")\n    if (S is A.localroot or S is B.localroot):\n        #print(\"4.05\") if A.topo_order < B.topo_order:\n            #print(\"4.05.1\")\n            Copy_List_Items(P.blue_next_hops, X.blue_next_hops)\n            Copy_List_Items(P.red_next_hops, Y.red_next_hops)\n            return\n        else:\n            #print(\"4.05.2\")\n            Copy_List_Items(P.blue_next_hops, X.red_next_hops)\n            Copy_List_Items(P.red_next_hops, Y.blue_next_hops)\n            return\n    if A.LOWER:\n        #print(\"4.1\")\n        if B.HIGHER:\n            #print(\"4.1.1\")\n            Copy_List_Items(P.blue_next_hops, X.red_next_hops)\n            Copy_List_Items(P.red_next_hops, Y.blue_next_hops)\n            return\n        if B.LOWER:\n            #print(\"4.1.2\")\n            if A.topo_order < B.topo_order:\n                #print(\"4.1.2.1\")\n                Copy_List_Items(P.blue_next_hops, X.blue_next_hops)\n                Copy_List_Items(P.red_next_hops, Y.red_next_hops)\n                return\n            else:\n                #print(\"4.1.2.2\")\n                Copy_List_Items(P.blue_next_hops, X.red_next_hops)\n                Copy_List_Items(P.red_next_hops, Y.blue_next_hops)\n                return\n        else:\n            #print(\"4.1.3\")\n            Copy_List_Items(P.blue_next_hops, X.red_next_hops)\n            Copy_List_Items(P.red_next_hops, Y.red_next_hops)\n            return\n    if A.HIGHER:\n        #print(\"4.2\")\n        if B.HIGHER:\n            #print(\"4.2.1\")\n            if A.topo_order < B.topo_order:\n                #print(\"4.2.1.1\")\n                Copy_List_Items(P.blue_next_hops, X.blue_next_hops)\n                Copy_List_Items(P.red_next_hops, Y.red_next_hops)\n                return\n            else:\n                #print(\"4.2.1.2\")\n                Copy_List_Items(P.blue_next_hops, X.red_next_hops)\n                Copy_List_Items(P.red_next_hops, Y.blue_next_hops)\n                return",
      "raw": true
    },
    {
      "indent": 4,
      "text": " if B.LOWER: #print(\"4.2.2\") Copy_List_Items(P.blue_next_hops, X.blue_next_hops) Copy_List_Items(P.red_next_hops, Y.red_next_hops) return else: #print(\"4.2.3\") Copy_List_Items(P.blue_next_hops, X.blue_next_hops) Copy_List_Items(P.red_next_hops, Y.blue_next_hops) return else: #print(\"4.3\") if B.LOWER: #print(\"4.3.1\") Copy_List_Items(P.blue_next_hops, X.red_next_hops) Copy_List_Items(P.red_next_hops, Y.red_next_hops) return if B.HIGHER: #print(\"4.3.2\") Copy_List_Items(P.blue_next_hops, X.blue_next_hops) Copy_List_Items(P.red_next_hops, Y.blue_next_hops) return else: #print(\"4.3.3\") if A.topo_order < B.topo_order: #print(\"4.3.3.1\") Copy_List_Items(P.blue_next_hops, X.blue_next_hops) Copy_List_Items(P.red_next_hops, Y.red_next_hops) return else: #print(\"4.3.3.2\") Copy_List_Items(P.blue_next_hops, X.red_next_hops) Copy_List_Items(P.red_next_hops, Y.blue_next_hops) return assert(False)",
      "ja": "B.LOWER場合：#print（ \"4.2.2\"）Copy_List_Items（P.blue_next_hops、X.blue_next_hops）Copy_List_Items（P.red_next_hops、Y.red_next_hopsは）他を返す：#print（ \"4.2.3\"）Copy_List_Items（P。 blue_next_hops、X.blue_next_hops）Copy_List_Items（P.red_next_hops、Y.blue_next_hops）他に戻します（ \"4.3\" を#print）B.LOWER場合：#print（ \"4.3.1\"）Copy_List_Items（P.blue_next_hops、X.red_next_hops） B.HIGHER場合Copy_List_Items（P.red_next_hops、Y.red_next_hops）リターン：#print（ \"4.3.2\"）Copy_List_Items（P.blue_next_hops、X.blue_next_hops）Copy_List_Items（P.red_next_hops、Y.blue_next_hops）それ以外を返す：#printを（ \"4.3.3\"）A.topo_order <B.topo_order場合：#print（ \"4.3.3.1\"）Copy_List_Items（P.blue_next_hops、X.blue_next_hops）Copy_List_Items（P.red_next_hops、Y.red_next_hopsは）他を返す：#print （ \"4.3.3.2\"）Copy_List_Items（P.blue_next_hops、X.red_next_hops）Copy_List_Items（P.red_next_hops、Y.blue_next_hops）リターンのassert（偽）"
    },
    {
      "indent": 0,
      "text": "def Compute_MRT_NHs_For_One_Src_To_Named_Proxy_Nodes(topo,S): for prefix in topo.named_proxy_dict: P = topo.named_proxy_dict[prefix] if P.pnar2 == None: if S is P.pnar1.node: # set the MRT next hops for the PNAR to # reach the LFIN and change FEC to green Copy_List_Items(P.blue_next_hops, P.pnar1.nh_intf_list) S.blue_to_green_nh_dict[P.node_id] = True Copy_List_Items(P.red_next_hops, P.pnar1.nh_intf_list)",
      "ja": "topo.named_proxy_dictでプレフィックスの：DEF Compute_MRT_NHs_For_One_Src_To_Named_Proxy_Nodes（TOPO、S）P = topo.named_proxy_dict [プレフィックス]場合P.pnar2 ==なし：SはP.pnar1.nodeである場合：＃は、MRTは次のPNARためホップセット＃LFINに到達し、緑色Copy_List_ItemsにFECを変更（P.blue_next_hops、P.pnar1.nh_intf_list）S.blue_to_green_nh_dict [P.node_id] =真Copy_List_Items（P.red_next_hops、P.pnar1.nh_intf_list）"
    },
    {
      "indent": 8,
      "text": "        S.red_to_green_nh_dict[P.node_id] = True\n    else:\n        # inherit MRT NHs for P from pnar1\n        Copy_List_Items(P.blue_next_hops,\n                        P.pnar1.node.blue_next_hops)\n        Copy_List_Items(P.red_next_hops,\n                        P.pnar1.node.red_next_hops)\nelse:\n    Select_Proxy_Node_NHs(P,S)\n    # set the MRT next hops for the PNAR to reach the LFIN\n    # and change FEC to green rely on the red or blue\n    # next hops being empty to figure out which one needs\n    # to point to the LFIN.\n    if S is P.pnar1.node:\n        this_pnar = P.pnar1\n    elif S is P.pnar2.node:\n        this_pnar = P.pnar2\n    else:\n        continue\n    if P.blue_next_hops == []:\n        Copy_List_Items(P.blue_next_hops,\n            this_pnar.nh_intf_list)\n        S.blue_to_green_nh_dict[P.node_id] = True\n    if P.red_next_hops == []:\n        Copy_List_Items(P.red_next_hops,\n            this_pnar.nh_intf_list)\n        S.red_to_green_nh_dict[P.node_id] = True",
      "raw": true
    },
    {
      "indent": 0,
      "text": "def Select_Alternates_Proxy_Node(P,F,primary_intf): S = primary_intf.local_node X = P.pnar_X Y = P.pnar_Y A = X.order_proxy B = Y.order_proxy if F is A and F is B: return 'PRIM_NH_IS_OP_FOR_BOTH_X_AND_Y' if F is A: return 'USE_RED' if F is B: return 'USE_BLUE'",
      "ja": "DEF Select_Alternates_Proxy_Node（P、F、primary_intf）：S = primary_intf.local_node X = Y = P.pnar_X P.pnar_Y A = B = X.order_proxy Y.order_proxy Fである場合、A及びFはBである：復帰 'PRIM_NH_IS_OP_FOR_BOTH_X_AND_Y' Fもしリターン「USE_RED」FがBがある場合：リターン「USE_BLUE」です"
    },
    {
      "indent": 4,
      "text": "if not In_Common_Block(A, B):\n    if In_Common_Block(F, A):\n        return 'USE_RED'\n    elif In_Common_Block(F, B):\n        return 'USE_BLUE'\n    else:\n        return 'USE_RED_OR_BLUE'",
      "raw": true
    },
    {
      "indent": 4,
      "text": "if (not In_Common_Block(F, A) and not In_Common_Block(F, A) ): return 'USE_RED_OR_BLUE'",
      "ja": "リターン 'USE_RED_OR_BLUE'：（ないIn_Common_Block（F、A）及びませんIn_Common_Block（F、A））の場合"
    },
    {
      "indent": 4,
      "text": "alt_to_X = Select_Alternates(X, F, primary_intf) alt_to_Y = Select_Alternates(Y, F, primary_intf)",
      "ja": "alt_to_X = Select_Alternates（X、F、primary_intf）alt_to_Y = Select_Alternates（Y、F、primary_intf）"
    },
    {
      "indent": 4,
      "text": "if (alt_to_X == 'USE_RED_OR_BLUE' and alt_to_Y == 'USE_RED_OR_BLUE'): return 'USE_RED_OR_BLUE' if alt_to_X == 'USE_RED_OR_BLUE': return 'USE_BLUE' if alt_to_Y == 'USE_RED_OR_BLUE': return 'USE_RED'",
      "ja": "もし（alt_to_X == 'USE_RED_OR_BLUE' とalt_to_Y == 'USE_RED_OR_BLUE'）：リターン 'USE_RED_OR_BLUE' もしalt_to_X == 'USE_RED_OR_BLUE'：リターン 'USE_BLUE' もしalt_to_Y == 'USE_RED_OR_BLUE'：リターン 'USE_RED'"
    },
    {
      "indent": 4,
      "text": "if (A is S.localroot and B is S.localroot): #print(\"1.0\") if (alt_to_X == 'USE_BLUE' and alt_to_Y == 'USE_RED'): return 'USE_RED_OR_BLUE' if alt_to_X == 'USE_BLUE': return 'USE_BLUE' if alt_to_Y == 'USE_RED': return 'USE_RED' assert(False) if (A is S.localroot and B is not S.localroot): #print(\"2.0\") if B.LOWER: #print(\"2.1\") if (alt_to_X == 'USE_BLUE' and alt_to_Y == 'USE_RED'): return 'USE_RED_OR_BLUE' if alt_to_X == 'USE_BLUE': return 'USE_BLUE' if alt_to_Y == 'USE_RED': return 'USE_RED' assert(False) if B.HIGHER: #print(\"2.2\") if (alt_to_X == 'USE_RED' and alt_to_Y == 'USE_BLUE'): return 'USE_RED_OR_BLUE' if alt_to_X == 'USE_RED': return 'USE_BLUE' if alt_to_Y == 'USE_BLUE': return 'USE_RED' assert(False) else: #print(\"2.3\") if (alt_to_X == 'USE_RED' and alt_to_Y == 'USE_RED'): return 'USE_RED_OR_BLUE' if alt_to_X == 'USE_RED': return 'USE_BLUE' if alt_to_Y == 'USE_RED': return 'USE_RED' assert(False) if (A is not S.localroot and B is S.localroot): #print(\"3.0\") if A.LOWER: #print(\"3.1\") if (alt_to_X == 'USE_RED' and alt_to_Y == 'USE_BLUE'): return 'USE_RED_OR_BLUE' if alt_to_X == 'USE_RED': return 'USE_BLUE' if alt_to_Y == 'USE_BLUE': return 'USE_RED' assert(False) if A.HIGHER: #print(\"3.2\") if (alt_to_X == 'USE_BLUE' and alt_to_Y == 'USE_RED'): return 'USE_RED_OR_BLUE' if alt_to_X == 'USE_BLUE': return 'USE_BLUE' if alt_to_Y == 'USE_RED': return 'USE_RED' assert(False) else: #print(\"3.3\") if (alt_to_X == 'USE_RED' and alt_to_Y == 'USE_RED'): return 'USE_RED_OR_BLUE' if alt_to_X == 'USE_RED': return 'USE_BLUE' if alt_to_Y == 'USE_RED': return 'USE_RED' assert(False) if (A is not S.localroot and B is not S.localroot): #print(\"4.0\") if (S is A.localroot or S is B.localroot): #print(\"4.05\") if A.topo_order < B.topo_order: #print(\"4.05.1\") if (alt_to_X == 'USE_BLUE' and alt_to_Y == 'USE_RED'): return 'USE_RED_OR_BLUE' if alt_to_X == 'USE_BLUE': return 'USE_BLUE'",
      "ja": "（AはS.localrootであり、BはS.localrootある）場合：#print（ \"1.0\"）（alt_to_X == 'USE_BLUE' とalt_to_Y == 'USE_RED'）場合：戻り 'USE_RED_OR_BLUE' もしalt_to_X == 'USE_BLUE' ：リターン 'USE_BLUE' もしalt_to_Y == 'USE_RED'：（AはS.localrootであり、BはS.localrootない）場合はリターン 'USE_RED' アサート（偽）：#print（ \"2.0\"）B.LOWER場合：＃印刷（ \"2.1\"）（alt_to_X == 'USE_BLUE' とalt_to_Y == 'USE_RED'）の場合：戻り 'USE_RED_OR_BLUE' もしalt_to_X == 'USE_BLUE'：リターン 'USE_BLUE' もしalt_to_Y == 'USE_RED'：リターン「USE_RED 「アサート（偽）B.HIGHER場合：#print（ \"2.2\"）であれば（alt_to_X == 'USE_RED' とalt_to_Y == 'USE_BLUE'）：リターン 'USE_RED_OR_BLUE USE_RED' alt_to_X ==もし ''：リターン 'USE_BLUE' alt_to_Y == 'USE_BLUE' の場合：リターン 'USE_RED' 他のassert（偽）：#print（ \"2.3\"）であれば（alt_to_X == 'USE_RED' とalt_to_Y == 'USE_RED'）：リターン 'USE_RED_OR_BLUE' もしalt_to_X == 'USE_RED'：alt_to_Y == 'USE_RED' もしリターン 'USE_BLUE'：リターン 'USE_RED' アサート（偽）場合（AがS.localroot及びBはS.localrootではない）：#print（ \"3.0\"）A.場合LOWER：#print（ \"3.1\"）であれば（alt_to_X == 'USE_RED' とalt_to_Y == 'USE_BLUE'）：リターン 'USE_RED_OR_BLUE' もしalt_to_X == 'USE_RED'：リターン 'USE_BLUE' もしalt_to_Y == 'USE_BLUE'：リターン 'USE_RED' アサートA.HIGHER場合（偽）：#print（ \"3.2\"）であれば（alt_to_X == 'USE_BLUE' とalt_to_Y == 'USE_RED'）：リターン 'USE_RED_OR_BLUE' もしalt_to_X == 'USE_BLUE'：リターン 'USE_BLUE' をalt_to_Y場合== 'USE_RED'：リターン 'USE_RED' 他のassert（偽）：#print（ \"3.3\"）であれば（alt_to_X == 'USE_RED' とalt_to_Y == 'USE_RED'）：リターン 'USE_RED_OR_BLUE' もしalt_to_X ==「USE_RED 「：リターン 'USE_BLUEはUSE_RED' alt_to_Y ==場合 ''：リターン 'USE_RED' アサート（偽）（AはS.localrootではなく、BがS.localrootない）場合：#print（ \"4.0\"）があれば（Sです#print（ \"4.05\"）であればA.topo_order <B.topo_order：A.localrootまたはSでB.localroot）である#print（ \"4.05.1\"）（alt_to_X == 'USE_BLUE' とalt_to_Y ==「もしUSE_RED 「）：リターン 'USE_RED_OR_BLUE USE_BLUE' alt_to_X ==もし ''：リターン 'USE_BLUE'"
    },
    {
      "indent": 8,
      "text": "        if alt_to_Y == 'USE_RED':\n            return 'USE_RED'\n        assert(False)\n    else:\n        #print(\"4.05.2\")\n        if (alt_to_X == 'USE_RED' and alt_to_Y == 'USE_BLUE'):\n            return 'USE_RED_OR_BLUE'\n        if alt_to_X == 'USE_RED':\n            return 'USE_BLUE'\n        if alt_to_Y == 'USE_BLUE':\n            return 'USE_RED'\n        assert(False)\nif A.LOWER:\n    #print(\"4.1\")\n    if B.HIGHER:\n        #print(\"4.1.1\")\n        if (alt_to_X == 'USE_RED' and alt_to_Y == 'USE_BLUE'):\n            return 'USE_RED_OR_BLUE'\n        if alt_to_X == 'USE_RED':\n            return 'USE_BLUE'\n        if alt_to_Y == 'USE_BLUE':\n            return 'USE_RED'\n        assert(False)\n    if B.LOWER:\n        #print(\"4.1.2\")\n        if A.topo_order < B.topo_order:\n            #print(\"4.1.2.1\")\n            if (alt_to_X == 'USE_BLUE'\n                and alt_to_Y == 'USE_RED'):\n                return 'USE_RED_OR_BLUE'\n            if alt_to_X == 'USE_BLUE':\n                return 'USE_BLUE'\n            if alt_to_Y == 'USE_RED':\n                return 'USE_RED'\n            assert(False)\n        else:\n            #print(\"4.1.2.2\")\n            if (alt_to_X == 'USE_RED'\n                and alt_to_Y == 'USE_BLUE'):\n                return 'USE_RED_OR_BLUE'\n            if alt_to_X == 'USE_RED':\n                return 'USE_BLUE'\n            if alt_to_Y == 'USE_BLUE':\n                return 'USE_RED'\n            assert(False)\n    else:\n        #print(\"4.1.3\")\n        if (F.LOWER and not F.HIGHER",
      "raw": true
    },
    {
      "indent": 8,
      "text": " and F.topo_order > A.topo_order): #print(\"4.1.3.1\") return 'USE_RED' else: #print(\"4.1.3.2\") return 'USE_BLUE' if A.HIGHER: #print(\"4.2\") if B.HIGHER: #print(\"4.2.1\") if A.topo_order < B.topo_order: #print(\"4.2.1.1\") if (alt_to_X == 'USE_BLUE' and alt_to_Y == 'USE_RED'): return 'USE_RED_OR_BLUE' if alt_to_X == 'USE_BLUE': return 'USE_BLUE' if alt_to_Y == 'USE_RED': return 'USE_RED' assert(False) else: #print(\"4.2.1.2\") if (alt_to_X == 'USE_RED' and alt_to_Y == 'USE_BLUE'): return 'USE_RED_OR_BLUE' if alt_to_X == 'USE_RED': return 'USE_BLUE' if alt_to_Y == 'USE_BLUE': return 'USE_RED' assert(False) if B.LOWER: #print(\"4.2.2\") if (alt_to_X == 'USE_BLUE' and alt_to_Y == 'USE_RED'): return 'USE_RED_OR_BLUE' if alt_to_X == 'USE_BLUE': return 'USE_BLUE' if alt_to_Y == 'USE_RED': return 'USE_RED' assert(False) else: #print(\"4.2.3\") if (F.HIGHER and not F.LOWER and F.topo_order < A.topo_order): return 'USE_RED' else: return 'USE_BLUE'",
      "ja": "そしてF.topo_order> A.topo_order）：#print（ \"4.1.3.1\"）のリターン 'USE_RED' 他：#print（ \"4.1.3.2\"）のリターン 'USE_BLUE' A.HIGHER場合：#print（ \"4.2\"） B.HIGHER場合：#print（ \"4.2.1\"）であればA.topo_order <B.topo_order：#print（ \"4.2.1.1\"）（alt_to_X == 'USE_BLUE' とalt_to_Y == 'USE_RED'）の場合：リターン'USE_RED_OR_BLUE' もしalt_to_X == 'USE_BLUE'：リターン 'USE_BLUE' もしalt_to_Y == 'USE_RED'：リターン 'USE_RED' アサート（偽）他：#print（ \"4.2.1.2\"）（もしalt_to_X == 'USE_RED'そしてalt_to_Y == 'USE_BLUE'）：リターン 'USE_RED_OR_BLUE' もしalt_to_X == 'USE_RED'：リターン 'USE_BLUE' もしalt_to_Y == 'USE_BLUE'：リターン 'USE_RED' アサート（B.LOWER場合）偽：#print（」 4.2.2\" ）（alt_to_X == 'USE_BLUE' とalt_to_Y == 'USE_RED'）の場合：戻り 'USE_RED_OR_BLUE' もしalt_to_X == 'USE_BLUE'：リターン 'USE_BLUE' もしalt_to_Y == 'USE_RED'：リターン 'USE_RED'それ以外（偽）をアサート：#print（ \"4.2.3\"）（F.HIGHERなくF.LOWERとF.topo_order <A.topo_order）場合：リターン 'USE_RED' 他：リターン 'USE_BLUE'"
    },
    {
      "indent": 4,
      "text": " else: #print(\"4.3\") if B.LOWER: #print(\"4.3.1\") if (F.LOWER and not F.HIGHER and F.topo_order > B.topo_order): return 'USE_BLUE' else: return 'USE_RED' if B.HIGHER: #print(\"4.3.2\") if (F.HIGHER and not F.LOWER and F.topo_order < B.topo_order): return 'USE_BLUE' else: return 'USE_RED' else: #print(\"4.3.3\") if A.topo_order < B.topo_order: #print(\"4.3.3.1\") if (alt_to_X == 'USE_BLUE' and alt_to_Y == 'USE_RED'): return 'USE_RED_OR_BLUE' if alt_to_X == 'USE_BLUE': return 'USE_BLUE' if alt_to_Y == 'USE_RED': return 'USE_RED' assert(False) else: #print(\"4.3.3.2\") if (alt_to_X == 'USE_RED' and alt_to_Y == 'USE_BLUE'): return 'USE_RED_OR_BLUE' if alt_to_X == 'USE_RED': return 'USE_BLUE' if alt_to_Y == 'USE_BLUE': return 'USE_RED' assert(False) assert(False)",
      "ja": "他：#print（ \"4.3\"）の場合B.LOWER：#print（ \"4.3.1\"）であれば（F.LOWERなくF.HIGHERとF.topo_order> B.topo_order）：リターン 'USE_BLUE' 他：リターンB.HIGHER場合は、 'USE_RED'：#print（ \"4.3.2\"）（F.HIGHERなくF.LOWERとF.topo_order <B.topo_order）の場合：戻り 'USE_BLUE' 他：リターン 'USE_RED' 他：＃印刷（ \"4.3.3\"）であればA.topo_order <B.topo_order：#print（ \"4.3.3.1\"）（alt_to_X == 'USE_BLUE' とalt_to_Y == 'USE_RED'）の場合：戻り 'USE_RED_OR_BLUE' もしalt_to_X = = 'USE_BLUE'：リターン 'USE_BLUE' もしalt_to_Y == 'USE_RED'：リターン 'USE_RED' 他のassert（偽）：#print（ \"4.3.3.2\"）（もしalt_to_X == 'USE_RED' とalt_to_Y ==「USE_BLUE 「）：リターン 'USE_RED_OR_BLUE' もしalt_to_X == 'USE_RED'：リターン 'USE_BLUE' もしalt_to_Y == 'USE_BLUE'：リターン 'USE_RED' アサート（False）がアサート（偽）"
    },
    {
      "indent": 0,
      "text": "def Compute_Primary_NHs_For_One_Src_To_Named_Proxy_Nodes(topo,src): for prefix in topo.named_proxy_dict: P = topo.named_proxy_dict[prefix] min_total_pref_cost = 2147483647 for (adv_node, prefix_cost) in P.node_prefix_cost_list: total_pref_cost = (adv_node.primary_spf_metric + prefix_cost) if total_pref_cost < min_total_pref_cost:",
      "ja": "DEF Compute_Primary_NHs_For_One_Src_To_Named_Proxy_Nodes（TOPO、SRC）：topo.named_proxy_dictにおける接頭辞：P = topo.named_proxy_dict [プレフィックス] min_total_pref_cost = 2147483647 P.node_prefix_cost_listで（adv_node、prefix_cost）用：total_pref_cost =（adv_node.primary_spf_metric + prefix_cost）場合min_total_pref_cost <total_pref_cost ："
    },
    {
      "indent": 12,
      "text": "    min_total_pref_cost = total_pref_cost\n    Copy_List_Items(P.primary_next_hops,\n                    adv_node.primary_next_hops)\nelif total_pref_cost == min_total_pref_cost:\n    for nh_intf in adv_node.primary_next_hops:\n        Add_Item_To_List_If_New(P.primary_next_hops,\n                                nh_intf)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "def Select_Alts_For_One_Src_To_Named_Proxy_Nodes(topo,src): for prefix in topo.named_proxy_dict: P = topo.named_proxy_dict[prefix] P.alt_list = [] for failed_intf in P.primary_next_hops: alt = Alternate() alt.failed_intf = failed_intf if failed_intf not in src.island_intf_list: alt.info = 'PRIM_NH_FOR_PROXY_NODE_NOT_IN_ISLAND' elif P.pnar1 is None: alt.info = 'NO_PNARs_EXIST_FOR_THIS_PREFIX' elif src is P.pnar1.node: alt.info = 'SRC_IS_PNAR' elif P.pnar2 is not None and src is P.pnar2.node: alt.info = 'SRC_IS_PNAR' elif P.pnar2 is None: #inherit alternates from the only pnar. alt.info = Select_Alternates(P.pnar1.node, failed_intf.remote_node, failed_intf) elif failed_intf in src.island_intf_list: alt.info = Select_Alternates_Proxy_Node(P, failed_intf.remote_node, failed_intf)",
      "ja": "DEF Select_Alts_For_One_Src_To_Named_Proxy_Nodes（TOPO、SRC）：P = topo.named_proxy_dict [プレフィックス] P.alt_list = [] P.primary_next_hopsでfailed_intf用：ALT =代替（）alt.failed_intf = failed_intf failed_intfないで場合topo.named_proxy_dictでプレフィックスのsrc.island_intf_list：alt.infoは= 'PRIM_NH_FOR_PROXY_NODE_NOT_IN_ISLAND' elifのP.pnar1がNone：= alt.info 'がNO_PNARs_EXIST_FOR_THIS_PREFIX' ELIFのsrcがP.pnar1.nodeです：= 'SRC_IS_PNAR' alt.infoはelifのP.pnar2はなしとSRCませんP.pnar2.nodeさ：elifのP.pnar2はなしalt.info = 'SRC_IS_PNAR' のではありません：だけpnarから#inherit交互に。 alt.info = Select_Alternates（P.pnar1.node、failed_intf.remote_node、failed_intf）src.island_intf_listでELIFのfailed_intf：alt.info = Select_Alternates_Proxy_Node（P、failed_intf.remote_node、failed_intf）"
    },
    {
      "indent": 12,
      "text": "if alt.info == 'USE_RED_OR_BLUE':\n    alt.red_or_blue = \\\n        random.choice(['USE_RED','USE_BLUE'])\nif (alt.info == 'USE_BLUE'\n    or alt.red_or_blue == 'USE_BLUE'):\n    Copy_List_Items(alt.nh_list, P.blue_next_hops)\n    alt.fec = 'BLUE'\n    alt.prot = 'NODE_PROTECTION'\nelif (alt.info == 'USE_RED'\n      or alt.red_or_blue == 'USE_RED'):\n    Copy_List_Items(alt.nh_list, P.red_next_hops)\n    alt.fec = 'RED'\n    alt.prot = 'NODE_PROTECTION'\nelif (alt.info == 'PRIM_NH_IS_D_OR_OP_FOR_D'\n    or alt.info == 'PRIM_NH_IS_OP_FOR_BOTH_X_AND_Y'):\n    if failed_intf.OUTGOING and failed_intf.INCOMING:\n        # cut-link: if there are parallel cut links, use",
      "raw": true
    },
    {
      "indent": 16,
      "text": "    # the link(s) with lowest metric that are not\n    # primary intf or None\n    cand_alt_list = [None]\n    min_metric = 2147483647\n    for intf in src.island_intf_list:\n        if ( intf is not failed_intf and\n             (intf.remote_node is\n             failed_intf.remote_node)):\n            if intf.metric < min_metric:\n                cand_alt_list = [intf]\n                min_metric = intf.metric\n            elif intf.metric == min_metric:\n                cand_alt_list.append(intf)\n    if cand_alt_list != [None]:\n        alt.fec = 'GREEN'\n        alt.prot = 'PARALLEL_CUTLINK'\n    else:\n        alt.fec = 'NO_ALTERNATE'\n        alt.prot = 'NO_PROTECTION'\n    Copy_List_Items(alt.nh_list, cand_alt_list)\nelse:\n    # set Z as the node to inherit blue next hops from\n    if alt.info == 'PRIM_NH_IS_D_OR_OP_FOR_D':\n        Z = P.pnar1.node\n    else:\n        Z = P\n    if failed_intf in Z.red_next_hops:\n        Copy_List_Items(alt.nh_list, Z.blue_next_hops)\n        alt.fec = 'BLUE'\n        alt.prot = 'LINK_PROTECTION'\n    else:\n        assert(failed_intf in Z.blue_next_hops)\n        Copy_List_Items(alt.nh_list, Z.red_next_hops)\n        alt.fec = 'RED'\n        alt.prot = 'LINK_PROTECTION'",
      "raw": true
    },
    {
      "indent": 12,
      "text": "elif alt.info == 'PRIM_NH_FOR_PROXY_NODE_NOT_IN_ISLAND': if (P.pnar2 == None and src is P.pnar1.node): #MRT Island is singly connected to non-island dest alt.fec = 'NO_ALTERNATE' alt.prot = 'NO_PROTECTION' elif P.node_id in src.blue_to_green_nh_dict: # blue to P goes to failed LFIN so use red to P Copy_List_Items(alt.nh_list, P.red_next_hops) alt.fec = 'RED' alt.prot = 'LINK_PROTECTION' elif P.node_id in src.red_to_green_nh_dict: # red to P goes to failed LFIN so use blue to P",
      "ja": "elifの== 'PRIM_NH_FOR_PROXY_NODE_NOT_IN_ISLAND' alt.info：（P.pnar2は==なしとsrcがP.pnar1.nodeはありません）場合：#MRT島を単独で非島に接続されているDEST alt.fec = 'NO_ALTERNATE' alt.prot = src.blue_to_green_nh_dictの 'NO_PROTECTION' のelif P.node_id：Pへ＃ブルーが失敗LFINにそうP Copy_List_Items（alt.nh_list、P.red_next_hops）に赤色を使用移行alt.fec = 'RED' alt.prot = 'LINK_PROTECTION' ELIF src.red_to_green_nh_dictでP.node_id：Pへ＃赤が失敗したLFINに行くので、Pに青を使用"
    },
    {
      "indent": 12,
      "text": " Copy_List_Items(alt.nh_list, P.blue_next_hops) alt.fec = 'BLUE' alt.prot = 'LINK_PROTECTION' else: Copy_List_Items(alt.nh_list, P.blue_next_hops) alt.fec = 'BLUE' alt.prot = 'LINK_PROTECTION' elif alt.info == 'TEMP_NO_ALTERNATE': alt.fec = 'NO_ALTERNATE' alt.prot = 'NO_PROTECTION'",
      "ja": "Copy_List_Items（alt.nh_list、P.blue_next_hops）alt.fec = '青' 他alt.prot = 'LINK_PROTECTION'：Copy_List_Items（alt.nh_list、P.blue_next_hops）alt.fec = '青' alt.prot = 'LINK_PROTECTION' elifのalt.info == 'TEMP_NO_ALTERNATE'：alt.fec = 'NO_ALTERNATE' alt.prot = 'NO_PROTECTION'"
    },
    {
      "indent": 12,
      "text": "P.alt_list.append(alt)",
      "ja": "P.alt_list.append（合計）"
    },
    {
      "indent": 0,
      "text": "def Run_Basic_MRT_for_One_Source(topo, src): MRT_Island_Identification(topo, src, 0, 0) Set_Island_Intf_and_Node_Lists(topo) Set_GADAG_Root(topo,src) Sort_Interfaces(topo) Run_Lowpoint(topo) Assign_Remaining_Lowpoint_Parents(topo) Construct_GADAG_via_Lowpoint(topo) Run_Assign_Block_ID(topo) Add_Undirected_Links(topo) Compute_MRT_NH_For_One_Src_To_Island_Dests(topo,src) Store_MRT_Nexthops_For_One_Src_To_Island_Dests(topo,src) Select_Alts_For_One_Src_To_Island_Dests(topo,src) Store_Primary_and_Alts_For_One_Src_To_Island_Dests(topo,src)",
      "ja": "DEF Run_Basic_MRT_for_One_Source（TOPO、SRC）：MRT_Island_Identification（TOPO、SRC、0、0）Set_Island_Intf_and_Node_Lists（TOPO）Set_GADAG_Root（TOPO、SRC）Sort_Interfaces（TOPO）Run_Lowpoint（TOPO）Assign_Remaining_Lowpoint_Parents（TOPO）Construct_GADAG_via_Lowpoint（TOPO）Run_Assign_Block_ID（TOPO）Add_Undirected_Links（トポ）Compute_MRT_NH_For_One_Src_To_Island_Dests（トポ、SRC）Store_MRT_Nexthops_For_One_Src_To_Island_Dests（トポ、SRC）Select_Alts_For_One_Src_To_Island_Dests（トポ、SRC）Store_Primary_and_Alts_For_One_Src_To_Island_Dests（トポ、SRC）"
    },
    {
      "indent": 0,
      "text": "def Store_GADAG_and_Named_Proxies_Once(topo): for node in topo.node_list: for intf in node.intf_list: if intf.OUTGOING: intf.SIMULATION_OUTGOING = True else: intf.SIMULATION_OUTGOING = False for prefix in topo.named_proxy_dict: P = topo.named_proxy_dict[prefix] topo.stored_named_proxy_dict[prefix] = P",
      "ja": "デフStore_GADAG_and_Named_Proxies_Once（トポ）：node.intf_listでINTF用：topo.node_list内のノードの場合intf.OUTGOING：intf.SIMULATION_OUTGOING =他の真：topo.named_proxy_dictでプレフィックスのintf.SIMULATION_OUTGOING =偽：P = topo.named_proxy_dict [接頭辞] topo.stored_named_proxy_dict [プレフィックス] = P"
    },
    {
      "indent": 0,
      "text": "def Run_Basic_MRT_for_All_Sources(topo): for src in topo.node_list: Reset_Computed_Node_and_Intf_Values(topo) Run_Basic_MRT_for_One_Source(topo,src) if src is topo.gadag_root: Store_GADAG_and_Named_Proxies_Once(topo)",
      "ja": "デフRun_Basic_MRT_for_All_Sources（トポ）：topo.node_listでSRC用：Reset_Computed_Node_and_Intf_Values（トポ）Run_Basic_MRT_for_One_Source（トポ、SRC）srcがtopo.gadag_rootの場合：Store_GADAG_and_Named_Proxies_Once（トポ）"
    },
    {
      "indent": 0,
      "text": "def Run_MRT_for_One_Source(topo, src): MRT_Island_Identification(topo, src, 0, 0) Set_Island_Intf_and_Node_Lists(topo) Set_GADAG_Root(topo,src) Sort_Interfaces(topo) Run_Lowpoint(topo) Assign_Remaining_Lowpoint_Parents(topo) Construct_GADAG_via_Lowpoint(topo) Run_Assign_Block_ID(topo) Add_Undirected_Links(topo) Compute_MRT_NH_For_One_Src_To_Island_Dests(topo,src) Store_MRT_Nexthops_For_One_Src_To_Island_Dests(topo,src) Select_Alts_For_One_Src_To_Island_Dests(topo,src) Store_Primary_and_Alts_For_One_Src_To_Island_Dests(topo,src) Create_Basic_Named_Proxy_Nodes(topo) Attach_Named_Proxy_Nodes(topo) Compute_MRT_NHs_For_One_Src_To_Named_Proxy_Nodes(topo,src) Store_MRT_NHs_For_One_Src_To_Named_Proxy_Nodes(topo,src) Compute_Primary_NHs_For_One_Src_To_Named_Proxy_Nodes(topo,src) Store_Primary_NHs_For_One_Src_To_Named_Proxy_Nodes(topo,src) Select_Alts_For_One_Src_To_Named_Proxy_Nodes(topo,src) Store_Alts_For_One_Src_To_Named_Proxy_Nodes(topo,src)",
      "ja": "DEF Run_MRT_for_One_Source（TOPO、SRC）：MRT_Island_Identification（TOPO、SRC、0、0）Set_Island_Intf_and_Node_Lists（TOPO）Set_GADAG_Root（TOPO、SRC）Sort_Interfaces（TOPO）Run_Lowpoint（TOPO）Assign_Remaining_Lowpoint_Parents（TOPO）Construct_GADAG_via_Lowpoint（TOPO）Run_Assign_Block_ID（TOPO）Add_Undirected_Links（ TOPO）Compute_MRT_NH_For_One_Src_To_Island_Dests（TOPO、SRC）Store_MRT_Nexthops_For_One_Src_To_Island_Dests（TOPO、SRC）Select_Alts_For_One_Src_To_Island_Dests（TOPO、SRC）Store_Primary_and_Alts_For_One_Src_To_Island_Dests（TOPO、SRC）Create_Basic_Named_Proxy_Nodes（TOPO）Attach_Named_Proxy_Nodes（TOPO）Compute_MRT_NHs_For_One_Src_To_Named_Proxy_Nodes（TOPO、SRC）Store_MRT_NHs_For_One_Src_To_Named_Proxy_Nodes（TOPO、SRC）Compute_Primary_NHs_For_One_Src_To_Named_Proxy_Nodes（TOPO、 SRC）Store_Primary_NHs_For_One_Src_To_Named_Proxy_Nodes（トポ、SRC）Select_Alts_For_One_Src_To_Named_Proxy_Nodes（トポ、SRC）Store_Alts_For_One_Src_To_Named_Proxy_Nodes（トポ、SRC）"
    },
    {
      "indent": 0,
      "text": "def Run_Prim_SPF_for_One_Source(topo,src): Normal_SPF(topo, src) Store_Primary_NHs_For_One_Source_To_Nodes(topo,src) Create_Basic_Named_Proxy_Nodes(topo) Compute_Primary_NHs_For_One_Src_To_Named_Proxy_Nodes(topo,src) Store_Primary_NHs_For_One_Src_To_Named_Proxy_Nodes(topo,src)",
      "ja": "DEF Run_Prim_SPF_for_One_Source（TOPO、SRC）：Normal_SPF（TOPO、SRC）Store_Primary_NHs_For_One_Source_To_Nodes（TOPO、SRC）Create_Basic_Named_Proxy_Nodes（TOPO）Compute_Primary_NHs_For_One_Src_To_Named_Proxy_Nodes（TOPO、SRC）Store_Primary_NHs_For_One_Src_To_Named_Proxy_Nodes（TOPO、SRC）"
    },
    {
      "indent": 0,
      "text": "def Run_MRT_for_All_Sources(topo): for src in topo.node_list: Reset_Computed_Node_and_Intf_Values(topo) if src in topo.island_node_list_for_test_gr: # src runs MRT if it is in same MRT island as test_gr Run_MRT_for_One_Source(topo,src) if src is topo.gadag_root: Store_GADAG_and_Named_Proxies_Once(topo) else: # src still runs SPF if not in MRT island Run_Prim_SPF_for_One_Source(topo,src)",
      "ja": "デフRun_MRT_for_All_Sources（トポ）：topo.node_listでSRC用：topo.island_node_list_for_test_grでReset_Computed_Node_and_Intf_Values（トポ）SRCの場合：srcがtopo.gadag_rootであれば、それはtest_gr Run_MRT_for_One_Source（トポ、SRC）と同じMRT島にある場合＃のSRCは、MRTを実行します：他Store_GADAG_and_Named_Proxies_Once（トポ）：＃1 srcがまだMRT島Run_Prim_SPF_for_One_Source（トポ、SRC）でSPFを実行している場合ではありません"
    },
    {
      "indent": 0,
      "text": "def Write_Output_To_Files(topo,file_prefix): Write_GADAG_To_File(topo,file_prefix) Write_Both_MRTs_For_All_Dests_To_File(topo,file_prefix) Write_Alternates_For_All_Dests_To_File(topo,file_prefix)",
      "ja": "DEF Write_Output_To_Files（TOPO、FILE_PREFIX）：Write_GADAG_To_File（TOPO、FILE_PREFIX）Write_Both_MRTs_For_All_Dests_To_File（TOPO、FILE_PREFIX）Write_Alternates_For_All_Dests_To_File（TOPO、FILE_PREFIX）"
    },
    {
      "indent": 0,
      "text": "def Create_Basic_Topology_Input_File(filename): data = [[01,02,10],[02,03,10],[03,04,11],[04,05,10,20],[05,06,10], [06,07,10],[06,07,10],[06,07,15],[07,01,10],[07,51,10], [51,52,10],[52,53,10],[53,03,10],[01,55,10],[55,06,10], [04,12,10],[12,13,10],[13,14,10],[14,15,10],[15,16,10], [16,17,10],[17,04,10],[05,76,10],[76,77,10],[77,78,10], [78,79,10],[79,77,10]] with open(filename + '.csv', 'w') as topo_file: for item in data: if len(item) > 3: line = (str(item[0])+','+str(item[1])+','+ str(item[2])+','+str(item[3])+'\\n') else: line = (str(item[0])+','+str(item[1])+','+ str(item[2])+'\\n') topo_file.write(line)",
      "ja": "DEF Create_Basic_Topology_Input_File（ファイル名）：データ= [01,02,10]、[02,03,10]、[03,04,11]、[04,05,10,20]、[05,06,10] [06,07,10]、[06,07,10]、[06,07,15]、[07,01,10]、[07,51,10]、[51,52,10]、[ 52,53,10]、[53,03,10]、[01,55,10]、[55,06,10]、[04,12,10]、[12,13,10]、[13]、[ 14,10]、[14,15,10]、[15,16,10]、[16,17,10]、[17,04,10]、[05,76,10]、[76,77、 10]、[77,78,10]、[78,79,10]、[79,77,10]開く（ファイル名+ 'の.csv'、 'W'）topo_fileとして：項目のデータで：もしLEN（項目）> 3：行=（STR（項目[0]）+ ' '+ STR（項目[1]）+'、 '+ STR（項目[2]）+'、' + STR（項目[ 3]）+ '\\ n'）他：行=（STR（項目[0]）+ ' '+ STR（項目[1]）+'、 '+ STR（項目[2]）+' \\ n' は）topo_file.write（ライン）"
    },
    {
      "indent": 0,
      "text": "def Create_Complex_Topology_Input_File(filename): data = [[01,02,10],[02,03,10],[03,04,11],[04,05,10,20],[05,06,10], [06,07,10],[06,07,10],[06,07,15],[07,01,10],[07,51,10], [51,52,10],[52,53,10],[53,03,10],[01,55,10],[55,06,10], [04,12,10],[12,13,10],[13,14,10],[14,15,10],[15,16,10], [16,17,10],[17,04,10],[05,76,10],[76,77,10],[77,78,10], [78,79,10],[79,77,10]] with open(filename + '.csv', 'w') as topo_file: for item in data: if len(item) > 3: line = (str(item[0])+','+str(item[1])+','+ str(item[2])+','+str(item[3])+'\\n') else: line = (str(item[0])+','+str(item[1])+','+ str(item[2])+'\\n') topo_file.write(line)",
      "ja": "DEF Create_Complex_Topology_Input_File（ファイル名）：データ= [01,02,10]、[02,03,10]、[03,04,11]、[04,05,10,20]、[05,06,10] [06,07,10]、[06,07,10]、[06,07,15]、[07,01,10]、[07,51,10]、[51,52,10]、[ 52,53,10]、[53,03,10]、[01,55,10]、[55,06,10]、[04,12,10]、[12,13,10]、[13]、[ 14,10]、[14,15,10]、[15,16,10]、[16,17,10]、[17,04,10]、[05,76,10]、[76,77、 10]、[77,78,10]、[78,79,10]、[79,77,10]開く（ファイル名+ 'の.csv'、 'W'）topo_fileとして：項目のデータで：もしLEN（項目）> 3：行=（STR（項目[0]）+ ' '+ STR（項目[1]）+'、 '+ STR（項目[2]）+'、' + STR（項目[ 3]）+ '\\ n'）他：行=（STR（項目[0]）+ ' '+ STR（項目[1]）+'、 '+ STR（項目[2]）+' \\ n' は）topo_file.write（ライン）"
    },
    {
      "indent": 4,
      "text": "data = [[01,0],[02,0],[03,0],[04,0],[05,0],\n        [06,0],[07,0],\n        [51,0],[55,0],\n        [12,0],[13,0],[14,0],[15,0],\n        [16,0],[17,0],[76,0],[77,0],\n        [78,0],[79,0]]\nwith open(filename + '.profile', 'w') as topo_file:\n    for item in data:\n        line = (str(item[0])+','+str(item[1])+'\\n')\n        topo_file.write(line)",
      "raw": true
    },
    {
      "indent": 4,
      "text": "data = [[2001,05,100],[2001,07,120],[2001,03,130], [2002,13,100],[2002,15,110], [2003,52,100],[2003,78,100]]",
      "ja": "データ= [2001,05,100]、[2001,07,120]、[2001,03,130]、[2002,13,100]、[2002,15,110]、[2003,52,100]、[2003,78,100]"
    },
    {
      "indent": 4,
      "text": "with open(filename + '.prefix', 'w') as topo_file: for item in data: line = (str(item[0])+','+str(item[1])+','+ str(item[2])+'\\n') topo_file.write(line)",
      "ja": "項目のデータで：topo_fileとして（ファイル名+ '.prefix'、 'W'）オープンに沿っ=（STR（項目[0]）+ ' '+ STR（項目[1]）+'' + STR （項目[2]）+ '\\ n'）topo_file.write（ライン）"
    },
    {
      "indent": 0,
      "text": "def Generate_Basic_Topology_and_Run_MRT(): this_gadag_root = 3 Create_Basic_Topology_Input_File('basic_topo_input') topo = Create_Topology_From_File('basic_topo_input') res_file_base = 'basic_topo' Compute_Island_Node_List_For_Test_GR(topo, this_gadag_root) Raise_GADAG_Root_Selection_Priority(topo,this_gadag_root) Run_Basic_MRT_for_All_Sources(topo) Write_Output_To_Files(topo, res_file_base)",
      "ja": "DEF Generate_Basic_Topology_and_Run_MRT（）：this_gadag_root = 3 Create_Basic_Topology_Input_File（ 'basic_topo_input'）TOPO = Create_Topology_From_File（ 'basic_topo_input'）res_file_base = 'basic_topo' Compute_Island_Node_List_For_Test_GR（TOPO、this_gadag_root）Raise_GADAG_Root_Selection_Priority（TOPO、this_gadag_root）Run_Basic_MRT_for_All_Sources（TOPO）Write_Output_To_Files（TOPO、res_file_base）"
    },
    {
      "indent": 0,
      "text": "def Generate_Complex_Topology_and_Run_MRT(): this_gadag_root = 3 Create_Complex_Topology_Input_File('complex_topo_input') topo = Create_Topology_From_File('complex_topo_input') Add_Profile_IDs_from_File(topo,'complex_topo_input') Add_Prefix_Advertisements_From_File(topo,'complex_topo_input') Compute_Island_Node_List_For_Test_GR(topo, this_gadag_root) Add_Prefixes_for_Non_Island_Nodes(topo) res_file_base = 'complex_topo' Raise_GADAG_Root_Selection_Priority(topo,this_gadag_root) Run_MRT_for_All_Sources(topo) Write_Output_To_Files(topo, res_file_base)",
      "ja": "DEF Generate_Complex_Topology_and_Run_MRT（）：this_gadag_root = 3 Create_Complex_Topology_Input_File（ 'complex_topo_input'）TOPO = Create_Topology_From_File（ 'complex_topo_input'）Add_Profile_IDs_from_File（TOPO、 'complex_topo_input'）Add_Prefix_Advertisements_From_File（TOPO、 'complex_topo_input'）Compute_Island_Node_List_For_Test_GR（TOPO、this_gadag_root）Add_Prefixes_for_Non_Island_Nodes（TOPO）res_file_base = 'complex_topo' Raise_GADAG_Root_Selection_Priority（TOPO、this_gadag_root）Run_MRT_for_All_Sources（TOPO）Write_Output_To_Files（TOPO、res_file_base）"
    },
    {
      "indent": 0,
      "text": "Generate_Basic_Topology_and_Run_MRT()",
      "ja": "Generate_Basic_Topology_and_Run_MRT（）"
    },
    {
      "indent": 0,
      "text": "Generate_Complex_Topology_and_Run_MRT()",
      "ja": "Generate_Complex_Topology_and_Run_MRT（）"
    },
    {
      "indent": 0,
      "text": "<CODE ENDS>",
      "ja": "<CODEはENDS>"
    },
    {
      "indent": 0,
      "text": "Appendix B. Constructing a GADAG Using SPFs",
      "ja": "付録B.は、SPF値を使用してGADAGの構築します"
    },
    {
      "indent": 3,
      "text": "The basic idea in this method for constructing a GADAG is to use slightly modified SPF computations to find ears. In every block, an SPF computation is first done to find a cycle from the local root and then SPF computations in that block find ears until there are no more interfaces to be explored. The used result from the SPF computation is the path of interfaces indicated by following the previous hops from the minimized IN_GADAG node back to the SPF root.",
      "ja": "GADAGを構築するため、この方法では基本的な考え方は、耳を見つけるためにわずかに変更されたSPF計算を使用することです。各ブロックでは、SPFの計算は、まずローカルルートからサイクルを見つけ、探求すべき複数のインターフェイスが存在しなくなるまで、そのブロック内のSPFの計算は耳を見つけるために行われます。 SPF計算の使用の結果は、バックSPFルートに最小IN_GADAGノードから前ホップを以下で示すインタフェースの経路です。"
    },
    {
      "indent": 3,
      "text": "To do this, first all cut-vertices must be identified and localroots assigned as specified in Figure 12.",
      "ja": "これを行うには、まずカット頂点が識別されなければならないと、図12で指定されるようにlocalroots割り当てられました。"
    },
    {
      "indent": 3,
      "text": "The slight modifications to the SPF are as follows. The root of the block is referred to as the block-root; it is either the GADAG root or a cut-vertex.",
      "ja": "次のようにSPFに若干の変更があります。ブロックのルートはブロックルートと呼ばれます。それはGADAGルートまたはカット頂点のいずれかです。"
    },
    {
      "indent": 3,
      "text": "a. The SPF is rooted at a neighbor x of an IN_GADAG node y. All links between y and x are marked as TEMP_UNUSABLE. They should not be used during the SPF computation.",
      "ja": "A。 SPFはIN_GADAGノードYの近隣Xに根ざしています。 yとxの間のすべてのリンクはTEMP_UNUSABLEとしてマークされています。彼らは、SPF計算の際に使用すべきではありません。"
    },
    {
      "indent": 3,
      "text": "b. If y is not the block-root, then it is marked TEMP_UNUSABLE. It should not be used during the SPF computation. This prevents ears from starting and ending at the same node and avoids cycles; the exception is because cycles to/from the block-root are acceptable and expected.",
      "ja": "B。 yはブロックルートではない場合、それはTEMP_UNUSABLEマークされます。これは、SPF計算の際に使用すべきではありません。これは、同じノードで開始と終了から耳を防止し、サイクルを回避します。 /ブロックルートからのサイクルが許容されると予想されるので、例外があります。"
    },
    {
      "indent": 3,
      "text": "c. Do not explore links to nodes whose localroot is not the block-root. This keeps the SPF confined to the particular block.",
      "ja": "C。 localrootブロック-rootでないノードへのリンクを探索しないでください。これは、特定のブロックに限定SPFを保持します。"
    },
    {
      "indent": 3,
      "text": "d. Terminate when the first IN_GADAG node z is minimized.",
      "ja": "D。第IN_GADAGノードZが最小化されたときに終了します。"
    },
    {
      "indent": 3,
      "text": "e. Respect the existing directions (e.g., INCOMING, OUTGOING, UNDIRECTED) already specified for each interface.",
      "ja": "電子。既存の方向（例えば、INCOMING、OUTGOING、無向）既に各インターフェイスに指定。"
    },
    {
      "indent": 4,
      "text": "Mod_SPF(spf_root, block_root) Initialize spf_heap to empty Initialize nodes' spf_metric to infinity spf_root.spf_metric = 0 insert(spf_heap, spf_root) found_in_gadag = false while (spf_heap is not empty) and (found_in_gadag is false) min_node = remove_lowest(spf_heap) if min_node.IN_GADAG found_in_gadag = true else foreach interface intf of min_node if ((intf.OUTGOING or intf.UNDIRECTED) and ((intf.remote_node.localroot is block_root) or (intf.remote_node is block_root)) and (intf.remote_node is not TEMP_UNUSABLE) and (intf is not TEMP_UNUSABLE)) path_metric = min_node.spf_metric + intf.metric if path_metric < intf.remote_node.spf_metric intf.remote_node.spf_metric = path_metric intf.remote_node.spf_prev_intf = intf insert_or_update(spf_heap, intf.remote_node) return min_node",
      "ja": "Mod_SPF（spf_root、block_root）= 0インサート（spf_heap、spf_root）found_in_gadag =偽一方（spf_heapが空でない）と（found_in_gadagがfalse）min_node = remove_lowest（spf_heap）場合無限spf_root.spf_metricに初期ノードのspf_metricを空にspf_heapを初期化min_nodeのmin_node.IN_GADAG found_in_gadag = trueの他のforeachインタフェースintf（（intf.OUTGOING又はintf.UNDIRECTED）及び（（intf.remote_node.localrootがblock_rootである）、または（intf.remote_node）がblock_rootである）および（intf.remote_nodeでない場合TEMP_UNUSABLE）及び（INTFがTEMP_UNUSABLEない））path_metric = min_node.spf_metric + intf.metric場合path_metric <intf.remote_node.spf_metric intf.remote_node.spf_metric = path_metric intf.remote_node.spf_prev_intf = INTF insert_or_update（spf_heap、intf.remote_node）リターンmin_node"
    },
    {
      "indent": 4,
      "text": "SPF_for_Ear(cand_intf.local_node,cand_intf.remote_node, block_root, method) Mark all interfaces between cand_intf.remote_node and cand_intf.local_node as TEMP_UNUSABLE if cand_intf.local_node is not block_root Mark cand_intf.local_node as TEMP_UNUSABLE Initialize ear_list to empty end_ear = Mod_SPF(spf_root, block_root) y = end_ear.spf_prev_hop while y.local_node is not spf_root add_to_list_start(ear_list, y) y.local_node.IN_GADAG = true y = y.local_node.spf_prev_intf if(method is not hybrid) Set_Ear_Direction(ear_list, cand_intf.local_node, end_ear,block_root) Clear TEMP_UNUSABLE from all interfaces between cand_intf.remote_node and cand_intf.local_node Clear TEMP_UNUSABLE from cand_intf.local_node return end_ear",
      "ja": "SPF_for_Ear（cand_intf.local_node、cand_intf.remote_node、block_root、方法）TEMP_UNUSABLEとしてcand_intf.remote_nodeとcand_intf.local_node間のすべてのインターフェイスcand_intf.local_nodeがTEMP_UNUSABLE初期化としてマークcand_intf.local_nodeがend_ear = Mod_SPFを空にするear_list block_rootされていない場合、マーク（spf_root、 block_root）Y = end_ear.spf_prev_hop y.local_nodeはspf_root add_to_list_start（ear_list、Yはないが）y.local_node.IN_GADAG = TRUE Y = y.local_node.spf_prev_intf（この方法は、ハイブリッドではない場合）Set_Ear_Direction（ear_list、cand_intf.local_node、end_ear cand_intf.local_nodeリターンend_earからcand_intf.remote_nodeとcand_intf.local_nodeクリアTEMP_UNUSABLE間のすべてのインターフェイスから、block_root）クリアTEMP_UNUSABLE"
    },
    {
      "indent": 14,
      "text": "Figure 31: Modified SPF for GADAG Construction",
      "ja": "図31：GADAGの建設のために変更されたSPF"
    },
    {
      "indent": 3,
      "text": "Assume that an ear is found by going from y to x and then running an SPF that terminates by minimizing z (e.g., y<->x...q<->z). Now it is necessary to determine the direction of the ear; if y<<z, then the path should be y->x...q->z; but if y>>z, then the path should be y<-x...q<-z. In Section 5.5, the same problem was handled by finding all ears that started at a node before looking at ears starting at nodes higher in the partial order. In this GADAG construction method, using that approach could mean that new ears aren't added in order of their total cost since all ears connected to a node would need to be found before additional nodes could be found.",
      "ja": "（< - > X ... Q < - > Z例えば、y）の耳をYからXに移動し、その後、Z最小化することによって終了SPFを実行することによって発見されると仮定する。今では、耳の方向を決定する必要があります。 Y << Zは、パスはY-> X ... Q-> Zでなければならない場合、 Y >> Z場合には、パスは-x ... Q <-z <Yであるべきです。 5.5節では、同じ問題は、部分的な順序で上位のノードから始まる耳を見る前にノードで開始したすべての耳を見つけることによって処理されていました。このGADAG工法では、このアプローチを使用すると、追加のノードを見つけることができる前にノードに接続されたすべての耳が見出される必要があるので、新たな耳は、それらの総コストの順序で添加されていないことを意味するかもしれません。"
    },
    {
      "indent": 3,
      "text": "The alternative is to track the order relationship of each node with respect to every other node. This can be accomplished by maintaining two sets of nodes at each node. The first set, Higher_Nodes, contains all nodes that are known to be ordered above the node. The second set, Lower_Nodes, contains all nodes that are known to be ordered below the node. This is the approach used in this GADAG construction method.",
      "ja": "代替的には、他のすべてのノードに対して、各ノードの順序関係を追跡することです。これは、各ノードでノードの二組を維持することによって達成することができます。最初のセット、Higher_Nodesは、ノード上に注文することが知られているすべてのノードを含みます。第二セット、Lower_Nodesは、ノードの下に注文することが知られているすべてのノードを含みます。これは、このGADAG工法で使用されるアプローチです。"
    },
    {
      "indent": 6,
      "text": "Set_Ear_Direction(ear_list, end_a, end_b, block_root) // Default of A_TO_B for the following cases: // (a) end_a and end_b are the same (root) // or (b) end_a is in end_b's Lower Nodes // or (c) end_a and end_b were unordered with respect to each // other direction = A_TO_B if (end_b is block_root) and (end_a is not end_b) direction = B_TO_A else if end_a is in end_b.Higher_Nodes direction = B_TO_A if direction is B_TO_A foreach interface i in ear_list i.UNDIRECTED = false i.INCOMING = true i.remote_intf.UNDIRECTED = false i.remote_intf.OUTGOING = true else foreach interface i in ear_list i.UNDIRECTED = false i.OUTGOING = true i.remote_intf.UNDIRECTED = false i.remote_intf.INCOMING = true if end_a is end_b return // Next, update all nodes' Lower_Nodes and Higher_Nodes if (end_a is in end_b.Higher_Nodes) foreach node x where x.localroot is block_root if end_a is in x.Lower_Nodes foreach interface i in ear_list add i.remote_node to x.Lower_Nodes if end_b is in x.Higher_Nodes foreach interface i in ear_list add i.local_node to x.Higher_Nodes else foreach node x where x.localroot is block_root if end_b is in x.Lower_Nodes foreach interface i in ear_list add i.local_node to x.Lower_Nodes if end_a is in x.Higher_Nodes foreach interface i in ear_list add i.remote_node to x.Higher_Nodes",
      "ja": "Set_Ear_Direction（ear_list、end_a、end_b、block_root）以下の例のためのA_TO_Bの//デフォルト：//（a）のend_aとend_bがある同じ（ルート）//または（b）のend_aは（end_bの下位ノード//またはでありますC）end_aとend_bは（end_aがend_bされていない）（end_bがblock_rootである場合、各//他の方向= A_TO_Bに関して順不同であった）と他方向= B_TO_A方向B_TO_Aのforeachのインタフェースである場合end_aはend_b.Higher_Nodes方向= B_TO_Aにある場合私ear_list i.UNDIRECTED = falseをi.INCOMING =真i.remote_intf.UNDIRECTED = falseのi.remote_intf.OUTGOING =他の真foreachのインターフェースで私ear_list i.UNDIRECTED = falseをi.OUTGOING = false trueのi.remote_intf.UNDIRECTED =中end_aがx.Lower_Nodes foreachのインタフェースである場合x.localrootはblock_rootあるi.remote_intf.INCOMING =真end_aは次にend_bリターン//である場合（end_aはend_b.Higher_Nodesにある）場合、すべてのノードのLower_NodesとHigher_Nodesを更新foreachのノードX end_bがx.Higher_Nodes foreachのINTEである場合、私はear_listにx.Lower_Nodesにi.remote_nodeを追加します私がear_list x.localrootがend_bがx.Lower_Nodes foreachのインタフェースである場合end_aはx.Higher_Nodes foreachのであれば私はx.Lower_Nodesにi.local_nodeを追加ear_list block_rootあるforeachのノードx他x.Higher_Nodesにi.local_nodeを追加データポートear_listのインターフェイス私はx.Higher_Nodesにi.remote_nodeを追加します"
    },
    {
      "indent": 9,
      "text": "Figure 32: Algorithm to Assign Links of an Ear Direction",
      "ja": "図32：アルゴリズムは、耳の方向のリンクを割り当てるには"
    },
    {
      "indent": 3,
      "text": "A goal of this GADAG construction method is to find the shortest cycles and ears. An ear is started by going to a neighbor x of an IN_GADAG node y. The path from x to an IN_GADAG node is minimal, since it is computed via SPF. Since a shortest path is made of shortest paths, to find the shortest ears requires reaching from the set of IN_GADAG nodes to the closest node that isn't IN_GADAG. Therefore, an ordered tree is maintained of interfaces that could be explored from the IN_GADAG nodes. The interfaces are ordered by their characteristics of metric, local loopback address, remote loopback address, and ifindex, based on the Interface_Compare function defined in Figure 14.",
      "ja": "このGADAG工法の目標は、最短のサイクルと耳を見つけることです。耳がIN_GADAGノードyの隣人xに行くことによって開始されます。それはSPFを介して計算されるので、XからIN_GADAGノードへのパスは、最小です。最短経路が最短耳を見つけるために、最短パスで構成されているのでIN_GADAGない最も近いノードにIN_GADAGノードの集合から到達必要とします。したがって、順序付きツリーはIN_GADAGノードから探求することができるインターフェイスで維持されます。インタフェースは、図14で定義されInterface_Compare関数に基づいて、メトリック、ローカルループバックアドレス、リモート・ループバックアドレス、およびifIndexのそれらの特性によって順序付けられます。"
    },
    {
      "indent": 3,
      "text": "This GADAG construction method ignores interfaces picked from the ordered list that belong to the block root if the block in which the interface is present already has an ear that has been computed. This is necessary since we allow at most one incoming interface to a block root in each block. This requirement stems from the way next hops are computed as was seen in Section 5.7. After any ear gets computed, we traverse the newly added nodes to the GADAG and insert interfaces whose far end is not yet on the GADAG to the ordered tree for later processing.",
      "ja": "このGADAG工法は、インターフェースが既に存在するブロックが計算された耳を持っている場合、ブロックルートに属する順序付きリストから選択インターフェースを無視します。私たちは、各ブロック内のブロックのルートに最大1つの着信インターフェイスで許可するので、これが必要です。この要件は、次のホップは5.7節で見たように計算されている方法に由来しています。任意の耳を計算取得した後、我々はGADAGに新しく追加されたノードをトラバースし、その遠端後の処理のために順序付けられたツリーにGADAGにまだないインターフェイスを挿入します。"
    },
    {
      "indent": 3,
      "text": "Finally, cut-links are a special case because there is no point in doing an SPF on a block of two nodes. The algorithm identifies cut-links simply as links where both ends of the link are cut-vertices. Cut-links can simply be added to the GADAG with both OUTGOING and INCOMING specified on their interfaces.",
      "ja": "二つのノードのブロックにSPFを行うにはポイントがないので最後に、カットリンクは特殊なケースです。アルゴリズムは、リンクの両端には、頂点を切断するリンクとして単にカットリンクを識別する。カットリンクは単にそのインタフェース上で指定発信および着信の両方でGADAGに添加することができます。"
    },
    {
      "indent": 5,
      "text": "add_eligible_interfaces_of_node(ordered_intfs_tree,node) for each interface of node if intf.remote_node.IN_GADAG is false insert(intf,ordered_intfs_tree)",
      "ja": "ノードの各インターフェイスのadd_eligible_interfaces_of_node（ordered_intfs_tree、ノード）intf.remote_node.IN_GADAGが偽インサート（INTF、ordered_intfs_tree）である場合"
    },
    {
      "indent": 5,
      "text": "check_if_block_has_ear(x,block_id) block_has_ear = false for all interfaces of x if ( (intf.remote_node.block_id == block_id) && intf.remote_node.IN_GADAG ) block_has_ear = true return block_has_ear",
      "ja": "check_if_block_has_ear xのすべてのインターフェイス（X、BLOCK_ID）block_has_ear = falseの場合（（intf.remote_node.block_id == BLOCK_ID）&& intf.remote_node.IN_GADAG）block_has_ear =真戻りblock_has_ear"
    },
    {
      "indent": 5,
      "text": "Construct_GADAG_via_SPF(topology, root)\n  Compute_Localroot (root,root)\n  Assign_Block_ID(root,0)\n  root.IN_GADAG = true\n     add_eligible_interfaces_of_node(ordered_intfs_tree,root)\n  while ordered_intfs_tree is not empty\n     cand_intf = remove_lowest(ordered_intfs_tree)\n     if cand_intf.remote_node.IN_GADAG is false\n        if L(cand_intf.remote_node) == D(cand_intf.remote_node)\n           // Special case for cut-links cand_intf.UNDIRECTED = false\n           cand_intf.remote_intf.UNDIRECTED = false\n           cand_intf.OUTGOING = true\n           cand_intf.INCOMING = true\n           cand_intf.remote_intf.OUTGOING = true\n           cand_intf.remote_intf.INCOMING = true\n           cand_intf.remote_node.IN_GADAG = true\n        add_eligible_interfaces_of_node(\n                       ordered_intfs_tree,cand_intf.remote_node)\n     else\n        if (cand_intf.remote_node.local_root ==\n            cand_intf.local_node) &&\n            check_if_block_has_ear(cand_intf.local_node,\n                         cand_intf.remote_node.block_id))\n            /* Skip the interface since the block root\n            already has an incoming interface in the\n            block */\n        else\n        ear_end = SPF_for_Ear(cand_intf.local_node,\n                cand_intf.remote_node,\n                cand_intf.remote_node.localroot,\n                SPF method)\n        y = ear_end.spf_prev_hop\n        while y.local_node is not cand_intf.local_node\n            add_eligible_interfaces_of_node(\n                ordered_intfs_tree, y.local_node)\n            y = y.local_node.spf_prev_intf",
      "raw": true
    },
    {
      "indent": 12,
      "text": "Figure 33: SPF-Based Method for GADAG Construction",
      "ja": "図33：GADAGの建設のためのSPFベースの方法"
    },
    {
      "indent": 0,
      "text": "Appendix C. Constructing a GADAG Using a Hybrid Method",
      "ja": "付録C.ハイブリッド法を用いたGADAGの構築します"
    },
    {
      "indent": 3,
      "text": "The idea of this method is to combine the salient features of the lowpoint inheritance and SPF methods. To this end, we process nodes as they get added to the GADAG just like in the lowpoint inheritance by maintaining a stack of nodes. This ensures that we do not need to maintain lower and higher sets at each node to ascertain ear directions since the ears will always be directed from the node being processed towards the end of the ear. To compute the ear however, we resort to an SPF to have the possibility of better ears (path lengths) thus giving more flexibility than the restricted use of lowpoint/dfs parents.",
      "ja": "この方法のアイデアはlowpoint継承とSPF方法の顕著な特徴を組み合わせることです。彼らは、ノードのスタックを維持することによって、単にlowpoint継承のようGADAGに追加されますように、この目的のために、我々は、ノードを処理します。これは、我々は耳が常に耳の終わりに向かって処理されているノードから指示されますので、耳の方向性を確認するために、各ノードでより低いおよびより高いセットを維持する必要がないことを保証します。しかし、耳を計算するために、我々はこのようにlowpoint / DFSの両親の使用制限よりも柔軟性を与え、より良い耳（路長）の可能性を持っているSPFに頼ります。"
    },
    {
      "indent": 3,
      "text": "Regarding ears involving a block root, unlike the SPF method, which ignored interfaces of the block root after the first ear, in the hybrid method we would have to process all interfaces of the block root before moving on to other nodes in the block since the direction of an ear is predetermined. Thus, whenever the block already has an ear computed, and we are processing an interface of the block root, we mark the block root as unusable before the SPF run that computes the ear. This ensures that the SPF terminates at some node other than the block-root. This in turn guarantees that the block-root has only one incoming interface in each block, which is necessary for correctly computing the next hops on the GADAG.",
      "ja": "ブロックルートを伴う耳について、最初の耳の後のブロックルートのインターフェイスを無視SPF法とは異なり、ハイブリッド方式では、以来、ブロック内の他のノードに移動する前に、ブロックルートのすべてのインタフェースを処理しなければなりません耳の方向が予め定められています。したがって、ブロックが既に計算耳を持ち、我々はブロックルートのインタフェースを処理しているときはいつでも、我々は耳を計算SPFを実行する前に、使用不可能としてブロックルートをマークします。これは、SPFは、ブロックルート以外のいくつかのノードで終端することを保証します。これはブロックルートが正しくGADAG上の次のホップを計算する必要がある各ブロックにおける唯一の着信インターフェイスを有していることを保証します。"
    },
    {
      "indent": 3,
      "text": "As in the SPF GADAG, bridge ears are handled as a special case.",
      "ja": "SPF GADAGのように、ブリッジ耳は特殊なケースとして扱われます。"
    },
    {
      "indent": 3,
      "text": "The entire algorithm is shown below in Figure 34.",
      "ja": "全体のアルゴリズムは、図34において以下に示されています。"
    },
    {
      "indent": 6,
      "text": "find_spf_stack_ear(stack, x, y, xy_intf, block_root) if L(y) == D(y) // Special case for cut-links xy_intf.UNDIRECTED = false xy_intf.remote_intf.UNDIRECTED = false xy_intf.OUTGOING = true xy_intf.INCOMING = true xy_intf.remote_intf.OUTGOING = true xy_intf.remote_intf.INCOMING = true xy_intf.remote_node.IN_GADAG = true push y onto stack return else if (y.local_root == x) && check_if_block_has_ear(x,y.block_id) //Avoid the block root during the SPF Mark x as TEMP_UNUSABLE end_ear = SPF_for_Ear(x,y,block_root,hybrid) If x was set as TEMP_UNUSABLE, clear it cur = end_ear while (cur != y) intf = cur.spf_prev_hop prev = intf.local_node intf.UNDIRECTED = false intf.remote_intf.UNDIRECTED = false intf.OUTGOING = true intf.remote_intf.INCOMING = true push prev onto stack cur = prev xy_intf.UNDIRECTED = false xy_intf.remote_intf.UNDIRECTED = false xy_intf.OUTGOING = true xy_intf.remote_intf.INCOMING = true return",
      "ja": "find_spf_stack_ear（スタック、X、Y、xy_intf、block_root）L（Y）であれば== D（Y）// xy_intf.UNDIRECTED =偽xy_intf.remote_intf.UNDIRECTED =偽xy_intf.OUTGOING =真xy_intfカットリンクのための特別な場合。 （y.local_rootは== x）は&& check_if_block_has_ear（X、y.block_id）場合スタックにINCOMING =真xy_intf.remote_intf.OUTGOING =真xy_intf.remote_intf.INCOMING =真xy_intf.remote_node.IN_GADAG =真のプッシュyは他に返す// SPFマークTEMP_UNUSABLE end_ear = SPF_for_Ear（X、Y、block_root、ハイブリッド）xはTEMP_UNUSABLEとして設定されていた場合、明確なそれCUR = end_earしばらく（CUR！= y）はINTF = cur.spf_prev_hop前= INTFように、X中にブロックのルートを避けます.local_node intf.UNDIRECTED = falseをintf.remote_intf.UNDIRECTED =スタックに偽intf.OUTGOING =真intf.remote_intf.INCOMING =真のプッシュ前CUR =前xy_intf.UNDIRECTED = falseをxy_intf.remote_intf.UNDIRECTED = falseをxy_intf.OUTGOING =真xy_intf.remote_intf.INCOMING =真のリターン"
    },
    {
      "indent": 6,
      "text": "Construct_GADAG_via_hybrid(topology,root) Compute_Localroot (root,root) Assign_Block_ID(root,0) root.IN_GADAG = true Initialize Stack to empty push root onto Stack while (Stack is not empty) x = pop(Stack) for each interface intf of x y = intf.remote_node if y.IN_GADAG is false find_spf_stack_ear(stack, x, y, intf, y.block_root)",
      "ja": "Construct_GADAG_via_hybrid（トポロジー、根）Compute_Localroot（根、根）Assign_Block_ID（根、0）root.IN_GADAG = TRUE初期化スタック（スタックが空ではない）、X = POP（スタック）しながら、XYのINTF各インタフェースのスタック上にプッシュルートを空に= intf.remote_node y.IN_GADAGが偽find_spf_stack_earある場合（スタック、X、Y、INTF、y.block_root）"
    },
    {
      "indent": 16,
      "text": "Figure 34: Hybrid GADAG Construction Method",
      "ja": "図34：ハイブリッドGADAG工法"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "The authors would like to thank Shraddha Hegde, Eric Wu, Janos Farkas, Stewart Bryant, Alvaro Retana, and Deccan (Shaofu Peng) for their suggestions and review. We would also like to thank Anil Kumar SN for his assistance in clarifying the algorithm description and pseudocode.",
      "ja": "著者は、彼らの提案やレビューのためにShraddha Hegde、エリック・ウー、ヤーノシュ・ファーカス、スチュワートブライアント、アルバロRetana、およびデカン（Shaofu鵬）を感謝したいと思います。また、アルゴリズム記述と擬似コードを明確に彼の援助のためのアニル・クマールSNに感謝したいと思います。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Gabor Sandor Enyedi Ericsson Konyves Kalman krt 11 Budapest 1097 Hungary",
      "ja": "ガボールサンドールEnyediエリクソンKonyvesカルマンは11ブダペスト1097ハンガリーをKRT"
    },
    {
      "indent": 3,
      "text": "Email: Gabor.Sandor.Enyedi@ericsson.com",
      "ja": "メール：Gabor.Sandor.Enyedi@ericsson.com"
    },
    {
      "indent": 3,
      "text": "Andras Csaszar Ericsson Konyves Kalman krt 11 Budapest 1097 Hungary",
      "ja": "アンドラーシュCsaszarエリクソンKonyvesカルマンは11ブダペスト1097ハンガリーKRT"
    },
    {
      "indent": 3,
      "text": "Email: Andras.Csaszar@ericsson.com",
      "ja": "メール：Andras.Csaszar@ericsson.com"
    },
    {
      "indent": 3,
      "text": "Alia Atlas Juniper Networks 10 Technology Park Drive Westford, MA 01886 United States",
      "ja": "アリアアトラスジュニパーネットワークスの10テクノロジーパークドライブウェストフォード、マサチューセッツ州01886米国"
    },
    {
      "indent": 3,
      "text": "Email: akatlas@juniper.net",
      "ja": "メール：akatlas@juniper.net"
    },
    {
      "indent": 3,
      "text": "Chris Bowers Juniper Networks 1194 N. Mathilda Ave. Sunnyvale, CA 94089 United States",
      "ja": "クリス・バワーズジュニパーネットワークスの1194 N.マチルダアベニュー。サニーベール、CA 94089米国"
    },
    {
      "indent": 3,
      "text": "Email: cbowers@juniper.net",
      "ja": "メール：cbowers@juniper.net"
    },
    {
      "indent": 3,
      "text": "Abishek Gopalan University of Arizona 1230 E Speedway Blvd. Tucson, AZ 85721 United States",
      "ja": "アリゾナ1230年のAbishekゴパラン大学Eスピードウェイブルバードツーソン、AZ 85721米国"
    },
    {
      "indent": 3,
      "text": "Email: abishek@ece.arizona.edu",
      "ja": "メール：abishek@ece.arizona.edu"
    }
  ]
}