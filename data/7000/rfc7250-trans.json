{
  "title": {
    "text": "RFC 7250 - Using Raw Public Keys in Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)",
    "ja": "RFC 7250 - トランスポート層セキュリティ（TLS）およびデータグラムトランスポート層セキュリティ（DTLS）に生の公開鍵を使用して"
  },
  "number": 7250,
  "created_at": "2019-10-30 17:19:34.799760+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                   P. Wouters, Ed.\nRequest for Comments: 7250                                       Red Hat\nCategory: Standards Track                             H. Tschofenig, Ed.\nISSN: 2070-1721                                                 ARM Ltd.\n                                                              J. Gilmore\n                                          Electronic Frontier Foundation\n                                                               S. Weiler\n                                                                 Parsons\n                                                              T. Kivinen\n                                                           INSIDE Secure\n                                                               June 2014",
      "raw": true
    },
    {
      "indent": 8,
      "text": "Using Raw Public Keys in Transport Layer Security (TLS)\n      and Datagram Transport Layer Security (DTLS)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document specifies a new certificate type and two TLS extensions for exchanging raw public keys in Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS). The new certificate type allows raw public keys to be used for authentication.",
      "ja": "この文書は、新しい証明書の種類およびTransport Layer Security（TLS）およびデータグラムトランスポート層セキュリティ（DTLS）に生の公開鍵を交換するための2つのTLS拡張子を指定します。新しい証明書の種類は、生の公開鍵を認証に使用することができます。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 5741のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7250.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7250で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2014 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2014 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3\n2.  Terminology . . . . . . . . . . . . . . . . . . . . . . . . .   4\n3.  Structure of the Raw Public Key Extension . . . . . . . . . .   4\n4.  TLS Client and Server Handshake Behavior  . . . . . . . . . .   7\n  4.1.  Client Hello  . . . . . . . . . . . . . . . . . . . . . .   7\n  4.2.  Server Hello  . . . . . . . . . . . . . . . . . . . . . .   8\n  4.3.  Client Authentication . . . . . . . . . . . . . . . . . .   9\n  4.4.  Server Authentication . . . . . . . . . . . . . . . . . .   9\n5.  Examples  . . . . . . . . . . . . . . . . . . . . . . . . . .  10\n  5.1.  TLS Server Uses a Raw Public Key  . . . . . . . . . . . .  10\n  5.2.  TLS Client and Server Use Raw Public Keys . . . . . . . .  11\n  5.3.  Combined Usage of Raw Public Keys and X.509 Certificates   12\n6.  Security Considerations . . . . . . . . . . . . . . . . . . .  13\n7.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  14\n8.  Acknowledgements  . . . . . . . . . . . . . . . . . . . . . .  14\n9.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  15\n  9.1.  Normative References  . . . . . . . . . . . . . . . . . .  15\n  9.2.  Informative References  . . . . . . . . . . . . . . . . .  15\nAppendix A.  Example Encoding . . . . . . . . . . . . . . . . . .  17",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "Traditionally, TLS client and server public keys are obtained in PKIX containers in-band as part of the TLS handshake procedure and are validated using trust anchors based on a [PKIX] certification authority (CA). This method can add a complicated trust relationship that is difficult to validate. Examples of such complexity can be seen in [Defeating-SSL]. TLS is, however, also commonly used with self-signed certificates in smaller deployments where the self-signed certificates are distributed to all involved protocol endpoints out-of-band. This practice does, however, still require the overhead of the certificate generation even though none of the information found in the certificate is actually used.",
      "ja": "伝統的に、TLSクライアントとサーバの公開鍵は、TLSハンドシェイク手順の一部として、インバンドPKIX容器に得られ、[PKIX]認証局（CA）に基づくトラストアンカーを使用して検証しています。この方法では、検証することは困難である複雑な信頼関係を追加することができます。そのような複雑さの例としては、[破っ-SSL]に見ることができます。 TLSは、しかし、また、一般的に自己署名証明書は、帯域外の関連するすべてのプロトコルエンドポイントに配布される小さな展開で自己署名証明書で使用されます。このような行為は、しかし、まだ証明書にある情報のどれも実際に使用されていないにもかかわらず、証明書の生成のオーバーヘッドを必要としません。"
    },
    {
      "indent": 3,
      "text": "Alternative methods are available that allow a TLS client/server to obtain the TLS server/client public key:",
      "ja": "代替方法は、TLSクライアント/サーバはTLSサーバ/クライアントの公開鍵を入手することができますが利用可能です："
    },
    {
      "indent": 3,
      "text": "o The TLS client can obtain the TLS server public key from a DNSSEC-secured resource record using DNS-Based Authentication of Named Entities (DANE) [RFC6698].",
      "ja": "O TLSクライアントは、名前付きエンティティ（DANE）[RFC6698]のDNSベースの認証を使用して、DNSSECで保護されたリソースレコードからTLSサーバの公開鍵を取得することができます。"
    },
    {
      "indent": 3,
      "text": "o The TLS client or server public key is obtained from a [PKIX] certificate chain from a Lightweight Directory Access Protocol [LDAP] server or web page.",
      "ja": "O TLSクライアントまたはサーバの公開鍵は、ライトウェイトディレクトリアクセスプロトコル[LDAP]サーバーやWebページから[PKIX]証明書チェーンから取得されます。"
    },
    {
      "indent": 3,
      "text": "o The TLS client and server public key is provisioned into the operating system firmware image and updated via software updates. For example:",
      "ja": "O TLSクライアントとサーバの公開鍵は、オペレーティング・システム・ファームウェア・イメージにプロビジョニングおよびソフトウェアアップデート経由で更新されます。例えば："
    },
    {
      "indent": 6,
      "text": "Some smart objects use the UDP-based Constrained Application Protocol [CoAP] to interact with a Web server to upload sensor data at regular intervals, such as temperature readings. CoAP can utilize DTLS for securing the client-to-server communication. As part of the manufacturing process, the embedded device may be configured with the address and the public key of a dedicated CoAP server, as well as a public/private key pair for the client itself.",
      "ja": "いくつかのスマートオブジェクトには、このような温度の読み取りなどの定期的な間隔でセンサデータをアップロードするには、Webサーバーと対話する[CoAP] UDPベースの制約アプリケーションプロトコルを使用します。 CoAPは、クライアントからサーバーへの通信を確保するためのDTLSを利用することができます。製造プロセスの一部として、埋め込み装置は、アドレスと専用CoAPサーバの公開鍵、ならびにクライアント自体の公開鍵/秘密鍵のペアで構成されてもよいです。"
    },
    {
      "indent": 3,
      "text": "This document introduces the use of raw public keys in TLS/DTLS. With raw public keys, only a subset of the information found in typical certificates is utilized: namely, the SubjectPublicKeyInfo structure of a PKIX certificate that carries the parameters necessary to describe the public key. Other parameters found in PKIX certificates are omitted. By omitting various certificate-related structures, the resulting raw public key is kept fairly small in comparison to the original certificate, and the code to process the keys can be simpler. Only a minimalistic ASN.1 parser is needed; code for certificate path validation and other PKIX-related processing is not required. Note, however, the SubjectPublicKeyInfo structure is still in an ASN.1 format. To further reduce the size of the exchanged information, this specification can be combined with the TLS Cached Info extension [CACHED-INFO], which enables TLS peers to exchange just fingerprints of their public keys.",
      "ja": "このドキュメントは、TLS / DTLSで生の公開鍵の使用を紹介します。生の公開鍵を用いて、一般的な証明書にある情報のサブセットのみが使用される：すなわち、必要なパラメータを運ぶPKIX証明書のSubjectPublicKeyInfoで構造が公開鍵を記述します。 PKIX証明書で見つかった他のパラメータは省略されています。各種証明書に関連する構造を省略することによって、得られた生の公開鍵は、元の証明書と比較してかなり小さく保たれ、キーを処理するコードが単純であることができます。のみ最小限のASN.1パーサーが必要とされています。証明書パスの検証および他のPKIX関連処理のためのコードが必要とされません。注意は、しかし、SubjectPublicKeyInfoで構造は、ASN.1形式のままです。さらに、交換される情報のサイズを小さくするために、本明細書は、その公開鍵の指紋だけを交換するためにTLSピアを可能TLSキャッシュ情報延長[CACHED-INFO]、と組み合わせることができます。"
    },
    {
      "indent": 3,
      "text": "The mechanism defined herein only provides authentication when an out-of-band mechanism is also used to bind the public key to the entity presenting the key.",
      "ja": "アウトオブバンドメカニズムは、キーを提示するエンティティに公開鍵をバインドするために使用される場合、本明細書に定義されたメカニズムは、認証を提供します。"
    },
    {
      "indent": 3,
      "text": "Section 3 defines the structure of the two new TLS extensions, client_certificate_type and server_certificate_type, which can be used as part of an extended TLS handshake when raw public keys are to be used. Section 4 defines the behavior of the TLS client and the TLS server. Example exchanges are described in Section 5. Section 6 describes security considerations with this approach. Finally, in Section 7 this document registers a new value to the IANA \"TLS Certificate Types\" subregistry for the support of raw public keys.",
      "ja": "セクション3は、生の公開鍵が使用されるとき、拡張TLSハンドシェイクの一部として使用することができる2つの新たなTLS拡張子、client_certificate_typeとserver_certificate_type、の構造を定義します。第4節では、TLSクライアントおよびTLSサーバの動作を定義します。例の交換は第6節は、このアプローチにセキュリティ上の考慮事項について説明し、セクション5で説明されています。最後に、第7節では、この文書では、生の公開鍵の支援のためのIANA「TLS証明書の種類」副登録に新しい値を登録します。"
    },
    {
      "indent": 0,
      "text": "2. Terminology",
      "section_title": true,
      "ja": "2.用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [RFC2119].",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はRFC 2119 [RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 3,
      "text": "We use the terms \"TLS server\" and \"server\" as well as \"TLS client\" and \"client\" interchangeably.",
      "ja": "我々は、交換可能に、「TLSサーバ」と「サーバ」や「TLSクライアント」と「クライアント」という用語を使用します。"
    },
    {
      "indent": 0,
      "text": "3. Structure of the Raw Public Key Extension",
      "section_title": true,
      "ja": "生の公開鍵拡張の3構造"
    },
    {
      "indent": 3,
      "text": "This section defines the two TLS extensions client_certificate_type and server_certificate_type, which can be used as part of an extended TLS handshake when raw public keys are used. Section 4 defines the behavior of the TLS client and the TLS server using these extensions.",
      "ja": "このセクションでは、生の公開鍵が使用されるとき、拡張TLSハンドシェイクの一部として使用することができる2つのTLS拡張client_certificate_typeとserver_certificate_typeを定義します。第4節では、TLSクライアントとこれらの拡張機能を使用してTLSサーバの動作を定義します。"
    },
    {
      "indent": 3,
      "text": "This specification uses raw public keys whereby the already available encoding used in a PKIX certificate in the form of a SubjectPublicKeyInfo structure is reused. To carry the raw public key within the TLS handshake, the Certificate payload is used as a container, as shown in Figure 1. The shown Certificate structure is an adaptation of its original form [RFC5246].",
      "ja": "この仕様はSubjectPublicKeyInfoで構造の形でPKIX証明書に使用される既に利用可能な符号化が再利用される生の公開鍵を使用します。 TLSハンドシェイク内生の公開鍵を運ぶために、証明書ペイロードを容器として使用され、図1に示すように示される証明書の構造は、元の形式[RFC5246]の適応です。"
    },
    {
      "indent": 3,
      "text": "opaque ASN.1Cert<1..2^24-1>;",
      "ja": "不透明ASN.1Cert <1..2 ^ 24-1>;"
    },
    {
      "indent": 3,
      "text": "struct {\n    select(certificate_type){",
      "raw": true
    },
    {
      "indent": 12,
      "text": "// certificate type defined in this document.\ncase RawPublicKey:\n  opaque ASN.1_subjectPublicKeyInfo<1..2^24-1>;",
      "raw": true
    },
    {
      "indent": 11,
      "text": "// X.509 certificate defined in RFC 5246 case X.509: ASN.1Cert certificate_list<0..2^24-1>;",
      "ja": "RFC 5246の場合のX.509で定義されている// X.509証明書：ASN.1Cert certificate_list <0..2 ^ 24-1>;"
    },
    {
      "indent": 3,
      "text": "        // Additional certificate type based on\n        // \"TLS Certificate Types\" subregistry\n    };\n} Certificate;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "Figure 1: Certificate Payload as a Container for the Raw Public Key",
      "ja": "図1：生公開鍵のコンテナとしての証明書ペイロード"
    },
    {
      "indent": 3,
      "text": "The SubjectPublicKeyInfo structure is defined in Section 4.1 of RFC 5280 [PKIX] and not only contains the raw keys, such as the public exponent and the modulus of an RSA public key, but also an algorithm identifier. The algorithm identifier can also include parameters. The SubjectPublicKeyInfo value in the Certificate payload MUST contain the DER encoding [X.690] of the SubjectPublicKeyInfo. The structure, as shown in Figure 2, therefore also contains length information. An example is provided in Appendix A.",
      "ja": "SubjectPublicKeyInfoで構造が[PKIX] RFC 5280のセクション4.1で定義されるだけでなく、このような公開指数とRSA公開鍵だけでなく、アルゴリズム識別子の弾性率として生キーが含まれています。アルゴリズム識別子は、パラメータをも含めることができます。証明書ペイロードにSubjectPublicKeyInfoで値[X.690] SubjectPublicKeyInfoでのDER符号化を含まなければなりません。構造は、図2に示すように、したがって、長さ情報を含みます。例は、付録Aで提供されています"
    },
    {
      "indent": 6,
      "text": "SubjectPublicKeyInfo  ::=  SEQUENCE  {\n     algorithm               AlgorithmIdentifier,\n     subjectPublicKey        BIT STRING  }",
      "raw": true
    },
    {
      "indent": 6,
      "text": "AlgorithmIdentifier   ::=  SEQUENCE  {\n     algorithm               OBJECT IDENTIFIER,\n     parameters              ANY DEFINED BY algorithm OPTIONAL  }",
      "raw": true
    },
    {
      "indent": 14,
      "text": "Figure 2: SubjectPublicKeyInfo ASN.1 Structure",
      "ja": "図2：SubjectPublicKeyInfoでASN.1構造"
    },
    {
      "indent": 3,
      "text": "The algorithm identifiers are Object Identifiers (OIDs). RFC 3279 [RFC3279] and RFC 5480 [RFC5480], for example, define the OIDs shown in Figure 3. Note that this list is not exhaustive, and more OIDs may be defined in future RFCs.",
      "ja": "アルゴリズム識別子は、オブジェクト識別子（OID）です。 RFC 3279 [RFC3279]及びRFC 5480 [RFC5480]は、例えば、このリストは網羅的ではないことを図3（注）に示すOIDを定義し、複数のOIDは、将来のRFCに定義されてもよいです。"
    },
    {
      "indent": 3,
      "text": "Key Type            | Document                   | OID\n--------------------+----------------------------+-------------------\nRSA                 | Section 2.3.1 of RFC 3279  | 1.2.840.113549.1.1\n....................|............................|...................\nDigital Signature   |                            |\nAlgorithm (DSA)     | Section 2.3.2 of RFC 3279  | 1.2.840.10040.4.1\n....................|............................|...................\nElliptic Curve      |                            |\nDigital Signature   |                            |\nAlgorithm (ECDSA)   | Section 2 of RFC 5480      | 1.2.840.10045.2.1\n--------------------+----------------------------+-------------------",
      "raw": true
    },
    {
      "indent": 14,
      "text": "Figure 3: Example Algorithm Object Identifiers",
      "ja": "図3の例のアルゴリズムのオブジェクト識別子"
    },
    {
      "indent": 3,
      "text": "The extension format for extended client and server hellos, which uses the \"extension_data\" field, is used to carry the ClientCertTypeExtension and the ServerCertTypeExtension structures. These two structures are shown in Figure 4. The CertificateType structure is an enum with values taken from the \"TLS Certificate Types\" subregistry of the \"Transport Layer Security (TLS) Extensions\" registry [TLS-Ext-Registry].",
      "ja": "「拡大」フィールドを使用して拡張されたクライアントとサーバのhelloパケットの拡張フォーマットは、ClientCertTypeExtensionとServerCertTypeExtension構造を運ぶために使用されます。これら2つの構造がCertificateType構造は、「トランスポート層セキュリティ（TLS）拡張機能」レジストリ[TLS-EXT-レジストリ]の「TLS証明書の種類」副登録から取られた値を持つ列挙型である図4に示されています。"
    },
    {
      "indent": 3,
      "text": "struct {\n        select(ClientOrServerExtension) {\n            case client:\n              CertificateType client_certificate_types<1..2^8-1>;\n            case server:\n              CertificateType client_certificate_type;\n        }\n} ClientCertTypeExtension;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct {\n        select(ClientOrServerExtension) {\n            case client:\n              CertificateType server_certificate_types<1..2^8-1>;\n            case server:\n              CertificateType server_certificate_type;\n        }\n} ServerCertTypeExtension;",
      "raw": true
    },
    {
      "indent": 19,
      "text": "Figure 4: CertTypeExtension Structure",
      "ja": "図4：CertTypeExtension構造"
    },
    {
      "indent": 0,
      "text": "4. TLS Client and Server Handshake Behavior",
      "section_title": true,
      "ja": "4. TLSクライアントとサーバーのハンドシェイクの動作"
    },
    {
      "indent": 3,
      "text": "This specification extends the ClientHello and the ServerHello messages, according to the extension procedures defined in [RFC5246]. It does not extend or modify any other TLS message.",
      "ja": "この仕様は、[RFC5246]で定義された拡張手順に従って、のClientHelloとのServerHelloメッセージを拡張します。これは、他のTLSメッセージを拡張または変更されません。"
    },
    {
      "indent": 3,
      "text": "Note: No new cipher suites are required to use raw public keys. All existing cipher suites that support a key exchange method compatible with the defined extension can be used.",
      "ja": "注：新しい暗号スイートは、生の公開鍵を使用する必要はありません。定義された拡張子と互換性のある鍵交換方式をサポートするすべての既存の暗号スイートを使用することができます。"
    },
    {
      "indent": 3,
      "text": "The high-level message exchange in Figure 5 shows the client_certificate_type and server_certificate_type extensions added to the client and server hello messages.",
      "ja": "図5の高レベルのメッセージ交換は、クライアントとサーバハローメッセージに追加client_certificate_typeとserver_certificate_type拡張を示しています。"
    },
    {
      "indent": 4,
      "text": "client_hello, client_certificate_type, server_certificate_type ->",
      "ja": "CLIENT_HELLO、client_certificate_type、server_certificate_type  - >"
    },
    {
      "indent": 4,
      "text": " <- server_hello, client_certificate_type, server_certificate_type, certificate, server_key_exchange, certificate_request, server_hello_done certificate, client_key_exchange, certificate_verify, change_cipher_spec, finished ->",
      "ja": "< -  server_hello、client_certificate_type、server_certificate_type、証明書、server_key_exchange、証明書要求、server_hello_done証明書、client_key_exchange、certificate_verify、change_cipher_spec、終了 - >"
    },
    {
      "indent": 30,
      "text": "<- change_cipher_spec,\n   finished",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Application Data        <------->     Application Data",
      "raw": true
    },
    {
      "indent": 16,
      "text": "Figure 5: Basic Raw Public Key TLS Exchange",
      "ja": "図5：基本的な生の公開鍵TLS交換"
    },
    {
      "indent": 0,
      "text": "4.1. Client Hello",
      "section_title": true,
      "ja": "4.1。クライアントこんにちは"
    },
    {
      "indent": 3,
      "text": "In order to indicate the support of raw public keys, clients include the client_certificate_type and/or the server_certificate_type extensions in an extended client hello message. The hello extension mechanism is described in Section 7.4.1.4 of TLS 1.2 [RFC5246].",
      "ja": "生の公開鍵のサポートを示すために、クライアントはclient_certificate_typeおよび/または拡張されたクライアントハローメッセージでserver_certificate_typeの拡張が含まれています。ハロー拡張機構は、TLS 1.2 [RFC5246]のセクション7.4.1.4に記載されています。"
    },
    {
      "indent": 3,
      "text": "The client_certificate_type extension in the client hello indicates the certificate types the client is able to provide to the server, when requested using a certificate_request message.",
      "ja": "証明書要求メッセージを使用して、要求されたときにクライアントのハローでclient_certificate_type拡張機能は、クライアントがサーバに提供することができる証明書の種類を示します。"
    },
    {
      "indent": 3,
      "text": "The server_certificate_type extension in the client hello indicates the types of certificates the client is able to process when provided by the server in a subsequent certificate payload.",
      "ja": "クライアントハローにおけるserver_certificate_type拡張は、後続の証明書ペイロードにサーバによって提供されるとき、クライアントが処理することができる証明書の種類を示しています。"
    },
    {
      "indent": 3,
      "text": "The client_certificate_type and server_certificate_type extensions sent in the client hello each carry a list of supported certificate types, sorted by client preference. When the client supports only one certificate type, it is a list containing a single element.",
      "ja": "各こんにちはクライアントに送信されclient_certificate_typeとserver_certificate_typeの拡張機能はクライアントの好みの順で並べサポート証明書の種類のリストを運びます。クライアントが一つだけの証明書の種類をサポートしている場合、それは単一の要素を含むリストです。"
    },
    {
      "indent": 3,
      "text": "The TLS client MUST omit certificate types from the client_certificate_type extension in the client hello if it does not possess the corresponding raw public key or certificate that it can provide to the server when requested using a certificate_request message, or if it is not configured to use one with the given TLS server. If the client has no remaining certificate types to send in the client hello, other than the default X.509 type, it MUST omit the client_certificate_type extension in the client hello.",
      "ja": "それが証明書要求メッセージを使用して要求されたとき、それがサーバーに提供できることを、対応する生の公開鍵や証明書を持たない場合、または1つを使用するように設定されていない場合、TLSクライアントはこんにちは、クライアントにclient_certificate_type拡張から証明書の種類を省略しなければなりません与えられたTLSサーバと。クライアントは、デフォルトのX.509タイプ以外のクライアントこんにちは、に送るべき残りの証明書の種類を持っていない場合は、クライアントハローにclient_certificate_typeの拡張子を省略しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The TLS client MUST omit certificate types from the server_certificate_type extension in the client hello if it is unable to process the corresponding raw public key or other certificate type. If the client has no remaining certificate types to send in the client hello, other than the default X.509 certificate type, it MUST omit the entire server_certificate_type extension from the client hello.",
      "ja": "TLSクライアントは、対応する生公開鍵またはその他の証明書の種類を処理できない場合こんにちはクライアントでserver_certificate_type拡張子から証明書の種類を省略しなければなりません。クライアントは、デフォルトのX.509証明書の種類以外に、ハロークライアントに送信するために残っ証明書の種類を持っていない場合は、クライアントハローから全体server_certificate_typeの拡張子を省略しなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.2. Server Hello",
      "section_title": true,
      "ja": "4.2。サーバーこんにちは"
    },
    {
      "indent": 3,
      "text": "If the server receives a client hello that contains the client_certificate_type extension and/or the server_certificate_type extension, then three outcomes are possible:",
      "ja": "サーバがclient_certificate_typeエクステンションおよび/またはserver_certificate_type拡張を含むクライアントのhelloを受信した場合、その後、3つの結果が考えられます。"
    },
    {
      "indent": 3,
      "text": "1. The server does not support the extension defined in this document. In this case, the server returns the server hello without the extensions defined in this document.",
      "ja": "1.サーバーは、この文書で定義された拡張をサポートしていません。この場合、サーバは、この文書で定義されている拡張せずにサーバーのハローを返します。"
    },
    {
      "indent": 3,
      "text": "2. The server supports the extension defined in this document, but it does not have any certificate type in common with the client. Then, the server terminates the session with a fatal alert of type \"unsupported_certificate\".",
      "ja": "2.サーバーは、この文書で定義された拡張をサポートしていますが、それは、クライアントと共通のすべての証明書の種類を持っていません。その後、サーバは「unsupported_certificate」タイプの致命的な警告とのセッションを終了します。"
    },
    {
      "indent": 3,
      "text": "3. The server supports the extensions defined in this document and has at least one certificate type in common with the client. In this case, the processing rules described below are followed.",
      "ja": "3.サーバーは、この文書で定義された拡張をサポートし、クライアントとの少なくとも1つの共通の証明書のタイプがあります。この場合、以下の処理規則に従います。"
    },
    {
      "indent": 3,
      "text": "The client_certificate_type extension in the client hello indicates the certificate types the client is able to provide to the server, when requested using a certificate_request message. If the TLS server wants to request a certificate from the client (via the certificate_request message), it MUST include the client_certificate_type extension in the server hello. This client_certificate_type extension in the server hello then indicates the type of certificates the client is requested to provide in a subsequent certificate payload. The value conveyed in the client_certificate_type extension MUST be selected from one of the values provided in the client_certificate_type extension sent in the client hello. The server MUST also include a certificate_request payload in the server hello message.",
      "ja": "証明書要求メッセージを使用して、要求されたときにクライアントのハローでclient_certificate_type拡張機能は、クライアントがサーバに提供することができる証明書の種類を示します。 TLSサーバは、（証明書要求メッセージを介して）クライアントからの証明書を要求したい場合は、サーバーでclient_certificate_typeの拡張子を含める必要がありますこんにちは。サーバーでこのclient_certificate_type拡張子はハローその後、クライアントは、後続の証明書ペイロードに提供するために、要求された証明書の種類を示します。 client_certificate_type拡張で搬送される値は、クライアントハローで送信client_certificate_type拡張で提供される値のいずれかから選択しなければなりません。また、サーバは、サーバハローメッセージで証明書要求ペイロードを含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the server does not send a certificate_request payload (for example, because client authentication happens at the application layer or no client authentication is required) or none of the certificates supported by the client (as indicated in the client_certificate_type extension in the client hello) match the server-supported certificate types, then the client_certificate_type payload in the server hello MUST be omitted.",
      "ja": "サーバは、証明書要求のペイロード（例えば、クライアント認証は、アプリケーション層で行わまたは全くクライアント認証が必要とされないため）、またはクライアントによってサポートされている証明書のどれも（クライアントにclient_certificate_type拡張に示されるように、ハロー）一致を送信しない場合サーバーがサポートする証明書の種類、サーバーのハローでclient_certificate_typeペイロードは省略しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The server_certificate_type extension in the client hello indicates the types of certificates the client is able to process when provided by the server in a subsequent certificate payload. If the client hello indicates support of raw public keys in the server_certificate_type extension and the server chooses to use raw public keys, then the TLS server MUST place the SubjectPublicKeyInfo structure into the Certificate payload. With the server_certificate_type extension in the server hello, the TLS server indicates the certificate type carried in the Certificate payload. This additional indication enables avoiding parsing ambiguities since the Certificate payload may contain either the X.509 certificate or a SubjectPublicKeyInfo structure. Note that only a single value is permitted in the server_certificate_type extension when carried in the server hello.",
      "ja": "クライアントハローにおけるserver_certificate_type拡張は、後続の証明書ペイロードにサーバによって提供されるとき、クライアントが処理することができる証明書の種類を示しています。クライアントハローがserver_certificate_type延長での生公開鍵のサポートを示すと、サーバは、生の公開鍵を使用することを選択した場合は、TLSサーバは、証明書ペイロードにSubjectPublicKeyInfoで構造を置かなければなりません。サーバーハローでserver_certificate_type拡張子を持つ、TLSサーバは、証明書ペイロードで運ばれた証明書の種類を示します。この追加表示は、証明書ペイロードは、X.509証明書またはSubjectPublicKeyInfoでの構造のいずれかを含む可能性があるので解析する曖昧さを避けることができます。サーバハローで運ばれたときにのみ、単一の値をserver_certificate_type拡張で許可されていることに注意してください。"
    },
    {
      "indent": 0,
      "text": "4.3. Client Authentication",
      "section_title": true,
      "ja": "4.3。クライアント認証"
    },
    {
      "indent": 3,
      "text": "When the TLS server has specified RawPublicKey as the client_certificate_type, authentication of the TLS client to the TLS server is supported only through authentication of the received client SubjectPublicKeyInfo via an out-of-band method.",
      "ja": "TLSサーバはclient_certificate_typeとしてRawPublicKeyを指定した場合、TLSサーバーへTLSクライアントの認証は、アウトオブバンド方式を介してのみ受信したクライアントSubjectPublicKeyInfoでの認証を介して支持されています。"
    },
    {
      "indent": 0,
      "text": "4.4. Server Authentication",
      "section_title": true,
      "ja": "4.4。サーバー認証"
    },
    {
      "indent": 3,
      "text": "When the TLS server has specified RawPublicKey as the server_certificate_type, authentication of the TLS server to the TLS client is supported only through authentication of the received client SubjectPublicKeyInfo via an out-of-band method.",
      "ja": "TLSサーバはserver_certificate_typeとしてRawPublicKeyを指定した場合、TLSクライアントにTLSサーバーの認証のみアウトオブバンド方式を介して受信したクライアントSubjectPublicKeyInfoでの認証を介して支持されています。"
    },
    {
      "indent": 0,
      "text": "5. Examples",
      "section_title": true,
      "ja": "5.例"
    },
    {
      "indent": 3,
      "text": "Figures 6, 7, and 8 illustrate example exchanges. Note that TLS ciphersuites using a Diffie-Hellman exchange offering forward secrecy can be used with a raw public key, although this document does not show the information exchange at that level with the subsequent message flows.",
      "ja": "図6、図7、図8は、例示的交換を示す図です。後続のメッセージが流れると、この文書は、そのレベルでの情報交換を示していないが、前方機密性を提供するのDiffie-Hellman交換を使用して、TLSの暗号スイートは、生の公開鍵と一緒に使用することができることに留意されたいです。"
    },
    {
      "indent": 0,
      "text": "5.1. TLS Server Uses a Raw Public Key",
      "section_title": true,
      "ja": "5.1。 TLSサーバは、生の公開鍵を使用します"
    },
    {
      "indent": 3,
      "text": "This section shows an example where the TLS client indicates its ability to receive and validate a raw public key from the server. In this example, the client is quite restricted since it is unable to process other certificate types sent by the server. It also does not have credentials at the TLS layer it could send to the server and therefore omits the client_certificate_type extension. Hence, the client only populates the server_certificate_type extension with the raw public key type, as shown in (1).",
      "ja": "このセクションでは、TLSクライアントがサーバからの生の公開鍵を受け取り、検証するその能力を示す一例を示しています。サーバーから送信された他の証明書タイプを処理することができないので、この例では、クライアントがかなり制限されています。それはまた、サーバーに送ることができTLS層での資格情報を持っていないので、client_certificate_type拡張子を省略します。 （1）に示すように、したがって、クライアントは、生公開鍵タイプserver_certificate_type拡張子を移入します。"
    },
    {
      "indent": 3,
      "text": "When the TLS server receives the client hello, it processes the extension. Since it has a raw public key, it indicates in (2) that it had chosen to place the SubjectPublicKeyInfo structure into the Certificate payload (3).",
      "ja": "TLSサーバがクライアントのhelloを受信すると、拡張子を処理します。それは生の公開鍵を持っているので、それが証明書ペイロード（3）にSubjectPublicKeyInfoで構造を配置することを選択したこと（2）に示します。"
    },
    {
      "indent": 3,
      "text": "The client uses this raw public key in the TLS handshake together with an out-of-band validation technique, such as DANE, to verify it.",
      "ja": "クライアントは、それを確認するために、このようDANEなどのアウトオブバンドの検証技術、一緒にTLSハンドシェイク中にこの生の公開鍵を使用しています。"
    },
    {
      "indent": 2,
      "text": "client_hello, server_certificate_type=(RawPublicKey) // (1) -> <- server_hello, server_certificate_type=RawPublicKey, // (2) certificate, // (3) server_key_exchange, server_hello_done",
      "ja": "CLIENT_HELLO、server_certificate_type =（RawPublicKey）//（1） - > < -  server_hello、server_certificate_type = RawPublicKey、//（2）証明書、//（3）server_key_exchange、server_hello_done"
    },
    {
      "indent": 2,
      "text": "client_key_exchange, change_cipher_spec, finished ->",
      "ja": "client_key_exchange、change_cipher_spec、終了 - >"
    },
    {
      "indent": 25,
      "text": "<- change_cipher_spec,\n   finished",
      "raw": true
    },
    {
      "indent": 2,
      "text": "Application Data       <-------> Application Data",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Figure 6: Example with Raw Public Key Provided by the TLS Server",
      "ja": "図6：TLSサーバが提供する生の公開鍵による例"
    },
    {
      "indent": 0,
      "text": "5.2. TLS Client and Server Use Raw Public Keys",
      "section_title": true,
      "ja": "5.2。 TLSクライアントとサーバの使用生の公開鍵"
    },
    {
      "indent": 3,
      "text": "This section shows an example where the TLS client as well as the TLS server use raw public keys. This is one of the use cases envisioned for smart object networking. The TLS client in this case is an embedded device that is configured with a raw public key for use with TLS and is also able to process a raw public key sent by the server. Therefore, it indicates these capabilities in (1). As in the previously shown example, the server fulfills the client's request, indicates this via the RawPublicKey value in the server_certificate_type payload (2), and provides a raw public key in the Certificate payload back to the client (see (3)). The TLS server demands client authentication, and therefore includes a certificate_request (4). The client_certificate_type payload in (5) indicates that the TLS server accepts a raw public key. The TLS client, which has a raw public key pre-provisioned, returns it in the Certificate payload (6) to the server.",
      "ja": "このセクションでは、TLSクライアントだけでなく、TLSサーバは、生の公開鍵を使用する例を示します。これは、スマートオブジェクトネットワーキングに想定されるユースケースの一つです。この場合のTLSクライアントはTLSで使用するための生公開鍵で構成され、サーバによって送信された生の公開鍵を処理することができるされている組み込み機器です。したがって、（1）にこれらの機能を示しています。先に示した例のように、サーバは、クライアントの要求を満たすserver_certificate_typeペイロード（2）でRawPublicKey値を介してこれを示しており、クライアントに証明書ペイロード内生公開鍵を提供する（（3）参照）。 TLSサーバーがクライアント認証を要求するため、証明書要求（4）を備えます。 （5）におけるclient_certificate_typeペイロードは、TLSサーバは、生の公開鍵を受け入れることを示しています。事前にプロビジョニングされた生の公開鍵を持っているTLSクライアントは、サーバに証明書ペイロード（6）で返します。"
    },
    {
      "indent": 0,
      "text": "client_hello, client_certificate_type=(RawPublicKey) // (1) server_certificate_type=(RawPublicKey) // (1) -> <- server_hello, server_certificate_type=RawPublicKey // (2) certificate, // (3) client_certificate_type=RawPublicKey // (5) certificate_request, // (4) server_key_exchange, server_hello_done",
      "ja": "CLIENT_HELLO、client_certificate_type =（RawPublicKey）//（1）server_certificate_type =（RawPublicKey）//（1） - > < -  server_hello、server_certificate_type = RawPublicKey //（2）証明書、//（3）client_certificate_type = RawPublicKey //（5 ）証明書要求、//（4）server_key_exchange、server_hello_done"
    },
    {
      "indent": 0,
      "text": "certificate, // (6) client_key_exchange, change_cipher_spec, finished ->",
      "ja": "証明書、//（6）client_key_exchange、change_cipher_spec、終了 - >"
    },
    {
      "indent": 25,
      "text": "<- change_cipher_spec,\n   finished",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Application Data        <------->     Application Data",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Figure 7: Example with Raw Public Key provided by the TLS Server and the Client",
      "ja": "図7：TLSサーバとクライアントが提供する生の公開鍵による例"
    },
    {
      "indent": 0,
      "text": "5.3. Combined Usage of Raw Public Keys and X.509 Certificates",
      "section_title": true,
      "ja": "5.3。生の公開鍵とX.509証明書の使用合計"
    },
    {
      "indent": 3,
      "text": "This section shows an example combining a raw public key and an X.509 certificate. The client uses a raw public key for client authentication, and the server provides an X.509 certificate. This exchange starts with the client indicating its ability to process an X.509 certificate, OpenPGP certificate, or a raw public key, if provided by the server. It prefers a raw public key, since the RawPublicKey value precedes the other values in the server_certificate_type vector. Additionally, the client indicates that it has a raw public key for client-side authentication (see (1)). The server chooses to provide its X.509 certificate in (3) and indicates that choice in (2). For client authentication, the server indicates in (4) that it has selected the raw public key format and requests a certificate from the client in (5). The TLS client provides a raw public key in (6) after receiving and processing the TLS server hello message.",
      "ja": "このセクションでは、生の公開鍵とX.509証明書を組み合わせた例を示しています。クライアントは、クライアント認証のための生の公開鍵を使用し、サーバがX.509証明書を提供します。この交換は、サーバによって提供されている場合、クライアントは、X.509証明書、OpenPGPの証明書、または生の公開鍵を処理する能力を示すことから始まります。 RawPublicKey値がserver_certificate_typeベクトルで他の値を先行するので、それは、生の公開鍵を好みます。さらに、クライアントは、それが（（1）参照）は、クライアント側の認証のための生の公開鍵を持っていることを示しています。サーバは、（3）そのX.509証明書を提供するために選択し、（2）にその選択を示します。クライアント認証のために、サーバは、生の公開鍵形式を選択し、（5）でクライアントからの証明書を要求していること（4）に示します。 TLSクライアントは、TLSサーバーハローメッセージを受信して​​処理した後（6）内の生公開鍵を提供します。"
    },
    {
      "indent": 0,
      "text": "client_hello, server_certificate_type=(RawPublicKey, X.509, OpenPGP) client_certificate_type=(RawPublicKey) // (1) -> <- server_hello, server_certificate_type=X.509 // (2) certificate, // (3) client_certificate_type=RawPublicKey // (4) certificate_request, // (5) server_key_exchange, server_hello_done certificate, // (6) client_key_exchange, change_cipher_spec, finished ->",
      "ja": "CLIENT_HELLO、server_certificate_type =（RawPublicKey、X.509、OpenPGPの）client_certificate_type =（RawPublicKey）//（1） - > < -  server_hello、server_certificate_type = X.509 //（2）証明書、//（3）client_certificate_type = RawPublicKey / /（4）証明書要求、//（5）server_key_exchange、server_hello_done証明書は、//（6）client_key_exchange、change_cipher_spec、終了しました - >"
    },
    {
      "indent": 26,
      "text": "<- change_cipher_spec,\n   finished",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Application Data        <------->     Application Data",
      "raw": true
    },
    {
      "indent": 19,
      "text": "Figure 8: Hybrid Certificate Example",
      "ja": "図8：ハイブリッド証明書の例"
    },
    {
      "indent": 0,
      "text": "6. Security Considerations",
      "section_title": true,
      "ja": "6.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "The transmission of raw public keys, as described in this document, provides benefits by lowering the over-the-air transmission overhead since raw public keys are naturally smaller than an entire certificate. There are also advantages from a code-size point of view for parsing and processing these keys. The cryptographic procedures for associating the public key with the possession of a private key also follows standard procedures.",
      "ja": "この文書に記載されているように、生の公開鍵の送信は、生の公開鍵が証明書全体より自然に小さいので、オーバー・ザ・エア送信オーバーヘッドを低下させることによって利点を提供します。これらのキーを解析し、処理するためのビューのコードサイズの点から利点もあります。秘密鍵の所有と公開鍵を関連付けるための暗号化の手順はまた、標準的な手順に従います。"
    },
    {
      "indent": 3,
      "text": "However, the main security challenge is how to associate the public key with a specific entity. Without a secure binding between identifier and key, the protocol will be vulnerable to man-in-the-middle attacks. This document assumes that such binding can be made out-of-band, and we list a few examples in Section 1. DANE [RFC6698] offers one such approach. In order to address these vulnerabilities, specifications that make use of the extension need to specify how the identifier and public key are bound. In addition to ensuring the binding is done out-of-band, an implementation also needs to check the status of that binding.",
      "ja": "しかし、主要なセキュリティ上の課題は、特定のエンティティと公開鍵を関連付ける方法です。識別子とキーの間の安全な結合することなく、プロトコルは、man-in-the-middle攻撃に対して脆弱になります。この文書では、このような結合は、アウト・オブ・バンドすることができ、我々は第1節DANE [RFC6698]でいくつかの例をリストすることを想定してそのようなアプローチを提供しています。これらの脆弱性に対処するために、拡張を利用する仕様は、識別子と公開鍵をバインドする方法を指定する必要があります。結合を確保することに加えて、実装はまた、その結合の状態を確認する必要がアウト・オブ・バンドで行われます。"
    },
    {
      "indent": 3,
      "text": "If public keys are obtained using DANE, these public keys are authenticated via DNSSEC. Using pre-configured keys is another out-of-band method for authenticating raw public keys. While pre-configured keys are not suitable for a generic Web-based e-commerce environment, such keys are a reasonable approach for many smart object deployments where there is a close relationship between the software running on the device and the server-side communication endpoint. Regardless of the chosen mechanism for out-of-band public key validation, an assessment of the most suitable approach has to be made prior to the start of a deployment to ensure the security of the system.",
      "ja": "公開鍵はDANEを使用して取得している場合は、これらの公開鍵は、DNSSECを介して認証されています。事前に設定キーを使用して、生の公開鍵を認証するための別のアウトオブバンド方式です。事前に設定されたキーは、一般的なWebベースの電子商取引環境には適していませんが、そのような鍵は、デバイス上で動作するソフトウェアとサーバ側の通信エンドポイントとの間には密接な関係があり、多くのスマートオブジェクトの展開のための合理的なアプローチです。かかわらず、アウトオブバンドの公開鍵検証のために選ばれたメカニズムの、最も適切なアプローチの評価は、システムのセキュリティを確保するために、展開前の開始に行われる必要があります。"
    },
    {
      "indent": 3,
      "text": "An attacker might try to influence the handshake exchange to make the parties select different certificate types than they would normally choose.",
      "ja": "攻撃者は、当事者が、彼らは通常、選ぶだろうとは異なる証明書の種類を選択するためにハンドシェイク交換に影響を与えることを試みるかもしれません。"
    },
    {
      "indent": 3,
      "text": "For this attack, an attacker must actively change one or more handshake messages. If this occurs, the client and server will compute different values for the handshake message hashes. As a result, the parties will not accept each others' Finished messages. Without the master_secret, the attacker cannot repair the Finished messages, so the attack will be discovered.",
      "ja": "この攻撃では、攻撃者が積極的に一つ以上のハンドシェイクメッセージを変更する必要があります。この問題が発生した場合、クライアントとサーバーはハンドシェイクメッセージのハッシュに異なる値を計算します。その結果、当事者はお互いのFinishedメッセージを受け付けません。攻撃が検出されますので、マスター_がなければ、攻撃者は、Finishedメッセージを修復することはできません。"
    },
    {
      "indent": 0,
      "text": "7. IANA Considerations",
      "section_title": true,
      "ja": "7. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "IANA has registered a new value in the \"TLS Certificate Types\" subregistry of the \"Transport Layer Security (TLS) Extensions\" registry [TLS-Ext-Registry], as follows:",
      "ja": "次のようにIANAは、「TLS証明書の種類」「トランスポート層セキュリティ（TLS）拡張機能」レジストリ[TLS-EXT-レジストリ]の副登録に新しい値を登録しています："
    },
    {
      "indent": 3,
      "text": "Value: 2 Description: Raw Public Key Reference: RFC 7250",
      "ja": "値：2説明：生の公開キー参照：RFC 7250"
    },
    {
      "indent": 3,
      "text": "IANA has allocated two new TLS extensions, client_certificate_type and server_certificate_type, from the \"TLS ExtensionType Values\" subregistry defined in [RFC5246]. These extensions are used in both the client hello message and the server hello message. The new extension types are used for certificate type negotiation. The values carried in these extensions are taken from the \"TLS Certificate Types\" subregistry of the \"Transport Layer Security (TLS) Extensions\" registry [TLS-Ext-Registry].",
      "ja": "IANAは[RFC5246]で定義された「TLS ExtensionType値」副登録から、二つの新しいTLS拡張、client_certificate_typeとserver_certificate_typeを割り当てました。これらの拡張機能は、クライアントのhelloメッセージとサーバハローメッセージの両方で使用されています。新しい拡張タイプは、証明書の種類のネゴシエーションに使用されています。これらの拡張機能で運ば値は、「トランスポート層セキュリティ（TLS）拡張機能」レジストリ[TLS-EXT-レジストリ]の「TLS証明書の種類」副登録から取得されます。"
    },
    {
      "indent": 0,
      "text": "8. Acknowledgements",
      "section_title": true,
      "ja": "8.謝辞"
    },
    {
      "indent": 3,
      "text": "The feedback from the TLS working group meeting at IETF 81 has substantially shaped the document, and we would like to thank the meeting participants for their input. The support for hashes of public keys has been moved to [CACHED-INFO] after the discussions at the IETF 82 meeting.",
      "ja": "IETF 81でTLSワーキンググループ会議からのフィードバックは、実質的に文書を形作っており、我々は彼らの入力のための会議の参加者に感謝したいと思います。公開鍵のハッシュのサポートは、IETF 82会議での議論の後に[CACHED-INFO]に移動しました。"
    },
    {
      "indent": 3,
      "text": "We would like to thank the following persons for their review comments: Martin Rex, Bill Frantz, Zach Shelby, Carsten Bormann, Cullen Jennings, Rene Struik, Alper Yegin, Jim Schaad, Barry Leiba, Paul Hoffman, Robert Cragie, Nikos Mavrogiannopoulos, Phil Hunt, John Bradley, Klaus Hartke, Stefan Jucker, Kovatsch Matthias, Daniel Kahn Gillmor, Peter Sylvester, Hauke Mehrtens, Alexey Melnikov, Stephen Farrell, Richard Barnes, and James Manger. Nikos Mavrogiannopoulos contributed the design for reusing the certificate type registry. Barry Leiba contributed guidance for the IANA Considerations text. Stefan Jucker, Kovatsch Matthias, and Klaus Hartke provided implementation feedback regarding the SubjectPublicKeyInfo structure.",
      "ja": "マーティン・レックス、ビル・フランツ、ザックシェルビー、カルステンボルマン、カレン・ジェニングス、ルネStruik、アルパースYegin、ジムSchaad、バリー・レイバ、ポール・ホフマン、ロバートCragie、ニコスMavrogiannopoulos、フィル：我々は彼らのレビューコメントに対して次の人に感謝したいと思いますハント、ジョン・ブラッドリー、クラウスHARTKE、ステファンJucker、Kovatschマティアス、ダニエル・カーンGillmor氏、ピーター・シルベスター、Hauke Mehrtens、アレクセイ・メルニコフ、スティーブン・ファレル、リチャード・バーンズ、そしてジェームス・マンジェ。ニコスMavrogiannopoulosは、証明書の種類レジストリを再利用するための設計に貢献しました。バリー・レイバは、IANAの考慮事項のテキストのためのガイダンスを提供しました。ステファンJucker、Kovatschマティアス、およびクラウスHARTKEはSubjectPublicKeyInfoで構造に関する実施のフィードバックを提供しました。"
    },
    {
      "indent": 3,
      "text": "Christer Holmberg provided the General Area (Gen-Art) review, Yaron Sheffer provided the Security Directorate (SecDir) review, Bert Greevenbosch provided the Applications Area Directorate review, and Linda Dunbar provided the Operations Directorate review.",
      "ja": "クリステルHolmbergのは、バートGreevenboschがエリア総局のレビューアプリケーションを提供し、ヤロン・シェイファーは、セキュリティ総局（SecDir）レビューを提供し、一般的なエリア（ジェン・アート）レビューを提供し、そしてリンダ・ダンバーは、Operations総局のレビューを提供しました。"
    },
    {
      "indent": 3,
      "text": "We would like to thank our TLS working group chairs, Eric Rescorla and Joe Salowey, for their guidance and support. Finally, we would like to thank Sean Turner, who is the responsible Security Area Director for this work, for his review comments and suggestions.",
      "ja": "私たちは、彼らの指導・支援のために、私たちのTLSワーキンググループチェア、エリックレスコラとジョーSaloweyに感謝したいと思います。最後に、我々は彼のレビューコメントや提案のために、この作品のために責任を負うセキュリティエリアディレクターであるショーン・ターナーを、感謝したいと思います。"
    },
    {
      "indent": 0,
      "text": "9. References",
      "section_title": true,
      "ja": "9.参考文献"
    },
    {
      "indent": 0,
      "text": "9.1. Normative References",
      "section_title": true,
      "ja": "9.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[PKIX] Cooper, D., Santesson, S., Farrell, S., Boeyen, S., Housley, R., and W. Polk, \"Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile\", RFC 5280, May 2008.",
      "ja": "[PKIX]クーパー、D.、Santesson、S.、ファレル、S.、Boeyen、S.、Housley氏、R.、およびW.ポーク、「インターネットX.509公開鍵暗号基盤証明書と証明書失効リスト（CRL）のプロフィール」、RFC 5280、2008年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC3279] Bassham, L., Polk, W., and R. Housley, \"Algorithms and Identifiers for the Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile\", RFC 3279, April 2002.",
      "ja": "[RFC3279] Bassham、L.、ポーク、W.、およびR. Housley氏、RFC 3279、2002年4月 \"インターネットX.509公開鍵暗号基盤証明書と証明書失効リスト（CRL）プロフィールのためのアルゴリズムと識別子\"。"
    },
    {
      "indent": 3,
      "text": "[RFC5246] Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS) Protocol Version 1.2\", RFC 5246, August 2008.",
      "ja": "[RFC5246]ダークス、T.およびE.レスコラ、 \"トランスポート層セキュリティ（TLS）プロトコルバージョン1.2\"、RFC 5246、2008年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC5480] Turner, S., Brown, D., Yiu, K., Housley, R., and T. Polk, \"Elliptic Curve Cryptography Subject Public Key Information\", RFC 5480, March 2009.",
      "ja": "[RFC5480]ターナー、S.、ブラ​​ウン、D.、耀輝、K.、Housley氏、R.、およびT.ポーク、 \"楕円曲線暗号件名公開鍵情報\"、RFC 5480、2009年3月。"
    },
    {
      "indent": 3,
      "text": "[TLS-Ext-Registry] IANA, \"Transport Layer Security (TLS) Extensions\", <http://www.iana.org/assignments/ tls-extensiontype-values>.",
      "ja": "[TLS-EXT-レジストリ] IANA、 \"トランスポート層セキュリティ（TLS）拡張機能\"、<http://www.iana.org/assignments/ TLS-extensiontype値>。"
    },
    {
      "indent": 3,
      "text": "[X.690] ITU-T, \"Information technology - ASN.1 encoding rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER)\", ITU-T Recommendation X.690, ISO/IEC 8825-1:2002, 2002.",
      "ja": "[X.690] ITU-T、 \"情報技術 -  ASN.1符号化ルール：基本符号化規則（BER）、Canonicalの符号化規則（CER）と識別符号化規則（DER）の仕様\"、ITU-T勧告X.690 、ISO / IEC 8825から1：2002、2002。"
    },
    {
      "indent": 0,
      "text": "9.2. Informative References",
      "section_title": true,
      "ja": "9.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[ASN.1-Dump] Gutmann, P., \"ASN.1 Object Dump Program\", February 2013, <http://www.cs.auckland.ac.nz/~pgut001/>.",
      "ja": "[ASN.1ダンプ] Gutmann氏、P.、 \"ASN.1オブジェクトダンププログラム\"、2013年2月、<http://www.cs.auckland.ac.nz/~pgut001/>。"
    },
    {
      "indent": 3,
      "text": "[CACHED-INFO] Santesson, S. and H. Tschofenig, \"Transport Layer Security (TLS) Cached Information Extension\", Work in Progress, February 2014.",
      "ja": "[CACHED-INFO] Santesson、S.およびH. Tschofenig、 \"トランスポート層セキュリティ（TLS）キャッシュされた情報拡張\"、進歩、2014年2月での作業。"
    },
    {
      "indent": 3,
      "text": "[CoAP] Shelby, Z., Hartke, K., and C. Bormann, \"The Constrained Application Protocol (CoAP)\", RFC 7252, June 2014.",
      "ja": "【CoAP]シェルビー、Z.、HARTKE、K.、およびC.ボルマン、 \"制約アプリケーションプロトコル（CoAP）\"、RFC 7252、2014年6月。"
    },
    {
      "indent": 3,
      "text": "[Defeating-SSL] Marlinspike, M., \"New Tricks for Defeating SSL in Practice\", February 2009, <http://www.blackhat.com/ presentations/bh-dc-09/Marlinspike/ BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf>.",
      "ja": "[倒す-SSL] Marlinspike氏、M.、2009年2月、 \"実際にはSSLを倒すための新しいトリック\"、<http://www.blackhat.com/プレゼンテーション/ BH-DC-09 / Marlinspike氏/ブラックハット-DC-09- Marlinspike氏-破っ-SSL.pdf>。"
    },
    {
      "indent": 3,
      "text": "[LDAP] Sermersheim, J., \"Lightweight Directory Access Protocol (LDAP): The Protocol\", RFC 4511, June 2006.",
      "ja": "[LDAP] Sermersheim、J.、 \"ライトウェイトディレクトリアクセスプロトコル（LDAP）：プロトコル\"、RFC 4511、2006年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC6698] Hoffman, P. and J. Schlyter, \"The DNS-Based Authentication of Named Entities (DANE) Transport Layer Security (TLS) Protocol: TLSA\", RFC 6698, August 2012.",
      "ja": "[RFC6698]ホフマン、P.およびJ. Schlyter、 \"名前付きエンティティ（DANE）トランスポート層セキュリティ（TLS）プロトコルのDNSベースの認証：TLSA\"、RFC 6698、2012年8月。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Example Encoding",
      "ja": "付録A.例のエンコーディング"
    },
    {
      "indent": 3,
      "text": "For example, the hex sequence shown in Figure 9 describes a SubjectPublicKeyInfo structure inside the certificate payload.",
      "ja": "例えば、図9に示す六角形配列は、証明書ペイロード内部SubjectPublicKeyInfoで構造が記載されています。"
    },
    {
      "indent": 3,
      "text": "       0     1     2     3     4     5     6     7     8     9\n   +------+-----+-----+-----+-----+-----+-----+-----+-----+-----\n1  | 0x30, 0x81, 0x9f, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48,\n2  | 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x81,\n3  | 0x8d, 0x00, 0x30, 0x81, 0x89, 0x02, 0x81, 0x81, 0x00, 0xcd,\n4  | 0xfd, 0x89, 0x48, 0xbe, 0x36, 0xb9, 0x95, 0x76, 0xd4, 0x13,\n5  | 0x30, 0x0e, 0xbf, 0xb2, 0xed, 0x67, 0x0a, 0xc0, 0x16, 0x3f,\n6  | 0x51, 0x09, 0x9d, 0x29, 0x2f, 0xb2, 0x6d, 0x3f, 0x3e, 0x6c,\n7  | 0x2f, 0x90, 0x80, 0xa1, 0x71, 0xdf, 0xbe, 0x38, 0xc5, 0xcb,\n8  | 0xa9, 0x9a, 0x40, 0x14, 0x90, 0x0a, 0xf9, 0xb7, 0x07, 0x0b,\n9  | 0xe1, 0xda, 0xe7, 0x09, 0xbf, 0x0d, 0x57, 0x41, 0x86, 0x60,\n10 | 0xa1, 0xc1, 0x27, 0x91, 0x5b, 0x0a, 0x98, 0x46, 0x1b, 0xf6,\n11 | 0xa2, 0x84, 0xf8, 0x65, 0xc7, 0xce, 0x2d, 0x96, 0x17, 0xaa,\n12 | 0x91, 0xf8, 0x61, 0x04, 0x50, 0x70, 0xeb, 0xb4, 0x43, 0xb7,\n13 | 0xdc, 0x9a, 0xcc, 0x31, 0x01, 0x14, 0xd4, 0xcd, 0xcc, 0xc2,\n14 | 0x37, 0x6d, 0x69, 0x82, 0xd6, 0xc6, 0xc4, 0xbe, 0xf2, 0x34,\n15 | 0xa5, 0xc9, 0xa6, 0x19, 0x53, 0x32, 0x7a, 0x86, 0x0e, 0x91,\n16 | 0x82, 0x0f, 0xa1, 0x42, 0x54, 0xaa, 0x01, 0x02, 0x03, 0x01,\n17 | 0x00, 0x01",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Figure 9: Example SubjectPublicKeyInfo Structure Byte Sequence",
      "ja": "図9：例SubjectPublicKeyInfoで構造バイトシーケンス"
    },
    {
      "indent": 3,
      "text": "The decoded byte sequence shown in Figure 9 (for example, using Peter Gutmann's ASN.1 decoder [ASN.1-Dump]) illustrates the structure, as shown in Figure 10.",
      "ja": "図10に示すように、図9に示すデコードバイトシーケンスは、（例えば、ピーター・ガットマンのASN.1デコーダ[ASN.1ダンプ]を使用して）構造を示します。"
    },
    {
      "indent": 3,
      "text": "Offset  Length   Description\n-------------------------------------------------------------------\n   0     3+159:   SEQUENCE {\n   3      2+13:     SEQUENCE {\n   5       2+9:      OBJECT IDENTIFIER Value (1 2 840 113549 1 1 1)\n              :             PKCS #1, rsaEncryption\n  16       2+0:      NULL\n              :      }\n  18     3+141:    BIT STRING, encapsulates {\n  22     3+137:      SEQUENCE {\n  25     3+129:        INTEGER Value (1024 bit)\n 157       2+3:        INTEGER Value (65537)\n              :        }\n              :      }\n              :    }",
      "raw": true
    },
    {
      "indent": 7,
      "text": "Figure 10: Decoding of Example SubjectPublicKeyInfo Structure",
      "ja": "図10：例SubjectPublicKeyInfoで構造のデコード"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Paul Wouters (editor) Red Hat",
      "ja": "ポールWOUTERS（エディタ）のRed Hat"
    },
    {
      "indent": 3,
      "text": "EMail: pwouters@redhat.com",
      "ja": "メールアドレス：pwouters@redhat.com"
    },
    {
      "indent": 3,
      "text": "Hannes Tschofenig (editor) ARM Ltd. 6060 Hall in Tirol Austria",
      "ja": "ハンネスTschofenig（エディタ）チロル、オーストリアのARM株式会社6060・ホール"
    },
    {
      "indent": 3,
      "text": "EMail: Hannes.tschofenig@gmx.net URI: http://www.tschofenig.priv.at",
      "ja": "電子メール：Hannes.tschofenig@gmx.net URI：http://www.tschofenig.priv.at"
    },
    {
      "indent": 3,
      "text": "John Gilmore Electronic Frontier Foundation PO Box 170608 San Francisco, California 94117 USA",
      "ja": "ジョン・ギルモア電子フロンティア財団私書箱170608サンフランシスコ、カリフォルニア94117 USA"
    },
    {
      "indent": 3,
      "text": "Phone: +1 415 221 6524 EMail: gnu@toad.com URI: https://www.toad.com/",
      "ja": "電話：+1 415 221 6524 Eメール：gnu@toad.com URI：https://www.toad.com/"
    },
    {
      "indent": 3,
      "text": "Samuel Weiler Parsons 7110 Samuel Morse Drive Columbia, Maryland 21046 US",
      "ja": "サミュエル・ワイラーパーソンズ7110サミュエル・モールスドライブコロンビア、メリーランド州21046米国"
    },
    {
      "indent": 3,
      "text": "EMail: weiler@tislabs.com",
      "ja": "メールアドレス：weiler@tislabs.com"
    },
    {
      "indent": 3,
      "text": "Tero Kivinen INSIDE Secure Eerikinkatu 28 Helsinki FI-00180 FI",
      "ja": "TERO Kivinen INSIDEはEerikinkatu 28 FI-00180ヘルシンキを固定し、FI"
    },
    {
      "indent": 3,
      "text": "EMail: kivinen@iki.fi",
      "ja": "メールアドレス：kivinen@iki.fi"
    }
  ]
}