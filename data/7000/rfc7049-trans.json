{
  "title": {
    "text": "RFC 7049 - Concise Binary Object Representation (CBOR)",
    "ja": "RFC 7049 - 簡潔なバイナリオブジェクトの表現（CBOR）"
  },
  "number": 7049,
  "created_at": "2019-10-28 01:25:43.050368+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                        C. Bormann\nRequest for Comments: 7049                       Universitaet Bremen TZI\nCategory: Standards Track                                     P. Hoffman\nISSN: 2070-1721                                           VPN Consortium\n                                                            October 2013",
      "raw": true
    },
    {
      "indent": 14,
      "text": "Concise Binary Object Representation (CBOR)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "The Concise Binary Object Representation (CBOR) is a data format whose design goals include the possibility of extremely small code size, fairly small message size, and extensibility without the need for version negotiation. These design goals make it different from earlier binary serializations such as ASN.1 and MessagePack.",
      "ja": "簡潔なバイナリオブジェクトの表現（CBOR）は、その設計目標バージョン交渉を必要とせずに、非常に小さなコードサイズ、かなり小さなメッセージサイズ、および拡張性の可能性を含めたデータ形式です。これらの設計目標は、ASN.1やMessagePackなど、以前のバイナリシリアル化と、それは違う作ります。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 5741のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7049.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7049で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2013 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2013 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3\n  1.1.  Objectives  . . . . . . . . . . . . . . . . . . . . . . .   4\n  1.2.  Terminology . . . . . . . . . . . . . . . . . . . . . . .   5\n2.  Specification of the CBOR Encoding  . . . . . . . . . . . . .   6\n  2.1.  Major Types . . . . . . . . . . . . . . . . . . . . . . .   7\n  2.2.  Indefinite Lengths for Some Major Types . . . . . . . . .   9\n    2.2.1.  Indefinite-Length Arrays and Maps . . . . . . . . . .   9\n    2.2.2.  Indefinite-Length Byte Strings and Text Strings . . .  11\n  2.3.  Floating-Point Numbers and Values with No Content . . . .  12\n  2.4.  Optional Tagging of Items . . . . . . . . . . . . . . . .  14\n    2.4.1.  Date and Time . . . . . . . . . . . . . . . . . . . .  16\n    2.4.2.  Bignums . . . . . . . . . . . . . . . . . . . . . . .  16\n    2.4.3.  Decimal Fractions and Bigfloats . . . . . . . . . . .  17\n    2.4.4.  Content Hints . . . . . . . . . . . . . . . . . . . .  18\n      2.4.4.1.  Encoded CBOR Data Item  . . . . . . . . . . . . .  18\n      2.4.4.2.  Expected Later Encoding for CBOR-to-JSON\n                Converters  . . . . . . . . . . . . . . . . . . .  18\n      2.4.4.3.  Encoded Text  . . . . . . . . . . . . . . . . . .  19\n    2.4.5.  Self-Describe CBOR  . . . . . . . . . . . . . . . . .  19\n3.  Creating CBOR-Based Protocols . . . . . . . . . . . . . . . .  20\n  3.1.  CBOR in Streaming Applications  . . . . . . . . . . . . .  20\n  3.2.  Generic Encoders and Decoders . . . . . . . . . . . . . .  21\n  3.3.  Syntax Errors . . . . . . . . . . . . . . . . . . . . . .  21\n    3.3.1.  Incomplete CBOR Data Items  . . . . . . . . . . . . .  22\n    3.3.2.  Malformed Indefinite-Length Items . . . . . . . . . .  22\n    3.3.3.  Unknown Additional Information Values . . . . . . . .  23\n  3.4.  Other Decoding Errors . . . . . . . . . . . . . . . . . .  23\n  3.5.  Handling Unknown Simple Values and Tags . . . . . . . . .  24\n  3.6.  Numbers . . . . . . . . . . . . . . . . . . . . . . . . .  24\n  3.7.  Specifying Keys for Maps  . . . . . . . . . . . . . . . .  25\n  3.8.  Undefined Values  . . . . . . . . . . . . . . . . . . . .  26\n  3.9.  Canonical CBOR  . . . . . . . . . . . . . . . . . . . . .  26\n  3.10. Strict Mode . . . . . . . . . . . . . . . . . . . . . . .  28\n4.  Converting Data between CBOR and JSON . . . . . . . . . . . .  29\n  4.1.  Converting from CBOR to JSON  . . . . . . . . . . . . . .  29\n  4.2.  Converting from JSON to CBOR  . . . . . . . . . . . . . .  30\n5.  Future Evolution of CBOR  . . . . . . . . . . . . . . . . . .  31\n  5.1.  Extension Points  . . . . . . . . . . . . . . . . . . . .  32\n  5.2.  Curating the Additional Information Space . . . . . . . .  33\n6.  Diagnostic Notation . . . . . . . . . . . . . . . . . . . . .  33\n  6.1.  Encoding Indicators . . . . . . . . . . . . . . . . . . .  34\n7.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  35\n  7.1.  Simple Values Registry  . . . . . . . . . . . . . . . . .  35\n  7.2.  Tags Registry . . . . . . . . . . . . . . . . . . . . . .  35\n  7.3.  Media Type (\"MIME Type\")  . . . . . . . . . . . . . . . .  36\n  7.4.  CoAP Content-Format . . . . . . . . . . . . . . . . . . .  37",
      "raw": true
    },
    {
      "indent": 3,
      "text": "  7.5.  The +cbor Structured Syntax Suffix Registration . . . . .  37\n8.  Security Considerations . . . . . . . . . . . . . . . . . . .  38\n9.  Acknowledgements  . . . . . . . . . . . . . . . . . . . . . .  38\n10. References  . . . . . . . . . . . . . . . . . . . . . . . . .  39\n  10.1.  Normative References . . . . . . . . . . . . . . . . . .  39\n  10.2.  Informative References . . . . . . . . . . . . . . . . .  40\nAppendix A.  Examples . . . . . . . . . . . . . . . . . . . . . .  41\nAppendix B.  Jump Table . . . . . . . . . . . . . . . . . . . . .  45\nAppendix C.  Pseudocode . . . . . . . . . . . . . . . . . . . . .  48\nAppendix D.  Half-Precision . . . . . . . . . . . . . . . . . . .  50\nAppendix E.  Comparison of Other Binary Formats to CBOR's Design\n             Objectives . . . . . . . . . . . . . . . . . . . . .  51\n  E.1.  ASN.1 DER, BER, and PER . . . . . . . . . . . . . . . . .  52\n  E.2.  MessagePack . . . . . . . . . . . . . . . . . . . . . . .  52\n  E.3.  BSON  . . . . . . . . . . . . . . . . . . . . . . . . . .  53\n  E.4.  UBJSON  . . . . . . . . . . . . . . . . . . . . . . . . .  53\n  E.5.  MSDTP: RFC 713  . . . . . . . . . . . . . . . . . . . . .  53\n  E.6.  Conciseness on the Wire . . . . . . . . . . . . . . . . .  53",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "There are hundreds of standardized formats for binary representation of structured data (also known as binary serialization formats). Of those, some are for specific domains of information, while others are generalized for arbitrary data. In the IETF, probably the best-known formats in the latter category are ASN.1's BER and DER [ASN.1].",
      "ja": "（また、バイナリシリアライゼーションフォーマットとしても知られる）構造化されたデータのバイナリ表現のための標準化された形式の何百もあります。他の任意のデータのために一般化されている間、それらのうち、いくつかは、情報の特定のドメインのためのものです。 IETFでは、後者のカテゴリで、おそらく最もよく知られている形式は、ASN.1のBERやDER [ASN.1]です。"
    },
    {
      "indent": 3,
      "text": "The format defined here follows some specific design goals that are not well met by current formats. The underlying data model is an extended version of the JSON data model [RFC4627]. It is important to note that this is not a proposal that the grammar in RFC 4627 be extended in general, since doing so would cause a significant backwards incompatibility with already deployed JSON documents. Instead, this document simply defines its own data model that starts from JSON.",
      "ja": "ここで定義されたフォーマットはよく、現在の形式で満たされていないいくつかの特定の設計目標を次の。基礎となるデータ・モデルは、JSONデータモデル[RFC4627]の拡張版です。そうすることが既に展開JSON文書と有意な後方互換性を引き起こすので、RFC 4627での文法は、一般的に拡張することが提案されていないことに注意することが重要です。代わりに、この文書では、単純にJSONから始まり、独自のデータモデルを定義します。"
    },
    {
      "indent": 3,
      "text": "Appendix E lists some existing binary formats and discusses how well they do or do not fit the design objectives of the Concise Binary Object Representation (CBOR).",
      "ja": "付録Eには、いくつかの既存のバイナリ形式を示していますし、彼らが行うか、簡潔なバイナリオブジェクトの表現（CBOR）の設計目標に適合しない方法も説明します。"
    },
    {
      "indent": 0,
      "text": "1.1. Objectives",
      "section_title": true,
      "ja": "1.1。目標"
    },
    {
      "indent": 3,
      "text": "The objectives of CBOR, roughly in decreasing order of importance, are:",
      "ja": "CBORの目的は、おおまかな重要性の順に、以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "1. The representation must be able to unambiguously encode most common data formats used in Internet standards.",
      "ja": "1.表現は明確にインターネット標準で使用される最も一般的なデータ形式をエンコードすることができなければなりません。"
    },
    {
      "indent": 7,
      "text": "*  It must represent a reasonable set of basic data types and\n   structures using binary encoding.  \"Reasonable\" here is\n   largely influenced by the capabilities of JSON, with the major\n   addition of binary byte strings.  The structures supported are\n   limited to arrays and trees; loops and lattice-style graphs\n   are not supported.",
      "raw": true
    },
    {
      "indent": 7,
      "text": "* There is no requirement that all data formats be uniquely encoded; that is, it is acceptable that the number \"7\" might be encoded in multiple different ways.",
      "ja": "*すべてのデータフォーマットを一意に符号化される必要はありません。つまり、「7」数は、複数の異なる方法で符号化されるかもしれないことが許容されます。"
    },
    {
      "indent": 3,
      "text": "2. The code for an encoder or decoder must be able to be compact in order to support systems with very limited memory, processor power, and instruction sets.",
      "ja": "2.エンコーダまたはデコーダのコードは非常に限られたメモリを有するシステム、プロセッサパワー、及び命令セットをサポートするためにコンパクトにすることができなければなりません。"
    },
    {
      "indent": 7,
      "text": "*  An encoder and a decoder need to be implementable in a very\n   small amount of code (for example, in class 1 constrained\n   nodes as defined in [CNN-TERMS]).",
      "raw": true
    },
    {
      "indent": 7,
      "text": "* The format should use contemporary machine representations of data (for example, not requiring binary-to-decimal conversion).",
      "ja": "*フォーマット（例えば、バイナリ・ツー・小数の変換を必要としない）データの現代の機械表現を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "3. Data must be able to be decoded without a schema description.",
      "section_title": true,
      "ja": "3.データは、スキーマの説明なしにデコードすることができなければなりません。"
    },
    {
      "indent": 7,
      "text": "*  Similar to JSON, encoded data should be self-describing so\n   that a generic decoder can be written.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "4. The serialization must be reasonably compact, but data compactness is secondary to code compactness for the encoder and decoder.",
      "ja": "4.シリアル化が合理的にコンパクトでなければならないが、データのコンパクトは、エンコーダおよびデコーダのコードコンパクトに二次的です。"
    },
    {
      "indent": 7,
      "text": "*  \"Reasonable\" here is bounded by JSON as an upper bound in\n   size, and by implementation complexity maintaining a lower\n   bound.  Using either general compression schemes or extensive\n   bit-fiddling violates the complexity goals.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "5. The format must be applicable to both constrained nodes and high-volume applications.",
      "ja": "5.フォーマットが制約ノードと大容量アプリケーションの両方に適用可能でなければなりません。"
    },
    {
      "indent": 7,
      "text": "*  This means it must be reasonably frugal in CPU usage for both\n   encoding and decoding.  This is relevant both for constrained\n   nodes and for potential usage in applications with a very high\n   volume of data.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "6. The format must support all JSON data types for conversion to and from JSON.",
      "ja": "6.フォーマットはJSONへとからの変換のためのすべてのJSONデータ型をサポートしている必要があります。"
    },
    {
      "indent": 7,
      "text": "*  It must support a reasonable level of conversion as long as\n   the data represented is within the capabilities of JSON.  It\n   must be possible to define a unidirectional mapping towards\n   JSON for all types of data.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "7. The format must be extensible, and the extended data must be decodable by earlier decoders.",
      "ja": "7.フォーマットは拡張可能でなければならず、拡張データは、以前のデコーダによって復号可能でなければなりません。"
    },
    {
      "indent": 7,
      "text": "* The format is designed for decades of use.",
      "ja": "*フォーマットは、使用の数十年のために設計されています。"
    },
    {
      "indent": 7,
      "text": "* The format must support a form of extensibility that allows fallback so that a decoder that does not understand an extension can still decode the message.",
      "ja": "*フォーマットは拡張子を理解しないデコーダが依然としてメッセージを復号することができるように、フォールバックを可能にする拡張性の形式をサポートしなければなりません。"
    },
    {
      "indent": 7,
      "text": "* The format must be able to be extended in the future by later IETF standards.",
      "ja": "*フォーマットは後でIETF標準で、将来的に拡張することができなければなりません。"
    },
    {
      "indent": 0,
      "text": "1.2. Terminology",
      "section_title": true,
      "ja": "1.2。用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119, BCP 14 [RFC2119] and indicate requirement levels for compliant CBOR implementations.",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はありますRFC 2119に記載されるように解釈されるべきで、BCP 14 [RFC2119]と準拠CBOR実装の要求レベルを示します。"
    },
    {
      "indent": 3,
      "text": "The term \"byte\" is used in its now-customary sense as a synonym for \"octet\". All multi-byte values are encoded in network byte order (that is, most significant byte first, also known as \"big-endian\").",
      "ja": "用語「バイト」は「オクテット」の同義語としてその今、慣習的な意味で使用されています。すべてのマルチバイトの値が（それは、最上位バイトが最初に、また「ビッグエンディアン」として知られている）ネットワークバイト順に符号化されています。"
    },
    {
      "indent": 3,
      "text": "This specification makes use of the following terminology:",
      "ja": "この仕様は、以下の用語を使用します："
    },
    {
      "indent": 3,
      "text": "Data item: A single piece of CBOR data. The structure of a data item may contain zero, one, or more nested data items. The term is used both for the data item in representation format and for the abstract idea that can be derived from that by a decoder.",
      "ja": "データ項目：CBORデータの一枚。データ項目の構造は、ゼロ、1つ、または複数のネストされたデータ項目を含むことができます。この用語は、表現形式のデータ項目およびデコーダによってその由来することができる抽象的アイデアの両方に使用されます。"
    },
    {
      "indent": 3,
      "text": "Decoder: A process that decodes a CBOR data item and makes it available to an application. Formally speaking, a decoder contains a parser to break up the input using the syntax rules of CBOR, as well as a semantic processor to prepare the data in a form suitable to the application.",
      "ja": "デコーダ：CBORデータ項目を復号し、アプリケーションにそれが利用できるようにするプロセス。正式に言えば、デコーダは、アプリケーションに適した形式でデータを準備するためにCBORの構文規則、ならびにセマンティックプロセッサを使用して入力を分割するパーサを含んでいます。"
    },
    {
      "indent": 3,
      "text": "Encoder: A process that generates the representation format of a CBOR data item from application information.",
      "ja": "エンコーダ：アプリケーション情報からCBORデータ項目の表現形式を生成するプロセス。"
    },
    {
      "indent": 3,
      "text": "Data Stream: A sequence of zero or more data items, not further assembled into a larger containing data item. The independent data items that make up a data stream are sometimes also referred to as \"top-level data items\".",
      "ja": "データストリーム：ゼロ以上のデータ項目の順序ではなく、さらに大きな含むデータ項目に組み込ま。データ・ストリームを構成する独立したデータ項目は、時々、「トップレベルのデータ項目」と呼ばれています。"
    },
    {
      "indent": 3,
      "text": "Well-formed: A data item that follows the syntactic structure of CBOR. A well-formed data item uses the initial bytes and the byte strings and/or data items that are implied by their values as defined in CBOR and is not followed by extraneous data.",
      "ja": "整形式：CBORの構文構造を、以下のデータ項目。十分に形成されたデータ項目は、最初のバイトと、バイトストリング及び/又はCBORで定義され、無関係なデータが続かないようにそれらの値によって暗示されているデータ項目を使用します。"
    },
    {
      "indent": 3,
      "text": "Valid: A data item that is well-formed and also follows the semantic restrictions that apply to CBOR data items.",
      "ja": "有効：よく形成されており、またCBORデータ項目に適用される意味上の制限を次のデータ項目。"
    },
    {
      "indent": 3,
      "text": "Stream decoder: A process that decodes a data stream and makes each of the data items in the sequence available to an application as they are received.",
      "ja": "ストリームデコーダ：データストリームをデコードし、それらが受信されるアプリケーションに利用可能な配列のデータ項目の各々を作るプロセス。"
    },
    {
      "indent": 3,
      "text": "Where bit arithmetic or data types are explained, this document uses the notation familiar from the programming language C, except that \"**\" denotes exponentiation. Similar to the \"0x\" notation for hexadecimal numbers, numbers in binary notation are prefixed with \"0b\". Underscores can be added to such a number solely for readability, so 0b00100001 (0x21) might be written 0b001_00001 to emphasize the desired interpretation of the bits in the byte; in this case, it is split into three bits and five bits.",
      "ja": "ビット演算又はデータタイプが説明されている場合、この文書は、「**」べき乗を表していることを除いて、プログラミング言語Cから馴染みの表記法を使用します。 16進数は、「0X」表記と同様に、2進数で数字を「0B」が付いています。下線は、単に読みやすくするために、このような数に添加することができるので、0b00100001は（0x21で）バイト内のビットの所望の解釈を強調する0b001_00001書き込まれるかもしれません。この場合には、それは3ビットと5ビットに分割されます。"
    },
    {
      "indent": 0,
      "text": "2. Specification of the CBOR Encoding",
      "section_title": true,
      "ja": "CBORエンコーディングの2仕様"
    },
    {
      "indent": 3,
      "text": "A CBOR-encoded data item is structured and encoded as described in this section. The encoding is summarized in Table 5.",
      "ja": "CBOR符号化されたデータ項目が構造化し、このセクションで説明したように符号化されます。符号化は、表5に要約します。"
    },
    {
      "indent": 3,
      "text": "The initial byte of each data item contains both information about the major type (the high-order 3 bits, described in Section 2.1) and additional information (the low-order 5 bits). When the value of the additional information is less than 24, it is directly used as a small unsigned integer. When it is 24 to 27, the additional bytes for a variable-length integer immediately follow; the values 24 to 27 of the additional information specify that its length is a 1-, 2-, 4-, or 8-byte unsigned integer, respectively. Additional information value 31 is used for indefinite-length items, described in Section 2.2. Additional information values 28 to 30 are reserved for future expansion.",
      "ja": "各データ項目の最初のバイトは、両方の主要なタイプの情報（セクション2.1で説明上位3ビット）と追加情報（下位5ビット）を含みます。付加情報の値が24未満である場合、それは直接小さい符号なし整数として使用されます。それは24〜27である場合、可変長整数のための追加のバイトは直ちに従います。付加情報27に値24は、その長さは、それぞれ、1-、2-、4-、または8バイトの符号なし整数であることを指定します。付加情報の値31は、セクション2.2に記載不定長のアイテムに使用されます。追加情報は、30から28は、将来の拡張のために予約されている値。"
    },
    {
      "indent": 3,
      "text": "In all additional information values, the resulting integer is interpreted depending on the major type. It may represent the actual data: for example, in integer types, the resulting integer is used for the value itself. It may instead supply length information: for example, in byte strings it gives the length of the byte string data that follows.",
      "ja": "すべての追加情報値は、得られた整数は、主要な種類に応じて解釈されます。これは、実際のデータを表すことができる：例えば、整数型で、得られた整数値自体に使用されます。これは、代わりに長さの情報を供給することができる：例えば、バイト文字列には、次のバイトの文字列データの長さを与えます。"
    },
    {
      "indent": 3,
      "text": "A CBOR decoder implementation can be based on a jump table with all 256 defined values for the initial byte (Table 5). A decoder in a constrained implementation can instead use the structure of the initial byte and following bytes for more compact code (see Appendix C for a rough impression of how this could look).",
      "ja": "CBORデコーダの実装では、最初のバイト（表5）のためのすべての256の定義された値とジャンプテーブルに基づくことができます。制約された実装で、デコーダではなく、初期バイトの構造がよりコンパクトなコードのための次のバイトを（これが見えることができる方法の大まかな印象については、付録Cを参照）を使用することができます。"
    },
    {
      "indent": 0,
      "text": "2.1. Major Types",
      "section_title": true,
      "ja": "2.1。主な種類"
    },
    {
      "indent": 3,
      "text": "The following lists the major types and the additional information and other bytes associated with the type.",
      "ja": "以下は、主要なタイプとタイプに関連する追加情報や他のバイトを示しています。"
    },
    {
      "indent": 3,
      "text": "Major type 0: an unsigned integer. The 5-bit additional information is either the integer itself (for additional information values 0 through 23) or the length of additional data. Additional information 24 means the value is represented in an additional uint8_t, 25 means a uint16_t, 26 means a uint32_t, and 27 means a uint64_t. For example, the integer 10 is denoted as the one byte 0b000_01010 (major type 0, additional information 10). The integer 500 would be 0b000_11001 (major type 0, additional information 25) followed by the two bytes 0x01f4, which is 500 in decimal.",
      "ja": "主なタイプ0：符号なし整数。 5ビットの付加情報が整数自体（付加情報23を介して値0）または追加データの長さのいずれかです。追加情報24は、26のuint32_tを意味し、追加のuint8_tで表される値が、25 uint16_tの手段、及び27はuint64_tをを意味します。例えば、整数10は、1バイト0b000_01010（主要なタイプ0、付加情報10）として示されます。整数500は小数で500である2バイト0x01f4、続い0b000_11001（主要なタイプ0、付加情報25）であろう。"
    },
    {
      "indent": 3,
      "text": "Major type 1: a negative integer. The encoding follows the rules for unsigned integers (major type 0), except that the value is then -1 minus the encoded unsigned integer. For example, the integer -500 would be 0b001_11001 (major type 1, additional information 25) followed by the two bytes 0x01f3, which is 499 in decimal.",
      "ja": "主要なタイプ1：負の整数。符号化値が符号化された符号なし整数次いで-1マイナスことを除いて、符号なし整数（主要なタイプ0）のための規則に従います。例えば、整数-500は小数で499である2バイト0x01f3、続い0b001_11001（主要なタイプ1、付加情報25）であろう。"
    },
    {
      "indent": 3,
      "text": "Major type 2: a byte string. The string's length in bytes is represented following the rules for positive integers (major type 0). For example, a byte string whose length is 5 would have an initial byte of 0b010_00101 (major type 2, additional information 5 for the length), followed by 5 bytes of binary content. A byte string whose length is 500 would have 3 initial bytes of",
      "ja": "主要タイプ2：バイト文字列。バイト単位での文字列の長さは正の整数（主要なタイプ0）のための規則に従って表されます。例えば、長さが5バイト列は、バイナリコンテンツの5つのバイトが続く0b010_00101（主要な2型、長さの付加情報5）の最初のバイトを有するであろう。長さが500であるの3初期バイトを持つことになり、バイト文字列"
    },
    {
      "indent": 6,
      "text": "0b010_11001 (major type 2, additional information 25 to indicate a two-byte length) followed by the two bytes 0x01f4 for a length of 500, followed by 500 bytes of binary content.",
      "ja": "バイナリコンテンツの500バイトに続く500の長さ2バイトの0x01f4、続い0b010_11001（主要な2型、2バイトの長さを示すために、追加の情報25）。"
    },
    {
      "indent": 3,
      "text": "Major type 3: a text string, specifically a string of Unicode characters that is encoded as UTF-8 [RFC3629]. The format of this type is identical to that of byte strings (major type 2), that is, as with major type 2, the length gives the number of bytes. This type is provided for systems that need to interpret or display human-readable text, and allows the differentiation between unstructured bytes and text that has a specified repertoire and encoding. In contrast to formats such as JSON, the Unicode characters in this type are never escaped. Thus, a newline character (U+000A) is always represented in a string as the byte 0x0a, and never as the bytes 0x5c6e (the characters \"\\\" and \"n\") or as 0x5c7530303061 (the characters \"\\\", \"u\", \"0\", \"0\", \"0\", and \"a\").",
      "ja": "主要なタイプ3：テキスト文字列、UTF-8でエンコードされたUnicode文字の具体列[RFC3629]。このタイプのフォーマットは、バイト文字列（主要なタイプ2）のものと同一である、すなわち、主要なタイプ2と同様に、長さがバイトの数を与えます。このタイプは、解釈または人間可読テキストを表示する必要があるシステムのために提供され、指定されたレパートリーとエンコーディングを有する構造化されていないバイトとテキストとの間の区別を可能にします。なJSONなどの形式とは対照的に、このタイプのUnicode文字がエスケープされることはありません。このように、改行文字（U + 000A）は、常にU「は、「\\」のバイトは0x0Aとして、決してバイト0x5c6e（文字「\\」と「N」）として、あるいは0x5c7530303061（文字などの文字列で表されます」、 \"0\"、 \"0\"、 \"0\"、および \"A\"）。"
    },
    {
      "indent": 3,
      "text": "Major type 4: an array of data items. Arrays are also called lists, sequences, or tuples. The array's length follows the rules for byte strings (major type 2), except that the length denotes the number of data items, not the length in bytes that the array takes up. Items in an array do not need to all be of the same type. For example, an array that contains 10 items of any type would have an initial byte of 0b100_01010 (major type of 4, additional information of 10 for the length) followed by the 10 remaining items.",
      "ja": "主要なタイプ4：データ項目のアレイ。配列はまた、リスト、配列、またはタプルと呼ばれています。配列の長さは、長さは、データ項目の数ではなく、配列が占めるバイト単位の長さを表していることを除いて、バイト列（主要なタイプ2）のための規則に従います。配列内のアイテムは、同じタイプのすべてである必要はありません。例えば、任意のタイプの10個の項目を含むアレイ10個の残りの項目が続く0b100_01010の最初のバイト（4の主要なタイプ、長さ10の追加的な情報）を有するであろう。"
    },
    {
      "indent": 3,
      "text": "Major type 5: a map of pairs of data items. Maps are also called tables, dictionaries, hashes, or objects (in JSON). A map is comprised of pairs of data items, each pair consisting of a key that is immediately followed by a value. The map's length follows the rules for byte strings (major type 2), except that the length denotes the number of pairs, not the length in bytes that the map takes up. For example, a map that contains 9 pairs would have an initial byte of 0b101_01001 (major type of 5, additional information of 9 for the number of pairs) followed by the 18 remaining items. The first item is the first key, the second item is the first value, the third item is the second key, and so on. A map that has duplicate keys may be well-formed, but it is not valid, and thus it causes indeterminate decoding; see also Section 3.7.",
      "ja": "主なタイプ5：データ項目のペアのマップ。マップはまた、（JSONで）テーブル、辞書、ハッシュ、またはオブジェクトと呼ばれています。マップは、データ項目、直ちに値が続いているキーからなる各ペアのペアで構成されています。マップの長さは、長さがペアの数ではなく、マップが占めるバイト単位の長さを示していることを除いて、バイト文字列（主要タイプ2）のための規則に従います。例えば、9対を含む地図18件の残りのアイテム続い0b101_01001（5の主要なタイプ、ペアの数9の付加情報）の最初のバイトを有するであろう。最初の項目は、3番目の項目は、第2の鍵である、というように、2番目の項目が第1の値であり、最初のキーです。重複キーを持つマップはよく形成することができ、それは有効でないので、それは不確定復号化を引き起こします。また、3.7節を参照してください。"
    },
    {
      "indent": 3,
      "text": "Major type 6: optional semantic tagging of other major types. See Section 2.4.",
      "ja": "主なタイプ6：他の主要なタイプのオプションのセマンティックタグ付け。 2.4節を参照してください。"
    },
    {
      "indent": 3,
      "text": "Major type 7: floating-point numbers and simple data types that need no content, as well as the \"break\" stop code. See Section 2.3.",
      "ja": "主なタイプ7：浮動小数点数と何のコンテンツを必要としない単純なデータ型だけでなく、「ブレイク」ストップコード。 2.3節を参照してください。"
    },
    {
      "indent": 3,
      "text": "These eight major types lead to a simple table showing which of the 256 possible values for the initial byte of a data item are used (Table 5).",
      "ja": "これらの8つの主要なタイプは、（表5）に使用されるデータ項目の最初のバイトのための256の可能な値の単純なテーブル示すことにつながります。"
    },
    {
      "indent": 3,
      "text": "In major types 6 and 7, many of the possible values are reserved for future specification. See Section 7 for more information on these values.",
      "ja": "主要なタイプ6および7に、可能な値の多くは、将来の仕様のために予約されています。これらの値の詳細については、セクション7を参照してください。"
    },
    {
      "indent": 0,
      "text": "2.2. Indefinite Lengths for Some Major Types",
      "section_title": true,
      "ja": "2.2。いくつかの主要なタイプの不定長"
    },
    {
      "indent": 3,
      "text": "Four CBOR items (arrays, maps, byte strings, and text strings) can be encoded with an indefinite length using additional information value 31. This is useful if the encoding of the item needs to begin before the number of items inside the array or map, or the total length of the string, is known. (The application of this is often referred to as \"streaming\" within a data item.)",
      "ja": "四つCBOR項目（列、マップ、バイト列、およびテキスト文字列）が付加情報値31を用いて不定長で符号化することができる項目の符号化はアレイまたはマップ内の項目の番号の前に開始する必要がある場合に便利です、または文字列の全長は、知られています。 （この出願は、しばしば、データ項目内の「ストリーミング」と呼ばれます。）"
    },
    {
      "indent": 3,
      "text": "Indefinite-length arrays and maps are dealt with differently than indefinite-length byte strings and text strings.",
      "ja": "不定長配列とマップは不定長のバイト列と文字列とは異なる扱われます。"
    },
    {
      "indent": 0,
      "text": "2.2.1. Indefinite-Length Arrays and Maps",
      "section_title": true,
      "ja": "2.2.1。不定長配列と地図"
    },
    {
      "indent": 3,
      "text": "Indefinite-length arrays and maps are simply opened without indicating the number of data items that will be included in the array or map, using the additional information value of 31. The initial major type and additional information byte is followed by the elements of the array or map, just as they would be in other arrays or maps. The end of the array or map is indicated by encoding a \"break\" stop code in a place where the next data item would normally have been included. The \"break\" is encoded with major type 7 and additional information value 31 (0b111_11111) but is not itself a data item: it is just a syntactic feature to close the array or map. That is, the \"break\" stop code comes after the last item in the array or map, and it cannot occur anywhere else in place of a data item. In this way, indefinite-length arrays and maps look identical to other arrays and maps except for beginning with the additional information value 31 and ending with the \"break\" stop code.",
      "ja": "不定長配列およびマップは、単に最初の主要なタイプ及び付加情報バイトが配列の要素が続く31の付加情報値を使用して、アレイまたはマップに含まれるデータ数を示すことなく開放されまたは、彼らは他のアレイまたはマップにあるのと同じように、マップします。アレイまたはマップの端部は、次のデータ項目が正常に含まれていたであろう場所に「ブレーク」ストップコードを符号化して示されています。 「ブレーク」は主要なタイプ7及び付加情報値31（0b111_11111）でエンコードされたが、データ項目自体ではない：それはアレイまたはマップを閉じるだけ構文的特徴です。それは「ブレーク」ストップコードが配列またはマップの最後の項目の後に来る、であり、それはデータ項目の代わりに、他の場所で発生することはできません。このように、不定長配列とマップは他の配列と追加情報値31で始まり、「ブレーク」ストップコードで終わる以外はマップと同じに見えます。"
    },
    {
      "indent": 3,
      "text": "Arrays and maps with indefinite lengths allow any number of items (for arrays) and key/value pairs (for maps) to be given before the \"break\" stop code. There is no restriction against nesting indefinite-length array or map items. A \"break\" only terminates a single item, so nested indefinite-length items need exactly as many \"break\" stop codes as there are type bytes starting an indefinite-length item.",
      "ja": "不定長さの配列とマップ（マップの）任意の（アレイの）アイテムの数とキー/値のペアが「ブレーク」ストップコードの前に与えられることを可能にします。入れ子不定長の配列またはマップアイテムに対する制限はありません。 「ブレーク」のみ不定長の項目を開始型バイトが存在するように、ネストされた不定長の項目は正確に同じ数の「ブレーク」ストップコードを必要とするので、単一のアイテムを終了します。"
    },
    {
      "indent": 3,
      "text": "For example, assume an encoder wants to represent the abstract array [1, [2, 3], [4, 5]]. The definite-length encoding would be 0x8301820203820405:",
      "ja": "例えば、エンコーダは抽象配列[1、[2,3]、[4,5]を表したいと仮定する。明確なレングス符号化は、0x8301820203820405次のようになります。"
    },
    {
      "indent": 3,
      "text": "83 -- Array of length 3 01 -- 1 82 -- Array of length 2 02 -- 2 03 -- 3 82 -- Array of length 2 04 -- 4 05 -- 5",
      "ja": "1 82  -   -  83  - 長さ3 01の配列長さの配列2月2日から3月2日まで -  3 82  - 長さの配列2月4日から4月5日まで -  5"
    },
    {
      "indent": 3,
      "text": "Indefinite-length encoding could be applied independently to each of the three arrays encoded in this data item, as required, leading to representations such as:",
      "ja": "不定長の符号化は、次のような表現につながる、必要に応じて、このデータ項目に符号化された3つのアレイの各々に独立に適用することができます。"
    },
    {
      "indent": 3,
      "text": "0x9f018202039f0405ffff 9F -- Start indefinite-length array 01 -- 1 82 -- Array of length 2 02 -- 2 03 -- 3 9F -- Start indefinite-length array 04 -- 4 05 -- 5 FF -- \"break\" (inner array) FF -- \"break\" (outer array)",
      "ja": "9F 0x9f018202039f0405ffff  -  4 05  -   -  5 FF  -  \"ブレーク\" 不定長のアレイ04を起動1  -  82  -   -  2 03  -   -  3 9Fの長さ2 02のアレイ不定長のアレイ01を起動し（内部配列）FF  -  \"ブレーク\"（外側の配列）"
    },
    {
      "indent": 3,
      "text": "0x9f01820203820405ff 9F -- Start indefinite-length array 01 -- 1 82 -- Array of length 2 02 -- 2 03 -- 3 82 -- Array of length 2 04 -- 4 05 -- 5 FF -- \"break\"",
      "ja": "9F 0x9f01820203820405ff 1  -  82  -   -  2 03  -   -  3 82  - 長さ2 02のアレイ4 05  -   -  5 FF  - 長さ2 04の配列 \"ブレーク\" 不定長のアレイ01を起動し"
    },
    {
      "indent": 3,
      "text": "0x83018202039f0405ff 83 -- Array of length 3 01 -- 1 82 -- Array of length 2 02 -- 2 03 -- 3 9F -- Start indefinite-length array 04 -- 4 05 -- 5 FF -- \"break\"",
      "ja": "83 0x83018202039f0405ff 1  -  82  -   - 長さ3 01のアレイ2 03  -   -  3 9F  - 長さ2 02のアレイ4 05  -   -  5 FF  -  \"ブレーク\" 不定長のアレイ04を起動し"
    },
    {
      "indent": 3,
      "text": "0x83019f0203ff820405 83 -- Array of length 3 01 -- 1 9F -- Start indefinite-length array 02 -- 2 03 -- 3 FF -- \"break\" 82 -- Array of length 2 04 -- 4 05 -- 5",
      "ja": "0x83019f0203ff820405 83から1 9F  -   - 長さ3 01のアレイ2 03  -   -  3 FF  -  \"ブレイク\" 82  - 不定長のアレイ02を起動長さの配列2月4日から4月5日まで -  5"
    },
    {
      "indent": 3,
      "text": "An example of an indefinite-length map (that happens to have two key/value pairs) might be:",
      "ja": "不定長のマップの一例は、かもしれない（すなわち、2つのキー/値のペアを持つことが起こります）。"
    },
    {
      "indent": 3,
      "text": "0xbf6346756ef563416d7421ff BF -- Start indefinite-length map 63 -- First key, UTF-8 string length 3 46756e -- \"Fun\" F5 -- First value, true 63 -- Second key, UTF-8 string length 3 416d74 -- \"Amt\" 21 -- -2 FF -- \"break\"",
      "ja": "0xbf6346756ef563416d7421ff BF  - 不定長のマップ63開始 - まずキー、UTF-8文字列の長さを3 46756e  -  \"楽しい\" F5  - 最初の値、真の63  -  2番目のキー、UTF-8文字列の長さ3 416d74  - 」 AMT」21  -  -2 FF  -  \"ブレーク\""
    },
    {
      "indent": 0,
      "text": "2.2.2. Indefinite-Length Byte Strings and Text Strings",
      "section_title": true,
      "ja": "2.2.2。不定長のバイト文字列とテキスト文字列"
    },
    {
      "indent": 3,
      "text": "Indefinite-length byte strings and text strings are actually a concatenation of zero or more definite-length byte or text strings (\"chunks\") that are together treated as one contiguous string. Indefinite-length strings are opened with the major type and additional information value of 31, but what follows are a series of byte or text strings that have definite lengths (the chunks). The end of the series of chunks is indicated by encoding the \"break\" stop code (0b111_11111) in a place where the next chunk in the series would occur. The contents of the chunks are concatenated together, and the overall length of the indefinite-length string will be the sum of the lengths of all of the chunks. In summary, an indefinite-length string is encoded similarly to how an indefinite-length array of its chunks would be encoded, except that the major type of the indefinite-length string is that of a (text or byte) string and matches the major types of its chunks.",
      "ja": "不定長のバイト列とテキスト文字列は、実際には、ゼロ個以上の明確な長さのバイトまたはテキスト文字列一緒に1つの連続した文字列として扱われ（「チャンク」）の連結です。不定長の文字列は、31の主要な種類と追加情報値で開かが、何以下は明確長（チャンク）を持っているバイトまたはテキスト文字列のシリーズですされています。チャンクの一連の端部は、一連の次のチャンクが発生する場所に「ブレーク」ストップコード（0b111_11111）をコードによって示されます。チャンクの内容が一緒に連結され、不定長の文字列の全体の長さは、チャンクのすべての長さの和であろう。要約すると、不定の長さの文字列は、不定長のストリングの主要なタイプは、（テキストまたはバイト）の文字列のものであり、主に一致することを除いて、そのチャンクの不定長の配列が符号化される方法と同様に符号化されますそのチャンクの種類。"
    },
    {
      "indent": 3,
      "text": "For indefinite-length byte strings, every data item (chunk) between the indefinite-length indicator and the \"break\" MUST be a definite-length byte string item; if the parser sees any item type other than a byte string before it sees the \"break\", it is an error.",
      "ja": "不定長のバイト列は、不定長のインジケータと「休憩」との間のすべてのデータ項目（チャンク）は、明確な長バイト列項目でなければなりません。それは「休憩」を見る前パーサはバイト文字列以外の任意の項目タイプを見れば、それは誤りです。"
    },
    {
      "indent": 3,
      "text": "For example, assume the sequence:",
      "ja": "例えば、配列を想定しています。"
    },
    {
      "indent": 3,
      "text": "0b010_11111 0b010_00100 0xaabbccdd 0b010_00011 0xeeff99 0b111_11111",
      "ja": "0b010_11111 0b010_00100 0xaabbccdd 0b010_00011 0xeeff99 0b111_11111"
    },
    {
      "indent": 3,
      "text": "5F -- Start indefinite-length byte string 44 -- Byte string of length 4 aabbccdd -- Bytes content 43 -- Byte string of length 3 eeff99 -- Bytes content FF -- \"break\"",
      "ja": "5F  - バイトコンテンツ43  -   - バイトコンテンツFF  -   - 「ブレーク」長3 eeff99のバイト文字列長さ4 AABBCCDDのバイト列 - 不定長のバイト列44を起動し"
    },
    {
      "indent": 3,
      "text": "After decoding, this results in a single byte string with seven bytes: 0xaabbccddeeff99.",
      "ja": "0xaabbccddeeff99：デコードした後、これは、7バイトのシングルバイト文字列になります。"
    },
    {
      "indent": 3,
      "text": "Text strings with indefinite lengths act the same as byte strings with indefinite lengths, except that all their chunks MUST be definite-length text strings. Note that this implies that the bytes of a single UTF-8 character cannot be spread between chunks: a new chunk can only be started at a character boundary.",
      "ja": "不定長さのテキスト文字列は、すべてのチャンクが明確な長さのテキスト文字列でなければならないことを除いて、無期限の長さのバイト列と同じように行動します。新しいチャンクが唯一の文字境界で開始することができます。これは、単一のUTF-8文字のバイトはチャンクの間に広がることができないことを意味することに注意してください。"
    },
    {
      "indent": 0,
      "text": "2.3. Floating-Point Numbers and Values with No Content",
      "section_title": true,
      "ja": "2.3。コンテンツのない浮動小数点数と値"
    },
    {
      "indent": 3,
      "text": "Major type 7 is for two types of data: floating-point numbers and \"simple values\" that do not need any content. Each value of the 5-bit additional information in the initial byte has its own separate meaning, as defined in Table 1. Like the major types for integers, items of this major type do not carry content data; all the information is in the initial bytes.",
      "ja": "浮動小数点数と任意のコンテンツを必要としない「単純な値」：主要タイプ7は、データの2種類です。最初のバイトの5ビットの付加情報の各値は、独自の独立した意味を持ち、整数の主要なタイプと同様に、表1に定義されているように、この主要なタイプのアイテムは、コンテンツデータを運びません。すべての情報は、最初のバイトです。"
    },
    {
      "indent": 4,
      "text": "+-------------+--------------------------------------------------+\n| 5-Bit Value | Semantics                                        |\n+-------------+--------------------------------------------------+\n| 0..23       | Simple value (value 0..23)                       |\n|             |                                                  |\n| 24          | Simple value (value 32..255 in following byte)   |\n|             |                                                  |\n| 25          | IEEE 754 Half-Precision Float (16 bits follow)   |\n|             |                                                  |\n| 26          | IEEE 754 Single-Precision Float (32 bits follow) |\n|             |                                                  |\n| 27          | IEEE 754 Double-Precision Float (64 bits follow) |\n|             |                                                  |\n| 28-30       | (Unassigned)                                     |\n|             |                                                  |\n| 31          | \"break\" stop code for indefinite-length items    |\n+-------------+--------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 8,
      "text": "Table 1: Values for Additional Information in Major Type 7",
      "ja": "表1：主要なタイプ7で追加情報の値"
    },
    {
      "indent": 3,
      "text": "As with all other major types, the 5-bit value 24 signifies a single-byte extension: it is followed by an additional byte to represent the simple value. (To minimize confusion, only the values 32 to 255 are used.) This maintains the structure of the initial bytes: as for the other major types, the length of these always depends on the additional information in the first byte. Table 2 lists the values assigned and available for simple types.",
      "ja": "他のすべての主要なタイプと同様に、5ビットの値24は、シングルバイトの拡張を意味する：単純な値を表すために追加のバイトが続きます。 （混乱を最小限にするために、255にのみ値32が使用される。）これは最初のバイトの構造を維持する：他の主要なタイプと同様に、これらの長さは、常に最初のバイトに追加情報に依存します。表2の値が割り当てられ、シンプルなタイプで使用できます。"
    },
    {
      "indent": 23,
      "text": "+---------+-----------------+\n| Value   | Semantics       |\n+---------+-----------------+\n| 0..19   | (Unassigned)    |\n|         |                 |\n| 20      | False           |\n|         |                 |\n| 21      | True            |\n|         |                 |\n| 22      | Null            |\n|         |                 |\n| 23      | Undefined value |\n|         |                 |\n| 24..31  | (Reserved)      |\n|         |                 |\n| 32..255 | (Unassigned)    |\n+---------+-----------------+",
      "raw": true
    },
    {
      "indent": 26,
      "text": "Table 2: Simple Values",
      "ja": "表2：単純な値"
    },
    {
      "indent": 3,
      "text": "The 5-bit values of 25, 26, and 27 are for 16-bit, 32-bit, and 64-bit IEEE 754 binary floating-point values. These floating-point values are encoded in the additional bytes of the appropriate size. (See Appendix D for some information about 16-bit floating point.)",
      "ja": "25、26、及び27の5ビット値は、16ビット、32ビット、および64ビットのIEEE 754バイナリ浮動小数点値のためのものです。これらの浮動小数点値を適切な大きさの追加バイトで符号化されます。 （16ビット浮動小数点に関するいくつかの情報は、付録Dを参照）。"
    },
    {
      "indent": 0,
      "text": "2.4. Optional Tagging of Items",
      "section_title": true,
      "ja": "2.4。アイテムのオプションのタグ付け"
    },
    {
      "indent": 3,
      "text": "In CBOR, a data item can optionally be preceded by a tag to give it additional semantics while retaining its structure. The tag is major type 6, and represents an integer number as indicated by the tag's integer value; the (sole) data item is carried as content data. If a tag requires structured data, this structure is encoded into the nested data item. The definition of a tag usually restricts what kinds of nested data item or items can be carried by a tag.",
      "ja": "CBORでは、データ項目は、必要に応じてその構造を保持しながら、それに追加の意味を与えるためにタグを付けることができます。タグは、主要なタイプ6で、タグの整数値によって示される整数を表します。 （唯一の）データ項目は、コンテンツデータとして搬送されます。タグは、構造化されたデータを必要とする場合、このような構造は、ネストされたデータ項目に符号化されます。タグの定義は、通常、ネストされたデータ項目または項目の種類は、タグによって担持することができるものを制限します。"
    },
    {
      "indent": 3,
      "text": "The initial bytes of the tag follow the rules for positive integers (major type 0). The tag is followed by a single data item of any type. For example, assume that a byte string of length 12 is marked with a tag to indicate it is a positive bignum (Section 2.4.2). This would be marked as 0b110_00010 (major type 6, additional information 2 for the tag) followed by 0b010_01100 (major type 2, additional information of 12 for the length) followed by the 12 bytes of the bignum.",
      "ja": "タグの最初のバイトは、正の整数（主要なタイプ0）の規則に従います。タグは、任意のタイプの単一のデータ項目が続きます。例えば、長さ12のバイト列は、それが正BIGNUM（2.4.2項）であることを示すタグでマークされていると仮定する。これはBIGNUMの12のバイトが続く0b010_01100（主要な2型、長さ12の追加的な情報）が続く0b110_00010（主要なタイプ6、タグの付加情報2）としてマークされることになります。"
    },
    {
      "indent": 3,
      "text": "Decoders do not need to understand tags, and thus tags may be of little value in applications where the implementation creating a particular CBOR data item and the implementation decoding that stream know the semantic meaning of each item in the data flow. Their primary purpose in this specification is to define common data types such as dates. A secondary purpose is to allow optional tagging when the decoder is a generic CBOR decoder that might be able to benefit from hints about the content of items. Understanding the semantic tags is optional for a decoder; it can just jump over the initial bytes of the tag and interpret the tagged data item itself.",
      "ja": "デコーダは、タグを理解する必要はありませんので、タグが実装は、特定のCBORデータ項目とデータフロー内の各項目の意味論的な意味を知っているストリーム実装デコードを作成するアプリケーションではほとんど価値のものであってもよいです。この仕様では、その主な目的は、日付などの一般的なデータ型を定義することです。第2の目的は、デコーダは、アイテムの内容に関するヒントの恩恵を受けることができるかもしれない一般的なCBORデコーダであるとき、オプションのタグ付けを可能にすることです。セマンティックタグを理解することは、デコーダのためのオプションです。それだけで、タグの最初のバイトを飛び越えるとタグ付けされたデータ項目自体を解釈することができます。"
    },
    {
      "indent": 3,
      "text": "A tag always applies to the item that is directly followed by it. Thus, if tag A is followed by tag B, which is followed by data item C, tag A applies to the result of applying tag B on data item C. That is, a tagged item is a data item consisting of a tag and a value. The content of the tagged item is the data item (the value) that is being tagged.",
      "ja": "タグは、常に直接それが続いている項目に適用されます。タグAがデータ項目Cが続くタグB、続いている場合したがって、タグAがデータ項目CにタグBを適用した結果に適用され、タグ付けされたアイテムは、タグとからなるデータ項目であります値。タグ付けされたアイテムのコンテンツがタグ付けされているデータ項目（値）です。"
    },
    {
      "indent": 3,
      "text": "IANA maintains a registry of tag values as described in Section 7.2. Table 3 provides a list of initial values, with definitions in the rest of this section.",
      "ja": "セクション7.2で説明したようにIANAは、タグ値のレジストリを維持します。表3は、このセクションの残りの定義で、初期値のリストを提供します。"
    },
    {
      "indent": 3,
      "text": "+--------------+------------------+---------------------------------+\n| Tag          | Data Item        | Semantics                       |\n+--------------+------------------+---------------------------------+\n| 0            | UTF-8 string     | Standard date/time string; see  |\n|              |                  | Section 2.4.1                   |\n|              |                  |                                 |\n| 1            | multiple         | Epoch-based date/time; see      |\n|              |                  | Section 2.4.1                   |\n|              |                  |                                 |\n| 2            | byte string      | Positive bignum; see Section    |\n|              |                  | 2.4.2                           |\n|              |                  |                                 |\n| 3            | byte string      | Negative bignum; see Section    |\n|              |                  | 2.4.2                           |\n|              |                  |                                 |\n| 4            | array            | Decimal fraction; see Section   |\n|              |                  | 2.4.3                           |\n|              |                  |                                 |\n| 5            | array            | Bigfloat; see Section 2.4.3     |\n|              |                  |                                 |\n| 6..20        | (Unassigned)     | (Unassigned)                    |\n|              |                  |                                 |\n| 21           | multiple         | Expected conversion to          |\n|              |                  | base64url encoding; see         |\n|              |                  | Section 2.4.4.2                 |\n|              |                  |                                 |\n| 22           | multiple         | Expected conversion to base64   |\n|              |                  | encoding; see Section 2.4.4.2   |\n|              |                  |                                 |\n| 23           | multiple         | Expected conversion to base16   |\n|              |                  | encoding; see Section 2.4.4.2   |\n|              |                  |                                 |\n| 24           | byte string      | Encoded CBOR data item; see     |\n|              |                  | Section 2.4.4.1                 |\n|              |                  |                                 |\n| 25..31       | (Unassigned)     | (Unassigned)                    |\n|              |                  |                                 |\n| 32           | UTF-8 string     | URI; see Section 2.4.4.3        |\n|              |                  |                                 |\n| 33           | UTF-8 string     | base64url; see Section 2.4.4.3  |\n|              |                  |                                 |\n| 34           | UTF-8 string     | base64; see Section 2.4.4.3     |\n|              |                  |                                 |\n| 35           | UTF-8 string     | Regular expression; see         |\n|              |                  | Section 2.4.4.3                 |\n|              |                  |                                 |\n| 36           | UTF-8 string     | MIME message; see Section       |\n|              |                  | 2.4.4.3                         |",
      "raw": true
    },
    {
      "indent": 3,
      "text": "|              |                  |                                 |\n| 37..55798    | (Unassigned)     | (Unassigned)                    |\n|              |                  |                                 |\n| 55799        | multiple         | Self-describe CBOR; see         |\n|              |                  | Section 2.4.5                   |\n|              |                  |                                 |\n| 55800+       | (Unassigned)     | (Unassigned)                    |\n+--------------+------------------+---------------------------------+",
      "raw": true
    },
    {
      "indent": 25,
      "text": "Table 3: Values for Tags",
      "ja": "表3：タグの値"
    },
    {
      "indent": 0,
      "text": "2.4.1. Date and Time",
      "section_title": true,
      "ja": "2.4.1。日時"
    },
    {
      "indent": 3,
      "text": "Tag value 0 is for date/time strings that follow the standard format described in [RFC3339], as refined by Section 3.3 of [RFC4287].",
      "ja": "[RFC4287]のセクション3.3により精製ようにタグ値0は、[RFC3339]に記載されている標準フォーマットに従った日付/時刻文字列のためのものです。"
    },
    {
      "indent": 3,
      "text": "Tag value 1 is for numerical representation of seconds relative to 1970-01-01T00:00Z in UTC time. (For the non-negative values that the Portable Operating System Interface (POSIX) defines, the number of seconds is counted in the same way as for POSIX \"seconds since the epoch\" [TIME_T].) The tagged item can be a positive or negative integer (major types 0 and 1), or a floating-point number (major type 7 with additional information 25, 26, or 27). Note that the number can be negative (time before 1970-01-01T00:00Z) and, if a floating-point number, indicate fractional seconds.",
      "ja": "Tagの値1は、1970-01-01T00に対する秒の数値表現のためである：UTC時間で00Z。 （ポータブルオペレーティングシステムインタフェース（POSIX）が定義され、非負の値の場合、秒数[time_tの「エポック秒」POSIXと同じ方法でカウントされる。）タグ付き項目が正であってもよく、または負の整数（主要なタイプ0と1）、または浮動小数点数（付加情報25、26、又は27の主要なタイプ7）。数値が負であることができることに留意されたい（1970-01-01T00前時間：00Z）と、浮動小数点数の場合、小数秒を示します。"
    },
    {
      "indent": 0,
      "text": "2.4.2. Bignums",
      "section_title": true,
      "ja": "2.4.2。 Bignums"
    },
    {
      "indent": 3,
      "text": "Bignums are integers that do not fit into the basic integer representations provided by major types 0 and 1. They are encoded as a byte string data item, which is interpreted as an unsigned integer n in network byte order. For tag value 2, the value of the bignum is n. For tag value 3, the value of the bignum is -1 - n. Decoders that understand these tags MUST be able to decode bignums that have leading zeroes.",
      "ja": "Bignumsは、それらがネットワークバイト順に符号のない整数nとして解釈されるバイト文字列データ項目として符号化される主要なタイプ0と1によって提供される基本的な整数表現に適合しない整数です。タグ値が2の場合、BIGNUMの値がnです。タグ値3について、BIGNUMの値は-1  -  N。これらのタグを理解するデコーダは、先行ゼロを持っているbignumsをデコードできなければなりません。"
    },
    {
      "indent": 3,
      "text": "For example, the number 18446744073709551616 (2**64) is represented as 0b110_00010 (major type 6, tag 2), followed by 0b010_01001 (major type 2, length 9), followed by 0x010000000000000000 (one byte 0x01 and eight bytes 0x00). In hexadecimal:",
      "ja": "例えば、数18446744073709551616（2 ** 64）0x010000000000000000（1つのバイトが0x01と8つのバイトは0x00）が続く0b010_01001（主要な2型、長さ9）、続いて、0b110_00010（主要なタイプ6、タグ2）のように表されます。進には："
    },
    {
      "indent": 3,
      "text": "C2 -- Tag 2 29 -- Byte string of length 9 010000000000000000 -- Bytes content",
      "ja": "C2  - タグ2 29  - 長さ9 010000000000000000のバイト文字列 - バイトコンテンツ"
    },
    {
      "indent": 0,
      "text": "2.4.3. Decimal Fractions and Bigfloats",
      "section_title": true,
      "ja": "2.4.3。小数とビッグフロート"
    },
    {
      "indent": 3,
      "text": "Decimal fractions combine an integer mantissa with a base-10 scaling factor. They are most useful if an application needs the exact representation of a decimal fraction such as 1.1 because there is no exact representation for many decimal fractions in binary floating point.",
      "ja": "小数は、ベース10スケーリング係数と整数仮数を組み合わせます。 2進浮動小数点で多くの小数のための正確な表現が存在しないため、アプリケーションは、1.1などの小数の正確な表現を必要とする場合、それらは最も有用です。"
    },
    {
      "indent": 3,
      "text": "Bigfloats combine an integer mantissa with a base-2 scaling factor. They are binary floating-point values that can exceed the range or the precision of the three IEEE 754 formats supported by CBOR (Section 2.3). Bigfloats may also be used by constrained applications that need some basic binary floating-point capability without the need for supporting IEEE 754.",
      "ja": "ビッグフロートは、ベース2スケーリング係数と整数仮数を組み合わせます。彼らは、範囲又はCBOR（2.3節）によってサポートされる3つのIEEE 754の形式の精度を超えることができるバイナリ浮動小数点値です。ビッグフロートはまたIEEE 754を支持するために必要とすることなく、いくつかの基本的な二進浮動小数点能力を必要とする制約のあるアプリケーションで使用されてもよいです。"
    },
    {
      "indent": 3,
      "text": "A decimal fraction or a bigfloat is represented as a tagged array that contains exactly two integer numbers: an exponent e and a mantissa m. Decimal fractions (tag 4) use base-10 exponents; the value of a decimal fraction data item is m*(10**e). Bigfloats (tag 5) use base-2 exponents; the value of a bigfloat data item is m*(2**e). The exponent e MUST be represented in an integer of major type 0 or 1, while the mantissa also can be a bignum (Section 2.4.2).",
      "ja": "指数eおよび仮数M：小数またはビッグフロートを正確に2つの整数の番号が含まれているタグ付き配列として表されます。小数（タグ4）はベース10の指数を使用します。小数データ項目の値は、m *（10 ** E）です。ビッグフロート（タグ5）がベース2指数を使用します。ビッグフロートデータ項目の値は、M *（2 ** E）です。仮数もBIGNUM（2.4.2項）することができるが指数eは、主要なタイプ0または1の整数で表現されなければなりません。"
    },
    {
      "indent": 3,
      "text": "An example of a decimal fraction is that the number 273.15 could be represented as 0b110_00100 (major type of 6 for the tag, additional information of 4 for the type of tag), followed by 0b100_00010 (major type of 4 for the array, additional information of 2 for the length of the array), followed by 0b001_00001 (major type of 1 for the first integer, additional information of 1 for the value of -2), followed by 0b000_11001 (major type of 0 for the second integer, additional information of 25 for a two-byte value), followed by 0b0110101010110011 (27315 in two bytes). In hexadecimal:",
      "ja": "小数の例は、数273.15は、アレイ4の0b100_00010（主要な種類、付加情報続いて、0b110_00100（タグ6の主要なタイプ、タグのタイプ4の付加情報）として表すことができることです配列の長さ2）の、第2の整数0の0b000_11001（主要な種類、付加情報続いて、最初の整数は1の0b001_00001（主要なタイプ、値-2 1の付加情報）が続きます2バイト値25）の、0b0110101010110011（27315 2バイト）が続きます。進には："
    },
    {
      "indent": 3,
      "text": "C4 -- Tag 4 82 -- Array of length 2 21 -- -2 19 6ab3 -- 27315",
      "ja": "C4  - タグ4 82  - 長さのアレイ2 21  -  19 -2 6ab3  -  27315"
    },
    {
      "indent": 3,
      "text": "An example of a bigfloat is that the number 1.5 could be represented as 0b110_00101 (major type of 6 for the tag, additional information of 5 for the type of tag), followed by 0b100_00010 (major type of 4 for the array, additional information of 2 for the length of the array), followed by 0b001_00000 (major type of 1 for the first integer, additional information of 0 for the value of -1), followed by 0b000_00011 (major type of 0 for the second integer, additional information of 3 for the value of 3). In hexadecimal:",
      "ja": "ビッグフロートの例は、数1.5アレイ4の0b100_00010（主要なタイプ、追加の情報、続い0b110_00101（タグ6の主要なタイプ、タグのタイプ5の付加情報）として表すことができることです第整数0の0b000_00011（主要な種類の付加情報が続く最初の整数1の0b001_00000（主要なタイプ-1の値が0の付加情報）が続く配列の長さ）、2 3の値は3）。進には："
    },
    {
      "indent": 3,
      "text": "C5 -- Tag 5 82 -- Array of length 2 20 -- -1 03 -- 3",
      "ja": "C5  - タグ5 82  - 長さのアレイ2 20  -  -1 03から3"
    },
    {
      "indent": 3,
      "text": "Decimal fractions and bigfloats provide no representation of Infinity, -Infinity, or NaN; if these are needed in place of a decimal fraction or bigfloat, the IEEE 754 half-precision representations from Section 2.3 can be used. For constrained applications, where there is a choice between representing a specific number as an integer and as a decimal fraction or bigfloat (such as when the exponent is small and non-negative), there is a quality-of-implementation expectation that the integer representation is used directly.",
      "ja": "小数とビッグフロートは無限、-Infinity、またはNaNのない表現を提供しません。これらは小数またはビッグフロートの代わりに、必要な場合は、2.3節からIEEE 754半精度表現を使用することができます。整数として特定の数を表すと（例えば指数が小さく、非負である場合など）小数またはビッグフロートなどの選択がある制約のあるアプリケーションについては、整数その品質の-実装期待されています表現が直接使用されます。"
    },
    {
      "indent": 0,
      "text": "2.4.4. Content Hints",
      "section_title": true,
      "ja": "2.4.4。コンテンツのヒント"
    },
    {
      "indent": 3,
      "text": "The tags in this section are for content hints that might be used by generic CBOR processors.",
      "ja": "このセクション内のタグは、一般的なCBORプロセッサによって使用されるかもしれないコンテンツのヒントのためのものです。"
    },
    {
      "indent": 0,
      "text": "2.4.4.1. Encoded CBOR Data Item",
      "section_title": true,
      "ja": "2.4.4.1。エンコードされたCBORデータ項目"
    },
    {
      "indent": 3,
      "text": "Sometimes it is beneficial to carry an embedded CBOR data item that is not meant to be decoded immediately at the time the enclosing data item is being parsed. Tag 24 (CBOR data item) can be used to tag the embedded byte string as a data item encoded in CBOR format.",
      "ja": "場合によっては、包囲データ項目が解析された時点で即座に復号化されることを意図されていない埋め込みCBORデータアイテムを運ぶために有益です。タグ24は、（CBORデータ項目）CBOR形式で符号化されたデータ項目として埋め込まれたバイト列をタグ付けするために使用することができます。"
    },
    {
      "indent": 0,
      "text": "2.4.4.2. Expected Later Encoding for CBOR-to-JSON Converters",
      "section_title": true,
      "ja": "2.4.4.2。 CBORツーJSONコンバータの予想その後エンコーディング"
    },
    {
      "indent": 3,
      "text": "Tags 21 to 23 indicate that a byte string might require a specific encoding when interoperating with a text-based representation. These tags are useful when an encoder knows that the byte string data it is writing is likely to be later converted to a particular JSON-based usage. That usage specifies that some strings are encoded as base64, base64url, and so on. The encoder uses byte strings instead of doing the encoding itself to reduce the message size, to reduce the code size of the encoder, or both. The encoder does not know whether or not the converter will be generic, and therefore wants to say what it believes is the proper way to convert binary strings to JSON.",
      "ja": "タグ21〜23は、テキストベースの表現と相互運用する場合、バイト文字列が特定のエンコーディングを必要とするかもしれないことを示しています。エンコーダは、それが書いているバイト列データは、後に特定のJSONベースの使用に変換可能性があることを知っているとき、これらのタグは便利です。その使用量は、文字列の一部がようにbase64で、base64url、およびとしてエンコードされていることを指定します。エンコーダは、エンコーダ、または両方のコードサイズを低減するために、代わりにメッセージのサイズを減少させるために符号化自体を行うためのバイト列を使用します。エンコーダは、コンバータがジェネリックになるかどうかを知っているので、それはJSONへのバイナリ文字列を変換するための適切な方法であると考えて何を言いたいしません。"
    },
    {
      "indent": 3,
      "text": "The data item tagged can be a byte string or any other data item. In the latter case, the tag applies to all of the byte string data items contained in the data item, except for those contained in a nested data item tagged with an expected conversion.",
      "ja": "タグ付けされたデータ項目は、バイト文字列または任意の他のデータ項目することができます。後者の場合、タグは、予想される変換でタグ付けされたネストされたデータ項目に含まれているものを除いて、データ項目に含まれるバイト列のデータ項目の全てに適用されます。"
    },
    {
      "indent": 3,
      "text": "These three tag types suggest conversions to three of the base data encodings defined in [RFC4648]. For base64url encoding, padding is not used (see Section 3.2 of RFC 4648); that is, all trailing equals",
      "ja": "これら三つのタグタイプは、[RFC4648]で定義された基本データエンコーディングの3つに変換を示唆しています。 base64url符号化のために、パディングは使用されない（RFC 4648のセクション3.2を参照）。それは、すべての後続イコールであります"
    },
    {
      "indent": 3,
      "text": "signs (\"=\") are removed from the base64url-encoded string. Later tags might be defined for other data encodings of RFC 4648 or for other ways to encode binary data in strings.",
      "ja": "記号（「=」）はbase64urlエンコードされた文字列から除去されます。その後、タグは、RFC 4648の他のデータのエンコーディングまたは文字列にバイナリデータをエンコードする他の方法のために定義される可能性があります。"
    },
    {
      "indent": 0,
      "text": "2.4.4.3. Encoded Text",
      "section_title": true,
      "ja": "2.4.4.3。エンコードされたテキスト"
    },
    {
      "indent": 3,
      "text": "Some text strings hold data that have formats widely used on the Internet, and sometimes those formats can be validated and presented to the application in appropriate form by the decoder. There are tags for some of these formats.",
      "ja": "いくつかのテキスト文字列は、インターネットで広く使用されるフォーマットを有するデータを保持し、時にはそれらのフォーマットは検証および復号器によって適切な形でアプリケーションに提示することができます。これらのフォーマットのいくつかのためのタグがあります。"
    },
    {
      "indent": 3,
      "text": "o Tag 32 is for URIs, as defined in [RFC3986];",
      "ja": "Oタグ32は、[RFC3986]で定義されるように、URIのためのものです。"
    },
    {
      "indent": 3,
      "text": "o Tags 33 and 34 are for base64url- and base64-encoded text strings, as defined in [RFC4648];",
      "ja": "[RFC4648]で定義されるように、Oタグ33及び34は、base64url-とbase64エンコードテキスト文字列のためのものです。"
    },
    {
      "indent": 3,
      "text": "o Tag 35 is for regular expressions in Perl Compatible Regular Expressions (PCRE) / JavaScript syntax [ECMA262].",
      "ja": "Oタグ35は、Perl互換正規表現の正規表現（PCRE）のためである/ JavaScriptのシンタックス[ECMA262]。"
    },
    {
      "indent": 3,
      "text": "o Tag 36 is for MIME messages (including all headers), as defined in [RFC2045];",
      "ja": "Oタグ36は、[RFC2045]で定義されるように、（すべてのヘッダを含む）MIMEメッセージのためのものです。"
    },
    {
      "indent": 3,
      "text": "Note that tags 33 and 34 differ from 21 and 22 in that the data is transported in base-encoded form for the former and in raw byte string form for the latter.",
      "ja": "33と34をタグ注21及び22からのデータは、前者と後者の生のバイト文字列形式でベース符号化された形で搬送さが異なります。"
    },
    {
      "indent": 0,
      "text": "2.4.5. Self-Describe CBOR",
      "section_title": true,
      "ja": "2.4.5。 CBORを自己説明"
    },
    {
      "indent": 3,
      "text": "In many applications, it will be clear from the context that CBOR is being employed for encoding a data item. For instance, a specific protocol might specify the use of CBOR, or a media type is indicated that specifies its use. However, there may be applications where such context information is not available, such as when CBOR data is stored in a file and disambiguating metadata is not in use. Here, it may help to have some distinguishing characteristics for the data itself.",
      "ja": "多くの用途では、CBORデータ項目を符号化するために用いられている文脈から明らかであろう。例えば、特定のプロトコルはCBORの使用を指定したり、メディアの種類は、その使用を指定することが示されています。しかしながら、そのようなCBORデータがファイルに格納されたメタデータを明確化すると、使用中でないときのようなコンテキスト情報が利用できないアプリケーションがあってもよいです。ここでは、データ自体のためのいくつかの顕著な特徴を持っているのに役立つことがあります。"
    },
    {
      "indent": 3,
      "text": "Tag 55799 is defined for this purpose. It does not impart any special semantics on the data item that follows; that is, the semantics of a data item tagged with tag 55799 is exactly identical to the semantics of the data item itself.",
      "ja": "タグ55799は、この目的のために定義されています。これは、次のデータ項目に特別な意味を付与しません。つまり、タグ55799でタグ付けされたデータ項目の意味は、データ項目自体の意味論と全く同じです。"
    },
    {
      "indent": 3,
      "text": "The serialization of this tag is 0xd9d9f7, which appears not to be in use as a distinguishing mark for frequently used file types. In particular, it is not a valid start of a Unicode text in any Unicode encoding if followed by a valid CBOR data item.",
      "ja": "このタグのシリアル化が頻繁に使用されるファイルの種類の特徴的なマークとして使用中ではないと思われる、0xd9d9f7です。有効なCBORデータ項目が続く場合は特に、それは、任意のUnicodeエンコーディングでのUnicodeテキストの有効なスタートではありません。"
    },
    {
      "indent": 3,
      "text": "For instance, a decoder might be able to parse both CBOR and JSON. Such a decoder would need to mechanically distinguish the two formats. An easy way for an encoder to help the decoder would be to tag the entire CBOR item with tag 55799, the serialization of which will never be found at the beginning of a JSON text.",
      "ja": "例えば、デコーダはCBORとJSONの両方を解析することができるかもしれません。そのようなデコーダは、機械的に二つのフォーマットを区別する必要があります。デコーダを支援するためのエンコーダのための簡単な方法は、タグ55799と全体CBORアイテムにタグ付けすることであろう、の直列化はJSONテキストの先頭で発見されることはありません。"
    },
    {
      "indent": 0,
      "text": "3. Creating CBOR-Based Protocols",
      "section_title": true,
      "ja": "3. CBORベースのプロトコルを作成します"
    },
    {
      "indent": 3,
      "text": "Data formats such as CBOR are often used in environments where there is no format negotiation. A specific design goal of CBOR is to not need any included or assumed schema: a decoder can take a CBOR item and decode it with no other knowledge.",
      "ja": "このようCBORなどのデータ形式は、多くの場合、何の形式のネゴシエーションが存在しない環境で使用されています。デコーダはCBORアイテムを取るとなし、他の知識とそれをデコードすることができます。CBORの具体的な設計目標は、任意の付属または想定したスキーマを必要としないことです。"
    },
    {
      "indent": 3,
      "text": "Of course, in real-world implementations, the encoder and the decoder will have a shared view of what should be in a CBOR data item. For example, an agreed-to format might be \"the item is an array whose first value is a UTF-8 string, second value is an integer, and subsequent values are zero or more floating-point numbers\" or \"the item is a map that has byte strings for keys and contains at least one pair whose key is 0xab01\".",
      "ja": "もちろん、現実世界の実装では、エンコーダおよびデコーダはCBORデータ項目にどうあるべきかの共有ビューを持つことになります。例えば、合意にフォーマットかもしれない「の項目は、その最初の値UTF-8文字列で配列され、第二の値は整数であり、後続の値は、ゼロ以上の浮動小数点数である」または「項目でありますキーのバイト列を持っており、そのキー0xab01\" であるとは、少なくとも1つのペアを含むマップ。"
    },
    {
      "indent": 3,
      "text": "This specification puts no restrictions on CBOR-based protocols. An encoder can be capable of encoding as many or as few types of values as is required by the protocol in which it is used; a decoder can be capable of understanding as many or as few types of values as is required by the protocols in which it is used. This lack of restrictions allows CBOR to be used in extremely constrained environments.",
      "ja": "この仕様はCBORベースのプロトコルに制限をかけていません。エンコーダは、多くのように、またはそれが使用されるプロトコルによって必要とされる値のいくつかのタイプとして符号化することが可能であることができます。デコーダは、それが使用されるプロトコルによって必要とされる値の多く又は少ない種類として理解することが可能であることができます。規制の欠如はCBORは非常に限られた環境で使用することができます。"
    },
    {
      "indent": 3,
      "text": "This section discusses some considerations in creating CBOR-based protocols. It is advisory only and explicitly excludes any language from RFC 2119 other than words that could be interpreted as \"MAY\" in the sense of RFC 2119.",
      "ja": "このセクションでは、CBORベースのプロトコルを作成する際に、いくつかの考慮事項について説明します。それだけで、明示的助言である「MAY」RFC 2119の意味であると解釈することができた単語以外のRFC 2119から任意の言語を除外します。"
    },
    {
      "indent": 0,
      "text": "3.1. CBOR in Streaming Applications",
      "section_title": true,
      "ja": "3.1。ストリーミングアプリケーションでCBOR"
    },
    {
      "indent": 3,
      "text": "In a streaming application, a data stream may be composed of a sequence of CBOR data items concatenated back-to-back. In such an environment, the decoder immediately begins decoding a new data item if data is found after the end of a previous data item.",
      "ja": "ストリーミングアプリケーションでは、データストリームは、バックツーバック連結CBORデータアイテムのシーケンスで構成されてもよいです。データが以前のデータ項目の終わりの後に発見された場合、このような環境では、デコーダは、直ちに新たなデータ項目を復号化し始めます。"
    },
    {
      "indent": 3,
      "text": "Not all of the bytes making up a data item may be immediately available to the decoder; some decoders will buffer additional data until a complete data item can be presented to the application. Other decoders can present partial information about a top-level data item to an application, such as the nested data items that could already be decoded, or even parts of a byte string that hasn't completely arrived yet.",
      "ja": "全てのデータ項目を構成するバイトは、デコーダに直ちに利用可能であってもよいです。完全なデータ項目がアプリケーションに提示できるようになるまで、いくつかのデコーダは、追加のデータをバッファリングします。他のデコーダは、既に復号化することができ、ネストされたデータ項目としてアプリケーション、または完全にまだ到着していないバイト列の偶数部分にトップレベルのデータ項目に関する部分的な情報を提示することができます。"
    },
    {
      "indent": 3,
      "text": "Note that some applications and protocols will not want to use indefinite-length encoding. Using indefinite-length encoding allows an encoder to not need to marshal all the data for counting, but it requires a decoder to allocate increasing amounts of memory while waiting for the end of the item. This might be fine for some applications but not others.",
      "ja": "いくつかのアプリケーションやプロトコルが不定長のエンコーディングを使用したくないことに注意してください。不定長エンコーディングを使用するエンコーダを計数のためにすべてのデータをマーシャリングする必要がないようにできますが、アイテムの終了を待っている間には、メモリの増加量を割り当てるようにデコーダを必要とします。これは、一部のアプリケーションではなく、他人のために細かいかもしれません。"
    },
    {
      "indent": 0,
      "text": "3.2. Generic Encoders and Decoders",
      "section_title": true,
      "ja": "3.2。ジェネリックエンコーダとデコーダ"
    },
    {
      "indent": 3,
      "text": "A generic CBOR decoder can decode all well-formed CBOR data and present them to an application. CBOR data is well-formed if it uses the initial bytes, as well as the byte strings and/or data items that are implied by their values, in the manner defined by CBOR, and no extraneous data follows (Appendix C).",
      "ja": "ジェネリックCBORデコーダは、すべての整形CBORデータをデコードし、アプリケーションにそれらを提示することができます。それはCBORによって定義されたように、最初のバイト、ならびにそれらの値によって暗示されるバイト文字列及び/又はデータ・アイテムを使用して、無関係なデータ（付録C）以下のない場合CBORデータは、整形式です。"
    },
    {
      "indent": 3,
      "text": "Even though CBOR attempts to minimize these cases, not all well-formed CBOR data is valid: for example, the format excludes simple values below 32 that are encoded with an extension byte. Also, specific tags may make semantic constraints that may be violated, such as by including a tag in a bignum tag or by following a byte string within a date tag. Finally, the data may be invalid, such as invalid UTF-8 strings or date strings that do not conform to [RFC3339]. There is no requirement that generic encoders and decoders make unnatural choices for their application interface to enable the processing of invalid data. Generic encoders and decoders are expected to forward simple values and tags even if their specific codepoints are not registered at the time the encoder/decoder is written (Section 3.5).",
      "ja": "CBORはこれらのケースを最小化しようとしていても、必ずしもすべての整形CBORデータが有効である：例えば、フォーマットは、拡張バイトで符号化された32以下の単純な値を除外する。また、特定のタグがBIGNUMタグや日付タグ内のバイトの文字列を、次のことで、タグを含めることによって、のような違反することができる意味制約を行うことができます。最後に、データは、[RFC3339]に準拠していない不正なUTF-8文字列や日付文字列として、無効になることがあります。ジェネリックエンコーダとデコーダは、無効なデータの処理を可能にするために彼らのアプリケーションインタフェースのための不自然な選択を行う必要はありません。一般的なエンコーダおよびデコーダは、単純な値とその特定のコードポイントは、エンコーダ/デコーダが書き込まれた時点（3.5節）に登録されていない場合でも、タグを転送することが期待されます。"
    },
    {
      "indent": 3,
      "text": "Generic decoders provide ways to present well-formed CBOR values, both valid and invalid, to an application. The diagnostic notation (Section 6) may be used to present well-formed CBOR values to humans.",
      "ja": "汎用デコーダは、アプリケーションに、有効および無効の両方整形CBOR値を提示する方法を提供します。診断表記（第6節）は、ヒトに整形CBOR値を提示するために使用されてもよいです。"
    },
    {
      "indent": 3,
      "text": "Generic encoders provide an application interface that allows the application to specify any well-formed value, including simple values and tags unknown to the encoder.",
      "ja": "一般的なエンコーダは、アプリケーションがエンコーダに未知の単純な値とタグを含む任意の整形式の値を指定することを可能にするアプリケーションインタフェースを提供します。"
    },
    {
      "indent": 0,
      "text": "3.3. Syntax Errors",
      "section_title": true,
      "ja": "3.3。構文エラー"
    },
    {
      "indent": 3,
      "text": "A decoder encountering a CBOR data item that is not well-formed generally can choose to completely fail the decoding (issue an error and/or stop processing altogether), substitute the problematic data and data items using a decoder-specific convention that clearly indicates there has been a problem, or take some other action.",
      "ja": "完全に復号化に失敗することを選択することができ、一般的に十分に形成されていないCBORデータ項目に遭遇するデコーダは明らかに存在示しデコーダ固有の規則を使用して問題のデータとデータ項目を置き換え、（エラーを発行し、および/または完全に停止処理します）問題となって、または他のいくつかの行動を取るました。"
    },
    {
      "indent": 0,
      "text": "3.3.1. Incomplete CBOR Data Items",
      "section_title": true,
      "ja": "3.3.1。不完全CBORデータ項目"
    },
    {
      "indent": 3,
      "text": "The representation of a CBOR data item has a specific length, determined by its initial bytes and by the structure of any data items enclosed in the data items. If less data is available, this can be treated as a syntax error. A decoder may also implement incremental parsing, that is, decode the data item as far as it is available and present the data found so far (such as in an event-based interface), with the option of continuing the decoding once further data is available.",
      "ja": "CBORデータ項目の表現は、その最初のバイトとデータ項目で囲まれた任意のデータ項目の構造によって決定される、特定の長さを有しています。少ないデータが利用可能な場合、これは構文エラーとして扱うことができます。デコーダはまた、それが利用可能である限り、データ項目を復号化、すなわち、インクリメンタル解析を実施し、一度さらにデータが復号化を継続するオプションを使用して、これまでに（このようなイベントベースのインタフェースのように）検出されたデータを提示することができます利用可能。"
    },
    {
      "indent": 3,
      "text": "Examples of incomplete data items include:",
      "ja": "不完全なデータ項目の例としては、"
    },
    {
      "indent": 3,
      "text": "o A decoder expects a certain number of array or map entries but instead encounters the end of the data.",
      "ja": "Oデコーダはアレイまたはマップエントリの特定の数を見込んではなく、データの最後に遭遇しました。"
    },
    {
      "indent": 3,
      "text": "o A decoder processes what it expects to be the last pair in a map and comes to the end of the data.",
      "ja": "Oデコーダは、それがマップの最後のペアであることを期待し、データの最後に来るもの処理します。"
    },
    {
      "indent": 3,
      "text": "o A decoder has just seen a tag and then encounters the end of the data.",
      "ja": "Oデコーダは単にタグを見て、データの最後に遭遇しました。"
    },
    {
      "indent": 3,
      "text": "o A decoder has seen the beginning of an indefinite-length item but encounters the end of the data before it sees the \"break\" stop code.",
      "ja": "Oデコーダは、不定長の項目の先頭を見たが、それは「ブレイク」ストップコードを認識する前に、データの終わりに遭遇しました。"
    },
    {
      "indent": 0,
      "text": "3.3.2. Malformed Indefinite-Length Items",
      "section_title": true,
      "ja": "3.3.2。不正な形式の不定長のアイテム"
    },
    {
      "indent": 3,
      "text": "Examples of malformed indefinite-length data items include:",
      "ja": "不正な不定長のデータ項目の例としては、"
    },
    {
      "indent": 3,
      "text": "o Within an indefinite-length byte string or text, a decoder finds an item that is not of the appropriate major type before it finds the \"break\" stop code.",
      "ja": "不定長のバイトストリングまたはテキスト内O、デコーダは、それが「ブレーク」ストップコードを発見する前に、適切な主要な型ではないアイテムを見つけます。"
    },
    {
      "indent": 3,
      "text": "o Within an indefinite-length map, a decoder encounters the \"break\" stop code immediately after reading a key (the value is missing).",
      "ja": "不定長のマップ内のO、デコーダは、直ちにキー（値が欠落している）を読んだ後に「ブレーク」ストップコードを検出しました。"
    },
    {
      "indent": 3,
      "text": "Another error is finding a \"break\" stop code at a point in the data where there is no immediately enclosing (unclosed) indefinite-length item.",
      "ja": "別のエラーには直ちに囲む（閉じていない）不定長の項目が存在しないデータのポイントに「ブレーク」ストップコードを見つけることです。"
    },
    {
      "indent": 0,
      "text": "3.3.3. Unknown Additional Information Values",
      "section_title": true,
      "ja": "3.3.3。不明な追加情報の値"
    },
    {
      "indent": 3,
      "text": "At the time of writing, some additional information values are unassigned and reserved for future versions of this document (see Section 5.2). Since the overall syntax for these additional information values is not yet defined, a decoder that sees an additional information value that it does not understand cannot continue parsing.",
      "ja": "執筆時点では、いくつかの追加情報の値が割り当てられていないと、このドキュメントの将来のバージョン（5.2節を参照）のために予約されています。これらの追加情報値のための全体的な構文はまだ定義されていないので、それは理解していない付加的な情報価値を見ているデコーダは、構文解析を続行できません。"
    },
    {
      "indent": 0,
      "text": "3.4. Other Decoding Errors",
      "section_title": true,
      "ja": "3.4。他のデコード・エラー"
    },
    {
      "indent": 3,
      "text": "A CBOR data item may be syntactically well-formed but present a problem with interpreting the data encoded in it in the CBOR data model. Generally speaking, a decoder that finds a data item with such a problem might issue a warning, might stop processing altogether, might handle the error and make the problematic value available to the application as such, or take some other type of action.",
      "ja": "CBORデータ項目は、構文的に整形式であるが、CBORデータモデルで、その中に符号化されたデータの解釈に問題を提示してもよいです。一般的に、警告を出すかもしれないような問題にデータ項目を見つけたデコーダを言えば、エラーを処理し、のようなアプリケーションに問題のある値を利用できるようにする、またはアクションの他のいくつかの種類がかかる場合があります、完全に処理を停止する場合があります。"
    },
    {
      "indent": 3,
      "text": "Such problems might include:",
      "ja": "このような問題が含まれる場合があります。"
    },
    {
      "indent": 3,
      "text": "Duplicate keys in a map: Generic decoders (Section 3.2) make data available to applications using the native CBOR data model. That data model includes maps (key-value mappings with unique keys), not multimaps (key-value mappings where multiple entries can have the same key). Thus, a generic decoder that gets a CBOR map item that has duplicate keys will decode to a map with only one instance of that key, or it might stop processing altogether. On the other hand, a \"streaming decoder\" may not even be able to notice (Section 3.7).",
      "ja": "マップ内の重複するキー：一般的なデコーダ（3.2節）は、ネイティブCBORデータモデルを使用してアプリケーションにデータを利用できるようにします。このデータモデルは、マップ（一意キーとキーと値のマッピング）、（複数のエントリは、同じキーを持つことができ、キーと値のマッピング）ではないmultimapのを含んでいます。従って、重複キーを有するCBORマップアイテムを取得する一般的なデコーダは、そのキーの唯一のインスタンスにマップをデコードする、またはそれが完全に処理を停止する可能性があります。一方、「ストリーミングデコーダは」偶数（セクション3.7）に気づくことができないかもしれません。"
    },
    {
      "indent": 3,
      "text": "Inadmissible type on the value following a tag: Tags (Section 2.4) specify what type of data item is supposed to follow the tag; for example, the tags for positive or negative bignums are supposed to be put on byte strings. A decoder that decodes the tagged data item into a native representation (a native big integer in this example) is expected to check the type of the data item being tagged. Even decoders that don't have such native representations available in their environment may perform the check on those tags known to them and react appropriately.",
      "ja": "タグの次の値の許容できないタイプ：タグ（2.4節）は、タグをたどることになっているデータ項目の種類を指定します。例えば、正または負のbignumsのためのタグがバイト文字列を置くことになっています。ネイティブ表現（この例では、ネイティブ大きな整数）にタグ付けされたデータ項目をデコードするデコーダは、タグ付けされているデータ項目の種類を確認することが期待されます。自分の環境で利用可能なネイティブな表現を持っていなくても、デコーダは、彼らに知られているこれらのタグにチェックを実行し、適切に反応することができます。"
    },
    {
      "indent": 3,
      "text": "Invalid UTF-8 string: A decoder might or might not want to verify that the sequence of bytes in a UTF-8 string (major type 3) is actually valid UTF-8 and react appropriately.",
      "ja": "無効なUTF-8文字列：デコーダがまたはUTF-8文字列（メジャータイプ3）のバイトシーケンスが実際に有効なUTF-8であると適切に反応することを確認する必要はない場合があります。"
    },
    {
      "indent": 0,
      "text": "3.5. Handling Unknown Simple Values and Tags",
      "section_title": true,
      "ja": "3.5。不明な単純な値とタグの処理"
    },
    {
      "indent": 3,
      "text": "A decoder that comes across a simple value (Section 2.3) that it does not recognize, such as a value that was added to the IANA registry after the decoder was deployed or a value that the decoder chose not to implement, might issue a warning, might stop processing altogether, might handle the error by making the unknown value available to the application as such (as is expected of generic decoders), or take some other type of action.",
      "ja": "そのようなデコーダがデプロイされた後にIANAレジストリに追加された値または値として、それは認識していないという単純な値（2.3節）に出くわすデコーダは、デコーダが実装しないことを選択したことを、警告を出すかもしれません、 、完全に処理を停止する場合があります（一般的なデコーダを期待されているもの）などのアプリケーションに未知の値を利用可能にすることによって、エラーを処理したり、アクションの他のいくつかのタイプを取ります。"
    },
    {
      "indent": 3,
      "text": "A decoder that comes across a tag (Section 2.4) that it does not recognize, such as a tag that was added to the IANA registry after the decoder was deployed or a tag that the decoder chose not to implement, might issue a warning, might stop processing altogether, might handle the error and present the unknown tag value together with the contained data item to the application (as is expected of generic decoders), might ignore the tag and simply present the contained data item only to the application, or take some other type of action.",
      "ja": "それは、そのようなデコーダをデプロイした後にIANAレジストリに追加されたタグまたはデコーダが実装しないことを選択したタグとして、認識されない警告を出すかもしれない、かもしれないというタグ（2.4節）に出くわすデコーダ完全に処理を停止する、エラーを処理し、（汎用デコーダが期待されているように）アプリケーションに含まれているデータ項目と一緒に未知のタグ値を提示し、タグを無視し、単に唯一のアプリケーションに含まれるデータ項目を提示し、又はとる場合がありますアクションのいくつかの他のタイプ。"
    },
    {
      "indent": 0,
      "text": "3.6. Numbers",
      "section_title": true,
      "ja": "3.6。数字"
    },
    {
      "indent": 3,
      "text": "For the purposes of this specification, all number representations for the same numeric value are equivalent. This means that an encoder can encode a floating-point value of 0.0 as the integer 0. It, however, also means that an application that expects to find integer values only might find floating-point values if the encoder decides these are desirable, such as when the floating-point value is more compact than a 64-bit integer.",
      "ja": "本明細書の目的のために、同じ数値のためのすべての数値表現は等価です。これは、エンコーダが0の整数として0.0の浮動小数点値を符号化することができることを意味し、しかし、また、エンコーダは、これらが望ましいことを決定した場合、整数値を見つけることを期待アプリケーションのみ浮動小数点値を見つけるかもしれないことを意味します浮動小数点値は64ビット整数よりもコンパクトである場合など。"
    },
    {
      "indent": 3,
      "text": "An application or protocol that uses CBOR might restrict the representations of numbers. For instance, a protocol that only deals with integers might say that floating-point numbers may not be used and that decoders of that protocol do not need to be able to handle floating-point numbers. Similarly, a protocol or application that uses CBOR might say that decoders need to be able to handle either type of number.",
      "ja": "CBORを使用するアプリケーションやプロトコルは、数字の表現を制限する場合があります。例えば、整数のみを扱うプロトコルは、浮動小数点数が使用できない可能性があることと、そのプロトコルのデコーダは浮動小数点数を扱うことができるようにする必要がないことを言うかもしれません。同様に、CBORを使用するプロトコルやアプリケーションは、デコーダは、数のいずれかのタイプを処理できるようにする必要があると言うかもしれません。"
    },
    {
      "indent": 3,
      "text": "CBOR-based protocols should take into account that different language environments pose different restrictions on the range and precision of numbers that are representable. For example, the JavaScript number system treats all numbers as floating point, which may result in silent loss of precision in decoding integers with more than 53 significant bits. A protocol that uses numbers should define its expectations on the handling of non-trivial numbers in decoders and receiving applications.",
      "ja": "CBORベースのプロトコルは、異なる言語環境が表現されている番号の範囲と精度の異なる制限を課すことを考慮に入れる必要があります。例えば、JavaScriptの数のシステムは、複数の53の最下位ビットと整数を復号精度のサイレント損失をもたらす可能性が浮動小数点などのすべての数字を扱います。番号はデコーダと受信アプリケーションで非自明な数の取り扱い上の期待を定義する必要が使用するプロトコル。"
    },
    {
      "indent": 3,
      "text": "A CBOR-based protocol that includes floating-point numbers can restrict which of the three formats (half-precision, single-precision, and double-precision) are to be supported. For an integer-only application, a protocol may want to completely exclude the use of floating-point values.",
      "ja": "浮動小数点数がサポートされる3つのフォーマット（半精度、単精度および倍精度）のかを制限することができる含むCBORベースのプロトコル。整数のみの適用のために、プロトコルが完全に浮動小数点値を使用することを排除することができます。"
    },
    {
      "indent": 3,
      "text": "A CBOR-based protocol designed for compactness may want to exclude specific integer encodings that are longer than necessary for the application, such as to save the need to implement 64-bit integers. There is an expectation that encoders will use the most compact integer representation that can represent a given value. However, a compact application should accept values that use a longer-than-needed encoding (such as encoding \"0\" as 0b000_11101 followed by two bytes of 0x00) as long as the application can decode an integer of the given size.",
      "ja": "コンパクトのために設計されCBORベースのプロトコルは、64ビット整数を実装する必要性を保存するなどの用途のために必要以上に長くある特定の整数のエンコーディングを、除外することもできます。エンコーダが所与の値を表すことができる最もコンパクトな整数表現を使用する期待があります。しかし、小型のアプリケーションであれば、アプリケーションは、所与のサイズの整数を復号することができるように（0×00の2つのバイトが続く0b000_11101ような符号「0」という）よりも長い必要なエンコードを使用値を受け入れるべきです。"
    },
    {
      "indent": 0,
      "text": "3.7. Specifying Keys for Maps",
      "section_title": true,
      "ja": "3.7。マップのキーを指定します"
    },
    {
      "indent": 3,
      "text": "The encoding and decoding applications need to agree on what types of keys are going to be used in maps. In applications that need to interwork with JSON-based applications, keys probably should be limited to UTF-8 strings only; otherwise, there has to be a specified mapping from the other CBOR types to Unicode characters, and this often leads to implementation errors. In applications where keys are numeric in nature and numeric ordering of keys is important to the application, directly using the numbers for the keys is useful.",
      "ja": "符号化と復号化のアプリケーションは、マップで使用されようとしているキーの種類に同意する必要があります。 JSONベースのアプリケーションと相互作用する必要があるアプリケーションでは、キーは、おそらく唯一のUTF-8文字列に限定すべきです。それ以外の場合は、Unicode文字に他のCBORタイプから指定されたマッピングが存在しなければならない、これは多くの場合、実装エラーにつながります。キーは、自然の中での数字であり、キーの数値の順序がアプリケーションにとって重要であるアプリケーションでは、直接キーの番号を使用すると便利です。"
    },
    {
      "indent": 3,
      "text": "If multiple types of keys are to be used, consideration should be given to how these types would be represented in the specific programming environments that are to be used. For example, in JavaScript objects, a key of integer 1 cannot be distinguished from a key of string \"1\". This means that, if integer keys are used, the simultaneous use of string keys that look like numbers needs to be avoided. Again, this leads to the conclusion that keys should be of a single CBOR type.",
      "ja": "キーの複数の種類を使用する場合、考慮すべき点は、これらのタイプが使用される特定のプログラミング環境で表現される方法に与えられるべきです。例えば、JavaScriptオブジェクトで、整数1のキーは、文字列「1」のキーと区別することはできません。これは、整数キーが使用されている場合は、数字のように見える文字列キーの同時使用は避ける必要がある、ということを意味します。繰り返しますが、これはキーが単一CBORタイプのものでなければならないという結論につながります。"
    },
    {
      "indent": 3,
      "text": "Decoders that deliver data items nested within a CBOR data item immediately on decoding them (\"streaming decoders\") often do not keep the state that is necessary to ascertain uniqueness of a key in a map. Similarly, an encoder that can start encoding data items before the enclosing data item is completely available (\"streaming encoder\") may want to reduce its overhead significantly by relying on its data source to maintain uniqueness.",
      "ja": "すぐに（「ストリーミングデコーダ」）、それらをデコードする上CBORデータ項目内にネストされたデータ項目を提供するデコーダは、多くの場合、マップ内のキーの一意性を確認する必要がある状態を保持しません。同様に、包囲データ項目（「ストリーミングエンコーダ」）完全に利用可能になる前にデータ項目をコードし始めることができるエンコーダは、一意性を維持するために、そのデータ・ソースに依存することによって大幅にオーバーヘッドを削減することができます。"
    },
    {
      "indent": 3,
      "text": "A CBOR-based protocol should make an intentional decision about what to do when a receiving application does see multiple identical keys in a map. The resulting rule in the protocol should respect the CBOR data model: it cannot prescribe a specific handling of the entries with the identical keys, except that it might have a rule that having identical keys in a map indicates a malformed map and that the decoder has to stop with an error. Duplicate keys are also prohibited by CBOR decoders that are using strict mode (Section 3.10).",
      "ja": "CBORベースのプロトコルは、受信側のアプリケーションは、マップ内の複数の同一のキーを見ないときに何をすべきかについての意図的な決定を下す必要があります。プロトコルで得られた規則はCBORデータモデルを尊重すべきである：それはマップに同じキーを有する不正なマップを示しているルールを有し、デコーダが有するかもしれないことを除いては、同一のキーを持つエントリの特定の取り扱いを規定することができませんエラーで停止します。重複キーはまた、厳密モード（3.10）を使用しているCBORデコーダによって禁止されています。"
    },
    {
      "indent": 3,
      "text": "The CBOR data model for maps does not allow ascribing semantics to the order of the key/value pairs in the map representation. Thus, it would be a very bad practice to define a CBOR-based protocol in such a way that changing the key/value pair order in a map would change the semantics, apart from trivial aspects (cache usage, etc.). (A CBOR-based protocol can prescribe a specific order of serialization, such as for canonicalization.)",
      "ja": "マップのCBORデータモデルは、マップの表現で、キー/値のペアの順序に意味を帰することはできません。したがって、マップ内のキー/値のペアの順序を変更して些細な側面（キャッシュ使用、等）別に、セマンティクスを変更することになるような方法でCBORベースのプロトコルを定義するために非常に悪い習慣であろう。 （CBORベースのプロトコルは、このような正規化については、シリアライゼーションの特定の順序を規定することができます。）"
    },
    {
      "indent": 3,
      "text": "Applications for constrained devices that have maps with 24 or fewer frequently used keys should consider using small integers (and those with up to 48 frequently used keys should consider also using small negative integers) because the keys can then be encoded in a single byte.",
      "ja": "キーは、単一のバイトでエンコードすることができますので、（小さな負の整数を使用しても検討すべきであると、最大48頻繁に使用するキーを持つもの）は小さな整数を使用することを検討すべきである24個のまたはそれより少ない頻繁に使用されるキーでマップを持っている制約のあるデバイスのためのアプリケーション。"
    },
    {
      "indent": 0,
      "text": "3.8. Undefined Values",
      "section_title": true,
      "ja": "3.8。未定義の値"
    },
    {
      "indent": 3,
      "text": "In some CBOR-based protocols, the simple value (Section 2.3) of Undefined might be used by an encoder as a substitute for a data item with an encoding problem, in order to allow the rest of the enclosing data items to be encoded without harm.",
      "ja": "一部CBORベースのプロトコルでは、未定義の単純な値（2.3節）を囲むデータの残りが害なしに符号化されることを可能にするために、符号化の問題を有するデータ項目の代わりにエンコーダによって使用されるかもしれません。"
    },
    {
      "indent": 0,
      "text": "3.9. Canonical CBOR",
      "section_title": true,
      "ja": "3.9。 CanonicalのCBOR"
    },
    {
      "indent": 3,
      "text": "Some protocols may want encoders to only emit CBOR in a particular canonical format; those protocols might also have the decoders check that their input is canonical. Those protocols are free to define what they mean by a canonical format and what encoders and decoders are expected to do. This section lists some suggestions for such protocols.",
      "ja": "一部のプロトコルでは、特定の標準的なフォーマットでCBORを発するようにエンコーダをたいこともあるでしょう。これらのプロトコルはまた、デコーダは、その入力が正規のあることを確認している可能性があります。これらのプロトコルは、彼らがどのようなエンコーダとデコーダが行うことに期待されている標準的な形式とによって何を意味するかを定義するのは自由です。このセクションでは、そのようなプロトコルのためのいくつかの提案を示しています。"
    },
    {
      "indent": 3,
      "text": "If a protocol considers \"canonical\" to mean that two encoder implementations starting with the same input data will produce the same CBOR output, the following four rules would suffice:",
      "ja": "プロトコルは同じ入力データで始まる2つのエンコーダの実装が同じCBOR出力を生成することを意味する「カノニカル」考える場合、以下の4つのルールが十分であろう。"
    },
    {
      "indent": 3,
      "text": "o Integers must be as small as possible.",
      "ja": "O整数は可能な限り小さくする必要があります。"
    },
    {
      "indent": 6,
      "text": "* 0 to 23 and -1 to -24 must be expressed in the same byte as the major type;",
      "ja": "* -24〜23 -1 0〜主要なタイプと同じバイトで表現されなければなりません。"
    },
    {
      "indent": 6,
      "text": "* 24 to 255 and -25 to -256 must be expressed only with an additional uint8_t;",
      "ja": "* -256 255と-25〜24は、追加のuint8_tで表現されなければなりません。"
    },
    {
      "indent": 6,
      "text": "* 256 to 65535 and -257 to -65536 must be expressed only with an additional uint16_t;",
      "ja": "* -65536〜65535の256及び-257は、追加uint16_tでのみ発現されなければなりません。"
    },
    {
      "indent": 6,
      "text": "* 65536 to 4294967295 and -65537 to -4294967296 must be expressed only with an additional uint32_t.",
      "ja": "* -4294967296〜4294967295のと-65537に65536のみで追加のuint32_tで表現しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o The expression of lengths in major types 2 through 5 must be as short as possible. The rules for these lengths follow the above rule for integers.",
      "ja": "O主要なタイプ2〜5の長さの発現が可能な限り短くなければなりません。これらの長さのための規則は、整数の上記のルールに従ってください。"
    },
    {
      "indent": 3,
      "text": "o The keys in every map must be sorted lowest value to highest. Sorting is performed on the bytes of the representation of the key data items without paying attention to the 3/5 bit splitting for major types. (Note that this rule allows maps that have keys of different types, even though that is probably a bad practice that could lead to errors in some canonicalization implementations.) The sorting rules are:",
      "ja": "すべてのマップ内のキーoを最高に最低値をソートする必要があります。ソートは主要なタイプのために3/5ビット分割に注意を払うことなく、キー・データ項目の表現のバイトで行われます。 （。このルールは、それはおそらく、いくつかの正規化の実装でエラーにつながる可能性が悪い習慣であっても、異なる種類のキーを持つマップを可能にすることに注意してください）仕分けルールは以下のとおりです。"
    },
    {
      "indent": 6,
      "text": "* If two keys have different lengths, the shorter one sorts earlier;",
      "ja": "*二つの鍵の長さが異なる場合は、短い方が先にソートします。"
    },
    {
      "indent": 6,
      "text": "* If two keys have the same length, the one with the lower value in (byte-wise) lexical order sorts earlier.",
      "ja": "* 2つのキーが同じ長さで、以前の（バイト単位）字句順ソートでは低い値を持つものを持っている場合。"
    },
    {
      "indent": 3,
      "text": "o Indefinite-length items must be made into definite-length items.",
      "ja": "O不定長の項目は、明確な長さの項目になされなければなりません。"
    },
    {
      "indent": 3,
      "text": "If a protocol allows for IEEE floats, then additional canonicalization rules might need to be added. One example rule might be to have all floats start as a 64-bit float, then do a test conversion to a 32-bit float; if the result is the same numeric value, use the shorter value and repeat the process with a test conversion to a 16-bit float. (This rule selects 16-bit float for positive and negative Infinity as well.) Also, there are many representations for NaN. If NaN is an allowed value, it must always be represented as 0xf97e00.",
      "ja": "プロトコルは、IEEE浮動小数点数を可能にした場合、追加の正規化ルールを追加する必要があります。一例のルールは、32ビット浮動小数点へのテスト変換を行い、その後、すべての浮動小数点数は64ビット浮動小数点として起動有することかもしれません。結果は同じ数値であれば、短い値を使用し、16ビット浮動小数点へのテスト変換を使用してプロセスを繰り返します。 （この規則は、同様に、正と負の無限大のための16ビット浮動小数点を選択する。）また、NaNのための多くの表現があります。 NaNの許容値である場合、それは常に0xf97e00として表現されなければなりません。"
    },
    {
      "indent": 3,
      "text": "CBOR tags present additional considerations for canonicalization. The absence or presence of tags in a canonical format is determined by the optionality of the tags in the protocol. In a CBOR-based protocol that allows optional tagging anywhere, the canonical format must not allow them. In a protocol that requires tags in certain places, the tag needs to appear in the canonical format. A CBOR-based protocol that uses canonicalization might instead say that all tags that appear in a message must be retained regardless of whether they are optional.",
      "ja": "CBORタグは正規化のための追加の考慮事項を提示します。標準フォーマットのタグの有無は、プロトコルのタグの選択性によって決定されます。どこにでもオプションのタグ付けを可能にCBORベースのプロトコルでは、標準的なフォーマットは、それらを許してはなりません。特定の場所のタグを必要としたプロトコルでは、タグは、標準的な形式で表示されている必要があります。正規化を使用していますCBORベースのプロトコルではなく、メッセージに表示されるすべてのタグに関係なく、彼らがオプションであるかどうかの保持されなければならないことを言うかもしれません。"
    },
    {
      "indent": 0,
      "text": "3.10. Strict Mode",
      "section_title": true,
      "ja": "3.10。 strictモード"
    },
    {
      "indent": 3,
      "text": "Some areas of application of CBOR do not require canonicalization (Section 3.9) but may require that different decoders reach the same (semantically equivalent) results, even in the presence of potentially malicious data. This can be required if one application (such as a firewall or other protecting entity) makes a decision based on the data that another application, which independently decodes the data, relies on.",
      "ja": "CBORのアプリケーションの一部の地域では、正規化（3.9節）を必要としませんが、別のデコーダも潜在的に悪質なデータの存在下で、同じ（意味的に等価）の結果に到達することを必要とするかもしれません。 （例えば、ファイアウォールまたは他の保護エンティティとして）一つのアプリケーションは、独立して、データを復号化する別のアプリケーションが、依存しているデータに基づいて決定を行う場合に必要とされることができます。"
    },
    {
      "indent": 3,
      "text": "Normally, it is the responsibility of the sender to avoid ambiguously decodable data. However, the sender might be an attacker specially making up CBOR data such that it will be interpreted differently by different decoders in an attempt to exploit that as a vulnerability. Generic decoders used in applications where this might be a problem need to support a strict mode in which it is also the responsibility of the receiver to reject ambiguously decodable data. It is expected that firewalls and other security systems that decode CBOR will only decode in strict mode.",
      "ja": "通常、曖昧に復号可能なデータを避けるために、送信者の責任です。ただし、送信者は、特別に、それは脆弱性としてそれを悪用しようとする試みに異なるデコーダによって異なって解釈されるようにCBORデータを構成する攻撃者かもしれません。これが問題になる可能性があるアプリケーションで使用される一般的なデコーダは、また曖昧に復号可能なデータを拒否する受信者の責任であるstrictモードをサポートする必要があります。 CBORをデコードファイアウォールや他のセキュリティシステムは、唯一のstrictモードでデコードすることが予想されます。"
    },
    {
      "indent": 3,
      "text": "A decoder in strict mode will reliably reject any data that could be interpreted by other decoders in different ways. It will reliably reject data items with syntax errors (Section 3.3). It will also expend the effort to reliably detect other decoding errors (Section 3.4). In particular, a strict decoder needs to have an API that reports an error (and does not return data) for a CBOR data item that contains any of the following:",
      "ja": "厳密モードで復号を確実に様々な方法で他のデコーダによって解釈することができる任意のデータを拒否します。これは、確実に構文エラー（3.3節）とのデータ項目を拒否します。また、確実に他のデコードエラー（3.4節）を検出するための努力を費やすだろう。具体的には、厳密な復号器は、エラーを報告（およびデータを返さない）次のいずれかが含まCBORデータ項目のためのAPIを有する必要があります。"
    },
    {
      "indent": 3,
      "text": "o a map (major type 5) that has more than one entry with the same key",
      "ja": "同じキーを持つ複数のエントリを有するマップ（主要なタイプ5）O"
    },
    {
      "indent": 3,
      "text": "o a tag that is used on a data item of the incorrect type",
      "ja": "O間違ったタイプのデータ項目で使用されているタグ"
    },
    {
      "indent": 3,
      "text": "o a data item that is incorrectly formatted for the type given to it, such as invalid UTF-8 or data that cannot be interpreted with the specific tag that it has been tagged with",
      "ja": "それがタグ付けされた特定のタグと解釈することができない無効なUTF-8またはデータとして誤ってそれに与えられたタイプのためにフォーマットされたデータ項目、O"
    },
    {
      "indent": 3,
      "text": "A decoder in strict mode can do one of two things when it encounters a tag or simple value that it does not recognize:",
      "ja": "それはそれは認識していないことを、タグや単純な値に遭遇したとき、strictモードでのデコーダは、2つのいずれかを行うことができます。"
    },
    {
      "indent": 3,
      "text": "o It can report an error (and not return data).",
      "ja": "Oそれは（データを返すとしない）エラーを報告することができます。"
    },
    {
      "indent": 3,
      "text": "o It can emit the unknown item (type, value, and, for tags, the decoded tagged data item) to the application calling the decoder with an indication that the decoder did not recognize that tag or simple value.",
      "ja": "Oそれは、デコーダは、そのタグまたは単純な値を認識しなかったことを示すとデコーダを呼び出すアプリケーションに（タグのため、復号されたデータ項目をタグ付けし、タイプ、値、および）未知のアイテムを放出することができます。"
    },
    {
      "indent": 3,
      "text": "The latter approach, which is also appropriate for non-strict decoders, supports forward compatibility with newly registered tags and simple values without the requirement to update the encoder at the same time as the calling application. (For this, the API for the decoder needs to have a way to mark unknown items so that the calling application can handle them in a manner appropriate for the program.)",
      "ja": "非厳密デコーダに適した後者のアプローチは、呼び出し元のアプリケーションと同時にエンコーダを更新する必要なしに新たに登録されたタグと単純な値との上位互換性をサポートします。 （このために、デコーダのためのAPIは、呼び出し元のアプリケーションは、プログラムのための適切な方法でそれらを扱うことができるように、未知のアイテムをマークする方法を持っている必要があります。）"
    },
    {
      "indent": 3,
      "text": "Since some of this processing may have an appreciable cost (in particular with duplicate detection for maps), support of strict mode is not a requirement placed on all CBOR decoders.",
      "ja": "この処理の一部は、（マップの重複検出と特に）かなりのコストを有する可能性があるため、厳密モードのサポートは、すべてのCBORデコーダ上に配置された要件ではありません。"
    },
    {
      "indent": 3,
      "text": "Some encoders will rely on their applications to provide input data in such a way that unambiguously decodable CBOR results. A generic encoder also may want to provide a strict mode where it reliably limits its output to unambiguously decodable CBOR, independent of whether or not its application is providing API-conformant data.",
      "ja": "いくつかのエンコーダは、このような方法で明確に復号可能なCBOR結果に入力データを提供するために、自社のアプリケーションに依存します。ジェネリックエンコーダはまた、確実にそのアプリケーションがAPIに準拠データを提供しているか否かとは無関係に、その出力に明確に復号可能CBORを制限する厳格なモードを提供することができます。"
    },
    {
      "indent": 0,
      "text": "4. Converting Data between CBOR and JSON",
      "section_title": true,
      "ja": "4. CBORとJSONの間でデータを変換"
    },
    {
      "indent": 3,
      "text": "This section gives non-normative advice about converting between CBOR and JSON. Implementations of converters are free to use whichever advice here they want.",
      "ja": "このセクションでは、CBORとJSONとの間の変換に関する非規範的なアドバイスを提供します。コンバータの実装は、ここで彼らが欲しい方のアドバイスを自由に使用できます。"
    },
    {
      "indent": 3,
      "text": "It is worth noting that a JSON text is a sequence of characters, not an encoded sequence of bytes, while a CBOR data item consists of bytes, not characters.",
      "ja": "CBORデータアイテムはバイトではなく文字で構成されている間、それは、JSONテキストは文字のシーケンスではなくバイトの符号化された配列であることは注目に値します。"
    },
    {
      "indent": 0,
      "text": "4.1. Converting from CBOR to JSON",
      "section_title": true,
      "ja": "4.1。 CBORからJSONへの変換"
    },
    {
      "indent": 3,
      "text": "Most of the types in CBOR have direct analogs in JSON. However, some do not, and someone implementing a CBOR-to-JSON converter has to consider what to do in those cases. The following non-normative advice deals with these by converting them to a single substitute value, such as a JSON null.",
      "ja": "CBOR内の型のほとんどはJSONで直接アナログを持っています。しかし、いくつかはそうではない、とCBORツーJSONコンバータを実装誰かがそのような場合に何をすべきかを検討する必要があります。そのようなJSONヌルとして、単一代替値に変換することにより、これらと以下の非規範的なアドバイスを扱っています。"
    },
    {
      "indent": 3,
      "text": "o An integer (major type 0 or 1) becomes a JSON number.",
      "ja": "O整数（主要なタイプ0または1）JSON番号となります。"
    },
    {
      "indent": 3,
      "text": "o A byte string (major type 2) that is not embedded in a tag that specifies a proposed encoding is encoded in base64url without padding and becomes a JSON string.",
      "ja": "Oパディングなしbase64urlで符号化された提案されたエンコーディングを指定し、JSON文字列となるタグに埋め込まれていないバイト列（主要なタイプ2）。"
    },
    {
      "indent": 3,
      "text": "o A UTF-8 string (major type 3) becomes a JSON string. Note that JSON requires escaping certain characters (RFC 4627, Section 2.5): quotation mark (U+0022), reverse solidus (U+005C), and the \"C0 control characters\" (U+0000 through U+001F). All other characters are copied unchanged into the JSON UTF-8 string.",
      "ja": "O UTF-8文字列（主なタイプ3）は、JSON文字列となります。 （U + 001Fを介してU + 0000）固相（U + 005C）を逆引用符（U + 0022）、及び \"C0制御文字\"：JSONは、特定の文字（RFC 4627、セクション2.5）エスケープが必要であることに留意されたいです。他のすべての文字はJSON UTF-8文字列にそのままコピーされます。"
    },
    {
      "indent": 3,
      "text": "o An array (major type 4) becomes a JSON array.",
      "ja": "Oアレイ（主要なタイプ4）は、JSON配列となります。"
    },
    {
      "indent": 3,
      "text": "o A map (major type 5) becomes a JSON object. This is possible directly only if all keys are UTF-8 strings. A converter might also convert other keys into UTF-8 strings (such as by converting integers into strings containing their decimal representation); however, doing so introduces a danger of key collision.",
      "ja": "Oマップ（主要なタイプ5）は、JSONオブジェクトになります。これは、すべてのキーがUTF-8文字列で直接場合にのみ可能です。コンバータはまた、（その10進表現を含む文字列に整数を変換することによってなど）UTF-8文字列に他のキーを変換するかもしれません。しかし、そうすることは、キーの衝突の危険性を紹介します。"
    },
    {
      "indent": 3,
      "text": "o False (major type 7, additional information 20) becomes a JSON false.",
      "ja": "O偽（主要7型、追加情報20）はJSON偽になります。"
    },
    {
      "indent": 3,
      "text": "o True (major type 7, additional information 21) becomes a JSON true.",
      "ja": "O真（主要7型、追加情報21）が真JSONになります。"
    },
    {
      "indent": 3,
      "text": "o Null (major type 7, additional information 22) becomes a JSON null.",
      "ja": "Oヌル（主要なタイプ7、付加情報22）はJSONヌルとなります。"
    },
    {
      "indent": 3,
      "text": "o A floating-point value (major type 7, additional information 25 through 27) becomes a JSON number if it is finite (that is, it can be represented in a JSON number); if the value is non-finite (NaN, or positive or negative Infinity), it is represented by the substitute value.",
      "ja": "それが有限である場合oを浮動小数点値（主要なタイプ7、付加情報27を介して、25）（すなわち、それはJSONの数で表すことができる）JSON番号となります。値（NaNに、または正または負の無限大）非有限である場合には、代替値で表されます。"
    },
    {
      "indent": 3,
      "text": "o Any other simple value (major type 7, any additional information value not yet discussed) is represented by the substitute value.",
      "ja": "O任意の他の単純な値（主要なタイプ7、まだ説明していない任意の追加情報値）を代替値で表されます。"
    },
    {
      "indent": 3,
      "text": "o A bignum (major type 6, tag value 2 or 3) is represented by encoding its byte string in base64url without padding and becomes a JSON string. For tag value 3 (negative bignum), a \"~\" (ASCII tilde) is inserted before the base-encoded value. (The conversion to a binary blob instead of a number is to prevent a likely numeric overflow for the JSON decoder.)",
      "ja": "O BIGNUM（主要なタイプ6、タグ値が2または3）パディングなしbase64urlそのバイト列を符号化することによって表され、JSON文字列となります。タグ値3（負BIGNUM）は、「〜」（ASCIIのチルダ）は、ベース・エンコードされた値の前に挿入されます。 （代わりに、数のバイナリブロブへの変換は、JSONデコーダのための可能性の高い数値オーバーフローを防止するためです。）"
    },
    {
      "indent": 3,
      "text": "o A byte string with an encoding hint (major type 6, tag value 21 through 23) is encoded as described and becomes a JSON string.",
      "ja": "oを符号化ヒント（主要なタイプ6、23を介して、タグ値21）のバイト列が記載されているように符号化され、JSON文字列となります。"
    },
    {
      "indent": 3,
      "text": "o For all other tags (major type 6, any other tag value), the embedded CBOR item is represented as a JSON value; the tag value is ignored.",
      "ja": "O、他のすべてのタグ（主要なタイプ6、他のタグ値）の場合、埋め込みCBOR項目はJSON値として表されます。タグ値は無視されます。"
    },
    {
      "indent": 3,
      "text": "o Indefinite-length items are made definite before conversion.",
      "ja": "O不定長の項目は、変換前の明確作られています。"
    },
    {
      "indent": 0,
      "text": "4.2. Converting from JSON to CBOR",
      "section_title": true,
      "ja": "4.2。 JSONからCBORへの変換"
    },
    {
      "indent": 3,
      "text": "All JSON values, once decoded, directly map into one or more CBOR values. As with any kind of CBOR generation, decisions have to be made with respect to number representation. In a suggested conversion: o JSON numbers without fractional parts (integer numbers) are represented as integers (major types 0 and 1, possibly major type 6 tag value 2 and 3), choosing the shortest form; integers longer than an implementation-defined threshold (which is usually either 32 or 64 bits) may instead be represented as floating-point values. (If the JSON was generated from a JavaScript implementation, its precision is already limited to 53 bits maximum.)",
      "ja": "すべてのJSONの値は、一度復号し、直接、一つ以上のCBOR値にマッピングします。 CBOR発生の任意の種類と同様に、決定は数値表現に関して行わなければなりません。提案変換中：小数部（整数）なしでJSON番号oを整数として表現される（主要なタイプ0及び1、おそらく主要なタイプ6タグ値2及び3）、最短形式を選択します。 （いずれかの通常32又は64ビット）実装定義の閾値よりも長い整数ではなく浮動小数点値として表すことができます。 （JSONはJavaScriptの実装から生成された場合、その精度は既に53ビットの最大値に制限されています。）"
    },
    {
      "indent": 3,
      "text": "o Numbers with fractional parts are represented as floating-point values. Preferably, the shortest exact floating-point representation is used; for instance, 1.5 is represented in a 16-bit floating-point value (not all implementations will be capable of efficiently finding the minimum form, though). There may be an implementation-defined limit to the precision that will affect the precision of the represented values. Decimal representation should only be used if that is specified in a protocol.",
      "ja": "小数部分とO番号は、浮動小数点値として表現されます。好ましくは、最短の正確な浮動小数点表現が使用されます。たとえば、1.5は、16ビット浮動小数点値（全てではない実装が、しかし、効率的に最小フォームを見つけることができるであろう）に示されています。示される値の精度に影響を与える高精度に実装定義限界があってもよいです。それはプロトコルで指定されている場合、10進表現にのみ使用されるべきです。"
    },
    {
      "indent": 3,
      "text": "CBOR has been designed to generally provide a more compact encoding than JSON. One implementation strategy that might come to mind is to perform a JSON-to-CBOR encoding in place in a single buffer. This strategy would need to carefully consider a number of pathological cases, such as that some strings represented with no or very few escapes and longer (or much longer) than 255 bytes may expand when encoded as UTF-8 strings in CBOR. Similarly, a few of the binary floating-point representations might cause expansion from some short decimal representations (1.1, 1e9) in JSON. This may be hard to get right, and any ensuing vulnerabilities may be exploited by an attacker.",
      "ja": "CBORは、一般的にJSONよりもコンパクトなエンコーディングを提供するように設計されています。心に来るかもしれない一つの実装戦略は、単一のバッファ内の所定の位置にJSONツーCBOR符号化を実行することです。この戦略は慎重CBORでUTF-8文字列としてエンコードされたときに255バイト以下または非常に少数のエスケープと長い（またははるかに長い）で表さないいくつかの文字列が拡張できるように、などの病理学的例数を、検討する必要があるだろう。同様に、二進浮動小数点表現のいくつかは、JSONに、いくつかの短い小数表現（1.1、1E9）から膨張を引き起こす可能性があります。これは、権利を取得するのは難しいかもしれ、および任意のその後の脆弱性が攻撃者によって悪用されることがあります。"
    },
    {
      "indent": 0,
      "text": "5. Future Evolution of CBOR",
      "section_title": true,
      "ja": "CBORの今後の進化"
    },
    {
      "indent": 3,
      "text": "Successful protocols evolve over time. New ideas appear, implementation platforms improve, related protocols are developed and evolve, and new requirements from applications and protocols are added. Facilitating protocol evolution is therefore an important design consideration for any protocol development.",
      "ja": "成功したプロトコルは、時間をかけて進化します。新しいアイデアは、表示される実装プラットフォームは改善し、関連するプロトコルが開発され、進化、およびアプリケーションとプロトコルからの新たな要件が追加されています。プロトコルの進化を促進することは、したがって任意のプロトコル開発のための重要な設計上の考慮事項です。"
    },
    {
      "indent": 3,
      "text": "For protocols that will use CBOR, CBOR provides some useful mechanisms to facilitate their evolution. Best practices for this are well known, particularly from JSON format development of JSON-based protocols. Therefore, such best practices are outside the scope of this specification.",
      "ja": "CBORを使用するプロトコルでは、CBORは、彼らの進化を促進するために、いくつかの有用なメカニズムを提供しています。このためのベストプラクティスは、特によくJSONベースのプロトコルのJSON形式の開発から、知られています。したがって、このようなベストプラクティスは、この仕様の範囲外です。"
    },
    {
      "indent": 3,
      "text": "However, facilitating the evolution of CBOR itself is very well within its scope. CBOR is designed to both provide a stable basis for development of CBOR-based protocols and to be able to evolve.",
      "ja": "しかし、CBOR自体の進化を促進することは非常によく、その範囲内にあります。 CBORはCBORベースのプロトコルの開発のための安定した基礎を提供するために両方と進化することができるように設計されています。"
    },
    {
      "indent": 3,
      "text": "Since a successful protocol may live for decades, CBOR needs to be designed for decades of use and evolution. This section provides some guidance for the evolution of CBOR. It is necessarily more subjective than other parts of this document. It is also necessarily incomplete, lest it turn into a textbook on protocol development.",
      "ja": "成功したプロトコルは何十年も生きることがありますので、CBORは、使用および進化の数十年のために設計する必要があります。このセクションでは、CBORの進化のためにいくつかのガイダンスを提供します。それは必ずしも、この文書の他の部分よりも主観的です。それはプロトコル開発の教科書に変わりないようにそれは、また、必然的に不完全です。"
    },
    {
      "indent": 0,
      "text": "5.1. Extension Points",
      "section_title": true,
      "ja": "5.1。拡張ポイント"
    },
    {
      "indent": 3,
      "text": "In a protocol design, opportunities for evolution are often included in the form of extension points. For example, there may be a codepoint space that is not fully allocated from the outset, and the protocol is designed to tolerate and embrace implementations that start using more codepoints than initially allocated.",
      "ja": "プロトコルの設計では、進化のための機会は、多くの場合、拡張ポイントの形で含まれています。例えば、完全に最初から割り当てられておらず、プロトコルが最初に割り当てられたより多くのコードポイントを使用して開始実装を許容し、包含するように設計されたコードポイントの空間があってもよいです。"
    },
    {
      "indent": 3,
      "text": "Sizing the codepoint space may be difficult because the range required may be hard to predict. An attempt should be made to make the codepoint space large enough so that it can slowly be filled over the intended lifetime of the protocol.",
      "ja": "必要な範囲を予測するのは難しいかもしれないのでコードポイントスペースをサイジングすることは難しいかもしれません。試みは、それがゆっくりとプロトコルの意図寿命にわたって充填することができるように十分な大きさのコードポイントのスペースを作るためになされるべきです。"
    },
    {
      "indent": 3,
      "text": "CBOR has three major extension points:",
      "ja": "CBORは三個の大拡張ポイントがあります。"
    },
    {
      "indent": 3,
      "text": "o the \"simple\" space (values in major type 7). Of the 24 efficient (and 224 slightly less efficient) values, only a small number have been allocated. Implementations receiving an unknown simple data item may be able to process it as such, given that the structure of the value is indeed simple. The IANA registry in Section 7.1 is the appropriate way to address the extensibility of this codepoint space.",
      "ja": "O（主要7型の値）「シンプル」スペース。 24効率的（及び224わずかに低い効率）の値、わずか数が割り当てられています。未知の単純なデータアイテムを受信する実装は、値の構造が実際に簡単であることを考えると、そのように処理することができるかもしれません。 7.1節でIANAレジストリは、このコードポイントスペースの拡張性に対処するための適切な方法です。"
    },
    {
      "indent": 3,
      "text": "o the \"tag\" space (values in major type 6). Again, only a small part of the codepoint space has been allocated, and the space is abundant (although the early numbers are more efficient than the later ones). Implementations receiving an unknown tag can choose to simply ignore it or to process it as an unknown tag wrapping the following data item. The IANA registry in Section 7.2 is the appropriate way to address the extensibility of this codepoint space.",
      "ja": "「タグ」空間（主要なタイプ6の値）O。再び、コードポイント空間のほんの一部が割り当てられている、および（初期番号が後のものよりも効率的であるが）スペースが豊富です。未知のタグを受け取る実装は、単にそれを無視するか、次のデータ項目を包む不明なタグとして、それを処理するために選択することができます。 7.2節でIANAレジストリは、このコードポイントスペースの拡張性に対処するための適切な方法です。"
    },
    {
      "indent": 3,
      "text": "o the \"additional information\" space. An implementation receiving an unknown additional information value has no way to continue parsing, so allocating codepoints to this space is a major step. There are also very few codepoints left.",
      "ja": "「追加情報」スペースO。未知の追加情報値を受け取る実装は、構文解析を継続する方法がないので、この空間にコードポイントを割り当てることは大きな一歩です。左は非常に少数のコードポイントもあります。"
    },
    {
      "indent": 0,
      "text": "5.2. Curating the Additional Information Space",
      "section_title": true,
      "ja": "5.2。追加情報スペースをキュレーション"
    },
    {
      "indent": 3,
      "text": "The human mind is sometimes drawn to filling in little perceived gaps to make something neat. We expect the remaining gaps in the codepoint space for the additional information values to be an attractor for new ideas, just because they are there.",
      "ja": "人間の心は時々きちんとしたものを作るために少しの知覚のギャップを埋めるに描かれています。我々は、彼らがあるという理由だけで、追加の情報値のためのコードポイント空間の残りのギャップは新しいアイデアのためのアトラクターことを期待しています。"
    },
    {
      "indent": 3,
      "text": "The present specification does not manage the additional information codepoint space by an IANA registry. Instead, allocations out of this space can only be done by updating this specification.",
      "ja": "本明細書はIANAレジストリによる追加情報のコードポイントスペースを管理しません。代わりに、この空間のうちの割り当ては、この仕様を更新することにより行うことができます。"
    },
    {
      "indent": 3,
      "text": "For an additional information value of n >= 24, the size of the additional data typically is 2**(n-24) bytes. Therefore, additional information values 28 and 29 should be viewed as candidates for 128-bit and 256-bit quantities, in case a need arises to add them to the protocol. Additional information value 30 is then the only additional information value available for general allocation, and there should be a very good reason for allocating it before assigning it through an update of this protocol.",
      "ja": "N> = 24の追加的な情報値のために、追加的なデータのサイズは、典型的には2 **（N-24）であるバイト。したがって、付加情報28値および必要にプロトコルに追加する必要が生じた場合に、図29に示すように、128ビットおよび256ビットの量の候補として見なされるべきです。追加情報値30は、次に、一般的な割当てのために利用可能な唯一の追加情報値であり、このプロトコルの更新を通してそれを割り当てる前に、それを割り当てるための非常に良い理由があるべきです。"
    },
    {
      "indent": 0,
      "text": "6. Diagnostic Notation",
      "section_title": true,
      "ja": "6.診断表記"
    },
    {
      "indent": 3,
      "text": "CBOR is a binary interchange format. To facilitate documentation and debugging, and in particular to facilitate communication between entities cooperating in debugging, this section defines a simple human-readable diagnostic notation. All actual interchange always happens in the binary format.",
      "ja": "CBORバイナリ交換フォーマットです。ドキュメントおよびデバッグを容易にするために、特にデバッグに協力エンティティ間の通信を容易にするために、このセクションでは、単純な人間可読診断表記法を定義します。すべての実際の交換は、必ずバイナリ形式で行われます。"
    },
    {
      "indent": 3,
      "text": "Note that this truly is a diagnostic format; it is not meant to be parsed. Therefore, no formal definition (as in ABNF) is given in this document. (Implementers looking for a text-based format for representing CBOR data items in configuration files may also want to consider YAML [YAML].)",
      "ja": "これは真に診断形式であることに留意されたいです。解析されることを意味しません。そのため、正式な定義は（ABNFのように）この文書で与えられていません。 （コンフィギュレーションファイルにCBORデータ項目を表現するためのテキストベースのフォーマットを探している実装者はまた、YAML [YAML]検討する必要があります。）"
    },
    {
      "indent": 3,
      "text": "The diagnostic notation is loosely based on JSON as it is defined in RFC 4627, extending it where needed.",
      "ja": "それが必要な場所に延びる、RFC 4627で定義されるような診断表記は緩くJSONに基づいています。"
    },
    {
      "indent": 3,
      "text": "The notation borrows the JSON syntax for numbers (integer and floating point), True (>true<), False (>false<), Null (>null<), UTF-8 strings, arrays, and maps (maps are called objects in JSON; the diagnostic notation extends JSON here by allowing any data item in the key position). Undefined is written >undefined< as in JavaScript. The non-finite floating-point numbers Infinity, -Infinity, and NaN are written exactly as in this sentence (this is also a way they can be written in JavaScript, although JSON does not allow them). A tagged item is written as an integer number for the tag followed by the item in parentheses; for instance, an RFC 3339 (ISO 8601) date could be notated as:",
      "ja": "表記は、ヌル（>ヌル<）（<>偽）、（<真>）FALSE TRUE JSON番号の構文（整数および浮動小数点）を、借用し、UTF-8文字列、配列、およびマップ（マップはオブジェクトと呼ばれますJSONに、診断表記）は、キーの位置に任意のデータ項目を可能にすることによってここにJSONを拡張します。未定義はJavaScriptでのように、<未定義>書かれています。非有限浮動小数点数インフィニティ、-Infinity、およびNaNは（JSONがそれらを許可していませんが、これは、また、彼らはJavaScriptで記述することが可能な方法である）この文のように正確に書かれています。タグ付けされたアイテムは、括弧内のアイテムに続くタグの整数として書き込まれます。例えば、RFC 3339（ISO 8601）の日付は次のように表記することができます："
    },
    {
      "indent": 6,
      "text": "0(\"2013-03-21T20:04:00Z\")",
      "ja": "0（ \"2013-03-21T20：04：00Z\"）"
    },
    {
      "indent": 3,
      "text": "or the equivalent relative time as",
      "ja": "または同等の相対時間として"
    },
    {
      "indent": 6,
      "text": "1(1363896240)",
      "ja": "１（１３６３８９６２４０）"
    },
    {
      "indent": 3,
      "text": "Byte strings are notated in one of the base encodings, without padding, enclosed in single quotes, prefixed by >h< for base16, >b32< for base32, >h32< for base32hex, >b64< for base64 or base64url (the actual encodings do not overlap, so the string remains unambiguous). For example, the byte string 0x12345678 could be written h'12345678', b32'CI2FM6A', or b64'EjRWeA'.",
      "ja": "バイト列は> base16ためのH <、> B32 <base32ため、> H32 <base32hexため、> B64 <BASE64またはbase64url（のための実際の符号化で始まる、単一引用符で囲まれ、パディングせずに、ベースエンコーディングのいずれかで表記されています文字列は、あいまいさのないままに）、重複していません。例えば、バイト文字列0x12345678のは書くことができh'12345678' 、b32'CI2FM6A「またはb64'EjRWeA」。"
    },
    {
      "indent": 3,
      "text": "Unassigned simple values are given as \"simple()\" with the appropriate integer in the parentheses. For example, \"simple(42)\" indicates major type 7, value 42.",
      "ja": "割り当てられていない単純な値は括弧内に適切な整数と「単純（）」として与えられます。例えば、 \"単純（42）は、\" 主要なタイプ7、値42を示しています。"
    },
    {
      "indent": 0,
      "text": "6.1. Encoding Indicators",
      "section_title": true,
      "ja": "6.1。エンコーディングインジケータ"
    },
    {
      "indent": 3,
      "text": "Sometimes it is useful to indicate in the diagnostic notation which of several alternative representations were actually used; for example, a data item written >1.5< by a diagnostic decoder might have been encoded as a half-, single-, or double-precision float.",
      "ja": "時には実際に使用されたいくつかの代替表現の診断表記で示すために有用です。例えば、診断デコーダによって書き込まれたデータ項目> 1.5 <半、一、又は倍精度浮動小数点としてエンコードされている場合があります。"
    },
    {
      "indent": 3,
      "text": "The convention for encoding indicators is that anything starting with an underscore and all following characters that are alphanumeric or underscore, is an encoding indicator, and can be ignored by anyone not interested in this information. Encoding indicators are always optional.",
      "ja": "エンコードの指標の大会は何がアンダースコアで始まり、英数字またはアンダースコアです以下のすべての文字は、エンコーディング指標であり、この情報に興味を持っていない誰もが無視することができるということです。エンコード指標は常にオプションです。"
    },
    {
      "indent": 3,
      "text": "A single underscore can be written after the opening brace of a map or the opening bracket of an array to indicate that the data item was represented in indefinite-length format. For example, [_ 1, 2] contains an indicator that an indefinite-length representation was used to represent the data item [1, 2].",
      "ja": "単一の下線は、データ項目が不定長形式で表現したことを示すために、マップまたはアレイの開口ブラケットの開口ブレースの後に書くことができます。例えば、[_ 1,2]不定長の表現は、データ項目[1、2]を表すために使用されたことを示すインジケータを含んでいます。"
    },
    {
      "indent": 3,
      "text": "An underscore followed by a decimal digit n indicates that the preceding item (or, for arrays and maps, the item starting with the preceding bracket or brace) was encoded with an additional information value of 24+n. For example, 1.5_1 is a half-precision floating-point number, while 1.5_3 is encoded as double precision. This encoding indicator is not shown in Appendix A. (Note that the encoding indicator \"_\" is thus an abbreviation of the full form \"_7\", which is not used.)",
      "ja": "10進数Nに続く下線は前号（配列やマップのまたは、先行ブラケット又はブレースで始まる項目が）24 + Nの付加情報値を用いて符号化されたことを示しています。 1.5_3が倍精度として符号化されている間、例えば、1.5_1は、半精度浮動小数点数です。この符号化インジケータは付録Aに示されていない（符号化インジケータは「_」このように使用されていない完全な形「_7」の略です。）"
    },
    {
      "indent": 3,
      "text": "As a special case, byte and text strings of indefinite length can be notated in the form (_ h'0123', h'4567') and (_ \"foo\", \"bar\").",
      "ja": "特殊なケースとして、不定長のバイトとテキスト文字列の形式（_ h'0123' 、H'4567' ）及び（_ 『FOO』、 『バー』）で表記することができます。"
    },
    {
      "indent": 0,
      "text": "7. IANA Considerations",
      "section_title": true,
      "ja": "7. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "IANA has created two registries for new CBOR values. The registries are separate, that is, not under an umbrella registry, and follow the rules in [RFC5226]. IANA has also assigned a new MIME media type and an associated Constrained Application Protocol (CoAP) Content-Format entry.",
      "ja": "IANAは新しいCBOR値のための2つのレジストリを作成しました。レジストリはつまり、ない傘レジストリの下に、分離され、そして、[RFC5226]のルールに従います。 IANAはまた、新しいMIMEメディアタイプとそれに関連する制約アプリケーションプロトコル（CoAP）コンテンツフォーマットのエントリが割り当てられています。"
    },
    {
      "indent": 0,
      "text": "7.1. Simple Values Registry",
      "section_title": true,
      "ja": "7.1。単純な値のレジストリ"
    },
    {
      "indent": 3,
      "text": "IANA has created the \"Concise Binary Object Representation (CBOR) Simple Values\" registry. The initial values are shown in Table 2.",
      "ja": "IANAは、「簡潔なバイナリオブジェクトの表現（CBOR）単純な値」レジストリを作成しました。初期値は、表2に示します。"
    },
    {
      "indent": 3,
      "text": "New entries in the range 0 to 19 are assigned by Standards Action. It is suggested that these Standards Actions allocate values starting with the number 16 in order to reserve the lower numbers for contiguous blocks (if any).",
      "ja": "範囲内の新しいエントリは0〜19までの標準アクションによって割り当てられます。これらの基準アクション連続ブロック（もしあれば）のためのより低い数値を確保するために、数16から始まる値を割り当てることが示唆されます。"
    },
    {
      "indent": 3,
      "text": "New entries in the range 32 to 255 are assigned by Specification Required.",
      "ja": "32〜255の範囲内の新しいエントリは、仕様が必要で割り当てられます。"
    },
    {
      "indent": 0,
      "text": "7.2. Tags Registry",
      "section_title": true,
      "ja": "7.2。タグレジストリ"
    },
    {
      "indent": 3,
      "text": "IANA has created the \"Concise Binary Object Representation (CBOR) Tags\" registry. The initial values are shown in Table 3.",
      "ja": "IANAは、「簡潔なバイナリオブジェクトの表現（CBOR）タグ」レジストリを作成しました。初期値は、表3に示します。"
    },
    {
      "indent": 3,
      "text": "New entries in the range 0 to 23 are assigned by Standards Action. New entries in the range 24 to 255 are assigned by Specification Required. New entries in the range 256 to 18446744073709551615 are assigned by First Come First Served. The template for registration requests is:",
      "ja": "範囲内の新しいエントリは0〜23までの標準アクションによって割り当てられます。 24〜255の範囲内の新しいエントリは、仕様が必要で割り当てられます。 256 18446744073709551615には、まずによって割り当てられた範囲内の新しいエントリは、最初に役立ってきます。登録要求のためのテンプレートは、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o Data item",
      "ja": "Oデータ項目"
    },
    {
      "indent": 3,
      "text": "o Semantics (short form)",
      "ja": "Oセマンティクス（ショートフォーム）"
    },
    {
      "indent": 3,
      "text": "In addition, First Come First Served requests should include:",
      "ja": "また、まず最初に添え是非要求が含まれている必要があります"
    },
    {
      "indent": 3,
      "text": "o Point of contact",
      "ja": "接触のOポイント"
    },
    {
      "indent": 3,
      "text": "o Description of semantics (URL) This description is optional; the URL can point to something like an Internet-Draft or a web page.",
      "ja": "Oセマンティクスの説明（URL）この記述はオプションです。 URLはインターネットドラフトやWebページのようなものを指すことができます。"
    },
    {
      "indent": 0,
      "text": "7.3. Media Type (\"MIME Type\")",
      "section_title": true,
      "ja": "7.3。メディアタイプ（「MIMEタイプ」）"
    },
    {
      "indent": 3,
      "text": "The Internet media type [RFC6838] for CBOR data is application/cbor.",
      "ja": "CBORデータとアプリケーション/ cborのためのインターネットメディアタイプ[RFC6838]。"
    },
    {
      "indent": 3,
      "text": "Type name: application",
      "ja": "型名：アプリケーション"
    },
    {
      "indent": 3,
      "text": "Subtype name: cbor",
      "ja": "サブタイプ名：cbor"
    },
    {
      "indent": 3,
      "text": "Required parameters: n/a",
      "ja": "必須パラメータ：N / A"
    },
    {
      "indent": 3,
      "text": "Optional parameters: n/a",
      "ja": "オプションのパラメータ：N / A"
    },
    {
      "indent": 3,
      "text": "Encoding considerations: binary",
      "ja": "エンコードの考慮事項：バイナリ"
    },
    {
      "indent": 3,
      "text": "Security considerations: See Section 8 of this document",
      "ja": "セキュリティの考慮事項：このドキュメントのセクション8を参照してください。"
    },
    {
      "indent": 3,
      "text": "Interoperability considerations: n/a",
      "ja": "相互運用性に関する注意事項：N / A"
    },
    {
      "indent": 3,
      "text": "Published specification: This document",
      "ja": "公開された仕様：このドキュメント"
    },
    {
      "indent": 3,
      "text": "Applications that use this media type: None yet, but it is expected that this format will be deployed in protocols and applications.",
      "ja": "まだなし、しかしこのフォーマットは、プロトコルやアプリケーションに配備されることが期待されます。このメディアタイプを使用するアプリケーション。"
    },
    {
      "indent": 3,
      "text": "Additional information: Magic number(s): n/a File extension(s): .cbor Macintosh file type code(s): n/a",
      "ja": "追加情報：マジックナンバー（S）：N /ファイルの拡張子（S）：.cbor Macintoshファイルタイプコード（S）：N / A"
    },
    {
      "indent": 3,
      "text": "Person & email address to contact for further information: Carsten Bormann cabo@tzi.org",
      "ja": "人とEメールアドレスは、詳細についての問い合わせ先：カルステンボルマンcabo@tzi.org"
    },
    {
      "indent": 3,
      "text": "Intended usage: COMMON",
      "ja": "意図している用法：COMMON"
    },
    {
      "indent": 3,
      "text": "Restrictions on usage: none",
      "ja": "使用に関する制限事項：なし"
    },
    {
      "indent": 3,
      "text": "Author: Carsten Bormann <cabo@tzi.org>",
      "ja": "著者：カールステンボルマン<cabo@tzi.org>"
    },
    {
      "indent": 3,
      "text": "Change controller: The IESG <iesg@ietf.org>",
      "ja": "変更コントローラ：IESG <iesg@ietf.org>"
    },
    {
      "indent": 0,
      "text": "7.4. CoAP Content-Format",
      "section_title": true,
      "ja": "7.4。 CoAPのコンテンツフォーマット"
    },
    {
      "indent": 3,
      "text": "Media Type: application/cbor",
      "ja": "メディアタイプ：アプリケーション/ cbor"
    },
    {
      "indent": 3,
      "text": "Encoding: -",
      "ja": "エンコード： - "
    },
    {
      "indent": 3,
      "text": "Id: 60",
      "ja": "ID：60"
    },
    {
      "indent": 3,
      "text": "Reference: [RFC7049]",
      "ja": "参考：[RFC7049]"
    },
    {
      "indent": 0,
      "text": "7.5. The +cbor Structured Syntax Suffix Registration",
      "section_title": true,
      "ja": "7.5。 + cbor構造化構文サフィックス登録"
    },
    {
      "indent": 3,
      "text": "Name: Concise Binary Object Representation (CBOR)",
      "ja": "名前：簡潔なバイナリオブジェクトの表現（CBOR）"
    },
    {
      "indent": 3,
      "text": "+suffix: +cbor",
      "ja": "+サフィックス：+ cbor"
    },
    {
      "indent": 3,
      "text": "References: [RFC7049]",
      "ja": "参考文献：[RFC7049]"
    },
    {
      "indent": 3,
      "text": "Encoding Considerations: CBOR is a binary format.",
      "ja": "留意事項をコード：CBORはバイナリ形式です。"
    },
    {
      "indent": 3,
      "text": "Interoperability Considerations: n/a",
      "ja": "相互運用性に関する注意事項：N / A"
    },
    {
      "indent": 3,
      "text": "Fragment Identifier Considerations: The syntax and semantics of fragment identifiers specified for +cbor SHOULD be as specified for \"application/cbor\". (At publication of this document, there is no fragment identification syntax defined for \"application/cbor\".)",
      "ja": "フラグメント識別子の考慮事項：構文と+のcborに指定されたフラグメント識別子の意味は、「アプリケーション/ cbor」に指定されるべきです。 （この文書の出版物では、「アプリケーション/ cbor」に定義された断片識別構文が存在しません。）"
    },
    {
      "indent": 6,
      "text": "The syntax and semantics for fragment identifiers for a specific \"xxx/yyy+cbor\" SHOULD be processed as follows:",
      "ja": "特定のためのフラグメント識別子の構文とセマンティクス「XXX / YYY + cbor」は次のように処理する必要があります。"
    },
    {
      "indent": 6,
      "text": "For cases defined in +cbor, where the fragment identifier resolves per the +cbor rules, then process as specified in +cbor.",
      "ja": "+ cborで指定されたフラグメント識別子は、その後、+のcborルールごとにプロセスを解決+ cbor、で定義された場合について。"
    },
    {
      "indent": 6,
      "text": "For cases defined in +cbor, where the fragment identifier does not resolve per the +cbor rules, then process as specified in \"xxx/yyy+cbor\".",
      "ja": "「XXX / YYY + cbor」で指定されたフラグメント識別子は、その後、+のcborルールごとにプロセスが解決されない+ cborで定義された場合、のために。"
    },
    {
      "indent": 6,
      "text": "For cases not defined in +cbor, then process as specified in \"xxx/yyy+cbor\".",
      "ja": "場合によっては、「XXX / YYY + cbor」で指定されるようにプロセス次いで、+ cborに定義されていません。"
    },
    {
      "indent": 3,
      "text": "Security Considerations: See Section 8 of this document",
      "ja": "セキュリティの考慮：このドキュメントのセクション8を参照してください。"
    },
    {
      "indent": 3,
      "text": "Contact: Apps Area Working Group (apps-discuss@ietf.org)",
      "ja": "連絡先：アプリエリアワーキンググループ（apps-discuss@ietf.org）"
    },
    {
      "indent": 3,
      "text": "Author/Change Controller: The Apps Area Working Group. The IESG has change control over this registration.",
      "ja": "著者/変更コントローラ：アプリエリアワーキンググループ。 IESGは、この登録に対する制御を変更しています。"
    },
    {
      "indent": 0,
      "text": "8. Security Considerations",
      "section_title": true,
      "ja": "8.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "A network-facing application can exhibit vulnerabilities in its processing logic for incoming data. Complex parsers are well known as a likely source of such vulnerabilities, such as the ability to remotely crash a node, or even remotely execute arbitrary code on it. CBOR attempts to narrow the opportunities for introducing such vulnerabilities by reducing parser complexity, by giving the entire range of encodable values a meaning where possible.",
      "ja": "ネットワーク側のアプリケーションは、入力データのための処理ロジックの脆弱性を発揮することができます。複合パーサはそのような遠隔ノードがクラッシュ、あるいはリモートで上で任意のコードを実行する能力のような脆弱性の可能性ソースとして知られています。 CBORは符号化可能な値の全範囲を可能な意味を与えることによって、パーサの複雑さを低減することによって、このような脆弱性を導入するための機会を狭くしようとします。"
    },
    {
      "indent": 3,
      "text": "Resource exhaustion attacks might attempt to lure a decoder into allocating very big data items (strings, arrays, maps) or exhaust the stack depth by setting up deeply nested items. Decoders need to have appropriate resource management to mitigate these attacks. (Items for which very large sizes are given can also attempt to exploit integer overflow vulnerabilities.)",
      "ja": "リソースの枯渇攻撃は非常に大きなデータ項目（文字列、配列、マップ）を割り当てるにデコーダを誘惑しようとしたり、深くネストされた項目を設定することにより、スタックの深さを使い果たす可能性があります。デコーダは、これらの攻撃を軽減するために、適切な資源管理を持っている必要があります。 （非常に大きなサイズを与えられている項目は、整数オーバーフローの脆弱性を悪用しようと試みることができます。）"
    },
    {
      "indent": 3,
      "text": "Applications where a CBOR data item is examined by a gatekeeper function and later used by a different application may exhibit vulnerabilities when multiple interpretations of the data item are possible. For example, an attacker could make use of duplicate keys in maps and precision issues in numbers to make the gatekeeper base its decisions on a different interpretation than the one that will be used by the second application. Protocols that are used in a security context should be defined in such a way that these multiple interpretations are reliably reduced to a single one. To facilitate this, encoder and decoder implementations used in such contexts should provide at least one strict mode of operation (Section 3.10).",
      "ja": "データ項目の複数の解釈が可能である場合CBORデータ項目は、ゲートキーパー機能によって調べ、後で別のアプリケーションによって使用されるアプリケーションは、脆弱性を示すことができます。例えば、攻撃者は、ゲートキーパーは、第二のアプリケーションで使用されるものとは異なる解釈にその決定の基礎を作るための番号で地図や精度の問題で重複キーを使用することができます。セキュリティコンテキストで使用されるプロトコルは、これらの複数の解釈が確実に単一のものに還元されるような方法で定義する必要があります。これを容易にするために、そのような文脈で使用されるエンコーダおよびデコーダの実装は、動作の少なくとも一つの厳密モード（3.10）を提供すべきです。"
    },
    {
      "indent": 0,
      "text": "9. Acknowledgements",
      "section_title": true,
      "ja": "9.謝辞"
    },
    {
      "indent": 3,
      "text": "CBOR was inspired by MessagePack. MessagePack was developed and promoted by Sadayuki Furuhashi (\"frsyuki\"). This reference to MessagePack is solely for attribution; CBOR is not intended as a version of or replacement for MessagePack, as it has different design goals and requirements.",
      "ja": "CBORはMessagePackに触発されました。 MessagePackは定征古橋（「frsyuki」）が開発し、促進されました。 MessagePackこの参照は、帰属のためだけです。 CBORは、それが異なる設計目標と要件を持っているとして、MessagePackのためのバージョンまたは代替として意図されていません。"
    },
    {
      "indent": 3,
      "text": "The need for functionality beyond the original MessagePack Specification became obvious to many people at about the same time around the year 2012. BinaryPack is a minor derivation of MessagePack that was developed by Eric Zhang for the binaryjs project. A similar, but different, extension was made by Tim Caswell for his msgpack-js and msgpack-js-browser projects. Many people have contributed to the recent discussion about extending MessagePack to separate text string representation from byte string representation.",
      "ja": "元MessagePack仕様を超えた機能の必要性は、2012年BinaryPackがbinaryjsプロジェクトのためにエリック張によって開発されたMessagePackのマイナー派生ある年の周りにほぼ同時に多くの人々に明らかになりました。同様の、しかし異なる、延長は彼のmsgpack-JSとmsgpack-JS-ブラウザプロジェクトのためのティム・キャスウェルによって作られました。多くの人々は、バイト文字列表現から別のテキスト文字列表現にMessagePackを拡張に関する最近の議論に貢献しています。"
    },
    {
      "indent": 3,
      "text": "The encoding of the additional information in CBOR was inspired by the encoding of length information designed by Klaus Hartke for CoAP.",
      "ja": "CBORにおける付加情報の符号化はCoAPためクラウスHARTKEによって設計された長さ情報の符号化に触発されました。"
    },
    {
      "indent": 3,
      "text": "This document also incorporates suggestions made by many people, notably Dan Frost, James Manger, Joe Hildebrand, Keith Moore, Matthew Lepinski, Nico Williams, Phillip Hallam-Baker, Ray Polk, Tim Bray, Tony Finch, Tony Hansen, and Yaron Sheffer.",
      "ja": "この文書はまた、多くの人々によって作られた提案、特にダンフロスト、ジェームス・マンジェ、ジョー・ヒルデブラント、キースムーア、マシューLepinski、ニコ・ウィリアムズ、フィリップハラム - ベイカー、レイ・ポルク、ティム・ブレイ、トニー・フィンチ、トニー・ハンセン、およびヤロン・シェイファーが組み込まれています。"
    },
    {
      "indent": 0,
      "text": "10. References",
      "section_title": true,
      "ja": "10.参考文献"
    },
    {
      "indent": 0,
      "text": "10.1. Normative References",
      "section_title": true,
      "ja": "10.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[ECMA262] European Computer Manufacturers Association, \"ECMAScript Language Specification 5.1 Edition\", ECMA Standard ECMA-262, June 2011, <http://www.ecma-international.org/ publications/files/ecma-st/ECMA-262.pdf>.",
      "ja": "[ECMA262]ヨーロッパ電子計算機工業会、 \"ECMAScriptの言語仕様5.1版\"、ECMA標準ECMA262、2011年6月、<http://www.ecma-international.org/出版/ファイル/ ECMA-ST / ECMA262。 PDF>。"
    },
    {
      "indent": 3,
      "text": "[RFC2045] Freed, N. and N. Borenstein, \"Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies\", RFC 2045, November 1996.",
      "ja": "[RFC2045]解放され、N.とN. Borenstein、 \"マルチパーパスインターネットメールエクステンション（MIME）第一部：インターネットメッセージ本体のフォーマット\"、RFC 2045、1996年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC3339] Klyne, G., Ed. and C. Newman, \"Date and Time on the Internet: Timestamps\", RFC 3339, July 2002.",
      "ja": "[RFC3339] Klyne、G.、エド。そして、C.ニューマン、「インターネット上の日付と時刻：タイムスタンプ」、RFC 3339、2002年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC3629] Yergeau, F., \"UTF-8, a transformation format of ISO 10646\", STD 63, RFC 3629, November 2003.",
      "ja": "[RFC3629] Yergeau、F.、 \"UTF-8、ISO 10646の変換フォーマット\"、STD 63、RFC 3629、2003年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC3986] Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform Resource Identifier (URI): Generic Syntax\", STD 66, RFC 3986, January 2005.",
      "ja": "[RFC3986]バーナーズ - リー、T.、フィールディング、R.、およびL. Masinter、 \"ユニフォームリソース識別子（URI）：汎用構文\"、STD 66、RFC 3986、2005年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC4287] Nottingham, M., Ed. and R. Sayre, Ed., \"The Atom Syndication Format\", RFC 4287, December 2005.",
      "ja": "[RFC4287]ノッティンガム、M.、エド。そして、R.セイヤー、エド。、 \"Atom配信フォーマット\"、RFC 4287、2005年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC4648] Josefsson, S., \"The Base16, Base32, and Base64 Data Encodings\", RFC 4648, October 2006.",
      "ja": "[RFC4648] Josefsson氏、S.、 \"Base16、Base32、およびBase64でデータエンコーディング\"、RFC 4648、2006年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC5226] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 5226, May 2008.",
      "ja": "[RFC5226] Narten氏、T.とH. Alvestrand、 \"RFCsにIANA問題部に書くためのガイドライン\"、BCP 26、RFC 5226、2008年5月。"
    },
    {
      "indent": 3,
      "text": "[TIME_T] The Open Group Base Specifications, \"Vol. 1: Base Definitions, Issue 7\", Section 4.15 'Seconds Since the Epoch', IEEE Std 1003.1, 2013 Edition, 2013, <http://pubs.opengroup.org/onlinepubs/9699919799/ basedefs/V1_chap04.html#tag_04_15>.",
      "ja": "【のtime_t] Open Groupの基本仕様、 \"第1巻：ベース定義、問題7\"、セクション4.15 'エポック秒'、IEEE STD 1003.1 2013年版、2013年<http://pubs.opengroup.org/ onlinepubs / 9699919799 / basedefs / V1_chap04.html＃tag_04_15>。"
    },
    {
      "indent": 0,
      "text": "10.2. Informative References",
      "section_title": true,
      "ja": "10.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[ASN.1] International Telecommunication Union, \"Information Technology -- ASN.1 encoding rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER)\", ITU-T Recommendation X.690, 1994.",
      "ja": "[ASN.1]国際電気通信連合、 \"情報技術 -  ASN.1エンコーディング規則：基本符号化規則（BER）、Canonicalの符号化規則（CER）、および顕著な符号化規則（DER）の仕様\"、ITU-T勧告X. 690、1994。"
    },
    {
      "indent": 3,
      "text": "[BSON] Various, \"BSON - Binary JSON\", 2013, <http://bsonspec.org/>.",
      "ja": "[BSON様々な、 \"BSON  - バイナリJSON\" 2013年、<http://bsonspec.org/>。"
    },
    {
      "indent": 3,
      "text": "[CNN-TERMS] Bormann, C., Ersue, M., and A. Keranen, \"Terminology for Constrained Node Networks\", Work in Progress, July 2013.",
      "ja": "[CNN-TERMS]ボルマン、C.、Ersue、M.、およびA. Keranen、 \"制約ノードネットワークの用語\"、進歩、2013年7月での作業。"
    },
    {
      "indent": 3,
      "text": "[MessagePack] Furuhashi, S., \"MessagePack\", 2013, <http://msgpack.org/>.",
      "ja": "「めっさげぱｃｋ」 ふるはし、 Ｓ。、 ”めっさげぱｃｋ”、 ２０１３、 ＜ｈっｔｐ：／／ｍｓｇぱｃｋ。おｒｇ／＞。"
    },
    {
      "indent": 3,
      "text": "[RFC0713] Haverty, J., \"MSDTP-Message Services Data Transmission Protocol\", RFC 713, April 1976.",
      "ja": "[RFC0713] Haverty、J.、 \"MSDTP・メッセージ・サービス・データ伝送プロトコル\"、RFC 713、1976年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC4627] Crockford, D., \"The application/json Media Type for JavaScript Object Notation (JSON)\", RFC 4627, July 2006.",
      "ja": "[RFC4627]クロックフォード、D.、RFC 4627、2006年7月 \"JavaScriptのObject Notation（JSON）形式のためのアプリケーション/ JSONのメディアタイプ\"。"
    },
    {
      "indent": 3,
      "text": "[RFC6838] Freed, N., Klensin, J., and T. Hansen, \"Media Type Specifications and Registration Procedures\", BCP 13, RFC 6838, January 2013.",
      "ja": "[RFC6838]解放され、N.、Klensin、J.、およびT.ハンセン、 \"メディアタイプの仕様と登録手順\"、BCP 13、RFC 6838、2013年1月。"
    },
    {
      "indent": 3,
      "text": "[UBJSON] The Buzz Media, \"Universal Binary JSON Specification\", 2013, <http://ubjson.org/>.",
      "ja": "[UBJSON]バズメディア、 \"ユニバーサルバイナリJSON仕様書\"、2013年、<http://ubjson.org/>。"
    },
    {
      "indent": 3,
      "text": "[YAML] Ben-Kiki, O., Evans, C., and I. Net, \"YAML Ain't Markup Language (YAML[TM]) Version 1.2\", 3rd Edition, October 2009, <http://www.yaml.org/spec/1.2/spec.html>.",
      "ja": "// WWW：[YAML]ベン・キキ、O.、エバンス、C.、およびI.ネット、第3版、2009年10月、<HTTP \"YAMLはマークアップ言語（YAML [TM]）バージョン1.2ではないです\"。 > yaml.org/spec/1.2/spec.html。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Examples",
      "ja": "付録A.例"
    },
    {
      "indent": 3,
      "text": "The following table provides some CBOR-encoded values in hexadecimal (right column), together with diagnostic notation for these values (left column). Note that the string \"\\u00fc\" is one form of diagnostic notation for a UTF-8 string containing the single Unicode character U+00FC, LATIN SMALL LETTER U WITH DIAERESIS (u umlaut). Similarly, \"\\u6c34\" is a UTF-8 string in diagnostic notation with a single character U+6C34 (CJK UNIFIED IDEOGRAPH-6C34, often representing \"water\"), and \"\\ud800\\udd51\" is a UTF-8 string in diagnostic notation with a single character U+10151 (GREEK ACROPHONIC ATTIC FIFTY STATERS). (Note that all these single-character strings could also be represented in native UTF-8 in diagnostic notation, just not in an ASCII-only specification like the present one.) In the diagnostic notation provided for bignums, their intended numeric value is shown as a decimal number (such as 18446744073709551616) instead of showing a tagged byte string (such as 2(h'010000000000000000')).",
      "ja": "以下の表は、一緒になって、これらの値の診断表記（左列）と、進数（右欄）内のいくつかCBORエンコード値を提供します。文字列「\\ u00fc」は、単一のユニコード文字U + 00FC、分音記号付きラテン小文字U（Uウムラウト）を含むUTF-8文字列の診断表記法の一の形態であることに留意されたいです。同様に、 \"\\ u6c34\" は、単一の文字U + 6C34と診断表記のUTF-8文字列（しばしば \"水\" を表すCJK UNIFIED表意文字-6C34）であり、 \"\\ ud800 \\ udd51\" はでUTF-8文字列であります単一文字U + 10151（ギリシャ語ACROPHONIC ATTIC FIFTY STATERS）と診断表記。 （これらのすべての単一文字列はまただけ存在しないようなASCIIのみ明細書において、診断表記でネイティブUTF-8で表すことができることに留意されたい。）bignumsために提供される診断表記では、それらの意図された数値が示されています（例えば18446744073709551616など）10進数の代わりに、（例えば2（h'010000000000000000' ）のような）タグ付きのバイト・ストリングを示します。"
    },
    {
      "indent": 3,
      "text": "+------------------------------+------------------------------------+\n| Diagnostic                   | Encoded                            |\n+------------------------------+------------------------------------+\n| 0                            | 0x00                               |\n|                              |                                    |\n| 1                            | 0x01                               |\n|                              |                                    |\n| 10                           | 0x0a                               |\n|                              |                                    |\n| 23                           | 0x17                               |\n|                              |                                    |\n| 24                           | 0x1818                             |\n|                              |                                    |\n| 25                           | 0x1819                             |\n|                              |                                    |\n| 100                          | 0x1864                             |\n|                              |                                    |\n| 1000                         | 0x1903e8                           |\n|                              |                                    |\n| 1000000                      | 0x1a000f4240                       |\n|                              |                                    |\n| 1000000000000                | 0x1b000000e8d4a51000               |\n|                              |                                    |\n| 18446744073709551615         | 0x1bffffffffffffffff               |\n|                              |                                    |\n| 18446744073709551616         | 0xc249010000000000000000           |\n|                              |                                    |\n| -18446744073709551616        | 0x3bffffffffffffffff               |\n|                              |                                    |",
      "raw": true
    },
    {
      "indent": 3,
      "text": "| -18446744073709551617 | 0xc349010000000000000000 | | | | | -1 | 0x20 | | | | | -10 | 0x29 | | | | | -100 | 0x3863 | | | | | -1000 | 0x3903e7 | | | | | 0.0 | 0xf90000 | | | | | -0.0 | 0xf98000 | | | | | 1.0 | 0xf93c00 | | | | | 1.1 | 0xfb3ff199999999999a | | | | | 1.5 | 0xf93e00 | | | | | 65504.0 | 0xf97bff | | | | | 100000.0 | 0xfa47c35000 | | | | | 3.4028234663852886e+38 | 0xfa7f7fffff | | | | | 1.0e+300 | 0xfb7e37e43c8800759c | | | | | 5.960464477539063e-8 | 0xf90001 | | | | | 0.00006103515625 | 0xf90400 | | | | | -4.0 | 0xf9c400 | | | | | -4.1 | 0xfbc010666666666666 | | | | | Infinity | 0xf97c00 | | | | | NaN | 0xf97e00 | | | | | -Infinity | 0xf9fc00 | | | | | Infinity | 0xfa7f800000 | | | | | NaN | 0xfa7fc00000 | | | | | -Infinity | 0xfaff800000 | | | |",
      "ja": "| -18446744073709551617 | 0xc349010000000000000000 | | | | | -1 | 0x20の| | | | | -10 | 0x29 | | | | | -100 | 0x3863 | | | | | -1000 | 0x3903e7 | | | | | 0.0 | 0xf90000 | | | | | -0.0 | 0xf98000 | | | | | 1.0 | 0xf93c00 | | | | | 1.1 | 0xfb3ff199999999999a | | | | | 1.5 | 0xf93e00 | | | | | 65504.0 | 0xf97bff | | | | | 100000.0 | 0xfa47c35000 | | | | | + 38 3.4028234663852886e | 0xfa7f7fffff | | | | | 1.0E + 300 | 0xfb7e37e43c8800759c | | | | | 5.960464477539063e-8 | 0xf90001 | | | | | 0.00006103515625 | 0xf90400 | | | | | -4.0 | 0xf9c400 | | | | | -4.1 | 0xfbc010666666666666 | | | | |インフィニティ| 0xf97c00 | | | | | NaNで| 0xf97e00 | | | | | -Infinity | 0xf9fc00 | | | | |インフィニティ| 0xfa7f800000 | | | | | NaNで| 0xfa7fc00000 | | | | | -Infinity | 0xfaff800000 | | | |"
    },
    {
      "indent": 3,
      "text": "| Infinity | 0xfb7ff0000000000000 | | | | | NaN | 0xfb7ff8000000000000 | | | | | -Infinity | 0xfbfff0000000000000 | | | | | false | 0xf4 | | | | | true | 0xf5 | | | | | null | 0xf6 | | | | | undefined | 0xf7 | | | | | simple(16) | 0xf0 | | | | | simple(24) | 0xf818 | | | | | simple(255) | 0xf8ff | | | | | 0(\"2013-03-21T20:04:00Z\") | 0xc074323031332d30332d32315432303a | | | 30343a30305a | | | | | 1(1363896240) | 0xc11a514b67b0 | | | | | 1(1363896240.5) | 0xc1fb41d452d9ec200000 | | | | | 23(h'01020304') | 0xd74401020304 | | | | | 24(h'6449455446') | 0xd818456449455446 | | | | | 32(\"http://www.example.com\") | 0xd82076687474703a2f2f7777772e6578 | | | 616d706c652e636f6d | | | | | h'' | 0x40 | | | | | h'01020304' | 0x4401020304 | | | | | \"\" | 0x60 | | | | | \"a\" | 0x6161 | | | | | \"IETF\" | 0x6449455446 | | | | | \"\\\"\\\\\" | 0x62225c | | | | | \"\\u00fc\" | 0x62c3bc | | | |",
      "ja": "|インフィニティ| 0xfb7ff0000000000000 | | | | | NaNで| 0xfb7ff8000000000000 | | | | | -Infinity | 0xfbfff0000000000000 | | | | |偽| 0xf4 | | | | |真| 0xf5 | | | | |ヌル| 0xf6 | | | | |未定義| 0xf7 | | | | |簡単な（16）| 0xF0 | | | | |簡単な（24）| 0xf818 | | | | |簡単な（255）| 0xf8ff | | | | | 0（ \"2013-03-21T20：04：00Z\"）| 0xc074323031332d30332d32315432303a | | | 30343a30305a | | | | | 1（1363896240）| 0xc11a514b67b0 | | | | | 1（1363896240.5）| 0xc1fb41d452d9ec200000 | | | | | 23（h'01020304' ）| 0xd74401020304 | | | | | 24（h'6449455446' ）| 0xd818456449455446 | | | | | 32（ \"http://www.example.com\"）| 0xd82076687474703a2f2f7777772e6578 | | | 616d706c652e636f6d | | | | | H '' | 0x40の| | | | | h'01020304' | 0x4401020304 | | | | | \"\" | 0x60 | | | | | 「」| 0x6161 | | | | | \"IETF\" | 0x6449455446 | | | | | \"\\\" \\\\」| 0x62225c | | | | | \"\\ u00fc\" | 0x62c3bc | | | |"
    },
    {
      "indent": 3,
      "text": "| \"\\u6c34\"                     | 0x63e6b0b4                         |\n|                              |                                    |\n| \"\\ud800\\udd51\"               | 0x64f0908591                       |\n|                              |                                    |\n| []                           | 0x80                               |\n|                              |                                    |\n| [1, 2, 3]                    | 0x83010203                         |\n|                              |                                    |\n| [1, [2, 3], [4, 5]]          | 0x8301820203820405                 |\n|                              |                                    |\n| [1, 2, 3, 4, 5, 6, 7, 8, 9,  | 0x98190102030405060708090a0b0c0d0e |\n| 10, 11, 12, 13, 14, 15, 16,  | 0f101112131415161718181819         |\n| 17, 18, 19, 20, 21, 22, 23,  |                                    |\n| 24, 25]                      |                                    |\n|                              |                                    |\n| {}                           | 0xa0                               |\n|                              |                                    |\n| {1: 2, 3: 4}                 | 0xa201020304                       |\n|                              |                                    |\n| {\"a\": 1, \"b\": [2, 3]}        | 0xa26161016162820203               |\n|                              |                                    |\n| [\"a\", {\"b\": \"c\"}]            | 0x826161a161626163                 |\n|                              |                                    |\n| {\"a\": \"A\", \"b\": \"B\", \"c\":    | 0xa5616161416162614261636143616461 |\n| \"C\", \"d\": \"D\", \"e\": \"E\"}     | 4461656145                         |\n|                              |                                    |\n| (_ h'0102', h'030405')       | 0x5f42010243030405ff               |\n|                              |                                    |\n| (_ \"strea\", \"ming\")          | 0x7f657374726561646d696e67ff       |\n|                              |                                    |\n| [_ ]                         | 0x9fff                             |\n|                              |                                    |\n| [_ 1, [2, 3], [_ 4, 5]]      | 0x9f018202039f0405ffff             |\n|                              |                                    |\n| [_ 1, [2, 3], [4, 5]]        | 0x9f01820203820405ff               |\n|                              |                                    |\n| [1, [2, 3], [_ 4, 5]]        | 0x83018202039f0405ff               |\n|                              |                                    |\n| [1, [_ 2, 3], [4, 5]]        | 0x83019f0203ff820405               |\n|                              |                                    |\n| [_ 1, 2, 3, 4, 5, 6, 7, 8,   | 0x9f0102030405060708090a0b0c0d0e0f |\n| 9, 10, 11, 12, 13, 14, 15,   | 101112131415161718181819ff         |\n| 16, 17, 18, 19, 20, 21, 22,  |                                    |\n| 23, 24, 25]                  |                                    |\n|                              |                                    |\n| {_ \"a\": 1, \"b\": [_ 2, 3]}    | 0xbf61610161629f0203ffff           |\n|                              |                                    |",
      "raw": true
    },
    {
      "indent": 3,
      "text": "| [\"a\", {_ \"b\": \"c\"}]          | 0x826161bf61626163ff               |\n|                              |                                    |\n| {_ \"Fun\": true, \"Amt\": -2}   | 0xbf6346756ef563416d7421ff         |\n+------------------------------+------------------------------------+",
      "raw": true
    },
    {
      "indent": 15,
      "text": "Table 4: Examples of Encoded CBOR Data Items",
      "ja": "表4：エンコードCBORデータ項目の例"
    },
    {
      "indent": 0,
      "text": "Appendix B. Jump Table",
      "ja": "付録B.ジャンプ表"
    },
    {
      "indent": 3,
      "text": "For brevity, this jump table does not show initial bytes that are reserved for future extension. It also only shows a selection of the initial bytes that can be used for optional features. (All unsigned integers are in network byte order.)",
      "ja": "簡潔にするため、このジャンプテーブルは、将来の拡張のために予約されている最初のバイトは表示されません。それはまた、唯一のオプション機能のために使用することができる最初のバイトの選択を示します。 （すべての符号なし整数はネットワークバイトオーダーです。）"
    },
    {
      "indent": 3,
      "text": "+-----------------+-------------------------------------------------+\n| Byte            | Structure/Semantics                             |\n+-----------------+-------------------------------------------------+\n| 0x00..0x17      | Integer 0x00..0x17 (0..23)                      |\n|                 |                                                 |\n| 0x18            | Unsigned integer (one-byte uint8_t follows)     |\n|                 |                                                 |\n| 0x19            | Unsigned integer (two-byte uint16_t follows)    |\n|                 |                                                 |\n| 0x1a            | Unsigned integer (four-byte uint32_t follows)   |\n|                 |                                                 |\n| 0x1b            | Unsigned integer (eight-byte uint64_t follows)  |\n|                 |                                                 |\n| 0x20..0x37      | Negative integer -1-0x00..-1-0x17 (-1..-24)     |\n|                 |                                                 |\n| 0x38            | Negative integer -1-n (one-byte uint8_t for n   |\n|                 | follows)                                        |\n|                 |                                                 |\n| 0x39            | Negative integer -1-n (two-byte uint16_t for n  |\n|                 | follows)                                        |\n|                 |                                                 |\n| 0x3a            | Negative integer -1-n (four-byte uint32_t for n |\n|                 | follows)                                        |\n|                 |                                                 |\n| 0x3b            | Negative integer -1-n (eight-byte uint64_t for  |\n|                 | n follows)                                      |\n|                 |                                                 |\n| 0x40..0x57      | byte string (0x00..0x17 bytes follow)           |\n|                 |                                                 |\n| 0x58            | byte string (one-byte uint8_t for n, and then n |\n|                 | bytes follow)                                   |\n|                 |                                                 |\n| 0x59            | byte string (two-byte uint16_t for n, and then  |\n|                 | n bytes follow)                                 |",
      "raw": true
    },
    {
      "indent": 3,
      "text": "| | | | 0x5a | byte string (four-byte uint32_t for n, and then | | | n bytes follow) | | | | | 0x5b | byte string (eight-byte uint64_t for n, and | | | then n bytes follow) | | | | | 0x5f | byte string, byte strings follow, terminated by | | | \"break\" | | | | | 0x60..0x77 | UTF-8 string (0x00..0x17 bytes follow) | | | | | 0x78 | UTF-8 string (one-byte uint8_t for n, and then | | | n bytes follow) | | | | | 0x79 | UTF-8 string (two-byte uint16_t for n, and then | | | n bytes follow) | | | | | 0x7a | UTF-8 string (four-byte uint32_t for n, and | | | then n bytes follow) | | | | | 0x7b | UTF-8 string (eight-byte uint64_t for n, and | | | then n bytes follow) | | | | | 0x7f | UTF-8 string, UTF-8 strings follow, terminated | | | by \"break\" | | | | | 0x80..0x97 | array (0x00..0x17 data items follow) | | | | | 0x98 | array (one-byte uint8_t for n, and then n data | | | items follow) | | | | | 0x99 | array (two-byte uint16_t for n, and then n data | | | items follow) | | | | | 0x9a | array (four-byte uint32_t for n, and then n | | | data items follow) | | | | | 0x9b | array (eight-byte uint64_t for n, and then n | | | data items follow) | | | | | 0x9f | array, data items follow, terminated by \"break\" | | | | | 0xa0..0xb7 | map (0x00..0x17 pairs of data items follow) | | | | | 0xb8 | map (one-byte uint8_t for n, and then n pairs | | | of data items follow) | | | |",
      "ja": "| | | | 0x5a | （その後、nの4バイトのuint32_t、および| | | nバイトが続く）バイト文字列| | | | | 0x5b |バイト文字列（nの8バイトのuint64_tを、および| | |そして、nバイトが続きます）| | | | | 0x5f | |バイト文字列は、バイト文字列がで終了し、続きます| | 「休憩」| | | | | 0x60..0x77 | UTF-8文字列（0x00..0x17バイトが続きます）| | | | | 0x78と| UTF-8文字列（nの1バイトuint8_t、その後、| | | nバイトが続きます）| | | | | 0x79 | UTF-8文字列（nの2バイトのuint16_t、その後、| | | nバイトが続きます）| | | | | 0x7Aの| UTF-8文字列（nの4バイトのuint32_t、および| | |そして、nバイトが続きます）| | | | | 0x7Bと| UTF-8文字列（nの8バイトのuint64_tを、および| | |そして、nバイトが続きます）| | | | | 0x7f | | UTF-8文字列、UTF-8文字列が終了し、続きます| | 「休憩」によります| | | | | 0x80..0x97 |配列（0x00..0x17データ項目が続きます）| | | | | 0×98 |アレイ（Nための1バイトuint8_t、次いでn個のデータ| | |商品従います）| | | | | 0x99 |アレイ（| | |項目が続く2つのバイトuint16_t N、次にn個のデータ用）| | | | | 0x9a |アレイ（| | |のデータ項目が続く4バイトのuint32_t次いでN、及びnについて）| | | | | 0x9b |配列（nの8バイトのuint64_tを、その後、N | | |データ項目が続きます）| | | | | 0x9f | 「ブレイク」で終わる配列、データ項目は、次のとおり| | | | | 0xa0..0xb7 |マップ（データ項目の0x00..0x17ペアが続きます）| | | | | 0xb8 |マップ（nの1バイトuint8_t、その後、n個のペア| | |データ項目の従います）| | | |"
    },
    {
      "indent": 3,
      "text": "| 0xb9 | map (two-byte uint16_t for n, and then n pairs | | | of data items follow) | | | | | 0xba | map (four-byte uint32_t for n, and then n pairs | | | of data items follow) | | | | | 0xbb | map (eight-byte uint64_t for n, and then n | | | pairs of data items follow) | | | | | 0xbf | map, pairs of data items follow, terminated by | | | \"break\" | | | | | 0xc0 | Text-based date/time (data item follows; see | | | Section 2.4.1) | | | | | 0xc1 | Epoch-based date/time (data item follows; see | | | Section 2.4.1) | | | | | 0xc2 | Positive bignum (data item \"byte string\" | | | follows) | | | | | 0xc3 | Negative bignum (data item \"byte string\" | | | follows) | | | | | 0xc4 | Decimal Fraction (data item \"array\" follows; | | | see Section 2.4.3) | | | | | 0xc5 | Bigfloat (data item \"array\" follows; see | | | Section 2.4.3) | | | | | 0xc6..0xd4 | (tagged item) | | | | | 0xd5..0xd7 | Expected Conversion (data item follows; see | | | Section 2.4.4.2) | | | | | 0xd8..0xdb | (more tagged items, 1/2/4/8 bytes and then a | | | data item follow) | | | | | 0xe0..0xf3 | (simple value) | | | | | 0xf4 | False | | | | | 0xf5 | True | | | | | 0xf6 | Null | | | | | 0xf7 | Undefined | | | |",
      "ja": "| 0xb9 |マップ（nの2バイトのuint16_t、その後、n個のペア| | |データ項目の従います）| | | | | 0xba |マップ（nの4バイトのuint32_t、その後、n個のペア| | |データ項目の従います）| | | | | 0xbb |マップ（nの8バイトのuint64_tを、その後、N | | |データ項目のペアが続きます）| | | | | 0xbfの|終了マップ、データ項目のペアが続きます、| | | 「休憩」| | | | | 0xc0から|テキストベースの日付/時間（データ項目は、以下参照; | | | 2.4.1項）| | | | | 0xc1 |エポックベースの日付/時間（データ項目は、以下参照; | | | 2.4.1項）| | | | | 0xC2 |正BIGNUM（データ項目 \"バイト列\" | | |次の）| | | | | 0xc3 |負BIGNUM（データ項目 \"バイト列\" | | |次の）| | | | | 0xc4 | |;小数（| 2.4.3を参照してください| |データ項目「アレイ」は以下） | | | | 0xc5 |ビッグフロート（データ項目 \"アレイ\" は以下参照; | | |セクション2.4.3）| | | | | 0xc6..0xd4 | （タグ付けされたアイテム）| | | | | 0xd5..0xd7 |期待の変換（データ項目は、以下参照; | | |セクション2.4.4.2）| | | | | 0xd8..0xdb | （複数のタグ付き商品、1/2/4/8バイト、その後| | |データ項目のフォロー）| | | | | 0xe0..0xf3 | （単純な値）| | | | | 0xf4 |偽| | | | | 0xf5 |真| | | | | 0xf6 |ヌル| | | | | 0xf7 |未定義| | | |"
    },
    {
      "indent": 3,
      "text": "| 0xf8            | (simple value, one byte follows)                |\n|                 |                                                 |\n| 0xf9            | Half-Precision Float (two-byte IEEE 754)        |\n|                 |                                                 |\n| 0xfa            | Single-Precision Float (four-byte IEEE 754)     |\n|                 |                                                 |\n| 0xfb            | Double-Precision Float (eight-byte IEEE 754)    |\n|                 |                                                 |\n| 0xff            | \"break\" stop code                               |\n+-----------------+-------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 19,
      "text": "Table 5: Jump Table for Initial Byte",
      "ja": "表5：初期Byteのジャンプテーブル"
    },
    {
      "indent": 0,
      "text": "Appendix C. Pseudocode",
      "ja": "付録C.擬似コード"
    },
    {
      "indent": 3,
      "text": "The well-formedness of a CBOR item can be checked by the pseudocode in Figure 1. The data is well-formed if and only if:",
      "ja": "CBOR項目の適格性は、データが場合にのみ、十分に形成されている図1の擬似コードによって確認することができます。"
    },
    {
      "indent": 3,
      "text": "o the pseudocode does not \"fail\";",
      "ja": "O擬似コードは「失敗」しません。"
    },
    {
      "indent": 3,
      "text": "o after execution of the pseudocode, no bytes are left in the input (except in streaming applications)",
      "ja": "O擬似コードの実行後、何バイトが（ストリーミングアプリケーションを除く）入力に残っていません"
    },
    {
      "indent": 3,
      "text": "The pseudocode has the following prerequisites:",
      "ja": "擬似コードは、次の前提条件があります。"
    },
    {
      "indent": 3,
      "text": "o take(n) reads n bytes from the input data and returns them as a byte string. If n bytes are no longer available, take(n) fails.",
      "ja": "O（n）は、入力データからnバイトを読み取り、バイト列としてそれらを返し取ります。 nバイトが使用できなくなっている場合は、（n）は失敗かかりません。"
    },
    {
      "indent": 3,
      "text": "o uint() converts a byte string into an unsigned integer by interpreting the byte string in network byte order.",
      "ja": "O UINT（）ネットワークバイト順のバイト文字列を解釈することによって、符号なし整数にバイト文字列を変換します。"
    },
    {
      "indent": 3,
      "text": "o Arithmetic works as in C.",
      "ja": "O算術演算は、Cと同様に動作します"
    },
    {
      "indent": 3,
      "text": "o All variables are unsigned integers of sufficient range.",
      "ja": "Oすべての変数は、十分な範囲の符号なし整数です。"
    },
    {
      "indent": 3,
      "text": "well_formed (breakable = false) {\n  // process initial bytes\n  ib = uint(take(1));\n  mt = ib >> 5;\n  val = ai = ib & 0x1f;\n  switch (ai) {\n    case 24: val = uint(take(1)); break;\n    case 25: val = uint(take(2)); break;\n    case 26: val = uint(take(4)); break;\n    case 27: val = uint(take(8)); break;\n    case 28: case 29: case 30: fail();\n    case 31:\n      return well_formed_indefinite(mt, breakable);\n  }\n  // process content\n  switch (mt) {\n    // case 0, 1, 7 do not have content; just use val\n    case 2: case 3: take(val); break; // bytes/UTF-8\n    case 4: for (i = 0; i < val; i++) well_formed(); break;\n    case 5: for (i = 0; i < val*2; i++) well_formed(); break;\n    case 6: well_formed(); break;     // 1 embedded data item\n  }\n  return mt;                    // finite data item\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "well_formed_indefinite(mt, breakable) {\n  switch (mt) {\n    case 2: case 3:\n      while ((it = well_formed(true)) != -1)\n        if (it != mt)           // need finite embedded\n          fail();               //    of same type\n      break;\n    case 4: while (well_formed(true) != -1); break;\n    case 5: while (well_formed(true) != -1) well_formed(); break;\n    case 7:\n      if (breakable)\n        return -1;              // signal break out\n      else fail();              // no enclosing indefinite\n    default: fail();            // wrong mt\n  }\n  return 0;                     // no break out\n}",
      "raw": true
    },
    {
      "indent": 14,
      "text": "Figure 1: Pseudocode for Well-Formedness Check",
      "ja": "図1：整形式チェックのための擬似コード"
    },
    {
      "indent": 3,
      "text": "Note that the remaining complexity of a complete CBOR decoder is about presenting data that has been parsed to the application in an appropriate form.",
      "ja": "完全CBORデコーダの残りの複雑さは、適切な形でアプリケーションに解析されたデータを提示することについてであることに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "Major types 0 and 1 are designed in such a way that they can be encoded in C from a signed integer without actually doing an if-then-else for positive/negative (Figure 2). This uses the fact that (-1-n), the transformation for major type 1, is the same as ~n (bitwise complement) in C unsigned arithmetic; ~n can then be expressed as (-1)^n for the negative case, while 0^n leaves n unchanged for non-negative. The sign of a number can be converted to -1 for negative and 0 for non-negative (0 or positive) by arithmetic-shifting the number by one bit less than the bit length of the number (for example, by 63 for 64-bit numbers).",
      "ja": "主要なタイプ0および1は、それらが実際に正/負（図2）のためにIF-THEN-ELSE行うことなく、符号付き整数からCに符号化することができるように設計されています。これは、（-1-n）は、主要なタイプ1の変換は、C符号なし算術演算で〜N（ビット単位の補数）と同じであるという事実を使用します。 0 ^ nは、非負のための不変のnを残しながら〜N次いで、N ^（-1）として負の場合のために発現させることができます。数の符号はにより非陰性（0または正）のために負のため-1及び0に変換することができる64 63によって、例えば数のビット長（より少ない1ビット数を算術シフトビット数）。"
    },
    {
      "indent": 3,
      "text": "void encode_sint(int64_t n) {\n  uint64t ui = n >> 63;    // extend sign to whole length\n  mt = ui & 0x20;          // extract major type\n  ui ^= n;                 // complement negatives\n  if (ui < 24)\n    *p++ = mt + ui;\n  else if (ui < 256) {\n    *p++ = mt + 24;\n    *p++ = ui;\n  } else\n       ...",
      "raw": true
    },
    {
      "indent": 12,
      "text": "Figure 2: Pseudocode for Encoding a Signed Integer",
      "ja": "図2：符号付き整数を符号化する擬似コード"
    },
    {
      "indent": 0,
      "text": "Appendix D. Half-Precision",
      "ja": "付録D.半精度"
    },
    {
      "indent": 3,
      "text": "As half-precision floating-point numbers were only added to IEEE 754 in 2008, today's programming platforms often still only have limited support for them. It is very easy to include at least decoding support for them even without such support. An example of a small decoder for half-precision floating-point numbers in the C language is shown in Figure 3. A similar program for Python is in Figure 4; this code assumes that the 2-byte value has already been decoded as an (unsigned short) integer in network byte order (as would be done by the pseudocode in Appendix C).",
      "ja": "半精度浮動小数点数は、唯一2008年にIEEE 754に追加されたとして、今日のプログラミングプラットフォームは、多くの場合、まだそれらのみを限定的にサポートしています。少なくともさえ、このようなサポートなしでそれらのためのサポートをデコード含めることは非常に簡単です。 C言語の半精度浮動小数点数のための小さなデコーダの例はPythonのための同様のプログラムは、図4にある図3に示されています。このコードは、2バイトの値は既にネットワークバイト順（付録Cの擬似コードによって行われるであろうように）に（符号なしshort）整数として復号されたと仮定しています。"
    },
    {
      "indent": 3,
      "text": "#include <math.h>",
      "ja": "書式#include <math.h>の"
    },
    {
      "indent": 3,
      "text": "double decode_half(unsigned char *halfp) {\n  int half = (halfp[0] << 8) + halfp[1];\n  int exp = (half >> 10) & 0x1f;\n  int mant = half & 0x3ff;\n  double val;\n  if (exp == 0) val = ldexp(mant, -24);\n  else if (exp != 31) val = ldexp(mant + 1024, exp - 25);\n  else val = mant == 0 ? INFINITY : NAN;\n  return half & 0x8000 ? -val : val;\n}",
      "raw": true
    },
    {
      "indent": 15,
      "text": "Figure 3: C Code for a Half-Precision Decoder",
      "ja": "図3：半精度デコーダのためのCコード"
    },
    {
      "indent": 3,
      "text": "import struct from math import ldexp",
      "ja": "数学の輸入ldexpからの輸入構造体"
    },
    {
      "indent": 3,
      "text": "def decode_single(single): return struct.unpack(\"!f\", struct.pack(\"!I\", single))[0]",
      "ja": "デフdecode_single（シングル）：リターンstruct.unpack（ \"F！の\"、struct.pack（ \"I！\"、シングル））[0]"
    },
    {
      "indent": 3,
      "text": "def decode_half(half): valu = (half & 0x7fff) << 13 | (half & 0x8000) << 16 if ((half & 0x7c00) != 0x7c00): return ldexp(decode_single(valu), 112) return decode_single(valu | 0x7f800000)",
      "ja": "デフdecode_half（ハーフ）：VALU =（ハーフ＆0x7FFFから）<< 13 | （！（ハーフ＆0x7c00）= 0x7c00）（ハーフ＆0x8000の）<< 16の場合：戻りldexp（decode_single（VALU）、112）、リターンdecode_single（VALU | 0x7f800000）"
    },
    {
      "indent": 12,
      "text": "Figure 4: Python Code for a Half-Precision Decoder",
      "ja": "図4：半精度デコーダ用のPythonコード"
    },
    {
      "indent": 0,
      "text": "Appendix E. Comparison of Other Binary Formats to CBOR's Design Objectives",
      "ja": "その他のバイナリ形式の付録E.比較CBORの設計目標に"
    },
    {
      "indent": 3,
      "text": "The proposal for CBOR follows a history of binary formats that is as long as the history of computers themselves. Different formats have had different objectives. In most cases, the objectives of the format were never stated, although they can sometimes be implied by the context where the format was first used. Some formats were meant to be universally usable, although history has proven that no binary format meets the needs of all protocols and applications.",
      "ja": "CBORのための提案は、コンピュータそのものの歴史と同じくらいの長さであるバイナリ形式の歴史をたどります。異なるフォーマットは異なる目的を持っていました。彼らは時々フォーマットが最初に使用された文脈によって暗示することができますが、ほとんどの場合、フォーマットの目的は、明記されませんでした。歴史は何バイナリフォーマットは、すべてのプロトコルやアプリケーションのニーズを満たしていないことを証明しているものの、一部の形式は、普遍的に使用可能であることを意味しました。"
    },
    {
      "indent": 3,
      "text": "CBOR differs from many of these formats due to it starting with a set of objectives and attempting to meet just those. This section compares a few of the dozens of formats with CBOR's objectives in order to help the reader decide if they want to use CBOR or a different format for a particular protocol or application.",
      "ja": "CBORは、それが目標のセットから始まり、ちょうどそれらを満たすためにしようとするため、これらのフォーマットの多くとは異なります。このセクションでは、彼らがCBORまたは特定のプロトコルやアプリケーションのための別のフォーマットを使用したい場合は、読者が決定するのを助けるためにCBORの目的とフォーマットの数十の数を比較します。"
    },
    {
      "indent": 3,
      "text": "Note that the discussion here is not meant to be a criticism of any format: to the best of our knowledge, no format before CBOR was meant to cover CBOR's objectives in the priority we have assigned them. A brief recap of the objectives from Section 1.1 is:",
      "ja": "ここでの議論は、任意の形式の批判であることを意味するものではないことに注意してください：我々の知る限りでは、CBOR前にはフォーマットが、我々はそれらを割り当てた優先順位にCBORの目的をカバーすることを意図しませんでした。セクション1.1から目的の簡単な要約は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "1. unambiguous encoding of most common data formats from Internet standards",
      "ja": "インターネット標準からの最も一般的なデータ形式の1明確なエンコーディング"
    },
    {
      "indent": 3,
      "text": "2. code compactness for encoder or decoder",
      "section_title": true,
      "ja": "エンコーダまたはデコーダ2.コードコンパクト"
    },
    {
      "indent": 3,
      "text": "3. no schema description needed",
      "section_title": true,
      "ja": "3.何スキーマの記述は必要ありません"
    },
    {
      "indent": 3,
      "text": "4. reasonably compact serialization",
      "section_title": true,
      "ja": "4.合理的にコンパクトな直列化"
    },
    {
      "indent": 3,
      "text": "5. applicability to constrained and unconstrained applications",
      "section_title": true,
      "ja": "制約と制約のないアプリケーションへの適用5."
    },
    {
      "indent": 3,
      "text": "6. good JSON conversion",
      "section_title": true,
      "ja": "6.良いJSON変換"
    },
    {
      "indent": 3,
      "text": "7. extensibility",
      "section_title": true,
      "ja": "7.拡張性"
    },
    {
      "indent": 0,
      "text": "E.1. ASN.1 DER, BER, and PER",
      "ja": "E.1。 ASN.1、BER、およびPER OF"
    },
    {
      "indent": 3,
      "text": "[ASN.1] has many serializations. In the IETF, DER and BER are the most common. The serialized output is not particularly compact for many items, and the code needed to decode numeric items can be complex on a constrained device.",
      "ja": "[ASN.1]は、多くのシリアル化されています。 IETFでは、DERとBERが最も一般的です。シリアル化された出力は、多くの項目のための特にコンパクトではなく、数値アイテムを復号するために必要なコードは、制約のあるデバイス上で複雑であることができます。"
    },
    {
      "indent": 3,
      "text": "Few (if any) IETF protocols have adopted one of the several variants of Packed Encoding Rules (PER). There could be many reasons for this, but one that is commonly stated is that PER makes use of the schema even for parsing the surface structure of the data stream, requiring significant tool support. There are different versions of the ASN.1 schema language in use, which has also hampered adoption.",
      "ja": "いくつかのIETFプロトコル圧縮符号化規則（PER）のいくつかの亜種のいずれかを採用している（もしあれば）。そここれには多くの理由であってもよいが、一般的に記載されている1は、PERでも重要なツールのサポートを必要とする、データ・ストリームの表面構造を解析するためのスキーマを使用することである可能性があります。また、採用を妨げている、使用中のASN.1スキーマ言語の異なるバージョンがあります。"
    },
    {
      "indent": 0,
      "text": "E.2. MessagePack",
      "ja": "E.2。 MessagePack"
    },
    {
      "indent": 3,
      "text": "[MessagePack] is a concise, widely implemented counted binary serialization format, similar in many properties to CBOR, although somewhat less regular. While the data model can be used to represent JSON data, MessagePack has also been used in many remote procedure call (RPC) applications and for long-term storage of data.",
      "ja": "幾分正規が[MessagePack】広く実装、簡潔には、CBORに多くの特性に類似したバイナリシリアライゼーションフォーマットをカウントします。データモデルは、JSONデータを表すために使用することができるが、MessagePackはまた、多くのリモートプロシージャコール（RPC）アプリケーションおよびデータの長期保存のために使用されてきました。"
    },
    {
      "indent": 3,
      "text": "MessagePack has been essentially stable since it was first published around 2011; it has not yet had a transition. The evolution of MessagePack is impeded by an imperative to maintain complete backwards compatibility with existing stored data, while only few bytecodes are still available for extension. Repeated requests over the years from the MessagePack user community to separate out binary and text strings in the encoding recently have led to an extension proposal that would leave MessagePack's \"raw\" data ambiguous between its usages for binary and text data. The extension mechanism for MessagePack remains unclear.",
      "ja": "それは最初に2011年の周りに出版されたので、MessagePackは基本的に安定しています。それはまだ移行を持っていません。ほんの数バイトコードはまだ拡張のために用意されていながら、MessagePackの進化は、既存の保存されたデータとの完全な下位互換性を維持するために不可欠で妨げられます。エンコーディングのバイナリとテキスト文字列を分離するためにMessagePackのユーザーコミュニティからの年間の再三の要求は最近、バイナリとテキストデータのためのその使用法の間の曖昧なMessagePackの「生」のデータを残して拡張提案につながっています。 MessagePackのための拡張メカニズムは不明なままです。"
    },
    {
      "indent": 0,
      "text": "E.3. BSON",
      "ja": "E.3。 BSON"
    },
    {
      "indent": 3,
      "text": "[BSON] is a data format that was developed for the storage of JSON-like maps (JSON objects) in the MongoDB database. Its major distinguishing feature is the capability for in-place update, foregoing a compact representation. BSON uses a counted representation except for map keys, which are null-byte terminated. While BSON can be used for the representation of JSON-like objects on the wire, its specification is dominated by the requirements of the database application and has become somewhat baroque. The status of how BSON extensions will be implemented remains unclear.",
      "ja": "[BSON]のMongoDBデータベースにJSON状のマップ（JSONオブジェクト）を格納するために開発されたデータフォーマットです。その主な特徴はコンパクトな表現を前述の、インプレース更新のための能力です。 BSONはNULLバイトが終了しているマップのキー以外のカウント表現を使用しています。 BSONは、ワイヤ上のJSONのようなオブジェクトの表現のために使用することができるが、その仕様は、データベース・アプリケーションの要件によって支配され、幾分バロックとなっています。 BSON拡張が実装されるかの状態が不明なままです。"
    },
    {
      "indent": 0,
      "text": "E.4. UBJSON",
      "ja": "E.4。 UBJSON"
    },
    {
      "indent": 3,
      "text": "[UBJSON] has a design goal to make JSON faster and somewhat smaller, using a binary format that is limited to exactly the data model JSON uses. Thus, there is expressly no intention to support, for example, binary data; however, there is a \"high-precision number\", expressed as a character string in JSON syntax. UBJSON is not optimized for code compactness, and its type byte coding is optimized for human recognition and not for compact representation of native types such as small integers. Although UBJSON is mostly counted, it provides a reserved \"unknown-length\" value to support streaming of arrays and maps (JSON objects). Within these containers, UBJSON also has a \"Noop\" type for padding.",
      "ja": "【UBJSON] JSONが使用する正確データ・モデルに制限されているバイナリ形式を使用して、より速く、幾分小さいJSONを作成するための設計目標を有しています。したがって、例えば、バイナリデータのサポートする意図は、明示が​​ありません。しかし、「高精度の数」がある、JSONの構文の文字列で表されます。 UBJSONは、コード小型化のために最適化されておらず、その型バイトコードは、小さな整数としてネイティブ型のコンパクトな表現のために人間の認識のために最適化されていません。 UBJSONはほとんどカウントされているが、それはアレイとマップ（JSONオブジェクト）のストリーミングをサポートするために予約された「未知の長さ」の値を提供します。これらのコンテナの中で、UBJSONもパディングのための「NOOP」タイプがあります。"
    },
    {
      "indent": 1,
      "text": "E.5. MSDTP:",
      "ja": "E.5。 MSDTP："
    },
    {
      "indent": 3,
      "text": "Message Services Data Transmission (MSDTP) is a very early example of a compact message format; it is described in [RFC0713], written in 1976. It is included here for its historical value, not because it was ever widely used.",
      "ja": "メッセージサービスデータ伝送（MSDTP）は、コンパクトなメッセージフォーマットの非常に初期の例です。それはそれはそれは、これまで広く使用されたではないので、その歴史的価値のためにここに含まれている1976年に書かれた、[RFC0713]に記述されています。"
    },
    {
      "indent": 0,
      "text": "E.6. Conciseness on the Wire",
      "ja": "E.6。ワイヤー上の簡潔さ"
    },
    {
      "indent": 3,
      "text": "While CBOR's design objective of code compactness for encoders and decoders is a higher priority than its objective of conciseness on the wire, many people focus on the wire size. Table 6 shows some encoding examples for the simple nested array [1, [2, 3]]; where some form of indefinite-length encoding is supported by the encoding, [_ 1, [2, 3]] (indefinite length on the outer array) is also shown.",
      "ja": "エンコーダとデコーダのコード小型のCBORの設計目標は、ワイヤ上の簡潔さ、その目的よりも高い優先順位ですが、多くの人々は、電線サイズに焦点を当てます。表6は、[3]、2 [1]単純なネストされた配列のためのいくつかの符号化の例を示す図です。ここで、不定長エンコーディングの何らかの形符号化によってサポートされている、[_ 1、[2,3]（外側のアレイ上の不定長さ）も示されています。"
    },
    {
      "indent": 3,
      "text": "+---------------+-------------------------+-------------------------+\n| Format        | [1, [2, 3]]             | [_ 1, [2, 3]]           |\n+---------------+-------------------------+-------------------------+\n| RFC 713       | c2 05 81 c2 02 82 83    |                         |\n|               |                         |                         |\n| ASN.1 BER     | 30 0b 02 01 01 30 06 02 | 30 80 02 01 01 30 06 02 |\n|               | 01 02 02 01 03          | 01 02 02 01 03 00 00    |\n|               |                         |                         |\n| MessagePack   | 92 01 92 02 03          |                         |\n|               |                         |                         |\n| BSON          | 22 00 00 00 10 30 00 01 |                         |\n|               | 00 00 00 04 31 00 13 00 |                         |\n|               | 00 00 10 30 00 02 00 00 |                         |\n|               | 00 10 31 00 03 00 00 00 |                         |\n|               | 00 00                   |                         |\n|               |                         |                         |\n| UBJSON        | 61 02 42 01 61 02 42 02 | 61 ff 42 01 61 02 42 02 |\n|               | 42 03                   | 42 03 45                |\n|               |                         |                         |\n| CBOR          | 82 01 82 02 03          | 9f 01 82 02 03 ff       |\n+---------------+-------------------------+-------------------------+",
      "raw": true
    },
    {
      "indent": 11,
      "text": "Table 6: Examples for Different Levels of Conciseness",
      "ja": "表6：意識の異なるレベルの例"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Carsten Bormann Universitaet Bremen TZI Postfach 330440 D-28359 Bremen Germany",
      "ja": "カルステンボルマンUniversitaetブレーメンTZI POSTFACH 330440 D-28359ブレーメン、ドイツ"
    },
    {
      "indent": 3,
      "text": "Phone: +49-421-218-63921 EMail: cabo@tzi.org",
      "ja": "電話：+ 49-421-218-63921 Eメール：cabo@tzi.org"
    },
    {
      "indent": 3,
      "text": "Paul Hoffman VPN Consortium",
      "ja": "ポール・ホフマンVPNコンソーシアム"
    },
    {
      "indent": 3,
      "text": "EMail: paul.hoffman@vpnc.org",
      "ja": "メールアドレス：paul.hoffman@vpnc.org"
    }
  ]
}