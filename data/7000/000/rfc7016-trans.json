{
  "title": {
    "text": "RFC 7016 - Adobe's Secure Real-Time Media Flow Protocol",
    "ja": "RFC 7016 - Adobeのセキュアリアルタイムメディアフロープロトコル"
  },
  "number": 7016,
  "created_at": "2019-10-27 15:28:38.647064+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                     M. Thornburgh\nRequest for Comments: 7016                                         Adobe\nCategory: Informational                                    November 2013\nISSN: 2070-1721",
      "raw": true
    },
    {
      "indent": 14,
      "text": "Adobe's Secure Real-Time Media Flow Protocol",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This memo describes Adobe's Secure Real-Time Media Flow Protocol (RTMFP), an endpoint-to-endpoint communication protocol designed to securely transport parallel flows of real-time video, audio, and data messages, as well as bulk data, over IP networks. RTMFP has features that make it effective for peer-to-peer (P2P) as well as client-server communications, even when Network Address Translators (NATs) are used.",
      "ja": "このメモは、Adobe社のセキュアリアルタイムメディアフロープロトコル（RTMFP）、セキュアIPネットワーク上で、リアルタイムのビデオ、オーディオ、およびデータメッセージのパラレルフローだけでなく、大量のデータを転送するために設計されたエンドポイント間の通信プロトコルを記述します。 RTMFPは、ネットワークが翻訳器（NAT）のアドレスであっても、それが効果的なピア・ツー・ピア（P2P）のために作るの機能だけでなく、クライアント - サーバ間の通信は、使用されています。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "ja": "このドキュメントはインターネット標準化過程仕様ではありません。それは、情報提供の目的のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are a candidate for any level of Internet Standard; see Section 2 of RFC 5741.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。 IESGによって承認されていないすべての文書がインターネットStandardのどんなレベルの候補です。 RFC 5741のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7016.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7016で取得することができます。"
    },
    {
      "indent": 0,
      "text": "IESG Note",
      "ja": "IESG注意"
    },
    {
      "indent": 3,
      "text": "This document represents technology developed outside the processes of the IETF and the IETF community has determined that it is useful to publish it as an RFC in its current form. It is a product of the IETF only in that it has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG), but the content of the document does not represent a consensus of the IETF.",
      "ja": "この文書は、IETFの過程外で開発された技術を表し、IETFコミュニティは、現在の形でのRFCとして公開するために有用であると判断しました。それは公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されているだけという点で、IETFの製品ですが、ドキュメントの内容は、IETFのコンセンサスを表すものではありません。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2013 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2013 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 3,
      "text": "This document may not be modified, and derivative works of it may not be created, except to format it for publication as an RFC or to translate it into languages other than English.",
      "ja": "RFCとして公表のためにそれをフォーマットしたり、英語以外の言語に翻訳することを除いて、このドキュメントは変更されないことがあり、それの派生作品が作成されないことがあります。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................5\n   1.1. Design Highlights of RTMFP .................................6\n   1.2. Terminology ................................................7\n2. Syntax ..........................................................8\n   2.1. Common Elements ............................................8\n        2.1.1. Elementary Types and Constructs .....................8\n        2.1.2. Variable Length Unsigned Integer (VLU) .............10\n        2.1.3. Option .............................................10\n        2.1.4. Option List ........................................11\n        2.1.5. Internet Socket Address (Address) ..................12\n   2.2. Network Layer .............................................13\n        2.2.1. Encapsulation ......................................13\n        2.2.2. Multiplex ..........................................13\n        2.2.3. Encryption .........................................14\n        2.2.4. Packet .............................................15\n   2.3. Chunks ....................................................18\n        2.3.1. Packet Fragment Chunk ..............................20\n        2.3.2. Initiator Hello Chunk (IHello) .....................21\n        2.3.3. Forwarded Initiator Hello Chunk (FIHello) ..........22\n        2.3.4. Responder Hello Chunk (RHello) .....................23\n        2.3.5. Responder Redirect Chunk (Redirect) ................24\n        2.3.6. RHello Cookie Change Chunk .........................26\n        2.3.7. Initiator Initial Keying Chunk (IIKeying) ..........27\n        2.3.8. Responder Initial Keying Chunk (RIKeying) ..........29\n        2.3.9. Ping Chunk .........................................31\n        2.3.10. Ping Reply Chunk ..................................32",
      "raw": true
    },
    {
      "indent": 3,
      "text": "        2.3.11. User Data Chunk ...................................33\n               2.3.11.1. Options for User Data ....................35\n                        2.3.11.1.1. User's Per-Flow Metadata ......35\n                        2.3.11.1.2. Return Flow Association .......36\n        2.3.12. Next User Data Chunk ..............................37\n        2.3.13. Data Acknowledgement Bitmap Chunk (Bitmap Ack) ....39\n        2.3.14. Data Acknowledgement Ranges Chunk (Range Ack) .....41\n        2.3.15. Buffer Probe Chunk ................................43\n        2.3.16. Flow Exception Report Chunk .......................43\n        2.3.17. Session Close Request Chunk (Close) ...............44\n        2.3.18. Session Close Acknowledgement Chunk (Close Ack) ...44\n3. Operation ......................................................45\n   3.1. Overview ..................................................45\n   3.2. Endpoint Identity .........................................46\n   3.3. Packet Multiplex ..........................................48\n   3.4. Packet Fragmentation ......................................48\n   3.5. Sessions ..................................................50\n        3.5.1. Startup ............................................53\n               3.5.1.1. Normal Handshake ..........................53\n                        3.5.1.1.1. Initiator ......................54\n                        3.5.1.1.2. Responder ......................55\n               3.5.1.2. Cookie Change .............................57\n               3.5.1.3. Glare .....................................59\n               3.5.1.4. Redirector ................................60\n               3.5.1.5. Forwarder .................................61\n               3.5.1.6. Redirector and Forwarder with NAT .........63\n               3.5.1.7. Load Distribution and Fault Tolerance .....66\n        3.5.2. Congestion Control .................................67\n               3.5.2.1. Time Critical Reverse Notification ........68\n               3.5.2.2. Retransmission Timeout ....................68\n               3.5.2.3. Burst Avoidance ...........................71\n        3.5.3. Address Mobility ...................................71\n        3.5.4. Ping ...............................................72\n               3.5.4.1. Keepalive .................................72\n               3.5.4.2. Address Mobility ..........................73\n               3.5.4.3. Path MTU Discovery ........................74\n        3.5.5. Close ..............................................74\n   3.6. Flows .....................................................75\n        3.6.1. Overview ...........................................75\n               3.6.1.1. Identity ..................................75\n               3.6.1.2. Messages and Sequencing ...................76\n               3.6.1.3. Lifetime ..................................77",
      "raw": true
    },
    {
      "indent": 3,
      "text": "        3.6.2. Sender .............................................78\n               3.6.2.1. Startup ...................................80\n               3.6.2.2. Queuing Data ..............................80\n               3.6.2.3. Sending Data ..............................81\n                        3.6.2.3.1. Startup Options ................83\n                        3.6.2.3.2. Send Next Data .................83\n               3.6.2.4. Processing Acknowledgements ...............83\n               3.6.2.5. Negative Acknowledgement and Loss .........84\n               3.6.2.6. Timeout ...................................85\n               3.6.2.7. Abandoning Data ...........................86\n                        3.6.2.7.1. Forward Sequence Number\n                                   Update .........................86\n               3.6.2.8. Examples ..................................87\n               3.6.2.9. Flow Control ..............................89\n                        3.6.2.9.1. Buffer Probe ...................89\n               3.6.2.10. Exception ................................89\n               3.6.2.11. Close ....................................90\n        3.6.3. Receiver ...........................................90\n               3.6.3.1. Startup ...................................93\n               3.6.3.2. Receiving Data ............................94\n               3.6.3.3. Buffering and Delivering Data .............95\n               3.6.3.4. Acknowledging Data ........................97\n                        3.6.3.4.1. Timing .........................98\n                        3.6.3.4.2. Size and Truncation ............99\n                        3.6.3.4.3. Constructing ...................99\n                        3.6.3.4.4. Delayed Acknowledgement .......100\n                        3.6.3.4.5. Obligatory Acknowledgement ....100\n                        3.6.3.4.6. Opportunistic\n                                   Acknowledgement ...............100\n                        3.6.3.4.7. Example .......................101\n               3.6.3.5. Flow Control .............................102\n               3.6.3.6. Receiving a Buffer Probe .................103\n               3.6.3.7. Rejecting a Flow .........................103\n               3.6.3.8. Close ....................................104\n4. IANA Considerations ...........................................104\n5. Security Considerations .......................................105\n6. Acknowledgements ..............................................106\n7. References ....................................................107\n   7.1. Normative References .....................................107\n   7.2. Informative References ...................................107\nAppendix A. Example Congestion Control Algorithm .................108\n  A.1. Discussion ................................................108\n  A.2. Algorithm .................................................110",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "Adobe's Secure Real-Time Media Flow Protocol (RTMFP) is intended for use as a general purpose endpoint-to-endpoint data transport service in IP networks. It has features that make it well suited to the transport of real-time media (such as low-delay video, audio, and data) as well as bulk data, and for client-server as well as peer-to-peer (P2P) communication. These features include independent parallel message flows that may have different delivery priorities, variable message reliability (from TCP-like full reliability to UDP-like best effort), multi-point congestion control, and built-in security. Session multiplexing and facilities to support UDP hole-punching simplify Network Address Translator (NAT) traversal in peer-to-peer systems.",
      "ja": "Adobeのセキュアリアルタイムメディアフロープロトコル（RTMFP）は、IPネットワークにおける汎用エンドポイント間のデータ転送サービスとして使用するためのものです。これは、リアルタイムメディアの輸送にそれが適しせる機能を備えています（このような低遅延ビデオ、オーディオ、およびデータなど）だけでなく、大量のデータ、およびクライアント・サーバー用としてだけでなく、ピア・ツー・ピア（P2P ） コミュニケーション。これらの特徴は、独立パラレル（UDPのようなベストエフォートにTCPのような完全な信頼性の）異なる配信優先度、可変メッセージの信頼性を有することができるメッセージ・フロー、マルチポイント輻輳制御、およびセキュリティ内蔵を含みます。セッションの多重化やピア・ツー・ピアシステムにおけるネットワークアドレス変換（NAT）トラバーサルを簡略化するUDPホールパンチングをサポートするための施設。"
    },
    {
      "indent": 3,
      "text": "RTMFP is implemented in Flash Player, Adobe Integrated Runtime (AIR), and Adobe Media Server (AMS, formerly Flash Media Server or FMS), all from Adobe Systems Incorporated, and is used as the foundation transport protocol for real-time video, audio, and data communication, both client-server and P2P, in those products. At the time of writing, the Adobe Flash Player runtime is installed on more than one billion end-user desktop computers.",
      "ja": "RTMFPは、すべてのAdobe Systems Incorporated（アドビシステムズ社）から、Flash Playerが、アドビの統合ランタイム（AIR）、およびAdobeメディアサーバー（AMS、以前のFlash Media ServerまたはFMS）で実装されており、リアルタイムのビデオ、オーディオのための基盤トランスポートプロトコルとして使用されています、データ通信、これらの製品の両方のクライアント・サーバーやP2P、と。執筆時点では、Adobe Flash Playerのランタイムは、以上の10億エンドユーザーのデスクトップコンピュータにインストールされています。"
    },
    {
      "indent": 3,
      "text": "RTMFP was developed by Adobe Systems Incorporated and is not the product of an IETF activity.",
      "ja": "RTMFPは、Adobe Systems Incorporated（アドビシステムズ社）によって開発され、IETF活動の製品ではありませんました。"
    },
    {
      "indent": 3,
      "text": "This memo describes the syntax and operation of the Secure Real-Time Media Flow Protocol.",
      "ja": "このメモは、セキュアリアルタイムメディアフロープロトコルの構文と動作について説明しています。"
    },
    {
      "indent": 3,
      "text": "This memo describes a general security framework that, when combined with an application-specific Cryptography Profile, can be used to establish a confidential and authenticated session between endpoints. The application-specific Cryptography Profile, not defined herein, would detail the specific cryptographic algorithms, data formats, and semantics to be used within this framework. Interoperation between applications of RTMFP requires common or compatible Cryptography Profiles.",
      "ja": "このメモは、アプリケーション固有の暗号プロファイルと組み合わせた場合、エンドポイント間の機密と認証されたセッションを確立するために使用することができる一般的なセキュリティフレームワークを記述する。アプリケーション固有の暗号プロファイルは、本明細書で定義されていないが、詳細特定の暗号化アルゴリズム、データフォーマット、及び意味論は、このフレームワーク内で使用されるであろう。 RTMFPのアプリケーション間の相互運用は、共通または互換性のある暗号化プロファイルが必要です。"
    },
    {
      "indent": 3,
      "text": "Note to implementers: at the time of writing, the Cryptography Profile used by the above-mentioned Adobe products is not publicly described by Adobe. Implementers should investigate the availability of documentation of that Cryptography Profile prior to implementing RTMFP for the purpose of interoperation with the above-mentioned Adobe products.",
      "ja": "実装者への注意：執筆時点では、上記のアドビ製品で使用される暗号化のプロフィールは、公的アドビによって記述されていません。実装者は、上記のアドビ製品との相互運用のために、RTMFPを実装する前に、その暗号プロファイルのドキュメントの利用可能性を調査する必要があります。"
    },
    {
      "indent": 0,
      "text": "1.1. Design Highlights of RTMFP",
      "section_title": true,
      "ja": "1.1。 RTMFPのデザインのハイライト"
    },
    {
      "indent": 3,
      "text": "Between any pair of communicating endpoints is a single, bidirectional, secured, congestion controlled session. Unidirectional flows convey messages from one end to the other within the session. An endpoint can have concurrent sessions with multiple other far endpoints.",
      "ja": "通信エンドポイントの任意のペア間の単一の、双方向、固定、輻輳制御セッションです。単方向フローは、セッション内の他の端から端までのメッセージを伝えます。エンドポイントは、他の複数の遠くのエンドポイントとの同時セッションを持つことができます。"
    },
    {
      "indent": 3,
      "text": "Design highlights of RTMFP include the following:",
      "ja": "RTMFPのデザインのハイライトは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o The security framework is an inherent part of the basic protocol. The application designer chooses the cryptographic formats and algorithms to suit the needs of the application, and may update them as the state of the security arts progresses.",
      "ja": "Oセキュリティフレームワークは、基本的なプロトコルの固有の部分です。アプリケーション設計者は、アプリケーションのニーズに合わせて、暗号形式とアルゴリズムを選択し、セキュリティ芸術の状態が進むにつれて、それらを更新することができます。"
    },
    {
      "indent": 3,
      "text": "o Cryptographic Endpoint Discriminators can resist port scanning.",
      "ja": "O暗号化エンドポイントディスクリミネータは、ポートスキャンを抵抗することができます。"
    },
    {
      "indent": 3,
      "text": "o All header, control, and framing information, except for network addressing information and a session identifier, is encrypted according to the Cryptography Profile.",
      "ja": "Oネットワークアドレス情報及びセッション識別子を除くすべてのヘッダー、制御、及びフレーミング情報は、暗号化プロファイルに従って暗号化されます。"
    },
    {
      "indent": 3,
      "text": "o There is a single session and associated congestion control state between a pair of endpoints.",
      "ja": "Oエンドポイントのペア間の単一のセッションと関連した輻輳制御状態です。"
    },
    {
      "indent": 3,
      "text": "o Each session may have zero or more unidirectional message-oriented flows in each direction. All of a session's sending flows share the session's congestion control state.",
      "ja": "Oの各セッションは、各方向におけるゼロ以上の一方向メッセージ指向の流れを有することができます。セッションの送信フローのすべてのセッションの輻輳制御状態を共有しています。"
    },
    {
      "indent": 3,
      "text": "o Return Flow Association (Section 2.3.11.1.2) generalizes bidirectional communication to arbitrarily complex trees of flows.",
      "ja": "Oリターンフロー協会（セクション2.3.11.1.2）はフローの任意の複雑な木々に双方向通信を一般化します。"
    },
    {
      "indent": 3,
      "text": "o Messages in flows can be arbitrarily large and are fragmented for transmission.",
      "ja": "Oフロー内のメッセージは、任意の大きさであってもよく、送信のために断片化されます。"
    },
    {
      "indent": 3,
      "text": "o Messages of any size may be sent with full, partial, or no reliability (sender's choice). Messages may be delivered to the receiving user in original queuing order or network arrival order (receiver's choice).",
      "ja": "O任意のサイズのメッセージは、完全、部分、または全く信頼性（送信者の選択肢）を用いて送信することができます。メッセージは、元の待ち行列の順序またはネットワーク到着順序（受信機の選択）に受信ユーザに送達することができます。"
    },
    {
      "indent": 3,
      "text": "o Flows are named with arbitrary, user-defined metadata (Section 2.3.11.1.1) rather than port or stream numbers.",
      "ja": "Oフローは、任意のユーザ定義メタデータ（セクション2.3.11.1.1）よりもむしろポートまたはストリーム番号で命名されています。"
    },
    {
      "indent": 3,
      "text": "o The sequence numbers of each flow are independent of all other flows and are not permanently bound to a session-wide transmission ordering. This allows real-time priority decisions to be made at transmission or retransmission time.",
      "ja": "oを各フローのシーケンス番号は、他のすべてのフローの独立しており、恒久的にセッション全体の伝送順序にバインドされていません。これは、リアルタイムの優先順位の決定は、送信または再送信時に行うことを可能にします。"
    },
    {
      "indent": 3,
      "text": "o Each flow has its own receive window and, therefore, independent flow control.",
      "ja": "O各フローは、独自の、窓を受け、したがって、独立したフロー制御を持っています。"
    },
    {
      "indent": 3,
      "text": "o Round trips are expensive and are minimized or eliminated when possible.",
      "ja": "O往復は高価であり、可能な場合は、最小化または排除されています。"
    },
    {
      "indent": 3,
      "text": "o After a session is established, flows begin by sending the flow's messages with no additional handshake (and associated round trips).",
      "ja": "セッションが確立された後、O、追加のハンドシェイク（および関連する往復）と流れのメッセージを送信することから始めて流れ。"
    },
    {
      "indent": 3,
      "text": "o Transmitting bytes on the network is much more expensive than moving bytes in a CPU or memory. Wasted bytes are minimized or eliminated when possible and practical, and variable length encodings are used, even at the expense of breaking 32-bit alignment and making the text diagrams in this specification look awkward.",
      "ja": "ネットワーク上のバイトを送信oをCPUやメモリ内のバイトを移動するよりもはるかに高価です。無駄なバイトがあっても、32ビットの整列を破壊し、本明細書のテキスト図は厄介見せるを犠牲にし、最小化または可能で実用的な、及び可変長符号化が使用されるときに除去されます。"
    },
    {
      "indent": 3,
      "text": "o P2P lookup and peer introduction (including UDP hole-punching for NAT and firewall traversal) are supported directly by the session startup handshake.",
      "ja": "O P2P検索と（NATやファイアウォール越えのためのUDPホールパンチングを含む）ピア導入は、セッション起動ハンドシェイクによって直接サポートされています。"
    },
    {
      "indent": 3,
      "text": "o Session identifiers allow an endpoint to multiplex many sessions over a single local transport address while allowing sessions to survive changes in transport address (as may happen in mobile or wireless deployments).",
      "ja": "（モバイルまたはワイヤレス展開に起こり得るような）トランスポートアドレスの変更を生き残るためにセッションを可能にしながら、Oセッション識別子は、エンドポイントが単一のローカルトランスポートアドレス上で多くのセッションを多重化することができます。"
    },
    {
      "indent": 3,
      "text": "The syntax of the protocol is detailed in Section 2. The operation of the protocol is detailed in Section 3.",
      "ja": "プロトコルの構文は、プロトコルの動作は、第3節に詳述されている第2節に詳述されています。"
    },
    {
      "indent": 0,
      "text": "1.2. Terminology",
      "section_title": true,
      "ja": "1.2。用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "キーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、 \"SHALL\"、 \"SHOULD\"、 \"ないもの\"、 \"推奨\" \"ない（SHOULD NOT）\"、 \"MAY\"、 \"推奨NOT\"、および「OPTIONAL 「本書では[RFC2119]で説明されるように解釈されるべきです。"
    },
    {
      "indent": 0,
      "text": "2. Syntax",
      "section_title": true,
      "ja": "2.構文"
    },
    {
      "indent": 3,
      "text": "Definitions of types and structures in this specification use traditional text diagrams paired with procedural descriptions using a C-like syntax. The C-like procedural descriptions SHALL be construed as definitive.",
      "ja": "本明細書における種類や構造の定義は、Cに似た構文を使用して、手続きの記述とペアになって、伝統的なテキスト・ダイアグラムを使用しています。 C-ような手続き記述は決定的なものと解釈されるものとする（SHALL）。"
    },
    {
      "indent": 3,
      "text": "Structures are packed to take only as many bytes as explicitly indicated. There is no 32-bit alignment constraint, and fields are not padded for alignment unless explicitly indicated or described. Text diagrams may include a bit ruler across the top; this is a convenience for counting bits in individual fields and does not necessarily imply field alignment on a multiple of the ruler width.",
      "ja": "構造はとして明示的に示されているだけのように多くのバイトを取るためにパックされています。そこには、32ビットのアライメント制約はなく、明示又は記載されない限りフィールドは、位置合わせのために埋め込まれていません。テキスト図は、上部にビット定規を含むことができます。これは、個々のフィールド内のビットをカウントするための便宜であり、必ずしも定規幅の複数のフィールドの配置を意味するものではありません。"
    },
    {
      "indent": 3,
      "text": "Unless specified otherwise, reserved fields SHOULD be set to 0 by a sender and MUST be ignored by a receiver.",
      "ja": "特に指定のない限り、予約フィールドは、送信者によって0に設定されるべきであり、受信機で無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The procedural syntax of this specification defines correct and error-free encoded inputs to a parser. The procedural syntax does not describe a fully featured parser, including error detection and handling. Implementations MUST include means to identify error circumstances, including truncations causing elementary or composed types to not fit inside containing structures, fields, or elements. Unless specified otherwise, an error circumstance SHALL abort the parsing and processing of an element and its enclosing elements, up to the containing packet.",
      "ja": "本明細書の手続き構文パーサに正しいとエラーフリー符号化入力を定義します。手続き型構文は、エラー検出および処理を含むフル機能のパーサーを、説明していません。実装は、構造、フィールド、または要素を含む内側適合しないように、基本構成や種類を引き起こす切断などのエラー状況を識別するための手段を含まなければなりません。特に断らない限り、エラー状況を含むパケットまで、要素とその囲み要素の解析および処理を中断します。"
    },
    {
      "indent": 0,
      "text": "2.1. Common Elements",
      "section_title": true,
      "ja": "2.1。共通要素"
    },
    {
      "indent": 3,
      "text": "This section lists types and structures that are used throughout this specification.",
      "ja": "このセクションでは、本明細書を通じて使用されている種類と構造を示しています。"
    },
    {
      "indent": 0,
      "text": "2.1.1. Elementary Types and Constructs",
      "section_title": true,
      "ja": "2.1.1。小学校種類と構築"
    },
    {
      "indent": 3,
      "text": "This section lists the elementary types and constructs out of which all of the following sections' definitions are built.",
      "ja": "このセクションでは、次のセクションの定義のすべてが構築されるのうち基本タイプと構造を示しています。"
    },
    {
      "indent": 3,
      "text": "uint8_t var;",
      "ja": "uint8_tでした。"
    },
    {
      "indent": 6,
      "text": "An unsigned integer 8 bits (one byte) in length and byte aligned.",
      "ja": "長さとバイト位置合わせの符号なし整数8ビット（1バイト）。"
    },
    {
      "indent": 3,
      "text": "uint16_t var;",
      "ja": "uint16_tでした。"
    },
    {
      "indent": 6,
      "text": "An unsigned integer 16 bits in length, in network byte order (\"big endian\") and byte aligned.",
      "ja": "符号なし整数ネットワークバイト順で長さが16ビット（「ビッグエンディアン」）とバイトを整列します。"
    },
    {
      "indent": 3,
      "text": "uint32_t var;",
      "ja": "uint32_tでした。"
    },
    {
      "indent": 6,
      "text": "An unsigned integer 32 bits in length, in network byte order and byte aligned.",
      "ja": "符号なし整数ネットワークバイト順と、バイト整列の長さは32ビット、。"
    },
    {
      "indent": 3,
      "text": "uint128_t var;",
      "ja": "uint128_tでした。"
    },
    {
      "indent": 6,
      "text": "An unsigned integer 128 bits in length, in network byte order and byte aligned.",
      "ja": "符号なし整数ネットワークバイト順とバイト位置合わせされ、長さ128ビット、。"
    },
    {
      "indent": 3,
      "text": "uintn_t var :bitsize;",
      "ja": "そこuint_t：bitesizeを。"
    },
    {
      "indent": 6,
      "text": "An unsigned integer of any other size, potentially not byte aligned. Its size in bits is specified explicitly by bitsize.",
      "ja": "他のサイズの符号なし整数、潜在的にバイトにアライメントが合っていません。ビットでそのサイズはビットサイズによって明示的に指定されています。"
    },
    {
      "indent": 3,
      "text": "bool_t var :1;",
      "ja": "bool_tは以下の通りであった：1。"
    },
    {
      "indent": 6,
      "text": "A boolean flag having the value true (1 or set) or false (0 or clear) and being one bit in length.",
      "ja": "ブール・フラグ（1またはセット）または偽（0またはクリア）真の値を有し、長さが1ビットです。"
    },
    {
      "indent": 3,
      "text": "type var[num];",
      "ja": "タイプは、[NUM]でした。"
    },
    {
      "indent": 6,
      "text": "A packed array of type with length num*sizeof(type)*8 bits.",
      "ja": "長num個の*のはsizeof（タイプ）* 8ビットのタイプのパックされたアレイ。"
    },
    {
      "indent": 3,
      "text": "struct name_t { ... } name :bitsize;",
      "ja": "構造体のtime_t {...}名前：bitesize。"
    },
    {
      "indent": 6,
      "text": "A packed structure. Its size in bits is specified by bitsize.",
      "ja": "充填構造。ビットでそのサイズはbitesizeによって指定されます。"
    },
    {
      "indent": 3,
      "text": "remainder();",
      "ja": "残りの（）。"
    },
    {
      "indent": 6,
      "text": "The number of bytes from the current offset to the end of the enclosing structure.",
      "ja": "囲い構造の端部にオフセット電流からのバイトの数。"
    },
    {
      "indent": 3,
      "text": "type var[remainder()];",
      "ja": "タイプした余り（）]。"
    },
    {
      "indent": 6,
      "text": "A packed array of type, its size extending to the end of the enclosing structure.",
      "ja": "タイプのパックされた配列は、その大きさは、封入構造体の端まで延びます。"
    },
    {
      "indent": 3,
      "text": "Note that a bitsize of \"variable\" indicates that the size of the structure is determined by the sizes of its interior components. A bitsize of \"n*8\" indicates that the size of the structure is a whole number of bytes and is byte aligned.",
      "ja": "「可変」のビットサイズは、構造のサイズは、その内部コンポーネントのサイズによって決定されることを示していることに留意されたいです。 「N * 8」のビットサイズは、構造のサイズがバイトの整数であり、バイト整列であることを示しています。"
    },
    {
      "indent": 0,
      "text": "2.1.2. Variable Length Unsigned Integer (VLU)",
      "section_title": true,
      "ja": "2.1.2。可変長符号なし整数（VLU）"
    },
    {
      "indent": 3,
      "text": "A VLU encodes any finite non-negative integer into one or more bytes. For each encoded byte, if the high bit is set, the next byte is also part of the VLU. If the high bit is clear, this is the final byte of the VLU. The remaining bits encode the number, seven bits at a time, from most significant to least significant.",
      "ja": "VLUは、一つ以上のバイトに任意の有限の負でない整数を符号化します。高いビットが設定されている場合、各符号化されたバイトのために、次のバイトはまた、VLUの一部です。高ビットがクリアされている場合、これはVLUの最後のバイトです。残りのビットは最下位の最上位から、一度に数、7ビットを符号化します。"
    },
    {
      "indent": 3,
      "text": " 0 1 2 3 4 5 6 7                 0 1 2 3 4 5 6 7\n+~+~+~+~+~+~+~+~+               +-+-+-+-+-+-+-+-+\n|1|    digit    |...............|0|    digit    |\n+~+~+~+~+~+~+~+~+               +-+-+-+-+-+-+-+-+\n^                               ^\n+--------- zero or more --------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct vlu_t\n{\n    value = 0;\n    do {\n        bool_t  more  :1;\n        uintn_t digit :7;\n        value = (value * 128) + digit;\n    } while(more);\n} :variable*8;",
      "raw": true
    },
    {
      "indent": 30,
      "text": "+-------------/-+\n|             \\ |\n+-------------/-+",
      "raw": true
    },
    {
      "indent": 15,
      "text": "Figure 1: VLU Depiction in Following Diagrams",
      "ja": "図1：以下の図ではVLU描写"
    },
    {
      "indent": 3,
      "text": "Unless stated otherwise in this specification, implementations SHOULD handle VLUs encoding unsigned integers at least 64 bits in length (that is, encoding a maximum value of at least 2^64 - 1).",
      "ja": "本明細書において特に明記しない限り、実装は、（ -  1、少なくとも2 ^ 64の最大値を符号化する、つまり）のVLUが符号なし整数を長さが少なくとも64ビットを符号化処理します。"
    },
    {
      "indent": 0,
      "text": "2.1.3. Option",
      "section_title": true,
      "ja": "2.1.3。オプション"
    },
    {
      "indent": 3,
      "text": "An Option is a Length-Type-Value triplet. Length and Type are encoded in VLU format. Length is the number of bytes of payload following the Length field. The payload comprises the Type and Value fields. Type identifies the kind of option this is. The syntax of the Value field is determined by the type of option.",
      "ja": "オプションは、長さ・タイプ値のトリプレットです。長さとタイプはVLU形式でエンコードされています。長さは、長さフィールド、次のペイロードのバイト数です。ペイロードは型と値フィールドを含みます。タイプは、これはオプションの種類を識別します。値フィールドの構文は、オプションの種類によって決定されます。"
    },
    {
      "indent": 3,
      "text": "An Option can have a length of zero, in which case it has no type and no value and is empty. An empty Option is called a \"Marker\".",
      "ja": "オプションは、それがタイプと値を持たない空である場合には、ゼロの長さを有することができます。空のオプションは、「マーカー」と呼ばれています。"
    },
    {
      "indent": 3,
      "text": "+-------------/-+~~~~~~~~~~~~~/~+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+\n|   length    \\ |    type     \\ |            value              |\n+-------------/-+~~~~~~~~~~~~~/~+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/\n                ^                                               ^\n                +-------- length bytes long (may be 0) ---------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct option_t\n{\n    vlu_t length :variable*8; // \"L\"\n    if(length > 0)\n    {\n        struct {\n            vlu_t   type :variable*8;   // \"T\"\n            uint8_t value[remainder()]; // \"V\"\n        } payload :length*8;\n    }\n} :variable*8;",
      "raw": true
    },
    {
      "indent": 29,
      "text": "+---/---/-------+\n| L \\ T \\   V   |\n+---/---/-------+",
      "raw": true
    },
    {
      "indent": 13,
      "text": "Figure 2: Option Depiction in Following Diagrams",
      "ja": "図2：以下の図ではオプションの描写"
    },
    {
      "indent": 0,
      "text": "2.1.4. Option List",
      "section_title": true,
      "ja": "2.1.4。オプションリスト"
    },
    {
      "indent": 3,
      "text": "An Option List is a sequence of zero or more non-empty Options terminated by a Marker.",
      "ja": "オプションリストは、マーカーで終了し、ゼロ以上の非空のオプションのシーケンスです。"
    },
    {
      "indent": 3,
      "text": "+~~~/~~~/~~~~~~~+               +~~~/~~~/~~~~~~~+-------------/-+\n| L \\ T \\   V   |...............| L \\ T \\   V   |       0     \\ |\n+~~~/~~~/~~~~~~~+               +~~~/~~~/~~~~~~~+-------------/-+\n^                                               ^     Marker\n+------- zero or more non-empty Options --------+ (empty Option)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct optionList_t\n{\n    do\n    {\n        option_t option :variable*8;\n    } while(option.length > 0);\n} :variable*8;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "2.1.5. Internet Socket Address (Address)",
      "section_title": true,
      "ja": "2.1.5。インターネットソケットアドレス（住所）"
    },
    {
      "indent": 3,
      "text": "When communicating an Internet socket address (a combination of a 32-bit IPv4 [RFC0791] or 128-bit IPv6 [RFC2460] address and a 16-bit port number) to another RTMFP, this encoding is used. This encoding additionally allows an address to be tagged with an origin type, which an RTMFP MAY use to modify the use or disposition of the address.",
      "ja": "別のRTMFPにインターネットソケットアドレス（32ビットのIPv4 [RFC0791]または128ビットのIPv6 [RFC2460]アドレスと16ビットのポート番号の組み合わせ）を通信する場合、このエンコーディングが使用されます。この符号化は、さらに、アドレスがRTMFPは、アドレスの使用または処分を変更するために使用するかもしれ原点タイプ、でタグ付けされることを可能にします。"
    },
    {
      "indent": 3,
      "text": "                                                     1\n 0 1 2 3 4 5 6 7                 0 1 2 3 4 5 6 7|8 9 0 1 2 3 4 5\n+-+-+-+-+-+-+-+-+-----/.../-----+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|I|         | O |    Internet   |                               |\n|P|0 0 0 0 0| R |    address    |              port             |\n|6|   rsv   | I |32 or 128 bits |                               |\n+-+-+-+-+-+-+-+-+-----/.../-----+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct address_t\n{\n    bool_t  inet6    :1;     // \"IP6\"\n    uintn_t reserved :5 = 0; // \"rsv\"\n    uintn_t origin   :2;     // \"ORI\"\n    if(inet6)\n        uint128_t ipAddress;\n    else\n        uint32_t ipAddress;\n    uint16_t port;\n} :variable*8;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "inet6: If set, the Internet address is a 128-bit IPv6 address. If clear, the Internet address is a 32-bit IPv4 address.",
      "ja": "INET6：設定されている場合、インターネットアドレスは128ビットのIPv6アドレスです。明確な場合は、インターネット・アドレスは32ビットのIPv4アドレスです。"
    },
    {
      "indent": 3,
      "text": "origin: The origin tag of this address. Possible values are:",
      "ja": "原産地：このアドレスの原点タグ。可能な値は以下のとおりです。"
    },
    {
      "indent": 6,
      "text": "0: Unknown, unspecified, or \"other\"",
      "ja": "0：不明、未指定、または「その他」"
    },
    {
      "indent": 6,
      "text": "1: Address was reported by the origin as a local, directly attached interface address",
      "ja": "1：アドレスは、ローカル、直接接続されたインターフェイスのアドレスとして、原点で報告されました"
    },
    {
      "indent": 6,
      "text": "2: Address was observed to be the source address from which a packet was received (a \"reflexive transport address\" in the terminology of [RFC5389])",
      "ja": "2：アドレスは、パケットが受信された送信元アドレス（[RFC5389]の用語では「再帰トランスポートアドレス」）であることが観察されました"
    },
    {
      "indent": 6,
      "text": "3: Address is a relay, proxy, or introducer (a Redirector and/or Forwarder)",
      "ja": "3：アドレスは、リレー、プロキシ、または導入（リダイレクタおよび/またはフォワーダ）であります"
    },
    {
      "indent": 3,
      "text": "ipAddress: The Internet address, in network byte order.",
      "ja": "ipAddressは：インターネットアドレス、ネットワークバイトオーダーインチ"
    },
    {
      "indent": 3,
      "text": "port: The 16-bit port number, in network byte order.",
      "ja": "ポート：ネットワークバイトオーダーで16ビットのポート番号、。"
    },
    {
      "indent": 0,
      "text": "2.2. Network Layer",
      "section_title": true,
      "ja": "2.2。ネットワーク層"
    },
    {
      "indent": 0,
      "text": "2.2.1. Encapsulation",
      "section_title": true,
      "ja": "2.2.1。カプセル化"
    },
    {
      "indent": 3,
      "text": "RTMFP Multiplex packets are usually carried in UDP [RFC0768] datagrams so that they may transit commonly deployed NATs and firewalls, and so that RTMFP may be implemented on commonly deployed operating systems without special privileges or permissions.",
      "ja": "彼らはトランジットは、一般のNATやファイアウォールを展開することができ、RTMFPは、特別な特権または許可なしに、一般的に展開され、オペレーティング・システム上に実装することができるようにというように、RTMFP多重パケットは、通常はUDPで[RFC0768]データグラムを実施しています。"
    },
    {
      "indent": 3,
      "text": "RTMFP Multiplex packets MAY be carried by any suitable datagram transport or encapsulation where endpoints are addressed by an Internet socket address (that is, an IPv4 or IPv6 address and a 16-bit port number).",
      "ja": "RTMFP多重パケットは、エンドポイントがインターネットソケットアドレス（すなわち、IPv4またはIPv6アドレスと16ビットのポート番号である）によってアドレス指定される任意の適切なデータグラム輸送またはカプセル化によって実施することができます。"
    },
    {
      "indent": 3,
      "text": "The choice of port numbers is not mandated by this specification. Higher protocol layers or the application define the port numbers used.",
      "ja": "ポート番号の選択は、この仕様書で義務付けられていません。より高いプロトコル層またはアプリケーションが使用するポート番号を定義します。"
    },
    {
      "indent": 0,
      "text": "2.2.2. Multiplex",
      "section_title": true,
      "ja": "2.2.2。複数の"
    },
    {
      "indent": 3,
      "text": " 0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                 Scrambled Session ID (SSID)                   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             e             first32[0]                          |\n|- - - - - -  n  - - - - - - - - - - - - - - - - - - - - - - - -|\n|             c             first32[1]                          |\n+- - - - - -  r  - - - - - - - - - - - - - - - - - - - - - - - -+\n|             y                                                 |\n|             pted packet                                       |\n+---------------------------------------------------------------/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct multiplex_t\n{\n    uint32_t scrambledSessionID; // \"SSID\"\n    union {\n        uint32_t first32[2]; // see note\n        uint8_t  encryptedPacket[remainder()];\n    } :(encapsulation.length - 4)*8;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "    // if encryptedPacket is less than 8 bytes long, treat it\n    // as if it were end-padded with 0s for the following:\n    sessionID = scrambledSessionID XOR first32[0] XOR first32[1];\n} :encapsulation.length*8;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The 32-bit Scrambled Session ID is the 32-bit session ID modified by performing a bitwise exclusive-or with the bitwise exclusive-or of the first two 32-bit words of the encrypted packet.",
      "ja": "セッションIDスクランブル32ビットは、排他的または排他的または暗号化されたパケットの最初の2つの32ビット・ワードのビット単位でビット単位を行うことによって改変さ32ビットのセッションIDです。"
    },
    {
      "indent": 3,
      "text": "The session ID is a 32-bit value that the receiver has requested to be used by the sender when sending packets to this receiver (Sections 2.3.7 and 2.3.8). The session ID identifies the session to which this packet belongs and the decryption key to be used to decrypt the encrypted packet.",
      "ja": "セッションIDは、受信機は、この受信機（セクション2.3.7および2.3.8）にパケットを送信するとき、送信者によって使用されることを要求した32ビットの値です。セッションIDは、このパケットが属するセッションと暗号化されたパケットを解読するために使用する復号鍵を特定します。"
    },
    {
      "indent": 3,
      "text": "Note: Session ID 0 (prior to scrambling) denotes the startup pseudo-session and implies the Default Session Key.",
      "ja": "注：セッションID 0（前のスクランブルに）起動擬似セッションを示し、デフォルトのセッションキーを意味します。"
    },
    {
      "indent": 3,
      "text": "Note: If the encrypted packet is less than 8 bytes long, then for the scrambling operation, perform the exclusive-or as though the encrypted packet were end-padded with enough 0-bytes to bring its length to 8.",
      "ja": "暗号化されたパケットが8バイト未満の長さである場合には、スクランブリング動作のために、排他的または暗号化されたパケットかのように実行8にその長さを持って0バイト十分で末端パディングした：注意。"
    },
    {
      "indent": 0,
      "text": "2.2.3. Encryption",
      "section_title": true,
      "ja": "2.2.3。暗号化"
    },
    {
      "indent": 3,
      "text": "RTMFP packets are encrypted according to a Cryptography Profile. This specification doesn't define a Cryptography Profile or mandate a particular choice of cryptography. The application defines the cryptographic syntax and algorithms.",
      "ja": "RTMFPパケットは暗号化プロファイルに応じて暗号化されています。この仕様は、暗号化プロファイルを定義したり、暗号の特定の選択を強制しません。アプリケーションは、暗号化構文とアルゴリズムを定義します。"
    },
    {
      "indent": 3,
      "text": "Packet encryption is RECOMMENDED to be a block cipher operating in Cipher Block Chaining [CBC] or similar mode. Encrypted packets MUST be decipherable without inter-packet dependency, since packets may be lost, duplicated, or reordered in the network.",
      "ja": "パケットの暗号化は、暗号ブロック連鎖[CBC]または類似のモードで動作するブロック暗号であることが推奨されます。パケットは、失われた複製、またはネットワークに並べ替えることができるので、暗号化されたパケットは、パケット間の依存関係なしに解読していなければなりません。"
    },
    {
      "indent": 3,
      "text": "The packet encryption layer is responsible for data integrity and authenticity of packets, for example by means of a checksum or cryptographic message authentication code. To mitigate replay attacks, data integrity SHOULD comprise duplicate packet detection, for example by means of a session-wide packet sequence number. The packet encryption layer SHALL discard a received packet that does not pass integrity or authenticity tests.",
      "ja": "パケットの暗号化層は、チェックサムまたは暗号のメッセージ認証コードを用いて、たとえば、パケットのデータの整合性と信頼性に責任があります。リプレイ攻撃を軽減するために、データの整合性は、セッション全体のパケットシーケンス番号によって例えば、重複パケット検出を、含むべきです。パケットの暗号化層は、整合性や信頼性のテストに合格しない、受信したパケットを破棄すること。"
    },
    {
      "indent": 3,
      "text": "Note that the structures described below are of plain, unencrypted packets. Encrypted packets MUST be decrypted according to the Session Key associated with the Multiplex Session ID before being interpreted according to this specification.",
      "ja": "下記の構造は、プレーン、暗号化されていないパケットであることに注意してください。暗号化されたパケットは、この仕様に従って解釈される前に、多重セッションIDに関連付けられたセッションキーに従って復号化しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The Cryptography Profile defines a well-known Default Session Key that is used at session startup, during which per-session key(s) are negotiated by the two endpoints. A session ID of zero denotes use of the Default Session Key. The Default Session Key is also used with non-zero session IDs during the latter phases of session startup (Sections 2.3.6 and 2.3.8). See Security Considerations (Section 5) for more about the Default Session Key.",
      "ja": "暗号プロファイルごとのセッション鍵（s）は2つのエンドポイントによってネゴシエートされる間のセッションの起動時に使用されるよく知られたデフォルトのセッションキーを定義します。ゼロのセッションIDは、デフォルトのセッションキーを使用することを示しています。デフォルトのセッションキーは、セッションの起動（セクション2.3.6および2.3.8）の後半の段階でゼロ以外のセッションIDが使用されています。デフォルトのセッションキーの詳細のためのセキュリティ上の考慮事項（第5節）を参照してください。"
    },
    {
      "indent": 0,
      "text": "2.2.4. Packet",
      "section_title": true,
      "ja": "2.2.4。パケット"
    },
    {
      "indent": 3,
      "text": "An (unencrypted, plain) RTMFP packet consists of a variable sized common header, zero or more chunks, and padding. Padding can be inserted by the encryption layer of the sender to meet cipher block size constraints and is ignored by the receiver. A sender's encryption layer MAY pad the end of a packet with bytes with value 0xff such that the resulting packet is a natural and appropriate size for the cipher. Alternatively, the Cryptography Profile MAY define its own framing and padding scheme, if needed, such that decrypted packets are compatible with the syntax defined in this section.",
      "ja": "（暗号化されていない、プレーン）RTMFPパケットは可変サイズの共通ヘッダ、ゼロまたはそれ以上のチャンク、およびパディングで構成されています。パディングは暗号ブロックサイズの制約を満たすために、送信者の暗号化層によって挿入することができ、受信側では無視されます。送信者の暗号化層MAYパッド得られたパケットは暗号の天然及び適切なサイズであるような値は0xFFとバイトのパケットの終わり。必要に応じて、あるいは、暗号化プロファイルは、復号化されたパケットは、このセクションで定義された構文と互換性があるように、独自のフレーミングとパディング方式を定義することができます。"
    },
    {
      "indent": 3,
      "text": " 0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+\n|T|T| r |T|T| M |\n|C|C| s |S|S| O |\n| |R| v | |E| D |\n+-+-+-+-+-+-+-+-+\n+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+\n|        if(TS) timestamp       |     if(TSE) timestampEcho     |\n+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+\n|                             Chunk                             |\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/\n                                :\n                                :\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+\n|                             Chunk                             |\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+\n|                            padding                            |\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct packet_t\n{\n    bool_t  timeCritical         :1; // \"TC\"\n    bool_t  timeCriticalReverse  :1; // \"TCR\"\n    uintn_t reserved             :2; // \"rsv\"\n    bool_t  timestampPresent     :1; // \"TS\"\n    bool_t  timestampEchoPresent :1; // \"TSE\"\n    uintn_t mode                 :2; // \"MOD\"\n    if(0 != mode)\n    {\n        if(timestampPresent)\n            uint16_t timestamp;\n        if(timestampEchoPresent)\n            uint16_t timestampEcho;\n        while(remainder() > 2)\n        {\n            uint8_t  chunkType;\n            uint16_t chunkLength;\n            if(remainder() < chunkLength)\n                break;\n            uint8_t  chunkPayload[chunkLength];\n        } // chunks\n        uint8_t padding[remainder()];\n    }\n} :plainPacket.length*8;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "timeCritical: Time Critical Forward Notification. If set, indicates that this packet contains real-time user data.",
      "ja": "timeCritical：タイムクリティカルフォワード通知。設定された場合、このパケットは、リアルタイムのユーザーデータが含まれていることを示しています。"
    },
    {
      "indent": 3,
      "text": "timeCriticalReverse: Time Critical Reverse Notification. If set, indicates that the sender is currently receiving packets on other sessions that have the timeCritical flag set.",
      "ja": "timeCriticalReverse：タイムクリティカルリバース通知。設定した場合、送信者は現在timeCriticalフラグが設定されている他のセッションでパケットを受信して​​いることを示しています。"
    },
    {
      "indent": 3,
      "text": "timestampPresent: If set, indicates that the timestamp field is present. If clear, there is no timestamp field.",
      "ja": "timestampPresentは：設定した場合、タイムスタンプフィールドが存在していることを示しています。明確な場合は、タイムスタンプフィールドはありません。"
    },
    {
      "indent": 3,
      "text": "timestampEchoPresent: If set, indicates that the timestamp echo field is present. If clear, there is no timestamp echo field.",
      "ja": "timestampEchoPresentは：設定した場合、タイムスタンプエコーフィールドが存在することを示しています。明確な場合は、タイムスタンプエコーフィールドがありません。"
    },
    {
      "indent": 3,
      "text": "mode: The mode of this packet. See below for additional discussion of packet modes. Possible values are:",
      "ja": "モード：このパケットのモード。パケットモードの追加の議論については、以下を参照してください。可能な値は以下のとおりです。"
    },
    {
      "indent": 6,
      "text": "0: Forbidden value",
      "ja": "0：禁断の値"
    },
    {
      "indent": 6,
      "text": "1: Initiator Mark",
      "ja": "1：イニシエータマーク"
    },
    {
      "indent": 6,
      "text": "2: Responder Mark",
      "ja": "2：レスポンダマーク"
    },
    {
      "indent": 6,
      "text": "3: Startup",
      "ja": "3：スタートアップ"
    },
    {
      "indent": 3,
      "text": "timestamp: If the timestampPresent flag is set, this field is present and contains the low 16 bits of the sender's 250 Hz clock (4 milliseconds per tick) at transmit time. The sender's clock MAY have its origin at any time in the past.",
      "ja": "タイムスタンプ：timestampPresentフラグが設定されている場合、このフィールドが存在し、送信時に送信者250 Hzのクロックの下位16ビット（目盛り当たり4ミリ秒）を含みます。送信者の時計は、過去の任意の時点でその起源を持っているかもしれません。"
    },
    {
      "indent": 3,
      "text": "timestampEcho: If the timestampEchoPresent flag is set, this field is present and contains the sender's estimate of what the timestamp field of a packet received from the other end would be at the time this packet was transmitted, using the method described in Section 3.5.2.2.",
      "ja": "timestampEcho：timestampEchoPresentフラグが設定されている場合、このフィールドは存在し、もう一方の端から受信したパケットのタイムスタンプフィールドは、セクション3.5.2.2に記載の方法を用いて、このパケットが送信された時点であろうものの送信者の推定値を含んでいます。"
    },
    {
      "indent": 3,
      "text": "chunks: Zero or more chunks follow the header. It is RECOMMENDED that a packet contain at least one chunk.",
      "ja": "チャンク：ゼロ以上のチャンクは、ヘッダに従います。パケットは、少なくとも1つのチャンクが含まれていることが推奨されます。"
    },
    {
      "indent": 3,
      "text": "padding: Zero or more bytes of padding follow the chunks. The following conditions indicate padding:",
      "ja": "パディング：パディングのゼロ以上のバイトチャンクに従ってください。以下の条件は、パディングを示します。"
    },
    {
      "indent": 6,
      "text": "* Fewer than three bytes (the size of a chunk header) remain in the packet.",
      "ja": "* 3バイト（チャンクヘッダの大きさ）よりも少ないパケットに残ります。"
    },
    {
      "indent": 6,
      "text": "* The chunkLength field of what would be the current chunk header indicates that the hypothetical chunk payload wouldn't fit in the remaining bytes of the packet.",
      "ja": "*現在のチャンクヘッダであるもののchunkLengthフィールドは、仮想的なチャンクペイロードは、パケットの残りのバイトに収まらないであろうことを示しています。"
    },
    {
      "indent": 3,
      "text": "Packet mode 0 is not allowed. Packets marked with this mode are invalid and MUST be discarded.",
      "ja": "パケットモード0が許可されていません。このモードでマークされたパケットは無効であり、捨てなければなりません。"
    },
    {
      "indent": 3,
      "text": "The original initiator of a session MUST mark all non-startup packets it sends in that session with packet mode 1 (\"Initiator Mark\"). It SHOULD ignore any packet received in that session with packet mode 1.",
      "ja": "セッションの元のイニシエータは、それがパケットモード1（「イニシエータマーク」）と、そのセッションに送信するすべての非起動パケットをマークしなければなりません。これは、パケットモード1と、そのセッションで受信されたすべてのパケットを無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "The original responder of a session MUST mark all non-startup packets it sends in that session with packet mode 2 (\"Responder Mark\"). It SHOULD ignore any packet received in that session with packet mode 2.",
      "ja": "セッションの元レスポンダは、それがパケットモード2（「レスポンダマーク」）と、そのセッションに送信するすべての非起動パケットをマークしなければなりません。これは、パケットモード2と、そのセッションで受信されたすべてのパケットを無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "Packet mode 3 is for session startup. Session startup chunks are only allowed in packets with this mode.",
      "ja": "パケットモード3は、セッション起動のためです。セッション起動チャンクはこのモードだけを持つパケットで許可されています。"
    },
    {
      "indent": 3,
      "text": "Chunks that are not for session startup are only allowed in packets with modes 1 or 2.",
      "ja": "セッション起動のためではありませんチャンクはモード1または2のパケットに許可されています。"
    },
    {
      "indent": 0,
      "text": "2.3. Chunks",
      "section_title": true,
      "ja": "2.3。チャンク"
    },
    {
      "indent": 3,
      "text": " 0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   chunkType   |          chunkLength          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+\n|        chunkPayload (chunkLength bytes, may be zero)          |\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct chunk_t\n{\n    uint8_t  chunkType;\n    uint16_t chunkLength;\n    uint8_t  chunkPayload[chunkLength];\n} :variable*8;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "chunkType: The chunk type code.",
      "ja": "chunkType：チャンクタイプコード。"
    },
    {
      "indent": 3,
      "text": "chunkLength: The size, in bytes, of the chunk payload.",
      "ja": "chunkLength：チャンクペイロードのバイト単位のサイズ、。"
    },
    {
      "indent": 3,
      "text": "chunkPayload: The type-specific payload of this chunk, chunkLength bytes in length (may be empty).",
      "ja": "chunkPayload：このチャンクの型特異的ペイロード、chunkLengthは（空の場合もある）長さがバイト。"
    },
    {
      "indent": 3,
      "text": "Defined chunk types are enumerated here in the order they might be encountered in the course of a typical session. The following chunk type codes are defined:",
      "ja": "定義のチャンクタイプは、彼らは典型的なセッションの過程で遭遇する可能性があるために、ここに列挙されています。以下のチャンクタイプコードが定義されています。"
    },
    {
      "indent": 3,
      "text": "0x7f: Packet Fragment (Section 2.3.1)",
      "ja": "0x7f：パケットフラグメント（2.3.1項）"
    },
    {
      "indent": 3,
      "text": "0x30: Initiator Hello (Section 2.3.2)",
      "ja": "0x30から：イニシエータこんにちは（2.3​​.2）"
    },
    {
      "indent": 3,
      "text": "0x0f: Forwarded Initiator Hello (Section 2.3.3)",
      "ja": "0x0Fの：転送されたイニシエータこんにちは（2.3​​.3項）"
    },
    {
      "indent": 3,
      "text": "0x70: Responder Hello (Section 2.3.4)",
      "ja": "0x70：レスポンダこんにちは（2.3​​.4項）"
    },
    {
      "indent": 3,
      "text": "0x71: Responder Redirect (Section 2.3.5)",
      "ja": "（0x71）を：レスポンダリダイレクト（2.3.5項）"
    },
    {
      "indent": 3,
      "text": "0x79: RHello Cookie Change (Section 2.3.6)",
      "ja": "0x79：RHelloクッキーの変更（2.3.6項）"
    },
    {
      "indent": 3,
      "text": "0x38: Initiator Initial Keying (Section 2.3.7)",
      "ja": "0x38：イニシエータ初期キーイング（2.3.7項）"
    },
    {
      "indent": 3,
      "text": "0x78: Responder Initial Keying (Section 2.3.8)",
      "ja": "0x78と：初期キーイングレスポンダ（第2.3.8項）"
    },
    {
      "indent": 3,
      "text": "0x01: Ping (Section 2.3.9)",
      "ja": "0x01の：Pingの（セクション2.3.9）"
    },
    {
      "indent": 3,
      "text": "0x41: Ping Reply (Section 2.3.10)",
      "ja": "0×41：ping応答（セクション2.3.10）"
    },
    {
      "indent": 3,
      "text": "0x10: User Data (Section 2.3.11)",
      "ja": "0x10のユーザデータ（セクション2.3.11）"
    },
    {
      "indent": 3,
      "text": "0x11: Next User Data (Section 2.3.12)",
      "ja": "0x11を：次のユーザーデータ（セクション2.3.12）"
    },
    {
      "indent": 3,
      "text": "0x50: Data Acknowledgement Bitmap (Section 2.3.13)",
      "ja": "0x50を：データ確認応答ビットマップ（セクション2.3.13）"
    },
    {
      "indent": 3,
      "text": "0x51: Data Acknowledgement Ranges (Section 2.3.14)",
      "ja": "0x51：データ確認応答（セクション2.3.14）を範囲"
    },
    {
      "indent": 3,
      "text": "0x18: Buffer Probe (Section 2.3.15)",
      "ja": "0x18の：バッファプローブ（セクション2.3.15）"
    },
    {
      "indent": 3,
      "text": "0x5e: Flow Exception Report (Section 2.3.16)",
      "ja": "0x5Eの：フロー例外レポート（セクション2.3.16）"
    },
    {
      "indent": 3,
      "text": "0x0c: Session Close Request (Section 2.3.17)",
      "ja": "0x0Cの：セッションクローズリクエスト（セクション2.3.17）"
    },
    {
      "indent": 3,
      "text": "0x4c: Session Close Acknowledgement (Section 2.3.18)",
      "ja": "0x4c：セッションを閉じる確認応答（セクション2.3.18）"
    },
    {
      "indent": 3,
      "text": "0x00: Ignore/Padding",
      "ja": "$ 00：無視/パディング"
    },
    {
      "indent": 3,
      "text": "0xff: Ignore/Padding",
      "ja": "0xffの：無視/パディング"
    },
    {
      "indent": 3,
      "text": "A receiver MUST ignore a chunk having an unrecognized chunk type code. A receiver MUST ignore a chunk appearing in a packet having a mode inappropriate to that chunk type.",
      "ja": "受信機は、認識されないチャンクタイプコードを有するチャンクを無視しなければなりません。受信機は、チャンクタイプに不適切なモードを有するパケットに現れるチャンクを無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Unless specified otherwise, if a chunk has a syntax or processing error (for example, the chunk's payload field is not long enough to contain the specified syntax elements), the chunk SHALL be ignored as though it was not present in the packet, and parsing and processing SHALL commence with the next chunk in the packet, if any.",
      "ja": "特に指定のない限りチャンクが構文または処理エラーがある場合、（例えば、チャンクのペイロードフィールドは、指定された構文要素を含むのに十分な長さではありません）、チャンクは、それがパケット中に存在していなかったかのように無視され、解析されるものとする（SHALL）もしあれば、処理は、パケット内の次のチャンクを開始しなければなりません。"
    },
    {
      "indent": 0,
      "text": "2.3.1. Packet Fragment Chunk",
      "section_title": true,
      "ja": "2.3.1。パケットのフラグメントチャンク"
    },
    {
      "indent": 3,
      "text": "This chunk is used to divide a plain RTMFP packet (Section 2.2.4) that is unavoidably larger than the path MTU (such as session startup packets containing Responder Hello (Section 2.3.4) or Initiator Initial Keying (Section 2.3.7) chunks with large certificates) into segments that do not exceed the path MTU, and to allow the segments to be sent through the network at a moderated rate to avoid jamming interfaces, links, or paths.",
      "ja": "このチャンクは、パスMTU（例えば、レスポンダハローを含むセッション起動パケットとして（セクション2.3.4）または初期キーイング（セクション2.3.7）チャンクイニシエータより不可避的に大きくなっている無地RTMFPパケット（セクション2.2.4）に分割するために使用されていますパスMTUを超えない、およびセグメントがジャミングインターフェイス、リンク、または経路を避けるために、緩やかな速度でネットワークを介して送信できるようにセグメントに大きい証明書）を有します。"
    },
    {
      "indent": 3,
      "text": " 0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|      0x7f     |          chunkLength          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n+-+-+-+-+-+-+-+-+-------------/-+-------------/-+\n|M|  reserved   |   packetID  \\ | fragmentNum \\ |\n+-+-+-+-+-+-+-+-+-------------/-+-------------/-+\n+---------------------------------------------------------------+\n|                         packetFragment                        |\n+---------------------------------------------------------------/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct fragmentChunkPayload_t\n{\n    bool_t  moreFragments :1; // M\n    uintn_t reserved      :7;\n    vlu_t   packetID      :variable*8;\n    vlu_t   fragmentNum   :variable*8;\n    uint8_t packetFragment[remainder()];\n} :chunkLength*8;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "moreFragments: If set, the indicated packet comprises additional fragments. If clear, this fragment is the final fragment of the packet.",
      "ja": "moreFragments：設定した場合は、指示されたパケットは、追加の断片を含みます。明確な場合は、このフラグメントは、パケットの最後のフラグメントです。"
    },
    {
      "indent": 3,
      "text": "reserved: Reserved for future use.",
      "ja": "予約：将来の使用のために予約されています。"
    },
    {
      "indent": 3,
      "text": "packetID: VLU, the identifier of this segmented packet. All fragments of the same packet have the same packetID.",
      "ja": "packetID：VLU、このセグメント化されたパケットの識別子。同じパケットのすべてのフラグメントは、同じpacketIDを持っています。"
    },
    {
      "indent": 3,
      "text": "fragmentNum: VLU, the index of this fragment of the indicated packet. The first fragment of the packet MUST be index 0. Fragments are numbered consecutively.",
      "ja": "fragmentNum：VLU、指示されたパケットのこのフラグメントのインデックス。パケットの最初のフラグメントは、インデックス0断片は、連続的に番号付けされなければなりません。"
    },
    {
      "indent": 3,
      "text": "packetFragment: The bytes of the indicated segment of the indicated original plain RTMFP packet. A packetFragment MUST NOT be empty.",
      "ja": "packetFragment：示されたオリジナル無地RTMFPパケットの指示セグメントのバイト。 packetFragmentは空にすることはできません。"
    },
    {
      "indent": 3,
      "text": "The use of this mechanism is detailed in Section 3.4.",
      "ja": "このメカニズムの使用は3.4節で詳述されます。"
    },
    {
      "indent": 0,
      "text": "2.3.2. Initiator Hello Chunk (IHello)",
      "section_title": true,
      "ja": "2.3.2。イニシエータこんにちはチャンク（IHello）"
    },
    {
      "indent": 3,
      "text": "This chunk is sent by the initiator of a new session to begin the startup handshake. This chunk is only allowed in a packet with Session ID 0, encrypted with the Default Session Key, and having packet mode 3 (Startup).",
      "ja": "このチャンクは、スタートアップハンドシェイクを開始するために、新しいセッションのイニシエータによって送信されます。このチャンクは唯一のデフォルトのセッションキーで暗号化され、セッションID 0のパケットで許可され、パケットモード3（スタートアップ）を有するています。"
    },
    {
      "indent": 3,
      "text": " 0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|      0x30     |          chunkLength          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n+-------------/-+-----------------------------------------------+\n|  epdLength  \\ |    endpointDiscriminator (epdLength bytes)    |\n+-------------/-+-----------------------------------------------/\n+---------------------------------------------------------------+\n|                              tag                              |\n+---------------------------------------------------------------/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct ihelloChunkPayload_t\n{\n    vlu_t   epdLength :variable*8;\n    uint8_t endpointDiscriminator[epdLength];\n    uint8_t tag[remainder()];\n} :chunkLength*8;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "epdLength: VLU, the length of the following endpointDiscriminator field in bytes.",
      "ja": "epdLength：VLU、バイト単位で次endpointDiscriminatorフィールドの長さ。"
    },
    {
      "indent": 3,
      "text": "endpointDiscriminator: The Endpoint Discriminator for the identity with which the initiator wants to communicate.",
      "ja": "endpointDiscriminator：イニシエータが通信したいとアイデンティティのためのエンドポイント識別子。"
    },
    {
      "indent": 3,
      "text": "tag: Initiator-provided data to be returned in a Responder Hello's tagEcho field. The tag/tagEcho is used to match Responder Hellos to the initiator's session startup state independent of the responder's address.",
      "ja": "タグ：イニシエータが提供するデータは、レスポンダこんにちはのtagEchoフィールドに返されます。タグ/ tagEchoは、応答者のアドレスの独立したイニシエータのセッション起動状態にレスポンダhelloを一致させるために使用されます。"
    },
    {
      "indent": 3,
      "text": "The use of IHello is detailed in Section 3.5.1.",
      "ja": "IHelloの使用は3.5.1項に詳述されています。"
    },
    {
      "indent": 0,
      "text": "2.3.3. Forwarded Initiator Hello Chunk (FIHello)",
      "section_title": true,
      "ja": "2.3.3。転送されたイニシエータこんにちはチャンク（FIHello）"
    },
    {
      "indent": 3,
      "text": "This chunk is sent on behalf of an initiator by a Forwarder. It is only allowed in packets of an established session having packet mode 1 or 2. A receiver MAY treat this chunk as though it was an Initiator Hello received directly from replyAddress. Alternatively, if the receiver is selected by the Endpoint Discriminator, it MAY respond to replyAddress with an Implied Redirect (Section 2.3.5).",
      "ja": "このチャンクはフォワーダにより開始剤の代わりに送信されます。これは、唯一それがイニシエータこんにちはreplyAddressから直接受信したかのように、受信機がこのチャンクを扱うかもしれ1または2で確立されたセッションのパケットモードのパケットに許可されています。受信機は、エンドポイント識別子によって選択された場合あるいは、それは暗黙のリダイレクト（セクション2.3.5）とreplyAddressに応答することができます。"
    },
    {
      "indent": 3,
      "text": " 0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|      0x0f     |          chunkLength          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n+-------------/-+-----------------------------------------------+\n|  epdLength  \\ |    endpointDiscriminator (epdLength bytes)    |\n+-------------/-+-----------------------------------------------/\n+---------------------------------------------------------------+\n|                          replyAddress                         |\n+---------------------------------------------------------------/\n+---------------------------------------------------------------+\n|                              tag                              |\n+---------------------------------------------------------------/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct fihelloChunkPayload_t\n{\n    vlu_t     epdLength :variable*8;\n    uint8_t   endpointDiscriminator[epdLength];\n    address_t replyAddress :variable*8;\n    uint8_t   tag[remainder()];\n} :chunkLength*8;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "epdLength: VLU, the length of the following endpointDiscriminator field in bytes.",
      "ja": "epdLength：VLU、バイト単位で次endpointDiscriminatorフィールドの長さ。"
    },
    {
      "indent": 3,
      "text": "endpointDiscriminator: The Endpoint Discriminator for the identity with which the original initiator wants to communicate, copied from the original Initiator Hello.",
      "ja": "endpointDiscriminator：元イニシエータが通信したいとアイデンティティのためのエンドポイント識別子、元イニシエータこんにちはからコピー。"
    },
    {
      "indent": 3,
      "text": "replyAddress: Address format (Section 2.1.5), the address that the forwarding node derived from the received Initiator Hello, to which the receiver should respond.",
      "ja": "replyAddress：アドレス形式（セクション2.1.5）、受信されたイニシエータハロー由来する転送ノードは、受信機が応答しなければならないためにアドレス。"
    },
    {
      "indent": 3,
      "text": "tag: Copied from the original Initiator Hello.",
      "ja": "タグ：元イニシエータからコピーこんにちは。"
    },
    {
      "indent": 3,
      "text": "The use of FIHello is detailed in Section 3.5.1.5.",
      "ja": "FIHelloの使用は、セクション3.5.1.5で詳述されます。"
    },
    {
      "indent": 0,
      "text": "2.3.4. Responder Hello Chunk (RHello)",
      "section_title": true,
      "ja": "2.3.4。レスポンダこんにちはチャンク（RHello）"
    },
    {
      "indent": 3,
      "text": "This chunk is sent by a responder in response to an Initiator Hello or Forwarded Initiator Hello if the Endpoint Discriminator indicates the responder's identity. This chunk is only allowed in a packet with Session ID 0, encrypted with the Default Session Key, and having packet mode 3 (Startup).",
      "ja": "エンドポイント識別子は、応答者のアイデンティティを示している場合、このチャンクは、イニシエータのHelloまたは転送イニシエータこんにちはに応じて、応答者によって送られます。このチャンクは唯一のデフォルトのセッションキーで暗号化され、セッションID 0のパケットで許可され、パケットモード3（スタートアップ）を有するています。"
    },
    {
      "indent": 3,
      "text": " 0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|      0x70     |          chunkLength          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n+-------------/-+-----------------------------------------------+\n|  tagLength  \\ |            tagEcho (tagLength bytes)          |\n+-------------/-+-----------------------------------------------/\n+-------------/-+-----------------------------------------------+\n| cookieLength\\ |           cookie (cookieLength bytes)         |\n+-------------/-+-----------------------------------------------/\n+---------------------------------------------------------------+\n|                     responderCertificate                      |\n+---------------------------------------------------------------/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct rhelloChunkPayload_t\n{\n    vlu_t   tagLength :variable*8;\n    uint8_t tagEcho[tagLength];\n    vlu_t   cookieLength :variable*8;\n    uint8_t cookie[cookieLength];\n    uint8_t responderCertificate[remainder()];\n} :chunkLength*8;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "tagLength: VLU, the length of the following tagEcho field in bytes.",
      "ja": "tagLength：VLU、バイト単位で次tagEchoフィールドの長さ。"
    },
    {
      "indent": 3,
      "text": "tagEcho: The tag from the Initiator Hello, unaltered.",
      "ja": "tagEcho：変更されていないイニシエータこんにちはからタグ。"
    },
    {
      "indent": 3,
      "text": "cookieLength: VLU, the length of the following cookie field in bytes.",
      "ja": "cookieLength：VLU、バイト単位で次のCookieフィールドの長さ。"
    },
    {
      "indent": 3,
      "text": "cookie: Responder-created state data to authenticate a future Initiator Initial Keying message (in order to prevent denial-of-service attacks).",
      "ja": "クッキー：レスポンダが作成した状態データ（サービス拒否攻撃を防ぐために）将来のイニシエータ初期キーイングメッセージを認証します。"
    },
    {
      "indent": 3,
      "text": "responderCertificate: The responder's cryptographic credentials.",
      "ja": "responderCertificate：応答の暗号資格情報。"
    },
    {
      "indent": 3,
      "text": "Note: This specification doesn't mandate a specific choice of certificate format. The Cryptography Profile determines the syntax, algorithms, and interpretation of the responderCertificate.",
      "ja": "注意：この仕様は、証明書フォーマットの特定の選択を強制しません。暗号化プロファイルは、構文、アルゴリズム、およびresponderCertificateの解釈を決定します。"
    },
    {
      "indent": 3,
      "text": "The use of RHello is detailed in Section 3.5.1.",
      "ja": "RHelloの使用は3.5.1項に詳述されています。"
    },
    {
      "indent": 0,
      "text": "2.3.5. Responder Redirect Chunk (Redirect)",
      "section_title": true,
      "ja": "2.3.5。レスポンダリダイレクトチャンク（リダイレクト）"
    },
    {
      "indent": 3,
      "text": "This chunk is sent in response to an Initiator Hello or Forwarded Initiator Hello to indicate that the requested endpoint can be reached at one or more of the indicated addresses. A receiver can add none, some, or all of the indicated addresses to the set of addresses to which it is sending Initiator Hello messages for the opening session associated with tagEcho. This chunk is only allowed in a packet with Session ID 0, encrypted with the Default Session Key, and having packet mode 3 (Startup).",
      "ja": "このチャンクは、要求されたエンドポイントが示されたアドレスの一つ以上に達することができることを示すために、イニシエータこんにちはまたは転送イニシエータこんにちはに対応して送信されます。受信機は、追加することができなし、tagEchoに関連付けられた開口セッションのためのいくつかの、またはアドレスのセットに示されたアドレスの全ては、それが送信されたイニシエータHelloメッセージ。このチャンクは唯一のデフォルトのセッションキーで暗号化され、セッションID 0のパケットで許可され、パケットモード3（スタートアップ）を有するています。"
    },
    {
      "indent": 3,
      "text": " 0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|      0x71     |          chunkLength          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n+-------------/-+-----------------------------------------------+\n|  tagLength  \\ |            tagEcho (tagLength bytes)          |\n+-------------/-+-----------------------------------------------/\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+\n|                     redirectDestination 1                     |\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/\n                                :\n                                :\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+\n|                     redirectDestination N                     |\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct responderRedirectChunkPayload_t\n{\n    vlu_t   tagLength :variable*8;\n    uint8_t tagEcho[tagLength];\n    addressCount = 0;\n    while(remainder() > 0)\n    {\n        address_t redirectDestination :variable*8;\n        addressCount++;\n    }\n    if(0 == addressCount)\n        redirectDestination = packetSourceAddress();\n} :chunkLength*8;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "tagLength: VLU, the length of the following tagEcho field in bytes.",
      "ja": "tagLength：VLU、バイト単位で次tagEchoフィールドの長さ。"
    },
    {
      "indent": 3,
      "text": "tagEcho: The tag from the Initiator Hello, unaltered.",
      "ja": "tagEcho：変更されていないイニシエータこんにちはからタグ。"
    },
    {
      "indent": 3,
      "text": "redirectDestination: (Zero or more) Address format (Section 2.1.5) addresses to add to the opening set for the indicated session.",
      "ja": "redirectDestination：（ゼロ以上）アドレス形式（2.1.5）が示されたセッションに設定開口部に追加するアドレス。"
    },
    {
      "indent": 3,
      "text": "If this chunk lists zero redirectDestination addresses, then this is an Implied Redirect, and the indicated address is the address from which the packet containing this chunk was received.",
      "ja": "このチャンクがゼロredirectDestinationアドレスを一覧表示している場合、これは暗黙のリダイレクトされ、示されたアドレスは、このチャンクを含むパケットを受信したアドレスです。"
    },
    {
      "indent": 3,
      "text": "The use of Redirect is detailed in Sections 3.5.1.1.1, 3.5.1.1.2, and 3.5.1.4.",
      "ja": "リダイレクトの使用はセクション3.5.1.1.1、3.5.1.1.2、および3.5.1.4に詳述されています。"
    },
    {
      "indent": 0,
      "text": "2.3.6. RHello Cookie Change Chunk",
      "section_title": true,
      "ja": "2.3.6。 RHelloクッキーの変更チャンク"
    },
    {
      "indent": 3,
      "text": "This chunk SHOULD be sent by a responder to an initiator in response to an Initiator Initial Keying if that chunk's cookie appears to have been created by the responder but the cookie is incorrect (for example, it includes a hash of the initiator's address, but the initiator's address is different than the one that elicited the Responder Hello containing the original cookie).",
      "ja": "そのチャンクのCookieが応答者によって作成されているように見えますが、クッキーが間違っている（例えば、それは、イニシエータのアドレスのハッシュが含まれていますが、この場合、チャンクは、イニシエータ初期キーイングに応じて、イニシエータとレスポンダーで送ってくださいイニシエータのアドレスは、オリジナルのクッキーを含むレスポンダこんにちは）を誘発したものとは異なっています。"
    },
    {
      "indent": 3,
      "text": "This chunk is only allowed in a packet encrypted with the Default Session Key and having packet mode 3, and with the session ID indicated in the initiatorSessionID field of the Initiator Initial Keying to which this is a response.",
      "ja": "このチャンクは唯一のデフォルトのセッションキーとパケットモード3、およびこれが応答であるためにイニシエータ初期キーイングのinitiatorSessionIDフィールドに示されたセッションIDとを持つ暗号化されたパケットに許可されています。"
    },
    {
      "indent": 3,
      "text": " 0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|      0x79     |          chunkLength          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n+-------------/-+-----------------------------------------------+\n| oldCookieLen\\ |        oldCookie (oldCookieLen bytes)         |\n+-------------/-+-----------------------------------------------/\n+---------------------------------------------------------------+\n|                           newCookie                           |\n+---------------------------------------------------------------/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct rhelloCookieChangeChunkPayload_t\n{\n    vlu_t   oldCookieLen :variable*8;\n    uint8_t oldCookie[oldCookieLen];\n    uint8_t newCookie[remainder()];\n} :chunkLength*8;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "oldCookieLen: VLU, the length of the following oldCookie field in bytes.",
      "ja": "oldCookieLen：VLU、バイト単位で次oldCookieフィールドの長さ。"
    },
    {
      "indent": 3,
      "text": "oldCookie: The cookie that was sent in a previous Responder Hello and Initiator Initial Keying.",
      "ja": "oldCookie：前のレスポンダこんにちは、イニシエータ初期キーイングで送信されたクッキー。"
    },
    {
      "indent": 3,
      "text": "newCookie: The new cookie that the responder would like sent (and signed) in a replacement Initiator Initial Keying. The old and new cookies need not have the same lengths.",
      "ja": "newCookie：レスポンダが送信され（と署名）の交換イニシエータ初期キーイングに希望の新しいクッキー。古いものと新しいクッキーは、同じ長さを有している必要はありません。"
    },
    {
      "indent": 3,
      "text": "On receipt of this chunk, the initiator SHOULD compute, sign, and send a new Initiator Initial Keying having newCookie in place of oldCookie. The use of this chunk is detailed in Section 3.5.1.2.",
      "ja": "このチャンクを受信すると、イニシエータは、計算に署名、およびoldCookieの代わりにnewCookieを有する新規イニシエータ初期キーイングを送るべきです。このチャンクの使用は、セクション3.5.1.2で詳述されます。"
    },
    {
      "indent": 0,
      "text": "2.3.7. Initiator Initial Keying Chunk (IIKeying)",
      "section_title": true,
      "ja": "2.3.7。初期キーイングチャンクを開始剤（IIKeying）"
    },
    {
      "indent": 3,
      "text": "This chunk is sent by an initiator to establish a session with a responder. The initiator MUST have obtained a valid cookie to use with the responder, typically by receiving a Responder Hello from it. This chunk is only allowed in a packet with Session ID 0, encrypted with the Default Session Key, and having packet mode 3 (Startup).",
      "ja": "このチャンクは応答者とのセッションを確立するために、イニシエータによって送信されます。開始剤は、典型的には、それから、レスポンダのHelloを受信することにより、応答で使用するための有効なクッキーを取得している必要があります。このチャンクは唯一のデフォルトのセッションキーで暗号化され、セッションID 0のパケットで許可され、パケットモード3（スタートアップ）を有するています。"
    },
    {
      "indent": 3,
      "text": " 0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|      0x38     |          chunkLength          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                       initiatorSessionID                      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n+-------------/-+-----------------------------------------------+\n| cookieLength\\ |                  cookieEcho                   |\n+-------------/-+-----------------------------------------------/\n+-------------/-+-----------------------------------------------+\n|  certLength \\ |             initiatorCertificate              |\n+-------------/-+-----------------------------------------------/\n+-------------/-+-----------------------------------------------+\n|  skicLength \\ |          sessionKeyInitiatorComponent         |\n+-------------/-+-----------------------------------------------/\n+---------------------------------------------------------------+\n|                           signature                           |\n+---------------------------------------------------------------/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct iikeyingChunkPayload_t\n{\n    struct\n    {\n        uint32_t initiatorSessionID;\n        vlu_t    cookieLength :variable*8;\n        uint8_t  cookieEcho[cookieLength];\n        vlu_t    certLength :variable*8;\n        uint8_t  initiatorCertificate[certLength];\n        vlu_t    skicLength :variable*8;\n        uint8_t  sessionKeyInitiatorComponent[skicLength];\n    } initiatorSignedParameters :variable*8;\n    uint8_t signature[remainder()];\n} :chunkLength*8;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "initiatorSessionID: The session ID to be used by the responder when sending packets to the initiator.",
      "ja": "initiatorSessionID：イニシエータにパケットを送信するときにレスポンダが使用するセッションID。"
    },
    {
      "indent": 3,
      "text": "cookieLength: VLU, the length of the following cookieEcho field in bytes.",
      "ja": "cookieLength：VLU、バイト単位で次cookieEchoフィールドの長さ。"
    },
    {
      "indent": 3,
      "text": "cookieEcho: The cookie from the Responder Hello, unaltered.",
      "ja": "cookieEcho：変更されていないレスポンダこんにちはからクッキー、。"
    },
    {
      "indent": 3,
      "text": "certLength: VLU, the length of the following initiatorCertificate field in bytes.",
      "ja": "certLength：VLU、バイト単位で次initiatorCertificateフィールドの長さ。"
    },
    {
      "indent": 3,
      "text": "initiatorCertificate: The initiator's identity credentials.",
      "ja": "initiatorCertificate：イニシエータの身元の資格。"
    },
    {
      "indent": 3,
      "text": "skicLength: VLU, the length of the following sessionKeyInitiatorComponent field in bytes.",
      "ja": "skicLength：VLU、バイト単位で次sessionKeyInitiatorComponentフィールドの長さ。"
    },
    {
      "indent": 3,
      "text": "sessionKeyInitiatorComponent: The initiator's portion of the session key negotiation according to the Cryptography Profile.",
      "ja": "sessionKeyInitiatorComponent：暗号化プロファイルに応じてセッションキー交渉のイニシエータの一部。"
    },
    {
      "indent": 3,
      "text": "initiatorSignedParameters: The payload portion of this chunk up to the signature field.",
      "ja": "initiatorSignedParameters：署名フィールドに、このチャンクの最大のペイロード部分。"
    },
    {
      "indent": 3,
      "text": "signature: The initiator's digital signature of the initiatorSignedParameters according to the Cryptography Profile.",
      "ja": "署名：暗号プロファイルに従ってinitiatorSignedParametersのイニシエータのデジタル署名。"
    },
    {
      "indent": 3,
      "text": "Note: This specification doesn't mandate a specific choice of cryptography. The Cryptography Profile determines the syntax, algorithms, and interpretation of the initiatorCertificate, responderCertificate, sessionKeyInitiatorComponent, sessionKeyResponderComponent, and signature, and how the sessionKeyInitiatorComponent and sessionKeyResponderComponent are combined to derive the session keys.",
      "ja": "注意：この仕様は、暗号化の具体的な選択を強制しません。暗号プロフィールinitiatorCertificate、responderCertificate、sessionKeyInitiatorComponent、sessionKeyResponderComponent、および署名の構文、アルゴリズム、及び解釈を決定し、sessionKeyInitiatorComponentとsessionKeyResponderComponentはセッションキーを導出するために結合される方法。"
    },
    {
      "indent": 3,
      "text": "The use of IIKeying is detailed in Section 3.5.1.",
      "ja": "IIKeyingの使用は3.5.1項に詳述されています。"
    },
    {
      "indent": 0,
      "text": "2.3.8. Responder Initial Keying Chunk (RIKeying)",
      "section_title": true,
      "ja": "2.3.8。レスポンダ初期キーイングチャンク（RIKeying）"
    },
    {
      "indent": 3,
      "text": "This chunk is sent by a responder in response to an Initiator Initial Keying as the final phase of session startup. This chunk is only allowed in a packet encrypted with the Default Session Key, having packet mode 3 (Startup), and sent to the initiator with the session ID specified by the initiatorSessionID field from the Initiator Initial Keying.",
      "ja": "このチャンクはセッション起動の最終段階として、イニシエータ初期キーイングに応じて、応答者によって送られます。このチャンクは唯一のパケットモード3（スタートアップ）を有する、デフォルトのセッション鍵で暗号化されたパケットで許可され、イニシエータ初期キーイングからinitiatorSessionIDフィールドで指定されたセッションIDのイニシエータに送信されます。"
    },
    {
      "indent": 3,
      "text": " 0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|      0x78     |          chunkLength          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                       responderSessionID                      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n+-------------/-+-----------------------------------------------+\n|  skrcLength \\ |         sessionKeyResponderComponent          |\n+-------------/-+-----------------------------------------------/\n+---------------------------------------------------------------+\n|                           signature                           |\n+---------------------------------------------------------------/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct rikeyingChunkPayload_t\n{\n    struct\n    {\n        uint32_t responderSessionID;\n        vlu_t    skrcLength :variable*8;\n        uint8_t  sessionKeyResponderComponent[skrcLength];\n    } responderSignedParametersPortion :variable*8;\n    uint8_t  signature[remainder()];\n} :chunkLength*8;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct\n{\n    responderSignedParametersPortion;\n    sessionKeyInitiatorComponent;\n} responderSignedParameters;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "responderSessionID: The session ID to be used by the initiator when sending packets to the responder.",
      "ja": "responderSessionID：レスポンダにパケットを送信するときに、セッションIDは、イニシエータによって使用されます。"
    },
    {
      "indent": 3,
      "text": "skrcLength: VLU, the length of the following sessionKeyResponderComponent field in bytes.",
      "ja": "skrcLength：VLU、バイト単位で次sessionKeyResponderComponentフィールドの長さ。"
    },
    {
      "indent": 3,
      "text": "sessionKeyResponderComponent: The responder's portion of the session key negotiation according to the Cryptography Profile.",
      "ja": "sessionKeyResponderComponent：暗号化プロファイルに応じてセッションキー交渉の応答者の一部。"
    },
    {
      "indent": 3,
      "text": "responderSignedParametersPortion: The payload portion of this chunk up to the signature field.",
      "ja": "responderSignedParametersPortion：署名フィールドまでの、このチャンクのペイロード部分。"
    },
    {
      "indent": 3,
      "text": "signature: The responder's digital signature of the responderSignedParameters (see below) according to the Cryptography Profile.",
      "ja": "署名：responderSignedParametersの応答者のデジタル署名暗号化プロファイルに従って（下記参照）。"
    },
    {
      "indent": 3,
      "text": "responderSignedParameters: The concatenation of the responderSignedParametersPortion (the payload portion of this chunk up to the signature field) and the sessionKeyInitiatorComponent from the Initiator Initial Keying to which this chunk is a response.",
      "ja": "responderSignedParameters：このチャンクが応答されたイニシエータ初期キーイングからresponderSignedParametersPortion（署名フィールドに、このチャンク最大のペイロード部分）とsessionKeyInitiatorComponentの連結。"
    },
    {
      "indent": 3,
      "text": "Note: This specification doesn't mandate a specific choice of cryptography. The Cryptography Profile determines the syntax, algorithms, and interpretation of the initiatorCertificate, responderCertificate, sessionKeyInitiatorComponent, sessionKeyResponderComponent, and signature, and how the sessionKeyInitiatorComponent and sessionKeyResponderComponent are combined to derive the session keys.",
      "ja": "注意：この仕様は、暗号化の具体的な選択を強制しません。暗号プロフィールinitiatorCertificate、responderCertificate、sessionKeyInitiatorComponent、sessionKeyResponderComponent、および署名の構文、アルゴリズム、及び解釈を決定し、sessionKeyInitiatorComponentとsessionKeyResponderComponentはセッションキーを導出するために結合される方法。"
    },
    {
      "indent": 3,
      "text": "Once the responder has computed the sessionKeyResponderComponent, it has all of the information and state necessary for an established session with the initiator. Once the responder has sent this chunk to the initiator, the session is established and ready to carry flows of user data.",
      "ja": "レスポンダがsessionKeyResponderComponentを計算した後、それは開始剤と確立されたセッションに必要な情報及び状態の全てを有しています。レスポンダはイニシエータにこのチャンクを送信した後は、セッションが確立され、ユーザデータの流れを伝送する準備ができています。"
    },
    {
      "indent": 3,
      "text": "Once the initiator receives, verifies, and processes this chunk, it has all of the information and state necessary for an established session with the responder. The session is established and ready to carry flows of user data.",
      "ja": "イニシエータは、受信を確認し、このチャンクを処理したら、レスポンダとの確立されたセッションに必要な情報及び状態の全てを有しています。セッションが確立され、ユーザデータの流れを伝送する準備ができています。"
    },
    {
      "indent": 3,
      "text": "The use of RIKeying is detailed in Section 3.5.1.",
      "ja": "RIKeyingの使用は3.5.1項に詳述されています。"
    },
    {
      "indent": 0,
      "text": "2.3.9. Ping Chunk",
      "section_title": true,
      "ja": "2.3.9。 pingのチャンク"
    },
    {
      "indent": 3,
      "text": "This chunk is sent in order to elicit a Ping Reply from the receiver. It is only allowed in a packet belonging to an established session and having packet mode 1 or 2.",
      "ja": "このチャンクは受信機からのping応答を惹起するために送信されます。これは、パケットのみ確立されたセッションに属するパケットモード1または2を有することを許可されています。"
    },
    {
      "indent": 3,
      "text": " 0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|      0x01     |          chunkLength          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+\n|                             message                           |\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct pingChunkPayload_t\n{\n    uint8_t message[chunkLength];\n} :chunkLength*8;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "message: The (potentially empty) message that is expected to be returned by the other end of the session in a Ping Reply.",
      "ja": "メッセージ：ping応答におけるセッションの他方の端部によって戻されると予想される（潜在的に空の）メッセージ。"
    },
    {
      "indent": 3,
      "text": "The receiver of this chunk SHOULD reply as immediately as is practical with a Ping Reply.",
      "ja": "このチャンクの受信機は、ping応答を持つ実用的である限り、直ちに返信すべきです。"
    },
    {
      "indent": 3,
      "text": "Ping and the expected Ping Reply are typically used for session keepalive, endpoint address change verification, and path MTU discovery. See Section 3.5.4 for details.",
      "ja": "pingと予想されるping応答は、通常のセッションキープアライブ、エンドポイントアドレス変更の確認、およびパスMTUディスカバリのために使用されています。詳細については、3.5.4項を参照してください。"
    },
    {
      "indent": 0,
      "text": "2.3.10. Ping Reply Chunk",
      "section_title": true,
      "ja": "2.3.10。 ping応答チャンク"
    },
    {
      "indent": 3,
      "text": "This chunk is sent in response to a Ping chunk. It is only allowed in a packet belonging to an established session and having packet mode 1 or 2.",
      "ja": "このチャンクはPingのチャンクに対応して送信されます。これは、パケットのみ確立されたセッションに属するパケットモード1または2を有することを許可されています。"
    },
    {
      "indent": 3,
      "text": " 0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|      0x41     |          chunkLength          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+\n|                           messageEcho                         |\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct pingReplyChunkPayload_t\n{\n    uint8_t messageEcho[chunkLength];\n} :chunkLength*8;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "messageEcho: The message from the Ping to which this is a response, unaltered.",
      "ja": "messageEcho：これは変更されていない応答であり、これには、pingからのメッセージ。"
    },
    {
      "indent": 0,
      "text": "2.3.11. User Data Chunk",
      "section_title": true,
      "ja": "2.3.11。ユーザーデータチャンク"
    },
    {
      "indent": 3,
      "text": "This chunk is the basic unit of transmission for the user messages of a flow. A user message comprises one or more fragments. Each fragment is carried in its own chunk and has a unique sequence number in its flow. It is only allowed in a packet belonging to an established session and having packet mode 1 or 2.",
      "ja": "このチャンクは、フローのユーザメッセージのための伝送の基本単位です。ユーザのメッセージは、一つ以上の断片を含みます。各断片は、それ自身のチャンクに運ばれ、その流れに固有のシーケンス番号を有しています。これは、パケットのみ確立されたセッションに属するパケットモード1または2を有することを許可されています。"
    },
    {
      "indent": 3,
      "text": " 0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|      0x10     |          chunkLength          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n+-+-+-+-+-+-+-+-+\n|O|r| F | r |A|F|\n|P|s| R | s |B|I|\n|T|v| A | v |N|N|\n+-+-+-+-+-+-+-+-+\n+-------------/-+-------------/-+-------------/-+\n|   flowID    \\ |     seq#    \\ |  fsnOffset  \\ |\n+-------------/-+-------------/-+-------------/-+\n+~~~/~~~/~~~~~~~+               +~~~/~~~/~~~~~~~+-------------/-+\n| L \\ T \\   V   |... options ...| L \\ T \\   V   |       0     \\ |\n\\~~~/~~~/~~~~~~~+   [if(OPT)]   +~~~/~~~/~~~~~~~+-------------/-/\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+\n|                            userData                           |\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct userDataChunkPayload_t\n{\n    bool_t  optionsPresent :1;  // \"OPT\"\n    uintn_t reserved1 :1;       // \"rsv\"\n    uintn_t fragmentControl :2; // \"FRA\"\n        // 0=whole, 1=begin, 2=end, 3=middle\n    uintn_t reserved2 :2;       // \"rsv\"\n    bool_t  abandon :1;         // \"ABN\"\n    bool_t  final :1;           // \"FIN\"\n    vlu_t   flowID :variable*8;\n    vlu_t   sequenceNumber :variable*8; // \"seq#\"\n    vlu_t   fsnOffset :variable*8;\n    forwardSequenceNumber = sequenceNumber - fsnOffset;\n    if(optionsPresent)\n        optionList_t options :variable*8;\n    uint8_t userData[remainder()];\n} :chunkLength*8;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "optionsPresent: If set, indicates the presence of an option list before the user data. If clear, there is no option list in this chunk.",
      "ja": "optionsPresent：設定されている場合、ユーザデータの前にオプションのリストが存在することを示しています。明確な場合は、このチャンクにはオプションリストはありません。"
    },
    {
      "indent": 3,
      "text": "fragmentControl: Indicates how this fragment is assembled, potentially with others, into a complete user message. Possible values:",
      "ja": "fragmentControl：ユーザーメッセージに、潜在的に他の人と、このフラグメントを組み立てる方法を示します。可能な値："
    },
    {
      "indent": 6,
      "text": "0: This fragment is a complete message.",
      "ja": "0：このフラグメントは、完全なメッセージです。"
    },
    {
      "indent": 6,
      "text": "1: This fragment is the first of a multi-fragment message.",
      "ja": "1：このフラグメントは、マルチ断片メッセージの最初のものです。"
    },
    {
      "indent": 6,
      "text": "2: This fragment is the last of a multi-fragment message.",
      "ja": "2：このフラグメントは、マルチ断片メッセージの最後です。"
    },
    {
      "indent": 6,
      "text": "3: This fragment is in the middle of a multi-fragment message.",
      "ja": "3：このフラグメントは、マルチ断片メッセージの真ん中にあります。"
    },
    {
      "indent": 6,
      "text": "A single-fragment user message has a fragment control of \"0-whole\". When a message has more than one fragment, the first fragment has a fragment control of \"1-begin\", then zero or more \"3-middle\" fragments, and finally a \"2-end\" fragment. The sequence numbers of a multi-fragment message MUST be contiguous.",
      "ja": "シングル断片ユーザ・メッセージが「0-全体」の断片の制御を有します。メッセージが複数の断片を有している場合、最初のフラグメントは、「1-開始」、ゼロまたはそれ以上の「3中間」断片、および最後に「2エンド」断片の断片の制御を有します。マルチ断片メッセージのシーケンス番号が連続していなければなりません。"
    },
    {
      "indent": 3,
      "text": "abandon: If set, this sequence number has been abandoned by the sender. The userData, if any, MUST be ignored.",
      "ja": "放棄：設定されている場合、このシーケンス番号は、送信者が放棄されています。 userDataは、もしあれば、無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "final: If set, this is the last sequence number of the flow.",
      "ja": "最終：設定されている場合、これは流れの最後のシーケンス番号です。"
    },
    {
      "indent": 3,
      "text": "flowID: VLU, the flow identifier.",
      "ja": "フローID：VLU、フロー識別子。"
    },
    {
      "indent": 3,
      "text": "sequenceNumber: VLU, the sequence number of this fragment. Fragments are assigned contiguous increasing sequence numbers in a flow. The first sequence number of a flow SHOULD be 1. The first sequence number of a flow MUST be greater than zero. Sequence numbers are unbounded and do not wrap.",
      "ja": "sequenceNumberが：VLU、この断片のシーケンス番号。フラグメントは、フロー内の連続増加するシーケンス番号が割り当てられています。フローの最初のシーケンス番号は、フローの最初のシーケンス番号がゼロより大きくなければならない1であるべきです。シーケンス番号は無制限であり、折り返されません。"
    },
    {
      "indent": 3,
      "text": "fsnOffset: VLU, the difference between the sequence number and the Forward Sequence Number. This field MUST NOT be zero if the abandon flag is not set. This field MUST NOT be greater than sequenceNumber.",
      "ja": "fsnOffset：VLU、シーケンス番号とフォワードシーケンス番号の違い。放棄フラグが設定されていない場合、このフィールドはゼロであるはずがありません。このフィールドは、sequenceNumberがより大きくすることはできません。"
    },
    {
      "indent": 3,
      "text": "forwardSequenceNumber: The flow sender will not send (or resend) any fragment with a sequence number less than or equal to the Forward Sequence Number.",
      "ja": "forwardSequenceNumber：フローの送信者は、以下転送シーケンス番号に等しいシーケンス番号を有する任意の断片を送信（または再送信）しないであろう。"
    },
    {
      "indent": 3,
      "text": "options: If the optionsPresent flag is set, a list of zero or more Options terminated by a Marker is present. See Section 2.3.11.1 for defined options.",
      "ja": "オプション：optionsPresentフラグが設定されている場合は、マーカーで終了し、ゼロ以上のオプションのリストが存在しています。定義されたオプションについては、セクション2.3.11.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "userData: The actual user data for this fragment.",
      "ja": "userData：このフラグメントのための実際のユーザデータ。"
    },
    {
      "indent": 3,
      "text": "The use of User Data is detailed in Section 3.6.2.",
      "ja": "ユーザーデータの使用は3.6.2項に詳述されています。"
    },
    {
      "indent": 0,
      "text": "2.3.11.1. Options for User Data",
      "section_title": true,
      "ja": "2.3.11.1。ユーザーデータのためのオプション"
    },
    {
      "indent": 3,
      "text": "This section lists options that may appear in User Data option lists. A conforming implementation MUST support the options in this section.",
      "ja": "このセクションでは、ユーザーデータのオプションリストに表示される場合がありますオプションを示します。準拠した実装では、このセクションのオプションをサポートしなければなりません。"
    },
    {
      "indent": 3,
      "text": "A flow receiver MUST reject a flow containing a flow option that is not understood if the option type is less than 8192 (0x2000). A flow receiver MUST ignore any flow option that is not understood if the option type is 8192 or greater.",
      "ja": "フロー受信機は、オプションタイプ未満8192（0x2000で）である場合には理解されていないフローオプションを含む流れを拒絶しなければなりません。フロー受信機は、オプションタイプが8192以上である場合には理解されていない任意のフローオプションを無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The following option type codes are defined for User Data:",
      "ja": "次のオプション・タイプ・コードは、ユーザデータのために定義されています。"
    },
    {
      "indent": 3,
      "text": "0x00: User's Per-Flow Metadata (Section 2.3.11.1.1)",
      "ja": "$ 00：ユーザーズ・フロー単位のメタデータ（セクション2.3.11.1.1）"
    },
    {
      "indent": 3,
      "text": "0x0a: Return Flow Association (Section 2.3.11.1.2)",
      "ja": "0x0Aを：リターンフロー協会（セクション2.3.11.1.2）"
    },
    {
      "indent": 0,
      "text": "2.3.11.1.1. User's Per-Flow Metadata",
      "section_title": true,
      "ja": "2.3.11.1.1。ユーザーごとのフローのメタデータ"
    },
    {
      "indent": 3,
      "text": "This option conveys the user's per-flow metadata for the flow to which it's attached.",
      "ja": "このオプションは、それが取り付けられていますする流れのためのユーザーのフローごとのメタデータを伝えます。"
    },
    {
      "indent": 3,
      "text": "+-------------/-+-------------/-+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+\n|   length    \\ |     0x00    \\ |         userMetadata          |\n+-------------/-+-------------/-+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct userMetadataOptionValue_t\n{\n    uint8_t userMetadata[remainder()];\n} :remainder()*8;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The user associates application-defined metadata with each flow. The metadata does not change over the life of the flow. Every flow MUST have metadata. A flow sender MUST send this option with the first User Data chunk for this flow in each packet until an acknowledgement for this flow is received. A flow sender SHOULD NOT send this option more than once for each flow in any one packet. A flow sender SHOULD NOT send this option for a flow once the flow has been acknowledged.",
      "ja": "ユーザは、各フローにアプリケーション定義のメタデータを関連付けます。メタデータは、フローの期間にわたって変更されません。すべてのフローは、メタデータを持っていなければなりません。このフローの確認応答を受信するまでのフローの送信者は、各パケット内のこのフローの最初のユーザデータのチャンクでは、このオプションを送らなければなりません。フローの送信者は、いずれかのパケット内の各フローのためにこのオプションを複数回送信することはできません。流れが確認された後、フローの送信者は、フローのために、このオプションを送るべきではありません。"
    },
    {
      "indent": 3,
      "text": "This specification doesn't mandate the encoding, syntax, or interpretation of the user's per-flow metadata; this is determined by the application.",
      "ja": "この仕様は、ユーザーのフローごとのメタデータのエンコーディング、構文、または解釈を強制しません。これは、アプリケーションによって決定されます。"
    },
    {
      "indent": 3,
      "text": "The userMetadata SHOULD NOT exceed 512 bytes. The userMetadata MAY be 0 bytes in length.",
      "ja": "userMetadataは512バイトを超えないようにしてください。 userMetadataは、長さが0バイトになる場合があります。"
    },
    {
      "indent": 0,
      "text": "2.3.11.1.2. Return Flow Association",
      "section_title": true,
      "ja": "2.3.11.1.2。リターンフロー協会"
    },
    {
      "indent": 3,
      "text": "A new flow can be considered to be in return (or response) to a flow sent by the other endpoint. This option encodes the receive flow identifier to which this new sending flow is a response.",
      "ja": "新しいフローは、他のエンドポイントによって送信されたフローにリターン（または応答）であると考えることができます。このオプションでは、この新しい送信フローが応答されている受信フロー識別子を符号化します。"
    },
    {
      "indent": 3,
      "text": "+-------------/-+-------------/-+-------------/-+\n|   length    \\ |     0x0a    \\ |    flowID   \\ |\n+-------------/-+-------------/-+-------------/-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct returnFlowAssociationOptionValue_t\n{\n    vlu_t flowID :variable*8;\n} :variable*8;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Consider endpoints A and B. Endpoint A begins a flow with identifier 5 to endpoint B. A is the flow sender for A's flowID=5, and B is the flow receiver for A's flowID=5. B begins a return flow with identifier 7 to A in response to A's flowID=5. B is the flow sender for B's flowID=7, and A is the flow receiver for B's flowID=7. B sends this option with flowID set to 5 to indicate that B's flowID=7 is in response to and associated with A's flowID=5.",
      "ja": "エンドポイントAを考えるとBエンドポイントAは、B、AがAのフローID = 5のためのフロー送信元であるエンドポイントに識別子5と流れを開始し、BはAのフローID = 5のためのフローの受信機です。 Bは、AのフローID = 5に対応してAに識別子7とリターン・フローを開始します。 Bは、BのフローID = 7のフローの送信者であり、そしてAは、BのフローID = 7のためのフローの受信機です。 Bは、BのフローID = 7に対応しており、= 5 AのフローIDに関連付けられていることを示すために、5に設定フローIDと、このオプションを送信します。"
    },
    {
      "indent": 3,
      "text": "If there is a return association, the flow sender MUST send this option with the first User Data chunk for this flow in each packet until an acknowledgement for this flow is received. A flow sender SHOULD NOT send this option more than once for each flow in any one packet. A flow sender SHOULD NOT send this option for a flow once the flow has been acknowledged.",
      "ja": "リターン・アソシエーションが存在する場合、この流れのための肯定応答が受信されるまで、フローの送信者は、各パケット内のこのフローの最初のユーザデータのチャンクでは、このオプションを送らなければなりません。フローの送信者は、いずれかのパケット内の各フローのためにこのオプションを複数回送信することはできません。流れが確認された後、フローの送信者は、フローのために、このオプションを送るべきではありません。"
    },
    {
      "indent": 3,
      "text": "A flow MUST NOT indicate more than one return association.",
      "ja": "フローは、複数の戻り値の関連性を示してはいけません。"
    },
    {
      "indent": 3,
      "text": "A flow MUST indicate its return association, if any, upon its first transmission of a User Data chunk. A return association can't be added to a sending flow after it begins.",
      "ja": "フローは、ユーザデータチャンクの最初の送信時に、もしあれば、その戻り関連を示さなければなりません。それは開始後リターンの関連付けは、送信フローに追加することはできません。"
    },
    {
      "indent": 3,
      "text": "A flow receiver MUST reject a new receiving flow having a return flow association that does not indicate an F_OPEN sending flow.",
      "ja": "フロー受信機はF_OPEN送信フローを示していないリターン・フロー・アソシエーションを有する新たな受信フローを拒絶しなければなりません。"
    },
    {
      "indent": 0,
      "text": "2.3.12. Next User Data Chunk",
      "section_title": true,
      "ja": "2.3.12。次のユーザデータチャンク"
    },
    {
      "indent": 3,
      "text": "This chunk is equivalent to the User Data chunk for purposes of sending the user messages of a flow. When used, it MUST follow a User Data chunk or another Next User Data chunk in the same packet.",
      "ja": "このチャンクは、フローのユーザメッセージを送信する目的のためにユーザーデータチャンクに相当します。使用した場合、それは同じパケット内のユーザデータチャンクまたは他の次のユーザーデータのチャンクに従わなければなりません。"
    },
    {
      "indent": 3,
      "text": " 0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|      0x11     |          chunkLength          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n+-+-+-+-+-+-+-+-+\n|O|r| F | r |A|F|\n|P|s| R | s |B|I|\n|T|v| A | v |N|N|\n+-+-+-+-+-+-+-+-+\n+~~~/~~~/~~~~~~~+               +~~~/~~~/~~~~~~~+-------------/-+\n| L \\ T \\   V   |... options ...| L \\ T \\   V   |       0     \\ |\n\\~~~/~~~/~~~~~~~+   [if(OPT)]   +~~~/~~~/~~~~~~~+-------------/-/\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+\n|                            userData                           |\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct nextUserDataChunkPayload_t\n{\n    bool_t  optionsPresent :1;  // \"OPT\"\n    uintn_t reserved1 :1;       // \"rsv\"\n    uintn_t fragmentControl :2; // \"FRA\"\n        // 0=whole, 1=begin, 2=end, 3=middle\n    uintn_t reserved2 :2;       // \"rsv\"\n    bool_t  abandon :1;         // \"ABN\"\n    bool_t  final :1;           // \"FIN\"\n    if(optionsPresent)\n        optionList_t options :variable*8;\n    uint8_t userData[remainder()];\n} :chunkLength*8;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This chunk is considered to be for the same flowID as the most recently preceding User Data or Next User Data chunk in the same packet, having the same Forward Sequence Number, and having the next sequence number. The optionsPresent, fragmentControl, abandon, and final flags, and the options (if present), have the same interpretation as for the User Data chunk.",
      "ja": "最近同じ転送シーケンス番号を有し、次のシーケンス番号を有する同じパケット内のユーザデータまたは次のユーザデータチャンクに先行するように、このチャンクは同一のフローIDのためであると考えられます。 optionsPresent、fragmentControl、放棄、および最終フラグ、およびオプション（存在する場合）は、ユーザデータのチャンクと同じ解釈を持っています。"
    },
    {
      "indent": 15,
      "text": "...\n----------+------------------------------------\n10 00 07  | User Data chunk, length=7\n00        | OPT=0, FRA=0 \"whole\", ABN=0, FIN=0\n02 05 03  | flowID=2, seq#=5, fsn=(5-3)=2\n00 01 02  | data 3 bytes: 00, 01, 02\n----------+------------------------------------\n11 00 04  | Next User Data chunk,length=4\n00        | OPT=0, FRA=0 \"whole\", ABN=0, FIN=0\n          | flowID=2, seq#=6, fsn=2\n03 04 05  | data 3 bytes: 03, 04, 05\n----------+------------------------------------\n11 00 04  | Next User Data chunk, length=4\n00        | OPT=0, FRA=0 \"whole\", ABN=0, FIN=0\n          | flowID=2, seq#=7, fsn=2\n06 07 08  | data 3 bytes: 06, 07, 08\n----------+------------------------------------",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Figure 3: Sequential Messages in One Packet Using Next User Data",
      "ja": "図3：次のユーザーデータを使用して一つのパケットでシーケンシャルのメッセージ"
    },
    {
      "indent": 3,
      "text": "The use of Next User Data is detailed in Section 3.6.2.3.2.",
      "ja": "次のユーザーデータの使用は、セクション3.6.2.3.2で詳細です。"
    },
    {
      "indent": 0,
      "text": "2.3.13. Data Acknowledgement Bitmap Chunk (Bitmap Ack)",
      "section_title": true,
      "ja": "2.3.13。データ確認応答ビットマップチャンク（ビットマップACK）"
    },
    {
      "indent": 3,
      "text": "This chunk is sent by the flow receiver to indicate to the flow sender the User Data fragment sequence numbers that have been received for one flow. It is only allowed in a packet belonging to an established session and having packet mode 1 or 2.",
      "ja": "このチャンクは、フロー送信者に一つのフローのために受信されているユーザーデータの断片配列番号を示すために、フロー受信機によって送信されます。これは、パケットのみ確立されたセッションに属するパケットモード1または2を有することを許可されています。"
    },
    {
      "indent": 3,
      "text": "The flow receiver can choose to acknowledge User Data with this chunk or with a Range Ack. It SHOULD choose whichever format has the most compact encoding of the sequence numbers received.",
      "ja": "フロー受信機は、このチャンク、あるいは範囲ACKでユーザーデータを確認することを選択できます。これは、受信したシーケンス番号の最もコンパクトなエンコーディングを持っている方のフォーマットを選択する必要があります。"
    },
    {
      "indent": 3,
      "text": " 0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|      0x50     |          chunkLength          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n+-------------/-+-------------/-+-------------/-+\n|   flowID    \\ |   bufAvail  \\ |    cumAck   \\ |\n+-------------/-+-------------/-+-------------/-+\n+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+\n|C|C|C|C|C|C|C|C|C|C|C|C|C|C|C|C|C|C|C|C|C|C|C|C|\n|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|+|\n|9|8|7|6|5|4|3|2|1|1|1|1|1|1|1|1|2|2|2|2|2|2|1|1| ....\n| | | | | | | | |7|6|5|4|3|2|1|0|5|4|3|2|1|0|9|8|\n+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct dataAckBitmapChunkPayload_t\n{\n    vlu_t flowID :variable*8;\n    vlu_t bufferBlocksAvailable :variable*8; // \"bufAvail\"\n    vlu_t cumulativeAck :variable*8; // \"cumAck\"\n    bufferBytesAvailable = bufferBlocksAvailable * 1024;\n    acknowledge(0 through cumulativeAck);\n    ackCursor = cumulativeAck + 1;\n    while(remainder() > 0)\n    {\n        for(bitPosition = 8; bitPosition > 0; bitPosition--)\n        {\n            bool_t bit :1;\n            if(bit)\n                acknowledge(ackCursor + bitPosition);\n        }\n        ackCursor += 8;\n    }\n} :chunkLength*8;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "flowID: VLU, the flow identifier.",
      "ja": "フローID：VLU、フロー識別子。"
    },
    {
      "indent": 3,
      "text": "bufferBlocksAvailable: VLU, the number of 1024-byte blocks of User Data that the receiver is currently able to accept. Section 3.6.3.5 describes how to calculate this value.",
      "ja": "bufferBlocksAvailable：VLU、受信機は現在、受け入れることができるユーザーデータの1024バイトのブロックの数。セクション3.6.3.5は、この値を計算する方法について説明します。"
    },
    {
      "indent": 3,
      "text": "cumulativeAck: VLU, the acknowledgement of every fragment sequence number in this flow that is less than or equal to this value. This MUST NOT be less than the highest Forward Sequence Number received in this flow.",
      "ja": "cumulativeAck：VLU、この値以下であり、このフローのすべてのフラグメントシーケンス番号の確認応答。これは、この流れで受信し、最高順方向シーケンス番号以上でなければなりません。"
    },
    {
      "indent": 3,
      "text": "bit field: A sequence of zero or more bytes representing a bit field of received fragment sequence numbers after the cumulative acknowledgement, least significant bit first. A set bit indicates receipt of a sequence number. A clear bit indicates that sequence number was not received. The least significant bit of the first byte is the second sequence number following the cumulative acknowledgement, the next bit is the third sequence number following, and so on.",
      "ja": "ビットフィールド：最初の累積確認応答の後、最下位ビットを受信したフラグメントのシーケンス番号のビット・フィールドを表すゼロ以上のバイトのシーケンス。設定されたビットは、シーケンス番号の受信を示しています。クリアビットは、シーケンス番号が受信されなかったことを示しています。最初のバイトの最下位ビットは、累積確認応答を、以下の第二シーケンス番号は、次のビットがそうで次の第3のシーケンス番号であり、です。"
    },
    {
      "indent": 6,
      "text": "Figure 4 shows an example Bitmap Ack indicating acknowledgement of fragment sequence numbers 0 through 16, 18, 21 through 24, 27, and 28.",
      "ja": "図4は、16、18、21〜24、27、及び28を介してフラグメントシーケンス番号0の肯定応答を示す実施例ビットマップACKを示しています。"
    },
    {
      "indent": 9,
      "text": "50 00 05 | Bitmap Ack, length=5 bytes 05 7f 10 | flowID=5, bufAvail=127*1024 bytes, cumAck=0..16 79 06 | 01111001 00000110 = 18, 21, 22, 23, 24, 27, 28",
      "ja": "50 00 05 |ビットマップACK、長さ= 5バイト05 7F 10 |フローID = 5、bufAvail = 127 * 1024バイト、cumAck = 0..16 79 06 | 01111001 00000110 = 18、21、22、23、24、27、28"
    },
    {
      "indent": 23,
      "text": "Figure 4: Example Bitmap Ack",
      "ja": "図4：例ビットマップのAck"
    },
    {
      "indent": 0,
      "text": "2.3.14. Data Acknowledgement Ranges Chunk (Range Ack)",
      "section_title": true,
      "ja": "2.3.14。データ確認応答がチャンクを範囲（レンジのAck）"
    },
    {
      "indent": 3,
      "text": "This chunk is sent by the flow receiver to indicate to the flow sender the User Data fragment sequence numbers that have been received for one flow. It is only allowed in a packet belonging to an established session and having packet mode 1 or 2.",
      "ja": "このチャンクは、フロー送信者に一つのフローのために受信されているユーザーデータの断片配列番号を示すために、フロー受信機によって送信されます。これは、パケットのみ確立されたセッションに属するパケットモード1または2を有することを許可されています。"
    },
    {
      "indent": 3,
      "text": "The flow receiver can choose to acknowledge User Data with this chunk or with a Bitmap Ack. It SHOULD choose whichever format has the most compact encoding of the sequence numbers received.",
      "ja": "フロー受信機は、このチャンクまたはビットマップACKでユーザーデータを確認することを選択できます。これは、受信したシーケンス番号の最もコンパクトなエンコーディングを持っている方のフォーマットを選択する必要があります。"
    },
    {
      "indent": 3,
      "text": " 0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|      0x51     |          chunkLength          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n+-------------/-+-------------/-+-------------/-+\n|   flowID    \\ |   bufAvail  \\ |    cumAck   \\ |\n+-------------/-+-------------/-+-------------/-+\n+~~~~~~~~~~~~~/~+~~~~~~~~~~~~~/~+\n|   #holes-1  \\ |   #recv-1   \\ |\n+~~~~~~~~~~~~~/~+~~~~~~~~~~~~~/~+\n                :\n                :\n+~~~~~~~~~~~~~/~+~~~~~~~~~~~~~/~+\n|   #holes-1  \\ |   #recv-1   \\ |\n+~~~~~~~~~~~~~/~+~~~~~~~~~~~~~/~+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct dataAckRangesChunkPayload_t\n{\n    vlu_t flowID :variable*8;\n    vlu_t bufferBlocksAvailable :variable*8; // \"bufAvail\"\n    vlu_t cumulativeAck :variable*8; // \"cumAck\"\n    bufferBytesAvailable = bufferBlocksAvailable * 1024;\n    acknowledge(0 through cumulativeAck);\n    ackCursor = cumulativeAck;\n    while(remainder() > 0)\n    {\n        vlu_t holesMinusOne :variable*8; // \"#holes-1\"\n        vlu_t receivedMinusOne :variable*8; // \"#recv-1\"",
      "raw": true
    },
    {
      "indent": 11,
      "text": "ackCursor++;\nrangeFrom = ackCursor + holesMinusOne + 1;\nrangeTo = rangeFrom + receivedMinusOne;\nacknowledge(rangeFrom through rangeTo);",
      "raw": true
    },
    {
      "indent": 3,
      "text": "        ackCursor = rangeTo;\n    }\n} :chunkLength*8;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "flowID: VLU, the flow identifier.",
      "ja": "フローID：VLU、フロー識別子。"
    },
    {
      "indent": 3,
      "text": "bufferBlocksAvailable: VLU, the number of 1024-byte blocks of User Data that the receiver is currently able to accept. Section 3.6.3.5 describes how to calculate this value.",
      "ja": "bufferBlocksAvailable：VLU、受信機は現在、受け入れることができるユーザーデータの1024バイトのブロックの数。セクション3.6.3.5は、この値を計算する方法について説明します。"
    },
    {
      "indent": 3,
      "text": "cumulativeAck: VLU, the acknowledgement of every fragment sequence number in this flow that is less than or equal to this value. This MUST NOT be less than the highest Forward Sequence Number received in this flow.",
      "ja": "cumulativeAck：VLU、この値以下であり、このフローのすべてのフラグメントシーケンス番号の確認応答。これは、この流れで受信し、最高順方向シーケンス番号以上でなければなりません。"
    },
    {
      "indent": 3,
      "text": "holesMinusOne / receivedMinusOne: Zero or more acknowledgement ranges, run-length encoded. Runs are encoded as zero or more pairs of VLUs indicating the number (minus one) of missing sequence numbers followed by the number (minus one) of received sequence numbers, starting at the cumulative acknowledgement. NOTE: If a parser syntax error is encountered here (that is, if the chunk is truncated such that not enough bytes remain to completely encode both VLUs of the acknowledgement range), then treat and process this chunk as though it was properly formed up to the last completely encoded range.",
      "ja": "holesMinusOne / receivedMinusOne：ゼロ以上の承認範囲は、ランレングス符号化さ。実験は、累積確認応答から始まる、受信されたシーケンス番号の数（マイナス1）、続いて欠落したシーケンス番号の数（マイナス1）を示すのVLUのゼロまたはそれ以上の対として符号化されます。注：パーサ構文エラーが（チャンクが十分でないバイトが完全に受信確認の範囲の両方のVLUをエンコードするために残るよう切り捨てられた場合には、ある）、ここで検出された場合、それが適切にまで形成されたかのように、このチャンクを処理し、処理最後に、完全にエンコードされた範囲。"
    },
    {
      "indent": 6,
      "text": "Figure 5 shows an example Range Ack indicating acknowledgement of fragment sequence numbers 0 through 16, 18, 21, 22, 23, and 24.",
      "ja": "図5は、16、18、21、22、23、及び24を介してフラグメントシーケンス番号0の肯定応答を示す実施例の範囲ACKを示しています。"
    },
    {
      "indent": 6,
      "text": "51 00 07 | Range Ack, length=7 05 7f 10 | flowID=5, bufAvail=127*1024 bytes, cumAck=0..16 00 00 | holes=1, received=1 -- missing 17, received 18 01 03 | holes=2, received=4 -- missing 19..20, received 21..24",
      "ja": "51 00 07 |レンジのAck、長= 7 05 7F 10 |フローID = 5、bufAvail = 127 * 1024バイト、cumAck = 0..16 00 00 |穴= 1、= 1受信 - 、17の欠落が受信18 01 03 | 、19..20が欠落21..24を受信 -  = 2穴は、= 4を受け"
    },
    {
      "indent": 24,
      "text": "Figure 5: Example Range Ack",
      "ja": "図5：例範囲のAck"
    },
    {
      "indent": 6,
      "text": "Figure 6 shows an example Range Ack indicating acknowledgement of fragment sequence numbers 0 through 16 and 18, with a truncated last range. Note that the truncation and parse error does not abort the entire chunk in this case.",
      "ja": "図6は、切り捨て最後範囲で、16および18を介してフラグメントシーケンス番号0の肯定応答を示す実施例の範囲ACKを示しています。切り捨てとパースエラーが、この場合、全体のチャンクを中止しないことに注意してください。"
    },
    {
      "indent": 7,
      "text": "51 00 07 | Range Ack, length=9 05 7f 10 | flowID=5, bufAvail=127*1024 bytes, cumAck=0..16 00 00 | holes=1, received=1 -- missing 17, received 18 01 83 | holes=2, received=VLU parse error, ignore this range",
      "ja": "51 00 07 |レンジのAck、長= 9 05 7F 10 |フローID = 5、bufAvail = 127 * 1024バイト、cumAck = 0..16 00 00 |ホール= 1、= 1受信 - 、17欠落が受け取ら18 01 83 | = 2穴は、この範囲を無視して、= VLUの解析エラーを受信しました"
    },
    {
      "indent": 19,
      "text": "Figure 6: Example Truncated Range Ack",
      "ja": "図6：例切り捨て範囲のAck"
    },
    {
      "indent": 0,
      "text": "2.3.15. Buffer Probe Chunk",
      "section_title": true,
      "ja": "2.3.15。バッファプローブチャンク"
    },
    {
      "indent": 3,
      "text": "This chunk is sent by the flow sender in order to request the current available receive buffer (in the form of a Data Acknowledgement) for a flow. It is only allowed in a packet belonging to an established session and having packet mode 1 or 2.",
      "ja": "このチャンクは、フローのため（データ確認応答の形で）現在利用可能な受信バッファを要求するためにフロー送信者によって送信されます。これは、パケットのみ確立されたセッションに属するパケットモード1または2を有することを許可されています。"
    },
    {
      "indent": 3,
      "text": " 0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|      0x18     |          chunkLength          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n+-------------/-+\n|   flowID    \\ |\n+-------------/-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct bufferProbeChunkPayload_t\n{\n    vlu_t flowID :variable*8;\n} :chunkLength*8;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "flowID: VLU, the flow identifier.",
      "ja": "フローID：VLU、フロー識別子。"
    },
    {
      "indent": 3,
      "text": "The receiver of this chunk SHOULD reply as immediately as is practical with a Data Acknowledgement.",
      "ja": "このチャンクの受信機は、データ受信確認と実用的である限り、直ちに返信すべきです。"
    },
    {
      "indent": 0,
      "text": "2.3.16. Flow Exception Report Chunk",
      "section_title": true,
      "ja": "2.3.16。フロー例外レポートチャンク"
    },
    {
      "indent": 3,
      "text": "This chunk is sent by the flow receiver to indicate that it is not (or is no longer) interested in the flow and would like the flow sender to close the flow. This chunk SHOULD precede every Data Acknowledgement chunk for the same flow in this condition.",
      "ja": "このチャンクはそれがない（または、もはやありません）の流れに興味や流れを閉じるには、フローの送信者を希望することを示すために、フロー受信機によって送信されます。このチャンクは、この状態で同一のフローごとのデータ謝辞塊に先行すべきです。"
    },
    {
      "indent": 3,
      "text": "This chunk is only allowed in a packet belonging to an established session and having packet mode 1 or 2.",
      "ja": "このチャンクはパケットのみ確立されたセッションに属するパケットモード1または2を有することを許可されています。"
    },
    {
      "indent": 3,
      "text": " 0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|      0x5e     |          chunkLength          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n+-------------/-+-------------/-+\n|   flowID    \\ |  exception  \\ |\n+-------------/-+-------------/-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct flowExceptionReportChunkPayload_t\n{\n    vlu_t flowID :variable*8;\n    vlu_t exception :variable*8;\n} :chunkLength*8;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "flowID: VLU, the flow identifier.",
      "ja": "フローID：VLU、フロー識別子。"
    },
    {
      "indent": 3,
      "text": "exception: VLU, the application-defined exception code being reported.",
      "ja": "例外：VLU、アプリケーション定義の例外コードが報告されています。"
    },
    {
      "indent": 3,
      "text": "A receiving RTMFP might reject a flow automatically, for example if it is missing metadata, or if an invalid return association is specified. In circumstances where an RTMFP rejects a flow automatically, the exception code MUST be 0. The application can specify any exception code, including 0, when rejecting a flow. All non-zero exception codes are reserved for the application.",
      "ja": "受信RTMFPは、メタデータが不足している場合など、自動的に流れを拒否、または無効なリターン協会が指定されている場合があります。アプリケーションフローを拒否するとき、0を含む任意の例外コードを指定することができ0 RTMFPが自動的にフローを拒否状況では、例外コードでなければなりません。すべてのゼロ以外の例外コードがアプリケーション用に予約されています。"
    },
    {
      "indent": 0,
      "text": "2.3.17. Session Close Request Chunk (Close)",
      "section_title": true,
      "ja": "2.3.17。セッションクローズリクエストチャンク（閉じます）"
    },
    {
      "indent": 3,
      "text": "This chunk is sent to cleanly terminate a session. It is only allowed in a packet belonging to an established or closing session and having packet mode 1 or 2.",
      "ja": "このチャンクはきれいにセッションを終了するために送信されます。これは、パケットのみ確立または閉じたセッションに属するパケットモード1または2を有することを許可されています。"
    },
    {
      "indent": 3,
      "text": " 0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|      0x0c     |               0               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This chunk has no payload.",
      "ja": "このチャンクは何のペイロードを持っていません。"
    },
    {
      "indent": 3,
      "text": "The use of Close is detailed in Section 3.5.5.",
      "ja": "閉じるの使用は、セクション3.5.5で詳述されます。"
    },
    {
      "indent": 0,
      "text": "2.3.18. Session Close Acknowledgement Chunk (Close Ack)",
      "section_title": true,
      "ja": "2.3.18。セッションを閉じる謝辞チャンク（クローズACK）"
    },
    {
      "indent": 3,
      "text": "This chunk is sent in response to a Session Close Request to indicate that the sender has terminated the session. It is only allowed in a packet belonging to an established or closing session and having packet mode 1 or 2.",
      "ja": "このチャンクは、送信者がセッションを終了したことを示すためにセッションを閉じる要求に応答して送信されます。これは、パケットのみ確立または閉じたセッションに属するパケットモード1または2を有することを許可されています。"
    },
    {
      "indent": 3,
      "text": " 0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|      0x4c     |               0               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This chunk has no payload.",
      "ja": "このチャンクは何のペイロードを持っていません。"
    },
    {
      "indent": 3,
      "text": "The use of Close Ack is detailed in Section 3.5.5.",
      "ja": "閉じるのAckの使用は、セクション3.5.5で詳述されます。"
    },
    {
      "indent": 0,
      "text": "3. Operation",
      "section_title": true,
      "ja": "3.操作"
    },
    {
      "indent": 0,
      "text": "3.1. Overview",
      "section_title": true,
      "ja": "3.1。概要"
    },
    {
      "indent": 14,
      "text": "+--------+                             +--------+\n| Peer A |        S E S S I O N        | Peer B |\n|        /=============================\\        |\n|       ||            Flows            ||       |\n|       ||---------------------------->||       |\n|       ||---------------------------->||       |\n|       ||<----------------------------||       |\n|       ||<----------------------------||       |\n|       ||<----------------------------||       |\n|        \\=============================/        |\n|        |                             |        |\n|        |                             +--------+\n|        |\n|        |                             +--------+\n|        |        S E S S I O N        | Peer C |\n|        /=============================\\        |\n|       ||            Flows            ||       |\n|       ||---------------------------->||       |\n|       ||<----------------------------||       |\n|       ||<----------------------------||       |\n|        \\=============================/        |\n|        |                             |        |\n+--------+                             +--------+",
      "raw": true
    },
    {
      "indent": 8,
      "text": "Figure 7: Sessions between Pairs of Communicating Endpoints",
      "ja": "図7：通信エンドポイントのペア間のセッション"
    },
    {
      "indent": 3,
      "text": "Between any pair of communicating endpoints is a single, bidirectional, secured, congestion controlled session. Unidirectional flows convey messages from one end to the other within the session.",
      "ja": "通信エンドポイントの任意のペア間の単一の、双方向、固定、輻輳制御セッションです。単方向フローは、セッション内の他の端から端までのメッセージを伝えます。"
    },
    {
      "indent": 3,
      "text": "An endpoint initiates a session to a far end when communication is desired. An initiator begins with one or more candidate destination socket addresses, and it may learn and try more candidate addresses during startup handshaking. Eventually, a first suitable response is received, and that endpoint is selected. Startup proceeds to the selected endpoint. In the case of session startup glare, one endpoint is the prevailing initiator and the other assumes the role of responder. Encryption keys and session identifiers are negotiated between the endpoints, and the session is established.",
      "ja": "通信が望まれるとき、エンドポイントは、遠端にセッションを開始します。イニシエータは、一の以上の候補先のソケットアドレスで始まり、それが起動ハンドシェーク中に複数の候補アドレスを学習してみてください。最終的には、まず適切な応答が受信され、そのエンドポイントが選択されます。スタートアップは、選択したエンドポイントに移行します。セッション起動グレアの場合、一方のエンドポイントがprevailingイニシエータであり、他方がレスポンダの役割を想定しています。暗号化鍵とセッション識別子は、エンドポイント間でネゴシエートされ、セッションが確立されています。"
    },
    {
      "indent": 3,
      "text": "Each endpoint may begin sending message flows to the other end. For each flow, the far end may accept it and deliver its messages to the user, or it may reject the flow and transmit an exception to the sender. The flow receiver may close and reject a flow at a later time, after first accepting it. The flow receiver acknowledges all data sent to it, regardless of whether the flow was accepted. Acknowledgements drive a congestion control mechanism.",
      "ja": "メッセージの送信を開始することができる各エンドポイントは、他方の端部へと流れます。各フローについて、遠端はそれを受け入れることができ、ユーザにそのメッセージを配信、またはそれが流れを拒否し、送信者に例外を送信してもよいです。フロー受信機は、最初にそれを受け入れた後、後で流れを閉じ、拒否することができます。フロー受信機は、フローが受け入れられたかどうかに関係なく、それに送られたすべてのデータを肯定応答します。謝辞は、輻輳制御機構を駆動します。"
    },
    {
      "indent": 3,
      "text": "An endpoint may have concurrent sessions with other far endpoints. The multiple sessions are distinguished by a session identifier rather than by socket address. This allows an endpoint's address to change mid-session without having to tear down and re-establish a session. The existing cryptographic state for a session can be used to verify a change of address while protecting against session hijacking or denial of service.",
      "ja": "エンドポイントは、他のこれまでのエンドポイントとの同時セッションを有することができます。複数のセッションは、セッション識別子ではなく、ソケットアドレスで区別されています。これは、エンドポイントのアドレスを取り壊すとのセッションを再確立することなく、半ばセッションを変更することができます。セッションの既存の暗号化状態は、セッションハイジャック又はサービスの拒否から保護しながら、アドレスの変更を確認するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "A sender may indicate to a receiver that some user messages are of a time critical or real-time nature. A receiver may indicate to senders on concurrent sessions that it is receiving time critical messages from another endpoint. The other senders SHOULD modify their congestion control parameters to yield capacity to the session carrying time critical messages.",
      "ja": "送信者は、一部のユーザーのメッセージがタイムクリティカルまたはリアルタイムの性質のものであることを受信機に示すことができます。受信機は、それが別のエンドポイントからの時間重要なメッセージを受信して​​いる同時セッションの送信者に示すことができます。他の送信者は、タイムクリティカルなメッセージを運ぶセッションに容量を得るために彼らの輻輳制御パラメータを変更する必要があります。"
    },
    {
      "indent": 3,
      "text": "A sender may close a flow. The flow is completed when the receiver has no outstanding gaps before the final fragment of the flow. The sender and receiver reserve a completed flow's identifier for a time to allow in-flight messages to drain from the network.",
      "ja": "送信者は、流れを閉じることができます。受信機は、フローの最後の断片の前に未処理のギャップを持っていない場合、フローは終了します。送信者と受信者は、飛行中のメッセージがネットワークから排出させるための時間で完了フローの識別子を予約します。"
    },
    {
      "indent": 3,
      "text": "Eventually, neither end will have any flows open to the other. The session will be idle and quiescent. Either end may reliably close the session to recover its resources.",
      "ja": "結局、どちらの終わりには、他に開いているすべてのフローを持つことになります。セッションがアイドル状態と休止状態になります。どちらの終わりには、確実にそのリソースを回復するために、セッションを閉じることができます。"
    },
    {
      "indent": 3,
      "text": "In certain circumstances, an endpoint may be ceasing operation and not have time to wait for acknowledgement of a reliable session close. In this case, the halting endpoint may send an abrupt session close to advise the far end that it is halting immediately.",
      "ja": "特定の状況では、エンドポイントは、運転を停止し、信頼性の高いセッションクローズの確認応答を待機する時間を持っていなくても良いです。この場合、停止エンドポイントは、それが即座に停止される遠端に助言するために近くに突然のセッションを送信することができます。"
    },
    {
      "indent": 0,
      "text": "3.2. Endpoint Identity",
      "section_title": true,
      "ja": "3.2。エンドポイントのアイデンティティ"
    },
    {
      "indent": 3,
      "text": "Each RTMFP endpoint has an identity. The identity is encoded in a certificate. This specification doesn't mandate any particular certificate format, cryptographic algorithms, or cryptographic properties for certificates.",
      "ja": "各RTMFPエンドポイントは、同一性を有します。アイデンティティは、証明書にエンコードされています。この仕様は、証明書のいずれかの特定の証明書形式、暗号化アルゴリズム、または暗号化プロパティを強制しません。"
    },
    {
      "indent": 3,
      "text": "An endpoint is named by an Endpoint Discriminator. This specification doesn't mandate any particular format for Endpoint Discriminators.",
      "ja": "エンドポイントは、エンドポイント識別子によって命名されます。この仕様は、エンドポイントディスクリミネータのための特定のフォーマットを規定していません。"
    },
    {
      "indent": 3,
      "text": "An Endpoint Discriminator MAY select more than one identity and MAY match more than one distinct certificate.",
      "ja": "エンドポイント識別子は、複数のIDを選択することと、複数の異なる証明書を一致させることができます。"
    },
    {
      "indent": 3,
      "text": "Multiple distinct Endpoint Discriminators MAY match one certificate.",
      "ja": "複数の異なるエンドポイントディスクリミネータは、1証明書を一致させることができます。"
    },
    {
      "indent": 3,
      "text": "It is RECOMMENDED that multiple endpoints not have the same identity. Entities with the same identity are indistinguishable during session startup; this situation could be undesirable in some applications.",
      "ja": "複数のエンドポイントが同じIDを持っていないことが推奨されます。同じIDを持つエンティティは、セッションの起動時に見分けがつきません。このような状況は、いくつかの用途では望ましくない可能性があります。"
    },
    {
      "indent": 3,
      "text": "An endpoint MAY have more than one address.",
      "ja": "エンドポイントは、複数のアドレスを持っているかもしれません。"
    },
    {
      "indent": 3,
      "text": "The Cryptography Profile implements the following functions for identities, certificates, and Endpoint Discriminators, whose operation MUST be deterministic:",
      "ja": "暗号化プロファイルは、操作決定論的でなければならないのアイデンティティ、証明書、およびエンドポイントディスクリミネータ、について以下の機能を実装しています。"
    },
    {
      "indent": 3,
      "text": "o Test whether a given certificate is authentic. Authenticity can comprise verifying an issuer signature chain in a public key infrastructure.",
      "ja": "O指定された証明書が本物であるかどうかをテストします。真正性は、公開鍵インフラストラクチャに発行者の署名チェーンを検証することを含むことができます。"
    },
    {
      "indent": 3,
      "text": "o Test whether a given Endpoint Discriminator selects a given certificate.",
      "ja": "所与のエンドポイント識別子が指定された証明書を選択するかどうかをテストし、O。"
    },
    {
      "indent": 3,
      "text": "o Test whether a given Endpoint Discriminator selects the local endpoint.",
      "ja": "所与のエンドポイント識別子は、ローカルエンドポイントを選択するかどうかをテストし、O。"
    },
    {
      "indent": 3,
      "text": "o Generate a Canonical Endpoint Discriminator for a given certificate. Canonical Endpoint Discriminators for distinct identities SHOULD be distinct. If two distinct identities have the same Canonical Endpoint Discriminator, an initiator might abort a new opening session to the second identity (Section 3.5.1.1.1); this behavior might not be desirable.",
      "ja": "O指定された証明書のための正規エンドポイント識別子を生成します。明確なアイデンティティのための正規のエンドポイントディスクリミネータは明瞭であるべきです。二つの異なるアイデンティティが同じ正規エンドポイント識別子を使用している場合、イニシエータは、第二のアイデンティティ（セクション3.5.1.1.1）への新しいオープニングセッションを中止するかもしれません。この動作は望ましくない場合があります。"
    },
    {
      "indent": 3,
      "text": "o Given a certificate, a message, and a digital signature over the message, test whether the signature is valid and generated by the owner of the certificate.",
      "ja": "O証明書、メッセージ、およびメッセージ上のデジタル署名を考えると、署名が有効と証明書の所有者によって生成されるかどうかをテストします。"
    },
    {
      "indent": 3,
      "text": "o Generate a digital signature for a given message corresponding to the near identity.",
      "ja": "O周辺のアイデンティティに対応する与えられたメッセージのデジタル署名を生成します。"
    },
    {
      "indent": 3,
      "text": "o Given the near identity and a far certificate, determine which one shall prevail as Initiator and which shall assume the Responder role in the case of startup glare. The far end MUST arrive at the same conclusion. A comparison function can comprise performing a lexicographic ordering of the binary certificates, declaring the far identity the prevailing endpoint if the far certificate is ordered before the near certificate, and otherwise declaring the near identity to be the prevailing endpoint.",
      "ja": "O近くのアイデンティティと遠く証明書を考えると、1がイニシエータとして優先するものとされ、起動グレアの場合、レスポンダの役割を負うかを決定します。遠端は同じ結論に到着しなければなりません。比較関数は、はるかに証明書が近い証明書の前に注文された場合にこれまでのアイデンティティに有力なエンドポイントを宣言し、それ以外の場合は現行のエンドポイントであることを近くのアイデンティティを宣言し、バイナリ証明書の辞書式順序付けを行うことを含むことができます。"
    },
    {
      "indent": 3,
      "text": "o Given a first certificate and a second certificate, test whether a new incoming session from the second shall override an existing session with the first. It is RECOMMENDED that the test comprise testing whether the certificates are bitwise identical.",
      "ja": "O最初の証明書と第二の証明書を考えると、第二の新しい着信セッションが最初との既存のセッションを無効にするものかどうかをテストします。テスト証明書は、同一のビット単位されているかどうかをテストすることを含むことが推奨されます。"
    },
    {
      "indent": 3,
      "text": "All other semantics for certificates and Endpoint Discriminators are determined by the Cryptography Profile and the application.",
      "ja": "証明書およびエンドポイントディスクリミネータのための他のすべてのセマンティクスは暗号プロファイルおよびアプリケーションによって決定されます。"
    },
    {
      "indent": 0,
      "text": "3.3. Packet Multiplex",
      "section_title": true,
      "ja": "3.3。パケット多重"
    },
    {
      "indent": 3,
      "text": "An RTMFP typically has one or more interfaces through which it communicates with other RTMFP endpoints. RTMFP can communicate with multiple distinct other RTMFP endpoints through each local interface. Session multiplexing over a shared interface can facilitate peer-to-peer communications through a NAT, by enabling third-party endpoints such as Forwarders (Section 3.5.1.5) and Redirectors (Section 3.5.1.4) to observe the translated public address and inform peers of the translation.",
      "ja": "RTMFPは、典型的には、それが他のRTMFPエンドポイントと通信する1つまたは複数のインターフェイスを有しています。 RTMFPは、各ローカルインタフェースを介して複数の異なる他のRTMFPエンドポイントと通信することができます。共有インターフェース上のセッション多重化は、（セクション3.5.1.4）は、翻訳パブリックアドレスを観察し、ピアに通知する（セクション3.5.1.5）とリダイレクタフォワーダとしてサードパーティのエンドポイントを有効にすることによって、NATを介してピア・ツー・ピア通信を容易にすることができます翻訳の。"
    },
    {
      "indent": 3,
      "text": "An interface is typically a UDP socket (Section 2.2.1) but MAY be any suitable datagram transport service where endpoints can be addressed by IPv4 or IPv6 socket addresses.",
      "ja": "インターフェースは、典型的には、UDPソケット（セクション2.2.1）であるが、エンドポイントがIPv4またはIPv6のソケット・アドレスによってアドレス指定することができる任意の適切なデータグラム輸送サービスとすることができます。"
    },
    {
      "indent": 3,
      "text": "RTMFP uses a session ID to multiplex and demultiplex communications with distinct endpoints (Section 2.2.2), in addition to the endpoint socket address. This allows an RTMFP to detect a far-end address change (as might happen, for example, in mobile and wireless scenarios) and allows communication sessions to survive address changes. This also allows an RTMFP to act as a Forwarder or Redirector for an endpoint with which it has an active session, by distinguishing startup packets from those of the active session.",
      "ja": "RTMFPは、エンドポイントのソケットアドレスに加えて、異なるエンドポイント（セクション2.2.2）との通信を多重化及び逆多重化するために、セッションIDを使用します。これは、（モバイルおよびワイヤレスのシナリオでは、例えば、発生する可能性があります）RTMFPは、遠端アドレスの変更を検出することを可能にし、通信セッションは、アドレスの変更を生き残ることができます。これはまた、RTMFPは、それがアクティブセッションのものから起動パケットを区別することによって、アクティブなセッションを有するとエンドポイントのフォワーダまたはリダイレクタとして作用することを可能にします。"
    },
    {
      "indent": 3,
      "text": "On receiving a packet, an RTMFP decodes the session ID to look up the corresponding session information context and decryption key. Session ID 0 is reserved for session startup and MUST NOT be used for an active session. A packet for Session ID 0 uses the Default Session Key as defined by the Cryptography Profile.",
      "ja": "パケットを受信すると、RTMFPは、対応するセッション情報のコンテキストと復号鍵をルックアップするためにセッションIDをデコードします。セッションID 0は、セッション起動のために予約されており、アクティブなセッションのために使用してはいけません。セッションID 0のためのパケットが暗号化プロファイルで定義されたデフォルトのセッションキーを使用しています。"
    },
    {
      "indent": 0,
      "text": "3.4. Packet Fragmentation",
      "section_title": true,
      "ja": "3.4。パケットの断片"
    },
    {
      "indent": 3,
      "text": "When an RTMFP packet (Section 2.2.4) is unavoidably larger than the path MTU (such as a startup packet containing an RHello (Section 2.3.4) or IIKeying (Section 2.3.7) chunk with a large certificate), it can be fragmented into segments that do not exceed the path MTU by using the Packet Fragment chunk (Section 2.3.1).",
      "ja": "RTMFPパケット（セクション2.2.4）（例えばRHello（セクション2.3.4）またはIIKeying（セクション2.3.7）大きい証明書を使用してチャンクを含むスタートアップ・パケットのような）パスMTUよりも不可避的に大きい場合、それはすることができパケットの断片化のチャンク（2.3.1）を使用してパスMTUを超えないセグメントに断片化。"
    },
    {
      "indent": 3,
      "text": "The packet fragmentation mechanism SHOULD be used only to segment unavoidably large packets. Accordingly, this mechanism SHOULD be employed only during session startup with Session ID 0. This mechanism MUST NOT be used instead of the natural fragmentation mechanism of the User Data (Section 2.3.11) and Next User Data (Section 2.3.12) chunks for dividing the messages of the user's data flows into segments that do not exceed the path MTU.",
      "ja": "パケットの断片化機構は、セグメント不可避大きなパケットにのみ使用されるべきです。従って、このメカニズムは、セッションID 0とのセッションの起動時にのみ、このメカニズムを使用されるべきである代わりに、ユーザデータの天然の断片化機構（セクション2.3.11）、次のユーザデータ（セクション2.3.12）のチャンクのための使用してはいけませんユーザデータのメッセージを分割すると、パスMTUを超えていないセグメントに流れます。"
    },
    {
      "indent": 3,
      "text": "A fragmented plain RTMFP packet is reassembled by concatenating the packetFragment fields of the fragments for the packet in contiguous ascending order, starting from index 0 through and including the final fragment.",
      "ja": "断片化された無地RTMFPパケットは、連続昇順でパケットのフラグメントのpacketFragmentフィールドを連結することを介して、インデックス0から開始し、最終的な断片を含むことによって再組み立てされます。"
    },
    {
      "indent": 3,
      "text": "When reassembling packets for Session ID 0, a receiver SHOULD identify the packets by the socket address from which the packet containing the fragment was received, as well as the indicated packetID.",
      "ja": "セッションID 0のパケットを再組み立てするとき、受信機は、断片を含むパケットが受信されたソケットアドレス、ならびに指示packetIDによってパケットを識別すべきです。"
    },
    {
      "indent": 3,
      "text": "A receiver SHOULD allow up to 60 seconds to completely receive a fragmented packet for which progress is being made. A packet is progressing if at least one new fragment for it was received in the last second.",
      "ja": "受信機は、完全に進歩が行われているフラグメントパケットを受信するために60秒まで可能にすべきです。それのための少なくとも1つの新しいフラグメントが最後の1秒に受信された場合、パケットが進んでいます。"
    },
    {
      "indent": 3,
      "text": "A receiver MUST discard a Packet Fragment chunk having an empty packetFragment field.",
      "ja": "受信機は、空packetFragmentフィールドを有するパケットフラグメントチャンクを捨てなければなりません。"
    },
    {
      "indent": 3,
      "text": "The mode of each packet containing Packet Fragments for the same fragmented packet MUST match the mode of the fragmented packet. A receiver MUST discard any new Packet Fragment chunk received in a packet with a mode different from the mode of the packet containing the first received fragment. A receiver MUST discard any reassembled packet with a mode different than the packets containing its fragments.",
      "ja": "同じフラグメントパケットのためのパケット断片を含む各パケットのモードは、断片化されたパケットのモードと一致しなければなりません。受信機は、最初に受信したフラグメントを含むパケットのモードとは異なるモードのパケットで受信された任意の新しいパケットフラグメントチャンクを捨てなければなりません。受信機は、そのフラグメントを含むパケットとは異なるモードを有する任意の再構成されたパケットを破棄しなければなりません。"
    },
    {
      "indent": 3,
      "text": "In order to avoid jamming the network, the sender MUST rate limit packet transmission. In the absence of specific path capacity information (for instance, during session startup), a sender SHOULD NOT send more than 4380 bytes nor more than four packets per distinct endpoint every 200 ms.",
      "ja": "ネットワークを妨害避けるために、送信者は、リミットパケット伝送を評価しなければなりません。 （例えば、セッションの起動時に）特定のパス能力情報がない場合、送信者は、以上の4380のバイトもの別個のエンドポイントごとに複数の4つのパケット毎に200ミリ秒を送るべきではありません。"
    },
    {
      "indent": 3,
      "text": "To avoid resource exhaustion, a receiver SHOULD limit the number of concurrent packet reassembly buffers and the size of each buffer. Limits can depend, for example, on the expected size of reassembled packets, on the rate at which fragmented packets are expected to be received, on the expected degree of interleaving, and on the expected function of the receiver. Limits can depend on the available resources of the receiver. There can be different limits for packets with Session ID 0 and packets for established sessions. For example, a busy server might need to allow for several hundred concurrent packet reassembly buffers to accommodate hundreds of connection requests per second with potentially interleaved fragments, but a client device with constrained resources could allow just a few reassembly buffers. In the absence of specific information regarding the expected size of reassembled packets, a receiver should set the limit for each packet reassembly buffer to 65536 bytes.",
      "ja": "リソースの枯渇を回避するために、受信機は、同時パケット再アセンブリ・バッファの数と各バッファのサイズを制限する必要があります。制限は断片化されたパケットをインターリーブの期待度に、受信されることが期待される速度で、再組み立てされたパケットの予想されるサイズに、例えば、依存し、受信機の予想される機能にすることができます。制限は、受信機の利用可能なリソースに依存することができます。確立されたセッションのセッションIDが0のパケットとパケットごとに異なる制限がある場合もあります。例えば、ビジー状態のサーバは、潜在的にインターリーブ断片毎秒接続要求の数百人を収容するための数百の同時パケットの再構成バッファを可能にする必要があるかもしれませんが、制約のリソースを持つクライアントデバイスは、わずか数再組み立てバッファを可能性があります。再組み立てされたパケットの予想されるサイズに関する特定の情報がない場合、受信機は、65536バイトの各パケットの再組み立てバッファの制限を設定すべきです。"
    },
    {
      "indent": 0,
      "text": "3.5. Sessions",
      "section_title": true,
      "ja": "3.5。セッション"
    },
    {
      "indent": 3,
      "text": "A session is the protocol relationship between a pair of communicating endpoints, comprising the shared and endpoint-specific information context necessary to carry out the communication. The session context at each end includes at least:",
      "ja": "セッションは、エンドポイントを連通信を行うために必要な共有およびエンドポイント固有の情報コンテキストを含む一対の間のプロトコルの関係です。各端部セッションコンテキストを少なくとも含みます。"
    },
    {
      "indent": 3,
      "text": "o TS_RX: the last timestamp received from the far end;",
      "ja": "O TS_RX：遠端から受信した最後のタイムスタンプ。"
    },
    {
      "indent": 3,
      "text": "o TS_RX_TIME: the time at which TS_RX was first observed to be different than its previous value;",
      "ja": "O TS_RX_TIME：TS_RXは最初の前の値とは異なることが観察された時間。"
    },
    {
      "indent": 3,
      "text": "o TS_ECHO_TX: the last timestamp echo sent to the far end;",
      "ja": "O TS_ECHO_TX：最後のタイムスタンプは、遠端に送信されたエコー。"
    },
    {
      "indent": 3,
      "text": "o MRTO: the measured retransmission timeout;",
      "ja": "O MRTO：測定された再送タイムアウト。"
    },
    {
      "indent": 3,
      "text": "o ERTO: the effective retransmission timeout;",
      "ja": "ERTO○：効果的な再送タイムアウト。"
    },
    {
      "indent": 3,
      "text": "o Cryptographic keys for encrypting and decrypting packets, and for verifying the validity of packets, according to the Cryptography Profile;",
      "ja": "パケットの暗号化及び復号化するための、および暗号化プロファイルに従って、パケットの正当性を検証するためのO暗号鍵。"
    },
    {
      "indent": 3,
      "text": "o Cryptographic near and far nonces according to the Cryptography Profile, where the near nonce is the far end's far nonce, and vice versa;",
      "ja": "O暗号遠近ナンス周辺nonceが遠端の遠ノンスである暗号化プロファイル、およびその逆に係ります。"
    },
    {
      "indent": 3,
      "text": "o The certificate of the far end;",
      "ja": "遠端の証明書O;"
    },
    {
      "indent": 3,
      "text": "o The receive session identifier, used by the far end when sending packets to this end;",
      "ja": "この目的のためにパケットを送信するとき、遠端で使用される受信セッション識別子、O。"
    },
    {
      "indent": 3,
      "text": "o The send session identifier to use when sending packets to the far end;",
      "ja": "遠端にパケットを送信するときに使用する送信セッション識別子O;"
    },
    {
      "indent": 3,
      "text": "o DESTADDR: the destination socket address to use when sending packets to the far end;",
      "ja": "O DESTADDR：遠端にパケットを送信するときに使用する先のソケットアドレス。"
    },
    {
      "indent": 3,
      "text": "o The set of all sending flow contexts (Section 3.6.2);",
      "ja": "すべての送信フローの状況（3.6.2項）のセットO;"
    },
    {
      "indent": 3,
      "text": "o The set of all receiving flow contexts (Section 3.6.3);",
      "ja": "O全ての受信フローコンテキスト（セクション3.6.3）のセット。"
    },
    {
      "indent": 3,
      "text": "o The transmission budget, which controls the rate at which data is sent into the network (for example, a congestion window);",
      "ja": "データは、（例えば、輻輳ウィンドウ）ネットワークに送信される速度を制御する送信予算、O。"
    },
    {
      "indent": 3,
      "text": "o S_OUTSTANDING_BYTES: the total amount of user message data outstanding, or in flight, in the network -- that is, the sum of the F_OUTSTANDING_BYTES of each sending flow in the session;",
      "ja": "O S_OUTSTANDING_BYTES：ユーザメッセージデータの合計量発行済、または飛行中、ネットワークに - つまり、セッション内の各送信フローのF_OUTSTANDING_BYTESの和。"
    },
    {
      "indent": 3,
      "text": "o RX_DATA_PACKETS: a count of the number of received packets containing at least one User Data chunk since the last acknowledgement was sent, initially 0;",
      "ja": "RX_DATA_PACKETS O：最初に少なくとも一つのユーザーデータチャンクを含む受信パケットの数のカウント最後の確認応答が送信されたので、0。"
    },
    {
      "indent": 3,
      "text": "o ACK_NOW: a boolean flag indicating whether an acknowledgement should be sent immediately, initially false;",
      "ja": "O ACK_NOW：肯定応答が偽最初に、すぐに送信されるべきかどうかを示すブールフラグ。"
    },
    {
      "indent": 3,
      "text": "o DELACK_ALARM: an alarm to trigger an acknowledgement after a delay, initially unset;",
      "ja": "O DELACK_ALARM：遅延の後に確認応答をトリガするアラーム、当初は未設定。"
    },
    {
      "indent": 3,
      "text": "o The state, at any time being one of the following values: the opening states S_IHELLO_SENT and S_KEYING_SENT, the open state S_OPEN, the closing states S_NEARCLOSE and S_FARCLOSE_LINGER, and the closed states S_CLOSED and S_OPEN_FAILED; and",
      "ja": "O状態は、次の値のいずれかである任意の時点で：開口部はS_IHELLO_SENTとS_KEYING_SENT、開状態S_OPEN、閉鎖状態がS_NEARCLOSEとS_FARCLOSE_LINGER、及び閉状態S_CLOSEDとS_OPEN_FAILED述べて。そして"
    },
    {
      "indent": 3,
      "text": "o The role -- either Initiator or Responder -- of this end of the session.",
      "ja": "イニシエータまたはレスポンダのどちらか -   - セッションのこの終わりの役割O。"
    },
    {
      "indent": 3,
      "text": "Note: The following diagram is only a summary of state transitions and their causing events, and is not a complete operational specification.",
      "ja": "注意：以下の図は、状態遷移とその原因となるイベントの概要だけで、完全な動作仕様ではありません。"
    },
    {
      "indent": 8,
      "text": "  rcv IIKeying Glare\n  far prevails +-------------+   ultimate open timeout\n+--------------|S_IHELLO_SENT|-------------+\n|              +-------------+             |\n|                     |rcv RHello          |\n|                     |                    v\n|                     v             +-------------+\n|<-----------(duplicate session?)   |S_OPEN_FAILED|\n|         yes         |no           +-------------+\n|                     |                    ^\n| rcv IIKeying Glare  v                    |\n| far prevails +-------------+             |\n|<-------------|S_KEYING_SENT|-------------+\n|              +-------------+   ultimate open timeout\n|                     |rcv RIKeying\n|                     |\n|       rcv           v\n|   +-+ IIKeying  +--------+ rcv Close Request\n|   |X|---------->| S_OPEN |--------------------+\n|   +-+           +--------+                    |\n|                   |    |ABRUPT CLOSE          |\n|      ORDERLY CLOSE|    |or rcv Close Ack      |\n|                   |    |or rcv IIKeying       |\n|                   |    |   session override   |\n|                   |    +-------+              |\n|                   v            |              v\n|             +-----------+      |     +-----------------+\n|             |S_NEARCLOSE|      |     |S_FARCLOSE_LINGER|\n|             +-----------+      |     +-----------------+\n|      rcv Close Ack|            |              |rcv Close Ack\n|      or 90 seconds|            v              |or 19 seconds\n|                   |       +--------+          |\n|                   +------>|S_CLOSED|<---------+\n+-------------------------->|        |\n                            +--------+",
      "raw": true
    },
    {
      "indent": 22,
      "text": "Figure 8: Session State Diagram",
      "ja": "図8：セッション状態図"
    },
    {
      "indent": 0,
      "text": "3.5.1. Startup",
      "section_title": true,
      "ja": "3.5.1。起動"
    },
    {
      "indent": 0,
      "text": "3.5.1.1. Normal Handshake",
      "section_title": true,
      "ja": "3.5.1.1。通常のハンドシェイク"
    },
    {
      "indent": 3,
      "text": "RTMFP sessions are established with a 4-way handshake in two round trips. The initiator begins by sending an IHello to one or more candidate addresses for the desired destination endpoint. A responder statelessly sends an RHello in response. The first correct RHello received at the initiator is selected; all others are ignored. The initiator computes its half of the session keying and sends an IIKeying. The responder receives the IIKeying and, if it is acceptable, computes its half of the session keying, at which point it can also compute the shared session keying and session nonces. The responder creates a new S_OPEN session with the initiator and sends an RIKeying. The initiator receives the RIKeying and, if it is acceptable, computes the shared session keying and session nonces. The initiator's session is now S_OPEN.",
      "ja": "RTMFPセッションは2回の往復で4ウェイハンドシェイクで確立されています。開始剤は、所望の宛先エンドポイントのための1つまたは複数の候補アドレスにIHelloを送信することによって始まります。応答者は、ステートレスに応じてRHelloを送信します。最初の正しいRHelloが選択されているイニシエータで受信しました。他のすべては無視されます。イニシエータは、セッションキーのその半分を計算しIIKeyingを送信します。それが許容される場合、レスポンダは、IIKeyingを受信し、それはまた、共有セッションキーとセッションナンスを計算することができ、その時点で、セッションキーのその半分を計算します。レスポンダは、イニシエータで新しいS_OPENセッションを作成し、RIKeyingを送信します。イニシエータはRIKeyingを受信し、それが許容される場合、共有セッションキーとセッションナンスを計算します。イニシエータのセッションは今S_OPENです。"
    },
    {
      "indent": 8,
      "text": ".     Initiator                                Responder     .\n              | IHello                         |\n              |(EPD,Tag)                       |\nS_IHELLO_SENT |(SID=0)                         |\n              |------------------------------->|\n              |                                |\n              |                         RHello |\n              |              (Tag,Cookie,RCert)|\n              |                         (SID=0)|\n              |<-------------------------------|\nS_KEYING_SENT |                                |\n              | IIKeying                       |\n              |(ISID,Cookie,ICert,SKIC,ISig)   |\n              |(SID=0)                         |\n              |------------------------------->|\n              |                                |\n              |                       RIKeying |\n              |                (RSID,SKRC,RSig)|\n              |          (SID=ISID,Key=Default)| S_OPEN\n              |<-------------------------------|\n       S_OPEN |                                |\n              |          S E S S I O N         |\n              |<-------------------(SID=ISID)--|\n              |--(SID=RSID)------------------->|",
      "raw": true
    },
    {
      "indent": 24,
      "text": "Figure 9: Normal Handshake",
      "ja": "図9：通常のハンドシェイク"
    },
    {
      "indent": 3,
      "text": "In the following sections, the handshake is detailed from the perspectives of the initiator and responder.",
      "ja": "以下のセクションでは、ハンドシェークは、イニシエータとレスポンダーの観点から詳細に説明します。"
    },
    {
      "indent": 0,
      "text": "3.5.1.1.1. Initiator",
      "section_title": true,
      "ja": "3.5.1.1.1。イニシエータ"
    },
    {
      "indent": 3,
      "text": "The initiator determines that a session is needed for an Endpoint Discriminator. The initiator creates state for a new opening session and begins with a candidate endpoint address set containing at least one address. The new session is placed in the S_IHELLO_SENT state.",
      "ja": "イニシエータは、セッションがエンドポイント識別子のために必要であると判断します。イニシエータは、新しいオープニングセッションの状態を作成し、少なくとも1つのアドレスを含む候補エンドポイントアドレスのセットから始まります。新しいセッションがS_IHELLO_SENT状態に置かれています。"
    },
    {
      "indent": 3,
      "text": "If the session does not move to the S_OPEN state before an ultimate open timeout, the session has failed and moves to the S_OPEN_FAILED state. The RECOMMENDED ultimate open timeout is 95 seconds.",
      "ja": "セッションが究極のオープンタイムアウト前S_OPEN状態に移動できない場合、セッションは失敗したとS_OPEN_FAILED状態に移行しました。推奨究極のオープンタイムアウトは95秒です。"
    },
    {
      "indent": 3,
      "text": "The initiator chooses a new, unique tag not used by any currently opening session. It is RECOMMENDED that the tag be cryptographically pseudorandom and be at least 8 bytes in length, so that it is hard to guess. The initiator constructs an IHello chunk (Section 2.3.2) with the Endpoint Discriminator and the tag.",
      "ja": "イニシエータは、任意の現在開くセッションで使用されていない新しい、ユニークなタグを選択します。タグが暗号擬似ランダムであっても、推測しにくいように、長さが少なくとも8バイトであることが推奨されます。イニシエータは、エンドポイント識別子とタグとIHelloチャンク（2.3.2項）を構築します。"
    },
    {
      "indent": 3,
      "text": "While the initiator is in the S_IHELLO_SENT state, it sends the IHello to each candidate endpoint address in the set, on a backoff schedule. The backoff SHOULD NOT be less than multiplicative, with not less than 1.5 seconds added to the interval between each attempt. The backoff SHOULD be scheduled separately for each candidate address, since new candidates can be added over time.",
      "ja": "イニシエータはS_IHELLO_SENT状態にある間、それはバックオフスケジュールで、セット内の各候補エンドポイントアドレスにIHelloを送信します。バックオフは、各試行間の間隔に追加されていない以下1.5秒以上で、乗法未満すべきではありません。新しい候補者が時間をかけて追加することができるので、バックオフは、各候補アドレスに対して個別にスケジュールする必要があります。"
    },
    {
      "indent": 3,
      "text": "If the initiator receives a Redirect chunk (Section 2.3.5) with a tag echo matching this session, AND this session is in the S_IHELLO_SENT state, then for each redirect destination indicated in the Redirect: if the candidate endpoint address set contains fewer than REDIRECT_THRESHOLD addresses, add the indicated redirect destination to the candidate endpoint address set. REDIRECT_THRESHOLD SHOULD NOT be more than 24.",
      "ja": "イニシエータは、このセッションに一致するエコータグと（セクション2.3.5）リダイレクトチャンクを受信し、このセッションがS_IHELLO_SENT状態である場合、各リダイレクトに示されている宛先をリダイレクトするための：候補エンドポイントアドレスセットがREDIRECT_THRESHOLDより少ないが含まれている場合アドレスは、候補エンドポイントアドレスのセットに示されたリダイレクト先を追加します。 REDIRECT_THRESHOLDは24以上すべきではありません。"
    },
    {
      "indent": 3,
      "text": "If the initiator receives an RHello chunk (Section 2.3.4) with a tag echo matching this session, AND this session is in the S_IHELLO_SENT state, AND the responder certificate matches the desired Endpoint Discriminator, AND the certificate is authentic according to the Cryptography Profile, then:",
      "ja": "イニシエータは、このセッションに一致するタグエコーとRHelloチャンク（2.3.4項）を受信し、このセッションはS_IHELLO_SENT状態であり、レスポンダの証明書は、所望のエンドポイント識別子と一致し、証明書は暗号化プロファイルに従って真正である場合に、そして："
    },
    {
      "indent": 3,
      "text": "1. If the Canonical Endpoint Discriminator for the responder certificate matches the Canonical Endpoint Discriminator of another existing session in the S_KEYING_SENT or S_OPEN states, AND the certificate of the other opening session matches the desired Endpoint Discriminator, then this session is a duplicate and SHOULD be aborted in favor of the other existing session; otherwise,",
      "ja": "1.レスポンダ証明書の正規エンドポイント識別子がS_KEYING_SENT又はS_OPEN状態で別の既存のセッションの標準エンドポイント識別子と一致し、他方の開口セッションの証明書は、所望のエンドポイント識別子と一致する場合、このセッションが重複してすべきであり他の既存のセッションの賛成で中止され、そうでなければ、"
    },
    {
      "indent": 3,
      "text": "2. Move to the S_KEYING_SENT state. Set DESTADDR, the far-end address for the session, to the address from which this RHello was received. The initiator chooses a new, unique receive session ID, not used by any other session, for the responder to use when sending packets to the initiator. It computes a Session Key Initiator Component appropriate to the responder's certificate according to the Cryptography Profile. Using this data and the cookie from the RHello, the initiator constructs and signs an IIKeying chunk (Section 2.3.7).",
      "ja": "S_KEYING_SENT状態に2.移動します。このRHelloを受信したアドレスを、DESTADDR、セッションのための遠端アドレスを設定します。イニシエータは、イニシエータにパケットを送信するときに使用する応答者のためではなく、他のセッションで使用される新しい、ユニークな受信セッションIDを、選択します。これは、暗号化プロファイルに応じた応答者の証明書にセッションキーイニシエータコンポーネントの適切なを計算します。このデータとRHello、イニシエータ構築物および標識IIKeyingチャンク（セクション2.3.7）からクッキーを使用して。"
    },
    {
      "indent": 3,
      "text": "While the initiator is in the S_KEYING_SENT state, it sends the IIKeying to DESTADDR on a backoff schedule. The backoff SHOULD NOT be less than multiplicative, with not less than 1.5 seconds added to the interval between each attempt.",
      "ja": "イニシエータはS_KEYING_SENT状態にあるが、それはバックオフスケジュールでDESTADDRにIIKeyingを送信します。バックオフは、各試行間の間隔に追加されていない以下1.5秒以上で、乗法未満すべきではありません。"
    },
    {
      "indent": 3,
      "text": "If the initiator receives an RIKeying chunk (Section 2.3.8) in a packet with this session's receive session identifier, AND this session is in the S_KEYING_SENT state, AND the signature in the chunk is authentic according to the far end's certificate (from the RHello), AND the Session Key Responder Component successfully combines with the Session Key Initiator Component and the near and far certificates to form the shared session keys and nonces according to the Cryptography Profile, then the session has opened successfully. The session moves to the S_OPEN state. The send session identifier is set from the RIKeying. Packet encryption, decryption, and verification now use the newly computed shared session keys, and the session nonces are available for application-layer cryptographic challenges.",
      "ja": "イニシエータは、このセッションのセッション識別子を受信し、このセッションがS_KEYING_SENT状態であり、チャンク内の署名がRHelloから（遠端の証明書によれば本物であるとパケットにRIKeyingチャンク（セクション2.3.8）を受信した場合）、およびセッションキーレスポンダコンポーネントが正常に暗号化プロファイルに従って、共有セッション鍵とナンスを形成するためにセッションキーイニシエータコンポーネントと近くと遠くの証明書と結合し、その後、セッションが正常にオープンしました。セッションはS_OPEN状態に移行します。送信セッション識別子はRIKeyingから設定されています。パケットの暗号化、復号化、および検証は今、新たに計算された共有セッションキーを使用して、セッションナンスは、アプリケーション層の暗号化の課題のために用意されています。"
    },
    {
      "indent": 0,
      "text": "3.5.1.1.2. Responder",
      "section_title": true,
      "ja": "3.5.1.1.2。答え"
    },
    {
      "indent": 3,
      "text": "On receipt of an IHello chunk (Section 2.3.2) with an Endpoint Discriminator that selects its identity, an endpoint SHOULD construct an RHello chunk (Section 2.3.4) and send it to the address from which the IHello was received. To avoid a potential resource exhaustion denial of service, the endpoint SHOULD NOT create any persistent state associated with the IHello. The endpoint MUST generate the cookie for the RHello in such a way that it can be recognized as authentic and valid when echoed in an IIKeying. The endpoint SHOULD use the address from which the IHello was received as part of the cookie generation formula. Cookies SHOULD be valid only for a limited time; that lifetime SHOULD NOT be less than 95 seconds (the recommended ultimate session open timeout).",
      "ja": "そのアイデンティティーを選択するエンドポイント識別子とIHelloチャンク（セクション2.3.2）の受信時に、エンドポイントはRHelloチャンク（2.3.4項）を構築すべきであり、IHelloが受信されたアドレスに送信します。サービスの潜在的な資源枯渇の拒否を回避するために、エンドポイントはIHelloに関連するすべての永続的な状態を作成しないでください。エンドポイントはIIKeyingにこだましたときに、それは本物と有効なものとして認識できるようにRHelloのCookieを生成しなければなりません。エンドポイントはIHelloクッキー生成式の一部として受信されたアドレスを使用する必要があります。クッキーには、限られた時間のみ有効であるべきです。その寿命は95未満秒（推奨究極のセッションタイムアウトオープン）すべきではありません。"
    },
    {
      "indent": 3,
      "text": "On receipt of an FIHello chunk (Section 2.3.3) from a Forwarder (Section 3.5.1.5) where the Endpoint Discriminator selects its identity, an endpoint SHOULD do one of the following:",
      "ja": "エンドポイント識別子は、そのIDを選択フォワーダからFIHelloチャンク（2.3.3項）（セクション3.5.1.5）を受信すると、エンドポイントは、次のいずれかを実行する必要があります。"
    },
    {
      "indent": 3,
      "text": "1. Compute, construct, and send an RHello as though the FIHello was an IHello received from the indicated reply address; or",
      "ja": "1.計算、構成、及びFIHelloが指示返信アドレスからIHelloを受信されたかのようにRHelloを送信します。または"
    },
    {
      "indent": 3,
      "text": "2. Construct and send an Implied Redirect (Section 2.3.5) to the FIHello's reply address; or",
      "ja": "2.構築とFIHelloの返信アドレスに暗黙リダイレクト（2.3.5項）​​を送ります。または"
    },
    {
      "indent": 3,
      "text": "3. Ignore this FIHello.",
      "section_title": true,
      "ja": "3.このFIHelloを無視します。"
    },
    {
      "indent": 3,
      "text": "On receipt of an IIKeying chunk (Section 2.3.7), if the cookie is not authentic or if it has expired, ignore this IIKeying; otherwise,",
      "ja": "IIKeyingチャンク（セクション2.3.7）を受信すると、クッキーが本物でない、期限が切れている場合は、このIIKeyingを無視すれば、そうでなければ、"
    },
    {
      "indent": 3,
      "text": "On receipt of an IIKeying chunk, if the cookie appears authentic but does not match the address from which the IIKeying's packet was received, perform the special processing at Cookie Change (Section 3.5.1.2); otherwise,",
      "ja": "クッキーは本物表示されますが、IIKeyingのパケットが受信されたアドレスと一致しない場合IIKeyingチャンクを受信すると、クッキーの変更（セクション3.5.1.2）で特別な処理を行います。そうでなければ、"
    },
    {
      "indent": 3,
      "text": "On receipt of an IIKeying with an authentic and valid cookie, if the certificate is authentic according to the Cryptography Profile, AND the signature in the chunk is authentic according to the far end's certificate and the Cryptography Profile, AND the Session Key Initiator Component is acceptable, then:",
      "ja": "本物と有効なクッキーとIIKeyingを受信すると、証明書は暗号化プロファイルに応じて、本物である、チャンク内の署名は、遠端の証明書と暗号化のプロフィールによると、本物である、とセッション鍵イニシエータコンポーネントが受け入れ可能である場合、そして："
    },
    {
      "indent": 3,
      "text": "1. If the address from which this IIKeying was received corresponds to an opening session in the S_IHELLO_SENT or S_KEYING_SENT state, perform the special processing at Glare (Section 3.5.1.3); otherwise,",
      "ja": "1.このIIKeyingがS_IHELLO_SENT又はS_KEYING_SENT状態で開口セッションに対応する受信されたアドレスは、グレア（セクション3.5.1.3）での特別な処理を実行する場合、そうでなければ、"
    },
    {
      "indent": 3,
      "text": "2. If the address from which this IIKeying was received corresponds to a session in the S_OPEN state, then:",
      "ja": "2.このIIKeyingが受信されたアドレスは、S_OPEN状態でセッションに対応する場合："
    },
    {
      "indent": 7,
      "text": "1.  If the receiver was the Responder for the S_OPEN session and\n    the session identifier, certificate, and Session Key\n    Initiator Component are identical to those of the S_OPEN\n    session, this IIKeying is a retransmission, so resend the\n    S_OPEN session's RIKeying using the Default Session Key as\n    specified below; otherwise,",
      "raw": true
    },
    {
      "indent": 7,
      "text": "2. If the certificate from this IIKeying does not override the certificate of the S_OPEN session, ignore this IIKeying; otherwise,",
      "ja": "2.このIIKeyingから証明書がS_OPENセッションの証明書を無効にしない場合は、このIIKeyingを無視します。そうでなければ、"
    },
    {
      "indent": 7,
      "text": "3. The certificate from this IIKeying overrides the certificate of the S_OPEN session; this is a new opening session from the same identity, and the existing S_OPEN session is stale. Move the existing S_OPEN session to S_CLOSED and abort all of its flows (signaling exceptions to the user), then continue processing this IIKeying.",
      "ja": "3.このIIKeyingから証明書がS_OPENセッションの証明書を無効にします。これは、同じIDからの新オープニングセッションで、既存のS_OPENセッションが古くなっています。 S_CLOSED既存S_OPENセッションを移動し、このIIKeyingの処理を続行し、（ユーザの例外をシグナリング）そのフローのすべてを中止。"
    },
    {
      "indent": 7,
      "text": "Otherwise,",
      "ja": "そうでなければ、"
    },
    {
      "indent": 3,
      "text": "3. Compute a Session Key Responder Component and choose a new, unique receive session ID not used by any other session for the initiator to use when sending packets to the responder. Using this data, construct and, with the Session Key Initiator Component, sign an RIKeying chunk (Section 2.3.8). Using the Session Key Initiator and Responder Components and the near and far certificates, the responder combines and computes the shared session keys and nonces according to the Cryptography Profile. The responder creates a new session in the S_OPEN state, with the far-endpoint address DESTADDR taken from the source address of the packet containing the IIKeying and the send session identifier taken from the IIKeying. The responder sends the RIKeying to the initiator using the Default Session Key and the requested send session identifier. Packet encryption, decryption, and verification of all future packets for this session use the newly computed keys, and the session nonces are available for application-layer cryptographic challenges.",
      "ja": "3.計算セッションキーレスポンダコンポーネントとレスポンダにパケットを送信するときに使用するイニシエータのために他のセッションで使用されていない新しい、ユニークな受信セッションIDを選択してください。セッションキーイニシエータコンポーネントで、このデータを使用して構築し、RIKeyingチャンク（第2.3.8項）に署名。セッションキーイニシエータとレスポンダコンポーネントと近くと遠くの証明書を使用して、応答者のコンバインと暗号化プロファイルに従って、共有セッション鍵とナンスを計算します。レスポンダはIIKeyingとIIKeyingから取られた送信セッション識別子を含むパケットの送信元アドレスから取られた遠エンドポイントアドレスDESTADDRで、S_OPEN状態で新しいセッションを作成します。応答者は、デフォルトのセッションキーと要求された送信セッション識別子を使用してイニシエータにRIKeyingを送信します。パケットの暗号化、復号化、およびこのセッションのすべての将来のパケットの検証が新たに算出されたキーを使用して、セッションナンスは、アプリケーション層の暗号化の課題のために用意されています。"
    },
    {
      "indent": 0,
      "text": "3.5.1.2. Cookie Change",
      "section_title": true,
      "ja": "3.5.1.2。クッキーの変更"
    },
    {
      "indent": 3,
      "text": "In some circumstances, the responder may generate an RHello cookie for an initiator's address that isn't the address the initiator would use when sending packets directly to the responder. This can happen, for example, when the initiator has multiple local addresses and uses one address to reach a Forwarder (Section 3.5.1.5) but another to reach the responder.",
      "ja": "いくつかの状況では、レスポンダはレスポンダに直接パケットを送信するときに、イニシエータが使用するアドレスではありません、イニシエータのアドレスのためのRHelloクッキーを生成してもよいです。これは、イニシエータが、複数のローカルアドレスを持っており、フォワーダ（セクション3.5.1.5）に達するが、別の応答者に到達するために一つのアドレスを使用する場合、例えば、発生する可能性があります。"
    },
    {
      "indent": 3,
      "text": "Consider the following example:",
      "ja": "次の例を考えてみます。"
    },
    {
      "indent": 3,
      "text": "Initiator                    Forwarder                     Responder\n| IHello                         |                                 |\n|(Src=Ix)                        |                                 |\n|------------------------------->|                                 |\n|                                | FIHello                         |\n|                                |(RA=Ix)                          |\n|                                |-------------------------------->|\n|                                                                  |\n|                                                           RHello |\n|                                                       (Cookie:Ix)|\n|<-----------------------------------------------------------------|\n|                                                                  |\n| IIKeying                                                         |\n|(Cookie:Ix,Src=Iy)                                                |\n|----------------------------------------------------------------->|\n|                                                                  |\n|                                             RHello Cookie Change |\n|                                             (Cookie:Ix,Cookie:Iy)|\n|<-----------------------------------------------------------------|\n|                                                                  |\n| IIKeying                                                         |\n|(Cookie:Iy)                                                       |\n|----------------------------------------------------------------->|\n|                                                                  |\n|                                                         RIKeying |\n|<-----------------------------------------------------------------|\n|                                                                  |\n|<======================== S E S S I O N =========================>|",
      "raw": true
    },
    {
      "indent": 18,
      "text": "Figure 10: Handshake with Cookie Change",
      "ja": "図10：クッキーの変更と握手"
    },
    {
      "indent": 3,
      "text": "The initiator has two network interfaces: a first preferred interface with address Ix = 192.0.2.100:50000, and a second with address Iy = 198.51.100.101:50001. The responder has one interface with address Ry = 198.51.100.200:51000, on the same network as the initiator's second interface. The initiator uses its first interface to reach a Forwarder. The Forwarder observes the initiator's address of Ix and sends a Forwarded IHello (Section 2.3.3) to the responder. The responder treats this as if it were an IHello from Ix, calculates a corresponding cookie, and sends an RHello to Ix. The initiator receives this RHello from Ry and selects that address as the destination for the session. It then sends an IIKeying, copying the cookie from the RHello. However, since the source of the RHello is Ry, on a network to which the initiator is directly connected, the initiator uses its second interface Iy to send the IIKeying. The responder, on receiving the IIKeying, will compare the cookie to the expected value based on the source address of the packet, and since the IIKeying source doesn't match the IHello source used to generate the cookie, the responder will reject the IIKeying.",
      "ja": "アドレス1×= 192.0.2.100:50000有する第一の好ましい界面、及びアドレスIyの= 198.51.100.101:50001と第二：開始剤は、2つのネットワークインタフェースを有します。レスポンダは、イニシエータの第2のインタフェースと同じネットワーク上に、アドレスさRy = 198.51.100.200:51000とつのインタフェースを有しています。イニシエータは、フォワーダに到達するための最初のインターフェイスを使用しています。フォワーダーは、IXのイニシエータのアドレスを観察し、応答者に転送IHello（2.3.3項）を送信します。応答者の扱い、このことは、1×からIHelloであるかのように、対応するクッキーを計算し、およびIXにRHelloを送信します。開始剤は、ライからこのRHelloを受信し、セッションの宛先としてそのアドレスを選択します。その後RHelloからクッキーをコピーし、IIKeyingを送信します。 RHelloのソースはイニシエータが直接接続されるネットワーク上のRyが、あるので、イニシエータはIIKeyingを送信するために、その第2のインタフェースIyのを使用します。応答者は、IIKeyingを受信すると、パケットの送信元アドレスに基づいて、期待値にクッキーを比較し、IIKeying源がクッキーを生成するために使用さIHelloソースと一致しないので、応答者はIIKeyingを拒否します。"
    },
    {
      "indent": 3,
      "text": "If the responder determines that it generated the cookie in the IIKeying but the cookie doesn't match the sender's address (for example, if the cookie is in two parts, with a first part generated independently of the initiator's address and a second part dependent on the address), the responder SHOULD generate a new cookie based on the address from which the IIKeying was received and send an RHello Cookie Change chunk (Section 2.3.6) to the source of the IIKeying, using the session ID from the IIKeying and the Default Session Key.",
      "ja": "レスポンダは、IIKeyingにクッキーを生成することを決定するが、クッキーは、2つの部分にある場合、クッキーは、イニシエータのアドレスとに依存する第二の部分とは独立して生成された第一の部分と、（例えば、送信者のアドレスと一致しない場合アドレス）、応答者はIIKeyingが受信されたアドレスに基づいて、新しいクッキーを生成し、IIKeyingのソースにRHelloクッキーの変更チャンク（2.3.6項）を送信し、IIKeyingからセッションIDを使用したとすべきですセッションキーをデフォルト。"
    },
    {
      "indent": 3,
      "text": "If the initiator receives an RHello Cookie Change chunk for a session in the S_KEYING_SENT state, AND the old cookie matches the one originally sent to the responder, then the initiator adopts the new cookie, constructs and signs a new IIKeying chunk, and sends the new IIKeying to the responder. The initiator SHOULD NOT change the cookie for a session more than once.",
      "ja": "イニシエータはS_KEYING_SENT状態でのセッションのためにRHelloクッキーの変更チャンクを受け取り、古いクッキーは元々レスポンダに送信されたものと一致した場合、その後、イニシエータは新しいクッキー、構築物及び看板新しいIIKeyingチャンクを採用し、新しいを送信しますレスポンダにIIKeying。イニシエータは、複数回のセッションのためにクッキーを変更しないでください。"
    },
    {
      "indent": 0,
      "text": "3.5.1.3. Glare",
      "section_title": true,
      "ja": "3.5.1.3。グレア"
    },
    {
      "indent": 3,
      "text": "Glare occurs when two endpoints attempt to initiate sessions to each other concurrently. Glare is detected by receipt of a valid and authentic IIKeying from an endpoint address that is a destination for an opening session. Only one session is allowed between a pair of endpoints.",
      "ja": "2つのエンドポイントが同時に互いにセッションを開始しようとすると、グレアが発生します。グレアは、開口セッションの宛先であるエンドポイントアドレスから有効かつ本物IIKeyingの受信によって検出されます。一つだけのセッションは、エンドポイントのペアの間で許可されています。"
    },
    {
      "indent": 3,
      "text": "Glare is resolved by comparing the certificate in the received IIKeying with the near end's certificate. The Cryptography Profile defines a certificate comparison function to determine the prevailing endpoint when there is glare.",
      "ja": "グレアは、近端の証明書を使用して、受信IIKeyingに証明書を比較することによって解決されます。暗号化プロファイルはグレアがある場合に支配エンドポイントを決定するために、証明書の比較関数を定義します。"
    },
    {
      "indent": 3,
      "text": "If the near end prevails, discard and ignore the received IIKeying. The far end will abort its opening session on receipt of IIKeying from the near end.",
      "ja": "近端が優勢ならば、破棄し、受信IIKeyingを無視します。遠端が近端からIIKeyingの領収書にそのオープニングセッションを中止します。"
    },
    {
      "indent": 3,
      "text": "Otherwise, the far end prevails:",
      "ja": "それ以外の場合は、遠端が優先さ："
    },
    {
      "indent": 3,
      "text": "1. If the certificate in the IIKeying overrides the certificate associated with the near opening session according to the Cryptography Profile, then abort and destroy the near opening session. Then,",
      "ja": "1. IIKeying内の証明書は、暗号化プロファイルに従って周辺開口セッションに関連付けられた証明書を上書きした場合、周辺の開口セッションを中止し、破壊します。その後、"
    },
    {
      "indent": 3,
      "text": "2. Continue with normal Responder IIKeying processing (Section 3.5.1.1.2).",
      "ja": "2.通常のレスポンダIIKeying処理（セクション3.5.1.1.2）に進みます。"
    },
    {
      "indent": 0,
      "text": "3.5.1.4. Redirector",
      "section_title": true,
      "ja": "3.5.1.4。リダイレクタ"
    },
    {
      "indent": 8,
      "text": "+-----------+           +------------+          +-----------+\n| Initiator |---------->| Redirector |          | Responder |\n|           |<----------|            |          |           |\n|           |           +------------+          |           |\n|           |<=================================>|           |\n+-----------+                                   +-----------+",
      "raw": true
    },
    {
      "indent": 27,
      "text": "Figure 11: Redirector",
      "ja": "図11：リダイレクタ"
    },
    {
      "indent": 3,
      "text": "A Redirector acts like a name server for Endpoint Discriminators. An initiator MAY use a Redirector to discover additional candidate endpoint addresses for a desired endpoint.",
      "ja": "リダイレクターは、エンドポイントディスクリミネータのネームサーバのように動作します。イニシエータは、所望の終点のための追加の候補エンドポイントのアドレスを発見するためにリダイレクタを使用するかもしれません。"
    },
    {
      "indent": 3,
      "text": "On receipt of an IHello chunk with an Endpoint Discriminator that does not select the Redirector's identity, the Redirector constructs and sends back to the initiator a Responder Redirect chunk (Section 2.3.5) containing one or more additional candidate addresses for the indicated endpoint.",
      "ja": "リダイレクタのアイデンティティ、リダイレクタの構造を選択して、イニシエータに戻って指示されたエンドポイントの1つの以上の追加の候補アドレスを含むレスポンダリダイレクトチャンク（セクション2.3.5）を送信していないエンドポイント識別子とIHelloチャンクを受信します。"
    },
    {
      "indent": 3,
      "text": "Initiator                   Redirector                     Responder\n| IHello                         |                                 |\n|------------------------------->|                                 |\n|                                |                                 |\n|                       Redirect |                                 |\n|<-------------------------------|                                 |\n|                                                                  |\n| IHello                                                           |\n|----------------------------------------------------------------->|\n|                                                                  |\n|                                                           RHello |\n|<-----------------------------------------------------------------|\n|                                                                  |\n| IIKeying                                                         |\n|----------------------------------------------------------------->|\n|                                                                  |\n|                                                         RIKeying |\n|<-----------------------------------------------------------------|\n|                                                                  |\n|<======================== S E S S I O N =========================>|",
      "raw": true
    },
    {
      "indent": 18,
      "text": "Figure 12: Handshake Using a Redirector",
      "ja": "図12：リダイレクタを使用してハンドシェイク"
    },
    {
      "indent": 3,
      "text": "Deployment Design Note: Redirectors SHOULD NOT initiate new sessions to endpoints that might use the Redirector's address as a candidate for another endpoint, since the far end might interpret the Redirector's IIKeying as glare for the far end's initiation to the other endpoint.",
      "ja": "展開のデザインノート：リダイレクタは、遠端が他のエンドポイントへの遠端の開始のためのグレアとしてリダイレクタのIIKeyingを解釈するかもしれないので、別のエンドポイントの候補としてリダイレクタのアドレスを使用する場合がありますエンドポイントに新しいセッションを開始すべきではありません。"
    },
    {
      "indent": 0,
      "text": "3.5.1.5. Forwarder",
      "section_title": true,
      "ja": "3.5.1.5。フォワーダ"
    },
    {
      "indent": 9,
      "text": "+-----------+     +-----------+     +---+     +-----------+\n| Initiator |---->| Forwarder |<===>| N |<===>| Responder |\n|           |     +-----------+     | A |     |           |\n|           |<=====================>| T |<===>|           |\n+-----------+                       +---+     +-----------+",
      "raw": true
    },
    {
      "indent": 27,
      "text": "Figure 13: Forwarder",
      "ja": "図13：フォワーダー"
    },
    {
      "indent": 3,
      "text": "A responder might be behind a NAT or firewall that doesn't allow inbound packets to reach the endpoint until it first sends an outbound packet for a particular far-endpoint address.",
      "ja": "応答者は、それが第1の特定の遠エンドポイントのアドレスに発信パケットを送信するまで着信パケットがエンドポイントに到達することはできませんNATやファイアウォールの背後にあるかもしれません。"
    },
    {
      "indent": 3,
      "text": "A Forwarder's endpoint address MAY be a candidate address for another endpoint. A responder MAY use a Forwarder to receive FIHello chunks sent on behalf of an initiator.",
      "ja": "フォワーダのエンドポイントアドレスは、別のエンドポイントの候補アドレスであってもよいです。レスポンダは、開始剤の代わりに送信FIHelloチャンクを受信するフォワーダを使用するかもしれません。"
    },
    {
      "indent": 3,
      "text": "On receipt of an IHello chunk with an Endpoint Discriminator that does not select the Forwarder's identity, if the Forwarder has an S_OPEN session with an endpoint whose certificate matches the desired Endpoint Discriminator, the Forwarder constructs and sends an FIHello chunk (Section 2.3.3) to the selected endpoint over the S_OPEN session, using the tag and Endpoint Discriminator from the IHello chunk and the source address of the packet containing the IHello for the corresponding fields of the FIHello.",
      "ja": "フォワーダがFIHelloチャンクを証明希望エンドポイント識別子、フォワーダーの構造に一致するエンドポイントとS_OPENセッションを持っており、送信した場合、フォワーダーのIDを選択していないエンドポイント識別子とIHelloチャンクを受信する（2.3.3項） S_OPENセッションにわたって選択されたエンドポイントに、IHelloチャンクとFIHelloの対応するフィールドのIHelloを含むパケットの送信元アドレスからタグとエンドポイント識別子を使用して。"
    },
    {
      "indent": 3,
      "text": "On receipt of an FIHello chunk, a responder might send an RHello or Implied Redirect to the original source of the IHello (Section 3.5.1.1.2), potentially allowing future packets to flow directly between the initiator and responder through the NAT or firewall.",
      "ja": "FIHelloチャンクを受信すると、応答は、潜在的に、将来のパケットがNATまたはファイアウォールを介してイニシエータとレスポンダとの間で直接流すこと、IHello（セクション3.5.1.1.2）の元のソースにRHelloまたは暗黙のリダイレクトを送信するかもしれません。"
    },
    {
      "indent": 3,
      "text": "Initiator                    Forwarder           NAT       Responder\n| IHello                         |                |                |\n|------------------------------->|                |                |\n|                                | FIHello        |                |\n|                                |--------------->|--------------->|\n|                                                 |                |\n|                                                 |         RHello |\n|                                                 :<---------------|\n|<------------------------------------------------:                |\n|                                                 :                |\n| IIKeying                                        :                |\n|-------------------------------------------------:--------------->|\n|                                                 :                |\n|                                                 :       RIKeying |\n|                                                 :<---------------|\n|<------------------------------------------------:                |\n|                                                 :                |\n|<======================== S E S S I O N ========>:<==============>|",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Figure 14: Forwarder Handshake where Responder Sends an RHello",
      "ja": "図14：レスポンダはRHelloを送信フォワーダハンドシェイク"
    },
    {
      "indent": 3,
      "text": "Initiator                    Forwarder           NAT       Responder\n| IHello                         |                |                |\n|------------------------------->|                |                |\n|                                | FIHello        |                |\n|                                |--------------->|--------------->|\n|                                                 |                |\n|                                                 |       Redirect |\n|                                                 | (Implied,RD={})|\n|                                                 :<---------------|\n|<------------------------------------------------:                |\n|                                                 :                |\n| IHello                                          :                |\n|------------------------------------------------>:--------------->|\n|                                                 :                |\n|                                                 :         RHello |\n|                                                 :<---------------|\n|<------------------------------------------------:                |\n|                                                 :                |\n| IIKeying                                        :                |\n|------------------------------------------------>:--------------->|\n|                                                 :                |\n|                                                 :       RIKeying |\n|                                                 :<---------------|\n|<------------------------------------------------:                |\n|                                                 :                |\n|<======================== S E S S I O N ========>:<==============>|",
      "raw": true
    },
    {
      "indent": 10,
      "text": "Figure 15: Forwarder Handshake where Responder Sends an\n                   Implied Redirect",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.5.1.6. Redirector and Forwarder with NAT",
      "section_title": true,
      "ja": "3.5.1.6。リダイレクトとNATを進めます"
    },
    {
      "indent": 13,
      "text": "+---+       +---+       +---+      +---+      +---+\n| I |       | N |       | I |      | N |      | R |\n| n |------>| A |------>| n |      | A |      | e |\n| i |       | T |       | t |<====>| T |<====>| s |\n| t |<------|   |<------| r |      |   |      | p |\n| i |       |   |       | o |      |   |      | o |\n| a |       |   |       +---+      |   |      | n |\n| t |       |   |                  |   |      | d |\n| o |<=====>|   |<================>|   |<====>| e |\n| r |       |   |                  |   |      | r |\n+---+       +---+                  +---+      +---+",
      "raw": true
    },
    {
      "indent": 8,
      "text": "Figure 16: Introduction Service for Initiator and Responder behind NATs",
      "ja": "図16：NATの背後はじめイニシエータのサービスとレスポンダ"
    },
    {
      "indent": 3,
      "text": "An initiator and responder might each be behind distinct NATs or firewalls that don't allow inbound packets to reach the respective endpoints until each first sends an outbound packet for a particular far-endpoint address.",
      "ja": "イニシエータとレスポンダは、それぞれ各第一は、特定の遠エンドポイントのアドレスに発信パケットを送信するまでの着信パケットは、それぞれのエンドポイントに到達することはできません。個別のNATのか、ファイアウォールの背後かもしれません。"
    },
    {
      "indent": 3,
      "text": "An introduction service comprising Redirector and Forwarder functions may facilitate direct communication between endpoints each behind a NAT.",
      "ja": "リダイレクタとフォワーダ機能を含む紹介サービスは、NATの背後にあるエンドポイントのそれぞれとの間の直接通信を容易にすることができます。"
    },
    {
      "indent": 3,
      "text": "The responder is registered with the introduction service via an S_OPEN session to it. The service observes and records the responder's public NAT address as the DESTADDR of the S_OPEN session. The service MAY record other addresses for the responder, for example addresses that the responder self-reports as being directly attached.",
      "ja": "応答者は、それにS_OPENセッションを介して紹介サービスに登録されています。サービスはS_OPENセッションのDESTADDRとして応答者のパブリックNATアドレスを観察し、記録します。サービスは、応答者のために他のアドレスを記録することができ、例えば、直接接続されているとして、その応答の自己報告に対応しています。"
    },
    {
      "indent": 3,
      "text": "The initiator begins with an address of the introduction service as an initial candidate. The Redirector portion of the service sends to the initiator a Responder Redirect containing at least the responder's public NAT address as previously recorded. The Forwarder portion of the service sends to the responder a Forwarded IHello containing the initiator's public NAT address as observed to be the source of the IHello.",
      "ja": "イニシエータは最初の候補として紹介サービスのアドレスから始まります。サービスのリダイレクター部分は、以前に記録された少なくとも応答者のパブリックNATアドレスを含むイニシエータレスポンダリダイレクトに送信します。 IHelloの源であることが観察されたサービスのフォワーダ部分は、イニシエータのパブリックNATアドレスを含む応答転送さIHelloに送信します。"
    },
    {
      "indent": 3,
      "text": "The responder sends an RHello to the initiator's public NAT address in response to the FIHello. This will allow inbound packets to the responder through its NAT from the initiator's public NAT address.",
      "ja": "応答者は、FIHelloに応じて、イニシエータのパブリックNATアドレスにRHelloを送信します。これは、イニシエータのパブリックNATアドレスからのNAT経由のレスポンダへのインバウンドパケットを許可します。"
    },
    {
      "indent": 3,
      "text": "The initiator sends an IHello to the responder's public NAT address in response to the Responder Redirect. This will allow inbound packets to the initiator through its NAT from the responder's public NAT address.",
      "ja": "イニシエータは、レスポンダリダイレクトに応じて、応答者のパブリックNATアドレスにIHelloを送信します。これは、応答者のパブリックNATアドレスからのNAT経由イニシエータへのインバウンドパケットを許可します。"
    },
    {
      "indent": 3,
      "text": "With transit paths created in both NATs, normal session startup can proceed.",
      "ja": "トランジットパスは両方のNATで作成すると、通常のセッションの起動を続行することができます。"
    },
    {
      "indent": 3,
      "text": "Initiator     NAT-I    Redirector+Forwarder     NAT-R      Responder\n|               |                |                |                |\n| IHello        |                |                |                |\n|(Dst=Intro)    |                |                |                |\n|-------------->|                |                |                |\n|               |--------------->|                |                |\n|               |                | FIHello        |                |\n|               |                |(RA=NAT-I-Pub)  |                |\n|               |                |--------------->|--------------->|\n|               |       Redirect |                |                |\n|               | (RD={NAT-R-Pub,|                |                |\n|               |           ...})|                |                |\n|<--------------|<---------------|                |                |\n|               |                                 |         RHello |\n|               |                                 | (Dst=NAT-I-Pub)|\n|               |                                 :<---------------|\n|               | (*)  <--------------------------:                |\n| IHello        |                                 :                |\n|(Dst=NAT-R-Pub)|                                 :                |\n|-------------->:                                 :                |\n|               :-------------------------------->:--------------->|\n|               :                                 :                |\n|               :                                 :         RHello |\n|               :                                 :<---------------|\n|<--------------:<--------------------------------:                |\n|               :                                 :                |\n| IIKeying      :                                 :                |\n|-------------->:                                 :                |\n|               :-------------------------------->:--------------->|\n|               :                                 :                |\n|               :                                 :       RIKeying |\n|               :                                 :<---------------|\n|<--------------:<--------------------------------:                |\n|               :                                 :                |\n|<=============>:<======== S E S S I O N ========>:<==============>|",
      "raw": true
    },
    {
      "indent": 12,
      "text": "Figure 17: Handshake with Redirector and Forwarder",
      "ja": "図17：リダイレクタとフォワーダと握手"
    },
    {
      "indent": 3,
      "text": "At the point in Figure 17 marked (*), the responder's RHello from the FIHello might arrive at the initiator's NAT before or after the initiator's IHello is sent outbound to the responder's public NAT address. If it arrives before, it may be dropped by the NAT. If it arrives after, it will transit the NAT and trigger keying without waiting for another round-trip time. The timing of this race depends, among other factors, on the relative distances of the initiator and responder from each other and from the introduction service.",
      "ja": "イニシエータのIHelloが応答者のパブリックNATアドレスへの送信を送信される前または後に、図17のポイントマーク（*）で、FIHelloからの応答者のRHelloは、イニシエータのNATに到着するかもしれません。それは前に到着した場合、それはNATによってドロップすることができます。それが後に到着した場合、それはトランジットNATとトリガーは別のラウンドトリップ時間を待たずにキーイングします。このレースのタイミングは、互いに及び紹介サービスからイニシエータとレスポンダとの相対距離に、他の要因の中でも特に、依存します。"
    },
    {
      "indent": 0,
      "text": "3.5.1.7. Load Distribution and Fault Tolerance",
      "section_title": true,
      "ja": "3.5.1.7。負荷分散とフォールトトレランス"
    },
    {
      "indent": 13,
      "text": "+---+    IHello/RHello    +-------------+\n| I |<------------------->| Responder 1 |\n| n |                     +-------------+\n| i |  SESSION  +-------------+\n| t |<=========>| Responder 2 |\n| i |           +-------------+\n| a |   IHello...                 +----------------+\n| t |-------------------------> X | Dead Responder |\n| o |                             +----------------+\n| r |  IHello/RHello   +-------------+\n|   |<---------------->| Responder N |\n+---+                  +-------------+",
      "raw": true
    },
    {
      "indent": 14,
      "text": "Figure 18: Parallel Open to Multiple Endpoints",
      "ja": "図18：複数のエンドポイントへのオープンパラレル"
    },
    {
      "indent": 3,
      "text": "As specified in Section 3.2, more than one endpoint is allowed to be selected by one Endpoint Discriminator. This will typically be the case for a set of servers, any of which could accommodate a connecting client.",
      "ja": "セクション3.2で指定されるように、複数のエンドポイントは、一つエンドポイント識別子によって選択することが許されます。これは、一般的に接続しているクライアントを収容できる任意のそれらのサーバーのセット、のためのケースとなります。"
    },
    {
      "indent": 3,
      "text": "As specified in Section 3.5.1.1.1, an initiator is allowed to use multiple candidate endpoint addresses when starting a session, and the sender of the first acceptable RHello chunk to be received is selected to complete the session, with later responses ignored. An initiator can start with the multiple candidate endpoint addresses, or it may learn them during startup from one or more Redirectors (Section 3.5.1.4).",
      "ja": "節3.5.1.1.1に規定されているように、イニシエータがセッションを開始するときに複数の候補エンドポイントアドレスを使用させ、第一に許容されるRHelloチャンクの送信者が受信すべき無視以降の応答と、セッションを完了するために選択されます。イニシエータは、複数の候補のエンドポイントアドレスで開始することができ、またはそれは、一つ以上のリダイレクタ（セクション3.5.1.4）からの起動時にそれらを学ぶことがあります。"
    },
    {
      "indent": 3,
      "text": "Parallel open to multiple endpoints for the same Endpoint Discriminator, combined with selection by earliest RHello, can be used for load distribution and fault tolerance. The cost at each endpoint that is not selected is limited to receiving and processing an IHello, and generating and sending an RHello.",
      "ja": "最も早いRHelloによる選択と組み合わされ、同じエンドポイント識別子のための複数のエンドポイントと平行オープンは、負荷分散およびフォールトトレランスのために使用することができます。選択されていない各エンドポイントにおけるコストを受信しIHelloを処理し、生成しRHelloの送信に限定されています。"
    },
    {
      "indent": 3,
      "text": "In one circumstance, multiple servers of similar processing and networking capacity may be located in near proximity to each other, such as in a data center. In this circumstance, a less heavily loaded server can respond to an IHello more quickly than more heavily loaded servers and will tend to be selected by a client.",
      "ja": "1つの状況では、同様の処理及びネットワーク容量の複数のサーバは、データセンターのように、互いに近くに近接して配置することができます。この状況では、少ない負荷の高いサーバは、より高負荷のサーバよりも早くIHelloに応答することができますし、クライアントが選択される傾向があります。"
    },
    {
      "indent": 3,
      "text": "In another circumstance, multiple servers may be located in different physical locations, such as different data centers. In this circumstance, a server that is located nearer (in terms of network distance) to the client can respond earlier than more distant servers and will tend to be selected by the client.",
      "ja": "別の状況では、複数のサーバは、異なるデータセンターのような異なる物理的位置に配置することができます。この状況では、クライアントに（ネットワーク距離の面で）近いが置かれているサーバーは、より遠くのサーバよりも早く対応することができ、クライアントによって選択される傾向があります。"
    },
    {
      "indent": 3,
      "text": "Multiple servers, in proximity or distant from one another, can form a redundant pool of servers. A client can perform a parallel open to the multiple servers. In normal operation, the multiple servers will all respond, and the client will select one of them as described above. If one of the multiple servers fails, other servers in the pool can still respond to the client, allowing the client to succeed to an S_OPEN session with one of them.",
      "ja": "複数のサーバは、互いに近接または遠隔で、サーバの冗長プールを形成することができます。クライアントが複数のサーバーに並行オープンを実行することができます。通常の操作では、複数のサーバがすべて応答します、そして前述のように、クライアントはそれらのいずれかを選択します。複数のサーバのいずれかに障害が発生した場合は、プール内の他のサーバーは、まだクライアントはそのうちの一つでS_OPENセッションに成功することができ、クライアントに応答することができます。"
    },
    {
      "indent": 0,
      "text": "3.5.2. Congestion Control",
      "section_title": true,
      "ja": "3.5.2。輻輳制御"
    },
    {
      "indent": 3,
      "text": "An RTMFP MUST implement congestion control and avoidance algorithms that are \"TCP compatible\", in accordance with Internet best current practice [RFC2914]. The algorithms SHOULD NOT be more aggressive in sending data than those described in \"TCP Congestion Control\" [RFC5681] and MUST NOT be more aggressive in sending data than the \"slow start algorithm\" described in Section 3.1 of RFC 5681.",
      "ja": "RTMFPは、インターネットのベストプラクティス現在の[RFC2914]に従って、「TCP互換性」であり、輻輳制御と回避アルゴリズムを実装しなければなりません。アルゴリズムは[RFC5681]「TCP輻輳制御」に記載されているものよりもデータを送信し、より積極的にすべきではないとRFC 5681のセクション3.1に記載された「スロースタートアルゴリズム」よりデータを送信することで、より積極的にすることはできません。"
    },
    {
      "indent": 3,
      "text": "An endpoint maintains a transmission budget in the session information context of each S_OPEN session (Section 3.5), controlling the rate at which the endpoint sends data into the network.",
      "ja": "エンドポイントは、エンドポイントがネットワークにデータを送信する速度を制御し、各S_OPENセッション（セクション3.5）のセッション情報コンテキストで伝送バジェットを維持します。"
    },
    {
      "indent": 3,
      "text": "For window-based congestion control and avoidance algorithms, the transmission budget is the congestion window, which is the amount of user data that is allowed to be outstanding, or in flight, in the network. Transmission is allowed when S_OUTSTANDING_BYTES (Section 3.5) is less than the congestion window (Section 3.6.2.3). See Appendix A for an experimental window-based congestion control algorithm for real-time and bulk data.",
      "ja": "ウィンドウベースの輻輳制御と回避アルゴリズムは、送信予算は、ネットワーク内の、未処理が許可されるユーザデータの量、または飛行中である輻輳ウィンドウ、です。 S_OUTSTANDING_BYTES（セクション3.5）輻輳ウィンドウ（セクション3.6.2.3）未満である場合、送信が許可されています。リアルタイムとバルクデータのための実験的なウィンドウベースの輻輳制御アルゴリズムについては、付録Aを参照してください。"
    },
    {
      "indent": 3,
      "text": "An endpoint avoids sending large bursts of data or packets into the network (Section 3.5.2.3).",
      "ja": "エンドポイントは、ネットワーク（セクション3.5.2.3）へのデータまたはパケットの大バーストを送信することが回避されます。"
    },
    {
      "indent": 3,
      "text": "A sending endpoint increases and decreases its transmission budget in response to acknowledgements (Section 3.6.2.4) and loss according to the congestion control and avoidance algorithms. Loss is detected by negative acknowledgement (Section 3.6.2.5) and timeout (Section 3.6.2.6).",
      "ja": "エンドポイントの増加を送信し、肯定応答（セクション3.6.2.4）と、輻輳制御と回避アルゴリズムに従って損失に応答してその送信予算を減少させます。損失は​​否定応答（セクション3.6.2.5）とタイムアウト（セクション3.6.2.6）によって検出されます。"
    },
    {
      "indent": 3,
      "text": "Timeout is determined by the Effective Retransmission Timeout (ERTO) (Section 3.5.2.2). The ERTO is measured using the Timestamp and Timestamp Echo packet header fields (Section 2.2.4).",
      "ja": "タイムアウトは、効果的な再送信タイムアウト（ERTO）（セクション3.5.2.2）によって決定されます。 ERTOは、タイムスタンプ及びタイムスタンプエコーパケットヘッダフィールド（セクション2.2.4）を用いて測定されます。"
    },
    {
      "indent": 3,
      "text": "A receiving endpoint acknowledges all received data (Section 3.6.3.4) to enable the sender to measure receipt of data, or lack thereof.",
      "ja": "受信エンドポイントは、すべてのそのデータの受信、又は欠如を測定するために、送信者を有効にする（セクション3.6.3.4）でデータを受信し承認します。"
    },
    {
      "indent": 3,
      "text": "A receiving endpoint may be receiving time critical (or real-time) data from a first sender while receiving data from other senders. The receiving endpoint can signal its other senders (Section 2.2.4)",
      "ja": "受信エンドポイントは、他の送信者からのデータを受信しながら最初の送信者からの臨界時間（またはリアルタイム）データを受信して​​もよいです。受信エンドポイントが、その他の送信者信号を送ることができる（セクション2.2.4）"
    },
    {
      "indent": 3,
      "text": "to cause them to decrease the aggressiveness of their congestion control and avoidance algorithms, in order to yield network capacity to the time critical data (Section 3.5.2.1).",
      "ja": "彼らは重要なデータ（セクション3.5.2.1）時にネットワーク容量を得るために、彼らの輻輳制御と回避アルゴリズムの攻撃性を減少させます。"
    },
    {
      "indent": 0,
      "text": "3.5.2.1. Time Critical Reverse Notification",
      "section_title": true,
      "ja": "3.5.2.1。タイムクリティカルリバース通知"
    },
    {
      "indent": 3,
      "text": "A sender can increase its transmission budget at a rate compatible with (but not exceeding) the \"slow start algorithm\" specified in RFC 5681 (with which the transmission rate is doubled every round trip when beginning or restarting transmission, until loss is detected). However, a sender MUST behave as though the slow start threshold SSTHRESH is clamped to 0 (disabling the slow start algorithm's exponential increase behavior) on a session where a Time Critical Reverse Notification (Section 2.2.4) indication has been received from the far end within the last 800 milliseconds, unless the sender is itself currently sending time critical data to the far end.",
      "ja": "送信者は（損失が検出されるまで、開始または送信を再開する場合、伝送速度は、すべてのラウンドトリップを倍増している）RFC 5681で指定された「スロースタートアルゴリズムを」（しかし超えない）と互換性の速度でその伝送予算を増やすことができます。スロースタートしきい値SSTHRESHは、タイムクリティカルリバース通知（2.2.4）表示が遠端から受信されたセッションで（スロースタートアルゴリズムの指数関数的な増加の動作を無効にする）0にクランプされているかのようしかし、送信者が振る舞わなければならない（MUST）送信者が自分自身でない限り、最後の800ミリ秒以内に、現在の遠端にタイムクリティカルなデータを送信します。"
    },
    {
      "indent": 3,
      "text": "During each round trip, a sender SHOULD NOT increase the transmission budget by more than 0.5% or by 384 bytes per round trip (whichever is greater) on a session where a Time Critical Reverse Notification indication has been received from the far end within the last 800 milliseconds, unless the sender is itself currently sending time critical data to the far end.",
      "ja": "各ラウンドトリップ中に、送信者は、タイムクリティカル逆通知指示が最後内の遠端から受信されたセッションで（いずれか大きい方）より0.5％によって、または往復当たり384バイトで送信予算を増やすべきではありません800ミリ秒、送信者自身が現在、遠端にタイムクリティカルなデータを送信している場合を除きます。"
    },
    {
      "indent": 0,
      "text": "3.5.2.2. Retransmission Timeout",
      "section_title": true,
      "ja": "3.5.2.2。再送信タイムアウト"
    },
    {
      "indent": 3,
      "text": "RTMFP uses the ERTO to detect when a user data fragment has been lost in the network. The ERTO is typically calculated in a manner similar to that specified in \"Requirements for Internet Hosts - Communication Layers\" [RFC1122] and is a function of round-trip time measurements and persistent timeout behavior.",
      "ja": "RTMFPは、ユーザデータフラグメントがネットワークで失われたときを検出するERTOを使用します。 ERTOは、典型的には、「インターネットホストのための要件 - 通信層」で指定したのと同様の方法で計算され、[RFC1122]と往復時間の測定と持続タイムアウト挙動の関数です。"
    },
    {
      "indent": 3,
      "text": "The ERTO SHOULD be at least 250 milliseconds and SHOULD allow for the receiver to delay sending an acknowledgement for up to 200 milliseconds (Section 3.6.3.4.4). The ERTO MUST NOT be less than the round-trip time.",
      "ja": "ERTOは、少なくとも250ミリ秒であるべきであり、最大200ミリ秒（セクション3.6.3.4.4）に対する肯定応答を送信遅延させる受信を可能にすべきです。 ERTOは往復時間以上でなければなりません。"
    },
    {
      "indent": 3,
      "text": "To facilitate round-trip time measurement, an endpoint MUST implement the Timestamp Echo facility:",
      "ja": "往復時間の測定を容易にするために、エンドポイントは、タイムスタンプエコー機能を実装する必要があります。"
    },
    {
      "indent": 3,
      "text": "o On a session entering the S_OPEN state, initialize TS_RX_TIME to negative infinity, and initialize TS_RX and TS_ECHO_TX to have no value.",
      "ja": "O S_OPEN状態に入るセッションで、負の無限大にTS_RX_TIMEを初期化し、値を持たないようにTS_RXとTS_ECHO_TXを初期化します。"
    },
    {
      "indent": 3,
      "text": "o On receipt of a packet in an S_OPEN session with the timestampPresent (Section 2.2.4) flag set, if the timestamp field in the packet is different than TS_RX, set TS_RX to the value of the timestamp field in the packet, and set TS_RX_TIME to the current time.",
      "ja": "O timestampPresent（セクション2.2.4）フラグが設定されたS_OPENセッションでパケットを受信すると、パケットにおけるタイムスタンプフィールドはTS_RX_TIMEパケットにおけるタイムスタンプフィールドの値にTS_RXを設定し、TS_RXは異なる、と設定している場合現在の時刻に。"
    },
    {
      "indent": 3,
      "text": "o When sending a packet to the far end in an S_OPEN session:",
      "ja": "S_OPENセッションで遠端にパケットを送信する場合○："
    },
    {
      "indent": 6,
      "text": "1. Calculate TS_RX_ELAPSED = current time - TS_RX_TIME. If TS_RX_ELAPSED is more than 128 seconds, then set TS_RX and TS_ECHO_TX to have no value, and do not include a timestamp echo; otherwise,",
      "ja": "1.計算TS_RX_ELAPSED =現在の時刻 -  TS_RX_TIME。 TS_RX_ELAPSED以上128秒である場合には、TS_RXとTS_ECHO_TXが値を持たないように設定され、タイムスタンプのエコーが含まれていません。そうでなければ、"
    },
    {
      "indent": 6,
      "text": "2. Calculate TS_RX_ELAPSED_TICKS to be the number of whole 4-millisecond periods in TS_RX_ELAPSED; then",
      "ja": "2.計算TS_RX_ELAPSED_TICKS TS_RX_ELAPSEDにおける全4ミリ秒期間の数であり;それから"
    },
    {
      "indent": 6,
      "text": "3. Calculate TS_ECHO = (TS_RX + TS_RX_ELAPSED_TICKS) MODULO 65536; then",
      "ja": "3.計算TS_ECHO =（TS_RX + TS_RX_ELAPSED_TICKS）MODULO 65536。それから"
    },
    {
      "indent": 6,
      "text": "4. If TS_ECHO is not equal to TS_ECHO_TX, then set TS_ECHO_TX to TS_ECHO, set the timestampEchoPresent flag, and set the timestampEcho field to TS_ECHO_TX.",
      "ja": "4. TS_ECHOがTS_ECHO_TXに等しくない場合、timestampEchoPresentフラグを設定し、TS_ECHO_TXにtimestampEchoフィールドを設定し、TS_ECHOにTS_ECHO_TXを設定。"
    },
    {
      "indent": 3,
      "text": "The remainder of this section describes an OPTIONAL method for calculating the ERTO. Real-time applications and P2P mesh applications often require knowing the round-trip time and RTT variance. This section additionally describes a method for measuring the round-trip time and RTT variance, and calculating a smoothed round-trip time.",
      "ja": "このセクションの残りはERTOを計算するための任意の方法を記載しています。リアルタイムアプリケーションやP2Pメッシュアプ​​リケーションは、多くの場合、往復時間とRTTの変動を知る必要があります。このセクションでは、さらに、往復時間とRTTの変動を測定し、平滑化往復時間を計算するための方法を記載しています。"
    },
    {
      "indent": 3,
      "text": "Let the session information context contain additional variables:",
      "ja": "セッション情報のコンテキストは、追加の変数が含まれてみましょう："
    },
    {
      "indent": 3,
      "text": "o TS_TX: the last timestamp sent to the far end, initialized to have no value;",
      "ja": "O TS_TX：遠端に送信された最後のタイムスタンプは、値を持たないように初期化。"
    },
    {
      "indent": 3,
      "text": "o TS_ECHO_RX: the last timestamp echo received from the far end, initialized to have no value;",
      "ja": "O TS_ECHO_RX：最後のタイムスタンプが値を持たないように初期化、遠端から受信されたエコー。"
    },
    {
      "indent": 3,
      "text": "o SRTT: the smoothed round-trip time, initialized to have no value;",
      "ja": "O SRTT：値を持たないように初期化平滑化往復時間、;"
    },
    {
      "indent": 3,
      "text": "o RTTVAR: the round-trip time variance, initialized to 0.",
      "ja": "O RTTVAR：往復時間の分散、0に初期化。"
    },
    {
      "indent": 3,
      "text": "Initialize MRTO to 250 milliseconds.",
      "ja": "250ミリ秒にMRTOを初期化します。"
    },
    {
      "indent": 3,
      "text": "Initialize ERTO to 3 seconds.",
      "ja": "3秒にERTOを初期化します。"
    },
    {
      "indent": 3,
      "text": "On sending a packet to the far end of an S_OPEN session, if the current send timestamp is not equal to TS_TX, then set TS_TX to the current send timestamp, set the timestampPresent flag in the packet header, and set the timestamp field to TS_TX.",
      "ja": "現在の送信タイムスタンプがTS_TXに等しくない場合、S_OPENセッションの遠端にパケットを送信することで、その後TS_TX現在の送信タイムスタンプに設定され、パケットヘッダにtimestampPresentフラグを設定し、TS_TXにタイムスタンプフィールドを設定します。"
    },
    {
      "indent": 3,
      "text": "On receipt of a packet from the far end of an S_OPEN session, if the timestampEchoPresent flag is set in the packet header, AND the timestampEcho field is not equal to TS_ECHO_RX, then:",
      "ja": "timestampEchoPresentフラグは、パケットヘッダに設定された場合S_OPENセッションの遠端からパケットを受信すると、timestampEchoフィールドが次にTS_ECHO_RX、に等しくありません。"
    },
    {
      "indent": 3,
      "text": "1. Set TS_ECHO_RX to timestampEcho;",
      "section_title": true,
      "ja": "timestampEcho 1.設定TS_ECHO_RX。"
    },
    {
      "indent": 3,
      "text": "2. Calculate RTT_TICKS = (current send timestamp - timestampEcho) MODULO 65536;",
      "ja": "2.計算RTT_TICKS =（現在の送信タイムスタンプ -  timestampEcho）MODULO 65536。"
    },
    {
      "indent": 3,
      "text": "3. If RTT_TICKS is greater than 32767, the measurement is invalid, so discard this measurement; otherwise,",
      "ja": "3. RTT_TICKSが32767より大きい場合、測定が無効であるため、この測定値を捨てます。そうでなければ、"
    },
    {
      "indent": 3,
      "text": "4. Calculate RTT = RTT_TICKS * 4 milliseconds;",
      "section_title": true,
      "ja": "4.計算RTT = RTT_TICKS * 4ミリ秒。"
    },
    {
      "indent": 3,
      "text": "5. If SRTT has a value, then calculate new values of RTTVAR and SRTT:",
      "ja": "5. SRTTが値を持っている場合、RTTVARとSRTTの新しい値を計算します。"
    },
    {
      "indent": 7,
      "text": "1. RTT_DELTA = | SRTT - RTT |;",
      "section_title": true,
      "ja": "1. RTT_DELTA = | SRTT  -  RTT |。"
    },
    {
      "indent": 7,
      "text": "2. RTTVAR = ((3 * RTTVAR) + RTT_DELTA) / 4;",
      "section_title": true,
      "ja": "2. RTTVAR =（（3 * RTTVAR）+ RTT_DELTA）/ 4。"
    },
    {
      "indent": 7,
      "text": "3. SRTT = ((7 * SRTT) + RTT) / 8.",
      "section_title": true,
      "ja": "3. SRTT =（（7 *のSRTT）+ RTT）/ 8。"
    },
    {
      "indent": 3,
      "text": "6. If SRTT has no value, then set SRTT = RTT and RTTVAR = RTT / 2;",
      "section_title": true,
      "ja": "SRTTに値がない場合6.は、SRTT = RTTとRTTVAR = RTT / 2を設定します。"
    },
    {
      "indent": 3,
      "text": "7. Set MRTO = SRTT + 4 * RTTVAR + 200 milliseconds;",
      "section_title": true,
      "ja": "7.設定しMRTO = SRTT + 4 *のRTTVAR + 200ミリ秒。"
    },
    {
      "indent": 3,
      "text": "8. Set ERTO to MRTO or 250 milliseconds, whichever is greater.",
      "section_title": true,
      "ja": "大きい方MRTO又は250ミリ秒に8セットERTO、。"
    },
    {
      "indent": 3,
      "text": "A retransmission timeout occurs when the most recently transmitted user data fragment has remained outstanding in the network for ERTO. When this timeout occurs, increase ERTO on an exponential backoff with an ultimate backoff cap of 10 seconds:",
      "ja": "再送タイムアウトは、最後に送信されたユーザデータの断片がERTOのためのネットワークに優れ残っている場合に発生します。このタイムアウトが発生した場合、10秒の究極のバックオフキャップで指数バックオフにERTOを増やします。"
    },
    {
      "indent": 3,
      "text": "1. Calculate ERTO_BACKOFF = ERTO * 1.4142;",
      "section_title": true,
      "ja": "1.計算ERTO_BACKOFF = ERTO * 1.4142;"
    },
    {
      "indent": 3,
      "text": "2. Calculate ERTO_CAPPED to be ERTO_BACKOFF or 10 seconds, whichever is less;",
      "ja": "2.計算ERTO_CAPPED小さい方ERTO_BACKOFF又は10秒、ことを特徴とします。"
    },
    {
      "indent": 3,
      "text": "3. Set ERTO to ERTO_CAPPED or MRTO, whichever is greater.",
      "section_title": true,
      "ja": "いずれか大きい方ERTO_CAPPEDまたはMRTO 3.設定ERTO、。"
    },
    {
      "indent": 0,
      "text": "3.5.2.3. Burst Avoidance",
      "section_title": true,
      "ja": "3.5.2.3。バースト回避"
    },
    {
      "indent": 3,
      "text": "An application's sending patterns may cause the transmission budget to grow to a large value, but at times its sending patterns will result in a comparatively small amount of data outstanding in the network. In this circumstance, especially with a window-based congestion avoidance algorithm, if the application then has a large amount of new data to send (for example, a new bulk data transfer), it could send data into the network all at once to fill the window. This kind of transmission burst is undesirable, however, because it can jam interfaces, links, and buffers.",
      "ja": "アプリケーションの送信パターンは、伝送バジェットが大きい値に成長する可能性がありますが、時にはその送信パターンは、ネットワーク内の未処理データ量が比較的少ないになります。特にウィンドウベースの輻輳回避アルゴリズムと、このような状況において、アプリケーションはその後（例えば、新しいバルクデータ転送）を送信するための新たな大量のデータを有する場合、それは埋めるために一斉ネットワークにデータを送信することができ窓。それはインターフェイス、リンク、および緩衝液を妨害することができるので、送信バーストのこの種は、しかし、望ましくありません。"
    },
    {
      "indent": 3,
      "text": "Accordingly, in any session, an endpoint SHOULD NOT send more than six packets containing user data between receiving any acknowledgements or retransmission timeouts.",
      "ja": "従って、任意のセッションで、エンドポイントは、任意の確認応答又は再送タイムアウトを受信する間に、ユーザデータを含む以上の6つのパケットを送るべきではありません。"
    },
    {
      "indent": 3,
      "text": "The following describes an OPTIONAL method to avoid bursting large numbers of packets into the network:",
      "ja": "以下は、ネットワークにパケットを大量に破裂を避けるために任意の方法を説明します。"
    },
    {
      "indent": 3,
      "text": "Let the session information context contain an additional variable DATA_PACKET_COUNT, initialized to 0.",
      "ja": "セッション情報コンテキストが0に初期化され、追加の変数DATA_PACKET_COUNTを、含まれてみましょう。"
    },
    {
      "indent": 3,
      "text": "Transmission of a user data fragment on this session is not allowed if DATA_PACKET_COUNT is greater than or equal to 6, regardless of any other allowance of the congestion control algorithm.",
      "ja": "DATA_PACKET_COUNTに関係なく、輻輳制御アルゴリズムの他の手当の、より大きいまたは6に等しい場合、このセッションのユーザデータフラグメントの送信が許可されていません。"
    },
    {
      "indent": 3,
      "text": "On transmission of a packet containing at least one User Data chunk (Section 2.3.11), set DATA_PACKET_COUNT = DATA_PACKET_COUNT + 1.",
      "ja": "少なくとも1つのユーザデータチャンク（セクション2.3.11）を含むパケットの送信に、= DATA_PACKET_COUNT + 1 DATA_PACKET_COUNTを設定します。"
    },
    {
      "indent": 3,
      "text": "On receipt of an acknowledgement chunk (Sections 2.3.13 and 2.3.14), set DATA_PACKET_COUNT to 0.",
      "ja": "肯定応答チャンク（セクション2.3.13および2.3.14）の受信時に、0にDATA_PACKET_COUNTを設定。"
    },
    {
      "indent": 3,
      "text": "On a retransmission timeout, set DATA_PACKET_COUNT to 0.",
      "ja": "再送タイムアウトでは、0にDATA_PACKET_COUNTを設定します。"
    },
    {
      "indent": 0,
      "text": "3.5.3. Address Mobility",
      "section_title": true,
      "ja": "3.5.3。住所モビリティ"
    },
    {
      "indent": 3,
      "text": "Sessions are demultiplexed with a 32-bit session ID, rather than by endpoint address. This allows an endpoint's address to change during an S_OPEN session. This can happen, for example, when switching from a wireless to a wired network, or when moving from one wireless base station to another, or when a NAT restarts.",
      "ja": "セッションはなく、エンドポイントアドレスによるよりも、32ビットのセッションIDを用いて分離されます。これは、エンドポイントのアドレスがS_OPENセッション中に変更することができます。 NAT再起動を有線ネットワークに無線から切り替えるとき、または別の無線基地局から移動するとき、またはとき、これは、例えば、起こることができます。"
    },
    {
      "indent": 3,
      "text": "If the near end receives a valid packet for an S_OPEN session from a source address that doesn't match DESTADDR, the far end might have changed addresses. The near end SHOULD verify that the far end is definitively at the new address before changing DESTADDR. A suggested verification method is described in Section 3.5.4.2.",
      "ja": "近端がDESTADDRと一致しない送信元アドレスからのS_OPENセッションの有効なパケットを受信した場合、遠端のアドレスを変更している場合があります。近端は、遠端がDESTADDRを変更する前に、新しいアドレスに決定的であることを確認する必要があります。提案検証方法は、セクション3.5.4.2に記載されています。"
    },
    {
      "indent": 0,
      "text": "3.5.4. Ping",
      "section_title": true,
      "ja": "3.5.4。 Pingの"
    },
    {
      "indent": 3,
      "text": "If an endpoint receives a Ping chunk (Section 2.3.9) in a session in the S_OPEN state, it SHOULD construct and send a Ping Reply chunk (Section 2.3.10) in response if possible, copying the message unaltered. The Ping Reply SHOULD be sent as quickly as possible following receipt of a Ping. The semantics of a Ping's message is reserved for the sender; a receiver SHOULD NOT interpret the Ping's message.",
      "ja": "エンドポイントがS_OPEN状態でのセッションでpingのチャンク（セクション2.3.9）を受信した場合、可能ならば、それは変更されていないメッセージをコピーし、応答（セクション2.3.10）ping応答チャンクを構築し、送信すべきです。 ping応答は、Pingのを受けた後、可能な限り迅速に送ってください。 Pingのメッセージの意味は、送信者のために予約されています。受信機は、Pingののメッセージを解釈すべきではありません。"
    },
    {
      "indent": 3,
      "text": "Endpoints can use the mechanism of the Ping chunk and the expected Ping Reply for any purpose. This specification doesn't mandate any specific constraints on the format or semantics of a Ping message. A Ping Reply MUST be sent only as a response to a Ping.",
      "ja": "エンドポイントは、Pingのチャンクのメカニズムと任意の目的のために予想されるping応答を使用することができます。この仕様は、Pingメッセージの形式や意味論上の任意の特定の制約を強制しません。 ping応答が唯一のPingへの応答として送らなければなりません。"
    },
    {
      "indent": 3,
      "text": "Receipt of a Ping Reply implies live bidirectional connectivity. This specification doesn't mandate any other semantics for a Ping Reply.",
      "ja": "ping応答の領収書は、ライブ双方向接続を意味します。この仕様は、ping応答のための任意の他のセマンティクスを強制しません。"
    },
    {
      "indent": 0,
      "text": "3.5.4.1. Keepalive",
      "section_title": true,
      "ja": "3.5.4.1。生き続ける"
    },
    {
      "indent": 3,
      "text": "An endpoint can use a Ping to test for live bidirectional connectivity, to test that the far end of a session is still in the S_OPEN state, to keep NAT translations alive, and to keep firewall holes open.",
      "ja": "エンドポイントは、生きているNAT変換を維持するために、オープンファイアウォールの穴を維持するために、セッションの遠端がS_OPEN状態のままであることをテストするために、ライブ双方向の接続をテストするには、pingを使用することができます。"
    },
    {
      "indent": 3,
      "text": "An endpoint can use a Ping to hasten detection of a near-end address change by the far end.",
      "ja": "エンドポイントは、遠端で近端アドレス変更の検出を早めるためのPingを使用することができます。"
    },
    {
      "indent": 3,
      "text": "An endpoint may declare a session to be defunct and dead after a persistent failure by the far end to return Ping Replies in response to Pings.",
      "ja": "エンドポイントは、Pingのがpingに応答して返信を返すために、遠端で永続的な障害が発生した後は亡きと死んだようにセッションを宣言することができます。"
    },
    {
      "indent": 3,
      "text": "If used for these purposes, a Keepalive Ping SHOULD have an empty message.",
      "ja": "これらの目的のために使用した場合は、キープアライブのPingは、空のメッセージを持っているべきです。"
    },
    {
      "indent": 3,
      "text": "A Keepalive Ping SHOULD NOT be sent more often than once per ERTO. If a corresponding Ping Reply is not received within ERTO of sending the Ping, ERTO SHOULD be increased according to Section 3.5.2 (\"Congestion Control\").",
      "ja": "キープアライブpingはERTOに一回よりも頻繁に送るべきではありません。対応するping応答がpingを送信ERTO内に受信されない場合、ERTOセクション3.5.2（「輻輳制御」）に応じて増加されるべきです。"
    },
    {
      "indent": 0,
      "text": "3.5.4.2. Address Mobility",
      "section_title": true,
      "ja": "3.5.4.2。住所モビリティ"
    },
    {
      "indent": 3,
      "text": "This section describes an OPTIONAL but suggested method for processing and verifying a far-end address change.",
      "ja": "このセクションでは、処理し、遠端アドレスの変更を確認するためのオプションですが、提案された方法を説明します。"
    },
    {
      "indent": 3,
      "text": "Let the session context contain additional variables MOB_TX_TS, MOB_RX_TS, and MOB_SECRET. MOB_TX_TS and MOB_RX_TS have initial values of negative infinity. MOB_SECRET should be a cryptographically pseudorandom value not less than 128 bits in length and known only to this end.",
      "ja": "セッションコンテキストは、追加の変数MOB_TX_TS、MOB_RX_TS、およびMOB_SECRETが含まれてみましょう。 MOB_TX_TSとMOB_RX_TSは負の無限大の初期値を持っています。 MOB_SECRETは、長さが128ビット未満しかこの目的のために知られていない暗号擬似ランダム値であるべきです。"
    },
    {
      "indent": 3,
      "text": "On receipt of a packet for an S_OPEN session, after processing all chunks in the packet: if the session is still in the S_OPEN state, AND the source address of the packet does not match DESTADDR, AND MOB_TX_TS is at least one second in the past, then:",
      "ja": "S_OPENセッションのためのパケットを受信すると、パケット内のすべてのチャンクを処理した後：セッションがS_OPEN状態のままであり、パケットの送信元アドレスはDESTADDRと一致していない、とMOB_TX_TSは、過去に少なくとも一つの第二の場合、そして："
    },
    {
      "indent": 3,
      "text": "1. Set MOB_TX_TS to the current time;",
      "section_title": true,
      "ja": "現在の時刻に1セットMOB_TX_TS。"
    },
    {
      "indent": 3,
      "text": "2. Construct a Ping message comprising the following: a marking to indicate (to this end when returned in a Ping Reply) that it is a mobility check (for example, the first byte being ASCII 'M' for \"Mobility\"), a timestamp set to MOB_TX_TS, and a cryptographic hash over the following: the preceding items, the address from which the packet was received, and MOB_SECRET; and",
      "ja": "2.以下を含んでPingメッセージを構築：（ping応答で返されたときにこの目的のために）それは（、「モビリティ」のための最初のバイトであることASCII「M」は、例えば）モビリティ・チェックであることを示すためにマーキング、 MOB_TX_TSに設定されたタイムスタンプ、および下記オーバー暗号ハッシュ：上記項目、パケットが受信されたアドレス、及びMOB_SECRET。そして"
    },
    {
      "indent": 3,
      "text": "3. Send this Ping to the address from which the packet was received, instead of DESTADDR.",
      "ja": "3.代わりにDESTADDRの、パケットが受信されたアドレスにこのPing]を送信します。"
    },
    {
      "indent": 3,
      "text": "On receipt of a Ping Reply in an S_OPEN session, if the Ping Reply's message satisfies all of these conditions:",
      "ja": "ping応答のメッセージは、これらの条件のすべてを満たす場合のPingを受信すると、S_OPENセッションに返信："
    },
    {
      "indent": 3,
      "text": "o it has this end's expected marking to indicate that it is a mobility check, and",
      "ja": "Oそれは、この最後の期待している、それはモビリティチェックであることを示すためにマーキングし、"
    },
    {
      "indent": 3,
      "text": "o the timestamp in the message is not more than 120 seconds in the past, and",
      "ja": "メッセージのタイムスタンプが過去に120秒以上ではないO、及び"
    },
    {
      "indent": 3,
      "text": "o the timestamp in the message is greater than MOB_RX_TS, and",
      "ja": "OメッセージのタイムスタンプはMOB_RX_TSより大きく、そして"
    },
    {
      "indent": 3,
      "text": "o the cryptographic hash matches the expected value according to the contents of the message plus the source address of the packet containing this Ping Reply and MOB_SECRET,",
      "ja": "暗号ハッシュは、メッセージの内容に応じた期待値プラスこのping応答とMOB_SECRETを含むパケットの送信元アドレスと一致oを"
    },
    {
      "indent": 3,
      "text": "then:",
      "ja": "その後："
    },
    {
      "indent": 3,
      "text": "1. Set MOB_RX_TS to the timestamp in the message; and",
      "section_title": true,
      "ja": "メッセージのタイムスタンプに1セットMOB_RX_TS。そして"
    },
    {
      "indent": 3,
      "text": "2. Set DESTADDR to the source address of the packet containing this Ping Reply.",
      "ja": "このping応答を含むパケットの送信元アドレスに2セットDESTADDR。"
    },
    {
      "indent": 0,
      "text": "3.5.4.3. Path MTU Discovery",
      "section_title": true,
      "ja": "3.5.4.3。パスMTUディスカバリ"
    },
    {
      "indent": 3,
      "text": "\"Packetization Layer Path MTU Discovery\" [RFC4821] describes a method for measuring the path MTU between communicating endpoints.",
      "ja": "「パケット化層のパスMTUディスカバリ」[RFC4821]は通信エンドポイント間のパスMTUを測定するための方法を記載しています。"
    },
    {
      "indent": 3,
      "text": "An RTMFP SHOULD perform path MTU discovery.",
      "ja": "RTMFPは、パスMTUディスカバリを実行する必要があります。"
    },
    {
      "indent": 3,
      "text": "The method described in RFC 4821 can be adapted for use in RTMFP by sending a probe packet comprising one of the Padding chunk types (type 0x00 or 0xff) and a Ping. The Ping chunk SHOULD come after the Padding chunk, to guard against a false positive response in case the probe packet is truncated.",
      "ja": "RFC 4821に記載された方法は、パディングチャンクタイプ（タイプ0×00または0xffの）とPingのいずれかを含むプローブパケットを送信することによってRTMFPにおける使用に適合させることができます。 pingのチャンクは、プローブパケットが切り捨てられる場合には偽陽性反応を防ぐために、パディングチャンクの後に来る必要があります。"
    },
    {
      "indent": 0,
      "text": "3.5.5. Close",
      "section_title": true,
      "ja": "3.5.5。閉じる"
    },
    {
      "indent": 3,
      "text": "An endpoint may close a session at any time. Typically, an endpoint will close a session when there have been no open flows in either direction for a time. In another circumstance, an endpoint may be ceasing operation and will close all of its sessions even if they have open flows.",
      "ja": "エンドポイントは、いつでもセッションを閉じることができます。時間のためにどちらかの方向にもオープンフローがなかった場合、通常、エンドポイントは、セッションを終了します。別の状況では、エンドポイントは、運転を停止することができると、彼らはオープンフローを持っている場合でも、そのセッションのすべてを閉じます。"
    },
    {
      "indent": 3,
      "text": "To close an S_OPEN session in a reliable and orderly fashion, an endpoint moves the session to the S_NEARCLOSE state.",
      "ja": "信頼性が高く、整然とS_OPENセッションを閉じるには、エンドポイントはS_NEARCLOSE状態にセッションを移動します。"
    },
    {
      "indent": 3,
      "text": "On a session transitioning from S_OPEN to S_NEARCLOSE and every 5 seconds thereafter while still in the S_NEARCLOSE state, send a Session Close Request chunk (Section 2.3.17).",
      "ja": "セッションでは、セッションクローズリクエストチャンク（セクション2.3.17）を送信し、その後しばらくまだS_NEARCLOSE状態で5秒をS_NEARCLOSE、すべてのためにS_OPENから移行します。"
    },
    {
      "indent": 3,
      "text": "A session that has been in the S_NEARCLOSE state for at least 90 seconds (allowing time to retransmit the Session Close Request multiple times) SHOULD move to the S_CLOSED state.",
      "ja": "（セッションのクローズリクエストを複数回再送する時間を与えること）は、少なくとも90秒間S_NEARCLOSE状態にあったセッションがS_CLOSED状態に移動する必要があります。"
    },
    {
      "indent": 3,
      "text": "On a session transitioning from S_OPEN to the S_NEARCLOSE, S_FARCLOSE_LINGER or S_CLOSED state, immediately abort and terminate all open or closing flows. Flows only exist in S_OPEN sessions.",
      "ja": "S_NEARCLOSE、S_FARCLOSE_LINGERまたはS_CLOSED状態にS_OPENから移行セッションで、直ちにすべての開いているか閉じて流れを中断して終了。フローは唯一S_OPENセッションに存在します。"
    },
    {
      "indent": 3,
      "text": "To close an S_OPEN session abruptly, send a Session Close Acknowledgement chunk (Section 2.3.18), then move to the S_CLOSED state.",
      "ja": "（セクション2.3.18）セッションを閉じる謝辞チャンクを送信、突然S_OPENセッションを閉じるには、その後、S_CLOSED状態に移行します。"
    },
    {
      "indent": 3,
      "text": "On receipt of a Session Close Request chunk for a session in the S_OPEN, S_NEARCLOSE, or S_FARCLOSE_LINGER states, send a Session Close Acknowledgement chunk; then, if the session is in the S_OPEN state, move to the S_FARCLOSE_LINGER state.",
      "ja": "S_OPEN、S_NEARCLOSE、またはS_FARCLOSE_LINGER状態でのセッションのセッションクローズリクエストチャンクを受信すると、セッションを閉じる謝辞チャンクを送信します。セッションがS_OPEN状態にある場合には、その後、S_FARCLOSE_LINGER状態に移行します。"
    },
    {
      "indent": 3,
      "text": "A session that has been in the S_FARCLOSE_LINGER state for at least 19 seconds (allowing time to answer 3 retransmissions of a Session Close Request) SHOULD move to the S_CLOSED state.",
      "ja": "（時間はセッションクローズリクエストの3つの再送を答えるためにできるように）少なくとも19秒間S_FARCLOSE_LINGER状態にあったセッションがS_CLOSED状態に移動する必要があります。"
    },
    {
      "indent": 3,
      "text": "On receipt of a Session Close Acknowledgement chunk for a session in the S_OPEN, S_NEARCLOSE, or S_FARCLOSE_LINGER states, move to the S_CLOSED state.",
      "ja": "S_OPEN、S_NEARCLOSE、またはS_FARCLOSE_LINGER状態でのセッションのためのセッションを閉じる謝辞チャンクを受信すると、S_CLOSED状態に移行します。"
    },
    {
      "indent": 0,
      "text": "3.6. Flows",
      "section_title": true,
      "ja": "3.6。流れ"
    },
    {
      "indent": 3,
      "text": "A flow is a unidirectional communication channel in a session for transporting a correlated series of user messages from a sender to a receiver. Each end of a session may have zero or more sending flows to the other end. Each sending flow at one end has a corresponding receiving flow at the other end.",
      "ja": "フローは、受信機に送信機からユーザメッセージの相関系列を搬送するためのセッションにおける片方向通信チャネルです。セッションの各端部は、他端にゼロ個以上の送信フローを有することができます。一端にそれぞれ送信フローは、もう一方の端に対応する受信フローを有しています。"
    },
    {
      "indent": 0,
      "text": "3.6.1. Overview",
      "section_title": true,
      "ja": "3.6.1。概要"
    },
    {
      "indent": 0,
      "text": "3.6.1.1. Identity",
      "section_title": true,
      "ja": "3.6.1.1。身元"
    },
    {
      "indent": 3,
      "text": "Flows are multiplexed in a session by a flow identifier. Each end of a session chooses its sending flow identifiers independently of the other end. The choice of similar flow identifiers by both ends does not imply an association. A sender MAY choose any identifier for any flow; therefore, a flow receiver MUST NOT ascribe any semantic meaning, role, or name to a flow based only on its identifier. There are no \"well known\" or reserved flow identifiers.",
      "ja": "フローは、フロー識別子によってセッション中に多重化されています。セッションの各端部は、他方の端部とは独立してその送信フロー識別子を選択します。両端によると同様のフロー識別子の選択は、関連を意味するものではありません。送信者は、任意の流れのための任意の識別子を選ぶかもしれ。そのため、フロー受信機はその識別子に基づいて、フローにどんな意味論的な意味、役割、または名前を帰するてはなりません。何も「よく知られている」または予約フロー識別子がありません。"
    },
    {
      "indent": 3,
      "text": "Bidirectional flow association is indicated at flow startup with the Return Flow Association option (Section 2.3.11.1.2). An endpoint can indicate that a new sending flow is in return (or response) to a receiving flow from the other end. A sending flow MUST NOT indicate more than one return association. A receiving flow can be specified as the return association for any number of sending flows. The return flow association, if any, is fixed for the lifetime of the sending flow. Note: Closure of one flow in an association does not automatically close other flows in the association, except as specified in Section 3.6.3.1.",
      "ja": "双方向フローの関連付けはリターンフロー協会オプション（セクション2.3.11.1.2）と流れが起動時に表示されます。エンドポイントは、新しい送信フローが他端から受信フローにリターン（または応答）であることを示すことができます。送信フローは、複数の戻り値の関連性を示してはいけません。受信フローは、フローを送信する任意の数のリターン・アソシエーションとして指定することができます。リターン・フロー・アソシエーションは、もしあれば、送信フローの寿命のために固定されています。注：会合した1つの流れの閉鎖を自動的にセクション3.6.3.1に指定される場合を除き、関連して他のフローを閉じません。"
    },
    {
      "indent": 3,
      "text": "Flows are named with arbitrary user metadata. This specification doesn't mandate any particular encoding, syntax, or semantics for the user metadata, except for the encoded size (Section 2.3.11.1.1); the user metadata is entirely reserved for the application. The user metadata is fixed for the lifetime of the flow.",
      "ja": "フローは、任意のユーザメタデータと命名されています。この仕様は、符号化されたサイズ（セクション2.3.11.1.1）を除いて、任意の特定の符号化、構文、またはユーザメタデータのセマンティクスを強制しません。ユーザメタデータは完全にアプリケーションのために予約されています。ユーザメタデータは、フローの寿命のために固定されています。"
    },
    {
      "indent": 0,
      "text": "3.6.1.2. Messages and Sequencing",
      "section_title": true,
      "ja": "3.6.1.2。メッセージとシーケンシング"
    },
    {
      "indent": 3,
      "text": "Flows provide message-oriented framing. Large messages are fragmented for transport in the network. Receivers reassemble fragmented messages and only present complete messages to the user.",
      "ja": "フローは、メッセージ指向のフレーミングを提供しています。大きなメッセージは、ネットワーク内の輸送のために断片化されています。レシーバは、断片化されたメッセージと、ユーザーにのみ存在の完全なメッセージを組み立て直します。"
    },
    {
      "indent": 3,
      "text": "A sender queues messages on a sending flow one after another. A receiver can recover the original queuing order of the messages, even when they are reordered in transit by the network or as a result of loss and retransmission, by means of the messages' fragment sequence numbers. Flows are the basic units of message sequencing; each flow is sequenced independently of all other flows; inter-flow message arrival and delivery sequencing are not guaranteed.",
      "ja": "送信者は送信フロー次々にメッセージをキューに入れます。受信機は、それらがメッセージフラグメントシーケンス番号によって、ネットワークによって、または損失および再送の結果として、輸送中に並べ替えられた場合でも、メッセージの元のキューイング順序を回復することができます。フローは、メッセージシーケンスの基本単位です。各フローは、独立して、他のすべてのフローの配列決定されます。インターフローメッセージ到着と配達の順序は保証されません。"
    },
    {
      "indent": 3,
      "text": "Independent flow sequencing allows a sender to prioritize the transmission or retransmission of the messages of one flow over those of other flows in a session, allocating capacity from the transmission budget according to priority. RTMFP is designed for flows to be the basic unit of prioritization. In any flow, fragment sequence numbers are unique and monotonically increasing; that is, the fragment sequence numbers for any message MUST be greater than the fragment sequence numbers of all messages previously queued in that flow. Receipt of fragments out of sequence number order within a flow creates discontiguous gaps at the receiver, causing it to send an acknowledgement for every packet and also causing the size of the encoded acknowledgements to grow. Therefore, for any flow, the sender SHOULD send lower sequence numbers first.",
      "ja": "独立した流れ配列は、送信者が優先順位に従って送信予算から容量を割り当てる、セッション中に他のフローのものよりつの流れのメッセージの送信または再送信を優先することを可能にします。 RTMFPは、優先順位付けの基本単位となるフローのために設計されています。任意のフローでは、フラグメントシーケンス番号は一意であり、単調に増加します。つまり、任意のメッセージのフラグメントシーケンス番号が以前にそのフローのキューに入れられたすべてのメッセージの断片シーケンス番号よりも大きくなければなりません。フロー内のシーケンス番号順のうちフラグメントの受信は、それがすべてのパケットに対する肯定応答を送信させ、また、符号化された確認応答のサイズが成長させ、受信機において不連続ギャップを作成します。したがって、任意の流れのために、送信者は、第一下部のシーケンス番号を送るべきです。"
    },
    {
      "indent": 3,
      "text": "A sender can abandon a queued message at any time, even if some fragments of that message have been received by the other end. A receiver MUST be able to detect a gap in the flow when a message is abandoned; therefore, each message SHOULD take at least one sequence number from the sequence space even if no fragments for that message are ever sent. The sender will transmit the fragments of all messages not abandoned, and retransmit any lost fragments of all messages not abandoned, until all the fragments of all messages not abandoned are acknowledged by the receiver. A sender indicates a Forward Sequence Number (FSN) to instruct the receiver that sequence numbers less than or equal to the FSN will not be transmitted or retransmitted. This allows the receiver to move forward over gaps and continue sequenced delivery of completely received messages to the user. Any incomplete messages missing fragments with sequence numbers less than or equal to the FSN were abandoned by the sender and will never be completed. A gap indication MUST be communicated to the receiving user.",
      "ja": "送信者は、そのメッセージのいくつかの断片が、もう一方の端で受信された場合でも、いつでもキューに入れられたメッセージを放棄することができます。受信機は、メッセージが破棄されるフローのギャップを検出することができなければなりません。そのため、各メッセージは、そのメッセージのための断片が今までに送信されない場合でも、シーケンス空間から少なくとも1つのシーケンス番号を取る必要があります。送信者が放棄されていないすべてのメッセージの断片を送信し、放棄されていないすべてのメッセージの全ての断片が受信機によって承認されるまでは、放棄されていないすべてのメッセージのいずれかの失われた断片を再送します。送信者は、以下FSNに等しいシーケンス番号が送信または再送されないことを受信機に指示する転送シーケンス番号（FSN）を示しています。これは、受信機はギャップ上に前進し、ユーザに完全に受信したメッセージのシーケンスされた送達を継続することを可能にします。以下FSNに等しいシーケンス番号を有する断片が欠けて任意の不完全なメッセージは送信者によって放棄された、完成されることはありません。ギャップ指示は、受信ユーザに通信されなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.6.1.3. Lifetime",
      "section_title": true,
      "ja": "3.6.1.3。一生"
    },
    {
      "indent": 3,
      "text": "A sender begins a flow by sending user message fragments to the other end, and including the user metadata and, if any, the return flow association. The sender continues to include the user metadata and return flow association until the flow is acknowledged by the far end, at which point the sender knows that the receiver has received the user metadata and, if any, the return flow association. After that point, the flow identifier alone is sufficient.",
      "ja": "送信者は、他端にユーザメッセージフラグメントを送信し、ユーザメタデータと、もしあれば、戻り流協会含むことによって流れを開始します。送信者は、流れが、もしあれば、リターン・フロー・アソシエーションを送信者が受信機は、ユーザメタデータを受信したことを知っている時点で、遠端によって承認とされるまで、ユーザメタデータ及びリターンフローの関連付けを含むことを続けます。その時点の後、単独でフロー識別子は十分です。"
    },
    {
      "indent": 3,
      "text": "Flow receivers SHOULD acknowledge all sequence numbers received for any flow, whether the flow is accepted or rejected. Flow receivers MUST NOT acknowledge sequence numbers higher than the FSN that were not received. Acknowledgements drive the congestion control and avoidance algorithms and therefore must be accurate.",
      "ja": "フロー受信機は、流れを受諾するか拒否するかを、任意のフローのために受信したすべてのシーケンス番号を認識すべきです。フロー受信機は受信されませんでしたFSNよりも高いシーケンス番号を認めてはなりません。謝辞は、輻輳制御と回避アルゴリズムを駆動し、したがって、正確でなければなりません。"
    },
    {
      "indent": 3,
      "text": "An endpoint can reject a receiving flow at any time in the flow's lifetime. To reject the flow, the receiving endpoint sends a Flow Exception Report chunk (Section 2.3.16) immediately preceding every acknowledgement chunk for the rejected receiving flow.",
      "ja": "エンドポイントは、フローの寿命の任意の時点で受信フローを拒否することができます。流れを拒否するには、受信エンドポイントはすぐに拒否された受信フローごとに受信確認のチャンクの前のフロー例外レポートのチャンク（セクション2.3.16）を送信します。"
    },
    {
      "indent": 3,
      "text": "An endpoint may eventually conclude and close a sending flow. The last sequence number of the flow is marked with the Final flag. The sending flow is complete when all sequence numbers of the flow, including the final sequence number, have been cumulatively acknowledged by the receiver. The receiving flow is complete when every sequence number from the FSN to the final sequence number has been received. The sending flow and corresponding receiving flow at the respective ends hold the flow identifier of a completed flow in reserve for a time to allow delayed or duplicated fragments and acknowledgements to drain from the network without erroneously initiating a new receiving flow or erroneously acknowledging a new sending flow.",
      "ja": "エンドポイントは、最終的に送信する流れを締結して閉じることができます。流れの最後のシーケンス番号は、最終的なフラグでマークされています。最後のシーケンス番号を含む流れ、すべてのシーケンス番号は、累積的に受信機によって承認された場合、送信フローは完了です。最終シーケンス番号FSNからすべてのシーケンス番号が受信されたときに受信フローが完了する。それぞれの端部での流れを送信し、対応する受信フローが遅延または複製フラグメントおよび確認応答が誤って送信新を認める誤っ新しい受信流れを開始又はなしでネットワークから排出することを可能にする時間の予備で終了フローのフロー識別子を保持しますフロー。"
    },
    {
      "indent": 3,
      "text": "If a flow sender receives a Flow Exception indication from the other end, the flow sender SHOULD close the flow and abandon all of the undelivered queued messages. The flow sender SHOULD indicate an exception to the user.",
      "ja": "フロー送信者がもう一方の端からのフロー例外の指示を受信した場合は、フロー送信者はフローを終了し、未配信キューに入れられたメッセージのすべてを放棄すべきです。フローの送信者は、ユーザーに例外を示すべきです。"
    },
    {
      "indent": 0,
      "text": "3.6.2. Sender",
      "section_title": true,
      "ja": "3.6.2。送信者"
    },
    {
      "indent": 3,
      "text": "Each sending flow comprises the flow-specific information context necessary to transfer that flow's messages to the other end. Each sending flow context includes at least:",
      "ja": "各送信フローは、他端にそのフローのメッセージを転送するために必要なフロー固有情報コンテキストを含みます。各送信フローコンテキストは、少なくとも、"
    },
    {
      "indent": 3,
      "text": "o F_FLOW_ID: this flow's identifier;",
      "ja": "O F_FLOW_ID：このフローの識別子。"
    },
    {
      "indent": 3,
      "text": "o STARTUP_OPTIONS: the set of options to send to the receiver until this flow is acknowledged, including the User's Per-Flow Metadata and, if set, the Return Flow Association;",
      "ja": "O STARTUP_OPTIONS：このフローが確認されるまで、ユーザーのフローごとのメタデータと、設定した場合、リターンフロー協会を含め、受信機に送信するためのオプションのセット。"
    },
    {
      "indent": 3,
      "text": "o SEND_QUEUE: the unacknowledged message fragments queued in this flow, initially empty; each message fragment entry comprising the following:",
      "ja": "O SEND_QUEUE：このフローにキューイング未確認のメッセージフラグメント、最初は空。以下を含む各メッセージフラグメントエントリ："
    },
    {
      "indent": 6,
      "text": "* SEQUENCE_NUMBER: the sequence number of this fragment;",
      "ja": "* SEQUENCE_NUMBER：このフラグメントのシーケンス番号。"
    },
    {
      "indent": 6,
      "text": "* DATA: this fragment's user data;",
      "ja": "* DATA：このフラグメントのユーザーデータ。"
    },
    {
      "indent": 6,
      "text": "* FRA: the fragment control value for this message fragment, having one of the values enumerated for that purpose in Section 2.3.11 (\"User Data Chunk\");",
      "ja": "* FRA：このメッセージフラグメントについてのフラグメント制御値、セクション2.3.11（「ユーザデータチャンク」）で、その目的のために列挙された値の1つを有します。"
    },
    {
      "indent": 6,
      "text": "* ABANDONED: a boolean flag indicating whether this fragment has been abandoned;",
      "ja": "*放棄：このフラグメントは、放棄されたかどうかを示すブールフラグ。"
    },
    {
      "indent": 6,
      "text": "* SENT_ABANDONED: a boolean flag indicating whether this fragment was abandoned when sent;",
      "ja": "* SENT_ABANDONED：送信されたときに、この断片を放棄されたかどうかを示すブールフラグ。"
    },
    {
      "indent": 6,
      "text": "* EVER_SENT: a boolean flag indicating whether this fragment has been sent at least once, initially false;",
      "ja": "* EVER_SENT：このフラグメントは偽最初に、少なくとも一回送信されたかどうかを示すブールフラグ。"
    },
    {
      "indent": 6,
      "text": "* NAK_COUNT: a count of the number of negative acknowledgements detected for this fragment, initially 0;",
      "ja": "* NAK_COUNT：最初にこのフラグメントについて検出された否定応答の数のカウント、0。"
    },
    {
      "indent": 6,
      "text": "* IN_FLIGHT: a boolean flag indicating whether this fragment is currently outstanding, or in flight, in the network, initially false;",
      "ja": "* IN_FLIGHT：このフラグメントは、現在未処理であるか、または飛行中かどうかを示すブールフラグ、ネットワークに、最初に偽。"
    },
    {
      "indent": 6,
      "text": "* TRANSMIT_SIZE: the size, in bytes, of the encoded User Data chunk (including the chunk header) for this fragment when it was transmitted into the network.",
      "ja": "* TRANSMIT_SIZE：このフラグメントのための（チャンクヘッダを含む）符号化されたユーザーデータチャンクのバイト単位のサイズは、それがネットワークに送信された場合。"
    },
    {
      "indent": 3,
      "text": "o F_OUTSTANDING_BYTES: the sum of the TRANSMIT_SIZE of each entry in SEND_QUEUE where entry.IN_FLIGHT is true;",
      "ja": "F_OUTSTANDING_BYTES O：entry.IN_FLIGHTが真SEND_QUEUEの各エントリのTRANSMIT_SIZEの和。"
    },
    {
      "indent": 3,
      "text": "o RX_BUFFER_SIZE: the most recent available buffer advertisement from the other end (Sections 2.3.13 and 2.3.14), initially 65536 bytes;",
      "ja": "O RX_BUFFER_SIZE：もう一方の端から最新の利用可能なバッファ広告（セクション2.3.13および2.3.14）、最初は65536バイト。"
    },
    {
      "indent": 3,
      "text": "o NEXT_SN: the next sequence number to assign to a message fragment, initially 1;",
      "ja": "O NEXT_SN：最初は1、メッセージフラグメントに割り当てる次のシーケンス番号。"
    },
    {
      "indent": 3,
      "text": "o F_FINAL_SN: the sequence number assigned to the final message fragment of the flow, initially having no value;",
      "ja": "O F_FINAL_SN：最初は値を持たない、流れの最終メッセージフラグメントに割り当てられたシーケンス番号。"
    },
    {
      "indent": 3,
      "text": "o EXCEPTION: a boolean flag indicating whether an exception has been reported by the receiver, initially false;",
      "ja": "O EXCEPTION：例外が偽最初に、受信機によって報告されているかどうかを示すブールフラグ。"
    },
    {
      "indent": 3,
      "text": "o The state, at any time being one of the following values: the open state F_OPEN; the closing states F_CLOSING and F_COMPLETE_LINGER; and the closed state F_CLOSED.",
      "ja": "いつ次のいずれかの値である時、状態O：オープン状態F_OPEN。クローズ状態F_CLOSINGとF_COMPLETE_LINGER。そして、閉状態がF_CLOSED。"
    },
    {
      "indent": 3,
      "text": "Note: The following diagram is only a summary of state transitions and their causing events, and is not a complete operational specification.",
      "ja": "注意：以下の図は、状態遷移とその原因となるイベントの概要だけで、完全な動作仕様ではありません。"
    },
    {
      "indent": 29,
      "text": "    +--------+\n    | F_OPEN |\n    +--------+\n         |CLOSE or\n         |rcv Flow Exception\n         |\n         v\n    +---------+\n    |F_CLOSING|\n    +---------+\n         |rcv Data Ack\n         |  0..F_FINAL_SN\n         v\n+-----------------+\n|F_COMPLETE_LINGER|\n+-----------------+\n         | 130 seconds\n         v\n     +--------+\n     |F_CLOSED|\n     +--------+",
      "raw": true
    },
    {
      "indent": 19,
      "text": "Figure 19: Sending Flow State Diagram",
      "ja": "図19：フロー状態図を送信"
    },
    {
      "indent": 0,
      "text": "3.6.2.1. Startup",
      "section_title": true,
      "ja": "3.6.2.1。起動"
    },
    {
      "indent": 3,
      "text": "The application opens a new sending flow to the other end in an S_OPEN session. The implementation chooses a new flow ID that is not assigned to any other sending flow in that session in the F_OPEN, F_CLOSING, or F_COMPLETE_LINGER states. The flow starts in the F_OPEN state. The STARTUP_OPTIONS for the new flow is set with the User's Per-Flow Metadata (Section 2.3.11.1.1). If this flow is in return (or response) to a receiving flow from the other end, that flow's ID is encoded in a Return Flow Association (Section 2.3.11.1.2) option and added to STARTUP_OPTIONS. A new sending flow SHOULD NOT be opened in response to a receiving flow from the other end that is not in the RF_OPEN state when the sending flow is opened.",
      "ja": "アプリケーションはS_OPENセッション内の他の最後に新しい送信の流れを開きます。実装はF_OPEN、F_CLOSING、またはF_COMPLETE_LINGER状態で、そのセッション内の他の送信フローに割り当てられていない新しいフローIDを選択します。流れはF_OPEN状態で起動します。新しいフローのためのSTARTUP_OPTIONSは、ユーザーのフローごとのメタデータ（セクション2.3.11.1.1）で設定されています。この流れは、もう一方の端からの受信の流れに戻る（または応答）にある場合は、そのフローのIDは、リターンフロー協会（セクション2.3.11.1.2）オプションでエンコードし、STARTUP_OPTIONSに追加されます。新しい送信フローは、送信フローが開かれたときRF_OPEN状態ではないもう一方の端からの受信の流れに応じて開かないでください。"
    },
    {
      "indent": 3,
      "text": "At this point, the flow exists in the sender but not in the receiver. The flow begins when user data fragments are transmitted to the receiver. A sender can begin a flow in the absence of immediate user data by sending a Forward Sequence Number Update (Section 3.6.2.7.1), by queuing and transmitting a user data fragment that is already abandoned.",
      "ja": "この時点で、流れは、送信者ではなく、受信機に存在します。ユーザデータの断片が受信機に送信されたときにフローが開始されます。送信者は、キューイング、すでに放棄されたユーザデータの断片を送信することにより、転送シーケンス番号の更新（セクション3.6.2.7.1）を送信することによって直ちにユーザデータが存在しない場合のフローを開始することができます。"
    },
    {
      "indent": 0,
      "text": "3.6.2.2. Queuing Data",
      "section_title": true,
      "ja": "3.6.2.2。キューイングデータ"
    },
    {
      "indent": 3,
      "text": "The application queues messages in an F_OPEN sending flow for transmission to the far end. The implementation divides each message into one or more fragments for transmission in User Data chunks (Section 2.3.11). Each fragment MUST be small enough so that, if assembled into a packet (Section 2.2.4) with a maximum-size common header, User Data chunk header, and, if not empty, this flow's STARTUP_OPTIONS, the packet will not exceed the path MTU (Section 3.5.4.3).",
      "ja": "アプリケーションは、遠端に送信するための流れを送るF_OPENでメッセージをキューに入れます。実装は、ユーザデータのチャンクで送信するための1つの以上のフラグメント（セクション2.3.11）に各メッセージを分割します。各断片は、最大サイズの共通ヘッダ、ユーザデータチャンクヘッダとなるように、パケットに組み立てられた場合（セクション2.2.4）に十分小さくなければならない、そして、空でない場合は、このフローのSTARTUP_OPTIONS、パケットはパスを超えませんMTU（セクション3.5.4.3）。"
    },
    {
      "indent": 3,
      "text": "For each fragment, create a fragment entry and set fragmentEntry.SEQUENCE_NUMBER to flow.NEXT_SN, and increment flow.NEXT_SN by one. Set fragmentEntry.FRA according to the encoding in User Data chunks:",
      "ja": "各断片について、断片エントリを作成し、flow.NEXT_SNにfragmentEntry.SEQUENCE_NUMBERを設定し、いずれかによってflow.NEXT_SNをインクリメントします。ユーザーデータのチャンクでエンコーディングに従ってfragmentEntry.FRA設定します。"
    },
    {
      "indent": 3,
      "text": "0: This fragment is a complete message.",
      "ja": "0：このフラグメントは、完全なメッセージです。"
    },
    {
      "indent": 3,
      "text": "1: This fragment is the first of a multi-fragment message.",
      "ja": "1：このフラグメントは、マルチ断片メッセージの最初のものです。"
    },
    {
      "indent": 3,
      "text": "2: This fragment is the last of a multi-fragment message.",
      "ja": "2：このフラグメントは、マルチ断片メッセージの最後です。"
    },
    {
      "indent": 3,
      "text": "3: This fragment is in the middle of a multi-fragment message.",
      "ja": "3：このフラグメントは、マルチ断片メッセージの真ん中にあります。"
    },
    {
      "indent": 3,
      "text": "Append fragmentEntry to flow.SEND_QUEUE.",
      "ja": "flow.SEND_QUEUEにfragmentEntryを追加します。"
    },
    {
      "indent": 0,
      "text": "3.6.2.3. Sending Data",
      "section_title": true,
      "ja": "3.6.2.3。データの送信"
    },
    {
      "indent": 3,
      "text": "A sending flow is ready to transmit if the SEND_QUEUE contains at least one entry that is eligible to send, and if either RX_BUFFER_SIZE is greater than F_OUTSTANDING_BYTES or EXCEPTION is set to true.",
      "ja": "送信フローはSEND_QUEUEを送信するために資格がある少なくとも1つのエントリが含まれている場合に送信する準備ができている、とのいずれかRX_BUFFER_SIZEがF_OUTSTANDING_BYTESより大きい場合、または例外がtrueに設定されています。"
    },
    {
      "indent": 3,
      "text": "A SEND_QUEUE entry is eligible to send if it is not IN_FLIGHT, AND at least one of the following conditions holds:",
      "ja": "SEND_QUEUEエントリは、それがIN_FLIGHTない場合に送信する資格があるし、次の条件のうちの少なくとも1つが成り立ちます。"
    },
    {
      "indent": 3,
      "text": "o The entry is not ABANDONED; or",
      "ja": "Oエントリが放棄されていません。または"
    },
    {
      "indent": 3,
      "text": "o The entry is the first one in the SEND_QUEUE; or",
      "ja": "OエントリはSEND_QUEUEにおける最初のものです。または"
    },
    {
      "indent": 3,
      "text": "o The entry's SEQUENCE_NUMBER is equal to flow.F_FINAL_SN.",
      "ja": "OエントリのSEQUENCE_NUMBERはflow.F_FINAL_SNに等しいです。"
    },
    {
      "indent": 3,
      "text": "If the session's transmission budget allows, a flow that is ready to transmit is selected for transmission according to the implementation's prioritization scheme. The manner of flow prioritization is not mandated by this specification.",
      "ja": "セッションの伝送予算が許すならば、送信する準備ができている流れは、実装の優先順位付け方式による伝送のために選択されています。フロー優先順位付けの方法は、本明細書で義務付けられていません。"
    },
    {
      "indent": 3,
      "text": "Trim abandoned messages from the front of the queue, and find the Forward Sequence Number (FSN):",
      "ja": "キューの先頭から捨てられたメッセージをトリム、およびフォワードシーケンス番号（FSN）を見つけます："
    },
    {
      "indent": 3,
      "text": "1. While the SEND_QUEUE contains at least two entries, AND the first entry is not IN_FLIGHT, AND the first entry is ABANDONED, remove and discard the first entry from the SEND_QUEUE;",
      "ja": "1. SEND_QUEUEは、少なくとも2つのエントリを含むが、最初のエントリはIN_FLIGHTではなく、最初のエントリを削除し、SEND_QUEUEから最初のエントリを破棄し、破棄されます。"
    },
    {
      "indent": 3,
      "text": "2. If the first entry in the SEND_QUEUE is not abandoned, set FSN to entry.SEQUENCE_NUMBER - 1; otherwise,",
      "ja": "2. SEND_QUEUEの最初のエントリが放棄されていない場合、entry.SEQUENCE_NUMBERにFSNを設定 -  1。そうでなければ、"
    },
    {
      "indent": 3,
      "text": "3. If the first entry in the SEND_QUEUE is IN_FLIGHT, AND entry.SENT_ABANDONED is false, set FSN to entry.SEQUENCE_NUMBER - 1; otherwise,",
      "ja": "3. SEND_QUEUEの最初のエントリがIN_FLIGHTで、entry.SENT_ABANDONEDがfalseの場合、entry.SEQUENCE_NUMBERにFSNを設定 -  1。そうでなければ、"
    },
    {
      "indent": 3,
      "text": "4. The first entry in the SEND_QUEUE is abandoned and either is not IN_FLIGHT or was already abandoned when sent; set FSN to entry.SEQUENCE_NUMBER.",
      "ja": "4. SEND_QUEUEの最初のエントリは、放棄されたいずれかIN_FLIGHTないか、または送信されたときに既に放棄しています。 entry.SEQUENCE_NUMBERにFSNを設定します。"
    },
    {
      "indent": 3,
      "text": "The FSN MUST NOT be greater than any sequence number currently outstanding. The FSN MUST NOT be equal to any sequence number currently outstanding that was not abandoned when sent.",
      "ja": "FSNは現在、優れた任意のシーケンス番号よりも大きくすることはできません。 FSNは、送信されたときに放棄されていなかった、現在未解決の任意のシーケンス番号と同じにすることはできません。"
    },
    {
      "indent": 3,
      "text": "Assemble user data chunks for this flow into a packet to send to the receiver. While enough space remains in the packet and the flow is ready to transmit:",
      "ja": "受信機に送信するパケットには、この流れのためのユーザ・データ・チャンクを組み立てます。十分なスペースは、パケットに残り、流れは、送信する準備ができているものの："
    },
    {
      "indent": 3,
      "text": "1. Starting at the head of the SEND_QUEUE, find the first eligible fragment entry;",
      "ja": "1. SEND_QUEUEの先頭から開始し、最初の適格なフラグメントエントリを見つけます。"
    },
    {
      "indent": 3,
      "text": "2. Encode the entry into a User Data chunk (Section 2.3.11) or, if possible (Section 3.6.2.3.2), a Next User Data chunk (Section 2.3.12);",
      "ja": "2.ユーザデータチャンク（セクション2.3.11）へのエントリまたは、可能な場合（セクション3.6.2.3.2）、次のユーザデータチャンク（セクション2.3.12）をコードします。"
    },
    {
      "indent": 3,
      "text": "3. If present, set chunk.flowID to flow.F_FLOW_ID;",
      "section_title": true,
      "ja": "3.存在する場合、chunk.flowIDはflow.F_FLOW_IDに設定。"
    },
    {
      "indent": 3,
      "text": "4. If present, set chunk.sequenceNumber to entry.SEQUENCE_NUMBER;",
      "section_title": true,
      "ja": "4.存在する場合、chunk.sequenceNumberはentry.SEQUENCE_NUMBERに設定します。"
    },
    {
      "indent": 3,
      "text": "5. If present, set chunk.fsnOffset to entry.SEQUENCE_NUMBER - FSN;",
      "section_title": true,
      "ja": "5.存在する場合、chunk.fsnOffsetはentry.SEQUENCE_NUMBERに設定 -  FSN。"
    },
    {
      "indent": 3,
      "text": "6. Set chunk.fragmentControl to entry.FRA;",
      "section_title": true,
      "ja": "entry.FRA 6.設定chunk.fragmentControl。"
    },
    {
      "indent": 3,
      "text": "7. Set chunk.abandon to entry.ABANDONED;",
      "section_title": true,
      "ja": "entry.ABANDONEDに設定7. chunk.abandon。"
    },
    {
      "indent": 3,
      "text": "8. If entry.SEQUENCE_NUMBER equals flow.F_FINAL_SN, set chunk.final to true; else set chunk.final to false;",
      "ja": "8. entry.SEQUENCE_NUMBERはflow.F_FINAL_SNに等しい場合は、trueに設定しchunk.final。それ以外の場合はfalseに設定しchunk.final。"
    },
    {
      "indent": 3,
      "text": "9. If any options are being sent with this chunk, set chunk.optionsPresent to true, assemble the options into the chunk, and assemble a Marker to terminate the option list;",
      "ja": "9.すべてのオプションは、このチャンクで送信されている場合は、チャンクにオプションを組み立て、そしてオプションリストを終了するマーカーを組み立て、trueにchunk.optionsPresentを設定します。"
    },
    {
      "indent": 3,
      "text": "10.  If entry.ABANDONED is true, set chunk.userData to empty;\n     otherwise, set chunk.userData to entry.DATA;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "11. If adding the assembled chunk to the packet would cause the packet to exceed the path MTU, do not assemble this chunk into the packet; enough space no longer remains in the packet; stop. Otherwise, continue:",
      "ja": "11.パケットに組み立てられたチャンクを追加することで、パケットにこのチャンクを組み立てていない、パスMTUを超過するパケットを起こした場合、十分なスペースは、もは​​やパケット内に残っていません。やめる。それ以外の場合は、継続します："
    },
    {
      "indent": 3,
      "text": "12. Set entry.IN_FLIGHT to true;",
      "section_title": true,
      "ja": "trueに設定する12. entry.IN_FLIGHT。"
    },
    {
      "indent": 3,
      "text": "13. Set entry.EVER_SENT to true;",
      "section_title": true,
      "ja": "trueに設定する13. entry.EVER_SENT。"
    },
    {
      "indent": 3,
      "text": "14. Set entry.NAK_COUNT to 0;",
      "section_title": true,
      "ja": "0 14.設定entry.NAK_COUNT。"
    },
    {
      "indent": 3,
      "text": "15. Set entry.SENT_ABANDONED to entry.ABANDONED;",
      "section_title": true,
      "ja": "entry.ABANDONEDにentry.SENT_ABANDONED 15セット。"
    },
    {
      "indent": 3,
      "text": "16. Set entry.TRANSMIT_SIZE to the size of the assembled chunk, including the chunk header;",
      "ja": "チャンクヘッダーを含む組み立てられたチャンクのサイズに16を設定entry.TRANSMIT_SIZE。"
    },
    {
      "indent": 3,
      "text": "17. Assemble this chunk into the packet; and",
      "section_title": true,
      "ja": "17パケットにこのチャンクをアセンブル。そして"
    },
    {
      "indent": 3,
      "text": "18. If this flow or entry is considered Time Critical (real-time), set the timeCritical flag in the packet header (Section 2.2.4).",
      "ja": "18.このフローまたはエントリがタイムクリティカル（リアルタイム）であると考えられる場合、パケットヘッダ（セクション2.2.4）にtimeCriticalフラグを設定します。"
    },
    {
      "indent": 3,
      "text": "Complete any other appropriate packet processing, and transmit the packet to the far end.",
      "ja": "任意の他の適切なパケット処理を完了し、遠端にパケットを送信します。"
    },
    {
      "indent": 0,
      "text": "3.6.2.3.1. Startup Options",
      "section_title": true,
      "ja": "3.6.2.3.1。起動オプション"
    },
    {
      "indent": 3,
      "text": "If STARTUP_OPTIONS is not empty, then when assembling the FIRST User Data chunk for this flow into a packet, add the encoded STARTUP_OPTIONS to that chunk's option list.",
      "ja": "STARTUP_OPTIONSが空でない場合、パケットには、この流れのための最初のユーザデータチャンクを組み立てる際に、そして、そのチャンクのオプションリストにエンコードSTARTUP_OPTIONSを追加します。"
    },
    {
      "indent": 0,
      "text": "3.6.2.3.2. Send Next Data",
      "section_title": true,
      "ja": "3.6.2.3.2。次のデータを送信します"
    },
    {
      "indent": 3,
      "text": "The Next User Data chunk (Section 2.3.12) is a compact encoding for a user message fragment when multiple contiguous fragments are assembled into one packet. Using this chunk where possible can conserve space in a packet, potentially reducing transmission overhead or allowing additional information to be sent in a packet.",
      "ja": "次のユーザデータチャンク（セクション2.3.12）は、複数の連続したフラグメントが1つのパケットに組み立てられるユーザメッセージフラグメントのためのコンパクトな符号化です。可能な場合、このチャンクを使用すると、潜在的に送信オーバーヘッドを低減または追加情報がパケットで送信できるように、パケット内のスペースを節約することができます。"
    },
    {
      "indent": 3,
      "text": "If, after assembling a user message fragment of a flow into a packet (Section 3.6.2.3), the next eligible fragment to be selected for assembly into that packet belongs to the same flow, AND its sequence number is one greater than that of the fragment just assembled, it is RECOMMENDED that an implementation encode a Next User Data chunk instead of a User Data chunk.",
      "ja": "、パケット（セクション3.6.2.3）への流れのユーザメッセージフラグメントを組み立てた後、次の対象断片がそのパケットに組み立てのために選択される場合、同じフローに属し、そのシーケンス番号がよりも1大きいです断片は、実装は次のユーザデータチャンクの代わりにユーザデータチャンクをエンコードすることが推奨され、組み立てられました。"
    },
    {
      "indent": 3,
      "text": "The FIRST fragment of a flow assembled into a packet MUST be encoded as a User Data chunk.",
      "ja": "パケットに組み立てフローの最初の断片は、ユーザデータチャンクとして符号化されなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.6.2.4. Processing Acknowledgements",
      "section_title": true,
      "ja": "3.6.2.4。処理謝辞"
    },
    {
      "indent": 3,
      "text": "A Data Acknowledgement Bitmap chunk (Section 2.3.13) or a Data Acknowledgement Ranges chunk (Section 2.3.14) encodes the acknowledgement of receipt of one or more sequence numbers of a flow, as well as the receiver's current receive window advertisement.",
      "ja": "データ確認応答ビットマップチャンク（セクション2.3.13）またはデータ肯定応答は、チャンク（セクション2.3.14）は、1つ又は複数の流れのシーケンス番号、ならびに受信機の現在の受信ウィンドウ広告の受信の肯定応答を符号化する範囲です。"
    },
    {
      "indent": 3,
      "text": "On receipt of an acknowledgement chunk for a sending flow:",
      "ja": "送信フローに対する肯定応答のチャンクを受信します："
    },
    {
      "indent": 3,
      "text": "1. Set PRE_ACK_OUTSTANDING_BYTES to flow.F_OUTSTANDING_BYTES;",
      "section_title": true,
      "ja": "flow.F_OUTSTANDING_BYTES 1.設定PRE_ACK_OUTSTANDING_BYTES。"
    },
    {
      "indent": 3,
      "text": "2. Set flow.STARTUP_OPTIONS to empty;",
      "section_title": true,
      "ja": "空へ2.設定flow.STARTUP_OPTIONS。"
    },
    {
      "indent": 3,
      "text": "3. Set flow.RX_BUFFER_SIZE to chunk.bufferBytesAvailable;",
      "section_title": true,
      "ja": "chunk.bufferBytesAvailable 3.設定flow.RX_BUFFER_SIZE。"
    },
    {
      "indent": 3,
      "text": "4. For each sequence number encoded in the acknowledgement, if there is an entry in flow.SEND_QUEUE with that sequence number and its IN_FLIGHT is true, then remove the entry from flow.SEND_QUEUE; and",
      "ja": "そこそのシーケンス番号を持つflow.SEND_QUEUEのエントリがあり、そのIN_FLIGHTが真である場合、次いでflow.SEND_QUEUEからエントリを削除し、肯定応答でエンコードされた各シーケンス番号4.。そして"
    },
    {
      "indent": 3,
      "text": "5. Notify the congestion control and avoidance algorithms that PRE_ACK_OUTSTANDING_BYTES - flow.F_OUTSTANDING_BYTES were acknowledged. Note that negative acknowledgements (Section 3.6.2.5) affect \"TCP friendly\" congestion control.",
      "ja": "flow.F_OUTSTANDING_BYTESが確認された -  5 PRE_ACK_OUTSTANDING_BYTES輻輳制御と回避アルゴリズムを通知します。否定応答（セクション3.6.2.5）は、「TCPフレンドリー」輻輳制御に影響を与えることに注意してください。"
    },
    {
      "indent": 0,
      "text": "3.6.2.5. Negative Acknowledgement and Loss",
      "section_title": true,
      "ja": "3.6.2.5。否定応答と損失"
    },
    {
      "indent": 3,
      "text": "A negative acknowledgement is inferred for an outstanding fragment if an acknowledgement is received for any other fragments sent after it in the same session.",
      "ja": "肯定応答は、同じセッション内で後に送信される任意の他のフラグメントを受信した場合、否定応答が未処理断片について推定されます。"
    },
    {
      "indent": 3,
      "text": "An implementation SHOULD consider a fragment to be lost once that fragment receives three negative acknowledgements. A lost fragment is no longer outstanding in the network.",
      "ja": "実装は、その断片が、3つの否定応答を受信するとフラグメントが失われるために検討すべきです。失われたフラグメントは、もはや優れたネットワークではありません。"
    },
    {
      "indent": 3,
      "text": "The following describes an OPTIONAL method for detecting negative acknowledgements.",
      "ja": "以下は、否定応答を検出するための任意の方法を記載しています。"
    },
    {
      "indent": 3,
      "text": "Let the session track the order in which fragments are transmitted across all its sending flows by way of a monotonically increasing Transmission Sequence Number (TSN) recorded with each fragment queue entry each time that fragment is transmitted.",
      "ja": "セッションは、フラグメントは、各フラグメントキューエントリとフラグメントが送信されるたびに記録された単調増加送信シーケンス番号（TSN）の方法によって、すべての送信のフローを介して送信される順序を追跡してみましょう。"
    },
    {
      "indent": 3,
      "text": "Let the session information context contain additional variables:",
      "ja": "セッション情報のコンテキストは、追加の変数が含まれてみましょう："
    },
    {
      "indent": 3,
      "text": "o NEXT_TSN: the next TSN to record with a fragment's queue entry when it is transmitted, initially 1;",
      "ja": "O NEXT_TSN：それが送信されると、最初は1、フラグメントのキューエントリを記録するために次のTSN。"
    },
    {
      "indent": 3,
      "text": "o MAX_TSN_ACK: the highest acknowledged TSN, initially 0.",
      "ja": "MAX_TSN_ACK O：最高認めTSN、最初は0。"
    },
    {
      "indent": 3,
      "text": "Let each fragment queue entry contain an additional variable TSN, initially 0, to track its transmission order.",
      "ja": "各フラグメントのキュー・エントリは、その送信順序を追跡するために、最初は0、追加の変数TSNを含んでいましょう。"
    },
    {
      "indent": 3,
      "text": "On transmission of a message fragment into the network, set its entry.TSN to session.NEXT_TSN, and increment session.NEXT_TSN.",
      "ja": "ネットワークへのメッセージフラグメントの送信に、session.NEXT_TSNへのentry.TSNを設定し、session.NEXT_TSNをインクリメントします。"
    },
    {
      "indent": 3,
      "text": "On acknowledgement of an outstanding fragment, if its entry.TSN is greater than session.MAX_TSN_ACK, set session.MAX_TSN_ACK to entry.TSN.",
      "ja": "未処理断片の確認応答に、そのentry.TSNはsession.MAX_TSN_ACKより大きい場合、entry.TSNにsession.MAX_TSN_ACKを設定。"
    },
    {
      "indent": 3,
      "text": "After processing all acknowledgements in a packet containing at least one acknowledgement, then for each sending flow in that session, for each entry in that flow's SEND_QUEUE, if entry.IN_FLIGHT is true and entry.TSN is less than session.MAX_TSN_ACK, increment entry.NAK_COUNT and notify the congestion control and avoidance algorithms that a negative acknowledgement was detected in this packet.",
      "ja": "entry.IN_FLIGHTが真であるとentry.TSNがsession.MAX_TSN_ACK未満である場合に少なくとも一つの肯定応答を含むパケット内のすべての肯定応答を処理した後、そのセッション内の各送信フローについて、そのフローのSEND_QUEUEの各エントリについて、エントリをインクリメント。否定応答は、このパケットで検出された輻輳制御と回避アルゴリズムをNAK_COUNTと通知します。"
    },
    {
      "indent": 3,
      "text": "For each sending flow in that session, for each entry in that flow's SEND_QUEUE, if entry.IN_FLIGHT is true and entry.NAK_COUNT is at least 3, that fragment was lost in the network and is no longer considered to be in flight. Set entry.IN_FLIGHT to false. Notify the congestion control and avoidance algorithms of the loss.",
      "ja": "entry.IN_FLIGHTが真であるとentry.NAK_COUNTは少なくとも3である場合、そのセッション内の各送信の流れについて、その流れのSEND_QUEUEの各エントリのために、その断片がネットワークで失われなかったし、もはや飛行中であると考えられています。 falseにentry.IN_FLIGHTを設定します。輻輳制御と損失の回避アルゴリズムを通知します。"
    },
    {
      "indent": 0,
      "text": "3.6.2.6. Timeout",
      "section_title": true,
      "ja": "3.6.2.6。タイムアウト"
    },
    {
      "indent": 3,
      "text": "A fragment is considered lost and no longer in flight in the network if it has remained outstanding for at least ERTO.",
      "ja": "それは、少なくともERTOのために優れ残っている場合はフラグメントは、ネットワーク内の飛行中、もはや失われたと考えられていません。"
    },
    {
      "indent": 3,
      "text": "The following describes an OPTIONAL method to manage transmission timeouts. This method REQUIRES that either burst avoidance (Section 3.5.2.3) is implemented or the implementation's congestion control and avoidance algorithms will eventually stop sending new fragments into the network if acknowledgements are persistently not received.",
      "ja": "以下は、送信のタイムアウトを管理するための任意の方法を説明します。この方法では、バースト回避（セクション3.5.2.3）のいずれかが実装されているか、実装の輻輳制御と回避アルゴリズムは、最終的に確認応答が永続的に受信されない場合、ネットワークに新たなフラグメントの送信を停止することを必要とします。"
    },
    {
      "indent": 3,
      "text": "Let the session information context contain an alarm TIMEOUT_ALARM, initially unset.",
      "ja": "セッション情報のコンテキストが最初に設定解除、警報TIMEOUT_ALARMが含まれてみましょう。"
    },
    {
      "indent": 3,
      "text": "On sending a packet containing at least one User Data chunk, set or reset TIMEOUT_ALARM to fire in ERTO.",
      "ja": "少なくとも1つのユーザデータチャンクを含むパケットを送信するには、設定またはERTOに発射するTIMEOUT_ALARMをリセットします。"
    },
    {
      "indent": 3,
      "text": "On receiving a packet containing at least one acknowledgement, reset TIMEOUT_ALARM (if already set) to fire in ERTO.",
      "ja": "少なくとも一つの肯定応答を含むパケットを受信すると、ERTOに発射するためにTIMEOUT_ALARMを（既に設定されている場合）にリセット。"
    },
    {
      "indent": 3,
      "text": "When TIMEOUT_ALARM fires:",
      "ja": "ときTIMEOUTアラーム火災："
    },
    {
      "indent": 3,
      "text": "1. Set WAS_LOSS = false;",
      "section_title": true,
      "ja": "1.設定WAS_LOSS =偽;"
    },
    {
      "indent": 3,
      "text": "2. For each sending flow in the session, and for each entry in that flow's SEND_QUEUE:",
      "ja": "各送信セッション中に流れ、その流れのSEND_QUEUEの各エントリの2.："
    },
    {
      "indent": 7,
      "text": "1. If entry.IN_FLIGHT is true, set WAS_LOSS = true; and",
      "section_title": true,
      "ja": "1. entry.IN_FLIGHTがtrueの場合、真WAS_LOSS =を設定します。そして"
    },
    {
      "indent": 7,
      "text": "2. Set entry.IN_FLIGHT to false.",
      "section_title": true,
      "ja": "falseに設定する2. entry.IN_FLIGHT。"
    },
    {
      "indent": 3,
      "text": "3. If WAS_LOSS is true, perform ERTO backoff (Section 3.5.2.2); and",
      "section_title": true,
      "ja": "3. WAS_LOSSがtrueの場合、ERTOバックオフ（セクション3.5.2.2）を行います。そして"
    },
    {
      "indent": 3,
      "text": "4. Notify the congestion control and avoidance algorithms of the timeout and, if WAS_LOSS is true, that there was loss.",
      "ja": "4.損失があったこと、WAS_LOSSが真である場合、タイムアウトの輻輳制御と回避アルゴリズムを通知し。"
    },
    {
      "indent": 0,
      "text": "3.6.2.7. Abandoning Data",
      "section_title": true,
      "ja": "3.6.2.7。データを放棄"
    },
    {
      "indent": 3,
      "text": "The application can abandon queued messages at any time and for any reason. Example reasons include (but are not limited to) the following: one or more fragments of a message have remained in the SEND_QUEUE for longer than a specified message lifetime; a fragment has been retransmitted more than a specified retransmission limit; a prior message on which this message depends (such as a key frame in a prediction chain) was abandoned and not delivered.",
      "ja": "放棄することができるアプリケーションは、いつでも、いかなる理由でメッセージをキューに入れられました。例示的な理由は、以下のものが挙げられる（これらに限定されない）：メッセージの1つのまたは複数のフラグメントが指定されたメッセージの有効期間よりも長くSEND_QUEUEに残っています。フラグメントは、指定された再送信の制限を超えて再送されています。このメッセージは、（例えば、予測チェーンのキーフレームのように）依存する前にメッセージを破棄し、配信されませんでした。"
    },
    {
      "indent": 3,
      "text": "To abandon a message fragment, set its SEND_QUEUE entry's ABANDON flag to true. When abandoning a message fragment, abandon all fragments of the message to which it belongs.",
      "ja": "メッセージフラグメントを放棄するには、trueにSEND_QUEUEエントリのABANDONフラグを設定します。メッセージフラグメントを放棄する場合、それが属するメッセージの全ての断片を放棄。"
    },
    {
      "indent": 3,
      "text": "An abandoned fragment MUST NOT be un-abandoned.",
      "ja": "捨てられた断片は、非放棄しているはずがありません。"
    },
    {
      "indent": 0,
      "text": "3.6.2.7.1. Forward Sequence Number Update",
      "section_title": true,
      "ja": "3.6.2.7.1。フォワードシーケンス番号を更新"
    },
    {
      "indent": 3,
      "text": "Abandoned data may leave gaps in the sequence number space of a flow. Gaps may cause the receiver to hold completely received messages for ordered delivery to allow for retransmission of the missing fragments. User Data chunks (Section 2.3.11) encode a Forward Sequence Number (FSN) to instruct the receiver that fragments with sequence numbers less than or equal to the FSN will not be transmitted or retransmitted.",
      "ja": "放棄されたデータフローのシーケンス番号空間のギャップを残すことができます。ギャップは、受信機が行方不明の断片の再送信を可能にするよう命じ配信のための完全に受信したメッセージを保持する可能性があります。ユーザデータチャンク（セクション2.3.11）は、送信または再送信されないFSN以下のシーケンス番号を有する断片レシーバを指示する転送シーケンス番号（FSN）をコードします。"
    },
    {
      "indent": 3,
      "text": "When the receiver has gaps in the received sequence number space and no non-abandoned message fragments remain in the SEND_QUEUE, the sender SHOULD transmit a Forward Sequence Number Update (FSN Update) comprising a User Data chunk marked abandoned, whose sequence number is the FSN and whose fsnOffset is 0. An FSN Update allows the receiver to skip gaps that will not be repaired and deliver received messages to the user. An FSN Update may be thought of as a transmission or retransmission of abandoned sequence numbers without actually sending the data.",
      "ja": "受信機は、受信したシーケンス番号空間のギャップを有し、全く非放棄メッセージフラグメントがSEND_QUEUEに残っていない場合、送信側はシーケンス番号FSNである放棄されたマークされたユーザデータチャンクを含むフォワードシーケンス番号を更新（FSN更新）を送信しなければなりませんそして、そのfsnOffset 0であるFSN更新が修復されないギャップをスキップして、ユーザに受信したメッセージを配信するレシーバを可能にします。 FSN更新は、実際にデータを送信せずに放棄されたシーケンス番号の送信または再送信と考えることができます。"
    },
    {
      "indent": 3,
      "text": "The method described in Section 3.6.2.3 (\"Sending Data\") generates FSN Updates when appropriate.",
      "ja": "セクション3.6.2.3（「データ送信」）に記載された方法は、適切な場合FSN更新を生成します。"
    },
    {
      "indent": 0,
      "text": "3.6.2.8. Examples",
      "section_title": true,
      "ja": "3.6.2.8。例"
    },
    {
      "indent": 4,
      "text": "Sender\n  |                   :\n1 |<---  Ack  ID=2, seq:0-16\n2 |--->  Data ID=2, seq#=25, fsnOff=9 (fsn=16)\n3 |--->  Data ID=2, seq#=26, fsnOff=10 (fsn=16)\n4 |<---  Ack  ID=2, seq:0-18\n5 |--->  Data ID=2, seq#=27, fsnOff=9 (fsn=18)\n6 |--->  Data ID=2, seq#=28, fsnOff=10 (fsn=18)\n  |                   :",
      "raw": true
    },
    {
      "indent": 3,
      "text": "There are 9 sequence numbers in flight with delayed acknowledgements.",
      "ja": "遅延確認応答と飛行中の9つのシーケンス番号があります。"
    },
    {
      "indent": 20,
      "text": "Figure 20: Normal Flow with No Loss",
      "ja": "図20：損失なしに通常フロー"
    },
    {
      "indent": 3,
      "text": " Sender\n   |                   :\n 1 |<---  Ack  ID=3, seq:0-30\n 2 |--->  Data ID=3, seq#=45, fsnOff=15 (fsn=30)\n 3 |<---  Ack  ID=3, seq:0-30, 32 (nack 31:1)\n 4 |--->  Data ID=3, seq#=46, fsnOff=16 (fsn=30)\n 5 |<---  Ack  ID=3, seq:0-30, 32, 34 (nack 31:2, 33:1)\n 6 |<---  Ack  ID=3, seq:0-30, 32, 34-35 (nack 31:3=lost, 33:2)\n 7 |--->  Data ID=3, seq#=47, fsnOff=15 (fsn=32, abandon 31)\n 8 |<---  Ack  ID=3, seq:0-30, 32, 34-36 (nack 33:3=lost)\n 9 |--->  Data ID=3, seq#=33, fsnOff=1 (fsn=32, retransmit 33)\n10 |<---  Ack  ID=3, seq:0-30, 32, 34-37\n11 |--->  Data ID=3, seq#=48, fsnOff=16 (fsn=32)\n   |                   :\n   |      (continues through seq#=59)\n   |                   :\n12 |--->  Data ID=3, seq#=60, fsnOff=28(fsn=32)\n13 |<---  Ack  ID=3, seq:0-30, 34-46\n14 |--->  Data ID=3, seq#=61, fsnOff=29 (fsn=32)\n15 |<---  Ack  ID=3, seq:0-32, 34-47\n16 |--->  Data ID=3, seq#=62, fsnOff=30 (fsn=32)\n17 |<---  Ack  ID=3, seq:0-47\n18 |--->  Data ID=3, seq#=63, fsnOff=16 (fsn=47)\n19 |<---  Ack  ID=3, seq:0-49\n20 |--->  Data ID=3, seq#=64, fsnOff=15 (fsn=49)\n   |                   :\n21 |<---  Ack  ID=3, seq:0-59\n22 |<---  Ack  ID=3, seq:0-59, 61 (nack 60:1)\n23 |<---  Ack  ID=3, seq:0-59, 61-62 (nack 60:2)\n24 |<---  Ack  ID=3, seq:0-59, 61-63 (nack 60:3=lost)\n25 |--->  Data ID=3, ABN=1, seq#=60, fsnOff=0 (fsn=60, abandon 60)\n26 |<---  Ack  ID=3, seq:0-59, 61-64\n   |                   :\n27 |<---  Ack  ID=3, seq:0-64",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Flow with sequence numbers 31, 33, and 60 lost in transit, and a pause at 64. 33 is retransmitted; 31 and 60 are abandoned. Note that line 25 is a Forward Sequence Number Update (Section 3.6.2.7.1).",
      "ja": "配列番号31、33、及び輸送中に失われた60、及び再送信される64 33で休止して流れます。 31と60は放棄されています。そのライン25は、フォワードシーケンス番号の更新（セクション3.6.2.7.1）であることに注意してください。"
    },
    {
      "indent": 25,
      "text": "Figure 21: Flow with Loss",
      "ja": "図21：損失と流れ"
    },
    {
      "indent": 0,
      "text": "3.6.2.9. Flow Control",
      "section_title": true,
      "ja": "3.6.2.9。フロー制御"
    },
    {
      "indent": 3,
      "text": "The flow receiver advertises the amount of new data it's willing to accept from the flow sender with the bufferBytesAvailable derived field of an acknowledgement (Sections 2.3.13 and 2.3.14).",
      "ja": "フロー受信機は、肯定応答（セクション2.3.13および2.3.14）のbufferBytesAvailable由来フィールドにフロー送信者から受け入れるの新しいデータの量をアドバタイズ。"
    },
    {
      "indent": 3,
      "text": "The flow sender MUST NOT send new data into the network if flow.F_OUTSTANDING_BYTES is greater than or equal to the most recently received buffer advertisement, unless flow.EXCEPTION is true (Section 3.6.2.3).",
      "ja": "flow.EXCEPTION（セクション3.6.2.3）が真でなければflow.F_OUTSTANDING_BYTESは、最後に受信バッファ広告以上であれば、フローの送信者は、ネットワークに新たなデータを送ってはいけません。"
    },
    {
      "indent": 0,
      "text": "3.6.2.9.1. Buffer Probe",
      "section_title": true,
      "ja": "3.6.2.9.1。バッファプローブ"
    },
    {
      "indent": 3,
      "text": "The flow sender is suspended if the most recently received buffer advertisement is zero and the flow hasn't been rejected by the receiver -- that is, while RX_BUFFER_SIZE is zero AND EXCEPTION is false. To guard against potentially lost acknowledgements that might reopen the receive window, a suspended flow sender SHOULD send a packet comprising a Buffer Probe chunk (Section 2.3.15) for this flow from time to time.",
      "ja": "RX_BUFFER_SIZEがゼロであると例外が偽である間、である - 最後に受信バッファの広告がゼロで、流れがレシーバによって拒否されていない場合、フロー送信者が中断されます。受信ウィンドウを再度開く可能性がある潜在的に失われた確認応答を防ぐために、一時停止フローの送信者は、随時、この流れのためのバッファプローブチャンク（セクション2.3.15）を含むパケットを送信すべきです。"
    },
    {
      "indent": 3,
      "text": "If the receive window advertisement transitions from non-zero to zero, the flow sender MAY send a Buffer Probe immediately and SHOULD send a probe within one second.",
      "ja": "ゼロに非ゼロからウィンドウ広告遷移を受け取った場合は、フローの送信者は、直ちにバッファプローブを送信することと、1秒以内のプローブを送るべきです。"
    },
    {
      "indent": 3,
      "text": "The initial period between Buffer Probes SHOULD be at least one second or ERTO, whichever is greater. The period between probes SHOULD increase over time, but the period between probes SHOULD NOT be more than one minute or ERTO, whichever is greater.",
      "ja": "バッファプローブ間の初期の期間は、大きい方の少なくとも一つの第二又はERTOでなければなりません。プローブ間の期間は、時間の経過と共に増加するはずであるが、プローブ間の期間は、いずれか大きい方を超える1分ERTO、すべきではありません。"
    },
    {
      "indent": 3,
      "text": "The flow sender SHOULD stop sending Buffer Probes if it is no longer suspended.",
      "ja": "それはもはや中断された場合、フロー送信者はバッファプローブの送信を停止してはなりません。"
    },
    {
      "indent": 0,
      "text": "3.6.2.10. Exception",
      "section_title": true,
      "ja": "3.6.2.10。例外"
    },
    {
      "indent": 3,
      "text": "The flow receiver can reject the flow at any time and for any reason. The flow receiver sends a Flow Exception Report (Section 2.3.16) when it has rejected a flow.",
      "ja": "フロー受信機は、いつでも、いかなる理由で流れを拒否することができます。フロー受信機は、それが流れを拒否したフロー例外レポート（セクション2.3.16）を送信します。"
    },
    {
      "indent": 3,
      "text": "On receiving a Flow Exception Report for a sending flow:",
      "ja": "送信フローのためのフロー例外レポートを受信します："
    },
    {
      "indent": 3,
      "text": "1. If the flow is F_OPEN, close the flow (Section 3.6.2.11) and notify the user that the far end reported an exception with the encoded exception code;",
      "ja": "1.フローがF_OPEN場合、遠端が符号化された例外コードに例外を報告することを流れ（セクション3.6.2.11）を閉じて、ユーザに通知します。"
    },
    {
      "indent": 3,
      "text": "2. Set the EXCEPTION flag to true; and",
      "section_title": true,
      "ja": "2.真の例外フラグを設定します。そして"
    },
    {
      "indent": 3,
      "text": "3. For each entry in SEND_QUEUE, set entry.ABANDONED = true.",
      "section_title": true,
      "ja": "SEND_QUEUE内の各エントリについて3. entry.ABANDONED = trueを設定します。"
    },
    {
      "indent": 0,
      "text": "3.6.2.11. Close",
      "section_title": true,
      "ja": "3.6.2.11。閉じる"
    },
    {
      "indent": 3,
      "text": "A sending flow is closed by the user or as a result of an exception. To close an F_OPEN flow:",
      "ja": "送信フローは、ユーザによってまたは例外の結果として閉じられています。 F_OPENの流れを閉じるには："
    },
    {
      "indent": 3,
      "text": "1. Move to the F_CLOSING state;",
      "section_title": true,
      "ja": "F_CLOSING状態1.移動し、"
    },
    {
      "indent": 3,
      "text": "2. If the SEND_QUEUE is not empty, AND the tail entry of the SEND_QUEUE has a sequence number of NEXT_SN - 1, AND the tail entry.EVER_SENT is false, set F_FINAL_SN to entry.SEQUENCE_NUMBER; else",
      "ja": "2. SEND_QUEUEは空ではなく、SEND_QUEUEの尾エントリはNEXT_SNのシーケンス番号がある場合は -  1を、テールentry.EVER_SENTが偽で、entry.SEQUENCE_NUMBERにF_FINAL_SNを設定します。他"
    },
    {
      "indent": 3,
      "text": "3. The SEND_QUEUE is empty, OR the tail entry does not have a sequence number of NEXT_SN - 1, OR the tail entry.EVER_SENT is true: enqueue a new SEND_QUEUE entry with entry.SEQUENCE_NUMBER = flow.NEXT_SN, entry.FRA = 0, and entry.ABANDONED = true, and set flow.F_FINAL_SN to entry.SEQUENCE_NUMBER.",
      "ja": "3. SEND_QUEUEは空で、OR尾エントリはNEXT_SNのシーケンス番号がありません -  1を、ORテールentry.EVER_SENTが真である：entry.SEQUENCE_NUMBER = flow.NEXT_SN、entry.FRA = 0で新しいSEND_QUEUEエントリをエンキュー、およびentry.ABANDONED =真、およびentry.SEQUENCE_NUMBERにflow.F_FINAL_SNを設定します。"
    },
    {
      "indent": 3,
      "text": "An F_CLOSING sending flow is complete when its SEND_QUEUE transitions to empty, indicating that all sequence numbers, including the FINAL_SN, have been acknowledged by the other end.",
      "ja": "そのSEND_QUEUE遷移が空にするときの流れを送るF_CLOSINGはFINAL_SNを含むすべてのシーケンス番号が、もう一方の端に認知されていることを示す、完了です。"
    },
    {
      "indent": 3,
      "text": "When an F_CLOSING sending flow becomes complete, move to the F_COMPLETE_LINGER state.",
      "ja": "F_CLOSING送信の流れが完全になると、F_COMPLETE_LINGER状態に移行します。"
    },
    {
      "indent": 3,
      "text": "A sending flow MUST remain in the F_COMPLETE_LINGER state for at least 130 seconds. After at least 130 seconds, move to the F_CLOSED state. The sending flow is now closed, its resources can be reclaimed, and its F_FLOW_ID MAY be used for a new sending flow.",
      "ja": "送信フローは、少なくとも130秒間F_COMPLETE_LINGER状態のままにしなければなりません。少なくとも130秒後、F_CLOSED状態に移行します。送信フローは終了いたしました、そのリソースを再利用することができ、そしてそのF_FLOW_IDは新しい送信フローのために使用されるかもしれません。"
    },
    {
      "indent": 0,
      "text": "3.6.3. Receiver",
      "section_title": true,
      "ja": "3.6.3。受信機"
    },
    {
      "indent": 3,
      "text": "Each receiving flow comprises the flow-specific information context necessary to receive that flow's messages from the sending end and deliver completed messages to the user. Each receiving flow context includes at least:",
      "ja": "各受信フローは、送信端からそのフローのメッセージを受信し、ユーザに完了メッセージを配信するために必要なフロー固有情報コンテキストを含みます。各受信フローコンテキストを少なくとも含みます。"
    },
    {
      "indent": 3,
      "text": "o RF_FLOW_ID: this flow's identifier;",
      "ja": "O RF_FLOW_ID：このフローの識別子。"
    },
    {
      "indent": 3,
      "text": "o SEQUENCE_SET: the set of all fragment sequence numbers seen in this receiving flow, whether received or abandoned, initially empty;",
      "ja": "O SEQUENCE_SET：この受信フローに見られる全てのフラグメントシーケンス番号のセット、受信または放棄されたかどうか、最初は空。"
    },
    {
      "indent": 3,
      "text": "o RF_FINAL_SN: the final fragment sequence number of the flow, initially having no value;",
      "ja": "入出力RF_FINAL_SN：フローの最終的な断片のシーケンス番号は、最初は値を持ちません。"
    },
    {
      "indent": 3,
      "text": "o RECV_BUFFER: the message fragments waiting to be delivered to the user, sorted by sequence number in ascending order, initially empty; each message fragment entry comprising the following:",
      "ja": "O RECV_BUFFER：メッセージフラグメントが空最初に、昇順のシーケンス番号によってソートされ、ユーザに配信されるのを待っています。以下を含む各メッセージフラグメントエントリ："
    },
    {
      "indent": 6,
      "text": "* SEQUENCE_NUMBER: the sequence number of this fragment;",
      "ja": "* SEQUENCE_NUMBER：このフラグメントのシーケンス番号。"
    },
    {
      "indent": 6,
      "text": "* DATA: this fragment's user data; and",
      "ja": "* DATA：このフラグメントのユーザーデータ。そして"
    },
    {
      "indent": 6,
      "text": "* FRA: the fragment control value for this message fragment, having one of the values enumerated for that purpose in Section 2.3.11 (\"User Data Chunk\").",
      "ja": "* FRA：このメッセージフラグメントについてのフラグメント制御値、セクション2.3.11（「ユーザデータチャンク」）で、その目的のために列挙された値の1つを有します。"
    },
    {
      "indent": 3,
      "text": "o BUFFERED_SIZE: the sum of the lengths of each fragment in RECV_BUFFER plus any additional storage overhead for the fragments incurred by the implementation, in bytes;",
      "ja": "O BUFFERED_SIZE：RECV_BUFFERの各断片の長さの合計を加えたバイト数、実装によって生じた断片のための任意の追加のストレージオーバーヘッド。"
    },
    {
      "indent": 3,
      "text": "o BUFFER_CAPACITY: the desired maximum size for the receive buffer, in bytes;",
      "ja": "O BUFFER_CAPACITY：バッファを受信するための所望の最大サイズ（バイト単位）。"
    },
    {
      "indent": 3,
      "text": "o PREV_RWND: the most recent receive window advertisement sent in an acknowledgement, in 1024-byte blocks, initially having no value;",
      "ja": "O PREV_RWND：最新のは最初は値を持たない、1024バイトのブロックで、確認応答で送信されたウィンドウ広告を受け取ります。"
    },
    {
      "indent": 3,
      "text": "o SHOULD_ACK: whether or not an acknowledgement should be sent for this flow, initially false;",
      "ja": "O SHOULD_ACK：確認応答がこの流れのために送られるべきかどうか、最初はfalse;"
    },
    {
      "indent": 3,
      "text": "o EXCEPTION_CODE: the exception code to report to the sender when the flow has been rejected, initially 0;",
      "ja": "O EXCEPTION_CODE：フローが拒否されたとき、送信者に報告する例外コード、最初は0;"
    },
    {
      "indent": 3,
      "text": "o The state, at any time being one of the following values: the open state RF_OPEN; the closing states RF_REJECTED and RF_COMPLETE_LINGER; and the closed state RF_CLOSED.",
      "ja": "次の値のいずれかである任意の時点で、状態O：オープン状態RF_OPENと、クローズ状態RF_REJECTEDとRF_COMPLETE_LINGER。そして、閉状態がRF_CLOSED。"
    },
    {
      "indent": 3,
      "text": "Note: The following diagram is only a summary of state transitions and their causing events, and is not a complete operational specification.",
      "ja": "注意：以下の図は、状態遷移とその原因となるイベントの概要だけで、完全な動作仕様ではありません。"
    },
    {
      "indent": 14,
      "text": "                         +-+\n                         |X|\n                         +-+\n                          |rcv User Data for\n                          |  no existing flow\n                          v\n                     +---------+\n                     | RF_OPEN |\n                     +---------+\nrcv all sequence numbers|   |user reject,\n        0..RF_FINAL_SN  |   |rcv bad option,\n                        |   |no metadata at open,\n                        |   |association specified\n                        |   |  but not F_OPEN at open\n                    +---+   |\n                    |       v\n                    |  +-----------+\n                    |  |RF_REJECTED|\n                    |  +-----------+\n                    |       |rcv all sequence numbers\n                    |       |  0..RF_FINAL_SN\n                    v       v\n               +------------------+\n               |RF_COMPLETE_LINGER|\n               +------------------+\n                        | 120 seconds\n                        v\n                   +---------+\n                   |RF_CLOSED|\n                   +---------+",
      "raw": true
    },
    {
      "indent": 18,
      "text": "Figure 22: Receiving Flow State Diagram",
      "ja": "図22：フロー状態図を受けます"
    },
    {
      "indent": 0,
      "text": "3.6.3.1. Startup",
      "section_title": true,
      "ja": "3.6.3.1。起動"
    },
    {
      "indent": 3,
      "text": "A new receiving flow starts on receipt of a User Data chunk (Section 2.3.11) encoding a flow ID not belonging to any other receiving flow in the same session in the RF_OPEN, RF_REJECTED, or RF_COMPLETE_LINGER states.",
      "ja": "新しい受信流れはRF_OPEN、RF_REJECTED、又はRF_COMPLETE_LINGER状態で同じセッション内の他の受信フローに属さないフローIDをコード化ユーザーデータチャンク（セクション2.3.11）の受信時に開始します。"
    },
    {
      "indent": 3,
      "text": "On receipt of such a User Data chunk:",
      "ja": "そのようなユーザーデータチャンクを受信します："
    },
    {
      "indent": 3,
      "text": "1. Set temporary variables METADATA, ASSOCIATED_FLOWID, and ASSOCIATION to each have no value;",
      "ja": "1.値を持たないそれぞれに一時変数メタデータ、ASSOCIATED_FLOWID、および関連付けを設定します。"
    },
    {
      "indent": 3,
      "text": "2. Create a new receiving flow context in this session, setting its RF_FLOW_ID to the flow ID encoded in the opening User Data chunk, and set to the RF_OPEN state;",
      "ja": "2.開口ユーザデータチャンクに符号化フローIDへのRF_FLOW_IDを設定する、このセッションで新しい受信フローコンテキストを作成し、RF_OPEN状態に設定。"
    },
    {
      "indent": 3,
      "text": "3. If the opening User Data chunk encodes a User's Per-Flow Metadata option (Section 2.3.11.1.1), set METADATA to option.userMetadata;",
      "ja": "3.オープニングユーザーデータチャンクがユーザーのフロー単位のメタデータオプション（セクション2.3.11.1.1）をコードする場合、option.userMetadataにメタデータを設定します。"
    },
    {
      "indent": 3,
      "text": "4. If the opening User Data chunk encodes a Return Flow Association option (Section 2.3.11.1.2), set ASSOCIATED_FLOWID to option.flowID;",
      "ja": "4.オープニングユーザーデータチャンクがリターンフロー協会オプション（セクション2.3.11.1.2）、option.flowIDに設定ASSOCIATED_FLOWIDをコードする場合、"
    },
    {
      "indent": 3,
      "text": "5. If METADATA has no value, the receiver MUST reject the flow (Section 3.6.3.7), moving it to the RF_REJECTED state;",
      "ja": "前記メタデータが値を持たない場合、受信機はRF_REJECTED状態に移動、流れ（セクション3.6.3.7）を拒絶しなければなりません。"
    },
    {
      "indent": 3,
      "text": "6. If ASSOCIATED_FLOWID has a value, then if there is no sending flow in the same session with a flow ID of ASSOCIATED_FLOWID, the receiver MUST reject the flow, moving it to the RF_REJECTED state; otherwise, set ASSOCIATION to the indicated sending flow;",
      "ja": "ASSOCIATED_FLOWID値を有する場合ASSOCIATED_FLOWIDのフローIDと同じセッションには送信フローが存在しない場合6.次いで、受信機はRF_REJECTED状態に移動、流れを拒絶しなければなりません。そうでなければ、示さ送信フローに関連付けを設定します。"
    },
    {
      "indent": 3,
      "text": "7. If ASSOCIATION indicates a sending flow, AND that sending flow's state is not F_OPEN, the receiver MUST reject this receiving flow, moving it to the RF_REJECTED state;",
      "ja": "協会は、送信フローを示しており、送信フローの状態がF_OPENないことならば、受信機はRF_REJECTED状態に移動、この受信フローを拒絶しなければなりません7。"
    },
    {
      "indent": 3,
      "text": "8. If the opening User Data chunk encodes any unrecognized option with a type code less than 8192 (Section 2.3.11.1), the receiver MUST reject the flow, moving it to the RF_REJECTED state;",
      "ja": "8開口ユーザデータチャンクは、タイプコードと認識されないオプション未満8192（セクション2.3.11.1）をコードする場合、受信機はRF_REJECTED状態に移動、流れを拒絶しなければなりません。"
    },
    {
      "indent": 3,
      "text": "9. If this new receiving flow is still RF_OPEN, then notify the user that a new receiving flow has opened, including the METADATA and, if present, the ASSOCIATION, and set flow.BUFFER_CAPACITY according to the user;",
      "ja": "9.この新しい受信フローが依然としてRF_OPENである場合には、メタデータと、存在する場合、ASSOCIATION含む新たな受信フローが開いたことをユーザに通知し、ユーザに応じて設定さflow.BUFFER_CAPACITY。"
    },
    {
      "indent": 3,
      "text": "10. Perform the normal data processing (Section 3.6.3.2) for the opening User Data chunk; and",
      "ja": "10開口ユーザデータチャンクのための通常のデータ処理（セクション3.6.3.2）を実行します。そして"
    },
    {
      "indent": 3,
      "text": "11. Set this session's ACK_NOW to true.",
      "section_title": true,
      "ja": "11. trueに、このセッションのACK_NOWを設定します。"
    },
    {
      "indent": 0,
      "text": "3.6.3.2. Receiving Data",
      "section_title": true,
      "ja": "3.6.3.2。データ受信中"
    },
    {
      "indent": 3,
      "text": "A User Data chunk (Section 2.3.11) or a Next User Data chunk (Section 2.3.12) encodes one fragment of a user data message of a flow, as well as the flow's Forward Sequence Number and potentially optional parameters (Section 2.3.11.1).",
      "ja": "ユーザーデータチャンク（セクション2.3.11）または次のユーザデータチャンク（セクション2.3.12）は、一つのフローのユーザデータメッセージの断片、ならびに流れの順方向シーケンス番号と、潜在的に任意のパラメータ（セクション2.3をコードします。 11.1）。"
    },
    {
      "indent": 3,
      "text": "On receipt of a User Data or Next User Data chunk:",
      "ja": "ユーザーデータや次のユーザーデータチャンクを受信します："
    },
    {
      "indent": 3,
      "text": "1. If chunk.flowID doesn't indicate an existing receiving flow in the same session in the RF_OPEN, RF_REJECTED, or RF_COMPLETE_LINGER state, perform the steps of Section 3.6.3.1 (\"Startup\") to start a new receiving flow;",
      "ja": "1. chunk.flowID新しい受信フローを開始するために、セクション3.6.3.1（「スタートアップ」）の手順を実行し、RF_OPEN、RF_REJECTED、又はRF_COMPLETE_LINGER状態で同じセッションに存在する受信フローを示していない場合。"
    },
    {
      "indent": 3,
      "text": "2. Retrieve the receiving flow context for the flow indicated by chunk.flowID;",
      "ja": "2. chunk.flowIDによって示される流れのための受信フローコンテキストを取得します。"
    },
    {
      "indent": 3,
      "text": "3. Set flow.SHOULD_ACK to true;",
      "section_title": true,
      "ja": "trueに設定する3. flow.SHOULD_ACK。"
    },
    {
      "indent": 3,
      "text": "4. If the flow is RF_OPEN, AND the chunk encodes any unrecognized option with a type code less than 8192 (Section 2.3.11.1), the flow MUST be rejected: notify the user of an exception, and reject the flow (Section 3.6.3.7), moving it to the RF_REJECTED state;",
      "ja": "流れがRF_OPENであり、チャンクタイプコード未満8192（セクション2.3.11.1）と認識されないオプションをコード4.場合、フローは拒絶しなければなりません：例外をユーザに通知し、フロー（3.6節を拒否する。 3.7）、RF_REJECTED状態に移動します。"
    },
    {
      "indent": 3,
      "text": "5. If the flow is not in the RF_OPEN state, set session.ACK_NOW to true;",
      "ja": "5.フローがRF_OPEN状態でない場合、session.ACK_NOWはtrueに設定します。"
    },
    {
      "indent": 3,
      "text": "6. If flow.PREV_RWND has a value and that value is less than 2 blocks, set session.ACK_NOW to true;",
      "ja": "6. flow.PREV_RWND値を持ち、その値が2つの未満のブロックである場合、session.ACK_NOWをtrueに設定します。"
    },
    {
      "indent": 3,
      "text": "7. If chunk.abandon is true, set session.ACK_NOW to true;",
      "section_title": true,
      "ja": "7. chunk.abandonがtrueの場合、trueにsession.ACK_NOWを設定します。"
    },
    {
      "indent": 3,
      "text": "8. If flow.SEQUENCE_SET has any gaps (that is, if it doesn't contain every sequence number from 0 through and including the highest sequence number in the set), set session.ACK_NOW to true;",
      "ja": "8. flow.SEQUENCE_SETは（それが0からを通じてすべてのシーケンス番号を含み、セット内の最高のシーケンス番号を含めない場合には、である）任意の間隙を有している場合、session.ACK_NOWをtrueに設定します。"
    },
    {
      "indent": 3,
      "text": "9. If flow.SEQUENCE_SET contains chunk.sequenceNumber, then this chunk is a duplicate: set session.ACK_NOW to true;",
      "ja": "9. flow.SEQUENCE_SETはchunk.sequenceNumberが含まれている場合、このチャンクは重複です：trueにsession.ACK_NOWを設定します。"
    },
    {
      "indent": 3,
      "text": "10. If flow.SEQUENCE_SET doesn't contain chunk.sequenceNumber, AND chunk.final is true, AND flow.RF_FINAL_SN has no value, then set flow.RF_FINAL_SN to chunk.sequenceNumber, and set session.ACK_NOW to true;",
      "ja": "10. flow.SEQUENCE_SETはchunk.sequenceNumberが含まれていない、とchunk.finalがtrueで、flow.RF_FINAL_SNが値を持たない、そしてchunk.sequenceNumberにflow.RF_FINAL_SNを設定し、trueにsession.ACK_NOWを設定した場合、"
    },
    {
      "indent": 3,
      "text": "11. If the flow is in the RF_OPEN state, AND flow.SEQUENCE_SET doesn't contain chunk.sequenceNumber, AND chunk.abandon is false, then create a new RECV_BUFFER entry for this chunk's data and set entry.SEQUENCE_NUMBER to chunk.sequenceNumber, entry.DATA to chunk.userData, and entry.FRA to chunk.fragmentControl, and insert this new entry into flow.RECV_BUFFER;",
      "ja": "11.フローはRF_OPEN状態にある、AND、flow.SEQUENCE_SETはchunk.sequenceNumberが含まれていない、とchunk.abandonがfalseで、このチャンクのデータのための新しいRECV_BUFFERエントリを作成し、chunk.sequenceNumberにentry.SEQUENCE_NUMBERを設定した場合chunk.fragmentControlにchunk.userData、およびentry.FRAにentry.DATA、およびflow.RECV_BUFFERにこの新しいエントリを挿入します。"
    },
    {
      "indent": 3,
      "text": "12. Add to flow.SEQUENCE_SET the range of sequence numbers from 0 through and including the chunk.forwardSequenceNumber derived field;",
      "ja": "12. 0から通ってchunk.forwardSequenceNumber派生フィールドを含むシーケンス番号の範囲をflow.SEQUENCE_SETに加えます。"
    },
    {
      "indent": 3,
      "text": "13. Add chunk.sequenceNumber to flow.SEQUENCE_SET;",
      "section_title": true,
      "ja": "13. flow.SEQUENCE_SETにchunk.sequenceNumberを追加します。"
    },
    {
      "indent": 3,
      "text": "14. If flow.SEQUENCE_SET now has any gaps, set session.ACK_NOW to true;",
      "ja": "14. flow.SEQUENCE_SETは今のギャップを持っている場合は、session.ACK_NOWはtrueに設定します。"
    },
    {
      "indent": 3,
      "text": "15. If session.ACK_NOW is false and session.DELACK_ALARM is not set, set session.DELACK_ALARM to fire in 200 milliseconds; and",
      "ja": "15. session.ACK_NOWがfalseで、session.DELACK_ALARMが設定されていない場合、200ミリ秒で起動するようにsession.DELACK_ALARMを設定します。そして"
    },
    {
      "indent": 3,
      "text": "16. Attempt delivery of completed messages in this flow's RECV_BUFFER to the user (Section 3.6.3.3).",
      "ja": "ユーザにこの流れのRECV_BUFFERで完成したメッセージの16試行配信（セクション3.6.3.3）。"
    },
    {
      "indent": 3,
      "text": "After processing all chunks in a packet containing at least one User Data chunk, increment session.RX_DATA_PACKETS by one. If session.RX_DATA_PACKETS is at least two, set session.ACK_NOW to true.",
      "ja": "少なくとも一つのユーザデータのチャンクを含むパケット内のすべてのチャンクを処理した後、いずれかによってsession.RX_DATA_PACKETSをインクリメントします。 session.RX_DATA_PACKETSは少なくとも2である場合、session.ACK_NOWはtrueに設定します。"
    },
    {
      "indent": 3,
      "text": "A receiving flow that is not in the RF_CLOSED state is ready to send an acknowledgement if its SHOULD_ACK flag is set. Acknowledgements for receiving flows that are ready are sent either opportunistically by piggybacking on a packet that's already sending user data or an acknowledgement (Section 3.6.3.4.6), or when the session's ACK_NOW flag is set (Section 3.6.3.4.5).",
      "ja": "RF_CLOSED状態でない受信フローは、そのSHOULD_ACKフラグが設定されている場合に肯定応答を送信する準備ができています。準備されたフローを受信するための謝辞日和見既にユーザデータ又は確認応答（セクション3.6.3.4.6）を送信だパケット、またはセッションのACK_NOWフラグがセットされている（セクション3.6.3.4.5）にピギーバックすることによってのいずれかで送信されます。"
    },
    {
      "indent": 0,
      "text": "3.6.3.3. Buffering and Delivering Data",
      "section_title": true,
      "ja": "3.6.3.3。バッファリングおよびデータ配信"
    },
    {
      "indent": 3,
      "text": "A receiving flow's information context contains a RECV_BUFFER for reordering, reassembling, and holding the user data messages of the flow. Only complete messages are delivered to the user; an implementation MUST NOT deliver partially received messages, except by special arrangement with the user.",
      "ja": "受信フローの情報コンテキストは再組み立て、およびフローのユーザデータメッセージを保持し、並べ替えのためRECV_BUFFERが含まれています。唯一の完全なメッセージがユーザーに配信されます。実装は、ユーザーとの特別な取り決めによる場合を除いて、部分的に受信したメッセージを届けるてはなりません。"
    },
    {
      "indent": 3,
      "text": "Let the Cumulative Acknowledgement Sequence Number (CSN) be the highest number in the contiguous range of numbers in SEQUENCE_SET starting with 0. For example, if SEQUENCE_SET contains {0, 1, 2, 3, 5, 6}, the contiguous range starting with 0 is 0..3, so the CSN is 3.",
      "ja": "SEQUENCE_SETが含まれている場合、累積確認応答シーケンス番号（CSN）は、例えば0から始まるSEQUENCE_SETの数字の連続した範囲内の最高数とする、{0、1、2、3、5、6}、連続した範囲が始まります0は0..3ので、CSNは3です。"
    },
    {
      "indent": 3,
      "text": "A message is complete if all of its fragments are present in the RECV_BUFFER. The fragments of one message have contiguous sequence numbers. A message can be either a single fragment, whose fragment control value is 0-whole, or two or more fragments where the first's fragment control value is 1-begin, followed by zero or more fragments with control value 3-middle, and terminated by a last fragment with control value 2-end.",
      "ja": "そのフラグメントの全てがRECV_BUFFERに存在している場合、メッセージは完了です。一つのメッセージの断片は、連続したシーケンス番号を持っています。メッセージは、単一のその断片の制御値が0全体で断片、または初フラグメント制御値が制御値3中間ゼロ以上のフラグメントが続き、によって終了、1-始まる2つの以上のフラグメントのいずれかとすることができます制御値2端部を有する最後のフラグメント。"
    },
    {
      "indent": 3,
      "text": "An incomplete message segment is a contiguous sequence of one or more fragments that do not form a complete message -- that is, a 1-begin followed by zero or more 3-middle fragments but with no 2-end, or zero or more 3-middle fragments followed by a 2-end but with no 1-begin, or one or more 3-middle fragments with neither a 1-begin nor a 2-end.",
      "ja": "不完全なメッセージセグメントは、完全なメッセージを形成しない1以上の断片の連続した配列である - つまり、1-始めるゼロ以上3中間断片ではなく、NO 2端と、続いて、またはゼロ以上3 -middle断片は、2エンドではなく、1-開始、または1-始まるも2端も有する1つ以上の3中間フラグメントなしで続きます。"
    },
    {
      "indent": 3,
      "text": "Incomplete message segments can either be in progress or abandoned. An incomplete segment is abandoned in the following cases:",
      "ja": "不完全なメッセージセグメントはいずれか進行中であるか、または放棄することができます。不完全なセグメントは、次の場合に破棄されます。"
    },
    {
      "indent": 3,
      "text": "o The sequence number of the segment's first fragment is less than or equal to the CSN, AND that fragment's control value is not 1-begin; or",
      "ja": "Oセグメントの最初のフラグメントのシーケンス番号は、CSN以下である、その断片の制御値は、1-開始ありません。または"
    },
    {
      "indent": 3,
      "text": "o The sequence number of the segment's last fragment is less than the CSN.",
      "ja": "Oセグメントの最後のフラグメントのシーケンス番号は、CSNよりも小さいです。"
    },
    {
      "indent": 3,
      "text": "Abandoned message segments will never be completed, so they SHOULD be removed from the RECV_BUFFER to make room in the advertised receive window and the receiver's memory for messages that can be completed.",
      "ja": "放棄されたメッセージのセグメントが完了することはありませんので、それらを受け取る広告ウィンドウと完了することができ、メッセージのための受信機のメモリに空きを作るためにRECV_BUFFERから削除する必要があります。"
    },
    {
      "indent": 3,
      "text": "The user can suspend delivery of a flow's messages. A suspended receiving flow holds completed messages in its RECV_BUFFER until the user resumes delivery. A suspended flow can cause the receive window advertisement to go to zero even when the BUFFER_CAPACITY is non-zero; this is described in detail in Section 3.6.3.5 (\"Flow Control\").",
      "ja": "ユーザーは、フローのメッセージの配信を一時停止することができます。ユーザーが配信を再開するまで一時停止の受信フローは、そのRECV_BUFFERで完成したメッセージを保持しています。中断の流れはBUFFER_CAPACITYがゼロでない場合でも、ゼロに行くウィンドウ広告を受け取る引き起こす可能性があります。これは、セクション3.6.3.5（「フロー制御」）に詳細に記載されています。"
    },
    {
      "indent": 3,
      "text": "When the receiving flow is not suspended, the original queuing order of the messages is recovered by delivering, in ascending sequence number order, complete messages in the RECV_BUFFER whose sequence numbers are less than or equal to the CSN.",
      "ja": "受信フローが中断されていない場合、メッセージの元の待ち行列の順序は、シーケンス番号の昇順に、シーケンス番号は以下CSNに等しいRECV_BUFFERで完全なメッセージを送達することによって回収されます。"
    },
    {
      "indent": 3,
      "text": "The following describes a method for discarding abandoned message segments and delivering complete messages in original queuing order when the receiving flow is not suspended.",
      "ja": "以下は放棄されたメッセージのセグメントを破棄し、受信フローが中断されていない場合、元の待ち行列の順序で完了メッセージを配信するための方法を記載しています。"
    },
    {
      "indent": 3,
      "text": "While the first fragment entry in the RECV_BUFFER has a sequence number less than or equal to the CSN and delivery is still possible:",
      "ja": "RECV_BUFFERにおける最初のフラグメントエントリがCSNにシーケンス番号以下であり、送達が依然として可能であるが。"
    },
    {
      "indent": 3,
      "text": "1. If entry.FRA is 0-whole, deliver entry.DATA to the user, and remove this entry from RECV_BUFFER; otherwise,",
      "ja": "1. entry.FRA 0-全体ある場合、ユーザにentry.DATAを提供し、RECV_BUFFERからこのエントリを削除します。そうでなければ、"
    },
    {
      "indent": 3,
      "text": "2. If entry.FRA is 2-end or 3-middle, this entry belongs to an abandoned segment, so remove and discard this entry from RECV_BUFFER; otherwise,",
      "ja": "2. entry.FRA 2末端または3中間である場合、このエントリが放棄されたセグメントに属しているので、RECV_BUFFERからこのエントリを削除し、破棄、そうでなければ、"
    },
    {
      "indent": 3,
      "text": "3. Entry.FRA is 1-begin. Let LAST_ENTRY be the last RECV_BUFFER entry that is part of this message segment (LAST_ENTRY can be entry if the segment has only one fragment so far). Then:",
      "ja": "3. Entry.FRAは1-始まりです。 LAST_ENTRYこのメッセージセグメント（セグメントがこれまで唯一のフラグメントを有する場合LAST_ENTRYエントリであり得る）の一部であり、最後RECV_BUFFERエントリとします。その後："
    },
    {
      "indent": 7,
      "text": "1.  If LAST_ENTRY.FRA is 2-end, this segment is a complete\n    message, so concatenate the DATA fields of each fragment\n    entry of this segment in ascending sequence number order and\n    deliver the complete message to the user, then remove the\n    entries for this complete message from RECV_BUFFER;\n    otherwise,",
      "raw": true
    },
    {
      "indent": 7,
      "text": "2. If LAST_ENTRY.SEQUENCE_NUMBER is less than CSN, this segment is incomplete and abandoned, so remove and discard the entries for this segment from RECV_BUFFER; otherwise,",
      "ja": "2. LAST_ENTRY.SEQUENCE_NUMBERがCSNよりも小さい場合、このセグメントが不完全と放棄されたので、RECV_BUFFERからこのセグメントのエントリを削除して破棄。そうでなければ、"
    },
    {
      "indent": 7,
      "text": "3. LAST_ENTRY.SEQUENCE_NUMBER is equal to CSN and LAST_ENTRY.FRA is not 2-end: this segment is incomplete but still in progress. Ordered delivery is no longer possible until at least one more fragment is received. Stop.",
      "ja": "3. LAST_ENTRY.SEQUENCE_NUMBERは、CSNとLAST_ENTRY.FRAに等しい2エンドではない：このセグメントは不完全まだ進行中です。少なくとももう1つのフラグメントが受信されるまで、規則正しい配信はもはや不可能です。やめる。"
    },
    {
      "indent": 3,
      "text": "If flow.RF_FINAL_SN has a value and is equal to the CSN, AND RECV_BUFFER is empty, all complete messages have been delivered to the user, so notify the user that the flow is complete.",
      "ja": "flow.RF_FINAL_SNが値を持っており、CSNに等しく、RECV_BUFFERが空の場合、すべての完全なメッセージがユーザーに配信するので、流れが完了したことをユーザに通知されています。"
    },
    {
      "indent": 0,
      "text": "3.6.3.4. Acknowledging Data",
      "section_title": true,
      "ja": "3.6.3.4。データを認識し"
    },
    {
      "indent": 3,
      "text": "A flow receiver SHOULD acknowledge all user data fragment sequence numbers seen in that flow. Acknowledgements drive the sender's congestion control and avoidance algorithms, clear data from the sender's buffers, and in some sender implementations clock new data into the network; therefore, the acknowledgements must be accurate and timely.",
      "ja": "フロー受信機は、そのフローに見られるすべてのユーザーデータフラグメントのシーケンス番号を確認すべきです。謝辞は、ネットワークに新しいデータを送信側の輻輳制御と回避アルゴリズムを駆動し、送信側のバッファから明確なデータ、およびいくつかの送信者の実装のクロックで、そのため、確認応答は、正確かつタイムリーでなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.6.3.4.1. Timing",
      "section_title": true,
      "ja": "3.6.3.4.1。タイミング"
    },
    {
      "indent": 3,
      "text": "For reasons similar to those discussed in Section 4.2.3.2 of RFC 1122 [RFC1122], it is advantageous to delay sending acknowledgements for a short time, so that multiple data fragments can be acknowledged in a single transmission. However, it is also advantageous for a sender to receive timely notification about the receiver's disposition of the flow, particularly in unusual or exceptional circumstances, so that the circumstances can be addressed if possible.",
      "ja": "RFC 1122のセクション4.2.3.2 [RFC1122]で説明したものと同様の理由から、複数のデータフラグメントが単一の送信に肯定応答することができるように、短時間の確認応答を送信遅延することが有利です。可能であれば状況に対処できるように、送信者は、特に異常なまたは例外的な状況では、フローの受信機の配置についてタイムリーな通知を受信するためしかし、それはまた、有利です。"
    },
    {
      "indent": 3,
      "text": "Therefore, a flow receiver SHOULD send an acknowledgement for a flow as soon as is practical in any of the following circumstances:",
      "ja": "したがって、フロー受信機は、以下の状況のいずれかにおいて実用的であるとすぐに流れのための確認応答を送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "o On receipt of a User Data chunk that starts a new flow;",
      "ja": "新しいフローを開始ユーザーデータチャンクを受信すると、O。"
    },
    {
      "indent": 3,
      "text": "o On receipt of a User Data or Next User Data chunk if the flow is not in the RF_OPEN state;",
      "ja": "Oユーザーデータまたは次のユーザデータチャンクを受信すると流れがRF_OPEN状態にない場合、"
    },
    {
      "indent": 3,
      "text": "o On receipt of a User Data chunk where, before processing the chunk, the SEQUENCE_SET of the indicated flow does not contain every sequence number between 0 and the highest sequence number in the set (that is, if there was a sequence number gap before processing the chunk);",
      "ja": "シーケンス番号のギャップを処理する前にあった場合、Oユーザーデータチャンクを受信するチャンクを処理する前に、指示された流れのSEQUENCE_SETは0〜セット内の最高のシーケンス番号（つまり、すべてのシーケンス番号を含まない場合、チャンク）;"
    },
    {
      "indent": 3,
      "text": "o On receipt of a User Data chunk where, after processing the chunk, the flow's SEQUENCE_SET does not contain every sequence number between 0 and the highest sequence number in the set (that is, if this chunk causes a sequence number gap);",
      "ja": "Oチャンクを処理した後、フローのSEQUENCE_SETが0とセット内の最高のシーケンス番号（このチャンクは、シーケンス番号のギャップを生じさせる場合には、である）との間のすべてのシーケンス番号が含まれていないユーザデータチャンクを受信します。"
    },
    {
      "indent": 3,
      "text": "o On receipt of a Buffer Probe for the flow;",
      "ja": "Oフローに対するバッファプローブを受信します。"
    },
    {
      "indent": 3,
      "text": "o On receipt of a User Data chunk if the last acknowledgement sent for the flow indicated fewer than two bufferBlocksAvailable;",
      "ja": "Oフローに対して送信された最後の確認応答がより少ない2 bufferBlocksAvailableを示した場合、ユーザーデータチャンクを受信します。"
    },
    {
      "indent": 3,
      "text": "o On receipt of a User Data or Next User Data chunk for the flow if, after processing the chunk, the flow's BUFFER_CAPACITY is not at least 1024 bytes greater than BUFFERED_SIZE;",
      "ja": "Oフローのためのユーザー・データまたは次のユーザデータチャンクを受信する場合には、チャンクを処理した後、フローのBUFFER_CAPACITYはBUFFERED_SIZEより少なくとも1024バイト大きくありません。"
    },
    {
      "indent": 3,
      "text": "o On receipt of a User Data or Next User Data chunk for any sequence number that was already seen (that is, on receipt of a duplicate);",
      "ja": "Oユーザーデータまたは既に見られた任意のシーケンス番号の次のユーザデータチャンクを受信すると（つまり、重複の受信時に、です）。"
    },
    {
      "indent": 3,
      "text": "o On the first receipt of the final sequence number of the flow;",
      "ja": "Oフローの最終シーケンス番号の最初受信します。"
    },
    {
      "indent": 3,
      "text": "o On receipt of two packets in the session that contain user data for any flows since an acknowledgement was last sent, the new acknowledgements being for the flows having any User Data chunks in the received packets (that is, for every second packet containing user data);",
      "ja": "O任意のフローのためのユーザデータを含むセッション内の2つのパケットの受信に肯定応答は新しい確認応答が受信されたパケット内の任意のユーザーデータチャンクを有するフローのためである、最後に送られたため（すなわち、ユーザデータを含むすべての第2のパケットのために、あります）;"
    },
    {
      "indent": 3,
      "text": "o After receipt of a User Data chunk for the flow, if an acknowledgement for any other flow is being sent (that is, consolidate acknowledgements);",
      "ja": "Oフローのためのユーザデータチャンクを受信すると、他のフローのための肯定応答が送信されている場合、後に（つまり、肯定応答を統合）。"
    },
    {
      "indent": 3,
      "text": "o After receipt of a User Data chunk for the flow, if any user data for a sending flow is being sent in a packet and if there is space available in the same packet (that is, attempt to piggyback an acknowledgement with user data if possible);",
      "ja": "O、フローのためのユーザデータチャンクを受信した後に送信フローのための任意のユーザデータがパケットで送信され、同じパケットに空きがある場合（つまり、可能な場合、ユーザデータと受信確認をピギーバックしようとしている場合）;"
    },
    {
      "indent": 3,
      "text": "o No longer than 200 milliseconds after receipt of a User Data chunk for the flow.",
      "ja": "Oもはや流れのためのユーザ・データ・チャンクの受領後200ミリ秒以下です。"
    },
    {
      "indent": 0,
      "text": "3.6.3.4.2. Size and Truncation",
      "section_title": true,
      "ja": "3.6.3.4.2。サイズと切り捨て"
    },
    {
      "indent": 3,
      "text": "Including an encoded acknowledgement in a packet might cause the packet to exceed the path MTU. In that case:",
      "ja": "パケット内のエンコードされた確認応答を含むパケットがパスMTUを超過することがあります。その場合には："
    },
    {
      "indent": 3,
      "text": "o If the packet is being sent primarily to send an acknowledgement, AND this is the first acknowledgement in the packet, truncate the acknowledgement so that the packet does not exceed the path MTU; otherwise,",
      "ja": "パケットが確認応答を送信するために主に送信され、これは、パケットの最初の肯定応答である場合、パケットはパスMTUを超えないようにO、肯定応答を切り捨てます。そうでなければ、"
    },
    {
      "indent": 3,
      "text": "o The acknowledgement is being piggybacked in a packet with user data or with an acknowledgement for another flow: do not include this acknowledgement in the packet, and send it later.",
      "ja": "O承認は、ユーザデータを持つまたは他のフローに対する肯定応答のパケットにピギーバックされている：パケットでこの確認を含めて、後でそれを送信しないでください。"
    },
    {
      "indent": 0,
      "text": "3.6.3.4.3. Constructing",
      "section_title": true,
      "ja": "3.6.3.4.3。構築"
    },
    {
      "indent": 3,
      "text": "The Data Acknowledgement Bitmap chunk (Section 2.3.13) and Data Acknowledgement Ranges chunk (Section 2.3.14) encode a receiving flow's SEQUENCE_SET and its receive window advertisement. The two chunks are semantically equivalent; implementations SHOULD send whichever provides the most compact encoding of the SEQUENCE_SET.",
      "ja": "データ確認応答ビットマップチャンク（セクション2.3.13）とデータ謝辞チャンク（セクション2.3.14）は受信フローのSEQUENCE_SET及びその受信ウィンドウ広告を符号化する範囲。 2つのチャンクは、意味的に等価です。実装はSEQUENCE_SETの最もコンパクトな符号化を提供する方送ります。"
    },
    {
      "indent": 3,
      "text": "When assembling an acknowledgement for a receiving flow:",
      "ja": "受信フローに対する肯定応答を組み立てる際："
    },
    {
      "indent": 3,
      "text": "1. If the flow's state is RF_REJECTED, first assemble a Flow Exception Report chunk (Section 2.3.16) for flow.flowID;",
      "ja": "1.流れの状態が最初のflow.flowIDのフロー例外レポートのチャンク（セクション2.3.16）を組み立て、RF_REJECTEDであれば、"
    },
    {
      "indent": 3,
      "text": "2. Choose the acknowledgement chunk type that most compactly encodes flow.SEQUENCE_SET;",
      "ja": "2.最もコンパクトflow.SEQUENCE_SETをコードして確認チャンクタイプを選択します。"
    },
    {
      "indent": 3,
      "text": "3. Use the method described in Section 3.6.3.5 (\"Flow Control\") to determine the value for the acknowledgement chunk's bufferBlocksAvailable field.",
      "ja": "3.確認のチャンクのbufferBlocksAvailableフィールドの値を決定するために、セクション3.6.3.5（「フロー制御」）に記載の方法を使用します。"
    },
    {
      "indent": 0,
      "text": "3.6.3.4.4. Delayed Acknowledgement",
      "section_title": true,
      "ja": "3.6.3.4.4。遅延確認応答"
    },
    {
      "indent": 3,
      "text": "As discussed in Section 3.6.3.4.1 (\"Timing\"), a flow receiver can delay sending an acknowledgement for up to 200 milliseconds after receiving user data. The method described in Section 3.6.3.2 (\"Receiving Data\") sets the session's DELACK_ALARM.",
      "ja": "セクション3.6.3.4.1（「タイミング」）で説明したように、フロー受信機は、ユーザデータを受信した後、最大200ミリ秒の確認応答を送信遅延させることができます。 3.6.3.2項（「データ受信」）に記載された方法は、セッションのDELACK_ALARMを設定します。"
    },
    {
      "indent": 3,
      "text": "When DELACK_ALARM fires, set ACK_NOW to true.",
      "ja": "DELACK_ALARM火災は、trueにACK_NOWを設定した場合。"
    },
    {
      "indent": 0,
      "text": "3.6.3.4.5. Obligatory Acknowledgement",
      "section_title": true,
      "ja": "3.6.3.4.5。必須謝辞"
    },
    {
      "indent": 3,
      "text": "One or more acknowledgements should be sent as soon as is practical when the session's ACK_NOW flag is set. While the ACK_NOW flag is set:",
      "ja": "一つ以上の確認応答は、セッションのACK_NOWフラグが設定されている場合に実用的であるとすぐに送られるべきです。 ACK_NOWフラグがセットされている間："
    },
    {
      "indent": 3,
      "text": "1. Choose a receiving flow that is ready to send an acknowledgement;",
      "section_title": true,
      "ja": "1.確認応答を送信する準備ができている受信フローを選択してください。"
    },
    {
      "indent": 3,
      "text": "2. If there is no such flow, there is no work to do, set ACK_NOW to false, set RX_DATA_PACKETS to 0, clear the DELACK_ALARM, and stop; otherwise,",
      "ja": "2.そのような流れが存在しない場合には、やるべき仕事決してありませんが、falseにACK_NOWを設定し、0にRX_DATA_PACKETSを設定DELACK_ALARMをクリアし、停止します。そうでなければ、"
    },
    {
      "indent": 3,
      "text": "3. Start a new packet;",
      "section_title": true,
      "ja": "3.新しいパケットを開始します。"
    },
    {
      "indent": 3,
      "text": "4. Assemble an acknowledgement for the flow and include it in the packet, truncating it if necessary so that the packet doesn't exceed the path MTU;",
      "ja": "4.フローに対する肯定応答を組み立て、パケットが経路MTUを超えないように必要に応じて切り捨て、パケットに含めます。"
    },
    {
      "indent": 3,
      "text": "5. Set flow.SHOULD_ACK to false;",
      "section_title": true,
      "ja": "falseに設定する5. flow.SHOULD_ACK。"
    },
    {
      "indent": 3,
      "text": "6. Set flow.PREV_RWND to the bufferBlocksAvailable field of the included acknowledgement chunk;",
      "ja": "6.セットが含ま承認チャンクのbufferBlocksAvailable分野にflow.PREV_RWND。"
    },
    {
      "indent": 3,
      "text": "7. Attempt to piggyback acknowledgements for any other flows that are ready to send an acknowledgement into the packet, as described below; and",
      "ja": "以下に説明するように、パケットに確認応答を送信する準備ができている他のフローの確認応答をピギーバックする試み7。そして"
    },
    {
      "indent": 3,
      "text": "8. Send the packet.",
      "section_title": true,
      "ja": "8.パケットを送信します。"
    },
    {
      "indent": 0,
      "text": "3.6.3.4.6. Opportunistic Acknowledgement",
      "section_title": true,
      "ja": "3.6.3.4.6。日和見謝辞"
    },
    {
      "indent": 3,
      "text": "When sending a packet with user data or an acknowledgement, any other receiving flows that are ready to send an acknowledgement should include their acknowledgements in the packet if possible.",
      "ja": "ユーザデータや受信確認のパケットを送信するときに、可能な場合、確認応答を送信する準備ができている任意の他の受信フローは、パケットに自分の謝辞を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "To piggyback acknowledgements in a packet that is already being sent, where the packet contains user data or an acknowledgement, while there is at least one receiving flow that is ready to send an acknowledgement:",
      "ja": "確認応答を送信する準備ができている少なくとも一つの受信フローがある間、パケットが、ユーザデータ又は確認応答が含ま既に送信されたパケットに肯定応答をピギーバックします。"
    },
    {
      "indent": 3,
      "text": "1. Assemble an acknowledgement for the flow;",
      "section_title": true,
      "ja": "1.流れのための肯定応答をアセンブル。"
    },
    {
      "indent": 3,
      "text": "2. If the acknowledgement cannot be included in the packet without exceeding the path MTU, the packet is full; stop. Otherwise,",
      "ja": "2.確認がパスMTUを超えることなく、パケットに含めることができない場合、パケットが満杯です。やめる。そうでなければ、"
    },
    {
      "indent": 3,
      "text": "3. Include the acknowledgement in the packet;",
      "section_title": true,
      "ja": "3.パケットに確認応答を含めます。"
    },
    {
      "indent": 3,
      "text": "4. Set flow.SHOULD_ACK to false;",
      "section_title": true,
      "ja": "falseに設定する4. flow.SHOULD_ACK。"
    },
    {
      "indent": 3,
      "text": "5. Set flow.PREV_RWND to the bufferBlocksAvailable field of the included acknowledgement chunk; and",
      "ja": "5.セットが含ま承認チャンクのbufferBlocksAvailable分野にflow.PREV_RWND。そして"
    },
    {
      "indent": 3,
      "text": "6. If there are no longer any receiving flows in the session that are ready to send an acknowledgement, set session.ACK_NOW to false, set session.RX_DATA_PACKETS to 0, and clear session.DELACK_ALARM.",
      "ja": "6.もはや存在している場合は任意の受信が確認応答を送信する準備ができているセッションでは流れない、falseにsession.ACK_NOWを設定し、0にsession.RX_DATA_PACKETSを設定し、クリアsession.DELACK_ALARM。"
    },
    {
      "indent": 0,
      "text": "3.6.3.4.7. Example",
      "section_title": true,
      "ja": "3.6.3.4.7。例"
    },
    {
      "indent": 3,
      "text": "Figure 23 shows an example flow with sequence numbers 31 and 33 lost in transit; 31 is abandoned, and 33 is retransmitted.",
      "ja": "図23は、輸送中に失われたシーケンス番号31と33との例示的なフローを示す図です。 31は放棄され、そして33が再送信されます。"
    },
    {
      "indent": 3,
      "text": "Receiver\n 1 |<---  Data ID=3, seq#=29, fsnOff=11 (fsn=18)\n 2 |<---  Data ID=3, seq#=30, fsnOff=12 (fsn=18)\n 3 |--->  Ack  ID=3, seq:0-30\n 4 |<---  Data ID=3, seq#=32, fsnOff=12 (fsn=20)\n 5 |--->  Ack  ID=3, seq:0-30, 32\n 6 |<---  Data ID=3, seq#=34, fsnOff=12 (fsn=22)\n 7 |--->  Ack  ID=3, seq:0-30, 32, 34\n   |                   :\n 8 |<---  Data ID=3, seq#=46, fsnOff=16 (fsn=30)\n 9 |--->  Ack  ID=3, seq:0-30, 32, 34-46\n10 |<---  Data ID=3, seq#=47, fsnOff=15 (fsn=32)\n11 |--->  Ack  ID=3, seq:0-32, 34-47\n12 |<---  Data ID=3, seq#=33, fsnOff=1 (fsn=32)\n13 |--->  Ack  ID=3, seq#=0-47\n14 |<---  Data ID=3, seq#=48, fsnOff=16 (fsn=32)\n15 |<---  Data ID=3, seq#=49, fsnOff=17 (fsn=32)\n16 |--->  Ack  ID=3, seq#=0-49\n   |                   :",
      "raw": true
    },
    {
      "indent": 21,
      "text": "Figure 23: Flow Example with Loss",
      "ja": "図23：損失と流れの例"
    },
    {
      "indent": 0,
      "text": "3.6.3.5. Flow Control",
      "section_title": true,
      "ja": "3.6.3.5。フロー制御"
    },
    {
      "indent": 3,
      "text": "The flow receiver maintains a buffer for reassembling and reordering messages for delivery to the user (Section 3.6.3.3). The implementation and the user may wish to limit the amount of resources (including buffer memory) that a flow is allowed to use.",
      "ja": "フロー受信機は、ユーザ（セクション3.6.3.3）への配信のためにメッセージを再組み立てし、並べ替えのためのバッファを維持します。実装およびユーザがフローが使用を許可されている（バッファメモリを含む）リソースの量を制限することを望むかもしれません。"
    },
    {
      "indent": 3,
      "text": "RTMFP provides a means for each receiving flow to govern the amount of data sent by the sender, by way of the bufferBytesAvailable derived field of acknowledgement chunks (Sections 2.3.13 and 2.3.14). This derived field indicates the amount of data that the sender is allowed to have outstanding in the network, until instructed otherwise. This amount is also called the receive window.",
      "ja": "RTMFPは、肯定応答のチャンク（セクション2.3.13および2.3.14）のbufferBytesAvailable由来の分野の方法によって、送信側によって送信されたデータの量を管理するために、各受信フローのための手段を提供します。この派生フィールドには、そうでない場合は指示があるまで、送信者は、ネットワーク内で優秀なを持つことが許可されているデータの量を示しています。この量は、また、受信ウィンドウと呼ばれています。"
    },
    {
      "indent": 3,
      "text": "The flow receiver can suspend the sender by advertising a closed (zero length) receive window.",
      "ja": "フロー受信機は、受信ウィンドウを閉じ（ゼロ長さ）を広告することによって送信者を一時停止することができます。"
    },
    {
      "indent": 3,
      "text": "The user can suspend delivery of messages from the receiving flow (Section 3.6.3.3). This can cause the receive buffer to fill.",
      "ja": "ユーザーは、受信フロー（セクション3.6.3.3）からのメッセージの配信を一時停止することができます。これは、受信バッファがいっぱいになる可能性があります。"
    },
    {
      "indent": 3,
      "text": "In order for progress to be made on completing a fragmented message or repairing a gap for sequenced delivery in a flow, the flow receiver MUST advertise at least one buffer block in an acknowledgement if it is not suspended, even if the amount of data in the buffer exceeds the buffer capacity, unless the buffer capacity is 0. Otherwise, deadlock can occur, as the receive buffer will stay full and won't drain because of a gap or incomplete message, and the gap or incomplete message can't be repaired or completed because the sender is suspended.",
      "ja": "断片化されたメッセージを完成またはフローで配列決定送達のためのギャップを修復する上でなされるべき進歩のために、それが中断されていない場合、フロー受信機は、肯定応答で少なくとも一つのバッファブロックをアドバタイズする必要があり、偶数のデータ量であればバッファ容量がそうでなければ0でない限り、受信バッファがいっぱいにとどまるとドレインないのでギャップまたは不完全なメッセージを、ギャップまたは不完全なメッセージは修復できないようにバッファがバッファ容量を超えて、デッドロックが発生する可能性があります送信者が一時停止されているため、または完了しました。"
    },
    {
      "indent": 3,
      "text": "The receive window is advertised in units of 1024-byte blocks. For example, advertisements for 1 byte, 1023 bytes, and 1024 bytes each require one block. An advertisement for 1025 bytes requires two blocks.",
      "ja": "受信ウィンドウは1024バイトのブロック単位でアドバタイズされます。例えば、1バイト、1023バイト、1024バイトの広告は、それぞれ一つのブロックを必要とします。 1025バイトの広告は、二つのブロックが必要です。"
    },
    {
      "indent": 3,
      "text": "The following describes the RECOMMENDED method of calculating the bufferBlocksAvailable field of an acknowledgement chunk for a receiving flow:",
      "ja": "以下は、受信フローの確認応答チャンクのbufferBlocksAvailableフィールドを計算する推奨される方法を記載しています。"
    },
    {
      "indent": 3,
      "text": "1. If BUFFERED_SIZE is greater than or equal to BUFFER_CAPACITY, set ADVERTISE_BYTES to 0;",
      "ja": "1. BUFFERED_SIZEがより大きいかBUFFER_CAPACITYに等しい場合、0にADVERTISE_BYTESを設定し、"
    },
    {
      "indent": 3,
      "text": "2. If BUFFERED_SIZE is less than BUFFER_CAPACITY, set ADVERTISE_BYTES to BUFFER_CAPACITY - BUFFERED_SIZE;",
      "ja": "2. BUFFERED_SIZEがBUFFER_CAPACITY未満の場合、BUFFER_CAPACITYにセットADVERTISE_BYTES  -  BUFFERED_SIZE。"
    },
    {
      "indent": 3,
      "text": "3. Set ADVERTISE_BLOCKS to CEIL(ADVERTISE_BYTES / 1024);",
      "section_title": true,
      "ja": "CEIL 3.設定ADVERTISE_BLOCKS（ADVERTISE_BYTES / 1024）。"
    },
    {
      "indent": 3,
      "text": "4. If ADVERTISE_BLOCKS is 0, AND BUFFER_CAPACITY is greater than 0, AND delivery to the user is not suspended, set ADVERTISE_BLOCKS to 1; and",
      "ja": "4. ADVERTISE_BLOCKSは0であり、BUFFER_CAPACITYは0より大きく、ユーザへの配信が中断されていない、1にADVERTISE_BLOCKSを設定した場合、そして"
    },
    {
      "indent": 3,
      "text": "5. Set the acknowledgement's bufferBlocksAvailable field to ADVERTISE_BLOCKS.",
      "ja": "5. ADVERTISE_BLOCKSに確認のbufferBlocksAvailableフィールドを設定します。"
    },
    {
      "indent": 0,
      "text": "3.6.3.6. Receiving a Buffer Probe",
      "section_title": true,
      "ja": "3.6.3.6。バッファプローブを受けます"
    },
    {
      "indent": 3,
      "text": "A Buffer Probe chunk (Section 2.3.15) is sent by the flow sender (Section 3.6.2.9.1) to request the current receive window advertisement (in the form of an acknowledgement) from the flow receiver.",
      "ja": "バッファプローブチャンク（セクション2.3.15）は、フロー受信機から（確認応答の形で）現在の受信ウィンドウ広告を要求するフローの送信者（セクション3.6.2.9.1）によって送信されます。"
    },
    {
      "indent": 3,
      "text": "On receipt of a Buffer Probe chunk:",
      "ja": "バッファプローブチャンクを受信します："
    },
    {
      "indent": 3,
      "text": "1. If chunk.flowID doesn't belong to a receiving flow in the same session in the RF_OPEN, RF_REJECTED, or RF_COMPLETE_LINGER state, ignore this Buffer Probe; otherwise,",
      "ja": "1. chunk.flowIDこのバッファプローブを無視し、RF_OPEN、RF_REJECTED、又はRF_COMPLETE_LINGER状態で同じセッションで受信フローに属していない場合。そうでなければ、"
    },
    {
      "indent": 3,
      "text": "2. Retrieve the receiving flow context for the flow indicated by chunk.flowID; then",
      "ja": "2. chunk.flowIDによって示される流れのための受信フローコンテキストを取得します。それから"
    },
    {
      "indent": 3,
      "text": "3. Set flow.SHOULD_ACK to true; and",
      "section_title": true,
      "ja": "trueに設定する3. flow.SHOULD_ACK。そして"
    },
    {
      "indent": 3,
      "text": "4. Set session.ACK_NOW to true.",
      "section_title": true,
      "ja": "trueに設定する4. session.ACK_NOW。"
    },
    {
      "indent": 0,
      "text": "3.6.3.7. Rejecting a Flow",
      "section_title": true,
      "ja": "3.6.3.7。フローを拒否"
    },
    {
      "indent": 3,
      "text": "A receiver can reject an RF_OPEN flow at any time and for any reason. To reject a receiving flow in the RF_OPEN state:",
      "ja": "受信機は、いつでも任意の理由でRF_OPENフローを拒否することができます。 RF_OPEN状態で受信フローを拒否するには："
    },
    {
      "indent": 3,
      "text": "1. Move to the RF_REJECTED state;",
      "section_title": true,
      "ja": "RF_REJECTED状態1.移動し、"
    },
    {
      "indent": 3,
      "text": "2. Discard all entries in flow.RECV_BUFFER, as they are no longer relevant;",
      "ja": "彼らはもはや適切であるとして2、flow.RECV_BUFFER内のすべてのエントリを破棄しません。"
    },
    {
      "indent": 3,
      "text": "3. If the user rejected the flow, set flow.EXCEPTION_CODE to the exception code indicated by the user; otherwise, the flow was rejected automatically by the implementation, so the exception code is 0;",
      "ja": "3.ユーザがフローを拒否した場合、flow.EXCEPTION_CODEは、ユーザによって示された例外コードに設定します。例外コードが0であるので、そうでない場合、フローは、実装によって自動的に拒否されました。"
    },
    {
      "indent": 3,
      "text": "4. Set flow.SHOULD_ACK to true; and",
      "section_title": true,
      "ja": "trueに設定する4. flow.SHOULD_ACK。そして"
    },
    {
      "indent": 3,
      "text": "5. Set session.ACK_NOW to true.",
      "section_title": true,
      "ja": "trueに設定する5. session.ACK_NOW。"
    },
    {
      "indent": 3,
      "text": "The receiver indicates that it has rejected a flow by sending a Flow Exception Report chunk (Section 2.3.16) with every acknowledgement (Section 3.6.3.4.3) for a flow in the RF_REJECTED state.",
      "ja": "受信機は、それがRF_REJECTED状態でフローごとに確認応答（セクション3.6.3.4.3）でフロー例外レポートのチャンク（セクション2.3.16）を送信することにより、流れを拒否したことを示しています。"
    },
    {
      "indent": 0,
      "text": "3.6.3.8. Close",
      "section_title": true,
      "ja": "3.6.3.8。閉じる"
    },
    {
      "indent": 3,
      "text": "A receiving flow is complete when every sequence number from 0 through and including the final sequence number has been received -- that is, when flow.RF_FINAL_SN has a value and flow.SEQUENCE_SET contains every sequence number from 0 through flow.RF_FINAL_SN, inclusive.",
      "ja": "flow.RF_FINAL_SNの値を有し、flow.SEQUENCE_SETは、包括flow.RF_FINAL_SN 0〜毎にシーケンス番号が含まれている場合には、その - 受信フローは、最終シーケンス番号を含むすべての配列を介して0から番号とを受信したときに完了する。"
    },
    {
      "indent": 3,
      "text": "When an RF_OPEN or RF_REJECTED receiving flow becomes complete, move to the RF_COMPLETE_LINGER state, set flow.SHOULD_ACK to true, and set session.ACK_NOW to true.",
      "ja": "RF_OPEN又はRF_REJECTED受信流れが完全になったとき、RF_COMPLETE_LINGER状態に移動し、trueにflow.SHOULD_ACKを設定し、trueにsession.ACK_NOWを設定。"
    },
    {
      "indent": 3,
      "text": "A receiving flow SHOULD remain in the RF_COMPLETE_LINGER state for 120 seconds. After 120 seconds, move to the RF_CLOSED state. The receiving flow is now closed, and its resources can be reclaimed once all complete messages in flow.RECV_BUFFER have been delivered to the user (Section 3.6.3.3). The same flow ID might be used for a new flow by the sender after this point.",
      "ja": "受信フローは120秒間RF_COMPLETE_LINGER状態に留まるべきです。 120秒後、RF_CLOSED状態に移動します。受信フローは現在閉鎖され、そのリソースは一度flow.RECV_BUFFER内のすべての完全なメッセージがユーザー（セクション3.6.3.3）に配信されている再利用することができます。同じフローIDは、この点の後に送信者によって新しいフローのために使用される可能性があります。"
    },
    {
      "indent": 3,
      "text": "Discussion: The flow sender detects that the flow is complete on receiving an acknowledgement of all fragment sequence numbers of the flow. This can't happen until after the receiver has detected that the flow is complete and acknowledged all of the sequence numbers. The receiver's RF_COMPLETE_LINGER period is two minutes (one Maximum Segment Lifetime (MSL)); this period allows any in-flight packets to drain from the network without being misidentified and gives the sender an opportunity to retransmit any sequence numbers if the completing acknowledgement is lost. The sender's F_COMPLETE_LINGER period is at least two minutes plus 10 seconds and doesn't begin until the completing acknowledgement is received; therefore, the same flow identifier won't be reused by the flow sender for a new sending flow for at least 10 seconds after the flow receiver has closed the receiving flow context. This ensures correct operation independent of network delay, even when the sender's clock runs up to 8 percent faster than the receiver's.",
      "ja": "ディスカッション：フローの送信者は、流れが流れのすべての断片配列番号の確認を受けた上で完了したことを検知します。これは、受信機は、フローが完了したことを検出し、シーケンス番号のすべてを認めた後までに発生することはできません。受信機のRF_COMPLETE_LINGER期間は2分（1つの最大セグメント寿命（MSL））です。この期間は、任意の飛行中のパケットが誤認されることなく、ネットワークから流出することを可能にすると、送信者に完了の確認応答が失われた場合に任意のシーケンス番号を再送信する機会を与えてくれます。送信者のF_COMPLETE_LINGER期間は少なくとも2分プラス10秒で完了し、確認応答が受信されるまで開始されません。フロー受信機は、受信フローコンテキストを閉じた後従って、同じフロー識別子は、少なくとも10秒間、新規送信のフローのフロー送信者が再利用されないであろう。これは、送信側のクロックが受信側のより速い8％まで走る場合でも、ネットワーク遅延の正しい操作の独立を保証します。"
    },
    {
      "indent": 0,
      "text": "4. IANA Considerations",
      "section_title": true,
      "ja": "4. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This memo specifies chunk type code values (Section 2.3) and User Data option type code values (Section 2.3.11.1). These type code values are assigned and maintained by Adobe. Therefore, this memo has no IANA actions.",
      "ja": "このメモは、チャンクタイプコード値（2.3節）とユーザーデータオプションタイプコード値（セクション2.3.11.1）を指定します。これらのタイプのコード値が割り当てられ、Adobeが維持されています。したがって、このメモにはIANAのアクションを持っていません。"
    },
    {
      "indent": 0,
      "text": "5. Security Considerations",
      "section_title": true,
      "ja": "5.セキュリティについての考慮事項"
    },
    {
      "indent": 3,
      "text": "This memo specifies a general framework that can be used to establish a confidential and authenticated session between endpoints. A Cryptography Profile, not specified herein, defines the cryptographic algorithms, data formats, and semantics as used within this framework. Designing a Cryptography Profile to ensure that communications are protected to the degree required by the application-specific threat model is outside the scope of this specification.",
      "ja": "このメモは、エンドポイント間の機密情報や認証されたセッションを確立するために用いることができる一般的なフレームワークを指定します。本明細書で指定されていない暗号化プロファイルは、このフレームワーク内で使用される暗号化アルゴリズム、データフォーマット、およびセマンティクスを定義します。通信は、アプリケーション固有の脅威モデルによって必要とされる程度に保護されることを保証するために暗号化プロファイルを設計することは、この明細書の範囲外です。"
    },
    {
      "indent": 3,
      "text": "A block cipher in CBC mode is RECOMMENDED for packet encryption (Section 2.2.3). An attacker can predict the values of some fields from one plain RTMFP packet to the next or predict that some fields may be the same from one packet to the next. This SHOULD be considered in choosing and implementing a packet encryption cipher and mode.",
      "ja": "CBCモードでブロック暗号は、パケットの暗号化（2.2.3項）に推奨されます。攻撃者は、次の1つの普通RTMFPパケットからいくつかのフィールドの値を予測またはいくつかのフィールドが次の一つのパケットと同じであってもよいことが予測できます。これは、パケットの暗号化暗号およびモードを選択し、実行する際に考慮すべきです。"
    },
    {
      "indent": 3,
      "text": "The well-known Default Session Key of a Cryptography Profile serves multiple purposes, including the scrambling of session startup packets to protect interior fields from undesirable modification by middleboxes such as NATs, increasing the effort required for casual passive observation of startup packets, and allowing different applications of RTMFP using different Default Session Keys to (intentionally or not) share network transport addresses without interference. The Default Session Key, being well known, MUST NOT be construed to contribute to the security of session startup; session startup is essentially in the clear.",
      "ja": "暗号プロファイルのよく知られているデフォルトのセッションキーは、そのようなNATのような中間装置によって、望ましくない変形から内部フィールドを保護するために、セッション開始パケットのスクランブル起動パケットのカジュアル受動的観察に必要な作業量を増加させる、および異なる許可を含む複数の目的を提供しています干渉なしRTMFPのアプリケーションに（意図的かどうか）は、異なるデフォルトのセッションキーを使用して共有ネットワーク・トランスポート・アドレス。デフォルトのセッションキーは、よく知られている、セッション起動の安全保障に貢献すると解釈してはなりません。セッションの起動が明らかに本質的です。"
    },
    {
      "indent": 3,
      "text": "Section 3.5.4.2 describes an OPTIONAL method for processing a change of network address of a communicating peer. Securely processing address mobility using that method, or any substantially similar method, REQUIRES at least that the packet encryption function of the Cryptography Profile (Section 2.2.3) employs a cryptographic verification mechanism comprising secret information known only to the two endpoints. Without this constraint, that method, or any substantially similar method, becomes \"session hijacking support\".",
      "ja": "セクション3.5.4.2は、通信ピアのネットワークアドレスの変更を処理するための任意の方法を記載しています。安全その方法、または任意の実質的に同様の方法を用いてアドレスの移動性を処理、暗号プロファイル（セクション2.2.3）のパケットの暗号化機能は、2つのだけのエンドポイントに知られている秘密情報を含む暗号化検証メカニズムを採用することを少なくとも必要とします。この制約がなければ、そのメソッド、または任意の実質的に類似の方法は、「セッションハイジャックのサポート」になります。"
    },
    {
      "indent": 3,
      "text": "Flows and packet fragmentation imply semantics that could cause unbounded resource utilization in receivers, causing a denial of service. Implementations SHOULD guard against unbounded or excessive resource use and abort sessions that appear abusive.",
      "ja": "フローおよびパケットの断片化は、サービス拒否を引き起こし、受信機で無制限のリソース使用率を引き起こす可能性があるセマンティクスを暗示しています。実装は無制限や過剰な資源利用を防ぐと虐待に表示されたセッションを中止すべきです。"
    },
    {
      "indent": 3,
      "text": "A rogue but popular Redirector (Section 3.5.1.4) could direct session initiators to flood a victim address or network with Initiator Hello packets, potentially causing a denial of service.",
      "ja": "不正しかし、人気のリダイレクタ（セクション3.5.1.4）は、潜在的にサービス拒否を引き起こし、イニシエータHelloパケットを犠牲者のアドレスまたはネットワークをあふれさせるセッションイニシエータを指示できます。"
    },
    {
      "indent": 3,
      "text": "An attacker that can passively observe an IHello and that possesses a certificate matching the Endpoint Discriminator (without having to know the private key, if any, associated with it) can deny the initiator access to the desired responder by sending an RHello before the desired responder does, since only the first received RHello is selected by the initiator. The attacker needn't forge the desired responder's source address, since the RHello is selected based on the tag echo and not the packet's source address. This can simplify the attack in some network or host configurations.",
      "ja": "受動IHello、それは（それに関連するすべての場合、秘密鍵を知ることなく、）エンドポイント識別子と一致する証明書を所有を観察することができ、攻撃者は、所望の応答前RHelloを送信することによって、所望の応答へのイニシエータのアクセスを拒否することができ最初の受信RHelloがイニシエータによって選択されているので、ありません。攻撃者はRHelloは、タグエコーではなく、パケットの送信元アドレスに基づいて選択されているので、希望応答の送信元アドレスを偽造する必要はありません。これは、いくつかのネットワークまたはホストの構成での攻撃を簡素化することができます。"
    },
    {
      "indent": 3,
      "text": "An attacker that can passively observe and record the packets of an established session can use traffic analysis techniques to infer the start and completion of flows without decrypting the packets. The User Data fragments of flows have unique sequence numbers, so flows are immune to replay while they are open. However, once a flow has completed and the linger period has concluded, the attacker could replay the recorded packets, opening a new flow in the receiver and duplicating the flow's data; this replay might have undesirable effects on the receiver's application. The attacker could also infer that a new flow has begun reusing the recorded flow's identifier and replay the final sequence number or any of the other fragments in the flow, potentially denying or interfering with legitimate traffic to the receiver. Therefore, the data integrity aspect of packet encryption SHOULD comprise anti-replay measures.",
      "ja": "受動的に確立されたセッションのパケットを観察し、記録することができ、攻撃者は、パケットを復号化することなく、フローの開始と完了を推測するトラフィック分析技術を使用することができます。フローは、彼らが開いている間再生する免疫があるように、流れのユーザデータの断片は、ユニークなシーケンス番号を持っています。フローが完了したとリンガー期間が終了した後、しかし、攻撃者が受信機に新しい流れを開き、フローのデータを複製し、記録されたパケットを再生することができ、このリプレイは、受信側のアプリケーションに好ましくない影響を与える可能性があります。攻撃者はまた、新しい流れが記録フローの識別子を再利用し始めていることを推測し、潜在的に拒否または受信機への正当なトラフィックと干渉し、流れの中で、最終的なシーケンス番号または他のフラグメントのいずれかを再生することができます。そのため、パケットの暗号化データ整合性の側面は、アンチリプレイ対策を含むべきです。"
    },
    {
      "indent": 0,
      "text": "6. Acknowledgements",
      "section_title": true,
      "ja": "6.謝辞"
    },
    {
      "indent": 3,
      "text": "Special thanks go to Matthew Kaufman for his contributions to the creation and design of RTMFP.",
      "ja": "特別な感謝は、RTMFPの作成と設計への貢献のためにマシュー・カウフマンに行きます。"
    },
    {
      "indent": 3,
      "text": "Thanks to Jari Arkko, Ben Campbell, Wesley Eddy, Stephen Farrell, Philipp Hancke, Bela Lubkin, Hilarie Orman, Richard Scheffenegger, and Martin Stiemerling for their detailed reviews of this memo.",
      "ja": "このメモの詳細なレビューについてヤリArkko、ベン・キャンベル、ウェズリーエディ、スティーブン・ファレル、フィリップHancke、ベラLubkin、ヒラリーオーマン、リチャードScheffenegger、そしてマーティンStiemerlingに感謝します。"
    },
    {
      "indent": 0,
      "text": "7. References",
      "section_title": true,
      "ja": "7.参考"
    },
    {
      "indent": 0,
      "text": "7.1. Normative References",
      "section_title": true,
      "ja": "7.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[CBC] Dworkin, M., \"Recommendation for Block Cipher Modes of Operation\", NIST Special Publication 800-38A, December 2001, <http://csrc.nist.gov/publications/ nistpubs/800-38a/sp800-38a.pdf>.",
      "ja": "[CBC] Dworkin、M.、 \"操作のブロック暗号モードのための勧告\" は、NIST Special Publication 800-38Aの2001年12月、<http://csrc.nist.gov/publications/ nistpubs / 800-38A / sp800-38a .PDF>。"
    },
    {
      "indent": 3,
      "text": "[RFC0768] Postel, J., \"User Datagram Protocol\", STD 6, RFC 768, August 1980.",
      "ja": "[RFC0768]ポステル、J.、 \"ユーザ・データグラム・プロトコル\"、STD 6、RFC 768、1980年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC0791] Postel, J., \"Internet Protocol\", STD 5, RFC 791, September 1981.",
      "ja": "[RFC0791]ポステル、J.、 \"インターネットプロトコル\"、STD 5、RFC 791、1981年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC1122] Braden, R., \"Requirements for Internet Hosts - Communication Layers\", STD 3, RFC 1122, October 1989.",
      "ja": "[RFC1122]ブレーデン、R.、 \"インターネットホストのための要件 - 通信層\"、STD 3、RFC 1122、1989年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2460] Deering, S. and R. Hinden, \"Internet Protocol, Version 6 (IPv6) Specification\", RFC 2460, December 1998.",
      "ja": "[RFC2460]デアリング、S.とR. Hindenと、 \"インターネットプロトコルバージョン6（IPv6）の仕様\"、RFC 2460、1998年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC2914] Floyd, S., \"Congestion Control Principles\", BCP 41, RFC 2914, September 2000.",
      "ja": "[RFC2914]フロイド、S.、 \"輻輳制御の原理\"、BCP 41、RFC 2914、2000年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC4821] Mathis, M. and J. Heffner, \"Packetization Layer Path MTU Discovery\", RFC 4821, March 2007.",
      "ja": "[RFC4821]マシス、M.とJ. Heffner、 \"パケット化レイヤのパスMTUディスカバリ\"、RFC 4821、2007年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC5681] Allman, M., Paxson, V., and E. Blanton, \"TCP Congestion Control\", RFC 5681, September 2009.",
      "ja": "[RFC5681]オールマン、M.、パクソン、V.、およびE.ブラントン、 \"TCP輻輳制御\"、RFC 5681、2009年9月。"
    },
    {
      "indent": 0,
      "text": "7.2. Informative References",
      "section_title": true,
      "ja": "7.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[RFC5389] Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, \"Session Traversal Utilities for NAT (STUN)\", RFC 5389, October 2008.",
      "ja": "[RFC5389]ローゼンバーグ、J.、マーイ、R.、マシューズ、P.、およびD.翼、 \"NAT（STUN）のセッショントラバーサルユーティリティ\"、RFC 5389、2008年10月。"
    },
    {
      "indent": 3,
      "text": "[ScalableTCP] Kelly, T., \"Scalable TCP: Improving Performance in Highspeed Wide Area Networks\", December 2002, <http://datatag.web.cern.ch/datatag/papers/ pfldnet2003-ctk.pdf>.",
      "ja": "[ScalableTCP]ケリー、T.、 \"スケーラブルTCP：ハイスピード広域ネットワークにおけるパフォーマンスの向上\"、2002年12月、<http://datatag.web.cern.ch/datatag/papers/ pfldnet2003-ctk.pdf>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Example Congestion Control Algorithm",
      "ja": "付録A.例の輻輳制御アルゴリズム"
    },
    {
      "indent": 3,
      "text": "As mandated in Section 3.5.2, an RTMFP is required to use TCP-compatible congestion control, but flexibility in exact implementation is allowed, within certain limits. This section describes an experimental window-based congestion control algorithm that is appropriate for real-time and bulk data transport in RTMFP. The algorithm includes slow start and congestion avoidance phases, including modified increase and decrease parameters. These parameters are further adjusted according to whether real-time data is being sent and whether Time Critical Reverse Notifications are received.",
      "ja": "セクション3.5.2に義務付けたように、RTMFPは、TCP互換輻輳制御を使用する必要があるが、正確な実装における柔軟性がある範囲内、許容されます。このセクションでは、リアルタイムおよびRTMFPバルクデータ転送に適した実験的なウィンドウベースの輻輳制御アルゴリズムを記載しています。アルゴリズムは、修正増減パラメータを含むスロースタートと輻輳回避フェーズを含みます。これらのパラメータは、さらに、リアルタイムデータが送信され、タイムクリティカル逆通知を受信したか否かをされているか否かに応じて調整されます。"
    },
    {
      "indent": 0,
      "text": "A.1. Discussion",
      "ja": "A.1。討論"
    },
    {
      "indent": 3,
      "text": "RFC 5681 defines the standard window-based congestion control algorithms for TCP. These algorithms are appropriate for delay-insensitive bulk data transport but have undesirable behaviors for delay- and loss-sensitive applications. Among the undesirable behaviors are the cutting of the congestion window in half during a loss event, and the rapidity of the slow start algorithm's exponential growth. Cutting the congestion window in half requires a large channel headroom to support a real-time application and can cause a large amount of jitter from sender-side buffering. Doubling the congestion window during the slow start phase can lead to the congestion window temporarily growing to twice the size it should be, causing a period of excessive loss in the path.",
      "ja": "RFC 5681は、TCPのための標準的なウィンドウベースの輻輳制御アルゴリズムを定義します。これらのアルゴリズムは、遅延の影響を受けないバルクデータ転送に適していますが、遅延 - 、損失に敏感なアプリケーションのために望ましくない行動を持っています。望ましくない行動の中で損失事象の間に半分に輻輳ウィンドウの切断、およびスロースタートアルゴリズムの指数関数的な成長の速さです。半分に輻輳ウィンドウをカットするリアルタイムアプリケーションをサポートするために、大きなチャネルヘッドルームを必要とし、送信側のバッファリングからジッタを大量に発生する可能性があります。スロースタートフェーズの間に輻輳ウィンドウを倍増することは輻輳ウィンドウが一時的にパス内の過剰損失の期間を引き起こし、それがあるべき2倍のサイズに成長しているにつながることができます。"
    },
    {
      "indent": 3,
      "text": "We found that a number of deployed TCP implementations use the method of equation (3) from Section 3.1 of RFC 5681; this method, when combined with the recommended behavior of acknowledging every other packet, causes the congestion window to grow at approximately half the rate that the recommended method specifies. In order to compete fairly with these deployed TCPs, we choose 768 bytes per round trip as the increment during the normal congestion avoidance phase; this is approximately half of the typical maximum segment size of 1500 bytes and is also easily subdivided.",
      "ja": "我々は、展開TCP実装の数は、RFC 5681のセクション3.1から式（3）の方法を使用することを見出しました。この方法は、他のすべてのパケットを認めるの推奨動作と組み合わせると、約推奨される方法は指定ハーフレートすることを成長すると、輻輳ウィンドウが発生します。これらの展開のTCPと公平に競争するために、我々は、通常の輻輳回避フェーズの間に増分として往復ごとに768のバイトを選択してください。これは、約1500バイトの典型的な最大セグメントサイズの半分であり、また容易に細分されます。"
    },
    {
      "indent": 3,
      "text": "The sender may be sending real-time data to the far end. When sending real-time data, a smoother response to congestion is desired while still competing with reasonable fairness to other flows in the Internet. In order to scale the sending rate quickly, the slow start algorithm is desired, but slow start's normal rate of increase can cause excessive loss in the last round trip. Accordingly, slow start's exponential increase rate is adjusted to double approximately every 3 round trips instead of every round trip. The multiplicative decrease cuts the congestion window by one eighth on loss to maintain a smoother sending rate. The additive increase is done at half the normal rate (incrementing at 384 bytes per round trip), to both compensate for the less aggressive loss response and probe the path capacity more gently.",
      "ja": "送信者は、遠端にリアルタイムデータを送信することができます。リアルタイムデータを送信する場合は、まだインターネットで他のフローを合理的な公正に競争しながら、混雑へのスムーズな対応が望まれます。素早く送信速度をスケーリングするためには、スロースタートアルゴリズムが望まれているが、増加のスロースタートの通常のレートは、最後のラウンドトリップで過度の損失を引き起こす可能性があります。したがって、スロースタートの指数関数的な増加率は約代わりにすべてのラウンドトリップのすべての3ラウンドトリップを倍増するように調整されます。乗算減少は、スムーズな送信レートを維持するために、損失の八分の一で輻輳ウィンドウをカット。添加物の増加は、両方の少ない積極的損失応答を補償するために、（ラウンドトリップあたり384バイトでインクリメント）通常の半分の速度で行われ、より緩やかパス能力をプローブです。"
    },
    {
      "indent": 3,
      "text": "The far end may report that it is receiving real-time data from other peers, or the sender may be sending real-time data to other far ends. In these circumstances (if not sending real-time data to this far end), it is desirable to respond differently than the standard TCP algorithms specify, to both yield capacity to the real-time flows and avoid excessive losses while probing the path capacity. Slow start's exponential increase is disabled, and the additive increase is done at half the normal rate (incrementing at 384 bytes per round trip). Multiplicative decrease is left at the normal rate (cutting by half) to yield to other flows.",
      "ja": "遠端は、それが他のピアからのリアルタイムデータを受信して​​いる、または送信者が他の遠端にリアルタイムデータを送信することができることを報告することがあります。 （この遠端にリアルタイムデータを送信しない場合）このような状況では、標準のTCPアルゴリズムが指定するよりも、リアルタイムのフローの両方利回りの容量を、異なる応答とパス能力を探査しながら、過度の損失を回避することが望ましいです。スロースタートの指数関数的な増加は無効になり、添加物の増加は、（往復あたり384バイトでインクリメント）通常の半分の速度で実行されます。乗法減少が他のフローを生成するために、通常の速度（ハーフによる切断）に残されます。"
    },
    {
      "indent": 3,
      "text": "Since real-time messages may be small, and sent regularly, it is advantageous to spread congestion window increases out across the round-trip time instead of doing them all at once. We divide the round trip into 16 segments with an additive increase of a useful size (48 bytes) per segment.",
      "ja": "リアルタイムのメッセージが小さく、定期的に送信される可能性があるので、輻輳ウィンドウは、一度にすべてを行うのではなく、往復時間を越えて増加広げることが有利です。我々は、セグメント当たりの有用なサイズ（48バイト）の添加の増加に伴って16個のセグメントに往復を分割します。"
    },
    {
      "indent": 3,
      "text": "Scalable TCP [ScalableTCP] describes experimental methods of modifying the additive increase and multiplicative decrease of the congestion window in large delay-bandwidth scenarios. The congestion window is increased by 1% each round trip and decreased by one eighth on loss in the congestion avoidance phase in certain circumstances (specifically, when a 1% increase is larger than the normal additive-increase amount). Those methods are adapted here. The scalable increase amount is 48 bytes for every 4800 bytes acknowledged, to spread the increase out over the round trip. The congestion window is decreased by one eighth on loss when it is at least 67200 bytes per round trip, which is seven eighths of 76800 (the point at which 1% is greater than 768 bytes per round trip). When sending real-time data to the far end, the scalable increase is 1% or 384 bytes per round trip, whichever is greater. Otherwise, when notified that the far end is receiving real-time data from other peers, the scaled increase is adjusted to 0.5% or 384 bytes per round trip, whichever is greater.",
      "ja": "スケーラブルTCPは[ScalableTCP】添加剤の増加と大遅延帯域幅シナリオにおける輻輳ウィンドウの乗法減少を変更する実験方法を記載しています。輻輳ウィンドウは1％ずつ往復を増加し、特定の状況における輻輳回避フェーズで損失に八分の一だけ減少される（具体的には、1％の増加は通常、添加剤の増加量よりも大きい場合）。これらの方法は、ここに適合されています。スケーラブルな増加量は、すべての4800バイトのための48のバイトは、往復の上に外に増加を広めるために、認識されています。輻輳ウィンドウは、76800の8分の7（1％往復当たり768バイトよりも大きい点）である損失に八分の一、それは往復あたり少なくとも67200バイトであり、減少されます。遠端にリアルタイムデータを送信する場合は、拡張性の増加が大きい方、1％または往復ごとに384バイトです。遠端が他のピアからのリアルタイムデータを受信して​​いることを通知されたとき、さもなければ、スケーリングされた増加は、大きい方のラウンドトリップ、0.5％、または384バイトに調整されます。"
    },
    {
      "indent": 0,
      "text": "A.2. Algorithm",
      "ja": "A.2。アルゴリズム"
    },
    {
      "indent": 3,
      "text": "Let SMSS denote the Sender Maximum Segment Size [RFC5681], for example 1460 bytes. Let CWND_INIT denote the Initial Congestion Window (IW) according to Section 3.1 of RFC 5681, for example 4380 bytes. Let CWND_TIMEDOUT denote the congestion window after a timeout indicating lost data, being 1*SMSS (for example, 1460 bytes).",
      "ja": "SMSSは、例えば、1460のバイトを送信側最大セグメントサイズ[RFC5681]を示すものとします。 CWND_INITは、例えば、4380バイトをRFC 5681のセクション3.1に従って初期輻輳ウィンドウ（IW）を表すものとします。 CWND_TIMEDOUT 1 *のSMSS（例えば、1460バイト）であり、失われたデータを示すタイムアウト後に輻輳ウィンドウを示すものとします。"
    },
    {
      "indent": 3,
      "text": "Let the session information context contain additional variables:",
      "ja": "セッション情報のコンテキストは、追加の変数が含まれてみましょう："
    },
    {
      "indent": 3,
      "text": "o CWND: the congestion window, initialized to CWND_INIT;",
      "ja": "O CWND：輻輳ウィンドウ、CWND_INITに初期化。"
    },
    {
      "indent": 3,
      "text": "o SSTHRESH: the slow start threshold, initialized to positive infinity;",
      "ja": "SSTHRESH O：スロースタート閾値を、正の無限大に初期化。"
    },
    {
      "indent": 3,
      "text": "o ACKED_BYTES_ACCUMULATOR: a count of acknowledged bytes, initialized to 0;",
      "ja": "O ACKED_BYTES_ACCUMULATOR：0に初期化され承認されたバイト数、;"
    },
    {
      "indent": 3,
      "text": "o ACKED_BYTES_THIS_PACKET: a count of acknowledged bytes observed in the current packet;",
      "ja": "OのACKED_BYTES_THIS_PACKET：現在のパケットで観察され承認されたバイト数。"
    },
    {
      "indent": 3,
      "text": "o PRE_ACK_OUTSTANDING: the number of bytes outstanding in the network before processing any acknowledgements in the current packet;",
      "ja": "O PRE_ACK_OUTSTANDING：現在のパケット内の任意の肯定応答を処理する前に、ネットワーク内の未処理のバイト数。"
    },
    {
      "indent": 3,
      "text": "o ANY_LOSS: an indication of whether any loss has been detected in the current packet;",
      "ja": "ANY_LOSS O：任意の損失は、現在のパケットで検出されたかどうかの表示。"
    },
    {
      "indent": 3,
      "text": "o ANY_NAKS: an indication of whether any negative acknowledgements have been detected in the current packet;",
      "ja": "ANY_NAKS O：否定確認応答が現在のパケットで検出されているかどうかの表示。"
    },
    {
      "indent": 3,
      "text": "o ANY_ACKS: an indication of whether any acknowledgement chunks have been received in the current packet.",
      "ja": "ANY_ACKS O：任意の肯定応答チャンクは、現在のパケットで受信されたかどうかの指示。"
    },
    {
      "indent": 3,
      "text": "Let FASTGROW_ALLOWED indicate whether the congestion window is allowed to grow at the normal rate versus a slower rate, being false if a Time Critical Reverse Notification has been received on this session within the last 800 milliseconds (Sections 2.2.4 and 3.5.2.1) or if a Time Critical Forward Notification has been sent on ANY session in the last 800 milliseconds, and otherwise being true.",
      "ja": "タイムクリティカルリバース通知は、最後の800ミリ秒以内に、このセッションで受信されている場合FASTGROW_ALLOWEDが偽であること、輻輳ウィンドウが遅い速度対通常の速度で成長することが許可されているかどうかを示してみましょう（セクション2.2.4および3.5.2.1）またはタイムクリティカルフォワードの通知が最後の800ミリ秒のいずれかのセッションで送信された場合、それ以外の場合は真であること。"
    },
    {
      "indent": 3,
      "text": "Let TC_SENT indicate whether a Time Critical Forward Notification has been sent on this session within the last 800 milliseconds.",
      "ja": "TC_SENTは、タイムクリティカルフォワードの通知は、最後の800ミリ秒以内にこのセッションで送信されたかどうかを示しましょう。"
    },
    {
      "indent": 3,
      "text": "Implement the method described in Section 3.6.2.6 to manage transmission timeouts, including setting the TIMEOUT_ALARM.",
      "ja": "TIMEOUT_ALARM設定など、送信タイムアウトを管理するために、セクション3.6.2.6に記載の方法を実施します。"
    },
    {
      "indent": 3,
      "text": "On being notified that the TIMEOUT_ALARM has fired, perform the function shown in Figure 24:",
      "ja": "TIMEOUT_ALARMが発射したことを通知される上に、図24に示す機能を実行します。"
    },
    {
      "indent": 3,
      "text": "on TimeoutNotification(WAS_LOSS): set SSTHRESH to MAX(SSTHRESH, CWND * 3/4). set ACKED_BYTES_ACCUMULATOR to 0. if WAS_LOSS is true: set CWND to CWND_TIMEDOUT. else: set CWND to CWND_INIT.",
      "ja": "TimeoutNotification（WAS_LOSS）上：MAXに設定SSTHRESH（SSTHRESH、CWND * 3/4）。 WAS_LOSSがtrueの場合は0にACKED_BYTES_ACCUMULATORを設定します。CWND_TIMEDOUTにCWNDを設定します。他：CWND_INITにCWNDを設定します。"
    },
    {
      "indent": 9,
      "text": "Figure 24: Pseudocode for Handling a Timeout Notification",
      "ja": "図24：タイムアウトの通知を処理するための擬似コード"
    },
    {
      "indent": 3,
      "text": "Before processing each received packet in this session:",
      "ja": "このセッションでは、各受信したパケットを処理する前に："
    },
    {
      "indent": 3,
      "text": "1. Set ANY_LOSS to false;",
      "section_title": true,
      "ja": "falseに設定1. ANY_LOSS。"
    },
    {
      "indent": 3,
      "text": "2. Set ANY_NAKS to false;",
      "section_title": true,
      "ja": "falseに設定2. ANY_NAKS。"
    },
    {
      "indent": 3,
      "text": "3. Set ACKED_BYTES_THIS_PACKET to 0; and",
      "section_title": true,
      "ja": "0 3.設定ACKED_BYTES_THIS_PACKET。そして"
    },
    {
      "indent": 3,
      "text": "4. Set PRE_ACK_OUTSTANDING to S_OUTSTANDING_BYTES.",
      "section_title": true,
      "ja": "S_OUTSTANDING_BYTESにPRE_ACK_OUTSTANDING 4.設定。"
    },
    {
      "indent": 3,
      "text": "On notification of loss (Section 3.6.2.5), set ANY_LOSS to true.",
      "ja": "損失（セクション3.6.2.5）の通知には、trueにANY_LOSSを設定します。"
    },
    {
      "indent": 3,
      "text": "On notification of negative acknowledgement (Section 3.6.2.5), set ANY_NAKS to true.",
      "ja": "否定応答（セクション3.6.2.5）の通知には、trueにANY_NAKSを設定します。"
    },
    {
      "indent": 3,
      "text": "On notification of acknowledgement of data (Section 3.6.2.4), set ANY_ACKS to true, and add the count of acknowledged bytes to ACKED_BYTES_THIS_PACKET.",
      "ja": "データの確認応答（セクション3.6.2.4）の通知には、trueにANY_ACKSを設定し、ACKED_BYTES_THIS_PACKETに承認されたバイト数を追加します。"
    },
    {
      "indent": 3,
      "text": "After processing all chunks in each received packet for this session, perform the function shown in Figure 25:",
      "ja": "このセッションのために、各受信したパケット内のすべてのチャンクを処理した後、図25に示す機能を実行します。"
    },
    {
      "indent": 3,
      "text": "if ANY_LOSS is true: if (TC_SENT is true) OR (PRE_ACK_OUTSTANDING > 67200 AND \\ FASTGROW_ALLOWED is true): set SSTHRESH to MAX(PRE_ACK_OUTSTANDING * 7/8, CWND_INIT). else: set SSTHRESH to MAX(PRE_ACK_OUTSTANDING * 1/2, CWND_INIT). set CWND to SSTHRESH. set ACKED_BYTES_ACCUMULATOR to 0. else if (ANY_ACKS is true) AND (ANY_NAKS is false) AND \\ (PRE_ACK_OUTSTANDING >= CWND): set var INCREASE to 0. var AITHRESH. if FASTGROW_ALLOWED is true: if CWND < SSTHRESH: set INCREASE to ACKED_BYTES_THIS_PACKET. else: add ACKED_BYTES_THIS_PACKET to ACKED_BYTES_ACCUMULATOR. set AITHRESH to MIN(MAX(CWND / 16, 64), 4800). while ACKED_BYTES_ACCUMULATOR >= AITHRESH: subtract AITHRESH from ACKED_BYTES_ACCUMULATOR. add 48 to INCREASE. else FASTGROW_ALLOWED is false: if CWND < SSTHRESH AND TC_SENT is true: set INCREASE to CEIL(ACKED_BYTES_THIS_PACKET / 4). else: var AITHRESH_CAP. if TC_SENT is true: set AITHRESH_CAP to 2400. else: set AITHRESH_CAP to 4800. add ACKED_BYTES_THIS_PACKET to ACKED_BYTES_ACCUMULATOR. set AITHRESH to MIN(MAX(CWND / 16, 64), AITHRESH_CAP). while ACKED_BYTES_ACCUMULATOR >= AITHRESH: subtract AITHRESH from ACKED_BYTES_ACCUMULATOR. add 24 to INCREASE. set CWND to MAX(CWND + MIN(INCREASE, SMSS), CWND_INIT).",
      "ja": "ANY_LOSSがtrueの場合：（TC_SENTが真である）OR（PRE_ACK_OUTSTANDING> 67200と\\ FASTGROW_ALLOWEDが真である）場合：MAXにSSTHRESHを設定する（PRE_ACK_OUTSTANDING * 7/8、CWND_INIT）。他：MAXに設定SSTHRESH（PRE_ACK_OUTSTANDING * 1/2、CWND_INIT）。 SSTHRESHにCWNDを設定します。それ以外であれば0にACKED_BYTES_ACCUMULATORを設定する（ANY_ACKSが真）AND（ANY_NAKSはfalse）と\\（PRE_ACK_OUTSTANDING> = CWND）：0 VARのAITHRESHにセットするvar増加を。 FASTGROW_ALLOWEDがtrueの場合：もしCWND <SSTHRESH：ACKED_BYTES_THIS_PACKETに設定し増加しました。他：ACKED_BYTES_ACCUMULATORにACKED_BYTES_THIS_PACKETを追加します。 MIN（MAX（CWND / 16、64）、4800）にAITHRESHセット。 ACKED_BYTES_ACCUMULATOR> = AITHRESHながら：ACKED_BYTES_ACCUMULATORからAITHRESHを引きます。増加に48を追加します。他FASTGROW_ALLOWEDはfalseです：CWND <SSTHRESHとTC_SENTがtrueの場合：CEIL（ACKED_BYTES_THIS_PACKET / 4）に設定された増加しました。他ます。var AITHRESH_CAP。 TC_SENTがtrueの場合：他の2400にAITHRESH_CAPを設定：4800に設定AITHRESH_CAP ACKED_BYTES_ACCUMULATORにACKED_BYTES_THIS_PACKETを追加します。 MIN（MAX（CWND / 16、64）、AITHRESH_CAP）にAITHRESHセット。 ACKED_BYTES_ACCUMULATOR> = AITHRESHながら：ACKED_BYTES_ACCUMULATORからAITHRESHを引きます。増加に24を追加します。 MAX（CWND + MIN（INCREASE、SMSS）、CWND_INIT）にCWNDを設定します。"
    },
    {
      "indent": 10,
      "text": "Figure 25: Pseudocode for Congestion Window Adjustment\n               after Processing a Packet",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Author's Address",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Michael C. Thornburgh Adobe Systems Incorporated 345 Park Avenue San Jose, CA 95110-2704 US",
      "ja": "マイケルC. Thornburgh Adob​​e Systems Incorporated（アドビシステムズ社）345パークアベニューサンノゼ、CA 95110-2704米国"
    },
    {
      "indent": 3,
      "text": "Phone: +1 408 536 6000 EMail: mthornbu@adobe.com URI: http://www.adobe.com/",
      "ja": "電話：+1 408 536 6000 Eメール：mthornbu@adobe.com URI：http://www.adobe.com/"
    }
  ]
}