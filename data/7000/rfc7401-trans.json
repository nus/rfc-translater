{
  "title": {
    "text": "RFC 7401 - Host Identity Protocol Version 2 (HIPv2)",
    "ja": "RFC 7401 - ホストアイデンティティプロトコルバージョン2（HIPv2）"
  },
  "number": 7401,
  "created_at": "2019-11-01 14:38:27.593821+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                 R. Moskowitz, Ed.\nRequest for Comments: 7401                                HTT Consulting\nObsoletes: 5201                                                  T. Heer\nCategory: Standards Track              Hirschmann Automation and Control\nISSN: 2070-1721                                                P. Jokela\n                                            Ericsson Research NomadicLab\n                                                            T. Henderson\n                                                University of Washington\n                                                              April 2015",
      "raw": true
    },
    {
      "indent": 16,
      "text": "Host Identity Protocol Version 2 (HIPv2)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document specifies the details of the Host Identity Protocol (HIP). HIP allows consenting hosts to securely establish and maintain shared IP-layer state, allowing separation of the identifier and locator roles of IP addresses, thereby enabling continuity of communications across IP address changes. HIP is based on a Diffie-Hellman key exchange, using public key identifiers from a new Host Identity namespace for mutual peer authentication. The protocol is designed to be resistant to denial-of-service (DoS) and man-in-the-middle (MitM) attacks. When used together with another suitable security protocol, such as the Encapsulating Security Payload (ESP), it provides integrity protection and optional encryption for upper-layer protocols, such as TCP and UDP.",
      "ja": "この文書では、ホスト識別プロトコル（HIP）の詳細を指定します。 HIPは、確実に、共有IPレイヤの状態を確立し、維持するためにホストを同意IPアドレスの識別子及びロケータの役割の分離を可能にすることにより、IPアドレスの変更を横切って通信の継続を可能にすることができます。 HIPは、相互ピア認証用の新しいホストアイデンティティの名前空間からの公開鍵の識別子を使用して、Diffie-Hellman鍵交換に基づいています。プロトコルは、サービス拒否（DOS）とMITM（中間者）攻撃に対して耐性があるように設計されています。そのようなカプセル化セキュリティペイロード（ESP）などの別の適切なセキュリティプロトコル、と一緒に使用する場合、そのようなTCPやUDPなどの上位層プロトコルのための完全性保護およびオプションの暗号化を提供します。"
    },
    {
      "indent": 3,
      "text": "This document obsoletes RFC 5201 and addresses the concerns raised by the IESG, particularly that of crypto agility. It also incorporates lessons learned from the implementations of RFC 5201.",
      "ja": "この文書はRFC 5201を廃止し、IESGによって懸念、暗号アジリティの特にそれに対応しています。また、RFC 5201の実装から学んだ教訓を搭載しています。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 5741のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7401.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7401で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2015 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2015 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................5\n   1.1. A New Namespace and Identifiers ............................6\n   1.2. The HIP Base Exchange (BEX) ................................6\n   1.3. Memo Structure .............................................7\n2. Terms and Definitions ...........................................7\n   2.1. Requirements Terminology ...................................7\n   2.2. Notation ...................................................8\n   2.3. Definitions ................................................8\n3. Host Identity (HI) and Its Structure ............................9\n   3.1. Host Identity Tag (HIT) ...................................10\n   3.2. Generating a HIT from an HI ...............................11\n4. Protocol Overview ..............................................12\n   4.1. Creating a HIP Association ................................12\n        4.1.1. HIP Puzzle Mechanism ...............................14\n        4.1.2. Puzzle Exchange ....................................15\n        4.1.3. Authenticated Diffie-Hellman Protocol with\n               DH Group Negotiation ...............................17\n        4.1.4. HIP Replay Protection ..............................18\n        4.1.5. Refusing a HIP Base Exchange .......................19\n        4.1.6. Aborting a HIP Base Exchange .......................20\n        4.1.7. HIP Downgrade Protection ...........................20\n        4.1.8. HIP Opportunistic Mode .............................21\n   4.2. Updating a HIP Association ................................24\n   4.3. Error Processing ..........................................24\n   4.4. HIP State Machine .........................................25\n        4.4.1. State Machine Terminology ..........................26\n        4.4.2. HIP States .........................................27\n        4.4.3. HIP State Processes ................................28\n        4.4.4. Simplified HIP State Diagram .......................35",
      "raw": true
    },
    {
      "indent": 3,
      "text": "   4.5. User Data Considerations ..................................37\n        4.5.1. TCP and UDP Pseudo Header Computation for\n               User Data ..........................................37\n        4.5.2. Sending Data on HIP Packets ........................37\n        4.5.3. Transport Formats ..................................37\n        4.5.4. Reboot, Timeout, and Restart of HIP ................37\n   4.6. Certificate Distribution ..................................38\n5. Packet Formats .................................................38\n   5.1. Payload Format ............................................38\n        5.1.1. Checksum ...........................................40\n        5.1.2. HIP Controls .......................................40\n        5.1.3. HIP Fragmentation Support ..........................40\n   5.2. HIP Parameters ............................................41\n        5.2.1. TLV Format .........................................44\n        5.2.2. Defining New Parameters ............................46\n        5.2.3. R1_COUNTER .........................................47\n        5.2.4. PUZZLE .............................................48\n        5.2.5. SOLUTION ...........................................49\n        5.2.6. DH_GROUP_LIST ......................................50\n        5.2.7. DIFFIE_HELLMAN .....................................51\n        5.2.8. HIP_CIPHER .........................................52\n        5.2.9. HOST_ID ............................................54\n        5.2.10. HIT_SUITE_LIST ....................................56\n        5.2.11. TRANSPORT_FORMAT_LIST .............................58\n        5.2.12. HIP_MAC ...........................................59\n        5.2.13. HIP_MAC_2 .........................................59\n        5.2.14. HIP_SIGNATURE .....................................60\n        5.2.15. HIP_SIGNATURE_2 ...................................61\n        5.2.16. SEQ ...............................................61\n        5.2.17. ACK ...............................................62\n        5.2.18. ENCRYPTED .........................................62\n        5.2.19. NOTIFICATION ......................................64\n        5.2.20. ECHO_REQUEST_SIGNED ...............................67\n        5.2.21. ECHO_REQUEST_UNSIGNED .............................68\n        5.2.22. ECHO_RESPONSE_SIGNED ..............................69\n        5.2.23. ECHO_RESPONSE_UNSIGNED ............................69\n   5.3. HIP Packets ...............................................70\n        5.3.1. I1 - the HIP Initiator Packet ......................71\n        5.3.2. R1 - the HIP Responder Packet ......................72\n        5.3.3. I2 - the Second HIP Initiator Packet ...............75\n        5.3.4. R2 - the Second HIP Responder Packet ...............76\n        5.3.5. UPDATE - the HIP Update Packet .....................77\n        5.3.6. NOTIFY - the HIP Notify Packet .....................78\n        5.3.7. CLOSE - the HIP Association Closing Packet .........78\n        5.3.8. CLOSE_ACK - the HIP Closing Acknowledgment Packet ..79",
      "raw": true
    },
    {
      "indent": 3,
      "text": "   5.4. ICMP Messages .............................................79\n        5.4.1. Invalid Version ....................................79\n        5.4.2. Other Problems with the HIP Header and\n               Packet Structure ...................................80\n        5.4.3. Invalid Puzzle Solution ............................80\n        5.4.4. Non-existing HIP Association .......................80\n6. Packet Processing ..............................................80\n   6.1. Processing Outgoing Application Data ......................81\n   6.2. Processing Incoming Application Data ......................82\n   6.3. Solving the Puzzle ........................................83\n   6.4. HIP_MAC and SIGNATURE Calculation and Verification ........84\n        6.4.1. HMAC Calculation ...................................84\n        6.4.2. Signature Calculation ..............................87\n   6.5. HIP KEYMAT Generation .....................................89\n   6.6. Initiation of a HIP Base Exchange .........................90\n        6.6.1. Sending Multiple I1 Packets in Parallel ............91\n        6.6.2. Processing Incoming ICMP Protocol\n               Unreachable Messages ...............................92\n   6.7. Processing of Incoming I1 Packets .........................92\n        6.7.1. R1 Management ......................................94\n        6.7.2. Handling of Malformed Messages .....................94\n   6.8. Processing of Incoming R1 Packets .........................94\n        6.8.1. Handling of Malformed Messages .....................97\n   6.9. Processing of Incoming I2 Packets .........................97\n        6.9.1. Handling of Malformed Messages ....................100\n   6.10. Processing of Incoming R2 Packets .......................101\n   6.11. Sending UPDATE Packets ..................................101\n   6.12. Receiving UPDATE Packets ................................102\n        6.12.1. Handling a SEQ Parameter in a Received\n                UPDATE Message ...................................103\n        6.12.2. Handling an ACK Parameter in a Received\n                UPDATE Packet ....................................104\n   6.13. Processing of NOTIFY Packets ............................104\n   6.14. Processing of CLOSE Packets .............................105\n   6.15. Processing of CLOSE_ACK Packets .........................105\n   6.16. Handling State Loss .....................................105\n7. HIP Policies ..................................................106\n8. Security Considerations .......................................106\n9. IANA Considerations ...........................................109\n10. Differences from RFC 5201 ....................................113\n11. References ...................................................117\n   11.1. Normative References ....................................117\n   11.2. Informative References ..................................119\nAppendix A. Using Responder Puzzles ..............................122\nAppendix B. Generating a Public Key Encoding from an HI ..........123",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Appendix C. Example Checksums for HIP Packets ....................123\n  C.1. IPv6 HIP Example (I1 Packet) ..............................124\n  C.2. IPv4 HIP Packet (I1 Packet) ...............................124\n  C.3. TCP Segment ...............................................125\nAppendix D. ECDH and ECDSA 160-Bit Groups ........................125\nAppendix E. HIT Suites and HIT Generation ........................125\nAcknowledgments ..................................................127\nAuthors' Addresses ...............................................128",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "This document specifies the details of the Host Identity Protocol (HIP). A high-level description of the protocol and the underlying architectural thinking is available in the separate HIP architecture description [HIP-ARCH]. Briefly, the HIP architecture proposes an alternative to the dual use of IP addresses as \"locators\" (routing labels) and \"identifiers\" (endpoint, or host, identifiers). In HIP, public cryptographic keys, of a public/private key pair, are used as host identifiers, to which higher-layer protocols are bound instead of an IP address. By using public keys (and their representations) as host identifiers, dynamic changes to IP address sets can be directly authenticated between hosts, and if desired, strong authentication between hosts at the TCP/IP stack level can be obtained.",
      "ja": "この文書では、ホスト識別プロトコル（HIP）の詳細を指定します。プロトコルと根底にある建築思考の高レベルの記述は、別個のHIPアーキテクチャ記述[HIP-ARCH]で入手可能です。簡単に言えば、HIPアーキテクチャは、「ロケータ」（ルーティングラベル）と「識別子」（エンドポイント、またはホスト、識別子）などのIPアドレスの二重使用に代わるものを提案しています。 HIPでは、公開暗号鍵は、公開鍵/秘密鍵のペアを、その上位層プロトコルは、IPアドレスの代わりにバインドされているために、ホスト識別子として使用されています。ホスト識別子としての公開鍵（およびその表現）を使用して、IPアドレス設定の動的な変更は、直接ホストとの間で認証することができ、必要に応じて、TCP / IPスタックレベルでホストとの間の強力な認証を得ることができます。"
    },
    {
      "indent": 3,
      "text": "This memo specifies the base HIP protocol (\"base exchange\") used between hosts to establish an IP-layer communications context, called a HIP association, prior to communications. It also defines a packet format and procedures for updating and terminating an active HIP association. Other elements of the HIP architecture are specified in other documents, such as:",
      "ja": "このメモは、従来通信にIPレイヤの通信コンテキストを確立するためにホストとの間で使用される（「塩基交換」）、HIPアソシエーションと呼ばれる、ベースHIPプロトコルを指定します。それはまた、活性HIPの関連付けを更新し、終了するためのパケットフォーマットおよび手順を定義します。 HIPアーキテクチャの他の要素は、次のような他の文書で指定されています。"
    },
    {
      "indent": 3,
      "text": "o \"Using the Encapsulating Security Payload (ESP) Transport Format with the Host Identity Protocol (HIP)\" [RFC7402]: how to use the Encapsulating Security Payload (ESP) for integrity protection and optional encryption",
      "ja": "O [RFC7402]「ホストアイデンティティプロトコル（HIP）とカプセル化セキュリティペイロード（ESP）トランスポートフォーマットの使用」：整合性の保護とオプションの暗号化のためのカプセル化セキュリティペイロード（ESP）の使用方法"
    },
    {
      "indent": 3,
      "text": "o \"Host Mobility with the Host Identity Protocol\" [HIP-HOST-MOB]: how to support host mobility in HIP",
      "ja": "[HIP-HOST-MOB] o \"のホスト識別プロトコルとホストモビリティ\"：HIPホストモビリティをサポートする方法"
    },
    {
      "indent": 3,
      "text": "o \"Host Identity Protocol (HIP) Domain Name System (DNS) Extension\" [HIP-DNS-EXT]: how to extend DNS to contain Host Identity information",
      "ja": "O \"ホストアイデンティティプロトコル（HIP）ドメインネームシステム（DNS）拡張子\" [HIP-DNS-EXT]：ホスト識別情報を格納するためのDNSを拡張する方法"
    },
    {
      "indent": 3,
      "text": "o \"Host Identity Protocol (HIP) Rendezvous Extension\" [HIP-REND-EXT]: using a rendezvous mechanism to contact mobile HIP hosts",
      "ja": "O「ホストアイデンティティプロトコル（HIP）ランデブー拡張子」[HIP-REND-EXT]：モバイルHIPホストに連絡するためにランデブーメカニズムを使用して"
    },
    {
      "indent": 3,
      "text": "Since the HIP base exchange was first developed, there have been a few advances in cryptography and attacks against cryptographic systems. As a result, all cryptographic protocols need to be agile. That is, the ability to switch from one cryptographic primitive to another should be a part of such protocols. It is important to support a reasonable set of mainstream algorithms to cater to different use cases and allow moving away from algorithms that are later discovered to be vulnerable. This update to the base exchange includes this needed cryptographic agility while addressing the downgrade attacks that such flexibility introduces. In addition, Elliptic Curve support via Elliptic Curve DSA (ECDSA) and Elliptic Curve Diffie-Hellman (ECDH) has been added.",
      "ja": "HIP基本交換が最初に開発されたため、暗号化と暗号システムへの攻撃では、いくつかの進歩がありました。その結果、すべての暗号化プロトコルは、アジャイルにする必要があります。すなわち、そのようなプロトコルの一部でなければならない別のプリミティブ暗号一方から切り替える機能です。異なるユースケースにお応えし、後で脆弱性が発見されたアルゴリズムから遠ざかっできるように主流のアルゴリズムの合理的なセットをサポートすることが重要です。このような柔軟性が導入されていることをダウングレード攻撃に対処しながら、ベース交換にこの更新は、この必要な暗号俊敏性を含んでいます。また、楕円曲線DSA（ECDSA）と楕円曲線ディフィ - ヘルマン（ECDH）を介して楕円曲線のサポートが追加されています。"
    },
    {
      "indent": 0,
      "text": "1.1. A New Namespace and Identifiers",
      "section_title": true,
      "ja": "1.1. 新しい名前空間と識別子"
    },
    {
      "indent": 3,
      "text": "The Host Identity Protocol introduces a new namespace, the Host Identity namespace. Some ramifications of this new namespace are explained in the HIP architecture description [HIP-ARCH].",
      "ja": "ホスト識別プロトコルは、新しい名前空間、ホストアイデンティティの名前空間を紹介します。この新しい名前空間の一部波及効果は、HIPアーキテクチャ記述[HIP-ARCH]で説明されています。"
    },
    {
      "indent": 3,
      "text": "There are two main representations of the Host Identity, the full Host Identity (HI) and the Host Identity Tag (HIT). The HI is a public key and directly represents the Identity of a host. Since there are different public key algorithms that can be used with different key lengths, the HI, as such, is unsuitable for use as a packet identifier, or as an index into the various state-related implementation structures needed to support HIP. Consequently, a hash of the HI, the Host Identity Tag (HIT), is used as the operational representation. The HIT is 128 bits long and is used in the HIP headers and to index the corresponding state in the end hosts. The HIT has an important security property in that it is self-certifying (see Section 3).",
      "ja": "ホストアイデンティティの二つの主要な表現がありますが、完全なホストアイデンティティ（HI）とホストアイデンティティタグ（HIT）。 HIは、公開鍵であり、直接そのホストのアイデンティティを表します。異なる鍵の長さで使用することができ、異なる公開鍵アルゴリズムがあるので、HIは、等、パケット識別子として、またはHIPをサポートするために必要な種々の状態に関連した実装構造体へのインデックスとして使用するのに不適当です。その結果、HI、ホストアイデンティティタグ（HIT）のハッシュを運用表現として使用されています。 HITは、128ビット長であり、エンドホストに対応する状態HIPヘッダに、インデックスに使用されます。 HITは、それが自己証明（セクション3を参照）であることを重要なセキュリティ性を有しています。"
    },
    {
      "indent": 0,
      "text": "1.2. The HIP Base Exchange (BEX)",
      "section_title": true,
      "ja": "1.2.  HIP基本交換（BEX）"
    },
    {
      "indent": 3,
      "text": "The HIP base exchange is a two-party cryptographic protocol used to establish communications context between hosts. The base exchange is a SIGMA-compliant [KRA03] four-packet exchange. The first party is called the Initiator and the second party the Responder. The protocol exchanges Diffie-Hellman [DIF76] keys in the 2nd and 3rd packets, and authenticates the parties in the 3rd and 4th packets. The four-packet design helps to make HIP resistant to DoS attacks. It allows the Responder to stay stateless until the IP address and the cryptographic puzzle are verified. The Responder starts the puzzle exchange in the 2nd packet, with the Initiator completing it in the 3rd packet before the Responder stores any state from the exchange.",
      "ja": "HIP基本交換は、ホスト間の通信コンテキストを確立するために使用される二つのパーティの暗号プロトコルです。塩基交換はSIGMA準拠[KRA03]四パケット交換機です。最初のパーティは、イニシエータと第二党レスポンダと呼ばれています。プロトコル交換は、ディフィー - ヘルマン[DIF76] 2番目と3番目のパケットのキー、及び3番目と4番目のパケット内の当事者を認証します。 4パケットのデザインは、DoS攻撃へのHIP耐性作るのに役立ちます。これは、IPアドレスと暗号パズルが確認されるまで、Responderはステートレス滞在することができます。 Responderは交換局からレスポンダ店の前に第三のパケット内の任意の状態を、それを完了するイニシエータと、第二パケット内のパズルの交換を開始します。"
    },
    {
      "indent": 3,
      "text": "The exchange can use the Diffie-Hellman output to encrypt the Host Identity of the Initiator in the 3rd packet (although Aura, et al. [AUR05] note that such operation may interfere with packet-inspecting middleboxes), or the Host Identity may instead be sent unencrypted. The Responder's Host Identity is not protected. It should be noted, however, that both the Initiator's and the Responder's HITs are transported as such (in cleartext) in the packets, allowing an eavesdropper with a priori knowledge about the parties to identify them by their HITs. Hence, encrypting the HI of any party does not provide privacy against such an attacker.",
      "ja": "交換は、第3パケット内のイニシエータのホストIDを暗号化するためのDiffie-Hellman出力を使用することができる（ただし、オーラ、ら[AUR05】このような動作は、パケット検査中間装置を妨害し得ることに留意されたい）、またはホストIDが代わりにしてもよいです暗号化されずに送信すること。レスポンダのホストアイデンティティが保護されていません。両方のイニシエータのとレスポンダのヒットは彼らのヒット曲でそれらを識別するために、当事者についての先験的な知識を持つ盗聴が可能、（クリアテキストで）そのようなパケットのように輸送されることに留意すべきです。したがって、当事者のHIを暗号化することは、攻撃者に対してプライバシーを提供していません。"
    },
    {
      "indent": 3,
      "text": "Data packets start to flow after the 4th packet. The 3rd and 4th HIP packets may carry a data payload in the future. However, the details of this may be defined later.",
      "ja": "データパケットは、第四パケットの後に流れ始めます。 3番目と4番目のHIPパケットは、将来的にはデータペイロードを運ぶことができます。しかし、これについての詳細は後で定義することができます。"
    },
    {
      "indent": 3,
      "text": "An existing HIP association can be updated using the update mechanism defined in this document, and when the association is no longer needed, it can be closed using the defined closing mechanism.",
      "ja": "既存のHIP協会は、この文書で定義された更新メカニズムを使用して更新することができ、関連付けが不要になったとき、それは定義された開閉機構を使用して閉じていないことができます。"
    },
    {
      "indent": 3,
      "text": "Finally, HIP is designed as an end-to-end authentication and key establishment protocol, to be used with Encapsulating Security Payload (ESP) [RFC7402] and other end-to-end security protocols. The base protocol does not cover all the fine-grained policy control found in Internet Key Exchange (IKE) [RFC7296] that allows IKE to support complex gateway policies. Thus, HIP is not a complete replacement for IKE.",
      "ja": "最後に、HIPは、カプセル化セキュリティペイロード（ESP）[RFC7402]と他のエンドツーエンドのセキュリティプロトコルと共に使用されるように、エンド・ツー・エンドの認証及び鍵確立プロトコルとして設計されています。基本プロトコルは、IKEは、複合ゲートウェイポリシーをサポートすることを可能にするインターネット鍵交換（IKE）[RFC7296]で見つかったすべてのきめ細かなポリシー制御をカバーしていません。このように、HIPは、IKEのための完全な代替品ではありません。"
    },
    {
      "indent": 0,
      "text": "1.3. Memo Structure",
      "section_title": true,
      "ja": "1.3. メモの構造"
    },
    {
      "indent": 3,
      "text": "The rest of this memo is structured as follows. Section 2 defines the central keywords, notation, and terms used throughout the rest of the document. Section 3 defines the structure of the Host Identity and its various representations. Section 4 gives an overview of the HIP base exchange protocol. Sections 5 and 6 define the detailed packet formats and rules for packet processing. Finally, Sections 7, 8, and 9 discuss policy, security, and IANA considerations, respectively.",
      "ja": "次のようにこのメモの残りの部分が構成されています。第2節では、ドキュメントの残りの部分全体で使用中央キーワード、記号、および用語を定義します。セクション3は、ホストID及びその種々の表現の構造を定義します。セクション4は、HIP基本交換プロトコルの概要を示します。セクション5及び6は、パケット処理の詳細なパケットフォーマットとルールを定義します。最後に、セクション7、8、および9は、それぞれ、ポリシー、セキュリティ、およびIANAの考慮事項について説明します。"
    },
    {
      "indent": 0,
      "text": "2. Terms and Definitions",
      "section_title": true,
      "ja": "2.用語と定義"
    },
    {
      "indent": 0,
      "text": "2.1. Requirements Terminology",
      "section_title": true,
      "ja": "2.1. 要件の用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [RFC2119].",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はRFC 2119 [RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "2.2. Notation",
      "section_title": true,
      "ja": "2.2. 表記法"
    },
    {
      "indent": 3,
      "text": "[x] indicates that x is optional.",
      "ja": "[x]は、xは任意であることを示しています。"
    },
    {
      "indent": 3,
      "text": "{x} indicates that x is encrypted.",
      "ja": "{x}はxが暗号化されていることを示しています。"
    },
    {
      "indent": 3,
      "text": "X(y) indicates that y is a parameter of X.",
      "ja": "X（Y）は、YはXのパラメータであることを示しています"
    },
    {
      "indent": 3,
      "text": "<x>i indicates that x exists i times.",
      "ja": "<x>は、私は、xが私回存在することを示しています。"
    },
    {
      "indent": 3,
      "text": "--> signifies \"Initiator to Responder\" communication (requests).",
      "ja": " - >通信（要求）「をイニシエータがレスポンダに」を意味します。"
    },
    {
      "indent": 3,
      "text": "<-- signifies \"Responder to Initiator\" communication (replies).",
      "ja": "< - が意味「イニシエータにレスポンダ」通信（返信）。"
    },
    {
      "indent": 3,
      "text": "| signifies concatenation of information (e.g., X | Y is the concatenation of X with Y).",
      "ja": "|情報の連結を意味する（例えば、Xは、| Yは、YとXの連結です）。"
    },
    {
      "indent": 3,
      "text": "Ltrunc (H(x), #K) denotes the lowest-order #K bits of the result of the hash function H on the input x.",
      "ja": "Ltrunc（H（x）は、#K）は、入力xにハッシュ関数Hの結果の最下位#Kビットを表します。"
    },
    {
      "indent": 0,
      "text": "2.3. Definitions",
      "section_title": true,
      "ja": "2.3. 定義"
    },
    {
      "indent": 3,
      "text": "HIP base exchange (BEX): The handshake for establishing a new HIP association.",
      "ja": "HIPベース交換（BEX）：新しいHIPの関連性を確立するためのハンドシェイク。"
    },
    {
      "indent": 3,
      "text": "Host Identity (HI): The public key of the signature algorithm that represents the identity of the host. In HIP, a host proves its identity by creating a signature with the private key belonging to its HI (cf. Section 3).",
      "ja": "アイデンティティをホスト（HI）：ホストのIDを表し署名アルゴリズムの公開鍵。 HIPでは、ホストは、そのHI（参照：セクション3）に属する秘密鍵で署名を作成することによって、その身元を証明します。"
    },
    {
      "indent": 3,
      "text": "Host Identity Tag (HIT): A shorthand for the HI in IPv6 format. It is generated by hashing the HI (cf. Section 3.1).",
      "ja": "IPv6形式のHIの略記：アイデンティティタグ（HIT）をホストします。これは、HI（節参照3.1）をハッシュすることによって生成されます。"
    },
    {
      "indent": 3,
      "text": "HIT Suite: A HIT Suite groups all cryptographic algorithms that are required to generate and use an HI and its HIT. In particular, these algorithms are 1) the public key signature algorithm, 2) the hash function, and 3) the truncation (cf. Appendix E).",
      "ja": "HITスイート：HITスイート・グループHIとそのHITを生成し、使用するために必要なすべての暗号アルゴリズム。特に、これらのアルゴリズムは、1）公開鍵署名アルゴリズム、2）ハッシュ関数、及び3）トランケーション（参照付録E）です。"
    },
    {
      "indent": 3,
      "text": "HIP association: The shared state between two peers after completion of the BEX.",
      "ja": "HIPアソシエーション：BEXが完了した後2つのピア間で共有状態。"
    },
    {
      "indent": 3,
      "text": "HIP packet: A control packet carrying a HIP packet header relating to the establishment, maintenance, or termination of the HIP association.",
      "ja": "HIPパケット：HIPアソシエーションの確立、維持、または終了に関連HIPパケットヘッダを運ぶ制御パケット。"
    },
    {
      "indent": 3,
      "text": "Initiator: The host that initiates the BEX. This role is typically forgotten once the BEX is completed.",
      "ja": "イニシエータ：BEXを開始したホスト。 BEXが完了したら、この役割は、一般的に忘れられています。"
    },
    {
      "indent": 3,
      "text": "Responder: The host that responds to the Initiator in the BEX. This role is typically forgotten once the BEX is completed.",
      "ja": "レスポンダ：BEXでイニシエータに応答したホスト。 BEXが完了したら、この役割は、一般的に忘れられています。"
    },
    {
      "indent": 3,
      "text": "Responder's HIT hash algorithm (RHASH): The hash algorithm used for various hash calculations in this document. The algorithm is the same as is used to generate the Responder's HIT. The RHASH is the hash function defined by the HIT Suite of the Responder's HIT (cf. Section 5.2.10).",
      "ja": "レスポンダのHITハッシュアルゴリズム（RHASH）：この文書に記載されている様々なハッシュ計算に使用するハッシュアルゴリズム。このアルゴリズムは、レスポンダのHITを生成するために使用されるのと同じです。 RHASHはレスポンダのHIT（節参照5.2.10）のHITスイートによって定義されたハッシュ関数です。"
    },
    {
      "indent": 3,
      "text": "Length of the Responder's HIT hash algorithm (RHASH_len): The natural output length of RHASH in bits.",
      "ja": "レスポンダのHITハッシュアルゴリズム（RHASH_len）の長さ：ビットでRHASHの天然の出力長。"
    },
    {
      "indent": 3,
      "text": "Signed data: Data that is signed is protected by a digital signature that was created by the sender of the data by using the private key of its HI.",
      "ja": "署名されたデータ：データ署名されているそのHIの秘密鍵を使用して、データの送信者によって作成されたデジタル署名によって保護されています。"
    },
    {
      "indent": 3,
      "text": "KDF: The Key Derivation Function (KDF) is used for deriving the symmetric keys from the Diffie-Hellman key exchange.",
      "ja": "KDF：鍵導出関数（KDF）は、ディフィー・ヘルマン鍵交換から対称鍵を導出するために使用されます。"
    },
    {
      "indent": 3,
      "text": "KEYMAT: The keying material derived from the Diffie-Hellman key exchange by using the KDF. Symmetric keys for encryption and integrity protection of HIP packets and encrypted user data packets are drawn from this keying material.",
      "ja": "KEYMAT：KDFを使用してのDiffie-Hellman鍵交換に由来するキーイングマテリアル。 HIPパケットと暗号化されたユーザデータパケットの暗号化と整合性の保護のための対称鍵は、この鍵素材から引き出されています。"
    },
    {
      "indent": 0,
      "text": "3. Host Identity (HI) and Its Structure",
      "section_title": true,
      "ja": "3.ホストアイデンティティ（HI）とその構造"
    },
    {
      "indent": 3,
      "text": "In this section, the properties of the Host Identity and Host Identity Tag are discussed, and the exact format for them is defined. In HIP, the public key of an asymmetric key pair is used as the Host Identity (HI). Correspondingly, the host itself is defined as the entity that holds the private key of the key pair. See the HIP architecture specification [HIP-ARCH] for more details on the difference between an identity and the corresponding identifier.",
      "ja": "このセクションでは、ホストIDとホスト識別タグの性質が議論され、そしてそれらのための正確な形式が定義されています。 HIPにおいて、非対称鍵ペアの公開鍵は、ホストアイデンティティ（HI）として使用されます。これに対応し、ホスト自体は、鍵ペアの秘密鍵を保持するエンティティとして定義されます。アイデンティティと対応する識別子との間の差の詳細については、HIPアーキテクチャ仕様[HIP-ARCH]を参照。"
    },
    {
      "indent": 3,
      "text": "HIP implementations MUST support the Rivest Shamir Adleman [RSA] public key algorithm and the Elliptic Curve Digital Signature Algorithm (ECDSA) for generating the HI as defined in Section 5.2.9. Additional algorithms MAY be supported.",
      "ja": "HIP実装は、リベストシャミールエイドルマン[RSA]公開鍵アルゴリズム、セクション5.2.9で定義されるようにHIを生成するための楕円曲線デジタル署名アルゴリズム（ECDSA）をサポートしなければなりません。追加のアルゴリズムがサポートされるかもしれません。"
    },
    {
      "indent": 3,
      "text": "A hashed encoding of the HI, the Host Identity Tag (HIT), is used in protocols to represent the Host Identity. The HIT is 128 bits long and has the following three key properties: i) it is the same length as an IPv6 address and can be used in fixed address-sized fields in APIs and protocols; ii) it is self-certifying (i.e., given a HIT, it is computationally hard to find a Host Identity key that matches the HIT); and iii) the probability of a HIT collision between two hosts is very low; hence, it is infeasible for an attacker to find a collision with a HIT that is in use. For details on the security properties of the HIT, see [HIP-ARCH].",
      "ja": "HI、ホストアイデンティティタグ（HIT）のハッシュ化された符号化は、ホストアイデンティティを表現するためにプロトコルで使用されています。 HITは、128ビット長であり、以下の3つの重要な性質を有する：I）は、IPv6アドレスと同じ長さであり、APIおよびプロトコルにおける固定アドレスサイズフィールドに使用することができます。 ⅱ）それは（すなわち、HIT与えられ、）HITと一致するホストのアイデンティティのキ​​ーを見つけることは計算困難である自己証明です。およびiii）2つのホスト間HIT衝突の確率は非常に低いです。攻撃者が使用しているHITとの衝突を発見するために、したがって、それは実行不可能です。 HITのセキュリティプロパティの詳細については、[HIP-ARCH]を参照してください。"
    },
    {
      "indent": 3,
      "text": "The structure of the HIT is defined in [RFC7343]. The HIT is an Overlay Routable Cryptographic Hash Identifier (ORCHID) and consists of three parts: first, an IANA-assigned prefix to distinguish it from other IPv6 addresses; second, a four-bit encoding of the algorithms that were used for generating the HI and the hashed representation of HI; third, a 96-bit hashed representation of the Host Identity. The encoding of the ORCHID generation algorithm and the exact algorithm for generating the hashed representation are specified in Appendix E and [RFC7343].",
      "ja": "HITの構造は、[RFC7343]で定義されています。 HITは、オーバーレイルーティング可能な暗号ハッシュ識別子（ORCHID）であり、3つの部分で構成さ：他のIPv6アドレスと区別するために最初に、IANAによって割り当てられたプレフィックス。第二、HI及びHIのハッシュ表現を生成するために使用されたアルゴリズムの4ビットの符号化、第三に、96ビットがホストIDの表現をハッシュ。蘭生成アルゴリズムの符号化及びハッシュ化された表現を生成するための正確なアルゴリズムは、付録Eと[RFC7343]で指定されています。"
    },
    {
      "indent": 3,
      "text": "Carrying HIs and HITs in the header of user data packets would increase the overhead of packets. Thus, it is not expected that they are carried in every packet, but other methods are used to map the data packets to the corresponding HIs. In some cases, this makes it possible to use HIP without any additional headers in the user data packets. For example, if ESP is used to protect data traffic, the Security Parameter Index (SPI) carried in the ESP header can be used to map the encrypted data packet to the correct HIP association.",
      "ja": "ユーザ・データ・パケットのヘッダで彼とヒットを搬送するパケットのオーバーヘッドを増加させるであろう。したがって、それらはすべてのパケットで運ばれることが期待されていないが、他の方法は、彼の対応にデータパケットをマッピングするために使用されています。いくつかのケースでは、これは、ユーザデータパケットに追加のヘッダーなしでHIPを使用することが可能となります。 ESPは、データトラフィックを保護するために使用される場合、例えば、ESPヘッダで運ばれるセキュリティパラメータインデックス（SPI）が正しいHIPアソシエーションに暗号化されたデータパケットをマッピングするために使用することができます。"
    },
    {
      "indent": 0,
      "text": "3.1. Host Identity Tag (HIT)",
      "section_title": true,
      "ja": "3.1. ホストアイデンティティタグ（HIT）"
    },
    {
      "indent": 3,
      "text": "The Host Identity Tag is a 128-bit value -- a hashed encoding of the Host Identifier. There are two advantages of using a hashed encoding over the actual variable-sized Host Identity public key in protocols. First, the fixed length of the HIT keeps packet sizes manageable and eases protocol coding. Second, it presents a consistent format for the protocol, independent of the underlying identity technology in use.",
      "ja": "ホスト識別子のハッシュ化された符号化 - ホストIDタグは、128ビットの値です。プロトコルの実際の可変サイズのホストアイデンティティの公開鍵の上にハッシュされたエンコーディングを使用しての2つの利点があります。まず、HITの固定長は、管理可能なサイズおよびプロトコル符号化を容易にパケットを保持します。第二に、それは、使用中の基本的なアイデンティティ技術の独立したプロトコルのための一貫性のある形式を提示します。"
    },
    {
      "indent": 3,
      "text": "RFC 7343 [RFC7343] specifies 128-bit hash-based identifiers, called ORCHIDs. Their prefix, allocated from the IPv6 address block, is defined in [RFC7343]. The Host Identity Tag is one type of ORCHID.",
      "ja": "RFC 7343 [RFC7343]はランと呼ばれる128ビットのハッシュベースの識別子を指定します。 IPv6アドレスブロックから割り当てられ、それらの接頭辞は、[RFC7343]で定義されています。ホストアイデンティティタグはORCHIDの一種です。"
    },
    {
      "indent": 3,
      "text": "This document extends the original, experimental HIP specification [RFC5201] with measures to support crypto agility. One of these measures allows different hash functions for creating a HIT. HIT Suites group the sets of algorithms that are required to generate and use a particular HIT. The Suites are encoded in HIT Suite IDs. These HIT Suite IDs are transmitted in the ORCHID Generation Algorithm (OGA) field in the ORCHID. With the HIT Suite ID in the OGA ID field, a host can tell, from another host's HIT, whether it supports the necessary hash and signature algorithms to establish a HIP association with that host.",
      "ja": "この文書は、暗号俊敏性をサポートするための措置で、元の、実験的なHIP仕様[RFC5201]を拡張します。これらの対策の一つは、HITを作成するためのさまざまなハッシュ関数を可能にします。スイート・グループを生成し、特定のHITを使用するために必要とされるアルゴリズムのセットを打ちます。スイートは、HITスイートIDの中でエンコードされています。これらのHITスイートIDはORCHIDにORCHID生成アルゴリズム（OGA）フィールドで送信されています。 OGA IDフィールドにHITスイートIDを使用すると、ホストはそのホストとのHIPアソシエーションを確立するために必要なハッシュと署名アルゴリズムをサポートしているかどうか、別のホストのHITから、伝えることができます。"
    },
    {
      "indent": 0,
      "text": "3.2. Generating a HIT from an HI",
      "section_title": true,
      "ja": "3.2.  HIからHITの生成"
    },
    {
      "indent": 3,
      "text": "The HIT MUST be generated according to the ORCHID generation method described in [RFC7343] using a context ID value of 0xF0EF F02F BFF4 3D0F E793 0C3C 6E61 74EA (this tag value has been generated randomly by the editor of this specification), and an input that encodes the Host Identity field (see Section 5.2.9) present in a HIP payload packet. The set of hash function, signature algorithm, and the algorithm used for generating the HIT from the HI depends on the HIT Suite (see Section 5.2.10) and is indicated by the four bits of the OGA ID field in the ORCHID. Currently, truncated SHA-1, truncated SHA-384, and truncated SHA-256 [FIPS.180-4.2012] are defined as hashes for generating a HIT.",
      "ja": "HITは0xF0EF F02F BFF4 3D0F E793 0C3C 6E61 74EA（このタグの値は、本明細書の編集者によってランダムに生成された）、及び入力のコンテキストID値を使用して、[RFC7343]に記載のラン生成方法に従って生成されなければなりませんHIPペイロードパケットに存在する（5.2.9項を参照）ホストIDフィールドを符号化します。ハッシュ関数、署名アルゴリズム、およびHIからHITを生成するために使用されるアルゴリズムのセットは、HITスイート（セクション5.2.10を参照のこと）に依存し、ORCHIDでOGA IDフィールドの4ビットによって示されます。現在、切り捨てはSHA-1、切断型SHA-384、および短縮型SHA-256 [FIPS.180-4.2012] HITを生成するためのハッシュとして定義されます。"
    },
    {
      "indent": 3,
      "text": "For identities that are either RSA, Digital Signature Algorithm (DSA) [FIPS.186-4.2013], or Elliptic Curve DSA (ECDSA) public keys, the ORCHID input consists of the public key encoding as specified for the Host Identity field of the HOST_ID parameter (see Section 5.2.9). This document defines four algorithm profiles: RSA, DSA, ECDSA, and ECDSA_LOW. The ECDSA_LOW profile is meant for devices with low computational capabilities. Hence, one of the following applies:",
      "ja": "HOST_IDのホストIDフィールドに指定されるようにRSA、デジタル署名アルゴリズム（DSA）[FIPS.186-4.2013]、または楕円曲線DSA（ECDSA）のいずれかの公開鍵であるアイデンティティのために、ラン入力は、公開鍵暗号で構成されパラメータ（5.2.9項を参照してください）。 RSA、DSA、ECDSA、およびECDSA_LOW：この文書では、4つのアルゴリズムプロファイルを定義します。 ECDSA_LOWプロファイルは、低演算能力を持つデバイスのためのものです。したがって、次のいずれかが適用されます。"
    },
    {
      "indent": 6,
      "text": "The RSA public key is encoded as defined in [RFC3110], Section 2, taking the exponent length (e_len), exponent (e), and modulus (n) fields concatenated. The length (n_len) of the modulus (n) can be determined from the total HI Length and the preceding HI fields including the exponent (e). Thus, the data that serves as input for the HIT generation has the same length as the HI. The fields MUST be encoded in network byte order, as defined in [RFC3110].",
      "ja": "[RFC3110]で定義されるようにRSA公開鍵が符号化され、第2、指数長（e_len）を取って、指数（E）、及び弾性率（n）が連結フィールド。モジュラスの長さ（n_len）（n）は、総HI長さ及び指数（E）を含む先行HIフィールドから決定することができます。したがって、HITを生成するための入力となるデータはHIと同じ長さを有しています。 [RFC3110]で定義されたフィールドは、ネットワークバイト順に符号化されなければなりません。"
    },
    {
      "indent": 6,
      "text": "The DSA public key is encoded as defined in [RFC2536], Section 2, taking the fields T, Q, P, G, and Y, concatenated as input. Thus, the data to be hashed is 1 + 20 + 3 * 64 + 3 * 8 * T octets long, where T is the size parameter as defined in [RFC2536]. The size parameter T, affecting the field lengths, MUST be selected as the minimum value that is long enough to accommodate P, G, and Y. The fields MUST be encoded in network byte order, as defined in [RFC2536].",
      "ja": "[RFC2536]、セクション2で定義されるようなDSA公開鍵を入力として連結フィールドT、Q、P、G、及びYを取って、符号化されます。このように、ハッシュされるデータは、1 + 20 + 3 * 64 + 3 * 8 * Tは、[RFC2536]で定義されるサイズパラメータであり、Tは、長いオクテット。フィールド長に影響を及ぼすサイズパラメータTは、[RFC2536]で定義されるフィールドは、ネットワークバイト順に符号化されなければならないP、G、及びYを収容するのに十分な長さの最小値として選択されなければなりません。"
    },
    {
      "indent": 6,
      "text": "The ECDSA public keys are encoded as defined in Sections 4.2 and 6 of [RFC6090].",
      "ja": "セクション4.2で定義され、[RFC6090]の6としてECDSA公開鍵が符号化されます。"
    },
    {
      "indent": 3,
      "text": "In Appendix B, the public key encoding process is illustrated using pseudo-code.",
      "ja": "付録Bにおいて、公開鍵の符号化プロセスは、擬似コードを用いて示されています。"
    },
    {
      "indent": 0,
      "text": "4. Protocol Overview",
      "section_title": true,
      "ja": "4.プロトコルの概要"
    },
    {
      "indent": 3,
      "text": "This section is a simplified overview of the HIP protocol operation, and does not contain all the details of the packet formats or the packet processing steps. Sections 5 and 6 describe in more detail the packet formats and packet processing steps, respectively, and are normative in case of any conflicts with this section.",
      "ja": "このセクションでは、HIPプロトコルの動作の簡略化した概要であり、パケットフォーマット、またはパケット処理手順の詳細をすべて含んでいません。セクション5及び6は、それぞれ、より詳細にはパケットフォーマット及びパケット処理手順を説明し、このセクションとの競合の場合に規定されています。"
    },
    {
      "indent": 3,
      "text": "The protocol number 139 has been assigned by IANA to the Host Identity Protocol.",
      "ja": "プロトコル番号139は、ホストアイデンティティプロトコルにIANAによって割り当てられています。"
    },
    {
      "indent": 3,
      "text": "The HIP payload (Section 5.1) header could be carried in every IP datagram. However, since HIP headers are relatively large (40 bytes), it is desirable to 'compress' the HIP header so that the HIP header only occurs in control packets used to establish or change HIP association state. The actual method for header 'compression' and for matching data packets with existing HIP associations (if any) is defined in separate documents, describing transport formats and methods. All HIP implementations MUST implement, at minimum, the ESP transport format for HIP [RFC7402].",
      "ja": "HIPペイロード（セクション5.1）ヘッダは、すべてのIPデータグラムに実行することができました。 HIPヘッダが（40バイト）が比較的大きいので、HIPヘッダのみHIPアソシエーション状態を確立または変更するために使用される制御パケットに発生するようしかし、それはHIPヘッダ「圧縮」することが望ましいです。ヘッダ「圧縮」および（もしあれば）既存のHIPアソシエーションとデータ・パケットを一致させるための実際の方法は、トランスポートフォーマット及び方法を記載する、別の文書で定義されています。すべてのHIP実装は、最低でも、HIP [RFC7402]のためにESPのトランスポートフォーマットを実装しなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.1. Creating a HIP Association",
      "section_title": true,
      "ja": "4.1.  HIP協会を作成します"
    },
    {
      "indent": 3,
      "text": "By definition, the system initiating a HIP base exchange is the Initiator, and the peer is the Responder. This distinction is typically forgotten once the base exchange completes, and either party can become the Initiator in future communications.",
      "ja": "定義により、HIP基本交換を開始するシステムがイニシエータであり、ピアがレスポンダです。この区別は、塩基交換が完了すると、一般的に忘れられ、いずれかの当事者は、将来の通信にイニシエータになることができます。"
    },
    {
      "indent": 3,
      "text": "The HIP base exchange serves to manage the establishment of state between an Initiator and a Responder. The first packet, I1, initiates the exchange, and the last three packets, R1, I2, and R2, constitute an authenticated Diffie-Hellman [DIF76] key exchange for session-key generation. In the first two packets, the hosts agree on a set of cryptographic identifiers and algorithms that are then used in and after the exchange. During the Diffie-Hellman key exchange, a piece of keying material is generated. The HIP association keys are drawn from this keying material by using a Key Derivation Function (KDF). If other cryptographic keys are needed, e.g., to be used with ESP, they are expected to be drawn from the same keying material by using the KDF.",
      "ja": "HIP基本交換は、イニシエータとレスポンダとの間の状態の確立を管理するのに役立ちます。最初のパケット、I1は、交換を開始し、最後の3つのパケット、R1、I2、及びR2は、認証されたディフィー・ヘルマンセッション鍵生成のための[DIF76]キー交換を構成します。最初の二つのパケットでは、ホストは、次いで、交換に及び後に使用される暗号化識別子およびアルゴリズムのセットに同意します。 Diffie-Hellman鍵交換中、材料をキーイングのピースが生成されます。 HIP関連キーは、鍵導出関数（KDF）を使用して、この鍵材料から引き出されます。他の暗号鍵が必要な場合、例えば、ESPで使用されるように、それらは、KDFを用いて、同一のキーイングマテリアルから引き出されることが期待されます。"
    },
    {
      "indent": 3,
      "text": "The Initiator first sends a trigger packet, I1, to the Responder. The packet contains the HIT of the Initiator and possibly the HIT of the Responder, if it is known. Moreover, the I1 packet initializes the negotiation of the Diffie-Hellman group that is used for generating the keying material. Therefore, the I1 packet contains a list of Diffie-Hellman Group IDs supported by the Initiator. Note that in some cases it may be possible to replace this trigger packet with some other form of a trigger, in which case the protocol starts with the Responder sending the R1 packet. In such cases, another mechanism to convey the Initiator's supported DH groups (e.g., by using a default group) must be specified.",
      "ja": "イニシエータは、ファーストレスポンダに、トリガーパケット、I1を送信します。それがわかっている場合、パケットは、おそらくイニシエータのHITとレスポンダのHITが含まれています。また、I1パケットが鍵材料を生成するために使用されるのDiffie-Hellmanグループのネゴシエーションを初期化します。したがって、I1パケットは、イニシエータでサポートされているのDiffie-HellmanのグループIDのリストが含まれています。いくつかのケースでは、プロトコルはR1パケットを送信レスポンダで開始する場合には、トリガのいくつかの他の形態でこのトリガパケットを交換することが可能であることに留意されたいです。このような場合、イニシエータのサポートDHグループを伝達する別のメカニズム（例えば、デフォルトのグループを使用して）指定されなければなりません。"
    },
    {
      "indent": 3,
      "text": "The second packet, R1, starts the actual authenticated Diffie-Hellman exchange. It contains a puzzle -- a cryptographic challenge that the Initiator must solve before continuing the exchange. The level of difficulty of the puzzle can be adjusted based on the level of trust with the Initiator, the current load, or other factors. In addition, the R1 contains the Responder's Diffie-Hellman parameter and lists of cryptographic algorithms supported by the Responder. Based on these lists, the Initiator can continue, abort, or restart the base exchange with a different selection of cryptographic algorithms. Also, the R1 packet contains a signature that covers selected parts of the message. Some fields are left outside the signature to support pre-created R1s.",
      "ja": "第2のパケット、R1は、実際の認証されたDiffie-Hellman交換を開始します。イニシエータは、交換を続行する前に解決しなければならない暗号挑戦 - それはパズルが含まれています。パズルの難易度は、開始剤、現在の負荷、または他の因子との信頼レベルに基づいて調整することができます。また、R1は、レスポンダののDiffie-Hellmanパラメータとレスポンダでサポートされている暗号化アルゴリズムのリストが含まれています。これらのリストに基づいて、イニシエータは、継続中止、または暗号アルゴリズムの異なる選択と塩基交換を再開することができます。また、R1パケットは、メッセージの選択された部分を覆っている署名を含みます。いくつかのフィールドは、事前に作成したのR1をサポートするために、署名の外に残っています。"
    },
    {
      "indent": 3,
      "text": "In the I2 packet, the Initiator MUST display the solution to the received puzzle. Without a correct solution, the I2 message is discarded. The I2 packet also contains a Diffie-Hellman parameter that carries needed information for the Responder. The I2 packet is signed by the Initiator.",
      "ja": "I2パケットでは、イニシエータは、受信パズルの解決策を表示しなければなりません。正しい解決策がなければ、I2メッセージは破棄されます。 I2パケットもレスポンダに必要な情報を運ぶのDiffie-Hellmanパラメータを含んでいます。 I2パケットは、イニシエータによって署名されています。"
    },
    {
      "indent": 3,
      "text": "The R2 packet acknowledges the receipt of the I2 packet and completes the base exchange. The packet is signed by the Responder.",
      "ja": "R2パケットがI2パケットの受信を確認し、塩基交換を完了します。パケットは、レスポンダによって署名されています。"
    },
    {
      "indent": 3,
      "text": "The base exchange is illustrated below in Figure 1. The term \"key\" refers to the Host Identity public key, and \"sig\" represents a signature using such a key. The packets contain other parameters not shown in this figure.",
      "ja": "塩基交換は、用語「キー」は、ホストアイデンティティの公開鍵を指す、図1において以下に示されており、「SIG」は、そのような鍵を用いて署名を表しています。パケットは、この図に示されていない他のパラメータが含まれています。"
    },
    {
      "indent": 6,
      "text": "Initiator Responder",
      "ja": "イニシエータレスポンダ"
    },
    {
      "indent": 3,
      "text": "                I1: DH list\n              -------------------------->\n                                          select precomputed R1\n                R1: puzzle, DH, key, sig\n              <-------------------------\ncheck sig                                 remain stateless\nsolve puzzle\n              I2: solution, DH, {key}, sig\n              -------------------------->\ncompute DH                                check puzzle\n                                          check sig\n                        R2: sig\n              <--------------------------\ncheck sig                                 compute DH",
      "raw": true
    },
    {
      "indent": 33,
      "text": "Figure 1",
      "ja": "図1"
    },
    {
      "indent": 0,
      "text": "4.1.1. HIP Puzzle Mechanism",
      "section_title": true,
      "ja": "4.1.1.  HIPパズルメカニズム"
    },
    {
      "indent": 3,
      "text": "The purpose of the HIP puzzle mechanism is to protect the Responder from a number of denial-of-service threats. It allows the Responder to delay state creation until receiving the I2 packet. Furthermore, the puzzle allows the Responder to use a fairly cheap calculation to check that the Initiator is \"sincere\" in the sense that it has churned enough CPU cycles in solving the puzzle.",
      "ja": "HIPパズル機構の目的は、サービス拒否の脅威の数からレスポンダを保護することです。これは、ResponderがI2パケットを受信するまでの状態の作成を遅らせることができます。さらに、パズルは、Responderがイニシエータは、それがパズルを解くには、十分なCPUサイクルを解約したという意味で、「誠実」であることを確認するために、かなり安価な計算を使用することができます。"
    },
    {
      "indent": 3,
      "text": "The puzzle allows a Responder implementation to completely delay association-specific state creation until a valid I2 packet is received. An I2 packet without a valid puzzle solution can be rejected immediately once the Responder has checked the solution. The solution can be checked by computing only one hash function, and invalid solutions can be rejected before state is created, and before CPU-intensive public-key signature verification and Diffie-Hellman key generation are performed. By varying the difficulty of the puzzle, the Responder can frustrate CPU- or memory-targeted DoS attacks.",
      "ja": "パズルは、有効なI2パケットが受信されるまでレスポンダの実装は完全に関連固有の状態の作成を遅らせることができます。 Responderが解決策を確認した後、有効なパズルの解決なしI2パケットが即座に拒否することができます。溶液は、1つのハッシュ関数を計算することによって確認することができ、そして状態が作成される前に無効なソリューションは拒否することができ、CPU集約型公開鍵署名検証およびDiffie-Hellman鍵生成前に行われます。パズルの難易度を変化させることにより、ResponderはCPU-メモリまたは標的DoS攻撃を阻むことができます。"
    },
    {
      "indent": 3,
      "text": "The Responder can remain stateless and drop most spoofed I2 packets because puzzle calculation is based on the Initiator's Host Identity Tag. The idea is that the Responder has a (perhaps varying) number of pre-calculated R1 packets, and it selects one of these based on the information carried in the I1 packet. When the Responder then later receives the I2 packet, it can verify that the puzzle has been solved using the Initiator's HIT. This makes it impractical for the attacker to first exchange one I1/R1 packet, and then generate a large number of spoofed I2 packets that seemingly come from different HITs. This method does not protect the Responder from an attacker that uses fixed HITs, though. Against such an attacker, a viable approach may be to create a piece of local state, and remember that the puzzle check has previously failed. See Appendix A for one possible implementation. Responder implementations SHOULD include sufficient randomness in the puzzle values so that algorithmic complexity attacks become impossible [CRO03].",
      "ja": "Responderはステートレスままとパズルの計算は、イニシエータのホストアイデンティティタグに基づいているため、ほとんどの偽装されたI2パケットをドロップすることができます。アイデアは、レスポンダは予め計算R1パケットの（おそらく変化する）番号を有することであり、I1パケットで運ばれた情報に基づいて、これらのいずれかを選択します。 Responderがその後I2パケットを受信すると、パズルがイニシエータのHITを使用して解決されていることを確認することができます。これは、第1交換I1 / R1パケットに攻撃者にとっては非現実的になり、その後、一見異なるヒットから来る偽装I2パケットを大量に生成します。この方法は、しかし、固定されたヒットを使用して、攻撃者からのレスポンダを保護することはできません。こうした攻撃に対して、実行可能なアプローチは、ローカル状態の作品を作成して、パズルのチェックが以前に失敗したことを覚えておくことかもしれません。一つの可能​​な実装については、付録Aを参照してください。アルゴリズムの複雑攻撃は[CRO03]不可能になるようにレスポンダの実装は、パズル値で十分ランダム性を含むべきです。"
    },
    {
      "indent": 3,
      "text": "The Responder can set the puzzle difficulty for the Initiator, based on its level of trust of the Initiator. Because the puzzle is not included in the signature calculation, the Responder can use pre-calculated R1 packets and include the puzzle just before sending the R1 to the Initiator. The Responder SHOULD use heuristics to determine when it is under a denial-of-service attack, and set the puzzle difficulty value #K appropriately, as explained later.",
      "ja": "レスポンダは、イニシエータの信頼のそのレベルに基づいて、イニシエータのためのパズルの難易度を設定することができます。パズルは、署名計算に含まれないため、レスポンダは、予め計算R1パケットを使用して、単にイニシエータにR1を送信する前にパズルを含むことができます。 Responderは、それがサービス拒否攻撃を受けているときを決定するヒューリスティックを使用して、後述するように、適切にパズルの難易値＃Kを設定する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.1.2. Puzzle Exchange",
      "section_title": true,
      "ja": "4.1.2. パズル交換"
    },
    {
      "indent": 3,
      "text": "The Responder starts the puzzle exchange when it receives an I1 packet. The Responder supplies a random number #I, and requires the Initiator to find a number #J. To select a proper #J, the Initiator must create the concatenation of #I, the HITs of the parties, and #J, and calculate a hash over this concatenation using the RHASH algorithm. The lowest-order #K bits of the result MUST be zeros. The value #K sets the difficulty of the puzzle.",
      "ja": "Responderは、それがI1パケットを受信したパズルの交換を開始します。 Responderは乱数#Iを供給し、番号の#Jを見つけるために、イニシエータが必要です。適切な#Jを選択するには、イニシエータは、＃I、当事者のヒット、そして#Jの連結を作成し、RHASHアルゴリズムを使用して、この連結上のハッシュを計算する必要があります。結果の最下位#Kビットはゼロでなければなりません。値＃Kは、パズルの難易度を設定します。"
    },
    {
      "indent": 3,
      "text": "To generate a proper number #J, the Initiator will have to generate a number of #Js until one produces the hash target of zeros. The Initiator SHOULD give up after exceeding the puzzle Lifetime in the PUZZLE parameter (as described in Section 5.2.4). The Responder needs to re-create the concatenation of #I, the HITs, and the provided #J, and compute the hash once to prove that the Initiator completed its assigned task.",
      "ja": "適切な数の#Jを生成するには、イニシエータは1つがゼロのハッシュターゲットを作るまで#Jsの番号を生成する必要があります。イニシエータは、パズルパラメータ（5.2.4項に記載されているように）にパズルの寿命を超えた後に放棄すべきです。 Responderは＃I、ヒット、および提供#Jの連結を再作成し、イニシエータはその割り当てられたタスクを完了したことを証明するために、一度ハッシュを計算する必要があります。"
    },
    {
      "indent": 3,
      "text": "To prevent precomputation attacks, the Responder MUST select the number #I in such a way that the Initiator cannot guess it. Furthermore, the construction MUST allow the Responder to verify that the value #I was indeed selected by it and not by the Initiator. See Appendix A for an example on how to implement this.",
      "ja": "事前計算攻撃を防ぐために、レスポンダはイニシエータがそれを推測できないように番号#Iを選択する必要があります。さらに、工事はResponderが値#Iが実際にそれではなくイニシエータによって選択されたことを確認するために許容しなければなりません。これを実装する方法の例については、付録Aを参照してください。"
    },
    {
      "indent": 3,
      "text": "Using the Opaque data field in the PUZZLE (see Section 5.2.4) in an ECHO_REQUEST_SIGNED (see Section 5.2.20) or in an ECHO_REQUEST_UNSIGNED parameter (see Section 5.2.21), the Responder",
      "ja": "パズルに不透明なデータフィールドを使用して、レスポンダをECHO_REQUEST_SIGNED（セクション5.2.20を参照）（セクション5.2.4を参照）またはECHO_REQUEST_UNSIGNEDパラメータで（セクション5.2.21を参照のこと）"
    },
    {
      "indent": 3,
      "text": "can include some data in R1 that the Initiator MUST copy unmodified in the corresponding I2 packet. The Responder can use the opaque data to transfer a piece of local state information to the Initiator and back -- for example, to recognize that the I2 is a response to a previously sent R1. The Responder can generate the opaque data in various ways, e.g., using encryption or hashing with some secret, the sent #I, and possibly using other related data. With the same secret, the received #I (from the I2 packet), and the other related data (if any), the Responder can verify that it has itself sent the #I to the Initiator. The Responder MUST periodically change such a secret.",
      "ja": "イニシエータは、対応I2パケットに修飾されていないコピーしなければならないことR1内の一部のデータを含むことができます。レスポンダは、イニシエータに局所的な状態情報の部分を転送しバックアップする不透明なデータを使用することができる - 例えば、I2が以前R1送信に対する応答であることを認識します。 Responderは、暗号化を使用したり、いくつかの秘密、送られた＃Iでハッシング、そしておそらく他の関連データを使用して、例えば、さまざまな方法で不透明なデータを生成することができます。同じ秘密、受信#I（I2パケットから）、および他の関連データ（もしあれば）と、レスポンダは、それ自体がイニシエータに#Iを送信したことを確認することができます。 Responderは、定期的な秘密を変更する必要があります。"
    },
    {
      "indent": 3,
      "text": "It is RECOMMENDED that the Responder generates new secrets for the puzzle and new R1s once every few minutes. Furthermore, it is RECOMMENDED that the Responder is able to verify a valid puzzle solution at least Lifetime seconds after the puzzle secret has been deprecated. This time value guarantees that the puzzle is valid for at least Lifetime and at most 2 * Lifetime seconds. This limits the usability that an old, solved puzzle has to an attacker. Moreover, it avoids problems with the validity of puzzles if the lifetime is relatively short compared to the network delay and the time for solving the puzzle.",
      "ja": "Responderがパズルと新しいのR1に一度、数分のための新たな秘密を生成することを推奨されます。さらに、Responderがパズルの秘密が廃止されました、少なくとも生涯秒後に有効なパズルの解決策を確認することができることが推奨されます。パズルは、少なくとも生涯のために、ほとんどの2 *生涯秒で有効であることをこの時間値を保証します。これは、古い、解決パズルが攻撃者にあり利便性を制限します。寿命が比較的短いネットワーク遅延やパズルを解決するための時間と比較した場合また、それはパズルの妥当性の問題を回避します。"
    },
    {
      "indent": 3,
      "text": "The puzzle value #I and the solution #J are inputs for deriving the keying material from the Diffie-Hellman key exchange (see Section 6.5). Therefore, to ensure that the derived keying material differs, a Responder SHOULD NOT use the same puzzle #I with the same DH keys for the same Initiator twice. Such uniqueness can be achieved, for example, by using a counter as an additional input for generating #I. This counter can be increased for each processed I1 packet. The state of the counter can be transmitted in the Opaque data field in the PUZZLE (see Section 5.2.4), in an ECHO_REQUEST_SIGNED parameter (see Section 5.2.20), or in an ECHO_REQUEST_UNSIGNED parameter (see Section 5.2.21) without the need to establish state.",
      "ja": "パズル値#Iと溶液#Jは、ディフィー・ヘルマン鍵共有（セクション6.5を参照）からの鍵材料を導出するための入力です。したがって、派生鍵材料が異なることを保証するために、Responderは二度同じイニシエータに同じDHキーと同じパズル#Iを使用しないでください。そのような独自性は、例えば、#Iを生成するための追加の入力としてカウンタを使用することによって、達成することができます。このカウンターは、各処理されたI1パケットのために増加させることができます。カウンタの状態は、なし（セクション5.2.21を参照のこと）パズルに不透明なデータフィールド（セクション5.2.4を参照）、ECHO_REQUEST_SIGNEDパラメータ（セクション5.2.20を参照）、またはECHO_REQUEST_UNSIGNEDパラメータで送信することができます状態を確立する必要があります。"
    },
    {
      "indent": 3,
      "text": "NOTE: The protocol developers explicitly considered whether R1 should include a timestamp in order to protect the Initiator from replay attacks. The decision was to NOT include a timestamp, to avoid problems with global time synchronization.",
      "ja": "注：プロトコルの開発者が明示的にR1は、リプレイ攻撃からイニシエータを保護するためにタイムスタンプを含めるべきかどうかを検討しました。決定は、グローバル時刻同期の問題を回避するために、タイムスタンプを含めないようにしました。"
    },
    {
      "indent": 3,
      "text": "NOTE: The protocol developers explicitly considered whether a memory-bound function should be used for the puzzle instead of a CPU-bound function. The decision was to not use memory-bound functions.",
      "ja": "注：プロトコルの開発者が明示的にメモリが結合した機能ではなく、CPUバウンド機能のパズルのために使用すべきかどうかを検討しました。決定は、メモリが結合した機能を使用しないことでした。"
    },
    {
      "indent": 0,
      "text": "4.1.3. Authenticated Diffie-Hellman Protocol with DH Group Negotiation",
      "section_title": true,
      "ja": "4.1.3.  DHグループの交渉で認証のDiffie-Hellmanのプロトコル"
    },
    {
      "indent": 3,
      "text": "The packets R1, I2, and R2 implement a standard authenticated Diffie-Hellman exchange. The Responder sends one of its public Diffie-Hellman keys and its public authentication key, i.e., its Host Identity, in R1. The signature in the R1 packet allows the Initiator to verify that the R1 has been once generated by the Responder. However, since the R1 is precomputed and therefore does not cover association-specific information in the I1 packet, it does not protect against replay attacks.",
      "ja": "パケットR1、I2、及びR2は、標準的な認証のDiffie-Hellman交換を実現します。 ResponderはR1で、その公共のDiffie-Hellman鍵とその公開認証キー、すなわち、そのホストのアイデンティティの1を送信します。 R1パケット内の署名は、イニシエータがR1が一度レスポンダによって生成されたことを確認することを可能にします。 R1は、事前に計算され、したがって、I1パケット内の関連固有の情報をカバーしていないので、しかし、それはリプレイ攻撃を防ぐことはできません。"
    },
    {
      "indent": 3,
      "text": "Before the actual authenticated Diffie-Hellman exchange, the Initiator expresses its preference regarding its choice of the DH groups in the I1 packet. The preference is expressed as a sorted list of DH Group IDs. The I1 packet is not protected by a signature. Therefore, this list is sent in an unauthenticated way to avoid costly computations for processing the I1 packet at the Responder side. Based on the preferences of the Initiator, the Responder sends an R1 packet containing its most suitable public DH value. The Responder also attaches a list of its own preferences to the R1 to convey the basis for the DH group selection to the Initiator. This list is carried in the signed part of the R1 packet. If the choice of the DH group value in the R1 does not match the preferences of the Initiator and the Responder, the Initiator can detect that the list of DH Group IDs in the I1 was manipulated (see below for details).",
      "ja": "実際の認証済みのDiffie-Hellman交換の前に、イニシエータは、I1パケット内のDHグループのその選択に関するその好みを表現しています。好ましいのは、DHグループIDのソートされたリストとして表現されます。 I1パケットが署名により保護されていません。したがって、このリストは、レスポンダ側I1パケットを処理するための高価な計算を回避するために認証されていない方法で送信されます。イニシエータの好みに基づいて、Responderはその最も適した公共DH値を含むR1パケットを送信します。 Responderはまた、イニシエータへのDHグループを選択するための基礎を伝えるためにR1に、自身の好みのリストを添付します。このリストは、R1パケットの署名部分に運ばれます。 R1でのDHグループ値の選択は、イニシエータとレスポンダの好みと一致しない場合、イニシエータは、（詳細は下記を参照してください）I1でDHグループIDのリストが操作されたことを検出することができます。"
    },
    {
      "indent": 3,
      "text": "If none of the DH Group IDs in the I1 packet are supported by the Responder, the Responder selects the DH group most suitable for it, regardless of the Initiator's preference. It then sends the R1 containing this DH group and its list of supported DH Group IDs to the Initiator.",
      "ja": "I1パケット内のDHグループIDのいずれもレスポンダによってサポートされていない場合、Responderは関係なく、イニシエータの好みの、それのために最も適したDHグループを選択します。それは、このDHグループを含むR1とイニシエータへのサポートDHグループIDのリストを送信します。"
    },
    {
      "indent": 3,
      "text": "When the Initiator receives an R1, it receives one of the Responder's public Diffie-Hellman values and the list of DH Group IDs supported by the Responder. This list is covered by the signature in the R1 packet to avoid forgery. The Initiator compares the Group ID of the public DH value in the R1 packet to the list of supported DH Group IDs in the R1 packets and to its own preferences expressed in the list of supported DH Group IDs. The Initiator continues the BEX only if the Group ID of the public DH value of the Responder is the most preferred of the IDs supported by both the Initiator and Responder. Otherwise, the communication is subject to a downgrade attack, and the Initiator MUST either restart the base exchange with a new I1 packet or abort the base exchange. If the Responder's choice of the DH group is not supported by the Initiator, the Initiator MAY abort the handshake or send a new I1 packet with a different list of supported DH groups. However, the Initiator MUST verify the signature of the R1 packet before restarting or aborting the handshake. It MUST silently ignore the R1 packet if the signature is not valid.",
      "ja": "イニシエータは、R1を受信すると、レスポンダの公開のDiffie-Hellman値のいずれかとレスポンダでサポートされているDHグループIDのリストを受け取ります。このリストは、偽造を防ぐためにR1パケットに署名で覆われています。イニシエータは、R1パケットでサポートされているDHグループIDのリストに、サポートDHグループIDのリストで表し、自身の好みにR1パケット内の公共DH値のグループIDを比較します。イニシエータは、レスポンダの公開DH値のグループIDが最もイニシエータとレスポンダの両方でサポートされているIDの好まれている場合のみBEXを続けています。そうでなければ、通信はダウングレード攻撃を受け、イニシエータは新しいI1パケットで塩基交換を再起動するか、塩基交換を中止する必要があります。 DHグループのレスポンダの選択は、イニシエータでサポートされていない場合、イニシエータは握手を中止またはサポートされているDHグループの別のリストに新しいI1パケットを送信することができます。しかし、イニシエータは、再起動したり握手を中止する前にR1パケットの署名を検証しなければなりません。署名が有効でない場合には黙っR1パケットを無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the preferences regarding the DH Group ID match, the Initiator computes the Diffie-Hellman session key (Kij). The Initiator creates a HIP association using keying material from the session key (see Section 6.5) and may use the HIP association to encrypt its public authentication key, i.e., the Host Identity. The resulting I2 packet contains the Initiator's Diffie-Hellman key and its (optionally encrypted) public authentication key. The signature of the I2 message covers all parameters of the signed parameter ranges (see Section 5.2) in the packet without exceptions, as in the R1.",
      "ja": "DHグループIDの一致に関する嗜好場合、イニシエータはのDiffie-Hellmanセッションキー（Kijを）を計算します。イニシエータは、セッション鍵（セクション6.5を参照）から、キーイング材料を使用して、HIPの関連付けを作成し、その公開認証鍵、すなわち、ホストIDを暗号化するためにHIPアソシエーションを使用してもよいです。その結果I2パケットは、イニシエータののDiffie-Hellmanキーと（必要に応じて暗号化された）パブリック認証キーが含まれています。 I2メッセージの署名は、署名されたパラメータの範囲のすべてのパラメータは、R1のように、例外なしパケットに（セクション5.2を参照）を覆っています。"
    },
    {
      "indent": 3,
      "text": "The Responder extracts the Initiator's Diffie-Hellman public key from the I2 packet, computes the Diffie-Hellman session key, creates a corresponding HIP association, and decrypts the Initiator's public authentication key. It can then verify the signature using the authentication key.",
      "ja": "レスポンダは、I2パケットからイニシエータのディフィー - ヘルマン公開鍵を抽出するのDiffie-Hellmanセッション鍵を計算し、対応するHIPアソシエーションを作成し、イニシエータの公開認証鍵を復号化します。その後、認証キーを使用して署名を検証することができます。"
    },
    {
      "indent": 3,
      "text": "The final message, R2, completes the BEX and protects the Initiator against replay attacks, because the Responder uses the shared key from the Diffie-Hellman exchange to create a Hashed Message Authentication Code (HMAC) and also uses the private key of its Host Identity to sign the packet contents.",
      "ja": "Responderがハッシュメッセージ認証コード（HMAC）を作成するのDiffie-Hellman交換から共有キーを使用しても、そのホストIDの秘密鍵を使用しているため、最終的なメッセージ、R2は、BEXを完了し、リプレイ攻撃に対するイニシエータを保護しますパケットの内容を署名します。"
    },
    {
      "indent": 0,
      "text": "4.1.4. HIP Replay Protection",
      "section_title": true,
      "ja": "4.1.4.  HIPリプレイ保護"
    },
    {
      "indent": 3,
      "text": "HIP includes the following mechanisms to protect against malicious packet replays. Responders are protected against replays of I1 packets by virtue of the stateless response to I1 packets with pre-signed R1 messages. Initiators are protected against R1 replays by a monotonically increasing \"R1 generation counter\" included in the R1. Responders are protected against replays of forged I2 packets by the puzzle mechanism (see Section 4.1.1 above), and optional use of opaque data. Hosts are protected against replays of R2 packets and UPDATEs by use of a less expensive HMAC verification preceding the HIP signature verification.",
      "ja": "HIPは、悪意のあるパケットリプレイから保護するために、以下のメカニズムが含まれています。応答者は、予め署名R1メッセージでI1パケットにステートレス応答によってI1パケットのリプレイから保護されます。開始剤は、R1に含まれて単調に増加する「R1世代カウンタ」によってR1リプレイから保護されています。応答者がパズル機構によって偽造I2パケットのリプレイから保護され、不透明なデータの任意の使用（セクション4.1.1上記を参照のこと）。ホストはHIP署名検証を先行安価HMAC認証を使用することによってR2パケットおよび更新のリプレイから保護されます。"
    },
    {
      "indent": 3,
      "text": "The R1 generation counter is a monotonically increasing 64-bit counter that may be initialized to any value. The scope of the counter MAY be system-wide, but there SHOULD be a separate counter for each Host Identity, if there is more than one local Host Identity. The value of this counter SHOULD be preserved across system reboots and invocations of the HIP base exchange. This counter indicates the current generation of puzzles. Implementations MUST accept puzzles from the current generation and MAY accept puzzles from earlier generations. A system's local counter MUST be incremented at least as often as every time old R1s cease to be valid. The local counter SHOULD never be decremented; otherwise, the host exposes its peers to the replay of previously generated, higher-numbered R1s.",
      "ja": "R1生成カウンタは、任意の値に初期化され得る、単調に増加する64ビット・カウンタです。カウンタの範囲は、システム全体であってもよく、しかし、複数のローカルホストIDが存在する場合、各ホストIDのために別個のカウンタがあるべきです。このカウンタの値は、システムが再起動し、HIP基本交換の呼出しに対して保存されるべきです。このカウンタは、パズルの現在の発生を示します。実装は、現在の世代からパズルを受け入れなければならないし、それ以前の世代からパズルを受け入れることができます。システムのローカルカウンタを有効にするたびに、古いのR1の停戦と少なくとも同じ頻繁に増加しなければなりません。ローカルカウンタをデクリメントしてはいけません。そうでない場合、ホストは、以前に生成され、より高い番号のR1の再生にそのピアを露出させます。"
    },
    {
      "indent": 3,
      "text": "A host may receive more than one R1, either due to sending multiple I1 packets (see Section 6.6.1) or due to a replay of an old R1. When sending multiple I1 packets to the same host, an Initiator SHOULD wait for a small amount of time (a reasonable time may be 2 * expected RTT) after the first R1 reception to allow possibly multiple R1s to arrive, and it SHOULD respond to an R1 among the set with the largest R1 generation counter. If an Initiator is processing an R1 or has already sent an I2 packet (still waiting for the R2 packet) and it receives another R1 with a larger R1 generation counter, it MAY elect to restart R1 processing with the fresher R1, as if it were the first R1 to arrive.",
      "ja": "ホストが古いR1の再生に複数I1パケットを送信のために（セクション6.6.1を参照）、またはいずれかによる、複数のR1を受信することができます。同じホストに複数I1パケットを送信するとき、イニシエータは、おそらく複数のR1が到達できるように最初のR1受信後（妥当な時間は2 *はRTTを期待することができる）時間の少量のを待つ必要があり、それに応答すべき最大のR1世代のカウンターとセットの中R1。イニシエータは、R1を処理しているか、既にI2パケットを送信した（依然としてR2パケットを待っている）、それは、より大きなR1生成カウンタと別のR1を受信し、それはあたかも、新鮮R1とR1の処理を再開することを選択することができる場合到着する最初のR1。"
    },
    {
      "indent": 3,
      "text": "The R1 generation counter may roll over or may become reset. It is important for an Initiator to be robust to the loss of state about the R1 generation counter of a peer or to a reset of the peer's counter. It is recommended that, when choosing between multiple R1s, the Initiator prefer to use the R1 that corresponds to the current R1 generation counter, but that if it is unable to make progress with that R1, the Initiator may try the other R1s, beginning with the R1 packet with the highest counter.",
      "ja": "R1生成カウンタはロールオーバーしたり、リセットになることがあります。イニシエータがピアのR1生成カウンタについてまたはピアのカウンタのリセットに状態の損失に対してロバストであることが重要です。複数のR1、イニシエータの間で選択する際には、現在のR1世代のカウンターに対応するR1を使用することを好む、ということをお勧めしますが、それはそのR1と進歩を遂げることができない場合、イニシエータは、他のR1を試みること、で始まります最高のカウンターでR1パケット。"
    },
    {
      "indent": 0,
      "text": "4.1.5. Refusing a HIP Base Exchange",
      "section_title": true,
      "ja": "4.1.5.  HIP基本交換を拒否"
    },
    {
      "indent": 3,
      "text": "A HIP-aware host may choose not to accept a HIP base exchange. If the host's policy is to only be an Initiator and policy allows the establishment of a HIP association with the original Initiator, it should begin its own HIP base exchange. A host MAY choose to have such a policy since only the privacy of the Initiator's HI is protected in the exchange. It should be noted that such behavior can introduce the risk of a race condition if each host's policy is to only be an Initiator, at which point the HIP base exchange will fail.",
      "ja": "HIP-意識したホストは、HIP基本交換はお受けしないこともできます。ホストのポリシーが唯一のイニシエータすることで、ポリシーは、元のイニシエータとHIP協会の設立を許可している場合、それは自身のHIP基本交換を開始する必要があります。ホストは、イニシエータのHIの唯一のプライバシーが交換で保護されているため、このようなポリシーを持っているのを選ぶかもしれ。各ホストのポリシーは唯一のHIP基本交換が失敗した時点で、イニシエータ、する場合は、そのような行動は、競合状態の危険性を導入できることに留意すべきです。"
    },
    {
      "indent": 3,
      "text": "If the host's policy does not permit it to enter into a HIP exchange with the Initiator, it should send an ICMP 'Destination Unreachable, Administratively Prohibited' message. A more complex HIP packet is not used here as it actually opens up more potential DoS attacks than a simple ICMP message. A HIP NOTIFY message is not used because no HIP association exists between the two hosts at that time.",
      "ja": "ホストのポリシーは、イニシエータとHIP交換に入ることを許可しない場合は、ICMP「宛先到達不能、管理上禁止」というメッセージを送信する必要があります。より複雑なHIPパケットは、それが実際に簡単なICMPメッセージよりも多くの潜在的なDoS攻撃を開くと、ここで使用されていません。何HIPアソシエーションがその時点で2つのホスト間に存在しないので、HIP NOTIFYメッセージは使用されません。"
    },
    {
      "indent": 0,
      "text": "4.1.6. Aborting a HIP Base Exchange",
      "section_title": true,
      "ja": "4.1.6.  HIP基本交換を中止"
    },
    {
      "indent": 3,
      "text": "Two HIP hosts may encounter situations in which they cannot complete a HIP base exchange because of insufficient support for cryptographic algorithms, in particular the HIT Suites and DH groups. After receiving the R1 packet, the Initiator can determine whether the Responder supports the required cryptographic operations to successfully establish a HIP association. The Initiator can abort the BEX silently after receiving an R1 packet that indicates an unsupported set of algorithms. The specific conditions are described below.",
      "ja": "二つHIPホストは、それらがHITスイートおよびDHグループ特に、なぜなら暗号化アルゴリズムのための不十分な支持体のHIP基本交換を完了できない状況が発生する場合があります。 R1パケットを受信した後、イニシエータは、レスポンダが正常HIPアソシエーションを確立するために必要な暗号化操作をサポートしているかどうかを確認することができます。イニシエータは、アルゴリズムのサポートされていないセットを示すR1パケットを受信した後、静かにBEXを中止することができます。具体的な条件は以下の通りです。"
    },
    {
      "indent": 3,
      "text": "The R1 packet contains a signed list of HIT Suite IDs as supported by the Responder. Therefore, the Initiator can determine whether its source HIT is supported by the Responder. If the HIT Suite ID of the Initiator's HIT is not contained in the list of HIT Suites in the R1, the Initiator MAY abort the handshake silently or MAY restart the handshake with a new I1 packet that contains a source HIT supported by the Responder.",
      "ja": "レスポンダでサポートされているようR1パケットは、HITスイートIDの署名リストが含まれています。したがって、イニシエータは、そのソースHITは、レスポンダによって支持されているかどうかを判定することができます。イニシエータのHITのHITスイートIDがR1でHITスイートのリストに含まれていない場合、イニシエータは黙って握手を中止したり、レスポンダでサポートされているソースHITを含む新しいI1パケットと握手を再起動する場合があります。"
    },
    {
      "indent": 3,
      "text": "During the handshake, the Initiator and the Responder agree on a single DH group. The Responder selects the DH group and its DH public value in the R1 based on the list of DH Group IDs in the I1 packet. If the Responder supports none of the DH groups requested by the Initiator, the Responder selects an arbitrary DH and replies with an R1 containing its list of supported DH Group IDs. In such a case, the Initiator receives an R1 packet containing the DH public value for an unrequested DH group and also the Responder's DH group list in the signed part of the R1 packet. At this point, the Initiator MAY abort the handshake or MAY restart the handshake by sending a new I1 packet containing a selection of DH Group IDs that is supported by the Responder.",
      "ja": "ハンドシェイク時に、イニシエータとレスポンダは、単一のDHグループに同意するものとします。 ResponderはDHグループとI1パケット内のDHグループIDのリストに基づいて、R1でのDH公開値を選択します。レスポンダがイニシエータによって要求されたDHグループのどれをサポートしていない場合は、Responderは任意のDHを選択して、サポートDHグループIDのリストを含むR1で応答します。このような場合には、イニシエータは、R1パケットの署名された部分における非要求DHグループのDHパブリック値ともレスポンダのDHグループリストを含むR1パケットを受信します。この時点で、イニシエータは握手を中止したり、レスポンダによってサポートされているDHグループIDの選択を含む新しいI1パケットを送信することにより、ハンドシェイクを再起動する場合があります。"
    },
    {
      "indent": 0,
      "text": "4.1.7. HIP Downgrade Protection",
      "section_title": true,
      "ja": "4.1.7.  HIPダウングレードの保護"
    },
    {
      "indent": 3,
      "text": "In a downgrade attack, an attacker attempts to unnoticeably manipulate the packets of an Initiator and/or a Responder to influence the result of the cryptographic negotiations in the BEX in its favor. As a result, the victims select weaker cryptographic algorithms than they would otherwise have selected without the attacker's interference. Downgrade attacks can only be successful if they remain undetected by the victims and the victims falsely assume a secure communication channel.",
      "ja": "ダウングレード攻撃では、攻撃者がunnoticeablyイニシエータのパケットおよび/またはその好意でBEXで暗号化交渉の結果に影響を与えるレスポンダを操作しようとします。その結果、被害者は、彼らがそうでなければ、攻撃者の干渉なしに選択されているであろうよりも弱い暗号化アルゴリズムを選択します。彼らは犠牲者によって検出されないままと被害者が誤って安全な通信チャネルを想定した場合にダウングレード攻撃にのみ成功することができます。"
    },
    {
      "indent": 3,
      "text": "In HIP, almost all packet parameters related to cryptographic negotiations are covered by signatures. These parameters cannot be directly manipulated in a downgrade attack without invalidating the signature. However, signed packets can be subject to replay attacks.",
      "ja": "HIPでは、暗号化交渉に関連するほとんどすべてのパケットのパラメータは、シグネチャで覆われています。これらのパラメータは、直接署名を無効にすることなくダウングレード攻撃で操作することができません。しかし、署名パケットはリプレイ攻撃の対象となることができます。"
    },
    {
      "indent": 3,
      "text": "In such a replay attack, the attacker could use an old BEX packet with an outdated and weak selection of cryptographic algorithms and replay it instead of a more recent packet with a collection of stronger cryptographic algorithms. Signed packets that could be subject to this replay attack are the R1 and I2 packet. However, replayed R1 and I2 packets cannot be used to successfully establish a HIP BEX because these packets also contain the public DH values of the Initiator and the Responder. Old DH values from replayed packets lead to invalid keying material and mismatching shared secrets because the attacker is unable to derive valid keying material from the DH public keys in the R1 and cannot generate a valid HMAC and signature for a replayed I2.",
      "ja": "このようリプレイ攻撃では、攻撃者が暗号化アルゴリズムの時代遅れと弱い選択して古いBEXパケットを使用することができますし、より強力な暗号化アルゴリズムのコレクションで、より最近のパケットの代わりにそれを再生します。このリプレイ攻撃を受ける可能性が署名されたパケットがR1とI2パケットです。しかし、R1を再生し、これらのパケットはまた、イニシエータとレスポンダの公開DH値が含まれているためI2パケットが正常にHIPのBEXを確立するために使用することはできません。リプレイパケットから旧DH値は、攻撃者がR1でのDH公開鍵から有効な鍵素材を導出することができず、再生I2のための有効なHMACと署名を生成することができないので、材料をキーイングと共有秘密ミスマッチ無効につながります。"
    },
    {
      "indent": 3,
      "text": "In contrast to the first version of HIP [RFC5201], version 2 of HIP as defined in this document begins the negotiation of the DH groups already in the first BEX packet, the I1. The I1 packet is, by intention, not protected by a signature, to avoid CPU-intensive cryptographic operations processing floods of I1 packets targeted at the Responder. Hence, the list of DH Group IDs in the I1 packet is vulnerable to forgery and manipulation. To thwart an unnoticed manipulation of the I1 packet, the Responder chooses the DH group deterministically and includes its own list of DH Group IDs in the signed part of the R1 packet. The Initiator can detect an attempted downgrade attack by comparing the list of DH Group IDs in the R1 packet to its own preferences in the I1 packet. If the choice of the DH group in the R1 packet does not equal the best match of the two lists (the highest-priority DH ID of the Responder that is present in the Initiator's DH list), the Initiator can conclude that its list in the I1 packet was altered by an attacker. In this case, the Initiator can restart or abort the BEX. As mentioned before, the detection of the downgrade attack is sufficient to prevent it.",
      "ja": "HIPの最初のバージョン[RFC5201]とは対照的に、本文書で定義されているHIPのバージョン2は、第1 BEXパケット、I1に既にDHグループのネゴシエーションを開始します。 I1パケットは、意思によって、レスポンダを対象I1パケットの洪水を処理するCPU集約型の暗号化操作を回避するために、署名によって保護されていません。したがって、I1パケット内のDHグループIDのリストは、偽造や操作に対して脆弱です。 I1パケットの見過ごさ操作を阻止するために、レスポンダは、決定論DHグループを選択し、R1パケットの署名された部分におけるDHグループIDの独自のリストを含みます。イニシエータは、I1パケットに自身の好みにR1パケットでDHグループIDのリストを比較して試みたダウングレード攻撃を検出することができます。 R1パケットでDHグループの選択は二つのリストのベストマッチ（イニシエータのDHのリストに存在するレスポンダの最優先のDH ID）が等しくない場合、イニシエータは、そのリストと結論付けることができますI1パケットが攻撃者によって変更されました。この場合、イニシエータは、BEXを再起動するか、中止することができます。前に述べたように、ダウングレード攻撃の検出は、それを防止するのに十分です。"
    },
    {
      "indent": 0,
      "text": "4.1.8. HIP Opportunistic Mode",
      "section_title": true,
      "ja": "4.1.8.  HIP日和見モード"
    },
    {
      "indent": 3,
      "text": "It is possible to initiate a HIP BEX even if the Responder's HI (and HIT) is unknown. In this case, the initial I1 packet contains all zeros as the destination HIT. This kind of connection setup is called opportunistic mode.",
      "ja": "レスポンダのHI（およびHIT）が不明であっても、HIP BEXを開始することが可能です。この場合、初期I1パケットは、宛先HITとしてオールゼロを含んでいます。接続設定のこの種は、日和見モードと呼ばれています。"
    },
    {
      "indent": 3,
      "text": "The Responder may have multiple HITs due to multiple supported HIT Suites. Since the Responder's HIT Suite in the opportunistic mode is not determined by the destination HIT of the I1 packet, the Responder can freely select a HIT of any HIT Suite. The complete set of HIT Suites supported by the Initiator is not known to the Responder. Therefore, the Responder SHOULD select its HIT from the same HIT Suite as the Initiator's HIT (indicated by the HIT Suite information in the OGA ID field of the Initiator's HIT) because this HIT Suite is obviously supported by the Initiator. If the Responder selects a different HIT that is not supported by the Initiator, the Initiator MAY restart the BEX with an I1 packet with a source HIT that is contained in the list of the Responder's HIT Suites in the R1 packet.",
      "ja": "Responderは、複数のサポートHITスイートによる複数のヒットを有することができます。日和見モードにおけるレスポンダのHITスイートがI1パケットの宛先HITによって決定されていないため、レスポンダは自由に任意HITスイートのHITを選択することができます。イニシエータでサポートされているHITスイーツの完全なセットは、レスポンダには知られていません。このHITスイートが明らかにイニシエータによって支持されているので、したがって、レスポンダは、（イニシエータのHITのOGA IDフィールドにHITスイート情報によって示される）イニシエータのHITと同じHITスイートからのHITを選択すべきです。レスポンダがイニシエータでサポートされていない別のHITを選択した場合、イニシエータは、R1パケット内のレスポンダのHITスイートのリストに含まれているソースHITとI1パケットをBEXを再起動する場合があります。"
    },
    {
      "indent": 3,
      "text": "Note that the Initiator cannot verify the signature of the R1 packet if the Responder's HIT Suite is not supported. Therefore, the Initiator MUST treat R1 packets with unsupported Responder HITs as potentially forged and MUST NOT use any parameters from the unverified R1 besides the HIT_SUITE_LIST. Moreover, an Initiator that uses an unverified HIT_SUITE_LIST from an R1 packet to determine a possible source HIT MUST verify that the HIT_SUITE_LIST in the first unverified R1 packet matches the HIT_SUITE_LIST in the second R1 packet for which the Initiator supports the signature algorithm. The Initiator MUST restart the BEX with a new I1 packet for which the algorithm was mentioned in the verifiable R1 if the two lists do not match. This procedure is necessary to mitigate downgrade attacks.",
      "ja": "レスポンダのHITスイートがサポートされていない場合、イニシエータは、R1パケットの署名を検証することができないことに注意してください。そのため、イニシエータは、潜在的に偽造とHIT_SUITE_LIST以外の未検証R1から任意のパラメータを使用してはならない、サポートされていないレスポンダヒットとR1パケットを扱わなければなりません。また、可能なソースHITを決定するために、R1パケットから未確認HIT_SUITE_LISTを使用するイニシエータは、第一未検証R1パケット内HIT_SUITE_LISTイニシエータ署名アルゴリズムをサポートするための第二のR1パケットにHIT_SUITE_LISTと一致することを確認しなければなりません。イニシエータは、二つのリストが一致しない場合、アルゴリズムは、検証R1で言及されたため、新たなI1パケットをBEXを再起動する必要があります。この手順は、ダウングレード攻撃を軽減する必要があります。"
    },
    {
      "indent": 3,
      "text": "There are both security and API issues involved with the opportunistic mode. These issues are described in the remainder of this section.",
      "ja": "日和見モードに関わるセキュリティとAPIの問題の両方があります。これらの問題は、このセクションの残りの部分に記載されています。"
    },
    {
      "indent": 3,
      "text": "Given that the Responder's HI is not known by the Initiator, there must be suitable API calls that allow the Initiator to request, directly or indirectly, that the underlying system initiates the HIP base exchange solely based on locators. The Responder's HI will be tentatively available in the R1 packet, and in an authenticated form once the R2 packet has been received and verified. Hence, the Responder's HIT could be communicated to the application via new API mechanisms. However, with a backwards-compatible API the application sees only the locators used for the initial contact. Depending on the desired semantics of the API, this can raise the following issues:",
      "ja": "レスポンダのHIは、イニシエータによって知られていないことを考えると、基本的なシステムは、単にロケータに基づいてHIP基本交換を開始することを、直接的または間接的に、イニシエータが要求できるよう、適切なAPI呼び出しがなければなりません。 R2パケットを受信し、検証された後、レスポンダのHIは、R1パケットであり、認証された形で暫定的に利用できるようになります。したがって、レスポンダのHITは、新しいAPI機構を介してアプリケーションに通信することができます。しかし、後方互換APIとアプリケーションが最初に接触するために使用される唯一のロケータを見ています。 APIの所望のセマンティクスに応じて、これは次の問題を提起することができます："
    },
    {
      "indent": 3,
      "text": "o The actual locators may later change if an UPDATE message is used, even if from the API perspective the association still appears to be between two specific locators. However, the locator update is still secure, and the association is still between the same nodes.",
      "ja": "UPDATEメッセージが使用される場合、O実際のロケータは、後にAPIの観点からアソシエーションがまだ2つの特定のロケータとの間であるように見える場合であっても、変化してもよいです。しかしながら、ロケータの更新はまだ安全である、との関連付けは、同じノード間で依然としてあります。"
    },
    {
      "indent": 3,
      "text": "o Different associations between the same two locators may result in connections to different nodes, if the implementation no longer remembers which identifier the peer had in an earlier association. This is possible when the peer's locator has changed for legitimate reasons or when an attacker pretends to be a node that has the peer's locator. Therefore, when using opportunistic mode, HIP implementations MUST NOT place any expectation that the peer's HI returned in the R1 message matches any HI previously seen from that address.",
      "ja": "実装がもはやピアが以前関連していたがidentifierた覚えている場合、O、同じ2つのロケータとの間の異なる関連付けは、異なるノードへの接続を生じないかもしれません。ピアのロケータは、正当な理由のために変更されたとき、または、攻撃者はピアのロケータを有するノードになりすました場合にこれが可能です。日和見モードを使用するときため、HIPの実装は、ピアのHIは、R1メッセージで返されたHIが以前にそのアドレスから見て一致する任意の期待を配置してはならず。"
    },
    {
      "indent": 6,
      "text": "If the HIP implementation and application do not have the same understanding of what constitutes an association, this may even happen within the same association. For instance, an implementation may not know when HIP state can be purged for UDP-based applications.",
      "ja": "HIP実装し、アプリケーションが関連を構成するものの同じ理解を持っていない場合、これは同じであっても協会内で発生することがあります。 HIP状態はUDPベースのアプリケーションのためにパージすることができたときにたとえば、実装は知らないかもしれません。"
    },
    {
      "indent": 3,
      "text": "In addition, the following security considerations apply. The generation counter mechanism will be less efficient in protecting against replays of the R1 packet, given that the Responder can choose a replay that uses an arbitrary HI, not just the one given in the I1 packet.",
      "ja": "また、次のセキュリティの考慮事項が適用されます。生成カウンタ機構は、レスポンダは、任意のHIを使用して再生を選択することができることを考えると、R1パケットのリプレイに対する保護であまり効率的であろうだけでなく、I1パケットに指定されたもの。"
    },
    {
      "indent": 3,
      "text": "More importantly, the opportunistic exchange is vulnerable to man-in-the-middle attacks, because the Initiator does not have any public key information about the peer. To assess the impacts of this vulnerability, we compare it to vulnerabilities in current, non-HIP-capable communications.",
      "ja": "イニシエータがピアについての公開鍵情報を持っていないので、もっと重要なのは、日和見交換は、man-in-the-middle攻撃に対して脆弱です。この脆弱性の影響を評価するために、我々は現在、非HIP可能な通信の脆弱性と比較します。"
    },
    {
      "indent": 3,
      "text": "An attacker on the path between the two peers can insert itself as a man-in-the-middle by providing its own identifier to the Initiator and then initiating another HIP association towards the Responder. For this to be possible, the Initiator must employ opportunistic mode, and the Responder must be configured to accept a connection from any HIP-enabled node.",
      "ja": "2つのピア間の経路上の攻撃者は、イニシエータに独自の識別子を提供し、次いでレスポンダに向かって別のHIPアソシエーションを開始することによってのman-in-the-middleとして自身を挿入することができます。これを可能にするために、イニシエータは、日和見モードを使用しなければならない、とResponderは任意HIP対応ノードからの接続を受け入れるように構成されなければなりません。"
    },
    {
      "indent": 3,
      "text": "An attacker outside the path will be unable to do so, given that it cannot respond to the messages in the base exchange.",
      "ja": "パス外の攻撃者は、それがベース交換でメッセージに応答することができないことを考えると、そうすることができません。"
    },
    {
      "indent": 3,
      "text": "These security properties are characteristic also of communications in the current Internet. A client contacting a server without employing end-to-end security may find itself talking to the server via a man-in-the-middle, assuming again that the server is willing to talk to anyone.",
      "ja": "これらのセキュリティ・プロパティは、現在のインターネットにおける通信の特徴でもあります。エンドツーエンドのセキュリティを用いることなく、サーバーに接続クライアントは、自身がサーバが誰にも話をして喜んでであることを再び仮定し、のman-in-the-middleを介してサーバに話を見つけることがあります。"
    },
    {
      "indent": 3,
      "text": "If end-to-end security is in place, then the worst that can happen in both the opportunistic HIP and non-HIP (normal IP) cases is denial-of-service; an entity on the path can disrupt communications, but will be unable to successfully insert itself as a man-in-the-middle.",
      "ja": "エンドツーエンドのセキュリティが所定の位置にある場合には、日和見HIPと非HIP（通常IP）の両方の場合に起こることができる最悪の事態は、サービス拒否です。パス上のエンティティは、通信を中断させることができますが、成功してman-in-the-middleとしての地位を挿入することができません。"
    },
    {
      "indent": 3,
      "text": "However, once the opportunistic exchange has successfully completed, HIP provides confidentiality and integrity protection for the communications, and can securely change the locators of the endpoints.",
      "ja": "日和見交換が正常に完了した後しかし、HIPは、通信のための機密性と完全性保護を提供し、しっかりとエンドポイントのロケータを変更することができます。"
    },
    {
      "indent": 3,
      "text": "As a result, opportunistic mode in HIP offers a \"better than nothing\" security model. Initially, a base exchange authenticated in the opportunistic mode involves a leap of faith subject to man-in-the-middle attacks, but subsequent datagrams related to the same HIP association cannot be compromised by a new man-in-the-middle attack. Further, if the man-in-the-middle moves away from the path of the active association, the attack would be exposed after the fact. Thus, it can be stated that opportunistic mode in HIP is at least as secure as unprotected IP-based communications.",
      "ja": "その結果、HIPにおける日和見モードは、「より良い何よりも」セキュリティモデルを提供しています。最初は、日和見モードで認証された塩基交換は、man-in-the-middle攻撃への信仰対象の飛躍を含むが、同じHIP協会に関連し、後続のデータグラムは、新たなman-in-the-middle攻撃によって妥協することはできません。 man-in-the-middle離れアクティブ協会のパスから移動した場合また、攻撃は事実の後にさらされることになります。したがって、HIPにおける日和見モードが保護されていないIPベー​​スの通信と少なくとも同程度に安全であると言うことができます。"
    },
    {
      "indent": 0,
      "text": "4.2. Updating a HIP Association",
      "section_title": true,
      "ja": "4.2.  HIP協会の更新"
    },
    {
      "indent": 3,
      "text": "A HIP association between two hosts may need to be updated over time. Examples include the need to rekey expiring security associations, add new security associations, or change IP addresses associated with hosts. The UPDATE packet is used for those and other similar purposes. This document only specifies the UPDATE packet format and basic processing rules, with mandatory parameters. The actual usage is defined in separate specifications.",
      "ja": "2つのホスト間のHIP協会は、時間をかけて更新する必要があります。例としては、セキュリティアソシエーションの期限切れリキー新しいセキュリティアソシエーションを追加、またはホストに関連付けられたIPアドレスを変更する必要があります。 UPDATEパケットは、これらおよび他の同様の目的のために使用されています。この文書では、唯一の必須パラメータで、UPDATEパケットフォーマットと基本的な処理規則を指定します。実際の使用は、別の仕様で定義されています。"
    },
    {
      "indent": 3,
      "text": "HIP provides a general-purpose UPDATE packet, which can carry multiple HIP parameters, for updating the HIP state between two peers. The UPDATE mechanism has the following properties:",
      "ja": "HIPは、2つのピア間HIP状態を更新するため、複数のHIPパラメータを運ぶことができる汎用UPDATEパケットを、提供します。 UPDATEメカニズムは、次のプロパティがあります。"
    },
    {
      "indent": 6,
      "text": "UPDATE messages carry a monotonically increasing sequence number and are explicitly acknowledged by the peer. Lost UPDATEs or acknowledgments may be recovered via retransmission. Multiple UPDATE messages may be outstanding under certain circumstances.",
      "ja": "UPDATEメッセージが単調に増加するシーケンス番号を運ぶと、明示的にピアによって確認されています。失われた更新や確認応答が再送信を介して回収することができます。複数のUPDATEメッセージは、特定の状況下で優れたかもしれません。"
    },
    {
      "indent": 6,
      "text": "UPDATE is protected by both HIP_MAC and HIP_SIGNATURE parameters, since processing UPDATE signatures alone is a potential DoS attack against intermediate systems.",
      "ja": "単独でUPDATEシグネチャを処理する中間システムに対する潜在的なDoS攻撃であるため、更新は、HIP_MACとHIP_SIGNATUREパラメータの両方によって保護されています。"
    },
    {
      "indent": 6,
      "text": "UPDATE packets are explicitly acknowledged by the use of an acknowledgment parameter that echoes an individual sequence number received from the peer. A single UPDATE packet may contain both a sequence number and one or more acknowledgment numbers (i.e., piggybacked acknowledgment(s) for the peer's UPDATE).",
      "ja": "アップデートパケットを明示的ピアから受信した個々のシーケンス番号を確認応答エコーパラメータの使用によって認められています。単一UPDATEパケットがシーケンス番号および1つまたは複数の確認応答番号の両方を含んでいてもよい（即ち、ピアのUPDATEに対する肯定応答（複数可）をピギーバック）。"
    },
    {
      "indent": 3,
      "text": "The UPDATE packet is defined in Section 5.3.5.",
      "ja": "UPDATEパケットは、セクション5.3.5で定義されています。"
    },
    {
      "indent": 0,
      "text": "4.3. Error Processing",
      "section_title": true,
      "ja": "4.3. エラー処理"
    },
    {
      "indent": 3,
      "text": "HIP error processing behavior depends on whether or not there exists an active HIP association. In general, if a HIP association exists between the sender and receiver of a packet causing an error condition, the receiver SHOULD respond with a NOTIFY packet. On the other hand, if there are no existing HIP associations between the sender and receiver, or the receiver cannot reasonably determine the identity of the sender, the receiver MAY respond with a suitable ICMP message; see Section 5.4 for more details.",
      "ja": "HIPエラー処理動作は、アクティブHIPアソシエーションが存在するか否かに依存します。 HIPアソシエーションがエラー条件を引き起こしたパケットの送信者と受信者との間に存在する場合、一般的に、受信機は、NOTIFYパケットで応答する必要があります。一方、送信者と受信者、または合理的に送信者の同一性を決定することができない受信機との間の既存のHIPアソシエーションが存在しない場合、適切なICMPメッセージで応答することができる受信機。詳細は、5.4節を参照してください。"
    },
    {
      "indent": 3,
      "text": "The HIP protocol and state machine are designed to recover from one of the parties crashing and losing its state. The following scenarios describe the main use cases covered by the design.",
      "ja": "HIPプロトコル状態マシンがクラッシュし、その状態を失う当事者の一方から回復するために設計されています。次のシナリオは、設計でカバー主な使用例を説明します。"
    },
    {
      "indent": 6,
      "text": "No prior state between the two systems.",
      "ja": "2つのシステム間の事前の状態はありません。"
    },
    {
      "indent": 9,
      "text": "The system with data to send is the Initiator. The process follows the standard four-packet base exchange, establishing the HIP association.",
      "ja": "送信するデータを持つシステムがイニシエータです。プロセスは、HIPアソシエーションを確立し、標準的な4パケットベースの交換に従います。"
    },
    {
      "indent": 6,
      "text": "The system with data to send has no state with the receiver, but the receiver has a residual HIP association.",
      "ja": "送信するデータを有するシステムは、受信機とは状態を有していないが、受信機は、残留HIPの関連性を有しています。"
    },
    {
      "indent": 9,
      "text": "The system with data to send is the Initiator. The Initiator acts as in no prior state, sending an I1 packet and receiving an R1 packet. When the Responder receives a valid I2 packet, the old association is 'discovered' and deleted, and the new association is established.",
      "ja": "送信するデータを持つシステムがイニシエータです。イニシエータは、I1パケットを送信し、R1パケットを受信し、事前の状態のように作用します。 Responderが有効I2パケットを受信すると、古い協会を「発見」し、削除され、新しいアソシエーションが確立されています。"
    },
    {
      "indent": 6,
      "text": "The system with data to send has a HIP association, but the receiver does not.",
      "ja": "送信するデータを有するシステムは、HIPの関連性を有しているが、受信機がありません。"
    },
    {
      "indent": 9,
      "text": "The system sends data on the outbound user data security association. The receiver 'detects' the situation when it receives a user data packet that it cannot match to any HIP association. The receiving host MUST discard this packet.",
      "ja": "システムは、アウトバウンド、ユーザデータのセキュリティアソシエーション上でデータを送信します。受信機は、それがどんなHIP協会に一致させることができないユーザデータパケットを受信状況「を検出します」。受信ホストはこのパケットを捨てなければなりません。"
    },
    {
      "indent": 9,
      "text": "The receiving host SHOULD send an ICMP packet, with the type Parameter Problem, to inform the sender that the HIP association does not exist (see Section 5.4), and it MAY initiate a new HIP BEX. However, responding with these optional mechanisms is implementation or policy dependent. If the sending application doesn't expect a response, the system could possibly send a large number of packets in this state, so for this reason, the sending of one or more ICMP packets is RECOMMENDED. However, any such responses MUST be rate-limited to prevent abuse (see Section 5.4).",
      "ja": "受信ホストは、（5.4節を参照）HIPアソシエーションが存在しないことを送信者に通知するために、タイプパラメータ問題で、ICMPパケットを送信する必要があり、それが新しいHIP BEXを開始することができます。しかし、これらのオプションのメカニズムで応答することは、実装またはポリシーに依存しています。送信側アプリケーションが応答を期待していない場合、システムは、おそらくこの状態で大量のパケットを送信することができ、したがってこのような理由のために、推奨される1つの以上のICMPパケットの送信します。しかし、どのような応答は、（5.4節を参照）乱用を防ぐためにレート制限しなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.4. HIP State Machine",
      "section_title": true,
      "ja": "4.4.  HIPステートマシン"
    },
    {
      "indent": 3,
      "text": "HIP itself has little state. In the HIP base exchange, there is an Initiator and a Responder. Once the security associations (SAs) are established, this distinction is lost. If the HIP state needs to be re-established, the controlling parameters are which peer still has state and which has a datagram to send to its peer. The following state machine attempts to capture these processes.",
      "ja": "HIP自体がほとんどない状態があります。 HIP基本交換では、イニシエータとレスポンダがあります。セキュリティアソシエーション（SA）が確立されると、この区別は失われます。 HIPの状態を再確立する必要がある場合は、制御パラメータは、まだピアの状態を持っており、どのピアに送信するデータグラムを持っているです。以下のステートマシンは、これらのプロセスを捕獲しようとします。"
    },
    {
      "indent": 3,
      "text": "The state machine is symmetric and is presented in a single system view, representing either an Initiator or a Responder. The state machine is not a full representation of the processing logic. Additional processing rules are presented in the packet definitions. Hence, both are needed to completely implement HIP.",
      "ja": "ステートマシンは、対称的であり、イニシエータまたはレスポンダのいずれかを表し、単一のシステムビューで提示されます。ステートマシンは、処理ロジックの完全な表現ではありません。追加の処理ルールは、パケットの定義に提示されています。したがって、両方が完全にHIPを実装するために必要な。"
    },
    {
      "indent": 3,
      "text": "This document extends the state machine as defined in [RFC5201] and introduces a restart option to allow for the negotiation of cryptographic algorithms. The extension to the previous state machine in [RFC5201] is a transition from state I1-SENT back again to I1-SENT; namely, the restart option. An Initiator is required to restart the HIP base exchange if the Responder does not support the HIT Suite of the Initiator. In this case, the Initiator restarts the HIP base exchange by sending a new I1 packet with a source HIT supported by the Responder.",
      "ja": "この文書では、[RFC5201]で定義されたステートマシンを拡張し、暗号アルゴリズムの折衝を可能にする再起動オプションを紹介します。 [RFC5201]の前の状態マシンへの拡張は、状態I1-SENT I1-SENTに再びからの遷移です。つまり、再起動オプション。イニシエータは、レスポンダはイニシエータのHIT Suiteをサポートしていない場合HIP基本交換を再起動する必要があります。この場合、イニシエータはレスポンダによってサポートされるソースHITを有する新しいI1パケットを送信することによって、HIP基本交換を再開する。"
    },
    {
      "indent": 3,
      "text": "Implementors must understand that the state machine, as described here, is informational. Specific implementations are free to implement the actual processing logic differently. Section 6 describes the packet processing rules in more detail. This state machine focuses on the HIP I1, R1, I2, and R2 packets only. New states and state transitions may be introduced by mechanisms in other specifications (such as mobility and multihoming).",
      "ja": "実装者は、ステートマシンは、ここで説明するように、情報提供であることを理解しなければなりません。具体的な実装は異なり、実際の処理ロジックを実装するのは自由です。第6節では、より詳細にパケット処理のルールを説明します。このステートマシンは唯一のHIP I1、R1、I2、およびR2パケットに焦点を当てています。新しい状態および状態遷移は、（例えば、移動度及びマルチホーミングのような）他の仕様のメカニズムによって導入することができます。"
    },
    {
      "indent": 0,
      "text": "4.4.1. State Machine Terminology",
      "section_title": true,
      "ja": "4.4.1. ステートマシン用語"
    },
    {
      "indent": 3,
      "text": "Unused Association Lifetime (UAL): Implementation-specific time for which, if no packet is sent or received for this time interval, a host MAY begin to tear down an active HIP association.",
      "ja": "未結合のライフタイム（UAL）：全くパケットがこの時間間隔のために送信されないまたは受信された場合の実装固有時、ホストがアクティブHIPアソシエーションを切断し始めることができます。"
    },
    {
      "indent": 3,
      "text": "Maximum Segment Lifetime (MSL): Maximum time that a HIP packet is expected to spend in the network. A default value of 2 minutes has been borrowed from [RFC0793] because it is a prevailing assumption for packet lifetimes.",
      "ja": "最大セグメント寿命（MSL）：HIPパケットがネットワークに過ごすことが予想されていることを最大時間。それは、パケットの寿命のための有力な前提であるため、2分のデフォルト値は[RFC0793]から借りてきました。"
    },
    {
      "indent": 3,
      "text": "Exchange Complete (EC): Time that the host spends at the R2-SENT state before it moves to the ESTABLISHED state. The time is n * I2 retransmission timeout, where n is about I2_RETRIES_MAX.",
      "ja": "取引完了（EC）：それはESTABLISHED状態に移行する前に、ホストがR2-SENT状態で過ごす時間。時間は、nはI2_RETRIES_MAXについてです* I2の再送タイムアウト、です。"
    },
    {
      "indent": 3,
      "text": "Receive ANYOTHER: Any received packet for which no state transitions or processing rules are defined for a given state.",
      "ja": "任意の他の受信：なし状態遷移または処理ルールが所与の状態のために定義されていないれる任意の受信したパケットを。"
    },
    {
      "indent": 0,
      "text": "4.4.2. HIP States",
      "section_title": true,
      "ja": "4.4.2.  HIP州"
    },
    {
      "indent": 3,
      "text": "+---------------------+---------------------------------------------+\n| State               | Explanation                                 |\n+---------------------+---------------------------------------------+\n| UNASSOCIATED        | State machine start                         |\n|                     |                                             |\n| I1-SENT             | Initiating base exchange                    |\n|                     |                                             |\n| I2-SENT             | Waiting to complete base exchange           |\n|                     |                                             |\n| R2-SENT             | Waiting to complete base exchange           |\n|                     |                                             |\n| ESTABLISHED         | HIP association established                 |\n|                     |                                             |\n| CLOSING             | HIP association closing, no data can be     |\n|                     | sent                                        |\n|                     |                                             |\n| CLOSED              | HIP association closed, no data can be sent |\n|                     |                                             |\n| E-FAILED            | HIP base exchange failed                    |\n+---------------------+---------------------------------------------+",
      "raw": true
    },
    {
      "indent": 28,
      "text": "Table 1: HIP States",
      "ja": "表1：HIP州"
    },
    {
      "indent": 0,
      "text": "4.4.3. HIP State Processes",
      "section_title": true,
      "ja": "4.4.3.  HIP状態のプロセス"
    },
    {
      "indent": 3,
      "text": "System behavior in state UNASSOCIATED, Table 2.",
      "ja": "状態関連付けられていない、表2のシステムの挙動。"
    },
    {
      "indent": 3,
      "text": "+----------------------------+--------------------------------------+\n| Trigger                    | Action                               |\n+----------------------------+--------------------------------------+\n| User data to send,         | Send I1 and go to I1-SENT            |\n| requiring a new HIP        |                                      |\n| association                |                                      |\n|                            |                                      |\n| Receive I1                 | Send R1 and stay at UNASSOCIATED     |\n|                            |                                      |\n| Receive I2, process        | If successful, send R2 and go to     |\n|                            | R2-SENT                              |\n|                            |                                      |\n|                            | If fail, stay at UNASSOCIATED        |\n|                            |                                      |\n| Receive user data for an   | Optionally send ICMP as defined in   |\n| unknown HIP association    | Section 5.4 and stay at UNASSOCIATED |\n|                            |                                      |\n| Receive CLOSE              | Optionally send ICMP Parameter       |\n|                            | Problem and stay at UNASSOCIATED     |\n|                            |                                      |\n| Receive ANYOTHER           | Drop and stay at UNASSOCIATED        |\n+----------------------------+--------------------------------------+",
      "raw": true
    },
    {
      "indent": 20,
      "text": "Table 2: UNASSOCIATED - Start State",
      "ja": "表2：関連付けられていない - スタート状態"
    },
    {
      "indent": 3,
      "text": "System behavior in state I1-SENT, Table 3.",
      "ja": "状態I1-SENT、表3のシステムの動作。"
    },
    {
      "indent": 3,
      "text": "+---------------------+---------------------------------------------+\n| Trigger             | Action                                      |\n+---------------------+---------------------------------------------+\n| Receive I1 from     | If the local HIT is smaller than the peer   |\n| Responder           | HIT, drop I1 and stay at I1-SENT (see       |\n|                     | Section 6.5 for HIT comparison)             |\n|                     |                                             |\n|                     | If the local HIT is greater than the peer   |\n|                     | HIT, send R1 and stay at I1-SENT            |\n|                     |                                             |\n| Receive I2, process | If successful, send R2 and go to R2-SENT    |\n|                     |                                             |\n|                     | If fail, stay at I1-SENT                    |\n|                     |                                             |\n| Receive R1, process | If the HIT Suite of the local HIT is not    |\n|                     | supported by the peer, select supported     |\n|                     | local HIT, send I1, and stay at I1-SENT     |\n|                     |                                             |\n|                     | If successful, send I2 and go to I2-SENT    |\n|                     |                                             |\n|                     | If fail, stay at I1-SENT                    |\n|                     |                                             |\n| Receive ANYOTHER    | Drop and stay at I1-SENT                    |\n|                     |                                             |\n| Timeout             | Increment trial counter                     |\n|                     |                                             |\n|                     | If counter is less than I1_RETRIES_MAX,     |\n|                     | send I1 and stay at I1-SENT                 |\n|                     |                                             |\n|                     | If counter is greater than I1_RETRIES_MAX,  |\n|                     | go to E-FAILED                              |\n+---------------------+---------------------------------------------+",
      "raw": true
    },
    {
      "indent": 12,
      "text": "Table 3: I1-SENT - Initiating the HIP Base Exchange",
      "ja": "表3：I1-SENT  -  HIP基本交換を開始"
    },
    {
      "indent": 3,
      "text": "System behavior in state I2-SENT, Table 4.",
      "ja": "状態I2-SENT、表4のシステムの挙動。"
    },
    {
      "indent": 3,
      "text": "+---------------------+---------------------------------------------+\n| Trigger             | Action                                      |\n+---------------------+---------------------------------------------+\n| Receive I1          | Send R1 and stay at I2-SENT                 |\n|                     |                                             |\n| Receive R1, process | If successful, send I2 and stay at I2-SENT  |\n|                     |                                             |\n|                     | If fail, stay at I2-SENT                    |\n|                     |                                             |\n| Receive I2, process | If successful and local HIT is smaller than |\n|                     | the peer HIT, drop I2 and stay at I2-SENT   |\n|                     |                                             |\n|                     | If successful and local HIT is greater than |\n|                     | the peer HIT, send R2 and go to R2-SENT     |\n|                     |                                             |\n|                     | If fail, stay at I2-SENT                    |\n|                     |                                             |\n| Receive R2, process | If successful, go to ESTABLISHED            |\n|                     |                                             |\n|                     | If fail, stay at I2-SENT                    |\n|                     |                                             |\n| Receive CLOSE,      | If successful, send CLOSE_ACK and go to     |\n| process             | CLOSED                                      |\n|                     |                                             |\n|                     | If fail, stay at I2-SENT                    |\n|                     |                                             |\n| Receive ANYOTHER    | Drop and stay at I2-SENT                    |\n|                     |                                             |\n| Timeout             | Increment trial counter                     |\n|                     |                                             |\n|                     | If counter is less than I2_RETRIES_MAX,     |\n|                     | send I2 and stay at I2-SENT                 |\n|                     |                                             |\n|                     | If counter is greater than I2_RETRIES_MAX,  |\n|                     | go to E-FAILED                              |\n+---------------------+---------------------------------------------+",
      "raw": true
    },
    {
      "indent": 8,
      "text": "Table 4: I2-SENT - Waiting to Finish the HIP Base Exchange",
      "ja": "表4：I2-SENT  -  HIP基本交換を完了するために待っています"
    },
    {
      "indent": 3,
      "text": "System behavior in state R2-SENT, Table 5.",
      "ja": "状態R2-SENT、表5のシステムの挙動。"
    },
    {
      "indent": 3,
      "text": "+------------------------+------------------------------------------+\n| Trigger                | Action                                   |\n+------------------------+------------------------------------------+\n| Receive I1             | Send R1 and stay at R2-SENT              |\n|                        |                                          |\n| Receive I2, process    | If successful, send R2 and stay at       |\n|                        | R2-SENT                                  |\n|                        |                                          |\n|                        | If fail, stay at R2-SENT                 |\n|                        |                                          |\n| Receive R1             | Drop and stay at R2-SENT                 |\n|                        |                                          |\n| Receive R2             | Drop and stay at R2-SENT                 |\n|                        |                                          |\n| Receive data or UPDATE | Move to ESTABLISHED                      |\n|                        |                                          |\n| Exchange Complete      | Move to ESTABLISHED                      |\n| Timeout                |                                          |\n|                        |                                          |\n| Receive CLOSE, process | If successful, send CLOSE_ACK and go to  |\n|                        | CLOSED                                   |\n|                        |                                          |\n|                        | If fail, stay at ESTABLISHED             |\n|                        |                                          |\n| Receive CLOSE_ACK      | Drop and stay at R2-SENT                 |\n|                        |                                          |\n| Receive NOTIFY         | Process and stay at R2-SENT              |\n+------------------------+------------------------------------------+",
      "raw": true
    },
    {
      "indent": 17,
      "text": "Table 5: R2-SENT - Waiting to Finish HIP",
      "ja": "表5：R2-SENT  -  HIPを終了するために待っています"
    },
    {
      "indent": 3,
      "text": "System behavior in state ESTABLISHED, Table 6.",
      "ja": "状態でのシステムの動作は、表6を設立しました。"
    },
    {
      "indent": 3,
      "text": "+---------------------+---------------------------------------------+\n| Trigger             | Action                                      |\n+---------------------+---------------------------------------------+\n| Receive I1          | Send R1 and stay at ESTABLISHED             |\n|                     |                                             |\n| Receive I2          | Process with puzzle and possible Opaque     |\n|                     | data verification                           |\n|                     |                                             |\n|                     | If successful, send R2, drop old HIP        |\n|                     | association, establish a new HIP            |\n|                     | association, and go to R2-SENT              |\n|                     |                                             |\n|                     | If fail, stay at ESTABLISHED                |\n|                     |                                             |\n| Receive R1          | Drop and stay at ESTABLISHED                |\n|                     |                                             |\n| Receive R2          | Drop and stay at ESTABLISHED                |\n|                     |                                             |\n| Receive user data   | Process and stay at ESTABLISHED             |\n| for HIP association |                                             |\n|                     |                                             |\n| No packet           | Send CLOSE and go to CLOSING                |\n| sent/received       |                                             |\n| during UAL minutes  |                                             |\n|                     |                                             |\n| Receive UPDATE      | Process and stay at ESTABLISHED             |\n|                     |                                             |\n| Receive CLOSE,      | If successful, send CLOSE_ACK and go to     |\n| process             | CLOSED                                      |\n|                     |                                             |\n|                     | If fail, stay at ESTABLISHED                |\n|                     |                                             |\n| Receive CLOSE_ACK   | Drop and stay at ESTABLISHED                |\n|                     |                                             |\n| Receive NOTIFY      | Process and stay at ESTABLISHED             |\n+---------------------+---------------------------------------------+",
      "raw": true
    },
    {
      "indent": 12,
      "text": "Table 6: ESTABLISHED - HIP Association Established",
      "ja": "表6：ESTABLISHED  -  HIP協会を設立します"
    },
    {
      "indent": 3,
      "text": "System behavior in state CLOSING, Table 7.",
      "ja": "状態CLOSING、表7のシステムの挙動。"
    },
    {
      "indent": 3,
      "text": "+----------------------------+--------------------------------------+\n| Trigger                    | Action                               |\n+----------------------------+--------------------------------------+\n| User data to send,         | Send I1 and go to I1-SENT            |\n| requires the creation of   |                                      |\n| another incarnation of the |                                      |\n| HIP association            |                                      |\n|                            |                                      |\n| Receive I1                 | Send R1 and stay at CLOSING          |\n|                            |                                      |\n| Receive I2, process        | If successful, send R2 and go to     |\n|                            | R2-SENT                              |\n|                            |                                      |\n|                            | If fail, stay at CLOSING             |\n|                            |                                      |\n| Receive R1, process        | If successful, send I2 and go to     |\n|                            | I2-SENT                              |\n|                            |                                      |\n|                            | If fail, stay at CLOSING             |\n|                            |                                      |\n| Receive CLOSE, process     | If successful, send CLOSE_ACK,       |\n|                            | discard state, and go to CLOSED      |\n|                            |                                      |\n|                            | If fail, stay at CLOSING             |\n|                            |                                      |\n| Receive CLOSE_ACK, process | If successful, discard state and go  |\n|                            | to UNASSOCIATED                      |\n|                            |                                      |\n|                            | If fail, stay at CLOSING             |\n|                            |                                      |\n| Receive ANYOTHER           | Drop and stay at CLOSING             |\n|                            |                                      |\n| Timeout                    | Increment timeout sum and reset      |\n|                            | timer.  If timeout sum is less than  |\n|                            | UAL+MSL minutes, retransmit CLOSE    |\n|                            | and stay at CLOSING.                 |\n|                            |                                      |\n|                            | If timeout sum is greater than       |\n|                            | UAL+MSL minutes, go to UNASSOCIATED  |\n+----------------------------+--------------------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Table 7: CLOSING - HIP Association Has Not Been Used for UAL Minutes",
      "ja": "表7：CLOSING  -  HIP協会は、UAL分間使用されませんでした"
    },
    {
      "indent": 3,
      "text": "System behavior in state CLOSED, Table 8.",
      "ja": "状態でのシステムの動作は、表8を閉じました。"
    },
    {
      "indent": 3,
      "text": "+----------------------------------------+--------------------------+\n| Trigger                                | Action                   |\n+----------------------------------------+--------------------------+\n| Datagram to send, requires the         | Send I1 and stay at      |\n| creation of another incarnation of the | CLOSED                   |\n| HIP association                        |                          |\n|                                        |                          |\n| Receive I1                             | Send R1 and stay at      |\n|                                        | CLOSED                   |\n|                                        |                          |\n| Receive I2, process                    | If successful, send R2   |\n|                                        | and go to R2-SENT        |\n|                                        |                          |\n|                                        | If fail, stay at CLOSED  |\n|                                        |                          |\n| Receive R1, process                    | If successful, send I2   |\n|                                        | and go to I2-SENT        |\n|                                        |                          |\n|                                        | If fail, stay at CLOSED  |\n|                                        |                          |\n| Receive CLOSE, process                 | If successful, send      |\n|                                        | CLOSE_ACK and stay at    |\n|                                        | CLOSED                   |\n|                                        |                          |\n|                                        | If fail, stay at CLOSED  |\n|                                        |                          |\n| Receive CLOSE_ACK, process             | If successful, discard   |\n|                                        | state and go to          |\n|                                        | UNASSOCIATED             |\n|                                        |                          |\n|                                        | If fail, stay at CLOSED  |\n|                                        |                          |\n| Receive ANYOTHER                       | Drop and stay at CLOSED  |\n|                                        |                          |\n| Timeout (UAL+2MSL)                     | Discard state and go to  |\n|                                        | UNASSOCIATED             |\n+----------------------------------------+--------------------------+",
      "raw": true
    },
    {
      "indent": 4,
      "text": "Table 8: CLOSED - CLOSE_ACK Sent, Resending CLOSE_ACK if Necessary",
      "ja": "表8：CLOSED  - 送信CLOSE_ACK、の再送CLOSE_ACK必要に応じて、"
    },
    {
      "indent": 3,
      "text": "System behavior in state E-FAILED, Table 9.",
      "ja": "状態でのシステムの動作は、表9のE-FAILED。"
    },
    {
      "indent": 3,
      "text": "+-------------------------+-----------------------------------------+\n| Trigger                 | Action                                  |\n+-------------------------+-----------------------------------------+\n| Wait for                | Go to UNASSOCIATED.  Renegotiation is   |\n| implementation-specific | possible after moving to UNASSOCIATED   |\n| time                    | state.                                  |\n+-------------------------+-----------------------------------------+",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Table 9: E-FAILED - HIP Failed to Establish Association with Peer",
      "ja": "表9：E-FAILED  -  HIPは、ピアとのアソシエーションを確立するために失敗しました。"
    },
    {
      "indent": 0,
      "text": "4.4.4. Simplified HIP State Diagram",
      "section_title": true,
      "ja": "4.4.4. 簡素化されたHIP状態図"
    },
    {
      "indent": 3,
      "text": "The following diagram (Figure 2) shows the major state transitions. Transitions based on received packets implicitly assume that the packets are successfully authenticated or processed.",
      "ja": "次の図（図2）は、主要な状態遷移を示しています。受信したパケットに基づいて、トランジションは、暗黙のうちにパケットが正常に認証または処理されていることを前提としています。"
    },
    {
      "indent": 3,
      "text": "                            +--+       +----------------------------+\n           recv I1, send R1 |  |       |                            |\n                            |  v       v                            |\n                          +--------------+  recv I2, send R2        |\n         +----------------| UNASSOCIATED |----------------+         |\ndatagram |  +--+          +--------------+                |         |\nto send, |  |  | Alg. not supported,                      |         |\n send I1 |  |  | send I1                                  |         |\n  .      v  |  v                                          |         |\n  .   +---------+  recv I2, send R2                       |         |\n+---->| I1-SENT |--------------------------------------+  |         |\n|     +---------+            +----------------------+  |  |         |\n|          | recv R2,        | recv I2, send R2     |  |  |         |\n|          v send I2         |                      v  v  v         |\n|       +---------+          |                    +---------+       |\n|  +--->| I2-SENT |----------+     +--------------| R2-SENT |<---+  |\n|  |    +---------+                |              +---------+    |  |\n|  |          |  |recv R2          |        data or|             |  |\n|  |recv R1,  |  |                 |     EC timeout|             |  |\n|  |send I2   +--|-----------------+               |  receive I2,|  |\n|  |          |  |       +-------------+           |      send R2|  |\n|  |          |  +------>| ESTABLISHED |<----------+             |  |\n|  |          |          +-------------+                         |  |\n|  |          |            |  |  |      receive I2, send R2      |  |\n|  |          +------------+  |  +-------------------------------+  |\n|  |          |               +-----------+                      |  |\n|  |          |    no packet sent/received|    +---+             |  |\n|  |          |    for UAL min, send CLOSE|    |   |timeout      |  |\n|  |          |                           v    v   |(UAL+MSL)    |  |\n|  |          |                        +---------+ |retransmit   |  |\n+--|----------|------------------------| CLOSING |-+CLOSE        |  |\n   |          |                        +---------+               |  |\n   |          |                         | |   | |                |  |\n   +----------|-------------------------+ |   | +----------------+  |\n   |          |               +-----------+   +------------------|--+\n   |          |               |recv CLOSE,      recv CLOSE_ACK   |  |\n   |          +-------------+ |send CLOSE_ACK   or timeout       |  |\n   |     recv CLOSE,        | |                 (UAL+MSL)        |  |\n   |     send CLOSE_ACK     v v                                  |  |\n   |                     +--------+  receive I2, send R2         |  |\n   +---------------------| CLOSED |------------------------------+  |\n                         +--------+                                 |\n                          ^ |  |                                    |\nrecv CLOSE, send CLOSE_ACK| |  |              timeout (UAL+2MSL)    |\n                          +-+  +------------------------------------+",
      "raw": true
    },
    {
      "indent": 33,
      "text": "Figure 2",
      "ja": "図2"
    },
    {
      "indent": 0,
      "text": "4.5. User Data Considerations",
      "section_title": true,
      "ja": "4.5. ユーザーデータの考慮事項"
    },
    {
      "indent": 0,
      "text": "4.5.1. TCP and UDP Pseudo Header Computation for User Data",
      "section_title": true,
      "ja": "4.5.1. ユーザーデータのためのTCPおよびUDP擬似ヘッダの計算"
    },
    {
      "indent": 3,
      "text": "When computing TCP and UDP checksums on user data packets that flow through sockets bound to HITs, the IPv6 pseudo header format [RFC2460] MUST be used, even if the actual addresses in the header of the packet are IPv4 addresses. Additionally, the HITs MUST be used in place of the IPv6 addresses in the IPv6 pseudo header. Note that the pseudo header for actual HIP payloads is computed differently; see Section 5.1.1.",
      "ja": "ヒットに結合したソケットを流れるユーザデータパケットにTCPおよびUDPチェックサムを計算するとき、IPv6の疑似ヘッダフォーマット[RFC2460]は、パケットのヘッダ内の実際のアドレスは、IPv4アドレスであっても、使用しなければなりません。また、HITSは、IPv6疑似ヘッダーのIPv6アドレスの代わりに使用されなければなりません。実際のHIPペイロードのための疑似ヘッダが異なって計算されることに留意されたいです。 5.1.1項を参照してください。"
    },
    {
      "indent": 0,
      "text": "4.5.2. Sending Data on HIP Packets",
      "section_title": true,
      "ja": "4.5.2.  HIPのパケットへのデータの送信"
    },
    {
      "indent": 3,
      "text": "Other documents may define how to include user data in various HIP packets. However, currently the HIP header is a terminal header, and not followed by any other headers.",
      "ja": "他の文書は、様々なHIPパケット内のユーザデータを含める方法を定義することができます。しかし、現在HIPヘッダが端子ヘッダであり、そして任意の他のヘッダが続きません。"
    },
    {
      "indent": 0,
      "text": "4.5.3. Transport Formats",
      "section_title": true,
      "ja": "4.5.3. トランスポートフォーマット"
    },
    {
      "indent": 3,
      "text": "The actual data transmission format, used for user data after the HIP base exchange, is not defined in this document. Such transport formats and methods are described in separate specifications. All HIP implementations MUST implement, at minimum, the ESP transport format for HIP [RFC7402]. The transport format to be chosen is negotiated in the base exchange. The Responder expresses its preference regarding the transport format in the TRANSPORT_FORMAT_LIST in the R1 packet, and the Initiator selects one transport format and adds the respective HIP parameter to the I2 packet.",
      "ja": "HIP基本交換後のユーザデータのために使用される実際のデータ伝送フォーマットは、本文書で定義されていません。そのようなトランスポートフォーマット及び方法は別仕様書に記載されています。すべてのHIP実装は、最低でも、HIP [RFC7402]のためにESPのトランスポートフォーマットを実装しなければなりません。選択されるトランスポートフォーマットは、塩基交換で交渉されます。レスポンダは、R1パケット内TRANSPORT_FORMAT_LISTにおけるトランスポートフォーマットに関するその嗜好を表し、イニシエータは、一つのトランスポートフォーマットを選択し、I2パケットにそれぞれHIPパラメータを追加します。"
    },
    {
      "indent": 0,
      "text": "4.5.4. Reboot, Timeout, and Restart of HIP",
      "section_title": true,
      "ja": "4.5.4. 再起動し、タイムアウト、およびHIPの再起動"
    },
    {
      "indent": 3,
      "text": "Simulating a loss of state is a potential DoS attack. The following process has been crafted to manage state recovery without presenting a DoS opportunity.",
      "ja": "状態の損失をシミュレートする潜在的なDoS攻撃です。次のプロセスは、DoS攻撃の機会を提示することなく、状態の回復を管理するために細工されています。"
    },
    {
      "indent": 3,
      "text": "If a host reboots or the HIP association times out, it has lost its HIP state. If the host that lost state has a datagram to send to the peer, it simply restarts the HIP base exchange. After the base exchange has completed, the Initiator can create a new payload association and start sending data. The peer does not reset its state until it receives a valid I2 packet.",
      "ja": "ホストの再起動やHIP協会がタイムアウトした場合、それはそのHIP状態を失いました。状態を失ったホストがピアに送信するデータグラムを持っている場合、それは単にHIP基本交換を再起動します。塩基交換が完了した後は、イニシエータは新しいペイロードの関連付けを作成し、データの送信を開始することができます。それが有効なI2パケットを受信するまで、ピアはその状態をリセットしません。"
    },
    {
      "indent": 3,
      "text": "If a system receives a user data packet that cannot be matched to any existing HIP association, it is possible that it has lost the state and its peer has not. It MAY send an ICMP packet with the Parameter Problem type, and with the Pointer pointing to the referred",
      "ja": "システムは、既存のHIPアソシエーションに一致させることができないユーザ・データ・パケットを受信した場合、状態を失っており、そのピアがいない可能性があります。これは、パラメータ問題タイプのICMPパケットを送信し、ポインタが指して呼ばれてもよい（MAY）"
    },
    {
      "indent": 3,
      "text": "HIP-related association information. Reacting to such traffic depends on the implementation and the environment where the implementation is used.",
      "ja": "HIP-関連の関連情報。そのようなトラフィックに反応させて実装し、実装が使用される環境に依存します。"
    },
    {
      "indent": 3,
      "text": "If the host that apparently has lost its state decides to restart the HIP base exchange, it sends an I1 packet to the peer. After the base exchange has been completed successfully, the Initiator can create a new HIP association, and the peer drops its old payload associations and creates a new one.",
      "ja": "どうやらその状態を失ったホストはHIP基本交換を再起動することを決定した場合、それはピアにI1パケットを送信します。塩基交換が正常に完了した後は、イニシエータは新しいHIPの関連付けを作成することができ、およびピアはその古いペイロードの関連付けをドロップし、新しいものを作成します。"
    },
    {
      "indent": 0,
      "text": "4.6. Certificate Distribution",
      "section_title": true,
      "ja": "4.6. 証明書配布"
    },
    {
      "indent": 3,
      "text": "This document does not define how to use certificates or how to transfer them between hosts. These functions are expected to be defined in a future specification, as was done for HIP version 1 (see [RFC6253]). A parameter type value, meant to be used for carrying certificates, is reserved, though: CERT, Type 768; see Section 5.2.",
      "ja": "このドキュメントでは、証明書を使用する方法やホスト間でそれらを転送する方法を定義していません。 HIPバージョン1に対して行ったように、これらの機能は、将来の仕様で定義されることが期待される（[RFC6253]を参照）。証明書を運ぶために使用されることを意図パラメータタイプ値が、予約されているけれども：CERT、タイプ768。 5.2節を参照してください。"
    },
    {
      "indent": 0,
      "text": "5. Packet Formats",
      "section_title": true,
      "ja": "5.パケットフォーマット"
    },
    {
      "indent": 0,
      "text": "5.1. Payload Format",
      "section_title": true,
      "ja": "5.1. ペイロードフォーマット"
    },
    {
      "indent": 3,
      "text": "All HIP packets start with a fixed header.",
      "ja": "すべてのHIPパケットは、固定ヘッダで始まります。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Next Header   | Header Length |0| Packet Type |Version| RES.|1|\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Checksum             |           Controls            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                Sender's Host Identity Tag (HIT)               |\n|                                                               |\n|                                                               |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|               Receiver's Host Identity Tag (HIT)              |\n|                                                               |\n|                                                               |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n/                        HIP Parameters                         /\n/                                                               /\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The HIP header is logically an IPv6 extension header. However, this document does not describe processing for Next Header values other than decimal 59, IPPROTO_NONE, the IPv6 'no next header' value. Future documents MAY define behavior for other values. However, current implementations MUST ignore trailing data if an unimplemented Next Header value is received.",
      "ja": "HIPヘッダは、論理的にIPv6拡張ヘッダです。しかしながら、この文献は、59進以外の次ヘッダ値についてIPPROTO_NONE、IPv6の「いいえ次ヘッダーの値を処理を記載していません。将来の文書は、他の値のための行動を定義することができます。実装されていない次のヘッダー値が受信された場合は、現在の実装では、後続のデータを無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The Header Length field contains the combined length of the HIP Header and HIP parameters in 8-byte units, excluding the first 8 bytes. Since all HIP headers MUST contain the sender's and receiver's HIT fields, the minimum value for this field is 4, and conversely, the maximum length of the HIP Parameters field is (255 * 8) - 32 = 2008 bytes (see Section 5.1.3 regarding HIP fragmentation). Note: this sets an additional limit for sizes of parameters included in the Parameters field, independent of the individual parameter maximum lengths.",
      "ja": "ヘッダ長フィールドは、最初の8つのバイトを除く、8バイト単位でHIPヘッダおよびHIPパラメータの組み合わせた長さが含まれています。すべてのHIPヘッダは送信者と受信者のHITフィールドを含まなければならないため、このフィールドの最小値は4であり、そして逆に、HIPパラメータフィールドの最大長は（255 * 8）である -  32 = 2008バイト（セクション5.1.3参照します）HIPの断片化に関する。注：これは、個々のパラメータの最大長さの独立したパラメータフィールドに含まれるパラメータの大きさのために追加の制限を設定します。"
    },
    {
      "indent": 3,
      "text": "The Packet Type indicates the HIP packet type. The individual packet types are defined in the relevant sections. If a HIP host receives a HIP packet that contains an unrecognized packet type, it MUST drop the packet.",
      "ja": "パケットタイプは、HIPパケットの種類を示します。個々のパケットタイプは、関連セクションで定義されています。 HIPホストが認識できないパケットタイプが含まれているHIPパケットを受信した場合、それはパケットをドロップしなければなりません。"
    },
    {
      "indent": 3,
      "text": "The HIP Version field is four bits. The version defined in this document is 2. The version number is expected to be incremented only if there are incompatible changes to the protocol. Most extensions can be handled by defining new packet types, new parameter types, or new Controls (see Section 5.1.2).",
      "ja": "HIP Versionフィールドは4ビットです。この文書で定義されたバージョンは、バージョン番号がプロトコルに互換性のない変更がある場合にのみインクリメントされることが期待される2です。ほとんどの拡張機能は、新たなパケットタイプ、新しいパラメータタイプ、または新しいコントロールを定義することによって処理することができます（5.1.2項を参照してください）。"
    },
    {
      "indent": 3,
      "text": "The following three bits are reserved for future use. They MUST be zero when sent, and they MUST be ignored when handling a received packet.",
      "ja": "以下の3つのビットは将来の使用のために予約されています。送信されたとき、彼らはゼロでなければならない、と、受信したパケットを処理するときに、それらを無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The two fixed bits in the header are reserved for SHIM6 compatibility [RFC5533], Section 5.3. For implementations adhering (only) to this specification, they MUST be set as shown when sending and MUST be ignored when receiving. This is to ensure optimal forward compatibility. Note that for implementations that implement other compatible specifications in addition to this specification, the corresponding rules may well be different. For example, an implementation that implements both this specification and the SHIM6 protocol may need to check these bits in order to determine how to handle the packet.",
      "ja": "ヘッダ内の2つの固定ビットがSHIM6互換[RFC5533]、セクション5.3のために予約されています。示されるように送受信時に無視されなければならない場合、本明細書に（のみ）付着実装のために、それらは設定しなければなりません。これは、最適な上位互換性を確保することです。この明細書に加えて他の互換性の仕様を実現する実装のために、対応するルールが十分に異なっていてもよいことに留意されたいです。例えば、本明細書及びSHIM6プロトコルの両方を実装する実装では、パケットの処理方法を決定するためにこれらのビットをチェックする必要があるかもしれません。"
    },
    {
      "indent": 3,
      "text": "The HIT fields are always 128 bits (16 bytes) long.",
      "ja": "HITフィールドは常に長い128ビット（16バイト）です。"
    },
    {
      "indent": 0,
      "text": "5.1.1. Checksum",
      "section_title": true,
      "ja": "5.1.1. チェックサム"
    },
    {
      "indent": 3,
      "text": "Since the checksum covers the source and destination addresses in the IP header, it MUST be recomputed on HIP-aware NAT devices.",
      "ja": "チェックサムは、IPヘッダ内の送信元アドレスと宛先アドレスをカバーするので、HIP対応NATデバイスに再計算されなければなりません。"
    },
    {
      "indent": 3,
      "text": "If IPv6 is used to carry the HIP packet, the pseudo header [RFC2460] contains the source and destination IPv6 addresses, HIP packet length in the pseudo header Length field, a zero field, and the HIP protocol number (see Section 5.1) in the Next Header field. The Length field is in bytes and can be calculated from the HIP Header Length field:",
      "ja": "IPv6がHIPパケットを搬送するために使用される場合、疑似ヘッダ[RFC2460]は、ソースおよび宛先IPv6アドレスを含んでいる、疑似ヘッダ長フィールド、ゼロフィールド、及びHIPプロトコル番号でHIPパケット長（5.1節を参照）次ヘッダフィールド。 Lengthフィールドは、バイト単位であり、HIPヘッダ長フィールドから計算することができます。"
    },
    {
      "indent": 3,
      "text": "(HIP Header Length + 1) * 8.",
      "ja": "（HIPヘッダ長+ 1）* 8。"
    },
    {
      "indent": 3,
      "text": "In case of using IPv4, the IPv4 UDP pseudo header format [RFC0768] is used. In the pseudo header, the source and destination addresses are those used in the IP header, the zero field is obviously zero, the protocol is the HIP protocol number (see Section 4), and the length is calculated as in the IPv6 case.",
      "ja": "IPv4を使用する場合には、IPv4のUDP疑似ヘッダフォーマット[RFC0768]は使用されています。疑似ヘッダに、送信元および宛先アドレスはIPヘッダで使用されるものであり、ゼロフィールドが明らかにゼロであり、プロトコルは、HIPプロトコル番号（セクション4を参照）であり、長さは、IPv6の場合のように計算されます。"
    },
    {
      "indent": 0,
      "text": "5.1.2. HIP Controls",
      "section_title": true,
      "ja": "5.1.2.  HIPコントロール"
    },
    {
      "indent": 3,
      "text": "The HIP Controls field conveys information about the structure of the packet and capabilities of the host.",
      "ja": "HIPコントロールフィールドは、ホストのパケットや能力の構造についての情報を伝えます。"
    },
    {
      "indent": 3,
      "text": "The following fields have been defined:",
      "ja": "次のフィールドが定義されています。"
    },
    {
      "indent": 5,
      "text": "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| | | | | | | | | | | | | | | |A|\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A - Anonymous: If this is set, the sender's HI in this packet is anonymous, i.e., one not listed in a directory. Anonymous HIs SHOULD NOT be stored. This control is set in packets using anonymous sender HIs. The peer receiving an anonymous HI in an R1 or I2 may choose to refuse it.",
      "ja": " - 匿名：これが設定されている場合は、このパケット内の送信者のHIは、すなわち、1がディレクトリに記載されていない、匿名です。匿名彼は保存しないでください。この制御は、匿名の送信者、彼を使用してパケットに設定されています。 R1またはI2で匿名HIを受けたピアは、それを拒否することもできます。"
    },
    {
      "indent": 3,
      "text": "The rest of the fields are reserved for future use, and MUST be set to zero in sent packets and MUST be ignored in received packets.",
      "ja": "残りのフィールドは、将来の使用のために予約されており、送信されたパケットにゼロに設定しなければならなくて、受信したパケットに無視しなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.1.3. HIP Fragmentation Support",
      "section_title": true,
      "ja": "5.1.3.  HIPの断片化のサポート"
    },
    {
      "indent": 3,
      "text": "A HIP implementation MUST support IP fragmentation/reassembly. Fragment reassembly MUST be implemented in both IPv4 and IPv6, but fragment generation is REQUIRED to be implemented in IPv4 (IPv4 stacks and networks will usually do this by default) and RECOMMENDED to be implemented in IPv6. In IPv6 networks, the minimum MTU is larger, 1280 bytes, than in IPv4 networks. The larger MTU size is usually sufficient for most HIP packets, and therefore fragment generation may not be needed. If it is expected that a host will send HIP packets that are larger than the minimum IPv6 MTU, the implementation MUST implement fragment generation even for IPv6.",
      "ja": "HIPの実装では、IPフラグメンテーション/再構築をサポートしなければなりません。フラグメント再構成は、IPv4とIPv6の両方に実装されなければならないが、断片の生成はIPv4のに実装する必要がある（のIPv4スタック及びネットワークは通常、デフォルトでこれを行います）とIPv6に実装することを推奨します。 IPv6ネットワークでは、最小のMTUは、IPv4ネットワークに比べて、1280バイト大きくなります。より大きなMTUサイズが最もHIPパケットの通常十分であり、したがって、フラグメント生成が必要とされなくてもよいです。それは、ホストが最小のIPv6 MTUより大きいHIPパケットを送信することが予想される場合は、実装でもIPv6のフラグメントの生成を実装しなければなりません。"
    },
    {
      "indent": 3,
      "text": "In IPv4 networks, HIP packets may encounter low MTUs along their routed path. Since basic HIP, as defined in this document, does not provide a mechanism to use multiple IP datagrams for a single HIP packet, support for path MTU discovery does not bring any value to HIP in IPv4 networks. HIP-aware NAT devices SHOULD perform IPv4 reassembly/fragmentation for HIP packets.",
      "ja": "IPv4ネットワークでは、HIPパケットは、そのルーティングパスに沿って低いのMTUが発生することがあります。基本的なHIPので、この文書で定義されるように、IPv4ネットワークでHIPに任意の値を持っていないパスMTUディスカバリをサポート、シングルHIPパケットに対して複数のIPデータグラムを使用するためのメカニズムを提供していません。 HIP対応のNATデバイスは、HIPパケットのIPv4再構築/断片化を実行する必要があります。"
    },
    {
      "indent": 3,
      "text": "All HIP implementations have to be careful while employing a reassembly algorithm so that the algorithm is sufficiently resistant to DoS attacks.",
      "ja": "すべてのHIP実装は、アルゴリズムがDoS攻撃に対して十分な耐性になるように再構築アルゴリズムを採用しながら注意する必要があります。"
    },
    {
      "indent": 3,
      "text": "Certificate chains can cause the packet to be fragmented, and fragmentation can open implementations to denial-of-service attacks [KAU03]. \"Hash and URL\" schemes as defined in [RFC6253] for HIP version 1 may be used to avoid fragmentation and mitigate resulting DoS attacks.",
      "ja": "証明書チェーンは、パケットが断片化されることがありますし、断片化は、サービス拒否攻撃[KAU03]への実装を開くことができます。 HIPバージョン1 [RFC6253]で定義されるように「ハッシュとURL」スキームは断片化を回避し、結果として得られるDoS攻撃を軽減するために使用することができます。"
    },
    {
      "indent": 0,
      "text": "5.2. HIP Parameters",
      "section_title": true,
      "ja": "5.2.  HIPパラメータ"
    },
    {
      "indent": 3,
      "text": "The HIP parameters carry information that is necessary for establishing and maintaining a HIP association. For example, the peer's public keys as well as the signaling for negotiating ciphers and payload handling are encapsulated in HIP parameters. Additional information, meaningful for end hosts or middleboxes, may also be included in HIP parameters. The specification of the HIP parameters and their mapping to HIP packets and packet types is flexible to allow HIP extensions to define new parameters and new protocol behavior.",
      "ja": "HIPパラメータは、HIPアソシエーションを確立し、維持するために必要な情報を運びます。例えば、ピアの公開鍵だけでなく、暗号ペイロード処理を交渉するためのシグナリングは、HIPパラメータにカプセル化されます。エンドホスト又は中間装置のために意味のある追加情報は、また、HIPパラメータに含まれてもよいです。 HIPパケットとパケットタイプにHIPパラメータとそのマッピングの仕様は、HIPの拡張は、新しいパラメータと新しいプロトコルの動作を定義することができるように柔軟です。"
    },
    {
      "indent": 3,
      "text": "In HIP packets, HIP parameters are ordered according to their numeric type number and encoded in TLV format.",
      "ja": "HIPパケットで、HIPパラメータは、数値タイプ番号に従って順序付けられ、TLV形式でエンコード。"
    },
    {
      "indent": 3,
      "text": "The following parameter types are currently defined.",
      "ja": "次のパラメータの種類は、現在定義されています。"
    },
    {
      "indent": 3,
      "text": "+------------------------+-------+-----------+----------------------+\n| TLV                    | Type  | Length    | Data                 |\n+------------------------+-------+-----------+----------------------+\n| R1_COUNTER             | 129   | 12        | Puzzle generation    |\n|                        |       |           | counter              |\n|                        |       |           |                      |\n| PUZZLE                 | 257   | 12        | #K and Random #I     |\n|                        |       |           |                      |\n| SOLUTION               | 321   | 20        | #K, Random #I and    |\n|                        |       |           | puzzle solution #J   |\n|                        |       |           |                      |\n| SEQ                    | 385   | 4         | UPDATE packet ID     |\n|                        |       |           | number               |\n|                        |       |           |                      |\n| ACK                    | 449   | variable  | UPDATE packet ID     |\n|                        |       |           | number               |\n|                        |       |           |                      |\n| DH_GROUP_LIST          | 511   | variable  | Ordered list of DH   |\n|                        |       |           | Group IDs supported  |\n|                        |       |           | by a host            |\n|                        |       |           |                      |\n| DIFFIE_HELLMAN         | 513   | variable  | public key           |\n|                        |       |           |                      |\n| HIP_CIPHER             | 579   | variable  | List of HIP          |\n|                        |       |           | encryption           |\n|                        |       |           | algorithms           |\n|                        |       |           |                      |\n| ENCRYPTED              | 641   | variable  | Encrypted part of a  |\n|                        |       |           | HIP packet           |\n|                        |       |           |                      |\n| HOST_ID                | 705   | variable  | Host Identity with   |\n|                        |       |           | Fully Qualified      |\n|                        |       |           | Domain Name (FQDN)   |\n|                        |       |           | or Network Access    |\n|                        |       |           | Identifier (NAI)     |\n|                        |       |           |                      |\n| HIT_SUITE_LIST         | 715   | variable  | Ordered list of the  |\n|                        |       |           | HIT Suites supported |\n|                        |       |           | by the Responder     |\n|                        |       |           |                      |\n| CERT                   | 768   | variable  | HI Certificate; used |\n|                        |       |           | to transfer          |\n|                        |       |           | certificates.        |\n|                        |       |           | Specified in a       |\n|                        |       |           | separate document.   |\n|                        |       |           |                      |",
      "raw": true
    },
    {
      "indent": 3,
      "text": "| NOTIFICATION           | 832   | variable  | Informational data   |\n|                        |       |           |                      |\n| ECHO_REQUEST_SIGNED    | 897   | variable  | Opaque data to be    |\n|                        |       |           | echoed back; signed  |\n|                        |       |           |                      |\n| ECHO_RESPONSE_SIGNED   | 961   | variable  | Opaque data echoed   |\n|                        |       |           | back by request;     |\n|                        |       |           | signed               |\n|                        |       |           |                      |\n| TRANSPORT_FORMAT_LIST  | 2049  | Ordered   | variable             |\n|                        |       | list of   |                      |\n|                        |       | preferred |                      |\n|                        |       | HIP       |                      |\n|                        |       | transport |                      |\n|                        |       | type      |                      |\n|                        |       | numbers   |                      |\n|                        |       |           |                      |\n| HIP_MAC                | 61505 | variable  | HMAC-based message   |\n|                        |       |           | authentication code, |\n|                        |       |           | with key material    |\n|                        |       |           | from KEYMAT          |\n|                        |       |           |                      |\n| HIP_MAC_2              | 61569 | variable  | HMAC-based message   |\n|                        |       |           | authentication code, |\n|                        |       |           | with key material    |\n|                        |       |           | from KEYMAT.  Unlike |\n|                        |       |           | HIP_MAC, the HOST_ID |\n|                        |       |           | parameter is         |\n|                        |       |           | included in          |\n|                        |       |           | HIP_MAC_2            |\n|                        |       |           | calculation.         |\n|                        |       |           |                      |\n| HIP_SIGNATURE_2        | 61633 | variable  | Signature used in R1 |\n|                        |       |           | packet               |\n|                        |       |           |                      |\n| HIP_SIGNATURE          | 61697 | variable  | Signature of the     |\n|                        |       |           | packet               |\n|                        |       |           |                      |\n| ECHO_REQUEST_UNSIGNED  | 63661 | variable  | Opaque data to be    |\n|                        |       |           | echoed back; after   |\n|                        |       |           | signature            |\n|                        |       |           |                      |\n| ECHO_RESPONSE_UNSIGNED | 63425 | variable  | Opaque data echoed   |\n|                        |       |           | back by request;     |\n|                        |       |           | after signature      |\n+------------------------+-------+-----------+----------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "As the ordering (from lowest to highest) of HIP parameters is strictly enforced (see Section 5.2.1), the parameter type values for existing parameters have been spaced to allow for future protocol extensions.",
      "ja": "厳密に（5.2.1項を参照）が施行されたHIPパラメータの（最低から最高まで）の順序としては、既存のパラメータのためのパラメータの型の値は、将来のプロトコル拡張を可能にするために間隔を置いて配置されています。"
    },
    {
      "indent": 3,
      "text": "The following parameter type number ranges are defined.",
      "ja": "次のパラメータのタイプ番号範囲が定義されています。"
    },
    {
      "indent": 3,
      "text": "+---------------+---------------------------------------------------+\n| Type Range    | Purpose                                           |\n+---------------+---------------------------------------------------+\n| 0 -  1023     | Handshake                                         |\n|               |                                                   |\n| 1024 -   2047 | Reserved                                          |\n|               |                                                   |\n| 2048 -   4095 | Parameters related to HIP transport formats       |\n|               |                                                   |\n| 4096 -   8191 | Signed parameters allocated through specification |\n|               | documents                                         |\n|               |                                                   |\n| 8192 -  32767 | Reserved                                          |\n|               |                                                   |\n| 32768 - 49151 | Reserved for Private Use.  Signed parameters.     |\n|               |                                                   |\n| 49152 - 61439 | Reserved                                          |\n|               |                                                   |\n| 61440 - 62463 | Signatures and (signed) MACs                      |\n|               |                                                   |\n| 62464 - 63487 | Parameters that are neither signed nor MACed      |\n|               |                                                   |\n| 63488 - 64511 | Rendezvous and relaying                           |\n|               |                                                   |\n| 64512 - 65023 | Parameters that are neither signed nor MACed      |\n|               |                                                   |\n| 65024 - 65535 | Reserved                                          |\n+---------------+---------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The process for defining new parameters is described in Section 5.2.2 of this document.",
      "ja": "新しいパラメータを定義するためのプロセスは、このドキュメントのセクション5.2.2に記載されています。"
    },
    {
      "indent": 3,
      "text": "The range between 32768 (2^15) and 49151 (2^15 + 2^14) is Reserved for Private Use. Types from this range SHOULD be selected in a random fashion to reduce the probability of collisions.",
      "ja": "（15 + 2 ^ 14 ^ 2）専用使用のために予約されている32768（2 ^ 15）と49151の間の範囲。この範囲からのタイプは、衝突の確率を減らすためにランダムに選択する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.2.1. TLV Format",
      "section_title": true,
      "ja": "5.2.1.  TLVのフォーマット"
    },
    {
      "indent": 3,
      "text": "The TLV-encoded parameters are described in the following subsections. The Type field value also describes the order of these fields in the packet. The parameters MUST be included in the packet so that their types form an increasing order. If multiple parameters with the same type number are in one packet, the parameters with the same type MUST be consecutive in the packet. If the order does not follow this rule, the packet is considered to be malformed and it MUST be discarded.",
      "ja": "TLV符号化されたパラメータは、以下のサブセクションに記載されています。 Typeフィールドの値は、パケット内のこれらのフィールドの順序を説明しています。その種類は、昇順を形成するようにパラメータがパケットに含まれなければなりません。同じタイプ番号を持つ複数のパラメータは、一つのパケットである場合、同じタイプのパラメータは、パケット内の連続していなければなりません。順番はこのルールに従わない場合、パケットは不正な形式されたとみなされ、それを捨てなければなりません。"
    },
    {
      "indent": 3,
      "text": "Parameters using type values from 2048 up to 4095 are related to transport formats. Currently, one transport format is defined: the ESP transport format [RFC7402].",
      "ja": "2048から4095までのタイプの値を使用して、パラメータはフォーマットを輸送するために関連しています。現在、1つのトランスポートフォーマットが定義されている：ESPのトランスポートフォーマット[RFC7402]。"
    },
    {
      "indent": 3,
      "text": "All of the encoded TLV parameters have a length (that includes the Type and Length fields), which is a multiple of 8 bytes. When needed, padding MUST be added to the end of the parameter so that the total length is a multiple of 8 bytes. This rule ensures proper alignment of data. Any added padding bytes MUST be zeroed by the sender, and their values SHOULD NOT be checked by the receiver.",
      "ja": "符号化されたTLVパラメータの全ては、8バイトの倍数である長さ（つまり、タイプと長さフィールドを含む）を有します。必要なときに全長が8バイトの倍数になるように、パディングは、パラメータの末尾に追加する必要があります。このルールは、データの適切なアライメントを保証します。任意の追加パディングバイトは、送信者によってゼロにしなければならない、とそれらの値は、受信機によって確認されるべきではありません。"
    },
    {
      "indent": 3,
      "text": "The Length field indicates the length of the Contents field (in bytes). Consequently, the total length of the TLV parameter (including Type, Length, Contents, and Padding) is related to the Length field according to the following formula:",
      "ja": "長さフィールドは、（バイト）内容フィールドの長さを示します。従って、（タイプ、長さ、内容、およびパディングを含む）TLVパラメータの全長は、以下の式に従ってLengthフィールドに関連しています。"
    },
    {
      "indent": 3,
      "text": "Total Length = 11 + Length - (Length + 3) % 8;",
      "ja": "全長= 11 +長さ - （長さ+ 3）％8。"
    },
    {
      "indent": 3,
      "text": "where % is the modulo operator.",
      "ja": "ここで、％はモジュロ演算子です。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             Type            |C|             Length            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n/                          Contents                             /\n/                                               +-+-+-+-+-+-+-+-+\n|                                               |    Padding    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Type Type code for the parameter. 16 bits long, C-bit being part of the Type code. C Critical. One if this parameter is critical and MUST be recognized by the recipient, zero otherwise. The C-bit is considered to be a part of the Type field. Consequently, critical parameters are always odd, and non-critical ones have an even value. Length Length of the Contents, in bytes, excluding Type, Length, and Padding Contents Parameter specific, defined by Type Padding Padding, 0-7 bytes, added if needed",
      "ja": "パラメータのタイプのコードを入力します。 16ビット長、Cビットは、タイプ・コードの一部です。 Cクリティカル。このパラメータが重要であり、受信者によって認識されなければならない場合は、1つは、そうでない場合はゼロ。 Cビットは、タイプフィールドの一部であると考えられます。そのため、重要なパラメータは常に奇数であり、非重要なものは、偶数値を持っています。必要に応じてタイプ、長さ、およびパディングの内容を除く内容、バイト単位の長さの長さは、パラメータは、特定のタイプのパディングパディング、0-7バイトで定義され、追加しました"
    },
    {
      "indent": 3,
      "text": "Critical parameters (indicated by the odd type number value) MUST be recognized by the recipient. If a recipient encounters a critical parameter that it does not recognize, it MUST NOT process the packet any further. It MAY send an ICMP or NOTIFY, as defined in Section 4.3.",
      "ja": "（奇数型数値で示される）の重要なパラメータは、受信者によって認識されなければなりません。受信者は、それが認識しない重要なパラメータに遭遇した場合、それはそれ以上のパケットを処理してはいけません。 4.3節で定義されたように、それは、ICMPを送信したり、通知することができます。"
    },
    {
      "indent": 3,
      "text": "Non-critical parameters MAY be safely ignored. If a recipient encounters a non-critical parameter that it does not recognize, it SHOULD proceed as if the parameter was not present in the received packet.",
      "ja": "非クリティカルなパラメータは無視してかまいません。受信者は、それが認識しない非クリティカルなパラメータに遭遇した場合、そのパラメータは、受信したパケットには存在しなかったかのように進めるべき。"
    },
    {
      "indent": 0,
      "text": "5.2.2. Defining New Parameters",
      "section_title": true,
      "ja": "5.2.2. 新しいパラメータの定義"
    },
    {
      "indent": 3,
      "text": "Future specifications may define new parameters as needed. When defining new parameters, care must be taken to ensure that the parameter type values are appropriate and leave suitable space for other future extensions. One must remember that the parameters MUST always be arranged in numerically increasing order by Type code, thereby limiting the order of parameters (see Section 5.2.1).",
      "ja": "必要に応じて今後の仕様は、新たなパラメータを定義することができます。新しいパラメータを定義する場合、注意がパラメータの型の値が適切であることを確認し、他の将来の拡張のために、適切なスペースを残すように注意しなければなりません。一つは、それによってパラメータ（5.2.1項を参照）の順番を制限し、パラメータは常に数値型コードで昇順に配置しなければならないことを覚えておく必要があります。"
    },
    {
      "indent": 3,
      "text": "The following rules MUST be followed when defining new parameters.",
      "ja": "新しいパラメータを定義するときに、次の規則に従わなければなりません。"
    },
    {
      "indent": 3,
      "text": "1. The low-order bit C of the Type code is used to distinguish between critical and non-critical parameters. Hence, even parameter type numbers indicate non-critical parameters while odd parameter type numbers indicate critical parameters.",
      "ja": "1.コードの下位ビットCは、クリティカル及び非クリティカルパラメータとを区別するために使用されます。奇数のパラメータタイプ番号は重要なパラメータを示しながらしたがって、偶数パラメータタイプ数は重要でないパラメータを示します。"
    },
    {
      "indent": 3,
      "text": "2. A new parameter MAY be critical only if an old implementation that ignored it would cause security problems. In general, new parameters SHOULD be defined as non-critical, and expect a reply from the recipient.",
      "ja": "2. A新しいパラメータは、それを無視し、古い実装では、セキュリティ上の問題を引き起こす場合にのみ重要になることがあります。一般的には、新しいパラメータは非クリティカルとして定義され、受信者からの応答を期待するべきです。"
    },
    {
      "indent": 3,
      "text": "3. If a system implements a new critical parameter, it MUST provide the ability to set the associated feature off, such that the critical parameter is not sent at all. The configuration option MUST be well documented. Implementations operating in a mode adhering to this specification MUST disable the sending of new critical parameters by default. In other words, the management interface MUST allow vanilla standards-only mode as a default configuration setting, and MAY allow new critical payloads to be configured on (and off).",
      "ja": "3.システムが新しい重要なパラメータを実装している場合、それは重要なパラメータが全く送られないように、関連する機能をオフに設定する機能を提供しなければなりません。設定オプションは、十分に文書化されなければなりません。この仕様に準拠モードで動作する実装は、デフォルトでは、新たな重要なパラメータの送信を無効にする必要があります。言い換えれば、管理インターフェイスは、デフォルトの構成設定としてバニラ規格専用モードを許容しなければなりませんし、新しい重要なペイロードは（オフ）に設定されることを可能にします。"
    },
    {
      "indent": 3,
      "text": "4. See Section 9 for allocation rules regarding Type codes.",
      "section_title": true,
      "ja": "4.コードについての割り当て規則については、セクション9を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.2.3. R1_COUNTER",
      "section_title": true,
      "ja": "5.2.3.  R1_COUNTER"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             Type              |             Length            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                       Reserved, 4 bytes                       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                R1 generation counter, 8 bytes                 |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Type 129 Length 12 R1 generation counter The current generation of valid puzzles",
      "ja": "タイプ129の長さ12 R1生成カウンタ有効なパズルの現在の世代"
    },
    {
      "indent": 3,
      "text": "The R1_COUNTER parameter contains a 64-bit unsigned integer in network byte order, indicating the current generation of valid puzzles. The sender SHOULD increment this counter periodically. It is RECOMMENDED that the counter value is incremented at least as often as old PUZZLE values are deprecated so that SOLUTIONs to them are no longer accepted.",
      "ja": "R1_COUNTERパラメーターは、有効なパズルの現在の世代を示す、ネットワークバイト順で64ビットの符号なし整数を含んでいます。送信者は、定期的にこのカウンタをインクリメントすべきです。それらの解決策は、もはや受け入れられているように、古いPUZZLE値は推奨されていないとして、カウンタ値が、少なくともできるだけ頻繁にインクリメントすることをお勧めします。"
    },
    {
      "indent": 3,
      "text": "Support for the R1_COUNTER parameter is mandatory, although its inclusion in the R1 packet is optional. It SHOULD be included in the R1 (in which case it is covered by the signature), and if present in the R1, it MUST be echoed (including the Reserved field verbatim) by the Initiator in the I2 packet.",
      "ja": "R1パケット内の包含は任意であるがR1_COUNTERパラメータのサポートは必須です。これはR1（その場合、それは署名で覆われている）に含まれるべきであり、R1中に存在する場合、それはI2パケットにイニシエータによって（逐語的Reservedフィールドを含む）をエコーし​​なければなりません。"
    },
    {
      "indent": 0,
      "text": "5.2.4. PUZZLE",
      "section_title": true,
      "ja": "5.2.4. パズル"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             Type              |             Length            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  #K, 1 byte   |    Lifetime   |        Opaque, 2 bytes        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      Random #I, RHASH_len / 8 bytes           |\n/                                                               /\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Type 257 Length 4 + RHASH_len / 8 #K #K is the number of verified bits Lifetime puzzle lifetime 2^(value - 32) seconds Opaque data set by the Responder, indexing the puzzle Random #I random number of size RHASH_len bits",
      "ja": "サイズRHASH_lenビットのパズルランダム#I乱数をインデックスレスポンダによって設定された不透明なデータ、秒 -  257長さ4 + RHASH_len / 8 #K #Kが検証ビット寿命パズル寿命の数2 ^（32値）を入力"
    },
    {
      "indent": 3,
      "text": "Random #I is represented as an n-bit integer (where n is RHASH_len), and #K and Lifetime as 8-bit integers, all in network byte order.",
      "ja": "ランダム#Iは、ネットワークバイト順に8ビット整数としてnビット（nはRHASH_lenある）の整数であり、#K寿命、すべてのように表されます。"
    },
    {
      "indent": 3,
      "text": "The PUZZLE parameter contains the puzzle difficulty #K and an n-bit random integer #I. The Puzzle Lifetime indicates the time during which the puzzle solution is valid, and sets a time limit that should not be exceeded by the Initiator while it attempts to solve the puzzle. The lifetime is indicated as a power of 2 using the formula 2^(Lifetime - 32) seconds. A puzzle MAY be augmented with an ECHO_REQUEST_SIGNED or an ECHO_REQUEST_UNSIGNED parameter included in the R1; the contents of the echo request are then echoed back in the ECHO_RESPONSE_SIGNED or in the ECHO_RESPONSE_UNSIGNED parameter, allowing the Responder to use the included information as a part of its puzzle processing.",
      "ja": "パズルパラメータは、パズルの難易度#Kとnビットのランダムな整数#Iを含有します。パズル寿命はパズルの解決策が有効である時間を示し、それはパズルを解決しようとしながら、イニシエータが超えてはならない制限時間を設定します。秒 - 寿命は式2 ^（32寿命）を使用して2のべき乗として示されています。パズルはECHO_REQUEST_SIGNED又はR1に含まECHO_REQUEST_UNSIGNEDパラメータで増強されるかもしれません。エコー要求の内容物は、次いでレスポンダは、そのパズルの処理の一部として含まれる情報を使用することができ、ECHO_RESPONSE_SIGNEDまたはECHO_RESPONSE_UNSIGNEDパラメータにエコーバックされます。"
    },
    {
      "indent": 3,
      "text": "The Opaque and Random #I fields are not covered by the HIP_SIGNATURE_2 parameter.",
      "ja": "不透明とランダム#IフィールドはHIP_SIGNATURE_2パラメータによってカバーされていません。"
    },
    {
      "indent": 0,
      "text": "5.2.5. SOLUTION",
      "section_title": true,
      "ja": "5.2.5. 解決"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             Type              |             Length            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  #K, 1 byte   |   Reserved    |        Opaque, 2 bytes        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      Random #I, n bytes                       |\n/                                                               /\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|            Puzzle solution #J, RHASH_len / 8 bytes            |\n/                                                               /\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Type 321 Length 4 + RHASH_len / 4 #K #K is the number of verified bits Reserved zero when sent, ignored when received Opaque copied unmodified from the received PUZZLE parameter Random #I random number of size RHASH_len bits Puzzle solution #J random number of size RHASH_len bits",
      "ja": "入力321の長さ4 + RHASH_len / 4 #K #KサイズRHASH_lenの乱数のパズル溶液#J乱数ビット不透明が受信パズルパラメータランダム#Iから修飾されていないコピー受信した場合に無視され、送信されたときにゼロに予約確認ビットの数でありますサイズRHASH_lenビット"
    },
    {
      "indent": 3,
      "text": "Random #I and Random #J are represented as n-bit unsigned integers (where n is RHASH_len), and #K as an 8-bit unsigned integer, all in network byte order.",
      "ja": "ランダム#Iとランダム#Jは（nはRHASH_lenである）は、nビットの符号なし整数として表される、と#K 8ビットの符号なし整数として、すべてのネットワークバイト順です。"
    },
    {
      "indent": 3,
      "text": "The SOLUTION parameter contains a solution to a puzzle. It also echoes back the random difficulty #K, the Opaque field, and the puzzle integer #I.",
      "ja": "SOLUTIONパラメータは、パズルの解が含まれています。また、ランダムな難易＃K、不透明なフィールド、およびパズル整数#Iをエコーバック。"
    },
    {
      "indent": 0,
      "text": "5.2.6. DH_GROUP_LIST",
      "section_title": true,
      "ja": "5.2.6.  DH_GROUP_LIST"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             Type              |             Length            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| DH GROUP ID #1| DH GROUP ID #2| DH GROUP ID #3| DH GROUP ID #4|\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| DH GROUP ID #n|                Padding                        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Type 511 Length number of DH Group IDs DH GROUP ID identifies a DH GROUP ID supported by the host. The list of IDs is ordered by preference of the host. The possible DH Group IDs are defined in the DIFFIE_HELLMAN parameter. Each DH Group ID is one octet long.",
      "ja": "DHグループのID DH GROUPの511の長さの番号を入力するIDはDH GROUP IDは、ホストでサポートされている識別します。 IDのリストは、ホストの優先順位によって順序付けされます。可能なDHグループIDはDIFFIE_HELLMANパラメータで定義されています。各DHグループIDは1つのオクテットの長さです。"
    },
    {
      "indent": 3,
      "text": "The DH_GROUP_LIST parameter contains the list of supported DH Group IDs of a host. The Initiator sends the DH_GROUP_LIST in the I1 packet, and the Responder sends its own list in the signed part of the R1 packet. The DH Group IDs in the DH_GROUP_LIST are listed in the order of their preference of the host sending the list. DH Group IDs that are listed first are preferred over the DH Group IDs listed later. The information in the DH_GROUP_LIST allows the Responder to select the DH group preferred by itself and supported by the Initiator. Based on the DH_GROUP_LIST in the R1 packet, the Initiator can determine if the Responder has selected the best possible choice based on the Initiator's and Responder's preferences. If the Responder's choice differs from the best choice, the Initiator can conclude that there was an attempted downgrade attack (see Section 4.1.7).",
      "ja": "DH_GROUP_LISTパラメータは、ホストのサポートDHグループIDのリストが含まれています。イニシエータは、I1パケットにDH_GROUP_LISTを送信し、ResponderはR1パケットの署名部分に独自のリストを送信します。 DH_GROUP_LISTでDHグループIDはリストを送信するホストの彼らの好みの順に記載されています。最初にリストされているDHグループIDは、後に記載されているDHグループIDがより好ましいです。 DH_GROUP_LISTの情報は、レスポンダは、イニシエータによって単独で好ましい支持DHグループを選択することを可能にします。レスポンダはイニシエータのとレスポンダの好みに基づいて最良の選択肢を選択した場合はR1パケットでDH_GROUP_LISTに基づいて、イニシエータが決定することができます。レスポンダの選択が最良の選択と異なる場合、イニシエータは、（4.1.7項を参照）を試みたダウングレード攻撃があったと結論付けることができます。"
    },
    {
      "indent": 3,
      "text": "When selecting the DH group for the DIFFIE_HELLMAN parameter in the R1 packet, the Responder MUST select the first DH Group ID in its DH_GROUP_LIST in the R1 packet that is compatible with one of the Suite IDs in the Initiator's DH_GROUP_LIST in the I1 packet. The Responder MUST NOT select any other DH Group ID that is contained in both lists, because then a downgrade attack cannot be detected.",
      "ja": "R1パケットでDIFFIE_HELLMANパラメータのDHグループを選択するとき、ResponderはI1パケット内のイニシエータのDH_GROUP_LISTでスイートIDのいずれかと互換性のあるR1パケットでそのDH_GROUP_LISTに最初のDHグループIDを選択する必要があります。その後、ダウングレード攻撃を検出することができないので、Responderは、両方のリストに含まれている他のDHグループIDを選択してはなりません。"
    },
    {
      "indent": 3,
      "text": "In general, hosts SHOULD prefer stronger groups over weaker ones if the computation overhead is not prohibitively high for the intended application.",
      "ja": "計算オーバーヘッドが意図された用途のために法外に高くない場合、一般的に、ホストは、弱いものより強い基を好むべきです。"
    },
    {
      "indent": 0,
      "text": "5.2.7. DIFFIE_HELLMAN",
      "section_title": true,
      "ja": "5.2.7.  DIFFIE_HELLMAN"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             Type              |             Length            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Group ID    |      Public Value Length      | Public Value  /\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                               |            Padding            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Type 513 Length length in octets, excluding Type, Length, and Padding Group ID identifies values for p and g as well as the KDF Public Value length of the following Public Value in octets Length Public Value the sender's public Diffie-Hellman key",
      "ja": "タイプ、長さを除いた、オクテット513の長さの長さを入力し、パディンググループIDは、pとgの値だけでなく、送信者の公開のDiffie-Hellmanキーオクテット長公開値で、以下の公開値のKDF公開値の長さを特定します"
    },
    {
      "indent": 3,
      "text": "A single DIFFIE_HELLMAN parameter may be included in selected HIP packets based on the DH Group ID selected (Section 5.2.6). The following Group IDs have been defined; values are assigned by this document:",
      "ja": "単一DIFFIE_HELLMANパラメータは、DHグループID選択（セクション5.2.6）に基づいて選択されたHIPパケットに含まれてもよいです。以下のグループIDが定義されています。値は、この文書によって割り当てられます。"
    },
    {
      "indent": 4,
      "text": "Group KDF Value",
      "ja": "グループKDF値"
    },
    {
      "indent": 4,
      "text": "Reserved 0 DEPRECATED 1 DEPRECATED 2 1536-bit MODP group [RFC3526] HKDF [RFC5869] 3 3072-bit MODP group [RFC3526] HKDF [RFC5869] 4 DEPRECATED 5 DEPRECATED 6 NIST P-256 [RFC5903] HKDF [RFC5869] 7 NIST P-384 [RFC5903] HKDF [RFC5869] 8 NIST P-521 [RFC5903] HKDF [RFC5869] 9 SECP160R1 [SECG] HKDF [RFC5869] 10 2048-bit MODP group [RFC3526] HKDF [RFC5869] 11",
      "ja": "0予約非推奨1非難2 1536ビットMODPグループ[RFC3526] HKDF [RFC5869] 3 3072ビットMODPグループ[RFC3526] HKDF [RFC5869] 4非難5非難6 NIST P-256 [RFC5903] HKDF [RFC5869] 7 NIST P -384 [RFC5903] HKDF [RFC5869] 8 NIST P-521 [RFC5903] HKDF [RFC5869] 9 SECP160R1 [SECG] HKDF [RFC5869] 10 2048ビットMODPグループ[RFC3526] HKDF [RFC5869] 11"
    },
    {
      "indent": 3,
      "text": "The MODP Diffie-Hellman groups are defined in [RFC3526]. ECDH groups 7-9 are defined in [RFC5903] and [RFC6090]. ECDH group 10 is covered in Appendix D. Any ECDH used with HIP MUST have a co-factor of 1.",
      "ja": "MODPのDiffie-Hellmanグループは、[RFC3526]で定義されています。 ECDHグループ7-9は、[RFC5903]及び[RFC6090]で定義されています。 ECDH群10は付録D 1の補因子を持たなければならないHIPで使用される任意のECDHを覆われています。"
    },
    {
      "indent": 3,
      "text": "The Group ID also defines the key derivation function that is to be used for deriving the symmetric keys for the HMAC and symmetric encryption from the keying material from the Diffie-Hellman key exchange (see Section 6.5).",
      "ja": "グループIDはまた、HMACおよびDiffie-Hellman鍵交換からキーイングマテリアルから対称暗号化のための対称鍵を導出するために使用される鍵導出関数を定義する（セクション6.5を参照）。"
    },
    {
      "indent": 3,
      "text": "A HIP implementation MUST implement Group ID 3. The 160-bit SECP160R1 group can be used when lower security is enough (e.g., web surfing) and when the equipment is not powerful enough (e.g., some PDAs). Implementations SHOULD implement Group IDs 4 and 8.",
      "ja": "HIPの実装は、より低いセキュリティが十分に（例えば、ウェブサーフィン）である場合に160ビットSECP160R1基を用いることができるグループID 3を実装し、装置が十分に強力ではない（例えば、一部のPDA）しなければなりません。実装は、グループIDが4と8を実装する必要があります。"
    },
    {
      "indent": 3,
      "text": "To avoid unnecessary failures during the base exchange, the rest of the groups SHOULD be implemented in hosts where resources are adequate.",
      "ja": "塩基交換の際に、不必要な障害を避けるために、グループの残りの部分は、リソースが十分であるホストに実装する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.2.8. HIP_CIPHER",
      "section_title": true,
      "ja": "5.2.8.  HIP_CIPHER"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             Type              |             Length            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Cipher ID #1         |          Cipher ID #2         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Cipher ID #n         |             Padding           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Type 579 Length length in octets, excluding Type, Length, and Padding Cipher ID identifies the cipher algorithm to be used for encrypting the contents of the ENCRYPTED parameter",
      "ja": "タイプ、長さを除いた、オクテット579の長さの長さを入力し、パディング暗号IDは、暗号化パラメータの内容を暗号化するために使用される暗号アルゴリズムを特定し"
    },
    {
      "indent": 3,
      "text": "The following Cipher IDs are defined:",
      "ja": "以下の暗号IDが定義されています。"
    },
    {
      "indent": 8,
      "text": "Suite ID Value",
      "ja": "スイートID値"
    },
    {
      "indent": 8,
      "text": "RESERVED 0 NULL-ENCRYPT 1 ([RFC2410]) AES-128-CBC 2 ([RFC3602]) RESERVED 3 (unused value) AES-256-CBC 4 ([RFC3602])",
      "ja": "0 NULL-ENCRYPT 1（[RFC2410]）、AES-128-CBC 2（[RFC3602]）は3（未使用値）予約予約AES-256-CBC 4（[RFC3602]）"
    },
    {
      "indent": 3,
      "text": "The sender of a HIP_CIPHER parameter MUST make sure that there are no more than six (6) Cipher IDs in one HIP_CIPHER parameter.",
      "ja": "HIP_CIPHERパラメータの送信者は1つのHIP_CIPHERパラメータには半年以上（6）暗号のIDが存在しないことを確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "Conversely, a recipient MUST be prepared to handle received transport parameters that contain more than six Cipher IDs by accepting the first six Cipher IDs and dropping the rest. The limited number of Cipher IDs sets the maximum size of the HIP_CIPHER parameter. As the default configuration, the HIP_CIPHER parameter MUST contain at least one of the mandatory Cipher IDs. There MAY be a configuration option that allows the administrator to override this default.",
      "ja": "逆に、受信者は最初の6つの暗号IDを受け付け、残りを滴下し半年以上の暗号IDを含む受信したトランスポートパラメータを処理するために準備されなければなりません。暗号IDの限られた数HIP_CIPHERパラメータの最大サイズを設定します。デフォルトの設定として、HIP_CIPHERパラメータは必須暗号IDの少なくとも一つを含まなければなりません。管理者は、このデフォルトを上書きすることを可能にする設定オプションがあるかもしれません。"
    },
    {
      "indent": 3,
      "text": "The Responder lists supported and desired Cipher IDs in order of preference in the R1, up to the maximum of six Cipher IDs. The Initiator MUST choose only one of the corresponding Cipher IDs. This Cipher ID will be used for generating the ENCRYPTED parameter.",
      "ja": "レスポンダリストは、6つの暗号IDの最大値まで、R1における優先順に暗号IDを支持し、望ましいです。イニシエータは、対応する暗号のIDを1つだけ選択する必要があります。この暗号IDは、暗号化されたパラメータを生成するために使用されます。"
    },
    {
      "indent": 3,
      "text": "Mandatory implementation: AES-128-CBC. Implementors SHOULD support NULL-ENCRYPT for testing/debugging purposes but MUST NOT offer or accept this value unless explicitly configured for testing/debugging of HIP.",
      "ja": "必須の実装：AES-128-CBC。実装者は、テスト/デバッグの目的のためにNULL暗号化をサポートする必要がありますが、明示的にHIPのテスト/デバッグ用に設定されない限り、この値を提供するか、受け入れてはいけません。"
    },
    {
      "indent": 0,
      "text": "5.2.9. HOST_ID",
      "section_title": true,
      "ja": "5.2.9.  HOST_ID"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             Type              |             Length            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          HI Length            |DI-Type|      DI Length        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Algorithm            |         Host Identity         /\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                               |       Domain Identifier       /\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                                               |    Padding    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Type 705 Length length in octets, excluding Type, Length, and Padding HI Length length of the Host Identity in octets DI-Type type of the following Domain Identifier field DI Length length of the Domain Identifier field in octets Algorithm index to the employed algorithm Host Identity actual Host Identity Domain Identifier the identifier of the sender",
      "ja": "使用されるアルゴリズムのホストへのタイプ、長さ、及びオクテットアルゴリズム指数のドメイン識別子フィールドの次のドメイン識別子フィールドDI長長のオクテットDI型タイプホストIDのパディングHI長長さを除く、オクテット705の長さの長さを入力アイデンティティ実際のホスト識別ドメイン識別子送信者の識別子"
    },
    {
      "indent": 3,
      "text": "The following DI-Types have been defined:",
      "ja": "以下DI-タイプが定義されています。"
    },
    {
      "indent": 9,
      "text": "Type Value",
      "ja": "タイプ値"
    },
    {
      "indent": 9,
      "text": "none included 0 FQDN 1 NAI 2",
      "ja": "いずれも0 FQDN 1 NAI 2を含みません"
    },
    {
      "indent": 9,
      "text": "FQDN Fully Qualified Domain Name, in binary format NAI Network Access Identifier",
      "ja": "バイナリ形式NAIネットワークアクセス識別子でFQDN完全修飾ドメイン名、"
    },
    {
      "indent": 3,
      "text": "The format for the FQDN is defined in RFC 1035 [RFC1035], Section 3.1. The format for the NAI is defined in [RFC4282].",
      "ja": "FQDNの形式は、RFC 1035 [RFC1035]、セクション3.1で定義されています。 NAIの形式は[RFC4282]で定義されています。"
    },
    {
      "indent": 3,
      "text": "A host MAY optionally associate the Host Identity with a single Domain Identifier in the HOST_ID parameter. If there is no Domain Identifier, i.e., the DI-Type field is zero, the DI Length field is set to zero as well.",
      "ja": "ホストは、任意HOST_IDパラメータの単一ドメイン識別子とホストIDを関連付けることができます。いかなるドメイン識別子がない場合、すなわち、DI-Typeフィールドがゼロである、DI長フィールドも同様にゼロに設定されます。"
    },
    {
      "indent": 3,
      "text": "The following HI Algorithms have been defined:",
      "ja": "以下HIアルゴリズムが定義されています。"
    },
    {
      "indent": 8,
      "text": "Algorithm profiles Values",
      "ja": "アルゴリズムは、値のプロファイル"
    },
    {
      "indent": 8,
      "text": "RESERVED 0 DSA 3 [FIPS.186-4.2013] (RECOMMENDED) RSA 5 [RFC3447] (REQUIRED) ECDSA 7 [RFC4754] (REQUIRED) ECDSA_LOW 9 [SECG] (RECOMMENDED)",
      "ja": "RESERVED 0 DSA 3 [FIPS.186-4.2013]（推奨）RSA 5 [RFC3447]（必須）ECDSA 7 [RFC4754]（必須）ECDSA_LOW 9 [SECG]（推奨）"
    },
    {
      "indent": 3,
      "text": "For DSA, RSA, and ECDSA key types, profiles containing at least 112 bits of security strength (as defined by [NIST.800-131A.2011]) should be used. For RSA signature padding, the Probabilistic Signature Scheme (PSS) method of padding [RFC3447] MUST be used.",
      "ja": "DSA、RSA、およびECDSAキータイプについて、セキュリティ強度（[NIST.800-131A.2011]によって定義される）の少なくとも112ビットを含むプロファイルを使用すべきです。 RSA署名パディングのために、パディング[RFC3447]の確率署名方式（PSS）メソッドを使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The Host Identity is derived from the DNSKEY format for RSA and DSA. For these, the Public Key field of the RDATA part from RFC 4034 [RFC4034] is used. For Elliptic Curve Cryptography (ECC), we distinguish two different profiles: ECDSA and ECDSA_LOW. ECC contains curves approved by NIST and defined in RFC 4754 [RFC4754]. ECDSA_LOW is defined for devices with low computational capabilities and uses shorter curves from the Standards for Efficient Cryptography Group [SECG]. Any ECDSA used with HIP MUST have a co-factor of 1.",
      "ja": "ホストIDは、RSAおよびDSAのためのDNSKEYフォーマットから派生しています。これらについては、RFC 4034 [RFC4034]からのRDATA部の公開鍵フィールドが使用されています。 ECDSAとECDSA_LOW：楕円曲線暗号（ECC）のために、我々は2つの異なるプロファイルを区別する。 ECCは、曲線NISTによって承認され、RFC 4754 [RFC4754]で定義されているが含まれています。 ECDSA_LOWは低い計算能力を持つデバイス用に定義されており、効率的な暗号化グループ[SECG]のための基準から短いカーブを使用しています。 HIPで使用されるすべてのECDSAは1の補因子を持っていなければなりません。"
    },
    {
      "indent": 3,
      "text": "For ECDSA and ECDSA_LOW, Host Identities are represented by the following fields:",
      "ja": "ECDSAとECDSA_LOWのために、ホストアイデンティティは、次のフィールドで表されます。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          ECC Curve            |                               /\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                         Public Key                            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 5,
      "text": "ECC Curve Curve label Public Key Represented in octet-string format [RFC6090]",
      "ja": "オクテット文字列の形式で表現ECC曲線カーブラベル公開鍵[RFC6090]"
    },
    {
      "indent": 3,
      "text": "For hosts that implement ECDSA as the algorithm, the following ECC curves are required:",
      "ja": "アルゴリズムとしてECDSAを実装するホストについては、以下のECC曲線が必要です。"
    },
    {
      "indent": 8,
      "text": "Algorithm Curve Values",
      "ja": "アルゴリズム曲線値"
    },
    {
      "indent": 8,
      "text": "ECDSA RESERVED 0 ECDSA NIST P-256 1 [RFC4754] ECDSA NIST P-384 2 [RFC4754]",
      "ja": "ECDSA RESERVED 0 ECDSA NIST P-256 1 [RFC4754] ECDSA NIST P-384 2 [RFC4754]"
    },
    {
      "indent": 3,
      "text": "For hosts that implement the ECDSA_LOW algorithm profile, the following curve is required:",
      "ja": "ECDSA_LOWアルゴリズムプロファイルを実装するホストについては、以下の曲線が必要です。"
    },
    {
      "indent": 8,
      "text": "Algorithm Curve Values",
      "ja": "アルゴリズム曲線値"
    },
    {
      "indent": 8,
      "text": "ECDSA_LOW RESERVED 0 ECDSA_LOW SECP160R1 1 [SECG]",
      "ja": "ECDSA_LOW RESERVED 0 ECDSA_LOW SECP160R1 1 [SECG]"
    },
    {
      "indent": 0,
      "text": "5.2.10. HIT_SUITE_LIST",
      "section_title": true,
      "ja": "5.2.10.  HIT_SUITE_LIST"
    },
    {
      "indent": 3,
      "text": "The HIT_SUITE_LIST parameter contains a list of the supported HIT Suite IDs of the Responder. The Responder sends the HIT_SUITE_LIST in the signed part of the R1 packet. Based on the HIT_SUITE_LIST, the Initiator can determine which source HIT Suite IDs are supported by the Responder.",
      "ja": "HIT_SUITE_LISTパラメータは、レスポンダのサポートHITスイートIDのリストが含まれています。 ResponderはR1パケットの署名部分にHIT_SUITE_LISTを送信します。 HIT_SUITE_LISTに基づいて、イニシエータはソースHITスイートIDはレスポンダによってサポートされているかを決定することができます。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             Type              |             Length            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     ID #1     |     ID #2     |     ID #3     |     ID #4     |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     ID #n     |                Padding                        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Type 715 Length number of HIT Suite IDs ID identifies a HIT Suite ID supported by the host. The list of IDs is ordered by preference of the host. Each HIT Suite ID is one octet long. The four higher-order bits of the ID field correspond to the HIT Suite ID in the ORCHID OGA ID field. The four lower-order bits are reserved and set to 0 by the sender. The reception of an ID with the four lower-order bits not set to 0 SHOULD be considered as an error that MAY result in a NOTIFICATION of type UNSUPPORTED_HIT_SUITE.",
      "ja": "HITスイートIDがIDの715長番号を入力すると、ホストでサポートされているHITスイートIDを識別する。 IDのリストは、ホストの優先順位によって順序付けされます。各HITスイートIDは1つのオクテットの長さです。 IDフィールドの4上位ビットはORCHID OGA IDフィールドにHITスイートIDに対応します。下位4ビットは予約送信者によって0に設定されます。 0に設定されていない下位4ビットを有するIDの受信は、タイプUNSUPPORTED_HIT_SUITEの通知に生じ得る誤差として考慮されるべきです。"
    },
    {
      "indent": 3,
      "text": "The HIT Suite ID indexes a HIT Suite. HIT Suites are composed of signature algorithms as defined in Section 5.2.9, and hash functions.",
      "ja": "HITスイートIDインデックスHITスイート。セクション5.2.9、およびハッシュ関数で定義されているHITスイートは、署名アルゴリズムで構成されています。"
    },
    {
      "indent": 3,
      "text": "The ID field in the HIT_SUITE_LIST is defined as an eight-bit field, as opposed to the four-bit HIT Suite ID and OGA ID field in the ORCHID. This difference is a measure to accommodate larger HIT Suite IDs if the 16 available values prove insufficient. In that case, one of the 16 values, zero, will be used to indicate that four additional bits of the ORCHID will be used to encode the HIT Suite ID. Hence, the current four-bit HIT Suite IDs only use the four higher-order bits in the ID field. Future documents may define the use of the four lower-order bits in the ID field.",
      "ja": "ORCHIDに4ビットHITスイートIDとOGA IDフィールドとは対照的にHIT_SUITE_LISTにおけるIDフィールドは、8ビットのフィールドとして定義されています。この違いは、16の利用可能な値が不十分であることが判明した場合、より大きなHITスイートIDを収容するための尺度です。その場合、16個の値のいずれか、ゼロは、ランの4つの追加ビットがHITスイートIDを符号化するために使用されることを示すために使用されます。したがって、現在の4ビットHITスイートIDは唯一のIDフィールドの4つの上位ビットを使用します。将来の文書は、IDフィールド内の4つの下位ビットの使用を定義することができます。"
    },
    {
      "indent": 3,
      "text": "The following HIT Suite IDs are defined, and the relationship between the four-bit ID value used in the OGA ID field and the eight-bit encoding within the HIT_SUITE_LIST ID field is clarified:",
      "ja": "以下HITスイートIDが定義され、OGA IDフィールドに使用される4ビットID値とHIT_SUITE_LIST IDフィールド内の8ビットの符号化との関係が明らかにされています。"
    },
    {
      "indent": 8,
      "text": "HIT Suite Four-bit ID Eight-bit encoding",
      "ja": "HITスイート4ビットID 8ビットエンコーディング"
    },
    {
      "indent": 8,
      "text": "RESERVED 0 0x00 RSA,DSA/SHA-256 1 0x10 (REQUIRED) ECDSA/SHA-384 2 0x20 (RECOMMENDED) ECDSA_LOW/SHA-1 3 0x30 (RECOMMENDED)",
      "ja": "RESERVED 0 0x00のRSA、DSA / SHA-256 1が0x10（REQUIRED）ECDSA / SHA-384 2は0x20（推奨）ECDSA_LOW / SHA-1 3 0x30から（推奨）"
    },
    {
      "indent": 3,
      "text": "The following table provides more detail on the above HIT Suite combinations. The input for each generation algorithm is the encoding of the HI as defined in Section 3.2. The output is 96 bits long and is directly used in the ORCHID.",
      "ja": "次の表は、上記HITスイートの組み合わせの詳細を提供します。セクション3.2で定義されるように、各生成アルゴリズムのための入力がHIの符号化です。出力は96ビット長であり、直接ORCHIDに使用されます。"
    },
    {
      "indent": 3,
      "text": "+-------+----------+--------------+------------+--------------------+\n| Index | Hash     | HMAC         | Signature  | Description        |\n|       | function |              | algorithm  |                    |\n|       |          |              | family     |                    |\n+-------+----------+--------------+------------+--------------------+\n|     0 |          |              |            | Reserved           |\n|       |          |              |            |                    |\n|     1 | SHA-256  | HMAC-SHA-256 | RSA, DSA   | RSA or DSA HI      |\n|       |          |              |            | hashed with        |\n|       |          |              |            | SHA-256, truncated |\n|       |          |              |            | to 96 bits         |\n|       |          |              |            |                    |\n|     2 | SHA-384  | HMAC-SHA-384 | ECDSA      | ECDSA HI hashed    |\n|       |          |              |            | with SHA-384,      |\n|       |          |              |            | truncated to 96    |\n|       |          |              |            | bits               |\n|       |          |              |            |                    |\n|     3 | SHA-1    | HMAC-SHA-1   | ECDSA_LOW  | ECDSA_LOW HI       |\n|       |          |              |            | hashed with SHA-1, |\n|       |          |              |            | truncated to 96    |\n|       |          |              |            | bits               |\n+-------+----------+--------------+------------+--------------------+",
      "raw": true
    },
    {
      "indent": 27,
      "text": "Table 10: HIT Suites",
      "ja": "表10：HITスイーツ"
    },
    {
      "indent": 3,
      "text": "The hash of the Responder as defined in the HIT Suite determines the HMAC to be used for the RHASH function. The HMACs currently defined here are HMAC-SHA-256 [RFC4868], HMAC-SHA-384 [RFC4868], and HMAC-SHA-1 [RFC2404].",
      "ja": "HITスイートで定義されているレスポンダのハッシュはHMACはRHASH機能のために使用することを決定します。現在、ここで定義HMACsはHMAC-SHA-256 [RFC4868]、HMAC-SHA-384 [RFC4868]、およびHMAC-SHA-1 [RFC2404]です。"
    },
    {
      "indent": 0,
      "text": "5.2.11. TRANSPORT_FORMAT_LIST",
      "section_title": true,
      "ja": "5.2.11.  TRANSPORT_FORMAT_LIST"
    },
    {
      "indent": 3,
      "text": "The TRANSPORT_FORMAT_LIST parameter contains a list of the supported HIP transport formats (TFs) of the Responder. The Responder sends the TRANSPORT_FORMAT_LIST in the signed part of the R1 packet. Based on the TRANSPORT_FORMAT_LIST, the Initiator chooses one suitable transport format and includes the respective HIP transport format parameter in its response packet.",
      "ja": "TRANSPORT_FORMAT_LISTパラメータは、レスポンダのサポートHIPのトランスポートフォーマット（TFS）のリストが含まれています。 ResponderはR1パケットの署名部分にTRANSPORT_FORMAT_LISTを送信します。 TRANSPORT_FORMAT_LISTに基づいて、イニシエータは、一つの適切なトランスポートフォーマットを選択し、その応答パケットの各HIPのトランスポートフォーマットパラメータを含みます。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             Type              |             Length            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          TF type #1           |           TF type #2          /\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/          TF type #n           |             Padding           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Type 2049 Length 2x number of TF types TF Type identifies a transport format (TF) type supported by the host. The TF type numbers correspond to the HIP parameter type numbers of the respective transport format parameters. The list of TF types is ordered by preference of the sender.",
      "ja": "TFタイプTFタイプのタイプ2049の長さ2倍の数は、トランスポートフォーマット（TF）ホストによってサポートされているタイプを識別する。 TFタイプ番号は各トランスポートフォーマットパラメータのHIPパラメータ種別番号に対応します。 TFタイプのリストは、送信者の好みによって順序付けされます。"
    },
    {
      "indent": 3,
      "text": "The TF type numbers index the respective HIP parameters for the transport formats in the type number range between 2050 and 4095. The parameters and their use are defined in separate documents. Currently, the only transport format defined is IPsec ESP [RFC7402].",
      "ja": "TFタイプ番号インデックスが2050、及び4095のパラメータとその使用との間の種類数範囲内のトランスポートフォーマットのためのそれぞれのHIPパラメータは、別の文書で定義されています。現在、定義されている唯一のトランスポートフォーマットは、IPsec ESP [RFC7402]です。"
    },
    {
      "indent": 3,
      "text": "For each listed TF type, the sender of the TRANSPORT_FORMAT_LIST parameter MUST include the respective transport format parameter in the HIP packet. The receiver MUST ignore the TF type in the TRANSPORT_FORMAT_LIST if no matching transport format parameter is present in the packet.",
      "ja": "各リストされたTFタイプに対して、TRANSPORT_FORMAT_LISTパラメータの送信者は、HIPパケットにおけるそれぞれのトランスポート・フォーマット・パラメータを含まなければなりません。一致するトランスポートフォーマットパラメータがパケット内に存在しない場合、受信機はTRANSPORT_FORMAT_LISTにおけるTFのタイプを無視しなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.2.12. HIP_MAC",
      "section_title": true,
      "ja": "5.2.12.  HIP_MAC"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             Type              |             Length            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n|                             HMAC                              |\n/                                                               /\n/                               +-------------------------------+\n|                               |            Padding            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Type 61505 Length length in octets, excluding Type, Length, and Padding HMAC HMAC computed over the HIP packet, excluding the HIP_MAC parameter and any following parameters, such as HIP_SIGNATURE, HIP_SIGNATURE_2, ECHO_REQUEST_UNSIGNED, or ECHO_RESPONSE_UNSIGNED. The Checksum field MUST be set to zero, and the HIP header length in the HIP common header MUST be calculated not to cover any excluded parameters when the HMAC is calculated. The size of the HMAC is the natural size of the hash computation output depending on the used hash function.",
      "ja": "タイプ、長さ、及びパディングHMAC HMAC HIPパケットにわたって計算、HIP_MACパラメータを除くと、そのようなHIP_SIGNATURE、HIP_SIGNATURE_2、ECHO_REQUEST_UNSIGNED、又はECHO_RESPONSE_UNSIGNEDなどの任意の以下のパラメータを除く、オクテット単位で61505の長さの長さを入力します。チェックサムフィールドはゼロに設定しなければなりません、そしてHIP共通ヘッダにおけるHIPヘッダ長は、HMACを計算する際、任意の除外パラメータをカバーしないように計算しなければなりません。 HMACの大きさは、使用されるハッシュ関数に応じてハッシュ演算出力の自然なサイズです。"
    },
    {
      "indent": 3,
      "text": "The HMAC uses RHASH as the hash algorithm. The calculation and verification process is presented in Section 6.4.1.",
      "ja": "HMACは、ハッシュアルゴリズムとしてRHASHを使用しています。計算と検証プロセスは、セクション6.4.1に示されています。"
    },
    {
      "indent": 0,
      "text": "5.2.13. HIP_MAC_2",
      "section_title": true,
      "ja": "5.2.13.  HIP_MAC_2"
    },
    {
      "indent": 3,
      "text": "HIP_MAC_2 is a MAC of the packet and the HI of the sender in the form of a HOST_ID parameter when that parameter is not actually included in the packet. The parameter structure is the same as the structure shown in Section 5.2.12. The fields are as follows:",
      "ja": "そのパラメータは、実際にパケットに含まれていない場合HIP_MAC_2は、パケットのMACとHOST_IDパラメータの形式で送信者のHIです。パラメータ構造は、セクション5.2.12に示した構造と同じです。次のようにフィールドは次のとおりです。"
    },
    {
      "indent": 5,
      "text": "Type 61569 Length length in octets, excluding Type, Length, and Padding HMAC HMAC computed over the HIP packet, excluding the HIP_MAC_2 parameter and any following parameters such as HIP_SIGNATURE, HIP_SIGNATURE_2, ECHO_REQUEST_UNSIGNED, or ECHO_RESPONSE_UNSIGNED, and including an additional sender's HOST_ID parameter during the HMAC calculation. The Checksum field MUST be set to zero, and the HIP header length in the HIP common header MUST be calculated not to cover any excluded parameters when the HMAC is calculated. The size of the HMAC is the natural size of the hash computation output depending on the used hash function.",
      "ja": "HIP_MAC_2パラメータや、HIP_SIGNATURE、HIP_SIGNATURE_2、ECHO_REQUEST_UNSIGNED、またはECHO_RESPONSE_UNSIGNEDなど任意の次のパラメータを除く、HIPパケットにわたって計算タイプ、長さ、およびパディングHMAC HMACを除く、オクテット単位で61569の長さの長さを入力し、中に追加の送信者のHOST_IDパラメータを含みますHMAC計算。チェックサムフィールドはゼロに設定しなければなりません、そしてHIP共通ヘッダにおけるHIPヘッダ長は、HMACを計算する際、任意の除外パラメータをカバーしないように計算しなければなりません。 HMACの大きさは、使用されるハッシュ関数に応じてハッシュ演算出力の自然なサイズです。"
    },
    {
      "indent": 3,
      "text": "The HMAC uses RHASH as the hash algorithm. The calculation and verification process is presented in Section 6.4.1.",
      "ja": "HMACは、ハッシュアルゴリズムとしてRHASHを使用しています。計算と検証プロセスは、セクション6.4.1に示されています。"
    },
    {
      "indent": 0,
      "text": "5.2.14. HIP_SIGNATURE",
      "section_title": true,
      "ja": "5.2.14.  HIP_SIGNATURE"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             Type              |             Length            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|    SIG alg                    |            Signature          /\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                               |             Padding           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Type 61697 Length length in octets, excluding Type, Length, and Padding SIG alg signature algorithm Signature the signature is calculated over the HIP packet, excluding the HIP_SIGNATURE parameter and any parameters that follow the HIP_SIGNATURE parameter. When the signature is calculated, the Checksum field MUST be set to zero, and the HIP header length in the HIP common header MUST be calculated only up to the beginning of the HIP_SIGNATURE parameter.",
      "ja": "タイプ、長さを除く、オクテット単位で61697の長さの長さを入力し、パディングSIG ALG署名アルゴリズム署名署名はHIP_SIGNATUREパラメータとHIP_SIGNATUREパラメータに従う任意のパラメータを除く、HIPパケットにわたって計算されます。署名が算出されると、チェックサムフィールドはゼロに設定しなければなりません、そしてHIP共通ヘッダにおけるHIPヘッダ長だけHIP_SIGNATUREパラメータの開始までに計算しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The signature algorithms are defined in Section 5.2.9. The signature in the Signature field is encoded using the method depending on the signature algorithm (e.g., according to [RFC3110] in the case of RSA/ SHA-1, [RFC5702] in the case of RSA/SHA-256, [RFC2536] in the case of DSA, or [RFC6090] in the case of ECDSA).",
      "ja": "署名アルゴリズムはセクション5.2.9で定義されています。署名フィールドの署名は、RSA / SHA-1の場合には[RFC3110]に記載の署名アルゴリズム（例えば、RSA / SHA-256の場合には[RFC5702]、[RFC2536]に応じた方法を使用して符号化されますDSAの場合、又はECDSAの場合には[RFC6090]）です。"
    },
    {
      "indent": 3,
      "text": "HIP_SIGNATURE calculation and verification follow the process defined in Section 6.4.2.",
      "ja": "HIP_SIGNATURE計算と検証は、6.4.2項で定義されたプロセスに従ってください。"
    },
    {
      "indent": 0,
      "text": "5.2.15. HIP_SIGNATURE_2",
      "section_title": true,
      "ja": "5.2.15.  HIP_SIGNATURE_2"
    },
    {
      "indent": 3,
      "text": "HIP_SIGNATURE_2 excludes the variable parameters in the R1 packet to allow R1 pre-creation. The parameter structure is the same as the structure shown in Section 5.2.14. The fields are as follows:",
      "ja": "HIP_SIGNATURE_2はR1事前に作成できるように、R1パケット内の可変パラメータを除外します。パラメータ構造は、セクション5.2.14に示した構造と同じです。次のようにフィールドは次のとおりです。"
    },
    {
      "indent": 5,
      "text": "Type 61633 Length length in octets, excluding Type, Length, and Padding SIG alg signature algorithm Signature Within the R1 packet that contains the HIP_SIGNATURE_2 parameter, the Initiator's HIT, the Checksum field, and the Opaque and Random #I fields in the PUZZLE parameter MUST be set to zero while computing the HIP_SIGNATURE_2 signature. Further, the HIP packet length in the HIP header MUST be adjusted as if the HIP_SIGNATURE_2 was not in the packet during the signature calculation, i.e., the HIP packet length points to the beginning of the HIP_SIGNATURE_2 parameter during signing and verification.",
      "ja": "PUZZLEパラメータにしなければならないタイプ、長さを除いた、オクテット61633長の長さを入力し、HIP_SIGNATURE_2パラメータが含まれているR1パケット内のパディングSIG ALG署名アルゴリズム署名、イニシエータのHIT、チェックサムフィールド、および不透明とランダム#IフィールドHIP_SIGNATURE_2署名を計算しながら、ゼロに設定されます。 HIP_SIGNATURE_2署名計算時パケットでなかったかのように、さらに、HIPヘッダーのHIPパケット長を調整しなければならない、即ち、HIPパケット長点署名と検証中HIP_SIGNATURE_2パラメータの先頭に。"
    },
    {
      "indent": 3,
      "text": "Zeroing the Initiator's HIT makes it possible to create R1 packets beforehand, to minimize the effects of possible DoS attacks. Zeroing the Random #I and Opaque fields within the PUZZLE parameter allows these fields to be populated dynamically on precomputed R1s.",
      "ja": "イニシエータのHITをゼロにすることは可能DoS攻撃の影響を最小限に抑えるために、事前にR1パケットを作成することが可能となります。 PUZZLEパラメータ内のランダム#Iと不透明なフィールドをゼロにすることは、これらのフィールドは、事前に計算のR1に動的に移入することができます。"
    },
    {
      "indent": 3,
      "text": "Signature calculation and verification follow the process defined in Section 6.4.2.",
      "ja": "署名の計算及び検証は、セクション6.4.2で定義されたプロセスに従います。"
    },
    {
      "indent": 0,
      "text": "5.2.16. SEQ",
      "section_title": true,
      "ja": "5.2.16.  SEQ"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             Type              |             Length            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                            Update ID                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Type 385 Length 4 Update ID 32-bit sequence number",
      "ja": "385長さ4の更新ID 32ビットのシーケンス番号を入力"
    },
    {
      "indent": 3,
      "text": "The Update ID is an unsigned number in network byte order, initialized by a host to zero upon moving to ESTABLISHED state. The Update ID has scope within a single HIP association, and not across multiple associations or multiple hosts. The Update ID is incremented by one before each new UPDATE that is sent by the host; the first UPDATE packet originated by a host has an Update ID of 0.",
      "ja": "更新IDは、確立された状態に移動する際にゼロにホストによって初期化ネットワークバイト順に符号のない数です。更新IDは、単一のHIPアソシエーション内ではなく、複数のアソシエーションまたは複数のホスト間で範囲を有しています。更新IDは、ホストによって送信されたそれぞれの新しいUPDATEの前に1ずつインクリメントされます。ホストによって発信最初のUPDATEパケットは0の更新IDを持っています。"
    },
    {
      "indent": 0,
      "text": "5.2.17. ACK",
      "section_title": true,
      "ja": "5.2.17.  ACK"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             Type              |             Length            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                       peer Update ID 1                        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                       peer Update ID n                        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Type 449 Length length in octets, excluding Type and Length peer Update ID 32-bit sequence number corresponding to the Update ID being ACKed",
      "ja": "ACKさである更新IDに対応するタイプと長ピア更新ID 32ビットのシーケンス番号を除く、オクテット449の長さの長さを入力"
    },
    {
      "indent": 3,
      "text": "The ACK parameter includes one or more Update IDs that have been received from the peer. The number of peer Update IDs can be inferred from the length by dividing it by 4.",
      "ja": "ACKパラメータがピアから受信された1つまたは複数の更新IDを含みます。ピア更新IDの数は、4で割って長さから推測することができます。"
    },
    {
      "indent": 0,
      "text": "5.2.18. ENCRYPTED",
      "section_title": true,
      "ja": "5.2.18.  ENCRYPTED"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             Type              |             Length            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                           Reserved                            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                              IV                               /\n/                                                               /\n/                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               /\n/                        Encrypted data                         /\n/                                                               /\n/                               +-------------------------------+\n/                               |            Padding            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Type 641 Length length in octets, excluding Type, Length, and Padding Reserved zero when sent, ignored when received",
      "ja": "受信時に無視され、送信されたときにゼロを予約型、長さ、およびパディングを除く、オクテット641の長さの長さを入力します"
    },
    {
      "indent": 5,
      "text": "IV Initialization vector, if needed, otherwise nonexistent. The length of the IV is inferred from the HIP_CIPHER. Encrypted The data is encrypted using the encryption algorithm data defined in the HIP_CIPHER parameter.",
      "ja": "IV初期化ベクトル、必要であれば、そうでない場合は存在しません。 IVの長さはHIP_CIPHERから推測されます。暗号化されたデータはHIP_CIPHERパラメータで定義された暗号化アルゴリズムのデータを使用して暗号化されます。"
    },
    {
      "indent": 3,
      "text": "The ENCRYPTED parameter encapsulates other parameters, the encrypted data, which holds one or more HIP parameters in block encrypted form.",
      "ja": "暗号化されたパラメータが他のパラメータ、ブロック暗号化された形態における1つ以上のHIPパラメータを保持している暗号化されたデータを、カプセル化します。"
    },
    {
      "indent": 3,
      "text": "Consequently, the first fields in the encapsulated parameter(s) are Type and Length of the first such parameter, allowing the contents to be easily parsed after decryption.",
      "ja": "従って、カプセル化されたパラメータ（単数または複数）の最初のフィールドは、内容が容易に復号化した後に解析することを可能にする、最初のそのようなパラメータのタイプと長さです。"
    },
    {
      "indent": 3,
      "text": "The field labeled \"Encrypted data\" consists of the output of one or more HIP parameters concatenated together that have been passed through an encryption algorithm. Each of these inner parameters is padded according to the rules of Section 5.2.1 for padding individual parameters. As a result, the concatenated parameters will be a block of data that is 8-byte aligned.",
      "ja": "「暗号化データ」と表示されたフィールドは、暗号化アルゴリズムを通過してきた一緒に連結された1つ以上のHIPパラメータの出力で構成されています。これらの内の各パラメータは、個々のパラメータをパディングするための5.2.1の規則に従ってパディングされます。その結果、連結パラメータは、8バイト境界で整列されているデータのブロックです。"
    },
    {
      "indent": 3,
      "text": "Some encryption algorithms require that the data to be encrypted must be a multiple of the cipher algorithm block size. In this case, the above block of data MUST include additional padding, as specified by the encryption algorithm. The size of the extra padding is selected so that the length of the unencrypted data block is a multiple of the cipher block size. The encryption algorithm may specify padding bytes other than zero; for example, AES [FIPS.197.2001] uses the PKCS5 padding scheme (see Section 6.1.1 of [RFC2898]) where the remaining n bytes to fill the block each have the value of n. This yields an \"unencrypted data\" block that is transformed to an \"encrypted data\" block by the cipher suite. This extra padding added to the set of parameters to satisfy the cipher block alignment rules is not counted in HIP TLV Length fields, and this extra padding should be removed by the cipher suite upon decryption.",
      "ja": "いくつかの暗号化アルゴリズムは、暗号化すべきデータが暗号アルゴリズムのブロックサイズの倍数でなければならないことが必要です。暗号化アルゴリズムで指定され、この場合、データの上記ブロックは、追加のパディングを含まなければなりません。暗号化されていないデータブロックの長さが暗号ブロックサイズの倍数になるように、余分なパディングのサイズが選択されます。暗号化アルゴリズムは、ゼロ以外のパディングバイトを指定してもよいです。例えば、AESは[FIPS.197.2001】残りのnは、それぞれn個の値を有するブロックを埋めるバイトPKCS5パディング方式を（[RFC2898]のセクション6.1.1を参照）を使用します。これは、暗号スイートによって、「暗号化されたデータ」ブロックに変換され、「暗号化されていないデータ」ブロックを生成します。暗号ブロックアライメントルールを満たすためにパラメータのセットに加え、このパディングは、HIP TLVの長さフィールドにカウントされず、この余分なパディングは、復号時に暗号スイートによって除去されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Note that the length of the cipher suite output may be smaller or larger than the length of the set of parameters to be encrypted, since the encryption process may compress the data or add additional padding to the data.",
      "ja": "暗号化処理は、データを圧縮またはデータに追加のパディングを追加することができるので、暗号スイート出力の長さは、暗号化されるパラメータのセットの長さよりも小さくても大きくてもよいことに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "Once this encryption process is completed, the Encrypted data field is ready for inclusion in the parameter. If necessary, additional Padding for 8-byte alignment is then added according to the rules of Section 5.2.1.",
      "ja": "この暗号化プロセスが完了すると、暗号化されたデータ・フィールドは、パラメータに含めるための準備ができています。必要に応じて、8バイトアラインメントのための追加のパディングは、その後、セクション5.2.1の規則に従って追加されます。"
    },
    {
      "indent": 0,
      "text": "5.2.19. NOTIFICATION",
      "section_title": true,
      "ja": "5.2.19. 通知"
    },
    {
      "indent": 3,
      "text": "The NOTIFICATION parameter is used to transmit informational data, such as error conditions and state transitions, to a HIP peer. A NOTIFICATION parameter may appear in NOTIFY packets. The use of the NOTIFICATION parameter in other packet types is for further study.",
      "ja": "通知パラメータは、HIPピアに、そのようなエラー状態と状態遷移などの情報データを送信するために使用されます。通知パラメータは、パケットをNOTIFYで表示されることがあります。他のパケットタイプで通知パラメータを使用することは、今後の検討課題です。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             Type              |             Length            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Reserved             |      Notify Message Type      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               /\n/                   Notification Data                           /\n/                                               +---------------+\n/                                               |     Padding   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Type 832 Length length in octets, excluding Type, Length, and Padding Reserved zero when sent, ignored when received Notify Message specifies the type of notification Type Notification informational or error data transmitted in Data addition to the Notify Message Type. Values for this field are type specific (see below).",
      "ja": "NOTIFYメッセージを受信した通知メッセージタイプのデータに加えて送信された通知タイプ通知情報又はエラーデータの種類を指定した場合に無視タイプ、長さ、及びパディング予約送信ゼロを除く、オクテット単位で832の長さの長さを入力します。このフィールドの値は、型の特定（下記参照）です。"
    },
    {
      "indent": 3,
      "text": "Notification information can be error messages specifying why a HIP Security Association could not be established. It can also be status data that a HIP implementation wishes to communicate with a peer process. The table below lists the notification messages and their Notify Message Types. HIP packets MAY contain multiple NOTIFICATION parameters if several problems exist or several independent pieces of information must be transmitted.",
      "ja": "通知情報は、HIPセキュリティアソシエーションが確立できなかった理由を指定したエラーメッセージすることができます。また、HIPの実装では、ピアプロセスと通信することを望む状況データとすることができます。下の表は、通知メッセージとその通知メッセージタイプを示しています。いくつかの問題が存在する場合HIPパケットは、複数の通知パラメータを含んでいてもよく、あるいは情報のいくつかの独立した部分が送信されなければなりません。"
    },
    {
      "indent": 3,
      "text": "To avoid certain types of attacks, a Responder SHOULD avoid sending a NOTIFICATION to any host with which it has not successfully verified a puzzle solution.",
      "ja": "あるタイプの攻撃を回避するために、レスポンダは、それが正常にパズルの解決策を確認しなかったとの任意のホストに通知を送信することは避けてください。"
    },
    {
      "indent": 3,
      "text": "Notify Message Types in the range 0-16383 are intended for reporting errors, and those in the range 16384-65535 are for other status information. An implementation that receives a NOTIFY packet with a Notify Message Type that indicates an error in response to a request packet (e.g., I1, I2, UPDATE) SHOULD assume that the corresponding request has failed entirely. Unrecognized error types MUST be ignored, except that they SHOULD be logged.",
      "ja": "範囲0から16383でメッセージタイプを通知するには、エラー報告のために意図されており、範囲16384から65535までのものは、他のステータス情報のためのものです。 （例えば、I1、I2、UPDATE）は、対応する要求が完全に失敗したと仮定すべきである要求パケットに応答してエラーを示す通知メッセージタイプとNOTIFYパケットを受信する実装。認識されないエラーの種類は、彼らがログに記録されるべきであることを除いて、無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "As currently defined, Notify Message Type values 1-10 are used for informing about errors in packet structures, and values 11-20 for informing about problems in parameters.",
      "ja": "現在定義されているように、メッセージの種類は1-10がパケット構造のエラーを知らせるために使用される値、およびパラメータの問題について知らせるための11-20値通知。"
    },
    {
      "indent": 3,
      "text": "Notification Data in NOTIFICATION parameters where the Notify Message Type is in the status range MUST be ignored if not recognized.",
      "ja": "認識されない場合は通知メッセージタイプがステータス範囲内にある通知パラメータで通知データを無視しなければなりません。"
    },
    {
      "indent": 5,
      "text": "Notify Message Types - Errors             Value\n-----------------------------             -----",
      "raw": true
    },
    {
      "indent": 5,
      "text": "UNSUPPORTED_CRITICAL_PARAMETER_TYPE 1",
      "ja": "UNSUPPORTED_CRITICAL_PARAMETER_TYPE 1"
    },
    {
      "indent": 7,
      "text": "Sent if the parameter type has the \"critical\" bit set and the parameter type is not recognized. Notification Data contains the two-octet parameter type.",
      "ja": "パラメータタイプは「重要な」ビットがセットされていると、パラメータの種類が認識されない場合に送信されます。通知データは、2オクテットのパラメータの型が含まれています。"
    },
    {
      "indent": 5,
      "text": "INVALID_SYNTAX 7",
      "ja": "INVALID_SYNTAX 7"
    },
    {
      "indent": 7,
      "text": "Indicates that the HIP message received was invalid because some type, length, or value was out of range or because the request was otherwise malformed. To avoid a denial-of-service attack using forged messages, this status may only be returned for packets whose HIP_MAC (if present) and SIGNATURE have been verified. This status MUST be sent in response to any error not covered by one of the other status types and SHOULD NOT contain details, to avoid leaking information to someone probing a node. To aid debugging, more detailed error information SHOULD be written to a console or log.",
      "ja": "いくつかのタイプ、長さ、または値が範囲外か、要求が他の奇形であったためであったため、メッセージが受信HIPが無効であったことを示しています。偽造メッセージを使用してサービス拒否攻撃を回避するために、このステータスは、そのHIP_MAC（存在する場合）と署名検証されたパケットのために返されることがあります。このステータスは、他のステータスタイプの1とノードをプロービング誰かに情報を漏洩しないようするために、詳細を含めるべきではありませんでカバーされていない任意のエラーに対応して送らなければなりません。デバッグを支援するために、より詳細なエラー情報は、コンソールまたはログに書き込む必要があります。"
    },
    {
      "indent": 5,
      "text": "NO_DH_PROPOSAL_CHOSEN 14",
      "ja": "NO_DH_PROPOSAL_CHOSEN 14"
    },
    {
      "indent": 7,
      "text": "None of the proposed Group IDs were acceptable.",
      "ja": "提案されたグループIDのいずれも許容しませんでした。"
    },
    {
      "indent": 5,
      "text": "INVALID_DH_CHOSEN 15",
      "ja": "INVALID_DH_CHOSEN 15"
    },
    {
      "indent": 7,
      "text": "The DH Group ID field does not correspond to one offered by the Responder.",
      "ja": "DHグループIDフィールドは、レスポンダによって提供されるものに対応していません。"
    },
    {
      "indent": 5,
      "text": "NO_HIP_PROPOSAL_CHOSEN 16",
      "ja": "NO_HIP_PROPOSAL_CHOSEN 16"
    },
    {
      "indent": 7,
      "text": "None of the proposed HIT Suites or HIP Encryption Algorithms were acceptable.",
      "ja": "提案HITスイーツやHIP暗号化アルゴリズムのいずれも許容しませんでした。"
    },
    {
      "indent": 5,
      "text": "INVALID_HIP_CIPHER_CHOSEN 17",
      "ja": "INVALID_HIP_CIPHER_CHOSEN 17"
    },
    {
      "indent": 7,
      "text": "The HIP_CIPHER Crypto ID does not correspond to one offered by the Responder.",
      "ja": "HIP_CIPHER暗号IDは、レスポンダによって提供されるものに対応していません。"
    },
    {
      "indent": 5,
      "text": "UNSUPPORTED_HIT_SUITE 20",
      "ja": "UNSUPPORTED_HIT_SUITE 20"
    },
    {
      "indent": 7,
      "text": "Sent in response to an I1 or R1 packet for which the HIT Suite is not supported.",
      "ja": "HIT Suiteは、サポートされていないI1またはR1パケットに応答して送信されます。"
    },
    {
      "indent": 5,
      "text": "AUTHENTICATION_FAILED 24",
      "ja": "AUTHENTICATION_FAILED 24"
    },
    {
      "indent": 7,
      "text": "Sent in response to a HIP signature failure, except when the signature verification fails in a NOTIFY message.",
      "ja": "署名検証は、NOTIFYメッセージに失敗した場合を除き、HIP署名失敗に応答して送信されます。"
    },
    {
      "indent": 5,
      "text": "CHECKSUM_FAILED 26",
      "ja": "CHECKSUM_FAILED 26"
    },
    {
      "indent": 7,
      "text": "Sent in response to a HIP checksum failure.",
      "ja": "HIPのチェックサム障害に応じて送信されます。"
    },
    {
      "indent": 5,
      "text": "HIP_MAC_FAILED 28",
      "ja": "HIP_MAC_FAILED 28"
    },
    {
      "indent": 7,
      "text": "Sent in response to a HIP HMAC failure.",
      "ja": "HIP HMACの障害に応じて送信されます。"
    },
    {
      "indent": 5,
      "text": "ENCRYPTION_FAILED 32",
      "ja": "ENCRYPTION_FAILED 32"
    },
    {
      "indent": 7,
      "text": "The Responder could not successfully decrypt the ENCRYPTED parameter.",
      "ja": "レスポンダが正常にENCRYPTEDパラメータを復号化することができませんでした。"
    },
    {
      "indent": 5,
      "text": "INVALID_HIT 40",
      "ja": "INVALID_HIT 40"
    },
    {
      "indent": 7,
      "text": "Sent in response to a failure to validate the peer's HIT from the corresponding HI.",
      "ja": "対応HIからピアのHITを検証する失敗に応答して送信されます。"
    },
    {
      "indent": 5,
      "text": "BLOCKED_BY_POLICY 42",
      "ja": "BLOCKED_BY_POLICY 42"
    },
    {
      "indent": 7,
      "text": "The Responder is unwilling to set up an association for some policy reason (e.g., the received HIT is NULL and the policy does not allow opportunistic mode).",
      "ja": "レスポンダは、いくつかのポリシーの理由（例えば、受信されたHITがNULLであり、ポリシーが日和見モードを許可しない）のための関連付けを設定することが不本意です。"
    },
    {
      "indent": 5,
      "text": "RESPONDER_BUSY_PLEASE_RETRY 44",
      "ja": "RESPONDER_BUSY_PLEASE_RETRY 44"
    },
    {
      "indent": 7,
      "text": "The Responder is unwilling to set up an association, as it is suffering under some kind of overload and has chosen to shed load by rejecting the Initiator's request. The Initiator may retry; however, the Initiator MUST find another (different) puzzle solution for any such retries. Note that the Initiator may need to obtain a new puzzle with a new I1/R1 exchange.",
      "ja": "Responderは、それが過負荷のいくつかの種類の下で苦しんでいるとイニシエータの要求を拒否することで、負荷を当てることを選択したとして、関連付けを設定したくないです。イニシエータが再試行すること。しかし、開始剤は、任意のそのような再試行のために別の（異なる）パズルの解決策を見つけなければなりません。イニシエータは新しいI1 / R1交換で新しいパズルを取得する必要があるかもしれないことに注意してください。"
    },
    {
      "indent": 5,
      "text": "Notify Message Types - Status            Value\n-----------------------------            -----",
      "raw": true
    },
    {
      "indent": 5,
      "text": "I2_ACKNOWLEDGEMENT 16384",
      "ja": "I2_ACKNOWLEDGEMENT 16384"
    },
    {
      "indent": 7,
      "text": "The Responder has an I2 packet from the Initiator but had to queue the I2 packet for processing. The puzzle was correctly solved, and the Responder is willing to set up an association but currently has a number of I2 packets in the processing queue. The R2 packet is sent after the I2 packet was processed.",
      "ja": "レスポンダは、イニシエータからI2パケットを持っているが、処理のためにI2パケットをキューイングしなければなりませんでした。パズルが正しく解決された、とResponderは関連を設定していく所存ですが、現在処理キュー内I2パケットの数を持っています。 I2パケットが処理された後にR2パケットが送信されます。"
    },
    {
      "indent": 0,
      "text": "5.2.20. ECHO_REQUEST_SIGNED",
      "section_title": true,
      "ja": "5.2.20.  ECHO_REQUEST_SIGNED"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             Type              |             Length            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                 Opaque data (variable length)                 |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Type 897 Length length of the opaque data in octets Opaque data opaque data, supposed to be meaningful only to the node that sends ECHO_REQUEST_SIGNED and receives a corresponding ECHO_RESPONSE_SIGNED or ECHO_RESPONSE_UNSIGNED",
      "ja": "オクテットに不透明なデータの長さ897の長さを入力のみ対応ECHO_RESPONSE_SIGNED又はECHO_RESPONSE_UNSIGNEDをECHO_REQUEST_SIGNEDを送信し、受信ノードに有意義であると考え不透明なデータ不透明なデータ、"
    },
    {
      "indent": 3,
      "text": "The ECHO_REQUEST_SIGNED parameter contains an opaque blob of data that the sender wants to get echoed back in the corresponding reply packet.",
      "ja": "ECHO_REQUEST_SIGNEDパラメータは、送信者が対応する応答パケットにエコーバックを取得したいデータの不透明ブロブが含まれています。"
    },
    {
      "indent": 3,
      "text": "The ECHO_REQUEST_SIGNED and corresponding echo response parameters MAY be used for any purpose where a node wants to carry some state in a request packet and get it back in a response packet. The ECHO_REQUEST_SIGNED is covered by the HIP_MAC and SIGNATURE. A HIP packet can contain only one ECHO_REQUEST_SIGNED parameter and MAY contain multiple ECHO_REQUEST_UNSIGNED parameters. The ECHO_REQUEST_SIGNED parameter MUST be responded to with an ECHO_RESPONSE_SIGNED.",
      "ja": "ECHO_REQUEST_SIGNEDと対応するエコー応答パラメータは、ノードが要求パケットにいくつかの状態を運ぶと応答パケットにそれを取り戻すしたい任意の目的に使用することができます。 ECHO_REQUEST_SIGNEDはHIP_MACとSIGNATUREで覆われています。 HIPパケットが一つだけECHO_REQUEST_SIGNEDのパラメータを含むことができ、複数のECHO_REQUEST_UNSIGNEDのパラメータを含むかもしれません。 ECHO_REQUEST_SIGNEDパラメータはECHO_RESPONSE_SIGNEDで応答しなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.2.21. ECHO_REQUEST_UNSIGNED",
      "section_title": true,
      "ja": "5.2.21.  ECHO_REQUEST_UNSIGNED"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             Type              |             Length            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                 Opaque data (variable length)                 |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Type 63661 Length length of the opaque data in octets Opaque data opaque data, supposed to be meaningful only to the node that sends ECHO_REQUEST_UNSIGNED and receives a corresponding ECHO_RESPONSE_UNSIGNED",
      "ja": "オクテットに不透明なデータの長さ63661の長さを入力のみ対応ECHO_RESPONSE_UNSIGNEDをECHO_REQUEST_UNSIGNEDを送信し、受信ノードに有意義であると考え不透明なデータ不透明なデータ、"
    },
    {
      "indent": 3,
      "text": "The ECHO_REQUEST_UNSIGNED parameter contains an opaque blob of data that the sender wants to get echoed back in the corresponding reply packet.",
      "ja": "ECHO_REQUEST_UNSIGNEDパラメータは、送信者が対応する応答パケットにエコーバックを取得したいデータの不透明ブロブが含まれています。"
    },
    {
      "indent": 3,
      "text": "The ECHO_REQUEST_UNSIGNED and corresponding echo response parameters MAY be used for any purpose where a node wants to carry some state in a request packet and get it back in a response packet. The ECHO_REQUEST_UNSIGNED is not covered by the HIP_MAC and SIGNATURE. A HIP packet can contain one or more ECHO_REQUEST_UNSIGNED parameters. It is possible that middleboxes add ECHO_REQUEST_UNSIGNED parameters in HIP packets passing by. The creator of the ECHO_REQUEST_UNSIGNED (end host or middlebox) has to create the Opaque field so that it can later identify and remove the corresponding ECHO_RESPONSE_UNSIGNED parameter.",
      "ja": "ECHO_REQUEST_UNSIGNEDと対応するエコー応答パラメータは、ノードが要求パケットにいくつかの状態を運ぶと応答パケットにそれを取り戻すしたい任意の目的に使用することができます。 ECHO_REQUEST_UNSIGNEDはHIP_MACとSIGNATUREによってカバーされていません。 HIPパケットは、一つ以上のECHO_REQUEST_UNSIGNEDパラメータを含めることができます。ミドルボックスが通り過ぎるHIPパケットでECHO_REQUEST_UNSIGNEDパラメータを追加することも可能です。 ECHO_REQUEST_UNSIGNED（エンドホストまたはミドル）の作成者は、後で対応ECHO_RESPONSE_UNSIGNEDパラメータを識別して除去することができるように、不透明なフィールドを作成しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The ECHO_REQUEST_UNSIGNED parameter MUST be responded to with an ECHO_RESPONSE_UNSIGNED parameter.",
      "ja": "ECHO_REQUEST_UNSIGNEDパラメータはECHO_RESPONSE_UNSIGNEDパラメータで応答しなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.2.22. ECHO_RESPONSE_SIGNED",
      "section_title": true,
      "ja": "5.2.22.  ECHO_RESPONSE_SIGNED"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             Type              |             Length            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                 Opaque data (variable length)                 |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Type 961 Length length of the opaque data in octets Opaque data opaque data, copied unmodified from the ECHO_REQUEST_SIGNED or ECHO_REQUEST_UNSIGNED parameter that triggered this response",
      "ja": "不透明なデータオクテットでこのレスポンスをトリガーECHO_REQUEST_SIGNEDまたはECHO_REQUEST_UNSIGNEDパラメータから修飾されていないコピーされた不透明なデータを、不透明なデータの長さ961長さを入力"
    },
    {
      "indent": 3,
      "text": "The ECHO_RESPONSE_SIGNED parameter contains an opaque blob of data that the sender of the ECHO_REQUEST_SIGNED wants to get echoed back. The opaque data is copied unmodified from the ECHO_REQUEST_SIGNED parameter.",
      "ja": "ECHO_RESPONSE_SIGNEDパラメータはECHO_REQUEST_SIGNEDの送信者がエコーバック取得したいデータの不透明ブロブが含まれています。不透明なデータはECHO_REQUEST_SIGNEDパラメータから修飾されていないコピーされます。"
    },
    {
      "indent": 3,
      "text": "The ECHO_REQUEST_SIGNED and ECHO_RESPONSE_SIGNED parameters MAY be used for any purpose where a node wants to carry some state in a request packet and get it back in a response packet. The ECHO_RESPONSE_SIGNED is covered by the HIP_MAC and SIGNATURE.",
      "ja": "ECHO_REQUEST_SIGNEDとECHO_RESPONSE_SIGNEDパラメータは、ノードが要求パケットにいくつかの状態を運ぶと応答パケットにそれを取り戻すしたい任意の目的に使用することができます。 ECHO_RESPONSE_SIGNEDはHIP_MACとSIGNATUREで覆われています。"
    },
    {
      "indent": 0,
      "text": "5.2.23. ECHO_RESPONSE_UNSIGNED",
      "section_title": true,
      "ja": "5.2.23.  ECHO_RESPONSE_UNSIGNED"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             Type              |             Length            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                 Opaque data (variable length)                 |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Type 63425 Length length of the opaque data in octets Opaque data opaque data, copied unmodified from the ECHO_REQUEST_SIGNED or ECHO_REQUEST_UNSIGNED parameter that triggered this response",
      "ja": "不透明なデータオクテットでこのレスポンスをトリガーECHO_REQUEST_SIGNEDまたはECHO_REQUEST_UNSIGNEDパラメータから修飾されていないコピーされた不透明なデータを、不透明なデータの長さ63425の長さを入力"
    },
    {
      "indent": 3,
      "text": "The ECHO_RESPONSE_UNSIGNED parameter contains an opaque blob of data that the sender of the ECHO_REQUEST_SIGNED or ECHO_REQUEST_UNSIGNED wants to get echoed back. The opaque data is copied unmodified from the corresponding echo request parameter.",
      "ja": "ECHO_RESPONSE_UNSIGNEDパラメータはECHO_REQUEST_SIGNEDまたはECHO_REQUEST_UNSIGNEDの送信者がエコーバック取得したいデータの不透明ブロブが含まれています。不透明なデータは、対応するエコー要求パラメータから修飾されていないコピーされます。"
    },
    {
      "indent": 3,
      "text": "The echo request and ECHO_RESPONSE_UNSIGNED parameters MAY be used for any purpose where a node wants to carry some state in a request packet and get it back in a response packet. The ECHO_RESPONSE_UNSIGNED is not covered by the HIP_MAC and SIGNATURE.",
      "ja": "エコー要求とECHO_RESPONSE_UNSIGNEDパラメータは、ノードが要求パケットにいくつかの状態を運ぶと応答パケットにそれを取り戻すしたい任意の目的に使用することができます。 ECHO_RESPONSE_UNSIGNEDはHIP_MACとSIGNATUREによってカバーされていません。"
    },
    {
      "indent": 0,
      "text": "5.3. HIP Packets",
      "section_title": true,
      "ja": "5.3.  HIPのパケット"
    },
    {
      "indent": 3,
      "text": "There are eight basic HIP packets (see Table 11). Four are for the HIP base exchange, one is for updating, one is for sending notifications, and two are for closing a HIP association. Support for the NOTIFY packet type is optional, but support for all other HIP packet types listed below is mandatory.",
      "ja": "8つの基本的なHIPパケットは、（表11を参照）があります。四つは、HIP基本交換のためである1つは、1つの通知を送信するためのものであり、更新のためであり、2つのHIPアソシエーションを閉鎖するためのものです。 NOTIFYパケットタイプのサポートはオプションであるが、以下に挙げる他のすべてのHIPパケットタイプのためのサポートが必須です。"
    },
    {
      "indent": 3,
      "text": "+------------------+------------------------------------------------+\n|   Packet type    | Packet name                                    |\n+------------------+------------------------------------------------+\n|        1         | I1 - the HIP Initiator Packet                  |\n|                  |                                                |\n|        2         | R1 - the HIP Responder Packet                  |\n|                  |                                                |\n|        3         | I2 - the Second HIP Initiator Packet           |\n|                  |                                                |\n|        4         | R2 - the Second HIP Responder Packet           |\n|                  |                                                |\n|        16        | UPDATE - the HIP Update Packet                 |\n|                  |                                                |\n|        17        | NOTIFY - the HIP Notify Packet                 |\n|                  |                                                |\n|        18        | CLOSE - the HIP Association Closing Packet     |\n|                  |                                                |\n|        19        | CLOSE_ACK - the HIP Closing Acknowledgment     |\n|                  | Packet                                         |\n+------------------+------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 15,
      "text": "Table 11: HIP Packets and Packet Type Values",
      "ja": "表11：HIPパケットとパケットタイプ値"
    },
    {
      "indent": 3,
      "text": "Packets consist of the fixed header as described in Section 5.1, followed by the parameters. The parameter part, in turn, consists of zero or more TLV-coded parameters.",
      "ja": "パラメータが続くセクション5.1に記載のパケットは、固定ヘッダから成ります。パラメータの一部は、今度は、ゼロまたはそれ以上のTLV符号化されたパラメータで構成されています。"
    },
    {
      "indent": 3,
      "text": "In addition to the base packets, other packet types may be defined later in separate specifications. For example, support for mobility and multihoming is not included in this specification.",
      "ja": "ベース・パケットに加えて、他のパケットタイプは、後で別の仕様で定義されてもよいです。例えば、移動性とマルチホーミングのサポートは、この仕様には含まれていません。"
    },
    {
      "indent": 3,
      "text": "See \"Notation\" (Section 2.2) for the notation used in the operations.",
      "ja": "操作において使用される表記法は、「表記」（セクション2.2）を参照してください。"
    },
    {
      "indent": 3,
      "text": "In the future, an optional upper-layer payload MAY follow the HIP header. The Next Header field in the header indicates if there is additional data following the HIP header. The HIP packet, however, MUST NOT be fragmented into multiple extension headers by setting the Next Header field in a HIP header to the HIP protocol number. This limits the size of the possible additional data in the packet.",
      "ja": "将来的には、任意上層ペイロードはHIPヘッダに従うことができます。 HIPヘッダ以下の追加データがある場合、ヘッダーのNext Headerフィールドを示します。 HIPパケットは、しかしながら、HIPプロトコル番号にHIPヘッダに次ヘッダフィールドを設定することによって、複数の拡張ヘッダに断片化してはいけません。これは、パケット内の可能な追加データのサイズを制限します。"
    },
    {
      "indent": 0,
      "text": "5.3.1. I1 - the HIP Initiator Packet",
      "section_title": true,
      "ja": "5.3.1.  I1  -  HIPイニシエータパケット"
    },
    {
      "indent": 3,
      "text": "The HIP header values for the I1 packet:",
      "ja": "I1パケットのHIPヘッダー値："
    },
    {
      "indent": 5,
      "text": "Header: Packet Type = 1 SRC HIT = Initiator's HIT DST HIT = Responder's HIT, or NULL",
      "ja": "ヘッダー：パケットタイプ= 1つのSRCのHIT =イニシエータのHIT DSTのHIT =レスポンダのHIT、またはNULL"
    },
    {
      "indent": 5,
      "text": "IP ( HIP ( DH_GROUP_LIST ) )",
      "ja": "IP（HIP（DH_GROUP_LIST））"
    },
    {
      "indent": 3,
      "text": "The I1 packet contains the fixed HIP header and the Initiator's DH_GROUP_LIST.",
      "ja": "I1パケットは、固定されたHIPヘッダとイニシエータのDH_GROUP_LISTを含有します。"
    },
    {
      "indent": 3,
      "text": "Valid control bits: None",
      "ja": "有効な制御ビット：なし"
    },
    {
      "indent": 3,
      "text": "The Initiator receives the Responder's HIT from either a DNS lookup of the Responder's FQDN (see [HIP-DNS-EXT]), some other repository, or a local table. If the Initiator does not know the Responder's HIT, it may attempt to use opportunistic mode by using NULL (all zeros) as the Responder's HIT. See also \"HIP Opportunistic Mode\" (Section 4.1.8).",
      "ja": "イニシエータはレスポンダのFQDNのDNSルックアップ（[HIP-DNS-EXT]を参照）、いくつかの他のリポジトリ、またはローカルテーブルのいずれかからレスポンダのHITを受信します。イニシエータは、レスポンダのHITがわからない場合は、レスポンダのHITとしてNULL（すべてゼロ）を使用して日和見モードを使用することを試みることができます。また、「HIP日和見モード」（セクション4.1.8）を参照してください。"
    },
    {
      "indent": 3,
      "text": "Since the I1 packet is so easy to spoof even if it were signed, no attempt is made to add to its generation or processing cost.",
      "ja": "I1パケットは、それが締結された場合でも、偽装するのは簡単ですので、何の試みは、その生成や処理コストに追加する行われません。"
    },
    {
      "indent": 3,
      "text": "The Initiator includes a DH_GROUP_LIST parameter in the I1 packet to inform the Responder of its preferred DH Group IDs. Note that the DH_GROUP_LIST in the I1 packet is not protected by a signature.",
      "ja": "イニシエータは、その好適なDHグループIDのレスポンダを知らせるためにI1パケット内のDH_GROUP_LISTパラメータを含んでいます。 I1パケット内DH_GROUP_LISTが署名によって保護されていないことに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "Implementations MUST be able to handle a storm of received I1 packets, discarding those with common content that arrive within a small time delta.",
      "ja": "実装は、短い時間内に到着デルタ共通のコンテンツを有するものを廃棄、受信I1パケットの嵐を扱うことができなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.3.2. R1 - the HIP Responder Packet",
      "section_title": true,
      "ja": "5.3.2.  R1  - パケットレスポンダHIP"
    },
    {
      "indent": 3,
      "text": "The HIP header values for the R1 packet:",
      "ja": "R1パケットのHIPヘッダー値："
    },
    {
      "indent": 5,
      "text": "Header: Packet Type = 2 SRC HIT = Responder's HIT DST HIT = Initiator's HIT",
      "ja": "ヘッダー：パケットタイプ= 2 SRCのHIT =レスポンダのHIT DSTのHIT =イニシエータのHIT"
    },
    {
      "indent": 5,
      "text": "IP ( HIP ( [ R1_COUNTER, ] PUZZLE, DIFFIE_HELLMAN, HIP_CIPHER, HOST_ID, HIT_SUITE_LIST, DH_GROUP_LIST, [ ECHO_REQUEST_SIGNED, ] TRANSPORT_FORMAT_LIST, HIP_SIGNATURE_2 ) <, ECHO_REQUEST_UNSIGNED >i)",
      "ja": "IP（HIP（[R1_COUNTER、】パズルDIFFIE_HELLMAN、HIP_CIPHER、HOST_ID、HIT_SUITE_LIST、DH_GROUP_LIST、[ECHO_REQUEST_SIGNED、】TRANSPORT_FORMAT_LIST、HIP_SIGNATURE_2）<、ECHO_REQUEST_UNSIGNED> I）"
    },
    {
      "indent": 3,
      "text": "Valid control bits: A",
      "ja": "有効な制御ビット：A"
    },
    {
      "indent": 3,
      "text": "If the Responder's HI is an anonymous one, the A control MUST be set.",
      "ja": "レスポンダのHIは匿名のものであれば、Aの制御を設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The Initiator's HIT MUST match the one received in the I1 packet if the R1 is a response to an I1. If the Responder has multiple HIs, the Responder's HIT used MUST match the Initiator's request. If the Initiator used opportunistic mode, the Responder may select freely among its HIs. See also \"HIP Opportunistic Mode\" (Section 4.1.8).",
      "ja": "R1は、I1への応答であればイニシエータのHITは、I1パケットで受信したものと一致しなければなりません。 Responderが彼の複数を持っている場合は、使用レスポンダのHITは、イニシエータの要求に合致しなければなりません。イニシエータは日和見モードを使用した場合、Responderはその彼の間で自由に選択することができます。また、「HIP日和見モード」（セクション4.1.8）を参照してください。"
    },
    {
      "indent": 3,
      "text": "The R1 packet generation counter is used to determine the currently valid generation of puzzles. The value is increased periodically, and it is RECOMMENDED that it is increased at least as often as solutions to old puzzles are no longer accepted.",
      "ja": "R1パケット生成カウンタは、パズルの現在有効な世代を決定するために使用されます。値が定期的に増加し、少なくともとして頻繁に古いパズルの解決は、もはや受け入れられているように増加することが推奨されます。"
    },
    {
      "indent": 3,
      "text": "The puzzle contains a Random #I and the difficulty #K. The difficulty #K indicates the number of lower-order bits, in the puzzle hash result, that must be zeros; see Section 4.1.2. The Random #I is not covered by the signature and must be zeroed during the signature calculation, allowing the sender to select and set the #I into a precomputed R1 packet just prior to sending it to the peer.",
      "ja": "パズルはランダム#Iと難易＃Kが含まれています。難易度#Kはゼロでなければならないパズルハッシュ結果に、下位ビットの数を示します。 4.1.2項を参照してください。ランダム#Iは、署名で覆われていないと、送信者が直前にピアに送信する事前に計算R1パケットに#Iを選択して設定することができ、署名計算時にゼロにする必要があります。"
    },
    {
      "indent": 3,
      "text": "The Responder selects the DIFFIE_HELLMAN Group ID and Public Value based on the Initiator's preference expressed in the DH_GROUP_LIST parameter in the I1 packet. The Responder sends back its own preference based on which it chose the DH public value as",
      "ja": "レスポンダは、イニシエータの好みに基づいてDIFFIE_HELLMANグループIDと公開値を選択I1パケットにDH_GROUP_LISTパラメータで表現。 ResponderはそれのようにDH公開値を選択したかに基づいて、自身の好みを送り返します"
    },
    {
      "indent": 3,
      "text": "DH_GROUP_LIST. This allows the Initiator to determine whether its own DH_GROUP_LIST in the sent I1 packet was manipulated by an attacker.",
      "ja": "DH_GROUP_LIST。これは、イニシエータが送信I1パケットに独自DH_GROUP_LISTが攻撃者によって操作されたかどうかを決定することを可能にします。"
    },
    {
      "indent": 3,
      "text": "The Diffie-Hellman public value is ephemeral, and values SHOULD NOT be reused across different HIP associations. Once the Responder has received a valid response to an R1 packet, that Diffie-Hellman value SHOULD be deprecated. It is possible that the Responder has sent the same Diffie-Hellman value to different hosts simultaneously in corresponding R1 packets, and those responses should also be accepted. However, as a defense against I1 packet storms, an implementation MAY propose, and reuse unless avoidable, the same Diffie-Hellman value for a period of time -- for example, 15 minutes. By using a small number of different puzzles for a given Diffie-Hellman value, the R1 packets can be precomputed and delivered as quickly as I1 packets arrive. A scavenger process should clean up unused Diffie-Hellman values and puzzles.",
      "ja": "Diffie-Hellman公開値は短命で、値が異なるHIP団体で再利用されるべきではありません。レスポンダ一度のDiffie-Hellman値は推奨されるべきであること、R1パケットに有効な応答を受信しました。 Responderが同時にR1パケットを対応する異なるホストに同一のDiffie-Hellman値を送信し、それらの応答も受け入れられるべきであることが可能です。しかし、I1パケットストームに対する防御として、実装が提案することができる、及び時間の期間回避、同一のDiffie-Hellman値ない限り再利用する - 例えば、15分。所与のDiffie-Hellman値に対して異なるパズルの小さな数を使用することにより、R1パケットが早くI1パケットが到着するように事前計算して配信することができます。スカベンジャープロセスは、未使用のDiffie-Hellman値とパズルをクリーンアップする必要があります。"
    },
    {
      "indent": 3,
      "text": "Reusing Diffie-Hellman public values opens up the potential security risk of more than one Initiator ending up with the same keying material (due to faulty random number generators). Also, more than one Initiator using the same Responder public key half may lead to potentially easier cryptographic attacks and to imperfect forward security.",
      "ja": "Diffie-Hellman公開値を再利用する（不良による乱数ジェネレータに）同じ鍵素材で終わる複数のイニシエータの潜在的なセキュリティリスクを開きます。また、同じレスポンダの公開鍵の半分を使用して複数のイニシエータは、潜在的に簡単に暗号攻撃につながる可能性と前方セキュリティを不完全なために。"
    },
    {
      "indent": 3,
      "text": "However, these risks involved in reusing the same public value are statistical; that is, the authors are not aware of any mechanism that would allow manipulation of the protocol so that the risk of the reuse of any given Responder Diffie-Hellman public key would differ from the base probability. Consequently, it is RECOMMENDED that Responders avoid reusing the same DH key with multiple Initiators, but because the risk is considered statistical and not known to be manipulable, the implementations MAY reuse a key in order to ease resource-constrained implementations and to increase the probability of successful communication with legitimate clients even under an I1 packet storm. In particular, when it is too expensive to generate enough precomputed R1 packets to supply each potential Initiator with a different DH key, the Responder MAY send the same DH key to several Initiators, thereby creating the possibility of multiple legitimate Initiators ending up using the same Responder-side public key. However, as soon as the Responder knows that it will use a particular DH key, it SHOULD stop offering it. This design is aimed to allow resource-constrained Responders to offer services under I1 packet storms and to simultaneously make the probability of DH key reuse both statistical and as low as possible.",
      "ja": "しかし、同じ公共の価値を再利用に関与し、これらのリスクは統計的です。つまり、著者は、任意のレスポンダのDiffie-Hellman公開鍵の再利用のリスクは基本確率異なるなるようにプロトコルの操作を可能にする任意のメカニズムを認識していません。したがって、レスポンダが複数のイニシエータと同じDHキーを再利用しないよう、しかし、リスクが操作可能であることが知られた統計とみなされていないので、実装は、リソースに制約の実装を容易にするためにキーを再利用するかもしれなくて、確率を高めることが推奨されますでも、I1パケットストームの下で正当なクライアントとの正常な通信の。それは異なるDHキーでそれぞれの潜在的開始剤を供給するのに十分な予め計算R1パケットを生成するために非常に高価である場合、特に、レスポンダは、それによってそれを用い終わる複数の正当な開始剤の可能性を作成し、いくつかのイニシエータに同じDH鍵を送信することができますレスポンダ側の公開鍵。しかし、できるだけ早くResponderが、それは特定のDHキーを使用することを知っているように、それはそれを提供して停止する必要があります。この設計は、リソースに制約のあるレスポンダがI1パケットストームの下でサービスを提供すると同時に、統計と可能な限り低く、両方のDHキーの再利用の可能性を作ることができるように目指しています。"
    },
    {
      "indent": 3,
      "text": "If the Responder uses the same DH key pair for multiple handshakes, it must take care to avoid small subgroup attacks [RFC2785]. To avoid these attacks, when receiving the I2 message, the Responder SHOULD validate the Initiator's DH public key as described in [RFC2785], Section 3.1. If the validation fails, the Responder MUST NOT generate a DH shared key and MUST silently abort the HIP BEX.",
      "ja": "Responderが複数の握手のために同じDH鍵ペアを使用している場合、それは小さなサブグループ攻撃[RFC2785]を避けるように注意する必要があります。 I2メッセージを受信したときに、[RFC2785]で説明したように、これらの攻撃を回避するために、Responderは、3.1節をイニシエータのDH公開鍵を検証する必要があります。検証が失敗した場合、ResponderはDH鍵共有生成してはならないと黙っHIP BEXを中止しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The HIP_CIPHER parameter contains the encryption algorithms supported by the Responder to encrypt the contents of the ENCRYPTED parameter, in the order of preference. All implementations MUST support AES [RFC3602].",
      "ja": "HIP_CIPHERパラメータは、優先順位では、暗号化されたパラメータの内容を暗号化するためにレスポンダによってサポートされている暗号化アルゴリズムが含まれています。すべての実装はAES [RFC3602]をサポートしなければなりません。"
    },
    {
      "indent": 3,
      "text": "The HIT_SUITE_LIST parameter is an ordered list of the Responder's preferred and supported HIT Suites. The list allows the Initiator to determine whether its own source HIT matches any suite supported by the Responder.",
      "ja": "HIT_SUITE_LISTパラメータは、レスポンダの優先およびサポートHITスイーツの順序付きリストです。リストには、イニシエータは、自身のソースHITは、レスポンダでサポートされている任意のスイートと一致するかどうかを決定することができます。"
    },
    {
      "indent": 3,
      "text": "The ECHO_REQUEST_SIGNED and ECHO_REQUEST_UNSIGNED parameters contain data that the sender wants to receive unmodified in the corresponding response packet in the ECHO_RESPONSE_SIGNED or ECHO_RESPONSE_UNSIGNED parameter. The R1 packet may contain zero or more ECHO_REQUEST_UNSIGNED parameters as described in Section 5.2.21.",
      "ja": "ECHO_REQUEST_SIGNEDとECHO_REQUEST_UNSIGNEDパラメータは、送信者がECHO_RESPONSE_SIGNEDまたはECHO_RESPONSE_UNSIGNEDパラメータに対応する応答パケットにそのまま受信したいというデータが含まれています。 R1パケットは、セクション5.2.21に記載されているように、ゼロ以上ECHO_REQUEST_UNSIGNEDパラメータを含んでいてもよいです。"
    },
    {
      "indent": 3,
      "text": "The TRANSPORT_FORMAT_LIST parameter is an ordered list of the Responder's preferred and supported transport format types. The list allows the Initiator and the Responder to agree on a common type for payload protection. This parameter is described in Section 5.2.11.",
      "ja": "TRANSPORT_FORMAT_LISTパラメータは、レスポンダの優先およびサポートされているトランスポート・フォーマット・タイプの順序付きリストです。リストには、イニシエータとレスポンダは、ペイロードの保護のための一般的なタイプに同意することができます。このパラメータは、セクション5.2.11に記載されています。"
    },
    {
      "indent": 3,
      "text": "The signature is calculated over the whole HIP packet as described in Section 5.2.15. This allows the Responder to use precomputed R1s. The Initiator SHOULD validate this signature. It MUST check that the Responder's HI matches with the one expected, if any.",
      "ja": "セクション5.2.15に記載されるように署名全体HIPパケットにわたって計算されます。これは、Responderが事前に計算のR1を使用することができます。イニシエータは、この署名を検証する必要があります。これは、レスポンダのHIがあれば、期待されるものと一致していることをチェックしなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.3.3. I2 - the Second HIP Initiator Packet",
      "section_title": true,
      "ja": "5.3.3.  I2  - セカンドHIPイニシエータパケット"
    },
    {
      "indent": 3,
      "text": "The HIP header values for the I2 packet:",
      "ja": "I2パケットのHIPヘッダー値："
    },
    {
      "indent": 5,
      "text": "Header: Packet Type = 3 SRC HIT = Initiator's HIT DST HIT = Responder's HIT",
      "ja": "ヘッダー：パケットタイプ= 3 SRCのHIT =イニシエータのHIT DSTのHIT =レスポンダのHIT"
    },
    {
      "indent": 5,
      "text": "IP ( HIP ( [R1_COUNTER,] SOLUTION, DIFFIE_HELLMAN, HIP_CIPHER, ENCRYPTED { HOST_ID } or HOST_ID, [ ECHO_RESPONSE_SIGNED, ] TRANSPORT_FORMAT_LIST, HIP_MAC, HIP_SIGNATURE <, ECHO_RESPONSE_UNSIGNED>i ) )",
      "ja": "IP（HIP（[R1_COUNTER、】溶液DIFFIE_HELLMAN、HIP_CIPHER、ENCRYPTED {HOST_ID}又はHOST_ID、[ECHO_RESPONSE_SIGNED、】TRANSPORT_FORMAT_LIST、HIP_MAC、HIP_SIGNATURE <、ECHO_RESPONSE_UNSIGNED> i））を"
    },
    {
      "indent": 3,
      "text": "Valid control bits: A",
      "ja": "有効な制御ビット：A"
    },
    {
      "indent": 3,
      "text": "The HITs used MUST match the ones used in the R1.",
      "ja": "使用ヒットはR1で使用されるものと一致しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the Initiator's HI is an anonymous one, the A control bit MUST be set.",
      "ja": "イニシエータのHIは匿名のものであれば、A制御ビットを設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If present in the I1 packet, the Initiator MUST include an unmodified copy of the R1_COUNTER parameter received in the corresponding R1 packet into the I2 packet.",
      "ja": "I1パケット内に存在する場合、イニシエータはI2パケットに対応するR1パケットで受信R1_COUNTERパラメータの非修飾コピーを含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "The Solution contains the Random #I from R1 and the computed #J. The low-order #K bits of the RHASH( #I | ... | #J ) MUST be zero.",
      "ja": "ソリューションは、R1からランダム#Iと計算#Jが含まれています。 RHASH（| ... | #I #J）の下位＃Kビットはゼロでなければなりません。"
    },
    {
      "indent": 3,
      "text": "The Diffie-Hellman value is ephemeral. If precomputed, a scavenger process should clean up unused Diffie-Hellman values. The Responder MAY reuse Diffie-Hellman values under some conditions as specified in Section 5.3.2.",
      "ja": "Diffie-Hellman値は短命です。事前に計算した場合、スカベンジャープロセスは、未使用のDiffie-Hellman値をクリーンアップする必要があります。 5.3.2項で指定されたResponderはいくつかの条件の下でのDiffie-Hellman値を再利用することができます。"
    },
    {
      "indent": 3,
      "text": "The HIP_CIPHER contains the single encryption suite selected by the Initiator, that it uses to encrypt the ENCRYPTED parameters. The chosen cipher MUST correspond to one of the ciphers offered by the Responder in the R1. All implementations MUST support AES [RFC3602].",
      "ja": "HIP_CIPHERは、それが暗号化されたパラメータを暗号化するために使用する、イニシエータによって選択された単一の暗号スイートが含まれています。選択された暗号はR1にレスポンダが提供する暗号化方式の1つに対応しなければなりません。すべての実装はAES [RFC3602]をサポートしなければなりません。"
    },
    {
      "indent": 3,
      "text": "The Initiator's HI MAY be encrypted using the HIP_CIPHER encryption algorithm. The keying material is derived from the Diffie-Hellman exchange as defined in Section 6.5.",
      "ja": "イニシエータのHIはHIP_CIPHER暗号化アルゴリズムを用いて暗号化することができます。セクション6.5で定義されるように鍵材料は、ディフィー - ヘルマン交換に由来します。"
    },
    {
      "indent": 3,
      "text": "The ECHO_RESPONSE_SIGNED and ECHO_RESPONSE_UNSIGNED contain the unmodified opaque data copied from the corresponding echo request parameter(s).",
      "ja": "ECHO_RESPONSE_SIGNEDとECHO_RESPONSE_UNSIGNEDは、対応するエコー要求パラメータ（単数または複数）からコピーされた修飾されていない不透明なデータを含みます。"
    },
    {
      "indent": 3,
      "text": "The TRANSPORT_FORMAT_LIST contains the single transport format type selected by the Initiator. The chosen type MUST correspond to one of the types offered by the Responder in the R1. Currently, the only transport format defined is the ESP transport format ([RFC7402]).",
      "ja": "TRANSPORT_FORMAT_LISTがイニシエータによって選択された単一のトランスポート・フォーマット・タイプを含みます。選択されたタイプはR1におけるレスポンダによって提供されるタイプの1つに対応しなければなりません。現在、定義された唯一のトランスポート・フォーマットは、ESPのトランスポートフォーマット（[RFC7402]）です。"
    },
    {
      "indent": 3,
      "text": "The HMAC value in the HIP_MAC parameter is calculated over the whole HIP packet, excluding any parameters after the HIP_MAC, as described in Section 6.4.1. The Responder MUST validate the HIP_MAC.",
      "ja": "セクション6.4.1に記載したようにHIP_MACパラメータのHMAC値は、HIP_MAC後の任意のパラメータを除く、全HIPパケットにわたって計算されます。 ResponderはHIP_MACを検証する必要があります。"
    },
    {
      "indent": 3,
      "text": "The signature is calculated over the whole HIP packet, excluding any parameters after the HIP_SIGNATURE, as described in Section 5.2.14. The Responder MUST validate this signature. The Responder uses the HI in the packet or an HI acquired by some other means for verifying the signature.",
      "ja": "セクション5.2.14に記載されているように署名は、HIP_SIGNATURE後の任意のパラメータを除く、全HIPパケットにわたって計算されます。 Responderは、この署名を検証する必要があります。レスポンダは、署名を検証するための他の手段により取得されたパケットまたはHIでHIを使用します。"
    },
    {
      "indent": 0,
      "text": "5.3.4. R2 - the Second HIP Responder Packet",
      "section_title": true,
      "ja": "5.3.4.  R2  - パケットレスポンダセカンドHIP"
    },
    {
      "indent": 3,
      "text": "The HIP header values for the R2 packet:",
      "ja": "R2パケットのHIPヘッダー値："
    },
    {
      "indent": 5,
      "text": "Header: Packet Type = 4 SRC HIT = Responder's HIT DST HIT = Initiator's HIT",
      "ja": "ヘッダー：パケットタイプ= 4 SRCのHIT =レスポンダのHIT DSTのHIT =イニシエータのHIT"
    },
    {
      "indent": 5,
      "text": "IP ( HIP ( HIP_MAC_2, HIP_SIGNATURE ) )",
      "ja": "IP（HIP（HIP_MAC_2、HIP_SIGNATURE））"
    },
    {
      "indent": 3,
      "text": "Valid control bits: None",
      "ja": "有効な制御ビット：なし"
    },
    {
      "indent": 3,
      "text": "The HIP_MAC_2 is calculated over the whole HIP packet, with the Responder's HOST_ID parameter concatenated with the HIP packet. The HOST_ID parameter is removed after the HMAC calculation. The procedure is described in Section 6.4.1.",
      "ja": "HIP_MAC_2はHIPパケットと連結レスポンダのHOST_IDパラメータで、全体のHIPパケットに対して計算されます。 HOST_IDパラメータは、HMAC計算後に除去されます。手順は、6.4.1項で説明されています。"
    },
    {
      "indent": 3,
      "text": "The signature is calculated over the whole HIP packet.",
      "ja": "署名は全体HIPパケットにわたって計算されます。"
    },
    {
      "indent": 3,
      "text": "The Initiator MUST validate both the HIP_MAC and the signature.",
      "ja": "イニシエータはHIP_MACと署名の両方を検証しなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.3.5. UPDATE - the HIP Update Packet",
      "section_title": true,
      "ja": "5.3.5.  UPDATE  -  HIPアップデートパケット"
    },
    {
      "indent": 3,
      "text": "The HIP header values for the UPDATE packet:",
      "ja": "UPDATEパケットのHIPヘッダー値："
    },
    {
      "indent": 5,
      "text": "Header: Packet Type = 16 SRC HIT = Sender's HIT DST HIT = Recipient's HIT",
      "ja": "ヘッダー：パケットタイプ= 16 SRCのHIT =送信者のHIT DSTのHIT =受信者のHIT"
    },
    {
      "indent": 5,
      "text": "IP ( HIP ( [SEQ, ACK, ] HIP_MAC, HIP_SIGNATURE ) )",
      "ja": "IP（HIP（[配列、ACK、】HIP_MAC、HIP_SIGNATURE））"
    },
    {
      "indent": 3,
      "text": "Valid control bits: None",
      "ja": "有効な制御ビット：なし"
    },
    {
      "indent": 3,
      "text": "The UPDATE packet contains mandatory HIP_MAC and HIP_SIGNATURE parameters, and other optional parameters.",
      "ja": "UPDATEパケットは必須HIP_MACとHIP_SIGNATUREパラメータ、および他の任意のパラメータが含まれています。"
    },
    {
      "indent": 3,
      "text": "The UPDATE packet contains zero or one SEQ parameter. The presence of a SEQ parameter indicates that the receiver MUST acknowledge the UPDATE. An UPDATE that does not contain a SEQ but only an ACK parameter is simply an acknowledgment of a previous UPDATE and itself MUST NOT be acknowledged by a separate ACK parameter. Such UPDATE packets containing only an ACK parameter do not require processing in relative order to other UPDATE packets. An UPDATE packet without either a SEQ or an ACK parameter is invalid; such unacknowledged updates MUST instead use a NOTIFY packet.",
      "ja": "UPDATEパケットは、ゼロまたは1 SEQパラメータが含まれています。 SEQパラメータの存在は、受信機が更新を確認しなければならないことを示しています。 SEQだけACKパラメータが含まれていないUPDATEは、単に前回の更新の確認であり、それ自体が独立したACKパラメータで認めてはなりません。のみACKパラメータを含むようアップデートパケットは、他のアップデートパケットに対して順序で処理を必要としません。 SEQまたはACKのパラメータのいずれかのないUPDATEパケットは無効です。このよう未確認の更新ではなく、NOTIFYパケットを使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "An UPDATE packet contains zero or one ACK parameter. The ACK parameter echoes the SEQ sequence number of the UPDATE packet being ACKed. A host MAY choose to acknowledge more than one UPDATE packet at a time; e.g., the ACK parameter may contain the last two SEQ values received, for resilience against packet loss. ACK values are not cumulative; each received unique SEQ value requires at least one corresponding ACK value in reply. Received ACK parameters that are redundant are ignored. Hosts MUST implement the processing of ACK parameters with multiple SEQ sequence numbers even if they do not implement sending ACK parameters with multiple SEQ sequence numbers.",
      "ja": "UPDATEパケットは、ゼロまたは1つのACKパラメータが含まれています。 ACKパラメータは、ACKされているUPDATEパケットのSEQシーケンス番号をエコーし​​ます。ホストは、一度に複数のUPDATEパケットを承認することを選択するかもしれません。例えば、ACKパラメータは、パケット損失に対する回復力のために、受信された最後の二つのSEQ値を含んでいてもよいです。 ACK値は累積的ではありません。それぞれは、応答に少なくとも一つの対応するACK値を必要とする一意のSEQ値を受け取りました。冗長で受信したACKのパラメータは無視されます。彼らは、複数の配列のシーケンス番号とACKパラメータを送信する実装していない場合でも、ホストは、複数の配列のシーケンス番号を持つACKパラメータの処理を実装しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The UPDATE packet may contain both a SEQ and an ACK parameter. In this case, the ACK parameter is being piggybacked on an outgoing UPDATE. In general, UPDATEs carrying SEQ SHOULD be ACKed upon completion of the processing of the UPDATE. A host MAY choose to hold the UPDATE carrying an ACK parameter for a short period of time to allow for the possibility of piggybacking the ACK parameter, in a manner similar to TCP delayed acknowledgments.",
      "ja": "UPDATEパケットは、配列とACKパラメータの両方を含んでいてもよいです。この場合、ACKパラメータは発信UPDATEにピギーバックされています。一般に、配列を担持する更新はUPDATEの処理の完了時にACKされるべきです。 TCPと同様に、ACKパラメータをピギーバックの可能性を可能にするために、短時間のACKパラメータを運ぶUPDATEを保持することを選択するかもしれないホストが確認応答を遅らせます。"
    },
    {
      "indent": 3,
      "text": "A sender MAY choose to forego reliable transmission of a particular UPDATE (e.g., it becomes overcome by events). The semantics are such that the receiver MUST acknowledge the UPDATE, but the sender MAY choose to not care about receiving the ACK parameter.",
      "ja": "送信者は、特定のUPDATE（例えば、それはイベントによって克服になります）の信頼性の高い伝送を放棄することを選択するかもしれません。セマンティクスは、受信機がUPDATEを確認しなければならないようなものであるが、送信側はACKパラメータを受信気にしないことを選ぶかもしれません。"
    },
    {
      "indent": 3,
      "text": "UPDATEs MAY be retransmitted without incrementing SEQ. If the same subset of parameters is included in multiple UPDATEs with different SEQs, the host MUST ensure that the receiver's processing of the parameters multiple times will not result in a protocol error.",
      "ja": "アップデートは、SEQをインクリメントせずに再送信されても​​よいです。パラメータの同じサブセットは異なるSEQsと複数の更新に含まれている場合、ホストは、受信機のパラメータの処理を複数回にプロトコルエラーが発生しないことを保証しなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.3.6. NOTIFY - the HIP Notify Packet",
      "section_title": true,
      "ja": "5.3.6.  NOTIFY  -  HIPはパケットを通知します"
    },
    {
      "indent": 3,
      "text": "The NOTIFY packet MAY be used to provide information to a peer. Typically, NOTIFY is used to indicate some type of protocol error or negotiation failure. NOTIFY packets are unacknowledged. The receiver can handle the packet only as informational, and SHOULD NOT change its HIP state (see Section 4.4.2) based purely on a received NOTIFY packet.",
      "ja": "NOTIFYパケットをピアに情報を提供するために使用され得ます。典型的には、プロトコルエラーまたはネゴシエーション失敗のいくつかのタイプを示すために使用されるNOTIFY。 NOTIFYパケットは未確認です。受信機は、情報提供のみを、パケットを処理することができ、およびNOTIFY受信したパケットに純粋に基づいて、そのHIP状態を（4.4.2項を参照）を変更しないでください。"
    },
    {
      "indent": 3,
      "text": "The HIP header values for the NOTIFY packet:",
      "ja": "NOTIFYパケットのHIPヘッダー値："
    },
    {
      "indent": 5,
      "text": "Header: Packet Type = 17 SRC HIT = Sender's HIT DST HIT = Recipient's HIT, or zero if unknown",
      "ja": "ヘッダー：パケットタイプ= 17 SRCのHIT =送信者のHIT DSTのHIT =受信者のHIT、またはゼロ不明な場合"
    },
    {
      "indent": 5,
      "text": "IP ( HIP (<NOTIFICATION>i, [HOST_ID, ] HIP_SIGNATURE) )",
      "ja": "IP（HIP（<NOTIFICATION> I、[HOST_ID、】HIP_SIGNATURE））"
    },
    {
      "indent": 3,
      "text": "Valid control bits: None",
      "ja": "有効な制御ビット：なし"
    },
    {
      "indent": 3,
      "text": "The NOTIFY packet is used to carry one or more NOTIFICATION parameters.",
      "ja": "NOTIFYパケットは、1つまたは複数の通知パラメータを運ぶために使用されます。"
    },
    {
      "indent": 0,
      "text": "5.3.7. CLOSE - the HIP Association Closing Packet",
      "section_title": true,
      "ja": "5.3.7.  CLOSE  -  HIP協会クロージングパケット"
    },
    {
      "indent": 3,
      "text": "The HIP header values for the CLOSE packet:",
      "ja": "CLOSEパケットのHIPヘッダー値："
    },
    {
      "indent": 5,
      "text": "Header: Packet Type = 18 SRC HIT = Sender's HIT DST HIT = Recipient's HIT",
      "ja": "ヘッダー：パケットタイプ= 18 SRCのHIT =送信者のHIT DSTのHIT =受信者のHIT"
    },
    {
      "indent": 5,
      "text": "IP ( HIP ( ECHO_REQUEST_SIGNED, HIP_MAC, HIP_SIGNATURE ) )",
      "ja": "IP（HIP（ECHO_REQUEST_SIGNED、HIP_MAC、HIP_SIGNATURE））"
    },
    {
      "indent": 3,
      "text": "Valid control bits: None",
      "ja": "有効な制御ビット：なし"
    },
    {
      "indent": 3,
      "text": "The sender MUST include an ECHO_REQUEST_SIGNED used to validate CLOSE_ACK received in response, and both a HIP_MAC and a signature (calculated over the whole HIP packet).",
      "ja": "送信者はCLOSE_ACK応答で受信した検証に使用され、HIP_MAC及び（全HIPパケットにわたって計算された）署名の両方ECHO_REQUEST_SIGNEDを含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "The receiver peer MUST reply with a CLOSE_ACK containing an ECHO_RESPONSE_SIGNED corresponding to the received ECHO_REQUEST_SIGNED.",
      "ja": "受信側ピアは、受信したECHO_REQUEST_SIGNEDに対応ECHO_RESPONSE_SIGNEDを含むCLOSE_ACKで応答しなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.3.8. CLOSE_ACK - the HIP Closing Acknowledgment Packet",
      "section_title": true,
      "ja": "5.3.8.  CLOSE_ACK  -  HIPは、肯定応答パケットを閉じます"
    },
    {
      "indent": 3,
      "text": "The HIP header values for the CLOSE_ACK packet:",
      "ja": "CLOSE_ACKパケットのHIPヘッダー値："
    },
    {
      "indent": 5,
      "text": "Header: Packet Type = 19 SRC HIT = Sender's HIT DST HIT = Recipient's HIT",
      "ja": "ヘッダー：パケットタイプ= 19 SRCのHIT =送信者のHIT DSTのHIT =受信者のHIT"
    },
    {
      "indent": 5,
      "text": "IP ( HIP ( ECHO_RESPONSE_SIGNED, HIP_MAC, HIP_SIGNATURE ) )",
      "ja": "IP（HIP（ECHO_RESPONSE_SIGNED、HIP_MAC、HIP_SIGNATURE））"
    },
    {
      "indent": 3,
      "text": "Valid control bits: None",
      "ja": "有効な制御ビット：なし"
    },
    {
      "indent": 3,
      "text": "The sender MUST include both an HMAC and signature (calculated over the whole HIP packet).",
      "ja": "送信者は、（全体のHIPパケットにわたって計算）HMACと署名の両方を含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "The receiver peer MUST validate the ECHO_RESPONSE_SIGNED and validate both the HIP_MAC and the signature if the receiver has state for a HIP association.",
      "ja": "受信ピアはECHO_RESPONSE_SIGNEDを検証し、受信機は、HIPの関連付けのための状態を有する場合HIP_MACと署名の両方を検証しなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.4. ICMP Messages",
      "section_title": true,
      "ja": "5.4.  ICMPメッセージ"
    },
    {
      "indent": 3,
      "text": "When a HIP implementation detects a problem with an incoming packet, and it either cannot determine the identity of the sender of the packet or does not have any existing HIP association with the sender of the packet, it MAY respond with an ICMP packet. Any such replies MUST be rate-limited as described in [RFC4443]. In most cases, the ICMP packet has the Parameter Problem type (12 for ICMPv4, 4 for ICMPv6), with the Pointer pointing to the field that caused the ICMP message to be generated.",
      "ja": "HIP実装が着信パケットの問題を検出し、それはどちらか、パケットの送信者の身元を判別できないか、パケットの送信元を持つ既存のHIPの関連性を持っていない場合は、ICMPパケットで応答することができます。 [RFC4443]に記載されているように、任意のそのような応答は、レート制限されなければなりません。ほとんどの場合、ICMPパケットは、ICMPメッセージが生成される原因となったフィールドを指し示すポインタとパラメータ問題のタイプ（ICMPv6のためICMPv4の、4 12）を有します。"
    },
    {
      "indent": 0,
      "text": "5.4.1. Invalid Version",
      "section_title": true,
      "ja": "5.4.1. 無効なバージョン"
    },
    {
      "indent": 3,
      "text": "If a HIP implementation receives a HIP packet that has an unrecognized HIP version number, it SHOULD respond, rate-limited, with an ICMP packet with type Parameter Problem, with the Pointer pointing to the Version/RES. byte in the HIP header.",
      "ja": "HIP実装が認識できないHIPバージョン番号を持っているHIPパケットを受信した場合、それはバージョン/ RESを指し示すポインタで、タイプパラメータ問題とICMPパケットで、レートが制限された、応答する必要があります。 HIPヘッダーのバイト。"
    },
    {
      "indent": 0,
      "text": "5.4.2. Other Problems with the HIP Header and Packet Structure",
      "section_title": true,
      "ja": "5.4.2.  HIPヘッダおよびパケットの構造を持つその他の問題"
    },
    {
      "indent": 3,
      "text": "If a HIP implementation receives a HIP packet that has other unrecoverable problems in the header or packet format, it MAY respond, rate-limited, with an ICMP packet with type Parameter Problem, with the Pointer pointing to the field that failed to pass the format checks. However, an implementation MUST NOT send an ICMP message if the checksum fails; instead, it MUST silently drop the packet.",
      "ja": "HIP実装がヘッダまたはパケットの形式で他の回復不可能な問題点があったHIPパケットを受信した場合、それは形式を渡すことができなかったフィールドを指すポインタで、型パラメータ問題にICMPパケットで、速度が制限され、応答MAYチェック。チェックサムが失敗した場合ただし、実装はICMPメッセージを送ってはいけません。その代わり、それは静かにパケットを廃棄しなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.4.3. Invalid Puzzle Solution",
      "section_title": true,
      "ja": "5.4.3. 無効なパズルソリューション"
    },
    {
      "indent": 3,
      "text": "If a HIP implementation receives an I2 packet that has an invalid puzzle solution, the behavior depends on the underlying version of IP. If IPv6 is used, the implementation SHOULD respond with an ICMP packet with type Parameter Problem, with the Pointer pointing to the beginning of the Puzzle solution #J field in the SOLUTION payload in the HIP message.",
      "ja": "HIP実装が無効なパズルのソリューションを持っているI2パケットを受信した場合、動作は、IPの基本的なバージョンに依存します。 IPv6が使用されている場合、実装はHIPメッセージでSOLUTIONペイロード内のパズルソリューション#Jフィールドの先頭を指すポインタで、タイプパラメータ問題とICMPパケットで応答する必要があります。"
    },
    {
      "indent": 3,
      "text": "If IPv4 is used, the implementation MAY respond with an ICMP packet with the type Parameter Problem, copying enough bytes from the I2 message so that the SOLUTION parameter fits into the ICMP message, with the Pointer pointing to the beginning of the Puzzle solution #J field, as in the IPv6 case. Note, however, that the resulting ICMPv4 message exceeds the typical ICMPv4 message size as defined in [RFC0792].",
      "ja": "IPv4のが使用されている場合はSOLUTIONパラメータは、ICMPメッセージの中に収まるように、実装は、パズルソリューション#Jの先頭を指すポインタで、I2メッセージから十分なバイトをコピーし、タイプパラメータの問題にICMPパケットで応答することができますIPv6のケースのようにフィールド、。 [RFC0792]で定義されるように、得られたICMPv4のメッセージは、典型的なICMPv4のメッセージサイズを超えていること、しかし、注意してください。"
    },
    {
      "indent": 0,
      "text": "5.4.4. Non-existing HIP Association",
      "section_title": true,
      "ja": "5.4.4. 非既存のHIP協会"
    },
    {
      "indent": 3,
      "text": "If a HIP implementation receives a CLOSE or UPDATE packet, or any other packet whose handling requires an existing association, that has either a Receiver or Sender HIT that does not match with any existing HIP association, the implementation MAY respond, rate-limited, with an ICMP packet with the type Parameter Problem. The Pointer of the ICMP Parameter Problem packet is set pointing to the beginning of the first HIT that does not match.",
      "ja": "HIP実装がReceiverまたは既存のHIP協会と一致しない送信者HITのいずれかを持っているCLOSEまたはUPDATEパケット、またはその取扱い、既存の関連付けを必要とする他のパケットを受信した場合、実装はして、レート制限、対応MAYタイプパラメータ問題とICMPパケット。 ICMPパラメータ問題パケットのポインタが一致していない最初のHITの先頭を指して設定されています。"
    },
    {
      "indent": 3,
      "text": "A host MUST NOT reply with such an ICMP if it receives any of the following messages: I1, R2, I2, R2, and NOTIFY packet. When introducing new packet types, a specification SHOULD define the appropriate rules for sending or not sending this kind of ICMP reply.",
      "ja": "I1、R2、I2、R2、およびパケットをNOTIFY：それは、次のいずれかのメッセージを受信した場合、ホストは、ICMPで返答してはなりません。新しいパケットタイプを導入する場合、仕様が送信またはICMP応答のこの種を送信しないための適切なルールを定義する必要があります。"
    },
    {
      "indent": 0,
      "text": "6. Packet Processing",
      "section_title": true,
      "ja": "6.パケット処理"
    },
    {
      "indent": 3,
      "text": "Each host is assumed to have a single HIP implementation that manages the host's HIP associations and handles requests for new ones. Each HIP association is governed by a conceptual state machine, with states defined above in Section 4.4. The HIP implementation can",
      "ja": "各ホストは、ホストのHIPの関連付けを管理し、新しいものに対する要求を処理する単一のHIP実装を有するものとします。各HIPアソシエーションはセクション4.4で上記で定義された状態で、概念的な状態マシンによって支配されます。 HIP実装することができます"
    },
    {
      "indent": 3,
      "text": "simultaneously maintain HIP associations with more than one host. Furthermore, the HIP implementation may have more than one active HIP association with another host; in this case, HIP associations are distinguished by their respective HITs. It is not possible to have more than one HIP association between any given pair of HITs. Consequently, the only way for two hosts to have more than one parallel association is to use different HITs, at least at one end.",
      "ja": "同時に複数のホストでHIPの関連付けを維持します。また、HIPの実装では、別のホストと複数のアクティブHIPアソシエーションを有していてもよいです。この場合には、HIPの関連付けは、それぞれのヒットによって区別されます。ヒットの任意の対の間に複数のHIPアソシエーションを持つことは不可能です。その結果、2つのホストが複数の平行の関連付けを有するようにするための唯一の方法は、少なくとも一方の端部に、異なるヒットを使用することです。"
    },
    {
      "indent": 3,
      "text": "The processing of packets depends on the state of the HIP association(s) with respect to the authenticated or apparent originator of the packet. A HIP implementation determines whether it has an active association with the originator of the packet based on the HITs. In the case of user data carried in a specific transport format, the transport format document specifies how the incoming packets are matched with the active associations.",
      "ja": "パケットの処理は、パケットの認証され又は明らか発信に対するHIPアソシエーション（複数可）の状態に依存します。 HIP実装は、それがヒットに基づいて、パケットの発信元とのアクティブ・アソシエーションを有しているか否かを判定する。特定のトランスポートフォーマットで運ばユーザデータの場合には、トランスポート・フォーマットの文書は、着信パケットがアクティブアソシエーションと一致している方法を指定します。"
    },
    {
      "indent": 0,
      "text": "6.1. Processing Outgoing Application Data",
      "section_title": true,
      "ja": "6.1. 送信アプリケーションデータを処理"
    },
    {
      "indent": 3,
      "text": "In a HIP host, an application can send application-level data using an identifier specified via the underlying API. The API can be a backwards-compatible API (see [RFC5338]), using identifiers that look similar to IP addresses, or a completely new API, providing enhanced services related to Host Identities. Depending on the HIP implementation, the identifier provided to the application may be different; for example, it can be a HIT or an IP address.",
      "ja": "HIPホストにおいて、アプリケーションは、基礎となるAPIを介して指定された識別子を使用して、アプリケーションレベルのデータを送信することができます。 APIは、アイデンティティをホストに関連する高度なサービスを提供し、IPアドレス、または完全に新しいAPIと似た識別子を使用して、後方互換API（[RFC5338]を参照）することができます。 HIPの実装に依存して、アプリケーションに提供識別子が異なっていてもよいです。例えば、それはHITまたはIPアドレスを指定できます。"
    },
    {
      "indent": 3,
      "text": "The exact format and method for transferring the user data from the source HIP host to the destination HIP host are defined in the corresponding transport format document. The actual data is transferred in the network using the appropriate source and destination IP addresses.",
      "ja": "先HIPホストにソースHIPホストからのユーザデータを転送するための正確な形式および方法は、対応するトランスポートフォーマットの文書で定義されています。実際のデータは、適切なソースおよび宛先IPアドレスを使用してネットワークに転送されます。"
    },
    {
      "indent": 3,
      "text": "In this document, conceptual processing rules are defined only for the base case where both hosts have only single usable IP addresses; the multi-address multihoming case is specified separately.",
      "ja": "この文書では、概念的な処理ルールのみ両方のホストが単一の使用可能なIPアドレスを持つ基本ケースのために定義されています。マルチアドレスマルチホーミングケースは別々に指定されています。"
    },
    {
      "indent": 3,
      "text": "The following conceptual algorithm describes the steps that are required for handling outgoing datagrams destined to a HIT.",
      "ja": "次の概念的なアルゴリズムは、HIT宛の送信データグラムを処理するために必要な手順について説明します。"
    },
    {
      "indent": 3,
      "text": "1. If the datagram has a specified source address, it MUST be a HIT. If it is not, the implementation MAY replace the source address with a HIT. Otherwise, it MUST drop the packet.",
      "ja": "1.データグラムが指定した送信元アドレスを持っている場合、それはHITでなければなりません。そうでない場合は、実装は、HITと送信元アドレスを交換することができます。それ以外の場合は、パケットを廃棄しなければなりません。"
    },
    {
      "indent": 3,
      "text": "2. If the datagram has an unspecified source address, the implementation MUST choose a suitable source HIT for the datagram. Selecting the source HIT is subject to local policy.",
      "ja": "2.データグラムが指定されていない送信元アドレスを持っている場合、実装はデータグラムに適したソースHITを選択する必要があります。ソースHITを選択すると、ローカルポリシーが適用されます。"
    },
    {
      "indent": 3,
      "text": "3. If there is no active HIP association with the given <source, destination> HIT pair, one MUST be created by running the base exchange. While waiting for the base exchange to complete, the implementation SHOULD queue at least one user data packet per HIP association to be formed, and it MAY queue more than one.",
      "ja": "所与の<ソース、宛先> HIT対でアクティブなHIPアソシエーションが存在しない場合3は、一つは塩基交換を実行することによって作成されなければなりません。塩基交換が完了するのを待っている間、実装はHIP協会あたり少なくとも1つのユーザデータパケットが形成されるようにキューべきであり、それ以上のものを待機させることができます。"
    },
    {
      "indent": 3,
      "text": "4. Once there is an active HIP association for the given <source, destination> HIT pair, the outgoing datagram is passed to transport handling. The possible transport formats are defined in separate documents, of which the ESP transport format for HIP is mandatory for all HIP implementations.",
      "ja": "4.所与<ソース、宛先> HITペアのアクティブHIPアソシエーションが存在すると、発信データグラムは、取り扱いを輸送するために渡されます。可能なトランスポートフォーマットは、HIPのためのESPトランスポートフォーマットは、すべてのHIPの実装のために必須となっている、別の文書で定義されています。"
    },
    {
      "indent": 3,
      "text": "5. Before sending the packet, the HITs in the datagram are replaced with suitable IP addresses. For IPv6, the rules defined in [RFC6724] SHOULD be followed. Note that this HIT-to-IP-address conversion step MAY also be performed at some other point in the stack, e.g., before wrapping the packet into the output format.",
      "ja": "5.パケットを送信する前に、データグラム内のヒットは、適切なIPアドレスに置き換えられます。 IPv6の場合、[RFC6724]で定義されたルールに従わされるべきです。このHITとIPアドレス変換ステップは、出力フォーマットにパケットを巻き付ける前に、例えば、スタック内の他のいくつかの時点で実行されてもよいことに留意されたいです。"
    },
    {
      "indent": 0,
      "text": "6.2. Processing Incoming Application Data",
      "section_title": true,
      "ja": "6.2. 着信アプリケーションデータを処理"
    },
    {
      "indent": 3,
      "text": "The following conceptual algorithm describes the incoming datagram handling when HITs are used at the receiving host as application-level identifiers. More detailed steps for processing packets are defined in corresponding transport format documents.",
      "ja": "以下の概念アルゴリズムは、ヒットがアプリケーションレベルの識別子として受信ホストで使用される入力データグラムの取り扱いについて記載しています。パケットを処理する詳細な手順は、対応するトランスポートフォーマットの文書で定義されています。"
    },
    {
      "indent": 3,
      "text": "1. The incoming datagram is mapped to an existing HIP association, typically using some information from the packet. For example, such mapping may be based on the ESP Security Parameter Index (SPI).",
      "ja": "1.着信データグラムは、典型的には、パケットからの情報を使用して、既存のHIPアソシエーションにマッピングされます。例えば、このようなマッピングは、ESPセキュリティパラメータインデックス（SPI）に基づくことができます。"
    },
    {
      "indent": 3,
      "text": "2. The specific transport format is unwrapped, in a way depending on the transport format, yielding a packet that looks like a standard (unencrypted) IP packet. If possible, this step SHOULD also verify that the packet was indeed (once) sent by the remote HIP host, as identified by the HIP association.",
      "ja": "2.特定のトランスポート・フォーマットは、標準的な（暗号化されていない）IPパケットのように見えるパケットを得、トランスポート・フォーマットに応じた方法で、開封されています。可能な場合、このステップは、また、HIPアソシエーションによって識別されるパケットが実際に（1回）、リモートHIPホストによって送信されたことを確認してください。"
    },
    {
      "indent": 7,
      "text": "Depending on the used transport mode, the verification method can\nvary.  While the HI (as well as the HIT) is used as the higher-\nlayer identifier, the verification method has to verify that the\ndata packet was sent by the correct node identity and that the\nactual identity maps to this particular HIT.  When using the ESP\ntransport format [RFC7402], the verification is done using the\nSPI value in the data packet to find the corresponding SA with\nassociated HIT and key, and decrypting the packet with that\nassociated key.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "3. The IP addresses in the datagram are replaced with the HITs associated with the HIP association. Note that this IP-address-to-HIT conversion step MAY also be performed at some other point in the stack.",
      "ja": "前記データグラムのIPアドレスはHIPアソシエーションに関連付けられたヒットで置換されています。このIPアドレス対HIT変換ステップは、スタック内の他のいくつかの時点で実行されてもよいことに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "4. The datagram is delivered to the upper layer (e.g., UDP or TCP). When demultiplexing the datagram, the right upper-layer socket is selected based on the HITs.",
      "ja": "4.データグラムは、上位層（例えば、UDPまたはTCP）に送達されます。データグラムを逆多重化するとき、右上層ソケットがヒットに基づいて選択されます。"
    },
    {
      "indent": 0,
      "text": "6.3. Solving the Puzzle",
      "section_title": true,
      "ja": "6.3. パズルを解きます"
    },
    {
      "indent": 3,
      "text": "This subsection describes the details for solving the puzzle.",
      "ja": "ここでは、パズルを解決するための詳細について説明します。"
    },
    {
      "indent": 3,
      "text": "In the R1 packet, the values #I and #K are sent in network byte order. Similarly, in the I2 packet, the values #I and #J are sent in network byte order. The hash is created by concatenating, in network byte order, the following data, in the following order and using the RHASH algorithm:",
      "ja": "R1パケットでは、値#Iと＃Kは、ネットワークバイト順に送信されます。同様に、I2パケットに、値#Iと#Jは、ネットワークバイト順で送信されます。ハッシュは、次の順序で、ネットワークバイト順で、以下のデータを連結し、RHASHアルゴリズムを使用して作成されます。"
    },
    {
      "indent": 6,
      "text": "n-bit random value #I (where n is RHASH_len), in network byte order, as appearing in the R1 and I2 packets.",
      "ja": "nビットR1及びI2パケットに現れるように、ネットワークバイト順で、（nはRHASH_lenある）ランダム値#I。"
    },
    {
      "indent": 6,
      "text": "128-bit Initiator's HIT, in network byte order, as appearing in the HIP Payload in the R1 and I2 packets.",
      "ja": "ネットワークバイト順に128ビットのイニシエータのHIT、R1及びI2パケットでHIPペイロードに現れるとして。"
    },
    {
      "indent": 6,
      "text": "128-bit Responder's HIT, in network byte order, as appearing in the HIP Payload in the R1 and I2 packets.",
      "ja": "ネットワークバイト順に128ビットのレスポンダのHIT、R1及びI2パケットでHIPペイロードに現れるとして。"
    },
    {
      "indent": 6,
      "text": "n-bit random value #J (where n is RHASH_len), in network byte order, as appearing in the I2 packet.",
      "ja": "nビットのI2パケットに現れるように、ネットワークバイト順で、（nはRHASH_lenある）ランダム値#J。"
    },
    {
      "indent": 3,
      "text": "In a valid response puzzle, the #K low-order bits of the resulting RHASH digest MUST be zero.",
      "ja": "有効な応答パズルにおいて、得られたRHASHダイジェストの#K下位ビットはゼロでなければなりません。"
    },
    {
      "indent": 3,
      "text": "Notes:",
      "ja": "ノート："
    },
    {
      "indent": 8,
      "text": "i) The length of the data to be hashed is variable, depending on\n   the output length of the Responder's hash function RHASH.",
      "raw": true
    },
    {
      "indent": 7,
      "text": "ii) All the data in the hash input MUST be in network byte order.",
      "ja": "ⅱ）ハッシュ入力内のすべてのデータはネットワークバイト順でなければなりません。"
    },
    {
      "indent": 6,
      "text": "iii) The orderings of the Initiator's and Responder's HITs are different in the R1 and I2 packets; see Section 5.1. Care must be taken to copy the values in the right order to the hash input.",
      "ja": "III）イニシエータのとレスポンダのヒットの順序は、R1及びI2パケットが異なります。セクション5.1を参照してください。ケアは、ハッシュ入力に正しい順序で値をコピーするために取られなければなりません。"
    },
    {
      "indent": 7,
      "text": "iv) For a puzzle #I, there may exist multiple valid puzzle solutions #J.",
      "ja": "ⅳ）パズル＃Iの場合は、複数の有効なパズルソリューション#Jが存在してもよいです。"
    },
    {
      "indent": 3,
      "text": "The following procedure describes the processing steps involved, assuming that the Responder chooses to precompute the R1 packets:",
      "ja": "次の手順では、レスポンダは、R1パケットを事前計算することを選択したと仮定すると、関係する処理ステップを説明します。"
    },
    {
      "indent": 3,
      "text": "Precomputation by the Responder: Sets up the puzzle difficulty #K. Creates a signed R1 and caches it.",
      "ja": "レスポンダによって事前計算は：パズルの難易度＃Kを設定します。署名R1を作成し、それをキャッシュします。"
    },
    {
      "indent": 3,
      "text": "Responder: Selects a suitable cached R1. Generates a random number #I. Sends #I and #K in an R1. Saves #I and #K for a delta time.",
      "ja": "Responderは：、適切なキャッシュされたR1を選択します。乱数#Iを生成します。 #Iと＃KはR1に送信します。デルタ時間#Iと＃Kを保存します。"
    },
    {
      "indent": 3,
      "text": "Initiator: Generates repeated attempts to solve the puzzle until a matching #J is found: Ltrunc( RHASH( #I | HIT-I | HIT-R | #J ), #K ) == 0 Sends #I and #J in an I2.",
      "ja": "イニシエータは：マッチング#Jが見つかるまでパズルを解決するための試みを繰り返し生成：Ltrunc（RHASH（#I | HIT-I | HIT-R | #J）、#K）== 0で#Iと#Jを送信I2。"
    },
    {
      "indent": 3,
      "text": "Responder: Verifies that the received #I is a saved one. Finds the right #K based on #I. Computes V := Ltrunc( RHASH( #I | HIT-I | HIT-R | #J ), #K ) Rejects if V != 0 Accepts if V == 0",
      "ja": "レスポンダ：受信#Iが保存された一つであることを確認します。 #Iに基づく権利＃Kを検索します。 ！V == 0ならばV = 0が受け入れた場合に拒否= Ltrunc（| HIT-I | | HIT-R #J）、＃K RHASH（#I）：Vが計算"
    },
    {
      "indent": 0,
      "text": "6.4. HIP_MAC and SIGNATURE Calculation and Verification",
      "section_title": true,
      "ja": "6.4.  HIP_MACと署名計算と検証"
    },
    {
      "indent": 3,
      "text": "The following subsections define the actions for processing HIP_MAC, HIP_MAC_2, HIP_SIGNATURE, and HIP_SIGNATURE_2 parameters. The HIP_MAC_2 parameter is contained in the R2 packet. The HIP_SIGNATURE_2 parameter is contained in the R1 packet. The HIP_SIGNATURE and HIP_MAC parameters are contained in other HIP packets.",
      "ja": "以下のサブセクションではHIP_MAC、HIP_MAC_2、HIP_SIGNATURE、及びHIP_SIGNATURE_2パラメータを処理するためのアクションを定義します。 HIP_MAC_2パラメータは、R2のパケットに含まれています。 HIP_SIGNATURE_2パラメータは、R1パケットに含まれています。 HIP_SIGNATUREとHIP_MACパラメータは、他のHIPパケットに含まれています。"
    },
    {
      "indent": 0,
      "text": "6.4.1. HMAC Calculation",
      "section_title": true,
      "ja": "6.4.1.  HMACの計算"
    },
    {
      "indent": 3,
      "text": "The HMAC uses RHASH as the underlying hash function. The type of RHASH depends on the HIT Suite of the Responder. Hence, HMAC-SHA-256 [RFC4868] is used for HIT Suite RSA/DSA/SHA-256, HMAC-SHA-1 [RFC2404] is used for HIT Suite ECDSA_LOW/SHA-1, and HMAC-SHA-384 [RFC4868] is used for HIT Suite ECDSA/SHA-384.",
      "ja": "HMACは、基礎となるハッシュ関数としてRHASHを使用しています。 RHASHの種類は、レスポンダのHITスイートに依存します。したがって、HMAC-SHA-256 [RFC4868]はHITスイートRSA / DSA / SHA-256、HMAC-SHA-1 [RFC2404]のために使用されるHITスイートECDSA_LOW / SHA-1、およびHMAC-SHA-384のために使用される[RFC4868 ] HITスイートECDSA / SHA-384のために使用されます。"
    },
    {
      "indent": 3,
      "text": "The following process applies both to the HIP_MAC and HIP_MAC_2 parameters. When processing HIP_MAC_2, the difference is that the HIP_MAC calculation includes a pseudo HOST_ID field containing the Responder's information as sent in the R1 packet earlier.",
      "ja": "次のプロセスはHIP_MACとHIP_MAC_2パラメータの両方に適用されます。 HIP_MAC_2を処理するときに、違いは、以前のR1パケットで送信されるようHIP_MAC計算はレスポンダの情報を含む擬似HOST_IDフィールドを含むことです。"
    },
    {
      "indent": 3,
      "text": "Both the Initiator and the Responder should take some care when verifying or calculating the HIP_MAC_2. Specifically, the Initiator has to preserve the HOST_ID exactly as it was received in the R1 packet until it receives the HIP_MAC_2 in the R2 packet.",
      "ja": "検証やHIP_MAC_2を計算するときに、イニシエータとレスポンダの両方が、いくつかの世話をする必要があります。具体的には、イニシエータは、R2パケットにHIP_MAC_2を受信するまで、それがR1パケットで受信したものと同じHOST_IDを維持しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The scope of the calculation for HIP_MAC is as follows:",
      "ja": "次のようにHIP_MACの計算の範囲です。"
    },
    {
      "indent": 3,
      "text": "HMAC: { HIP header | [ Parameters ] }",
      "ja": "HMAC：{HIPヘッダ| [ パラメーター ] }"
    },
    {
      "indent": 3,
      "text": "where Parameters include all of the packet's HIP parameters with type values ranging from 1 to (HIP_MAC's type value - 1), and excluding those parameters with type values greater than or equal to HIP_MAC's type value.",
      "ja": "、及び以上HIP_MACの型の値に等しいタイプ値とそれらのパラメータを除く - ここでパラメータは1から（1 HIP_MACのタイプの値）の範囲タイプ値を有するパケットのHIPパラメータのすべてを含みます。"
    },
    {
      "indent": 3,
      "text": "During HIP_MAC calculation, the following apply:",
      "ja": "HIP_MAC計算中は、次のように適用されます。"
    },
    {
      "indent": 3,
      "text": "o In the HIP header, the Checksum field is set to zero.",
      "ja": "HIPヘッダ中のO、チェックサムフィールドはゼロに設定されます。"
    },
    {
      "indent": 3,
      "text": "o In the HIP header, the Header Length field value is calculated to the beginning of the HIP_MAC parameter.",
      "ja": "O HIPヘッダは、ヘッダ長フィールドの値がHIP_MACパラメータの最初に計算されます。"
    },
    {
      "indent": 3,
      "text": "Parameter order is described in Section 5.2.1.",
      "ja": "パラメータの順序は、セクション5.2.1に記載されています。"
    },
    {
      "indent": 3,
      "text": "The scope of the calculation for HIP_MAC_2 is as follows:",
      "ja": "次のようにHIP_MAC_2の計算の範囲です。"
    },
    {
      "indent": 3,
      "text": "HIP_MAC_2: { HIP header | [ Parameters ] | HOST_ID }",
      "ja": "HIP_MAC_2：{HIPヘッダ| [パラメータ] | HOST_ID}"
    },
    {
      "indent": 3,
      "text": "where Parameters include all of the packet's HIP parameters with type values from 1 to (HIP_MAC_2's type value - 1), and excluding those parameters with type values greater than or equal to HIP_MAC_2's type value.",
      "ja": "ここで、パラメータは、1から（HIP_MAC_2のタイプ値 -  1）にタイプ値を持つパケットのHIPパラメータの全てを含み、そしてより大きいかHIP_MAC_2の型の値に等しいタイプ値とそれらのパラメータを除きます。"
    },
    {
      "indent": 3,
      "text": "During HIP_MAC_2 calculation, the following apply:",
      "ja": "HIP_MAC_2計算中は、次のように適用されます。"
    },
    {
      "indent": 3,
      "text": "o In the HIP header, the Checksum field is set to zero.",
      "ja": "HIPヘッダ中のO、チェックサムフィールドはゼロに設定されます。"
    },
    {
      "indent": 3,
      "text": "o In the HIP header, the Header Length field value is calculated to the beginning of the HIP_MAC_2 parameter and increased by the length of the concatenated HOST_ID parameter length (including the Type and Length fields).",
      "ja": "O HIPヘッダは、ヘッダ長フィールドの値がHIP_MAC_2パラメータの最初に計算され、（タイプと長さフィールドを含む）連結HOST_IDパラメータ長の長さが増加しました。"
    },
    {
      "indent": 3,
      "text": "o The HOST_ID parameter is exactly in the form it was received in the R1 packet from the Responder.",
      "ja": "O HOST_IDパラメータは、正確には、レスポンダからR1パケットで受信された形態です。"
    },
    {
      "indent": 3,
      "text": "Parameter order is described in Section 5.2.1, except that the HOST_ID parameter in this calculation is added to the end.",
      "ja": "パラメータの順序は、この計算でHOST_IDパラメータが最後に追加されることを除いて、セクション5.2.1に記載されています。"
    },
    {
      "indent": 3,
      "text": "The HIP_MAC parameter is defined in Section 5.2.12 and the HIP_MAC_2 parameter in Section 5.2.13. The HMAC calculation and verification process (the process applies both to HIP_MAC and HIP_MAC_2, except where HIP_MAC_2 is mentioned separately) is as follows:",
      "ja": "HIP_MACパラメータは、セクション5.2.12および5.2.13節でHIP_MAC_2パラメータで定義されています。 HMAC計算および検証プロセス（プロセスがHIP_MAC_2が別々に記載されている場合を除きHIP_MACとHIP_MAC_2、の両方に適用される）以下の通りであります："
    },
    {
      "indent": 3,
      "text": "Packet sender:",
      "ja": "パケット送信："
    },
    {
      "indent": 3,
      "text": "1. Create the HIP packet, without the HIP_MAC, HIP_SIGNATURE, HIP_SIGNATURE_2, or any other parameter with greater type value than the HIP_MAC parameter has.",
      "ja": "1. HIP_MAC、HIP_SIGNATURE、HIP_SIGNATURE_2、又はHIP_MACパラメータより大きいタイプの値を持つ他のパラメータ有することなく、HIPパケットを作成します。"
    },
    {
      "indent": 3,
      "text": "2. In case of HIP_MAC_2 calculation, add a HOST_ID (Responder) parameter to the end of the packet.",
      "ja": "2. HIP_MAC_2計算の場合には、パケットの最後にHOST_ID（レスポンダ）パラメータを追加します。"
    },
    {
      "indent": 3,
      "text": "3. Calculate the Header Length field in the HIP header, including the added HOST_ID parameter in case of HIP_MAC_2.",
      "ja": "3. HIP_MAC_2の場合に添加HOST_IDパラメータを含むHIPヘッダのヘッダ長フィールドを計算します。"
    },
    {
      "indent": 3,
      "text": "4. Compute the HMAC using either the HIP-gl or HIP-lg integrity key retrieved from KEYMAT as defined in Section 6.5.",
      "ja": "HIP-GLまたはセクション6.5で定義されるようKEYMATから取得HIP-LGインテグリティキーのいずれかを使用して4.計算HMAC。"
    },
    {
      "indent": 3,
      "text": "5. In case of HIP_MAC_2, remove the HOST_ID parameter from the packet.",
      "ja": "5. HIP_MAC_2の場合には、パケットからHOST_IDパラメータを削除します。"
    },
    {
      "indent": 3,
      "text": "6. Add the HIP_MAC parameter to the packet and any parameter with greater type value than the HIP_MAC's (HIP_MAC_2's) that may follow, including possible HIP_SIGNATURE or HIP_SIGNATURE_2 parameters.",
      "ja": "前記パケットにHIP_MACパラメータとより大きなタイプの値を持つパラメータを追加HIP_MACの可能HIP_SIGNATURE又はHIP_SIGNATURE_2パラメータを含む、従うことができる（HIP_MAC_2'S）。"
    },
    {
      "indent": 3,
      "text": "7. Recalculate the Length field in the HIP header.",
      "section_title": true,
      "ja": "7. HIPヘッダの長さフィールドを再計算。"
    },
    {
      "indent": 3,
      "text": "Packet receiver:",
      "ja": "パケット受信機："
    },
    {
      "indent": 3,
      "text": "1. Verify the HIP Header Length field.",
      "section_title": true,
      "ja": "1. HIPヘッダ長フィールドを確認してください。"
    },
    {
      "indent": 3,
      "text": "2. Remove the HIP_MAC or HIP_MAC_2 parameter, as well as all other parameters that follow it with greater type value including possible HIP_SIGNATURE or HIP_SIGNATURE_2 fields, saving the contents if they are needed later.",
      "ja": "2. HIP_MACまたはHIP_MAC_2パラメータを削除するだけでなく、彼らが後で必要な場合に内容を保存し、可能HIP_SIGNATUREまたはHIP_SIGNATURE_2フィールドを含むより大きなタイプの値と、それに続く他のすべてのパラメータ。"
    },
    {
      "indent": 3,
      "text": "3. In case of HIP_MAC_2, build and add a HOST_ID parameter (with Responder information) to the packet. The HOST_ID parameter should be identical to the one previously received from the Responder.",
      "ja": "3. HIP_MAC_2の場合には、構築したパケットに（レスポンダ情報付き）HOST_IDパラメータを追加します。 HOST_IDパラメータは、以前にレスポンダから受信したものと同一でなければなりません。"
    },
    {
      "indent": 3,
      "text": "4. Recalculate the HIP packet length in the HIP header and clear the Checksum field (set it to all zeros). In case of HIP_MAC_2, the length is calculated with the added HOST_ID parameter.",
      "ja": "4. HIPヘッダーのHIPパケット長を再計算し（全てゼロに設定）チェックサムフィールドをクリアします。 HIP_MAC_2の場合には、長さが追加HOST_IDパラメータで計算されます。"
    },
    {
      "indent": 3,
      "text": "5. Compute the HMAC using either the HIP-gl or HIP-lg integrity key as defined in Section 6.5 and verify it against the received HMAC.",
      "ja": "5.計算HMACセクション6.5で定義されるようにHIP-GLまたはHIP-LGインテグリティキーのいずれかを使用して、受信したHMACに対してそれを検証します。"
    },
    {
      "indent": 3,
      "text": "6. Set the Checksum and Header Length fields in the HIP header to original values. Note that the Checksum and Length fields contain incorrect values after this step.",
      "ja": "6.元の値にHIPヘッダのチェックサムとヘッダ長フィールドを設定します。チェックサムと長さフィールドは、このステップの後に不正な値が含まれていることに注意してください。"
    },
    {
      "indent": 3,
      "text": "7. In case of HIP_MAC_2, remove the HOST_ID parameter from the packet before further processing.",
      "ja": "7. HIP_MAC_2の場合には、さらなる処理の前にパケットからHOST_IDパラメータを削除します。"
    },
    {
      "indent": 0,
      "text": "6.4.2. Signature Calculation",
      "section_title": true,
      "ja": "6.4.2. 署名計算"
    },
    {
      "indent": 3,
      "text": "The following process applies both to the HIP_SIGNATURE and HIP_SIGNATURE_2 parameters. When processing the HIP_SIGNATURE_2 parameter, the only difference is that instead of the HIP_SIGNATURE parameter, the HIP_SIGNATURE_2 parameter is used, and the Initiator's HIT and PUZZLE Opaque and Random #I fields are cleared (set to all zeros) before computing the signature. The HIP_SIGNATURE parameter is defined in Section 5.2.14 and the HIP_SIGNATURE_2 parameter in Section 5.2.15.",
      "ja": "次のプロセスはHIP_SIGNATUREとHIP_SIGNATURE_2パラメータの両方に適用されます。 HIP_SIGNATURE_2パラメータを処理する場合、唯一の違いは、代わりHIP_SIGNATUREパラメータの、HIP_SIGNATURE_2パラメータが使用されることで、イニシエータのHITパズル不透明とランダム#Iフィールドは、署名を計算する前に（全てゼロに設定）がクリアされています。 HIP_SIGNATUREパラメータは、セクション5.2.14および5.2.15節でHIP_SIGNATURE_2パラメータで定義されています。"
    },
    {
      "indent": 3,
      "text": "The scope of the calculation for HIP_SIGNATURE and HIP_SIGNATURE_2 is as follows:",
      "ja": "次のようにHIP_SIGNATUREとHIP_SIGNATURE_2の計算の範囲です。"
    },
    {
      "indent": 3,
      "text": "HIP_SIGNATURE: { HIP header | [ Parameters ] }",
      "ja": "HIP_SIGNATURE：{HIPヘッダ| [ パラメーター ] }"
    },
    {
      "indent": 3,
      "text": "where Parameters include all of the packet's HIP parameters with type values from 1 to (HIP_SIGNATURE's type value - 1).",
      "ja": "ここで、パラメータは、1から（ -  1 HIP_SIGNATUREのタイプの値）にタイプ値を持つパケットのHIPパラメータのすべてを含みます。"
    },
    {
      "indent": 3,
      "text": "During signature calculation, the following apply:",
      "ja": "署名計算の間に、次が適用されます。"
    },
    {
      "indent": 3,
      "text": "o In the HIP header, the Checksum field is set to zero.",
      "ja": "HIPヘッダ中のO、チェックサムフィールドはゼロに設定されます。"
    },
    {
      "indent": 3,
      "text": "o In the HIP header, the Header Length field value is calculated to the beginning of the HIP_SIGNATURE parameter.",
      "ja": "O HIPヘッダは、ヘッダ長フィールドの値がHIP_SIGNATUREパラメータの最初に計算されます。"
    },
    {
      "indent": 3,
      "text": "Parameter order is described in Section 5.2.1.",
      "ja": "パラメータの順序は、セクション5.2.1に記載されています。"
    },
    {
      "indent": 3,
      "text": "HIP_SIGNATURE_2: { HIP header | [ Parameters ] }",
      "ja": "HIP_SIGNATURE_2：{HIPヘッダ| [ パラメーター ] }"
    },
    {
      "indent": 3,
      "text": "where Parameters include all of the packet's HIP parameters with type values ranging from 1 to (HIP_SIGNATURE_2's type value - 1).",
      "ja": "パラメータは、1から（ -  1 HIP_SIGNATURE_2のタイプの値）の範囲タイプ値を有するパケットのHIPパラメータのすべてを含む場合。"
    },
    {
      "indent": 3,
      "text": "During signature calculation, the following apply:",
      "ja": "署名計算の間に、次が適用されます。"
    },
    {
      "indent": 3,
      "text": "o In the HIP header, both the Checksum and the Receiver's HIT fields are set to zero.",
      "ja": "O HIPヘッダに、チェックサムと受信機のヒットフィールドの両方がゼロに設定されています。"
    },
    {
      "indent": 3,
      "text": "o In the HIP header, the Header Length field value is calculated to the beginning of the HIP_SIGNATURE_2 parameter.",
      "ja": "O HIPヘッダは、ヘッダ長フィールドの値がHIP_SIGNATURE_2パラメータの最初に計算されます。"
    },
    {
      "indent": 3,
      "text": "o The PUZZLE parameter's Opaque and Random #I fields are set to zero.",
      "ja": "O PUZZLEパラメータの不透明とランダム#Iフィールドはゼロに設定されています。"
    },
    {
      "indent": 3,
      "text": "Parameter order is described in Section 5.2.1.",
      "ja": "パラメータの順序は、セクション5.2.1に記載されています。"
    },
    {
      "indent": 3,
      "text": "The signature calculation and verification process (the process applies both to HIP_SIGNATURE and HIP_SIGNATURE_2, except in the case where HIP_SIGNATURE_2 is separately mentioned) is as follows:",
      "ja": "署名の計算及び検証処理（プロセスがHIP_SIGNATURE_2が別々に記載されている場合を除き、HIP_SIGNATUREとHIP_SIGNATURE_2の両方に適用される）以下の通りであります："
    },
    {
      "indent": 3,
      "text": "Packet sender:",
      "ja": "パケット送信："
    },
    {
      "indent": 3,
      "text": "1. Create the HIP packet without the HIP_SIGNATURE parameter or any other parameters that follow the HIP_SIGNATURE parameter.",
      "ja": "1. HIP_SIGNATUREパラメータまたはHIP_SIGNATUREパラメータに続く他のパラメータなしでHIPパケットを作成します。"
    },
    {
      "indent": 3,
      "text": "2. Calculate the Length field and zero the Checksum field in the HIP header. In case of HIP_SIGNATURE_2, set the Initiator's HIT field in the HIP header as well as the PUZZLE parameter's Opaque and Random #I fields to zero.",
      "ja": "2. Lengthフィールドを計算し、HIPヘッダ内のチェックサムフィールドをゼロ。 HIP_SIGNATURE_2の場合には、ゼロにHIPヘッダ内のイニシエータのHITフィールドならびにパズルパラメータの不透明とランダム#Iフィールドを設定します。"
    },
    {
      "indent": 3,
      "text": "3. Compute the signature using the private key corresponding to the Host Identifier (public key).",
      "ja": "3.計算ホスト識別子（公開鍵）に対応する秘密鍵を用いて署名。"
    },
    {
      "indent": 3,
      "text": "4. Add the HIP_SIGNATURE parameter to the packet.",
      "section_title": true,
      "ja": "4.パケットにHIP_SIGNATUREパラメータを追加します。"
    },
    {
      "indent": 3,
      "text": "5. Add any parameters that follow the HIP_SIGNATURE parameter.",
      "section_title": true,
      "ja": "5. HIP_SIGNATUREパラメータに続く任意のパラメータを追加します。"
    },
    {
      "indent": 3,
      "text": "6. Recalculate the Length field in the HIP header, and calculate the Checksum field.",
      "ja": "6. HIPヘッダの長さフィールドを再計算し、チェックサムフィールドを計算します。"
    },
    {
      "indent": 3,
      "text": "Packet receiver:",
      "ja": "パケット受信機："
    },
    {
      "indent": 3,
      "text": "1. Verify the HIP Header Length field and checksum.",
      "section_title": true,
      "ja": "1. HIPヘッダ長フィールドとチェックサムを確認してください。"
    },
    {
      "indent": 3,
      "text": "2. Save the contents of the HIP_SIGNATURE parameter and any other parameters following the HIP_SIGNATURE parameter, and remove them from the packet.",
      "ja": "2. HIP_SIGNATUREパラメータの内容とHIP_SIGNATUREパラメータ以下のいずれかの他のパラメータを保存し、パケットから削除します。"
    },
    {
      "indent": 3,
      "text": "3. Recalculate the HIP packet Length in the HIP header and clear the Checksum field (set it to all zeros). In case of HIP_SIGNATURE_2, set the Initiator's HIT field in the HIP header as well as the PUZZLE parameter's Opaque and Random #I fields to zero.",
      "ja": "3. HIPヘッダーのHIPパケット長を再計算し（全てゼロに設定）チェックサムフィールドをクリアします。 HIP_SIGNATURE_2の場合には、ゼロにHIPヘッダ内のイニシエータのHITフィールドならびにパズルパラメータの不透明とランダム#Iフィールドを設定します。"
    },
    {
      "indent": 3,
      "text": "4. Compute the signature and verify it against the received signature using the packet sender's Host Identity (public key).",
      "ja": "4.署名を計算し、パケットの送信元のホストID（公開鍵）を使用して、受信した署名に対してそれを検証します。"
    },
    {
      "indent": 3,
      "text": "5. Restore the original packet by adding removed parameters (in step 2) and resetting the values that were set to zero (in step 3).",
      "ja": "5.（ステップ2）を除去パラメータを追加し、（ステップ3）がゼロに設定された値をリセットして元のパケットを復元します。"
    },
    {
      "indent": 3,
      "text": "The verification can use either the HI received from a HIP packet; the HI retrieved from a DNS query, if the FQDN has been received in the HOST_ID parameter; or an HI received by some other means.",
      "ja": "検証は、いずれかを使用することができHIはHIPパケットから受け取りました。 FQDNは、HOST_IDパラメータに受信された場合にHIは、DNSクエリから取得しました。またはHIは、いくつかの他の手段によって受信されました。"
    },
    {
      "indent": 0,
      "text": "6.5. HIP KEYMAT Generation",
      "section_title": true,
      "ja": "6.5.  HIPのKEYMATの生成"
    },
    {
      "indent": 3,
      "text": "HIP keying material is derived from the Diffie-Hellman session key, Kij, produced during the HIP base exchange (see Section 4.1.3). The Initiator has Kij during the creation of the I2 packet, and the Responder has Kij once it receives the I2 packet. This is why I2 can already contain encrypted information.",
      "ja": "HIPキーイング材料をHIP基本交換の間に生成さのDiffie-Hellmanセッション鍵、Kijを、（セクション4.1.3を参照）から誘導されます。イニシエータは、I2パケットの作成中にKijをを持っており、それがI2パケットを受信するとResponderはKijをしています。 I2はすでに暗号化された情報を含めることができる理由です。"
    },
    {
      "indent": 3,
      "text": "The KEYMAT is derived by feeding Kij into the key derivation function defined by the DH Group ID. Currently, the only key derivation function defined in this document is the Hash-based Key Derivation Function (HKDF) [RFC5869] using the RHASH hash function. Other documents may define new DH Group IDs and corresponding key distribution functions.",
      "ja": "KEYMATはDHグループIDによって定義された鍵導出関数にKijを供給することによって導出されます。現在、このドキュメントで定義された唯一の鍵導出関数はRHASHハッシュ関数を使用してハッシュベースの鍵導出関数（HKDF）[RFC5869]です。他の文書は新しいDHグループIDと対応するキー分布関数を定義することもできます。"
    },
    {
      "indent": 3,
      "text": "In the following, we provide the details for deriving the keying material using HKDF.",
      "ja": "以下では、我々はHKDFを使用して鍵素材を導出するための詳細を提供します。"
    },
    {
      "indent": 3,
      "text": "where",
      "ja": "どこ"
    },
    {
      "indent": 3,
      "text": "info = sort(HIT-I | HIT-R) salt = #I | #J",
      "ja": "情報=ソート（HIT-I | HIT-R）塩= #I | #J"
    },
    {
      "indent": 3,
      "text": "Sort(HIT-I | HIT-R) is defined as the network byte order concatenation of the two HITs, with the smaller HIT preceding the larger HIT, resulting from the numeric comparison of the two HITs interpreted as positive (unsigned) 128-bit integers in network byte order. The #I and #J values are from the puzzle and its solution that were exchanged in R1 and I2 messages when this HIP association was set up. Both hosts have to store #I and #J values for the HIP association for future use.",
      "ja": "ソート（HIT-Iは、| HIT-R）が正（符号なし）128ビットとして解釈2安打の数値比較から生じる、より大きなHIT先行小さいHITと、2安打のネットワークバイト順の連結として定義されますネットワークバイト順序の整数。 #Iと#J値は、このHIPアソシエーションが設定されたとき、R1とI2のメッセージで交換されたパズルとその溶液からです。両方のホストは、将来の使用のためのHIPアソシエーションの#Iと#J値を格納しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The initial keys are drawn sequentially in the order that is determined by the numeric comparison of the two HITs, with the comparison method described in the previous paragraph. HOST_g denotes the host with the greater HIT value, and HOST_l the host with the lower HIT value.",
      "ja": "最初のキーは、前の段落で説明した比較方法を有する2本のヒットの数値比較によって決定された順序で順次描画されます。 HOST_gが大きくHIT値でホストを示し、下部HIT値でHOST_lホスト。"
    },
    {
      "indent": 3,
      "text": "The drawing order for the four initial keys is as follows:",
      "ja": "次の4つの初期のキーの描画順序は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "HIP-gl encryption key for HOST_g's ENCRYPTED parameter",
      "ja": "HOST_gの暗号化されたパラメータのHIP-GL暗号化キー"
    },
    {
      "indent": 6,
      "text": "HIP-gl integrity (HMAC) key for HOST_g's outgoing HIP packets",
      "ja": "HIP-GLの整合性（HMAC）HOST_gの送信HIPパケットのキー"
    },
    {
      "indent": 6,
      "text": "HIP-lg encryption key for HOST_l's ENCRYPTED parameter",
      "ja": "HOST_lの暗号化されたパラメータのHIP-LG暗号化キー"
    },
    {
      "indent": 6,
      "text": "HIP-lg integrity (HMAC) key for HOST_l's outgoing HIP packets",
      "ja": "HIP-LGインテグリティ（HMAC）HOST_lの送信HIPパケットのキー"
    },
    {
      "indent": 3,
      "text": "The number of bits drawn for a given algorithm is the \"natural\" size of the keys. For the mandatory algorithms, the following sizes apply:",
      "ja": "所定のアルゴリズムに描かれたビットの数は、キーの「自然な」サイズです。必須のアルゴリズムについては、以下のサイズが適用されます。"
    },
    {
      "indent": 6,
      "text": "AES 128 or 256 bits",
      "ja": "AES 128または256ビット"
    },
    {
      "indent": 6,
      "text": "SHA-1 160 bits",
      "ja": "SHA-1 160ビット"
    },
    {
      "indent": 6,
      "text": "SHA-256 256 bits",
      "ja": "SHA-256 256ビット"
    },
    {
      "indent": 6,
      "text": "SHA-384 384 bits",
      "ja": "SHA-384 384ビット"
    },
    {
      "indent": 6,
      "text": "NULL 0 bits",
      "ja": "NULL 0ビット"
    },
    {
      "indent": 3,
      "text": "If other key sizes are used, they MUST be treated as different encryption algorithms and defined separately.",
      "ja": "他のキーサイズが使用されている場合、それらは異なる暗号化アルゴリズムとして扱われ、個別に定義されなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.6. Initiation of a HIP Base Exchange",
      "section_title": true,
      "ja": "6.6.  HIP基本交換の開始"
    },
    {
      "indent": 3,
      "text": "An implementation may originate a HIP base exchange to another host based on a local policy decision, usually triggered by an application datagram, in much the same way that an IPsec IKE key exchange can dynamically create a Security Association. Alternatively, a system may initiate a HIP exchange if it has rebooted or timed out, or otherwise lost its HIP state, as described in Section 4.5.4.",
      "ja": "実装は、かなりのIPsec IKE鍵交換が動的にセキュリティアソシエーションを作成することができるのと同じように、通常はアプリケーションのデータグラムによってトリガローカルポリシーの決定に基づいて、別のホストへのHIP基本交換を生じてもよいです。あるいは、それは再起動またはタイムアウトした場合、システムは、HIP交換を開始することができる、またはそうでなければ、セクション4.5.4に記載したように、そのHIP状態を失いました。"
    },
    {
      "indent": 3,
      "text": "The implementation prepares an I1 packet and sends it to the IP address that corresponds to the peer host. The IP address of the peer host may be obtained via conventional mechanisms, such as DNS lookup. The I1 packet contents are specified in Section 5.3.1. The",
      "ja": "実装は、I1パケットを作成し、ピア・ホストに対応するIPアドレスに送信します。ピア・ホストのIPアドレスは、DNSルックアップのような従来の機構を介して得ることができます。 I1パケットの内容は、セクション5.3.1で指定されています。ザ・"
    },
    {
      "indent": 3,
      "text": "selection of which source or destination Host Identity to use, if an Initiator or Responder has more than one to choose from, is typically a policy decision.",
      "ja": "イニシエータまたはレスポンダから選択する以上のものを持っている場合は、ソースまたは宛先ホストIDを使用するかの選択は、一般的に政策決定です。"
    },
    {
      "indent": 3,
      "text": "The following steps define the conceptual processing rules for initiating a HIP base exchange:",
      "ja": "次の手順は、HIP基本交換を開始するための概念的な処理ルールを定義します。"
    },
    {
      "indent": 3,
      "text": "1. The Initiator receives one or more of the Responder's HITs and one or more addresses from either a DNS lookup of the Responder's FQDN, some other repository, or a local database. If the Initiator does not know the Responder's HIT, it may attempt opportunistic mode by using NULL (all zeros) as the Responder's HIT (see also \"HIP Opportunistic Mode\" (Section 4.1.8)). If the Initiator can choose from multiple Responder HITs, it selects a HIT for which the Initiator supports the HIT Suite.",
      "ja": "1.イニシエータがレスポンダのヒットとレスポンダのFQDNのDNSルックアップ、いくつかの他のレポジトリ、またはローカルデータベースのいずれかから1つ以上のアドレスの一つ以上を受け取ります。イニシエータは、レスポンダのHITを知らない場合、それは（また、「HIP日和見モード」（セクション4.1.8）を参照してください）レスポンダのHITとしてNULL（すべてゼロ）を使用して日和見モードを試みることができます。イニシエータは、複数のレスポンダのヒットから選ぶことができた場合は、イニシエータがHIT SuiteをサポートするためにHITを選択します。"
    },
    {
      "indent": 3,
      "text": "2. The Initiator sends an I1 packet to one of the Responder's addresses. The selection of which address to use is a local policy decision.",
      "ja": "2.イニシエータは、レスポンダのアドレスの1つにI1パケットを送信します。使用するアドレスの選択は、ローカルの政策決定です。"
    },
    {
      "indent": 3,
      "text": "3. The Initiator includes the DH_GROUP_LIST in the I1 packet. The selection and order of DH Group IDs in the DH_GROUP_LIST MUST be stored by the Initiator, because this list is needed for later R1 processing. In most cases, the preferences regarding the DH groups will be static, so no per-association storage is necessary.",
      "ja": "前記イニシエータは、I1パケット内DH_GROUP_LISTを含みます。このリストは、後にR1の処理のために必要とされているので、DH_GROUP_LISTでDHグループIDの選択と順序は、イニシエータによって格納する必要があります。ほとんどの場合、DHグループに関する優先静的されるので、何ごとの関連ストレージは必要ありません。"
    },
    {
      "indent": 3,
      "text": "4. Upon sending an I1 packet, the sender transitions to state I1-SENT and starts a timer for which the timeout value SHOULD be larger than the worst-case anticipated RTT. The sender SHOULD also increment the trial counter associated with the I1.",
      "ja": "I1パケットを送信すると4は、送信遷移はI1-SENT状態及びタイムアウト値はRTTを予想最悪の場合よりも大きくすべきためのタイマを起動します。送信者はまた、I1に関連付けられた試行カウンタをインクリメントすべきです。"
    },
    {
      "indent": 3,
      "text": "5. Upon timeout, the sender SHOULD retransmit the I1 packet and restart the timer, up to a maximum of I1_RETRIES_MAX tries.",
      "ja": "タイムアウト時に5.は、送信者がアップI1_RETRIES_MAXしようとの最大の、I1パケットを再送し、タイマーを再起動する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.6.1. Sending Multiple I1 Packets in Parallel",
      "section_title": true,
      "ja": "6.6.1. 同時に複数のI1パケットを送信します"
    },
    {
      "indent": 3,
      "text": "For the sake of minimizing the association establishment latency, an implementation MAY send the same I1 packet to more than one of the Responder's addresses. However, it MUST NOT send to more than three (3) Responder addresses in parallel. Furthermore, upon timeout, the implementation MUST refrain from sending the same I1 packet to multiple addresses. That is, if it retries to initialize the connection after a timeout, it MUST NOT send the I1 packet to more than one destination address. These limitations are placed in order to avoid congestion of the network, and potential DoS attacks that might occur, e.g., because someone's claim to have hundreds or thousands of addresses could generate a huge number of I1 packets from the Initiator.",
      "ja": "アソシエーション確立待ち時間を最小化するために、実装はレスポンダの複数のアドレスに同じI1パケットを送信することができます。しかし、それは並列につ以上（3）レスポンダアドレスに送ってはいけません。また、タイムアウト時に、実装は複数のアドレスに同じI1パケットを送信控えなければなりません。つまり、タイムアウト後に接続を初期化するために再試行する場合、それは複数の宛先アドレスにI1パケットを送ってはいけません、です。アドレスの数百または数千を持っている誰かの主張は、イニシエータからI1パケットの膨大な数を生成する可能性があるため、これらの制限は、例えば、ネットワークの混雑を避けるために配置され、発生する可能性のある潜在的なDoS攻撃されています。"
    },
    {
      "indent": 3,
      "text": "As the Responder is not guaranteed to distinguish the duplicate I1 packets it receives at several of its addresses (because it avoids storing states when it answers back an R1 packet), the Initiator may receive several duplicate R1 packets.",
      "ja": "レスポンダは、そのアドレスのいくつかで受信重複I1パケットを区別することが保証されないように（それはR1パケットをバック応答するとき、それは記憶状態を回避するため）、イニシエータは、いくつかの重複R1パケットを受信することができます。"
    },
    {
      "indent": 3,
      "text": "The Initiator SHOULD then select the initial preferred destination address using the source address of the selected received R1, and use the preferred address as a source address for the I2 packet. Processing rules for received R1s are discussed in Section 6.8.",
      "ja": "イニシエータは、次に、選択された受信R1の送信元アドレスを使用して初期好適宛先アドレスを選択し、I2パケットの送信元アドレスとして好適アドレスを使用すべきです。受信のR1のための処理規則は6.8節で議論されています。"
    },
    {
      "indent": 0,
      "text": "6.6.2. Processing Incoming ICMP Protocol Unreachable Messages",
      "section_title": true,
      "ja": "6.6.2. 着信ICMPプロトコル到達不能メッセージの処理"
    },
    {
      "indent": 3,
      "text": "A host may receive an ICMP 'Destination Protocol Unreachable' message as a response to sending a HIP I1 packet. Such a packet may be an indication that the peer does not support HIP, or it may be an attempt to launch an attack by making the Initiator believe that the Responder does not support HIP.",
      "ja": "ホストはHIPのI1パケットを送信に対する応答としてICMP「宛先プロトコル到達不能」というメッセージを受け取ることができます。このようなパケットは、ピアがHIPをサポートしていないことを示している可能性が、またはイニシエータがレスポンダは、HIPをサポートしていないと信じていることによって、攻撃を開始しようとする試みかもしれません。"
    },
    {
      "indent": 3,
      "text": "When a system receives an ICMP 'Destination Protocol Unreachable' message while it is waiting for an R1 packet, it MUST NOT terminate waiting. It MAY continue as if it had not received the ICMP message, and send a few more I1 packets. Alternatively, it MAY take the ICMP message as a hint that the peer most probably does not support HIP, and return to state UNASSOCIATED earlier than otherwise. However, at minimum, it MUST continue waiting for an R1 packet for a reasonable time before returning to UNASSOCIATED.",
      "ja": "それはR1パケットを待っている間に、システムがICMP「デスティネーション・プロトコル到達不能」というメッセージを受信すると、それは待って終了してはなりません。それはICMPメッセージを受け取っていないかのように継続し、さらにいくつかのI1パケットを送信することができます。また、それは、ピアがおそらくHIPをサポートしていないことをヒントとしてICMPメッセージをとることができ、および関連付けられていない以前のそれ以外よりも状態に戻ります。しかし、最低でも、それが関連付けられていないに戻る前に、合理的な時間のためのR1パケットを待ち続ける必要があります。"
    },
    {
      "indent": 0,
      "text": "6.7. Processing of Incoming I1 Packets",
      "section_title": true,
      "ja": "6.7. 着信I1パケットの処理"
    },
    {
      "indent": 3,
      "text": "An implementation SHOULD reply to an I1 with an R1 packet, unless the implementation is unable or unwilling to set up a HIP association. If the implementation is unable to set up a HIP association, the host SHOULD send an 'ICMP Destination Protocol Unreachable, Administratively Prohibited' message to the I1 packet source IP address. If the implementation is unwilling to set up a HIP association, the host MAY ignore the I1 packet. This latter case may occur during a DoS attack such as an I1 packet flood.",
      "ja": "実装はHIPの関連付けを設定することができない、または不本意でなければ実装は、R1パケットでI1に応答すべきです。実装はHIPの関連付けを設定することができない場合は、ホストが「到達不能ICMPの宛先プロトコル、管理上禁止」I1パケットの送信元IPアドレスにメッセージを送信する必要があります。実装はHIPの関連付けを設定することが不本意である場合、ホストは、I1パケットを無視するかもしれません。この後者の場合は、I1パケットフラッドとしてDoS攻撃の間に起こり得ます。"
    },
    {
      "indent": 3,
      "text": "The implementation SHOULD be able to handle a storm of received I1 packets, discarding those with common content that arrive within a small time delta.",
      "ja": "実装は、短い時間内に到着デルタ共通のコンテンツを有するものを廃棄、受信I1パケットの嵐を扱うことができるべきです。"
    },
    {
      "indent": 3,
      "text": "A spoofed I1 packet can result in an R1 attack on a system. An R1 packet sender MUST have a mechanism to rate-limit R1 packets sent to an address.",
      "ja": "偽装されたI1パケットは、システム上のR1攻撃につながることができます。 R1パケットの送信者アドレスに送信されたR1パケット制限を評価する仕組みを持たなければなりません。"
    },
    {
      "indent": 3,
      "text": "It is RECOMMENDED that the HIP state machine does not transition upon sending an R1 packet.",
      "ja": "HIPステートマシンは、R1パケットを送信するときに移行しないことが推奨されます。"
    },
    {
      "indent": 3,
      "text": "The following steps define the conceptual processing rules for responding to an I1 packet:",
      "ja": "次の手順は、I1パケットに応答するための概念的な処理ルールを定義します。"
    },
    {
      "indent": 3,
      "text": "1. The Responder MUST check that the Responder's HIT in the received I1 packet is either one of its own HITs or NULL. Otherwise, it must drop the packet.",
      "ja": "1. Responderは受け取ったI1パケット内のレスポンダのHITは、自身のヒットまたはNULLのいずれか一つであることをチェックしなければなりません。それ以外の場合は、パケットをドロップする必要があります。"
    },
    {
      "indent": 3,
      "text": "2. If the Responder is in ESTABLISHED state, the Responder MAY respond to this with an R1 packet, prepare to drop an existing HIP security association with the peer, and stay at ESTABLISHED state.",
      "ja": "2. ResponderがESTABLISHED状態にある場合、Responderは、R1パケットでこれに応えたピアとの既存のHIPセキュリティアソシエーションをドロップし、ESTABLISHED状態に滞在する準備をするかもしれません。"
    },
    {
      "indent": 3,
      "text": "3. If the Responder is in I1-SENT state, it MUST make a comparison between the sender's HIT and its own (i.e., the receiver's) HIT. If the sender's HIT is greater than its own HIT, it should drop the I1 packet and stay at I1-SENT. If the sender's HIT is smaller than its own HIT, it SHOULD send the R1 packet and stay at I1-SENT. The HIT comparison is performed as defined in Section 6.5.",
      "ja": "前記レスポンダは、I1-SENT状態にある場合は、送信者のHIT、自身（即ち、受信機の）HITとの比較を行う必要があります。送信者のHITは独自のHITよりも大きい場合、それはI1パケットをドロップし、I1-SENTに滞在する必要があります。送信者のHITは独自のHITよりも小さい場合、それはR1パケットを送信し、I1-SENTに滞在する必要があります。セクション6.5で定義されるようにHITの比較が行われます。"
    },
    {
      "indent": 3,
      "text": "4. If the implementation chooses to respond to the I1 packet with an R1 packet, it creates a new R1 or selects a precomputed R1 according to the format described in Section 5.3.2. It creates or chooses an R1 that contains its most preferred DH public value that is also contained in the DH_GROUP_LIST in the I1 packet. If no suitable DH Group ID was contained in the DH_GROUP_LIST in the I1 packet, it sends an R1 with any suitable DH public key.",
      "ja": "4.実装はR1パケットでI1パケットに応答することを選択した場合、それは新しいR1を作成するか、セクション5.3.2で説明したフォーマットに従って予め計算R1を選択します。また、I1パケットにDH_GROUP_LISTに含まれているその最も好ましいDH公開値が含まれているR1を作成または選択します。もし適切なDHグループIDがI1パケットにDH_GROUP_LISTに含まれていなかった場合は、任意の適切なDH公開鍵でR1を送信します。"
    },
    {
      "indent": 3,
      "text": "5. If the received Responder's HIT in the I1 is NULL, the Responder selects a HIT with the same HIT Suite as the Initiator's HIT. If this HIT Suite is not supported by the Responder, it SHOULD select a REQUIRED HIT Suite from Section 5.2.10, which is currently RSA/DSA/SHA-256. Other than that, selecting the HIT is a local policy matter.",
      "ja": "5. I1で受信レスポンダのHITがNULLの場合、レスポンダはイニシエータのHITと同じHIT SuiteにHITを選択します。このHITスイートは、レスポンダでサポートされていない場合、それは現在、RSA / DSA / SHA-256である5.2.10からREQUIRED HIT Suiteを選択する必要があります。それ以外は、HITを選択すると、ローカルポリシーの問題です。"
    },
    {
      "indent": 3,
      "text": "6. The Responder expresses its supported HIP transport formats in the TRANSPORT_FORMAT_LIST as described in Section 5.2.11. The Responder MUST provide at least one payload transport format type.",
      "ja": "セクション5.2.11に記載されるように前記レスポンダはTRANSPORT_FORMAT_LISTそのサポートHIPのトランスポートフォーマットを表します。レスポンダは、少なくとも一つのペイロードのトランスポート・フォーマット・タイプを提供しなければなりません。"
    },
    {
      "indent": 3,
      "text": "7. The Responder sends the R1 packet to the source IP address of the I1 packet.",
      "ja": "7. ResponderはI1パケットの送信元IPアドレスにR1パケットを送信します。"
    },
    {
      "indent": 0,
      "text": "6.7.1. R1 Management",
      "section_title": true,
      "ja": "6.7.1.  R1管理"
    },
    {
      "indent": 3,
      "text": "All compliant implementations MUST be able to produce R1 packets; even if a device is configured by policy to only initiate associations, it must be able to process I1s in cases of recovery from loss of state or key exhaustion. An R1 packet MAY be precomputed. An R1 packet MAY be reused for a short time period, denoted here as \"Delta T\", which is implementation dependent, and SHOULD be deprecated and not used once a valid response I2 packet has been received from an Initiator. During an I1 message storm, an R1 packet MAY be reused beyond the normal Delta T. R1 information MUST NOT be discarded until a time period \"Delta S\" (again, implementation dependent) after the R1 packet is no longer being offered. Delta S is the assumed maximum time needed for the last I2 packet in response to the R1 packet to arrive back at the Responder.",
      "ja": "すべての準拠した実装はR1パケットを生成できなければなりません。デバイスのみの関連付けを開始するポリシーによって構成されても、状態またはキー疲労の損失からの回復の場合にはI1sを処理することができなければなりません。 R1パケットが事前に計算されるかもしれません。 R1パケットは実装依存である「デルタT」、としてここに示される短い期間のために再利用することができる、と廃止されるべきで、イニシエータから一度有効な応答I2パケットを受信した使用されません。 I1メッセージ嵐の中、R1パケットは、期間（再び、実装に依存）R1パケットの後にはもはや提供されている「デルタS」まで捨ててはならない、通常のデルタT. R1情報を超えて再利用することができます。デルタSは、レスポンダに戻って到着するR1パケットへの応答の最後のI2パケットのために必要な想定される最大時間です。"
    },
    {
      "indent": 3,
      "text": "Implementations that support multiple DH groups MAY precompute R1 packets for each supported group so that incoming I1 packets with different DH Group IDs in the DH_GROUP_LIST can be served quickly.",
      "ja": "DH_GROUP_LISTの異なるDHグループIDを持つ、着信I1パケットを迅速に提供できるように、複数のDHグループをサポートする実装は、サポートされている各グループのためにR1パケットを事前に計算してもよい（MAY）。"
    },
    {
      "indent": 3,
      "text": "An implementation MAY keep state about received I1 packets and match the received I2 packets against the state, as discussed in Section 4.1.1.",
      "ja": "セクション4.1.1で説明したように実装では、受信されたI1パケットに関する状態を維持した状態に対して受信I2パケットを一致させることができます。"
    },
    {
      "indent": 0,
      "text": "6.7.2. Handling of Malformed Messages",
      "section_title": true,
      "ja": "6.7.2. 不正な形式のメッセージの処理"
    },
    {
      "indent": 3,
      "text": "If an implementation receives a malformed I1 packet, it SHOULD NOT respond with a NOTIFY message, as such a practice could open up a potential denial-of-service threat. Instead, it MAY respond with an ICMP packet, as defined in Section 5.4.",
      "ja": "実装が不正な形式のI1パケットを受信した場合、このような慣行は、潜在的なサービス拒否の脅威を開く可能性があるので、それは、NOTIFYメッセージで応答すべきでありません。セクション5.4で定義されている代わりに、それは、ICMPパケットで応答することができます。"
    },
    {
      "indent": 0,
      "text": "6.8. Processing of Incoming R1 Packets",
      "section_title": true,
      "ja": "6.8. 着信R1パケットの処理"
    },
    {
      "indent": 3,
      "text": "A system receiving an R1 packet MUST first check to see if it has sent an I1 packet to the originator of the R1 packet (i.e., it is in state I1-SENT). If so, it SHOULD process the R1 as described below, send an I2 packet, and transition to state I2-SENT, setting a timer to protect the I2 packet. If the system is in state I2-SENT, it MAY respond to the R1 packet if the R1 packet has a larger R1 generation counter; if so, it should drop its state due to processing the previous R1 packet and start over from state I1-SENT. If the system is in any other state with respect to that host, the system SHOULD silently drop the R1 packet.",
      "ja": "R1パケットを受信システムは最初に、R1パケットの発信元（すなわち、それは状態I1-SENTである）にI1パケットを送信したかどうかを確認しなければなりません。もしそうなら、それはI2パケットを保護するためのタイマーを設定、後述するように、R1を処理I2パケットを送信し、状態I2-SENTに遷移すべきです。システムが状態I2-SENTであるならば、それはR1パケットが大きなR1生成カウンタを持っている場合はR1パケットに応答することができます。もしそうなら、それが原因前R1パケットを処理し、その状態を削除し、状態I1-SENTからやり直すべきです。システムは、そのホストに対して任意の他の状態にある場合、システムは静かR1パケットをドロップすべきです。"
    },
    {
      "indent": 3,
      "text": "When sending multiple I1 packets, an Initiator SHOULD wait for a small amount of time after the first R1 reception to allow possibly multiple R1 packets to arrive, and it SHOULD respond to an R1 packet among the set with the largest R1 generation counter.",
      "ja": "複数I1パケットを送信する場合、イニシエータは、おそらく複数R1パケットが到達できるように最初のR1受信後の時間の少量のを待つ必要があり、それが最大R1生成カウンタとセット間R1パケットに応答する必要があります。"
    },
    {
      "indent": 3,
      "text": "The following steps define the conceptual processing rules for responding to an R1 packet:",
      "ja": "次の手順は、R1パケットに応答するための概念的な処理ルールを定義します。"
    },
    {
      "indent": 3,
      "text": "1. A system receiving an R1 MUST first check to see if it has sent an I1 packet to the originator of the R1 packet (i.e., it has a HIP association that is in state I1-SENT and that is associated with the HITs in the R1). Unless the I1 packet was sent in opportunistic mode (see Section 4.1.8), the IP addresses in the received R1 packet SHOULD be ignored by the R1 processing and, when looking up the right HIP association, the received R1 packet SHOULD be matched against the associations using only the HITs. If a match exists, the system should process the R1 packet as described below.",
      "ja": "1. R1を受信するシステムは、最初に、R1パケットの発信元にI1パケットを送信したかどうかをチェックしなければならない（すなわち、それは状態I1-送られ、その中でHIPアソシエーションがでヒットに関連付けられ有しますR1）。 I1パケットが（セクション4.1.8を参照）日和見モードで送信された場合を除き、受信R1パケット内のIPアドレスは、R1処理によって無視されるべきであると、右のHIPの関連付けを検索する場合、受信R1パケットはと照合されるべきである（SHOULD）ヒットのみを使用して団体。一致が存在する場合、以下に記載されるように、システムは、R1パケットを処理しなければなりません。"
    },
    {
      "indent": 3,
      "text": "2. Otherwise, if the system is in any state other than I1-SENT or I2-SENT with respect to the HITs included in the R1 packet, it SHOULD silently drop the R1 packet and remain in the current state.",
      "ja": "システムは、I1-送信またはI2-SENTヒットに対しては、R1パケットに含まれる以外の状態にある場合2.そうでない場合、それは静かR1パケットをドロップし、現在の状態のままであるべきです。"
    },
    {
      "indent": 3,
      "text": "3. If the HIP association state is I1-SENT or I2-SENT, the received Initiator's HIT MUST correspond to the HIT used in the original I1. Also, the Responder's HIT MUST correspond to the one used in the I1, unless the I1 packet contained a NULL HIT.",
      "ja": "3. HIP関連状態はI1-I2送信または送信済みであれば、受信したイニシエータのHITは、元のI1に使用HITに対応しなければなりません。 I1パケットがNULLのHITを含まない限り、また、レスポンダのHITは、I1で使用されるものに対応しなければなりません。"
    },
    {
      "indent": 3,
      "text": "4. The system SHOULD validate the R1 signature before applying further packet processing, according to Section 5.2.15.",
      "ja": "前記システムは、セクション5.2.15によると、さらにパケット処理を適用する前に、R1の署名を検証すべきです。"
    },
    {
      "indent": 3,
      "text": "5. If the HIP association state is I1-SENT, and multiple valid R1 packets are present, the system MUST select from among the R1 packets with the largest R1 generation counter.",
      "ja": "5. HIP関連状態はI1-送られ、複数の有効なR1パケットが存在する場合、システムは、最大R1生成カウンタとR1パケットのうちから選択しなければなりません。"
    },
    {
      "indent": 3,
      "text": "6. The system MUST check that the Initiator's HIT Suite is contained in the HIT_SUITE_LIST parameter in the R1 packet (i.e., the Initiator's HIT Suite is supported by the Responder). If the HIT Suite is supported by the Responder, the system proceeds normally. Otherwise, the system MAY stay in state I1-SENT and restart the BEX by sending a new I1 packet with an Initiator HIT that is supported by the Responder and hence is contained in the HIT_SUITE_LIST in the R1 packet. The system",
      "ja": "前記システムは、イニシエータのHIT SuiteはR1パケット内HIT_SUITE_LISTパラメータに含まれていることを確認しなければならない（すなわち、イニシエータのHITスイートは、レスポンダによって支持されています）。 HIT Suiteはレスポンダによってサポートされている場合、システムが正常に進行します。そうしないと、システムはSENT-I1状態にとどまるとレスポンダによってサポートされているので、R1パケットでHIT_SUITE_LISTに含まれているイニシエータHITで新しいI1パケットを送信することにより、BEXを再起動する場合があります。システム"
    },
    {
      "indent": 8,
      "text": "MAY abort the BEX if no suitable source HIT is available.  The\nsystem SHOULD wait for an acceptable time span to allow further\nR1 packets with higher R1 generation counters or different HIT\nand HIT Suites to arrive before restarting or aborting the BEX.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "7. The system MUST check that the DH Group ID in the DIFFIE_HELLMAN parameter in the R1 matches the first DH Group ID in the Responder's DH_GROUP_LIST in the R1 packet, and also that this Group ID corresponds to a value that was included in the Initiator's DH_GROUP_LIST in the I1 packet. If the DH Group ID of the DIFFIE_HELLMAN parameter does not express the Responder's best choice, the Initiator can conclude that the DH_GROUP_LIST in the I1 packet was adversely modified. In such a case, the Initiator MAY send a new I1 packet; however, it SHOULD NOT change its preference in the DH_GROUP_LIST in the new I1 packet. Alternatively, the Initiator MAY abort the HIP base exchange.",
      "ja": "7.システムはR1でDIFFIE_HELLMANパラメータのDHグループIDがR1パケットにレスポンダのDH_GROUP_LISTに最初のDHグループIDと一致し、また、このグループIDは、イニシエータのDH_GROUP_LISTに含まれていた値に対応していることいることを確認しなければなりませんI1パケットインチDIFFIE_HELLMANパラメータのDHグループIDは、レスポンダの最良の選択を発現しない場合は、イニシエータは、I1パケット内のDH_GROUP_LISTが悪変更されたと結論付けることができます。そのような場合には、イニシエータは新しいI1パケットを送信することができ、しかし、それは新しいI1パケットにDH_GROUP_LISTにその優先度を変更しないでください。また、イニシエータは、HIP基本交換を中止することができます。"
    },
    {
      "indent": 3,
      "text": "8. If the HIP association state is I2-SENT, the system MAY re-enter state I1-SENT and process the received R1 packet if it has a larger R1 generation counter than the R1 packet responded to previously.",
      "ja": "8. HIP関連状態はI2-送信される場合、システムを再入力することができる状態I1-送られ、それはR1パケットが以前に応答よりも大きなR1生成カウンタを有する場合、受信したR1パケットを処理します。"
    },
    {
      "indent": 3,
      "text": "9. The R1 packet may have the A-bit set -- in this case, the system MAY choose to refuse it by dropping the R1 packet and returning to state UNASSOCIATED. The system SHOULD consider dropping the R1 packet only if it used a NULL HIT in the I1 packet. If the A-bit is set, the Responder's HIT is anonymous and SHOULD NOT be stored permanently.",
      "ja": "この場合には、システムはR1パケットをドロップすると関連付けられていない状態に戻ることによってそれを拒否することを選択するかもしれない -  9. R1パケットがAビットのセットを有することができます。システムは、それがI1パケットにおけるNULLのHITを使用した場合にのみR1パケットをドロップ検討すべきです。 Aビットがセットされている場合、レスポンダのHITは匿名で、恒久的に保存しないでください。"
    },
    {
      "indent": 3,
      "text": "10. The system SHOULD attempt to validate the HIT against the received Host Identity by using the received Host Identity to construct a HIT and verify that it matches the Sender's HIT.",
      "ja": "10.システムは、HITを構築し、それが送信者のHITと一致することを確認するために、受信したホストのアイデンティティを使用して、受信したホストIDに対してHITを検証しようとすべきです。"
    },
    {
      "indent": 3,
      "text": "11. The system MUST store the received R1 generation counter for future reference.",
      "ja": "11.システムは、将来の参照のために受信されたR1世代カウンタを格納しなければなりません。"
    },
    {
      "indent": 3,
      "text": "12. The system attempts to solve the puzzle in the R1 packet. The system MUST terminate the search after exceeding the remaining lifetime of the puzzle. If the puzzle is not successfully solved, the implementation MAY either resend the I1 packet within the retry bounds or abandon the HIP base exchange.",
      "ja": "12.システムがR1パケット内のパズルを解くことを試みます。システムは、パズルの残りの寿命を超えた後、検索を終えなければなりません。パズルが正常に解決されない場合、実装は、いずれかの再試行の範囲内でI1パケットを再送するか、HIP基本交換を放棄することができます。"
    },
    {
      "indent": 3,
      "text": "13. The system computes standard Diffie-Hellman keying material according to the public value and Group ID provided in the DIFFIE_HELLMAN parameter. The Diffie-Hellman keying material Kij is used for key extraction as specified in Section 6.5.",
      "ja": "13.システムがDIFFIE_HELLMANパラメータに設けられた公開値とグループIDに係る標準的なディフィー・ヘルマン鍵材料を算出します。セクション6.5で指定されたDiffie-Hellmanの鍵材料Kijを鍵抽出のために使用されます。"
    },
    {
      "indent": 3,
      "text": "14. The system selects the HIP_CIPHER ID from the choices presented in the R1 packet and uses the selected values subsequently when generating and using encryption keys, and when sending the I2 packet. If the proposed alternatives are not acceptable to the system, it may either resend an I1 within the retry bounds or abandon the HIP base exchange.",
      "ja": "14.システムがR1パケットに提示選択肢からHIP_CIPHER IDを選択し、暗号鍵を生成し、使用する場合、その後選択された値を使用し、そしてI2パケットを送信するとき。提案された代替システムに受け入れられない場合は、リトライ範囲内I1を再送信するか、HIP基本交換を放棄することができるいずれか。"
    },
    {
      "indent": 3,
      "text": "15. The system chooses one suitable transport format from the TRANSPORT_FORMAT_LIST and includes the respective transport format parameter in the subsequent I2 packet.",
      "ja": "15.システムがTRANSPORT_FORMAT_LISTからの1つの適切なトランスポートフォーマットを選択し、その後のI2パケットの各トランスポートフォーマットパラメータを含みます。"
    },
    {
      "indent": 3,
      "text": "16. The system initializes the remaining variables in the associated state, including Update ID counters.",
      "ja": "16.システムは、更新IDカウンタを含む関連状態における残りの変数を初期化します。"
    },
    {
      "indent": 3,
      "text": "17. The system prepares and sends an I2 packet, as described in Section 5.3.3.",
      "ja": "17.システムを準備し、セクション5.3.3に記載したように、I2パケットを送信します。"
    },
    {
      "indent": 3,
      "text": "18. The system SHOULD start a timer whose timeout value SHOULD be larger than the worst-case anticipated RTT, and MUST increment a trial counter associated with the I2 packet. The sender SHOULD retransmit the I2 packet upon a timeout and restart the timer, up to a maximum of I2_RETRIES_MAX tries.",
      "ja": "18.システムは、そのタイムアウト値は、最悪の場合よりも大きくなければならないRTTを予想タイマーを起動する必要があり、およびI2のパケットに関連付けられた試行カウンタをインクリメントしなければなりません。送信者は、タイムアウト時にI2パケットを再送し、タイマーを再起動し、I2_RETRIES_MAX試みるの最大までべきです。"
    },
    {
      "indent": 3,
      "text": "19. If the system is in state I1-SENT, it SHALL transition to state I2-SENT. If the system is in any other state, it remains in the current state.",
      "ja": "19.システムが状態I1-SENTである場合、それは状態I2-SENTに遷移します。システムが他の状態にある場合、それは現在の状態のままになります。"
    },
    {
      "indent": 0,
      "text": "6.8.1. Handling of Malformed Messages",
      "section_title": true,
      "ja": "6.8.1. 不正な形式のメッセージの処理"
    },
    {
      "indent": 3,
      "text": "If an implementation receives a malformed R1 message, it MUST silently drop the packet. Sending a NOTIFY or ICMP would not help, as the sender of the R1 packet typically doesn't have any state. An implementation SHOULD wait for some more time for a possibly well-formed R1, after which it MAY try again by sending a new I1 packet.",
      "ja": "実装が不正な形式のR1メッセージを受信した場合、それは静かにパケットを廃棄しなければなりません。 R1パケットの送信者は、典型的には、任意の状態を持っていないようNOTIFYまたはICMPを送信すると、役に立たないでしょう。実装は、それが新しいI1パケットを送信することにより、再試行してください可能性がある後、おそらく整形式R1のためのいくつかのより多くの時間を待つべき。"
    },
    {
      "indent": 0,
      "text": "6.9. Processing of Incoming I2 Packets",
      "section_title": true,
      "ja": "6.9. 着信I2パケットの処理"
    },
    {
      "indent": 3,
      "text": "Upon receipt of an I2 packet, the system MAY perform initial checks to determine whether the I2 packet corresponds to a recent R1 packet that has been sent out, if the Responder keeps such state. For example, the sender could check whether the I2 packet is from an address or HIT for which the Responder has recently received an I1. The R1 packet may have had opaque data included that was echoed back in the I2 packet. If the I2 packet is considered to be suspect, it MAY be silently discarded by the system.",
      "ja": "I2パケットを受信すると、システムは、I2パケットをレスポンダがそのような状態を維持する場合、送出された最近R1パケットに対応するかどうかを決定するために、初期チェックを実行してもよいです。例えば、送信者はI2パケットがResponderが最近I1を受信したためにアドレスまたはHITからであるかどうかを確認できます。 R1パケットは不透明なデータはそれがI2パケットにエコーバックされた含ま持っていたかもしれません。 I2パケットが疑わしいと見なされた場合、それは静かに、システムによって破棄されることがあります。"
    },
    {
      "indent": 3,
      "text": "Otherwise, the HIP implementation SHOULD process the I2 packet. This includes validation of the puzzle solution, generating the Diffie-Hellman key, possibly decrypting the Initiator's Host Identity, verifying the signature, creating state, and finally sending an R2 packet.",
      "ja": "それ以外の場合は、HIPの実装はI2パケットを処理する必要があります。これはおそらく、イニシエータのホストIDを復号化署名を検証し、状態を作成し、最終的にはR2のパケットを送信する、のDiffie-Hellman鍵を生成、パズルソリューションの検証を含んでいます。"
    },
    {
      "indent": 3,
      "text": "The following steps define the conceptual processing rules for responding to an I2 packet:",
      "ja": "次のステップは、I2パケットに応答するための概念的な処理ルールを定義します。"
    },
    {
      "indent": 3,
      "text": "1. The system MAY perform checks to verify that the I2 packet corresponds to a recently sent R1 packet. Such checks are implementation dependent. See Appendix A for a description of an example implementation.",
      "ja": "1.システムは、I2パケットが最近送信されたR1パケットに対応することを確認するためにチェックを行うことができます。このようなチェックは実装に依存しています。実装例については、付録Aを参照してください。"
    },
    {
      "indent": 3,
      "text": "2. The system MUST check that the Responder's HIT corresponds to one of its own HITs and MUST drop the packet otherwise.",
      "ja": "2.システムは、レスポンダのHITは、自身のヒットの一つに対応し、そうでない場合はパケットを廃棄しなければならないことをチェックしなければなりません。"
    },
    {
      "indent": 3,
      "text": "3. The system MUST further check that the Initiator's HIT Suite is supported. The Responder SHOULD silently drop I2 packets with unsupported Initiator HITs.",
      "ja": "3.システムはさらに、イニシエータのHITスイートがサポートされていることをチェックしなければなりません。 Responderは静かにサポートされていないイニシエータヒットとI2パケットをドロップすべきです。"
    },
    {
      "indent": 3,
      "text": "4. If the system's state machine is in the R2-SENT state, the system MAY check to see if the newly received I2 packet is similar to the one that triggered moving to R2-SENT. If so, it MAY retransmit a previously sent R2 packet and reset the R2-SENT timer, and the state machine stays in R2-SENT.",
      "ja": "4.システムのステートマシンは、R2-SENT状態にある場合、システムは、新たに受信したI2パケットがR2-SENTに移動トリガものと類似しているかどうかを確認するかもしれません。もしそうなら、それは以前に送られたR2のパケットを再送信し、R2-SENTタイマーをリセットし、ステートマシンは、R2-SENTにとどまるかもしれません。"
    },
    {
      "indent": 3,
      "text": "5. If the system's state machine is in the I2-SENT state, the system MUST make a comparison between its local and sender's HITs (similar to the comparison method described in Section 6.5). If the local HIT is smaller than the sender's HIT, it should drop the I2 packet, use the peer Diffie-Hellman key and nonce #I from the R1 packet received earlier, and get the local Diffie-Hellman key and nonce #J from the I2 packet sent to the peer earlier. Otherwise, the system should process the received I2 packet and drop any previously derived Diffie-Hellman keying material Kij it might have formed upon sending the I2 packet previously. The peer Diffie-Hellman key and the nonce #J are taken from the I2 packet that just arrived. The local Diffie-Hellman key and the nonce #I are the ones that were sent earlier in the R1 packet.",
      "ja": "5.システムの状態マシンはI2-SENT状態にある場合、システムは、ローカルと（セクション6.5に記載の比較法と同様に）送信者のヒットとの間の比較を行う必要があります。ローカルHITは、送信者のHITよりも小さい場合、それは先に受信R1パケットからピアのDiffie-Hellmanキーとナンス#Iを使用し、I2パケットをドロップし、より現地のDiffie-Hellmanキーとナンス#Jを取得する必要がありますI2パケットは、以前のピアに送信しました。そうしないと、システムは、受信I2パケットを処理し、Kijを、それが以前にI2パケットを送信する際に形成されている可能性のある以前に得られたのDiffie-Hellmanの鍵材料をドロップする必要があります。ピアのDiffie-Hellmanキーとナンスの#Jはちょうど到着I2パケットから取得されます。地元のDiffie-Hellmanキーとナンス#Iは、以前のR1パケットで送信されたものです。"
    },
    {
      "indent": 3,
      "text": "6. If the system's state machine is in the I1-SENT state, and the HITs in the I2 packet match those used in the previously sent I1 packet, the system uses this received I2 packet as the basis for the HIP association it was trying to form, and stops retransmitting I1 packets (provided that the I2 packet passes the additional checks below).",
      "ja": "6.システムの状態機械は、I1-SENT状態にあり、I2パケットにおけるヒットは、システムは、これが、それはしようとしていたHIPアソシエーションのベースとしてI2パケットを受信使用し、以前に送信されたI1パケットに使用されるものと一致した場合フォーム、およびI1パケットを再送信停止は、（I2パケットは、以下の追加チェックを通過することを条件とします）。"
    },
    {
      "indent": 3,
      "text": "7. If the system's state machine is in any state other than R2-SENT, the system SHOULD check that the echoed R1 generation counter in the I2 packet is within the acceptable range if the counter is included. Implementations MUST accept puzzles from the current generation and MAY accept puzzles from earlier generations. If the generation counter in the newly received I2 packet is outside the accepted range, the I2 packet is stale (and perhaps replayed) and SHOULD be dropped.",
      "ja": "7.システムの状態マシンはR2-SENT以外の状態にある場合、システムは、カウンタが含まれていれば、I2パケット内のエコーR1生成カウンタが許容範囲内であることを確認する必要があります。実装は、現在の世代からパズルを受け入れなければならないし、それ以前の世代からパズルを受け入れることができます。新たに受信I2パケットで生成カウンタが許容範囲外である場合、I2パケットが古い（おそらく再生）され、ドロップされるべきです。"
    },
    {
      "indent": 3,
      "text": "8. The system MUST validate the solution to the puzzle by computing the hash described in Section 5.3.3 using the same RHASH algorithm.",
      "ja": "8.システムは、同じRHASHアルゴリズムを使用して、セクション5.3.3に記載のハッシュを計算することによって、パズルの解決策を検証しなければなりません。"
    },
    {
      "indent": 3,
      "text": "9. The I2 packet MUST have a single value in the HIP_CIPHER parameter, which MUST match one of the values offered to the Initiator in the R1 packet.",
      "ja": "9. I2パケットがR1パケット内のイニシエータに提供される値のいずれかと一致する必要がありHIP_CIPHERパラメータの単一の値を有していなければなりません。"
    },
    {
      "indent": 3,
      "text": "10. The system must derive Diffie-Hellman keying material Kij based on the public value and Group ID in the DIFFIE_HELLMAN parameter. This key is used to derive the HIP association keys, as described in Section 6.5. If the Diffie-Hellman Group ID is unsupported, the I2 packet is silently dropped.",
      "ja": "10.システムはDIFFIE_HELLMANパラメータの公開値とグループIDに基づいてのDiffie-Hellmanの鍵材料Kijをを導き出す必要があります。セクション6.5で説明したように、このキーは、HIP関連鍵を導出するために使用されます。 Diffie-HellmanのグループIDがサポートされていない場合、I2パケットは黙って落とされます。"
    },
    {
      "indent": 3,
      "text": "11. The encrypted HOST_ID is decrypted by the Initiator's encryption key defined in Section 6.5. If the decrypted data is not a HOST_ID parameter, the I2 packet is silently dropped.",
      "ja": "11.暗号化HOST_IDは、6.5節で定義されたイニシエータの暗号化鍵で復号化されます。復号化されたデータは、HOST_IDパラメータでない場合は、I2パケットは黙って落とされます。"
    },
    {
      "indent": 3,
      "text": "12. The implementation SHOULD also verify that the Initiator's HIT in the I2 packet corresponds to the Host Identity sent in the I2 packet. (Note: some middleboxes may not be able to make this verification.)",
      "ja": "12.実装は、I2パケット内のイニシエータのHITはI2パケットで送信されたホストIDに対応していることを確認する必要があります。 （注：一部のミドルボックスは、この検証をすることができない場合があります。）"
    },
    {
      "indent": 3,
      "text": "13. The system MUST process the TRANSPORT_FORMAT_LIST parameter. Other documents specifying transport formats (e.g., [RFC7402]) contain specifications for handling any specific transport selected.",
      "ja": "13.システムがTRANSPORT_FORMAT_LISTパラメータを処理しなければなりません。 （例えば、[RFC7402]）トランスポートフォーマットを指定する他の文書が選択された任意の特定のトランスポートを処理するための仕様を含みます。"
    },
    {
      "indent": 3,
      "text": "14. The system MUST verify the HIP_MAC according to the procedures in Section 5.2.12.",
      "ja": "14.システムはセクション5.2.12の手順に従ってHIP_MACを確認しなければなりません。"
    },
    {
      "indent": 3,
      "text": "15. The system MUST verify the HIP_SIGNATURE according to Sections 5.2.14 and 5.3.3.",
      "ja": "15.システムは、セクション5.2.14及び5.3.3に従ってHIP_SIGNATUREを確認しなければなりません。"
    },
    {
      "indent": 3,
      "text": "16. If the checks above are valid, then the system proceeds with further I2 processing; otherwise, it discards the I2 and its state machine remains in the same state.",
      "ja": "16.上記のチェックが有効である場合、システムは、さらに、I2処理に進みます。それ以外の場合は、I2を破棄し、そのステートマシンは、同じ状態のままになります。"
    },
    {
      "indent": 3,
      "text": "17. The I2 packet may have the A-bit set -- in this case, the system MAY choose to refuse it by dropping the I2 and the state machine returns to state UNASSOCIATED. If the A-bit is set, the Initiator's HIT is anonymous and should not be stored permanently.",
      "ja": "この場合、システムは、関連付けられていない状態するI2とステートマシン戻りをドロップすることによって、それを拒否することを選ぶかもしれ -  17 I2パケットは、Aビットセットを有することができます。 Aビットがセットされている場合、イニシエータのHITは匿名で、恒久的に保存すべきではありません。"
    },
    {
      "indent": 3,
      "text": "18. The system initializes the remaining variables in the associated state, including Update ID counters.",
      "ja": "18.システムは、更新IDカウンタを含む関連状態における残りの変数を初期化します。"
    },
    {
      "indent": 3,
      "text": "19. Upon successful processing of an I2 message when the system's state machine is in state UNASSOCIATED, I1-SENT, I2-SENT, or R2-SENT, an R2 packet is sent and the system's state machine transitions to state R2-SENT.",
      "ja": "システムの状態マシンが関連付けられていない状態であるI2メッセージの成功処理すると19が、I1-SENT、I2-SENT、またはR2が-SENT、R2パケットが送信され、状態R2-SENTに、システムのステートマシン遷移されます。"
    },
    {
      "indent": 3,
      "text": "20. Upon successful processing of an I2 packet when the system's state machine is in state ESTABLISHED, the old HIP association is dropped and a new one is installed, an R2 packet is sent, and the system's state machine transitions to R2-SENT.",
      "ja": "システムの状態マシンが状態で確立されるとI2パケットの成功した処理時20は、R2-SENTに古いHIPの関連付けが削除され、新しいものがインストールされ、R2パケットが送信され、システムのステートマシン遷移します。"
    },
    {
      "indent": 3,
      "text": "21. Upon the system's state machine transitioning to R2-SENT, the system starts a timer. The state machine transitions to ESTABLISHED if some data has been received on the incoming HIP association, or an UPDATE packet has been received (or some other packet that indicates that the peer system's state machine has moved to ESTABLISHED). If the timer expires (allowing for a maximal amount of retransmissions of I2 packets), the state machine transitions to ESTABLISHED.",
      "ja": "R2-SENTに、システムのステート・マシンの移行時21は、システムはタイマーを開始します。一部のデータが入ってくるHIPアソシエーション上で受信された場合に設立され、又はUPDATEパケットを受信したステートマシン遷移（またはピアシステムの状態機械がESTABLISHEDに移動したことを示すいくつかの他のパケット）。タイマーが満了した場合はESTABLISHEDステートマシンの遷移は、（I2パケットの再送信の最大量を可能にします）。"
    },
    {
      "indent": 0,
      "text": "6.9.1. Handling of Malformed Messages",
      "section_title": true,
      "ja": "6.9.1. 不正な形式のメッセージの処理"
    },
    {
      "indent": 3,
      "text": "If an implementation receives a malformed I2 message, the behavior SHOULD depend on how many checks the message has already passed. If the puzzle solution in the message has already been checked, the implementation SHOULD report the error by responding with a NOTIFY packet. Otherwise, the implementation MAY respond with an ICMP message as defined in Section 5.4.",
      "ja": "実装が不正な形式のI2メッセージを受信した場合、動作はメッセージが既に経過しているどのように多くのチェックに依存する必要があります。メッセージ中のパズルのソリューションは、すでに確認されている場合、実装はNOTIFYパケットで応答することで、エラーを報告する必要があります。セクション5.4で定義されているそれ以外の場合、実装はICMPメッセージで応答することができます。"
    },
    {
      "indent": 0,
      "text": "6.10. Processing of Incoming R2 Packets",
      "section_title": true,
      "ja": "6.10. 着信R2パケットの処理"
    },
    {
      "indent": 3,
      "text": "An R2 packet received in state UNASSOCIATED, I1-SENT, or ESTABLISHED results in the R2 packet being dropped and the state machine staying in the same state. If an R2 packet is received in state I2-SENT, it MUST be processed.",
      "ja": "R2パケットにおいて、I1-SENT、または確立R2パケットが関連付けられていない状態で受信された結果は、ドロップされると、状態マシンは、同じ状態に滞在します。 R2パケットは状態I2-SENTに受信された場合、それが処理しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The following steps define the conceptual processing rules for an incoming R2 packet:",
      "ja": "次のステップは、着信R2パケットの概念的な処理ルールを定義します。"
    },
    {
      "indent": 3,
      "text": "1. If the system is in any state other than I2-SENT, the R2 packet is silently dropped.",
      "ja": "1.システムがI2-SENT以外の状態にある場合、R2パケットがサイレントドロップされます。"
    },
    {
      "indent": 3,
      "text": "2. The system MUST verify that the HITs in use correspond to the HITs that were received in the R1 packet that caused the transition to the I1-SENT state.",
      "ja": "2.システムは、使用中のヒットがI1-SENT状態への遷移を引き起こしR1パケットで受信されたヒットに対応することを確かめなければなりません。"
    },
    {
      "indent": 3,
      "text": "3. The system MUST verify the HIP_MAC_2 according to the procedures in Section 5.2.13.",
      "ja": "3.システムはセクション5.2.13の手順に従ってHIP_MAC_2を確認しなければなりません。"
    },
    {
      "indent": 3,
      "text": "4. The system MUST verify the HIP signature according to the procedures in Section 5.2.14.",
      "ja": "4.システムはセクション5.2.14の手順に従ってHIP署名を検証しなければなりません。"
    },
    {
      "indent": 3,
      "text": "5. If any of the checks above fail, there is a high probability of an ongoing man-in-the-middle or other security attack. The system SHOULD act accordingly, based on its local policy.",
      "ja": "5.上記のチェックのいずれか失敗した場合、現在進行中のman-in-the-middleまたは他のセキュリティ攻撃の可能性が高いです。システムは、ローカルポリシーに基づいて、それに従って行動しなければなりません。"
    },
    {
      "indent": 3,
      "text": "6. Upon successful processing of the R2 packet, the state machine transitions to state ESTABLISHED.",
      "ja": "R2パケットの成功した処理、設立された状態への状態マシン遷移時6。"
    },
    {
      "indent": 0,
      "text": "6.11. Sending UPDATE Packets",
      "section_title": true,
      "ja": "6.11.  UPDATEパケットを送信します"
    },
    {
      "indent": 3,
      "text": "A host sends an UPDATE packet when it intends to update some information related to a HIP association. There are a number of possible scenarios when this can occur, e.g., mobility management and rekeying of an existing ESP Security Association. The following paragraphs define the conceptual rules for sending an UPDATE packet to the peer. Additional steps can be defined in other documents where the UPDATE packet is used.",
      "ja": "それはHIP協会に関連するいくつかの情報を更新しようとする場合は、ホストUPDATEパケットを送信します。これは、例えば、発生する可能性が考えられるシナリオの数、既存のESPセキュリティアソシエーションのモビリティ管理およびキーの再発行があります。以下の段落では、ピアに更新パケットを送信するための概念ルールを定義します。追加のステップは、UPDATEパケットが使用されている他のドキュメントで定義することができます。"
    },
    {
      "indent": 3,
      "text": "The sequence of UPDATE messages is indicated by their SEQ parameter. Before sending an UPDATE message, the system first determines whether there are any outstanding UPDATE messages that may conflict with the new UPDATE message under consideration. When multiple UPDATEs are outstanding (not yet acknowledged), the sender must assume that such UPDATEs may be processed in an arbitrary order by the receiver. Therefore, any new UPDATEs that depend on a previous outstanding UPDATE being successfully received and acknowledged MUST be postponed until reception of the necessary ACK(s) occurs. One way to prevent any conflicts is to only allow one outstanding UPDATE at a time. However, allowing multiple UPDATEs may improve the performance of mobility and multihoming protocols.",
      "ja": "UPDATEメッセージのシーケンスは、その配列パラメータで示されています。 UPDATEメッセージを送信する前に、システムが最初に検討中の新しいUPDATEメッセージと競合する可能性のある優れたUPDATEメッセージがあるかどうかを決定します。複数の更新が（まだ認めていない）未処理である場合、送信者はそのような更新は、受信機によって任意の順序で処理されてもよいことを想定しなければなりません。したがって、以前の未処理UPDATEに依存するすべての新しい更新が正常に受信され、必要に応じてACK（S）の受信が行われるまで延期されなければならない認めています。競合を防止するための一つの方法は、一度に1つの優れたUPDATEできるようにすることです。しかし、複数の更新を許可することは、モビリティとマルチホーミングプロトコルの性能を改善することができます。"
    },
    {
      "indent": 3,
      "text": "The following steps define the conceptual processing rules for sending UPDATE packets:",
      "ja": "次の手順は、更新パケットを送信するための概念的な処理ルールを定義します。"
    },
    {
      "indent": 3,
      "text": "1. The first UPDATE packet is sent with an Update ID of zero. Otherwise, the system increments its own Update ID value by one before continuing the steps below.",
      "ja": "1.最初の更新パケットは、ゼロの更新IDと送信されます。そうしないと、システムは、以下の手順を続行する前に1によって、自身のアップデートID値をインクリメントします。"
    },
    {
      "indent": 3,
      "text": "2. The system creates an UPDATE packet that contains a SEQ parameter with the current value of the Update ID. The UPDATE packet MAY also include zero or more ACKs of the peer's Update ID(s) from previously received UPDATE SEQ parameter(s).",
      "ja": "2.システムは、更新IDの電流値でSEQパラメータが含まれている更新パケットを作成します。更新パケットは、以前受信したUPDATE SEQパラメータ（単数または複数）からピアの更新ID（複数可）のゼロ個以上のACKを含むかもしれません。"
    },
    {
      "indent": 3,
      "text": "3. The system sends the created UPDATE packet and starts an UPDATE timer. The default value for the timer is 2 * RTT estimate. If multiple UPDATEs are outstanding, multiple timers are in effect.",
      "ja": "3.システムが作成したUPDATEパケットを送信し、UPDATEタイマーを開始します。タイマーのデフォルト値は2 * RTTの推定値です。複数の更新が傑出している場合は、複数のタイマが有効になります。"
    },
    {
      "indent": 3,
      "text": "4. If the UPDATE timer expires, the UPDATE is resent. The UPDATE can be resent UPDATE_RETRY_MAX times. The UPDATE timer SHOULD be exponentially backed off for subsequent retransmissions. If no acknowledgment is received from the peer after UPDATE_RETRY_MAX times, the HIP association is considered to be broken and the state machine SHOULD move from state ESTABLISHED to state CLOSING as depicted in Section 4.4.4. The UPDATE timer is cancelled upon receiving an ACK from the peer that acknowledges receipt of the UPDATE.",
      "ja": "4. UPDATEタイマーが期限切れになった場合、UPDATEが再送信されます。 UPDATEはUPDATE_RETRY_MAX時間を再送することができます。 UPDATEタイマーは指数関数的に、その後の再送信のためにオフにバックアップする必要があります。肯定応答がUPDATE_RETRY_MAX時間後のピアから受信されない場合、HIPの関連付けが破損していると考えられる、セクション4.4.4に示すように、状態マシンは状態閉鎖するために設立された状態から移動する必要があります。更新タイマは、UPDATEの受信を肯定応答するピアからのACKを受信すると解除されます。"
    },
    {
      "indent": 0,
      "text": "6.12. Receiving UPDATE Packets",
      "section_title": true,
      "ja": "6.12.  UPDATEパケットを受信"
    },
    {
      "indent": 3,
      "text": "When a system receives an UPDATE packet, its processing depends on the state of the HIP association and the presence and values of the SEQ and ACK parameters. Typically, an UPDATE message also carries optional parameters whose handling is defined in separate documents.",
      "ja": "システムは、更新パケットを受信した場合、その処理は、HIPアソシエーションとSEQとACKパラメータの存在及び値の状態に依存します。典型的には、UPDATEメッセージはまた、その取り扱い別の文書で定義されているオプションのパラメータを運びます。"
    },
    {
      "indent": 3,
      "text": "For each association, a host stores the peer's next expected in-sequence Update ID (\"peer Update ID\"). Initially, this value is zero. Update ID comparisons of \"less than\" and \"greater than\" are performed with respect to a circular sequence number space. Hence, a wraparound after 2^32 updates has to be expected and MUST be handled accordingly.",
      "ja": "各関連付けのため、ホスト記憶ピアの次の予想におけるシーケンス更新ID（「ピア更新ID」）。最初は、この値はゼロです。円形のシーケンス番号空間に対して実行され、「より大きい」、「未満」のIDの比較を更新します。したがって、2 ^ 32の更新後の回り込みが予想されなければならないし、それに応じて取り扱わなければなりません。"
    },
    {
      "indent": 3,
      "text": "The sender MAY send multiple outstanding UPDATE messages. These messages are processed in the order in which they are received at the receiver (i.e., no resequencing is performed). When processing",
      "ja": "送信者は、複数の未処理のUPDATEメッセージを送信することができます。これらのメッセージは、それらが受信機で受信された順序で処理される（すなわち、全く再配列決定は行われません）。処理するとき"
    },
    {
      "indent": 3,
      "text": "UPDATEs out of order, the receiver MUST keep track of which UPDATEs were previously processed, so that duplicates or retransmissions are ACKed and not reprocessed. A receiver MAY choose to define a receive window of Update IDs that it is willing to process at any given time, and discard received UPDATEs falling outside of that window.",
      "ja": "オーダーのうち更新、受信機は、重複や再送がACKされ、再処理されないように、更新が以前に、処理されたを追跡する必要があります。受信機は、任意の時点で処理する意思があることを更新IDの受信ウィンドウを定義するために選択し、そのウィンドウの外の受信した更新を捨てるかもしれ。"
    },
    {
      "indent": 3,
      "text": "The following steps define the conceptual processing rules for receiving UPDATE packets:",
      "ja": "次の手順は、更新パケットを受信するための概念的な処理ルールを定義します。"
    },
    {
      "indent": 3,
      "text": "1. If there is no corresponding HIP association, the implementation MAY reply with an ICMP Parameter Problem, as specified in Section 5.4.4.",
      "ja": "1.該当するHIPアソシエーションが存在しない場合、実装はセクション5.4.4で指定されるように、ICMPパラメータ問題に応答することができます。"
    },
    {
      "indent": 3,
      "text": "2. If the association is in the ESTABLISHED state and the SEQ (but not ACK) parameter is present, the UPDATE is processed and replied to as described in Section 6.12.1.",
      "ja": "アソシエーションがESTABLISHED状態とSEQ（ただしACK）パラメータが存在している場合2. UPDATEが処理され、セクション6.12.1に記載されているように返信されます。"
    },
    {
      "indent": 3,
      "text": "3. If the association is in the ESTABLISHED state and the ACK (but not SEQ) parameter is present, the UPDATE is processed as described in Section 6.12.2.",
      "ja": "3.アソシエーションが確立状態とACK（ただしSEQ）パラメータである場合、セクション6.12.2に記載されているようにUPDATEが処理され、存在しています。"
    },
    {
      "indent": 3,
      "text": "4. If the association is in the ESTABLISHED state and there are both an ACK and SEQ in the UPDATE, the ACK is first processed as described in Section 6.12.2, and then the rest of the UPDATE is processed as described in Section 6.12.1.",
      "ja": "4.アソシエーションがESTABLISHED状態にあり、ACKおよび配列の両方がアップデートである場合、セクション6.12.2に記載されているように、ACKが最初に処理され、そして、セクション6.12に記載されているように、更新の残りの部分が処理されます。 1。"
    },
    {
      "indent": 0,
      "text": "6.12.1. Handling a SEQ Parameter in a Received UPDATE Message",
      "section_title": true,
      "ja": "6.12.1. 受信したUPDATEメッセージでSEQパラメータの処理"
    },
    {
      "indent": 3,
      "text": "The following steps define the conceptual processing rules for handling a SEQ parameter in a received UPDATE packet:",
      "ja": "次のステップは、受信された更新パケット内SEQパラメータを処理するための概念的な処理ルールを定義します。"
    },
    {
      "indent": 3,
      "text": "1. If the Update ID in the received SEQ is not the next in the sequence of Update IDs and is greater than the receiver's window for new UPDATEs, the packet MUST be dropped.",
      "ja": "1.受け取った配列で更新IDは、更新IDの順序で次のものではなく、新しいアップデートを受信側のウィンドウよりも大きい場合、パケットは廃棄されなければなりません。"
    },
    {
      "indent": 3,
      "text": "2. If the Update ID in the received SEQ corresponds to an UPDATE that has recently been processed, the packet is treated as a retransmission. The HIP_MAC verification (next step) MUST NOT be skipped. (A byte-by-byte comparison of the received packet and a stored packet would be acceptable, though.) It is recommended that a host caches UPDATE packets sent with ACKs to avoid the cost of generating a new ACK packet to respond to a replayed UPDATE. The system MUST acknowledge, again, such (apparent) UPDATE message retransmissions but SHOULD also consider rate-limiting such retransmission responses to guard against replay attacks.",
      "ja": "2.受信SEQで更新IDは最近のパケットを再送として処理され、処理された更新に対応する場合。 HIP_MAC検証（次のステップ）をスキップしてはなりません。 （受信したパケットのバイト単位の比較および格納されたパケットは、しかし、許容可能である。）これは、ホストキャッシュの更新パケットが再生に対応するため、新たなACKパケットを生成するコストを回避するためのACKを送信していることをお勧めします更新。このシステムは、再び、そのような（見かけの）UPDATEメッセージの再送を確認する必要がありますが、また、リプレイ攻撃を防ぐための律速な再送応答を検討すべきです。"
    },
    {
      "indent": 3,
      "text": "3. The system MUST verify the HIP_MAC in the UPDATE packet. If the verification fails, the packet MUST be dropped.",
      "ja": "3.システムがUPDATEパケットにHIP_MACを確かめなければなりません。検証が失敗した場合、パケットは廃棄されなければなりません。"
    },
    {
      "indent": 3,
      "text": "4. The system MAY verify the SIGNATURE in the UPDATE packet. If the verification fails, the packet SHOULD be dropped and an error message logged.",
      "ja": "4.システムはUPDATEパケット内の署名を検証することができます。検証が失敗した場合、パケットは廃棄されるべきであるとのエラーメッセージが記録されます。"
    },
    {
      "indent": 3,
      "text": "5. If a new SEQ parameter is being processed, the parameters in the UPDATE are then processed. The system MUST record the Update ID in the received SEQ parameter, for replay protection.",
      "ja": "5.新しいSEQパラメータが処理されている場合は、UPDATE内のパラメータが、その後に処理されます。システムは、再生保護のために、受け取ったSEQパラメータの更新IDを記録しなければなりません。"
    },
    {
      "indent": 3,
      "text": "6. An UPDATE acknowledgment packet with the ACK parameter is prepared and sent to the peer. This ACK parameter MAY be included in a separate UPDATE or piggybacked in an UPDATE with the SEQ parameter, as described in Section 5.3.5. The ACK parameter MAY acknowledge more than one of the peer's Update IDs.",
      "ja": "ACKパラメータ6. UPDATE確認パケットを調製し、ピアに送信されます。セクション5.3.5に記載したように、このACKパラメータは、別の更新プログラムに含まれる、またはSEQパラメータでUPDATEにピギーバックされるかもしれません。 ACKパラメータは、ピアのアップデートIDの複数のを確認してもよいです。"
    },
    {
      "indent": 0,
      "text": "6.12.2. Handling an ACK Parameter in a Received UPDATE Packet",
      "section_title": true,
      "ja": "6.12.2. 受信した更新パケット内のACKパラメータの処理"
    },
    {
      "indent": 3,
      "text": "The following steps define the conceptual processing rules for handling an ACK parameter in a received UPDATE packet:",
      "ja": "次のステップは、受信された更新パケット内のACKパラメータを処理するための概念的な処理ルールを定義します。"
    },
    {
      "indent": 3,
      "text": "1. The sequence number reported in the ACK must match with an UPDATE packet sent earlier that has not already been acknowledged. If no match is found or if the ACK does not acknowledge a new UPDATE, then either the packet MUST be dropped if no SEQ parameter is present, or the processing steps in Section 6.12.1 are followed.",
      "ja": "1. ACKで報告されたシーケンス番号がすでに確認されていない以前送られたUPDATEパケットと一致している必要があります。一致が見つからない場合、またはACKが、新しいUPDATEを認めない場合はどちらかのパケットが廃棄されなければならない場合は、配列のパラメータが存在しない、またはセクション6.12.1での処理工程が続いている場合。"
    },
    {
      "indent": 3,
      "text": "2. The system MUST verify the HIP_MAC in the UPDATE packet. If the verification fails, the packet MUST be dropped.",
      "ja": "2.システムがUPDATEパケットにHIP_MACを確かめなければなりません。検証が失敗した場合、パケットは廃棄されなければなりません。"
    },
    {
      "indent": 3,
      "text": "3. The system MAY verify the SIGNATURE in the UPDATE packet. If the verification fails, the packet SHOULD be dropped and an error message logged.",
      "ja": "3.システムがUPDATEパケット内の署名を検証することができます。検証が失敗した場合、パケットは廃棄されるべきであるとのエラーメッセージが記録されます。"
    },
    {
      "indent": 3,
      "text": "4. The corresponding UPDATE timer is stopped (see Section 6.11) so that the now-acknowledged UPDATE is no longer retransmitted. If multiple UPDATEs are acknowledged, multiple timers are stopped.",
      "ja": "今-認めUPDATEはもはや再送さになるように4対応UPDATEタイマーは（6.11節を参照）が停止されていません。複数の更新が確認されている場合は、複数のタイマが停止されています。"
    },
    {
      "indent": 0,
      "text": "6.13. Processing of NOTIFY Packets",
      "section_title": true,
      "ja": "6.13.  NOTIFYパケットの処理"
    },
    {
      "indent": 3,
      "text": "Processing of NOTIFY packets is OPTIONAL. If processed, any errors in a received NOTIFICATION parameter SHOULD be logged. Received errors MUST be considered only as informational, and the receiver SHOULD NOT change its HIP state (see Section 4.4.2) purely based on the received NOTIFY message.",
      "ja": "NOTIFYパケットの処理は任意です。処理された場合は、受信した通知パラメータにエラーが記録されるべきです。純粋にNOTIFYメッセージを受信に基づいて（4.4.2項を参照）を受信したエラーは情報提供のみと考えなければなりませんし、受信機は、そのHIP状態を変更しないでください。"
    },
    {
      "indent": 0,
      "text": "6.14. Processing of CLOSE Packets",
      "section_title": true,
      "ja": "6.14.  CLOSEパケットの処理"
    },
    {
      "indent": 3,
      "text": "When the host receives a CLOSE message, it responds with a CLOSE_ACK message and moves to the CLOSED state. (The authenticity of the CLOSE message is verified using both HIP_MAC and SIGNATURE.) This processing applies whether or not the HIP association state is CLOSING, in order to handle simultaneous CLOSE messages from both ends that cross in flight.",
      "ja": "ホストは、CLOSEメッセージを受信すると、CLOSE_ACKメッセージで応答し、CLOSED状態に移行します。 （CLOSEメッセージの真正性をHIP_MACと署名の両方を使用して検証される。）この処理は、HIP関連状態が飛行中交差両端から同時にCLOSEメッセージを処理するために、閉じているか否かを適用します。"
    },
    {
      "indent": 3,
      "text": "The HIP association is not discarded before the host moves to the UNASSOCIATED state.",
      "ja": "ホストが関連付けられていない状態に移行する前にHIPの関連付けが破棄されていません。"
    },
    {
      "indent": 3,
      "text": "Once the closing process has started, any new need to send data packets triggers the creation and establishment of a new HIP association, starting with sending an I1 packet.",
      "ja": "クローズ処理が開始されると、データ・パケットを送信するために、新しい必要がI1パケットを送信することから始まる、新しいHIP協会の作成と確立をトリガします。"
    },
    {
      "indent": 3,
      "text": "If there is no corresponding HIP association, the CLOSE packet is dropped.",
      "ja": "該当するHIPの関連付けがない場合は、CLOSEパケットはドロップされます。"
    },
    {
      "indent": 0,
      "text": "6.15. Processing of CLOSE_ACK Packets",
      "section_title": true,
      "ja": "6.15.  CLOSE_ACKパケットの処理"
    },
    {
      "indent": 3,
      "text": "When a host receives a CLOSE_ACK message, it verifies that it is in the CLOSING or CLOSED state and that the CLOSE_ACK was in response to the CLOSE. A host can map CLOSE_ACK messages to CLOSE messages by comparing the value of ECHO_REQUEST_SIGNED (in the CLOSE packet) to the value of ECHO_RESPONSE_SIGNED (in the CLOSE_ACK packet).",
      "ja": "ホストはCLOSE_ACKメッセージを受信すると、それは閉じたり閉じた状態にし、CLOSE_ACKがCLOSEに応答したことであることを検証します。ホストは、（CLOSE_ACKパケットに）ECHO_RESPONSE_SIGNEDの値（CLOSEパケットに）ECHO_REQUEST_SIGNEDの値を比較することによって、メッセージを閉じCLOSE_ACKメッセージをマッピングすることができます。"
    },
    {
      "indent": 3,
      "text": "The CLOSE_ACK contains the HIP_MAC and the SIGNATURE parameters for verification. The state is discarded when the state changes to UNASSOCIATED and, after that, the host MAY respond with an ICMP Parameter Problem to an incoming CLOSE message (see Section 5.4.4).",
      "ja": "CLOSE_ACKはHIP_MACと検証のためSIGNATUREパラメータが含まれています。状態が関連付けられていないにするときの状態変化を破棄され、その後、ホストは（5.4.4項を参照）、着信CLOSEメッセージにICMPパラメータ問題で応答することができます。"
    },
    {
      "indent": 0,
      "text": "6.16. Handling State Loss",
      "section_title": true,
      "ja": "6.16. 国家の損失の取り扱い"
    },
    {
      "indent": 3,
      "text": "In the case of a system crash and unanticipated state loss, the system SHOULD delete the corresponding HIP state, including the keying material. That is, the state SHOULD NOT be stored in long-term storage. If the implementation does drop the state (as RECOMMENDED), it MUST also drop the peer's R1 generation counter value, unless a local policy explicitly defines that the value of that particular host is stored. An implementation MUST NOT store a peer's R1 generation counters by default, but storing R1 generation counter values, if done, MUST be configured by explicit HITs.",
      "ja": "システムクラッシュや予期しない状態の損失の場合には、システムは、キーイング材料を含む、対応するHIP状態を削除する必要があります。つまり、状態が長期保存に保存しないでください。実装は（推奨されるように）状態をドロップした場合、ローカルポリシーが明示的にその特定のホストの値が格納されていることを定義していない限り、それはまた、ピアのR1世代カウンタ値を削除する必要があります。実装は、デフォルトでは、ピアのR1世代カウンタを格納してはいけませんが、R1生成カウンタ値を格納し、行われた場合、明示的なヒットで構成しなければなりません。"
    },
    {
      "indent": 0,
      "text": "7. HIP Policies",
      "section_title": true,
      "ja": "7. HIPポリシー"
    },
    {
      "indent": 3,
      "text": "There are a number of variables that will influence the HIP base exchanges that each host must support. All HIP implementations MUST support more than one simultaneous HI, at least one of which SHOULD be reserved for anonymous usage. Although anonymous HIs will be rarely used as Responders' HIs, they will be common for Initiators. Support for more than two HIs is RECOMMENDED.",
      "ja": "各ホストがサポートしなければならないHIPベースの交流に影響を与える変数の数があります。すべてのHIP実装は、複数の同時HI、匿名の使用のために確保すべきで少なくとも一つをサポートしなければなりません。匿名ものの、彼はめったにレスポンダとして使用されることはありません彼の、彼らは、イニシエータの共通となります。二つ以上の彼のサポートが推奨されます。"
    },
    {
      "indent": 3,
      "text": "Initiators MAY use a different HI for different Responders to provide basic privacy. Whether such private HIs are used repeatedly with the same Responder, and how long these HIs are used, are decided by local policy and depend on the privacy requirements of the Initiator.",
      "ja": "開始剤は、基本的なプライバシーを提供するために、異なるレスポンダに異なるHIを使用するかもしれません。こうした民間のかどうか、彼は同じレスポンダで繰り返し使用され、どのくらいこれらの彼の使用している、ローカルポリシーによって決定され、イニシエータのプライバシー要件に依存しています。"
    },
    {
      "indent": 3,
      "text": "The value of #K used in the HIP R1 must be chosen with care. Values of #K that are too high will exclude clients with weak CPUs because these devices cannot solve the puzzle within a reasonable amount of time. #K should only be raised if a Responder is under high load, i.e., it cannot process all incoming HIP handshakes any more. If a Responder is not under high load, #K SHOULD be 0.",
      "ja": "HIP R1で使用される＃Kの値は慎重に選択する必要があります。これらのデバイスは、妥当な時間内のパズルを解くことができないため、高すぎる＃Kの値が弱いのCPUを搭載したクライアントを除外します。 #Kは、レスポンダが高負荷下にある場合、すなわち、それはもはやすべての着信HIPハンドシェークを処理できない上昇させるべきです。 Responderが高負荷でない場合には、＃Kは0にしてください。"
    },
    {
      "indent": 3,
      "text": "Responders that only respond to selected Initiators require an Access Control List (ACL), representing for which hosts they accept HIP base exchanges, and the preferred transport format and local lifetimes. Wildcarding SHOULD be supported for such ACLs, and also for Responders that offer public or anonymous services.",
      "ja": "のみ選択イニシエータに応答する応答は、それらがHIP基本交換を受け入れるホスト、好ましいトランスポートフォーマットとローカル寿命のために示す、アクセス制御リスト（ACL）を必要とします。ワイルドカードは、ACLのためにサポートし、また公共または匿名のサービスを提供するレスポンダのためにする必要があります。"
    },
    {
      "indent": 0,
      "text": "8. Security Considerations",
      "section_title": true,
      "ja": "8.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "HIP is designed to provide secure authentication of hosts. HIP also attempts to limit the exposure of the host to various denial-of-service and man-in-the-middle (MitM) attacks. In doing so, HIP itself is subject to its own DoS and MitM attacks that potentially could be more damaging to a host's ability to conduct business as usual.",
      "ja": "HIPは、ホストの安全な認証を提供するように設計されています。 HIPは、様々なサービス拒否とMITM（中間者）攻撃に対する宿主の曝露を制限しようとします。そうすることで、HIP自体が潜在的に通常通り業務を遂行するために、ホストの能力によりダメージを与える可能性があり、独自のDoSとのMitM攻撃の対象となります。"
    },
    {
      "indent": 3,
      "text": "Denial-of-service attacks often take advantage of asymmetries in the cost of starting an association. One example of such asymmetry is the need of a Responder to store local state while a malicious Initiator can stay stateless. HIP makes no attempt to increase the cost of the start of state at the Initiator, but makes an effort to reduce the cost for the Responder. This is accomplished by having the Responder start the 3-way exchange instead of the Initiator, making the HIP exchange 4 packets long. In doing this, the first packet from the Responder, R1, becomes a 'stock' packet that the Responder MAY use many times, until some Initiator has provided a valid response to such an R1 packet. During an I1 packet storm, the host may reuse the same DH value also, even if some Initiator has provided a valid response using that particular DH value. However, such behavior is discouraged and should be avoided. Using the same Diffie-Hellman values and random puzzle #I value has some risks. This risk needs to be balanced against a potential storm of HIP I1 packets.",
      "ja": "DoS攻撃は、多くの場合、関連付けを開始するコストに非対称性を利用します。そのような非対称性の一例は、悪質なイニシエータはステートレス滞在することができますしながら、ローカルの状態を保存するレスポンダが必要です。 HIPは、イニシエータの状態の開始のコストを増加させる試みませんが、レスポンダのためのコストを削減する努力をします。これは、レスポンダはなく、開始剤の3ウェイ交換を開始有する4パケット長HIP交換を行うことによって達成されます。これを行うには、レスポンダ、R1、からの最初のパケットは、いくつかのイニシエータは、R1パケットに有効な応答を提供するまでResponderが、何回も使用するかもしれ「株式」のパケットになります。 I1パケットストームの間、ホストは、いくつかのイニシエータがその特定のDH値を使用して、有効な応答を提供した場合であっても、また同一のDH値を再利用してもよいです。しかし、そのような行動は推奨されており、避けるべきです。同じのDiffie-Hellman値とランダムパズル#I値を使用すると、いくつかのリスクがあります。このリスクはHIPのI1パケットの潜在的な嵐とのバランスする必要があります。"
    },
    {
      "indent": 3,
      "text": "This shifting of the start of state cost to the Initiator in creating the I2 HIP packet presents another DoS attack. The attacker can spoof the I1 packet, and the Responder sends out the R1 HIP packet. This could conceivably tie up the 'Initiator' with evaluating the R1 HIP packet, and creating the I2 packet. The defense against this attack is to simply ignore any R1 packet where a corresponding I1 packet was not sent (as defined in Section 6.8, step 1).",
      "ja": "I2のHIPパケットを作成するためのイニシエータへの状態コストの開始のこのシフトは、別のDoS攻撃を提示します。攻撃者は、I1パケットを偽装することができ、およびレスポンダは、R1のHIPパケットを送信します。これはおそらく、R1のHIPパケットを評価し、そしてI2パケットを作成して「イニシエータ」をタイアップができます。この攻撃に対する防御は、単に（セクション6.8、ステップ1で定義されるように）対応するI1パケットが送信されなかった任意R1パケットを無視することです。"
    },
    {
      "indent": 3,
      "text": "The R1 packet is considerably larger than the I1 packet. This asymmetry can be exploited in a reflection attack. A malicious attacker could spoof the IP address of a victim and send a flood of I1 messages to a powerful Responder. For each small I1 packet, the Responder would send a larger R1 packet to the victim. The difference in packet sizes can further amplify a flooding attack against the victim. To avoid such reflection attacks, the Responder SHOULD rate-limit the sending of R1 packets in general or SHOULD rate-limit the sending of R1 packets to a specific IP address.",
      "ja": "R1パケットがI1パケットよりもかなり大きいです。この非対称性は、反射攻撃に悪用される可能性があります。悪意のある攻撃者は、被害者のIPアドレスを偽装し、強力なレスポンダにI1メッセージの洪水を送信することができます。各小I1パケットの場合、Responderが被害者に大きなR1パケットを送信します。パケットサイズの差は、さらに被害者に対してフラッディング攻撃を増幅することができます。このような反射攻撃を避けるために、レスポンダは、一般に、R1パケットの送信をレート制限すべきであるまたは特定のIPアドレスにR1パケットの送信を制限を評価すべきです。"
    },
    {
      "indent": 3,
      "text": "Floods of forged I2 packets form a second kind of DoS attack. Once the attacking Initiator has solved the puzzle, it can send packets with spoofed IP source addresses with either an invalid HIP signature or invalid encrypted HIP payload (in the ENCRYPTED parameter). This would take resources in the Responder's part to reach the point to discover that the I2 packet cannot be completely processed. The defense against this attack is that after N bad I2 packets with the same puzzle solution, the Responder would discard any I2 packets that contain the given solution. This will shut down the attack. The attacker would have to request another R1 packet and use that to launch a new attack. The Responder could increase the value of #K while under attack. Keeping a list of solutions from malformed packets requires that the Responder keeps state for these malformed I2 packets. This state has to be kept until the R1 counter is increased. As malformed packets are generally filtered by their checksum before signature verification, only solutions in packets that are forged to pass the checksum and puzzle are put into the blacklist. In addition, a valid puzzle is required before a new list entry is created. Hence, attackers that intend to flood the blacklist must solve puzzles first.",
      "ja": "偽造I2パケットの洪水は、DoS攻撃の第二種を形成します。攻撃イニシエータは、パズルを解いていたら、それは無効なHIP署名または（暗号化されたパラメータで）無効な暗号化されたHIPペイロードのいずれかで偽装されたIP送信元アドレスを持つパケットを送信することができます。これは、I2パケットが完全に処理できないことを発見するためのポイントに到達するためにレスポンダの一部のリソースを取るだろう。この攻撃に対する防御は同じパズルソリューションとNの悪いI2パケットの後、Responderが与えられたソリューションが含まれている任意のI2パケットを捨てるだろうということです。これは、攻撃をシャットダウンします。攻撃者は、別のR1パケットを要求し、新しい攻撃を開始するためにそれを使用する必要があります。攻撃を受けながら、Responderは＃Kの値を増加させる可能性があります。不正な形式のパケットからのソリューションのリストを維持するResponderがこれらの不正な形式のI2パケットの状態を保つことが必要です。この状態は、R1カウンタが増加されるまで保持する必要があります。不正な形式のパケットは、一般的に署名検証の前にそのチェックサムによってフィルタリングされたように、チェックサムとパズルを渡すために偽造されたパケットの唯一の解決策は、ブラックリストに入れています。新しいリストのエントリが作成される前に加えて、有効なパズルが必要です。このため、ブラックリストをあふれさせるつもり攻撃者は、最初のパズルを解く必要があります。"
    },
    {
      "indent": 3,
      "text": "A third form of DoS attack is emulating the restart of state after a reboot of one of the peers. A restarting host would send an I1 packet to the peers, which would respond with an R1 packet even if it were in the ESTABLISHED state. If the I1 packet were spoofed, the resulting R1 packet would be received unexpectedly by the spoofed host and would be dropped, as in the first case above.",
      "ja": "DoS攻撃の第三の形態は、ピアの1つの再起動後の状態の再起動をエミュレートしています。再起動するホストは、それがESTABLISHED状態にあった場合でも、R1パケットで応答するピアにI1パケットを送信します。 I1パケットが偽装された場合、得られたR1パケットがスプーフィングされたホストが予期せずに受信されると、上記第一の場合のように、ドロップされることになります。"
    },
    {
      "indent": 3,
      "text": "A fourth form of DoS attack is emulating the closing of the HIP association. HIP relies on timers and a CLOSE/CLOSE_ACK handshake to explicitly signal the end of a HIP association. Because both CLOSE and CLOSE_ACK messages contain a HIP_MAC, an outsider cannot close a connection. The presence of an additional SIGNATURE allows middleboxes to inspect these messages and discard the associated state (e.g., for firewalling, SPI-based NATing, etc.). However, the optional behavior of replying to CLOSE with an ICMP Parameter Problem packet (as described in Section 5.4.4) might allow an attacker spoofing the source IP address to send CLOSE messages to launch reflection attacks.",
      "ja": "DoS攻撃の第四の形態は、HIP協会の閉鎖をエミュレートしています。 HIPは、明示的にHIPアソシエーションの終了を知らせるタイマーとCLOSE / CLOSE_ACKハンドシェイクに依存しています。 CLOSEとCLOSE_ACKメッセージの両方がHIP_MACが含まれているため、部外者には、接続を閉じることができません。追加SIGNATUREの存在は、中間装置は、これらのメッセージを検査し、関連する状態（例えば、ファイアウォールのために、SPIベースのNAT変換、等）を破棄することを可能にします。しかし、（セクション5.4.4で説明したように）ICMPパラメータ問題パケットと密接に返信のオプションの動作は、送信元IPアドレスを偽装攻撃者は反射攻撃を開始するためにCLOSEメッセージを送信することを可能にするかもしれません。"
    },
    {
      "indent": 3,
      "text": "A fifth form of DoS attack is replaying R1s to cause the Initiator to solve stale puzzles and become out of synchronization with the Responder. The R1 generation counter is a monotonically increasing counter designed to protect against this attack, as described in Section 4.1.4.",
      "ja": "DoS攻撃の第五の形式は、古いパズルを解くとレスポンダとの同期外れになるためのイニシエータを引き起こすのR1を再生されます。 R1生成カウンタは、第4.1.4項で説明したように、この攻撃から保護するために設計された単調に増加するカウンタです。"
    },
    {
      "indent": 3,
      "text": "Man-in-the-middle attacks are difficult to defend against, without third-party authentication. A skillful MitM could easily handle all parts of HIP, but HIP indirectly provides the following protection from a MitM attack. If the Responder's HI is retrieved from a signed DNS zone, a certificate, or through some other secure means, the Initiator can use this to validate the R1 HIP packet.",
      "ja": "man-in-the-middle攻撃は、サードパーティの認証なし、防御することは困難です。熟練のMitMは簡単HIPのすべての部分を扱うことができますが、HIPは、間接的にのMITM攻撃から、次の保護を提供します。レスポンダのHIが署名DNSゾーン、証明書から取得された場合、またはいくつかの他の安全な手段を通じて、イニシエータは、R1のHIPパケットを検証するためにこれを使用することができます。"
    },
    {
      "indent": 3,
      "text": "Likewise, if the Initiator's HI is in a secure DNS zone, a trusted certificate, or otherwise securely available, the Responder can retrieve the HI (after having got the I2 HIP packet) and verify that the HI indeed can be trusted.",
      "ja": "イニシエータのHIは、セキュアなDNSゾーン、信頼できる証明書、またはその他の安全利用可能である場合には同様に、Responderは（I2のHIPパケットを得た後）HIを取得し、HIが実際に信頼することができることを確認することができます。"
    },
    {
      "indent": 3,
      "text": "The HIP \"opportunistic mode\" concept has been introduced in this document, but this document does not specify what the semantics of such a connection setup are for applications. There are certain concerns with opportunistic mode, as discussed in Section 4.1.8.",
      "ja": "HIP「日和見モード」という概念は、このドキュメントで紹介されていますが、この文書では、このような接続設定のセマンティクスはアプリケーションのためのものであるかを指定しません。セクション4.1.8で説明したように日和見モードで特定の懸念があります。"
    },
    {
      "indent": 3,
      "text": "NOTIFY messages are used only for informational purposes, and they are unacknowledged. A HIP implementation cannot rely solely on the information received in a NOTIFY message because the packet may have been replayed. An implementation SHOULD NOT change any state information purely based on a received NOTIFY message.",
      "ja": "NOTIFYメッセージは情報提供のみを目的に使用される、と彼らは未確認ですされています。パケットが再生されている可能性があるため、HIPの実装では、NOTIFYメッセージで受信した情報のみに依存することはできません。実装は純粋にNOTIFYメッセージを受信に基づいてすべての状態情報を変更するべきではありません。"
    },
    {
      "indent": 3,
      "text": "Since not all hosts will ever support HIP, ICMP 'Destination Protocol Unreachable' messages are to be expected and may be used for a DoS attack. Against an Initiator, the attack would look like the Responder does not support HIP, but shortly after receiving the ICMP message, the Initiator would receive a valid R1 HIP packet. Thus, to protect against this attack, an Initiator SHOULD NOT react to an ICMP message until a reasonable delta time to get the real Responder's R1 HIP packet. A similar attack against the Responder is more involved. Normally, if an I1 message received by a Responder was a bogus one sent by an attacker, the Responder may receive an ICMP message from the IP address the R1 message was sent to. However, a sophisticated attacker can try to take advantage of such behavior and try to break up the HIP base exchange by sending such an ICMP message to the Responder before the Initiator has a chance to send a valid I2 message. Hence, the Responder SHOULD NOT act on such an ICMP message. Especially, it SHOULD NOT remove any minimal state created when it sent the R1 HIP packet (if it did create one), but wait for either a valid I2 HIP packet or the natural timeout (that is, if R1 packets are tracked at all). Likewise, the Initiator SHOULD ignore any ICMP message while waiting for an R2 HIP packet, and SHOULD delete any pending state only after a natural timeout.",
      "ja": "いないすべてのホストがこれまでにHIPをサポートしていますので、ICMP「宛先プロトコル到達不能」メッセージが予想されるとDoS攻撃のために使用することができます。イニシエータに対して、攻撃はHIPをサポートしていないレスポンダのように見えるだろうが、すぐにICMPメッセージを受信した後、イニシエータは、有効なR1のHIPパケットを受け取ることになります。したがって、この攻撃から保護するために、イニシエータは、実際のレスポンダのR1のHIPパケットを取得するには、合理的なデルタ時間まで、ICMPメッセージに反応してはなりません。レスポンダに対する同様の攻撃はより複雑です。レスポンダによって受信I1メッセージが攻撃者によって送信された偽のものであった場合、通常、レスポンダは、R1のメッセージが送られたIPアドレスからのICMPメッセージを受信することができます。しかし、洗練された攻撃者は、このような行動を利用しようとすると、イニシエータが有効なI2メッセージを送信する機会を得る前にレスポンダに、このようなICMPメッセージを送信することにより、HIP基本交換を破るしようとすることができます。したがって、Responderは、このようなICMPメッセージに基づいて行動すべきではありません。特に、それは（それが1を作成しなかった場合）、それはR1のHIPパケットを送信したときに作成された最小限の状態を削除しますが、有効なI2のHIPパケットまたは自然のタイムアウトのいずれかを待つべきではありません（R1パケットがすべてで追跡している場合には、あります） 。同様に、イニシエータは、R2のHIPパケットを待っている間に任意のICMPメッセージを無視すべきである、とだけ自然のタイムアウトの後、保留中の状態を削除する必要があります。"
    },
    {
      "indent": 0,
      "text": "9. IANA Considerations",
      "section_title": true,
      "ja": "9. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "IANA has reserved protocol number 139 for the Host Identity Protocol and included it in the \"IPv6 Extension Header Types\" registry [RFC7045] and the \"Assigned Internet Protocol Numbers\" registry. The reference in both of these registries has been updated from [RFC5201] to this specification.",
      "ja": "IANAは、ホスト識別プロトコルのためのプロトコル番号139を予約し、「IPv6拡張ヘッダータイプ」レジストリ[RFC7045]と「割り当てられたインターネットプロトコル番号」レジストリにそれを含めています。これらのレジストリの両方における参照は、本明細書に[RFC5201]から更新されました。"
    },
    {
      "indent": 3,
      "text": "The reference to the 128-bit value under the CGA Message Type namespace [RFC3972] of \"0xF0EF F02F BFF4 3D0F E793 0C3C 6E61 74EA\" has been changed from [RFC5201] to this specification.",
      "ja": "「0xF0EF F02F BFF4 3D0F E793 0C3C 6E61 74EA」のCGAメッセージタイプネームスペース[RFC3972]の下で、128ビットの値を参照し、本明細書に[RFC5201]から変更されています。"
    },
    {
      "indent": 3,
      "text": "The following changes to the \"Host Identity Protocol (HIP) Parameters\" have been made. In many cases, the changes involved updating the reference from [RFC5201] to this specification, but there are some differences as outlined below. Allocation terminology is defined in [RFC5226]; any existing references to \"IETF Consensus\" can be replaced with \"IETF Review\" as per [RFC5226].",
      "ja": "「ホストアイデンティティプロトコル（HIP）パラメータ」に以下の変更が行われました。多くの場合、変更は、本明細書に[RFC5201]から参照を更新関与するが、下記のようにいくつかの違いがあります。割り当て用語は[RFC5226]で定義されています。 「IETFコンセンサス」への既存の参照は、[RFC5226]あたりとして「IETFレビュー」に置き換えることができます。"
    },
    {
      "indent": 3,
      "text": "HIP Version",
      "ja": "HIPバージョン"
    },
    {
      "indent": 6,
      "text": "This document adds the value \"2\" to the existing registry. The value of \"1\" has been left with a reference to [RFC5201].",
      "ja": "この文書では、既存のレジストリに値「2」を追加します。 「1」の値は、[RFC5201]を参照して残されています。"
    },
    {
      "indent": 3,
      "text": "Packet Type",
      "ja": "パケットタイプ"
    },
    {
      "indent": 6,
      "text": "The 7-bit Packet Type field in a HIP protocol packet describes the type of a HIP protocol message. It is defined in Section 5.1. All existing values referring to [RFC5201] have been updated to refer to this specification. Other values have been left unchanged.",
      "ja": "7ビットのパケットタイプフィールドHIPプロトコルパケットでHIPプロトコルメッセージのタイプを記述する。これは、セクション5.1で定義されています。 [RFC5201]を参照するすべての既存の値は、この仕様を参照するように更新されました。他の値は変更されないままにされています。"
    },
    {
      "indent": 3,
      "text": "HIT Suite ID",
      "ja": "スイートIDを打ちます"
    },
    {
      "indent": 6,
      "text": "This specification creates a new registry for \"HIT Suite ID\". This is different than the existing registry for \"Suite ID\", which can be left unmodified for version 1 of the protocol ([RFC5201]). The registry has been closed to new registrations.",
      "ja": "この仕様は、「HITスイートID」のための新しいレジストリを作成します。これは、プロトコルのバージョン1（[RFC5201]）のために修飾されていないままにしておくことができ、「スイートID」のための既存のレジストリとは異なります。レジストリは、新しい登録に閉鎖されました。"
    },
    {
      "indent": 6,
      "text": "The four-bit HIT Suite ID uses the OGA ID field in the ORCHID to express the type of the HIT. This document defines three HIT Suites (see Section 5.2.10).",
      "ja": "4ビットHITスイートIDはHITの種類を表現するためにORCHIDでOGA IDフィールドを使用します。この文書では、3つのHITスイーツ（5.2.10項を参照）を定義します。"
    },
    {
      "indent": 6,
      "text": "The HIT Suite ID is also carried in the four higher-order bits of the ID field in the HIT_SUITE_LIST parameter. The four lower-order bits are reserved for future extensions of the HIT Suite ID space beyond 16 values.",
      "ja": "HITスイートIDもHIT_SUITE_LISTパラメータのIDフィールドの4上位ビットで搬送されます。下位4ビットは、16の値を超えHITスイートID空間の将来の拡張のために予約されています。"
    },
    {
      "indent": 6,
      "text": "For the time being, the HIT Suite uses only four bits because these bits have to be carried in the HIT. Using more bits for the HIT Suite ID reduces the cryptographic strength of the HIT. HIT Suite IDs must be allocated carefully to avoid namespace exhaustion. Moreover, deprecated IDs should be reused after an appropriate time span. If 15 Suite IDs (the zero value is initially reserved) prove to be insufficient and more HIT Suite IDs are needed concurrently, more bits can be used for the HIT Suite ID by using one HIT Suite ID (0) to indicate that more bits should be used. The HIT_SUITE_LIST parameter already supports 8-bit HIT Suite IDs, should longer IDs be needed. However, RFC 7343 [RFC7343] does not presently support such an extension. We suggest trying the rollover approach described in Appendix E first. Possible extensions of the HIT Suite ID space to accommodate eight bits and new HIT Suite IDs are defined through IETF Review.",
      "ja": "これらのビットがHITで運ばれる必要があるため、当分の間、HITスイートは4ビットのみを使用しています。 HITスイートIDのためのより多くのビットを使用すると、HITの暗号の強度が低下します。 HITスイートIDは名前空間の枯渇を避けるために、慎重に割り当てる必要があります。また、非推奨IDは、適切な期間後に再利用されるべきです。 15のスイートのID（ゼロ値が最初に予約されている）が不十分とよりHITスイートのIDであることを証明することが同時に必要とされる場合、より多くのビットは、一つHITスイートIDを使用してHITスイートIDのために使用することができる（0）より多くのビットが必要があることを示すために利用される。 HIT_SUITE_LISTパラメータは、すでに長いIDが必要とされなければならない、8ビットのHITスイートIDをサポートしています。しかし、RFC 7343 [RFC7343]は、現在、このような拡張機能をサポートしていません。我々は最初の付録Eで説明したロールオーバーアプローチを試みることをお勧めします。 HITスイートID空間の可能性のある拡張子が8ビットに対応するため、新たなHITスイートIDはIETFレビューを通じて定義されています。"
    },
    {
      "indent": 6,
      "text": "Requests to register reused values should include a note that the value is being reused after a deprecation period, to ensure appropriate IETF review and approval.",
      "ja": "再利用の値を登録するための要求は、値が適切なIETFレビューと承認を確保するため、非推奨期間後に再利用されていることに注意を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "Parameter Type",
      "ja": "パラメータタイプ"
    },
    {
      "indent": 6,
      "text": "The 16-bit Type field in a HIP parameter describes the type of the parameter. It is defined in Section 5.2.1. The current values are defined in Sections 5.2.3 through 5.2.23. The existing \"Parameter Types\" registry has been updated as follows.",
      "ja": "HIPパラメータの16ビットのタイプフィールドは、パラメータのタイプを記述する。これは、5.2.1項で定義されています。電流値は、5.2.23を介してセクション5.2.3で定義されています。次のように既存の「パラメータのタイプ」レジストリが更新されました。"
    },
    {
      "indent": 6,
      "text": "A new value (129) for R1_COUNTER has been introduced, with a reference to this specification, and the existing value (128) for R1_COUNTER has been left in place with a reference to [RFC5201]. This documents the change in value that has occurred in version 2 of this protocol. For clarity, the name for the value 128 has been changed from \"R1_COUNTER\" to \"R1_Counter (v1 only)\".",
      "ja": "R1_COUNTERの新しい値（129）は、この明細書を参照して、導入された、およびR1_COUNTERの既存の値（128）[RFC5201]を参照して所定の位置に残されています。これは、このプロトコルのバージョン2で発生した値の変化を説明します。明確にするために、値128の名前は、「R1_Counter（のみV1）」から「R1_COUNTER」から変更されています。"
    },
    {
      "indent": 6,
      "text": "A new value (579) for a new Parameter Type HIP_CIPHER has been added, with reference to this specification. This Parameter Type functionally replaces the HIP_TRANSFORM Parameter Type (value 577), which has been left in the table with the existing reference to [RFC5201]. For clarity, the name for the value 577 has been changed from \"HIP_TRANSFORM\" to \"HIP_TRANSFORM (v1 only)\".",
      "ja": "新しいパラメータタイプHIP_CIPHERの新しい値（579）は、この明細書を参照して、追加されています。このパラメータタイプは、機能[RFC5201]への既存の参照を持つテーブルに残されているHIP_TRANSFORMパラメータタイプ（値577）を、置き換えます。明確にするために、値577の名前は、「（V1のみ）HIP_TRANSFORM」に「HIP_TRANSFORM」から変更されました。"
    },
    {
      "indent": 6,
      "text": "A new value (715) for a new Parameter Type HIT_SUITE_LIST has been added, with reference to this specification.",
      "ja": "新しいパラメータタイプHIT_SUITE_LISTの新しい値（715）は、この明細書を参照して、追加されています。"
    },
    {
      "indent": 6,
      "text": "A new value (2049) for a new Parameter Type TRANSPORT_FORMAT_LIST has been added, with reference to this specification.",
      "ja": "新しいパラメータタイプTRANSPORT_FORMAT_LISTの新しい値（2049）は、この明細書を参照して、追加されています。"
    },
    {
      "indent": 6,
      "text": "The name of the HMAC Parameter Type (value 61505) has been changed to HIP_MAC. The name of the HMAC_2 Parameter Type (value 61569) has been changed to HIP_MAC_2. The reference has been changed to this specification.",
      "ja": "HMACパラメータタイプ（値61505）の名前がHIP_MACに変更されました。 HMAC_2パラメータタイプ（値61569）の名前がHIP_MAC_2に変更されました。参照は、この仕様に変更されました。"
    },
    {
      "indent": 6,
      "text": "All other Parameter Types that reference [RFC5201] have been updated to refer to this specification, and Parameter Types that reference other RFCs are unchanged.",
      "ja": "[RFC5201]を参照する他のすべてのパラメータの種類は、この仕様を参照するように更新されており、およびその他のRFCを参照するパラメータの種類は変更されません。"
    },
    {
      "indent": 6,
      "text": "The Type codes 32768 through 49151 (not 49141: a value corrected from a previous version of this table) have been Reserved for Private Use. Implementors SHOULD select types in a random fashion from this range, thereby reducing the probability of collisions. A method employing genuine randomness (such as flipping a coin) SHOULD be used.",
      "ja": "タイプコード32768〜49151（49141ません：この表の以前のバージョンから修正された値）は、私的使用のために予約されています。実装は、それによって衝突の確率を減少させる、この範囲からランダムにタイプを選択すべきです。 （そのようなコインを反転など）真正乱数を用いた方法が使用されるべきです。"
    },
    {
      "indent": 6,
      "text": "Where the existing ranges once stated \"First Come First Served with Specification Required\", this has been changed to \"Specification Required\".",
      "ja": "既存の範囲はかつて「まず第一に仕様が必要添え来る」述べた場合、これは「仕様が必要」に変更されました。"
    },
    {
      "indent": 3,
      "text": "Group ID",
      "ja": "グループID"
    },
    {
      "indent": 6,
      "text": "The eight-bit Group ID values appear in the DIFFIE_HELLMAN parameter and the DH_GROUP_LIST parameter and are defined in Section 5.2.7. This registry has been updated based on the new values specified in Section 5.2.7; values noted as being DEPRECATED can be left in the table with reference to [RFC5201]. New values are assigned through IETF Review.",
      "ja": "8ビットのグループID値はDIFFIE_HELLMANパラメータとDH_GROUP_LISTパラメータに表示され、5.2.7項​​で定義されています。このレジストリは、セクション5.2.7で指定された新しい値に基づいて更新されています。推奨されるように留意値は[RFC5201]を参照して、テーブル内に残すことができます。新しい値はIETFレビューを通じて割り当てられます。"
    },
    {
      "indent": 3,
      "text": "HIP Cipher ID",
      "ja": "HIP暗号ID"
    },
    {
      "indent": 6,
      "text": "The 16-bit Cipher ID values in a HIP_CIPHER parameter are defined in Section 5.2.8. This is a new registry. New values from either the reserved or unassigned space are assigned through IETF Review.",
      "ja": "HIP_CIPHERパラメータの16ビット暗号ID値はセクション5.2.8で定義されています。これは新しいレジストリです。予約済みまたは未割り当てスペースのいずれかから新しい値はIETFレビューを通じて割り当てられます。"
    },
    {
      "indent": 3,
      "text": "DI-Type",
      "ja": "OF-タイプ"
    },
    {
      "indent": 6,
      "text": "The four-bit DI-Type values in a HOST_ID parameter are defined in Section 5.2.9. New values are assigned through IETF Review. All existing values referring to [RFC5201] have been updated to refer to this specification.",
      "ja": "HOST_IDパラメータの4ビットDI-Type値はセクション5.2.9で定義されています。新しい値はIETFレビューを通じて割り当てられます。 [RFC5201]を参照するすべての既存の値は、この仕様を参照するように更新されました。"
    },
    {
      "indent": 3,
      "text": "HI Algorithm",
      "ja": "HIアルゴリズム"
    },
    {
      "indent": 6,
      "text": "The 16-bit Algorithm values in a HOST_ID parameter are defined in Section 5.2.9. This is a new registry. New values from either the reserved or unassigned space are assigned through IETF Review.",
      "ja": "HOST_IDパラメータの16ビットのアルゴリズム値はセクション5.2.9で定義されています。これは新しいレジストリです。予約済みまたは未割り当てスペースのいずれかから新しい値はIETFレビューを通じて割り当てられます。"
    },
    {
      "indent": 3,
      "text": "ECC Curve Label",
      "ja": "ECC曲線ラベル"
    },
    {
      "indent": 6,
      "text": "When the HI Algorithm values in a HOST_ID parameter are defined to the values of either \"ECDSA\" or \"ECDSA_LOW\", a new registry is needed to maintain the values for the ECC Curve Label as defined in Section 5.2.9. This might be handled by specifying two algorithm-specific subregistries named \"ECDSA Curve Label\" and \"ECDSA_LOW Curve Label\". New values are to be assigned through IETF Review.",
      "ja": "HOST_IDパラメータのHIアルゴリズム値は「ECDSA」または「ECDSA_LOW」のいずれかの値に定義されている場合、新しいレジストリは、5.2.9項で定義されているECC曲線ラベルの値を維持するために必要とされます。これは「ECDSA曲線ラベル」と「ECDSA_LOWカーブラベル」という名前の2つのアルゴリズム固有のsubregistriesを指定することによって処理される可能性があります。新しい値は、IETFレビューを通じて割り当てられます。"
    },
    {
      "indent": 3,
      "text": "Notify Message Type",
      "ja": "メッセージタイプを通知します"
    },
    {
      "indent": 6,
      "text": "The 16-bit Notify Message Type values in a NOTIFICATION parameter are defined in Section 5.2.19.",
      "ja": "通知パラメータの16ビットNOTIFYメッセージ・タイプ値は、セクション5.2.19で定義されています。"
    },
    {
      "indent": 6,
      "text": "Notify Message Type values 1-10 are used for informing about errors in packet structures, values 11-20 for informing about problems in parameters containing cryptographic related material, and values 21-30 for informing about problems in authentication or packet integrity verification. Parameter numbers above 30 can be used for informing about other types of errors or events.",
      "ja": "通知メッセージタイプは、1〜10がパケット構造のエラーを知らせるために使用される値の暗号化関連物質を含むパラメータの問題について知らせるための11-20値、および認証やパケットの完全性の検証で問題を知らせるために21-30値。 30以上のパラメータ番号はエラーまたは他のタイプのイベントについて通知するために使用することができます。"
    },
    {
      "indent": 6,
      "text": "The existing registration procedures have been updated as follows. The range from 1-50 can remain as \"IETF Review\". The range from 51-8191 has been marked as \"Specification Required\". Values 8192-16383 remain as \"Reserved for Private Use\". Values 16384-40959 have been marked as \"Specification Required\". Values 40960-65535 remain as \"Reserved for Private Use\".",
      "ja": "次のように既存の登録手続きが更新されました。 1-50の範囲は、「IETFレビュー」として残ることができます。 51から8191までの範囲では、「仕様が必要」としてマークされています。値は8192から16383は「貸切」として残ります。値は16384から40959は、「仕様が必要」としてマークされています。値は40960から65535は「貸切」として残ります。"
    },
    {
      "indent": 6,
      "text": "The following updates to the values have been made to the existing registry. All existing values referring to [RFC5201] have been updated to refer to this specification.",
      "ja": "値に次の更新では、既存のレジストリに行われました。 [RFC5201]を参照するすべての既存の値は、この仕様を参照するように更新されました。"
    },
    {
      "indent": 6,
      "text": "INVALID_HIP_TRANSFORM_CHOSEN has been renamed to INVALID_HIP_CIPHER_CHOSEN with the same value (17).",
      "ja": "INVALID_HIP_TRANSFORM_CHOSENは同じ値（17）とINVALID_HIP_CIPHER_CHOSENという名前に変更されました。"
    },
    {
      "indent": 6,
      "text": "A new value of 20 for the type UNSUPPORTED_HIT_SUITE has been added.",
      "ja": "タイプUNSUPPORTED_HIT_SUITEのための20の新しい値が追加されました。"
    },
    {
      "indent": 6,
      "text": "HMAC_FAILED has been renamed to HIP_MAC_FAILED with the same value (28).",
      "ja": "HMAC_FAILEDは同じ値（28）とHIP_MAC_FAILEDという名前に変更されました。"
    },
    {
      "indent": 6,
      "text": "SERVER_BUSY_PLEASE_RETRY has been renamed to RESPONDER_BUSY_PLEASE_RETRY with the same value (44).",
      "ja": "SERVER_BUSY_PLEASE_RETRYは同じ値（44）とRESPONDER_BUSY_PLEASE_RETRYという名前に変更されました。"
    },
    {
      "indent": 1,
      "text": "10. Differences from",
      "section_title": true,
      "ja": "から10の違い"
    },
    {
      "indent": 3,
      "text": "This section summarizes the technical changes made from [RFC5201]. This section is informational, intended to help implementors of the previous protocol version. If any text in this section contradicts text in other portions of this specification, the text found outside of this section should be considered normative.",
      "ja": "このセクションでは、[RFC5201]から作られた技術的な変更点をまとめたものです。このセクションでは、以前のプロトコルバージョンの実装を支援するためのもの、情報提供です。このセクションの任意のテキストは、本明細書の他の部分のテキストと矛盾する場合は、このセクションの外側に見つかったテキストが規定考慮すべきです。"
    },
    {
      "indent": 3,
      "text": "This document specifies the HIP Version 2 protocol, which is not interoperable with the HIP Version 1 protocol specified in [RFC5201]. The main technical changes are the inclusion of additional cryptographic agility features, and an update of the mandatory and optional algorithms, including Elliptic Curve support via the",
      "ja": "このドキュメントは[RFC5201]で指定されたHIPバージョン1つのプロトコルとの相互運用ないHIPバージョン2プロトコルを指定します。主な技術的な変更は、ビア楕円曲線のサポートを含む追加の暗号アジリティ機能を含めること、および必須および任意のアルゴリズムの更新、あります"
    },
    {
      "indent": 3,
      "text": "Elliptic Curve DSA (ECDSA) and Elliptic Curve Diffie-Hellman (ECDH) algorithms. The mandatory cryptographic algorithm implementations have been updated, such as replacing HMAC-SHA-1 with HMAC-SHA-256 and the RSA/SHA-1 signature algorithm with RSASSA-PSS, and adding ECDSA to RSA as mandatory public key types. This version of HIP is also aligned with the ORCHID revision [RFC7343].",
      "ja": "楕円曲線DSA（ECDSA）と楕円曲線ディフィ - ヘルマン（ECDH）アルゴリズム。必須の暗号アルゴリズムの実装は、HMAC-SHA-256とRSASSA-PSSとRSA / SHA-1署名アルゴリズムとHMAC-SHA-1を置き換え、そして必須の公開鍵タイプとしてRSAにECDSAを追加するように、更新されています。 HIPのこのバージョンはまた、ORCHID改訂[RFC7343]と整列しています。"
    },
    {
      "indent": 3,
      "text": "The following changes have been made to the protocol operation.",
      "ja": "次の変更は、プロトコルの動作が行われました。"
    },
    {
      "indent": 3,
      "text": "o Section 4.1.3 describes the new process for Diffie-Hellman group negotiation, an aspect of cryptographic agility. The Initiator may express a preference for the choice of a DH group in the I1 packet and may suggest multiple possible choices. The Responder replies with a preference based on local policy and the options provided by the Initiator. The Initiator may restart the base exchange if the option chosen by the Responder is unsuitable (unsupported algorithms).",
      "ja": "O部4.1.3のDiffie-Hellmanグループのネゴシエーション、暗号敏捷性の側面のための新しいプロセスを説明します。イニシエータは、I1パケット内DHグループの選択のための好みを表現してもよいし、複数の可能な選択肢を提案することができます。レスポンダは、ローカルポリシーおよび開始剤によって提供されるオプションに基づいて、優先的に応答します。応答者によって選択されたオプションは、（サポートされていないアルゴリズム）不適切である場合、イニシエータは、塩基交換を再開してもよいです。"
    },
    {
      "indent": 3,
      "text": "o Another aspect of cryptographic agility that has been added is the ability to use different cryptographic hash functions to generate the HIT. The Responder's HIT hash algorithm (RHASH) terminology was introduced to support this. In addition, HIT Suites have been introduced to group the set of cryptographic algorithms used together for public key signature, hash function, and hash truncation. The use of HIT Suites constrains the combinatorial possibilities of algorithm selection for different functions. HIT Suite IDs are related to the ORCHID OGA ID field ([RFC7343]).",
      "ja": "O追加された暗号アジリティの別の態様は、HITを生成するために、異なる暗号ハッシュ関数を使用する能力です。レスポンダのHITハッシュアルゴリズム（RHASH）の用語は、これをサポートするために導入されました。また、HITスイートは、グループ公開鍵署名、ハッシュ関数、ハッシュトランケーションのために一緒に使用される暗号アルゴリズムのセットが導入されています。 HITスイーツの使用は、異なる機能のためのアルゴリズム選択の組み合わせの可能性を制約します。 HITスイートIDはORCHID OGA IDフィールド（[RFC7343]）に関連しています。"
    },
    {
      "indent": 3,
      "text": "o The puzzle mechanism has been slightly changed, in that the #I parameter depends on the HIT hash function (RHASH) selected, and the specification now advises against reusing the same #I value to the same Initiator; more details are provided in Sections 4.1.2 and 5.2.4).",
      "ja": "パズル機構がわずかに変更されたO、という点で#Iパラメータは、選択されたHITハッシュ関数（RHASH）に依存し、仕様は現在、同じイニシエータに同じ#I値を再利用に対する助言します。詳細については、セクション4.1.2および5.2.4）で提供されています。"
    },
    {
      "indent": 3,
      "text": "o Section 4.1.4 was extended to cover details about R1 generation counter rollover or reset.",
      "ja": "O 4.1.4はR1生成カウンタのロールオーバーまたはリセットの詳細をカバーするように拡張されました。"
    },
    {
      "indent": 3,
      "text": "o Section 4.1.6 was added to describe procedures for aborting a HIP base exchange.",
      "ja": "Oセクション4.1.6は、HIP基本交換を中止するための手順を説明するために添加しました。"
    },
    {
      "indent": 3,
      "text": "o Section 4.1.7 provides guidance on avoiding downgrade attacks on the cryptographic algorithms.",
      "ja": "O部4.1.7は、暗号化アルゴリズムにダウングレード攻撃を回避についてのガイダンスを提供します。"
    },
    {
      "indent": 3,
      "text": "o Section 4.1.8 on opportunistic mode has been updated to account for cryptographic agility by adding HIT selection procedures.",
      "ja": "O日和見モードのセクション4.1.8には、HITの選択手順を追加することにより、暗号敏捷性を考慮して更新されています。"
    },
    {
      "indent": 3,
      "text": "o The HIP KEYMAT generation has been updated as described in Section 6.5 to make the key derivation function a negotiable aspect of the protocol.",
      "ja": "鍵導出関数プロトコルの交渉局面にするために、セクション6.5で説明したように、O HIPのKEYMAT生成が更新されました。"
    },
    {
      "indent": 3,
      "text": "o Packet processing for the I1, R1, and I2 packets has been updated to account for new parameter processing.",
      "ja": "I1、R1、およびI2パケットのOパケット処理は、新たなパラメータ処理を説明するために更新されています。"
    },
    {
      "indent": 3,
      "text": "o This specification adds a requirement that hosts MUST support processing of ACK parameters with several SEQ sequence numbers even when they do not support sending such parameters.",
      "ja": "Oこの仕様は、彼らがそのようなパラメータの送信をサポートしていなくても、いくつかのSEQシーケンス番号とACKパラメータの処理をサポートしなければならないホストの要件を追加します。"
    },
    {
      "indent": 3,
      "text": "o This document now clarifies that several ECHO_REQUEST_UNSIGNED parameters may be present in an R1 and that several ECHO_RESPONSE parameters may be present in an I2.",
      "ja": "Oこの文書は、ここ数ECHO_REQUEST_UNSIGNEDパラメータがR1に存在し、いくつかのECHO_RESPONSEパラメータがI2に存在し得ることもできることを明確にしています。"
    },
    {
      "indent": 3,
      "text": "o Procedures for responding to version mismatches with an ICMP Parameter Problem have been added.",
      "ja": "ICMPパラメータ問題でバージョンの不一致への対応のためのO手順が追加されました。"
    },
    {
      "indent": 3,
      "text": "o The security considerations section (Section 8) has been updated to remove possible attacks no longer considered applicable.",
      "ja": "セキュリティの考慮事項のセクション（セクション8）Oもはや適用みなさ攻撃の可能性を取り除くために更新されています。"
    },
    {
      "indent": 3,
      "text": "o The use of the Anonymous bit for making the sender's Host Identity anonymous is now supported in packets other than the R1 and I2.",
      "ja": "O送信者のホストアイデンティティ匿名を作るための匿名ビットの使用は今R1とI2以外のパケットでサポートされています。"
    },
    {
      "indent": 3,
      "text": "o Support for the use of a NULL HIP CIPHER is explicitly limited to debugging and testing HIP and is no longer a mandatory algorithm to support.",
      "ja": "NULLのHIP暗号を使用するためのOサポートを明示的にデバッグおよびテストHIPに限らず、もはやサポートするための必須アルゴリズムです。"
    },
    {
      "indent": 3,
      "text": "The following changes have been made to the parameter types and encodings (Section 5.2).",
      "ja": "次の変更は、パラメータの種類とエンコーディング（5.2節）に行われました。"
    },
    {
      "indent": 3,
      "text": "o Four new parameter types have been added: DH_GROUP_LIST, HIP_CIPHER, HIT_SUITE_LIST, and TRANSPORT_FORMAT_LIST.",
      "ja": "O四の新しいパラメータタイプが追加されました：DH_GROUP_LIST、HIP_CIPHER、HIT_SUITE_LIST、およびTRANSPORT_FORMAT_LIST。"
    },
    {
      "indent": 3,
      "text": "o Two parameter types have been renamed: HMAC has been renamed to HIP_MAC, and HMAC2 has been renamed to HIP_MAC_2.",
      "ja": "HMACはHIP_MACに改名された、とHMAC2はHIP_MAC_2に名前が変更されました：O 2つのパラメータの種類は、名前が変更されました。"
    },
    {
      "indent": 3,
      "text": "o One parameter type is deprecated: HIP_TRANSFORM. Functionally, it has been replaced by the HIP_CIPHER but with slightly different semantics (hashes have been removed and are now determined by RHASH).",
      "ja": "O 1つのパラメータの種類が廃止されました：HIP_TRANSFORMを。機能的には、それはHIP_CIPHERによって若干異なる意味（ハッシュが削除されており、RHASHによって決定されている）に置き換えられました。"
    },
    {
      "indent": 3,
      "text": "o The TRANSPORT_FORMAT_LIST parameter allows transports to be negotiated with the list instead of by their order in the HIP packet.",
      "ja": "TRANSPORT_FORMAT_LISTパラメータoをトランスポートがリストではなく、HIPパケット内の順序によって交渉することができます。"
    },
    {
      "indent": 3,
      "text": "o The type code for the R1_COUNTER has been changed from 128 to 129 to reflect that it is now considered a Critical parameter and must be echoed when present in R1.",
      "ja": "O R1_COUNTERの型コードは、それが今重要なパラメータと考えられ、存在する場合R1にエコーされなければならないことを反映するために129から128から変更されています。"
    },
    {
      "indent": 3,
      "text": "o The PUZZLE and SOLUTION parameter lengths are now variable and dependent on the RHASH length.",
      "ja": "パズル、溶液パラメータoを長さは今可変とRHASHの長さに依存します。"
    },
    {
      "indent": 3,
      "text": "o The Diffie-Hellman Group IDs supported have been updated.",
      "ja": "OのDiffie-HellmanのグループIDが更新されているサポートされています。"
    },
    {
      "indent": 3,
      "text": "o The HOST_ID parameter now requires specification of an Algorithm.",
      "ja": "O HOST_IDパラメータは、今アルゴリズムを指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "o The NOTIFICATION parameter supports new Notify Message Type values.",
      "ja": "O通知パラメータはメッセージタイプ値を通知する新しいサポートされています。"
    },
    {
      "indent": 3,
      "text": "o The HIP_SIGNATURE algorithm field has been changed from 8 bits to 16 bits to achieve alignment with the HOST_ID parameters.",
      "ja": "O HIP_SIGNATUREアルゴリズムフィールドは、HOST_IDパラメータとの整合を達成するために、8ビットから16ビットに変更されています。"
    },
    {
      "indent": 3,
      "text": "o The specification clarifies that the SEQ parameter always contains one update ID but that the ACK parameter may acknowledge several update IDs.",
      "ja": "O仕様は、SEQパラメータは、常に1つの更新IDが含まれていることが、ACKパラメータは、いくつかの更新IDを確認してもよいことを明確にしています。"
    },
    {
      "indent": 3,
      "text": "o The restriction that only one ECHO_RESPONSE_UNSIGNED parameter must be present in each HIP packet has been removed.",
      "ja": "OつのみECHO_RESPONSE_UNSIGNEDパラメータは、各HIPパケット内に存在しなければならない制約が除去されています。"
    },
    {
      "indent": 3,
      "text": "o The document creates a new type range allocation for parameters that are only covered by a signature if a signature is present and applies it to the newly created DH_GROUP_LIST parameter.",
      "ja": "文書が署名が存在し、新たに作成されたDH_GROUP_LISTパラメータに適用した場合にのみ署名によって覆われているパラメータの新しいタイプの範囲の割り当てを作成し、O。"
    },
    {
      "indent": 3,
      "text": "o The document clarifies that several NOTIFY parameters may be present in a packet.",
      "ja": "Oドキュメントは、いくつかのNOTIFYパラメータがパケット中に存在し得ることを明確にしています。"
    },
    {
      "indent": 3,
      "text": "The following changes have been made to the packet contents (Section 5.3).",
      "ja": "次の変更は、パケットの内容（5.3節）に行われました。"
    },
    {
      "indent": 3,
      "text": "o The I1 packet now carries the Initiator's DH_GROUP_LIST.",
      "ja": "O I1パケットは現在、イニシエータのDH_GROUP_LISTを運びます。"
    },
    {
      "indent": 3,
      "text": "o The R1 packet now carries the HIP_CIPHER, HIT_SUITE_LIST, DH_GROUP_LIST, and TRANSPORT_FORMAT_LIST parameters.",
      "ja": "O R1パケットが今HIP_CIPHER、HIT_SUITE_LIST、DH_GROUP_LIST、及びTRANSPORT_FORMAT_LISTパラメータを運びます。"
    },
    {
      "indent": 3,
      "text": "o The I2 packet now carries the HIP_CIPHER and TRANSPORT_FORMAT_LIST parameters.",
      "ja": "O I2パケットは現在HIP_CIPHERとTRANSPORT_FORMAT_LISTパラメータを運びます。"
    },
    {
      "indent": 3,
      "text": "o This document clarifies that UPDATE packets that do not contain either a SEQ or ACK parameter are invalid.",
      "ja": "Oこの文書では、配列またはACKのパラメータのいずれかが無効である含まれていないことUPDATEパケットを明確にしています。"
    },
    {
      "indent": 0,
      "text": "11. References",
      "section_title": true,
      "ja": "11.参考文献"
    },
    {
      "indent": 0,
      "text": "11.1. Normative References",
      "section_title": true,
      "ja": "11.1. 引用規格"
    },
    {
      "indent": 3,
      "text": "[FIPS.180-4.2012] National Institute of Standards and Technology, \"Secure Hash Standard (SHS)\", FIPS PUB 180-4, March 2012, <http://csrc.nist.gov/publications/fips/fips180-4/ fips-180-4.pdf>.",
      "ja": "[FIPS.180-4.2012]米国国立標準技術研究所、 \"セキュアハッシュ規格（SHS）\"、FIPS PUB 180-4の、2012年3月、<http://csrc.nist.gov/publications/fips/fips180-4 / FIPS-180-4.pdf>。"
    },
    {
      "indent": 3,
      "text": "[NIST.800-131A.2011] National Institute of Standards and Technology, \"Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths\", NIST SP 800-131A, January 2011, <http://csrc.nist.gov/ publications/nistpubs/800-131A/sp800-131A.pdf>.",
      "ja": "[NIST.800-131A.2011]標準技術、総合研究所「トランジション：暗号アルゴリズムや鍵長の使用移行のための勧告」、NIST SP 800-131A、2011年1月に、<のhttp：//csrc.nist。 GOV /出版/ nistpubs / 800-131A / sp800-131A.pdf>。"
    },
    {
      "indent": 3,
      "text": "[RFC0768] Postel, J., \"User Datagram Protocol\", STD 6, RFC 768, August 1980, <http://www.rfc-editor.org/info/rfc768>.",
      "ja": "[RFC0768]ポステル、J.、 \"ユーザ・データグラム・プロトコル\"、STD 6、RFC 768、1980年8月、<http://www.rfc-editor.org/info/rfc768>。"
    },
    {
      "indent": 3,
      "text": "[RFC0793] Postel, J., \"Transmission Control Protocol\", STD 7, RFC 793, September 1981, <http://www.rfc-editor.org/ info/rfc793>.",
      "ja": "[RFC0793]ポステル、J.、 \"伝送制御プロトコル\"、STD 7、RFC 793、1981年9月、<http://www.rfc-editor.org/情報/ RFC793>。"
    },
    {
      "indent": 3,
      "text": "[RFC1035] Mockapetris, P., \"Domain names - implementation and specification\", STD 13, RFC 1035, November 1987, <http://www.rfc-editor.org/info/rfc1035>.",
      "ja": "[RFC1035] Mockapetris、P.、 \"ドメイン名 - 実装及び仕様\"、STD 13、RFC 1035、1987年11月、<http://www.rfc-editor.org/info/rfc1035>。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月、<http://www.rfc-editor.org/info/rfc2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC2404] Madson, C. and R. Glenn, \"The Use of HMAC-SHA-1-96 within ESP and AH\", RFC 2404, November 1998, <http://www.rfc-editor.org/info/rfc2404>.",
      "ja": "[RFC2404] Madson、C.およびR.グレン、 \"ESPおよびAH内HMAC-SHA-1-96の使用\"、RFC 2404、1998年11月、<http://www.rfc-editor.org/info/ rfc2404>。"
    },
    {
      "indent": 3,
      "text": "[RFC2410] Glenn, R. and S. Kent, \"The NULL Encryption Algorithm and Its Use With IPsec\", RFC 2410, November 1998, <http://www.rfc-editor.org/info/rfc2410>.",
      "ja": "[RFC2410]グレン、R.とS.ケント、 \"NULL暗号化アルゴリズムとIPsecでの使用\"、RFC 2410、1998年11月、<http://www.rfc-editor.org/info/rfc2410>。"
    },
    {
      "indent": 3,
      "text": "[RFC2460] Deering, S. and R. Hinden, \"Internet Protocol, Version 6 (IPv6) Specification\", RFC 2460, December 1998, <http://www.rfc-editor.org/info/rfc2460>.",
      "ja": "[RFC2460]デアリング、S.とR. Hindenと、 \"インターネットプロトコルバージョン6（IPv6）の仕様\"、RFC 2460、1998年12月、<http://www.rfc-editor.org/info/rfc2460>。"
    },
    {
      "indent": 3,
      "text": "[RFC2536] Eastlake 3rd, D., \"DSA KEYs and SIGs in the Domain Name System (DNS)\", RFC 2536, March 1999, <http://www.rfc-editor.org/info/rfc2536>.",
      "ja": "[RFC2536]イーストレイク3日、D.、RFC 2536 \"ドメインネームシステム（DNS）でのDSA鍵とのSIG\"、1999年3月、<http://www.rfc-editor.org/info/rfc2536>。"
    },
    {
      "indent": 3,
      "text": "[RFC3110] Eastlake 3rd, D., \"RSA/SHA-1 SIGs and RSA KEYs in the Domain Name System (DNS)\", RFC 3110, May 2001, <http://www.rfc-editor.org/info/rfc3110>.",
      "ja": "[RFC3110]イーストレーク3日、D.、 \"RSA / SHA-1のSIG及びドメインネームシステム（DNS）におけるRSAキー\"、RFC 3110、2001年5月、<http://www.rfc-editor.org/info/ rfc3110>。"
    },
    {
      "indent": 3,
      "text": "[RFC3526] Kivinen, T. and M. Kojo, \"More Modular Exponential (MODP) Diffie-Hellman groups for Internet Key Exchange (IKE)\", RFC 3526, May 2003, <http://www.rfc-editor.org/ info/rfc3526>.",
      "ja": "[RFC3526] Kivinen、T.およびM.古城、 \"インターネット鍵交換のためのより多くのモジュラー指数（MODP）のDiffie-Hellmanグループ（IKE）\"、RFC 3526、2003年5月、<http://www.rfc-editor.org /情報/ rfc3526>。"
    },
    {
      "indent": 3,
      "text": "[RFC3602] Frankel, S., Glenn, R., and S. Kelly, \"The AES-CBC Cipher Algorithm and Its Use with IPsec\", RFC 3602, September 2003, <http://www.rfc-editor.org/info/rfc3602>.",
      "ja": "[RFC3602]フランケル、S.、グレン、R.、およびS.ケリー、 \"AES-CBC暗号アルゴリズムおよびIPSecでの使用\"、RFC 3602、2003年9月、<http://www.rfc-editor.org /情報/ rfc3602>。"
    },
    {
      "indent": 3,
      "text": "[RFC3972] Aura, T., \"Cryptographically Generated Addresses (CGA)\", RFC 3972, March 2005, <http://www.rfc-editor.org/ info/rfc3972>.",
      "ja": "[RFC3972]オーラ、T.、 \"暗号的に生成されたアドレス（CGA）\"、RFC 3972、2005年3月、<http://www.rfc-editor.org/情報/ rfc3972>。"
    },
    {
      "indent": 3,
      "text": "[RFC4034] Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, \"Resource Records for the DNS Security Extensions\", RFC 4034, March 2005, <http://www.rfc-editor.org/ info/rfc4034>.",
      "ja": "[RFC4034]アレンズ、R.、Austeinと、R.、ラーソン、M.、マッシー、D.、およびS.ローズ、 \"DNSセキュリティ拡張機能のためのリソースレコード\"、RFC 4034、2005年3月、<のhttp：// WWW .rfc-editor.org /情報/ RFC4034>。"
    },
    {
      "indent": 3,
      "text": "[RFC4282] Aboba, B., Beadles, M., Arkko, J., and P. Eronen, \"The Network Access Identifier\", RFC 4282, December 2005, <http://www.rfc-editor.org/info/rfc4282>.",
      "ja": "[RFC4282] Aboba、B.、Beadles、M.、Arkko、J.、およびP. Eronen、 \"ネットワークアクセス識別子\"、RFC 4282、2005年12月<http://www.rfc-editor.org/info / RFC4282>。"
    },
    {
      "indent": 3,
      "text": "[RFC4443] Conta, A., Deering, S., and M. Gupta, \"Internet Control Message Protocol (ICMPv6) for the Internet Protocol Version 6 (IPv6) Specification\", RFC 4443, March 2006, <http://www.rfc-editor.org/info/rfc4443>.",
      "ja": "[RFC4443]コンタ、A.、デアリング、S.、およびM.グプタ、 \"インターネットプロトコルバージョン6（IPv6）の仕様のためのインターネット制御メッセージプロトコル（ICMPv6の）\"、RFC 4443、2006年3月、<のhttp：// WWW .rfc-editor.org /情報/ rfc4443>。"
    },
    {
      "indent": 3,
      "text": "[RFC4754] Fu, D. and J. Solinas, \"IKE and IKEv2 Authentication Using the Elliptic Curve Digital Signature Algorithm (ECDSA)\", RFC 4754, January 2007, <http://www.rfc-editor.org/ info/rfc4754>.",
      "ja": "[RFC4754]フー、D.およびJ. Solinas、 \"IKE及びIKEv2の認証楕円曲線デジタル署名アルゴリズム（ECDSA）の使用\"、RFC 4754、2007年1月、<http://www.rfc-editor.org/先/ rfc4754>。"
    },
    {
      "indent": 3,
      "text": "[RFC4868] Kelly, S. and S. Frankel, \"Using HMAC-SHA-256, HMAC-SHA-384, and HMAC-SHA-512 with IPsec\", RFC 4868, May 2007, <http://www.rfc-editor.org/info/rfc4868>.",
      "ja": "[RFC4868]ケリー、S.とS.フランケル、 \"HMAC-SHA-256を使用して、HMAC-SHA-384、およびIPSecとHMAC-SHA-512\"、RFC 4868、2007年5月、<のhttp：//www.rfc -editor.org/info/rfc4868>。"
    },
    {
      "indent": 3,
      "text": "[RFC5702] Jansen, J., \"Use of SHA-2 Algorithms with RSA in DNSKEY and RRSIG Resource Records for DNSSEC\", RFC 5702, October 2009, <http://www.rfc-editor.org/info/rfc5702>.",
      "ja": "[RFC5702]ヤンセン、J.、 \"DNSKEYとDNSSECのためのRRSIGリソースレコードでRSAとSHA-2アルゴリズムの使用\"、RFC 5702、2009年10月、<http://www.rfc-editor.org/info/rfc5702> 。"
    },
    {
      "indent": 3,
      "text": "[RFC6724] Thaler, D., Draves, R., Matsumoto, A., and T. Chown, \"Default Address Selection for Internet Protocol Version 6 (IPv6)\", RFC 6724, September 2012, <http://www.rfc-editor.org/info/rfc6724>.",
      "ja": "[RFC6724]ターラー、D.、Draves、R.、松本、A.、およびT. CHOWN、 \"インターネットプロトコルバージョン6（IPv6）のためのデフォルトのアドレス選択\"、RFC 6724、2012年9月、<のhttp：// WWW。 rfc-editor.org/info/rfc6724>。"
    },
    {
      "indent": 3,
      "text": "[RFC7343] Laganier, J. and F. Dupont, \"An IPv6 Prefix for Overlay Routable Cryptographic Hash Identifiers Version 2 (ORCHIDv2)\", RFC 7343, September 2014, <http://www.rfc-editor.org/info/rfc7343>.",
      "ja": "[RFC7343] Laganier、J.およびF.デュポン、 \"オーバーレイルーティング可能な暗号ハッシュ識別子バージョン2（ORCHIDv2）のIPv6プレフィックス\"、RFC 7343、2014年9月、<http://www.rfc-editor.org/info/ rfc7343>。"
    },
    {
      "indent": 3,
      "text": "[RFC7402] Jokela, P., Moskowitz, R., and J. Melen, \"Using the Encapsulating Security Payload (ESP) Transport Format with the Host Identity Protocol (HIP)\", RFC 7402, April 2015, <http://www.rfc-editor.org/info/rfc7402>.",
      "ja": "[RFC7402] Jokela、P.、モスコウィッツ、R.、およびJ.メレン、RFC 7402 \"ホスト識別プロトコル（HIP）とカプセル化セキュリティペイロード（ESP）トランスポートフォーマットの使用\" を、2015年4月、<のhttp：// www.rfc-editor.org/info/rfc7402>。"
    },
    {
      "indent": 0,
      "text": "11.2. Informative References",
      "section_title": true,
      "ja": "11.2. 参考文献"
    },
    {
      "indent": 3,
      "text": "[AUR05] Aura, T., Nagarajan, A., and A. Gurtov, \"Analysis of the HIP Base Exchange Protocol\", in Proceedings of the 10th Australasian Conference on Information Security and Privacy, July 2005.",
      "ja": "[AUR05]情報セキュリティとプライバシー、2005年7月10日にオーストラリアの会議の議事録でオーラ、T.、Nagarajan、A.、およびA. Gurtov、「HIP基本交換プロトコルの分析」、。"
    },
    {
      "indent": 3,
      "text": "[CRO03] Crosby, S. and D. Wallach, \"Denial of Service via Algorithmic Complexity Attacks\", in Proceedings of the 12th USENIX Security Symposium, Washington, D.C., August 2003.",
      "ja": "[CRO03]クロスビー、S.、12 USENIXセキュリティシンポジウム、ワシントンD.C.、2003年8月D.ウォラック、「アルゴリズムの複雑攻撃を経由してサービス拒否」、。"
    },
    {
      "indent": 3,
      "text": "[DIF76] Diffie, W. and M. Hellman, \"New Directions in Cryptography\", IEEE Transactions on Information Theory Volume IT-22, Number 6, pages 644-654, November 1976.",
      "ja": "[DIF76]ディフィー、W.とM.ヘルマン、 \"暗号に関する新\"、情報理論ボリュームIT-22、数6、ページ644から654、1976年11月にIEEEトランザクション。"
    },
    {
      "indent": 3,
      "text": "[FIPS.186-4.2013] National Institute of Standards and Technology, \"Digital Signature Standard (DSS)\", FIPS PUB 186-4, July 2013, <http://nvlpubs.nist.gov/nistpubs/FIPS/ NIST.FIPS.186-4.pdf>.",
      "ja": "[FIPS.186-4.2013]米国国立標準技術研究所、 \"デジタル署名標準（DSS）\"、FIPS PUBの186から4、2013年7月、<http://nvlpubs.nist.gov/nistpubs/FIPS/ NIST.FIPS .186-4.pdf>。"
    },
    {
      "indent": 3,
      "text": "[FIPS.197.2001] National Institute of Standards and Technology, \"Advanced Encryption Standard (AES)\", FIPS PUB 197, November 2001, <http://csrc.nist.gov/publications/fips/fips197/ fips-197.pdf>.",
      "ja": "[FIPS.197.2001]米国国立標準技術研究所、 \"高度暗号化標準（AES）\"、FIPS PUBの197、2001年11月、<http://csrc.nist.gov/publications/fips/fips197/ FIPS-197.pdf >。"
    },
    {
      "indent": 3,
      "text": "[HIP-ARCH] Moskowitz, R., Ed., and M. Komu, \"Host Identity Protocol Architecture\", Work in Progress, draft-ietf-hip-rfc4423-bis-09, October 2014.",
      "ja": "[HIP-ARCH]モスコウィッツ、R.、エド。、およびM.こむ、 \"ホストアイデンティティプロトコルアーキテクチャ\" が進行中で働いて、ドラフト-IETF-ヒップrfc4423  - ビス -  09、2014年10月。"
    },
    {
      "indent": 3,
      "text": "[HIP-DNS-EXT] Laganier, J., \"Host Identity Protocol (HIP) Domain Name System (DNS) Extension\", Work in Progress, draft-ietf-hip-rfc5205-bis-06, January 2015.",
      "ja": "[HIP-DNS-EXT] Laganier、J.、 \"ホストアイデンティティプロトコル（HIP）ドメインネームシステム（DNS）の拡張\" が進行中で働いて、ドラフト-IETF-ヒップrfc5205  - ビス -  06、2015年1月。"
    },
    {
      "indent": 3,
      "text": "[HIP-HOST-MOB] Henderson, T., Ed., Vogt, C., and J. Arkko, \"Host Mobility with the Host Identity Protocol\", Work in Progress, draft-ietf-hip-rfc5206-bis-08, January 2015.",
      "ja": "[HIP-HOST-MOB]ヘンダーソン、T.、エド。、フォークト、C.、およびJ. Arkko、 \"ホストアイデンティティプロトコルとホストモビリティ\" が進行中で働いて、ドラフト-IETF-ヒップrfc5206  - ビス -  08 、2015年1月。"
    },
    {
      "indent": 3,
      "text": "[HIP-REND-EXT] Laganier, J. and L. Eggert, \"Host Identity Protocol (HIP) Rendezvous Extension\", Work in Progress, draft-ietf-hip-rfc5204-bis-05, December 2014.",
      "ja": "[HIP-REND-EXT] Laganier、J.及びL.エッゲルト、 \"ホストアイデンティティプロトコル（HIP）ランデブー拡張子\"、進行中で働いて、ドラフトIETF-ヒップrfc5204ビス -  05、2014年12月。"
    },
    {
      "indent": 3,
      "text": "[KAU03] Kaufman, C., Perlman, R., and B. Sommerfeld, \"DoS protection for UDP-based protocols\", in Proceedings of the 10th ACM Conference on Computer and Communications Security, October 2003.",
      "ja": "コンピュータおよび通信セキュリティ第10回ACM会議議事録、2003年10月[KAU03]カウフマン、C.、パールマン、R.、およびB.ゾンマーフェルト、「UDPベースのプロトコルのためのDoS防御」、。"
    },
    {
      "indent": 3,
      "text": "[KRA03] Krawczyk, H., \"SIGMA: The 'SIGn-and-MAc' Approach to Authenticated Diffie-Hellman and Its Use in the IKE Protocols\", in Proceedings of CRYPTO 2003, pages 400-425, August 2003.",
      "ja": "[KRA03] Krawczyk、H.、 \"SIGMA：認証済みのDiffie-HellmanのとIKEプロトコルでの使用に '記号-と-MAC' アプローチ\" CRYPTO 2003の議事録では、ページ400から425、2003年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC0792] Postel, J., \"Internet Control Message Protocol\", STD 5, RFC 792, September 1981, <http://www.rfc-editor.org/ info/rfc792>.",
      "ja": "[RFC0792]ポステル、J.、 \"インターネット制御メッセージプロトコル\"、STD 5、RFC 792、1981年9月、<http://www.rfc-editor.org/情報/ RFC792>。"
    },
    {
      "indent": 3,
      "text": "[RFC2785] Zuccherato, R., \"Methods for Avoiding the \"Small-Subgroup\" Attacks on the Diffie-Hellman Key Agreement Method for S/MIME\", RFC 2785, March 2000, <http://www.rfc-editor.org/info/rfc2785>.",
      "ja": "[RFC2785] Zuccherato、R.、 \"S / MIMEにDiffie-Hellman鍵合意方式に対する攻撃 \"小サブグループ\" の回避のための方法\"、RFC 2785、2000年3月、<のhttp：//www.rfc-editor。組織/情報/ rfc2785>。"
    },
    {
      "indent": 3,
      "text": "[RFC2898] Kaliski, B., \"PKCS #5: Password-Based Cryptography Specification Version 2.0\", RFC 2898, September 2000, <http://www.rfc-editor.org/info/rfc2898>.",
      "ja": "[RFC2898] Kaliski、B.、 \"PKCS＃5：パスワードベースの暗号化仕様バージョン2.0\"、RFC 2898、2000年9月、<http://www.rfc-editor.org/info/rfc2898>。"
    },
    {
      "indent": 3,
      "text": "[RFC3447] Jonsson, J. and B. Kaliski, \"Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1\", RFC 3447, February 2003, <http://www.rfc-editor.org/info/rfc3447>.",
      "ja": "[RFC3447]ジョンソン、J.とB. Kaliski、 \"公開鍵暗号規格（PKCS）＃1：RSA暗号仕様バージョン2.1\"、RFC 3447、2003年2月、<http://www.rfc-editor.org/情報/ RFC3447>。"
    },
    {
      "indent": 3,
      "text": "[RFC3849] Huston, G., Lord, A., and P. Smith, \"IPv6 Address Prefix Reserved for Documentation\", RFC 3849, July 2004, <http://www.rfc-editor.org/info/rfc3849>.",
      "ja": "[RFC3849]ヒューストン、G.、主よ、A.、およびP.スミス、 \"ドキュメンテーションのためのIPv6アドレスプレフィックス予約\"、RFC 3849、2004年7月、<http://www.rfc-editor.org/info/rfc3849> 。"
    },
    {
      "indent": 3,
      "text": "[RFC5201] Moskowitz, R., Nikander, P., Jokela, P., and T. Henderson, \"Host Identity Protocol\", RFC 5201, April 2008, <http://www.rfc-editor.org/info/rfc5201>.",
      "ja": "[RFC5201]モスコウィッツ、R.、Nikander、P.、Jokela、P.、およびT.ヘンダーソン、 \"ホストアイデンティティプロトコル\"、RFC 5201、2008年4月、<http://www.rfc-editor.org/info/ rfc5201>。"
    },
    {
      "indent": 3,
      "text": "[RFC5226] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 5226, May 2008, <http://www.rfc-editor.org/info/rfc5226>.",
      "ja": "[RFC5226] Narten氏、T.とH. Alvestrand、 \"RFCsにIANA問題部に書くためのガイドライン\"、BCP 26、RFC 5226、2008年5月、<http://www.rfc-editor.org/info/rfc5226> 。"
    },
    {
      "indent": 3,
      "text": "[RFC5338] Henderson, T., Nikander, P., and M. Komu, \"Using the Host Identity Protocol with Legacy Applications\", RFC 5338, September 2008, <http://www.rfc-editor.org/info/rfc5338>.",
      "ja": "[RFC5338]ヘンダーソン、T.、Nikander、P.、およびM.こむ、 \"レガシーアプリケーションをホストアイデンティティプロトコルを使用する\"、RFC 5338、2008年9月、<http://www.rfc-editor.org/info/ rfc5338>。"
    },
    {
      "indent": 3,
      "text": "[RFC5533] Nordmark, E. and M. Bagnulo, \"Shim6: Level 3 Multihoming Shim Protocol for IPv6\", RFC 5533, June 2009, <http://www.rfc-editor.org/info/rfc5533>.",
      "ja": "[RFC5533] Nordmarkと、E.およびM. Bagnulo、 \"SHIM6：IPv6のレベル3マルチホーミングシム・プロトコル\"、RFC 5533、2009年6月、<http://www.rfc-editor.org/info/rfc5533>。"
    },
    {
      "indent": 3,
      "text": "[RFC5737] Arkko, J., Cotton, M., and L. Vegoda, \"IPv4 Address Blocks Reserved for Documentation\", RFC 5737, January 2010, <http://www.rfc-editor.org/info/rfc5737>.",
      "ja": "[RFC5737] Arkko、J.、綿、M.、およびL. Vegoda、 \"ドキュメントのために予約されたIPv4アドレスブロック\"、RFC 5737、2010年1月、<http://www.rfc-editor.org/info/rfc5737> 。"
    },
    {
      "indent": 3,
      "text": "[RFC5869] Krawczyk, H. and P. Eronen, \"HMAC-based Extract-and-Expand Key Derivation Function (HKDF)\", RFC 5869, May 2010, <http://www.rfc-editor.org/info/rfc5869>.",
      "ja": "[RFC5869] Krawczyk、H.、およびP. Eronen、 \"HMACベースの抽出物と、拡大鍵導出関数（HKDF）\"、RFC 5869、2010年5月、<http://www.rfc-editor.org/info/ rfc5869>。"
    },
    {
      "indent": 3,
      "text": "[RFC5903] Fu, D. and J. Solinas, \"Elliptic Curve Groups modulo a Prime (ECP Groups) for IKE and IKEv2\", RFC 5903, June 2010, <http://www.rfc-editor.org/info/rfc5903>.",
      "ja": "[RFC5903]フー、D.およびJ. Solinas、 \"楕円曲線グループIKE及びIKEv2のためのプライム（ECPグループ）モジュロ\"、RFC 5903、2010年6月、<http://www.rfc-editor.org/info/ rfc5903>。"
    },
    {
      "indent": 3,
      "text": "[RFC6090] McGrew, D., Igoe, K., and M. Salter, \"Fundamental Elliptic Curve Cryptography Algorithms\", RFC 6090, February 2011, <http://www.rfc-editor.org/info/rfc6090>.",
      "ja": "[RFC6090]マグリュー、D.、Igoe、K.、およびM.ソルター、 \"基礎楕円曲線暗号アルゴリズム\"、RFC 6090、2011年2月、<http://www.rfc-editor.org/info/rfc6090>。"
    },
    {
      "indent": 3,
      "text": "[RFC6253] Heer, T. and S. Varjonen, \"Host Identity Protocol Certificates\", RFC 6253, May 2011, <http://www.rfc-editor.org/info/rfc6253>.",
      "ja": "[RFC6253] Heerさん、T.とS. Varjonen、 \"ホストアイデンティティプロトコル証明書\"、RFC 6253、2011年5月、<http://www.rfc-editor.org/info/rfc6253>。"
    },
    {
      "indent": 3,
      "text": "[RFC7045] Carpenter, B. and S. Jiang, \"Transmission and Processing of IPv6 Extension Headers\", RFC 7045, December 2013, <http://www.rfc-editor.org/info/rfc7045>.",
      "ja": "[RFC7045]カーペンター、B.及びS.江、 \"送信とIPv6拡張ヘッダの処理\"、RFC 7045、2013年12月、<http://www.rfc-editor.org/info/rfc7045>。"
    },
    {
      "indent": 3,
      "text": "[RFC7296] Kaufman, C., Hoffman, P., Nir, Y., Eronen, P., and T. Kivinen, \"Internet Key Exchange Protocol Version 2 (IKEv2)\", STD 79, RFC 7296, October 2014, <http://www.rfc-editor.org/info/rfc7296>.",
      "ja": "[RFC7296]カウフマン、C.、ホフマン、P.、ニール、Y.、Eronen、P.、およびT. Kivinen、 \"インターネット鍵交換プロトコルバージョン2（IKEv2の）\"、STD 79、RFC 7296、2014年10月、< http://www.rfc-editor.org/info/rfc7296>。"
    },
    {
      "indent": 3,
      "text": "[RSA] Rivest, R., Shamir, A., and L. Adleman, \"A Method for Obtaining Digital Signatures and Public-Key Cryptosystems\", Communications of the ACM 21 (2), pp. 120-126, February 1978.",
      "ja": "\"デジタル署名と公開鍵暗号を得る方法\" [RSA]リベスト、R.、シャミル、A.、およびL.エーデルマン、ACM 21の通信（2）、頁120-126、1978年2月。"
    },
    {
      "indent": 3,
      "text": "[SECG] SECG, \"Recommended Elliptic Curve Domain Parameters\", SEC 2 Version 2.0, January 2010, <http://www.secg.org/>.",
      "ja": "[SECG] SECG、SEC 2バージョン2.0、2010年1月、 \"楕円曲線ドメインパラメータを推奨\" <http://www.secg.org/>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Using Responder Puzzles",
      "ja": "レスポンダパズルを使用した付録A."
    },
    {
      "indent": 3,
      "text": "As mentioned in Section 4.1.1, the Responder may delay state creation and still reject most spoofed I2 packets by using a number of pre-calculated R1 packets and a local selection function. This appendix defines one possible implementation in detail. The purpose of this appendix is to give the implementors an idea of how to implement the mechanism. If the implementation is based on this appendix, it MAY contain some local modification that makes an attacker's task harder.",
      "ja": "セクション4.1.1で述べたように、レスポンダは、状態の作成を遅らせ、まだ予め計算R1パケットの数とローカル選択機能を使用することによって最もスプーフィングされたI2パケットを拒否することができます。この付録では、具体的に一つの可能​​な実装を定義します。この付録の目的は、実装者にメカニズムを実装する方法のアイデアを与えることです。実装は、この付録に基づいている場合、それは難しく、攻撃者の作業を行い、いくつかのローカルの変更を含むかもしれません。"
    },
    {
      "indent": 3,
      "text": "The Responder creates a secret value S, that it regenerates periodically. The Responder needs to remember the two latest values of S. Each time the S is regenerated, the R1 generation counter value is incremented by one.",
      "ja": "Responderは、それが定期的に再生成すること、秘密値Sを作成します。 ResponderはSが再生成されるたびに、R1世代カウンタ値を1ずつインクリメントされるS.の最新の2つの値を覚えておく必要があります。"
    },
    {
      "indent": 3,
      "text": "The Responder generates a pre-signed R1 packet. The signature for pre-generated R1s must be recalculated when the Diffie-Hellman key is recomputed or when the R1_COUNTER value changes due to S value regeneration.",
      "ja": "レスポンダは、事前に署名されたR1パケットを生成します。事前生成のR1の署名は、ディフィー・ヘルマン鍵が再計算されたときに再計算またはなければならない場合、S値再生によるR1_COUNTER値が変化します。"
    },
    {
      "indent": 3,
      "text": "When the Initiator sends the I1 packet for initializing a connection, the Responder receives the HIT and IP address from the packet, and generates an #I value for the puzzle. The #I value is set to the pre-signed R1 packet.",
      "ja": "イニシエータは接続を初期化するためI1パケットを送信すると、レスポンダは、パケットからHITとIPアドレスを受信し、パズルのための#I値を生成します。 #I値は、予め署名R1パケットに設定されています。"
    },
    {
      "indent": 7,
      "text": "#I value calculation:\n#I = Ltrunc( RHASH ( S | HIT-I | HIT-R | IP-I | IP-R ), n)\nwhere n = RHASH_len",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The RHASH algorithm is the same as is used to generate the Responder's HIT value.",
      "ja": "RHASHアルゴリズムは、レスポンダのHIT値を生成するために使用されるのと同じです。"
    },
    {
      "indent": 3,
      "text": "From an incoming I2 packet, the Responder receives the required information to validate the puzzle: HITs, IP addresses, and the information of the used S value from the R1_COUNTER. Using these values, the Responder can regenerate the #I, and verify it against the #I received in the I2 packet. If the #I values match, it can verify the solution using #I, #J, and difficulty #K. If the #I values do not match, the I2 is dropped.",
      "ja": "HITS、IPアドレス、およびR1_COUNTERから使用S値の情報：入ってくるI2パケットから、Responderは、パズルを検証するために必要な情報を受け取ります。これらの値を用いて、Responderは#Iを再生成し、#IはI2パケットで受信に対してそれを確認することができます。 #Iの値が一致した場合、それは＃I、＃J、および難易＃Kを使用してソリューションを検証することができます。 #Iの値が一致しない場合、I2はドロップされます。"
    },
    {
      "indent": 7,
      "text": "puzzle_check:\nV := Ltrunc( RHASH( I2.I | I2.hit_i | I2.hit_r | I2.J ), #K )\nif V != 0, drop the packet",
      "raw": true
    },
    {
      "indent": 3,
      "text": "If the puzzle solution is correct, the #I and #J values are stored for later use. They are used as input material when keying material is generated.",
      "ja": "パズル溶液が正しい場合、#Iと#J値は、後の使用のために格納されています。キーイング材料が生成されるときには、入力材料として使用されます。"
    },
    {
      "indent": 3,
      "text": "Keeping state about failed puzzle solutions depends on the implementation. Although it is possible for the Responder not to keep any state information, it still may do so to protect itself against certain attacks (see Section 4.1.1).",
      "ja": "失敗したパズルのソリューションについての状態を保つことは、実装に依存します。 Responderがどのような状態情報を保持しないためにそれは可能ですが、それはまだ特定の攻撃（4.1.1項を参照）に対して自身を守るためにそうすることができます。"
    },
    {
      "indent": 0,
      "text": "Appendix B. Generating a Public Key Encoding from an HI",
      "ja": "HIから公開鍵暗号の生成付録B."
    },
    {
      "indent": 3,
      "text": "The following pseudo-code illustrates the process to generate a public key encoding from an HI for both RSA and DSA.",
      "ja": "次の擬似コードは、RSAやDSAの両方のためのHIから公開鍵暗号を生成するプロセスを示します。"
    },
    {
      "indent": 3,
      "text": "The symbol \":=\" denotes assignment; the symbol \"+=\" denotes appending. The pseudo-function \"encode_in_network_byte_order\" takes two parameters, an integer (bignum) and a length in bytes, and returns the integer encoded into a byte string of the given length.",
      "ja": "記号「：=」は代入を表します。シンボルは「+ =」添付を示しています。擬似関数「encode_in_network_byte_order」は、2つのパラメータ、整数（BIGNUM）およびバイト単位の長さをとり、所定の長さのバイト列にエンコードされた整数値を返します。"
    },
    {
      "indent": 3,
      "text": "switch ( HI.algorithm ) {",
      "ja": "スイッチ（HI.algorithm）{"
    },
    {
      "indent": 3,
      "text": "case RSA: buffer := encode_in_network_byte_order ( HI.RSA.e_len, ( HI.RSA.e_len > 255 ) ? 3 : 1 ) buffer += encode_in_network_byte_order ( HI.RSA.e, HI.RSA.e_len ) buffer += encode_in_network_byte_order ( HI.RSA.n, HI.RSA.n_len )",
      "ja": "ケースRSA：バッファー：= encode_in_network_byte_order（HI.RSA.e_len、（> 255 HI.RSA.e_len）3：1）バッファー+ = encode_in_network_byte_order（HI.RSA.e、HI.RSA.e_len）バッファー+ = encode_in_network_byte_order（ HI.RSA.n、HI.RSA.n_len）"
    },
    {
      "indent": 6,
      "text": "break;",
      "ja": "ブレーク;"
    },
    {
      "indent": 3,
      "text": "case DSA: buffer := encode_in_network_byte_order ( HI.DSA.T , 1 ) buffer += encode_in_network_byte_order ( HI.DSA.Q , 20 ) buffer += encode_in_network_byte_order ( HI.DSA.P , 64 + 8 * HI.DSA.T ) buffer += encode_in_network_byte_order ( HI.DSA.G , 64 + 8 * HI.DSA.T ) buffer += encode_in_network_byte_order ( HI.DSA.Y , 64 + 8 * HI.DSA.T )",
      "ja": "ケースDSA：バッファー：= encode_in_network_byte_order（HI.DSA.T、1）バッファ+ = encode_in_network_byte_order（HI.DSA.Q、20）緩衝剤+ = encode_in_network_byte_order（HI.DSA.P、64 + 8 * HI.DSA.T）バッファ+ = encode_in_network_byte_order（HI.DSA.G、64 + 8 * HI.DSA.T）+ = encode_in_network_byte_orderバッファ（HI.DSA.Y、64 + 8 * HI.DSA.T）"
    },
    {
      "indent": 6,
      "text": "break;",
      "ja": "ブレーク;"
    },
    {
      "indent": 3,
      "text": "}",
      "ja": "｝"
    },
    {
      "indent": 0,
      "text": "Appendix C. Example Checksums for HIP Packets",
      "ja": "付録C.例サムHIPパケットのために"
    },
    {
      "indent": 3,
      "text": "The HIP checksum for HIP packets is specified in Section 5.1.1. Checksums for TCP and UDP packets running over HIP-enabled security associations are specified in Section 4.5.1. The examples below use [RFC3849] and [RFC5737] addresses, and HITs with the prefix of 2001:20 followed by zeros, followed by a decimal 1 or 2, respectively.",
      "ja": "HIPパケットのHIPチェックサムは、セクション5.1.1で指定されています。 HIP-有効なセキュリティアソシエーション上で実行されているTCPおよびUDPパケットのためのチェックサムは、セクション4.5.1で指定されています。使用以下の例[RFC3849]と2001年の接頭辞[RFC5737]アドレス、およびヒット数：小数それぞれ1又は2、続いてゼロ、続く20。"
    },
    {
      "indent": 3,
      "text": "The following example is defined only for testing the checksum calculation.",
      "ja": "以下の実施例のみチェックサム計算をテストするために定義されています。"
    },
    {
      "indent": 0,
      "text": "C.1. IPv6 HIP Example (I1 Packet)",
      "ja": "C.1。 IPv6のHIP例（I1パケット）"
    },
    {
      "indent": 5,
      "text": "Source Address:                 2001:db8::1\nDestination Address:            2001:db8::2\nUpper-Layer Packet Length:      48              0x30\nNext Header:                    139             0x8b\nPayload Protocol:               59              0x3b\nHeader Length:                  5               0x5\nPacket Type:                    1               0x1\nVersion:                        2               0x2\nReserved:                       1               0x1\nControl:                        0               0x0\nChecksum:                       6750            0x1a5e\nSender's HIT:                   2001:20::1\nReceiver's HIT:                 2001:20::2\nDH_GROUP_LIST type:             511             0x1ff\nDH_GROUP_LIST length:           3               0x3\nDH_GROUP_LIST Group IDs:        3,4,8",
      "raw": true
    },
    {
      "indent": 0,
      "text": "C.2. IPv4 HIP Packet (I1 Packet)",
      "ja": "C.2。 IPv4 HIPパケット（I1パケット）"
    },
    {
      "indent": 3,
      "text": "The IPv4 checksum value for the example I1 packet is shown below.",
      "ja": "例えば、I1パケットのIPv4チェックサム値を以下に示します。"
    },
    {
      "indent": 5,
      "text": "Source Address: 192.0.2.1 Destination Address: 192.0.2.2 Upper-Layer Packet Length: 48 0x30 Next Header: 139 0x8b Payload Protocol: 59 0x3b Header Length: 5 0x5 Packet Type: 1 0x1 Version: 2 0x2 Reserved: 1 0x1 Control: 0 0x0 Checksum: 61902 0xf1ce Sender's HIT: 2001:20::1 Receiver's HIT: 2001:20::2 DH_GROUP_LIST type: 511 0x1ff DH_GROUP_LIST length: 3 0x3 DH_GROUP_LIST Group IDs: 3,4,8",
      "ja": "送信元アドレス：192.0.2.1の宛先アドレス：192.0.2.2上位層パケットの長さ：48 0x30の次のヘッダ：139 0x8bペイロードプロトコル：59 0x3bヘッダ長：5 0x5のパケットタイプ：1 ​​0x1のバージョン：2 0x2の予約：1つの0x1のコントロール： 0 0x0のチェックサム：61902 0xf1ce送信者HIT：2001：20 :: 1 ReceiverのHIT：2001：20 :: 2 DH_GROUP_LISTタイプ：511 0x1ff DH_GROUP_LIST長さ：3を0x3 DH_GROUP_LISTグループID：-1,3,4,8-"
    },
    {
      "indent": 0,
      "text": "C.3. TCP Segment",
      "ja": "C.3。 TCPセグメント"
    },
    {
      "indent": 3,
      "text": "Regardless of whether IPv6 or IPv4 is used, the TCP and UDP sockets use the IPv6 pseudo header format [RFC2460], with the HITs used in place of the IPv6 addresses.",
      "ja": "かかわらずのIPv6またはIPv4を使用するかどうかの、TCPとUDPソケットは、IPv6アドレスの代わりに使用するヒットと、IPv6の疑似ヘッダフォーマット[RFC2460]を使用します。"
    },
    {
      "indent": 5,
      "text": "Sender's HIT: 2001:20::1 Receiver's HIT: 2001:20::2 Upper-Layer Packet Length: 20 0x14 Next Header: 6 0x06 Source port: 65500 0xffdc Destination port: 22 0x0016 Sequence number: 1 0x00000001 Acknowledgment number: 0 0x00000000 Data offset: 5 0x5 Flags: SYN 0x02 Window size: 65535 0xffff Checksum: 28586 0x6faa Urgent pointer: 0 0x0000",
      "ja": "送信者のHIT：2001：20 :: 1 ReceiverのHIT：2001：20 :: 2上位層パケットの長さ：20 0x14に次のヘッダ：6 0x06の送信元ポート：65500 0xffdc宛先ポート：22 0x0016シーケンス番号：1 0x00000001の確認番号：0 0x00000000のデータは、オフセット：5つの0x5フラグ：SYN 0x02のウィンドウサイズ：チェックサム0xFFFFの65535：28586 0x6faa緊急ポインタ：0 0000を"
    },
    {
      "indent": 0,
      "text": "Appendix D. ECDH and ECDSA 160-Bit Groups",
      "ja": "付録D. ECDHとECDSA 160ビットグループ"
    },
    {
      "indent": 3,
      "text": "The ECDH and ECDSA 160-bit group SECP160R1 is rated at 80 bits symmetric strength. This was once considered appropriate for one year of security. Today, these groups should be used only when the host is not powerful enough (e.g., some embedded devices) and when security requirements are low (e.g., long-term confidentiality is not required).",
      "ja": "ECDHとECDSA 160ビットのグループSECP160R1は80ビット対称な強度で評価されます。これは、一度セキュリティの一年間の適切であると考えられました。今日では、これらのグループは、ホストが十分に強力でない場合にのみ使用すべきである（例えば、いくつかの組み込み機器）とセキュリティ要件が低い（例えば、長期の機密性が必要とされていない）しているとき。"
    },
    {
      "indent": 0,
      "text": "Appendix E. HIT Suites and HIT Generation",
      "ja": "付録E.はスイートとHITの生成を打ちます"
    },
    {
      "indent": 3,
      "text": "The HIT as an ORCHID [RFC7343] consists of three parts: A 28-bit prefix, a 4-bit encoding of the ORCHID generation algorithm (OGA), and a hash that includes the Host Identity and a context ID. The OGA is an index pointing to the specific algorithm by which the public key and the 96-bit hashed encoding are generated. The OGA is protocol specific and is to be interpreted as defined below for all protocols that use the same context ID as HIP. HIP groups sets of valid combinations of signature and hash algorithms into HIT Suites. These HIT Suites are addressed by an index, which is transmitted in the OGA ID field of the ORCHID.",
      "ja": "28ビットのプレフィックス、蘭生成アルゴリズム（OGA）の4ビットの符号化、およびホストID、コンテキストIDを含むハッシュ：ORCHID [RFC7343]としてHITは、3つの部分から構成されています。 OGAは、公開鍵と96ビットのハッシュ符号が生成されることにより、特定のアルゴリズムを指し示すインデックスです。 OGAは、プロトコル固有であり、HIPと同じコンテキストIDを使用するすべてのプロトコルのために以下に定義するように解釈されるべきです。 HITスイーツへの署名とハッシュアルゴリズムの有効な組み合わせのHIPグループセット。これらHITスイートはORCHIDのOGA IDフィールドで送信されたインデックス、によって対処されます。"
    },
    {
      "indent": 3,
      "text": "The set of used HIT Suites will be extended to counter the progress in computation capabilities and vulnerabilities in the employed algorithms. The intended use of the HIT Suites is to introduce a new HIT Suite and phase out an old one before it becomes insecure. Since the 4-bit OGA ID field only permits 15 HIT Suites to be used at the same time (the HIT Suite with ID 0 is reserved), phased-out HIT",
      "ja": "使用HITスイートのセットは、使用するアルゴリズムでの演算能力と脆弱性の進展に対抗するように拡張されます。 HITスイーツの使用目的は、新しいHITスイートを導入し、それが安全ではないになる前に、古いものを段階的にです。 4ビットOGA IDフィールドのみ（ID 0のHITスイートが予約されている）を同時に使用する15のHITスイートを可能にするため、段階的アウトHIT"
    },
    {
      "indent": 3,
      "text": "Suites must be reused at some point. In such a case, there will be a rollover of the HIT Suite ID and the next newly introduced HIT Suite will start with a lower HIT Suite index than the previously introduced one. The rollover effectively deprecates the reused HIT Suite. For a smooth transition, the HIT Suite should be deprecated a considerable time before the HIT Suite index is reused.",
      "ja": "スイートには、いくつかの点で再利用されなければなりません。このような場合には、HITスイートIDのロールオーバーと以前に導入されたものより低いHITスイートインデックスで開始され、次の新たに導入されたHITスイートが存在するであろう。ロールオーバーが有効に再利用HIT Suiteを非難します。スムーズな移行のために、HITスイートは、HITスイートインデックスが再利用される前に、かなりの時間を廃止されるべきです。"
    },
    {
      "indent": 3,
      "text": "Since the number of HIT Suites is tightly limited to 16, the HIT Suites must be assigned carefully. Hence, sets of suitable algorithms are grouped in a HIT Suite.",
      "ja": "HITスイートの数はしっかりと16に制限されているので、HITのスイートは、慎重に割り当てる必要があります。したがって、適切なアルゴリズムのセットは、HITスイートにグループ化されます。"
    },
    {
      "indent": 3,
      "text": "The HIT Suite of the Responder's HIT determines the RHASH and the hash function to be used for the HMAC in HIP packets as well as the signature algorithm family used for generating the HI. The list of HIT Suites is defined in Table 10.",
      "ja": "レスポンダのHITのHITスイートRHASHとHIPパケットならびにHIを生成するために使用される署名アルゴリズムのファミリーでHMACに使用されるハッシュ関数を決定します。 HITスイートのリストは、表10に定義されています。"
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "The drive to create HIP came to being after attending the MALLOC meeting at the 43rd IETF meeting. Baiju Patel and Hilarie Orman really gave the original author, Bob Moskowitz, the assist to get HIP beyond 5 paragraphs of ideas. It has matured considerably since the early versions thanks to extensive input from IETFers. Most importantly, its design goals are articulated and are different from other efforts in this direction. Particular mention goes to the members of the NameSpace Research Group of the IRTF. Noel Chiappa provided valuable input at early stages of discussions about identifier handling and Keith Moore the impetus to provide resolvability. Steve Deering provided encouragement to keep working, as a solid proposal can act as a proof of ideas for a research group.",
      "ja": "HIPを作成するには、ドライブが第43回IETF会合でMALLOC会議に出席した後であることになりました。 Baijuパテルとヒラリーオーマンは本当に原作者、ボブ・モスコウィッツ、アイデアの5つの段落を超えてHIPを取得するために支援を与えました。これは、初期バージョン以来かなりIETFersから広範囲の入力のおかげで成熟しています。最も重要なのは、その設計目標は、多関節と、この方向で他の努力とは異なりますされています。特に言及はIRTFのネームスペース研究グループのメンバーになります。クリスマスChiappaは、識別子の取り扱いとキース・ムーア解像性を提供するために、弾み議論の早い段階での貴重な入力を提供します。スティーブデアリングは、固体の提案は研究グループのためのアイデアの証明として機能することができて、作業を続けるために励ましを提供します。"
    },
    {
      "indent": 3,
      "text": "Many others contributed; extensive security tips were provided by Steve Bellovin. Rob Austein kept the DNS parts on track. Paul Kocher taught Bob Moskowitz how to make the puzzle exchange expensive for the Initiator to respond, but easy for the Responder to validate. Bill Sommerfeld supplied the Birthday concept, which later evolved into the R1 generation counter, to simplify reboot management. Erik Nordmark supplied the CLOSE-mechanism for closing connections. Rodney Thayer and Hugh Daniels provided extensive feedback. In the early times of this document, John Gilmore kept Bob Moskowitz challenged to provide something of value.",
      "ja": "多くの他の人が貢献しました。広範なセキュリティのヒントは、スティーブBellovin氏によって提供されました。ロブAusteinとは、トラック上のDNS部品を保ちました。ポール・コッフェルはパズルの交換がイニシエータが応答するために高価な、しかし検証するResponderのための簡単な作り方をボブ・モスコウィッツを教えました。ビル・ゾンマーフェルトは、後で再起動管理を簡素化するために、R1世代カウンタに進化誕生日概念を、供給されました。エリックNordmarkとは、接続を閉じるためのCLOSE-メカニズムを提供しました。ロドニーセイヤーとヒュー・ダニエルズは、広範なフィードバックを提供しました。このドキュメントの初期の時代には、ジョン・ギルモアは、ボブ・モスコウィッツは、価値のあるものを提供するために挑戦し続けました。"
    },
    {
      "indent": 3,
      "text": "During the later stages of this document, when the editing baton was transferred to Pekka Nikander, the input from the early implementors was invaluable. Without having actual implementations, this document would not be on the level it is now.",
      "ja": "編集バトンがペッカNikanderに移したときに、このドキュメントの後の段階で、早期の実装者からの入力は非常に貴重でした。実際の実装を持たずに、この文書は、それが今のレベルにはならないでしょう。"
    },
    {
      "indent": 3,
      "text": "In the usual IETF fashion, a large number of people have contributed to the actual text or ideas. The list of these people includes Jeff Ahrenholz, Francis Dupont, Derek Fawcus, George Gross, Xin Gu, Rene Hummen, Miika Komu, Mika Kousa, Julien Laganier, Andrew McGregor, Jan Melen, Henrik Petander, Michael Richardson, Tim Shepard, Jorma Wall, and Jukka Ylitalo. Our apologies to anyone whose name is missing.",
      "ja": "通常のIETFのファッションでは、多数の人々は、実際のテキストやアイデアに貢献してきました。これらの人々のリストはジェフAhrenholz、フランシスデュポン、デレクFawcus、ジョージ・グロス、新区、ルネHummen、Miikaこむ、ミカKousa、ジュリアンLaganier、アンドリュー・マクレガー、ジャンメレン、ヘンリクPetander、マイケル・リチャードソン、ティム・シェパード、ヨルマ壁を含みます、およびユッカYlitalo。名前欠けている誰にも私たちの謝罪。"
    },
    {
      "indent": 3,
      "text": "Once the HIP Working Group was founded in early 2004, a number of changes were introduced through the working group process. Most notably, the original document was split in two, one containing the base exchange and the other one defining how to use ESP. Some modifications to the protocol proposed by Aura, et al. [AUR05] were added at a later stage.",
      "ja": "HIPワーキンググループは、2004年初めに設立された後は、変更の数は、ワーキンググループのプロセスを経て導入されました。最も顕著なのは、元の文書は、二つの、塩基交換とESPを使用する方法を定義する他のものを含む1に分割されました。オーラによって提案されたプロトコルにいくつかの変更、ら。 【AUR05】後の段階で添加しました。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Robert Moskowitz (editor) HTT Consulting Oak Park, MI United States",
      "ja": "ロバート・モスコウィッツ（エディタ）HTTコンサルティングオークパーク、MI、米国"
    },
    {
      "indent": 3,
      "text": "EMail: rgm@labs.htt-consult.com",
      "ja": "メールアドレス：rgm@labs.htt-consult.com"
    },
    {
      "indent": 3,
      "text": "Tobias Heer Hirschmann Automation and Control Stuttgarter Strasse 45-51 Neckartenzlingen 72654 Germany",
      "ja": "トビアス軍ヒルシュマンオートメーションとコントロールシュツットガルトシュトラーセ45-51 72654 Neckartenzlingenドイツ"
    },
    {
      "indent": 3,
      "text": "EMail: tobias.heer@belden.com",
      "ja": "メールアドレス：tobias.heer@belden.com"
    },
    {
      "indent": 3,
      "text": "Petri Jokela Ericsson Research NomadicLab Jorvas FIN-02420 Finland",
      "ja": "ペトリJokelaエリクソン研究NomadicLab Jorvas FIN-02420フィンランド"
    },
    {
      "indent": 3,
      "text": "Phone: +358 9 299 1 EMail: petri.jokela@nomadiclab.com",
      "ja": "電話：+358 9 299 1 Eメール：petri.jokela@nomadiclab.com"
    },
    {
      "indent": 3,
      "text": "Thomas R. Henderson University of Washington Campus Box 352500 Seattle, WA United States",
      "ja": "トーマス・R.ヘンダーソンワシントン大学のキャンパスボックス352500シアトル、ワシントン州、米国"
    },
    {
      "indent": 3,
      "text": "EMail: tomhend@u.washington.edu",
      "ja": "メールアドレス：tomhend@u.washington.edu"
    }
  ]
}