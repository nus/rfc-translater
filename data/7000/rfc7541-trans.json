{
  "title": {
    "text": "RFC 7541 - HPACK: Header Compression for HTTP/2",
    "ja": "RFC 7541 - HPACK：ヘッダー圧縮のためのHTTP / 2"
  },
  "number": 7541,
  "created_at": "2019-10-30 04:32:52.609224+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                           R. Peon\nRequest for Comments: 7541                                   Google, Inc\nCategory: Standards Track                                     H. Ruellan\nISSN: 2070-1721                                                Canon CRF\n                                                                May 2015",
      "raw": true
    },
    {
      "indent": 18,
      "text": "HPACK: Header Compression for HTTP/2",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This specification defines HPACK, a compression format for efficiently representing HTTP header fields, to be used in HTTP/2.",
      "ja": "この仕様はHPACK、効率的にHTTP / 2で使用されるように、HTTPヘッダフィールドを表すための圧縮フォーマットを定義します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 5741のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7541.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7541で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2015 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2015 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................4\n   1.1. Overview ...................................................4\n   1.2. Conventions ................................................5\n   1.3. Terminology ................................................5\n2. Compression Process Overview ....................................6\n   2.1. Header List Ordering .......................................6\n   2.2. Encoding and Decoding Contexts .............................6\n   2.3. Indexing Tables ............................................6\n        2.3.1. Static Table ........................................6\n        2.3.2. Dynamic Table .......................................6\n        2.3.3. Index Address Space .................................7\n   2.4. Header Field Representation ................................8\n3. Header Block Decoding ...........................................8\n   3.1. Header Block Processing ....................................8\n   3.2. Header Field Representation Processing .....................9\n4. Dynamic Table Management ........................................9\n   4.1. Calculating Table Size ....................................10\n   4.2. Maximum Table Size ........................................10\n   4.3. Entry Eviction When Dynamic Table Size Changes ............11\n   4.4. Entry Eviction When Adding New Entries ....................11\n5. Primitive Type Representations .................................11\n   5.1. Integer Representation ....................................11\n   5.2. String Literal Representation .............................13\n6. Binary Format ..................................................14\n   6.1. Indexed Header Field Representation .......................14\n   6.2. Literal Header Field Representation .......................15\n        6.2.1. Literal Header Field with Incremental Indexing .....15\n        6.2.2. Literal Header Field without Indexing ..............16\n        6.2.3. Literal Header Field Never Indexed .................17\n   6.3. Dynamic Table Size Update .................................18\n7. Security Considerations ........................................19\n   7.1. Probing Dynamic Table State ...............................19\n        7.1.1. Applicability to HPACK and HTTP ....................20\n        7.1.2. Mitigation .........................................20\n        7.1.3. Never-Indexed Literals .............................21\n   7.2. Static Huffman Encoding ...................................22\n   7.3. Memory Consumption ........................................22\n   7.4. Implementation Limits .....................................23\n8. References .....................................................23\n   8.1. Normative References ......................................23\n   8.2. Informative References ....................................24\nAppendix A. Static Table Definition ...............................25\nAppendix B. Huffman Code ..........................................27",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Appendix C. Examples ..............................................33\n  C.1. Integer Representation Examples ............................33\n    C.1.1. Example 1: Encoding 10 Using a 5-Bit Prefix ............33\n    C.1.2. Example 2: Encoding 1337 Using a 5-Bit Prefix ..........33\n    C.1.3. Example 3: Encoding 42 Starting at an Octet Boundary ...34\n  C.2. Header Field Representation Examples .......................34\n    C.2.1. Literal Header Field with Indexing .....................34\n    C.2.2. Literal Header Field without Indexing ..................35\n    C.2.3. Literal Header Field Never Indexed .....................36\n    C.2.4. Indexed Header Field ...................................37\n  C.3. Request Examples without Huffman Coding ....................37\n    C.3.1. First Request ..........................................37\n    C.3.2. Second Request .........................................38\n    C.3.3. Third Request ..........................................39\n  C.4. Request Examples with Huffman Coding .......................41\n    C.4.1. First Request ..........................................41\n    C.4.2. Second Request .........................................42\n    C.4.3. Third Request ..........................................43\n  C.5. Response Examples without Huffman Coding ...................45\n    C.5.1. First Response .........................................45\n    C.5.2. Second Response ........................................46\n    C.5.3. Third Response .........................................47\n  C.6. Response Examples with Huffman Coding ......................49\n    C.6.1. First Response .........................................49\n    C.6.2. Second Response ........................................51\n    C.6.3. Third Response .........................................52\nAcknowledgments ...................................................55\nAuthors' Addresses ................................................55",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "In HTTP/1.1 (see [RFC7230]), header fields are not compressed. As web pages have grown to require dozens to hundreds of requests, the redundant header fields in these requests unnecessarily consume bandwidth, measurably increasing latency.",
      "ja": "HTTP / 1.1（[RFC7230]を参照）、ヘッダフィールドは圧縮されません。 Webページがリクエストの数十〜数百を必要とするように成長してきたように、これらの要求で冗長ヘッダフィールドは、不必要に測定可能な待ち時間が増加、帯域幅を消費します。"
    },
    {
      "indent": 3,
      "text": "SPDY [SPDY] initially addressed this redundancy by compressing header fields using the DEFLATE [DEFLATE] format, which proved very effective at efficiently representing the redundant header fields. However, that approach exposed a security risk as demonstrated by the CRIME (Compression Ratio Info-leak Made Easy) attack (see [CRIME]).",
      "ja": "SPDYは[SPDY]最初に効率的に冗長なヘッダフィールドを表すのに非常に有効であることが証明DEFLATE [DEFLATE]フォーマットを使用して、ヘッダフィールドを圧縮することによって、この冗長性に対処しました。犯罪（圧縮率インフォリークMade Easyを）攻撃（[犯罪]を参照）によって実証されるようにしかし、そのアプローチは、セキュリティ上のリスクを露呈しました。"
    },
    {
      "indent": 3,
      "text": "This specification defines HPACK, a new compressor that eliminates redundant header fields, limits vulnerability to known security attacks, and has a bounded memory requirement for use in constrained environments. Potential security concerns for HPACK are described in Section 7.",
      "ja": "この仕様はHPACK、冗長ヘッダフィールドを排除する既知のセキュリティ攻撃に対する脆弱性を制限する新たなコンプレッサーを定義し、制約のある環境で使用するための有界メモリ要件を有しています。 HPACKのための潜在的なセキュリティ上の懸念は、第7節で説明されています。"
    },
    {
      "indent": 3,
      "text": "The HPACK format is intentionally simple and inflexible. Both characteristics reduce the risk of interoperability or security issues due to implementation error. No extensibility mechanisms are defined; changes to the format are only possible by defining a complete replacement.",
      "ja": "HPACKフォーマットは、意図的にシンプルで柔軟性がありません。両方の特性は、実装誤差による相互運用性やセキュリティの問題のリスクを軽減します。いいえ拡張メカニズムが定義されていません。フォーマットへの変更は、完全な交換を定義することによってのみ可能です。"
    },
    {
      "indent": 0,
      "text": "1.1. Overview",
      "section_title": true,
      "ja": "1.1. 概要"
    },
    {
      "indent": 3,
      "text": "The format defined in this specification treats a list of header fields as an ordered collection of name-value pairs that can include duplicate pairs. Names and values are considered to be opaque sequences of octets, and the order of header fields is preserved after being compressed and decompressed.",
      "ja": "本明細書で定義されたフォーマットは、重複するペアを含むことができ、名前と値のペアの順序付き集合としてヘッダフィールドのリストを処理します。名前と値はオクテットの不透明な配列であると考えられ、そしてヘッダフィールドの順序は、圧縮及び解凍された後に保存されます。"
    },
    {
      "indent": 3,
      "text": "Encoding is informed by header field tables that map header fields to indexed values. These header field tables can be incrementally updated as new header fields are encoded or decoded.",
      "ja": "符号化は、索引付けされた値にヘッダフィールドをマッピングするヘッダ・フィールド・テーブルによって通知されます。新しいヘッダフィールドが符号化又は復号化されるように、これらのヘッダ・フィールド・テーブルは、増分更新することができます。"
    },
    {
      "indent": 3,
      "text": "In the encoded form, a header field is represented either literally or as a reference to a header field in one of the header field tables. Therefore, a list of header fields can be encoded using a mixture of references and literal values.",
      "ja": "符号化された形態では、ヘッダフィールドは、文字通りまたはヘッダフィールドテーブルの1つのヘッダフィールドへの参照のいずれかとして表されています。したがって、ヘッダフィールドのリストを参照し、リテラル値の混合物を使用して符号化することができます。"
    },
    {
      "indent": 3,
      "text": "Literal values are either encoded directly or use a static Huffman code.",
      "ja": "リテラル値は、直接符号化された、または静的ハフマン符号を使用しています。"
    },
    {
      "indent": 3,
      "text": "The encoder is responsible for deciding which header fields to insert as new entries in the header field tables. The decoder executes the modifications to the header field tables prescribed by the encoder, reconstructing the list of header fields in the process. This enables decoders to remain simple and interoperate with a wide variety of encoders.",
      "ja": "エンコーダは、ヘッダフィールドのテーブルに新規エントリとして挿入するためにヘッダフィールドを決定する責任があります。デコーダは、プロセス内のヘッダフィールドのリストを再構築する、エンコーダによって所定のヘッダフィールドのテーブルへの変更を実行します。これは単純なままで、エンコーダの多種多様と相互運用できるようにデコーダを可能にします。"
    },
    {
      "indent": 3,
      "text": "Examples illustrating the use of these different mechanisms to represent header fields are available in Appendix C.",
      "ja": "ヘッダフィールドを表すために、これらの異なるメカニズムの使用を示す例は、付録Cで利用可能です"
    },
    {
      "indent": 0,
      "text": "1.2. Conventions",
      "section_title": true,
      "ja": "1.2. 表記"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [RFC2119].",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はRFC 2119 [RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 3,
      "text": "All numeric values are in network byte order. Values are unsigned unless otherwise indicated. Literal values are provided in decimal or hexadecimal as appropriate.",
      "ja": "すべての数値は、ネットワークバイト順です。特に断らない限り、値は符号なしです。リテラル値は、必要に応じて10進数または16進数で提供されます。"
    },
    {
      "indent": 0,
      "text": "1.3. Terminology",
      "section_title": true,
      "ja": "1.3. 用語"
    },
    {
      "indent": 3,
      "text": "This specification uses the following terms:",
      "ja": "この仕様は、次の用語を使用します。"
    },
    {
      "indent": 3,
      "text": "Header Field: A name-value pair. Both the name and value are treated as opaque sequences of octets.",
      "ja": "ヘッダーフィールド：名前と値のペア。名前と値の両方がオクテットの不透明なシーケンスとして扱われます。"
    },
    {
      "indent": 3,
      "text": "Dynamic Table: The dynamic table (see Section 2.3.2) is a table that associates stored header fields with index values. This table is dynamic and specific to an encoding or decoding context.",
      "ja": "動的表：動的テーブル（セクション2.3.2を参照）のインデックス値を格納されたヘッダフィールドを関連付けるテーブルです。このテーブルは、符号化または復号化コンテキストに動的かつ特異的です。"
    },
    {
      "indent": 3,
      "text": "Static Table: The static table (see Section 2.3.1) is a table that statically associates header fields that occur frequently with index values. This table is ordered, read-only, always accessible, and it may be shared amongst all encoding or decoding contexts.",
      "ja": "静的表：静的テーブル（セクション2.3.1を参照）静的インデックス値と頻繁に発生ヘッダーフィールドを対応付けたテーブルです。このテーブルは読み取り専用で、常にアクセス、発注され、そしてそれは、すべてのエンコードまたはデコードコンテキスト間で共有することができます。"
    },
    {
      "indent": 3,
      "text": "Header List: A header list is an ordered collection of header fields that are encoded jointly and can contain duplicate header fields. A complete list of header fields contained in an HTTP/2 header block is a header list.",
      "ja": "ヘッダーリスト：ヘッダリストは、一緒に符号化され、重複したヘッダフィールドを含めることができますヘッダフィールドの順序付きコレクションです。 HTTP / 2ヘッダブロックに含まれるヘッダフィールドの完全なリストは、ヘッダリストです。"
    },
    {
      "indent": 3,
      "text": "Header Field Representation: A header field can be represented in encoded form either as a literal or as an index (see Section 2.4).",
      "ja": "ヘッダフィールド表示：ヘッダーフィールド（セクション2.4を参照）のいずれかリテラルまたはインデックスのようにエンコードされた形式で表現することができます。"
    },
    {
      "indent": 3,
      "text": "Header Block: An ordered list of header field representations, which, when decoded, yields a complete header list.",
      "ja": "ヘッダーブロック：デコード、ヘッダフィールド表現の順序付けられたリストは、完全なヘッダのリストを生成します。"
    },
    {
      "indent": 0,
      "text": "2. Compression Process Overview",
      "section_title": true,
      "ja": "2.圧縮プロセスの概要"
    },
    {
      "indent": 3,
      "text": "This specification does not describe a specific algorithm for an encoder. Instead, it defines precisely how a decoder is expected to operate, allowing encoders to produce any encoding that this definition permits.",
      "ja": "この仕様は、エンコーダのための特定のアルゴリズムを記述していません。代わりに、デコーダは、エンコーダが、この定義が可能にする任意の符号化を生成することができ、動作することが期待される正確方法を定義します。"
    },
    {
      "indent": 0,
      "text": "2.1. Header List Ordering",
      "section_title": true,
      "ja": "2.1. ヘッダリストの順序"
    },
    {
      "indent": 3,
      "text": "HPACK preserves the ordering of header fields inside the header list. An encoder MUST order header field representations in the header block according to their ordering in the original header list. A decoder MUST order header fields in the decoded header list according to their ordering in the header block.",
      "ja": "HPACKは、ヘッダリスト内のヘッダフィールドの順序を保持します。エンコーダは、元のヘッダのリストにおけるそれらの順序に従ってヘッダブロック内のヘッダフィールドの表現を注文しなければなりません。デコーダは、ヘッダブロックでの順序付けに従ってデコードされたヘッダリストのヘッダフィールドを注文しなければなりません。"
    },
    {
      "indent": 0,
      "text": "2.2. Encoding and Decoding Contexts",
      "section_title": true,
      "ja": "2.2. 符号化と復号化コンテキスト"
    },
    {
      "indent": 3,
      "text": "To decompress header blocks, a decoder only needs to maintain a dynamic table (see Section 2.3.2) as a decoding context. No other dynamic state is needed.",
      "ja": "ヘッダブロックを解凍するために、デコーダは、復号化コンテキストとして（セクション2.3.2を参照）動的テーブルを維持する必要があります。他の動的な状態は必要ありません。"
    },
    {
      "indent": 3,
      "text": "When used for bidirectional communication, such as in HTTP, the encoding and decoding dynamic tables maintained by an endpoint are completely independent, i.e., the request and response dynamic tables are separate.",
      "ja": "例えばHTTPのような双方向通信のために使用される場合、エンドポイントによって維持符号化及び復号化ダイナミックテーブル、すなわち、要求と応答動的テーブルが分離されて、完全に独立しています。"
    },
    {
      "indent": 0,
      "text": "2.3. Indexing Tables",
      "section_title": true,
      "ja": "2.3. インデックステーブル"
    },
    {
      "indent": 3,
      "text": "HPACK uses two tables for associating header fields to indexes. The static table (see Section 2.3.1) is predefined and contains common header fields (most of them with an empty value). The dynamic table (see Section 2.3.2) is dynamic and can be used by the encoder to index header fields repeated in the encoded header lists.",
      "ja": "HPACKはインデックスにヘッダーフィールドを関連付けるための2つのテーブルを使用します。静的テーブル（セクション2.3.1を参照）は、事前定義され、共通のヘッダフィールド（空の値を持つそれらのほとんど）を含みます。動的テーブル（セクション2.3.2参照）、動的であり、符号化されたヘッダリストに繰り返しインデックスヘッダフィールドにエンコーダによって使用することができます。"
    },
    {
      "indent": 3,
      "text": "These two tables are combined into a single address space for defining index values (see Section 2.3.3).",
      "ja": "この2つのテーブルは、インデックス値を定義するための単一アドレス空間に結合される（セクション2.3.3参照）。"
    },
    {
      "indent": 0,
      "text": "2.3.1. Static Table",
      "section_title": true,
      "ja": "2.3.1. 静的表"
    },
    {
      "indent": 3,
      "text": "The static table consists of a predefined static list of header fields. Its entries are defined in Appendix A.",
      "ja": "静的テーブルは、ヘッダフィールドの所定の静的リストから成ります。そのエントリは、付録Aで定義されています"
    },
    {
      "indent": 0,
      "text": "2.3.2. Dynamic Table",
      "section_title": true,
      "ja": "2.3.2. 動的テーブル"
    },
    {
      "indent": 3,
      "text": "The dynamic table consists of a list of header fields maintained in first-in, first-out order. The first and newest entry in a dynamic table is at the lowest index, and the oldest entry of a dynamic table is at the highest index.",
      "ja": "動的テーブルは、先入れ先出し順に維持ヘッダフィールドのリストから成ります。動的テーブルの最初と最新のエントリは、最低のインデックスであり、動的テーブルの最も古いエントリは、最高のインデックスです。"
    },
    {
      "indent": 3,
      "text": "The dynamic table is initially empty. Entries are added as each header block is decompressed.",
      "ja": "動的テーブルは最初は空です。各ヘッダブロックが伸張されるようにエントリが追加されます。"
    },
    {
      "indent": 3,
      "text": "The dynamic table can contain duplicate entries (i.e., entries with the same name and same value). Therefore, duplicate entries MUST NOT be treated as an error by a decoder.",
      "ja": "動的テーブルは、重複エントリ（同じ名前と同じ値を持つ、すなわち、エントリ）を含むことができます。したがって、重複したエントリは、デコーダによってエラーとして扱われてはいけません。"
    },
    {
      "indent": 3,
      "text": "The encoder decides how to update the dynamic table and as such can control how much memory is used by the dynamic table. To limit the memory requirements of the decoder, the dynamic table size is strictly bounded (see Section 4.2).",
      "ja": "エンコーダは、動的テーブルを更新するために、そのように動的テーブルで使用されるどのくらいのメモリを制御する方法を決定します。デコーダのメモリ要件を制限するために、動的テーブルのサイズは厳密に（セクション4.2を参照）制限されます。"
    },
    {
      "indent": 3,
      "text": "The decoder updates the dynamic table during the processing of a list of header field representations (see Section 3.2).",
      "ja": "デコーダは、ヘッダフィールドの表現のリストの処理中に動的テーブルを更新する（セクション3.2を参照）。"
    },
    {
      "indent": 0,
      "text": "2.3.3. Index Address Space",
      "section_title": true,
      "ja": "2.3.3. インデックスアドレス空間"
    },
    {
      "indent": 3,
      "text": "The static table and the dynamic table are combined into a single index address space.",
      "ja": "静的テーブルおよび動的テーブルは、単一の索引アドレス空間に結合されます。"
    },
    {
      "indent": 3,
      "text": "Indices between 1 and the length of the static table (inclusive) refer to elements in the static table (see Section 2.3.1).",
      "ja": "1及び静的テーブルの長さとの間の指数は（包括的）静的テーブル内の要素を参照する（セクション2.3.1を参照）。"
    },
    {
      "indent": 3,
      "text": "Indices strictly greater than the length of the static table refer to elements in the dynamic table (see Section 2.3.2). The length of the static table is subtracted to find the index into the dynamic table.",
      "ja": "静的テーブルの長さよりも厳密に大きいインデックス（セクション2.3.2を参照）動的テーブル内の要素を指します。静的テーブルの長さは、動的テーブルへのインデックスを見つけるために減算されます。"
    },
    {
      "indent": 3,
      "text": "Indices strictly greater than the sum of the lengths of both tables MUST be treated as a decoding error.",
      "ja": "両方のテーブルの長さの合計よりも厳密に大きいインデックスは、復号エラーとして扱わなければなりません。"
    },
    {
      "indent": 3,
      "text": "For a static table size of s and a dynamic table size of k, the following diagram shows the entire valid index address space.",
      "ja": "複数の静的テーブルサイズとkの動的テーブルサイズは、次の図は、全体の有効なインデックスのアドレス空間を示しています。"
    },
    {
      "indent": 11,
      "text": "<----------  Index Address Space ---------->\n<-- Static  Table -->  <-- Dynamic Table -->\n+---+-----------+---+  +---+-----------+---+\n| 1 |    ...    | s |  |s+1|    ...    |s+k|\n+---+-----------+---+  +---+-----------+---+\n                       ^                   |\n                       |                   V\n                Insertion Point      Dropping Point",
      "raw": true
    },
    {
      "indent": 23,
      "text": "Figure 1: Index Address Space",
      "ja": "図1：インデックスアドレス空間"
    },
    {
      "indent": 0,
      "text": "2.4. Header Field Representation",
      "section_title": true,
      "ja": "2.4. ヘッダーフィールド表現"
    },
    {
      "indent": 3,
      "text": "An encoded header field can be represented either as an index or as a literal.",
      "ja": "エンコードされたヘッダフィールドは、インデックスとして、またはリテラルのいずれかとして表すことができます。"
    },
    {
      "indent": 3,
      "text": "An indexed representation defines a header field as a reference to an entry in either the static table or the dynamic table (see Section 6.1).",
      "ja": "索引付けされた表現が静的テーブルまたは動的テーブルのいずれかのエントリを参照するようにヘッダーフィールドを定義する（セクション6.1を参照）。"
    },
    {
      "indent": 3,
      "text": "A literal representation defines a header field by specifying its name and value. The header field name can be represented literally or as a reference to an entry in either the static table or the dynamic table. The header field value is represented literally.",
      "ja": "リテラル表現は、その名前と値を指定してヘッダーフィールドを定義します。ヘッダフィールド名は、文字通りまたは静的テーブルまたは動的テーブルのいずれかのエントリを参照として表すことができます。ヘッダフィールド値を文字通り表されます。"
    },
    {
      "indent": 3,
      "text": "Three different literal representations are defined:",
      "ja": "三つの異なるリテラル表現が定義されています。"
    },
    {
      "indent": 3,
      "text": "o A literal representation that adds the header field as a new entry at the beginning of the dynamic table (see Section 6.2.1).",
      "ja": "動的テーブルの先頭に新たなエントリとしてヘッダフィールドを付加するリテラル表現O（セクション6.2.1を参照）。"
    },
    {
      "indent": 3,
      "text": "o A literal representation that does not add the header field to the dynamic table (see Section 6.2.2).",
      "ja": "ダイナミックテーブルにヘッダーフィールドを追加しないリテラル表現O（セクション6.2.2を参照）。"
    },
    {
      "indent": 3,
      "text": "o A literal representation that does not add the header field to the dynamic table, with the additional stipulation that this header field always use a literal representation, in particular when re-encoded by an intermediary (see Section 6.2.3). This representation is intended for protecting header field values that are not to be put at risk by compressing them (see Section 7.1.3 for more details).",
      "ja": "O仲介によって再符号化されたときに、このヘッダフィールドは常に、特に、リテラル表現を使用することの追加の規定と、動的テーブルにヘッダーフィールドを追加しないリテラル表現（セクション6.2.3を参照します）。この表現は、それらを圧縮することによって危険にさらされるべきではなく、ヘッダーフィールド値を保護するためのものである（詳細は7.1.3項を参照してください）。"
    },
    {
      "indent": 3,
      "text": "The selection of one of these literal representations can be guided by security considerations, in order to protect sensitive header field values (see Section 7.1).",
      "ja": "これらのリテラルの表現の1つの選択を敏感ヘッダフィールド値を保護するために、セキュリティを考慮して案内することができる（7.1節を参照）。"
    },
    {
      "indent": 3,
      "text": "The literal representation of a header field name or of a header field value can encode the sequence of octets either directly or using a static Huffman code (see Section 5.2).",
      "ja": "ヘッダーフィールド名またはヘッダフィールド値のリテラル表現は直接または静的ハフマン符号を使用して、オクテットの配列をコードすることができる（5.2節を参照）。"
    },
    {
      "indent": 0,
      "text": "3. Header Block Decoding",
      "section_title": true,
      "ja": "3.ヘッダーブロックのデコード"
    },
    {
      "indent": 0,
      "text": "3.1. Header Block Processing",
      "section_title": true,
      "ja": "3.1. ヘッダブロック処理"
    },
    {
      "indent": 3,
      "text": "A decoder processes a header block sequentially to reconstruct the original header list.",
      "ja": "デコーダは、元のヘッダのリストを再構成するためにヘッダブロックを順次処理します。"
    },
    {
      "indent": 3,
      "text": "A header block is the concatenation of header field representations. The different possible header field representations are described in Section 6.",
      "ja": "ヘッダブロックは、ヘッダフィールドの表現の連結です。異なる可能なヘッダフィールド表現はセクション6に記載されています。"
    },
    {
      "indent": 3,
      "text": "Once a header field is decoded and added to the reconstructed header list, the header field cannot be removed. A header field added to the header list can be safely passed to the application.",
      "ja": "ヘッダフィールドが復号され、再構成されたヘッダリストに追加されると、ヘッダ・フィールドを削除することはできません。ヘッダリストに追加ヘッダフィールドは安全にアプリケーションに渡すことができます。"
    },
    {
      "indent": 3,
      "text": "By passing the resulting header fields to the application, a decoder can be implemented with minimal transitory memory commitment in addition to the memory required for the dynamic table.",
      "ja": "アプリケーションに得られたヘッダフィールドを通過させることによって、デコーダは、ダイナミックテーブルに必要なメモリに加えて、最小限の一時記憶コミットメントで実現することができます。"
    },
    {
      "indent": 0,
      "text": "3.2. Header Field Representation Processing",
      "section_title": true,
      "ja": "3.2. ヘッダーフィールドの表現処理"
    },
    {
      "indent": 3,
      "text": "The processing of a header block to obtain a header list is defined in this section. To ensure that the decoding will successfully produce a header list, a decoder MUST obey the following rules.",
      "ja": "ヘッダのリストを取得するために、ヘッダブロックの処理は、このセクションで定義されています。復号が成功ヘッダリストを生成することを保証するために、デコーダは、次の規則に従わなければなりません。"
    },
    {
      "indent": 3,
      "text": "All the header field representations contained in a header block are processed in the order in which they appear, as specified below. Details on the formatting of the various header field representations and some additional processing instructions are found in Section 6.",
      "ja": "以下に指定されるように、ヘッダブロックに含まれる全てのヘッダフィールドの表現は、それらが現れる順序で処理されます。様々なヘッダフィールド表示といくつかの追加の処理命令のフォーマットの詳細はセクション6に見出されます。"
    },
    {
      "indent": 3,
      "text": "An _indexed representation_ entails the following actions:",
      "ja": "_indexed representation_は次のアクションを伴います："
    },
    {
      "indent": 3,
      "text": "o The header field corresponding to the referenced entry in either the static table or dynamic table is appended to the decoded header list.",
      "ja": "Oスタティックテーブルまたは動的テーブルのいずれかで参照されるエントリに対応するヘッダフィールドは、デコードされたヘッダリストに追加されます。"
    },
    {
      "indent": 3,
      "text": "A _literal representation_ that is _not added_ to the dynamic table entails the following action:",
      "ja": "動的テーブルに_not added_ある_literal representation_には、次のアクションを伴います："
    },
    {
      "indent": 3,
      "text": "o The header field is appended to the decoded header list.",
      "ja": "Oヘッダフィールドは、デコードされたヘッダリストに追加されます。"
    },
    {
      "indent": 3,
      "text": "A _literal representation_ that is _added_ to the dynamic table entails the following actions:",
      "ja": "動的テーブルに_added_ある_literal representation_は、次のアクションを伴います："
    },
    {
      "indent": 3,
      "text": "o The header field is appended to the decoded header list.",
      "ja": "Oヘッダフィールドは、デコードされたヘッダリストに追加されます。"
    },
    {
      "indent": 3,
      "text": "o The header field is inserted at the beginning of the dynamic table. This insertion could result in the eviction of previous entries in the dynamic table (see Section 4.4).",
      "ja": "Oヘッダフィールドは、動的テーブルの先頭に挿入されます。この挿入は（セクション4.4を参照）は、動的テーブル内の以前のエントリの立ち退きをもたらし得ます。"
    },
    {
      "indent": 0,
      "text": "4. Dynamic Table Management",
      "section_title": true,
      "ja": "4.動的テーブルの管理"
    },
    {
      "indent": 3,
      "text": "To limit the memory requirements on the decoder side, the dynamic table is constrained in size.",
      "ja": "デコーダ側のメモリ要件を制限するために、動的テーブルのサイズが制約されます。"
    },
    {
      "indent": 0,
      "text": "4.1. Calculating Table Size",
      "section_title": true,
      "ja": "4.1. 計算テーブルサイズ"
    },
    {
      "indent": 3,
      "text": "The size of the dynamic table is the sum of the size of its entries.",
      "ja": "動的テーブルのサイズは、そのエントリのサイズの合計です。"
    },
    {
      "indent": 3,
      "text": "The size of an entry is the sum of its name's length in octets (as defined in Section 5.2), its value's length in octets, and 32.",
      "ja": "エントリのサイズ（セクション5.2で定義されるように）オクテットでその名前の長さの和は、その値のオクテットの長さ、および32です。"
    },
    {
      "indent": 3,
      "text": "The size of an entry is calculated using the length of its name and value without any Huffman encoding applied.",
      "ja": "エントリの大きさは、適用されたハフマン符号化することなく、その名前と値の長さを用いて計算されます。"
    },
    {
      "indent": 6,
      "text": "Note: The additional 32 octets account for an estimated overhead associated with an entry. For example, an entry structure using two 64-bit pointers to reference the name and the value of the entry and two 64-bit integers for counting the number of references to the name and value would have 32 octets of overhead.",
      "ja": "注：追加の32個のオクテットは、エントリに関連付けられた推定オーバーヘッドを占めています。例えば、名前エントリと名前と値への参照の数をカウントするための2つの64ビット整数の値を参照するために2つの64ビット・ポインタを使用して、エントリの構造は、オーバーヘッドの32個のオクテットを有するであろう。"
    },
    {
      "indent": 0,
      "text": "4.2. Maximum Table Size",
      "section_title": true,
      "ja": "4.2. 最大テーブルサイズ"
    },
    {
      "indent": 3,
      "text": "Protocols that use HPACK determine the maximum size that the encoder is permitted to use for the dynamic table. In HTTP/2, this value is determined by the SETTINGS_HEADER_TABLE_SIZE setting (see Section 6.5.2 of [HTTP2]).",
      "ja": "HPACKを使用するプロトコルは、エンコーダは、動的テーブルの利用を許可された最大サイズを決定します。 HTTP / 2では、この値はSETTINGS_HEADER_TABLE_SIZE設定（[HTTP2]のセクション6.5.2を参照）によって決定されます。"
    },
    {
      "indent": 3,
      "text": "An encoder can choose to use less capacity than this maximum size (see Section 6.3), but the chosen size MUST stay lower than or equal to the maximum set by the protocol.",
      "ja": "エンコーダは、（セクション6.3を参照）、この最大サイズよりも小さい容量を使用することを選択できるが、選択されたサイズは、より低いまたはプロトコルによって設定された最大値に等しいままでなければなりません。"
    },
    {
      "indent": 3,
      "text": "A change in the maximum size of the dynamic table is signaled via a dynamic table size update (see Section 6.3). This dynamic table size update MUST occur at the beginning of the first header block following the change to the dynamic table size. In HTTP/2, this follows a settings acknowledgment (see Section 6.5.3 of [HTTP2]).",
      "ja": "動的テーブルの最大サイズの変化は、動的テーブルサイズの更新を介してシグナリングされる（セクション6.3参照）。この動的テーブルサイズの更新は、動的テーブルのサイズに変更後の最初のヘッダブロックの開始時に発生しなければなりません。 HTTP / 2では、これは（[HTTP2]のセクション6.5.3を参照）の設定確認に従います。"
    },
    {
      "indent": 3,
      "text": "Multiple updates to the maximum table size can occur between the transmission of two header blocks. In the case that this size is changed more than once in this interval, the smallest maximum table size that occurs in that interval MUST be signaled in a dynamic table size update. The final maximum size is always signaled, resulting in at most two dynamic table size updates. This ensures that the decoder is able to perform eviction based on reductions in dynamic table size (see Section 4.3).",
      "ja": "最大テーブルサイズの複数の更新は、二つのヘッダブロックの送信の間に起こり得ます。このサイズは、この間隔で複数回変更された場合には、その間隔で発生する最小の最大テーブルサイズは、動的テーブルサイズの更新にシグナリングされなければなりません。最終的な最大サイズは常に最大で2回の動的テーブルサイズの更新をもたらす、シグナリングされます。これは、デコーダが、ダイナミックテーブルサイズの減少に基づいて、立ち退きを行うことができることを確実にする（セクション4.3を参照）。"
    },
    {
      "indent": 3,
      "text": "This mechanism can be used to completely clear entries from the dynamic table by setting a maximum size of 0, which can subsequently be restored.",
      "ja": "この機構は、その後復元することができる0の最大サイズを設定することにより、ダイナミックテーブルから完全に明確なエントリを使用することができます。"
    },
    {
      "indent": 0,
      "text": "4.3. Entry Eviction When Dynamic Table Size Changes",
      "section_title": true,
      "ja": "4.3. エントリ追い出したときの動的テーブルサイズの変更"
    },
    {
      "indent": 3,
      "text": "Whenever the maximum size for the dynamic table is reduced, entries are evicted from the end of the dynamic table until the size of the dynamic table is less than or equal to the maximum size.",
      "ja": "動的テーブルの最大サイズが小さくなるたびに動的テーブルのサイズが最大サイズ以下になるまで、エントリが動的テーブルの端部から追い出されます。"
    },
    {
      "indent": 0,
      "text": "4.4. Entry Eviction When Adding New Entries",
      "section_title": true,
      "ja": "4.4. エントリ立ち退き新規エントリを追加するとき"
    },
    {
      "indent": 3,
      "text": "Before a new entry is added to the dynamic table, entries are evicted from the end of the dynamic table until the size of the dynamic table is less than or equal to (maximum size - new entry size) or until the table is empty.",
      "ja": "またはテーブルが空になるまで - 新しいエントリが動的テーブルに追加される前に、動的テーブルのサイズがより小さいか（新規エントリのサイズ最大サイズ）に等しくなるまで、エントリが動的テーブルの端部から追い出されます。"
    },
    {
      "indent": 3,
      "text": "If the size of the new entry is less than or equal to the maximum size, that entry is added to the table. It is not an error to attempt to add an entry that is larger than the maximum size; an attempt to add an entry larger than the maximum size causes the table to be emptied of all existing entries and results in an empty table.",
      "ja": "新規エントリのサイズがより小さいか最大サイズに等しい場合、そのエントリがテーブルに追加されます。最大サイズよりも大きいエントリを追加しようとすると、エラーではありません。最大サイズよりも大きいエントリを追加しようとすると、テーブルが空のテーブル内のすべての既存のエントリ及び結果が空にさせます。"
    },
    {
      "indent": 3,
      "text": "A new entry can reference the name of an entry in the dynamic table that will be evicted when adding this new entry into the dynamic table. Implementations are cautioned to avoid deleting the referenced name if the referenced entry is evicted from the dynamic table prior to inserting the new entry.",
      "ja": "新しいエントリは、動的テーブルに新しいエントリを追加するときに追い出さする動的テーブル内のエントリの名前を参照することができます。実装は、参照エントリが前新しいエントリを挿入する動的テーブルから削除された場合に、参照名を削除避けるために警告されます。"
    },
    {
      "indent": 0,
      "text": "5. Primitive Type Representations",
      "section_title": true,
      "ja": "5.プリミティブ型表現"
    },
    {
      "indent": 3,
      "text": "HPACK encoding uses two primitive types: unsigned variable-length integers and strings of octets.",
      "ja": "符号なしの可変長整数とオクテット文字列：HPACKエンコーディングは、2つの基本タイプを使用しています。"
    },
    {
      "indent": 0,
      "text": "5.1. Integer Representation",
      "section_title": true,
      "ja": "5.1. 整数表現"
    },
    {
      "indent": 3,
      "text": "Integers are used to represent name indexes, header field indexes, or string lengths. An integer representation can start anywhere within an octet. To allow for optimized processing, an integer representation always finishes at the end of an octet.",
      "ja": "整数は、名前インデックス、ヘッダーフィールドのインデックス、または文字列の長さを表すために使用されます。整数表現は、オクテット内のどこにでも始めることができます。最適化された処理を可能にするために、整数の表現は常にオクテットの終了時に終了します。"
    },
    {
      "indent": 3,
      "text": "An integer is represented in two parts: a prefix that fills the current octet and an optional list of octets that are used if the integer value does not fit within the prefix. The number of bits of the prefix (called N) is a parameter of the integer representation.",
      "ja": "現在のオクテット整数値が接頭辞に収まらない場合に使用されているオクテットのオプションのリストを埋め接頭辞：整数は2つの部分で表されます。 （Nと呼ばれる）の接頭辞のビット数は、整数表現のパラメータです。"
    },
    {
      "indent": 3,
      "text": "If the integer value is small enough, i.e., strictly less than 2^N-1, it is encoded within the N-bit prefix.",
      "ja": "整数値は2 ^ N-1よりも厳密に小さい、すなわち、十分に小さい場合は、Nビットのプレフィックス内に符号化されます。"
    },
    {
      "indent": 3,
      "text": "  0   1   2   3   4   5   6   7\n+---+---+---+---+---+---+---+---+\n| ? | ? | ? |       Value       |\n+---+---+---+-------------------+",
      "raw": true
    },
    {
      "indent": 4,
      "text": "Figure 2: Integer Value Encoded within the Prefix (Shown for N = 5)",
      "ja": "図2：プレフィックス（N = 5について示さ）内にコード整数値"
    },
    {
      "indent": 3,
      "text": "Otherwise, all the bits of the prefix are set to 1, and the value, decreased by 2^N-1, is encoded using a list of one or more octets. The most significant bit of each octet is used as a continuation flag: its value is set to 1 except for the last octet in the list. The remaining bits of the octets are used to encode the decreased value.",
      "ja": "そうでない場合、接頭辞のすべてのビットが1に設定され、2 ^ N-1だけ減少値は、1つの以上のオクテットのリストを使用して符号化されます。各オクテットの最上位ビットは継続フラグとして使用される。その値は、リスト内の最後のオクテットを除いて1に設定されています。オクテットの残りのビットは減少値を符号化するために使用されます。"
    },
    {
      "indent": 3,
      "text": "  0   1   2   3   4   5   6   7\n+---+---+---+---+---+---+---+---+\n| ? | ? | ? | 1   1   1   1   1 |\n+---+---+---+-------------------+\n| 1 |    Value-(2^N-1) LSB      |\n+---+---------------------------+\n               ...\n+---+---------------------------+\n| 0 |    Value-(2^N-1) MSB      |\n+---+---------------------------+",
      "raw": true
    },
    {
      "indent": 4,
      "text": "Figure 3: Integer Value Encoded after the Prefix (Shown for N = 5)",
      "ja": "図3：プレフィックス後整数値符号化された（N = 5について示さ）"
    },
    {
      "indent": 3,
      "text": "Decoding the integer value from the list of octets starts by reversing the order of the octets in the list. Then, for each octet, its most significant bit is removed. The remaining bits of the octets are concatenated, and the resulting value is increased by 2^N-1 to obtain the integer value.",
      "ja": "オクテットのリストから整数値をデコードすると、リスト内のオクテットの順序を逆にすることによって開始します。その後、各オクテットのために、その最上位ビットが削除されます。オクテットの残りのビットは連結され、そして得られた値は、整数値を取得するために2 ^ N-1だけ増加されます。"
    },
    {
      "indent": 3,
      "text": "The prefix size, N, is always between 1 and 8 bits. An integer starting at an octet boundary will have an 8-bit prefix.",
      "ja": "プレフィックスサイズ、Nは、1と8ビットの間に常にあります。オクテット境界で始まる整数は8ビットのプレフィックスを持つことになります。"
    },
    {
      "indent": 3,
      "text": "Pseudocode to represent an integer I is as follows:",
      "ja": "擬似コードは以下のようにIは整数を表現します。"
    },
    {
      "indent": 3,
      "text": "if I < 2^N - 1, encode I on N bits else encode (2^N - 1) on N bits I = I - (2^N - 1) while I >= 128 encode (I % 128 + 128) on 8 bits I = I / 128 encode I on 8 bits",
      "ja": "私は場合は、<2 ^ N  -  1、エンコードI他Nビット（2 ^ N  -  1）符号化にNビットにI = I  - （2 ^ N  -  1）一方、I> = 128エンコード（I％128 + 128） 8ビットに8ビットでI = I / 128 Iをエンコード"
    },
    {
      "indent": 3,
      "text": "Pseudocode to decode an integer I is as follows:",
      "ja": "次のように私はある整数を復号するための擬似コード："
    },
    {
      "indent": 3,
      "text": "decode I from the next N bits if I < 2^N - 1, return I else M = 0 repeat B = next octet I = I + (B & 127) * 2^M M = M + 7 while B & 128 == 128 return I",
      "ja": "1他I M = 0繰り返しB =次のオクテットI = Iが+（B＆127）* 2 ^ MM = M + 7ながらB＆128 ==戻り、 - 私は^ N 2 <場合、次のNビットからIをデコード128リターンI"
    },
    {
      "indent": 3,
      "text": "Examples illustrating the encoding of integers are available in Appendix C.1.",
      "ja": "整数のエンコーディングを示す例は、付録C.1でご利用いただけます。"
    },
    {
      "indent": 3,
      "text": "This integer representation allows for values of indefinite size. It is also possible for an encoder to send a large number of zero values, which can waste octets and could be used to overflow integer values. Integer encodings that exceed implementation limits -- in value or octet length -- MUST be treated as decoding errors. Different limits can be set for each of the different uses of integers, based on implementation constraints.",
      "ja": "この整数表現は、不定サイズの値を可能にします。エンコーダはオクテットを無駄にすることができ、整数値をオーバーフローするために使用することができるゼロ値の多数を送信することも可能です。値またはオクテットの長さ -   - 実装の限界を超える整数符号化は、復号エラーとして扱わなければなりません。別の制限は、実装上の制約に基づいて、整数の異なる用途ごとに設定することができます。"
    },
    {
      "indent": 0,
      "text": "5.2. String Literal Representation",
      "section_title": true,
      "ja": "5.2. 文字列リテラル表現"
    },
    {
      "indent": 3,
      "text": "Header field names and header field values can be represented as string literals. A string literal is encoded as a sequence of octets, either by directly encoding the string literal's octets or by using a Huffman code (see [HUFFMAN]).",
      "ja": "ヘッダフィールド名とヘッダフィールド値は、文字列リテラルとして表すことができます。リテラル文字列は、直接の文字列リテラルのオクテットを符号化またはハフマン符号を使用してのいずれかで、オクテットのシーケンスとして符号化される（[ハフマン]参照）。"
    },
    {
      "indent": 3,
      "text": "  0   1   2   3   4   5   6   7\n+---+---+---+---+---+---+---+---+\n| H |    String Length (7+)     |\n+---+---------------------------+\n|  String Data (Length octets)  |\n+-------------------------------+",
      "raw": true
    },
    {
      "indent": 18,
      "text": "Figure 4: String Literal Representation",
      "ja": "図4：文字列リテラル表現"
    },
    {
      "indent": 3,
      "text": "A string literal representation contains the following fields:",
      "ja": "文字列リテラルの表現は、以下のフィールドが含まれています。"
    },
    {
      "indent": 3,
      "text": "H: A one-bit flag, H, indicating whether or not the octets of the string are Huffman encoded.",
      "ja": "H：1ビットのフラグ、H、文字列のオクテットがハフマン符号化されているか否かを示します。"
    },
    {
      "indent": 3,
      "text": "String Length: The number of octets used to encode the string literal, encoded as an integer with a 7-bit prefix (see Section 5.1).",
      "ja": "文字列の長さ：7ビットのプレフィックスを持つ整数としてエンコードリテラル文字列を符号化するために使用されるオクテットの数（5.1節を参照）。"
    },
    {
      "indent": 3,
      "text": "String Data: The encoded data of the string literal. If H is '0', then the encoded data is the raw octets of the string literal. If H is '1', then the encoded data is the Huffman encoding of the string literal.",
      "ja": "文字列データ：文字列リテラルのエンコードされたデータ。 Hが「0」の場合、符号化されたデータは、文字列リテラルの生のオクテットです。 Hは「1」である場合、符号化データは、リテラル文字列のハフマン符号化です。"
    },
    {
      "indent": 3,
      "text": "String literals that use Huffman encoding are encoded with the Huffman code defined in Appendix B (see examples for requests in Appendix C.4 and for responses in Appendix C.6). The encoded data is the bitwise concatenation of the codes corresponding to each octet of the string literal.",
      "ja": "ハフマン符号化を使用して文字列リテラルは、付録Bで定義されたハフマン符号で符号化されている（付録C.4における要求の付録C.6に応答するための例を参照）。符号化データは、リテラル文字列の各オクテットに対応するコードのビット単位の連結です。"
    },
    {
      "indent": 3,
      "text": "As the Huffman-encoded data doesn't always end at an octet boundary, some padding is inserted after it, up to the next octet boundary. To prevent this padding from being misinterpreted as part of the string literal, the most significant bits of the code corresponding to the EOS (end-of-string) symbol are used.",
      "ja": "ハフマン符号化されたデータは、常にオクテット境界で終わらないように、一部のパディングが次のオクテット境界まで、それの後に挿入されています。文字列の一部リテラルとして誤って解釈されるから、このパディングを防止するために、EOS（エンド・オブ・ストリング）シンボルに対応するコードの最上位ビットが使用されます。"
    },
    {
      "indent": 3,
      "text": "Upon decoding, an incomplete code at the end of the encoded data is to be considered as padding and discarded. A padding strictly longer than 7 bits MUST be treated as a decoding error. A padding not corresponding to the most significant bits of the code for the EOS symbol MUST be treated as a decoding error. A Huffman-encoded string literal containing the EOS symbol MUST be treated as a decoding error.",
      "ja": "復号化時に、符号化されたデータの終わりに不完全なコードがパディングとみなされ、廃棄されるべきです。パディングは、厳密に長い7ビットより復号エラーとして扱わなければなりません。 EOSシンボルのためのコードの最上位ビットに対応していないパディングは、復号エラーとして扱わなければなりません。 EOSシンボルを含むハフマン符号化された文字列リテラルは、復号エラーとして扱わなければなりません。"
    },
    {
      "indent": 0,
      "text": "6. Binary Format",
      "section_title": true,
      "ja": "6.バイナリフォーマット"
    },
    {
      "indent": 3,
      "text": "This section describes the detailed format of each of the different header field representations and the dynamic table size update instruction.",
      "ja": "このセクションでは、異なるヘッダフィールド表現と動的テーブルのサイズ更新命令のそれぞれの詳細なフォーマットを記述する。"
    },
    {
      "indent": 0,
      "text": "6.1. Indexed Header Field Representation",
      "section_title": true,
      "ja": "6.1. インデックス付きヘッダーフィールド表現"
    },
    {
      "indent": 3,
      "text": "An indexed header field representation identifies an entry in either the static table or the dynamic table (see Section 2.3).",
      "ja": "索引付けヘッダフィールドの表現は、静的テーブルまたは動的テーブル（セクション2.3を参照）のいずれかのエントリを識別する。"
    },
    {
      "indent": 3,
      "text": "An indexed header field representation causes a header field to be added to the decoded header list, as described in Section 3.2.",
      "ja": "索引付けヘッダフィールドの表現は、3.2節で説明したように、デコードされたヘッダリストに追加するヘッダフィールドを引き起こします。"
    },
    {
      "indent": 3,
      "text": "  0   1   2   3   4   5   6   7\n+---+---+---+---+---+---+---+---+\n| 1 |        Index (7+)         |\n+---+---------------------------+",
      "raw": true
    },
    {
      "indent": 22,
      "text": "Figure 5: Indexed Header Field",
      "ja": "図5：インデックスヘッダーフィールド"
    },
    {
      "indent": 3,
      "text": "An indexed header field starts with the '1' 1-bit pattern, followed by the index of the matching header field, represented as an integer with a 7-bit prefix (see Section 5.1).",
      "ja": "索引付けヘッダフィールドは7ビットのプレフィックスを持つ整数として表現マッチングヘッダフィールドのインデックスに続く「1」の1ビットのパターン、（セクション5.1を参照）で始まります。"
    },
    {
      "indent": 3,
      "text": "The index value of 0 is not used. It MUST be treated as a decoding error if found in an indexed header field representation.",
      "ja": "0のインデックス値は使用されません。索引付けされたヘッダフィールド表現で見つかった場合には、復号エラーとして扱わなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.2. Literal Header Field Representation",
      "section_title": true,
      "ja": "6.2. リテラルヘッダーフィールド表現"
    },
    {
      "indent": 3,
      "text": "A literal header field representation contains a literal header field value. Header field names are provided either as a literal or by reference to an existing table entry, either from the static table or the dynamic table (see Section 2.3).",
      "ja": "リテラルヘッダフィールド表現は、リテラルヘッダフィールド値を含みます。ヘッダフィールド名がリテラルとして、または既存のテーブルエントリを参照することにより、静的テーブルまたは動的テーブルのいずれかから提供される（セクション2.3参照）。"
    },
    {
      "indent": 3,
      "text": "This specification defines three forms of literal header field representations: with indexing, without indexing, and never indexed.",
      "ja": "索引付けすることなく、索引付けと、そしてインデックス付け決して：この仕様は、リテラルヘッダフィールド表現の三の形態を定義します。"
    },
    {
      "indent": 0,
      "text": "6.2.1. Literal Header Field with Incremental Indexing",
      "section_title": true,
      "ja": "6.2.1. インクリメンタルインデックス付きリテラルヘッダーフィールド"
    },
    {
      "indent": 3,
      "text": "A literal header field with incremental indexing representation results in appending a header field to the decoded header list and inserting it as a new entry into the dynamic table.",
      "ja": "デコードされたヘッダリストにヘッダーフィールドを追加し、動的テーブルに新規エントリとして挿入における増分インデクシング表現結果とリテラルヘッダフィールド。"
    },
    {
      "indent": 3,
      "text": "  0   1   2   3   4   5   6   7\n+---+---+---+---+---+---+---+---+\n| 0 | 1 |      Index (6+)       |\n+---+---+-----------------------+\n| H |     Value Length (7+)     |\n+---+---------------------------+\n| Value String (Length octets)  |\n+-------------------------------+",
      "raw": true
    },
    {
      "indent": 4,
      "text": "Figure 6: Literal Header Field with Incremental Indexing -- Indexed Name",
      "ja": "図6：インクリメンタルインデックス付きリテラルヘッダーフィールド - 索引名"
    },
    {
      "indent": 3,
      "text": "  0   1   2   3   4   5   6   7\n+---+---+---+---+---+---+---+---+\n| 0 | 1 |           0           |\n+---+---+-----------------------+\n| H |     Name Length (7+)      |\n+---+---------------------------+\n|  Name String (Length octets)  |\n+---+---------------------------+\n| H |     Value Length (7+)     |\n+---+---------------------------+\n| Value String (Length octets)  |\n+-------------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Figure 7: Literal Header Field with Incremental Indexing -- New Name",
      "ja": "図7：インクリメンタルインデックス付きリテラルヘッダーフィールド - 新名"
    },
    {
      "indent": 3,
      "text": "A literal header field with incremental indexing representation starts with the '01' 2-bit pattern.",
      "ja": "増分インデクシング表現リテラルヘッダフィールドが「01」2ビットのパターンで始まります。"
    },
    {
      "indent": 3,
      "text": "If the header field name matches the header field name of an entry stored in the static table or the dynamic table, the header field name can be represented using the index of that entry. In this case, the index of the entry is represented as an integer with a 6-bit prefix (see Section 5.1). This value is always non-zero.",
      "ja": "ヘッダフィールド名が静的テーブルに格納されたエントリまたは動的テーブルのヘッダフィールド名と一致する場合、ヘッダフィールド名は、そのエントリのインデックスを使用して表すことができます。この場合には、エントリのインデックスが6ビットのプレフィックスを持つ整数として表現される（セクション5.1参照）。この値は常にゼロです。"
    },
    {
      "indent": 3,
      "text": "Otherwise, the header field name is represented as a string literal (see Section 5.2). A value 0 is used in place of the 6-bit index, followed by the header field name.",
      "ja": "そうでなければ、ヘッダフィールド名は、文字列リテラル（セクション5.2を参照）として表されます。値0は、ヘッダフィールド名が続き、6ビットのインデックスの代わりに使用されます。"
    },
    {
      "indent": 3,
      "text": "Either form of header field name representation is followed by the header field value represented as a string literal (see Section 5.2).",
      "ja": "ヘッダフィールド名の表現のいずれかの形態をリテラル文字列として表さヘッダフィールド値が続いている（セクション5.2を参照）。"
    },
    {
      "indent": 0,
      "text": "6.2.2. Literal Header Field without Indexing",
      "section_title": true,
      "ja": "6.2.2. リテラルヘッダーフィールドインデックスなし"
    },
    {
      "indent": 3,
      "text": "A literal header field without indexing representation results in appending a header field to the decoded header list without altering the dynamic table.",
      "ja": "動的テーブルを変更せずにデコードされたヘッダリストにヘッダーフィールドを追加で表現結果にインデックスを付けることなく、リテラルヘッダフィールド。"
    },
    {
      "indent": 3,
      "text": "  0   1   2   3   4   5   6   7\n+---+---+---+---+---+---+---+---+\n| 0 | 0 | 0 | 0 |  Index (4+)   |\n+---+---+-----------------------+\n| H |     Value Length (7+)     |\n+---+---------------------------+\n| Value String (Length octets)  |\n+-------------------------------+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Figure 8: Literal Header Field without Indexing -- Indexed Name",
      "ja": "図8：リテラルヘッダーフィールドインデックスなし - インデックス付きの名前"
    },
    {
      "indent": 3,
      "text": "  0   1   2   3   4   5   6   7\n+---+---+---+---+---+---+---+---+\n| 0 | 0 | 0 | 0 |       0       |\n+---+---+-----------------------+\n| H |     Name Length (7+)      |\n+---+---------------------------+\n|  Name String (Length octets)  |\n+---+---------------------------+\n| H |     Value Length (7+)     |\n+---+---------------------------+\n| Value String (Length octets)  |\n+-------------------------------+",
      "raw": true
    },
    {
      "indent": 8,
      "text": "Figure 9: Literal Header Field without Indexing -- New Name",
      "ja": "図9：リテラルヘッダーフィールドインデックスなし - 新しい名前"
    },
    {
      "indent": 3,
      "text": "A literal header field without indexing representation starts with the '0000' 4-bit pattern.",
      "ja": "インデクシング表現無しリテラルヘッダフィールドは、「0000」4ビットのパターンで始まります。"
    },
    {
      "indent": 3,
      "text": "If the header field name matches the header field name of an entry stored in the static table or the dynamic table, the header field name can be represented using the index of that entry. In this case, the index of the entry is represented as an integer with a 4-bit prefix (see Section 5.1). This value is always non-zero.",
      "ja": "ヘッダフィールド名が静的テーブルに格納されたエントリまたは動的テーブルのヘッダフィールド名と一致する場合、ヘッダフィールド名は、そのエントリのインデックスを使用して表すことができます。この場合には、エントリのインデックスが4ビットのプレフィックスを持つ整数として表現される（セクション5.1参照）。この値は常にゼロです。"
    },
    {
      "indent": 3,
      "text": "Otherwise, the header field name is represented as a string literal (see Section 5.2). A value 0 is used in place of the 4-bit index, followed by the header field name.",
      "ja": "そうでなければ、ヘッダフィールド名は、文字列リテラル（セクション5.2を参照）として表されます。値0は、ヘッダフィールド名が続き、4ビットのインデックスの代わりに使用されます。"
    },
    {
      "indent": 3,
      "text": "Either form of header field name representation is followed by the header field value represented as a string literal (see Section 5.2).",
      "ja": "ヘッダフィールド名の表現のいずれかの形態をリテラル文字列として表さヘッダフィールド値が続いている（セクション5.2を参照）。"
    },
    {
      "indent": 0,
      "text": "6.2.3. Literal Header Field Never Indexed",
      "section_title": true,
      "ja": "6.2.3. リテラルヘッダーフィールドネヴァー・インデックス"
    },
    {
      "indent": 3,
      "text": "A literal header field never-indexed representation results in appending a header field to the decoded header list without altering the dynamic table. Intermediaries MUST use the same representation for encoding this header field.",
      "ja": "リテラルヘッダフィールド、インデックス付き決して表現が動的テーブルを変更することなく、デコードされたヘッダリストにヘッダフィールドを付加することになります。仲介者は、このヘッダ・フィールドを符号化するための同じ表現を使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "  0   1   2   3   4   5   6   7\n+---+---+---+---+---+---+---+---+\n| 0 | 0 | 0 | 1 |  Index (4+)   |\n+---+---+-----------------------+\n| H |     Value Length (7+)     |\n+---+---------------------------+\n| Value String (Length octets)  |\n+-------------------------------+",
      "raw": true
    },
    {
      "indent": 7,
      "text": "Figure 10: Literal Header Field Never Indexed -- Indexed Name",
      "ja": "図10：リテラルヘッダーフィールド決してインデックス - インデックスの名前"
    },
    {
      "indent": 3,
      "text": "  0   1   2   3   4   5   6   7\n+---+---+---+---+---+---+---+---+\n| 0 | 0 | 0 | 1 |       0       |\n+---+---+-----------------------+\n| H |     Name Length (7+)      |\n+---+---------------------------+\n|  Name String (Length octets)  |\n+---+---------------------------+\n| H |     Value Length (7+)     |\n+---+---------------------------+\n| Value String (Length octets)  |\n+-------------------------------+",
      "raw": true
    },
    {
      "indent": 9,
      "text": "Figure 11: Literal Header Field Never Indexed -- New Name",
      "ja": "図11：リテラルヘッダーフィールド決してインデックス - 新しい名前"
    },
    {
      "indent": 3,
      "text": "A literal header field never-indexed representation starts with the '0001' 4-bit pattern.",
      "ja": "表現インデックスはないリテラルヘッダフィールドは、「0001」4ビットのパターンで始まります。"
    },
    {
      "indent": 3,
      "text": "When a header field is represented as a literal header field never indexed, it MUST always be encoded with this specific literal representation. In particular, when a peer sends a header field that it received represented as a literal header field never indexed, it MUST use the same representation to forward this header field.",
      "ja": "リテラルヘッダーフィールドがインデックスはないように、ヘッダフィールドが表現されるとき、それは常にこの特定のリテラル表現で符号化されなければなりません。具体的には、ピアは、それがインデックスはないリテラルヘッダフィールドとして表現受信したヘッダフィールドが送信するときは、このヘッダフィールドを転送するために、同じ表現を使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "This representation is intended for protecting header field values that are not to be put at risk by compressing them (see Section 7.1 for more details).",
      "ja": "この表現は（詳細は7.1節を参照）、それらを圧縮することによって危険にさらされるべきではなく、ヘッダーフィールド値を保護するためのものです。"
    },
    {
      "indent": 3,
      "text": "The encoding of the representation is identical to the literal header field without indexing (see Section 6.2.2).",
      "ja": "表現の符号化がインデキシング無しリテラルヘッダフィールドと同一である（セクション6.2.2を参照）。"
    },
    {
      "indent": 0,
      "text": "6.3. Dynamic Table Size Update",
      "section_title": true,
      "ja": "6.3. 動的テーブルのサイズを更新"
    },
    {
      "indent": 3,
      "text": "A dynamic table size update signals a change to the size of the dynamic table.",
      "ja": "動的テーブルサイズの更新は、動的テーブルのサイズに変化を知らせます。"
    },
    {
      "indent": 3,
      "text": "  0   1   2   3   4   5   6   7\n+---+---+---+---+---+---+---+---+\n| 0 | 0 | 1 |   Max size (5+)   |\n+---+---------------------------+",
      "raw": true
    },
    {
      "indent": 15,
      "text": "Figure 12: Maximum Dynamic Table Size Change",
      "ja": "図12：最大ダイナミックテーブルサイズの変更"
    },
    {
      "indent": 3,
      "text": "A dynamic table size update starts with the '001' 3-bit pattern, followed by the new maximum size, represented as an integer with a 5-bit prefix (see Section 5.1).",
      "ja": "動的テーブルサイズの更新は、5ビットのプレフィックスを持つ整数として表される新しい最大サイズが続く「001」の3ビットパターン（セクション5.1を参照）で始まります。"
    },
    {
      "indent": 3,
      "text": "The new maximum size MUST be lower than or equal to the limit determined by the protocol using HPACK. A value that exceeds this limit MUST be treated as a decoding error. In HTTP/2, this limit is the last value of the SETTINGS_HEADER_TABLE_SIZE parameter (see Section 6.5.2 of [HTTP2]) received from the decoder and acknowledged by the encoder (see Section 6.5.3 of [HTTP2]).",
      "ja": "新しい最大サイズはHPACKを使用してプロトコルによって決定限界より低いか等しくなければなりません。この制限を超える値は、復号エラーとして扱わなければなりません。 HTTP / 2では、この制限はSETTINGS_HEADER_TABLE_SIZEパラメータの最後の値である（[HTTP2]のセクション6.5.2を参照）（[HTTP2]のセクション6.5.3を参照）デコーダから受信し、エンコーダによって認め。"
    },
    {
      "indent": 3,
      "text": "Reducing the maximum size of the dynamic table can cause entries to be evicted (see Section 4.3).",
      "ja": "動的テーブルの最大サイズを小さくする（4.3節を参照）のエントリが追い出されることがあります。"
    },
    {
      "indent": 0,
      "text": "7. Security Considerations",
      "section_title": true,
      "ja": "7.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "This section describes potential areas of security concern with HPACK:",
      "ja": "このセクションでは、HPACKとセキュリティ上の問題の可能性がある領域について説明します。"
    },
    {
      "indent": 3,
      "text": "o Use of compression as a length-based oracle for verifying guesses about secrets that are compressed into a shared compression context.",
      "ja": "共有圧縮コンテキストに圧縮される秘密について推測を検証するための長さベースのOracleなどの圧縮のOを使用します。"
    },
    {
      "indent": 3,
      "text": "o Denial of service resulting from exhausting processing or memory capacity at a decoder.",
      "ja": "Oデコーダで処理やメモリ容量を排気から生じるサービスの拒否。"
    },
    {
      "indent": 0,
      "text": "7.1. Probing Dynamic Table State",
      "section_title": true,
      "ja": "7.1. 動的テーブルの状態をプロービング"
    },
    {
      "indent": 3,
      "text": "HPACK reduces the length of header field encodings by exploiting the redundancy inherent in protocols like HTTP. The ultimate goal of this is to reduce the amount of data that is required to send HTTP requests or responses.",
      "ja": "HPACKは、HTTPなどのプロトコルに固有の冗長性を利用してヘッダーフィールドのエンコーディングの長さを減少させます。これの究極の目標は、HTTP要求または応答を送信するために必要とされるデータの量を減らすことです。"
    },
    {
      "indent": 3,
      "text": "The compression context used to encode header fields can be probed by an attacker who can both define header fields to be encoded and transmitted and observe the length of those fields once they are encoded. When an attacker can do both, they can adaptively modify requests in order to confirm guesses about the dynamic table state. If a guess is compressed into a shorter length, the attacker can observe the encoded length and infer that the guess was correct.",
      "ja": "ヘッダ・フィールドを符号化するために使用する圧縮コンテキストは、符号化され、送信されるヘッダフィールドを定義し、それらがエンコードされたら、これらのフィールドの長さを観察することができ、両方の攻撃者によってプローブすることができます。攻撃者はその両方を行うことができたとき、彼らは適応動的テーブルの状態についての推測を確認するために要求を変更することができます。推測では、短い長さに圧縮されている場合、攻撃者はエンコードされた長さを観察し、推測が正しかったことを推測することができます。"
    },
    {
      "indent": 3,
      "text": "This is possible even over the Transport Layer Security (TLS) protocol (see [TLS12]), because while TLS provides confidentiality protection for content, it only provides a limited amount of protection for the length of that content.",
      "ja": "TLSは、コンテンツの機密保護を提供しながら、それだけでそのコンテンツの長さのための保護の限られた量を提供しますので、これは、でも、トランスポート層セキュリティ（TLS）プロトコル（[TLS12]を参照）を介して可能です。"
    },
    {
      "indent": 6,
      "text": "Note: Padding schemes only provide limited protection against an attacker with these capabilities, potentially only forcing an increased number of guesses to learn the length associated with a given guess. Padding schemes also work directly against compression by increasing the number of bits that are transmitted.",
      "ja": "注意：パディングスキームは、潜在的にのみ与えられた推測に関連した長さを学ぶことが推測の増加数を強制的に、これらの能力を持つ攻撃者に対して限られた保護を提供します。パディング方式も送信されるビットの数を増加させることによって圧縮に対して直接働きます。"
    },
    {
      "indent": 3,
      "text": "Attacks like CRIME [CRIME] demonstrated the existence of these general attacker capabilities. The specific attack exploited the fact that DEFLATE [DEFLATE] removes redundancy based on prefix matching. This permitted the attacker to confirm guesses a character at a time, reducing an exponential-time attack into a linear-time attack.",
      "ja": "CRIME [犯罪]のような攻撃は、これらの一般的な攻撃能力の存在を実証しました。特定の攻撃は、DEFLATE [DEFLATE]が前方一致に基づいて冗長性を除去しているという事実を利用しました。これは、線形時間攻撃に指数関数時間の攻撃を減らすこと、一度推測に文字を確認するために、攻撃者が許可しました。"
    },
    {
      "indent": 0,
      "text": "7.1.1. Applicability to HPACK and HTTP",
      "section_title": true,
      "ja": "7.1.1.  HPACKおよびHTTPへの適用"
    },
    {
      "indent": 3,
      "text": "HPACK mitigates but does not completely prevent attacks modeled on CRIME [CRIME] by forcing a guess to match an entire header field value rather than individual characters. Attackers can only learn whether a guess is correct or not, so they are reduced to brute-force guesses for the header field values.",
      "ja": "HPACKを緩和するが、完全に全体ヘッダーフィールド値ではなく、個々の文字に一致するように推測を強制することによって[犯罪]犯罪モデル化された攻撃を防ぐことはできません。攻撃者は、推測が正しいか否かを知ることができるので、それらは、ヘッダフィールド値のブルートフォース推測に還元されます。"
    },
    {
      "indent": 3,
      "text": "The viability of recovering specific header field values therefore depends on the entropy of values. As a result, values with high entropy are unlikely to be recovered successfully. However, values with low entropy remain vulnerable.",
      "ja": "従って、特定のヘッダフィールド値を回復の生存率は、値のエントロピーに依存します。その結果、高いエントロピーを持つ値が正常に回復されそうにありません。しかし、低エントロピーとの値が脆弱なまま。"
    },
    {
      "indent": 3,
      "text": "Attacks of this nature are possible any time that two mutually distrustful entities control requests or responses that are placed onto a single HTTP/2 connection. If the shared HPACK compressor permits one entity to add entries to the dynamic table and the other to access those entries, then the state of the table can be learned.",
      "ja": "この種の攻撃は、単一のHTTP / 2接続上に配置された2つの相互不信のエンティティが要求または応答を制御することはいつでも可能です。共有HPACK圧縮機はこれらのエントリにアクセスするために動的テーブルと他のにエントリを追加するために、1つのエンティティを許可する場合、テーブルの状態を知ることができます。"
    },
    {
      "indent": 3,
      "text": "Having requests or responses from mutually distrustful entities occurs when an intermediary either:",
      "ja": "相互不信のエンティティからの要求または応答を持つことは、発生したときに仲介のいずれか："
    },
    {
      "indent": 3,
      "text": "o sends requests from multiple clients on a single connection toward an origin server, or",
      "ja": "oはオリジンサーバに向けて、単一の接続で複数のクライアントからのリクエストを送信し、または"
    },
    {
      "indent": 3,
      "text": "o takes responses from multiple origin servers and places them on a shared connection toward a client.",
      "ja": "oは、複数のオリジンサーバからの応答を受け取り、クライアントに向けて共有接続上に配置します。"
    },
    {
      "indent": 3,
      "text": "Web browsers also need to assume that requests made on the same connection by different web origins [ORIGIN] are made by mutually distrustful entities.",
      "ja": "Webブラウザは、異なるウェブ起源[ORIGIN]によって、同じ接続上で行われた要求は、相互不信のエンティティによって行われていることを前提とする必要があります。"
    },
    {
      "indent": 0,
      "text": "7.1.2. Mitigation",
      "section_title": true,
      "ja": "7.1.2. 緩和"
    },
    {
      "indent": 3,
      "text": "Users of HTTP that require confidentiality for header fields can use values with entropy sufficient to make guessing infeasible. However, this is impractical as a general solution because it forces all users of HTTP to take steps to mitigate attacks. It would impose new constraints on how HTTP is used.",
      "ja": "ヘッダフィールドの機密性が必要なHTTPのユーザーが実行不可能推測するのに十分なエントロピーを使用して値を使用することができます。それはHTTPのすべてのユーザーが攻撃を軽減するための措置をとることを強制するためしかし、これは一般的な解決策として非現実的です。これは、HTTPを使用する方法についての新たな制約を課します。"
    },
    {
      "indent": 3,
      "text": "Rather than impose constraints on users of HTTP, an implementation of HPACK can instead constrain how compression is applied in order to limit the potential for dynamic table probing.",
      "ja": "HTTPのユーザに制約を課すのではなく、HPACKの実装ではなく、圧縮が動的テーブルプロービングの可能性を制限するために適用される方法を制約することができます。"
    },
    {
      "indent": 3,
      "text": "An ideal solution segregates access to the dynamic table based on the entity that is constructing header fields. Header field values that are added to the table are attributed to an entity, and only the entity that created a particular value can extract that value.",
      "ja": "理想的な解決策は、ヘッダフィールドを構築されたエンティティに基づいて動的テーブルへのアクセスを分離します。テーブルに追加されたヘッダフィールド値をエンティティに起因する、特定の値を作成する唯一のエンティティは、その値を抽出することができます。"
    },
    {
      "indent": 3,
      "text": "To improve compression performance of this option, certain entries might be tagged as being public. For example, a web browser might make the values of the Accept-Encoding header field available in all requests.",
      "ja": "このオプションの圧縮性能を向上させるために、特定のエントリは、パブリックであるとしてタグ付けされる可能性があります。たとえば、Webブラウザは、すべての要求でのAccept-Encodingヘッダフィールドの値が利用可能になるかもしれません。"
    },
    {
      "indent": 3,
      "text": "An encoder without good knowledge of the provenance of header fields might instead introduce a penalty for a header field with many different values, such that a large number of attempts to guess a header field value results in the header field no longer being compared to the dynamic table entries in future messages, effectively preventing further guesses.",
      "ja": "ヘッダフィールドの起源の十分な知識なしに、エンコーダは代わりに、ヘッダフィールドにヘッダフィールド値の結果を推測する試みの多くは、もはや動的に比較されるように、多くの異なる値を有するヘッダフィールドのペナルティを導入するかもしれません今後のメッセージでのテーブルエントリは、効果的にさらに推測を防ぎます。"
    },
    {
      "indent": 6,
      "text": "Note: Simply removing entries corresponding to the header field from the dynamic table can be ineffectual if the attacker has a reliable way of causing values to be reinstalled. For example, a request to load an image in a web browser typically includes the Cookie header field (a potentially highly valued target for this sort of attack), and web sites can easily force an image to be loaded, thereby refreshing the entry in the dynamic table.",
      "ja": "注：攻撃者が再インストールされる値を引き起こす信頼できる方法を持っている場合だけで動的テーブルからヘッダ・フィールドに対応するエントリを除去する効果がないとすることができます。例えば、ウェブブラウザにイメージをロードするための要求は、典型的には、Cookieヘッダフィールド（この種の攻撃のための潜在的に高い評価対象）を有し、及びウェブサイトはやすくのエントリをリフレッシュ、ロードする画像を強制することができ動的テーブル。"
    },
    {
      "indent": 3,
      "text": "This response might be made inversely proportional to the length of the header field value. Marking a header field as not using the dynamic table anymore might occur for shorter values more quickly or with higher probability than for longer values.",
      "ja": "この応答は、ヘッダフィールド値の長さに反比例して行われるかもしれません。もう動的テーブルを使用しないようヘッダフィールドをマークすると、より速く以上の値よりも高い確率で短い値のために発生する可能性があります。"
    },
    {
      "indent": 0,
      "text": "7.1.3. Never-Indexed Literals",
      "section_title": true,
      "ja": "7.1.3. 決して、インデックス付きリテラル"
    },
    {
      "indent": 3,
      "text": "Implementations can also choose to protect sensitive header fields by not compressing them and instead encoding their value as literals.",
      "ja": "また、実装は、それらを圧縮し、代わりにリテラルとしての価値をコードしないことにより、敏感なヘッダフィールドを保護するために選択することができます。"
    },
    {
      "indent": 3,
      "text": "Refusing to generate an indexed representation for a header field is only effective if compression is avoided on all hops. The never-indexed literal (see Section 6.2.3) can be used to signal to intermediaries that a particular value was intentionally sent as a literal.",
      "ja": "圧縮がすべてのホップに回避されている場合、ヘッダフィールドのインデックス付き表現を生成することを拒否することのみ有効です。インデックスはないリテラル（セクション6.2.3を参照）、特定の値を意図的にリテラルとして送信された媒体に信号を送るために使用することができます。"
    },
    {
      "indent": 3,
      "text": "An intermediary MUST NOT re-encode a value that uses the never-indexed literal representation with another representation that would index it. If HPACK is used for re-encoding, the never-indexed literal representation MUST be used.",
      "ja": "仲介は、それはそれインデックスだろう別の表現と決してインデックスませんリテラル表現を使用して値を再エンコードしてはなりません。 HPACKは、再エンコードするために使用されている場合は、インデックスはありませんリテラル表現を使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The choice to use a never-indexed literal representation for a header field depends on several factors. Since HPACK doesn't protect against guessing an entire header field value, short or low-entropy values are more readily recovered by an adversary. Therefore, an encoder might choose not to index values with low entropy.",
      "ja": "ヘッダフィールドのインデックス決してリテラル表現を使用するための選択肢はいくつかの要因に依存します。 HPACK全体ヘッダーフィールド値を推測から保護しないため、短いまたは低エントロピー値は、より容易に敵対することによって回収されます。したがって、エンコーダは、低エントロピーでないインデックス値に選択することがあります。"
    },
    {
      "indent": 3,
      "text": "An encoder might also choose not to index values for header fields that are considered to be highly valuable or sensitive to recovery, such as the Cookie or Authorization header fields.",
      "ja": "エンコーダはまた、非常に価値のある、またはそのようなクッキーまたは認可ヘッダーフィールドとして、回復に敏感であると考えられているヘッダフィールドのインデックス値にないことを選択するかもしれません。"
    },
    {
      "indent": 3,
      "text": "On the contrary, an encoder might prefer indexing values for header fields that have little or no value if they were exposed. For instance, a User-Agent header field does not commonly vary between requests and is sent to any server. In that case, confirmation that a particular User-Agent value has been used provides little value.",
      "ja": "逆に、エンコーダは、それらが暴露された場合はほとんど、あるいはまったく価値を持つヘッダーフィールドのインデックス値を好むかもしれません。たとえば、User-Agentヘッダフィールドは、一般的に要求し、任意のサーバーに送信されるの間で変化しません。その場合には、特定のUser-Agentの値が使用されていることの確認は、ほとんど価値を提供します。"
    },
    {
      "indent": 3,
      "text": "Note that these criteria for deciding to use a never-indexed literal representation will evolve over time as new attacks are discovered.",
      "ja": "新しい攻撃が発見されると、インデックスされませんリテラル表現の使用を決定するためのこれらの基準は、時間をかけて進化していくことに注意してください。"
    },
    {
      "indent": 0,
      "text": "7.2. Static Huffman Encoding",
      "section_title": true,
      "ja": "7.2. 静的ハフマン符号化"
    },
    {
      "indent": 3,
      "text": "There is no currently known attack against a static Huffman encoding. A study has shown that using a static Huffman encoding table created an information leakage; however, this same study concluded that an attacker could not take advantage of this information leakage to recover any meaningful amount of information (see [PETAL]).",
      "ja": "静的ハフマン符号化に対しては、現在知られている攻撃はありません。研究は、静的ハフマン符号化テーブルを使用して情報漏洩を作成したことが示されています。しかし、この同じ研究では、攻撃者が（[PETAL]参照）の情報のいずれかの意味のある量を回復するために、この情報漏洩の利点を取ることができなかったと結論付けました。"
    },
    {
      "indent": 0,
      "text": "7.3. Memory Consumption",
      "section_title": true,
      "ja": "7.3. メモリ消費量"
    },
    {
      "indent": 3,
      "text": "An attacker can try to cause an endpoint to exhaust its memory. HPACK is designed to limit both the peak and state amounts of memory allocated by an endpoint.",
      "ja": "攻撃者は、そのメモリを排気するためのエンドポイントを引き起こすことを試みることができます。 HPACKは、エンドポイントによって割り当てられたメモリのピークと状態量の両方を制限するように設計されています。"
    },
    {
      "indent": 3,
      "text": "The amount of memory used by the compressor is limited by the protocol using HPACK through the definition of the maximum size of the dynamic table. In HTTP/2, this value is controlled by the decoder through the setting parameter SETTINGS_HEADER_TABLE_SIZE (see Section 6.5.2 of [HTTP2]). This limit takes into account both the size of the data stored in the dynamic table, plus a small allowance for overhead.",
      "ja": "圧縮機によって使用されるメモリの量は、動的テーブルの最大サイズの定義によってHPACKを使用してプロトコルによって制限されます。 HTTP / 2では、この値は設定パラメータSETTINGS_HEADER_TABLE_SIZE介してデコーダによって制御される（[HTTP2]のセクション6.5.2を参照）。この制限は、アカウントに動的テーブルに格納されたデータのサイズ、プラスオーバーヘッドのために小さな余裕の両方を取ります。"
    },
    {
      "indent": 3,
      "text": "A decoder can limit the amount of state memory used by setting an appropriate value for the maximum size of the dynamic table. In HTTP/2, this is realized by setting an appropriate value for the SETTINGS_HEADER_TABLE_SIZE parameter. An encoder can limit the amount of state memory it uses by signaling a lower dynamic table size than the decoder allows (see Section 6.3).",
      "ja": "デコーダは、ダイナミックテーブルの最大サイズに適切な値を設定することにより、使用状態メモリの量を制限することができます。 HTTP / 2では、これはSETTINGS_HEADER_TABLE_SIZEパラメータの適切な値を設定することによって実現されます。エンコーダは、デコーダより低いダイナミックテーブルサイズをシグナリングすることによって、それが使用状態メモリの量を制限することができる（セクション6.3を参照）ことができます。"
    },
    {
      "indent": 3,
      "text": "The amount of temporary memory consumed by an encoder or decoder can be limited by processing header fields sequentially. An implementation does not need to retain a complete list of header fields. Note, however, that it might be necessary for an application to retain a complete header list for other reasons; even though HPACK does not force this to occur, application constraints might make this necessary.",
      "ja": "エンコーダまたはデコーダによって消費される一時的なメモリの量が順次ヘッダフィールドを処理することによって制限することができます。実装は、ヘッダフィールドの完全なリストを保持する必要はありません。それは他の理由のための完全なヘッダのリストを保持するアプリケーションのために必要であるかもしれないこと、しかし、注意してください。 HPACKが発生し、これを強制するものではありませんが、アプリケーションの制約は、これが必要になるかもしれません。"
    },
    {
      "indent": 0,
      "text": "7.4. Implementation Limits",
      "section_title": true,
      "ja": "7.4. 実装に関する制限"
    },
    {
      "indent": 3,
      "text": "An implementation of HPACK needs to ensure that large values for integers, long encoding for integers, or long string literals do not create security weaknesses.",
      "ja": "HPACKの実装では、整数、整数、または長い文字列リテラルの長いエンコーディングのための大きな値は、セキュリティ上の弱点を作成しないことを保証する必要があります。"
    },
    {
      "indent": 3,
      "text": "An implementation has to set a limit for the values it accepts for integers, as well as for the encoded length (see Section 5.1). In the same way, it has to set a limit to the length it accepts for string literals (see Section 5.2).",
      "ja": "実装は、それが整数の受け入れ値の上限を設定する必要があり、同様に符号化された長さ（セクション5.1を参照）。同様に、それは文字列リテラル用に受け入れる長さに制限を設定しなければならない（セクション5.2を参照）。"
    },
    {
      "indent": 0,
      "text": "8. References",
      "section_title": true,
      "ja": "8.参照文献"
    },
    {
      "indent": 0,
      "text": "8.1. Normative References",
      "section_title": true,
      "ja": "8.1. 引用規格"
    },
    {
      "indent": 3,
      "text": "[HTTP2] Belshe, M., Peon, R., and M. Thomson, Ed., \"Hypertext Transfer Protocol Version 2 (HTTP/2)\", RFC 7540, DOI 10.17487/RFC7540, May 2015, <http://www.rfc-editor.org/info/rfc7540>.",
      "ja": "[HTTP2] Belshe、M.、ペオン、R.、およびM.トムソン、エド、 \"ハイパーテキスト転送プロトコルバージョン2（HTTP / 2）\"、RFC 7540、DOI 10.17487 / RFC7540、2015年5月、<のhttp：// www.rfc-editor.org/info/rfc7540>。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<http://www.rfc-editor.org/info/ RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC7230] Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing\", RFC 7230, DOI 10.17487/RFC7230, June 2014, <http://www.rfc-editor.org/info/rfc7230>.",
      "ja": "[RFC7230]フィールディング、R.、エド。及びJ. Reschke、編、 \"ハイパーテキスト転送プロトコル（HTTP / 1.1）：メッセージの構文およびルーティング\"、RFC 7230、DOI 10.17487 / RFC7230、2014年6月、<http://www.rfc-editor.org/info/ rfc7230>。"
    },
    {
      "indent": 0,
      "text": "8.2. Informative References",
      "section_title": true,
      "ja": "8.2. 参考文献"
    },
    {
      "indent": 3,
      "text": "[CANONICAL] Schwartz, E. and B. Kallick, \"Generating a canonical prefix encoding\", Communications of the ACM, Volume 7 Issue 3, pp. 166-169, March 1964, <https://dl.acm.org/ citation.cfm?id=363991>.",
      "ja": "【CANONICAL]シュワルツ、E.およびB. Kallick、 \"カノニカルプレフィックス符号を生成\"、ACMの通信、7巻3号、頁166-169、1964年3月、<https://dl.acm.org/ citation.cfm？ID = 363991>。"
    },
    {
      "indent": 3,
      "text": "[CRIME] Wikipedia, \"CRIME\", May 2015, <http://en.wikipedia.org/w/ index.php?title=CRIME&oldid=660948120>.",
      "ja": "[犯罪]ウィキペディア、 \"CRIME\"、2015年5月、<http://en.wikipedia.org/w/のindex.php？タイトル=犯罪＆oldid = 660948120>。"
    },
    {
      "indent": 3,
      "text": "[DEFLATE] Deutsch, P., \"DEFLATE Compressed Data Format Specification version 1.3\", RFC 1951, DOI 10.17487/RFC1951, May 1996, <http://www.rfc-editor.org/info/rfc1951>.",
      "ja": "[DEFLATE]ドイツ、P.、 \"DEFLATE圧縮データフォーマット仕様バージョン1.3\"、RFC 1951、DOI 10.17487 / RFC1951、1996年5月、<http://www.rfc-editor.org/info/rfc1951>は。"
    },
    {
      "indent": 3,
      "text": "[HUFFMAN] Huffman, D., \"A Method for the Construction of Minimum-Redundancy Codes\", Proceedings of the Institute of Radio Engineers, Volume 40, Number 9, pp. 1098-1101, September 1952, <http://ieeexplore.ieee.org/xpl/ articleDetails.jsp?arnumber=4051119>.",
      "ja": "[HUFFMAN]ハフマン、D.、「最小-冗長符号の構築のための方法」、ラジオ学会、40巻の議事録、数9頁1098年から1101年、1952年9月、<のhttp：// ieeexplore .ieee.org / XPL / articleDetails.jsp？arnumber = 4051119>。"
    },
    {
      "indent": 3,
      "text": "[ORIGIN] Barth, A., \"The Web Origin Concept\", RFC 6454, DOI 10.17487/RFC6454, December 2011, <http://www.rfc-editor.org/info/rfc6454>.",
      "ja": "[ORIGIN]バース、A.、 \"ウェブ起源コンセプト\"、RFC 6454、DOI 10.17487 / RFC6454、2011年12月、<http://www.rfc-editor.org/info/rfc6454>。"
    },
    {
      "indent": 3,
      "text": "[PETAL] Tan, J. and J. Nahata, \"PETAL: Preset Encoding Table Information Leakage\", April 2013, <http://www.pdl.cmu.edu/PDL-FTP/associated/ CMU-PDL-13-106.pdf>.",
      "ja": "【PETAL】タン、J.およびJ. Nahata、 \"PETAL：プリセットエンコーディング表情報漏洩\"、2013年4月、<http://www.pdl.cmu.edu/PDL-FTP/associated/ CMU-PDL-13- 106.pdf>。"
    },
    {
      "indent": 3,
      "text": "[SPDY] Belshe, M. and R. Peon, \"SPDY Protocol\", Work in Progress, draft-mbelshe-httpbis-spdy-00, February 2012.",
      "ja": "[SPDY] Belshe、M.とR.ペオン、 \"SPDYプロトコル\" が進行中で働いて、ドラフトmbelshe-httpbis-SPDY-00、2012年2月。"
    },
    {
      "indent": 3,
      "text": "[TLS12] Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS) Protocol Version 1.2\", RFC 5246, DOI 10.17487/RFC5246, August 2008, <http://www.rfc-editor.org/info/rfc5246>.",
      "ja": "[TLS12]ダークス、T.およびE.レスコラ、 \"トランスポート層セキュリティ（TLS）プロトコルバージョン1.2\"、RFC 5246、DOI 10.17487 / RFC5246、2008年8月、<http://www.rfc-editor.org/info / RFC5246>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Static Table Definition",
      "ja": "付録A.静的テーブル定義"
    },
    {
      "indent": 3,
      "text": "The static table (see Section 2.3.1) consists in a predefined and unchangeable list of header fields.",
      "ja": "静的テーブル（セクション2.3.1を参照）ヘッダフィールドの所定の及び不変リストからなります。"
    },
    {
      "indent": 3,
      "text": "The static table was created from the most frequent header fields used by popular web sites, with the addition of HTTP/2-specific pseudo-header fields (see Section 8.1.2.1 of [HTTP2]). For header fields with a few frequent values, an entry was added for each of these frequent values. For other header fields, an entry was added with an empty value.",
      "ja": "静的テーブルはHTTP / 2固有疑似ヘッダフィールドを加えて、人気のあるウェブサイトで使用される最も頻繁なヘッダフィールドから作成された（[HTTP2]のセクション8.1.2.1を参照）。いくつかの頻繁な値を持つヘッダフィールドに、エントリは、これらの頻出値のそれぞれのために添加しました。他のヘッダフィールドの場合、エントリが空の値を加えました。"
    },
    {
      "indent": 3,
      "text": "Table 1 lists the predefined header fields that make up the static table and gives the index of each entry.",
      "ja": "表1は、静的テーブルを構成し、各項目の指標を与える事前定義されたヘッダフィールド。"
    },
    {
      "indent": 10,
      "text": "+-------+-----------------------------+---------------+\n| Index | Header Name                 | Header Value  |\n+-------+-----------------------------+---------------+\n| 1     | :authority                  |               |\n| 2     | :method                     | GET           |\n| 3     | :method                     | POST          |\n| 4     | :path                       | /             |\n| 5     | :path                       | /index.html   |\n| 6     | :scheme                     | http          |\n| 7     | :scheme                     | https         |\n| 8     | :status                     | 200           |\n| 9     | :status                     | 204           |\n| 10    | :status                     | 206           |\n| 11    | :status                     | 304           |\n| 12    | :status                     | 400           |\n| 13    | :status                     | 404           |\n| 14    | :status                     | 500           |\n| 15    | accept-charset              |               |\n| 16    | accept-encoding             | gzip, deflate |\n| 17    | accept-language             |               |\n| 18    | accept-ranges               |               |\n| 19    | accept                      |               |\n| 20    | access-control-allow-origin |               |\n| 21    | age                         |               |\n| 22    | allow                       |               |\n| 23    | authorization               |               |\n| 24    | cache-control               |               |\n| 25    | content-disposition         |               |\n| 26    | content-encoding            |               |\n| 27    | content-language            |               |\n| 28    | content-length              |               |\n| 29    | content-location            |               |\n| 30    | content-range               |               |",
      "raw": true
    },
    {
      "indent": 10,
      "text": "| 31    | content-type                |               |\n| 32    | cookie                      |               |\n| 33    | date                        |               |\n| 34    | etag                        |               |\n| 35    | expect                      |               |\n| 36    | expires                     |               |\n| 37    | from                        |               |\n| 38    | host                        |               |\n| 39    | if-match                    |               |\n| 40    | if-modified-since           |               |\n| 41    | if-none-match               |               |\n| 42    | if-range                    |               |\n| 43    | if-unmodified-since         |               |\n| 44    | last-modified               |               |\n| 45    | link                        |               |\n| 46    | location                    |               |\n| 47    | max-forwards                |               |\n| 48    | proxy-authenticate          |               |\n| 49    | proxy-authorization         |               |\n| 50    | range                       |               |\n| 51    | referer                     |               |\n| 52    | refresh                     |               |\n| 53    | retry-after                 |               |\n| 54    | server                      |               |\n| 55    | set-cookie                  |               |\n| 56    | strict-transport-security   |               |\n| 57    | transfer-encoding           |               |\n| 58    | user-agent                  |               |\n| 59    | vary                        |               |\n| 60    | via                         |               |\n| 61    | www-authenticate            |               |\n+-------+-----------------------------+---------------+",
      "raw": true
    },
    {
      "indent": 23,
      "text": "Table 1: Static Table Entries",
      "ja": "表1：静的テーブルエントリ"
    },
    {
      "indent": 0,
      "text": "Appendix B. Huffman Code",
      "ja": "付録B.ハフマン符号"
    },
    {
      "indent": 3,
      "text": "The following Huffman code is used when encoding string literals with a Huffman coding (see Section 5.2).",
      "ja": "ハフマン符号化を用いて文字列リテラルを符号化するとき、次のハフマンコードが使用される（セクション5.2参照）。"
    },
    {
      "indent": 3,
      "text": "This Huffman code was generated from statistics obtained on a large sample of HTTP headers. It is a canonical Huffman code (see [CANONICAL]) with some tweaking to ensure that no symbol has a unique code length.",
      "ja": "このハフマンコードは、HTTPヘッダーの大きい試料について得られた統計から生成されました。それには、シンボルが一意のコード長さを有していないことを確実にするためにいくつかの調整と（[CANONICAL]を参照）カノニカルハフマンコードです。"
    },
    {
      "indent": 3,
      "text": "Each row in the table defines the code used to represent a symbol:",
      "ja": "テーブルの各行は、シンボルを表すために使用されるコードを定義しています。"
    },
    {
      "indent": 3,
      "text": "sym: The symbol to be represented. It is the decimal value of an octet, possibly prepended with its ASCII representation. A specific symbol, \"EOS\", is used to indicate the end of a string literal.",
      "ja": "SYM：シンボルを表現することにします。それは、おそらくそのASCII表現を先頭に追加、オクテットの10進値です。特定のシンボル、「EOS」は、リテラル文字列の終わりを示すために使用されます。"
    },
    {
      "indent": 3,
      "text": "code as bits: The Huffman code for the symbol represented as a base-2 integer, aligned on the most significant bit (MSB).",
      "ja": "ビットとしてコード：ベース2の整数として表されるシンボルのハフマン符号、最上位ビット（MSB）に整列されます。"
    },
    {
      "indent": 3,
      "text": "code as hex: The Huffman code for the symbol, represented as a hexadecimal integer, aligned on the least significant bit (LSB).",
      "ja": "ヘクスとしてコード：シンボルのハフマンコードは、最下位ビット（LSB）に位置合わせ進整数として表されます。"
    },
    {
      "indent": 3,
      "text": "len: The number of bits for the code representing the symbol.",
      "ja": "LEN：シンボルを表すコードのビット数。"
    },
    {
      "indent": 3,
      "text": "As an example, the code for the symbol 47 (corresponding to the ASCII character \"/\") consists in the 6 bits \"0\", \"1\", \"1\", \"0\", \"0\", \"0\". This corresponds to the value 0x18 (in hexadecimal) encoded in 6 bits.",
      "ja": "一例として、シンボル47のコード（ASCII文字 \"/\" に対応）が6ビット \"0\"、 \"1\"、 \"1\"、 \"0\"、 \"0\"、 \"0\" からなります。これは、6ビットで符号化された（16進数）の値0x18のに相当します。"
    },
    {
      "indent": 3,
      "text": " code code as bits as hex len sym aligned to MSB aligned in to LSB bits ( 0) |11111111|11000 1ff8 [13] ( 1) |11111111|11111111|1011000 7fffd8 [23] ( 2) |11111111|11111111|11111110|0010 fffffe2 [28] ( 3) |11111111|11111111|11111110|0011 fffffe3 [28] ( 4) |11111111|11111111|11111110|0100 fffffe4 [28] ( 5) |11111111|11111111|11111110|0101 fffffe5 [28] ( 6) |11111111|11111111|11111110|0110 fffffe6 [28] ( 7) |11111111|11111111|11111110|0111 fffffe7 [28] ( 8) |11111111|11111111|11111110|1000 fffffe8 [28] ( 9) |11111111|11111111|11101010 ffffea [24] ( 10) |11111111|11111111|11111111|111100 3ffffffc [30] ( 11) |11111111|11111111|11111110|1001 fffffe9 [28] ( 12) |11111111|11111111|11111110|1010 fffffea [28] ( 13) |11111111|11111111|11111111|111101 3ffffffd [30] ( 14) |11111111|11111111|11111110|1011 fffffeb [28] ( 15) |11111111|11111111|11111110|1100 fffffec [28] ( 16) |11111111|11111111|11111110|1101 fffffed [28] ( 17) |11111111|11111111|11111110|1110 fffffee [28] ( 18) |11111111|11111111|11111110|1111 fffffef [28] ( 19) |11111111|11111111|11111111|0000 ffffff0 [28] ( 20) |11111111|11111111|11111111|0001 ffffff1 [28] ( 21) |11111111|11111111|11111111|0010 ffffff2 [28] ( 22) |11111111|11111111|11111111|111110 3ffffffe [30] ( 23) |11111111|11111111|11111111|0011 ffffff3 [28] ( 24) |11111111|11111111|11111111|0100 ffffff4 [28] ( 25) |11111111|11111111|11111111|0101 ffffff5 [28] ( 26) |11111111|11111111|11111111|0110 ffffff6 [28] ( 27) |11111111|11111111|11111111|0111 ffffff7 [28] ( 28) |11111111|11111111|11111111|1000 ffffff8 [28] ( 29) |11111111|11111111|11111111|1001 ffffff9 [28] ( 30) |11111111|11111111|11111111|1010 ffffffa [28] ( 31) |11111111|11111111|11111111|1011 ffffffb [28] ' ' ( 32) |010100 14 [ 6] '!' ( 33) |11111110|00 3f8 [10] '\"' ( 34) |11111110|01 3f9 [10] '#' ( 35) |11111111|1010 ffa [12] '$' ( 36) |11111111|11001 1ff9 [13] '%' ( 37) |010101 15 [ 6] '&' ( 38) |11111000 f8 [ 8] ''' ( 39) |11111111|010 7fa [11] '(' ( 40) |11111110|10 3fa [10] ')' ( 41) |11111110|11 3fb [10] '*' ( 42) |11111001 f9 [ 8] '+' ( 43) |11111111|011 7fb [11] ',' ( 44) |11111010 fa [ 8] '-' ( 45) |010110 16 [ 6] '.' ( 46) |010111 17 [ 6] '/' ( 47) |011000 18 [ 6] '0' ( 48) |00000 0 [ 5] '1' ( 49) |00001 1 [ 5] '2' ( 50) |00010 2 [ 5] '3' ( 51) |011001 19 [ 6] '4' ( 52) |011010 1a [ 6] '5' ( 53) |011011 1b [ 6] '6' ( 54) |011100 1c [ 6] '7' ( 55) |011101 1d [ 6] '8' ( 56) |011110 1e [ 6] '9' ( 57) |011111 1f [ 6] ':' ( 58) |1011100 5c [ 7] ';' ( 59) |11111011 fb [ 8] '<' ( 60) |11111111|1111100 7ffc [15] '=' ( 61) |100000 20 [ 6]",
      "ja": "11111111 | | LSBビット（0）に整列MSBに揃えヘクスlenのSYMとしてビットとして符号コード11000 1ff8 [13]（1）| 11111111 | 11111111 | 1011000 7fffd8 [23]（2）| 11111111 | 11111111 | 11111110 | 0010 fffffe2 [28]（3）| 11111111 | 11111111 | 11111110 | 0011 fffffe3 [28]（4）| 11111111 | 11111111 | 11111110 | 0100 fffffe4 [28]（5）| 11111111 | 11111111 | 11111110 | 0101 fffffe5 [28] （6）| 11111111 | 11111111 | 11111110 | 0110 fffffe6 [28]（7）| 11111111 | 11111111 | 11111110 | 0111 fffffe7 [28]（8）| 11111111 | 11111111 | 11111110 | 1000年fffffe8 [28]（9）| 11111111 | 11111111 | 11101010 ffffea [24]（10）| 11111111 | 11111111 | 11111111 | 111100 3ffffffc [30]（11）| 11111111 | 11111111 | 11111110 | 1001 fffffe9 [28]（12）| 11111111 | 11111111 | 11111110 | 1010 fffffea [28]（13）| 11111111 | 11111111 | 11111111 | 111101 3ffffffd [30]（14）| 11111111 | 11111111 | 11111110 | 1011 fffffeb [28]（15）| 11111111 | 11111111 | 11111110 | 1100 fffffec [28]（16 ）| 11111111 | 11111111 | 11111110 | 1101 [28]（17）fffffed | 11111 | 11111111 | 11111111 | 11111111 | 11111111 | 11111110 | 1110 fffffee [28]（18） 110 | 1111 fffffef [28]（19）| 11111111 | 11111111 | 11111111 | 0000 ffffff0 [28]（20）| 11111111 | 11111111 | 11111111 | 0001 ffffff1 [28]（21）| 11111111 | 11111111 | 11111111 | 0010 ffffff2 [ 28（22）| 11111111 | 11111111 | 11111111 | 111110 3ffffffe [30]（23）| 11111111 | 11111111 | 11111111 | 0011 ffffff3 [28]（24）| 11111111 | 11111111 | 11111111 | 0100 ffffff4 [28]（25） | 11111111 | 11111111 | 11111111 | 0101 ffffff5 [28]（26）| 11111111 | 11111111 | 11111111 | 0110 ffffff6 [28]（27）| 11111111 | 11111111 | 11111111 | 0111 ffffff7 [28]（28）| 11111111 | 11111111 | 11111111 | 1000年ffffff8 [28]（29）| 11111111 | 11111111 | 11111111 | 1001 ffffff9 [28]（30）| 11111111 | 11111111 | 11111111 | 1010 ffffffa [28]（31）| 11111111 | 11111111 | 11111111 | 1011 ffffffb [ 28] ''（32）| 010100 14 [6] ''！ （33）| 11111110 | 00 3F8 [10] '\"'（34）| 11111110 | 01 3F9 [10] '＃'（35）| 11111111 | 1010 FFA [12] '$'（36）| 11111111 | 11001 1ff9 [13] '％'（37）| 010101 15 [6] '＆'（38）| 11111000のF8 [8] ''」（39）| 11111111 | 010 7FA [11] '（'（40）| 11111110 | 10 3FA [10] ''）（41）| 11111110 | 11 3FB [10] '*'（42）| 11111001 F9 [8] '+'（43）| 11111111 | 011 7FB [11] ''（44 ）| 11111010 FA [8] ' - '（45）| 010110 16 [6] '' （46）| 010111 17 [6] '/'（47）| 011000 18 [6] '0'（48）| 00000 0 [5] '1'（49）| 00001 1 [5] '2'（50 ）| 00010 2 [5] '3'（51）| 011001 19 [6] '4'（52）| 011010 1A [6] '5'（53）| 011011 1B [6] '6'（54）| 011100 1C [6] [7]（55）| 011101 1D [6] '8'（56）| 011110 1E [6] '9'（57）| 011111 1F [6] '：'（58）| 1011100 5C [ 7] ';' （59）| 11111011のFB [8] '<'（60）| 11111111 | 1111100 7ffc [15] '='（61）| 100000 20 [6]"
    },
    {
      "indent": 3,
      "text": "'>' ( 62) |11111111|1011 ffb [12] '?' ( 63) |11111111|00 3fc [10] '@' ( 64) |11111111|11010 1ffa [13] 'A' ( 65) |100001 21 [ 6] 'B' ( 66) |1011101 5d [ 7] 'C' ( 67) |1011110 5e [ 7] 'D' ( 68) |1011111 5f [ 7] 'E' ( 69) |1100000 60 [ 7] 'F' ( 70) |1100001 61 [ 7] 'G' ( 71) |1100010 62 [ 7] 'H' ( 72) |1100011 63 [ 7] 'I' ( 73) |1100100 64 [ 7] 'J' ( 74) |1100101 65 [ 7] 'K' ( 75) |1100110 66 [ 7] 'L' ( 76) |1100111 67 [ 7] 'M' ( 77) |1101000 68 [ 7] 'N' ( 78) |1101001 69 [ 7] 'O' ( 79) |1101010 6a [ 7] 'P' ( 80) |1101011 6b [ 7] 'Q' ( 81) |1101100 6c [ 7] 'R' ( 82) |1101101 6d [ 7] 'S' ( 83) |1101110 6e [ 7] 'T' ( 84) |1101111 6f [ 7] 'U' ( 85) |1110000 70 [ 7] 'V' ( 86) |1110001 71 [ 7] 'W' ( 87) |1110010 72 [ 7] 'X' ( 88) |11111100 fc [ 8] 'Y' ( 89) |1110011 73 [ 7] 'Z' ( 90) |11111101 fd [ 8] '[' ( 91) |11111111|11011 1ffb [13] '\\' ( 92) |11111111|11111110|000 7fff0 [19] ']' ( 93) |11111111|11100 1ffc [13] '^' ( 94) |11111111|111100 3ffc [14] '_' ( 95) |100010 22 [ 6] '`' ( 96) |11111111|1111101 7ffd [15] 'a' ( 97) |00011 3 [ 5] 'b' ( 98) |100011 23 [ 6] 'c' ( 99) |00100 4 [ 5] 'd' (100) |100100 24 [ 6] 'e' (101) |00101 5 [ 5] 'f' (102) |100101 25 [ 6] 'g' (103) |100110 26 [ 6] 'h' (104) |100111 27 [ 6] 'i' (105) |00110 6 [ 5] 'j' (106) |1110100 74 [ 7] 'k' (107) |1110101 75 [ 7] 'l' (108) |101000 28 [ 6] 'm' (109) |101001 29 [ 6]",
      "ja": "'>'（62）| 11111111 | 1011 FFB [12] '？' （63）| 11111111 | 00 3FC [10] '@'（64）| 11111111 | 11010 1ffa [13] 'A'（65）| 100001 21 [6] 'B'（66）| 1011101 5D [7] ' C」（67）| 1011110 5E [7] 'D'（68）| 1011111 5F [7] 'E'（69）| 1100000 60 [7] 'F'（70）| 1100001 61 [7] 'G' （71）| 1100010 62 [7] 'H'（72）| 1100011 63 [7] 'I'（73）| 1100100 64 [7] 'J'（74）| 1100101が65 [7] 'K'（75 ）| 1100110 66 [7] 'L'（76）| 1100111 67 [7] 'M'（77）| 1101000 68 [7] 'N'（78）| 1101001 69 [7] 'O'（79）| 1101010 6A [7] 'P'（80）| 1101011 6B [7] 'Q'（81）| 1101100 6C [7] 'R'（82）| 1101101 6D [7] 'S'（83）| 1101110 6E [7] 'T'（84）| 1101111 6F [7] 'U'（85）| 1110000 70 [7] 'V'（86）| 1110001 71 [7]（87） 'W' | 1110010 72 7 ] 'X'（88）| 11111100 FC [8] 'Y'（89）| 1110011 73 [7] 'Z'（90）| 11111101 FD [8] '['（91）| 11111111 | 11011 1ffb [13 ] '\\'（92）| 11111111 | 11111110 | 000 7fff0 [19] ']'（93）| 11111111 | 11100 1ffc [13] '^'（94）| 11111111 | 111100 3ffc [14] '_'（95 ）| 100010 22 [6] '''（96）| 11111111 | 1111101 7ffd [15] ''（97）| 00011 3 [5] 'B'（98）| 100011 23 [6] 'C'（99）| 00100 4 [5] 'D'（100）| 100100 24 [6] 'E'（101）| 00101 5 [ 5] 'F'（102）| 100101 25 [6] 'G'（103）| 100110 26 [6] 'H'（104）| 100111 27 [6] 'I'（105）| 00110 6 [5] 'J'（106）| 1110100 74 [7] 'K'（107）| 1110101 75 [7] 'L'（108）| 101000 28 [6] 'M'（109）| 101001 29 [6]"
    },
    {
      "indent": 3,
      "text": "'n' (110) |101010 2a [ 6] 'o' (111) |00111 7 [ 5] 'p' (112) |101011 2b [ 6] 'q' (113) |1110110 76 [ 7] 'r' (114) |101100 2c [ 6] 's' (115) |01000 8 [ 5] 't' (116) |01001 9 [ 5] 'u' (117) |101101 2d [ 6] 'v' (118) |1110111 77 [ 7] 'w' (119) |1111000 78 [ 7] 'x' (120) |1111001 79 [ 7] 'y' (121) |1111010 7a [ 7] 'z' (122) |1111011 7b [ 7] '{' (123) |11111111|1111110 7ffe [15] '|' (124) |11111111|100 7fc [11] '}' (125) |11111111|111101 3ffd [14] '~' (126) |11111111|11101 1ffd [13] (127) |11111111|11111111|11111111|1100 ffffffc [28] (128) |11111111|11111110|0110 fffe6 [20] (129) |11111111|11111111|010010 3fffd2 [22] (130) |11111111|11111110|0111 fffe7 [20] (131) |11111111|11111110|1000 fffe8 [20] (132) |11111111|11111111|010011 3fffd3 [22] (133) |11111111|11111111|010100 3fffd4 [22] (134) |11111111|11111111|010101 3fffd5 [22] (135) |11111111|11111111|1011001 7fffd9 [23] (136) |11111111|11111111|010110 3fffd6 [22] (137) |11111111|11111111|1011010 7fffda [23] (138) |11111111|11111111|1011011 7fffdb [23] (139) |11111111|11111111|1011100 7fffdc [23] (140) |11111111|11111111|1011101 7fffdd [23] (141) |11111111|11111111|1011110 7fffde [23] (142) |11111111|11111111|11101011 ffffeb [24] (143) |11111111|11111111|1011111 7fffdf [23] (144) |11111111|11111111|11101100 ffffec [24] (145) |11111111|11111111|11101101 ffffed [24] (146) |11111111|11111111|010111 3fffd7 [22] (147) |11111111|11111111|1100000 7fffe0 [23] (148) |11111111|11111111|11101110 ffffee [24] (149) |11111111|11111111|1100001 7fffe1 [23] (150) |11111111|11111111|1100010 7fffe2 [23] (151) |11111111|11111111|1100011 7fffe3 [23] (152) |11111111|11111111|1100100 7fffe4 [23] (153) |11111111|11111110|11100 1fffdc [21] (154) |11111111|11111111|011000 3fffd8 [22] (155) |11111111|11111111|1100101 7fffe5 [23] (156) |11111111|11111111|011001 3fffd9 [22] (157) |11111111|11111111|1100110 7fffe6 [23] (158) |11111111|11111111|1100111 7fffe7 [23] (159) |11111111|11111111|11101111 ffffef [24] (160) |11111111|11111111|011010 3fffda [22] (161) |11111111|11111110|11101 1fffdd [21] (162) |11111111|11111110|1001 fffe9 [20] (163) |11111111|11111111|011011 3fffdb [22] (164) |11111111|11111111|011100 3fffdc [22] (165) |11111111|11111111|1101000 7fffe8 [23] (166) |11111111|11111111|1101001 7fffe9 [23] (167) |11111111|11111110|11110 1fffde [21] (168) |11111111|11111111|1101010 7fffea [23] (169) |11111111|11111111|011101 3fffdd [22] (170) |11111111|11111111|011110 3fffde [22] (171) |11111111|11111111|11110000 fffff0 [24] (172) |11111111|11111110|11111 1fffdf [21] (173) |11111111|11111111|011111 3fffdf [22] (174) |11111111|11111111|1101011 7fffeb [23] (175) |11111111|11111111|1101100 7fffec [23] (176) |11111111|11111111|00000 1fffe0 [21] (177) |11111111|11111111|00001 1fffe1 [21] (178) |11111111|11111111|100000 3fffe0 [22] (179) |11111111|11111111|00010 1fffe2 [21] (180) |11111111|11111111|1101101 7fffed [23] (181) |11111111|11111111|100001 3fffe1 [22] (182) |11111111|11111111|1101110 7fffee [23] (183) |11111111|11111111|1101111 7fffef [23] (184) |11111111|11111110|1010 fffea [20] (185) |11111111|11111111|100010 3fffe2 [22] (186) |11111111|11111111|100011 3fffe3 [22] (187) |11111111|11111111|100100 3fffe4 [22] (188) |11111111|11111111|1110000 7ffff0 [23] (189) |11111111|11111111|100101 3fffe5 [22] (190) |11111111|11111111|100110 3fffe6 [22] (191) |11111111|11111111|1110001 7ffff1 [23] (192) |11111111|11111111|11111000|00 3ffffe0 [26] (193) |11111111|11111111|11111000|01 3ffffe1 [26] (194) |11111111|11111110|1011 fffeb [20] (195) |11111111|11111110|001 7fff1 [19] (196) |11111111|11111111|100111 3fffe7 [22] (197) |11111111|11111111|1110010 7ffff2 [23] (198) |11111111|11111111|101000 3fffe8 [22] (199) |11111111|11111111|11110110|0 1ffffec [25] (200) |11111111|11111111|11111000|10 3ffffe2 [26] (201) |11111111|11111111|11111000|11 3ffffe3 [26] (202) |11111111|11111111|11111001|00 3ffffe4 [26] (203) |11111111|11111111|11111011|110 7ffffde [27] (204) |11111111|11111111|11111011|111 7ffffdf [27] (205) |11111111|11111111|11111001|01 3ffffe5 [26] (206) |11111111|11111111|11110001 fffff1 [24] (207) |11111111|11111111|11110110|1 1ffffed [25] (208) |11111111|11111110|010 7fff2 [19] (209) |11111111|11111111|00011 1fffe3 [21] (210) |11111111|11111111|11111001|10 3ffffe6 [26] (211) |11111111|11111111|11111100|000 7ffffe0 [27] (212) |11111111|11111111|11111100|001 7ffffe1 [27] (213) |11111111|11111111|11111001|11 3ffffe7 [26] (214) |11111111|11111111|11111100|010 7ffffe2 [27] (215) |11111111|11111111|11110010 fffff2 [24] (216) |11111111|11111111|00100 1fffe4 [21] (217) |11111111|11111111|00101 1fffe5 [21] (218) |11111111|11111111|11111010|00 3ffffe8 [26] (219) |11111111|11111111|11111010|01 3ffffe9 [26] (220) |11111111|11111111|11111111|1101 ffffffd [28] (221) |11111111|11111111|11111100|011 7ffffe3 [27] (222) |11111111|11111111|11111100|100 7ffffe4 [27] (223) |11111111|11111111|11111100|101 7ffffe5 [27] (224) |11111111|11111110|1100 fffec [20] (225) |11111111|11111111|11110011 fffff3 [24] (226) |11111111|11111110|1101 fffed [20] (227) |11111111|11111111|00110 1fffe6 [21] (228) |11111111|11111111|101001 3fffe9 [22] (229) |11111111|11111111|00111 1fffe7 [21] (230) |11111111|11111111|01000 1fffe8 [21] (231) |11111111|11111111|1110011 7ffff3 [23] (232) |11111111|11111111|101010 3fffea [22] (233) |11111111|11111111|101011 3fffeb [22] (234) |11111111|11111111|11110111|0 1ffffee [25] (235) |11111111|11111111|11110111|1 1ffffef [25] (236) |11111111|11111111|11110100 fffff4 [24] (237) |11111111|11111111|11110101 fffff5 [24] (238) |11111111|11111111|11111010|10 3ffffea [26] (239) |11111111|11111111|1110100 7ffff4 [23] (240) |11111111|11111111|11111010|11 3ffffeb [26] (241) |11111111|11111111|11111100|110 7ffffe6 [27] (242) |11111111|11111111|11111011|00 3ffffec [26] (243) |11111111|11111111|11111011|01 3ffffed [26] (244) |11111111|11111111|11111100|111 7ffffe7 [27] (245) |11111111|11111111|11111101|000 7ffffe8 [27] (246) |11111111|11111111|11111101|001 7ffffe9 [27] (247) |11111111|11111111|11111101|010 7ffffea [27] (248) |11111111|11111111|11111101|011 7ffffeb [27] (249) |11111111|11111111|11111111|1110 ffffffe [28] (250) |11111111|11111111|11111101|100 7ffffec [27] (251) |11111111|11111111|11111101|101 7ffffed [27] (252) |11111111|11111111|11111101|110 7ffffee [27] (253) |11111111|11111111|11111101|111 7ffffef [27] (254) |11111111|11111111|11111110|000 7fffff0 [27] (255) |11111111|11111111|11111011|10 3ffffee [26] EOS (256) |11111111|11111111|11111111|111111 3fffffff [30]",
      "ja": "'N'（110）| 101010 2A [6] 'O'（111）| 00111 7 [5] 'P'（112）| 101011 2B [6] 'Q'（113）| 1110110 76 [7] R」 '（114）| 101100 2C [6] 'S'（115）| 01000 8 [5] 'T'（116）| 01001 9 [5] 'U'（117）| 101101 2D [6] 'V'（ 118）| 1110111 77 [7] 'W'（119）| 1111000 78 [7] 'X'（120）| 1111001 79 [7] 'Y'（121）| 1111010 7A [7] 'Z'（122） | 1111011 7B [7] '{'（123）| 11111111 | 1111110 7ffe [15] '|' （124）| 11111111 | 100 7FC [11] '}'（125）| 11111111 | 111101 3ffd [14] '〜'（126）| 11111111 | 11101 1ffd [13]（127）| 11111111 | 11111111 | 11111111 | 1100 ffffffc [28]（128）| 11111111 | 11111110 | 0110 fffe6 [20]（129）| 11111111 | 11111111 | 010010 3fffd2 [22]（130）| 11111111 | 11111110 | 0111 fffe7 [20]（131）| 11111111 | 11111110 | 1000年fffe8 [20]（132）| 11111111 | 11111111 | 010011 3fffd3 [22]（133）| 11111111 | 11111111 | 010100 3fffd4 [22]（134）| 11111111 | 11111111 | 010101 3fffd5 [22]（135）| 11111111 | 11111111 | 1011001 7fffd9 [23]（136）| 11111111 | 11111111 | 010110 3fffd6 [22]（137）| 11111111 | 11111111 | 1011010 7fffda [23]（138）| 11111111 | 11111111 | 1011011 7fffdb [23]（139） | 11111111 | 11111111 | 1011100 7fffdc [23]（140）| 11111111 | 11111111 | 1011101 7fffdd [23]（141）| 11111111 | 11111111 | 1011110 7fffde [23]（142）| 11111111 | 11111111 | 11101011 ffffeb [24]（ 143）| 11111111 | 11111111 | 1011111 7fffdf [23]（144）| 11111111 | 11111111 | 11101100 ffffec [24]（145）| 11111111 | 11111111 | 11101101 ffffed [24]（146）| 11111111 | 11111111 | 010111 3fffd7 [22 ]（147） | 11111111 | 11111111 | 1100000 7fffe0 [23]（148）| 11111111 | 11111111 | 11101110 ffffee [24]（149）| 11111111 | 11111111 | 1100001 7fffe1 [23]（150）| 11111111 | 11111111 | 1100010 7fffe2 [23]（ 151）| 11111111 | 11111111 | 1100011 7fffe3 [23]（152）| 11111111 | 11111111 | 1100100 7fffe4 [23]（153）| 11111111 | 11111110 | 11100 1fffdc [21]（154）| 11111111 | 11111111 | 011000 3fffd8 [22 （155）| 11111111 | 11111111 | 1100101 7fffe5 [23]（156）| 11111111 | 11111111 | 011001 3fffd9 [22]（157）| 11111111 | 11111111 | 1100110 7fffe6 [23]（158）| 11111111 | 11111111 | 1100111 7fffe7 [23]（159）| 11111111 | 11111111 | 11101111 ffffef [24]（160）| 11111111 | 11111111 | 011010 3fffda [22]（161）| 11111111 | 11111110 | 11101 1fffdd [21]（162）| 11111111 | 11111110 | 1001 fffe9 [20]（163）| 11111111 | 11111111 | 011011 3fffdb [22]（164）| 11111111 | 11111111 | 011100 3fffdc [22]（165）| 11111111 | 11111111 | 1101000 7fffe8 [23]（166）| 11111111 | 11111111 | 1101001 7fffe9 [23]（167）| 11111111 | 11111110 | 11110 1fffde [21]（168）| 11111111 | 11111111 | 1101010 7fffea [23]（169）| 11111111 | 11111111 | 0111 01 3fffdd [22]（170）| 11111111 | 11111111 | 011110 3fffde [22]（171）| 11111111 | 11111111 | 11110000 fffff0 [24]（172）| 11111111 | 11111110 | 11111 1fffdf [21]（173）| 11111111 | 11111111 | 011111 3fffdf [22]（174）| 11111111 | 11111111 | 1101011 7fffeb [23]（175）| 11111111 | 11111111 | 1101100 7fffec [23]（176）| 11111111 | 11111111 | 00000 1fffe0 [21]（177）| 11111111 | 11111111 | 00001 1fffe1 [21]（178）| 11111111 | 11111111 | 100000 3fffe0 [22]（179）| 11111111 | 11111111 | 00010 1fffe2 [21]（180）| 11111111 | 11111111 | 1101101 7fffed [23]（181 ）| 11111111 | 11111111 | 100001 3fffe1 [22]（182）| 11111111 | 11111111 | 1101110 7fffee [23]（183）| 11111111 | 11111111 | 1101111 7fffef [23]（184）| 11111111 | 11111110 | 1010 fffea [20] （185）| 11111111 | 11111111 | 100010 3fffe2 [22]（186）| 11111111 | 11111111 | 100011 3fffe3 [22]（187）| 11111111 | 11111111 | 100100 3fffe4 [22]（188）| 11111111 | 11111111 | 1110000 7ffff0 [ 23（189）| 11111111 | 11111111 | 100101 3fffe5 [22]（190）| 11111111 | 11111111 | 100110 3fffe6 [22]（191）| 11111111 | 11111111 | 1110001 7ffff1 [23]（192）| 11111111 | 11111111 | 11111000 | 00 3ffffe0 [26]（193）| 11111111 | 11111111 | 11111000 | 01 3ffffe1 [26]（194）| 11111111 | 11111110 | 1011 fffeb [20]（195）| 11111111 | 11111110 | 001 7fff1 [19 （196）| 11111111 | 11111111 | 100111 3fffe7 [22]（197）| 11111111 | 11111111 | 1110010 7ffff2 [23]（198）| 11111111 | 11111111 | 101000 3fffe8 [22]（199）| 11111111 | 11111111 | 11110110 | 0 1ffffec [25]（200）| 11111111 | 11111111 | 11111000 | 10 3ffffe2 [26]（201）| 11111111 | 11111111 | 11111000 | 11 3ffffe3 [26]（202）| 11111111 | 11111111 | 11111001 | 00 3ffffe4 [26] （203）| 11111111 | 11111111 | 11111011 | 110 7ffffde [27]（204）| 11111111 | 11111111 | 11111011 | 111 7ffffdf [27]（205）| 11111111 | 11111111 | 11111001 | 01 3ffffe5 [26]（206）| 11111111 | 11111111 | 11110001 fffff1 [24]（207）| 11111111 | 11111111 | 11110110 | 1 1ffffed [25]（208）| 11111111 | 11111110 | 010 7fff2 [19]（209）| 11111111 | 11111111 | 00011 1fffe3 [21]（ 210）| 11111111 | 11111111 | 11111001 | 10 3ffffe6 [26]（211）| 11111111 | 11111111 | 11111100 | 000 7ffffe0 [27]（212）| 11111111 | 11111111 | 11111100 | 001 7ffffe1 [27]（213）| 11111111 | 1111 1111 | 11111001 | 11 3ffffe7 [26]（214）| 11111111 | 11111111 | 11111100 | 010 7ffffe2 [27]（215）| 11111111 | 11111111 | 11110010 fffff2 [24]（216）| 11111111 | 11111111 | 00100 1fffe4 [21] （217）| 11111111 | 11111111 | 00101 1fffe5 [21]（218）| 11111111 | 11111111 | 11111010 | 00 3ffffe8 [26]（219）| 11111111 | 11111111 | 11111010 | 01 3ffffe9 [26]（220）| 11111111 | 11111111 | 11111111 | 1101 ffffffd [28]（221）| 11111111 | 11111111 | 11111100 | 011 7ffffe3 [27]（222）| 11111111 | 11111111 | 11111100 | 100 7ffffe4 [27]（223）| 11111111 | 11111111 | 11111100 | 101 7ffffe5 [27]（224）| 11111111 | 11111110 | 1100 fffec [20]（225）| 11111111 | 11111111 | 11110011 fffff3 [24]（226）| 11111111 | 11111110 | 1101 fffed [20]（227）| 11111111 | 11111111 | 00110 1fffe6 [21]（228）| 11111111 | 11111111 | 101001 3fffe9 [22]（229）| 11111111 | 11111111 | 00111 1fffe7 [21]（230）| 11111111 | 11111111 | 01000 1fffe8 [21]（231）| 11111111 | 11111111 | 1110011 7ffff3 [23]（232）| 11111111 | 11111111 | 101010 3fffea [22]（233）| 11111111 | 11111111 | 101011 3fffeb [22]（234）| 11111111 | 11111111 | 11110111 | 0 1ffffee [25] （235）| 11111111 | 11111111 | 11110111 | 1 1ffffef [25]（236）| 11111111 | 11111111 | 11110100 fffff4 [24]（237）| 11111111 | 11111111 | 11110101 fffff5 [24]（238）| 11111111 | 11111111 | 11111010 | 10 3ffffea [26]（239）| 11111111 | 11111111 | 1110100 7ffff4 [23]（240）| 11111111 | 11111111 | 11111010 | 11 3ffffeb [26]（241）| 11111111 | 11111111 | 11111100 | 110 7ffffe6 [27]（ 242）| 11111111 | 11111111 | 11111011 | 00 3ffffec [26]（243）| 11111111 | 11111111 | 11111011 | 01 3ffffed [26]（244）| 11111111 | 11111111 | 11111100 | 111 7ffffe7 [27]（245）| 11111111 | 11111111 | 11111101 | 000 7ffffe8 [27]（246）| 11111111 | 11111111 | 11111101 | 001 7ffffe9 [27]（247）| 11111111 | 11111111 | 11111101 | 010 7ffffea [27]（248）| 11111111 | 11111111 | 11111101 | 011 7ffffeb [27]（249）| 11111111 | 11111111 | 11111111 | 1110 ffffffe [28]（250）| 11111111 | 11111111 | 11111101 | 100 7ffffec [27]（251）| 11111111 | 11111111 | 11111101 | 101 7ffffed [27]（ 252）| 11111111 | 11111111 | 11111101 | 110 7ffffee [27]（253）| 11111111 | 11111111 | 11111101 | 111 7ffffef [27]（254）| 11111111 | 11111111 | 11111110 | 000 7fffff0 [27] （255）| 11111111 | 11111111 | 11111011 | 10 3ffffee [26] EOS（256）| 11111111 | 11111111 | 11111111 | 111111〜3FFFFFFF [30]"
    },
    {
      "indent": 0,
      "text": "Appendix C. Examples",
      "ja": "付録C.例"
    },
    {
      "indent": 3,
      "text": "This appendix contains examples covering integer encoding, header field representation, and the encoding of whole lists of header fields for both requests and responses, with and without Huffman coding.",
      "ja": "この付録では、とし、ハフマン符号化することなく、整数符号化、ヘッダフィールドの表現、及び要求と応答の両方のためのヘッダフィールドの全体リストのエンコーディングをカバーする例を示します。"
    },
    {
      "indent": 0,
      "text": "C.1. Integer Representation Examples",
      "ja": "C.1。整数表現の例"
    },
    {
      "indent": 3,
      "text": "This section shows the representation of integer values in detail (see Section 5.1).",
      "ja": "このセクションでは、詳細に整数値の表現を示す図である（5.1節を参照）。"
    },
    {
      "indent": 0,
      "text": "C.1.1. Example 1: Encoding 10 Using a 5-Bit Prefix",
      "ja": "C.1.1。実施例1：5ビットのプレフィックスを使用して10をコードします"
    },
    {
      "indent": 3,
      "text": "The value 10 is to be encoded with a 5-bit prefix.",
      "ja": "値10は、5ビットのプレフィックスを用いて符号化されるべきです。"
    },
    {
      "indent": 3,
      "text": "o 10 is less than 31 (2^5 - 1) and is represented using the 5-bit prefix.",
      "ja": "10 O未満、31（2 ^ 5 1  - ）であり、5ビットのプレフィックスを使用して表されます。"
    },
    {
      "indent": 3,
      "text": "  0   1   2   3   4   5   6   7\n+---+---+---+---+---+---+---+---+\n| X | X | X | 0 | 1 | 0 | 1 | 0 |   10 stored on 5 bits\n+---+---+---+---+---+---+---+---+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "C.1.2. Example 2: Encoding 1337 Using a 5-Bit Prefix",
      "ja": "C.1.2。実施例2：5ビットのプレフィックスを用いた符号化1337"
    },
    {
      "indent": 3,
      "text": "The value I=1337 is to be encoded with a 5-bit prefix.",
      "ja": "値I = 1337は、5ビットのプレフィックスを用いて符号化されるべきです。"
    },
    {
      "indent": 6,
      "text": "1337 is greater than 31 (2^5 - 1).",
      "ja": "1337 31（1  -  2 ^ 5）よりも大きいです。"
    },
    {
      "indent": 9,
      "text": "The 5-bit prefix is filled with its max value (31).",
      "ja": "5ビットのプレフィックスは、その最大値（31）が充填されています。"
    },
    {
      "indent": 6,
      "text": "I = 1337 - (2^5 - 1) = 1306.",
      "ja": "I = 1337  -  1306 =  - （1 2 ^ 5）。"
    },
    {
      "indent": 9,
      "text": "I (1306) is greater than or equal to 128, so the while loop body executes:",
      "ja": "I（1306）128以上であるので、whileループ本体は実行されます。"
    },
    {
      "indent": 12,
      "text": "I % 128 == 26",
      "ja": "I％128 == 26"
    },
    {
      "indent": 12,
      "text": "26 + 128 == 154",
      "ja": "２６ ＋ １２８ ＝＝ １５４"
    },
    {
      "indent": 12,
      "text": "154 is encoded in 8 bits as: 10011010",
      "ja": "10011010：154のように8ビットで符号化されます"
    },
    {
      "indent": 12,
      "text": "I is set to 10 (1306 / 128 == 10)",
      "ja": "Iが10に設定されている（128分の1306 == 10）"
    },
    {
      "indent": 12,
      "text": "I is no longer greater than or equal to 128, so the while loop terminates.",
      "ja": "whileループが終了するので、私は、もはや128以上ではありません。"
    },
    {
      "indent": 9,
      "text": "I, now 10, is encoded in 8 bits as: 00001010.",
      "ja": "00001010：私は今10として8ビットで符号化されます。"
    },
    {
      "indent": 6,
      "text": "The process ends.",
      "ja": "処理は終了します。"
    },
    {
      "indent": 3,
      "text": "  0   1   2   3   4   5   6   7\n+---+---+---+---+---+---+---+---+\n| X | X | X | 1 | 1 | 1 | 1 | 1 |  Prefix = 31, I = 1306\n| 1 | 0 | 0 | 1 | 1 | 0 | 1 | 0 |  1306>=128, encode(154), I=1306/128\n| 0 | 0 | 0 | 0 | 1 | 0 | 1 | 0 |  10<128, encode(10), done\n+---+---+---+---+---+---+---+---+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "C.1.3. Example 3: Encoding 42 Starting at an Octet Boundary",
      "ja": "C.1.3。例3：オクテット境界で開始する42のエンコーディング"
    },
    {
      "indent": 3,
      "text": "The value 42 is to be encoded starting at an octet boundary. This implies that a 8-bit prefix is used.",
      "ja": "値42は、オクテットの境界で始まる符号化されます。これは8ビットのプレフィックスが使用されていることを意味します。"
    },
    {
      "indent": 3,
      "text": "o 42 is less than 255 (2^8 - 1) and is represented using the 8-bit prefix.",
      "ja": "O 42未満255（^ 8 1  -  2）であり、8ビットのプレフィックスを使用して表されます。"
    },
    {
      "indent": 3,
      "text": "  0   1   2   3   4   5   6   7\n+---+---+---+---+---+---+---+---+\n| 0 | 0 | 1 | 0 | 1 | 0 | 1 | 0 |   42 stored on 8 bits\n+---+---+---+---+---+---+---+---+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "C.2. Header Field Representation Examples",
      "ja": "C.2。ヘッダーフィールド表現の例"
    },
    {
      "indent": 3,
      "text": "This section shows several independent representation examples.",
      "ja": "このセクションでは、いくつかの独立した表現の例を示します。"
    },
    {
      "indent": 0,
      "text": "C.2.1. Literal Header Field with Indexing",
      "ja": "C.2.1。インデックス付きリテラルヘッダーフィールド"
    },
    {
      "indent": 3,
      "text": "The header field representation uses a literal name and a literal value. The header field is added to the dynamic table.",
      "ja": "ヘッダフィールドの表現は、文字名とリテラル値を使用します。ヘッダフィールドは、動的テーブルに追加されます。"
    },
    {
      "indent": 3,
      "text": "Header list to encode:",
      "ja": "エンコードのヘッダーリスト："
    },
    {
      "indent": 3,
      "text": "custom-key: custom-header",
      "ja": "カスタムキー：カスタムヘッダー"
    },
    {
      "indent": 3,
      "text": "Hex dump of encoded data:",
      "ja": "符号化データの進ダンプ："
    },
    {
      "indent": 3,
      "text": "400a 6375 7374 6f6d 2d6b 6579 0d63 7573 | @.custom-key.cus 746f 6d2d 6865 6164 6572 | tom-header",
      "ja": "400A 6375 7374 6f6d 2d6b 0d63 7573 6579 | @ .custom-key.cus 746f 6d2d 6164 6572 6865 |トム・ヘッダ"
    },
    {
      "indent": 3,
      "text": "Decoding process:",
      "ja": "復号化処理："
    },
    {
      "indent": 3,
      "text": "40 | == Literal indexed == 0a | Literal name (len = 10) 6375 7374 6f6d 2d6b 6579 | custom-key 0d | Literal value (len = 13) 6375 7374 6f6d 2d68 6561 6465 72 | custom-header | -> custom-key: | custom-header",
      "ja": "40 | ==リテラルがインデックス== 0A |リテラル名（LEN = 10）6f6d 2d6b 6579 7374 6375 |カスタムキー0D |リテラル値（LEN = 13）6375 7374 6f6dの2d68 6561 6465 72 |カスタムヘッダー| - >カスタムキー：|カスタムヘッダー"
    },
    {
      "indent": 3,
      "text": "Dynamic Table (after decoding):",
      "ja": "（復号後）動的テーブル："
    },
    {
      "indent": 3,
      "text": "[ 1] (s = 55) custom-key: custom-header Table size: 55",
      "ja": "[1]（S = 55）カスタムキー：カスタム・ヘッダ・テーブル・サイズ：55"
    },
    {
      "indent": 3,
      "text": "Decoded header list:",
      "ja": "デコードされたヘッダリスト："
    },
    {
      "indent": 3,
      "text": "custom-key: custom-header",
      "ja": "カスタムキー：カスタムヘッダー"
    },
    {
      "indent": 0,
      "text": "C.2.2. Literal Header Field without Indexing",
      "ja": "C.2.2。リテラルヘッダーフィールドインデックスなし"
    },
    {
      "indent": 3,
      "text": "The header field representation uses an indexed name and a literal value. The header field is not added to the dynamic table.",
      "ja": "ヘッダフィールドの表現は、インデックス付きの名前とリテラル値を使用します。ヘッダフィールドは、動的テーブルに追加されません。"
    },
    {
      "indent": 3,
      "text": "Header list to encode:",
      "ja": "エンコードのヘッダーリスト："
    },
    {
      "indent": 3,
      "text": ":path: /sample/path",
      "ja": "：パス：/サンプル/パス"
    },
    {
      "indent": 3,
      "text": "Hex dump of encoded data:",
      "ja": "符号化データの進ダンプ："
    },
    {
      "indent": 3,
      "text": "040c 2f73 616d 706c 652f 7061 7468 | ../sample/path",
      "ja": "040C 2f73 616D 706C 7061 7468 652f | ../sample/path"
    },
    {
      "indent": 3,
      "text": "Decoding process:",
      "ja": "復号化処理："
    },
    {
      "indent": 3,
      "text": "04 | == Literal not indexed == | Indexed name (idx = 4) | :path 0c | Literal value (len = 12) 2f73 616d 706c 652f 7061 7468 | /sample/path | -> :path: /sample/path",
      "ja": "04 | ==リテラル索引付けされていない== |インデックス付きの名前（IDX = 4）| ：パス0C |リテラル値（LEN = 12）2f73 616D 706C 652f 7061 7468 | /サンプル/パス| - >：パス：/サンプル/パス"
    },
    {
      "indent": 3,
      "text": "Dynamic table (after decoding): empty.",
      "ja": "（デコード後）動的テーブル：空。"
    },
    {
      "indent": 3,
      "text": "Decoded header list:",
      "ja": "デコードされたヘッダリスト："
    },
    {
      "indent": 3,
      "text": ":path: /sample/path",
      "ja": "：パス：/サンプル/パス"
    },
    {
      "indent": 0,
      "text": "C.2.3. Literal Header Field Never Indexed",
      "ja": "C.2.3。リテラルヘッダーフィールドネヴァー・インデックス"
    },
    {
      "indent": 3,
      "text": "The header field representation uses a literal name and a literal value. The header field is not added to the dynamic table and must use the same representation if re-encoded by an intermediary.",
      "ja": "ヘッダフィールドの表現は、文字名とリテラル値を使用します。ヘッダフィールドは、動的テーブルに追加されず、中間によって再符号化された場合に同じ表現を使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Header list to encode:",
      "ja": "エンコードのヘッダーリスト："
    },
    {
      "indent": 3,
      "text": "password: secret",
      "ja": "パスワード：秘密"
    },
    {
      "indent": 3,
      "text": "Hex dump of encoded data:",
      "ja": "符号化データの進ダンプ："
    },
    {
      "indent": 3,
      "text": "1008 7061 7373 776f 7264 0673 6563 7265 | ..password.secre 74 | t",
      "ja": "7264 0673 6563 7265 1008 7061 7373 776f | ..password.secre 74 |トン"
    },
    {
      "indent": 3,
      "text": "Decoding process:",
      "ja": "復号化処理："
    },
    {
      "indent": 3,
      "text": "10 | == Literal never indexed == 08 | Literal name (len = 8) 7061 7373 776f 7264 | password 06 | Literal value (len = 6) 7365 6372 6574 | secret | -> password: secret",
      "ja": "10 | ==リテラルがインデックスされません== 08 |リテラル名（LEN = 8）7061 776f 7264 7373 |パスワード06 | （LEN = 6）リテラル値7365 6372 6574 |秘密| - >パスワード：秘密"
    },
    {
      "indent": 3,
      "text": "Dynamic table (after decoding): empty.",
      "ja": "（デコード後）動的テーブル：空。"
    },
    {
      "indent": 3,
      "text": "Decoded header list:",
      "ja": "デコードされたヘッダリスト："
    },
    {
      "indent": 3,
      "text": "password: secret",
      "ja": "パスワード：秘密"
    },
    {
      "indent": 0,
      "text": "C.2.4. Indexed Header Field",
      "ja": "C.2.4。インデックス付きヘッダーフィールド"
    },
    {
      "indent": 3,
      "text": "The header field representation uses an indexed header field from the static table.",
      "ja": "ヘッダフィールドの表現は、静的テーブルからインデックス付けヘッダフィールドを使用します。"
    },
    {
      "indent": 3,
      "text": "Header list to encode:",
      "ja": "エンコードのヘッダーリスト："
    },
    {
      "indent": 3,
      "text": ":method: GET",
      "ja": "：メソッド：GET"
    },
    {
      "indent": 3,
      "text": "Hex dump of encoded data:",
      "ja": "符号化データの進ダンプ："
    },
    {
      "indent": 3,
      "text": "82 | .",
      "ja": "８２ ｜ 。"
    },
    {
      "indent": 3,
      "text": "Decoding process:",
      "ja": "復号化処理："
    },
    {
      "indent": 3,
      "text": "82 | == Indexed - Add == | idx = 2 | -> :method: GET",
      "ja": "82 | ==インデックス付き -  ==追加| IDX = 2 | - >：メソッド：GET"
    },
    {
      "indent": 3,
      "text": "Dynamic table (after decoding): empty.",
      "ja": "（デコード後）動的テーブル：空。"
    },
    {
      "indent": 3,
      "text": "Decoded header list:",
      "ja": "デコードされたヘッダリスト："
    },
    {
      "indent": 3,
      "text": ":method: GET",
      "ja": "：メソッド：GET"
    },
    {
      "indent": 0,
      "text": "C.3. Request Examples without Huffman Coding",
      "ja": "C.3。ハフマン符号化せずに例をリクエスト"
    },
    {
      "indent": 3,
      "text": "This section shows several consecutive header lists, corresponding to HTTP requests, on the same connection.",
      "ja": "このセクションでは、同じ接続上で、HTTPリクエストに対応し、いくつかの連続するヘッダリストを示しています。"
    },
    {
      "indent": 0,
      "text": "C.3.1. First Request",
      "ja": "C.3.1。最初のリクエスト"
    },
    {
      "indent": 3,
      "text": "Header list to encode:",
      "ja": "エンコードのヘッダーリスト："
    },
    {
      "indent": 3,
      "text": ":method: GET :scheme: http :path: / :authority: www.example.com",
      "ja": "：メソッド：GET：スキームます：http：パス：/：権限：www.example.com"
    },
    {
      "indent": 3,
      "text": "Hex dump of encoded data:",
      "ja": "符号化データの進ダンプ："
    },
    {
      "indent": 3,
      "text": "8286 8441 0f77 7777 2e65 7861 6d70 6c65 | ...A.www.example 2e63 6f6d | .com",
      "ja": "8441 0f77 7777 8286 2e65 7861 6d70 6c65 | ... 2e63 6f6d A.www.example | .COM"
    },
    {
      "indent": 3,
      "text": "Decoding process:",
      "ja": "復号化処理："
    },
    {
      "indent": 3,
      "text": "82 | == Indexed - Add == | idx = 2 | -> :method: GET 86 | == Indexed - Add == | idx = 6 | -> :scheme: http 84 | == Indexed - Add == | idx = 4 | -> :path: / 41 | == Literal indexed == | Indexed name (idx = 1) | :authority 0f | Literal value (len = 15) 7777 772e 6578 616d 706c 652e 636f 6d | www.example.com | -> :authority: | www.example.com",
      "ja": "82 | ==インデックス付き -  ==追加| IDX = 2 | - >：メソッド：86をGET | ==インデックス付き -  ==追加| IDX = 6 | - >：スキーム：HTTP 84 | ==インデックス付き -  ==追加| IDX = 4 | - >：パス：/ 41 | ==リテラルをインデックス== |インデックス付きの名前（IDX = 1）| ：権限0F |リテラル値（LEN = 15）7777 772e 6578 616D 706C 652e 636f 6D | www.example.com | - >：権限：| www.example.com"
    },
    {
      "indent": 3,
      "text": "Dynamic Table (after decoding):",
      "ja": "（復号後）動的テーブル："
    },
    {
      "indent": 3,
      "text": "[ 1] (s = 57) :authority: www.example.com Table size: 57",
      "ja": "[1]（S = 57）：権限：www.example.comテーブルサイズ：57"
    },
    {
      "indent": 3,
      "text": "Decoded header list:",
      "ja": "デコードされたヘッダリスト："
    },
    {
      "indent": 3,
      "text": ":method: GET :scheme: http :path: / :authority: www.example.com",
      "ja": "：メソッド：GET：スキームます：http：パス：/：権限：www.example.com"
    },
    {
      "indent": 0,
      "text": "C.3.2. Second Request",
      "ja": "C.3.2。二つ目の要求"
    },
    {
      "indent": 3,
      "text": "Header list to encode:",
      "ja": "エンコードのヘッダーリスト："
    },
    {
      "indent": 3,
      "text": ":method: GET :scheme: http :path: / :authority: www.example.com cache-control: no-cache",
      "ja": "：メソッド：GETません：スキームます：http：パス：/：権限：www.example.comキャッシュ制御：なし - キャッシュ"
    },
    {
      "indent": 3,
      "text": "Hex dump of encoded data:",
      "ja": "符号化データの進ダンプ："
    },
    {
      "indent": 3,
      "text": "8286 84be 5808 6e6f 2d63 6163 6865 | ....X.no-cache",
      "ja": "6865 6e6fの2d63 6163 84be 5808 8286 | .... X.noキャッシュ"
    },
    {
      "indent": 3,
      "text": "Decoding process:",
      "ja": "復号化処理："
    },
    {
      "indent": 3,
      "text": "82 | == Indexed - Add == | idx = 2 | -> :method: GET 86 | == Indexed - Add == | idx = 6 | -> :scheme: http 84 | == Indexed - Add == | idx = 4 | -> :path: / be | == Indexed - Add == | idx = 62 | -> :authority: | www.example.com 58 | == Literal indexed == | Indexed name (idx = 24) | cache-control 08 | Literal value (len = 8) 6e6f 2d63 6163 6865 | no-cache | -> cache-control: no-cache",
      "ja": "82 | ==インデックス付き -  ==追加| IDX = 2 | - >：メソッド：86をGET | ==インデックス付き -  ==追加| IDX = 6 | - >：スキーム：HTTP 84 | ==インデックス付き -  ==追加| IDX = 4 | - >：パス：/ BE | ==インデックス付き -  ==追加| IDX = 62 | - >：権限：| www.example.com 58 | ==リテラルをインデックス== |インデックス付きの名前（IDX = 24）|キャッシュ制御08 |リテラル値（LEN = 8）6e6f 2d63 6163 6865 |キャッシュなし| - >キャッシュコントロール：キャッシュなし"
    },
    {
      "indent": 3,
      "text": "Dynamic Table (after decoding):",
      "ja": "（復号後）動的テーブル："
    },
    {
      "indent": 3,
      "text": "[ 1] (s = 53) cache-control: no-cache [ 2] (s = 57) :authority: www.example.com Table size: 110",
      "ja": "[1]（S = 53）キャッシュ制御：ノーキャッシュ[2]（S = 57）：権限：www.example.comテーブルサイズ：110"
    },
    {
      "indent": 3,
      "text": "Decoded header list:",
      "ja": "デコードされたヘッダリスト："
    },
    {
      "indent": 3,
      "text": ":method: GET :scheme: http :path: / :authority: www.example.com cache-control: no-cache",
      "ja": "：メソッド：GETません：スキームます：http：パス：/：権限：www.example.comキャッシュ制御：なし - キャッシュ"
    },
    {
      "indent": 0,
      "text": "C.3.3. Third Request",
      "ja": "C.3.3。第三のリクエスト"
    },
    {
      "indent": 3,
      "text": "Header list to encode:",
      "ja": "エンコードのヘッダーリスト："
    },
    {
      "indent": 3,
      "text": ":method: GET :scheme: https :path: /index.html :authority: www.example.com custom-key: custom-value",
      "ja": "：メソッド：GET：スキームます。https：パス：/index.htmlが：権限：www.example.comカスタムキー：カスタム値"
    },
    {
      "indent": 3,
      "text": "Hex dump of encoded data:",
      "ja": "符号化データの進ダンプ："
    },
    {
      "indent": 3,
      "text": "8287 85bf 400a 6375 7374 6f6d 2d6b 6579 | ....@.custom-key 0c63 7573 746f 6d2d 7661 6c75 65 | .custom-value",
      "ja": "6f6d 2d6b 6579 85bf 400A 6375 7374 8287 | 。.... @カスタムキー0c63 7573 746f 6d2d 7661 6c75 65 | .custom値"
    },
    {
      "indent": 3,
      "text": "Decoding process:",
      "ja": "復号化処理："
    },
    {
      "indent": 3,
      "text": "82 | == Indexed - Add == | idx = 2 | -> :method: GET 87 | == Indexed - Add == | idx = 7 | -> :scheme: https 85 | == Indexed - Add == | idx = 5 | -> :path: /index.html bf | == Indexed - Add == | idx = 63 | -> :authority: | www.example.com 40 | == Literal indexed == 0a | Literal name (len = 10) 6375 7374 6f6d 2d6b 6579 | custom-key 0c | Literal value (len = 12) 6375 7374 6f6d 2d76 616c 7565 | custom-value | -> custom-key: | custom-value",
      "ja": "82 | ==インデックス付き -  ==追加| IDX = 2 | - >：メソッド：87をGET | ==インデックス付き -  ==追加| IDX = 7 | - >：スキーム：httpsの85 | ==インデックス付き -  ==追加| IDX = 5 | - >：パス：/index.htmlがBF | ==インデックス付き -  ==追加| IDX = 63 | - >：権限：| www.example.com 40 | ==リテラルがインデックス== 0A |リテラル名（LEN = 10）6f6d 2d6b 6579 7374 6375 |カスタムキー0C |リテラル値（LEN = 12）6375 7374 6f6dの2d76の616C 7565 |カスタム値| - >カスタムキー：|カスタム値"
    },
    {
      "indent": 3,
      "text": "Dynamic Table (after decoding):",
      "ja": "（復号後）動的テーブル："
    },
    {
      "indent": 3,
      "text": "[ 1] (s = 54) custom-key: custom-value [ 2] (s = 53) cache-control: no-cache [ 3] (s = 57) :authority: www.example.com Table size: 164",
      "ja": "[1]（S = 54）カスタムキー：カスタム値[2]（S = 53）キャッシュ制御：ノーキャッシュ[3]（S = 57）：権限：www.example.comテーブルサイズ：164"
    },
    {
      "indent": 3,
      "text": "Decoded header list:",
      "ja": "デコードされたヘッダリスト："
    },
    {
      "indent": 3,
      "text": ":method: GET :scheme: https :path: /index.html :authority: www.example.com custom-key: custom-value",
      "ja": "：メソッド：GET：スキームます。https：パス：/index.htmlが：権限：www.example.comカスタムキー：カスタム値"
    },
    {
      "indent": 0,
      "text": "C.4. Request Examples with Huffman Coding",
      "ja": "C.4。ハフマン符号化と要求の例"
    },
    {
      "indent": 3,
      "text": "This section shows the same examples as the previous section but uses Huffman encoding for the literal values.",
      "ja": "このセクションでは、前のセクションと同じ例を示しているが、リテラル値に対してハフマン符号化を使用します。"
    },
    {
      "indent": 0,
      "text": "C.4.1. First Request",
      "ja": "C.4.1。最初のリクエスト"
    },
    {
      "indent": 3,
      "text": "Header list to encode:",
      "ja": "エンコードのヘッダーリスト："
    },
    {
      "indent": 3,
      "text": ":method: GET :scheme: http :path: / :authority: www.example.com",
      "ja": "：メソッド：GET：スキームます：http：パス：/：権限：www.example.com"
    },
    {
      "indent": 3,
      "text": "Hex dump of encoded data:",
      "ja": "符号化データの進ダンプ："
    },
    {
      "indent": 3,
      "text": "8286 8441 8cf1 e3c2 e5f2 3a6b a0ab 90f4 | ...A......:k.... ff | .",
      "ja": "8441 8cf1 e3c2 e5f2 3a6b a0ab 90f4 8286 | ... A ......。K .... FF | 。"
    },
    {
      "indent": 3,
      "text": "Decoding process:",
      "ja": "復号化処理："
    },
    {
      "indent": 3,
      "text": "82 | == Indexed - Add == | idx = 2 | -> :method: GET 86 | == Indexed - Add == | idx = 6 | -> :scheme: http 84 | == Indexed - Add == | idx = 4 | -> :path: / 41 | == Literal indexed == | Indexed name (idx = 1) | :authority 8c | Literal value (len = 12) | Huffman encoded: f1e3 c2e5 f23a 6ba0 ab90 f4ff | .....:k..... | Decoded: | www.example.com | -> :authority: | www.example.com",
      "ja": "82 | ==インデックス付き -  ==追加| IDX = 2 | - >：メソッド：86をGET | ==インデックス付き -  ==追加| IDX = 6 | - >：スキーム：HTTP 84 | ==インデックス付き -  ==追加| IDX = 4 | - >：パス：/ 41 | ==リテラルをインデックス== |インデックス付きの名前（IDX = 1）| ：権限8C |リテラル値（LEN = 12）|ハフマン符号化された：f1e3 c2e5 F23A 6ba0 ab90 f4ff | .....：K ..... |デコード：| www.example.com | - >：権限：| www.example.com"
    },
    {
      "indent": 3,
      "text": "Dynamic Table (after decoding):",
      "ja": "（復号後）動的テーブル："
    },
    {
      "indent": 3,
      "text": "[ 1] (s = 57) :authority: www.example.com Table size: 57",
      "ja": "[1]（S = 57）：権限：www.example.comテーブルサイズ：57"
    },
    {
      "indent": 3,
      "text": "Decoded header list:",
      "ja": "デコードされたヘッダリスト："
    },
    {
      "indent": 3,
      "text": ":method: GET :scheme: http :path: / :authority: www.example.com",
      "ja": "：メソッド：GET：スキームます：http：パス：/：権限：www.example.com"
    },
    {
      "indent": 0,
      "text": "C.4.2. Second Request",
      "ja": "C.4.2。二つ目の要求"
    },
    {
      "indent": 3,
      "text": "Header list to encode:",
      "ja": "エンコードのヘッダーリスト："
    },
    {
      "indent": 3,
      "text": ":method: GET :scheme: http :path: / :authority: www.example.com cache-control: no-cache",
      "ja": "：メソッド：GETません：スキームます：http：パス：/：権限：www.example.comキャッシュ制御：なし - キャッシュ"
    },
    {
      "indent": 3,
      "text": "Hex dump of encoded data:",
      "ja": "符号化データの進ダンプ："
    },
    {
      "indent": 3,
      "text": "8286 84be 5886 a8eb 1064 9cbf | ....X....d..",
      "ja": "8286 84be 5886 a8eb 1064 9cbf | .... X .... D .."
    },
    {
      "indent": 3,
      "text": "Decoding process:",
      "ja": "復号化処理："
    },
    {
      "indent": 3,
      "text": "82 | == Indexed - Add == | idx = 2 | -> :method: GET 86 | == Indexed - Add == | idx = 6 | -> :scheme: http 84 | == Indexed - Add == | idx = 4 | -> :path: / be | == Indexed - Add == | idx = 62 | -> :authority: | www.example.com 58 | == Literal indexed == | Indexed name (idx = 24) | cache-control 86 | Literal value (len = 6) | Huffman encoded: a8eb 1064 9cbf | ...d.. | Decoded: | no-cache | -> cache-control: no-cache",
      "ja": "82 | ==インデックス付き -  ==追加| IDX = 2 | - >：メソッド：86をGET | ==インデックス付き -  ==追加| IDX = 6 | - >：スキーム：HTTP 84 | ==インデックス付き -  ==追加| IDX = 4 | - >：パス：/ BE | ==インデックス付き -  ==追加| IDX = 62 | - >：権限：| www.example.com 58 | ==リテラルをインデックス== |インデックス付きの名前（IDX = 24）|キャッシュ制御86 |リテラル値（LEN = 6）|ハフマン符号化された：1064 9cbf a8eb | ... D .. |デコード：|キャッシュなし| - >キャッシュコントロール：キャッシュなし"
    },
    {
      "indent": 3,
      "text": "Dynamic Table (after decoding):",
      "ja": "（復号後）動的テーブル："
    },
    {
      "indent": 3,
      "text": "[ 1] (s = 53) cache-control: no-cache [ 2] (s = 57) :authority: www.example.com Table size: 110",
      "ja": "[1]（S = 53）キャッシュ制御：ノーキャッシュ[2]（S = 57）：権限：www.example.comテーブルサイズ：110"
    },
    {
      "indent": 3,
      "text": "Decoded header list:",
      "ja": "デコードされたヘッダリスト："
    },
    {
      "indent": 3,
      "text": ":method: GET :scheme: http :path: / :authority: www.example.com cache-control: no-cache",
      "ja": "：メソッド：GETません：スキームます：http：パス：/：権限：www.example.comキャッシュ制御：なし - キャッシュ"
    },
    {
      "indent": 0,
      "text": "C.4.3. Third Request",
      "ja": "C.4.3。第三のリクエスト"
    },
    {
      "indent": 3,
      "text": "Header list to encode:",
      "ja": "エンコードのヘッダーリスト："
    },
    {
      "indent": 3,
      "text": ":method: GET :scheme: https :path: /index.html :authority: www.example.com custom-key: custom-value",
      "ja": "：メソッド：GET：スキームます。https：パス：/index.htmlが：権限：www.example.comカスタムキー：カスタム値"
    },
    {
      "indent": 3,
      "text": "Hex dump of encoded data:",
      "ja": "符号化データの進ダンプ："
    },
    {
      "indent": 3,
      "text": "8287 85bf 4088 25a8 49e9 5ba9 7d7f 8925 | ....@.%.I.[.}..% a849 e95b b8e8 b4bf | .I.[....",
      "ja": "8287 85bf 4088 25a8 49e9 5ba9 7d7f 8925 | .... @％I [} ..％a849 e95bのb8e8のb4bf。。。。| 。私。[...."
    },
    {
      "indent": 3,
      "text": "Decoding process:",
      "ja": "復号化処理："
    },
    {
      "indent": 3,
      "text": "82 | == Indexed - Add == | idx = 2 | -> :method: GET 87 | == Indexed - Add == | idx = 7 | -> :scheme: https 85 | == Indexed - Add == | idx = 5 | -> :path: /index.html bf | == Indexed - Add == | idx = 63 | -> :authority: | www.example.com 40 | == Literal indexed == 88 | Literal name (len = 8) | Huffman encoded: 25a8 49e9 5ba9 7d7f | %.I.[.}. | Decoded: | custom-key 89 | Literal value (len = 9) | Huffman encoded: 25a8 49e9 5bb8 e8b4 bf | %.I.[.... | Decoded: | custom-value | -> custom-key: | custom-value",
      "ja": "82 | ==インデックス付き -  ==追加| IDX = 2 | - >：メソッド：87をGET | ==インデックス付き -  ==追加| IDX = 7 | - >：スキーム：httpsの85 | ==インデックス付き -  ==追加| IDX = 5 | - >：パス：/index.htmlがBF | ==インデックス付き -  ==追加| IDX = 63 | - >：権限：| www.example.com 40 | ==リテラルは== 88をインデックス化|リテラル名（LEN = 8）|ハフマン符号化された：25a8 49e9 5ba9 7d7f | ％。私。[。}。 |デコード：|カスタムキー89 |リテラル値（LEN = 9）|ハフマン符号化された：25a8 49e9 5bb8 e8b4 BF | ％.I [......。|デコード：|カスタム値| - >カスタムキー：|カスタム値"
    },
    {
      "indent": 3,
      "text": "Dynamic Table (after decoding):",
      "ja": "（復号後）動的テーブル："
    },
    {
      "indent": 3,
      "text": "[ 1] (s = 54) custom-key: custom-value [ 2] (s = 53) cache-control: no-cache [ 3] (s = 57) :authority: www.example.com Table size: 164",
      "ja": "[1]（S = 54）カスタムキー：カスタム値[2]（S = 53）キャッシュ制御：ノーキャッシュ[3]（S = 57）：権限：www.example.comテーブルサイズ：164"
    },
    {
      "indent": 3,
      "text": "Decoded header list:",
      "ja": "デコードされたヘッダリスト："
    },
    {
      "indent": 3,
      "text": ":method: GET :scheme: https :path: /index.html :authority: www.example.com custom-key: custom-value",
      "ja": "：メソッド：GET：スキームます。https：パス：/index.htmlが：権限：www.example.comカスタムキー：カスタム値"
    },
    {
      "indent": 0,
      "text": "C.5. Response Examples without Huffman Coding",
      "ja": "C.5。ハフマン符号化せずにレスポンスの例"
    },
    {
      "indent": 3,
      "text": "This section shows several consecutive header lists, corresponding to HTTP responses, on the same connection. The HTTP/2 setting parameter SETTINGS_HEADER_TABLE_SIZE is set to the value of 256 octets, causing some evictions to occur.",
      "ja": "このセクションでは、同じ接続上で、HTTPレスポンスに対応する、いくつかの連続するヘッダリストを示しています。 HTTP / 2設定パラメータSETTINGS_HEADER_TABLE_SIZEは、いくつかの追い出しが発生する原因と、256オクテットの値に設定されています。"
    },
    {
      "indent": 0,
      "text": "C.5.1. First Response",
      "ja": "C.5.1。ファースト・レスポンス"
    },
    {
      "indent": 3,
      "text": "Header list to encode:",
      "ja": "エンコードのヘッダーリスト："
    },
    {
      "indent": 3,
      "text": ":status: 302 cache-control: private date: Mon, 21 Oct 2013 20:13:21 GMT location: https://www.example.com",
      "ja": "：状況：302キャッシュ制御：プライベート日：月、2013年10月21日午前20時13分21秒GMT場所：https://www.example.com"
    },
    {
      "indent": 3,
      "text": "Hex dump of encoded data:",
      "ja": "符号化データの進ダンプ："
    },
    {
      "indent": 3,
      "text": "4803 3330 3258 0770 7269 7661 7465 611d | H.302X.privatea. 4d6f 6e2c 2032 3120 4f63 7420 3230 3133 | Mon, 21 Oct 2013 2032 303a 3133 3a32 3120 474d 546e 1768 | 20:13:21 GMTn.h 7474 7073 3a2f 2f77 7777 2e65 7861 6d70 | ttps://www.examp 6c65 2e63 6f6d | le.com",
      "ja": "4803 3330 3258 0770 7269 7661 7465 611D | H.302X.privatea。 4d6f 6e2c 4f63 7420 3230 3133 2032 3120 |月、2013年10月21日2032 303A 3133 3a32 3120 474D 546e 1768 | 20時13分21秒GMTn.h 7474 7073 3a2f 2f77 7777 2e65 7861 6d70 | ttps：//www.examp 6c65 2e63 6f6d | le.com"
    },
    {
      "indent": 3,
      "text": "Decoding process:",
      "ja": "復号化処理："
    },
    {
      "indent": 3,
      "text": "48 | == Literal indexed == | Indexed name (idx = 8) | :status 03 | Literal value (len = 3) 3330 32 | 302 | -> :status: 302 58 | == Literal indexed == | Indexed name (idx = 24) | cache-control 07 | Literal value (len = 7) 7072 6976 6174 65 | private | -> cache-control: private 61 | == Literal indexed == | Indexed name (idx = 33) | date 1d | Literal value (len = 29) 4d6f 6e2c 2032 3120 4f63 7420 3230 3133 | Mon, 21 Oct 2013 2032 303a 3133 3a32 3120 474d 54 | 20:13:21 GMT | -> date: Mon, 21 Oct 2013 | 20:13:21 GMT 6e | == Literal indexed == | Indexed name (idx = 46)",
      "ja": "48 | ==リテラルをインデックス== |インデックス付きの名前（IDX = 8）| ：ステータス03 |リテラル値（LEN = 3）3330 32 | 302 | - >：状態：302 58 | ==リテラルをインデックス== |インデックス付きの名前（IDX = 24）|キャッシュ制御07 |リテラル値6976 6174 65 7072（LEN = 7）|プライベート| - >キャッシュ制御：プライベート61 | ==リテラルをインデックス== |インデックス付きの名前（IDX = 33）|日付1D |リテラル値（LEN = 29）4d6f 6e2c 4f63 7420 3230 3133 2032 3120 |月、2013年10月21日2032 303A 3133 3a32 3120 474D 54 | 20時13分21秒GMT | - >日付：月、2013年10月21日| 20時13分21秒GMT 6eと| ==リテラルをインデックス== |インデックス付きの名前（IDX = 46）"
    },
    {
      "indent": 3,
      "text": " | location 17 | Literal value (len = 23) 6874 7470 733a 2f2f 7777 772e 6578 616d | https://www.exam 706c 652e 636f 6d | ple.com | -> location: | https://www.example.com",
      "ja": "|場所17 |リテラル値（LEN = 23）6874 7470 733A 2f2f 7777 772e 6578 616D | HTTPS：//www.examの706C 652e 636f 6D | ple.com | - >所在地：| https://www.example.com"
    },
    {
      "indent": 3,
      "text": "Dynamic Table (after decoding):",
      "ja": "（復号後）動的テーブル："
    },
    {
      "indent": 3,
      "text": "[ 1] (s = 63) location: https://www.example.com [ 2] (s = 65) date: Mon, 21 Oct 2013 20:13:21 GMT [ 3] (s = 52) cache-control: private [ 4] (s = 42) :status: 302 Table size: 222",
      "ja": "[1]（S = 63）場所：https://www.example.com [2]（S = 65）日付：月、2013年10月21日20時13分21秒GMT [3]（S = 52）cache-コントロール：プライベート[4]（S = 42）：ステータス：302テーブル・サイズ：222"
    },
    {
      "indent": 3,
      "text": "Decoded header list:",
      "ja": "デコードされたヘッダリスト："
    },
    {
      "indent": 3,
      "text": ":status: 302 cache-control: private date: Mon, 21 Oct 2013 20:13:21 GMT location: https://www.example.com",
      "ja": "：状況：302キャッシュ制御：プライベート日：月、2013年10月21日午前20時13分21秒GMT場所：https://www.example.com"
    },
    {
      "indent": 0,
      "text": "C.5.2. Second Response",
      "ja": "C.5.2。第二レスポンス"
    },
    {
      "indent": 3,
      "text": "The (\":status\", \"302\") header field is evicted from the dynamic table to free space to allow adding the (\":status\", \"307\") header field.",
      "ja": "ヘッダフィールド（「：ステータス」、「302」）ヘッダフィールドは、（「ステータス」、「307」）を追加できるように自由空間に動的テーブルから追い出されます。"
    },
    {
      "indent": 3,
      "text": "Header list to encode:",
      "ja": "エンコードのヘッダーリスト："
    },
    {
      "indent": 3,
      "text": ":status: 307 cache-control: private date: Mon, 21 Oct 2013 20:13:21 GMT location: https://www.example.com",
      "ja": "：状況：307キャッシュ制御：プライベート日：月、2013年10月21日午前20時13分21秒GMT場所：https://www.example.com"
    },
    {
      "indent": 3,
      "text": "Hex dump of encoded data:",
      "ja": "符号化データの進ダンプ："
    },
    {
      "indent": 3,
      "text": "4803 3330 37c1 c0bf | H.307...",
      "ja": "4803 3330 37c1 c0bf | H.307 ..."
    },
    {
      "indent": 3,
      "text": "Decoding process:",
      "ja": "復号化処理："
    },
    {
      "indent": 3,
      "text": "48 | == Literal indexed == | Indexed name (idx = 8) | :status 03 | Literal value (len = 3) 3330 37 | 307 | - evict: :status: 302 | -> :status: 307 c1 | == Indexed - Add ==",
      "ja": "48 | ==リテラルをインデックス== |インデックス付きの名前（IDX = 8）| ：ステータス03 |リテラル値（LEN = 3）3330 37 | 307 | - 追い出し：状況：302 | - >：状態：307のC1 | ==インデックス付き - 追加=="
    },
    {
      "indent": 3,
      "text": " | idx = 65 | -> cache-control: private c0 | == Indexed - Add == | idx = 64 | -> date: Mon, 21 Oct 2013 | 20:13:21 GMT bf | == Indexed - Add == | idx = 63 | -> location: | https://www.example.com",
      "ja": "| IDX = 65 | - >キャッシュ制御：プライベートC0 | ==インデックス付き -  ==追加| IDX = 64 | - >日付：月、2013年10月21日| 20時13分21秒GMTのBF | ==インデックス付き -  ==追加| IDX = 63 | - >所在地：| https://www.example.com"
    },
    {
      "indent": 3,
      "text": "Dynamic Table (after decoding):",
      "ja": "（復号後）動的テーブル："
    },
    {
      "indent": 3,
      "text": "[ 1] (s = 42) :status: 307 [ 2] (s = 63) location: https://www.example.com [ 3] (s = 65) date: Mon, 21 Oct 2013 20:13:21 GMT [ 4] (s = 52) cache-control: private Table size: 222",
      "ja": "[1]（S = 42）：ステータス：307 [2]（S = 63）場所：https://www.example.com [3]（S = 65）日付：月、2013年10月21日午前20時13： 21 GMT [4]（S = 52）キャッシュ制御：プライベートテーブルサイズ：222"
    },
    {
      "indent": 3,
      "text": "Decoded header list:",
      "ja": "デコードされたヘッダリスト："
    },
    {
      "indent": 3,
      "text": ":status: 307 cache-control: private date: Mon, 21 Oct 2013 20:13:21 GMT location: https://www.example.com",
      "ja": "：状況：307キャッシュ制御：プライベート日：月、2013年10月21日午前20時13分21秒GMT場所：https://www.example.com"
    },
    {
      "indent": 0,
      "text": "C.5.3. Third Response",
      "ja": "C.5.3。サードレスポンス"
    },
    {
      "indent": 3,
      "text": "Several header fields are evicted from the dynamic table during the processing of this header list.",
      "ja": "いくつかのヘッダフィールドは、このヘッダリストの処理中に動的表から追い出されます。"
    },
    {
      "indent": 3,
      "text": "Header list to encode:",
      "ja": "エンコードのヘッダーリスト："
    },
    {
      "indent": 3,
      "text": ":status: 200 cache-control: private date: Mon, 21 Oct 2013 20:13:22 GMT location: https://www.example.com content-encoding: gzip set-cookie: foo=ASDJKHQKBZXOQWEOPIUAXQWEOIU; max-age=3600; version=1",
      "ja": "：状況：200キャッシュ制御：プライベート日：月、2013年10月21日午後08時13分22秒GMT場所：https://www.example.comコンテンツエンコード：gzipでのSet-Cookie：FOO = ASDJKHQKBZXOQWEOPIUAXQWEOIU。最大エージング= 3600;バージョン= 1"
    },
    {
      "indent": 3,
      "text": "Hex dump of encoded data:",
      "ja": "符号化データの進ダンプ："
    },
    {
      "indent": 3,
      "text": "88c1 611d 4d6f 6e2c 2032 3120 4f63 7420 | ..a.Mon, 21 Oct 3230 3133 2032 303a 3133 3a32 3220 474d | 2013 20:13:22 GM 54c0 5a04 677a 6970 7738 666f 6f3d 4153 | T.Z.gzipw8foo=AS 444a 4b48 514b 425a 584f 5157 454f 5049 | DJKHQKBZXOQWEOPI 5541 5851 5745 4f49 553b 206d 6178 2d61 | UAXQWEOIU; max-a 6765 3d33 3630 303b 2076 6572 7369 6f6e | ge=3600; version 3d31 | =1",
      "ja": "88c1 611D 4d6f 6e2c 2032 4f63 7420 3120 | ..a.Mon、10月21日3230 3133 2032 303A 3133 3a32 3220 474D | 2013夜8時13分22秒GM 54c0 5a04 677A 6970 7738 666f 6f3d 4153 | T.Z.gzipw8foo = 444A 4b48 514B AS 425A 584f 454f 5049 5157 | DJKHQKBZXOQWEOPI 5541 5851 5745 4f49 553B 206D 6178 2d61 | UAXQWEOIU; MAX-6765 3D33 3630 303B 2076 6572 7369 6f6e | GE = 3600;バージョン3d31 | = 1"
    },
    {
      "indent": 3,
      "text": "Decoding process:",
      "ja": "復号化処理："
    },
    {
      "indent": 3,
      "text": "88 | == Indexed - Add == | idx = 8 | -> :status: 200 c1 | == Indexed - Add == | idx = 65 | -> cache-control: private 61 | == Literal indexed == | Indexed name (idx = 33) | date 1d | Literal value (len = 29) 4d6f 6e2c 2032 3120 4f63 7420 3230 3133 | Mon, 21 Oct 2013 2032 303a 3133 3a32 3220 474d 54 | 20:13:22 GMT | - evict: cache-control: | private | -> date: Mon, 21 Oct 2013 | 20:13:22 GMT c0 | == Indexed - Add == | idx = 64 | -> location: | https://www.example.com 5a | == Literal indexed == | Indexed name (idx = 26) | content-encoding 04 | Literal value (len = 4) 677a 6970 | gzip | - evict: date: Mon, 21 Oct | 2013 20:13:21 GMT | -> content-encoding: gzip 77 | == Literal indexed == | Indexed name (idx = 55) | set-cookie 38 | Literal value (len = 56) 666f 6f3d 4153 444a 4b48 514b 425a 584f | foo=ASDJKHQKBZXO 5157 454f 5049 5541 5851 5745 4f49 553b | QWEOPIUAXQWEOIU; 206d 6178 2d61 6765 3d33 3630 303b 2076 | max-age=3600; v 6572 7369 6f6e 3d31 | ersion=1",
      "ja": "88 | ==インデックス付き -  ==追加| IDX = 8 | - >：状態：200のC1 | ==インデックス付き -  ==追加| IDX = 65 | - >キャッシュ制御：プライベート61 | ==リテラルをインデックス== |インデックス付きの名前（IDX = 33）|日付1D |リテラル値（LEN = 29）4d6f 6e2c 4f63 7420 3230 3133 2032 3120 |月、2013年10月21日2032 303A 3133 3a32 3220 474D 54 |午後08時13分22秒GMT | - 追い出し：キャッシュ制御：|プライベート| - >日付：月、2013年10月21日|午後08時13分22秒GMTのC0 | ==インデックス付き -  ==追加| IDX = 64 | - >所在地：| https://www.example.com図5a | ==リテラルをインデックス== |インデックス付きの名前（IDX = 26）|コンテンツエンコード04 |リテラル値（LEN = 4）677A 6970 | GZIP | - 追い出し：日付：月、10月21日| 2013年20時13分21秒GMT | - >コンテンツエンコード：gzipの77 | ==リテラルをインデックス== |インデックス付きの名前（IDX = 55）|セットクッキー38 |リテラル値（LEN = 56）666f 6f3d 4153 444A 4b48 514B 425A 584f | FOO = ASDJKHQKBZXO 5157 454f 5049 5541 5851 5745 4f49 553B | QWEOPIUAXQWEOIU; 206D 6178 2d61 6765 3D33 3630 303B 2076 |最大エージング= 3600; V 6572 7369 6f6e 3d31 | ERSION = 1"
    },
    {
      "indent": 43,
      "text": "| - evict: location:\n|   https://www.example.com\n| - evict: :status: 307\n| -> set-cookie: foo=ASDJKHQ\n|   KBZXOQWEOPIUAXQWEOIU; ma\n|   x-age=3600; version=1",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Dynamic Table (after decoding):",
      "ja": "（復号後）動的テーブル："
    },
    {
      "indent": 3,
      "text": "[ 1] (s = 98) set-cookie: foo=ASDJKHQKBZXOQWEOPIUAXQWEOIU; max-age=3600; version=1 [ 2] (s = 52) content-encoding: gzip [ 3] (s = 65) date: Mon, 21 Oct 2013 20:13:22 GMT Table size: 215",
      "ja": "[1]（S = 98）のSet-Cookie：FOO = ASDJKHQKBZXOQWEOPIUAXQWEOIU。最大エージング= 3600;バージョン= 1 [2]（S = 52）コンテンツエンコード：GZIP [3]（S = 65）日付：月、2013年10月21日午後08時13分22秒GMTテーブルサイズ：215"
    },
    {
      "indent": 3,
      "text": "Decoded header list:",
      "ja": "デコードされたヘッダリスト："
    },
    {
      "indent": 3,
      "text": ":status: 200 cache-control: private date: Mon, 21 Oct 2013 20:13:22 GMT location: https://www.example.com content-encoding: gzip set-cookie: foo=ASDJKHQKBZXOQWEOPIUAXQWEOIU; max-age=3600; version=1",
      "ja": "：状況：200キャッシュ制御：プライベート日：月、2013年10月21日午後08時13分22秒GMT場所：https://www.example.comコンテンツエンコード：gzipでのSet-Cookie：FOO = ASDJKHQKBZXOQWEOPIUAXQWEOIU。最大エージング= 3600;バージョン= 1"
    },
    {
      "indent": 0,
      "text": "C.6. Response Examples with Huffman Coding",
      "ja": "C.6。ハフマン符号化とレスポンスの例"
    },
    {
      "indent": 3,
      "text": "This section shows the same examples as the previous section but uses Huffman encoding for the literal values. The HTTP/2 setting parameter SETTINGS_HEADER_TABLE_SIZE is set to the value of 256 octets, causing some evictions to occur. The eviction mechanism uses the length of the decoded literal values, so the same evictions occur as in the previous section.",
      "ja": "このセクションでは、前のセクションと同じ例を示しているが、リテラル値に対してハフマン符号化を使用します。 HTTP / 2設定パラメータSETTINGS_HEADER_TABLE_SIZEは、いくつかの追い出しが発生する原因と、256オクテットの値に設定されています。立ち退き機構は、復号リテラル値の長さを使用するため、同一の立ち退きは、前節と同様に起こります。"
    },
    {
      "indent": 0,
      "text": "C.6.1. First Response",
      "ja": "C.6.1。ファースト・レスポンス"
    },
    {
      "indent": 3,
      "text": "Header list to encode:",
      "ja": "エンコードのヘッダーリスト："
    },
    {
      "indent": 3,
      "text": ":status: 302 cache-control: private date: Mon, 21 Oct 2013 20:13:21 GMT location: https://www.example.com",
      "ja": "：状況：302キャッシュ制御：プライベート日：月、2013年10月21日午前20時13分21秒GMT場所：https://www.example.com"
    },
    {
      "indent": 3,
      "text": "Hex dump of encoded data:",
      "ja": "符号化データの進ダンプ："
    },
    {
      "indent": 3,
      "text": "4882 6402 5885 aec3 771a 4b61 96d0 7abe | H.d.X...w.Ka..z. 9410 54d4 44a8 2005 9504 0b81 66e0 82a6 | ..T.D. .....f... 2d1b ff6e 919d 29ad 1718 63c7 8f0b 97c8 | -..n..)...c..... e9ae 82ae 43d3 | ....C.",
      "ja": "4882 6402 5885 aec3 771a 4b61 96d0の7abe | H.d.X ... w.Ka..z。 9410 54d4 44a8 2005 9504 0b81 66e0の82a6 | ..T.D。 ..... F ... 2d1b ff6e 919d 29ad 63c7 8f0b 97c8 1718 | -  ... N ...）... C ..... e9ae 82ae 43d3 | .... C。"
    },
    {
      "indent": 3,
      "text": "Decoding process:",
      "ja": "復号化処理："
    },
    {
      "indent": 3,
      "text": "48                                      | == Literal indexed ==\n                                        |   Indexed name (idx = 8)\n                                        |     :status\n82                                      |   Literal value (len = 2)\n                                        |     Huffman encoded:\n6402                                    | d.\n                                        |     Decoded:\n                                        | 302\n                                        | -> :status: 302\n58                                      | == Literal indexed ==\n                                        |   Indexed name (idx = 24)\n                                        |     cache-control\n85                                      |   Literal value (len = 5)\n                                        |     Huffman encoded:\naec3 771a 4b                            | ..w.K\n                                        |     Decoded:\n                                        | private\n                                        | -> cache-control: private\n61                                      | == Literal indexed ==\n                                        |   Indexed name (idx = 33)\n                                        |     date\n96                                      |   Literal value (len = 22)\n                                        |     Huffman encoded:\nd07a be94 1054 d444 a820 0595 040b 8166 | .z...T.D. .....f\ne082 a62d 1bff                          | ...-..\n                                        |     Decoded:\n                                        | Mon, 21 Oct 2013 20:13:21\n                                        | GMT\n                                        | -> date: Mon, 21 Oct 2013\n                                        |   20:13:21 GMT\n6e                                      | == Literal indexed ==\n                                        |   Indexed name (idx = 46)\n                                        |     location\n91                                      |   Literal value (len = 17)\n                                        |     Huffman encoded:\n9d29 ad17 1863 c78f 0b97 c8e9 ae82 ae43 | .)...c.........C\nd3                                      | .\n                                        |     Decoded:\n                                        | https://www.example.com\n                                        | -> location:\n                                        |   https://www.example.com",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Dynamic Table (after decoding):",
      "ja": "（復号後）動的テーブル："
    },
    {
      "indent": 3,
      "text": "[ 1] (s = 63) location: https://www.example.com [ 2] (s = 65) date: Mon, 21 Oct 2013 20:13:21 GMT [ 3] (s = 52) cache-control: private [ 4] (s = 42) :status: 302 Table size: 222",
      "ja": "[1]（S = 63）場所：https://www.example.com [2]（S = 65）日付：月、2013年10月21日20時13分21秒GMT [3]（S = 52）cache-コントロール：プライベート[4]（S = 42）：ステータス：302テーブル・サイズ：222"
    },
    {
      "indent": 3,
      "text": "Decoded header list:",
      "ja": "デコードされたヘッダリスト："
    },
    {
      "indent": 3,
      "text": ":status: 302 cache-control: private date: Mon, 21 Oct 2013 20:13:21 GMT location: https://www.example.com",
      "ja": "：状況：302キャッシュ制御：プライベート日：月、2013年10月21日午前20時13分21秒GMT場所：https://www.example.com"
    },
    {
      "indent": 0,
      "text": "C.6.2. Second Response",
      "ja": "C.6.2。第二レスポンス"
    },
    {
      "indent": 3,
      "text": "The (\":status\", \"302\") header field is evicted from the dynamic table to free space to allow adding the (\":status\", \"307\") header field.",
      "ja": "ヘッダフィールド（「：ステータス」、「302」）ヘッダフィールドは、（「ステータス」、「307」）を追加できるように自由空間に動的テーブルから追い出されます。"
    },
    {
      "indent": 3,
      "text": "Header list to encode:",
      "ja": "エンコードのヘッダーリスト："
    },
    {
      "indent": 3,
      "text": ":status: 307 cache-control: private date: Mon, 21 Oct 2013 20:13:21 GMT location: https://www.example.com",
      "ja": "：状況：307キャッシュ制御：プライベート日：月、2013年10月21日午前20時13分21秒GMT場所：https://www.example.com"
    },
    {
      "indent": 3,
      "text": "Hex dump of encoded data:",
      "ja": "符号化データの進ダンプ："
    },
    {
      "indent": 3,
      "text": "4883 640e ffc1 c0bf | H.d.....",
      "ja": "4883 640E FFC1 c0bf | H.d ....."
    },
    {
      "indent": 3,
      "text": "Decoding process:",
      "ja": "復号化処理："
    },
    {
      "indent": 3,
      "text": "48 | == Literal indexed == | Indexed name (idx = 8) | :status 83 | Literal value (len = 3) | Huffman encoded: 640e ff | d.. | Decoded: | 307 | - evict: :status: 302 | -> :status: 307 c1 | == Indexed - Add == | idx = 65 | -> cache-control: private c0 | == Indexed - Add == | idx = 64",
      "ja": "48 | ==リテラルをインデックス== |インデックス付きの名前（IDX = 8）| ：ステータス83 |リテラル値（LEN = 3）|ハフマン符号化された：FFを640E | D .. |デコード：| 307 | - 追い出し：状況：302 | - >：状態：307のC1 | ==インデックス付き -  ==追加| IDX = 65 | - >キャッシュ制御：プライベートC0 | ==インデックス付き -  ==追加| IDX = 64"
    },
    {
      "indent": 3,
      "text": " | -> date: Mon, 21 Oct 2013 | 20:13:21 GMT bf | == Indexed - Add == | idx = 63 | -> location: | https://www.example.com",
      "ja": "| - >日付：月、2013年10月21日| 20時13分21秒GMTのBF | ==インデックス付き -  ==追加| IDX = 63 | - >所在地：| https://www.example.com"
    },
    {
      "indent": 3,
      "text": "Dynamic Table (after decoding):",
      "ja": "（復号後）動的テーブル："
    },
    {
      "indent": 3,
      "text": "[ 1] (s = 42) :status: 307 [ 2] (s = 63) location: https://www.example.com [ 3] (s = 65) date: Mon, 21 Oct 2013 20:13:21 GMT [ 4] (s = 52) cache-control: private Table size: 222",
      "ja": "[1]（S = 42）：ステータス：307 [2]（S = 63）場所：https://www.example.com [3]（S = 65）日付：月、2013年10月21日午前20時13： 21 GMT [4]（S = 52）キャッシュ制御：プライベートテーブルサイズ：222"
    },
    {
      "indent": 3,
      "text": "Decoded header list:",
      "ja": "デコードされたヘッダリスト："
    },
    {
      "indent": 3,
      "text": ":status: 307 cache-control: private date: Mon, 21 Oct 2013 20:13:21 GMT location: https://www.example.com",
      "ja": "：状況：307キャッシュ制御：プライベート日：月、2013年10月21日午前20時13分21秒GMT場所：https://www.example.com"
    },
    {
      "indent": 0,
      "text": "C.6.3. Third Response",
      "ja": "C.6.3。サードレスポンス"
    },
    {
      "indent": 3,
      "text": "Several header fields are evicted from the dynamic table during the processing of this header list.",
      "ja": "いくつかのヘッダフィールドは、このヘッダリストの処理中に動的表から追い出されます。"
    },
    {
      "indent": 3,
      "text": "Header list to encode:",
      "ja": "エンコードのヘッダーリスト："
    },
    {
      "indent": 3,
      "text": ":status: 200 cache-control: private date: Mon, 21 Oct 2013 20:13:22 GMT location: https://www.example.com content-encoding: gzip set-cookie: foo=ASDJKHQKBZXOQWEOPIUAXQWEOIU; max-age=3600; version=1",
      "ja": "：状況：200キャッシュ制御：プライベート日：月、2013年10月21日午後08時13分22秒GMT場所：https://www.example.comコンテンツエンコード：gzipでのSet-Cookie：FOO = ASDJKHQKBZXOQWEOPIUAXQWEOIU。最大エージング= 3600;バージョン= 1"
    },
    {
      "indent": 3,
      "text": "Hex dump of encoded data:",
      "ja": "符号化データの進ダンプ："
    },
    {
      "indent": 3,
      "text": "88c1 6196 d07a be94 1054 d444 a820 0595 | ..a..z...T.D. ..\n040b 8166 e084 a62d 1bff c05a 839b d9ab | ...f...-...Z....\n77ad 94e7 821d d7f2 e6c7 b335 dfdf cd5b | w..........5...[\n3960 d5af 2708 7f36 72c1 ab27 0fb5 291f | 9`..'..6r..'..).\n9587 3160 65c0 03ed 4ee5 b106 3d50 07   | ..1`e...N...=P.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Decoding process:",
      "ja": "復号化処理："
    },
    {
      "indent": 3,
      "text": "88                                      | == Indexed - Add ==\n                                        |   idx = 8\n                                        | -> :status: 200\nc1                                      | == Indexed - Add ==\n                                        |   idx = 65\n                                        | -> cache-control: private\n61                                      | == Literal indexed ==\n                                        |   Indexed name (idx = 33)\n                                        |     date\n96                                      |   Literal value (len = 22)\n                                        |     Huffman encoded:\nd07a be94 1054 d444 a820 0595 040b 8166 | .z...T.D. .....f\ne084 a62d 1bff                          | ...-..\n                                        |     Decoded:\n                                        | Mon, 21 Oct 2013 20:13:22\n                                        | GMT\n                                        | - evict: cache-control:\n                                        |   private\n                                        | -> date: Mon, 21 Oct 2013\n                                        |   20:13:22 GMT\nc0                                      | == Indexed - Add ==\n                                        |   idx = 64\n                                        | -> location:\n                                        |   https://www.example.com\n5a                                      | == Literal indexed ==\n                                        |   Indexed name (idx = 26)\n                                        |     content-encoding\n83                                      |   Literal value (len = 3)\n                                        |     Huffman encoded:\n9bd9 ab                                 | ...\n                                        |     Decoded:\n                                        | gzip\n                                        | - evict: date: Mon, 21 Oct\n                                        |    2013 20:13:21 GMT\n                                        | -> content-encoding: gzip\n77                                      | == Literal indexed ==\n                                        |   Indexed name (idx = 55)\n                                        |     set-cookie\nad                                      |   Literal value (len = 45)\n                                        |     Huffman encoded:\n94e7 821d d7f2 e6c7 b335 dfdf cd5b 3960 | .........5...[9`\nd5af 2708 7f36 72c1 ab27 0fb5 291f 9587 | ..'..6r..'..)...\n3160 65c0 03ed 4ee5 b106 3d50 07        | 1`e...N...=P.\n                                        |     Decoded:\n                                        | foo=ASDJKHQKBZXOQWEOPIUAXQ\n                                        | WEOIU; max-age=3600; versi",
      "raw": true
    },
    {
      "indent": 43,
      "text": "| on=1\n| - evict: location:\n|   https://www.example.com\n| - evict: :status: 307\n| -> set-cookie: foo=ASDJKHQ\n|   KBZXOQWEOPIUAXQWEOIU; ma\n|   x-age=3600; version=1",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Dynamic Table (after decoding):",
      "ja": "（復号後）動的テーブル："
    },
    {
      "indent": 3,
      "text": "[ 1] (s = 98) set-cookie: foo=ASDJKHQKBZXOQWEOPIUAXQWEOIU; max-age=3600; version=1 [ 2] (s = 52) content-encoding: gzip [ 3] (s = 65) date: Mon, 21 Oct 2013 20:13:22 GMT Table size: 215",
      "ja": "[1]（S = 98）のSet-Cookie：FOO = ASDJKHQKBZXOQWEOPIUAXQWEOIU。最大エージング= 3600;バージョン= 1 [2]（S = 52）コンテンツエンコード：GZIP [3]（S = 65）日付：月、2013年10月21日午後08時13分22秒GMTテーブルサイズ：215"
    },
    {
      "indent": 3,
      "text": "Decoded header list:",
      "ja": "デコードされたヘッダリスト："
    },
    {
      "indent": 3,
      "text": ":status: 200 cache-control: private date: Mon, 21 Oct 2013 20:13:22 GMT location: https://www.example.com content-encoding: gzip set-cookie: foo=ASDJKHQKBZXOQWEOPIUAXQWEOIU; max-age=3600; version=1",
      "ja": "：状況：200キャッシュ制御：プライベート日：月、2013年10月21日午後08時13分22秒GMT場所：https://www.example.comコンテンツエンコード：gzipでのSet-Cookie：FOO = ASDJKHQKBZXOQWEOPIUAXQWEOIU。最大エージング= 3600;バージョン= 1"
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "This specification includes substantial input from the following individuals:",
      "ja": "この仕様は以下の個人からの実質的な入力が含まれています。"
    },
    {
      "indent": 3,
      "text": "o Mike Bishop, Jeff Pinner, Julian Reschke, and Martin Thomson (substantial editorial contributions).",
      "ja": "Oマイク・ビショップ、ジェフ・ピナー、ジュリアンReschke、そしてマーティン・トムソン（かなりの社説の貢献）。"
    },
    {
      "indent": 3,
      "text": "o Johnny Graettinger (Huffman code statistics).",
      "ja": "ジョニーGraettinger（ハフマン符号統計）O。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Roberto Peon Google, Inc",
      "ja": "ロベルトペオングーグル株式会社"
    },
    {
      "indent": 3,
      "text": "EMail: fenix@google.com",
      "ja": "メールアドレス：fenix@google.com"
    },
    {
      "indent": 3,
      "text": "Herve Ruellan Canon CRF",
      "ja": "エルベRuellanキヤノンCRF"
    },
    {
      "indent": 3,
      "text": "EMail: herve.ruellan@crf.canon.fr",
      "ja": "メールアドレス：herve.ruellan@crf.canon.fr"
    }
  ]
}