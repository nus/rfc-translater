{
  "title": {
    "text": "RFC 7851 - Peer-to-Peer (P2P) Overlay Diagnostics",
    "ja": "RFC 7851 - ピア・ツー・ピア（P2P）オーバーレイ診断"
  },
  "number": 7851,
  "created_at": "2019-11-02 17:38:32.211537+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                           H. Song\nRequest for Comments: 7851                                      X. Jiang\nCategory: Standards Track                                        R. Even\nISSN: 2070-1721                                                   Huawei\n                                                                D. Bryan\n                                                            ethernot.org\n                                                                  Y. Sun\n                                                                     ICT\n                                                                May 2016",
      "raw": true
    },
    {
      "indent": 17,
      "text": "Peer-to-Peer (P2P) Overlay Diagnostics",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document describes mechanisms for Peer-to-Peer (P2P) overlay diagnostics. It defines extensions to the REsource LOcation And Discovery (RELOAD) base protocol to collect diagnostic information and details the protocol specifications for these extensions. Useful diagnostic information for connection and node status monitoring is also defined. The document also describes the usage scenarios and provides examples of how these methods are used to perform diagnostics.",
      "ja": "この文書では、ピア・ツー・ピア（P2P）オーバーレイの診断のためのメカニズムについて説明します。これは、診断情報を収集するリソースロケーションと発見（リロード）基本プロトコルへの拡張を定義し、これらの拡張のためのプロトコル仕様を詳述します。接続ノード状態監視のための有用な診断情報も定義されています。文書はまた、利用シナリオを説明し、これらのメソッドは、診断を実行するために使用されている方法の例を示します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 5741のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7851.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7851で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2016 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2016 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   4\n2.  Terminology . . . . . . . . . . . . . . . . . . . . . . . . .   5\n3.  Diagnostic Scenarios  . . . . . . . . . . . . . . . . . . . .   5\n4.  Data Collection Mechanisms  . . . . . . . . . . . . . . . . .   6\n  4.1.  Overview of Operations  . . . . . . . . . . . . . . . . .   6\n  4.2.  \"Ping-like\" Behavior: Extending Ping  . . . . . . . . . .   8\n    4.2.1.  RELOAD Request Extension: Ping  . . . . . . . . . . .   9\n  4.3.  \"Traceroute-like\" Behavior: The PathTrack Method  . . . .   9\n    4.3.1.  New RELOAD Request: PathTrack . . . . . . . . . . . .  10\n  4.4.  Error Code Extensions . . . . . . . . . . . . . . . . . .  12\n5.  Diagnostic Data Structures  . . . . . . . . . . . . . . . . .  13\n  5.1.  DiagnosticsRequest Data Structure . . . . . . . . . . . .  13\n  5.2.  DiagnosticsResponse Data Structure  . . . . . . . . . . .  15\n  5.3.  dMFlags and Diagnostic Kind ID Types  . . . . . . . . . .  16\n6.  Message Processing  . . . . . . . . . . . . . . . . . . . . .  19\n  6.1.  Message Creation and Transmission . . . . . . . . . . . .  19\n  6.2.  Message Processing: Intermediate Peers  . . . . . . . . .  20\n  6.3.  Message Response Creation . . . . . . . . . . . . . . . .  21\n  6.4.  Interpreting Results  . . . . . . . . . . . . . . . . . .  22\n7.  Authorization through Overlay Configuration . . . . . . . . .  23\n8.  Security Considerations . . . . . . . . . . . . . . . . . . .  23\n9.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  24\n  9.1.  Diagnostics Flag  . . . . . . . . . . . . . . . . . . . .  24\n  9.2.  Diagnostic Kind ID  . . . . . . . . . . . . . . . . . . .  25\n  9.3.  Message Codes . . . . . . . . . . . . . . . . . . . . . .  26\n  9.4.  Error Code  . . . . . . . . . . . . . . . . . . . . . . .  26\n  9.5.  Message Extension . . . . . . . . . . . . . . . . . . . .  26\n  9.6.  XML Name Space Registration . . . . . . . . . . . . . . .  27\n10. References  . . . . . . . . . . . . . . . . . . . . . . . . .  27\n  10.1.  Normative References . . . . . . . . . . . . . . . . . .  27\n  10.2.  Informative References . . . . . . . . . . . . . . . . .  28\nAppendix A.  Examples . . . . . . . . . . . . . . . . . . . . . .  29\n  A.1.  Example 1 . . . . . . . . . . . . . . . . . . . . . . . .  29\n  A.2.  Example 2 . . . . . . . . . . . . . . . . . . . . . . . .  29\n  A.3.  Example 3 . . . . . . . . . . . . . . . . . . . . . . . .  29\nAppendix B.  Problems with Generating Multiple Responses on Path   29\nAcknowledgments . . . . . . . . . . . . . . . . . . . . . . . . .  30\nAuthors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  30",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "In the last few years, overlay networks have rapidly evolved and emerged as a promising platform for deployment of new applications and services in the Internet. One of the reasons overlay networks are seen as an excellent platform for large-scale distributed systems is their resilience in the presence of failures. This resilience has three aspects: data replication, routing recovery, and static resilience. Routing recovery algorithms are used to repopulate the routing table with live nodes when failures are detected. Static resilience measures the extent to which an overlay can route around failures even before the recovery algorithm repairs the routing table. Both routing recovery and static resilience rely on accurate and timely detection of failures.",
      "ja": "ここ数年では、オーバーレイネットワークは急速に進化してきたし、インターネットでの新しいアプリケーションやサービスの展開のための有望なプラットフォームとして浮上しました。オーバレイネットワークは、大規模分散システムのための優れたプラットフォームと見られている理由の一つは、障害の存在下でそれらのレジリエンスです。データ複製、ルーティングの回復、および静的な回復力：この回復力は、三つの側面があります。ルーティング回復アルゴリズムは、障害が検出された場合、ライブノードにルーティングテーブルを再作成するために使用されます。静的な回復力でも回復アルゴリズムの修理ルーティングテーブルの前に障害の周りのオーバーレイルーティングすることができる程度を測定します。ルーティング回復と静的回復力の両方が障害の正確でタイムリーな検出に依存しています。"
    },
    {
      "indent": 3,
      "text": "There are a number of situations in which some nodes in a Peer-to-Peer (P2P) overlay may malfunction or behave badly. For example, these nodes may be disabled, congested, or may be misrouting messages. The impact of these malfunctions on the overlay network may be a degradation of quality of service provided collectively by the peers in the overlay network or an interruption of the overlay services. It is desirable to identify malfunctioning or badly behaving peers through diagnostic tools and exclude or reject them from the P2P system. Node failures may also be caused by failures of underlying layers. For example, recovery from an incorrect overlay topology may be slow when the speed at which IP routing recovers after link failures is very slow. Moreover, if a backbone link fails and the failover is slow, the network may be partitioned, leading to partitions of overlay topologies and inconsistent routing results between different partitioned components.",
      "ja": "ピア・ツー・ピア（P2P）オーバーレイの一部のノードが故障又はひどく振る舞う可能性のある多くの状況があります。例えば、これらのノードは、輻輳無効にすることができ、又はmisroutingメッセージであってもよいです。オーバレイネットワーク上のこれらの誤動作の影響は、オーバーレイ・ネットワーク内のピアまたはオーバーレイサービスの中断によって集合的に提供するサービスの品質の低下であってもよいです。診断ツールによって誤動作したり、ひどく振る舞うピアを特定し、P2Pシステムからそれらを除外するか、拒否することが望ましいです。ノード障害はまた、下地層の障害によって引き起こされ得ます。 IPルーティングは、リンク障害後に回復する速度が非常に遅い場合たとえば、間違ったオーバーレイ・トポロジーからの回復が遅くなることがあります。バックボーン・リンクが失敗し、フェイルオーバーが遅い場合はまた、ネットワークは、オーバーレイ・トポロジと異なるパーティション構成要素間の一貫性のないルーティング結果のパーティションにつながる、分割されてもよいです。"
    },
    {
      "indent": 3,
      "text": "Some keep-alive algorithms based on periodic probe and acknowledge mechanisms enable accurate and timely detection of failures of one node's neighbors [Overlay-Failure-Detection], but these algorithms by themselves can only detect the disabled neighbors using the periodic method. This may not be sufficient for the service provider operating the overlay network.",
      "ja": "定期的なプローブに基づいていくつかのキープアライブのアルゴリズムとメカニズムを認める一方のノードの隣人の失敗の正確でタイムリーな検出[オーバーレイ予防-検出]を有効にしても、それ自体で、これらのアルゴリズムは、唯一の定期的な方法を使用して無効に隣人を検出することができます。これは、オーバーレイネットワークを動作させるサービスプロバイダのために十分ではないかもしれません。"
    },
    {
      "indent": 3,
      "text": "A P2P overlay diagnostic framework supporting periodic and on-demand methods for detecting node failures and network failures is desirable. This document describes a general P2P overlay diagnostic extension to the base protocol RELOAD [RFC6940] and is intended as a complement to keep-alive algorithms in the P2P overlay itself. Readers are advised to consult [P2PSIP-CONCEPTS] for further background on the problem domain.",
      "ja": "ノード障害とネットワーク障害を検出するための周期的なオンデマンドの方法をサポートするP2Pオーバーレイ診断フレームワークが望ましいです。この文書は、一般的なP2PベースプロトコルRELOAD [RFC6940]に診断拡張オーバーレイ説明とキープアライブするためのアルゴリズムをP2Pオーバーレイ自体に補完するものとして意図されています。読者は、問題領域の詳細な背景について[P2PSIP-CONCEPTS]を相談することをお勧めします。"
    },
    {
      "indent": 0,
      "text": "2. Terminology",
      "section_title": true,
      "ja": "2.用語"
    },
    {
      "indent": 3,
      "text": "This document uses the concepts defined in RELOAD [RFC6940]. In addition, the following terms are used in the document:",
      "ja": "この文書では、RELOAD [RFC6940]で定義された概念を使用しています。また、以下の用語が文書で使用されています。"
    },
    {
      "indent": 3,
      "text": "overlay hop: One overlay hop is one portion of path between the initiator node and the destination peer in a RELOAD overlay. Each time packets are passed to the next node in the RELOAD overlay, one overlay hop occurs.",
      "ja": "オーバーレイホップ：一のオーバーレイホップは、イニシエータノード、リロードオーバーレイの宛先ピアとの間の経路の一部です。各時間パケットがリロードオーバレイにおける次のノードに渡され、あるオーバーレイホップが生じます。"
    },
    {
      "indent": 3,
      "text": "underlay hop: An underlay hop is one portion of the path between source and destination in the IP layer. Each time packets are passed to the next IP-layer device, an underlay hop occurs.",
      "ja": "下敷きホップ：アンダーレイホップはIP層における送信元と宛先との間の経路の一部です。各時間パケットが次のIP層のデバイスに渡され、アンダーレイホップが発生します。"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はあります[RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "3. Diagnostic Scenarios",
      "section_title": true,
      "ja": "3.診断シナリオ"
    },
    {
      "indent": 3,
      "text": "P2P systems are self-organizing, and ideally the setup and configuration of individual P2P nodes requires no network management in the traditional sense. However, users of an overlay as well as P2P service providers may contemplate usage scenarios where some monitoring and diagnostics are required. We present a simple connectivity test and some useful diagnostic information that may be used in such diagnostics.",
      "ja": "P2Pシステムでは、自己組織化され、理想的に設定し、個々のP2Pノードの構成は、従来の意味でのネットワーク管理を必要としません。しかし、オーバーレイのユーザーだけでなく、P2Pサービスプロバイダは、いくつかの監視および診断が必要とされている使用シナリオを考えることがあります。我々は、単純な接続性テストなどの診断に使用することができるいくつかの有用な診断情報を提供します。"
    },
    {
      "indent": 3,
      "text": "The common usage scenarios for P2P diagnostics can be broadly categorized in three classes:",
      "ja": "P2Pの診断のための一般的な使用シナリオは、大きく3つのクラスに分類することができます。"
    },
    {
      "indent": 3,
      "text": "a. Automatic diagnostics built into the P2P overlay routing protocol. Nodes perform periodic checks of known neighbors and remove those nodes from the routing tables that fail to respond to connectivity checks [Handling_Churn_in_a_DHT]. Unresponsive nodes may only be temporarily disabled, for example, due to a local cryptographic processing overload, disk processing overload, or link overload. It is therefore useful to repeat the connectivity checks to see nodes have recovered and can be again placed in the routing tables. This process is known as 'failed node recovery' and can be optimized as described in the paper \"Handling Churn in a DHT\" [Handling_Churn_in_a_DHT].",
      "ja": "A。 P2Pオーバーレイルーティングプロトコルに組み込まれた自動診断。ノードは、既知の近隣の定期的なチェックを実行し、接続性チェック[Handling_Churn_in_a_DHT]に応答しないルーティングテーブルからそのノードを削除します。応答しないノードのみによるローカル暗号処理の過負荷、ディスク処理の過負荷、またはリンク過負荷に、例えば、一時的に無効とすることができます。ノードが回復しており、再度ルーティングテーブルに配置することができる見るために接続性チェックを繰り返すことが有用です。このプロセスは、「障害が発生したノードの回復」として知られており、[Handling_Churn_in_a_DHT「DHTにチャーンを処理する」論文に記載されているように最適化することができます。"
    },
    {
      "indent": 3,
      "text": "b. Diagnostics used by a particular node to follow up on an individual user complaint or failure. For example, a technical support staff member may use a desktop sharing application (with the permission of the user) to remotely determine the health of, and possible problems with, the malfunctioning node. Part of the remote diagnostics may consist of simple connectivity tests with other nodes in the P2P overlay and retrieval of statistics from nodes in the overlay. The simple connectivity tests are not dependent on the type of P2P overlay. Note that other tests may be required as well, including checking the health and performance of the user's computer or mobile device and checking the bandwidth of the link connecting the user to the Internet.",
      "ja": "B。個々のユーザの苦情または障害をフォローアップするために、特定のノードによって使用される診断。例えば、テクニカルサポートのスタッフは、遠隔の健康状態を決定するために、（ユーザの許可を得て）、デスクトップ共有アプリケーションを使用してもよいし、故障したノードとの可能性のある問題。遠隔診断の一部は、オーバーレイ内のノードからの統計のP2Pオーバーレイと検索内の他のノードとの単純な接続テストから構成されてもよいです。簡単な接続テストは、P2Pオーバーレイの種類に依存しません。他のテストは、ユーザーのコンピュータやモバイル機器の健全性とパフォーマンスをチェックし、インターネットにユーザーを接続するリンクの帯域幅をチェックするなど、同様に必要とされることに注意してください。"
    },
    {
      "indent": 3,
      "text": "c. P2P system-wide diagnostics used to check the overall health of the P2P overlay network. These include checking the consumption of network bandwidth, checking for the presence of problem links, and checking for abusive or malicious nodes. This is not a trivial problem and has been studied in detail for content and streaming P2P overlays [Diagnostic_Framework] and has not been addressed in earlier documents. While this is a difficult problem, a great deal of information that can help in diagnosing these problems can be obtained by obtaining basic diagnostic information for peers and the network. This document provides a framework for obtaining this information.",
      "ja": "C。 P2Pシステム全体の診断は、P2Pオーバーレイネットワークの全体的な健康状態をチェックするために使用します。これらは、ネットワーク帯域幅の消費量をチェックし、問題リンクの存在をチェックし、虐待や悪意のあるノードをチェックしています。これは些細な問題ではありませんし、コンテンツやストリーミングP2Pオーバーレイ[Diagnostic_Framework]で詳細に研究されており、それ以前の文書で扱われていませんでした。これは難しい問題であるが、これらの問題の診断に役立つことができ、多くの情報は、仲間やネットワークのための基本的な診断情報を取得することによって得ることができます。この文書では、この情報を取得するためのフレームワークを提供します。"
    },
    {
      "indent": 0,
      "text": "4. Data Collection Mechanisms",
      "section_title": true,
      "ja": "4.データ収集の仕組み"
    },
    {
      "indent": 0,
      "text": "4.1. Overview of Operations",
      "section_title": true,
      "ja": "4.1。事業の概要"
    },
    {
      "indent": 3,
      "text": "The diagnostic mechanisms described in this document are primarily intended to detect and locate failures or monitor performance in P2P overlay networks. It provides mechanisms to detect and locate malfunctioning or badly behaving nodes including disabled nodes, congested nodes, and misrouting peers. It provides a mechanism to detect direct connectivity or connectivity to a specified node, a mechanism to detect the availability of specified resource records, and a mechanism to discover P2P overlay topology and the underlay topology failures.",
      "ja": "この文書に記載された診断機構は、主に検出し、障害を見つけるか、P2Pオーバーレイネットワークにおけるパフォーマンスを監視することを意図しています。それは無効ノード、輻輳ノード、及びmisroutingピア含む誤動作または悪い行動ノードを検出して検索するメカニズムを提供します。これは、P2Pオーバーレイ・トポロジとアンダーレイトポロジ障害を発見するために指定されたノード、指定されたリソースレコードの利用可能性を検出するための機構、及び機構に直接接続または接続を検出するための機構を提供します。"
    },
    {
      "indent": 3,
      "text": "The RELOAD diagnostics extensions define two mechanisms to collect data. The first is an extension to the RELOAD Ping mechanism that allows diagnostic data to be queried from a node as well as to diagnose the path to that node. The second is a new method, PathTrack, for collecting diagnostic information iteratively. Payloads for these mechanisms allowing diagnostic data to be collected and represented are presented, and additional error codes are introduced. Essentially, this document reuses the RELOAD specification [RFC6940] and extends it to introduce the new",
      "ja": "RELOAD診断の拡張機能は、データを収集するために2つのメカニズムを定義します。第一は、そのノードへのパスを診断する診断データがノードから照会することを可能にするだけでなく、リロードピング機構の拡張です。第二は、反復的な診断情報を収集するための新しい方法、PathTrack、です。診断データを収集し、表現することを可能にするこれらのメカニズムのためのペイロードが提示され、追加のエラーコードが導入されます。基本的に、このドキュメントはRELOAD仕様[RFC6940]を再利用し、新しいを導入し、それを拡張します"
    },
    {
      "indent": 3,
      "text": "diagnostics methods. The extensions strictly follow how RELOAD specifies message routing, transport, NAT traversal, and other RELOAD protocol features.",
      "ja": "診断方法。 RELOADは、メッセージのルーティング、輸送、NATトラバーサル、および他のRELOADプロトコル機能を指定する方法の拡張機能は、厳密に従ってください。"
    },
    {
      "indent": 3,
      "text": "This document primarily describes how to detect and locate failures including disabled nodes, congested nodes, misrouting behaviors, and underlying network faults in P2P overlay networks through a simple and efficient mechanism. This mechanism is modeled after the ping/ traceroute paradigm: ping [RFC792] is used for connectivity checks, and traceroute is used for hop-by-hop fault localization as well as path tracing. This document specifies a \"ping-like\" mode (by extending the RELOAD Ping method to gather diagnostics) and a \"traceroute-like\" mode (by defining the new PathTrack method) for diagnosing P2P overlay networks.",
      "ja": "この文書では、主に、シンプルかつ効率的なメカニズムを通じて無効ノード、混雑したノード、misrouting行動、およびP2Pオーバーレイネットワークにおける基本的なネットワーク障害などの障害を検出して検索する方法を説明します。 pingが[RFC792]接続性チェックのために使用され、およびtracerouteは、ホップバイホップ障害局在ならびにパストレースのために使用される。この機構は、ピング/トレースルートパラダイムの後にモデル化されます。この文書では、P2Pオーバーレイネットワークを診断するための「ピング様」モード（診断を収集するために、RELOADピング法を拡張することによって）及び（新しいPathTrackメソッドを定義することによって）「tracerouteの様」モードを指定します。"
    },
    {
      "indent": 3,
      "text": "One way these tools can be used is to detect the connectivity to the specified node or the availability of the specified resource record through the extended Ping operation. Once the overlay network receives some alarms about overlay service degradation or interruption, a Ping is sent. If the Ping fails, one can then send a PathTrack to determine where the fault lies.",
      "ja": "これらのツールを使用することができる一つの方法は、拡張ping操作で指定されたノードまたは指定されたリソースレコードの可用性への接続を検出することです。オーバーレイネットワークは、オーバーレイサービス低下や中断についてのいくつかのアラームを受信すると、Pingのが送信されます。 pingが失敗した場合、1は、障害がどこにあるかを決定するためにPathTrackを送ることができます。"
    },
    {
      "indent": 3,
      "text": "The diagnostic information can only be provided to authorized nodes. Some diagnostic information can be provided to all the participants in the P2P overlay, and some other diagnostic information can only be provided to the nodes authorized by the local or overlay policy. The authorization depends on the type of the diagnostic information and the administrative considerations and is application specific.",
      "ja": "診断情報は、許可されたノードに提供することができます。いくつかの診断情報は、P2Pオーバレイ内のすべての参加者に提供することができ、いくつかの他の診断情報は、ローカルまたはオーバーレイポリシーによって許可されたノードに提供することができます。認可は、診断情報の種類と管理の考慮事項に依存し、アプリケーション固有のものです。"
    },
    {
      "indent": 3,
      "text": "This document considers the general administrative scenario based on diagnostic Kind, where a whole overlay can authorize a certain kind of diagnostic information to a small list of particular nodes (e.g., administrative nodes). That means if a node gets the authorization to access a diagnostic Kind, it can access that information from all nodes in the overlay network. It leaves the scenario where a particular node authorizes its diagnostic information to a particular list of nodes out of scope. This could be achieved by extension of this document if there is a requirement in the near future. The default policy or access rule for a type of diagnostic information is \"deny\" unless specified in the diagnostics extension document. As the RELOAD protocol already requires that each message carries the message signature of the sender, the receiver of the diagnostics requests can use the signature to identify the sender. It can then use the overlay configuration file with this signature to determine which types of diagnostic information that node is authorized for.",
      "ja": "この文書は全体オーバーレイが特定のノード（例えば、管理ノード）の小さなリストに診断情報の特定の種類を許可することができ、診断種類に基づいて、一般的な管理シナリオを考慮する。すなわち、ノードは、診断種類にアクセスするための許可を取得した場合、それはオーバーレイ・ネットワーク内のすべてのノードからの情報にアクセスできることを意味します。これは、特定のノードが範囲外のノードの特定のリストに、その診断情報を許可するシナリオを残します。近い将来の要件がある場合、これは、このドキュメントの拡張によって達成することができました。診断情報の種類のデフォルトポリシーやアクセスルールは、診断拡張文書に指定がない限り、「拒否」です。リロードプロトコルは既に各メッセージが送信者のメッセージの署名を運ぶことを必要として、診断要求の受信は、送信者を識別するために署名を使用することができます。これは、そのノードがために認可された診断情報のどのタイプを決定するために、この署名付きオーバーレイ設定ファイルを使用することができます。"
    },
    {
      "indent": 3,
      "text": "In the remainder of this section we define mechanisms for collecting data, as well as the specific protocol extensions (message extensions, new methods, and error codes) required to collect this information. In Section 5 we discuss the format of the data collected, and in Section 6 we discuss detailed message processing.",
      "ja": "このセクションの残りでは、この情報を収集するために必要なデータを収集するための機構、ならびに特定のプロトコル拡張（メッセージの拡張、新規な方法、およびエラー・コード）を定義します。 5章では、収集されたデータの形式を議論し、第6節では、詳細なメッセージ処理を議論します。"
    },
    {
      "indent": 3,
      "text": "It is important to note that the mechanisms described in this document do not guarantee that the information collected is in fact related to the previous failures. However, using the information from previous traversed nodes, the user (or management system) may be able to infer the problem. Symmetric routing can be achieved by using the Via List [RFC6940] (or an alternate DHT routing algorithm), but the response path is not guaranteed to be the same.",
      "ja": "この文書で説明するメカニズムは、収集した情報は、実際には、以前の障害に関連していることを保証するものではないことに注意することが重要です。しかし、前横断ノードからの情報を使用して、ユーザ（または管理システム）は、問題を推測することができるかもしれません。対称ルーティングビアリスト[RFC6940]（または代替DHTルーティングアルゴリズム）を使用することによって達成することができるが、応答パスが同じであることが保証されません。"
    },
    {
      "indent": 0,
      "text": "4.2. \"Ping-like\" Behavior: Extending Ping",
      "section_title": true,
      "ja": "4.2。 「ピンポンのような」行動：Pingの拡張"
    },
    {
      "indent": 3,
      "text": "To provide \"ping-like\" behavior, the RELOAD Ping method is extended to collect diagnostic data along the path. The request message is forwarded by the intermediate peers along the path and then terminated by the responsible peer. After optional local diagnostics, the responsible peer returns a response message. If an error is found when routing, an error response is sent to the initiator node by the intermediate peer.",
      "ja": "「ピング様」挙動を提供するために、リロードのPing方法は、経路に沿って診断データを収集するように拡張されます。要求メッセージは、経路に沿った中間ピアによって転送し、次いで責任ピアによって終了されます。オプションのローカル診断した後、責任ピアは、応答メッセージを返します。ルーティング時に、エラーが検出された場合、エラー応答が中間ピアによって開始ノードに送信されます。"
    },
    {
      "indent": 3,
      "text": "The message flow of a Ping message (with diagnostic extensions) is as follows:",
      "ja": "次のように（診断拡張子を持つ）Pingメッセージのメッセージ・フローです。"
    },
    {
      "indent": 4,
      "text": "Peer A              Peer B               Peer C             Peer D\n  |                    |                    |                    |\n  |(1). PingReq        |                    |                    |\n  |------------------->|(2). PingReq        |                    |\n  |                    |------------------->|(3). PingReq        |\n  |                    |                    |------------------->|\n  |                    |                    |                    |\n  |                    |                    |<-------------------|\n  |                    |<-------------------|(4). PingAns        |\n  |<-------------------|(5). PingAns        |                    |\n  |(6). PingAns        |                    |                    |\n  |                    |                    |                    |",
      "raw": true
    },
    {
      "indent": 18,
      "text": "Figure 1: Ping Diagnostic Message Flow",
      "ja": "図1：Pingの診断メッセージフロー"
    },
    {
      "indent": 0,
      "text": "4.2.1. RELOAD Request Extension: Ping",
      "section_title": true,
      "ja": "4.2.1。 RELOADリクエスト拡張子：Pingの"
    },
    {
      "indent": 3,
      "text": "To extend the Ping request for use in diagnostics, a new extension of RELOAD is defined. The structure for a MessageExtension in RELOAD is defined as:",
      "ja": "診断で使用するためのPing要求を拡張するには、RELOADの新しい拡張機能が定義されています。リロードでMessageExtensionための構造が次のように定義されます。"
    },
    {
      "indent": 12,
      "text": "struct {\n  MessageExtensionType  type;\n  Boolean               critical;\n  opaque                extension_contents<0..2^32-1>;\n} MessageExtension;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "For the Ping request extension, we define a new MessageExtensionType, extension 0x2 named \"Diagnostic_Ping\", as specified in Table 4. The extension contents consists of a DiagnosticsRequest structure, defined in Section 5.1. This extension MAY be used for new requests of the Ping method and MUST NOT be included in requests using any other method.",
      "ja": "拡張内容は表4に指定されているようPing要求拡張のために、私たちは、新しいMessageExtensionType、「Diagnostic_Ping」という名前の拡張を0x2を定義するセクション5.1で定義されたDiagnosticsRequest構造、構成されています。この拡張は、Pingの方法の新しい要求のために用いることができ、他の方法を使用して要求に含まれてはいけません。"
    },
    {
      "indent": 3,
      "text": "This extension is not critical. If a peer does not support the extension, they will simply ignore the diagnostic portion of the message and will treat the message as if it were a normal ping. Senders MUST accept a response that lacks diagnostic information and SHOULD NOT resend the message expecting a reply. Receivers who receive a method other than Ping including this extension MUST ignore the extension.",
      "ja": "この拡張は重要ではありません。ピアが拡張をサポートしていない場合、彼らは単にメッセージの診断部分を無視し、それは通常のpingであるかのようにメッセージを扱います。送信者は、診断情報が欠けているとの回答を期待してメッセージを再送すべきではない応答を受け入れなければなりません。この拡張機能を含むのPing以外の方法を受け取る受信機は拡張子を無視しなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.3. \"Traceroute-like\" Behavior: The PathTrack Method",
      "section_title": true,
      "ja": "4.3。 「tracerouteのような」行動：PathTrack方法"
    },
    {
      "indent": 3,
      "text": "We define a simple PathTrack method for retrieving diagnostic information iteratively.",
      "ja": "私たちは、反復的に診断情報を取得するための簡単なPathTrackメソッドを定義します。"
    },
    {
      "indent": 3,
      "text": "The operation of this request is shown below in Figure 2. The initiator node A asks its neighbor B which is the next hop peer to the destination ID, and B returns a message with the next hop peer C information, along with optional diagnostic information for B to the initiator node. Then the initiator node A asks the next hop peer C (direct response routing [RFC7263] or via symmetric routing) to return next hop peer D information and diagnostic information of C. Unless a failure prevents the message from being forwarded, this step can be repeated until the request reaches responsible peer D for the destination ID and retrieves the diagnostic information of peer D.",
      "ja": "この要求の操作は、イニシエータノードAが宛先IDへのネクストホップピアでその隣接Bを依頼図2に下に示されており、Bはのためのオプションの診断情報と共に、次のホップピアCの情報を含むメッセージを返しますイニシエータノードB。次いで、イニシエータノードAに障害が転送されてからメッセージを防止しない限り次のホップピアDの情報及びCの診断情報を返すためにネクストホップピアC（直接応答ルーティング[RFC7263]または対称ルーティングを介して）を要求し、このステップであることができます要求は宛先IDを担当するピアDに到達すると、ピアDの診断情報を取得するまで繰り返します"
    },
    {
      "indent": 3,
      "text": "The message flow of a PathTrack message (with diagnostic extensions) is as follows:",
      "ja": "次のように（診断拡張子を持つ）PathTrackメッセージのメッセージ・フローです。"
    },
    {
      "indent": 3,
      "text": "Peer-A              Peer-B               Peer-C             Peer-D\n  |                    |                    |                    |\n  |(1).PathTrackReq    |                    |                    |\n  |------------------->|                    |                    |\n  |(2).PathTrackAns    |                    |                    |\n  |<-------------------|                    |                    |\n  |                    |(3).PathTrackReq    |                    |\n  |--------------------|------------------->|                    |\n  |                    |(4).PathTrackAns    |                    |\n  |<-------------------|--------------------|                    |\n  |                    |                    |(5).PathTrackReq    |\n  |--------------------|--------------------|------------------->|\n  |                    |                    |(6).PathTrackAns    |\n  |<-------------------|--------------------|--------------------|\n  |                    |                    |                    |",
      "raw": true
    },
    {
      "indent": 16,
      "text": "Figure 2: PathTrack Diagnostic Message Flow",
      "ja": "図2：PathTrack診断メッセージフロー"
    },
    {
      "indent": 3,
      "text": "There have been proposals that RouteQuery and a series of Fetch requests can be used to replace the PathTrack mechanism; however, in the presence of high rates of churn, such an operation would not, strictly speaking, provide identical results, as the path may change between RouteQuery and Fetch operations. While obviously the path could change between steps of PathTrack as well, with a single message rather than two messages for query and fetch, less inconsistency is likely, and thus the use of a single message is preferred.",
      "ja": "RouteQueryとフェッチ要求のシリーズはPathTrackメカニズムを置き換えるために使用することができるの提案がなされています。パスはRouteQuery間で変更や操作をフェッチすることができるしかし、解約の高い割合の存在下で、このような動作は、厳密には、同一の結果を提供しないであろう。当然ながら、パスがクエリの単一のメッセージを用いて、同様にPathTrackの工程の間ではなく、2つのメッセージを変更し、フェッチができ、より少ない矛盾がそうであるので、単一のメッセージを使用することが好ましいです。"
    },
    {
      "indent": 3,
      "text": "Given that in a typical diagnostic scenario the peer sending the PathTrack request desires to obtain information about the current path to the destination, in the event that successive calls to PathTrack return different paths, the results should be discarded and the request resent, ensuring that the second request traverses the appropriate path.",
      "ja": "典型的な診断シナリオでPathTrack要求を送信するピアがことを保証する、PathTrackに連続呼び出しが異なる経路、結果を破棄しなければならないと要求の再送を返した場合には、目的地までの現在の経路に関する情報を取得することを望むことを考えると第2の要求は、適切なパスを横切ります。"
    },
    {
      "indent": 0,
      "text": "4.3.1. New RELOAD Request: PathTrack",
      "section_title": true,
      "ja": "4.3.1。新RELOAD要求：PathTrack"
    },
    {
      "indent": 3,
      "text": "This document defines a new RELOAD method, PathTrack, to retrieve the diagnostic information from the intermediate peers along the routing path. At each step of the PathTrack request, the responsible peer responds to the initiator node with requested status information. Status information can include a peer's congestion state, processing power, available bandwidth, the number of entries in its neighbor table, uptime, identity, network address information, and next hop peer information.",
      "ja": "この文書は、新しいRELOAD法、PathTrack、ルーティング経路に沿った中間ピアから診断情報を取得するために定義します。 PathTrack要求の各段階で、責任ピアは、要求されたステータス情報をイニシエータノードに応答します。ステータス情報は、電力、利用可能な帯域幅、その隣のテーブルのエントリ数、稼働時間、アイデンティティ、ネットワークアドレス情報、およびネクストホップピア情報を処理し、ピアの輻輳状態を含めることができます。"
    },
    {
      "indent": 3,
      "text": "A PathTrack request specifies which diagnostic information is requested using a DiagnosticsRequest data structure, which is defined and discussed in detail in Section 5.1. Base information is requested by setting the appropriate flags in the data structure in the request. If all flags are clear (no bits are set), then the PathTrack request is only used for requesting the next hop information. In this case, the iterative mode of PathTrack is degraded to a RouteQuery method that is only used for checking the liveness of the peers along the routing path. The PathTrack request can be routed using direct response routing or other routing methods chosen by the initiator node.",
      "ja": "PathTrack要求が定義され、セクション5.1で詳細に説明されるDiagnosticsRequestデータ構造を使用して要求された診断れる情報を指定します。ベース情報は、要求内のデータ構造内の適切なフラグを設定することによって要求されます。すべてのフラグが（何ビットが設定されていない）をクリアしている場合、PathTrack要求は次のホップ情報を要求するためだけに使用されます。この場合、PathTrackの反復モードは、ルーティングパスに沿ってピアの生存性をチェックするために使用されるRouteQuery方法に分解されます。 PathTrack要求は直接応答ルーティングまたはイニシエータノードによって選択された他のルーティング方法を使用してルーティングすることができます。"
    },
    {
      "indent": 3,
      "text": "A response to a successful PathTrackReq is a PathTrackAns message. The PathTrackAns contains general diagnostic information in the payload, returned using a DiagnosticResponse data structure. This data structure is defined and discussed in detail in Section 5.2. The information returned is determined based on the information requested in the flags in the corresponding request.",
      "ja": "成功PathTrackReqに対する応答はPathTrackAnsメッセージです。 PathTrackAnsペイロードにおける一般的な診断情報が含まれている、DiagnosticResponseデータ構造を使用して返さ。このデータ構造は、セクション5.2で定義され、詳細に説明します。返された情報は、対応する要求のフラグに要求された情報に基づいて決定されます。"
    },
    {
      "indent": 0,
      "text": "4.3.1.1. PathTrack Request",
      "section_title": true,
      "ja": "4.3.1.1。 PathTrackリクエスト"
    },
    {
      "indent": 3,
      "text": "The structure of the PathTrack request is as follows:",
      "ja": "次のようにPathTrack要求の構造は次のとおりです。"
    },
    {
      "indent": 27,
      "text": "struct{\n    Destination destination;\n    DiagnosticsRequest request;\n}PathTrackReq;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The fields of the PathTrackReq are as follows:",
      "ja": "次のようにPathTrackReqのフィールドは、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "destination: The destination that the initiator node is interested in. This may be any valid destination object, including a NodeID, opaque ids, or ResourceID. One example should be noted that, for debugging purposes, the initiator will use the destination ID as it was used when failure happened.",
      "ja": "宛先：イニシエータノードが興味を持っている先のNodeIDこれは、不透明なIDS、またはのResourceIDを含む、任意の有効な宛先オブジェクトであってもよいです。一つの例は、障害が起こったときにそれを使用したとして、デバッグの目的で、イニシエータは先のIDを使用することに留意すべきです。"
    },
    {
      "indent": 3,
      "text": "request: A DiagnosticsRequest, as discussed in Section 5.1.",
      "ja": "リクエスト：DiagnosticsRequest、5.1節で述べたように。"
    },
    {
      "indent": 0,
      "text": "4.3.1.2. PathTrack Response",
      "section_title": true,
      "ja": "4.3.1.2。 PathTrackレスポンス"
    },
    {
      "indent": 3,
      "text": "The structure of the PathTrack response is as follows:",
      "ja": "次のようにPathTrack応答の構造は次のとおりです。"
    },
    {
      "indent": 29,
      "text": "struct{\n     Destination next_hop;\n     DiagnosticsResponse response;\n }PathTrackAns;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The fields of the PathTrackAns are as follows:",
      "ja": "次のようにPathTrackAnsのフィールドは、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "next_hop: The information of the next hop node from the responding intermediate peer to the destination. If the responding peer is the responsible peer for the destination ID, then the next_hop node ID equals the responding node ID, and after receiving a PathTrackAns where the next_hop node ID equals the responding node ID, the initiator MUST stop the iterative process.",
      "ja": "NEXT_HOP：宛先への応答の中間ピアから次ホップノードの情報。応答ピアが宛先IDを担当するピアである場合、NEXT_HOPノードIDは、応答ノードのIDに等しく、NEXT_HOPノードIDが応答ノードIDに等しいPathTrackAnsを受信した後、開始剤は、反復処理を停止する必要があります。"
    },
    {
      "indent": 3,
      "text": "response: A DiagnosticsResponse, as discussed in Section 5.2.",
      "ja": "応答：5.2節で述べたようにDiagnosticsResponse、。"
    },
    {
      "indent": 0,
      "text": "4.4. Error Code Extensions",
      "section_title": true,
      "ja": "4.4。エラーコードの拡張"
    },
    {
      "indent": 3,
      "text": "This document extends the error response method defined in the RELOAD specification to support error cases resulting from diagnostic queries. When an error is encountered in RELOAD, the Message Code 0xffff is returned. The ErrorResponse structure includes an error code. We define new error codes to report possible error conditions detected while performing diagnostics:",
      "ja": "この文書は、診断クエリから生じるエラーケースをサポートするためにリロード仕様で定義されたエラー応答方法を拡張します。エラーがRELOADに遭遇した場合、メッセージコードは0xffffが返されます。 ErrorResponse構造は、エラーコードを含みます。私たちは、診断を実行中に検出可能なエラー条件を報告するために、新しいエラーコードを定義します。"
    },
    {
      "indent": 6,
      "text": "Code Value Error Code Name 0x15 Error_Underlay_Destination_Unreachable 0x16 Error_Underlay_Time_Exceeded 0x17 Error_Message_Expired 0x18 Error_Upstream_Misrouting 0x19 Error_Loop_Detected 0x1a Error_TTL_Hops_Exceeded",
      "ja": "コード値エラーコード名0x15のError_Underlay_Destination_Unreachable 0x16 0x17のError_Underlay_Time_Exceeded Error_Message_Expired 0x18のError_Upstream_Misrouting 0x19 Error_Loop_Detected 0x1a Error_TTL_Hops_Exceeded"
    },
    {
      "indent": 3,
      "text": "The error code is returned by the upstream node before the failure node. The upstream node uses the normal ping to detect the failure type and return it to the initiator node, which will help the user (initiator node) to understand where the failure happened and what kind of error happened, as the failure may happen at the same location and for the same reason when sending the normal message and the diagnostics message.",
      "ja": "エラーコードは、障害ノードの前に上流のノードによって戻されます。障害が同じで起こり得るように、障害が起こったエラーの種類が起こった場合、上流ノードは理解する障害の種類を検出し、ユーザ（イニシエータノード）を助けるイニシエータノード、にそれを戻すために通常のpingを使用し場所と通常のメッセージと診断メッセージを送るのと同じ理由のために。"
    },
    {
      "indent": 3,
      "text": "As defined in RELOAD, additional information may be stored (in an implementation-specific way) in the optional error_info byte string. While the specifics are obviously left to the implementation, as an example, in the case of 0x15, the error_field could be used to provide additional information as to why the underlay destination is unreachable (net unreachable, host unreachable, fragmentation needed, etc.).",
      "ja": "リロードで定義されるように、追加の情報は、オプションERROR_INFOバイト列に（実装固有の方法で）記憶することができます。詳細は明らかに実装に任されているが、一例として、0x15の場合に、ERROR_FIELDはアンダーレイ先が（等、必要な正味到達でき、ホスト到達不能、フラグメンテーション）到達できない理由に関する追加情報を提供するために使用することができます。"
    },
    {
      "indent": 0,
      "text": "5. Diagnostic Data Structures",
      "section_title": true,
      "ja": "5.診断データ構造"
    },
    {
      "indent": 3,
      "text": "Both the extended Ping method and PathTrack method use the following common diagnostics data structures to collect data. Two common structures are defined: DiagnosticsRequest for requesting data and DiagnosticsResponse for returning the information.",
      "ja": "拡張ping方式とPathTrack方法の両方がデータを収集するために、次の一般的な診断データ構造を使用します。二つの一般的な構造が定義されています。DiagnosticsRequest情報を返すためのデータとDiagnosticsResponseを要求します。"
    },
    {
      "indent": 0,
      "text": "5.1. DiagnosticsRequest Data Structure",
      "section_title": true,
      "ja": "5.1。診断要求データ構造"
    },
    {
      "indent": 3,
      "text": "The DiagnosticsRequest data structure is used to request diagnostic information and has the following form:",
      "ja": "DiagnosticsRequestデータ構造は、診断情報を要求するために使用され、以下の形式を有します。"
    },
    {
      "indent": 10,
      "text": "enum{ (2^16-1) } DiagnosticKindId;",
      "ja": "列挙{（2 ^ 16-1）} DiagnosticKindId。"
    },
    {
      "indent": 10,
      "text": "struct{\n    DiagnosticKindId kind;\n    opaque  diagnostic_extension_contents<0..2^32-1>;\n}DiagnosticExtension;",
      "raw": true
    },
    {
      "indent": 10,
      "text": "struct{\n    uint64 expiration;\n    uint64 timestamp_initiated;\n    uint64 dMFlags;\n    uint32 ext_length;\n    DiagnosticExtension diagnostic_extensions_list<0..2^32-1>;\n }DiagnosticsRequest;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The fields in the DiagnosticsRequest are as follows:",
      "ja": "次のように診断要求内のフィールドは以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "expiration: The time when the request will expire represented as the number of milliseconds elapsed since midnight Jan 1, 1970 UTC (not counting leap seconds). This will have the same values for seconds as standard UNIX time or POSIX time. More information can be found at \"Unix time\" in Wikipedia [UnixTime]. This value MUST have a value between 1 and 600 seconds in the future. This value is used to prevent replay attacks.",
      "ja": "有効期限：リクエストが深夜1970年1月1日UTC（うるう秒を数えていない）からの経過ミリ秒数として表さ期限切れとなる時間。これは、UNIXの標準時間またはPOSIX時間として秒に同じ値を持つことになります。詳細については、[UnixTime]ウィキペディアに「Unixの時間」で見つけることができます。この値は、将来的には1から600秒の間の値でなければなりません。この値は、リプレイ攻撃を防ぐために使用されます。"
    },
    {
      "indent": 3,
      "text": "timestamp_initiated: The time when the diagnostics request was initiated, represented as the number of milliseconds elapsed since midnight Jan 1, 1970 UTC (not counting leap seconds). This will have the same values for seconds as standard UNIX time or POSIX time.",
      "ja": "timestamp_initiated：診断要求が開始された時間は、深夜1970年1月1日UTC（うるう秒を数えていない）からの経過ミリ秒数として表現しました。これは、UNIXの標準時間またはPOSIX時間として秒に同じ値を持つことになります。"
    },
    {
      "indent": 3,
      "text": "dMFlags: A mandatory field that is an unsigned 64-bit integer indicating which base diagnostic information the request initiator node is interested in. The initiator sets different bits to retrieve different kinds of diagnostic information. If dMFlags is set to zero, then no base diagnostic information is conveyed in the PathTrack response. If dMFlags is set to all \"1\"s, then all base diagnostic information values are requested. A request may set any number of the flags to request the corresponding diagnostic information.",
      "ja": "dMFlags：要求のイニシエータノードが興味のある診断情報の基礎を示す符号なし64ビット整数であり、イニシエータは、診断情報の種類を取得するために、異なるビットを設定する必須フィールド。 dMFlagsがゼロに設定されている場合、何のベース診断情報がPathTrack応答で搬送されていません。 dMFlagsが全て「1」に設定されている場合は、すべてのベースの診断情報の値が要求されます。要求は、対応する診断情報を要求するためにフラグの任意の数を設定してもよいです。"
    },
    {
      "indent": 6,
      "text": "Note this memo specifies the initial set of flags; the flags can be extended. The dMflags indicate general diagnostic information. The mapping between the bits in the dMFlags and the diagnostic Kind ID presented is as described in Section 9.1.",
      "ja": "このメモは、フラグの初期設定を指定します注意してください。フラグは、拡張することができます。 dMflagsは、一般的な診断情報を示しています。セクション9.1で説明したようにdMFlagsのビットと提示診断種類のIDの間のマッピングです。"
    },
    {
      "indent": 3,
      "text": "ext_length: The length of the extended diagnostic request information in bytes. If the value is greater than or equal to 1, then some extended diagnostic information is being requested on the assumption this information will be included in the response if the recipient understands the extended request and is willing to provide it. The specific diagnostic information requested is defined in the diagnostic_extensions_list below. A value of zero indicates no extended diagnostic information is being requested. The value of ext_length MUST NOT be negative. Note that it is not the length of the entire DiagnosticsRequest data structure, but of the data making up the diagnostic_extensions_list.",
      "ja": "ext_length：バイトの拡張診断依頼情報の長さ。値が1以上であれば、いくつかの拡張診断情報は、受信者が拡張要求を理解し、それを提供する意思がある場合は、この情報は、応答に含まれる前提として要求されています。要求された特定の診断情報は、以下diagnostic_extensions_listに定義されています。ゼロという値は、拡張診断情報が要求されていない示しています。 ext_lengthの値は負であってはなりません。それは全体DiagnosticsRequestデータ構造の長さではなく、データのdiagnostic_extensions_listを構成していることに注意してください。"
    },
    {
      "indent": 3,
      "text": "diagnostic_extensions_list: Consists of one or more DiagnosticExtension structures (see below) documenting additional diagnostic information being requested. Each DiagnosticExtension consists of the following fields:",
      "ja": "diagnostic_extensions_listは：追加の診断情報が要求されている文書一の以上DiagnosticExtension構造（下記参照）からなります。各DiagnosticExtensionは、次のフィールドで構成されています。"
    },
    {
      "indent": 6,
      "text": "kind: A numerical code indicating the type of extension diagnostic information (see Section 9.2). Note that kinds 0xf000 - 0xfffe are reserved for overlay specific diagnostics and may be used without IANA registration for local diagnostic information. Kinds from 0x0000 to 0x003f MUST NOT be indicated in the diagnostic_extensions_list in the message request, as they may be represented using the dMFlags in a much simpler (and more space efficient) way.",
      "ja": "種類：拡張診断情報の種類を示す数値コード（セクション9.2を参照）。 0xFFFEというオーバーレイ特定の診断のために予約されており、ローカル診断情報のためのIANA登録せずに使用することができる - 種類0XF000ことに注意してください。彼らははるかに簡単（より空間効率的）にdMFlagsを使用して表すことができるようには0x0000から0x003fの種類は、メッセージ要求にdiagnostic_extensions_listに示されてはいけません方法。"
    },
    {
      "indent": 6,
      "text": "diagnostic_extension_contents: The opaque data containing the request for this particular extension. This data is extension dependent.",
      "ja": "diagnostic_extension_contents：この特定の拡張のための要求を含む不透明なデータ。このデータは、拡張機能に依存しています。"
    },
    {
      "indent": 0,
      "text": "5.2. DiagnosticsResponse Data Structure",
      "section_title": true,
      "ja": "5.2。診断レスポンスデータ構造"
    },
    {
      "indent": 3,
      "text": "The DiagnosticsResponse data structure is used to return the diagnostic information and has the following form:",
      "ja": "DiagnosticsResponseデータ構造は、診断情報を返すために使用され、以下の形式を有します。"
    },
    {
      "indent": 15,
      "text": "enum { (2^16-1) } DiagnosticKindId;\nstruct{\n    DiagnosticKindId kind;\n    opaque diagnostic_info_contents<0..2^16-1>;\n}DiagnosticInfo;",
      "raw": true
    },
    {
      "indent": 15,
      "text": "struct{\n    uint64 expiration;\n    uint64 timestamp_initiated;\n    uint64 timestamp_received;\n    uint8 hop_counter;\n    uint32 ext_length;\n    DiagnosticInfo diagnostic_info_list<0..2^32-1>;\n}DiagnosticsResponse;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The fields in the DiagnosticsResponse are as follows:",
      "ja": "次のように診断レスポンス内のフィールドは以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "expiration: The time when the response will expire represented as the number of milliseconds elapsed since midnight Jan 1, 1970 UTC (not counting leap seconds). This will have the same values for seconds as standard UNIX time or POSIX time. This value MUST have a value between 1 and 600 seconds in the future.",
      "ja": "有効期限：応答は深夜1970年1月1日UTC（うるう秒を数えていない）からの経過ミリ秒数として表さ期限切れとなる時間。これは、UNIXの標準時間またはPOSIX時間として秒に同じ値を持つことになります。この値は、将来的には1から600秒の間の値でなければなりません。"
    },
    {
      "indent": 3,
      "text": "timestamp_initiated: This value is copied from the diagnostics request message. The benefit of containing such a value in the response message is that the initiator node does not have to maintain the state.",
      "ja": "timestamp_initiated：この値は、診断要求メッセージからコピーされます。応答メッセージ内のそのような値を含むことの利点は、イニシエータノードは、状態を維持する必要がないことです。"
    },
    {
      "indent": 3,
      "text": "timestamp_received: The time when the diagnostic request was received represented as the number of milliseconds elapsed since midnight Jan 1, 1970 UTC (not counting leap seconds). This will have the same values for seconds as standard UNIX time or POSIX time.",
      "ja": "timestamp_received：診断要求を受信した時刻が深夜1970年1月1日UTC（うるう秒を数えていない）からの経過ミリ秒数として表現。これは、UNIXの標準時間またはPOSIX時間として秒に同じ値を持つことになります。"
    },
    {
      "indent": 3,
      "text": "hop_counter: This field only appears in diagnostic responses. It MUST be exactly copied from the TTL field of the forwarding header in the received request. This information is sent back to the request initiator, allowing it to compute the number of hops that the message traversed in the overlay.",
      "ja": "hop_counter：このフィールドは、診断応答に表示されます。それは丁度受信した要求に転送ヘッダのTTLフィールドからコピーしなければなりません。この情報は、メッセージがオーバーレイに横断ホップの数を計算することができ、バック要求のイニシエータに送信されます。"
    },
    {
      "indent": 3,
      "text": "ext_length: The length of the returned DiagnosticInfo information in bytes. If the value is greater than or equal to 1, then some extended diagnostic information (as specified in the DiagnosticsRequest) was available and is being returned. In that case, this value indicates the length of the returned information. A value of zero indicates no extended diagnostic information is included either because none was requested or the request could not be accommodated. The value of ext_length MUST NOT be negative. Note that it is not the length of the entire DiagnosticsRequest data structure but of the data making up the diagnostic_info_list.",
      "ja": "ext_length：バイト単位で返さDiagnosticInfo情報の長さ。値が1以上であれば、（DiagnosticsRequestで指定されるように）、その後、いくつかの拡張診断情報が利用可能であったと戻されています。その場合には、この値が返された情報の長さを示します。ゼロの値はいずれも要求されなかったか、要求を収容することができなかったので、何の拡張診断情報がいずれか含まれていない示します。 ext_lengthの値は負であってはなりません。それは全体DiagnosticsRequestデータ構造の長さではなく、データのdiagnostic_info_listを構成していることに注意してください。"
    },
    {
      "indent": 3,
      "text": "diagnostic_info_list: consists of one or more DiagnosticInfo structures containing the requested diagnostic_info_contents. The fields in the DiagnosticInfo structure are as follows:",
      "ja": "diagnostic_info_list：要求diagnostic_info_contentsを含む1つ以上のDiagnosticInfo構造で構成されています。次のようにDiagnosticInfo構造体のフィールドは以下のとおりです。"
    },
    {
      "indent": 6,
      "text": "kind: A numeric code indicating the type of information being returned. For base data requested using the dMFlags, this code corresponds to the dMFlag set and is described in Section 5.1. For diagnostic extensions, this code will be identical to the value of the DiagnosticKindId set in the \"kind\" field of the DiagnosticExtension of the request. See Section 9.2.",
      "ja": "種類：情報の種類を示す数値コードが返されます。基本データはdMFlagsを使用して要求されたため、このコードはdMFlagセットに対応し、セクション5.1に記載されています。診断の拡張のために、このコードは、要求のDiagnosticExtensionの「種類」欄に設定DiagnosticKindIdの値と同じになります。 9.2節を参照してください。"
    },
    {
      "indent": 6,
      "text": "diagnostic_info_contents: Data containing the value for the diagnostic information being reported. Various kinds of diagnostic information can be retrieved. Please refer to Section 5.3 for details of the diagnostic Kind ID for the base diagnostic information that may be reported.",
      "ja": "diagnostic_info_contents：診断情報の値を含むデータが報告されています。診断各種情報を取得することができます。報告されることが基本診断情報のための診断種類のIDの詳細については、5.3節を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.3. dMFlags and Diagnostic Kind ID Types",
      "section_title": true,
      "ja": "5.3。 dMFlagsと診断カインドIDタイプ"
    },
    {
      "indent": 3,
      "text": "The dMFlags field described above is a 64-bit field that allows initiator nodes to identify up to 62 items of base information to request in a request message (the first and last flags being reserved). The dMFlags also reserves all \"0\"s, which means nothing is requested, and all \"1\"s, which means everything is requested. But at the same time, the first and last bits cannot be used for other purposes, and they MUST be set to 0 when other particular diagnostic Kind IDs are requested. When the requested base information is returned in the response, the value of the diagnostic Kind ID will correspond to the numeric field marked in the dMFlags in the request. The values for the dMFlags are defined in Section 9.1 and the diagnostic Kind IDs are defined in Section 9.2. The information contained for each value is described in this section. Access to each kind of diagnostic information MUST NOT be allowed unless compliant to the rules defined in Section 7.",
      "ja": "上記dMFlagsフィールドには、イニシエータノードが要求メッセージ（予約されている最初と最後のフラグ）に要求するベース情報の62項目まで識別することを可能にする64ビットのフィールドです。 dMFlagsも何もすべてのものが要求されることを意味し、要求されず、すべて「1」されることを意味し、全て「0」を留保します。しかし同時に、最初と最後のビットは他の目的に使用することができず、他の特定の診断種類IDが要求される場合、それらは0に設定しなければなりません。要求されたベース情報が応答で返された場合に、診断種類IDの値は、要求にdMFlagsにマークされた数値フィールドに対応します。 dMFlagsの値は、セクション9.1で定義されていると診断種類IDは、セクション9.2で定義されています。各値のために含まれている情報は、このセクションに記載されています。診断情報の各種類へのアクセスは、第7節で定義されたルールに準拠した場合を除き許可されてはなりません。"
    },
    {
      "indent": 3,
      "text": "STATUS_INFO (8 bits): A single-value element containing an unsigned byte representing whether or not the node is in congestion status. An example usage of STATUS_INFO is for congestion-aware routing. In this scenario, each peer has to update its congestion status periodically. An intermediate peer in the Distributed Hash Table (DHT) network will choose its next hop according to both the DHT routing algorithm and the status information. This is done to avoid increasing load on congested peers. The rightmost 4 bits are used and other bits MUST be cleared to \"0\"s for future use.",
      "ja": "STATUS_INFO（8ビット）：ノードが輻輳状態であるか否かを示す符号なしバイトを含む単一値の要素。 STATUS_INFOの使用例は、輻輳アウェアルーティングするためのものです。このシナリオでは、各ピアは、定期的に輻輳状態を更新しなければなりません。分散ハッシュテーブル（DHT）ネットワーク内の中間ピアがDHTルーティングアルゴリズムおよびステータス情報の両方に応じて、その次のホップを選択します。これは、混雑のピアの負荷を増大させる避けるために行われます。下位4ビットが使用され、他のビットは将来の使用のために「0」にクリアされなければなりません。"
    },
    {
      "indent": 6,
      "text": "There are 16 levels of congestion status, with 0x00 representing zero load and 0x0f representing congestion. This document does not provide a specific method for congestion and leaves this decision to each overlay implementation. One possible option for an overlay implementation would be to take node's CPU/memory/ bandwidth usage percentage in the past 600 seconds and normalize the highest value to the range from 0x00 to 0x0f. An overlay implementation can also decide to not use all the 16 values from 0x00 to 0x0f. A future document may define an objective measure or specific algorithm for this.",
      "ja": "輻輳を表すゼロ負荷を表す0x00から0x0Fのと輻輳状態の16個のレベルがあります。この文書では、混雑のための具体的な方法を提供し、各オーバーレイ実装にこの決定を残していません。オーバーレイ実装のための一つの可能​​な選択肢は、過去600秒でノードのCPU /メモリ/帯域幅の使用率を取るとは0x00から0x0Fの範囲に最高値を正規化することです。オーバーレイの実装も$ 00から0x0Fのに全16個の値を使用しないことを決定することができます。将来の文書では、このために客観的な尺度または特定のアルゴリズムを定義することができます。"
    },
    {
      "indent": 3,
      "text": "ROUTING_TABLE_SIZE (32 bits): A single-value element containing an unsigned 32-bit integer representing the number of peers in the peer's routing table. The administrator of the overlay may be interested in statistics of this value for reasons such as routing efficiency.",
      "ja": "ROUTING_TABLE_SIZE（32ビット）：ピアのルーティングテーブル内のピアの数を表す32ビットの符号なし整数を含む単一値の要素。オーバーレイの管理者は、このような効率のルーティングなどの理由のために、この値の統計に興味があるかもしれません。"
    },
    {
      "indent": 3,
      "text": "PROCESS_POWER (64 bits): A single-value element containing an unsigned 64-bit integer specifying the processing power of the node with MIPS as the unit. Fractional values are rounded up.",
      "ja": "PROCESS_POWER（64ビット）単位としてMIPSとノードの処理能力を指定する符号なし64ビット整数を含む単一値の要素。フラクショナル値は切り上げられます。"
    },
    {
      "indent": 3,
      "text": "UPSTREAM_BANDWIDTH (64 bits): A single-value element containing an unsigned 64-bit integer specifying the upstream network bandwidth (provisioned or maximum, not available) of the node with units of kbit/s. Fractional values are rounded up. For multihomed hosts, this should be the link used to send the response.",
      "ja": "UPSTREAM_BANDWIDTH（64ビット）：キロビット/秒の単位でノードの上流のネットワーク帯域幅を指定する符号なし64ビット整数を含む単一値の要素（プロビジョニングまたは最大、利用できません）。フラクショナル値は切り上げられます。マルチホームホストの場合、これは、応答を送信するために使用されるリンクでなければなりません。"
    },
    {
      "indent": 3,
      "text": "DOWNSTREAM_BANDWIDTH (64 bits): A single-value element containing an unsigned 64-bit integer specifying the downstream network bandwidth (provisioned or maximum, not available) of the node with kbit/s as the unit. Fractional values are rounded up. For multihomed hosts, this should be the link the request was received from.",
      "ja": "DOWNSTREAM_BANDWIDTH（64ビット）単位としてキロビット/秒のノードのダウンストリームネットワーク（プロビジョニングまたは最大、利用できない）帯域幅を指定する符号なし64ビット整数を含む単一値の要素。フラクショナル値は切り上げられます。マルチホームホストの場合、これはリクエストから受け取ったリンクでなければなりません。"
    },
    {
      "indent": 3,
      "text": "SOFTWARE_VERSION: A single-value element containing a US-ASCII string that identifies the manufacture, model, operating system information, and the version of the software. Given that there are a very large number of peers in some networks, and no peer is likely to know all other peer's software, this information may be very useful to help determine if the cause of certain groups of misbehaving peers is related to specific software versions. While the format is peer defined, a suggested format is as follows: \"ApplicationProductToken (Platform; OS-or-CPU) VendorProductToken (VendorComment)\", for example, \"MyReloadApp/1.0 (Unix; Linux x86_64) libreload-java/0.7.0 (Stonyfish Inc.)\". The string is a C-style string and MUST be terminated by \"\\0\".\"\\0\" MUST NOT be included in the string itself to prevent confusion with the delimiter.",
      "ja": "SOFTWARE_VERSION：製造、モデル、オペレーティングシステム情報、およびソフトウェアのバージョンを識別するUS-ASCII文字列を含む単一値要素。そこにいくつかのネットワーク内のピアの非常に大きな数があり、そして何のピアが他のすべてのピアのソフトウェアを知っている可能性がないことを考えると、この情報は、不正な動作ピアの特定のグループの原因は、特定のソフトウェアのバージョンに関連しているかどうかを判断を助けるために非常に有用である可能性があります。フォーマットピア定義されるが、以下のように、推奨される形式は： \"ApplicationProductToken（プラットフォーム、OS-OR-CPU）VendorProductToken（VendorComment）\"、例えば、「MyReloadApp / 1.0（のUnix、Linuxのx86_64で）libreload-のJava / 0.7。 0（Stonyfish社）」。文字列は、Cスタイルの文字列であり、「\\ 0」で終了する必要があります。「\\ 0」区切り文字との混同を防ぐために、文字列自体に含まれてはいけません。"
    },
    {
      "indent": 3,
      "text": "MACHINE_UPTIME (64 bits): A single-value element containing an unsigned 64-bit integer specifying the time the node's underlying system has been up (in seconds).",
      "ja": "MACHINE_UPTIME（64ビット）：ノードの基礎となるシステムは、（秒）アップされている時間を特定の符号なし64ビット整数を含む単一値の要素。"
    },
    {
      "indent": 3,
      "text": "APP_UPTIME (64 bits): A single-value element containing an unsigned 64-bit integer specifying the time the P2P application has been up (in seconds).",
      "ja": "APP_UPTIME（64ビット）：P2Pアプリケーションは、（秒）アップされている時間を特定の符号なし64ビット整数を含む単一値の要素。"
    },
    {
      "indent": 3,
      "text": "MEMORY_FOOTPRINT (64 bits): A single-value element containing an unsigned 64-bit integer representing the memory footprint of the peer program in kilobytes (1024 bytes). Fractional values are rounded up.",
      "ja": "MEMORY_FOOTPRINT（64ビット）：キロバイトピア・プログラム（1024バイト）のメモリフットプリントを表す符号なし64ビット整数を含む単一値の要素。フラクショナル値は切り上げられます。"
    },
    {
      "indent": 3,
      "text": "DATASIZE_STORED (64 bits): An unsigned 64-bit integer representing the number of bytes of data being stored by this node.",
      "ja": "DATASIZE_STORED（64ビット）：このノードによって格納されるデータのバイト数を表す符号無し64ビット整数。"
    },
    {
      "indent": 3,
      "text": "INSTANCES_STORED: An array element containing the number of instances of each kind stored. The array is indexed by Kind-ID. Each entry is an unsigned 64-bit integer.",
      "ja": "INSTANCES_STORED：記憶された各種類のインスタンスの数を含む配列要素。アレイは、種類-IDによってインデックスされます。各エントリは、符号なし64ビット整数です。"
    },
    {
      "indent": 3,
      "text": "MESSAGES_SENT_RCVD: An array element containing the number of messages sent and received. The array is indexed by method code. Each entry in the array is a pair of unsigned 64-bit integers (packed end to end) representing sent and received.",
      "ja": "MESSAGES_SENT_RCVD：送信と受信したメッセージの数を含む配列要素。アレイは、メソッドコードによってインデックス付けされます。アレイ内の各エントリは、送信と受信を表す符号なし64ビット整数の対（端まで充填端部）です。"
    },
    {
      "indent": 3,
      "text": "EWMA_BYTES_SENT (32 bits): A single-value element containing an unsigned 32-bit integer representing an exponential weighted average of bytes sent per second by this peer:",
      "ja": "EWMA_BYTES_SENT（32ビット）：このピアによって1秒あたりに送信されたバイトの指数加重平均を表す32ビットの符号なし整数を含む単一値の要素："
    },
    {
      "indent": 6,
      "text": "sent = alpha x sent_present + (1 - alpha) x sent_last",
      "ja": "=アルファX sent_present +送信（1  - アルファ）X sent_last"
    },
    {
      "indent": 6,
      "text": "where sent_present represents the bytes sent per second since the last calculation and sent_last represents the last calculation of bytes sent per second. A suitable value for alpha is 0.8 (or another value as determined by the implementation). This value is calculated every five seconds (or another time period as determined by the implementation). The value for the very first time period should simply be the average of bytes sent in that time period.",
      "ja": "最後の計算とsent_last毎秒送信されたバイトの最後の計算を表すのでsent_presentは毎秒送信されたバイトを表します。アルファに適した値は、0.8（または実装によって決定される他の値）です。 （実装によって決定されるように、または他の時間）この値は5秒ごとに計算されます。非常に第1の期間のための値は、単に、その期間内に送信されたバイトの平均値であるべきです。"
    },
    {
      "indent": 3,
      "text": "EWMA_BYTES_RCVD (32 bits): A single-value element containing an unsigned 32-bit integer representing an exponential weighted average of bytes received per second by this peer:",
      "ja": "EWMA_BYTES_RCVD（32ビット）：このピアによって1秒あたりに受信したバイトの指数加重平均を表す32ビットの符号なし整数を含む単一値の要素："
    },
    {
      "indent": 6,
      "text": "rcvd = alpha x rcvd_present + (1 - alpha) x rcvd_last",
      "ja": "RCVD =アルファX rcvd_present +（1  - アルファ）X rcvd_last"
    },
    {
      "indent": 6,
      "text": "where rcvd_present represents the bytes received per second since the last calculation and rcvd_last represents the last calculation of bytes received per second. A suitable value for alpha is 0.8 (or another value as determined by the implementation). This value is calculated every five seconds (or another time period as determined by the implementation). The value for the very first time period should simply be the average of bytes received in that time period.",
      "ja": "最後の計算とrcvd_lastは、秒あたりの受信バイトの最後の計算を表すのでrcvd_presentは、秒あたりの受信バイト数を表します。アルファに適した値は、0.8（または実装によって決定される他の値）です。 （実装によって決定されるように、または他の時間）この値は5秒ごとに計算されます。非常に第1の期間のための値は、単に、その時間内に受信したバイトの平均値であるべきです。"
    },
    {
      "indent": 3,
      "text": "UNDERLAY_HOP (8 bits): Indicates the IP-layer hops from the intermediate peer, which receives the diagnostics message to the next-hop peer for this message. (Note: RELOAD does not require the intermediate peers to look into the message body. So, here we use PathTrack to gather underlay hops for diagnostics purpose).",
      "ja": "UNDERLAY_HOP（8ビット）：IP-層は、このメッセージの次ホップピアに診断メッセージを受信する中間ピアからのホップを示します。 （注：RELOADは、メッセージ本文に見て、中間ピアを必要としないので、ここで我々は下敷きを収集するためにPathTrackを使用するには、診断目的のためにホップ）。"
    },
    {
      "indent": 3,
      "text": "BATTERY_STATUS (8 bits): The leftmost bit is used to indicate whether this peer is using a battery or not. If this bit is clear (set to \"0\"), then the peer is using a battery for power. The other 7 bits are to be determined by specific applications.",
      "ja": "BATTERY_STATUS（8ビット）：左端のビットは、このピアは、電池を使用しているか否かを示すために使用されます。このビットがクリアされている場合、ピアは電源用の電池を使用して、（「0」に設定）。他の7ビットは、特定の用途によって決定されるべきです。"
    },
    {
      "indent": 0,
      "text": "6. Message Processing",
      "section_title": true,
      "ja": "6.メッセージ処理"
    },
    {
      "indent": 0,
      "text": "6.1. Message Creation and Transmission",
      "section_title": true,
      "ja": "6.1。メッセージの作成と送信"
    },
    {
      "indent": 3,
      "text": "When constructing either a Ping message with diagnostic extensions or a PathTrack message, the sender first creates and populates a DiagnosticsRequest data structure. The timestamp_initiated field is set to the current time, and the expiration field is constructed based on this time. The sender includes the dMFlags field in the structure, setting any number (including all) of the flags to request particular diagnostic information. The sender MAY leave all the bits unset, thereby requesting no particular diagnostic information.",
      "ja": "診断拡張やPathTrackメッセージとPingメッセージのいずれかを構築する場合、送信者は、最初に作成し、DiagnosticsRequestデータ構造を移入します。 timestamp_initiatedフィールドは、現在の時刻に設定され、有効期限のフィールドは、この時間に基づいて構築されます。送信者は、特定の診断情報を要求するためにフラグの（全てを含む）任意の数を設定し、構造にdMFlagsフィールドを含みます。送信者は、それによって特に診断情報を要求していない、未設定のすべてのビットを残すことができます。"
    },
    {
      "indent": 3,
      "text": "The sender MAY also include diagnostic extensions in the DiagnosticsRequest data structure to request additional information.",
      "ja": "送信者は、追加情報を要求するために、診断依頼データ構造での診断の拡張機能を含むこともできます。"
    },
    {
      "indent": 3,
      "text": "If the sender includes any extensions, it MUST calculate the length of these extensions and set the ext_length field to this value. If no extensions are included, the sender MUST set ext_length to zero.",
      "ja": "送信者が任意の拡張子が含まれている場合、それは、これらの拡張の長さを計算し、この値にext_lengthフィールドを設定しなければなりません。何の拡張機能が含まれていない場合は、送信者はゼロにext_lengthを設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The format of the DiagnosticRequest data structure and its fields MUST follow the restrictions defined in Section 5.1.",
      "ja": "DiagnosticRequestデータ構造とそのフィールドのフォーマットは、セクション5.1で定義された制限に従わなければなりません。"
    },
    {
      "indent": 3,
      "text": "When constructing a Ping message with diagnostic extensions, the sender MUST create a MessageExtension structure as defined in RELOAD [RFC6940], setting the value of type to 0x2 and the value of critical to FALSE. The value of extension_contents MUST be a DiagnosticsRequest structure as defined above. The message MAY be directed to a particular NodeID or ResourceID but MUST NOT be sent to the broadcast NodeID.",
      "ja": "診断拡張子のpingメッセージを構築する場合を0x2のタイプの値とFALSEに臨界の値を設定し、RELOAD [RFC6940]で定義されるように、送信者はMessageExtension構造を作成する必要があります。上記で定義した通りextension_contentsの値はDiagnosticsRequest構造でなければなりません。メッセージは、特定のNodeIDかのResourceIDに向けることができるが、ブロードキャストのNodeIDに送ってはいけません。"
    },
    {
      "indent": 3,
      "text": "When constructing a PathTrack message, the sender MUST set the message_code for the RELOAD MessageContents structure to path_track_req 0x27. The request field of the PathTrackReq MUST be set to the DiagnosticsRequest data structure defined above. The destination field MUST be set to the desired destination, which MAY be either a NodeID or ResourceID but SHOULD NOT be the broadcast NodeID.",
      "ja": "PathTrackメッセージを構築する場合、送信者はpath_track_reqのは0x27にRELOADのMessageContents構造のためmessage_codeにを設定しなければなりません。 PathTrackReqの要求フィールドは、上記で定義DiagnosticsRequestデータ構造に設定しなければなりません。宛先フィールドはのNodeIDかのResourceIDのいずれであってもよいが、放送用のNodeIDすべきではない所望の目的地に設定しなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.2. Message Processing: Intermediate Peers",
      "section_title": true,
      "ja": "6.2。メッセージ処理：中級ピア"
    },
    {
      "indent": 3,
      "text": "When a request arrives at a peer, if the peer's responsible ID space does not cover the destination ID of the request, then the peer MUST continue processing this request according to the overlay specified routing mode from RELOAD protocol.",
      "ja": "要求ピアに到着すると、ピアの責任ID空間は、要求の宛先IDをカバーしていない場合、ピアは、リロードプロトコルからオーバーレイ指定されたルーティングモードに応じて、この要求の処理を継続しなければなりません。"
    },
    {
      "indent": 3,
      "text": "In P2P overlay, error responses to a message can be generated by either an intermediate peer or the responsible peer. When a request is received at a peer, the peer may find connectivity failures or malfunctioning peers through the predefined rules of the overlay network, e.g., by analyzing the Via List or underlay error messages. In this case, the intermediate peer returns an error response to the initiator node, reporting any malfunction node information available in the error message payload. All error responses generated MUST contain the appropriate error code.",
      "ja": "P2Pオーバーレイにおいて、メッセージに対するエラー応答は、中間ピアまたはピア責任のいずれかによって生成することができます。要求がピアで受信された場合、ピアは、ビアリストまたはアンダーエラーメッセージを解析することにより、例えば、オーバレイネットワークの事前定義されたルールを介して接続障害または誤動作ピアを見つけることができます。この場合、中間ピアはエラー・メッセージ・ペイロード内の利用可能な任意の故障ノードの情報を報告し、イニシエータノードへエラー応答を返します。生成されたすべてのエラー応答は、適切なエラーコードを含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "Each intermediate peer receiving a Ping message with extensions (and that understands the extension) or receiving a PathTrack request / response MUST check the expiration value (Unix time format) to determine if the message is expired. If the message expired, the intermediate peer MUST generate a response with error code 0x17 \"Error_Message_Expired\", return the response to the initiator node, and discard the message.",
      "ja": "各中間拡張子のpingメッセージを受信ピア（それは拡張理解）またはメッセージの有効期限が切れているかどうかを決定するために満了値（Unixの時間フォーマット）を確認しなければならないPathTrack要求/応答を受信します。メッセージの有効期限が切れた場合、中間ピアはエラーコード0x17の「Error_Message_Expired」との応答を生成しなければなりません、イニシエータノードに応答を返し、メッセージを破棄する。"
    },
    {
      "indent": 3,
      "text": "The intermediate peer MUST return an error response with the error code 0x15 \"Error_Underlay_Destination_Unreachable\" when it receives an ICMP message with \"Destination Unreachable\" information after forwarding the received request to the destination peer.",
      "ja": "中間ピアはエラーコード0x15の「Error_Underlay_Destination_Unreachable」は宛先ピアに受信した要求を転送した後、「宛先到達不能」情報とICMPメッセージを受信すると、エラー応答を返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "The intermediate peer MUST return an error response with the error code 0x16 \"Error_Underlay_Time_Exceeded\" when it receives an ICMP message with \"Time Exceeded\" information after forwarding the received request.",
      "ja": "中間ピアはエラーコード0x16「Error_Underlay_Time_Exceeded」が受信された要求を転送した後に情報を「時間超過」のICMPメッセージを受信すると、エラー応答を返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "The peer MUST return an error response with error code 0x18 \"Error_Upstream_Misrouting\" when it finds its upstream peer disobeys the routing rules defined in the overlay. The immediate upstream peer information MUST also be conveyed to the initiator node.",
      "ja": "ピアは、その上流側ピアがオーバーレイで定義されたルーティングルールを従わないと認めるときは「Error_Upstream_Misrouting」エラーコード0x18の有するエラー応答を返さなければなりません。直上流ピア情報は、イニシエータノードに搬送しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The peer MUST return an error response with error code 0x19 \"Error_Loop_Detected\" when it finds a loop through the analysis of the Via List.",
      "ja": "それは経由リストの分析を通じてループを見つけたときに、ピアは、エラーコード0x19「Error_Loop_Detected」とのエラー応答を返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "The peer MUST return an error response with error code 0x1a \"Error_TTL_Hops_Exceeded\" when it finds that the TTL field value is no more than 0 when forwarding.",
      "ja": "ピアはエラーコード0x1aとエラー応答を返さなければならない、それはTTLフィールド値がもはや0より転送であると認めるときは「Error_TTL_Hops_Exceeded」。"
    },
    {
      "indent": 0,
      "text": "6.3. Message Response Creation",
      "section_title": true,
      "ja": "6.3。メッセージ応答の作成"
    },
    {
      "indent": 3,
      "text": "When a diagnostic request message arrives at a peer, it is responsible for the destination ID specified in the forwarding header, and assuming it understands the extension (in the case of Ping) or the new request type PathTrack, it MUST follow the specifications defined in RELOAD to form the response header, and perform the following operations:",
      "ja": "診断要求メッセージがピアに到達すると、それが転送ヘッダで指定された宛先IDの原因である、と仮定すると、それは（PINGの場合）拡張または新しい要求タイプPathTrackを理解し、それに定義された仕様に従わなければなりません応答ヘッダを形成するためにリロードして、次の操作を実行します。"
    },
    {
      "indent": 3,
      "text": "o When constructing a PathTrack response, the sender MUST set the message_code for the RELOAD MessageContents structure to path_track_ans 0x28.",
      "ja": "PathTrack応答を構築する場合、O、送信者はpath_track_ansのの0x28にRELOADのMessageContents構造のためmessage_codeにを設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o The receiver MUST check the expiration value (Unix time format) in the DiagnosticsRequest to determine if the message is expired. If the message is expired, the peer MUST generate a response with the error code 0x17 \"Error_Message_Expired\", return the response to the initiator node, and discard the message.",
      "ja": "O受信機は、メッセージの有効期限が切れているかどうかを決定するためにDiagnosticsRequestに満了値（Unixの時間フォーマット）を確認しなければなりません。メッセージの有効期限が切れている場合、ピアはエラーコード0x17の「Error_Message_Expired」との応答を生成しなければなりません、イニシエータノードに応答を返し、メッセージを破棄する。"
    },
    {
      "indent": 3,
      "text": "o If the message is not expired, the receiver MUST construct a DiagnosticsResponse structure as follows: 1) the TTL value from the forwarding header is copied to the hop_counter field of the DiagnosticsResponse structure (note that the default value for TTL at the beginning represents 100 hops unless the overlay configuration has overridden the value), and 2) the receiver generates a Unix time format timestamp for the current time of day and places it in the timestamp_received field and constructs a new expiration time and places it in the expiration field of the DiagnosticsResponse.",
      "ja": "メッセージの有効期限が切れていない場合、次のようにO、受信機はDiagnosticsResponse構造を構築しなければならない：1）転送ヘッダのTTL値がDiagnosticsResponse構造のhop_counterフィールドにコピーされる（開始時TTLのデフォルト値は100を表していることに注意オーバーレイの設定値を上書きしていない限り）ホップ、及び2）受信機は、現在時刻のUNIX時間形式のタイムスタンプを生成し、timestamp_receivedフィールドに置き、満了フィールドに新しい有効期限や場所を構築しますDiagnosticsResponse。"
    },
    {
      "indent": 3,
      "text": "o The destination peer MUST check if the initiator node has the authority to request specific types of diagnostic information, and if appropriate, append the diagnostic information requested in the dMFlags and diagnostic_extensions (if any) using the diagnostic_info_list field to the DiagnosticsResponse structure. If any information is returned, the receiver MUST calculate the length of the response and set ext_length appropriately. If no diagnostic information is returned, ext_length MUST be set to zero.",
      "ja": "O宛先ピアは、イニシエータノードは、診断情報の特定のタイプを要求する権限を有するかどうかを確認し、適切であれば、dMFlagsとDiagnosticsResponse構造にdiagnostic_info_listフィールドを使用してdiagnostic_extensions（もしあれば）に要求された診断情報を追加する必要があります。いずれかの情報が返された場合、受信機は応答の長さを計算し、ext_length適切に設定しなければなりません。何の診断情報が返されない場合、ext_lengthをゼロに設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o The format of the DiagnosticResponse data structure and its fields MUST follow the restrictions defined in Section 5.2.",
      "ja": "O DiagnosticResponseデータ構造とそのフィールドのフォーマットは、5.2節で定義された制限に従わなければなりません。"
    },
    {
      "indent": 3,
      "text": "o In the event of an error, an error response containing the error code followed by the description (if they exist) MUST be created and sent to the sender. If the initiator node asks for diagnostic information that they are not authorized to query, the receiving peer MUST return an error response with the error code 2 \"Error_Forbidden\".",
      "ja": "エラーの場合には、O、（存在する場合）の説明に続いて、エラーコードを含むエラーレスポンスを作成する必要があり、送信者に送信されます。イニシエータノードは、それらが照会を許可されていないこと診断情報を要求する場合、受信ピアはエラーコード2「Error_Forbidden」とエラー応答を返さなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.4. Interpreting Results",
      "section_title": true,
      "ja": "6.4。解釈結果"
    },
    {
      "indent": 3,
      "text": "The initiator node, as well as the responding peer, may compute the overlay One-Way-Delay time through the value in timestamp_received and the timestamp_initiated field. However, for a single hop measurement, the traditional measurement methods (IP-layer ping) MUST be used instead of the overlay layer diagnostics methods.",
      "ja": "イニシエータノード、ならびに応答するピアが、timestamp_receivedの値とtimestamp_initiatedフィールドを介してオーバーレイ一方向遅延時間を計算することができます。しかし、単一ホップの測定のために、従来の測定方法（IP層のping）を代わりにオーバーレイ層の診断方法を用いなければなりません。"
    },
    {
      "indent": 3,
      "text": "The P2P overlay network using the diagnostics methods specified in this document MUST enforce time synchronization with a central time server. The Network Time Protocol [RFC5905] can usually maintain time to within tens of milliseconds over the public Internet and can achieve better than one millisecond accuracy in local area networks under ideal conditions. However, this document does not specify the choice for time resolution and synchronization, leaving it to the implementation.",
      "ja": "この文書で指定された診断方法を使用してP2Pオーバレイネットワークは、中央の時刻サーバとの時刻同期を強制しなければなりません。ネットワークタイムプロトコル[RFC5905]は通常、公共のインターネット上で数十ミリ秒以内までの時間を維持することができ、理想的な条件の下でローカルエリアネットワークでより良いよりも1ミリ秒の精度を達成することができます。しかし、この文書は実装にそれを残して、時間分解能との同期のための選択肢を指定していません。"
    },
    {
      "indent": 3,
      "text": "The initiator node receiving the Ping response may check the hop_counter field and compute the overlay hops to the destination peer for the statistics of connectivity quality from the perspective of overlay hops.",
      "ja": "Pingの応答を受信したイニシエータノードはhop_counterフィールドをチェックして、オーバーレイは、オーバーレイホップの観点から接続品質の統計の宛先ピアにホップ計算してもよいです。"
    },
    {
      "indent": 0,
      "text": "7. Authorization through Overlay Configuration",
      "section_title": true,
      "ja": "オーバーレイの設定を通じて7.認証"
    },
    {
      "indent": 3,
      "text": "Different level of access control can be made for different users/ nodes. For example, diagnostic information A can be accessed by nodes 1 and 2, but diagnostic information B can only be accessed by node 2.",
      "ja": "アクセス制御の異なるレベルが異なるユーザ/ノードに対して行うことができます。例えば、診断情報Aは、ノード1および2によってアクセスすることができるが、診断情報Bのみ、ノード2によってアクセスすることができます。"
    },
    {
      "indent": 3,
      "text": "The overlay configuration file MUST contain the following XML elements for authorizing a node to access the relative diagnostic Kinds.",
      "ja": "オーバーレイ・コンフィギュレーション・ファイルは、相対診断種類にアクセスするノードを認証するための次のXML要素を含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "diagnostic-kind: This has the attribute \"kind\" with the hexadecimal number indicating the diagnostic Kind ID. This attribute has the same value with Section 9.2 and at least one subelement \"access-node\".",
      "ja": "診断-種類：これは、診断種類IDを示す進数の属性「種類」を有します。この属性は、セクション9.2および少なくとも一つのサブ要素「アクセス・ノード」と同じ値を持っています。"
    },
    {
      "indent": 3,
      "text": "access-node: This element contains one hexadecimal number indicating a NodeID, and the node with this NodeID is allowed to access the diagnostic \"kind\" under the same diagnostic-kind element.",
      "ja": "アクセス・ノード：この要素はのNodeIDを示す1つの16進数を含み、これのNodeIDを有するノードは、同じ診断現物要素の下の診断「種類」にアクセスすることが許可されています。"
    },
    {
      "indent": 0,
      "text": "8. Security Considerations",
      "section_title": true,
      "ja": "8.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "The authorization for diagnostic information must be designed with care to prevent it becoming a method to retrieve information for both attacks. It should also be noted that attackers can use diagnostics to analyze overlay information to attack certain key peers. For example, diagnostic information might be used to fingerprint a peer where the peer will lose its anonymity characteristics, but anonymity might be very important for some P2P overlay networks, and defenses against such fingerprinting are probably very hard. As such, networks where anonymity is of very high importance may find implementation of diagnostics problematic or even undesirable, despite the many advantages it offers. As this document is a RELOAD extension, it follows RELOAD message header and routing specifications. The common security considerations described in the base document [RFC6940] are also applicable to this document. Overlays may define their own requirements on who can collect/share diagnostic information.",
      "ja": "診断情報の認可は、それが両方の攻撃のための情報を取得するための方法になってきてないように注意して設計する必要があります。また、攻撃者が特定のキーのピアを攻撃するためにオーバーレイ情報を分析するために診断プログラムを使用することに留意すべきです。例えば、診断情報は、ピアはその匿名性を失うことになるが、匿名性は、いくつかのP2Pオーバーレイネットワークのために非常に重要であるかもしれない、そのような指紋に対する防御は、おそらく非常に困難なピアを指紋ために使用される可能性があります。そのため、匿名性が非常に高い重要であるネットワークは、それが提供する多くの利点にもかかわらず、問題のある、あるいは望ましくない診断の実施を見つけることができます。この文書リロード拡張されるので、リロードメッセージヘッダ及びルーティング仕様に従います。ベース文書[RFC6940]に記載の一般的なセキュリティ問題もまた、この文書に適用可能です。オーバーレイは/共有診断情報を収集することができ、誰に独自の要件を定義することもできます。"
    },
    {
      "indent": 0,
      "text": "9. IANA Considerations",
      "section_title": true,
      "ja": "9. IANAの考慮事項"
    },
    {
      "indent": 0,
      "text": "9.1. Diagnostics Flag",
      "section_title": true,
      "ja": "9.1。診断旗"
    },
    {
      "indent": 3,
      "text": "IANA has created a \"RELOAD Diagnostics Flag\" registry under protocol RELOAD. Entries in this registry are 1-bit flags contained in a 64-bit integer dMFlags denoting diagnostic information to be retrieved as described in Section 4.3.1. New entries SHALL be defined via Standards Action as per [RFC5226]. The initial contents of this registry are:",
      "ja": "IANAは、プロトコルRELOADの下に「RELOAD診断フラグ」レジストリを作成しました。このレジストリのエントリは、セクション4.3.1に記載したように取得される診断情報を示す64ビット整数dMFlagsに含まれる1ビットのフラグです。新しいエントリは、[RFC5226]あたりとして標準化アクションを経由して定義されなければなりません。このレジストリの初期の内容は以下のとおりです。"
    },
    {
      "indent": 5,
      "text": "+-------------------------+----------------------------+----------+\n|  Diagnostic Information |Diagnostic Flag in dMFlags  | Reference|\n|-------------------------+----------------------------+----------|\n|Reserved All 0s value    | 0x 0000 0000 0000 0000     | RFC 7851 |\n|Reserved First Bit       | 0x 0000 0000 0000 0001     | RFC 7851 |\n|STATUS_INFO              | 0x 0000 0000 0000 0002     | RFC 7851 |\n|ROUTING_TABLE_SIZE       | 0x 0000 0000 0000 0004     | RFC 7851 |\n|PROCESS_POWER            | 0x 0000 0000 0000 0008     | RFC 7851 |\n|UPSTREAM_BANDWIDTH       | 0x 0000 0000 0000 0010     | RFC 7851 |\n|DOWNSTREAM_ BANDWIDTH    | 0x 0000 0000 0000 0020     | RFC 7851 |\n|SOFTWARE_VERSION         | 0x 0000 0000 0000 0040     | RFC 7851 |\n|MACHINE_UPTIME           | 0x 0000 0000 0000 0080     | RFC 7851 |\n|APP_UPTIME               | 0x 0000 0000 0000 0100     | RFC 7851 |\n|MEMORY_FOOTPRINT         | 0x 0000 0000 0000 0200     | RFC 7851 |\n|DATASIZE_STORED          | 0x 0000 0000 0000 0400     | RFC 7851 |\n|INSTANCES_STORED         | 0x 0000 0000 0000 0800     | RFC 7851 |\n|MESSAGES_SENT_RCVD       | 0x 0000 0000 0000 1000     | RFC 7851 |\n|EWMA_BYTES_SENT          | 0x 0000 0000 0000 2000     | RFC 7851 |\n|EWMA_BYTES_RCVD          | 0x 0000 0000 0000 4000     | RFC 7851 |\n|UNDERLAY_HOP             | 0x 0000 0000 0000 8000     | RFC 7851 |\n|BATTERY_STATUS           | 0x 0000 0000 0001 0000     | RFC 7851 |\n|Reserved Last Bit        | 0x 8000 0000 0000 0000     | RFC 7851 |\n|Reserved All 1s value    | 0x ffff ffff ffff ffff     | RFC 7851 |\n+-------------------------+----------------------------+----------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "9.2. Diagnostic Kind ID",
      "section_title": true,
      "ja": "9.2。診断種類ID"
    },
    {
      "indent": 3,
      "text": "IANA has created a \"RELOAD Diagnostic Kind ID\" registry under protocol RELOAD. Entries in this registry are 16-bit integers denoting diagnostics extension data kinds carried in the diagnostic request and response messages, as described in Sections and 5.1 and 5.2. Code points from 0x0001 to 0x003e are asked to be assigned together with flags within the \"RELOAD Diagnostics Flag\" registry. The registration procedure for the \"RELOAD Diagnostic Kind ID\" registry is Standards Action as defined in RFC 5226.",
      "ja": "IANAは、プロトコルRELOADの下に「RELOAD診断カインドID」レジストリを作成しました。このレジストリのエントリは、セクション5.1および5.2に記載されているように、診断要求メッセージと応答メッセージで運ば診断拡張データの種類を示す16ビット整数です。 0x003eには0x0001からコードポイントは「RELOAD診断旗」レジストリ内のフラグと一緒に割り当てることが求められます。 「RELOAD診断カインドID」レジストリのための登録手続きはRFC 5226で定義されている標準アクションです。"
    },
    {
      "indent": 9,
      "text": "+----------------------+---------------+---------------+\n| Diagnostic Kind      |      Code     | Specification |\n+----------------------+---------------+---------------+\n| Reserved             |     0x0000    |    RFC 7851   |\n| STATUS_INFO          |     0x0001    |    RFC 7851   |\n| ROUTING_TABLE_SIZE   |     0x0002    |    RFC 7851   |\n| PROCESS_POWER        |     0x0003    |    RFC 7851   |\n| UPSTREAM_BANDWIDTH   |     0x0004    |    RFC 7851   |\n| DOWNSTREAM_BANDWIDTH |     0x0005    |    RFC 7851   |\n| SOFTWARE_VERSION     |     0x0006    |    RFC 7851   |\n| MACHINE_UPTIME       |     0x0007    |    RFC 7851   |\n| APP_UPTIME           |     0x0008    |    RFC 7851   |\n| MEMORY_FOOTPRINT     |     0x0009    |    RFC 7851   |\n| DATASIZE_STORED      |     0x000a    |    RFC 7851   |\n| INSTANCES_STORED     |     0x000b    |    RFC 7851   |\n| MESSAGES_SENT_RCVD   |     0x000c    |    RFC 7851   |\n| EWMA_BYTES_SENT      |     0x000d    |    RFC 7851   |\n| EWMA_BYTES_RCVD      |     0x000e    |    RFC 7851   |\n| UNDERLAY_HOP         |     0x000f    |    RFC 7851   |\n| BATTERY_STATUS       |     0x0010    |    RFC 7851   |\n| Unassigned           | 0x0011-0x003e |    RFC 7851   |\n| local use (Reserved) | 0xf000-0xfffe |    RFC 7851   |\n| Reserved             |     0xffff    |    RFC 7851   |\n+----------------------+---------------+---------------+",
      "raw": true
    },
    {
      "indent": 25,
      "text": "Table 1: Diagnostic Kind",
      "ja": "表1：診断種類"
    },
    {
      "indent": 0,
      "text": "9.3. Message Codes",
      "section_title": true,
      "ja": "9.3。メッセージコード"
    },
    {
      "indent": 3,
      "text": "This document introduces two new types of messages and their responses, so the following additions have been made to the \"RELOAD Message Codes\" registry defined in RELOAD [RFC6940].",
      "ja": "以下の追加がRELOAD [RFC6940]で定義された「RELOADメッセージ・コード」レジストリに行われてきたように、この文書では、メッセージとその応答の二つの新しいタイプを紹介します。"
    },
    {
      "indent": 15,
      "text": "+-------------------+------------+----------+\n| Message Code Name | Code Value |   RFC    |\n+-------------------+------------+----------+\n|   path_track_req  |    0x27    | RFC 7851 |\n|   path_track_ans  |    0x28    | RFC 7851 |\n+-------------------+------------+----------+",
      "raw": true
    },
    {
      "indent": 16,
      "text": "Table 2: Extensions to RELOAD Message Codes",
      "ja": "表2：拡張メッセージコードをリロードします"
    },
    {
      "indent": 0,
      "text": "9.4. Error Code",
      "section_title": true,
      "ja": "9.4。エラーコード"
    },
    {
      "indent": 3,
      "text": "This document introduces the following new error codes, which have been added to the \"RELOAD Error Codes\" registry.",
      "ja": "この文書では、「RELOADエラーコード」レジストリに追加された以下の新しいエラーコードを、ご紹介します。"
    },
    {
      "indent": 4,
      "text": "+----------------------------------------+------------+-----------+\n| Error Code Name                        | Code Value | Reference |\n+----------------------------------------+------------+-----------+\n| Error_Underlay_Destination_Unreachable |    0x15    |  RFC 7851 |\n| Error_Underlay_Time_Exceeded           |    0x16    |  RFC 7851 |\n| Error_Message_Expired                  |    0x17    |  RFC 7851 |\n| Error_Upstream_Misrouting              |    0x18    |  RFC 7851 |\n| Error_Loop_Detected                    |    0x19    |  RFC 7851 |\n| Error_TTL_Hops_Exceeded                |    0x1A    |  RFC 7851 |\n+----------------------------------------+------------+-----------+",
      "raw": true
    },
    {
      "indent": 24,
      "text": "Table 3: RELOAD Error Codes",
      "ja": "表3：RELOADエラーコード"
    },
    {
      "indent": 0,
      "text": "9.5. Message Extension",
      "section_title": true,
      "ja": "9.5。メッセージ拡張"
    },
    {
      "indent": 3,
      "text": "This document introduces the following new RELOAD extension code:",
      "ja": "このドキュメントは、以下の新しいRELOAD延長コードが導入されています。"
    },
    {
      "indent": 18,
      "text": "+-----------------+------+-----------+\n|  Extension Name | Code | Reference |\n+-----------------+------+-----------+\n| Diagnostic_Ping | 0x2  |  RFC 7851 |\n+-----------------+------+-----------+",
      "raw": true
    },
    {
      "indent": 20,
      "text": "Table 4: New RELOAD Extension Code",
      "ja": "表4：新しいRELOAD延長コード"
    },
    {
      "indent": 0,
      "text": "9.6. XML Name Space Registration",
      "section_title": true,
      "ja": "9.6。 XML名前空間の登録"
    },
    {
      "indent": 3,
      "text": "This document registers a URI for the config-diagnostics XML namespace in the IETF XML registry defined in [RFC3688]. All the elements defined in this document belong to this namespace.",
      "ja": "この文書では、[RFC3688]で定義されたIETF XMLレジストリの設定、診断のXML名前空間のURIを登録します。この文書で定義されたすべての要素は、この名前空間に属します。"
    },
    {
      "indent": 3,
      "text": "URI: urn:ietf:params:xml:ns:p2p:config-diagnostics Registrant Contact: The IESG. XML: N/A; the requested URIs are XML namespaces",
      "ja": "URI：URN：IETF：のparams：XML：NS：P2Pます。config-診断登録者連絡先：IESG。 XML：N / A。要求されたURIは、XML名前空間です"
    },
    {
      "indent": 3,
      "text": "The overlay configuration file MUST contain the following XML language declaring P2P diagnostics as a mandatory extension to RELOAD.",
      "ja": "オーバーレイ設定ファイルがリロードする必須の拡張としてP2P診断を宣言し、次のXML言語を含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "<mandatory-extension> urn:ietf:params:xml:ns:p2p:config-diagnostics </mandatory-extension>",
      "ja": "<必須拡張> URN：IETF：のparams：XML：NS：P2Pます。config-診断</必須拡張>"
    },
    {
      "indent": 0,
      "text": "10. References",
      "section_title": true,
      "ja": "10.参考文献"
    },
    {
      "indent": 0,
      "text": "10.1. Normative References",
      "section_title": true,
      "ja": "10.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC792] Postel, J., \"Internet Control Message Protocol\", STD 5, RFC 792, DOI 10.17487/RFC0792, September 1981, <http://www.rfc-editor.org/info/rfc792>.",
      "ja": "[RFC792]ポステル、J.、 \"インターネット制御メッセージプロトコル\"、STD 5、RFC 792、DOI 10.17487 / RFC0792、1981年9月、<http://www.rfc-editor.org/info/rfc792>。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<http://www.rfc-editor.org/info/ RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC3688] Mealling, M., \"The IETF XML Registry\", BCP 81, RFC 3688, DOI 10.17487/RFC3688, January 2004, <http://www.rfc-editor.org/info/rfc3688>.",
      "ja": "[RFC3688] Mealling、M.、 \"IETF XMLレジストリ\"、BCP 81、RFC 3688、DOI 10.17487 / RFC3688、2004年1月、<http://www.rfc-editor.org/info/rfc3688>。"
    },
    {
      "indent": 3,
      "text": "[RFC5226] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 5226, DOI 10.17487/RFC5226, May 2008, <http://www.rfc-editor.org/info/rfc5226>.",
      "ja": "[RFC5226] Narten氏、T.とH. Alvestrand、 \"RFCsにIANA問題部に書くためのガイドライン\"、BCP 26、RFC 5226、DOI 10.17487 / RFC5226、2008年5月、<http://www.rfc-editor.org /情報/ RFC5226>。"
    },
    {
      "indent": 3,
      "text": "[RFC5905] Mills, D., Martin, J., Ed., Burbank, J., and W. Kasch, \"Network Time Protocol Version 4: Protocol and Algorithms Specification\", RFC 5905, DOI 10.17487/RFC5905, June 2010, <http://www.rfc-editor.org/info/rfc5905>.",
      "ja": "[RFC5905]ミルズ、D.、マーティン、J.、エド、バーバンク、J.、およびW. Kasch、 \"ネットワークタイムプロトコルバージョン4：プロトコルとアルゴリズムの仕様\"。、RFC 5905、DOI 10.17487 / RFC5905、2010年6月、 <http://www.rfc-editor.org/info/rfc5905>。"
    },
    {
      "indent": 3,
      "text": "[RFC6940] Jennings, C., Lowekamp, B., Ed., Rescorla, E., Baset, S., and H. Schulzrinne, \"REsource LOcation And Discovery (RELOAD) Base Protocol\", RFC 6940, DOI 10.17487/RFC6940, January 2014, <http://www.rfc-editor.org/info/rfc6940>.",
      "ja": "[RFC6940]ジェニングス、C.、Lowekamp、B.、編。、レスコラ、E.、BASET、S.、およびH. Schulzrinneと、 \"リソースロケーションと発見（リロード）ベースプロトコル\"、RFC 6940、DOI 10.17487 / RFC6940 、2014年1月、<http://www.rfc-editor.org/info/rfc6940>。"
    },
    {
      "indent": 3,
      "text": "[RFC7263] Zong, N., Jiang, X., Even, R., and Y. Zhang, \"An Extension to the REsource LOcation And Discovery (RELOAD) Protocol to Support Direct Response Routing\", RFC 7263, DOI 10.17487/RFC7263, June 2014, <http://www.rfc-editor.org/info/rfc7263>.",
      "ja": "[RFC7263]宗、N.、江、X.、でも、R.、およびY.チャン、 \"ダイレクトレスポンスルーティングをサポートするためのリソースの場所と発見（RELOAD）プロトコルの拡張\"、RFC 7263、DOI 10.17487 / RFC7263 、2014年6月、<http://www.rfc-editor.org/info/rfc7263>。"
    },
    {
      "indent": 0,
      "text": "10.2. Informative References",
      "section_title": true,
      "ja": "10.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[UnixTime] Wikipedia, \"Unix time\", April 2016, <https://en.wikipedia.org/w/ index.php?title=Unix_time&oldid=715503178>.",
      "ja": "[UnixTime]ウィキペディア、 \"Unixの時間\"、2016年4月、<https://en.wikipedia.org/w/のindex.php？タイトル= UNIX_TIME＆oldid = 715503178>。"
    },
    {
      "indent": 3,
      "text": "[P2PSIP-CONCEPTS] Bryan, D., Matthews, P., Shim, E., Willis, D., and S. Dawkins, \"Concepts and Terminology for Peer to Peer SIP\", Work in Progress, draft-ietf-p2psip-concepts-09, April 2016.",
      "ja": "[P2PSIP-CONCEPTS]ブライアン、D.、マシューズ、P.、シム、E.、ウィリス、D.、およびS.ドーキンス、 \"概念とSIPピアツーピアのための用語\"、進行中で働いて、ドラフトIETF-P2PSIP 、概念-09、2016年4月。"
    },
    {
      "indent": 3,
      "text": "[Overlay-Failure-Detection] Zhuang, S., Geels, D., Stoica, I., and R. Katz, \"On failure detection algorithms in overlay networks\", In Proceedings of the IEEE INFOCOM 2005, pp. 2112-2123, DOI 10.1109/INFCOM.2005.1498487, March 2005.",
      "ja": "IEEE INFOCOM 2005頁の議事録の[オーバーレイ - 障害検出]荘、S.、Geels、D.、ストイカ、I.、およびR.カッツ、「故障検出アルゴリズムにオーバレイネットワークにおける」、。2112年から2123年、DOI 10.1109 / INFCOM.2005.1498487、2005年3月。"
    },
    {
      "indent": 3,
      "text": "[Handling_Churn_in_a_DHT] Rhea, S., Geels, D., Roscoe, T., and J. Kubiatowicz, \"Handling Churn in a DHT\", In Proceedings of the USENIX Annual Technical Conference, June 2004.",
      "ja": "USENIX年次技術会議2004年6月の議事録において【Handling_Churn_in_a_DHT]レア、S.、Geels、D.、ロスコー、T.、およびJ. Kubiatowicz、 \"DHTに解約の処理\"、。"
    },
    {
      "indent": 3,
      "text": "[Diagnostic_Framework] Jin, X., Xiong, Y., Zhang, Q., and S. Chan, \"A Diagnostic Framework for Peer-to-peer Streaming\", IEEE ICME 2006, July 2006.",
      "ja": "【Diagnostic_Framework]ジン、X.、熊、Y.、張、Q.、及びS.チャン、 \"ピアツーピアストリーミングのための診断フレームワーク\"、IEEE ICME 2006 2006年7月。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Examples",
      "ja": "付録A.例"
    },
    {
      "indent": 3,
      "text": "Below, we sketch how these metrics can be used.",
      "ja": "以下では、これらのメトリックを使用することができますどのようにスケッチします。"
    },
    {
      "indent": 0,
      "text": "A.1. Example 1",
      "ja": "A.1。例1"
    },
    {
      "indent": 3,
      "text": "A peer may set EWMA_BYTES_SENT and EWMA_BYTES_RCVD flags in the PathTrackReq to its direct neighbors. A peer can use EWMA_BYTES_SENT and EWMA_BYTES_RCVD of another peer to infer whether it is acting as a media relay. It may then choose not to forward any requests for media relay to this peer. Similarly, among the various candidates for filling up a routing table, a peer may prefer a peer with a large UPTIME value, small RTT, and small LAST_CONTACT value.",
      "ja": "ピアは、その直接の隣人にPathTrackReqにEWMA_BYTES_SENTとEWMA_BYTES_RCVDフラグを設定することができます。ピアは、それがメディアリレーとして動作しているかどうかを推測する他のピアのEWMA_BYTES_SENTとEWMA_BYTES_RCVDを使用することができます。それは、このピアにメディアリレーのための任意の要求を転送しないこともできます。同様に、ルーティングテーブルを埋めるための種々の候補の中から、ピアが大きい稼働時間値、小さなRTT、及び小さなLAST_CONTACT値ピアを好むかもしれません。"
    },
    {
      "indent": 0,
      "text": "A.2. Example 2",
      "ja": "A.2。例2"
    },
    {
      "indent": 3,
      "text": "A peer may set the STATUS_INFO Flag in the PathTrackReq to a remote destination peer. The overlay has its own threshold definition for congestion. The peer can obtain knowledge of all the status information of the intermediate peers along the path, then it can choose other paths to that node for the subsequent requests.",
      "ja": "ピアは、リモート宛先ピアにPathTrackReqにSTATUS_INFOフラグを設定してもよいです。オーバーレイは、混雑のために、独自のしきい値定義を持っています。ピアは、それが後続の要求のためにそのノードに他のパスを選択することができ、経路に沿った中間のピアのすべてのステータス情報の知識を得ることができます。"
    },
    {
      "indent": 0,
      "text": "A.3. Example 3",
      "ja": "A.3。例3"
    },
    {
      "indent": 3,
      "text": "A peer may use Ping to evaluate the average overlay hops to other peers by sending PingReq to a set of random resource or node IDs in the overlay. A peer may adjust its timeout value according to the change of average overlay hops.",
      "ja": "ピアは、オーバレイにおけるランダムリソースまたはノードIDのセットにPingReqを送信することによって他のピアへの平均オーバーレイホップを評価するには、pingを使用してもよいです。ピアは平均オーバーレイホップの変化に応じて、そのタイムアウト値を調整してもよいです。"
    },
    {
      "indent": 0,
      "text": "Appendix B. Problems with Generating Multiple Responses on Path",
      "ja": "パス上の複数の応答を生成して付録B.問題"
    },
    {
      "indent": 3,
      "text": "An earlier draft version of this document considered an approach where a response was generated by each intermediate peer as the message traversed the overlay. This approach was discarded. One reason this approach was discarded was that it could provide a DoS mechanism, whereby an attacker could send an arbitrary message claiming to be from a spoofed \"sender\" the real sender wished to attack. As a result of sending this one message, many messages would be generated and sent back to the spoofed \"sender\" -- one from each intermediate peer on the message path. While authentication mechanisms could reduce some risk of this attack, it still resulted in a fundamental break from the request-response nature of the RELOAD protocol, as multiple responses are generated to a single request. Although one request with responses from all the peers in the route will be more efficient, it was determined to be too great a security risk and a deviation from the RELOAD architecture.",
      "ja": "この文書の以前のドラフト版は、メッセージがオーバーレイを横切るように応答が各中間ピアによって生成されたアプローチを検討しました。このアプローチを廃棄しました。このアプローチは、廃棄された一つの理由は、それが攻撃者が実際の送信者が攻撃を望ん偽装された「送信者」からであると主張する任意のメッセージを送ることができることにより、DoS攻撃のメカニズムを、提供できるということでした。このつのメッセージを送信した結果として、多くのメッセージが生成され、バックなりすまし「送信者」に送信される - メッセージ経路上の各中間ピアからの1つ。認証メカニズムは、この攻撃のいくつかのリスクを減らすことができますが、複数の応答が単一の要求に生成されたとして、それはまだ、RELOADプロトコルの要求と応答の自然から基本的なブレークしました。ルート内のすべてのピアからの応答を持つつの要求をより効率的になりますが、それはあまりにも偉大なセキュリティリスクとRELOADアーキテクチャからの偏差であると決定されました。"
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "We would like to thank Zheng Hewen for the contribution of the initial draft version of this document. We would also like to thank Bruce Lowekamp, Salman Baset, Henning Schulzrinne, Jiang Haifeng, and Marc Petit-Huguenin for the email discussion and their valued comments, and special thanks to Henry Sinnreich for contributing to the usage scenarios text. We would like to thank the authors of the RELOAD protocol for transferring text about diagnostics to this document.",
      "ja": "私たちは、この文書の最初のドラフト版の貢献のための鄭Hewenに感謝したいと思います。また、使用シナリオのテキストに貢献するためにヘンリーSinnreichへの電子メールの議論とその価値のコメント、および特別な感謝のためにブルースLowekamp、サルマンBASET、ヘニングSchulzrinneと、江ハイフォン、およびマルク・プティ・Hugueninに感謝したいと思います。私たちは、この文書に診断に関するテキストを転送するためRELOADプロトコルの作者に感謝したいと思います。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Haibin Song Huawei",
      "ja": "H AIビン松花江があります"
    },
    {
      "indent": 3,
      "text": "Email: haibin.song@huawei.com",
      "ja": "メール：haibin.song@huawei.com"
    },
    {
      "indent": 3,
      "text": "Jiang Xingfeng Huawei",
      "ja": "江XING HU風ました"
    },
    {
      "indent": 3,
      "text": "Email: jiangxingfeng@huawei.com",
      "ja": "メール：jiangxingfeng@huawei.com"
    },
    {
      "indent": 3,
      "text": "Roni Even Huawei 14 David Hamelech Tel Aviv 64953 Israel",
      "ja": "ロニでもHuawei社14デイビッドHamelechテルアビブ64953イスラエル"
    },
    {
      "indent": 3,
      "text": "Email: ron.even.tlv@gmail.com",
      "ja": "メール：ron.even.tlv@gmail.com"
    },
    {
      "indent": 3,
      "text": "David A. Bryan ethernot.org Cedar Park, Texas United States",
      "ja": "デビッド・A・ブライアンethernot.orgシーダーパーク、テキサス州アメリカ合衆国"
    },
    {
      "indent": 3,
      "text": "Email: dbryan@ethernot.org",
      "ja": "メール：dbryan@ethernot.org"
    },
    {
      "indent": 3,
      "text": "Yi Sun ICT",
      "ja": "李日ICT"
    },
    {
      "indent": 3,
      "text": "Email: sunyi@ict.ac.cn",
      "ja": "メール：sunyi@ict.ac.cn"
    }
  ]
}