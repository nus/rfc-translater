{
  "title": {
    "text": "RFC 7806 - On Queuing, Marking, and Dropping",
    "ja": "RFC 7806 - キューイング、マーキング、および削除の"
  },
  "number": 7806,
  "created_at": "2019-11-01 23:16:51.625843+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                          F. Baker\nRequest for Comments: 7806                                        R. Pan\nCategory: Informational                                    Cisco Systems\nISSN: 2070-1721                                               April 2016",
      "raw": true
    },
    {
      "indent": 19,
      "text": "On Queuing, Marking, and Dropping",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This note discusses queuing and marking/dropping algorithms. While these algorithms may be implemented in a coupled manner, this note argues that specifications, measurements, and comparisons should decouple the different algorithms and their contributions to system behavior.",
      "ja": "このノートは、アルゴリズムをドロップ/キューイングとマーキングについて説明します。これらのアルゴリズムは、結合された方法で実施することができるが、このノート仕様、測定、および比較は、異なるアルゴリズムおよびシステムの動作への貢献を分離すべきであると主張しています。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "ja": "このドキュメントはインターネット標準化過程仕様ではありません。それは、情報提供の目的のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are a candidate for any level of Internet Standard; see Section 2 of RFC 5741.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。 IESGによって承認されていないすべての文書がインターネットStandardのどんなレベルの候補です。 RFC 5741のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7806.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7806で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2016 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2016 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   2\n2.  Fair Queuing: Algorithms and History  . . . . . . . . . . . .   3\n  2.1.  Generalized Processor Sharing . . . . . . . . . . . . . .   3\n    2.1.1.  GPS Comparisons: Transmission Quanta  . . . . . . . .   4\n    2.1.2.  GPS Comparisons: Flow Definition  . . . . . . . . . .   4\n    2.1.3.  GPS Comparisons: Unit of Measurement  . . . . . . . .   5\n  2.2.  GPS Approximations  . . . . . . . . . . . . . . . . . . .   5\n    2.2.1.  Definition of a Queuing Algorithm . . . . . . . . . .   5\n    2.2.2.  Round-Robin Models  . . . . . . . . . . . . . . . . .   6\n    2.2.3.  Calendar Queue Models . . . . . . . . . . . . . . . .   7\n    2.2.4.  Work-Conserving Models and Stochastic Fairness\n            Queuing . . . . . . . . . . . . . . . . . . . . . . .   9\n    2.2.5.  Non-Work-Conserving Models and Virtual Clock  . . . .   9\n3.  Queuing, Marking, and Dropping  . . . . . . . . . . . . . . .  10\n  3.1.  Queuing with Tail Mark/Drop . . . . . . . . . . . . . . .  11\n  3.2.  Queuing with CoDel Mark/Drop  . . . . . . . . . . . . . .  11\n  3.3.  Queuing with RED or PIE Mark/Drop . . . . . . . . . . . .  11\n4.  Conclusion  . . . . . . . . . . . . . . . . . . . . . . . . .  12\n5.  Security Considerations . . . . . . . . . . . . . . . . . . .  13\n6.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  13\n  6.1.  Normative References  . . . . . . . . . . . . . . . . . .  13\n  6.2.  Informative References  . . . . . . . . . . . . . . . . .  13\nAcknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  15\nAuthors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  16",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "In the discussion of Active Queue Management (AQM), there has been discussion of the coupling of queue management algorithms such as Stochastic Fairness Queuing [SFQ], Virtual Clock [VirtualClock], or Deficit Round Robin [DRR] with mark/drop algorithms such as Controlled Delay (CoDel) [DELAY-AQM] or Proportional Integral controller Enhanced (PIE) [AQM-PIE]. In the interest of clarifying the discussion, we document possible implementation approaches to that and analyze the possible effects and side effects. The language and model derive from the Architecture for Differentiated Services [RFC2475].",
      "ja": "アクティブキュー管理（AQM）の議論では、このようなマーク/ドロップアルゴリズムと、そのような確率フェアネス・キューイング[SFQ]、仮想時計[VirtualClock]、または赤字ラウンドロビン[DRR]としてキュー管理アルゴリズムのカップリングの議論がありました制御遅延（CODEL）DELAY-AQM]または拡張比例積分制御（PIE）AQM-PIE]として。議論を明確に関心では、我々はそれに可能な実装手法を文書化し、可能な効果と副作用を分析します。言語モデルは、差別化サービス[RFC2475]のためのアーキテクチャから派生します。"
    },
    {
      "indent": 3,
      "text": "This note is informational and is intended to describe reasonable possibilities without constraining outcomes. This is not so much about \"right\" or \"wrong\" as it is \"what might be reasonable\" and discusses several possible implementation strategies. Also, while queuing might be implemented in almost any layer, the note specifically addresses queues that might be used in the Differentiated Services Architecture and are therefore at or below the IP layer.",
      "ja": "このノートは情報であるとの結果を制限することなく、合理的な可能性を説明することを意図しています。これは、「合理的であるかもしれないもの」であるとして、「右」または「間違っている」についてはあまりなく、いくつかの可能な実装戦略について説明します。キューイングは、ほぼすべての層に実装されるかもしれないが。また、ノートでは、具体的に、またはIP層の下したがって、差別化サービスアーキテクチャで使用しているかもしれないキューに対応しています。"
    },
    {
      "indent": 0,
      "text": "2. Fair Queuing: Algorithms and History",
      "section_title": true,
      "ja": "2.フェアキューイング：アルゴリズムと歴史"
    },
    {
      "indent": 3,
      "text": "There is extensive history in the set of algorithms collectively referred to as \"fair queuing\". The model was initially discussed in [RFC970], which proposed it hypothetically as a solution to the TCP Silly Window Syndrome issue in BSD 4.1. The problem was that, due to a TCP implementation bug, some senders would settle into sending a long stream of very short segments, which unnecessarily consumed bandwidth on TCP and IP headers and occupied short packet buffers, thereby disrupting competing sessions. Nagle suggested that if packet streams were sorted by their source address and the sources treated in a round-robin fashion, a sender's effect on end-to-end latency and increased loss rate would primarily affect only itself. This touched off perhaps a decade of work by various researchers on what was and is termed \"fair queuing\", philosophical discussions of the meaning of the word \"fair\", operational reasons that one might want a \"weighted\" or \"predictably unfair\" queuing algorithm, and so on.",
      "ja": "総称して「公平キューイング」と呼ばれるアルゴリズムのセットで豊富な歴史があります。モデルは、最初BSD 4.1でTCPシリーウインドウシンドロームの問題に対する解決策として、仮にそれを提案している、[RFC970]で議論されました。問題は、TCPの実装のバグが、いくつかの送信者は、これにより、不必要なTCPおよびIPヘッダ上の帯域幅を消費し、ショートパケットバッファを占有非常に短いセグメントの長いストリームを送信競合セッションを中断することに落ち着くだろう、ということでした。ネーグルは、もしパケットストリームは、その送信元アドレスと、ラウンドロビン方式で処理するソースによってソートされたエンド・ツー・エンドの待ち時間に、送信者の影響と損失の増加率は、主にのみ、それ自体に影響を与えることを示唆しました。これは何であったかについて、様々な研究者による作品のおそらく十年を触発し、「公平キューイング」、「公正」という言葉の意味の哲学的議論、1は「加重」または「予想通り不公平」をお勧めします運用上の理由がキューイングと呼ばれますアルゴリズム、およびように。"
    },
    {
      "indent": 0,
      "text": "2.1. Generalized Processor Sharing",
      "section_title": true,
      "ja": "2.1。汎用プロセッサシェアリング"
    },
    {
      "indent": 3,
      "text": "Conceptually, any fair queuing algorithm attempts to implement some approximation to the Generalized Processor Sharing [GPS] model.",
      "ja": "概念的には、任意の公平キューイングアルゴリズムは一般化プロセッサの共有[GPS]モデルにいくつかの近似を実装しようとします。"
    },
    {
      "indent": 3,
      "text": "The GPS model, in its essence, presumes that a set of identified data streams, called \"flows\", pass through an interface. Each flow has a rate when measured over a period of time; a voice session might, for example, require 64 kbit/s plus whatever overhead is necessary to deliver it, and a TCP session might have variable throughput depending on where it is in its evolution. The premise of Generalized Processor Sharing is that on all time scales, the flow occupies a predictable bit rate so that if there is enough bandwidth for the flow in the long term, it also lacks nothing in the short term. \"All time scales\" is obviously untenable in a packet network -- and even in a traditional Time-Division Multiplexer (TDM) circuit switch network -- because a timescale shorter than the duration of a packet will only see one packet at a time. However, it provides an ideal for other models to be compared against.",
      "ja": "GPSモデルは、その本質的に、「フロー」と呼ばれる識別されたデータストリームのセットは、インターフェイスを通過することを前提。各フローは、時間の期間にわたって測定された率を持っています。音声セッションは、たとえば、64キロビット/秒を必要とプラス何でもオーバーヘッドは、それを実現する必要があり、TCPセッションは、その進化している場所に応じて可変のスループットを持っている場合があります。汎用プロセッサシェアリングの前提は長期的には、フローのための十分な帯域幅がある場合、それはまた、短期的には何も欠けないように、全ての時間スケールで、流れが予測可能なビットレートを占めているということです。パケットの持続時間よりも短い時間スケールは一度に一つのパケットが表示されますので、 - とさえ伝統的な時分割マルチプレクサ（TDM）回線交換網で - 「すべての時間スケールは、」明らかに、パケット網で理不尽です。しかし、比較されるべき他のモデルのための理想的なを提供します。"
    },
    {
      "indent": 3,
      "text": "There are a number of attributes of approximations to the GPS model that bear operational consideration, including at least the transmission quanta, the definition of a \"flow\", and the unit of measurement. Implementation approaches have different practical impacts as well.",
      "ja": "少なくとも送信量子、「フロー」の定義、および測定の単位を含む動作を考慮に耐えるGPSモデルへの近似の属性の数があります。実装のアプローチは、同様に別の実用的な影響を持っています。"
    },
    {
      "indent": 0,
      "text": "2.1.1. GPS Comparisons: Transmission Quanta",
      "section_title": true,
      "ja": "2.1.1。 GPSの比較：送信クアンタ"
    },
    {
      "indent": 3,
      "text": "The most obvious comparison between the GPS model and common approximations to it is that real world data is not delivered uniformly, but in some quantum. The smallest quantum in a packet network is a packet. But quanta can be larger; for example, in video applications, it is common to describe data flow in frames per second, where a frame describes a picture on a screen or the changes made from a previous one. A single video frame is commonly on the order of tens of packets. If a codec is delivering thirty frames per second, it is conceivable that the packets comprising a frame might be sent as thirty bursts per second, with each burst sent at the interface rate of the camera or other sender. Similarly, TCP exchanges have an initial window (common values of which include 1, 2, 3, 4 [RFC3390], and 10 [RFC6928]), and there are also reports of bursts of 64 KB at the relevant Maximum Segment Size (MSS), which is to say about 45 packets in one burst, presumably coming from TCP Segment Offload ((TSO) also called TCP Offload Engine (TOE)) engines (at least one implementation is known to be able to send a burst of 256 KB). After that initial burst, TCP senders commonly send pairs of packets but may send either smaller or larger bursts [RFC5690].",
      "ja": "それにGPSモデルと共通近似の間の最も明白な比較は、実世界のデータは一様に配信が、いくつかの量子にされていないということです。パケットネットワークにおける最小の量子パケットです。しかし、量子が大きくなることができます。例えば、ビデオ・アプリケーションでは、フレームは画面または前のものから作られた変更に画像を記述する秒あたりのフレーム内のデータの流れを記述するのが一般的です。単一のビデオフレームは、パケットの数十のオーダーにあるのが一般的です。コーデックは毎秒30個のフレームを提供している場合は、フレームを含むパケットは、カメラ又は他の送信者のインターフェース・レートで送信される各バーストで、毎秒30のバーストとして送信されるかもしれないことが考えられます。同様に、TCP交換は初期画面（共通1を含むそれらの値、2、3、4、[RFC3390]及び10 [RFC6928]）を有し、また、ある関連する最大セグメントサイズ（MSSで64キロバイトのバースト報告）、おそらくTCPセグメントオフロード（（TSO）からの1つのバーストでは約45パケットは、また、TCPオフロードエンジン（TOE））エンジン（少なくとも1つのインプリメンテーションが256キロバイトのバーストを送信することができることが知られていると呼ばれると言うことです）。その初期バースト後、TCP送信者は、一般的にパケットのペアを送信するが、いずれか小さいか大きいバースト[RFC5690]を送信してもよいです。"
    },
    {
      "indent": 0,
      "text": "2.1.2. GPS Comparisons: Flow Definition",
      "section_title": true,
      "ja": "2.1.2。 GPSの比較：フロー定義"
    },
    {
      "indent": 3,
      "text": "An important engineering trade-off relevant to GPS is the definition of a \"flow\". A flow is, by definition, a defined data stream. Common definitions include:",
      "ja": "GPSに関連する重要なエンジニアリングのトレードオフは、「フロー」の定義です。フローは、定義により、定義されたデータストリームです。一般的な定義は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o packets in a single transport layer session (\"microflow\"), identified by a five-tuple [RFC2990];",
      "ja": "5タプル[RFC2990]によって識別される単一のトランスポート層セッション（「マイクロ」）中のOのパケット;"
    },
    {
      "indent": 3,
      "text": "o packets between a single pair of addresses, identified by a source and destination address or prefix;",
      "ja": "送信元および宛先アドレスまたはプレフィックスによって識別されるアドレス、単一の対の間の入出力パケット。"
    },
    {
      "indent": 3,
      "text": "o packets from a single source address or prefix [RFC970];",
      "ja": "単一のソースアドレスまたはプレフィックスからOパケット[RFC970]。"
    },
    {
      "indent": 3,
      "text": "o packets to a single destination address or prefix; and",
      "ja": "単一の宛先アドレスまたはプレフィックスに対するOのパケット。そして"
    },
    {
      "indent": 3,
      "text": "o packets to or from a single subscriber, customer, or peer [RFC6057]. In Service Provider operations, this might be a neighboring Autonomous System; in broadband, this might be a residential customer.",
      "ja": "パケット又は単一の加入者、顧客、またはピア[RFC6057]からO。サービスプロバイダ事業では、これは近隣の自律システムであるかもしれません。ブロードバンドでは、これは住宅の顧客であるかもしれません。"
    },
    {
      "indent": 3,
      "text": "The difference should be apparent. Consider a comparison between sorting by source address or destination address, to pick two examples, in the case that a given router interface has N application sessions going through it between N/2 local destinations and N remote sources. Sorting by source, or in this case by source/destination pair, would give each remote peer an upper-bound guarantee of 1/N of the available capacity, which might be distributed very unevenly among the local destinations. Sorting by destination would give each local destination an upper-bound guarantee of 2/N of the available capacity, which might be distributed very unevenly among the remote systems and correlated sessions. Who is one fair to? In both cases, they deliver equal service by their definition, but that might not be someone else's definition.",
      "ja": "違いは明らかであるべきです。所与のルータインターフェイスは、N / 2ローカル宛先およびNリモートソースとの間にそれを通過するN個のアプリケーションセッションを有する場合に、2つの例を選択するために、ソースアドレスまたは宛先アドレスでソート間の比較を考えます。ソースによって、またはこの場合には、ソース/宛先ペアによってソート、各リモートピアにローカルな目的地の間で非常に不均一に分布されるかもしれない利用可能な容量の1 / Nの上限保証を与えます。先によってソートする各ローカルの宛先をリモートシステムと相関セッションの間で非常に不均一に分布されるかもしれない利用可能な容量の2 / Nの上限保証を与えます。 1つのフェアは誰ですか？どちらの場合も、彼らはその定義によって同等のサービスを提供し、それは誰か他の人の定義ではないかもしれません。"
    },
    {
      "indent": 3,
      "text": "Flow fairness, and the implications of TCP's congestion avoidance algorithms, is discussed extensively in [NoFair].",
      "ja": "公平性をフロー、およびTCPの輻輳回避アルゴリズムの意味は、[NoFair]で広く議論されています。"
    },
    {
      "indent": 0,
      "text": "2.1.3. GPS Comparisons: Unit of Measurement",
      "section_title": true,
      "ja": "2.1.3。 GPSの比較：測定単位"
    },
    {
      "indent": 3,
      "text": "And finally, there is the question of what is measured for rate. If the only objective is to force packet streams to not dominate each other, it is sufficient to count packets. However, if the issue is the bit rate of a Service Level Agreement (SLA), one must consider the sizes of the packets (the aggregate throughput of a flow measured in bits or bytes). If predictable unfairness is a consideration, the value must be weighted accordingly.",
      "ja": "そして最後に、率を測定するものの質問があります。唯一の目的はお互いを支配しないようにパケットストリームを強制する場合は、パケットをカウントするのに十分です。問題は、サービスレベル契約（SLA）のビットレートである場合は、一つのパケットのサイズ（ビット単位またはバイト単位で測定されたフローの総スループット）を考慮しなければなりません。予測可能な不公平が考慮された場合、値はそれに応じて重み付けをしなければなりません。"
    },
    {
      "indent": 3,
      "text": "[RFC7141] discusses measurement.",
      "ja": "[RFC7141]は、測定を論じています。"
    },
    {
      "indent": 0,
      "text": "2.2. GPS Approximations",
      "section_title": true,
      "ja": "2.2。 GPS近似"
    },
    {
      "indent": 3,
      "text": "Carrying the matter further, a queuing algorithm may also be termed \"work conserving\" or \"non work conserving\". A queue in a work-conserving algorithm, by definition, is either empty, in which case no attempt is being made to dequeue data from it, or contains something, in which case the algorithm continuously tries to empty the queue. A work-conserving queue that contains queued data at an interface with a given rate will deliver data at that rate until it empties. A non-work-conserving queue might stop delivering even though it still contains data. A common reason for doing this is to impose an artificial upper bound on a class of traffic that is lower than the rate of the underlying physical interface.",
      "ja": "さらに問題を運ぶ、キューイングアルゴリズムは、「作業節約」や「節約以外の仕事を」と呼ぶことができます。作業保存アルゴリズムにおけるキューは、定義により、試みはそれからデータをデキューするために行われていない、または何かが含まれている、アルゴリズムは継続的にキューを空にしようとした場合にはされている場合には、空ですか。それが空になるまで一定の割合で界面でのキューイングされたデータが含まれている作業保存キューは、そのレートでデータをお届けします。非作業保存キューは、それはまだデータが含まれているにもかかわらず、配信を停止することがあります。これを行うための一般的な理由は、基礎となる物理インターフェイスのレートより低いトラフィックのクラスに人工的な上限を課すことです。"
    },
    {
      "indent": 0,
      "text": "2.2.1. Definition of a Queuing Algorithm",
      "section_title": true,
      "ja": "2.2.1。キューイングアルゴリズムの定義"
    },
    {
      "indent": 3,
      "text": "In the discussion following, we assume a basic definition of a queuing algorithm. A queuing algorithm has, at minimum:",
      "ja": "以下の議論では、我々は、キューイングアルゴリズムの基本的な定義を前提としています。キューイングアルゴリズムは、最低でも、持っています："
    },
    {
      "indent": 3,
      "text": "o some form of internal storage for the elements kept in the queue;",
      "ja": "キューに保持要素のための内部ストレージのいくつかのフォームOであり;"
    },
    {
      "indent": 3,
      "text": "o if it has multiple internal classifications, then it has",
      "ja": "それは、複数の内部の分類を持っている場合は、O、それは持っています"
    },
    {
      "indent": 6,
      "text": "* a method for classifying elements and",
      "ja": "*要素を分類する方法と"
    },
    {
      "indent": 6,
      "text": "* additional storage for the classifier and implied classes;",
      "ja": "*分類器と暗示クラスのための追加の記憶;"
    },
    {
      "indent": 3,
      "text": "o potentially, a method for creating the queue;",
      "ja": "O潜在的に、キューを作成する方法。"
    },
    {
      "indent": 3,
      "text": "o potentially, a method for destroying the queue;",
      "ja": "O潜在的に、キューを破壊するための方法。"
    },
    {
      "indent": 3,
      "text": "o an enqueuing method for placing packets into the queue or queuing system; and",
      "ja": "キューにパケットを配置したり、システムをキューイングするためのエンキュー方法O。そして"
    },
    {
      "indent": 3,
      "text": "o a dequeuing method for removing packets from the queue or queuing system.",
      "ja": "キューからパケットを除去またはシステムをキューイングするためのデキュ​​ー方法O。"
    },
    {
      "indent": 3,
      "text": "There may also be other information or methods, such as the ability to inspect the queue. It also often has inspectable external attributes, such as the total volume of packets or bytes in queue, and may have limit thresholds, such as a maximum number of packets or bytes the queue might hold.",
      "ja": "また、他の情報、またはそのようなキューを検査する機能などの方法が存在してもよいです。それはまた、多くの場合、キュー内のパケットまたはバイト数の合計体積として検査可能外部の属性を有し、そのようなパケットの最大数として制限しきい値を有してもよく、またはキューが保持するかもしれないバイト。"
    },
    {
      "indent": 3,
      "text": "For example, a simple FIFO queue has a linear data structure, enqueues packets at the tail, and dequeues packets from the head. It might have a maximum queue depth and a current queue depth maintained in packets or bytes.",
      "ja": "たとえば、単純なFIFOキューは、線形データ構造を有し尾でパケットをキューに入れ、そして頭からパケットをデキューします。これは、キューの最大の深さと、パケットまたはバイト単位で維持され、現在のキューの深さを持っているかもしれません。"
    },
    {
      "indent": 0,
      "text": "2.2.2. Round-Robin Models",
      "section_title": true,
      "ja": "2.2.2。ラウンドロビンモデル"
    },
    {
      "indent": 3,
      "text": "One class of implementation approaches, generically referred to as \"Weighted Round Robin\" (WRR), implements the structure of the queue as an array or ring of subqueues associated with flows for whatever definition of a flow is important.",
      "ja": "流れのどの定義するためのフローに関連するサブキューのアレイまたは環が重要であるとして一般に「加重ラウンドロビン」（WRR）と呼ばれる実装アプローチの1つのクラスは、キューの構造を実現します。"
    },
    {
      "indent": 3,
      "text": "The arriving packet must, of course, first be classified. If a hash is used as a classifier, the hash result might be used as an array index, selecting the subqueue that the packet will go into. One can imagine other classifiers, such as using a Differentiated Services Code Point (DSCP) value as an index into an array containing the queue number for a flow, or more complex access list implementations.",
      "ja": "到着したパケットは、もちろん、最初に分類されなければなりません。ハッシュが分類器として使用されている場合は、ハッシュ結果は、パケットがになりますサブキューを選択し、配列のインデックスとして使用される可能性があります。一つは、このような流れのためのキュー番号、またはより複雑なアクセスリストの実装を含む配列へのインデックスとして差別化サービスコードポイント（DSCP）値を使用するなど、他の分類器を、想像することができます。"
    },
    {
      "indent": 3,
      "text": "In any event, a subqueue contains the traffic for a flow, and data is sent from each subqueue in succession.",
      "ja": "いずれにせよ、サブキューは、フローのトラフィックが含まれており、データが連続して各サブキューから送信されます。"
    },
    {
      "indent": 3,
      "text": "Upon entering the queue, the enqueue method places a classified packet into a simple FIFO subqueue.",
      "ja": "キューに入ると、エンキュー方法は、単純なFIFOのサブキューに分類パケットを配置します。"
    },
    {
      "indent": 3,
      "text": "On dequeue, the subqueues are searched in round-robin order, and when a subqueue is identified that contains data, the dequeue method removes a specified quantum of data from it. That quantum is at minimum a packet, but it may be more. If the system is intended to maintain a byte rate, there will be memory between searches of the excess previously dequeued.",
      "ja": "デキューに、サブキューはラウンドロビンの順序で検索され、そしてサブキューにデータが含まれていることを識別された場合、デキューする方法は、そこからデータの指定された量子を除去します。その量子は、最低でもパケットであるが、それは以上であってもよいです。システムはバイトレートを維持するために意図されている場合は、以前にデキュー過剰の検索の間にメモリが存在します。"
    },
    {
      "indent": 22,
      "text": "      +-+\n    +>|1|\n    | +-+\n    |  |\n    | +-+               +-+\n    | |1|             +>|3|\n    | +-+             | +-+\n    |  |              |  |\n    | +-+      +-+    | +-+\n    | |1|    +>|2|    | |3|\n    | +-+    | +-+    | +-+\n    |  A     |  A     |  A\n    |  |     |  |     |  |\n   ++--++   ++--++   ++--++\n+->| Q  |-->| Q  |-->| Q  |--+\n|  +----+   +----+   +----+  |\n+----------------------------+",
      "raw": true
    },
    {
      "indent": 23,
      "text": "Figure 1: Round-Robin Queues",
      "ja": "図1：ラウンドロビンキュー"
    },
    {
      "indent": 0,
      "text": "2.2.3. Calendar Queue Models",
      "section_title": true,
      "ja": "2.2.3。カレンダキューモデル"
    },
    {
      "indent": 3,
      "text": "Another class of implementation approaches, generically referred to as Calendar Queue Implementations [CalendarQueue], implements the structure of the queue as an array or ring of subqueues (often called \"buckets\") associated with time or sequence; each bucket contains the set of packets, which may be null, intended to be sent at a certain time or following the emptying of the previous bucket. The queue structure includes a look-aside table that indicates the current depth (which is to say, the next bucket) of any given class of traffic, which might similarly be identified using a hash, a DSCP, an access list, or any other classifier. Conceptually, the queues each contain zero or more packets from each class of traffic. One is the queue being emptied \"now\"; the rest are associated with some time or sequence in the future. The characteristics under \"load\" have been investigated in [Deadline].",
      "ja": "一般的にカレンダーキュー実装【CalendarQueue]と呼ばれる実装アプローチの別のクラスは、時間又はシーケンスに関連する（しばしば「バケット」と呼ばれる）サブキューのアレイ又はリングとしてキューの構造を実現します。各バケットは、特定の時間に、または前のバケットの排出を以下送信することを意図するものでヌルとすることができるパケットのセットを含みます。キュー構造は、同様に、ハッシュ、DSCP、アクセスリスト、またはその他を使用して識別されるかもしれないトラフィックの任意のクラスの（と言うことです、次のバケット）現在の深さを示しルックアサイドテーブルを含んでいます分類器。概念的には、キューそれぞれは、トラフィックの各クラスからのゼロ個以上のパケットを含みます。一つは、「今」空にされているキューです。残りは将来のある時点またはシーケンスに関連付けされています。 「負荷」の下の特性は[締切]で検討されています。"
    },
    {
      "indent": 3,
      "text": "Upon entering the queue, the enqueue method, considering a classified packet, determines the current depth of that class with a view to scheduling it for transmission at some time or sequence in the future. If the unit of scheduling is a packet and the queuing quantum is one packet per subqueue, a burst of packets arrives in a given flow, and if at the start the flow has no queued data, the first packet goes into the \"next\" queue, the second into its successor, and so on. If there was some data in the class, the first packet in the burst would go into the bucket pointed to by the look-aside table. If the unit of scheduling is time, the explanation in Section 2.2.5 might be simplest to follow, but the bucket selected will be the bucket corresponding to a given transmission time in the future. A necessary side effect, memory being finite, is that there exist a finite number of \"future\" buckets. If enough traffic arrives to cause a class to wrap, one is forced to drop something (tail drop).",
      "ja": "分類されたパケットを考慮すると、キュー、エンキュー方法に入ると、将来のある時点またはシーケンスでの伝送のためにそれをスケジュールを視野に入れて、そのクラスの現在の深さを決定します。スケジューリングの単位はパケットであるとキューイング量子サブキューにつき1つのパケットである場合は、パケットのバーストは、所定のフローに到着し、何がデータをキューに入れられた流れを起動しないであれば、最初のパケットは「次」のキューに入ります、その後継者に二、というように。クラス内の一部のデータがあった場合は、バーストの最初のパケットは、バケットがルックアサイドテーブルによって指さに行くだろう。スケジューリングの単位は時間である場合は、2.2.5項で説明が続くための最も簡単なことかもしれないが、選択されたバケットは、将来的に与えられた伝送時間に対応するバケットになります。必要な副作用は、メモリは有限であり、「未来」バケットの有限数が存在することです。十分なトラフィックをラップするクラスを引き起こすために到着した場合、1は何か（テールドロップ）をドロップするように強制されます。"
    },
    {
      "indent": 3,
      "text": "On dequeue, the buckets are searched at their stated times or in their stated sequence, and when a bucket is identified that contains data, the dequeue method removes a specified quantum of data from it and, by extension, from the associated traffic classes. A single bucket might contain data from a number of classes simultaneously.",
      "ja": "デキューでは、バケットは、その定められた時刻に、またはその定められた順序で検索され、バケットにデータが含まれていることが同定されている場合、デキューの方法は、関連するトラフィッククラスから、拡張子によって、そこからデータの指定された量子を削除します。単一バケットは同時に多数のクラスからのデータが含まれる場合があります。"
    },
    {
      "indent": 18,
      "text": "           +-+\n         +>|1|\n         | +-+\n         |  |\n         | +-+      +-+\n         | |2|    +>|2|\n         | +-+    | +-+\n         |  |     |  |\n         | +-+    | +-+      +-+\n         | |3|    | |1|    +>|1|\n         | +-+    | +-+    | +-+\n         |  A     |  A     |  A\n         |  |     |  |     |  |\n        ++--++   ++--++   ++--++\n\"now\"+->| Q  |-->| Q  |-->| Q  |-->...\n        +----+   +----+   +----+\n           A       A         A\n           |3      |2        |1\n        +++++++++++++++++++++++\n        ||||     Flow      ||||\n        +++++++++++++++++++++++",
      "raw": true
    },
    {
      "indent": 25,
      "text": "Figure 2: Calendar Queue",
      "ja": "図2：カレンダキュー"
    },
    {
      "indent": 3,
      "text": "In any event, a subqueue contains the traffic for a point in time or a point in sequence, and data is sent from each subqueue in succession. If subqueues are associated with time, an interesting end case develops: if the system is draining a given subqueue and the time of the next subqueue arrives, what should the system do? One potentially valid line of reasoning would have it continue delivering the data in the present queue on the assumption that it will likely trade off for time in the next. Another potentially valid line of reasoning would have it discard any waiting data in the present queue and move to the next.",
      "ja": "いずれにせよ、サブキューは、特定の時点またはシーケンス内のポイントのトラフィックが含まれており、データが連続して各サブキューから送信されます。サブキューは、時間に関連付けられている場合は、興味深いエンドケースは、開発：システムが与えられたサブキューを排出され、次のサブキューの時間が到着した場合、システムが何をすべきでしょうか？推論の一つの潜在的に有効なラインは、それはそれはおそらく次の時間のためのトレードオフになることを前提に現在キューにデータを提供し続けるだろう。推論のもう一つの潜在的に有効なラインは、それが現在キュー内で待機中のデータを破棄し、次へ移動しなければなりません。"
    },
    {
      "indent": 0,
      "text": "2.2.4. Work-Conserving Models and Stochastic Fairness Queuing",
      "section_title": true,
      "ja": "2.2.4。作業保存モデルと確率的公正キューイング"
    },
    {
      "indent": 3,
      "text": "Stochastic Fairness Queuing [SFQ] is an example of a work-conserving algorithm. This algorithm measures packets and considers a \"flow\" to be an equivalence class of traffic defined by a hashing algorithm over the source and destination IPv4 addresses. As packets arrive, the enqueue method performs the indicated hash and places the packet into the indicated subqueue. The dequeue method operates as described in Section 2.2.2; subqueues are inspected in round-robin sequence and a packet is removed if they contain one or more packets.",
      "ja": "確率的公平キューイング[SFQは】ワーク節約アルゴリズムの一例です。このアルゴリズムは、測定パケットと送信元および宛先IPv4アドレス上ハッシュアルゴリズムによって定義されたトラフィックの同値類であることを「フロー」を考えます。パケットが到着すると、エンキュー方法が示され、ハッシュを実行し、指示されたサブキューにパケットを配置します。 2.2.2項で説明したようにデキューする方法は動作し、サブキューはラウンドロビン順序で検査され、それらが1つ以上のパケットが含まれている場合、パケットは削除されます。"
    },
    {
      "indent": 3,
      "text": "The Deficit Round Robin [DRR] model modifies the quanta to bytes and deals with variable length packets. A subqueue descriptor contains a waiting quantum (the amount intended to be dequeued on the previous dequeue attempt that was not satisfied), a per-round quantum (the subqueue is intended to dequeue a certain number of bytes each round), and a maximum to permit (some multiple of the MTU). In each dequeue attempt, the dequeue method sets the waiting quantum to the smaller of the maximum quantum and the sum of the waiting and incremental quantum. It then dequeues up to the waiting quantum (in bytes) of packets in the queue and reduces the waiting quantum by the number of bytes dequeued. Since packets will not normally be exactly the size of the quantum, some dequeue attempts will dequeue more than others, but they will over time average the incremental quantum per round if there is data present.",
      "ja": "不足ラウンドロビン[DRR]モデルは、可変長パケットを有するバイトと事前に量子を修正します。サブキュー記述子は待機量子（満足しなかった以前のデキュー試行でデキューされることを意図量）、毎ラウンド量子（サブキューは、各ラウンドバイトの一定数をデキューすることを意図している）、および最大が含ま許可証（MTUのいくつかの倍数）。各デキュー試みにおいて、デキューする方法は、最大量子小さく、待機及び増分量子の和に待機量子を設定します。これは、キュー内のパケットの（バイト単位）待っている量子までデキューし、デキューバイト数で待っている量子を低減します。パケットは、通常、量子の正確大きさではありませんので、いくつかのデキューの試みは他のものよりをデキューしますが、データが存在した場合、彼らはラウンドごとに増分量子時間平均をオーバーします。"
    },
    {
      "indent": 3,
      "text": "[SFQ] and [DRR] could be implemented as described in Section 2.2.3. The weakness of a classical WRR approach is the search time expended inspecting and not choosing sub-queues that contain no data or not enough to trigger a transmission from them.",
      "ja": "セクション2.2.3に記載したように[SFQ]及び[DRR]実施することができます。古典WRRアプローチの弱点は、検索時間が検査し、それらからの送信をトリガするのに十分な何のデータかどうかが含まれていないサブキューを選択しないで消費されます。"
    },
    {
      "indent": 0,
      "text": "2.2.5. Non-Work-Conserving Models and Virtual Clock",
      "section_title": true,
      "ja": "2.2.5。非作業保存モデルと仮想時計"
    },
    {
      "indent": 3,
      "text": "Virtual Clock [VirtualClock] is an example of a non-work-conserving algorithm. It is trivially implemented as described in Section 2.2.3. It associates buckets with intervals in time that have durations on the order of microseconds to tens of milliseconds. Each flow is assigned a rate in bytes per interval. The flow entry maintains a point in time the \"next\" packet in the flow should be scheduled.",
      "ja": "仮想時計は、[VirtualClock]非作業保存アルゴリズムの一例です。 2.2.3項で説明したようにそれは自明実装されています。これは、数十ミリ秒マイクロ秒程度の持続時間を有する時間の間隔でバケットを関連付けます。各フローは、間隔あたりのバイト数レートが割り当てられます。フローエントリは、フロー内の「次」のパケットが必要な時期である時点を維持しています。"
    },
    {
      "indent": 3,
      "text": "On enqueue, the method determines whether the \"next schedule\" time is \"in the past\"; if so, the packet is scheduled \"now\", and if not, the packet is scheduled at that time. It then calculates the new \"next schedule\" time as the current \"next schedule\" time plus the length of the packet divided by the rate. If the resulting time is also in the past, the \"next schedule\" time is set to \"now\"; otherwise, it is set to the calculated time. As noted in Section 2.2.3, there is an interesting point regarding \"too much time in the future\"; if a packet is scheduled too far into the future, it may be marked or dropped in the AQM procedure, and if it runs beyond the end of the queuing system, may be defensively tail dropped.",
      "ja": "エンキューに、この方法は、「次のスケジュール」時間「が過去」であるか否かを判定する。その場合、パケットは「今」予定されている、とされていない場合、パケットは、その時点で予定されています。その後、現在の「次のスケジュール」の時間を加えた率で割ったパケットの長さとして、新しい「次のスケジュール」の時間を計算します。その結果、時間が過去にもある場合は、「次のスケジュール」の時間は、「今」に設定されています。それ以外の場合は、算出された時間に設定されています。 2.2.3項で述べたように、「将来的にあまりにも多くの時間」に関する興味深い点があります。パケットがあまりにも遠い将来に予定されている場合、それはマークまたは削除AQMの手順で、それがキューイング・システムの終わりを超えて実行されている場合、防御的に尾が破棄される可能性がありすることができます。"
    },
    {
      "indent": 3,
      "text": "On dequeue, the bucket associated with the time \"now\" is inspected. If it contains a packet, the packet is dequeued and transmitted. If the bucket is empty and the time for the next bucket has not arrived, the system waits, even if there is a packet in the next bucket. As noted in Section 2.2.3, there is an interesting point regarding the queue associated with \"now\". If a subsequent bucket, even if it is actually empty, would be delayed by the transmission of a packet, one could imagine marking the packet Explicit Congestion Notification - Congestion Experienced (ECN-CE) [RFC3168] [RFC6679] or dropping the packet.",
      "ja": "デキューでは、時間に関連したバケットは、「今」を検査します。それは、パケットが含まれている場合、パケットはキューから取り出されて送信されます。バケットが空で、次のバケットのための時間が到着していない場合、システムは次のバケットでパケットがあっても、待っています。 2.2.3項で述べたように、「今」に関連付けられたキューに関する興味深い点があります。後続のバケットが、それが実際に空であっても、パケットの伝送によって遅延される場合、一つのパケット明示的輻輳通知マーキング想像 - 輻輳経験（ECN-CE）[RFC3168]、[RFC6679]、またはパケットをドロップします。"
    },
    {
      "indent": 0,
      "text": "3. Queuing, Marking, and Dropping",
      "section_title": true,
      "ja": "3.キューイング、マーキング、およびドロップ"
    },
    {
      "indent": 3,
      "text": "Queuing, marking, and dropping are integrated in any system that has a queue. If nothing else, as memory is finite, a system has to drop as discussed in Sections 2.2.3 and 2.2.5 in order to protect itself. However, host transports interpret drops as signals, so AQM algorithms use that as a mechanism to signal.",
      "ja": "キューイング、マーキング、およびドロップはキューを持っている任意のシステムに統合されています。何もない場合は、メモリが有限であるように、システムは、セクション2.2.3と2.2.5で説明したように、それ自体を保護するためにドロップする必要があります。しかし、ホストが信号として滴を解釈搬送ので、AQMアルゴリズムはシグナリングするメカニズムとしてそれを使用します。"
    },
    {
      "indent": 3,
      "text": "It is useful to think of the effects of queuing as a signal as well. The receiver sends acknowledgements as data is received, so the arrival of acknowledgements at the sender paces the sender at approximately the average rate it is able to achieve through the network. This is true even if the sender keeps an arbitrarily large amount of data stored in network queues and is the basis for delay-based congestion control algorithms. So, delaying a packet momentarily in order to permit another session to improve its operation has the effect of signaling a slightly lower capacity to the sender.",
      "ja": "それだけでなく、信号としてキューイングの影響を考えると便利です。データが受信されると、受信機は、肯定応答を送信するので、送信側で確認応答の到着は、ネットワークを介して達成することができるほぼ平均速度で送信者をペーシングします。これは、送信者は、ネットワークキューに格納されたデータの任意の大きな量を保持し、遅延ベースの輻輳制御アルゴリズムの基礎となっている場合も同様です。だから、その動作を改善するために、別のセッションを可能にするために一時的にパケットを遅らせることは、送信者にやや低い容量のシグナリング効果があります。"
    },
    {
      "indent": 0,
      "text": "3.1. Queuing with Tail Mark/Drop",
      "section_title": true,
      "ja": "3.1。テールマーク/ドロップでキューイング"
    },
    {
      "indent": 3,
      "text": "In the default case in which a FIFO queue is used with defensive tail drop only, the effect is to signal to the sender in two ways:",
      "ja": "FIFOキューが唯一の防御的なテールドロップで使用されるデフォルトの場合、効果は、2つの方法で送信者に知らせることです。"
    },
    {
      "indent": 3,
      "text": "o Ack clocking, which involves pacing the sender to send at approximately the rate it can deliver data to the receiver; and",
      "ja": "それは、受信機にデータを配信することができ、約速度を送信する送信者をペーシング伴うOのAckクロッキング、。そして"
    },
    {
      "indent": 3,
      "text": "o Defensive loss, which is when a sender sends faster than available capacity (such as by probing network capacity when fully utilizing that capacity) and overburdens a queue.",
      "ja": "送信者が（例えば、完全にその能力を利用したときにネットワーク容量をプロービングするなど）、利用可能な容量よりも速く送信し、キューをoverburdensときであるO守備損失、。"
    },
    {
      "indent": 0,
      "text": "3.2. Queuing with CoDel Mark/Drop",
      "section_title": true,
      "ja": "3.2。 CODELマーク/ドロップでキューイング"
    },
    {
      "indent": 3,
      "text": "In any case wherein a queuing algorithm is used along with CoDel [DELAY-AQM], the sequence of events is that a packet is time stamped, enqueued, dequeued, compared to a subsequent reading of the clock, and then acted on, whether by dropping it, marking and forwarding it, or simply forwarding it. This is to say that the only drop algorithm inherent in queuing is the defensive drop when the queue's resources are overrun. However, the intention of marking or dropping is to signal to the sender much earlier when a certain amount of delay has been observed. In a FIFO+CoDel, Virtual Clock+CoDel, or FlowQueue-Codel [FQ-CODEL] implementation, the queuing algorithm is completely separate from the AQM algorithm. Using them in series results in four signals to the sender:",
      "ja": "キューイングアルゴリズムはCODEL [DELAY-AQM]と共に使用されるいずれの場合にも、イベントのシーケンスは、パケットが時間を、スタンプさエンキュー、デキュー、クロックのその後の読み出しに比べ、その後によってかどうか、に作用されることですそれをマーキングおよび転送、それをドロップ、または単にそれを転送します。これは、キューイングに固有の唯一のドロップアルゴリズムはキューのリソースがオーバーランしている守備の低下であると言うことです。しかし、マーキングまたはドロップの意図は、遅延の一定量が観測されたはるかに早く、送信者に知らせることです。 FIFO + CODEL、仮想時計+ CODEL、またはFlowQueue-CODEL [FQ-CODEL】実装において、キューイングアルゴリズムは、AQMアルゴリズムから完全に分離されています。送信者への4つの信号における直列結果でそれらを使用します："
    },
    {
      "indent": 3,
      "text": "o Ack clocking, which involves pacing the sender to send at approximately the rate it can deliver data to the receiver through a queue;",
      "ja": "約それはキューを介して受信機にデータを配信することができますレートを送信する送信者をペーシング含まOのAckクロッキング、;"
    },
    {
      "indent": 3,
      "text": "o Lossless signaling that a certain delay threshold has been reached, if ECN [RFC3168] [RFC6679] is in use;",
      "ja": "Oロスレスは、ECN [RFC3168]、[RFC6679]が使用されている場合、特定の遅延閾値が到達されたことを知らせます。"
    },
    {
      "indent": 3,
      "text": "o Intentional signaling via loss that a certain delay threshold has been reached, if ECN is not in use; and",
      "ja": "ECNが使用されていない場合、特定の遅延閾値が到達されたこと損失介しO意図的なシグナリング。そして"
    },
    {
      "indent": 3,
      "text": "o Defensive loss, which is when a sender sends faster than available capacity (such as by probing network capacity when fully utilizing that capacity) and overburdens a queue.",
      "ja": "送信者が（例えば、完全にその能力を利用したときにネットワーク容量をプロービングするなど）、利用可能な容量よりも速く送信し、キューをoverburdensときであるO守備損失、。"
    },
    {
      "indent": 0,
      "text": "3.3. Queuing with RED or PIE Mark/Drop",
      "section_title": true,
      "ja": "3.3。 REDまたはPIEマーク/ドロップでキューイング"
    },
    {
      "indent": 3,
      "text": "In any case wherein a queuing algorithm is used along with PIE [AQM-PIE], Random Early Detection (RED) [RFC7567], or other such algorithms, the sequence of events is that a queue is inspected, a packet is dropped, marked, or left unchanged, enqueued, dequeued, compared to a subsequent reading of the clock, and then forwarded on.",
      "ja": "キューイングアルゴリズムはPIE [AQM-PIE]、ランダム早期検出（RED）[RFC7567]、または他のこのようなアルゴリズムと共に使用されるいずれの場合にも、イベントのシーケンスは、パケットは、ドロップマークされ、キューを検査することです、又は、そのままエンキュー、デキュー、クロックのその後の読み出しに比べ、その後に転送されます。"
    },
    {
      "indent": 3,
      "text": "This is to say that the AQM Mark/Drop Algorithm precedes enqueue; if it has not been effective and as a result the queue is out of resources anyway, the defensive drop algorithm steps in, and failing that, the queue operates in whatever way it does. Hence, in a FIFO+PIE, SFQ+PIE, or Virtual Clock+PIE implementation, the queuing algorithm is again completely separate from the AQM algorithm. Using them in series results in four signals to the sender:",
      "ja": "これは、AQMマーク/ドロップアルゴリズムは、エンキューの前ということです。それは効果的ではなかったし、結果としてキューが守備のドロップアルゴリズムのステップで、とにかくリソース不足であり、それを失敗した場合、キューはそれがないどのような方法で動作します。したがって、FIFO + PIE、SFQ + PIE、または仮想クロック+ PIE実装において、キューイングアルゴリズムが再びAQMアルゴリズムから完全に分離されています。送信者への4つの信号における直列結果でそれらを使用します："
    },
    {
      "indent": 3,
      "text": "o Ack clocking, which involves pacing the sender to send at approximately the rate it can deliver data to the receiver through a queue;",
      "ja": "約それはキューを介して受信機にデータを配信することができますレートを送信する送信者をペーシング含まOのAckクロッキング、;"
    },
    {
      "indent": 3,
      "text": "o Lossless signaling that a queue depth that corresponds to a certain delay threshold has been reached, if ECN is in use;",
      "ja": "Oロスレスは、ECNが使用中である場合に特定の遅延しきい値に対応するキューの深さは、到達したことを知らせます。"
    },
    {
      "indent": 3,
      "text": "o Intentional signaling via loss that a queue depth that corresponds to a certain delay threshold has been reached, if ECN is not in use; and",
      "ja": "ECNが使用されていない場合、特定の遅延しきい値に対応するキューの深さは、到達したこと損失介しO意図的なシグナリング。そして"
    },
    {
      "indent": 3,
      "text": "o Defensive loss, which is when a sender sends faster than available capacity (such as by probing network capacity when fully utilizing that capacity) and overburdens a queue.",
      "ja": "送信者が（例えば、完全にその能力を利用したときにネットワーク容量をプロービングするなど）、利用可能な容量よりも速く送信し、キューをoverburdensときであるO守備損失、。"
    },
    {
      "indent": 0,
      "text": "4. Conclusion",
      "section_title": true,
      "ja": "4.おわりに"
    },
    {
      "indent": 3,
      "text": "To summarize, in Section 2, implementation approaches for several classes of queuing algorithms were explored. Queuing algorithms such as SFQ, Virtual Clock, and FlowQueue-Codel [FQ-CODEL] have value in the network in that they delay packets to enforce a rate upper bound or to permit competing flows to compete more effectively. ECN marking and loss are also useful signals if used in a manner that enhances TCP / Steam Control Transmission Protocol (SCTP) operation or restrains unmanaged UDP data flows.",
      "ja": "第2節では、要約すると、キューイングアルゴリズムのいくつかのクラスの実装手法が模索されました。彼らは上限レートを強制したり、より効果的に競争するために、競合するフローを許可するパケットを遅らせることで、ネットワーク内の値を持つようにSFQ、仮想クロック、およびFlowQueue-CODEL [FQ-CODEL]などのアルゴリズムをキューイング。 TCP /スチーム制御伝送プロトコル（SCTP）動作を強化又は管理されていないUDPデータフロー抑制する方法で使用される場合ECNマーキング及び損失も有用信号です。"
    },
    {
      "indent": 3,
      "text": "Conceptually, queuing algorithms and mark/drop algorithms operate in series (as discussed in Section 3), not as a single algorithm. The observed effects differ: defensive loss protects the intermediate system and provides a signal, AQM mark/drop works to reduce mean latency, and the scheduling of flows works to modify flow interleave and acknowledgement pacing. Certain features like flow isolation are provided by fair-queuing-related designs but are not the effect of the mark/drop algorithm.",
      "ja": "概念的には、キューイングアルゴリズムおよびマーク/ドロップ・アルゴリズムではなく、単一のアルゴリズムとして、（第3節で説明したように）直列で動作します。観察された効果は、異なる：守備損失が中間システムを保護し、信号を提供し、AQMマーク/ドロップは、平均待ち時間を短縮するために動作し、フローのスケジューリングは、フローインターリーブ及び肯定応答ペーシングを変更するために働きます。流れ分離などの一部の機能は、公正・キューイング関連のデザインによって提供さが、マーク/ドロップアルゴリズムの効果はありませんされています。"
    },
    {
      "indent": 3,
      "text": "There is value in implementing and coupling the operation of both queuing algorithms and queue management algorithms, and there is definitely interesting research in this area, but specifications, measurements, and comparisons should decouple the different algorithms and their contributions to system behavior.",
      "ja": "値は、キューイングアルゴリズムとキュー管理アルゴリズムの両方の動作を実現し、カップリングであり、この分野で興味深い研究は間違いなくありますが、仕様、測定、および比較は異なるアルゴリズムとシステム動作への貢献を切り離す必要があります。"
    },
    {
      "indent": 0,
      "text": "5. Security Considerations",
      "section_title": true,
      "ja": "5.セキュリティについての考慮事項"
    },
    {
      "indent": 3,
      "text": "This memo adds no new security issues; it observes implementation strategies for Diffserv implementation.",
      "ja": "このメモには、新たなセキュリティ問題を追加しません。それはDiffservの実装のための実装戦略を観察します。"
    },
    {
      "indent": 0,
      "text": "6. References",
      "section_title": true,
      "ja": "6.参照"
    },
    {
      "indent": 0,
      "text": "6.1. Normative References",
      "section_title": true,
      "ja": "6.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC2475] Blake, S., Black, D., Carlson, M., Davies, E., Wang, Z., and W. Weiss, \"An Architecture for Differentiated Services\", RFC 2475, DOI 10.17487/RFC2475, December 1998, <http://www.rfc-editor.org/info/rfc2475>.",
      "ja": "[RFC2475]ブレイク、S.、ブラ​​ック、D.、カールソン、M.、デイヴィス、E.、王、Z.、およびW.ワイス、 \"差別化サービスのためのアーキテクチャ\"、RFC 2475、DOI 10.17487 / RFC2475、12月1998年、<http://www.rfc-editor.org/info/rfc2475>。"
    },
    {
      "indent": 0,
      "text": "6.2. Informative References",
      "section_title": true,
      "ja": "6.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[AQM-PIE] Pan, R., Natarajan, P., and F. Baker, \"PIE: A Lightweight Control Scheme To Address the Bufferbloat Problem\", Work in Progress, draft-ietf-aqm-pie-06, April 2016.",
      "ja": "[AQM-PIE]パン、R.、Natarajan、P.、およびF.ベイカー、 \"PIE：軽量制御方式Bufferbloat問題に対処するために\"、進捗状況、ドラフト-IETF-AQM-パイ-06、2016年4月での作業。"
    },
    {
      "indent": 3,
      "text": "[CalendarQueue] Brown, R., \"Calendar queues: a fast 0(1) priority queue implementation for the simulation event set problem\", Communications of the ACM Volume 21, Issue 10, pp. 1220-1227, DOI 10.1145/63039.63045, October 1988, <http://dl.acm.org/citation.cfm?id=63045>.",
      "ja": "【CalendarQueue]ブラウン、R.、 \"カレンダーキュー：シミュレーションイベント設定問題の高速0（1）優先度キューの実装\"。ACMボリューム21の、通信、号10頁1220年から1227年、DOI 10.1145 / 63039.63045、 1988年10月、<http://dl.acm.org/citation.cfm?id=63045>。"
    },
    {
      "indent": 3,
      "text": "[Deadline] Kruk, L., Lohoczky, J., Ramanan, K., and S. Shreve, \"Heavy Traffic Analysis For EDF Queues With Reneging\", The Annals of Applied Probability Volume 21, Issue No. 2, pp. 484-545, DOI 10.1214/10-AAP681, 2011, <http://www.math.cmu.edu/users/shreve/Reneging.pdf>.",
      "ja": "[締切] Kruk、L.、Lohoczky、J.、Ramanan、K.、およびS. Shreveの、 \"RenegingとEDFキューに大量のトラフィック分析\"、史料応用の確率21巻、発行番号2、頁484 -545、DOI 10.1214 / 10-AAP681、2011年、<http://www.math.cmu.edu/users/shreve/Reneging.pdf>。"
    },
    {
      "indent": 3,
      "text": "[DELAY-AQM] Nichols, K., Jacobson, V., McGregor, A., and J. Iyengar, \"Controlled Delay Active Queue Management\", Work in Progress, draft-ietf-aqm-codel-03, March 2016.",
      "ja": "[DELAY-AQM]ニコルズ、K.、ヤコブソン、V.、マクレガー、A.、およびJ.アイアンガー、 \"制御された遅延アクティブキュー管理\"、進捗状況、ドラフト-IETF-AQM-CODEL-03、2016年3月での作業。"
    },
    {
      "indent": 3,
      "text": "[DRR] Shreedhar, M. and G. Varghese, \"Efficient fair queuing using deficit round-robin\", IEEE/ACM Transactions on Networking Volume 4, Issue 3, pp. 375-385, DOI 10.1109/90.502236, June 1996, <http://ieeexplore.ieee.org/stamp/ stamp.jsp?tp=&arnumber=502236>.",
      "ja": "【DRR] Shreedhar、M.およびG. Varghese、 \"効率的な均等化キューイング不足ラウンドロビンを使用して\"、IEEEネットワーク4巻、3号、頁375から385に/ ACMトランザクション、DOI 10.1109 / 90.502236、1996年6月、< http://ieeexplore.ieee.org/stamp/ stamp.jsp？TP =＆arnumber = 502236>。"
    },
    {
      "indent": 3,
      "text": "[FQ-CODEL] Hoeiland-Joergensen, T., McKenney, P., Taht, D., Gettys, J., and E. Dumazet, \"The FlowQueue-CoDel Packet Scheduler and Active Queue Management Algorithm\", Work in Progress, draft-ietf-aqm-fq-codel-06, March 2016.",
      "ja": "[FQ-CODEL] Hoeiland-Joergensen、T.、McKenney、P.、Taht、D.、ゲティス、J.、およびE. Dumazet、 \"FlowQueue-CODELパケットスケジューラ及びアクティブキュー管理アルゴリズム\"、進行中で働いて、ドラフト-IETF-AQM-FQ-CODEL-06、2016年3月。"
    },
    {
      "indent": 3,
      "text": "[GPS] Demers, A., University of California, Berkeley, and Xerox PARC, \"Analysis and Simulation of a Fair Queueing Algorithm\", ACM SIGCOMM Computer Communication Review, Volume 19, Issue 4, pp. 1-12, DOI 10.1145/75247.75248, September 1989, <http://blizzard.cs.uwaterloo.ca/keshav/home/Papers/ data/89/fq.pdf>.",
      "ja": "[GPS]デマーズ、A.、カリフォルニア大学バークレー校、およびゼロックスPARC、 \"分析と公平キューイングアルゴリズムのシミュレーション\" の大学、ACM SIGCOMMコンピュータコミュニケーションレビュー、第19巻、第4号、頁1-12、DOI 10.1145 / 75247.75248、1989年9月、<http://blizzard.cs.uwaterloo.ca/keshav/home/Papers/データ/ 89 / fq.pdf>。"
    },
    {
      "indent": 3,
      "text": "[NoFair] Briscoe, B., \"Flow rate fairness: dismantling a religion\", ACM SIGCOMM Computer Communication Review, Volume 37, Issue 2, pp. 63-74, DOI 10.1145/1232919.1232926, April 2007, <http://dl.acm.org/citation.cfm?id=1232926>.",
      "ja": "[NoFair]ブリスコー、B.、 \"流量公平性：宗教を解体\"、ACM SIGCOMMコンピュータコミュニケーションレビュー、37巻、2号、頁63-74、DOI 10.1145 / 1232919.1232926、2007年4月、<のhttp：// DL .acm.org / citation.cfm？ID = 1232926>。"
    },
    {
      "indent": 3,
      "text": "[RFC970] Nagle, J., \"On Packet Switches With Infinite Storage\", RFC 970, DOI 10.17487/RFC0970, December 1985, <http://www.rfc-editor.org/info/rfc970>.",
      "ja": "[RFC970]ネーグル、J.、 \"無限のストレージを持つパケットスイッチオン\"、RFC 970、DOI 10.17487 / RFC0970、1985年12月、<http://www.rfc-editor.org/info/rfc970>。"
    },
    {
      "indent": 3,
      "text": "[RFC2990] Huston, G., \"Next Steps for the IP QoS Architecture\", RFC 2990, DOI 10.17487/RFC2990, November 2000, <http://www.rfc-editor.org/info/rfc2990>.",
      "ja": "[RFC2990]ヒューストン、G.、 \"IP QoSのアーキテクチャーのための次のステップ\"、RFC 2990、DOI 10.17487 / RFC2990、2000年11月、<http://www.rfc-editor.org/info/rfc2990>。"
    },
    {
      "indent": 3,
      "text": "[RFC3168] Ramakrishnan, K., Floyd, S., and D. Black, \"The Addition of Explicit Congestion Notification (ECN) to IP\", RFC 3168, DOI 10.17487/RFC3168, September 2001, <http://www.rfc-editor.org/info/rfc3168>.",
      "ja": "\"IPへの明示的輻輳通知の追加（ECN）\" [RFC3168]ラマクリシュナン、K.、フロイド、S.、およびD.ブラック、RFC 3168、DOI 10.17487 / RFC3168、2001年9月、<のhttp：// WWW。 rfc-editor.org/info/rfc3168>。"
    },
    {
      "indent": 3,
      "text": "[RFC3390] Allman, M., Floyd, S., and C. Partridge, \"Increasing TCP's Initial Window\", RFC 3390, DOI 10.17487/RFC3390, October 2002, <http://www.rfc-editor.org/info/rfc3390>.",
      "ja": "[RFC3390]オールマン、M.、フロイド、S.、およびC.ヤマウズラ、 \"TCPの初期ウィンドウを増やす\"、RFC 3390、DOI 10.17487 / RFC3390、2002年10月、<http://www.rfc-editor.org/info / rfc3390>。"
    },
    {
      "indent": 3,
      "text": "[RFC5690] Floyd, S., Arcia, A., Ros, D., and J. Iyengar, \"Adding Acknowledgement Congestion Control to TCP\", RFC 5690, DOI 10.17487/RFC5690, February 2010, <http://www.rfc-editor.org/info/rfc5690>.",
      "ja": "[RFC5690]フロイド、S.、Arcia、A.、ロス、D.、およびJ.アイアンガー、 \"TCPに対する確認応答輻輳制御を追加\"、RFC 5690、DOI 10.17487 / RFC5690、2010年2月、<HTTP：// WWW。 rfc-editor.org/info/rfc5690>。"
    },
    {
      "indent": 3,
      "text": "[RFC6057] Bastian, C., Klieber, T., Livingood, J., Mills, J., and R. Woundy, \"Comcast's Protocol-Agnostic Congestion Management System\", RFC 6057, DOI 10.17487/RFC6057, December 2010, <http://www.rfc-editor.org/info/rfc6057>.",
      "ja": "[RFC6057]バスティアン、C.、Klieber、T.、Livingood、J.、ミルズ、J.、およびR. Woundy、 \"Comcastのプロトコルに依存しない輻輳管理システム\"、RFC 6057、DOI 10.17487 / RFC6057、2010年12月、< http://www.rfc-editor.org/info/rfc6057>。"
    },
    {
      "indent": 3,
      "text": "[RFC6679] Westerlund, M., Johansson, I., Perkins, C., O'Hanlon, P., and K. Carlberg, \"Explicit Congestion Notification (ECN) for RTP over UDP\", RFC 6679, DOI 10.17487/RFC6679, August 2012, <http://www.rfc-editor.org/info/rfc6679>.",
      "ja": "[RFC6679]ウェスター、M.、ヨハンソン、I.、パーキンス、C.、オハンロン、P.、およびK.カールバーグ、 \"明示的輻輳通知UDP上のRTPのための（ECN）\"、RFC 6679、DOI 10.17487 / RFC6679 、2012年8月、<http://www.rfc-editor.org/info/rfc6679>。"
    },
    {
      "indent": 3,
      "text": "[RFC6928] Chu, J., Dukkipati, N., Cheng, Y., and M. Mathis, \"Increasing TCP's Initial Window\", RFC 6928, DOI 10.17487/RFC6928, April 2013, <http://www.rfc-editor.org/info/rfc6928>.",
      "ja": "[RFC6928]チュー、J.、Dukkipati、N.、チェン、Y.、およびM.マシス、 \"TCPの初期ウィンドウを増やす\"、RFC 6928、DOI 10.17487 / RFC6928、2013年4月、<のhttp：//www.rfc- editor.org/info/rfc6928>。"
    },
    {
      "indent": 3,
      "text": "[RFC7141] Briscoe, B. and J. Manner, \"Byte and Packet Congestion Notification\", BCP 41, RFC 7141, DOI 10.17487/RFC7141, February 2014, <http://www.rfc-editor.org/info/rfc7141>.",
      "ja": "[RFC7141]ブリスコー、B.及びJ.マナー、 \"バイトおよびパケット輻輳通知\"、BCP 41、RFC 7141、DOI 10.17487 / RFC7141、2014年2月、<http://www.rfc-editor.org/info/rfc7141 >。"
    },
    {
      "indent": 3,
      "text": "[RFC7567] Baker, F., Ed. and G. Fairhurst, Ed., \"IETF Recommendations Regarding Active Queue Management\", BCP 197, RFC 7567, DOI 10.17487/RFC7567, July 2015, <http://www.rfc-editor.org/info/rfc7567>.",
      "ja": "[RFC7567]ベーカー、F.、エド。そして、G. Fairhurst、エド。、 \"アクティブキュー管理に関するIETF勧告\"、BCP 197、RFC 7567、DOI 10.17487 / RFC7567、2015年7月、<http://www.rfc-editor.org/info/rfc7567>。"
    },
    {
      "indent": 3,
      "text": "[SFQ] Mckenney, P., \"Stochastic Fairness Queuing\", Proceedings of IEEE INFOCOM '90, Volume 2, pp. 733-740, DOI 10.1109/INFCOM.1990.91316, June 1990, <http://www2.rdrop.com/~paulmck/scalability/paper/ sfq.2002.06.04.pdf>.",
      "ja": "[SFQ] Mckenney、P.、 \"確率的公正キューイング\"、IEEE INFOCOM '90、第2巻、頁733から740までの議事録、DOI 10.1109 / INFCOM.1990.91316、1990年6月、<http://www2.rdrop.com /〜paulmck /拡張性/紙/ sfq.2002.06.04.pdf>。"
    },
    {
      "indent": 3,
      "text": "[VirtualClock] Zhang, L., \"VirtualClock: A New Traffic Control Algorithm for Packet Switching Networks\", Proceedings of the ACM Symposium on Communications Architectures and Protocols, Volume 20, DOI 10.1145/99508.99525, September 1990, <http://dl.acm.org/citation.cfm?id=99508.99525>.",
      "ja": "[VirtualClock]チャン、L.、 \"VirtualClock：パケット交換ネットワークのための新しいトラフィック制御アルゴリズム\"、通信アーキテクチャとプロトコル、20巻のACMシンポジウム、DOI 10.1145 / 99508.99525、1990年9月、<のhttp：// DL .acm.org / citation.cfm？ID = 99508.99525>。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "This note grew out of, and is in response to, mailing list discussions in AQM, in which some have pushed an algorithm to compare to AQM marking and dropping algorithms, but which includes flow queuing.",
      "ja": "このノートはから生まれた、といくつかのアルゴリズムをマーキングし、ドロップAQMに比較するためのアルゴリズムを押しますが、フローイングが含まれているにAQMにおけるメーリングリストでの議論、に対応しています。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Fred Baker Cisco Systems Santa Barbara, California 93117 United States",
      "ja": "フレッドベイカーシスコシステムズサンタバーバラ、カリフォルニア93117米国"
    },
    {
      "indent": 3,
      "text": "Email: fred@cisco.com",
      "ja": "メール：fred@cisco.com"
    },
    {
      "indent": 3,
      "text": "Rong Pan Cisco Systems Milpitas, California 95035 United States",
      "ja": "栄パンシスコシステムズミルピタス、カリフォルニア95035米国"
    },
    {
      "indent": 3,
      "text": "Email: ropan@cisco.com",
      "ja": "メール：ropan@cisco.com"
    }
  ]
}