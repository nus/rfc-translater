{
  "title": {
    "text": "RFC 7951 - JSON Encoding of Data Modeled with YANG",
    "ja": "RFC 7951 - データのJSONエンコーディングをYANGでモデル化"
  },
  "number": 7951,
  "created_at": "2019-11-02 15:22:05.053722+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                         L. Lhotka\nRequest for Comments: 7951                                        CZ.NIC\nCategory: Standards Track                                    August 2016\nISSN: 2070-1721",
      "raw": true
    },
    {
      "indent": 16,
      "text": "JSON Encoding of Data Modeled with YANG",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document defines encoding rules for representing configuration data, state data, parameters of Remote Procedure Call (RPC) operations or actions, and notifications defined using YANG as JavaScript Object Notation (JSON) text.",
      "ja": "この文書は、構成データ、状態データ、リモートプロシージャコール（RPC）操作またはアクションのパラメータを表すための符号化規則を定義し、通知は、JavaScript Object Notation（JSON）テキストとしてYANGを使用して定義されました。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 7841のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7951.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7951で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2016 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2016 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3\n2.  Terminology and Notation  . . . . . . . . . . . . . . . . . .   3\n3.  Properties of the JSON Encoding . . . . . . . . . . . . . . .   4\n4.  Names and Namespaces  . . . . . . . . . . . . . . . . . . . .   5\n5.  Encoding of YANG Data Node Instances  . . . . . . . . . . . .   7\n  5.1.  The \"leaf\" Data Node  . . . . . . . . . . . . . . . . . .   7\n  5.2.  The \"container\" Data Node . . . . . . . . . . . . . . . .   8\n  5.3.  The \"leaf-list\" Data Node . . . . . . . . . . . . . . . .   8\n  5.4.  The \"list\" Data Node  . . . . . . . . . . . . . . . . . .   9\n  5.5.  The \"anydata\" Data Node . . . . . . . . . . . . . . . . .   9\n  5.6.  The \"anyxml\" Data Node  . . . . . . . . . . . . . . . . .  10\n  5.7.  Metadata Objects  . . . . . . . . . . . . . . . . . . . .  11\n6.  Representing YANG Data Types in JSON Values . . . . . . . . .  11\n  6.1.  Numeric Types . . . . . . . . . . . . . . . . . . . . . .  11\n  6.2.  The \"string\" Type . . . . . . . . . . . . . . . . . . . .  11\n  6.3.  The \"boolean\" Type  . . . . . . . . . . . . . . . . . . .  11\n  6.4.  The \"enumeration\" Type  . . . . . . . . . . . . . . . . .  12\n  6.5.  The \"bits\" Type . . . . . . . . . . . . . . . . . . . . .  12\n  6.6.  The \"binary\" Type . . . . . . . . . . . . . . . . . . . .  12\n  6.7.  The \"leafref\" Type  . . . . . . . . . . . . . . . . . . .  12\n  6.8.  The \"identityref\" Type  . . . . . . . . . . . . . . . . .  12\n  6.9.  The \"empty\" Type  . . . . . . . . . . . . . . . . . . . .  13\n  6.10. The \"union\" Type  . . . . . . . . . . . . . . . . . . . .  14\n  6.11. The \"instance-identifier\" Type  . . . . . . . . . . . . .  15\n7.  I-JSON Compliance . . . . . . . . . . . . . . . . . . . . . .  15\n8.  Security Considerations . . . . . . . . . . . . . . . . . . .  16\n9.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  16\n  9.1.  Normative References  . . . . . . . . . . . . . . . . . .  16\n  9.2.  Informative References  . . . . . . . . . . . . . . . . .  17\nAppendix A.  A Complete Example . . . . . . . . . . . . . . . . .  18\nAcknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  20\nAuthor's Address  . . . . . . . . . . . . . . . . . . . . . . . .  20",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "The Network Configuration Protocol (NETCONF) [RFC6241] uses XML [XML] for encoding data in its Content Layer. Other management protocols might want to use other encodings while still benefiting from using YANG [RFC7950] as the data modeling language.",
      "ja": "ネットワーク設定プロトコル（NETCONF）[RFC6241]はそのコンテンツレイヤにおける符号化データのためのXML [XML]を使用しています。他の管理プロトコルは、まだデータモデリング言語としてYANG [RFC7950]を使用して恩恵を受けながら、他のエンコーディングを使用する場合があります。"
    },
    {
      "indent": 3,
      "text": "For example, the RESTCONF protocol [RESTCONF] supports two encodings: XML (media type \"application/yang.data+xml\") and JavaScript Object Notation (JSON) (media type \"application/yang.data+json\").",
      "ja": "XML（メディアタイプ \"アプリケーション/ yang.data + XML\"）およびJavaScriptオブジェクト表記（JSON）（メディアタイプ \"アプリケーション/ yang.data + JSON\"）：例えば、RESTCONFプロトコルが[RESTCONF 2つのエンコーディングをサポートしています。"
    },
    {
      "indent": 3,
      "text": "The specification of the YANG 1.1 data modeling language [RFC7950] defines only XML encoding of data trees, i.e., configuration data, state data, input/output parameters of Remote Procedure Call (RPC) operations or actions, and notifications. The aim of this document is to define rules for encoding the same data as JSON text [RFC7159].",
      "ja": "YANG 1.1データモデリング言語[RFC7950]の仕様は、データツリーの唯一のXMLエンコーディング、リモートプロシージャコール（RPC）操作またはアクション、および通知の、すなわち、構成データ、状態データ、入力/出力パラメータを定義します。この文書の目的は、JSONテキスト[RFC7159]と同じデータを符号化するためのルールを定義することです。"
    },
    {
      "indent": 0,
      "text": "2. Terminology and Notation",
      "section_title": true,
      "ja": "2.用語と記法"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はあります[RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 3,
      "text": "The following terms are defined in [RFC7950]:",
      "ja": "以下の用語は[RFC7950]で定義されています。"
    },
    {
      "indent": 3,
      "text": "o action",
      "ja": "Oアクション"
    },
    {
      "indent": 3,
      "text": "o anydata",
      "ja": "O ANYDATA"
    },
    {
      "indent": 3,
      "text": "o anyxml",
      "ja": "AnyXMLでO"
    },
    {
      "indent": 3,
      "text": "o augment",
      "ja": "または増加"
    },
    {
      "indent": 3,
      "text": "o container",
      "ja": "Oコンテナ"
    },
    {
      "indent": 3,
      "text": "o data node",
      "ja": "お だた ので"
    },
    {
      "indent": 3,
      "text": "o data tree",
      "ja": "Oデータツリー"
    },
    {
      "indent": 3,
      "text": "o identity",
      "ja": "Oアイデンティティ"
    },
    {
      "indent": 3,
      "text": "o instance identifier",
      "ja": "O体を識別"
    },
    {
      "indent": 3,
      "text": "o leaf",
      "ja": "葉"
    },
    {
      "indent": 3,
      "text": "o leaf-list",
      "ja": "リーフリスト"
    },
    {
      "indent": 3,
      "text": "o list o module",
      "ja": "OリストのOモジュール"
    },
    {
      "indent": 3,
      "text": "o RPC operation",
      "ja": "OのRPC操作"
    },
    {
      "indent": 3,
      "text": "o submodule",
      "ja": "Oサブモジュール"
    },
    {
      "indent": 3,
      "text": "The following terms are defined in [RFC6241]:",
      "ja": "以下の用語は[RFC6241]で定義されています。"
    },
    {
      "indent": 3,
      "text": "o configuration data",
      "ja": "O構成データ"
    },
    {
      "indent": 3,
      "text": "o notification",
      "ja": "O通知"
    },
    {
      "indent": 3,
      "text": "o state data",
      "ja": "O状態データ"
    },
    {
      "indent": 0,
      "text": "3. Properties of the JSON Encoding",
      "section_title": true,
      "ja": "JSONエンコーディングの3. [プロパティ"
    },
    {
      "indent": 3,
      "text": "This document defines JSON encoding for YANG data trees and their subtrees. It is always assumed that the top-level structure in JSON-encoded data is an object.",
      "ja": "この文書では、YANGデータツリーとそのサブツリーのJSONエンコーディングを定義します。常にJSONエンコードされたデータの最上位構造が対象とします。"
    },
    {
      "indent": 3,
      "text": "Instances of YANG data nodes (leafs, containers, leaf-lists, lists, anydata nodes, and anyxml nodes) are encoded as members of a JSON object, i.e., name/value pairs. Section 4 defines how the name part is formed, and the following sections deal with the value part. The encoding rules are identical for all types of data trees, i.e., configuration data, state data, parameters of RPC operations, actions, and notifications.",
      "ja": "YANGデータノード（リーフ、コンテナ、リーフ・リスト、リスト、ANYDATAノード、及びAnyXMLでノード）のインスタンスは、JSONオブジェクトのメンバー、すなわち、名前/値ペアとして符号化されます。セクション4は、名前部分が形成される方法を定義し、次のセクションでは、値の一部に対処します。符号化規則は、データ・ツリーのすべてのタイプ、すなわち、構成データ、状態データ、RPC操作、アクション、および通知のパラメータについて同一です。"
    },
    {
      "indent": 3,
      "text": "With the exception of \"anydata\" encoding (Section 5.5), all rules in this document are also applicable to YANG 1.0 [RFC6020].",
      "ja": "「ANYDATA」エンコーディング（5.5項）を除いて、この文書に記載されているすべてのルールもYANG 1.0 [RFC6020]に適用されます。"
    },
    {
      "indent": 3,
      "text": "Unlike XML element content, JSON values carry partial type information (number, string, boolean). The JSON encoding is defined so that this information is never in conflict with the data type of the corresponding YANG leaf or leaf-list.",
      "ja": "XML要素のコンテンツとは異なり、JSON値は、部分的なタイプの情報（数、文字列、ブール値）を運びます。この情報は、対応するYANG葉または葉リストのデータ・タイプと競合しないしないようにJSONエンコードが定義されています。"
    },
    {
      "indent": 3,
      "text": "With the exception of anyxml and schema-less anydata nodes, it is possible to map a JSON-encoded data tree to XML encoding as defined in [RFC7950], and vice versa. However, such conversions require the YANG data model to be available.",
      "ja": "AnyXMLでスキーマレスANYDATAノードを除いて、[RFC7950]で定義されるようにXMLエンコードにJSONエンコードされたデータ・ツリーをマッピングすることができ、その逆。しかし、このような変換が利用できるようにYANGデータモデルを必要とします。"
    },
    {
      "indent": 3,
      "text": "In order to achieve maximum interoperability while allowing implementations to use a variety of existing JSON parsers, the JSON encoding rules follow, as much as possible, the constraints of the I-JSON (Internet JSON) restricted profile [RFC7493]. Section 7 discusses I-JSON conformance in more detail.",
      "ja": "実装は、既存のJSONパーサーの様々な使用を可能にしながら、最大の相互運用性を達成するために、JSONエンコーディング規則は、可能な限り、I-JSON（インターネットJSON）制限プロファイル[RFC7493]の制約に従います。第7節は、より詳細にI-JSONの適合性について説明します。"
    },
    {
      "indent": 0,
      "text": "4. Names and Namespaces",
      "section_title": true,
      "ja": "4.名前と名前空間"
    },
    {
      "indent": 3,
      "text": "A JSON object member name MUST be in one of the following forms:",
      "ja": "JSONオブジェクトのメンバー名は、次のいずれかの形式でなければなりません。"
    },
    {
      "indent": 3,
      "text": "o simple - identical to the identifier of the corresponding YANG data node.",
      "ja": "単純O  - 対応YANGデータノードの識別子と同じ。"
    },
    {
      "indent": 3,
      "text": "o namespace-qualified - the data node identifier is prefixed with the name of the module in which the data node is defined, separated from the data node identifier by the colon character (\":\").",
      "ja": "O名前空間修飾 - データ・ノード識別子はコロン（「：」）によってデータノード識別子から分離され、データ・ノードが定義されているモジュールの名前が付いています。"
    },
    {
      "indent": 3,
      "text": "The name of a module determines the namespace of all data node names defined in that module. If a data node is defined in a submodule, then the namespace-qualified member name uses the name of the main module to which the submodule belongs.",
      "ja": "モジュールの名前は、そのモジュールで定義されているすべてのデータノード名の名前空間を決定します。データノードは、サブモジュールで定義されている場合、名前空間修飾メンバー名はサブモジュールが属するメインモジュールの名前を使用します。"
    },
    {
      "indent": 3,
      "text": "ABNF syntax [RFC5234] of a member name is shown in Figure 1, where the production for \"identifier\" is defined in Section 14 of [RFC7950].",
      "ja": "メンバ名のABNF構文[RFC5234]は、「識別子」の生産は[RFC7950]のセクション14で定義され、図1に示されています。"
    },
    {
      "indent": 11,
      "text": "member-name = [identifier \":\"] identifier",
      "ja": "メンバ名= [識別子「：」]識別子"
    },
    {
      "indent": 13,
      "text": "Figure 1: ABNF Production for a JSON Member Name",
      "ja": "図1：JSONメンバーの名前のためのABNF生産"
    },
    {
      "indent": 3,
      "text": "A namespace-qualified member name MUST be used for all members of a top-level JSON object and then also whenever the namespaces of the data node and its parent node are different. In all other cases, the simple form of the member name MUST be used.",
      "ja": "名前空間修飾メンバー名と、データノードとその親ノードの名前空間が異なるにもいつでもトップレベルのJSONオブジェクトのすべてのメンバーのために使用しなければなりません。他のすべての例では、メンバー名の単純な形式を使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "For example, consider the following YANG module:",
      "ja": "たとえば、次のようYANGモジュールを考慮してください。"
    },
    {
      "indent": 3,
      "text": "module example-foomod {",
      "ja": "モジュール例-foomod {"
    },
    {
      "indent": 5,
      "text": "namespace \"http://example.com/foomod\";",
      "ja": "名前空間「http://example.com/foomod」。"
    },
    {
      "indent": 5,
      "text": "prefix \"foomod\";",
      "ja": "接頭辞「foomod」。"
    },
    {
      "indent": 3,
      "text": " container top { leaf foo { type uint8; } } }",
      "ja": "容器上面{葉FOO {型UINT8。 }}}"
    },
    {
      "indent": 3,
      "text": "If the data model consists only of this module, then the following is valid JSON-encoded configuration data:",
      "ja": "データモデルはこのモジュールだけで構成されている場合、次は有効なJSONエンコードされた構成データは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "{\n  \"example-foomod:top\": {\n    \"foo\": 54\n  }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Note that the member of the top-level object uses the namespace-qualified name but the \"foo\" leaf doesn't because it is defined in the same module as its parent container \"top\".",
      "ja": "トップレベルのオブジェクトのメンバーは、名前空間修飾名を使用していますが、「foo」という葉は、それがその親コン​​テナ「トップ」と同じモジュールで定義されていないので注意してください。"
    },
    {
      "indent": 3,
      "text": "Now, assume that the container \"top\" is augmented from another module, \"example-barmod\":",
      "ja": "さて、コンテナ「トップ」は、別のモジュール、「例-barmod」から強化されていることを前提としています。"
    },
    {
      "indent": 3,
      "text": "module example-barmod {",
      "ja": "モジュール例-barmod {"
    },
    {
      "indent": 5,
      "text": "namespace \"http://example.com/barmod\";",
      "ja": "名前空間「http://example.com/barmod」。"
    },
    {
      "indent": 5,
      "text": "prefix \"barmod\";",
      "ja": "接頭辞「barmod」。"
    },
    {
      "indent": 5,
      "text": "import example-foomod { prefix \"foomod\"; }",
      "ja": "インポート例-foomod {接頭辞「foomod」。 }"
    },
    {
      "indent": 3,
      "text": " augment \"/foomod:top\" { leaf bar { type boolean; } } }",
      "ja": "{葉のバー{boolean型;： \"トップ/ foomod\" を強化}}}"
    },
    {
      "indent": 3,
      "text": "Valid JSON-encoded configuration data containing both leafs may then look like this:",
      "ja": "両方の葉を含む有効なJSONエンコードされたコンフィギュレーション・データは、次のようになります。"
    },
    {
      "indent": 3,
      "text": "{\n  \"example-foomod:top\": {\n    \"foo\": 54,\n    \"example-barmod:bar\": true\n  }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The name of the \"bar\" leaf is prefixed with the namespace identifier because its parent is defined in a different module.",
      "ja": "その親が別のモジュールで定義されているため、「バー」の葉の名前は、名前空間識別子が付いています。"
    },
    {
      "indent": 3,
      "text": "Explicit namespace identifiers are sometimes needed when encoding values of the \"identityref\" and \"instance-identifier\" types. The same form of namespace-qualified name as defined above is then used. See Sections 6.8 and 6.11 for details.",
      "ja": "「identityref」および「インスタンス識別子」タイプの値を符号化する際に、明示的な名前空間識別子が時々必要です。上記で定義された名前空間修飾名の同じ形態を次に使用されます。セクションに詳細については、6.8と6.11を参照してください。"
    },
    {
      "indent": 0,
      "text": "5. Encoding of YANG Data Node Instances",
      "section_title": true,
      "ja": "YANGデータノードインスタンスの5エンコーディング"
    },
    {
      "indent": 3,
      "text": "Every data node instance is encoded as a name/value pair where the name is formed from the data node identifier using the rules of Section 4. The value depends on the category of the data node, as explained in the following subsections.",
      "ja": "すべてのデータ・ノード・インスタンスは、以下のサブセクションで説明したように名前は、値がデータノードのカテゴリに依存セクション4の規則を使用してデータノード識別子から形成されている名前/値ペアとして符号化されます。"
    },
    {
      "indent": 3,
      "text": "Character encoding MUST be UTF-8.",
      "ja": "文字エンコーディングはUTF-8でなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.1. The \"leaf\" Data Node",
      "section_title": true,
      "ja": "5.1。 「リーフ」データノード"
    },
    {
      "indent": 3,
      "text": "A leaf instance is encoded as a name/value pair where the value can be a string, number, literal \"true\" or \"false\", or the special array \"[null]\", depending on the type of the leaf (see Section 6 for the type encoding rules).",
      "ja": "葉のインスタンスが値が葉の種類に応じて、文字列、数値、リテラル「true」または「false」、または特別なアレイ「[NULL]」とすることができる名前/値ペアとして符号化される（節を参照型の符号化規則6）。"
    },
    {
      "indent": 3,
      "text": "Example: For the leaf node definition",
      "ja": "例：リーフノード定義について"
    },
    {
      "indent": 3,
      "text": "leaf foo { type uint8; }",
      "ja": "リーフFOO {型UINT8。 }"
    },
    {
      "indent": 3,
      "text": "the following is a valid JSON-encoded instance:",
      "ja": "以下は、有効なJSONエンコードされたインスタンスです。"
    },
    {
      "indent": 3,
      "text": "\"foo\": 123",
      "ja": "\"foo\" という：123"
    },
    {
      "indent": 0,
      "text": "5.2. The \"container\" Data Node",
      "section_title": true,
      "ja": "5.2。 「コンテナ」データノード"
    },
    {
      "indent": 3,
      "text": "A container instance is encoded as a name/object pair. The container's child data nodes are encoded as members of the object.",
      "ja": "コンテナインスタンスは、名前/オブジェクト対として符号化されます。コンテナの子のデータノードは、オブジェクトのメンバーとしてエンコードされています。"
    },
    {
      "indent": 3,
      "text": "Example: For the container definition",
      "ja": "例：コンテナの定義について"
    },
    {
      "indent": 3,
      "text": "container bar { leaf foo { type uint8; } }",
      "ja": "コンテナバー{葉FOO {型UINT8。 }}"
    },
    {
      "indent": 3,
      "text": "the following is a valid JSON-encoded instance:",
      "ja": "以下は、有効なJSONエンコードされたインスタンスです。"
    },
    {
      "indent": 3,
      "text": "\"bar\": {\n  \"foo\": 123\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "5.3. The \"leaf-list\" Data Node",
      "section_title": true,
      "ja": "5.3。 「リーフリスト」データノード"
    },
    {
      "indent": 3,
      "text": "A leaf-list is encoded as a name/array pair, and the array elements are values of some scalar type, which can be a string, number, literal \"true\" or \"false\", or the special array \"[null]\", depending on the type of the leaf-list (see Section 6 for the type encoding rules).",
      "ja": "リーフリストは、名前/アレイペアとしてエンコードされ、そして配列要素は、文字列、数値、リテラル「true」または「false」、または特別なアレイ「[NULL]」とすることができるいくつかのスカラー型の値であります、リーフ・リストのタイプに応じて（型符号化規則については、セクション6を参照）。"
    },
    {
      "indent": 3,
      "text": "The ordering of array elements follows the same rules as the ordering of XML elements representing leaf-list entries in the XML encoding. Specifically, the \"ordered-by\" properties (Section 7.7.7 in [RFC7950]) MUST be observed.",
      "ja": "配列要素の順序付けは、XMLエンコーディングにリーフリストエントリを表すXML要素の順序と同じ規則に従います。具体的には、「規則正しいバイ」プロパティ（[RFC7950]セクション7.7.7）が観察されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Example: For the leaf-list definition",
      "ja": "例：リーフリストの定義について"
    },
    {
      "indent": 3,
      "text": "leaf-list foo { type uint8; }",
      "ja": "リーフリストFOO {型UINT8。 }"
    },
    {
      "indent": 3,
      "text": "the following is a valid JSON-encoded instance:",
      "ja": "以下は、有効なJSONエンコードされたインスタンスです。"
    },
    {
      "indent": 3,
      "text": "\"foo\": [123, 0]",
      "raw": true
    },
    {
      "indent": 0,
      "text": "5.4. The \"list\" Data Node",
      "section_title": true,
      "ja": "5.4。 「リスト」データノード"
    },
    {
      "indent": 3,
      "text": "A list instance is encoded as a name/array pair, and the array elements are JSON objects.",
      "ja": "リストのインスタンスは、名前/アレイペアとしてエンコードされ、そして配列要素は、JSONオブジェクトです。"
    },
    {
      "indent": 3,
      "text": "The ordering of array elements follows the same rules as the ordering of XML elements representing list entries in the XML encoding. Specifically, the \"ordered-by\" properties (Section 7.7.7 in [RFC7950]) MUST be observed.",
      "ja": "配列要素の順序付けは、XMLエンコーディングでリスト項目を表すXML要素の順序と同じ規則に従います。具体的には、「規則正しいバイ」プロパティ（[RFC7950]セクション7.7.7）が観察されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Unlike the XML encoding, where list keys are required to precede any other siblings within a list entry and appear in the order specified by the data model, the order of members in a JSON-encoded list entry is arbitrary because JSON objects are fundamentally unordered collections of members.",
      "ja": "JSONオブジェクトは基本的に順序付けられていないコレクションであるため、リストキーがリストエントリ内の任意の他の兄弟の前に、データモデルによって指定された順序で表示されるために必要とされるXMLエンコーディングとは異なり、JSONエンコードされたリスト・エントリ内のメンバーの順序は任意ですメンバーの。"
    },
    {
      "indent": 3,
      "text": "Example: For the list definition",
      "ja": "例：リストの定義については"
    },
    {
      "indent": 3,
      "text": "list bar {\n  key foo;\n  leaf foo {\n    type uint8;\n  }\n  leaf baz {\n    type string;\n  }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "the following is a valid JSON-encoded instance:",
      "ja": "以下は、有効なJSONエンコードされたインスタンスです。"
    },
    {
      "indent": 3,
      "text": "\"bar\": [\n  {\n    \"foo\": 123,\n    \"baz\": \"zig\"\n  },\n  {\n    \"baz\": \"zag\",\n    \"foo\": 0\n  }\n]",
      "raw": true
    },
    {
      "indent": 0,
      "text": "5.5. The \"anydata\" Data Node",
      "section_title": true,
      "ja": "5.5。 「ANYDATA」データノード"
    },
    {
      "indent": 3,
      "text": "The anydata data node serves as a container for an arbitrary set of nodes that otherwise appear as normal YANG-modeled data. A data model for anydata content may or may not be known at runtime. In the latter case, converting JSON-encoded instances to the XML encoding defined in [RFC7950] may be impossible.",
      "ja": "ANYDATAデータノードは、そうでなければ正常YANG、モデル化されたデータとして表示されたノードの任意のセットのコンテナとして機能します。 ANYDATAコンテンツのためのデータモデルは、または実行時に知られていない可能性があります。後者の場合には、[RFC7950]で定義されたXMLエンコーディングにJSONエンコードインスタンスを変換することは不可能であってもよいです。"
    },
    {
      "indent": 3,
      "text": "An anydata instance is encoded in the same way as a container, i.e., as a name/object pair. The requirement that anydata content can be modeled by YANG implies the following rules for the JSON text inside the object:",
      "ja": "ANYDATAインスタンス名/オブジェクトのペアとして、すなわち容器と同様に符号化されます。 ANYDATAコンテンツがYANGによってモデル化することができる要件は、オブジェクト内部JSONテキストの次のルールを暗示します。"
    },
    {
      "indent": 3,
      "text": "o It is valid I-JSON [RFC7493].",
      "ja": "Oそれは有効なI-JSON [RFC7493]です。"
    },
    {
      "indent": 3,
      "text": "o All object member names satisfy the ABNF production in Figure 1.",
      "ja": "Oすべてのオブジェクトのメンバー名は、図1のABNF生産を満たします。"
    },
    {
      "indent": 3,
      "text": "o Any JSON array contains either only unique scalar values (as a leaf-list; see Section 5.3) or only objects (as a list; see Section 5.4).",
      "ja": "O任意のJSON配列に含まれるいずれかのみ一意スカラー値、またはオブジェクトのみ（リーフリストとして第5.3節を参照されたい）（リストとして、セクション5.4を参照）。"
    },
    {
      "indent": 3,
      "text": "o The \"null\" value is only allowed in the single-element array \"[null]\" corresponding to the encoding of the \"empty\" type; see Section 6.9.",
      "ja": "O「ヌル」値は単一要素の配列で許可されている「[NULL]」「空」タイプの符号化に対応します。セクション6.9を参照してください。"
    },
    {
      "indent": 3,
      "text": "Example: For the anydata definition",
      "ja": "例：ANYDATAの定義について"
    },
    {
      "indent": 3,
      "text": "anydata data;",
      "ja": "ANYDATAデータ;"
    },
    {
      "indent": 3,
      "text": "the following is a valid JSON-encoded instance:",
      "ja": "以下は、有効なJSONエンコードされたインスタンスです。"
    },
    {
      "indent": 3,
      "text": "\"data\": {\n  \"ietf-notification:notification\": {\n    \"eventTime\": \"2014-07-29T13:43:01Z\",\n    \"example-event:event\": {\n      \"event-class\": \"fault\",\n      \"reporting-entity\": {\n        \"card\": \"Ethernet0\"\n      },\n      \"severity\": \"major\"\n    }\n  }\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "5.6. The \"anyxml\" Data Node",
      "section_title": true,
      "ja": "5.6。 「AnyXMLで」データノード"
    },
    {
      "indent": 3,
      "text": "An anyxml instance is encoded as a JSON name/value pair. The value MUST satisfy I-JSON constraints.",
      "ja": "AnyXMLでインスタンスは、JSONの名前/値ペアとして符号化されます。値は、I-JSONの制約を満たさなければなりません。"
    },
    {
      "indent": 3,
      "text": "Example: For the anyxml definition",
      "ja": "例：AnyXMLでの定義について"
    },
    {
      "indent": 3,
      "text": "anyxml bar;",
      "ja": "AnyXMLでバー;"
    },
    {
      "indent": 3,
      "text": "the following is a valid JSON-encoded instance:",
      "ja": "以下は、有効なJSONエンコードされたインスタンスです。"
    },
    {
      "indent": 3,
      "text": "\"bar\": [true, null, true]",
      "raw": true
    },
    {
      "indent": 0,
      "text": "5.7. Metadata Objects",
      "section_title": true,
      "ja": "5.7。メタデータ・オブジェクト"
    },
    {
      "indent": 3,
      "text": "Apart from instances of YANG data nodes, a JSON document MAY contain special object members whose name starts with the \"@\" character (COMMERCIAL AT). Such members are used for special purposes, such as encoding metadata [RFC7952]. The exact syntax and semantics of such members are outside the scope of this document.",
      "ja": "別にYANGデータノードのインスタンスから、JSON文書は、名前が「@」文字（COMMERCIAL AT）で始まる特別なオブジェクトのメンバーを含むかもしれません。そのような部材は、符号化メタデータ[RFC7952]などの特別な目的のために使用されます。正確な構文と、そのようなメンバーのセマンティクスは、この文書の範囲外です。"
    },
    {
      "indent": 0,
      "text": "6. Representing YANG Data Types in JSON Values",
      "section_title": true,
      "ja": "6. JSON値のYANGデータ型を表現"
    },
    {
      "indent": 3,
      "text": "The type of the JSON value in an instance of the leaf or leaf-list data node depends on the type of that data node, as specified in the following subsections.",
      "ja": "以下のサブセクションで指定された葉または葉リストデータノードのインスタンスでJSON値のタイプは、そのデータ・ノードのタイプに依存します。"
    },
    {
      "indent": 0,
      "text": "6.1. Numeric Types",
      "section_title": true,
      "ja": "6.1。数値型"
    },
    {
      "indent": 3,
      "text": "A value of the \"int8\", \"int16\", \"int32\", \"uint8\", \"uint16\", or \"uint32\" type is represented as a JSON number.",
      "ja": "\"INT8\"、 \"INT16\"、 \"INT32\"、 \"UINT8\"、 \"uint16の\"、または \"UINT32\" タイプの値は、JSONの数として表されます。"
    },
    {
      "indent": 3,
      "text": "A value of the \"int64\", \"uint64\", or \"decimal64\" type is represented as a JSON string whose content is the lexical representation of the corresponding YANG type as specified in Sections 9.2.1 and 9.3.1 of [RFC7950].",
      "ja": "「Int64型」、「UINT64」、または「decimal64」タイプの値は、そのコンテンツのセクション9.2.1で指定され、対応する陽型の字句表現であるJSON文字列として表され、[RFC7950]の9.3.1。"
    },
    {
      "indent": 3,
      "text": "For example, if the type of the leaf \"foo\" in Section 5.1 was \"uint64\" instead of \"uint8\", the instance would have to be encoded as",
      "ja": "セクション5.1で葉「FOO」の種類が「UINT64」の代わりに「UINT8」であった場合、例えば、インスタンスはとして符号化されなければなりません"
    },
    {
      "indent": 3,
      "text": "\"foo\": \"123\"",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The special handling of 64-bit numbers follows from the I-JSON recommendation to encode numbers exceeding the IEEE 754-2008 double-precision range [IEEE754-2008] as strings; see Section 2.2 in [RFC7493].",
      "ja": "64ビット数の特別な処理は、文字列として[IEEE754-2008] IEEE 754-2008倍精度の範囲を超える数値を符号化するためにI-JSON推薦から以下; [RFC7493]で2.2節を参照してください。"
    },
    {
      "indent": 0,
      "text": "6.2. The \"string\" Type",
      "section_title": true,
      "ja": "6.2。 「文字列」タイプ"
    },
    {
      "indent": 3,
      "text": "A \"string\" value is represented as a JSON string, subject to JSON string encoding rules.",
      "ja": "「文字列」の値は、JSON文字列の符号化規則に従うJSON文字列として表されます。"
    },
    {
      "indent": 0,
      "text": "6.3. The \"boolean\" Type",
      "section_title": true,
      "ja": "6.3。 「ブール」タイプ"
    },
    {
      "indent": 3,
      "text": "A \"boolean\" value is represented as the corresponding JSON literal name \"true\" or \"false\".",
      "ja": "「ブール」値は、対応するJSONリテラル名「true」または「false」として表現されます。"
    },
    {
      "indent": 0,
      "text": "6.4. The \"enumeration\" Type",
      "section_title": true,
      "ja": "6.4。 「列挙」タイプ"
    },
    {
      "indent": 3,
      "text": "An \"enumeration\" value is represented as a JSON string -- one of the names assigned by \"enum\" statements in YANG.",
      "ja": "YANGで「列挙型」文によって割り当てられた名前の1  - 「列挙」値は、JSON文字列として表現されます。"
    },
    {
      "indent": 3,
      "text": "The representation is identical to the lexical representation of the \"enumeration\" type in XML; see Section 9.6 in [RFC7950].",
      "ja": "表現は、XMLの「列挙」型の字句表現と同一です。 [RFC7950]でセクション9.6を参照してください。"
    },
    {
      "indent": 0,
      "text": "6.5. The \"bits\" Type",
      "section_title": true,
      "ja": "6.5。 「ビット」タイプ"
    },
    {
      "indent": 3,
      "text": "A \"bits\" value is represented as a JSON string -- a space-separated sequence of names of bits that are set. The permitted bit names are assigned by \"bit\" statements in YANG.",
      "ja": "設定されたビットの名前のスペースで区切られた配列 - 「ビット」値をJSON文字列として表現されます。許可ビット名はYANGで「ビット」のステートメントによって割り当てられます。"
    },
    {
      "indent": 3,
      "text": "The representation is identical to the lexical representation of the \"bits\" type; see Section 9.7 in [RFC7950].",
      "ja": "表現は、「ビット」タイプの字句表現と同一です。 [RFC7950]でセクション9.7を参照してください。"
    },
    {
      "indent": 0,
      "text": "6.6. The \"binary\" Type",
      "section_title": true,
      "ja": "6.6。 「バイナリー」タイプ"
    },
    {
      "indent": 3,
      "text": "A \"binary\" value is represented as a JSON string -- base64 encoding of arbitrary binary data.",
      "ja": "任意のバイナリデータのbase64エンコード - 「バイナリ」値は、JSON文字列として表されます。"
    },
    {
      "indent": 3,
      "text": "The representation is identical to the lexical representation of the \"binary\" type in XML; see Section 9.8 in [RFC7950].",
      "ja": "表現は、XMLの「バイナリ」タイプの字句表現と同一です。 [RFC7950]でセクション9.8を参照してください。"
    },
    {
      "indent": 0,
      "text": "6.7. The \"leafref\" Type",
      "section_title": true,
      "ja": "6.7。 「leafref」タイプ"
    },
    {
      "indent": 3,
      "text": "A \"leafref\" value is represented using the same rules as the type of the leaf to which the leafref value refers.",
      "ja": "「leafref」値はleafref値が参照する葉の種類と同じ規則を使用して表されています。"
    },
    {
      "indent": 0,
      "text": "6.8. The \"identityref\" Type",
      "section_title": true,
      "ja": "6.8。 「identityref」タイプ"
    },
    {
      "indent": 3,
      "text": "An \"identityref\" value is represented as a string -- the name of an identity. If the identity is defined in a module other than the leaf node containing the identityref value, the namespace-qualified form (Section 4) MUST be used. Otherwise, both the simple and namespace-qualified forms are permitted.",
      "ja": "アイデンティティの名前 - 「identityref」値は、文字列として表現されます。アイデンティティがidentityref値を含むリーフノード以外のモジュール内で定義されている場合、名前空間修飾形態（第4章）を使用しなければなりません。それ以外の場合は、両方のシンプルで名前空間修飾形式が許可されています。"
    },
    {
      "indent": 3,
      "text": "For example, consider the following schematic module:",
      "ja": "たとえば、次の図のモジュールを考慮してください。"
    },
    {
      "indent": 3,
      "text": "module example-mod {\n  ...\n  import ietf-interfaces {\n    prefix if;\n  }\n  ...\n  leaf type {\n    type identityref {\n      base \"if:interface-type\";\n    }\n  }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A valid instance of the \"type\" leaf is then encoded as follows:",
      "ja": "以下のように「タイプ」の葉の有効なインスタンスは、符号化されています。"
    },
    {
      "indent": 3,
      "text": "\"type\": \"iana-if-type:ethernetCsmacd\"",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The namespace identifier \"iana-if-type\" must be present in this case because the \"ethernetCsmacd\" identity is not defined in the same module as the \"type\" leaf.",
      "ja": "「ethernetCsmacd」同一性「は型」葉と同じモジュール内で定義されていないので、名前空間識別子「IANA-IF型」とは、この場合に存在しなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.9. The \"empty\" Type",
      "section_title": true,
      "ja": "6.9。 「空」の種類"
    },
    {
      "indent": 3,
      "text": "An \"empty\" value is represented as \"[null]\", i.e., an array with the \"null\" literal being its only element. For the purposes of this document, \"[null]\" is considered an atomic scalar value.",
      "ja": "「空」の値は次のように表現される「[NULL]」、すなわち、「ヌル」リテラルである唯一の要素を持つ配列。本文書の目的のために、「[NULL]」アトミックスカラー値であると考えられます。"
    },
    {
      "indent": 3,
      "text": "This encoding of the \"empty\" type was chosen instead of using simply \"null\" in order to facilitate the use of empty leafs in common programming languages where the \"null\" value of a member is treated as if the member is not present.",
      "ja": "「空の」タイプのこの符号化は、メンバーが存在しないかのように会員の「ヌル」値が処理され、共通のプログラミング言語内の空の葉の使用を容易にするために、代わりに、単に「NULL」を使用する選択されました。"
    },
    {
      "indent": 3,
      "text": "Example: For the leaf definition",
      "ja": "例：葉の定義について"
    },
    {
      "indent": 3,
      "text": "leaf foo { type empty; }",
      "ja": "リーフFOO {タイプ空。 }"
    },
    {
      "indent": 3,
      "text": "a valid instance is",
      "ja": "有効なインスタンスであります"
    },
    {
      "indent": 3,
      "text": "\"foo\": [null]",
      "raw": true
    },
    {
      "indent": 0,
      "text": "6.10. The \"union\" Type",
      "section_title": true,
      "ja": "6.10。 「労働組合」タイプ"
    },
    {
      "indent": 3,
      "text": "A value of the \"union\" type is encoded as the value of any of the member types.",
      "ja": "「ユニオン」タイプの値は、メンバーの種類のいずれかの値として符号化されます。"
    },
    {
      "indent": 3,
      "text": "When validating a value of the \"union\" type, the type information conveyed by the JSON encoding MUST also be taken into account. JSON syntax thus provides additional means for resolving the member type of the union that are not available in XML encoding.",
      "ja": "「ユニオン」タイプの値を検証するときに、JSONエンコーディングによって搬送タイプ情報も考慮しなければなりません。 JSONの構文は、このようにXMLのエンコーディングでは利用できない労働組合のメンバーの種類を解決するための追加的な手段を提供します。"
    },
    {
      "indent": 3,
      "text": "For example, consider the following YANG definition:",
      "ja": "たとえば、次のようYANG定義を考えてみます。"
    },
    {
      "indent": 3,
      "text": "leaf bar {\n  type union {\n    type uint16;\n    type string;\n  }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "In RESTCONF [RESTCONF], it is possible to set the value of \"bar\" in the following way when using the \"application/yang.data+xml\" media type:",
      "ja": "RESTCONF [RESTCONF]には、「アプリケーション/ yang.data + XML」メディアタイプを使用する場合、以下のように「バー」の値を設定することが可能です。"
    },
    {
      "indent": 3,
      "text": "<bar>13.5</bar>",
      "ja": "<バー> 13.5 </バー>"
    },
    {
      "indent": 3,
      "text": "because the value may be interpreted as a string, i.e., the second member type of the union. When using the \"application/yang.data+json\" media type, however, this is an error:",
      "ja": "値は、文字列、すなわち、組合の第2部材型として解釈することができるからです。 「アプリケーション/ yang.data + JSON」メディアタイプを使用する場合は、しかし、これは誤りです。"
    },
    {
      "indent": 3,
      "text": "\"bar\": 13.5",
      "ja": "\"バー\"：13.5"
    },
    {
      "indent": 3,
      "text": "In this case, the JSON encoding indicates that the value is supposed to be a number rather than a string, and it is not a valid \"uint16\" value.",
      "ja": "この場合、JSONエンコード値が数値ではなく文字列であると想定されていることを示し、それは、有効な「uint16の」値ではありません。"
    },
    {
      "indent": 3,
      "text": "Conversely, the value of",
      "ja": "逆に、値"
    },
    {
      "indent": 3,
      "text": "\"bar\": \"1\"",
      "raw": true
    },
    {
      "indent": 3,
      "text": "is to be interpreted as a string.",
      "ja": "文字列として解釈されるべきです。"
    },
    {
      "indent": 0,
      "text": "6.11. The \"instance-identifier\" Type",
      "section_title": true,
      "ja": "6.11。 「インスタンス識別子」タイプ"
    },
    {
      "indent": 3,
      "text": "An \"instance-identifier\" value is encoded as a string that is analogical to the lexical representation in XML encoding; see Section 9.13.2 in [RFC7950]. However, the encoding of namespaces in instance-identifier values follows the rules stated in Section 4, namely:",
      "ja": "「インスタンス識別子」の値は、XMLエンコーディングに字句表現に類推された文字列として符号化されます。 [RFC7950]でセクション9.13.2を参照してください。しかしながら、インスタンス識別子の値の名前空間の符号化、すなわち、セクション4で述べた規則に従います。"
    },
    {
      "indent": 3,
      "text": "o The leftmost (top-level) data node name is always in the namespace-qualified form.",
      "ja": "最左（最上位）Oデータノード名は、名前空間修飾形で常に。"
    },
    {
      "indent": 3,
      "text": "o Any subsequent data node name is in the namespace-qualified form if the node is defined in a module other than its parent node, and the simple form is used otherwise. This rule also holds for node names appearing in predicates.",
      "ja": "Oノードがその親ノード以外のモジュールで定義されている場合でも、後続のデータノード名は、名前空間修飾形態であり、そして単純な形は、そうでなければ使用されます。このルールは、述語に登場するノード名を保持しています。"
    },
    {
      "indent": 3,
      "text": "For example,",
      "ja": "例えば、"
    },
    {
      "indent": 3,
      "text": "/ietf-interfaces:interfaces/interface[name='eth0']/ietf-ip:ipv4/ip",
      "ja": "/ IETF-インターフェイス：インターフェイス/インターフェイス[NAME = 'はeth0'] / IETF-IP：のIPv4 / IP"
    },
    {
      "indent": 3,
      "text": "is a valid instance-identifier value because the data nodes \"interfaces\", \"interface\", and \"name\" are defined in the module \"ietf-interfaces\", whereas \"ipv4\" and \"ip\" are defined in \"ietf-ip\".",
      "ja": "データノード「インターフェース」、「インターフェース」、および「名前」が「-インターフェイスIETF」モジュールで定義されているので、有効なインスタンス識別子の値は、「IPv4の」および「IP」に対し、「IETF-IP」で定義されています。"
    },
    {
      "indent": 0,
      "text": "7. I-JSON Compliance",
      "section_title": true,
      "ja": "7. I-JSONコンプライアンス"
    },
    {
      "indent": 3,
      "text": "I-JSON [RFC7493] is a restricted profile of JSON that guarantees maximum interoperability for protocols that use JSON in their messages, no matter what JSON encoders/decoders are used in protocol implementations. The encoding defined in this document therefore observes the I-JSON requirements and recommendations as closely as possible.",
      "ja": "I-JSON [RFC7493]に関係なく、エンコーダ/デコーダは、プロトコルの実装に使用されているものをJSON、そのメッセージにJSONを使用していないプロトコルのための最大の相互運用性を保証してJSONの制限プロファイルです。この文書で定義された符号化は、したがって、できるだけI-JSONの要件と推奨事項を観察します。"
    },
    {
      "indent": 3,
      "text": "In particular, the following properties are guaranteed:",
      "ja": "具体的には、次のプロパティが保証されています。"
    },
    {
      "indent": 3,
      "text": "o Character encoding is UTF-8.",
      "ja": "Oの文字エンコーディングはUTF-8です。"
    },
    {
      "indent": 3,
      "text": "o Member names within the same JSON object are always unique.",
      "ja": "O同じJSONオブジェクト内のメンバーの名前は常にユニークです。"
    },
    {
      "indent": 3,
      "text": "o The order of JSON object members is never relied upon.",
      "ja": "O JSONオブジェクトのメンバの順序が依拠されることはありません。"
    },
    {
      "indent": 3,
      "text": "o Numbers of any type supported by YANG can be exchanged reliably. See Section 6.1 for details.",
      "ja": "YANGでサポートされている任意のタイプのOの数は確実に交換することができます。詳細については、6.1節を参照してください。"
    },
    {
      "indent": 3,
      "text": "The JSON encoding defined in this document deviates from I-JSON only in the representation of the \"binary\" type. In order to remain compatible with XML encoding, the base64 encoding scheme is used (Section 6.6), whilst I-JSON recommends base64url instead.",
      "ja": "この文書で定義されたJSONエンコーディングのみ「バイナリ」タイプの表現でI-JSONから外れます。 I-JSON代わりbase64urlを推奨しながら、XMLエンコーディングとの互換性を維持するためには、Base64エンコード方式は、（セクション6.6）が使用されます。"
    },
    {
      "indent": 0,
      "text": "8. Security Considerations",
      "section_title": true,
      "ja": "8.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document defines an alternative encoding for data modeled in the YANG data modeling language. As such, it doesn't contribute any new security issues beyond those discussed in Section 17 of [RFC7950].",
      "ja": "この文書では、YANGデータモデリング言語でモデル化されたデータのための代替エンコーディングを定義します。このように、それは、[RFC7950]のセクション17で説明したものを超えてどんな新しいセキュリティ問題を寄与していません。"
    },
    {
      "indent": 3,
      "text": "This document defines no mechanisms for signing and encrypting data modeled with YANG. Under normal circumstances, data security and integrity are guaranteed by the management protocol in use, such as NETCONF [RFC6241] or RESTCONF [RESTCONF]. If this is not the case, external mechanisms, such as Public-Key Cryptography Standards (PKCS) #7 [RFC2315] or JSON Object Signing and Encryption (JOSE) [RFC7515] [RFC7516], need to be considered.",
      "ja": "この文書では、YANGでモデル化されたデータに署名し、暗号化のための何のメカニズムを定義しません。通常の状況下では、データのセキュリティと完全性は、NETCONF [RFC6241]またはRESTCONF [RESTCONF]と、使用中の管理プロトコルによって保証されます。そうでない場合は、そのような公開鍵暗号規格などの外部メカニズム、（PKCS）＃7 [RFC2315]またはJSONオブジェクトの署名と暗号化（JOSE）[RFC7515] [RFC7516]は、考慮する必要があります。"
    },
    {
      "indent": 3,
      "text": "JSON processing is rather different from XML, and JSON parsers may thus suffer from different types of vulnerabilities than their XML counterparts. To minimize these new security risks, software on the receiving side SHOULD reject all messages that do not comply with the rules of this document and reply with an appropriate error message to the sender.",
      "ja": "JSON処理がXMLからかなり異なり、JSONパーサは、このように、それらのXML対応物よりも脆弱性の異なる種類に苦しむことができます。これらの新たなセキュリティリスクを最小限に抑えるために、受信側のソフトウェアは、この文書のルールを遵守し、送信者に適切なエラーメッセージで応答していないすべてのメッセージを拒否すべきです。"
    },
    {
      "indent": 0,
      "text": "9. References",
      "section_title": true,
      "ja": "9.参考文献"
    },
    {
      "indent": 0,
      "text": "9.1. Normative References",
      "section_title": true,
      "ja": "9.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<http://www.rfc-editor.org/info/ RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC5234] Crocker, D., Ed. and P. Overell, \"Augmented BNF for Syntax Specifications: ABNF\", STD 68, RFC 5234, DOI 10.17487/RFC5234, January 2008, <http://www.rfc-editor.org/info/rfc5234>.",
      "ja": "[RFC5234]クロッカー、D.、エド。そして、P. Overell、 \"構文仕様のための増大しているBNF：ABNF\"、STD 68、RFC 5234、DOI 10.17487 / RFC5234、2008年1月、<http://www.rfc-editor.org/info/rfc5234>。"
    },
    {
      "indent": 3,
      "text": "[RFC6241] Enns, R., Ed., Bjorklund, M., Ed., Schoenwaelder, J., Ed., and A. Bierman, Ed., \"Network Configuration Protocol (NETCONF)\", RFC 6241, DOI 10.17487/RFC6241, June 2011, <http://www.rfc-editor.org/info/rfc6241>.",
      "ja": "[RFC6241]エンス、R.、編、Bjorklund、M.、編、Schoenwaelder、J.、編、及びA. Bierman、編、 \"ネットワーク構成プロトコル（NETCONF）\"、RFC 6241、DOI 10.17487 / RFC6241、2011年6月、<http://www.rfc-editor.org/info/rfc6241>。"
    },
    {
      "indent": 3,
      "text": "[RFC7159] Bray, T., Ed., \"The JavaScript Object Notation (JSON) Data Interchange Format\", RFC 7159, DOI 10.17487/RFC7159, March 2014, <http://www.rfc-editor.org/info/rfc7159>.",
      "ja": "[RFC7159]ブレイ、T.、エド。、 \"JavaScriptのObject Notation（JSON）形式のデータ交換フォーマット\"、RFC 7159、DOI 10.17487 / RFC7159、2014年3月、<http://www.rfc-editor.org/info/ rfc7159>。"
    },
    {
      "indent": 3,
      "text": "[RFC7493] Bray, T., Ed., \"The I-JSON Message Format\", RFC 7493, DOI 10.17487/RFC7493, March 2015, <http://www.rfc-editor.org/info/rfc7493>.",
      "ja": "[RFC7493]ブレイ、T.、エド。、 \"I-JSONメッセージ形式\"、RFC 7493、DOI 10.17487 / RFC7493、2015年3月、<http://www.rfc-editor.org/info/rfc7493>。"
    },
    {
      "indent": 3,
      "text": "[RFC7950] Bjorklund, M., Ed., \"The YANG 1.1 Data Modeling Language\", RFC 7950, DOI 10.17487/RFC7950, August 2016, <http://www.rfc-editor.org/info/rfc7950>.",
      "ja": "[RFC7950] Bjorklund、M.編、 \"YANG 1.1データモデリング言語\"、RFC 7950、DOI 10.17487 / RFC7950、2016年8月、<http://www.rfc-editor.org/info/rfc7950>。"
    },
    {
      "indent": 0,
      "text": "9.2. Informative References",
      "section_title": true,
      "ja": "9.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[IEEE754-2008] IEEE, \"IEEE Standard for Floating-Point Arithmetic\", IEEE 754-2008, DOI 10.1109/IEEESTD.2008.4610935, 2008, <http://standards.ieee.org/findstds/ standard/754-2008.html>.",
      "ja": "[IEEE754-2008] IEEE、 \"浮動小数点演算のためのIEEE規格\"、IEEE 754-2008、DOI 10.1109 / IEEESTD.2008.4610935、2008年、<http://standards.ieee.org/findstds/標準/ 754-2008。 HTML>。"
    },
    {
      "indent": 3,
      "text": "[RESTCONF] Bierman, A., Bjorklund, M., and K. Watsen, \"RESTCONF Protocol\", Work in Progress, draft-ietf-netconf-restconf-16, August 2016.",
      "ja": "【RESTCONF] Bierman、A.、Bjorklund、M.、およびK. Watsen、 \"RESTCONFプロトコル\"、ProgressのWork、ドラフトIETF-NETCONF-restconf-16、2016年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC2315] Kaliski, B., \"PKCS #7: Cryptographic Message Syntax Version 1.5\", RFC 2315, DOI 10.17487/RFC2315, March 1998, <http://www.rfc-editor.org/info/rfc2315>.",
      "ja": "[RFC2315] Kaliski、B.、 \"PKCS＃7：暗号メッセージ構文バージョン1.5\"、RFC 2315、DOI 10.17487 / RFC2315、1998年3月、<http://www.rfc-editor.org/info/rfc2315>。"
    },
    {
      "indent": 3,
      "text": "[RFC6020] Bjorklund, M., Ed., \"YANG - A Data Modeling Language for the Network Configuration Protocol (NETCONF)\", RFC 6020, DOI 10.17487/RFC6020, October 2010, <http://www.rfc-editor.org/info/rfc6020>.",
      "ja": "[RFC6020] Bjorklund、M.、エド、 \"YANG  - ネットワーク構成プロトコルのためのデータモデリング言語（NETCONF）\"、RFC 6020、DOI 10.17487 / RFC6020、2010年10月、<のhttp：。//www.rfc-editor。組織/情報/ rfc6020>。"
    },
    {
      "indent": 3,
      "text": "[RFC7223] Bjorklund, M., \"A YANG Data Model for Interface Management\", RFC 7223, DOI 10.17487/RFC7223, May 2014, <http://www.rfc-editor.org/info/rfc7223>.",
      "ja": "[RFC7223] Bjorklund、M.、 \"インターフェイスの管理のためのYANGデータモデル\"、RFC 7223、DOI 10.17487 / RFC7223、2014年5月、<http://www.rfc-editor.org/info/rfc7223>。"
    },
    {
      "indent": 3,
      "text": "[RFC7515] Jones, M., Bradley, J., and N. Sakimura, \"JSON Web Signature (JWS)\", RFC 7515, DOI 10.17487/RFC7515, May 2015, <http://www.rfc-editor.org/info/rfc7515>.",
      "ja": "[RFC7515]ジョーンズ、M.、ブラッドリー、J。、およびN. Sakimura、 \"JSONウェブ署名（JWS）\"、RFC 7515、DOI 10.17487 / RFC7515、2015年5月、<http://www.rfc-editor.org /情報/ rfc7515>。"
    },
    {
      "indent": 3,
      "text": "[RFC7516] Jones, M. and J. Hildebrand, \"JSON Web Encryption (JWE)\", RFC 7516, DOI 10.17487/RFC7516, May 2015, <http://www.rfc-editor.org/info/rfc7516>.",
      "ja": "[RFC7516]ジョーンズ、M.及びJ.ヒルデブランド、 \"JSONウェブ暗号化（JWE）\"、RFC 7516、DOI 10.17487 / RFC7516、2015年5月、<http://www.rfc-editor.org/info/rfc7516>。"
    },
    {
      "indent": 3,
      "text": "[RFC7952] Lhotka, L., \"Defining and Using Metadata with YANG\", RFC 7952, DOI 10.17487/RFC7952, August 2016, <http://www.rfc-editor.org/info/rfc7952>.",
      "ja": "[RFC7952] Lhotka、L.、 \"定義とYANGでメタデータを使用する\"、RFC 7952、DOI 10.17487 / RFC7952、2016年8月、<http://www.rfc-editor.org/info/rfc7952>。"
    },
    {
      "indent": 3,
      "text": "[XML] Bray, T., Paoli, J., Sperberg-McQueen, M., Maler, E., and F. Yergeau, \"Extensible Markup Language (XML) 1.0 (Fifth Edition)\", World Wide Web Consortium Recommendation REC-xml-20081126, November 2008, <http://www.w3.org/TR/2008/REC-xml-20081126>.",
      "ja": "[XML]ブレイ、T.、パオリ、J.、Sperberg-マックイーン、M.、MALER、E.、およびF. Yergeau、 \"拡張マークアップ言語（XML）1.0（第5版）\"、ワールドワイドウェブコンソーシアム推薦REC -xml-20081126、2008年11月、<http://www.w3.org/TR/2008/REC-xml-20081126>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. A Complete Example",
      "ja": "付録A. A完全な例"
    },
    {
      "indent": 3,
      "text": "The JSON document shown below represents the same data as the reply to the NETCONF <get> request appearing in Appendix D of [RFC7223]. The data model is a combination of two YANG modules: \"ietf-interfaces\" and \"ex-vlan\" (the latter is an example module from Appendix C of [RFC7223]). The \"if-mib\" feature defined in the \"ietf-interfaces\" module is supported.",
      "ja": "以下に示すJSON文書は[RFC7223]の付録Dに現れるNETCONF <GET>要求に対する応答と同じデータを表しています。 「IETF・インターフェース」と「EX-VLAN」（後者は[RFC7223]の付録Cから例えばモジュールである）：データ・モデルは、2つのYANGモジュールの組み合わせです。 「IETF-インターフェース」モジュールで定義された「IF-MIB」機能がサポートされています。"
    },
    {
      "indent": 3,
      "text": "{\n  \"ietf-interfaces:interfaces\": {\n    \"interface\": [\n      {\n        \"name\": \"eth0\",\n        \"type\": \"iana-if-type:ethernetCsmacd\",\n        \"enabled\": false\n      },\n      {\n        \"name\": \"eth1\",\n        \"type\": \"iana-if-type:ethernetCsmacd\",\n        \"enabled\": true,\n        \"ex-vlan:vlan-tagging\": true\n      },\n      {\n        \"name\": \"eth1.10\",\n        \"type\": \"iana-if-type:l2vlan\",\n        \"enabled\": true,\n        \"ex-vlan:base-interface\": \"eth1\",\n        \"ex-vlan:vlan-id\": 10\n      },\n      {\n        \"name\": \"lo1\",\n        \"type\": \"iana-if-type:softwareLoopback\",\n        \"enabled\": true\n      }\n    ]\n  },\n  \"ietf-interfaces:interfaces-state\": {\n    \"interface\": [\n      {\n        \"name\": \"eth0\",\n        \"type\": \"iana-if-type:ethernetCsmacd\",\n        \"admin-status\": \"down\",\n        \"oper-status\": \"down\",\n        \"if-index\": 2,\n        \"phys-address\": \"00:01:02:03:04:05\",\n        \"statistics\": {\n          \"discontinuity-time\": \"2013-04-01T03:00:00+00:00\"",
      "raw": true
    },
    {
      "indent": 9,
      "text": "  }\n},\n{\n  \"name\": \"eth1\",\n  \"type\": \"iana-if-type:ethernetCsmacd\",\n  \"admin-status\": \"up\",\n  \"oper-status\": \"up\",\n  \"if-index\": 7,\n  \"phys-address\": \"00:01:02:03:04:06\",\n  \"higher-layer-if\": [\n    \"eth1.10\"\n  ],\n  \"statistics\": {\n    \"discontinuity-time\": \"2013-04-01T03:00:00+00:00\"\n  }\n},\n{\n  \"name\": \"eth1.10\",\n  \"type\": \"iana-if-type:l2vlan\",\n  \"admin-status\": \"up\",\n  \"oper-status\": \"up\",\n  \"if-index\": 9,\n  \"lower-layer-if\": [\n    \"eth1\"\n  ],\n  \"statistics\": {\n    \"discontinuity-time\": \"2013-04-01T03:00:00+00:00\"\n  }\n},\n{\n  \"name\": \"eth2\",\n  \"type\": \"iana-if-type:ethernetCsmacd\",\n  \"admin-status\": \"down\",\n  \"oper-status\": \"down\",\n  \"if-index\": 8,\n  \"phys-address\": \"00:01:02:03:04:07\",\n  \"statistics\": {\n    \"discontinuity-time\": \"2013-04-01T03:00:00+00:00\"\n  }\n},\n{\n  \"name\": \"lo1\",\n  \"type\": \"iana-if-type:softwareLoopback\",\n  \"admin-status\": \"up\",\n  \"oper-status\": \"up\",\n  \"if-index\": 1,\n  \"statistics\": {\n    \"discontinuity-time\": \"2013-04-01T03:00:00+00:00\"",
      "raw": true
    },
    {
      "indent": 3,
      "text": " } } ] } }",
      "ja": "｝ ｝ 」 ｝ ｝"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "The author wishes to thank Andy Bierman, Martin Bjorklund, Dean Bogdanovic, Balazs Lengyel, Juergen Schoenwaelder, and Phil Shafer for their helpful comments and suggestions.",
      "ja": "作者は彼らの役に立つコメントと提案のためにアンディBierman、マーティンBjorklund、ディーンBogdanovic、バラージュLengyel、ユルゲンSchoenwaelder、そしてフィル・シェーファーに感謝したいです。"
    },
    {
      "indent": 0,
      "text": "Author's Address",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Ladislav Lhotka CZ.NIC",
      "ja": "ラディスラフLhotka CZ.NIC"
    },
    {
      "indent": 3,
      "text": "Email: lhotka@nic.cz",
      "ja": "メール：lhotka@nic.cz"
    }
  ]
}