{
  "title": {
    "text": "RFC 7664 - Dragonfly Key Exchange",
    "ja": "RFC 7664 - トンボ鍵交換"
  },
  "number": 7664,
  "created_at": "2019-10-31 22:23:51.905771+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Research Task Force (IRTF)                      D. Harkins, Ed.\nRequest for Comments: 7664                                Aruba Networks\nCategory: Informational                                    November 2015\nISSN: 2070-1721",
      "raw": true
    },
    {
      "indent": 25,
      "text": "Dragonfly Key Exchange",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document specifies a key exchange using discrete logarithm cryptography that is authenticated using a password or passphrase. It is resistant to active attack, passive attack, and offline dictionary attack. This document is a product of the Crypto Forum Research Group (CFRG).",
      "ja": "この文書では、パスワードやパスフレーズを使用して認証された離散対数暗号を使用して鍵交換を指定します。これは、アクティブな攻撃、受動的攻撃、およびオフライン辞書攻撃に耐性があります。この文書では、暗号化フォーラム研究グループ（CFRG）の製品です。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "ja": "このドキュメントはインターネット標準化過程仕様ではありません。それは、情報提供の目的のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Research Task Force (IRTF). The IRTF publishes the results of Internet-related research and development activities. These results might not be suitable for deployment. This RFC represents the individual opinion(s) of one or more members of the Crypto Forum Research Group of the Internet Research Task Force (IRTF). Documents approved for publication by the IRSG are not a candidate for any level of Internet Standard; see Section 2 of RFC 5741.",
      "ja": "この文書はインターネットResearch Task Force（IRTF）の製品です。 IRTFはインターネット関連の研究開発活動の成果を公表しています。これらの結果は、展開に適していない可能性があります。このRFCはインターネットResearch Task Force（IRTF）の暗号化フォーラム研究グループの1つまたは複数のメンバーの個々の意見（複数可）を表しています。 IRSGによって公表のために承認されたドキュメントは、インターネット標準の任意のレベルの候補ではありません。 RFC 5741のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7664.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7664で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2015 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2015 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   2\n  1.1.  Requirements Language . . . . . . . . . . . . . . . . . .   2\n  1.2.  Definitions . . . . . . . . . . . . . . . . . . . . . . .   3\n    1.2.1.  Notations . . . . . . . . . . . . . . . . . . . . . .   3\n    1.2.2.  Resistance to Dictionary Attack . . . . . . . . . . .   3\n2.  Discrete Logarithm Cryptography . . . . . . . . . . . . . . .   4\n  2.1.  Elliptic Curve Cryptography . . . . . . . . . . . . . . .   4\n  2.2.  Finite Field Cryptography . . . . . . . . . . . . . . . .   5\n3.  The Dragonfly Key Exchange  . . . . . . . . . . . . . . . . .   6\n  3.1.  Assumptions . . . . . . . . . . . . . . . . . . . . . . .   7\n  3.2.  Derivation of the Password Element  . . . . . . . . . . .   8\n    3.2.1.  Hunting and Pecking with ECC Groups . . . . . . . . .  10\n    3.2.2.  Hunting and Pecking with MODP Groups  . . . . . . . .  12\n  3.3.  The Commit Exchange . . . . . . . . . . . . . . . . . . .  13\n  3.4.  The Confirm Exchange  . . . . . . . . . . . . . . . . . .  14\n4.  Security Considerations . . . . . . . . . . . . . . . . . . .  15\n5.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  16\n  5.1.  Normative References  . . . . . . . . . . . . . . . . . .  16\n  5.2.  Informative References  . . . . . . . . . . . . . . . . .  16\nAcknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  18\nAuthor's Address  . . . . . . . . . . . . . . . . . . . . . . . .  18",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "Passwords and passphrases are the predominant way of doing authentication in the Internet today. Many protocols that use passwords and passphrases for authentication exchange password-derived data as a proof-of-knowledge of the password (for example, [RFC7296] and [RFC5433]). This opens the exchange up to an offline dictionary attack where the attacker gleans enough knowledge from either an active or passive attack on the protocol to run through a pool of potential passwords and compute verifiers until it is able to match the password-derived data.",
      "ja": "パスワードとパスフレーズは、今日のインターネットでの認証を行うための主要な方法です。証明の知識パスワード（例えば、[RFC7296]及び[RFC5433]）のように認証交換のパスワード由来のデータのパスワードとパスフレーズを使用する多くのプロトコル。これにより、攻撃者は潜在的なパスワードのプールを介して実行し、パスワード由来のデータを一致させることが可能になるまで、ベリファイアを計算するためのプロトコル上のアクティブまたはパッシブ攻撃のいずれかから十分な知識をgleansオフライン辞書攻撃までの交換を開きます。"
    },
    {
      "indent": 3,
      "text": "This protocol employs discrete logarithm cryptography to perform an efficient exchange in a way that performs mutual authentication using a password that is provably resistant to an offline dictionary attack. Consensus of the CFRG for this document was rough.",
      "ja": "このプロトコルは、オフライン辞書攻撃に対して証明可能耐性であるパスワードを使用して相互認証を行う方法で効率的な交換を実行する離散対数暗号化を採用しています。この文書のCFRGのコンセンサスが荒れていました。"
    },
    {
      "indent": 0,
      "text": "1.1. Requirements Language",
      "section_title": true,
      "ja": "1.1。要件言語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [RFC2119].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はありますRFC 2119 [RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "1.2. Definitions",
      "section_title": true,
      "ja": "1.2。定義"
    },
    {
      "indent": 0,
      "text": "1.2.1. Notations",
      "section_title": true,
      "ja": "1.2.1。表記"
    },
    {
      "indent": 3,
      "text": "The following notations are used in this memo.",
      "ja": "次の表記は、このメモで使用されています。"
    },
    {
      "indent": 3,
      "text": "password A shared, secret, and potentially low-entropy word, phrase, code, or key used as a credential to mutually authenticate the peers. It is not restricted to characters in a human language.",
      "ja": "パスワードAは秘密、共有、および潜在的に低エントロピーの単語、フレーズ、コード、または相互にピアを認証するために証明書として使用されるキー。それは、人間の言語の文字に制限されていません。"
    },
    {
      "indent": 3,
      "text": "a | b denotes concatenation of bit string \"a\" with bit string \"b\".",
      "ja": "| （b）は、ビット列「」ビット列と「B」の連結を示しています。"
    },
    {
      "indent": 3,
      "text": "len(a) indicates the length in bits of the bit string \"a\".",
      "ja": "LEN（a）はビット列「A」のビットの長さを示しています。"
    },
    {
      "indent": 3,
      "text": "lsb(a) returns the least-significant bit of the bit string \"a\".",
      "ja": "LSB（a）は、ビット列「A」の最下位ビットを返します。"
    },
    {
      "indent": 3,
      "text": "lgr(a,b) takes \"a\" and a prime, \"b\", and returns the Legendre symbol (a/b).",
      "ja": "LGR（a、b）は、 \"B\"、 \"A\" と素数をとり、ルジャンドル記号を返す（/ B）。"
    },
    {
      "indent": 3,
      "text": "min(a,b) returns the lexicographical minimum of strings \"a\" and \"b\", or zero (0) if \"a\" equals \"b\".",
      "ja": "分（a、b）は \"a\" と \"b\" の文字列の辞書式に最小値を返す、またはゼロ（0） \"\" \"B\" に等しい場合。"
    },
    {
      "indent": 3,
      "text": "max(a,b) returns the lexicographical maximum of strings \"a\" and \"b\", or zero (0) if \"a\" equals \"b\".",
      "ja": "MAX（a、b）は、文字列の辞書式最大 \"a\" および \"b\" を返し、またはゼロ（0） \"\" \"B\" に等しい場合。"
    },
    {
      "indent": 3,
      "text": "The convention for this memo is to represent an element in a finite cyclic group with an uppercase letter or acronym, while a scalar is indicated with a lowercase letter or acronym. An element that represents a point on an elliptic curve has an implied composite nature -- i.e., it has both an x- and y-coordinate.",
      "ja": "スカラーは、小文字または頭字語で示されている間、このメモのための規則は、大文字または頭字語で有限巡回群の要素を表すためです。楕円曲線上の点を表す要素は暗黙の複合的な性質を有している - すなわち、それは、xとy座標の両方を有します。"
    },
    {
      "indent": 0,
      "text": "1.2.2. Resistance to Dictionary Attack",
      "section_title": true,
      "ja": "1.2.2。辞書攻撃への抵抗"
    },
    {
      "indent": 3,
      "text": "Resistance to dictionary attack means that any advantage an adversary can gain must be directly related to the number of interactions she makes with an honest protocol participant and not through computation. The adversary will not be able to obtain any information about the password except whether a single guess from a protocol run is correct or incorrect.",
      "ja": "辞書攻撃に対する耐性は、敵対者が得ることができます任意の利点は、直接、彼女は正直なプロトコルの参加者ではなく計算により行い相互作用の数に関連していなければならないことを意味しています。敵は、プロトコルの実行から単一の推測が正しいか間違っているかどうかを除いて、パスワードに関する情報を入手することができません。"
    },
    {
      "indent": 0,
      "text": "2. Discrete Logarithm Cryptography",
      "section_title": true,
      "ja": "2.離散対数暗号"
    },
    {
      "indent": 3,
      "text": "Dragonfly uses discrete logarithm cryptography to achieve authentication and key agreement (see [SP800-56A]). Each party to the exchange derives ephemeral keys with respect to a particular set of domain parameters (referred to here as a \"group\"). A group can be based on Finite Field Cryptography (FFC) or Elliptic Curve Cryptography (ECC).",
      "ja": "トンボは、（[SP800-56A]を参照）認証と鍵の合意を達成するための離散対数暗号を使用しています。為替への各当事者は、（「グループ」としてここに呼ばれる）ドメインパラメータの特定のセットに関してはかないキーを導出します。グループは、有限フィールド暗号（FFC）や楕円曲線暗号（ECC）に基づくことができます。"
    },
    {
      "indent": 3,
      "text": "Three operations are defined for both types of groups:",
      "ja": "3つの操作は、グループの両方のタイプのために定義されています。"
    },
    {
      "indent": 3,
      "text": "o \"scalar operation\" -- takes a scalar and an element in the group to produce another element -- Z = scalar-op(x, Y).",
      "ja": "O「スカラー演算は、」 -  Z =スカラーOP（X、Y） - スカラーと別の要素を生成するために、グループ内の要素をとります。"
    },
    {
      "indent": 3,
      "text": "o \"element operation\" -- takes two elements in the group to produce a third -- Z = element-op(X, Y).",
      "ja": "O「要素動作は、」 -  Z =要素-OP（X、Y） - 三分の一を生成するために、グループ内の2つの要素をとります。"
    },
    {
      "indent": 3,
      "text": "o \"inverse operation\" -- takes an element and returns another element such that the element operation on the two produces the identity element of the group -- Y = inverse(X).",
      "ja": "O「逆動作」 - 要素を取り、2つのオン素子動作は、グループの識別要素生成するように別の要素を返し -  Y =インバース（X）を。"
    },
    {
      "indent": 0,
      "text": "2.1. Elliptic Curve Cryptography",
      "section_title": true,
      "ja": "2.1。楕円曲線暗号"
    },
    {
      "indent": 3,
      "text": "Domain parameters for the ECC groups used by Dragonfly are:",
      "ja": "トンボで使用されるECCグループのドメインパラメータは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o A prime, p, determining a prime field GF(p). The cryptographic group will be a subgroup of the full elliptic curve group that consists of points on an elliptic curve -- elements from GF(p) that satisfy the curve's equation -- together with the \"point at infinity\" that serves as the identity element. The group operation for ECC groups is addition of points on the elliptic curve.",
      "ja": "素体GF（p）を決定素数、P、O。 GFの要素（P）の曲線の式を満たす -   - 識別素子として「無限遠点」と一緒に暗号化グループは、楕円曲線上の点で構成され、完全な楕円曲線群のサブグループであろう。 ECCグループのグループ操作は、楕円曲線上の点の加算です。"
    },
    {
      "indent": 3,
      "text": "o Elements a and b from GF(p) that define the curve's equation. The point (x, y) in GF(p) x GF(p) is on the elliptic curve if and only if (y^2 - x^3 - a*x - b) mod p equals zero (0).",
      "ja": "曲線の方程式を定義GF（P）からO要素AおよびB。 GF（p）×GF（p）内の点（x、y）は、楕円曲線上にある場合にのみ（Y ^ 2  -  X ^ 3  -  A * X  -  B）MOD pがゼロに等しい（0）。"
    },
    {
      "indent": 3,
      "text": "o A point, G, on the elliptic curve, which serves as a generator for the ECC group. G is chosen such that its order, with respect to elliptic curve addition, is a sufficiently large prime.",
      "ja": "O点、G、ECCグループの発電機として機能する楕円曲線上。 Gは、その順序は、楕円曲線加算に対して、十分に大きな素数であるように選択されます。"
    },
    {
      "indent": 3,
      "text": "o A prime, q, which is the order of G, and thus is also the size of the cryptographic subgroup that is generated by G.",
      "ja": "OこうしてGのオーダーであり、素数、qは、Gによって生成された暗号化サブグループのサイズでもあります"
    },
    {
      "indent": 3,
      "text": "An (x,y) pair is a valid ECC element if: 1) the x- and y-coordinates are both greater than zero (0) and less than the prime defining the underlying field; and, 2) the x- and y-coordinates satisfy the equation for the curve and produce a valid point on the curve that is not the point at infinity. If either one of those conditions do not hold, the (x,y) pair is not a valid element.",
      "ja": "（x、y）の対があれば、有効なECC素子である：1）x座標とy座標の両方（0）ゼロより大きく、基本フィールドを定義する素数未満です。および、2）x座標とy座標は、曲線の方程式を満たし、無限遠点ではない曲線上有効なポイントを生成します。これらの条件のいずれかが成立しない場合は、（x、y）の対が有効な要素ではありません。"
    },
    {
      "indent": 3,
      "text": "The scalar operation is addition of a point on the curve with itself a number of times. The point Y is multiplied x times to produce another point Z:",
      "ja": "スカラー演算は、回数自体の曲線上の点の加算です。点Yは、別の点Zを生成するためにX回乗算されます。"
    },
    {
      "indent": 6,
      "text": "Z = scalar-op(x, Y) = x*Y",
      "ja": "Z =スカラー-OP（X、Y）= X * Y"
    },
    {
      "indent": 3,
      "text": "The element operation is addition of two points on the curve. Points X and Y are summed to produce another point Z:",
      "ja": "素子動作は、曲線上の2点の追加です。点XとYは、別の点Zを生成するために合計されます。"
    },
    {
      "indent": 6,
      "text": "Z = element-op(X, Y) = X + Y",
      "ja": "Z =エレメント-OP（X、Y）= X + Y"
    },
    {
      "indent": 3,
      "text": "The inverse function is defined such that the sum of an element and its inverse is \"0\", the point at infinity of an elliptic curve group:",
      "ja": "逆関数は、要素の和とその逆数が「0」、楕円曲線群の無限遠点であるように定義されます。"
    },
    {
      "indent": 6,
      "text": "R + inverse(R) = \"0\"",
      "ja": "R +の逆（R）= \"0\""
    },
    {
      "indent": 3,
      "text": "Elliptic curve groups require a mapping function, q = F(Q), to convert a group element to an integer. The mapping function used in this memo returns the x-coordinate of the point it is passed.",
      "ja": "楕円曲線グループは、整数にグループ要素を変換するために、Q = F（Q）、マッピング機能を必要とします。このメモで使用されるマッピング関数は、渡された点のx座標を返します。"
    },
    {
      "indent": 3,
      "text": "scalar-op(x, Y) can be viewed as x iterations of element-op() by defining:",
      "ja": "スカラー-OP（X、Y）を定義することにより、素子-OP（）のx反復とみなすことができます。"
    },
    {
      "indent": 6,
      "text": "Y = scalar-op(1, Y)",
      "ja": "Y =スカラー-OP（1、Y）"
    },
    {
      "indent": 6,
      "text": "Y = scalar-op(x, Y) = element-op(Y, scalar-op(x-1, Y)), for x > 1",
      "ja": "Y =スカラー-OP（X、Y）=  - オン元素（Y、スカラーの（X-1、Y））、X> 1"
    },
    {
      "indent": 3,
      "text": "A definition of how to add two points on an elliptic curve (i.e., element-op(X, Y)) can be found in [RFC6090].",
      "ja": "楕円曲線（すなわち、要素-OP（X、Y））上の2点を追加する方法の定義は、[RFC6090]に見出すことができます。"
    },
    {
      "indent": 3,
      "text": "Note: There is another elliptic curve domain parameter, a cofactor, h, that is defined by the requirement that the size of the full elliptic curve group (including \"0\") be the product of h and q. Elliptic curve groups used with Dragonfly authentication MUST have a cofactor of one (1).",
      "ja": "注：完全な楕円曲線群の大きさをhとqの積である（「0」を含む）の要件によって定義される他の楕円曲線ドメインパラメータ、補因子、Hがあります。トンボ認証で使用される楕円曲線基は、1つ（1）の補因子がなければなりません。"
    },
    {
      "indent": 0,
      "text": "2.2. Finite Field Cryptography",
      "section_title": true,
      "ja": "2.2。有限フィールド暗号化"
    },
    {
      "indent": 3,
      "text": "Domain parameters for the FFC groups used in Dragonfly are:",
      "ja": "トンボに使用されるFFCグループのドメインパラメータは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o A prime, p, determining a prime field GF(p), the integers modulo p. The FFC group will be a subgroup of GF(p)*, the multiplicative group of non-zero elements in GF(p). The group operation for FFC groups is multiplication modulo p.",
      "ja": "素数、P O、素体GF（p）を決定し、整数Pを法。 FFC基はGF（P）のサブグループになり*、GFにおける非零要素の乗法群（P）。 FFCグループのグループ操作は、乗算剰余Pです。"
    },
    {
      "indent": 3,
      "text": "o An element, G, in GF(p)* which serves as a generator for the FFC group. G is chosen such that its multiplicative order is a sufficiently large prime divisor of ((p-1)/2).",
      "ja": "FFCグループのジェネレータとして機能GF（P）の要素、G、* O。 Gはその乗法順序は（（P-1）/ 2）の十分に大きな素数除数であるように選択されます。"
    },
    {
      "indent": 3,
      "text": "o A prime, q, which is the multiplicative order of G, and thus also the size of the cryptographic subgroup of GF(p)* that is generated by G.",
      "ja": "OこうしてGF（p）の暗号サブグループのサイズもGの乗法オーダーであり、素数、qが、*それはGで生成され"
    },
    {
      "indent": 3,
      "text": "A number is a valid element in an FFC group if: 1) it is between one (1) and one (1) less than the prime, p, exclusive (i.e., 1 < element < p-1); and, 2) if modular exponentiation of the element by the group order, q, equals one (1). If either one of those conditions do not hold, the number is not a valid element.",
      "ja": "1）それは間の1つ（1）と1（1）プライム、P、排他的（すなわち、1 <要素<P-1）未満である。あれば数はFFCグループ内の有効な要素でありますおよび、2）グループの順序、Qによって素子のべき乗剰余が1に等しい場合（1）。これらのいずれかの条件が満たされていない場合、番号は有効な要素ではありません。"
    },
    {
      "indent": 3,
      "text": "The scalar operation is exponentiation of a generator modulo a prime. An element Y is taken to the x-th power modulo the prime returning another element, Z:",
      "ja": "スカラ演算は、プライム剰余発電機の累乗です。 Yは、x乗するものと解釈される要素が別の要素、Zを返す素数を法。"
    },
    {
      "indent": 6,
      "text": "Z = scalar-op(x, Y) = Y^x mod p",
      "ja": "Z =スカラー-OP（X、Y）= Y ^ X MOD P"
    },
    {
      "indent": 3,
      "text": "The element operation is modular multiplication. Two elements, X and Y, are multiplied modulo the prime returning another element, Z:",
      "ja": "素子動作は、剰余乗算です。二つの要素、X及びYは、他の元素、Zを返す素数を法として乗算されます。"
    },
    {
      "indent": 6,
      "text": "Z = element-op(X, Y) = (X * Y) mod p",
      "ja": "Z =エレメント-OP（X、Y）=（X * Y）MOD P"
    },
    {
      "indent": 3,
      "text": "The inverse function for a MODP group is defined such that the product of an element and its inverse modulo the group prime equals one (1). In other words,",
      "ja": "MODPグループの逆関数は、要素とグループプライムモジュロその逆数の積が1に等しいように定義されている（1）。言い換えると、"
    },
    {
      "indent": 6,
      "text": "(R * inverse(R)) mod p = 1",
      "ja": "（R *反転（R））MOD p = 1"
    },
    {
      "indent": 0,
      "text": "3. The Dragonfly Key Exchange",
      "section_title": true,
      "ja": "3.トンボ鍵交換"
    },
    {
      "indent": 3,
      "text": "There are two parties to the Dragonfly exchange named, for convenience and by convention, Alice and Bob. The two parties have a shared password that was established in an out-of-band mechanism, and they both agree to use a particular domain parameter set (either ECC or FFC). In the Dragonfly exchange, both Alice and Bob share an identical view of the shared password -- i.e., it is not \"augmented\", where one side holds a password and the other side holds a non-invertible verifier. This allows Dragonfly to be used in traditional client-server protocols and also in peer-to-peer applications in which there are not fixed roles and either party may initiate the exchange (and both parties may implement it simultaneously).",
      "ja": "便宜上、コンベンション、アリスとボブによって名前のトンボ交換には2人の当事者が、あります。両当事者は、アウトオブバンドメカニズムに設立された共有パスワードを持っている、と彼らは両方の特定のドメインパラメータセット（ECCまたはFFCのいずれか）を使用することに同意します。即ち、それは「拡張」されていない、一の側がパスワードを保持し、他方の面が非可逆検証を保持する - トンボ交換において、アリスとボブの両方は、共有パスワードの同じビューを共有します。これは、トンボは、従来のクライアントサーバプロトコルにもそこの役割を固定されておらず、いずれかの当事者が交換を開始することができる（そして、両者が同時にそれを実装すること）したピア・ツー・ピアアプリケーションで使用することができます。"
    },
    {
      "indent": 3,
      "text": "Prior to beginning the Dragonfly exchange, the two peers MUST derive a secret element in the chosen domain parameter set. Two \"hunting-and-pecking\" techniques to determine a secret element, one for ECC and one for FFC, are described in Section 3.2, but any secure, deterministic method that is agreed upon can be used. For instance, the technique described in [hash2ec] can be used for ECC groups.",
      "ja": "トンボの交換を開始する前に、2つのピアが選択したドメインパラメータセットでの秘密の要素を導出しなければなりません。秘密の要素を決定するために2つの「狩猟と-つつき」技術、ECC用とFFCのための1つは、3.2節で説明されているが、合意されている任意の安全な、決定論的方法を用いることができます。例えば、[hash2ec]に記載された技術は、ECCグループのために使用することができます。"
    },
    {
      "indent": 3,
      "text": "The Dragonfly exchange consists of two message exchanges, a \"Commit Exchange\" in which both sides commit to a single guess of the password, and a \"Confirm Exchange\" in which both sides confirm knowledge of the password. A side effect of running the Dragonfly exchange is an authenticated, shared, and secret key whose cryptographic strength is set by the agreed-upon group.",
      "ja": "トンボ交換は2回のメッセージ交換で構成されて、その両側には、パスワードの単一の推測にコミットし、双方がパスワードの知識を確認する「交流の確認」の「Exchangeをコミット」。トンボ交換を実行するの副作用は、その暗号強度合意されたグループによって設定され、認証された共有秘密鍵です。"
    },
    {
      "indent": 3,
      "text": "Dragonfly uses a random function, H(), a mapping function, F(), and a key derivation function, KDF().",
      "ja": "トンボは、ランダム関数H（）、マッピング関数F（）、および鍵導出関数KDFを使用して（）。"
    },
    {
      "indent": 0,
      "text": "3.1. Assumptions",
      "section_title": true,
      "ja": "3.1。仮定"
    },
    {
      "indent": 3,
      "text": "In order to avoid attacks on the Dragonfly protocol, some basic assumptions are made:",
      "ja": "トンボプロトコルへの攻撃を避けるために、いくつかの基本的な仮定が行われます。"
    },
    {
      "indent": 3,
      "text": "1. Function H is a \"random oracle\" (see [RANDOR]) that maps a binary string of indeterminate length onto a fixed binary string that is x bits in length.",
      "ja": "1.関数Hは、長さXビットである固定バイナリ文字列に不定長のバイナリ列をマッピング「ランダムオラクル」（[RANDOR]参照します）。"
    },
    {
      "indent": 10,
      "text": "H: {0,1}^* --> {0,1}^x",
      "ja": "H：{0,1} ^ *  - > {0,1} ^ X"
    },
    {
      "indent": 3,
      "text": "2. Function F is a mapping function that takes an element in a group and returns an integer. For ECC groups, function F() returns the x-coordinate of the element (which is a point on the elliptic curve); for FFC groups, function F() is the identity function (since all elements in an FFC group are already integers less than the prime).",
      "ja": "2.関数Fは、グループ内の要素を取得し、整数を返すマッピング関数です。 ECCグループ、関数F（）のX座標（楕円曲線上の点である）元素のを返します。 FFCグループ、機能F（）のための恒等関数（FFCグループ内のすべての要素がすでにプライム未満の整数であるため）です。"
    },
    {
      "indent": 10,
      "text": "ECC: x = F(P), where P=(x,y)",
      "ja": "ECC：X = F（P）、ここで、P =（x、y）は"
    },
    {
      "indent": 10,
      "text": "FFC: x = F(x)",
      "ja": "FFC：X = F（X）"
    },
    {
      "indent": 3,
      "text": "3. Function KDF is a key derivation function (see, for instance, [SP800-108]) that takes a key to stretch, k, a label to bind to the key, label, and an indication of the desired output, n:",
      "ja": "3.関数KDFは、Kを伸ばすためのキーをとる鍵導出関数（例えば、参照、[SP800-108]）であり、ラベルは、キー、ラベルに結合し、所望の出力の表示、Nします。"
    },
    {
      "indent": 10,
      "text": "stretch = KDF-n(k, label)",
      "ja": "ストレッチ= KDF-N（K、ラベル）"
    },
    {
      "indent": 7,
      "text": "so that len(stretch) equals n.",
      "ja": "その結果、LEN（ストレッチ）は、nに等しいです。"
    },
    {
      "indent": 3,
      "text": "4. The discrete logarithm problem for the chosen group is hard. That is, given G, P, and Y = G^x mod p, it is computationally infeasible to determine x. Similarly, for an ECC group given the curve definition, a generator G, and Y = x * G, it is computationally infeasible to determine x.",
      "ja": "4.選択したグループのための離散対数問題が困難です。つまり、G与えられ、Pであり、そしてY = G ^ Xのmod Pは、Xを決定する計算上実行不可能です。同様に、ECCグループについての曲線の定義、ジェネレータGを与え、そしてY = X * Gは、それがXを決定する計算上実行不可能です。"
    },
    {
      "indent": 3,
      "text": "5. There exists a pool of passwords from which the password shared by the two peers is drawn. This pool can consist of words from a dictionary, for example. Each password in this pool has an equal probability of being the shared password. All potential attackers have access to this pool of passwords.",
      "ja": "5. 2つのピアで共有パスワードが描かれているから、パスワードのプールが存在します。このプールは、例えば、辞書から単語で構成されます。このプール内の各パスワードは、共有パスワードであることの等しい確率を持っています。すべての潜在的な攻撃者は、パスワードのこのプールへのアクセス権を持っています。"
    },
    {
      "indent": 3,
      "text": "6. The peers have the ability to produce quality random numbers.",
      "section_title": true,
      "ja": "6.ピアは、品質の乱数を生成する能力を持っています。"
    },
    {
      "indent": 0,
      "text": "3.2. Derivation of the Password Element",
      "section_title": true,
      "ja": "3.2。パスワード要素の導出"
    },
    {
      "indent": 3,
      "text": "Prior to beginning the exchange of information, the peers MUST derive a secret element, called the Password Element (PE), in the group defined by the chosen domain parameter set. From the point of view of an attacker who does not know the password, the PE will be a random element in the negotiated group. Two examples are described here for completeness, but any method of deterministically mapping a secret string into an element in a selected group can be used -- for instance, the technique in [hash2ec] for ECC groups. If a different technique than the ones described here is used, the secret string SHOULD include the identities of the peers.",
      "ja": "情報の交換を開始する前に、ピアは秘密の要素を導出しなければならない、選択されたドメイン・パラメータ・セットによって定義されたグループで、パスワードエレメント（PE）と呼ばれます。パスワードを知らない攻撃者の観点から、PEは交渉し、グループ内のランダムな要素となります。二つの例は、完全を期すために、ここで説明されているが、確定選択されたグループ内の要素に秘密の文字列をマッピングする任意の方法を使用することができる - 例えば、ECCグループの[hash2ec]で技術。ここで説明するものとは異なる技術が使用されている場合は、秘密の文字列は、ピアのアイデンティティを含むべきです。"
    },
    {
      "indent": 3,
      "text": "To fix the PE, both peers MUST have a common view of the password. If there is any password processing necessary (for example, to support internationalization), the processed password is then used as the shared credential. If either side wants to store a hashed version of the password (hashing the password with random data called a \"salt\"), it will be necessary to convey the salt to the other side prior to commencing the exchange, and the hashed password is then used as the shared credential.",
      "ja": "PEを修正するには、両方のピアは、パスワードの共通のビューを持たなければなりません。 （例えば、国際化をサポートするために）必要なパスワード処理がある場合、処理パスワードは、共有秘密鍵証明書として使用されます。どちらかの側には、パスワードのハッシュ化されたバージョンを保存したい場合、前の交換を開始し、他の側に塩を伝えるために必要となります（「塩」と呼ばれるランダムなデータとパスワードをハッシュ）とハッシュ化されたパスワードがあります共有証明書として使用。"
    },
    {
      "indent": 3,
      "text": "Note: Only one party would be able to maintain a salted password, and this would require that the Dragonfly key exchange be used in a protocol that has strict roles for client (that always initiates) and server (that always responds). Due to the symmetric nature of Dragonfly, salting passwords does not prevent an impersonation attack after compromise of a database of salted passwords.",
      "ja": "注：一つだけのパーティは塩漬けのパスワードを維持することができるだろう、これはトンボの鍵交換は、厳密なクライアントのための役割（つまり、常に開始）とサーバ（つまり常に応答）は、プロトコルで使用されることを必要とします。トンボの対称性のために、パスワードを塩漬けして塩漬けパスワードのデータベースの妥協の後になりすまし攻撃を防ぐことはできません。"
    },
    {
      "indent": 3,
      "text": "The deterministic process to select the PE begins with choosing a secret seed and then performing a group-specific hunting-and-pecking technique -- one for FFC groups and another for ECC groups.",
      "ja": "FFCグループ用とECCグループの別の -  PEを選択するための決定論的プロセスは、秘密シードを選択した後、グループ固有ハンチングアンドつつきの技術を実行することから始まります。"
    },
    {
      "indent": 3,
      "text": "To thwart side-channel attacks that attempt to determine the number of iterations of the hunting-and-pecking loop used to find the PE for a given password, a security parameter, k, is used that ensures that at least k iterations are always performed. The probability that one requires more than n iterations of the hunting-and-pecking loop to find an ECC PE is roughly (q/2p)^n and to find an FFC PE is roughly (q/p)^n, both of which rapidly approach zero (0) as n increases. The security parameter, k, SHOULD be set sufficiently large such that the probability that finding the PE would take more than k iterations is sufficiently small (see Section 4).",
      "ja": "与えられたパスワード、セキュリティパラメータ、kのPEを見つけるために使用ハンチングアンドつつきループの反復回数を決定しようとするサイドチャネル攻撃を阻止するために、少なくともk個の反復が常に実行されることを確実に使用されます。一つのECC PEを見つけるためのハンチングアンドつつきループ以上のN回の反復を必要とする確率はおおよそである（Q / 2P）^ nおよびFFC PEを見つけるためには、N ^（Q / P）おおよそでどちらの急速Nが増加するにつれて、ゼロ（0）に近づきます。セキュリティパラメータ、kは、PEを見つけることはk個の反復以上を取る確率が十分に小さくなるように（セクション4を参照）を十分に大きく設定されてください。"
    },
    {
      "indent": 3,
      "text": "First, an 8-bit counter is set to one (1), and a secret base is computed using the negotiated one-way function with the identities of the two participants, Alice and Bob, the secret password, and the counter:",
      "ja": "まず、8ビットカウンタを1（1）に設定され、秘密基地は2人の参加者、アリスとボブ、秘密のパスワード、およびカウンタのアイデンティティと交渉一方向関数を用いて計算されます。"
    },
    {
      "indent": 3,
      "text": "base = H(max(Alice,Bob) | min(Alice,Bob) | password | counter)",
      "ja": "ベース= H（MAX（アリス、ボブ）|分（アリス、ボブ）|パスワード|カウンタ）"
    },
    {
      "indent": 3,
      "text": "The identities are passed to the max() and min() functions to provide the necessary ordering of the inputs to H() while still allowing for a peer-to-peer exchange where both Alice and Bob each view themselves as the \"initiator\" of the exchange.",
      "ja": "同一性は、MAX（）および分（）H（）への入力の必要な順序を提供するために、関数に渡され、まだアリスとボブの両方は、それぞれ、「イニシエータ」として自分自身を表示するピア・ツー・ピア交換を可能にしながら為替の。"
    },
    {
      "indent": 3,
      "text": "The base is then stretched using the technique from Section B.5.1 of [FIPS186-4]. The key derivation function, KDF, is used to produce a bitstream whose length is equal to the length of the prime from the group's domain parameter set plus the constant sixty-four (64) to derive a temporary value, and the temporary value is modularly reduced to produce a seed:",
      "ja": "塩基は、次いで、[FIPS186-4]のセクションB.5.1からの技術を用いて延伸されます。鍵導出関数KDFは、一時的な値を導出するために、長さがグループのドメインパラメータセットからプライムプラス定数64個の長さに等しいビットストリームを生成するために使用され、そして一時的な値は、モジュール式であります種子を生産するために減少："
    },
    {
      "indent": 3,
      "text": "n = len(p) + 64",
      "ja": "N = LEN（P）+ 64"
    },
    {
      "indent": 3,
      "text": "temp = KDF-n(base, \"Dragonfly Hunting and Pecking\")",
      "ja": "TEMP = KDF-N（ベース、 \"トンボ狩猟とつつき\"）"
    },
    {
      "indent": 3,
      "text": "seed = (temp mod (p - 1)) + 1",
      "ja": "シード=（一時MOD（P  -  1））+ 1"
    },
    {
      "indent": 3,
      "text": "The string bound to the derived temporary value is for illustrative purposes only. Implementations of the Dragonfly key exchange SHOULD use a usage-specific label with the KDF.",
      "ja": "得られた仮の値にバインドされた文字列は、説明のみを目的としています。トンボ鍵交換の実装はKDFでの使用に固有のラベルを使用すべきです。"
    },
    {
      "indent": 3,
      "text": "Note: The base is stretched to 64 more bits than are needed so that the bias from the modular reduction is not so apparent.",
      "ja": "注：モジュラー減少からバイアスがそれほど明らかでないように塩基が必要とされるよりも64以上のビットに延伸されます。"
    },
    {
      "indent": 3,
      "text": "The seed is then passed to the group-specific hunting-and-pecking technique.",
      "ja": "種子は、グループ固有のハンチングアンド盗み技術に渡されます。"
    },
    {
      "indent": 3,
      "text": "If the protocol performing the Dragonfly exchange has the ability to exchange random nonces, those SHOULD be added to the computation of the base to ensure that each run of the protocol produces a different PE.",
      "ja": "トンボ交換を行うプロトコルは、ランダムなノンスを交換する能力を有する場合、それらは、プロトコルの各実行は、異なるPEを生成することを保証するために、ベースの計算に加えられるべきです。"
    },
    {
      "indent": 0,
      "text": "3.2.1. Hunting and Pecking with ECC Groups",
      "section_title": true,
      "ja": "3.2.1。 ECCグループと狩猟とつつき"
    },
    {
      "indent": 3,
      "text": "The ECC-specific hunting-and-pecking technique entails looping until a valid point on the elliptic curve has been found. The seed is used as an x-coordinate with the equation of the curve to check whether x^3 + a*x + b is a quadratic residue modulo p. If it is not, then the counter is incremented, a new base and new seed are generated, and the hunting and pecking continues. If it is a quadratic residue modulo p, then the x-coordinate is assigned the value of seed and the current base is stored. When the hunting-and-pecking loop terminates, the x-coordinate is used with the equation of the curve to solve for a y-coordinate. An ambiguity exists since two values for the y-coordinate would be valid, and the low-order bit of the stored base is used to unambiguously determine the correct y-coordinate. The resulting (x,y) pair becomes the Password Element, PE.",
      "ja": "ECC特有の狩猟 - と - つつき技術は、楕円曲線上の有効なポイントが発見されるまでループ伴います。シードは以下のように使用されるX ^ 3 + A * X + bは平方剰余モジュロPであるかどうかを確認するために、曲線の式でx座標。そうでない場合は、カウンタがインクリメントされ、新しいベースと新しいシードが生成され、狩猟とつつきは継続されています。それは平方剰余モジュロPである場合、シードの値が割り当てられ、X座標と現在のベースが格納されています。狩猟アンドつつきループが終了すると、y座標を求めるために、曲線の式で使用されるx座標。曖昧さがy座標のための2つの値が有効となり、そして保存された塩基の下位ビットが明確に正しいy座標を決定するために使用されるために存在します。得られた（x、y）のペアは、PE、パスワード要素となります。"
    },
    {
      "indent": 3,
      "text": "Algorithmically, the process looks like this:",
      "ja": "アルゴリズム的に、プロセスは次のようになります。"
    },
    {
      "indent": 8,
      "text": "found = 0\ncounter = 1\nn = len(p) + 64\ndo {\n  base = H(max(Alice,Bob) | min(Alice,Bob) | password | counter)\n  temp = KDF-n(base, \"Dragonfly Hunting And Pecking\")\n  seed = (temp mod (p - 1)) + 1\n  if ( (seed^3 + a*seed + b) is a quadratic residue mod p)\n  then\n    if ( found == 0 )\n    then\n      x = seed\n      save = base\n      found = 1\n    fi\n  fi\n  counter = counter + 1\n} while ((found == 0) || (counter <= k))\ny = sqrt(x^3 + ax + b)\nif ( lsb(y) == lsb(save) )\nthen\n  PE = (x,y)\nelse\n  PE = (x,p-y)\nfi",
      "raw": true
    },
    {
      "indent": 20,
      "text": "Figure 1: Fixing PE for ECC Groups",
      "ja": "図1：ECCグループに対するPEを修正"
    },
    {
      "indent": 3,
      "text": "Checking whether a value is a quadratic residue modulo a prime can leak information about that value in a side-channel attack. Therefore, it is RECOMMENDED that the technique used to determine if the value is a quadratic residue modulo p blind the value with a random number so that the blinded value can take on all numbers between 1 and p-1 with equal probability while not changing its quadratic residuosity. Determining the quadratic residue in a fashion that resists leakage of information is handled by flipping a coin and multiplying the blinded value by either a random quadratic residue or a random quadratic nonresidue and checking whether the multiplied value is a quadratic residue (qr) or a quadratic nonresidue (qnr) modulo p, respectively. The random residue and nonresidue can be calculated prior to hunting and pecking by calculating the Legendre symbol on random values until they are found:",
      "ja": "値は、サイドチャネル攻撃にその値に関する情報を漏洩することができる素数を法とする平方剰余であるかどうかをチェックします。したがって、値は変化しないが、盲検値が等しい確率で1とp-1との間のすべての数値を取ることができるように、平方剰余モジュロpが乱数との値をブラインドである場合に使用される技術を決定することが推奨され、その二次residuosity。情報の漏洩に抵抗する方法で平方剰余を決定するコインを反転し、ランダム平方剰余又はランダム二次nonresidueいずれかによって盲目値を乗算し、乗算値は、平方剰余（QR）又は二次であるか否かをチェックすることによって処理されますそれぞれnonresidue（QNR）モジュロP、。彼らが発見されるまで、ランダム残基とnonresidueはランダムな値にルジャンドル記号を計算することによって、従来狩猟とつつきに計算することができます。"
    },
    {
      "indent": 6,
      "text": "do { qr = random() mod p } while ( lgr(qr, p) != 1)",
      "ja": "実行{QR =ランダム（）MOD P}ながら（LGR（QR、P）！= 1）"
    },
    {
      "indent": 6,
      "text": "do { qnr = random() mod p } while ( lgr(qnr, p) != -1)",
      "ja": "{QNR =ランダム（）MOD P}を行いながら（LGR（QNR、P）！= -1）"
    },
    {
      "indent": 3,
      "text": "Algorithmically, the masking technique to find out whether or not a value is a quadratic residue looks like this:",
      "ja": "アルゴリズム的に、値が平方剰余であるかどうかを調べるためにマスキング技術は次のようになります。"
    },
    {
      "indent": 6,
      "text": "is_quadratic_residue (val, p) { r = (random() mod (p - 1)) + 1 num = (val * r * r) mod p if ( lsb(r) == 1 ) num = (num * qr) mod p if ( lgr(num, p) == 1) then return TRUE fi else num = (num * qnr) mod p if ( lgr(num, p) == -1) then return TRUE fi fi return FALSE }",
      "ja": "is_quadratic_residue（ヴァル、P）{R =（ランダム（）MOD（P  -  1））+ = 1 NUM（ヴァル*のR * rの）MOD P IF（LSB（R）== 1）NUM =（num個の*のQR） MOD P IF（LGR（NUM、P）== 1）、次いで（LGR（NUM、P）== -1）をTRUEのfi Fiの戻りFALSEを返す場合} TRUE Fiの他NUM =（NUM * QNR）MOD Pを返します"
    },
    {
      "indent": 0,
      "text": "3.2.2. Hunting and Pecking with MODP Groups",
      "section_title": true,
      "ja": "3.2.2。 MODPグループでの狩猟とつつき"
    },
    {
      "indent": 3,
      "text": "The MODP-specific hunting-and-pecking technique entails finding a random element which, when used as a generator, will create a group with the same order as the group created by the generator from the domain parameter set. The secret generator is found by exponentiating the seed to the value ((p-1)/q), where p is the prime and q is the order from the domain parameter set. If that value is greater than one (1), it becomes the PE; otherwise, the counter is incremented, a new base and seed are generated, and the hunting and pecking continues.",
      "ja": "MODP特異ハンチングアンドつつき技術は、発電機として使用する場合、ドメインパラメータセットからジェネレータによって作成されたグループと同じ順序でグループを作成し、ランダムな要素を見つけることを伴います。秘密発生器は、pは素数であり、q値（（P-1）/ Q）にシードを累乗することによって見出されるドメインパラメータセットからの注文です。その値が1（1）よりも大きい場合、それはPEなります。そうでない場合、カウンタは、新しいベースとシードが生成され、インクリメントされ、狩猟とつつきが継続します。"
    },
    {
      "indent": 3,
      "text": "Algorithmically, the process looks like this:",
      "ja": "アルゴリズム的に、プロセスは次のようになります。"
    },
    {
      "indent": 6,
      "text": "found = 0 counter = 1 n = len(p) + 64 do { base = H(max(Alice,Bob) | min(Alice,Bob) | password | counter) temp = KDF-n(seed, \"Dragonfly Hunting And Pecking\") seed = (temp mod (p - 1)) + 1 temp = seed ^ ((p-1)/q) mod p if (temp > 1) then if (not found) PE = temp found = 1 fi fi counter = counter + 1 } while ((found == 0) || (counter <= k))",
      "ja": "見出さ= 0カウンタ= 1からn = LEN（P）+ 64行う{塩基= H（MAX（アリス、ボブ）|分（アリス、ボブ）|パスワード|カウンタ）TEMP = KDF-N（シード、「トンボ狩猟盗み」）シード=（一時MOD（P  -  1））+ 1つのTEMP =シード^（（P-1）/ Q）MOD Pなら= 1 Fiが見出さ（TEMP> 1）をIF（見つかりません）PE = TEMP Fiのカウンタ=カウント+ 1}（（見出さ== 0）||（カウンタ<= K））、一方"
    },
    {
      "indent": 20,
      "text": "Figure 2: Fixing PE for MODP Groups",
      "ja": "図2：MODPグループのためのPEを修正"
    },
    {
      "indent": 0,
      "text": "3.3. The Commit Exchange",
      "section_title": true,
      "ja": "3.3。コミット交換"
    },
    {
      "indent": 3,
      "text": "In the Commit Exchange, both sides commit to a single guess of the password. The peers generate a scalar and an element, exchange them with each other, and process the other's scalar and element to generate a common and shared secret.",
      "ja": "コミット取引所では、両側には、パスワードの単一の推測にコミットします。ピアは、スカラーと要素を生成お互いにそれらを交換し、共通の共有シークレットを生成するの他のスカラ要素を処理します。"
    },
    {
      "indent": 3,
      "text": "First, each peer generates two random numbers, private and mask that are each greater than one (1) and less than the order from the selected domain parameter set:",
      "ja": "まず、各ピアは、選択された各領域パラメータセットから順に比べ（1）及び1未満の大きい2つの乱数、プライベートマスクを生成します。"
    },
    {
      "indent": 6,
      "text": "1 < private < q 1 < mask < q",
      "ja": "1 <プライベート<Q 1 <マスク<Q"
    },
    {
      "indent": 3,
      "text": "These two secrets and the Password Element are then used to construct the scalar and element:",
      "ja": "これら二つの秘密とパスワード要素は、その後、スカラーや要素を構築するために使用されています。"
    },
    {
      "indent": 9,
      "text": "scalar = (private + mask) modulo q\nElement = inverse(scalar-op(mask, PE))",
      "raw": true
    },
    {
      "indent": 3,
      "text": "If the scalar is less than two (2), the private and mask MUST be thrown away and new values generated. Once a valid scalar and Element are generated, the mask is no longer needed and MUST be irretrievably destroyed.",
      "ja": "スカラーは2未満である場合（2）、プライベートとマスクを捨てなければなりません、そして、新しい値が生成されます。有効なスカラーと要素が生成されると、マスクは不要であり、取り返しのつかないほど破壊されなければなりません。"
    },
    {
      "indent": 3,
      "text": "The peers exchange their scalar and Element and check the peer's scalar and Element, deemed peer-scalar and Peer-Element. If the peer has sent an identical scalar and Element -- i.e., if scalar equals peer-scalar and Element equals Peer-Element -- it is sign of a reflection attack, and the exchange MUST be aborted. If the values differ, peer-scalar and Peer-Element must be validated. For the peer-scalar to be valid, it MUST be between 1 and q exclusive. Validation of the Peer-Element depends on the type of cryptosystem -- validation of an (x,y) pair as an ECC element is specified in Section 2.1, and validation of a number as an FFC element is specified in Section 2.2. If either the peer-scalar or Peer-Element fail validation, then the exchange MUST be terminated and authentication fails. If both the peer-scalar and Peer-Element are valid, they are used with the Password Element to derive a shared secret, ss:",
      "ja": "ピアはそのスカラーとエレメントを交換し、ピアのスカラーと要素、みなしピア・スカラーおよびピア要素をチェックしてください。ピアが同じスカラーおよび要素を送信した場合 - すなわち、スカラーは、ピア・スカラに等しく、要素がピア要素に等しい場合 - それが反射攻撃の兆候であり、交換が中止されなければなりません。値が異なる場合は、ピア・スカラーおよびピア要素を検証する必要があります。ピアスカラーが有効であるためには、1とq排他的でなければなりません。ピア要素の検証は、暗号システムのタイプに依存する - （x、y）の対の検証をECC要素はセクション2.1で指定され、FFC要素として数の検証は、セクション2.2で指定されます。ピア・スカラまたはピア要素のいずれかが検証に失敗した場合は、交換が終了し、認証が失敗しなければなりません。ピア・スカラーおよびピア要素の両方が有効である場合、それらは、SSを共有秘密を導出するためにパスワード要素で使用されています。"
    },
    {
      "indent": 12,
      "text": "ss = F(scalar-op(private,\n                 element-op(peer-Element,\n                            scalar-op(peer-scalar, PE))))",
      "raw": true
    },
    {
      "indent": 3,
      "text": "To enforce key separation and cryptographic hygiene, the shared secret is stretched into two subkeys -- a key confirmation key, kck, and a master key, mk. Each of the subkeys SHOULD be at least the length of the prime used in the selected group.",
      "ja": "キー確認キー、KCK、およびマスターキー、MK  - キー分離と暗号衛生を強制するには、共有秘密は、二つのサブキーに延伸されます。サブキーの各々は、選択されたグループで使用される素数の少なくとも長さでなければなりません。"
    },
    {
      "indent": 9,
      "text": "kck | mk = KDF-n(ss, \"Dragonfly Key Derivation\")",
      "ja": "KCK | MK = KDF-N（SS、 \"トンボキー導出\"）"
    },
    {
      "indent": 3,
      "text": "where n = len(p)*2.",
      "ja": "ここで、n = LEN（P）* 2。"
    },
    {
      "indent": 0,
      "text": "3.4. The Confirm Exchange",
      "section_title": true,
      "ja": "3.4。確認交換"
    },
    {
      "indent": 3,
      "text": "In the Confirm Exchange, both sides confirm that they derived the same secret, and therefore, are in possession of the same password.",
      "ja": "確認取引所では、双方は、彼らが同じ秘密を導出することを確認し、そのため、同じパスワードを所持しています。"
    },
    {
      "indent": 3,
      "text": "The Commit Exchange consists of an exchange of data that is the output of the random function, H(), the key confirmation key, and the two scalars and two elements exchanged in the Commit Exchange. The order of the scalars and elements are: scalars before elements, and sender's value before recipient's value. So from each peer's perspective, it would generate:",
      "ja": "コミットExchangeがランダム関数の出力であるデータの交換から成り、H（）、キー確認キーと、2つのスカラと2つの要素がコミット取引所で交換しました。スカラと要素の順序は以下のとおりです。スカラ前の要素、および受信者の値の前に、送信者の値。したがって、各ピアの観点から、それが生成されます。"
    },
    {
      "indent": 16,
      "text": "confirm = H(kck | scalar | peer-scalar |\n            Element | Peer-Element | <sender-id>)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Where <sender-id> is the identity of the sender of the confirm message. This identity SHALL be that contributed by the sender of the confirm message in generation of the base in Section 3.2.",
      "ja": "ここで、<送信者-id>は、確認メッセージの送信者の身元です。このIDは、3.2節中の塩基の世代で確認メッセージの送信者が寄与しているとされなければなりません。"
    },
    {
      "indent": 3,
      "text": "The two peers exchange these confirmations and verify the correctness of the other peer's confirmation that they receive. If the other peer's confirmation is valid, authentication succeeds; if the other peer's confirmation is not valid, authentication fails.",
      "ja": "2つのピアがこれらの確認を交換し、彼らが受け取る他のピアの確認の正しさを検証します。他のピアの確認が有効であれば、認証が成功します。他のピアの確認が有効でない場合、認証は失敗します。"
    },
    {
      "indent": 3,
      "text": "If authentication fails, all ephemeral state created as part of the particular run of the Dragonfly exchange MUST be irretrievably destroyed. If authentication does not fail, mk can be exported as an authenticated and secret key that can be used by another protocol, for instance IPsec, to protect other data.",
      "ja": "認証が失敗した場合、トンボ交換の特定の実行の一環として作成されたすべてのはかない状態が取り返しのつかないほど破壊されなければなりません。認証が失敗していない場合は、MKは、他のデータを保護するために、例えばIPsecのために、別のプロトコルで使用することができ、認証と秘密鍵としてエクスポートすることができます。"
    },
    {
      "indent": 0,
      "text": "4. Security Considerations",
      "section_title": true,
      "ja": "4.セキュリティについての考慮事項"
    },
    {
      "indent": 3,
      "text": "The Dragonfly exchange requires both participants to have an identical representation of the password. Salting of the password merely generates a new credential -- the salted password -- that must be identically represented on both sides. If an adversary is able to gain access to the database of salted passwords, she would be able to impersonate one side to the other, even if she was unable to determine the underlying, unsalted password.",
      "ja": "トンボ交換は、パスワードの同じ表現を持つように両方の参加者が必要です。塩漬けパスワード -   - 同じように両側に表現されなければならないパスワードの塩漬けは、単に新しい資格を生成します。敵が塩漬けのパスワードのデータベースへのアクセスを得ることが可能であるならば、彼女は基礎となる、無塩パスワードを決定することができませんでした場合でも、他に片側を偽装することができるだろう。"
    },
    {
      "indent": 3,
      "text": "Resistance to dictionary attack means that an adversary must launch an active attack to make a single guess at the password. If the size of the dictionary from which the password was extracted was d, and each password in the dictionary has an equal probability of being chosen, then the probability of success after a single guess is 1/d. After x guesses, and removal of failed guesses from the pool of possible passwords, the probability becomes 1/(d-x). As x grows, so does the probability of success. Therefore, it is possible for an adversary to determine the password through repeated brute-force, active, guessing attacks. Users of the Dragonfly key exchange SHOULD ensure that the size of the pool from which the password was drawn, d, is sufficiently large to make this attack preventable. Implementations of Dragonfly SHOULD support countermeasures to deal with this attack -- for instance, by refusing authentication attempts for a certain amount of time, after the number of failed authentication attempts reaches a certain threshold. No such threshold or amount of time is recommended in this memo.",
      "ja": "辞書攻撃に対する耐性は敵がパスワードで単一の推測をするためにアクティブな攻撃を開始しなければならないことを意味します。パスワードが抽出された辞書の大きさは、Dされた場合、辞書内の各パスワードが選択される等しい確率を有する、単一の推測後の成功の確率は1 / dです。 Xの推測、および可能なパスワードのプールから失敗した推測を除去した後、確率は1 /（D-X）となります。 xが大きくなるにつれて、その成功の確率はありません。敵対者が繰り返しブルートフォース、アクティブ、推測攻撃でパスワードを決定するためにしたがって、それは可能です。トンボ鍵交換のユーザーは、パスワードが描かれたプールのサイズ、dは、この攻撃は予防可能にするのに十分な大きさであることを確認する必要があります。例えば、失敗した認証試行の数が一定のしきい値に達した後、一定時間の認証の試行を拒否することによって - トンボの実装は、この攻撃に対処するための対策をサポートしなければなりません。時間のそのようなしきい値または量は、このメモで推奨されていません。"
    },
    {
      "indent": 3,
      "text": "Due to the problems with using groups that contain a small subgroup, it is RECOMMENDED that implementations of Dragonfly not allow for the specification of a group's complete domain parameter to be sent in-line, but instead use a common repository and pass an identifier to a domain parameter set whose strength has been rigorously proven and that does not have small subgroups. If a group's complete domain parameter set is passed in-line, it SHOULD NOT be used with Dragonfly unless it directly matches a known good group.",
      "ja": "小さなサブグループを含む基を使用しての問題に起因し、トンボの実装がないグループの完全なドメインパラメータの指定を可能にインライン送信されるように、代わりに共通リポジトリを使用してに識別子を渡すことが推奨されますその強さのドメインパラメータセットは、厳密に証明されている、それは小さなサブグループを持っていません。グループの完全なドメインパラメータセットがインラインで渡された場合、それは直接、既知の良好なグループと一致しない限り、それはトンボと一緒に使用しないでください。"
    },
    {
      "indent": 3,
      "text": "It is RECOMMENDED that an implementation set the security parameter, k, to a value of at least forty (40) which will put the probability that more than forty iterations are needed in the order of one in one trillion (1:1,000,000,000,000).",
      "ja": "実装が40回の以上の反復が1兆（：1,000,000,000,000 1）の一方のために必要とされる確率を置く少なくとも40（40）の値を、kはセキュリティパラメータを設定することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "The technique used to obtain the Password Element in Section 3.2.1 addresses side-channel attacks in a manner deemed controversial by some reviewers in the CFRG. An alternate method, such as the one defined in [hash2ec], can be used to alleviate concerns.",
      "ja": "方法で3.2.1アドレスのサイドチャネル攻撃にパスワード要素を取得するために使用される技術はCFRGにおけるいくつかのレビューで論争とみなさ。別の方法、例えば[hash2ec]で定義されたものとして、懸念を軽減するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "This key exchange protocol has received cryptanalysis in [clarkehao]. [lanskro] provides a security proof of Dragonfly in the random oracle model when both identities are included in the data sent in the Confirm Exchange (see Section 3.4).",
      "ja": "この鍵交換プロトコルは、[clarkehao]で暗号解読を受けました。両方のアイデンティティを確認Exchangeで送信されるデータに含まれている場合[lanskroランダムオラクルモデルにおけるトンボのセキュリティ証明を提供する（セクション3.4を参照）。"
    },
    {
      "indent": 0,
      "text": "5. References",
      "section_title": true,
      "ja": "5.参考文献"
    },
    {
      "indent": 0,
      "text": "5.1. Normative References",
      "section_title": true,
      "ja": "5.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<http://www.rfc-editor.org/info/ RFC2119>。"
    },
    {
      "indent": 0,
      "text": "5.2. Informative References",
      "section_title": true,
      "ja": "5.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[clarkehao] Clarke, D. and F. Hao, \"Cryptanalysis of the Dragonfly Key Exchange Protocol\", IET Information Security, Volume 8, Issue 6, DOI 10.1049/iet-ifs.2013.0081, November 2014.",
      "ja": "[clarkehao]クラーク、D.およびF.ハオ、 \"トンボ鍵交換プロトコルの解読\"、IET情報セキュリティ、8巻、第6号、DOI 10.1049 / IET-ifs.2013.0081、2014年11月。"
    },
    {
      "indent": 3,
      "text": "[FIPS186-4] NIST, \"Digital Signature Standard (DSS)\", Federal Information Processing Standard (FIPS) 186-4, DOI 10.6028/NIST.FIPS.186-4, July 2013.",
      "ja": "[FIPS186-4] NIST、 \"デジタル署名標準（DSS）\"、連邦情報処理標準（FIPS）186から4、DOI 10.6028 / NIST.FIPS.186-4、2013年7月。"
    },
    {
      "indent": 3,
      "text": "[hash2ec] Brier, E., Coron, J-S., Icart, T., Madore, D., Randriam, H., and M. Tibouchi, \"Efficient Indifferentiable Hashing into Ordinary Elliptic Curves\", Cryptology ePrint Archive Report 2009/340, 2009.",
      "ja": "【hash2ec]ブライヤー、E.、コロン、JS。、イカール、T.、Madore、D.、Randriam、H.、およびM. Tibouchi、 \"通常楕円曲線にハッシュ効率Indifferentiable\"、暗号理論のePrintアーカイブレポート340分の2009 2009年。"
    },
    {
      "indent": 3,
      "text": "[lanskro] Lancrenon, J. and M. Skrobot, \"On the Provable Security of the Dragonfly Protocol\", Proceedings of 18th International Information Security Conference (ISC 2015), pp 244-261, DOI 10.1007/978-3-319-23318-5_14, September 2015.",
      "ja": "[lanskro] Lancrenon、J.とM. Skrobot、 \"トンボ議定書の証明可能安全性について\"、第18回国際情報セキュリティ会議（ISC 2015）、頁244から261までの議事録、DOI 10.1007 / 978-3-319-23318 -5_14、2015年9月。"
    },
    {
      "indent": 3,
      "text": "[RANDOR] Bellare, M. and P. Rogaway, \"Random Oracles are Practical: A Paradigm for Designing Efficient Protocols\", Proceedings of the 1st ACM Conference on Computer and Communication Security, ACM Press, DOI 10.1145/168588.168596, 1993.",
      "ja": "[RANDOR]ベラー、M.とP. Rogawayは、「ランダムオラクルは、実用的である：効率的なプロトコルを設計するためのパラダイム」、コンピュータおよび通信セキュリティ、ACMプレスの第一ACM会議の議事録、/ 168588.168596、1993 DOI 10.1145。"
    },
    {
      "indent": 3,
      "text": "[RFC5433] Clancy, T. and H. Tschofenig, \"Extensible Authentication Protocol - Generalized Pre-Shared Key (EAP-GPSK) Method\", RFC 5433, DOI 10.17487/RFC5433, February 2009, <http://www.rfc-editor.org/info/rfc5433>.",
      "ja": "[RFC5433]クランシー、T.及びH. Tschofenig、 \"拡張認証プロトコル - 一般化された事前共有鍵（EAP-GPSK）方法\"、RFC 5433、DOI 10.17487 / RFC5433、2009年2月、<HTTP：//www.rfc- editor.org/info/rfc5433>。"
    },
    {
      "indent": 3,
      "text": "[RFC6090] McGrew, D., Igoe, K., and M. Salter, \"Fundamental Elliptic Curve Cryptography Algorithms\", RFC 6090, DOI 10.17487/RFC6090, February 2011, <http://www.rfc-editor.org/info/rfc6090>.",
      "ja": "[RFC6090]マグリュー、D.、Igoe、K.、およびM.ソルター、 \"基礎楕円曲線暗号アルゴリズム\"、RFC 6090、DOI 10.17487 / RFC6090、2011年2月、<http://www.rfc-editor.org/情報/ rfc6090>。"
    },
    {
      "indent": 3,
      "text": "[RFC7296] Kaufman, C., Hoffman, P., Nir, Y., Eronen, P., and T. Kivinen, \"Internet Key Exchange Protocol Version 2 (IKEv2)\", STD 79, RFC 7296, DOI 10.17487/RFC7296, October 2014, <http://www.rfc-editor.org/info/rfc7296>.",
      "ja": "[RFC7296]コーフマン、C.、ホフマン、P.、ニール、Y.、Eronen、P.、およびT. Kivinen、 \"インターネット鍵交換プロトコルバージョン2（IKEv2の）\"、STD 79、RFC 7296、DOI 10.17487 / RFC7296 、2014年10月、<http://www.rfc-editor.org/info/rfc7296>。"
    },
    {
      "indent": 3,
      "text": "[SP800-108] Chen, L., \"Recommendation for Key Derivation Using Pseudorandom Functions\", NIST Special Publication 800-108, October 2009.",
      "ja": "[SP800-108]チェン、L.、は、NIST Special Publication 800から108、2009年10月 \"擬似ランダム関数を使用した鍵導出のための勧告\"。"
    },
    {
      "indent": 3,
      "text": "[SP800-56A] Barker, E., Johnson, D., and M. Smid, \"Recommendation for Pair-Wise Key Establishment Schemes Using Discrete Logarithm Cryptography (Revised)\", NIST Special Publication 800-56A, March 2007.",
      "ja": "[SP800-56A]バーカー、E.、ジョンソン、D.、およびM. SMID、 \"離散対数暗号を使用してペアワイズ鍵確立スキームのための勧告は（改訂）\"、は、NIST Special Publication 800-56A、2007年3月。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "The author would like to thank Kevin Igoe and David McGrew, chairmen of the Crypto Forum Research Group (CFRG) for agreeing to accept this memo as a CFRG work item. Additional thanks go to Scott Fluhrer and Hideyuki Suzuki for discovering attacks against earlier versions of this key exchange and suggesting fixes to address them. Lily Chen provided helpful discussions on hashing into an elliptic curve. Rich Davis suggested the validation steps used on received elements to prevent a small subgroup attack. Dylan Clarke and Feng Hao discovered a dictionary attack against Dragonfly if those checks are not made and a group with a small subgroup is used. And finally, a very heartfelt thanks to Jean Lancrenon and Marjan Skrobot for developing a proof of the security of Dragonfly.",
      "ja": "著者はケビンIgoeとDavidマグリュー、CFRG作業項目としてこのメ​​モを受け入れることに同意のための暗号化フォーラム研究グループ（CFRG）の議長に感謝したいと思います。追加のおかげで、この鍵交換の以前のバージョンへの攻撃を発見し、それらに対処するための修正を示唆するためにスコットFluhrerと英之鈴木に行きます。リリー・チェンは、楕円曲線にハッシュ化に役立つ議論を提供します。リッチ・デイビスは、小さなサブグループの攻撃を防ぐために、受信要素に使用検証手順を提案しました。これらのチェックが行われていない、小さなサブグループのグループが使用されている場合ディラン・クラークと風水ハオはトンボに対する辞書攻撃を発見しました。そして最後に、トンボのセキュリティの証拠を開発するためのジャンLancrenonとマルジャンSkrobotに非常に心から感謝します。"
    },
    {
      "indent": 3,
      "text": "The blinding scheme to prevent side-channel attacks when determining whether a value is a quadratic residue modulo a prime was suggested by Scott Fluhrer. Kevin Igoe suggested addition of the security parameter k to hide the amount of time taken hunting and pecking for the password element.",
      "ja": "値が素数のモジュロ平方剰余であるか否かを決定する際にサイドチャネル攻撃を防ぐためにブラインド方式は、スコットFluhrerによって示唆されました。ケビンIgoeは、パスワード要素のための狩猟とつつきを取られた時間の量を非表示にするには、セキュリティパラメータkの追加を示唆しました。"
    },
    {
      "indent": 0,
      "text": "Author's Address",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Dan Harkins (editor) Aruba Networks 1322 Crossman Avenue Sunnyvale, CA 94089-1113 United States",
      "ja": "ダンハーキンズ（エディタ）アルバネットワークス1322クロスマンアベニューサニーベール、CA 94089から1113米国"
    },
    {
      "indent": 3,
      "text": "Email: dharkins@arubanetworks.com",
      "ja": "メール：dharkins@arubanetworks.com"
    }
  ]
}