{
  "title": {
    "text": "RFC 7664 - Dragonfly Key Exchange",
    "ja": "RFC 7664 - トンボ鍵交換"
  },
  "number": 7664,
  "created_at": "2019-11-04 20:23:11.178992+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Research Task Force (IRTF)                      D. Harkins, Ed.\nRequest for Comments: 7664                                Aruba Networks\nCategory: Informational                                    November 2015\nISSN: 2070-1721",
      "raw": true
    },
    {
      "indent": 25,
      "text": "Dragonfly Key Exchange",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document specifies a key exchange using discrete logarithm cryptography that is authenticated using a password or passphrase. It is resistant to active attack, passive attack, and offline dictionary attack. This document is a product of the Crypto Forum Research Group (CFRG).",
      "ja": "このドキュメントは、パスワードまたはパスフレーズを使用して認証される離散対数暗号化を使用するキー交換を指定します。 アクティブ攻撃、パッシブ攻撃、オフライン辞書攻撃に対して耐性があります。 このドキュメントは、Crypto Forum Research Group（CFRG）の製品です。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "ja": "このドキュメントは、インターネット標準化過程の仕様ではありません。 情報提供の目的で公開されています。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Research Task Force (IRTF). The IRTF publishes the results of Internet-related research and development activities. These results might not be suitable for deployment. This RFC represents the individual opinion(s) of one or more members of the Crypto Forum Research Group of the Internet Research Task Force (IRTF). Documents approved for publication by the IRSG are not a candidate for any level of Internet Standard; see Section 2 of RFC 5741.",
      "ja": "このドキュメントは、Internet Research Task Force（IRTF）の製品です。 IRTFは、インターネット関連の研究開発活動の結果を公開しています。 これらの結果は、展開に適さない場合があります。 このRFCは、インターネット研究特別調査委員会（IRTF）の暗号フォーラム研究グループの1人以上のメンバーの個々の意見を表しています。 IRSGによる公開が承認された文書は、どのレベルのインターネット標準の候補でもありません。 RFC 5741のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7664.",
      "ja": "このドキュメントの現在のステータス、エラッタ、およびフィードバックに関する情報は、http：//www.rfc-editor.org/info/rfc7664で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2015 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2015 IETF Trustおよび文書作成者として特定された人物。 全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document.",
      "ja": "この文書は、この文書の発行日に有効なBCP 78およびIETFトラストのIETF文書に関する法的条項（http://trustee.ietf.org/license-info）の対象となります。 これらのドキュメントは、このドキュメントに関するあなたの権利と制限を説明しているので、注意深く確認してください。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   2\n  1.1.  Requirements Language . . . . . . . . . . . . . . . . . .   2\n  1.2.  Definitions . . . . . . . . . . . . . . . . . . . . . . .   3\n    1.2.1.  Notations . . . . . . . . . . . . . . . . . . . . . .   3\n    1.2.2.  Resistance to Dictionary Attack . . . . . . . . . . .   3\n2.  Discrete Logarithm Cryptography . . . . . . . . . . . . . . .   4\n  2.1.  Elliptic Curve Cryptography . . . . . . . . . . . . . . .   4\n  2.2.  Finite Field Cryptography . . . . . . . . . . . . . . . .   5\n3.  The Dragonfly Key Exchange  . . . . . . . . . . . . . . . . .   6\n  3.1.  Assumptions . . . . . . . . . . . . . . . . . . . . . . .   7\n  3.2.  Derivation of the Password Element  . . . . . . . . . . .   8\n    3.2.1.  Hunting and Pecking with ECC Groups . . . . . . . . .  10\n    3.2.2.  Hunting and Pecking with MODP Groups  . . . . . . . .  12\n  3.3.  The Commit Exchange . . . . . . . . . . . . . . . . . . .  13\n  3.4.  The Confirm Exchange  . . . . . . . . . . . . . . . . . .  14\n4.  Security Considerations . . . . . . . . . . . . . . . . . . .  15\n5.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  16\n  5.1.  Normative References  . . . . . . . . . . . . . . . . . .  16\n  5.2.  Informative References  . . . . . . . . . . . . . . . . .  16\nAcknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  18\nAuthor's Address  . . . . . . . . . . . . . . . . . . . . . . . .  18",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. 前書き"
    },
    {
      "indent": 3,
      "text": "Passwords and passphrases are the predominant way of doing authentication in the Internet today. Many protocols that use passwords and passphrases for authentication exchange password-derived data as a proof-of-knowledge of the password (for example, [RFC7296] and [RFC5433]). This opens the exchange up to an offline dictionary attack where the attacker gleans enough knowledge from either an active or passive attack on the protocol to run through a pool of potential passwords and compute verifiers until it is able to match the password-derived data.",
      "ja": "パスワードとパスフレーズは、今日のインターネットで主に認証を行う方法です。 認証にパスワードとパスフレーズを使用する多くのプロトコルは、パスワードの知識の証明としてパスワード派生データを交換します（たとえば、[RFC7296]および[RFC5433]）。 これにより、交換はオフライン辞書攻撃につながり、攻撃者はプロトコルに対するアクティブまたはパッシブ攻撃から十分な知識を集めて、パスワードから派生したデータと一致するまで、潜在的なパスワードのプールと検証者を計算します。"
    },
    {
      "indent": 3,
      "text": "This protocol employs discrete logarithm cryptography to perform an efficient exchange in a way that performs mutual authentication using a password that is provably resistant to an offline dictionary attack. Consensus of the CFRG for this document was rough.",
      "ja": "このプロトコルは、離散対数暗号化を採用して、オフライン辞書攻撃に対して確実に耐性のあるパスワードを使用して相互認証を実行する方法で効率的な交換を実行します。 このドキュメントに対するCFRGのコンセンサスは粗いものでした。"
    },
    {
      "indent": 0,
      "text": "1.1. Requirements Language",
      "section_title": true,
      "ja": "1.1. 要件言語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [RFC2119].",
      "ja": "このドキュメントのキーワード「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、および「OPTIONAL」は RFC 2119 [RFC2119]で説明されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "1.2. Definitions",
      "section_title": true,
      "ja": "1.2. 定義"
    },
    {
      "indent": 0,
      "text": "1.2.1. Notations",
      "section_title": true,
      "ja": "1.2.1. 表記法"
    },
    {
      "indent": 3,
      "text": "The following notations are used in this memo.",
      "ja": "このメモでは、次の表記法が使用されます。"
    },
    {
      "indent": 3,
      "text": "password A shared, secret, and potentially low-entropy word, phrase, code, or key used as a credential to mutually authenticate the peers. It is not restricted to characters in a human language.",
      "ja": "パスワードピアを相互認証するための資格情報として使用される、共有された、秘密の、潜在的に低エントロピーの単語、フレーズ、コード、またはキー。 人間の言語の文字に制限されません。"
    },
    {
      "indent": 3,
      "text": "a | b denotes concatenation of bit string \"a\" with bit string \"b\".",
      "ja": "a | bは、ビット文字列「a」とビット文字列「b」の連結を示します。"
    },
    {
      "indent": 3,
      "text": "len(a) indicates the length in bits of the bit string \"a\".",
      "ja": "len（a）は、ビット文字列「a」のビット長を示します。"
    },
    {
      "indent": 3,
      "text": "lsb(a) returns the least-significant bit of the bit string \"a\".",
      "ja": "lsb（a）は、ビット文字列 \"a\"の最下位ビットを返します。"
    },
    {
      "indent": 3,
      "text": "lgr(a,b) takes \"a\" and a prime, \"b\", and returns the Legendre symbol (a/b).",
      "ja": "lgr（a、b）は、「a」と素数「b」を取り、ルジャンドル記号（a / b）を返します。"
    },
    {
      "indent": 3,
      "text": "min(a,b) returns the lexicographical minimum of strings \"a\" and \"b\", or zero (0) if \"a\" equals \"b\".",
      "ja": "min（a、b）は、文字列「a」と「b」の辞書編集上の最小値、または「a」と「b」が等しい場合はゼロ（0）を返します。"
    },
    {
      "indent": 3,
      "text": "max(a,b) returns the lexicographical maximum of strings \"a\" and \"b\", or zero (0) if \"a\" equals \"b\".",
      "ja": "max（a、b）は、文字列「a」と「b」の辞書式最大値を返します。「a」と「b」が等しい場合はゼロ（0）を返します。"
    },
    {
      "indent": 3,
      "text": "The convention for this memo is to represent an element in a finite cyclic group with an uppercase letter or acronym, while a scalar is indicated with a lowercase letter or acronym. An element that represents a point on an elliptic curve has an implied composite nature -- i.e., it has both an x- and y-coordinate.",
      "ja": "このメモの規則は、有限サイクリックグループの要素を大文字または頭字語で表すことです。一方、スカラーは小文字または頭字語で示されます。 楕円曲線上の点を表す要素は、暗黙の複合的な性質を持っています。つまり、x座標とy座標の両方を持っています。"
    },
    {
      "indent": 0,
      "text": "1.2.2. Resistance to Dictionary Attack",
      "section_title": true,
      "ja": "1.2.2. 辞書攻撃に対する抵抗"
    },
    {
      "indent": 3,
      "text": "Resistance to dictionary attack means that any advantage an adversary can gain must be directly related to the number of interactions she makes with an honest protocol participant and not through computation. The adversary will not be able to obtain any information about the password except whether a single guess from a protocol run is correct or incorrect.",
      "ja": "辞書攻撃への抵抗は、敵が得ることができる利点は、計算ではなく、正直なプロトコル参加者とのやり取りの数に直接関係する必要があることを意味します。 攻撃者は、プロトコル実行からの単一の推測が正しいか間違っているかを除いて、パスワードに関する情報を取得できません。"
    },
    {
      "indent": 0,
      "text": "2. Discrete Logarithm Cryptography",
      "section_title": true,
      "ja": "2. 離散対数暗号"
    },
    {
      "indent": 3,
      "text": "Dragonfly uses discrete logarithm cryptography to achieve authentication and key agreement (see [SP800-56A]). Each party to the exchange derives ephemeral keys with respect to a particular set of domain parameters (referred to here as a \"group\"). A group can be based on Finite Field Cryptography (FFC) or Elliptic Curve Cryptography (ECC).",
      "ja": "Dragonflyは、離散対数暗号化を使用して認証とキー合意を達成します（[SP800-56A]を参照）。 交換の各パーティは、ドメインパラメータの特定のセット（ここでは「グループ」と呼びます）に関して一時キーを導出します。 グループは、有限フィールド暗号化（FFC）または楕円曲線暗号化（ECC）に基づくことができます。"
    },
    {
      "indent": 3,
      "text": "Three operations are defined for both types of groups:",
      "ja": "両方のタイプのグループに対して3つの操作が定義されています。"
    },
    {
      "indent": 3,
      "text": "o \"scalar operation\" -- takes a scalar and an element in the group to produce another element -- Z = scalar-op(x, Y).",
      "ja": "o 「スカラー演算」-- グループ内のスカラーと要素を取り、別の要素を生成します -- Z = scalar-op（x、Y）。"
    },
    {
      "indent": 3,
      "text": "o \"element operation\" -- takes two elements in the group to produce a third -- Z = element-op(X, Y).",
      "ja": "o 「要素操作」-- グループ内の2つの要素を取り、3番目の要素を生成します -- Z = element-op（X、Y）。"
    },
    {
      "indent": 3,
      "text": "o \"inverse operation\" -- takes an element and returns another element such that the element operation on the two produces the identity element of the group -- Y = inverse(X).",
      "ja": "o 「逆演算」-- 要素を受け取り、2つの要素演算がグループの恒等要素を生成するように別の要素を返します -- Y = inverse（X）。"
    },
    {
      "indent": 0,
      "text": "2.1. Elliptic Curve Cryptography",
      "section_title": true,
      "ja": "2.1. 楕円曲線暗号"
    },
    {
      "indent": 3,
      "text": "Domain parameters for the ECC groups used by Dragonfly are:",
      "ja": "Dragonflyが使用するECCグループのドメインパラメーターは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o A prime, p, determining a prime field GF(p). The cryptographic group will be a subgroup of the full elliptic curve group that consists of points on an elliptic curve -- elements from GF(p) that satisfy the curve's equation -- together with the \"point at infinity\" that serves as the identity element. The group operation for ECC groups is addition of points on the elliptic curve.",
      "ja": "o 素数フィールドGF（p）を決定する素数p。 暗号グループは、楕円曲線上の点（曲線の方程式を満たすGF（p）の要素）と、恒等要素として機能する「無限遠点」で構成される完全な楕円曲線グループのサブグループになります。 。 ECCグループのグループ操作は、楕円曲線上のポイントの追加です。"
    },
    {
      "indent": 3,
      "text": "o Elements a and b from GF(p) that define the curve's equation. The point (x, y) in GF(p) x GF(p) is on the elliptic curve if and only if (y^2 - x^3 - a*x - b) mod p equals zero (0).",
      "ja": "o 曲線の方程式を定義するGF（p）の要素aおよびb。 （y ^ 2-x ^ 3-a * x-b）mod pがゼロ（0）の場合にのみ、GF（p）x GF（p）の点（x、y）は楕円曲線上にあります。"
    },
    {
      "indent": 3,
      "text": "o A point, G, on the elliptic curve, which serves as a generator for the ECC group. G is chosen such that its order, with respect to elliptic curve addition, is a sufficiently large prime.",
      "ja": "o ECCグループのジェネレーターとして機能する楕円曲線上の点G。 Gは、楕円曲線の加算に関してその次数が十分に大きい素数になるように選択されます。"
    },
    {
      "indent": 3,
      "text": "o A prime, q, which is the order of G, and thus is also the size of the cryptographic subgroup that is generated by G.",
      "ja": "o 素数q。これはGの次数であり、Gによって生成される暗号化サブグループのサイズでもあります。"
    },
    {
      "indent": 3,
      "text": "An (x,y) pair is a valid ECC element if: 1) the x- and y-coordinates are both greater than zero (0) and less than the prime defining the underlying field; and, 2) the x- and y-coordinates satisfy the equation for the curve and produce a valid point on the curve that is not the point at infinity. If either one of those conditions do not hold, the (x,y) pair is not a valid element.",
      "ja": "（x、y）ペアは、次の場合に有効なECCエレメントです。1）x座標とy座標の両方がゼロ（0）より大きく、基になるフィールドを定義する素数より小さい。 また、2）x座標とy座標は曲線の方程式を満たし、無限遠点ではない有効な点を曲線上に生成します。 これらの条件のいずれかが成り立たない場合、（x、y）ペアは有効な要素ではありません。"
    },
    {
      "indent": 3,
      "text": "The scalar operation is addition of a point on the curve with itself a number of times. The point Y is multiplied x times to produce another point Z:",
      "ja": "スカラー演算は、曲線上のポイントを何度も追加することです。 ポイントYをx回乗算して別のポイントZを生成します。"
    },
    {
      "indent": 6,
      "text": "Z = scalar-op(x, Y) = x*Y",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The element operation is addition of two points on the curve. Points X and Y are summed to produce another point Z:",
      "ja": "要素操作は、曲線上の2つのポイントの追加です。 ポイントXとポイントYを合計して、別のポイントZを生成します。"
    },
    {
      "indent": 6,
      "text": "Z = element-op(X, Y) = X + Y",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The inverse function is defined such that the sum of an element and its inverse is \"0\", the point at infinity of an elliptic curve group:",
      "ja": "逆関数は、要素とその逆の合計が「0」、つまり楕円曲線グループの無限遠点になるように定義されます。"
    },
    {
      "indent": 6,
      "text": "R + inverse(R) = \"0\"",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Elliptic curve groups require a mapping function, q = F(Q), to convert a group element to an integer. The mapping function used in this memo returns the x-coordinate of the point it is passed.",
      "ja": "楕円曲線グループには、グループ要素を整数に変換するためのマッピング関数q = F（Q）が必要です。 このメモで使用されるマッピング関数は、渡されたポイントのx座標を返します。"
    },
    {
      "indent": 3,
      "text": "scalar-op(x, Y) can be viewed as x iterations of element-op() by defining:",
      "ja": "scalar-op（x、Y）は、以下を定義することにより、element-op（）のx回の繰り返しと見なすことができます。"
    },
    {
      "indent": 6,
      "text": "Y = scalar-op(1, Y)",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Y = scalar-op(x, Y) = element-op(Y, scalar-op(x-1, Y)), for x > 1",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A definition of how to add two points on an elliptic curve (i.e., element-op(X, Y)) can be found in [RFC6090].",
      "ja": "楕円曲線上に2つのポイントを追加する方法の定義（つまり、element-op（X、Y））は[RFC6090]で見つけることができます。"
    },
    {
      "indent": 3,
      "text": "Note: There is another elliptic curve domain parameter, a cofactor, h, that is defined by the requirement that the size of the full elliptic curve group (including \"0\") be the product of h and q. Elliptic curve groups used with Dragonfly authentication MUST have a cofactor of one (1).",
      "ja": "注：完全な楕円曲線グループ（「0」を含む）のサイズがhとqの積であるという要件によって定義される、別の楕円曲線ドメインパラメーターである補因子hがあります。 Dragonfly認証で使用される楕円曲線グループには、1の補因子が必要です。"
    },
    {
      "indent": 0,
      "text": "2.2. Finite Field Cryptography",
      "section_title": true,
      "ja": "2.2. 有限フィールド暗号化"
    },
    {
      "indent": 3,
      "text": "Domain parameters for the FFC groups used in Dragonfly are:",
      "ja": "Dragonflyで使用されるFFCグループのドメインパラメーターは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o A prime, p, determining a prime field GF(p), the integers modulo p. The FFC group will be a subgroup of GF(p)*, the multiplicative group of non-zero elements in GF(p). The group operation for FFC groups is multiplication modulo p.",
      "ja": "o 素数体GF（p）、pを法とする整数を決定する素数p。 FFCグループは、GF（p）*の非ゼロ要素の乗法グループであるGF（p）*のサブグループになります。 FFCグループのグループ演算は、pを法とする乗算です。"
    },
    {
      "indent": 3,
      "text": "o An element, G, in GF(p)* which serves as a generator for the FFC group. G is chosen such that its multiplicative order is a sufficiently large prime divisor of ((p-1)/2).",
      "ja": "o FFCグループのジェネレーターとして機能するGF（p）*の要素G。 Gは、乗法次数が（（p-1）/ 2）の十分に大きい素数であるように選択されます。"
    },
    {
      "indent": 3,
      "text": "o A prime, q, which is the multiplicative order of G, and thus also the size of the cryptographic subgroup of GF(p)* that is generated by G.",
      "ja": "o Gの乗数次数である素数q。したがって、Gによって生成されるGF（p）*の暗号サブグループのサイズ。"
    },
    {
      "indent": 3,
      "text": "A number is a valid element in an FFC group if: 1) it is between one (1) and one (1) less than the prime, p, exclusive (i.e., 1 < element < p-1); and, 2) if modular exponentiation of the element by the group order, q, equals one (1). If either one of those conditions do not hold, the number is not a valid element.",
      "ja": "数値は、次の場合にFFCグループの有効な要素です。1）プライム、p、排他的（1 <element <p-1）よりも1から1の間だけ小さい場合。 および、2）グループ順序qによる要素のモジュラーべき乗が1に等しい場合。 これらの条件のいずれかが成り立たない場合、番号は有効な要素ではありません。"
    },
    {
      "indent": 3,
      "text": "The scalar operation is exponentiation of a generator modulo a prime. An element Y is taken to the x-th power modulo the prime returning another element, Z:",
      "ja": "スカラー演算は、素数を法とするジェネレータの累乗です。 要素Yは、別の要素Zを返す素数を法とするxのべき乗になります。"
    },
    {
      "indent": 6,
      "text": "Z = scalar-op(x, Y) = Y^x mod p",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The element operation is modular multiplication. Two elements, X and Y, are multiplied modulo the prime returning another element, Z:",
      "ja": "要素演算はモジュラー乗算です。 2つの要素XとYは、素数を法として乗算され、別の要素Zを返します。"
    },
    {
      "indent": 6,
      "text": "Z = element-op(X, Y) = (X * Y) mod p",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The inverse function for a MODP group is defined such that the product of an element and its inverse modulo the group prime equals one (1). In other words,",
      "ja": "MODPグループの逆関数は、要素とそのグループの素数を法とする逆数の積が1になるように定義されます。 言い換えると、"
    },
    {
      "indent": 6,
      "text": "(R * inverse(R)) mod p = 1",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3. The Dragonfly Key Exchange",
      "section_title": true,
      "ja": "3. トンボの鍵交換"
    },
    {
      "indent": 3,
      "text": "There are two parties to the Dragonfly exchange named, for convenience and by convention, Alice and Bob. The two parties have a shared password that was established in an out-of-band mechanism, and they both agree to use a particular domain parameter set (either ECC or FFC). In the Dragonfly exchange, both Alice and Bob share an identical view of the shared password -- i.e., it is not \"augmented\", where one side holds a password and the other side holds a non-invertible verifier. This allows Dragonfly to be used in traditional client-server protocols and also in peer-to-peer applications in which there are not fixed roles and either party may initiate the exchange (and both parties may implement it simultaneously).",
      "ja": "便宜上、慣例により、アリスとボブという名前のDragonfly交換には2つのパーティがあります。 両者は、帯域外メカニズムで確立された共有パスワードを持ち、両者は特定のドメインパラメーターセット（ECCまたはFFC）を使用することに同意します。 Dragonfly交換では、アリスとボブの両方が共有パスワードの同じビューを共有します。つまり、一方がパスワードを保持し、もう一方が非可逆検証者を保持する「拡張」ではありません。 これにより、Dragonflyを従来のクライアント/サーバープロトコルで使用したり、固定された役割がなく、どちらの当事者も交換を開始したり（両方の当事者が同時に実装したり）、ピアツーピアアプリケーションで使用したりできます。"
    },
    {
      "indent": 3,
      "text": "Prior to beginning the Dragonfly exchange, the two peers MUST derive a secret element in the chosen domain parameter set. Two \"hunting-and-pecking\" techniques to determine a secret element, one for ECC and one for FFC, are described in Section 3.2, but any secure, deterministic method that is agreed upon can be used. For instance, the technique described in [hash2ec] can be used for ECC groups.",
      "ja": "Dragonfly交換を開始する前に、2つのピアは、選択されたドメインパラメーターセットの秘密要素を取得する必要があります。 セクション3.2で、ECC用とFFC用の秘密要素を決定する2つの「狩りとつつき」技術について説明しますが、合意されている安全で決定的な方法を使用できます。 たとえば、[hash2ec]で説明されている手法は、ECCグループに使用できます。"
    },
    {
      "indent": 3,
      "text": "The Dragonfly exchange consists of two message exchanges, a \"Commit Exchange\" in which both sides commit to a single guess of the password, and a \"Confirm Exchange\" in which both sides confirm knowledge of the password. A side effect of running the Dragonfly exchange is an authenticated, shared, and secret key whose cryptographic strength is set by the agreed-upon group.",
      "ja": "Dragonflyの交換は、2つのメッセージ交換で構成されます。両側がパスワードの単一の推測にコミットする「Commit Exchange」と、両側がパスワードの知識を確認する「Confirm Exchange」です。 Dragonflyエクスチェンジを実行する副作用は、合意されたグループによって暗号強度が設定される認証済み、共有、および秘密キーです。"
    },
    {
      "indent": 3,
      "text": "Dragonfly uses a random function, H(), a mapping function, F(), and a key derivation function, KDF().",
      "ja": "Dragonflyは、ランダム関数H()、マッピング関数F()、およびキー派生関数KDF()を使用します。"
    },
    {
      "indent": 0,
      "text": "3.1. Assumptions",
      "section_title": true,
      "ja": "3.1. 仮定"
    },
    {
      "indent": 3,
      "text": "In order to avoid attacks on the Dragonfly protocol, some basic assumptions are made:",
      "ja": "Dragonflyプロトコルへの攻撃を回避するために、いくつかの基本的な仮定が行われます。"
    },
    {
      "indent": 3,
      "text": "1. Function H is a \"random oracle\" (see [RANDOR]) that maps a binary string of indeterminate length onto a fixed binary string that is x bits in length.",
      "ja": "1. 関数Hは、不定長のバイナリ文字列をxビット長の固定バイナリ文字列にマッピングする「ランダムオラクル」（[RANDOR]を参照）です。"
    },
    {
      "indent": 10,
      "text": "H: {0,1}^* --> {0,1}^x",
      "raw": true
    },
    {
      "indent": 3,
      "text": "2. Function F is a mapping function that takes an element in a group and returns an integer. For ECC groups, function F() returns the x-coordinate of the element (which is a point on the elliptic curve); for FFC groups, function F() is the identity function (since all elements in an FFC group are already integers less than the prime).",
      "ja": "2. 関数Fは、グループ内の要素を受け取り、整数を返すマッピング関数です。 ECCグループの場合、関数F()は、要素（楕円曲線上の点）のx座標を返します。 FFCグループの場合、関数F()は恒等関数です（FFCグループのすべての要素は既に素数よりも小さい整数であるため）。"
    },
    {
      "indent": 10,
      "text": "ECC: x = F(P), where P=(x,y)",
      "raw": true
    },
    {
      "indent": 10,
      "text": "FFC: x = F(x)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "3. Function KDF is a key derivation function (see, for instance, [SP800-108]) that takes a key to stretch, k, a label to bind to the key, label, and an indication of the desired output, n:",
      "ja": "3. 関数KDFは、鍵導出関数（たとえば、[SP800-108]を参照）で、鍵を引き伸ばすk、鍵にバインドするラベル、ラベル、および目的の出力nの指示を受け取ります。"
    },
    {
      "indent": 10,
      "text": "stretch = KDF-n(k, label)",
      "raw": true
    },
    {
      "indent": 7,
      "text": "so that len(stretch) equals n.",
      "ja": "len（stretch）がnと等しくなるようにします。"
    },
    {
      "indent": 3,
      "text": "4. The discrete logarithm problem for the chosen group is hard. That is, given G, P, and Y = G^x mod p, it is computationally infeasible to determine x. Similarly, for an ECC group given the curve definition, a generator G, and Y = x * G, it is computationally infeasible to determine x.",
      "ja": "4. 選択したグループの離散対数問題は困難です。 つまり、G、P、およびY = G ^ x mod pが与えられた場合、xを決定することは計算上実行不可能です。 同様に、曲線定義、ジェネレーターG、およびY = x * Gが与えられたECCグループの場合、xを決定することは計算上実行不可能です。"
    },
    {
      "indent": 3,
      "text": "5. There exists a pool of passwords from which the password shared by the two peers is drawn. This pool can consist of words from a dictionary, for example. Each password in this pool has an equal probability of being the shared password. All potential attackers have access to this pool of passwords.",
      "ja": "5. 2つのピアによって共有されるパスワードが引き出されるパスワードのプールが存在します。 このプールは、たとえば辞書の単語で構成できます。 このプール内の各パスワードは、共有パスワードになる確率が等しくなります。 すべての潜在的な攻撃者は、このパスワードのプールにアクセスできます。"
    },
    {
      "indent": 3,
      "text": "6. The peers have the ability to produce quality random numbers.",
      "ja": "6. ピアには、高品質の乱数を生成する機能があります。"
    },
    {
      "indent": 0,
      "text": "3.2. Derivation of the Password Element",
      "section_title": true,
      "ja": "3.2. パスワード要素の派生"
    },
    {
      "indent": 3,
      "text": "Prior to beginning the exchange of information, the peers MUST derive a secret element, called the Password Element (PE), in the group defined by the chosen domain parameter set. From the point of view of an attacker who does not know the password, the PE will be a random element in the negotiated group. Two examples are described here for completeness, but any method of deterministically mapping a secret string into an element in a selected group can be used -- for instance, the technique in [hash2ec] for ECC groups. If a different technique than the ones described here is used, the secret string SHOULD include the identities of the peers.",
      "ja": "情報の交換を開始する前に、ピアは、選択されたドメインパラメータセットによって定義されたグループ内で、パスワード要素（PE）と呼ばれる秘密要素を導出する必要があります。 パスワードを知らない攻撃者の観点から、PEはネゴシエートされたグループのランダムな要素になります。 ここでは完全性のために2つの例を説明しますが、選択したグループの要素に秘密の文字列を決定論的にマッピングする方法はすべて使用できます。たとえば、ECCグループの[hash2ec]の手法です。 ここで説明した手法とは異なる手法を使用する場合、秘密文字列にはピアのIDを含める必要があります。"
    },
    {
      "indent": 3,
      "text": "To fix the PE, both peers MUST have a common view of the password. If there is any password processing necessary (for example, to support internationalization), the processed password is then used as the shared credential. If either side wants to store a hashed version of the password (hashing the password with random data called a \"salt\"), it will be necessary to convey the salt to the other side prior to commencing the exchange, and the hashed password is then used as the shared credential.",
      "ja": "PEを修正するには、両方のピアがパスワードの共通ビューを持っている必要があります。 （国際化をサポートするためなど）必要なパスワード処理がある場合、処理されたパスワードは共有資格情報として使用されます。 どちらかの側がパスワードのハッシュバージョンを保存する場合（「ソルト」と呼ばれるランダムデータでパスワードをハッシュする場合）、交換を開始する前に反対側にソルトを伝達する必要があり、ハッシュされたパスワードは 共有資格情報として使用されます。"
    },
    {
      "indent": 3,
      "text": "Note: Only one party would be able to maintain a salted password, and this would require that the Dragonfly key exchange be used in a protocol that has strict roles for client (that always initiates) and server (that always responds). Due to the symmetric nature of Dragonfly, salting passwords does not prevent an impersonation attack after compromise of a database of salted passwords.",
      "ja": "注：ソルトパスワードを維持できるのは1者のみであり、これには、クライアント（常に開始する）とサーバー（常に応答する）に対して厳密な役割を持つプロトコルでDragonflyキー交換を使用する必要があります。 Dragonflyの対称性により、パスワードをソルトしても、ソルトされたパスワードのデータベースが侵害された後の偽装攻撃を防ぐことはできません。"
    },
    {
      "indent": 3,
      "text": "The deterministic process to select the PE begins with choosing a secret seed and then performing a group-specific hunting-and-pecking technique -- one for FFC groups and another for ECC groups.",
      "ja": "PEを選択する決定論的なプロセスは、シークレットシードを選択してから、グループ固有のハンティングアンドペッキング手法（FFCグループ用とECCグループ用）を実行することから始まります。"
    },
    {
      "indent": 3,
      "text": "To thwart side-channel attacks that attempt to determine the number of iterations of the hunting-and-pecking loop used to find the PE for a given password, a security parameter, k, is used that ensures that at least k iterations are always performed. The probability that one requires more than n iterations of the hunting-and-pecking loop to find an ECC PE is roughly (q/2p)^n and to find an FFC PE is roughly (q/p)^n, both of which rapidly approach zero (0) as n increases. The security parameter, k, SHOULD be set sufficiently large such that the probability that finding the PE would take more than k iterations is sufficiently small (see Section 4).",
      "ja": "与えられたパスワードのPEを見つけるために使用されるハンティングとペッキングループの反復回数を決定しようとするサイドチャネル攻撃を阻止するには、少なくともk回の反復が常に実行されることを保証するセキュリティパラメーターkが使用されます 。 ECC PEを見つけるためにハンティングアンドペッキングループをn回以上繰り返す必要がある確率は、おおよそ（q / 2p）^ nであり、FFC PEを見つけるにはおおよそ（q / p）^ nです。 nが増加すると、急速にゼロ（0）に近づきます。 セキュリティパラメータkは、PEを見つけるのにk回を超える反復が必要になる確率が十分に小さくなるように十分に大きく設定する必要があります（セクション4を参照）。"
    },
    {
      "indent": 3,
      "text": "First, an 8-bit counter is set to one (1), and a secret base is computed using the negotiated one-way function with the identities of the two participants, Alice and Bob, the secret password, and the counter:",
      "ja": "最初に、8ビットカウンターが1に設定され、2つの参加者、AliceとBobのID、シークレットパスワード、およびカウンターとのネゴシエートされた一方向関数を使用して、シークレットベースが計算されます。"
    },
    {
      "indent": 3,
      "text": "base = H(max(Alice,Bob) | min(Alice,Bob) | password | counter)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The identities are passed to the max() and min() functions to provide the necessary ordering of the inputs to H() while still allowing for a peer-to-peer exchange where both Alice and Bob each view themselves as the \"initiator\" of the exchange.",
      "ja": "アイデンティティはmax（）およびmin（）関数に渡され、H（）への入力に必要な順序を提供しながら、アリスとボブの両方が自分自身を「イニシエーター」と見なすピアツーピア交換を可能にします 交換の。"
    },
    {
      "indent": 3,
      "text": "The base is then stretched using the technique from Section B.5.1 of [FIPS186-4]. The key derivation function, KDF, is used to produce a bitstream whose length is equal to the length of the prime from the group's domain parameter set plus the constant sixty-four (64) to derive a temporary value, and the temporary value is modularly reduced to produce a seed:",
      "ja": "次に、[FIPS186-4]のセクションB.5.1の手法を使用してベースを引き伸ばします。 鍵導出関数KDFを使用して、グループのドメインパラメーターセットからの素数の長さと定数64（64）に等しい長さのビットストリームを生成し、一時値を導出します。 シードを生成するために削減されました"
    },
    {
      "indent": 3,
      "text": "n = len(p) + 64",
      "raw": true
    },
    {
      "indent": 3,
      "text": "temp = KDF-n(base, \"Dragonfly Hunting and Pecking\")",
      "raw": true
    },
    {
      "indent": 3,
      "text": "seed = (temp mod (p - 1)) + 1",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The string bound to the derived temporary value is for illustrative purposes only. Implementations of the Dragonfly key exchange SHOULD use a usage-specific label with the KDF.",
      "ja": "派生した一時値にバインドされた文字列は、説明のみを目的としています。 Dragonfly鍵交換の実装は、KDFで用途固有のラベルを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note: The base is stretched to 64 more bits than are needed so that the bias from the modular reduction is not so apparent.",
      "ja": "注：ベースは必要以上に64ビットに拡張されているため、モジュラー削減によるバイアスはそれほど明確ではありません。"
    },
    {
      "indent": 3,
      "text": "The seed is then passed to the group-specific hunting-and-pecking technique.",
      "ja": "その後、シードはグループ固有の狩猟とつつきの手法に渡されます。"
    },
    {
      "indent": 3,
      "text": "If the protocol performing the Dragonfly exchange has the ability to exchange random nonces, those SHOULD be added to the computation of the base to ensure that each run of the protocol produces a different PE.",
      "ja": "Dragonfly交換を実行するプロトコルにランダムノンスを交換する機能がある場合、それらをベースの計算に追加して、プロトコルの各実行で異なるPEが生成されるようにする必要があります。"
    },
    {
      "indent": 0,
      "text": "3.2.1. Hunting and Pecking with ECC Groups",
      "section_title": true,
      "ja": "3.2.1. ECCグループを使用したハンティングとペッキング"
    },
    {
      "indent": 3,
      "text": "The ECC-specific hunting-and-pecking technique entails looping until a valid point on the elliptic curve has been found. The seed is used as an x-coordinate with the equation of the curve to check whether x^3 + a*x + b is a quadratic residue modulo p. If it is not, then the counter is incremented, a new base and new seed are generated, and the hunting and pecking continues. If it is a quadratic residue modulo p, then the x-coordinate is assigned the value of seed and the current base is stored. When the hunting-and-pecking loop terminates, the x-coordinate is used with the equation of the curve to solve for a y-coordinate. An ambiguity exists since two values for the y-coordinate would be valid, and the low-order bit of the stored base is used to unambiguously determine the correct y-coordinate. The resulting (x,y) pair becomes the Password Element, PE.",
      "ja": "ECC固有のハンチングテクニックは、楕円曲線上の有効なポイントが見つかるまでループする必要があります。 シードは、x ^ 3 + a * x + bがpを法とする2次剰余であるかどうかを確認するために、曲線の方程式でx座標として使用されます。 そうでない場合、カウンターが増分され、新しいベースと新しいシードが生成され、ハンティングとペッキングが続行されます。 pを法とする2次剰余の場合、x座標にseedの値が割り当てられ、現在のベースが格納されます。 ハンティングとペッキングループが終了すると、x座標が曲線の方程式で使用され、y座標が解かれます。 y座標の2つの値が有効であり、格納されたベースの下位ビットを使用して正しいy座標を明確に決定するため、あいまいさが存在します。 結果の（x、y）ペアは、パスワード要素PEになります。"
    },
    {
      "indent": 3,
      "text": "Algorithmically, the process looks like this:",
      "ja": "アルゴリズム的には、プロセスは次のようになります。"
    },
    {
      "indent": 8,
      "text": "found = 0\ncounter = 1\nn = len(p) + 64\ndo {\n  base = H(max(Alice,Bob) | min(Alice,Bob) | password | counter)\n  temp = KDF-n(base, \"Dragonfly Hunting And Pecking\")\n  seed = (temp mod (p - 1)) + 1\n  if ( (seed^3 + a*seed + b) is a quadratic residue mod p)\n  then\n    if ( found == 0 )\n    then\n      x = seed\n      save = base\n      found = 1\n    fi\n  fi\n  counter = counter + 1\n} while ((found == 0) || (counter <= k))\ny = sqrt(x^3 + ax + b)\nif ( lsb(y) == lsb(save) )\nthen\n  PE = (x,y)\nelse\n  PE = (x,p-y)\nfi",
      "raw": true
    },
    {
      "indent": 20,
      "text": "Figure 1: Fixing PE for ECC Groups",
      "ja": "図1：ECCグループのPEの修正"
    },
    {
      "indent": 3,
      "text": "Checking whether a value is a quadratic residue modulo a prime can leak information about that value in a side-channel attack. Therefore, it is RECOMMENDED that the technique used to determine if the value is a quadratic residue modulo p blind the value with a random number so that the blinded value can take on all numbers between 1 and p-1 with equal probability while not changing its quadratic residuosity. Determining the quadratic residue in a fashion that resists leakage of information is handled by flipping a coin and multiplying the blinded value by either a random quadratic residue or a random quadratic nonresidue and checking whether the multiplied value is a quadratic residue (qr) or a quadratic nonresidue (qnr) modulo p, respectively. The random residue and nonresidue can be calculated prior to hunting and pecking by calculating the Legendre symbol on random values until they are found:",
      "ja": "値が素数を法とする二次剰余であるかどうかをチェックすると、サイドチャネル攻撃でその値に関する情報が漏洩する可能性があります。 したがって、値がpを法とする2次剰余であるかどうかを判断する手法を使用して、値を変更せずに1からp-1までのすべての数字を同じ確率で取得できるように、乱数で値をブラインドすることをお勧めします 二次残余。 情報の漏洩に抵抗する方法で二次剰余を決定するには、コインを反転し、ランダムな二次剰余またはランダムな二次非剰余のいずれかでブラインド値を乗算し、乗算値が二次剰余（qr）または二次であるかどうかを確認することによって処理されます それぞれpを法とする非剰余（qnr）。 ランダムな残基と非残基は、ランダム値でルジャンドル記号を計算することにより、それらが見つかるまでハンティングとペッキングの前に計算できます。"
    },
    {
      "indent": 6,
      "text": "do {\n  qr = random() mod p\n} while ( lgr(qr, p) != 1)",
      "raw": true
    },
    {
      "indent": 6,
      "text": "do {\n  qnr = random() mod p\n} while ( lgr(qnr, p) != -1)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Algorithmically, the masking technique to find out whether or not a value is a quadratic residue looks like this:",
      "ja": "アルゴリズム的に、値が2次剰余であるかどうかを調べるマスキング手法は次のようになります。"
    },
    {
      "indent": 6,
      "text": "is_quadratic_residue (val, p) {\n    r = (random() mod (p - 1)) + 1\n    num = (val * r * r) mod p\n    if ( lsb(r) == 1 )\n       num = (num * qr) mod p\n       if ( lgr(num, p) == 1)\n       then\n          return TRUE\n       fi\n    else\n       num = (num * qnr) mod p\n       if ( lgr(num, p) == -1)\n       then\n          return TRUE\n       fi\n    fi\n    return FALSE\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.2.2. Hunting and Pecking with MODP Groups",
      "section_title": true,
      "ja": "3.2.2. MODPグループを使用したハンティングとペッキング"
    },
    {
      "indent": 3,
      "text": "The MODP-specific hunting-and-pecking technique entails finding a random element which, when used as a generator, will create a group with the same order as the group created by the generator from the domain parameter set. The secret generator is found by exponentiating the seed to the value ((p-1)/q), where p is the prime and q is the order from the domain parameter set. If that value is greater than one (1), it becomes the PE; otherwise, the counter is incremented, a new base and seed are generated, and the hunting and pecking continues.",
      "ja": "MODP固有のハンティングとペッキングの手法では、ジェネレーターとして使用する場合、ドメインパラメーターセットからジェネレーターによって作成されたグループと同じ順序でグループを作成するランダム要素を見つける必要があります。 シークレットジェネレーターは、シードを値（（p-1）/ q）に累乗することで検出されます。ここで、pは素数、qはドメインパラメーターセットからの次数です。 その値が1より大きい場合、PEになります。 そうでない場合、カウンターが増分され、新しいベースとシードが生成され、ハンティングとペッキングが続行されます。"
    },
    {
      "indent": 3,
      "text": "Algorithmically, the process looks like this:",
      "ja": "アルゴリズム的には、プロセスは次のようになります。"
    },
    {
      "indent": 6,
      "text": "found = 0\ncounter = 1\nn = len(p) + 64\ndo {\n  base = H(max(Alice,Bob) | min(Alice,Bob) | password | counter)\n  temp = KDF-n(seed, \"Dragonfly Hunting And Pecking\")\n  seed = (temp mod (p - 1)) + 1\n  temp = seed ^ ((p-1)/q) mod p\n  if (temp > 1)\n  then\n    if (not found)\n      PE = temp\n      found = 1\n    fi\n  fi\n  counter = counter + 1\n} while ((found == 0) || (counter <= k))",
      "raw": true
    },
    {
      "indent": 20,
      "text": "Figure 2: Fixing PE for MODP Groups",
      "ja": "図2：MODPグループのPEの修正"
    },
    {
      "indent": 0,
      "text": "3.3. The Commit Exchange",
      "section_title": true,
      "ja": "3.3. コミット交換"
    },
    {
      "indent": 3,
      "text": "In the Commit Exchange, both sides commit to a single guess of the password. The peers generate a scalar and an element, exchange them with each other, and process the other's scalar and element to generate a common and shared secret.",
      "ja": "Commit Exchangeでは、両側がパスワードの単一の推測にコミットします。 ピアはスカラーと要素を生成し、相互に交換し、他のスカラーと要素を処理して共通の共有秘密を生成します。"
    },
    {
      "indent": 3,
      "text": "First, each peer generates two random numbers, private and mask that are each greater than one (1) and less than the order from the selected domain parameter set:",
      "ja": "最初に、各ピアは、選択されたドメインパラメータセットから、それぞれ1より大きく、順序より小さい2つの乱数、privateとmaskを生成します。"
    },
    {
      "indent": 6,
      "text": "1 < private < q\n1 < mask < q",
      "raw": true
    },
    {
      "indent": 3,
      "text": "These two secrets and the Password Element are then used to construct the scalar and element:",
      "ja": "次に、これらの2つのシークレットとパスワード要素を使用して、スカラーと要素を構築します。"
    },
    {
      "indent": 9,
      "text": "scalar = (private + mask) modulo q\nElement = inverse(scalar-op(mask, PE))",
      "raw": true
    },
    {
      "indent": 3,
      "text": "If the scalar is less than two (2), the private and mask MUST be thrown away and new values generated. Once a valid scalar and Element are generated, the mask is no longer needed and MUST be irretrievably destroyed.",
      "ja": "スカラーが2未満の場合、プライベートとマスクを破棄し、新しい値を生成する必要があります。 有効なスカラーと要素が生成されると、マスクは不要になり、回復不能に破棄する必要があります。"
    },
    {
      "indent": 3,
      "text": "The peers exchange their scalar and Element and check the peer's scalar and Element, deemed peer-scalar and Peer-Element. If the peer has sent an identical scalar and Element -- i.e., if scalar equals peer-scalar and Element equals Peer-Element -- it is sign of a reflection attack, and the exchange MUST be aborted. If the values differ, peer-scalar and Peer-Element must be validated. For the peer-scalar to be valid, it MUST be between 1 and q exclusive. Validation of the Peer-Element depends on the type of cryptosystem -- validation of an (x,y) pair as an ECC element is specified in Section 2.1, and validation of a number as an FFC element is specified in Section 2.2. If either the peer-scalar or Peer-Element fail validation, then the exchange MUST be terminated and authentication fails. If both the peer-scalar and Peer-Element are valid, they are used with the Password Element to derive a shared secret, ss:",
      "ja": "ピアはスカラーと要素を交換し、ピアのスカラーとピア要素と見なされるピアのスカラーと要素を確認します。 ピアが同一のスカラーとElementを送信した場合、つまり、スカラーがpeer-scalarに等しく、ElementがPeer-Elementに等しい場合、リフレクション攻撃の兆候であり、交換は中止されなければなりません。 値が異なる場合、peer-scalarとPeer-Elementを検証する必要があります。 ピアスカラーを有効にするには、1〜q排他的でなければなりません。 Peer-Elementの検証は暗号システムのタイプに依存します-ECC要素としての（x、y）ペアの検証はセクション2.1で指定され、FFC要素としての数値の検証はセクション2.2で指定されます。 peer-scalarまたはPeer-Elementのいずれかが検証に失敗した場合、交換は終了しなければならず、認証は失敗します。 peer-scalarとPeer-Elementの両方が有効な場合、それらはPassword Elementと一緒に使用されて、共有シークレットssを導き出します。"
    },
    {
      "indent": 12,
      "text": "ss = F(scalar-op(private,\n                 element-op(peer-Element,\n                            scalar-op(peer-scalar, PE))))",
      "raw": true
    },
    {
      "indent": 3,
      "text": "To enforce key separation and cryptographic hygiene, the shared secret is stretched into two subkeys -- a key confirmation key, kck, and a master key, mk. Each of the subkeys SHOULD be at least the length of the prime used in the selected group.",
      "ja": "鍵の分離と暗号衛生を強化するために、共有シークレットは、鍵確認キーkckとマスターキーmkの2つのサブキーに拡張されます。 各サブキーは、少なくとも選択したグループで使用される素数の長さである必要があります。"
    },
    {
      "indent": 9,
      "text": "kck | mk = KDF-n(ss, \"Dragonfly Key Derivation\")",
      "raw": true
    },
    {
      "indent": 3,
      "text": "where n = len(p)*2.",
      "ja": "ただし、n = len(p) * 2。"
    },
    {
      "indent": 0,
      "text": "3.4. The Confirm Exchange",
      "section_title": true,
      "ja": "3.4. 確認交換"
    },
    {
      "indent": 3,
      "text": "In the Confirm Exchange, both sides confirm that they derived the same secret, and therefore, are in possession of the same password.",
      "ja": "Confirm Exchangeでは、双方が同じシークレットを導出し、したがって同じパスワードを所有していることを確認します。"
    },
    {
      "indent": 3,
      "text": "The Commit Exchange consists of an exchange of data that is the output of the random function, H(), the key confirmation key, and the two scalars and two elements exchanged in the Commit Exchange. The order of the scalars and elements are: scalars before elements, and sender's value before recipient's value. So from each peer's perspective, it would generate:",
      "ja": "コミット交換は、ランダム関数の出力であるデータの交換、H()、鍵確認キー、およびコミット交換で交換される2つのスカラーと2つの要素で構成されます。 スカラーと要素の順序は、要素の前のスカラーと、受信者の値の前の送信者の値です。 したがって、各ピアの観点からは、以下を生成します。"
    },
    {
      "indent": 16,
      "text": "confirm = H(kck | scalar | peer-scalar |\n            Element | Peer-Element | <sender-id>)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Where <sender-id> is the identity of the sender of the confirm message. This identity SHALL be that contributed by the sender of the confirm message in generation of the base in Section 3.2.",
      "ja": "<sender-id>は、確認メッセージの送信者のIDです。 このアイデンティティは、セクション3.2のベースの生成において確認メッセージの送信者によって提供されたものでなければならない（SHALL）。"
    },
    {
      "indent": 3,
      "text": "The two peers exchange these confirmations and verify the correctness of the other peer's confirmation that they receive. If the other peer's confirmation is valid, authentication succeeds; if the other peer's confirmation is not valid, authentication fails.",
      "ja": "2つのピアはこれらの確認を交換し、受信した他のピアの確認の正当性を確認します。 他のピアの確認が有効な場合、認証は成功します。 他のピアの確認が有効でない場合、認証は失敗します。"
    },
    {
      "indent": 3,
      "text": "If authentication fails, all ephemeral state created as part of the particular run of the Dragonfly exchange MUST be irretrievably destroyed. If authentication does not fail, mk can be exported as an authenticated and secret key that can be used by another protocol, for instance IPsec, to protect other data.",
      "ja": "認証が失敗した場合、Dragonfly交換の特定の実行の一部として作成されたすべての一時的な状態は、回復不能に破壊されなければなりません。 認証が失敗しない場合、mkは、他のデータを保護するために、たとえばIPsecなどの別のプロトコルで使用できる認証済みの秘密鍵としてエクスポートできます。"
    },
    {
      "indent": 0,
      "text": "4. Security Considerations",
      "section_title": true,
      "ja": "4. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "The Dragonfly exchange requires both participants to have an identical representation of the password. Salting of the password merely generates a new credential -- the salted password -- that must be identically represented on both sides. If an adversary is able to gain access to the database of salted passwords, she would be able to impersonate one side to the other, even if she was unable to determine the underlying, unsalted password.",
      "ja": "Dragonfly交換では、両方の参加者が同じパスワード表現を持っている必要があります。 パスワードのソルトは、新しい資格情報（ソルトパスワード）を生成するだけです。これは、両側で同じように表されなければなりません。 攻撃者がソルトパスワードのデータベースにアクセスできる場合、基礎となるソルトされていないパスワードを特定できなかったとしても、攻撃者は一方を他方に偽装することができます。"
    },
    {
      "indent": 3,
      "text": "Resistance to dictionary attack means that an adversary must launch an active attack to make a single guess at the password. If the size of the dictionary from which the password was extracted was d, and each password in the dictionary has an equal probability of being chosen, then the probability of success after a single guess is 1/d. After x guesses, and removal of failed guesses from the pool of possible passwords, the probability becomes 1/(d-x). As x grows, so does the probability of success. Therefore, it is possible for an adversary to determine the password through repeated brute-force, active, guessing attacks. Users of the Dragonfly key exchange SHOULD ensure that the size of the pool from which the password was drawn, d, is sufficiently large to make this attack preventable. Implementations of Dragonfly SHOULD support countermeasures to deal with this attack -- for instance, by refusing authentication attempts for a certain amount of time, after the number of failed authentication attempts reaches a certain threshold. No such threshold or amount of time is recommended in this memo.",
      "ja": "辞書攻撃に対する抵抗とは、攻撃者がアクティブな攻撃を開始してパスワードを推測する必要があることを意味します。パスワードが抽出された辞書のサイズがdであり、辞書内の各パスワードが選択される確率が等しい場合、1回の推測後の成功の確率は1 / dです。 x回推測し、可能なパスワードのプールから失敗した推測を削除すると、確率は1 /（d-x）になります。 xが大きくなると、成功の確率も大きくなります。したがって、攻撃者は、ブルートフォースのアクティブな推測攻撃を繰り返してパスワードを決定することができます。 Dragonfly鍵交換のユーザーは、パスワードの抽出元のプールのサイズdがこの攻撃を防止できるように十分に大きいことを確認する必要があります。 Dragonflyの実装は、この攻撃に対処するための対策をサポートする必要があります（たとえば、失敗した認証試行回数が特定のしきい値に達した後、一定時間認証試行を拒否するなど）。このメモでは、このようなしきい値や時間は推奨されていません。"
    },
    {
      "indent": 3,
      "text": "Due to the problems with using groups that contain a small subgroup, it is RECOMMENDED that implementations of Dragonfly not allow for the specification of a group's complete domain parameter to be sent in-line, but instead use a common repository and pass an identifier to a domain parameter set whose strength has been rigorously proven and that does not have small subgroups. If a group's complete domain parameter set is passed in-line, it SHOULD NOT be used with Dragonfly unless it directly matches a known good group.",
      "ja": "小さなサブグループを含むグループを使用すると問題が発生するため、Dragonflyの実装では、グループの完全なドメインパラメータの指定をインラインで送信できず、代わりに共通リポジトリを使用して識別子を渡すことが推奨されます 強度が厳密に証明されており、小さなサブグループがないドメインパラメータセット。 グループの完全なドメインパラメータセットがインラインで渡される場合、既知の適切なグループと直接一致しない限り、Dragonflyで使用しないでください。"
    },
    {
      "indent": 3,
      "text": "It is RECOMMENDED that an implementation set the security parameter, k, to a value of at least forty (40) which will put the probability that more than forty iterations are needed in the order of one in one trillion (1:1,000,000,000,000).",
      "ja": "実装では、セキュリティパラメータkを少なくとも40の値に設定することをお勧めします。これにより、40を超える反復が1兆分の1（1：1,000,000,000,000）のオーダーで必要になる確率が高くなります。"
    },
    {
      "indent": 3,
      "text": "The technique used to obtain the Password Element in Section 3.2.1 addresses side-channel attacks in a manner deemed controversial by some reviewers in the CFRG. An alternate method, such as the one defined in [hash2ec], can be used to alleviate concerns.",
      "ja": "セクション3.2.1でパスワード要素を取得するために使用される技術は、CFRGの一部のレビュー担当者によって議論の余地があると見なされる方法でサイドチャネル攻撃に対処します。 [hash2ec]で定義されているような代替方法を使用して、懸念を軽減することができます。"
    },
    {
      "indent": 3,
      "text": "This key exchange protocol has received cryptanalysis in [clarkehao]. [lanskro] provides a security proof of Dragonfly in the random oracle model when both identities are included in the data sent in the Confirm Exchange (see Section 3.4).",
      "ja": "この鍵交換プロトコルは、[clarkehao]で暗号解読を受け取りました。 [lanskro]は、Exchangeの確認で送信されるデータに両方のIDが含まれる場合、ランダムオラクルモデルでDragonflyのセキュリティ証明を提供します（セクション3.4を参照）。"
    },
    {
      "indent": 0,
      "text": "5. References",
      "section_title": true,
      "ja": "5. 参照資料"
    },
    {
      "indent": 0,
      "text": "5.1. Normative References",
      "section_title": true,
      "ja": "5.1. 規範的参考文献"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] Bradner、S.、「要求レベルを示すためにRFCで使用するキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<http://www.rfc-editor.org/info/ rfc2119>。"
    },
    {
      "indent": 0,
      "text": "5.2. Informative References",
      "section_title": true,
      "ja": "5.2. 参考資料"
    },
    {
      "indent": 3,
      "text": "[clarkehao] Clarke, D. and F. Hao, \"Cryptanalysis of the Dragonfly Key Exchange Protocol\", IET Information Security, Volume 8, Issue 6, DOI 10.1049/iet-ifs.2013.0081, November 2014.",
      "ja": "[clarkehao] Clarke、D.およびF. Hao、「Cryptanalysis of the Dragonfly Key Exchange Protocol」、IET Information Security、Volume 8、Issue 6、DOI 10.1049 / iet-ifs.2013.0081、2014年11月。"
    },
    {
      "indent": 3,
      "text": "[FIPS186-4] NIST, \"Digital Signature Standard (DSS)\", Federal Information Processing Standard (FIPS) 186-4, DOI 10.6028/NIST.FIPS.186-4, July 2013.",
      "ja": "[FIPS186-4] NIST、「デジタル署名標準（DSS）」、連邦情報処理標準（FIPS）186-4、DOI 10.6028 / NIST.FIPS.186-4、2013年7月。"
    },
    {
      "indent": 3,
      "text": "[hash2ec] Brier, E., Coron, J-S., Icart, T., Madore, D., Randriam, H., and M. Tibouchi, \"Efficient Indifferentiable Hashing into Ordinary Elliptic Curves\", Cryptology ePrint Archive Report 2009/340, 2009.",
      "ja": "[hash2ec] Brier、E.、Coron、JS。、Icart、T.、Madore、D.、Randriam、H.、およびM. Tibouchi、 \"効率的な微分不可能なハッシュを通常の楕円曲線に変換する\"、Cryptology ePrint Archive Report 2009/340 、2009年。"
    },
    {
      "indent": 3,
      "text": "[lanskro] Lancrenon, J. and M. Skrobot, \"On the Provable Security of the Dragonfly Protocol\", Proceedings of 18th International Information Security Conference (ISC 2015), pp 244-261, DOI 10.1007/978-3-319-23318-5_14, September 2015.",
      "ja": "[lanskro] Lancrenon、J。およびM. Skrobot、「トンボプロトコルの証明可能なセキュリティについて」、第18回国際情報セキュリティ会議の議事録（ISC 2015）、pp 244-261、DOI 10.1007 / 978-3-319-23318 -5_14、2015年9月。"
    },
    {
      "indent": 3,
      "text": "[RANDOR] Bellare, M. and P. Rogaway, \"Random Oracles are Practical: A Paradigm for Designing Efficient Protocols\", Proceedings of the 1st ACM Conference on Computer and Communication Security, ACM Press, DOI 10.1145/168588.168596, 1993.",
      "ja": "[RANDOR] Bellare、M.、P。Rogaway、「Random Oracles are Practical：A Paradigm for Designing Efficient Protocols」、Proceedings of the 1st ACM Conference on Computer and Communication Security、ACM Press、DOI 10.1145 / 168588.168596、1993。"
    },
    {
      "indent": 3,
      "text": "[RFC5433] Clancy, T. and H. Tschofenig, \"Extensible Authentication Protocol - Generalized Pre-Shared Key (EAP-GPSK) Method\", RFC 5433, DOI 10.17487/RFC5433, February 2009, <http://www.rfc-editor.org/info/rfc5433>.",
      "ja": "[RFC5433] Clancy、T。およびH. Tschofenig、「拡張認証プロトコル-汎用事前共有キー（EAP-GPSK）メソッド」、RFC 5433、DOI 10.17487 / RFC5433、2009年2月、<http：//www.rfc- editor.org/info/rfc5433>。"
    },
    {
      "indent": 3,
      "text": "[RFC6090] McGrew, D., Igoe, K., and M. Salter, \"Fundamental Elliptic Curve Cryptography Algorithms\", RFC 6090, DOI 10.17487/RFC6090, February 2011, <http://www.rfc-editor.org/info/rfc6090>.",
      "ja": "[RFC6090] McGrew、D.、Igoe、K。、およびM. Salter、「Fundamental Elliptic Curve Cryptography Algorithms」、RFC 6090、DOI 10.17487 / RFC6090、2011年2月、<http://www.rfc-editor.org/ info / rfc6090>。"
    },
    {
      "indent": 3,
      "text": "[RFC7296] Kaufman, C., Hoffman, P., Nir, Y., Eronen, P., and T. Kivinen, \"Internet Key Exchange Protocol Version 2 (IKEv2)\", STD 79, RFC 7296, DOI 10.17487/RFC7296, October 2014, <http://www.rfc-editor.org/info/rfc7296>.",
      "ja": "[RFC7296] Kaufman、C.、Hoffman、P.、Nir、Y.、Eronen、P。、およびT. Kivinen、「インターネットキー交換プロトコルバージョン2（IKEv2）」、STD 79、RFC 7296、DOI 10.17487 / RFC7296 、2014年10月、<http://www.rfc-editor.org/info/rfc7296>。"
    },
    {
      "indent": 3,
      "text": "[SP800-108] Chen, L., \"Recommendation for Key Derivation Using Pseudorandom Functions\", NIST Special Publication 800-108, October 2009.",
      "ja": "[SP800-108] Chen、L。、「疑似ランダム関数を使用した鍵導出の推奨事項」、NIST Special Publication 800-108、2009年10月。"
    },
    {
      "indent": 3,
      "text": "[SP800-56A] Barker, E., Johnson, D., and M. Smid, \"Recommendation for Pair-Wise Key Establishment Schemes Using Discrete Logarithm Cryptography (Revised)\", NIST Special Publication 800-56A, March 2007.",
      "ja": "[SP800-56A] Barker、E.、Johnson、D。、およびM. Smid、「離散対数暗号化を使用したペアワイズ鍵確立スキームの推奨（改訂）」、NIST Special Publication 800-56A、2007年3月。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "The author would like to thank Kevin Igoe and David McGrew, chairmen of the Crypto Forum Research Group (CFRG) for agreeing to accept this memo as a CFRG work item. Additional thanks go to Scott Fluhrer and Hideyuki Suzuki for discovering attacks against earlier versions of this key exchange and suggesting fixes to address them. Lily Chen provided helpful discussions on hashing into an elliptic curve. Rich Davis suggested the validation steps used on received elements to prevent a small subgroup attack. Dylan Clarke and Feng Hao discovered a dictionary attack against Dragonfly if those checks are not made and a group with a small subgroup is used. And finally, a very heartfelt thanks to Jean Lancrenon and Marjan Skrobot for developing a proof of the security of Dragonfly.",
      "ja": "著者は、このメモをCFRG作業項目として受け入れることに同意してくれた、暗号フォーラム研究グループ（CFRG）の議長であるKevin IgoeとDavid McGrewに感謝します。 この鍵交換の以前のバージョンに対する攻撃を発見し、それらに対処するための修正を提案してくれたScott FluhrerとHideyuki Suzukiに感謝します。 リリー・チェンは、楕円曲線へのハッシングに関する有益な議論を提供しました。 リッチデイビスは、小さなサブグループ攻撃を防ぐために、受け取った要素で使用される検証手順を提案しました。 Dylan ClarkeとFeng Haoは、これらのチェックが行われず、小さなサブグループを持つグループが使用されている場合、Dragonflyに対する辞書攻撃を発見しました。 そして最後に、Dragonflyのセキュリティの証拠を開発してくれたJean LancrenonとMarjan Skrobotに心から感謝します。"
    },
    {
      "indent": 3,
      "text": "The blinding scheme to prevent side-channel attacks when determining whether a value is a quadratic residue modulo a prime was suggested by Scott Fluhrer. Kevin Igoe suggested addition of the security parameter k to hide the amount of time taken hunting and pecking for the password element.",
      "ja": "値が素数を法とする二次剰余であるかどうかを判断する際にサイドチャネル攻撃を防ぐブラインド方式が、Scott Fluhrerによって提案されました。 Kevin Igoeは、セキュリティ要素kを追加して、パスワード要素の探索と突っ込みにかかる時間を隠すことを提案しました。"
    },
    {
      "indent": 0,
      "text": "Author's Address",
      "ja": "著者の住所"
    },
    {
      "indent": 3,
      "text": "Dan Harkins (editor) Aruba Networks 1322 Crossman Avenue Sunnyvale, CA 94089-1113 United States",
      "ja": "Dan Harkins（編集者）Aruba Networks 1322 Crossman Avenue Sunnyvale、CA 94089-1113アメリカ合衆国"
    },
    {
      "indent": 3,
      "text": "Email: dharkins@arubanetworks.com",
      "ja": "メール：dharkins@arubanetworks.com"
    }
  ]
}
