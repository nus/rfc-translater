{
  "title": {
    "text": "RFC 7609 - IBM's Shared Memory Communications over RDMA (SMC-R) Protocol",
    "ja": "RFC 7609 - RDMAを超えるIBMの共有メモリ・コミュニケーションズ（SMC-R）プロトコル"
  },
  "number": 7609,
  "created_at": "2019-10-31 03:54:30.753965+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Independent Submission                                            M. Fox\nRequest for Comments: 7609                                   C. Kassimis\nCategory: Informational                                       J. Stevens\nISSN: 2070-1721                                                      IBM\n                                                             August 2015",
      "raw": true
    },
    {
      "indent": 5,
      "text": "IBM's Shared Memory Communications over RDMA (SMC-R) Protocol",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document describes IBM's Shared Memory Communications over RDMA (SMC-R) protocol. This protocol provides Remote Direct Memory Access (RDMA) communications to TCP endpoints in a manner that is transparent to socket applications. It further provides for dynamic discovery of partner RDMA capabilities and dynamic setup of RDMA connections, as well as transparent high availability and load balancing when redundant RDMA network paths are available. It maintains many of the traditional TCP/IP qualities of service such as filtering that enterprise users demand, as well as TCP socket semantics such as urgent data.",
      "ja": "この文書では、RDMAを超えるIBMの共有メモリ・コミュニケーションズ（SMC-R）プロトコルを記述しています。このプロトコルは、ソケット・アプリケーションに対して透過的な方法でTCPエンドポイントへのリモートダイレクトメモリアクセス（RDMA）通信を提供します。冗長なRDMAネットワークパスが利用可能な場合には、さらにパートナーのRDMA機能とRDMA接続の動的な設定のダイナミックな発見だけでなく、透明性、高可用性と負荷分散のために用意されています。これは、企業ユーザーが求めるフィルタリング等のサービスの伝統的なTCP / IPの資質の多く、ならびに緊急データとしてTCPソケットのセマンティクスを維持します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "ja": "このドキュメントはインターネット標準化過程仕様ではありません。それは、情報提供の目的のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This is a contribution to the RFC Series, independently of any other RFC stream. The RFC Editor has chosen to publish this document at its discretion and makes no statement about its value for implementation or deployment. Documents approved for publication by the RFC Editor are not a candidate for any level of Internet Standard; see Section 2 of RFC 5741.",
      "ja": "これは、独立して、他のRFCストリームの、RFCシリーズへの貢献です。 RFC Editorはその裁量でこの文書を公開することを選択し、実装や展開のためにその値についての声明を出すていません。 RFC編集者によって公表のために承認されたドキュメントは、インターネット標準の任意のレベルの候補ではありません。 RFC 5741のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7609.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7609で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2015 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2015 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................5\n   1.1. Protocol Overview ..........................................6\n        1.1.1. Hardware Requirements ...............................8\n   1.2. Definition of Common Terms .................................8\n   1.3. Conventions Used in This Document .........................11\n2. Link Architecture ..............................................11\n   2.1. Remote Memory Buffers (RMBs) ..............................12\n   2.2. SMC-R Link Groups .........................................18\n        2.2.1. Link Group Types ...................................18\n        2.2.2. Maximum Number of Links in Link Group ..............21\n        2.2.3. Forming and Managing Link Groups ...................23\n        2.2.4. SMC-R Link Identifiers .............................24\n   2.3. SMC-R Resilience and Load Balancing .......................24\n3. SMC-R Rendezvous Architecture ..................................26\n   3.1. TCP Options ...............................................26\n   3.2. Connection Layer Control (CLC) Messages ...................27\n   3.3. LLC Messages ..............................................27\n   3.4. CDC Messages ..............................................29\n   3.5. Rendezvous Flows ..........................................29\n        3.5.1. First Contact ......................................29\n               3.5.1.1. Pre-negotiation of TCP Options ............29\n               3.5.1.2. Client Proposal ...........................30\n               3.5.1.3. Server Acceptance .........................32\n               3.5.1.4. Client Confirmation .......................32\n               3.5.1.5. Link (QP) Confirmation ....................32\n               3.5.1.6. Second SMC-R Link Setup ...................35\n                        3.5.1.6.1. Client Processing of ADD LINK\n                                   LLC Message from Server ........35\n                        3.5.1.6.2. Server Processing of ADD LINK\n                                   Reply LLC Message from Client ..36\n                        3.5.1.6.3. Exchange of RKeys on\n                                   Second SMC-R Link ..............38\n                        3.5.1.6.4. Aborting SMC-R and\n                                   Falling Back to IP .............38",
      "raw": true
    },
    {
      "indent": 3,
      "text": "        3.5.2. Subsequent Contact .................................38\n               3.5.2.1. SMC-R Proposal ............................39\n               3.5.2.2. SMC-R Acceptance ..........................40\n               3.5.2.3. SMC-R Confirmation ........................41\n               3.5.2.4. TCP Data Flow Race with SMC\n                        Confirm CLC Message .......................41\n        3.5.3. First Contact Variation: Creating a\n               Parallel Link Group ................................42\n        3.5.4. Normal SMC-R Link Termination ......................43\n        3.5.5. Link Group Management Flows ........................44\n               3.5.5.1. Adding and Deleting Links in an\n                        SMC-R Link Group ..........................44\n                        3.5.5.1.1. Server-Initiated ADD\n                                   LINK Processing ................45\n                        3.5.5.1.2. Client-Initiated ADD\n                                   LINK Processing ................45\n                        3.5.5.1.3. Server-Initiated DELETE\n                                   LINK Processing ................46\n                        3.5.5.1.4. Client-Initiated DELETE\n                                   LINK Request ...................48\n               3.5.5.2. Managing Multiple RKeys over\n                        Multiple SMC-R Links in a Link Group ......49\n                        3.5.5.2.1. Adding a New RMB to an\n                                   SMC-R Link Group ...............50\n                        3.5.5.2.2. Deleting an RMB from an\n                                   SMC-R Link Group ...............53\n                        3.5.5.2.3. Adding a New SMC-R Link to a\n                                   Link Group with Multiple RMBs ..54\n               3.5.5.3. Serialization of LLC Exchanges,\n                        and Collisions ............................56\n                        3.5.5.3.1. Collisions with ADD\n                                   LINK / CONFIRM LINK Exchange ...57\n                        3.5.5.3.2. Collisions during\n                                   DELETE LINK Exchange ...........58\n                        3.5.5.3.3. Collisions during\n                                   CONFIRM RKEY Exchange ..........59\n4. SMC-R Memory-Sharing Architecture ..............................60\n   4.1. RMB Element Allocation Considerations .....................60\n   4.2. RMB and RMBE Format .......................................60\n   4.3. RMBE Control Information ..................................60\n   4.4. Use of RMBEs ..............................................61\n        4.4.1. Initializing and Accessing RMBEs ...................61\n        4.4.2. RMB Element Reuse and Conflict Resolution ..........62\n   4.5. SMC-R Protocol Considerations .............................63\n        4.5.1. SMC-R Protocol Optimized Window Size Updates .......63\n        4.5.2. Small Data Sends ...................................64\n        4.5.3. TCP Keepalive Processing ...........................65",
      "raw": true
    },
    {
      "indent": 3,
      "text": "   4.6. TCP Connection Failover between SMC-R Links ...............67\n        4.6.1. Validating Data Integrity ..........................67\n        4.6.2. Resuming the TCP Connection on a New SMC-R Link ....68\n   4.7. RMB Data Flows ............................................69\n        4.7.1. Scenario 1: Send Flow, Window Size Unconstrained ...69\n        4.7.2. Scenario 2: Send/Receive Flow, Window Size\n               Unconstrained ......................................71\n        4.7.3. Scenario 3: Send Flow, Window Size Constrained .....72\n        4.7.4. Scenario 4: Large Send, Flow Control, Full\n               Window Size Writes .................................74\n        4.7.5. Scenario 5: Send Flow, Urgent Data, Window\n               Size Unconstrained .................................77\n        4.7.6. Scenario 6: Send Flow, Urgent Data, Window\n               Size Closed ........................................79\n   4.8. Connection Termination ....................................81\n        4.8.1. Normal SMC-R Connection Termination Flows ..........81\n        4.8.2. Abnormal SMC-R Connection Termination Flows ........86\n        4.8.3. Other SMC-R Connection Termination Conditions ......88\n5. Security Considerations ........................................89\n   5.1. VLAN Considerations .......................................89\n   5.2. Firewall Considerations ...................................89\n   5.3. Host-Based IP Filters .....................................89\n   5.4. Intrusion Detection Services ..............................90\n   5.5. IP Security (IPsec) .......................................90\n   5.6. TLS/SSL ...................................................90\n6. IANA Considerations ............................................90\n7. Normative References ...........................................91\nAppendix A. Formats ...............................................92\n  A.1. TCP Option .................................................92\n  A.2. CLC Messages ...............................................92\n       A.2.1. Peer ID Format ......................................93\n       A.2.2. SMC Proposal CLC Message Format .....................94\n       A.2.3. SMC Accept CLC Message Format .......................98\n       A.2.4. SMC Confirm CLC Message Format .....................102\n       A.2.5. SMC Decline CLC Message Format .....................105\n  A.3. LLC Messages ..............................................106\n       A.3.1. CONFIRM LINK LLC Message Format ....................107\n       A.3.2. ADD LINK LLC Message Format ........................109\n       A.3.3. ADD LINK CONTINUATION LLC Message Format ...........112\n       A.3.4. DELETE LINK LLC Message Format .....................115\n       A.3.5. CONFIRM RKEY LLC Message Format ....................117\n       A.3.6. CONFIRM RKEY CONTINUATION LLC Message Format .......120\n       A.3.7. DELETE RKEY LLC Message Format .....................122\n       A.3.8. TEST LINK LLC Message Format .......................124\n  A.4. Connection Data Control (CDC) Message Format ..............125",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Appendix B. Socket API Considerations ............................129\n  B.1. setsockopt() / getsockopt() Considerations ................130\nAppendix C. Rendezvous Error Scenarios ...........................131\n  C.1. SMC Decline during CLC Negotiation ........................131\n  C.2. SMC Decline during LLC Negotiation ........................131\n  C.3. The SMC Decline Window ....................................133\n  C.4. Out-of-Sync Conditions during SMC-R Negotiation ...........133\n  C.5. Timeouts during CLC Negotiation ...........................134\n  C.6. Protocol Errors during CLC Negotiation ....................134\n  C.7. Timeouts during LLC Negotiation ...........................135\n       C.7.1. Recovery Actions for LLC Timeouts and Failures .....136\n  C.8. Failure to Add Second SMC-R Link to a Link Group ..........142\nAuthors' Addresses ...............................................143",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "This document specifies IBM's Shared Memory Communications over RDMA (SMC-R) protocol. SMC-R is a protocol for Remote Direct Memory Access (RDMA) communication between TCP socket endpoints. SMC-R runs over networks that support RDMA over Converged Ethernet (RoCE). It is designed to permit existing TCP applications to benefit from RDMA without requiring modifications to the applications or predefinition of RDMA partners.",
      "ja": "この文書では、IBMの共有メモリ・コミュニケーションズRDMAオーバー（SMC-R）プロトコルを指定します。 SMC-Rは、TCPソケットのエンドポイント間のリモートダイレクトメモリアクセス（RDMA）通信するためのプロトコルです。 SMC-Rは、コンバージド・イーサネット（ROCE）上でRDMAをサポートするネットワーク上で実行されます。 RDMAパートナーのアプリケーションや事前定義の変更を必要とせずにRDMAの恩恵を受けるために、既存のTCPアプリケーションを可能にするように設計されています。"
    },
    {
      "indent": 3,
      "text": "SMC-R provides dynamic discovery of the RDMA capabilities of TCP peers and automatic setup of RDMA connections that those peers can use. SMC-R also provides transparent high availability and load-balancing capabilities that are demanded by enterprise installations but are missing from current RDMA protocols. If redundant RoCE-capable hardware such as RDMA-capable Network Interface Cards (RNICs) and RoCE-capable switches is present, SMC-R can load-balance over that redundant hardware and can also non-disruptively move TCP traffic from failed paths to surviving paths, all seamlessly to the application and the sockets layer. Because SMC-R preserves socket semantics and the TCP three-way handshake, many TCP qualities of service such as filtering, load balancing, and Secure Socket Layer (SSL) encryption are preserved, as are TCP features such as urgent data.",
      "ja": "SMC-Rは、TCPピアおよびそれらのピアが使用できるRDMA接続の自動設定のRDMA機能の動的な発見を提供します。 SMC-Rは、エンタープライズインストールによって要求されているが、現在のRDMAプロトコルから欠落している透明高可用性と負荷分散機能を提供します。そのようなRDMA対応ネットワーク・インタフェース・カード（RNICs）冗長ROCE対応ハードウェアおよびROCE対応スイッチが存在する場合、SMC-Rは、冗長ハードウェア上バランスをロードすることができ、また無停止生存に障害が発生したパスからのTCPトラフィックを移動させることができます全てシームレスアプリケーションとソケット層へのパス、。 SMC-Rは、ソケットのセマンティクスと、TCP 3ウェイハンドシェイクを保持しているため、このような緊急データとしてTCPの機能がそうであるように、そのようなフィルタリング、負荷分散、およびセキュア・ソケット・レイヤー（SSL）暗号化などのサービスの多くのTCP品質が保持されます。"
    },
    {
      "indent": 3,
      "text": "Because of the dynamic discovery and setup of SMC-R connectivity between peers, no RDMA connection manager (RDMA-CM) is required. This also means that support for Unreliable Datagram (UD) Queue Pairs (QPs) is also not required.",
      "ja": "なぜならピア間SMC-R接続の動的な発見とセットアップ、何RDMA接続マネージャ（RDMA-CM）が必要とされません。これはまた、信頼できないデータグラム（UD）キューペア（のQP）のサポートも必要とされていないことを意味します。"
    },
    {
      "indent": 3,
      "text": "It is recommended that the SMC-R services be implemented in kernel space, which enables optimizations such as resource-sharing between connections across multiple processes and also permits applications using SMC-R to spawn multiple processes (e.g., fork) without losing SMC-R functionality. A user-space implementation is compatible with this architecture, but it may not support spawned processes (e.g., fork), which limits sharing and resource optimization to TCP connections that originate from the same process. This might be an appropriate design choice if the use case is a system that hosts a large single process application that creates many TCP connections to a peer host, or in implementations where a kernel-space implementation is not possible or introduces excessive overhead for \"kernel space to user space\" context switches.",
      "ja": "SMC-Rを失うことなく、SMC-Rのサービスは、複数のプロセス間の接続との間の資源共有のような最適化を可能にし、また、複数のプロセス（例えば、フォーク）をスポーンするSMC-Rを使用してアプリケーションを可能にするカーネル空間で実装することが推奨されます機能。ユーザ空間の実装では、このアーキテクチャと互換性があり、それが生成されたプロセスと同じプロセスを起源とTCP接続を共有し、リソース最適化を制限する（例えば、フォーク）を、サポートしていてもよいです。これは、ユースケースは、ピア・ホストに多くのTCP接続を作成し、大規模な単一のプロセスアプリケーションをホストするシステムである場合、またはカーネル空間の実装が可能ではないか、カーネル「のために、過剰なオーバーヘッドを紹介する実装で適切な設計上の選択であるかもしれませんユーザ空間」コンテキストスイッチにスペース。"
    },
    {
      "indent": 0,
      "text": "1.1. Protocol Overview",
      "section_title": true,
      "ja": "1.1。プロトコルの概要"
    },
    {
      "indent": 3,
      "text": "SMC-R defines the concept of the SMC-R link, which is a logical point-to-point link using reliably connected queue pairs between TCP/IP stack peers over a RoCE fabric. An SMC-R link is bound to a specific hardware path, meaning a specific RNIC on each peer. SMC-R links are created and maintained by an SMC-R layer, which may reside in kernel space or user space, depending upon operating system and implementation requirements. The SMC-R layer resides below the sockets layer and directs data traffic for TCP connections between connected peers over the RoCE fabric using RDMA rather than over a TCP connection. The TCP/IP stack, with its requirements for fragmentation, packetization, etc., is bypassed, and the application data is moved between peers using RDMA.",
      "ja": "SMC-RはROCEファブリック上にTCP / IPスタックピア間確実に接続されたキュー・ペアを使用して論理ポイントツーポイントリンクであるSMC-Rリンクの概念を定義します。 SMC-Rリンクは、各ピア上の特定のRNICを意味し、特定のハードウェア・パスにバインドされています。 SMC-Rリンクは、オペレーティングシステムと実施要件に応じて、カーネル空間またはユーザー空間に存在してもよいSMC-R層、によって作成され、維持されます。 SMC-R層は、ソケット層の下に存在し、TCP接続を介してRDMAを使用しなくROCEファブリックを介して接続されたピア間のTCP接続のためのデータトラフィックを向けます。 TCP / IPスタックは、などの断片化、パケット化、のためにその要件と、バイパスされ、アプリケーションデータは、RDMAを使用してピア間で移動されます。"
    },
    {
      "indent": 3,
      "text": "Multiple SMC-R links between the same two TCP/IP stack peers are also supported. A set of SMC-R links called a link group can be logically bonded together to provide redundant connectivity. If there is redundant hardware -- for example, two RNICs on each peer -- separate SMC-R links are created between the peers to exploit that redundant hardware. The link group architecture with redundant links provides load balancing and increased bandwidth, as well as seamless failover.",
      "ja": "同じ2つのTCP / IPの間に複数のSMC-Rリンクはピアもサポートされているスタック。リンクグループと呼ばれるSMC-Rリンクのセットは、論理的に冗長接続を提供するために一緒に結合させることができます。冗長ハードウェアがある場合 - 例えば、各ピア上の2つのRNICs  - は別個SMC-Rリンクは、冗長ハードウェアを利用するためにピア間で作成されます。冗長リンクとリンクグループアーキテクチャは、負荷分散と帯域幅の増加だけでなく、シームレスなフェイルオーバーを提供します。"
    },
    {
      "indent": 3,
      "text": "Each SMC-R link group is associated with an area of memory called Remote Memory Buffers (RMBs), which are areas of memory that are available for SMC-R peers to write into using RDMA writes. Multiple TCP connections between peers may be multiplexed over a single SMC-R link, in which case the SMC-R layer manages the partitioning of the RMBs between the TCP connections. This multiplexing reduces the RDMA resources, such as QPs and RMBs, that are required to support multiple connections between peers, and it also reduces the processing and delays related to setting up QPs, pinning memory, and other RDMA setup tasks when new TCP connections are created. In a kernel-space SMC-R implementation in which the RMBs reside in kernel storage, this sharing and optimization works across multiple processes executing on the same host. In a user-space SMC-R implementation in which the RMBs reside in user space, this sharing and optimization is limited to multiple TCP connections created by a single process, as separate RMBs and QPs will be required for each process.",
      "ja": "各SMC-Rリンク群は、リモートメモリバッファSMC-Rピアが書き込む使用RDMAに書き込むために使用可能なメモリの領域である（RMBS）と呼ばれるメモリのエリアに関連付けられています。ピア間に複数のTCP接続はSMC-R層がTCP接続間RMBSのパーティションを管理する場合には、単一のSMC-Rリンク上で多重化されてもよいです。新しいTCP接続がある場合は、この多重化は、ピア間の複数の接続をサポートするために必要とされるなどのQPやRMBSなどRDMAリソースを、減少させ、それはまたのQPを設定に関する処理や遅延を減少させ、メモリを固定し、他のRDMAのセットアップ作業作成した。 RMBSは、カーネル・ストレージ内に常駐するカーネル空間SMC-Rの実装では、この共有および最適化は、同じホスト上で実行される複数のプロセス間で動作します。別RMBSとのQPは、各プロセスのために必要とされるようにRMBSは、ユーザ空間に存在するユーザ空間SMC-Rの実装では、この共有および最適化は、単一のプロセスによって作成された複数のTCP接続に制限されます。"
    },
    {
      "indent": 3,
      "text": "SMC-R also introduces a rendezvous protocol that is used to dynamically discover the RDMA capabilities of TCP connection partners and exchange credentials necessary to exploit that capability if present. TCP connections are set up using the normal TCP three-way handshake [RFC793], with the addition of a new TCP option that indicates SMC-R capability. If both partners indicate SMC-R capability, then at the completion of the three-way TCP handshake the SMC-R layers in each peer take control of the TCP connection and use it to exchange additional Connection Layer Control (CLC) messages to negotiate SMC-R credentials such as QP information; addressability over the RoCE fabric; RMB buffer sizes; and keys and addresses for accessing RMBs over RDMA. If at any time during this negotiation a failure or decline occurs, the TCP connection falls back to using the IP fabric.",
      "ja": "SMC-Rはまた、動的にTCPコネクションパートナーおよび存在する場合、その機能を利用するために必要な交換資格情報のRDMA機能を発見するために使用されるランデブープロトコルを紹介します。 TCP接続はSMC-Rの能力を示す新しいTCPオプションの追加により、通常のTCP 3ウェイハンドシェイク[RFC793]を使用して設定されています。両方のパートナーは、SMC-Rの能力を示す場合には、三方TCPハンドシェークの完了時それぞれにおけるSMC-Rの層は、TCP接続の制御を取るとSMCを交渉するために追加の接続層制御（CLC）メッセージを交換するためにそれを使用するピアこのようなQP情報として-Rクレデンシャル。 ROCEの生地の上にアドレス指定;人民元のバッファサイズ。そしてキーとRDMA上RMBSにアクセスするためのアドレス。故障や低下が発生し、この交渉中の任意の時点で場合、TCP接続はバックIPファブリックを使用することに落ちます。"
    },
    {
      "indent": 3,
      "text": "If the SMC-R negotiation succeeds and either a new SMC-R link is set up or an existing SMC-R link is chosen for the TCP connection, then the SMC-R layers open the sockets to the applications and the applications use the sockets as normal. The SMC-R layer intercepts the socket reads and writes and moves the TCP connection data over the SMC-R link, \"out of band\" to the TCP connection, which remains open and idle over the IP fabric, except for termination flows and possible keepalive flows. Regular TCP sequence numbering methods are used for the TCP flows that do occur; data flowing over RDMA does not use or affect TCP sequence numbers.",
      "ja": "SMC-Rのネゴシエーションが成功し、新しいSMC-Rのリンクのいずれかが設定されているか、既存のSMC-Rリンクは、TCP接続のために選択された場合は、SMC-R層は、アプリケーションへのソケットを開き、アプリケーションはソケットを使用します普段通り。 SMC-R層は、終端フローと可能性を除いて、ソケットはIPファブリックを介し開き、アイドル状態のままでTCPコネクションに「帯域外」、読み取りと書き込み、SMC-Rのリンク上のTCP接続データを移動させ傍受しますキープアライブが流れます。メソッドの番号正規TCPシーケンスが発生したTCPフローのために使用されています。 RDMA上を流れるデータを使用するか、またはTCPシーケンス番号には影響を与えません。"
    },
    {
      "indent": 3,
      "text": "This architecture does not support fallback of active SMC-R connections to IP. Once connection data has completed the switch to RDMA, a TCP connection cannot be switched back to IP and will reset if RDMA becomes unusable.",
      "ja": "このアーキテクチャは、IPへのアクティブSMC-R接続のフォールバックをサポートしていません。接続データがRDMAへの切り替えを完了すると、TCP接続がIPに戻すことができず、RDMAが使用できなくなった場合にリセットされます。"
    },
    {
      "indent": 3,
      "text": "The SMC-R protocol defines the format of the RMBs that are used to receive TCP connection data written over RDMA, as well as the semantics for managing and writing to these buffers using Connection Data Control (CDC) messages.",
      "ja": "SMC-Rプロトコルは、TCP接続RDMA上に書き込まれたデータ、ならびに管理および接続データコントロール（CDC）メッセージを使用して、これらのバッファに書き込むためのセマンティクスを受信するために使用されているRMBSのフォーマットを定義します。"
    },
    {
      "indent": 3,
      "text": "Finally, SMC-R defines Link Layer Control (LLC) messages that are exchanged over the RoCE fabric between peer SMC-R layers to manage the SMC-R links and link groups. These include messages to test and confirm connectivity over an SMC-R link, add and delete SMC-R links to or from the link group, and exchange RMB addressability information.",
      "ja": "最後に、SMC-Rは、リンクレイヤ制御（LLC）SMC-Rリンク及びリンクグループを管理するために、ピアSMC-R層間ROCEファブリック上で交換されるメッセージを定義します。これらは、テストし、SMC-Rリンクを介して接続を確認、リンクグループにまたはからSMC-Rのリンクを追加および削除するメッセージ、および為替人民元のアドレス指定情報が含まれています。"
    },
    {
      "indent": 0,
      "text": "1.1.1. Hardware Requirements",
      "section_title": true,
      "ja": "1.1.1。ハードウェア要件"
    },
    {
      "indent": 3,
      "text": "SMC-R does not require full Converged Enhanced Ethernet switch functionality. SMC-R functions over standard Ethernet fabrics, provided that endpoint RNICs are provided and IEEE 802.3x Global Pause Frame is supported and enabled in the switch fabric.",
      "ja": "SMC-Rは、完全なコンバージド・エンハンスト・イーサネット・スイッチの機能を必要としません。標準のイーサネットファブリック上SMC-R機能は、エンドポイントRNICsが提供され、IEEE 802.3Xグローバル・ポーズフレームがサポートされており、スイッチファブリックで有効になっていることを条件とします。"
    },
    {
      "indent": 3,
      "text": "While SMC-R as specified in this document is designed to operate over RoCE fabrics, adjustments to the rendezvous methods could enable it to run over other RDMA fabrics, such as InfiniBand [RoCE] and iWARP.",
      "ja": "この文書で指定されているSMC-Rは、ROCEファブリックで動作するように設計されているが、ランデブー方法の調整は、例えば、インフィニ[ROCE]とiWARPのような他のRDMA織物、上で動作することを可能にすることができます。"
    },
    {
      "indent": 0,
      "text": "1.2. Definition of Common Terms",
      "section_title": true,
      "ja": "1.2。一般的な用語の定義"
    },
    {
      "indent": 3,
      "text": "This section provides definitions of terms that have a specific meaning to the SMC-R protocol and are used throughout this document.",
      "ja": "このセクションでは、SMC-Rプロトコルに特定の意味を持っており、このドキュメントで使用されている用語の定義を提供します。"
    },
    {
      "indent": 3,
      "text": "SMC-R Link",
      "ja": "SMC-Rリンク"
    },
    {
      "indent": 6,
      "text": "An SMC-R link is a logical point-to-point connection over the RoCE fabric via specific physical adapters (Media Access Control / Global Identifier (MAC/GID)). The link is formed during the \"first contact\" sequence of the TCP/IP three-way handshake sequence that occurs over the IP fabric. During this handshake, an RDMA reliably connected queue pair (RC-QP) connection is formed between the two peer SMC hosts and is defined as the SMC-R link. The SMC-R link can then support multiple TCP connections between the two peers. An SMC-R link is associated with a single LAN (or VLAN) segment and is not routable.",
      "ja": "SMC-Rリンクは、特定の物理アダプタ（メディアアクセス制御/グローバル識別子（MAC / GID））を介してROCEファブリック上の論理ポイントツーポイント接続です。リンクは、IPファブリック上で発生したTCP / IPスリーウェイハンドシェイクシーケンスの「最初の接触」シーケンスの間に形成されています。このハンドシェイク中に、確実にキュー・ペアを接続RDMAは、（RC-QP）接続は、2台のピアSMCホストとの間に形成され、SMC-Rリンクとして定義されます。 SMC-Rリンクは、2つのピア間で複数のTCP接続をサポートすることができます。 SMC-Rリンクは、単一のLAN（またはVLAN）セグメントに関連付けられ、ルーティング可能ではありません。"
    },
    {
      "indent": 3,
      "text": "SMC-R Link Group",
      "ja": "SMC-Rリンクグループ"
    },
    {
      "indent": 6,
      "text": "An SMC-R link group is a group of SMC-R links between the same two SMC-R peers, typically with each link over unique RoCE adapters. Each link in the link group has equal characteristics, such as the same VLAN ID (if VLANs are in use), access to the same RMB(s), and access to the same TCP server/client.",
      "ja": "SMC-Rリンク基は、典型的に一意ROCEアダプタ上の各リンクに、同じ2つのSMC-Rピア間SMC-Rリンクのグループです。リンクグループ内の各リンクは、同じVLAN ID（VLANが使用されている場合）、同じRMB（S）へのアクセスと同じTCPサーバ/クライアントへのアクセスと同等の特性を有しています。"
    },
    {
      "indent": 3,
      "text": "SMC-R Peer",
      "ja": "SMC-Rピア"
    },
    {
      "indent": 6,
      "text": "The SMC-R peer is the peer software stack within the peer operating system with respect to the Shared Memory Communications (messaging) protocol.",
      "ja": "SMC-Rピアは共有メモリ通信（メッセージ）プロトコルに対するピア・オペレーティング・システム内のピア・ソフトウェアスタックです。"
    },
    {
      "indent": 3,
      "text": "SMC-R Rendezvous",
      "ja": "SMC-Rランデブー"
    },
    {
      "indent": 6,
      "text": "SMC-R Rendezvous is the SMC-R peer discovery and handshake sequence that occurs transparently over the IP (Ethernet) fabric during and immediately after the TCP connection three-way handshake by exchanging the SMC-R capabilities and credentials using experimental TCP option and CLC messages.",
      "ja": "SMC-Rランデブーは中、すぐにTCPコネクション3ウェイハンドシェイクの後に実験的なTCPオプションとCLCを使用してSMC-Rの能力と資格情報を交換することにより、IP（イーサネット）生地の上に透過的に発生したSMC-Rピア発見と握手シーケンスでありますメッセージ。"
    },
    {
      "indent": 3,
      "text": "RoCE SendMsg",
      "ja": "年にsendmsg"
    },
    {
      "indent": 6,
      "text": "RoCE SendMsg is a send operation posted to a reliably connected queue pair with inline data, for the purpose of transferring control information between peers.",
      "ja": "ROCE SENDMSGは、ピア間で制御情報を転送するために、インラインデータと確実に接続されたキュー・ペアに投稿送信動作です。"
    },
    {
      "indent": 3,
      "text": "TCP Client",
      "ja": "TCPクライアント"
    },
    {
      "indent": 6,
      "text": "The TCP client is the TCP socket-based peer that initiates a TCP connection.",
      "ja": "TCPクライアントは、TCP接続を開始するTCPソケットベースのピアです。"
    },
    {
      "indent": 3,
      "text": "TCP Server",
      "ja": "TCPサーバー"
    },
    {
      "indent": 6,
      "text": "The TCP server is the TCP socket-based peer that accepts a TCP connection.",
      "ja": "TCPサーバは、TCP接続を受け入れるTCPソケットベースのピアです。"
    },
    {
      "indent": 3,
      "text": "CLC Messages",
      "ja": "CLCメッセージ"
    },
    {
      "indent": 6,
      "text": "The SMC-R protocol defines a set of Connection Layer Control messages that flow over the TCP connection that are used to manage SMC-R link rendezvous at TCP connection setup time. This mechanism is analogous to SSL setup messages.",
      "ja": "SMC-Rプロトコルは、TCP接続のセットアップ時にSMC-Rリンクランデブーを管理するために使用されているTCPコネクション上を流れる接続層制御メッセージのセットを定義します。このメカニズムは、SSL設定メッセージに類似しています。"
    },
    {
      "indent": 3,
      "text": "LLC Commands",
      "ja": "LLCコマンド"
    },
    {
      "indent": 6,
      "text": "The SMC-R protocol defines a set of RoCE Link Layer Control commands that flow over the RoCE fabric using RoCE SendMsg, that are used to manage SMC-R links, SMC-R link groups, and SMC-R link group RMB expansion and contraction.",
      "ja": "SMC-Rプロトコルは、SMC-RリンクグループをSMC-Rリンクを管理するために使用されるROCE SENDMSGを用いROCE布、上を流れるROCEリンクレイヤ制御コマンドのセットを定義し、SMC-Rリンク群RMB伸縮。"
    },
    {
      "indent": 3,
      "text": "CDC Message",
      "ja": "CDCのメッセージ"
    },
    {
      "indent": 6,
      "text": "The SMC-R protocol defines a Connection Data Control message that flows over the RoCE fabric using RoCE SendMsg that is used to manage the SMC-R connection data. This message provides information about data being transferred over the out-of-band RDMA connection, such as data cursors, sequence numbers, and data flags (for example, urgent data). The receipt of this message also provides an interrupt to inform the receiver that it has received RDMA data.",
      "ja": "SMC-Rプロトコルは、SMC-Rの接続情報を管理するために使用されROCE SENDMSGを用いROCEファブリック上を流れるデータ接続制御メッセージを定義します。このメッセージは、データカーソル、シーケンス番号、およびデータフラグ（例えば、緊急データ）として、アウトオブバンドRDMA接続を介して転送されるデータに関する情報を提供します。このメッセージの受信はまた、RDMAデータを受信した受信機に通知するための割り込みを提供します。"
    },
    {
      "indent": 3,
      "text": "RMB",
      "ja": "RMB"
    },
    {
      "indent": 6,
      "text": "A Remote (RDMA) Memory Buffer is a fixed or pinned buffer allocated in each of the peer hosts for a TCP (via SMC-R) connection. The RMB is registered to the RNIC and allows remote access by the remote peer using RDMA semantics. Each host is passed the peer's RMB-specific access information (RMB Key (RKey) and RMB element offset) during the SMC-R Rendezvous process. The host stores socket application user data directly into the peer's RMB using RDMA over RoCE.",
      "ja": "（RDMA）リモートメモリバッファは、TCP（SMC-Rを介して）接続のピアホストのそれぞれに割り当てられた固定または固定バッファです。 RMBはRNICに登録し、RDMAセマンティクスを使用してリモートピアによってリモートアクセスを可能にします。各ホストは、SMC-Rランデブー・プロセス中にピアのRMB固有のアクセス情報（RMBキー（RKEY）及びRMB素子オフセット）に渡されます。 ROCE上RDMAを使用して、ピアの元に直接ホスト格納ソケットアプリケーションユーザーデータ。"
    },
    {
      "indent": 3,
      "text": "RToken",
      "ja": "Rとけん"
    },
    {
      "indent": 6,
      "text": "The RToken is the combination of an RMB's RKey and RDMA virtual address. An RToken provides RMB addressability information to an RDMA peer.",
      "ja": "トークンは、人民元のRKEYとRDMA仮想アドレスを組み合わせたものです。そして、eTokenのは、RDMAピアに人民元のアドレス指定情報を提供します。"
    },
    {
      "indent": 3,
      "text": "RMBE",
      "ja": "RMBE"
    },
    {
      "indent": 6,
      "text": "The Remote Memory Buffer Element (RMBE) is an area of an RMB that is allocated to a specific TCP connection. The RMBE contains data for the TCP connection. The RMBE represents the TCP receive buffer, whereby the remote peer writes into the RMBE and the local peer reads from the local RMBE. The alert token resolves to a specific RMBE.",
      "ja": "リモートメモリ・バッファ要素（RMBE）は、特定のTCP接続に割り当てられた元の領域です。 RMBEは、TCP接続のためのデータが含まれています。リモートピアがRMBEに書き込み、ローカルピアがローカルRMBEから読み出すことによりRMBEは、TCP受信バッファを表します。警告トークンは、特定のRMBEに解決されます。"
    },
    {
      "indent": 3,
      "text": "Alert Token",
      "ja": "アラートトークン"
    },
    {
      "indent": 6,
      "text": "The SMC-R alert token is a 4-byte value that uniquely identifies the TCP connection over an SMC-R connection. The alert token allows the SMC peer to quickly identify the target TCP connection that now has new work. The format of the token is defined by the owning SMC-R endpoint and is considered opaque to the remote peer. However, the token should not simply be an index to an RMBE; it should reference a TCP connection and be able to be validated to avoid reading data from stale connections.",
      "ja": "SMC-Rアラートトークンは一意SMC-R接続を介してTCPコネクションを識別する4バイトの値です。警告トークンは、SMCピアがすぐに新しい仕事を持つターゲットTCPコネクションを識別することができます。トークンの形式は、所有SMC-Rエンドポイントによって定義され、リモートピアに対して不透明であると考えられます。しかし、トークンは、単にRMBEへのインデックスではありません。それは、TCPコネクションを参照すると、失効した接続からのデータ読み出しを避けるために検証されることができるはずです。"
    },
    {
      "indent": 3,
      "text": "RNIC",
      "ja": "RNIC"
    },
    {
      "indent": 6,
      "text": "The RDMA-capable Network Interface Card (RNIC) is an Ethernet NIC that supports RDMA semantics and verbs using RoCE.",
      "ja": "RDMA対応のネットワークインターフェイスカード（RNIC）ROCEを使用してRDMAの意味と動詞をサポートしていますイーサネットNICです。"
    },
    {
      "indent": 3,
      "text": "First Contact",
      "ja": "第一接触"
    },
    {
      "indent": 6,
      "text": "\"First contact\" describes an SMC-R negotiation to set up the first link in a link group.",
      "ja": "「最初の接触は、」リンクグループ内の最初のリンクを設定するSMC-Rのネゴシエーションを説明します。"
    },
    {
      "indent": 3,
      "text": "Subsequent Contact",
      "ja": "その後の連絡先"
    },
    {
      "indent": 6,
      "text": "\"Subsequent contact\" describes an SMC-R negotiation between peers who are using an already-existing SMC-R link group.",
      "ja": "「その後の接触は、」既存のSMC-Rリンクグループを使用しているピア間のSMC-Rのネゴシエーションを説明します。"
    },
    {
      "indent": 0,
      "text": "1.3. Conventions Used in This Document",
      "section_title": true,
      "ja": "1.3。このドキュメントの表記規則"
    },
    {
      "indent": 3,
      "text": "In the rendezvous flow diagrams, dashed lines (----) are used to\nindicate flows over the TCP/IP fabric and dotted lines (....) are\nused to indicate flows over the RoCE fabric.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "In the data transfer ladder diagrams, dashed lines (----) are used to\nindicate RDMA write operations and dotted lines (....) are used to\nindicate CDC messages, which are RDMA messages with inline data that\ncontain control information for the connection.",
      "raw": true
    },
    {
      "indent": 0,
      "text": "2. Link Architecture",
      "section_title": true,
      "ja": "2.リンクアーキテクチャ"
    },
    {
      "indent": 3,
      "text": "An SMC-R link is based on reliably connected queue pairs (QPs) that form a \"logical point-to-point link\" between the two SMC-R peers over a RoCE fabric. An SMC-R link extends from SMC-R peer to SMC-R peer, where typically each peer would be a TCP/IP stack and would reside on separate hosts.",
      "ja": "SMC-RリンクはROCEファブリック上の2つのSMC-Rのピアとの間の「論理ポイントツーポイントリンク」を形成確実に接続されたキュー・ペア（のQP）に基づいています。 SMC-Rリンクは、典型的には、各ピアがTCP / IPスタックであろうと、別のホスト上に存在するであろうSMC-RピアにSMC-Rピアから延びています。"
    },
    {
      "indent": 5,
      "text": "                       ,,.--..,_\n+----+             _-``         `-,           +-----+\n|QP 8|            -   RoCE         ',         |QP 64|\n|    |          /     VLAN M         .        |     |\n+----+--------+/                     \\+-------+-----+\n | RNIC 1     |    SMC-R Link         | RNIC 2     |\n |            |<--------------------->|            |\n +------------+ ,                    /+------------+\n         MAC A (GID A)             MAC B (GID B)\n                  .                .`\n                   `',          ,-`\n                      ``''--''``",
      "raw": true
    },
    {
      "indent": 23,
      "text": "Figure 1: SMC-R Link Overview",
      "ja": "図1：SMC-Rリンクの概要"
    },
    {
      "indent": 3,
      "text": "Figure 1 illustrates an overview of the basic concepts of SMC-R peer-to-peer connectivity; this is called the SMC-R link. The SMC-R link forms a logical point-to-point connection between two SMC-R peers via RoCE. The SMC-R link is defined and identified by the following attributes:",
      "ja": "図1は、SMC-Rピアツーピア接続の基本的な概念の概要を示す図です。これは、SMC-Rリンクと呼ばれています。 SMC-RリンクはROCE介して2つのSMC-Rピア間の論理的なポイントツーポイント接続を形成します。 SMC-Rのリンクは次の属性によって定義され、識別されます。"
    },
    {
      "indent": 6,
      "text": "SMC-R link = RC QPs (source VMAC GID QP + target VMAC GID QP + VLAN ID)",
      "ja": "SMC-Rリンク= RCのQP（ソースVMAC GID QP + VMAC GID QP + VLAN IDをターゲット）"
    },
    {
      "indent": 3,
      "text": "The SMC-R link can optionally be associated with a VLAN ID. If VLANs are in use for the associated IP (LAN) connection, then the VLAN attribute is carried over on the SMC-R link. When VLANs are in use, each SMC-R link group is associated with a single and specific VLAN. The RoCE fabric is the same physical Ethernet LAN used for standard TCP/IP-over-Ethernet communications, with switches as described in Section 1.1.1.",
      "ja": "SMC-Rリンクは、必要に応じてVLAN IDに関連付けることができます。 VLANは、関連するIP（LAN）接続のために使用されている場合は、VLAN属性はSMC-Rリンクで持ち越されます。 VLANが使用されている場合、各SMC-Rリンクグループは、単一の、特定のVLANに関連付けられています。 ROCEファブリックは、セクション1.1.1に記載したのと同じ物理イーサネットLANスイッチと、標準のTCP / IP・オーバー・イーサネット通信のために使用されます。"
    },
    {
      "indent": 3,
      "text": "An SMC-R link is designed to support multiple TCP connections between the same two peers. An SMC-R link is intended to be long lived, while the underlying TCP connections can dynamically come and go. The associated RMBs can also be dynamically added and removed from the link as needed. The first TCP connection between the peers establishes the SMC-R link. Subsequent TCP connections then use the previously established link. When the last TCP connection terminates, the link can then be terminated, typically after an implementation-defined idle timeout period has elapsed. The TCP server is responsible for initiating and terminating the SMC-R link.",
      "ja": "SMC-Rのリンクが同じ2つのピア間で複数のTCP接続をサポートするように設計されています。 SMC-Rのリンクは基本的なTCP接続を動的に来て、行くことができますが、長く住んでいたことを意図しています。関連するRMBSも動的に追加し、必要に応じてリンクから削除することができます。ピア間の最初のTCPコネクションは、SMC-Rリンクを確立します。後続のTCPコネクションは、以前に確立されたリンクを使用します。最後のTCP接続が終了すると、リンクは、実装定義のアイドルタイムアウト期間が経過した後に、通常、終了することができます。 TCPサーバは、SMC-Rのリンクを開始し、終了するための責任があります。"
    },
    {
      "indent": 0,
      "text": "2.1. Remote Memory Buffers (RMBs)",
      "section_title": true,
      "ja": "2.1。リモートメモリバッファ（RMBS）"
    },
    {
      "indent": 3,
      "text": "Figure 2 shows the hosts -- Hosts X and Y -- and their associated RMBs within each host. With the SMC-R link, and the associated RKeys and RDMA virtual addresses, each SMC-R-enabled TCP/IP stack can remotely access its peer's RMBs using RDMA. The RKeys and virtual addresses are exchanged during the rendezvous processing when the link is established. The combination of the RKey and the virtual address is the RToken. Note that the SMC-R link ends at the QP providing access to the RMB (via the link + RToken).",
      "ja": "ホストXおよびY  -   - 各ホスト内のその関連RMBS図2は、ホストを示します。 SMC-Rのリンク、および関連するRKeysとRDMA仮想アドレスを使用すると、各SMC-R対応のTCP / IPスタックは、リモートでRDMAを使用して、そのピアのRMBSにアクセスすることができます。 RKeysと仮想アドレスは、リンクが確立されたランデブー処理中に交換されています。 RKEYと仮想アドレスの組み合わせがRTOKENです。 SMC-Rリンクは（リンク+ RTOKEN介して）元へのアクセスを提供QPで終了することに留意されたいです。"
    },
    {
      "indent": 5,
      "text": "     Host X                                     Host Y\n+-------------------+        ,.--.,_       +-------------------+\n|                   |     .'`       '.     |                   |\n| Protection        |   ,'            `,   |    Protection     |\n| Domain X          |  /                \\  |    Domain Y       |\n|            +------+ /                  \\ +------+            |\n|       QP 8 |RNIC 1| |   SMC-R Link     | |RNIC 2|  QP 64     |\n|        |   |      |<-------------------->|      |   |        |\n|        |   |      ||                    ||      |   |        |\n|        |   +------+|    VLAN A          |+------+   |        |\n|        |          ||                    ||          |        |\n|        |          | |   RoCE           | |          |        |\n|        |RToken X  | \\                  / |RToken Y  |        |\n|        |          |  \\                /  |          |        |\n|        V          |   `.            ,'   |          V        |\n| +--------+        |     '._       ,'     |        +--------+ |\n| |        |        |        `''-'``       |        |        | |\n| | RMB    |        |                      |        | RMB    | |\n| |        |        |                      |        |        | |\n| +--------+        |                      |        +--------+ |\n+-------------------+                      +-------------------+",
      "raw": true
    },
    {
      "indent": 23,
      "text": "Figure 2: SMC-R Link and RMBs",
      "ja": "図2：SMC-RリンクおよびRMBS"
    },
    {
      "indent": 3,
      "text": "An SMC-R link can support multiple RMBs that are independently managed by each peer. The number and the size of RMBs are managed by the peers based on the host's unique memory management requirements; however, the maximum number of RMBs that can be associated to a link group on one peer is 255. The QP has a single protection domain, but each RMB has a unique RToken. All RTokens must be exchanged with the peer.",
      "ja": "SMC-Rリンクは、独立して各ピアによって管理される複数のRMBSをサポートすることができます。数およびRMBSのサイズは、ホスト独自のメモリ管理要件に基づいてピアによって管理されています。しかし、一方のピアにリンクグループに関連付けることができるRMBSの最大数は255 QPは、単一の保護ドメインを有しているが、各RMBは一意RTOKENを有しています。すべてのRTokensは、ピアと交換しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Each peer manages the RMBs in its local memory for its remote SMC-R peer by sharing access to the RMBs via RTokens with its peers. The remote peer writes into the RMBs via RDMA, and the local peer (RMB owner) then reads from the RMBs.",
      "ja": "各ピアは、そのピアとRTokens介しRMBSへのアクセスを共有することによって、リモートSMC-RピアのローカルメモリにRMBSを管理します。リモートピアがRDMAを介しRMBSに書き込む、およびローカルピア（RMBの所有者）をRMBSから読み出します。"
    },
    {
      "indent": 3,
      "text": "When two peers decide to use SMC-R for a given TCP connection, they each allocate a local RMB element for the TCP connection and communicate the location of this local RMB element during rendezvous processing. To that end, RMB elements are created in pairs, with one RMB element allocated locally on each peer of the SMC-R link.",
      "ja": "2つのピアが所与のTCP接続のためのSMC-Rを使用することを決定するとき、それらはそれぞれ、TCP接続のローカルRMB要素を割り当て、ランデブー処理中にこのローカルRMB要素の位置を伝えます。そのために、元の要素はSMC-Rリンクの各ピアにローカルに割り当てられた1つのRMB要素と、ペアで作成されます。"
    },
    {
      "indent": 9,
      "text": "         ---  +------------+---------------+\n         /\\   |Eye Catcher |               |\n          |   +------------+               |\n          |   |                            |\nRMB Element 1 |                            |\n          |   |   Receive Buffer           |\n          |   |                            |\n          |   |                            |\n         \\/   |                            |\n         ---  +------------+---------------+\n         /\\   |Eye Catcher |               |\n          |   +------------+               |\n          |   |                            |\nRMB Element 2 |                            |\n          |   |   Receive Buffer           |\n          |   |                            |\n          |   |                            |\n         \\/   |                            |\n         ---  +----------------------------+\n              |            .               |\n              |            .               |\n              |            .               |\n              |            .               |\n              |    (up to 255 elements)    |\n              +----------------------------+",
      "raw": true
    },
    {
      "indent": 27,
      "text": "Figure 3: RMB Format",
      "ja": "図3：人民元フォーマット"
    },
    {
      "indent": 3,
      "text": "Figure 3 illustrates the basic format of an RMB. The RMB is a virtual memory buffer whose backing real memory is pinned, which can support up to 255 TCP connections to exactly one remote SMC-R peer. Each RMB is therefore associated with the SMC-R links within a link group for the two peers and a specific RoCE Protection Domain. Other than the two peers identified by the SMC-R link, no other SMC-R peers can have RDMA access to an RMB; this requires a unique Protection Domain for every SMC-R link. This is critical to ensure integrity of SMC-R communications.",
      "ja": "図3は、元の基本的なフォーマットを示します。人民元は、1つのリモートSMC-Rのピアに255本のTCP接続をサポートすることができ、その実メモリをバックアップピン留めされた仮想メモリ・バッファ、です。各RMBしたがってつのピアのリンクグループ内のSMC-Rリンクと特定ROCE保護ドメインと関連しています。 SMC-Rリンクで識別される2つのピア以外に、他のSMC-Rピアは、元のRDMAアクセスを持つことはできません。これは、すべてのSMC-Rのリンクのためのユニークな保護ドメインが必要です。これは、SMC-R通信の整合性を確保することが重要です。"
    },
    {
      "indent": 3,
      "text": "RMBs are subdivided into multiple elements for efficiency, with each RMB Element (RMBE) associated with a single TCP connection. Therefore, multiple TCP connections across an SMC-R link group can share the same memory for RDMA purposes, reducing the overhead of having to register additional memory with the RNIC for every new TCP connection. The number of elements in an RMB and the size of each RMBE are entirely governed by the owning peer, subject to the SMC-R architecture rules; however, all RMB elements within a given RMB must be the same size. Each peer can decide the level of resource-sharing that is desirable across TCP connections based on local constraints, such as available system memory. An RMB element is identified to the remote SMC-R peer via an RMB Element Token, which consists of the following:",
      "ja": "RMBSは、単一のTCP接続に関連付けられた各RMB要素（RMBE）と、効率のために複数の要素に細分されます。従って、SMC-Rリンク群を横切る複数のTCP接続は、すべての新しいTCP接続のRNICと追加のメモリを登録することのオーバーヘッドを低減する、RDMAのために同じメモリを共有することができます。元の要素の数と各RMBEのサイズは、完全にSMC-Rアーキテクチャ規則に従って、所有ピアによって管理されています。しかし、与えられたRMB内のすべての人民元の要素は、同じサイズでなければなりません。各ピアは、利用可能なシステム・メモリなどのローカル制約に基づいてTCPコネクションを横切る望ましい資源共有のレベルを決定することができます。 RMB要素は、以下から成るRMB要素トークンを介して遠隔SMC-Rピアに識別されます。"
    },
    {
      "indent": 3,
      "text": "o RMB RToken: The combination of the RKey and virtual address provided by the RNIC that identifies the start of the RMB for RDMA operations.",
      "ja": "O RMB RTOKEN：RDMAオペレーションのための元の開始を識別RKEYおよびRNICによって提供される仮想アドレスの組み合わせ。"
    },
    {
      "indent": 3,
      "text": "o RMB Index: Identifies the RMB element index in the RMB. Used to locate a specific RMB element within an RMB. Valid value range is 1-255.",
      "ja": "O人民元インデックス：人民元人民元の要素のインデックスを識別します。 RMB内の特定の人民元の要素を見つけるために使用。有効な値の範囲は1〜255です。"
    },
    {
      "indent": 3,
      "text": "o RMB Element Length: The length of the RMB element's eye catcher plus the length of the receive buffer. This length is equal for all RMB elements in a given RMB. This length can be variable across different RMBs.",
      "ja": "O RMB要素長さ：RMB要素アイキャッチャーの長さを加えた受信バッファの長さ。この長さは、所与のRMB内のすべての元の要素について同じです。この長さは異なるRMBS間で可変とすることができます。"
    },
    {
      "indent": 3,
      "text": "Multiple RMBs can be associated to an SMC-R link group, and each peer in an SMC-R link group manages allocation of its RMBs. RMB allocation can be asymmetric. For example, Server X can allocate two RMBs to an SMC-R link group while Server Y allocates five. This provides maximum implementation flexibility to allow hosts to optimize RMB management for their own local requirements. The maximum number of RMBs that can be allocated on one peer to a link group is 255. If more RMBs are required, the peer may fall back to IP for subsequent connections or, if the peer is the server, create a parallel link group.",
      "ja": "複数RMBSは、SMC-Rリンクグループに関連付けることができ、及びSMC-Rリンクグループ内の各ピアは、そのRMBSの割り当てを管理します。人民元の割り当ては、非対称であってもよいです。サーバYは、5を割り当てながら、例えば、サーバXは、SMC-Rリンクグループへの2件のRMBSを割り当てることができます。これは、ホストは独自のローカル要件については、人民元の管理を最適化できるようにするために、最大実装の柔軟性を提供します。よりRMBSが必要な場合は、リンクグループに1つのピアに割り当てることができるRMBSの最大数は255であり、ピアは、後続の接続のためにバックIPに落ちるか、または、ピアがサーバである場合、平行リンクグループを作成します。"
    },
    {
      "indent": 3,
      "text": "One use case for multiple RMBs is multiple receive buffer sizes. Since every element in an RMB must be the same size, multiple RMBs with different element sizes can be allocated if varying receive buffer sizes are required.",
      "ja": "複数のRMBSのための一つのユースケースは、バッファサイズを受け取り、複数のです。 RMB内のすべての要素が同じ大きさでなければならないので、受信変化するバッファサイズが必要な場合、異なる要素サイズを持つ複数のRMBSを割り当てることができます。"
    },
    {
      "indent": 3,
      "text": "Also, since the maximum number of TCP connections whose receive buffers can be allocated to an RMB is 255, multiple RMBs may be required to provide capacity for large numbers of TCP connections between two peers.",
      "ja": "また、受信バッファRMBに割り当てることができる255であるTCP接続の最大数ので、複数RMBSは、2つのピア間のTCP接続の多数のための容量を提供するために必要とされ得ます。"
    },
    {
      "indent": 3,
      "text": "Separately from the RMB, the TCP/IP stack that owns each RMB maintains control data for each RMB element within its local control structures. The control data contains flags for maintaining the state of the TCP data (for example, urgent data indicator) and, most importantly, the following two cursors, which are illustrated below in Figure 4:",
      "ja": "別に元から、各人民元を所有しているTCP / IPスタックはそのローカル制御構造内の各人民元の要素のための制御データを保持します。制御データは、最も重要なのは、図4で以下に示されている以下の2つのカーソルを、（例えば、緊急データインジケータ）TCPデータの状態を維持するためのフラグを含みます。"
    },
    {
      "indent": 3,
      "text": "o The peer producer cursor: This is a wrapping offset into the RMB element's receive buffer that points to the next byte of data to be written by the remote peer. This cursor is provided by the remote peer in a Connection Data Control (CDC) message, which is sent using RoCE SendMsg processing, and tells the local peer how far it can consume data in the RMBE buffer.",
      "ja": "ピアプロデューサカーソル○：これは、リモートピアによって書き込まれるデータの次のバイトを指すRMB要素の受信バッファへのオフセットラッピングです。このカーソルはROCE SENDMSG処理を使用して送信され、それはRMBEバッファ内のデータを消費する可能性がどの程度までローカルピアに指示された接続データコントロール（CDC）メッセージ、リモートピアによって提供されます。"
    },
    {
      "indent": 3,
      "text": "o The peer consumer cursor: This is a wrapping offset into the remote peer's RMB element's receive buffer that points to the next byte of data to be consumed by the remote peer in its own RMBE. The local peer cannot write into the remote peer's RMBE beyond this point without causing data loss. This cursor is also provided by the peer using a Connection Data Control message.",
      "ja": "ピア・コンシューマ・カーソル○：これは、それ自身のRMBEリモートピアによって消費されるデータの次のバイトを指すリモートピアのRMB要素の受信バッファへのオフセットラッピングです。ローカルピアは、データの損失を引き起こすことなく、この点を超えて、リモートピアのRMBEに書き込むことはできません。このカーソルは、接続データ・コントロール・メッセージを使用してピアによって提供されます。"
    },
    {
      "indent": 3,
      "text": "Each TCP connection peer maintains its cursors for a TCP connection's RMBE in its local control structures. In other words, the peer who writes into a remote peer's RMBE provides its producer cursor to the peer whose RMBE it has written into. The peer who reads from its RMBE provides its consumer cursor to the writing peer. In this manner, the reads and writes between peers are kept coordinated.",
      "ja": "各TCPコネクションピアがそのローカル制御構造におけるTCPコネクションのRMBEために、そのカーソルを維持しています。言い換えれば、リモートピアのRMBEに書き込むピアはRMBEそれがに書き込まれたピアへのプロデューサーカーソルを提供します。そのRMBEから読み込むピアは書き込みピアへの消費者のカーソルを提供します。このようにして、読み込み、ピアが協調的に保持されている間に書き込みます。"
    },
    {
      "indent": 3,
      "text": "For example, referring to Figure 4, Peer B writes the hashed data into the receive buffer of Peer A's RMBE. After that write completes, Peer B uses a CDC message to update its producer cursor to Peer A, to indicate to Peer A how much data is available for Peer A to consume. The CDC message that Peer B sends to Peer A wakes up Peer A and notifies it that there is data to be consumed.",
      "ja": "例えば、図4を参照すると、ピアBは、ピアAのRMBEの受信バッファにハッシュデータを書き込みます。その書き込みが完了した後、ピアBは、ピアAが消費するためにどのくらいのデータが利用可能であるピアに示すために、ピアするそのプロデューサカーソルを更新するために、CDCメッセージを使用します。 BピアCDCメッセージは、Aは、ピアAをウェイクアップし、消費されるべきデータがあることを通知するピアに送ります。"
    },
    {
      "indent": 3,
      "text": "Similarly, when Peer A consumes data written by Peer B, it uses a CDC message to update its consumer cursor to Peer B to let Peer B know how much data it has consumed, so Peer B knows how much space is available for further writes. If Peer B were to write enough data to Peer A that it would wrap the RMBE receive buffer and exceed the consumer cursor, data loss would result.",
      "ja": "ピアAは、ピアBによって書き込まれたデータを消費する場合も同様に、それはピアBは、それが消費しているどのくらいのデータを知っているようにBをピアするために、その消費者のカーソルを更新するために、CDCメッセージを使用するため、ピアBは、さらに書き込みのために提供されていますどのくらいのスペースを知っています。ピアBは、消費者のカーソルをバッファリングし、超えてそれがRMBEラップあろうそのピアに十分なデータを書き込むために受信された場合、データの損失が生じます。"
    },
    {
      "indent": 3,
      "text": "Note that this is a simplistic description of the control flows, and they are optimized to minimize the number of CDC messages required, as described in Section 4.7 (\"RMB Data Flows\").",
      "ja": "この制御フローの単純な説明であり、これらは、セクション4.7で説明したように、必要なCDCメッセージ（「RMBデータフロー」）の数を最小限にするように最適化されることに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "   Peer A's RMBE Control Info            Peer B's RMBE Control Info\n  +--------------------------+          +--------------------------+\n  |                          |          |                          |\n   /----Peer producer cursor |    +-----+-Peer consumer cursor     |\n /|                          |    |     |                          |\n| +--------------------------+    |     +--------------------------+\n|  Peer A's RMBE                  |\n| +--------------------------+    |\n| |            +------------------+\n| |            |             |\n| |            \\/            |\n| |             +------------|\n| |-------------+/////////// |\n| |//RDMA data written by ///|\n| |/// Peer B that is ////// |\n| |/available to be consumed/|\n| |///////////////////////// |\n| |///////// +---------------|\n| |----------+/\\             |\n| |            |             |\n \\|            |             |\n  \\           /              |\n  |\\---------/               |\n  |                          |\n  |                          |",
      "raw": true
    },
    {
      "indent": 26,
      "text": "Figure 4: RMBE Cursors",
      "ja": "図4：RMBEカーソル"
    },
    {
      "indent": 3,
      "text": "Additional flags and indicators are communicated between peers. In all cases, these flags and indicators are updated by the peer using CDC messages, which are sent using RoCE SendMsg. More details on these additional flags and indicators are described in Section 4.3 (\"RMBE Control Information\").",
      "ja": "追加のフラグおよびインジケータは、ピア間で通信されます。すべての場合において、これらのフラグおよびインジケータは、ROCE SENDMSGを使用して送信されたCDCメッセージを、使用してピアによって更新されます。これらの追加のフラグと指標についての詳細は、4.3項（「RMBE制御情報」）に記載されています。"
    },
    {
      "indent": 0,
      "text": "2.2. SMC-R Link Groups",
      "section_title": true,
      "ja": "2.2。 SMC-Rリンクグループ"
    },
    {
      "indent": 3,
      "text": "SMC-R links are logically grouped together to form an SMC-R link group. The purpose of the link group is for supporting multiple links between the same two peers to provide for:",
      "ja": "SMC-Rリンクは、論理的にSMC-Rリンクグループを形成するために一緒にグループ化されます。リンクグループの目的は、のために提供するために、同じ2つのピア間に複数のリンクをサポートするためのものです："
    },
    {
      "indent": 3,
      "text": "o Resilience: Provides transparent and dynamic switching of the link used by existing TCP connections during link failures, typically hardware related. TCP traffic using the failing link can be switched to an active link within the link group, thereby avoiding disruptions to application workloads.",
      "ja": "O回復力：ハードウェア関連、通常、リンク障害時に既存のTCP接続で使用されるリンクの透明性とダイナミックスイッチングを提供します。障害のあるリンクを使用して、TCPトラフィックは、それによってアプリケーションのワークロードの混乱を回避する、リンクグループ内のアクティブリンクに切り替えることができます。"
    },
    {
      "indent": 3,
      "text": "o Link utilization: Provides an active/active link usage model allowing TCP traffic to be balanced across the links, which increases bandwidth and also avoids hardware imbalances and bottlenecks. Note that both adapter and switch utilization can become potential resource constraint issues.",
      "ja": "Oリンクの利用率は：帯域幅が増加し、また、ハードウェアの不均衡やボトルネックを回避TCPトラフィックがリンク上でバランスをとることができるように、アクティブ/アクティブリンクの使用モデルを提供します。両方のアダプタとスイッチの利用は、潜在的な資源制約の問題になることができることに注意してください。"
    },
    {
      "indent": 3,
      "text": "SMC-R link group support is required. Resilience is not optional. However, the user can elect to provision a single RNIC (on one or both hosts).",
      "ja": "SMC-Rリンクグループのサポートが必要です。回復力はオプションではありません。しかし、ユーザは、プロビジョニング（一方または両方のホスト上の）単一のRNICに選択することができます。"
    },
    {
      "indent": 3,
      "text": "Multiple links that are formed between the same two peers fall into two distinct categories:",
      "ja": "同じ2つのピア間に形成されている複数のリンクは、2つの異なるカテゴリに分類されます。"
    },
    {
      "indent": 3,
      "text": "1. Equal Links: Links providing equal access to the same RMB(s) at both endpoints, whereby all TCP connections associated with the links must have the same VLAN ID and have the same TCP server and TCP client roles or relationship.",
      "ja": "1.均等リンク：リンクに関連付けられているすべてのTCP接続が同じVLAN IDを持ち、同じTCPサーバとTCPクライアントの役割や関係を持っている必要がありますすることにより、両方のエンドポイントで同じRMB（S）への平等なアクセスを提供するリンク。"
    },
    {
      "indent": 3,
      "text": "2. Unequal Links: Links providing access to unique, unrelated and isolated RMB(s) (i.e., for unique VLANs or unique and isolated application workloads, etc.) or having unique TCP server or client roles.",
      "ja": "2.不等リンク：または固有TCPサーバまたはクライアントの役割を有する（固有のVLANまたはユニークで単離されたアプリケーションのワークロード、等のために、すなわち、）、ユニーク無関係および単離されたRMB（S）へのアクセスを提供するリンク。"
    },
    {
      "indent": 3,
      "text": "Links that are logically grouped together forming an SMC-R link group must be equal links.",
      "ja": "SMC-Rリンクグループを形成する、論理的にグループ化されたリンクは、同じリンクでなければなりません。"
    },
    {
      "indent": 0,
      "text": "2.2.1. Link Group Types",
      "section_title": true,
      "ja": "2.2.1。リンクグループの種類"
    },
    {
      "indent": 3,
      "text": "Equal links within a link group also have another \"Link Group Type\" attribute based on the link's associated underlying physical path. The following SMC-R link types are defined:",
      "ja": "リンクグループ内の均等のリンクは、リンクの関連基礎となる物理パスに基づいて別の「リンクグループタイプ」属性を持っています。以下SMC-Rのリンクタイプが定義されています。"
    },
    {
      "indent": 3,
      "text": "1. Single link: the only active link within a link group",
      "section_title": true,
      "ja": "1.シングルリンク：リンクグループ内でのみアクティブリンク"
    },
    {
      "indent": 3,
      "text": "2. Parallel link: not allowed -- SMC-R links having the same physical RNIC at both hosts",
      "ja": "2.平行リンク：許可されていない - 両方のホストで同じ物理RNICを有するSMC-Rリンク"
    },
    {
      "indent": 3,
      "text": "3. Asymmetric link: links that have unique RNIC adapters at one host but share a single adapter at the peer host",
      "ja": "3.非対称リンク：1つのホストでユニークなRNICアダプタを持っているが、ピアのホストで単一のアダプタを共有するリンク"
    },
    {
      "indent": 3,
      "text": "4. Symmetric link: links that have unique RNIC adapters at both hosts",
      "section_title": true,
      "ja": "4.対称リンク：両方のホストでユニークなRNICアダプタを持っているリンク"
    },
    {
      "indent": 3,
      "text": "These link group types are further explained in the following figures and descriptions.",
      "ja": "これらのリンクグループの種類は、以下の図面および説明で説明されています。"
    },
    {
      "indent": 3,
      "text": "Figure 2 above shows the single-link case. The single link illustrated in Figure 2 also establishes the SMC-R link group. Link groups are supposed to have multiple links, but when only one RNIC is available at both hosts then only a single link can be created. This is expected to be a transient case.",
      "ja": "図2は、上記シングルリンク場合を示しています。図2に示される単一のリンクはまた、SMC-Rリンク群を確立します。リンク・グループは、複数のリンクを持っていることになっているが、一つだけRNICは、両方のホストで利用可能な場合にのみ、単一のリンクを作成することができます。これは、過渡的ケースであることが予想されます。"
    },
    {
      "indent": 3,
      "text": "Figure 5 shows the symmetric-link case. Both hosts have unique and redundant RNIC adapters. This configuration meets the objectives for providing full RoCE redundancy required to provide the level of resilience required for high availability for SMC-R. While this configuration is not required, it is a strongly recommended \"best practice\" for the exploitation of SMC-R. Single and asymmetric links must be supported but are intended to provide for short-term transient conditions -- for example, during a temporary outage or recycle of an RNIC.",
      "ja": "図5は、対称リンク場合を示しています。どちらのホストがユニークで冗長RNICアダプタを持っています。この構成は、SMC-Rの高可用性のために必要な弾力性のレベルを提供するために必要な完全ROCE冗長性を提供するための目標を満たしています。この設定は必須ではありませんが、それはSMC-Rの開発のために強く推奨「ベストプラクティス」です。シングルおよび非対称のリンクがサポートされている必要がありますが、短期的過渡状態のために提供することを意図している - 例えば、RNICの一時的な停止やリサイクル時に。"
    },
    {
      "indent": 5,
      "text": "     Host X                                     Host Y\n+-------------------+                      +-------------------+\n|                   |                      |                   |\n| Protection        |                      |    Protection     |\n| Domain X          |                      |    Domain Y       |\n|            +------+                      +------+            |\n|       QP 8 |RNIC 1|     SMC-R Link 1     |RNIC 2|  QP 64     |\n|RToken X|   |      |<-------------------->|      |   |        |\n|        |   |      |                      |      |   |RToken Y|\n|       \\/   +------+                      +------+  \\/        |\n|+--------+         |                      |        +--------+ |\n||        |         |                      |        |        | |\n|| RMB    |         |                      |        | RMB    | |\n||        |         |                      |        |        | |\n|+--------+         |                      |        +--------+ |\n|       /\\   +------+                      +------+  /\\        |\n|RToken Z|   |      |     SMC-R Link 2     |      |   |RToken W|\n|        |   |RNIC 3|<-------------------->|RNIC 4|   |        |\n|       QP 9 |      |                      |      |  QP 65     |\n|            +------+                      +------+            |\n+-------------------+                      +-------------------+",
      "raw": true
    },
    {
      "indent": 22,
      "text": "Figure 5: Symmetric SMC-R Links",
      "ja": "図5：対称SMC-Rリンク"
    },
    {
      "indent": 5,
      "text": "     Host X                                     Host Y\n+-------------------+                      +-------------------+\n|                   |                      |                   |\n| Protection        |                      |    Protection     |\n| Domain X          |                      |    Domain Y       |\n|            +------+                      +------+            |\n|       QP 8 |RNIC 1|     SMC-R Link 1     |RNIC 2|  QP 64     |\n|RToken X|   |      |<-------------------->|      |   |        |\n|        |   |      |                   .->|      |   |RToken Y|\n|       \\/   +------+                 .`   +------+  \\/        |\n|+--------+         |               .`     |        +--------+ |\n||        |         |             .`       |        |        | |\n|| RMB    |         |           .`         |        | RMB    | |\n||        |         |         .`SMC-R      |        |        | |\n|+--------+         |       .` Link 2      |        +--------+ |\n|       /\\   +------+     .`               +------+            |\n|RToken Z|   |      |   .`                 |      |down or     |\n|        |   |RNIC 3|<-`                   |RNIC 4|unavailable |\n|       QP 9 |      |                      |      |            |\n|            +------+                      +------+            |\n+-------------------+                      +-------------------+",
      "raw": true
    },
    {
      "indent": 21,
      "text": "Figure 6: Asymmetric SMC-R Links",
      "ja": "図6：非対称SMC-Rリンク"
    },
    {
      "indent": 3,
      "text": "In the example provided by Figure 6, Host X has two RNICs but Host Y only has one RNIC because RNIC 4 is not available. This configuration allows for the creation of an asymmetric link. While an asymmetric link will provide some resilience (for example, when RNIC 1 fails), ideally each host should provide two redundant RNICs. This should be a transient case, and when RNIC 4 becomes available, this configuration must transition to a symmetric-link configuration. This transition is accomplished by first creating the new symmetric link and then deleting the asymmetric link with reason code \"Asymmetric link no longer needed\" specified in the DELETE LINK LLC message.",
      "ja": "図6によって提供された例では、ホストXは、二つRNICsを有するが、RNIC 4が利用できないため、ホストYは、唯一のRNICを有します。この構成は、非対称リンクを作成できます。 （RNIC 1に障害が発生した場合など）、非対称リンクは、いくつかの弾力性を提供するが、理想的には各ホストは、2つの冗長RNICsを提供すべきです。これは、過渡ケースであるべきであり、RNIC 4が使用可能になったとき、この構成は、対称リンク構成に移行しなければなりません。この遷移は、第一の新しい対称のリンクを作成し、DELETE LINK LLCメッセージで指定された理由コード「もはや必要非対称リンク」非対称リンクを削除することによって達成されます。"
    },
    {
      "indent": 5,
      "text": "     Host X                                     Host Y\n+-------------------+                      +-------------------+\n|                   |                      |                   |\n| Protection        |                      |    Protection     |\n| Domain X          |                      |    Domain Y       |\n|            +------+  SMC-R Link 1        +------+            |\n|       QP 8 |RNIC 1|<-------------------->|RNIC 2|  QP 64     |\n|RToken X|   |      |                      |      |   |        |\n|        |   |      |<-------------------->|      |   |RToken Y|\n|       \\/   +------+  SMC-R Link 2        +------+  \\/        |\n|+--------+   QP 9  |                      | QP 65  +--------+ |\n||        |    |    |                      |  |     |        | |\n|| RMB    |<-- +    |                      |  +---->| RMB    | |\n||        |         |                      |        |        | |\n|+--------+         |                      |        +--------+ |\n|            +------+                      +------+            |\n|     down or|      |                      |      |down or     |\n| unavailable|RNIC 3|                      |RNIC 4|unavailable |\n|            |      |                      |      |            |\n|            +------+                      +------+            |\n+-------------------+                      +-------------------+",
      "raw": true
    },
    {
      "indent": 14,
      "text": "Figure 7: SMC-R Parallel Links (Not Supported)",
      "ja": "図7：SMC-Rパラレルリンク（サポートされていません）"
    },
    {
      "indent": 3,
      "text": "Figure 7 shows parallel links, which are two links in the link group that use the same hardware. This configuration is not permitted. Because SMC-R multiplexes multiple TCP connections over an SMC-R link and both links are using the exact same hardware, there is no additional redundancy or capacity benefit obtained from this configuration. In addition to providing no real benefit, this configuration adds the unnecessary overhead of additional queue pairs, generation of additional RKeys, etc.",
      "ja": "図7は、同じハードウェアを使用してリンクグループ内の2つのリンクである平行リンクを、示しています。この設定は許可されていません。 SMC-Rは、SMC-Rリンクを介して複数のTCP接続を多重化し、両方のリンクが正確に同じハードウェアを使用しているため、このような構成から得られる追加の冗長性や容量の利点はありません。本当の利益を提供しないことに加えて、この構成では、追加のキューのペアの不要なオーバーヘッドを追加し、追加RKeysの生成など"
    },
    {
      "indent": 0,
      "text": "2.2.2. Maximum Number of Links in Link Group",
      "section_title": true,
      "ja": "2.2.2。リンクグループ内のリンクの最大数"
    },
    {
      "indent": 3,
      "text": "The SMC-R protocol defines a maximum of eight symmetric SMC-R links within a single SMC-R link group. This allows for support for up to eight unique physical paths between peer hosts. However, in terms of meeting the basic requirements for redundancy, support for at least two symmetric links must be implemented. Supporting more than two links also simplifies implementation for practical matters relating to dynamically adding and removing links -- for example, starting a third SMC-R link prior to taking down one of the two existing links. Recall that all links within a link group must have equal access to all associated RMBs.",
      "ja": "SMC-Rプロトコルは、単一のSMC-Rリンクグループ内の8対称SMC-Rリンクの最大値を定義します。これは、ピアのホスト間で最大8つのユニークな物理パスをサポートすることができます。ただし、冗長性のための基本的な要件を満たすという点で、少なくとも二つの対称リンクのサポートが実現されなければなりません。例えば、前2つの既存のリンクのいずれかを降ろす第3 SMC-Rリンクを起動 - つ以上のリンクをサポートすることも、動的にリンクを追加および削除に関する実用的な事柄のための実装を簡素化します。リンクグループ内のすべてのリンクは、関連するすべてのRMBSへの平等なアクセスを持たなければならないことを思い出してください。"
    },
    {
      "indent": 3,
      "text": "The SMC-R protocol allows an implementation to assign an implementation-specific and appropriate value for maximum symmetric links. The implementation value must not exceed the architecture limit of 8; also, the value must not be lower than 2, because the SMC-R protocol requires redundancy. This does not mean that two RNICs are physically required to enable SMC-R connectivity, but at least two RNICs for redundancy are strongly recommended.",
      "ja": "SMC-Rプロトコルが実装が最大の対称リンクの実装固有の、適切な値を割り当てることができます。実装値が8のアーキテクチャの限界を超えてはなりません。 SMC-Rプロトコルは冗長性を必要とするので、また、値は、2よりも低くてはなりません。これは、2 RNICsが物理的SMC-Rの接続を可能にするために必要であることを意味するものではありませんが、冗長性のために少なくとも2 RNICsを強くお勧めします。"
    },
    {
      "indent": 3,
      "text": "The SMC-R peers exchange their implementation maximum link values during the link group establishment using the defined maximum link value in the CONFIRM LINK LLC command. Once the initial exchange completes, the value is set for the life of the link group. The maximum link value can be provided by both the server and client. The server must supply a value, whereas the client maximum link value is optional. When the client does not supply a value, it indicates that the client accepts the server-supplied maximum value. If the client provides a value, it cannot exceed the server-supplied maximum value. If the client passes a lower value, this lower value then becomes the final negotiated maximum number of symmetric links for this link group. Again, the minimum value is 2.",
      "ja": "SMC-RピアはCONFIRMリンクLLCコマンドで定義された最大リンク値を使用してリンクグループの確立中に、その実装の最大リンク値を交換します。最初の交換が完了すると、値がリンクグループの生活のために設定されています。最大リンク値は、サーバとクライアントの両方で提供することができます。クライアントの最大リンク値がオプションであるのに対し、サーバーは、値を指定する必要があります。クライアントが値を供給しない場合は、クライアントは、サーバが提供する最大値を受け入れることを示しています。クライアントが値を提供する場合、それは、サーバが提供する最大値を超えることはできません。クライアントは、より低い値に合格した場合、この低い値は、このリンクグループの対称リンクの最終ネゴシエート最大数となります。再度、最小値は2です。"
    },
    {
      "indent": 3,
      "text": "During run time, the client must never request that the server add a symmetric link to a link group that would exceed the negotiated maximum link value. Likewise, the server must never attempt to add a symmetric link to a link group that would exceed the negotiated maximum value.",
      "ja": "実行時に、クライアントは、サーバがネゴシエート最大リンク値を超えるリンクグループに左右対称のリンクを追加することを要求してはなりません。同様に、サーバが交渉さの最大値を超えてしまうリンクグループに左右対称のリンクを追加しようとしてはなりません。"
    },
    {
      "indent": 3,
      "text": "In terms of counting the number of active links within a link group, the initial link (or the only/last) link is always counted as 1. Then, as additional links are added, they are either symmetric or asymmetric links.",
      "ja": "追加のリンクが追加されるように、リンクグループ内のアクティブなリンクの数をカウントする点で、最初のリンク（または最後の/のみ）リンクは常に、そして1としてカウントされ、それらは対称または非対称のどちらかのリンクです。"
    },
    {
      "indent": 3,
      "text": "With regards to enforcing the maximum link rules, asymmetric links are an exception having a unique set of rules:",
      "ja": "最大リンク規則の施行に関しては、非対称リンクは、ルールの独自のセットを持つ例外です。"
    },
    {
      "indent": 3,
      "text": "o Asymmetric links are always limited to one asymmetric link allowed per link group.",
      "ja": "O非対称リンクは常にリンクグループごとに許可される1つの非対称リンクに限定されています。"
    },
    {
      "indent": 3,
      "text": "o Asymmetric links must not be counted in the maximum symmetric-link count calculation. When tracking the current count or enforcing the negotiated maximum number of links, an asymmetric link is not to be counted.",
      "ja": "O非対称リンクは、最大対称リンク数の計算にカウントされない必要があります。現在のカウントの追跡やリンクのネゴシエートされた最大数を強制するとき、非対称リンクがカウントされるべきではありません。"
    },
    {
      "indent": 0,
      "text": "2.2.3. Forming and Managing Link Groups",
      "section_title": true,
      "ja": "2.2.3。形成及びリンクグループの管理"
    },
    {
      "indent": 3,
      "text": "SMC-R link groups are self-defining. The first SMC-R link in a link group is created using TCP option flows on the TCP three-way handshake followed by CLC message flows over the TCP connection. Subsequent SMC-R links in the link group are created by sending LLC messages over an SMC-R link that already exists in the link group. Once an SMC-R link group is created, no additional SMC-R links in that group are created using TCP and CLC negotiation. Because subsequent SMC-R links are created exclusively by sending LLC messages over an existing SMC-R link in a link group, the membership of SMC-R links in a link group is self-defining.",
      "ja": "SMC-Rのリンクグループは、自己定義されています。リンクグループ内の最初のSMC-Rリンクは、TCPオプションを使用して作成されたTCP接続を介して流れるCLCメッセージ続いTCPスリーウェイハンドシェイクを流れます。リンクグループにおけるその後のSMC-Rリンクは、すでにリンクグループ内に存在するSMC-Rリンク上LLCメッセージを送信することにより作成されます。 SMC-Rのリンクグループが作成されると、そのグループには、追加のSMC-RリンクはTCPとCLCネゴシエーションを使用して作成されていません。その後のSMC-Rのリンクは、リンクグループ内の既存のSMC-Rリンク上LLCメッセージを送信することにより、排他的に作成されるため、リンクグループにおけるSMC-Rリンクの会員は自己定義です。"
    },
    {
      "indent": 3,
      "text": "This architecture does not define a specific identifier for an SMC-R link group. This identification may be useful for network management and may be assigned in a platform-specific manner, or in an extension to this architecture.",
      "ja": "このアーキテクチャは、SMC-Rリンクグループのための固有の識別子を定義していません。この識別は、ネットワーク管理のために有用であってもよく、プラットフォーム固有の方法で、またはこのアーキテクチャの拡張に割り当てられてもよいです。"
    },
    {
      "indent": 3,
      "text": "In each SMC-R link group, one peer is the server for all TCP connections and the other peer is the client. If there are additional TCP connections between the peers that use SMC-R and have the client and server roles reversed, another SMC-R link group is set up between them with the opposite client-server relationship.",
      "ja": "各SMC-Rのリンクグループでは、1つのピアは、すべてのTCP接続のためのサーバであり、他のピアがクライアントです。 SMC-Rを使用して、クライアントとサーバーの役割が逆転していピア間の追加のTCP接続がある場合は、別のSMC-Rリンクグループは反対のクライアント - サーバの関係でそれらの間に設定されています。"
    },
    {
      "indent": 3,
      "text": "This is required because there are specific responsibilities divided between the client and server in the management of an SMC-R link group.",
      "ja": "SMC-Rリンクグループの経営にクライアントとサーバとの間で分割特有の責任があるので、これは必要とされます。"
    },
    {
      "indent": 3,
      "text": "In this architecture, the decision of whether to use an existing SMC-R link group or create a new SMC-R link group for a TCP connection is made exclusively by the server.",
      "ja": "このアーキテクチャでは、既存のSMC-Rリンクグループを使用するか、TCP接続のための新しいSMC-Rリンクグループを作成するかどうかの決定は、サーバによってのみ行われます。"
    },
    {
      "indent": 3,
      "text": "Management of the links in an SMC-R link group is also a server responsibility. The server is responsible for adding and deleting links in a link group. The client may request that the server take certain actions, but the final responsibility is the server's.",
      "ja": "SMC-Rリンクグループ内のリンクの管理は、サーバの責任です。サーバーは、リンクグループ内のリンクを追加および削除する責任があります。クライアントは、サーバが特定のアクションを取ることを要求することができるが、最終的な責任は、サーバのです。"
    },
    {
      "indent": 0,
      "text": "2.2.4. SMC-R Link Identifiers",
      "section_title": true,
      "ja": "2.2.4。 SMC-Rリンク識別子"
    },
    {
      "indent": 3,
      "text": "This architecture defines multiple identifiers to identify SMC-R links and peers.",
      "ja": "このアーキテクチャは、SMC-Rリンク及びピアを識別するために、複数の識別子を定義します。"
    },
    {
      "indent": 3,
      "text": "o Link number: This is a 1-byte value that identifies an SMC-R link within a link group. Both the server and the client use this number to distinguish an SMC-R link from other links within the same link group. It is only unique within a link group. In order to prevent timing windows that may occur when a server creates a new link while the client is still cleaning up a previously existing link, link numbers cannot be reused until the entire link numbering space has been exhausted.",
      "ja": "Oリンクの数：これは、リンクグループ内のSMC-Rのリンクを識別する1バイトの値です。サーバとクライアントの両方が同じリンクグループ内の他のリンクからSMC-Rのリンクを区別するために、この番号を使用します。これは、リンクグループ内でのみ一意です。リンク全体の番号空間が枯渇するまで、クライアントはまだ以前に既存のリンクを掃除している間、サーバーが新しいリンクを作成するときに発生する可能性がタイミングウィンドウを防ぐために、リンク番号は再利用することはできません。"
    },
    {
      "indent": 3,
      "text": "o Link user ID: This is an architecturally opaque 4-byte value that a peer uses to uniquely define an SMC-R link within its own space. This means that a link user ID is unique within one peer only. Each peer defines its own link user ID for a link. The peers exchange this information once during link setup, and it is never used architecturally again. The purpose of this identifier is for network management, display, and debugging. For example, an operator on a client could provide the operator on the server with the server's link user ID if he requires the server's operator to check on the operation of a link that the client is having trouble with.",
      "ja": "OリンクユーザーID：これはピアが一意に独自の空間内SMC-Rのリンクを定義するために使用するアーキテクチャ不透明4バイトの値です。これは、リンクのユーザーIDは一つだけのピア内で一意であることを意味します。各ピアは、リンクのために、独自のリンクのユーザーIDを定義します。ピアは、リンクのセットアップ時に一度、この情報を交換し、そしてそれは、アーキテクチャ、再び使用されることはありません。この識別子の目的は、ネットワーク管理、表示、およびデバッグ用です。彼は、クライアントが持つ悩みを持っているリンクの動作をチェックするために、サーバのオペレータを必要とする場合たとえば、クライアント上のオペレータは、サーバーのリンクユーザーIDを使用してサーバ上の演算子を提供することができます。"
    },
    {
      "indent": 3,
      "text": "o Peer ID: The SMC-R peer ID uniquely identifies a specific instance of a specific TCP/IP stack. It is required because in clustered and load-balancing environments, an IP address does not uniquely identify a TCP/IP stack. An RNIC's MAC/GID also doesn't uniquely or reliably identify a TCP/IP stack, because RNICs can go up and down and even be redeployed to other TCP/IP stacks in a multiple-partitioned or virtualized environment. The peer ID is not only unique per TCP/IP stack but is also unique per instance of a TCP/IP stack, meaning that if a TCP/IP stack is restarted, its peer ID changes.",
      "ja": "OピアIDは：SMC-RピアIDは一意に特定TCP / IPスタックの特定のインスタンスを識別する。あるため、クラスタ化と負荷分散の環境では、IPアドレスが一意にTCP / IPスタックを識別しないが必要です。 RNICsが上がることができ、ダウン、さらには、複数のパーティションや仮想化環境では、他のTCP / IPスタックに再デプロイするためRNICのMAC / GIDも、独自にまたは確実にTCP / IPスタックを識別しません。ピアIDだけではなく、TCP / IPスタックごとに一意であるが、TCP / IPスタックが、そのピアIDの変更を再起動するとことを意味し、また、TCP / IPスタックのインスタンスごとに一意です。"
    },
    {
      "indent": 0,
      "text": "2.3. SMC-R Resilience and Load Balancing",
      "section_title": true,
      "ja": "2.3。 SMC-R弾力性とロードバランシング"
    },
    {
      "indent": 3,
      "text": "The SMC-R multilink architecture provides resilience for network high availability via failover capability to an alternate RoCE adapter.",
      "ja": "SMC-Rマルチリンクアーキテクチャは、代替ROCEアダプタにフェイルオーバー機能を介してネットワークの高可用性のための回復力を提供します。"
    },
    {
      "indent": 3,
      "text": "The SMC-R multilink architecture does not define primary, secondary, or alternate roles to the links. Instead, there are multiple active links representing multiple redundant RoCE paths over the same LAN.",
      "ja": "SMC-Rマルチリンクアーキテクチャは、リンクに、第一、第二、または代替の役割を定義していません。代わりに、同じLAN上に複数の冗長ROCEパスを表す複数のアクティブなリンクがあります。"
    },
    {
      "indent": 3,
      "text": "Assignment of TCP connections to links is unidirectional and asymmetric. This means that the client and server may each choose a separate link for their RDMA writes associated with a specific TCP connection.",
      "ja": "リンクへのTCP接続の割り当ては単方向と非対称です。これは彼らのRDMAは、特定のTCP接続に関連した書き込みのために、クライアントとサーバはそれぞれ別々のリンクを選択してもよいことを意味します。"
    },
    {
      "indent": 3,
      "text": "If a hardware failure occurs or a QP failure associated with an individual link occurs, then the TCP connections that were associated with the failing link are dynamically and transparently switched to use another available link. The server or the client can detect a failure, immediately move their TCP connections, and then notify their peer via the DELETE LINK LLC command. While the client can notify the server of an apparent link failure with the DELETE LINK LLC command, the server performs the actual link deletion.",
      "ja": "ハードウェア障害が発生した場合、または個々のリンクに関連付けられたQP障害が発生した場合、失敗したリンクに関連付けられたTCP接続を動的かつ透過的に別の利用可能なリンクを使用するように切り替えられます。サーバーまたはクライアントは、障害を検出し、すぐに自分のTCPコネクションを移動し、DELETE LINK LLCコマンドでそのピアに通知することができます。クライアントは、DELETE LINK LLCのコマンドを使用して、見かけ上のリンク障害のサーバーに通知することができますが、サーバーは、実際のリンクの削除を実行します。"
    },
    {
      "indent": 3,
      "text": "The movement of TCP connections to another link can be accomplished with minimal coordination between the peers. The TCP connection movement is also transparent to, and non-disruptive to, the TCP socket application workloads for most failure scenarios. After a failure, the surviving links and all associated hardware must handle the link group's workload.",
      "ja": "別のリンクへのTCP接続の移動は、ピア間の最小の協調を用いて達成することができます。 TCPコネクションの動きは、ほとんどの障害シナリオのためのTCPソケットアプリケーションのワークロードへの透明性、および非破壊的です。障害が発生した後、生き残ったリンクや、関連するすべてのハードウェアは、リンクグループのワークロードを処理する必要があります。"
    },
    {
      "indent": 3,
      "text": "As each SMC-R peer begins to move active TCP connections to another link, all current RDMA write operations must be allowed to complete. The moving peer then sends a signal to verify receipt of the last successful write by its peer. If this verification fails, the TCP connection must be reset. Once this verification is complete, all writes that failed may then be retried, in order, over the new link. Any data writes or CDC messages for which the sender did not receive write completion must be replayed before any subsequent data or CDC write operations are sent. LLC messages are not retried over the new link, because they are dependent on a known link configuration, which has just changed because of the failure. The initiator of an LLC message exchange that fails will be responsible for retrying once the link group configuration stabilizes.",
      "ja": "各SMC-Rのピアは、別のリンクにアクティブなTCP接続を移動し始めると、現在のすべてのRDMA書き込み操作が完了するまでに許可する必要があります。移動ピアは、そのピアで最後に成功した書き込みの受領を確認するために信号を送ります。この検証が失敗した場合、TCP接続をリセットする必要があります。この検証が完了すると、失敗したすべての書き込みは、新しいリンク上で、順番に、再試行することができます。それ以降のデータやCDCの書き込み操作が送信される前に、送信者が書き込み完了を受けなかったため、任意のデータの書き込みやCDCメッセージが再生されなければなりません。彼らは単に障害のために変更された知られているリンクの設定に依存しているため、LLCのメッセージは、新しいリンク上で再試行されません。リンクグループの構成が安定一度失敗したLLCのメッセージ交換のイニシエータは、再試行のために責任を負うことになります。"
    },
    {
      "indent": 3,
      "text": "When a new link becomes available and is re-added to the link group, each peer is free to rebalance its current TCP connections as needed or only assign new TCP connections to the newly added link. Both the server and client are free to manage TCP connections across the link group as needed. TCP connection movement does not have to be stimulated by a link failure.",
      "ja": "新しいリンクが利用可能になるとリンクグループに再度追加されると、各ピアは、必要に応じて、現在のTCP接続のバランスを再調整のみ新しく追加されたリンクに新しいTCP接続を割り当てることが自由です。サーバとクライアントの両方が必要に応じてリンクグループ間でTCP接続を管理するのは自由です。 TCPコネクションの動きは、リンク障害によって刺激されることはありません。"
    },
    {
      "indent": 3,
      "text": "The SMC-R architecture also defines orderly versus disorderly failover. The type of failover is communicated in the LLC DELETE LINK command and is simply a means to indicate that the link has terminated (disorderly) or link termination is imminent (orderly). The orderly link deletion could be initiated via operator command or programmatically to bring down an idle link. For example, an operator command could initiate orderly shutdown of an adapter for service. Implementation of the two types is based on implementation requirements and is beyond the scope of the SMC-R architecture.",
      "ja": "SMC-Rアーキテクチャはまた無秩序フェイルオーバ対整然と定義します。フェイルオーバーのタイプは、リンクコマンドをDELETE LLCで通信し、単にリンクが終了した（無秩序）またはリンク終端が（秩序）差し迫っていることを示すための手段です。整然としたリンク削除は、オペレータコマンドによって開始されたり、プログラムのアイドルリンクをダウンさせます。例えば、オペレータコマンドは、サービス用のアダプタの正常シャットダウンを開始することができます。二つのタイプの実装は、実装要件に基づいており、SMC-Rアーキテクチャの範囲外です。"
    },
    {
      "indent": 0,
      "text": "3. SMC-R Rendezvous Architecture",
      "section_title": true,
      "ja": "3. SMC-Rランデブーアーキテクチャ"
    },
    {
      "indent": 3,
      "text": "\"Rendezvous\" is the process that SMC-R-capable peers use to dynamically discover each others' capabilities, negotiate SMC-R connections, set up SMC-R links and link groups, and manage those link groups. A key aspect of SMC-R Rendezvous is that it occurs dynamically and automatically, without requiring SMC-R link configuration to be defined by an administrator.",
      "ja": "「ランデブーは」SMC-R対応のピアが動的にお互いの能力を発見するために使用するプロセスであり、SMC-Rの接続をネゴシエート、SMC-Rリンク及びリンクグループを設定し、それらのリンクグループを管理します。 SMC-Rランデブーの重要な側面は、それが管理者によって定義されるSMC-Rリンク構成を必要とせずに、動的かつ自動的に行われることです。"
    },
    {
      "indent": 3,
      "text": "SMC-R Rendezvous starts with the TCP/IP three-way handshake, during which connection peers use TCP options to announce their SMC-R capabilities. If both endpoints are SMC-R capable, then Connection Layer Control (CLC) messages are exchanged between the peers' SMC-R layers over the newly established TCP connection to negotiate SMC-R credentials. The CLC message mechanism is analogous to the messages exchanged by SSL for its handshake processing.",
      "ja": "SMC-Rランデブーは、接続ピアが自分のSMC-R機能を発表するTCPオプションを使用している間、TCP / IPスリーウェイハンドシェイクで始まります。両方のエンドポイントがSMC-R対応している場合は、接続層制御（CLC）のメッセージは、SMC-Rの資格情報を交渉するために新設されたTCP接続を介してピアのSMC-R層の間で交換されています。 CLCメッセージ機構は、ハンドシェイク処理のためにSSLによって交換されるメッセージに類似しています。"
    },
    {
      "indent": 3,
      "text": "If a new SMC-R link is being set up, Link Layer Control (LLC) messages are used to confirm RDMA connectivity. LLC messages are also used by the SMC-R layers at each peer to manage the links and link groups.",
      "ja": "新しいSMC-Rのリンクが設定されている場合、リンクレイヤ制御（LLC）のメッセージは、RDMAの接続性を確認するために使用されています。 LLCメッセージも、リンクとリンクグループを管理するために、各ピアでSMC-Rの層によって使用されます。"
    },
    {
      "indent": 3,
      "text": "Once an SMC-R link is set up or agreed to by the peers, the TCP sockets are passed to the peer applications, which use them as normal. The SMC-R layer, which resides under the sockets layer, transmits the socket data between peers over RDMA using the SMC-R protocol, bypassing the TCP/IP stack.",
      "ja": "SMC-Rのリンクはピアによって設定するかに同意されると、TCPソケットは、通常のようにそれらを使用するピア・アプリケーションに渡されます。ソケット層の下に存在するSMC-R層は、TCP / IPスタックをバイパスし、SMC-Rプロトコルを使用して、RDMA上のピア間のソケットデータを送信します。"
    },
    {
      "indent": 0,
      "text": "3.1. TCP Options",
      "section_title": true,
      "ja": "3.1。 TCPオプション"
    },
    {
      "indent": 3,
      "text": "During the TCP/IP three-way handshake, the client and server indicate their support for SMC-R by including experimental TCP option 254 on the three-way handshake flows, in accordance with [RFC6994] (\"Shared Use of Experimental TCP Options\"). The Experiment Identifier (ExID) value used is the string \"SMCR\" in EBCDIC (IBM-1047) encoding (0xE2D4C3D9). This ExID has been registered in the \"TCP Experimental Option Experiment Identifiers (TCP ExIDs)\" registry maintained by IANA.",
      "ja": "TCP / IPスリーウェイハンドシェイク中に、クライアントとサーバは、[RFC6994]（「実験TCPオプションの共同利用」に合わせて、3ウェイハンドシェイクの流れに関する実験TCPオプション254を含むことによって、SMC-Rのための彼らのサポートを示します）。使用される実験識別子（EXID）値はEBCDIC文字列 \"SMCR\"（IBM-1047）符号化（0xE2D4C3D9）です。このEXIDはIANAによって維持「TCP実験オプション実験識別子（TCP ExIDs）」のレジストリに登録されています。"
    },
    {
      "indent": 3,
      "text": "After completion of the three-way TCP handshake, each peer queries its peer's options. If both peers set the TCP option on the three-way handshake, inline SMC-R negotiation occurs using CLC messages. If neither peer, or only one peer, sets the TCP option, SMC-R cannot be used for the TCP connection, and the TCP connection completes the setup using the IP fabric.",
      "ja": "3ウェイTCPハンドシェイクが完了した後、各ピアは、そのピアのオプションを照会します。両方のピアは、3ウェイハンドシェイクのTCPオプションを設定した場合は、インラインSMC-Rの交渉はCLCメッセージを使用して発生します。どちらのピア、または唯一のピアは、TCPオプションを設定した場合、SMC-Rは、TCP接続に使用することができず、TCP接続はIPファブリックを使用してセットアップを完了します。"
    },
    {
      "indent": 0,
      "text": "3.2. Connection Layer Control (CLC) Messages",
      "section_title": true,
      "ja": "3.2。接続層制御（CLC）のメッセージ"
    },
    {
      "indent": 3,
      "text": "CLC messages are sent as data payload over the IP network using the TCP connection between SMC-R layers at the peers. They are analogous to the messages used to exchange parameters for SSL.",
      "ja": "CLCメッセージは、ピアでSMC-R層の間のTCP接続を使用して、IPネットワーク上のデータペイロードとして送信されます。彼らは、SSLのためのパラメータを交換するために使用されるメッセージに似ています。"
    },
    {
      "indent": 3,
      "text": "The use of CLC messages is detailed in the following sections. The following list provides a summary of the defined CLC messages and their purposes:",
      "ja": "CLCメッセージの使用は、以下のセクションで詳しく説明されています。以下のリストは、定義されたCLCメッセージとその目的の概要を提供します。"
    },
    {
      "indent": 3,
      "text": "o SMC Proposal: Sent from the client to propose that this TCP connection is eligible to be moved to SMC-R. The client identifies itself and its subnet to the server and passes the SMC-R elements for a suggested RoCE path via the MAC and GID.",
      "ja": "O SMCの提案：このTCP接続はSMC-Rに移動の対象であることを提案し、クライアントから送信されます。クライアントは、サーバに自身とそのサブネットを識別し、MACとGIDを介して提案ROCEパスのSMC-Rの要素を通過します。"
    },
    {
      "indent": 3,
      "text": "o SMC Accept: Sent from the server to accept the client's TCP connection SMC Proposal. The server responds to the client's proposal by identifying itself to the client and passing the elements of a RoCE path that the client can use to perform RDMA writes to the server. This consists of such SMC-R link elements as RoCE MAC, GID, and RMB information.",
      "ja": "O SMCは受け入れ：クライアントのTCPコネクションSMCの提案を受け入れるように、サーバから送信されます。サーバはクライアントに自分自身を識別し、クライアントがRDMAは、サーバーへの書き込みを実行するために使用することができますROCEパスの要素を渡すことによって、クライアントの提案に応答します。これはROCE MAC、GID、及びRMB情報などのSMC-Rリンク要素から成ります。"
    },
    {
      "indent": 3,
      "text": "o SMC Confirm: Sent from the client to confirm the server's acceptance of the SMC connection. The client responds to the server's acceptance by passing the elements of a RoCE path that the server can use to perform RDMA writes to the client. This consists of such SMC-R link elements as RoCE MAC, GID, and RMB information.",
      "ja": "O SMCは確認してください：SMC接続のサーバーの受け入れを確認するために、クライアントから送信されます。クライアントは、サーバがRDMAは、クライアントへの書き込みを実行するために使用することができますROCEパスの要素を渡すことによって、サーバの受け入れに応答します。これはROCE MAC、GID、及びRMB情報などのSMC-Rリンク要素から成ります。"
    },
    {
      "indent": 3,
      "text": "o SMC Decline: Sent from either the server or the client to reject the SMC connection, indicating the reason the peer must decline the SMC Proposal and allowing the TCP connection to revert back to IP connectivity.",
      "ja": "O SMC衰退：ピアはSMCの提案を拒否し、IP接続に戻すためのTCP接続を許可しなければならない理由を示す、サーバやSMCの接続を拒否するために、クライアントのいずれかから送信されます。"
    },
    {
      "indent": 0,
      "text": "3.3. LLC Messages",
      "section_title": true,
      "ja": "3.3。 LLCメッセージ"
    },
    {
      "indent": 3,
      "text": "Link Layer Control (LLC) messages are sent between peer SMC-R layers over an SMC-R link to manage the link or the link group. LLC messages are sent using RoCE SendMsg and are 44 bytes long. The 44-byte size is based on what can fit into a RoCE Work Queue Element (WQE) without requiring the posting of receive buffers.",
      "ja": "リンクレイヤ制御（LLC）のメッセージは、リンクまたはリンクグループを管理するために、SMC-Rのリンク上でピアSMC-R層の間に送信されます。 LLCメッセージはROCE SENDMSGを使用して送信され、44バイトの長されています。 44バイトのサイズは、受信バッファの掲載を必要とせずにROCEワークキュー要素（WQE）に収まることができるものに基づいています。"
    },
    {
      "indent": 3,
      "text": "LLC messages generally follow a request-reply semantic. Each message has a request flavor and a reply flavor, and each request must be confirmed with a reply, except where otherwise noted. The use of LLC messages is detailed in the following sections. The following list provides a summary of the defined LLC messages and their purposes:",
      "ja": "LLCのメッセージは、一般的にセマンティック要求 - 応答に従ってください。各メッセージは、要求風味及び返信風味を有し、各要求は、特記する場合を除いて、応答で確認されなければなりません。 LLCメッセージの使用は、次のセクションで詳しく説明しています。以下のリストは、定義されたLLCのメッセージとその目的の概要を提供します。"
    },
    {
      "indent": 3,
      "text": "o ADD LINK: Used to add a new link to a link group. Sent from the server to the client to initiate addition of a new link to the link group, or from the client to the server to request that the server initiate addition of a new link.",
      "ja": "Oリンクを追加：リンクグループに新しいリンクを追加するために使用します。サーバーは、新しいリンクの追加を開始することを要求するためのリンク群に、またはクライアントからサーバーへの新しいリンクの追加を開始するために、サーバからクライアントに送信されます。"
    },
    {
      "indent": 3,
      "text": "o ADD LINK CONTINUATION: A continuation of ADD LINK that allows the ADD LINK to span multiple commands, because all of the link information cannot be contained in a single ADD LINK message.",
      "ja": "リンク情報のすべてを単一のADDリンクメッセージに含めることができないので、複数のコマンドにまたがるADDリンクを可能ADDリンクの継続：O LINK継続を追加します。"
    },
    {
      "indent": 3,
      "text": "o CONFIRM LINK: Used to confirm that RoCE connectivity over a newly created SMC-R link is working correctly. Initiated by the server. Both this message and its reply must flow over the SMC-R link being confirmed.",
      "ja": "OのCONFIRMのLINK：新しく作成されたSMC-Rリンクを介しROCE接続が正常に動作していることを確認するために使用します。サーバーによって開始されます。 SMC-Rリンク上を流れなければなりません。このメッセージとその応答の両方が確認されています。"
    },
    {
      "indent": 3,
      "text": "o DELETE LINK: When initiated by the server, deletes a specific link from the link group or deletes the entire link group. When initiated by the client, requests that the server delete a specific link or the entire link group.",
      "ja": "Oリンクを削除：サーバーによって開始された場合、リンクグループから特定のリンクを削除したり、リンク全体のグループを削除します。クライアントによって開始された場合、サーバは特定のリンクまたはリンク全体のグループを削除することを要求します。"
    },
    {
      "indent": 3,
      "text": "o CONFIRM RKEY: Informs the peer on the SMC-R link of the addition of an RMB to the link group.",
      "ja": "入出力確認RKEY：リンクグループにRMBの添加のSMC-Rリンク上のピアに通知します。"
    },
    {
      "indent": 3,
      "text": "o CONFIRM RKEY CONTINUATION: A continuation of CONFIRM RKEY that allows the CONFIRM RKEY to span multiple commands, in the event that all of the information cannot be contained in a single CONFIRM RKEY message.",
      "ja": "情報の全ては、単一確認RKEYメッセージに含まれることができない場合には、複数のコマンドにまたがる確認RKEYを許可確認RKEYの継続：O RKEY継続を確認します。"
    },
    {
      "indent": 3,
      "text": "o DELETE RKEY: Informs the peer on the SMC-R link of the deletion of one or more RMBs from the link group.",
      "ja": "O RKEYを削除しますリンクグループからの1件の以上のRMBSの削除のSMC-Rリンク上のピアに通知します。"
    },
    {
      "indent": 3,
      "text": "o TEST LINK: Verifies that an already-active SMC-R link is active and healthy.",
      "ja": "OテストのLINK：既にアクティブSMC-Rのリンクがアクティブで健康的であることを確認します。"
    },
    {
      "indent": 3,
      "text": "o Optional LLC message: Any LLC message in which the two high-order bits of the opcode are b'10'. This optional message must be silently discarded by a receiving peer that does not support the opcode. No such messages are defined in this version of the architecture; however, the concept is defined to allow for toleration of possible advanced, optional functions.",
      "ja": "OオプションLLCメッセージ：オペコードの上位2ビットがB'10' される任意のLLCメッセージ。このオプションのメッセージは黙ってオペコードをサポートしていない受信ピアによって廃棄されなければなりません。そのようなメッセージは、アーキテクチャのこのバージョンで定義されていません。しかし、コンセプトは、可能な高度な、オプション機能の認容可能にするために定義されています。"
    },
    {
      "indent": 3,
      "text": "CONFIRM LINK and TEST LINK are sensitive to which link they flow on and must flow on the link being confirmed or tested. The other flows may flow over any active link in the link group. When there are multiple links in a link group, a response to an LLC message must flow over the same link that the original message flowed over, with the following exceptions:",
      "ja": "LINKとテストリンクを確認して、それらが上を流れると、リンクを確認またはテストされているに流れなければならないリンクに敏感です。他のフローは、リンクグループ内のアクティブなリンクを介して流れることができます。リンクグループ内に複数のリンクがある場合は、LLCのメッセージに対する応答は、元のメッセージは、次の例外を除いて、上に流したのと同じリンク上を流れている必要があります。"
    },
    {
      "indent": 3,
      "text": "o ADD LINK request from a server in response to an ADD LINK from a client.",
      "ja": "OクライアントからのADD LINKに応じてサーバからLINK要求を追加します。"
    },
    {
      "indent": 3,
      "text": "o DELETE LINK request from a server in response to a DELETE LINK from a client.",
      "ja": "OクライアントからDELETE LINKに応じてサーバからのLINK要求を削除します。"
    },
    {
      "indent": 0,
      "text": "3.4. CDC Messages",
      "section_title": true,
      "ja": "3.4。 CDC投稿"
    },
    {
      "indent": 3,
      "text": "Connection Data Control (CDC) messages are sent over the RoCE fabric between peers using RoCE SendMsg and are 44 bytes long. The 44-byte size is based on the size that can fit into a RoCE WQE without requiring the posting of receive buffers. CDC messages are used to describe the socket application data passed via RDMA write operations, as well as TCP connection state information, including producer cursors and consumer cursors, RMBE state information, and failover data validation.",
      "ja": "接続データコントロール（CDC）メッセージはROCE SENDMSGを使用してピア間ROCEファブリックを介して送信し、44バイトの長されています。 44バイトのサイズは、受信バッファの投稿を必要とせずにROCE WQEに収まるサイズに基づいています。 CDCメッセージは、プロデューサカーソルと消費者カーソル、RMBE状態情報、およびフェイルオーバーデータ検証を含むRDMA書き込み操作を介して渡されたソケットのアプリケーションデータ、ならびにTCP接続状態情報を記述するために使用されます。"
    },
    {
      "indent": 0,
      "text": "3.5. Rendezvous Flows",
      "section_title": true,
      "ja": "3.5。ランデブーフロー"
    },
    {
      "indent": 3,
      "text": "Rendezvous information for SMC-R is exchanged as TCP options on the TCP three-way handshake flows to indicate capability, followed by inline TCP negotiation messages to actually do the SMC-R setup. Formats of all rendezvous options and messages discussed in this section are detailed in Appendix A.",
      "ja": "SMC-Rのためのランデブー情報は、TCP 3ウェイハンドシェイクのTCPオプションとして交換され、実際にSMC-Rのセットアップを行うには、インラインTCPネゴシエーションメッセージに続いて、性能を示すために流れます。このセクションで説明するすべてのランデブーオプションとメッセージのフォーマットは、付録Aに詳述されています"
    },
    {
      "indent": 0,
      "text": "3.5.1. First Contact",
      "section_title": true,
      "ja": "3.5.1。第一接触"
    },
    {
      "indent": 3,
      "text": "First contact between RoCE peers occurs when a new SMC-R link group is being set up. This could be because no SMC-R links already exist between the peers, or the server decides to create a new SMC-R link group in parallel with an existing one.",
      "ja": "ROCEピア間の最初の接触は、新しいSMC-Rのリンクグループが設定されている場合に発生します。何のSMC-Rのリンクがすでにピア間存在しない、またはサーバーが既存のものと並行して新しいSMC-Rリンクグループを作成することを決定したので、これは可能性があります。"
    },
    {
      "indent": 0,
      "text": "3.5.1.1. Pre-negotiation of TCP Options",
      "section_title": true,
      "ja": "3.5.1.1。 TCPオプションの事前交渉"
    },
    {
      "indent": 3,
      "text": "The client and server indicate their SMC-R capability to each other using TCP option 254 on the TCP three-way handshake flows.",
      "ja": "クライアントとサーバは、TCP 3ウェイハンドシェイク・フローにTCPオプション254を使用して、お互いに自分のSMC-Rの能力を示します。"
    },
    {
      "indent": 3,
      "text": "A client who wishes to do SMC-R will include TCP option 254 using an ExID equal to the EBCDIC (codepage IBM-1047) encoding of \"SMCR\" on its SYN flow.",
      "ja": "SMCRを行うことを希望するクライアントは、そのSYNフローの「SMCR」のEBCDIC（コードページIBM-1047）の符号化に等しいEXIDを使用してTCPオプション254が含まれます。"
    },
    {
      "indent": 3,
      "text": "A server that supports SMC-R will include TCP option 254 with the ExID value of EBCDIC \"SMCR\" on its SYN-ACK flow. Because the server is listening for connections and does not know where client connections will come from, the server implementation may choose to unconditionally include this TCP option if it supports SMC-R. This may be required for server implementations where extensions to the TCP stack are not practical. For server implementations that can add code to examine and react to packets during the three-way handshake, the server should only include the SMC-R TCP option on the SYN-ACK if the client included it on its SYN packet.",
      "ja": "SMCRをサポートするサーバーは、そのSYN-ACKの流れのEBCDIC「SMCR」のEXID値でTCPオプション254が含まれます。サーバが接続を監視すると、クライアント接続から来るどこを知らないので、サーバーの実装は、それがSMC-Rをサポートしている場合、無条件にこのTCPオプションを含めるように選択することができます。これは、TCPスタックへの拡張は実用的でないサーバの実装のために必要となる場合があります。調べ、3ウェイハンドシェイク中にパケットに反応するようにコードを追加することができ、サーバの実装では、サーバは、クライアントがそのSYNパケットの上に含まれている場合、SYN-ACKのSMC-R TCPオプションを含めるのみ必要があります。"
    },
    {
      "indent": 3,
      "text": "A client who supports SMC-R and meets the three conditions outlined above may optionally include the TCP option for SMC-R on its ACK flow, regardless of whether or not the server included it on its SYN-ACK flow. Some TCP/IP stacks may have to include it if the SMC-R layer cannot modify the options on the socket until the three-way handshake completes. Proprietary servers should not include this option on the ACK flow, since including it on the SYN flow was sufficient to indicate the client's capabilities.",
      "ja": "SMC-Rをサポートし、上記で概説した三つの条件を満たしているクライアントは、任意にかかわらず、サーバがSYN-ACKフローにそれを含めるか否かを、そのACKフローにSMC-RのためのTCPオプションを含むことができます。 3ウェイハンドシェイクが完了するまで、SMC-R層は、ソケットのオプションを変更できない場合、いくつかのTCP / IPスタックは、それを含める必要があります。 SYNの流れでそれを含むことは、クライアントの能力を示すのに十分であったため、独自のサーバは、ACKの流れでこのオプションを含めるべきではありません。"
    },
    {
      "indent": 3,
      "text": "Once the initial three-way TCP handshake is completed, each peer examines the socket options. SMC-R implementations may do this by examining what was actually provided on the SYN and SYN-ACK packets or by performing a getsockopt() operation to determine the options sent by the peer. If neither peer, or only one peer, specified the TCP option for SMC-R, then SMC-R cannot be used on this connection and it proceeds using normal IP flows and processing.",
      "ja": "最初の3ウェイTCPハンドシェイクが完了すると、各ピアは、ソケットオプションを調べます。 SMC-Rの実装は、実際にSYNおよびSYN-ACKパケットまたはピアによって送信されたオプションを決定するためのgetsockopt（）オペレーションを実行することによって提供されたものを調べることによってこれを行うことができます。どちらのピア、または唯一のピアは、SMC-RのためのTCPオプションを指定した場合、SMC-Rは、この接続で使用することができず、それが通常のIPフロー及び処理を使用して進みます。"
    },
    {
      "indent": 3,
      "text": "If both peers specified the TCP option for SMC-R, then the TCP connection is not started yet and the peers proceed to SMC-R negotiation using inline data flows. The socket is not yet turned over to the applications; instead, the respective SMC layers exchange CLC messages over the newly formed TCP connection.",
      "ja": "両方のピアは、SMC-RのためのTCPオプションを指定した場合、TCP接続はまだ開始されておらず、ピアはインラインデータフローを使用してSMC-Rのネゴシエーションに進みます。ソケットは、まだアプリケーションに引き渡されていません。代わりに、それぞれのSMC層が新たに形成されたTCP接続を介してCLCメッセージを交換します。"
    },
    {
      "indent": 0,
      "text": "3.5.1.2. Client Proposal",
      "section_title": true,
      "ja": "3.5.1.2。クライアントの提案"
    },
    {
      "indent": 3,
      "text": "If SMC-R is supported by both peers, the client sends an SMC Proposal CLC message to the server. It is not immediately apparent on this flow from client to server whether this is a new or existing SMC-R link, because in clustered environments a single IP address may represent multiple hosts. This type of cluster virtual IP address can be owned by a network-based or host-based Layer 4 load balancer that distributes incoming TCP connections across a cluster of servers/hosts. For purposes of high availability, other clustered environments may also support the movement of a virtual IP address dynamically from one host in the cluster to another. In summary, the client cannot predetermine that a connection is targeting the same host by simply matching the destination IP address for outgoing TCP connections. Therefore, it cannot predetermine the SMC-R link that will be used for a new TCP connection. This information will be dynamically learned, and the appropriate actions will be taken as the SMC-R negotiation handshake unfolds.",
      "ja": "SMC-Rは、両方のピアでサポートされている場合、クライアントはサーバーにSMC提案CLCメッセージを送信します。クラスタ環境で単一のIPアドレスが複数のホストを表すことができるので、これは、新規または既存のSMC-Rリンクであるかどうかは、クライアントからサーバへのこの流れにすぐに明らかではありません。クラスタの仮想IPアドレスのこのタイプは、サーバ/ホストのクラスタ全体での着信TCP接続を配布するネットワークベースまたはホストベースのレイヤ4ロードバランサが所有することができます。高可用性の目的のために、他のクラスタ環境では、動的に別のクラスタ内の1つのホストからの仮想IPアドレスの動きをサポートすることができます。要約すると、クライアントは接続が簡単に発信TCP接続の宛先IPアドレスを照合することによって、同じホストをターゲットにしていることを事前に決定することはできません。したがって、新しいTCP接続のために使用されるSMC-Rのリンクを事前ことはできません。この情報は、動的に学習され、SMC-Rのネゴシエーションハンドシェイクが繰り広げられるよう適切な措置が取られます。"
    },
    {
      "indent": 3,
      "text": "In the SMC-R proposal message, the initiator (client) proposes the use of SMC-R by including its peer ID, GID, and MAC addresses, as well as the IP subnet number of the outgoing interface (if IPv4) or the IP prefix list for the network over which the proposal is sent (if IPv6). At this point in the flow, the client makes no local commitments of resources for SMC-R.",
      "ja": "SMC-R提案メッセージに、イニシエータ（クライアント）は、ピアID、GID、およびMACアドレス、ならびに発信インターフェイスのIPサブネット番号（IPv4の場合）またはIPを含めることにより、SMC-Rの使用を提案しています提案が送信されるネットワークのプレフィックスリスト（IPv6の場合）。流れのこの時点で、クライアントは、SMC-Rのためのリソースのローカル約束するものではありません。"
    },
    {
      "indent": 3,
      "text": "When the server receives the SMC Proposal CLC message, it uses the peer ID provided by the client, plus subnet or prefix information provided by the client, to determine if it already has a usable SMC-R link with this SMC-R peer. If there are one or more existing SMC-R links with this SMC-R peer, the server then decides which SMC-R link it will use for this TCP connection. See Sections 3.5.2 and 3.5.3 for the cases of reusing an existing SMC-R link or creating a parallel SMC-R link group between SMC-R peers.",
      "ja": "サーバがSMC提案CLCメッセージを受信すると、それは既にこのSMC-Rのピアと使用可能なSMC-Rのリンクを有しているかどうかを決定するために、クライアントによって提供されるピアIDを使用して、プラスサブネットまたはプレフィックス情報は、クライアントによって提供されます。このSMC-Rのピアと1つ以上の既存のSMC-Rのリンクがある場合、サーバーは、SMC-Rは、それがこのTCP接続に使用するリンクを決定します。切片を既存のSMC-Rのリンクを再利用するか、SMC-Rピアとの間に並列SMC-Rリンクグループを作成する場合の3.5.2及び3.5.3を参照。"
    },
    {
      "indent": 3,
      "text": "If this is a first contact between SMC-R peers, the server must validate that it is on the same LAN as the client before continuing. For IPv4, the server does this by verifying that it has an interface with an IP subnet number that matches the subnet number sent by the client in the SMC Proposal. For IPv6, it does this by verifying that it is directly attached to at least one IP prefix that was listed by the client in its SMC Proposal message.",
      "ja": "これはSMC-Rピア間の最初の接触である場合、サーバは、それが継続する前に、クライアントと同じLAN上にあることを検証する必要があります。 IPv4の場合、サーバは、SMCの提案では、クライアントから送信されたサブネット番号と一致するIPサブネット番号とのインタフェースを持っていることを確認することによってこれを行います。 IPv6の場合、それは直接そのSMC提案メッセージにクライアントによって列挙された少なくとも1つのIPプレフィックスに装着されていることを確認することによってこれを行います。"
    },
    {
      "indent": 3,
      "text": "If the server agrees to use SMC-R, the server begins the setup of a new SMC-R link by allocating local QP and RMB resources (setting its QP state to INIT) and providing its full SMC-R information in an SMC Accept CLC message to the client over the TCP connection, along with a flag set indicating that this is a first contact flow. While the SMC Accept message could flow over any IP route back to the client depending upon Layer 3 IP routing, the SMC-R credentials provided must be for the common subnet or prefix between the server and client, as determined above. If the server cannot or does not want to do SMC-R with the client, it sends an SMC Decline CLC message to the client, and the connection data may begin flowing using normal TCP/IP flows.",
      "ja": "サーバがSMC-Rを使用することに同意する場合は、サーバーはCLCを受け入れる地元のQPと人民元リソースを割り当てる（INITにそのQP状態を設定）し、SMCにそのフルSMC-Rの情報を提供することにより、新しいSMC-Rリンクのセットアップを開始しますこれが最初の接触の流れであることを示すフラグセットと共にTCP接続を介してクライアントにメッセージ。 SMCは、メッセージは、レイヤ3のIPルーティングに応じてクライアントに任意のIP経路上を流れる可能性が受け入れながら上記決定されるように、設けられSMC-R認証情報は、サーバとクライアントの間で共通のサブネットまたは接頭辞でなければなりません。サーバがまたはクライアントでSMC-Rをしたくはありませんができない場合は、SMCクライアントにCLCメッセージを拒否送信し、接続データは、通常のTCP / IPフローを使用して流れ始めることができます。"
    },
    {
      "indent": 0,
      "text": "3.5.1.3. Server Acceptance",
      "section_title": true,
      "ja": "3.5.1.3。サーバーの受け入れ"
    },
    {
      "indent": 3,
      "text": "When the client receives the SMC Accept from the server, it determines whether this is a new or existing SMC-R link, using the combination of the following: the first contact flag, its MAC/GID and the MAC/GID returned by the server, the VLAN over which the connection is setting up, and the QP number provided by the server.",
      "ja": "クライアントは、SMCがサーバから受け入れる受信すると、それは次の組み合わせで使用して、これは、新規または既存のSMC-Rリンクであるか否かを判断する：最初のコンタクトフラグを、そのMAC / GIDとMAC / GIDは、サーバから返されました、接続が設定されている上にVLAN、およびサーバによって提供されるQP番号。"
    },
    {
      "indent": 3,
      "text": "If it is an existing SMC-R link and the client agrees to use that link for the TCP connection, see Section 3.5.2 (\"Subsequent Contact\") below. If it is a new SMC-R link between peers that already have an SMC-R link, then the server is starting a new SMC-R link group.",
      "ja": "それは既存のSMC-Rリンクであり、クライアントがTCP接続のためにそのリンクを使用することに同意する場合は、以下のセクション3.5.2（「後続の連絡先」を参照してください）。それはすでにSMC-Rのリンクを持っているピア間の新しいSMC-Rのリンクがある場合、サーバーは新しいSMC-Rリンクグループを開始しています。"
    },
    {
      "indent": 3,
      "text": "Assuming that either (1) this is a first contact between peers or (2) the server is starting a new SMC-R link group, the client now allocates local QP and RMB resources for the SMC-R link (setting the QP state to RTR (ready to receive)), associates them with the server QP as learned from the SMC Accept CLC message, and sends an SMC Confirm CLC message to the server over the TCP connection with its SMC-R link information included. The client also starts a timer to wait for the server to confirm the reliably connected queue pair, as described below.",
      "ja": "いずれかの（1）これはピア又は（2）サーバが新しいSMC-Rリンクグループを起動さとの間の最初の接点であると仮定すると、クライアントは現在のQP状態を設定するSMC-Rリンク（ローカルQPとRMBリソースを割り当てます）RTR（受信する準備ができて）、CLCメッセージを受け入れSMCから学んだように、サーバーのQPでそれらを関連付けて、SMCが含まれ、そのSMC-Rのリンク情報とのTCP接続を介してサーバーにCLCメッセージを確認して送信します。また、クライアントは、サーバが確実に接続されているキュー・ペアを確認するために、以下に説明するように、待機するようにタイマーを開始します。"
    },
    {
      "indent": 0,
      "text": "3.5.1.4. Client Confirmation",
      "section_title": true,
      "ja": "3.5.1.4。顧客の確認"
    },
    {
      "indent": 3,
      "text": "Upon receipt of the client's SMC Confirm CLC message, the server associates its QP for this SMC-R link with the client's QP as learned from the SMC Confirm CLC message and sets its QP state to RTS (ready to send). The client and the server now have reliably connected queue pairs.",
      "ja": "SMCから学んだとして、クライアントのSMCは、CLCメッセージを確認を受信すると、サーバーは、CLCメッセージを確認し、クライアントのQPと、このSMC-RのリンクのためのQPを関連付け、RTS（送信する準備ができ）へのQPの状態を設定します。クライアントとサーバーが確実に接続されているキューのペアを持っています。"
    },
    {
      "indent": 0,
      "text": "3.5.1.5. Link (QP) Confirmation",
      "section_title": true,
      "ja": "3.5.1.5。リンク（QP）確認"
    },
    {
      "indent": 3,
      "text": "Since setting up the SMC-R link and its QPs did not require any network flows on the RoCE fabric, the client and server must now confirm connectivity over the RoCE fabric. To accomplish this, the server will send a CONFIRM LINK Link Layer Control (LLC) message to the client over the newly created SMC-R link, using the RoCE fabric. The CONFIRM LINK LLC message will provide the server's MAC, GID, and QP information for the connection, allow each partner to communicate the maximum number of links it can tolerate in this link group (the \"link limit\"), and will additionally provide two link IDs:",
      "ja": "SMC-Rのリンクを設定し、そののQPは、任意のネットワークがROCEファブリック上を流れる必要はありませんでしたので、クライアントとサーバは現在ROCEの生地の上に、接続を確認しなければなりません。これを実現するために、サーバーは、ROCEの生地を使用して、新しく作成されたSMC-Rのリンクを介してクライアントにCONFIRM LINKリンク層制御（LLC）メッセージを送信します。 CONFIRMリンクLLCメッセージは、接続のためのサーバのMAC、GID、及びQP情報を提供する各パートナーが、それはこのリンクグループ（「リンク制限」）に耐えることができるリンクの最大数を通信することを可能にし、さらに両者を提供するであろうリンクID："
    },
    {
      "indent": 3,
      "text": "o a 1-byte server-assigned link number that is used by both peers to identify the link within the link group and is only unique within a link group.",
      "ja": "Oリンクグループ内のリンクを識別するために、両方のピアによって使用される1バイトのサーバが割り当てたリンク番号、リンクのグループ内でのみ一意です。"
    },
    {
      "indent": 3,
      "text": "o a 4-byte link user ID. This opaque value is assigned by the server for the server's local use and is provided to the client for management purposes -- for example, to use in network management displays and products.",
      "ja": "4バイトのリンクのユーザID、O。この不透明な値は、サーバのローカルでの使用のために、サーバによって割り当てられ、管理目的のためにクライアントに提供される - たとえば、ネットワーク管理が表示され、製品に使用します。"
    },
    {
      "indent": 3,
      "text": "When the server sends this message, it will set a timer for receiving confirmation from the client.",
      "ja": "サーバはこのメッセージを送信するときに、クライアントからの確認を受信するためのタイマーを設定します。"
    },
    {
      "indent": 3,
      "text": "When the client receives the server's confirmation in the form of a CONFIRM LINK LLC message, it will cancel the confirmation timer it set when it sent the SMC Confirm message. The client will also advance its QP state to RTS and respond over the RoCE fabric with a CONFIRM LINK response LLC message that (1) provides its MAC, GID, QP number, and link limit, (2) confirms the 1-byte link number sent by the server, and (3) provides its own 4-byte link user ID to the server.",
      "ja": "クライアントがCONFIRMリンクLLCメッセージの形式で、サーバーの確認を受信すると、それはSMCメッセージを確認して送信したとき、それは設定確認のタイマーをキャンセルします。クライアントはまた、RTSへのQPの状態を進め、（1）そのMACを提供することを確認リンク応答LLCメッセージでROCEファブリック上に応じる、GID、QP数、およびリンク制限、（2）1バイトのリンク番号を確認しますサーバによって送信され、そして（3）サーバに独自の4バイトのリンクユーザIDを提供します。"
    },
    {
      "indent": 4,
      "text": "   Host X -- Server                           Host Y -- Client\n+-------------------+                      +-------------------+\n| Peer ID = PS1     |                      |   Peer ID = PC1   |\n|            +------+                      +------+            |\n|       QP 8 |RNIC 1|                      |RNIC 2|  QP 64     |\n|RToken X|   |MAC MA|                      |MAC MB|   |        |\n|        |   |GID GA|                      |GID GB|   |RToken Y|\n|       \\/   +------+      (Subnet S1)     +------+  \\/        |\n|+--------+         |                      |        +--------+ |\n|| RMB    |         |                      |        | RMB    | |\n|+--------+         |                      |        +--------+ |\n|            +------+                      +------+            |\n|            |RNIC 3|                      |RNIC 4|            |\n|            |MAC MC|                      |MAC MD|            |\n|            |GID GC|                      |GID GD|            |\n|            +------+                      +------+            |\n+-------------------+                      +-------------------+",
      "raw": true
    },
    {
      "indent": 8,
      "text": "             SYN TCP options(254,\"SMCR\")\n<---------------------------------------------------------",
      "raw": true
    },
    {
      "indent": 8,
      "text": "             SYN-ACK TCP options(254,\"SMCR\")\n--------------------------------------------------------->",
      "raw": true
    },
    {
      "indent": 8,
      "text": "             ACK [TCP options(254,\"SMCR\")]\n<--------------------------------------------------------",
      "raw": true
    },
    {
      "indent": 8,
      "text": "            SMC Proposal(PC1,MB,GB,S1)\n<--------------------------------------------------------",
      "raw": true
    },
    {
      "indent": 4,
      "text": "SMC Accept(PS1,first contact,MA,GA,MTU,QP8,RToken=X,RMB elem index)\n    --------------------------------------------------------->",
      "raw": true
    },
    {
      "indent": 9,
      "text": "SMC Confirm(PC1,MB,GB,MTU,QP64,RToken=Y,RMB element index)\n<--------------------------------------------------------",
      "raw": true
    },
    {
      "indent": 7,
      "text": "CONFIRM LINK(MA,GA,QP8, link lim, server link user ID, linknum)\n .........................................................>",
      "raw": true
    },
    {
      "indent": 4,
      "text": "CONFIRM LINK rsp(MB,GB,QP64, link lim, client link user ID, linknum)\n    <........................................................",
      "raw": true
    },
    {
      "indent": 11,
      "text": "                Legend:\n         ------------   TCP/IP and CLC flows\n         ............   RoCE (LLC) flows\nSquare brackets (\"[ ]\") indicate optional information",
      "raw": true
    },
    {
      "indent": 17,
      "text": "Figure 8: First Contact Rendezvous Flows",
      "ja": "図8：ファーストコンタクトランデブー・フロー"
    },
    {
      "indent": 3,
      "text": "Technically, the data for the TCP connection could now flow over the RoCE path. However, if this is a first contact, there is no alternate for this recently established RoCE path. Since in the current architecture there is no failover from RoCE to IP once connection data starts flowing, this means that a failure of this path would disrupt the TCP connection, meaning that the level of redundancy and failover is less than that provided by IP. If the network has alternate RoCE paths available, they would not be usable at this point. This situation would be unacceptable.",
      "ja": "技術的には、TCP接続のためのデータは現在ROCEパス上を流れることができます。これが最初の接触である場合には、この最近設立ROCEパスのための代替はありません。現在のアーキテクチャにIPへのROCEからのフェイルオーバーが存在しないため、接続データが流れ始めると、これは、このパスの障害は、冗長性とフェイルオーバーのレベルはIPで提供されるものよりも小さいことを意味し、TCP接続を中断することを意味します。ネットワークが利用可能な代替ROCEパスを持っている場合、それらはこの時点では使用できないであろう。この状況は受け入れられないだろう。"
    },
    {
      "indent": 0,
      "text": "3.5.1.6. Second SMC-R Link Setup",
      "section_title": true,
      "ja": "3.5.1.6。第二にSMC-Rリンクのセットアップ"
    },
    {
      "indent": 3,
      "text": "Because of the unacceptable situation described above, TCP data will not be allowed to flow on the newly established SMC-R link until a second path has been set up, or at least attempted.",
      "ja": "なぜなら、上述の容認できない状況で、TCPデータを第2パスが設定、または少なくとも試みられてきたまで新設SMC-Rリンクで流すことがないであろう。"
    },
    {
      "indent": 3,
      "text": "If the server has a second RNIC available on the same LAN, it attempts to set up the second SMC-R link over that second RNIC. If it only has one RNIC available on the LAN, it will attempt to set up the second SMC-R link over that one RNIC. In the latter case, the server is attempting to set up an asymmetric link, in case the client does have a second RNIC on the LAN.",
      "ja": "サーバーが同じLAN上で使用可能な2つ目のRNICを持っている場合、それは、第2 RNIC上に第2のSMC-Rのリンクを設定しようとします。それが唯一のLANで利用可能な1つのRNICを持っている場合は、その1つのRNIC上に第2のSMC-Rのリンクを設定しようとします。後者の場合、サーバーは、クライアントがLAN上の第二RNICを持っていない場合には、非対称リンクを設定しようとしています。"
    },
    {
      "indent": 3,
      "text": "In either case, the server allocates a new QP over the RNIC it is attempting to use for the second link and assigns a link number to the new link; the server also creates an RToken for the RMB over this second QP (note that this means that the first and second QP each have their own RToken to represent the same RMB). The server provides this information, as well as the MAC and GID of the RNIC over which it is attempting to set up the second link, in an ADD LINK LLC message that it sends to the client over the SMC-R link that is already set up.",
      "ja": "いずれの場合も、サーバーは、第2のリンクのために使用しようとしてRNICを超える新しいQPを割り当て、新しいリンクへのリンク番号を割り当てます。また、サーバは、この第二のQP上RMB（これは、第1および第2のQPそれぞれ独自RTOKENが同じRMBを表現しなければならないことを意味することに留意されたい）のためRTOKENを作成します。サーバは、この情報を提供するだけでなく、すでに設定されているSMC-Rのリンクを介してクライアントに送信するADDリンクLLCのメッセージでは、第2のリンクを設定しようとしている上RNICのMACおよびGIDアップ。"
    },
    {
      "indent": 0,
      "text": "3.5.1.6.1. Client Processing of ADD LINK LLC Message from Server",
      "section_title": true,
      "ja": "3.5.1.6.1。サーバーからADDリンクLLCメッセージのクライアント処理"
    },
    {
      "indent": 3,
      "text": "When the client receives the server's ADD LINK LLC message, it examines the GID and MAC provided by the server to determine whether the server is attempting to use the same server-side RNIC as the existing SMC-R link or a different one.",
      "ja": "クライアントがサーバーのADDリンクLLCメッセージを受信すると、サーバが提供するGIDとMACは、サーバが既存のSMC-Rリンクまたは異なるものと同じサーバー側RNICを使用しようとしているかどうかを判断するために調べます。"
    },
    {
      "indent": 3,
      "text": "If the server is attempting to use the same server-side RNIC as the existing SMC-R link, then the client verifies that it has a second RNIC on the same LAN. If it does not, the client rejects the ADD LINK request from the server, because the resulting link would be a parallel link, which is not supported within a link group. If the client does have a second RNIC on the same LAN, it accepts the request, and an asymmetric link will be set up.",
      "ja": "サーバーは、既存のSMC-Rのリンクと同じサーバー側RNICを使用しようとしている場合、クライアントは、同じLAN上の第二RNICを持っていることを確認します。そうでない場合は結果のリンクは、リンクグループ内でサポートされていない平行リンク、になるので、クライアントは、サーバーからのADD LINK要求を拒否します。クライアントが同じLAN上の第2のRNICを持っている場合は、その要求を受け付け、非対称リンクが設定されます。"
    },
    {
      "indent": 3,
      "text": "If the server is using a different server-side RNIC from the existing SMC-R link, then the client will accept the request and a second SMC-R link will be set up in this SMC-R link group. If the client has a second RNIC on the same LAN, that second RNIC will be used for the second SMC-R link, creating symmetric links. If the client does not have a second RNIC on the same LAN, it will use the same RNIC as was used for the initial SMC-R link, resulting in the setup of an asymmetric link in the SMC-R link group.",
      "ja": "サーバーは、既存のSMC-Rのリンクから別のサーバー側RNICを使用している場合、クライアントは要求を受け入れると第二SMC-Rリンクは、このSMC-Rのリンクグループに設定されます。クライアントが同じLAN上の第二RNICを持っている場合は、その第二RNICは、対称リンクを作成する、二SMC-Rのリンクに使用されます。クライアントが同じLAN上の第2のRNICを持っていない場合は、SMC-Rリンクグループにおける非対称リンクの設定で、その結果、初期のSMC-Rのリンクに使用されたのと同じRNICを使用します。"
    },
    {
      "indent": 3,
      "text": "In either case, when the client accepts the server's ADD LINK request, it allocates a new QP on the chosen RNIC and creates an RKey over that new QP for the client-side RMB for the SMC-R link group, then sends an ADD LINK reply LLC message to the server providing that information as well as echoing the link number that was sent by the server.",
      "ja": "クライアントは、サーバーの[リンクの追加要求を受け付け、いずれの場合では、それは選ばれたRNICに新しいQPを割り当て、SMC-Rのリンクグループのクライアント側の人民元のためにその新しいQPオーバーRKEYを作成し、その後、ADDのLINKを送信その情報を提供するだけでなく、サーバーによって送信されたリンク番号をエコーサーバにLLCのメッセージを返信します。"
    },
    {
      "indent": 3,
      "text": "If the client rejects the server's ADD LINK request, it sends an ADD LINK reply LLC message to the server with the reason code for the rejection.",
      "ja": "クライアントは、サーバーの[リンクの追加要求を拒否した場合、それは拒否の理由コードを使用してサーバにADDのLINK応答LLCメッセージを送信します。"
    },
    {
      "indent": 0,
      "text": "3.5.1.6.2. Server Processing of ADD LINK Reply LLC Message from Client",
      "section_title": true,
      "ja": "3.5.1.6.2。 ADDのLINKのサーバ処理がクライアントからLLCメッセージを返信"
    },
    {
      "indent": 3,
      "text": "If the client sends a negative response to the server or no reply is received, the server frees the RoCE resources it had allocated for the new link. Having a single link in an SMC-R link group is undesirable. The server's recovery is detailed in Appendix C.8 (\"Failure to Add Second SMC-R Link to a Link Group\").",
      "ja": "クライアントがサーバに否定応答を送信するか、応答がない場合、サーバーは、それが新しいリンク用に割り当てられていたROCEのリソースを解放します。 SMC-Rリンクグループ内の単一のリンクを持つことは望ましくありません。サーバーの回復は、付録C.8（「リンクグループに2つ目のSMC-Rのリンクを追加に失敗」）に詳述されています。"
    },
    {
      "indent": 3,
      "text": "If the client sends a positive reply to the server with MAC/GID/QP/RKey information, the server associates its QP for the new SMC-R link to the QP that the client provided. Now, the new SMC-R link is in the same situation that the first was in after the client sent its ACK packet -- there is a reliably connected queue pair over the new RoCE path, but there have been no RoCE flows to confirm that it's actually usable. So, at this point, the client and server will exchange CONFIRM LINK LLC messages just like they did on the first SMC-R link.",
      "ja": "クライアントがMAC / GID / QP / RKEYの情報をサーバーに肯定応答を送信した場合、サーバーは、クライアントが提供したQPに新しいSMC-RのリンクのためのQPを関連付けます。新しいSMC-Rリンクは、最初のクライアントがそのACKパケットを送信した後であったと同じ状況にある今、 - 新しいROCEパスオーバー確実に接続されたキュー・ペアがあるが、ないROCEがなかったことを確認するために流れ、それは、実際に使用可能です。だから、この時点では、クライアントとサーバは、彼らが最初にSMC-Rリンクで行ったようLINK LLCのメッセージを確認して交換します。"
    },
    {
      "indent": 3,
      "text": "If either peer receives a failure during this second CONFIRM LINK LLC exchange (either an immediate failure -- which implies that the message did not reach the partner -- or a timeout), it sends a DELETE LINK LLC message to the partner over the first (and now only) link in the link group. This DELETE LINK LLC message must be acknowledged before data can flow on the single link in the link group.",
      "ja": "どちらかのピアがこの第二CONFIRMリンクLLC交換時の失敗（ - メッセージが相手に到達しなかったことを意味 - のいずれかの即時失敗またはタイムアウト）を受信した場合、それは最初の上にパートナーにDELETE LINK LLCメッセージを送信しますリンクグループ内（今だけ）リンク。データがリンクグループ内の単一のリンク上を流れることができる前に、このDELETE LINK LLCメッセージを確認する必要があります。"
    },
    {
      "indent": 4,
      "text": "   Host X -- Server                           Host Y -- Client\n+-------------------+                      +-------------------+\n| Peer ID = PS1     |                      |   Peer ID = PC1   |\n|            +------+                      +------+            |\n|       QP 8 |RNIC 1|      SMC-R Link 1    |RNIC 2|  QP 64     |\n|RToken X|   |MAC MA|<-------------------->|MAC MB|   |        |\n|        |   |GID GA|                      |GID GB|   |RToken Y|\n|       \\/   +------+                      +------+  \\/        |\n|+--------+         |                      |        +--------+ |\n||        |         |                      |        |        | |\n|| RMB    |         |                      |        | RMB    | |\n||        |         |                      |        |        | |\n|+--------+         |                      |        +--------+ |\n|       /\\   +------+                      +------+  /\\        |\n|        |   |RNIC 3|      SMC-R Link 2    |RNIC 4|  |         |\n|RToken Z|   |MAC MC|<-------------------->|MAC MD|  |RToken W |\n|       QP 9 |GID GC|      (being added)   |GID GD| QP 65      |\n|            +------+                      +------+            |\n+-------------------+                      +-------------------+",
      "raw": true
    },
    {
      "indent": 12,
      "text": "    First SMC-R link setup as shown in Figure 8\n<-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.->",
      "raw": true
    },
    {
      "indent": 12,
      "text": "ADD LINK request(QP9,MC,GC, link number = 2)\n............................................>",
      "raw": true
    },
    {
      "indent": 12,
      "text": "ADD LINK response(QP65,MD,GD, link number = 2)\n<............................................",
      "raw": true
    },
    {
      "indent": 12,
      "text": "ADD LINK CONTINUATION request(RToken=Z)\n............................................>",
      "raw": true
    },
    {
      "indent": 11,
      "text": "ADD LINK CONTINUATION response(RToken=W)\n <............................................",
      "raw": true
    },
    {
      "indent": 9,
      "text": "CONFIRM LINK(MC,GC,QP9, link number = 2, link user ID)\n   .............................................>",
      "raw": true
    },
    {
      "indent": 6,
      "text": "CONFIRM LINK response(MD,GD,QP65, link number = 2, link user ID)\n      <.............................................",
      "raw": true
    },
    {
      "indent": 19,
      "text": "       Legend:\n------------   TCP/IP and CLC flows\n............   RoCE (LLC) flows",
      "raw": true
    },
    {
      "indent": 16,
      "text": "Figure 9: First Contact, Second Link Setup",
      "ja": "図9：ファーストコンタクト、第2のリンクの設定"
    },
    {
      "indent": 0,
      "text": "3.5.1.6.3. Exchange of RKeys on Second SMC-R Link",
      "section_title": true,
      "ja": "3.5.1.6.3。第二にSMC-Rリンク上RKeysの交換"
    },
    {
      "indent": 3,
      "text": "Note that in the scenario described here -- first contact -- there is only one RMB RKey to exchange on the second SMC-R link, and it is exchanged in the ADD LINK CONTINUATION request and reply. In scenarios other than first contact -- for example, adding a new SMC-R link to a longstanding link group with multiple RMBs -- additional flows will be required to exchange additional RMB RKeys. See Section 3.5.5.2.3 (\"Adding a New SMC-R Link to a Link Group with Multiple RMBs\") for more details on these flows.",
      "ja": "最初の接触は -   - つのみRMB RKEYが第SMC-Rリンクで交換することがあり、それはADDリンク継続要求と応答で交換される、ここで説明するシナリオであることに注意してください。複数RMBSと長年リンクグループに新しいSMC-Rのリンクを追加すること、例えば、 -   - 第一の接点以外のシナリオでは、追加のフローを追加人民元RKeysを交換する必要があります。これらのフローの詳細については、セクション3.5.5.2.3（「複数のRMBSとリンクグループに新しいSMC-Rリンクの追加」を参照）を参照してください。"
    },
    {
      "indent": 0,
      "text": "3.5.1.6.4. Aborting SMC-R and Falling Back to IP",
      "section_title": true,
      "ja": "3.5.1.6.4。 SMC-Rを中止し、IPにフォールバック"
    },
    {
      "indent": 3,
      "text": "If both partners don't provide the SMC-R TCP option during the three-way TCP handshake, the connection falls back to normal TCP/IP. During the SMC-R negotiation that occurs after the three-way TCP handshake, either partner may break off SMC-R by sending an SMC Decline CLC message. The SMC Decline CLC message may be sent in place of any expected message and may also be sent during the CONFIRM LINK LLC exchange if there is a failure before any application data has flowed over the RoCE fabric. For more details on exactly when an SMC Decline can flow during link group setup, see Appendices C.1 (\"SMC Decline during CLC Negotiation\") and C.2 (\"SMC Decline during LLC Negotiation\").",
      "ja": "両方のパートナーが3ウェイTCPハンドシェイク中にSMC-R TCPオプションを提供しない場合は、接続が正常に戻っTCP / IPに落ちます。 3ウェイTCPハンドシェイクの後に発生したSMC-Rのネゴシエーション中に、いずれかのパートナーは、SMC衰退CLCメッセージを送信することにより、SMC-Rを断つことがあります。 SMCは、CLCメッセージを拒否任意予想メッセージの代わりに送信されても​​よく、データはROCEファブリック上に流した任意のアプリケーションの前に障害がある場合もCONFIRMリンクLLC交換中に送信されても​​よいです。 SMCの衰退は、リンク・グループのセットアップ中に流れることができる正確にいつの詳細については、付録C.1（「CLC交渉中のSMC衰退」）とC.2（「LLCネゴシエーション中にSMCの低下を」）を参照してください。"
    },
    {
      "indent": 3,
      "text": "If this fallback to IP happens while setting up a new SMC-R link group, the RoCE resources allocated for this SMC-R link group relationship are torn down, and it will be retried as a new SMC-R link group next time a connection starts between these peers with SMC-R proposed. Note that if this happens because one side doesn't support SMC-R, there will be very little to tear down, as the TCP option will have failed to flow on either the initial SYN or the SYN-ACK before either side had reserved any local RoCE resources.",
      "ja": "新しいSMC-Rリンクグループを設定しながら、IPにこのフォールバックが発生した場合は、このSMC-Rリンクグループの関係に割り当てられたROCEリソースが切断され、それは次回の接続新しいSMC-Rリンクグループとして再試行されます提案されたSMC-Rでこれらのピア間で開始します。片側がSMC-Rをサポートしていないので、どちらかの側がいずれかを予約していた前に、TCPオプションは、最初のSYNまたはSYN-ACKのいずれかに流れるように失敗しているので、これが発生した場合は、取り壊すことは非常にほとんどないことに注意してくださいローカルROCE資源。"
    },
    {
      "indent": 0,
      "text": "3.5.2. Subsequent Contact",
      "section_title": true,
      "ja": "3.5.2。その後の連絡先"
    },
    {
      "indent": 3,
      "text": "\"Subsequent contact\" means setting up a new TCP connection between two peers that already have an SMC-R link group between them and reusing the existing SMC-R link group. In this case, it is not necessary to allocate new QPs. However, it is possible that a new RMB has been allocated for this TCP connection, if the previous TCP connection used the last element available in the previously used RMB, or for any other implementation-dependent reason. For this reason, and for convenience and error checking, the same TCP option 254, followed by the inline negotiation method described for initial contact, will be used for subsequent contact, but the processing differs in some ways. That processing is described below.",
      "ja": "「その後の接触は、」すでに彼らと再利用、既存のSMC-Rリンクグループの間でSMC-Rリンクグループを持つ2つのピア間の新しいTCP接続を設定することを意味します。この場合、新しいのQPを割り当てる必要はありません。しかし、以前のTCP接続が以前に使用した人民元で利用可能な最後の要素を使用し、またはその他の実装依存の理由であれば、新たな人民元は、このTCP接続のために割り当てられている可能性があります。このため、利便性とエラーチェックのために、最初の接触のために説明したインライン交渉方法に続いて同じTCPオプション254は、その後の接触のために使用されますが、処理はいくつかの点で異なります。その処理について説明します。"
    },
    {
      "indent": 0,
      "text": "3.5.2.1. SMC-R Proposal",
      "section_title": true,
      "ja": "3.5.2.1。 SMC-Rの提案"
    },
    {
      "indent": 3,
      "text": "When the client begins the inline negotiation with the server, it does not know if this is a first contact or a subsequent contact. The client cannot know this information until it sees the server's peer ID, to determine whether or not it already has an SMC-R link with this peer that it can use. There are several reasons why it is not sufficient to use the partner IP address, subnet, VLAN, or other IP information to make this determination. The most obvious reason is distributed systems: if the server IP address is actually a virtual IP address representing a distributed cluster, the actual host serving this TCP connection may not be the same as the host that served the last TCP connection to this same IP address.",
      "ja": "クライアントがサーバーとインラインネゴシエーションを開始すると、これが最初の接触や、その後の接触であれば、それは知りません。それはすでに、それは使用することができ、このピアとSMC-Rのリンクを持っているかどうかを判断するために、サーバーのピアのIDを見るまで、クライアントは、この情報を知ることができません。この決意をするために、パートナーのIPアドレス、サブネット、VLAN、または他のIP情報を使用するには十分ではない理由はいくつかあります。最も明白な理由は、システムが配布されます。サーバーIPアドレスは、実際に、分散クラスタを表す仮想IPアドレスであれば、このTCPコネクションを提供する実際のホストが同じIPアドレスへの最後のTCP接続を務めたホストと同じではないかもしれません。"
    },
    {
      "indent": 3,
      "text": "After the TCP three-way handshake, assuming that both partners indicate SMC-R capability, the client builds and sends the SMC Proposal CLC message to the server in exactly the same manner as it does in the \"first contact\" case, and in fact at this point doesn't know if it's a first contact or a subsequent contact. As in the \"first contact\" case, the client sends its peer ID value, suggested RNIC MAC/GID, and IP subnet or prefix information.",
      "ja": "TCP 3ウェイハンドシェイクの後、両方のパートナーは、SMC-Rの能力を示すと仮定して、クライアントが構築し、それが「最初の接触」の場合でないとまったく同じように、サーバーにSMC提案CLCメッセージを送信し、実際にはそれが最初の接触や、その後の連絡先の場合は、この時点では知りません。 「最初の接触」の場合のように、クライアントはそのピアID値を送信し、RNIC MAC / GID、およびIPサブネットまたはプレフィックス情報を示唆しました。"
    },
    {
      "indent": 3,
      "text": "Upon receiving the client's proposal, the server looks up the provided peer ID to determine if it already has a usable SMC-R link group with this peer. If it does already have a usable SMC-R link group, the server then needs to decide whether it will use the existing SMC-R link group or create a new link group. For the case of the new link group, see Section 3.5.3 (\"First Contact Variation: Creating a Parallel Link Group\") below.",
      "ja": "クライアントの提案を受信すると、サーバは、それがすでにこのピアで使用可能なSMC-Rリンクグループを持っているかどうかを判断するために提供ピアIDを検索します。それは、すでに使用可能なSMC-Rリンクグループを持っていない場合は、サーバは、それが既存のSMC-Rリンクグループを使用するか、新しいリンクグループを作成するかどうかを決定する必要があります。新しいリンクグループの場合には、第3.5.3項（「ファーストコンタクトバリエーションを：パラレルリンクグループの作成」）を参照してください以下。"
    },
    {
      "indent": 3,
      "text": "For this discussion, assume that the server decides to use the existing SMC-R link group for the TCP connection, which is expected to be the most common case. The server is responsible for making this decision. The server then needs to communicate that information to the client, but it is not necessary to allocate, associate, and confirm QPs for the chosen SMC-R link. All that remains to be done is to set up RMB space for this TCP connection.",
      "ja": "この議論のために、サーバは最も一般的なケースであることが予想されるTCPコネクション、既存のSMC-Rリンクグループを使用することを決定したことを想定しています。サーバーは、この決定を行うための責任があります。次に、サーバはクライアントにその情報を通信する必要があるが、割り当て会合、および選択されたSMC-RリンクのためのQPを確認する必要はありません。行う必要が残っているのは、このTCP接続のために人民元のスペースを設定することです。"
    },
    {
      "indent": 3,
      "text": "If one of the RMBs already in use for this SMC-R link group has an available element that uses the appropriate buffer size, the server merely chooses one for this TCP connection and then sends an SMC Accept CLC message providing the full RoCE information for the chosen SMC-R link to the client, using the same format as the SMC Accept CLC message described in Section 3.5.1 (\"First Contact\") above.",
      "ja": "このSMC-Rリンクグループの既に使用されているRMBSの一つは、適切なバッファサイズを使用して利用可能な要素を持っている場合、サーバは単にこのTCP接続のための1つを選択し、その後の完全なROCE情報を提供するCLC AcceptメッセージをSMCを送信します。 SMCは、セクション3.5.1（「ファースト・コンタクト」）に記載CLC Acceptメッセージと同じフォーマットを使用して、クライアントにSMC-Rのリンクを選択しました。"
    },
    {
      "indent": 3,
      "text": "The server may choose to use the SMC-R link that matches the suggested MAC/GID provided by the client in the SMC Proposal for its RDMA writes but is not obligated to do so. The final decision on which specific SMC-R link to assign a TCP connection to is an independent server and client decision.",
      "ja": "サーバーは、そのRDMAの書き込み用のSMCの提案で、クライアントが提供する提案MAC / GIDと一致しますが、そうする義務を負いませんSMC-Rのリンクを使用することもできます。 TCP接続を割り当てることで、特定のSMC-Rリンク最終決定は、独立したサーバーとクライアントの決定です。"
    },
    {
      "indent": 3,
      "text": "It may be necessary for the server to allocate a new RMB for this connection. The reasons for this are implementation dependent and could include the following:",
      "ja": "サーバーがこの接続のための新しい人民元を割り当てることが必要になることがあります。この理由は、実装依存しており、以下のものが含まれることができます："
    },
    {
      "indent": 3,
      "text": "o no available space in existing RMB or RMBs, or",
      "ja": "O既存の人民元やRMBSでありません使用可能なスペース、または"
    },
    {
      "indent": 3,
      "text": "o desire to allocate a new RMB that uses a different buffer size from the ones already created, or",
      "ja": "Oすでに作成とは異なるバッファサイズを使用する新しい人民元を割り当てることを望む、または"
    },
    {
      "indent": 3,
      "text": "o any other implementation-dependent reason",
      "ja": "O他の実装に依存する理由"
    },
    {
      "indent": 3,
      "text": "In this case, the server will allocate the new RMB and then perform the flows described in Section 3.5.5.2.1 (\"Adding a New RMB to an SMC-R Link Group\"). Once that processing is complete, the server then provides the full RoCE information, including the new RKey, for this connection in an SMC Confirm CLC message to the client.",
      "ja": "この場合、サーバは、新しいRMBを割り当て、次いで、（「SMC-Rリンクグループに新しいRMBの追加」）セクション3.5.5.2.1に記載のフローを実行します。その処理が完了すると、サーバはクライアントにCLCメッセージを確認SMCでこの接続のために、新しいRKEYを含む、完全なROCE情報を提供します。"
    },
    {
      "indent": 0,
      "text": "3.5.2.2. SMC-R Acceptance",
      "section_title": true,
      "ja": "3.5.2.2。 SMC-Rの受け入れ"
    },
    {
      "indent": 3,
      "text": "Upon receiving the SMC Accept CLC message from the server, the client examines the RoCE information provided by the server to determine whether this is a first contact for a new SMC-R link group or a subsequent contact for an existing SMC-R link group. It is a subsequent contact if the server-side peer ID, GID, MAC, and QP number provided in the packet match a known SMC-R link, and the first contact flag is not set. If this is not the case -- for example, the GID and MAC match but the QP is new -- then the server is creating a new, parallel SMC-R link group, and this is treated as a first contact.",
      "ja": "サーバーからCLCメッセージを受け入れSMCを受信すると、クライアントは、これが新しいSMC-Rリンクグループまたは既存のSMC-Rリンクグループの後続の接触のための最初の接点であるかどうかを決定するためにサーバによって提供ROCE情報を調べます。これは、サーバー側のピアIDは、パケット内に設けられたGID、MAC、及びQPの数は既知SMC-Rリンクと一致する場合、後続のコンタクトであり、第1のコンタクトフラグがセットされていません。そうでない場合 - その後、サーバは、新しい並列SMC-Rリンクグループを作成し、これを最初の接点として扱われる - 例えば、GIDとMACが一致するが、QPは、新規です。"
    },
    {
      "indent": 3,
      "text": "A different RMB RToken does not indicate a first contact, as the server may have allocated a new RMB or may be using several RMBs for this SMC-R link. The client needs the server's RMB information only for its RDMA writes to the server, and since there is no requirement for symmetric RMBs, this information is simply control information for the RDMA writes on this SMC-R link.",
      "ja": "サーバは新しいRMBを割り当てられている場合があり、またはこのSMC-RリンクのためのいくつかのRMBSを使用することができるように、異なるRMB RTOKENは、最初の接触を示すものではありません。クライアントは、RDMAは、サーバーへの書き込みのみのために、サーバーの人民元の情報を必要とし、対称型RMBSのための要件が​​ないため、RDMAは、このSMC-Rのリンク上の書き込みのために、この情報は単に情報を制御しています。"
    },
    {
      "indent": 3,
      "text": "The client must validate that the RMB element being provided by the server is not in use by another TCP connection on this SMC-R link group. This validation must validate the new <rtoken, index> across all known <rtoken, index> on this link group. See Section 4.4.2 (\"RMB Element Reuse and Conflict Resolution\") for the case in which the server tries to use an RMB element that is already in use on this link group.",
      "ja": "クライアントは、サーバによって提供されている人民元の要素は、このSMC-Rリンクグループ内の別のTCP接続で使用されていないことを検証する必要があります。この検証は、このリンクグループのすべての知られている<RTOKEN、インデックス>全体で新しい<RTOKEN、インデックス>を検証する必要があります。サーバはこのリンクグループですでに使用されている人民元の要素を使用しようとした場合の4.4.2項（「人民元要素の再利用および紛争解決を」）を参照してください。"
    },
    {
      "indent": 3,
      "text": "Once the client has determined that this TCP connection is a subsequent contact over an existing SMC-R link, it performs an RMB allocation process similar to what the server did: it either (1) allocates an element from an RMB already associated with this SMC-R link or (2) allocates a new RMB, associates it with this SMC-R link, and then chooses an element out of it.",
      "ja": "クライアントがこのTCP接続が既存のSMC-Rリンクを介して後続の接触であると判断したならば、それはサーバが行ったものと同様RMB割り当て処理を実行する：それは、（1）既にこのSMCに関連付けられている元から要素を割り当てるのいずれか-Rリンクまたは（2）は、新しいRMBを割り当て、このSMC-Rリンクに関連付け、そしてそれから要素を選択します。"
    },
    {
      "indent": 3,
      "text": "If the client allocates a new RMB for this TCP connection, it performs the processing described in Section 3.5.5.2.1 (\"Adding a New RMB to an SMC-R Link Group\"). Once that processing is complete, the client provides its full RoCE information for this TCP connection in an SMC Confirm CLC message.",
      "ja": "クライアントがこのTCP接続のための新しい人民元を割り当てた場合、それはセクション3.5.5.2.1に記述された処理を実行する（「SMC-Rリンクグループに新しい人民元の追加」を参照）。その処理が完了すると、クライアントは、CLCメッセージを確認SMCでこのTCP接続のための完全なROCE情報を提供します。"
    },
    {
      "indent": 3,
      "text": "Because an SMC-R link with a verified connected QP already exists and is being reused, there is no need for verification or alternate QP selection flows or timers.",
      "ja": "検証接続QPとSMC-Rリンクが既に存在して再利用されているため、検証または代替QP選択フローまたはタイマーは不要です。"
    },
    {
      "indent": 0,
      "text": "3.5.2.3. SMC-R Confirmation",
      "section_title": true,
      "ja": "3.5.2.3。 SMC-Rの確認"
    },
    {
      "indent": 3,
      "text": "When the server receives the client's SMC Confirm CLC message on a subsequent contact, it verifies the following:",
      "ja": "サーバーがクライアントのSMCは、その後の接触にCLCメッセージを確認して受信すると、次のことを検証します。"
    },
    {
      "indent": 3,
      "text": "o The RMB element provided by the client is not already in use by another TCP connection on this SMC-R link group (see Section 4.4.2 (\"RMB Element Reuse and Conflict Resolution\") for the case in which it is).",
      "ja": "クライアントが提供する人民元の要素は、このSMC-Rリンクグループ内の別のTCP接続で使用されていないO（4.4.2項（それがある場合のために、「人民元の要素の再利用および紛争解決を」）を参照してください）。"
    },
    {
      "indent": 3,
      "text": "o The MAC/GID/QP information provided by the client matches an active link within the link group. The client is free to select any valid/active link. The client is not required to select the same link as the server.",
      "ja": "Oクライアントによって提供されるMAC / GID / QP情報は、リンクグループ内のアクティブリンクに一致します。クライアントは、任意の有効な/アクティブリンクを自由に選択することができます。クライアントがサーバーと同じリンクを選択する必要はありません。"
    },
    {
      "indent": 3,
      "text": "If this validation passes, the server stores the client's RMB information for this connection, and the RoCE setup of the TCP connection is complete.",
      "ja": "この検証に合格した場合、サーバーはこの接続のために、クライアントの人民元情報を格納し、TCPコネクションのROCEのセットアップは完了です。"
    },
    {
      "indent": 0,
      "text": "3.5.2.4. TCP Data Flow Race with SMC Confirm CLC Message",
      "section_title": true,
      "ja": "3.5.2.4。 SMCとのTCPデータフロー人種CLCメッセージを確認"
    },
    {
      "indent": 3,
      "text": "On a subsequent contact TCP/IP connection, a peer may send data as soon as it has received the peer RMB information for the connection. There are no additional RoCE confirmation flows, since the QPs on the SMC-R link are already reliably connected and verified.",
      "ja": "その後の接触TCP / IP接続では、ピアは、すぐにそれは、接続のピア人民元の情報を受信したとしてデータを送信することができます。 SMC-Rリンク上のQPは既に確実に接続され、検証されているので、追加のROCE確認フローは、ありません。"
    },
    {
      "indent": 3,
      "text": "In the majority of cases, the first data will flow from the client to the server. The client must send the SMC Confirm CLC message before sending any connection data over the chosen SMC-R link; however, the client need not wait for confirmation of this message, and in fact there will be no such confirmation. Since the server is required to have the RMB fully set up and ready to receive data from the client before sending an SMC Accept CLC message, the client can begin sending data over the SMC-R link immediately upon completing the send of the SMC Confirm CLC message.",
      "ja": "ほとんどの場合、最初のデータは、クライアントからサーバーに流れます。クライアントは、SMCが選ばれたSMC-Rリンクを介して任意の接続データを送信する前にCLCメッセージを確認して送信する必要があります。ただし、クライアントは、このメッセージの確認を待つ必要はなく、実際にはそのような確認はありません。サーバは、人民元が完全に設定し、CLCメッセージを受け入れSMCを送信する前に、クライアントからのデータを受信する準備が要求されるので、クライアントはすぐにSMCを確認してくださいCLCの送信が完了するとSMC-Rのリンクを介してデータの送信を開始することができますメッセージ。"
    },
    {
      "indent": 3,
      "text": "It is possible that data from the client will arrive at the server-side RMB before the SMC Confirm CLC message from the client has been processed. In this case, the server must handle this race condition and not provide the arrived TCP data to the socket application until the SMC Confirm CLC message has been received and fully processed, opening the socket.",
      "ja": "SMCが処理されたクライアントからのCLCメッセージを確認する前に、クライアントからのデータがサーバー側の元に到着する可能性があります。この場合、サーバはこの競合状態を処理しなければならないし、SMCは、CLCメッセージが受信され、完全にソケットを開いて、処理されたことを確認するまで、ソケットアプリケーションに到着したTCPデータを提供しません。"
    },
    {
      "indent": 3,
      "text": "If the server has initial data to send to the client that is not a response to the client (this case should be rare), it can send the data immediately upon receiving and processing the SMC Confirm CLC message from the client. The client must have opened the TCP socket to the client application upon sending the SMC Confirm CLC message so the client will be ready to process data from the server.",
      "ja": "サーバはクライアントへの応答（この場合は稀であるべき）ではないクライアントに送信する初期データを持っている場合、それはクライアントからのCLCのメッセージを確認してSMCを受信して​​処理した直後にデータを送信することができます。クライアントは、クライアントがサーバーからのデータを処理できるようになりますので、SMCは、CLCメッセージを確認して送信すると、クライアントアプリケーションにTCPソケットを開いている必要があります。"
    },
    {
      "indent": 0,
      "text": "3.5.3. First Contact Variation: Creating a Parallel Link Group",
      "section_title": true,
      "ja": "3.5.3。ファーストコンタクトバリエーション：パラレルリンクグループの作成"
    },
    {
      "indent": 3,
      "text": "Recall that parallel SMC-R links within an SMC-R link group are not supported. These are multiple SMC-R links within a link group that use the same network path. However, multiple SMC-R link groups between the same peers are supported. This means that if multiple SMC-R links over the same RoCE path are desired, it is necessary to use multiple SMC-R link groups. While not a recommended practice, this could be done for platform-specific reasons, like QP separation of different workloads. Only the server can drive the creation of multiple SMC-R link groups between peers.",
      "ja": "SMC-Rリンクグループ内の平行SMC-Rリンクがサポートされていないことを想起されたいです。これらは、同一のネットワークパスを使用するリンクグループ内の複数のSMC-Rリンクです。しかし、同じピア間に複数のSMC-Rリンクグループは、サポートされています。これは、同じROCE経路上の複数のSMC-Rリンクが望まれる場合、複数のSMC-Rリンクグループを使用する必要があることを意味します。お勧めではないが、これはさまざまなワークロードのQP分離のように、プラットフォーム固有の理由のために行うことができます。サーバだけがピア間で複数のSMC-Rリンクグループの作成を駆動することができます。"
    },
    {
      "indent": 3,
      "text": "At a high level, when the server decides to create an additional SMC-R link group with a client with which it already has an SMC-R link group, the flows are basically the same as the normal \"first contact\" case described above. The following text provides more detail and clarification of processing in this case.",
      "ja": "サーバが既にSMC-Rリンク基を有するとクライアントとの追加のSMC-Rリンクグループを作成することを決定し、高レベルで、フローは、基本的に上述した通常の「最初の接触」の場合と同様です。次のテキストは、この場合の処理​​の詳細及び説明を提供します。"
    },
    {
      "indent": 3,
      "text": "When the server receives the SMC Proposal CLC message from the client and, using the MAC/GID information, determines that it already has an SMC-R link group with this client, the server can either reuse the existing SMC-R link group (detailed in Section 3.5.2 (\"Subsequent Contact\") above) or create a new SMC-R link group in addition to the existing one.",
      "ja": "サーバはクライアントからのSMC提案CLCメッセージを受信し、MAC / GID情報を使用して、それは既にこのクライアントとSMC-Rリンク基を有すると判断した場合、サーバは、詳細（既存のSMC-Rリンク群を再使用しますかセクション3.5.2で（「後発連絡先」）上記）、または既存のに加えて、新たにSMC-Rリンクグループを作成します。"
    },
    {
      "indent": 3,
      "text": "If the server decides to create a new SMC-R link group, it does the same processing it would have done for first contact: allocate QP and RMB resources as well as alternate QP resources, and communicate the QP and RMB information to the client in the SMC Accept CLC message with the first contact flag set.",
      "ja": "QPと人民元のリソースを割り当てるだけでなく、代替QPリソース、およびクライアントにQPと人民元の情報を通信する：サーバーは新しいSMC-Rリンクグループを作成することを決定した場合、それは最初の接触のために行っているのと同じ処理を行いますSMCは、第一の接触フラグが設定されたCLCメッセージを受け入れます。"
    },
    {
      "indent": 3,
      "text": "When the client receives the server's SMC Accept CLC message with the new QP information and the first contact flag set, it knows that the server is creating a new SMC-R link group even though it already has an SMC-R link group with the server. In this case, the client will also allocate a new QP for this new SMC-R link, allocate an RMB for it, and generate an RKey for it.",
      "ja": "クライアントがサーバのSMCは、新しいQP情報と、第一のコンタクトフラグを設定してCLC Acceptメッセージを受信すると、それはすでにサーバとSMC-Rリンクグループを持っているにもかかわらず、サーバが新しいSMC-Rリンクグループを作成していることを知っています。この場合、クライアントはまた、この新しいSMC-Rのリンクのための新しいQPが割り当てられますそれのために人民元を割り当て、そしてそのためのRKEYを生成します。"
    },
    {
      "indent": 3,
      "text": "Note that multiple SMC-R link groups between the same peers must access different RMB resources, so new RMBs will be required. Using the same RMBs that are in use in another SMC-R link group is not permitted.",
      "ja": "ので、新しいRMBSが必要になります、同じピア間で複数のSMC-Rリンクグループが異なる人民元のリソースにアクセスする必要があることに注意してください。別のSMC-Rリンク群に使用されている同じRMBSを使用することは許可されません。"
    },
    {
      "indent": 3,
      "text": "The client then associates its new QP with the server's new QP and sends its SMC Confirm CLC message back to the server providing the new QP/RMB information, and then sets its confirmation timer for the new SMC-R link.",
      "ja": "次に、クライアントは、サーバーの新しいQPとの新しいQPを関連付け、そのSMCが戻って新しいQP /人民元の情報を提供しているサーバへのCLCメッセージを確認して送信し、新しいSMC-Rリンクのその確認のタイマーを設定します。"
    },
    {
      "indent": 3,
      "text": "When the server receives the client's SMC Confirm CLC message, it associates its QP with the client's QP as learned from the SMC Confirm CLC message and sends a confirmation LLC message. The rest of the flow, with the confirmation QP and setup of additional SMC-R links, unfolds just like the \"first contact\" case.",
      "ja": "サーバーがクライアントのSMCは、CLCメッセージを確認して受信すると、SMCから学んだようCLCメッセージを確認し、クライアントのQPとのQPを関連付け、確認LLCメッセージを送信します。追加のSMC-Rリンクの確認QPとセットアップと流れの残りの部分は、単に「最初の接触」の場合のように繰り広げられます。"
    },
    {
      "indent": 0,
      "text": "3.5.4. Normal SMC-R Link Termination",
      "section_title": true,
      "ja": "3.5.4。通常のSMC-Rリンク終了"
    },
    {
      "indent": 3,
      "text": "The normal socket API trigger points are used by the SMC-R layer to initiate SMC-R connection termination flows. The main design point for SMC-R normal connection flows is to use the SMC-R protocol to first shut down the SMC-R connection and free up any SMC-R RDMA resources, and then allow the normal TCP connection termination protocol (i.e., FIN processing) to drive cleanup of the TCP connection that exists on the IP fabric. This design point is very important in ensuring that RDMA resources such as the RMBEs are only freed and reused when both SMC-R endpoints are completely done with their RDMA write operations to the partner's RMBE.",
      "ja": "通常のソケットAPIのトリガーポイントはSMC-R接続終了フローを開始するために、SMC-R層によって使用されます。 SMC-R通常の接続のための主要な設計ポイントが流れる最初のSMC-Rの接続をシャットダウンするSMC-Rプロトコルを使用し、任意のSMC-RのRDMAリソースを解放し、その後、通常のTCP接続終了プロトコル（すなわち、可能にすることですIPファブリック上に存在するTCPコネクションのクリーンアップを駆動するFIN処理）。この設計のポイントは、RMBEsとしてそのRDMAリソースのみを解放し、両方SMC-Rのエンドポイントは、完全に相手のRMBEへのRDMAの書き込み操作で行われたときに再利用されている確保する上で非常に重要です。"
    },
    {
      "indent": 3,
      "text": "When the last TCP connection over an SMC-R link group terminates, the link group can be terminated. Similar to creation of SMC-R links and link groups, the primary responsibility for determining that normal termination is needed and initiating it lies with the server.",
      "ja": "SMC-Rリンクグループの上に最後のTCP接続が終了すると、リンクグループを終了させることができます。 SMC-Rリンク及びリンクグループの作成と同様に、正常終了が必要であると判断すると、それを開始するための主要な責任は、サーバーにあります。"
    },
    {
      "indent": 3,
      "text": "Implementations may opt to set timers to keep SMC-R link groups up for a specified time after the last TCP connection ends, to avoid churn in cases where TCP connections come and go regularly.",
      "ja": "最後のTCP接続が終了した後、実装はTCP接続が来て、定期的に行く場合に解約を回避するために、指定された時間のためのSMC-Rのリンクグループを維持するためにタイマーを設定することを選ぶことができます。"
    },
    {
      "indent": 3,
      "text": "The link or link group may also be terminated as a result of a command initiated by the operator. This command can be entered at either the client or the server. If entered at the client, the client requests that the server perform link or link group termination, and the responsibility for doing so ultimately lies with the server.",
      "ja": "リンクまたはリンクグループは、オペレータによって開始されたコマンドの結果として終了してもよいです。このコマンドは、クライアントまたはサーバのいずれかで入力することができます。クライアントで入力された場合、クライアントはサーバーがリンクまたはリンクグループの終了を実行することを要求し、そうするための責任は最終的には、サーバにあります。"
    },
    {
      "indent": 3,
      "text": "When the server determines that the SMC-R link group is to be terminated, it sends a DELETE LINK LLC message to the client, with a flag set indicating that all links in the link group are to be terminated. After receiving confirmation from the adapter that the DELETE LINK LLC message has been sent, the server can clean up its end of the link group (QPs, RMBs, etc.). Upon receipt of the DELETE LINK message from the server, the client must immediately comply and clean up its end of the link group. Any TCP connections that the client believes to be active on the link group must be immediately terminated.",
      "ja": "サーバがSMC-Rリンクグループを終了すると判断した場合は、リンク・グループ内のすべてのリンクが終了されるべきであることを示すフラグを設定して、クライアントにDELETE LINK LLCメッセージを送信します。 DELETE LINK LLCメッセージが送信されたアダプタからの確認を受け取った後、サーバは、リンク・グループの終わり（のQP、RMBSなど）をクリーンアップすることができます。サーバーからDELETE LINKメッセージを受信すると、クライアントはすぐに準拠しており、リンク群の終わりをクリーンアップする必要があります。クライアントがリンクグループにアクティブになるようにと考えている任意のTCP接続がすぐに終了する必要があります。"
    },
    {
      "indent": 3,
      "text": "The client can request that the server delete the link group as well. The client does this by sending a DELETE LINK message to the server, indicating that cleanup of all links is requested. The server must comply by sending a DELETE LINK to the client and processing as described in the previous paragraph. If there are TCP connections active on the link group when the server receives this request, they are immediately terminated by sending a RST flow over the IP fabric.",
      "ja": "クライアントは、サーバーが同様にリンクグループを削除することを要求することができます。クライアントは、すべてのリンクのクリーンアップが要求されていることを示す、サーバーにDELETE LINKメッセージを送信することでこれを行います。サーバは、前の段落で説明したように、クライアントと処理にDELETE LINKを送信することにより、遵守しなければなりません。サーバはこの要求を受けたリンクグループのアクティブなTCP接続がある場合、それらはすぐにIPファブリックを介しRSTの流れを送信することで終了します。"
    },
    {
      "indent": 0,
      "text": "3.5.5. Link Group Management Flows",
      "section_title": true,
      "ja": "3.5.5。リンクグループの管理フロー"
    },
    {
      "indent": 0,
      "text": "3.5.5.1. Adding and Deleting Links in an SMC-R Link Group",
      "section_title": true,
      "ja": "3.5.5.1。 SMC-Rリンクグループ内のリンクの追加と削除"
    },
    {
      "indent": 3,
      "text": "The server has the lead role in managing the composition of the link group. Links are added to the link group by the server. The client may notify the server of new conditions that may result in the server adding a new link, but the server is ultimately responsible. In general, links are deleted from the link group by the server; however, in certain error cases the client may inform the server that a link must be deleted and treat it as deleted without waiting for action from the server. These flows are detailed in the sections that follow.",
      "ja": "サーバーは、リンクグループの構成を管理する上で先導的な役割を持っています。リンクは、サーバによってリンクグループに追加されます。クライアントは、新しいリンクを追加し、サーバーをもたらすことができる新しい条件のサーバに通知してもよいが、サーバーは最終的に責任があります。一般に、リンクは、サーバによってリンクグループから削除されます。しかし、特定のエラーの場合、クライアントはサーバーからのアクションを待つことなく、リンクを削除しなければならないサーバに通知し、削除したとして、それを扱うことがあります。これらのフローは、以下のセクションで詳述されています。"
    },
    {
      "indent": 0,
      "text": "3.5.5.1.1. Server-Initiated ADD LINK Processing",
      "section_title": true,
      "ja": "3.5.5.1.1。サーバ起動ADDのリンク処理"
    },
    {
      "indent": 3,
      "text": "As described in previous sections, the server initiates an ADD LINK exchange to create redundancy in a newly created link group. Once a link group is established, the server may also initiate ADD LINK for other reasons, including:",
      "ja": "前のセクションで説明したように、サーバは、新しく作成されたリンクグループの冗長性を作成するためのADD LINK交換を開始します。リンクグループが確立されると、サーバはまたなど、他の理由のためにリンクを追加開始することができます。"
    },
    {
      "indent": 3,
      "text": "o Availability of additional resources on the server host to support an additional SMC-R link. This may include the provisioning of an additional RNIC, more storage becoming available to support additional QP resources, operator command, or any other implementation-dependent reason. Note that in order to be available for an existing link group a new RNIC must be attached to the same RoCE LAN that the link group is using.",
      "ja": "追加のSMC-Rのリンクをサポートするサーバホスト上の追加リソースのOの可用性。これは、より多くのストレージが追加QPリソース、オペレータコマンド、または任意の他の実装依存の理由をサポートするために利用可能になって、追加のRNICのプロビジョニングを含むことができます。ために新しいRNICは、リンクグループが使用している同じROCE LANに接続する必要があり、既存のリンクグループのために利用できるようにすることに注意してください。"
    },
    {
      "indent": 3,
      "text": "o Receipt of notification from the client that additional resources on the client are available to support an additional SMC-R link. See Section 3.5.5.1.2 (\"Client-Initiated ADD LINK Processing\").",
      "ja": "クライアント上の追加リソースが追加SMC-Rのリンクをサポートするために利用されているクライアントからの通知のOの領収書。セクション3.5.5.1.2（「クライアント起動のADDのリンク処理」）を参照してください。"
    },
    {
      "indent": 3,
      "text": "Server-initiated ADD LINK processing in an established SMC-R link group is the same as the ADD LINK processing described in Section 3.5.1.6 (\"Second SMC-R Link Setup\"), with the following changes:",
      "ja": "設立SMC-Rのリンクグループでのサーバ起動ADDのリンク処理は次のように変更して、セクション3.5.1.6で説明ADDリンク処理（「第二SMC-Rリンク設定」）と同じです。"
    },
    {
      "indent": 3,
      "text": "o If an asymmetric SMC-R link already exists in the link group, a second asymmetric link will not be created. Only one asymmetric link is permitted in a link group.",
      "ja": "非対称SMC-Rリンクが既にリンク・グループ内に存在する場合、O、第2の非対称リンクが作成されません。一つだけ、非対称リンクは、リンクグループに許可されています。"
    },
    {
      "indent": 3,
      "text": "o TCP data flow on already-existing link(s) in the link group is not halted or otherwise affected during the process of setting up the additional link.",
      "ja": "O TCPデータを停止または他の追加のリンクを設定するプロセスの間に影響されないリンクグループ内の既存のリンク（複数可）に流れます。"
    },
    {
      "indent": 3,
      "text": "The server will not initiate ADD LINK processing if the link group already has the maximum number of links negotiated by the partners.",
      "ja": "リンクグループは、すでにパートナーが交渉されたリンクの最大数を持っている場合、サーバーは、ADD LINK処理を開始しません。"
    },
    {
      "indent": 0,
      "text": "3.5.5.1.2. Client-Initiated ADD LINK Processing",
      "section_title": true,
      "ja": "3.5.5.1.2。クライアントが開始ADDのリンク処理"
    },
    {
      "indent": 3,
      "text": "If an additional RNIC becomes available for an existing SMC-R link group on the client's side, the client notifies the server by sending an ADD LINK request LLC message to the server. Unlike an ADD LINK request sent by the server to the client, this ADD LINK request merely informs the server that the client has a new RNIC. If the link group lacks redundancy or has redundancy only on an asymmetric link with a single RNIC on the client side, the server must initiate an ADD LINK exchange in response to this message, to create or improve the link group's redundancy.",
      "ja": "追加のRNICは、クライアント側の既存のSMC-Rリンクグループのために利用可能になった場合、クライアントはサーバーにADDのLINK要求LLCメッセージを送信することにより、サーバーに通知します。サーバからクライアントに送られたADDのLINK要求とは異なり、このADDのLINK要求は単にクライアントが新しいRNICを持つサーバーに通知します。リンクグループは、冗長性を欠いたりのみ、クライアント側での単一のRNICとの非対称リンクで冗長性を持っている場合、サーバーは、リンク・グループの冗長性を作成するか、または改善するために、このメッセージに応答してADDのLINK交換を開始しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the link group already has symmetric-link redundancy but has fewer than the negotiated maximum number of links, the server may respond by initiating an ADD LINK exchange to create a new link using the client's new resource but is not required to do so.",
      "ja": "リンクグループがすでに対称リンクの冗長性を持っていますが、リンクの交渉された最大数よりも少ない数を持っている場合、サーバーはクライアントの新しいリソースを使用して新しいリンクを作成するためのADD LINK交換を開始することによって応答することができるが、そうする必要はありません。"
    },
    {
      "indent": 3,
      "text": "If the link group already has the negotiated maximum number of links, the server must ignore the client's ADD LINK request LLC message.",
      "ja": "リンクグループは、すでにリンクの交渉された最大数を持っている場合、サーバーはクライアントのADD LINK要求LLCのメッセージを無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Because the server is not required to respond to the client's ADD LINK LLC message in all cases, the client must not wait for a response or throw an error if one does not come.",
      "ja": "サーバはすべてのケースで、クライアントのADDリンクLLCメッセージに応答するために必要とされていないため、クライアントは応答を待つてはいけないまたは1つが来ない場合は、エラーがスローされます。"
    },
    {
      "indent": 0,
      "text": "3.5.5.1.3. Server-Initiated DELETE LINK Processing",
      "section_title": true,
      "ja": "3.5.5.1.3。サーバ起動DELETE LINK処理"
    },
    {
      "indent": 3,
      "text": "Reasons that a server may delete a link include the following:",
      "ja": "サーバは、リンクを削除しても良い理由には次のものがあります。"
    },
    {
      "indent": 3,
      "text": "o The link has not been used for TCP connections for an implementation-defined time interval, and deleting the link will not cause the link group to lack redundancy.",
      "ja": "Oリンクは、実装定義の時間間隔のためのTCP接続に使用されていない、とのリンクを削除すると、リンクグループは、冗長性に欠けることはありません。"
    },
    {
      "indent": 3,
      "text": "o Errors in resources supporting the link occur. These errors may include, but are not limited to, RNIC errors, QP errors, and software errors.",
      "ja": "Oリンクをサポートするリソースでエラーが発生します。これらのエラーが含まれるが、RNICエラー、QPエラー、およびソフトウェア・エラーが、これらに限定されません。"
    },
    {
      "indent": 3,
      "text": "o The RNIC supporting this SMC-R link is being taken down, either because of an error case or because of an operator or software command.",
      "ja": "OこのSMC-RのリンクをサポートするRNICは、エラーが発生したため、ケースのため、またはオペレータまたはソフトウェアのコマンドのいずれか、ダウン取られています。"
    },
    {
      "indent": 3,
      "text": "If a link being deleted is supporting TCP connections and there are one or more surviving links in the link group, the TCP connections are moved to the surviving links. For more information on this processing, see Section 2.3 (\"SMC-R Resilience and Load Balancing\").",
      "ja": "削除されたリンクは、TCP接続をサポートしている1つ以上の生き残ったリンクがリンクグループである場合、TCP接続は存続のリンクに移動します。この処理の詳細については、セクション2.3を参照してください（「SMC-Rレジリエンスおよびロード・バランシング」）。"
    },
    {
      "indent": 3,
      "text": "The server deletes a link from the link group by sending a DELETE LINK request LLC message to the client over any of the usable links in the link group. Because the DELETE LINK LLC message specifies which link is to be deleted, it may flow over any link in the link group. The server must not clean up its RoCE resources for the link until the client responds.",
      "ja": "サーバーは、リンクグループで使用可能なリンクのいずれかを介してクライアントへのDELETE LINK要求LLCメッセージを送信することにより、リンクグループからのリンクを削除します。 DELETE LINK LLCメッセージを削除しようとするリンクを指定するため、リンクグループ内の任意のリンクの上に流すことができます。クライアントが応答するまで、サーバーは、リンクのためにそのROCEのリソースをクリーンアップしてはなりません。"
    },
    {
      "indent": 3,
      "text": "The client responds to the server's DELETE LINK request LLC message by sending the server a DELETE LINK response LLC message. The client must respond positively; it cannot decline to delete the link. Once the server has received the client's DELETE LINK response, both sides may clean up their resources for the link.",
      "ja": "クライアントは、サーバDELETE LINK応答LLCメッセージを送信することにより、サーバのDELETE LINK要求LLCメッセージに応答します。クライアントは、積極的に対応しなければなりません。それは、リンクを削除するために辞退することはできません。サーバーがクライアントのDELETE LINK応答を受信した後は、両側には、リンクのための彼らのリソースをクリーンアップすることがあります。"
    },
    {
      "indent": 3,
      "text": "Either a positive write completion or some other indication from the RNIC on the client's side is sufficient to indicate to the client that the server has received the DELETE LINK response.",
      "ja": "正の書き込み完了またはクライアント側のRNICからいくつかの他の徴候のいずれかが、サーバーがDELETE LINK応答を受信したことをクライアントに指示するのに十分です。"
    },
    {
      "indent": 4,
      "text": "     Host X                                     Host Y\n+-------------------+                      +-------------------+\n|            +------+                      +------+            |\n|       QP 8 |RNIC 1|     SMC-R Link 1     |RNIC 2| QP 9       |\n|RToken X|   |Failed|<--X----X----X----X-->|      |            |\n|        |   |      |                      |      |            |\n|       \\/   +------+                      +------+            |\n|+--------+         |                      |                   |\n|| Deleted|         |                      |                   |\n|| RMB    |         |                      |                   |\n||        |         |                      |                   |\n|+--------+         |                      |                   |\n|       /\\   +------+                      +------+            |\n|RToken Z|   |      |     SMC-R Link 2     |      |            |\n|        |   |RNIC 3|<-------------------->|RNIC 4|            |\n|       QP 64|      |                      |      | QP 65      |\n|            +------+                      +------+            |\n+-------------------+                      +-------------------+",
      "raw": true
    },
    {
      "indent": 10,
      "text": "DELETE LINK(request, link number = 1,\n      ................................................>\n             reason code = RNIC failure)",
      "raw": true
    },
    {
      "indent": 10,
      "text": "DELETE LINK(response, link number = 1)\n     <................................................",
      "raw": true
    },
    {
      "indent": 11,
      "text": "(Note: Architecturally, this exchange can flow over either SMC-R link but most likely flows over Link 2, since the RNIC for Link 1 has failed.)",
      "ja": "（注：アーキテクチャ的に、この交換は、いずれかのSMC-Rリンクを介して流れることができるが、リンク1に対するRNICが失敗したので、ほとんどの場合、リンク2上を流れます。）"
    },
    {
      "indent": 15,
      "text": "Figure 10: Server-Initiated DELETE LINK Flow",
      "ja": "図10：サーバ起動DELETE LINKフロー"
    },
    {
      "indent": 0,
      "text": "3.5.5.1.4. Client-Initiated DELETE LINK Request",
      "section_title": true,
      "ja": "3.5.5.1.4。クライアントが開始したDELETE LINK要求"
    },
    {
      "indent": 3,
      "text": "The client may request that the server delete a link for the same reasons that the server may delete a link, except for inactivity timeout.",
      "ja": "クライアントは、サーバは、サーバが非アクティブタイムアウトを除き、リンクを削除してもよい。同じ理由でリンクを削除することを要求することができます。"
    },
    {
      "indent": 3,
      "text": "Because the client depends on the server to delete links, there are two types of delete requests from client to server:",
      "ja": "クライアントがリンクを削除するには、サーバーに依存しているため、クライアントからサーバーへの削除要求の2つの種類があります。"
    },
    {
      "indent": 3,
      "text": "o Orderly: The client is requesting that the server delete the link when able. This would result from an operator command to bring down the RNIC or some other nonfatal reason. In this case, the server is required to delete the link but may not do it right away.",
      "ja": "O秩序：クライアントは、いつでき、サーバーがリンクを削除することを要求しています。これは、RNICまたは他のいくつかの致命的ではない理由をダウンさせるためにオペレータコマンドから生じます。この場合、サーバーは、リンクを削除するために必要とされるが、すぐにそれをしないことがあります。"
    },
    {
      "indent": 3,
      "text": "o Disorderly: The server must delete the link right away, because the client has experienced a fatal error with the link.",
      "ja": "O無秩序：サーバは、クライアントがリンクで致命的なエラーを経験しているので、すぐにリンクを削除する必要があります。"
    },
    {
      "indent": 3,
      "text": "In either case, the server responds by initiating a DELETE LINK exchange with the client, as described in the previous section. The difference between the two is whether the server must do so immediately or can delay for an opportunity to gracefully delete the link.",
      "ja": "前のセクションで説明したようにいずれの場合も、サーバは、クライアントとDELETE LINK交換を開始することによって応答します。 2つの違いは、サーバーはすぐにそうしなければならないか、優雅にリンクを削除する機会を遅らせることができるかどうかです。"
    },
    {
      "indent": 5,
      "text": "     Host X                                     Host Y\n+-------------------+                      +-------------------+\n|            +------+                      +------+            |\n|       QP 8 |RNIC 1|     SMC-R Link 1     |RNIC 2| QP 9       |\n|RToken X|   |      |<---X--X--X--X--X--X->|Failed|            |\n|        |   |      |                      |      |            |\n|       \\/   +------+                      +------+            |\n|+--------+         |                      |                   |\n|| Deleted|         |                      |                   |\n|| RMB    |         |                      |                   |\n||        |         |                      |                   |\n|+--------+         |                      |                   |\n|       /\\   +------+                      +------+            |\n|RToken Z|   |      |     SMC-R Link 2     |      |            |\n|        |   |RNIC 3|<-------------------->|RNIC 4|            |\n|       QP 64|      |                      |      | QP 65      |\n|            +------+                      +------+            |\n+-------------------+                      +-------------------+",
      "raw": true
    },
    {
      "indent": 11,
      "text": "DELETE LINK(request, link number = 1, disorderly,\n     <...............................................\n            reason code = RNIC failure)",
      "raw": true
    },
    {
      "indent": 11,
      "text": "DELETE LINK(request, link number = 1,\n      ................................................>\n             reason code = RNIC failure)",
      "raw": true
    },
    {
      "indent": 11,
      "text": "DELETE LINK(response, link number = 1)\n     <................................................",
      "raw": true
    },
    {
      "indent": 11,
      "text": "(Note: Architecturally, this exchange can flow over either SMC-R link but most likely flows over Link 2, since the RNIC for Link 1 has failed.)",
      "ja": "（注：アーキテクチャ的に、この交換は、いずれかのSMC-Rリンクを介して流れることができるが、リンク1に対するRNICが失敗したので、ほとんどの場合、リンク2上を流れます。）"
    },
    {
      "indent": 15,
      "text": "Figure 11: Client-Initiated DELETE LINK Flow",
      "ja": "図11：クライアントが開始したDELETE LINKフロー"
    },
    {
      "indent": 0,
      "text": "3.5.5.2. Managing Multiple RKeys over Multiple SMC-R Links in a Link Group",
      "ja": "3.5.5.2。リンクグループ内の複数のSMC-Rのリンクを介して複数のRKeysを管理します"
    },
    {
      "indent": 3,
      "text": "After the initial contact sequence completes and the number of TCP connections increases, it is possible that the SMC peers could add more RMBs to the link group. Recall that each peer independently manages its RMBs. Also recall that an RMB's RToken is specific to a QP, which means that when there are multiple SMC-R links in a link group, each RMB accessed with the link group requires a separate RToken for each SMC-R link in the group.",
      "ja": "最初の接触のシーケンスが完了すると、TCPコネクションの数が増加した後、SMCのピアがリンクグループに多くのRMBSを追加する可能性があります。各ピアは、独立してそのRMBSを管理していることを思い出してください。また、RMBのRTOKENは、リンクグループ内の複数のSMC-Rリンクがある場合、リンクのグループでアクセス各RMBは、グループ内の各SMC-Rのリンクに対して別々RTOKENを必要とすることを意味するQP、に特異的であることを思い出してください。"
    },
    {
      "indent": 3,
      "text": "Each RMB that is added to a link must be added to all links within the link group. The set of RMBs created for the link is called the \"RToken set\". The RTokens must be exchanged with the peer. As RMBs are added and deleted, the RToken set must remain in sync.",
      "ja": "リンクに追加された各人民元は、リンクグループ内のすべてのリンクに追加する必要があります。リンク用に作成されたRMBSのセットは、「RTOKENセット」と呼ばれています。 RTokensは、ピアと交換しなければなりません。 RMBSを追加および削除されると、RTOKENセットが同期していなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.5.5.2.1. Adding a New RMB to an SMC-R Link Group",
      "section_title": true,
      "ja": "3.5.5.2.1。 SMC-Rリンクグループに新しい人民元の追加"
    },
    {
      "indent": 3,
      "text": "A new RMB can be added to an SMC-R link group on either the client side or the server side. When an additional RMB is added to an existing SMC-R link group, that RMB must be associated with the QPs for each link in the link group. Therefore, when an RMB is added to an SMC-R link group, its RMB RToken for each SMC-R link's QP must be communicated to the peer.",
      "ja": "新しい人民元は、クライアント側またはサーバ側のいずれかにSMC-Rのリンクグループに追加することができます。追加RMBを既存のSMC-Rリンクグループに追加されると、その元は、リンクグループ内の各リンクのためのQPに関連付けされなければなりません。 RMBはSMC-Rリンクグループに追加されたときにそのため、各SMC-RリンクのQPのためにRMB RTOKENピアに通信されなければなりません。"
    },
    {
      "indent": 3,
      "text": "The tokens for a new RMB added to an existing SMC-R link group are communicated using CONFIRM RKEY LLC messages, as shown in Figure 12. The RToken set is specified as pairs: an SMC-R link number, paired with the new RMB's RToken over that SMC-R link. To preserve failover capability, any TCP connection that uses a newly added RMB cannot go active until all RTokens for the RMB have been communicated for all of the links in the link group.",
      "ja": "ペアとして指定されている。図12. RTOKENセットに示されるように、既存のSMC-Rリンクグループに追加された新しい元のトークンは、RKEY LLCメッセージを確認して使用して通信される：SMC-Rリンク番号を、新たなRMBのRTOKENとペアそのSMC-Rリンクを介し。人民元のためのすべてのRTokensは、リンクグループ内のすべてのリンクのために伝達されるまで、フェールオーバー機能を維持するには、新しく追加された人民元を使用する任意のTCP接続がアクティブ行くことはできません。"
    },
    {
      "indent": 5,
      "text": "     Host X                                     Host Y\n+-------------------+                      +-------------------+\n|            +------+                      +------+            |\n|       QP 8 |RNIC 1|     SMC-R Link 1     |RNIC 2| QP 9       |\n|RToken X|   |      |<-------------------->|      |            |\n|        |   |      |                      |      |            |\n|       \\/   +------+                      +------+            |\n|+--------+         |                      |                   |\n|| New    |         |                      |                   |\n|| RMB    |         |                      |                   |\n||        |         |                      |                   |\n|+--------+         |                      |                   |\n|       /\\   +------+                      +------+            |\n|RToken Z|   |      |     SMC-R Link 2     |      |            |\n|        |   |RNIC 3|<-------------------->|RNIC 4|            |\n|       QP 64|      |                      |      | QP 65      |\n|            +------+                      +------+            |\n+-------------------+                      +-------------------+",
      "raw": true
    },
    {
      "indent": 11,
      "text": "CONFIRM RKEY(request, Add,\n      ................................................>\n           RToken set((Link 1,RToken X),(Link 2,RToken Z)))",
      "raw": true
    },
    {
      "indent": 11,
      "text": "CONFIRM RKEY(response, Add,\n     <................................................\n           RToken set((Link 1,RToken X),(Link 2,RToken Z)))",
      "raw": true
    },
    {
      "indent": 12,
      "text": "(Note: This exchange can flow over either SMC-R link.)",
      "ja": "（注：この交換は、いずれかのSMC-Rリンクを介して流れることができます。）"
    },
    {
      "indent": 17,
      "text": "Figure 12: Add RMB to Existing Link Group",
      "ja": "図12：既存のリンクグループに人民元を追加"
    },
    {
      "indent": 3,
      "text": "Implementations may choose to proactively add RMBs to link groups in anticipation of need. For example, an implementation may add a new RMB when a certain usage threshold (e.g., percentage used) for all of its existing RMBs has been exceeded.",
      "ja": "実装は、積極的に必要性を見越してリンクグループにRMBSを追加することもできます。例えば、実装が超えている既存のRMBSのすべてに対して特定の使用量しきい値を（例えば、パーセンテージを使用）新しいRMBを追加することができます。"
    },
    {
      "indent": 3,
      "text": "A new RMB may also be added to an existing link group on an as-needed basis -- for example, when a new TCP connection is added to the link group but there are no available RMB elements. In this case, the CLC exchange is paused while the peer that requires the new RMB adds it. An example of this is illustrated in Figure 13.",
      "ja": "新しいRMBはまた、必要に応じて既存のリンクグループに追加されてもよい - 例えば、新しいTCP接続がリンクグループに追加されるが、ときに利用可能なRMB要素は存在しません。新しい人民元が必要ですピアはそれを追加しながら、この場合は、CLC交換が一時停止されています。この例は、図13に示されています。"
    },
    {
      "indent": 4,
      "text": "   Host X -- Server                            Host Y -- Client\n+-------------------+                      +--------------------+\n| Peer ID = PS1     |                      |   Peer ID = PC1    |\n|            +------+                      +------+             |\n|       QP 8 |RNIC 1|    SMC-R Link 1      |RNIC 2|  QP 64      |\n|RToken X|   |MAC MA|<-------------------->|MAC MB|   |         |\n|        |   |GID GA|                      |GID GB|   |RToken Y2|\n|       \\/   +------+                      +------+  \\/         |\n|+--------+         |                      |        +--------+  |\n||        |         |   Subnet S1          |        | New    |  |\n|| RMB    |         |                      |        | RMB    |  |\n|+--------+         |                      |        +--------+  |\n|       /\\   +------+                      +------+  /\\         |\n|        |   |RNIC 3|    SMC-R Link 2      |RNIC 4|   |RToken W2|\n|        |   |MAC MC|<-------------------->|MAC MD|   |         |\n|       QP 9 |GID GC|                      |GID GD|  QP 65      |\n|            +------+                      +------+             |\n+-------------------+                      +--------------------+",
      "raw": true
    },
    {
      "indent": 8,
      "text": "   SYN / SYN-ACK / ACK TCP three-way handshake with TCP option\n<--------------------------------------------------------->",
      "raw": true
    },
    {
      "indent": 8,
      "text": "            SMC Proposal(PC1,MB,GB,S1)\n<--------------------------------------------------------",
      "raw": true
    },
    {
      "indent": 6,
      "text": "SMC Accept(PS1,not 1st contact,MA,GA,QP8,RToken=X,RMB elem index)\n  --------------------------------------------------------->",
      "raw": true
    },
    {
      "indent": 8,
      "text": "  CONFIRM RKEY(request, Add,\n<........................................................\n          RToken set((Link 1,RToken Y2),(Link 2,RToken W2)))",
      "raw": true
    },
    {
      "indent": 9,
      "text": " CONFIRM RKEY(response, Add,\n........................................................>\n         RToken set((Link 1,RToken Y2),(Link 2,RToken W2)))",
      "raw": true
    },
    {
      "indent": 8,
      "text": "  SMC Confirm(PC1,MB,GB,QP64,RToken=Y2, RMB element index)\n<--------------------------------------------------------",
      "raw": true
    },
    {
      "indent": 18,
      "text": "       Legend:\n------------   TCP/IP and CLC flows\n............   RoCE (LLC) flows",
      "raw": true
    },
    {
      "indent": 10,
      "text": "Figure 13: Client Adds RMB during TCP Connection Setup",
      "ja": "図13：クライアントは、TCP接続のセットアップ中に人民元を追加します。"
    },
    {
      "indent": 0,
      "text": "3.5.5.2.2. Deleting an RMB from an SMC-R Link Group",
      "section_title": true,
      "ja": "3.5.5.2.2。 SMC-Rリンクグループから人民元を削除します"
    },
    {
      "indent": 3,
      "text": "Either peer can delete one or more of its RMBs as long as it is not being used for any TCP connections. Ideally, an SMC-R peer would use a timer to avoid freeing an RMB immediately after the last TCP connection stops using it, to keep the RMB available for later TCP connections and avoid thrashing with addition and deletion of RMBs. Once an SMC-R peer decides to delete an RMB, it sends a DELETE RKEY LLC message to its peer. It can then free the RMB once it receives a response from the peer. Multiple RMBs can be deleted in a DELETE RKEY exchange.",
      "ja": "どちらのピアは、それが任意のTCP接続に使用されていないとして、そのRMBSの一つ以上を削除することができます。理想的には、SMC-Rのピアは、最後のTCP接続は、後にTCP接続のために利用可能な人民元を維持し、RMBSの追加と削除をスラッシングを避けるために、それを使用して停止した直後に、人民元を解放避けるためにタイマーを使用します。 SMC-Rのピアが人民元を削除することを決定したら、それはそのピアにDELETE RKEY LLCメッセージを送信します。それは、ピアからの応答を受信したら、それはその後、人民元を解放することができます。複数のRMBSは、DELETE RKEY交換で削除することができます。"
    },
    {
      "indent": 3,
      "text": "Note that in a DELETE RKEY message, it is not necessary to specify the full RToken for a deleted RMB. The RMB's RKey over one link in the link group is sufficient to specify which RMB is being deleted.",
      "ja": "DELETE RKEYメッセージに、削除された人民元の完全RTOKENを指定する必要はないことに注意してください。リンクグループ内の1つのリンク上での人民元のRKEYは、人民元が削除されている指定するのに十分です。"
    },
    {
      "indent": 5,
      "text": "     Host X                                     Host Y\n+-------------------+                      +-------------------+\n|            +------+                      +------+            |\n|       QP 8 |RNIC 1|     SMC-R Link 1     |RNIC 2| QP 9       |\n|RToken X|   |      |<-------------------->|      |            |\n|        |   |      |                      |      |            |\n|       \\/   +------+                      +------+            |\n|+--------+         |                      |                   |\n|| Deleted|         |                      |                   |\n|| RMB    |         |                      |                   |\n||        |         |                      |                   |\n|+--------+         |                      |                   |\n|       /\\   +------+                      +------+            |\n|RToken Z|   |      |     SMC-R Link 2     |      |            |\n|        |   |RNIC 3|<-------------------->|RNIC 4|            |\n|       QP 9 |      |                      |      |            |\n|            +------+                      +------+            |\n+-------------------+                      +-------------------+",
      "raw": true
    },
    {
      "indent": 11,
      "text": "DELETE RKEY(request, RKey list(RKey X))\n      ................................................>",
      "raw": true
    },
    {
      "indent": 11,
      "text": "DELETE RKEY(response, RKey list(RKey X))\n     <................................................",
      "raw": true
    },
    {
      "indent": 11,
      "text": "(Note: This exchange can flow over either SMC-R link.)",
      "ja": "（注：この交換は、いずれかのSMC-Rリンクを介して流れることができます。）"
    },
    {
      "indent": 16,
      "text": "Figure 14: Delete RMB from SMC-R Link Group",
      "ja": "図14：SMC-Rリンクグループから人民元を削除します"
    },
    {
      "indent": 0,
      "text": "3.5.5.2.3. Adding a New SMC-R Link to a Link Group with Multiple RMBs",
      "section_title": true,
      "ja": "3.5.5.2.3。複数のRMBSとリンクグループに新しいSMC-Rのリンクの追加"
    },
    {
      "indent": 3,
      "text": "When a new SMC-R link is added to an existing link group, there could be multiple RMBs on each side already associated with the link group. There could also be a different number of RMBs on one side than on the other, because each peer manages its RMBs independently. Each of these RMBs will require a new RToken to be used on the new SMC-R link, and those new RTokens must then be communicated to the peer. This requires two-way communication, as the server will have to communicate its RTokens to the client and vice versa.",
      "ja": "新しいSMC-Rリンクが既存のリンクグループに追加されたときに、既にリンクグループに関連付けられたそれぞれの側に複数のRMBSがあるかもしれません。各ピアは、独立してそのRMBSを管理しているためにも、他に比べて片側のRMBSの異なる数があるかもしれません。これらのRMBSのそれぞれには、新しいSMC-Rリンクで使用する新しいRTOKENが必要になりますし、それらの新しいRTokensは、ピアに伝達されなければなりません。サーバは、クライアントとその逆にそのRTokensを通信する必要がありますように、これは、双方向通信が必要です。"
    },
    {
      "indent": 3,
      "text": "RTokens are communicated between peers in pairs. Each RToken pair consists of:",
      "ja": "RTokensペア内のピア間で通信されます。各RTOKENペアの構成は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o The RToken for the RMB, as is already known on an existing SMC-R link in the link group.",
      "ja": "RMBためRTOKEN O、既にリンクグループ内の既存のSMC-Rリンクで知られているように。"
    },
    {
      "indent": 3,
      "text": "o The RToken for the same RMB, to be used on the new SMC-R link.",
      "ja": "同じRMBためRTOKEN O、新しいSMC-Rリンクで使用されます。"
    },
    {
      "indent": 3,
      "text": "These pairs are required to ensure that each peer knows which RTokens across QPs are equivalent.",
      "ja": "これらのペアは、各ピアがQPを横切ってRTokensが等価であるかを知っていることを保証するために必要とされます。"
    },
    {
      "indent": 3,
      "text": "The ADD LINK request and response LLC messages do not have enough space to contain any RToken pairs. ADD LINK CONTINUATION LLC messages are used to communicate these pairs, as shown in Figure 15. The ADD LINK CONTINUATION LLC messages are sent on the same SMC-R link that the ADD LINK LLC messages were sent over, and in both the ADD LINK and ADD LINK CONTINUATION LLC messages the first RToken in each RToken pair will be the RToken for the RMB as known on the SMC-R link over which the LLC message is being sent.",
      "ja": "ADDのLINK要求と応答LLCメッセージは、任意のRTOKENのペアを格納するための十分なスペースがありません。 LINK継続LLCメッセージを追加し、図15.に示すように、これらの対を通信するために使用されるLINK継続LLCメッセージを追加LINK LLCメッセージの追加を介して送信されたのと同じSMC-Rリンク上で送信され、及びADDのLINKの両方にあり、各RTOKEN対のリンク継続LLCメッセージを最初RTOKENを追加するLLCメッセージが送信されている上にSMC-Rリンクで知られているようにRMBためRTOKENあろう。"
    },
    {
      "indent": 4,
      "text": "   Host X -- Server                           Host Y -- Client\n+-------------------+                      +-------------------+\n| Peer ID = PS1     |                      |   Peer ID = PC1   |\n|            +------+                      +------+            |\n|       QP 8 |RNIC 1|    SMC-R Link 1      |RNIC 2|  QP 64     |\n|RKey set|   |MAC MA|<-------------------->|MAC MB|   |RKey set|\n|X,Y,Z   |   |GID GA|                      |GID GB|   |Q,R,S,T |\n|       \\/   +------+                      +------+  \\/        |\n|+--------+         |                      |        +--------+ |\n|| 3 RMBs |         |                      |        | 4 RMBs | |\n|+--------+         |                      |        +--------+ |\n|       /\\   +------+                      +------+  /\\        |\n|RKey set|   |RNIC 3|    SMC-R Link 2      |RNIC 4|  | RKey set|\n|U,V,W   |   |MAC MC|<-------------------->|MAC MD|  | L,M,N,P |\n|       QP 9 |GID GC|    (being added)     |GID GD| QP 65      |\n|            +------+                      +------+            |\n+-------------------+                      +-------------------+",
      "raw": true
    },
    {
      "indent": 12,
      "text": "ADD LINK request (QP9,MC,GC, link number = 2)\n............................................>",
      "raw": true
    },
    {
      "indent": 12,
      "text": "ADD LINK response (QP65,MD,GD, link number = 2)\n<............................................",
      "raw": true
    },
    {
      "indent": 4,
      "text": "ADD LINK CONTINUATION req(RToken pairs=((X,U),(Y,V),(Z,W)))\n         ............................................>",
      "raw": true
    },
    {
      "indent": 4,
      "text": "ADD LINK CONTINUATION rsp(RToken pairs=((Q,L),(R,M),(S,N),(T,P)))\n         <.............................................",
      "raw": true
    },
    {
      "indent": 11,
      "text": "CONFIRM LINK req/rsp exchange on Link 2\n <.............................................>",
      "raw": true
    },
    {
      "indent": 19,
      "text": "       Legend:\n------------   TCP/IP and CLC flows\n............   RoCE (LLC) flows",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Figure 15: Exchanging RKeys when a New Link Is Added to a Link Group",
      "ja": "図15：新規リンクがリンクグループに追加されたときにRKeysの交換"
    },
    {
      "indent": 0,
      "text": "3.5.5.3. Serialization of LLC Exchanges, and Collisions",
      "section_title": true,
      "ja": "3.5.5.3。 LLCの交換、および衝突のシリアライズ"
    },
    {
      "indent": 3,
      "text": "LLC flows can be divided into two main groups for serialization considerations.",
      "ja": "LLC・フローは、直列化を考慮して2つのグループに分けることができます。"
    },
    {
      "indent": 3,
      "text": "The first group is LLC messages that are independent and can flow at any time. These are one-time, unsolicited messages that either do not have a required response or have a simple response that does not interfere with the operations of another group of messages. These messages are as follows:",
      "ja": "最初のグループは独立しており、いつでも流れることができるLLCメッセージです。これらは、いずれかが必要な応答を持っているか、メッセージの他のグループの操作に干渉しない、単純な応答を持っていない1回限り、未承諾メッセージです。次のようにこれらのメッセージは以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "o TEST LINK from either the client or the server: This message requires a TEST LINK response to be returned but does not affect the configuration of the link group or the RKeys.",
      "ja": "クライアントまたはサーバのいずれかからOテストのLINK：このメッセージは、返されるテストリンク応答が必要ですが、リンク群の構成やRKeysには影響を与えません。"
    },
    {
      "indent": 3,
      "text": "o ADD LINK from the client to the server: This message is provided as an \"FYI\" to the server to let it know that the client has an additional RNIC available. The server is not required to act upon or respond to this message.",
      "ja": "Oクライアントからサーバへのリンクを追加：このメッセージは、クライアントが利用できる追加のRNICを持っていることを知っているように、「FYI」サーバーへと提供されます。サーバが作用や、このメッセージに応答する必要はありません。"
    },
    {
      "indent": 3,
      "text": "o DELETE LINK from the client to the server: This message informs the server that either (1) the client has experienced an error or problem that requires a link or link group to be terminated or (2) an operator has commanded that a link or link group be terminated. The server does not respond directly to the message; rather, it initiates a DELETE LINK exchange as a result of receiving it.",
      "ja": "Oクライアントからサーバにリンクを削除：このメッセージは、（1）クライアントを終了するリンクまたはリンクグループを必要とするエラーまたは問題を経験しているか、（2）オペレータがそのリンクを命じたかサーバーに通知し、またはリンクグループが終了します。サーバーは、メッセージに直接応答しません。むしろ、それを受信した結果としてDELETE LINK交換を開始します。"
    },
    {
      "indent": 3,
      "text": "o DELETE LINK from the server to the client, with the \"delete entire link group\" flag set: This message informs the client that the entire link group is being deleted.",
      "ja": "o「は全体のリンクグループを削除」フラグを設定して、サーバからクライアントへのリンクを削除：このメッセージは、リンク全体のグループが削除されていることをクライアントに通知します。"
    },
    {
      "indent": 3,
      "text": "The second group is LLC messages that are part of an exchange of LLC messages that affects link group configuration; this exchange must complete before another exchange of LLC messages that affects link group configuration can be processed. When a peer knows that one of these exchanges is in progress, it must not start another exchange. These exchanges are as follows:",
      "ja": "第2のグループは、リンクグループの設定に影響を与えるLLCメッセージの交換の一部であるLLCメッセージです。この交換は、コンフィギュレーションを処理することができるリンクグループに影響を与えLLCメッセージの別の交換の前に完了しなければなりません。ピアは、これらの交換のいずれかが進行中であることを知っている場合は、別の交換を開始してはいけません。次のようにこれらの交換は、以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "o ADD LINK / ADD LINK response / ADD LINK CONTINUATION / ADD LINK CONTINUATION response / CONFIRM LINK / CONFIRM LINK response: This exchange, by adding a new link, changes the configuration of the link group.",
      "ja": "O LINK継続を追加/ LINK / CONFIRMリンク応答CONFIRM / LINK継続応答を追加/リンク応答を追加/リンクを追加：この交換を、新しいリンクを追加することによって、リンクグループの構成を変更します。"
    },
    {
      "indent": 3,
      "text": "o DELETE LINK / DELETE LINK response initiated by the server, without the \"delete entire link group\" flag set: This exchange, by deleting a link, changes the configuration of the link group.",
      "ja": "O /リンクを削除「リンク全体グループを削除」フラグを設定することなく、サーバによって開始されたリンク応答を削除しますリンクを削除することによって、この交換、リンクグループの構成を変更します。"
    },
    {
      "indent": 3,
      "text": "o CONFIRM RKEY / CONFIRM RKEY response or DELETE RKEY / DELETE RKEY response: This exchange changes the RMB configuration of the link group. RKeys cannot change while links are being added or deleted (while an ADD LINK or DELETE LINK is in progress). However, CONFIRM RKEY and DELETE RKEY are unique in that both the client and server can independently manage (add or remove) their own RMBs. This allows each peer to concurrently change their RKeys and therefore concurrently send CONFIRM RKEY or DELETE RKEY requests. The concurrent CONFIRM RKEY or DELETE RKEY requests can be independently processed and do not represent a collision.",
      "ja": "O RKEY / CONFIRMのRKEY応答を確認するか、またはRKEYをDELETE / RKEY応答を削除します。この交換は、リンクグループの元の構成を変更します。リンクが追加または削除されている間（ADDリンクまたはDELETE LINKが進行している間）RKeysを変更することはできません。しかし、RKEYを確認し、RKEYをDELETEは、クライアントとサーバの両方が独立して管理することができます（追加または削除）、自分のRMBSという点でユニークです。これは、それぞれが同時に彼らのRKeysを変更して、同時にRKEY要求を確認RKEYを送信または削除するピアことができます。同時CONFIRMのRKEYまたはDELETE RKEY要求が独立して処理することができ、衝突を表すものではありません。"
    },
    {
      "indent": 3,
      "text": "Because the server is in control of the configuration of the link group, many timing windows and collisions are avoided, but there are still some that must be handled.",
      "ja": "サーバーは、リンクグループの構成を制御しているので、多くのタイミングウィンドウとの衝突は避け、まだ処理しなければならないものもありますされています。"
    },
    {
      "indent": 0,
      "text": "3.5.5.3.1. Collisions with ADD LINK / CONFIRM LINK Exchange",
      "section_title": true,
      "ja": "3.5.5.3.1。 ADDのLINK / CONFIRMリンクExchangeとの衝突"
    },
    {
      "indent": 3,
      "text": "Colliding LLC message: TEST LINK",
      "ja": "衝突LLCのメッセージ：テストリンク"
    },
    {
      "indent": 6,
      "text": "Action to resolve: Send immediate TEST LINK reply.",
      "ja": "解決するアクション：即時テストリンク応答を送信します。"
    },
    {
      "indent": 3,
      "text": "Colliding LLC message: ADD LINK from client to server",
      "ja": "LLCメッセージを衝突：クライアントからサーバへのリンクを追加"
    },
    {
      "indent": 6,
      "text": "Action to resolve: Server ignores the ADD LINK message. When client receives server's ADD LINK, client will consider that message to be in response to its ADD LINK message and the flow works. Since both client and server know not to start this exchange if an ADD LINK operation is already underway, this can only occur if the client sends this message before receiving the server's ADD LINK and this message crosses with the server's ADD LINK message; therefore, the server's ADD LINK arrives at the client immediately after the client sent this message.",
      "ja": "解決するために処置：サーバーは、ADD LINKメッセージを無視します。クライアントは、サーバーの追加]リンクを受信すると、クライアントはそのADDのLINKメッセージとフロー作品への応答にあるように、そのメッセージを検討します。クライアントとサーバーの両方がADDのLINK操作はすでに進行中である場合は、この交換を開始しないように知っているので、クライアントは、サーバーの追加]リンクを受信する前にこのメッセージを送信し、このメッセージは、サーバーのADDのLINKメッセージと交わる場合、これが唯一の発生する可能性があります。そのため、サーバの追加]リンクは、クライアントがこのメッセージを送信した直後にクライアントに到着します。"
    },
    {
      "indent": 3,
      "text": "Colliding LLC message: DELETE LINK from client to server, specific link specified",
      "ja": "指定された、クライアントからサーバーへのリンクを削除する特定のリンク：LLCメッセージを衝突します"
    },
    {
      "indent": 6,
      "text": "Action to resolve: Server queues the DELETE LINK message and processes it after the ADD LINK exchange completes. If it is an orderly link termination, it can wait until after this exchange continues. If it is disorderly and the link affected is the one that the current exchange is using, the server will discover the outage when a message in this exchange fails.",
      "ja": "サーバーは、DELETE LINKメッセージをキューに入れ、ADDのLINK交換が完了した後、それを処理します。解決するためのアクション。それは整然としたリンク終了であれば、それはこの交換は続けた後まで待つことができます。それは無秩序で、影響を受けたリンクは、現在の為替が使用しているものであればこの交換でメッセージが失敗した場合、サーバが停止を発見するでしょう。"
    },
    {
      "indent": 3,
      "text": "Colliding LLC message: DELETE LINK from client to server, entire link group to be deleted",
      "ja": "LLCメッセージを衝突：クライアントからサーバへのリンクを削除、リンク全体のグループが削除されます"
    },
    {
      "indent": 6,
      "text": "Action to resolve: Immediately clean up the link group.",
      "ja": "すぐにリンクグループをクリーンアップ：解決するためのアクション。"
    },
    {
      "indent": 3,
      "text": "Colliding LLC message: CONFIRM RKEY from client",
      "ja": "クライアントからCONFIRMのRKEY：LLCメッセージを衝突します"
    },
    {
      "indent": 6,
      "text": "Action to resolve: Send a negative CONFIRM RKEY response to the client. Once the current exchange finishes, client will have to recompute its RKey set to include the new link and then start a new CONFIRM RKEY exchange.",
      "ja": "解決するために処置：クライアントへの負CONFIRMのRKEY応答を送信します。現在の交換が終了すると、クライアントは、新しいリンクを含めるし、新しいCONFIRMのRKEY交換を開始するように設定されたRKEYを再計算する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.5.5.3.2. Collisions during DELETE LINK Exchange",
      "section_title": true,
      "ja": "3.5.5.3.2。 DELETE LINK交換中に衝突"
    },
    {
      "indent": 3,
      "text": "Colliding LLC message: TEST LINK from either peer",
      "ja": "ピアのいずれかからテストリンク：LLCメッセージを衝突します"
    },
    {
      "indent": 6,
      "text": "Action to resolve: Send immediate TEST LINK response.",
      "ja": "解決するアクション：即時テストリンク応答を送信します。"
    },
    {
      "indent": 3,
      "text": "Colliding LLC message: ADD LINK from client to server",
      "ja": "LLCメッセージを衝突：クライアントからサーバへのリンクを追加"
    },
    {
      "indent": 6,
      "text": "Action to resolve: Server queues the ADD LINK and processes it after the current exchange completes.",
      "ja": "解決するために処置：サーバーは、ADD LINKをキューに入れ、現在の交換が完了した後、それを処理します。"
    },
    {
      "indent": 3,
      "text": "Colliding LLC message: DELETE LINK from client to server (specific link)",
      "ja": "LLCメッセージを衝突：クライアントからサーバへのリンクを削除する（特定のリンク）"
    },
    {
      "indent": 6,
      "text": "Action to resolve: Server queues the DELETE LINK message and processes it after the current exchange completes. If it is an orderly link termination, it can wait until after this exchange continues. If it is disorderly and the link affected is the one that the current exchange is using, the server will discover the outage when a message in this exchange fails.",
      "ja": "解決するために処置：サーバーは、DELETE LINKメッセージをキューに入れ、現在の交換が完了した後、それを処理します。それは整然としたリンク終了であれば、それはこの交換は続けた後まで待つことができます。それは無秩序で、影響を受けたリンクは、現在の為替が使用しているものであればこの交換でメッセージが失敗した場合、サーバが停止を発見するでしょう。"
    },
    {
      "indent": 3,
      "text": "Colliding LLC message: DELETE LINK from either client or server, deleting the entire link group",
      "ja": "LLCメッセージを衝突：クライアントまたはサーバからのリンクを削除、全体のリンクグループを削除します"
    },
    {
      "indent": 6,
      "text": "Action to resolve: Immediately clean up the link group.",
      "ja": "すぐにリンクグループをクリーンアップ：解決するためのアクション。"
    },
    {
      "indent": 3,
      "text": "Colliding LLC message: CONFIRM RKEY from client to server",
      "ja": "LLCメッセージを衝突：クライアントからサーバにRKEYを確認"
    },
    {
      "indent": 6,
      "text": "Action to resolve: Send a negative CONFIRM RKEY response to the client. Once the current exchange finishes, client will have to recompute its RKey set to include the new link and then start a new CONFIRM RKEY exchange.",
      "ja": "解決するために処置：クライアントへの負CONFIRMのRKEY応答を送信します。現在の交換が終了すると、クライアントは、新しいリンクを含めるし、新しいCONFIRMのRKEY交換を開始するように設定されたRKEYを再計算する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.5.5.3.3. Collisions during CONFIRM RKEY Exchange",
      "section_title": true,
      "ja": "3.5.5.3.3。 CONFIRMのRKEY交換中に衝突"
    },
    {
      "indent": 3,
      "text": "Colliding LLC message: TEST LINK",
      "ja": "衝突LLCのメッセージ：テストリンク"
    },
    {
      "indent": 6,
      "text": "Action to resolve: Send immediate TEST LINK reply.",
      "ja": "解決するアクション：即時テストリンク応答を送信します。"
    },
    {
      "indent": 3,
      "text": "Colliding LLC message: ADD LINK from client to server",
      "ja": "LLCメッセージを衝突：クライアントからサーバへのリンクを追加"
    },
    {
      "indent": 6,
      "text": "Action to resolve: Queue the ADD LINK, and process it after the current exchange completes.",
      "ja": "解決するために処置：ADDのLINKをキュー、および現在の交換が完了した後、それを処理します。"
    },
    {
      "indent": 3,
      "text": "Colliding LLC message: ADD LINK from server to client (CONFIRM RKEY exchange was initiated by the client, and it crossed with the server initiating an ADD LINK exchange)",
      "ja": "LLCメッセージを衝突：サーバーからクライアントへのリンクを追加（CONFIRMのRKEY交換をクライアントによって開始され、そしてそれは、ADD LINK交換を開始するサーバーと交配されました）"
    },
    {
      "indent": 6,
      "text": "Action to resolve: Process the ADD LINK. Client will receive a negative CONFIRM RKEY from the server and will have to redo this CONFIRM RKEY exchange after the ADD LINK exchange completes.",
      "ja": "アクションは解決する：ADDリンクを処理します。クライアントは、サーバからの負CONFIRMのRKEYを受信すると、ADDのLINK交換が完了した後、このCONFIRMのRKEY交換をやり直す必要があります。"
    },
    {
      "indent": 3,
      "text": "Colliding LLC message: DELETE LINK from client to server, specific link to be deleted (CONFIRM RKEY exchange was initiated by the server, and it crossed with the client's DELETE LINK request)",
      "ja": "LLCメッセージを衝突：クライアントからサーバへのリンクを削除する、特定のリンクを削除する（CONFIRMのRKEY交換は、サーバによって開始され、そしてそれは、クライアントのDELETE LINK要求と交配されました）"
    },
    {
      "indent": 6,
      "text": "Action to resolve: Server queues the DELETE LINK message and processes it after the CONFIRM RKEY exchange completes. If it is an orderly link termination, it can wait until after this exchange continues. If it is disorderly and the link affected is the one that the current exchange is using, the server will discover the outage when a message in this exchange fails.",
      "ja": "サーバーは、DELETE LINKメッセージをキューに入れ、CONFIRMのRKEY交換が完了した後、それを処理します。解決するためのアクション。それは整然としたリンク終了であれば、それはこの交換は続けた後まで待つことができます。それは無秩序で、影響を受けたリンクは、現在の為替が使用しているものであればこの交換でメッセージが失敗した場合、サーバが停止を発見するでしょう。"
    },
    {
      "indent": 3,
      "text": "Colliding LLC message: DELETE LINK from server to client, specific link deleted (CONFIRM RKEY exchange was initiated by the client, and it crossed with the server's DELETE LINK)",
      "ja": "衝突LLCメッセージ：特定のリンクを削除、サーバからクライアントへのリンクを削除する（CONFIRMのRKEY交換は、クライアントによって開始され、そしてそれは、サーバーのDELETE LINKと交配させました）"
    },
    {
      "indent": 6,
      "text": "Action to resolve: Process the DELETE LINK. Client will receive a negative CONFIRM RKEY from the server and will have to redo this CONFIRM RKEY exchange after the ADD LINK exchange completes.",
      "ja": "解決するために処置：DELETE LINKを処理します。クライアントは、サーバからの負CONFIRMのRKEYを受信すると、ADDのLINK交換が完了した後、このCONFIRMのRKEY交換をやり直す必要があります。"
    },
    {
      "indent": 3,
      "text": "Colliding LLC message: DELETE LINK from either client or server, entire link group deleted",
      "ja": "LLCメッセージを衝突：クライアントまたはサーバからのリンクを削除、リンク全体グループは削除します"
    },
    {
      "indent": 6,
      "text": "Action to resolve: Immediately clean up the link group.",
      "ja": "すぐにリンクグループをクリーンアップ：解決するためのアクション。"
    },
    {
      "indent": 3,
      "text": "Colliding LLC message: CONFIRM LINK from the peer that did not start the current CONFIRM LINK exchange",
      "ja": "現在CONFIRMのLINK交換を開始しなかったピアからCONFIRMのLINK：LLCメッセージを衝突します"
    },
    {
      "indent": 6,
      "text": "Action to resolve: Queue the request, and process it after the current exchange completes.",
      "ja": "解決する処置：要求をキュー、および現在の交換が完了した後、それを処理します。"
    },
    {
      "indent": 0,
      "text": "4. SMC-R Memory-Sharing Architecture",
      "section_title": true,
      "ja": "4. SMC-Rメモリ共有アーキテクチャ"
    },
    {
      "indent": 0,
      "text": "4.1. RMB Element Allocation Considerations",
      "section_title": true,
      "ja": "4.1。人民元要素割当の考慮事項"
    },
    {
      "indent": 3,
      "text": "Each TCP connection using SMC-R must be allocated an RMBE by each SMC-R peer. This allocation is performed by each endpoint independently to allow each endpoint to select an RMBE that best matches the characteristics on its TCP socket endpoint. The RMBE associated with a TCP socket endpoint must have a receive buffer that is at least as large as the TCP receive buffer size in effect for that connection. The receive buffer size can be determined by what is specified explicitly by the application using setsockopt() or implicitly via the system-configured default value. This will allow sufficient data to be RDMA-written by the SMC-R peer to fill an entire receive buffer size's worth of data on a given data flow. Given that each RMB must have fixed-length RMBEs, this implies that an SMC-R endpoint may need to maintain multiple RMBs of various sizes for SMC-R connections on a given SMC-R link and can then select an RMBE that most closely fits a connection.",
      "ja": "SMC-Rを使用して、各TCP接続は、各SMC-RピアによってRMBEを割り当てられなければなりません。この割り当ては、各エンドポイントは、最高のTCPソケットエンドポイント上の特性と一致するRMBEを選択することができるように、独立して、各エンドポイントによって行われます。 TCPソケットエンドポイントに関連付けられRMBEは、TCPは、その接続のために有効に受信バッファサイズと少なくとも同じ大きさである受信バッファを有していなければなりません。受信バッファのサイズは、システム設定のデフォルト値を介して暗黙的にアプリケーション使用のsetsockoptによって明示的に指定（）またはれるものによって決定することができます。これは、SMC-RによりRDMA-書き込まれるのに十分なデータが所定のデータフローに対するデータの全受信バッファサイズ分を埋めるためにピアを可能にします。各人民元が固定長RMBEsを持たなければならないことを考えると、これはSMC-Rのエンドポイントが与えられたSMC-RリンクでSMC-Rの接続のために様々なサイズの複数のRMBSを維持する必要があり、その後、最も密接に合うRMBEを選択できることを意味します接続。"
    },
    {
      "indent": 0,
      "text": "4.2. RMB and RMBE Format",
      "section_title": true,
      "ja": "4.2。人民元とRMBEフォーマット"
    },
    {
      "indent": 3,
      "text": "An RMB is a virtual memory buffer whose backing real memory is pinned. The RMB is subdivided into a whole number of equal-sized RMB Elements (RMBEs). Each RMBE begins with a 4-byte eye catcher for diagnostic and service purposes, followed by the receive data buffer. The contents of this diagnostic eye catcher are implementation dependent and should be used by the local SMC-R peer to check for overlay errors by verifying an intact eye catcher with every RMBE access.",
      "ja": "人民元は、そのバックアップ実メモリ固定されている仮想メモリバッファです。 RMBは、同じサイズのRMB要素（RMBEs）の整数に細分されます。各RMBEは、受信データバッファに続く診断および保守目的のための4バイト目のキャッチャー、始まります。この診断アイキャッチャーの内容は実装依存であり、ローカルSMC-Rによって使用されるべきすべてのRMBEアクセス無傷の眼キャッチャーを検証することによってオーバーレイエラーをチェックするピア。"
    },
    {
      "indent": 3,
      "text": "The RMBE is a wrapping receive buffer for receiving RDMA writes from the peer. Cursors, as described below, are exchanged between peers to manage and track RDMA writes and local data reads from the RMBE for a TCP connection.",
      "ja": "RMBEは、RDMAを受信するためのバッファをラップ受信されるピアから書き込みます。カーソルは、後述するように、書き込み、ローカルデータは、TCP接続のためにRMBEから読み込むRDMAを管理し、追跡するピア間で交換されています。"
    },
    {
      "indent": 0,
      "text": "4.3. RMBE Control Information",
      "section_title": true,
      "ja": "4.3。 RMBE制御情報"
    },
    {
      "indent": 3,
      "text": "RMBE control information consists of consumer cursors, producer cursors, wrap counts, CDC message sequence numbers, control flags such as urgent data and \"writer blocked\" indicators, and TCP connection information such as termination flags. This information is exchanged between SMC-R peers using CDC messages, which are passed using RoCE SendMsg. A TCP/IP stack implementing SMC-R must receive and store this information in its internal data structures, as it is used to manage the RMBE and its data buffer.",
      "ja": "RMBE制御情報は、緊急データとして、消費者のカーソル、プロデューサーカーソル、ラップ数、CDCメッセージのシーケンス番号、制御フラグで構成指標を「作家がブロックされた」、およびTCP接続情報などの終了フラグなど。この情報は、ROCE SENDMSGを使用して渡されたCDCメッセージを使用してSMC-Rピア間で交換されます。 RMBEとそのデータバッファを管理するために使用されるSMC-Rを実現するTCP / IPスタックは、その内部データ構造にこの情報を受信して​​格納しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The format and contents of the CDC message are described in detail in Appendix A.4 (\"Connection Data Control (CDC) Message Format\"). The following is a high-level description of what this control information contains.",
      "ja": "CDCメッセージのフォーマットおよび内容は付録A.4（「接続データコントロール（CDC）メッセージフォーマット」）に詳細に記載されています。以下では、この制御情報が含まれているものの高レベルの記述です。"
    },
    {
      "indent": 3,
      "text": "o Connection state flags such as sending done, connection closed, failover data validation, and abnormal close.",
      "ja": "そのような行う送信などO接続状態フラグ、接続が閉じられ、フェイルオーバーデータの検証、および異常近いです。"
    },
    {
      "indent": 3,
      "text": "o A sequence number that is managed by the sender. This sequence number starts at 1, is increased each send, and wraps to 0. This sequence number tracks the CDC message sent and is not related to the number of bytes sent. It is used for failover data validation.",
      "ja": "送信者によって管理されているシーケンス番号O。このシーケンス番号は1から始まり、このシーケンス番号は送信されたCDCメッセージを追跡し、送信されたバイトの数には関係しない、それぞれが送信増加し、0にラップされています。これは、フェイルオーバーデータの検証に使用されます。"
    },
    {
      "indent": 3,
      "text": "o Producer cursor: a wrapping offset into the receiver's RMBE data area. Set by the peer that is writing into the RMBE, it points to where the writing peer will write the next byte of data into an RMBE. This cursor is accompanied by a wrap sequence number to help the RMBE owner (the receiver) identify full window size wrapping writes. Note that this cursor must account for (i.e., skip over) the RMBE eye catcher that is in the beginning of the data area.",
      "ja": "Oプロデューサーカーソル：受信機のRMBEデータ領域へのオフセットをラッピング。 RMBEに書いているピアによって設定し、それが書き込みピアがRMBEへのデータの次のバイトを書き込む場所を指します。このカーソルはRMBEの所有者（受信機）がフルウィンドウサイズのラッピング書き込みを識別しやすくするためにラップ・シーケンス番号を伴っています。このカーソルは、データ領域の先頭にある（すなわち、スキップ）RMBEアイキャッチャーを考慮しなければならないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "o Consumer cursor: a wrapping offset into the receiver's RMBE data area. Set by the owner of the RMBE (the peer that is reading from it), this cursor points to the offset of the next byte of data to be consumed by the peer in its own RMBE. The sender cannot write beyond this cursor into the receiver's RMBE without causing data loss. Like the producer cursor, this is accompanied by a wrap count to help the writer identify full window size wrapping reads. Note that this cursor must account for (i.e., skip over) the RMBE eye catcher that is in the beginning of the data area.",
      "ja": "O消費者のカーソル：受信機のRMBEデータ領域へのオフセットをラッピング。 RMBE（そこから読み取っているピア）の所有者によって設定され、データの次のバイトのオフセットにこのカーソルポイントは、それ自身のRMBEにおけるピアによって消費されます。送信者は、データの損失を発生させることなく、受信機のRMBEにこのカーソルを超えて書き込むことはできません。プロデューサーのカーソルと同じように、これは作家がラッピングを読み込むフルウィンドウサイズを識別しやすくするためにラップ数を伴っています。このカーソルは、データ領域の先頭にある（すなわち、スキップ）RMBEアイキャッチャーを考慮しなければならないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "o Data flags such as urgent data, writer blocked indicator, and cursor update requests.",
      "ja": "こうした緊急データ、作家ブロックされたインジケータ、およびカーソルの更新要求としてOデータフラグ。"
    },
    {
      "indent": 0,
      "text": "4.4. Use of RMBEs",
      "section_title": true,
      "ja": "4.4。 RMBEsの使用"
    },
    {
      "indent": 0,
      "text": "4.4.1. Initializing and Accessing RMBEs",
      "section_title": true,
      "ja": "4.4.1。初期化とアクセスRMBEs"
    },
    {
      "indent": 3,
      "text": "The RMBE eye catcher is initialized by the RMB owner prior to assigning it to a specific TCP connection and communicating its RMB index to the SMC-R partner. After an RMBE index is communicated to the SMC-R partner, the RMBE can only be referenced in \"read-only mode\" by the owner, and all updates to it are performed by the remote SMC-R partner via RDMA write operations.",
      "ja": "RMBEアイキャッチャは、特定のTCP接続に割り当てるとSMC-Rパートナーにその元のインデックスを通信する前に、元の所有者によって初期化されます。 RMBEインデックスがSMC-Rパートナーに伝達された後、RMBEのみ所有者によって「読み取り専用モード」で参照することができ、それに対するすべての更新は、RDMA書き込み操作を介して遠隔SMC-Rパートナーによって実行されます。"
    },
    {
      "indent": 3,
      "text": "Initialization of an RMBE must include the following:",
      "ja": "RMBEの初期化は、以下を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "o Zeroing out the entire RMBE receive buffer, which helps minimize data integrity issues (e.g., data from a previous connection somehow being presented to the current connection).",
      "ja": "Oデータの整合性の問題を最小限に抑えることができますバッファ、受信全体RMBEをゼロ（例えば、以前の接続からのデータは何らかの方法で、現在の接続に提示されます）。"
    },
    {
      "indent": 3,
      "text": "o Setting the beginning RMBE eye catcher. This eye catcher plays an important role in helping detect accidental overlays of the RMBE. The RMB owner should always validate these eye catchers before each new reference to the RMBE. If the eye catchers are found to be corrupted, the local host must reset the TCP connection associated with this RMBE and log the appropriate diagnostic information.",
      "ja": "初めRMBEアイキャッチャーを設定し、O。このアイキャッチャーはRMBEの偶発オーバーレイを検出するうえで重要な役割を果たしています。元の所有者は、常にRMBEへの各新しい参照の前にこれらのアイキャッチャーを検証する必要があります。アイキャッチャーが破損することがわかっている場合は、ローカルホストは、このRMBEに関連付けられているTCP接続をリセットし、適切な診断情報をログに記録しなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.4.2. RMB Element Reuse and Conflict Resolution",
      "section_title": true,
      "ja": "4.4.2。人民元要素の再利用および紛争解決"
    },
    {
      "indent": 3,
      "text": "RMB elements can be reused once their associated TCP and SMC-R connections are terminated. Under normal and abnormal SMC-R connection termination processing, both SMC-R peers must explicitly acknowledge that they are done using an RMBE before that element can be freed and reassigned to another SMC-R connection instance. For more details on SMC-R connection termination, refer to Section 4.8.",
      "ja": "それらに関連するTCPおよびSMC-Rの接続が終了されると人民元の要素を再利用することができます。正常および異常なSMC-R接続終了処理の下で、両方のSMC-Rピアは、明示的にその要素が解放され、別のSMC-Rの接続インスタンスに再割り当てすることができる前に、彼らはRMBEを使用して行われることを認識しなければなりません。 SMC-Rの接続終了の詳細については、セクション4.8を参照してください。"
    },
    {
      "indent": 3,
      "text": "However, there are some error scenarios where this two-way explicit acknowledgment may not be completed. In these scenarios, an RMBE owner may choose to reassign this RMBE to a new SMC-R connection instance on this SMC-R link group. When this occurs, the partner SMC-R peer must detect this condition during SMC-R Rendezvous processing when presented with an RMBE that it believes is already in use for a different SMC-R connection. In this case, the SMC-R peer must abort the existing SMC-R connection associated with this RMBE. The abort processing resets the TCP connection (if it is still active), but it must not attempt to perform any RDMA writes to this RMBE and must also ignore any data sitting in the local RMBE associated with the existing connection. It then proceeds to free up the local RMBE and notify the local application that the connection is being abnormally reset.",
      "ja": "しかし、この双方向の明示的な承認が完了しないことがいくつかのエラーシナリオがあります。これらのシナリオでは、RMBEの所有者は、このSMC-Rのリンクグループに新しいSMC-Rの接続インスタンスにこのRMBEを再割り当てすることもできます。これが発生すると、それは異なるSMC-R接続のため既に使用されていると考えていることRMBEを提示するとき、パートナーSMC-RピアはSMC-Rのランデブー処理中にこの状態を検出しなければなりません。この場合、SMC-Rピアは、このRMBEに関連付けられている既存のSMC-Rの接続を中止しなければなりません。 （それがまだアクティブである場合）、アボート処理は、TCP接続をリセットしますが、それはすべてのRDMAを実行しようとしてはならない。このRMBEに書き込みをしても、既存の接続に関連付けられたローカルRMBEに座って任意のデータを無視しなければなりません。その後、地元のRMBEを解放し、接続が異常にリセットされているローカルアプリケーションに通知するために進みます。"
    },
    {
      "indent": 3,
      "text": "The remote SMC-R peer then proceeds to normal processing for this new SMC-R connection.",
      "ja": "リモートSMC-Rピアは、この新たなSMC-R接続の通常の処理に移行します。"
    },
    {
      "indent": 0,
      "text": "4.5. SMC-R Protocol Considerations",
      "section_title": true,
      "ja": "4.5。 SMC-Rプロトコルの考慮事項"
    },
    {
      "indent": 3,
      "text": "The following sections describe considerations for the SMC-R protocol as compared to TCP.",
      "ja": "以下のセクションでは、TCPと比較してSMC-Rプロトコルのための考慮事項を記載しています。"
    },
    {
      "indent": 0,
      "text": "4.5.1. SMC-R Protocol Optimized Window Size Updates",
      "section_title": true,
      "ja": "4.5.1。 SMC-Rプロトコル最適化されたウィンドウサイズアップデート"
    },
    {
      "indent": 3,
      "text": "An SMC-R receiver host sends its consumer cursor information to the sender to convey the progress that the receiving application has made in consuming the sent data. The difference between the writer's producer cursor and the associated receiver's consumer cursor indicates the window size available for the sender to write into. This is somewhat similar to TCP window update processing and therefore has some similar considerations, such as silly window syndrome avoidance, whereby TCP has an optimization that minimizes the overhead of very small, unproductive window size updates associated with suboptimal socket applications consuming very small amounts of data on every receive() invocation. For SMC-R, the receiver only updates its consumer cursor via a unique CDC message under the following conditions:",
      "ja": "SMC-R受信ホストは、受信アプリケーションが送信されたデータを消費で行った進捗を伝えるために、送信者への消費者のカーソルの情報を送信します。作家のプロデューサーカーソルと関連する受信機の消費者のカーソルとの違いは、送信者に書き込むために利用可能なウィンドウサイズを示します。これは、TCPウィンドウの更新処理に多少類似しており、したがって、TCPは、非常に少量の消費次善ソケット・アプリケーションに関連付けられた非常に小さな、非生産的なウィンドウサイズの更新のオーバーヘッドを最小化する最適化を有していることにより、このような愚かなウィンドウ症候群回避のようないくつかの同様の考察を、有しますすべての上のデータは、（）の呼び出しを受けます。 SMC-Rのために、受信機は、以下の条件で一意CDCメッセージを介して、その消費者のカーソルを更新します。"
    },
    {
      "indent": 3,
      "text": "o The current window size (from a sender's perspective) is less than half of the receive buffer space, and the consumer cursor update will result in a minimum increase in the window size of 10% of the receive buffer space. Some examples:",
      "ja": "O（送信者の観点から）現在のウィンドウサイズが受信バッファスペースの半分以下であり、消費者のカーソルの更新は、受信バッファスペースの10％のウィンドウサイズの最小の増加をもたらすであろう。いくつかの例："
    },
    {
      "indent": 6,
      "text": "a. Receive buffer size: 64K, current window size (from a sender's perspective): 50K. No need to update the consumer cursor. Plenty of space is available for the sender.",
      "ja": "A。 64K、現在のウィンドウサイズ（送信者の視点から）：50Kバッファサイズを受け取ります。消費者のカーソルを更新する必要はありません。十分なスペースは、送信者のために利用可能です。"
    },
    {
      "indent": 6,
      "text": "b. Receive buffer size: 64K, current window size (from a sender's perspective): 30K, current window size from a receiver's perspective: 31K. No need to update the consumer cursor; even though the sender's window size is < 1/2 of the 64K, the window update would only increase that by 1K, which is < 1/10th of the 64K buffer size.",
      "ja": "B。 64K、現在のウィンドウサイズ（送信者の視点から）：30K、受信側の視点から現在のウィンドウサイズ：31Kバッファサイズを受け取ります。消費者のカーソルを更新する必要はありません。送信側のウィンドウサイズが<64Kの1/2であっても、ウィンドウの更新は、<1/10 64Kのバッファサイズであり、1Kによってそれを増加させるであろう。"
    },
    {
      "indent": 6,
      "text": "c. Receive buffer size: 64K, current window size (from a sender's perspective): 30K, current window size from a receiver's perspective: 64K. The receiver updates the consumer cursor (sender's window size is < 1/2 of the 64K; the window update would increase that by > 6.4K).",
      "ja": "C。 64K、現在のウィンドウサイズ（送信者の視点から）：30K、受信側の視点から現在のウィンドウサイズ：64Kバッファサイズを受け取ります。受信機は、消費者のカーソル（; 6.4K送信者のウィンドウサイズが<ウィンドウの更新はによってそれを増加させるであろう64Kの1/2>である）を更新します。"
    },
    {
      "indent": 3,
      "text": "o The receiver must always include a consumer cursor update whenever it sends a CDC message to the partner for another flow (i.e., send flow in the opposite direction). This allows the window size update to be delivered with no additional overhead. This is somewhat similar to TCP DelayAck processing and quite effective for request/response data patterns.",
      "ja": "受信機oを常に（すなわち、反対方向の流れを送る）は、別の流れのためのパートナーにCDCメッセージを送信するたびに、消費者のカーソルの更新を含んでいなければなりません。これは、ウィンドウサイズの更新はなし追加のオーバーヘッドで配信することができます。これは、TCP DelayAck処理に幾分類似しており、リクエスト/レスポンス・データ・パターンのための非常に有効です。"
    },
    {
      "indent": 3,
      "text": "o If a peer has set the B-bit in a CDC message, then any consumption of data by the receiver causes a CDC message to be sent, updating the consumer cursor until a CDC message with that bit cleared is received from the peer.",
      "ja": "ピアは、CDCメッセージにBビットを設定した場合、O、受信機によるデータの任意の消費がクリアされているビットを有するCDCメッセージがピアから受信されるまで、消費者のカーソルを更新し、CDCメッセージが送信されるようにします。"
    },
    {
      "indent": 3,
      "text": "o The optimized window size updates are overridden when the sender sets the Consumer Cursor Update Requested flag in a CDC message to the receiver. When this indicator is on, the consumer must send a consumer cursor update immediately when data is consumed by the local application or if the cursor has not been updated for a while (i.e., local copy of the consumer cursor does not match the last consumer cursor value sent to the partner). This allows the sender to perform optional diagnostics for detecting a stalled receiver application (data has been sent but not consumed). It is recommended that the Consumer Cursor Update Requested flag only be sent for diagnostic procedures, as it may result in non-optimal data path performance.",
      "ja": "送信者が消費者カーソル更新が受信機にCDCメッセージにフラグを要求し設定するとoを最適化されたウィンドウサイズの更新が上書きされます。このインジケーターがオンになっている場合、データがローカルアプリケーションによって消費されたか、カーソルがしばらく更新されていない場合（すなわち、消費者のカーソルのローカルコピーが最後の消費者のカーソルと一致しない場合、消費者はすぐに消費者のカーソルの更新を送信する必要がありますパートナーに送信された値）。これは、（データが送信されるが、消費されないされている）送信者がストール受信機アプリケーションを検出するためのオプションの診断を実行することを可能にします。非最適なデータ経路性能をもたらすことができるように消費者カーソル更新要求フラグのみ、診断手順のために送信することが推奨されます。"
    },
    {
      "indent": 0,
      "text": "4.5.2. Small Data Sends",
      "section_title": true,
      "ja": "4.5.2。小さなデータを送信します。"
    },
    {
      "indent": 3,
      "text": "The SMC-R protocol makes no special provisions for handling small data segments sent across a stream socket. Data is always sent if sufficient window space is available. In contrast to the TCP Nagle algorithm, there are no special provisions in SMC-R for coalescing small data segments.",
      "ja": "SMC-Rプロトコルは、ストリームソケットを介して送信される小さなデータセグメントを処理するための特別な規定を行いません。十分なウインドウスペースが利用可能な場合、データは常に送信されます。 TCP Nagleアルゴリズムとは対照的に、小さなデータセグメントを合体するためのSMC-Rに特別な規定は存在しません。"
    },
    {
      "indent": 3,
      "text": "An implementation of SMC-R can be configured to optimize its sending processing by coalescing outbound data for a given SMC-R connection so that it can reduce the number of RDMA write operations it performs, in a fashion similar to Nagle's algorithm. However, any such coalescing would require a timer on the sending host that would ensure that data was eventually sent. Also, the sending host would have to opt out of this processing if Nagle's algorithm had been disabled (programmatically or via system configuration).",
      "ja": "SMC-Rの実装は、Nagleアルゴリズムと同様の方法で、それが実行するRDMA書き込み操作の数を減らすことができるように、所定のSMC-Rの接続のための送信データを合体することによって、その送信処理を最適化するように構成することができます。しかし、そのような合体は、データが最終的に送られたことを確実にする送信側ホストのタイマーを必要とします。また、送信側ホストは、Nagleアルゴリズムは、（プログラムまたはシステム構成を経由して）無効にされていた場合には、この処理をオプトアウトする必要があります。"
    },
    {
      "indent": 0,
      "text": "4.5.3. TCP Keepalive Processing",
      "section_title": true,
      "ja": "4.5.3。 TCPキープアライブ処理"
    },
    {
      "indent": 3,
      "text": "TCP keepalive processing allows applications to direct the local TCP/IP host to periodically \"test\" the viability of an idle TCP connection. Since SMC-R connections have a TCP representation along with an SMC-R representation, there are unique keepalive processing considerations:",
      "ja": "TCPキープアライブ処理は、アプリケーションがローカルのTCP / IPホストに定期的に「テスト」アイドル状態のTCPコネクションの生存可能性を指示することができます。 SMC-Rの接続はSMC-Rの表現と一緒にTCP表現を持っているので、独自のキープアライブ処理の考慮事項があります。"
    },
    {
      "indent": 3,
      "text": "o SMC-R-layer keepalive processing: If keepalive is enabled for an SMC-R connection, the local host maintains a keepalive timer that reflects how long an SMC-R connection has been idle. The local host also maintains a timestamp of last activity for each SMC-R link (for any SMC-R connection on that link). When it is determined that an SMC-R connection has been idle longer than the keepalive interval, the host checks to see whether or not the SMC-R link has been idle for a duration longer than the keepalive timeout. If both conditions are met, the local host then performs a TEST LINK LLC command to test the viability of the SMC-R link over the RoCE fabric (RC-QPs). If a TEST LINK LLC command response is received within a reasonable amount of time, then the link is considered viable, and all connections using this link are considered viable as well. If, however, a response is not received in a reasonable amount of time or there's a failure in sending the TEST LINK LLC command, then this is considered a failure in the SMC-R link, and failover processing to an alternate SMC-R link must be triggered. If no alternate SMC-R link exists in the SMC-R link group, then all of the SMC-R connections on this link are abnormally terminated by resetting the TCP connections represented by these SMC-R connections. Given that multiple SMC-R connections can share the same SMC-R link, implementing an SMC-R link-level probe using the TEST LINK LLC command will help reduce the amount of unproductive keepalive traffic for SMC-R connections; as long as some SMC-R connections on a given SMC-R link are active (i.e., have had I/O activity within the keepalive interval), then there is no need to perform additional link viability testing.",
      "ja": "O SMC-R-層キープアライブ処理：キープアライブは、SMC-Rの接続のために有効になっている場合は、ローカルホストはSMC-Rの接続がアイドル状態になっているどのくらいの時間を反映キープアライブタイマーを維持します。ローカルホストは、（そのリンク上のSMC-Rの接続用）各SMC-Rリンクの最後のアクティビティのタイムスタンプを維持します。それはSMC-R接続は長くキープアライブ間隔よりもアイドル状態になっていると判定された場合、ホストチェックはSMC-Rリンクはキープアライブタイムアウトより長い期間にわたってアイドルであったか否かを確認します。両方の条件が満たされた場合、ローカルホストはROCEファブリック（RC-のQP）オーバーSMC-Rリンクの生存率をテストするためのテストリンクLLCコマンドを実行します。 TEST LINK LLCコマンド応答が妥当な時間内に受信されている場合、リンクは実行可能とみなされ、このリンクを使用してすべての接続も同様に実行可能と考えられています。しかし、応答が妥当な時間内に受信されないか、テストリンクのLLCコマンドを送信に失敗がある場合、これは、代替SMC-RリンクにSMC-Rリンクにおける障害、およびフェイルオーバ処理であると考えられますトリガされなければなりません。いかなる代替SMC-Rリンクは、SMC-Rリンク群に存在しない場合は、このリンク上のSMC-R接続の全てが異常これらSMC-R接続で表されるTCP接続をリセットして終了します。複数のSMC-Rの接続はSMC-Rの接続のための非生産的なキープアライブトラフィックの量を減らすのに役立ちますTESTリンクLLCコマンドを使用してSMC-Rリンクレベルのプローブを実装し、同じSMC-Rのリンクを共有できることを考えます。限り、所与のSMC-Rリンク上のいくつかのSMC-Rの接続がアクティブであるように（すなわち、キープアライブ間隔内にI / Oアクティビティがあった）、次いで、追加のリンク生存率試験を行う必要がありません。"
    },
    {
      "indent": 3,
      "text": "o TCP-layer keepalive processing: Traditional TCP \"keepalive\" packets are not as relevant for SMC-R connections, given that the TCP path is not used for these connections once the SMC-R Rendezvous processing is completed. All SMC-R connections by default have associated TCP connections that are idle. Are TCP keepalive probes still needed for these connections? There are two main scenarios to consider:",
      "ja": "O TCP層キープアライブ処理：従来のTCP「キープアライブ」パケットがTCPパスはSMC-Rのランデブー処理が完了すると、これらの接続に使用されていないことを考えると、SMC-Rの接続用として関連しません。デフォルトでは、すべてのSMC-Rの接続がアイドル状態にあるTCPコネクションが関連付けられています。まだこれらの接続に必要なTCPキープアライブプローブがありますか？検討するには、2つの主要なシナリオがあります。"
    },
    {
      "indent": 6,
      "text": "1. TCP keepalives that are used to determine whether or not the peer TCP endpoint is still active. This is not needed for SMC-R connections, as the SMC-R-level keepalives mentioned above will determine whether or not the remote endpoint connections are still active.",
      "ja": "ピアTCPエンドポイントがまだアクティブであるか否かを決定するために使用される1 TCPキープアライブ。上記SMC-Rレベルのキープアライブは、リモートエンドポイント接続がまだアクティブであるか否かを決定するように、これは、SMC-R接続のために必要とされません。"
    },
    {
      "indent": 6,
      "text": "2. TCP keepalives that are used to ensure that TCP connections traversing an intermediate proxy maintain an active state. For example, stateful firewalls typically maintain state representing every valid TCP connection that traverses the firewall. These types of firewalls are known to expire idle connections by removing their state in the firewall to conserve memory. TCP keepalives are often used in this scenario to prevent firewalls from timing out otherwise idle connections. When using SMC-R, both endpoints must reside in the same Layer 2 network (i.e., the same subnet). As a result, firewalls cannot be injected in the path between two SMC-R endpoints. However, other intermediate proxies, such as TCP/IP-layer load balancers, may be injected in the path of two SMC-R endpoints. These types of load balancers also maintain connection state so that they can forward TCP connection traffic to the appropriate cluster endpoint. When using SMC-R, these TCP connections will appear to be completely idle, making them susceptible to potential timeouts at the load-balancing proxy. As a result, for this scenario, TCP keepalives may still be relevant.",
      "ja": "中間プロキシを通過するTCP接続がアクティブ状態を維持することを保証するために使用される2 TCPキープアライブ。たとえば、ステートフルファイアウォールは、一般的に、ファイアウォールを通過するすべての有効なTCP接続を表す状態を維持します。ファイアウォールのこれらのタイプは、メモリを節約するために、ファイアウォールでそれらの状態を除去することにより、アイドル状態の接続を期限切れにすることが知られています。 TCPキープアライブは、多くの場合、アイドル状態の接続がタイムアウトからファイアウォールを防ぐために、このシナリオで使用されています。 SMC-Rを使用する場合、両方のエンドポイントが同じレイヤ2ネットワーク（即ち、同一サブネット）内に存在しなければなりません。その結果、ファイアウォールは、二つのSMC-Rエンドポイント間の経路に注入することができません。しかしながら、そのようなTCP / IP層のロードバランサなどの他の中間プロキシは、2つのSMC-Rエンドポイントの経路に注入されてもよいです。彼らは適切なクラスタ・エンドポイントへのTCPコネクションのトラフィックを転送できるように、ロードバランサのこれらのタイプは、接続状態を維持します。 SMC-Rを使用する場合は、これらのTCP接続は、負荷分散プロキシの電位タイムアウトに彼らが影響を受けやすく、完全にアイドル状態であることを表示されます。その結果、このシナリオでは、TCPキープアライブがまだ関連している可能性があります。"
    },
    {
      "indent": 3,
      "text": "The following are the TCP-level keepalive processing requirements for SMC-R-enabled hosts:",
      "ja": "以下SMC-R対応のホストに対するTCPレベルキープアライブ処理の要求です。"
    },
    {
      "indent": 3,
      "text": "o SMC-R peers should allow TCP keepalives to flow on the TCP path of SMC-R connections based on existing TCP keepalive configuration and programming options. However, it is strongly recommended that platforms provide the ability to specify very granular keepalive timers (for example, single-digit-second timers) and should consider providing a configuration option that limits the minimum keepalive timer that will be used for TCP-layer keepalives on SMC-R connections. This is important to minimize the amount of TCP keepalive packets transmitted in the network for SMC-R connections.",
      "ja": "O SMC-Rピアは、TCPキープアライブは、既存のTCPキープアライブ構成およびプログラミングオプションに基づいて、SMC-R接続のTCP経路上に流れることを可能にすべきです。しかし、プラットフォームは（たとえば、一桁秒のタイマーのために）非常に粒状のキープアライブタイマーを指定する機能を提供し、TCP層のキープアライブのために使用される最小キープアライブタイマーを制限設定オプションを提供することを検討すべきであるということを強くお勧めしますSMC-Rの接続に。これは、SMC-Rの接続のためのネットワークに送信されるTCPキープアライブパケットの量を最小限に抑えることが重要です。"
    },
    {
      "indent": 3,
      "text": "o SMC-R peers must always respond to inbound TCP-layer keepalives (by sending ACKs for these packets) even if the connection is using SMC-R. Typically, once a TCP connection has completed the SMC-R Rendezvous processing and is using SMC-R for data flows, no new inbound TCP segments are expected on that TCP connection, other than TCP termination segments (FIN, RST, etc.). TCP keepalives are the one exception that must be supported. Also, since TCP keepalive probes do not carry any application-layer data, this has no adverse impact on the application's inbound data stream.",
      "ja": "O SMC-Rピアは常にSMC-Rを使用して接続であっても（これらのパケットに対するACKを送信することにより）インバウンドTCP層のキープアライブに応答しなければなりません。 TCP接続はSMC-Rランデブー処理を完了し、データフローのためのSMC-Rを使用して後、典型的には、新しいインバウンドTCPセグメントは、TCP終端セグメント（FIN、RST、等）以外のそのTCP接続上で予想されません。 TCPキープアライブをサポートしなければならない唯一の例外です。また、TCPキープアライブプローブは、任意のアプリケーション層のデータを運ぶないので、これは、アプリケーションのインバウンド・データ・ストリームへの悪影響はありません。"
    },
    {
      "indent": 0,
      "text": "4.6. TCP Connection Failover between SMC-R Links",
      "section_title": true,
      "ja": "4.6。 SMC-Rのリンク間のTCP接続のフェイルオーバ"
    },
    {
      "indent": 3,
      "text": "A peer may change which SMC-R link within a link group it sends its writes over in the event of a link failure. Since each peer independently chooses which link to send writes over for a specific TCP connection, this process is done independently by each peer.",
      "ja": "ピアは、リンク障害が発生した場合に、その書き込みを超える送信リンクグループ内のどのSMC-Rのリンクを変更してもよいです。各ピアは、独立して、特定のTCP接続の上書き込み送信するためにどのリンクを選択したので、このプロセスは、各ピアによって独立して行われます。"
    },
    {
      "indent": 0,
      "text": "4.6.1. Validating Data Integrity",
      "section_title": true,
      "ja": "4.6.1。データ整合性の検証"
    },
    {
      "indent": 3,
      "text": "Even though RoCE is a reliable transport, there is a small subset of failure modes that could cause unrecoverable loss of data. When an RNIC acknowledges receipt of an RDMA write to its peer, that creates a write completion event to the sending peer, which allows the sender to release any buffers it is holding for that write. In normal operation and in most failures, this operation is reliable.",
      "ja": "ROCEが信頼できる輸送であっても、データの回復不能な損失を引き起こす可能性がある故障モードの小さなサブセットがあります。 RNICは、そのピアにRDMAライトの受信を確認すると、それは、送信者は、それがその書き込みのために保持している任意のバッファを解放することができます送信ピアへの書き込み完了イベントを作成します。通常の操作では、ほとんどの障害には、この操作は、信頼性があります。"
    },
    {
      "indent": 3,
      "text": "However, there are failure modes possible in which a receiving RNIC has acknowledged an RDMA write but then was not able to place the received data into its host memory -- for example, a sudden, disorderly failure of the interface between the RNIC and the host. While rare, these types of events must be guarded against to ensure data integrity. The process for switching SMC-R links during failover, as described in this section, guards against this possibility and is mandatory.",
      "ja": "例えば、RNICとホストとの間の界面の急激な、無秩序な障害 - しかしながら、受信RNICは、RDMA書き込みを認めたが、その後、ホストメモリに受信したデータを配置することができませんでしたに可能な故障モードが存在します。珍しいが、この種のイベントは、データの整合性を確保するために反対守られなければなりません。フェイルオーバー中SMC-Rリンクを切り替えるためのプロセスは、このセクションで説明したように、この可能性からデバイスを保護し、必須です。"
    },
    {
      "indent": 3,
      "text": "Each peer must track the current state of the CDC sequence numbers for a TCP connection. The sender must keep track of the sequence number of the CDC message that described the last write acknowledged by the peer RNIC, or Sequence Sent (SS). In other words, SS describes the last write that the sender believes its peer has successfully received. The receiver must keep track of the sequence number of the CDC message that described the last write that it has successfully received (i.e., the data has been successfully placed into an RMBE), or Sequence Received (SR).",
      "ja": "各ピアは、TCP接続のためのCDCのシーケンス番号の現在の状態を追跡する必要があります。送信者は送信ピアRNIC、またはシーケンス（SS）によって承認最後の書き込みを説明したCDCメッセージのシーケンス番号を追跡する必要があります。言い換えれば、SSは、送信者がそのピアが正常に受信していると考えている最後の書き込みについて説明します。受信機（すなわち、データが正常RMBE内に配置されている）、またはシーケンス受信（SR）が正常に受信した最後の書き込みを説明したCDCメッセージのシーケンス番号を追跡しなければなりません。"
    },
    {
      "indent": 3,
      "text": "When an RNIC fails and the sender changes SMC-R links, the sender must first send a CDC message with the F-bit (failover validation indicator; see Appendix A.4) set over the new SMC-R link. This is the failover data validation message. The sequence number in this CDC message is equal to SS. The CDC message key, the length, and the SMC-R alert token are the only other fields in this CDC message that are significant. No reply is expected from this validation message, and once the sender has sent it, the sender may resume sending on the new SMC-R link as described in Section 4.6.2.",
      "ja": "（フェイルオーバーの検証インジケータ;付録A.4を参照）RNICが失敗し、送信者がSMC-Rへのリンクを変更すると、送信者は最初のFビットとCDCメッセージを送信する必要があり、新たなSMC-Rリンク上で設定します。これは、フェイルオーバーデータ検証メッセージです。このCDCメッセージ内のシーケンス番号がSSに等しいです。 CDCのメッセージキー、長さ、およびSMC-Rのアラートトークンが重要である。このCDCメッセージで唯一の他のフィールドです。返事は、この検証メッセージから期待されていない、と送信者がそれを送った後、送信者は、セクション4.6.2で説明したように、新たなSMC-Rのリンク上で送信を再開します。"
    },
    {
      "indent": 3,
      "text": "Upon receipt of the failover validation message, the receiver must verify that its SR value for the TCP connection is equal to or greater than the sequence number in the failover validation message. If so, no further action is required, and the TCP connection resumes on the new SMC-R link. If SR is less than the sequence number value in the validation message, data has been lost, and the receiver must immediately reset the TCP connection.",
      "ja": "フェイルオーバーの検証メッセージを受信すると、受信機は、TCP接続のためのSR値は、フェイルオーバ検証メッセージ内のシーケンス番号以上であることを確認しなければなりません。もしそうなら、それ以上のアクションは必要ありませんし、TCP接続は、新しいSMC-Rのリンクを再開します。 SRは、検証メッセージ内のシーケンス番号の値よりも小さい場合は、データが失われている、受信機はすぐにTCP接続をリセットする必要があります。"
    },
    {
      "indent": 0,
      "text": "4.6.2. Resuming the TCP Connection on a New SMC-R Link",
      "section_title": true,
      "ja": "4.6.2。新SMC-Rのリンク上のTCP接続を再開"
    },
    {
      "indent": 3,
      "text": "When a connection is moved to a new SMC-R link and the failover validation message has been sent, the sender can immediately resume normal transmission. In order to preserve the application message stream, the sender must replay any RDMA writes (and their associated CDC messages) that were in progress or failed when the previous SMC-R link failed, before sending new data on the new SMC-R link. The sender has two options for accomplishing this:",
      "ja": "接続は新しいSMC-Rのリンクに移動して、フェールオーバーの検証メッセージが送信された場合には、送信者は直ちに通常の送信を再開することができます。アプリケーション・メッセージ・ストリームを維持するために、任意のRDMAを再生しなければならない送信者が書き込む（およびそれに関連するCDCメッセージ）進行中であったり、前のSMC-Rリンクは新しいSMC-Rリンクに新しいデータを送信する前に、失敗したときに失敗しました。送信者は、これを達成するための2つのオプションがあります。"
    },
    {
      "indent": 3,
      "text": "o Preserve the sequence numbers \"as is\": Retry all failed and pending operations as they were originally done, including reposting all associated RDMA write operations and their associated CDC messages without making any changes. Then resume sending new data using new sequence numbers.",
      "ja": "「そのまま」Oシーケンス番号を保持：彼らはもともと何も変更せずに、関連するすべてのRDMA書き込み操作とそれに関連するCDCメッセージを再ポストを含め、行われたとして、すべて失敗し、保留中の操作を再試行してください。次に、新しいシーケンス番号を使用して、新しいデータの送信を再開。"
    },
    {
      "indent": 3,
      "text": "o Combine pending messages and possibly add new data: Combine failed and pending messages into a single new write with a new sequence number. This allows the sender to combine pending messages into fewer operations. As a further optimization, this write can also include new data, as long as all failed and pending data are also included. If this approach is taken, the sequence number must be increased beyond the last failed or pending sequence number.",
      "ja": "O保留中のメッセージを組み合わせると、おそらく新しいデータを追加：新しいシーケンス番号を持つ単一の新しい書き込みに失敗し、保留中のメッセージを結合します。これは、送信者が少ない業務に保留中のメッセージを結合することができます。さらに最適化したように、この書き込みも限りすべてが失敗し、データを保留も含まれているとして、新しいデータを含むことができます。このアプローチが取られている場合、シーケンス番号は、最後に失敗したか、保留中のシーケンス番号を超えて増加しなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.7. RMB Data Flows",
      "section_title": true,
      "ja": "4.7。元のデータフロー"
    },
    {
      "indent": 3,
      "text": "The following sections describe the RDMA wire flows for the SMC-R protocol after a TCP connection has switched into SMC-R mode (i.e., SMC-R Rendezvous processing is complete and a pair of RMB elements has been assigned and communicated by the SMC-R peers). The ladder diagrams below include the following:",
      "ja": "以下のセクションでは（すなわち、SMC-Rのランデブー処理が完了し、元要素の対はSMC-によって割り当てられ、伝達されたTCP接続はSMC-Rモードに切り替わった後にRDMAワイヤがSMC-Rプロトコルの流れる説明しますRピア）。以下のラダー図は、次のものがあります。"
    },
    {
      "indent": 3,
      "text": "o RMBE control information kept by each peer. Only a subset of the information is depicted, specifically only the fields that reflect the stream of data written by Host A and read by Host B.",
      "ja": "各ピアによって保持O RMBE制御情報。唯一の情報のサブセットは、ホストAによって書き込まれたデータのストリームを反映具体フィールドのみを図示し、ホストBによって読み取られます"
    },
    {
      "indent": 3,
      "text": "o Time line 0-x, which shows the wire flows in a time-relative fashion.",
      "ja": "Oタイムライン線を示す0-xは、時間相対様式で流れます。"
    },
    {
      "indent": 3,
      "text": "o Note that RMBE control information is only shown in a time interval if its value changed (otherwise, assume that the value is unchanged from the previously depicted value).",
      "ja": "Oの値が変更された場合、そのRMBE制御情報のみの時間間隔に示されている（注）（そうでない場合、値は以前に示された値から変化しないと仮定）。"
    },
    {
      "indent": 3,
      "text": "o The local copy of the producer cursors and consumer cursors that is maintained by each host is not depicted in these figures. Note that the cursor values in the diagram reflect the necessity of skipping over the eye catcher in the RMBE data area. They start and wrap at 4, not 0.",
      "ja": "O各ホストによって維持されるプロデューサカーソルと消費者のカーソルのローカルコピーは、これらの図に示されていません。図中のカーソル値がRMBEデータ領域のアイキャッチャをスキップする必要性を反映することに留意されたいです。彼らは、開始と4ではなく、0で折り返します。"
    },
    {
      "indent": 0,
      "text": "4.7.1. Scenario 1: Send Flow, Window Size Unconstrained",
      "section_title": true,
      "ja": "4.7.1。シナリオ1：フロー、制約のないウィンドウサイズを送信"
    },
    {
      "indent": 3,
      "text": "         SMC Host A                             SMC Host B\n        RMBE A Info                            RMBE B Info\n    (Consumer Cursors)                      (Producer Cursors)\nCursor   Wrap Seq# Time               Time Cursor   Wrap Seq#  Flags\n4        0         0                  0    4        0          0\n0        0         1 ---------------> 1    0        0          0\n                     RDMA-WR Data\n                       (4:1003)\n4        0         2 ...............> 2    1004     0          0\n                     CDC Message",
      "raw": true
    },
    {
      "indent": 8,
      "text": "Figure 16: Scenario 1: Send Flow, Window Size Unconstrained",
      "ja": "図16：シナリオ1：フロー、制約のないウィンドウサイズを送信"
    },
    {
      "indent": 3,
      "text": "Scenario assumptions:",
      "ja": "シナリオの前提条件："
    },
    {
      "indent": 3,
      "text": "o Kernel implementation.",
      "ja": "Oカーネルの実装。"
    },
    {
      "indent": 3,
      "text": "o New SMC-R connection; no data has been sent on the connection.",
      "ja": "新SMC-Rの接続O;データが接続上で送信されていません。"
    },
    {
      "indent": 3,
      "text": "o Host A: Application issues send for 1000 bytes to Host B.",
      "ja": "OホストA：アプリケーションの問題はB.ホストするために1000年のためにバイトを送信"
    },
    {
      "indent": 3,
      "text": "o Host B: RMBE receive buffer size is 10,000; application has issued a recv for 10,000 bytes.",
      "ja": "OホストB：RMBEは、バッファサイズが10,000で受け取ります。アプリケーションは、10,000バイトのためにrecvを発行しています。"
    },
    {
      "indent": 3,
      "text": "Flow description:",
      "ja": "フロー記述："
    },
    {
      "indent": 3,
      "text": "1. The application issues a send() for 1000 bytes; the SMC-R layer copies data into a kernel send buffer. It then schedules an RDMA write operation to move the data into the peer's RMBE receive buffer, at relative position 4-1003 (to skip the 4-byte eye catcher in the RMBE data area). Note that no immediate data or alert (i.e., interrupt) is provided to Host B for this RDMA operation.",
      "ja": "1.アプリケーションは、1000バイトのセンド（）を発行します。カーネル送信バッファへのSMC-R層のデータをコピーします。次にスケジュールRDMA書き込み動作は、相対位置4から1003（RMBEデータ領域内の4バイト目キャッチャーをスキップする）で、ピアのRMBE受信バッファにデータを移動させます。即時データまたは警告ことに留意されたい（すなわち、割り込み）このRDMA動作のためにBをホストするために提供されます。"
    },
    {
      "indent": 3,
      "text": "2. Host A sends a CDC message to update the producer cursor to byte 1004. This CDC message will deliver an interrupt to Host B. At this point, the SMC-R layer can return control back to the application. Host B, once notified of the completion of the previous RDMA operation, locates the RMBE associated with the RMBE alert token that was included in the message and proceeds to perform normal receive-side processing, waking up the suspended application read thread, copying the data into the application's receive buffer, etc. It will use the producer cursor as an indicator of how much data is available to be delivered to the local application. After this processing is complete, the SMC-R layer will also update its local consumer cursor to match the producer cursor (i.e., indicating that all data has been consumed). Note that a message to the peer updating the consumer cursor is not needed at this time, as the window size is unconstrained (> 1/2 of the receive buffer size). The window size is calculated by taking the difference between the producer cursor and the consumer cursor in the RMBEs (10,000 - 1004 = 8996).",
      "ja": "2.ホストAは、このCDCメッセージは、この時点でBをホストするための割り込みを配信するバイト1004へプロデューサカーソルを更新するためのCDCメッセージを送信し、SMC-R層はバックアプリケーションに制御を返すことができます。一度前RDMAオペレーションの完了を通知ホストBは、データをコピーし、メッセージに含まれる懸濁アプリケーションスレッドを読み取る目覚め、通常、受信側の処理を実行するように進むたRMBEアラートトークンに関連付けられたRMBEを探し出しアプリケーションのなど、受信バッファには、ローカル・アプリケーションに配信することが可能ですどのくらいのデータの指標としてプロデューサーのカーソルを使用します。この処理が完了した後、SMC-R層は、プロデューサカーソル（すなわち、すべてのデータが消費されたことを示す）と一致するようにそのローカル消費者のカーソルを更新します。 （受信バッファサイズの> 1/2）ウィンドウサイズが制約されないように、消費者のカーソルを更新するピアへのメッセージは、この時点では必要とされないことに留意されたいです。ウィンドウサイズは、プロデューサカーソルとRMBEs（ -  = 8996 1004 10,000）における消費者のカーソルの間の差を取ることによって計算されます。"
    },
    {
      "indent": 0,
      "text": "4.7.2. Scenario 2: Send/Receive Flow, Window Size Unconstrained",
      "section_title": true,
      "ja": "4.7.2。シナリオ2：送信/受信フロー、ウィンドウサイズの制約なし"
    },
    {
      "indent": 4,
      "text": "         SMC Host A                             SMC Host B\n        RMBE A Info                            RMBE B Info\n    (Consumer Cursors)                      (Producer Cursors)\nCursor   Wrap Seq# Time               Time Cursor   Wrap Seq#  Flags\n4        0         0                  0    4        0          0\n0        0         1 ---------------> 1    0        0          0\n                     RDMA-WR Data\n                       (4:1003)\n4        0         2 ...............> 2    1004     0          0\n                     CDC Message",
      "raw": true
    },
    {
      "indent": 4,
      "text": "0        0         3 <--------------  3    1004     0          0\n                     RDMA-WR Data\n                       (4:503)\n1004     0         4 <..............  4    1004     0          0\n                      CDC Message",
      "raw": true
    },
    {
      "indent": 4,
      "text": "Figure 17: Scenario 2: Send/Receive Flow, Window Size Unconstrained",
      "ja": "図17：シナリオ2：送信/受信フロー、ウィンドウサイズの制約なし"
    },
    {
      "indent": 3,
      "text": "Scenario assumptions:",
      "ja": "シナリオの前提条件："
    },
    {
      "indent": 3,
      "text": "o New SMC-R connection; no data has been sent on the connection.",
      "ja": "新SMC-Rの接続O;データが接続上で送信されていません。"
    },
    {
      "indent": 3,
      "text": "o Host A: Application issues send for 1000 bytes to Host B.",
      "ja": "OホストA：アプリケーションの問題はB.ホストするために1000年のためにバイトを送信"
    },
    {
      "indent": 3,
      "text": "o Host B: RMBE receive buffer size is 10,000; application has already issued a recv for 10,000 bytes. Once the receive is completed, the application sends a 500-byte response to Host A.",
      "ja": "OホストB：RMBEは、バッファサイズが10,000で受け取ります。アプリケーションは、既に10,000バイトのためにrecvを発行しています。ザ・受信が完了すると、アプリケーションはA.ホストするために500バイトの応答を送信します"
    },
    {
      "indent": 3,
      "text": "Flow description:",
      "ja": "フロー記述："
    },
    {
      "indent": 3,
      "text": "1. The application issues a send() for 1000 bytes; the SMC-R layer copies data into a kernel send buffer. It then schedules an RDMA write operation to move the data into the peer's RMBE receive buffer, at relative position 4-1003. Note that no immediate data or alert (i.e., interrupt) is provided to Host B for this RDMA operation.",
      "ja": "1.アプリケーションは、1000バイトのセンド（）を発行します。カーネル送信バッファへのSMC-R層のデータをコピーします。次にスケジュールRDMA書き込み動作は、相対位置4から1003で、ピアのRMBE受信バッファにデータを移動させます。即時データまたは警告ことに留意されたい（すなわち、割り込み）このRDMA動作のためにBをホストするために提供されます。"
    },
    {
      "indent": 3,
      "text": "2. Host A sends a CDC message to update the producer cursor to byte 1004. This CDC message will deliver an interrupt to Host B. At this point, the SMC-R layer can return control back to the application.",
      "ja": "2.ホストAは、このCDCメッセージは、この時点でBをホストするための割り込みを配信するバイト1004へプロデューサカーソルを更新するためのCDCメッセージを送信し、SMC-R層はバックアプリケーションに制御を返すことができます。"
    },
    {
      "indent": 3,
      "text": "3. Host B, once notified of the receipt of the previous CDC message, locates the RMBE associated with the RMBE alert token and proceeds to perform normal receive-side processing, waking up the suspended application read thread, copying the data into the application's receive buffer, etc. After this processing is complete, the SMC-R layer will also update its local consumer cursor to match the producer cursor (i.e., indicating that all data has been consumed). Note that an update of the consumer cursor to the peer is not needed at this time, as the window size is unconstrained (> 1/2 of the receive buffer size). The application then performs a send() for 500 bytes to Host A. The SMC-R layer will copy the data into a kernel buffer and then schedule an RDMA write into the partner's RMBE receive buffer. Note that this RDMA write operation includes no immediate data or notification to Host A.",
      "ja": "一度前CDCメッセージの受信を通知3.ホストBは、RMBEアラートトークンに関連付けられRMBEを検索し、通常受信側の処理を実行するように進み、中断アプリケーションを目覚めアプリケーションの受信にデータをコピーし、スレッドを読んバッファなど、この処理が完了した後、SMC-R層は、プロデューサカーソル（すなわち、すべてのデータが消費されたことを示す）と一致するようにそのローカル消費者のカーソルを更新します。ウィンドウサイズが制約されないようにピアへの消費者のカーソルの更新が（>受信バッファサイズの1/2）、この時点では必要とされないことに留意されたいです。アプリケーションは、その後、SMC-R層は、カーネルバッファにデータをコピーして受信バッファパートナーのRMBEにRDMA書き込みをスケジュールするA.をホストするために500バイトのための送信（）を実行します。このRDMA書き込み動作は即時データまたはAをホストに通知が含まれていないことに注意してください"
    },
    {
      "indent": 3,
      "text": "4. Host B sends a CDC message to update the partner's RMBE control information with the latest producer cursor (set to 503 and not shown in the diagram above) and to also inform the peer that the consumer cursor value is now 1004. It also updates the local current consumer cursor and the last sent consumer cursor to 1004. This CDC message includes notification, since we are updating our producer cursor; this requires attention by the peer host.",
      "ja": "4.ホストBは、最新の生産カーソル（503に設定され、上の図には示されていない）とパートナーのRMBE制御情報を更新するとともに、消費者のカーソル値はまた、今アップデート1004であるピアに通知するためにCDCメッセージを送信しますローカルの現在の消費者のカーソルと私たちは私たちのプロデューサーカーソルを更新しているので、このCDCのメッセージは、通知を含ん1004への最後の送信された消費者のカーソル。これは、ピアのホストで注意が必要です。"
    },
    {
      "indent": 0,
      "text": "4.7.3. Scenario 3: Send Flow, Window Size Constrained",
      "section_title": true,
      "ja": "4.7.3。シナリオ3：フロー、制約ウィンドウサイズを送信"
    },
    {
      "indent": 4,
      "text": "         SMC Host A                             SMC Host B\n        RMBE A Info                            RMBE B Info\n    (Consumer Cursors)                      (Producer Cursors)\nCursor   Wrap Seq# Time               Time Cursor   Wrap Seq#  Flags\n4        0         0                  0    4        0          0\n4        0         1 ---------------> 1    4        0          0\n                     RDMA-WR Data\n                       (4:3003)\n4        0         2 ...............> 2    3004     0          0\n                     CDC Message\n4        0         3                  3    3004     0          0\n4        0         4 ---------------> 4    3004     0          0\n                     RDMA-WR Data\n                       (3004:7003)\n4        0         5 ................> 5   7004     0          0\n                     CDC Message\n7004     0         6 <................ 6   7004     0          0\n                     CDC Message",
      "raw": true
    },
    {
      "indent": 9,
      "text": "Figure 18: Scenario 3: Send Flow, Window Size Constrained",
      "ja": "図18：シナリオ3：フロー、制約ウィンドウサイズを送信"
    },
    {
      "indent": 3,
      "text": "Scenario assumptions:",
      "ja": "シナリオの前提条件："
    },
    {
      "indent": 3,
      "text": "o New SMC-R connection; no data has been sent on this connection.",
      "ja": "新SMC-Rの接続O;データは、この接続で送信されていません。"
    },
    {
      "indent": 3,
      "text": "o Host A: Application issues send for 3000 bytes to Host B and then another send for 4000 bytes.",
      "ja": "Oホスト：アプリケーションの問題は、ホストBに3000バイトを送信した後、別の4000のバイトを送信します。"
    },
    {
      "indent": 3,
      "text": "o Host B: RMBE receive buffer size is 10,000. Application has already issued a recv for 10,000 bytes.",
      "ja": "OホストB：RMBEは、バッファサイズが10,000で受け取ります。アプリケーションは、既に10,000バイトのためにrecvを発行しています。"
    },
    {
      "indent": 3,
      "text": "Flow description:",
      "ja": "フロー記述："
    },
    {
      "indent": 3,
      "text": "1. The application issues a send() for 3000 bytes; the SMC-R layer copies data into a kernel send buffer. It then schedules an RDMA write operation to move the data into the peer's RMBE receive buffer, at relative position 4-3003. Note that no immediate data or alert (i.e., interrupt) is provided to Host B for this RDMA operation.",
      "ja": "1.アプリケーションは、3000バイトのための送信（）を発行します。カーネル送信バッファへのSMC-R層のデータをコピーします。次にスケジュールRDMA書き込み動作は、相対位置4から3003で、ピアのRMBE受信バッファにデータを移動させます。即時データまたは警告ことに留意されたい（すなわち、割り込み）このRDMA動作のためにBをホストするために提供されます。"
    },
    {
      "indent": 3,
      "text": "2. Host A sends a CDC message to update its producer cursor to byte 3003. This CDC message will deliver an interrupt to Host B. At this point, the SMC-R layer can return control back to the application.",
      "ja": "2.ホストAはバイト3003この時点で、B.をホストするために、割り込みを配信するこのCDCメッセージにそのプロデューサカーソルを更新するためのCDCメッセージを送信し、SMC-R層はバックアプリケーションに制御を返すことができます。"
    },
    {
      "indent": 3,
      "text": "3. Host B, once notified of the receipt of the previous CDC message, locates the RMBE associated with the RMBE alert token and proceeds to perform normal receive-side processing, waking up the suspended application read thread, copying the data into the application's receive buffer, etc. After this processing is complete, the SMC-R layer will also update its local consumer cursor to match the producer cursor (i.e., indicating that all data has been consumed). It will not, however, update the partner with this information, as the window size is not constrained (10,000 - 3000 = 7000 bytes of available space). The application on Host B also issues a new recv() for 10,000 bytes.",
      "ja": "一度前CDCメッセージの受信を通知3.ホストBは、RMBEアラートトークンに関連付けられRMBEを検索し、通常受信側の処理を実行するように進み、中断アプリケーションを目覚めアプリケーションの受信にデータをコピーし、スレッドを読んバッファなど、この処理が完了した後、SMC-R層は、プロデューサカーソル（すなわち、すべてのデータが消費されたことを示す）と一致するようにそのローカル消費者のカーソルを更新します。 （ - 利用可能なスペースの3000 = 7000バイト10,000）ウィンドウサイズが制約されないように、それは、しかし、この情報を持つパートナーを更新しません。ホストB上のアプリケーションでは、10,000バイトのための新しいRECV（）を発行します。"
    },
    {
      "indent": 3,
      "text": "4. On Host A, the application issues a send() for 4000 bytes. The SMC-R layer copies the data into a kernel buffer and schedules an async RDMA write into the peer's RMBE receive buffer at relative position 3003-7004. Note that no alert is provided to Host B for this flow.",
      "ja": "ホストA 4.、アプリケーションが4000バイトのセンド（）を発行します。非同期RDMA書き込みピアのRMBEにカーネルバッファおよびスケジュールにSMC-R層のコピーデータが相対位置3003から7004に受信バッファ。何の警告がこの流れのためのホストBに提供されていないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "5. Host A sends a CDC message to update the producer cursor to byte 7004. This CDC message will deliver an interrupt to Host B. At this point, the SMC-R layer can return control back to the application.",
      "ja": "5.ホストAは、このCDCメッセージは、この時点でBをホストするための割り込みを配信するバイト7004へプロデューサカーソルを更新するためのCDCメッセージを送信し、SMC-R層はバックアプリケーションに制御を返すことができます。"
    },
    {
      "indent": 3,
      "text": "6. Host B, once notified of the receipt of the previous CDC message, locates the RMBE associated with the RMBE alert token and proceeds to perform normal receive-side processing, waking up the suspended application read thread, copying the data into the application's receive buffer, etc. After this processing is complete, the SMC-R layer will also update its local consumer cursor to match the producer cursor (i.e., indicating that all data has been consumed). It will then determine whether or not it needs to update the consumer cursor to the peer. The available window size is now 3000 (10,000 - (producer cursor - last sent consumer cursor)), which is < 1/2 of the receive buffer size (10,000/2 = 5000), and the advance of the window size is > 10% of the window size (1000). Therefore, a CDC message is issued to update the consumer cursor to Peer A.",
      "ja": "一度前CDCメッセージの受信を通知6.ホストBは、RMBEアラートトークンに関連付けられRMBEを検索し、通常受信側の処理を実行するように進み、中断アプリケーションを目覚めアプリケーションの受信にデータをコピーし、スレッドを読んバッファなど、この処理が完了した後、SMC-R層は、プロデューサカーソル（すなわち、すべてのデータが消費されたことを示す）と一致するようにそのローカル消費者のカーソルを更新します。それはそれは、ピアへの消費者のカーソルを更新する必要があるかどうかを決定します。 （ - （プロデューサカーソル - 万最終消費者のカーソル）送信された）使用可能なウィンドウサイズは現在、3000であり、10 <受信バッファサイズ（10,000 / 2 = 5000）の1/2、およびウィンドウサイズの前進をされています>ウィンドウサイズ（1000）の％。したがって、CDCメッセージは、ピアAに消費者のカーソルを更新するために発行されます"
    },
    {
      "indent": 0,
      "text": "4.7.4. Scenario 4: Large Send, Flow Control, Full Window Size Writes",
      "section_title": true,
      "ja": "4.7.4。シナリオ4：大量送信、フロー制御、フル・ウィンドウ・サイズを書き込みます"
    },
    {
      "indent": 4,
      "text": "         SMC Host A                             SMC Host B\n        RMBE A Info                            RMBE B Info\n    (Consumer Cursors)                      (Producer Cursors)\nCursor   Wrap Seq# Time               Time Cursor   Wrap Seq#  Flags\n1004     1         0                  0    1004     1          0\n1004     1         1 ---------------> 1    1004     1          0\n                     RDMA-WR Data\n                       (1004:9999)\n1004     1         2 ---------------> 2    1004     1          0\n                     RDMA-WR Data\n                       (4:1003)\n1004     1         3 ...............> 3    1004     2          Wrt\n                     CDC Message                               Blk",
      "raw": true
    },
    {
      "indent": 4,
      "text": "1004     2         4 <............... 4    1004     2          Wrt\n                     CDC Message                               Blk",
      "raw": true
    },
    {
      "indent": 4,
      "text": "1004     2         5 ---------------> 5    1004     2          Wrt\n                     RDMA-WR Data                              Blk\n                       (1004:9999)\n1004     2         6 ---------------> 6    1004     2          Wrt\n                     RDMA-WR Data                              Blk\n                      (4:1003)\n1004     2         7 ...............> 7    1004     3          Wrt\n                     CDC Message                               Blk",
      "raw": true
    },
    {
      "indent": 4,
      "text": "1004     3         8 <............... 8    1004     3          Wrt\n                     CDC Message                               Blk",
      "raw": true
    },
    {
      "indent": 13,
      "text": "Figure 19: Scenario 4: Large Send, Flow Control,\n             Full Window Size Writes",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Scenario assumptions:",
      "ja": "シナリオの前提条件："
    },
    {
      "indent": 3,
      "text": "o Kernel implementation.",
      "ja": "Oカーネルの実装。"
    },
    {
      "indent": 3,
      "text": "o Existing SMC-R connection, Host B's receive window size is fully open (peer consumer cursor = peer producer cursor).",
      "ja": "O既存のSMC-Rの接続、ホストBさんのウィンドウサイズが（ピア・コンシューマ・カーソル=ピアプロデューサカーソル）全開受け取ります。"
    },
    {
      "indent": 3,
      "text": "o Host A: Application issues send for 20,000 bytes to Host B.",
      "ja": "B.ホストするために20,000バイトを送信するアプリケーションの問題：Oホスト"
    },
    {
      "indent": 3,
      "text": "o Host B: RMBE receive buffer size is 10,000; application has issued a recv for 10,000 bytes.",
      "ja": "OホストB：RMBEは、バッファサイズが10,000で受け取ります。アプリケーションは、10,000バイトのためにrecvを発行しています。"
    },
    {
      "indent": 3,
      "text": "Flow description:",
      "ja": "フロー記述："
    },
    {
      "indent": 3,
      "text": "1. The application issues a send() for 20,000 bytes; the SMC-R layer copies data into a kernel send buffer (assumes that send buffer space of 20,000 is available for this connection). It then schedules an RDMA write operation to move the data into the peer's RMBE receive buffer, at relative position 1004-9999. Note that no immediate data or alert (i.e., interrupt) is provided to Host B for this RDMA operation.",
      "ja": "1.アプリケーション20,000バイトのセンド（）を発行します。 SMC-R層コピーデータのカーネル送信バッファへ（20,000送信バッファ空間は、この接続のために利用可能であると仮定）。次にスケジュールRDMA書き込み動作は、相対位置1004から9999に、ピアのRMBE受信バッファにデータを移動させます。即時データまたは警告ことに留意されたい（すなわち、割り込み）このRDMA動作のためにBをホストするために提供されます。"
    },
    {
      "indent": 3,
      "text": "2. Host A then schedules an RDMA write operation to fill the remaining 1000 bytes of available space in the peer's RMBE receive buffer, at relative position 4-1003. Note that no immediate data or alert (i.e., interrupt) is provided to Host B for this RDMA operation. Also note that an implementation of SMC-R may optimize this processing by combining steps 1 and 2 into a single RDMA write operation (with two different data sources).",
      "ja": "2.ホストAは、その後スケジュールがRDMA書き込み動作は、相対位置4から1003で、ピアのRMBE受信バッファ内の利用可能なスペースの残り1000バイトを充填します。即時データまたは警告ことに留意されたい（すなわち、割り込み）このRDMA動作のためにBをホストするために提供されます。また、SMC-Rの実装では、（2つの異なるデータソースを持つ）単一のRDMA書き込み動作中にステップ1および2を組み合わせることにより、この処理を最適化することができることに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "3. Host A sends a CDC message to update the producer cursor to byte 1004. Since the entire receive buffer space is filled, the producer writer blocked flag (the \"Wrt Blk\" indicator (flag) in Figure 19) is set and the producer cursor wrap sequence number (the producer \"Wrap Seq#\" in Figure 19) is incremented. This CDC message will deliver an interrupt to Host B. At this point, the SMC-R layer can return control back to the application.",
      "ja": "3.ホストAは全体の受信バッファ空間が充填されるので、バイト1004にプロデューサカーソルを更新するために、CDCメッセージを送信し、プロデューサーライタは（図19に「WrtのBLK」インジケータ（FLAG））フラグをブロック設定され、プロデューサーカーソルラップシーケンス番号（図19のプロデューサ「ラップSEQ番号」）がインクリメントされます。このCDCのメッセージは、SMC-R層は戻っアプリケーションに制御を返すことができ、この時点でB.をホストするために、割り込みをお届けします。"
    },
    {
      "indent": 3,
      "text": "4. Host B, once notified of the receipt of the previous CDC message, locates the RMBE associated with the RMBE alert token and proceeds to perform normal receive-side processing, waking up the suspended application read thread, copying the data into the application's receive buffer, etc. In this scenario, Host B notices that the producer cursor has not been advanced (same value as the consumer cursor); however, it notices that the producer cursor wrap sequence number is different from its local value (1), indicating that a full window of new data is available. All of the data in the receive buffer can be processed, with the first segment (1004-9999) followed by the second segment (4-1003). Because the producer writer blocked indicator was set, Host B schedules a CDC message to update its latest information to the peer: consumer cursor (1004), consumer cursor wrap sequence number (the current value of 2 is used).",
      "ja": "一度前CDCメッセージの受信を通知4.ホストBは、RMBEアラートトークンに関連付けられRMBEを検索し、通常受信側の処理を実行するように進み、中断アプリケーションを目覚めアプリケーションの受信にデータをコピーし、スレッドを読んプロデューサカーソルが前進していないバッファなど、このシナリオでは、ホストB通知（消費者のカーソルと同じ値）。しかし、生産カーソルラップ・シーケンス番号は、新しいデータの完全なウィンドウが利用可能であることを示し、そのローカル値（1）とは異なることに気付きます。受信バッファ内の全てのデータは、第二セグメント（4から1003）、続いて最初のセグメント（1004から9999）を用いて、処理することができます。消費者のカーソル（1004）、消費者のカーソルラップ・シーケンス番号（2の現在の値が使用されている）：プロデューサーライタ遮断インジケータが設定されているので、ホストBスケジュールCDCメッセージは、ピアへの最新情報を更新します。"
    },
    {
      "indent": 3,
      "text": "5. Host A, upon receipt of the CDC message, locates the TCP connection associated with the alert token and, upon examining the control information provided, notices that Host B has consumed all of the data (based on the consumer cursor and the consumer cursor wrap sequence number) and initiates the next RDMA write to fill the receive buffer at offset 1003-9999.",
      "ja": "5.ホストAは、CDCメッセージを受信すると、アラートトークンに関連付けられたTCP接続を検索し、提供される制御情報を調べる際に、ホストBは、消費者のカーソルと消費者カーソルに基づいてデータのすべてを（消費したことに気付きますシーケンス番号をラップ）し、1003から9999までのオフセットで受信バッファを埋めるために、次のRDMA書き込みを開始します。"
    },
    {
      "indent": 3,
      "text": "6. Host A then moves the next 1000 bytes into the beginning of the receive buffer (4-1003) by scheduling an RDMA write operation. Note that at this point there are still 8 bytes remaining to be written.",
      "ja": "6.ホストAは、次に、RDMA書き込み動作をスケジューリングすることによって受信バッファ（4から1003）の先頭に次の1000のバイトを移動させます。この時点で書き込まれる残りの8つのバイトが残っていることに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "7. Host A then sends a CDC message to set the producer writer blocked indicator and to increment the producer cursor wrap sequence number (3).",
      "ja": "7.ホストAは、その後、プロデューサライタ遮断インジケータを設定し、生産カーソルラップ・シーケンス番号（3）をインクリメントするCDCメッセージを送信します。"
    },
    {
      "indent": 3,
      "text": "8. Host B, upon notification, completes the same processing as step 4 above, including sending a CDC message to update the peer to indicate that all data has been consumed. At this point, Host A can write the final 8 bytes to Host B's RMBE into positions 1004-1011 (not shown).",
      "ja": "8.ホストBは、通知時に、すべてのデータが消費されたことを示すためにピアを更新するために、CDCメッセージの送信を含む上記ステップ4と同様の処理を終了します。この時点で、ホストAは、位置1004から1011へのBのRMBEをホストするために最後の8つのバイトを書き込むことができる（図示せず）。"
    },
    {
      "indent": 0,
      "text": "4.7.5. Scenario 5: Send Flow, Urgent Data, Window Size Unconstrained",
      "section_title": true,
      "ja": "4.7.5。シナリオ5：フロー、緊急データ、制約のないウィンドウサイズを送信"
    },
    {
      "indent": 4,
      "text": "         SMC Host A                             SMC Host B\n        RMBE A Info                            RMBE B Info\n    (Consumer Cursors)                      (Producer Cursors)\nCursor   Wrap Seq# Time               Time Cursor   Wrap Seq#  Flag\n1000     1         0                  0    1000     1          0\n1000     1         1 ---------------> 1    1000     1          0\n                     RDMA-WR Data\n                       (1000:1499)\n1000     1         2 ...............> 2    1500     1          UrgP\n                     CDC Message                               UrgA",
      "raw": true
    },
    {
      "indent": 4,
      "text": "1500     1         3 <............... 3    1500     1          UrgP\n                     CDC Message                               UrgA",
      "raw": true
    },
    {
      "indent": 4,
      "text": "1500     1         4 ---------------> 4    1500     1          UrgP\n                     RDMA-WR Data                              UrgA\n                       (1500:2499)\n1500     1         5 ...............> 5    2500     1          0\n                     CDC Message",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Figure 20: Scenario 5: Send Flow, Urgent Data, Window Size Open",
      "ja": "図20：シナリオ5：フロー、緊急データ、オープンウィンドウサイズを送信"
    },
    {
      "indent": 3,
      "text": "Scenario assumptions:",
      "ja": "シナリオの前提条件："
    },
    {
      "indent": 3,
      "text": "o Kernel implementation.",
      "ja": "Oカーネルの実装。"
    },
    {
      "indent": 3,
      "text": "o Existing SMC-R connection; window size open (unconstrained); all data has been consumed by receiver.",
      "ja": "O既存のSMC-Rの接続。ウィンドウサイズオープン（拘束されていません）。すべてのデータが受信機によって消費されています。"
    },
    {
      "indent": 3,
      "text": "o Host A: Application issues send for 500 bytes with urgent data indicator (out of band) to Host B, then sends 1000 bytes of normal data.",
      "ja": "Oホスト：問題がホストBに（帯域外）緊急データインジケータと500のバイトを送信するアプリケーションは、通常のデータの1000のバイトを送信します。"
    },
    {
      "indent": 3,
      "text": "o Host B: RMBE receive buffer size is 10,000; application has issued a recv for 10,000 bytes and is also monitoring the socket for urgent data.",
      "ja": "OホストB：RMBEは、バッファサイズが10,000で受け取ります。アプリケーションは、10,000バイトのためにrecvを発行しているし、また、緊急データ用のソケットを監視しています。"
    },
    {
      "indent": 3,
      "text": "Flow description:",
      "ja": "フロー記述："
    },
    {
      "indent": 3,
      "text": "1. The application issues a send() for 500 bytes of urgent data; the SMC-R layer copies data into a kernel send buffer. It then schedules an RDMA write operation to move the data into the peer's RMBE receive buffer, at relative position 1000-1499. Note that no immediate data or alert (i.e., interrupt) is provided to Host B for this RDMA operation.",
      "ja": "1.アプリケーションは、緊急データの500バイトのための送信（）を発行します。カーネル送信バッファへのSMC-R層のデータをコピーします。次にスケジュールRDMA書き込み動作は、相対位置1000から1499に、ピアのRMBE受信バッファにデータを移動させます。即時データまたは警告ことに留意されたい（すなわち、割り込み）このRDMA動作のためにBをホストするために提供されます。"
    },
    {
      "indent": 3,
      "text": "2. Host A sends a CDC message to update its producer cursor to byte 1500 and to turn on the producer Urgent Data Pending (UrgP) and Urgent Data Present (UrgA) flags. This CDC message will deliver an interrupt to Host B. At this point, the SMC-R layer can return control back to the application.",
      "ja": "2.ホストAはバイト1500にそのプロデューサカーソルを更新し、生産緊急データ保留（UrgP）及び緊急データプレゼント（UrgA）フラグをオンするようにCDCメッセージを送信します。このCDCのメッセージは、SMC-R層は戻っアプリケーションに制御を返すことができ、この時点でB.をホストするために、割り込みをお届けします。"
    },
    {
      "indent": 3,
      "text": "3. Host B, once notified of the receipt of the previous CDC message, locates the RMBE associated with the RMBE alert token, notices that the Urgent Data Pending flag is on, and proceeds with out-of-band socket API notification -- for example, satisfying any outstanding select() or poll() requests on the socket by indicating that urgent data is pending (i.e., by setting the exception bit on). The urgent data present indicator allows Host B to also determine the position of the urgent data (the producer cursor points 1 byte beyond the last byte of urgent data). Host B can then perform normal receive-side processing (including specific urgent data processing), copying the data into the application's receive buffer, etc. Host B then sends a CDC message to update the partner's RMBE control area with its latest consumer cursor (1500). Note that this CDC message must occur, regardless of the current local window size that is available. The partner host (Host A) cannot initiate any additional RDMA writes until it receives acknowledgment that the urgent data has been processed (or at least processed/remembered at the SMC-R layer).",
      "ja": "一度前CDCメッセージの受信を通知3.ホストBは、RMBEアラートトークンに関連付けられRMBEを検索し、緊急データ保留フラグがオンであり、アウト・オブ・バンドソケットAPIの通知に進むことに気付く - のため例えば、緊急データは（例外ビットに設定することにより、IE）保留中であることを示すことにより、ソケットの未解決の選択（）またはポーリング（）要求を満たします。緊急データ存在インジケータは、ホストBはまた、緊急情報（緊急データの最後のバイトを超えて生産カーソルポイント1バイト）の位置を決定することを可能にします。ホストBは、次いで、（特定の緊急データの処理を含む）は、通常、受信側の処理を実行することができ、アプリケーションのなど、受信バッファホストBへデータをコピーすることは、その後1500（最新の消費者のカーソルとパートナーのRMBE制御エリアを更新するために、CDCメッセージを送信します）。かかわらず利用可能である現在のローカルウィンドウサイズの、このCDCメッセージが発生しなければならないことに注意してください。相手ホスト（ホストA）は、緊急データを処理（又は少なくともSMC-R層で覚え/処理）されたことの確認応答を受信するまで、追加のRDMA書き込みを開始することができません。"
    },
    {
      "indent": 3,
      "text": "4. Upon receipt of the message, Host A wakes up, sees that the peer consumed all data up to and including the last byte of urgent data, and now resumes sending any pending data. In this case, the application had previously issued a send for 1000 bytes of normal data, which would have been copied in the send buffer, and control would have been returned to the application. Host A now initiates an RDMA write to move that data to the peer's receive buffer at position 1500-2499.",
      "ja": "メッセージを受信すると4、ホストAは、目を覚ますピアはまでのすべてのデータを消費することを見て、緊急データの最後のバイトを含め、現在は保留中のデータの送信を再開します。この場合、アプリケーションは、以前に送信バッファにコピーされていたであろう通常のデータの1000バイト、のセンドを発行していた、と制御がアプリケーションに返されていたであろう。今の位置1500-2499で、ピアの受信バッファにそのデータを移動するために、RDMA書き込みを開始ホスト。"
    },
    {
      "indent": 3,
      "text": "5. Host A then sends a CDC message to update its producer cursor value (2500) and to turn off the Urgent Data Pending and Urgent Data Present flags. Host B wakes up, processes the new data (resumes application, copies data into the application receive buffer), and then proceeds to update the local current consumer cursor (2500). Given that the window size is unconstrained, there is no need for a consumer cursor update in the peer's RMBE.",
      "ja": "5.ホストAは、そのプロデューサカーソル値（2500）を更新し、緊急データ保留及び緊急データ現在のフラグをオフにするCDCメッセージを送信します。ホストBは、ウェイクアップ新しいデータを処理する（受信バッファアプリケーションにアプリケーション、コピーデータを再開）し、ローカル現在の消費者のカーソル（2500）を更新するように進みます。ウィンドウサイズが拘束されていることを考えると、ピアのRMBEにおける消費者のカーソル更新は必要ありません。"
    },
    {
      "indent": 0,
      "text": "4.7.6. Scenario 6: Send Flow, Urgent Data, Window Size Closed",
      "section_title": true,
      "ja": "4.7.6。シナリオ6：フロー、緊急データ、閉じられたウィンドウサイズを送信"
    },
    {
      "indent": 4,
      "text": "         SMC Host A                             SMC Host B\n        RMBE A Info                            RMBE B Info\n    (Consumer Cursors)                      (Producer Cursors)\nCursor   Wrap Seq# Time               Time Cursor   Wrap Seq#  Flag\n1000     1         0                  0    1000     2          Wrt\n                                                               Blk",
      "raw": true
    },
    {
      "indent": 4,
      "text": "1000     1         1 ...............> 1    1000     2          Wrt\n                     CDC Message                               Blk\n                                                               UrgP",
      "raw": true
    },
    {
      "indent": 4,
      "text": "1000     2         2 <............... 2    1000     2          Wrt\n                     CDC Message                               Blk\n                                                               UrgP",
      "raw": true
    },
    {
      "indent": 4,
      "text": "1000     2         3 ---------------> 3    1000     2          Wrt\n                     RDMA-WR Data                              Blk\n                       (1000:1499)                             UrgP",
      "raw": true
    },
    {
      "indent": 4,
      "text": "1000     2         4 ...............> 4    1500     2          UrgP\n                     CDC Message                               UrgA",
      "raw": true
    },
    {
      "indent": 4,
      "text": "1500     2         5 <............... 5    1500     2          UrgP\n                     CDC Message                               UrgA",
      "raw": true
    },
    {
      "indent": 4,
      "text": "1500     2         6 ---------------> 6    1500     2          UrgP\n                     RDMA-WR Data                              UrgA\n                       (1500:2499)\n1000     2         7 ...............> 7    2500     2          0\n                     CDC Message",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Figure 21: Scenario 6: Send Flow, Urgent Data, Window Size Closed",
      "ja": "図21：シナリオ6：フロー、緊急データを送信し、ウィンドウサイズは休館します"
    },
    {
      "indent": 3,
      "text": "Scenario assumptions:",
      "ja": "シナリオの前提条件："
    },
    {
      "indent": 3,
      "text": "o Kernel implementation.",
      "ja": "Oカーネルの実装。"
    },
    {
      "indent": 3,
      "text": "o Existing SMC-R connection; window size closed; writer is blocked.",
      "ja": "O既存のSMC-Rの接続。ウィンドウサイズは閉じられ、ライターがブロックされています。"
    },
    {
      "indent": 3,
      "text": "o Host A: Application issues send for 500 bytes with urgent data indicator (out of band) to Host B, then sends 1000 bytes of normal data.",
      "ja": "Oホスト：問題がホストBに（帯域外）緊急データインジケータと500のバイトを送信するアプリケーションは、通常のデータの1000のバイトを送信します。"
    },
    {
      "indent": 3,
      "text": "o Host B: RMBE receive buffer size is 10,000; application has no outstanding recv() (for normal data) and is monitoring the socket for urgent data.",
      "ja": "OホストB：RMBEは、バッファサイズが10,000で受け取ります。アプリケーションが（通常のデータ用））（未処理RECVを持たず、緊急データ用のソケットを監視しています。"
    },
    {
      "indent": 3,
      "text": "Flow description:",
      "ja": "フロー記述："
    },
    {
      "indent": 3,
      "text": "1. The application issues a send() for 500 bytes of urgent data; the SMC-R layer copies data into a kernel send buffer (if available). Since the writer is blocked (window size closed), it cannot send the data immediately. It then sends a CDC message to notify the peer of the Urgent Data Pending (UrgP) indicator (the writer blocked indicator remains on as well). This serves as a signal to Host B that urgent data is pending in the stream. Control is also returned to the application at this point.",
      "ja": "1.アプリケーションは、緊急データの500バイトのための送信（）を発行します。カーネル送信バッファへのSMC-R層のコピーデータ（利用可能な場合）。ライターは（ウィンドウサイズが閉じ）ブロックされているので、すぐにデータを送信することはできません。その後、緊急データ保留（UrgP）インジケータ（ライターブロックされたインジケータが同様にオンのまま）のピアに通知するために、CDCメッセージを送信します。これは、ストリーム内の緊急データが保留されているBをホストする信号となります。コントロールもこの時点で、アプリケーションに返されます。"
    },
    {
      "indent": 3,
      "text": "2. Host B, once notified of the receipt of the previous CDC message, locates the RMBE associated with the RMBE alert token, notices that the Urgent Data Pending flag is on, and proceeds with out-of-band socket API notification -- for example, satisfying any outstanding select() or poll() requests on the socket by indicating that urgent data is pending (i.e., by setting the exception bit on). At this point, it is expected that the application will enter urgent data mode processing, expeditiously processing all normal data (by issuing recv API calls) so that it can get to the urgent data byte. Whether the application has this urgent mode processing or not, at some point, the application will consume some or all of the pending data in the receive buffer. When this occurs, Host B will also send a CDC message to update its consumer cursor and consumer cursor wrap sequence number to the peer. In the example above, a full window's worth of data was consumed.",
      "ja": "一度前CDCメッセージの受信を通知2.ホストBは、RMBEアラートトークンに関連付けられRMBEを検索し、緊急データ保留フラグがオンであり、アウト・オブ・バンドソケットAPIの通知に進むことに気付く - のため例えば、緊急データは（例外ビットに設定することにより、IE）保留中であることを示すことにより、ソケットの未解決の選択（）またはポーリング（）要求を満たします。この時点で、緊急データのバイトを得ることができるようにアプリケーションが（RECV API呼び出しを発行することにより）迅速にすべての通常のデータを処理し、緊急データモード処理に入ることが期待されます。アプリケーションがこの緊急モード処理を持っているかどうかは、いくつかの点で、アプリケーションは、受信バッファ内の保留中のデータの一部またはすべてを消費します。これが発生すると、ホストBは、ピアへの消費者のカーソルと消費者カーソルラップシーケンス番号を更新するために、CDCメッセージを送信します。上記の例では、データの完全なウィンドウの価値が消費されました。"
    },
    {
      "indent": 3,
      "text": "3. Host A, once awakened by the message, will notice that the window size is now open on this connection (based on the consumer cursor and the consumer cursor wrap sequence number, which now matches the producer cursor wrap sequence number) and resume sending of the urgent data segment by scheduling an RDMA write into relative position 1000-1499.",
      "ja": "3.ホストAは、一度メッセージによって起こさ、（消費者のカーソル、現在プロデューサカーソルラップ・シーケンス番号と一致する消費者のカーソルラップシーケンス番号に基づいて）ウィンドウサイズはこの接続で今開いていることを確認し、送信を再開します相対位置1000-1499にRDMA書き込みをスケジューリングすることにより、緊急データセグメントの。"
    },
    {
      "indent": 3,
      "text": "4. Host A then sends a CDC message to advance its producer cursor (1500) and to also notify Host B of the Urgent Data Present (UrgA) indicator (and turn off the writer blocked indicator). This signals to Host B that the urgent data is now in the local receive buffer and that the producer cursor points to the last byte of urgent data.",
      "ja": "4.ホストAは、そのプロデューサカーソル（1500）前進し、また、緊急データプレゼント（UrgA）インジケータ（ライタブロックされたインジケータをオフにする）のホストBに通知するCDCメッセージを送信します。この信号は、ローカルバッファと緊急データの最後のバイトまでプロデューサカーソルポイントこと受け取るに緊急データが今であるBをホストします。"
    },
    {
      "indent": 3,
      "text": "5. Host B wakes up, processes the urgent data, and, once the urgent data is consumed, sends a CDC message to update its consumer cursor (1500).",
      "ja": "5.ホストBは、ウェイクアップ緊急データを処理し、そして、緊急データが消費されると、その消費者のカーソル（1500）を更新するCDCメッセージを送信します。"
    },
    {
      "indent": 3,
      "text": "6. Host A wakes up, sees that Host B has consumed the sequence number associated with the urgent data, and then initiates the next RDMA write operation to move the 1000 bytes associated with the next send() of normal data into the peer's receive buffer at position 1500-2499. Note that the send API would have likely completed earlier in the process by copying the 1000 bytes into a send buffer and returning back to the application, even though we could not send any new data until the urgent data was processed and acknowledged by Host B.",
      "ja": "Aは、ウェイクアップ6ホストがホストBは、緊急データに関連付けられたシーケンス番号を消費したことを見て、ピアの受信バッファに通常のデータの次の送信（）に関連付けられた1000のバイトを移動するために、次のRDMA書き込み動作を開始します位置1500-2499で。送信APIの可能性が高い緊急データは、ホストBによって処理され、承認されるまで、我々は、新しいデータを送信できませんでしたにもかかわらず、送信バッファに1000のバイトをコピーして戻ってアプリケーションに戻すことによって、プロセスの早い段階で完了していることに注意してください"
    },
    {
      "indent": 3,
      "text": "7. Host A sends a CDC message to advance its producer cursor to 2500 and to reset the Urgent Data Pending and Urgent Data Present flags. Host B wakes up and processes the inbound data.",
      "ja": "7.ホストA 2500へのプロデューサカーソルを前進させると、緊急データ保留及び緊急データ現在のフラグをリセットするために、CDCメッセージを送信します。ホストBはウェイクアップし、インバウンド・データを処理します。"
    },
    {
      "indent": 0,
      "text": "4.8. Connection Termination",
      "section_title": true,
      "ja": "4.8。接続終了"
    },
    {
      "indent": 3,
      "text": "Just as SMC-R connections are established using a combination of TCP connection establishment flows and SMC-R protocol flows, the termination of SMC-R connections also uses a similar combination of SMC-R protocol termination flows and normal TCP connection termination flows. The following sections describe the SMC-R protocol normal and abnormal connection termination flows.",
      "ja": "SMC-Rの接続がTCP接続確立の流れとSMC-R・プロトコル・フローの組み合わせを使用して確立されているのと同様に、SMC-R接続の終了はまた、SMC-Rプロトコル終端フローの同様の組み合わせを使用し、通常のTCP接続の終了が流れます。以下のセクションでは、正常および異常な接続終了フローSMC-Rプロトコルを記述する。"
    },
    {
      "indent": 0,
      "text": "4.8.1. Normal SMC-R Connection Termination Flows",
      "section_title": true,
      "ja": "4.8.1。通常のSMC-Rの接続の終了フロー"
    },
    {
      "indent": 3,
      "text": "Normal SMC-R connection flows are triggered via the normal stream socket API semantics, namely by the application issuing a close() or shutdown() API. Most applications, after consuming all incoming data and after sending any outbound data, will then issue a close() API to indicate that they are done both sending and receiving data. Some applications, typically a small percentage, make use of the shutdown() API that allows them to indicate that the application is done sending data, receiving data, or both sending and receiving data. The main use of this API is scenarios where a TCP application wants to alert its partner endpoint that it is done sending data but is still receiving data on its socket (shutdown for write). Issuing shutdown() for both sending and receiving data is really no different than issuing a close() and can therefore be treated in a similar fashion. Shutdown for read is typically not a very useful operation and in normal circumstances does not trigger any network flows to notify the partner TCP endpoint of this operation.",
      "ja": "正常なSMC-Rの接続フロー、すなわちクローズ（）またはシャットダウン（）APIを発行するアプリケーションによって、通常のストリームソケットAPIのセマンティックスを介してトリガされます。ほとんどのアプリケーションは、すべての着信データを消費した後、任意のアウトバウンドデータを送信した後、その後、彼らは両方のデータの送受信を行っていることを示すために近い（）APIを発行します。一部のアプリケーション、一般的に小さな割合は、彼らがアプリケーションは、データの送信データを受信、またはその両方の送信とデータを受信完了したことを示すことができますシャットダウン（）APIを利用します。このAPIの主な用途は、TCPアプリケーションがデータを送信して行われているが、まだそのソケット（書き込みのためのシャットダウン時）にデータを受信して​​いるパートナーのエンドポイントを警告したいと考えていたシナリオです。両方の送信およびデータ受信のためのシャットダウン（）を発行すると（クローズを発行するよりも実際に異なっていない）、したがって、同様の方法で処理することができます。読み取りのためのシャットダウンは、典型的には非常に便利な操作ではなく、通常の状況では、この操作のパートナーTCPエンドポイントに通知する任意のネットワーク・フローをトリガしません。"
    },
    {
      "indent": 3,
      "text": "These same trigger points will be used by the SMC-R layer to initiate SMC-R connection termination flows. The main design point for SMC-R normal connection flows is to use the SMC-R protocol to first shut down the SMC-R connection and free up any SMC-R RDMA resources, and then allow the normal TCP connection termination protocol (i.e., FIN processing) to drive cleanup of the TCP connection. This design point is very important in ensuring that RDMA resources such as the RMBEs are only freed and reused when both SMC-R endpoints are completely done with their RDMA write operations to the partner's RMBE.",
      "ja": "これらの同じトリガポイントは、SMC-R接続終了フローを開始するために、SMC-R層で使用されるであろう。 SMC-R通常の接続のための主要な設計ポイントが流れる最初のSMC-Rの接続をシャットダウンするSMC-Rプロトコルを使用し、任意のSMC-RのRDMAリソースを解放し、その後、通常のTCP接続終了プロトコル（すなわち、可能にすることですTCP接続のクリーンアップを駆動するFIN処理）。この設計のポイントは、RMBEsとしてそのRDMAリソースのみを解放し、両方SMC-Rのエンドポイントは、完全に相手のRMBEへのRDMAの書き込み操作で行われたときに再利用されている確保する上で非常に重要です。"
    },
    {
      "indent": 4,
      "text": "                                  1\n                        +-----------------+\n        |-------------->|     CLOSED      |<-------------|\n    3D  |               |                 |              |  4D\n        |               +-----------------+              |\n        |                       |                        |\n        |                     2 |                        |\n        |                       V                        |\n+----------------+     +-----------------+     +----------------+\n|AppFinCloseWait |     |     ACTIVE      |     |PeerFinCloseWait|\n|                |     |                 |     |                |\n+----------------+     +-----------------+     +----------------+\n        |                   |         |                   |\n        |     Active Close  | 3A | 4A |  Passive Close    |\n        |                   V    |    V                   |\n        |       +--------------+ | +-------------+        |\n        |--<----|PeerCloseWait1| | |AppCloseWait1|--->----|\n    3C  |       |              | | |             |        |  4C\n        |       +--------------+ | +-------------+        |\n        |             |          |         |              |\n        |             | 3B       |     4B  |              |\n        |             V          |         V              |\n        |       +--------------+ | +-------------+        |\n        |--<----|PeerCloseWait2| | |AppCloseWait2|--->----|\n                |              | | |             |\n                +--------------+ | +-------------+\n                                 |\n                                 |",
      "raw": true
    },
    {
      "indent": 20,
      "text": "Figure 22: SMC-R Connection States",
      "ja": "図22：SMC-Rの接続状態"
    },
    {
      "indent": 3,
      "text": "Figure 22 describes the states that an SMC-R connection typically goes through. Note that there are variations to these states that can occur when an SMC-R connection is abnormally terminated, similar in a way to when a TCP connection is reset. The following are the high-level state transitions for an SMC-R connection:",
      "ja": "図22は、SMC-R接続は、典型的に通過する状態を記述する。 SMC-Rの接続が異常TCP接続がリセットされたときに道に類似し、終了したときに発生することができ、これらの状態にばらつきがあることに留意されたいです。 SMC-Rの接続のための高レベル状態遷移は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "1. An SMC-R connection begins in the Closed state. This state is meant to reflect an RMBE that is not currently in use (was previously in use but no longer is, or was never allocated).",
      "ja": "1. SMC-Rの接続が閉じた状態で開始されます。この状態は、現在使用されていないRMBEを反映するものである（使用中の以前だったが、もはや、または割り当てられていませんでした）。"
    },
    {
      "indent": 3,
      "text": "2. An SMC-R connection progresses to the Active state once the SMC-R Rendezvous processing has successfully completed, RMB element indices have been exchanged, and SMC-R links have been activated. In this state, the TCP connection is fully established, rendezvous processing has been completed, and SMC-R peers can begin the exchange of data via RDMA.",
      "ja": "SMC-Rランデブー処理が正常に完了した後2 SMC-Rの接続がアクティブ状態に移行し、元のエレメントインデックスが交換されており、SMC-Rリンクが活性化されています。この状態では、TCP接続が完全に確立され、ランデブー処理が完了した、とSMC-RのピアがRDMAを介してデータの交換を開始することができます。"
    },
    {
      "indent": 3,
      "text": "3. Active close processing (on the SMC-R peer that is initiating the connection termination).",
      "ja": "（接続の終了を開始しているSMC-Rピアに）3.アクティブクローズ処理。"
    },
    {
      "indent": 6,
      "text": "A. When an application on one of the SMC-R connection peers issues a close(), a shutdown() for write, or a shutdown() for both read and write, the SMC-R layer on that host will initiate SMC-R connection termination processing. First, if a close() or shutdown(both) is issued, it will check to see that there's no data in the local RMB element that has not been read by the application. If unread data is detected, the SMC-R connection must be abnormally reset; for more details on this, refer to Section 4.8.2 (\"Abnormal SMC-R Connection Termination Flows\"). If no unread data is pending, it then checks to see whether or not any outstanding data is waiting to be written to the peer, or if any outstanding RDMA writes for this SMC-R connection have not yet completed. If either of these two scenarios is true, an indicator that this connection is in a pending close state is saved in internal data structures representing this SMC-R connection, and control is returned to the application. If all data to be written to the partner has completed, this peer will send a CDC message to notify the peer of either the PeerConnectionClosed indicator (close or shutdown for both was issued) or the PeerDoneWriting indicator. This will provide an interrupt to inform that partner SMC-R peer that the connection is terminating. At this point, the local side of the SMC-R connection transitions in the PeerCloseWait1 state, and control can be returned to the application. If this process could not be completed synchronously (the pending close condition mentioned above), it is completed when all RDMA writes for data and control cursors have been completed.",
      "ja": "A. SMC-R接続ピアの1つ上のアプリケーションは、読み取りと書き込みの両方のためのクローズ（）、書き込みのためのシャットダウン（）、またはシャットダウン（）を発行すると、そのホスト上のSMC-R層はSMC-を開始しますR接続終了処理。まず、もし近い（）またはシャットダウン（両方）が発行され、それがアプリケーションによって読み込まれていない地元の人民元の要素にはデータがありませんことを確認します。未読データが検出された場合、SMC-Rの接続が異常リセットされなければなりません。これについての詳細は、第4.8.2項（「異常SMC-R接続終了フロー」）を参照してください。未読データが保留されていない場合、それは、未処理のデータがピアに書き込まれるのを待っているかどうかが調べ、または未処理のRDMAは、このSMC-R接続に書き込みを行う場合には、まだ完了していません。これら2つのシナリオのいずれかに該当する場合、この接続が保留近い状態であることの指標は、このSMC-Rの接続を表す内部データ構造に保存され、制御がアプリケーションに返されます。パートナーに書き込まれるすべてのデータが完了している場合、このピアはPeerConnectionClosedインジケータ（近いまたはその両方のためのシャットダウンが発行された）またはPeerDoneWritingインジケータのいずれかのピアに通知するためにCDCメッセージを送信します。これは、接続が終了しているパートナーSMC-Rのピアに通知するための割り込みを提供します。この時点で、ローカルPeerCloseWait1状態におけるSMC-Rの接続遷移の側、および制御アプリケーションに戻すことができます。このプロセスは、（保留近い条件は、上述の）同期完了できなかった場合はRDMAは、データおよび制御カーソルの書き込みがすべて完了したとき、それが完了しています。"
    },
    {
      "indent": 6,
      "text": "B. At some point, the SMC-R peer application (passive close) will consume all incoming data, realize that that partner is done sending data on this connection, and proceed to initiate its own close of the connection once it has completed sending all data from its end. The partner application can initiate this connection termination processing via close() or shutdown() APIs. If the application does so by issuing a shutdown() for write, then the partner SMC-R layer will send a CDC message to notify the peer (the active close side) of the PeerDoneWriting indicator. When the \"active close\" SMC-R peer wakes up as a result of the previous CDC message, it will notice that the PeerDoneWriting indicator is now on and transition to the PeerCloseWait2 state. This state indicates that the peer is done sending data and may still be reading data. At this point, the \"active close\" peer will also need to ensure that any outstanding recv() calls for this socket are woken up and remember that no more data is forthcoming on this connection (in case the local connection was shutdown() for write only).",
      "ja": "B.いくつかの時点で、SMC-Rピアアプリケーション（受動近い）は、すべての着信データを消費することパートナーが、この接続上でデータを送信して行われることを理解し、それがすべての送信完了した後、接続の独自のクローズを開始するように進行しますその端からのデータ。パートナ・アプリケーションは、クローズ（）またはシャットダウン（）APIを介してこの接続終了処理を開始することができます。アプリケーションが書き込みのためのシャットダウン（）を発行することにより、そうしなければ、その後パートナーSMC-R層がPeerDoneWritingインジケータのピア（アクティブ近い側）に通知するためのCDCメッセージを送信します。 「アクティブクローズ」SMC-Rピアが以前のCDCメッセージの結果として目覚めるとき、それはPeerDoneWritingインジケータが今とPeerCloseWait2状態への遷移であることがわかります。この状態は、ピアがデータを送信して行われ、静止画データを読み出すことができることを示しています。この時点で、「アクティブ近い」ピアはまた、未処理のrecv（）がこのソケットがウェイクアップされているために呼び出すことを確実とするために）（これ以上データがローカル接続がシャットダウンした場合には（この接続に迫っていないことを覚えておく必要があります。 ）のみの書き込み。"
    },
    {
      "indent": 6,
      "text": "C. This flow is a common transition from 3A or 3B above. When the SMC-R peer (passive close) consumes all data and updates all necessary cursors to the peer, and the application closes its socket (close or shutdown for both), it will send a CDC message to the peer (the active close side) with the PeerConnectionClosed indicator set. At this point, the connection can transition back to the Closed state if the local application has already closed (or issued shutdown for both) the socket. Once in the Closed state, the RMBE can now be safely reused for a new SMC-R connection. When the PeerConnectionClosed indicator is turned on, the SMC-R peer is indicating that it is done updating the partner's RMBE.",
      "ja": "C.このフローは上記3A又は3Bから共通の遷移があります。 SMC-Rピア（受動近い）は、すべてのデータを消費し、ピアに必要なすべてのカーソルを更新し、アプリケーションが（両方のためのクローズまたはシャットダウン）ソケットを閉じたとき、それはピア（アクティブ近い側にCDCメッセージを送信します）PeerConnectionClosedインジケータが設定されています。ローカルアプリケーションが既に閉じられて（あるいはその両方のためのシャットダウンを発行）ソケットいる場合は、この時点で、接続がクローズ状態に戻って移行することができます。一度閉じた状態で、RMBEは現在、安全に新しいSMC-Rの接続のために再利用することができます。 PeerConnectionClosedインジケータがオンになると、SMC-Rのピアは、それが相手のRMBEを更新して行われていることを示しています。"
    },
    {
      "indent": 6,
      "text": "D. Conditional state: If the local application has not yet issued a close() or shutdown(both), we need to wait until the application does so. Once it does, the local host will send a CDC message to notify the peer of the PeerConnectionClosed indicator and then transition to the Closed state.",
      "ja": "D.条件付き状態：ローカル・アプリケーションがまだ近い（）またはシャットダウン（両方）を発行していない場合、我々は、アプリケーションがそうするまで待つ必要があります。それがないと、ローカルホストはPeerConnectionClosedインジケータのピアに通知し、その後、閉状態に移行するCDCメッセージを送信します。"
    },
    {
      "indent": 3,
      "text": "4. Passive close processing (on the SMC-R peer that receives an indication that the partner is closing the connection).",
      "ja": "（相手が接続を閉じているという指示を受信するSMC-Rピアに）4.受動クローズ処理。"
    },
    {
      "indent": 6,
      "text": "A. Upon receipt of a CDC message, the SMC-R layer will detect that the PeerConnectionClosed indicator or PeerDoneWriting indicator is on. If any outstanding recv() calls are pending, they are completed with an indicator that the partner has closed the connection (zero-length data presented to the application). If there is any pending data to be written and PeerConnectionClosed is on, then an SMC-R connection reset must be performed. The connection then enters the AppCloseWait1 state on the passive close side waiting for the local application to initiate its own close processing.",
      "ja": "CDCメッセージを受信するとA.、SMC-R層がPeerConnectionClosedインジケータまたはPeerDoneWritingインジケータがオンになっていることを検出します。未処理のrecv（）呼び出しが保留されている場合、それらはパートナーが接続（アプリケーションに提示長さゼロのデータ）を閉鎖したことの指標で完成されています。そこに保留中のデータが書き込まれるとPeerConnectionClosedがオンである場合、SMC-Rの接続リセットが実行されなければなりません。接続は、それ自身のクローズ処理を開始するローカルアプリケーションを待っている受動近い側AppCloseWait1状態に入ります。"
    },
    {
      "indent": 6,
      "text": "B. If the local application issues a shutdown() for writing, then the SMC-R layer will send a CDC message to notify the partner of the PeerDoneWriting indicator and then transition the local side of the SMC-R connection to the AppCloseWait2 state.",
      "ja": "B.ローカルアプリケーションが書き込みのためにシャットダウン（）を発行する場合、SMC-R層がPeerDoneWritingインジケータの相手に通知するために、CDCメッセージを送信した後AppCloseWait2状態へのSMC-Rの接続のローカル側に移行します。"
    },
    {
      "indent": 6,
      "text": "C. When the application issues a close() or shutdown() for both, the local SMC-R peer will send a message informing the peer of the PeerConnectionClosed indicator and transition to the Closed state if the remote peer has also sent the local peer the PeerConnectionClosed indicator. If the peer has not sent the PeerConnectionClosed indicator, we transition into the PeerFinCloseWait state.",
      "ja": "リモートピアは、ローカルピアを送信した場合、アプリケーションがクローズ（）、または両方のためのシャットダウン（）を発行C.は、ローカルSMC-Rピアは閉状態にPeerConnectionClosedインジケータと遷移のピアに通知メッセージを送信しますPeerConnectionClosedインジケータ。ピアがPeerConnectionClosedインジケータを送信していない場合、我々はPeerFinCloseWait状態に移行します。"
    },
    {
      "indent": 6,
      "text": "D. The local SMC-R connection stays in this state until the peer sends the PeerConnectionClosed indicator in a CDC message. When the indicator is sent, we transition to the Closed state and are then free to reuse this RMBE.",
      "ja": "ピアは、CDCメッセージにPeerConnectionClosedインジケータを送信するまでD.ローカルSMC-R接続は、この状態に留まります。インジケータが送信されると、我々はクローズ状態に移行してから、このRMBEを再利用するのは自由です。"
    },
    {
      "indent": 3,
      "text": "Note that each SMC-R peer needs to provide some logic that will prevent being stranded in a termination state indefinitely. For example, if an Active Close SMC-R peer is in a PeerCloseWait (1 or 2) state waiting for the remote SMC-R peer to update its connection termination status, it needs to provide a timer that will prevent it from waiting in that state indefinitely should the remote SMC-R peer not respond to this termination request. This could occur in error scenarios -- for example, if the remote SMC-R peer suffered a failure prior to being able to respond to the termination request or the remote application is not responding to this connection termination request by closing its own socket. This latter scenario is similar to the TCP FINWAIT2 state, which has been known to sometimes cause issues when remote TCP/IP hosts lose track of established connections and neglect to close them. Even though the TCP standards do not mandate a timeout from the TCP FINWAIT2 state, most TCP/IP implementations assign a timeout for this state. A similar timeout will be required for SMC-R connections. When this timeout occurs, the local SMC-R peer performs TCP reset processing for this connection. However, no additional RDMA writes to the partner RMBE can occur at this point (we have already indicated that we are done updating the peer's RMBE). After the TCP connection is reset, the RMBE can be returned to the free pool for reallocation. See Section 4.4.2 for more details.",
      "ja": "各SMC-Rのピアが無期限に停止状態で撚りされなくなり、いくつかのロジックを提供する必要があることに留意されたいです。アクティブ閉じるSMC-Rピアが接続終了ステータスを更新するために、リモートSMC-Rピア待っPeerCloseWait（1又は2）の状態にある場合、例えば、その中で待っているから、それを防止するタイマーを提供する必要があります状態は、無期限に、リモートSMC-Rのピアは、この終了要求に応じるべきではありません。これは、エラーシナリオで発生する可能性 - 例えば、リモートSMC-Rピア前独自のソケットを閉じることにより終了要求またはリモート・アプリケーションがこの接続終了要求に応答していないに応答することができることに障害を受けた場合。この後者のシナリオは、リモートTCP / IPホストがそれらを閉じるために確立された接続と無視のトラックを失ったときに時々問題を引き起こすことが知られているTCP FINWAIT2状態に似ています。 TCP規格はTCP FINWAIT2状態からタイムアウトを強制しませんが、ほとんどのTCP / IPの実装は、この状態のタイムアウトを割り当てます。同様のタイムアウトはSMC-R接続のために必要とされるであろう。このタイムアウトが発生すると、ローカルSMC-Rピアは、この接続のためにTCPリセット処理を行います。しかし、追加のRDMAはRMBEがこの時点で発生する可能性がパートナーに書き込むことはありません（私たちは、すでに私たちは、ピアのRMBE更新して行われていることを示しています）。 TCP接続がリセットされた後、RMBEは再配分のための空きプールに戻すことができます。詳細は、4.4.2項を参照してください。"
    },
    {
      "indent": 3,
      "text": "Also note that it is possible to have two SMC-R endpoints initiate an Active close concurrently. In that scenario, the flows above still apply; however, both endpoints follow the active close path (path 3).",
      "ja": "また、2 SMC-Rのエンドポイントが同時にアクティブクローズを開始させることが可能であることに注意してください。そのシナリオでは、上記フローはまだ適用されます。しかし、両方のエンドポイントがアクティブに近いパス（パス3）に従います。"
    },
    {
      "indent": 0,
      "text": "4.8.2. Abnormal SMC-R Connection Termination Flows",
      "section_title": true,
      "ja": "4.8.2。異常SMC-Rの接続の終了フロー"
    },
    {
      "indent": 3,
      "text": "Abnormal SMC-R connection termination can occur for a variety of reasons, including the following:",
      "ja": "異常なSMC-Rコネクション終端は、以下を含む、さまざまな理由で発生する可能性があります。"
    },
    {
      "indent": 3,
      "text": "o The TCP connection associated with an SMC-R connection is reset. In TCP, either endpoint can send a RST segment to abort an existing TCP connection when error conditions are detected for the connection or the application overtly requests that the connection be reset.",
      "ja": "O SMC-Rの接続に関連するTCP接続がリセットされます。いずれか、TCPエンドポイントはエラー状態を接続または明白接続をリセットすることを要求するアプリケーションのために検出された場合、既存のTCP接続を中止するRSTセグメントを送信することができます。"
    },
    {
      "indent": 3,
      "text": "o Normal SMC-R connection termination processing has unexpectedly stalled for a given connection. When the stall is detected (connection termination timeout condition), an abnormal SMC-R connection termination flow is initiated.",
      "ja": "O正常SMC-R接続終了処理が予期せずに特定の接続のために失速しました。ストールが（接続終了タイムアウト状態）が検出された場合、異常なSMC-R接続終了フローが開始されます。"
    },
    {
      "indent": 3,
      "text": "In these scenarios, it is very important that resources associated with the affected SMC-R connections are properly cleaned up to ensure that there are no orphaned resources and that resources can reliably be reused for new SMC-R connections. Given that SMC-R relies heavily on the RDMA write processing, special care needs to be taken to ensure that an RMBE is no longer being used by an SMC-R peer before logically reassigning that RMBE to a new SMC-R connection.",
      "ja": "これらのシナリオでは、影響を受けたSMC-Rの接続に関連付けられたリソースを適切に何の孤立したリソースが存在しないことを保証するためにクリーンアップされていることと、リソースが確実に新しいSMC-Rの接続のために再利用できることが非常に重要です。 SMC-Rは、RDMA書き込み処理に大きく依存していることを考えると、特別なケアはRMBEがもはや論理的に新しいSMC-Rの接続にそのRMBEを再割り当てする前に、SMC-Rピアで使用されていることを確認しないように注意する必要があります。"
    },
    {
      "indent": 3,
      "text": "When an SMC-R peer initiates a TCP connection reset, it also initiates an SMC-R abnormal connection flow at the same time. The SMC-R peers explicitly signal their intent to abnormally terminate an SMC-R connection and await explicit acknowledgment that the peer has received this notification and has also completed abnormal connection termination on its end. Note that TCP connection reset processing can occur in parallel to these flows.",
      "ja": "SMC-Rピアは、TCP接続のリセットを開始するとき、それはまた同時にSMC-R接続異常フローを開始します。 SMC-Rピアは、明示的異常SMC-Rの接続を終了するために彼らの意図を通知し、ピアがこの通知を受信し、また、その端部に接続異常終了を完了したことを明示的に肯定応答を待ちます。 TCP接続のリセット処理はこれらの流れに平行に起こり得ることに留意されたいです。"
    },
    {
      "indent": 12,
      "text": "                +-----------------+\n|-------------->|     CLOSED      |<-------------|\n|               |                 |              |\n|               +-----------------+              |\n|                                                |\n|                                                |\n|                                                |\n|           +-----------------------+            |\n|           |     Any state         |            |\n|1B         | (before setting       |          2B|\n|           |  PeerConnectionClosed |            |\n|           |  indicator in         |            |\n|           |  peer's RMBE)         |            |\n|           +-----------------------+            |\n|         1A        |         |      2A          |\n|     Active Abort  |         |  Passive Abort   |\n|                   V         V                  |\n|       +--------------+   +--------------+      |\n|-------|PeerAbortWait |   | Process Abort|------|\n        |              |   |              |\n        +--------------+   +--------------+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Figure 23: SMC-R Abnormal Connection Termination State Diagram",
      "ja": "図23：SMC-R接続の異常終了状態図"
    },
    {
      "indent": 3,
      "text": "Figure 23 above shows the SMC-R abnormal connection termination state diagram:",
      "ja": "図23は、上記SMC-R異常接続終了状態図を示しています。"
    },
    {
      "indent": 3,
      "text": "1. Active abort designates the SMC-R peer that is initiating the TCP RST processing. At the time that the TCP RST is sent, the active abort side must also do the following:",
      "ja": "1.アクティブアボートはTCP RST処理を開始しているSMC-Rのピアを指定します。 TCP RSTを送信された時点で、アクティブなアボート側は、次の操作を行う必要があります。"
    },
    {
      "indent": 6,
      "text": "A. Send the PeerConnAbort indicator to the partner in a CDC message, and then transition to the PeerAbortWait state. During this state, it will monitor this SMC-R connection waiting for the peer to send its corresponding PeerConnAbort indicator but will ignore any other activity in this connection (i.e., new incoming data). It will also generate an appropriate error to any socket API calls issued against this socket (e.g., ECONNABORTED, ECONNRESET).",
      "ja": "A.は、CDCメッセージのパートナーにPeerConnAbortインジケータを送信し、その後PeerAbortWait状態に遷移します。この状態の間に、その対応するPeerConnAbortインジケータを送信するピアを待って、このSMC-Rの接続を監視しますが、この接続（すなわち、新しい着信データ）内の任意の他の活動を無視します。また、このソケット（例えば、ECONNABORTED、ECONNRESET）に対して発行されたソケットAPI呼び出しに適切なエラーが発生します。"
    },
    {
      "indent": 6,
      "text": "B. Once the peer sends the PeerConnAbort indicator to the local host, the local host can transition this SMC-R connection to the Closed state and reuse this RMBE. Note that the SMC-R peer that goes into the active abort state must provide some protection against staying in that state indefinitely should the remote SMC-R peer not respond by sending its own PeerConnAbort indicator to the local host. While this should be a rare scenario, it could occur if the remote SMC-R peer (passive abort) suffered a failure right after the local SMC-R peer (active abort) sent the PeerConnAbort indicator. To protect against these types of failures, a timer can be set after entering the PeerAbortWait state, and if that timer pops before the peer has sent its local PeerConnAbort indicator (to the active abort side), this RMBE can be returned to the free pool for possible reallocation. See Section 4.4.2 for more details.",
      "ja": "B.ピアがローカルホストにPeerConnAbortインジケータを送信すると、ローカルホストは、閉状態に、このSMC-Rの接続を移行し、このRMBEを再利用することができます。リモートSMC-Rのピアはローカルホストに独自のPeerConnAbortインジケータを送信することで応答すべきでないアクティブなアボート状態になりSMC-Rのピアが無期限にその状態での滞在に対してある程度の保護を提供しなければならないことに注意してください。これはまれなシナリオであるべきであるが、リモートSMC-Rピア（受動アボート）は右ローカルSMC-Rピア（アクティブ中断）した後に障害を受けPeerConnAbortインジケータを送信した場合、それが起こる可能性があります。このような障害から保護するために、タイマーがPeerAbortWait状態に入った後に設定することができ、かつ、ピアの前にそのタイマーポップ（アクティブアボート側に）そのローカルPeerConnAbortインジケータを送信した場合、このRMBEは空きプールに戻すことができます可能再配分のため。詳細は、4.4.2項を参照してください。"
    },
    {
      "indent": 3,
      "text": "2. Passive abort designates the SMC-R peer that is the recipient of an SMC-R abort from the peer designated by the PeerConnAbort indicator being sent by the peer in a CDC message. Upon receiving this request, the local peer must do the following:",
      "ja": "2.受動アボートは、SMC-Rの受信者は、CDCメッセージにピアによって送信されるPeerConnAbortインジケータによって指定されたピアから中断されるSMC-Rのピアを指定します。この要求を受信すると、ローカルピアは、次の操作を行う必要があります。"
    },
    {
      "indent": 6,
      "text": "A. Using the appropriate error codes, indicate to the socket application that this connection has been aborted, and then purge all in-flight data for this connection that is waiting to be read or waiting to be sent.",
      "ja": "適切なエラー・コードを使用するA.は、この接続が中断され、その後、読まれるのを待っているか、送信されるのを待っているこの接続のために、すべての飛行中のデータをパージされたことをソケットアプリケーションに示しています。"
    },
    {
      "indent": 6,
      "text": "B. Send a CDC message to notify the peer of the PeerConnAbort indicator and, once that is completed, transition this RMBE to the Closed state.",
      "ja": "それが完了すると、B.閉状態への遷移、このRMBEをPeerConnAbortインジケータのピアに通知するCDCメッセージを送信し。"
    },
    {
      "indent": 3,
      "text": "If an SMC-R peer receives a TCP RST for a given SMC-R connection, it also initiates SMC-R abnormal connection termination processing if it has not already been notified (via the PeerConnAbort indicator) that the partner is severing the connection. It is possible to have two SMC-R endpoints concurrently be in an active abort role for a given connection. In that scenario, the flows above still apply but both endpoints take the active abort path (path 1).",
      "ja": "SMC-Rピアが所与のSMC-R接続に対してTCP RSTを受信した場合、既に相手が接続を切断していること（PeerConnAbortインジケータを介して）通知されていない場合、それはまた、SMC-R異常接続終了処理を開始します。 2つのSMC-Rエンドポイントが同時に指定された接続のための活性アボート役割であっても有することが可能です。そのシナリオでは、上記フローは依然として適用するが、両方のエンドポイントがアクティブアボートパス（パス1）を取ります。"
    },
    {
      "indent": 0,
      "text": "4.8.3. Other SMC-R Connection Termination Conditions",
      "section_title": true,
      "ja": "4.8.3。他のSMC-R接続の終了条件"
    },
    {
      "indent": 3,
      "text": "The following are additional conditions that have implications for SMC-R connection termination:",
      "ja": "SMC-Rの接続終了のための意味を持っている追加の条件は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "o An SMC-R peer being gracefully shut down. If an SMC-R peer supports a graceful shutdown operation, it should attempt to terminate all SMC-R connections as part of shutdown processing. This could be accomplished via LLC DELETE LINK requests on all active SMC-R links.",
      "ja": "O SMC-Rピアが正常にシャットダウンされています。 SMC-Rピアが正常な停止動作をサポートしている場合は、シャットダウン処理の一環として、すべてのSMC-Rの接続を終了することを試みるべきです。これは、すべてのアクティブなSMC-RリンクのLINK要求をDELETE LLCを通じて達成することができます。"
    },
    {
      "indent": 3,
      "text": "o Abnormal termination of an SMC-R peer. In this example, there may be no opportunity for the host to perform any SMC-R cleanup processing. In this scenario, it is up to the remote peer to detect a RoCE communications failure with the failing host. This could trigger SMC-R link switchover, but that would also generate RoCE errors, causing the remote host to eventually terminate all existing SMC-R connections to this peer.",
      "ja": "SMC-RピアのO異常終了。この例では、任意のSMC-Rのクリーンアップ処理を実行するホストのための機会が存在しなくてもよいです。このシナリオでは、障害のホストとROCEの通信障害を検出するために、リモートピアまでです。これは、SMC-Rリンクスイッチオーバーをトリガすることができ、それはまた、最終的にこのピアへのすべての既存のSMC-Rの接続を終了するリモートホストを引き起こし、ROCEエラーを生成します。"
    },
    {
      "indent": 3,
      "text": "o Loss of RoCE connectivity between two SMC-R peers. If two peers are no longer reachable across any links in their SMC-R link group, then both peers perform a TCP reset for the connections, generate an error to the local applications, and free up all QP resources associated with the link group.",
      "ja": "2 SMC-Rのピア間ROCE接続のO損失。 2つのピアが自分のSMC-Rリンクグループ内の任意のリンクを介して、もはや到達可能でない場合は、両方のピアが接続のためにTCPリセットを実行し、ローカルアプリケーションにエラーを生成し、リンクグループに関連付けられているすべてのQPリソースを解放。"
    },
    {
      "indent": 0,
      "text": "5. Security Considerations",
      "section_title": true,
      "ja": "5.セキュリティについての考慮事項"
    },
    {
      "indent": 0,
      "text": "5.1. VLAN Considerations",
      "section_title": true,
      "ja": "5.1。 VLANの考慮事項"
    },
    {
      "indent": 3,
      "text": "The concepts and access control of virtual LANs (VLANs) must be extended to also cover the RoCE network traffic flowing across the Ethernet.",
      "ja": "VLAN（仮想LAN）の概念とアクセス制御もイーサネットを流れるROCEのネットワークトラフィックをカバーするように拡張されなければなりません。"
    },
    {
      "indent": 3,
      "text": "The RoCE VLAN configuration and access permissions must mirror the IP VLAN configuration and access permissions over the Converged Enhanced Ethernet fabric. This means that hosts, routers, and switches that have access to specific VLANs on the IP fabric must also have the same VLAN access across the RoCE fabric. In other words, the SMC-R connectivity will follow the same virtual network access permissions as normal TCP/IP traffic.",
      "ja": "ROCE VLANの設定およびアクセス許可は、コンバージドエンハンスドイーサネットファブリック上のIP VLANの設定およびアクセス権限を反映しなければなりません。これは、IPファブリック上の特定のVLANへのアクセス権を持っているホスト、ルータ、およびスイッチもROCEファブリック全体で同じVLANへのアクセスを持たなければならないことを意味します。言い換えれば、SMC-Rの接続は、通常のTCP / IPトラフィックと同じ仮想ネットワークのアクセス許可に従います。"
    },
    {
      "indent": 0,
      "text": "5.2. Firewall Considerations",
      "section_title": true,
      "ja": "5.2。ファイアウォールに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "As mentioned above, the RoCE fabric inherits the same VLAN topology/access as the IP fabric. RoCE is a Layer 2 protocol that requires both endpoints to reside in the same Layer 2 network (i.e., VLAN). RoCE traffic cannot traverse multiple VLANs, as there is no support for routing RoCE traffic beyond a single VLAN. As a result, SMC-R communications will also be confined to peers that are members of the same VLAN. IP-based firewalls are typically inserted between VLANs (or physical LANs) and rely on normal IP routing to insert themselves in the data path. Since RoCE (and by extension SMC-R) is not routable beyond the local VLAN, there is no ability to insert a firewall in the network path of two SMC-R peers.",
      "ja": "上述したように、ROCEファブリックは、IPファブリックと同じVLANトポロジー/アクセス権を継承します。 ROCEは同じレイヤ2ネットワーク（すなわち、VLAN）に存在する両方のエンドポイントが必要とレイヤ2プロトコルです。単一のVLANを超えてROCEトラフィックをルーティングするためのサポートがないようROCEトラフィックは、複数のVLANを通過することはできません。結果として、SMC-R通信はまた、同じVLANのメンバーであるピアに限定されるであろう。 IPベースのファイアウォールは、典型的には、VLANの（または物理LAN）との間に挿入され、データパスに自身を挿入するために、通常のIPルーティングに依存しています。 ROCEは（ひいてはSMC-Rによって）ローカルVLANを超えてルーティング可能ではないので、2 SMC-Rピアのネットワークパスにファイアウォールを挿入する能力はありません。"
    },
    {
      "indent": 0,
      "text": "5.3. Host-Based IP Filters",
      "section_title": true,
      "ja": "5.3。ホストベースのIPフィルタ"
    },
    {
      "indent": 3,
      "text": "Because SMC-R maintains the TCP three-way handshake for connection setup before switching to RoCE out of band, existing IP filters that control connection setup flows remain effective in an SMC-R environment. IP filters that operate on traffic flowing in an active TCP connection are not supported, because the connection data does not flow over IP.",
      "ja": "SMC-Rは、帯域外ROCEに切り替える前に、接続設定のためのTCP 3ウェイハンドシェイクを維持しているため、接続設定の流れを制御する既存のIPフィルタは、SMC-R環境でも有効です。接続データは、IP上で流れていないため、アクティブなTCPコネクションを流れるトラフィックを操作IPフィルタは、サポートされていません。"
    },
    {
      "indent": 0,
      "text": "5.4. Intrusion Detection Services",
      "section_title": true,
      "ja": "5.4。侵入検知サービス"
    },
    {
      "indent": 3,
      "text": "Similar to IP filters, intrusion detection services that operate on TCP connection setups are compatible with SMC-R with no changes required. However, once the TCP connection has switched to RoCE out of band, packets are not available for examination.",
      "ja": "IPフィルタと同様に、TCP接続のセットアップで動作する侵入検知サービスは、必要な変更なしでSMC-Rと互換性があります。 TCP接続は帯域外ROCEに切り替わった後ただし、パケットが検査のため利用できません。"
    },
    {
      "indent": 0,
      "text": "5.5. IP Security (IPsec)",
      "section_title": true,
      "ja": "5.5。 IPセキュリティ（IPSec）"
    },
    {
      "indent": 3,
      "text": "IP security is not compatible with SMC-R, because there are no IP packets on which to operate. TCP connections that require IP security must opt out of SMC-R.",
      "ja": "操作するにはIPパケットが存在しないため、IPセキュリティは、SMC-Rとの互換性はありません。 IPセキュリティを必要とTCP接続はSMC-Rのオプトアウトする必要があります。"
    },
    {
      "indent": 0,
      "text": "5.6. TLS/SSL",
      "section_title": true,
      "ja": "5.6。 TLS / SSL"
    },
    {
      "indent": 3,
      "text": "Transport Layer Security/Secure Socket Layer (TLS/SSL) is preserved in an SMC-R environment. The TLS/SSL layer resides above the SMC-R layer, and outgoing connection data is encrypted before being passed down to the SMC-R layer for RDMA write. Similarly, incoming connection data goes through the SMC-R layer encrypted and is decrypted by the TLS/SSL layer as it is today.",
      "ja": "トランスポートレイヤセキュリティ/セキュア・ソケット・レイヤー（TLS / SSL）は、SMC-R環境に保存されています。 TLS / SSL層は、SMC-R層の上に存在し、発信接続データは、RDMA書き込み用SMC-R層に渡される前に暗号化されます。同様に、着信接続のデータが暗号化され、それが今日のようTLS / SSL層によって復号化されたSMC-R層を通過します。"
    },
    {
      "indent": 3,
      "text": "The TLS/SSL handshake messages flow over the TCP connection after the connection has switched to SMC-R, and so they are exchanged using RDMA writes by the SMC-R layer, transparently to the TLS/SSL layer.",
      "ja": "接続はSMC-Rに切り替わった、そしてので、彼らは、RDMAを使用して交換された後、TLS / SSLハンドシェイクメッセージは、TCP接続上を流れ、透過的TLS / SSL層に、SMC-R層で書き込みます。"
    },
    {
      "indent": 0,
      "text": "6. IANA Considerations",
      "section_title": true,
      "ja": "6. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "The scarcity of TCP option codes available for assignment is understood, and this architecture uses experimental TCP options following the conventions of [RFC6994] (\"Shared Use of Experimental TCP Options\").",
      "ja": "割り当て可能なTCPオプションコードの不足を理解し、このアーキテクチャは、[RFC6994]（「実験TCPオプションの共同利用」）の規則を以下の実験TCPオプションを使用します。"
    },
    {
      "indent": 3,
      "text": "TCP ExID 0xE2D4C3D9 has been registered with IANA as a TCP Experiment Identifier. See Section 3.1.",
      "ja": "TCP EXID 0xE2D4C3D9は、TCP実験識別子としてIANAに登録されています。 3.1節を参照してください。"
    },
    {
      "indent": 3,
      "text": "If this protocol achieves wide acceptance, a discrete option code may be requested by subsequent versions of this protocol.",
      "ja": "このプロトコルは、広く受け入れを達成する場合、別個のオプションコードは、このプロトコルの後続バージョンによって要求されてもよいです。"
    },
    {
      "indent": 0,
      "text": "7. Normative References",
      "section_title": true,
      "ja": "7.引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC793] Postel, J., \"Transmission Control Protocol\", STD 7, RFC 793, DOI 10.17487/RFC0793, September 1981, <http://www.rfc-editor.org/info/rfc793>.",
      "ja": "[RFC793]ポステル、J.、 \"伝送制御プロトコル\"、STD 7、RFC 793、DOI 10.17487 / RFC0793、1981年9月、<http://www.rfc-editor.org/info/rfc793>。"
    },
    {
      "indent": 3,
      "text": "[RFC6994] Touch, J., \"Shared Use of Experimental TCP Options\", RFC 6994, DOI 10.17487/RFC6994, August 2013, <http://www.rfc-editor.org/info/rfc6994>.",
      "ja": "[RFC6994]タッチ、J.、 \"実験TCPオプションの共同利用\"、RFC 6994、DOI 10.17487 / RFC6994、2013年8月、<http://www.rfc-editor.org/info/rfc6994>。"
    },
    {
      "indent": 3,
      "text": "[RoCE] InfiniBand, \"RDMA over Converged Ethernet specification\", <https://cw.infinibandta.org/wg/Members/documentRevision/ download/7149>.",
      "ja": "[ROCE]インフィニバンド、 \"RDMAコンバージドオーバーイーサネット仕様\"、<https://cw.infinibandta.org/wg/Members/documentRevision/ダウンロード/ 7149>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Formats",
      "ja": "付録A.フォーマット"
    },
    {
      "indent": 0,
      "text": "A.1. TCP Option",
      "ja": "A.1。 TCPオプション"
    },
    {
      "indent": 3,
      "text": "The SMC-R TCP option is formatted in accordance with [RFC6994] (\"Shared Use of Experimental TCP Options\"). The ExID value is IBM-1047 (EBCDIC) encoding for \"SMCR\".",
      "ja": "SMC-R TCPオプションは、[RFC6994]（「実験TCPオプションの共同利用」）に従ってフォーマットされます。 EXID値は \"SMCR\" のIBM-1047（EBCDIC）符号化です。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Kind = 254  | Length = 6    |   x'E2'       |   x'D4'       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|    x'C3'      |    x'D9'      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 20,
      "text": "Figure 24: SMC-R TCP Option Format",
      "ja": "図24：SMC-R TCPオプションフォーマット"
    },
    {
      "indent": 0,
      "text": "A.2. CLC Messages",
      "ja": "A.2。 CLCメッセージ"
    },
    {
      "indent": 3,
      "text": "The following rules apply to all CLC messages:",
      "ja": "次の規則は、すべてのCLCのメッセージに適用されます。"
    },
    {
      "indent": 3,
      "text": "General rules on formats:",
      "ja": "形式上の一般的なルール："
    },
    {
      "indent": 3,
      "text": "o Reserved fields must be set to zero and not validated.",
      "ja": "O予約フィールドはゼロに設定し、検証されませんする必要があります。"
    },
    {
      "indent": 3,
      "text": "o Each message has an eye catcher at the start and another eye catcher at the end. These must both be validated by the receiver.",
      "ja": "Oの各メッセージは、開始時のアイキャッチャーと端で別のアイキャッチャを有します。これらは、両方の受信機によって検証されなければなりません。"
    },
    {
      "indent": 3,
      "text": "o SMC version indicator: The only SMC-R version defined in this architecture is version 1. In the future, if peers have a mismatch of versions, the lowest common version number is used.",
      "ja": "O SMCバージョンインジケータ：このアーキテクチャで定義された唯一のSMC-Rバージョンがピアがバージョンの不一致がある場合、最も低い共通のバージョン番号が使用され、今後のバージョン1です。"
    },
    {
      "indent": 0,
      "text": "A.2.1. Peer ID Format",
      "ja": "A.2.1。ピアIDのフォーマット"
    },
    {
      "indent": 3,
      "text": "All CLC messages contain a peer ID that uniquely identifies an instance of a TCP/IP stack. This peer ID is required to be universally unique across TCP/IP stacks and instances (including restarts) of TCP/IP stacks.",
      "ja": "全てCLCメッセージを一意にTCP / IPスタックのインスタンスを識別するピアIDを含みます。このピアIDは、TCP / IPスタックとTCP / IPスタックの（再起動を含む）インスタンス間で普遍的に一意であることが要求されます。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Instance ID          |    RoCE MAC (first 2 bytes)   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                    RoCE MAC (last 4 bytes)                    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 25,
      "text": "Figure 25: Peer ID Format",
      "ja": "図25：ピアIDのフォーマット"
    },
    {
      "indent": 3,
      "text": "Instance ID",
      "ja": "インスタンスID"
    },
    {
      "indent": 6,
      "text": "A 2-byte instance count that ensures that if the same RNIC MAC is later used in the peer ID for a different TCP/IP stack -- for example, if an RNIC is redeployed to another stack -- the values are unique. It also ensures that if a TCP/IP stack is restarted, the instance ID changes. The value is implementation defined, with one suggestion being 2 bytes of the system clock.",
      "ja": "例えば、RNICは、別のスタックに再配置されている場合 -   - 値が一意で同じRNIC MACが後で別のTCP / IPスタックのピアIDで使用される場合ことを確実にする2バイトのインスタンス数。また、確実にTCP / IPスタックが再起動された場合、インスタンスIDの変更。値は、一の実施の提案は、システムクロックの2バイトであると、定義されています。"
    },
    {
      "indent": 3,
      "text": "RoCE MAC",
      "ja": "MAC年"
    },
    {
      "indent": 6,
      "text": "The RoCE MAC address for one of the peer's RNICs. Note that in a virtualized environment this will be the virtual MAC of one of the peer's RNICs.",
      "ja": "ピアのRNICsの1のためのROCE MACアドレス。仮想化環境では、これはピアのRNICsの1の仮想MACになることに注意してください。"
    },
    {
      "indent": 0,
      "text": "A.2.2. SMC Proposal CLC Message Format",
      "ja": "A.2.2。 SMC提案CLCメッセージ形式"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   x'E2'       |   x'D4'       |     x'C3'     |     x'D9'     |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Type = 1     |           Length              |Version| Rsrvd |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n+-                       Client's Peer ID                      -+\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n+-                                                             -+\n|                                                               |\n+-                Client's preferred GID                       -+\n|                                                               |\n+-                                                             -+\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Client's preferred RoCE                                      |\n+- MAC address                  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                               |Offset to mask/prefix area (0) |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n.                                                               .\n.                  Area for future growth                       .\n.                                                               .\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                         IPv4 Subnet Mask                      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| IPv4 Mask Lgth|           Reserved            |Num IPv6 prfx  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n:                                                               :\n:           Array of IPv6 prefixes (variable length)            :\n:                                                               :\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   x'E2'       |   x'D4'       |     x'C3'     |     x'D9'     |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 16,
      "text": "Figure 26: SMC Proposal CLC Message Format",
      "ja": "図26：SMC提案CLCメッセージ形式"
    },
    {
      "indent": 3,
      "text": "The fields present in the SMC Proposal CLC message are:",
      "ja": "SMC提案CLCメッセージに存在フィールドは、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Eye catchers",
      "ja": "アイキャッチャー"
    },
    {
      "indent": 6,
      "text": "Like all CLC messages, the SMC Proposal has beginning and ending eye catchers to aid with verification and parsing. The hex digits spell \"SMCR\" in IBM-1047 (EBCDIC).",
      "ja": "すべてのCLCのメッセージと同様に、SMCの提案は、検証と解析を支援するために、目のキャッチャーを開始し、終了しました。進数字は、IBM-1047（EBCDIC）に \"SMCR\" を綴ります。"
    },
    {
      "indent": 3,
      "text": "Type",
      "ja": "タイプ"
    },
    {
      "indent": 6,
      "text": "CLC message Type 1 indicates SMC Proposal.",
      "ja": "CLCメッセージタイプ1は、SMCの提案を示します。"
    },
    {
      "indent": 3,
      "text": "Length",
      "ja": "長さ"
    },
    {
      "indent": 6,
      "text": "The length of this CLC message. If this is an IPv4 flow, this value is 52. Otherwise, it is variable, depending upon how many prefixes are listed.",
      "ja": "このCLCメッセージの長さ。これは、IPv4フローである場合、この値は、それが記載されているどのように多くのプレフィックスに応じて、可変であり、そうでなければ52です。"
    },
    {
      "indent": 3,
      "text": "Version",
      "ja": "版"
    },
    {
      "indent": 6,
      "text": "Version of the SMC-R protocol. Version 1 is the only currently defined value.",
      "ja": "SMC-Rプロトコルのバージョン。バージョン1のみ、現在定義された値です。"
    },
    {
      "indent": 3,
      "text": "Client's Peer ID",
      "ja": "クライアントのピアID"
    },
    {
      "indent": 6,
      "text": "As described in Appendix A.2.1 above.",
      "ja": "上記の付録A.2.1で説明したように。"
    },
    {
      "indent": 3,
      "text": "Client's preferred RoCE GID",
      "ja": "クライアントの希望する米GIF"
    },
    {
      "indent": 6,
      "text": "The IPv6 address of the client's preferred RNIC on the RoCE fabric.",
      "ja": "ROCEファブリック上のクライアントの希望するRNICのIPv6アドレス。"
    },
    {
      "indent": 3,
      "text": "Client's preferred RoCE MAC address",
      "ja": "クライアントの優先ROCE MACアドレス"
    },
    {
      "indent": 6,
      "text": "The MAC address of the client's preferred RNIC on the RoCE fabric. It is required, as some operating systems do not have neighbor discovery or ARP support for RoCE RNICs.",
      "ja": "ROCEファブリック上のクライアントの希望するRNICのMACアドレス。一部のオペレーティングシステムは、ROCE RNICsのための近隣探索やARPをサポートしていないとしてそれは、必要とされます。"
    },
    {
      "indent": 3,
      "text": "Offset to mask/prefix area",
      "ja": "/プレフィックスエリアをマスクするオフセット"
    },
    {
      "indent": 6,
      "text": "Provides the number of bytes that must be skipped after this field, to access the IPv4 Subnet Mask field and the fields that follow it. Allows for future growth of this signal. In this version of the architecture, this value is always zero.",
      "ja": "IPv4のサブネットマスクフィールドと、それに続くフィールドにアクセスするには、このフィールドの後にスキップしなければならないバイト数を提供します。この信号の将来の成長を可能にします。アーキテクチャのこのバージョンでは、この値は常にゼロです。"
    },
    {
      "indent": 3,
      "text": "Area for future growth",
      "ja": "将来の成長のためのエリア"
    },
    {
      "indent": 6,
      "text": "In this version of the architecture, this field does not exist. This indicates where additional information may be inserted into the signal in the future. The \"Offset to mask/prefix area\" field must be used to skip over this area.",
      "ja": "アーキテクチャのこのバージョンでは、このフィールドは存在しません。追加情報は、将来の信号に挿入することができる場合、これは示しています。 「/プレフィックスエリアをマスクするオフセット」フィールドは、このエリアをスキップするために使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "IPv4 Subnet Mask",
      "ja": "IPv4のサブネットマスク"
    },
    {
      "indent": 6,
      "text": "If this message is flowing over an IPv4 TCP connection, the value of the subnet mask associated with the interface over which the client sent this message. If this is an IPv6 flow, this field is all zeros.",
      "ja": "このメッセージは、IPv4のTCP接続を介して流れている場合、サブネットマスクの値は、クライアントがこのメッセージを送信した上インタフェースに関連付けられました。これはIPv6のフローがある場合は、このフィールドはすべてゼロです。"
    },
    {
      "indent": 6,
      "text": "This field, along with all fields that follow it in this signal, must be accessed by skipping the number of bytes listed in the \"Offset to mask/prefix area\" field after the end of that field.",
      "ja": "このフィールドは、この信号にそれに続くすべてのフィールドと一緒に、そのフィールドの終了後フィールド「/プレフィックス領域をマスクするオフセット」に記載されているバイトの数をスキップすることによってアクセスされなければなりません。"
    },
    {
      "indent": 3,
      "text": "IPv4 Mask Lgth",
      "ja": "IPv4のマスク長"
    },
    {
      "indent": 6,
      "text": "If this message is flowing over an IPv4 TCP connection, the number of significant bits in the IPv4 Subnet Mask field. If this is an IPv6 flow, this field is zero.",
      "ja": "このメッセージは、IPv4のTCP接続を介して流れている場合、IPv4のサブネット内の有効ビット数は、フィールドマスク。これはIPv6のフローがある場合は、このフィールドはゼロです。"
    },
    {
      "indent": 3,
      "text": "Num IPv6 prfx",
      "ja": "IPv6のprfxで"
    },
    {
      "indent": 6,
      "text": "If this message is flowing over an IPv6 TCP connection, the number of IPv6 prefixes that follow, with a maximum value of 8. If this is an IPv4 flow, this field is zero and is immediately followed by the ending eye catcher.",
      "ja": "このメッセージは、IPv6 TCP接続を介して流れている場合、これはIPv4のフローである場合8の最大値と、追従IPv6プレフィックスの数は、このフィールドはゼロであり、直ちに終了アイキャッチャが続きます。"
    },
    {
      "indent": 3,
      "text": "Array of IPv6 prefixes",
      "ja": "IPv6プレフィックスの配列"
    },
    {
      "indent": 6,
      "text": "For IPv6 TCP connections, a list of the IPv6 prefixes associated with the network over which the client sent this message, up to a maximum of eight prefixes.",
      "ja": "IPv6のTCP接続、クライアントは8つのプレフィックスの最大値まで、このメッセージを送信した上でネットワークに関連付けられているIPv6プレフィックスのリストについて。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n+                                                               +\n|                                                               |\n+                  IPv6 prefix value                            +\n|                                                               |\n+                                                               +\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Prefix Length |\n+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 14,
      "text": "Figure 27: Format for IPv6 Prefix Array Element",
      "ja": "図27：IPv6のプレフィックスの配列要素のためのフォーマット"
    },
    {
      "indent": 0,
      "text": "A.2.3. SMC Accept CLC Message Format",
      "ja": "A.2.3。 SMC CLCメッセージ形式を受け入れます"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   x'E2'       |   x'D4'       |     x'C3'     |     x'D9'     |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Type = 2     |    Length = 68                |Version|F|Rsrvd|\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n+-                       Server's Peer ID                      -+\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n+-                                                             -+\n|                                                               |\n+-                Server's RoCE GID                            -+\n|                                                               |\n+-                                                             -+\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Server's RoCE                                                |\n+- MAC address                  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                               |     Server QP (bytes 1-2)     |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+---+\n|Srvr QP byte 3 |         Server RMB RKey (bytes 1-3)           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|Srvr RMB byte 4|Server RMB indx| Srvr RMB alert tkn (bytes 1-2)|\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Srvr RMB alert tkn (bytes 3-4)|Bsize  | MTU   |   Reserved    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n+-                     Server's RMB virtual address            -+\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Reserved      |    Server's initial packet sequence number    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   x'E2'       |   x'D4'       |     x'C3'     |     x'D9'     |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 17,
      "text": "Figure 28: SMC Accept CLC Message Format",
      "ja": "図28：SMC CLCメッセージの形式を受け入れます"
    },
    {
      "indent": 3,
      "text": "The fields present in the SMC Accept CLC message are:",
      "ja": "CLCメッセージを受け入れSMCに存在するフィールドは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Eye catchers",
      "ja": "アイキャッチャー"
    },
    {
      "indent": 6,
      "text": "Like all CLC messages, the SMC Accept has beginning and ending eye catchers to aid with verification and parsing. The hex digits spell \"SMCR\" in IBM-1047 (EBCDIC).",
      "ja": "すべてのCLCのメッセージのように、SMCは受け入れは、検証と解析を支援するために、目のキャッチャーを開始し、終了しました。進数字は、IBM-1047（EBCDIC）に \"SMCR\" を綴ります。"
    },
    {
      "indent": 3,
      "text": "Type",
      "ja": "タイプ"
    },
    {
      "indent": 6,
      "text": "CLC message Type 2 indicates SMC Accept.",
      "ja": "CLCメッセージタイプ2は、SMCが受け入れを示しています。"
    },
    {
      "indent": 3,
      "text": "Length",
      "ja": "長さ"
    },
    {
      "indent": 6,
      "text": "The SMC Accept CLC message is 68 bytes long.",
      "ja": "SMC CLCメッセージを受け入れるには、68バイト長です。"
    },
    {
      "indent": 3,
      "text": "Version",
      "ja": "版"
    },
    {
      "indent": 6,
      "text": "Version of the SMC-R protocol. Version 1 is the only currently defined value.",
      "ja": "SMC-Rプロトコルのバージョン。バージョン1のみ、現在定義された値です。"
    },
    {
      "indent": 3,
      "text": "F-bit",
      "ja": "F-ビット"
    },
    {
      "indent": 6,
      "text": "First contact flag: A 1-bit flag that indicates that the server believes this TCP connection is the first SMC-R contact for this link group.",
      "ja": "最初の接触フラグ：サーバは、このTCP接続がこのリンクグループの最初のSMC-Rの接点であると考えていることを示す1ビットのフラグ。"
    },
    {
      "indent": 3,
      "text": "Server's Peer ID",
      "ja": "サーバーのピアID"
    },
    {
      "indent": 6,
      "text": "As described in Appendix A.2.1 above.",
      "ja": "上記の付録A.2.1で説明したように。"
    },
    {
      "indent": 3,
      "text": "Server's RoCE GID",
      "ja": "サーバーのGID年"
    },
    {
      "indent": 6,
      "text": "The IPv6 address of the RNIC that the server chose for this SMC-R link.",
      "ja": "サーバは、このSMC-Rのリンクのために選択したRNICのIPv6アドレス。"
    },
    {
      "indent": 3,
      "text": "Server's RoCE MAC address",
      "ja": "サーバーのROCE MACアドレス"
    },
    {
      "indent": 6,
      "text": "The MAC address of the server's RNIC for the SMC-R link. It is required, as some operating systems do not have neighbor discovery or ARP support for RoCE RNICs.",
      "ja": "SMC-RリンクのサーバーのRNICのMACアドレス。一部のオペレーティングシステムは、ROCE RNICsのための近隣探索やARPをサポートしていないとしてそれは、必要とされます。"
    },
    {
      "indent": 3,
      "text": "Server's QP number",
      "ja": "サーバーのQP番号"
    },
    {
      "indent": 6,
      "text": "The number for the reliably connected queue pair that the server created for this SMC-R link.",
      "ja": "サーバは、このSMC-Rのリンク用に作成されたことを確実に接続されているキュー・ペアの番号。"
    },
    {
      "indent": 3,
      "text": "Server's RMB RKey",
      "ja": "サーバーの人民元RKEY"
    },
    {
      "indent": 6,
      "text": "The RDMA RKey for the RMB that the server created or chose for this TCP connection.",
      "ja": "サーバーが作成またはこのTCP接続のために選択した人民元のためのRDMA RKEY。"
    },
    {
      "indent": 3,
      "text": "Server's RMB element index",
      "ja": "サーバーの人民元の要素のインデックス"
    },
    {
      "indent": 6,
      "text": "Indexes which element within the server's RMB will represent this TCP connection.",
      "ja": "サーバーの人民元内のどの要素のインデックスは、このTCPコネクションを表します。"
    },
    {
      "indent": 3,
      "text": "Server's RMB element alert token",
      "ja": "サーバーの人民元要素のアラートトークン"
    },
    {
      "indent": 6,
      "text": "A platform-defined, architecturally opaque token that identifies this TCP connection. Added by the client as immediate data on RDMA writes from the client to the server to inform the server that there is data for this connection to retrieve from the RMB element.",
      "ja": "このTCP接続を特定のプラットフォームに定義された、アーキテクチャ不透明トークン。 RDMA上の即時データとしてクライアントによって追加は、人民元の要素から取得するには、この接続のためのデータがあることをサーバーに通知するために、クライアントからサーバーに書き込みます。"
    },
    {
      "indent": 3,
      "text": "Bsize:",
      "ja": "BSIZE："
    },
    {
      "indent": 6,
      "text": "Server's RMB element buffer size in 4-bit compressed notation: x = 4 bits. Actual buffer size value is (2^(x + 4)) * 1K. Smallest possible value is 16K. Largest size supported by this architecture is 512K.",
      "ja": "4ビットの圧縮された表記で、サーバの元の要素のバッファサイズ：X = 4ビット。実際のバッファサイズ値は、（2 ^（X + 4））* 1Kです。可能な最小値は16Kです。このアーキテクチャでサポートされている最大のサイズは512Kです。"
    },
    {
      "indent": 3,
      "text": "MTU",
      "ja": "MTU"
    },
    {
      "indent": 6,
      "text": "An enumerated value indicating this peer's QP MTU size. The two peers exchange their MTU values, and whichever value is smaller will be used for the QP. This field should only be validated in the first contact exchange.",
      "ja": "このピアのQP MTUサイズを示す列挙値。 2つのピアがそのMTU値を交換し、どちらの値がQPのために小さい使用されるています。このフィールドは、最初のコンタクト交換で検証する必要があります。"
    },
    {
      "indent": 6,
      "text": "The enumerated MTU values are:",
      "ja": "列挙されたMTU値は次のとおりです。"
    },
    {
      "indent": 9,
      "text": "0: reserved",
      "ja": "0：予約済み"
    },
    {
      "indent": 9,
      "text": "1: 256",
      "ja": "１： ２５６"
    },
    {
      "indent": 9,
      "text": "2: 512",
      "ja": "２： ５１２"
    },
    {
      "indent": 9,
      "text": "3: 1024",
      "ja": "３： １０２４"
    },
    {
      "indent": 9,
      "text": "4: 2048",
      "ja": "４： ２０４８"
    },
    {
      "indent": 9,
      "text": "5: 4096",
      "ja": "５： ４０９６"
    },
    {
      "indent": 9,
      "text": "6-15: reserved",
      "ja": "6-15：予約済み"
    },
    {
      "indent": 3,
      "text": "Server's RMB virtual address",
      "ja": "サーバーの人民元の仮想アドレス"
    },
    {
      "indent": 6,
      "text": "The virtual address of the server's RMB as assigned by the server's RNIC.",
      "ja": "サーバのRNICによって割り当てられたサーバーの人民元の仮想アドレス。"
    },
    {
      "indent": 3,
      "text": "Server's initial packet sequence number",
      "ja": "サーバーの初期パケットシーケンス番号"
    },
    {
      "indent": 6,
      "text": "The starting packet sequence number that this peer will use when sending to the other peer, so that the other peer can prepare its QP for the sequence number to expect.",
      "ja": "他のピアに送信するときに他のピアが期待するシーケンス番号のためにQPを準備できるように、このピアが、使用することを開始パケットのシーケンス番号。"
    },
    {
      "indent": 0,
      "text": "A.2.4. SMC Confirm CLC Message Format",
      "ja": "A.2.4。 SMC CLCメッセージフォーマットを確認してください"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   x'E2'       |   x'D4'       |     x'C3'     |     x'D9'     |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Type = 3     |    Length = 68                |Version| Rsrvd |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n+-                       Client's Peer ID                      -+\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n+-                                                             -+\n|                                                               |\n+-                Client's RoCE GID                            -+\n|                                                               |\n+-                                                             -+\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Client's RoCE                                                |\n+- MAC address                  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                               |     Client QP (bytes 1-2)     |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+---+\n|Clnt QP byte 3 |         Client RMB RKey (bytes 1-3)           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|Clnt RMB byte 4|Client RMB indx| Clnt RMB alert tkn (bytes 1-2)|\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Clnt RMB alert tkn (bytes 3-4)|Bsize  | MTU   |   Reserved    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n+-                  Client's RMB Virtual Address               -+\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Reserved      |    Client's initial packet sequence number    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   x'E2'       |   x'D4'       |     x'C3'     |     x'D9'     |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 17,
      "text": "Figure 29: SMC Confirm CLC Message Format",
      "ja": "図29：SMC CLCメッセージの形式を確認してください"
    },
    {
      "indent": 3,
      "text": "The SMC Confirm CLC message is nearly identical to the SMC Accept, except that it contains client information and lacks a first contact flag.",
      "ja": "SMCは、CLCメッセージを確認し、それが顧客情報が含まれており、第一のコンタクトフラグを欠いていることを除いて、受け入れSMCとほぼ同じです。"
    },
    {
      "indent": 3,
      "text": "The fields present in the SMC Confirm CLC message are:",
      "ja": "CLCメッセージを確認してSMCに存在するフィールドは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Eye catchers",
      "ja": "アイキャッチャー"
    },
    {
      "indent": 6,
      "text": "Like all CLC messages, the SMC Confirm has beginning and ending eye catchers to aid with verification and parsing. The hex digits spell \"SMCR\" in IBM-1047 (EBCDIC).",
      "ja": "すべてのCLCのメッセージと同様に、SMCの確認は、検証と解析を支援するために、目のキャッチャーを開始し、終了しました。進数字は、IBM-1047（EBCDIC）に \"SMCR\" を綴ります。"
    },
    {
      "indent": 3,
      "text": "Type",
      "ja": "タイプ"
    },
    {
      "indent": 6,
      "text": "CLC message Type 3 indicates SMC Confirm.",
      "ja": "CLCメッセージタイプ3は、SMCの確認を示します。"
    },
    {
      "indent": 3,
      "text": "Length",
      "ja": "長さ"
    },
    {
      "indent": 6,
      "text": "The SMC Confirm CLC message is 68 bytes long.",
      "ja": "SMCは、CLCメッセージを確認して68バイト長です。"
    },
    {
      "indent": 3,
      "text": "Version",
      "ja": "版"
    },
    {
      "indent": 6,
      "text": "Version of the SMC-R protocol. Version 1 is the only currently defined value.",
      "ja": "SMC-Rプロトコルのバージョン。バージョン1のみ、現在定義された値です。"
    },
    {
      "indent": 3,
      "text": "Client's Peer ID",
      "ja": "クライアントのピアID"
    },
    {
      "indent": 6,
      "text": "As described in Appendix A.2.1 above.",
      "ja": "上記の付録A.2.1で説明したように。"
    },
    {
      "indent": 3,
      "text": "Client's RoCE GID",
      "ja": "クライアントのGID年"
    },
    {
      "indent": 6,
      "text": "The IPv6 address of the RNIC that the client chose for this SMC-R link.",
      "ja": "クライアントは、このSMC-Rのリンクのために選択したRNICのIPv6アドレス。"
    },
    {
      "indent": 3,
      "text": "Client's RoCE MAC address",
      "ja": "クライアントのROCE MACアドレス"
    },
    {
      "indent": 6,
      "text": "The MAC address of the client's RNIC for the SMC-R link. It is required, as some operating systems do not have neighbor discovery or ARP support for RoCE RNICs.",
      "ja": "SMC-Rリンク用クライアントのRNICのMACアドレス。一部のオペレーティングシステムは、ROCE RNICsのための近隣探索やARPをサポートしていないとしてそれは、必要とされます。"
    },
    {
      "indent": 3,
      "text": "Client's QP number",
      "ja": "クライアントのQP番号"
    },
    {
      "indent": 6,
      "text": "The number for the reliably connected queue pair that the client created for this SMC-R link.",
      "ja": "クライアントは、このSMC-Rのリンク用に作成されたことを確実に接続されているキュー・ペアの番号。"
    },
    {
      "indent": 3,
      "text": "Client's RMB RKey",
      "ja": "クライアントの人民元RKEY"
    },
    {
      "indent": 6,
      "text": "The RDMA RKey for the RMB that the client created or chose for this TCP connection.",
      "ja": "クライアントが作成したか、このTCP接続のために選択した人民元のためのRDMA RKEY。"
    },
    {
      "indent": 3,
      "text": "Client's RMB element index",
      "ja": "クライアントの人民元の要素のインデックス"
    },
    {
      "indent": 6,
      "text": "Indexes which element within the client's RMB will represent this TCP connection.",
      "ja": "クライアントの人民元内のどの要素のインデックスは、このTCPコネクションを表します。"
    },
    {
      "indent": 3,
      "text": "Client's RMB element alert token",
      "ja": "クライアントの人民元要素のアラートトークン"
    },
    {
      "indent": 6,
      "text": "A platform-defined, architecturally opaque token that identifies this TCP connection. Added by the server as immediate data on RDMA writes from the server to the client to inform the client that there is data for this connection to retrieve from the RMB element.",
      "ja": "このTCP接続を特定のプラットフォームに定義された、アーキテクチャ不透明トークン。 RDMA上の即時データとしてサーバーによって追加は、人民元の要素から取得するには、この接続のためのデータがあることをクライアントに通知するために、サーバからクライアントに書き込みます。"
    },
    {
      "indent": 3,
      "text": "Bsize:",
      "ja": "BSIZE："
    },
    {
      "indent": 6,
      "text": "Client's RMB element buffer size in 4-bit compressed notation: x = 4 bits. Actual buffer size value is (2^(x + 4)) * 1K. Smallest possible value is 16K. Largest size supported by this architecture is 512K.",
      "ja": "4ビットの圧縮された表記のクライアントの元の要素のバッファサイズ：X = 4ビット。実際のバッファサイズ値は、（2 ^（X + 4））* 1Kです。可能な最小値は16Kです。このアーキテクチャでサポートされている最大のサイズは512Kです。"
    },
    {
      "indent": 3,
      "text": "MTU",
      "ja": "MTU"
    },
    {
      "indent": 6,
      "text": "An enumerated value indicating this peer's QP MTU size. The two peers exchange their MTU values, and whichever value is smaller will be used for the QP. The values are enumerated in Appendix A.2.3. This value should only be validated in the first contact exchange.",
      "ja": "このピアのQP MTUサイズを示す列挙値。 2つのピアがそのMTU値を交換し、どちらの値がQPのために小さい使用されるています。値は、付録A.2.3に列挙されています。この値は、最初の接触交換して検証する必要があります。"
    },
    {
      "indent": 3,
      "text": "Client's RMB Virtual Address",
      "ja": "クライアントの元仮想アドレス"
    },
    {
      "indent": 6,
      "text": "The virtual address of the client's RMB as assigned by the server's RNIC.",
      "ja": "サーバのRNICによって割り当てられる、クライアントの元の仮想アドレス。"
    },
    {
      "indent": 3,
      "text": "Client's initial packet sequence number",
      "ja": "クライアントの初期のパケットシーケンス番号"
    },
    {
      "indent": 6,
      "text": "The starting packet sequence number that this peer will use when sending to the other peer, so that the other peer can prepare its QP for the sequence number to expect.",
      "ja": "他のピアに送信するときに他のピアが期待するシーケンス番号のためにQPを準備できるように、このピアが、使用することを開始パケットのシーケンス番号。"
    },
    {
      "indent": 0,
      "text": "A.2.5. SMC Decline CLC Message Format",
      "ja": "A.2.5。 SMC CLCメッセージフォーマットを辞退"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   x'E2'       |   x'D4'       |     x'C3'     |     x'D9'     |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Type = 4     |    Length = 28                |Version|S|Rsrvd|\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n+-                       Sender's Peer ID                      -+\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|              Peer Diagnosis Information                       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   x'E2'       |   x'D4'       |     x'C3'     |     x'D9'     |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 17,
      "text": "Figure 30: SMC Decline CLC Message Format",
      "ja": "図30：SMC CLCメッセージの形式を拒否する"
    },
    {
      "indent": 3,
      "text": "The fields present in the SMC Decline CLC message are:",
      "ja": "SMC衰退CLCメッセージに存在するフィールドは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Eye catchers",
      "ja": "アイキャッチャー"
    },
    {
      "indent": 6,
      "text": "Like all CLC messages, the SMC Decline has beginning and ending eye catchers to aid with verification and parsing. The hex digits spell \"SMCR\" in IBM-1047 (EBCDIC).",
      "ja": "すべてのCLCのメッセージと同様に、SMCの衰退は、検証と解析を支援するために、目のキャッチャーを開始し、終了しました。進数字は、IBM-1047（EBCDIC）に \"SMCR\" を綴ります。"
    },
    {
      "indent": 3,
      "text": "Type",
      "ja": "タイプ"
    },
    {
      "indent": 6,
      "text": "CLC message Type 4 indicates SMC Decline.",
      "ja": "CLCメッセージタイプ4は、SMCの低下を示しています。"
    },
    {
      "indent": 3,
      "text": "Length",
      "ja": "長さ"
    },
    {
      "indent": 6,
      "text": "The SMC Decline CLC message is 28 bytes long.",
      "ja": "SMC衰退CLCメッセージは、28バイト長です。"
    },
    {
      "indent": 3,
      "text": "Version",
      "ja": "版"
    },
    {
      "indent": 6,
      "text": "Version of the SMC-R protocol. Version 1 is the only currently defined value.",
      "ja": "SMC-Rプロトコルのバージョン。バージョン1のみ、現在定義された値です。"
    },
    {
      "indent": 3,
      "text": "S-bit",
      "ja": "Sビット"
    },
    {
      "indent": 6,
      "text": "Sync Bit. Indicates that the link group is out of sync and the receiving peer must clean up its representation of the link group.",
      "ja": "同期ビット。リンクグループが同期していないと受信ピアがリンクグループのその表現をクリーンアップする必要があることを示します。"
    },
    {
      "indent": 3,
      "text": "Sender's Peer ID",
      "ja": "ブロードキャスターのピアID"
    },
    {
      "indent": 6,
      "text": "As described in Appendix A.2.1 above.",
      "ja": "上記の付録A.2.1で説明したように。"
    },
    {
      "indent": 3,
      "text": "Peer Diagnosis Information",
      "ja": "診断情報をピア"
    },
    {
      "indent": 6,
      "text": "4 bytes of diagnosis information provided by the peer. These values are defined by the individual peers, and it is necessary to consult the peer's system documentation to interpret the results.",
      "ja": "ピアによって提供される診断情報の4バイト。これらの値は、個々のピアによって定義され、結果を解釈するためにピアのシステムのマニュアルを参照する必要があります。"
    },
    {
      "indent": 0,
      "text": "A.3. LLC Messages",
      "ja": "A.3。 LLCメッセージ"
    },
    {
      "indent": 3,
      "text": "LLC messages are sent over an existing SMC-R link using RoCE SendMsg and are always 44 bytes long so that they fit into the space available in a single WQE without requiring the receiver to post receive buffers. If all 44 bytes are not needed, they are padded out with zeros. LLC messages are in a request/response format. The message type is the same for request and response, and a flag indicates whether a message is flowing as a request or a response.",
      "ja": "LLCメッセージはROCE SENDMSGを使用して、既存のSMC-Rのリンクを介して送信されると、彼らは受信バッファを投稿する受信機を必要とせずに、単一のWQEで利用可能なスペースに収まるように、44バイト長は常にされています。すべての44バイトが必要とされていない場合は、ゼロでパディングされます。 LLCのメッセージは、要求/応答形式です。メッセージタイプは、要求と応答のために同じであり、フラグは、メッセージが要求または応答として流れているか否かを示します。"
    },
    {
      "indent": 3,
      "text": "The two high-order bits of an LLC message opcode indicate how it is to be handled by a peer that does not support the opcode.",
      "ja": "LLCメッセージ命令コードの上位2ビットは、オペコードをサポートしていないピアによって処理される方法を示します。"
    },
    {
      "indent": 3,
      "text": "If the high-order bits of the opcode are b'00', then the peer must support the LLC message and indicate a protocol error if it does not.",
      "ja": "オペコードの上位ビットがB'00' されている場合、ピアはLLCのメッセージをサポートしている必要がありますし、そうでない場合は、プロトコル・エラーを示しています。"
    },
    {
      "indent": 3,
      "text": "If the high-order bits of the opcode are b'10', then the peer must silently discard the LLC message if it does not support the opcode. This requirement is included to allow for toleration of advanced, but optional, functionality.",
      "ja": "オペコードの上位ビットがB'10' している場合、それはオペコードをサポートしていない場合、ピアは静かLLCのメッセージを破棄しなければなりません。この要件は、高度な、しかし、オプション、機能性の寛容を可能にするために含まれています。"
    },
    {
      "indent": 3,
      "text": "High-order bits of b'11' indicate a Connection Data Control (CDC) message as described in Appendix A.4.",
      "ja": "B'11' の上位ビット付録A.4に記載されるように接続データコントロール（CDC）メッセージを示します。"
    },
    {
      "indent": 0,
      "text": "A.3.1. CONFIRM LINK LLC Message Format",
      "ja": "A.3.1。 LINK LLCメッセージフォーマットを確認"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Type = 1     |  Length = 44  |   Reserved    |R|  Reserved   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Sender's RoCE                                                |\n+-   MAC address                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                               |                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +\n|                                                               |\n+-                                                             -+\n|                 Sender's RoCE GID                             |\n+-                                                             -+\n|                                                               |\n+-                              +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                               |Sender's QP number, bytes 1-2  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|Sender QP byte3| Link number   |Sender's link userID, bytes 1-2|\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|Sender's link userID, bytes 3-4| Max links     |  Reserved     |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n+-                         Reserved                            -+\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 16,
      "text": "Figure 31: CONFIRM LINK LLC Message Format",
      "ja": "図31：LINK LLCメッセージフォーマットを確認"
    },
    {
      "indent": 3,
      "text": "The CONFIRM LINK LLC message is required to be exchanged between the server and client over a newly created SMC-R link to complete the setup of an SMC-R link. Its purpose is to confirm that the RoCE path is actually usable.",
      "ja": "CONFIRMリンクLLCメッセージがSMC-Rリンクのセットアップを完了するために、新しく作成されたSMC-Rのリンクを介してサーバとクライアントの間で交換する必要があります。その目的は、ROCEパスが実際に使用可能であることを確認することです。"
    },
    {
      "indent": 3,
      "text": "On first contact, this message flows after the server receives the SMC Confirm CLC message from the client over the IP connection. For additional links added to an SMC-R link group, it flows after the ADD LINK and ADD LINK CONTINUATION exchange. This flow provides confirmation that the queue pair is in fact usable. Each peer echoes its RoCE information back to the other.",
      "ja": "サーバがSMCは、IP接続を介してクライアントからのCLCメッセージを確認して受信した後の最初の接触では、このメッセージが流れます。 SMC-Rリンクグループに追加された追加のリンクのために、それは、ADD LINK後に流れ、LINK継続交換を追加します。この流れは、キュー・ペアが実際に使用可能であることの確認を提供します。各ピアは他のバックにそのROCE情報をエコーし​​ます。"
    },
    {
      "indent": 3,
      "text": "The contents of the CONFIRM LINK LLC message are:",
      "ja": "CONFIRM LINKのLLCメッセージの内容は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "Type",
      "ja": "タイプ"
    },
    {
      "indent": 6,
      "text": "Type 1 indicates CONFIRM LINK.",
      "ja": "タイプ1は、CONFIRMのリンクを示します。"
    },
    {
      "indent": 3,
      "text": "Length",
      "ja": "長さ"
    },
    {
      "indent": 6,
      "text": "The CONFIRM LINK LLC message is 44 bytes long.",
      "ja": "CONFIRMリンクLLCのメッセージは、44バイト長です。"
    },
    {
      "indent": 3,
      "text": "R",
      "ja": "R"
    },
    {
      "indent": 6,
      "text": "Reply flag. When set, indicates that this is a CONFIRM LINK reply.",
      "ja": "フラグを返信します。設定した場合、これはCONFIRMリンク応答であることを示しています。"
    },
    {
      "indent": 3,
      "text": "Sender's RoCE MAC address",
      "ja": "送信者のROCE MACアドレス"
    },
    {
      "indent": 6,
      "text": "The MAC address of the sender's RNIC for the SMC-R link. It is required, as some operating systems do not have neighbor discovery or ARP support for RoCE RNICs.",
      "ja": "SMC-Rリンクの送信者のRNICのMACアドレス。一部のオペレーティングシステムは、ROCE RNICsのための近隣探索やARPをサポートしていないとしてそれは、必要とされます。"
    },
    {
      "indent": 3,
      "text": "Sender's RoCE GID",
      "ja": "送信者のGID年"
    },
    {
      "indent": 6,
      "text": "The IPv6 address of the RNIC that the sender is using for this SMC-R link.",
      "ja": "送信者は、このSMC-Rリンクに使用されるRNICのIPv6アドレス。"
    },
    {
      "indent": 3,
      "text": "Sender's QP number",
      "ja": "送信者のQP番号"
    },
    {
      "indent": 6,
      "text": "The number for the reliably connected queue pair that the sender created for this SMC-R link.",
      "ja": "送信者は、このSMC-Rのリンク用に作成されたことを確実に接続されているキュー・ペアの番号。"
    },
    {
      "indent": 3,
      "text": "Link number",
      "ja": "リンク数"
    },
    {
      "indent": 6,
      "text": "An identifier assigned by the server that uniquely identifies the link within the link group. This identifier is ONLY unique within a link group. Provided by the server and echoed back by the client.",
      "ja": "一意リンクグループ内のリンクを識別し、サーバによって割り当てられた識別子。この識別子は、リンク・グループ内でのみ一意です。サーバによって提供され、クライアントによってエコーバック。"
    },
    {
      "indent": 3,
      "text": "Link user ID",
      "ja": "リンクユーザーID"
    },
    {
      "indent": 6,
      "text": "An opaque, implementation-defined identifier assigned by the sender and provided to the receiver solely for purposes of display, diagnosis, network management, etc. The link user ID should be unique across the sender's entire software space, including all other link groups.",
      "ja": "不透明な、実装定義の識別子送信者によって割り当てられ、もっぱら表示、診断、ネットワーク管理の目的のために受信機に提供する、などのリンクのユーザーIDは、他のすべてのリンクグループを含め、送信者の全体のソフトウェア・スペース全体で一意である必要があります。"
    },
    {
      "indent": 3,
      "text": "Max links",
      "ja": "最大リンク"
    },
    {
      "indent": 6,
      "text": "The maximum number of links the sender can support in a link group. The maximum for this link group is the smaller of the values provided by the two peers.",
      "ja": "リンクの最大数は、送信者がリンクグループでサポートすることができます。このリンクグループの最大2つのピアによって提供される値のうち小さい方です。"
    },
    {
      "indent": 0,
      "text": "A.3.2. ADD LINK LLC Message Format",
      "ja": "A.3.2。 LINK LLCメッセージ形式を追加"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Type = 2     |  Length = 44  | Rsrvd |RsnCode|R|Z| Reserved  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Sender's RoCE                                                |\n+-   MAC address                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                               |                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +\n|                                                               |\n+-                                                             -+\n|                 Sender's RoCE GID                             |\n+-                                                             -+\n|                                                               |\n+-                              +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                               |Sender's QP number, bytes 1-2  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|Sender QP byte3| Link number   |Rsrvd  |  MTU  |Initial PSN    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Initial PSN (continued)      |                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                              -+\n|                          Reserved                             |\n+-                                                             -+\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 18,
      "text": "Figure 32: ADD LINK LLC Message Format",
      "ja": "図32：LINK LLCメッセージフォーマットを追加"
    },
    {
      "indent": 3,
      "text": "The ADD LINK LLC message is sent over an existing link in the link group when a peer wishes to add an SMC-R link to an existing SMC-R link group. It is sent by the server to add a new SMC-R link to the group, or by the client to request that the server add a new link -- for example, when a new RNIC becomes active. When sent from the client to the server, it represents a request that the server initiate an ADD LINK exchange.",
      "ja": "ピアが既存のSMC-RリンクグループにSMC-Rのリンクを追加したい場合ADDリンクLLCメッセージは、リンクグループ内の既存のリンクを介して送信されます。例えば、新しいRNICがアクティブになったとき - サーバーが新しいリンクを追加することを要求するためにグループに新しいSMC-Rのリンクを追加、またはクライアントによって、サーバによって送信されます。クライアントからサーバに送られたときは、サーバーは、ADDのLINK交換を開始要求を表します。"
    },
    {
      "indent": 3,
      "text": "This message is sent immediately after the initial SMC-R link in the group completes, as described in Section 3.5.1 (\"First Contact\"). It can also be sent over an existing SMC-R link group at any time as new RNICs are added and become available. Therefore, there can be as few as one new RMB RToken to be communicated, or several. RTokens will be communicated using ADD LINK CONTINUATION messages.",
      "ja": "このメッセージは、3.5.1項（「ファーストコンタクト」）で説明したように、グループ内の最初のSMC-Rリンクは、完了した直後に送信されます。また、新しいRNICsが追加されるといつでも既存のSMC-Rリンク群を介して送信され、利用可能になることができます。したがって、1新しい人民元通信されるRTOKEN、またはいくつかのように、いくつかが存在することができます。 RTokensはLINK継続メッセージを追加使用して通信されます。"
    },
    {
      "indent": 3,
      "text": "The contents of the ADD LINK LLC message are:",
      "ja": "ADD LINKのLLCメッセージの内容は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "Type",
      "ja": "タイプ"
    },
    {
      "indent": 6,
      "text": "Type 2 indicates ADD LINK.",
      "ja": "タイプ2は、リンクを追加を示しています。"
    },
    {
      "indent": 3,
      "text": "Length",
      "ja": "長さ"
    },
    {
      "indent": 6,
      "text": "The ADD LINK LLC message is 44 bytes long.",
      "ja": "ADDリンクLLCのメッセージは、44バイト長です。"
    },
    {
      "indent": 3,
      "text": "RsnCode",
      "ja": "RsnCode"
    },
    {
      "indent": 6,
      "text": "If the Z (rejection) flag is set, this field provides the reason code. Values can be:",
      "ja": "Z（拒絶）フラグが設定されている場合、このフィールドは、理由コードを提供します。可能な値は："
    },
    {
      "indent": 9,
      "text": "X'1' - no alternate path available: set when the server provides the same MAC/GID as an existing SMC-R link in the group, and the client does not have any additional RNICs available (i.e., the server is attempting to set up an asymmetric link but none is available).",
      "ja": "X'1'  - なし代替パス：サーバがグループ内の既存のSMC-Rのリンクと同じMAC / GIDを提供し、クライアントが利用可能な追加のRNICsを持っていないときに設定（つまり、サーバーを設定しようとしています）非対称リンクアップが、どれも使用できません。"
    },
    {
      "indent": 9,
      "text": "X'2' - Invalid MTU value specified.",
      "ja": "X'2'  - 指定された無効なMTU値。"
    },
    {
      "indent": 3,
      "text": "R",
      "ja": "R"
    },
    {
      "indent": 6,
      "text": "Reply flag. When set, indicates that this is an ADD LINK reply.",
      "ja": "フラグを返信します。設定した場合、これはADDのLINK応答であることを示しています。"
    },
    {
      "indent": 3,
      "text": "Z",
      "ja": "とともに"
    },
    {
      "indent": 6,
      "text": "Rejection flag. When set on reply, indicates that the server's ADD LINK was rejected by the client. When this flag is set, the reason code will also be set.",
      "ja": "拒絶フラグ。返信に設定すると、サーバーの追加]リンクがクライアントによって拒否されたことを示しています。このフラグが設定されている場合は、理由コードも設定されます。"
    },
    {
      "indent": 3,
      "text": "Sender's RoCE MAC address",
      "ja": "送信者のROCE MACアドレス"
    },
    {
      "indent": 6,
      "text": "The MAC address of the sender's RNIC for the new SMC-R link. It is required, as some operating systems do not have neighbor discovery or ARP support for RoCE RNICs.",
      "ja": "新しいSMC-Rリンクの送信者のRNICのMACアドレス。一部のオペレーティングシステムは、ROCE RNICsのための近隣探索やARPをサポートしていないとしてそれは、必要とされます。"
    },
    {
      "indent": 3,
      "text": "Sender's RoCE GID",
      "ja": "送信者のGID年"
    },
    {
      "indent": 6,
      "text": "The IPv6 address of the RNIC that the sender is using for the new SMC-R link.",
      "ja": "送信者が新しいSMC-Rリンクに使用されるRNICのIPv6アドレス。"
    },
    {
      "indent": 3,
      "text": "Sender's QP number",
      "ja": "送信者のQP番号"
    },
    {
      "indent": 6,
      "text": "The number for the reliably connected queue pair that the sender created for the new SMC-R link.",
      "ja": "送信者が新しいSMC-Rのリンク用に作成されたことを確実に接続されているキュー・ペアの番号。"
    },
    {
      "indent": 3,
      "text": "Link number",
      "ja": "リンク数"
    },
    {
      "indent": 6,
      "text": "An identifier for the new SMC-R link. This is assigned by the server and uniquely identifies the link within the link group. This identifier is ONLY unique within a link group. Provided by the server and echoed back by the client.",
      "ja": "新しいSMC-Rリンクの識別子。これはサーバによって割り当てられ、一意にリンクグループ内のリンクを識別しています。この識別子は、リンク・グループ内でのみ一意です。サーバによって提供され、クライアントによってエコーバック。"
    },
    {
      "indent": 3,
      "text": "MTU",
      "ja": "MTU"
    },
    {
      "indent": 6,
      "text": "An enumerated value indicating this peer's QP MTU size. The two peers exchange their MTU values, and whichever value is smaller will be used for the QP. The values are enumerated in Appendix A.2.3.",
      "ja": "このピアのQP MTUサイズを示す列挙値。 2つのピアがそのMTU値を交換し、どちらの値がQPのために小さい使用されるています。値は、付録A.2.3に列挙されています。"
    },
    {
      "indent": 3,
      "text": "Initial PSN",
      "ja": "初期PSN"
    },
    {
      "indent": 6,
      "text": "The starting packet sequence number (PSN) that this peer will use when sending to the other peer, so that the other peer can prepare its QP for the sequence number to expect.",
      "ja": "他のピアに送信するときに他のピアが期待するシーケンス番号のためにQPを準備できるように、このピアが、使用することを開始パケットシーケンス番号（PSN）。"
    },
    {
      "indent": 0,
      "text": "A.3.3. ADD LINK CONTINUATION LLC Message Format",
      "ja": "A.3.3。 LINK継続LLCメッセージ形式を追加"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Type = 3     |  Length = 44  |  Reserved     |R|  Reserved   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Linknum     | NumRTokens    |         Reserved              |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n+-                                                             -+\n|                                                               |\n+-                  RKey/RToken pair                           -+\n|                                                               |\n+-                                                             -+\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n+-                                                             -+\n|                                                               |\n+-                  RKey/RToken pair or zeros                  -+\n|                                                               |\n+-                                                             -+\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        Reserved                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 12,
      "text": "Figure 33: ADD LINK CONTINUATION LLC Message Format",
      "ja": "図33：ADD LINK継続LLCメッセージ形式"
    },
    {
      "indent": 3,
      "text": "When a new SMC-R link is added to an SMC-R link group, it is necessary to communicate the new link's RTokens for the RMBs that the SMC-R link group can access. This message follows the ADD LINK and provides the RTokens.",
      "ja": "新しいSMC-Rリンクは、SMC-Rリンクグループに追加されたとき、SMC-RリンクグループがアクセスできるRMBS新しいリンクのRTokensを通信する必要があります。このメッセージは、ADDリンクをたどり、RTokensを提供します。"
    },
    {
      "indent": 3,
      "text": "The server kicks off this exchange by sending the first ADD LINK CONTINUATION LLC message, and the server controls the exchange as described below.",
      "ja": "サーバは、最初のADD LINK継続LLCメッセージを送信することにより、この交換をキックオフ、後述するように、サーバは、交換を制御します。"
    },
    {
      "indent": 3,
      "text": "o If the client and the server require the same number of ADD LINK CONTINUATION messages to communicate their RTokens, the server starts the exchange by sending the first ADD LINK CONTINUATION request to the client with its (the server's) RTokens. The client then responds with an ADD LINK CONTINUATION response with its RTokens, and so on until the exchange is completed.",
      "ja": "クライアントとサーバーがそのRTokensを伝えるためにADD LINK継続メッセージの同じ数を必要とする場合は、O、サーバはその（サーバの）RTokensと、クライアントへの最初のADD LINK継続要求を送信することにより、交換を開始します。次に、クライアントは、そのRTokensとADDのLINK継続応答で応答など交換が完了するまで。"
    },
    {
      "indent": 3,
      "text": "o If the server requires more ADD LINK CONTINUATION messages than the client, then after the client has communicated all of its RTokens, the server continues to send ADD LINK CONTINUATION request messages to the client. The client continues to respond, using empty (number of RTokens to be communicated = 0) ADD LINK CONTINUATION response messages.",
      "ja": "サーバが複数のクライアントよりも、LINK継続メッセージを追加する必要がある場合は、クライアントがそのRTokensのすべてを伝えた後、O、そして、サーバはクライアントにADDのLINK継続要求メッセージを送信し続けます。クライアントは、リンクの継続応答メッセージを追加する（= 0を通信するRTokensの数）が空を用いて、応答し続けます。"
    },
    {
      "indent": 3,
      "text": "o If the client requires more ADD LINK CONTINUATION messages than the server, then after communicating all of its RTokens, the server will continue to send empty ADD LINK CONTINUATION messages to the client to solicit replies with the client's RTokens, until all have been communicated.",
      "ja": "クライアントがより必要とするサーバーよりも、LINK継続メッセージを追加する場合は、O、そのRTokensのすべてを伝える後、サーバーは、すべての通信が完了するまで、クライアントのRTokensとの回答を勧誘するために、クライアントに空のADD LINK継続メッセージを送信し続けます。"
    },
    {
      "indent": 3,
      "text": "The contents of the ADD LINK CONTINUATION LLC message are:",
      "ja": "ADDのLINK継続LLCメッセージの内容は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "Type",
      "ja": "タイプ"
    },
    {
      "indent": 6,
      "text": "Type 3 indicates ADD LINK CONTINUATION.",
      "ja": "タイプ3は、LINKの継続をADDを示しています。"
    },
    {
      "indent": 3,
      "text": "Length",
      "ja": "長さ"
    },
    {
      "indent": 6,
      "text": "The ADD LINK CONTINUATION LLC message is 44 bytes long.",
      "ja": "ADDのLINK継続LLCのメッセージは、44バイト長です。"
    },
    {
      "indent": 3,
      "text": "R",
      "ja": "R"
    },
    {
      "indent": 6,
      "text": "Reply flag. When set, indicates that this is an ADD LINK CONTINUATION reply.",
      "ja": "フラグを返信します。設定した場合、これはADDのLINK継続応答であることを示しています。"
    },
    {
      "indent": 3,
      "text": "LinkNum",
      "ja": "リンク"
    },
    {
      "indent": 6,
      "text": "The link number of the new link within the SMC-R link group for which RKeys are being communicated.",
      "ja": "RKeysが通信されているSMC-Rリンクグループ内の新しいリンクのリンク番号。"
    },
    {
      "indent": 3,
      "text": "NumRTokens",
      "ja": "NumRTokens"
    },
    {
      "indent": 6,
      "text": "Number of RTokens remaining to be communicated (including the ones in this message). If the value is less than or equal to 2, this is the last message. If it is greater than 2, another continuation message will be required, and its value will be the value in this message minus 2, and so on until all RKeys are communicated. The maximum value for this field is 255.",
      "ja": "（このメッセージに含め）通信すべき残りRTokensの数。値が2以下である場合、これが最後のメッセージです。それは2よりも大きい場合には、別の継続メッセージが必要となり、そして全てRKeysが伝達されるまで、その値はように、このメッセージの値マイナス2であり、そしてあろう。このフィールドの最大値は255です。"
    },
    {
      "indent": 3,
      "text": "RKey/RToken pairs (two or less)",
      "ja": "キー/トークンペア（2個以下）"
    },
    {
      "indent": 6,
      "text": "These consist of an RKey for an RMB that is known on the SMC-R link over which this message was sent (the reference RKey), paired with the same RMB's RToken over the new SMC-R link. A full RToken is not required for the reference, because it is only being used to distinguish which RMB it applies to, not address it.",
      "ja": "これらは、新しいSMC-Rリンクを介して同じRMBのRTOKENと対にこのメッセージが送信された先のSMC-Rリンク（参照RKEY）に知られているRMBためRKEYから成ります。それだけに対処していない、それが適用される人民元区別するために使用されているので、完全RTOKENは、参考のために必要とされません。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                         Reference RKey                        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                            New RKey                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n+-                       New Virtual Address                   -+\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 20,
      "text": "Figure 34: RKey/RToken Pair Format",
      "ja": "図34：キー/トークンペアのフォーマット"
    },
    {
      "indent": 3,
      "text": "The contents of the RKey/RToken pair are:",
      "ja": "キー/トークンペアの内容は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "Reference RKey",
      "ja": "参考RKEY"
    },
    {
      "indent": 6,
      "text": "The RKey of the RMB as it is already known on the SMC-R link over which this message is being sent. Required so that the peer knows with which RMB to associate the new RToken.",
      "ja": "それは既にこのメッセージが送信されている上にSMC-Rリンクで知られているように、元のRKEY。ピアが新しいRTOKENを関連付けるた人民元で認識できるように必要です。"
    },
    {
      "indent": 3,
      "text": "New RKey",
      "ja": "新RKEY"
    },
    {
      "indent": 6,
      "text": "The RKey of this RMB as it is known over the new SMC-R link.",
      "ja": "それは新しいSMC-Rリンク上で知られているように、この元のRKEY。"
    },
    {
      "indent": 3,
      "text": "New Virtual Address",
      "ja": "新しい仮想アドレス"
    },
    {
      "indent": 6,
      "text": "The virtual address of this RMB as it is known over the new SMC-R link.",
      "ja": "それは新しいSMC-Rリンク上で知られているように、この元の仮想アドレス。"
    },
    {
      "indent": 0,
      "text": "A.3.4. DELETE LINK LLC Message Format",
      "ja": "A.3.4。 LINK LLCメッセージフォーマットを削除"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Type = 4     |  Length = 44  |  Reserved     |R|A|O| Rsrvd   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Linknum     |         reason code (bytes 1-3)               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|RsnCode byte 4 |                                               |\n+-+-+-+-+-+-+-+-+                                              -+\n|                                                               |\n+-                                                             -+\n|                                                               |\n+-                                                             -+\n|                                                               |\n+-                          Reserved                           -+\n|                                                               |\n+-                                                             -+\n|                                                               |\n+-                                                             -+\n|                                                               |\n+-                                                             -+\n|                                                               |\n+-                                                             -+\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 17,
      "text": "Figure 35: DELETE LINK LLC Message Format",
      "ja": "図35：LINK LLCメッセージフォーマットを削除"
    },
    {
      "indent": 3,
      "text": "When the client or server detects that a QP or SMC-R link goes down or needs to come down, it sends this message over one of the other links in the link group.",
      "ja": "クライアントまたはサーバがQPまたはSMC-Rのリンクがダウンしたか、降りてくる必要があることを検知した場合には、リンクグループ内の他のリンクの1つにこのメッセージを送信します。"
    },
    {
      "indent": 3,
      "text": "When the DELETE LINK is sent from the client, it only serves as a notification, and the client expects the server to respond by sending a DELETE LINK request. To avoid races, only the server will initiate the actual DELETE LINK request and response sequence that results from notification from the client.",
      "ja": "DELETE LINKは、クライアントから送信されると、それが唯一の通知として機能し、クライアントは、サーバがDELETE LINK要求を送信して応答を期待しています。レースを回避するために、唯一のサーバは、クライアントからの通知により生じる実際のDELETE LINK要求と応答シーケンスを開始します。"
    },
    {
      "indent": 3,
      "text": "The server can also initiate the DELETE LINK without notification from the client if it detects an error or if orderly link termination was initiated.",
      "ja": "整然としたリンク終了が開始された場合、それはエラーを検出した場合、またはサーバは、クライアントからの通知なしにDELETE LINKを開始することができます。"
    },
    {
      "indent": 3,
      "text": "The client may also request termination of the entire link group, and the server may terminate the entire link group using this message.",
      "ja": "また、クライアントは、全体のリンクグループの終了を要求することができ、サーバは、このメッセージを使用して全体のリンクグループを終了させることができます。"
    },
    {
      "indent": 3,
      "text": "The contents of the DELETE LINK LLC message are:",
      "ja": "DELETE LINK LLCメッセージの内容は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "Type",
      "ja": "タイプ"
    },
    {
      "indent": 6,
      "text": "Type 4 indicates DELETE LINK.",
      "ja": "タイプ4は、DELETE LINKを示しています。"
    },
    {
      "indent": 3,
      "text": "Length",
      "ja": "長さ"
    },
    {
      "indent": 6,
      "text": "The DELETE LINK LLC message is 44 bytes long.",
      "ja": "DELETE LINK LLCのメッセージは、44バイト長です。"
    },
    {
      "indent": 3,
      "text": "R",
      "ja": "R"
    },
    {
      "indent": 6,
      "text": "Reply flag. When set, indicates that this is a DELETE LINK reply.",
      "ja": "フラグを返信します。設定した場合、これはDELETE LINK応答であることを示しています。"
    },
    {
      "indent": 3,
      "text": "A",
      "ja": "A"
    },
    {
      "indent": 6,
      "text": "\"All\" flag. When set, indicates that all links in the link group are to be terminated. This terminates the link group.",
      "ja": "「すべて」のフラグ。設定した場合、リンクグループ内のすべてのリンクを終了すべきであることを示しています。これは、リンクグループを終了します。"
    },
    {
      "indent": 3,
      "text": "O",
      "ja": "尾"
    },
    {
      "indent": 6,
      "text": "Orderly flag. Indicates orderly termination. Orderly termination is generally caused by an operator command rather than an error on the link. When the client requests orderly termination, the server may wait to complete other work before terminating.",
      "ja": "整然としたフラグ。整然とした終了を示します。規則的終端は、一般に、オペレータコマンドではなく、リンク上のエラーによって引き起こされます。クライアントは整然とした終了を要求すると、サーバが終了する前に、他の作業を完了するのを待つことがあります。"
    },
    {
      "indent": 3,
      "text": "LinkNum",
      "ja": "リンク"
    },
    {
      "indent": 6,
      "text": "The link number of the link to be terminated. If the A flag is set, this field has no meaning and is set to 0.",
      "ja": "リンクのリンク数が終了します。 Aフラグが設定されている場合、このフィールドは意味を持たないと0に設定されています。"
    },
    {
      "indent": 3,
      "text": "RsnCode",
      "ja": "RsnCode"
    },
    {
      "indent": 6,
      "text": "The termination reason code. Currently defined reason codes are:",
      "ja": "終了理由コード。現在、定義された理由コードは以下のとおりです。"
    },
    {
      "indent": 6,
      "text": "Request reason codes:",
      "ja": "要求理由コード："
    },
    {
      "indent": 9,
      "text": "X'00010000' = Lost path",
      "ja": "X'00010000' =ロスト・パス"
    },
    {
      "indent": 9,
      "text": "X'00020000' = Operator initiated termination",
      "ja": "X'00020000' =演算子は、終了を開始しました"
    },
    {
      "indent": 9,
      "text": "X'00030000' = Program initiated termination (link inactivity)",
      "ja": "X'00030000' =プログラム開始終了（リンクの非アクティブ）"
    },
    {
      "indent": 9,
      "text": "X'00040000' = LLC protocol violation",
      "ja": "X'00040000' = LLCプロトコル違反"
    },
    {
      "indent": 9,
      "text": "X'00050000' = Asymmetric link no longer needed",
      "ja": "X'00050000' はもはや必要=非対称リンク"
    },
    {
      "indent": 6,
      "text": "Response reason code:",
      "ja": "レスポンス理由コード："
    },
    {
      "indent": 9,
      "text": "X'00100000' = Unknown link ID (no link)",
      "ja": "X'00100000' =未知のリンクID（リンクなし）"
    },
    {
      "indent": 0,
      "text": "A.3.5. CONFIRM RKEY LLC Message Format",
      "ja": "A.3.5。 RKEY LLCメッセージフォーマットを確認"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Type = 6     |  Length = 44  |   Reserved    |R|0|Z|C|Rsrvd  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   NumTkns     |  New RMB RKey for this link (bytes 1-3)       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|ThisLink byte 4|                                               |\n+-+-+-+-+-+-+-+-+                                              -+\n|           New RMB virtual address for this link               |\n+-              +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|               |                                               |\n+-+-+-+-+-+-+-+-+                                              -+\n|                                                               |\n+-   Other link RMB specification or zeros                     -+\n|                                                               |\n+-                              +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                               |                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                              -+\n|                                                               |\n+-                                                             -+\n|      Other link RMB specification or zeros                    |\n+-                                              +-+-+-+-+-+-+-+-+\n|                                               |  Reserved     |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 16,
      "text": "Figure 36: CONFIRM RKEY LLC Message Format",
      "ja": "図36：RKEY LLCメッセージフォーマットを確認"
    },
    {
      "indent": 3,
      "text": "The CONFIRM RKEY flow can be sent at any time from either the client or the server, to inform the peer that an RMB has been created or deleted. The creator of a new RMB must inform its peer of the new RMB's RToken for all SMC-R links in the SMC-R link group.",
      "ja": "CONFIRMのRKEYの流れは、人民元が作成または削除されたピアに通知するために、クライアントまたはサーバから任意の時点で送信することができます。新しい元の作成者は、SMC-Rリンクグループ内のすべてのSMC-Rリンクのための新しい人民元のRTOKENのピアに通知しなければなりません。"
    },
    {
      "indent": 3,
      "text": "For RMB creation, the creator sends this message over the SMC-R link that the first TCP connection that uses the new RMB is using. This message contains the new RMB RToken for the SMC-R link over which the message is sent. It then lists the sender's SMC-R links in the link group paired with the new RToken for the new RMB for that link. This message can communicate the new RTokens for three QPs: the QP for the link over which this message is sent, and two others. If there are more than three links in the SMC-R link group, a CONFIRM RKEY CONTINUATION will be required.",
      "ja": "人民元の作成のために、作成者は、新たな人民元を使用する最初のTCP接続が使用されていることをSMC-Rリンク上でこのメッセージを送信します。このメッセージは、メッセージが送信されるSMC-Rのリンクのための新しい人民元RTOKENが含まれています。これは、そのリンクのための新たな人民元のための新しいRTOKENとペアリンクグループでの送信者のSMC-Rのリンクが一覧表示されます。このメッセージが送信されるリンクのQP、他2名：このメッセージは、3つのQPのための新しいRTokensを伝えることができます。 SMC-Rリンクグループの中に3個以上のリンクがある場合は、CONFIRMのRKEYの継続が必要となります。"
    },
    {
      "indent": 3,
      "text": "The peer responds by simply echoing the message with the response flag set. If the response is a negative response, the sender must recalculate the RToken set and start a new CONFIRM RKEY exchange from the beginning. The timing of this retry is controlled by the C flag, as described below.",
      "ja": "ピアは単に応答フラグが設定されたメッセージをエコーすることによって応答します。応答が否定応答である場合、送信者はRTOKENセットを再計算し、最初から新しいCONFIRMのRKEY交換を開始する必要があります。以下に説明するように、このリトライのタイミングは、Cフラグによって制御されます。"
    },
    {
      "indent": 3,
      "text": "The contents of the CONFIRM RKEY LLC message are:",
      "ja": "CONFIRM RKEY LLCメッセージの内容は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "Type",
      "ja": "タイプ"
    },
    {
      "indent": 6,
      "text": "Type 6 indicates CONFIRM RKEY.",
      "ja": "タイプ6は、CONFIRMのRKEYを示します。"
    },
    {
      "indent": 3,
      "text": "Length",
      "ja": "長さ"
    },
    {
      "indent": 6,
      "text": "The CONFIRM RKEY LLC message is 44 bytes long.",
      "ja": "CONFIRM RKEY LLCのメッセージは、44バイト長です。"
    },
    {
      "indent": 3,
      "text": "R",
      "ja": "R"
    },
    {
      "indent": 6,
      "text": "Reply flag. When set, indicates that this is a CONFIRM RKEY reply.",
      "ja": "フラグを返信します。設定した場合、これはCONFIRMのRKEY応答であることを示しています。"
    },
    {
      "indent": 3,
      "text": "0",
      "ja": "０"
    },
    {
      "indent": 6,
      "text": "Reserved bit.",
      "ja": "予約ビット。"
    },
    {
      "indent": 3,
      "text": "Z",
      "ja": "とともに"
    },
    {
      "indent": 6,
      "text": "Negative response flag.",
      "ja": "否定応答フラグ。"
    },
    {
      "indent": 3,
      "text": "C",
      "ja": "C"
    },
    {
      "indent": 6,
      "text": "Configuration Retry bit. If this is a negative response and this flag is set, the originator should recalculate the RKey set and retry this exchange as soon as the current configuration change is completed. If this flag is not set on a negative response, the originator must wait for the next natural stimulus (for example, a new TCP connection started that requires a new RMB) before retrying.",
      "ja": "コンフィギュレーションリトライビット。これは否定応答であり、このフラグが設定されている場合は、発信者はRKEYセットを再計算する必要があり、現在の構成の変更が完了するとすぐにこの交換を再試行してください。このフラグが否定応答に設定されていない場合は、発信者が再試行する前に（たとえば、新しいTCP接続がそれが新しい人民元を必要とし始めた）次の自然な刺激を待つ必要があります。"
    },
    {
      "indent": 3,
      "text": "NumTkns",
      "ja": "NumTkns"
    },
    {
      "indent": 6,
      "text": "The number of other link/RToken pairs, including those provided in this message, to be communicated. Note that this value does not include the RToken for the link on which this message was sent (i.e., the maximum value is 2). If this value is 3 or less, this is the only message in the exchange. If this value is greater than 3, a CONFIRM RKEY CONTINUATION message will be required.",
      "ja": "このメッセージで提供されたものを含む、他のリンク/ RTOKEN対の数が通信されます。この値は、このメッセージが送信されたリンクについてRTOKENを含んでいないことに留意されたい（すなわち、最大値は2です）。この値が3以下であれば、これは交換の唯一のメッセージです。この値が3より大きい場合は、CONFIRM RKEY継続メッセージが必要とされるであろう。"
    },
    {
      "indent": 6,
      "text": "Note: In this version of the architecture, eight is the maximum number of links supported in a link group.",
      "ja": "注：アーキテクチャのこのバージョンでは、8は、リンクグループでサポートされているリンクの最大数です。"
    },
    {
      "indent": 3,
      "text": "New RMB RKey for this link",
      "ja": "このリンクのための新しい人民元RKEY"
    },
    {
      "indent": 6,
      "text": "The new RMB's RKey as assigned on the link over which this message is being sent.",
      "ja": "このメッセージが送信されて、その上のリンクで割り当てられているように、新しい人民元のRKEY。"
    },
    {
      "indent": 3,
      "text": "New RMB virtual address for this link",
      "ja": "このリンクのための新しい元の仮想アドレス"
    },
    {
      "indent": 6,
      "text": "The new RMB's virtual address as assigned on the link over which this message is being sent.",
      "ja": "このメッセージが送信されて、その上のリンクで割り当てられているように、新しい人民元の仮想アドレス。"
    },
    {
      "indent": 3,
      "text": "Other link RMB specification",
      "ja": "その他のリンク元の仕様"
    },
    {
      "indent": 6,
      "text": "The new RMB's specification on the other links in the link group, as shown in Figure 37.",
      "ja": "図37に示すように、リンクグループ内の他のリンク、上の新しい人民元の仕様。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Link number   | RMB's RKey for the specified link (bytes 1-3) |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|New RKey byte 4|                                               |\n+-+-+-+-+-+-+-+-+                                              -+\n|           RMB's virtual address for the specified link        |\n+-              +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|               |\n+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 16,
      "text": "Figure 37: Format of Link Number/RKey Pairs",
      "ja": "図37：リンク数/ RKEYペアのフォーマット"
    },
    {
      "indent": 3,
      "text": "Link number",
      "ja": "リンク数"
    },
    {
      "indent": 6,
      "text": "The link number for a link in the link group.",
      "ja": "リンクグループ内のリンクのリンク番号。"
    },
    {
      "indent": 3,
      "text": "RMB's RKey for the specified link",
      "ja": "指定されたリンクの人民元のRKEY"
    },
    {
      "indent": 6,
      "text": "The RKey used to reach the RMB over the link whose number was specified in the Link number field.",
      "ja": "RKEYは数リンク番号フィールドで指定されたリンクを介して元に到達するために使用されます。"
    },
    {
      "indent": 3,
      "text": "RMB's virtual address for the specified link",
      "ja": "指定されたリンクの元の仮想アドレス"
    },
    {
      "indent": 6,
      "text": "The virtual address used to reach the RMB over the link whose number was specified in the Link number field.",
      "ja": "仮想アドレスは、数のリンク番号フィールドで指定されたリンクを介して元に到達するために使用されます。"
    },
    {
      "indent": 0,
      "text": "A.3.6. CONFIRM RKEY CONTINUATION LLC Message Format",
      "ja": "A.3.6。 RKEY継続LLCメッセージ形式を確認"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Type = 8     |  Length = 44  |   Reserved    |R|0|Z|  Rsrvd  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  NumTknsLeft  |                                               |\n+-+-+-+-+-+-+-+-+                                              -+\n|                                                               |\n+-          Other link RMB specification                       -+\n|                                                               |\n+-              +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|               |                                               |\n+-+-+-+-+-+-+-+-+                                              -+\n|                                                               |\n+-   Other link RMB specification or zeros                     -+\n|                                                               |\n+-                              +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                               |                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                              -+\n|                                                               |\n+-                                                             -+\n|      Other link RMB specification or zeros                    |\n+-                                              +-+-+-+-+-+-+-+-+\n|                                               |  Reserved     |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 10,
      "text": "Figure 38: CONFIRM RKEY CONTINUATION LLC Message Format",
      "ja": "図38：CONFIRM RKEY継続LLCのメッセージ形式"
    },
    {
      "indent": 3,
      "text": "The CONFIRM RKEY CONTINUATION LLC message is used to communicate any additional RMB RTokens that did not fit into the CONFIRM RKEY message. Each of these messages can hold up to three RMB RTokens. The NumTknsLeft field indicates how many RMB RTokens are to be communicated, including the ones in this message. If the value is 3 or less, this is the last message of the group. If the value is 4 or higher, additional CONFIRM RKEY CONTINUATION messages will follow, and the NumTknsLeft value will be a countdown until all are communicated.",
      "ja": "CONFIRM RKEY継続LLCメッセージがCONFIRMのRKEYメッセージに適合していなかった追加の人民元RTokensを通信するために使用されます。これらのメッセージはそれぞれ、3元RTokensまで保持できます。 NumTknsLeftフィールドには、多くの人民元のRTokensは、このメッセージにものを含めて、通信することになっているかを示します。値が3以下であれば、このことは、グループの最後のメッセージです。値が4以上である場合には、追加の確認RKEY継続メッセージが続く、とすべてが伝達されるまでNumTknsLeft値がカウントダウンされます。"
    },
    {
      "indent": 3,
      "text": "Like the CONFIRM RKEY message, the peer responds by echoing the message back with the reply flag set.",
      "ja": "CONFIRMのRKEYメッセージように、ピアは、応答フラグを設定してメッセージをエコーバックすることによって応答します。"
    },
    {
      "indent": 3,
      "text": "The contents of the CONFIRM RKEY CONTINUATION LLC message are:",
      "ja": "CONFIRMのRKEY継続LLCメッセージの内容は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "Type",
      "ja": "タイプ"
    },
    {
      "indent": 6,
      "text": "Type 8 indicates CONFIRM RKEY CONTINUATION.",
      "ja": "タイプ8は、CONFIRMのRKEYの継続を示します。"
    },
    {
      "indent": 3,
      "text": "Length",
      "ja": "長さ"
    },
    {
      "indent": 6,
      "text": "The CONFIRM RKEY CONTINUATION LLC message is 44 bytes long.",
      "ja": "CONFIRM RKEY継続LLCのメッセージは、44バイト長です。"
    },
    {
      "indent": 3,
      "text": "R",
      "ja": "R"
    },
    {
      "indent": 6,
      "text": "Reply flag. When set, indicates that this is a CONFIRM RKEY CONTINUATION reply.",
      "ja": "フラグを返信します。設定した場合、これはCONFIRM RKEY継続応答であることを示しています。"
    },
    {
      "indent": 3,
      "text": "0",
      "ja": "０"
    },
    {
      "indent": 6,
      "text": "Reserved bit.",
      "ja": "予約ビット。"
    },
    {
      "indent": 3,
      "text": "Z",
      "ja": "とともに"
    },
    {
      "indent": 6,
      "text": "Negative response flag.",
      "ja": "否定応答フラグ。"
    },
    {
      "indent": 3,
      "text": "NumTknsLeft",
      "ja": "NumTknsLeft"
    },
    {
      "indent": 6,
      "text": "The number of link/RToken pairs, including those provided in this message, that are remaining to be communicated. If this value is 3 or less, this is the last message in the exchange. If this value is greater than 3, another CONFIRM RKEY CONTINUATION message will be required. Note that in this version of the architecture, eight is the maximum number of links supported in a link group.",
      "ja": "通信さ残っているこのメッセージで提供されるものを含むリンク/ RTOKEN対の数。この値が3以下であれば、これは交換の最後のメッセージです。この値が3より大きい場合は、別のCONFIRM RKEY継続メッセージが必要とされるであろう。アーキテクチャのこのバージョンでは、8は、リンクグループでサポートされているリンクの最大数であることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Other link RMB specification",
      "ja": "その他のリンク元の仕様"
    },
    {
      "indent": 6,
      "text": "The new RMB's specification on other links in the link group, as shown in Figure 37.",
      "ja": "図37に示すように、リンクグループ内の他のリンク、上の新しい人民元の仕様。"
    },
    {
      "indent": 0,
      "text": "A.3.7. DELETE RKEY LLC Message Format",
      "ja": "A.3.7。 RKEY LLCメッセージフォーマットを削除"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Type = 9     |  Length = 44  |   Reserved    |R|0|Z|  Rsrvd  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     Count     | Error Mask    |        Reserved               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                First deleted RKey                             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|            Second deleted RKey or zeros                       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|            Third deleted RKey or zeros                        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|            Fourth deleted RKey or zeros                       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|            Fifth deleted RKey or zeros                        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|            Sixth deleted RKey or zeros                        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|            Seventh deleted RKey or zeros                      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|            Eighth deleted RKey or zeros                       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                       Reserved                                |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 17,
      "text": "Figure 39: DELETE RKEY LLC Message Format",
      "ja": "図39：RKEY LLCメッセージフォーマットを削除"
    },
    {
      "indent": 3,
      "text": "The DELETE RKEY flow can be sent at any time from either the client or the server, to inform the peer that one or more RMBs have been deleted. Because the peer already knows every RMB's RKey on each link in the link group, this message only specifies one RKey for each RMB being deleted. The RKey provided for each deleted RMB will be its RKey as known on the SMC-R link over which this message is sent.",
      "ja": "DELETE RKEYの流れは、一つ以上のRMBSが削除されていることを相手に知らせるために、クライアントまたはサーバから任意の時点で送信することができます。ピアがすでにリンクグループ内の各リンク上のすべての人民元のRKEYを知っているので、このメッセージは削除されている各人民元に対して1 RKEYを指定します。このメッセージが送信されるSMC-Rリンクで知られているように、各削除RMBに設けられRKEYは、RKEYあろう。"
    },
    {
      "indent": 3,
      "text": "It is not necessary to provide the entire RToken. The RKey alone is sufficient for identifying an existing RMB.",
      "ja": "全体RTOKENを提供する必要はありません。 RKEY単独で既存の元を識別するために十分です。"
    },
    {
      "indent": 3,
      "text": "The peer responds by simply echoing the message with the response flag set. If the peer did not recognize an RKey, a negative response flag will be set; however, no aggressive recovery action beyond logging the error will be taken.",
      "ja": "ピアは単に応答フラグが設定されたメッセージをエコーすることによって応答します。ピアがRKEYを認識しなかった場合、否定応答フラグが設定されます。しかし、エラーをログに記録を超えていない積極的な回復措置が取られません。"
    },
    {
      "indent": 3,
      "text": "The contents of the DELETE RKEY LLC message are:",
      "ja": "DELETE RKEY LLCメッセージの内容は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "Type",
      "ja": "タイプ"
    },
    {
      "indent": 6,
      "text": "Type 9 indicates DELETE RKEY.",
      "ja": "タイプ9は、Deleteキーを示します。"
    },
    {
      "indent": 3,
      "text": "Length",
      "ja": "長さ"
    },
    {
      "indent": 6,
      "text": "The DELETE RKEY LLC message is 44 bytes long.",
      "ja": "DELETE RKEY LLCのメッセージは、44バイト長です。"
    },
    {
      "indent": 3,
      "text": "R",
      "ja": "R"
    },
    {
      "indent": 6,
      "text": "Reply flag. When set, indicates that this is a DELETE RKEY reply.",
      "ja": "フラグを返信します。設定した場合、これはDELETE RKEY応答であることを示しています。"
    },
    {
      "indent": 3,
      "text": "0",
      "ja": "０"
    },
    {
      "indent": 6,
      "text": "Reserved bit.",
      "ja": "予約ビット。"
    },
    {
      "indent": 3,
      "text": "Z",
      "ja": "とともに"
    },
    {
      "indent": 6,
      "text": "Negative response flag.",
      "ja": "否定応答フラグ。"
    },
    {
      "indent": 3,
      "text": "Count",
      "ja": "カウント"
    },
    {
      "indent": 6,
      "text": "Number of RMBs being deleted by this message. Maximum value is 8.",
      "ja": "RMBSの番号は、このメッセージによって削除されています。最大値は8です。"
    },
    {
      "indent": 3,
      "text": "Error Mask",
      "ja": "エラーマスク"
    },
    {
      "indent": 6,
      "text": "If this is a negative response, indicates which RMBs were not successfully deleted. Each bit corresponds to a listed RMB; for example, b'01010000' indicates that the second and fourth RKeys weren't successfully deleted.",
      "ja": "これは否定応答である場合は、正常に削除されなかったRMBSを示しています。各ビットは、リストされた元に対応します。例えば、b'01010000' は、第2及び第RKeysが正常に削除されなかったことを示しています。"
    },
    {
      "indent": 3,
      "text": "Deleted RKeys",
      "ja": "削除されたRKeys"
    },
    {
      "indent": 6,
      "text": "A list of Count RKeys. Provided on the request flow and echoed back on the response flow. Each RKey is valid on the link over which this message is sent and represents a deleted RMB. Up to eight RMBs can be deleted in this message.",
      "ja": "カウントRKeysのリスト。要求フロー上に設けられ、応答フローにエコーバック。各RKEYには、このメッセージが送信されるリンク上で有効であり、削除元を表します。最大8件のRMBSは、このメッセージに削除することができます。"
    },
    {
      "indent": 0,
      "text": "A.3.8. TEST LINK LLC Message Format",
      "ja": "A.3.8。 TEST LINK LLCのメッセージ形式"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Type = 7     |  Length = 44  |   Reserved    |R|  Reserved   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n+-                                                             -+\n|                                                               |\n+-                         User Data                           -+\n|                                                               |\n+-                                                             -+\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n+-                                                             -+\n|                                                               |\n+-                                                             -+\n|                          Reserved                             |\n+-                                                             -+\n|                                                               |\n+-                                                             -+\n|                                                               |\n+-                                                             -+\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 18,
      "text": "Figure 40: TEST LINK LLC Message Format",
      "ja": "図40：TEST LINK LLCメッセージ形式"
    },
    {
      "indent": 3,
      "text": "The TEST LINK request can be sent from either peer to the other on an existing SMC-R link at any time to test that the SMC-R link is active and healthy at the software level. A peer that receives a TEST LINK LLC message immediately sends back a TEST LINK reply, echoing back the user data. Refer also to Section 4.5.3 (\"TCP Keepalive Processing\").",
      "ja": "テストリンク要求がSMC-Rリンクはソフトウェアレベルでアクティブと健康であることをテストするために、いつでも既存のSMC-Rリンク上の他のいずれかのピアから送信することができます。直ちにTESTリンクLLCメッセージを受信するピアは、ユーザデータをエコーバック、テストリンク応答を送り返します。 4.5.3項（「TCPキープアライブ処理」）も参照してください。"
    },
    {
      "indent": 3,
      "text": "The contents of the TEST LINK LLC message are:",
      "ja": "TESTリンクLLCメッセージの内容は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "Type",
      "ja": "タイプ"
    },
    {
      "indent": 6,
      "text": "Type 7 indicates TEST LINK.",
      "ja": "タイプ7は、テストリンクを示します。"
    },
    {
      "indent": 3,
      "text": "Length",
      "ja": "長さ"
    },
    {
      "indent": 6,
      "text": "The TEST LINK LLC message is 44 bytes long.",
      "ja": "TEST LINK LLCのメッセージは、44バイト長です。"
    },
    {
      "indent": 3,
      "text": "R",
      "ja": "R"
    },
    {
      "indent": 6,
      "text": "Reply flag. When set, indicates that this is a TEST LINK reply.",
      "ja": "フラグを返信します。設定した場合、これはテストリンク応答であることを示しています。"
    },
    {
      "indent": 3,
      "text": "User Data",
      "ja": "ユーザデータ"
    },
    {
      "indent": 6,
      "text": "The receiver of this message echoes the sender's data back in a TEST LINK response LLC message.",
      "ja": "このメッセージの受信者は、バックテストリンク応答LLCメッセージで送信者のデータをエコー。"
    },
    {
      "indent": 0,
      "text": "A.4. Connection Data Control (CDC) Message Format",
      "ja": "A.4。接続データコントロール（CDC）メッセージフォーマット"
    },
    {
      "indent": 3,
      "text": "The RMBE control data is communicated using Connection Data Control (CDC) messages, which use RoCE SendMsg, similar to LLC messages. Also, as with LLC messages, CDC messages are 44 bytes long to ensure that they can fit into private data areas of receive WQEs without requiring the receiver to post receive buffers.",
      "ja": "RMBE制御データは、LLCメッセージと同様ROCE SENDMSGを使用する接続データコントロール（CDC）メッセージを用いて通信されます。また、LLCのメッセージと同様に、CDCのメッセージは、彼らが受信バッファを投稿する受信機を必要とせずに受け取るのWQEのプライベートデータ領域に収まることができることを保証するために44バイト長です。"
    },
    {
      "indent": 3,
      "text": "Unlike LLC messages, this data is integral to the data path, so its processing must be prioritized and optimized similarly to other data path processing. While LLC messages may be processed on a slower path than data, these messages cannot be.",
      "ja": "LLCのメッセージとは異なり、このデータは、データパスに不可欠であるので、その処理は、他のデータパス処理と同様に優先順位付けし、最適化する必要があります。 LLCメッセージがデータより遅いパスで処理することができるが、これらのメッセージは、することはできません。"
    },
    {
      "indent": 3,
      "text": "    0                   1                   2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n0  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   | Type = x'FE'  | Length = 44   |      Sequence number          |\n4  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                       SMC-R alert token                       |\n8  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |         Reserved              | Producer cursor wrap seqno    |\n12 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                       Producer Cursor                         |\n16 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |         Reserved              | Consumer cursor wrap seqno    |\n20 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                       Consumer Cursor                         |\n24 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |B|P|U|R|F|Rsrvd|D|C|A|             Reserved                    |\n28 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                                                               |\n32 +-                                                             -+\n   |                                                               |\n36 +-                         Reserved                            -+\n   |                                                               |\n40 +-                                                             -+\n   |                                                               |\n44 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 10,
      "text": "Figure 41: Connection Data Control (CDC) Message Format",
      "ja": "図41：接続データコントロール（CDC）メッセージフォーマット"
    },
    {
      "indent": 3,
      "text": "Type = x'FE'",
      "ja": "タイプ= X'FE」"
    },
    {
      "indent": 6,
      "text": "This type number has the two high-order bits turned on to enable processing to quickly distinguish it from an LLC message.",
      "ja": "このタイプの数は、上位2ビットが迅速LLCメッセージからそれを区別するための処理を可能にするために有効になっています。"
    },
    {
      "indent": 3,
      "text": "Length = 44",
      "ja": "長さ= 44"
    },
    {
      "indent": 6,
      "text": "The length of inline data that does not require the posting of a receive buffer.",
      "ja": "受信バッファの投稿を必要としないインラインデータの長さ。"
    },
    {
      "indent": 3,
      "text": "Sequence number",
      "ja": "シーケンス番号"
    },
    {
      "indent": 6,
      "text": "A 2-byte unsigned integer that represents a wrapping sequence number. The initial value is 1, and this value can wrap to 0. Incremented with every control message sent, except for the failover data validation message, and used to guard against processing an old control message out of sequence. Also used in failover data validation. In normal usage, if this number is less than the last received value, discard this message. If greater, process this message. Old control messages can be lost with no ill effect but cannot be processed after newer ones.",
      "ja": "ラッピングシーケンス番号を示す2バイトの符号なし整数。初期値は1であり、この値は、フェイルオーバーデータ検証メッセージを除いて、送信されるすべての制御メッセージでインクリメント0にラップ、およびシーケンス外古い制御メッセージの処理を防ぐために使用することができます。また、フェイルオーバーデータの検証に使用されます。通常の使用において、この数が最後に受信した値より小さい場合、このメッセージを破棄する。大きい場合は、このメッセージを処理します。旧制御メッセージはありません病気に効果が失われることがありますが、新しいものの後に処理することはできません。"
    },
    {
      "indent": 6,
      "text": "If this is a failover validation CDC message (F flag set), then the receiver must verify that it has received and fully processed the RDMA write that was described by the CDC message with the sequence number in this message. If not, the TCP connection must be reset to guard against data loss. Details of this processing are provided in Section 4.6.1.",
      "ja": "これは、フェイルオーバーの検証CDCメッセージ（Fフラグのセット）である場合、受信機は、受信完全このメッセージにシーケンス番号を持つCDCメッセージによって記述されたRDMA書き込みを処理したことを確認しなければなりません。そうでない場合、TCP接続は、データの損失を防ぐためにリセットする必要があります。この処理の詳細は、セクション4.6.1で提供されています。"
    },
    {
      "indent": 3,
      "text": "SMC-R alert token",
      "ja": "SMC-Rのアラートトークン"
    },
    {
      "indent": 6,
      "text": "The endpoint-assigned alert token that identifies to which TCP connection on the link group this control message refers.",
      "ja": "この制御メッセージが参照リンク・グループのどのTCPコネクションを識別するエンドポイントに割り当てられたアラートトークン。"
    },
    {
      "indent": 3,
      "text": "Producer cursor wrap seqno",
      "ja": "プロデューサーカーソルラップSEQNO"
    },
    {
      "indent": 6,
      "text": "A 2-byte unsigned integer that represents a wrapping counter incremented by the producer whenever the data written into this RMBE receive buffer causes a wrap (i.e., the producer cursor wraps). This is used by the receiver to determine when new data is available even though the cursors appear unchanged, such as when a full window size write is completed (producer cursor of this RMBE sent by peer = local consumer cursor) or in scenarios where the producer cursor sent for this RMBE < local consumer cursor.",
      "ja": "このRMBEに書き込まれたデータが受信バッファたびプロデューサだけ増分ラッピングカウンタを表す2バイトの符号なし整数（即ち、プロデューサカーソルラップ）ラップを引き起こします。これは、新しいデータは、フルウィンドウサイズの書き込みが完了したときのように（ピア=ローカル消費者のカーソルによって送信され、このRMBEの生産カーソル）またはプロデューサーシナリオで、カーソルはそのまま表示されていても利用可能であるときを決定するために受信機によって使用されますこのRMBE <現地消費者のカーソルのために送られたカーソル。"
    },
    {
      "indent": 3,
      "text": "Producer Cursor",
      "ja": "プロデューサーのカーソル"
    },
    {
      "indent": 6,
      "text": "A 4-byte unsigned integer that is a wrapping offset into the RMBE data area. Points to the next byte of data to be written by the sender. Can advance up to the receiver's consumer cursor as known by the sender. When the urgent data present indicator is on, points 1 byte beyond the last byte of urgent data. When computing this cursor, the presence of the eye catcher in the RMBE data area must be accounted for. The first writable data location in the RMBE is at offset 4, so this cursor begins at 4 and wraps to 4.",
      "ja": "RMBEデータ領域へのオフセットラッピングである4バイトの符号なし整数。送信者によって書き込まれるデータの次のバイトを指します。送信者が知られているように、受信機の消費者のカーソルまで進めることができます。緊急データ存在インジケータがオンになっている場合は、緊急データの最後のバイトを超えて1つのバイトを指します。このカーソルを計算するとき、RMBEデータ領域のアイキャッチャーの存在が考慮されなければなりません。 RMBEにおける最初の書き込み可能なデータ位置が4のオフセットであるので、このカーソルは4から始まり、4に折り返さ。"
    },
    {
      "indent": 3,
      "text": "Consumer cursor wrap seqno",
      "ja": "消費者のカーソルラップSEQNO"
    },
    {
      "indent": 6,
      "text": "A 2-byte unsigned integer that mirrors the value of the producer cursor wrap sequence number when the last read from this RMBE occurred. Used as an indicator of how far along the consumer is in reading data (i.e., processed last wrap point or not). The producer side can use this indicator to detect whether or not more data can be written to the partner in full window write scenarios (where the producer cursor = consumer cursor as known on the remote RMBE). In this scenario, if the consumer sequence number equals the local producer sequence number, the producer knows that more data can be written.",
      "ja": "このRMBEから最後の読み取りが発生プロデューサカーソルラップ・シーケンス番号の値を反映する2バイトの符号なし整数。どこまで消費者に沿っての指標として使用（すなわち、処理された最後のラップポイントまたはしない）データ読み出しです。生産者側はより多くのデータがフルウィンドウライトシナリオ（リモートRMBEに知られているように、プロデューサカーソルが=消費者のカーソル）のパートナーに書き込むことができるか否かを検出するために、このインジケータを使用することができます。消費者のシーケンス番号が地元生産者シーケンス番号と等しい場合、このシナリオでは、プロデューサーには、より多くのデータを書き込むことができることを知っています。"
    },
    {
      "indent": 3,
      "text": "Consumer Cursor",
      "ja": "消費者のカーソル"
    },
    {
      "indent": 6,
      "text": "A 4-byte unsigned integer that is a wrapping offset into the sender's RMBE data area. Points to the offset of the next byte of data to be consumed by the peer in its own RMBE. When computing this cursor, the presence of the eye catcher in the RMBE data area must be accounted for. The first writable data location in the RMBE is at offset 4, so this cursor begins at 4 and wraps to 4. The sender cannot write beyond this cursor into the peer's RMBE without causing data loss.",
      "ja": "送信者RMBEデータ領域へのオフセットラッピングである4バイトの符号なし整数。独自のRMBEにピアによって消費されるデータの次のバイトのオフセットを指します。このカーソルを計算するとき、RMBEデータ領域のアイキャッチャーの存在が考慮されなければなりません。 RMBEにおける最初の書き込み可能なデータ位置が4のオフセットであるので、このカーソルは4で開始し、送信側がデータの損失を引き起こすことなく、ピアのRMBEにこのカーソルを超えて書き込むことができない4にラップ。"
    },
    {
      "indent": 3,
      "text": "B-bit",
      "ja": "Bビット"
    },
    {
      "indent": 6,
      "text": "Writer blocked indicator: Sender is blocked for writing. If this bit is set, sender will require explicit notification when receive buffer space is available.",
      "ja": "ライターブロックされたインジケータ：送信者は書き込みのためにブロックされています。このビットがセットされている場合は、受信バッファスペースが利用可能な場合、送信者は、明示的な通知が必要になります。"
    },
    {
      "indent": 3,
      "text": "P-bit",
      "ja": "Pビット"
    },
    {
      "indent": 6,
      "text": "Urgent data pending: Sender has urgent data pending for this connection.",
      "ja": "緊急データ保留：Senderは、この接続のために保留中の緊急データを持っています。"
    },
    {
      "indent": 3,
      "text": "U-bit",
      "ja": "Uビット"
    },
    {
      "indent": 6,
      "text": "Urgent data present: Indicates that urgent data is present in the RMBE data area, and the producer cursor points to 1 byte beyond the last byte of urgent data.",
      "ja": "緊急データの存在：緊急データはRMBEデータ領域に存在していることを示し、かつ緊急データの最後のバイトを超えた1バイトのプロデューサーカーソルポイント。"
    },
    {
      "indent": 3,
      "text": "R-bit",
      "ja": "Rビット"
    },
    {
      "indent": 6,
      "text": "Request for consumer cursor update: Indicates that an immediate consumer cursor update is requested, regardless of whether or not one is warranted according to the window size optimization algorithm described in Section 4.5.1.",
      "ja": "消費者のカーソルの更新の要求は：即時消費者のカーソルの更新は、かどうかにかかわらず一方の、要求されたセクション4.5.1に記載のウィンドウサイズの最適化アルゴリズムに従って保証されていることを示します。"
    },
    {
      "indent": 3,
      "text": "F-bit",
      "ja": "F-ビット"
    },
    {
      "indent": 6,
      "text": "Failover validation indicator: Sent by a peer to guard against data loss during failover when the TCP connection is being moved to another SMC-R link in the link group. When this bit is set, the only other fields in the CDC message that are significant are the Type, Length, SMC-R alert token, and Sequence number fields. The receiver must validate that it has fully processed the RDMA write described by the previous CDC message bearing the same sequence number as this validation message. If it has, no further action is required. If it has not, the TCP connection must be reset. This processing is described in detail in Section 4.6.1.",
      "ja": "フェイルオーバ検証インジケータ：TCP接続がリンクグループ内の別のSMC-Rリンクに移動している場合、フェイルオーバー時のデータ損失を防ぐためにピアによって送信されます。このビットが設定されている場合、有意であるCDCメッセージの唯一の他のフィールドは、タイプ、長さ、SMC-Rアラートトークン、およびシーケンス番号フィールドです。受信機は、それが完全にこの検証メッセージと同じシーケンス番号を担持する前のCDCメッセージによって記述RDMA書き込みを処理したことを検証しなければなりません。それが持っている場合は、それ以上のアクションは必要ありません。それはしていない場合は、TCP接続をリセットする必要があります。この処理は、4.6.1節で詳細に記載されています。"
    },
    {
      "indent": 3,
      "text": "D-bit",
      "ja": "Dビット"
    },
    {
      "indent": 6,
      "text": "Sending done indicator: Sent by a peer when it is done writing new data into the receiver's RMBE data area.",
      "ja": "それは、受信機のRMBEデータ領域に新しいデータを書き込むことで行われるピアによって送信された：行わインジケータを送信します。"
    },
    {
      "indent": 3,
      "text": "C-bit",
      "ja": "Cビット"
    },
    {
      "indent": 6,
      "text": "PeerConnectionClosed indicator: Sent by a peer when it is completely done with this connection and will no longer be making any updates to the receiver's RMBE or sending any more control messages.",
      "ja": "PeerConnectionClosedインジケータ：それは完全にこの接続で行われ、もはや受信者のRMBEへの更新を行っていないか、それ以上の制御メッセージを送信することになるときピアによって送信されます。"
    },
    {
      "indent": 3,
      "text": "A-bit",
      "ja": "ビット"
    },
    {
      "indent": 6,
      "text": "Abnormal close indicator: Sent by a peer when the connection is abnormally terminated (for example, the TCP connection was reset). When sent, it indicates that the peer is completely done with this connection and will no longer be making any updates to this RMBE or sending any more control messages. It also indicates that the RMBE owner must flush any remaining data on this connection and generate an error return code to any outstanding socket APIs on this connection (same processing as receiving a RST segment on a TCP connection).",
      "ja": "異常近いインジケータ：接続が異常終了したピアによって送信され（例えば、TCP接続がリセットされました）。送信された場合は、ピアは完全にこの接続で行われ、もはやこのRMBEへの更新を行っていないか、それ以上の制御メッセージを送信することを示します。またRMBE所有者は、この接続上の任意の残りのデータをフラッシュし、この接続（TCP接続にRSTセグメントを受信したと同様の処理）に未処理のソケットAPIにエラー戻りコードを生成しなければならないことを示しています。"
    },
    {
      "indent": 0,
      "text": "Appendix B. Socket API Considerations",
      "ja": "付録B.ソケットAPIの考慮事項"
    },
    {
      "indent": 3,
      "text": "A key design goal for SMC-R is to require no application changes for exploitation. It is confined to socket applications using stream (i.e., TCP) sockets over IPv4 or IPv6. By virtue of the fact that the switch to the SMC-R protocol occurs after a TCP connection is established, no changes are required in a socket address family or in the IP addresses and ports that the socket applications are using. Existing socket APIs that allow applications to retrieve local and remote socket address structures for an established TCP connection (for example, getsockname() and getpeername()) will continue to function as they have before. Existing DNS setup and APIs for resolving hostnames to IP addresses and vice versa also continue to function without any changes. In general, all of the usual socket APIs that are used for TCP communications (send APIs, recv APIs, etc.) will continue to function as they do today, even if SMC-R is used as the underlying protocol.",
      "ja": "SMC-Rのための重要な設計目標は、搾取のためのアプリケーションの変更を必要としないことです。これは、ストリームIPv4またはIPv6上（すなわち、TCP）ソケットを使用して、ソケット・アプリケーションに制限されます。 TCP接続が確立された後、SMC-Rのプロトコルへの切り替えが発生したという事実によって、変更はソケットアドレスファミリーまたはソケットアプリケーションが使用しているIPアドレスおよびポートで必要とされません。アプリケーションは、確立されたTCP接続のためのローカルおよびリモートのソケットアドレス構造体を取得することができ、既存のソケットAPI（たとえば、のgetsockname（）とgetpeernameのためには、（））、彼らが前に持っているとして機能し続けます。ホスト名をIPアドレスに解決し、その逆も変更せずに機能し続けるためにDNSの設定とAPIを既存の。彼らは今日そうであるように、一般的には、TCPの通信に使用される通常のソケットAPI（などのAPI、RECV APIを、送信）の全ては、SMC-Rは、基本的なプロトコルとして使用されていても、機能し続けます。"
    },
    {
      "indent": 3,
      "text": "Each SMC-R-enabled implementation does, however, need to pay special attention to any socket APIs that have a reliance on the underlying TCP and IP protocols and also ensure that their behavior in an SMC-R environment is reasonable and minimizes impact on the application. While the basic socket API set is fairly similar across different operating systems, there is more variability when it comes to advanced socket API options. Each implementation needs to perform a detailed analysis of its API options, any possible impact that SMC-R may have, and any resultant implications. As part of that step, a discussion or review with other implementations supporting SMC-R would be useful to ensure consistent implementation.",
      "ja": "各SMC-R対応の実装では、しかし、また、SMC-R環境での彼らの行動は合理的であると上の影響を最小限に抑えることを保証する基本的なTCPとIPのプロトコルへの依存度を持っており、任意のソケットAPIに特別な注意を払う必要がありません応用。基本的なソケットAPIセットが異なるオペレーティングシステム間でかなり類似しているが、それは、高度なソケットAPIのオプションに来るとき、多くのばらつきがあります。各実装は、そのAPIのオプションの詳細な分析、SMC-Rが持つかもしれない可能性への影響、および任意の結果の意味合いを実行する必要があります。そのステップの一部として、SMC-Rを支持する他の実装との話し合いやレビューは、一貫した実施を確保するために有用であろう。"
    },
    {
      "indent": 0,
      "text": "B.1. setsockopt() / getsockopt() Considerations",
      "ja": "B.1。 setsockopt（）/はgetsockopt（）の注意事項"
    },
    {
      "indent": 3,
      "text": "These APIs allow socket applications to manipulate socket, transport (TCP/UDP), and IP-level options associated with a given socket. Typically, a platform restricts the number of IP options available to stream (TCP) socket applications, given their connection-oriented nature. The general guideline here is to continue processing these APIs in a manner that allows for application compatibility. Some options will be relevant to the SMC-R protocol and will require special processing \"under the covers\". For example, the ability to manipulate TCP send and receive buffer sizes is still valid for SMC-R. However, other options may have no meaning for SMC-R. For example, if an application enabled the TCP_NODELAY socket option to disable Nagle's algorithm, it should have no real effect on SMC-R communications, as there is no notion of Nagle's algorithm with this new protocol. But the implementation must accept the TCP_NODELAY option as it does today and save it so that it can be later extracted via getsockopt() processing. Note that any TCP or IP-level options will still have an effect on any TCP/IP packets flowing for an SMC-R connection (i.e., as part of TCP/IP connection establishment and TCP/IP connection termination packet flows).",
      "ja": "これらのAPIは、ソケットアプリケーションがソケット、トランスポート（TCP / UDP）、および特定のソケットに関連付けられたIPレベルのオプションを操作することができます。一般的に、プラットフォームは、接続指向の性質を考えると、（TCP）ソケットアプリケーションをストリーミングするために利用できるIPオプションの数を制限します。ここでの一般的なガイドラインは、アプリケーションの互換性を可能にするように、これらのAPIの処理を継続することです。一部のオプションは、SMC-Rプロトコルに関連するだろうし、「アンダーカバー」の特別な処理が必要になります。たとえば、TCP送信を操作し、バッファサイズを受信する機能はまだSMC-Rに対して有効です。しかし、他のオプションは、SMC-Rに対しては意味を持たないことがあります。アプリケーションは、Nagleアルゴリズムを無効にするTCP_NODELAYソケットオプションを有効にした場合、この新しいプロトコルとNagleアルゴリズムの概念がないので、例えば、それは、SMC-R通信には、実際の影響はないはずです。しかし、実装は、それが今日そうであるようTCP_NODELAYオプションを受け入れ、それは後でのgetsockopt（）処理を介して抽出することができるようにそれを保存する必要があります。任意のTCPまたはIPレベルのオプションは依然として（すなわち、TCP / IP接続の確立とTCP / IP接続終了パケットフローの一部として）SMC-R接続用流れる任意のTCP / IPパケットに影響を与えるであろうことに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "Under the covers, manipulation of the TCP options will also include the SMC-layer setting, as well as reading the SMC-R experimental option before and after completion of the three-way TCP handshake.",
      "ja": "カバーの下に、TCPオプションの操作はまた、SMC-層の設定が含まれます、だけでなく、3ウェイTCPハンドシェイクが完了する前と後のSMC-R実験的なオプションを読みました。"
    },
    {
      "indent": 0,
      "text": "Appendix C. Rendezvous Error Scenarios",
      "ja": "付録C.ランデブーエラーのシナリオ"
    },
    {
      "indent": 3,
      "text": "This section discusses error scenarios for setting up and managing SMC-R links.",
      "ja": "このセクションでは、SMC-Rへのリンクを設定し、管理するためのエラーのシナリオについて説明します。"
    },
    {
      "indent": 0,
      "text": "C.1. SMC Decline during CLC Negotiation",
      "ja": "C.1。 CLC交渉中のSMC衰退"
    },
    {
      "indent": 3,
      "text": "A peer to the SMC-R CLC negotiation can send an SMC Decline in lieu of any expected CLC message to decline SMC and force the TCP connection back to the IP fabric. There can be several reasons for an SMC Decline during the CLC negotiation, including the following:",
      "ja": "SMC-R CLCネゴシエーションにピアがSMCを拒否し、バックIPファブリックへのTCP接続を強制することが予想されるCLCメッセージの代わりに、SMCの低下を送信することができます。以下を含むCLC交渉中のSMC衰退、いくつかの理由がある場合もあります。"
    },
    {
      "indent": 3,
      "text": "o RNIC went down",
      "ja": "O RNICがダウンしました"
    },
    {
      "indent": 3,
      "text": "o SMC-R forbidden by local policy",
      "ja": "SMC-R Oローカルポリシーで禁止"
    },
    {
      "indent": 3,
      "text": "o subnet (IPv4) or prefix (IPv6) doesn't match",
      "ja": "Oサブネット（IPv4）のか、接頭辞（IPv6）が一致していません。"
    },
    {
      "indent": 3,
      "text": "o lack of resources to perform SMC-R",
      "ja": "Oリソースの不足は、SMC-Rを実行します"
    },
    {
      "indent": 3,
      "text": "In all cases, when an SMC Decline is sent in lieu of an expected CLC message, no confirmation is required, and the TCP connection immediately falls back to using the IP fabric.",
      "ja": "SMCの低下が予想されるCLCメッセージの代わりに送信されたすべてのケースでは、何の確認が必要とされない、とのTCP接続がすぐにIPファブリックを使用するようにフォールバックします。"
    },
    {
      "indent": 3,
      "text": "To prevent ambiguity between CLC messages and application data, an SMC Decline cannot \"chase\" another CLC message. An SMC Decline can only be sent in lieu of an expected CLC message. For example, if the client sends an SMC Proposal and then its RNIC goes down, it must wait for the SMC Accept from the server and then reply to the SMC Accept with an SMC Decline.",
      "ja": "CLCメッセージとアプリケーションデータ間の曖昧さを防ぐために、他のCLCメッセージSMC辞退することができます「追いかける」ではありません。 SMCの減少が予想されるだけCLCメッセージの代わりに送信することができます。例えば、クライアントは、SMCの提案を送信した場合、その後、そのRNICがダウンし、それがサーバから受け入れ、その後、SMCの低下と受け入れSMCに返信SMCのを待たなければなりません。"
    },
    {
      "indent": 3,
      "text": "This \"no chase\" rule means that if this TCP connection is not a first contact between RoCE peers, a server cannot send an SMC Decline after sending an SMC Accept -- it can only either break the TCP connection or fail over if a problem arises in the RoCE fabric after it has sent the SMC Accept. Similarly, once the client sends an SMC Confirm on a TCP connection that isn't a first contact, it is committed to SMC-R for this TCP connection and cannot fall back to IP.",
      "ja": "この「ノー追いかける」のルールは、このTCP接続がROCEピア間の最初の接触でない場合、サーバはSMCが受け入れる送信後、SMCの低下を送信できないことを意味します - それはどちらか一方のみのTCP接続を切断したり、問題が発生した場合にフェイルオーバーすることができますROCEの生地にはSMCが受け入れ送信した後。クライアントが送信すると同様に、SMCは、それがこのTCP接続のためのSMC-Rにコミットしている最初の接触ではなく、バックIPにフォールすることはできませんTCP接続で確認してください。"
    },
    {
      "indent": 0,
      "text": "C.2. SMC Decline during LLC Negotiation",
      "ja": "C.2。 LLCネゴシエーション中にSMC衰退"
    },
    {
      "indent": 3,
      "text": "For a TCP connection that represents a first contact between RoCE pairs, it is possible for SMC to fall back to IP during the LLC negotiation. This is possible until the first contact SMC-R link is confirmed. For example, see Figure 42. After a first contact SMC-R link is confirmed, fallback to IP is no longer possible. This translates to the following rule: a first contact peer can send an",
      "ja": "SMCは、LLCネゴシエーション中にバックIPに落下するためROCEペア間の最初の接触を表しTCP接続の場合、それが可能です。最初の接点SMC-Rのリンクが確認されるまで、これが可能です。例えば、第一のコンタクトSMC-Rのリンクが確認された後、IPにフォールバック図42を参照することはできなくなりました。これは、次のルールに変換されます：最初のコンタクトピアが送信することができます"
    },
    {
      "indent": 3,
      "text": "SMC Decline at any time during LLC negotiation until it has successfully sent its CONFIRM LINK (request or response) flow. After that point, it cannot fall back to IP.",
      "ja": "LLCネゴシエーション中にいつでもSMC衰退それはそのCONFIRMのLINK（要求または応答）の流れを正常に送信するまで。そのポイントの後、それが戻ってIPにフォールすることはできません。"
    },
    {
      "indent": 4,
      "text": "   Host X -- Server                           Host Y -- Client\n+-------------------+                      +-------------------+\n| Peer ID = PS1     |                      |   Peer ID = PC1   |\n|            +------+                      +------+            |\n|       QP 8 |RNIC 1|    SMC-R Link 1      |RNIC 2|  QP 64     |\n| RKey X |   |MAC MA|<-------------------->|MAC MB|   |        |\n|        |   |GID GA|   attempted setup    |GID GB|   | RKey Y2|\n|       \\/   +------+                      +------+  \\/        |\n|+--------+         |                      |        +--------+ |\n|| RMB    |         |                      |        | RMB    | |\n|+--------+         |                      |        +--------+ |\n|       /\\   +------+                      +------+  /\\        |\n|        |   |RNIC 3|                      |RNIC 4|   | RKey W2|\n|        |   |MAC MC|                      |MAC MD|   |        |\n|       QP 9 |GID GC|                      |GID GD|  QP 65     |\n|            +------+                      +------+            |\n+-------------------+                      +-------------------+",
      "raw": true
    },
    {
      "indent": 9,
      "text": " SYN / SYN-ACK / ACK TCP three-way handshake with TCP option\n<--------------------------------------------------------->",
      "raw": true
    },
    {
      "indent": 9,
      "text": "   SMC Proposal / SMC Accept / SMC Confirm exchange\n<-------------------------------------------------------->",
      "raw": true
    },
    {
      "indent": 9,
      "text": "  CONFIRM LINK(request, Link 1)\n.........................................................>",
      "raw": true
    },
    {
      "indent": 27,
      "text": "CONFIRM LINK(response, Link 1)\n   X...................................\n     :\n     : RoCE write failure\n     :.................................>",
      "raw": true
    },
    {
      "indent": 10,
      "text": " SMC Decline(PC1, reason code)\n<--------------------------------------------------------",
      "raw": true
    },
    {
      "indent": 10,
      "text": "    Connection data flows over IP fabric\n<------------------------------------------------------->",
      "raw": true
    },
    {
      "indent": 19,
      "text": "       Legend:\n------------   TCP/IP and CLC flows\n............   RoCE (LLC) flows",
      "raw": true
    },
    {
      "indent": 15,
      "text": "Figure 42: SMC Decline during LLC Negotiation",
      "ja": "図42：LLCネゴシエーション中にSMC下落"
    },
    {
      "indent": 0,
      "text": "C.3. The SMC Decline Window",
      "ja": "C.3。 SMCの辞退ウィンドウ"
    },
    {
      "indent": 3,
      "text": "Because SMC-R does not support fallback to IP for a TCP connection that is already using RDMA, there are specific rules on when the SMC Decline CLC message, which signals a fallback to IP because of an error or problem with the RoCE fabric, can be sent during TCP connection setup. There is a \"point of no return\" after which a connection cannot fall back to IP, and RoCE errors that occur after this point require the connection to be broken with a RST flow in the IP fabric.",
      "ja": "SMC-Rは既にRDMAを使用しているTCP接続のIPへのフォールバックをサポートしていないため、SMCが原因ROCE布を持つエラーまたは問題のIPへのフォールバックを信号CLCメッセージを拒否するときに特定のルールができ、ありますTCP接続のセットアップ時に送られます。そこの接続が戻っIPに該当しないことができた後に「ノーリターンのポイントは」あり、この点の後に発生ROCEエラーがIPファブリック内のRSTの流れで破壊する接続が必要です。"
    },
    {
      "indent": 3,
      "text": "For a first contact, that point of no return is after the ADD LINK LLC message has been successfully sent for the second SMC-R link. Specifically, the server cannot fall back to IP after receiving either (1) a positive write completion indication for the ADD LINK request or (2) the ADD LINK response from the client, whichever comes first. The client cannot fall back to IP after sending a negative ADD LINK response, receiving a positive write complete on a positive ADD LINK response, or receiving a CONFIRM LINK for the second SMC-R link from the server, whichever comes first.",
      "ja": "ADDリンクLLCメッセージが正常に第SMC-Rリンクに送信された後の最初の接触のため、ノーリターンの点です。具体的には、サーバは、いずれか早い方のクライアント、からADDリンク要求または（2）ADDリンク応答（1）正の書き込み完了指示のいずれかを受信した後、バックIPに落下することはできません。クライアントは、負のADD LINK応答を送信する正のADD LINK応答に完全な正の書き込みを受け、またはいずれか早い方のサーバから第二SMC-RリンクのCONFIRMのLINKを受けた後、バックIPにフォールすることはできません。"
    },
    {
      "indent": 3,
      "text": "For a subsequent contact, that point of no return is after the last send of the CLC negotiation completes. This, in combination with the rule that error \"chasers\" are not allowed during CLC negotiation, means that the server cannot send an SMC Decline after sending an SMC Accept, and the client cannot send an SMC Decline after sending an SMC Confirm.",
      "ja": "CLC交渉の最後の送信が完了した後、後続の接触のため、ノーリターンのポイントです。これは、エラー「フリーク」はCLCネゴシエーション中に許可されていないルールとの組み合わせで、サーバは受け入れ、クライアントは確認してSMCを送信した後、SMCの低下を送信することはできませんSMCを送信した後、SMCの低下を送信できないことを意味します。"
    },
    {
      "indent": 0,
      "text": "C.4. Out-of-Sync Conditions during SMC-R Negotiation",
      "ja": "C.4。同期外れ条件SMC-R交渉中"
    },
    {
      "indent": 3,
      "text": "The SMC Accept CLC message contains a first contact flag that indicates to the client whether the server believes it is setting up a new link group or using an existing link group. This flag is used to detect an out-of-sync condition between the client and the server. The scenario for such a condition is as follows: there is a single existing SMC-R link between the peers. After the client sends the SMC Proposal CLC message, the existing SMC-R link between the client and the server fails. The client cannot chase the SMC Proposal CLC message with an SMC Decline CLC message in this case, because the client does not yet know that the server would have wanted to choose the SMC-R link that just crashed. The QP that failed recovers before the server returns its SMC Accept CLC message. This means that there is a QP but no SMC-R link. Since the server had not yet learned of the SMC-R link failure when it sent the SMC Accept CLC message, it attempts to reuse the SMC-R link that just failed. This means that the server would not set the first contact flag, indicating to the client that the server thinks it is reusing an SMC-R link. However, the client does not have an SMC-R link that matches the server's specification. Because the first contact flag is off, the client realizes it is out of sync with the server and sends an SMC Decline to cause the connection to fall back to IP.",
      "ja": "SMCは、CLCメッセージを受け入れるサーバは、それが新たなリンクグループを設定するか、既存のリンクグループを使用していると考えているかどうかをクライアントに示す第1のコンタクトフラグが含まれています。このフラグは、クライアントとサーバ間の同期外れ状態を検出するために使用されます。以下のような条件のシナリオがある：ピアとの間の単一の既存のSMC-Rのリンクがあります。クライアントは、SMC提案CLCメッセージを送信した後、クライアントとサーバの間の既存のSMC-Rのリンクは失敗します。クライアントは、クライアントがまだサーバがクラッシュしSMC-Rのリンクを選択したいと思っているだろうことを知っていないため、SMCとSMC提案CLCメッセージが、この場合にはCLCメッセージを断る追いかけることができません。サーバはそのSMCはCLC Acceptメッセージを返す前に、回復に失敗したQP。これは、QPが、無SMC-Rのリンクがあることを意味します。それはSMCはCLCメッセージを受け入れる送信したときに、サーバーがまだSMC-Rのリンク障害を知っていなかったので、それだけで失敗したSMC-Rのリンクを再利用しようとします。これは、サーバがサーバがSMC-Rのリンクを再利用していると考え、クライアントに示す、第一の接触フラグを設定しないことを意味します。ただし、クライアントは、サーバーの仕様に一致するSMC-Rのリンクを持っていません。最初の接触フラグがオフになっているので、クライアントは、サーバと同期していないと、接続がバックIPにフォールさせるためのSMCの低下を送り実現します。"
    },
    {
      "indent": 0,
      "text": "C.5. Timeouts during CLC Negotiation",
      "ja": "C.5。 CLCネゴシエーション中にタイムアウト"
    },
    {
      "indent": 3,
      "text": "Because the SMC-R negotiation flows as TCP data, there are built-in timeouts and retransmits at the TCP layer for individual messages. Implementations also must protect the overall TCP/CLC handshake with a timer or timers to prevent connections from hanging indefinitely due to SMC-R processing. This can be done with individual timers for individual CLC messages or an overall timer for the entire exchange, which may include the TCP handshake and the CLC handshake under one timer or separate timers. This decision is implementation dependent.",
      "ja": "SMC-RのネゴシエーションがTCPデータとして流れるので、そこにタイムアウトを内蔵しており、個々のメッセージのためのTCPレイヤで再送信されます。実装はまた、SMC-Rの処理に無限にハングからの接続を防ぐために、タイマーやタイマーで全体的なTCP / CLCハンドシェイクを保護する必要があります。これは、個々のCLCメッセージのための個々のタイマまたは1つのタイマーまたは別のタイマーの下でTCPハンドシェイクとCLCハンドシェイクを含むことが全体の交換のための全体的なタイマーで行うことができます。この決定は実装依存です。"
    },
    {
      "indent": 3,
      "text": "If the TCP and/or CLC handshakes time out, the TCP connection must be terminated as it would be in a legacy IP environment when connection setup doesn't complete in a timely manner. Because the CLC flows are TCP messages, if they cannot be sent and received in a timely fashion, the TCP connection is not healthy and would not work if fallback to IP were attempted.",
      "ja": "TCPおよび/またはCLCハンドシェイクがタイムアウトした場合、接続設定がタイムリーに完了しないときには、レガシーIP環境になるよう、TCPコネクションを終了する必要があります。彼らはタイムリーに送信され、受信できない場合はCLC・フローは、TCPメッセージであるため、TCP接続が正常でないとIPへのフォールバックが試みられた場合は動作しません。"
    },
    {
      "indent": 0,
      "text": "C.6. Protocol Errors during CLC Negotiation",
      "ja": "C.6。 CLC交渉中のプロトコルエラー"
    },
    {
      "indent": 3,
      "text": "Protocol errors occur during CLC negotiation when a message is received that is not expected. For example, a peer that is expecting a CLC message but instead receives application data has experienced a protocol error; this also indicates a likely software error, as the two sides are out of sync. When application data is expected, this data is not parsed to ensure that it's not a CLC message.",
      "ja": "メッセージを受信したときにプロトコルエラーが期待されていないことCLC交渉中に発生します。例えば、CLCメッセージを期待代わりにアプリケーションデータを受信して​​いるピアは、プロトコルエラーを経験しています。双方が同期していて、これはまた、おそらくソフトウェアエラーを示します。アプリケーションデータが期待されている場合、このデータは、CLCメッセージではないことを確認するために解析されません。"
    },
    {
      "indent": 3,
      "text": "When a peer is expecting a CLC negotiation message, any parsing error except a bad enumerated value in that message must be treated as application data. The CLC negotiation messages are designed with beginning and ending eye catchers to help verify that a CLC negotiation message is actually the expected message. If other parsing errors in an expected CLC message occur, such as incorrect length fields or incorrectly formatted fields, the message must be treated as application data.",
      "ja": "ピアがCLCネゴシエーションメッセージを予期している場合、そのメッセージの不良列挙された値以外の任意の解析エラーは、アプリケーション・データとして処理されなければなりません。 CLCネゴシエーションメッセージはCLCネゴシエーションメッセージは、実際に期待メッセージであることを確認助けるために最初と最後のアイキャッチャーに設計されています。予想CLCメッセージ内の他の構文解析エラーは、誤った長さフィールドまたは正しくフォーマットフィールドとして、発生した場合、メッセージは、アプリケーションデータとして扱われなければなりません。"
    },
    {
      "indent": 3,
      "text": "All protocol errors, with the exception of bad enumerated values, must result in termination of the TCP connection. No fallback to IP is allowed in the case of a protocol error, because if the protocols are out of sync, mismatched, or corrupted, then data and security integrity cannot be ensured.",
      "ja": "すべてのプロトコルエラーは、不正な列挙値を除いて、TCP接続の終了につながる必要があります。プロトコルは、同期がずれて一致していない、または破損した場合、そのデータとセキュリティの整合性が確保できないため、IPへのフォールバックは、プロトコルエラーの場合には許可されていません。"
    },
    {
      "indent": 3,
      "text": "The exception to this rule is enumerated values -- for example, the QP MTU values on SMC Accept and SMC Confirm. If a reserved value is received, the proper error response is to send an SMC Decline and fall back to IP; this is because the use of a reserved enumerated value indicates that the other partner likely has additional support that the receiving partner does not have. This indicated mismatch of SMC-R capabilities is not an integrity problem but indicates that SMC-R cannot be used for this connection.",
      "ja": "例えば、SMCのQP MTU値を受け入れ、SMCは確認して - この規則の例外は、値が列挙されています。予約値が受信された場合、適切なエラー応答がSMC衰退を送信し、IPにフォールバックすることです。予約済みの列挙値の使用は、他のパートナーが可能性の高い受信相手が持っていない追加のサポートを持っていることを示しているためです。 SMC-R機能のこの示された不一致は、整合性の問題ではなく、SMC-Rは、この接続に使用することができないことを示しています。"
    },
    {
      "indent": 0,
      "text": "C.7. Timeouts during LLC Negotiation",
      "ja": "C.7。 LLCネゴシエーション中にタイムアウト"
    },
    {
      "indent": 3,
      "text": "Whenever a peer sends an LLC message to which a reply is expected, it sets a timer after the send posts to wait for the reply. An expected response may be a reply flavor of the LLC message (for example, a CONFIRM LINK reply) or a new LLC message (for example, an ADD LINK CONTINUATION expected from the server by the client if there are more RKeys to be communicated).",
      "ja": "ピアが応答が期待されているLLCメッセージを送信するたびに、それは返事を待つために、送信ポスト後にタイマーを設定します。 （通信すべき複数RKeysがある場合、例えば、クライアントがサーバから予想されるのADD LINK継続）予想される応答は、（例えば、CONFIRMリンク応答）LLCメッセージまたは新しいLLCメッセージの返信風味であってもよいです。"
    },
    {
      "indent": 3,
      "text": "On LLC flows that are part of a first contact setup of a link group, the value of the timer is implementation dependent but should be long enough to allow the other peer to have a write complete timeout and 2-3 retransmits of an SMC Decline on the TCP fabric. For LLC flows that are maintaining the link group and are not part of a first contact setup of a link group, the timers may be shorter. Upon receipt of an expected reply, the timer is cancelled. If a timer pops without a reply having been received, the sender must initiate a recovery action.",
      "ja": "リンクグループの最初の接触のセットアップの一部であるLLCの流れで、タイマーの値は実装依存であるが、書込み完了タイムアウトを持っている他のピアを可能にするのに十分長くなければならないと2-3は、SMCの再送信に断りますTCP生地。リンクグループを維持し、リンクグループの最初の接触のセットアップの一部ではないLLC・フローについては、タイマーが短くなる場合があります。期待される応答を受信すると、タイマーは解除されます。応答なしのタイマーポップが受信された場合は、送信者は回復アクションを開始する必要があります。"
    },
    {
      "indent": 3,
      "text": "During first contact processing, failure of an LLC verification timer is a \"should-not-occur\" that indicates a problem with one of the endpoints; this is because if there is a \"routine\" failure in the RoCE fabric that causes an LLC verification send to fail, the sender will get a write completion failure and will then send an SMC Decline to the partner. The only time an LLC verification timer will expire on a first contact is when the sender thinks the send succeeded but it actually didn't. Because of the reliably connected nature of QP connections on the RoCE fabric, this indicates a problem with one of the peers, not with the RoCE fabric.",
      "ja": "最初の接触処理中に、LLC検証タイマーの失敗はそれは、エンドポイントの1つに問題があることを示し、「-起こらないはず」されます。失敗するLLC検証送信の原因となるROCEファブリック内の「日常」障害が発生した場合、送信者が書き込み完了の失敗を取得し、その後、パートナーへのSMCの低下をお送りしますので、これはです。送信者は送信が成功しましたが、それは実際にはなかったと思ったときにLLC検証タイマーが最初の接触時に期限切れとなるだけです。そのためROCEファブリック上QP接続の確実接続性質上、これはないROCEファブリックとピアの1つ、問題があることを示します。"
    },
    {
      "indent": 3,
      "text": "After the reliably connected queue pair for the first SMC-R link in a link group is set up on initial contact, the client sets a timer to wait for a RoCE verification message from the server that the QP is actually connected and usable. If the server experiences a failure sending its QP confirmation message, it will send an SMC Decline, which should arrive at the client before the client's verification timer expires. If the client's timer expires without receiving either an SMC Decline or a RoCE message confirmation from the server, there is a problem with either the server or the TCP fabric. In either case, the client must break the TCP connection and clean up the SMC-R link.",
      "ja": "最初の接触時に設定されているリンクグループの最初のSMC-Rリンクについて確実に接続されているキュー・ペアの後、クライアントはQPが実際に接続して使用可能であるサーバからROCE確認メッセージを待つためにタイマーを設定します。サーバがそのQP確認メッセージを送信し、障害が発生した場合、それはクライアントの検証タイマーが切れる前にクライアントに到着する必要があるSMCの低下を、送信されます。クライアントのタイマーがSMC衰退やサーバーからROCEのメッセージ確認のいずれかを受信することなく満了した場合は、サーバーまたはTCPファブリックのいずれかに問題があります。いずれの場合も、クライアントは、TCP接続を切断し、SMC-Rのリンクをクリーンアップする必要があります。"
    },
    {
      "indent": 3,
      "text": "There are two scenarios in which the client's response to the QP verification message fails to reach the server. The main difference is whether or not the client has successfully completed the send of the CONFIRM LINK response.",
      "ja": "QP確認メッセージに対するクライアントの応答がサーバーに到達するために失敗した2つのシナリオがあります。主な違いは、クライアントがCONFIRMのLINK応答の送信を正常に完了したかどうかです。"
    },
    {
      "indent": 3,
      "text": "In the normal case of a problem with the RoCE path, the client will learn of the failure by getting a write completion failure, before the server's timer expires. In this case, the client sends an SMC Decline CLC message to the server, and the TCP connection falls back to IP.",
      "ja": "ROCEパスに問題が通常の場合、クライアントはサーバーのタイマーが切れる前に、書き込み完了の失敗を取得することにより、障害の学びます。この場合、クライアントは、SMCは、サーバーにCLCメッセージを拒否送信し、TCP接続はバックIPに落ちます。"
    },
    {
      "indent": 3,
      "text": "If the client's send of the confirmation message receives a positive return code but for some reason still does not reach the server, or the client's SMC Decline CLC message fails to reach the server after the client fails to send its RoCE confirmation message, then the server's timer will time out and the server must break the TCP connection by sending a RST. This is expected to be a very rare case, because if the client cannot send its CONFIRM LINK response LLC message, the client should get a negative return code and initiate fallback to IP. A client receiving a positive return code on a send that fails to reach the server should also be an extremely rare case.",
      "ja": "確認メッセージのクライアントの送信は、サーバーの正のリターンコードを受信するが、何らかの理由で、まだ、サーバに到達、またはクライアントがそのROCE確認メッセージを送信するために失敗した後、クライアントのSMC衰退CLCメッセージがサーバーに到達するために失敗していない場合タイマーがタイムアウトすると、サーバはRSTを送信してTCP接続を切断しなければなりません。これは、クライアントがそのCONFIRM LINK応答LLCメッセージを送信できない場合、クライアントは負のリターンコードを取得し、IPへのフォールバックを開始する必要があるため、非常に稀なケースであることが期待されます。サーバーに到達するために失敗したセンドにプラスのリターンコードを受信するクライアントはまた、非常にまれなケースでなければなりません。"
    },
    {
      "indent": 0,
      "text": "C.7.1. Recovery Actions for LLC Timeouts and Failures",
      "ja": "C.7.1。 LLCタイムアウトや障害のために回復アクション"
    },
    {
      "indent": 3,
      "text": "The following list describes recovery actions for LLC timeouts. A write completion failure or other indication of send failure for an LLC command is treated the same as a timeout.",
      "ja": "以下のリストは、LLCタイムアウトの回復アクションを説明します。書き込み完了障害またはLLCコマンドの送信の失敗の他の指標は、タイムアウトと同じように扱われます。"
    },
    {
      "indent": 3,
      "text": "LLC message: CONFIRM LINK from server (first contact, first link in the link group)",
      "ja": "LLCメッセージ：サーバーからCONFIRMリンク（最初の接触、リンクグループ内の最初のリンク）"
    },
    {
      "indent": 6,
      "text": "Timer waits for: CONFIRM LINK reply from client.",
      "ja": "タイマーを待ち：クライアントからのLINK応答を確認してください。"
    },
    {
      "indent": 6,
      "text": "Recovery action: Break the TCP connection by sending a RST, and clean up the link. The server should have received an SMC Decline from the client by now if the client had an LLC send failure.",
      "ja": "回復処置：RSTを送信することにより、TCP接続を解除し、リンクをクリーンアップします。クライアントは、LLCが障害を送っていた場合、サーバーは、今では、クライアントからのSMCの下落を受けているはずです。"
    },
    {
      "indent": 3,
      "text": "LLC message: CONFIRM LINK from server (first contact, second link in the link group)",
      "ja": "LLCメッセージ：サーバーからCONFIRMリンク（最初の接触、リンクグループ内の第2のリンク）"
    },
    {
      "indent": 6,
      "text": "Timer waits for: CONFIRM LINK reply from client.",
      "ja": "タイマーを待ち：クライアントからのLINK応答を確認してください。"
    },
    {
      "indent": 6,
      "text": "Recovery action: The second link was not successfully set up. Send a DELETE LINK to the client. Connection data cannot flow in the first link in the link group, until the reply to this DELETE LINK is received, to prevent the peers from being out of sync on the state of the link group.",
      "ja": "回復処置：2番目のリンクが正常に設定されていませんでした。クライアントへのDELETE LINKを送信します。このDELETE LINKへの応答が受信されるまで接続データは、リンクグループの状態に同期してあることからピアを防止するために、リンクグループ内の最初のリンクに流れることができません。"
    },
    {
      "indent": 3,
      "text": "LLC message: CONFIRM LINK from server (not first contact)",
      "ja": "LLCメッセージ：サーバーからCONFIRMのLINK（最初接触していません）"
    },
    {
      "indent": 6,
      "text": "Timer waits for: CONFIRM LINK reply from client.",
      "ja": "タイマーを待ち：クライアントからのLINK応答を確認してください。"
    },
    {
      "indent": 6,
      "text": "Recovery action: Clean up the new link, and set a timer to retry. Send a DELETE LINK to the client, in case the client has a longer timer interval, so the client can stop waiting.",
      "ja": "回復処置：新しいリンクをクリーンアップし、再試行するタイマーを設定します。クライアントが長いタイマー間隔を有している場合には、クライアントにDELETEのリンクを送信するので、クライアントが待って停止することができます。"
    },
    {
      "indent": 3,
      "text": "LLC message: CONFIRM LINK reply from client (first contact)",
      "ja": "LLCメッセージ：クライアントからのLINK応答を確認（最初の接点）"
    },
    {
      "indent": 6,
      "text": "Timer waits for: ADD LINK from server.",
      "ja": "サーバーからのリンクを追加：タイマーを待ちます。"
    },
    {
      "indent": 6,
      "text": "Recovery action: Clean up the SMC-R link, and break the TCP connection by sending a RST over the IP fabric. There is a problem with the server. If the server had a send failure, it should have sent an SMC Decline by now.",
      "ja": "回復処置：SMC-Rのリンクをクリーンアップ、およびIP生地の上にRSTを送信してTCP接続を切断。サーバーに問題があります。サーバが送信失敗した場合は、それが今ではSMCの低下を送っているはずです。"
    },
    {
      "indent": 3,
      "text": "LLC message: ADD LINK from server (first contact)",
      "ja": "LLCメッセージ：サーバーからのリンクを追加（第一のコンタクト）"
    },
    {
      "indent": 6,
      "text": "Timer waits for: ADD LINK reply from client.",
      "ja": "タイマーを待ち：クライアントからのLINK返信を追加します。"
    },
    {
      "indent": 6,
      "text": "Recovery action: Break the TCP connection with a RST, and clean up RoCE resources. The connection is past the point where the server can fall back to IP, and if the client had a send problem it should have sent an SMC Decline by now.",
      "ja": "回復処置：RSTとのTCP接続を解除し、ROCEのリソースをクリーンアップ。接続は、サーバーがバックIPに落ちることができるポイントを過ぎている、そしてクライアントが送信に問題があった場合、それは今ではSMCの低下を送っているはずです。"
    },
    {
      "indent": 3,
      "text": "LLC message: ADD LINK from server (not first contact)",
      "ja": "LLCメッセージ：サーバー（最初に接触していない）からのリンクを追加"
    },
    {
      "indent": 6,
      "text": "Timer waits for: ADD LINK reply from client.",
      "ja": "タイマーを待ち：クライアントからのLINK返信を追加します。"
    },
    {
      "indent": 6,
      "text": "Recovery action: Clean up resources (QP, RKeys, etc.) for the new link, and treat the link over which the ADD LINK was sent as if it had failed. If there is another link available to resend the ADD LINK and the link group still needs another link, retry the ADD LINK over another link in the link group.",
      "ja": "回復処置：リソースをクリーンアップする新しいリンクについて（QP、RKeys、など）、およびそれが失敗したかのように追加]リンクが送信された上でリンクを扱います。 ADDリンクとリンクグループは、まだ別のリンクを必要とする再送信するために利用可能な別のリンクがある場合は、リンクグループ内の別のリンク上のADD LINKを再試行してください。"
    },
    {
      "indent": 3,
      "text": "LLC message: ADD LINK reply from client (and there are more RKeys to be communicated)",
      "ja": "LLCのメッセージ：クライアントからのLINK返信を追加します（と通信されるべき多くのRKeysがあります）"
    },
    {
      "indent": 6,
      "text": "Timer waits for: ADD LINK CONTINUATION from server.",
      "ja": "タイマーを待ち：サーバからLINK継続を追加します。"
    },
    {
      "indent": 6,
      "text": "Recovery action: Treat the same as ADD LINK timer failure.",
      "ja": "回復処置：ADDのLINKタイマーの障害と同じ扱い。"
    },
    {
      "indent": 3,
      "text": "LLC message: ADD LINK reply or ADD LINK CONTINUATION reply from client (and there are no more RKeys to be communicated, for the second link in a first contact scenario)",
      "ja": "LLCメッセージ：LINK応答を追加したり、クライアントからのリンク継続応答を追加（及び通信すべきそれ以上RKeysが存在しない、最初の接触シナリオにおける第2のリンク用）"
    },
    {
      "indent": 6,
      "text": "Timer waits for: CONFIRM LINK from the server, over the new link.",
      "ja": "タイマーを待ち：新しいリンクを介して、サーバからLINKを確認します。"
    },
    {
      "indent": 6,
      "text": "Recovery action: The setup of the new link failed. Send a DELETE LINK to the server. Do not consider the socket opened to the client application until receiving confirmation from the server in the form of a DELETE LINK request for this link and sending the reply (to prevent the partners from being out of sync on the state of the link group).",
      "ja": "回復処置：新しいリンクの設定に失敗しました。サーバーへのDELETE LINKを送信します。 （リンクグループの状態に同期していているから相手を防ぐために）ソケットはこのリンクのDELETE LINK要求の形式で、サーバーからの確認を受信し、応答を送信するまで、クライアントアプリケーションに開かれた検討しないでください。"
    },
    {
      "indent": 6,
      "text": "Set a timer to send another ADD LINK to the server if there is still an unused RNIC on the client side.",
      "ja": "まだ、クライアント側で未使用のRNICがある場合は、サーバーに別のADDのリンクを送信するためにタイマーを設定します。"
    },
    {
      "indent": 3,
      "text": "LLC message: ADD LINK reply or ADD LINK CONTINUATION reply from client (and there are no more RKeys to be communicated)",
      "ja": "LLCのメッセージ：LINKの返信を追加したり、クライアントからのLINK継続返信を追加します（と通信されるべきもうRKeysはありません）"
    },
    {
      "indent": 6,
      "text": "Timer waits for: CONFIRM LINK from the server, over the new link.",
      "ja": "タイマーを待ち：新しいリンクを介して、サーバからLINKを確認します。"
    },
    {
      "indent": 6,
      "text": "Recovery action: Send a DELETE LINK to the server for the new link, then clean up any resource allocated for the new link and set a timer to send an ADD LINK to the server if there is still an unused RNIC on the client side. The setup of the new link failed, but the link over which the ADD LINK exchange occurred is unaffected.",
      "ja": "回復処置：新しいリンクのために割り当てられたすべてのリソースをクリーンアップし、未使用のRNICは、クライアント側にまだ存在する場合は、サーバーへの追加]リンクを送信するためにタイマーを設定し、その後、新しいリンクのためのサーバーにDELETE LINKを送信します。新しいリンクのセットアップは失敗したが、ADDのLINK交換が発生した上でのリンクは影響を受けません。"
    },
    {
      "indent": 3,
      "text": "LLC message: ADD LINK CONTINUATION from server",
      "ja": "LLCメッセージ：サーバーからLINK継続を追加"
    },
    {
      "indent": 6,
      "text": "Timer waits for: ADD LINK CONTINUATION reply from client.",
      "ja": "タイマーを待ち：クライアントからのLINK継続返信を追加します。"
    },
    {
      "indent": 6,
      "text": "Recovery action: Treat the same as ADD LINK timer failure.",
      "ja": "回復処置：ADDのLINKタイマーの障害と同じ扱い。"
    },
    {
      "indent": 3,
      "text": "LLC message: ADD LINK CONTINUATION reply from client (first contact, and RMB count fields indicate that the server owes more ADD LINK CONTINUATION messages)",
      "ja": "LLCのメッセージ：クライアントからのLINK継続返信を追加します（最初に接触し、人民元のカウントフィールドは、サーバがLINK継続メッセージを追加し、より負っていることを示しています）"
    },
    {
      "indent": 6,
      "text": "Timer waits for: ADD LINK CONTINUATION from server.",
      "ja": "タイマーを待ち：サーバからLINK継続を追加します。"
    },
    {
      "indent": 6,
      "text": "Recovery action: Clean up the SMC-R link, and break the TCP connection by sending a RST. There is a problem with the server.",
      "ja": "回復処置：SMC-Rのリンクをクリーンアップし、RSTを送信してTCP接続を切断。サーバーに問題があります。"
    },
    {
      "indent": 6,
      "text": "If the server had a send failure, it should have sent an SMC Decline by now.",
      "ja": "サーバが送信失敗した場合は、それが今ではSMCの低下を送っているはずです。"
    },
    {
      "indent": 3,
      "text": "LLC message: ADD LINK CONTINUATION reply from client (not first contact, and RMB count fields indicate that the server owes more ADD LINK CONTINUATION messages)",
      "ja": "LLCのメッセージ：クライアントからのLINK継続返信を追加します（最初に接触していない、と人民元のカウントフィールドは、サーバがLINK継続メッセージを追加し、より負っていることを示しています）"
    },
    {
      "indent": 6,
      "text": "Timer waits for: ADD LINK CONTINUATION from server.",
      "ja": "タイマーを待ち：サーバからLINK継続を追加します。"
    },
    {
      "indent": 6,
      "text": "Recovery action: Treat as if client detected link failure on the link that the ADD LINK exchange is using. Send a DELETE LINK to the server over another active link if one exists; otherwise, clean up the link group.",
      "ja": "回復処置：クライアントは、ADDのLINK交換が使用しているリンク上のリンク障害を検出したかのように扱います。 1が存在する場合は、別のアクティブなリンクを介してサーバーにDELETE LINKを送信します。そうでない場合は、リンクグループをクリーンアップします。"
    },
    {
      "indent": 3,
      "text": "LLC message: DELETE LINK from client",
      "ja": "LLCのメッセージ：クライアントからのリンクを削除"
    },
    {
      "indent": 6,
      "text": "Timer waits for: DELETE LINK request from server.",
      "ja": "タイマーを待ち：サーバからのLINK要求を削除します。"
    },
    {
      "indent": 6,
      "text": "Recovery action: If the scope of the request is to delete a single link, the surviving link over which the client sent the DELETE LINK is no longer usable either. If this is the last link in the link group, end TCP connections over the link group by sending RST packets. If there are other surviving links in the link group, resend over a surviving link. Also send a DELETE LINK over a surviving link for the link over which the client attempted to send the initial DELETE LINK message. If the scope of the request is to delete the entire link group, try resending on other links in the link group until success is achieved. If all sends fail, tear down the link group and any TCP connections that exist on it.",
      "ja": "回復処置：要求の範囲は、単一のリンクを削除する場合は、クライアントはDELETE LINKを送信した上で存続リンクはどちらか使用できなくなっています。これは、リンクグループ内の最後のリンクは、リンク群オーバーエンドのTCP接続RSTパケットを送信することである場合。リンクグループ内の他の存続のリンクがある場合は、生き残ったリンクを経由再送信します。また、クライアントが初期DELETE LINKメッセージを送信しようとした上でリンクの存続リンク上でDELETE LINKを送信します。要求の範囲は全体のリンクグループを削除する場合は、成功が達成されるまで、リンクグループ内の他のリンクに再送信してみてください。すべてが失敗送信した場合、リンク群とそれに存在する任意のTCP接続を切断。"
    },
    {
      "indent": 3,
      "text": "LLC message: DELETE LINK from server (scope: entire link group)",
      "ja": "LLCメッセージ：サーバーからのリンクを削除（範囲：全体のリンクグループ）"
    },
    {
      "indent": 6,
      "text": "Timer waits for: Confirmation from the adapter that the message was delivered.",
      "ja": "メッセージが配信されたアダプタからの確認：タイマーを待ちます。"
    },
    {
      "indent": 6,
      "text": "Recovery action: Tear down the link group and any TCP connections that exist on it.",
      "ja": "回復処置：リンク・グループとその上に存在する任意のTCP接続を切断。"
    },
    {
      "indent": 3,
      "text": "LLC message: DELETE LINK from server (scope: single link)",
      "ja": "LLCメッセージ：サーバー（範囲：シングルリンク）からリンクを削除"
    },
    {
      "indent": 6,
      "text": "Timer waits for: DELETE LINK reply from client.",
      "ja": "クライアントからのLINK応答をDELETE：タイマーを待ちます。"
    },
    {
      "indent": 6,
      "text": "Recovery action: The link over which the server sent the DELETE LINK is no longer usable either. If this is the last link in the link group, end TCP connections over the link group by sending RST packets. If there are other surviving links in the link group, resend over a surviving link. Also send a DELETE LINK over a surviving link for the link over which the server attempted to send the initial DELETE LINK message. If the scope of the request is to delete the entire link group, try resending on other links in the link group until success is achieved. If all sends fail, tear down the link group and any TCP connections that exist on it.",
      "ja": "回復処置：サーバーは、DELETE LINKを送信した上でリンクがいずれか使用できなくなっています。これは、リンクグループ内の最後のリンクは、リンク群オーバーエンドのTCP接続RSTパケットを送信することである場合。リンクグループ内の他の存続のリンクがある場合は、生き残ったリンクを経由再送信します。また、サーバが初期DELETE LINKメッセージを送信しようとした上でリンクの存続リンク上でDELETE LINKを送信します。要求の範囲は全体のリンクグループを削除する場合は、成功が達成されるまで、リンクグループ内の他のリンクに再送信してみてください。すべてが失敗送信した場合、リンク群とそれに存在する任意のTCP接続を切断。"
    },
    {
      "indent": 3,
      "text": "LLC message: CONFIRM RKEY from client",
      "ja": "LLCメッセージ：クライアントからCONFIRMのRKEY"
    },
    {
      "indent": 6,
      "text": "Timer waits for: CONFIRM RKEY reply from server.",
      "ja": "タイマーを待ち：サーバからRKEYの返信を確認してください。"
    },
    {
      "indent": 6,
      "text": "Recovery action: Perform normal client procedures for detection of failed link. The link over which the message was sent has failed.",
      "ja": "回復処置：失敗したリンクの検出のための通常のクライアントの手順を実行します。メッセージが送信された先のリンクに障害が発生しました。"
    },
    {
      "indent": 3,
      "text": "LLC message: CONFIRM RKEY from server",
      "ja": "LLCメッセージ：サーバーからCONFIRMのRKEY"
    },
    {
      "indent": 6,
      "text": "Timer waits for: CONFIRM RKEY reply from client.",
      "ja": "タイマーを待ち：クライアントからRKEY応答を確認してください。"
    },
    {
      "indent": 6,
      "text": "Recovery action: Perform normal server procedures for detection of failed link. The link over which the message was sent has failed.",
      "ja": "回復処置：失敗したリンクの検出のための通常のサーバの手順を実行します。メッセージが送信された先のリンクに障害が発生しました。"
    },
    {
      "indent": 3,
      "text": "LLC message: TEST LINK from client",
      "ja": "LLCメッセージ：クライアントからのテストリンク"
    },
    {
      "indent": 6,
      "text": "Timer waits for: TEST LINK reply from server.",
      "ja": "サーバーからのテストリンク応答：タイマーを待ちます。"
    },
    {
      "indent": 6,
      "text": "Recovery action: Perform normal client procedures for detection of failed link. The link over which the message was sent has failed.",
      "ja": "回復処置：失敗したリンクの検出のための通常のクライアントの手順を実行します。メッセージが送信された先のリンクに障害が発生しました。"
    },
    {
      "indent": 3,
      "text": "LLC message: TEST LINK from server",
      "ja": "LLCメッセージ：サーバーからのテストリンク"
    },
    {
      "indent": 6,
      "text": "Timer waits for: TEST LINK reply from client.",
      "ja": "クライアントからのテストリンク応答：タイマーを待ちます。"
    },
    {
      "indent": 6,
      "text": "Recovery action: Perform normal server procedures for detection of failed link. The link over which the message was sent has failed.",
      "ja": "回復処置：失敗したリンクの検出のための通常のサーバの手順を実行します。メッセージが送信された先のリンクに障害が発生しました。"
    },
    {
      "indent": 3,
      "text": "The following list describes recovery actions for invalid LLC messages. These could be misformatted or contain out-of-sync data.",
      "ja": "以下のリストは無効LLCメッセージの回復アクションを説明します。これらはmisformattedまたは同期外れのデータが含まれていることができました。"
    },
    {
      "indent": 3,
      "text": "LLC message received: CONFIRM LINK from server",
      "ja": "LLCのメッセージは、受信：CONFIRMのLINKをサーバーから"
    },
    {
      "indent": 6,
      "text": "What it indicates: Incorrect link information.",
      "ja": "それは何を示している：不正なリンク情報。"
    },
    {
      "indent": 6,
      "text": "Recovery action: Protocol error. The link must be brought down by sending a DELETE LINK for the link over another link in the link group if one exists. If this is a first contact, fall back to IP by sending an SMC Decline to the server.",
      "ja": "回復処置：プロトコルエラー。リンクは1つが存在する場合は、リンクグループ内の別のリンク上のリンクのためのDELETE LINKを送信することにより、倒さなければなりません。これが最初の接触である場合は、サーバーへのSMCの低下を送信することによって、IPにフォールバック。"
    },
    {
      "indent": 3,
      "text": "LLC message received: ADD LINK",
      "ja": "LLCメッセージ受信：リンクを追加"
    },
    {
      "indent": 6,
      "text": "What it indicates: Undefined enumerated MTU value.",
      "ja": "それは何を示している：不定列挙MTU値。"
    },
    {
      "indent": 6,
      "text": "Recovery action: Send a negative ADD LINK reply with reason code x'2'.",
      "ja": "回復処置：理由コードX'2' で負のADD LINK応答を送信します。"
    },
    {
      "indent": 3,
      "text": "LLC message received: ADD LINK reply from client",
      "ja": "LLCメッセージを受信：クライアントからのリンクの返信を追加します。"
    },
    {
      "indent": 6,
      "text": "What it indicates: Client-side link information that would result in a parallel link being set up.",
      "ja": "それが何を示すか：パラレルリンクにつながるクライアント側のリンク情報が設定されています。"
    },
    {
      "indent": 6,
      "text": "Recovery action: Parallel links are not permitted. Delete the link by sending a DELETE LINK to the client over another link in the link group.",
      "ja": "回復処置：パラレルリンクが許可されていません。リンクグループ内の別のリンクを介してクライアントへのDELETE LINKを送信することにより、リンクを削除します。"
    },
    {
      "indent": 3,
      "text": "LLC message received: Any link group command from the server, except DELETE LINK for the entire link group",
      "ja": "LLCのメッセージは、受信：任意のリンクグループのコマンドをサーバーから、リンク全体のグループのためのDELETE LINK除き、"
    },
    {
      "indent": 6,
      "text": "What it indicates: Client has sent a DELETE LINK for the link on which the message was received.",
      "ja": "それが何を示すか：クライアントがメッセージを受信したリンクの削除リンクを送りました。"
    },
    {
      "indent": 6,
      "text": "Recovery action: Ignore the LLC message. Worst case: the server will time out. Best case: the DELETE LINK crosses with the command from the server, and the server realizes it failed.",
      "ja": "回復処置：LLCメッセージを無視します。最悪の場合：サーバーがタイムアウトします。ベストケース：DELETE LINKは、サーバからのコマンドで交差し、サーバはそれが失敗した実現します。"
    },
    {
      "indent": 3,
      "text": "LLC message received: ADD LINK CONTINUATION from server or ADD LINK CONTINUATION reply from client",
      "ja": "LLCのメッセージは、受信：サーバーからLINK継続を追加したり、クライアントからのLINK継続返信を追加します。"
    },
    {
      "indent": 6,
      "text": "What it indicates: Number of RMBs provided doesn't match count given on initial ADD LINK or ADD LINK reply message.",
      "ja": "それが示すもの：提供RMBSの数は、初期のADD LINKに与えられたカウントまたはLINK応答メッセージを追加一致していません。"
    },
    {
      "indent": 6,
      "text": "Recovery action: Protocol error. Treat as if detected link outage.",
      "ja": "回復処置：プロトコルエラー。検出されたリンク停止かのように扱います。"
    },
    {
      "indent": 3,
      "text": "LLC message received: DELETE LINK from client",
      "ja": "LLCのメッセージを受信します。クライアントからのリンクを削除"
    },
    {
      "indent": 6,
      "text": "What it indicates: Link indicated doesn't exist.",
      "ja": "それは何を示している：リンクが存在しません示されました。"
    },
    {
      "indent": 6,
      "text": "Recovery action: If the link is in the process of being cleaned up, assume timing window and ignore message. Otherwise, send a DELETE LINK reply with reason code 1.",
      "ja": "回復処置：リンクがクリーンアップ中である場合、タイミングウィンドウを想定し、メッセージを無視します。そうでない場合は、理由コード1とDELETE LINK応答を送信します。"
    },
    {
      "indent": 3,
      "text": "LLC message received: DELETE LINK from server",
      "ja": "LLCメッセージを受信：サーバーからのリンクを削除"
    },
    {
      "indent": 6,
      "text": "What it indicates: Link indicated doesn't exist.",
      "ja": "それは何を示している：リンクが存在しません示されました。"
    },
    {
      "indent": 6,
      "text": "Recovery action: Send a DELETE LINK reply with reason code 1.",
      "ja": "回復処置：理由コード1とDELETE LINK応答を送信します。"
    },
    {
      "indent": 3,
      "text": "LLC message received: CONFIRM RKEY from either client or server",
      "ja": "LLCのメッセージは、受信：CONFIRMのRKEYをクライアントまたはサーバのいずれかから"
    },
    {
      "indent": 6,
      "text": "What it indicates: No RKey provided for one or more of the links in the link group.",
      "ja": "それが何を示すか：いいえRKEYは、リンクグループ内のリンクの1以上を提供します。"
    },
    {
      "indent": 6,
      "text": "Recovery action: Treat as if detected failure of the link(s) for which no RKey was provided.",
      "ja": "回復処置：キーが提供されなかったためにリンク（複数可）の検出された障害かのように扱います。"
    },
    {
      "indent": 3,
      "text": "LLC message received: DELETE RKEY",
      "ja": "LLCメッセージ受信：RKEYをDELETE"
    },
    {
      "indent": 6,
      "text": "What it indicates: Specified RKey doesn't exist.",
      "ja": "それが何を示すか：指定RKEYは存在しません。"
    },
    {
      "indent": 6,
      "text": "Recovery action: Send a negative DELETE RKEY response.",
      "ja": "回復処置：負DELETE RKEY応答を送信します。"
    },
    {
      "indent": 3,
      "text": "LLC message received: TEST LINK reply",
      "ja": "LLCメッセージ受信：テストリンク返信"
    },
    {
      "indent": 6,
      "text": "What it indicates: User data doesn't match what was sent in the TEST LINK request.",
      "ja": "それが示すもの：ユーザーデータは、テストリンク要求で送信されたものと一致していません。"
    },
    {
      "indent": 6,
      "text": "Recovery action: Treat as if detected that the link has gone down. This is a protocol error.",
      "ja": "回復処置：リンクがダウンしたことを検出したかのように扱います。これは、プロトコルエラーです。"
    },
    {
      "indent": 3,
      "text": "LLC message received: Unknown LLC type with high-order bits of opcode equal to b'10'",
      "ja": "LLCメッセージを受信：不明LLCタイプをB'10' に等しいオペコードの上位ビットと"
    },
    {
      "indent": 6,
      "text": "What it indicates: This is an optional LLC message that the receiver does not support.",
      "ja": "それが何を示すか：これは、受信機がサポートしていないオプションのLLCのメッセージです。"
    },
    {
      "indent": 6,
      "text": "Recovery action: Ignore (silently discard) the message.",
      "ja": "回復処置：（静かに破棄）メッセージを無視します。"
    },
    {
      "indent": 3,
      "text": "LLC message received: Any unambiguously incorrect or out-of-sync LLC message",
      "ja": "LLCのメッセージは、受信：すべて明確に間違っていたり外の同期LLCのメッセージ"
    },
    {
      "indent": 6,
      "text": "What it indicates: Link is out of sync.",
      "ja": "それが何を示すか：リンクは同期されていません。"
    },
    {
      "indent": 6,
      "text": "Recovery action: Treat as if detected that the link has gone down. Note that an unsupported or unknown LLC opcode whose two high-order bits are b'10' is not an error and must be silently discarded. Any other unknown or unsupported LLC opcode is an error.",
      "ja": "回復処置：リンクがダウンしたことを検出したかのように扱います。その上位2ビットがB'10' されているサポートされていないか、未知LLCオペコードはエラーではなく、静かに廃棄しなければならないことに注意してください。その他の未知またはサポートされていないLLCオペコードは誤りです。"
    },
    {
      "indent": 0,
      "text": "C.8. Failure to Add Second SMC-R Link to a Link Group",
      "ja": "C.8。リンクグループに2つ目のSMC-Rリンクの追加に失敗"
    },
    {
      "indent": 3,
      "text": "When there is any failure in setting up the second SMC-R link in an SMC-R link group, including confirmation timer expiration, the SMC-R link group is allowed to continue without available failover. However, this situation is extremely undesirable, and the server must endeavor to correct it as soon as it can.",
      "ja": "確認タイマ満了を含むSMC-Rリンクグループ内の2番目のSMC-Rのリンクを設定する際に何らかの障害が発生した場合には、SMC-Rリンクグループは、利用可能なフェールオーバせずに継続することができます。しかし、この状況は非常に望ましくなく、サーバーはすぐにそれができるようにそれを修正するために努力しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The server peer in the SMC-R link group must set a timer to drive it to retry setup of a failed additional SMC-R link. The server will immediately retry the SMC-R link setup when the first of the following events occurs:",
      "ja": "SMC-Rリンクグループ内のサーバーピアは、失敗した追加のSMC-Rリンクの設定を再試行することを駆動するようにタイマーを設定する必要があります。次のイベントの最初の発生時に、サーバーはすぐにSMC-Rリンクセットアップを再試行します。"
    },
    {
      "indent": 3,
      "text": "o The retry timer expires.",
      "ja": "Oリトライタイマが満了します。"
    },
    {
      "indent": 3,
      "text": "o A new RNIC becomes available to the server, on the same LAN as the SMC-R link group.",
      "ja": "O新しいRNICは、SMC-Rリンクグループと同じLAN上で、サーバに利用可能になります。"
    },
    {
      "indent": 3,
      "text": "o An ADD LINK LLC request message is received from the client; this indicates the availability of a new RNIC on the client side.",
      "ja": "OのADD LINK LLC要求メッセージは、クライアントから受信されます。これは、クライアント側での新しいRNICの利用可能性を示します。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Mike Fox IBM 3039 Cornwallis Rd. Research Triangle Park, NC 27709 United States",
      "ja": "マイク・フォックスIBM 3039コーンウォリスRdを。リサーチトライアングルパーク、ノースカロライナ州27709米国"
    },
    {
      "indent": 3,
      "text": "Email: mjfox@us.ibm.com",
      "ja": "メール：mjfox@us.ibm.com"
    },
    {
      "indent": 3,
      "text": "Constantinos (Gus) Kassimis IBM 3039 Cornwallis Rd. Research Triangle Park, NC 27709 United States",
      "ja": "コンスタン（GUS）Kassimis IBM 3039コーンRdを。リサーチトライアングルパーク、ノースカロライナ州27709米国"
    },
    {
      "indent": 3,
      "text": "Email: kassimis@us.ibm.com",
      "ja": "メール：kassimis@us.ibm.com"
    },
    {
      "indent": 3,
      "text": "Jerry Stevens IBM 3039 Cornwallis Rd. Research Triangle Park, NC 27709 United States",
      "ja": "ジェリー・スティーブンスIBM 3039コーンウォリスRdを。リサーチトライアングルパーク、ノースカロライナ州27709米国"
    },
    {
      "indent": 3,
      "text": "Email: sjerry@us.ibm.com",
      "ja": "メール：sjerry@us.ibm.com"
    }
  ]
}