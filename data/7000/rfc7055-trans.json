{
  "title": {
    "text": "RFC 7055 - A GSS-API Mechanism for the Extensible Authentication Protocol",
    "ja": "RFC 7055 - 拡張認証プロトコルのためのGSS-APIメカニズム"
  },
  "number": 7055,
  "created_at": "2019-10-28 03:24:01.982637+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                   S. Hartman, Ed.\nRequest for Comments: 7055                             Painless Security\nCategory: Standards Track                                     J. Howlett\nISSN: 2070-1721                                                JANET(UK)\n                                                           December 2013",
      "raw": true
    },
    {
      "indent": 5,
      "text": "A GSS-API Mechanism for the Extensible Authentication Protocol",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document defines protocols, procedures, and conventions to be employed by peers implementing the Generic Security Service Application Program Interface (GSS-API) when using the Extensible Authentication Protocol mechanism. Through the GS2 family of mechanisms defined in RFC 5801, these protocols also define how Simple Authentication and Security Layer (SASL) applications use the Extensible Authentication Protocol.",
      "ja": "このドキュメントは、プロトコル、手順、および拡張認証プロトコルメカニズムを使用している場合、汎用セキュリティサービスアプリケーションプログラムインタフェース（GSS-API）を実装するピアによって採用される規則を定義します。 RFC 5801で定義されたメカニズムのGS2ファミリーを通じて、これらのプロトコルも、どのように簡易認証セキュリティー層（SASL）アプリケーションは、拡張認証プロトコルを使用して定義します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 5741のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7055.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7055で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2013 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2013 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................3\n   1.1. Discovery ..................................................4\n   1.2. Authentication .............................................4\n   1.3. Secure Association Protocol ................................6\n2. Requirements Notation ...........................................6\n3. EAP Channel Binding and Naming ..................................6\n   3.1. Mechanism Name Format ......................................7\n   3.2. Internationalization of Names .............................10\n   3.3. Exported Mechanism Names ..................................10\n   3.4. Acceptor Name RADIUS AVP ..................................11\n   3.5. Proxy Verification of Acceptor Name .......................11\n4. Selection of EAP Method ........................................12\n5. Context Tokens .................................................13\n   5.1. Mechanisms and Encryption Types ...........................14\n   5.2. Processing Received Tokens ................................15\n   5.3. Error Subtokens ...........................................16\n   5.4. Initial State .............................................16\n        5.4.1. Vendor Subtoken ....................................17\n        5.4.2. Acceptor Name Request ..............................17\n        5.4.3. Acceptor Name Response .............................18\n   5.5. Authenticate State ........................................18\n        5.5.1. EAP Request Subtoken ...............................19\n        5.5.2. EAP Response Subtoken ..............................19\n   5.6. Extensions State ..........................................20\n        5.6.1. Flags Subtoken .....................................20\n        5.6.2. GSS Channel Bindings Subtoken ......................20\n        5.6.3. MIC Subtoken .......................................21\n   5.7. Example Token .............................................22\n   5.8. Context Options ...........................................23\n6. Acceptor Services ..............................................23\n   6.1. GSS-API Channel Binding ...................................24\n   6.2. Per-Message Security ......................................24\n   6.3. Pseudorandom Function .....................................24\n7. IANA Considerations ............................................25\n   7.1. OID Registry ..............................................25\n   7.2. RFC 4121 Token Identifiers ................................26\n   7.3. GSS-EAP Subtoken Types ....................................26\n   7.4. RADIUS Attribute Assignments ..............................27\n   7.5. Registration of the EAP-AES128 SASL Mechanisms ............28\n   7.6. GSS-EAP Errors ............................................28\n   7.7. GSS-EAP Context Flags .....................................30\n8. Security Considerations ........................................30\n9. Acknowledgements ...............................................32\n10. References ....................................................32\nAppendix A. Pre-publication RADIUS VSA ............................33",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "The Application Bridging for Federated Access Beyond Web (ABFAB) document [ABFAB-ARCH] describes an architecture for providing federated access management to applications using the Generic Security Service Application Programming Interface (GSS-API) [RFC2743] and Simple Authentication and Security Layer (SASL) [RFC4422]. This specification provides the core mechanism for bringing federated authentication to these applications.",
      "ja": "フェデレーションアクセスを超えたWeb（ABFAB）ドキュメント[ABFAB-ARCH]のためのブリッジングアプリケーションは、一般的なセキュリティサービスアプリケーションプログラミングインターフェイス（GSS-API）[RFC2743]と簡易認証セキュリティー層を（使用するアプリケーションへのフェデレーションアクセス管理を提供するためのアーキテクチャについて説明しますSASL）[RFC4422]。この仕様は、これらのアプリケーションへのフェデレーション認証をもたらすためのコアメカニズムを提供します。"
    },
    {
      "indent": 3,
      "text": "The Extensible Authentication Protocol (EAP) [RFC3748] defines a framework for authenticating a network access client and server in order to gain access to a network. A variety of different EAP methods are in wide use; one of EAP's strengths is that for most types of credentials in common use, there is an EAP method that permits the credential to be used.",
      "ja": "拡張認証プロトコル（EAP）[RFC3748]は、ネットワークへのアクセスを獲得するために、ネットワーク・アクセス・クライアント及びサーバを認証するためのフレームワークを定義します。異なるEAPの種々の方法は、広く使用されています。 EAPの強みの一つは、一般的に使用される資格情報のほとんどのタイプのために、使用する資格を許可するEAP方式があるということです。"
    },
    {
      "indent": 3,
      "text": "EAP is often used in conjunction with a backend Authentication, Authorization and Accounting (AAA) server via RADIUS [RFC3579] or Diameter [RFC4072]. In this mode, the Network Access Server (NAS) simply tunnels EAP packets over the backend authentication protocol to a home EAP/AAA server for the client. After EAP succeeds, the backend authentication protocol is used to communicate key material to the NAS. In this mode, the NAS need not be aware of or have any specific support for the EAP method used between the client and the home EAP server. The client and EAP server share a credential that depends on the EAP method; the NAS and AAA server share a credential based on the backend authentication protocol in use. The backend authentication server acts as a trusted third party, enabling network access even though the client and NAS may not actually share any common authentication methods. As described in the architecture document [ABFAB-ARCH], using AAA proxies, this mode can be extended beyond one organization to provide federated authentication for network access.",
      "ja": "EAPは、多くの場合、RADIUS [RFC3579]または直径[RFC4072]を介してバックエンド認証、認可およびアカウンティング（AAA）サーバと組み合わせて使用​​されます。このモードでは、ネットワーク・アクセス・サーバ（NAS）は、単にクライアントのホームEAP / AAAサーバへのバックエンド認証プロトコル上でEAPパケットをトンネルします。 EAPが成功した後、バックエンド認証プロトコルはNASに鍵を通信するために使用されます。このモードでは、NASはを意識するか、クライアントとホームEAPサーバの間で使用されるEAPメソッドのいずれかの特定のサポートを持っている必要はありません。クライアントとEAPサーバシェアEAP方式に依存資格。 NASとAAAサーバー共有使用されているバックエンド認証プロトコルに基づいて資格。バックエンド認証サーバは、クライアントとNASは、実際に任意の一般的な認証方法を共有していなくてもネットワークアクセスを可能にする、信頼できる第三者として機能します。アーキテクチャの文書に記載されているように[ABFAB-ARCH]は、AAAプロキシを使用して、このモードでは、ネットワークアクセスのための連合認証を提供するために、1つの組織を超えて拡張することができます。"
    },
    {
      "indent": 3,
      "text": "The GSS-API provides a generic framework for applications to use security services including authentication and per-message data security. Between protocols that support GSS-API directly or protocols that support SASL [RFC4422], many application protocols can use GSS-API for security services. However, with the exception of Kerberos [RFC4121], few GSS-API mechanisms are in wide use on the Internet. While GSS-API permits an application to be written independent of the specific GSS-API mechanism in use, there is no facility to separate the server from the implementation of the mechanism as there is with EAP and backend authentication servers.",
      "ja": "GSS-APIは、認証とメッセージごとのデータセキュリティを含むセキュリティ・サービスを使用するアプリケーションのための汎用的なフレームワークを提供します。 SASL [RFC4422]をサポートし、直接GSS-APIをサポートするプロトコルまたはプロトコルの間、多くのアプリケーションプロトコルは、セキュリティサービスのためのGSS-APIを使用することができます。しかし、ケルベロス[RFC4121]を除いて、いくつかのGSS-APIメカニズムは、インターネット上で広く使用されています。 GSS-APIは、アプリケーションが使用中の特定のGSS-API機構の独立して書かれることを可能にする一方で、EAPおよびバックエンド認証サーバとがあるので、メカニズムの実装からサーバーを分離する機能はありません。"
    },
    {
      "indent": 3,
      "text": "The goal of this specification is to combine GSS-API's support for application protocols with EAP/AAA's support for common credential types and for authenticating to a server without requiring that server to specifically support the authentication method in use. In addition, this specification supports the architectural goal of transporting attributes about subjects to relying parties. Together this combination will provide federated authentication and authorization for GSS-API applications. This specification meets the applicability requirements for EAP to application authentication [RFC7057].",
      "ja": "この仕様の目標は、一般的なクレデンシャルタイプのため、特に使用中の認証方式をサポートするために、そのサーバーを必要とせずに、サーバーへの認証のためのEAP / AAAのサポートとアプリケーションプロトコルのためのGSS-APIのサポートを組み合わせることです。また、この仕様は、依拠当事者への被験者についての属性を輸送の建築の目標をサポートしています。一緒にこの組み合わせは、GSS-APIアプリケーションのための連合の認証と承認を提供します。この仕様は、アプリケーション認証[RFC7057]にEAPのための適用要件を満たしています。"
    },
    {
      "indent": 3,
      "text": "This mechanism is a GSS-API mechanism that encapsulates an EAP conversation. From the perspective of RFC 3748, this specification defines a new lower-layer protocol for EAP. From the perspective of the application, this specification defines a new GSS-API mechanism.",
      "ja": "このメカニズムは、EAPの会話をカプセル化するGSS-APIメカニズムです。 RFC 3748の観点から、本明細書は、EAPのための新たな下位層のプロトコルを定義します。アプリケーションの観点から、この仕様は新しいGSS-APIメカニズムを定義します。"
    },
    {
      "indent": 3,
      "text": "Section 1.3 of [RFC5247] outlines the typical conversation between EAP peers where an EAP key is derived:",
      "ja": "[RFC5247]のセクション1.3はEAPキーが導出されるEAPピアとの間の典型的な会話を概説します。"
    },
    {
      "indent": 3,
      "text": "Phase 0: Discovery Phase 1: Authentication 1a: EAP authentication 1b: AAA Key Transport (optional) Phase 2: Secure Association Protocol 2a: Unicast Secure Association 2b: Multicast Secure Association (optional)",
      "ja": "位相0：発見フェーズ1：認証1A：EAP認証1B：AAAキートランスポート（オプション）フェーズ2：セキュアアソシエーションプロトコル2A：ユニキャストセキュアアソシエーション2bは：アソシエーションをセキュアマルチキャスト（オプション）"
    },
    {
      "indent": 0,
      "text": "1.1. Discovery",
      "section_title": true,
      "ja": "1.1. 発見"
    },
    {
      "indent": 3,
      "text": "GSS-API peers discover each other and discover support for GSS-API in an application-dependent mechanism. SASL [RFC4422] describes how discovery of a particular SASL mechanism such as a GSS-API EAP mechanism is conducted. The Simple and Protected Negotiation mechanism (SPNEGO) [RFC4178] provides another approach for discovering what GSS-API mechanisms are available. The specific approach used for discovery is out of scope for this mechanism.",
      "ja": "GSS-APIピアは互いを発見し、アプリケーション依存性機構でGSS-APIのサポートを発見します。 SASL [RFC4422]は、そのようなGSS-API EAP機構として特定のSASL機構の発見を行う方法について説明します。単純で保護ネゴシエーションメカニズム（SPNEGO）[RFC4178]はGSS-APIメカニズムが利用可能であるかを発見するための別のアプローチを提供します。発見のために使用される特定のアプローチは、このメカニズムの範囲外です。"
    },
    {
      "indent": 0,
      "text": "1.2. Authentication",
      "section_title": true,
      "ja": "1.2. 認証"
    },
    {
      "indent": 3,
      "text": "GSS-API authenticates a party called the \"GSS-API initiator\" to the GSS-API acceptor, optionally providing authentication of the acceptor to the initiator. Authentication starts with a mechanism-specific message called a \"context token\" sent from the initiator to the acceptor. The acceptor responds, followed by the initiator, and so on until authentication succeeds or fails. GSS-API context tokens are reliably delivered by the application using GSS-API. The application is responsible for in-order delivery and retransmission.",
      "ja": "GSS-APIは、当事者は、必要に応じてイニシエータにアクセプターの認証を提供し、GSS-APIアクセプターへの「GSS-APIのイニシエーター」と呼ばれる認証します。認証は、アクセプターに、イニシエータから送信された「コンテキストトークン」と呼ばれる機構固有のメッセージで始まります。アクセプターは、認証が成功または失敗するまでようにイニシエータが続き、そして、応答します。 GSS-APIコンテキストトークンを確実にGSS-APIを使用するアプリケーションによって提供されています。アプリケーションは、順序どおりの配信および再送信を担当しています。"
    },
    {
      "indent": 3,
      "text": "EAP authenticates a party called a \"peer\" to a party called the \"EAP server\". A third party called an \"EAP pass-through authenticator\" may decapsulate EAP messages from a lower layer and re-encapsulate them into a AAA protocol. The term EAP authenticator refers to whichever of the pass-through authenticator or EAP server receives the lower-layer EAP packets. The first EAP message travels from the authenticator to the peer; a GSS-API message is sent from the initiator to acceptor to prompt the authenticator to send the first EAP message. The EAP peer maps onto the GSS-API initiator. The role of the GSS-API acceptor is split between the EAP authenticator and the EAP server. When these two entities are combined, the division resembles GSS-API acceptors in other mechanisms. When a more typical deployment is used and there is a pass-through authenticator, most context establishment takes place on the EAP server and per-message operations take place on the authenticator. EAP messages from the peer to the authenticator are called responses; messages from the authenticator to the peer are called requests.",
      "ja": "EAPは、「EAPサーバ」と呼ばれるパーティはパーティを「ピア」と呼ばれる認証を行います。サードパーティは、「EAPパススルー認証者は」下位層からEAPメッセージをデカプセル化してもよいし、AAAプロトコルにそれらを再カプセル化と呼ばれます。用語EAP認証はパススルー認証者のいずれかを意味するか、EAPサーバは、下位層のEAPパケットを受信します。最初のEAPメッセージは、ピアに認証者から移動します。 GSS-APIメッセージは、最初のEAPメッセージを送信するために、認証を要求するようにアクセプターに、イニシエータから送信されます。 EAPピアはGSS-APIのイニシエータにマッピングします。 GSS-APIのアクセプタの役割は、EAP認証とEAPサーバの間で分割されます。これら2つのエンティティを組み合わせた場合、分割が他のメカニズムでGSS-APIアクセプターに似ています。より一般的な展開を使用して、パススルー認証システムがあるされている場合、ほとんどのコンテキスト確立は、EAPサーバ上で行われ、メッセージごとの操作は、オーセンティケータに場所を取ります。オーセンティケータへのピアからのEAPメッセージが応答と呼ばれています。オーセンティケータからピアへのメッセージは要求と呼ばれています。"
    },
    {
      "indent": 3,
      "text": "Because GSS-API applications provide guaranteed delivery of context tokens, the EAP retransmission timeout MUST be infinite and the EAP layer MUST NOT retransmit a message.",
      "ja": "GSS-APIアプリケーションはコンテキストトークンの配信保証を提供しているため、EAPの再送タイムアウトは無限でなければならないとEAP層は、メッセージを再送してはなりません。"
    },
    {
      "indent": 3,
      "text": "This specification permits a GSS-API acceptor to hand off the processing of the EAP packets to a remote EAP server by using AAA protocols such as RADIUS, Transport Layer Security (TLS) Encryption thereof [RFC6929], or Diameter. In this case, the GSS-API acceptor acts as an EAP pass-through authenticator. The pass-through authenticator is responsible for retransmitting AAA messages if a response is not received from the AAA server. If a response cannot be received, then the authenticator generates an error at the GSS-API level. If EAP authentication is successful, and where the chosen EAP method supports key derivation, EAP keying material may also be derived. If a AAA protocol is used, this can also be used to replicate the EAP Key from the EAP server to the EAP authenticator.",
      "ja": "この仕様は、RADIUS、トランスポート層セキュリティ（TLS）[RFC6929]その暗号化、または直径としてAAAプロトコルを使用してリモートEAPサーバへのEAPパケットの処理をハンドオフするためにGSS-APIアクセプターを可能にします。この場合、GSS-APIのアクセプターはEAPパススルー認証者として機能します。パススルー認証システムは、応答がAAAサーバから受信されていない場合、AAAメッセージを再送信する責任があります。応答を受信できない場合は、オーセンティケータはGSS-APIレベルでエラーが発生します。 EAP認証が成功した場合、および選択されたEAPメソッドがキー導出をサポートする場合、EAPキーイング材料も誘導することができます。 AAAプロトコルが使用されている場合、これはまた、EAP認証にEAPサーバからのEAPキーを複製するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "See Section 5 for details of the authentication exchange.",
      "ja": "認証交換の詳細については、第5章を参照してください。"
    },
    {
      "indent": 0,
      "text": "1.3. Secure Association Protocol",
      "section_title": true,
      "ja": "1.3. セキュアアソシエーションプロトコル"
    },
    {
      "indent": 3,
      "text": "After authentication succeeds, GSS-API provides a number of per-message security services that can be used:",
      "ja": "認証が成功した後、GSS-APIを使用することができ、メッセージごとのセキュリティサービスの数を提供します。"
    },
    {
      "indent": 6,
      "text": "GSS_Wrap() provides integrity and optional confidentiality for a message.",
      "ja": "GSS_Wrap（）は、メッセージの整合性とオプションの機密性を提供します。"
    },
    {
      "indent": 6,
      "text": "GSS_GetMIC() provides integrity protection for data sent independently of the GSS-API",
      "ja": "GSS_GetMIC（）GSS-APIとは独立して送信されるデータの整合性の保護を提供"
    },
    {
      "indent": 6,
      "text": "GSS_Pseudo_random [RFC4401] provides key derivation functionality.",
      "ja": "GSS_Pseudo_random [RFC4401]は、鍵導出機能を提供します。"
    },
    {
      "indent": 3,
      "text": "These services perform a function similar to secure association protocols in network access. Like secure association protocols, these services need to be performed near the authenticator/acceptor even when a AAA protocol is used to separate the authenticator from the EAP server. The key used for these per-message services is derived from the EAP key; the EAP peer and authenticator derive this key as a result of a successful EAP authentication. In the case that the EAP authenticator is acting as a pass-through, it obtains it via the AAA protocol. See Section 6 for details.",
      "ja": "これらのサービスは、ネットワークアクセスに関連プロトコルを確保するために同様の機能を実行します。安全な協会プロトコルと同様に、これらのサービスは、AAAプロトコルがEAPサーバからオーセンティケータを分離するために使用されていても、認証/アクセプターの近くに実行する必要があります。これらのメッセージごとのサービスのために使用されるキーは、EAPキーから導出されます。 EAPピアとオーセンティケータは成功したEAP認証の結果として、このキーを導き出します。 EAP認証がパススルーとして動作している場合には、AAAプロトコルを介してそれを取得します。詳細については、第6章を参照してください。"
    },
    {
      "indent": 0,
      "text": "2. Requirements Notation",
      "section_title": true,
      "ja": "2.要件表記"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はあります[RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "3. EAP Channel Binding and Naming",
      "section_title": true,
      "ja": "3. EAPチャンネルバインドと命名"
    },
    {
      "indent": 3,
      "text": "EAP authenticates a user to a realm. The peer knows that it has exchanged authentication with an EAP server in a given realm. Today, the peer does not typically know which NAS it is talking to securely. That is often fine for network access. However, privileges to delegate to a chat server seem very different than privileges for a file server or trading site. Also, an EAP peer knows the identity of the home realm, but perhaps not even the visited realm.",
      "ja": "EAPは、レルムにユーザーを認証します。ピアは、それが特定の分野におけるEAPサーバとの認証を交換したことを知っています。今日では、ピアは、典型的には、それがしっかりと話をしているNASを知りません。それは、多くの場合、ネットワークアクセスのための罰金です。しかし、チャットサーバに委譲する権限は、ファイルサーバーや取引サイトの権限は非常に異なるように見えます。また、EAPピアはホーム領域のアイデンティティを知っている、おそらくないにも訪問した分野。"
    },
    {
      "indent": 3,
      "text": "In contrast, GSS-API takes a name for both the initiator and acceptor as inputs to the authentication process. When mutual authentication is used, both parties are authenticated. The granularity of these names is somewhat mechanism dependent. In the case of the Kerberos mechanism, the acceptor name typically identifies both the protocol in use (such as IMAP) and the specific instance of the service being connected to. The acceptor name almost always identifies the administrative domain providing service.",
      "ja": "これとは対照的に、GSS-APIは、認証プロセスへの入力として、イニシエータとアクセプタの両方の名前を取ります。相互認証を使用する場合は、両当事者が認証されます。これらの名前の粒度はややメカニズムに依存しています。ケルベロス機構の場合には、アクセプター名は、典型的には、使用中のプロトコル（例えば、IMAPなど）とに接続されているサービスの特定のインスタンスの両方を識別する。アクセプター名はほとんどの場合、サービスを提供する管理ドメインを識別します。"
    },
    {
      "indent": 3,
      "text": "A GSS-API EAP mechanism needs to provide GSS-API naming semantics in order to work with existing GSS-API applications. EAP channel binding [RFC6677] is used to provide GSS-API naming semantics. Channel binding sends a set of attributes from the peer to the EAP server either as part of the EAP conversation or as part of a secure association protocol. In addition, attributes are sent in the backend authentication protocol from the authenticator to the EAP server. The EAP server confirms the consistency of these attributes. Confirming attribute consistency also involves checking consistency against a local policy database as discussed in Section 3.5. In particular, the peer sends the name of the acceptor it is authenticating to as part of channel binding. The acceptor sends its full name as part of the backend authentication protocol. The EAP server confirms consistency of the names.",
      "ja": "GSS-API EAPメカニズムは、既存のGSS-APIアプリケーションと連携するために、GSS-APIのネーミングセマンティクスを提供する必要があります。 [RFC6677]を結合EAPチャネルは、GSS-APIのネーミングセマンティクスを提供するために使用されます。結合チャネルは、EAPの会話の一部として、または安全な協会プロトコルの一部としてのいずれかEAPサーバへのピアからの属性のセットを送信します。また、属性がEAPサーバにオーセンティケータからバックエンド認証プロトコルに送信されます。 EAPサーバは、これらの属性の一貫性を確認しました。属性の一貫性を確認することも、セクション3.5で説明したように、ローカルポリシーデータベースに対して整合性をチェック含まれます。具体的には、ピアは、それが結合チャネルの一部として認証されているアクセプターの名前を送信します。アクセプターは、バックエンドの認証プロトコルの一部として、その完全な名前を送信します。 EAPサーバは、名前の一貫性を確認しました。"
    },
    {
      "indent": 3,
      "text": "EAP channel binding is easily confused with a facility in GSS-API also called \"channel binding\". GSS-API channel binding provides protection against man-in-the-middle attacks when GSS-API is used as authentication inside some tunnel; it is similar to a facility called \"cryptographic binding\" in EAP. See [RFC5056] for a discussion of the differences between these two facilities and Section 6.1 for how GSS-API channel binding is handled in this mechanism.",
      "ja": "結合EAPチャネルはまた、「結合チャネル」と呼ばれるGSS-APIにおける機能と簡単に混乱しています。結合GSS-APIチャネルはGSS-APIは、いくつかのトンネル内認証として使用されるman-in-the-middle攻撃に対する保護を提供します。それは、EAPに「暗号の結合」と呼ばれる施設に似ています。結合GSS-APIのチャネルは、このメカニズムで処理される方法のためにこれらの2つの機能と6.1節の相違点については、[RFC5056]を参照してください。"
    },
    {
      "indent": 0,
      "text": "3.1. Mechanism Name Format",
      "section_title": true,
      "ja": "3.1. メカニズム名の形式"
    },
    {
      "indent": 3,
      "text": "Before discussing how the initiator and acceptor names are validated in the AAA infrastructure, it is necessary to discuss what composes a name for an EAP GSS-API mechanism. GSS-API permits several types of generic names to be imported using GSS_Import_name(). Once a mechanism is chosen, these names are converted into a mechanism-specific name called a \"Mechanism Name\". Note that a Mechanism Name is the name of an initiator or acceptor, not of a GSS-API mechanism. This section first discusses the mechanism name form and then discusses what name forms are supported.",
      "ja": "イニシエータとアクセプタ名がAAAインフラストラクチャで検証されている方法を説明する前に、EAP GSS-APIメカニズムの名前を構成するものを議論する必要があります。 GSS-APIは、一般的な名前のいくつかの種類がGSS_Import_nameを使用してインポートすることができます（）。メカニズムが選択されると、これらの名前は、「機構名」と呼ばれる機構固有の名前に変換されます。機構名がイニシエータまたはアクセプターのではなく、GSS-API機構の名前であることに注意してください。このセクションでは、最初のメカニズム名の形式について説明し、その後、名前形式がサポートされているものを説明します。"
    },
    {
      "indent": 3,
      "text": "The string representation of the GSS-EAP mechanism name has the following ABNF [RFC5234] representation:",
      "ja": "GSS-EAP機構名の文字列表現は、以下のABNF [RFC5234]表現を有します。"
    },
    {
      "indent": 8,
      "text": "char-normal = %x00-2E/%x30-3F/%x41-5B/%x5D-FF\nchar-escaped = \"\\\" %x2F / \"\\\" %x40 / \"\\\" %x5C\nname-char = char-normal / char-escaped\nname-string = 1*name-char\nuser-or-service = name-string\nhost = [name-string]\nrealm = name-string\nservice-specific = name-string\nservice-specifics = service-specific 0*(\"/\" service-specifics)\nname = user-or-service [\"/\" host [ \"/\" service-specifics]] [ \"@\"\n        realm ]",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Special characters appearing in a name can be backslash escaped to avoid their special meanings. For example, \"\\\\\" represents a literal backslash. This escaping mechanism is a property of the string representation; if the components of a name are transported in some mechanism that will keep them separate without backslash escaping, then backslash SHOULD have no special meaning.",
      "ja": "名前に登場する特殊文字はバックスラッシュは、その特別な意味を避けるためにエスケープすることができます。たとえば、「\\\\」リテラルバックスラッシュを表します。このエスケープ機構は、文字列表現のプロパティです。名前のコンポーネントはバックスラッシュをエスケープせずに別々にそれらを維持するいくつかのメカニズムに輸送される場合は、バックスラッシュは特別な意味を持っていないはずです。"
    },
    {
      "indent": 3,
      "text": "The user-or-service component is similar to the portion of a network access identifier (NAI) before the '@' symbol for initiator names and the service name from the registry of GSS-API host-based services in the case of acceptor names [GSS-IANA]. The NAI specification provides rules for encoding and string preparation in order to support internationalization of NAIs; implementations of this mechanism MUST NOT prepare the user-or-service according to these rules; see Section 3.2 for internationalization of this mechanism. The host portion is empty for initiators and typically contains the domain name of the system on which an acceptor service is running. Some services MAY require additional parameters to distinguish the entity being authenticated against. Such parameters are encoded in the service-specifics portion of the name. The EAP server MUST reject authentication of any acceptor name that has a non-empty service-specifics component unless the EAP server understands the service-specifics and authenticates them. The interpretation of the service-specifics is scoped by the user-or-service portion. The realm is similar to the realm portion of a NAI for initiator names; again the NAI specification's internationalization rules MUST NOT be applied to the realm. The realm is the administrative realm of a service for an acceptor name.",
      "ja": "ユーザまたはサービス・コンポーネントは、アクセプター名の場合にはGSS-APIのホストベースのサービスのレジストリからイニシエータ名に「@」記号とサービス名の前にネットワークアクセス識別子（NAI）の部分に似ています[GSS-IANA]。 NAI仕様はのNAIの国際化をサポートするために符号化し、文字列を調製するためのルールを提供します。このメカニズムの実装は、以下のルールに従って、ユーザ又はサービスを用意してはいけません。このメカニズムの国際化のためのセクション3.2を参照してください。ホスト部分は、イニシエータの空で、通常、アクセプター・サービスが実行されているシステムのドメイン名が含まれています。一部のサービスはに対して認証されたエンティティを区別するために追加のパラメータが必要な場合があります。そのようなパラメータは、名前のサービス内容の部分に符号化されます。 EAPサーバは、EAPサーバがサービス仕様を理解し、それらを認証しない限り、非空でサービスの仕様の成分を有する任意のアクセプター名の認証を拒絶しなければなりません。サービス内容の解釈は、ユーザまたはサービス部によってスコープされます。レルムは、イニシエータ名のNAIのレルム部分と類似しています。再びNAI仕様の国際ルールは、レルムに適用してはなりません。レルムは、アクセプター名のサービスの管理領域です。"
    },
    {
      "indent": 3,
      "text": "The string representation of this name form is designed to be generally compatible with the string representation of Kerberos names defined in [RFC1964].",
      "ja": "この名前の形式の文字列表現は、[RFC1964]で定義されたケルベロス名の文字列表現とほぼ適合するように設計されています。"
    },
    {
      "indent": 3,
      "text": "The GSS_C_NT_USER_NAME form represents the name of an individual user. From the standpoint of this mechanism, it may take the form of either an undecorated user name or a name semantically similar to a network access identifier (NAI) [RFC4282]. The name is split at the first at-sign ('@') into the part preceding the realm, which is the user-or-service portion of the mechanism name, and the realm portion, which is the realm portion of the mechanism name.",
      "ja": "GSS_C_NT_USER_NAME形態は、個々のユーザーの名前を表します。このメカニズムの観点からは、装飾されていないユーザー名またはネットワークアクセス識別子（NAI）[RFC4282]と意味的に類似した名前のいずれかの形態をとることができます。名前はアットマーク（「@」）機構名のレルム部分であり、機構名のユーザ又はサービスの部分である領域、およびレルム部分を、前の部分に最初に分割され。"
    },
    {
      "indent": 3,
      "text": "The GSS_C_NT_HOSTBASED_SERVICE name form represents a service running on a host; it is textually represented as \"service@host\". This name form is required by most SASL profiles and is used by many existing applications that use the Kerberos GSS-API mechanism. While support for this name form is critical, it presents an interesting challenge in terms of EAP channel binding. Consider a case where the server communicates with a \"server proxy,\" or a AAA server near the server. That server proxy communicates with the EAP server. The EAP server and server proxy are in different administrative realms. The server proxy is in a position to verify that the request comes from the indicated host. However, the EAP server cannot make this determination directly. So, the EAP server needs to determine whether to trust the server proxy to verify the host portion of the acceptor name. This trust decision depends both on the host name and the realm of the server proxy. In effect, the EAP server decides whether to trust that the realm of the server proxy is the right realm for the given hostname and then makes a trust decision about the server proxy itself. The same problem appears in Kerberos: there, clients decide what Kerberos realm to trust for a given hostname. The service portion of this name is imported into the user-or-service portion of the mechanism name; the host portion is imported into the host portion of the mechanism name. The realm portion is empty. However, authentication will typically fail unless some AAA component indicates the realm to the EAP server. If the application server knows its realm, then it should be indicated in the outgoing AAA request. Otherwise, a proxy SHOULD add the realm. An alternate form of this name type MAY be used on acceptors; in this case, the name form is \"service\" with no host component. This is imported with the service as user-or-service and an empty host and realm portion. This form is useful when a service is unsure which name an initiator knows it by.",
      "ja": "GSS_C_NT_HOSTBASED_SERVICE名の形式は、ホスト上で実行されているサービスを表します。それはテキストで「サービス@ホスト」として表現されます。この名前の形式は、ほとんどのSASLプロファイルによって必要とされ、Kerberos GSS-APIメカニズムを使用する多くの既存のアプリケーションで使用されます。この名前の形式のサポートは重要ですが、それが結合EAPチャネルの面で興味深い課題を提示しています。サーバは、「サーバプロキシ」、またはサーバーの近くにAAAサーバと通信する場合を考えてみましょう。そのサーバープロキシは、EAPサーバと通信します。 EAPサーバおよびサーバプロキシは、異なる管理のレルムです。サーバプロキシは、要求が指示されたホストから来ていることを確認する立場にあります。しかし、EAPサーバは、直接この決意をすることはできません。だから、EAPサーバは、アクセプター名のホスト部分を確認するために、サーバープロキシを信頼するかどうかを決定する必要があります。この信頼の決定は、ホスト名とサーバプロキシの領域の両方に依存します。実際には、EAPサーバは、サーバプロキシのレルムが与えられたホスト名の右側の領域であることを信頼するかどうかを決定し、その後、サーバプロキシ自体に関する信頼の決定を行います。同じ問題は、Kerberosに表示されますが、クライアントはKerberosレルムが指定されたホスト名のために信頼するかを決めます。この名前のサービス部分は、機構名のユーザまたはサービス部分にインポートされます。ホスト部分はメカニズム名のホスト部分にインポートされます。分野の部分は空です。いくつかのAAAコンポーネントがEAPサーバへのレルムを示していない限りただし、認証は一般的に失敗します。アプリケーションサーバはそのレルムを知っている場合、それは、発信AAA要求に示すべきです。それ以外の場合、プロキシは、レルムを追加する必要があります。この名前タイプの代替形態は、アクセプター上で使用することができます。この場合には、名前の形式はnoホストコンポーネントとの「サービス」です。これは、ユーザーやサービスなどのサービス空ホストとレルム部分でインポートされます。サービスは、イニシエータがによってそれを知っている名前が不明である場合は、このフォームが便利です。"
    },
    {
      "indent": 3,
      "text": "If the null name type or the GSS_EAP_NT_EAP_NAME (OID 1.3.6.1.5.5.15.2.1) (see Section 7.1 ) is imported, then the string representation above should be directly imported. Mechanisms MAY support the GSS_KRB5_NT_KRB5_PRINCIPAL_NAME name form with the OID {iso(1) member-body(2) United States(840) mit(113554) infosys(1) gssapi(2) krb5(2) krb5_name(1)}. In many circumstances, Kerberos GSS-API mechanism names will behave as expected when used with the GSS-API EAP mechanism, but there are some differences that may cause some confusion. If an implementation does support importing Kerberos names it SHOULD fail the import if the Kerberos name is not syntactically a valid GSS-API EAP mechanism name as defined in this section.",
      "ja": "ヌル名前タイプまたはGSS_EAP_NT_EAP_NAME（OID 1.3.6.1.5.5.15.2.1）は（7.1節を参照）インポートされている場合は、上記の文字列表現を直接インポートする必要があります。メカニズムはOIDとGSS_KRB5_NT_KRB5_PRINCIPAL_NAME名形式をサポートするかもしれ{ISO（1）部材本体（2）米国（840）MIT（113554）インフォシス（1）GSSAPI（2）krb5の（2）krb5_name（1）}。多くの状況では、KerberosのGSS-API機構名は、GSS-API EAP機構を使用すると、期待どおりに動作しますが、いくつかの混乱を引き起こす可能性があり、いくつかの違いがあります。実装がサポートは、Kerberos名をインポートしない場合は、このセクションで定義されているKerberos名が構文的に有効なGSS-API EAPメカニズム名でない場合には、インポートを失敗するはずです。"
    },
    {
      "indent": 0,
      "text": "3.2. Internationalization of Names",
      "section_title": true,
      "ja": "3.2. 名の国際化"
    },
    {
      "indent": 3,
      "text": "For the most part, GSS-EAP names are transported in other protocols; those protocols define the internationalization semantics. For example, if a AAA server wishes to communicate the user-or-service portion of the initiator name to an acceptor, it does so using existing mechanisms in the AAA protocol. Existing internationalization rules are applied. Similarly, within an application, existing specifications such as [RFC5178] define the encoding of names that are imported and displayed with the GSS-API.",
      "ja": "ほとんどの部分については、GSS-EAP名は、他のプロトコルに輸送されます。これらのプロトコルは、国際化の意味を定義します。 AAAサーバは、アクセプターにイニシエータ名のユーザまたはサービス部分を通信することを望む場合、例えば、それはそうAAAプロトコルにおける既存のメカニズムを使用しません。既存の国際ルールが適用されます。同様に、アプリケーション内で、このような[RFC5178]などの既存の仕様は、インポートとGSS-APIで表示される名前の符号化を定義します。"
    },
    {
      "indent": 3,
      "text": "This mechanism does introduce a few cases where name components are sent. In these cases, the encoding of the string is UTF-8. Senders SHOULD NOT normalize or map strings before sending. These strings include RADIUS attributes introduced in Section 3.4.",
      "ja": "このメカニズムは、名前のコンポーネントが送信されるいくつかの例を紹介しません。これらの例では、文字列のエンコーディングはUTF-8です。送信者は、送信する前に、文字列を正規化するか、マッピングしてはなりません。これらの文字列は、セクション3.4で導入されたRADIUS属性が含まれます。"
    },
    {
      "indent": 3,
      "text": "When comparing the host portion of a GSS-EAP acceptor name supplied in EAP channel binding by a peer to that supplied by an acceptor, EAP servers SHOULD prepare the host portion according to [RFC5891] prior to comparison. Applications MAY prepare domain names prior to importing them into this mechanism.",
      "ja": "アクセプターによって供給されるものとピアによってEAP結合チャネルに供給されるGSS-EAP受容名のホスト部分を比較した場合、EAPサーバは、比較の前に[RFC5891]に記載のホスト部分を準備する必要があります。アプリケーションは、このメカニズムにインポートする前に、ドメイン名を作成することができます。"
    },
    {
      "indent": 0,
      "text": "3.3. Exported Mechanism Names",
      "section_title": true,
      "ja": "3.3. エクスポートされたメカニズム名"
    },
    {
      "indent": 3,
      "text": "GSS-API provides the GSS_Export_name call. This call can be used to export the binary representation of a name. This name form can be stored on access control lists for binary comparison.",
      "ja": "GSS-APIはGSS_Export_nameコールを提供します。この呼び出しは、名前のバイナリ表現をエクスポートするために使用することができます。この名前の形式は、バイナリ比較のために、アクセス制御リストに保存することができます。"
    },
    {
      "indent": 3,
      "text": "The exported name token MUST use the format described in Section 3.2 of RFC 2743. The mechanism specific portion of this name token is the string format of the mechanism name described in Section 3.1.",
      "ja": "エクスポートされた名前のトークンは、この名前のトークンのメカニズム特定の部分は、セクション3.1で説明されたメカニズム名の文字列形式であるRFC 2743のセクション3.2で説明したフォーマットを使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "RFC 2744 [RFC2744] places the requirement that the result of importing a name, canonicalizing it to a Mechanism Name and then exporting it needs to be the same as importing that name, obtaining credentials for that principal, initiating a context with those credentials and exporting the name on the acceptor. In practice, GSS mechanisms often, but not always, meet this requirement. For names expected to be used as initiator names, this requirement is met. However, permitting empty host and realm components when importing host-based services may make it possible for an imported name to differ from the exported name actually used. Other mechanisms such as Kerberos have similar situations where imported and exported names may differ.",
      "ja": "RFC 2744 [RFC2744]は、名前をインポートメカニズム名前にcanonicalizing、次にエクスポートの結果は、それが、その名前をインポートそのプリンシパルの信任状を取得し、それらの資格情報を使用してコンテキストを開始し、エクスポートと同じである必要がある要件を課しますアクセプターの名前。実際には、GSSメカニズムは、多くの場合、常にではないが、この要件を満たしています。イニシエータ名として使用されることが期待名については、この要件が満たされています。インポートされた名前は、実際に使用されエクスポートされた名前と異なるためただし、ホストベースのサービスをインポートするときに、空のホストおよびレルムのコンポーネントを許可することで行うことができます。 Kerberosなどの他の機構は、インポートおよびエクスポート名が異なる場合が同様の状況を持っています。"
    },
    {
      "indent": 0,
      "text": "3.4. Acceptor Name RADIUS AVP",
      "section_title": true,
      "ja": "3.4. アクセプター名RADIUS AVP"
    },
    {
      "indent": 3,
      "text": "See Section 7.4 for registrations of RADIUS attribute types to carry the acceptor service name. All the attribute types registered in that section are strings. See Section 3.1 for details of the values in a name.",
      "ja": "RADIUSの登録については、セクション7.4を参照してくださいアクセプター・サービス名を運ぶために属性タイプ。そのセクションに登録されたすべての属性タイプは文字列です。名前の値の詳細については、3.1節を参照してください。"
    },
    {
      "indent": 3,
      "text": "If RADIUS is used as a AAA transport, the acceptor MUST send the acceptor name in these attribute types. That is, the acceptor decomposes its name and sends any non-empty portion as a RADIUS attribute. With the exception of the service-specifics portion of the name, the backslash escaping mechanism is not used in RADIUS attributes; backslash has no special meaning. In the service-specifics portion, a literal \"/\" separates components. In this one attribute, \"\\/\" indicates a slash character that does not separate components and \"\\\\\" indicates a literal backslash character.",
      "ja": "RADIUSは、AAAのトランスポートとして使用されている場合、アクセプターは、これらの属性タイプにアクセプター名を送らなければなりません。つまり、アクセプターは、その名前を分解し、RADIUS属性として任意の空でない部分を送信します。名前のサービス仕様の部分を除き、バックスラッシュエスケープ機構は、属性をR​​ADIUSで使用されていません。バックスラッシュは特別な意味を持ちません。サービス詳細部分において、リテラルは、「/」の成分を分離します。この一つの属性では、「\\ /」ではない、別のコンポーネントがと「\\\\」リテラルのバックスラッシュ文字を示していスラッシュ文字を示します。"
    },
    {
      "indent": 3,
      "text": "The initiator MUST require that the EAP method in use support channel binding and MUST send the acceptor name as part of the channel binding data. The client MUST NOT indicate mutual authentication in the result of GSS_Init_sec_context unless all name elements that the client supplied are in a successful channel binding response. For example, if the client supplied a hostname in channel binding data, the hostname MUST be in a successful channel binding response.",
      "ja": "開始剤は、使用支持チャネルにおけるEAPメソッドが結合することを要求しなければならないとデータを結合チャネルの一部として、アクセプター名を送らなければなりません。クライアントが提供するすべての名前の要素が成功したチャネル結合反応していない限り、クライアントは、もしGSS_Init_sec_contextの結果で相互認証を示してはいけません。クライアントがデータを結合チャネルでホスト名を指定した場合は、例えば、ホスト名が成功したチャネル結合応答でなければなりません。"
    },
    {
      "indent": 3,
      "text": "If an empty target name is supplied to GSS_Init_sec_context, the initiator MUST fail context establishment unless the acceptor supplies the acceptor name response (Section 5.4.3). If a null target name is supplied, the initiator MUST use this response to populate EAP channel bindings.",
      "ja": "空のターゲット名がもしGSS_Init_sec_contextに供給されている場合はアクセプターが受容名応答（5.4.3項）を供給しない限り、イニシエータは、コンテキストの確立に失敗しなければなりません。ヌルターゲット名が与えられた場合、イニシエータは、EAPチャネルバインディングを移入するために、この応答を使用しなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.5. Proxy Verification of Acceptor Name",
      "section_title": true,
      "ja": "3.5. アクセプターの名前のプロキシの検証"
    },
    {
      "indent": 3,
      "text": "Proxies may play a role in verification of the acceptor identity. For example, a AAA proxy near the acceptor may be in a position to verify the acceptor hostname, while the EAP server is likely to be too distant to reliably verify this on its own.",
      "ja": "プロキシは、アクセプターのアイデンティティの検証において役割を果たし得ます。 EAPサーバは確実に自分自身でこれを確認するにはあまりにも遠い可能性がある一方、例えば、アクセプタ近くAAAプロキシは、アクセプターのホスト名を確認する立場にあってもよいです。"
    },
    {
      "indent": 3,
      "text": "The EAP server or some proxy trusted by the EAP server is likely to be in a position to verify the acceptor realm. In effect, this proxy is confirming that the right AAA credential is used for the claimed realm and thus that the acceptor is in the organization it claims to be part of. This proxy is also typically trusted by the EAP server to make sure that the hostname claimed by the acceptor is a reasonable hostname for the realm of the acceptor.",
      "ja": "EAPサーバまたはEAPサーバによって信頼され、いくつかのプロキシは、アクセプター領域を確認する立場になる可能性があります。実際には、このプロキシは右AAAクレデンシャルはアクセプターがそれの一部であると主張する組織であることが記載レルムのために使用されることが確認されています。このプロキシは、通常、アクセプターが主張するホスト名は、アクセプタの領域のための合理的なホスト名であることを確認するために、EAPサーバによって信頼されています。"
    },
    {
      "indent": 3,
      "text": "A proxy close to the EAP server is unlikely to be in a position to confirm that the acceptor is claiming the correct hostname. Instead, this is typically delegated to a proxy near the acceptor. That proxy is typically expected to verify the acceptor hostname and to verify the appropriate AAA credential for that host is used. Such a proxy may insert the acceptor realm if it is absent, permitting realm configuration to be at the proxy boundary rather than on acceptors.",
      "ja": "EAPサーバに近いプロキシは、アクセプターが正しいホスト名を主張していることを確認する立場になることはほとんどありません。その代わり、これは一般的に受容近くプロキシに委任されます。そのプロキシは、典型的には、アクセプターのホスト名を確認し、そのホストのための適切なAAAクレデンシャルが使用されていることを確認することが期待されます。それが存在しない場合、このようなプロキシは、プロキシの境界ではなく、受容体上にある領域の構成を可能に、アクセプター領域を挿入することができます。"
    },
    {
      "indent": 3,
      "text": "Ultimately, specific proxy behavior is a matter for deployment. The EAP server MUST assure that the appropriate validation has been done before including acceptor name attributes in a successful channel binding response. If the acceptor service is included, the EAP server asserts that the service is plausible for the acceptor. If the acceptor hostname is included, the EAP server asserts that the acceptor hostname is verified. If the realm is included the EAP server asserts that the realm has been verified, and if the hostname was also included, that the realm and hostname are consistent. Part of this verification MAY be delegated to proxies, but the EAP server configuration MUST guarantee that the combination of proxies meets these requirements. Typically, such delegation will involve business or operational measures such as cross-organizational agreements as well as technical measures.",
      "ja": "最終的には、特定のプロキシの動作は、展開のための問題です。 EAPサーバは、適切な検証がアクセプター名が成功したチャネル結合応答の属性を含む前に行われていることを保証しなければなりません。アクセプター・サービスが含まれている場合、EAPサーバは、サービスがアクセプターのためのもっともらしいことを主張します。アクセプターのホスト名が含まれている場合、EAPサーバは、アクセプターのホスト名が検証されたと主張しています。レルムが含まれている場合、EAPサーバは、レルムが検証されたと主張し、ホスト名も含まれていた場合、領域とホスト名が一致していること。この検証の一部は、プロキシに委任することができるが、EAPサーバの設定は、プロキシの組み合わせがこれらの要件を満たしていることを保証しなければなりません。代表的には、このような委任は、組織横断的な契約だけでなく、技術的な措置として、ビジネスや運用の措置を必要とするだろう。"
    },
    {
      "indent": 3,
      "text": "It is likely that future technical work will be needed to communicate what verification has been done by proxies along the path. Such technical measures will not release the EAP server from its responsibility to decide whether proxies on the path should be trusted to perform checks delegated to them. However, technical measures could prevent misconfigurations and help to support diverse environments.",
      "ja": "将来の技術的な仕事は、パスに沿ってプロキシが行われていたものを検証通信に必要となる可能性が高いです。このような技術的な措置は、パス上のプロキシがそれらに委任チェックを実行するために信頼すべきかどうかを決定するために、その責任からEAPサーバを解放しません。しかし、技術的な対策は、設定ミスを防止し、多様な環境をサポートするために助けることができます。"
    },
    {
      "indent": 0,
      "text": "4. Selection of EAP Method",
      "section_title": true,
      "ja": "EAPメソッドの4セレクション"
    },
    {
      "indent": 3,
      "text": "EAP does not provide a facility for an EAP server to advertise what methods are available to a peer. Instead, a server starts with its preferred method selection. If the peer does not accept that method, the peer sends a NAK response containing the list of methods supported by the client.",
      "ja": "EAPは、ピアに利用可能な方法を宣伝するためにEAPサーバのための施設を提供していません。代わりに、サーバーは、その好ましい方法の選択から始まります。ピアはその方法を受け入れない場合、ピアは、クライアントでサポートされているメソッドのリストを含むNAK応答を送信します。"
    },
    {
      "indent": 3,
      "text": "Providing multiple facilities to negotiate which security mechanism to use is undesirable. Section 7.3 of [RFC4462]describes the problem referencing the Secure Shell (SSH) Protocol key exchange negotiation and the SPNEGO GSS-API mechanism. If a client preferred an EAP method A, a non-EAP authentication mechanism B, and then an EAP method C, then the client would have to commit to using EAP before learning whether A is actually supported. Such a client might end up using C when B is available.",
      "ja": "使用するセキュリティメカニズム交渉する複数の施設を提供することは望ましくありません。 [RFC4462]のセクション7.3は、セキュアシェル（SSH）プロトコル鍵交換交渉とSPNEGO GSS-APIメカニズムを参照する問題について説明します。クライアントがEAP方法A、非EAP認証機構B、その後、EAPメソッドCを優先した場合、クライアントはAが実際にサポートされているかどうかを学習する前に、EAPを使用してコミットする必要があります。このようなクライアントは、Bが利用可能なときにCを使用して終わるかもしれません。"
    },
    {
      "indent": 3,
      "text": "The standard solution to this problem is to perform all the negotiation at one layer. In this case, rather than defining a single GSS-API mechanism, a family of mechanisms should be defined. Each mechanism corresponds to an EAP method. The EAP method type should be part of the GSS-API OID. Then, a GSS-API rather than EAP facility can be used for negotiation.",
      "ja": "この問題の標準溶液を1層で、すべてのネゴシエーションを実行することです。この場合には、むしろ単一のGSS-API機構を定義するよりも、機構のファミリーが定義されるべきです。各機構は、EAPメソッドに対応します。 EAPメソッドタイプは、GSS-API OIDの一部である必要があります。その後、GSS-APIはなく、EAP施設は、交渉のために使用することができます。"
    },
    {
      "indent": 3,
      "text": "Unfortunately, using a family of mechanisms has a number of problems. First, GSS-API assumes that both the initiator and acceptor know the entire set of mechanisms that are available. Some negotiation mechanisms are driven by the client; others are driven by the server. With EAP GSS-API, the acceptor does not know what methods the EAP server implements. The EAP server that is used depends on the identity of the client. The best solution so far is to accept the disadvantages of multi-layer negotiation and commit to using EAP GSS-API before a specific EAP method. This has two main disadvantages. First, authentication may fail when other methods might allow authentication to succeed. Second, a non-optimal security mechanism may be chosen.",
      "ja": "残念ながら、メカニズムの家族を使用すると、多くの問題があります。まず、GSS-APIは、イニシエータとアクセプタの両方が利用できる機構のセット全体を知っていることを前提としています。いくつかの交渉メカニズムは、クライアントによって駆動されます。他の人がサーバーによって駆動されます。 EAP GSS-APIを使用すると、アクセプターは、どのような方法EAPサーバの実装を知りません。使用されているEAPサーバは、クライアントのアイデンティティに依存します。これまでの最善の解決策は、多層交渉の欠点を受け入れ、特定のEAPメソッドの前にEAP GSS-APIを使用してコミットすることです。これは、2つの主な欠点を持っています。まず、認証は、他の方法は、認証が成功することを可能にする可能性がある場合失敗することがあります。第二に、非最適なセキュリティ・メカニズムを選択することができます。"
    },
    {
      "indent": 0,
      "text": "5. Context Tokens",
      "section_title": true,
      "ja": "5.コンテキストトークン"
    },
    {
      "indent": 3,
      "text": "All context establishment tokens emitted by the EAP mechanism SHALL have the framing described in Section 3.1 of [RFC2743], as illustrated by the following pseudo-ASN.1 structures:",
      "ja": "EAP機構によって放出されるすべてのコンテキスト確立トークンは以下の擬似ASN.1構造によって示されるように、[RFC2743]のセクション3.1に記載さフレーミングを有するものとします。"
    },
    {
      "indent": 3,
      "text": "GSS-API DEFINITIONS ::=\n         BEGIN",
      "raw": true
    },
    {
      "indent": 12,
      "text": "MechType ::= OBJECT IDENTIFIER\n-- representing EAP mechanism\nGSSAPI-Token ::=\n-- option indication (delegation, etc.) indicated within\n-- mechanism-specific token\n[APPLICATION 0] IMPLICIT SEQUENCE {\n        thisMech MechType,\n        innerToken ANY DEFINED BY thisMech\n           -- contents mechanism-specific\n           -- ASN.1 structure not required\n        }\nEND",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The innerToken field starts with a 16-bit network byte order token type identifier. The remainder of the innerToken field is a set of type-length-value subtokens. The following figure describes the structure of the inner token:",
      "ja": "innerTokenフィールドは、16ビットのネットワークバイト順トークンタイプ識別子から始まります。 innerTokenフィールドの残りの部分は、タイプレングス値のサブトークンのセットです。次の図は、内部トークンの構造について説明します。"
    },
    {
      "indent": 14,
      "text": "+----------------+---------------------------+\n| Octet Position | Description               |\n+----------------+---------------------------+\n| 0..1           | token ID                  |\n|                |                           |\n| 2..5           | first subtoken type       |\n|                |                           |\n| 6..9           | length  of first subtoken |\n|                |                           |\n| 10..10+n-1     | first subtoken body       |\n|                |                           |\n| 10+n..10+n+3   | second subtoken type      |\n+----------------+---------------------------+",
      "raw": true
    },
    {
      "indent": 25,
      "text": "Structure of Inner Token",
      "ja": "内部トークンの構造"
    },
    {
      "indent": 3,
      "text": "The inner token continues with length, second subtoken body, and so forth. If a subtoken type is present, its length and body MUST be present.",
      "ja": "内側トークンは、等長、第二サブトークン本体と、を続けます。サブトークンタイプが存在する場合、その長さ及び身体が存在しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The length is a four-octet length of the subtoken body in network byte order. The length does not include the length of the type field or the length field; the length only covers the body.",
      "ja": "長さは、ネットワークバイト順でサブトークン本体の4オクテット長です。長さは、タイプフィールドの長さまたは長さフィールドを含んでいません。長さは本体のみをカバーしています。"
    },
    {
      "indent": 3,
      "text": "Tokens from the initiator to acceptor use an inner token type with ID 06 01; tokens from acceptor to initiator use an inner token type with ID 06 02. These token types are registered in the registry of RFC 4121 token types; see Section 7.2.",
      "ja": "アクセプターへのイニシエータからのトークンは、ID 06 01とインナートークンタイプを使用します。アクセプターからのトークンが06 02これらのトークンのタイプは、RFC 4121トークンタイプのレジストリに登録されているIDとインナートークンタイプを使用して開始剤;セクション7.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "See Section 5.7 for the encoding of a complete token. The following sections discuss how mechanism OIDs are chosen and the state machine that defines what subtokens are permitted at each point in the context establishment process.",
      "ja": "完全なトークンのエンコーディングについては、セクション5.7を参照してください。以下のセクションでは、機構のOIDを選択する方法を議論し、サブトークンは、コンテキスト確立プロセスの各時点で許可されるかを定義ステートマシン。"
    },
    {
      "indent": 0,
      "text": "5.1. Mechanisms and Encryption Types",
      "section_title": true,
      "ja": "5.1. メカニズムおよび暗号化タイプ"
    },
    {
      "indent": 3,
      "text": "This mechanism family uses the security services of the Kerberos cryptographic framework [RFC3961]. The root of the OID ARC for mechanisms described in this document is 1.3.6.1.5.5.15.1.1; a Kerberos encryption type number [RFC3961] is appended to that root OID to form a mechanism OID. As such, a particular encryption type needs to be chosen. By convention, there is a single object identifier arc for the EAP family of GSS-API mechanisms. A specific mechanism is chosen by adding the numeric Kerberos encryption type number to the root of this arc. However, in order to register the SASL name, the specific usage with a given encryption type needs to be registered. This document defines the EAP-AES128 GSS-API mechanism.",
      "ja": "このメカニズムファミリは、Kerberos暗号化フレームワーク[RFC3961]のセキュリティサービスを使用しています。本書で説明されたメカニズムのためのOID ARCのルートは1.3.6.1.5.5.15.1.1あります。ケルベロス暗号化タイプ番号[RFC3961]は機構OIDを形成するために、そのルートのOIDに付加されます。そのため、特定の暗号化タイプを選択する必要があります。慣例により、GSS-API機構のEAPファミリの単一のオブジェクト識別子アークがあります。特定の機構は、この円弧のルートに数値ケルベロス暗号化タイプの数を追加することによって選択されます。しかし、SASL名を登録するためには、与えられた暗号化タイプとの具体的な使用方法は、登録する必要があります。この文書では、EAP-AES128 GSS-APIメカニズムを定義します。"
    },
    {
      "indent": 0,
      "text": "5.2. Processing Received Tokens",
      "section_title": true,
      "ja": "5.2. 受信したトークンを処理"
    },
    {
      "indent": 3,
      "text": "Whenever a context token is received, the receiver performs the following checks. First, the receiver confirms the object identifier is that of the mechanism being used. The receiver confirms that the token type corresponds to the role of the peer: acceptors will only process initiator tokens and initiators will only process acceptor tokens.",
      "ja": "コンテキストトークンが受信されるたびに、受信機は、次のチェックを行います。まず、受信機は、オブジェクト識別子が使用されている機構のもので確認します。受信機は、トークンタイプは、ピアの役割に対応することを確認：アクセプタのみ処理開始トークンと開始剤は、アクセプタートークンを処理するであろう。"
    },
    {
      "indent": 3,
      "text": "Implementations of this mechanism maintain a state machine for the context establishment process. Both the initiator and acceptor start out in the initial state; see Section 5.4 for a description of this state. Associated with each state are a set of subtoken types that are processed in that state and rules for processing these subtoken types. The receiver examines the subtokens in order, processing any that are appropriate for the current state. Unknown subtokens or subtokens that are not expected in the current state are ignored if their critical bit (see below) is clear.",
      "ja": "このメカニズムの実装は、コンテキスト確立処理のための状態機械を維持します。イニシエータとアクセプタの両方が初期状態で出始めます。この状態の説明については、5.4節を参照してください。各状態に関連付けられているこれらのサブトークンタイプを処理するために、その状態および規則で処理されるサブトークン型のセットです。受信機は、現在の状態のために適切である任意の処理を、順番にサブトークンを調べます。彼らの重要なビット（下記参照）がクリアされている場合、現在の状態では期待されていない未知のサブトークンまたはサブトークンは無視されます。"
    },
    {
      "indent": 3,
      "text": "A state may have a set of required subtoken types. If a subtoken type is required by the current state but no subtoken of that type is present, then the context establishment MUST fail.",
      "ja": "状態は、必要なサブトークンタイプのセットを有することができます。サブトークンタイプの現在の状態によって必要とされるが、そのタイプのないサブトークンが存在しない、コンテキストの確立が失敗しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The most significant bit (0x80000000) in a subtoken type is the critical bit. If a subtoken with this bit set in the type is received, the receiver MUST fail context establishment unless the subtoken is understood and processed for the current state.",
      "ja": "サブトークンタイプでは最上位ビット（0x80000000からは）重要なビットです。タイプに設定このビットがサブトークンを受信した場合にサブトークンを理解し、現在の状態のために処理されていない限り、受信器は、コンテキストの確立に失敗しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The subtoken type MUST be unique within a given token.",
      "ja": "サブトークンタイプが与えられたトークン内で一意でなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.3. Error Subtokens",
      "section_title": true,
      "ja": "5.3. エラーサブトークン"
    },
    {
      "indent": 3,
      "text": "The acceptor may always end the exchange by generating an error subtoken. The error subtoken has the following format:",
      "ja": "アクセプターは、常にエラーのサブトークンを生成することにより、交換を終了する場合があります。エラーサブトークンの形式は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "+--------+----------------------------------------------------------+\n| Pos    | Description                                              |\n+--------+----------------------------------------------------------+\n| 0..3   | 0x80 00 00 01                                            |\n|        |                                                          |\n| 4..7   | length of error token                                    |\n|        |                                                          |\n| 8..11  | major status from RFC 2744 as 32-bit network byte order  |\n|        |                                                          |\n| 12..15 | GSS-EAP error code as 32-bit network byte order; see     |\n|        | Section 7.6                                              |\n+--------+----------------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Initiators MUST ignore octets beyond the GSS-EAP error code for future extensibility. As indicated, the error token is always marked critical.",
      "ja": "イニシエータは、将来の拡張のためのGSS-EAPのエラー・コードを超えてオクテットを無視しなければなりません。示されているように、エラー・トークンは、常に重要なマークされます。"
    },
    {
      "indent": 0,
      "text": "5.4. Initial State",
      "section_title": true,
      "ja": "5.4. 初期状態"
    },
    {
      "indent": 3,
      "text": "Both the acceptor and initiator start the context establishment process in the initial state.",
      "ja": "アクセプターおよび開始剤の両方が初期状態のコンテキスト確立プロセスを開始します。"
    },
    {
      "indent": 3,
      "text": "The initiator sends a token to the acceptor. It MAY be empty; no subtokens are required in this state. Alternatively, the initiator MAY include a vendor ID subtoken or an acceptor name request subtoken.",
      "ja": "イニシエータは、受け入れ側にトークンを送信します。それは空でもよいです。何のサブトークンは、この状態では必要ありません。あるいは、開始剤は、ベンダIDのサブトークンまたはアクセプター名要求サブトークンを含むかもしれません。"
    },
    {
      "indent": 3,
      "text": "The acceptor responds to this message. It MAY include an acceptor name response subtoken. It MUST include a first EAP request; this is an EAP request/identity message (see Section 5.5.1 for the format of this subtoken).",
      "ja": "アクセプターは、このメッセージに応答します。これは、アクセプター名応答サブトークンを含むかもしれません。これは、最初のEAP要求を含まなければなりません。これは、EAP要求/識別メッセージ（このサブトークンの形式については、セクション5.5.1を参照します）。"
    },
    {
      "indent": 3,
      "text": "The initiator and acceptor then transition to authenticate state.",
      "ja": "イニシエータとアクセプターは、状態を認証するために遷移します。"
    },
    {
      "indent": 0,
      "text": "5.4.1. Vendor Subtoken",
      "section_title": true,
      "ja": "5.4.1. ベンダーサブトークン"
    },
    {
      "indent": 3,
      "text": "The vendor ID subtoken has type 0x0000000B and the following structure:",
      "ja": "ベンダーIDのサブトークンは0x0000000B、以下の構造を入力しています"
    },
    {
      "indent": 17,
      "text": "+-------------+------------------------+\n| Pos         | Description            |\n+-------------+------------------------+\n| 0..3        | 0x0000000B             |\n|             |                        |\n| 4..7        | length of vendor token |\n|             |                        |\n| 8..8+length | Vendor ID string       |\n+-------------+------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The vendor ID string is an UTF-8 string describing the vendor of this implementation. This string is unstructured and for debugging purposes only.",
      "ja": "ベンダIDストリングは、この実装のベンダーを説明するUTF-8文字列です。この文字列は、非構造化およびデバッグ目的でのみです。"
    },
    {
      "indent": 0,
      "text": "5.4.2. Acceptor Name Request",
      "section_title": true,
      "ja": "5.4.2. アクセプター名リクエスト"
    },
    {
      "indent": 3,
      "text": "The acceptor name request token is sent from the initiator to the acceptor indicating that the initiator wishes a particular acceptor name. This is similar to Transport Layer Security (TLS) Server Name Indication [RFC6066] that permits a client to indicate which one of a number of virtual services to contact. The structure is as follows:",
      "ja": "アクセプタ名要求トークンは、開始剤は、特定のアクセプター名を望むことを示すアクセプターにイニシエータから送信されます。これは、仮想サービスのうちの1つが接触するかを示すために、クライアントを許可する層セキュリティ（TLS）サーバー名の表示[RFC6066]を輸送するのに似ています。次のような構造は次のようになります。"
    },
    {
      "indent": 18,
      "text": "+------+------------------------------+\n| Pos  | Description                  |\n+------+------------------------------+\n| 0..3 | 0x00000002                   |\n|      |                              |\n| 4..7 | length of subtoken           |\n|      |                              |\n| 8..n | string form of acceptor name |\n+------+------------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "It is likely that channel binding and thus authentication will fail if the acceptor does not choose a name that is a superset of this name. That is, if a hostname is sent, the acceptor needs to be willing to accept this hostname.",
      "ja": "チャネル結合およびアクセプターがこの名前のスーパーセットである名前を選択していない場合ので、認証に失敗する可能性があります。これは、ホスト名が送信された場合、アクセプターは、このホスト名を受け入れることをいとわないする必要があり、です。"
    },
    {
      "indent": 0,
      "text": "5.4.3. Acceptor Name Response",
      "section_title": true,
      "ja": "5.4.3. アクセプターの名前レスポンス"
    },
    {
      "indent": 3,
      "text": "The acceptor name response subtoken indicates what acceptor name is used. This is useful, for example, if the initiator supplied no target name to the context initialization. This allows the initiator to learn the acceptor name. EAP channel bindings will provide confirmation that the acceptor is accurately naming itself.",
      "ja": "アクセプター名応答サブトークンは、アクセプターの名前が使用されているかを示します。イニシエータは、コンテキストの初期化にないターゲット名を供給されない場合、これは、例えば、有用です。これは、イニシエータが、アクセプターの名前を学ぶことができます。 EAPのチャネルバインディングは、アクセプターが正確に自分自身を命名された確認を提供します。"
    },
    {
      "indent": 3,
      "text": "This token is sent from the acceptor to initiator. In the Initial state, this token would typically be sent if the acceptor name request is absent, because if the initiator already sent an acceptor name, then the initiator knows what acceptor it wishes to contact. This subtoken is also sent in Extensions state Section 5.6, so the initiator can protect against a man-in-the-middle modifying the acceptor name request subtoken.",
      "ja": "このトークンは、イニシエータに、アクセプタから送信されます。イニシエータは、すでにアクセプター名を送信した場合、その後、イニシエータは、それが接触することを希望するものをアクセプターを知っているので、アクセプター名要求が、存在しない場合は、初期状態では、このトークンは、一般的に送信されます。イニシエータは、アクセプター名要求サブトークンを修正するのman-in-the-middleから守ることができますので、このサブトークンはまた、拡張機能の状態のセクション5.6に送信されます。"
    },
    {
      "indent": 18,
      "text": "+------+------------------------------+\n| Pos  | Description                  |\n+------+------------------------------+\n| 0..3 | 0x00000003                   |\n|      |                              |\n| 4..7 | length of subtoken           |\n|      |                              |\n| 8..n | string form of acceptor name |\n+------+------------------------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "5.5. Authenticate State",
      "section_title": true,
      "ja": "5.5. 状態を認証"
    },
    {
      "indent": 3,
      "text": "In this state, the acceptor sends EAP requests to the initiator and the initiator generates EAP responses. The goal of the state is to perform a successful EAP authentication. Since the acceptor sends an identity request at the end of the initial state, the first half-round-trip in this state is a response to that request from the initiator.",
      "ja": "この状態では、アクセプターは、イニシエータにEAP要求を送信し、イニシエータは、EAP応答を生成します。国家の目標は、成功したEAP認証を実行することです。アクセプターが初期状態の終了時のアイデンティティ要求を送信しているので、この状態で第一のハーフラウンドトリップは、イニシエータからの要求に対する応答です。"
    },
    {
      "indent": 3,
      "text": "The EAP conversation can end in a number of ways:",
      "ja": "EAPの会話は、いくつかの方法で終了することができます。"
    },
    {
      "indent": 3,
      "text": "o If the EAP state machine generates an EAP Success message, then the EAP authenticator believes the authentication is successful. The acceptor MUST confirm that a key has been derived (Section 7.10 of [RFC3748]). The acceptor MUST confirm that this success indication is consistent with any protected result indication for combined authenticators and with AAA indication of success for pass-through authenticators. If any of these checks fail, the acceptor MUST send an error subtoken and fail the context establishment. If these checks succeed, the acceptor sends the Success message using the EAP Request subtoken type and transitions to Extensions state. If the initiator receives an EAP",
      "ja": "EAPステートマシンはEAP成功メッセージを生成した場合は、O、その後、EAP認証は、認証が成功したと考えています。アクセプターは、キー（[RFC3748]のセクション7.10）が導出されていることを確認しなければなりません。アクセプターは、この成功指示が組み合わさオーセンティケータのための任意の保護された結果の指示を有するとパススルー認証者の成功のAAA指示と一致することを確認しなければなりません。これらのチェックのいずれかが失敗した場合、アクセプターはエラーサブトークンを送信し、コンテキスト確立に失敗しなければなりません。これらのチェックが成功した場合、アクセプターは、拡張状態にEAP要求サブトークンの種類やトランジションを使用して成功メッセージを送信します。イニシエータは、EAPを受信した場合"
    },
    {
      "indent": 6,
      "text": "Success message, it confirms that a key has been derived and that the EAP Success is consistent with any protected result indication. If so, it transitions to Extensions state. Otherwise, it returns an error to the caller of GSS_Init_sec_context without producing an output token.",
      "ja": "成功メッセージは、キーが導出されていることを確認し、EAP成功は、任意の保護された結果の表示と一致していること。もしそうなら、それは状態を拡張するために移行します。それ以外の場合は、出力トークンを生成することなく、もしGSS_Init_sec_contextの呼び出し元にエラーを返します。"
    },
    {
      "indent": 3,
      "text": "o If the acceptor receives an EAP failure, then the acceptor sends this in the EAP Request subtoken type. If the initiator receives an EAP Failure, it returns GSS failure.",
      "ja": "アクセプターは、EAPの失敗を受信した場合、O、そしてアクセプターは、EAP要求サブトークンタイプでこれを送信します。イニシエータは、EAPの失敗を受信した場合、GSSの障害を返します。"
    },
    {
      "indent": 3,
      "text": "o If there is some other error, the acceptor MAY return an error subtoken.",
      "ja": "他のいくつかのエラーがある場合は、O、アクセプターは、エラーサブトークンを返すことがあります。"
    },
    {
      "indent": 0,
      "text": "5.5.1. EAP Request Subtoken",
      "section_title": true,
      "ja": "5.5.1.  EAP要求サブトークン"
    },
    {
      "indent": 3,
      "text": "The EAP Request subtoken is sent from the acceptor to the initiator. This subtoken is always critical and is REQUIRED in the authentication state.",
      "ja": "EAP要求サブトークンをイニシエータにアクセプターから送信されます。このサブトークンは常に重要であり、認証状態で必要とされます。"
    },
    {
      "indent": 18,
      "text": "+-------------+-----------------------+\n| Pos         | Description           |\n+-------------+-----------------------+\n| 0..3        | 0x80000005            |\n|             |                       |\n| 4..7        | length of EAP message |\n|             |                       |\n| 8..8+length | EAP message           |\n+-------------+-----------------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "5.5.2. EAP Response Subtoken",
      "section_title": true,
      "ja": "5.5.2.  EAPレスポンスサブトークン"
    },
    {
      "indent": 3,
      "text": "This subtoken is REQUIRED in authentication state messages from the initiator to the acceptor. It is always critical.",
      "ja": "このサブトークンは、アクセプターへのイニシエータから認証状態メッセージで必要とされます。それは、常に重要です。"
    },
    {
      "indent": 18,
      "text": "+-------------+-----------------------+\n| Pos         | Description           |\n+-------------+-----------------------+\n| 0..3        | 0x80000004            |\n|             |                       |\n| 4..7        | length of EAP message |\n|             |                       |\n| 8..8+length | EAP message           |\n+-------------+-----------------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "5.6. Extensions State",
      "section_title": true,
      "ja": "5.6. 拡張機能の状態"
    },
    {
      "indent": 3,
      "text": "After EAP Success, the initiator sends a token to the acceptor including additional subtokens that negotiate optional features or provide GSS-API channel binding (see Section 6.1). The acceptor then responds with a token to the initiator. When the acceptor produces its final token, it returns GSS_S_COMPLETE; when the initiator consumes this token, it returns GSS_S_COMPLETE if no errors are detected.",
      "ja": "EAP成功した後、イニシエータは、オプション機能を交渉するか（6.1節を参照）を結合GSS-APIのチャンネルを提供する追加のサブトークンを含む受容体にトークンを送信します。アクセプターは、イニシエータへのトークンで応答します。アクセプターがその最終的なトークンを生成するとき、それはGSS_S_COMPLETEを返します。イニシエータがこのトークンを消費したときにエラーが検出されない場合、それはGSS_S_COMPLETEを返します。"
    },
    {
      "indent": 3,
      "text": "The acceptor SHOULD send an acceptor name response (Section 5.4.3) so that the initiator can get a copy of the acceptor name protected by the Message Integrity Check (MIC) subtoken.",
      "ja": "イニシエータはメッセージ完全性チェック（MIC）サブトークンによって保護されたアクセプター名のコピーを得ることができるように、アクセプターは、アクセプター名の応答（セクション5.4.3）を送信すべきです。"
    },
    {
      "indent": 3,
      "text": "Both the initiator and acceptor MUST include and verify a MIC subtoken to protect the extensions exchange.",
      "ja": "イニシエータとアクセプタの両方が拡張交換を保護するために、MICサブトークンが含まれており、確かめなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.6.1. Flags Subtoken",
      "section_title": true,
      "ja": "5.6.1. 国旗サブトークン"
    },
    {
      "indent": 3,
      "text": "This subtoken is sent to convey initiator flags to the acceptor. The flags are sent as a 32-bit integer in network byte order. The only flag defined so far is GSS_C_MUTUAL_FLAG, indicating that the initiator successfully performed mutual authentication of the acceptor. This flag is communicated to the acceptor because some protocols [RFC4462] require the acceptor to know whether the initiator has confirmed its identity. This flag has the value 0x2 to be consistent with RFC 2744.",
      "ja": "このサブトークンは、受け入れ側に、イニシエータフラグを伝えるために送信されます。フラグは、ネットワークバイト順で32ビットの整数として送信されます。これまでに定義された唯一のフラグは、イニシエータが正常受容体の相互認証を行うことを示す、GSS_C_MUTUAL_FLAGあります。いくつかのプロトコル[RFC4462]は、イニシエータは、その同一性を確認したかどうかを知るためにアクセプターを必要とするため、このフラグは、アクセプターに伝達されます。このフラグは、RFC 2744と一致するように値を0x2を有します。"
    },
    {
      "indent": 21,
      "text": "+-------+-----------------------+\n| Pos   | Description           |\n+-------+-----------------------+\n| 0..3  | 0x0000000C            |\n|       |                       |\n| 4..7  | length of flags token |\n|       |                       |\n| 8..11 | flags                 |\n+-------+-----------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Initiators MUST send 4 octets of flags. Acceptors MUST ignore flag octets beyond the first 4 and MUST ignore flag bits other than GSS_C_MUTUAL_FLAG. Initiators MUST send undefined flag bits as zero.",
      "ja": "イニシエータは、フラグの4つのオクテットを送らなければなりません。アクセプターは、最初の4越えフラグオクテットを無視しなければならないとGSS_C_MUTUAL_FLAG以外のフラグビットを無視しなければなりません。開始剤は、ゼロとして未定義のフラグビットを送らなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.6.2. GSS Channel Bindings Subtoken",
      "section_title": true,
      "ja": "5.6.2.  GSSチャネルバインディングサブトークン"
    },
    {
      "indent": 3,
      "text": "This subtoken is always critical when sent. It is sent from the initiator to the acceptor. The contents of this token are an RFC 3961 get_mic token of the application data from the GSS channel bindings structure passed into the context establishment call.",
      "ja": "送信されたときに、このサブトークンは常に重要です。これは、アクセプターに、イニシエータから送信されます。このトークンの内容は、コンテキスト確立呼び出しに渡さGSSチャネルバインディング構造からのアプリケーションデータのRFC 3961 get_micトークンです。"
    },
    {
      "indent": 6,
      "text": "+-------------+-----------------------------------------------+\n| Pos         | Description                                   |\n+-------------+-----------------------------------------------+\n| 0..3        | 0x80000006                                    |\n|             |                                               |\n| 4..7        | length of token                               |\n|             |                                               |\n| 8..8+length | get_mic  of  channel binding application data |\n+-------------+-----------------------------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Again, only the application data is sent in the channel binding. Any initiator and acceptor addresses passed by an application into context establishment calls are ignored and not sent over the wire. The checksum type of the get_mic token SHOULD be the mandatory-to-implement checksum type of the Context Root Key (CRK). The key to use is the CRK and the key usage is 60 (KEY_USAGE_GSSEAP_CHBIND_MIC). An acceptor MAY accept any MIC in the channel bindings subtoken if the channel bindings input to GSS_Accept_sec_context is not provided. If the channel binding input to GSS_Accept_sec_context is provided, the acceptor MUST return failure if the channel binding MIC in a received channel binding subtoken fails to verify.",
      "ja": "ここでも、唯一のアプリケーションデータを結合チャネルで送信されます。コンテキスト確立の呼び出しにアプリケーションから渡された任意のイニシエータとアクセプタのアドレスは無視され、ワイヤ上で送信されることはありません。 get_micトークンのチェックサムタイプは、コンテキスト・ルートキー（CRK）の実装に必須のチェックサムタイプでなければなりません。使用するキーは、CRKであり、鍵の使用は、60（KEY_USAGE_GSSEAP_CHBIND_MIC）です。アクセプターのgss_accept_sec_contextにチャネルバインディング入力が用意されていない場合、サブトークンチャネルバインディングのいずれかのMICを受け入れることができます。場合gss_accept_sec_contextに入力を結合チャネルが提供されている場合、受信したチャネル結合サブトークンにMICを結合チャネルが検証に失敗した場合、アクセプターは失敗を返さなければなりません。"
    },
    {
      "indent": 3,
      "text": "The initiator MUST send this token if channel bindings including application data are passed into GSS_Init_sec_context and MUST NOT send this token otherwise.",
      "ja": "アプリケーションデータを含むチャネルバインディングがもしGSS_Init_sec_contextに渡され、そうでない場合は、このトークンを送ってはいけません場合、イニシエータは、このトークンを送らなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.6.3. MIC Subtoken",
      "section_title": true,
      "ja": "5.6.3.  MICサブトークン"
    },
    {
      "indent": 3,
      "text": "This subtoken MUST be the last subtoken in the tokens sent in Extensions state. This subtoken is sent both by the initiator and acceptor.",
      "ja": "このサブトークンは、拡張状態で送信されたトークンの最後のサブトークンでなければなりません。このサブトークンは、イニシエータとアクセプタの両方によって送信されます。"
    },
    {
      "indent": 4,
      "text": "+-------------+--------------------------------------------------+\n| Pos         | Description                                      |\n+-------------+--------------------------------------------------+\n| 0..3        | 0x8000000D for initiator 0x8000000E for acceptor |\n|             |                                                  |\n| 4..7        | length of RFC 3961 MIC token                     |\n|             |                                                  |\n| 8..8+length | RFC 3961 result of get_mic                       |\n+-------------+--------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "As with any call to get_mic, a token is produced as described in RFC 3961 using the CRK (Section 6) as the key and the mandatory checksum type for the encryption type of the CRK as the checksum type. The key usage is 61 (KEY_USAGE_GSSEAP_ACCTOKEN_MIC) for the subtoken from the acceptor to the initiator and 62 (KEY_USAGE_GSSEAP_INITTOKEN_MIC) for the subtoken from the initiator to the acceptor. The input is as follows:",
      "ja": "RFC 3961に記載されているようにget_micへの呼び出しと同様に、トークンは、鍵とチェックサムタイプとしてCRKの暗号化タイプのための必須のチェックサム・タイプとしてCRK（第6節）を用いて製造されます。鍵使用法は、受容体へイニシエータからサブトークンのための開始剤及び62（KEY_USAGE_GSSEAP_INITTOKEN_MIC）にアクセプタからサブトークン61（KEY_USAGE_GSSEAP_ACCTOKEN_MIC）です。次のように入力します："
    },
    {
      "indent": 3,
      "text": "1. The DER-encoded object identifier of the mechanism in use; this value starts with 0x06 (the tag for object identifier). When encoded in an RFC 2743 context token, the object identifier is preceded by the tag and length for [Application 0] SEQUENCE. This tag and the length of the overall token is not included; only the tag, length, and value of the object identifier itself.",
      "ja": "1.使用されている機構のDER符号化されたオブジェクトの識別子。この値は0x06で（オブジェクト識別子のタグ）で始まります。 RFC 2743コンテキストトークンで符号化するとき、オブジェクト識別子は、[アプリケーション0] SEQUENCEのタグと長さによって先行されます。このタグおよび全体的なトークンの長さは含まれません。タグ、長さ、およびオブジェクト識別子自体の値のみ。"
    },
    {
      "indent": 3,
      "text": "2. A 16-bit token type in network byte order of the RFC 4121 token identifier (0x0601 for initiator, 0x0602 for acceptor).",
      "ja": "2. 16ビットのトークンタイプRFC 4121トークン識別子（開始剤0x0601、アクセプターのための0x0602）のネットワークバイト順です。"
    },
    {
      "indent": 3,
      "text": "3. For each subtoken, other than the MIC subtoken itself, the order the subtokens appear in the token is as follows:",
      "ja": "次のように各サブトークン3.は、それ自体をサブトークンMIC以外、サブトークンがトークンに表示される順序は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "4.",
      "section_title": true,
      "ja": "４。"
    },
    {
      "indent": 7,
      "text": "1. A four-octet subtoken type in network byte order",
      "section_title": true,
      "ja": "1.ネットワークバイト順の4オクテットのサブトークンのタイプ"
    },
    {
      "indent": 7,
      "text": "2. A four-byte length in network byte order",
      "section_title": true,
      "ja": "2.ネットワークバイト順における4バイトの長さ"
    },
    {
      "indent": 7,
      "text": "3. Length octets of value from that subtoken",
      "section_title": true,
      "ja": "そのサブトークンからの値の3の長さのオクテット"
    },
    {
      "indent": 0,
      "text": "5.7. Example Token",
      "section_title": true,
      "ja": "5.7. 例トークン"
    },
    {
      "indent": 3,
      "text": "+----+------+----+------+-----+-------------------------+\n| 60 |  23  | 06 |  09  | 2b  | 06 01 05 05 0f 01 01 11 |\n+----+------+----+------+-----+-------------------------+\n|App0|Token |OID |OID   | 1 3 |  6  1  5  5 15  1  1 17 |\n|Tag |length|Tag |length|      Mechanism object ID      |\n+----+------+----+------+-------------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "+----------+-------------+-------------+\n|  06 01   | 00 00 00 02 | 00 00 00 0e |\n+----------+-------------|-------------|\n|Initiator | Acceptor    | Length      |\n|context   | name        | (14 octets) |\n|token ID  | request     |             |\n+----------+-------------+-------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "+-------------------------------------------+\n| 68 6f 73 74 2f 6c 6f 63 61 6c 68 6f 73 74 |\n+-------------------------------------------+\n| String form of acceptor name              |\n| \"host/localhost\"                          |\n+-------------------------------------------+",
      "raw": true
    },
    {
      "indent": 26,
      "text": "Example Initiator Token",
      "ja": "例イニシエータトークン"
    },
    {
      "indent": 0,
      "text": "5.8. Context Options",
      "section_title": true,
      "ja": "5.8. コンテキストオプション"
    },
    {
      "indent": 3,
      "text": "GSS-API provides a number of optional per-context services requested by flags on the call to GSS_Init_sec_context and indicated as outputs from both GSS_Init_sec_context and GSS_Accept_sec_context. This section describes how these services are handled. Which services the client selects in the call to GSS_Init_sec_context controls what EAP methods MAY be used by the client. Section 7.2 of RFC 3748 describes a set of security claims for EAP. As described below, the selected GSS options place requirements on security claims that MUST be met.",
      "ja": "GSS-APIは、もしGSS_Init_sec_contextの呼び出しにフラグによって要求されたともしGSS_Init_sec_context及び場合gss_accept_sec_contextの両方からの出力として示されるオプションごとのコンテキストサービスの数を提供します。このセクションでは、これらのサービスがどのように処理されるかを説明します。どのサービスもしGSS_Init_sec_contextへの呼び出しは、EAPメソッドは、クライアントによって使用されるかもしれないものを制御するには、クライアントが選択されます。 RFC 3748のセクション7.2には、EAPのセキュリティクレームのセットを記述する。後述するように、選択されたGSSオプションを満たしている必要がありますセキュリティ主張の要件を置きます。"
    },
    {
      "indent": 3,
      "text": "This GSS mechanism MUST only be used with EAP methods that provide dictionary-attack resistance. Typically, dictionary-attack resistance is obtained by using an EAP tunnel method to tunnel an inner method in TLS.",
      "ja": "このGSS機構は、辞書攻撃耐性を提供するEAPメソッドを使用する必要があります。典型的には、辞書攻撃耐性がトンネルにEAPトンネル方式TLS内側の方法を用いて得られます。"
    },
    {
      "indent": 3,
      "text": "The EAP method MUST support key derivation. Integrity, confidentiality, sequencing, and replay detection MUST be indicated in the output of GSS_Init_sec_context and GSS_Accept_sec_context regardless of which services are requested.",
      "ja": "EAPメソッドは、鍵導出をサポートしなければなりません。整合性、機密性、シーケンシング、およびリプレイ検出は関係なく、もしGSS_Init_sec_contextとのgss_accept_sec_contextの出力に示さなければならないのサービスが要求されています。"
    },
    {
      "indent": 3,
      "text": "The PROT_READY service defined in Section 1.2.7 of [RFC2743] is never available with this mechanism. Implementations MUST NOT offer this flag or permit per-message security services to be used before context establishment.",
      "ja": "[RFC2743]のセクション1.2.7で定義されたPROT_READYサービスは、このメカニズムで利用可能になることはありません。実装は、このフラグを提供するか、コンテキストが確立する前に、使用するメッセージごとのセキュリティ・サービスを許可してはなりません。"
    },
    {
      "indent": 3,
      "text": "The EAP method MUST support mutual authentication and channel binding. See Section 3.4 for details on what is required for successful mutual authentication. Regardless of whether mutual authentication is requested, the implementation MUST include channel bindings in the EAP authentication. If mutual authentication is requested and successful mutual authentication takes place as defined in Section 3.4, the initiator MUST send a flags subtoken Section 5.6.1 in Extensions state.",
      "ja": "EAPメソッドは結合相互認証およびチャンネルをサポートしなければなりません。成功した相互認証に必要なものの詳細については、3.4節を参照してください。かかわらず、相互認証が要求されているかどうかの実装は、EAP認証のチャネルバインディングを含まなければなりません。相互認証が要求され、3.4節で定義されて成功した相互認証が行われた場合、イニシエータは、拡張状態で、セクション5.6.1をサブトークンのフラグを送らなければなりません。"
    },
    {
      "indent": 0,
      "text": "6. Acceptor Services",
      "section_title": true,
      "ja": "6.アクセプター・サービス"
    },
    {
      "indent": 3,
      "text": "The context establishment process may be passed through to an EAP server via a backend authentication protocol. However, after the EAP authentication succeeds, security services are provided directly by the acceptor.",
      "ja": "コンテキスト確立プロセスはバックエンド認証プロトコルを介してEAPサーバに通過することができます。 EAP認証が成功した後ただし、セキュリティサービスは、アクセプターによって直接提供されています。"
    },
    {
      "indent": 3,
      "text": "This mechanism uses an RFC 3961 cryptographic key called the Context Root Key (CRK). The CRK is derived from the GMSK (GSS-API Master Session Key). The GMSK is the result of the random-to-key [RFC3961] operation of the encryption type of this mechanism consuming the appropriate number of bits from the EAP MSK. For example, for aes128-cts-hmac-sha1-96, the random-to-key operation consumes 16 octets of key material; thus, the first 16 bytes of the MSK are input to random-to-key to form the GMSK. If the MSK is too short, authentication MUST fail.",
      "ja": "このメカニズムは、コンテキストルートキー（CRK）と呼ばれるRFC 3961暗号鍵を使用しています。 CRKは、GMSK（GSS-APIマスターセッションキー）から派生しています。 GMSKは、EAP MSKから適切なビット数を消費し、この機構の暗号化タイプのランダム・ツー・キー[RFC3961]演算の結果です。例えば、AES128-CTS-HMAC-SHA1-96ため、ランダムにキー操作キー材料の16個のオクテットを消費します。従って、MSKの最初の16のバイトがランダムにキーGMSKを形成するために入力されます。 MSKが短すぎると、認証が失敗しなければなりません。"
    },
    {
      "indent": 3,
      "text": "In the following, pseudorandom is the RFC 3961 pseudorandom operation for the encryption type of the GMSK and random-to-key is the RFC 3961 random-to-key operation for the enctype of the mechanism. The truncate function takes the initial l bits of its input. The goal in constructing a CRK is to call the pseudorandom function enough times to produce the right number of bits of output and discard any excess bits of output.",
      "ja": "以下では、擬似ランダム機構のENCTYPEためGMSKの暗号化タイプとランダムにキーであるRFC 3961ランダムにキー操作用RFC 3961擬似ランダム動作です。切り捨て機能は、入力の最初のLビットを取ります。 CRKを構築する上での目標は、出力のビットの右の数を生成し、出力の余分なビットを破棄する擬似ランダム機能に十分な時間を呼び出すことです。"
    },
    {
      "indent": 3,
      "text": "The CRK is derived from the GMSK using the following procedure:",
      "ja": "CRKは、以下の手順を使用して、GMSKから導出されます。"
    },
    {
      "indent": 3,
      "text": "Tn = pseudorandom(GMSK, n || \"rfc4121-gss-eap\") CRK = random-to-key(truncate(L, T0 || T1 || .. || Tn)) L = random-to-key input size",
      "ja": "TN =擬似乱数（GMSK、N || \"rfc4121-GSS-EAP\"）CRK =ランダム・ツー・キー（切り捨てる（L、T0 T1 || || ... || TN））L =ランダムにキー入力サイズ"
    },
    {
      "indent": 3,
      "text": "Where n is a 32-bit integer in network byte order starting at 0 and incremented to each call to the pseudo_random operation.",
      "ja": "nが0から始まるネットワークバイト順の32ビット整数であり、pseudo_random操作を呼び出すたびにインクリメントここ。"
    },
    {
      "indent": 0,
      "text": "6.1. GSS-API Channel Binding",
      "section_title": true,
      "ja": "6.1. バインディングGSS-APIチャンネル"
    },
    {
      "indent": 3,
      "text": "GSS-API channel binding [RFC5554] is a protected facility for exchanging a cryptographic name for an enclosing channel between the initiator and acceptor. The initiator sends channel binding data and the acceptor confirms that channel binding data has been checked.",
      "ja": "[RFC5554]を結合GSS-APIのチャネルは、イニシエータとアクセプタの間に包囲チャネルのための暗号名を交換するための保護施設です。イニシエータは、チャネルバインディングデータを送信し、アクセプターは、チャネルバインディングデータがチェックされていることを確認します。"
    },
    {
      "indent": 3,
      "text": "The acceptor SHOULD accept any channel binding provided by the initiator if null channel bindings are passed into gss_accept_sec_context. Protocols such as HTTP Negotiate [RFC4559] depend on this behavior of some Kerberos implementations.",
      "ja": "アクセプターは、ヌルチャネルバインディングを場合gss_accept_sec_contextに渡された場合、イニシエータによって提供される結合は、任意のチャネルを受け入れるべきです。 HTTPなどのプロトコル[RFC4559]をネゴシエートは、いくつかのKerberos実装のこの動作に依存します。"
    },
    {
      "indent": 3,
      "text": "As discussed, the GSS channel bindings subtoken is sent in the Extensions state.",
      "ja": "説明したように、サブトークンGSSチャネルバインディングが拡張状態で送信されます。"
    },
    {
      "indent": 0,
      "text": "6.2. Per-Message Security",
      "section_title": true,
      "ja": "6.2. メッセージごとのセキュリティ"
    },
    {
      "indent": 3,
      "text": "The per-message tokens of Section 4 of RFC 4121 are used. The CRK SHALL be treated as the initiator sub-session key, the acceptor sub-session key and the ticket session key.",
      "ja": "RFC 4121のセクション4のメッセージごとのトークンが使用されます。 CRKは、イニシエータサブセッション鍵、アクセプタサブセッション鍵とチケットセッション鍵として扱われます。"
    },
    {
      "indent": 0,
      "text": "6.3. Pseudorandom Function",
      "section_title": true,
      "ja": "6.3. 擬似ランダム関数"
    },
    {
      "indent": 3,
      "text": "The pseudorandom function defined in [RFC4402] is used to provide GSS_Pseudo_Random functionality to applications.",
      "ja": "[RFC4402]で定義された擬似ランダム関数は、アプリケーションにGSS_Pseudo_Random機能を提供するために使用されます。"
    },
    {
      "indent": 0,
      "text": "7. IANA Considerations",
      "section_title": true,
      "ja": "7. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This specification creates a number of IANA registries.",
      "ja": "この仕様は、IANAレジストリの数を作成します。"
    },
    {
      "indent": 0,
      "text": "7.1. OID Registry",
      "section_title": true,
      "ja": "7.1.  OIDレジストリ"
    },
    {
      "indent": 3,
      "text": "IANA has created a registry of ABFAB object identifiers titled \"Object Identifiers for Application Bridging for Federated Access\". The initial contents of the registry are specified below. The registration policy is IETF Review or IESG Approval [RFC5226]. Early allocation is permitted. IANA has updated the reference for the root of this OID delegation to point to the newly created registry.",
      "ja": "IANAは、「フェデレーションアクセス用のアプリケーションブリッジングのためのオブジェクト識別子」というタイトルABFABオブジェクト識別子のレジストリを作成しました。レジストリの初期の内容は以下に指定されています。登録ポリシーは、IETFレビューやIESG承認[RFC5226]です。初期の割り当てが許可されています。 IANAは、新しく作成されたレジストリを指すように、このOID委任のルートの参照を更新しました。"
    },
    {
      "indent": 3,
      "text": "Decimal   Name        Description                         References\n-------   ----        ----------------------------------  ----------\n      0   Reserved    Reserved                            RFC 7055\n      1   mechanisms  A sub-arc containing ABFAB          RFC 7055\n                      mechanisms\n      2   nametypes   A sub-arc containing ABFAB          RFC 7055\n                      GSS-API Name Types",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Prefix: iso.org.dod.internet.security.mechanisms.abfab (1.3.6.1.5.5.15)",
      "ja": "接頭辞：iso.org.dod.internet.security.mechanisms.abfab（1.3.6.1.5.5.15）"
    },
    {
      "indent": 3,
      "text": "NOTE: the following mechanisms registry is the root of the OID for the mechanism in question. As discussed in Section 5.1, a Kerberos encryption type number [RFC3961] is appended to the mechanism version OID below to form the OID of a specific mechanism.",
      "ja": "注：以下のメカニズムレジストリが問題のメカニズムのOIDのルートです。セクション5.1で議論したように、ケルベロス暗号化タイプ番号[RFC3961]は、特定の機構のOIDを形成するために、次のOID機構のバージョンに追加されます。"
    },
    {
      "indent": 3,
      "text": "Prefix: iso.org.dod.internet.security.mechanisms.abfab.mechanisms (1.3.6.1.5.5.15.1)",
      "ja": "接頭辞：iso.org.dod.internet.security.mechanisms.abfab.mechanisms（1.3.6.1.5.5.15.1）"
    },
    {
      "indent": 3,
      "text": "Decimal   Name          Description                      References\n-------   ----          -------------------------------  ----------\n      0   Reserved      Reserved                         RFC 7055\n      1   gss-eap-v1    The GSS-EAP mechanism            RFC 7055",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Prefix: iso.org.dod.internet.security.mechanisms.abfab.nametypes (1.3.6.1.5.5.15.2)",
      "ja": "接頭辞：iso.org.dod.internet.security.mechanisms.abfab.nametypes（1.3.6.1.5.5.15.2）"
    },
    {
      "indent": 3,
      "text": "Decimal   Name          Description            References\n-------   ----          ---------------------  ----------\n      0   Reserved      Reserved               RFC 7055\n      1   GSS_EAP_NT_EAP_NAME                  RFC 7055, Section 3.1",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.2. Token Identifiers",
      "section_title": true,
      "ja": "7.2. トークン識別子"
    },
    {
      "indent": 3,
      "text": "In the top-level registry titled \"Kerberos V GSS-API Mechanism Parameters\", a subregistry called \"Kerberos GSS-API Token Type Identifiers\" was created; the references for this subregistry are RFC 4121 and this document. The allocation procedure is Expert Review [RFC5226]. The Expert's primary job is to make sure that token type identifiers are requested by an appropriate requester for the RFC 4121 mechanism in which they will be used and that multiple values are not allocated for the same purpose. For RFC 4121 and this mechanism, the Expert is currently expected to make allocations for token identifiers from documents in the IETF stream; effectively, for these mechanisms, the Expert currently confirms the allocation meets the requirements of the IETF Review process.",
      "ja": "「ケルベロスV GSS-APIメカニズムのパラメータ」と題し、トップレベルのレジストリでは、「KerberosのGSS-APIトークンタイプ識別子」と呼ばれる副登録を作成しました。この副登録のための参照は、RFC 4121および本書です。割り当て手順エキスパートレビュー[RFC5226]です。 Expertの主な仕事は、トークンタイプ識別子は、彼らが使用されるRFC 4121のメカニズムのための適切な要求者に要求され、その複数の値が同じ目的のために割り当てられていないことを確認することです。 RFC 4121およびそのメカニズムについて、専門家は、現在IETFストリーム内の文書からトークン識別子の割り当てを行うことが期待されています。効果的に、これらのメカニズムのために、専門家は、現在割り当てがIETFレビュープロセスの要件を満たして確認します。"
    },
    {
      "indent": 3,
      "text": "The ID field is a hexadecimal token identifier specified in network byte order.",
      "ja": "IDフィールドは、ネットワークバイト順で指定された進数トークン識別子です。"
    },
    {
      "indent": 3,
      "text": "The initial registrations are as follows:",
      "ja": "次のように初期登録は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "+-------+-------------------------------+---------------------------+\n| ID    | Description                   | Reference                 |\n+-------+-------------------------------+---------------------------+\n| 01 00 | KRB_AP_REQ                    | RFC 4121, Section 4.1     |\n|       |                               |                           |\n| 02 00 | KRB_AP_REP                    | RFC 4121, Section 4.1     |\n|       |                               |                           |\n| 03 00 | KRB_ERROR                     | RFC 4121, Section 4.1     |\n|       |                               |                           |\n| 04 04 | MIC tokens                    | RFC 4121, Section 4.2.6.1 |\n|       |                               |                           |\n| 05 04 | wrap tokens                   | RFC 4121, Section 4.2.6.2 |\n|       |                               |                           |\n| 06 01 | GSS-EAP initiator context     | RFC 7055, Section 5       |\n|       | token                         |                           |\n|       |                               |                           |\n| 06 02 | GSS EAP acceptor context      | RFC 7055, Section 5       |\n|       | token                         |                           |\n+-------+-------------------------------+---------------------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.3. GSS-EAP Subtoken Types",
      "section_title": true,
      "ja": "7.3.  GAS-ESPのサブトークンタイプ"
    },
    {
      "indent": 3,
      "text": "This document creates a top-level registry called \"The Extensible Authentication Protocol Mechanism for the Generic Security Service Application Programming Interface (GSS-EAP) Parameters\". In any short form of that name, including any URI for this registry, it is important that the string GSS come before the string EAP; this will help to distinguish registries if EAP methods for performing GSS-API authentication are ever defined.",
      "ja": "この文書では、「一般的なセキュリティサービスアプリケーションプログラミングインターフェイス（GSS-EAP）のパラメータのための拡張認証プロトコルメカニズム」と呼ばれるトップレベルのレジストリを作成します。このレジストリのための任意のURIを含む、その名前のいずれか短い形式では、文字列GSSは、文字列EAPの前に来ることが重要です。これは、GSS-API認証を行うためのEAPメソッドがこれまでに定義されている場合はレジストリを区別するのに役立ちます。"
    },
    {
      "indent": 3,
      "text": "In this registry is a subregistry of subtoken types. Identifiers are 32-bit integers; the upper bit (0x80000000) is reserved as a critical flag and should not be indicated in the registration. Assignments of GSS-EAP subtoken types are made by Expert Review [RFC5226]. The Expert is expected to require a public specification of the subtoken similar in detail to registrations given in this document. The security of GSS-EAP depends on making sure that subtoken information has adequate protection and that the overall mechanism continues to be secure. Examining the security and architectural consistency of the proposed registration is the primary responsibility of the Expert.",
      "ja": "このレジストリではサブトークンタイプの副登録です。識別子は、32ビット整数です。上位ビット（0×80000000）が臨界フラグとして予約され、登録に示されるべきではありません。 GSS-EAPサブトークンタイプの割り当ては、専門家レビュー[RFC5226]によって作られています。専門家は、この文書で与えられた登録を詳細に似たサブトークンの公開仕様を必要とすると予想されます。 GSS-EAPのセキュリティは、サブトークン情報は、適切な保護を持っていることと、全体的なメカニズムが安全であり続けることを確認することに依存します。提案された登録のセキュリティおよびアーキテクチャの一貫性を調べると、専門家の主要な責任です。"
    },
    {
      "indent": 9,
      "text": "+------------+--------------------------+---------------+\n| Type       | Description              | Reference     |\n+------------+--------------------------+---------------+\n| 0x00000001 | Error                    | Section 5.3   |\n|            |                          |               |\n| 0x0000000B | Vendor                   | Section 5.4.1 |\n|            |                          |               |\n| 0x00000002 | Acceptor name request    | Section 5.4.2 |\n|            |                          |               |\n| 0x00000003 | Acceptor name response   | Section 5.4.3 |\n|            |                          |               |\n| 0x00000005 | EAP request              | Section 5.5.1 |\n|            |                          |               |\n| 0x00000004 | EAP response             | Section 5.5.2 |\n|            |                          |               |\n| 0x0000000C | Flags                    | Section 5.6.1 |\n|            |                          |               |\n| 0x00000006 | GSS-API channel bindings | Section 5.6.2 |\n|            |                          |               |\n| 0x0000000D | Initiator MIC            | Section 5.6.3 |\n|            |                          |               |\n| 0x0000000E | Acceptor MIC             | Section 5.6.3 |\n+------------+--------------------------+---------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.4. RADIUS Attribute Assignments",
      "section_title": true,
      "ja": "7.4.  RADIUS属性の割り当て"
    },
    {
      "indent": 3,
      "text": "The following RADIUS attribute type values [RFC3575] are assigned. The allocation instructions in Section 10.3 of [RFC6929] have been followed.",
      "ja": "次のRADIUS属性タイプ値[RFC3575]は割り当てられています。 [RFC6929]のセクション10.3で割り当て命令が続いてきました。"
    },
    {
      "indent": 3,
      "text": "+--------------------------------+-------+--------------------------+\n| Description                    | Value | More Information         |\n+--------------------------------+-------+--------------------------+\n| GSS-Acceptor-Service-Name      | 164   | user-or-service portion  |\n|                                |       | of name                  |\n|                                |       |                          |\n| GSS-Acceptor-Host-Name         | 165   | host portion of name     |\n|                                |       |                          |\n| GSS-Acceptor-Service-Specifics | 166   | service-specifics        |\n|                                |       | portion of name          |\n|                                |       |                          |\n| GSS-Acceptor-Realm-Name        | 167   | Realm portion of name    |\n+--------------------------------+-------+--------------------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.5. Registration of the EAP-AES128 SASL Mechanisms",
      "section_title": true,
      "ja": "7.5.  EAP-AES128 SASL機構の登録"
    },
    {
      "indent": 3,
      "text": "Subject: Registration of SASL mechanisms EAP-AES128 and EAP-AES128-PLUS",
      "ja": "件名：SASLメカニズムEAP-AES128およびEAP-AES128-PLUSの登録"
    },
    {
      "indent": 3,
      "text": "SASL mechanism names: EAP-AES128 and EAP-AES128-PLUS",
      "ja": "SASLメカニズム名：EAP-AES128およびEAP-AES128-PLUS"
    },
    {
      "indent": 3,
      "text": "Security considerations: See RFC 5801 and RFC 7055",
      "ja": "セキュリティの考慮事項：RFC 5801およびRFC 7055を参照してください。"
    },
    {
      "indent": 3,
      "text": "Published specification (recommended): RFC 7055",
      "ja": "公開された仕様（推奨）：RFC 7055"
    },
    {
      "indent": 3,
      "text": "Person & email address to contact for further information: Abfab Working Group, abfab@ietf.org",
      "ja": "人と詳細のために連絡する電子メールアドレス：Abfabワーキンググループ、abfab@ietf.org"
    },
    {
      "indent": 3,
      "text": "Intended usage: common",
      "ja": "意図している用法：共通"
    },
    {
      "indent": 3,
      "text": "Owner/Change controller: iesg@ietf.org",
      "ja": "所有者/変更コントローラ：iesg@ietf.org"
    },
    {
      "indent": 3,
      "text": "Note: This mechanism describes the GSS-EAP mechanism used with the aes128-cts-hmac-sha1-96 enctype. The GSS-API OID for this mechanism is 1.3.6.1.5.5.15.1.1.17.",
      "ja": "注意：このメカニズムは、AES128-CTS-HMAC-SHA1-96のenctypeで使用GSS-EAPのメカニズムを説明しています。このメカニズムのためのGSS-APIのOIDは1.3.6.1.5.5.15.1.1.17です。"
    },
    {
      "indent": 6,
      "text": "As described in RFC 5801, a PLUS variant of this mechanism is also required.",
      "ja": "RFC 5801に記載されているように、この機構のPLUS変異体も必要です。"
    },
    {
      "indent": 0,
      "text": "7.6. GSS-EAP Errors",
      "section_title": true,
      "ja": "7.6.  GSS-EAPエラー"
    },
    {
      "indent": 3,
      "text": "A new subregistry is created in the GSS-EAP parameters registry titled \"GSS-EAP Error Codes\". The error codes in this registry are unsigned 32-bit numbers. Values less than or equal to 127 are assigned by Standards Action [RFC5226]. Values 128 through 255 are assigned with the Specification Required assignment policy [RFC5226].",
      "ja": "新しい副登録は、「GSS-EAPエラーコード」という表題のGSS-EAPパラメータレジストリに作成されます。このレジストリ内のエラーコードは、符号なし32ビット数です。値未満または127に等しいが、標準アクション[RFC5226]によって割り当てられます。 128〜255は、仕様が必要で割り当てポリシー[RFC5226]に割り当てられている値。"
    },
    {
      "indent": 3,
      "text": "Values greater than 255 are reserved; updates to registration policy may make these values available for assignment and implementations MUST be prepared to receive them.",
      "ja": "255は予約されている以上の値。登録ポリシーの更新は、割り当てのために、これらの値を利用可能にすることができ、実装はそれらを受け取るために準備しなければなりません。"
    },
    {
      "indent": 3,
      "text": "This table provides the initial contents of the registry.",
      "ja": "このテーブルには、レジストリの初期内容を提供します。"
    },
    {
      "indent": 8,
      "text": "+-------+------------------------------------------------+\n| Value | Description                                    |\n+-------+------------------------------------------------+\n| 0     | Reserved                                       |\n|       |                                                |\n| 1     | Buffer is incorrect size                       |\n|       |                                                |\n| 2     | Incorrect mechanism OID                        |\n|       |                                                |\n| 3     | Token is corrupted                             |\n|       |                                                |\n| 4     | Token is truncated                             |\n|       |                                                |\n| 5     | Packet received by direction that sent it      |\n|       |                                                |\n| 6     | Incorrect token type identifier                |\n|       |                                                |\n| 7     | Unhandled critical subtoken received           |\n|       |                                                |\n| 8     | Missing required subtoken                      |\n|       |                                                |\n| 9     | Duplicate subtoken type                        |\n|       |                                                |\n| 10    | Received unexpected subtoken for current state |\n|       |                                                |\n| 11    | EAP did not produce a key                      |\n|       |                                                |\n| 12    | EAP key too short                              |\n|       |                                                |\n| 13    | Authentication rejected                        |\n|       |                                                |\n| 14    | AAA returned an unexpected message type        |\n|       |                                                |\n| 15    | AAA response did not include EAP request       |\n|       |                                                |\n| 16    | Generic AAA failure                            |\n+-------+------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.7. GSS-EAP Context Flags",
      "section_title": true,
      "ja": "7.7.  GSS-EAPコンテキスト国旗"
    },
    {
      "indent": 3,
      "text": "A new subregistry is created in the GSS-EAP parameters registry. This registry holds registrations of flag bits sent in the flags subtoken (Section 5.6.1). There are 32 flag bits available for registration represented as hexadecimal numbers from the most significant bit 0x80000000 to the least significant bit 0x1. The registration policy for this registry is IETF Review or, in exceptional cases, IESG Approval. The following table indicates initial registrations; all other values are available for assignment.",
      "ja": "新しい副登録はGSS-EAPパラメータレジストリに作成されます。このレジストリは、サブトークンフラグ（セクション5.6.1）に送信されるフラグビットの登録を保持しています。 0x80000000の最下位ビットを0x1に、最上位ビットから16進数として表さ登録に利用可能な32個のフラグ・ビットが存在します。このレジストリの登録ポリシーは、IETFレビューや、例外的な場合に、IESG承認です。次の表は、初期登録を示します。他のすべての値は、代入のために用意されています。"
    },
    {
      "indent": 15,
      "text": "+------+-------------------+---------------+\n| Flag | Name              | Reference     |\n+------+-------------------+---------------+\n| 0x2  | GSS_C_MUTUAL_FLAG | Section 5.6.1 |\n+------+-------------------+---------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "8. Security Considerations",
      "section_title": true,
      "ja": "8.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "RFC 3748 discusses security issues surrounding EAP. RFC 5247 discusses the security and requirements surrounding key management that leverages the AAA infrastructure. These documents are critical to the security analysis of this mechanism.",
      "ja": "RFC 3748には、EAPを取り巻くセキュリティの問題について説明します。 RFC 5247には、AAAインフラストラクチャを利用した鍵管理を取り巻くセキュリティおよび要件について説明します。これらの文書は、このメカニズムのセキュリティ分析に不可欠です。"
    },
    {
      "indent": 3,
      "text": "RFC 2743 discusses generic security considerations for the GSS-API. RFC 4121 discusses security issues surrounding the specific per-message services used in this mechanism.",
      "ja": "RFC 2743は、GSS-APIのための一般的なセキュリティ上の考慮事項について説明します。 RFC 4121は、このメカニズムで使用される特定のメッセージごとのサービスを取り巻くセキュリティの問題について説明します。"
    },
    {
      "indent": 3,
      "text": "As discussed in Section 4, this mechanism may introduce multiple layers of security negotiation into application protocols. Multiple layer negotiations are vulnerable to a bid-down attack when a mechanism negotiated at the outer layer is preferred to some but not all mechanisms negotiated at the inner layer; see Section 7.3 of [RFC4462] for an example. One possible approach to mitigate this attack is to construct security policy such that the preference for all mechanisms negotiated in the inner layer falls between preferences for two outer-layer mechanisms or falls at one end of the overall ranked preferences including both the inner and outer layer. Another approach is to only use this mechanism when it has specifically been selected for a given service. The second approach is likely to be common in practice because one common deployment will involve an EAP supplicant interacting with a user to select a given identity. Only when an identity is successfully chosen by the user will this mechanism be attempted.",
      "ja": "セクション4で説明したように、このメカニズムは、アプリケーションプロトコルにセキュリティネゴシエーションの複数の層を導入することができます。複数層の交渉は、外層でネゴシエート機構内層にネゴシエート一部ではないすべてのメカニズムに好ましいビッドダウン攻撃に対して脆弱です。例えば、[RFC4462]のセクション7.3を参照してください。この攻撃を軽減するための一つの可能​​なアプローチは、内層で交渉すべてのメカニズムの優先は、2つの外層機構の環境の間に入るか、内側と外側の層の両方を含む全体的なランク付けの好みの一方の端部に収まるようにセキュリティポリシーを構築することです。別のアプローチは、それが具体的に特定のサービスのために選択された場合にのみ、このメカニズムを使用することです。第2のアプローチは、一つの共通の展開が与えられたIDを選択するためにユーザと対話EAPサプリカントを伴いますので、実際には一般的である可能性が高いです。アイデンティティが成功し、ユーザによって選択された場合のみ、このメカニズムが試行されます。"
    },
    {
      "indent": 3,
      "text": "EAP channel binding is used to give the GSS-API initiator confidence in the identity of the GSS-API acceptor. Thus, the security of this mechanism depends on the use and verification of EAP channel binding.",
      "ja": "EAPチャネル結合は、GSS-APIのアクセプタのアイデンティティでGSS-APIのイニシエータの信頼を与えるために使用されます。したがって、このメカニズムのセキュリティは結合EAPチャネルの使用と検証に依存します。"
    },
    {
      "indent": 3,
      "text": "Today, EAP channel binding is in very limited deployment. If EAP channel binding is not used, then the system may be vulnerable to phishing attacks where a user is diverted from one service to another. If the EAP method in question supports mutual authentication then users can only be diverted between servers that are part of the same AAA infrastructure. For deployments where membership in the AAA infrastructure is limited, this may serve as a significant limitation on the value of phishing as an attack. For other deployments, use of EAP channel binding is critical to avoid phishing. These attacks are possible with EAP today although not typically with common GSS-API mechanisms. For this reason, implementations are required to implement and use EAP channel binding; see Section 3 for details.",
      "ja": "今日では、EAPチャネル結合は非常に限られた展開です。 EAPチャネル結合が使用されていない場合、システムは、ユーザが別のサービスから迂回されるフィッシング攻撃に対して脆弱であり得ます。問題のEAPメソッドは、相互認証をサポートしている場合、ユーザーは、同じAAAインフラストラクチャの一部であるサーバー間で流用することができます。 AAAインフラストラクチャ内のメンバーシップが制限されている展開では、これは攻撃としてフィッシングの値に重大な制約として機能することができます。他の展開では、結合EAPチャネルの使用は、フィッシング詐欺を避けるために重要です。これらの攻撃は、EAPではないが、典型的には、共通のGSS-APIメカニズムと、今日も可能です。このため、実装が実装し、結合EAPチャネルを使用する必要があります。詳細については、第3節を参照してください。"
    },
    {
      "indent": 3,
      "text": "The security considerations of EAP channel binding [RFC6677] describe the security properties of channel binding. Two attacks are worth calling out here. First, when a tunneled EAP method is used, it is critical that the channel binding be performed with an EAP server trusted by the peer. With existing EAP methods, this typically requires validating the certificate of the server tunnel endpoint back to a trust anchor and confirming the name of the entity who is a subject of that certificate. EAP methods may suffer from bid-down attacks where an attacker can cause a peer to think that a particular EAP server does not support channel binding. This does not directly cause a problem because mutual authentication is only offered at the GSS-API level when channel binding to the server's identity is successful. However, when an EAP method is not vulnerable to these bid-down attacks, additional protection is available. This mechanism will benefit significantly from new strong EAP methods such as [TEAP].",
      "ja": "EAPチャネル結合[RFC6677]のセキュリティ問題は、結合チャネルのセキュリティ特性を記述する。二つの攻撃は、ここに呼ん価値があります。トンネリングされたEAP方式が使用されている場合、最初、結合チャネルは、ピアが信頼するEAPサーバで実行することが重要です。既存のEAPメソッドを使用すると、これは通常、バックトラストアンカーへのサーバーのトンネルエンドポイントの証明書を検証し、その証明書の対象であるエンティティの名前を確認する必要が。 EAPメソッドは、攻撃者が特定のEAPサーバが結合チャネルをサポートしていないことを考えるピアを引き起こす可能性があります入札ダウン攻撃に苦しむことがあります。サーバーのIDに結合するチャネルが成功したときに、相互認証が唯一のGSS-APIレベルで提供されるので、これが直接問題を引き起こすことはありません。 EAPメソッドは、これらの入札ダウン攻撃に対して脆弱でないときただし、追加の保護が可能です。このメカニズムは、[TEAP]などの新しい強力なEAP方式から大幅に利益になります。"
    },
    {
      "indent": 3,
      "text": "Every proxy in the AAA chain from the authenticator to the EAP server needs to be trusted to help verify channel bindings and to protect the integrity of key material. GSS-API applications may be built to assume a trust model where the acceptor is directly responsible for authentication. However, GSS-API is definitely used with trusted-third-party mechanisms such as Kerberos.",
      "ja": "オーセンティケータからEAPサーバへのAAAチェーン内のすべてのプロキシは、チャネルバインディングを確認し、キーマテリアルの完全性を保護するのに役立つように、信頼する必要があります。 GSS-APIアプリケーションでは、アクセプターは、認証のために直接責任がある信頼モデルを想定して構築することができます。ただし、GSS-APIは、間違いなく、Kerberosなどの信頼できるサードパーティのメカニズムで使用されています。"
    },
    {
      "indent": 3,
      "text": "RADIUS does provide a weak form of hop-by-hop confidentiality of key material based on using MD5 as a stream cipher. Diameter can use TLS or IPsec but has no mandatory-to-implement confidentiality mechanism. Operationally, protecting key material as it is transported between the Identity Provider (IdP) and Relying Party (RP) is critical to per-message security and verification of GSS-API channel binding [RFC5056]. Mechanisms such as RADIUS over TLS [RFC6614] provide significantly better protection of key material than the base RADIUS specification.",
      "ja": "RADIUSは、ストリーム暗号としてMD5を使用することに基づいて鍵材料のホップバイホップ機密性の弱い形態を提供します。直径は、TLSやIPsecを使用しますが、何の実装に必須の機密保持機構を備えていることはできません。操作上、それはアイデンティティプロバイダ（IDP）と証明書利用者（RP）との間で輸送されるように、キーマテリアルを保護することは、[RFC5056]を結合GSS-APIのチャンネルのメッセージごとのセキュリティおよび検証のために重要です。そのようなTLS上RADIUS [RFC6614]などのメカニズムベースRADIUS仕様よりキー材料の有意に良好な保護を提供します。"
    },
    {
      "indent": 0,
      "text": "9. Acknowledgements",
      "section_title": true,
      "ja": "9.謝辞"
    },
    {
      "indent": 3,
      "text": "Luke Howard, Jim Schaad, Alejandro Perez Mendez, Alexey Melnikov, and Sujing Zhou provided valuable reviews of this document.",
      "ja": "ルーク・ハワード、ジムSchaad、アレハンドロ・ペレスメンデス、アレクセイ・メルニコフ、およびSujing周は、このドキュメントの貴重なレビューを提供します。"
    },
    {
      "indent": 3,
      "text": "Rhys Smith provided the text for the OID registry section. Sam Hartman's work on this document has been funded by JANET.",
      "ja": "リス・スミスは、OIDレジストリセクションのテキストを提供します。このドキュメントのサム・ハートマンの作品はJANETによって資金を供給されています。"
    },
    {
      "indent": 0,
      "text": "10. References",
      "section_title": true,
      "ja": "10.参考文献"
    },
    {
      "indent": 0,
      "text": "10.1. Normative References",
      "section_title": true,
      "ja": "10.1. 引用規格"
    },
    {
      "indent": 3,
      "text": "[GSS-IANA] IANA, \"GSS-API Service Name Registry\", <http://www.iana.org/assignments/gssapi-service-names>.",
      "ja": "[GSS-IANA] IANA、 \"GSS-APIサービス名レジストリ\"、<http://www.iana.org/assignments/gssapi-service-names>。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2743] Linn, J., \"Generic Security Service Application Program Interface Version 2, Update 1\", RFC 2743, January 2000.",
      "ja": "[RFC2743]リン、J.、 \"ジェネリックセキュリティーサービス適用業務プログラムインタフェースバージョン2、アップデート1\"、RFC 2743、2000年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC2744] Wray, J., \"Generic Security Service API Version 2 : C-bindings\", RFC 2744, January 2000.",
      "ja": "[RFC2744]レイ、J.、 \"ジェネリックセキュリティサービスAPIバージョン2：C-バインディング\"、RFC 2744、2000年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC3575] Aboba, B., \"IANA Considerations for RADIUS (Remote Authentication Dial In User Service)\", RFC 3575, July 2003.",
      "ja": "[RFC3575] Aboba、B.、 \"RADIUSのためのIANAの考慮事項（ユーザサービスにおけるリモート認証ダイヤル）\"、RFC 3575、2003年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC3748] Aboba, B., Blunk, L., Vollbrecht, J., Carlson, J., and H. Levkowetz, \"Extensible Authentication Protocol (EAP)\", RFC 3748, June 2004.",
      "ja": "[RFC3748] Aboba、B.、ブルンク、L.、Vollbrecht、J.、カールソン、J.、およびH. Levkowetz、 \"拡張認証プロトコル（EAP）\"、RFC 3748、2004年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC3961] Raeburn, K., \"Encryption and Checksum Specifications for Kerberos 5\", RFC 3961, February 2005.",
      "ja": "[RFC3961]レイバーン、K.、 \"暗号化とケルベロス5チェックサムの仕様\"、RFC 3961、2005年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC4121] Zhu, L., Jaganathan, K., and S. Hartman, \"The Kerberos Version 5 Generic Security Service Application Program Interface (GSS-API) Mechanism: Version 2\", RFC 4121, July 2005.",
      "ja": "[RFC4121]朱、L.、Jaganathan、K.、およびS.ハートマン、 \"Kerberosバージョン5の汎用セキュリティサービスアプリケーションプログラムインタフェース（GSS-API）メカニズム：バージョン2\"、RFC 4121、2005年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC4282] Aboba, B., Beadles, M., Arkko, J., and P. Eronen, \"The Network Access Identifier\", RFC 4282, December 2005.",
      "ja": "[RFC4282] Aboba、B.、Beadles、M.、Arkko、J.、およびP. Eronen、 \"ネットワークアクセス識別子\"、RFC 4282、2005年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC4401] Williams, N., \"A Pseudo-Random Function (PRF) API Extension for the Generic Security Service Application Program Interface (GSS-API)\", RFC 4401, February 2006.",
      "ja": "[RFC4401]ウィリアムズ、N.、RFC 4401 \"ジェネリックセキュリティーサービス適用業務プログラムインタフェース（GSS-API）のための擬似ランダム関数（PRF）APIの拡張\"、2006年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC4402] Williams, N., \"A Pseudo-Random Function (PRF) for the Kerberos V Generic Security Service Application Program Interface (GSS-API) Mechanism\", RFC 4402, February 2006.",
      "ja": "[RFC4402]ウィリアムズ、N.、RFC 4402、2006年2月、 \"ケルベロスVジェネリックセキュリティサービスアプリケーションプログラムインタフェース（GSS-API）メカニズムのための擬似ランダム関数（PRF）\"。"
    },
    {
      "indent": 3,
      "text": "[RFC5056] Williams, N., \"On the Use of Channel Bindings to Secure Channels\", RFC 5056, November 2007.",
      "ja": "\"チャネルを確保するチャネルバインディングの使用について\" [RFC5056]ウィリアムズ、N.、RFC 5056、2007年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC5226] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 5226, May 2008.",
      "ja": "[RFC5226] Narten氏、T.とH. Alvestrand、 \"RFCsにIANA問題部に書くためのガイドライン\"、BCP 26、RFC 5226、2008年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC5234] Crocker, D. and P. Overell, \"Augmented BNF for Syntax Specifications: ABNF\", STD 68, RFC 5234, January 2008.",
      "ja": "[RFC5234]クロッカー、D.、およびP. Overell、 \"構文仕様のための増大しているBNF：ABNF\"、STD 68、RFC 5234、2008年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC5554] Williams, N., \"Clarifications and Extensions to the Generic Security Service Application Program Interface (GSS-API) for the Use of Channel Bindings\", RFC 5554, May 2009.",
      "ja": "[RFC5554]ウィリアムズ、N.、RFC 5554、2009年05月05日「チャネルバインディングの使用のための一般的なセキュリティサービスアプリケーションプログラムインタフェース（GSS-API）への明確化と拡大」。"
    },
    {
      "indent": 3,
      "text": "[RFC5891] Klensin, J., \"Internationalized Domain Names in Applications (IDNA): Protocol\", RFC 5891, August 2010.",
      "ja": "[RFC5891] Klensin、J.、 \"アプリケーション（IDNA）で国際化ドメイン名：プロトコル\"、RFC 5891、2010年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC6677] Hartman, S., Clancy, T., and K. Hoeper, \"Channel-Binding Support for Extensible Authentication Protocol (EAP) Methods\", RFC 6677, July 2012.",
      "ja": "[RFC6677]ハートマン、S.、クランシー、T.、およびK. Hoeper、RFC 6677、2012年7月 \"拡張認証プロトコル（EAP）方式におけるチャネルバインディングサポート\"。"
    },
    {
      "indent": 3,
      "text": "[RFC7057] Winter, S. and J. Salowey, \"Update to the Extensible Authentication Protocol (EAP) Applicability Statement for Application Bridging for Federated Access Beyond Web (ABFAB)\", RFC 7057, December 2013.",
      "ja": "[RFC7057]冬、S.およびJ. Salowey、RFC 7057、2013年12月、 \"フェデレーションアクセスを越えてウェブ（ABFAB）のためにブリッジングアプリケーションのための拡張認証プロトコル（EAP）適用書にアップデート\"。"
    },
    {
      "indent": 0,
      "text": "10.2. Informative References",
      "section_title": true,
      "ja": "10.2. 参考文献"
    },
    {
      "indent": 3,
      "text": "[ABFAB-ARCH] Howlett, J., Hartman, S., Tschofenig, H., Lear, E., and J. Schaad, \"Application Bridging for Federated Access Beyond Web (ABFAB) Architecture\", Work in Progress, July 2013.",
      "ja": "[ABFAB-ARCH]ハウレット、J.、ハルトマン、S.、Tschofenig、H.、リア、E.、およびJ. Schaad、 \"アプリケーションは、フェデレーションアクセスを越えてウェブ（ABFAB）アーキテクチャのためのブリッジング\" 2013進行中で働いて、2011 。"
    },
    {
      "indent": 3,
      "text": "[RFC1964] Linn, J., \"The Kerberos Version 5 GSS-API Mechanism\", RFC 1964, June 1996.",
      "ja": "[RFC1964]リン、J.、 \"Kerberosバージョン5 GSS-APIメカニズム\"、RFC 1964、1996年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC3579] Aboba, B. and P. Calhoun, \"RADIUS (Remote Authentication Dial In User Service) Support For Extensible Authentication Protocol (EAP)\", RFC 3579, September 2003.",
      "ja": "[RFC3579] Aboba、B.およびP.カルフーン、 \"RADIUS（ユーザサービスにおけるリモート認証ダイヤル）拡張認証プロトコル（EAP）のサポート\"、RFC 3579、2003年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC4072] Eronen, P., Hiller, T., and G. Zorn, \"Diameter Extensible Authentication Protocol (EAP) Application\", RFC 4072, August 2005.",
      "ja": "[RFC4072] Eronen、P.、ヒラー、T.、およびG.ゾルン、 \"直径拡張認証プロトコル（EAP）アプリケーション\"、RFC 4072、2005年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC4178] Zhu, L., Leach, P., Jaganathan, K., and W. Ingersoll, \"The Simple and Protected Generic Security Service Application Program Interface (GSS-API) Negotiation Mechanism\", RFC 4178, October 2005.",
      "ja": "[RFC4178]朱、L.、リーチ、P.、Jaganathan、K.、およびW.インガーソル、 \"単純で保護された一般的なセキュリティサービスアプリケーションプログラムインタフェース（GSS-API）交渉メカニズム\"、RFC 4178、2005年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC4422] Melnikov, A. and K. Zeilenga, \"Simple Authentication and Security Layer (SASL)\", RFC 4422, June 2006.",
      "ja": "[RFC4422]メルニコフ、A.およびK. Zeilenga、 \"簡易認証セキュリティー層（SASL）\"、RFC 4422、2006年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC4462] Hutzelman, J., Salowey, J., Galbraith, J., and V. Welch, \"Generic Security Service Application Program Interface (GSS-API) Authentication and Key Exchange for the Secure Shell (SSH) Protocol\", RFC 4462, May 2006.",
      "ja": "[RFC4462] Hutzelman、J.、Salowey、J.、ガルブレイス、J.、およびV.ウェルチ、 \"ジェネリックセキュリティーサービス適用業務プログラムインタフェース（GSS-API）の認証とセキュアシェル（SSH）プロトコルのための鍵交換\"、RFC 4462、2006年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC4559] Jaganathan, K., Zhu, L., and J. Brezak, \"SPNEGO-based Kerberos and NTLM HTTP Authentication in Microsoft Windows\", RFC 4559, June 2006.",
      "ja": "[RFC4559] Jaganathan、K.、朱、L.、およびJ. Brezak、 \"Microsoft WindowsでのSPNEGOベースのKerberosとNTLM HTTP認証\"、RFC 4559、2006年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC5178] Williams, N. and A. Melnikov, \"Generic Security Service Application Program Interface (GSS-API) Internationalization and Domain-Based Service Names and Name Type\", RFC 5178, May 2008.",
      "ja": "[RFC5178]ウィリアムズ、N.とA.メルニコフ、「ジェネリックセキュリティーサービス適用業務プログラムインタフェース（GSS-API）国際化とドメインベースのサービス名と名前型」、RFC 5178、2008年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC5247] Aboba, B., Simon, D., and P. Eronen, \"Extensible Authentication Protocol (EAP) Key Management Framework\", RFC 5247, August 2008.",
      "ja": "[RFC5247] Aboba、B.、サイモン、D.、およびP. Eronen、 \"拡張認証プロトコル（EAP）鍵管理フレームワーク\"、RFC 5247、2008年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC6066] Eastlake, D., \"Transport Layer Security (TLS) Extensions: Extension Definitions\", RFC 6066, January 2011.",
      "ja": "[RFC6066]イーストレイク、D.、 \"トランスポート層セキュリティ（TLS）拡張機能：拡張定義\"、RFC 6066、2011年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC6614] Winter, S., McCauley, M., Venaas, S., and K. Wierenga, \"Transport Layer Security (TLS) Encryption for RADIUS\", RFC 6614, May 2012.",
      "ja": "[RFC6614]冬、S.、マッコーリー、M.、Venaas、S.、およびK. Wierenga、 \"RADIUSのためのトランスポート層セキュリティ（TLS）暗号化\"、RFC 6614、2012年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC6929] DeKok, A. and A. Lior, \"Remote Authentication Dial In User Service (RADIUS) Protocol Extensions\", RFC 6929, April 2013.",
      "ja": "[RFC6929] DeKok、A.とA. LIOR、RFC 6929、2013年4月 \"ユーザーサービス（RADIUS）プロトコルの拡張機能でリモート認証ダイヤル\"。"
    },
    {
      "indent": 3,
      "text": "[TEAP] Zhou, H., Cam-Winget, N., Salowey, J., and S. Hanna, \"Tunnel EAP Method (TEAP) Version 1\", Work in Progress, September 2013.",
      "ja": "【TEAP】周、H.、カムウィンゲット、N.、Salowey、J.、およびS.ハンナ、 \"トンネルEAPメソッド（TEAP）バージョン1\" は、進歩、2013年9月に働いています。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Pre-publication RADIUS VSA",
      "ja": "付録A.事前公表RADIUS VSA"
    },
    {
      "indent": 3,
      "text": "As described in Section 3.4, RADIUS attributes are used to carry the acceptor name when this family of mechanisms is used with RADIUS. Prior to the publication of this specification, a vendor-specific RADIUS attribute was used. This non-normative appendix documents that attribute as it may be seen from older implementations.",
      "ja": "3.4節で述べたようにメカニズムのこのファミリは、RADIUSで使用されている場合、RADIUS属性は、アクセプターの名前を運ぶために使用されています。本明細書の出版前に、ベンダー固有のRADIUS属性を使用しました。それは古い実装からもわかるよう属性この非規範付録文書。"
    },
    {
      "indent": 3,
      "text": "Prior to IANA assignment, GSS-EAP used a RADIUS vendor-specific attribute for carrying the acceptor name. The Vendor-Specific Attribute (VSA) with enterprise ID 25622 is formatted as a VSA according to the recommendation in the RADIUS specification. The following sub-attributes are defined:",
      "ja": "IANAの割り当てに先立ち、GSS-EAPは、アクセプターの名前を運ぶためのRADIUSベンダー固有の属性を使用していました。企業ID 25622を持つベンダー固有の属性（VSA）をRADIUS仕様の推奨に従ってVSAとしてフォーマットされます。以下のサブ属性が定義されています。"
    },
    {
      "indent": 3,
      "text": "+--------------------------------+-----------+----------------------+\n| Name                           | Attribute | Description          |\n+--------------------------------+-----------+----------------------+\n| GSS-Acceptor-Service-Name      | 128       | user-or-service      |\n|                                |           | portion of name      |\n|                                |           |                      |\n| GSS-Acceptor-Host-Name         | 129       | host portion of name |\n|                                |           |                      |\n| GSS-Acceptor-Service-Specifics | 130       | service-specifics    |\n|                                |           | portion of name      |\n|                                |           |                      |\n| GSS-Acceptor-Realm-Name        | 131       | Realm portion of     |\n|                                |           | name                 |\n+--------------------------------+-----------+----------------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Sam Hartman (editor) Painless Security",
      "ja": "サム・ハートマン（エディタ）無痛セキュリティ"
    },
    {
      "indent": 3,
      "text": "EMail: hartmans-ietf@mit.edu",
      "ja": "メールアドレス：hartmans-ietf@mit.edu"
    },
    {
      "indent": 3,
      "text": "Josh Howlett JANET(UK)",
      "ja": "ジョシュ・ハウレットJANET（UK）"
    },
    {
      "indent": 3,
      "text": "EMail: josh.howlett@ja.net",
      "ja": "メールアドレス：josh.howlett@ja.net"
    }
  ]
}