{
  "title": {
    "text": "RFC 7298 - Babel Hashed Message Authentication Code (HMAC) Cryptographic Authentication",
    "ja": "RFC 7298 - バベルハッシュメッセージ認証コード（HMAC）暗号化認証"
  },
  "number": 7298,
  "created_at": "2019-10-31 11:26:36.941809+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Independent Submission                                       D. Ovsienko\nRequest for Comments: 7298                                        Yandex\nUpdates: 6126                                                  July 2014\nCategory: Experimental\nISSN: 2070-1721",
      "raw": true
    },
    {
      "indent": 12,
      "text": "Babel Hashed Message Authentication Code (HMAC)\n          Cryptographic Authentication",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document describes a cryptographic authentication mechanism for the Babel routing protocol. This document updates RFC 6126. The mechanism allocates two new TLV types for the authentication data, uses Hashed Message Authentication Code (HMAC), and is both optional and backward compatible.",
      "ja": "この文書では、バベルのルーティングプロトコルの暗号認証メカニズムを説明しています。この文書の更新RFC 6126は、機構は、認証データのための2つの新たなTLVタイプを割り当て、ハッシュメッセージ認証コード（HMAC）を使用し、任意および下位互換性の両方です。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for examination, experimental implementation, and evaluation.",
      "ja": "このドキュメントはインターネット標準化過程仕様ではありません。それは、検査、実験的な実装、および評価のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document defines an Experimental Protocol for the Internet community. This is a contribution to the RFC Series, independently of any other RFC stream. The RFC Editor has chosen to publish this document at its discretion and makes no statement about its value for implementation or deployment. Documents approved for publication by the RFC Editor are not a candidate for any level of Internet Standard; see Section 2 of RFC 5741.",
      "ja": "この文書は、インターネットコミュニティのためにExperimentalプロトコルを定義します。これは、独立して、他のRFCストリームの、RFCシリーズへの貢献です。 RFC Editorはその裁量でこの文書を公開することを選択し、実装や展開のためにその値についての声明を出すていません。 RFC編集者によって公表のために承認されたドキュメントは、インターネット標準の任意のレベルの候補ではありません。 RFC 5741のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7298.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7298で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2014 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2014 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................3\n   1.1. Requirements Language ......................................5\n2. Cryptographic Aspects ...........................................5\n   2.1. Mandatory-to-Implement and Optional Hash Algorithms ........5\n   2.2. Definition of Padding ......................................6\n   2.3. Cryptographic Sequence Number Specifics ....................8\n   2.4. Definition of HMAC .........................................9\n3. Updates to Protocol Data Structures ............................11\n   3.1. RxAuthRequired ............................................11\n   3.2. LocalTS ...................................................11\n   3.3. LocalPC ...................................................11\n   3.4. MaxDigestsIn ..............................................11\n   3.5. MaxDigestsOut .............................................12\n   3.6. ANM Table .................................................12\n   3.7. ANM Timeout ...............................................13\n   3.8. Configured Security Associations ..........................14\n   3.9. Effective Security Associations ...........................16\n4. Updates to Protocol Encoding ...................................17\n   4.1. Justification .............................................17\n   4.2. TS/PC TLV .................................................19\n   4.3. HMAC TLV ..................................................20\n5. Updates to Protocol Operation ..................................21\n   5.1. Per-Interface TS/PC Number Updates ........................21\n   5.2. Deriving ESAs from CSAs ...................................23\n   5.3. Updates to Packet Sending .................................25\n   5.4. Updates to Packet Receiving ...............................28\n   5.5. Authentication-Specific Statistics Maintenance ............30\n6. Implementation Notes ...........................................31\n   6.1. Source Address Selection for Sending ......................31\n   6.2. Output Buffer Management ..................................31\n   6.3. Optimizations of Deriving Procedure for ESAs ..............32\n   6.4. Duplication of Security Associations ......................33\n7. Network Management Aspects .....................................34\n   7.1. Backward Compatibility ....................................34\n   7.2. Multi-Domain Authentication ...............................35\n   7.3. Migration to and from Authenticated Exchange ..............36\n   7.4. Handling of Authentication Key Exhaustion .................37\n8. Security Considerations ........................................38\n9. IANA Considerations ............................................43\n10. Acknowledgements ..............................................43\n11. References ....................................................44\n   11.1. Normative References .....................................44\n   11.2. Informative References ...................................44\nAppendix A. Figures and Tables ....................................47\nAppendix B. Test Vectors ..........................................52",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "Authentication of routing protocol exchanges is a common means of securing computer networks. The use of protocol authentication mechanisms helps in ascertaining that only the intended routers participate in routing information exchange and that the exchanged routing information is not modified by a third party.",
      "ja": "ルーティングプロトコル交換の認証は、コンピュータ・ネットワークを確保する一般的な手段です。プロトコルの認証メカニズムを使用することのみを意図ルータが情報交換をルーティングおよび交換ルーティング情報が第三者によって改変されていないことを参加することを確認するのに役立ちます。"
    },
    {
      "indent": 3,
      "text": "[BABEL] (\"the original specification\") defines data structures, encoding, and the operation of a basic Babel routing protocol instance (\"instance of the original protocol\"). This document (\"this specification\") defines data structures, encoding, and the operation of an extension to the Babel protocol -- an authentication mechanism (\"this mechanism\"). Both the instance of the original protocol and this mechanism are mostly self-contained and interact only at coupling points defined in this specification.",
      "ja": "[BABEL（「元の仕様」）は、データ構造、符号化、および基本的なバベルルーティングプロトコルインスタンス（「オリジナルプロトコルのインスタンス」）の動作を定義します。認証メカニズム（「このメカニズム」） - この文書（「本明細書」）は、データ構造、符号化、およびバベルプロトコルの拡張の動作を定義します。両方の元のプロトコルとこの機構の例は、主に自己完結型であり、本明細書で定義されている結合点でのみ相互作用します。"
    },
    {
      "indent": 3,
      "text": "A major design goal of this mechanism is transparency to operators that is not affected by implementation and configuration specifics. A complying implementation makes all meaningful details of authentication-specific processing clear to the operator, even when some of the operational parameters cannot be changed.",
      "ja": "このメカニズムの主要な設計目標は、実装と構成の仕様に影響されない事業者に対する透明性です。準拠実装では、動作パラメータの一部を変更することができない場合でも、オペレータへの認証に固有の処理の全ての意味の詳細が明らかになります。"
    },
    {
      "indent": 3,
      "text": "The currently established (see [RIP2-AUTH], [OSPF2-AUTH], [ISIS-AUTH-A], [RFC6039], and [OSPF3-AUTH-BIS]) approach to an authentication mechanism design for datagram-based routing protocols such as Babel relies on two principal data items embedded into protocol packets, typically as two integral parts of a single data structure:",
      "ja": "現在確立された（[RFC6039]、[ISIS-AUTH-A]、[OSPF2-AUTH]、[RIP2-AUTH]を参照し、[OSPF3-AUTH-BIS]）データグラムベースのルーティングプロトコルのための認証メカニズムの設計へのアプローチバベルは、2つの主要なデータ項目に依存しているような、典型的には単一のデータ構造の2つの一体的な部品として、プロトコルパケットに埋め込ま。"
    },
    {
      "indent": 3,
      "text": "o A fixed-length unsigned integer, typically called a cryptographic sequence number, used in replay attack protection.",
      "ja": "O固定長符号なし整数は、典型的には、リプレイ攻撃からの保護に使用される、暗号化シーケンス番号と呼ばれます。"
    },
    {
      "indent": 3,
      "text": "o A variable-length sequence of octets, a result of the Hashed Message Authentication Code (HMAC) construction (see [RFC2104]) computed on meaningful data items of the packet (including the cryptographic sequence number) on one hand and a secret key on the other, used in proving that both the sender and the receiver share the same secret key and that the meaningful data was not changed in transmission.",
      "ja": "Oオクテットの可変長配列、ハッシュメッセージ認証コード（HMAC）構造の結果は、（参照[RFC2104]）一方で（暗号化シーケンス番号を含む）パケットの意味のあるデータ項目および秘密鍵に基づいて計算証明に使用される、他のその送信者と受信者を共有同じ秘密鍵と意味のあるデータが送信中に変更されなかったことの両方。"
    },
    {
      "indent": 3,
      "text": "Depending on the design specifics, either all protocol packets or only those packets protecting the integrity of protocol exchange are authenticated. This mechanism authenticates all protocol packets.",
      "ja": "設計仕様に応じて、すべてのプロトコルパケットまたはプロトコル交換の整合性を保護するパケットのみのどちらかが認証されています。このメカニズムは、すべてのプロトコルパケットを認証します。"
    },
    {
      "indent": 3,
      "text": "Although the HMAC construction is just one of many possible approaches to cryptographic authentication of packets, this mechanism makes use of relevant prior experience by using HMAC as well, and its solution space correlates with the solution spaces of the mechanisms above. At the same time, it allows for a future extension that treats HMAC as a particular case of a more generic mechanism. Practical experience with the mechanism defined herein should be useful in designing such a future extension.",
      "ja": "HMACの建設は、パケットの暗号化認証に多くの可能なアプローチのひとつですが、このメカニズムは、同様にHMACを使用することによって、関連する以前の経験を利用して、その解空間は、上記のメカニズムの解スペースと相関します。同時に、それはより一般的なメカニズムの特定のケースとしてHMACを扱い、将来の拡張が可能になります。本明細書に定義される機構を備えた実用的な経験は、このような将来の拡張を設計する上で有用です。"
    },
    {
      "indent": 3,
      "text": "This specification defines the use of the cryptographic sequence number in detail sufficient to make replay attack protection strength predictable. That is, an operator can tell the strength from the declared characteristics of an implementation and, if the implementation allows the changing of relevant parameters, the effect of a reconfiguration as well.",
      "ja": "この仕様は、リプレイ攻撃に対する防御力が予測できるように十分な詳細の暗号化シーケンス番号の使用を定義します。実装は同様に、再構成の影響を関連パラメータの変更を可能にする場合、すなわち、操作者は、実装の宣言された特性からの強度を伝えることができます。"
    },
    {
      "indent": 3,
      "text": "This mechanism explicitly allows for multiple HMAC results per authenticated packet. Since meaningful data items of a given packet remain the same, each such HMAC result stands for a different secret key and/or a different hash algorithm. This enables a simultaneous, independent authentication within multiple domains. This specification is not novel in this regard; for example, the Layer 2 Tunneling Protocol (L2TPv3) allows for one or two results per authenticated packet ([RFC3931] Section 5.4.1), and Mobile Ad Hoc Network (MANET) protocols allow for several ([RFC7183] Section 6.1).",
      "ja": "このメカニズムは、明示的に認証されたパケットごとに複数のHMAC結果が可能になります。所与のパケットの意味のあるデータ項目が同一のままであるので、このような各HMAC結果は、異なる秘密鍵および/または異なるハッシュアルゴリズムを表します。これは、複数のドメイン内での同時、独立した認証が可能になります。この仕様は、この点では小説ではありません。例えば、レイヤ2トンネリングプロトコル（L2TPv3の）が認証パケットごとに1つのまたは2つの結果（[RFC3931]セクション5.4.1）を可能にし、モバイルアドホックネットワーク（MANET）プロトコルは、いくつかの（[RFC7183]セクション6.1）を可能にします。"
    },
    {
      "indent": 3,
      "text": "An important concern addressed by this mechanism is limiting the amount of HMAC computations done per authenticated packet, independently for sending and receiving. Without these limits, the number of computations per packet could be as high as the number of configured authentication keys (in the sending case) or as high as the number of keys multiplied by the number of supplied HMAC results (in the receiving case).",
      "ja": "このメカニズムによって対処の重要な関心事は、独立して送信と受信のために、認証されたパケットごとに行わHMAC計算の量を制限しています。これらの制限なしに、パケットあたりの計算の数は、（送信の場合に）構成された認証キーの数ほど高いまたは（受信場合）に供給されたHMAC結果の数を乗じたキーの数ほど高くなり得ます。"
    },
    {
      "indent": 3,
      "text": "These limits establish a basic competition between the configured keys and (in the receiving case) an additional competition between the supplied HMAC results. This specification defines related data structures and procedures in a way to make such competition transparent and predictable for an operator.",
      "ja": "これらの制限は、設定キー間及び供給HMAC結果の間に追加の競合（受信場合）基本的な競争を確立します。この仕様は、オペレータのために、このような競争は、透明性と予測可能にする方法に関連するデータ構造と手順を定義します。"
    },
    {
      "indent": 3,
      "text": "Wherever this specification mentions the operator reading or changing a particular data structure, variable, parameter, or event counter \"at runtime\", it is up to the implementor how this is to be done. For example, the implementation can employ an interactive command line interface (CLI), a management protocol such as the Simple Network Management Protocol (SNMP), a means of inter-process communication such as a local socket, or a combination of these.",
      "ja": "この仕様は、オペレータの読み取りまたは「実行時に」特定のデータ構造、変数、パラメータ、またはイベントカウンタを変更するに言及どこ、これが行われることになっている方法実装次第です。例えば、実装は、ローカルソケット、又はこれらの組み合わせなどの対話型コマンドラインインターフェイス（CLI）、簡易ネットワーク管理プロトコル（SNMP）、プロセス間通信の手段として、このような管理プロトコルを使用することができます。"
    },
    {
      "indent": 0,
      "text": "1.1. Requirements Language",
      "section_title": true,
      "ja": "1.1. 要件言語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はありますBCP 14 [RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "2. Cryptographic Aspects",
      "section_title": true,
      "ja": "2.暗号側面"
    },
    {
      "indent": 0,
      "text": "2.1. Mandatory-to-Implement and Optional Hash Algorithms",
      "section_title": true,
      "ja": "2.1.  -実装するには、必須およびオプションのハッシュアルゴリズム"
    },
    {
      "indent": 3,
      "text": "[RFC2104] defines HMAC as a construction that can use any cryptographic hash algorithm with a known digest length and internal block size. This specification preserves this property of HMAC by defining data processing that itself does not depend on any particular hash algorithm either. However, since this mechanism is a protocol extension case, there are relevant design considerations to take into account.",
      "ja": "[RFC2104]は既知の長さ及び内部ブロックサイズダイジェストを有する任意の暗号化ハッシュアルゴリズムを使用することができる構成としてHMACを定義します。この仕様は、それ自体がいずれかの任意の特定のハッシュアルゴリズムに依存しないデータの処理を定義することによってHMACのこの特性を保存します。このメカニズムは、プロトコル拡張ケースであるので、考慮すべき関連する設計上の考慮事項があります。"
    },
    {
      "indent": 3,
      "text": "Section 4.5 of [RFC6709] suggests selecting one hash algorithm as mandatory to implement for the purpose of global interoperability (Section 3.2 of [RFC6709]) and selecting another of distinct lineage as recommended for implementation for the purpose of cryptographic agility. This specification makes the latter property guaranteed, rather than probable, through an elevation of the requirement level. There are two mandatory-to-implement hash algorithms; each is unambiguously defined and generally available in multiple implementations.",
      "ja": "[RFC6709]のセクション4.5は、暗号敏捷性の目的のための実装のために推奨されているように世界的な相互運用性（[RFC6709]の3.2節）と明確な系統の別を選択する目的のために実装する義務として、1つのハッシュアルゴリズムを選択示唆しています。本明細書は後者のプロパティは、要求レベルの上昇を介して、むしろ予想よりも、保証させます。 2実装に必須のハッシュアルゴリズムがあります。各々が明確に定義され、複数の実装で一般的に利用可能です。"
    },
    {
      "indent": 3,
      "text": "An implementation of this mechanism MUST include support for two hash algorithms:",
      "ja": "このメカニズムの実装は、2つのハッシュアルゴリズムのサポートを含める必要があります。"
    },
    {
      "indent": 3,
      "text": "o RIPEMD-160 (160-bit digest)",
      "ja": "O RIPEMD-160（160ビットのダイジェスト）"
    },
    {
      "indent": 3,
      "text": "o SHA-1 (160-bit digest)",
      "ja": "O SHA-1（160ビットのダイジェスト）"
    },
    {
      "indent": 3,
      "text": "Besides that, an implementation of this mechanism MAY include support for additional hash algorithms, provided each such algorithm is publicly and openly specified and its digest length is 128 bits or more (to meet the constraint implied in Section 2.2). Implementors SHOULD consider strong, well-known hash algorithms as additional implementation options and MUST NOT consider a hash algorithm if meaningful attacks exist for it or it is commonly viewed as deprecated.",
      "ja": "それに加えて、このメカニズムの実装は、追加のハッシュアルゴリズムのためのサポートを含んでいてもよく、それぞれのそのようなアルゴリズムは、公的かつ公然と指定され、そのダイジェスト長が128ビット以上で提供（2.2節で暗黙の制約を満たすために）。実装者は、追加の実装オプションとして、強力な、よく知られたハッシュアルゴリズムを検討すべきであるし、意味のある攻撃がそれのために存在するか、廃止予定としては、一般的に観察された場合は、ハッシュアルゴリズムを検討してはなりません。"
    },
    {
      "indent": 3,
      "text": "In the latter case, it is important to take into account considerations both common (such as those made in [RFC4270]) and specific to the HMAC application of the hash algorithm. For example, [RFC6151] considers MD5 collisions and concludes that new protocol designs should not use HMAC-MD5, while [RFC6194] includes a comparable analysis of SHA-1 that finds HMAC-SHA-1 secure for the same purpose.",
      "ja": "後者の場合には、（例えば、[RFC4270]で作られたもののような）一般的なハッシュアルゴリズムのHMACのアプリケーションに固有の両方のアカウントに考慮することが重要です。例えば、[RFC6151]はMD5の衝突を考慮して、[RFC6194]は、同じ目的のための安全なHMAC-SHA-1を発見SHA-1の同等の分析を含むが、新しいプロトコルの設計は、HMAC-MD5を使用するべきではないと結論づけています。"
    },
    {
      "indent": 3,
      "text": "For example, the following hash algorithms meet these requirements at the time of this writing (in alphabetical order):",
      "ja": "たとえば、以下のハッシュアルゴリズムは、（アルファベット順で）これを書いている時点で、これらの要件を満たします："
    },
    {
      "indent": 3,
      "text": "o GOST R 34.11-94 (256-bit digest)",
      "ja": "O GOST R 34.11から94（256ビットのダイジェスト）"
    },
    {
      "indent": 3,
      "text": "o SHA-224 (224-bit digest, SHA-2 family)",
      "ja": "O SHA-224（224ビットのダイジェスト、SHA-2ファミリー）"
    },
    {
      "indent": 3,
      "text": "o SHA-256 (256-bit digest, SHA-2 family)",
      "ja": "O SHA-256（256ビットのダイジェスト、SHA-2ファミリー）"
    },
    {
      "indent": 3,
      "text": "o SHA-384 (384-bit digest, SHA-2 family)",
      "ja": "O SHA-384（384ビットのダイジェスト、SHA-2ファミリー）"
    },
    {
      "indent": 3,
      "text": "o SHA-512 (512-bit digest, SHA-2 family)",
      "ja": "O SHA-512（512ビットのダイジェスト、SHA-2ファミリー）"
    },
    {
      "indent": 3,
      "text": "o Tiger (192-bit digest)",
      "ja": "タイガーO（192ビットのダイジェスト）"
    },
    {
      "indent": 3,
      "text": "o Whirlpool (512-bit digest, 2nd rev., 2003)",
      "ja": "Oワールプール（512ビットのダイジェスト、第2 REV。、2003）"
    },
    {
      "indent": 3,
      "text": "The set of hash algorithms available in an implementation MUST be clearly stated. When known weak authentication keys exist for a hash algorithm used in the HMAC construction, an implementation MUST deny the use of such keys.",
      "ja": "実装で利用可能なハッシュアルゴリズムのセットが明確に記載しなければなりません。既知の弱い認証キーはHMACの構築に使用されるハッシュアルゴリズムのために存在する場合、実装は、そのようなキーの使用を拒否しなければなりません。"
    },
    {
      "indent": 0,
      "text": "2.2. Definition of Padding",
      "section_title": true,
      "ja": "2.2. パディングの定義"
    },
    {
      "indent": 3,
      "text": "Many practical applications of HMAC for authentication of datagram-based network protocols (including routing protocols) involve the padding procedure, a design-specific conditioning of the message that both the sender and the receiver perform before the HMAC computation. The specific padding procedure of this mechanism addresses the following needs:",
      "ja": "（ルーティングプロトコルを含む）データグラムベースのネットワークプロトコルの認証のためのHMACの多くの実用的なアプリケーションでは、パディング手順、送信者と受信者の両方がHMAC計算の前に行うメッセージの設計に固有のコンディショニングを含みます。このメカニズムの具体的なパディング手順は、次の必要性に対処します。"
    },
    {
      "indent": 3,
      "text": "o Data Initialization",
      "ja": "Oデータの初期化"
    },
    {
      "indent": 6,
      "text": "A design that places the HMAC result(s) computed for a message inside that same message after the computation has to have previously (i.e., before the computation) allocated in that message some data unit(s) purposed specifically for those HMAC result(s) (in this mechanism, it is the HMAC TLV(s); see Section 4.3). The padding procedure sets the respective octets of the data unit(s), in the simplest case to a fixed value known as the padding constant.",
      "ja": "計算が以前に（すなわち、演算前の）いくつかのデータユニット（単数または複数）が、それらのHMAC結果（秒具体的目的と、そのメッセージに割り当てられたなければならない後に、同じメッセージ内のメッセージについて計算HMAC結果（複数可）を配置する設計）（このメカニズムでは、HMAC TLV（sで）; 4.3節を参照）。パディング手順はパディング定数として知られている固定値に最も簡単な場合には、データ部（S）の各オクテットを設定します。"
    },
    {
      "indent": 6,
      "text": "The particular value of the constant is specific to each design. For instance, in [RIP2-AUTH] as well as works derived from it ([ISIS-AUTH-B], [OSPF2-AUTH], and [OSPF3-AUTH-BIS]), the value is 0x878FE1F3. In many other designs (for instance, [RFC3315], [RFC3931], [RFC4030], [RFC4302], [RFC5176], and [ISIS-AUTH-A]), the value is 0x00.",
      "ja": "一定の特定の値は、各設計に固有です。例えば、[RIP2-AUTH]ならびにそれから誘導される作品（[ISIS-AUTH-B]、[OSPF2-AUTH]、および[OSPF3-AUTH-BIS]）で、値が0x878FE1F3あります。多くの他の設計（例えば、[RFC3315]、[RFC3931]、[RFC4030]、[RFC4302]、[RFC5176]、および[ISIS-AUTH-A]）で、値が0x00です。"
    },
    {
      "indent": 6,
      "text": "However, the HMAC construction is defined on the basis of a cryptographic hash algorithm, that is, an algorithm meeting a particular set of requirements made for any input message. Thus, any padding constant values, whether single- or multiple-octet, as well as any other message-conditioning methods, don't affect cryptographic characteristics of the hash algorithm and the HMAC construction, respectively.",
      "ja": "しかし、HMAC構造は暗号ハッシュアルゴリズムに基づいて定義されている、すなわち、いずれかの入力メッセージのために作られた要件の特定のセットを満たすアルゴリズムです。したがって、任意のパディング定数値、単一または複数のオクテットかどうか、ならびに任意の他のメッセージコンディショニング方法は、それぞれ、ハッシュアルゴリズムとHMAC構造の暗号化特性に影響を及ぼしません。"
    },
    {
      "indent": 3,
      "text": "o Source Address Protection",
      "ja": "Oソースアドレス保護"
    },
    {
      "indent": 6,
      "text": "In the specific case of datagram-based routing protocols, the protocol packet (that is, the message being authenticated) often does not include network-layer addresses, although the source and (to a lesser extent) the destination address of the datagram may be meaningful in the scope of the protocol instance.",
      "ja": "データグラムのソース及び（より少ない程度に）宛先アドレスがあってもよいが、データグラムベースのルーティングプロトコルの特定の場合には、プロトコルパケット（すなわち、認証されるメッセージである）は、多くの場合、ネットワーク層アドレスが含まれていませんプロトコルインスタンスの範囲において有意義。"
    },
    {
      "indent": 6,
      "text": "In Babel, the source address may be used as a prefix next hop (see Section 3.5.3 of [BABEL]). A well-known (see Section 2.3 of [OSPF3-AUTH-BIS]) solution to the source address protection problem is to set the first respective octets of the data unit(s) above to the source address (yet setting the rest of the octets to the padding constant). This procedure adapts this solution to the specifics of Babel, which allows for the exchange of protocol packets using both IPv4 and IPv6 datagrams (see Section 4 of [BABEL]). Even though in the case of IPv6 exchange a Babel speaker currently uses only link-local source addresses (Section 3.1 of [BABEL]), this procedure protects all octets of an arbitrary given source address for the reasons of future extensibility. The procedure implies that future Babel extensions will never use an IPv4-mapped IPv6 address as a packet source address.",
      "ja": "バベルでは、送信元アドレス、プレフィックス、ネクストホップとして使用することができる（[BABEL]のセクション3.5.3を参照）。ソースアドレス保護の問題によく知られている（第2.3節を参照の[OSPF3-AUTH-BIS]）溶液は、まだ残りの設定（送信元アドレスに上記データユニット（複数可）の最初の各オクテットを設定することですパディング定数オクテット）。この手順は、IPv4とIPv6の両方のデータグラムを使用して、プロトコルパケット（[BABEL]のセクション4を参照）の交換を可能にバベルの仕様にこの溶液を適応させます。 IPv6の交換の場合にバベルスピーカーは、現在のみリンクローカル送信元アドレス（[BABEL]のセクション3.1）を使用しても、この手順は、将来の拡張性の理由のために、任意の所与の送信元アドレスのすべてのオクテットを保護します。手順は、将来のバベルの拡張は、パケットの送信元アドレスとしてIPv4射影IPv6アドレスを使用しないことを意味します。"
    },
    {
      "indent": 6,
      "text": "This procedure does not protect the destination address, which is currently considered meaningless (Section 3.1 of [BABEL]) in the same scope. A future extension that looks to add such protection would likely use a new TLV or sub-TLV to include the destination address in the protocol packet (see Section 4.1).",
      "ja": "この手順は、現在、同じスコープ内の無意味（[BABEL]のセクション3.1）であると考えられる宛先アドレスを、保護しません。そうなプロトコルパケットの宛先アドレスが含まれるように、新たなTLVまたはサブTLVを使用することになり、このような保護機能を追加することになります将来の拡張は（セクション4.1を参照してください）。"
    },
    {
      "indent": 3,
      "text": "Description of the padding procedure:",
      "ja": "パディング手順の説明："
    },
    {
      "indent": 3,
      "text": "1. Set the first 16 octets of the Digest field of the given HMAC TLV to:",
      "ja": "1.与えられたHMAC TLVのダイジェストフィールドの最初の16個のオクテットを設定します。"
    },
    {
      "indent": 7,
      "text": "* the given source address, if it is an IPv6 address, or",
      "ja": "*与えられた送信元アドレスを、それがIPv6アドレスである場合、または"
    },
    {
      "indent": 7,
      "text": "* the IPv4-mapped IPv6 address (per Section 2.5.5.2 of [RFC4291]) holding the given source address, if it is an IPv4 address.",
      "ja": "それはIPv4アドレスである場合*（[RFC4291]のセクション2.5.5.2当たり）IPv4射影IPv6アドレスは、所定の送信元アドレスを保持します。"
    },
    {
      "indent": 3,
      "text": "2. Set the remaining (TLV Length - 18) octets of the Digest field of the given HMAC TLV to 0x00 each.",
      "ja": "2.残り（TLVの長さ -  18）設定された所定のHMAC TLVのダイジェストフィールドのオクテットをそれぞれ0x00に。"
    },
    {
      "indent": 3,
      "text": "For an example of a Babel packet with padded HMAC TLVs, see Table 3 in Appendix A.",
      "ja": "パディングされたHMACのTLVとバベルパケットの例については、付録Aの表3参照"
    },
    {
      "indent": 0,
      "text": "2.3. Cryptographic Sequence Number Specifics",
      "section_title": true,
      "ja": "2.3. 暗号シーケンス番号細目"
    },
    {
      "indent": 3,
      "text": "The operation of this mechanism may involve multiple local and multiple remote cryptographic sequence numbers, each essentially being a 48-bit unsigned integer. This specification uses the term \"TS/PC number\" to avoid confusion with the route's (Section 2.5 of [BABEL]) or node's (Section 3.2.1 of [BABEL]) sequence numbers of the original Babel specification and to stress the fact that there are two distinguished parts of this 48-bit number, each handled in its specific way (see Section 5.1):",
      "ja": "この機構の動作は、それぞれが実質的に48ビットの符号なし整数である、複数のローカルおよび複数のリモート暗号化シーケンス番号を含むことができます。この仕様は、ルートの（[BABEL]の2.5節）、またはノードの（[BABEL]のセクション3.2.1）元バベル仕様のシーケンス番号との混同を避けるためにしているという事実を強調するために用語「TS / PC番号」を使用していますこの48ビットの数の2つの識別部分、その特定の方法で扱う各（セクション5.1を参照）があります。"
    },
    {
      "indent": 3,
      "text": " 0                   1     2 3                   4\n 0 1 2 3 4 5 6 7 8 9 0 //  9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+-+-+-//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|         TS         //         |              PC               |\n+-+-+-+-+-+-+-+-+-+-//+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                   //",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The high-order 32 bits are called \"timestamp\" (TS), and the low-order 16 bits are called \"packet counter\" (PC).",
      "ja": "上位32ビットは、「タイムスタンプ」（TS）と呼ばれ、下位16ビットは、「パケットカウント」（PC）と呼ばれます。"
    },
    {
      "indent": 3,
      "text": "This mechanism stores, updates, compares, and encodes each TS/PC number as two independent unsigned integers -- TS and PC, respectively. Such a comparison of TS/PC numbers, as performed in item 3 of Section 5.4, is algebraically equivalent to a comparison of the respective 48-bit unsigned integers. Any byte order conversion, when required, is performed on TS and PC parts independently.",
      "ja": "このメカニズムを格納、更新は、比較し、それぞれが、2つの独立した符号なし整数として/ PC番号をTSエンコード -  TSとPC、それぞれ。 TS / PC番号のような比較は、セクション5.4の項目3で行ったように、それぞれの48ビット符号なし整数の比較に代数的に等価です。任意のバイトオーダー変換は、必要なときに、独立してTSとPCパーツで行われます。"
    },
    {
      "indent": 0,
      "text": "2.4. Definition of HMAC",
      "section_title": true,
      "ja": "2.4.  HMACの定義"
    },
    {
      "indent": 3,
      "text": "The algorithm description below uses the following nomenclature, which is consistent with [FIPS-198]:",
      "ja": "アルゴリズム記述は、以下の[FIPS-198]と一致している以下の用語を使用します。"
    },
    {
      "indent": 3,
      "text": "Text The data on which the HMAC is calculated (note item (b) of Section 8). In this specification, it is the contents of a Babel packet ranging from the beginning of the Magic field of the Babel packet header to the end of the last octet of the Packet Body field, as defined in Section 4.2 of [BABEL] (see Figure 2 in Appendix A).",
      "ja": "HMACを計算されたテキストデータ（第8項の項目（B）に注意してください）。 [BABEL]のセクション4.2で定義されるように、本明細書では、（図を参照して、バベルパケットヘッダのマジック・フィールドの先頭からパケットボディフィールドの最後のオクテットの終わりまでの範囲バベルパケットの内容であります付録Aで2）。"
    },
    {
      "indent": 3,
      "text": "H The specific hash algorithm (see Section 2.1).",
      "ja": "H特定のハッシュアルゴリズム（セクション2.1を参照）。"
    },
    {
      "indent": 3,
      "text": "K A sequence of octets of an arbitrary, known length.",
      "ja": "任意の、既知の長さのオクテットのシーケンスをK。"
    },
    {
      "indent": 3,
      "text": "Ko The cryptographic key used with the hash algorithm.",
      "ja": "コハッシュアルゴリズムで使用される暗号鍵。"
    },
    {
      "indent": 3,
      "text": "B The block size of H, measured in octets rather than bits. Note that B is the internal block size, not the digest length.",
      "ja": "HのブロックサイズB、オクテットよりむしろビットで測定。 Bは、内部ブロック・サイズではなく、ダイジェストの長さであることに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "L The digest length of H, measured in octets rather than bits.",
      "ja": "オクテットよりむしろビットで測定されたHのLザダイジェスト長。"
    },
    {
      "indent": 3,
      "text": "XOR The bitwise exclusive-or operation.",
      "ja": "排他的論理和演算ビット単位のXOR。"
    },
    {
      "indent": 3,
      "text": "Opad The hexadecimal value 0x5C repeated B times.",
      "ja": "B回繰り返し0x5Cを16進数の値をOPAD。"
    },
    {
      "indent": 3,
      "text": "Ipad The hexadecimal value 0x36 repeated B times.",
      "ja": "アプリは、16進数の値0x36がB回繰り返します。"
    },
    {
      "indent": 3,
      "text": "The algorithm below is the original, unmodified HMAC construction as defined in both [RFC2104] and [FIPS-198]; hence, it is different from the algorithms defined in [RIP2-AUTH], [ISIS-AUTH-B], [OSPF2-AUTH], and [OSPF3-AUTH-BIS] in exactly two regards:",
      "ja": "[RFC2104]と[FIPS-198]の両方で定義されるように以下のアルゴリズムは、元の、非修飾HMAC構造です。したがって、[OSPF2-AUTH]、[ISIS-AUTH-B]、[RIP2-AUTH]で定義されたアルゴリズムとは異なる、とちょうど二つの点で[OSPF3-AUTH-BIS]です。"
    },
    {
      "indent": 3,
      "text": "o The algorithm below sets the size of Ko to B, not to L (L is not greater than B). This resolves both ambiguity in XOR expressions and incompatibility in the handling of keys that have length greater than L but not greater than B.",
      "ja": "Oアルゴリズムは、以下（LはBより大きくない）がLに、Bにコのサイズを設定します。これは、Lよりも大きいが、Bよりも大きくない長さを持つキーの取り扱いにXOR式の曖昧さとの非互換性の両方を解決します"
    },
    {
      "indent": 3,
      "text": "o The algorithm below does not change the value of Text before or after the computation. Padding a Babel packet before the computation and placing the result inside the packet are both performed elsewhere.",
      "ja": "Oアルゴリズムは、以下の前または演算後のテキストの値を変更しません。計算前バベルパケットをパディングし、パケット内の結果を確定すると、両方の他の場所で行われます。"
    },
    {
      "indent": 3,
      "text": "The intent of this is to enable the most straightforward use of cryptographic libraries by implementations of this specification. At the time of this writing, implementations of the original HMAC construction coupled with hash algorithms of choice are generally available.",
      "ja": "これの目的は、この仕様の実装によって暗号化ライブラリの最も簡単な使用を可能にするためです。この記事の執筆時点では、選択肢のハッシュアルゴリズムと相まって、オリジナルHMAC工事の実装が一般的に利用可能です。"
    },
    {
      "indent": 3,
      "text": "Description of the algorithm:",
      "ja": "アルゴリズムの説明："
    },
    {
      "indent": 3,
      "text": "1. Preparation of the Key",
      "section_title": true,
      "ja": "キーの調製"
    },
    {
      "indent": 7,
      "text": "In this application, Ko is always B octets long.  If K is B\noctets long, then Ko is set to K.  If K is more than B octets\nlong, then Ko is set to H(K) with the necessary amount of zeroes\nappended to the end of H(K), such that Ko is B octets long.  If K\nis less than B octets long, then Ko is set to K with zeroes\nappended to the end of K, such that Ko is B octets long.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "2. First-Hash",
      "section_title": true,
      "ja": "まず、ハッシュ"
    },
    {
      "indent": 7,
      "text": "A First-Hash, also known as the inner hash, is computed\nas follows:",
      "raw": true
    },
    {
      "indent": 20,
      "text": "First-Hash = H(Ko XOR Ipad || Text)",
      "ja": "一ハッシュ= H（KO XOR ipadと||テキスト）"
    },
    {
      "indent": 3,
      "text": "3. Second-Hash",
      "section_title": true,
      "ja": "3.セカンドハッシュ"
    },
    {
      "indent": 7,
      "text": "A Second-Hash, also known as the outer hash, is computed\nas follows:",
      "raw": true
    },
    {
      "indent": 17,
      "text": "Second-Hash = H(Ko XOR Opad || First-Hash)",
      "ja": "第二ハッシュ= H（KO XOR OPAD ||まず、ハッシュ）"
    },
    {
      "indent": 3,
      "text": "4. Result",
      "section_title": true,
      "ja": "4.結果"
    },
    {
      "indent": 7,
      "text": "The resulting Second-Hash becomes the authentication data that is\nreturned as the result of HMAC calculation.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Note that in the case of Babel the Text parameter will never exceed a few thousand octets in length. In this specific case, the optimization discussed in Section 6 of [FIPS-198] applies, namely, for a given K that is more than B octets long, the following associated intermediate results may be precomputed only once: Ko, (Ko XOR Ipad), and (Ko XOR Opad).",
      "ja": "バベルの場合にテキストパラメータは、長さが数千オクテットを超えることはありませんので注意してください。コ、（KO XOR計算された：この特定の場合では、[FIPS-198]のセクション6で説明した最適化、すなわち、Bが長いオクテットより多い所与のkについて、次の関連する中間結果は一度だけ事前に計算されてもよい、適用します）、及び（KO XOR OPAD）。"
    },
    {
      "indent": 0,
      "text": "3. Updates to Protocol Data Structures",
      "section_title": true,
      "ja": "プロトコル・データ構造へ3.アップデート"
    },
    {
      "indent": 0,
      "text": "3.1. RxAuthRequired",
      "section_title": true,
      "ja": "3.1.  RxAuthRequired"
    },
    {
      "indent": 3,
      "text": "RxAuthRequired is a boolean parameter. Its default value MUST be TRUE. An implementation SHOULD make RxAuthRequired a per-interface parameter but MAY make it specific to the whole protocol instance. The conceptual purpose of RxAuthRequired is to enable a smooth migration from an unauthenticated Babel packet exchange to an authenticated Babel packet exchange and back (see Section 7.3). The current value of RxAuthRequired directly affects the receiving procedure defined in Section 5.4. An implementation SHOULD allow the operator to change the RxAuthRequired value at runtime or by means of a Babel speaker restart. An implementation MUST allow the operator to discover the effective value of RxAuthRequired at runtime or from the system documentation.",
      "ja": "RxAuthRequiredはブール・パラメータです。デフォルト値はTRUEでなければなりません。実装はRxAuthRequiredにインタフェース毎のパラメータを確認する必要がありますが、全体プロトコルインスタンスにそれが特定のかもしれません。 RxAuthRequiredの概念の目的は、認証されたバベルパケット交換とバック（セクション7.3を参照）に認証されていないバベルパケット交換機からのスムーズな移行を可能にすることです。 RxAuthRequiredの電流値は、直接セクション5.4で定義された受信手順に影響を与えます。実装は、オペレータが実行時またはバベルスピーカーの再起動によってRxAuthRequired値を変更できるようにする必要があります。実装は、オペレータが、実行時またはシステムのマニュアルからRxAuthRequiredの実効値を発見するために許容しなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.2. LocalTS",
      "section_title": true,
      "ja": "3.2.  LocalTS"
    },
    {
      "indent": 3,
      "text": "LocalTS is a 32-bit unsigned integer variable. It is the TS part of a per-interface TS/PC number. LocalTS is a strictly per-interface variable not intended to be changed by the operator. Its initialization is explained in Section 5.1.",
      "ja": "LocalTSは、32ビットの符号なし整数変数です。これは、インターフェイスTS / PC数のTSの一部です。 LocalTSは、オペレータによって変更されるものではない厳密ごとインターフェース変数です。その初期化はセクション5.1で説明されています。"
    },
    {
      "indent": 0,
      "text": "3.3. LocalPC",
      "section_title": true,
      "ja": "3.3.  LocalPC"
    },
    {
      "indent": 3,
      "text": "LocalPC is a 16-bit unsigned integer variable. It is the PC part of a per-interface TS/PC number. LocalPC is a strictly per-interface variable not intended to be changed by the operator. Its initialization is explained in Section 5.1.",
      "ja": "LocalPCは、16ビットの符号なし整数変数です。これは、インターフェイスTS / PC数のPCの一部です。 LocalPCは、オペレータによって変更されるものではない厳密ごとインターフェース変数です。その初期化はセクション5.1で説明されています。"
    },
    {
      "indent": 0,
      "text": "3.4. MaxDigestsIn",
      "section_title": true,
      "ja": "3.4.  MaxDigestsIn"
    },
    {
      "indent": 3,
      "text": "MaxDigestsIn is an unsigned integer parameter conceptually purposed for limiting the amount of CPU time spent processing a received authenticated packet. The receiving procedure performs the most CPU-intensive operation -- the HMAC computation -- only at most MaxDigestsIn (Section 5.4 item 7) times for a given packet.",
      "ja": "MaxDigestsIn概念的受信した認証パケットの処理に費やされるCPU時間の量を制限するための目的と符号なし整数パラメータです。 HMAC計算 -   - のみ与えられたパケットのための最もMaxDigestsIn（5.4項目7）時間で受信手順は、ほとんどのCPU集約型の動作を行います。"
    },
    {
      "indent": 3,
      "text": "The MaxDigestsIn value MUST be at least 2. An implementation SHOULD make MaxDigestsIn a per-interface parameter but MAY make it specific to the whole protocol instance. An implementation SHOULD allow the operator to change the value of MaxDigestsIn at runtime or by means of a Babel speaker restart. An implementation MUST allow the operator to discover the effective value of MaxDigestsIn at runtime or from the system documentation.",
      "ja": "MaxDigestsIn値は少なくとも2でなければなりません実装ごとのインターフェイスパラメータをMaxDigestsInすべきであるが、全体のプロトコルインスタンスに特定のかもしれません。実装は、オペレータが実行時またはバベルスピーカーの再起動によってMaxDigestsInの値を変更できるようにする必要があります。実装は、オペレータが、実行時またはシステムのマニュアルからMaxDigestsInの実効値を発見するために許容しなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.5. MaxDigestsOut",
      "section_title": true,
      "ja": "3.5.  MaxDigestsOut"
    },
    {
      "indent": 3,
      "text": "MaxDigestsOut is an unsigned integer parameter conceptually purposed for limiting the amount of a sent authenticated packet's space spent on authentication data. The sending procedure adds at most MaxDigestsOut (Section 5.3 item 5) HMAC results to a given packet.",
      "ja": "MaxDigestsOutは概念的に認証データに費やさ送られ、認証パケットのスペースの量を制限するための目的と符号なし整数パラメータです。送信の手順は、与えられたパケットに最もMaxDigestsOut（5.3節項目5）HMAC結果に追加されます。"
    },
    {
      "indent": 3,
      "text": "The MaxDigestsOut value MUST be at least 2. An implementation SHOULD make MaxDigestsOut a per-interface parameter but MAY make it specific to the whole protocol instance. An implementation SHOULD allow the operator to change the value of MaxDigestsOut at runtime or by means of a Babel speaker restart, in a safe range. The maximum safe value of MaxDigestsOut is implementation specific (see Section 6.2). An implementation MUST allow the operator to discover the effective value of MaxDigestsOut at runtime or from the system documentation.",
      "ja": "MaxDigestsOut値は、少なくとも2実装ごとのインターフェイスパラメータをMaxDigestsOutすべきであるが、全体のプロトコルインスタンスにそれが特定行うことができるなければなりません。実装は、オペレータが安全な範囲で、実行時またはバベルスピーカーの再起動によってMaxDigestsOutの値を変更できるようにする必要があります。 MaxDigestsOutの最大安全値は実装固有の（6.2節を参照）です。実装は、オペレータが、実行時またはシステムのマニュアルからMaxDigestsOutの実効値を発見するために許容しなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.6. ANM Table",
      "section_title": true,
      "ja": "3.6.  ANM表"
    },
    {
      "indent": 3,
      "text": "The ANM (Authentic Neighbours Memory) table resembles the neighbour table defined in Section 3.2.3 of [BABEL]. Note that the term \"neighbour table\" means the neighbour table of the original Babel specification, and the term \"ANM table\" means the table defined herein. Indexing of the ANM table is done in exactly the same way as indexing of the neighbour table, but its purpose, field set, and associated procedures are different.",
      "ja": "ANM（本物ネイバーメモリ）テーブルには、[BABEL]のセクション3.2.3で定義されたネイバーテーブルに似ています。用語「隣接テーブル」は、元のバベル仕様のネイバーテーブルを意味し、用語「ANMテーブル」は、本明細書に定義されたテーブルを意味することに留意されたいです。 ANMテーブルのインデックスは、ネイバーテーブルのインデックスとまったく同じように行われますが、その目的、フィールドセット、および関連する手順が異なりますされています。"
    },
    {
      "indent": 3,
      "text": "The conceptual purpose of the ANM table is to provide longer-term replay attack protection than would be possible using the neighbour table. Expiry of an inactive entry in the neighbour table depends on the last received Hello Interval of the neighbour and typically stands for tens to hundreds of seconds (see Appendixes A and B of [BABEL]). Expiry of an inactive entry in the ANM table depends only on the local speaker's configuration. The ANM table retains (for at least the amount of seconds set by the ANM timeout parameter as defined in Section 3.7) a copy of the TS/PC number advertised in authentic packets by each remote Babel speaker.",
      "ja": "ANMテーブルの概念目的は、ネイバーテーブルを使用して可能であるよりも長期リプレイ攻撃からの保護を提供することです。ネイバーテーブル内の非アクティブなエントリの有効期限は、最後に依存隣人のハロー間隔を受け、通常は（[BABEL]の付録AとBを参照）秒の数十〜数百の略です。 ANMテーブルの非アクティブなエントリの有効期限は、ローカルスピーカーの設定に依存します。 ANMテーブル（ANMタイムアウトパラメータで設定された秒の少なくとも量については、セクション3.7で定義されるように）各リモートバベルスピーカーによって本物のパケットでアドバタイズTS / PCの数のコピーを保持します。"
    },
    {
      "indent": 3,
      "text": "The ANM table is indexed by pairs of the form (Interface, Source). Every table entry consists of the following fields:",
      "ja": "ANMテーブルは、フォーム（インタフェース、ソース）の対により索引付けされます。すべてのテーブルのエントリには、以下のフィールドから構成されています。"
    },
    {
      "indent": 3,
      "text": "o Interface",
      "ja": "Oインタフェース"
    },
    {
      "indent": 6,
      "text": "An implementation-specific reference to the local node's interface through which the authentic packet was received.",
      "ja": "本物のパケットを受信したを通じてローカルノードのインタフェースに実装固有参照。"
    },
    {
      "indent": 3,
      "text": "o Source",
      "ja": "お そうｒせ"
    },
    {
      "indent": 6,
      "text": "The source address of the Babel speaker from which the authentic packet was received.",
      "ja": "本物のパケットを受信したバベルスピーカーの送信元アドレス。"
    },
    {
      "indent": 3,
      "text": "o LastTS",
      "ja": "O LastTS"
    },
    {
      "indent": 6,
      "text": "A 32-bit unsigned integer -- the TS part of a remote TS/PC number.",
      "ja": "32ビット符号なし整数 - リモートTS / PC番号のTSの一部。"
    },
    {
      "indent": 3,
      "text": "o LastPC",
      "ja": "LastPC上"
    },
    {
      "indent": 6,
      "text": "A 16-bit unsigned integer -- the PC part of a remote TS/PC number.",
      "ja": "16ビット符号なし整数 - リモートTS / PCの数のPC部分。"
    },
    {
      "indent": 3,
      "text": "Each ANM table entry has an associated aging timer, which is reset by the receiving procedure (Section 5.4 item 9). If the timer expires, the entry is deleted from the ANM table.",
      "ja": "各ANMテーブルエントリは、受信手順（セクション5.4項目9）によってリセットされた関連エージングタイマーを有しています。タイマーが期限切れになった場合、エントリはANMテーブルから削除されます。"
    },
    {
      "indent": 3,
      "text": "An implementation SHOULD use persistent memory (NVRAM) to retain the contents of the ANM table across restarts of the Babel speaker, but only as long as both the Interface field reference and expiry of the aging timer remain correct. An implementation MUST be clear regarding if and how persistent memory is used for the ANM table. An implementation SHOULD allow the operator to retrieve the current contents of the ANM table at runtime. An implementation SHOULD allow the operator to remove some or all ANM table entries at runtime or by means of a Babel speaker restart.",
      "ja": "実装は、バベルスピーカーの再起動を横切っANMテーブルの内容を保持する持続性メモリ（NVRAM）を使用する必要があり、のみ限りInterfaceフィールド参照エージングタイマーの満了の両方として正しいままです。実装があれば、どのように永続メモリANMテーブルのために使用さに関して明確でなければなりません。実装は、オペレータが、実行時にANMテーブルの現在の内容を取得できるようにする必要があります。実装は、オペレータが実行時またはバベルスピーカーの再起動によって、一部またはすべてANMテーブルエントリを削除できるようにする必要があります。"
    },
    {
      "indent": 0,
      "text": "3.7. ANM Timeout",
      "section_title": true,
      "ja": "3.7.  ANMタイムアウト"
    },
    {
      "indent": 3,
      "text": "ANM timeout is an unsigned integer parameter. An implementation SHOULD make ANM timeout a per-interface parameter but MAY make it specific to the whole protocol instance. ANM timeout is conceptually purposed for limiting the maximum age (in seconds) of entries in the ANM table that stand for inactive Babel speakers. The maximum age is immediately related to replay attack protection strength. The strongest protection is achieved with the maximum possible value of ANM timeout set, but it may not provide the best overall result for specific network segments and implementations of this mechanism.",
      "ja": "ANMのタイムアウトは、符号なし整数パラメータです。実装は、インターフェースごとのパラメータANMのタイムアウトをしなければならないが、全体のプロトコルインスタンスにそれが特定のかもしれません。 ANMのタイムアウトは、概念的には、非アクティブバベルのスピーカー用スタンドANMテーブルのエントリ（秒）の最大年齢を制限するために目的とされます。最大年齢は、直ちに攻撃防御力を再生することが関係しています。最も強力な保護はANMタイムアウトセットの可能な最大値で達成されるが、それは、特定のネットワークセグメントと、このメカニズムの実装のための最良の全体的な結果を提供しないかもしれません。"
    },
    {
      "indent": 3,
      "text": "Specifically, implementations unable to maintain the local TS/PC number strictly increasing across Babel speaker restarts will reuse the advertised TS/PC numbers after each restart (see Section 5.1). The neighbouring speakers will treat the new packets as replayed and discard them until the aging timer of the respective ANM table entry expires or the new TS/PC number exceeds the one stored in the entry.",
      "ja": "具体的には、厳密にバベルのスピーカー再起動しても増加ローカルTS / PCの数を維持することができないの実装は（セクション5.1を参照）、各再起動後に広告を出してTS / PC番号を再利用します。近隣のスピーカーが再生される新しいパケットを処理し、それぞれのANMテーブルエントリのエージングタイマーが期限切れになったり、新しいTS / PCの数は、エントリに格納されている1つを超えるまで、それらを破棄します。"
    },
    {
      "indent": 3,
      "text": "Another possible, but less probable, case could be an environment that uses IPv6 for the exchange of Babel datagrams and that involves physical moves of network-interface hardware between Babel speakers. Even when performed without restarting the speakers, these physical moves would cause random drops of the TS/PC number advertised for a given (Interface, Source) index, as viewed by neighbouring speakers, since IPv6 link-local addresses are typically derived from interface hardware addresses.",
      "ja": "別の可能な、あまり可能性、ケースは、バベルデータグラムの交換のためのIPv6を使用する環境であることができ、それは、バベルのスピーカーとの間のネットワークインタフェースハードウェアの物理的な移動を伴います。スピーカーを再起動せずに行った場合でも、IPv6リンクローカルアドレスは通常、インターフェース・ハードウェアから派生しているので、これらの物理的な動きは、近隣のスピーカーで見られるように、与えられた（インタフェース、出所）インデックスのために宣伝TS / PC番号のランダムドロップを引き起こしますアドレス。"
    },
    {
      "indent": 3,
      "text": "Assuming that in such cases the operators would prefer to use a lower ANM timeout value to let the entries expire on their own rather than having to manually remove them from the ANM table each time, an implementation SHOULD set the default value of ANM timeout to a value between 30 and 300 seconds.",
      "ja": "このような場合には、オペレータがエントリが自分で期限が切れるようにする下ANMタイムアウト値を使用することを好むと仮定するというより、手動ANMテーブルから毎回それらを削除する必要が、実装はにANMタイムアウトのデフォルト値を設定する必要があります30〜300秒の間の値。"
    },
    {
      "indent": 3,
      "text": "At the same time, network segments may exist with every Babel speaker having its advertised TS/PC number strictly increasing over the deployed lifetime. Assuming that in such cases the operators would prefer using a much higher ANM timeout value, an implementation SHOULD allow the operator to change the value of ANM timeout at runtime or by means of a Babel speaker restart. An implementation MUST allow the operator to discover the effective value of ANM timeout at runtime or from the system documentation.",
      "ja": "同時に、ネットワークセグメントは、すべてのバベルのスピーカーは、厳密に展開生涯にわたり増加し、その広告を出しTS / PC番号を持つ存在してもよいです。このような場合には、オペレータがはるかに高いANMのタイムアウト値を使用して好むと仮定すると、実装は、オペレータは、実行時またはバベルスピーカーの再起動によって、ANMのタイムアウトの値を変更できるようにする必要があります。実装は、オペレータが、実行時またはシステムのドキュメントからANMタイムアウトの実効値を発見するために許容しなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.8. Configured Security Associations",
      "section_title": true,
      "ja": "3.8. 設定されたセキュリティアソシエーション"
    },
    {
      "indent": 3,
      "text": "A Configured Security Association (CSA) is a data structure conceptually purposed for associating authentication keys and hash algorithms with Babel interfaces. All CSAs are managed in finite sequences, one sequence per interface (hereafter referred to as \"interface's sequence of CSAs\"). Each interface's sequence of CSAs, as an integral part of the Babel speaker configuration, MAY be intended for persistent storage as long as this conforms with the implementation's key-management policy. The default state of an interface's sequence of CSAs is empty, which has a special meaning of no authentication configured for the interface. The sending (Section 5.3 item 1) and the receiving (Section 5.4 item 1) procedures address this convention accordingly.",
      "ja": "設定されたセキュリティ協会（CSA）概念的バベルインタフェースと認証キーとハッシュアルゴリズムを関連付ける目的とデータ構造です。すべてのCSAは、インターフェイスごとに1つの配列が（以下、「のCSAのインターフェースの配列」と呼ばれる）、有限系列で管理されています。 CSAの各インターフェイスのシーケンスは、バベルのスピーカー構成の不可欠な部分として、限り、これは実装のキー管理ポリシーに準拠して永続的な記憶のために意図され得ます。 CSAのインタフェースのシーケンスのデフォルトの状態は、インターフェイスに設定され、認証なしの特別な意味を持っている、空です。送信（5.3節項目1）および受信（5.4項目1）手順は、それに応じてこの規則に対処します。"
    },
    {
      "indent": 3,
      "text": "A single CSA structure consists of the following fields:",
      "ja": "単一CSAの構造は、次のフィールドで構成されています。"
    },
    {
      "indent": 3,
      "text": "o HashAlgo",
      "ja": "O HashAlgo"
    },
    {
      "indent": 6,
      "text": "An implementation-specific reference to one of the hash algorithms supported by this implementation (see Section 2.1).",
      "ja": "この実装でサポートされているハッシュアルゴリズムの一つに実装固有の基準（セクション2.1を参照）。"
    },
    {
      "indent": 3,
      "text": "o KeyChain",
      "ja": "Oキーホルダー"
    },
    {
      "indent": 6,
      "text": "A finite sequence of elements (hereafter referred to as \"KeyChain sequence\") representing authentication keys, each element being a structure consisting of the following fields:",
      "ja": "認証キーを表す要素の有限のシーケンス（以下、「キーチェーン配列」と呼ぶ）、各要素は、以下のフィールドからなる構造です。"
    },
    {
      "indent": 6,
      "text": "* LocalKeyID",
      "ja": "* LocalKeyID"
    },
    {
      "indent": 9,
      "text": "An unsigned integer of an implementation-specific bit length.",
      "ja": "実装固有のビット長の符号なし整数。"
    },
    {
      "indent": 6,
      "text": "* AuthKeyOctets",
      "ja": "* AuthKeyOctets"
    },
    {
      "indent": 9,
      "text": "A sequence of octets of an arbitrary, known length to be used as the authentication key.",
      "ja": "認証キーとして使用される任意の、既知の長さのオクテットのシーケンス。"
    },
    {
      "indent": 6,
      "text": "* KeyStartAccept",
      "ja": "* KeyStartAccept"
    },
    {
      "indent": 9,
      "text": "The time that this Babel speaker will begin considering this authentication key for accepting packets with authentication data.",
      "ja": "このバベルのスピーカーは、認証データのパケットを受け入れるため、この認証キーを考慮し始めます時間。"
    },
    {
      "indent": 6,
      "text": "* KeyStartGenerate",
      "ja": "* KeyStartGenerate"
    },
    {
      "indent": 9,
      "text": "The time that this Babel speaker will begin considering this authentication key for generating packet authentication data.",
      "ja": "このバベルのスピーカーは、パケットの認証データを生成するため、この認証キーを考慮し始めます時間。"
    },
    {
      "indent": 6,
      "text": "* KeyStopGenerate",
      "ja": "* KeyStopGenerate"
    },
    {
      "indent": 9,
      "text": "The time that this Babel speaker will stop considering this authentication key for generating packet authentication data.",
      "ja": "このバベルのスピーカーは、パケットの認証データを生成するため、この認証キーを考慮停止する時間。"
    },
    {
      "indent": 6,
      "text": "* KeyStopAccept",
      "ja": "* KeyStopAccept"
    },
    {
      "indent": 9,
      "text": "The time that this Babel speaker will stop considering this authentication key for accepting packets with authentication data.",
      "ja": "このバベルのスピーカーは、認証データのパケットを受け入れるため、この認証キーを考慮停止する時間。"
    },
    {
      "indent": 3,
      "text": "Since there is no limit imposed on the number of CSAs per interface, but the number of HMAC computations per sent/received packet is limited (through MaxDigestsOut and MaxDigestsIn, respectively), it may appear that only a fraction of the associated keys and hash algorithms are used in the process. The ordering of elements within a sequence of CSAs and within a KeyChain sequence is important to make the association selection process deterministic and transparent. Once this ordering is deterministic at the Babel interface level, the intermediate data derived by the procedure defined in Section 5.2 will be deterministically ordered as well.",
      "ja": "そこインタフェース当たりのCSAの数に課される制限はありませんが、送信/受信パケット当たりHMAC計算の数は、（それぞれMaxDigestsOutとMaxDigestsIn、によって）制限され、それが関連するキーとハッシュアルゴリズムの一部のみが表示されることがあるのでプロセスで使用されています。 CSAのシーケンス内のキーチェーンシーケンス内の要素の順序は、関連選択プロセスは、決定論的かつ透明にすることが重要です。この順序はバベルのインターフェイスレベルで確定的になったら、5.2節で定義された手順により得られた中間データが決定論的にも注文することになります。"
    },
    {
      "indent": 3,
      "text": "An implementation SHOULD allow an operator to set any arbitrary order of elements within a given interface's sequence of CSAs and within the KeyChain sequence of a given CSA. Regardless of whether this requirement is or isn't met, the implementation MUST provide a means to discover the actual element order used. Whichever order is used by an implementation, it MUST be preserved across Babel speaker restarts.",
      "ja": "実装は、オペレータが所与のCSAのインターフェイスの配列内の、与えられたCSAのキーチェーン配列内の要素の任意の順序を設定することが可能にすべきです。かかわらず、この要件があるか、または満たされていないかどうかの、実装が実際に使用される要素の順序を発見する手段を提供しなければなりません。どちらの順序は実装によって使用され、それはバベルスピーカ再起動して保存されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Note that none of the CSA structure fields is constrained to contain unique values. Section 6.4 explains this in more detail. It is possible for the KeyChain sequence to be empty, although this is not the intended manner of using CSAs.",
      "ja": "CSA構造体のフィールドのいずれもユニークな値を含むように制約されていないことに注意してください。 6.4節は、これをより詳細に説明します。キーチェーンシーケンスが空であるために、これはのCSAを使用することの意図される様式ではないが、それは、可能です。"
    },
    {
      "indent": 3,
      "text": "The KeyChain sequence has a direct prototype, which is the \"key chain\" syntax item of some existing router configuration languages. If an implementation already implements this syntax item, it is suggested that the implementation reuse it, that is, implement a CSA syntax item that refers to a key chain item rather than reimplement the latter in full.",
      "ja": "キーホルダーシーケンスは、いくつかの既存のルータの設定言語の「キーチェーン」構文項目で直接プロトタイプを、持っています。実装は既に、この構文アイテムを実装する場合、それは実装がそれを再利用することが示唆されている、すなわち、キーチェーン項目を指すのではなく完全に後者を再実装CSA構文アイテムを実装します。"
    },
    {
      "indent": 0,
      "text": "3.9. Effective Security Associations",
      "section_title": true,
      "ja": "3.9. 効果的なセキュリティアソシエーション"
    },
    {
      "indent": 3,
      "text": "An Effective Security Association (ESA) is a data structure immediately used in sending (Section 5.3) and receiving (Section 5.4) procedures. Its conceptual purpose is to determine a runtime interface between those procedures and the deriving procedure defined in Section 5.2. All ESAs are temporary data units managed as elements of finite sequences that are not intended for persistent storage. Element ordering within each such finite sequence (hereafter referred to as \"sequence of ESAs\") MUST be preserved as long as the sequence exists.",
      "ja": "効果的なセキュリティ協会（ESA）のすぐ（5.4節）の手順（5.3節）を送信および受信に使用されるデータ構造です。その概念の目的は、セクション5.2で定義された手順と導出手順の間のランタイム・インターフェースを決定することです。すべてのESAは、永続的な記憶のために意図されていない有限のシーケンスの要素として管理一時的なデータ単位です。各そのような有限のシーケンス内順序付け要素があれば、シーケンスが存在するように保存されなければならない（以下、「のESAの配列」と呼ばれます）。"
    },
    {
      "indent": 3,
      "text": "A single ESA structure consists of the following fields:",
      "ja": "単一ESAの構造は、次のフィールドで構成されています。"
    },
    {
      "indent": 3,
      "text": "o HashAlgo",
      "ja": "O HashAlgo"
    },
    {
      "indent": 6,
      "text": "An implementation-specific reference to one of the hash algorithms supported by this implementation (see Section 2.1).",
      "ja": "この実装でサポートされているハッシュアルゴリズムの一つに実装固有の基準（セクション2.1を参照）。"
    },
    {
      "indent": 3,
      "text": "o KeyID",
      "ja": "O鍵ID"
    },
    {
      "indent": 6,
      "text": "A 16-bit unsigned integer.",
      "ja": "16ビット符号なし整数。"
    },
    {
      "indent": 3,
      "text": "o AuthKeyOctets",
      "ja": "AuthKeyOctets O"
    },
    {
      "indent": 6,
      "text": "A sequence of octets of an arbitrary, known length to be used as the authentication key.",
      "ja": "認証キーとして使用される任意の、既知の長さのオクテットのシーケンス。"
    },
    {
      "indent": 3,
      "text": "Note that among the protocol data structures introduced by this mechanism, the ESA structure is the only one not directly interfaced with the system operator (see Figure 1 in Appendix A); it is not immediately present in the protocol encoding, either. However, the ESA structure is not just a possible implementation technique but an integral part of this specification: the deriving (Section 5.2), the sending (Section 5.3), and the receiving (Section 5.4) procedures are defined in terms of the ESA structure and its semantics provided herein. The ESA structure is as meaningful for a correct implementation as the other protocol data structures.",
      "ja": "（付録Aで図1を参照）は、この機構によって導入されたプロトコル・データ構造のうち、ESA構造を直接システムオペレータとインターフェースしない唯一のものであることに留意されたいです。それはどちらか、プロトコル・エンコーディングで直ちに存在しません。しかし、ESAの構造は、単に可能な実装技術が、本明細書の不可欠な部分ではない。導出（セクション5.2）、送信（セクション5.3）、および受信（5.4）の手順は、ESAの構造的に定義されていますそしてその意味は、本明細書に提供します。 ESA構造は、他のプロトコルのデータ構造として正しい実装用として意味があります。"
    },
    {
      "indent": 0,
      "text": "4. Updates to Protocol Encoding",
      "section_title": true,
      "ja": "プロトコルエンコーディング4.アップデート"
    },
    {
      "indent": 0,
      "text": "4.1. Justification",
      "section_title": true,
      "ja": "4.1. 正当化"
    },
    {
      "indent": 3,
      "text": "The choice of encoding is very important in the long term. The protocol encoding limits various authentication mechanism designs and encodings, which in turn limit future developments of the protocol.",
      "ja": "エンコードの選択は、長期的には非常に重要です。プロトコル符号化は、順番に、プロトコルの将来の発展を制限する様々な認証メカニズムの設計およびエンコーディングを、制限します。"
    },
    {
      "indent": 3,
      "text": "Considering existing implementations of the Babel protocol instance itself and related modules of packet analysers, the current encoding of Babel allows for compact and robust decoders. At the same time, this encoding allows for future extensions of Babel by three (not excluding each other) principal means as defined in Sections 4.2 and 4.3 of [BABEL] and further discussed in [BABEL-EXTENSION]:",
      "ja": "バベルプロトコルインスタンス自体とパケットアナライザの関連モジュールの既存の実装を考慮すると、バベルの現在の符号化は、コンパクトかつ堅牢なデコーダを可能にします。同時に、この符号化三（互いを排除しない）プリンシパルによってバベルの将来の拡張を可能にすることはセクション4.2および[BABEL] 4.3で定義され、さらに[BABEL-EXTENSION]で議論するように意味します。"
    },
    {
      "indent": 3,
      "text": "a. A Babel packet consists of a four-octet header followed by a packet body, that is, a sequence of TLVs (see Figure 2 in Appendix A). Besides the header and the body, an actual Babel",
      "ja": "A。バベルパケットは、のTLV（付録Aで図2を参照）の配列であるパケット本体に続く4オクテットのヘッダから成ります。ヘッダとボディ、実際のバベル以外"
    },
    {
      "indent": 7,
      "text": "datagram may have an arbitrary amount of trailing data between\nthe end of the packet body and the end of the datagram.  An\ninstance of the original protocol silently ignores such trailing\ndata.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "b. The packet body uses a binary format allowing for 256 TLV types and imposing no requirements on TLV ordering or number of TLVs of a given type in a packet. [BABEL] allocates TLV types 0 through 10 (see Table 1 in Appendix A), defines the TLV body structure for each, and establishes the requirement for a Babel protocol instance to ignore any unknown TLV types silently. This makes it possible to examine a packet body (to validate the framing and/or to pick particular TLVs for further processing), taking into account only the type (to distinguish between a Pad1 TLV and any other TLV) and the length of each TLV, regardless of whether any additional TLV types are eventually deployed (and if so, how many).",
      "ja": "B。パケット本体は256のTLVタイプを可能にし、パケットにTLVの順序または特定のタイプのTLVの数には要件を課すことないバイナリ形式を使用しています。 [BABEL] TLVタイプ10を介して0を割り当てるには、（付録Aの表1参照）、それぞれについてTLV体構造を定義し、静かに未知のTLVのタイプを無視するバベルプロトコルインスタンスの要件を確立します。これは、アカウントにのみタイプ（パッド1 TLV及び他のTLVを区別する）と、各TLVの長さを取る、（フレーミングを検証するために、および/またはさらなる処理のために特定のTLVを選択する）、パケット本体を検査することができます関係なく、任意の追加のTLVタイプが最終的に展開されているかどうかの（もしそうなら、どのように多くの）。"
    },
    {
      "indent": 3,
      "text": "c. Within each TLV of the packet body, there may be some extra data after the expected length of the TLV body. An instance of the original protocol silently ignores any such extra data. Note that any TLV types without the expected length defined (such as the PadN TLV) cannot be extended with the extra data.",
      "ja": "C。パケットボディの各TLV内、TLV体の予想される長さの後に、いくつかの余分なデータがあってもよいです。元のプロトコルのインスタンスは静かにそのような余分なデータを無視します。 （例えばパッドN TLVとして）定義された予想長せず、任意のTLVタイプは余分なデータで拡張することができないことに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "Considering each of these three principal extension means for the specific purpose of adding authentication data items to each protocol packet, the following arguments can be made:",
      "ja": "これら三つの主要な拡張のそれぞれを考慮すると、各プロトコルパケットに認証データ項目を追加する特定の目的のために、次の引数を行うことができることを意味します。"
    },
    {
      "indent": 3,
      "text": "o The use of the TLV extra data of some existing TLV type would not be a solution, since no particular TLV type is guaranteed to be present in a Babel packet.",
      "ja": "特にTLVタイプがバベルパケットの中に存在することが保証されないので、いくつかの既存のTLVタイプのTLV余分なデータの利用O、溶液ではないであろう。"
    },
    {
      "indent": 3,
      "text": "o The use of the TLV extra data could also conflict with future developments of the protocol encoding.",
      "ja": "O TLV余分なデータの使用はまた、プロトコルのエンコーディングの今後の展開と競合する可能性があります。"
    },
    {
      "indent": 3,
      "text": "o Since the packet trailing data is currently unstructured, using it would involve defining an encoding structure and associated procedures; this would add to the complexity of both specification and implementation and would increase exposure to protocol attacks such as fuzzing.",
      "ja": "Oパケット末尾データは、現在、それは符号化構造および関連する手順を定義伴うだろう使用して、構造化されていないからです。これは、仕様と実装の両方の複雑さに追加すると、このようなファジングなどのプロトコル攻撃への露出を増加するであろう。"
    },
    {
      "indent": 3,
      "text": "o A naive use of the packet trailing data would make it unavailable to any future extension of Babel. Since this mechanism is possibly not the last extension and since some other extensions may allow no other embedding means except the packet trailing data, the defined encoding structure would have to enable the multiplexing of data items belonging to different extensions. Such a definition is out of the scope of this work.",
      "ja": "Oパケット末尾のデータの素朴な使用はバベルの任意の将来の拡張にそれが使用できなくなるだろう。このメカニズムは、おそらく最後の拡張ではなく、いくつかの他の拡張機能ので、データを後続のパケットを除く他の埋め込み手段を可能にしないかもしれないので、定義された符号化構造は、異なる拡張子に属するデータの多重化を可能にしなければなりません。このような定義は、この作業の範囲外です。"
    },
    {
      "indent": 3,
      "text": "o Deprecating an extension (or only its protocol encoding) that uses purely purpose-allocated TLVs is as simple as deprecating the TLVs.",
      "ja": "O純粋目的割り当てのTLVは、TLVを廃止するだけで簡単に使用する拡張（または唯一のプロトコル符号化）を廃止。"
    },
    {
      "indent": 3,
      "text": "o The use of purpose-allocated TLVs is transparent for both the original protocol and any its future extensions, regardless of the embedding technique(s) used by the latter.",
      "ja": "O目的割り当てのTLVの使用にかかわらず、後者で使用される埋め込み技術（単数または複数）の、元のプロトコルと任意の将来の拡張の両方に対して透明です。"
    },
    {
      "indent": 3,
      "text": "Considering all of the above, this mechanism uses neither the packet trailing data nor the TLV extra data but uses two new TLV types: type 11 for a TS/PC number and type 12 for an HMAC result (see Table 1 in Appendix A).",
      "ja": "（付録Aの表1を参照）HMAC結果のためにTS / PC番号のタイプ11とタイプ12：上記のすべてを考慮すると、このメカニズムは、データを後続のパケットもTLV余分なデータも使用しないが、2つの新しいTLVタイプを使用しています。"
    },
    {
      "indent": 0,
      "text": "4.2. TS/PC TLV",
      "section_title": true,
      "ja": "4.2.  TS / PC TLV"
    },
    {
      "indent": 3,
      "text": "The purpose of a TS/PC TLV is to store a single TS/PC number. There is exactly one TS/PC TLV in an authenticated Babel packet.",
      "ja": "TS / PC TLVの目的は、単一のTS / PC番号を格納することです。正確に一つのTS / PC TLVは、認証されたバベルのパケットです。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Type = 11   |     Length    |         PacketCounter         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                           Timestamp                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Fields:",
      "ja": "フィールド："
    },
    {
      "indent": 3,
      "text": "Type Set to 11 to indicate a TS/PC TLV.",
      "ja": "タイプは、TS / PC TLVを示すために11に設定します。"
    },
    {
      "indent": 3,
      "text": "Length The length, in octets, of the body, exclusive of the Type and Length fields.",
      "ja": "長さタイプと長さフィールドの排他的な身体のオクテットの長さ、、、。"
    },
    {
      "indent": 3,
      "text": "PacketCounter A 16-bit unsigned integer in network byte order -- the PC part of a TS/PC number stored in this TLV.",
      "ja": "PacketCounter 16ビット符号なし整数ネットワークバイト順に - このTLVに格納されたTS / PCの数のPC部分。"
    },
    {
      "indent": 3,
      "text": "Timestamp A 32-bit unsigned integer in network byte order -- the TS part of a TS/PC number stored in this TLV.",
      "ja": "タイムスタンプネットワークバイト順に32ビット符号なし整数 - このTLVに格納されたTS / PC番号のTSの一部。"
    },
    {
      "indent": 3,
      "text": "Note that the ordering of PacketCounter and Timestamp in the TLV structure is the opposite of the ordering of TS and PC in the TS/PC number and the 48-bit equivalent (see Section 2.3).",
      "ja": "TLV構造でPacketCounterとタイムスタンプの順序がTSの順序とPC TS / PCの数は、48ビット相当の反対であることに注意してください（2.3節を参照してください）。"
    },
    {
      "indent": 3,
      "text": "Considering the expected length and the extra data as mentioned in Section 4.3 of [BABEL], the expected length of a TS/PC TLV body is unambiguously defined as 6 octets. The receiving procedure would correctly process any TS/PC TLV with body length not less than the expected length, ignoring any extra data (Section 5.4 items 3 and 9).",
      "ja": "[BABEL]のセクション4.3で述べたように、予想される長さと余分なデータを考慮すると、TS / PC TLV体の予想される長さを一義的6つのオクテットとして定義されます。受信手順が正常に余分なデータ（5.4節項目3と9）を無視して、予想される長さよりも小さくない体の長さを持つ任意のTS / PC TLVを処理します。"
    },
    {
      "indent": 3,
      "text": "The sending procedure produces a TS/PC TLV with body length equal to the expected length and the Length field, respectively, set as described in Section 5.3 item 3.",
      "ja": "送信手順は、第5.3節項目3に記載のように設定され、それぞれ、予想される長さと長さフィールドに等しい体長とTS / PC TLVを生成します。"
    },
    {
      "indent": 3,
      "text": "Future Babel extensions (such as sub-TLVs) MAY modify the sending procedure to include the extra data after the fixed-size TS/PC TLV body defined herein, making adjustments to the Length TLV field, the \"Body length\" packet header field, and output buffer management (as explained in Section 6.2) necessary.",
      "ja": "（例えば、サブTLVのような）未来のバベル拡張は、長TLVフィールドの調整を行う、本明細書で定義される固定サイズTS / PC TLV体後、余分なデータを含むように「身体長さ」パケットヘッダフィールドの送信手順を変更することができます出力バッファ管理（セクション6.2で説明したように）必要。"
    },
    {
      "indent": 0,
      "text": "4.3. HMAC TLV",
      "section_title": true,
      "ja": "4.3.  HMAC TLV"
    },
    {
      "indent": 3,
      "text": "The purpose of an HMAC TLV is to store a single HMAC result. To assist a receiver in reproducing the HMAC computation, LocalKeyID modulo 2^16 of the authentication key is also provided in the TLV. There is at least one HMAC TLV in an authenticated Babel packet.",
      "ja": "HMAC TLVの目的は、単一のHMAC結果を格納することです。 HMAC計算の再生中に受信機を支援するために、認証キーのLocalKeyIDモジュロ2 ^ 16はまた、TLVに設けられています。少なくとも一つのHMAC TLVは、認証されたバベルのパケットです。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Type = 12   |    Length     |             KeyID             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Digest...\n+-+-+-+-+-+-+-+-+-+-+-+-",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Fields:",
      "ja": "フィールド："
    },
    {
      "indent": 3,
      "text": "Type Set to 12 to indicate an HMAC TLV.",
      "ja": "タイプは、HMAC TLVを示すために12に設定します。"
    },
    {
      "indent": 3,
      "text": "Length The length, in octets, of the body, exclusive of the Type and Length fields.",
      "ja": "長さタイプと長さフィールドの排他的な身体のオクテットの長さ、、、。"
    },
    {
      "indent": 3,
      "text": "KeyID A 16-bit unsigned integer in network byte order.",
      "ja": "ネットワークバイト順に16ビットの符号なし整数をKEYID。"
    },
    {
      "indent": 3,
      "text": "Digest A variable-length sequence of octets that is at least 16 octets long (see Section 2.2).",
      "ja": "少なくとも16オクテット長であるオクテットの可変長配列を消化（セクション2.2を参照）。"
    },
    {
      "indent": 3,
      "text": "Considering the expected length and the extra data as mentioned in Section 4.3 of [BABEL], the expected length of an HMAC TLV body is not defined. The receiving and padding procedures process every octet of the Digest field, deriving the field boundary from the Length field value (Section 5.4 item 7 and Section 2.2, respectively). The sending procedure produces HMAC TLVs with the Length field precisely sizing the Digest field to match the digest length of the hash algorithm used (Section 5.3 items 5 and 8).",
      "ja": "[BABEL]のセクション4.3で述べたように、予想される長さと余分なデータを考慮すると、HMAC TLV体の予想される長さが定義されていません。受信及びパディングの手順は、長さフィールドの値（それぞれ、5.4項目7と2.2節）からフィールド境界を導出する、ダイジェストフィールドのすべてのオクテットを処理します。送信手順は、Lengthフィールドを正確に使用されるハッシュアルゴリズムのダイジェストの長さと一致するダイジェストフィールドサイズ（5.3節項目5および8）とHMAC TLVを生成します。"
    },
    {
      "indent": 3,
      "text": "The HMAC TLV structure defined herein is final. Future Babel extensions MUST NOT extend it with any extra data.",
      "ja": "本明細書で定義されるHMAC TLV構造が最終。将来のバベルの拡張子は、余分なデータとそれを拡張してはなりません。"
    },
    {
      "indent": 0,
      "text": "5. Updates to Protocol Operation",
      "section_title": true,
      "ja": "プロトコル動作5.アップデート"
    },
    {
      "indent": 0,
      "text": "5.1. Per-Interface TS/PC Number Updates",
      "section_title": true,
      "ja": "5.1. インターフェースごとのTS / PC数を更新"
    },
    {
      "indent": 3,
      "text": "The LocalTS and LocalPC interface-specific variables constitute the TS/PC number of a Babel interface. This number is advertised in the TS/PC TLV of authenticated Babel packets sent from that interface. There is only one property that is mandatory for the advertised TS/PC number: its 48-bit equivalent (see Section 2.3) MUST be strictly increasing within the scope of a given interface of a Babel speaker as long as the protocol instance is continuously operating. This property, combined with ANM tables of neighbouring Babel speakers, provides them with the most basic replay attack protection.",
      "ja": "LocalTSとLocalPCインターフェイス固有の変数は、バベルインターフェースのTS / PC番号を構成します。この番号は、そのインターフェイスから送信され、認証さバベルパケットのTS / PC TLVでアドバタイズされます。アドバタイズされたTS / PCの数のために必須であり、一つの特性のみがある：その48ビット相当（セクション2.3を参照）プロトコルインスタンスが連続的に動作している限り、バベルスピーカーの所定のインターフェイスの範囲内で増加する厳密でなければなりません。隣接バベルスピーカーのANMテーブルと組み合わせて、このプロパティは、最も基本的なリプレイ攻撃からの保護とそれらを提供します。"
    },
    {
      "indent": 3,
      "text": "Initialization and increment are two principal updates performed on an interface TS/PC number. The initialization is performed when a new interface becomes a part of a Babel protocol instance. The increment is performed by the sending procedure (Section 5.3 item 2) before advertising the TS/PC number in a TS/PC TLV.",
      "ja": "初期化と増分はインタフェースTS / PCの数に実施された2つの主要なアップデートです。新しいインターフェイスはバベルプロトコルインスタンスの一部になったときに初期化が行われます。増分はTS / PC TLVにおけるTS / PC番号を公示する前に送信する手順（5.3節項目2）によって行われます。"
    },
    {
      "indent": 3,
      "text": "Depending on the particular implementation method of these two updates, the advertised TS/PC number may possess additional properties that improve the replay attack protection strength. This includes, but is not limited to, the methods below.",
      "ja": "これらの2回の更新の特定の実装方法に応じて、広告を出してTS / PCの数は、リプレイ攻撃に対する防御力を向上させる追加のプロパティを有することができます。これには、以下の方法に限定されるものではありません。"
    },
    {
      "indent": 3,
      "text": "a. The most straightforward implementation would use LocalTS as a plain wrap counter, defining the updates as follows:",
      "ja": "A。最も簡単な実装では、次のように更新を定義し、プレーンなラップカウンタとしてLocalTSを使用します。"
    },
    {
      "indent": 7,
      "text": "initialization Set LocalPC to 0, and set LocalTS to 0.",
      "ja": "初期設定は0にLocalPCを設定し、0にLocalTSを設定します。"
    },
    {
      "indent": 7,
      "text": "increment Increment LocalPC by 1. If LocalPC wraps (0xFFFF + 1 = 0x0000), increment LocalTS by 1.",
      "ja": "LocalPCを1（0xFFFFの+ 1 = 0000）、インクリメントLocalTSをラップする場合1だけインクリメントLocalPCをインクリメントします。"
    },
    {
      "indent": 7,
      "text": "In this case, the advertised TS/PC numbers would be reused after each Babel protocol instance restart, making neighbouring speakers reject authenticated packets until the respective ANM table entries expire or the new TS/PC number exceeds the old (see Sections 3.6 and 3.7).",
      "ja": "この場合、広告を出してTS / PC番号は（セクション3.6と3.7を参照）、それぞれのANMテーブルのエントリが期限切れか、新しいTS / PCの数が古いを超えるまで、隣接するスピーカーは、認証済みパケットを拒否すること、各バベルプロトコルインスタンスの再起動後に再利用されるだろう。"
    },
    {
      "indent": 3,
      "text": "b. A more advanced implementation could make use of any 32-bit unsigned integer timestamp (number of time units since an arbitrary epoch), such as the UNIX timestamp, if the timestamp itself spans a reasonable time range and is guaranteed against a decrease (such as one resulting from network time use). The updates would be defined as follows:",
      "ja": "B。タイムスタンプ自体が妥当な時間範囲に及ぶと（例えば、減少に対して保証されている場合は、より高度な実装では、そのようなUNIXタイムスタンプとして、（任意のエポックからの時間単位の数）は、任意の32ビット符号なし整数のタイムスタンプを使用することができネットワーク時間の使用から生じた1）。次のようにアップデートが定義されます："
    },
    {
      "indent": 7,
      "text": "initialization Set LocalPC to 0, and set LocalTS to 0.",
      "ja": "初期設定は0にLocalPCを設定し、0にLocalTSを設定します。"
    },
    {
      "indent": 7,
      "text": "increment If the current timestamp is greater than LocalTS, set LocalTS to the current timestamp and LocalPC to 0, then consider the update complete. Otherwise, increment LocalPC by 1, and if LocalPC wraps, increment LocalTS by 1.",
      "ja": "インクリメント現在のタイムスタンプがLocalTSよりも大きい場合は、アップデートが完了検討し、その後、0に現在のタイムスタンプとLocalPCにLocalTSを設定します。それ以外の場合は、1でLocalPCをインクリメントし、LocalPCは1で、インクリメントLocalTSをラップしている場合。"
    },
    {
      "indent": 7,
      "text": "In this case, the advertised TS/PC number would remain unique across the speaker's deployed lifetime without the need for any persistent storage. However, a suitable timestamp source is not available in every implementation case.",
      "ja": "この場合、広告を出してTS / PCの数は、任意の永続ストレージを必要とせずに、話し手の展開生涯にわたって一意残ります。しかしながら、適切なタイムスタンプのソースでは、すべての実装の場合には使用できません。"
    },
    {
      "indent": 3,
      "text": "c. Another advanced implementation could use LocalTS in a way similar to the \"wrap/boot count\" suggested in Section 4.1 of [OSPF3-AUTH-BIS], defining the updates as follows:",
      "ja": "C。別の高度な実装は、次のように更新を定義し、[OSPF3-AUTH-BIS]の4.1節で提案「ラップ/ブート・カウント」と同様にLocalTSを使用することができます。"
    },
    {
      "indent": 7,
      "text": "initialization  Set LocalPC to 0.  If there is a TS value stored\n                in NVRAM for the current interface, set LocalTS\n                to the stored TS value, then increment the stored\n                TS value by 1.  Otherwise, set LocalTS to 0, and\n                set the stored TS value to 1.",
      "raw": true
    },
    {
      "indent": 7,
      "text": "increment Increment LocalPC by 1. If LocalPC wraps, set LocalTS to the TS value stored in NVRAM for the current interface, then increment the stored TS value by 1.",
      "ja": "LocalPCラップ場合1だけインクリメントLocalPCをインクリメントし、現在のインターフェイスのためのNVRAMに格納されたTS値にLocalTSを設定し、次に1によって記憶されたTS値をインクリメント。"
    },
    {
      "indent": 7,
      "text": "In this case, the advertised TS/PC number would also remain unique across the speaker's deployed lifetime, relying on NVRAM for storing multiple TS numbers, one per interface.",
      "ja": "この場合、広告を出してTS / PCの数は、複数のTS番号、インターフェイスごとに1つを格納するためにNVRAMに頼って、話し手の展開生涯にわたって一意残ります。"
    },
    {
      "indent": 3,
      "text": "As long as the TS/PC number retains its mandatory property stated above, it is up to the implementor to determine which methods of TS/ PC number updates are available and whether the operator can configure the method per interface and/or at runtime. However, an implementation MUST disclose the essence of each update method it includes, in a comprehensible form such as natural language description, pseudocode, or source code. An implementation MUST allow the operator to discover which update method is effective for any given interface, either at runtime or from the system documentation. These requirements are necessary to enable the optimal (see Section 3.7) management of ANM timeout in a network segment.",
      "ja": "TS / PCの数は上述の必須の特性を保持する限り、それは決定するために実装次第これはTS / PC番号の更新の方法が利用可能であり、オペレータおよび/または実行時インタフェース当たり方式を設定できるかどうか。しかし、実装は、そのような自然言語記述、擬似コード、またはソースコードとして理解できる形で、含む各更新方法の本質を開示しなければなりません。実装は、オペレータがランタイム時またはシステムのマニュアルのいずれかから、任意のインターフェイスのために有効である更新方法を発見することを可能にしなければなりません。これらの要件は、ネットワークセグメントに最適な（セクション3.7を参照）ANMタイムアウトの管理を可能にするのに必要です。"
    },
    {
      "indent": 3,
      "text": "Note that wrapping (0xFFFFFFFF + 1 = 0x00000000) of LastTS is unlikely, but possible, causing the advertised TS/PC number to be reused. Resolving this situation requires replacing all authentication keys of the involved interface. In addition to that, if the wrap was caused by a timestamp reaching its end of epoch, using this mechanism will be impossible for the involved interface until some different timestamp or update implementation method is used.",
      "ja": "LastTSのラッピング（0xFFFFFFFFの+ 1 = 0x00000000の）を再利用することにアドバタイズTS / PC番号を引き起こす可能性は低いが、可能であることに注意してください。この状況を解決することは、関係インターフェースのすべての認証キーを交換する必要があります。ラップは、エポックの終わりに到達するタイムスタンプによって引き起こされた場合、いくつかの異なるタイムスタンプまたは更新の実装方法が使用されるまで、それに加えて、このメカニズムを使用して関与インタフェースは不可能であろう。"
    },
    {
      "indent": 0,
      "text": "5.2. Deriving ESAs from CSAs",
      "section_title": true,
      "ja": "5.2.  CSAからのESAの導出"
    },
    {
      "indent": 3,
      "text": "Neither receiving nor sending procedures work with the contents of an interface's sequence of CSAs directly; both (Section 5.4 item 4 and Section 5.3 item 4, respectively) derive a sequence of ESAs from the sequence of CSAs and use the derived sequence (see Figure 1 in Appendix A). There are two main goals achieved through this indirection:",
      "ja": "どちらも受信も送信する手順は、直接のCSAのインタフェースのシーケンスの内容で動作します。両方（5.4アイテム4とそれぞれ5.3節項目4は、）のCSAの配列からのESAのシーケンスを導出し（付録Aで図1を参照）由来の配列を使用します。この間接を通じて達成二つの主な目標があります。"
    },
    {
      "indent": 3,
      "text": "o Elimination of expired authentication keys and deduplication of security associations. This is done as early as possible to keep subsequent procedures focused on their respective tasks.",
      "ja": "期限切れの認証キーおよびセキュリティアソシエーションの重複排除のOの除去。これは、それぞれのタスクに焦点を当て、その後の手続きを維持するために可能な限り早期に行われます。"
    },
    {
      "indent": 3,
      "text": "o Maintenance of particular ordering within the derived sequence of ESAs. The ordering deterministically depends on the ordering within the interface's sequence of CSAs and the ordering within the KeyChain sequence of each CSA. The particular correlation maintained by this procedure implements a concept of fair (independent of the number of keys contained by each) competition between CSAs.",
      "ja": "OのESAの誘導された配列内の特定の順序のメンテナンス。順序は決定論のCSAのインターフェースの配列内に発注し、各CSAのキーチェーンシーケンス内の順序に依存します。この手順によって維持特定の相関関係は、のCSA間の公正（それぞれに含まれるキーの数とは無関係に）競合の概念を実装します。"
    },
    {
      "indent": 3,
      "text": "The deriving procedure uses the following input arguments:",
      "ja": "導出手順は、次の入力引数を使用しています。"
    },
    {
      "indent": 3,
      "text": "o input sequence of CSAs",
      "ja": "CSAのO入力シーケンス"
    },
    {
      "indent": 3,
      "text": "o direction (sending or receiving)",
      "ja": "O方向（送信または受信）"
    },
    {
      "indent": 3,
      "text": "o current time (CT)",
      "ja": "O現在の時刻（CT）"
    },
    {
      "indent": 3,
      "text": "The processing of input arguments begins with an empty output sequence of ESAs and consists of the following steps:",
      "ja": "入力引数の処理のESAの空の出力シーケンスで始まり、以下のステップから成ります。"
    },
    {
      "indent": 3,
      "text": "1. Make a temporary copy of the input sequence of CSAs.",
      "section_title": true,
      "ja": "1.のCSAの入力シーケンスの一時的なコピーを作成します。"
    },
    {
      "indent": 3,
      "text": "2. Remove all expired authentication keys from each KeyChain sequence of the copy, that is, any keys such that:",
      "ja": "2.任意のキーように、つまり、コピーの各キーチェーンシーケンスからすべての期限切れの認証キーを削除します。"
    },
    {
      "indent": 7,
      "text": "*  for receiving: KeyStartAccept is greater than CT or\n   KeyStopAccept is less than CT",
      "raw": true
    },
    {
      "indent": 7,
      "text": "* for sending: KeyStartGenerate is greater than CT or KeyStopGenerate is less than CT",
      "ja": "*送信する：KeyStartGenerateはCTよりも大きいかKeyStopGenerateはCTよりも小さいです"
    },
    {
      "indent": 7,
      "text": "Note well that there are no special exceptions. Remove all expired keys, even if there are no keys left after that (see Section 7.4).",
      "ja": "特別な例外が存在しないことを十分に注意してください。その後残されたキーが存在しない場合でも、期限切れのすべてのキーを削除（7.4節を参照してください）。"
    },
    {
      "indent": 3,
      "text": "3. Use the copy to populate the output sequence of ESAs as follows:",
      "section_title": true,
      "ja": "3.次のようにのESAの出力シーケンスを移入するためにコピーを使用します。"
    },
    {
      "indent": 7,
      "text": "3.1.  When the KeyChain sequence of the first CSA contains at\n      least one key, use its first key to produce an ESA with\n      fields set as follows:",
      "raw": true
    },
    {
      "indent": 13,
      "text": "HashAlgo Set to HashAlgo of the current CSA.",
      "ja": "HashAlgoは、現在のCSAのHashAlgoに設定してください。"
    },
    {
      "indent": 13,
      "text": "KeyID Set to LocalKeyID modulo 2^16 of the current key of the current CSA.",
      "ja": "現在のCSAの現在のキーのLocalKeyIDモジュロ2 ^ 16に設定しますKEYID。"
    },
    {
      "indent": 13,
      "text": "AuthKeyOctets Set to AuthKeyOctets of the current key of the current CSA.",
      "ja": "現在のCSAの現在のキーのAuthKeyOctetsに設定AuthKeyOctets。"
    },
    {
      "indent": 13,
      "text": "Append this ESA to the end of the output sequence.",
      "ja": "出力シーケンスの最後に、このESAを追加します。"
    },
    {
      "indent": 7,
      "text": "3.2. When the KeyChain sequence of the second CSA contains at least one key, use its first key the same way, and so forth until all first keys of the copy are processed.",
      "ja": "3.2. 二CSAのキーチェーンシーケンスは少なくとも1つのキーが含まれている場合は、その最初のキーと同じ方法を使用して、などのコピーのすべての最初のキーが処理されるまで。"
    },
    {
      "indent": 7,
      "text": "3.3. When the KeyChain sequence of the first CSA contains at least two keys, use its second key the same way.",
      "ja": "3.3. 最初のCSAのキーチェーンシーケンスは、少なくとも2つのキーを含んでいる場合、その2番目のキーと同じ方法を使用しています。"
    },
    {
      "indent": 7,
      "text": "3.4. When the KeyChain sequence of the second CSA contains at least two keys, use its second key the same way, and so forth until all second keys of the copy are processed.",
      "ja": "3.4. 二CSAのキーチェーンシーケンスは、少なくとも2つのキーを含む場合はコピーの全ての第2のキーが処理されるまで、等々その2番目のキーと同じ方法を使用し、そして。"
    },
    {
      "indent": 7,
      "text": "3.5. ...and so forth, until all keys of all CSAs of the copy are processed, exactly once each.",
      "ja": "3.5.  ...など、コピーのすべてのCSAのすべてのキーが処理されるまで、正確に一度各。"
    },
    {
      "indent": 7,
      "text": "In the description above, the ordinals (\"first\", \"second\", and so on) with regard to keys stand for an element position after the removal of expired keys, not before. For example, if a KeyChain sequence was { Ka, Kb, Kc, Kd } before the removal and became { Ka, Kd } after, then Ka would be the \"first\" element and Kd would be the \"second\".",
      "ja": "上記の説明では、序数（「第1」、「第2」など）キーに関してない前に期限切れのキーを除去した後の素子の位置を表します。キーチェーン配列は除去前{カ、KB、Kcを、Kdを}であり、後{のKa、Kdは}となった場合、例えば、その後のKaは、「最初の」要素であろうとKdは「秒」であろう。"
    },
    {
      "indent": 3,
      "text": "4. Deduplicate the ESAs in the output sequence; that is, wherever two or more ESAs exist that share the same (HashAlgo, KeyID, AuthKeyOctets) triplet value, remove all of these ESAs except the one closest to the beginning of the sequence.",
      "ja": "前記出力シーケンス内のESAを重複排除。二つ以上のESAが同じ（HashAlgo、KeyIDを、AuthKeyOctets）トリプレット値をその共有存在どこ即ち、配列の先頭に最も近いものを除き、これらのESAをすべて削除。"
    },
    {
      "indent": 3,
      "text": "The resulting sequence will contain zero or more unique ESAs, ordered in a way deterministically correlated with the ordering of CSAs within the original input sequence of CSAs and the ordering of keys within each KeyChain sequence. This ordering maximizes the probability of having an equal amount of keys per original CSA in any N first elements of the resulting sequence. Possible optimizations of this deriving procedure are outlined in Section 6.3.",
      "ja": "得られた配列は、決定論のCSAの元の入力シーケンスと各シーケンスキーチェーン内のキーの順序内のCSAの順序と相関するように命じたゼロ個以上の一意のESAを含むであろう。この順序は、得られた配列の任意のN個の第1の要素の元のCSAあたりのキーの等量を有する確率を最大にします。この導出手順の可能な最適化は、6.3節で概説されています。"
    },
    {
      "indent": 0,
      "text": "5.3. Updates to Packet Sending",
      "section_title": true,
      "ja": "5.3. パケット送信するアップデート"
    },
    {
      "indent": 3,
      "text": "Perform the following authentication-specific processing after the instance of the original protocol considers an outgoing Babel packet ready for sending, but before the packet is actually sent (see Figure 1 in Appendix A). After that, send the packet, regardless of whether the authentication-specific processing modified the outgoing packet or left it intact.",
      "ja": "元のプロトコルのインスタンスが送信するための発信バベルパケットの準備ができ考慮した後、次の認証特有の処理を行うが、パケットが実際に送信される前に（付録Aの図1を参照）。その後、関係なく認証特有の処理は、発信パケットを変更または無傷それを残したかどうか、パケットを送信します。"
    },
    {
      "indent": 3,
      "text": "1. If the current outgoing interface's sequence of CSAs is empty, finish authentication-specific processing and consider the packet ready for sending.",
      "ja": "CSAの現在の発信インターフェイスのシーケンスが空の場合1.認証固有の処理を終了し、送信するためのパケットの準備ができて考えます。"
    },
    {
      "indent": 3,
      "text": "2. Increment the TS/PC number of the current outgoing interface, as explained in Section 5.1.",
      "ja": "2.インクリメント現在の発信インターフェイスのTS / PC番号、セクション5.1で説明したように。"
    },
    {
      "indent": 3,
      "text": "3. Add to the packet body (see the note at the end of this section) a TS/PC TLV with fields set as follows:",
      "ja": "3.次のように設定されたフィールドを持つパケット本体（このセクションの最後にある注を参照してください）TS / PC TLVに追加します。"
    },
    {
      "indent": 7,
      "text": "Type Set to 11.",
      "ja": "タイプは11に設定します。"
    },
    {
      "indent": 7,
      "text": "Length Set to 6.",
      "ja": "長さは6に設定してください。"
    },
    {
      "indent": 7,
      "text": "PacketCounter Set to the current value of the LocalPC variable of the current outgoing interface.",
      "ja": "PacketCounter現在の発信インターフェイスのLocalPC変数の現在の値に設定してください。"
    },
    {
      "indent": 7,
      "text": "Timestamp Set to the current value of the LocalTS variable of the current outgoing interface.",
      "ja": "現在の発信インターフェイスのLocalTS変数の現在の値に設定されたタイムスタンプ。"
    },
    {
      "indent": 7,
      "text": "Note that the current step may involve byte order conversion.",
      "ja": "現在のステップがバイトオーダー変換を伴うことがあります。"
    },
    {
      "indent": 3,
      "text": "4. Derive a sequence of ESAs, using the procedure defined in Section 5.2, with the current interface's sequence of CSAs as the input sequence of CSAs, the current time as CT, and \"sending\" as the direction. Proceed to the next step even if the derived sequence is empty.",
      "ja": "4.のCSAの入力シーケンスとしてのCSAの現在のインタフェースの配列と、セクション5.2で定義された手順を使用して、CTのような現在の時間のESAのシーケンスを導出し、方向として「送信」。由来の配列が空の場合でも、次のステップに進みます。"
    },
    {
      "indent": 3,
      "text": "5. Iterate over the derived sequence, using its ordering. For each ESA, add to the packet body (see the note at the end of this section) an HMAC TLV with fields set as follows:",
      "ja": "由来の配列を超える5.反復、その順序付けを使用します。各ESAについては、次のように設定されたフィールドを持つパケット本体（このセクションの最後にある注を参照してください）HMAC TLVに追加します。"
    },
    {
      "indent": 7,
      "text": "Type Set to 12.",
      "ja": "タイプは12に設定します。"
    },
    {
      "indent": 7,
      "text": "Length Set to 2 plus the digest length of HashAlgo of the current ESA.",
      "ja": "長さは2に設定してプラス現在のESAのHashAlgoのダイジェスト長。"
    },
    {
      "indent": 7,
      "text": "KeyID Set to KeyID of the current ESA.",
      "ja": "現在のESAの鍵IDに設定しKEYID。"
    },
    {
      "indent": 7,
      "text": "Digest Size exactly equal to the digest length of HashAlgo of the current ESA. Pad (see Section 2.2), using the source address of the current packet (see Section 6.1).",
      "ja": "現在のESAのHashAlgoのダイジェスト長に正確に等しいダイジェストサイズ。パッド（6.1節を参照してください）現在のパケットの送信元アドレスを使用して、（2.2節を参照してください）。"
    },
    {
      "indent": 7,
      "text": "As soon as there are MaxDigestsOut HMAC TLVs added to the current packet body, immediately proceed to the next step.",
      "ja": "すぐMaxDigestsOut HMACのTLVは、現在のパケット本体に付加があるので、すぐに次のステップに進みます。"
    },
    {
      "indent": 7,
      "text": "Note that the current step may involve byte order conversion.",
      "ja": "現在のステップがバイトオーダー変換を伴うことがあります。"
    },
    {
      "indent": 3,
      "text": "6. Increment the \"Body length\" field value of the current packet header by the total length of TS/PC and HMAC TLVs appended to the current packet body so far.",
      "ja": "TS / PC及びHMACのTLVの長さの合計によって前記インクリメント現在のパケットヘッダの「身体長さ」フィールドの値は、これまで、現在のパケットの本体に付加。"
    },
    {
      "indent": 7,
      "text": "Note that the current step may involve byte order conversion.",
      "ja": "現在のステップがバイトオーダー変換を伴うことがあります。"
    },
    {
      "indent": 3,
      "text": "7. Make a temporary copy of the current packet.",
      "section_title": true,
      "ja": "7.現在のパケットの一時的なコピーを作成します。"
    },
    {
      "indent": 3,
      "text": "8. Iterate over the derived sequence again, using the same order and number of elements. For each ESA (and, respectively, for each HMAC TLV recently appended to the current packet body), compute an HMAC result (see Section 2.4), using the temporary copy (not the original packet) as Text, HashAlgo of the current ESA as H, and AuthKeyOctets of the current ESA as K. Write the HMAC result to the Digest field of the current HMAC TLV (see Table 4 in Appendix A) of the current packet (not the copy).",
      "ja": "同じ順序と要素の数を使用して再び誘導された配列上8反復、。 （最近、現在のパケット本体に添付さ各HMAC TLVのためのそれぞれと、）各ESA、HMACの結果を計算するためのテキストとして一時的なコピー（ない元のパケット）を使用して、（2.4節を参照）、現在のESAなどのHashAlgo現在のパケット（コピーではなく）のH、及びK.、現在のHMAC TLVのダイジェストフィールドにHMAC結果を書くように、現在のESAのAuthKeyOctets（付録Aの表4を参照されたいです）。"
    },
    {
      "indent": 3,
      "text": "9. After this point, allow no more changes to the current packet header and body, and consider it ready for sending.",
      "ja": "9.この時点の後、現在のパケットのヘッダとボディへのより多くの変更を許可しない、および送信するためには準備ができて考えます。"
    },
    {
      "indent": 3,
      "text": "Note that even when the derived sequence of ESAs is empty, the packet is sent anyway, with only a TS/PC TLV appended to its body. Although such a packet would not be authenticated, the presence of the sole TS/PC TLV would indicate authentication key exhaustion to operators of neighbouring Babel speakers. See also Section 7.4.",
      "ja": "ESAの由来の配列が空の場合でも、パケットはその本体に添付さだけTS / PCのTLVで、とにかく送られることに注意してください。このようなパケットが認証されないが、唯一のTS / PC TLVの存在は、隣接バベルスピーカーの事業者に認証キー枯渇を示すことになります。また、セクション7.4を参照してください。"
    },
    {
      "indent": 3,
      "text": "Also note that it is possible to place the authentication-specific TLVs in the packet's sequence of TLVs in a number of different valid ways so long as there is exactly one TS/PC TLV in the sequence and the ordering of HMAC TLVs relative to each other, as produced in step 5 above, is preserved.",
      "ja": "また、正確に一つのTS / PCシーケンスのTLVと互いにHMACのTLVの相対的な順序がある限り、異なる有効ないくつかの方法でのTLVのパケットのシーケンスで認証固有のTLVを配置することが可能であることに注意してください、上記ステップ5で製造され、保存されます。"
    },
    {
      "indent": 3,
      "text": "For example, see Figure 2 in Appendix A. The diagrams represent a Babel packet without (D1) and with (D2, D3, D4) authentication-specific TLVs. The optional trailing data block that is present in D1 is preserved in D2, D3, and D4. Indexing (1, 2, ..., n) of the HMAC TLVs means the order in which the sending procedure produced them (and, respectively, the HMAC results). In D2, the added TLVs are appended: the previously existing TLVs are followed by the TS/PC TLV, which is followed by the HMAC TLVs. In D3, the added TLVs are prepended: the TS/PC TLV is the first and is followed by the HMAC TLVs, which are followed by the previously existing TLVs. In D4, the added TLVs are intermixed with the previously existing TLVs and the TS/PC TLV is placed after the HMAC TLVs. All three packets meet the requirements above.",
      "ja": "例えば、図は、（D1）がなく、（D2、D3、D4）認証固有のTLVとバベルパケットを表す付録Aの図2を参照。 D1に存在する任意後続データブロックがD2、D3、及びD4に保存されています。 HMACのTLVの割出し（1、2、...、n）は（HMACの結果、それぞれ、と）送信手順は、それらを生成する順序を意味します。 D2において、追加のTLVは、添付されている：既存のTLVは、HMACのTLVに続いてTS / PC TLV、が続きます。 D3では、追加のTLVが付加されている：TS / PC TLVが最初であり、既存のTLVが続くHMACのTLVが続きます。 D4では、追加のTLVは、既存のTLVと混合され、TS / PC TLVは、HMACのTLVの後に置かれています。すべての3つのパケットは、上記の要件を満たしています。"
    },
    {
      "indent": 3,
      "text": "Implementors SHOULD use appending (D2) for adding the authentication-specific TLVs to the sequence; this is expected to result in more straightforward implementation and troubleshooting in most use cases.",
      "ja": "実装は、配列への認証固有のTLVを追加する（D2）を追加使用する必要があります。これは、ほとんどのユースケースで、より簡単な実装とトラブルシューティングをもたらすことが期待されます。"
    },
    {
      "indent": 0,
      "text": "5.4. Updates to Packet Receiving",
      "section_title": true,
      "ja": "5.4. パケット受信の更新"
    },
    {
      "indent": 3,
      "text": "Perform the following authentication-specific processing after an incoming Babel packet is received from the local network stack but before it is acted upon by the Babel protocol instance (see Figure 1 in Appendix A). The final action conceptually depends not only upon the result of the authentication-specific processing but also on the current value of the RxAuthRequired parameter. Immediately after any processing step below accepts or refuses the packet, either deliver the packet to the instance of the original protocol (when the packet is accepted or RxAuthRequired is FALSE) or discard it (when the packet is refused and RxAuthRequired is TRUE).",
      "ja": "着信バベルパケットがローカルネットワークスタックから受信された後、次の認証特有の処理を行うが、それは、バベルプロトコルインスタンスが作用する前に（付録Aの図1を参照）。最終的なアクションは、概念的に認証特有の処理の結果にもRxAuthRequiredパラメータの現在の値だけでなく依存します。任意の処理ステップは、以下の、受け入れまたはパケットを拒否した直後に、元のプロトコルのインスタンスにパケットを届ける（パケットが受け入れられるか、RxAuthRequiredがFALSEである）、またはそれを破棄（パケットが拒否された場合にRxAuthRequiredがTRUEである）のいずれか。"
    },
    {
      "indent": 3,
      "text": "1. If the current incoming interface's sequence of CSAs is empty, accept the packet.",
      "ja": "1.のCSAの現在の着信インターフェイスのシーケンスが空の場合、パケットを受け入れます。"
    },
    {
      "indent": 3,
      "text": "2. If the current packet does not contain exactly one TS/PC TLV, refuse it.",
      "ja": "2.現在のパケットが正確に一つのTS / PC TLVが含まれていない場合は、それを拒否。"
    },
    {
      "indent": 3,
      "text": "3. Perform a lookup in the ANM table for an entry having Interface equal to the current incoming interface and Source equal to the source address of the current packet. If such an entry does not exist, immediately proceed to the next step. Otherwise, compare the entry's LastTS and LastPC field values with the Timestamp and PacketCounter values, respectively, of the TS/PC TLV of the packet. That is, refuse the packet if at least one of the following two conditions is true:",
      "ja": "3.現在の着信インターフェイスと現在のパケットの送信元アドレスに等しい送信元と同じインタフェースを有するエントリのANMテーブルのルックアップを実行します。そのようなエントリが存在しない場合は、すぐに次のステップに進みます。それ以外の場合は、パケットのTS / PC TLVの、それぞれ、タイムスタンプとPacketCounter値でエントリーのLastTSとLastPCフィールドの値を比較します。次の2つの条件のうち少なくともいずれかに該当する場合には、パケットを拒否されています。"
    },
    {
      "indent": 8,
      "text": "* Timestamp is less than LastTS",
      "ja": "*タイムスタンプはLastTS未満であります"
    },
    {
      "indent": 8,
      "text": "* Timestamp is equal to LastTS and PacketCounter is not greater than LastPC",
      "ja": "*タイムスタンプはLastTSに等しく、PacketCounterはLastPCより大きくありません"
    },
    {
      "indent": 8,
      "text": "Note that the current step may involve byte order conversion.",
      "ja": "現在のステップがバイトオーダー変換を伴うことがあります。"
    },
    {
      "indent": 3,
      "text": "4. Derive a sequence of ESAs, using the procedure defined in Section 5.2, with the current interface's sequence of CSAs as the input sequence of CSAs, current time as CT, and \"receiving\" as the direction. If the derived sequence is empty, refuse the packet.",
      "ja": "4.のCSA、CTとして現在時刻の入力シーケンスとしてのCSAの現在のインタフェースの配列と、セクション5.2で定義された手順を使用して、のESAのシーケンスを導出し、方向として「受信」。由来の配列が空の場合、パケットを拒否。"
    },
    {
      "indent": 3,
      "text": "5. Make a temporary copy of the current packet.",
      "section_title": true,
      "ja": "5.現在のパケットの一時的なコピーを作成します。"
    },
    {
      "indent": 3,
      "text": "6. Pad (see Section 2.2) every HMAC TLV present in the temporary copy (not the original packet), using the source address of the original packet.",
      "ja": "オリジナルのパケットの送信元アドレスを使用して6パッド（2.2節を参照）一時的なコピー（ない元のパケット）内のすべてのHMAC TLVの存在、。"
    },
    {
      "indent": 3,
      "text": "7. Iterate over all the HMAC TLVs of the original input packet (not the copy), using their order of appearance in the packet. For each HMAC TLV, look up all ESAs in the derived sequence such that 2 plus the digest length of HashAlgo of the ESA is equal to Length of the TLV and KeyID of the ESA is equal to the value of KeyID of the TLV. Iterate over these ESAs in the relative order of their appearance on the full sequence of ESAs. Note that nesting the iterations the opposite way (over ESAs, then over HMAC TLVs) would be wrong.",
      "ja": "上7.反復すべての元の入力パケットのHMACのTLV（コピーではなく）、パケット内の出現の順序を使用して。各HMAC TLVのために、ESAのHashAlgoのダイジェスト長さプラス2はESAのTLVとKeyIDをの長さに等しくなるように誘導された配列内のすべてのESAをルックアップするTLVのKeyIDをの値に等しいです。 ESAの全配列に、その外観の相対的な順序でこれらのESAを反復。イテレーションを逆方向をネスト（ESAの上では、その後、HMACのTLVを超える）間違っていることに注意してください。"
    },
    {
      "indent": 8,
      "text": "For each of these ESAs, compute an HMAC result (see\nSection 2.4), using the temporary copy (not the original packet)\nas Text, HashAlgo of the current ESA as H, and AuthKeyOctets of\nthe current ESA as K.  If the current HMAC result exactly\nmatches the contents of the Digest field of the current HMAC\nTLV, immediately proceed to the next step.  Otherwise, if the\nnumber of HMAC computations done for the current packet so far\nis equal to MaxDigestsIn, immediately proceed to the next step.\nOtherwise, follow the normal order of iterations.",
      "raw": true
    },
    {
      "indent": 8,
      "text": "Note that the current step may involve byte order conversion.",
      "ja": "現在のステップがバイトオーダー変換を伴うことがあります。"
    },
    {
      "indent": 3,
      "text": "8. Refuse the input packet unless there was a matching HMAC result in the previous step.",
      "ja": "マッチングHMAC結果が前の手順であった場合を除き8入力パケットを拒否する。"
    },
    {
      "indent": 3,
      "text": "9. Modify the ANM table, using the same index as for the entry lookup above, to contain an entry with LastTS set to the value of Timestamp and LastPC set to the value of PacketCounter fields of the TS/PC TLV of the current packet. That is, either add a new ANM table entry or update the existing one, depending on the result of the entry lookup above. Reset the entry's aging timer to the current value of ANM timeout.",
      "ja": "9.タイムスタンプとLastPCの値に設定さLastTSのエントリを含むように、上記のエントリの検索と同じインデックスを使用して、ANMテーブルを変更し、現在のパケットのTS / PC TLVのPacketCounterフィールドの値に設定します。それは、新しいANMテーブルエントリを追加するか、上記のエントリ検索の結果に応じて、既存のものを更新するのいずれか、です。 ANMのタイムアウトの現在の値にエントリのエージングタイマーをリセットします。"
    },
    {
      "indent": 8,
      "text": "Note that the current step may involve byte order conversion.",
      "ja": "現在のステップがバイトオーダー変換を伴うことがあります。"
    },
    {
      "indent": 3,
      "text": "10. Accept the input packet.",
      "section_title": true,
      "ja": "10.入力パケットを受け入れます。"
    },
    {
      "indent": 3,
      "text": "Before performing the authentication-specific processing above, an implementation SHOULD perform those basic procedures of the original protocol that don't take any protocol actions on the contents of the packet but that will discard the packet if it is not sufficiently well formed for further processing. Although the exact composition of such procedures belongs to the scope of the original protocol, it seems reasonable to state that a packet SHOULD be discarded early, regardless of whether any authentication-specific processing is due, unless its source address conforms to Section 3.1 of [BABEL] and is not the receiving speaker's own address (see item (e) of Section 8).",
      "ja": "上記認証特有の処理を行う前に、実装は、パケットの内容に任意のプロトコル・アクションを取らない独自プロトコルのこれらの基本的な手順を実行する必要があり、それは、十分にさらなる処理のために形成されない場合にはパケットを破棄します。このような手順の正確な組成は、元のプロトコルの範囲に属しているが、パケットに関係なく、その送信元アドレスがセクション3.1に準拠していない限り、任意の認証特有の処理が原因であるかどうかの早期廃棄されるべきであることを述べるために妥当と思われます[ BABEL]と受信話し手自身のアドレスではありません（8節の項目（e）を参照）。"
    },
    {
      "indent": 3,
      "text": "Note that RxAuthRequired affects only the final action but not the defined flow of authentication-specific processing. The purpose of this is to preserve authentication-specific processing feedback (such as log messages and event-counter updates), even with RxAuthRequired set to FALSE. This allows an operator to predict the effect of changing RxAuthRequired from FALSE to TRUE during a migration scenario (Section 7.3) implementation.",
      "ja": "RxAuthRequired認証特有の処理の定義されたフローだけ最終動作に影響はなく、ことに留意されたいです。この目的はRxAuthRequiredがFALSEに設定されさえして、（例えばログメッセージとイベントカウンタの更新など）の認証特有の処理のフィードバックを保存することです。これは、オペレータが移行シナリオ（セクション7.3）の実装時にfalseからtrueにRxAuthRequiredを変化させる効果を予測することを可能にします。"
    },
    {
      "indent": 0,
      "text": "5.5. Authentication-Specific Statistics Maintenance",
      "section_title": true,
      "ja": "5.5. 認証固有の統計情報のメンテナンス"
    },
    {
      "indent": 3,
      "text": "A Babel speaker implementing this mechanism SHOULD maintain a set of counters for the following events, per protocol instance and per interface:",
      "ja": "プロトコルインスタンスごとおよびインターフェイスごとに、次のイベントのカウンタのセットを維持する必要があり、この機構を実装バベルスピーカー。"
    },
    {
      "indent": 3,
      "text": "a. Sending an unauthenticated Babel packet through an interface having an empty sequence of CSAs (Section 5.3 item 1).",
      "ja": "A。 CSA（5.3節項目1）の空の配列を有するインタフェースを介して認証されていないバベルパケットを送信します。"
    },
    {
      "indent": 3,
      "text": "b. Sending an unauthenticated Babel packet with a TS/PC TLV but without any HMAC TLVs, due to an empty derived sequence of ESAs (Section 5.3 item 4).",
      "ja": "B。原因のESAの空由来の配列（セクション5.3項目4）に、TS / PCのTLVを有するが、任意のHMACのTLVなしで認証されていないバベルパケットを送信します。"
    },
    {
      "indent": 3,
      "text": "c. Sending an authenticated Babel packet containing both TS/PC and HMAC TLVs (Section 5.3 item 9).",
      "ja": "C。 TS / PCおよびHMACのTLV（5.3節項目9）の両方を含む、認証バベルパケットを送信します。"
    },
    {
      "indent": 3,
      "text": "d. Accepting a Babel packet received through an interface having an empty sequence of CSAs (Section 5.4 item 1).",
      "ja": "D。バベルパケットを受け入れることのCSAの空のシーケンス（5.4アイテム1）を有するインタフェースを介して受信しました。"
    },
    {
      "indent": 3,
      "text": "e. Refusing a received Babel packet due to an empty derived sequence of ESAs (Section 5.4 item 4).",
      "ja": "電子。原因のESA（5.4アイテム4）の空由来の配列に受信バベルパケットを拒否する。"
    },
    {
      "indent": 3,
      "text": "f. Refusing a received Babel packet that does not contain exactly one TS/PC TLV (Section 5.4 item 2).",
      "ja": "F。正確に一つのTS / PC TLV（5.4節の項目2）を含まない受信バベルパケットを拒否。"
    },
    {
      "indent": 3,
      "text": "g. Refusing a received Babel packet due to the TS/PC TLV failing the ANM table check (Section 5.4 item 3). With possible future extensions in mind, in implementations of this mechanism, this event SHOULD leave out some small amount, per current (Interface, Source, LastTS, LastPC) tuple, of the packets refused due to the Timestamp value being equal to LastTS and the PacketCounter value being equal to LastPC.",
      "ja": "グラム。 ANMテーブルのチェックを失敗によるTS / PC TLVに受信バベルパケットを拒否（5.4節項目3）。心の中で将来の拡張では、このメカニズムの実装では、このイベントはいくつかの小さな量を除外すべきで、現在（インタフェース、ソース、LastTS、LastPC）タプルごとに、パケットのため、Timestamp値はLastTSとに等しいを拒否PacketCounter値LastPCに等しいです。"
    },
    {
      "indent": 3,
      "text": "h. Refusing a received Babel packet missing any HMAC TLVs (Section 5.4 item 8).",
      "ja": "時間。任意のHMACのTLV（5.4節項目8）を欠落している受信バベルパケットを拒否。"
    },
    {
      "indent": 3,
      "text": "i. Refusing a received Babel packet due to none of the processed HMAC TLVs passing the ESA check (Section 5.4 item 8).",
      "ja": "私。 ESAによるチェック（5.4節項目8）を通過する処理HMACのTLVのどれに受信バベルパケットを拒否する。"
    },
    {
      "indent": 3,
      "text": "j. Accepting a received Babel packet having both TS/PC and HMAC TLVs (Section 5.4 item 10).",
      "ja": "J。 TS / PC及びHMACのTLV（5.4アイテム10）の両方を有する受信バベルパケットを受け入れます。"
    },
    {
      "indent": 3,
      "text": "k. Delivery of a refused packet to the instance of the original protocol due to the RxAuthRequired parameter being set to FALSE.",
      "ja": "K。 FALSEに設定されRxAuthRequiredパラメータによる独自プロトコルのインスタンスへの拒否パケットの配信。"
    },
    {
      "indent": 3,
      "text": "Note that the terms \"accepting\" and \"refusing\" are used in the sense of the receiving procedure; that is, \"accepting\" does not mean a packet delivered to the instance of the original protocol purely because the RxAuthRequired parameter is set to FALSE. Event-counter readings SHOULD be available to the operator at runtime.",
      "ja": "用語「受け入れ」と受信手続きの意味で使用される「拒否」ことに留意されたいです。つまり、「受け入れる」RxAuthRequiredパラメータがFALSEに設定されている純粋なので、元のプロトコルのインスタンスに送達パケットを意味するものではありません。イベント・カウンタの測定値は、実行時にオペレータに利用可能であるべきです。"
    },
    {
      "indent": 0,
      "text": "6. Implementation Notes",
      "section_title": true,
      "ja": "6.実装の注意事項"
    },
    {
      "indent": 0,
      "text": "6.1. Source Address Selection for Sending",
      "section_title": true,
      "ja": "6.1. 送信のためのソースアドレス選択"
    },
    {
      "indent": 3,
      "text": "Section 3.1 of [BABEL] allows for the exchange of protocol datagrams, using IPv4, IPv6, or both. The source address of the datagram is a unicast (link-local in the case of IPv6) address. Within an address family used by a Babel speaker, there may be more than one address eligible for the exchange and assigned to the same network interface. The original specification considers this case out of scope and leaves it up to the speaker's network stack to select one particular address as the datagram source address, but the sending procedure requires (Section 5.3 item 5) exact knowledge of the packet source address for proper padding of HMAC TLVs.",
      "ja": "[BABEL]のセクション3.1は、IPv4、IPv6の、または両方を使用して、プロトコルデータグラムの交換を可能にします。データグラムの送信元アドレスは、ユニキャスト（リンクローカルIPv6の場合）アドレスです。バベルのスピーカーで使用されるアドレスファミリの中で、交換の対象と同じネットワークインタフェースに割り当てられた複数のアドレスがあるかもしれません。元の仕様では、範囲外この場合を考慮し、データグラムの送信元アドレスとして一つの特定のアドレスを選択するために、話者のネットワークスタックにそれを残すが、送信手順（セクション5.3項目5）適切なパディング用パケットの送信元アドレスの正確な知識を必要としますHMACのTLVの。"
    },
    {
      "indent": 3,
      "text": "As long as a network interface has more than one address eligible for the exchange within the same address family, the Babel speaker SHOULD internally choose one of those addresses for Babel packet sending purposes and then indicate this choice to both the sending procedure and the network stack (see Figure 1 in Appendix A). Wherever this requirement cannot be met, this limitation MUST be clearly stated in the system documentation to allow an operator to plan network address management accordingly.",
      "ja": "ネットワークインタフェースが同じアドレスファミリ内の交換のための複数のアドレスの資格を持っている限り、バベルのスピーカーは、内部バベルパケット送信の目的のために、これらのアドレスのいずれかを選択してから送信する手順と、ネットワークスタックの両方にこの選択肢を示すべきです（付録Aで図1を参照）。この要件を満たすことができない限り、この制限は、明らかに、オペレータがそれに応じてネットワークアドレスの管理を計画することを可能にするシステムのマニュアルに記載されなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.2. Output Buffer Management",
      "section_title": true,
      "ja": "6.2. 出力バッファの管理"
    },
    {
      "indent": 3,
      "text": "An instance of the original protocol will buffer produced TLVs until the buffer becomes full or a delay timer has expired. This is performed independently for each Babel interface, with each buffer sized according to the interface MTU (see Sections 3.1 and 4 of [BABEL]).",
      "ja": "バッファがいっぱいになるか、遅延タイマーが満了するまで、元のプロトコルのインスタンスが生成さTLVをバッファリングします。これは、インターフェースのMTUに応じて大き各バッファと、各バベルインターフェイスに対して独立して実行される（[BABEL]のセクション3.1および4を参照されたいです）。"
    },
    {
      "indent": 3,
      "text": "Since TS/PC TLVs, HMAC TLVs, and any other TLVs -- and most likely the TLVs of the original protocol -- share the same packet space (see Figure 2 in Appendix A) and, respectively, the same buffer space, a particular portion of each interface buffer needs to be reserved for one TS/PC TLV and up to MaxDigestsOut HMAC TLVs. The amount (R) of this reserved buffer space is calculated as follows:",
      "ja": "そして、元のプロトコルの最も可能性が高いのTLV  -   -  TS / PCのTLV、HMACのTLV、及び任意の他のTLVので、それぞれ同じパケット空間（付録Aで図2を参照）と、同一のバッファスペース、特定の共有各インタフェース・バッファの部分は、1つのTS / PCのTLVおよびMaxDigestsOut HMACのTLVまでに予約する必要があります。次のようにこの予約済みバッファスペースの量（R）が計算されます。"
    },
    {
      "indent": 20,
      "text": "R = St + MaxDigestsOut * Sh\nR = 8  + MaxDigestsOut * (4 + Lmax)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "St The size of a TS/PC TLV.",
      "ja": "セントTS / PC TLVのサイズ。"
    },
    {
      "indent": 3,
      "text": "Sh The size of an HMAC TLV.",
      "ja": "HMAC TLVの大きさをSH。"
    },
    {
      "indent": 3,
      "text": "Lmax The maximum possible digest length in octets for a particular interface. It SHOULD be calculated based on the particular interface's sequence of CSAs but MAY be taken as the maximum digest length supported by a particular implementation.",
      "ja": "最大可能LMAX特定のインターフェイスのためのオクテットの長さを消化。それのCSAの特定のインターフェイスの配列に基づいて計算されるべきであるが、特定の実装によってサポートされる最大ダイジェスト長さとしてもよいです。"
    },
    {
      "indent": 3,
      "text": "An implementation allowing for a per-interface value of MaxDigestsOut or Lmax has to account for a different value of R across different interfaces, even interfaces having the same MTU. An implementation allowing for a runtime change to the value of R (due to MaxDigestsOut or Lmax) has to take care of the TLVs already buffered by the time of the change -- specifically, when the value of R increases.",
      "ja": "MaxDigestsOut又はLmaxとのインターフェースごとの値を可能にする実装も同じMTUを有するインターフェイス、異なるインターフェースを横切るRの異なる値を考慮しなければなりません。具体的には、Rの値が大きくなる - （起因MaxDigestsOut又は値Lmaxまで）Rの値にランタイムの変更を可能にする実装が既に変化の時間でバッファリングのTLVの世話をしなければなりません。"
    },
    {
      "indent": 3,
      "text": "The maximum safe value of the MaxDigestsOut parameter depends on the interface MTU and maximum digest length used. In general, at least 200-300 octets of a Babel packet should always be available to data other than TS/PC and HMAC TLVs. An implementation following the requirements of Section 4 of [BABEL] would send packets of 512 octets or larger. If, for example, the maximum digest length is 64 octets and the MaxDigestsOut value is 4, the value of R would be 280, leaving less than half of a 512-octet packet for any other TLVs. As long as the interface MTU is larger or the digest length is smaller, higher values of MaxDigestsOut can be used safely.",
      "ja": "MaxDigestsOutパラメータの最大安全値が使用されるインターフェイスMTU最大ダイジェストの長さに依存します。一般的には、バベルパケットの少なくとも200〜300個のオクテットは、常にTS / PCおよびHMACのTLV以外のデータが利用できるようにすべきです。 [BABEL]の第4の要件を以下の実装は、512オクテット以上のパケットを送信することになります。例えば、最大ダイジェストの長さは64個のオクテットであり、MaxDigestsOut値が4である、場合は、Rの値は、他のTLVのために512オクテットのパケットの半分未満を残し、280あろう。限りインタフェースMTUが大きい又はダイジェストの長さが小さいほど、MaxDigestsOutのより高い値は、安全に使用することができます。"
    },
    {
      "indent": 0,
      "text": "6.3. Optimizations of Deriving Procedure for ESAs",
      "section_title": true,
      "ja": "6.3.  ESAのための導出手順の最適化"
    },
    {
      "indent": 3,
      "text": "The following optimizations of the deriving procedure for ESAs can reduce the amount of CPU time consumed by authentication-specific processing, preserving an implementation's effective behaviour.",
      "ja": "ESAのための導出手順の次の最適化は、実装の効果的な行動を維持し、認証特有の処理で消費されるCPU時間の量を減らすことができます。"
    },
    {
      "indent": 3,
      "text": "a. The most straightforward implementation would treat the deriving procedure as a per-packet action, but since the procedure is deterministic (its output depends on its input only), it is possible to significantly reduce the number of times the procedure is performed.",
      "ja": "A。 、大幅に手続きが行われた回数を削減することができる最も簡単な実装では、パケットごとのアクションとして導出手順を扱っていましたが、手順は決定論的であるので、（その出力はその入力に依存します）。"
    },
    {
      "indent": 7,
      "text": "The procedure would obviously return the same result for the same\ninput arguments (sequence of CSAs, direction, CT) values.\nHowever, it is possible to predict when the result will remain\nthe same, even for a different input.  That is, when the input\nsequence of CSAs and the direction both remain the same but CT\nchanges, the result will remain the same as long as CT's order on\nthe time axis (relative to all critical points of the sequence of\nCSAs) remains unchanged.  Here, the critical points are\nKeyStartAccept and KeyStopAccept (for the receiving direction),\nand KeyStartGenerate and KeyStopGenerate (for the sending\ndirection), of all keys of all CSAs of the input sequence.  In\nother words, in this case the result will remain the same as long\nas (1) none of the active keys expire and (2) none of the\ninactive keys enter into operation.",
      "raw": true
    },
    {
      "indent": 7,
      "text": "An implementation optimized in this way would perform the full deriving procedure for a given (interface, direction) pair only after an operator's change to the interface's sequence of CSAs or after reaching one of the critical points mentioned above.",
      "ja": "このように最適化されたインプリメンテーションのみのCSAのインターフェイスの配列または上記臨界点のいずれかに到達した後、オペレータの変更後所定の（インタフェース、方向）一対の完全な導出手順を実行することになります。"
    },
    {
      "indent": 3,
      "text": "b. Considering that the sending procedure iterates over at most MaxDigestsOut elements of the derived sequence of ESAs (Section 5.3 item 5), there would be little sense, in the case of the sending direction, in returning more than MaxDigestsOut ESAs in the derived sequence. Note that a similar optimization would be relatively difficult in the case of the receiving direction, since the number of ESAs actually used in examining a particular received packet (not to be confused with the number of HMAC computations) depends on additional factors besides just MaxDigestsIn.",
      "ja": "B。 ESA（5.3節項目5）の誘導された配列の多くともMaxDigestsOut要素にわたって送信手順の反復は、誘導された配列にMaxDigestsOutのESA以上に戻る際に、送信方向の場合には、ほとんど意味があるであろうことを考慮。実際に特定の受信したパケットを検査に使用されるのESAの数は（HMAC計算の数と混同すべきではない）だけMaxDigestsIn以外に追加の要因に依存するので、同様の最適化は、受信方向の場合には比較的困難であることに留意されたいです。"
    },
    {
      "indent": 0,
      "text": "6.4. Duplication of Security Associations",
      "section_title": true,
      "ja": "6.4. セキュリティアソシエーションの複製"
    },
    {
      "indent": 3,
      "text": "This specification defines three data structures as finite sequences: a KeyChain sequence, an interface's sequence of CSAs, and a sequence of ESAs. There are associated semantics to take into account during implementation, in that the same element can appear multiple times at different positions of the sequence. In particular, none of the CSA structure fields (including HashAlgo, LocalKeyID, and AuthKeyOctets), alone or in a combination, have to be unique within a given CSA, or within a given sequence of CSAs, or within all sequences of CSAs of a Babel speaker.",
      "ja": "キーチェーンシーケンス、のCSAのインタフェースのシーケンス、およびのESAのシーケンス：この仕様は、有限配列のような3つのデータ構造を定義します。同じ要素がシーケンスの異なる位置に複数回表示されることができるで、実装時に考慮すべき関連するセマンティクスがあります。具体的には、単独または組み合わせて、（HashAlgo、LocalKeyID、及びAuthKeyOctets含む）CSA構造体のフィールドのどれが所与CSA内で一意でなければならない、またはのCSAの所与の配列内、またはのCSAのすべての配列内バベルスピーカー。"
    },
    {
      "indent": 3,
      "text": "In the CSA space defined in this way, for any two authentication keys, their one field (in)equality would not imply another field (in)equality. In other words, it is acceptable to have more than one authentication key with the same LocalKeyID or the same AuthKeyOctets, or both at a time. It is a conscious design decision that CSA semantics allow for duplication of security associations. Consequently, ESA semantics allow for duplication of intermediate ESAs in the sequence until the explicit deduplication (Section 5.2 item 4).",
      "ja": "任意の2つの認証キーのために、このように定義されたCSAスペースでは、その一つのフィールド（中）平等は、別のフィールド（中）平等を意味するものではありません。換言すれば、一度に同じLocalKeyID又は同じAuthKeyOctets、またはその両方で複数の認証キーを有することが許容されます。これは、CSAのセマンティクスはセキュリティアソシエーションの重複を可能に配慮した設計上の決定です。したがって、ESAのセマンティクスは、明示的な重複排除（5.2節項目4）までシーケンスにおける中間のESAの複製を可能にします。"
    },
    {
      "indent": 3,
      "text": "One of the intentions of this is to define the security association management in a way that allows the addressing of some specifics of Babel as a mesh routing protocol. For example, a system operator configuring a Babel speaker to participate in more than one administrative domain could find each domain using its own authentication key (AuthKeyOctets) under the same LocalKeyID value, e.g., a \"well-known\" or \"default\" value like 0 or 1. Since reconfiguring the domains to use distinct LocalKeyID values isn't always feasible, the multi-domain Babel speaker, using several distinct authentication keys under the same LocalKeyID, would make a valid use case for such duplication.",
      "ja": "この意図の一つは、メッシュルーティングプロトコルとしてバベルのいくつかの詳細のアドレス指定を可能にするようにセキュリティアソシエーション管理を定義することです。たとえば、複数の管理ドメインに参加するバベルのスピーカーを構成するシステムオペレータは、同じLocalKeyID値の下で独自の認証キー（AuthKeyOctets）を使用して各ドメインを見つけることができる、のような例えば、「既知の」または「デフォルト」値0または1別個LocalKeyID値を使用するようにドメインを再構成することは常に可能ではないので、同じLocalKeyID下でいくつかの異なる認証鍵を用いたマルチドメインバベルスピーカは、そのような複製のために有効なユースケースになるだろう。"
    },
    {
      "indent": 3,
      "text": "Furthermore, if the operator decided in this situation to migrate one of the domains to a different LocalKeyID value in a seamless way, the respective Babel speakers would use the same authentication key (AuthKeyOctets) under two different LocalKeyID values for the time of the transition (see also item (f) of Section 8). This would make a similar use case.",
      "ja": "オペレータは、シームレスな方法で異なるLocalKeyID値にドメインのいずれかに移行するために、このような状況で決定した場合、さらに、それぞれのバベルスピーカー（遷移の時間のための2つの異なるLocalKeyID値の下で同じ認証キー（AuthKeyOctets）を使用します）また、第8の項目（F）を参照してください。これは、同様のユースケースになるだろう。"
    },
    {
      "indent": 3,
      "text": "Another intention of this design decision is to decouple security association management from authentication key management as much as possible, so that the latter, be it manual keying or a key-management protocol, could be designed and implemented independently (as the respective reasoning made in Section 3.1 of [RIP2-AUTH] still applies). This way, the additional key-management constraints, if any, would remain out of the scope of this authentication mechanism. A similar thinking justifies the LocalKeyID field having a bit length in an ESA structure definition, but not in that of the CSA.",
      "ja": "後者はで行われ、それぞれの推論としては、手動キーまたはキー管理プロトコル、設計することができること及び（独立に実装されるように、この設計上の決定の別の目的は、可能な限り、認証鍵管理からセキュリティアソシエーションの管理を分離することです[RIP2-AUTH]のセクション3.1はまだ適用されます）。この方法では、追加のキー管理の制約は、もしあれば、この認証メカニズムの範囲外のままとなります。同様の考え方はなく、CSAの点で、ESA構造定義のビット長を有するLocalKeyIDフィールドを正当化します。"
    },
    {
      "indent": 0,
      "text": "7. Network Management Aspects",
      "section_title": true,
      "ja": "7.ネットワークの管理面"
    },
    {
      "indent": 0,
      "text": "7.1. Backward Compatibility",
      "section_title": true,
      "ja": "7.1. 下位互換性"
    },
    {
      "indent": 3,
      "text": "Support of this mechanism is optional. It does not change the default behaviour of a Babel speaker and causes no compatibility issues with speakers properly implementing the original Babel specification. Given two Babel speakers -- one implementing this mechanism and configured for authenticated exchange (A) and another not implementing it (B) -- these speakers would not distribute routing information unidirectionally, form a routing loop, or experience other protocol logic issues specific purely to the use of this mechanism.",
      "ja": "このメカニズムのサポートはオプションです。これはバベルスピーカーのデフォルトの動作を変更し、スピーカーが正しく元バベル仕様の実装には互換性の問題が発生しません。所与2つのバベルスピーカー - このメカニズムを実装する一方と認証交換（A）用に構成し、別のそれ（B）を実装しない - これらのスピーカーは、一方向ルーティング情報を配布しないであろう、ルーティングループを形成する、または経験他のプロトコルロジックの問題特定純粋このメカニズムを使用します。"
    },
    {
      "indent": 3,
      "text": "The Babel design requires a bidirectional neighbour reachability condition between two given speakers for a successful exchange of routing information. Apparently, neighbour reachability would be unidirectional in the case above. The presence of TS/PC and HMAC TLVs in Babel packets sent by A would be transparent to B, but a lack of authentication data in Babel packets sent by B would make them effectively invisible to the instance of the original protocol of A. Unidirectional links are not specific to the use of this mechanism; they naturally exist on their own and are properly detected and coped with by the original protocol (see Section 3.4.2 of [BABEL]).",
      "ja": "バベルのデザインは、ルーティング情報の交換が成功するための2つの与えられたスピーカー間の双方向ネイバー到達可能性の条件が必要です。どうやら、ネイバーの到達可能性は、上記の場合には、単方向になります。送信されたバベルパケットでTS / PCおよびHMACのTLVの存在は、Bに対して透過的になりますが、Bによって送信されたバベルパケット内の認証データの欠如はA.単方向リンクの元のプロトコルのインスタンスにそれらを効果的に見えなくなるだろうこのメカニズムの使用に固有のものではありません。彼らは自然に自分の上に存在し、適切に検出され、元のプロトコル（[BABEL]のセクション3.4.2を参照）ことで対処しています。"
    },
    {
      "indent": 0,
      "text": "7.2. Multi-Domain Authentication",
      "section_title": true,
      "ja": "7.2. マルチドメイン認証"
    },
    {
      "indent": 3,
      "text": "The receiving procedure treats a packet as authentic as soon as one of its HMAC TLVs passes the check against the derived sequence of ESAs. This allows for packet exchange authenticated with multiple (hash algorithm, authentication key) pairs simultaneously, in combinations as arbitrary as permitted by MaxDigestsIn and MaxDigestsOut.",
      "ja": "受信手順は、すぐにそのHMACのTLVの一つはのESAの由来の配列に対するチェックを通過すると、本物のようにパケットを処理します。これはMaxDigestsInとMaxDigestsOutによって許可限り、任意の組み合わせで、同時に複数の（ハッシュアルゴリズム、認証鍵）ペアで認証パケット交換を可能にします。"
    },
    {
      "indent": 3,
      "text": "For example, consider three Babel speakers with one interface each, configured with the following CSAs:",
      "ja": "たとえば、次のCSAで構成された一つのインタフェースそれぞれで3つのバベルスピーカーを検討してください。"
    },
    {
      "indent": 3,
      "text": "o speaker A: (hash algorithm H1; key SK1), (hash algorithm H1; key SK2)",
      "ja": "OスピーカーA：（ハッシュアルゴリズムH1、鍵SK1）、（ハッシュアルゴリズムH1;キーSK2）"
    },
    {
      "indent": 3,
      "text": "o speaker B: (hash algorithm H1; key SK1)",
      "ja": "OスピーカーB：（ハッシュアルゴリズムH1、鍵SK1）"
    },
    {
      "indent": 3,
      "text": "o speaker C: (hash algorithm H1; key SK2)",
      "ja": "OスピーカーC：（ハッシュアルゴリズムH1;キーSK2）"
    },
    {
      "indent": 3,
      "text": "Packets sent by A would contain two HMAC TLVs each. Packets sent by B and C would contain one HMAC TLV each. A and B would authenticate the exchange between themselves, using H1 and SK1; A and C would use H1 and SK2; B and C would discard each other's packets.",
      "ja": "Aによって送信されたパケットは、それぞれ2つのHMAC TLVを含んでいるでしょう。 B及びCによって送信されたパケットはそれぞれHMAC TLVを含むであろう。 A及びBは、H1とSK1を使用して、それらの間の交換を認証することになります。 AとCは、H1及びSK2を使用します。 BとCは互いのパケットを破棄します。"
    },
    {
      "indent": 3,
      "text": "Consider a similar set of speakers configured with different CSAs:",
      "ja": "異なるのCSAで構成されたスピーカーの同様のセットを考えてみましょう："
    },
    {
      "indent": 3,
      "text": "o speaker D: (hash algorithm H2; key SK3), (hash algorithm H3; key SK4)",
      "ja": "OスピーカーD：（ハッシュアルゴリズムH2;キーSK3）、（ハッシュアルゴリズムH3;キーSK4）"
    },
    {
      "indent": 3,
      "text": "o speaker E: (hash algorithm H2; key SK3), (hash algorithm H4; keys SK5 and SK6)",
      "ja": "OスピーカーE：（ハッシュアルゴリズムH2;キーSK3）、（ハッシュアルゴリズムH4;キーSK5とSK6）"
    },
    {
      "indent": 3,
      "text": "o speaker F: (hash algorithm H3; keys SK4 and SK7), (hash algorithm H5; key SK8)",
      "ja": "OスピーカF：（ハッシュアルゴリズムH3;キーSK4とSK7）、（ハッシュアルゴリズムH5;キーSK8）"
    },
    {
      "indent": 3,
      "text": "Packets sent by D would contain two HMAC TLVs each. Packets sent by E and F would contain three HMAC TLVs each. D and E would authenticate the exchange between themselves, using H2 and SK3; D and F would use H3 and SK4; E and F would discard each other's packets. The simultaneous use of H4, SK5, and SK6 by E, as well as the use of SK7, H5, and SK8 by F (for their own purposes), would remain insignificant to D.",
      "ja": "Dによって送信されたパケットは、それぞれ2つのHMAC TLVを含んでいるでしょう。 EとFによって送信されたパケットは、それぞれ3つのHMAC TLVを含んでいるでしょう。 DとEはH2とSK3を使用して、それらの間で交換を認証します。 DおよびFは、H3とSK4を使用します。 EとFは互いのパケットを破棄します。 EによってH4、SK5、SK6との同時使用、だけでなく、（自分自身の目的のために）FによってSK7、H5、およびSK8の使用は、Dに重要でないままであろう"
    },
    {
      "indent": 3,
      "text": "An operator implementing multi-domain authentication should keep in mind that values of MaxDigestsIn and MaxDigestsOut may be different both within the same Babel speaker and across different speakers. Since the minimum value of both parameters is 2 (see Sections 3.4 and 3.5), when more than two authentication domains are configured simultaneously it is advisable to confirm that every involved speaker can handle a sufficient number of HMAC results for both sending and receiving.",
      "ja": "マルチドメイン認証を実装する作業はMaxDigestsInとMaxDigestsOutの値が同じバベルスピーカー内および各スピーカー間の両方で異なる場合がありますことを心に留めておく必要があります。 、（セクション3.4および3.5を参照）両方のパラメータの最小値は2であるのでつ以上の認証ドメインが同時に設定されている場合、すべての関与スピーカが送信と受信の両方のためのHMAC結果の十分な数を処理できることを確認することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "The recommended method of Babel speaker configuration for multi-domain authentication is to not only use a different authentication key for each domain but also a separate CSA for each domain, even when hash algorithms are the same. This allows for fair competition between CSAs and sometimes limits the consequences of a possible misconfiguration to the scope of one CSA. See also item (f) of Section 8.",
      "ja": "マルチドメイン認証用バベルスピーカ構成の推奨される方法は、ハッシュアルゴリズムが同じであっても、ドメインごとに異なる認証キーだけでなく、ドメインごとに別々のCSAを使用しないだけです。これは、CSAの間の公正な競争を可能にし、時には1つのCSAの範囲に可能な設定ミスの影響を制限します。また、第8項の項目（F）を参照してください。"
    },
    {
      "indent": 0,
      "text": "7.3. Migration to and from Authenticated Exchange",
      "section_title": true,
      "ja": "7.3. 認証取引所へとからの移行"
    },
    {
      "indent": 3,
      "text": "It is common in practice to consider a migration to the authenticated exchange of routing information only after the network has already been deployed and put into active use. Performing the migration in a way without regular traffic interruption is typically demanded, and this specification allows a smooth migration using the RxAuthRequired interface parameter defined in Section 3.1. This measure is similar to the \"transition mode\" suggested in Section 5 of [OSPF3-AUTH-BIS].",
      "ja": "これは、ネットワークが既に展開し、積極的な活用に置かれた後にのみ、ルーティング情報の認証された交換機への移行を検討するために、実際に一般的です。通常のトラフィックを中断することなく、道での移行の実行は、一般的に要求され、そしてこの仕様は、3.1節で定義されたRxAuthRequiredインタフェースパラメータを使用してのスムーズな移行を可能にします。この尺度は、[OSPF3-AUTH-BIS]のセクション5で提案されている「遷移モード」と同様です。"
    },
    {
      "indent": 3,
      "text": "An operator performing the migration needs to arrange configuration changes as follows:",
      "ja": "移行を実行するオペレータは、次のように設定変更を配置する必要があります。"
    },
    {
      "indent": 3,
      "text": "1. Decide on particular hash algorithm(s) and key(s) to be used.",
      "section_title": true,
      "ja": "1.特定のハッシュアルゴリズム（複数可）及び使用される鍵（単数または複数）を決定。"
    },
    {
      "indent": 3,
      "text": "2. Identify all speakers and their involved interfaces that need to be migrated to authenticated exchange.",
      "ja": "2.すべてのスピーカーと認証されたExchangeに移行する必要が彼らの関与のインターフェイスを識別します。"
    },
    {
      "indent": 3,
      "text": "3. For each of the speakers and the interfaces to be reconfigured, first set the RxAuthRequired parameter to FALSE, then configure necessary CSA(s).",
      "ja": "スピーカーとインターフェースのそれぞれについて3を再構成するには、まず、次いで必要CSA（S）を構成FALSEにRxAuthRequiredパラメータを設定します。"
    },
    {
      "indent": 3,
      "text": "4. Examine the speakers to confirm that Babel packets are successfully authenticated according to the configuration (for instance, by examining ANM table entries and authentication-specific statistics; see Figure 1 in Appendix A), and address any discrepancies before proceeding further.",
      "ja": "、さらに進む前に、任意の不一致に対処する; 4.バベルパケットが正常（付録Aで図1を参照して、例えば、ANMテーブルエントリと認証固有の統計を調べることによって）構成に従って認証されることを確認するためにスピーカーを調べ。"
    },
    {
      "indent": 3,
      "text": "5. For each of the speakers and the reconfigured interfaces, set the RxAuthRequired parameter to TRUE.",
      "ja": "スピーカー及び再構成インターフェースの各々について5は、TRUEにRxAuthRequiredパラメータを設定します。"
    },
    {
      "indent": 3,
      "text": "Likewise, temporarily setting RxAuthRequired to FALSE can be used to migrate smoothly from an authenticated packet exchange back to an unauthenticated one.",
      "ja": "同様に、一時的にFALSEにRxAuthRequired設定認証されていないものに戻って認証パケット交換から円滑に移行するために使用することができます。"
    },
    {
      "indent": 0,
      "text": "7.4. Handling of Authentication Key Exhaustion",
      "section_title": true,
      "ja": "7.4. 認証キー枯渇の取扱い"
    },
    {
      "indent": 3,
      "text": "This specification employs a common concept of multiple authentication keys coexisting for a given interface, with two independent lifetime ranges associated with each key (one for sending and another for receiving). It is typically recommended that the keys be configured using finite lifetimes, adding new keys before the old keys expire. However, it is obviously possible for all keys to expire for a given interface (for sending, receiving, or both). Possible ways of addressing this situation raise their own concerns:",
      "ja": "この仕様は、各キーに関連付けられた2つの独立した寿命の範囲（受信のために送信用と別の）と、特定のインターフェイスのために共存する複数の認証キーの共通の概念を採用しています。通常、古いキーの有効期限が切れる前に新しいキーを追加し、有限の寿命を使用して、キーを構成することをお勧めします。すべてのキーが（送信、受信、または両方のために）特定のインターフェイスのために期限切れになるようにするためしかし、それは明らかに可能です。このような状況に対処する可能性のある方法は、自分の懸念を提起します："
    },
    {
      "indent": 3,
      "text": "o Automatic switching to unauthenticated protocol exchange. This behaviour invalidates the initial purposes of authentication and is commonly viewed as unacceptable ([RIP2-AUTH] Section 5.1, [OSPF2-AUTH] Section 3.2, and [OSPF3-AUTH-BIS] Section 3).",
      "ja": "O自動認証されていないプロトコル交換に切り替えます。この現象は、認証の初期の目的を無効にし、一般的に受け入れられない（[RIP2-AUTH]セクション5.1、[OSPF2-AUTH]セクション3.2、および[OSPF3-AUTH-BIS]セクション3）と見なされます。"
    },
    {
      "indent": 3,
      "text": "o Stopping routing information exchange over the interface. This behaviour is likely to impact regular traffic routing and is commonly viewed as \"not advisable\" ([RIP2-AUTH], [OSPF2-AUTH], and [OSPF3-AUTH]), although [OSPF3-AUTH-BIS] is different in this regard.",
      "ja": "インターフェイス上のルーティング情報の交換を停止O。 [OSPF3-AUTH-BISは]で異なっているが、この現象は、通常のトラフィックのルーティングに影響する可能性があり、一般に \"望ましくない\" として見られる（[RIP2-AUTH]、[OSPF2-AUTH]、および[OSPF3-AUTH]）この点について。"
    },
    {
      "indent": 3,
      "text": "o The use of the \"most recently expired\" key over its intended lifetime range. This behaviour is recommended for implementation in [RIP2-AUTH], [OSPF2-AUTH], and [OSPF3-AUTH] but not in [OSPF3-AUTH-BIS]. Such use of this key may become a problem, due to an offline cryptographic attack (see item (f) of Section 8) or a compromise of the key. In addition, distinguishing a recently expired key from a key that has never been used may be impossible after a router restart.",
      "ja": "その意図した生涯範囲にわたって、「最近期限切れ」キーの使用O。この動作は、[OSPF3-AUTH-BIS]で、[RIP2-AUTH]での実装を推奨[OSPF2-AUTH]、および[OSPF3-AUTH]が、されていません。このキーのような使用は、オフラインでの暗号攻撃（セクション8の項目（F）を参照）またはキーの妥協点に、問題になることがあります。また、使用されていないキーから最近期限切れの鍵を区別することは、ルータの再起動後にできない場合があります。"
    },
    {
      "indent": 3,
      "text": "The design of this mechanism prevents automatic switching to unauthenticated exchange and is consistent with similar authentication mechanisms in this regard, but since the best choice between two other options depends on local site policy, this decision is left up to the operator rather than the implementor (in a way resembling the \"fail secure\" configuration knob described in Section 5.1 of [RIP2-AUTH]).",
      "ja": "このメカニズムの設計は、認証されていない交換機への自動切り替えを防止し、この点で類似した認証メカニズムと一致しているが、他の二つの選択肢の間で最良の選択は、ローカルサイトのポリシーに依存するため、この決定は、オペレータではなく、実装者（に任されていますように）RIP2-AUTH]のセクション5.1に記載された「安全な失敗」設定ノブに似ています。"
    },
    {
      "indent": 3,
      "text": "Although the deriving procedure does not allow for any exceptions in the filtering of expired keys (Section 5.2 item 2), the operator can trivially enforce one of the two remaining behaviour options through local key-management procedures. In particular, when using the key over its intended lifetime is preferable to regular traffic disruption, the operator would explicitly leave the old key expiry time open until the new key is added to the router configuration. In the opposite case, the operator would always configure the old key with a finite lifetime and bear associated risks.",
      "ja": "導出手順は、期限切れのキー（5.2節項目2）のフィルタリングに例外を許容しないが、オペレータは自明ローカル鍵管理手順を介して、残りの2つの動作オプションのいずれかを適用することができます。具体的には、その意図する寿命にわたってキーを使用している場合は、通常のトラフィックを中断することが好ましい、新しいキーは、ルータの設定に追加されるまで、明示的に開いて、古いキーの有効期限の時間を残して作業。逆の場合には、オペレータは、常に有限の寿命を持つ古いキーを設定し、関連するリスクを負担します。"
    },
    {
      "indent": 0,
      "text": "8. Security Considerations",
      "section_title": true,
      "ja": "8.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "The use of this mechanism implies requirements common to the use of shared authentication keys, including, but not limited to:",
      "ja": "このメカニズムの使用は、以下を含む共有認証キーの使用に共通の要件を意味し、これらに限定されません："
    },
    {
      "indent": 3,
      "text": "o holding the keys secret,",
      "ja": "秘密鍵を保持して、O、"
    },
    {
      "indent": 3,
      "text": "o including sufficient amounts of random bits into each key,",
      "ja": "各キーへのランダムビットの十分な量を含む、O、"
    },
    {
      "indent": 3,
      "text": "o rekeying on a regular basis, and",
      "ja": "定期的に再入力、およびO"
    },
    {
      "indent": 3,
      "text": "o never reusing a used key for a different purpose.",
      "ja": "O異なる目的のために使用されるキーを再利用することはありません。"
    },
    {
      "indent": 3,
      "text": "That said, proper design and implementation of a key-management policy are out of the scope of this work. Many publications on this subject exist and should be used for this purpose (BCP 107 [RFC4107], BCP 132 [RFC4962], and [RFC6039] are suggested as starting points).",
      "ja": "いえ、適切な設計とキー管理ポリシーの実装は、この作業の範囲外です。この主題に関する多くの刊行物が存在すると（出発点として示唆されているBCP 107 [RFC4107]、BCP 132 [RFC4962]及び[RFC6039]）は、この目的のために使用されるべきです。"
    },
    {
      "indent": 3,
      "text": "It is possible for a network that exercises rollover of authentication keys to experience accidental expiration of all the keys for a network interface, as discussed at greater length in Section 7.4. With that and the guidance of Section 5.1 of [RIP2-AUTH] in mind, in such an event the Babel speaker MUST send a \"last key expired\" notification to the operator (e.g., via syslog, SNMP, and/or other implementation-specific means), most likely in relation to item (b) of Section 5.5. Also, any actual occurrence of an authentication key expiration MUST cause a security event to be logged by the implementation. The log item MUST include at least a note that the authentication key has expired, the Babel routing protocol instance(s) affected, the network interface(s) affected, the LocalKeyID that is affected, and the current date/time. Operators are encouraged to check such logs as an operational security practice.",
      "ja": "これは、7.4節でより詳細に論じとして、ネットワーク・インターフェースのためにすべてのキーを誤って有効期限を体験するための認証キーのロールオーバーを行使するネットワークが可能です。このことを念頭に置いて、[RIP2-AUTH]のセクション5.1の指導では、バベルのスピーカーが送らなければなりません、そのような場合に、オペレータに通知を「最後のキーを期限切れ」（例えば、Syslog経由、SNMP、および/または他のインプリメンテーション5.5節の項目との関係（b）の中で最も可能性の高い具体的な手段）、。また、認証キーの有効期限のいずれかの実際の発生は、セキュリティイベントは、実装によってログに記録させなければなりません。ログ項目が認証キーの有効期限が切れていること少なくとも音符を含まなければなりません、バベルルーティングプロトコルインスタンス（複数可）の影響を受け、ネットワークインターフェース（単数または複数）の影響を受け、影響を受けLocalKeyID、現在の日付/時刻。オペレータは、運用上のセキュリティプラクティスとして、このようなログをチェックすることをお勧めします。"
    },
    {
      "indent": 3,
      "text": "Considering particular attacks being in scope or out of scope on one hand and measures taken to protect against particular in-scope attacks on the other, the original Babel protocol and this authentication mechanism are in line with similar datagram-based routing protocols and their respective mechanisms. In particular, the primary concerns addressed are:",
      "ja": "範囲内または範囲外の一方及び他方の上の特定のスコープ内の攻撃から保護するための措置である特定の攻撃を考慮すると、元のバベルプロトコルとこの認証メカニズムは、同様のデータグラムベースのルーティングプロトコルとそれらのそれぞれのメカニズムと一致しています。特に、対処主な関心事は、以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "a. Peer Entity Authentication",
      "ja": "A。エンティティ認証ピア"
    },
    {
      "indent": 7,
      "text": "The Babel speaker authentication mechanism defined herein is\nbelieved to be as strong as the class itself to which it belongs.\nThis specification is built on fundamental concepts implemented\nfor authentication of similar routing protocols: per-packet\nauthentication, the use of the HMAC construction, and the use of\nshared keys.  Although this design approach does not address all\npossible concerns, it is so far known to be sufficient for most\npractical cases.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "b. Data Integrity",
      "ja": "B。データの整合性"
    },
    {
      "indent": 7,
      "text": "Meaningful parts of a Babel datagram are the contents of the\nBabel packet (in the definition of Section 4.2 of [BABEL]) and\nthe source address of the datagram (Section 3.5.3 of [BABEL]).\nThis mechanism authenticates both parts, using the HMAC\nconstruction, so that making any meaningful change to an\nauthenticated packet after it has been emitted by the sender\nshould be as hard as attacking the HMAC construction itself or\nsuccessfully recovering the authentication key.",
      "raw": true
    },
    {
      "indent": 7,
      "text": "Note well that any trailing data of the Babel datagram is not meaningful in the scope of the original specification and does not belong to the Babel packet. Integrity of the trailing data is thus not protected by this mechanism. At the same time, although any TLV extra data is also not meaningful in the same scope, its integrity is protected, since this extra data is a part of the Babel packet (see Figure 2 in Appendix A).",
      "ja": "バベルデータグラムの末尾データは元の仕様の範囲に意味がないとバベルパケットに属していないことを十分に注意してください。後続データの整合性は、このように、このメカニズムによって保護されていません。任意TLVエクストラデータも同じ範囲に意味がありませんが、この追加データは、バベルパケット（付録Aで図2を参照）の一部であるので、同時に、その完全性が保護されています。"
    },
    {
      "indent": 3,
      "text": "c. Denial of Service",
      "ja": "C。サービス拒否"
    },
    {
      "indent": 7,
      "text": "Proper deployment of this mechanism in a Babel network\nsignificantly increases the efforts required for an attacker to\nfeed arbitrary Babel packets into a protocol exchange (with the\nintent of attacking a particular Babel speaker or disrupting the\nexchange of regular traffic in a routing domain).  It also\nprotects the neighbour table from being flooded with forged\nspeaker entries.",
      "raw": true
    },
    {
      "indent": 7,
      "text": "At the same time, this protection comes with a price of CPU time being spent on HMAC computations. This may be a concern for low-performance CPUs combined with high-speed interfaces, as sometimes seen in embedded systems and hardware routers. The MaxDigestsIn parameter, which is used to limit the maximum amount of CPU time spent on a single received Babel packet, addresses this concern to some extent.",
      "ja": "同時に、この保護は、HMAC計算に費やされたCPU時間の価格が付属しています。これは、時々、組み込みシステムとハードウェアのルータに見られる高速インタフェースと組み合わせる低性能のCPUのための懸念であってもよいです。単一受信バベルパケットに費やされたCPU時間の最大量を制限するために使用されるMaxDigestsInパラメータは、ある程度この問題に対処します。"
    },
    {
      "indent": 3,
      "text": "d. Reflection Attacks",
      "ja": "D。リフレクション攻撃"
    },
    {
      "indent": 7,
      "text": "Given the approach discussed in item (b), the only potential\nreflection attack on this mechanism could be replaying exact\ncopies of Babel packets back to the sender from the same source\naddress.  The mitigation in this case is straightforward and is\ndiscussed in Section 5.4.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The following in-scope concern is only partially addressed:",
      "ja": "以下のスコープ内の関心は、部分的にしか扱われます。"
    },
    {
      "indent": 3,
      "text": "e. Replay Attacks",
      "ja": "電子。リプレイ攻撃"
    },
    {
      "indent": 7,
      "text": "This specification establishes a basic replay protection measure\n(see Section 3.6), defines a timeout parameter affecting its\nstrength (see Section 3.7), and outlines implementation methods\nalso affecting protection strength in several ways (see\nSection 5.1).  The implementor's choice of the timeout value and\nparticular implementation methods may be suboptimal due to, for\nexample, insufficient hardware resources of the Babel speaker.",
      "raw": true
    },
    {
      "indent": 7,
      "text": "Furthermore, it may be possible that an operator configures the timeout and the methods to address particular local specifics, and this further weakens the protection. An operator concerned about replay attack protection strength should understand these factors and their meaning in a given network segment.",
      "ja": "また、オペレータがタイムアウトと特定のローカル仕様に対処する方法を構成し、これはさらなる保護を弱めることが可能であってもよいです。リプレイ攻撃防御力を懸念オペレータは、特定のネットワークセグメントにこれらの要因とその意味を理解しておく必要があります。"
    },
    {
      "indent": 7,
      "text": "That said, a particular form of replay attack on this mechanism remains possible anyway. Whether there are two or more network segments using the same CSA and there is an adversary that captures Babel packets on one segment and replays on another (and vice versa, due to the bidirectional reachability requirement for neighbourship), some of the speakers on one such segment will detect the \"virtual\" neighbours from another and may prefer them for some destinations. This applies even more so as Babel doesn't require a common pre-configured network prefix between neighbours.",
      "ja": "つまり、このメカニズムのリプレイ攻撃の特定の形態は、とにかく可能のまま、と述べました。スピーカーの一部、1つには、同一のCSAを使用して2つの以上のネットワークセグメントが存在し、（neighbourshipための双方向到達可能性要件に起因し、その逆の）一つのセグメントとリプレイ別上にバベルパケットをキャプチャ敵が存在するか否かセグメントは、別の「仮想」隣人を検出し、いくつかの目的地のためにそれらを好むかもしれません。バベルは、近隣諸国との間の共通事前に構成されたネットワークプレフィックスを必要としないので、これはそれ以上に適用されます。"
    },
    {
      "indent": 7,
      "text": "A reliable solution to this particular problem, which Section 4.5 of [RFC7186] discusses as well, is not currently known. It is recommended that the operators use distinct CSAs for distinct network segments.",
      "ja": "[RFC7186]のセクション4.5は、同様に説明し、この特定の問題に信頼性の高いソリューションは、現在知られていません。事業者が別個のネットワークセグメントに対して個別のCSAを使用することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "The following in-scope concerns are not addressed:",
      "ja": "以下のスコープ内の懸念に対処されていません。"
    },
    {
      "indent": 3,
      "text": "f. Offline Cryptographic Attacks",
      "ja": "F。オフライン暗号攻撃"
    },
    {
      "indent": 7,
      "text": "This mechanism is obviously subject to offline cryptographic\nattacks.  As soon as an attacker has obtained a copy of an\nauthenticated Babel packet of interest (which gets easier to do\nin wireless networks), he has all of the parameters of the\nauthentication-specific processing performed by the sender,\nexcept for authentication key(s) and the choice of particular\nhash algorithm(s).  Since digest lengths of common hash\nalgorithms are well known and can be matched with those seen in\nthe packet, the complexity of this attack is essentially that of\nthe authentication key attack.",
      "raw": true
    },
    {
      "indent": 7,
      "text": "Viewing the cryptographic strength of particular hash algorithms as a concern of its own, the main practical means of resisting offline cryptographic attacks on this mechanism are periodic rekeying and the use of strong keys with a sufficient number of random bits.",
      "ja": "独自の懸念として、特定のハッシュアルゴリズムの暗号強度を表示し、この機構にオフライン暗号攻撃に抵抗する主な実用的な手段は、定期的なリキーとランダム十分なビット数との強いキーの使用です。"
    },
    {
      "indent": 7,
      "text": "It is important to understand that in the case of multiple keys being used within a single interface (for multi-domain authentication or during a key rollover) the strength of the combined configuration would be that of the weakest key, since only one successful HMAC test is required for an authentic packet. Operators concerned about offline cryptographic attacks should enforce the same strength policy for all keys used for a given interface.",
      "ja": "唯一の成功したHMAC試験ので、（マルチドメイン認証用またはキーロールオーバ時）は、単一のインタフェース内で使用されている複数のキーの場合に合わせた構成の強度が最も弱いキーのものであろうことを理解することが重要です本物のパケットのために必要とされます。オフライン暗号攻撃を懸念オペレータは、特定のインターフェイスのために使用されるすべてのキーの同じ強さのポリシーを適用する必要があります。"
    },
    {
      "indent": 7,
      "text": "Note that a special pathological case is possible with this mechanism. Whenever two or more authentication keys are configured for a given interface such that all keys share the same AuthKeyOctets and the same HashAlgo, but LocalKeyID modulo 2^16 is different for each key, these keys will not be treated as duplicate (Section 5.2 item 4), but an HMAC result computed for a given packet will be the same for each of these keys. In the case of the sending procedure, this can produce multiple HMAC TLVs with exactly the same value of the Digest field but different values of the KeyID field. In this case, the attacker will see that the keys are the same, even without knowledge of the key itself. The reuse of authentication keys is not the intended use case of this mechanism and should be strongly avoided.",
      "ja": "特別な病的な場合は、このメカニズムで可能であることに注意してください。二つ以上の認証鍵は、すべてのキーが同じAuthKeyOctetsと同じHashAlgoを共有するが、モジュロ2 ^ 16は、各キーごとに異なるLocalKeyIDように、所定のインターフェイスのために設定されているときはいつでも、これらのキーは（重複セクション5.2項目4として扱われることはありません）、所与のパケットに対して計算が、HMAC結果は、これらのキーの各々に対して同じです。送信手順の場合、これは正確ダイジェストフィールドの同じ値が、KeyIDをフィールドの異なる値を持つ複数のHMAC TLVを生成することができます。この場合、攻撃者はさらに、キー自体の知識がなくても、キーが同じであることがわかります。認証キーの再利用は、このメカニズムの使用目的の場合ではないと強く避けるべきです。"
    },
    {
      "indent": 3,
      "text": "g. Non-repudiation",
      "ja": "グラム。否認防止"
    },
    {
      "indent": 7,
      "text": "This specification relies on the use of shared keys.  There is no\ntimestamp infrastructure and no key-revocation mechanism defined\nto address the compromise of a shared key.  Establishing the time\nthat a particular authentic Babel packet was generated is thus\nnot possible.  Proving that a particular Babel speaker had\nactually sent a given authentic packet is also impossible as soon\nas the shared key is claimed compromised.  Even if the shared key\nis not compromised, reliably identifying the speaker that had\nactually sent a given authentic Babel packet is not possible.\nSince any of the speakers sharing a key can impersonate any other\nspeaker sharing the same key, it is only possible to prove that\nthe speaker belongs to the group sharing the key.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "h. Confidentiality Violations",
      "ja": "時間。守秘義務違反"
    },
    {
      "indent": 7,
      "text": "The original Babel protocol does not encrypt any of the\ninformation contained in its packets.  The contents of a Babel\npacket are trivial to decode and thus can reveal network topology\ndetails.  This mechanism does not improve this situation in any\nway.  Since routing protocol messages are not the only kind of\ninformation subject to confidentiality concerns, a complete\nsolution to this problem is likely to include measures based on\nthe channel security model, such as IPsec and Wi-Fi Protected\nAccess 2 (WPA2) at the time of this writing.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "i. Key Management",
      "ja": "私。キー管理"
    },
    {
      "indent": 7,
      "text": "Any authentication key exchange/distribution concerns are out of\nscope.  However, the internal representation of authentication\nkeys (see Section 3.8) allows implementations to use such diverse\nkey-management techniques as manual configuration, a provisioning\nsystem, a key-management protocol, or any other means that comply\nwith this specification.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "j. Message Deletion",
      "ja": "J。メッセージの削除"
    },
    {
      "indent": 7,
      "text": "Any message deletion attacks are out of scope.  Since a datagram\ndeleted by an attacker cannot be distinguished from a datagram\nnaturally lost in transmission, and since datagram-based routing\nprotocols are designed to withstand a certain loss of packets, the currently established practice is treating authentication\npurely as a per-packet function, without any added detection of\nlost packets.",
      "raw": true
    },
    {
      "indent": 0,
      "text": "9. IANA Considerations",
      "section_title": true,
      "ja": "9. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "At the time of publication of this document, the Babel TLV Types namespace did not have an IANA registry. TLV types 11 and 12 were assigned (see Table 1 in Appendix A) to the TS/PC and HMAC TLV types by Juliusz Chroboczek, designer of the original Babel protocol. Therefore, this document has no IANA actions.",
      "ja": "このドキュメントの公開時点で、バベルTLVタイプの名前空間はIANAレジストリを持っていませんでした。 TLVタイプ11及び12は、TS / PCとはJuliusz Chroboczek、オリジナルバベルプロトコルの設計者によってHMAC TLVタイプに（付録Aの表1参照）を割り当てました。したがって、このドキュメントには、IANAのアクションを持っていません。"
    },
    {
      "indent": 0,
      "text": "10. Acknowledgements",
      "section_title": true,
      "ja": "10.謝辞"
    },
    {
      "indent": 3,
      "text": "Thanks to Randall Atkinson and Matthew Fanto for their comprehensive work on [RIP2-AUTH] that initiated a series of publications on routing protocol authentication, including this one. This specification adopts many concepts belonging to the whole series.",
      "ja": "この1を含むルーティングプロトコル認証の出版物のシリーズを開始した[RIP2-AUTH]で自分の包括的な仕事のためのランドール・アトキンソンとマシューFantoに感謝します。この仕様は、全シリーズに属する多くの概念を採用しています。"
    },
    {
      "indent": 3,
      "text": "Thanks to Juliusz Chroboczek, Gabriel Kerneis, and Matthieu Boutier. This document incorporates many technical and editorial corrections based on their feedback. Thanks to all contributors to Babel, because this work would not be possible without the prior works. Thanks to Dominic Mulligan for editorial proofreading of this document. Thanks to Riku Hietamaki for suggesting the test vectors section.",
      "ja": "Juliusz Chroboczek、ガブリエルKerneis、そしてマシューBoutierに感謝します。この文書では、彼らのフィードバックに基づいて、多くの技術的、編集上の修正が組み込まれています。バベルのすべての貢献のおかげで、この作品は前作品なしには不可能であろうからです。このドキュメントの編集校正のためのドミニク・マリガンに感謝します。テストベクトルのセクションを示唆ためのリクHietamakiに感謝します。"
    },
    {
      "indent": 3,
      "text": "Thanks to Joel Halpern, Jim Schaad, Randall Atkinson, and Stephen Farrell for providing (in chronological order) valuable feedback on earlier versions of this document.",
      "ja": "このドキュメントの以前のバージョンで（古い順に）貴重なフィードバックを提供するためのジョエル・ハルパーン、ジムSchaad、ランドール・アトキンソン、そしてステファン・ファレルに感謝します。"
    },
    {
      "indent": 3,
      "text": "Thanks to Jim Gettys and Dave Taht for developing the CeroWrt wireless router project and collaborating on many integration issues. A practical need for Babel authentication emerged during research based on CeroWrt that eventually became the very first use case of this mechanism.",
      "ja": "CeroWrt無線ルータのプロジェクトを開発し、多くの統合問題を共同のためのジム・ゲティーズとDave Tahtに感謝します。バベル認証のための実用的な必要性は、最終的には、このメカニズムの非常に最初のユースケースとなりましたCeroWrtに基づいて研究中に現れました。"
    },
    {
      "indent": 3,
      "text": "Thanks to Kunihiro Ishiguro and Paul Jakma for establishing the GNU Zebra and Quagga routing software projects, respectively. Thanks to Werner Koch, the author of Libgcrypt. The very first implementation of this mechanism was made on a base of Quagga and Libgcrypt.",
      "ja": "それぞれ、GNU ZebraのとのQuaggaルーティングソフトウェアプロジェクトを確立するための国広石黒とポールJakmaに感謝します。ワーナー・コック、あるlibgcryptの作者に感謝します。この機構の非常に最初の実装は、Quaggaのとあるlibgcryptのベースに作られました。"
    },
    {
      "indent": 0,
      "text": "11. References",
      "section_title": true,
      "ja": "11.参考文献"
    },
    {
      "indent": 0,
      "text": "11.1. Normative References",
      "section_title": true,
      "ja": "11.1. 引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC2104] Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, February 1997.",
      "ja": "[RFC2104] Krawczyk、H.、ベラー、M.、およびR.カネッティ、 \"HMAC：メッセージ認証のための鍵付きハッシュ化\"、RFC 2104、1997年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC4291] Hinden, R. and S. Deering, \"IP Version 6 Addressing Architecture\", RFC 4291, February 2006.",
      "ja": "[RFC4291] HindenとR.とS.デアリング、 \"IPバージョン6アドレッシング体系\"、RFC 4291、2006年2月。"
    },
    {
      "indent": 3,
      "text": "[FIPS-198] National Institute of Standards and Technology, \"The Keyed-Hash Message Authentication Code (HMAC)\", FIPS PUB 198-1, July 2008.",
      "ja": "[FIPS-198]アメリカ国立標準技術研究所、 \"鍵付きハッシュメッセージ認証コード（HMAC）\"、FIPS PUBの198から1、2008年7月。"
    },
    {
      "indent": 3,
      "text": "[BABEL] Chroboczek, J., \"The Babel Routing Protocol\", RFC 6126, April 2011.",
      "ja": "[BABEL] Chroboczek、J.、 \"バベルルーティングプロトコル\"、RFC 6126、2011年4月。"
    },
    {
      "indent": 0,
      "text": "11.2. Informative References",
      "section_title": true,
      "ja": "11.2. 参考文献"
    },
    {
      "indent": 3,
      "text": "[RFC3315] Droms, R., Bound, J., Volz, B., Lemon, T., Perkins, C., and M. Carney, \"Dynamic Host Configuration Protocol for IPv6 (DHCPv6)\", RFC 3315, July 2003.",
      "ja": "[RFC3315] Droms、R.、バウンド、J.、フォルツ、B.、レモン、T.、パーキンス、C.、およびM.カーニー、 \"IPv6のための動的ホスト構成プロトコル（DHCPv6）\"、RFC 3315、2003年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC3931] Lau, J., Townsley, M., and I. Goyret, \"Layer Two Tunneling Protocol - Version 3 (L2TPv3)\", RFC 3931, March 2005.",
      "ja": "[RFC3931]ラウ、J.、Townsley、M.、およびI. Goyret、 \"レイヤ2トンネリングプロトコル - バージョン3（L2TPv3の）\"、RFC 3931、2005年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC4030] Stapp, M. and T. Lemon, \"The Authentication Suboption for the Dynamic Host Configuration Protocol (DHCP) Relay Agent Option\", RFC 4030, March 2005.",
      "ja": "[RFC4030]スタップ、M.とT.レモン、「認証サブオプション動的ホスト構成プロトコル（DHCP）リレーエージェントオプション」、RFC 4030、2005年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC4107] Bellovin, S. and R. Housley, \"Guidelines for Cryptographic Key Management\", BCP 107, RFC 4107, June 2005.",
      "ja": "[RFC4107] Bellovin氏、S.とR. Housley氏、 \"暗号鍵管理のためのガイドライン\"、BCP 107、RFC 4107、2005年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC4270] Hoffman, P. and B. Schneier, \"Attacks on Cryptographic Hashes in Internet Protocols\", RFC 4270, November 2005.",
      "ja": "[RFC4270]ホフマン、P.とB.シュナイアー、 \"インターネットプロトコルで暗号化ハッシュに対する攻撃\"、RFC 4270、2005年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC4302] Kent, S., \"IP Authentication Header\", RFC 4302, December 2005.",
      "ja": "[RFC4302]ケント、S.、 \"IP認証ヘッダー\"、RFC 4302、2005年12月。"
    },
    {
      "indent": 3,
      "text": "[RIP2-AUTH] Atkinson, R. and M. Fanto, \"RIPv2 Cryptographic Authentication\", RFC 4822, February 2007.",
      "ja": "[RIP2-AUTH]アトキンソン、R.とM. Fanto、 \"RIPv2の暗号化認証\"、RFC 4822、2007年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC4962] Housley, R. and B. Aboba, \"Guidance for Authentication, Authorization, and Accounting (AAA) Key Management\", BCP 132, RFC 4962, July 2007.",
      "ja": "[RFC4962] Housley氏、R。およびB. Aboba、 \"認証、許可、アカウンティング（AAA）キー管理のための指針\"、BCP 132、RFC 4962、2007年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC5176] Chiba, M., Dommety, G., Eklund, M., Mitton, D., and B. Aboba, \"Dynamic Authorization Extensions to Remote Authentication Dial In User Service (RADIUS)\", RFC 5176, January 2008.",
      "ja": "、RFC 5176、2008年1月[RFC5176]千葉、M.、Dommety、G.、エクランド、M.、ミトン、D.、およびB. Aboba、 \"ユーザーサービス（RADIUS）でリモート認証ダイヤルへのダイナミックな承認拡張機能\"。"
    },
    {
      "indent": 3,
      "text": "[ISIS-AUTH-A] Li, T. and R. Atkinson, \"IS-IS Cryptographic Authentication\", RFC 5304, October 2008.",
      "ja": "[ISIS-AUTH-A]のLi、T.及びR.アトキンソン、 \"ISIS暗号化認証\"、RFC 5304、2008年10月。"
    },
    {
      "indent": 3,
      "text": "[ISIS-AUTH-B] Bhatia, M., Manral, V., Li, T., Atkinson, R., White, R., and M. Fanto, \"IS-IS Generic Cryptographic Authentication\", RFC 5310, February 2009.",
      "ja": "[ISIS-AUTH-B] Bhatiaは、M.、Manral、V.、李、T.、アトキンソン、R.、ホワイト、R.、およびM. Fanto、 \"ISIS汎用暗号化認証\"、RFC 5310年2月2009。"
    },
    {
      "indent": 3,
      "text": "[OSPF2-AUTH] Bhatia, M., Manral, V., Fanto, M., White, R., Barnes, M., Li, T., and R. Atkinson, \"OSPFv2 HMAC-SHA Cryptographic Authentication\", RFC 5709, October 2009.",
      "ja": "[OSPF2-AUTH] Bhatiaは、M.、Manral、V.、Fanto、M.、ホワイト、R.、バーンズ、M.、李、T.、およびR.アトキンソン、 \"OSPFv2のHMAC-SHA暗号化認証\"、RFC 5709、2009年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC6039] Manral, V., Bhatia, M., Jaeggli, J., and R. White, \"Issues with Existing Cryptographic Protection Methods for Routing Protocols\", RFC 6039, October 2010.",
      "ja": "[RFC6039] Manral、V.、バティア、M.、Jaeggli、J.、およびR.ホワイト、 \"ルーティングプロトコルのための既存の暗号化保護方法の問題\"、RFC 6039、2010年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC6151] Turner, S. and L. Chen, \"Updated Security Considerations for the MD5 Message-Digest and the HMAC-MD5 Algorithms\", RFC 6151, March 2011.",
      "ja": "[RFC6151]ターナー、S.とL.チェン、 \"MD5メッセージダイジェストとHMAC-MD5アルゴリズムのための更新されたセキュリティ上の考慮事項\"、RFC 6151、2011年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC6194] Polk, T., Chen, L., Turner, S., and P. Hoffman, \"Security Considerations for the SHA-0 and SHA-1 Message-Digest Algorithms\", RFC 6194, March 2011.",
      "ja": "[RFC6194]ポーク、T.、陳、L.、ターナー、S.、およびP.ホフマン、 \"SHA-0およびSHA-1メッセージダイジェストアルゴリズムのためのセキュリティの考慮事項\"、RFC 6194、2011年3月。"
    },
    {
      "indent": 3,
      "text": "[OSPF3-AUTH] Bhatia, M., Manral, V., and A. Lindem, \"Supporting Authentication Trailer for OSPFv3\", RFC 6506, February 2012.",
      "ja": "[OSPF3-AUTH] Bhatiaは、M.、Manral、V.、およびA. Lindem、 \"OSPFv3のための支持認証トレーラー\"、RFC 6506、2012年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC6709] Carpenter, B., Aboba, B., and S. Cheshire, \"Design Considerations for Protocol Extensions\", RFC 6709, September 2012.",
      "ja": "[RFC6709]大工、B.、Aboba、B.、およびS.チェシャー、 \"プロトコル拡張のための設計上の考慮事項\"、RFC 6709、2012年9月。"
    },
    {
      "indent": 3,
      "text": "[BABEL-EXTENSION] Chroboczek, J., \"Extension Mechanism for the Babel Routing Protocol\", Work in Progress, June 2014.",
      "ja": "[BABEL-EXTENSION] Chroboczek、J.、 \"バベルルーティングプロトコルのための拡張機構\"、進歩、2014年6月に働いています。"
    },
    {
      "indent": 3,
      "text": "[OSPF3-AUTH-BIS] Bhatia, M., Manral, V., and A. Lindem, \"Supporting Authentication Trailer for OSPFv3\", RFC 7166, March 2014.",
      "ja": "[OSPF3-AUTH-BIS] Bhatiaは、M.、Manral、V.、およびA. Lindem、 \"OSPFv3のための支持認証トレーラー\"、RFC 7166、2014年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC7183] Herberg, U., Dearlove, C., and T. Clausen, \"Integrity Protection for the Neighborhood Discovery Protocol (NHDP) and Optimized Link State Routing Protocol Version 2 (OLSRv2)\", RFC 7183, April 2014.",
      "ja": "[RFC7183] Herberg、U.、Dearlove、C.、およびT.クラウゼン、 \"近所Discovery Protocolのための完全性保護（NHDP）と最適化されたリンクステートルーティングプロトコルバージョン2（OLSRv2）\"、RFC 7183、2014年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC7186] Yi, J., Herberg, U., and T. Clausen, \"Security Threats for the Neighborhood Discovery Protocol (NHDP)\", RFC 7186, April 2014.",
      "ja": "[RFC7186]李、J.、Herberg、U.、およびT. Clausenの、 \"近隣探索プロトコル（NHDP）のセキュリティの脅威\"、RFC 7186、2014年4月。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Figures and Tables",
      "ja": "付録A.の図表"
    },
    {
      "indent": 6,
      "text": "+-------------------------------------------------------------+\n|              authentication-specific statistics             |\n+-------------------------------------------------------------+\n  ^                            |                            ^\n  |                            v                            |\n  |    +-----------------------------------------------+    |\n  |    |                system operator                |    |\n  |    +-----------------------------------------------+    |\n  |        ^ |      ^ |       ^ |       ^ |      ^ |        |\n  |        | v      | |       | |       | |      | v        |\n+---+  +---------+  | |       | |       | |  +---------+  +---+\n|   |->|   ANM   |  | |       | |       | |  | LocalTS |->|   |\n| R |<-|  table  |  | |       | |       | |  | LocalPC |<-| T |\n| x |  +---------+  | v       | v       | v  +---------+  | x |\n|   |  +----------------+ +---------+ +----------------+  |   |\n| p |  | MaxDigestsIn   | |         | | MaxDigestsOut  |  | p |\n| r |<-| ANM timeout    | |  CSAs   | |                |->| r |\n| o |  | RxAuthRequired | |         | |                |  | o |\n| c |  +----------------+ +---------+ +----------------+  | c |\n| e |  +-------------+     |       |     +-------------+  | e |\n| s |  |   Rx ESAs   |     |       |     |   Tx ESAs   |  | s |\n| s |<-| (temporary) |<----+       +---->| (temporary) |->| s |\n| i |  +-------------+                   +-------------+  | i |\n| n |  +------------------------------+----------------+  | n |\n| g |  |     instance of              | output buffers |=>| g |\n|   |=>|     the original             +----------------+  |   |\n|   |  |     protocol                 | source address |->|   |\n+---+  +------------------------------+----------------+  +---+\n /\\                                            |            ||\n ||                                            v            \\/\n+-------------------------------------------------------------+\n|                        network stack                        |\n+-------------------------------------------------------------+\n   /\\ ||       /\\ ||                       /\\ ||       /\\ ||\n   || \\/       || \\/                       || \\/       || \\/\n+---------+ +---------+                 +---------+ +---------+\n| speaker | | speaker |       ...       | speaker | | speaker |\n+---------+ +---------+                 +---------+ +---------+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Flow of control data           : --->\nFlow of Babel datagrams/packets: ===>",
      "raw": true
    },
    {
      "indent": 23,
      "text": "Figure 1: Interaction Diagram",
      "ja": "図1：相互作用図"
    },
    {
      "indent": 3,
      "text": "               P\n|<---------------------------->|                                 (D1)\n|                B             |\n|  |<------------------------->|\n|  |                           |\n+--+-----+-----+...+-----+-----+--+   P: Babel packet\n|H |some |some |   |some |some |T |   H: Babel packet header\n|  |TLV  |TLV  |   |TLV  |TLV  |  |   B: Babel packet body\n|  |     |     |   |     |     |  |   T: optional trailing data block\n+--+-----+-----+...+-----+-----+--+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "                            P\n|<----------------------------------------------------->|        (D2)\n|                             B                         |\n|  |<-------------------------------------------------->|\n|  |                                                    |\n+--+-----+-----+...+-----+-----+------+------+...+------+--+\n|H |some |some |   |some |some |TS/PC |HMAC  |   |HMAC  |T |\n|  |TLV  |TLV  |   |TLV  |TLV  |TLV   |TLV 1 |   |TLV n |  |\n|  |     |     |   |     |     |      |      |   |      |  |\n+--+-----+-----+...+-----+-----+------+------+...+------+--+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "                            P\n|<----------------------------------------------------->|        (D3)\n|                             B                         |\n|  |<-------------------------------------------------->|\n|  |                                                    |\n+--+------+------+...+------+-----+-----+...+-----+-----+--+\n|H |TS/PC |HMAC  |   |HMAC  |some |some |   |some |some |T |\n|  |TLV   |TLV 1 |   |TLV n |TLV  |TLV  |   |TLV  |TLV  |  |\n|  |      |      |   |      |     |     |   |     |     |  |\n+--+------+------+...+------+-----+-----+...+-----+-----+--+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "                               P\n|<------------------------------------------------------------>| (D4)\n|                                B                             |\n|  |<--------------------------------------------------------->|\n|  |                                                           |\n+--+-----+------+-----+------+...+-----+------+...+------+-----+--+\n|H |some |HMAC  |some |HMAC  |   |some |HMAC  |   |TS/PC |some |T |\n|  |TLV  |TLV 1 |TLV  |TLV 2 |   |TLV  |TLV n |   |TLV   |TLV  |  |\n|  |     |      |     |      |   |     |      |   |      |     |  |\n+--+-----+------+-----+------+...+-----+------+...+------+-----+--+",
      "raw": true
    },
    {
      "indent": 20,
      "text": "Figure 2: Babel Datagram Structure",
      "ja": "図2：バベルデータグラムの構造"
    },
    {
      "indent": 12,
      "text": "+-------+-------------------------+---------------+\n| Value | Name                    | Reference     |\n+-------+-------------------------+---------------+\n|     0 | Pad1                    | [BABEL]       |\n|     1 | PadN                    | [BABEL]       |\n|     2 | Acknowledgement Request | [BABEL]       |\n|     3 | Acknowledgement         | [BABEL]       |\n|     4 | Hello                   | [BABEL]       |\n|     5 | IHU                     | [BABEL]       |\n|     6 | Router-Id               | [BABEL]       |\n|     7 | Next Hop                | [BABEL]       |\n|     8 | Update                  | [BABEL]       |\n|     9 | Route Request           | [BABEL]       |\n|    10 | Seqno Request           | [BABEL]       |\n|    11 | TS/PC                   | this document |\n|    12 | HMAC                    | this document |\n+-------+-------------------------+---------------+",
      "raw": true
    },
    {
      "indent": 19,
      "text": "Table 1: Babel TLV Types 0 through 12",
      "ja": "表1：バベルTLVタイプ12 0〜"
    },
    {
      "indent": 4,
      "text": "+--------------+-----------------------------+-------------------+\n| Packet field | Packet octets (hexadecimal) | Meaning (decimal) |\n+--------------+-----------------------------+-------------------+\n| Magic        | 2a                          | 42                |\n| Version      | 02                          | version 2         |\n| Body length  | 00:14                       | 20 octets         |\n| [TLV] Type   | 04                          | 4 (Hello)         |\n| [TLV] Length | 06                          | 6 octets          |\n| Reserved     | 00:00                       | no meaning        |\n| Seqno        | 09:25                       | 2341              |\n| Interval     | 01:90                       | 400 (4.00 s)      |\n| [TLV] Type   | 08                          | 8 (Update)        |\n| [TLV] Length | 0a                          | 10 octets         |\n| AE           | 00                          | 0 (wildcard)      |\n| Flags        | 40                          | default router-id |\n| Plen         | 00                          | 0 bits            |\n| Omitted      | 00                          | 0 bits            |\n| Interval     | ff:ff                       | infinity          |\n| Seqno        | 68:21                       | 26657             |\n| Metric       | ff:ff                       | infinity          |\n+--------------+-----------------------------+-------------------+",
      "raw": true
    },
    {
      "indent": 12,
      "text": "Table 2: A Babel Packet without Authentication TLVs",
      "ja": "テーブル2：認証のTLVなしにバベルパケット"
    },
    {
      "indent": 3,
      "text": "+---------------+-------------------------------+-------------------+\n| Packet field  | Packet octets (hexadecimal)   | Meaning (decimal) |\n+---------------+-------------------------------+-------------------+\n| Magic         | 2a                            | 42                |\n| Version       | 02                            | version 2         |\n| Body length   | 00:4c                         | 76 octets         |\n| [TLV] Type    | 04                            | 4 (Hello)         |\n| [TLV] Length  | 06                            | 6 octets          |\n| Reserved      | 00:00                         | no meaning        |\n| Seqno         | 09:25                         | 2341              |\n| Interval      | 01:90                         | 400 (4.00 s)      |\n| [TLV] Type    | 08                            | 8 (Update)        |\n| [TLV] Length  | 0a                            | 10 octets         |\n| AE            | 00                            | 0 (wildcard)      |\n| Flags         | 40                            | default router-id |\n| Plen          | 00                            | 0 bits            |\n| Omitted       | 00                            | 0 bits            |\n| Interval      | ff:ff                         | infinity          |\n| Seqno         | 68:21                         | 26657             |\n| Metric        | ff:ff                         | infinity          |\n| [TLV] Type    | 0b                            | 11 (TS/PC)        |\n| [TLV] Length  | 06                            | 6 octets          |\n| PacketCounter | 00:01                         | 1                 |\n| Timestamp     | 52:1d:7e:8b                   | 1377664651        |\n| [TLV] Type    | 0c                            | 12 (HMAC)         |\n| [TLV] Length  | 16                            | 22 octets         |\n| KeyID         | 00:c8                         | 200               |\n| Digest        | fe:80:00:00:00:00:00:00:0a:11 | padding           |\n|               | 96:ff:fe:1c:10:c8:00:00:00:00 |                   |\n| [TLV] Type    | 0c                            | 12 (HMAC)         |\n| [TLV] Length  | 16                            | 22 octets         |\n| KeyID         | 00:64                         | 100               |\n| Digest        | fe:80:00:00:00:00:00:00:0a:11 | padding           |\n|               | 96:ff:fe:1c:10:c8:00:00:00:00 |                   |\n+---------------+-------------------------------+-------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Table 3: A Babel Packet with Each HMAC TLV Padded Using IPv6 Address fe80::0a11:96ff:fe1c:10c8",
      "ja": "表3：96ff：fe1c：10c8のIPv6アドレスFE80 :: 0a11を使用して、各HMAC TLVパッド入りでバベルパケット"
    },
    {
      "indent": 3,
      "text": "+---------------+-------------------------------+-------------------+\n| Packet field  | Packet octets (hexadecimal)   | Meaning (decimal) |\n+---------------+-------------------------------+-------------------+\n| Magic         | 2a                            | 42                |\n| Version       | 02                            | version 2         |\n| Body length   | 00:4c                         | 76 octets         |\n| [TLV] Type    | 04                            | 4 (Hello)         |\n| [TLV] Length  | 06                            | 6 octets          |\n| Reserved      | 00:00                         | no meaning        |\n| Seqno         | 09:25                         | 2341              |\n| Interval      | 01:90                         | 400 (4.00 s)      |\n| [TLV] Type    | 08                            | 8 (Update)        |\n| [TLV] Length  | 0a                            | 10 octets         |\n| AE            | 00                            | 0 (wildcard)      |\n| Flags         | 40                            | default router-id |\n| Plen          | 00                            | 0 bits            |\n| Omitted       | 00                            | 0 bits            |\n| Interval      | ff:ff                         | infinity          |\n| Seqno         | 68:21                         | 26657             |\n| Metric        | ff:ff                         | infinity          |\n| [TLV] Type    | 0b                            | 11 (TS/PC)        |\n| [TLV] Length  | 06                            | 6 octets          |\n| PacketCounter | 00:01                         | 1                 |\n| Timestamp     | 52:1d:7e:8b                   | 1377664651        |\n| [TLV] Type    | 0c                            | 12 (HMAC)         |\n| [TLV] Length  | 16                            | 22 octets         |\n| KeyID         | 00:c8                         | 200               |\n| Digest        | c6:f1:06:13:30:3c:fa:f3:eb:5d | HMAC result       |\n|               | 60:3a:ed:fd:06:55:83:f7:ee:79 |                   |\n| [TLV] Type    | 0c                            | 12 (HMAC)         |\n| [TLV] Length  | 16                            | 22 octets         |\n| KeyID         | 00:64                         | 100               |\n| Digest        | df:32:16:5e:d8:63:16:e5:a6:4d | HMAC result       |\n|               | c7:73:e0:b5:22:82:ce:fe:e2:3c |                   |\n+---------------+-------------------------------+-------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Table 4: A Babel Packet with Each HMAC TLV Containing an HMAC Result",
      "ja": "表4：HMACの結果を含む各HMAC TLVとバベルパケット"
    },
    {
      "indent": 0,
      "text": "Appendix B. Test Vectors",
      "ja": "付録B.テストベクトル"
    },
    {
      "indent": 3,
      "text": "The test vectors below may be used to verify the correctness of some procedures performed by an implementation of this mechanism, namely:",
      "ja": "以下テストベクトル、すなわち、このメカニズムの実装によって実行されるいくつかの手順の正当性を検証するために使用されてもよいです。"
    },
    {
      "indent": 3,
      "text": "o appending TS/PC and HMAC TLVs to the Babel packet body,",
      "ja": "バベルパケット本体にTS / PCとHMAC TLVを追加し、O、"
    },
    {
      "indent": 3,
      "text": "o padding the HMAC TLV(s),",
      "ja": "HMAC TLV（単数または複数）をパディングO、"
    },
    {
      "indent": 3,
      "text": "o computation of the HMAC result(s), and",
      "ja": "HMAC結果（単数または複数）のO計算、及び"
    },
    {
      "indent": 3,
      "text": "o placement of the result(s) in the TLV(s).",
      "ja": "TLV（S）における結果（単数または複数）のO配置。"
    },
    {
      "indent": 3,
      "text": "This verification isn't exhaustive. There are other important implementation aspects that would require testing methods of their own.",
      "ja": "この検証は網羅的なものではありません。自分自身の試験方法を必要とする他の重要なインプリメンテーションの側面があります。"
    },
    {
      "indent": 3,
      "text": "The test vectors were produced as follows.",
      "ja": "次のようにテストベクトルを作製しました。"
    },
    {
      "indent": 3,
      "text": "1. A Babel speaker with a network interface with IPv6 link-local address fe80::0a11:96ff:fe1c:10c8 was configured to use two CSAs for the interface:",
      "ja": "IPv6リンクローカルアドレスFE80 :: 0a11とのネットワークインタフェース1. Aバベルスピーカー：96ff：fe1c：10c8は、インタフェースのための2つのCSAを使用するように構成されました。"
    },
    {
      "indent": 7,
      "text": "*  CSA1={HashAlgo=RIPEMD-160, KeyChain={{LocalKeyID=200,\n   AuthKeyOctets=Key26}}}",
      "raw": true
    },
    {
      "indent": 7,
      "text": "* CSA2={HashAlgo=SHA-1, KeyChain={{LocalKeyId=100, AuthKeyOctets=Key70}}}",
      "ja": "* CSA2 = {HashAlgo = SHA-1キーチェーン= {{LocalKeyId = 100、AuthKeyOctets = Key70}}}"
    },
    {
      "indent": 7,
      "text": "The authentication keys above are:",
      "ja": "上記認証キーは、次のとおりです。"
    },
    {
      "indent": 7,
      "text": "* Key26 in ASCII:",
      "ja": "* ASCIIでKey26："
    },
    {
      "indent": 10,
      "text": "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
      "ja": "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    },
    {
      "indent": 7,
      "text": "* Key26 in hexadecimal:",
      "ja": "* 16進数でKey26："
    },
    {
      "indent": 10,
      "text": "41:42:43:44:45:46:47:48:49:4a:4b:4c:4d:4e:4f:50 51:52:53:54:55:56:57:58:59:5a",
      "ja": "41：42：NF：HH：45：CHSH：chsht：48：chya：チャ：BW：chts：CHD：その：PRS：50 51：52：53：54：55：56：57：58：59：5"
    },
    {
      "indent": 7,
      "text": "* Key70 in ASCII:",
      "ja": "* ASCIIでKey70："
    },
    {
      "indent": 2,
      "text": "This=key=is=exactly=70=octets=long.=ABCDEFGHIJKLMNOPQRSTUVWXYZ01234567",
      "ja": "これは、キー= = =で正確に= 70 =オクテット=長い。= ABCDEFGHIJKLMNOPQRSTUVWXYZ01234567"
    },
    {
      "indent": 7,
      "text": "* Key70 in hexadecimal:",
      "ja": "* 16進数でKey70："
    },
    {
      "indent": 10,
      "text": "54:68:69:73:3d:6b:65:79:3d:69:73:3d:65:78:61:63 74:6c:79:3d:37:30:3d:6f:63:74:65:74:73:3d:6c:6f 6e:67:2e:3d:41:42:43:44:45:46:47:48:49:4a:4b:4c 4d:4e:4f:50:51:52:53:54:55:56:57:58:59:5a:30:31 32:33:34:35:36:37",
      "ja": "54：68：69：73：3D：6B：65：79：3D：69：73：3D：65：78：61：63 74：6C：79：3D：37：30：3D：6F：63：74 ：65：74：73：3D：6C：6Fの6E：67：2E：3D：41：42：43：44：45：46：47：48：49：4A：図4b：4cは4D：4E：4F：50 ：51：52：53：54：55：56：57：58：59：5A：30：31 32：33：34：35：36：37"
    },
    {
      "indent": 7,
      "text": "The length of each key was picked to relate (using the terms listed in Section 2.4) to the properties of its respective hash algorithm as follows:",
      "ja": "各キーの長さは、以下のようにそれぞれのハッシュアルゴリズムの特性（2.4節に記載されている用語を使用して）関連付けるために選ばれました。"
    },
    {
      "indent": 7,
      "text": "* the digest length (L) of both RIPEMD-160 and SHA-1 is 20 octets,",
      "ja": "* RIPEMD-160およびSHA-1の両方のダイジェスト長さ（L）は、20オクテットであります"
    },
    {
      "indent": 7,
      "text": "* the internal block size (B) of both RIPEMD-160 and SHA-1 is 64 octets,",
      "ja": "* RIPEMD-160およびSHA-1の両方の内部ブロックサイズ（B）は、64オクテットであります"
    },
    {
      "indent": 7,
      "text": "* the length of Key26 (26) is greater than L but less than B, and",
      "ja": "* Key26（26）の長さがLより大きくB以下である、及び"
    },
    {
      "indent": 7,
      "text": "* the length of Key70 (70) is greater than B (and thus greater than L).",
      "ja": "* Key70（70）の長さBよりも（したがって、より大きいLより）大きいです。"
    },
    {
      "indent": 7,
      "text": "KeyStartAccept, KeyStopAccept, KeyStartGenerate, and KeyStopGenerate were set to make both authentication keys valid.",
      "ja": "KeyStartAccept、KeyStopAccept、KeyStartGenerate、およびKeyStopGenerateは、両方の認証キーが有効にするために設定しました。"
    },
    {
      "indent": 3,
      "text": "2. The instance of the original protocol of the speaker produced a Babel packet (PktO) to be sent from the interface. Table 2 provides a decoding of PktO, the contents of which are below:",
      "ja": "2.スピーカーの独自プロトコルのインスタンスは、インタフェースから送信されるバベルパケット（PktO）を生成しました。表2は、PktOの復号化を提供する、その内容は以下のとおりです。"
    },
    {
      "indent": 7,
      "text": "2a:02:00:14:04:06:00:00:09:25:01:90:08:0a:00:40\n00:00:ff:ff:68:21:ff:ff",
      "raw": true
    },
    {
      "indent": 3,
      "text": "3. The authentication mechanism appended one TS/PC TLV and two HMAC TLVs to the packet body, updated the \"Body length\" packet header field, and padded the Digest field of the HMAC TLVs, using the link-local IPv6 address of the interface and the necessary amount of zeroes. Table 3 provides a decoding of the resulting temporary packet (PktT), the contents of which are below:",
      "ja": "3.認証機構「は、身体の長さ」パケットヘッダフィールドを更新し、パケットボディ1つのTS / PCのTLV二HMAC TLVを添付し、インターフェイスのリンクローカルIPv6アドレスを使用して、HMACのTLVのダイジェストフィールドを埋めそして、ゼロの必要量。表3は、得られた仮のパケット（PktT）の復号化を提供する、の内容は以下のとおりです。"
    },
    {
      "indent": 7,
      "text": "2a:02:00:4c:04:06:00:00:09:25:01:90:08:0a:00:40\n00:00:ff:ff:68:21:ff:ff:0b:06:00:01:52:1d:7e:8b\n0c:16:00:c8:fe:80:00:00:00:00:00:00:0a:11:96:ff\nfe:1c:10:c8:00:00:00:00:0c:16:00:64:fe:80:00:00\n00:00:00:00:0a:11:96:ff:fe:1c:10:c8:00:00:00:00",
      "raw": true
    },
    {
      "indent": 3,
      "text": "4. The authentication mechanism produced two HMAC results, performing the computations as follows:",
      "ja": "4.認証メカニズムは次のように計算を実行する、2つのHMACの結果が得られました："
    },
    {
      "indent": 7,
      "text": "* For H=RIPEMD-160, K=Key26, and Text=PktT, the HMAC result is:",
      "ja": "*についてH = RIPEMD-160、K = Key26、テキスト= PktT、HMAC結果です。"
    },
    {
      "indent": 10,
      "text": "c6:f1:06:13:30:3c:fa:f3:eb:5d:60:3a:ed:fd:06:55 83:f7:ee:79",
      "ja": "Shatt：P午前1時06分13秒：30：巣：中：効果：イッブ：頬：60：アモス：として：解像度：06：G場所：審査：A：右"
    },
    {
      "indent": 7,
      "text": "* For H=SHA-1, K=Key70, and Text=PktT, the HMAC result is:",
      "ja": "*についてH = SHA-1、K = Key70、テキスト= PktT、HMAC結果です。"
    },
    {
      "indent": 10,
      "text": "df:32:16:5e:d8:63:16:e5:a6:4d:c7:73:e0:b5:22:82 ce:fe:e2:3c",
      "ja": "デイブ：32：16：X：リング：63：16：ブラザー：フレームワーク：4 D：のKh：73：J 0：潮吹き：22：光Q：で：DONC：ネスト"
    },
    {
      "indent": 3,
      "text": "5. The authentication mechanism placed each HMAC result into its respective HMAC TLV, producing the final authenticated Babel packet (PktA), which was eventually sent from the interface.",
      "ja": "前記認証メカニズムは、最終的にインターフェイスから送信された最終的な認証バベルパケット（PktA）を生成し、そのそれぞれのHMAC TLVに各HMAC結果を置きました。"
    },
    {
      "indent": 7,
      "text": "Table 4 provides a decoding of PktA, the contents of which are\nbelow:",
      "raw": true
    },
    {
      "indent": 7,
      "text": "2a:02:00:4c:04:06:00:00:09:25:01:90:08:0a:00:40 00:00:ff:ff:68:21:ff:ff:0b:06:00:01:52:1d:7e:8b 0c:16:00:c8:c6:f1:06:13:30:3c:fa:f3:eb:5d:60:3a ed:fd:06:55:83:f7:ee:79:0c:16:00:64:df:32:16:5e d8:63:16:e5:a6:4d:c7:73:e0:b5:22:82:ce:fe:e2:3c",
      "ja": "図2a：02：00：4C：04：06：00：00：09：25：01：90：08：0A：00：40 00：00：FF：FF：68：21：FF：FF：0B：06 ：00：52：01 1D：7E：8B 0C：00：16：C8：C6：F1：06：13：30：3C：FA：F3：EB：5D：60：3（a）のED：FD：55：06 ：83：F7：EE：79：0C：16：00：64：DF：32：16：5EのD8：63：16：E5：A6：4D：C7：73：E0：B5：22：82：CE： FE：E2：図3c"
    },
    {
      "indent": 3,
      "text": "Interpretation of this process is to be done differently for the sending and receiving directions (see Figure 1).",
      "ja": "このプロセスの解釈は、送受信方向（図1参照）に対して異なる行われるべきです。"
    },
    {
      "indent": 3,
      "text": "For the sending direction, given a Babel speaker configured using the IPv6 address and the sequence of CSAs as described above, the implementation SHOULD (see notes in Section 5.3) produce exactly the temporary packet PktT if the original protocol instance produces exactly the packet PktO to be sent from the interface. If the temporary packet exactly matches PktT, the HMAC results computed afterwards MUST exactly match the respective results above, and the final authenticated packet MUST exactly match PktA above.",
      "ja": "送信方向のために、上記のようにバベルスピーカーは、IPv6アドレスとのCSAのシーケンスを使用して設定された所定の実装（セクション5.3のメモを参照）SHOULD元のプロトコルインスタンスが正確にパケットPktOを生成する場合、正確に一時的なパケットPktTを生成インターフェイスから送信され。一時的なパケットが正確にPktTと一致した場合、その後の計算HMAC結果は正確に上記のそれぞれの結果と一致しなければならない、そして最終的に認証されたパケットは、まさに上記のPktAと一致しなければなりません。"
    },
    {
      "indent": 3,
      "text": "For the receiving direction, given a Babel speaker configured using the sequence of CSAs as described above (but a different IPv6 address), the implementation MUST (assuming that the TS/PC check didn't fail) produce exactly the temporary packet PktT above if its network stack receives through the interface exactly the packet PktA above from the source IPv6 address above. The first HMAC result computed afterwards MUST match the first result above. The receiving procedure doesn't compute the second HMAC result in this case, but if the implementor decides to compute it anyway for verification purposes, it MUST exactly match the second result above.",
      "ja": "バベルスピーカは、上述したようのCSAの配列を使用して構成（異なるIPv6アドレス）指定された受信方向については、実装は（TS / PCチェックが失敗しなかったと仮定して）必要がある場合、上記正確一時パケットPktTを生成そのネットワークスタックは、上記送信元IPv6アドレスから上記正確パケットPktAインターフェースを介して受信します。その後、計算された最初のHMAC結果は、前述の第1の結果と一致しなければなりません。受信手順は、この場合、第2のHMAC結果を計算しませんが、実装は、検証目的のためにとにかくそれを計算することを決定した場合、それは正確に上記の2番目の結果と一致しなければなりません。"
    },
    {
      "indent": 0,
      "text": "Author's Address",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Denis Ovsienko Yandex 16, Leo Tolstoy St. Moscow 119021 Russia",
      "ja": "デニスOvsienko Yandexの16、トルストイセントモスクワ119021ロシア"
    },
    {
      "indent": 3,
      "text": "EMail: infrastation@yandex.ru",
      "ja": "メールアドレス：infrastation@yandex.ru"
    }
  ]
}