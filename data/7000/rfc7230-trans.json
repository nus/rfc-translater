{
  "title": {
    "text": "RFC 7230 - Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing",
    "ja": "RFC 7230 - ハイパーテキスト転送プロトコル（HTTP / 1.1）：メッセージの構文とルーティング"
  },
  "number": 7230,
  "created_at": "2019-10-30 09:53:56.979728+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                  R. Fielding, Ed.\nRequest for Comments: 7230                                         Adobe\nObsoletes: 2145, 2616                                    J. Reschke, Ed.\nUpdates: 2817, 2818                                           greenbytes\nCategory: Standards Track                                      June 2014\nISSN: 2070-1721",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing",
      "ja": "ハイパーテキスト転送プロトコル（HTTP / 1.1）：メッセージの構文とルーティング"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems. This document provides an overview of HTTP architecture and its associated terminology, defines the \"http\" and \"https\" Uniform Resource Identifier (URI) schemes, defines the HTTP/1.1 message syntax and parsing requirements, and describes related security concerns for implementations.",
      "ja": "ハイパーテキスト転送プロトコル（HTTP）は、分散、協調、ハイパーテキスト情報システムのためのステートレスなアプリケーションレベルのプロトコルです。この文書では、HTTPのアーキテクチャとその関連用語の概要を提供する「HTTP」と「HTTPS」のURI（Uniform Resource Identifier）スキームを定義し、HTTP / 1.1メッセージの構文および構文解析の要件を定義し、実装のために関連するセキュリティ上の問題が記載されています。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 5741のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7230.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7230で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2014 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2014 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 3,
      "text": "This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.",
      "ja": "この材料の一部がIETFトラストにこのような材料の変更を許可する権利を与えられていない可能性がありますにこの文書は、2008年、IETFドキュメントまたは11月10日以前に発行または公開さIETF貢献から著作権を支配する者（複数可）材料を含んでいてもよいですIETF標準化プロセスの外。そのような材料の著作権を管理者（単数または複数）から適切なライセンスを取得することなく、この文書は、IETF標準化過程の外側修正されないかもしれません、そして、それの派生物は、IETF標準化過程の外側に作成されない場合があり、それをフォーマットする以外出版RFCとして、英語以外の言語に翻訳します。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................5\n   1.1. Requirements Notation ......................................6\n   1.2. Syntax Notation ............................................6\n2. Architecture ....................................................6\n   2.1. Client/Server Messaging ....................................7\n   2.2. Implementation Diversity ...................................8\n   2.3. Intermediaries .............................................9\n   2.4. Caches ....................................................11\n   2.5. Conformance and Error Handling ............................12\n   2.6. Protocol Versioning .......................................13\n   2.7. Uniform Resource Identifiers ..............................16\n        2.7.1. http URI Scheme ....................................17\n        2.7.2. https URI Scheme ...................................18\n        2.7.3. http and https URI Normalization and Comparison ....19\n3. Message Format .................................................19\n   3.1. Start Line ................................................20\n        3.1.1. Request Line .......................................21\n        3.1.2. Status Line ........................................22\n   3.2. Header Fields .............................................22",
      "raw": true
    },
    {
      "indent": 3,
      "text": "        3.2.1. Field Extensibility ................................23\n        3.2.2. Field Order ........................................23\n        3.2.3. Whitespace .........................................24\n        3.2.4. Field Parsing ......................................25\n        3.2.5. Field Limits .......................................26\n        3.2.6. Field Value Components .............................27\n   3.3. Message Body ..............................................28\n        3.3.1. Transfer-Encoding ..................................28\n        3.3.2. Content-Length .....................................30\n        3.3.3. Message Body Length ................................32\n   3.4. Handling Incomplete Messages ..............................34\n   3.5. Message Parsing Robustness ................................34\n4. Transfer Codings ...............................................35\n   4.1. Chunked Transfer Coding ...................................36\n        4.1.1. Chunk Extensions ...................................36\n        4.1.2. Chunked Trailer Part ...............................37\n        4.1.3. Decoding Chunked ...................................38\n   4.2. Compression Codings .......................................38\n        4.2.1. Compress Coding ....................................38\n        4.2.2. Deflate Coding .....................................38\n        4.2.3. Gzip Coding ........................................39\n   4.3. TE ........................................................39\n   4.4. Trailer ...................................................40\n5. Message Routing ................................................40\n   5.1. Identifying a Target Resource .............................40\n   5.2. Connecting Inbound ........................................41\n   5.3. Request Target ............................................41\n        5.3.1. origin-form ........................................42\n        5.3.2. absolute-form ......................................42\n        5.3.3. authority-form .....................................43\n        5.3.4. asterisk-form ......................................43\n   5.4. Host ......................................................44\n   5.5. Effective Request URI .....................................45\n   5.6. Associating a Response to a Request .......................46\n   5.7. Message Forwarding ........................................47\n        5.7.1. Via ................................................47\n        5.7.2. Transformations ....................................49\n6. Connection Management ..........................................50\n   6.1. Connection ................................................51\n   6.2. Establishment .............................................52\n   6.3. Persistence ...............................................52\n        6.3.1. Retrying Requests ..................................53\n        6.3.2. Pipelining .........................................54\n   6.4. Concurrency ...............................................55\n   6.5. Failures and Timeouts .....................................55\n   6.6. Tear-down .................................................56\n   6.7. Upgrade ...................................................57\n7. ABNF List Extension: #rule .....................................59",
      "raw": true
    },
    {
      "indent": 3,
      "text": "8. IANA Considerations ............................................61\n   8.1. Header Field Registration .................................61\n   8.2. URI Scheme Registration ...................................62\n   8.3. Internet Media Type Registration ..........................62\n        8.3.1. Internet Media Type message/http ...................62\n        8.3.2. Internet Media Type application/http ...............63\n   8.4. Transfer Coding Registry ..................................64\n        8.4.1. Procedure ..........................................65\n        8.4.2. Registration .......................................65\n   8.5. Content Coding Registration ...............................66\n   8.6. Upgrade Token Registry ....................................66\n        8.6.1. Procedure ..........................................66\n        8.6.2. Upgrade Token Registration .........................67\n9. Security Considerations ........................................67\n   9.1. Establishing Authority ....................................67\n   9.2. Risks of Intermediaries ...................................68\n   9.3. Attacks via Protocol Element Length .......................69\n   9.4. Response Splitting ........................................69\n   9.5. Request Smuggling .........................................70\n   9.6. Message Integrity .........................................70\n   9.7. Message Confidentiality ...................................71\n   9.8. Privacy of Server Log Information .........................71\n10. Acknowledgments ...............................................72\n11. References ....................................................74\n   11.1. Normative References .....................................74\n   11.2. Informative References ...................................75\nAppendix A. HTTP Version History ..................................78\n   A.1. Changes from HTTP/1.0  ....................................78\n        A.1.1.  Multihomed Web Servers ............................78\n        A.1.2.  Keep-Alive Connections ............................79\n        A.1.3.  Introduction of Transfer-Encoding .................79\n   A.2.  Changes from RFC 2616 ....................................80\nAppendix B. Collected ABNF ........................................82\nIndex .............................................................85",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "The Hypertext Transfer Protocol (HTTP) is a stateless application-level request/response protocol that uses extensible semantics and self-descriptive message payloads for flexible interaction with network-based hypertext information systems. This document is the first in a series of documents that collectively form the HTTP/1.1 specification:",
      "ja": "ハイパーテキスト転送プロトコル（HTTP）は、ネットワークベースのハイパーテキスト情報システムとの柔軟な相互作用のための拡張可能なセマンティクスと自己記述メッセージペイロードを使用するステートレスアプリケーションレベル要求/応答プロトコルです。この文書では、総称してHTTP / 1.1の仕様を形成する一連の文書で最初のものです："
    },
    {
      "indent": 3,
      "text": "1. \"Message Syntax and Routing\" (this document)",
      "section_title": true,
      "ja": "1.「メッセージの構文とルーティング」（本書）"
    },
    {
      "indent": 3,
      "text": "2. \"Semantics and Content\" [RFC7231]",
      "section_title": true,
      "ja": "2. \"セマンティクスおよびコンテンツ\" [RFC7231]"
    },
    {
      "indent": 3,
      "text": "3. \"Conditional Requests\" [RFC7232]",
      "section_title": true,
      "ja": "3. \"条件付きリクエスト\" [RFC7232]"
    },
    {
      "indent": 3,
      "text": "4. \"Range Requests\" [RFC7233]",
      "section_title": true,
      "ja": "4. \"範囲要求\" [RFC7233]"
    },
    {
      "indent": 3,
      "text": "5. \"Caching\" [RFC7234]",
      "section_title": true,
      "ja": "5. \"キャッシュ\" [RFC7234]"
    },
    {
      "indent": 3,
      "text": "6. \"Authentication\" [RFC7235]",
      "section_title": true,
      "ja": "6. \"認証\" [RFC7235]"
    },
    {
      "indent": 3,
      "text": "This HTTP/1.1 specification obsoletes RFC 2616 and RFC 2145 (on HTTP versioning). This specification also updates the use of CONNECT to establish a tunnel, previously defined in RFC 2817, and defines the \"https\" URI scheme that was described informally in RFC 2818.",
      "ja": "このHTTP / 1.1仕様では、RFC 2616及びRFC 2145（HTTPのバージョンに）時代遅れ。本明細書はまた、トンネルを確立するためのCONNECTの使用を更新以前にRFC 2817で定義され、RFC 2818に非公式に記載された「HTTPS」URIスキームを定義します。"
    },
    {
      "indent": 3,
      "text": "HTTP is a generic interface protocol for information systems. It is designed to hide the details of how a service is implemented by presenting a uniform interface to clients that is independent of the types of resources provided. Likewise, servers do not need to be aware of each client's purpose: an HTTP request can be considered in isolation rather than being associated with a specific type of client or a predetermined sequence of application steps. The result is a protocol that can be used effectively in many different contexts and for which implementations can evolve independently over time.",
      "ja": "HTTPは、情報システムのための汎用インターフェースプロトコルです。サービスが提供されるリソースの種類とは独立したクライアントに統一されたインタフェースを提示することによって実装されている方法の詳細を隠すように設計されています。同様に、サーバは、各クライアントの目的を意識する必要はありません：HTTPリクエストは、単独で考えることができるのではなく、クライアントの特定のタイプやアプリケーションのステップの所定のシーケンスに関連付けられています。結果はさまざまな状況で効果的に使用することができ、そのため実装が経時的に独立して進化することができるプロトコルです。"
    },
    {
      "indent": 3,
      "text": "HTTP is also designed for use as an intermediation protocol for translating communication to and from non-HTTP information systems. HTTP proxies and gateways can provide access to alternative information services by translating their diverse protocols into a hypertext format that can be viewed and manipulated by clients in the same way as HTTP services.",
      "ja": "HTTPは、非HTTP情報システムへとからの通信を変換するための仲介プロトコルとして使用するために設計されています。 HTTPプロキシやゲートウェイは、HTTPサービスと同じ方法で、クライアントで表示および操作することができるハイパーテキスト形式に彼らの多様なプロトコルを変換することによって、代替情報サービスへのアクセスを提供することができます。"
    },
    {
      "indent": 3,
      "text": "One consequence of this flexibility is that the protocol cannot be defined in terms of what occurs behind the interface. Instead, we are limited to defining the syntax of communication, the intent of received communication, and the expected behavior of recipients. If the communication is considered in isolation, then successful actions ought to be reflected in corresponding changes to the observable interface provided by servers. However, since multiple clients might act in parallel and perhaps at cross-purposes, we cannot require that such changes be observable beyond the scope of a single response.",
      "ja": "この柔軟性の1つの結果は、プロトコルがインターフェイスの背後に何が起こるかで定義することができないということです。代わりに、私たちはコミュニケーションの構文、受信された通信の意図、および受信者の期待される動作を定義することに限定されています。通信は分離して考慮される場合、成功したアクションは、サーバによって提供される観察インターフェースに対応する変化に反映されるべきです。複数のクライアントが並行して行動し、おそらくクロスの目的でありますので、しかし、我々はそのような変更は、単一の応答の範囲を超えて観測可能であることを要求することはできません。"
    },
    {
      "indent": 3,
      "text": "This document describes the architectural elements that are used or referred to in HTTP, defines the \"http\" and \"https\" URI schemes, describes overall network operation and connection management, and defines HTTP message framing and forwarding requirements. Our goal is to define all of the mechanisms necessary for HTTP message handling that are independent of message semantics, thereby defining the complete set of requirements for message parsers and message-forwarding intermediaries.",
      "ja": "この文書では、使用されるか、またはHTTPで言及されている建築要素について説明して「HTTP」と「HTTPS」URIスキームを定義し、ネットワーク全体の動作及び接続管理を記述し、HTTPメッセージフレーミングおよび転送要件を定義します。私たちの目標は、それによってメッセージパーサとメッセージ転送仲介のための要件の完全なセットを定義し、メッセージの意味とは無関係であるHTTPメッセージの処理のために必要なメカニズムのすべてを定義することです。"
    },
    {
      "indent": 0,
      "text": "1.1. Requirements Notation",
      "section_title": true,
      "ja": "1.1。要件表記"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はあります[RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 3,
      "text": "Conformance criteria and considerations regarding error handling are defined in Section 2.5.",
      "ja": "適合基準およびエラー処理についての考察は、第2.5節で定義されています。"
    },
    {
      "indent": 0,
      "text": "1.2. Syntax Notation",
      "section_title": true,
      "ja": "1.2。構文記法"
    },
    {
      "indent": 3,
      "text": "This specification uses the Augmented Backus-Naur Form (ABNF) notation of [RFC5234] with a list extension, defined in Section 7, that allows for compact definition of comma-separated lists using a '#' operator (similar to how the '*' operator indicates repetition). Appendix B shows the collected grammar with all list operators expanded to standard ABNF notation.",
      "ja": "この仕様は、どのように「*と同様「＃」演算子を（使用してカンマ区切りリストのコンパクトな定義を可能にするセクション7で定義されたリストの拡張子、と[RFC5234]の増補バッカス - ナウアフォーム（ABNF）表記を使用します'演算子）は繰り返しを示します。付録Bは、標準のABNF表記法に拡張全リスト演算子で収集文法を示しています。"
    },
    {
      "indent": 3,
      "text": "The following core rules are included by reference, as defined in [RFC5234], Appendix B.1: ALPHA (letters), CR (carriage return), CRLF (CR LF), CTL (controls), DIGIT (decimal 0-9), DQUOTE (double quote), HEXDIG (hexadecimal 0-9/A-F/a-f), HTAB (horizontal tab), LF (line feed), OCTET (any 8-bit sequence of data), SP (space), and VCHAR (any visible [USASCII] character).",
      "ja": "[RFC5234]で定義されるように以下のコアルールは、参照により含まれる、付録B.1：ALPHA（文字）、CR（キャリッジリターン）、CRLF（CR LF）、CTL（コントロール）、数字（小数0-9） 、DQUOTE（二重引用符）、HEXDIG（16進数0-9 / AF / AF）、HTAB（水平タブ）、LF（ラインフィード）、OCTET（データの8ビットシーケンス）、SP（空間）、及びVCHAR（目に見える[USASCII]文字）。"
    },
    {
      "indent": 3,
      "text": "As a convention, ABNF rule names prefixed with \"obs-\" denote \"obsolete\" grammar rules that appear for historical reasons.",
      "ja": "慣例として、接頭辞ABNF規則の名前は歴史的な理由のために表示され、「時代遅れ」の文法規則を表します「obs-」。"
    },
    {
      "indent": 0,
      "text": "2. Architecture",
      "section_title": true,
      "ja": "2.アーキテクチャ"
    },
    {
      "indent": 3,
      "text": "HTTP was created for the World Wide Web (WWW) architecture and has evolved over time to support the scalability needs of a worldwide hypertext system. Much of that architecture is reflected in the terminology and syntax productions used to define HTTP.",
      "ja": "HTTPは、ワールド・ワイド・ウェブ（WWW）アーキテクチャ用に作成された、世界中のハイパーテキストシステムのスケーラビリティのニーズをサポートするために、時間をかけて進化してきました。そのアーキテクチャの多くは、HTTPを定義するために使用される用語や構文制作に反映されます。"
    },
    {
      "indent": 0,
      "text": "2.1. Client/Server Messaging",
      "section_title": true,
      "ja": "2.1。クライアント/サーバーメッセージング"
    },
    {
      "indent": 3,
      "text": "HTTP is a stateless request/response protocol that operates by exchanging messages (Section 3) across a reliable transport- or session-layer \"connection\" (Section 6). An HTTP \"client\" is a program that establishes a connection to a server for the purpose of sending one or more HTTP requests. An HTTP \"server\" is a program that accepts connections in order to service HTTP requests by sending HTTP responses.",
      "ja": "HTTPは、信頼transport-またはセッション層「接続」（第6節）を横切ってメッセージ（セクション3）を交換することによって動作するステートレスな要求/応答プロトコルです。 HTTP「クライアント」は、一つ以上のHTTPリクエストを送信するために、サーバーへの接続を確立するプログラムです。 HTTP「サーバは」HTTPレスポンスを送信することにより、HTTP要求を処理するために、接続を受け入れるプログラムです。"
    },
    {
      "indent": 3,
      "text": "The terms \"client\" and \"server\" refer only to the roles that these programs perform for a particular connection. The same program might act as a client on some connections and a server on others. The term \"user agent\" refers to any of the various client programs that initiate a request, including (but not limited to) browsers, spiders (web-based robots), command-line tools, custom applications, and mobile apps. The term \"origin server\" refers to the program that can originate authoritative responses for a given target resource. The terms \"sender\" and \"recipient\" refer to any implementation that sends or receives a given message, respectively.",
      "ja": "用語「クライアント」と「サーバー」は、これらのプログラムは、特定の接続のために行う役割のみを指します。同じプログラムは、いくつかの接続上のクライアントおよびその他のサーバーとして機能するかもしれません。用語「ユーザエージェントは、」要求を含む（これらに限定されない）のブラウザ、スパイダー（ウェブベースのロボット）、コマンドラインツール、カスタムアプリケーション、およびモバイルアプリケーションを開始し、さまざまなクライアントプログラムのいずれかを指します。用語「オリジンサーバは、」与えられた目標リソースに対する権限を持つ応答を発信することができますプログラムを指します。用語「送信者」及び「受信者」は、それぞれ、所定のメッセージを送信または受信する任意の実装を指します。"
    },
    {
      "indent": 3,
      "text": "HTTP relies upon the Uniform Resource Identifier (URI) standard [RFC3986] to indicate the target resource (Section 5.1) and relationships between resources. Messages are passed in a format similar to that used by Internet mail [RFC5322] and the Multipurpose Internet Mail Extensions (MIME) [RFC2045] (see Appendix A of [RFC7231] for the differences between HTTP and MIME messages).",
      "ja": "HTTPは、ターゲット・リソース（セクション5.1）とリソース間の関係を示すためのURI（Uniform Resource Identifier）標準[RFC3986]に依存します。メッセージはインターネットメール[RFC5322]およびMIME（Multipurpose Internet Mail Extensions）で使用したものと同様の形式で渡された[RFC2045]は（HTTPとMIMEメッセージの間の違いのために[RFC7231]の付録Aを参照してください）。"
    },
    {
      "indent": 3,
      "text": "Most HTTP communication consists of a retrieval request (GET) for a representation of some resource identified by a URI. In the simplest case, this might be accomplished via a single bidirectional connection (===) between the user agent (UA) and the origin server (O).",
      "ja": "ほとんどのHTTP通信は、URIによって識別されるいくつかのリソースの表現のための検索要求（GET）から成ります。最も単純な場合、これはユーザエージェント（UA）とオリジンサーバ（O）との間の単一の双方向接続（===）を介して達成されるかもしれません。"
    },
    {
      "indent": 7,
      "text": "     request   >\nUA ======================================= O\n                            <   response",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A client sends an HTTP request to a server in the form of a request message, beginning with a request-line that includes a method, URI, and protocol version (Section 3.1.1), followed by header fields containing request modifiers, client information, and representation metadata (Section 3.2), an empty line to indicate the end of the header section, and finally a message body containing the payload body (if any, Section 3.3).",
      "ja": "クライアントは、要求修飾子を含むヘッダフィールドに続く方法、URI、プロトコルバージョン（3.1.1）を含むリクエストラインで始まる、要求メッセージの形式でサーバにHTTP要求を送信し、クライアント情報、と表現メタデータ（セクション3.2）、ヘッダ部の終わりを示すために空行、およびペイロード体（もしあれば、セクション3.3）を含む、最終的にメッセージ本体。"
    },
    {
      "indent": 3,
      "text": "A server responds to a client's request by sending one or more HTTP response messages, each beginning with a status line that includes the protocol version, a success or error code, and textual reason phrase (Section 3.1.2), possibly followed by header fields containing server information, resource metadata, and representation metadata (Section 3.2), an empty line to indicate the end of the header section, and finally a message body containing the payload body (if any, Section 3.3).",
      "ja": "サーバーが1つまたは複数のHTTP応答メッセージ、プロトコルバージョン、成功またはエラーコード、およびテキストの理由句（節3.1.2）を含み、ステータスラインと各先頭を送信することによって、クライアントの要求に応答し、おそらくヘッダフィールドに続きますサーバ情報、リソースメタデータ、および表現メタデータを含む（セクション3.2）、ヘッダ部の終わりを示すために空行、およびペイロード体を含む最終的に、メッセージ本文（もしあれば、セクション3.3）。"
    },
    {
      "indent": 3,
      "text": "A connection might be used for multiple request/response exchanges, as defined in Section 6.3.",
      "ja": "セクション6.3で定義されるような接続は、複数の要求/応答の交換のために使用されるかもしれません。"
    },
    {
      "indent": 3,
      "text": "The following example illustrates a typical message exchange for a GET request (Section 4.3.1 of [RFC7231]) on the URI \"http://www.example.com/hello.txt\":",
      "ja": "次の例は、「http://www.example.com/hello.txt」URIにGET要求（[RFC7231]のセクション4.3.1）のための典型的なメッセージ交換を示します。"
    },
    {
      "indent": 3,
      "text": "Client request:",
      "ja": "クライアントの要求："
    },
    {
      "indent": 5,
      "text": "GET /hello.txt HTTP/1.1 User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3 Host: www.example.com Accept-Language: en, mi",
      "ja": "GET /hello.txt HTTP / 1.1のUser-Agent：カール/ 7.16.3のlibcurl / 7.16.3のOpenSSL / 0.9.7lのzlib / 1.2.3ホスト：www.example.comのAccept-言語：EN、MI"
    },
    {
      "indent": 3,
      "text": "Server response:",
      "ja": "サーバーの応答："
    },
    {
      "indent": 5,
      "text": "HTTP/1.1 200 OK Date: Mon, 27 Jul 2009 12:28:53 GMT Server: Apache Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT ETag: \"34aa387-d-1568eb00\" Accept-Ranges: bytes Content-Length: 51 Vary: Accept-Encoding Content-Type: text/plain",
      "ja": "HTTP / 1.1 200 OK日：月、2009年7月27日12時28分53秒GMTサーバー：ApacheののLast-Modified：水曜日、2009年7月22日19時15分56秒GMTのETagを： \"34aa387-D-1568eb00\" のAccept-範囲：バイトコンテンツの長さ：51ヴァリ：-受け入れエンコードのContent-Type：/プレーンテキストを"
    },
    {
      "indent": 5,
      "text": "Hello World! My payload includes a trailing CRLF.",
      "ja": "\"こんにちは世界\"私のペイロードは、末尾のCRLFを含んでいます。"
    },
    {
      "indent": 0,
      "text": "2.2. Implementation Diversity",
      "section_title": true,
      "ja": "2.2。実装の多様性"
    },
    {
      "indent": 3,
      "text": "When considering the design of HTTP, it is easy to fall into a trap of thinking that all user agents are general-purpose browsers and all origin servers are large public websites. That is not the case in practice. Common HTTP user agents include household appliances, stereos, scales, firmware update scripts, command-line programs, mobile apps, and communication devices in a multitude of shapes and sizes. Likewise, common HTTP origin servers include home automation units, configurable networking components, office machines, autonomous robots, news feeds, traffic cameras, ad selectors, and video-delivery platforms.",
      "ja": "HTTPのデザインを考えるとき、すべてのユーザエージェントは、汎用ブラウザであり、すべてのオリジンサーバは、大規模な公共のウェブサイトであることを考えるの罠に陥るのは簡単です。それは実際にはそうではありません。一般的なHTTPユーザエージェントは、形や大きさの多数の家庭用電化製品、ステレオ、スケール、ファームウェア更新スクリプト、コマンドラインプログラム、モバイルアプリケーション、および通信装置を含みます。同様に、一般的なHTTPオリジンサーバは、ホームオートメーションユニット、構成可能なネットワークコンポーネント、事務機器、自律ロボット、ニュースフィード、トラフィックのカメラ、広告セレクタ、およびビデオ配信プラットフォームが含まれます。"
    },
    {
      "indent": 3,
      "text": "The term \"user agent\" does not imply that there is a human user directly interacting with the software agent at the time of a request. In many cases, a user agent is installed or configured to run in the background and save its results for later inspection (or save only a subset of those results that might be interesting or erroneous). Spiders, for example, are typically given a start URI and configured to follow certain behavior while crawling the Web as a hypertext graph.",
      "ja": "用語「ユーザエージェントは、」直接要求時のソフトウェアエージェントと対話する人間のユーザが存在することを意味するものではありません。多くの場合、ユーザエージェントは、インストールまたはバックグラウンドで実行され、以降の検査のためにその結果を保存（または興味深いまたは誤ったかもしれないそれらの結果のサブセットのみを保存）するよう構成されています。スパイダーは、例えば、典型的には開始URIを与え、ハイパーグラフとしてウェブをクロールしながら、特定の動作に従うように構成されています。"
    },
    {
      "indent": 3,
      "text": "The implementation diversity of HTTP means that not all user agents can make interactive suggestions to their user or provide adequate warning for security or privacy concerns. In the few cases where this specification requires reporting of errors to the user, it is acceptable for such reporting to only be observable in an error console or log file. Likewise, requirements that an automated action be confirmed by the user before proceeding might be met via advance configuration choices, run-time options, or simple avoidance of the unsafe action; confirmation does not imply any specific user interface or interruption of normal processing if the user has already made that choice.",
      "ja": "HTTPの実装の多様性は、すべてのユーザーエージェントは、ユーザーにインタラクティブな提案をしたり、セキュリティやプライバシーの問題のために十分な警告を提供することができることを意味します。この仕様は、ユーザにエラーの報告を必要とするいくつかのケースでは、そのようなレポートのみエラーコンソールで観察可能であるか、またはファイルをログに記録するために許容可能です。同様に、自動化されたアクションは、先に進む前にユーザに確認することの要件は、事前構成の選択、実行時オプション、または危険なアクションの簡単な回避を経由して満たされるかもしれません。ユーザーが既にその選択をした場合の確認は、通常の処理のいずれかの特定のユーザーインタフェースまたは中断を意味するものではありません。"
    },
    {
      "indent": 0,
      "text": "2.3. Intermediaries",
      "section_title": true,
      "ja": "2.3。仲介"
    },
    {
      "indent": 3,
      "text": "HTTP enables the use of intermediaries to satisfy requests through a chain of connections. There are three common forms of HTTP intermediary: proxy, gateway, and tunnel. In some cases, a single intermediary might act as an origin server, proxy, gateway, or tunnel, switching behavior based on the nature of each request.",
      "ja": "HTTPはコネクションの連鎖を通じて要求を満たすために仲介の使用を可能にします。プロキシ、ゲートウェイ、およびトンネル：3つの一般的なHTTPの仲介の形式があります。いくつかの場合において、単一の中間者は、各リクエストの性質に基づいて動作を切り替える、オリジンサーバ、プロキシ、ゲートウェイ、またはトンネルとして作用するかもしれません。"
    },
    {
      "indent": 7,
      "text": "     >             >             >             >\nUA =========== A =========== B =========== C =========== O\n           <             <             <             <",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The figure above shows three intermediaries (A, B, and C) between the user agent and origin server. A request or response message that travels the whole chain will pass through four separate connections. Some HTTP communication options might apply only to the connection with the nearest, non-tunnel neighbor, only to the endpoints of the chain, or to all connections along the chain. Although the diagram is linear, each participant might be engaged in multiple, simultaneous communications. For example, B might be receiving requests from many clients other than A, and/or forwarding requests to servers other than C, at the same time that it is handling A's request. Likewise, later requests might be sent through a different path of connections, often based on dynamic configuration for load balancing.",
      "ja": "上図は、ユーザエージェントとオリジンサーバ間の3人の仲介者（A、B、及びC）を示します。チェーン全体を移動要求または応答メッセージは、4つの別々の接続を通過することになります。いくつかのHTTP通信オプションは、チェーンのエンドポイントに、またはチェーンに沿ってすべての接続に、唯一の最も近い、非トンネル隣人との接続に適用される場合があります。図は線形であるが、各参加者は、複数の同時通信に従事している可能性があります。例えば、BはA以外の多くのクライアントからの要求を受け、かつ/またはそれがAのリクエストを処理していると同時に、C以外のサーバに要求を転送することがあります。同様に、以降の要求は、多くの場合、負荷分散のための動的な構成に基づいて、接続の異なるパスを経由して送信される可能性があります。"
    },
    {
      "indent": 3,
      "text": "The terms \"upstream\" and \"downstream\" are used to describe directional requirements in relation to the message flow: all messages flow from upstream to downstream. The terms \"inbound\" and \"outbound\" are used to describe directional requirements in relation to the request route: \"inbound\" means toward the origin server and \"outbound\" means toward the user agent.",
      "ja": "「上流」および「下流」という用語は、メッセージ・フローに関して指向性の要件を記述するために使用されるすべてのメッセージは、上流から下流に流れます。用語「インバウンド」および「アウトバウンド」は、リクエストルートに関連して、方向性の要件を記述するために使用されている：「インバウンドは、」オリジンサーバに向かうことを意味し、「アウトバウンド」は、ユーザエージェントに向かうことを意味します。"
    },
    {
      "indent": 3,
      "text": "A \"proxy\" is a message-forwarding agent that is selected by the client, usually via local configuration rules, to receive requests for some type(s) of absolute URI and attempt to satisfy those requests via translation through the HTTP interface. Some translations are minimal, such as for proxy requests for \"http\" URIs, whereas other requests might require translation to and from entirely different application-level protocols. Proxies are often used to group an organization's HTTP requests through a common intermediary for the sake of security, annotation services, or shared caching. Some proxies are designed to apply transformations to selected messages or payloads while they are being forwarded, as described in Section 5.7.2.",
      "ja": "「代理」は、絶対URIの何らかのタイプの要求を受信し、HTTPインターフェースを介して翻訳を介してこれらの要求を満たすために試みること、通常ローカル構成規則を介して、クライアントによって選択されたメッセージ転送エージェントです。他の要求が全く異なるアプリケーションレベルのプロトコルにしてから翻訳を必要とするかもしれないのに対し、いくつかの翻訳は、そのような「HTTP」のURIのためのプロキシ要求のためとして、最小限です。プロキシは、多くの場合、セキュリティ、注釈サービス、または共有キャッシングのための共通介してグループに、組織のHTTPリクエストを使用しています。 5.7.2項で説明したようにいくつかのプロキシは、それらが転送されている間、選択したメッセージまたはペイロードへの変換を適用するように設計されています。"
    },
    {
      "indent": 3,
      "text": "A \"gateway\" (a.k.a. \"reverse proxy\") is an intermediary that acts as an origin server for the outbound connection but translates received requests and forwards them inbound to another server or servers. Gateways are often used to encapsulate legacy or untrusted information services, to improve server performance through \"accelerator\" caching, and to enable partitioning or load balancing of HTTP services across multiple machines.",
      "ja": "（別名「リバースプロキシ」）は、アウトバウンド接続用オリジンサーバとして機能するが、受信した要求を変換し、別のサーバまたはサーバへの着信転送し、中間である「ゲートウェイ」。ゲートウェイは、多くの場合、「アクセル」のキャッシングを介してサーバーのパフォーマンスを向上させるために、複数のマシン間でのHTTPサービスのパーティショニングや負荷分散を可能にするために、レガシーまたは信頼できない情報サービスをカプセル化するために使用されています。"
    },
    {
      "indent": 3,
      "text": "All HTTP requirements applicable to an origin server also apply to the outbound communication of a gateway. A gateway communicates with inbound servers using any protocol that it desires, including private extensions to HTTP that are outside the scope of this specification. However, an HTTP-to-HTTP gateway that wishes to interoperate with third-party HTTP servers ought to conform to user agent requirements on the gateway's inbound connection.",
      "ja": "オリジンサーバに適用されるすべてのHTTP要求は、ゲートウェイのアウトバウンド通信に適用されます。ゲートウェイは、それがこの仕様の範囲外であるHTTPにプライベート拡張を含む、希望する任意のプロトコルを使用して、インバウンドのサーバーと通信します。しかし、サードパーティのHTTPサーバと相互運用することを希望するHTTPツーHTTPゲートウェイは、ゲートウェイのインバウンド接続のユーザーエージェントの要件に適合するべきです。"
    },
    {
      "indent": 3,
      "text": "A \"tunnel\" acts as a blind relay between two connections without changing the messages. Once active, a tunnel is not considered a party to the HTTP communication, though the tunnel might have been initiated by an HTTP request. A tunnel ceases to exist when both ends of the relayed connection are closed. Tunnels are used to extend a virtual connection through an intermediary, such as when Transport Layer Security (TLS, [RFC5246]) is used to establish confidential communication through a shared firewall proxy.",
      "ja": "「トンネル」は、メッセージを変更せずに2つの接続間のブラインドリレーとして作用します。トンネルはHTTPリクエストによって開始されているかもしれませんが、アクティブたら、トンネルは、HTTP通信の当事者とはみなされません。トンネルは、中継接続の両端が閉じているときに存在しなくなります。トンネルは、トランスポート層セキュリティ（TLS、[RFC5246]）が共有ファイアウォール、プロキシを介して秘匿通信を確立するために使用される場合のように介して仮想接続を拡張するために使用されます。"
    },
    {
      "indent": 3,
      "text": "The above categories for intermediary only consider those acting as participants in the HTTP communication. There are also intermediaries that can act on lower layers of the network protocol stack, filtering or redirecting HTTP traffic without the knowledge or permission of message senders. Network intermediaries are indistinguishable (at a protocol level) from a man-in-the-middle attack, often introducing security flaws or interoperability problems due to mistakenly violating HTTP semantics.",
      "ja": "仲介のための上記のカテゴリだけでHTTP通信の参加者として動作し、それらを考慮してください。フィルタリングやメッセージ送信者の知識や許可なしにHTTPトラフィックをリダイレクトするネットワーク・プロトコル・スタックの下位層に作用することができ仲介もあります。ネットワーク仲介は、多くの場合、セキュリティ上の欠陥または誤ってHTTPのセマンティクスに違反による相互運用性の問題を導入し、man-in-the-middle攻撃から（プロトコルレベルで）区別することはできません。"
    },
    {
      "indent": 3,
      "text": "For example, an \"interception proxy\" [RFC3040] (also commonly known as a \"transparent proxy\" [RFC1919] or \"captive portal\") differs from an HTTP proxy because it is not selected by the client. Instead, an interception proxy filters or redirects outgoing TCP port 80 packets (and occasionally other common port traffic). Interception proxies are commonly found on public network access points, as a means of enforcing account subscription prior to allowing use of non-local Internet services, and within corporate firewalls to enforce network usage policies.",
      "ja": "それがクライアントによって選択されていないので、例えば、「傍受プロキシ」[RFC3040]（一般に「透過プロキシ」として知られている[RFC1919]または「キャプティブポータル」）は、HTTPプロキシは異なります。代わりに、傍受プロキシフィルタまたは発信TCPポート80個のパケット（時には他の一般的なポートのトラフィック）をリダイレクトします。迎撃プロキシは、一般的に前に非ローカルのインターネットサービスの使用を可能にするアカウントのサブスクリプションを強制する手段として、パブリックネットワークアクセスポイントで発見されており、企業のファイアウォール内のネットワーク使用ポリシーを施行します。"
    },
    {
      "indent": 3,
      "text": "HTTP is defined as a stateless protocol, meaning that each request message can be understood in isolation. Many implementations depend on HTTP's stateless design in order to reuse proxied connections or dynamically load balance requests across multiple servers. Hence, a server MUST NOT assume that two requests on the same connection are from the same user agent unless the connection is secured and specific to that agent. Some non-standard HTTP extensions (e.g., [RFC4559]) have been known to violate this requirement, resulting in security and interoperability problems.",
      "ja": "HTTPは、各要求メッセージは分離して理解することができることを意味し、ステートレスなプロトコルとして定義されます。多くの実装では、プロキシ接続を再利用したり、動的に複数のサーバ間のバランスのリクエストをロードするために、HTTPのステートレスな設計に依存します。そのため、サーバは接続を確保し、そのエージェントに固有のされていない限り、同じ接続上の2つの要求が同じユーザエージェントからのものと仮定してはいけません。いくつかの非標準のHTTPの拡張（例えば、[RFC4559]）セキュリティと相互運用性の問題が生じ、この要件に違反することが知られています。"
    },
    {
      "indent": 0,
      "text": "2.4. Caches",
      "section_title": true,
      "ja": "2.4。キャッシュ"
    },
    {
      "indent": 3,
      "text": "A \"cache\" is a local store of previous response messages and the subsystem that controls its message storage, retrieval, and deletion. A cache stores cacheable responses in order to reduce the response time and network bandwidth consumption on future, equivalent requests. Any client or server MAY employ a cache, though a cache cannot be used by a server while it is acting as a tunnel.",
      "ja": "「キャッシュ」は、以前の応答メッセージとそのメッセージの保存、検索、および削除を制御するサブシステムの地元のお店です。キャッシュは、将来、同等の要求の応答時間とネットワーク帯域幅の消費量を削減するために、キャッシュ可能な応答を格納します。それはトンネルとして動作している間、キャッシュはサーバーで使用することはできないものの、任意のクライアントまたはサーバは、キャッシュを使用することができます。"
    },
    {
      "indent": 3,
      "text": "The effect of a cache is that the request/response chain is shortened if one of the participants along the chain has a cached response applicable to that request. The following illustrates the resulting chain if B has a cached copy of an earlier response from O (via C) for a request that has not been cached by UA or A.",
      "ja": "キャッシュの効果がチェーンに沿って参加者の1人がその要求に適用可能なキャッシュされた応答を持っている場合は、要求/応答チェーンが短縮されるということです。 Bは、UAまたはAによってキャッシュされていない要求の（Cを介して）Oからの以前の応答のキャッシュされたコピーを有する場合、以下が得られるチェーンを示します"
    },
    {
      "indent": 10,
      "text": "     >             >\nUA =========== A =========== B - - - - - - C - - - - - - O\n           <             <",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A response is \"cacheable\" if a cache is allowed to store a copy of the response message for use in answering subsequent requests. Even when a response is cacheable, there might be additional constraints placed by the client or by the origin server on when that cached response can be used for a particular request. HTTP requirements for cache behavior and cacheable responses are defined in Section 2 of [RFC7234].",
      "ja": "キャッシュが後続の要求に答える中で使用するための応答メッセージのコピーを保存することが許可されている場合、応答は、「キャッシュ可能」です。応答がキャッシュ可能である場合でも、そのキャッシュされた応答は、特定の要求のために使用することができるときに、クライアントまたはオリジンサーバによって配置追加の制約があるかもしれません。キャッシュの動作やキャッシュ可能なレスポンスのHTTP要求は、[RFC7234]のセクション2で定義されています。"
    },
    {
      "indent": 3,
      "text": "There is a wide variety of architectures and configurations of caches deployed across the World Wide Web and inside large organizations. These include national hierarchies of proxy caches to save transoceanic bandwidth, collaborative systems that broadcast or multicast cache entries, archives of pre-fetched cache entries for use in off-line or high-latency environments, and so on.",
      "ja": "ワールド・ワイド・ウェブを横切り、大規模な組織内で展開され、キャッシュのアーキテクチャおよび多種多様な構成があります。これらは、その上の大洋横断の帯域幅を節約するために、プロキシキャッシュの国民階層、ブロードキャストやマルチキャストのキャッシュエントリの共同システム、オフラインまたは高遅延環境での使用のためのプリフェッチキャッシュエントリのアーカイブなどがあります。"
    },
    {
      "indent": 0,
      "text": "2.5. Conformance and Error Handling",
      "section_title": true,
      "ja": "2.5。適合性とエラー処理"
    },
    {
      "indent": 3,
      "text": "This specification targets conformance criteria according to the role of a participant in HTTP communication. Hence, HTTP requirements are placed on senders, recipients, clients, servers, user agents, intermediaries, origin servers, proxies, gateways, or caches, depending on what behavior is being constrained by the requirement. Additional (social) requirements are placed on implementations, resource owners, and protocol element registrations when they apply beyond the scope of a single communication.",
      "ja": "この仕様はHTTP通信における参加者の役割に応じた適合基準をターゲットにしています。したがって、HTTP要求は要求によって制約されているものの行動に応じて、送信者、受信者、クライアント、サーバ、ユーザエージェント、仲介、オリジンサーバ、プロキシ、ゲートウェイ、またはキャッシュに配置されます。彼らは、単一の通信の範囲を超えて適用する場合は、追加の（社会的な）要件を実装、リソースの所有者、およびプロトコル要素の登録に置かれています。"
    },
    {
      "indent": 3,
      "text": "The verb \"generate\" is used instead of \"send\" where a requirement differentiates between creating a protocol element and merely forwarding a received element downstream.",
      "ja": "動詞「生成」は要件がプロトコル要素を作成し、単に下流受信素子を転送区別ここで「送信」の代わりに使用されています。"
    },
    {
      "indent": 3,
      "text": "An implementation is considered conformant if it complies with all of the requirements associated with the roles it partakes in HTTP.",
      "ja": "それはHTTPでpartakes役割に関連付けられている要件のすべてに適合していた場合に実装が準拠とみなされます。"
    },
    {
      "indent": 3,
      "text": "Conformance includes both the syntax and semantics of protocol elements. A sender MUST NOT generate protocol elements that convey a meaning that is known by that sender to be false. A sender MUST NOT generate protocol elements that do not match the grammar defined by the corresponding ABNF rules. Within a given message, a sender MUST NOT generate protocol elements or syntax alternatives that are only allowed to be generated by participants in other roles (i.e., a role that the sender does not have for that message).",
      "ja": "適合性は、プロトコル要素の構文と意味の両方を含んでいます。送信者が偽であることをその送信者によって知られている意味を伝えるプロトコル要素を生成してはなりません。送信者は、対応するABNF規則によって定義された文法と一致しないプロトコル要素を生成してはなりません。指定されたメッセージ内に、送信者は、他のロールの参加者によって生成されることが許可されているプロトコル要素又は構文の選択肢を生成してはいけません（すなわち、送信者がそのメッセージを持っていない役割）。"
    },
    {
      "indent": 3,
      "text": "When a received protocol element is parsed, the recipient MUST be able to parse any value of reasonable length that is applicable to the recipient's role and that matches the grammar defined by the corresponding ABNF rules. Note, however, that some received protocol elements might not be parsed. For example, an intermediary forwarding a message might parse a header-field into generic field-name and field-value components, but then forward the header field without further parsing inside the field-value.",
      "ja": "受信されたプロトコル要素が解析されるとき、受信者は、受信者の役割に適用可能であり、それは、対応するABNF規則によって定義された文法に一致する合理的長さの任意の値を解析できなければなりません。いくつかの受信プロトコル要素が解析されない可能性があること、しかし、注意してください。例えば、メッセージを転送仲介は、一般的なフィールド名およびフィールド値成分にヘッダフィールドを解析するかもしれないが、その後さらに、フィールド値内部解析せずヘッダフィールドを転送します。"
    },
    {
      "indent": 3,
      "text": "HTTP does not have specific length limitations for many of its protocol elements because the lengths that might be appropriate will vary widely, depending on the deployment context and purpose of the implementation. Hence, interoperability between senders and recipients depends on shared expectations regarding what is a reasonable length for each protocol element. Furthermore, what is commonly understood to be a reasonable length for some protocol elements has changed over the course of the past two decades of HTTP use and is expected to continue changing in the future.",
      "ja": "適切かもしれない長さは、実装の展開状況と目的に応じて、広く変化するので、HTTPは、プロトコル要素の多くは特定の長さの制限がありません。したがって、送信者と受信者間の相互運用性は、各プロトコル要素のための合理的な長さであるものについて、共有の期待に依存します。また、どのような一般的にHTTPの使用の過去二十年にわたって変化しているいくつかのプロトコル要素のための合理的な長さであることが理解されており、将来的に変化続けると予想されます。"
    },
    {
      "indent": 3,
      "text": "At a minimum, a recipient MUST be able to parse and process protocol element lengths that are at least as long as the values that it generates for those same protocol elements in other messages. For example, an origin server that publishes very long URI references to its own resources needs to be able to parse and process those same references when received as a request target.",
      "ja": "最低でも、受信者は、それが他のメッセージにおけるものと同じプロトコル要素に対して生成値と少なくとも同じ長さであるプロトコル要素の長さを解析し、処理できなければなりません。たとえば、独自のリソースに非常に長いURI参照を公開するオリジンサーバは、要求のターゲットとして受信したときに、同じ参照を解析して処理できるようにする必要があります。"
    },
    {
      "indent": 3,
      "text": "A recipient MUST interpret a received protocol element according to the semantics defined for it by this specification, including extensions to this specification, unless the recipient has determined (through experience or configuration) that the sender incorrectly implements what is implied by those semantics. For example, an origin server might disregard the contents of a received Accept-Encoding header field if inspection of the User-Agent header field indicates a specific implementation version that is known to fail on receipt of certain content codings.",
      "ja": "受信者は送信者が誤ってこれらのセマンティクスによって示唆されているものを実装していること（経験または構成を介して）決定していない限り、受信者は、この仕様の拡張を含む、本明細書によって、定義されたセマンティクスに従って、受信プロトコル要素を解釈しなければなりません。 User-Agentヘッダフィールドの検査は、特定のコンテンツ・コーディングの受信に失敗することが知られている特定の実装のバージョンを示している場合、例えば、オリジンサーバは、受信された承諾をコードするヘッダフィールドの内容を無視するかもしれません。"
    },
    {
      "indent": 3,
      "text": "Unless noted otherwise, a recipient MAY attempt to recover a usable protocol element from an invalid construct. HTTP does not define specific error handling mechanisms except when they have a direct impact on security, since different applications of the protocol require different error handling strategies. For example, a Web browser might wish to transparently recover from a response where the Location header field doesn't parse according to the ABNF, whereas a systems control client might consider any form of error recovery to be dangerous.",
      "ja": "特に断りのない限り、受信者が無効な構築物から使用可能なプロトコル要素を回復しようとすることができます。プロトコルの異なるアプリケーションは異なるエラー処理戦略を必要とするため、HTTPは、彼らはセキュリティに直接影響を持っている場合を除き、特定のエラー処理メカニズムを定義していません。たとえば、Webブラウザは透過的にシステム制御クライアントが危険であるとエラー回復のいずれかの形式を検討するかもしれないのに対し、Locationヘッダフィールドは、ABNFによる解析しません応答から回復したいかもしれません。"
    },
    {
      "indent": 0,
      "text": "2.6. Protocol Versioning",
      "section_title": true,
      "ja": "2.6。プロトコルバージョン"
    },
    {
      "indent": 3,
      "text": "HTTP uses a \"<major>.<minor>\" numbering scheme to indicate versions of the protocol. This specification defines version \"1.1\". The protocol version as a whole indicates the sender's conformance with the set of requirements laid out in that version's corresponding specification of HTTP.",
      "ja": "HTTPプロトコルのバージョンを示すために、「<主要な>。<マイナー>」番号方式を使用しています。この仕様は、バージョン「1.1」を定義します。全体としてのプロトコルバージョンはHTTPのバージョンの対応する仕様にレイアウト要件のセットと、送信者の適合性を示します。"
    },
    {
      "indent": 3,
      "text": "The version of an HTTP message is indicated by an HTTP-version field in the first line of the message. HTTP-version is case-sensitive.",
      "ja": "HTTPメッセージのバージョンはメッセージの最初の行にHTTPバージョンフィールドによって示されています。 HTTP-バージョンは、大文字と小文字が区別されます。"
    },
    {
      "indent": 5,
      "text": "HTTP-version = HTTP-name \"/\" DIGIT \".\" DIGIT HTTP-name = %x48.54.54.50 ; \"HTTP\", case-sensitive",
      "ja": "HTTP-バージョン= HTTP-名 \"/\" DIGIT \"\" DIGIT HTTP-名=％のx48.54.54.50。 「HTTP」、大文字と小文字を区別"
    },
    {
      "indent": 3,
      "text": "The HTTP version number consists of two decimal digits separated by a \".\" (period or decimal point). The first digit (\"major version\") indicates the HTTP messaging syntax, whereas the second digit (\"minor version\") indicates the highest minor version within that major version to which the sender is conformant and able to understand for future communication. The minor version advertises the sender's communication capabilities even when the sender is only using a backwards-compatible subset of the protocol, thereby letting the recipient know that more advanced features can be used in response (by servers) or in future requests (by clients).",
      "ja": "HTTPのバージョン番号は、「」で区切られた2桁の10進数で構成されてい（ピリオドまたは小数点）。二桁目（「マイナーバージョン」）は、送信者が準拠し、将来の通信のために理解することができたというメジャーバージョン内で最高のマイナーバージョンを示し、一方、最初の桁（「メジャーバージョン」）は、HTTPメッセージの構文を示します。マイナーバージョンは、送信者が唯一、それによって受信者をさせる、プロトコルの下位互換性のサブセットを使用する場合であっても、送信者の通信機能をアドバタイズ（クライアントによって）、より高度な機能は、（サーバ別）応答または将来の要求で使用することができることを知っています。"
    },
    {
      "indent": 3,
      "text": "When an HTTP/1.1 message is sent to an HTTP/1.0 recipient [RFC1945] or a recipient whose version is unknown, the HTTP/1.1 message is constructed such that it can be interpreted as a valid HTTP/1.0 message if all of the newer features are ignored. This specification places recipient-version requirements on some new features so that a conformant sender will only use compatible features until it has determined, through configuration or the receipt of a message, that the recipient supports HTTP/1.1.",
      "ja": "HTTP / 1.1メッセージがHTTP / 1.0レシピエント[RFC1945]またはそのバージョンが不明である受信者に送信されると、HTTP / 1.1のメッセージは、新しいすべての場合、それは有効なHTTP / 1.0メッセージとして解釈することができるように構成されています機能は無視されます。それが決定するまでに準拠し、送信者が受信者だけがHTTP / 1.1をサポートしていること、構成やメッセージの受信により、互換性のある機能を使用するように、この仕様は、いくつかの新機能について受信者-バージョン要件を課します。"
    },
    {
      "indent": 3,
      "text": "The interpretation of a header field does not change between minor versions of the same major HTTP version, though the default behavior of a recipient in the absence of such a field can change. Unless specified otherwise, header fields defined in HTTP/1.1 are defined for all versions of HTTP/1.x. In particular, the Host and Connection header fields ought to be implemented by all HTTP/1.x implementations whether or not they advertise conformance with HTTP/1.1.",
      "ja": "そのようなフィールドが存在しない場合に、受信者のデフォルトの動作を変更することができますが、ヘッダフィールドの解釈は、同じメジャーHTTPのバージョンのマイナーバージョン間で変更されません。特に断りのない限り、HTTP / 1.1で定義されたヘッダフィールドは、HTTP / 1.1のすべてのバージョンのために定義されています。具体的には、ホストとの接続ヘッダフィールドは、それらがHTTP / 1.1に準拠をアドバタイズかどうか、すべてのHTTP / 1.1の実装によって実現されるべきです。"
    },
    {
      "indent": 3,
      "text": "New header fields can be introduced without changing the protocol version if their defined semantics allow them to be safely ignored by recipients that do not recognize them. Header field extensibility is discussed in Section 3.2.1.",
      "ja": "その定義されたセマンティクスは彼らが安全にそれらを認識しない受信者によって無視されることを可能にする場合は、新しいヘッダフィールドは、プロトコルのバージョンを変更せずに導入することができます。ヘッダフィールドの拡張性は、3.2.1節で説明されています。"
    },
    {
      "indent": 3,
      "text": "Intermediaries that process HTTP messages (i.e., all intermediaries other than those acting as tunnels) MUST send their own HTTP-version in forwarded messages. In other words, they are not allowed to blindly forward the first line of an HTTP message without ensuring that the protocol version in that message matches a version to which that intermediary is conformant for both the receiving and sending of messages. Forwarding an HTTP message without rewriting the",
      "ja": "HTTPメッセージ（トンネルとして機能するもの以外のすなわち、すべての仲介）を処理する仲介者は、転送されたメッセージでは、独自のHTTPバージョンを送らなければなりません。換言すれば、それらは盲目的にそのメッセージのプロトコルバージョンは、その中間の受信とメッセージの送信の両方のために適合されているバージョンと一致することを確実にすることなく、HTTPメッセージの最初のラインを転送することはできません。書き換えずにHTTPメッセージの転送"
    },
    {
      "indent": 3,
      "text": "HTTP-version might result in communication errors when downstream recipients use the message sender's version to determine what features are safe to use for later communication with that sender.",
      "ja": "下流の受信者はその送信者と、後の通信に使用しても安全であるかの特徴を決定するために、メッセージの送信者のバージョンを使用する場合、HTTP-バージョンは、通信エラーが発生する可能性があります。"
    },
    {
      "indent": 3,
      "text": "A client SHOULD send a request version equal to the highest version to which the client is conformant and whose major version is no higher than the highest version supported by the server, if this is known. A client MUST NOT send a version to which it is not conformant.",
      "ja": "クライアントは、クライアントが準拠し、そのメジャーバージョンこれがわかっている場合は、サーバーでサポートされている最も高いバージョンよりも高くないされている最も高いバージョンに等しい要求バージョンを送るべきです。クライアントが準拠していないにバージョンを送ってはいけません。"
    },
    {
      "indent": 3,
      "text": "A client MAY send a lower request version if it is known that the server incorrectly implements the HTTP specification, but only after the client has attempted at least one normal request and determined from the response status code or header fields (e.g., Server) that the server improperly handles higher request versions.",
      "ja": "サーバが誤っHTTP仕様を実装することが知られているが、クライアントは、少なくとも一つの通常の要求を試みた後にのみ、応答ステータスコード又はヘッダフィールド（例えば、サーバ）とは判定された場合、クライアントは、より低い要求のバージョンを送信することができますサーバーは不適切高い要求のバージョンを処理します。"
    },
    {
      "indent": 3,
      "text": "A server SHOULD send a response version equal to the highest version to which the server is conformant that has a major version less than or equal to the one received in the request. A server MUST NOT send a version to which it is not conformant. A server can send a 505 (HTTP Version Not Supported) response if it wishes, for any reason, to refuse service of the client's major protocol version.",
      "ja": "サーバは、要求で受信した1つ以下のメジャーバージョンを持っているサーバが適合されている最高のバージョンに等しい応答バージョンを送るべきです。サーバは準拠していないにバージョンを送ってはいけません。それが希望する場合、サーバーはクライアントの主要なプロトコルバージョンのサービスを拒否するために、何らかの理由で、505（HTTPバージョンがサポートされていない）応答を送信することができます。"
    },
    {
      "indent": 3,
      "text": "A server MAY send an HTTP/1.0 response to a request if it is known or suspected that the client incorrectly implements the HTTP specification and is incapable of correctly processing later version responses, such as when a client fails to parse the version number correctly or when an intermediary is known to blindly forward the HTTP-version even when it doesn't conform to the given minor version of the protocol. Such protocol downgrades SHOULD NOT be performed unless triggered by specific client attributes, such as when one or more of the request header fields (e.g., User-Agent) uniquely match the values sent by a client known to be in error.",
      "ja": "それが知られているか、またはクライアントが誤ってHTTPの仕様を実装しており、このようなクライアントが正しく場合や、バージョン番号を解析するために失敗したときのように正しく処理以降のバージョン応答、できないと疑われる場合、サーバーは、要求にHTTP / 1.0レスポンスを送信することができ仲介は盲目的にそれがプロトコルの特定のマイナーバージョンに準拠していなくてもHTTPバージョンを転送することが知られています。特定のクライアントによってトリガは、リクエストヘッダフィールドの1つ以上（例えば、ユーザーエージェント）一意エラーであることが知られているクライアントによって送信された値と一致するときのように、属性がない限り、このようなプロトコルのダウングレードを実行しないでください。"
    },
    {
      "indent": 3,
      "text": "The intention of HTTP's versioning design is that the major number will only be incremented if an incompatible message syntax is introduced, and that the minor number will only be incremented when changes made to the protocol have the effect of adding to the message semantics or implying additional capabilities of the sender. However, the minor version was not incremented for the changes introduced between [RFC2068] and [RFC2616], and this revision has specifically avoided any such changes to the protocol.",
      "ja": "HTTPのバージョン管理の設計の意図は、互換性のないメッセージ構文が導入されている場合、主要な数だけインクリメントされること、およびプロトコルに加えられた変更は、メッセージの意味を追加したり、追加の暗示の効果を持っている時にマイナー番号だけインクリメントされるということです送信者の能力。しかし、マイナーバージョンは、[RFC2068]及び[RFC2616]の間に導入された変更のためにインクリメントされていなかった、この改訂は、具体的には、プロトコルへの任意のそのような変更を避けてきました。"
    },
    {
      "indent": 3,
      "text": "When an HTTP message is received with a major version number that the recipient implements, but a higher minor version number than what the recipient implements, the recipient SHOULD process the message as if it were in the highest minor version within that major version to which the recipient is conformant. A recipient can assume that a message with a higher minor version, when sent to a recipient that has not yet indicated support for that higher version, is sufficiently backwards-compatible to be safely processed by any implementation of the same major version.",
      "ja": "HTTPメッセージは、受信者が実装するもの、それはへのメジャーバージョン内で最高のマイナーバージョンにあったかのように、受信者がメッセージを処理すべきであるよりも、受信者が実装するメジャーバージョン番号が、より高いマイナーバージョン番号を受信した場合受信者は準拠です。受信者は、まだより高いバージョンのサポートを示していない受信者に送信より高いマイナーバージョンのメッセージは、安全に同じメジャーバージョンのいずれかのインプリメンテーションによって処理されるのに十分に下位互換性があると仮定することができます。"
    },
    {
      "indent": 0,
      "text": "2.7. Uniform Resource Identifiers",
      "section_title": true,
      "ja": "2.7。統一資源識別子"
    },
    {
      "indent": 3,
      "text": "Uniform Resource Identifiers (URIs) [RFC3986] are used throughout HTTP as the means for identifying resources (Section 2 of [RFC7231]). URI references are used to target requests, indicate redirects, and define relationships.",
      "ja": "ユニフォームリソース識別子（URIの）[RFC3986]は、リソース（[RFC7231]のセクション2）を識別するための手段として、HTTP全体にわたって使用されます。 URI参照は、リクエストをターゲットリダイレクトを示し、関係を定義するために使用されています。"
    },
    {
      "indent": 3,
      "text": "The definitions of \"URI-reference\", \"absolute-URI\", \"relative-part\", \"scheme\", \"authority\", \"port\", \"host\", \"path-abempty\", \"segment\", \"query\", and \"fragment\" are adopted from the URI generic syntax. An \"absolute-path\" rule is defined for protocol elements that can contain a non-empty path component. (This rule differs slightly from the path-abempty rule of RFC 3986, which allows for an empty path to be used in references, and path-absolute rule, which does not allow paths that begin with \"//\".) A \"partial-URI\" rule is defined for protocol elements that can contain a relative URI but not a fragment component.",
      "ja": "「URI参照」、「絶対URI」、「相対的な部分」、「スキーム」、「権限」、「ポート」、「宿主」、「パスabempty」、「セグメント」、「クエリ」の定義、および「断片」URIジェネリック構文から採用されています。 「絶対パス」ルールは、非空のパスコンポーネントを含むことができるプロトコル要素のために定義されています。 （この規則は、参照に使用する空のパス、および「//」で始まるパスを許可しないパス絶対ルールを可能にするRFC 3986のパスabemptyルール、若干異なる。）「部分-uri」ルールは、相対URIはなくフラグメントコンポーネントを含むことができるプロトコル要素のために定義されています。"
    },
    {
      "indent": 5,
      "text": "URI-reference = <URI-reference, see [RFC3986], Section 4.1> absolute-URI = <absolute-URI, see [RFC3986], Section 4.3> relative-part = <relative-part, see [RFC3986], Section 4.2> scheme = <scheme, see [RFC3986], Section 3.1> authority = <authority, see [RFC3986], Section 3.2> uri-host = <host, see [RFC3986], Section 3.2.2> port = <port, see [RFC3986], Section 3.2.3> path-abempty = <path-abempty, see [RFC3986], Section 3.3> segment = <segment, see [RFC3986], Section 3.3> query = <query, see [RFC3986], Section 3.4> fragment = <fragment, see [RFC3986], Section 3.5>",
      "ja": "URIリファレンス= <URI参照、[RFC3986]、セクション4.1を参照>絶対URI =相対一部= <相対部分<絶対URIは、[RFC3986]、セクション4.3を参照>、[RFC3986]セクション4.2参照>スキーム= <スキーム、[RFC3986]を見てください、セクション3.1>権限= <権限、[RFC3986]を参照して、3.2節>のuri-ホスト= <ホスト、[RFC3986]を見てください、セクション3.2.2>ポート= <ポート、参照[RFC3986]、セクション3.2.3>パスabempty = <パスabempty、[RFC3986]を参照して、第3.3節>セグメント= <セグメント、[RFC3986]を参照して、第3.3節>クエリ= <クエリ、[RFC3986]を参照、セクション3.4>断片= <断片、[RFC3986]を参照して、セクション3.5>"
    },
    {
      "indent": 5,
      "text": "absolute-path = 1*( \"/\" segment ) partial-URI = relative-part [ \"?\" query ]",
      "ja": "絶対パス= 1 *（ \"/\" セグメント）部分-URI =相対パート[ \"？\"クエリ]"
    },
    {
      "indent": 3,
      "text": "Each protocol element in HTTP that allows a URI reference will indicate in its ABNF production whether the element allows any form of reference (URI-reference), only a URI in absolute form (absolute-URI), only the path and optional query components, or some combination of the above. Unless otherwise indicated, URI references are parsed relative to the effective request URI (Section 5.5).",
      "ja": "URI参照を可能にするHTTPの各プロトコル要素は、要素が参照（URI参照）のいずれかの形態、絶対形式でのみURI（絶対URI）、唯一のパスおよび任意のクエリコンポーネントを許可するかどうか、そのABNF生産に表示されます、または上記のいくつかの組み合わせ。特に断らない限り、URI参照は有効なリクエストURI（第5.5節）に対して解析されます。"
    },
    {
      "indent": 0,
      "text": "2.7.1. http URI Scheme",
      "section_title": true,
      "ja": "2.7.1。 HTTP URIスキーム"
    },
    {
      "indent": 3,
      "text": "The \"http\" URI scheme is hereby defined for the purpose of minting identifiers according to their association with the hierarchical namespace governed by a potential HTTP origin server listening for TCP ([RFC0793]) connections on a given port.",
      "ja": "「HTTP」URIスキームは、ここでTCP（[RFC0793]）指定されたポートで接続をリッスン潜在的なHTTPオリジンサーバによって支配階層的な名前空間との関連に応じて鋳造識別子の目的のために定義されています。"
    },
    {
      "indent": 5,
      "text": "http-URI = \"http:\" \"//\" authority path-abempty [ \"?\" query ] [ \"#\" fragment ]",
      "ja": "HTTP-URI = \"HTTP：\" \"//\" 権威パスabemptyの[ \"\"？クエリ] [ \"＃\" フラグメント]"
    },
    {
      "indent": 3,
      "text": "The origin server for an \"http\" URI is identified by the authority component, which includes a host identifier and optional TCP port ([RFC3986], Section 3.2.2). The hierarchical path component and optional query component serve as an identifier for a potential target resource within that origin server's name space. The optional fragment component allows for indirect identification of a secondary resource, independent of the URI scheme, as defined in Section 3.5 of [RFC3986].",
      "ja": "「HTTP」URIのオリジンサーバは、ホスト識別子と任意のTCPポート（[RFC3986]、セクション3.2.2）を含む権限コンポーネントによって識別されます。階層的なパスコンポーネントとオプションのクエリコンポーネントは、オリジンサーバの名前空間内の潜在的なターゲットリソースの識別子として機能します。任意のフラグメントコンポーネントは[RFC3986]のセクション3.5で定義されるように、URIスキームとは無関係に、二次リソースの間接的同定を可能にします。"
    },
    {
      "indent": 3,
      "text": "A sender MUST NOT generate an \"http\" URI with an empty host identifier. A recipient that processes such a URI reference MUST reject it as invalid.",
      "ja": "送信者は、空のホスト識別子と「HTTP」URIを生成してはなりません。そのようなURI参照を処理する受信者は、無効として拒絶しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the host identifier is provided as an IP address, the origin server is the listener (if any) on the indicated TCP port at that IP address. If host is a registered name, the registered name is an indirect identifier for use with a name resolution service, such as DNS, to find an address for that origin server. If the port subcomponent is empty or not given, TCP port 80 (the reserved port for WWW services) is the default.",
      "ja": "ホスト識別子がIPアドレスとして提供されている場合は、オリジンサーバはそのIPアドレスで指定されたTCPポート上のリスナーは、（もしあれば）です。ホストが登録名である場合は、登録された名前は、そのオリジナル・サーバーのアドレスを見つけるためのDNSなどの名前解決サービスで使用するための間接的な識別子です。ポートサブコンポーネントは、与えられた空かそうでない場合は、TCPポート80（WWWサービスのための予約ポート）がデフォルトです。"
    },
    {
      "indent": 3,
      "text": "Note that the presence of a URI with a given authority component does not imply that there is always an HTTP server listening for connections on that host and port. Anyone can mint a URI. What the authority component determines is who has the right to respond authoritatively to requests that target the identified resource. The delegated nature of registered names and IP addresses creates a federated namespace, based on control over the indicated host and port, whether or not an HTTP server is present. See Section 9.1 for security considerations related to establishing authority.",
      "ja": "与えられた権限コンポーネントを持つURIの存在は、そのホストとポートで接続をリッスンHTTPサーバが常に存在することを意味するものではないことに注意してください。誰もがミントURIことができます。どのような権限コンポーネントが決定すると、特定されたリソースをターゲット要求に正式に対応する権利を有する者です。登録名とIPアドレスの委任性質は、HTTPサーバが存在するか否かを、指示されたホストとポートの制御に基づいて、連合の名前空間を作成します。権威の確立に関連するセキュリティ上の考慮事項については、セクション9.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "When an \"http\" URI is used within a context that calls for access to the indicated resource, a client MAY attempt access by resolving the host to an IP address, establishing a TCP connection to that address on the indicated port, and sending an HTTP request message (Section 3) containing the URI's identifying data (Section 5) to the server. If the server responds to that request with a non-interim",
      "ja": "「HTTP」URIが指定されたリソースへのアクセスを求めてコンテキスト内で使用されている場合、クライアントは、IPアドレスにホストを解決示されたポート上のアドレスへのTCP接続を確立し、HTTPを送信することによって、アクセスを試みてもよい（MAY）要求メッセージをサーバに（セクション3）URIの識別データを含む（セクション5）。サーバーは非暫定で、その要求に応答した場合"
    },
    {
      "indent": 3,
      "text": "HTTP response message, as described in Section 6 of [RFC7231], then that response is considered an authoritative answer to the client's request.",
      "ja": "[RFC7231]のセクション6で説明したようにHTTP応答メッセージは、その応答がクライアントの要求に公式の答えと考えられています。"
    },
    {
      "indent": 3,
      "text": "Although HTTP is independent of the transport protocol, the \"http\" scheme is specific to TCP-based services because the name delegation process depends on TCP for establishing authority. An HTTP service based on some other underlying connection protocol would presumably be identified using a different URI scheme, just as the \"https\" scheme (below) is used for resources that require an end-to-end secured connection. Other protocols might also be used to provide access to \"http\" identified resources -- it is only the authoritative interface that is specific to TCP.",
      "ja": "HTTPトランスポートプロトコルに依存しているが名前委譲プロセスが権限を確立するためにTCPに依存しているため、「HTTP」のスキームは、TCPベースのサービスに固有のものです。他のいくつかの根本的な接続プロトコルに基づいて、HTTPサービスは、おそらく「HTTPS」スキームは（下記）エンドツーエンドのセキュアな接続を必要とするリソースのために使用されるのと同様に、異なるURIスキームを使用して識別されます。他のプロトコルも、「HTTP」が特定のリソースへのアクセスを提供するために使用されるかもしれない - それは唯一のTCPに固有の権威のインタフェースです。"
    },
    {
      "indent": 3,
      "text": "The URI generic syntax for authority also includes a deprecated userinfo subcomponent ([RFC3986], Section 3.2.1) for including user authentication information in the URI. Some implementations make use of the userinfo component for internal configuration of authentication information, such as within command invocation options, configuration files, or bookmark lists, even though such usage might expose a user identifier or password. A sender MUST NOT generate the userinfo subcomponent (and its \"@\" delimiter) when an \"http\" URI reference is generated within a message as a request target or header field value. Before making use of an \"http\" URI reference received from an untrusted source, a recipient SHOULD parse for userinfo and treat its presence as an error; it is likely being used to obscure the authority for the sake of phishing attacks.",
      "ja": "権威のためのURIの一般的な構文はまた、URIでのユーザ認証情報を含むため、非推奨のUserInfoサブコンポーネント（[RFC3986]、セクション3.2.1）が含まれています。いくつかの実装は、そのような使用法は、ユーザーIDまたはパスワードを公開する可能性があるにもかかわらず、このようなコマンドの呼び出しオプション、設定ファイル、またはブックマークリスト内などの認証情報の内部構成のためのUserInfoコンポーネントを利用します。送信者は、「HTTP」URI参照を要求対象又はヘッダフィールド値としてメッセージ内で生成されたユーザー情報サブコンポーネント（およびその「@」デリミタ）を生成してはいけません。信頼できないソースから受信した「HTTP」URI参照を利用する前に、受信者は、ユーザー情報のために解析し、エラーとしてその存在を扱うべきです。おそらくフィッシング攻撃のために権限を分かりにくくするために使用されています。"
    },
    {
      "indent": 0,
      "text": "2.7.2. https URI Scheme",
      "section_title": true,
      "ja": "2.7.2。 HTTPSのURIスキーム"
    },
    {
      "indent": 3,
      "text": "The \"https\" URI scheme is hereby defined for the purpose of minting identifiers according to their association with the hierarchical namespace governed by a potential HTTP origin server listening to a given TCP port for TLS-secured connections ([RFC5246]).",
      "ja": "「https」のURIスキームは、ここTLSで保護された接続のための特定のTCPポートを聞いて潜在的なHTTPオリジンサーバによって支配階層的な名前空間との関連に応じて鋳造識別子の目的のために定義される（[RFC5246]）。"
    },
    {
      "indent": 3,
      "text": "All of the requirements listed above for the \"http\" scheme are also requirements for the \"https\" scheme, except that TCP port 443 is the default if the port subcomponent is empty or not given, and the user agent MUST ensure that its connection to the origin server is secured through the use of strong encryption, end-to-end, prior to sending the first HTTP request.",
      "ja": "ポートサブコンポーネントが与えられていない空の場合、または「HTTP」スキームのための上記の要件のすべては、デフォルトそのTCPポート443を除いて「https」のスキームのための要件、されており、ユーザエージェントは確保しなければならないことへの接続オリジンサーバは、エンドツーエンドの、前に最初のHTTPリクエストを送信するには、強力な暗号化を使用して固定されています。"
    },
    {
      "indent": 5,
      "text": "https-URI = \"https:\" \"//\" authority path-abempty [ \"?\" query ] [ \"#\" fragment ]",
      "ja": "HTTPS-URI = \"HTTPS：\" \"//\" 権威パスabemptyの[ \"\"？クエリ] [ \"＃\" フラグメント]"
    },
    {
      "indent": 3,
      "text": "Note that the \"https\" URI scheme depends on both TLS and TCP for establishing authority. Resources made available via the \"https\" scheme have no shared identity with the \"http\" scheme even if their resource identifiers indicate the same authority (the same host listening to the same TCP port). They are distinct namespaces and are considered to be distinct origin servers. However, an extension to HTTP that is defined to apply to entire host domains, such as the Cookie protocol [RFC6265], can allow information set by one service to impact communication with other services within a matching group of host domains.",
      "ja": "「https」のURIスキームが権威を確立するためにTLSとTCPの両方に依存することに注意してください。 「https」のスキームを介して利用可能なリソースは、そのリソース識別子が同じ権限（同じTCPポートを聞いて同じホスト）を示している場合でも、「HTTP」の方式とは、共有IDを持っていません。彼らは、異なる名前空間であり、明確な元のサーバーと見なされます。しかしながら、このようなクッキープロトコルとして全体のホストドメイン、[RFC6265]に適用するように定義されるHTTPへの拡張は、一つのサービスによって設定された情報は、ホストドメインの整合グループ内の他のサービスとの通信に影響を与えることを可能にします。"
    },
    {
      "indent": 3,
      "text": "The process for authoritative access to an \"https\" identified resource is defined in [RFC2818].",
      "ja": "「https」の識別されたリソースへのアクセス権限のための方法は、[RFC2818]で定義されています。"
    },
    {
      "indent": 0,
      "text": "2.7.3. http and https URI Normalization and Comparison",
      "section_title": true,
      "ja": "2.7.3。 HTTPとHTTPS URI正規化との比較"
    },
    {
      "indent": 3,
      "text": "Since the \"http\" and \"https\" schemes conform to the URI generic syntax, such URIs are normalized and compared according to the algorithm defined in Section 6 of [RFC3986], using the defaults described above for each scheme.",
      "ja": "「HTTP」と「HTTPS」スキームは、URIジェネリックシンタックスに準拠しているので、そのようなURIは、各スキームについて上記したデフォルト値を使用して、[RFC3986]のセクション6で定義されたアルゴリズムに従って正規化と比較されます。"
    },
    {
      "indent": 3,
      "text": "If the port is equal to the default port for a scheme, the normal form is to omit the port subcomponent. When not being used in absolute form as the request target of an OPTIONS request, an empty path component is equivalent to an absolute path of \"/\", so the normal form is to provide a path of \"/\" instead. The scheme and host are case-insensitive and normally provided in lowercase; all other components are compared in a case-sensitive manner. Characters other than those in the \"reserved\" set are equivalent to their percent-encoded octets: the normal form is to not encode them (see Sections 2.1 and 2.2 of [RFC3986]).",
      "ja": "ポートはスキームのデフォルトポートと同じであれば、通常のフォームは、ポートサブコンポーネントを省略することです。 OPTIONS要求の要求対象の絶対形態で使用されていない場合、通常の形態は、「/」代わりの経路を提供することであるので、空のパスコンポーネントは、「/」の絶対パスと等価です。スキームとホストは大文字小文字を区別せず、通常小文字に設けられています。他のすべてのコンポーネントは大文字と小文字を区別した方法で比較されます。 「予約」セット中のもの以外の文字は、それらのパーセントエンコードされたオクテットに相当する：正規形は、（セクション2.1と[RFC3986]の2.2を参照）、それらを符号化しないことです。"
    },
    {
      "indent": 3,
      "text": "For example, the following three URIs are equivalent:",
      "ja": "たとえば、次の三つのURIは等価です。"
    },
    {
      "indent": 6,
      "text": "http://example.com:80/~smith/home.html http://EXAMPLE.com/%7Esmith/home.html http://EXAMPLE.com:/%7esmith/home.html",
      "ja": "ｈっｔｐ：／／えぁｍｐぇ。こｍ：８０／〜ｓみｔｈ／ほめ。ｈｔｍｌ ｈっｔｐ：／／えぁＭＰぇ。こｍ／％７えｓみｔｈ／ほめ。ｈｔｍｌ ｈっｔｐ：／／えぁＭＰぇ。こｍ：／％７えｓみｔｈ／ほめ。ｈｔｍｌ"
    },
    {
      "indent": 0,
      "text": "3. Message Format",
      "section_title": true,
      "ja": "3.メッセージフォーマット"
    },
    {
      "indent": 3,
      "text": "All HTTP/1.1 messages consist of a start-line followed by a sequence of octets in a format similar to the Internet Message Format [RFC5322]: zero or more header fields (collectively referred to as the \"headers\" or the \"header section\"), an empty line indicating the end of the header section, and an optional message body.",
      "ja": "ゼロ以上のヘッダフィールド（まとめて「ヘッダ」または「ヘッダ部」と称する：すべてのHTTP / 1.1のメッセージは、[RFC5322]はインターネットメッセージ形式と同様の形式でオクテットのシーケンスが続くスタートラインから成り）、ヘッダ部、および任意のメッセージ本体の終了を示す空行。"
    },
    {
      "indent": 5,
      "text": "HTTP-message = start-line *( header-field CRLF ) CRLF [ message-body ]",
      "ja": "HTTPメッセージ=開始行×（ヘッダフィールドCRLF）CRLF [メッセージ本体]"
    },
    {
      "indent": 3,
      "text": "The normal procedure for parsing an HTTP message is to read the start-line into a structure, read each header field into a hash table by field name until the empty line, and then use the parsed data to determine if a message body is expected. If a message body has been indicated, then it is read as a stream until an amount of octets equal to the message body length is read or the connection is closed.",
      "ja": "HTTPメッセージを解析するための通常の手順は、構造内にスタートラインを読み取る空白行まで、フィールド名でハッシュテーブルに各ヘッダフィールドを読み、そのメッセージ本体が期待されているかどうかを決定するために解析されたデータを使用することです。メッセージ本体が示されている場合、メッセージボディの長さに等しいオクテットの量が読み取られ、または接続が閉じられるまで、それはストリームとして読み出されます。"
    },
    {
      "indent": 3,
      "text": "A recipient MUST parse an HTTP message as a sequence of octets in an encoding that is a superset of US-ASCII [USASCII]. Parsing an HTTP message as a stream of Unicode characters, without regard for the specific encoding, creates security vulnerabilities due to the varying ways that string processing libraries handle invalid multibyte character sequences that contain the octet LF (%x0A). String-based parsers can only be safely used within protocol elements after the element has been extracted from the message, such as within a header field-value after message parsing has delineated the individual fields.",
      "ja": "受信者は、USASCII [USASCII]のスーパーセットでエンコードのオクテットのシーケンスとしてHTTPメッセージを解析する必要があります。 Unicode文字のストリームとしてHTTPメッセージを解析し、特定のエンコーディングに関係なく、文字列処理ライブラリはオクテットLF（％のX0A）を含有し、無効なマルチバイト文字列を扱う様々な方法によるセキュリティの脆弱性を作成します。メッセージの構文解析は、個々のフィールドを描写した後素子は、ヘッダフィールド値以内として、メッセージから抽出された後の文字列ベースのパーサは安全プロトコル要素内でのみ使用することができます。"
    },
    {
      "indent": 3,
      "text": "An HTTP message can be parsed as a stream for incremental processing or forwarding downstream. However, recipients cannot rely on incremental delivery of partial messages, since some implementations will buffer or delay message forwarding for the sake of network efficiency, security checks, or payload transformations.",
      "ja": "HTTPメッセージは、増分処理または下流転送用のストリームとして解析することができます。いくつかの実装は、緩衝液またはネットワーク効率、セキュリティチェック、またはペイロード変換のためにメッセージ転送を遅延させるので、受信者は、部分的なメッセージの増分配信に頼ることはできません。"
    },
    {
      "indent": 3,
      "text": "A sender MUST NOT send whitespace between the start-line and the first header field. A recipient that receives whitespace between the start-line and the first header field MUST either reject the message as invalid or consume each whitespace-preceded line without further processing of it (i.e., ignore the entire line, along with any subsequent lines preceded by whitespace, until a properly formed header field is received or the header section is terminated).",
      "ja": "送信側は、スタートラインと第一のヘッダフィールドとの間の空白を送ってはいけません。スタートラインと最初のヘッダーフィールドとの間の空白を受信する受信者が無効メッセージを拒否するかのさらなる処理なしに各空白先行ラインを消費しなければならないのいずれか（すなわち、空白が先行し後続の行とともに、行全体を無視します適切に形成されたヘッダフィールドが受信されるまで、または、ヘッダ部）が終了します。"
    },
    {
      "indent": 3,
      "text": "The presence of such whitespace in a request might be an attempt to trick a server into ignoring that field or processing the line after it as a new request, either of which might result in a security vulnerability if other implementations within the request chain interpret the same message differently. Likewise, the presence of such whitespace in a response might be ignored by some clients or cause others to cease parsing.",
      "ja": "要求中のこのような空白の存在は、要求チェーン内の他の実装が同じ解釈場合、セキュリティ上の脆弱性をもたらす可能性があるこれらのいずれも新しい要求としてそのフィールドを無視するか、後行の処理にサーバーをだますための試みであるかもしれませんメッセージは異なります。同様に、応答でこのような空白の存在は、いくつかのクライアントによって無視されたり、構文解析を中止し、他の原因である可能性があります。"
    },
    {
      "indent": 0,
      "text": "3.1. Start Line",
      "section_title": true,
      "ja": "3.1。スタートライン"
    },
    {
      "indent": 3,
      "text": "An HTTP message can be either a request from client to server or a response from server to client. Syntactically, the two types of message differ only in the start-line, which is either a request-line (for requests) or a status-line (for responses), and in the algorithm for determining the length of the message body (Section 3.3).",
      "ja": "HTTPメッセージは、クライアントからサーバーへの要求やサーバーからクライアントへの応答のいずれかになります。構文的に、メッセージの2種類がセクション（メッセージ本体の長さを決定する（要求用）リクエストラインのいずれかであるスタートライン、または（応答の）ステータスラインで、及びアルゴリズムのみが異なります3.3）。"
    },
    {
      "indent": 3,
      "text": "In theory, a client could receive requests and a server could receive responses, distinguishing them by their different start-line formats, but, in practice, servers are implemented to only expect a request (a response is interpreted as an unknown or invalid request method) and clients are implemented to only expect a response.",
      "ja": "理論的には、クライアントが要求を受け取ることができるし、サーバが応答を受け取ることができ、それらの異なるスタートライン形式でそれらを区別する、しかし、実際には、サーバのみを期待し、要求（応答が不明または無効なリクエストメソッドとして解釈されるに実装されています）とクライアントにのみ応答を期待するために実装されています。"
    },
    {
      "indent": 5,
      "text": "start-line = request-line / status-line",
      "ja": "スタートライン=リクエストライン/ステータスライン"
    },
    {
      "indent": 0,
      "text": "3.1.1. Request Line",
      "section_title": true,
      "ja": "3.1.1。要求行"
    },
    {
      "indent": 3,
      "text": "A request-line begins with a method token, followed by a single space (SP), the request-target, another single space (SP), the protocol version, and ends with CRLF.",
      "ja": "要求ラインは、単一の空間（SP）、要求先、別の単一の空間（SP）、プロトコルバージョン続い方法トークンで始まり、CRLFで終わります。"
    },
    {
      "indent": 5,
      "text": "request-line = method SP request-target SP HTTP-version CRLF",
      "ja": "リクエストライン=法SP要求対象のSPのHTTPバージョンCRLF"
    },
    {
      "indent": 3,
      "text": "The method token indicates the request method to be performed on the target resource. The request method is case-sensitive.",
      "ja": "方法トークンは、ターゲット・リソース上で実行される要求の方法を示しています。リクエストメソッドは、大文字と小文字が区別されます。"
    },
    {
      "indent": 5,
      "text": "method = token",
      "ja": "方法=トークン"
    },
    {
      "indent": 3,
      "text": "The request methods defined by this specification can be found in Section 4 of [RFC7231], along with information regarding the HTTP method registry and considerations for defining new methods.",
      "ja": "この仕様で定義されたリクエストのメソッドは、新しいメソッドを定義するためのHTTPメソッドレジストリと考慮事項に関する情報と共に、[RFC7231]のセクション4に見出すことができます。"
    },
    {
      "indent": 3,
      "text": "The request-target identifies the target resource upon which to apply the request, as defined in Section 5.3.",
      "ja": "セクション5.3で定義されるように要求ターゲットは、要求を適用する際に、ターゲットリソースを識別する。"
    },
    {
      "indent": 3,
      "text": "Recipients typically parse the request-line into its component parts by splitting on whitespace (see Section 3.5), since no whitespace is allowed in the three components. Unfortunately, some user agents fail to properly encode or exclude whitespace found in hypertext references, resulting in those disallowed characters being sent in a request-target.",
      "ja": "何空白は、3つの構成要素で許可されていないので、受信者は、典型的には、（3.5節を参照）空白に分割することによって、その構成部品に要求ラインを解析します。残念ながら、一部のユーザーエージェントが適切にこれらの禁止文字が要求ターゲットに送信され、その結果、ハイパーテキストの参照で見つかった空白をエンコードまたは除外するために失敗します。"
    },
    {
      "indent": 3,
      "text": "Recipients of an invalid request-line SHOULD respond with either a 400 (Bad Request) error or a 301 (Moved Permanently) redirect with the request-target properly encoded. A recipient SHOULD NOT attempt to autocorrect and then process the request without a redirect, since the invalid request-line might be deliberately crafted to bypass security filters along the request chain.",
      "ja": "無効な要求ラインの受信者は適切にエンコードされた要求対象とリダイレクト（恒久的に移動）400（不正な要求）エラーまたは301のいずれかで応答すべきです。無効な要求行が意図的に要求チェーンに沿ってセキュリティフィルタをバイパスするために作られるかもしれないので、受信者は、オートコレクト、その後、リダイレクトなしで要求を処理するために試みるべきではありません。"
    },
    {
      "indent": 3,
      "text": "HTTP does not place a predefined limit on the length of a request-line, as described in Section 2.5. A server that receives a method longer than any that it implements SHOULD respond with a 501 (Not Implemented) status code. A server that receives a request-target longer than any URI it wishes to parse MUST respond with a 414 (URI Too Long) status code (see Section 6.5.12 of [RFC7231]).",
      "ja": "セクション2.5で説明したようにHTTPは、リクエストラインの長さに所定の限界を置きません。もはやそれは501（実装されていない）状態コードで応答すべきで実装する任意のより方法を受信するサーバー。それが解析したい長い任意のURIより要求のターゲットを受け取るサーバは414（URIが長すぎます）ステータスコードで応じなければなりません（[RFC7231]のセクション6.5.12を参照してください）。"
    },
    {
      "indent": 3,
      "text": "Various ad hoc limitations on request-line length are found in practice. It is RECOMMENDED that all HTTP senders and recipients support, at a minimum, request-line lengths of 8000 octets.",
      "ja": "リクエストラインの長さにさまざまなアドホックな制限は、実際に発見されました。すべてのHTTP送信者と受信者が8000オクテットの最小値、リクエストラインの長さで、サポートすることが推奨されます。"
    },
    {
      "indent": 0,
      "text": "3.1.2. Status Line",
      "section_title": true,
      "ja": "3.1.2。ステータス行"
    },
    {
      "indent": 3,
      "text": "The first line of a response message is the status-line, consisting of the protocol version, a space (SP), the status code, another space, a possibly empty textual phrase describing the status code, and ending with CRLF.",
      "ja": "応答メッセージの最初の行は、プロトコルバージョンからなる、ステータスラインであり、空間（SP）、ステータスコード、別の空間、ステータスコードを記述可能性が空のテキストフレーズ、およびCRLFで終わります。"
    },
    {
      "indent": 5,
      "text": "status-line = HTTP-version SP status-code SP reason-phrase CRLF",
      "ja": "ステータスライン= HTTPバージョンSPステータスコードSP理由フレーズCRLF"
    },
    {
      "indent": 3,
      "text": "The status-code element is a 3-digit integer code describing the result of the server's attempt to understand and satisfy the client's corresponding request. The rest of the response message is to be interpreted in light of the semantics defined for that status code. See Section 6 of [RFC7231] for information about the semantics of status codes, including the classes of status code (indicated by the first digit), the status codes defined by this specification, considerations for the definition of new status codes, and the IANA registry.",
      "ja": "ステータスコードエレメントを理解し、クライアントの対応する要求を満たすために、サーバの試みの結果を説明する3桁の整数コードです。応答メッセージの残りの部分は、そのステータスコードに対して定義された意味論に照らして解釈されるべきです。 （最初の数字で示される）ステータスコードのクラスは、この仕様で定義されたステータスコード、新しいステータスコードの定義について考察、及びIANA含むステータスコードのセマンティクスについては、[RFC7231]のセクション6を参照してくださいレジストリ。"
    },
    {
      "indent": 5,
      "text": "status-code = 3DIGIT",
      "ja": "ステータスコード= 3DIGIT"
    },
    {
      "indent": 3,
      "text": "The reason-phrase element exists for the sole purpose of providing a textual description associated with the numeric status code, mostly out of deference to earlier Internet application protocols that were more frequently used with interactive text clients. A client SHOULD ignore the reason-phrase content.",
      "ja": "理由フレーズ要素は、より頻繁に対話式テキストクライアントで使用された以前のインターネットアプリケーションプロトコルにほとんど敬意の外に、数値ステータスコードに関連付けられたテキスト記述の提供を唯一の目的のために存在しています。クライアントは、理由フレーズの内容を無視します。"
    },
    {
      "indent": 5,
      "text": "reason-phrase = *( HTAB / SP / VCHAR / obs-text )",
      "ja": "理由フレーズ= *（HTAB / SP / VCHAR / OBS-テキスト）"
    },
    {
      "indent": 0,
      "text": "3.2. Header Fields",
      "section_title": true,
      "ja": "3.2。ヘッダフィールド"
    },
    {
      "indent": 3,
      "text": "Each header field consists of a case-insensitive field name followed by a colon (\":\"), optional leading whitespace, the field value, and optional trailing whitespace.",
      "ja": "オプション先頭の空白、フィールド値、およびオプションの末尾の空白：各ヘッダフィールドは、コロンに続く大文字と小文字を区別しないフィールド名（「」）からなります。"
    },
    {
      "indent": 5,
      "text": "header-field = field-name \":\" OWS field-value OWS",
      "ja": "ヘッダフィールド=フィールド名「：」OWSフィールド値OWS"
    },
    {
      "indent": 5,
      "text": "field-name = token field-value = *( field-content / obs-fold ) field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ] field-vchar = VCHAR / obs-text",
      "ja": "フィールド名=トークンフィールド値= *（フィールド・コンテンツ/ OBS倍）フィールド内容=フィールドvchar [1 *（SP / HTAB）フィールドvchar]フィールドvchar = VCHAR / OBSテキスト"
    },
    {
      "indent": 5,
      "text": "obs-fold = CRLF 1*( SP / HTAB ) ; obsolete line folding ; see Section 3.2.4",
      "ja": "OBS倍= CRLF 1 *（SP / HTAB）。廃止されたラインの折り畳み;セクション3.2.4を参照してください"
    },
    {
      "indent": 3,
      "text": "The field-name token labels the corresponding field-value as having the semantics defined by that header field. For example, the Date header field is defined in Section 7.1.1.2 of [RFC7231] as containing the origination timestamp for the message in which it appears.",
      "ja": "フィールド名トークンは、ヘッダフィールドによって定義された意味を有するものとして対応するフィールド値をラベル。例えば、日付ヘッダフィールドは、それが表示されるメッセージの発信タイムスタンプを含むように[RFC7231]のセクション7.1.1.2で定義されています。"
    },
    {
      "indent": 0,
      "text": "3.2.1. Field Extensibility",
      "section_title": true,
      "ja": "3.2.1。フィールドの拡張"
    },
    {
      "indent": 3,
      "text": "Header fields are fully extensible: there is no limit on the introduction of new field names, each presumably defining new semantics, nor on the number of header fields used in a given message. Existing fields are defined in each part of this specification and in many other specifications outside this document set.",
      "ja": "ヘッダフィールドは、完全に拡張可能である：新しいフィールド名、各おそらく定義新しい意味論の導入に、また与えられたメッセージに使用されるヘッダフィールドの数に制限はありません。既存のフィールドは、本明細書の各部分に、この文書のセット以外の多くの他の仕様で定義されています。"
    },
    {
      "indent": 3,
      "text": "New header fields can be defined such that, when they are understood by a recipient, they might override or enhance the interpretation of previously defined header fields, define preconditions on request evaluation, or refine the meaning of responses.",
      "ja": "新しいヘッダフィールドは、それらが受信者によって理解されているとき、彼らは上書きまたは増強以前に定義されたヘッダフィールドの解釈を、要求評価の前提条件を定義する、または応答の意味を絞り込むかもしれない、というように定義することができます。"
    },
    {
      "indent": 3,
      "text": "A proxy MUST forward unrecognized header fields unless the field-name is listed in the Connection header field (Section 6.1) or the proxy is specifically configured to block, or otherwise transform, such fields. Other recipients SHOULD ignore unrecognized header fields. These requirements allow HTTP's functionality to be enhanced without requiring prior update of deployed intermediaries.",
      "ja": "フィールド名は、Connectionヘッダフィールド（6.1節）に記載されているか、プロキシが、具体的にブロックする、または他の方法で変換するように構成され、そのようなフィールドがない限りプロキシは認識されないヘッダフィールドを転送する必要があります。他の受信者には認識されないヘッダフィールドを無視する必要があります。これらの要件は、HTTPの機能が展開仲介の前に更新を必要とせずに高めることを可能にします。"
    },
    {
      "indent": 3,
      "text": "All defined header fields ought to be registered with IANA in the \"Message Headers\" registry, as described in Section 8.3 of [RFC7231].",
      "ja": "すべての定義されたヘッダフィールドは、[RFC7231]のセクション8.3に記載されているように、「メッセージヘッダ」レジストリにIANAに登録されるべきです。"
    },
    {
      "indent": 0,
      "text": "3.2.2. Field Order",
      "section_title": true,
      "ja": "3.2.2。フィールドオーダー"
    },
    {
      "indent": 3,
      "text": "The order in which header fields with differing field names are received is not significant. However, it is good practice to send header fields that contain control data first, such as Host on requests and Date on responses, so that implementations can decide when not to handle a message as early as possible. A server MUST NOT apply a request to the target resource until the entire request header section is received, since later header fields might include conditionals, authentication credentials, or deliberately misleading duplicate header fields that would impact request processing.",
      "ja": "異なるフィールド名を持つヘッダフィールドが受信される順序は重要ではありません。しかし、可能な限り早期にメッセージを処理しないとき、実装が決定できるように、そのような応答の要求や日付のホストとして、第一の制御データを含むヘッダフィールドを送信することをお勧めします。全体リクエストヘッダ部を受信するまで、後のヘッダーフィールドは、要求処理に影響を与える条件式、認証証明書、又は故意に誤解を招く重複ヘッダーフィールドを含むかもしれないので、サーバは、ターゲットリソースにリクエストを適用してはいけません。"
    },
    {
      "indent": 3,
      "text": "A sender MUST NOT generate multiple header fields with the same field name in a message unless either the entire field value for that header field is defined as a comma-separated list [i.e., #(values)] or the header field is a well-known exception (as noted below).",
      "ja": "そのヘッダフィールドのフィールド全体の値がカンマで区切られたリスト[すなわち、＃（値）]として定義されるかしない限り、送信者は、メッセージ内の同じフィールド名を持つ複数のヘッダフィールドを生成してはいけませんまたはヘッダフィールドがよくあります既知の例外（以下に記載されるように）。"
    },
    {
      "indent": 3,
      "text": "A recipient MAY combine multiple header fields with the same field name into one \"field-name: field-value\" pair, without changing the semantics of the message, by appending each subsequent field value to the combined field value in order, separated by a comma. The order in which header fields with the same field name are received is therefore significant to the interpretation of the combined field value; a proxy MUST NOT change the order of these field values when forwarding a message.",
      "ja": "によって分離され、順番に組み合わせフィールド値に後続の各フィールド値を追加することによって、メッセージの意味を変えることなく、一対：受信者は、一つの「フィールド値のフィールド名」に同じフィールド名を持つ複数のヘッダフィールドを組み合わせることができますコンマ。同じフィールド名を持つヘッダフィールドが受信される順序は、合成フィールド値の解釈することが重要です。メッセージを転送するとき、プロキシは、これらのフィールドの値の順序を変更しないでください。"
    },
    {
      "indent": 6,
      "text": "Note: In practice, the \"Set-Cookie\" header field ([RFC6265]) often appears multiple times in a response message and does not use the list syntax, violating the above requirements on multiple header fields with the same name. Since it cannot be combined into a single field-value, recipients ought to handle \"Set-Cookie\" as a special case while processing header fields. (See Appendix A.2.3 of [Kri2001] for details.)",
      "ja": "注意：実際には、「のSet-Cookie」ヘッダフィールド（[RFC6265]）は、多くの場合、応答メッセージに複数回表示され、同じ名前の複数のヘッダフィールドに上記の要件に違反し、リストの構文を使用していません。それは単一のフィールド値に結合することができないため、受信者は、「セットクッキー」を特別な場合として、ヘッダフィールドの処理中に扱うべきです。 （詳細については、[Kri2001]の付録A.2.3を参照してください。）"
    },
    {
      "indent": 0,
      "text": "3.2.3. Whitespace",
      "section_title": true,
      "ja": "3.2.3。空白"
    },
    {
      "indent": 3,
      "text": "This specification uses three rules to denote the use of linear whitespace: OWS (optional whitespace), RWS (required whitespace), and BWS (\"bad\" whitespace).",
      "ja": "OWS（オプション空白）、RWS（必須空白）、およびBWS（「悪い」空白）：この仕様は、線形空白の使用を示すために3つのルールを使用します。"
    },
    {
      "indent": 3,
      "text": "The OWS rule is used where zero or more linear whitespace octets might appear. For protocol elements where optional whitespace is preferred to improve readability, a sender SHOULD generate the optional whitespace as a single SP; otherwise, a sender SHOULD NOT generate optional whitespace except as needed to white out invalid or unwanted protocol elements during in-place message filtering.",
      "ja": "OWSルールは、ゼロ以上の線形空白のオクテットが表示される場合があります場合に使用されます。任意の空白は、読みやすさを向上させることが好ましいプロトコル要素のために、送信者は単一のSPとして任意の空白を生成する必要があります。そうでない場合は、送信者は、インプレースメッセージフィルタリング中に白い無効または不要なプロトコル要素に必要な場合を除き、オプションの空白を生成するべきではありません。"
    },
    {
      "indent": 3,
      "text": "The RWS rule is used when at least one linear whitespace octet is required to separate field tokens. A sender SHOULD generate RWS as a single SP.",
      "ja": "少なくとも一つの線形の空白オクテットは別個フィールドトークンに必要とされる場合RWSルールが使用されます。送信者は、単一のSPとしてRWSを生成する必要があります。"
    },
    {
      "indent": 3,
      "text": "The BWS rule is used where the grammar allows optional whitespace only for historical reasons. A sender MUST NOT generate BWS in messages. A recipient MUST parse for such bad whitespace and remove it before interpreting the protocol element.",
      "ja": "文法のみ歴史的な理由のために任意の空白を許す場合BWSルールが使用されます。送信者は、メッセージにBWSを生成してはなりません。受信者は、このような悪い空白のために解析し、プロトコル要素を解釈する前にそれを削除する必要があります。"
    },
    {
      "indent": 5,
      "text": "OWS = *( SP / HTAB ) ; optional whitespace RWS = 1*( SP / HTAB ) ; required whitespace BWS = OWS ; \"bad\" whitespace",
      "ja": "OWS = *（SP / HTAB）。任意の空白RWS = 1 *（SP / HTAB）。必要な空白BWS = OWS。 「悪い」空白"
    },
    {
      "indent": 0,
      "text": "3.2.4. Field Parsing",
      "section_title": true,
      "ja": "3.2.4。フィールド解析"
    },
    {
      "indent": 3,
      "text": "Messages are parsed using a generic algorithm, independent of the individual header field names. The contents within a given field value are not parsed until a later stage of message interpretation (usually after the message's entire header section has been processed). Consequently, this specification does not use ABNF rules to define each \"Field-Name: Field Value\" pair, as was done in previous editions. Instead, this specification uses ABNF rules that are named according to each registered field name, wherein the rule defines the valid grammar for that field's corresponding field values (i.e., after the field-value has been extracted from the header section by a generic field parser).",
      "ja": "メッセージは、個々のヘッダーフィールド名の独立した汎用的なアルゴリズムを使用して解析されます。所定のフィールド値内の内容は、メッセージの解釈（通常、メッセージの全体ヘッダセクションが処理された後）の後の段階まで解析されていません。以前の版で行ったように、ペア：したがって、この仕様は、各「フィールド値フィールド名」を定義するためにABNF規則を使用していません。代わりに、この仕様は、フィールドの値は、一般的なフィールドパーサによってヘッダ部から抽出された後、ルールは、すなわち（そのフィールドの対応するフィールドの値の有効な文法を画定各登録フィールド名に従って命名されているABNF規則を使用します）。"
    },
    {
      "indent": 3,
      "text": "No whitespace is allowed between the header field-name and colon. In the past, differences in the handling of such whitespace have led to security vulnerabilities in request routing and response handling. A server MUST reject any received request message that contains whitespace between a header field-name and colon with a response code of 400 (Bad Request). A proxy MUST remove any such whitespace from a response message before forwarding the message downstream.",
      "ja": "何の空白は、ヘッダフィールド名および結腸の間で許可されていません。過去においては、このような空白の扱いの違いは、要求ルーティングおよび応答処理にセキュリティの脆弱性につながっています。サーバは、400（悪いRequest）の応答コードとヘッダフィールド名とコロンの間に空白を含む任意の受信したリクエストメッセージを拒絶しなければなりません。プロキシは、下流メッセージを転送する前に応答メッセージからこのような空白を削除する必要があります。"
    },
    {
      "indent": 3,
      "text": "A field value might be preceded and/or followed by optional whitespace (OWS); a single SP preceding the field-value is preferred for consistent readability by humans. The field value does not include any leading or trailing whitespace: OWS occurring before the first non-whitespace octet of the field value or after the last non-whitespace octet of the field value ought to be excluded by parsers when extracting the field value from a header field.",
      "ja": "フィールド値が先行及び/又は任意の空白（OWS）が続くかもしれません。フィールド値の前に単一のSPは、ヒトによって一貫した可読性のために好ましいです。フィールドの値は、任意の先頭または末尾の空白を含まない：OWSは、フィールド値の最後の非空白オクテットフィールド値の最初の非空白オクテットの前または後に起こるからフィールド値を抽出する際にパーサーによって除外されるべきですヘッダフィールド。"
    },
    {
      "indent": 3,
      "text": "Historically, HTTP header field values could be extended over multiple lines by preceding each extra line with at least one space or horizontal tab (obs-fold). This specification deprecates such line folding except within the message/http media type (Section 8.3.1). A sender MUST NOT generate a message that includes line folding (i.e., that has any field-value that contains a match to the obs-fold rule) unless the message is intended for packaging within the message/http media type.",
      "ja": "歴史的には、HTTPヘッダーフィールドの値は、少なくとも1つのスペースまたは水平タブ（OBS倍）で各追加のラインを先行することによって、複数の行にわたって拡張することができます。この仕様は、メッセージ/ HTTPメディアタイプ（セクション8.3.1）内を除いて、このような行の折り畳みを非難します。送信者は、メッセージがメッセージ/ HTTPメディアタイプ内にパッケージングすることを意図されていない場合（すなわち、それは、OBS倍ルールにマッチを含む任意のフィールドの値を持つ）折りたたみ線を含むメッセージを生成してはいけません。"
    },
    {
      "indent": 3,
      "text": "A server that receives an obs-fold in a request message that is not within a message/http container MUST either reject the message by sending a 400 (Bad Request), preferably with a representation explaining that obsolete line folding is unacceptable, or replace each received obs-fold with one or more SP octets prior to interpreting the field value or forwarding the message downstream.",
      "ja": "メッセージ/ HTTPコンテナ内にない要求メッセージにOBS倍を受信したサーバは、好ましくは、廃止された行の折り畳みが受け入れられないことを説明する表現と、400（悪いRequest）を送信することによって、メッセージを拒否し、またはそれぞれを交換しなければならないのいずれかでフィールド値を解釈または下流メッセージを転送する前に、一つ以上のSPオクテットとOBS倍を受けました。"
    },
    {
      "indent": 3,
      "text": "A proxy or gateway that receives an obs-fold in a response message that is not within a message/http container MUST either discard the message and replace it with a 502 (Bad Gateway) response, preferably with a representation explaining that unacceptable line folding was received, or replace each received obs-fold with one or more SP octets prior to interpreting the field value or forwarding the message downstream.",
      "ja": "メッセージ/ HTTPコンテナ内にない応答メッセージにOBS倍を受け取るプロキシまたはゲートウェイがメッセージを破棄して、好ましくは、許容できない行の折り畳みがあったことを説明する表現と、502（不正なゲートウェイ）応答と交換しなければならないのいずれかで受信された、または各フィールドの値を解釈または下流メッセージを転送する前に、一つ以上のSPオクテットとOBS倍を受け置き換えます。"
    },
    {
      "indent": 3,
      "text": "A user agent that receives an obs-fold in a response message that is not within a message/http container MUST replace each received obs-fold with one or more SP octets prior to interpreting the field value.",
      "ja": "メッセージ/ HTTPコンテナ内にない応答メッセージにOBS倍を受信するユーザエージェントは、それぞれが前フィールド値を解釈する1つまたは複数のSPオクテットとOBS倍を受け交換する必要があります。"
    },
    {
      "indent": 3,
      "text": "Historically, HTTP has allowed field content with text in the ISO-8859-1 charset [ISO-8859-1], supporting other charsets only through use of [RFC2047] encoding. In practice, most HTTP header field values use only a subset of the US-ASCII charset [USASCII]. Newly defined header fields SHOULD limit their field values to US-ASCII octets. A recipient SHOULD treat other octets in field content (obs-text) as opaque data.",
      "ja": "歴史的に、HTTPは、[RFC2047]のエンコーディングの使用を介して他の文字セットをサポートして、ISO-8859-1文字セット[ISO-8859-1]のテキストとフィールドの内容を可能にしました。実際には、ほとんどのHTTPヘッダフィールド値は[USASCII] USASCII文字セットのサブセットのみを使用します。新しく定義されたヘッダフィールドはUS-ASCIIオクテットにそのフィールドの値を制限する必要があります。受信者は、不透明なデータとしてフィールドの内容（OBS-テキスト）内の他のオクテットを扱うべきです。"
    },
    {
      "indent": 0,
      "text": "3.2.5. Field Limits",
      "section_title": true,
      "ja": "3.2.5。フィールドの制限"
    },
    {
      "indent": 3,
      "text": "HTTP does not place a predefined limit on the length of each header field or on the length of the header section as a whole, as described in Section 2.5. Various ad hoc limitations on individual header field length are found in practice, often depending on the specific field semantics.",
      "ja": "セクション2.5で説明したようにHTTPは、各ヘッダフィールドの長さに又は全体としてのヘッダ部の長さに所定の限界を置きません。個々のヘッダフィールドの長さに様々なアドホックな制限は、多くの場合、特定のフィールドのセマンティクスに依存して、実際に見出されます。"
    },
    {
      "indent": 3,
      "text": "A server that receives a request header field, or set of fields, larger than it wishes to process MUST respond with an appropriate 4xx (Client Error) status code. Ignoring such header fields would increase the server's vulnerability to request smuggling attacks (Section 9.5).",
      "ja": "リクエストヘッダフィールドを受信したサーバ、またはフィールドのセット、それを処理することを望むよりも大きく、適切な4XX（クライアントエラー）ステータスコードで応答しなければなりません。そのようなヘッダフィールドを無視すると、密輸攻撃（9.5節）を要求するために、サーバの脆弱性を増加させます。"
    },
    {
      "indent": 3,
      "text": "A client MAY discard or truncate received header fields that are larger than the client wishes to process if the field semantics are such that the dropped value(s) can be safely ignored without changing the message framing or response semantics.",
      "ja": "クライアントは、クライアントが、フィールドのセマンティクスは、ドロップされた値（s）は、安全メッセージフレーミングまたは応答のセマンティクスを変更せずに無視することができるようなものである場合に処理することを望むよりも大きい受信したヘッダフィールドを破棄するか、切り捨てられる場合があり。"
    },
    {
      "indent": 0,
      "text": "3.2.6. Field Value Components",
      "section_title": true,
      "ja": "3.2.6。フィールド値コンポーネント"
    },
    {
      "indent": 3,
      "text": "Most HTTP header field values are defined using common syntax components (token, quoted-string, and comment) separated by whitespace or specific delimiting characters. Delimiters are chosen from the set of US-ASCII visual characters not allowed in a token (DQUOTE and \"(),/:;<=>?@[\\]{}\").",
      "ja": "ほとんどのHTTPヘッダフィールドの値が空白または特定の区切り文字で区切られた共通の構文要素（トークン、引用符で囲まれた文字列、およびコメント）を使用して定義されています。デリミタは、トークン（DQUOTEおよび \"（）/ :; <=>？@ [\\] {}\"）に許可されていないUS-ASCIIビジュアル文字のセットから選択されます。"
    },
    {
      "indent": 5,
      "text": "token = 1*tchar",
      "ja": "トークン= 1 *のTCHAR"
    },
    {
      "indent": 5,
      "text": "tchar = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\" / \"+\" / \"-\" / \".\" / \"^\" / \"_\" / \"`\" / \"|\" / \"~\" / DIGIT / ALPHA ; any VCHAR, except delimiters",
      "ja": "TCHAR = \"！\" / \"＃\" / \"$\" / \"％\" / \"＆\" / \"'\" / \"*\" / \"+\" / \" - \" / \"。\" / \"^\" / \"_\" / \"`\"/ \"|\" / \"〜\" / DIGIT / ALPHA。区切り文字以外の任意のVCHAR、"
    },
    {
      "indent": 3,
      "text": "A string of text is parsed as a single value if it is quoted using double-quote marks.",
      "ja": "それは、二重引用符を使用して引用されている場合は、テキストの文字列は、単一の値として解析されます。"
    },
    {
      "indent": 5,
      "text": "quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE qdtext = HTAB / SP /%x21 / %x23-5B / %x5D-7E / obs-text obs-text = %x80-FF",
      "ja": "引用符で囲まれた文字列= DQUOTE *（qdtext /引用対）DQUOTE qdtext = HTAB / SP /％X21 /％x23-5B /％x5D-7E / OBSテキストOBSテキスト=％のX80-FF"
    },
    {
      "indent": 3,
      "text": "Comments can be included in some HTTP header fields by surrounding the comment text with parentheses. Comments are only allowed in fields containing \"comment\" as part of their field value definition.",
      "ja": "コメントは括弧とコメントテキストを囲むことにより、いくつかのHTTPヘッダフィールドに含めることができます。コメントは自分のフィールド値定義の一部として「コメント」を含むフィールドで許可されています。"
    },
    {
      "indent": 5,
      "text": "comment = \"(\" *( ctext / quoted-pair / comment ) \")\" ctext = HTAB / SP / %x21-27 / %x2A-5B / %x5D-7E / obs-text",
      "ja": "コメント= \"（\" *（CTEXT /引用されたペア/コメント） \"）\" CTEXT = HTAB / SP /％x21-27 /％X2A-5B /％x5D-7E / OBSテキスト"
    },
    {
      "indent": 3,
      "text": "The backslash octet (\"\\\") can be used as a single-octet quoting mechanism within quoted-string and comment constructs. Recipients that process the value of a quoted-string MUST handle a quoted-pair as if it were replaced by the octet following the backslash.",
      "ja": "バックスラッシュのオクテット（「\\」）は引用符で囲まれた文字列とコメント構文内の単一オクテット引用メカニズムとして使用することができます。それはバックスラッシュ次のオクテットに置き換えられたかのように引用符で囲まれた文字列の値を処理する受信者が引用されたペアを処理する必要があります。"
    },
    {
      "indent": 5,
      "text": "quoted-pair = \"\\\" ( HTAB / SP / VCHAR / obs-text )",
      "ja": "引用されたペア= \"\\\"（HTAB / SP / VCHAR / OBS-テキスト）"
    },
    {
      "indent": 3,
      "text": "A sender SHOULD NOT generate a quoted-pair in a quoted-string except where necessary to quote DQUOTE and backslash octets occurring within that string. A sender SHOULD NOT generate a quoted-pair in a comment except where necessary to quote parentheses [\"(\" and \")\"] and backslash octets occurring within that comment.",
      "ja": "送信者は、その文字列内で発生DQUOTEとバックスラッシュオクテットを引用し、必要な場合を除き、引用符で囲まれた文字列に引用されたペアを生成するべきではありません。送信者は、括弧を引用する必要な場合を除き、コメント[「（」と「）」]で引用ペアを生成すべきではなく、バックスラッシュのオクテットは、そのコメント内で発生します。"
    },
    {
      "indent": 0,
      "text": "3.3. Message Body",
      "section_title": true,
      "ja": "3.3。メッセージ本文"
    },
    {
      "indent": 3,
      "text": "The message body (if any) of an HTTP message is used to carry the payload body of that request or response. The message body is identical to the payload body unless a transfer coding has been applied, as described in Section 3.3.1.",
      "ja": "HTTPメッセージのメッセージ本体は、（もしあれば）その要求又は応答のペイロード体を搬送するために使用されます。セクション3.3.1に記載したように、転送符号化が適用されていない限り、メッセージ本体は、ペイロード体と同一です。"
    },
    {
      "indent": 5,
      "text": "message-body = *OCTET",
      "ja": "メッセージボディ= * OCTET"
    },
    {
      "indent": 3,
      "text": "The rules for when a message body is allowed in a message differ for requests and responses.",
      "ja": "メッセージ本体がメッセージに許可されているときの規則は、要求と応答で異なります。"
    },
    {
      "indent": 3,
      "text": "The presence of a message body in a request is signaled by a Content-Length or Transfer-Encoding header field. Request message framing is independent of method semantics, even if the method does not define any use for a message body.",
      "ja": "要求のメッセージ体の存在は、コンテンツ長や転送符号化ヘッダ・フィールドによって信号伝達されます。要求メッセージフレーミングは、メソッドは、メッセージ本文の任意の使用を定義していない場合でも、メソッドのセマンティクスとは無関係です。"
    },
    {
      "indent": 3,
      "text": "The presence of a message body in a response depends on both the request method to which it is responding and the response status code (Section 3.1.2). Responses to the HEAD request method (Section 4.3.2 of [RFC7231]) never include a message body because the associated response header fields (e.g., Transfer-Encoding, Content-Length, etc.), if present, indicate only what their values would have been if the request method had been GET (Section 4.3.1 of [RFC7231]). 2xx (Successful) responses to a CONNECT request method (Section 4.3.6 of [RFC7231]) switch to tunnel mode instead of having a message body. All 1xx (Informational), 204 (No Content), and 304 (Not Modified) responses do not include a message body. All other responses do include a message body, although the body might be of zero length.",
      "ja": "応答内のメッセージボディの存在は、それが応答されるリクエストメソッドとレスポンスステータスコード（セクション3.1.2）の両方に依存します。 HEADリクエストメソッド（[RFC7231]のセクション4.3.2）への応答は、（例えば、転送エンコード、コンテンツ長、）関連する応答ヘッダフィールドので、メッセージ本体を含むことがない、存在する場合、唯一のものそれらの値を示しますリクエストメソッドがGETされていた場合であったであろう（[RFC7231]のセクション4.3.1）。 CONNECTリクエストメソッドへの2xx（成功）応答の代わりに、メッセージボディを有するトンネルモードに切り替え（[RFC7231]のセクション4.3.6）。すべての1xx（情報）、204（コンテンツなし）、および304（未修正）応答は、メッセージ本体は含まれていません。体は長さがゼロであるかもしれないが、他のすべての応答は、メッセージ本体を含ん行います。"
    },
    {
      "indent": 0,
      "text": "3.3.1. Transfer-Encoding",
      "section_title": true,
      "ja": "3.3.1。転送エンコーディング"
    },
    {
      "indent": 3,
      "text": "The Transfer-Encoding header field lists the transfer coding names corresponding to the sequence of transfer codings that have been (or will be) applied to the payload body in order to form the message body. Transfer codings are defined in Section 4.",
      "ja": "転送符号化ヘッダ・フィールドがされている（又はあろう）の転送コーディングの配列に対応する名前をコード転送は、メッセージ本体を形成するために、ペイロード本体に適用示します。転送コーディングはセクション4で定義されています。"
    },
    {
      "indent": 5,
      "text": "Transfer-Encoding = 1#transfer-coding",
      "ja": "転送エンコード= 1＃転送コーディング"
    },
    {
      "indent": 3,
      "text": "Transfer-Encoding is analogous to the Content-Transfer-Encoding field of MIME, which was designed to enable safe transport of binary data over a 7-bit transport service ([RFC2045], Section 6). However, safe transport has a different focus for an 8bit-clean transfer protocol. In HTTP's case, Transfer-Encoding is primarily intended to accurately delimit a dynamically generated payload and to distinguish payload encodings that are only applied for transport efficiency or security from those that are characteristics of the selected resource.",
      "ja": "転送エンコーディングは、7ビットのトランスポート・サービス（[RFC2045]、セクション6）を介してバイナリデータの安全な輸送を可能にするために設計されたMIMEのContent-Transfer-Encodingフィールドに類似しています。しかし、安全な輸送は、8ビット・クリーンな転送プロトコルの異なる焦点を持っています。 HTTPの場合には、転送エンコードは、主に正確に動的に生成されたペイロードを区切るためにのみ選択されたリソースの特性であるものから輸送効率やセキュリティのために適用されているペイロードエンコーディングを区別することを意図しています。"
    },
    {
      "indent": 3,
      "text": "A recipient MUST be able to parse the chunked transfer coding (Section 4.1) because it plays a crucial role in framing messages when the payload body size is not known in advance. A sender MUST NOT apply chunked more than once to a message body (i.e., chunking an already chunked message is not allowed). If any transfer coding other than chunked is applied to a request payload body, the sender MUST apply chunked as the final transfer coding to ensure that the message is properly framed. If any transfer coding other than chunked is applied to a response payload body, the sender MUST either apply chunked as the final transfer coding or terminate the message by closing the connection.",
      "ja": "それは、ペイロードボディサイズは事前に知られていないときにメッセージをフレーミングで重要な役割を果たしているため、受信者は、チャンク転送コーディング（4.1節）を解析できなければなりません。送信者（すなわち、許可されていない既にチャンクメッセージをチャンキング）メッセージ本体に複数回チャンク適用しないしなければなりません。チャンク以外の符号化の任意の転送を要求ペイロード体に適用した場合、送信者は、メッセージが適切にフレーム化されることを保証するために、最終的な転送コーディングとしてチャンク適用しなければなりません。チャンク以外の符号化の任意の転送応答ペイロード体に適用した場合、送信者は、いずれかの適用最終転送コーディングとしてチャンクまたは接続を閉じることによって、メッセージを終了しなければなりません。"
    },
    {
      "indent": 3,
      "text": "For example,",
      "ja": "例えば、"
    },
    {
      "indent": 5,
      "text": "Transfer-Encoding: gzip, chunked",
      "ja": "転送 - エンコード：gzipで、チャンク"
    },
    {
      "indent": 3,
      "text": "indicates that the payload body has been compressed using the gzip coding and then chunked using the chunked coding while forming the message body.",
      "ja": "ペイロード本体はGZIP符号化を用いて圧縮した後、メッセージ体を形成しながら、チャンク符号化を使用してチャンクされたことを示します。"
    },
    {
      "indent": 3,
      "text": "Unlike Content-Encoding (Section 3.1.2.1 of [RFC7231]), Transfer-Encoding is a property of the message, not of the representation, and any recipient along the request/response chain MAY decode the received transfer coding(s) or apply additional transfer coding(s) to the message body, assuming that corresponding changes are made to the Transfer-Encoding field-value. Additional information about the encoding parameters can be provided by other header fields not defined by this specification.",
      "ja": "コンテンツ符号化（[RFC7231]のセクション3.1.2.1）とは異なり、転送エンコードは、メッセージのではなく、表現の特性であり、要求/応答チェーンに沿った任意の受信者は、受信した転送符号化（S）を復号化又は適用することができます対応する変更が転送-Encodingフィールド値に対して行われると仮定し、メッセージ本文に追加の転送符号化（S）。符号化パラメータに関する追加情報は、本明細書で定義されていない他のヘッダフィールドによって提供することができます。"
    },
    {
      "indent": 3,
      "text": "Transfer-Encoding MAY be sent in a response to a HEAD request or in a 304 (Not Modified) response (Section 4.1 of [RFC7232]) to a GET request, neither of which includes a message body, to indicate that the origin server would have applied a transfer coding to the message body if the request had been an unconditional GET. This indication is not required, however, because any recipient on the response chain (including the origin server) can remove transfer codings when they are not needed.",
      "ja": "転送エンコーディングは、オリジンサーバがあろうことを示すために、メッセージ本体を含むいずれものGET要求にHEAD要求に応答して、または304（変更されていません）応答（[RFC7232]のセクション4.1）で送られてもよいです要求は無条件GETしていた場合は、メッセージ本体に転送コーディングを適用しています。それらが必要でないとき（オリジンサーバを含む）応答チェーン上の任意の受信者が転送コーディングを削除することができますので、この表示は、しかし、必要とされていません。"
    },
    {
      "indent": 3,
      "text": "A server MUST NOT send a Transfer-Encoding header field in any response with a status code of 1xx (Informational) or 204 (No Content). A server MUST NOT send a Transfer-Encoding header field in any 2xx (Successful) response to a CONNECT request (Section 4.3.6 of [RFC7231]).",
      "ja": "サーバは、1XX（通知）または204（いいえコンテンツ）のステータスコードを有する任意の応答で転送エンコードヘッダフィールドを送ってはいけません。サーバは、接続要求（セクション4.3.6 [RFC7231]）に任意の2xx（成功）応答して転送エンコードヘッダフィールドを送ってはいけません。"
    },
    {
      "indent": 3,
      "text": "Transfer-Encoding was added in HTTP/1.1. It is generally assumed that implementations advertising only HTTP/1.0 support will not understand how to process a transfer-encoded payload. A client MUST NOT send a request containing Transfer-Encoding unless it knows the server will handle HTTP/1.1 (or later) requests; such knowledge might be in the form of specific user configuration or by remembering the version of a prior received response. A server MUST NOT send a response containing Transfer-Encoding unless the corresponding request indicates HTTP/1.1 (or later).",
      "ja": "転送エンコーディングは、HTTP / 1.1で追加されました。一般的な実装の広告のみHTTP / 1.0のサポートは、転送エンコードされたペイロードを処理する方法を理解できないだろうと想定されます。クライアントは、サーバがHTTP / 1.1（またはそれ以降）の要求を処理します知っている場合を除き、転送エンコーディングを含む要求を送ってはいけません。そのような知識は、特定のユーザー構成の形で、または前に受信したレスポンスのバージョンを記憶することによってかもしれません。対応する要求は、HTTP / 1.1（またはそれ以降）を示していない限り、サーバは、転送エンコードを含む応答を送信してはいけません。"
    },
    {
      "indent": 3,
      "text": "A server that receives a request message with a transfer coding it does not understand SHOULD respond with 501 (Not Implemented).",
      "ja": "それは理解していないコーディング転送を要求メッセージを受信したサーバーは、（実装されていません）501で応答する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.3.2. Content-Length",
      "section_title": true,
      "ja": "3.3.2。コンテンツの長さ"
    },
    {
      "indent": 3,
      "text": "When a message does not have a Transfer-Encoding header field, a Content-Length header field can provide the anticipated size, as a decimal number of octets, for a potential payload body. For messages that do include a payload body, the Content-Length field-value provides the framing information necessary for determining where the body (and message) ends. For messages that do not include a payload body, the Content-Length indicates the size of the selected representation (Section 3 of [RFC7231]).",
      "ja": "メッセージが転送エンコーディングヘッダフィールドを持っていない場合、Content-Lengthヘッダフィールドは、潜在的なペイロード本体ため、オクテットの10進数として、予想される大きさを提供することができます。ペイロード本体を含む行うメッセージに対して、コンテンツ長フィールド値は、本体（およびメッセージ）が終了する場所を決定するために必要なフレーミング情報を提供します。ペイロード体が含まれていないメッセージに対して、コンテンツの長さは、選択された表現（[RFC7231]のセクション3）の大きさを示しています。"
    },
    {
      "indent": 5,
      "text": "Content-Length = 1*DIGIT",
      "ja": "Content-Length = 1 * DIGIT"
    },
    {
      "indent": 3,
      "text": "An example is",
      "ja": "例があります"
    },
    {
      "indent": 5,
      "text": "Content-Length: 3495",
      "ja": "コンテンツの長さ：3495"
    },
    {
      "indent": 3,
      "text": "A sender MUST NOT send a Content-Length header field in any message that contains a Transfer-Encoding header field.",
      "ja": "送信者は転送-Encodingヘッダフィールドを含むすべてのメッセージにContent-Lengthヘッダフィールドを送ってはいけません。"
    },
    {
      "indent": 3,
      "text": "A user agent SHOULD send a Content-Length in a request message when no Transfer-Encoding is sent and the request method defines a meaning for an enclosed payload body. For example, a Content-Length header field is normally sent in a POST request even when the value is 0 (indicating an empty payload body). A user agent SHOULD NOT send a Content-Length header field when the request message does not contain a payload body and the method semantics do not anticipate such a body.",
      "ja": "いかなる転送符号化が送信されず、要求メソッドが封入ペイロード体のための意味を定義したとき、ユーザーエージェントは、要求メッセージ内のContent-Lengthを送信すべきです。例えば、Content-Lengthヘッダフィールドは、通常、（空のペイロード体を示す）の値が0であってもPOSTリクエストで送信されます。要求メッセージは、ペイロード体が含まれていないとメソッドのセマンティクスは、このような身体を予想していないときに、ユーザエージェントは、Content-Lengthヘッダフィールドを送るべきではありません。"
    },
    {
      "indent": 3,
      "text": "A server MAY send a Content-Length header field in a response to a HEAD request (Section 4.3.2 of [RFC7231]); a server MUST NOT send Content-Length in such a response unless its field-value equals the decimal number of octets that would have been sent in the payload body of a response if the same request had used the GET method.",
      "ja": "サーバは、HEAD要求（[RFC7231]のセクション4.3.2）に応答して、Content-Lengthヘッダフィールドを送ることができます。そのフィールド値が同じ要求がGETメソッドを使用していた場合は、応答のペイロードボディに送られていたであろうオクテットの十進数に等しい場合を除き、サーバは、応答のContent-Lengthを送ってはいけません。"
    },
    {
      "indent": 3,
      "text": "A server MAY send a Content-Length header field in a 304 (Not Modified) response to a conditional GET request (Section 4.1 of [RFC7232]); a server MUST NOT send Content-Length in such a response",
      "ja": "サーバは、条件付きのGET要求（[RFC7232]のセクション4.1）に304（変更されていません）応答にContent-Lengthヘッダフィールドを送ることができます。サーバーは、このような応答のContent-Lengthを送ってはいけません"
    },
    {
      "indent": 3,
      "text": "unless its field-value equals the decimal number of octets that would have been sent in the payload body of a 200 (OK) response to the same request.",
      "ja": "そのフィールド値が同じリクエストに対して200（OK）応答のペイロードボディに送られていたであろうオクテットの十進数に等しい場合を除きます。"
    },
    {
      "indent": 3,
      "text": "A server MUST NOT send a Content-Length header field in any response with a status code of 1xx (Informational) or 204 (No Content). A server MUST NOT send a Content-Length header field in any 2xx (Successful) response to a CONNECT request (Section 4.3.6 of [RFC7231]).",
      "ja": "サーバは、1XX（通知）または204（いいえコンテンツ）のステータスコードを有する任意の応答にContent-Lengthヘッダフィールドを送ってはいけません。サーバは、接続要求（セクション4.3.6 [RFC7231]）に任意の2xx（成功）応答にContent-Lengthヘッダフィールドを送ってはいけません。"
    },
    {
      "indent": 3,
      "text": "Aside from the cases defined above, in the absence of Transfer-Encoding, an origin server SHOULD send a Content-Length header field when the payload body size is known prior to sending the complete header section. This will allow downstream recipients to measure transfer progress, know when a received message is complete, and potentially reuse the connection for additional requests.",
      "ja": "ペイロードの本体サイズは、完全なヘッダ部を送信する前にわかっている場合はさておき転送エンコードの非存在下で、上記で定義されたケースから、オリジンサーバは、Content-Lengthヘッダフィールドを送るべきです。これは、下流の受信者は、転送の進行状況を測定し、受信したメッセージが完了したときに知っている、そして潜在的に追加の要求のための接続を再利用できるようになります。"
    },
    {
      "indent": 3,
      "text": "Any Content-Length field value greater than or equal to zero is valid. Since there is no predefined limit to the length of a payload, a recipient MUST anticipate potentially large decimal numerals and prevent parsing errors due to integer conversion overflows (Section 9.3).",
      "ja": "0以上の任意のContent-Lengthフィールドの値が有効です。ペイロードの長さに事前に定義された制限がないため、受信者は、潜在的に大きな進数字を予測し、変換オーバフロー（セクション9.3）を整数に起因する解析エラーを防止しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If a message is received that has multiple Content-Length header fields with field-values consisting of the same decimal value, or a single Content-Length header field with a field value containing a list of identical decimal values (e.g., \"Content-Length: 42, 42\"), indicating that duplicate Content-Length header fields have been generated or combined by an upstream message processor, then the recipient MUST either reject the message as invalid or replace the duplicated field-values with a single valid Content-Length field containing that decimal value prior to determining the message body length or forwarding the message.",
      "ja": "メッセージが受信された場合には、同一の小数点値のリストを含むフィールドの値と同じ小数点値、または単一Content-Lengthヘッダフィールドからなるフィールド値（例えば、「コンテンツ長を持つ複数のContent-Lengthヘッダフィールドを有しています：42、42\" ）、重複Content-Lengthヘッダフィールドは、上流メッセージ処理によって生成された、または合成されていることを示し、次いで、受信者は、無効としてメッセージを拒絶するか、単一の有効なコンテンツ長と重複フィールド値を置き換える必要がありいずれか前のメッセージボディの長さを決定する、またはメッセージを転送するために、その小数値を含むフィールド。"
    },
    {
      "indent": 6,
      "text": "Note: HTTP's use of Content-Length for message framing differs significantly from the same field's use in MIME, where it is an optional field used only within the \"message/external-body\" media-type.",
      "ja": "注意：メッセージフレーミングのコンテンツ長のHTTPの使用は、それが唯一の「message / external-body」というメディアタイプ内で使用されるオプションのフィールドであるMIME、内の同じフィールドの使用とは大きく異なります。"
    },
    {
      "indent": 0,
      "text": "3.3.3. Message Body Length",
      "section_title": true,
      "ja": "3.3.3。メッセージ本文の長さ"
    },
    {
      "indent": 3,
      "text": "The length of a message body is determined by one of the following (in order of precedence):",
      "ja": "メッセージ本体の長さは、（優先順に）次のいずれかによって決定されます。"
    },
    {
      "indent": 3,
      "text": "1. Any response to a HEAD request and any response with a 1xx (Informational), 204 (No Content), or 304 (Not Modified) status code is always terminated by the first empty line after the header fields, regardless of the header fields present in the message, and thus cannot contain a message body.",
      "ja": "1.任意のHEAD要求と1XX（通知）を有する任意の応答に応じて、204（いいえコンテンツ）、または304（変更されていません）ステータスコードは関係なく、常にヘッダフィールドの、ヘッダフィールドの後の最初の空行で終了しますメッセージ内に存在し、したがって、メッセージボディを含むことができません。"
    },
    {
      "indent": 3,
      "text": "2. Any 2xx (Successful) response to a CONNECT request implies that the connection will become a tunnel immediately after the empty line that concludes the header fields. A client MUST ignore any Content-Length or Transfer-Encoding header fields received in such a message.",
      "ja": "2. CONNECT要求に任意の2xx（成功）応答は、接続がヘッダフィールドを終了する空行の直後にトンネルになるであろうことを意味します。クライアントは、任意のコンテンツ長を無視しなければならないか、転送符号化ヘッダフィールドは、メッセージで受信しました。"
    },
    {
      "indent": 3,
      "text": "3. If a Transfer-Encoding header field is present and the chunked transfer coding (Section 4.1) is the final encoding, the message body length is determined by reading and decoding the chunked data until the transfer coding indicates the data is complete.",
      "ja": "3.転送符号化ヘッダ・フィールドが存在し、チャンク転送符号化（セクション4.1）、最終的な符号化である場合、メッセージ本文の長さが読み取り、転送符号化データが完全であることを示すまで、チャンクデータを復号化することによって決定されます。"
    },
    {
      "indent": 7,
      "text": "If a Transfer-Encoding header field is present in a response and\nthe chunked transfer coding is not the final encoding, the\nmessage body length is determined by reading the connection until\nit is closed by the server.  If a Transfer-Encoding header field\nis present in a request and the chunked transfer coding is not\nthe final encoding, the message body length cannot be determined\nreliably; the server MUST respond with the 400 (Bad Request)\nstatus code and then close the connection.",
      "raw": true
    },
    {
      "indent": 7,
      "text": "If a message is received with both a Transfer-Encoding and a Content-Length header field, the Transfer-Encoding overrides the Content-Length. Such a message might indicate an attempt to perform request smuggling (Section 9.5) or response splitting (Section 9.4) and ought to be handled as an error. A sender MUST remove the received Content-Length field prior to forwarding such a message downstream.",
      "ja": "メッセージが転送エンコードおよびContent-Lengthヘッダフィールドの両方で受信された場合、転送エンコードは、コンテンツ長を上書き。そのようなメッセージは、要求密輸（セクション9.5）または応答分割（セクション9.4）を実行する試みを示し、エラーとして処理されるべきかもしれません。送信側は下流ようなメッセージを転送する前に受信したコンテンツ長フィールドを削除する必要があります。"
    },
    {
      "indent": 3,
      "text": "4. If a message is received without Transfer-Encoding and with either multiple Content-Length header fields having differing field-values or a single Content-Length header field having an invalid value, then the message framing is invalid and the recipient MUST treat it as an unrecoverable error. If this is a request message, the server MUST respond with a 400 (Bad Request) status code and then close the connection. If this is a response message received by a proxy, the proxy MUST close the connection to the server, discard the received response, and send a 502 (Bad",
      "ja": "4.メッセージが転送エンコードすることなく、かつ異なるフィールド値を有する複数のContent-Lengthヘッダフィールドまたは無効な値を有する単一のContent-Lengthヘッダフィールドのいずれかで受信される場合、メッセージフレーミングが無効であると受信者がそれを扱わなければなりません回復不能なエラーとして。これは、要求メッセージである場合、サーバは400（悪いRequest）ステータスコードで応答し、接続を閉じる必要があります。このプロキシによって受信された応答メッセージである場合、プロキシは、サーバへの接続を閉じ、受信した応答を破棄し、そして502（不良を送らなければなりません"
    },
    {
      "indent": 7,
      "text": "Gateway) response to the client.  If this is a response message\nreceived by a user agent, the user agent MUST close the\nconnection to the server and discard the received response.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "5. If a valid Content-Length header field is present without Transfer-Encoding, its decimal value defines the expected message body length in octets. If the sender closes the connection or the recipient times out before the indicated number of octets are received, the recipient MUST consider the message to be incomplete and close the connection.",
      "ja": "5.有効なContent-Lengthヘッダフィールドは、転送エンコードせずに存在する場合、その小数点値は、オクテットで予想メッセージボディ長さを規定します。送信者がオクテットの指示された数が受信される前に出て、接続または受信者の時間を閉じた場合、受信者はメッセージが不完全であることを考えると、接続を閉じる必要があります。"
    },
    {
      "indent": 3,
      "text": "6. If this is a request message and none of the above are true, then the message body length is zero (no message body is present).",
      "ja": "6.この要求メッセージであり、上記のいずれも真でない場合は、メッセージ本体の長さは（メッセージ・ボディが存在しない）はゼロです。"
    },
    {
      "indent": 3,
      "text": "7. Otherwise, this is a response message without a declared message body length, so the message body length is determined by the number of octets received prior to the server closing the connection.",
      "ja": "7.それ以外の場合、これは宣言メッセージボディ長なしの応答メッセージであるので、メッセージ本体の長さは前の接続を閉じるサーバに受信されたオクテットの数によって決定されます。"
    },
    {
      "indent": 3,
      "text": "Since there is no way to distinguish a successfully completed, close-delimited message from a partially received message interrupted by network failure, a server SHOULD generate encoding or length-delimited messages whenever possible. The close-delimiting feature exists primarily for backwards compatibility with HTTP/1.0.",
      "ja": "ネットワーク故障によって中断部分的に受信されたメッセージから正常に完了し、クローズ区切りメッセージを区別する方法がないので、可能な限り、サーバは、エンコードまたは長さで区切られたメッセージを生成する必要があります。クローズ区切り機能は、HTTP / 1.0との後方互換性のために主に存在しています。"
    },
    {
      "indent": 3,
      "text": "A server MAY reject a request that contains a message body but not a Content-Length by responding with 411 (Length Required).",
      "ja": "サーバは411（長さ必須）で応答することにより、メッセージ本文ではなく、コンテンツの長さが含まれている要求を拒否するかもしれません。"
    },
    {
      "indent": 3,
      "text": "Unless a transfer coding other than chunked has been applied, a client that sends a request containing a message body SHOULD use a valid Content-Length header field if the message body length is known in advance, rather than the chunked transfer coding, since some existing services respond to chunked with a 411 (Length Required) status code even though they understand the chunked transfer coding. This is typically because such services are implemented via a gateway that requires a content-length in advance of being called and the server is unable or unwilling to buffer the entire request before processing.",
      "ja": "チャンク以外のコード転送が適用されている場合を除き、いくつかは、既存のため、メッセージ本文の長さは、むしろ、チャンク転送コーディングよりも、事前に分かっている場合は、メッセージ本体を含む要求を送信するクライアントは、有効なContent-Lengthヘッダフィールドを使用すべきですサービスは、彼らがチャンク転送コーディングを理解していても411（長さ必須）ステータスコードをチャンクに応答します。そのようなサービスが呼び出されるに先立ってコンテンツ長を必要とし、サーバーが処理する前に全体の要求をバッファリングすることができない、または不本意であるゲートウェイを介して実装されているので、これは、典型的です。"
    },
    {
      "indent": 3,
      "text": "A user agent that sends a request containing a message body MUST send a valid Content-Length header field if it does not know the server will handle HTTP/1.1 (or later) requests; such knowledge can be in the form of specific user configuration or by remembering the version of a prior received response.",
      "ja": "それは、サーバがHTTP / 1.1（またはそれ以降）リクエストを処理します知らない場合はメッセージ本体を含むリクエストを送信するユーザーエージェントは、有効なContent-Lengthヘッダフィールドを送らなければなりません。そのような知識は、特定のユーザー構成の形で、または前に受信したレスポンスのバージョンを覚えることであることができます。"
    },
    {
      "indent": 3,
      "text": "If the final response to the last request on a connection has been completely received and there remains additional data to read, a user agent MAY discard the remaining data or attempt to determine if that data belongs as part of the prior response body, which might be the case if the prior message's Content-Length value is incorrect. A client MUST NOT process, cache, or forward such extra data as a separate response, since such behavior would be vulnerable to cache poisoning.",
      "ja": "接続上の最後の要求に対する最終応答が完全に受信されたと読み取るために追加のデータが残っている場合、ユーザエージェントは、残りのデータを破棄するか、データが前レスポンスボディの一部として属しているかどうかを決定しようとすると、であるかもしれないMAY前のメッセージのContent-Length値が正しくない場合場合。クライアントは、キャッシュを処理し、またはそのような行動は、キャッシュポイズニングに対して脆弱になることから、個別の応答として、そのような余分なデータを転送してはなりません。"
    },
    {
      "indent": 0,
      "text": "3.4. Handling Incomplete Messages",
      "section_title": true,
      "ja": "3.4。不完全なメッセージの処理"
    },
    {
      "indent": 3,
      "text": "A server that receives an incomplete request message, usually due to a canceled request or a triggered timeout exception, MAY send an error response prior to closing the connection.",
      "ja": "通常によるキャンセル要求またはトリガタイムアウト例外に、不完全な要求メッセージを受信したサーバは、接続を閉じる前にエラー応答を送信することができます。"
    },
    {
      "indent": 3,
      "text": "A client that receives an incomplete response message, which can occur when a connection is closed prematurely or when decoding a supposedly chunked transfer coding fails, MUST record the message as incomplete. Cache requirements for incomplete responses are defined in Section 3 of [RFC7234].",
      "ja": "接続が早期に閉鎖またはデコード時おそらくチャンク転送符号化が失敗したときに発生する不完全な応答メッセージを受信するクライアントは、不完全なメッセージを記録しなければなりません。不完全な応答のためのキャッシュの要件は[RFC7234]のセクション3で定義されています。"
    },
    {
      "indent": 3,
      "text": "If a response terminates in the middle of the header section (before the empty line is received) and the status code might rely on header fields to convey the full meaning of the response, then the client cannot assume that meaning has been conveyed; the client might need to repeat the request in order to determine what action to take next.",
      "ja": "応答は、応答の完全な意味を伝えるためにヘッダフィールドに依存している可能性があるヘッダ部（空行が受信される前に）、ステータスコードの途中で終了した場合、クライアントは意味が搬送されたと仮定することはできません。クライアントは、次の取るべきアクションを決定するために要求を繰り返す必要があります。"
    },
    {
      "indent": 3,
      "text": "A message body that uses the chunked transfer coding is incomplete if the zero-sized chunk that terminates the encoding has not been received. A message that uses a valid Content-Length is incomplete if the size of the message body received (in octets) is less than the value given by Content-Length. A response that has neither chunked transfer coding nor Content-Length is terminated by closure of the connection and, thus, is considered complete regardless of the number of message body octets received, provided that the header section was received intact.",
      "ja": "符号化を終了ゼロサイズのチャンクが受信されていない場合にチャンク転送符号化を使用してメッセージ本体は不完全です。メッセージボディのサイズは、コンテンツの長さによって与えられた値未満である（オクテットで）受信された場合に有効なContent-Lengthを使用してメッセージが不完全です。チャンク転送符号化やコンテンツの長さもない応答は、接続の閉鎖によって終了され、したがって、ヘッダ部は無傷の受信されたことを条件にかかわらず、本体オクテットが受信されたメッセージの数を完了したと見なされます。"
    },
    {
      "indent": 0,
      "text": "3.5. Message Parsing Robustness",
      "section_title": true,
      "ja": "3.5。メッセージ解析堅牢性"
    },
    {
      "indent": 3,
      "text": "Older HTTP/1.0 user agent implementations might send an extra CRLF after a POST request as a workaround for some early server applications that failed to read message body content that was not terminated by a line-ending. An HTTP/1.1 user agent MUST NOT preface or follow a request with an extra CRLF. If terminating the request message body with a line-ending is desired, then the user agent MUST count the terminating CRLF octets as part of the message body length.",
      "ja": "古いHTTP / 1.0ユーザエージェントの実装は、行末で終了していなかったメッセージ本文の内容を読み取ることができなかったいくつかの初期のサーバーアプリケーションのための回避策として、POSTリクエストの後に余分なCRLFを送信することがあります。 HTTP / 1.1ユーザエージェントは、序文や余分なCRLFとの要求に従ってはなりません。行終了して要求メッセージ本体を終了することが所望される場合、ユーザエージェントは、メッセージ本体の長さの一部として、終端CRLFオクテットをカウントしなければなりません。"
    },
    {
      "indent": 3,
      "text": "In the interest of robustness, a server that is expecting to receive and parse a request-line SHOULD ignore at least one empty line (CRLF) received prior to the request-line.",
      "ja": "ロバスト性の利益のために、リクエスト・ラインを受信して​​解析することを期待されているサーバ（CRLF）は、前の要求ラインに受信された少なくとも1つの空の行を無視すべきです。"
    },
    {
      "indent": 3,
      "text": "Although the line terminator for the start-line and header fields is the sequence CRLF, a recipient MAY recognize a single LF as a line terminator and ignore any preceding CR.",
      "ja": "スタートラインとヘッダフィールドのラインターミネータシーケンスCRLFであるが、受信者は、ラインターミネータのような単一のLFを認識し、任意の先行CRを無視してもよいです。"
    },
    {
      "indent": 3,
      "text": "Although the request-line and status-line grammar rules require that each of the component elements be separated by a single SP octet, recipients MAY instead parse on whitespace-delimited word boundaries and, aside from the CRLF terminator, treat any form of whitespace as the SP separator while ignoring preceding or trailing whitespace; such whitespace includes one or more of the following octets: SP, HTAB, VT (%x0B), FF (%x0C), or bare CR. However, lenient parsing can result in security vulnerabilities if there are multiple recipients of the message and each has its own unique interpretation of robustness (see Section 9.5).",
      "ja": "リクエストラインとステータスラインの文法規則は構成要素の各々が単一のSPオクテットによって分離されることを必要とするが、受信者が代わりとして、空白の任意の形態を治療するため、脇CRLFターミネーターから、空白で区切られたワード境界に解析してもよく、 SP分離先行または末尾の空白を無視して、 SP、HTAB、VT（％のX0B）、FF（％のx0C）、または裸CR：そのような空白は、次のオクテットの一つ以上を含みます。そこにメッセージの複数の受信者であり、それぞれが堅牢性の独自の解釈を持っている場合は、寛大な解析がセキュリティの脆弱性につながることができます（9.5節を参照してください）。"
    },
    {
      "indent": 3,
      "text": "When a server listening only for HTTP request messages, or processing what appears from the start-line to be an HTTP request message, receives a sequence of octets that does not match the HTTP-message grammar aside from the robustness exceptions listed above, the server SHOULD respond with a 400 (Bad Request) response.",
      "ja": "サーバーが唯一のHTTPリクエストメッセージをリッスン、あるいはHTTPリクエストメッセージであることをスタートラインから表示される内容を処理する場合、上記の堅牢性の例外は、サーバとは別にHTTPメッセージの文法と一致していないオクテットのシーケンスを受信400（不正なリクエスト）レスポンスで応答する必要があります。"
    },
    {
      "indent": 0,
      "text": "4. Transfer Codings",
      "section_title": true,
      "ja": "4.転送コーディング"
    },
    {
      "indent": 3,
      "text": "Transfer coding names are used to indicate an encoding transformation that has been, can be, or might need to be applied to a payload body in order to ensure \"safe transport\" through the network. This differs from a content coding in that the transfer coding is a property of the message rather than a property of the representation that is being transferred.",
      "ja": "転送符号化名があった符号化変換を示すために使用される、とすることができる、またはネットワークを介して「安全輸送」を確保するために、ペイロード本体に適用する必要があるかもしれません。これは転送コーディングがメッセージのプロパティではなく、転送されている表現の性質であることを符号化コンテンツとは異なります。"
    },
    {
      "indent": 5,
      "text": "transfer-coding = \"chunked\" ; Section 4.1 / \"compress\" ; Section 4.2.1 / \"deflate\" ; Section 4.2.2 / \"gzip\" ; Section 4.2.3 / transfer-extension transfer-extension = token *( OWS \";\" OWS transfer-parameter )",
      "ja": "転送コーディングは=「チャンク」。 4.1節/「圧縮」。 4.2.1 /「収縮」。 4.2.2 / \"GZIP\"。セクション4.2.3 /転送伸長転送伸長=トークン*（OWS「;」OWS転送パラメータ）"
    },
    {
      "indent": 3,
      "text": "Parameters are in the form of a name or name=value pair.",
      "ja": "パラメータは、名前または名前=値のペアの形式です。"
    },
    {
      "indent": 5,
      "text": "transfer-parameter = token BWS \"=\" BWS ( token / quoted-string )",
      "ja": "転送パラメータ=トークンBWS「=」BWS（トークン/引用符で囲まれた文字列）"
    },
    {
      "indent": 3,
      "text": "All transfer-coding names are case-insensitive and ought to be registered within the HTTP Transfer Coding registry, as defined in Section 8.4. They are used in the TE (Section 4.3) and Transfer-Encoding (Section 3.3.1) header fields.",
      "ja": "すべての転送コーディング名は大文字と小文字を区別しないと、セクション8.4で定義されているように、HTTP転送コーディングレジストリに登録されるべきです。それらは、TE（セクション4.3）と転送エンコード（セクション3.3.1）ヘッダフィールドで使用されています。"
    },
    {
      "indent": 0,
      "text": "4.1. Chunked Transfer Coding",
      "section_title": true,
      "ja": "4.1。チャンク転送コーディング"
    },
    {
      "indent": 3,
      "text": "The chunked transfer coding wraps the payload body in order to transfer it as a series of chunks, each with its own size indicator, followed by an OPTIONAL trailer containing header fields. Chunked enables content streams of unknown size to be transferred as a sequence of length-delimited buffers, which enables the sender to retain connection persistence and the recipient to know when it has received the entire message.",
      "ja": "チャンク転送符号化がヘッダーフィールドを含むオプショントレーラが続くチャンクのシリーズ、独自のサイズインジケータと各、としてそれを転送するために、ペイロード本体をラップします。チャンクは、未知のサイズのコンテンツストリームが接続の永続性と、それが全体のメッセージを受信したときに知っている受信者を保持する送信者を可能にする長さで区切られたバッファのシーケンスとして転送されることを可能にします。"
    },
    {
      "indent": 5,
      "text": "chunked-body = *chunk last-chunk trailer-part CRLF",
      "ja": "チャンク・ボディ= *チャンクの最後のチャンクのトレーラー部分CRLF"
    },
    {
      "indent": 5,
      "text": "chunk = chunk-size [ chunk-ext ] CRLF chunk-data CRLF chunk-size = 1*HEXDIG last-chunk = 1*(\"0\") [ chunk-ext ] CRLF",
      "ja": "チャンク=チャンクサイズ[チャンク-EXT] CRLFチャンクデータCRLFチャンクサイズ= 1 * HEXDIG最後のチャンク= 1 *（ \"0\"）[チャンク-EXT] CRLF"
    },
    {
      "indent": 5,
      "text": "chunk-data = 1*OCTET ; a sequence of chunk-size octets",
      "ja": "チャンクデータ= 1 * OCTET。チャンクサイズのオクテットのシーケンス"
    },
    {
      "indent": 3,
      "text": "The chunk-size field is a string of hex digits indicating the size of the chunk-data in octets. The chunked transfer coding is complete when a chunk with a chunk-size of zero is received, possibly followed by a trailer, and finally terminated by an empty line.",
      "ja": "チャンクサイズのフィールドは、オクテットでチャンクデータのサイズを示す進数字の列です。ゼロのチャンクサイズのチャンクは恐らくトレーラー続いて、受信し、そして最後に空行で終了した場合にチャンク転送符号化が完了する。"
    },
    {
      "indent": 3,
      "text": "A recipient MUST be able to parse and decode the chunked transfer coding.",
      "ja": "受信者は、チャンク転送符号化を解析して復号化できなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.1.1. Chunk Extensions",
      "section_title": true,
      "ja": "4.1.1。チャンクの拡張機能"
    },
    {
      "indent": 3,
      "text": "The chunked encoding allows each chunk to include zero or more chunk extensions, immediately following the chunk-size, for the sake of supplying per-chunk metadata (such as a signature or hash), mid-message control information, or randomization of message body size.",
      "ja": "チャンクエンコーディングは、（署名またはハッシュなど）ごとのチャンクメタデータ、中間メッセージ制御情報、またはメッセージボディのランダム化を供給するために、直ちにチャンクサイズ以下、各チャンクはゼロまたはそれ以上のチャンクの拡張機能を含めることができサイズ。"
    },
    {
      "indent": 5,
      "text": "chunk-ext = *( \";\" chunk-ext-name [ \"=\" chunk-ext-val ] )",
      "ja": "チャンク-EXT = *（ \";\" チャンク-EXT-名[ \"=\" チャンク-EXT-VAL]）"
    },
    {
      "indent": 5,
      "text": "chunk-ext-name = token chunk-ext-val = token / quoted-string",
      "ja": "チャンク-EXT-名=トークンチャンク-EXT-VAL =トークン/引用符で囲まれた文字列"
    },
    {
      "indent": 3,
      "text": "The chunked encoding is specific to each connection and is likely to be removed or recoded by each recipient (including intermediaries) before any higher-level application would have a chance to inspect the extensions. Hence, use of chunk extensions is generally limited to specialized HTTP services such as \"long polling\" (where client and server can have shared expectations regarding the use of chunk extensions) or for padding within an end-to-end secured connection.",
      "ja": "チャンク符号化は、各接続に固有であり、任意のより高いレベルのアプリケーション拡張機能を検査する機会を有することになる前に（仲介を含む）各受信者によって削除または再符号化される可能性があります。したがって、チャンクの拡張機能の使用は、一般的に、（クライアントとサーバは、チャンクの拡張機能の使用に関する期待を共有していることができます）、「ロングポーリング」として、またはエンドツーエンドの安全な接続内のパディングのための専門的なHTTPサービスに限定されています。"
    },
    {
      "indent": 3,
      "text": "A recipient MUST ignore unrecognized chunk extensions. A server ought to limit the total length of chunk extensions received in a request to an amount reasonable for the services provided, in the same way that it applies length limitations and timeouts for other parts of a message, and generate an appropriate 4xx (Client Error) response if that amount is exceeded.",
      "ja": "受信者は認識できないチャンクの拡張子を無視しなければなりません。サーバは、それが長さの制限、メッセージの他の部分のためのタイムアウトを適用するのと同じ方法で、提供されるサービスのための合理的な量への要求で受信したチャンクの拡張の合計長さを制限し、適切な4XXを生成するはずである（クライアントエラーその量を超えた場合）、応答。"
    },
    {
      "indent": 0,
      "text": "4.1.2. Chunked Trailer Part",
      "section_title": true,
      "ja": "4.1.2。チャンクトレイラ部"
    },
    {
      "indent": 3,
      "text": "A trailer allows the sender to include additional fields at the end of a chunked message in order to supply metadata that might be dynamically generated while the message body is sent, such as a message integrity check, digital signature, or post-processing status. The trailer fields are identical to header fields, except they are sent in a chunked trailer instead of the message's header section.",
      "ja": "トレーラは、送信者がメッセージ本文を、メッセージ整合性チェック、デジタル署名、または後処理状態として、送信されている間、動的に生成されるかもしれないメタデータを供給するために、チャンクメッセージの最後に追加フィールドを含めることができます。それらは代わりに、メッセージのヘッダ部のチャンクトレーラーで送信されることを除いトレーラフィールドは、フィールドヘッダと同一です。"
    },
    {
      "indent": 5,
      "text": "trailer-part = *( header-field CRLF )",
      "ja": "トレーラ部= *（ヘッダフィールドCRLF）"
    },
    {
      "indent": 3,
      "text": "A sender MUST NOT generate a trailer that contains a field necessary for message framing (e.g., Transfer-Encoding and Content-Length), routing (e.g., Host), request modifiers (e.g., controls and conditionals in Section 5 of [RFC7231]), authentication (e.g., see [RFC7235] and [RFC6265]), response control data (e.g., see Section 7.1 of [RFC7231]), or determining how to process the payload (e.g., Content-Encoding, Content-Type, Content-Range, and Trailer).",
      "ja": "送信者はメッセージをフレーミング（例えば、転送エンコードおよびコンテンツ長）、ルーティング（例えば、ホスト）、要求修飾子（[RFC7231]のセクション5で例えば、コントロールと条件）のために必要なフィールドが含まれているトレーラーを生成してはなりません、認証（例えば、[RFC7231]のセクション7.1を参照）、応答制御データ（例えば、[RFC7235]及び[RFC6265]を参照）、またはペイロードを処理する方法を決定する（例えば、コンテンツのエンコーディング、コンテンツタイプ、のContent範囲、およびトレーラー）。"
    },
    {
      "indent": 3,
      "text": "When a chunked message containing a non-empty trailer is received, the recipient MAY process the fields (aside from those forbidden above) as if they were appended to the message's header section. A recipient MUST ignore (or consider as an error) any fields that are forbidden to be sent in a trailer, since processing them as if they were present in the header section might bypass external security filters.",
      "ja": "非空のトレーラを含むチャンクメッセージを受信すると、受信者は、彼らがメッセージのヘッダ部に付加されたかのように（上記禁止ものから脇）フィールドを処理することができます。彼らはヘッダ部に存在したかのようにそれらを処理する外部のセキュリティフィルタをバイパスする可能性があるため、受信者は、トレーラーに送信することが禁止されているすべてのフィールドを無視する（またはエラーとして考える）しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Unless the request includes a TE header field indicating \"trailers\" is acceptable, as described in Section 4.3, a server SHOULD NOT generate trailer fields that it believes are necessary for the user agent to receive. Without a TE containing \"trailers\", the server ought to assume that the trailer fields might be silently discarded along the path to the user agent. This requirement allows intermediaries to forward a de-chunked message to an HTTP/1.0 recipient without buffering the entire response.",
      "ja": "要求は、セクション4.3で説明したように「トレーラー」を示すTEヘッダフィールドは、許容できる含まれていない限り、サーバは、それが受信するユーザエージェントのために必要であると考えているトレーラフィールドを生成するべきではありません。 「トレーラー」を含むTEせずに、サーバーは、トレーラーのフィールドは黙っユーザエージェントへのパスに沿って廃棄された可能性があることを前提とするべきです。この要件は、仲介者は、全体の応答をバッファリングすることなく、HTTP / 1.0の受信者にデチャンクメッセージを転送することを可能にします。"
    },
    {
      "indent": 0,
      "text": "4.1.3. Decoding Chunked",
      "section_title": true,
      "ja": "4.1.3。デコーディングチャンク"
    },
    {
      "indent": 3,
      "text": "A process for decoding the chunked transfer coding can be represented in pseudo-code as:",
      "ja": "チャンク転送符号化を復号するためのプロセスは、疑似コードで表すことができます。"
    },
    {
      "indent": 5,
      "text": "length := 0 read chunk-size, chunk-ext (if any), and CRLF while (chunk-size > 0) { read chunk-data and CRLF append chunk-data to decoded-body length := length + chunk-size read chunk-size, chunk-ext (if any), and CRLF } read trailer field while (trailer field is not empty) { if (trailer field is allowed to be sent in a trailer) { append trailer field to existing header fields } read trailer-field } Content-Length := length Remove \"chunked\" from Transfer-Encoding Remove Trailer from existing header fields",
      "ja": "長さ：= 0リードチャンクサイズ、チャンク-EXT（もしあれば）、およびCRLF一方（チャンクサイズ> 0）{復号化ボディ長チャンクデータとCRLFの追記チャンクデータを読み出す：=長さ+チャンクサイズチャンクサイズ、チャンク-EXT（もしあれば）、およびCRLF}を読み取る（トレーラフィールドが空でない）しながら、トレーラフィールドを読み取る{（トレーラフィールドはトレーラーで送信することが許可されている）場合、{既存のヘッダフィールドにトレーラフィールドを追加}トレーラー・フィールド}のContent-Lengthをお読みください=長さ削除、既存のヘッダフィールドからトレーラーを外し転送エンコーディングから「チャンク」"
    },
    {
      "indent": 0,
      "text": "4.2. Compression Codings",
      "section_title": true,
      "ja": "4.2。圧縮コーディング"
    },
    {
      "indent": 3,
      "text": "The codings defined below can be used to compress the payload of a message.",
      "ja": "以下に定義されるコーディングは、メッセージのペイロードを圧縮するために使用することができます。"
    },
    {
      "indent": 0,
      "text": "4.2.1. Compress Coding",
      "section_title": true,
      "ja": "4.2.1。コーディング圧縮"
    },
    {
      "indent": 3,
      "text": "The \"compress\" coding is an adaptive Lempel-Ziv-Welch (LZW) coding [Welch] that is commonly produced by the UNIX file compression program \"compress\". A recipient SHOULD consider \"x-compress\" to be equivalent to \"compress\".",
      "ja": "符号「圧縮」は、一般的にUNIXファイル圧縮プログラムによって生成された適応型のLempel-Ziv符号、ウェルチ（LZW）コーディング[ウェルチは「圧縮」です。受信者は、「圧縮」に相当すると「X-圧縮」を検討すべきです。"
    },
    {
      "indent": 0,
      "text": "4.2.2. Deflate Coding",
      "section_title": true,
      "ja": "4.2.2。コーディング収縮"
    },
    {
      "indent": 3,
      "text": "The \"deflate\" coding is a \"zlib\" data format [RFC1950] containing a \"deflate\" compressed data stream [RFC1951] that uses a combination of the Lempel-Ziv (LZ77) compression algorithm and Huffman coding.",
      "ja": "符号「収縮」のLempel-Ziv符号（LZ77）圧縮アルゴリズムの組み合わせを使用し、ハフマン符号化、「収縮」圧縮データストリーム[RFC1951]を含む「ZLIB」データフォーマット[RFC1950]です。"
    },
    {
      "indent": 6,
      "text": "Note: Some non-conformant implementations send the \"deflate\" compressed data without the zlib wrapper.",
      "ja": "注意：一部の非準拠の実装はzlibのラッパーなしで「収縮」圧縮されたデータを送信します。"
    },
    {
      "indent": 0,
      "text": "4.2.3. Gzip Coding",
      "section_title": true,
      "ja": "4.2.3。コーディングをGzip"
    },
    {
      "indent": 3,
      "text": "The \"gzip\" coding is an LZ77 coding with a 32-bit Cyclic Redundancy Check (CRC) that is commonly produced by the gzip file compression program [RFC1952]. A recipient SHOULD consider \"x-gzip\" to be equivalent to \"gzip\".",
      "ja": "「GZIP」符号化は、一般的にgzipファイル圧縮プログラム[RFC1952]によって生成される32ビットの巡回冗長検査（CRC）とLZ77符号化です。受信者は、「GZIP」に相当すると「X-GZIP」を検討すべきです。"
    },
    {
      "indent": 0,
      "text": "4.3. TE",
      "section_title": true,
      "ja": "４。３。 て"
    },
    {
      "indent": 3,
      "text": "The \"TE\" header field in a request indicates what transfer codings, besides chunked, the client is willing to accept in response, and whether or not the client is willing to accept trailer fields in a chunked transfer coding.",
      "ja": "リクエスト中の「TE」ヘッダフィールドは、転送コーディングは、チャンク以外に、クライアントは応答して受け入れても構わないと思っているものを示しており、か否かをクライアントがチャンク転送符号化におけるトレーラフィールドを受け入れても構わないと思っています。"
    },
    {
      "indent": 3,
      "text": "The TE field-value consists of a comma-separated list of transfer coding names, each allowing for optional parameters (as described in Section 4), and/or the keyword \"trailers\". A client MUST NOT send the chunked transfer coding name in TE; chunked is always acceptable for HTTP/1.1 recipients.",
      "ja": "TE電界値は、名前、オプションのパラメータ（セクション4で説明したように）、および/またはキーワード「トレーラー」を可能にする、各符号化転送のコンマ区切りのリストで構成されています。クライアントは、TEに名前をコーディングチャンク転送を送ってはいけません。チャンクHTTP / 1.1の受信者に対して常に許容されます。"
    },
    {
      "indent": 5,
      "text": "TE = #t-codings t-codings = \"trailers\" / ( transfer-coding [ t-ranking ] ) t-ranking = OWS \";\" OWS \"q=\" rank rank = ( \"0\" [ \".\" 0*3DIGIT ] ) / ( \"1\" [ \".\" 0*3(\"0\") ] )",
      "ja": "\";\" TE =＃1 = \"トレーラー\" /（転送コーディング[T-ランキング]）T-ランク= OWSを-コーディングに対するTコーディングOWS \"Q =\" ランクランク=（ \"0\" [ \"\" 0 * DIGIT 3]）/（ \"1\" [ \"\" 0 * 3（ \"0\"）]）"
    },
    {
      "indent": 3,
      "text": "Three examples of TE use are below.",
      "ja": "私たちの3つの例は以下の通りです。"
    },
    {
      "indent": 5,
      "text": "TE: deflate TE: TE: trailers, deflate;q=0.5",
      "ja": "TE：TE：TE収縮収縮、トレーラー; Q = 0.5"
    },
    {
      "indent": 3,
      "text": "The presence of the keyword \"trailers\" indicates that the client is willing to accept trailer fields in a chunked transfer coding, as defined in Section 4.1.2, on behalf of itself and any downstream clients. For requests from an intermediary, this implies that either: (a) all downstream clients are willing to accept trailer fields in the forwarded response; or, (b) the intermediary will attempt to buffer the response on behalf of downstream recipients. Note that HTTP/1.1 does not define any means to limit the size of a chunked response such that an intermediary can be assured of buffering the entire response.",
      "ja": "キーワード「トレーラー」の存在は、クライアントが自身の代理と任意のダウンストリームクライアントに、4.1.2節で定義されるように、チャンク転送コーディングでトレーラーフィールドを受け入れることを望んでいることを示しています。 （a）すべてのダウンストリームのクライアントが転送応答トレーラーフィールドを受け入れて喜んでである;：仲介からの要求の場合、これはどちらかということを意味しますまたは、（b）は中間、下流の受信者に代わって応答をバッファリングしようとします。そのHTTP / 1.1は、中間全体の応答をバッファリングを保証することができるようにチャンク応答の大きさを制限する任意の手段を定義していません。"
    },
    {
      "indent": 3,
      "text": "When multiple transfer codings are acceptable, the client MAY rank the codings by preference using a case-insensitive \"q\" parameter (similar to the qvalues used in content negotiation fields, Section",
      "ja": "複数の転送コーディングが許容可能である場合、クライアントは、コンテンツネゴシエーション分野で使用qvalues、節と同様、大文字と小文字を区別しない「Q」パラメータ（使用嗜好によってコーディングをランク付け"
    },
    {
      "indent": 3,
      "text": "5.3.1 of [RFC7231]). The rank value is a real number in the range 0 through 1, where 0.001 is the least preferred and 1 is the most preferred; a value of 0 means \"not acceptable\".",
      "ja": "[RFC7231]の5.3.1）。ランク値は、0.001以上好ましく、1が最も好ましい範囲は0から1を介して、内の実数です。 0の値は「受け入れられない」を意味します。"
    },
    {
      "indent": 3,
      "text": "If the TE field-value is empty or if no TE field is present, the only acceptable transfer coding is chunked. A message with no transfer coding is always acceptable.",
      "ja": "TE電界値が空である場合、または全くTEフィールドが存在しない場合にのみ許容される転送符号化がチャンクされています。ない転送コーディングのメッセージは常に許容されます。"
    },
    {
      "indent": 3,
      "text": "Since the TE header field only applies to the immediate connection, a sender of TE MUST also send a \"TE\" connection option within the Connection header field (Section 6.1) in order to prevent the TE field from being forwarded by intermediaries that do not support its semantics.",
      "ja": "TEヘッダフィールドのみが即時接続に適用されるため、TEの送信者にも対応していないの仲介によって転送されることからTEフィールドを防ぐために、Connectionヘッダフィールド（6.1節）の中に、「TE」接続オプションを送らなければなりませんその意味論。"
    },
    {
      "indent": 0,
      "text": "4.4. Trailer",
      "section_title": true,
      "ja": "4.4。トレーラー"
    },
    {
      "indent": 3,
      "text": "When a message includes a message body encoded with the chunked transfer coding and the sender desires to send metadata in the form of trailer fields at the end of the message, the sender SHOULD generate a Trailer header field before the message body to indicate which fields will be present in the trailers. This allows the recipient to prepare for receipt of that metadata before it starts processing the body, which is useful if the message is being streamed and the recipient wishes to confirm an integrity check on the fly.",
      "ja": "メッセージは、チャンク転送符号化で符号化されたメッセージ本体を含み、送信者がメッセージの最後にトレーラフィールドの形でメタデータを送信したいときのメッセージ本体はれるフィールドかを示すために前に、送信者はトレーラーヘッダフィールドを生成する必要がありますトレーラー内に存在します。これは、メッセージがストリーミングされ、受信者がその場で整合性チェックを確認したい場合に有用であり、それは体の処理を開始する前に、受信者がそのメタデータの受信を準備することを可能にします。"
    },
    {
      "indent": 5,
      "text": "Trailer = 1#field-name",
      "ja": "トレーラー= 1＃フィールド名"
    },
    {
      "indent": 0,
      "text": "5. Message Routing",
      "section_title": true,
      "ja": "5.メッセージルーティング"
    },
    {
      "indent": 3,
      "text": "HTTP request message routing is determined by each client based on the target resource, the client's proxy configuration, and establishment or reuse of an inbound connection. The corresponding response routing follows the same connection chain back to the client.",
      "ja": "HTTPリクエストメッセージのルーティングは、着信接続のターゲットリソース、クライアントのプロキシ設定、確立又は再使用に基づいて、各クライアントによって決定されます。対応する応答は、ルーティングクライアントに同じ接続チェーンをたどります。"
    },
    {
      "indent": 0,
      "text": "5.1. Identifying a Target Resource",
      "section_title": true,
      "ja": "5.1。ターゲットリソースの識別"
    },
    {
      "indent": 3,
      "text": "HTTP is used in a wide variety of applications, ranging from general-purpose computers to home appliances. In some cases, communication options are hard-coded in a client's configuration. However, most HTTP clients rely on the same resource identification mechanism and configuration techniques as general-purpose Web browsers.",
      "ja": "HTTPは、汎用コンピュータから家電に至るまで、多種多様なアプリケーションで使用されています。いくつかのケースでは、通信オプションは、ハードコーディングされたクライアントの構成になっています。しかし、ほとんどのHTTPクライアントは、汎用のWebブラウザと同じリソース識別メカニズムや構成技術に依存しています。"
    },
    {
      "indent": 3,
      "text": "HTTP communication is initiated by a user agent for some purpose. The purpose is a combination of request semantics, which are defined in [RFC7231], and a target resource upon which to apply those semantics. A URI reference (Section 2.7) is typically used as an",
      "ja": "HTTP通信は、いくつかの目的のために、ユーザエージェントによって開始されます。目的は、[RFC7231]で定義された要求のセマンティクス、及びそれらの意味論を適用する際に対象リソースの組み合わせです。 URI参照（セクション2.7）は、通常のように使用されています"
    },
    {
      "indent": 3,
      "text": "identifier for the \"target resource\", which a user agent would resolve to its absolute form in order to obtain the \"target URI\". The target URI excludes the reference's fragment component, if any, since fragment identifiers are reserved for client-side processing ([RFC3986], Section 3.5).",
      "ja": "ユーザエージェントは、「ターゲットURI」を得るためにその絶対形式に解決なる「ターゲットリソース」の識別子。フラグメント識別子は、クライアント側の処理のために予約されているので、ターゲットURIは、もしあれば、基準のフラグメント成分を除外する（[RFC3986]、セクション3.5）。"
    },
    {
      "indent": 0,
      "text": "5.2. Connecting Inbound",
      "section_title": true,
      "ja": "5.2。インバウンドの接続"
    },
    {
      "indent": 3,
      "text": "Once the target URI is determined, a client needs to decide whether a network request is necessary to accomplish the desired semantics and, if so, where that request is to be directed.",
      "ja": "ターゲットURIが決定されると、その要求が指示される場合、クライアントは、もしそうであれば、ネットワーク要求は、所望のセマンティクスを達成するために必要であるかどうかを決定する必要があると。"
    },
    {
      "indent": 3,
      "text": "If the client has a cache [RFC7234] and the request can be satisfied by it, then the request is usually directed there first.",
      "ja": "クライアントは、キャッシュ[RFC7234]と要求を持っている場合、それによって満足することができ、その要求は通常、最初にそこに向けられています。"
    },
    {
      "indent": 3,
      "text": "If the request is not satisfied by a cache, then a typical client will check its configuration to determine whether a proxy is to be used to satisfy the request. Proxy configuration is implementation-dependent, but is often based on URI prefix matching, selective authority matching, or both, and the proxy itself is usually identified by an \"http\" or \"https\" URI. If a proxy is applicable, the client connects inbound by establishing (or reusing) a connection to that proxy.",
      "ja": "要求がキャッシュによって満たされていない場合、一般的なクライアントは、プロキシが要求を満たすために使用するかどうかを判断するために、その構成をチェックします。プロキシの設定は実装依存であるが、多くの場合、URI接頭辞マッチング、選択的権威のマッチング、またはその両方に基づいており、プロキシ自体は、通常は「http」または「https」URIによって識別されます。プロキシが適用される場合、クライアントが確立（または再利用）することにより、インバウンドそのプロキシへの接続を接続しています。"
    },
    {
      "indent": 3,
      "text": "If no proxy is applicable, a typical client will invoke a handler routine, usually specific to the target URI's scheme, to connect directly to an authority for the target resource. How that is accomplished is dependent on the target URI scheme and defined by its associated specification, similar to how this specification defines origin server access for resolution of the \"http\" (Section 2.7.1) and \"https\" (Section 2.7.2) schemes.",
      "ja": "何のプロキシが適用されない場合は、一般的なクライアントは、ターゲット・リソースの権限に直接接続するために、ターゲットURIのスキームには通常、特定の、ハンドラルーチンを呼び出します。どのようにそれが達成されたターゲットURIスキームに依存し、それに関連する仕様で定義され、この仕様は「HTTP」（2.7.1項）と「HTTPS」（第2.7.2項）の解像度のためのオリジンサーバへのアクセスを定義する方法と似ていますスキーム。"
    },
    {
      "indent": 3,
      "text": "HTTP requirements regarding connection management are defined in Section 6.",
      "ja": "接続管理に関するHTTP要求は、セクション6で定義されています。"
    },
    {
      "indent": 0,
      "text": "5.3. Request Target",
      "section_title": true,
      "ja": "5.3。要求の対象"
    },
    {
      "indent": 3,
      "text": "Once an inbound connection is obtained, the client sends an HTTP request message (Section 3) with a request-target derived from the target URI. There are four distinct formats for the request-target, depending on both the method being requested and whether the request is to a proxy.",
      "ja": "着信接続が得られると、クライアントは、ターゲットURIに由来する要求対象とHTTPリクエストメッセージ（セクション3）を送信します。リクエスト対象のための4つの異なるフォーマットが要求されている方法と要求がプロキシであるかどうかの両方に依存して、存在しています。"
    },
    {
      "indent": 5,
      "text": "request-target = origin-form / absolute-form / authority-form / asterisk-form",
      "ja": "リクエスト・ターゲット=原点形式/絶対形式/権限-フォーム/アスタリスクフォーム"
    },
    {
      "indent": 0,
      "text": "5.3.1. origin-form",
      "section_title": true,
      "ja": "5.3.1。原点フォーム"
    },
    {
      "indent": 3,
      "text": "The most common form of request-target is the origin-form.",
      "ja": "要求対象の最も一般的な形式は、原点の形です。"
    },
    {
      "indent": 5,
      "text": "origin-form = absolute-path [ \"?\" query ]",
      "ja": "原点型=絶対パス[「？」クエリ]"
    },
    {
      "indent": 3,
      "text": "When making a request directly to an origin server, other than a CONNECT or server-wide OPTIONS request (as detailed below), a client MUST send only the absolute path and query components of the target URI as the request-target. If the target URI's path component is empty, the client MUST send \"/\" as the path within the origin-form of request-target. A Host header field is also sent, as defined in Section 5.4.",
      "ja": "CONNECTまたはサーバ全体OPTIONS要求（以下に詳述するように）以外のオリジンサーバに直接要求を行う場合、クライアントは、要求のターゲットとしてのみター​​ゲットURIの絶対パスとクエリコンポーネントを送信しなければなりません。ターゲットURIのパスコンポーネントが空の場合、クライアントがリクエスト・ターゲットの原点フォーム内でパスとして「/」を送信しなければなりません。セクション5.4で定義されたように、ホストヘッダフィールドはまた、送信されます。"
    },
    {
      "indent": 3,
      "text": "For example, a client wishing to retrieve a representation of the resource identified as",
      "ja": "たとえば、リソースの表現を取得したいクライアントがあると同定します"
    },
    {
      "indent": 5,
      "text": "http://www.example.org/where?q=now",
      "ja": "ｈっｔｐ：／／ｗっｗ。えぁｍｐぇ。おｒｇ／うぇれ？ｑ＝のｗ"
    },
    {
      "indent": 3,
      "text": "directly from the origin server would open (or reuse) a TCP connection to port 80 of the host \"www.example.org\" and send the lines:",
      "ja": "直接オリジンサーバが開きます（または再利用）ホストのポート80へのTCPコネクション「www.example.org」と行を送信しますから。"
    },
    {
      "indent": 5,
      "text": "GET /where?q=now HTTP/1.1 Host: www.example.org",
      "ja": "？GET /ここで、Q =今HTTP / 1.1ホスト：www.example.org"
    },
    {
      "indent": 3,
      "text": "followed by the remainder of the request message.",
      "ja": "要求メッセージの残りが続きます。"
    },
    {
      "indent": 0,
      "text": "5.3.2. absolute-form",
      "section_title": true,
      "ja": "5.3.2。絶対フォーム"
    },
    {
      "indent": 3,
      "text": "When making a request to a proxy, other than a CONNECT or server-wide OPTIONS request (as detailed below), a client MUST send the target URI in absolute-form as the request-target.",
      "ja": "CONNECTまたは（以下に詳述するように）サーバ全体OPTIONS要求以外のプロキシに要求を行うときに、クライアントは、要求対象として絶対形式でターゲットURIを送らなければなりません。"
    },
    {
      "indent": 5,
      "text": "absolute-form = absolute-URI",
      "ja": "絶対形式=絶対URI"
    },
    {
      "indent": 3,
      "text": "The proxy is requested to either service that request from a valid cache, if possible, or make the same request on the client's behalf to either the next inbound proxy server or directly to the origin server indicated by the request-target. Requirements on such \"forwarding\" of messages are defined in Section 5.7.",
      "ja": "プロキシが可能な場合は、有効なキャッシュからリクエストする、または次のインバウンドプロキシサーバまたは直接リクエスト対象で示されるオリジンサーバへのいずれかへのクライアントの代わりに同じ要求を行うのいずれかのサービスに要求されています。メッセージのように「転送」の要件は、5.7節で定義されています。"
    },
    {
      "indent": 3,
      "text": "An example absolute-form of request-line would be:",
      "ja": "リクエストラインの例絶対形式は次のようになります。"
    },
    {
      "indent": 5,
      "text": "GET http://www.example.org/pub/WWW/TheProject.html HTTP/1.1",
      "ja": "GET http://www.example.org/pub/WWW/TheProject.html HTTP / 1.1"
    },
    {
      "indent": 3,
      "text": "To allow for transition to the absolute-form for all requests in some future version of HTTP, a server MUST accept the absolute-form in requests, even though HTTP/1.1 clients will only send them in requests to proxies.",
      "ja": "HTTPの将来のバージョンでは、すべての要求のための絶対的な形式への移行を可能にするため、サーバがリクエストに絶対形式を受け入れなければならない、HTTP / 1.1クライアントは、プロキシへの要求でそれらを送信するにもかかわらず。"
    },
    {
      "indent": 0,
      "text": "5.3.3. authority-form",
      "section_title": true,
      "ja": "5.3.3。権限フォーム"
    },
    {
      "indent": 3,
      "text": "The authority-form of request-target is only used for CONNECT requests (Section 4.3.6 of [RFC7231]).",
      "ja": "リクエスト対象の権限フォームのみCONNECT要求（[RFC7231]のセクション4.3.6）のために使用されます。"
    },
    {
      "indent": 5,
      "text": "authority-form = authority",
      "ja": "権限フォーム=権威"
    },
    {
      "indent": 3,
      "text": "When making a CONNECT request to establish a tunnel through one or more proxies, a client MUST send only the target URI's authority component (excluding any userinfo and its \"@\" delimiter) as the request-target. For example,",
      "ja": "一つ以上のプロキシ経由のトンネルを確立するためのCONNECT要求を行う場合は、クライアントはURIの権限コンポーネント要求のターゲットとして、（任意のuserinfoを、その「@」区切り文字を除く）の目標を送らなければなりません。例えば、"
    },
    {
      "indent": 5,
      "text": "CONNECT www.example.com:80 HTTP/1.1",
      "ja": "CONNECT www.example.com:80 HTTP / 1.1"
    },
    {
      "indent": 0,
      "text": "5.3.4. asterisk-form",
      "section_title": true,
      "ja": "5.3.4。アスタリスクフォーム"
    },
    {
      "indent": 3,
      "text": "The asterisk-form of request-target is only used for a server-wide OPTIONS request (Section 4.3.7 of [RFC7231]).",
      "ja": "リクエスト対象のアスタリスクフォームのみサーバ全体OPTIONS要求のために使用される（[RFC7231]のセクション4.3.7）。"
    },
    {
      "indent": 5,
      "text": "asterisk-form = \"*\"",
      "ja": "アスタリスクフォーム=「*」"
    },
    {
      "indent": 3,
      "text": "When a client wishes to request OPTIONS for the server as a whole, as opposed to a specific named resource of that server, the client MUST send only \"*\" (%x2A) as the request-target. For example,",
      "ja": "そのサーバーの特定の名前付きリソースとは対照的に、クライアントは、サーバ全体のオプションを要求したい場合、クライアントは、要求のターゲットとして、（％のX2A）「*」のみ送らなければなりません。例えば、"
    },
    {
      "indent": 5,
      "text": "OPTIONS * HTTP/1.1",
      "ja": "OPTIONS * HTTP / 1.1"
    },
    {
      "indent": 3,
      "text": "If a proxy receives an OPTIONS request with an absolute-form of request-target in which the URI has an empty path and no query component, then the last proxy on the request chain MUST send a request-target of \"*\" when it forwards the request to the indicated origin server.",
      "ja": "プロキシはOPTIONSは、URIが空パスなしクエリコンポーネントを有する、リクエスト対象の絶対形式で要求を受信した場合ときに転送し、その後、要求チェーンの最後のプロキシは、「*」のリクエスト対象を送らなければなりません指示されたオリジンサーバへの要求。"
    },
    {
      "indent": 3,
      "text": "For example, the request",
      "ja": "例えば、要求"
    },
    {
      "indent": 5,
      "text": "OPTIONS http://www.example.org:8001 HTTP/1.1",
      "ja": "OPTIONS http://www.example.org:8001 HTTP / 1.1"
    },
    {
      "indent": 3,
      "text": "would be forwarded by the final proxy as",
      "ja": "最終的なプロキシによって転送されるだろう"
    },
    {
      "indent": 5,
      "text": "OPTIONS * HTTP/1.1 Host: www.example.org:8001",
      "ja": "OPTIONS * HTTP / 1.1ホスト：www.example.org:8001"
    },
    {
      "indent": 3,
      "text": "after connecting to port 8001 of host \"www.example.org\".",
      "ja": "「www.example.org」ホストのポート8001に接続した後。"
    },
    {
      "indent": 0,
      "text": "5.4. Host",
      "section_title": true,
      "ja": "5.4。ホスト"
    },
    {
      "indent": 3,
      "text": "The \"Host\" header field in a request provides the host and port information from the target URI, enabling the origin server to distinguish among resources while servicing requests for multiple host names on a single IP address.",
      "ja": "リクエストで「ホスト」ヘッダフィールドは、単一のIPアドレスに複数のホスト名に対する要求にサービスを提供しながら、リソースを区別するためにオリジンサーバを有効にする、ターゲットURIからホストとポートの情報を提供します。"
    },
    {
      "indent": 5,
      "text": "Host = uri-host [ \":\" port ] ; Section 2.7.1",
      "ja": "ホスト= URI-ホスト[ \"：\" ポート]; 2.7.1項"
    },
    {
      "indent": 3,
      "text": "A client MUST send a Host header field in all HTTP/1.1 request messages. If the target URI includes an authority component, then a client MUST send a field-value for Host that is identical to that authority component, excluding any userinfo subcomponent and its \"@\" delimiter (Section 2.7.1). If the authority component is missing or undefined for the target URI, then a client MUST send a Host header field with an empty field-value.",
      "ja": "クライアントは、すべてのHTTP / 1.1リクエストメッセージにHostヘッダフィールドを送らなければなりません。ターゲットURIが権限コンポーネントが含まれている場合、クライアントはどんなのUserInfoサブコンポーネントとその「@」区切り（セクション2.7.1）を除く、その権限コンポーネントと同じであるホストのためのフィールド値を送らなければなりません。権限コンポーネントが欠落しているか、ターゲットURIのために定義されていない場合、クライアントは空のフィールド値とHostヘッダフィールドを送らなければなりません。"
    },
    {
      "indent": 3,
      "text": "Since the Host field-value is critical information for handling a request, a user agent SHOULD generate Host as the first header field following the request-line.",
      "ja": "Hostフィールド値は要求を処理するための重要な情報であるため、ユーザエージェントは、リクエストラインに続く最初のヘッダフィールドのような宿主を生成する必要があります。"
    },
    {
      "indent": 3,
      "text": "For example, a GET request to the origin server for <http://www.example.org/pub/WWW/> would begin with:",
      "ja": "たとえば、<http://www.example.org/pub/WWW/>のためのオリジンサーバへのGETリクエストで始まるでしょう："
    },
    {
      "indent": 5,
      "text": "GET /pub/WWW/ HTTP/1.1 Host: www.example.org",
      "ja": "GET /パブ/ WWW / HTTP / 1.1ホスト：www.example.org"
    },
    {
      "indent": 3,
      "text": "A client MUST send a Host header field in an HTTP/1.1 request even if the request-target is in the absolute-form, since this allows the Host information to be forwarded through ancient HTTP/1.0 proxies that might not have implemented Host.",
      "ja": "クライアントは、これは、ホスト情報がホストを実装していない可能性があり、古代のHTTP / 1.0プロキシ経由で転送されることを可能にするため、要求のターゲットは、絶対形式であってもHTTP / 1.1リクエストにHostヘッダフィールドを送らなければなりません。"
    },
    {
      "indent": 3,
      "text": "When a proxy receives a request with an absolute-form of request-target, the proxy MUST ignore the received Host header field (if any) and instead replace it with the host information of the request-target. A proxy that forwards such a request MUST generate a new Host field-value based on the received request-target rather than forward the received Host field-value.",
      "ja": "プロキシは、要求対象の絶対形式で要求を受信すると、プロキシは（もしあれば）受信したホストヘッダーフィールドを無視し、代わりに、要求対象のホスト情報と交換しなければなりません。そのような要求を転送するプロキシは、受信した要求ターゲットに基づく新しいHostフィールド値を生成するのではなく受信Hostフィールド値を転送する必要があります。"
    },
    {
      "indent": 3,
      "text": "Since the Host header field acts as an application-level routing mechanism, it is a frequent target for malware seeking to poison a shared cache or redirect a request to an unintended server. An interception proxy is particularly vulnerable if it relies on the Host field-value for redirecting requests to internal servers, or for use as a cache key in a shared cache, without first verifying that the intercepted connection is targeting a valid IP address for that host.",
      "ja": "ホストヘッダフィールドは、アプリケーションレベルのルーティングメカニズムとして作用するので、共有キャッシュを汚染または意図しないサーバに要求をリダイレクトしようとしているマルウェアの頻繁な標的です。傍受プロキシは、それが内部サーバーに要求をリダイレクトするためのHostフィールド値に依存している場合は特に脆弱である、または共有キャッシュ内のキャッシュ・キーとして使用するため、最初のインターセプトされた接続は、そのホストの有効なIPアドレスをターゲットにしていることを確認することなく、 。"
    },
    {
      "indent": 3,
      "text": "A server MUST respond with a 400 (Bad Request) status code to any HTTP/1.1 request message that lacks a Host header field and to any request message that contains more than one Host header field or a Host header field with an invalid field-value.",
      "ja": "サーバは、Hostヘッダフィールドを欠き、無効なフィールド値を用いて複数のホストヘッダーフィールドまたはHostヘッダフィールドを含む任意の要求メッセージへのHTTP / 1.1リクエストメッセージ400（不正な要求）ステータスコードで応答しなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.5. Effective Request URI",
      "section_title": true,
      "ja": "5.5。効果的なリクエストURI"
    },
    {
      "indent": 3,
      "text": "Since the request-target often contains only part of the user agent's target URI, a server reconstructs the intended target as an \"effective request URI\" to properly service the request. This reconstruction involves both the server's local configuration and information communicated in the request-target, Host header field, and connection context.",
      "ja": "リクエスト・ターゲットは、多くの場合、ユーザエージェントのターゲットURIの一部のみが含まれているので、サーバーは正常に要求を処理するために「効果的なリクエストURI」として意図されたターゲットを再構築します。この再構成は、サーバーのローカル構成情報の要求先で通信、ホストヘッダフィールドと、接続コンテキストの両方を含みます。"
    },
    {
      "indent": 3,
      "text": "For a user agent, the effective request URI is the target URI.",
      "ja": "ユーザエージェントのために、効果的なリクエストURIは、ターゲットURIです。"
    },
    {
      "indent": 3,
      "text": "If the request-target is in absolute-form, the effective request URI is the same as the request-target. Otherwise, the effective request URI is constructed as follows:",
      "ja": "リクエスト対象の絶対形態である場合、有効なリクエストURIは、要求のターゲットと同じです。次のようにそうでなければ、効果的なリクエストURIが構築されています。"
    },
    {
      "indent": 6,
      "text": "If the server's configuration (or outbound gateway) provides a fixed URI scheme, that scheme is used for the effective request URI. Otherwise, if the request is received over a TLS-secured TCP connection, the effective request URI's scheme is \"https\"; if not, the scheme is \"http\".",
      "ja": "サーバの設定（またはアウトバウンドゲートウェイ）が固定されたURIスキームを提供する場合、その方式は有効なリクエストURIに使用されます。リクエストがTLSで保護されたTCP接続を介して受信された場合はそれ以外の場合は、効果的な要求は、URIのスキームは、「https」のです。ない場合は、スキームは、「HTTP」です。"
    },
    {
      "indent": 6,
      "text": "If the server's configuration (or outbound gateway) provides a fixed URI authority component, that authority is used for the effective request URI. If not, then if the request-target is in authority-form, the effective request URI's authority component is the same as the request-target. If not, then if a Host header field is supplied with a non-empty field-value, the authority component is the same as the Host field-value. Otherwise, the authority component is assigned the default name configured for the server and, if the connection's incoming TCP port number differs from the default port for the effective request URI's scheme, then a colon (\":\") and the incoming port number (in decimal form) are appended to the authority component.",
      "ja": "サーバの設定（またはアウトバウンドゲートウェイ）が固定されたURIの権限コンポーネントを提供している場合、その権限は有効なリクエストURIに使用されます。そうでない場合、要求-ターゲットは権威-形であるならば、その後、効果的なリクエストURIの権限コンポーネントは、要求のターゲットと同じです。そうでない場合、ホストヘッダフィールドが非空のフィールド値が供給され、次いで場合、権限コンポーネントは、ホストフィールド値と同じです。 （中や着信ポート番号：それ以外の場合、権限コンポーネントは、接続の着信TCPポート番号が有効リクエストURIのスキームは、コロン（「」）のデフォルトポートと異なる場合、デフォルト名は、サーバー用に設定され、割り当てられ、小数形）は権限コンポーネントに追加されます。"
    },
    {
      "indent": 6,
      "text": "If the request-target is in authority-form or asterisk-form, the effective request URI's combined path and query component is empty. Otherwise, the combined path and query component is the same as the request-target.",
      "ja": "リクエスト対象が権限-フォームまたはアスタリスク-形態である場合、効果的なリクエストURIの組み合わせパスとクエリコンポーネントは空です。そうでない場合は、合成経路およびクエリコンポーネントは、要求のターゲットと同じです。"
    },
    {
      "indent": 6,
      "text": "The components of the effective request URI, once determined as above, can be combined into absolute-URI form by concatenating the scheme, \"://\", authority, and combined path and query component.",
      "ja": "「：//」、権限、そして合わせたパスとクエリコンポーネント一度上記のように決定された有効リクエストURIの成分は、スキームを連結することによって絶対URIの形に組み合わせることができます。"
    },
    {
      "indent": 3,
      "text": "Example 1: the following message received over an insecure TCP connection",
      "ja": "実施例1：非セキュアTCP接続を介して受信された次のメッセージ"
    },
    {
      "indent": 5,
      "text": "GET /pub/WWW/TheProject.html HTTP/1.1 Host: www.example.org:8080",
      "ja": "GET /pub/WWW/TheProject.html HTTP / 1.1ホスト：www.example.org:8080"
    },
    {
      "indent": 3,
      "text": "has an effective request URI of",
      "ja": "効果的な要求のURIを持っています"
    },
    {
      "indent": 5,
      "text": "http://www.example.org:8080/pub/WWW/TheProject.html",
      "ja": "ｈっｔｐ：／／ｗっｗ。えぁｍｐぇ。おｒｇ：８０８０／ぷｂ／ｗっｗ／てぇＰろじぇｃｔ。ｈｔｍｌ"
    },
    {
      "indent": 3,
      "text": "Example 2: the following message received over a TLS-secured TCP connection",
      "ja": "例2：次のメッセージがTLSで保護されたTCP接続を介して受信し"
    },
    {
      "indent": 5,
      "text": "OPTIONS * HTTP/1.1 Host: www.example.org",
      "ja": "OPTIONS * HTTP / 1.1ホスト：www.example.org"
    },
    {
      "indent": 3,
      "text": "has an effective request URI of",
      "ja": "効果的な要求のURIを持っています"
    },
    {
      "indent": 5,
      "text": "https://www.example.org",
      "ja": "ｈっｔｐｓ：／／ｗっｗ。えぁｍｐぇ。おｒｇ"
    },
    {
      "indent": 3,
      "text": "Recipients of an HTTP/1.0 request that lacks a Host header field might need to use heuristics (e.g., examination of the URI path for something unique to a particular host) in order to guess the effective request URI's authority component.",
      "ja": "Hostヘッダフィールドは、ヒューリスティックを使用する必要があります不足しているHTTP / 1.0リクエストの受信者（例えば、特定のホストに固有の何かのためのURIパスの審査）効果的なリクエストURIの権限コンポーネントを推測するためです。"
    },
    {
      "indent": 3,
      "text": "Once the effective request URI has been constructed, an origin server needs to decide whether or not to provide service for that URI via the connection in which the request was received. For example, the request might have been misdirected, deliberately or accidentally, such that the information within a received request-target or Host header field differs from the host or port upon which the connection has been made. If the connection is from a trusted gateway, that inconsistency might be expected; otherwise, it might indicate an attempt to bypass security filters, trick the server into delivering non-public content, or poison a cache. See Section 9 for security considerations regarding message routing.",
      "ja": "効果的なリクエストURIが構築されたら、オリジンサーバは、要求が受信された接続を介してそのURIのためのサービスを提供するかどうかを決定する必要があります。例えば、リクエストは、受信した要求対象またはホストヘッダフィールド内の情報は、接続が行われた時にホストまたはポートとは異なるように、故意または偶然、誤ったかもしれません接続が信頼できるゲートウェイからのものである場合、その矛盾が予想されます。それ以外の場合は、セキュリティフィルタをバイパスする非パブリックコンテンツを配信にサーバーをだまし、またはキャッシュを汚染する試みを示している可能性があります。メッセージのルーティングに関するセキュリティ上の考慮事項については、セクション9を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.6. Associating a Response to a Request",
      "section_title": true,
      "ja": "5.6。要求に対する応答の関連付け"
    },
    {
      "indent": 3,
      "text": "HTTP does not include a request identifier for associating a given request message with its corresponding one or more response messages. Hence, it relies on the order of response arrival to correspond exactly to the order in which requests are made on the same connection. More than one response message per request only occurs when one or more informational responses (1xx, see Section 6.2 of [RFC7231]) precede a final response to the same request.",
      "ja": "HTTPは、その対応する1つまたは複数の応答メッセージで指定された要求メッセージを関連付けるための要求識別子を含んでいません。したがって、要求が同じ接続で行われる順序に正確に対応する応答の到着の順序に依存しています。要求ごとに複数の応答メッセージは、一つ以上の情報応答（1XX、[RFC7231]のセクション6.2を参照）は、同じリクエストに対する最終応答に先行する場合に起こります。"
    },
    {
      "indent": 3,
      "text": "A client that has more than one outstanding request on a connection MUST maintain a list of outstanding requests in the order sent and MUST associate each received response message on that connection to the highest ordered request that has not yet received a final (non-1xx) response.",
      "ja": "持っている接続上に複数の未処理の要求が送られたために、未処理の要求のリストを維持しなければなりませんし、それぞれを関連付ける必要があり、クライアントはまだ、最終的な（非1xxの）を受信して​​いない最高の注文要求にその接続に応答メッセージを受信しました応答。"
    },
    {
      "indent": 0,
      "text": "5.7. Message Forwarding",
      "section_title": true,
      "ja": "5.7。メッセージ転送"
    },
    {
      "indent": 3,
      "text": "As described in Section 2.3, intermediaries can serve a variety of roles in the processing of HTTP requests and responses. Some intermediaries are used to improve performance or availability. Others are used for access control or to filter content. Since an HTTP stream has characteristics similar to a pipe-and-filter architecture, there are no inherent limits to the extent an intermediary can enhance (or interfere) with either direction of the stream.",
      "ja": "2.3節で述べたように、仲介者は、HTTPリクエストとレスポンスの処理中にさまざまな役割を果たすことができます。いくつかの仲介者は、パフォーマンスや可用性を向上させるために使用されています。その他には、アクセス制御に使用されているか、コンテンツをフィルタリングします。 HTTPストリームはパイプとフィルタアーキテクチャと同様の特性を有しているため、中間ストリームのいずれかの方向で強化（または妨害）することができる程度には固有の制限は存在しません。"
    },
    {
      "indent": 3,
      "text": "An intermediary not acting as a tunnel MUST implement the Connection header field, as specified in Section 6.1, and exclude fields from being forwarded that are only intended for the incoming connection.",
      "ja": "トンネルとして動作していない中間セクション6.1で指定されるように、接続ヘッダフィールドを実装し、そしてのみ着信接続のために意図されていることが転送されたフィールドを除外しなければなりません。"
    },
    {
      "indent": 3,
      "text": "An intermediary MUST NOT forward a message to itself unless it is protected from an infinite request loop. In general, an intermediary ought to recognize its own server names, including any aliases, local variations, or literal IP addresses, and respond to such requests directly.",
      "ja": "それは無限の要求ループから保護されていない限り、仲介者は、自分自身にメッセージを転送してはなりません。一般的には、仲介者は任意のエイリアス、ローカルバリエーション、またはリテラルIPアドレスを含む独自のサーバー名を、認識し、直接このような要求に応えるべきです。"
    },
    {
      "indent": 0,
      "text": "5.7.1. Via",
      "section_title": true,
      "ja": "5.7.1。経由"
    },
    {
      "indent": 3,
      "text": "The \"Via\" header field indicates the presence of intermediate protocols and recipients between the user agent and the server (on requests) or between the origin server and the client (on responses), similar to the \"Received\" header field in email (Section 3.6.7 of [RFC5322]). Via can be used for tracking message forwards, avoiding request loops, and identifying the protocol capabilities of senders along the request/response chain.",
      "ja": "「経由」ヘッダフィールドには、ユーザエージェントと（リクエストの）サーバーとの間の中間プロトコルと受信者の存在を示すか、オリジンサーバと電子メールで「受信」ヘッダフィールドに似た（回答の）クライアント、（節間[RFC5322]の3.6.7）。ビアは、転送メッセージを追跡要求ループを回避し、そして要求/応答チェーンに沿って送信者のプロトコル能力を識別するために使用することができます。"
    },
    {
      "indent": 5,
      "text": "Via = 1#( received-protocol RWS received-by [ RWS comment ] )",
      "ja": "= 1＃（受信により[RWSコメント]受信プロトコルRWS）を介して"
    },
    {
      "indent": 5,
      "text": "received-protocol = [ protocol-name \"/\" ] protocol-version ; see Section 6.7 received-by = ( uri-host [ \":\" port ] ) / pseudonym pseudonym = token",
      "ja": "受信プロトコル= [プロトコル名「/」]プロトコルバージョン。セクション6.7受信による=（URI-ホスト[ \"：\" ポート]）を参照/偽名偽名をトークン="
    },
    {
      "indent": 3,
      "text": "Multiple Via field values represent each proxy or gateway that has forwarded the message. Each intermediary appends its own information about how the message was received, such that the end result is ordered according to the sequence of forwarding recipients.",
      "ja": "フィールド値を介して複数のメッセージを転送した各プロキシまたはゲートウェイを表します。各仲介は、メッセージが最終的な結果は、受信者の転送の順序に従って順序付けされるように、受信された方法についての独自の情報を付加します。"
    },
    {
      "indent": 3,
      "text": "A proxy MUST send an appropriate Via header field, as described below, in each message that it forwards. An HTTP-to-HTTP gateway MUST send an appropriate Via header field in each inbound request message and MAY send a Via header field in forwarded response messages.",
      "ja": "以下に説明するように、プロキシは、その転送し、各メッセージに、ヘッダフィールドを介して適切なを送らなければなりません。 HTTPツーHTTPゲートウェイは、各着信要求メッセージのヘッダフィールドを介して適切なを送信しなければならなくて、転送された応答メッセージのViaヘッダフィールドを送ることができます。"
    },
    {
      "indent": 3,
      "text": "For each intermediary, the received-protocol indicates the protocol and protocol version used by the upstream sender of the message. Hence, the Via field value records the advertised protocol capabilities of the request/response chain such that they remain visible to downstream recipients; this can be useful for determining what backwards-incompatible features might be safe to use in response, or within a later request, as described in Section 2.6. For brevity, the protocol-name is omitted when the received protocol is HTTP.",
      "ja": "各中間のために、受信されたプロトコルは、メッセージの上流の送信者によって使用されるプロトコルとプロトコルバージョンを示します。したがって、Viaフィールドの値は、それらが下流の受信者に表示されたままにするように、要求/応答チェーンのアドバタイズプロトコル能力を記録します。これは後方互換性のない機能はセクション2.6で説明したように、応答では、以降の要求内で使用しても安全であるかもしれないかを決定するのに役立ちます。受信プロトコルがHTTPであるとき簡潔にするために、プロトコル名が省略されています。"
    },
    {
      "indent": 3,
      "text": "The received-by portion of the field value is normally the host and optional port number of a recipient server or client that subsequently forwarded the message. However, if the real host is considered to be sensitive information, a sender MAY replace it with a pseudonym. If a port is not provided, a recipient MAY interpret that as meaning it was received on the default TCP port, if any, for the received-protocol.",
      "ja": "受信して、フィールド値の部分は、通常、その後メッセージを転送先のサーバまたはクライアントのホストおよびオプションのポート番号です。本物のホストは機密情報であると考えられている場合は、送信者は仮名でそれを置き換えることができます。ポートが提供されていない場合があれば、受信者は、受信プロトコルのために、それはデフォルトのTCPポートで受信された意味とその解釈するかもしれません。"
    },
    {
      "indent": 3,
      "text": "A sender MAY generate comments in the Via header field to identify the software of each recipient, analogous to the User-Agent and Server header fields. However, all comments in the Via field are optional, and a recipient MAY remove them prior to forwarding the message.",
      "ja": "送信者は、ユーザエージェントとサーバのヘッダフィールドに類似し、各受信者のソフトウェアを識別するためにViaヘッダーフィールドにコメントを生成することがあります。しかし、Viaフィールド内のすべてのコメントはオプションであり、受信者は、彼らが前にメッセージを転送するために削除することができます。"
    },
    {
      "indent": 3,
      "text": "For example, a request message could be sent from an HTTP/1.0 user agent to an internal proxy code-named \"fred\", which uses HTTP/1.1 to forward the request to a public proxy at p.example.net, which completes the request by forwarding it to the origin server at www.example.com. The request received by www.example.com would then have the following Via header field:",
      "ja": "例えば、要求メッセージは、内部プロキシコードネーム「フレッド」、完了p.example.netで公衆プロキシに要求を転送するHTTP / 1.1を使用するHTTP / 1.0ユーザエージェントから送信することができますwww.example.comでオリジンサーバにそれを転送することによって要求します。 www.example.comで受信した要求は、次のViaヘッダーフィールドを持っているでしょう。"
    },
    {
      "indent": 5,
      "text": "Via: 1.0 fred, 1.1 p.example.net",
      "ja": "ビア：1.0平和、1.1 p.example.net"
    },
    {
      "indent": 3,
      "text": "An intermediary used as a portal through a network firewall SHOULD NOT forward the names and ports of hosts within the firewall region unless it is explicitly enabled to do so. If not enabled, such an intermediary SHOULD replace each received-by host of any host behind the firewall by an appropriate pseudonym for that host.",
      "ja": "明示的にそうするように有効にされていない限り、ネットワークファイアウォール経由のポータルとして使用する仲介者は、ファイアウォール領域内のホストの名前とポートを転送すべきではありません。有効でない場合は、そのような仲介者は、それぞれが受信して、ファイアウォールの背後にある任意のホストのホスト、そのホストのための適切なペンネームで置き換える必要があります。"
    },
    {
      "indent": 3,
      "text": "An intermediary MAY combine an ordered subsequence of Via header field entries into a single such entry if the entries have identical received-protocol values. For example,",
      "ja": "エントリは、同一の受信プロトコル値を有する場合、仲介は、単一のそのようなエントリにViaヘッダーフィールドエントリの順序付けられたシーケンスを組み合わせることができます。例えば、"
    },
    {
      "indent": 5,
      "text": "Via: 1.0 ricky, 1.1 ethel, 1.1 fred, 1.0 lucy",
      "ja": "ビア：1.0リッキー、1.1エセル、1.1フレッド、1.0ルーシー"
    },
    {
      "indent": 3,
      "text": "could be collapsed to",
      "ja": "に折りたたむことができ"
    },
    {
      "indent": 5,
      "text": "Via: 1.0 ricky, 1.1 mertz, 1.0 lucy",
      "ja": "ビア：1.0リッキー、1.1メルツ、1.0ルーシー"
    },
    {
      "indent": 3,
      "text": "A sender SHOULD NOT combine multiple entries unless they are all under the same organizational control and the hosts have already been replaced by pseudonyms. A sender MUST NOT combine entries that have different received-protocol values.",
      "ja": "彼らはすべて同じ組織の管理下にあり、ホストが既に偽名に置き換えられていない限り、送信者は、複数のエントリを結合すべきではありません。送信者は、別の受信プロトコル値を持つエントリを組み合わせてはなりません。"
    },
    {
      "indent": 0,
      "text": "5.7.2. Transformations",
      "section_title": true,
      "ja": "5.7.2。変換"
    },
    {
      "indent": 3,
      "text": "Some intermediaries include features for transforming messages and their payloads. A proxy might, for example, convert between image formats in order to save cache space or to reduce the amount of traffic on a slow link. However, operational problems might occur when these transformations are applied to payloads intended for critical applications, such as medical imaging or scientific data analysis, particularly when integrity checks or digital signatures are used to ensure that the payload received is identical to the original.",
      "ja": "いくつかの仲介は、メッセージとそのペイロードを変換するための機能が含まれています。プロキシは、例えば、キャッシュスペースを節約するか、低速リンク上のトラフィックの量を削減するために、画像フォーマット間の変換可能性があります。これらの変換は、整合性チェックまたはデジタル署名は、受信したペイロードは、元と同じであることを保証するために使用され、特に医用イメージング又は科学的データ解析、などの重要なアプリケーションのために意図ペイロードに適用した場合しかし、操作上の問題が発生する可能性があります。"
    },
    {
      "indent": 3,
      "text": "An HTTP-to-HTTP proxy is called a \"transforming proxy\" if it is designed or configured to modify messages in a semantically meaningful way (i.e., modifications, beyond those required by normal HTTP processing, that change the message in a way that would be significant to the original sender or potentially significant to downstream recipients). For example, a transforming proxy might be acting as a shared annotation server (modifying responses to include references to a local annotation database), a malware filter, a format transcoder, or a privacy filter. Such transformations are presumed to be desired by whichever client (or client organization) selected the proxy.",
      "ja": "意味的に意味のある方法、そのような方法でメッセージを変更する通常のHTTP処理で必要とされるものを超えて（すなわち、改変、でメッセージを修正するように設計または構成されている場合、HTTPツーHTTPプロキシは、「形質転換プロキシ」と呼ばれます。 ）元の送信者への重要なまたは下流の受信者に対して潜在的に重要です。例えば、変換プロキシは、マルウェアのフィルタ、フォーマットトランスコーダ、またはプライバシーフィルタ（ローカルアノテーションデータベースへの参照を含むように応答を変更する）共有注釈サーバとして機能するかもしれません。そのような変換は、いずれかのクライアント（またはクライアント組織）によって、所望のプロキシを選択すると推定されます。"
    },
    {
      "indent": 3,
      "text": "If a proxy receives a request-target with a host name that is not a fully qualified domain name, it MAY add its own domain to the host name it received when forwarding the request. A proxy MUST NOT change the host name if the request-target contains a fully qualified domain name.",
      "ja": "プロキシは完全修飾ドメイン名ではないホスト名と要求対象を受信した場合、その要求を転送するとき、それが受信したホスト名に独自のドメインを追加するかもしれません。リクエスト・ターゲットは完全修飾ドメイン名が含まれている場合、プロキシは、ホスト名を変更しないでください。"
    },
    {
      "indent": 3,
      "text": "A proxy MUST NOT modify the \"absolute-path\" and \"query\" parts of the received request-target when forwarding it to the next inbound server, except as noted above to replace an empty path with \"/\" or \"*\".",
      "ja": "次のインバウンドサーバにそれを転送するとき、プロキシは、「/」または「*」で空のパスを置き換えるために上述したよう除き、「絶対パス」と受信した要求対象の「クエリ」の部分を変更してはいけません。"
    },
    {
      "indent": 3,
      "text": "A proxy MAY modify the message body through application or removal of a transfer coding (Section 4).",
      "ja": "プロキシは、転送符号化（第4）の適用又は除去を通じてメッセージ本文を修正してもよいです。"
    },
    {
      "indent": 3,
      "text": "A proxy MUST NOT transform the payload (Section 3.3 of [RFC7231]) of a message that contains a no-transform cache-control directive (Section 5.2 of [RFC7234]).",
      "ja": "プロキシは、無変換キャッシュ制御指令（[RFC7234]のセクション5.2）を含むメッセージのペイロード（[RFC7231]のセクション3.3）を形質転換してはいけません。"
    },
    {
      "indent": 3,
      "text": "A proxy MAY transform the payload of a message that does not contain a no-transform cache-control directive. A proxy that transforms a payload MUST add a Warning header field with the warn-code of 214 (\"Transformation Applied\") if one is not already in the message (see Section 5.5 of [RFC7234]). A proxy that transforms the payload of a 200 (OK) response can further inform downstream recipients that a transformation has been applied by changing the response status code to 203 (Non-Authoritative Information) (Section 6.3.4 of [RFC7231]).",
      "ja": "プロキシは、無変換キャッシュ制御ディレクティブが含まれていないメッセージのペイロードを変換することができます。一つのメッセージになっていない場合、ペイロードを変換プロキシは214（「形質転換応用」）の警告コードと警告ヘッダフィールドを追加しなければならない（[RFC7234]のセクション5.5を参照）。 200（OK）応答のペイロードを変換プロキシは、さらに、変換が203に応答ステータスコード（非信頼できる情報）（[RFC7231]のセクション6.3.4）を変化させることにより適用されていることを、下流の受信者に通知することができます。"
    },
    {
      "indent": 3,
      "text": "A proxy SHOULD NOT modify header fields that provide information about the endpoints of the communication chain, the resource state, or the selected representation (other than the payload) unless the field's definition specifically allows such modification or the modification is deemed necessary for privacy or security.",
      "ja": "フィールドの定義は、特にそのような改変を可能にするか、変更がプライバシーやセキュリティのために必要と判断されない限り、プロキシは、通信チェーン、リソースの状態、または（ペイロード以外の）選択された表現のエンドポイントに関する情報を提供するヘッダーフィールドを変更しないでください。"
    },
    {
      "indent": 0,
      "text": "6. Connection Management",
      "section_title": true,
      "ja": "6.接続の管理"
    },
    {
      "indent": 3,
      "text": "HTTP messaging is independent of the underlying transport- or session-layer connection protocol(s). HTTP only presumes a reliable transport with in-order delivery of requests and the corresponding in-order delivery of responses. The mapping of HTTP request and response structures onto the data units of an underlying transport protocol is outside the scope of this specification.",
      "ja": "HTTPメッセージは、基礎となるtransport-またはセッション・レイヤ接続プロトコル（単数または複数）とは無関係です。 HTTPはリクエストの順序どおりの配信とレスポンスの対応で順次配信して信頼性の高い輸送を前提としています。基礎となるトランスポートプロトコルのデータユニットへのHTTPリクエストとレスポンス構造のマッピングは、本明細書の範囲外です。"
    },
    {
      "indent": 3,
      "text": "As described in Section 5.2, the specific connection protocols to be used for an HTTP interaction are determined by client configuration and the target URI. For example, the \"http\" URI scheme (Section 2.7.1) indicates a default connection of TCP over IP, with a default TCP port of 80, but the client might be configured to use a proxy via some other connection, port, or protocol.",
      "ja": "5.2節で説明したように、HTTPの相互作用のために使用される特定の接続プロトコルは、クライアントの設定とターゲットURIによって決定されます。たとえば、「HTTP」URIスキーム（2.7.1）は、80のデフォルトのTCPポートで、IP上のTCPのデフォルトの接続を示しますが、クライアントには、いくつかの他の接続を介してプロキシを使用するように設定される可能性があります、ポート、またはプロトコル。"
    },
    {
      "indent": 3,
      "text": "HTTP implementations are expected to engage in connection management, which includes maintaining the state of current connections, establishing a new connection or reusing an existing connection, processing messages received on a connection, detecting connection failures, and closing each connection. Most clients maintain multiple connections in parallel, including more than one connection per server endpoint. Most servers are designed to maintain thousands of concurrent connections, while controlling request queues to enable fair use and detect denial-of-service attacks.",
      "ja": "HTTP実装は、現在の接続の状態を維持する新たな接続を確立するか、または既存の接続を再利用する、メッセージは接続上で受信処理し、接続の失敗を検出し、各接続を閉じる含む、接続管理に従事することが期待されます。ほとんどのクライアントは、サーバーのエンドポイントごとに複数の接続を含む並行して複数の接続を維持します。公正使用を有効にし、サービス拒否（DoS）攻撃を検出するために要求キューを制御しながら、ほとんどのサーバーは、同時接続の数千人を維持するように設計されています。"
    },
    {
      "indent": 0,
      "text": "6.1. Connection",
      "section_title": true,
      "ja": "6.1。接続"
    },
    {
      "indent": 3,
      "text": "The \"Connection\" header field allows the sender to indicate desired control options for the current connection. In order to avoid confusing downstream recipients, a proxy or gateway MUST remove or replace any received connection options before forwarding the message.",
      "ja": "「接続」ヘッダフィールドは、送信者が、現在の接続のための所望の制御オプションを示すことができます。混乱下流受信者を回避するために、プロキシまたはゲートウェイがすべてのメッセージを転送する前に、接続オプションを受け取っを除去または交換しなければなりません。"
    },
    {
      "indent": 3,
      "text": "When a header field aside from Connection is used to supply control information for or about the current connection, the sender MUST list the corresponding field-name within the Connection header field. A proxy or gateway MUST parse a received Connection header field before a message is forwarded and, for each connection-option in this field, remove any header field(s) from the message with the same name as the connection-option, and then remove the Connection header field itself (or replace it with the intermediary's own connection options for the forwarded message).",
      "ja": "接続は別にヘッダフィールドは、現在の接続のため、又は約制御情報を供給するために使用される場合、送信側は接続ヘッダフィールド内の対応するフィールド名を一覧表示しなければなりません。プロキシまたはゲートウェイは、メッセージが転送される前に、受信した接続ヘッダフィールドを解析して、このフィールドの各接続オプションで、接続オプションと同じ名前を持つメッセージから任意のヘッダフィールド（複数可）を削除し、削除しなければなりませんConnectionヘッダフィールド自体（または転送メッセージのための仲介者自身の接続オプションと交換してください）。"
    },
    {
      "indent": 3,
      "text": "Hence, the Connection header field provides a declarative way of distinguishing header fields that are only intended for the immediate recipient (\"hop-by-hop\") from those fields that are intended for all recipients on the chain (\"end-to-end\"), enabling the message to be self-descriptive and allowing future connection-specific extensions to be deployed without fear that they will be blindly forwarded by older intermediaries.",
      "ja": "したがって、接続ヘッダフィールドは、チェーン上のすべての受信者のために意図されているこれらのフィールドからの即時受信者（「ホップバイホップ」）（「エンドツーエンドのために意図された区別ヘッダフィールドの宣言的な方法を提供します「）、自己記述するメッセージを可能にし、将来の接続固有の拡張機能は、彼らが盲目的に年上の仲介によって転送されることを恐れずに展開されることを可能にします。"
    },
    {
      "indent": 3,
      "text": "The Connection header field's value has the following grammar:",
      "ja": "Connectionヘッダフィールドの値は、次の文法を持っています："
    },
    {
      "indent": 5,
      "text": "Connection = 1#connection-option connection-option = token",
      "ja": "= 1＃の接続オプション接続オプションの接続=トークン"
    },
    {
      "indent": 3,
      "text": "Connection options are case-insensitive.",
      "ja": "接続オプションは、大文字と小文字を区別しません。"
    },
    {
      "indent": 3,
      "text": "A sender MUST NOT send a connection option corresponding to a header field that is intended for all recipients of the payload. For example, Cache-Control is never appropriate as a connection option (Section 5.2 of [RFC7234]).",
      "ja": "送信者は、ペイロードのすべての受信者を対象としたヘッダフィールドに対応する接続​​オプションを送ってはいけません。例えば、キャッシュ・コントロールは、接続オプション（[RFC7234]のセクション5.2）のような適切なことはありません。"
    },
    {
      "indent": 3,
      "text": "The connection options do not always correspond to a header field present in the message, since a connection-specific header field might not be needed if there are no parameters associated with a connection option. In contrast, a connection-specific header field that is received without a corresponding connection option usually indicates that the field has been improperly forwarded by an intermediary and ought to be ignored by the recipient.",
      "ja": "接続オプションは、常に、接続固有のヘッダフィールドは、接続オプションに関連付けられたパラメータが存在しない場合に必要とされないかもしれないので、メッセージ内に存在するヘッダフィールドに対応しません。対照的に、対応する接続​​オプションなしで受信された接続固有のヘッダフィールドは、通常、フィールドが不適切仲介によって転送され、受信者によって無視されるべきであることを示しています。"
    },
    {
      "indent": 3,
      "text": "When defining new connection options, specification authors ought to survey existing header field names and ensure that the new connection option does not share the same name as an already deployed header field. Defining a new connection option essentially reserves that potential field-name for carrying additional information related to the connection option, since it would be unwise for senders to use that field-name for anything else.",
      "ja": "新しい接続オプションを定義する場合、仕様作成者は、既存のヘッダーフィールド名を調査し、新しい接続オプションは、すでに展開されたヘッダフィールドと同じ名前を共有していないことを確認するべきです。送信者は、他の何かのためにそのフィールド名を使用することは賢明ではありませんので、新しい接続オプションを定義することは、本質的に、接続オプションに関連する追加情報を運ぶためにその潜在的なフィールド名を留保します。"
    },
    {
      "indent": 3,
      "text": "The \"close\" connection option is defined for a sender to signal that this connection will be closed after completion of the response. For example,",
      "ja": "送信者は、この接続は応答が完了した後に閉鎖されることを知らせるためには、「クローズ」接続オプションが定義されています。例えば、"
    },
    {
      "indent": 5,
      "text": "Connection: close",
      "ja": "接続：近いです"
    },
    {
      "indent": 3,
      "text": "in either the request or the response header fields indicates that the sender is going to close the connection after the current request/response is complete (Section 6.6).",
      "ja": "要求又は応答ヘッダフィールドのいずれかに現在の要求/応答（セクション6.6）が完了した後、送信者は、接続をクローズしようとしていることを示しています。"
    },
    {
      "indent": 3,
      "text": "A client that does not support persistent connections MUST send the \"close\" connection option in every request message.",
      "ja": "持続的な接続をサポートしていないクライアントは、すべての要求メッセージ中の「クローズ」接続オプションを送らなければなりません。"
    },
    {
      "indent": 3,
      "text": "A server that does not support persistent connections MUST send the \"close\" connection option in every response message that does not have a 1xx (Informational) status code.",
      "ja": "持続的な接続をサポートしていないサーバは1xxの（情報）ステータスコードを持っていないすべての応答メッセージで「クローズ」接続オプションを送らなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.2. Establishment",
      "section_title": true,
      "ja": "6.2。確立"
    },
    {
      "indent": 3,
      "text": "It is beyond the scope of this specification to describe how connections are established via various transport- or session-layer protocols. Each connection applies to only one transport link.",
      "ja": "これは、接続が様々なtransport-またはセッション層プロトコルを介して確立されている方法を説明するために、この仕様の範囲を超えています。各接続は、唯一のトランスポートリンクに適用されます。"
    },
    {
      "indent": 0,
      "text": "6.3. Persistence",
      "section_title": true,
      "ja": "6.3。固執"
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 defaults to the use of \"persistent connections\", allowing multiple requests and responses to be carried over a single connection. The \"close\" connection option is used to signal that a connection will not persist after the current request/response. HTTP implementations SHOULD support persistent connections.",
      "ja": "複数の要求と応答は、単一の接続を介して実行することができるようにするHTTP /「持続的な接続」の使用に1.1デフォルトで、。 「クローズ」接続オプションは、接続が現在のリクエスト/レスポンスの後に持続しないことを知らせるために使用されています。 HTTP実装は、持続的な接続をサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "A recipient determines whether a connection is persistent or not based on the most recently received message's protocol version and Connection header field (if any):",
      "ja": "受信者は、接続が（もしあれば）最も最近受信したメッセージのプロトコルバージョンと接続ヘッダフィールドに基づいて、永続的であるか否かを判定する。"
    },
    {
      "indent": 3,
      "text": "o If the \"close\" connection option is present, the connection will not persist after the current response; else,",
      "ja": "「クローズ」接続オプションが存在する場合は、O、接続は電流応答の後に保持されません。他に、"
    },
    {
      "indent": 3,
      "text": "o If the received protocol is HTTP/1.1 (or later), the connection will persist after the current response; else,",
      "ja": "受信プロトコルは、HTTP / 1.1（またはそれ以降）の場合、O、接続は、電流応答の後に持続します。他に、"
    },
    {
      "indent": 3,
      "text": "o If the received protocol is HTTP/1.0, the \"keep-alive\" connection option is present, the recipient is not a proxy, and the recipient wishes to honor the HTTP/1.0 \"keep-alive\" mechanism, the connection will persist after the current response; otherwise,",
      "ja": "O受信プロトコルはHTTP / 1.0の場合は、「キープアライブ」接続オプションが存在している、受信者はプロキシではなく、受信者はHTTP / 1.0「キープアライブ」メカニズムを尊重したい、接続が後も持続します電流応答;そうでなければ、"
    },
    {
      "indent": 3,
      "text": "o The connection will close after the current response.",
      "ja": "O接続は、電流応答の後に終了します。"
    },
    {
      "indent": 3,
      "text": "A client MAY send additional requests on a persistent connection until it sends or receives a \"close\" connection option or receives an HTTP/1.0 response without a \"keep-alive\" connection option.",
      "ja": "それが送信または「クローズ」接続オプションを受信するか、または「キープアライブ」接続オプションを指定せずにHTTP / 1.0応答を受信するまで、クライアントは永続的な接続で追加の要求を送信することができます。"
    },
    {
      "indent": 3,
      "text": "In order to remain persistent, all messages on a connection need to have a self-defined message length (i.e., one not defined by closure of the connection), as described in Section 3.3. A server MUST read the entire request message body or close the connection after sending its response, since otherwise the remaining data on a persistent connection would be misinterpreted as the next request. Likewise, a client MUST read the entire response message body if it intends to reuse the same connection for a subsequent request.",
      "ja": "セクション3.3で説明したように、永続的維持するために、接続上のすべてのメッセージは、（すなわち、一つの接続の閉鎖によって定義されていない）の自己定義されたメッセージの長さを有する必要があります。サーバは、要求全体のメッセージ本文を読んだり、そうでなければ永続的な接続に残っているデータは、次の要求として誤って解釈されるので、その応答を送信した後、接続を閉じる必要があります。それは後続の要求に同じ接続を再利用しようとする場合同様に、クライアントは、全体の応答メッセージ本文を読まなければなりません。"
    },
    {
      "indent": 3,
      "text": "A proxy server MUST NOT maintain a persistent connection with an HTTP/1.0 client (see Section 19.7.1 of [RFC2068] for information and discussion of the problems with the Keep-Alive header field implemented by many HTTP/1.0 clients).",
      "ja": "プロキシサーバは、HTTP / 1.0クライアントとの永続的な接続を（多くのHTTP / 1.0クライアントによって実装キープアライブヘッダフィールドでの問題の情報と議論のための[RFC2068]のセクション19.7.1を参照）を維持してはなりません。"
    },
    {
      "indent": 3,
      "text": "See Appendix A.1.2 for more information on backwards compatibility with HTTP/1.0 clients.",
      "ja": "HTTP / 1.0クライアントとの後方互換性の詳細については、付録A.1.2を参照してください。"
    },
    {
      "indent": 0,
      "text": "6.3.1. Retrying Requests",
      "section_title": true,
      "ja": "6.3.1。再試行のリクエスト"
    },
    {
      "indent": 3,
      "text": "Connections can be closed at any time, with or without intention. Implementations ought to anticipate the need to recover from asynchronous close events.",
      "ja": "接続して、または意図せずに、いつでも閉じることができます。実装は、非同期クローズイベントから回復する必要性を予測するべきです。"
    },
    {
      "indent": 3,
      "text": "When an inbound connection is closed prematurely, a client MAY open a new connection and automatically retransmit an aborted sequence of requests if all of those requests have idempotent methods (Section 4.2.2 of [RFC7231]). A proxy MUST NOT automatically retry non-idempotent requests.",
      "ja": "インバウンド接続が早まってクローズされた場合、クライアントは新しい接続を開くことができ、自動的にそれらのすべての要求は、メソッド（[RFC7231]のセクション4.2.2）を冪等した場合の要求の中止されましシーケンスを再送信します。プロキシは自動的に非べき等の要求を再試行してはなりません。"
    },
    {
      "indent": 3,
      "text": "A user agent MUST NOT automatically retry a request with a non-idempotent method unless it has some means to know that the request semantics are actually idempotent, regardless of the method, or some means to detect that the original request was never applied. For example, a user agent that knows (through design or configuration) that a POST request to a given resource is safe can repeat that request automatically. Likewise, a user agent designed specifically to operate on a version control repository might be able to recover from partial failure conditions by checking the target resource revision(s) after a failed connection, reverting or fixing any changes that were partially applied, and then automatically retrying the requests that failed.",
      "ja": "それは関係なく、法の要求のセマンティクスが実際に冪等であることを知っているいくつかの手段、または元の要求が適用されなかったことを検出するためのいくつかの手段を持っていない限り、ユーザエージェントは自動的に非冪等の方法で要求を再試行してはなりません。たとえば、特定のリソースへのPOSTリクエストが安全であることを（デザインや構成によって）知っているユーザエージェントは自動的にその要求を繰り返すことができます。同様に、ユーザエージェントは自動的に、その後、接続の失敗後に対象リソースのリビジョン（複数可）をチェック復帰または部分的に適用された変更を固定することにより、部分的な障害状態から回復することができるかもしれないバージョン管理リポジトリ上で動作するように特別に設計され、そして再試行失敗した要求。"
    },
    {
      "indent": 3,
      "text": "A client SHOULD NOT automatically retry a failed automatic retry.",
      "ja": "クライアントは自動的に失敗した自動再試行を再試行すべきではありません。"
    },
    {
      "indent": 0,
      "text": "6.3.2. Pipelining",
      "section_title": true,
      "ja": "6.3.2。パイプライン"
    },
    {
      "indent": 3,
      "text": "A client that supports persistent connections MAY \"pipeline\" its requests (i.e., send multiple requests without waiting for each response). A server MAY process a sequence of pipelined requests in parallel if they all have safe methods (Section 4.2.1 of [RFC7231]), but it MUST send the corresponding responses in the same order that the requests were received.",
      "ja": "持続的接続をサポートするクライアントは、「パイプライン」の要求が（すなわち、各応答を待たずに複数のリクエストを送信）するかもしれません。彼らはすべて安全な方法（[RFC7231]のセクション4.2.1）を持っている場合、サーバーは並列にパイプライン化要求のシーケンスを処理することができるが、それは要求が受け取られたのと同じ順序に対応する応答を送らなければなりません。"
    },
    {
      "indent": 3,
      "text": "A client that pipelines requests SHOULD retry unanswered requests if the connection closes before it receives all of the corresponding responses. When retrying pipelined requests after a failed connection (a connection not explicitly closed by the server in its last complete response), a client MUST NOT pipeline immediately after connection establishment, since the first remaining request in the prior pipeline might have caused an error response that can be lost again if multiple requests are sent on a prematurely closed connection (see the TCP reset problem described in Section 6.6).",
      "ja": "それは、対応するすべての応答を受信する前に、接続が閉じた場合のパイプライン要求が未回答の要求を再試行すべきであるクライアント。再試行が失敗した接続（明示的に最後の完全な応答でサーバーによって閉じられていない接続）の後にリクエストをパイプライン化すると、クライアントはすぐに接続確立後のパイプラインはならず、前パイプラインの最初の残りの要求は、そのエラー応答を引き起こしている場合がありますので、複数のリクエストが途中で閉じられた接続上で送信された場合、再び失われる可能性があります（6.6節で説明したTCPリセットの問題を参照してください）。"
    },
    {
      "indent": 3,
      "text": "Idempotent methods (Section 4.2.2 of [RFC7231]) are significant to pipelining because they can be automatically retried after a connection failure. A user agent SHOULD NOT pipeline requests after a non-idempotent method, until the final response status code for that method has been received, unless the user agent has a means to detect and recover from partial failure conditions involving the pipelined sequence.",
      "ja": "それらは自動的に接続に失敗した後に再試行することができるので、冪等の方法（[RFC7231]のセクション4.2.2）は、パイプラインに重要です。ユーザエージェントは、検出およびパイプライン化シーケンスを含む部分的な障害状態から回復する手段を持っていない限り、その方法のための最終的なレスポンスステータスコードが、受信されるまで、ユーザエージェントは、非冪等の方法の後にパイプライン要求はなりません。"
    },
    {
      "indent": 3,
      "text": "An intermediary that receives pipelined requests MAY pipeline those requests when forwarding them inbound, since it can rely on the outbound user agent(s) to determine what requests can be safely pipelined. If the inbound connection fails before receiving a response, the pipelining intermediary MAY attempt to retry a sequence of requests that have yet to receive a response if the requests all have idempotent methods; otherwise, the pipelining intermediary SHOULD forward any received responses and then close the corresponding outbound connection(s) so that the outbound user agent(s) can recover accordingly.",
      "ja": "パイプラインにはリクエストが安全にパイプライン化することができるかを決定するために、発信ユーザエージェント（複数可）に頼ることができるので、インバウンドそれらを転送し、これらの要求をMAYパイプライン化要求を受け取る仲介。インバウンド接続が応答を受信する前に失敗した場合、パイプラインの仲介を要求すべてが冪等のメソッドを持っている場合は、応答を受け取るためには至っていない要求のシーケンスを再試行してもよい（MAY）。そうでない場合は、パイプラインの中間には、任意の受信した応答を転送した後、アウトバウンド・ユーザエージェント（単数または複数）に応じて回復できるように、対応するアウトバウンド接続（単数または複数）を閉じてください。"
    },
    {
      "indent": 0,
      "text": "6.4. Concurrency",
      "section_title": true,
      "ja": "6.4。同時実行"
    },
    {
      "indent": 3,
      "text": "A client ought to limit the number of simultaneous open connections that it maintains to a given server.",
      "ja": "クライアントは、それが特定のサーバーに維持同時オープン接続の数を制限するべきです。"
    },
    {
      "indent": 3,
      "text": "Previous revisions of HTTP gave a specific number of connections as a ceiling, but this was found to be impractical for many applications. As a result, this specification does not mandate a particular maximum number of connections but, instead, encourages clients to be conservative when opening multiple connections.",
      "ja": "HTTPの以前のリビジョンは、天井などの接続の特定の数を与えたが、これは、多くのアプリケーションのために非現実的であることが判明しました。結果として、本明細書は接続の特定の最大数を強制しないが、代わりに、複数の接続を開くときに保守的にクライアントを奨励します。"
    },
    {
      "indent": 3,
      "text": "Multiple connections are typically used to avoid the \"head-of-line blocking\" problem, wherein a request that takes significant server-side processing and/or has a large payload blocks subsequent requests on the same connection. However, each connection consumes server resources. Furthermore, using multiple connections can cause undesirable side effects in congested networks.",
      "ja": "複数の接続は、典型的には、「ヘッドオブラインブロッキング」の問題を回避するために使用される重要サーバー側の処理を取り、および/または大きなペイロードブロック同じ接続上で後続の要求を有している要求。しかし、各接続は、サーバーのリソースを消費します。さらに、複数の接続を使用すると、混雑したネットワークでの望ましくない副作用を引き起こす可能性があります。"
    },
    {
      "indent": 3,
      "text": "Note that a server might reject traffic that it deems abusive or characteristic of a denial-of-service attack, such as an excessive number of open connections from a single client.",
      "ja": "サーバはそれが虐待や、単一のクライアントからのオープン接続の数が多すぎるなどのサービス拒否攻撃の特性をと考えるトラフィックを拒否するかもしれないことに注意してください。"
    },
    {
      "indent": 0,
      "text": "6.5. Failures and Timeouts",
      "section_title": true,
      "ja": "6.5。失敗とタイムアウト"
    },
    {
      "indent": 3,
      "text": "Servers will usually have some timeout value beyond which they will no longer maintain an inactive connection. Proxy servers might make this a higher value since it is likely that the client will be making more connections through the same proxy server. The use of persistent connections places no requirements on the length (or existence) of this timeout for either the client or the server.",
      "ja": "サーバは通常、彼らはもはや非アクティブな接続を維持しますこれを超えるいくつかのタイムアウト値を持つことになります。クライアントが同じプロキシサーバーを介して複数の接続を行うされる可能性があるため、プロキシサーバーは、この高い値になるかもしれません。持続的な接続を使用するには、クライアントまたはサーバーのいずれかのためにこのタイムアウトの長さ（または存在）に何の要件を置きません。"
    },
    {
      "indent": 3,
      "text": "A client or server that wishes to time out SHOULD issue a graceful close on the connection. Implementations SHOULD constantly monitor open connections for a received closure signal and respond to it as appropriate, since prompt closure of both sides of a connection enables allocated system resources to be reclaimed.",
      "ja": "タイムアウトを希望するクライアントまたはサーバは、接続上の優雅なクローズを発行する必要があります。実装は、常に受信閉鎖信号のオープン接続を監視し、接続の両側の迅速な閉鎖を再利用するために割り当てられたシステムリソースを有効にするので、必要に応じてそれに応答するべきです。"
    },
    {
      "indent": 3,
      "text": "A client, server, or proxy MAY close the transport connection at any time. For example, a client might have started to send a new request at the same time that the server has decided to close the \"idle\" connection. From the server's point of view, the connection is being closed while it was idle, but from the client's point of view, a request is in progress.",
      "ja": "クライアント、サーバ、またはプロキシは、いつでも輸送接続を終えるかもしれません。例えば、クライアントは、サーバーが「アイドル」の接続をクローズすることを決定したと同時に、新しいリクエストを送信し始めているかもしれません。それがアイドル状態であったサーバの観点からは、接続が閉じられているが、クライアントの観点から、要求が進行中です。"
    },
    {
      "indent": 3,
      "text": "A server SHOULD sustain persistent connections, when possible, and allow the underlying transport's flow-control mechanisms to resolve temporary overloads, rather than terminate connections with the expectation that clients will retry. The latter technique can exacerbate network congestion.",
      "ja": "サーバは、可能な場合、持続的な接続を維持し、基礎となるトランスポートのフロー制御メカニズムは、一時的な過負荷を解決するのではなく、クライアントが再試行することを期待して接続を終了できるようにする必要があります。後者の技術は、ネットワークの輻輳を悪化させることができます。"
    },
    {
      "indent": 3,
      "text": "A client sending a message body SHOULD monitor the network connection for an error response while it is transmitting the request. If the client sees a response that indicates the server does not wish to receive the message body and is closing the connection, the client SHOULD immediately cease transmitting the body and close its side of the connection.",
      "ja": "それは、要求を送信している間、メッセージ本文を送信するクライアントは、エラー応答のためのネットワーク接続を監視する必要があります。クライアントは、サーバがメッセージ本文を受信したくないことを示し、接続を閉じているレスポンスを見ている場合、クライアントはすぐに身体を送信中止し、接続のその側面を閉じる必要があります。"
    },
    {
      "indent": 0,
      "text": "6.6. Tear-down",
      "section_title": true,
      "ja": "6.6。取り壊す"
    },
    {
      "indent": 3,
      "text": "The Connection header field (Section 6.1) provides a \"close\" connection option that a sender SHOULD send when it wishes to close the connection after the current request/response pair.",
      "ja": "接続ヘッダフィールド（セクション6.1）は、現在の要求/応答のペアの後に接続をクローズしたい場合、送信者が送信する必要がある「クローズ」接続オプションを提供します。"
    },
    {
      "indent": 3,
      "text": "A client that sends a \"close\" connection option MUST NOT send further requests on that connection (after the one containing \"close\") and MUST close the connection after reading the final response message corresponding to this request.",
      "ja": "（「クローズ」を含む1の後に）その接続で更なる要求を送ってはいけません「クローズ」接続オプションを送信し、この要求に対応する最終応答メッセージを読んだ後、接続を閉じる必要がありますクライアント。"
    },
    {
      "indent": 3,
      "text": "A server that receives a \"close\" connection option MUST initiate a close of the connection (see below) after it sends the final response to the request that contained \"close\". The server SHOULD send a \"close\" connection option in its final response on that connection. The server MUST NOT process any further requests received on that connection.",
      "ja": "それは、「クローズ」に含まれるリクエストに対する最終応答を送信した後、接続のクローズを開始しなければならない「クローズ」接続オプションを受信したサーバは、（下記参照します）。サーバーは、その接続での最終的な応答で「クローズ」接続オプションを送るべきです。サーバーは、その接続で受信したすべての更なる要求を処理してはいけません。"
    },
    {
      "indent": 3,
      "text": "A server that sends a \"close\" connection option MUST initiate a close of the connection (see below) after it sends the response containing \"close\". The server MUST NOT process any further requests received on that connection.",
      "ja": "それは「近い」含む応答を送信した後、「クローズ」接続オプションを送信し、サーバは、（下記参照）接続のクローズを開始しなければなりません。サーバーは、その接続で受信したすべての更なる要求を処理してはいけません。"
    },
    {
      "indent": 3,
      "text": "A client that receives a \"close\" connection option MUST cease sending requests on that connection and close the connection after reading the response message containing the \"close\"; if additional pipelined requests had been sent on the connection, the client SHOULD NOT assume that they will be processed by the server.",
      "ja": "「クローズ」接続オプションを受け取るクライアントは、その接続でリクエストを送信を中止し、「クローズ」を含む応答メッセージを読んだ後、接続を閉じる必要があります。追加のパイプライン化の要求が接続で送信された場合、クライアントは、サーバーによって処理されることを仮定するべきではありません。"
    },
    {
      "indent": 3,
      "text": "If a server performs an immediate close of a TCP connection, there is a significant risk that the client will not be able to read the last HTTP response. If the server receives additional data from the client on a fully closed connection, such as another request that was sent by the client before receiving the server's response, the server's TCP stack will send a reset packet to the client; unfortunately, the reset packet might erase the client's unacknowledged input buffers before they can be read and interpreted by the client's HTTP parser.",
      "ja": "サーバーは、TCPコネクションの即時クローズを実行する場合、クライアントは最後のHTTPレスポンスを読み取ることができなくなります重大なリスクがあります。サーバーは、サーバーの応答を受信する前に、クライアントによって送信された別の要求として完全に閉じられた接続上のクライアントからの追加データを、受信した場合、サーバのTCPスタックはクライアントにリセットパケットを送信します。彼らは読んで、クライアントのHTTPパーサによって解釈される前に、残念ながら、リセットパケットは、クライアントの未確認の入力バッファを消去することがあります。"
    },
    {
      "indent": 3,
      "text": "To avoid the TCP reset problem, servers typically close a connection in stages. First, the server performs a half-close by closing only the write side of the read/write connection. The server then continues to read from the connection until it receives a corresponding close by the client, or until the server is reasonably certain that its own TCP stack has received the client's acknowledgement of the packet(s) containing the server's last response. Finally, the server fully closes the connection.",
      "ja": "TCPリセット問題を回避するために、サーバーは通常の段階で接続を閉じます。まず、サーバは、読み出し/書き込み接続の唯一の書き込み側を閉じることにより、ハーフクローズを行います。その後、サーバーは、クライアントによって、対応するクローズを受信するまで、接続からの読み出しを続け、またはサーバーには、独自のTCPスタックは、サーバの最後の応答を含むパケット（複数可）のクライアントの確認応答を受信したことを合理的に一定になるまで。最後に、サーバーが完全に接続を閉じます。"
    },
    {
      "indent": 3,
      "text": "It is unknown whether the reset problem is exclusive to TCP or might also be found in other transport connection protocols.",
      "ja": "リセットの問題はTCPに排他的であるか、また、他のトランスポートの接続プロトコルに見つかる可能性があるかどうかは不明です。"
    },
    {
      "indent": 0,
      "text": "6.7. Upgrade",
      "section_title": true,
      "ja": "6.7。アップグレード"
    },
    {
      "indent": 3,
      "text": "The \"Upgrade\" header field is intended to provide a simple mechanism for transitioning from HTTP/1.1 to some other protocol on the same connection. A client MAY send a list of protocols in the Upgrade header field of a request to invite the server to switch to one or more of those protocols, in order of descending preference, before sending the final response. A server MAY ignore a received Upgrade header field if it wishes to continue using the current protocol on that connection. Upgrade cannot be used to insist on a protocol change.",
      "ja": "フィールドが同じ接続上でいくつかの他のプロトコルにHTTP / 1.1から移行するための単純なメカニズムを提供することが意図されているヘッダを「アップグレード」。クライアントは、最終的な応答を送信する前に、優先の高い順に、それらのプロトコルの一つ以上に切り替えるサーバーを招待するための要求のアップグレードヘッダフィールドにプロトコルのリストを送信することができます。それは接続の現在のプロトコルを使用し続けることを望む場合、サーバは、受信したアップグレードヘッダーフィールドを無視してもよいです。アップグレードは、プロトコルの変更を主張するために使用することはできません。"
    },
    {
      "indent": 5,
      "text": "Upgrade = 1#protocol",
      "ja": "= 1＃プロトコルをアップグレード"
    },
    {
      "indent": 5,
      "text": "protocol = protocol-name [\"/\" protocol-version] protocol-name = token protocol-version = token",
      "ja": "プロトコル=プロトコル名[「/」プロトコルバージョン]プロトコル名=トークンプロトコルバージョン=トークン"
    },
    {
      "indent": 3,
      "text": "A server that sends a 101 (Switching Protocols) response MUST send an Upgrade header field to indicate the new protocol(s) to which the connection is being switched; if multiple protocol layers are being switched, the sender MUST list the protocols in layer-ascending order. A server MUST NOT switch to a protocol that was not indicated by the client in the corresponding request's Upgrade header field. A server MAY choose to ignore the order of preference indicated by the client and select the new protocol(s) based on other factors, such as the nature of the request or the current load on the server.",
      "ja": "アップグレードヘッダフィールドを送らなければなりません101（スイッチングプロトコル）応答を送信するサーバは、接続が切り替えされた新たなプロトコル（単数または複数）を示すために、複数のプロトコル層が切り替えられている場合、送信者は層昇順にプロトコルをリストする必要があります。サーバーは、対応する要求のUpgradeヘッダフィールドに、クライアントによって示されていなかったプロトコルに切り替えてはなりません。サーバは、クライアントによって示される優先順位を無視し、そのような要求またはサーバの現在の負荷の性質などの他の要因に基づいて新たなプロトコル（単数または複数）を選択するために選ぶかもしれ。"
    },
    {
      "indent": 3,
      "text": "A server that sends a 426 (Upgrade Required) response MUST send an Upgrade header field to indicate the acceptable protocols, in order of descending preference.",
      "ja": "好みの高い順に、許容されるプロトコルを示すためUpgradeヘッダフィールドを送らなければなりません応答（必須アップグレード）426を送信するサーバ。"
    },
    {
      "indent": 3,
      "text": "A server MAY send an Upgrade header field in any other response to advertise that it implements support for upgrading to the listed protocols, in order of descending preference, when appropriate for a future request.",
      "ja": "サーバは、適切な場合、将来の要求に対して、優先の高い順に、それは、列挙されたプロトコルにアップグレードするためのサポートを実装することをアドバタイズするために、他の応答にアップグレードヘッダーフィールドを送信することができます。"
    },
    {
      "indent": 3,
      "text": "The following is a hypothetical example sent by a client:",
      "ja": "以下は、クライアントから送信された仮想的な例です。"
    },
    {
      "indent": 5,
      "text": "GET /hello.txt HTTP/1.1 Host: www.example.com Connection: upgrade Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11",
      "ja": "GET /hello.txt HTTP / 1.1ホスト：www.example.com接続：アップグレードアップグレード：HTTP / 2.0、SHTTP / 1.3、IRC / 6.9、RTAは/ X11"
    },
    {
      "indent": 3,
      "text": "The capabilities and nature of the application-level communication after the protocol change is entirely dependent upon the new protocol(s) chosen. However, immediately after sending the 101 (Switching Protocols) response, the server is expected to continue responding to the original request as if it had received its equivalent within the new protocol (i.e., the server still has an outstanding request to satisfy after the protocol has been changed, and is expected to do so without requiring the request to be repeated).",
      "ja": "プロトコル変更後のアプリケーションレベルの通信の能力および性質は、選択された新しいプロトコル（複数可）に完全に依存しています。しかし、すぐに（プロトコル切り替え）応答を101を送信した後、サーバはそれが新しいプロトコル（すなわち以内に同等のものを受け取ったかのように、元の要求に応え続けることが予想され、サーバはまだプロトコルの後に満たすために、未処理の要求を持っています）変更された、重複する要求を必要とせずにこれを行うことが期待されます。"
    },
    {
      "indent": 3,
      "text": "For example, if the Upgrade header field is received in a GET request and the server decides to switch protocols, it first responds with a 101 (Switching Protocols) message in HTTP/1.1 and then immediately follows that with the new protocol's equivalent of a response to a GET on the target resource. This allows a connection to be upgraded to protocols with the same semantics as HTTP without the latency cost of an additional round trip. A server MUST NOT switch protocols unless the received message semantics can be honored by the new protocol; an OPTIONS request can be honored by any protocol.",
      "ja": "Upgradeヘッダフィールドは、GET要求で受信され、サーバはプロトコルを切り替えることを決定した場合、例えば、まず101（スイッチングプロトコル）とHTTP / 1.1のメッセージを応答した後、直ちに次のその応答の新しいプロトコルの当量ターゲット・リソースのGETへ。これは、接続には、追加のラウンドトリップの待ち時間のコストをかけずにHTTPと同じ意味を持つプロトコルにアップグレードすることができます。受信したメッセージの意味は、新しいプロトコルで表彰することができない限り、サーバーはプロトコルを切り替えてはなりません。 OPTIONS要求は、任意のプロトコルで表彰することができます。"
    },
    {
      "indent": 3,
      "text": "The following is an example response to the above hypothetical request:",
      "ja": "以下は、上記の仮想的な要求に対して、例えば応答です。"
    },
    {
      "indent": 5,
      "text": "HTTP/1.1 101 Switching Protocols Connection: upgrade Upgrade: HTTP/2.0",
      "ja": "HTTP / 1.1 101は、プロトコル接続切替：アップグレードアップグレード：HTTP / 2.0を"
    },
    {
      "indent": 5,
      "text": "[... data stream switches to HTTP/2.0 with an appropriate response (as defined by new protocol) to the \"GET /hello.txt\" request ...]",
      "ja": "【「GET /hello.txt」要求に対する適切な応答（新しいプロトコルによって定義されるような）...とHTTP / 2.0 ...データ・ストリーム・スイッチ]"
    },
    {
      "indent": 3,
      "text": "When Upgrade is sent, the sender MUST also send a Connection header field (Section 6.1) that contains an \"upgrade\" connection option, in order to prevent Upgrade from being accidentally forwarded by intermediaries that might not implement the listed protocols. A server MUST ignore an Upgrade header field that is received in an HTTP/1.0 request.",
      "ja": "アップグレードが送信されると、送信者はまた、誤って記載されているプロトコルを実装していない可能性があります仲介によって転送されることからのアップグレードを防ぐために、「アップグレード」接続オプションが含まれているConnectionヘッダフィールド（6.1節）を送らなければなりません。サーバは、HTTP / 1.0リクエストで受信されたアップグレードヘッダフィールドを無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "A client cannot begin using an upgraded protocol on the connection until it has completely sent the request message (i.e., the client can't change the protocol it is sending in the middle of a message). If a server receives both an Upgrade and an Expect header field with the \"100-continue\" expectation (Section 5.1.1 of [RFC7231]), the server MUST send a 100 (Continue) response before sending a 101 (Switching Protocols) response.",
      "ja": "それは完全に要求メッセージを送信するまで、クライアント（すなわち、クライアントは、メッセージの途中で送信されているプロトコルを変更することはできません）接続でアップグレードプロトコルの使用を開始することができません。サーバは「100-継続」期待値（[RFC7231]のセクション5.1.1）とアップグレードと期待ヘッダフィールドの両方を受信した場合、サーバは100（続行）を送信しなければならない応答101（プロトコル切り替え）応答を送信する前に。"
    },
    {
      "indent": 3,
      "text": "The Upgrade header field only applies to switching protocols on top of the existing connection; it cannot be used to switch the underlying connection (transport) protocol, nor to switch the existing communication to a different connection. For those purposes, it is more appropriate to use a 3xx (Redirection) response (Section 6.4 of [RFC7231]).",
      "ja": "アップグレードヘッダフィールドは、既存の接続の上のプロトコルをスイッチングに適用されます。基礎となる接続（トランスポート）プロトコルを切り替えるために使用することができない、また、異なる接続に既存の通信を切り替えます。これらの目的のために、3XX（リダイレクト）応答（[RFC7231]のセクション6.4）を使用することがより適切です。"
    },
    {
      "indent": 3,
      "text": "This specification only defines the protocol name \"HTTP\" for use by the family of Hypertext Transfer Protocols, as defined by the HTTP version rules of Section 2.6 and future updates to this specification. Additional tokens ought to be registered with IANA using the registration procedure defined in Section 8.6.",
      "ja": "この仕様の2.6節および将来のアップデートのHTTPバージョンルールで定義されたこの仕様は、ハイパーテキスト転送プロトコルの家族が使用するプロトコル名「HTTP」を定義します。追加のトークンは、8.6節で定義された登録手順を使用して、IANAに登録されるべきです。"
    },
    {
      "indent": 0,
      "text": "7. ABNF List Extension: #rule",
      "section_title": true,
      "ja": "7. ABNF一覧拡張子：#rule"
    },
    {
      "indent": 3,
      "text": "A #rule extension to the ABNF rules of [RFC5234] is used to improve readability in the definitions of some header field values.",
      "ja": "[RFC5234]のABNF規則に#rule拡張は、いくつかのヘッダフィールド値の定義に読みやすさを改善するために使用されます。"
    },
    {
      "indent": 3,
      "text": "A construct \"#\" is defined, similar to \"*\", for defining comma-delimited lists of elements. The full form is \"<n>#<m>element\" indicating at least <n> and at most <m> elements, each separated by a single comma (\",\") and optional whitespace (OWS).",
      "ja": "構築物「＃」要素のカンマ区切りのリストを定義するために、「*」に似て定義されます。完全形は、少なくとも<n>は、ほとんど<M>要素は、単一のコンマ（「」）および任意の空白（OWS）によって分離された各々に示す「<N>＃<M>要素」です。"
    },
    {
      "indent": 3,
      "text": "In any production that uses the list construct, a sender MUST NOT generate empty list elements. In other words, a sender MUST generate lists that satisfy the following syntax:",
      "ja": "リスト構造体を使用する任意の生産では、送信者は、空のリスト要素を生成してはなりません。言い換えれば、送信者は、次の構文を満たすリストを生成する必要があります。"
    },
    {
      "indent": 5,
      "text": "1#element => element *( OWS \",\" OWS element )",
      "ja": "1つの＃要素=>要素*（OWS \"\" OWS素子）"
    },
    {
      "indent": 3,
      "text": "and:",
      "ja": "そして："
    },
    {
      "indent": 5,
      "text": "#element => [ 1#element ]",
      "ja": "#element => [1つの＃要素]"
    },
    {
      "indent": 3,
      "text": "and for n >= 1 and m > 1:",
      "ja": "かつn> = 1であり、m> 1の場合："
    },
    {
      "indent": 5,
      "text": "<n>#<m>element => element <n-1>*<m-1>( OWS \",\" OWS element )",
      "ja": "<N>＃<M>要素=>要素<N-1> * <M-1>（OWS \"\" OWS素子）"
    },
    {
      "indent": 3,
      "text": "For compatibility with legacy list rules, a recipient MUST parse and ignore a reasonable number of empty list elements: enough to handle common mistakes by senders that merge values, but not so much that they could be used as a denial-of-service mechanism. In other words, a recipient MUST accept lists that satisfy the following syntax:",
      "ja": "値をマージ送信者によって一般的なミスを処理するのに十分な、しかし、彼らは、サービス拒否のメカニズムとして使用することができることはあまりありません：レガシーリストルールとの互換性のために、受信者は、空のリスト要素の合理的な数を解析し、無視しなければなりません。言い換えれば、受信者は、次の構文を満たすリストを受け入れなければなりません："
    },
    {
      "indent": 5,
      "text": "#element => [ ( \",\" / element ) *( OWS \",\" [ OWS element ] ) ]",
      "ja": "#element =>（ \"\" /要素）*（OWS \"\" [OWS要素]）]"
    },
    {
      "indent": 5,
      "text": "1#element => *( \",\" OWS ) element *( OWS \",\" [ OWS element ] )",
      "ja": "1つの＃要素=> *（ \"\" OWS）要素*（OWS \"\" [OWS要素]）"
    },
    {
      "indent": 3,
      "text": "Empty elements do not contribute to the count of elements present. For example, given these ABNF productions:",
      "ja": "空の要素が存在する要素の数に寄与しません。例えば、これらのABNF制作を与えられました："
    },
    {
      "indent": 5,
      "text": "example-list = 1#example-list-elmt example-list-elmt = token ; see Section 3.2.6",
      "ja": "例えばリスト= 1＃例えば、リストelmt例-リストelmt =トークン。 3.2.6項を参照してください"
    },
    {
      "indent": 3,
      "text": "Then the following are valid values for example-list (not including the double quotes, which are present for delimitation only):",
      "ja": "その後、次の（区切りのために存在している二重引用符を含むだけでなく）たとえば、リストの有効な値は次のとおりです。"
    },
    {
      "indent": 5,
      "text": "\"foo,bar\" \"foo ,bar,\" \"foo , ,bar,charlie \"",
      "ja": "\"FOO、バー\" \"FOO、バー、\" \"FOO、バー、チャーリー\""
    },
    {
      "indent": 3,
      "text": "In contrast, the following values would be invalid, since at least one non-empty element is required by the example-list production:",
      "ja": "少なくとも一つの非空の要素は、例えば、リストの生産に必要とされるので、これとは対照的に、以下の値は、無効になります。"
    },
    {
      "indent": 5,
      "text": "\"\" \",\" \", ,\"",
      "ja": "”” ”、” ”、 、”"
    },
    {
      "indent": 3,
      "text": "Appendix B shows the collected ABNF for recipients after the list constructs have been expanded.",
      "ja": "付録Bは、リスト構造が展開された後、受信者のために収集ABNFを示しています。"
    },
    {
      "indent": 0,
      "text": "8. IANA Considerations",
      "section_title": true,
      "ja": "8. IANAの考慮事項"
    },
    {
      "indent": 0,
      "text": "8.1. Header Field Registration",
      "section_title": true,
      "ja": "8.1。ヘッダーフィールドの登録"
    },
    {
      "indent": 3,
      "text": "HTTP header fields are registered within the \"Message Headers\" registry maintained at <http://www.iana.org/assignments/message-headers/>.",
      "ja": "HTTPヘッダフィールドは、<http://www.iana.org/assignments/message-headers/>に維持「メッセージヘッダ」レジストリ内に登録されています。"
    },
    {
      "indent": 3,
      "text": "This document defines the following HTTP header fields, so the \"Permanent Message Header Field Names\" registry has been updated accordingly (see [BCP90]).",
      "ja": "この文書は、次のHTTPヘッダーフィールドを定義するので、「永続的メッセージヘッダーフィールド名」レジストリ（[BCP90]参照）に応じて更新されました。"
    },
    {
      "indent": 3,
      "text": "+-------------------+----------+----------+---------------+\n| Header Field Name | Protocol | Status   | Reference     |\n+-------------------+----------+----------+---------------+\n| Connection        | http     | standard | Section 6.1   |\n| Content-Length    | http     | standard | Section 3.3.2 |\n| Host              | http     | standard | Section 5.4   |\n| TE                | http     | standard | Section 4.3   |\n| Trailer           | http     | standard | Section 4.4   |\n| Transfer-Encoding | http     | standard | Section 3.3.1 |\n| Upgrade           | http     | standard | Section 6.7   |\n| Via               | http     | standard | Section 5.7.1 |\n+-------------------+----------+----------+---------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Furthermore, the header field-name \"Close\" has been registered as \"reserved\", since using that name as an HTTP header field might conflict with the \"close\" connection option of the Connection header field (Section 6.1).",
      "ja": "また、ヘッダフィールド名は、「閉じる」HTTPヘッダーフィールドとしてその名前を使用して接続ヘッダーフィールドの「クローズ」接続オプション（セクション6.1）と競合する可能性があるため、「予約済み」として登録されています。"
    },
    {
      "indent": 3,
      "text": "+-------------------+----------+----------+-------------+\n| Header Field Name | Protocol | Status   | Reference   |\n+-------------------+----------+----------+-------------+\n| Close             | http     | reserved | Section 8.1 |\n+-------------------+----------+----------+-------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The change controller is: \"IETF (iesg@ietf.org) - Internet Engineering Task Force\".",
      "ja": "変更コントローラは次のとおりです。「IETF（iesg@ietf.org） - インターネットエンジニアリングタスクフォース」。"
    },
    {
      "indent": 0,
      "text": "8.2. URI Scheme Registration",
      "section_title": true,
      "ja": "8.2。 URIスキームの登録"
    },
    {
      "indent": 3,
      "text": "IANA maintains the registry of URI Schemes [BCP115] at <http://www.iana.org/assignments/uri-schemes/>.",
      "ja": "IANAは、<http://www.iana.org/assignments/uri-schemes/>で[BCP115] URIスキームのレジストリを維持します。"
    },
    {
      "indent": 3,
      "text": "This document defines the following URI schemes, so the \"Permanent URI Schemes\" registry has been updated accordingly.",
      "ja": "このドキュメントでは、次のURIスキームを定義するので、「恒久URIスキーム」レジストリが更新されました。"
    },
    {
      "indent": 3,
      "text": "+------------+------------------------------------+---------------+\n| URI Scheme | Description                        | Reference     |\n+------------+------------------------------------+---------------+\n| http       | Hypertext Transfer Protocol        | Section 2.7.1 |\n| https      | Hypertext Transfer Protocol Secure | Section 2.7.2 |\n+------------+------------------------------------+---------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "8.3. Internet Media Type Registration",
      "section_title": true,
      "ja": "8.3。インターネットメディアタイプ登録"
    },
    {
      "indent": 3,
      "text": "IANA maintains the registry of Internet media types [BCP13] at <http://www.iana.org/assignments/media-types>.",
      "ja": "IANAは、<http://www.iana.org/assignments/media-types>で[BCP13]インターネットメディアタイプのレジストリを維持します。"
    },
    {
      "indent": 3,
      "text": "This document serves as the specification for the Internet media types \"message/http\" and \"application/http\". The following has been registered with IANA.",
      "ja": "このドキュメントはインターネットメディアタイプ「メッセージ/ http」と「アプリケーション/ HTTP」の仕様として機能します。以下は、IANAに登録されています。"
    },
    {
      "indent": 0,
      "text": "8.3.1. Internet Media Type message/http",
      "section_title": true,
      "ja": "8.3.1。インターネットメディアタイプのメッセージ/ HTTP"
    },
    {
      "indent": 3,
      "text": "The message/http type can be used to enclose a single HTTP request or response message, provided that it obeys the MIME restrictions for all \"message\" types regarding line length and encodings.",
      "ja": "メッセージ/ HTTPタイプは、それが行の長さ及び符号化に関するすべての「メッセージ」タイプのMIMEの制限に従うことを条件とする、単一のHTTP要求または応答メッセージを囲むために使用することができます。"
    },
    {
      "indent": 3,
      "text": "Type name: message",
      "ja": "型名：メッセージ"
    },
    {
      "indent": 3,
      "text": "Subtype name: http",
      "ja": "サブタイプ名：HTTP"
    },
    {
      "indent": 3,
      "text": "Required parameters: N/A",
      "ja": "必須パラメータ：N / A"
    },
    {
      "indent": 3,
      "text": "Optional parameters: version, msgtype",
      "ja": "オプションのパラメータ：バージョン、MSGTYPE"
    },
    {
      "indent": 6,
      "text": "version: The HTTP-version number of the enclosed message (e.g., \"1.1\"). If not present, the version can be determined from the first line of the body.",
      "ja": "バージョン：同封のメッセージのHTTPバージョン番号（例えば、「1.1」）。存在しない場合、バージョンは、本体の最初の行から決定することができます。"
    },
    {
      "indent": 6,
      "text": "msgtype: The message type -- \"request\" or \"response\". If not present, the type can be determined from the first line of the body.",
      "ja": "MSGTYPE：メッセージタイプ - 「要求」または「応答」。存在しない場合は、タイプは、本体の最初の行から決定することができます。"
    },
    {
      "indent": 3,
      "text": "Encoding considerations: only \"7bit\", \"8bit\", or \"binary\" are permitted",
      "ja": "エンコードの考慮事項：のみ「7ビット」、「8ビット」、または「バイナリー」は許可されています"
    },
    {
      "indent": 3,
      "text": "Security considerations: see Section 9",
      "ja": "セキュリティの考慮事項：第9節を参照してください"
    },
    {
      "indent": 3,
      "text": "Interoperability considerations: N/A",
      "ja": "相互運用性に関する注意事項：N / A"
    },
    {
      "indent": 3,
      "text": "Published specification: This specification (see Section 8.3.1).",
      "ja": "公開された仕様：この仕様書（8.3.1項を参照してください）。"
    },
    {
      "indent": 3,
      "text": "Applications that use this media type: N/A",
      "ja": "このメディアタイプを使用するアプリケーション：N / A"
    },
    {
      "indent": 3,
      "text": "Fragment identifier considerations: N/A",
      "ja": "フラグメント識別子の考慮事項：N / A"
    },
    {
      "indent": 3,
      "text": "Additional information:",
      "ja": "追加情報："
    },
    {
      "indent": 6,
      "text": "Magic number(s): N/A",
      "ja": "マジックナンバー（S）：N / A"
    },
    {
      "indent": 6,
      "text": "Deprecated alias names for this type: N/A",
      "ja": "このタイプの非推奨別名：N / A"
    },
    {
      "indent": 6,
      "text": "File extension(s): N/A",
      "ja": "ファイルの拡張子（S）：N / A"
    },
    {
      "indent": 6,
      "text": "Macintosh file type code(s): N/A",
      "ja": "Macintoshのファイルタイプコード（S）：N / A"
    },
    {
      "indent": 3,
      "text": "Person and email address to contact for further information: See Authors' Addresses section.",
      "ja": "Personと詳細のために連絡する電子メールアドレス：著者のアドレスセクションを参照してください。"
    },
    {
      "indent": 3,
      "text": "Intended usage: COMMON",
      "ja": "意図している用法：COMMON"
    },
    {
      "indent": 3,
      "text": "Restrictions on usage: N/A",
      "ja": "使用に関する制限事項：N / A"
    },
    {
      "indent": 3,
      "text": "Author: See Authors' Addresses section.",
      "ja": "著者：著者のアドレスセクションを参照してください。"
    },
    {
      "indent": 3,
      "text": "Change controller: IESG",
      "ja": "変更コントローラ：IESG"
    },
    {
      "indent": 0,
      "text": "8.3.2. Internet Media Type application/http",
      "section_title": true,
      "ja": "8.3.2。インターネットメディアタイプapplication / HTTP"
    },
    {
      "indent": 3,
      "text": "The application/http type can be used to enclose a pipeline of one or more HTTP request or response messages (not intermixed).",
      "ja": "アプリケーション/ HTTPタイプは、1つ以上のHTTP要求または応答メッセージのパイプラインを囲むために使用することができる（混合しません）。"
    },
    {
      "indent": 3,
      "text": "Type name: application",
      "ja": "型名：アプリケーション"
    },
    {
      "indent": 3,
      "text": "Subtype name: http",
      "ja": "サブタイプ名：HTTP"
    },
    {
      "indent": 3,
      "text": "Required parameters: N/A",
      "ja": "必須パラメータ：N / A"
    },
    {
      "indent": 3,
      "text": "Optional parameters: version, msgtype",
      "ja": "オプションのパラメータ：バージョン、MSGTYPE"
    },
    {
      "indent": 6,
      "text": "version: The HTTP-version number of the enclosed messages (e.g., \"1.1\"). If not present, the version can be determined from the first line of the body.",
      "ja": "バージョン：同封のメッセージのHTTPバージョン番号（例えば、「1.1」）。存在しない場合、バージョンは、本体の最初の行から決定することができます。"
    },
    {
      "indent": 6,
      "text": "msgtype: The message type -- \"request\" or \"response\". If not present, the type can be determined from the first line of the body.",
      "ja": "MSGTYPE：メッセージタイプ - 「要求」または「応答」。存在しない場合は、タイプは、本体の最初の行から決定することができます。"
    },
    {
      "indent": 3,
      "text": "Encoding considerations: HTTP messages enclosed by this type are in \"binary\" format; use of an appropriate Content-Transfer-Encoding is required when transmitted via email.",
      "ja": "エンコードの考慮事項：このタイプで囲まれたHTTPメッセージは、「バイナリ」形式になっています。電子メールを介して送信時に適切なコンテンツ転送エンコードの使用が必要とされます。"
    },
    {
      "indent": 3,
      "text": "Security considerations: see Section 9",
      "ja": "セキュリティの考慮事項：第9節を参照してください"
    },
    {
      "indent": 3,
      "text": "Interoperability considerations: N/A",
      "ja": "相互運用性に関する注意事項：N / A"
    },
    {
      "indent": 3,
      "text": "Published specification: This specification (see Section 8.3.2).",
      "ja": "公開された仕様：この仕様書（8.3.2項を参照してください）。"
    },
    {
      "indent": 3,
      "text": "Applications that use this media type: N/A",
      "ja": "このメディアタイプを使用するアプリケーション：N / A"
    },
    {
      "indent": 3,
      "text": "Fragment identifier considerations: N/A",
      "ja": "フラグメント識別子の考慮事項：N / A"
    },
    {
      "indent": 3,
      "text": "Additional information:",
      "ja": "追加情報："
    },
    {
      "indent": 6,
      "text": "Deprecated alias names for this type: N/A",
      "ja": "このタイプの非推奨別名：N / A"
    },
    {
      "indent": 6,
      "text": "Magic number(s): N/A",
      "ja": "マジックナンバー（S）：N / A"
    },
    {
      "indent": 6,
      "text": "File extension(s): N/A",
      "ja": "ファイルの拡張子（S）：N / A"
    },
    {
      "indent": 6,
      "text": "Macintosh file type code(s): N/A",
      "ja": "Macintoshのファイルタイプコード（S）：N / A"
    },
    {
      "indent": 3,
      "text": "Person and email address to contact for further information: See Authors' Addresses section.",
      "ja": "Personと詳細のために連絡する電子メールアドレス：著者のアドレスセクションを参照してください。"
    },
    {
      "indent": 3,
      "text": "Intended usage: COMMON",
      "ja": "意図している用法：COMMON"
    },
    {
      "indent": 3,
      "text": "Restrictions on usage: N/A",
      "ja": "使用に関する制限事項：N / A"
    },
    {
      "indent": 3,
      "text": "Author: See Authors' Addresses section.",
      "ja": "著者：著者のアドレスセクションを参照してください。"
    },
    {
      "indent": 3,
      "text": "Change controller: IESG",
      "ja": "変更コントローラ：IESG"
    },
    {
      "indent": 0,
      "text": "8.4. Transfer Coding Registry",
      "section_title": true,
      "ja": "8.4。転送コーディングレジストリ"
    },
    {
      "indent": 3,
      "text": "The \"HTTP Transfer Coding Registry\" defines the namespace for transfer coding names. It is maintained at <http://www.iana.org/assignments/http-parameters>.",
      "ja": "「HTTP転送コーディングレジストリは」転送コーディング名の名前空間を定義します。それは、<http://www.iana.org/assignments/http-parameters>に維持されています。"
    },
    {
      "indent": 0,
      "text": "8.4.1. Procedure",
      "section_title": true,
      "ja": "8.4.1。手順"
    },
    {
      "indent": 3,
      "text": "Registrations MUST include the following fields:",
      "ja": "登録は、次のフィールドを含める必要があります。"
    },
    {
      "indent": 3,
      "text": "o Name",
      "ja": "O名"
    },
    {
      "indent": 3,
      "text": "o Description",
      "ja": "O説明"
    },
    {
      "indent": 3,
      "text": "o Pointer to specification text",
      "ja": "Oポインターは、テキストを仕様に"
    },
    {
      "indent": 3,
      "text": "Names of transfer codings MUST NOT overlap with names of content codings (Section 3.1.2.1 of [RFC7231]) unless the encoding transformation is identical, as is the case for the compression codings defined in Section 4.2.",
      "ja": "セクション4.2で定義された圧縮コーディングの場合のように、符号化変換が、同一でない限り、転送コーディングの名前はコンテンツコーディング（[RFC7231]のセクション3.1.2.1）の名前と重複してはなりません。"
    },
    {
      "indent": 3,
      "text": "Values to be added to this namespace require IETF Review (see Section 4.1 of [RFC5226]), and MUST conform to the purpose of transfer coding defined in this specification.",
      "ja": "この名前空間に追加される値は、（[RFC5226]のセクション4.1を参照）IETFレビューを必要とし、そして本明細書中で定義された転送コーディングの目的に適合しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Use of program names for the identification of encoding formats is not desirable and is discouraged for future encodings.",
      "ja": "符号化フォーマットを識別するためのプログラム名を使用することは望ましくなく、将来の符号化のために推奨されています。"
    },
    {
      "indent": 0,
      "text": "8.4.2. Registration",
      "section_title": true,
      "ja": "8.4.2。登録"
    },
    {
      "indent": 3,
      "text": "The \"HTTP Transfer Coding Registry\" has been updated with the registrations below:",
      "ja": "「レジストリをコーディングHTTP転送」は、以下の登録で更新されました："
    },
    {
      "indent": 3,
      "text": "+------------+--------------------------------------+---------------+\n| Name       | Description                          | Reference     |\n+------------+--------------------------------------+---------------+\n| chunked    | Transfer in a series of chunks       | Section 4.1   |\n| compress   | UNIX \"compress\" data format [Welch]  | Section 4.2.1 |\n| deflate    | \"deflate\" compressed data            | Section 4.2.2 |\n|            | ([RFC1951]) inside the \"zlib\" data   |               |\n|            | format ([RFC1950])                   |               |\n| gzip       | GZIP file format [RFC1952]           | Section 4.2.3 |\n| x-compress | Deprecated (alias for compress)      | Section 4.2.1 |\n| x-gzip     | Deprecated (alias for gzip)          | Section 4.2.3 |\n+------------+--------------------------------------+---------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "8.5. Content Coding Registration",
      "section_title": true,
      "ja": "8.5。登録内容コーディング"
    },
    {
      "indent": 3,
      "text": "IANA maintains the \"HTTP Content Coding Registry\" at <http://www.iana.org/assignments/http-parameters>.",
      "ja": "IANAは、<http://www.iana.org/assignments/http-parameters>で「レジストリをコーディングHTTPコンテンツ」を維持しています。"
    },
    {
      "indent": 3,
      "text": "The \"HTTP Content Coding Registry\" has been updated with the registrations below:",
      "ja": "「HTTPコンテンツコーディングレジストリ」は、以下の登録で更新されました："
    },
    {
      "indent": 3,
      "text": "+------------+--------------------------------------+---------------+\n| Name       | Description                          | Reference     |\n+------------+--------------------------------------+---------------+\n| compress   | UNIX \"compress\" data format [Welch]  | Section 4.2.1 |\n| deflate    | \"deflate\" compressed data            | Section 4.2.2 |\n|            | ([RFC1951]) inside the \"zlib\" data   |               |\n|            | format ([RFC1950])                   |               |\n| gzip       | GZIP file format [RFC1952]           | Section 4.2.3 |\n| x-compress | Deprecated (alias for compress)      | Section 4.2.1 |\n| x-gzip     | Deprecated (alias for gzip)          | Section 4.2.3 |\n+------------+--------------------------------------+---------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "8.6. Upgrade Token Registry",
      "section_title": true,
      "ja": "8.6。トークンレジストリをアップグレード"
    },
    {
      "indent": 3,
      "text": "The \"Hypertext Transfer Protocol (HTTP) Upgrade Token Registry\" defines the namespace for protocol-name tokens used to identify protocols in the Upgrade header field. The registry is maintained at <http://www.iana.org/assignments/http-upgrade-tokens>.",
      "ja": "「ハイパーテキスト転送プロトコル（HTTP）トークンレジストリのアップグレード」アップグレードヘッダフィールドにプロトコルを識別するために使用されるプロトコル名トークンの名前空間を定義します。レジストリは、<http://www.iana.org/assignments/http-upgrade-tokens>に維持されています。"
    },
    {
      "indent": 0,
      "text": "8.6.1. Procedure",
      "section_title": true,
      "ja": "8.6.1。手順"
    },
    {
      "indent": 3,
      "text": "Each registered protocol name is associated with contact information and an optional set of specifications that details how the connection will be processed after it has been upgraded.",
      "ja": "登録された各プロトコル名は、連絡先情報と、それがアップグレードされた後、接続が処理される方法の詳細な仕様のオプションのセットに関連付けられています。"
    },
    {
      "indent": 3,
      "text": "Registrations happen on a \"First Come First Served\" basis (see Section 4.1 of [RFC5226]) and are subject to the following rules:",
      "ja": "登録が起こる根拠を「まず最初に来る役立った」（[RFC5226]のセクション4.1を参照）、以下の規則に従います："
    },
    {
      "indent": 3,
      "text": "1. A protocol-name token, once registered, stays registered forever.",
      "section_title": true,
      "ja": "1.一度登録されたプロトコル名トークンは、永久に登録されたままになります。"
    },
    {
      "indent": 3,
      "text": "2. The registration MUST name a responsible party for the registration.",
      "ja": "2.登録は、登録のための責任者を指名しなければなりません。"
    },
    {
      "indent": 3,
      "text": "3. The registration MUST name a point of contact.",
      "section_title": true,
      "ja": "3.登録は接触のポイントを指名しなければなりません。"
    },
    {
      "indent": 3,
      "text": "4. The registration MAY name a set of specifications associated with that token. Such specifications need not be publicly available.",
      "ja": "4.登録は、そのトークンに関連付けられた一連の仕様を指定することができます。このような仕様は一般に公開する必要はありません。"
    },
    {
      "indent": 3,
      "text": "5. The registration SHOULD name a set of expected \"protocol-version\" tokens associated with that token at the time of registration.",
      "ja": "5.登録は、登録時にそのトークンに関連付けられた期待「プロトコルバージョン」トークンのセットに名前を付けるべきです。"
    },
    {
      "indent": 3,
      "text": "6. The responsible party MAY change the registration at any time. The IANA will keep a record of all such changes, and make them available upon request.",
      "ja": "6.責任者は、いつでも登録を変更することがあります。 IANAはそのようなすべての変更の記録を保持し、要求に応じてそれらを利用できるようになります。"
    },
    {
      "indent": 3,
      "text": "7. The IESG MAY reassign responsibility for a protocol token. This will normally only be used in the case when a responsible party cannot be contacted.",
      "ja": "7. IESGは、プロトコルトークンの責任を再割り当てすることができます。これは通常、唯一の責任者に連絡することができない場合に使用されます。"
    },
    {
      "indent": 3,
      "text": "This registration procedure for HTTP Upgrade Tokens replaces that previously defined in Section 7.2 of [RFC2817].",
      "ja": "HTTPは、トークンをアップグレードするためのこの登録手続きは、以前に[RFC2817]のセクション7.2で定義されていることを置き換えます。"
    },
    {
      "indent": 0,
      "text": "8.6.2. Upgrade Token Registration",
      "section_title": true,
      "ja": "8.6.2。トークンの登録をアップグレード"
    },
    {
      "indent": 3,
      "text": "The \"HTTP\" entry in the upgrade token registry has been updated with the registration below:",
      "ja": "アップグレードトークンレジストリ内の「HTTP」のエントリは、以下の登録で更新されました："
    },
    {
      "indent": 3,
      "text": "+-------+----------------------+----------------------+-------------+\n| Value | Description          | Expected Version     | Reference   |\n|       |                      | Tokens               |             |\n+-------+----------------------+----------------------+-------------+\n| HTTP  | Hypertext Transfer   | any DIGIT.DIGIT      | Section 2.6 |\n|       | Protocol             | (e.g, \"2.0\")         |             |\n+-------+----------------------+----------------------+-------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The responsible party is: \"IETF (iesg@ietf.org) - Internet Engineering Task Force\".",
      "ja": "責任者は、次のとおりです。「IETF（iesg@ietf.org） - インターネットエンジニアリングタスクフォース」。"
    },
    {
      "indent": 0,
      "text": "9. Security Considerations",
      "section_title": true,
      "ja": "9.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "This section is meant to inform developers, information providers, and users of known security considerations relevant to HTTP message syntax, parsing, and routing. Security considerations about HTTP semantics and payloads are addressed in [RFC7231].",
      "ja": "このセクションでは、HTTPメッセージの構文、パース、およびルーティングに関連する既知のセキュリティ上の考慮事項の開発者、情報提供者、およびユーザーに通知するものとします。 HTTPセマンティクスとペイロードに関するセキュリティ上の考慮事項は、[RFC7231]で扱われています。"
    },
    {
      "indent": 0,
      "text": "9.1. Establishing Authority",
      "section_title": true,
      "ja": "9.1。権威の確立"
    },
    {
      "indent": 3,
      "text": "HTTP relies on the notion of an authoritative response: a response that has been determined by (or at the direction of) the authority identified within the target URI to be the most appropriate response for that request given the state of the target resource at the time of response message origination. Providing a response from a non-authoritative source, such as a shared cache, is often useful to improve performance and availability, but only to the extent that the source can be trusted or the distrusted response can be safely used.",
      "ja": "一度に対象リソースの状態を与えられた要求のために最も適切な応答であることにより（又は方向で）ターゲットURI内で識別された権限が決定された応答：HTTPは、権威ある応答の概念に依存しています応答メッセージ発信の。 、共有キャッシュとして非信頼できるソースからの応答を提供するが、唯一のソースが信頼できるか信頼できない応答を安全に使用することができる程度に、パフォーマンスと可用性を向上させるために有用であることがしばしばあります。"
    },
    {
      "indent": 3,
      "text": "Unfortunately, establishing authority can be difficult. For example, phishing is an attack on the user's perception of authority, where that perception can be misled by presenting similar branding in hypertext, possibly aided by userinfo obfuscating the authority component (see Section 2.7.1). User agents can reduce the impact of phishing attacks by enabling users to easily inspect a target URI prior to making an action, by prominently distinguishing (or rejecting) userinfo when present, and by not sending stored credentials and cookies when the referring document is from an unknown or untrusted source.",
      "ja": "残念ながら、権威を確立することが困難な場合があります。たとえば、フィッシング詐欺は、おそらく権限コンポーネントを難読化のuserinfoに助けられている認識はハイパーテキストに似たブランディングを提示することによって誤解することができます権限のユーザーの知覚に攻撃、（2.7.1項を参照）です。ユーザエージェントは、容易に目立つ識別（または拒否）することにより、前のアクションを作ることにターゲットURIを検査することをユーザに可能にすることによって、フィッシング攻撃の影響を低減することができる存在する場合、および参照文書は、ANからのものであるときに格納された資格情報とクッキーを送信しないことにより、ユーザー情報未知、または信頼できないソース。"
    },
    {
      "indent": 3,
      "text": "When a registered name is used in the authority component, the \"http\" URI scheme (Section 2.7.1) relies on the user's local name resolution service to determine where it can find authoritative responses. This means that any attack on a user's network host table, cached names, or name resolution libraries becomes an avenue for attack on establishing authority. Likewise, the user's choice of server for Domain Name Service (DNS), and the hierarchy of servers from which it obtains resolution results, could impact the authenticity of address mappings; DNS Security Extensions (DNSSEC, [RFC4033]) are one way to improve authenticity.",
      "ja": "登録名は権限コンポーネントで使用される場合、「HTTP」URIスキーム（2.7.1）は、権威ある回答を見つけることができる場所を決定するために、ユーザーのローカルの名前解決サービスに依存しています。これは、ユーザのネットワークホストテーブル上の任意の攻撃は、キャッシュされた名前、または名前解決ライブラリが権威を確立する上での攻撃のための道になっていることを意味します。同様に、ドメインネームサービス（DNS）、およびそれが解決の結果を取得し、そこからサーバの階層のサーバーのユーザーの選択は、アドレスマッピングの信憑性に影響を与える可能性があります。 DNSセキュリティ拡張機能（DNSSEC、[RFC4033]）は信頼性を向上させるための一つの方法です。"
    },
    {
      "indent": 3,
      "text": "Furthermore, after an IP address is obtained, establishing authority for an \"http\" URI is vulnerable to attacks on Internet Protocol routing.",
      "ja": "さらに、IPアドレスの後にURIが、インターネット・プロトコル・ルーティングへの攻撃に対して脆弱である「HTTP」の権威を確立し、得られます。"
    },
    {
      "indent": 3,
      "text": "The \"https\" scheme (Section 2.7.2) is intended to prevent (or at least reveal) many of these potential attacks on establishing authority, provided that the negotiated TLS connection is secured and the client properly verifies that the communicating server's identity matches the target URI's authority component (see [RFC2818]). Correctly implementing such verification can be difficult (see [Georgiev]).",
      "ja": "「https」のスキーム（2.7.2項）が権威を確立する上で、これらの潜在的な攻撃の多くを防ぐ（または少なくとも明らかに）することを意図して、交渉しTLS接続が確保されると、クライアントが正しく通信サーバーのIDが一致することを確認することを提供URIの権限コンポーネントをターゲット（[RFC2818]を参照）。正しくそのような検証を実施する（[ゲオルギエフ]参照）困難であり得ます。"
    },
    {
      "indent": 0,
      "text": "9.2. Risks of Intermediaries",
      "section_title": true,
      "ja": "9.2。仲介者のリスク"
    },
    {
      "indent": 3,
      "text": "By their very nature, HTTP intermediaries are men-in-the-middle and, thus, represent an opportunity for man-in-the-middle attacks. Compromise of the systems on which the intermediaries run can result in serious security and privacy problems. Intermediaries might have access to security-related information, personal information about individual users and organizations, and proprietary information belonging to users and content providers. A compromised intermediary, or an intermediary implemented or configured without regard to security and privacy considerations, might be used in the commission of a wide range of potential attacks.",
      "ja": "その性質上、HTTPの仲介者は、男性・イン・ザ・ミドルあり、したがって、man-in-the-middle攻撃の機会を表しています。システムの妥協は、上で実行する仲介は深刻なセキュリティとプライバシーの問題をもたらす可能性があります。仲介は、セキュリティ関連の情報、個々のユーザーや組織、およびユーザーやコンテンツプロバイダに属する専有情報について、個人情報へのアクセス権を持っているかもしれません。妥協の仲介、またはセキュリティやプライバシーの配慮を考慮せずに実装または構成された仲介は、潜在的な攻撃の広い範囲の手数料で使用される可能性があります。"
    },
    {
      "indent": 3,
      "text": "Intermediaries that contain a shared cache are especially vulnerable to cache poisoning attacks, as described in Section 8 of [RFC7234].",
      "ja": "[RFC7234]のセクション8で説明したように共有キャッシュを含んで仲介は、キャッシュ汚染攻撃に対して特に脆弱です。"
    },
    {
      "indent": 3,
      "text": "Implementers need to consider the privacy and security implications of their design and coding decisions, and of the configuration options they provide to operators (especially the default configuration).",
      "ja": "実装者は、その設計とコーディングの決定の、そして、彼らは事業者（特にデフォルトの設定）に提供し、構成オプションのプライバシーとセキュリティの影響を考慮する必要があります。"
    },
    {
      "indent": 3,
      "text": "Users need to be aware that intermediaries are no more trustworthy than the people who run them; HTTP itself cannot solve this problem.",
      "ja": "ユーザーが仲介はありませんそれらを実行人々よりも信頼できることに注意する必要があります。 HTTP自体は、この問題を解決することはできません。"
    },
    {
      "indent": 0,
      "text": "9.3. Attacks via Protocol Element Length",
      "section_title": true,
      "ja": "9.3。プロトコル要素長を経由して攻撃"
    },
    {
      "indent": 3,
      "text": "Because HTTP uses mostly textual, character-delimited fields, parsers are often vulnerable to attacks based on sending very long (or very slow) streams of data, particularly where an implementation is expecting a protocol element with no predefined length.",
      "ja": "HTTPは主にテキスト、文字で区切られたフィールドを使用しているため、パーサーは、多くの場合、実装は、事前定義された長さとプロトコル要素を期待して、特にデータの非常に長い（又は非常に遅い）ストリームを送信することに基づいて、攻撃に対して脆弱です。"
    },
    {
      "indent": 3,
      "text": "To promote interoperability, specific recommendations are made for minimum size limits on request-line (Section 3.1.1) and header fields (Section 3.2). These are minimum recommendations, chosen to be supportable even by implementations with limited resources; it is expected that most implementations will choose substantially higher limits.",
      "ja": "相互運用性を促進するために、具体的な提言は、リクエストライン（3.1.1）とヘッダフィールド（セクション3.2）上の最小サイズ制限のために作られています。これらは、さらに限られたリソースで実装によってサポート可能であるように選択最小推奨です。ほとんどの実装は実質的により高い限界を選択することが期待されます。"
    },
    {
      "indent": 3,
      "text": "A server can reject a message that has a request-target that is too long (Section 6.5.12 of [RFC7231]) or a request payload that is too large (Section 6.5.11 of [RFC7231]). Additional status codes related to capacity limits have been defined by extensions to HTTP [RFC6585].",
      "ja": "サーバは、（[RFC7231]のセクション6.5.12）または（[RFC7231]のセクション6.5.11）が大きすぎる要求ペイロード長すぎる要求目標を持つメッセージを拒否することができます。容量制限に関連する追加のステータスコードは、[RFC6585]をHTTPの拡張によって定義されています。"
    },
    {
      "indent": 3,
      "text": "Recipients ought to carefully limit the extent to which they process other protocol elements, including (but not limited to) request methods, response status phrases, header field-names, numeric values, and body chunks. Failure to limit such processing can result in buffer overflows, arithmetic overflows, or increased vulnerability to denial-of-service attacks.",
      "ja": "受信者は注意深くそれらがリクエストメソッド、応答ステータスフレーズ、ヘッダフィールド名、数値、ボディのチャンクを含む（これらに限定されない）他のプロトコル要素を、処理する範囲を限定するべきです。このような処理を制限する障害がバッファオーバーフロー、算術オーバーフロー、またはサービス拒否攻撃に対する増大した脆弱性をもたらすことができます。"
    },
    {
      "indent": 0,
      "text": "9.4. Response Splitting",
      "section_title": true,
      "ja": "9.4。レスポンス分割"
    },
    {
      "indent": 3,
      "text": "Response splitting (a.k.a, CRLF injection) is a common technique, used in various attacks on Web usage, that exploits the line-based nature of HTTP message framing and the ordered association of requests to responses on persistent connections [Klein]. This technique can be particularly damaging when the requests pass through a shared cache.",
      "ja": "（CRLFインジェクション、a.k.a）応答分割は、HTTPメッセージフレーミングおよび永続的な接続に応答への要求の順序付けられた関連のラインベースの性質を利用したWebの使用に対する様々な攻撃に使用される一般的な技術、[クライン]です。要求が共有キャッシュを通過するときに、この技術は、特に損傷することができます。"
    },
    {
      "indent": 3,
      "text": "Response splitting exploits a vulnerability in servers (usually within an application server) where an attacker can send encoded data within some parameter of the request that is later decoded and echoed within any of the response header fields of the response. If the decoded data is crafted to look like the response has ended and a subsequent response has begun, the response has been split and the content within the apparent second response is controlled by the attacker. The attacker can then make any other request on the same persistent connection and trick the recipients (including intermediaries) into believing that the second half of the split is an authoritative answer to the second request.",
      "ja": "応答分割は、攻撃者が後でレスポンスのレスポンスヘッダフィールドのいずれかの中にデコードされ、エコーされリクエストの一部パラメータ内符号化されたデータを送信することができる（通常、アプリケーション・サーバー内）サーバの脆弱性を利用します。デコードされたデータは、応答が終了したとその後の対応が始まっているように見えるように細工された場合、応答が分割されていると見かけの二応答内のコンテンツが攻撃者によって制御されます。攻撃者は、その後、同じ持続的接続上の他の要求を行うと分割の後半は、第2の要求に正式な答えであることを信じるように（仲介業者を含む）の受信者をだますことができます。"
    },
    {
      "indent": 3,
      "text": "For example, a parameter within the request-target might be read by an application server and reused within a redirect, resulting in the same parameter being echoed in the Location header field of the response. If the parameter is decoded by the application and not properly encoded when placed in the response field, the attacker can send encoded CRLF octets and other content that will make the application's single response look like two or more responses.",
      "ja": "例えば、要求対象内のパラメータは、アプリケーション・サーバーによって読み取られる可能性があり、応答のLocationヘッダフィールドにエコーされる同じパラメータをもたらす、リダイレクト内で再利用します。パラメータは、アプリケーションによってデコードされ、応答フィールドに置かれたときに適切にエンコードされていない場合、攻撃者がアプリケーションの単一の応答を2つの以上の応答のように見えるようになりますエンコードされたCRLFオクテットやその他のコンテンツを送信することができます。"
    },
    {
      "indent": 3,
      "text": "A common defense against response splitting is to filter requests for data that looks like encoded CR and LF (e.g., \"%0D\" and \"%0A\"). However, that assumes the application server is only performing URI decoding, rather than more obscure data transformations like charset transcoding, XML entity translation, base64 decoding, sprintf reformatting, etc. A more effective mitigation is to prevent anything other than the server's core protocol libraries from sending a CR or LF within the header section, which means restricting the output of header fields to APIs that filter for bad octets and not allowing application servers to write directly to the protocol stream.",
      "ja": "応答分割に対する共通の防御は、符号化されたCRとLF（例えば、「％0D」及び「％の0A」）のように見えるデータの要求をフィルタリングすることです。しかし、それは、アプリケーション・サーバのみではなく、より効果的な緩和は、サーバのコアプロトコルライブラリ以外を防ぐためである文字セットのトランスコーディング、XMLエンティティの翻訳、base64でデコード、sprintfのリフォーマット、などのような、よりあいまいなデータ変換よりも、URIの復号化を実行されていると仮定しますAPIへの悪いオクテットのためにそのフィルタをヘッダフィールドの出力を制限することを意味し、ヘッダ部内CRまたはLFを送信し、アプリケーションサーバは、プロトコルストリームに直接書き込むことが可能ではないから。"
    },
    {
      "indent": 0,
      "text": "9.5. Request Smuggling",
      "section_title": true,
      "ja": "9.5。リクエスト密輸"
    },
    {
      "indent": 3,
      "text": "Request smuggling ([Linhart]) is a technique that exploits differences in protocol parsing among various recipients to hide additional requests (which might otherwise be blocked or disabled by policy) within an apparently harmless request. Like response splitting, request smuggling can lead to a variety of attacks on HTTP usage.",
      "ja": "リクエスト密輸（[Linhart]）は明らかに無害な要求内（特にポリシーによってブロックまたは無効にされるかもしれない）追加の要求を隠すために、様々な受信者の間でプロトコル解析の違いを利用する技術です。レスポンス分割と同様に、要求の密輸は、HTTPの使用上のさまざまな攻撃につながることができます。"
    },
    {
      "indent": 3,
      "text": "This specification has introduced new requirements on request parsing, particularly with regard to message framing in Section 3.3.3, to reduce the effectiveness of request smuggling.",
      "ja": "この仕様は、要求密輸の有効性を減らすために、特にセクション3.3.3でメッセージフレーミングに関しては、リクエストの解析に新たな要求を導入しました。"
    },
    {
      "indent": 0,
      "text": "9.6. Message Integrity",
      "section_title": true,
      "ja": "9.6。メッセージの整合性"
    },
    {
      "indent": 3,
      "text": "HTTP does not define a specific mechanism for ensuring message integrity, instead relying on the error-detection ability of underlying transport protocols and the use of length or chunk-delimited framing to detect completeness. Additional integrity mechanisms, such as hash functions or digital signatures applied to the content, can be selectively added to messages via extensible metadata header fields. Historically, the lack of a single integrity mechanism has been justified by the informal nature of most HTTP communication. However, the prevalence of HTTP as an information access mechanism has resulted in its increasing use within environments where verification of message integrity is crucial.",
      "ja": "HTTPは、代わりに、基礎となるトランスポートプロトコルのエラー検出能力と完全性を検出するための長さまたはチャンク区切りフレーミングの使用に頼って、メッセージの完全性を確保するための特定のメカニズムを定義していません。そのようなコンテンツに適用されるハッシュ関数、デジタル署名のような付加的な完全性機構は、選択的に拡張可能なメタデータ・ヘッダ・フィールドを介してメッセージに付加することができます。歴史的に、単一整合性のメカニズムの欠如は、ほとんどのHTTP通信の非公式な性質によって正当化されています。しかし、情報へのアクセスメカニズムとしてHTTPの有病率は、メッセージの完全性の検証が不可欠である環境内での使用の増加をもたらしました。"
    },
    {
      "indent": 3,
      "text": "User agents are encouraged to implement configurable means for detecting and reporting failures of message integrity such that those means can be enabled within environments for which integrity is necessary. For example, a browser being used to view medical history or drug interaction information needs to indicate to the user when such information is detected by the protocol to be incomplete, expired, or corrupted during transfer. Such mechanisms might be selectively enabled via user agent extensions or the presence of message integrity metadata in a response. At a minimum, user agents ought to provide some indication that allows a user to distinguish between a complete and incomplete response message (Section 3.4) when such verification is desired.",
      "ja": "ユーザーエージェントは、これらの手段は、整合性が必要な環境の中に有効にすることができるように、メッセージの完全性の障害を検出し、報告するための設定可能な手段を実装することをお勧めします。例えば、ブラウザは、病歴または薬物相互作用情報は、そのような情報は、不完全期限切れ、または転送中に破損するプロトコルによって検出されたときにユーザに知らせる必要がある表示するために使用されています。このようなメカニズムは、選択的に、ユーザエージェントの拡張や応答メッセージの整合性メタデータの存在を経由して有効にすることがあります。最低でも、ユーザエージェントは、ユーザがそのような検証が望まれる完全および不完全応答メッセージ（セクション3.4）を区別することを可能にするいくつかの指標を提供するべきです。"
    },
    {
      "indent": 0,
      "text": "9.7. Message Confidentiality",
      "section_title": true,
      "ja": "9.7。メッセージ秘匿"
    },
    {
      "indent": 3,
      "text": "HTTP relies on underlying transport protocols to provide message confidentiality when that is desired. HTTP has been specifically designed to be independent of the transport protocol, such that it can be used over many different forms of encrypted connection, with the selection of such transports being identified by the choice of URI scheme or within user agent configuration.",
      "ja": "HTTPはそれが望まれる場合、メッセージの機密性を提供するために、基本的なトランスポートプロトコルに依存しています。 HTTPは、具体的には、URIスキームの選択によって、またはユーザエージェント構成内で識別されるようなトランスポートの選択と、暗号化された接続の多くの異なる形態にわたって使用することができるように、トランスポートプロトコルに依存しないように設計されています。"
    },
    {
      "indent": 3,
      "text": "The \"https\" scheme can be used to identify resources that require a confidential connection, as described in Section 2.7.2.",
      "ja": "2.7.2項で説明したように「https」のスキームは、機密接続を必要とするリソースを識別するために使用することができます。"
    },
    {
      "indent": 0,
      "text": "9.8. Privacy of Server Log Information",
      "section_title": true,
      "ja": "9.8。サーバーログ情報のプライバシー"
    },
    {
      "indent": 3,
      "text": "A server is in the position to save personal data about a user's requests over time, which might identify their reading patterns or subjects of interest. In particular, log information gathered at an intermediary often contains a history of user agent interaction, across a multitude of sites, that can be traced to individual users.",
      "ja": "サーバーは、関心のある彼らの読書パターンまたは被験体を同定可能性がある、時間をかけてユーザーの要求に関する個人データを保存する立場にあります。特に、仲介で収集した情報は、多くの場合、ユーザエージェントの相互作用の歴史が含まれているログ、サイトの多数を越え、それは、個々のユーザーを追跡することが可能です。"
    },
    {
      "indent": 3,
      "text": "HTTP log information is confidential in nature; its handling is often constrained by laws and regulations. Log information needs to be securely stored and appropriate guidelines followed for its analysis. Anonymization of personal information within individual entries helps, but it is generally not sufficient to prevent real log traces from being re-identified based on correlation with other access characteristics. As such, access traces that are keyed to a specific client are unsafe to publish even if the key is pseudonymous.",
      "ja": "HTTPログ情報は、本質的に機密です。その取り扱いは、多くの場合、法律や規制によって制約されます。ログ情報を安全に保存する必要があり、適切なガイドラインは、その分析のために続きます。個々のエントリ内の個人情報の匿名化に役立ちますが、一般的に他のアクセス特性との相関に基づいて再識別されることから、実際のログトレースを防ぐのに十分ではありません。そのため、特定のクライアントにキーが付いていたアクセストレースは、キーはペンネームであっても、公開する安全ではありません。"
    },
    {
      "indent": 3,
      "text": "To minimize the risk of theft or accidental publication, log information ought to be purged of personally identifiable information, including user identifiers, IP addresses, and user-provided query parameters, as soon as that information is no longer necessary to support operational needs for security, auditing, or fraud control.",
      "ja": "ログ情報を、盗難や不慮の出版物の危険性を最小限に抑えるためには、すぐにその情報がセキュリティの運用ニーズをサポートする必要がなくなりましたように、ユーザ識別子、IPアドレス、およびユーザー提供のクエリパラメータなどの個人を特定できる情報、パージされるべきです、監査、または不正制御。"
    },
    {
      "indent": 0,
      "text": "10. Acknowledgments",
      "section_title": true,
      "ja": "10.謝辞"
    },
    {
      "indent": 3,
      "text": "This edition of HTTP/1.1 builds on the many contributions that went into RFC 1945, RFC 2068, RFC 2145, and RFC 2616, including substantial contributions made by the previous authors, editors, and Working Group Chairs: Tim Berners-Lee, Ari Luotonen, Roy T. Fielding, Henrik Frystyk Nielsen, Jim Gettys, Jeffrey C. Mogul, Larry Masinter, and Paul J. Leach. Mark Nottingham oversaw this effort as Working Group Chair.",
      "ja": "ティム・バーナーズ=リー、アリ・ルオトナン：HTTP / 1.1のこのエディションは、以前の著者、編集者、および作業部会の議長によって行われた多大な貢献を含め、RFC 1945、RFC 2068、RFC 2145、およびRFC 2616に入った多くの貢献に基づいています、ロイ・T.フィールディング、ヘンリック・フリスティック・ニールセン、ジム・ゲティーズ、ジェフリーC.モーグル、ラリーMasinter、そしてポール・J.リーチ。マーク・ノッティンガムは、ワーキンググループ議長として、この努力を監督しました。"
    },
    {
      "indent": 3,
      "text": "Since 1999, the following contributors have helped improve the HTTP specification by reporting bugs, asking smart questions, drafting or reviewing text, and evaluating open issues:",
      "ja": "1999年以来、次の貢献者は、未解決の問題を、スマートな質問をして、バグを報告起草やテキストを見直して、評価することにより、HTTPの仕様を改善に役立っています："
    },
    {
      "indent": 3,
      "text": "Adam Barth, Adam Roach, Addison Phillips, Adrian Chadd, Adrian Cole, Adrien W. de Croy, Alan Ford, Alan Ruttenberg, Albert Lunde, Alek Storm, Alex Rousskov, Alexandre Morgaut, Alexey Melnikov, Alisha Smith, Amichai Rothman, Amit Klein, Amos Jeffries, Andreas Maier, Andreas Petersson, Andrei Popov, Anil Sharma, Anne van Kesteren, Anthony Bryan, Asbjorn Ulsberg, Ashok Kumar, Balachander Krishnamurthy, Barry Leiba, Ben Laurie, Benjamin Carlyle, Benjamin Niven-Jenkins, Benoit Claise, Bil Corry, Bill Burke, Bjoern Hoehrmann, Bob Scheifler, Boris Zbarsky, Brett Slatkin, Brian Kell, Brian McBarron, Brian Pane, Brian Raymor, Brian Smith, Bruce Perens, Bryce Nesbitt, Cameron Heavon-Jones, Carl Kugler, Carsten Bormann, Charles Fry, Chris Burdess, Chris Newman, Christian Huitema, Cyrus Daboo, Dale Robert Anderson, Dan Wing, Dan Winship, Daniel Stenberg, Darrel Miller, Dave Cridland, Dave Crocker, Dave Kristol, Dave Thaler, David Booth, David Singer, David W. Morris, Diwakar Shetty, Dmitry Kurochkin, Drummond Reed, Duane Wessels, Edward Lee, Eitan Adler, Eliot Lear, Emile Stephan, Eran Hammer-Lahav, Eric D. Williams, Eric J. Bowman, Eric Lawrence, Eric Rescorla, Erik Aronesty, EungJun Yi, Evan Prodromou, Felix Geisendoerfer, Florian Weimer, Frank Ellermann, Fred Akalin, Fred Bohle, Frederic Kayser, Gabor Molnar, Gabriel Montenegro, Geoffrey Sneddon, Gervase Markham, Gili Tzabari, Grahame Grieve, Greg Slepak, Greg Wilkins, Grzegorz Calkowski, Harald Tveit Alvestrand, Harry Halpin, Helge Hess, Henrik Nordstrom, Henry S. Thompson, Henry Story, Herbert van de Sompel, Herve Ruellan, Howard Melman, Hugo Haas, Ian Fette, Ian Hickson, Ido Safruti, Ilari Liusvaara, Ilya Grigorik, Ingo Struck, J. Ross Nicoll, James Cloos, James H. Manger, James Lacey, James M. Snell, Jamie",
      "ja": "アダム・バース、アダムローチ、アディソン・フィリップス、エイドリアンCHADD、エイドリアン・コール、エイドリアンW.デクロイ、アラン・フォード、アランRuttenberg、アルバート・ルンデ、アレック嵐、アレックスRousskov、アレクサンドルMorgaut、アレクセイ・メルニコフ、アリーシャ・スミス、Amichaiロスマン、アミット・クライン、アモスジェフリーズ、アンドレアス・マイヤー、アンドレアス・ピーターソン、アンドレイ・ポポフ、アニル・シャルマ、アンバンKesteren氏、アンソニー・ブライアン、アスビョルンUlsberg、アショク・クマール、Balachander Krishnamurthy、バリー・レイバ、ベン・ローリー、ベンジャミン・カーライル、ベンジャミン・ニーヴン・ジェンキンス、ブノワClaise、ビリルビンコリー、ビル・バーク、ビョルンHoehrmann、ボブScheifler、ボリスZbarsky、ブレット・スラットキン、ブライアン・ケル、ブライアンMcBarron、ブライアン・ペイン、ブライアンRaymor、ブライアン・スミス、ブルース・ペレンズ、ブライスネスビット、キャメロンHeavon・ジョーンズ、カール・クーグラー、カルステンボルマン、チャールズフライ、クリスBurdess、クリス・ニューマン、クリスチャンのHuitema、サイラスDaboo、デイル・ロバート・アンダーソン、ダン・ウィング、ダン・ウィンシップ、ダニエル・ステンバーグ、ダレル・ミラー、デイブCridland、デイブ・クロッカー、デイブ・クリストル、デーブターラー、デビッド・ブース、デビッド・シンガー、デヴィッド・W 。モリス、ディワカシェティ、ドミトリーKurochkドラモンド・リード、デュアン・ウェッセル、エドワード・リー、エイタン・アドラー、エリオット・リア、エミール・ステファン、エランハンマー -  Lahav、エリック・D.ウィリアムズ、エリックJ.ボーマン、エリック・ローレンス、エリックレスコラ、エリックAronesty、EungJun李、エバン・プロドロームー、中、フェリックスGeisendoerfer、フロリアンWeimerさん、フランク・Ellermann、フレッドAkalin、フレッド・ボーレ、フレデリック・カイザー、ガボール・モルナー、ガブリエルモンテネグロ、ジェフリー・スネドン、ガーバス・マークハム、ギリTzabari、グラハムグリーブ、グレッグSlepak、グレッグ・ウィルキンス、グジェゴシCalkowski、ハラルド・トバイット・アルベストランド、ハリーハルピン、ヘルゲヘス、ヘンリック・ノードストローム、ヘンリーS.トンプソン、ヘンリー・ストーリー、ハーバート・バン・デ・ソンペル、エルベRuellan、ハワードMelman、ヒューゴ・ハース、イアンたFette、イアン・ヒクソン、イドSafruti、Ilari Liusvaara、イルヤ・グリゴリク、インゴが打た、J.ロス・ニコル、ジェームズCloos、ジェームズ・H.マネージャ、ジェームス・レイシー、ジェームズ・M.スネル、ジェイミー"
    },
    {
      "indent": 3,
      "text": "Lokier, Jan Algermissen, Jari Arkko, Jeff Hodges (who came up with the term 'effective Request-URI'), Jeff Pinner, Jeff Walden, Jim Luther, Jitu Padhye, Joe D. Williams, Joe Gregorio, Joe Orton, Joel Jaeggli, John C. Klensin, John C. Mallery, John Cowan, John Kemp, John Panzer, John Schneider, John Stracke, John Sullivan, Jonas Sicking, Jonathan A. Rees, Jonathan Billington, Jonathan Moore, Jonathan Silvera, Jordi Ros, Joris Dobbelsteen, Josh Cohen, Julien Pierre, Jungshik Shin, Justin Chapweske, Justin Erenkrantz, Justin James, Kalvinder Singh, Karl Dubost, Kathleen Moriarty, Keith Hoffman, Keith Moore, Ken Murchison, Koen Holtman, Konstantin Voronkov, Kris Zyp, Leif Hedstrom, Lionel Morand, Lisa Dusseault, Maciej Stachowiak, Manu Sporny, Marc Schneider, Marc Slemko, Mark Baker, Mark Pauley, Mark Watson, Markus Isomaki, Markus Lanthaler, Martin J. Duerst, Martin Musatov, Martin Nilsson, Martin Thomson, Matt Lynch, Matthew Cox, Matthew Kerwin, Max Clark, Menachem Dodge, Meral Shirazipour, Michael Burrows, Michael Hausenblas, Michael Scharf, Michael Sweet, Michael Tuexen, Michael Welzl, Mike Amundsen, Mike Belshe, Mike Bishop, Mike Kelly, Mike Schinkel, Miles Sabin, Murray S. Kucherawy, Mykyta Yevstifeyev, Nathan Rixham, Nicholas Shanks, Nico Williams, Nicolas Alvarez, Nicolas Mailhot, Noah Slater, Osama Mazahir, Pablo Castro, Pat Hayes, Patrick R. McManus, Paul E. Jones, Paul Hoffman, Paul Marquess, Pete Resnick, Peter Lepeska, Peter Occil, Peter Saint-Andre, Peter Watkins, Phil Archer, Phil Hunt, Philippe Mougin, Phillip Hallam-Baker, Piotr Dobrogost, Poul-Henning Kamp, Preethi Natarajan, Rajeev Bector, Ray Polk, Reto Bachmann-Gmuer, Richard Barnes, Richard Cyganiak, Rob Trace, Robby Simpson, Robert Brewer, Robert Collins, Robert Mattson, Robert O'Callahan, Robert Olofsson, Robert Sayre, Robert Siemer, Robert de Wilde, Roberto Javier Godoy, Roberto Peon, Roland Zink, Ronny Widjaja, Ryan Hamilton, S. Mike Dierken, Salvatore Loreto, Sam Johnston, Sam Pullara, Sam Ruby, Saurabh Kulkarni, Scott Lawrence (who maintained the original issues list), Sean B. Palmer, Sean Turner, Sebastien Barnoud, Shane McCarron, Shigeki Ohtsu, Simon Yarde, Stefan Eissing, Stefan Tilkov, Stefanos Harhalakis, Stephane Bortzmeyer, Stephen Farrell, Stephen Kent, Stephen Ludin, Stuart Williams, Subbu Allamaraju, Subramanian Moonesamy, Susan Hares, Sylvain Hellegouarch, Tapan Divekar, Tatsuhiro Tsujikawa, Tatsuya Hayashi, Ted Hardie, Ted Lemon, Thomas Broyer, Thomas Fossati, Thomas Maslen, Thomas Nadeau, Thomas Nordin, Thomas Roessler, Tim Bray, Tim Morgan, Tim Olsen, Tom Zhou, Travis Snoozy, Tyler Close, Vincent Murphy, Wenbo Zhu, Werner Baumann, Wilbur Streett, Wilfredo Sanchez Vega, William A. Rowe Jr., William Chan, Willy Tarreau, Xiaoshu Wang, Yaron Goland, Yngve Nysaeter Pettersen, Yoav Nir, Yogesh Bang, Yuchung Cheng, Yutaka Oiwa, Yves Lafon (long-time member of the editor team), Zed A. Shaw, and Zhong Yu.",
      "ja": "Lokier、ヤンアルガーミッセン、ヤリArkko、ジェフ・ホッジス（用語「効果的なのRequest-URI」を思い付いた）、ジェフ・ピナー、ジェフ・ウォールデン、ジム・ルーサー、Jitu Padhye、ジョー・D.ウィリアムズ、ジョー・グレゴリオ、ジョー・オートン、ジョエルJaeggli 、ジョンC. Klensin、ジョン・C・マレリー、ジョン・コーワン、ジョン・ケンプ、ジョン・パンツァー、ジョン・シュナイダー、ジョンStracke、ジョン・サリバン、ジョナスSicking、ジョナサンA.リース、ジョナサン・ビリントン、ジョナサン・ムーア、ジョナサンSilveraの、ジョルディ・ロス、ヨリスDobbelsteen、ジョシュ・コーエン、ジュリアン・ピエール、Jungshik新、ジャスティンChapweske、ジャスティン・エレンクランツ、ジャスティン・ジェームス、Kalvinderシン、カールDubost、キャスリーン・モリアーティ、キース・ホフマン、キースムーア、ケンマーチソン、公園Holtman、コンスタンチン・ボロンコフ、クリスZyp、レイフHedstrom、ライオネル・モラン、リサDusseault、マシエジ・スタチョウィアック、マヌーSporny、マルク・シュナイダー、マルク・Slemko、マーク・ベイカー、マーク・ポーリー、マーク・ワトソン、マルクスIsomaki、マーカス・ランサラー、マーティン・J. Duerst、マーティンMusatov、マーティン・ニルソン、マーティン・トムソン、マット・リンチ、マシュー・コックス、マシューKerwinいつ、マックス・クラーク、メナヘムダッジ、Meral Shirazipoウル、マイケルバローズ、マイケルHausenblas、マイケル・シャーフ、マイケル・スウィート、マイケルTuexen、マイケルWelzl、マイク・アムンゼン、マイクBelshe、マイク・ビショップ、マイク・ケリー、マイク・シンケル、マイルセービン、マレーS. Kucherawy、Mykyta Yevstifeyev、ネイサンRixham、ニコラスシャンクス、ニコ・ウィリアムズ、ニコラス・アルバレス、ニコラスMailhot、ノア・スレーター、オサマMazahir、パブロ・カストロ、パット・ヘイズ、パトリック・R.マクマナス、ポール・E.ジョーンズ、ポール・ホフマン、ポール・マルケス、ピート・レズニック、ピーターLepeska、ピーターOccil、ピーター・サン-Andre、ピーター・ワトキンス、フィル・アーチャー、フィル・ハント、フィリップMougin、フィリップハラム - ベイカー、ピョートルDobrogost、ポール・ヘンイング・カンプ、プリシーNatarajan、ラジーブBector、レイ・ポルク、レトバッハマン-Gmuer、リチャード・バーンズ、リチャード・シガーニアック、ロブ・トレー​​ス、ロビー・シンプソン、ロバート・ブリューワー、ロバート・コリンズ、ロバート・マットソン、ロバートO'Callahan、ロバート・オロフソン、ロバート・セイヤー、ロバートSiemer、ロバート・デ・ワイルド、ロベルト・ハビエル・ゴドイ、ロベルトペオン、ローランド・ジンク、ロニーWidjaja、ライアンハミルトン、S.マイクDierken、サルヴァトーレ・ロレート、サム・ジョンストン、サムPullara、サム・ラブY、Saurabh Kulkarniさん、（元の問題のリストを維持）スコット・ローレンス、ショーンB.パーマー、ショーン・ターナー、セバスチャンBarnoud、シェーンマカロン、茂樹大津、サイモンYarde、ステファンEissing、ステファンTilkov氏、ステファノHarhalakis、ステファンBortzmeyer、スティーブン・ファレル、スティーブン・ケント、スティーブンLudin、スチュアート・ウィリアムズ、Subbu Allamaraju、サブラマニアンMoonesamy、スーザンノウサギ、シルヴァンHellegouarch、Tapan Divekar、達広辻川、達也林、テッドハーディー、テッド・レモン、トーマスBroyer、トーマス・フォッサーティ、トーマスMaslen、トーマスナドー、トーマスノルディン、トーマスレスラー、ティム・ブレイ、ティム・モーガン、ティム・オルセン、トム周、トラヴィスSnoozy、タイラー閉じる、ヴィンセントマーフィー、Wenbo朱、ヴェルナー・バウマン、ウィルバーStreett、ウィルフレッド・サンチェスベガ、ウィリアム・A.・ロウ・ジュニア、ウィリアム・チャン、ウィリーTarreau、Xiaoshu王、ヤロンGoland、Yngve Nysaeterペター、ヨアフニール、ヨーゲッシュバン、Yuchungチェン、豊大岩、イヴ・ラフォン（編集チームの長年のメンバー）、ゼッドA.ショー、そして忠ゆいます。"
    },
    {
      "indent": 3,
      "text": "See Section 16 of [RFC2616] for additional acknowledgements from prior revisions.",
      "ja": "前リビジョンからの追加の承認のために[RFC2616]のセクション16を参照してください。"
    },
    {
      "indent": 0,
      "text": "11. References",
      "section_title": true,
      "ja": "11.参考文献"
    },
    {
      "indent": 0,
      "text": "11.1. Normative References",
      "section_title": true,
      "ja": "11.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC0793] Postel, J., \"Transmission Control Protocol\", STD 7, RFC 793, September 1981.",
      "ja": "[RFC0793]ポステル、J.、 \"伝送制御プロトコル\"、STD 7、RFC 793、1981年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC1950] Deutsch, L. and J-L. Gailly, \"ZLIB Compressed Data Format Specification version 3.3\", RFC 1950, May 1996.",
      "ja": "[RFC1950]ドイツ、L.及びJ-L。 Gailly氏、 \"ZLIB圧縮データフォーマット仕様バージョン3.3\"、RFC 1950、1996年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC1951] Deutsch, P., \"DEFLATE Compressed Data Format Specification version 1.3\", RFC 1951, May 1996.",
      "ja": "[RFC1951]ドイツ、P.、 \"DEFLATE圧縮データフォーマット仕様バージョン1.3\"、RFC 1951、1996年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC1952] Deutsch, P., Gailly, J-L., Adler, M., Deutsch, L., and G. Randers-Pehrson, \"GZIP file format specification version 4.3\", RFC 1952, May 1996.",
      "ja": "[RFC1952]ドイツ、P.、Gailly氏、J-L。、アドラー、M.、ドイツ、L.、及びG.ラナス-Pehrson、 \"GZIPファイル形式仕様バージョン4.3\"、RFC 1952、1996年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC3986] Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform Resource Identifier (URI): Generic Syntax\", STD 66, RFC 3986, January 2005.",
      "ja": "[RFC3986]バーナーズ - リー、T.、フィールディング、R.、およびL. Masinter、 \"ユニフォームリソース識別子（URI）：汎用構文\"、STD 66、RFC 3986、2005年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC5234] Crocker, D., Ed. and P. Overell, \"Augmented BNF for Syntax Specifications: ABNF\", STD 68, RFC 5234, January 2008.",
      "ja": "[RFC5234]クロッカー、D.、エド。そして、P. Overell、 \"構文仕様のための増大しているBNF：ABNF\"、STD 68、RFC 5234、2008年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC7231] Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content\", RFC 7231, June 2014.",
      "ja": "[RFC7231]フィールディング、R.、エド。そして、J. Reschke、エド、 \"ハイパーテキスト転送プロトコル（HTTP / 1.1）：セマンティクスおよびコンテンツ\"、RFC 7231、2014年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC7232] Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests\", RFC 7232, June 2014.",
      "ja": "[RFC7232]フィールディング、R.、エド。 。とJ. Reschke、エド、 \"ハイパーテキスト転送プロトコル（HTTP / 1.1）：条件付きリクエスト\"、RFC 7232、2014年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC7233] Fielding, R., Ed., Lafon, Y., Ed., and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Range Requests\", RFC 7233, June 2014.",
      "ja": "[RFC7233]フィールディング、R.、エド、ラフォン、Y.、エド、及びJ. Reschke、編、 \"ハイパーテキスト転送プロトコル（HTTP / 1.1）：範囲要求\"。。。、RFC 7233、2014年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC7234] Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Caching\", RFC 7234, June 2014.",
      "ja": "[RFC7234]フィールディング、R.、エド、ノッティンガム、M.、エド、及びJ. Reschke、編、 \"ハイパーテキスト転送プロトコル（HTTP / 1.1）：キャッシュ\"。。。、RFC 7234、2014年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC7235] Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Authentication\", RFC 7235, June 2014.",
      "ja": "[RFC7235]フィールディング、R.、エド。そして、J. Reschke、エド、 \"ハイパーテキスト転送プロトコル（HTTP / 1.1）：認証\"、RFC 7235、2014年6月。"
    },
    {
      "indent": 3,
      "text": "[USASCII] American National Standards Institute, \"Coded Character Set -- 7-bit American Standard Code for Information Interchange\", ANSI X3.4, 1986.",
      "ja": "「 - 情報交換のための7ビットの米国標準コードコード化文字セット」、ANSI X3.4、1986 [USASCII]米国規格協会、。"
    },
    {
      "indent": 3,
      "text": "[Welch] Welch, T., \"A Technique for High-Performance Data Compression\", IEEE Computer 17(6), June 1984.",
      "ja": "[ウェルチ]ウェルチ、T.、 \"高性能データ圧縮のための技術\"、IEEEコンピュータ17（6）、1984年6月。"
    },
    {
      "indent": 0,
      "text": "11.2. Informative References",
      "section_title": true,
      "ja": "11.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[BCP115] Hansen, T., Hardie, T., and L. Masinter, \"Guidelines and Registration Procedures for New URI Schemes\", BCP 115, RFC 4395, February 2006.",
      "ja": "[BCP115]ハンセン、T.、ハーディ、T.、およびL. Masinter、 \"新しいURIスキームのためのガイドラインと登録手順\"、BCP 115、RFC 4395、2006年2月。"
    },
    {
      "indent": 3,
      "text": "[BCP13] Freed, N., Klensin, J., and T. Hansen, \"Media Type Specifications and Registration Procedures\", BCP 13, RFC 6838, January 2013.",
      "ja": "[BCP13]、N.、Klensin、J.、およびT.ハンセン、 \"メディアタイプの仕様と登録手順\"、BCP 13、RFC 6838、2013年1月を解放しました。"
    },
    {
      "indent": 3,
      "text": "[BCP90] Klyne, G., Nottingham, M., and J. Mogul, \"Registration Procedures for Message Header Fields\", BCP 90, RFC 3864, September 2004.",
      "ja": "[BCP90] Klyne、G.、ノッティンガム、M.、およびJ.モーグル、 \"メッセージヘッダフィールドの登録手順\"、BCP 90、RFC 3864、2004年9月。"
    },
    {
      "indent": 3,
      "text": "[Georgiev] Georgiev, M., Iyengar, S., Jana, S., Anubhai, R., Boneh, D., and V. Shmatikov, \"The Most Dangerous Code in the World: Validating SSL Certificates in Non-browser Software\", In Proceedings of the 2012 ACM Conference on Computer and Communications Security (CCS '12), pp. 38-49, October 2012, <http://doi.acm.org/10.1145/2382196.2382204>.",
      "ja": "[ゲオルギエフ]ゲオルギエフ、M.、アイアンガー、S.、ジャナ、S.、Anubhai、R.、Boneh、D.、およびV. Shmatikov、「世界で最も危険なコード：ブラウザ以外のソフトウェアで検証SSL証明書」、コンピュータおよび通信セキュリティ上の2012 ACM会議議事録（CCS '12）、頁38-49、2012年10月には、<http://doi.acm.org/10.1145/2382196.2382204>。"
    },
    {
      "indent": 3,
      "text": "[ISO-8859-1] International Organization for Standardization, \"Information technology -- 8-bit single-byte coded graphic character sets -- Part 1: Latin alphabet No. 1\", ISO/IEC 8859-1:1998, 1998.",
      "ja": "[ISO-8859-1]国際標準化機構、 \"情報技術 -  8ビットシングルバイトコード化されたグラフィック文字集合 - 第1部：ラテンアルファベット1号\"、ISO / IEC 8859-1：1998、1998。"
    },
    {
      "indent": 3,
      "text": "[Klein] Klein, A., \"Divide and Conquer - HTTP Response Splitting, Web Cache Poisoning Attacks, and Related Topics\", March 2004, <http://packetstormsecurity.com/ papers/general/whitepaper_httpresponse.pdf>.",
      "ja": "[クライン]クライン、A.、 \"分割統治 -  HTTPレスポンス分割、Webキャッシュ汚染攻撃、および関連トピック\"、2004年3月、<http://packetstormsecurity.com/論文/一般/ whitepaper_httpresponse.pdf>。"
    },
    {
      "indent": 3,
      "text": "[Kri2001] Kristol, D., \"HTTP Cookies: Standards, Privacy, and Politics\", ACM Transactions on Internet Technology 1(2), November 2001, <http://arxiv.org/abs/cs.SE/0105018>.",
      "ja": "[Kri2001]クリストル、D.、 \"HTTPクッキー：標準、個人情報保護、および政治\" インターネット技術1に、ACMの取引（2）、2001年11月、<http://arxiv.org/abs/cs.SE/0105018> 。"
    },
    {
      "indent": 3,
      "text": "[Linhart] Linhart, C., Klein, A., Heled, R., and S. Orrin, \"HTTP Request Smuggling\", June 2005, <http://www.watchfire.com/news/whitepapers.aspx>.",
      "ja": "[Linhart] Linhart、C.、クライン、A.、Heled、R.、およびS.オリン、 \"HTTPリクエスト密輸\" 2005年6月、<http://www.watchfire.com/news/whitepapers.aspx>。"
    },
    {
      "indent": 3,
      "text": "[RFC1919] Chatel, M., \"Classical versus Transparent IP Proxies\", RFC 1919, March 1996.",
      "ja": "[RFC1919]シャテル、M.、 \"透明なIPプロキシ対クラシック\"、RFC 1919、1996年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC1945] Berners-Lee, T., Fielding, R., and H. Nielsen, \"Hypertext Transfer Protocol -- HTTP/1.0\", RFC 1945, May 1996.",
      "ja": "[RFC1945]バーナーズ=リー、T.、フィールディング、R.、およびH.ニールセン、 \"ハイパーテキスト転送プロトコル -  HTTP / 1.0\"、RFC 1945、1996年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC2045] Freed, N. and N. Borenstein, \"Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies\", RFC 2045, November 1996.",
      "ja": "[RFC2045]解放され、N.とN. Borenstein、 \"マルチパーパスインターネットメールエクステンション（MIME）第一部：インターネットメッセージ本体のフォーマット\"、RFC 2045、1996年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC2047] Moore, K., \"MIME (Multipurpose Internet Mail Extensions) Part Three: Message Header Extensions for Non-ASCII Text\", RFC 2047, November 1996.",
      "ja": "[RFC2047]ムーア、K.、 \"MIME（多目的インターネットメール拡張）パート3：非ASCIIテキストのためのメッセージヘッダの拡張\"、RFC 2047、1996年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC2068] Fielding, R., Gettys, J., Mogul, J., Nielsen, H., and T. Berners-Lee, \"Hypertext Transfer Protocol -- HTTP/1.1\", RFC 2068, January 1997.",
      "ja": "[RFC2068]フィールディング、R.、ゲティス、J.、モーグル、J.、ニールセン、H.、およびT.バーナーズ - リー、 \"ハイパーテキスト転送プロトコル -  HTTP / 1.1\"、RFC 2068、1997年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC2145] Mogul, J., Fielding, R., Gettys, J., and H. Nielsen, \"Use and Interpretation of HTTP Version Numbers\", RFC 2145, May 1997.",
      "ja": "[RFC2145]モーグル、J.、フィールディング、R.、ゲティス、J.、およびH.ニールセン、 \"使用とHTTPバージョン番号の解釈\"、RFC 2145、1997月。"
    },
    {
      "indent": 3,
      "text": "[RFC2616] Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P., and T. Berners-Lee, \"Hypertext Transfer Protocol -- HTTP/1.1\", RFC 2616, June 1999.",
      "ja": "[RFC2616]フィールディング、R.、ゲティス、J.、モーグル、J.、Frystyk、H.、Masinter、L.、リーチ、P.、およびT.バーナーズ - リー、 \"ハイパーテキスト転送プロトコル -  HTTP / 1.1\" 、RFC 2616、1999年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC2817] Khare, R. and S. Lawrence, \"Upgrading to TLS Within HTTP/1.1\", RFC 2817, May 2000.",
      "ja": "[RFC2817] Khare、R.およびS.ローレンス、 \"HTTP / 1.1内でTLSへのアップグレード\"、RFC 2817、2000年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC2818] Rescorla, E., \"HTTP Over TLS\", RFC 2818, May 2000.",
      "ja": "[RFC2818]レスコラ、E.、 \"TLSオーバーHTTP\"、RFC 2818、2000年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC3040] Cooper, I., Melve, I., and G. Tomlinson, \"Internet Web Replication and Caching Taxonomy\", RFC 3040, January 2001.",
      "ja": "[RFC3040]クーパー、I.、Melve、I.、およびG.トムリンソン、 \"インターネットのWebレプリケーションおよびキャッシング分類学\"、RFC 3040、2001年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC4033] Arends, R., Austein, R., Larson, M., Massey, D., and S. Rose, \"DNS Security Introduction and Requirements\", RFC 4033, March 2005.",
      "ja": "[RFC4033]アレンズ、R.、Austeinと、R.、ラーソン、M.、マッシー、D.、およびS.ローズ、 \"DNSセキュリティ序論と要件\"、RFC 4033、2005年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC4559] Jaganathan, K., Zhu, L., and J. Brezak, \"SPNEGO-based Kerberos and NTLM HTTP Authentication in Microsoft Windows\", RFC 4559, June 2006.",
      "ja": "[RFC4559] Jaganathan、K.、朱、L.、およびJ. Brezak、 \"Microsoft WindowsでのSPNEGOベースのKerberosとNTLM HTTP認証\"、RFC 4559、2006年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC5226] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 5226, May 2008.",
      "ja": "[RFC5226] Narten氏、T.とH. Alvestrand、 \"RFCsにIANA問題部に書くためのガイドライン\"、BCP 26、RFC 5226、2008年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC5246] Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS) Protocol Version 1.2\", RFC 5246, August 2008.",
      "ja": "[RFC5246]ダークス、T.およびE.レスコラ、 \"トランスポート層セキュリティ（TLS）プロトコルバージョン1.2\"、RFC 5246、2008年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC5322] Resnick, P., \"Internet Message Format\", RFC 5322, October 2008.",
      "ja": "[RFC5322]レズニック、P.、 \"インターネットメッセージ形式\"、RFC 5322、2008年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC6265] Barth, A., \"HTTP State Management Mechanism\", RFC 6265, April 2011.",
      "ja": "[RFC6265]バース、A.、 \"HTTP状態管理機構\"、RFC 6265、2011年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC6585] Nottingham, M. and R. Fielding, \"Additional HTTP Status Codes\", RFC 6585, April 2012.",
      "ja": "[RFC6585]ノッティンガム、M.とR.フィールディング、 \"追加のHTTPステータスコード\"、RFC 6585、2012年4月。"
    },
    {
      "indent": 0,
      "text": "Appendix A. HTTP Version History",
      "ja": "付録A. HTTPのバージョン履歴"
    },
    {
      "indent": 3,
      "text": "HTTP has been in use since 1990. The first version, later referred to as HTTP/0.9, was a simple protocol for hypertext data transfer across the Internet, using only a single request method (GET) and no metadata. HTTP/1.0, as defined by [RFC1945], added a range of request methods and MIME-like messaging, allowing for metadata to be transferred and modifiers placed on the request/response semantics. However, HTTP/1.0 did not sufficiently take into consideration the effects of hierarchical proxies, caching, the need for persistent connections, or name-based virtual hosts. The proliferation of incompletely implemented applications calling themselves \"HTTP/1.0\" further necessitated a protocol version change in order for two communicating applications to determine each other's true capabilities.",
      "ja": "HTTPは、後にHTTP / 0.9と呼ばれる1990年最初のバージョン以来使用されている、単一のリクエストメソッド（GET）とないメタデータを使用して、インターネットを介したハイパーテキストデータ転送のための単純なプロトコルでした。 [RFC1945]で定義されるようにHTTP / 1.0は、転送され、改質剤は、要求/応答セマンティクスに配置するメタデータを考慮して、要求の方法およびMIME状メッセージングの範囲を添加し​​ました。しかし、HTTP / 1.0を十分に考慮した階層プロキシ、キャッシング、持続的な接続の必要性、または名前ベースのバーチャルホストの影響を取ることはありませんでした。 「HTTP / 1.0」自分自身を呼び出す不完全実装したアプリケーションの普及はさらにお互いの本当の能力を決定するために、2つの通信アプリケーションのための順序でプロトコルバージョンの変更を必要としました。"
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 remains compatible with HTTP/1.0 by including more stringent requirements that enable reliable implementations, adding only those features that can either be safely ignored by an HTTP/1.0 recipient or only be sent when communicating with a party advertising conformance with HTTP/1.1.",
      "ja": "HTTP / 1.1は、HTTPとパーティ広告の適合性と通信するときにどちらかの安全にHTTP / 1.0受信者によって無視することができますかのみ送信することだけが機能を追加し、信頼性の高い実装を可能にする、より厳格な要件を含めることによって、HTTP / 1.0との互換性を維持/ 1.1 。"
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 has been designed to make supporting previous versions easy. A general-purpose HTTP/1.1 server ought to be able to understand any valid request in the format of HTTP/1.0, responding appropriately with an HTTP/1.1 message that only uses features understood (or safely ignored) by HTTP/1.0 clients. Likewise, an HTTP/1.1 client can be expected to understand any valid HTTP/1.0 response.",
      "ja": "HTTP / 1.1は、簡単に以前のバージョンをサポートするように設計されています。汎用HTTP / 1.1サーバは、HTTP / 1.0クライアントによって特徴理解（または無視）を使用してHTTP / 1.1メッセージで適切に応答する、HTTP / 1.0の形式で任意の有効な要求を理解することができるべきです。同様に、HTTP / 1.1クライアントは、任意の有効なHTTP / 1.0の応答を理解することが期待できます。"
    },
    {
      "indent": 3,
      "text": "Since HTTP/0.9 did not support header fields in a request, there is no mechanism for it to support name-based virtual hosts (selection of resource by inspection of the Host header field). Any server that implements name-based virtual hosts ought to disable support for HTTP/0.9. Most requests that appear to be HTTP/0.9 are, in fact, badly constructed HTTP/1.x requests caused by a client failing to properly encode the request-target.",
      "ja": "HTTP / 0.9リクエストのヘッダフィールドをサポートしなかったので、それは名前ベースのバーチャルホスト（Hostヘッダーフィールドの検査によってリソースの選択）をサポートするためのメカニズムはありません。名前ベースのバーチャルホストを実装している任意のサーバはHTTP / 0.9のサポートを無効にするべきです。 HTTP / 0.9のように見えるほとんどの要求は、実際には、ひどく適切に要求ターゲットをエンコードするために失敗し、クライアントによって引き起こされるHTTP / 1.1リクエストを構築しています。"
    },
    {
      "indent": 0,
      "text": "A.1. Changes from HTTP/1.0",
      "ja": "A.1。 HTTP / 1.0からの変更点"
    },
    {
      "indent": 3,
      "text": "This section summarizes major differences between versions HTTP/1.0 and HTTP/1.1.",
      "ja": "このセクションでは、バージョンHTTP / 1.0とHTTP / 1.1の主な違いをまとめたもの。"
    },
    {
      "indent": 0,
      "text": "A.1.1. Multihomed Web Servers",
      "ja": "A.1.1。マルチホームWebサーバー"
    },
    {
      "indent": 3,
      "text": "The requirements that clients and servers support the Host header field (Section 5.4), report an error if it is missing from an HTTP/1.1 request, and accept absolute URIs (Section 5.3) are among the most important changes defined by HTTP/1.1.",
      "ja": "クライアントとサーバは、それがHTTP / 1.1リクエストから欠落している場合、エラーを報告し、Hostヘッダフィールド（5.4節）をサポートし、絶対的なURI（セクション5.3）を受け入れ要件は、HTTP / 1.1で定義された最も重要な変更の一つです。"
    },
    {
      "indent": 3,
      "text": "Older HTTP/1.0 clients assumed a one-to-one relationship of IP addresses and servers; there was no other established mechanism for distinguishing the intended server of a request than the IP address to which that request was directed. The Host header field was introduced during the development of HTTP/1.1 and, though it was quickly implemented by most HTTP/1.0 browsers, additional requirements were placed on all HTTP/1.1 requests in order to ensure complete adoption. At the time of this writing, most HTTP-based services are dependent upon the Host header field for targeting requests.",
      "ja": "古いHTTP / 1.0クライアントは、IPアドレスやサーバの1対1の関係を仮定しました。その要求が向けられた先のIPアドレスより要求の意図したサーバーを区別するための他の確立されたメカニズムがありませんでした。 Hostヘッダフィールドは、HTTP / 1.1の開発中に導入されたと、それはすぐにほとんどのHTTP / 1.0のブラウザで実装されたものの、追加要件を完全に採用を確保するために、すべてのHTTP / 1.1リクエストの上に置きました。この記事の執筆時点では、ほとんどのHTTPベースのサービスは、リクエストをターゲットのホストヘッダーフィールドに依存しています。"
    },
    {
      "indent": 0,
      "text": "A.1.2. Keep-Alive Connections",
      "ja": "A.1.2。キープアライブ接続"
    },
    {
      "indent": 3,
      "text": "In HTTP/1.0, each connection is established by the client prior to the request and closed by the server after sending the response. However, some implementations implement the explicitly negotiated (\"Keep-Alive\") version of persistent connections described in Section 19.7.1 of [RFC2068].",
      "ja": "HTTP / 1.0では、各接続が要求前にクライアントによって確立され、応答を送信した後、サーバーによって閉じ。しかし、いくつかの実装は、[RFC2068]のセクション19.7.1で説明した持続的な接続の明示的に交渉（「キープアライブ」）バージョンを実装しています。"
    },
    {
      "indent": 3,
      "text": "Some clients and servers might wish to be compatible with these previous approaches to persistent connections, by explicitly negotiating for them with a \"Connection: keep-alive\" request header field. However, some experimental implementations of HTTP/1.0 persistent connections are faulty; for example, if an HTTP/1.0 proxy server doesn't understand Connection, it will erroneously forward that header field to the next inbound server, which would result in a hung connection.",
      "ja": "「：キープアライブ接続」リクエストヘッダフィールド一部のクライアントとサーバは、明示的に彼らのために交渉することによって、持続的な接続にこれらの従来のアプローチと互換性があることを望むかもしれません。しかし、HTTP / 1.0の永続的な接続のいくつかの実験的な実装が故障しています。 HTTP / 1.0プロキシサーバが接続を理解していない場合、例えば、それが誤っハング接続をもたらすであろう次のインバウンドサーバにそのヘッダフィールドを転送します。"
    },
    {
      "indent": 3,
      "text": "One attempted solution was the introduction of a Proxy-Connection header field, targeted specifically at proxies. In practice, this was also unworkable, because proxies are often deployed in multiple layers, bringing about the same problem discussed above.",
      "ja": "一つの試み溶液をプロキシに特異的に標的プロキシ接続ヘッダフィールドの導入でした。プロキシが、多くの場合、上記の同じ問題をもたらす、複数の層に配置されているので、実際には、これは、また、実行不可能でした。"
    },
    {
      "indent": 3,
      "text": "As a result, clients are encouraged not to send the Proxy-Connection header field in any requests.",
      "ja": "その結果、クライアントはすべての要求にプロキシ接続のヘッダフィールドを送信しないように奨励されています。"
    },
    {
      "indent": 3,
      "text": "Clients are also encouraged to consider the use of Connection: keep-alive in requests carefully; while they can enable persistent connections with HTTP/1.0 servers, clients using them will need to monitor the connection for \"hung\" requests (which indicate that the client ought stop sending the header field), and this mechanism ought not be used by clients at all when a proxy is being used.",
      "ja": "クライアントは、接続の使用を検討することが推奨されています。キープアライブ要求に慎重に。彼らはHTTP / 1.0のサーバとの永続的な接続を可能にすることができますが、それらを使用しているクライアントは、（クライアントはヘッダフィールドの送信を停止べきであることを示す）要求を「ハング」、およびこの機構がでクライアントが使用するべきではないため、接続を監視する必要があります。すべてのプロキシが使用されているとき。"
    },
    {
      "indent": 0,
      "text": "A.1.3. Introduction of Transfer-Encoding",
      "ja": "A.1.3。転送エンコードのご紹介"
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 introduces the Transfer-Encoding header field (Section 3.3.1). Transfer codings need to be decoded prior to forwarding an HTTP message over a MIME-compliant protocol.",
      "ja": "HTTP / 1.1は、転送エンコードヘッダーフィールド（セクション3.3.1）に導入します。転送コーディングは、MIME準拠のプロトコルを介してHTTPメッセージを転送する前に復号化される必要があります。"
    },
    {
      "indent": 1,
      "text": "A.2. Changes from",
      "ja": "A.2。からの変更点"
    },
    {
      "indent": 3,
      "text": "HTTP's approach to error handling has been explained. (Section 2.5)",
      "ja": "エラー処理するHTTPのアプローチが説明されています。 （2.5節）"
    },
    {
      "indent": 3,
      "text": "The HTTP-version ABNF production has been clarified to be case-sensitive. Additionally, version numbers have been restricted to single digits, due to the fact that implementations are known to handle multi-digit version numbers incorrectly. (Section 2.6)",
      "ja": "HTTP-バージョンABNF生産は大文字と小文字を区別ことが明らかにされています。また、バージョン番号が原因の実装が誤って複数桁のバージョン番号を処理することが知られているという事実のために、一桁に制限されています。 （2.6節）"
    },
    {
      "indent": 3,
      "text": "Userinfo (i.e., username and password) are now disallowed in HTTP and HTTPS URIs, because of security issues related to their transmission on the wire. (Section 2.7.1)",
      "ja": "UserInfo（つまり、ユーザ名とパスワード）は、今あるため、ワイヤ上での伝送に関連するセキュリティ上の問題により、HTTPおよびHTTPSのURIで禁止されています。 （2.7.1項）"
    },
    {
      "indent": 3,
      "text": "The HTTPS URI scheme is now defined by this specification; previously, it was done in Section 2.4 of [RFC2818]. Furthermore, it implies end-to-end security. (Section 2.7.2)",
      "ja": "HTTPS URIスキームは今、この仕様で定義されます。以前、それは[RFC2818]の2.4節で行いました。また、エンドツーエンドのセキュリティを意味します。 （2.7.2項）"
    },
    {
      "indent": 3,
      "text": "HTTP messages can be (and often are) buffered by implementations; despite it sometimes being available as a stream, HTTP is fundamentally a message-oriented protocol. Minimum supported sizes for various protocol elements have been suggested, to improve interoperability. (Section 3)",
      "ja": "HTTPメッセージは、実装によってバッファリングすること（そしてしばしばある）ことができます。それは時々ストリームとして利用可能であるにもかかわらず、HTTPは、基本的に、メッセージ指向のプロトコルです。様々なプロトコル要素でサポートされる最小サイズは、相互運用性を向上させるために、提案されています。 （第3節）"
    },
    {
      "indent": 3,
      "text": "Invalid whitespace around field-names is now required to be rejected, because accepting it represents a security vulnerability. The ABNF productions defining header fields now only list the field value. (Section 3.2)",
      "ja": "フィールド名の周りの無効な空白は今、それを受け入れることは、セキュリティ上の脆弱性を表しているので、拒否される必要があります。ヘッダフィールドを定義するABNFプロダクションは現在、唯一のフィールド値を一覧表示します。 （3.2節）"
    },
    {
      "indent": 3,
      "text": "Rules about implicit linear whitespace between certain grammar productions have been removed; now whitespace is only allowed where specifically defined in the ABNF. (Section 3.2.3)",
      "ja": "特定の文法プロダクション間の暗黙的な線形の空白についてのルールが削除されました。特にABNFで定義されているところ、今の空白のみが許可されます。 （3.2.3項）"
    },
    {
      "indent": 3,
      "text": "Header fields that span multiple lines (\"line folding\") are deprecated. (Section 3.2.4)",
      "ja": "（「ライン折りたたみ」）を複数行にまたがるヘッダーフィールドは廃止されました。 （3.2.4項）"
    },
    {
      "indent": 3,
      "text": "The NUL octet is no longer allowed in comment and quoted-string text, and handling of backslash-escaping in them has been clarified. The quoted-pair rule no longer allows escaping control characters other than HTAB. Non-US-ASCII content in header fields and the reason phrase has been obsoleted and made opaque (the TEXT rule was removed). (Section 3.2.6)",
      "ja": "NULオクテットはもはやコメントと引用符で囲まれた文字列のテキストでは許可されていない、とバックスラッシュエスケープそれらでの取り扱いは明らかにされています。引用されたペアのルールは、もはやHTAB以外の制御文字をエスケープすることができません。ヘッダフィールドでの非US-ASCIIの内容と理由句は廃止と（TEXTルールが削除された）不透明にされています。 （3.2.6項）"
    },
    {
      "indent": 3,
      "text": "Bogus Content-Length header fields are now required to be handled as errors by recipients. (Section 3.3.2)",
      "ja": "偽のContent-Lengthヘッダフィールドは、現在の受信者がエラーとして扱うことが要求されます。 （3.3.2）"
    },
    {
      "indent": 3,
      "text": "The algorithm for determining the message body length has been clarified to indicate all of the special cases (e.g., driven by methods or status codes) that affect it, and that new protocol elements cannot define such special cases. CONNECT is a new, special case in determining message body length. \"multipart/byteranges\" is no longer a way of determining message body length detection. (Section 3.3.3)",
      "ja": "メッセージボディの長さを決定するためのアルゴリズムは、それに影響を与える特別な場合（例えば、方法またはステータスコードによって駆動される）の全てを示すために明らかにされており、その新たなプロトコル要素は、そのような特殊なケースを定義することはできません。 CONNECTメッセージ本体の長さを決定する新たな、特殊なケースです。 「マルチパート/ byteranges」もはやメッセージ本体の長さの検出を決定する方法はありません。 （3.3.3項）"
    },
    {
      "indent": 3,
      "text": "The \"identity\" transfer coding token has been removed. (Sections 3.3 and 4)",
      "ja": "「アイデンティティ」転送コーディングトークンが削除されました。 （セクション3.3および4）"
    },
    {
      "indent": 3,
      "text": "Chunk length does not include the count of the octets in the chunk header and trailer. Line folding in chunk extensions is disallowed. (Section 4.1)",
      "ja": "チャンクの長さはチャンクヘッダとトレーラのオクテットのカウントが含まれていません。チャンクの拡張機能で行折り畳みが許可されていません。 （4.1節）"
    },
    {
      "indent": 3,
      "text": "The meaning of the \"deflate\" content coding has been clarified. (Section 4.2.2)",
      "ja": "コンテンツのコーディングを「収縮」の意味が明らかにされています。 （4.2.2）"
    },
    {
      "indent": 3,
      "text": "The segment + query components of RFC 3986 have been used to define the request-target, instead of abs_path from RFC 1808. The asterisk-form of the request-target is only allowed with the OPTIONS method. (Section 5.3)",
      "ja": "RFC 3986のセグメント+クエリコンポーネントは、リクエスト対象のアスタリスク状のみOPTIONSメソッドで許可されているRFC 1808の代わり腹筋_経路を、要求目標を定義するために使用されてきました。 （5.3節）"
    },
    {
      "indent": 3,
      "text": "The term \"Effective Request URI\" has been introduced. (Section 5.5)",
      "ja": "用語「効果的なリクエストURIは」導入されました。 （5.5節）"
    },
    {
      "indent": 3,
      "text": "Gateways do not need to generate Via header fields anymore. (Section 5.7.1)",
      "ja": "ゲートウェイはもうViaヘッダーフィールドを生成する必要はありません。 （5.7.1項）"
    },
    {
      "indent": 3,
      "text": "Exactly when \"close\" connection options have to be sent has been clarified. Also, \"hop-by-hop\" header fields are required to appear in the Connection header field; just because they're defined as hop-by-hop in this specification doesn't exempt them. (Section 6.1)",
      "ja": "正確には「クローズ」接続オプションを送らなければならないとき明らかにされています。また、「ホップバイホップ」ヘッダフィールドは、Connectionヘッダフィールドに表示するために必要とされます。彼らは次のように定義しているからといって、ホップバイホップこの仕様では、それらを除外しません。 （6.1節）"
    },
    {
      "indent": 3,
      "text": "The limit of two connections per server has been removed. An idempotent sequence of requests is no longer required to be retried. The requirement to retry requests under certain circumstances when the server prematurely closes the connection has been removed. Also, some extraneous requirements about when servers are allowed to close connections prematurely have been removed. (Section 6.3)",
      "ja": "サーバーごとに2つの接続の制限が削除されました。リクエストの冪等のシーケンスは、もは​​や再試行する必要はありません。サーバーが途中で接続が閉じられたときに、特定の状況下で、要求を再試行するための要件は削除されました。また、サーバが早まって接続を閉じるように許可されている場合についていくつかの余分な要件が削除されました。 （6.3節）"
    },
    {
      "indent": 3,
      "text": "The semantics of the Upgrade header field is now defined in responses other than 101 (this was incorporated from [RFC2817]). Furthermore, the ordering in the field value is now significant. (Section 6.7)",
      "ja": "アップグレードヘッダフィールドのセマンティクスは、現在（これは[RFC2817]から取り込まれた）101以外の応答で定義されています。さらに、フィールド値の順序は今重要です。 （6.7節）"
    },
    {
      "indent": 3,
      "text": "Empty list elements in list productions (e.g., a list header field containing \", ,\") have been deprecated. (Section 7)",
      "ja": "リスト制作（例えば、含むリストヘッダフィールド「」）で空のリスト要素が廃止されています。 （第7章）"
    },
    {
      "indent": 3,
      "text": "Registration of Transfer Codings now requires IETF Review (Section 8.4)",
      "ja": "転送コーディングの登録は、現在IETFレビューを必要とする（8.4節）"
    },
    {
      "indent": 3,
      "text": "This specification now defines the Upgrade Token Registry, previously defined in Section 7.2 of [RFC2817]. (Section 8.6)",
      "ja": "この仕様は現在、以前に[RFC2817]のセクション7.2で定義された、アップグレードトークンレジストリを定義します。 （8.6節）"
    },
    {
      "indent": 3,
      "text": "The expectation to support HTTP/0.9 requests has been removed. (Appendix A)",
      "ja": "HTTP / 0.9リクエストをサポートするために期待が削除されました。 （付録A）"
    },
    {
      "indent": 3,
      "text": "Issues with the Keep-Alive and Proxy-Connection header fields in requests are pointed out, with use of the latter being discouraged altogether. (Appendix A.1.2)",
      "ja": "リクエストにキープアライブとプロキシ接続のヘッダフィールドの問題は完全に落胆後者を使用して、指摘されています。 （付録A.1.2）"
    },
    {
      "indent": 0,
      "text": "Appendix B. Collected ABNF",
      "ja": "ABNF収集付録B."
    },
    {
      "indent": 3,
      "text": "BWS = OWS",
      "ja": "BUS = OWS"
    },
    {
      "indent": 3,
      "text": "Connection = *( \",\" OWS ) connection-option *( OWS \",\" [ OWS connection-option ] )",
      "ja": "接続= *（ \"\" OWS）接続オプション*（OWS \"\" [OWS接続オプション]）"
    },
    {
      "indent": 3,
      "text": "Content-Length = 1*DIGIT",
      "ja": "Content-Length = 1 * DIGIT"
    },
    {
      "indent": 3,
      "text": "HTTP-message = start-line *( header-field CRLF ) CRLF [ message-body ] HTTP-name = %x48.54.54.50 ; HTTP HTTP-version = HTTP-name \"/\" DIGIT \".\" DIGIT Host = uri-host [ \":\" port ]",
      "ja": "HTTPメッセージ=開始行×（ヘッダフィールドCRLF）CRLF [メッセージ本体]をHTTP名=％x48.54.54.50。 HTTP HTTP-バージョン= HTTP-名 \"/\" DIGIT \"\" DIGITホスト= URI-ホスト[ \"：\" ポート]"
    },
    {
      "indent": 3,
      "text": "OWS = *( SP / HTAB )",
      "ja": "OWS = *（SP / HTAB）"
    },
    {
      "indent": 3,
      "text": "RWS = 1*( SP / HTAB )",
      "ja": "RWS = 1 *（SP / HTAB）"
    },
    {
      "indent": 3,
      "text": "TE = [ ( \",\" / t-codings ) *( OWS \",\" [ OWS t-codings ] ) ] Trailer = *( \",\" OWS ) field-name *( OWS \",\" [ OWS field-name ] ) Transfer-Encoding = *( \",\" OWS ) transfer-coding *( OWS \",\" [ OWS transfer-coding ] )",
      "ja": "TE = [（ \"\" / T-コーディング）*（OWS \"\" [OWS T-コーディング]）]トレーラー= *（ \"\" OWS）フィールド名*（OWS \"\" [OWSフィールド名] ）転送エンコード= *（ \"\" OWS）転送コーディング*（OWS \"\" [OWS転送コーディング]）"
    },
    {
      "indent": 3,
      "text": "URI-reference = <URI-reference, see [RFC3986], Section 4.1> Upgrade = *( \",\" OWS ) protocol *( OWS \",\" [ OWS protocol ] )",
      "ja": "URIリファレンス= <URI参照、[RFC3986]、セクション4.1を参照>アップグレード= *（ \"\" OWS）プロトコル*（OWS \"\" [OWSプロトコル]）"
    },
    {
      "indent": 3,
      "text": "Via = *( \",\" OWS ) ( received-protocol RWS received-by [ RWS comment ] ) *( OWS \",\" [ OWS ( received-protocol RWS received-by [ RWS comment ] ) ] )",
      "ja": "= *（ \"\" OWS）*（OWS \"\" [受信することにより[RWSコメント] OWS（受信プロトコルRWS）]）（受信により[RWSコメント]受信プロトコルRWS）を介して"
    },
    {
      "indent": 3,
      "text": "absolute-URI = <absolute-URI, see [RFC3986], Section 4.3> absolute-form = absolute-URI absolute-path = 1*( \"/\" segment ) asterisk-form = \"*\" authority = <authority, see [RFC3986], Section 3.2> authority-form = authority chunk = chunk-size [ chunk-ext ] CRLF chunk-data CRLF chunk-data = 1*OCTET chunk-ext = *( \";\" chunk-ext-name [ \"=\" chunk-ext-val ] ) chunk-ext-name = token chunk-ext-val = token / quoted-string chunk-size = 1*HEXDIG chunked-body = *chunk last-chunk trailer-part CRLF comment = \"(\" *( ctext / quoted-pair / comment ) \")\" connection-option = token ctext = HTAB / SP / %x21-27 ; '!'-''' / %x2A-5B ; '*'-'[' / %x5D-7E ; ']'-'~' / obs-text",
      "ja": "絶対URI =絶対形式=絶対URI絶対パス= 1 *（ \"/\" セグメント）アスタリスク状<絶対URIは、[RFC3986]、セクション4.3を参照> = \"*\" 権限= <権限、参照[ RFC3986]、セクション3.2>権限型=権限チャンク=チャンクサイズ[チャンク-EXT] CRLFチャンクデータCRLFチャンクデータ= 1 *オクテットチャンク-EXT = *（ \";\" チャンク-EXT-名[「= \"チャンク-EXT-VAL]）チャンク-EXT-名=トークンチャンク-EXT-VAL =トークン/引用符で囲まれた文字列のチャンクサイズ= 1 * HEXDIGチャンク-体= *チャンクの最後のチャンクトレーラーパーツCRLFコメント=\"（ 「*（CTEXT /引用されたペア/コメント） \"）、\" 接続オプション=トークンCTEXT = HTAB / SP /％x21-27; '！'  -  ''」/％のX2A-5B; '*'  -  '[' /％x5D-7E; ']'  -  '〜' / OBSテキスト"
    },
    {
      "indent": 3,
      "text": "field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ] field-name = token field-value = *( field-content / obs-fold ) field-vchar = VCHAR / obs-text fragment = <fragment, see [RFC3986], Section 3.5>",
      "ja": "フィールド・コンテンツ=フィールドvchar [1 *（SP / HTAB）フィールドvchar]フィールド名=トークンフィールド値= *（フィールド・コンテンツ/ OBS倍）フィールドvchar = VCHAR / OBSテキスト断片= <フラグメント、[RFC3986]を見てください、セクション3.5>"
    },
    {
      "indent": 3,
      "text": "header-field = field-name \":\" OWS field-value OWS http-URI = \"http://\" authority path-abempty [ \"?\" query ] [ \"#\" fragment ] https-URI = \"https://\" authority path-abempty [ \"?\" query ] [ \"#\" fragment ]",
      "ja": "=フィールド名フィールドをヘッダー \"：\" OWSフィールド値OWSのhttp-URI = \"のhttp：//\" 権威パスabemptyの[を \"？\"クエリ] [ \"＃\" フラグメント] HTTPS-URI = \"https：//で\" 権威パスabemptyの[ \"？\"クエリ] [ \"＃\" フラグメント]"
    },
    {
      "indent": 3,
      "text": "last-chunk = 1*\"0\" [ chunk-ext ] CRLF",
      "ja": "最後のチャンク= 1 * \"0\" [チャンク-EXT] CRLF"
    },
    {
      "indent": 3,
      "text": "message-body = *OCTET method = token",
      "ja": "メッセージボディ= * OCTET方法=トークン"
    },
    {
      "indent": 3,
      "text": "obs-fold = CRLF 1*( SP / HTAB ) obs-text = %x80-FF origin-form = absolute-path [ \"?\" query ]",
      "ja": "OBS倍= CRLF 1 *（SP / HTAB）OBSテキスト=％X80-FF起点型=絶対パス[ \"？\"クエリ]"
    },
    {
      "indent": 3,
      "text": "partial-URI = relative-part [ \"?\" query ] path-abempty = <path-abempty, see [RFC3986], Section 3.3> port = <port, see [RFC3986], Section 3.2.3> protocol = protocol-name [ \"/\" protocol-version ] protocol-name = token protocol-version = token pseudonym = token",
      "ja": "部分的-URIは、相対的な部分の[を= \"？\"クエリ]パスabempty = <パスabempty、[RFC3986]を参照して、第3.3節>ポート= <ポート、参照[RFC3986]、セクション3.2.3>プロトコル=プロトコル名[ \"/\" プロトコルバージョン]プロトコル名=トークンプロトコルバージョン=トークン仮名=トークン"
    },
    {
      "indent": 3,
      "text": "qdtext = HTAB / SP / \"!\" / %x23-5B ; '#'-'[' / %x5D-7E ; ']'-'~' / obs-text query = <query, see [RFC3986], Section 3.4> quoted-pair = \"\\\" ( HTAB / SP / VCHAR / obs-text ) quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE",
      "ja": "qdtext = HTAB / SP / \"！\" /％x23-5B。 '＃'  -  '[' /％x5D-7E。 ']'  -  '〜' / OBSテキストクエリ= <クエリ、[RFC3986]を参照して、3.4節>引用されたペア= \"\\\"（HTAB / SP / VCHAR / OBS-テキスト）引用符で囲んだ文字列= DQUOTE *（qdtext /引用されたペア）DQUOTE"
    },
    {
      "indent": 3,
      "text": "rank = ( \"0\" [ \".\" *3DIGIT ] ) / ( \"1\" [ \".\" *3\"0\" ] ) reason-phrase = *( HTAB / SP / VCHAR / obs-text ) received-by = ( uri-host [ \":\" port ] ) / pseudonym received-protocol = [ protocol-name \"/\" ] protocol-version relative-part = <relative-part, see [RFC3986], Section 4.2> request-line = method SP request-target SP HTTP-version CRLF request-target = origin-form / absolute-form / authority-form / asterisk-form",
      "ja": "ランク=（ \"0\" [ \"\" * 3DIGIT]）/（ \"1\" [ \"\" * 3 \"0\"]）理由フレーズ= *（HTAB / SP / VCHAR / OBSテキスト）を受信することにより= （URI-ホスト[ \"：\" ポート]）/匿名受信プロトコル= [プロトコル名 \"/\"]プロトコルバージョン相対一部=要求ライン=法<相対一部、[RFC3986]、セクション4.2を参照> SP要求対象のSP HTTPバージョンのCRLF要求-対象=原点形式/絶対形式/権限-フォーム/アスタリスクフォーム"
    },
    {
      "indent": 3,
      "text": "scheme = <scheme, see [RFC3986], Section 3.1> segment = <segment, see [RFC3986], Section 3.3> start-line = request-line / status-line status-code = 3DIGIT status-line = HTTP-version SP status-code SP reason-phrase CRLF",
      "ja": "スキーム=スタートライン=要求ライン/ステータスラインステータスコード= 3DIGITステータスライン<[RFC3986]、セクション3.3を参照、セグメント>セグメント= <スキームは、セクション3.1、[RFC3986]参照> = HTTPバージョンSPステータスコードSP理由フレーズCRLF"
    },
    {
      "indent": 3,
      "text": "t-codings = \"trailers\" / ( transfer-coding [ t-ranking ] ) t-ranking = OWS \";\" OWS \"q=\" rank tchar = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\" / \"+\" / \"-\" / \".\" / \"^\" / \"_\" / \"`\" / \"|\" / \"~\" / DIGIT / ALPHA token = 1*tchar trailer-part = *( header-field CRLF ) transfer-coding = \"chunked\" / \"compress\" / \"deflate\" / \"gzip\" / transfer-extension transfer-extension = token *( OWS \";\" OWS transfer-parameter ) transfer-parameter = token BWS \"=\" BWS ( token / quoted-string )",
      "ja": "T-コーディング= \"トレーラー\" /（転送コーディング[T-ランキング]）T-ランク= OWS \";\" OWS \"Q =\" ランクTCHAR = \"！\" / \"＃\" / \"$\" / \"％\" / \"＆\" / \"'\" / \"*\" / \"+\" / \" - \" / \"。\" / \"^\" / \"_\" / \"`\"/ \"|\" / \"〜\" / DIGIT / ALPHA 1 =トークン* TCHARトレーラ部分= *（ヘッダフィールドCRLF）転送コーディング= \"チャンク\" / \"圧縮\" / \"収縮\" / \"GZIP\" /転送伸長転送伸長=トークン*（OWS \";\" OWS転送パラメータ）転送パラメータ=トークンBWS \"=\" BWS（トークン/引用符で囲まれた文字列）"
    },
    {
      "indent": 3,
      "text": "uri-host = <host, see [RFC3986], Section 3.2.2>",
      "ja": "URI-ホスト= <ホスト、参照[RFC3986]、セクション3.2.2>"
    },
    {
      "indent": 0,
      "text": "Index",
      "ja": "指数"
    },
    {
      "indent": 3,
      "text": "A absolute-form (of request-target) 42 accelerator 10 application/http Media Type 63 asterisk-form (of request-target) 43 authoritative response 67 authority-form (of request-target) 42-43",
      "ja": "42-43（要求対象の）43権威応答67権限型（要求対象の）42アクセル10アプリケーション/ HTTPメディアタイプ63アスタリスク状（要求対象の）絶対形式"
    },
    {
      "indent": 3,
      "text": "B browser 7",
      "ja": "Bブラウザ7"
    },
    {
      "indent": 3,
      "text": "C cache 11 cacheable 12 captive portal 11 chunked (Coding Format) 28, 32, 36 client 7 close 51, 56 compress (Coding Format) 38 connection 7 Connection header field 51, 56 Content-Length header field 30",
      "ja": "Cキャッシュ11のキャッシュ可能な12キャプティブポータル11は、チャンク（符号化フォーマット）28、32、36クライアント7近い51、56の圧縮（符号化フォーマット）38接続7接続ヘッダフィールド51、56 Content-Lengthヘッダフィールド30"
    },
    {
      "indent": 3,
      "text": "D deflate (Coding Format) 38 Delimiters 27 downstream 10",
      "ja": "DのDEFLATE（符号化フォーマット）38のデリミタ27下流10"
    },
    {
      "indent": 3,
      "text": "E effective request URI 45",
      "ja": "E効果的なリクエストURI 45"
    },
    {
      "indent": 3,
      "text": "G gateway 10 Grammar absolute-form 42 absolute-path 16 absolute-URI 16 ALPHA 6 asterisk-form 41, 43 authority 16 authority-form 42-43 BWS 25 chunk 36 chunk-data 36 chunk-ext 36 chunk-ext-name 36 chunk-ext-val 36 chunk-size 36 chunked-body 36 comment 27 Connection 51 connection-option 51 Content-Length 30 CR 6 CRLF 6 ctext 27 CTL 6 DIGIT 6 DQUOTE 6 field-content 23 field-name 23, 40 field-value 23 field-vchar 23 fragment 16 header-field 23, 37 HEXDIG 6 Host 44 HTAB 6 HTTP-message 19 HTTP-name 14 http-URI 17 HTTP-version 14 https-URI 18 last-chunk 36 LF 6 message-body 28 method 21 obs-fold 23 obs-text 27 OCTET 6 origin-form 42 OWS 25 partial-URI 16 port 16 protocol-name 47 protocol-version 47 pseudonym 47 qdtext 27 query 16 quoted-pair 27 quoted-string 27 rank 39 reason-phrase 22 received-by 47 received-protocol 47 request-line 21 request-target 41 RWS 25 scheme 16 segment 16 SP 6 start-line 21 status-code 22 status-line 22 t-codings 39 t-ranking 39 tchar 27 TE 39 token 27 Trailer 40 trailer-part 37 transfer-coding 35 Transfer-Encoding 28 transfer-extension 35 transfer-parameter 35 Upgrade 57 uri-host 16 URI-reference 16 VCHAR 6 Via 47 gzip (Coding Format) 39",
      "ja": "Gゲートウェイ10文法絶対形態42の絶対パス16絶対URI 16 ALPHA 6アスタリスク状41、43権限16権限状42-43 BWS 25チャンク36のチャンクデータチャンク36-EXT 36チャンク-EXT-名36チャンク-EXT-VAL 36チャンクサイズ36チャンクボディ36コメント27接続51接続オプション51のContent-Length 30 CR 6 CRLF 6 CTEXT 27 CTL 6 DIGIT 6 DQUOTE 6フィールド・コンテンツ23フィールド名23、40フィールド - 値23フィールドvchar 23断片16ヘッダフィールド23、37 HEXDIG 6ホスト44 HTAB 6 HTTPメッセージ19 HTTP名14 HTTP-URI 17 HTTPバージョン14 HTTPS-URI 18の最後のチャンク36 LF 6メッセージボディ28方法21 OBS倍23台のOBSテキスト27オクテット6原点形態42 OWS 25部分-URI 16ポート16プロトコル名47プロトコル・バージョン47仮名47 qdtext 27クエリ16引用対27引用符で囲まれた文字列27ランク39妥当語句22は、受信したバイ47受信プロトコル47リクエストライン21依頼ターゲット41 RWS 25スキーム16セグメント16 SP 6スタートライン21ステータスコード22のステータスライン22、T-コーディング39 T-ランキング39 TCHAR 27 TE 39トークン27のトレーラー40 TRAイラー部分37転送コーディング35転送エンコード28転送伸長35転送パラメータ35アップグレード57 URIホスト16 URIリファレンス16 VCHAR 6 47 GZIP（符号化フォーマット）39を介して"
    },
    {
      "indent": 3,
      "text": "H header field 19 header section 19 headers 19 Host header field 44 http URI scheme 17 https URI scheme 17 I inbound 9 interception proxy 11 intermediary 9",
      "ja": "Hヘッダーフィールド19ヘッダ部19個のヘッダ19ホストヘッダフィールド44 HTTP URIスキーム17 HTTPS URIスキーム17は、I 9傍受プロキシ11仲介9インバウンド"
    },
    {
      "indent": 3,
      "text": "M Media Type application/http 63 message/http 62 message 7 message/http Media Type 62 method 21",
      "ja": "Mメディアタイプapplication / HTTPメッセージ63 / HTTPメッセージ62 7メッセージ/ HTTPメディアタイプ62方法21"
    },
    {
      "indent": 3,
      "text": "N non-transforming proxy 49",
      "ja": "N非変換プロキシ49"
    },
    {
      "indent": 3,
      "text": "O origin server 7 origin-form (of request-target) 42 outbound 10",
      "ja": "（要求対象の）Oオリジンサーバ7原点形態42アウトバウンド10"
    },
    {
      "indent": 3,
      "text": "P phishing 67 proxy 10",
      "ja": "67プロキシ10フィッシングP"
    },
    {
      "indent": 3,
      "text": "R recipient 7 request 7 request-target 21 resource 16 response 7 reverse proxy 10",
      "ja": "R受信者7リクエスト7リクエスト対象21リソース16応答7リバースプロキシ10"
    },
    {
      "indent": 3,
      "text": "S sender 7 server 7 spider 7",
      "ja": "S送信者7サーバー7クモ7"
    },
    {
      "indent": 3,
      "text": "T target resource 40 target URI 40 TE header field 39 Trailer header field 40 Transfer-Encoding header field 28 transforming proxy 49 transparent proxy 11 tunnel 10",
      "ja": "Tターゲットリソース40ターゲットURI 40 TEヘッダフィールド39トレーラーヘッダフィールド40転送エンコードヘッダフィールド28変換プロキシ49透過プロキシ11トンネル10"
    },
    {
      "indent": 3,
      "text": "U Upgrade header field 57 upstream 9 URI scheme http 17 https 17 user agent 7",
      "ja": "Uは、ヘッダフィールド57の上流9 URIスキームHTTP 17 HTTPS 17ユーザエージェント7をアップグレード"
    },
    {
      "indent": 3,
      "text": "V Via header field 47",
      "ja": "ヘッダフィールド47を介してV"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Roy T. Fielding (editor) Adobe Systems Incorporated 345 Park Ave San Jose, CA 95110 USA",
      "ja": "ロイT.フィールディング（編集者）Adobe Systems Incorporated（アドビシステムズ社）345パークアベニューサンノゼ、CA 95110 USA"
    },
    {
      "indent": 3,
      "text": "EMail: fielding@gbiv.com URI: http://roy.gbiv.com/",
      "ja": "電子メール：fielding@gbiv.com URI：http://roy.gbiv.com/"
    },
    {
      "indent": 3,
      "text": "Julian F. Reschke (editor) greenbytes GmbH Hafenweg 16 Muenster, NW 48155 Germany",
      "ja": "ジュリアンF. Reschke（エディタ）greenbytes社Hafenweg 16ミュンスター、NW 48155ドイツ"
    },
    {
      "indent": 3,
      "text": "EMail: julian.reschke@greenbytes.de URI: http://greenbytes.de/tech/webdav/",
      "ja": "電子メール：julian.reschke@greenbytes.de URI：http://greenbytes.de/tech/webdav/"
    }
  ]
}