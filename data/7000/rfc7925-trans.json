{
  "title": {
    "text": "RFC 7925 - Transport Layer Security (TLS) / Datagram Transport Layer Security (DTLS) Profiles for the Internet of Things",
    "ja": "RFC 7925 - モノのインターネットのためのトランスポート層セキュリティ（TLS）/データグラムトランスポート層セキュリティ（DTLS）プロファイル"
  },
  "number": 7925,
  "created_at": "2019-11-01 23:55:55.683986+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                H. Tschofenig, Ed.\nRequest for Comments: 7925                                      ARM Ltd.\nCategory: Standards Track                                     T. Fossati\nISSN: 2070-1721                                                    Nokia\n                                                               July 2016",
      "raw": true
    },
    {
      "indent": 16,
      "text": "    Transport Layer Security (TLS) /\nDatagram Transport Layer Security (DTLS)\n  Profiles for the Internet of Things",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "A common design pattern in Internet of Things (IoT) deployments is the use of a constrained device that collects data via sensors or controls actuators for use in home automation, industrial control systems, smart cities, and other IoT deployments.",
      "ja": "物事（IOT）の展開のインターネットでの一般的なデザインパターンは、センサを介してデータを収集したり、ホームオートメーション、産業用制御システム、スマートシティ、およびその他のIoTの展開で使用するためのアクチュエータを制御制約のあるデバイスを使用することです。"
    },
    {
      "indent": 3,
      "text": "This document defines a Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS) 1.2 profile that offers communications security for this data exchange thereby preventing eavesdropping, tampering, and message forgery. The lack of communication security is a common vulnerability in IoT products that can easily be solved by using these well-researched and widely deployed Internet security protocols.",
      "ja": "この文書では、トランスポート層セキュリティ（TLS）およびデータグラムトランスポート層セキュリティ（DTLS）することにより、盗聴、改ざん、およびメッセージ偽造を防止し、このデータ交換のための通信のセキュリティを提供しています1.2のプロファイルを定義します。通信セキュリティの欠如は、簡単にこれらのよく研究し、広く普及しているインターネットセキュリティプロトコルを使用することによって解決することができるのIoT製品に共通する脆弱性です。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 7841のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7925.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7925で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2016 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2016 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   4\n2.  Terminology . . . . . . . . . . . . . . . . . . . . . . . . .   4\n3.  Overview  . . . . . . . . . . . . . . . . . . . . . . . . . .   5\n  3.1.  TLS and DTLS  . . . . . . . . . . . . . . . . . . . . . .   5\n  3.2.  Communication Models  . . . . . . . . . . . . . . . . . .   6\n  3.3.  The Ciphersuite Concept . . . . . . . . . . . . . . . . .  20\n4.  Credential Types  . . . . . . . . . . . . . . . . . . . . . .  21\n  4.1.  Preconditions . . . . . . . . . . . . . . . . . . . . . .  21\n  4.2.  Pre-Shared Secret . . . . . . . . . . . . . . . . . . . .  23\n  4.3.  Raw Public Key  . . . . . . . . . . . . . . . . . . . . .  25\n  4.4.  Certificates  . . . . . . . . . . . . . . . . . . . . . .  27\n5.  Signature Algorithm Extension . . . . . . . . . . . . . . . .  32\n6.  Error Handling  . . . . . . . . . . . . . . . . . . . . . . .  32\n7.  Session Resumption  . . . . . . . . . . . . . . . . . . . . .  34\n8.  Compression . . . . . . . . . . . . . . . . . . . . . . . . .  35\n9.  Perfect Forward Secrecy . . . . . . . . . . . . . . . . . . .  35\n10. Keep-Alive  . . . . . . . . . . . . . . . . . . . . . . . . .  36\n11. Timeouts  . . . . . . . . . . . . . . . . . . . . . . . . . .  38\n12. Random Number Generation  . . . . . . . . . . . . . . . . . .  39\n13. Truncated MAC and Encrypt-then-MAC Extension  . . . . . . . .  40\n14. Server Name Indication (SNI)  . . . . . . . . . . . . . . . .  40\n15. Maximum Fragment Length Negotiation . . . . . . . . . . . . .  41\n16. Session Hash  . . . . . . . . . . . . . . . . . . . . . . . .  41\n17. Renegotiation Attacks . . . . . . . . . . . . . . . . . . . .  42\n18. Downgrading Attacks . . . . . . . . . . . . . . . . . . . . .  42\n19. Crypto Agility  . . . . . . . . . . . . . . . . . . . . . . .  43\n20. Key Length Recommendations  . . . . . . . . . . . . . . . . .  44\n21. False Start . . . . . . . . . . . . . . . . . . . . . . . . .  45\n22. Privacy Considerations  . . . . . . . . . . . . . . . . . . .  45\n23. Security Considerations . . . . . . . . . . . . . . . . . . .  46\n24. References  . . . . . . . . . . . . . . . . . . . . . . . . .  47\n  24.1.  Normative References . . . . . . . . . . . . . . . . . .  47\n  24.2.  Informative References . . . . . . . . . . . . . . . . .  48\nAppendix A.  Conveying DTLS over SMS  . . . . . . . . . . . . . .  56\n  A.1.  Overview  . . . . . . . . . . . . . . . . . . . . . . . .  56\n  A.2.  Message Segmentation and Reassembly . . . . . . . . . . .  57\n  A.3.  Multiplexing Security Associations  . . . . . . . . . . .  57\n  A.4.  Timeout . . . . . . . . . . . . . . . . . . . . . . . . .  58\nAppendix B.  DTLS Record Layer Per-Packet Overhead  . . . . . . .  59\nAppendix C.  DTLS Fragmentation . . . . . . . . . . . . . . . . .  60\nAcknowledgments . . . . . . . . . . . . . . . . . . . . . . . . .  60\nAuthors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  61",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "An engineer developing an Internet of Things (IoT) device needs to investigate the security threats and decide about the security services that can be used to mitigate these threats.",
      "ja": "モノのインターネット（IOT）デバイスを開発するエンジニアは、セキュリティ上の脅威を調査し、これらの脅威を軽減するために使用できるセキュリティサービスについて決定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Enabling IoT devices to exchange data often requires authentication of the two endpoints and the ability to provide integrity and confidentiality protection of exchanged data. While these security services can be provided at different layers in the protocol stack, the use of Transport Layer Security (TLS) / Datagram Transport Layer Security (DTLS) has been very popular with many application protocols, and it is likely to be useful for IoT scenarios as well.",
      "ja": "データを交換するためのIoTデバイスを有効にすると、多くの場合、2つのエンドポイントの認証と交換されるデータの整合性と機密性の保護を提供する能力が必要です。これらのセキュリティサービスは、プロトコル・スタック内の異なる層に提供することができますが、トランスポート層セキュリティの使用（TLS）/データグラムトランスポート層セキュリティ（DTLS）は、多くのアプリケーションプロトコルに非常に人気となっている、そしてのIoTのために有用である可能性が高いですシナリオにも。"
    },
    {
      "indent": 3,
      "text": "Fitting Internet protocols into constrained devices can be difficult, but thanks to the standardization efforts, new profiles and protocols are available, such as the Constrained Application Protocol (CoAP) [RFC7252]. CoAP messages are mainly carried over UDP/DTLS, but other transports can be utilized, such as SMS (as described in Appendix A) or TCP (as currently being proposed with [COAP-TCP-TLS]).",
      "ja": "拘束装置にフィッティングインターネットプロトコルは困難であることができるが、標準化の努力のおかげで、新しいプロファイルとプロトコルは、このような制約アプリケーションプロトコル（CoAP）[RFC7252]として、利用可能です。 CoAPメッセージは、主にUDP / DTLSを介して搬送されるが、他のトランスポートは、（現在[COAP-TCP-TLS]で提案されているように）SMS（付録Aに記載されているように）、またはTCPのように、利用することができます。"
    },
    {
      "indent": 3,
      "text": "While the main goal for this document is to protect CoAP messages using DTLS 1.2 [RFC6347], the information contained in the following sections is not limited to CoAP nor to DTLS itself.",
      "ja": "この文書の主な目的は、DTLS 1.2 [RFC6347]を使用してCoAPメッセージを保護することであるが、次のセクションに含まれている情報は、CoAPにもDTLS自体に限定されるものではありません。"
    },
    {
      "indent": 3,
      "text": "Instead, this document defines a profile of DTLS 1.2 [RFC6347] and TLS 1.2 [RFC5246] that offers communication security services for IoT applications and is reasonably implementable on many constrained devices. Profile thereby means that available configuration options and protocol extensions are utilized to best support the IoT environment. This document does not alter TLS/DTLS specifications and does not introduce any new TLS/DTLS extension.",
      "ja": "代わりに、このドキュメントでは、DTLS 1.2のプロフィール[RFC6347]とのIoTアプリケーションのための通信のセキュリティサービスを提供し、多くの制約のあるデバイス上で合理的に実施可能であるTLS 1.2 [RFC5246]を定義します。プロファイルは、それによって利用可能な設定オプションおよびプロトコルの拡張が最高のIoT環境をサポートするために利用されていることを意味します。このドキュメントは、TLS / DTLSの仕様を変更しないと、新しいTLS / DTLSの拡張機能を導入しません。"
    },
    {
      "indent": 3,
      "text": "The main target audience for this document is the embedded system developer configuring and using a TLS/DTLS stack. This document may, however, also help those developing or selecting a suitable TLS/DTLS stack for an IoT product. If you are familiar with (D)TLS, then skip ahead to Section 4.",
      "ja": "この文書の主な対象読者は、TLS / DTLSスタックを構成し、使用した組込みシステムの開発者です。この文書では、しかし、またのIoT製品に適したTLS / DTLSスタックを開発するか、選択したものを助けるかもしれません。あなたは（D）TLSに精通している場合には、第4章に進んでください。"
    },
    {
      "indent": 0,
      "text": "2. Terminology",
      "section_title": true,
      "ja": "2.用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [RFC2119].",
      "ja": "キーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、 \"SHALL\"、 \"SHOULD\"、 \"ないもの\"、 \"推奨\" \"ない（SHOULD NOT）\"、 \"MAY\"、 \"推奨NOT\"、および「OPTIONAL RFC 2119 [RFC2119]に記載されているように「この文書に解釈されるべきです。"
    },
    {
      "indent": 3,
      "text": "This specification refers to TLS as well as DTLS and particularly to version 1.2, which is the most recent version at the time of writing.",
      "ja": "この仕様はTLSにだけでなく、DTLS、特に執筆時の最新バージョンであるバージョン1.2を指します。"
    },
    {
      "indent": 3,
      "text": "We refer to TLS/DTLS whenever the text is applicable to both versions of the protocol and to TLS or DTLS when there are differences between the two protocols. Note that TLS 1.3 is being developed, but it is not expected that this profile will \"just work\" due to the significant changes being done to TLS for version 1.3.",
      "ja": "2つのプロトコル間の違いがある場合、テキストはプロトコルの両方のバージョンへとTLSまたはDTLSに適用されたときに私たちは、TLS / DTLSを参照してください。 TLS 1.3が開発されているが、このプロファイルが原因バージョン1.3のためにTLSに行われている重要な変更に、「ただ働き」になることが期待されていないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "Note that \"client\" and \"server\" in this document refer to TLS/DTLS roles, where the client initiates the handshake. This does not restrict the interaction pattern of the protocols on top of DTLS since the record layer allows bidirectional communication. This aspect is further described in Section 3.2.",
      "ja": "このドキュメントの「クライアント」と「サーバー」は、クライアントがハンドシェイクを開始TLS / DTLSの役割、を参照することに注意してください。記録層は、双方向通信を可能にするので、これはDTLSの上のプロトコルの相互作用パターンを制限するものではありません。この態様はさらに、セクション3.2に記載されています。"
    },
    {
      "indent": 3,
      "text": "RFC 7228 [RFC7228] introduces the notion of constrained-node networks, which are made of small devices with severe constraints on power, memory, and processing resources. The terms constrained devices and IoT devices are used interchangeably.",
      "ja": "RFC 7228 [RFC7228]は、電力、メモリおよび処理リソースに厳しい制約を有する小さな装置で形成されている制約ノード・ネットワークの概念を導入します。デバイスとのIoTデバイスの制約の用語は互換的に用いられます。"
    },
    {
      "indent": 3,
      "text": "The terms \"certification authority\" (CA) and \"distinguished name\" (DN) are taken from [RFC5280]. The terms \"trust anchor\" and \"trust anchor store\" are defined in [RFC6024] as:",
      "ja": "用語「認証局」（CA）と「識別名」（DN）は[RFC5280]から取得されます。用語「トラストアンカー」と「トラストアンカーストアは」として、[RFC6024]で定義されています。"
    },
    {
      "indent": 6,
      "text": "A trust anchor represents an authoritative entity via a public key and associated data. The public key is used to verify digital signatures, and the associated data is used to constrain the types of information for which the trust anchor is authoritative.",
      "ja": "トラストアンカーは、公開鍵とそれに関連するデータを介して正式なエンティティを表します。公開鍵は、デジタル署名を検証するために使用され、関連データは、トラストアンカーが権限を持つ情報の種類を制限するために使用されます。"
    },
    {
      "indent": 6,
      "text": "A trust anchor store is a set of one or more trust anchors stored in a device.... A device may have more than one trust anchor store, each of which may be used by one or more applications.",
      "ja": "トラストアンカーストアがデバイスに格納された一つ以上のトラストアンカーのセットである....装置は、1つの以上のアプリケーションによって使用されてもよいこれらの各々は、複数のトラストアンカー・ストアを有することができます。"
    },
    {
      "indent": 0,
      "text": "3. Overview",
      "section_title": true,
      "ja": "3.概要"
    },
    {
      "indent": 0,
      "text": "3.1. TLS and DTLS",
      "section_title": true,
      "ja": "3.1。 TLSとDTLS"
    },
    {
      "indent": 3,
      "text": "The TLS protocol [RFC5246] provides authenticated, confidentiality-and integrity-protected communication between two endpoints. The protocol is composed of two layers: the Record Protocol and the handshaking protocols. At the lowest level, layered on top of a reliable transport protocol (e.g., TCP), is the Record Protocol. It provides connection security by using symmetric cryptography for confidentiality, data origin authentication, and integrity protection. The Record Protocol is used for encapsulation of various higher-level protocols. The handshaking protocols consist of three subprotocols -- namely, the handshake protocol, the change cipher spec protocol, and the alert protocol. The handshake protocol allows the server and client to authenticate each other and to negotiate an encryption algorithm and cryptographic keys before the application protocol transmits or receives data.",
      "ja": "TLSプロトコル[RFC5246]は、認証、機密性、及び2つのエンドポイント間の整合性保護された通信を提供します。レコードプロトコルおよびハンドシェークプロトコル：プロトコルは、二層で構成されています。最下位レベルでは、信頼性の高いトランスポートプロトコル（例えば、TCP）の上に重ね、レコードプロトコルです。これは、機密性、データ発信元認証、および完全性保護のための対称暗号化を使用して接続セキュリティを提供します。レコードプロトコルは、様々な上位レベルのプロトコルのカプセル化に使用されます。すなわち、ハンドシェイクプロトコル、変化暗号仕様プロトコル、およびアラートプロトコル - ハンドシェイクプロトコルは、3つのサブプロトコルで構成されています。ハンドシェイクプロトコルは、サーバーとクライアントが互いを認証し、アプリケーションプロトコルが送信またはデータを受信する前に、暗号化アルゴリズムと暗号鍵を交渉することを可能にします。"
    },
    {
      "indent": 3,
      "text": "The design of DTLS [RFC6347] is intentionally very similar to TLS. However, since DTLS operates on top of an unreliable datagram transport, it must explicitly cope with the absence of reliable and ordered delivery assumptions made by TLS. RFC 6347 explains these differences in great detail. As a short summary, for those not familiar with DTLS, the differences are:",
      "ja": "DTLS [RFC6347]の設計は、意図的にTLSと非常によく似ています。 DTLSは、信頼性のないデータグラム輸送の上で動作するため、しかし、それは明示的にTLSによって作られた信頼性の高い、注文配達仮定の不在に対処しなければなりません。 RFC 6347は、非常に詳細でこれらの違いを説明します。要約として、DTLSに慣れていない人のため、相違点は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o An explicit sequence number and an epoch field is included in the Record Protocol. Section 4.1 of RFC 6347 explains the processing rules for these two new fields. The value used to compute the Message Authentication Code (MAC) is the 64-bit value formed by concatenating the epoch and the sequence number.",
      "ja": "O明示的なシーケンス番号とエポックフィールドはレコードプロトコルに含まれています。 RFC 6347のセクション4.1には、これら2つの新しいフィールドの処理ルールを説明しています。メッセージ認証コード（MAC）を計算するために使用される値は、エポックとシーケンス番号を連結することによって形成される64ビット値です。"
    },
    {
      "indent": 3,
      "text": "o Stream ciphers must not be used with DTLS. The only stream cipher defined for TLS 1.2 is RC4, and due to cryptographic weaknesses, it is not recommended anymore even for use with TLS [RFC7465]. Note that the term \"stream cipher\" is a technical term in the TLS specification. Section 4.7 of RFC 5246 defines stream ciphers in TLS as follows: \"In stream cipher encryption, the plaintext is exclusive-ORed with an identical amount of output generated from a cryptographically secure keyed pseudorandom number generator.\"",
      "ja": "Oストリーム暗号は、DTLSを使用することはできません。 TLS 1.2用に定義されている唯一のストリーム暗号は、RC4、および暗号化の弱点に起因して、それがさえTLS [RFC7465]で使用するためにもはや推奨されません。用語「ストリーム暗号は、」TLS仕様の技術的な用語であることに注意してください。次のようにRFC 5246のセクション4.7はTLSでストリーム暗号を定義：「ストリーム暗号の暗号化では、平文は、排他的論理和は、暗号的に安全なキー付き疑似乱数発生器から生成される出力の同じ量です。」"
    },
    {
      "indent": 3,
      "text": "o The TLS handshake protocol has been enhanced to include a stateless cookie exchange for Denial-of-Service (DoS) resistance. For this purpose, a new handshake message, the HelloVerifyRequest, was added to DTLS. This handshake message is sent by the server and includes a stateless cookie, which is returned in a ClientHello message back to the server. Although the exchange is optional for the server to execute, a client implementation has to be prepared to respond to it. Furthermore, the handshake message format has been extended to deal with message loss, reordering, and fragmentation.",
      "ja": "O TLSハンドシェイクプロトコルは、サービス拒否（DoS）の抵抗のためにステートレスクッキー交換を含むように拡張されています。この目的のために、新しいハンドシェイクメッセージ、HelloVerifyRequestは、DTLSに追加されました。このハンドシェイクメッセージは、サーバによって送信され、戻ってサーバーにClientHelloメッセージで返されステートレスクッキーを、備えています。交換は、サーバが実行するためのオプションですが、クライアントの実装は、それに応えるために準備する必要があります。また、ハンドシェイクメッセージフォーマットは、メッセージ損失、並び替え、および断片化に対処するために拡張されています。"
    },
    {
      "indent": 0,
      "text": "3.2. Communication Models",
      "section_title": true,
      "ja": "3.2。通信モデル"
    },
    {
      "indent": 3,
      "text": "This document describes a profile of DTLS and, to be useful, it has to make assumptions about the envisioned communication architecture.",
      "ja": "この文書では、DTLSのプロファイルを説明し、有用であることが、それが想定される通信アーキテクチャについての仮定を行う必要があります。"
    },
    {
      "indent": 3,
      "text": "Two communication architectures (and consequently two profiles) are described in this document.",
      "ja": "二つの通信アーキテクチャ（その結果、2つのプロファイル）を、この文書に記載されています。"
    },
    {
      "indent": 0,
      "text": "3.2.1. Constrained TLS/DTLS Clients",
      "section_title": true,
      "ja": "3.2.1。制約TLS / DTLSクライアント"
    },
    {
      "indent": 3,
      "text": "The communication architecture shown in Figure 1 assumes a unicast communication interaction with an IoT device utilizing a constrained TLS/DTLS client interacting with one or multiple TLS/DTLS servers.",
      "ja": "図1に示す通信アーキテクチャは、一つまたは複数のTLS / DTLSサーバと相互作用する拘束TLS / DTLSクライアントを利用したIoT装置とユニキャスト通信との相互作用を想定しています。"
    },
    {
      "indent": 3,
      "text": "Before a client can initiate the TLS/DTLS handshake, it needs to know the IP address of that server and what credentials to use. Application-layer protocols, such as CoAP, which is conveyed on top of DTLS, may be configured with URIs of the endpoints to which CoAP needs to register and publish data. This configuration information (including non-confidential credentials, like certificates) may be conveyed to clients as part of a firmware/software package or via a configuration protocol. The following credential types are supported by this profile:",
      "ja": "クライアントがTLS / DTLSハンドシェイクを開始する前に、そのサーバのIPアドレスを知っている必要がありますし、どのような資格情報を使用します。そのようなDTLSの上部に搬送さCoAP、などのアプリケーション層プロトコルは、CoAPレジスタとデータを公開する必要があるのエンドポイントのURIに構成されてもよいです。 （証明書のような非機密信任状を含む）この設定情報は、ファームウェア/ソフトウェア・パッケージの一部として、またはコンフィギュレーションプロトコルを介してクライアントに伝達することができます。以下のクレデンシャルタイプは、このプロファイルによってサポートされています。"
    },
    {
      "indent": 3,
      "text": "o For authentication based on the Pre-Shared Key (PSK) (see Section 4.2), this includes the paired \"PSK identity\" and shared secret to be used with each server.",
      "ja": "事前共有鍵に基づく認証のためにO（PSK）（4.2節を参照）、これは一対の「PSK同一性」と各サーバで使用する共有秘密を含みます。"
    },
    {
      "indent": 3,
      "text": "o For authentication based on the raw public key (see Section 4.3), this includes either the server's public key or the hash of the server's public key.",
      "ja": "O生の公開鍵に基づいて認証の場合、これは、サーバの公開鍵やサーバの公開鍵のハッシュのいずれかを含んでいる（4.3節を参照してください）。"
    },
    {
      "indent": 3,
      "text": "o For certificate-based authentication (see Section 4.4), this includes a pre-populated trust anchor store that allows the DTLS stack to perform path validation for the certificate obtained during the handshake with the server.",
      "ja": "O証明書ベースの認証（セクション4.4を参照）、これはDTLSスタックがサーバとのハンドシェーク中に取得した証明書のパスの検証を実行することを可能にする事前にトラストアンカーストアを含みます。"
    },
    {
      "indent": 3,
      "text": "Figure 1 shows example configuration information stored at the constrained client for use with respective servers.",
      "ja": "図1は、各サーバで使用するための制約クライアントに格納されている例示的な構成情報を示しています。"
    },
    {
      "indent": 3,
      "text": "This document focuses on the description of the DTLS client-side functionality but, quite naturally, the equivalent server-side support has to be available.",
      "ja": "この文書では、DTLSクライアント側の機能の説明に焦点を当てていますが、ごく自然に、同等のサーバー側のサポートが利用可能でなければなりません。"
    },
    {
      "indent": 3,
      "text": "           +////////////////////////////////////+\n           |          Configuration             |\n           |////////////////////////////////////|\n           | Server A --> PSK Identity, PSK     |\n           |                                    |\n           | Server B --> Public Key (Server B),|\n           |              Public/Private Key    |\n           |              (for Client)          |\n           |                                    |\n           | Server C --> Public/Private Key    |\n           |              (for Client)          |\n           |              Trust Anchor Store    |\n           +------------------------------------+\n             oo\n       oooooo\n      o\n+-----------+\n|Constrained|\n|TLS/DTLS   |\n|Client     |-\n+-----------+ \\\n               \\  ,-------.\n                ,'         `.            +------+\n               /  IP-Based   \\           |Server|\n              (    Network    )          |  A   |\n               \\             /           +------+\n                `.         ,'\n                  '---+---'                  +------+\n                      |                      |Server|\n                      |                      |  B   |\n                      |                      +------+\n                      |\n                      |                  +------+\n                      +----------------->|Server|\n                                         |  C   |\n                                         +------+",
      "raw": true
    },
    {
      "indent": 19,
      "text": "Figure 1: Constrained Client Profile",
      "ja": "図1：制約クライアントプロファイル"
    },
    {
      "indent": 0,
      "text": "3.2.1.1. Examples of Constrained Client Exchanges",
      "section_title": true,
      "ja": "3.2.1.1。制約クライアントの交流の例"
    },
    {
      "indent": 0,
      "text": "3.2.1.1.1. Network Access Authentication Example",
      "section_title": true,
      "ja": "3.2.1.1.1。ネットワークアクセス認証の例"
    },
    {
      "indent": 3,
      "text": "Reuse is a recurring theme when considering constrained environments and is behind a lot of the directions taken in developments for constrained environments. The corollary of reuse is to not add functionality if it can be avoided. An example relevant to the use of TLS is network access authentication, which takes place when a device connects to a network and needs to go through an authentication and access control procedure before it is allowed to communicate with other devices or connect to the Internet.",
      "ja": "再利用は、制約のある環境を考慮し、限られた環境のための開発で撮影方向の多くの背後にある定期的なテーマです。再利用の当然の結果は、それを避けることができるかどうかの機能を追加しないことです。 TLSの使用に関連した例では、デバイスがネットワークに接続し、他のデバイスと通信やインターネットへの接続を許可される前に、認証とアクセス制御手順を経る必要があるときに起こるネットワークアクセス認証、です。"
    },
    {
      "indent": 3,
      "text": "Figure 2 shows the network access architecture with the IoT device initiating the communication to an access point in the network using the procedures defined for a specific physical layer. Since credentials may be managed and stored centrally, in the Authentication, Authorization, and Accounting (AAA) server, the security protocol exchange may need to be relayed via the Authenticator, i.e., functionality running on the access point to the AAA server. The authentication and key exchange protocol itself is encapsulated within a container, the Extensible Authentication Protocol (EAP) [RFC3748], and messages are conveyed back and forth between the EAP endpoints, namely the EAP peer located on the IoT device and the EAP server located on the AAA server or the access point. To route EAP messages from the access point, acting as a AAA client, to the AAA server requires an adequate protocol mechanism, namely RADIUS [RFC2865] or Diameter [RFC6733].",
      "ja": "図2は、特定の物理層のための定義された手順を使用してネットワーク内のアクセスポイントに通信を開始するのIoTデバイスとネットワーク・アクセス・アーキテクチャを示します。認証情報が管理され、認証、許可、アカウンティング（AAA）サーバで一元的に格納することができるので、セキュリティプロトコル交換、すなわち、機能がAAAサーバへのアクセスポイントで実行されている、認証を介して中継される必要があるかもしれません。それ自体がコンテナ内にカプセル化された認証及び鍵交換プロトコルは、拡張認証プロトコル（EAP）[RFC3748]、およびメッセージが前後EAPエンドポイント、すなわちのIoTデバイス上に位置するEAPピア及び位置EAPサーバとの間に搬送されますAAAサーバまたはアクセスポイントに。アクセスポイントから経路EAPメッセージを、AAAクライアントとして機能し、AAAサーバに十分なプロトコル機構、すなわち、RADIUS [RFC2865]または直径[RFC6733]を必要とします。"
    },
    {
      "indent": 3,
      "text": "More details about the concepts and a description about the terminology can be found in RFC 5247 [RFC5247].",
      "ja": "概念および用語について説明についての詳細は、RFC 5247 [RFC5247]に見出すことができます。"
    },
    {
      "indent": 4,
      "text": "                                            +--------------+\n                                            |Authentication|\n                                            |Authorization |\n                                            |Accounting    |\n                                            |Server        |\n                                            |(EAP Server)  |\n                                            |              |\n                                            +-^----------^-+\n                                              * EAP      o RADIUS/\n                                              *          o Diameter\n                                            --v----------v--\n                                         ///                \\\\\\\n                                       //                      \\\\\n                                      |        Federation        |\n                                      |        Substrate         |\n                                       \\\\                      //\n                                         \\\\\\                ///\n                                            --^----------^--\n                                              * EAP      o RADIUS/\n                                              *          o Diameter\n+-------------+                             +-v----------v--+\n|             |      EAP/EAP Method         |               |\n| Internet of |<***************************>| Access Point  |\n| Things      |                             |(Authenticator)|\n| Device      |    EAP Lower Layer and      |(AAA Client)   |\n| (EAP Peer)  | Secure Association Protocol |               |\n|             |<--------------------------->|               |\n|             |                             |               |\n|             |      Physical Layer         |               |\n|             |<===========================>|               |\n+-------------+                             +---------------+\n  Legend:",
      "raw": true
    },
    {
      "indent": 7,
      "text": "<****>: Device-to-AAA-Server Exchange\n<---->: Device-to-Authenticator Exchange\n<oooo>: AAA-Client-to-AAA-Server Exchange\n<====>: Physical layer like IEEE 802.11/802.15.4",
      "raw": true
    },
    {
      "indent": 19,
      "text": "Figure 2: Network Access Architecture",
      "ja": "図2：ネットワークアクセスアーキテクチャ"
    },
    {
      "indent": 3,
      "text": "One standardized EAP method is EAP-TLS, defined in RFC 5216 [RFC5216], which reuses the TLS-based protocol exchange and encapsulates it inside the EAP payload. In terms of reuse, this allows many components of the TLS protocol to be shared between the network access security functionality and the TLS functionality needed for securing application-layer traffic. In the EAP-TLS exchange shown in Figure 3, the IoT device as the EAP peer acts as a TLS client.",
      "ja": "一つの標準化されたEAP方式は、TLSベースのプロトコル交換を再利用し、EAPペイロード内部にそれをカプセル化するEAP-TLS、RFC 5216 [RFC5216]で定義されています。再利用の観点から、これは、TLSプロトコルの多くのコンポーネントは、ネットワークアクセスセキュリティ機能とアプリケーション層のトラフィックを確保するために必要なTLSの機能の間で共有されることを可能にします。図3に示されているEAP-TLS交換では、EAPピアとしてのIoTデバイスがTLSクライアントとして機能します。"
    },
    {
      "indent": 6,
      "text": "Authenticating Peer     Authenticator\n-------------------     -------------\n                        <- EAP-Request/\n                        Identity\nEAP-Response/\nIdentity (MyID) ->\n                        <- EAP-Request/\n                        EAP-Type=EAP-TLS\n                        (TLS Start)\nEAP-Response/\nEAP-Type=EAP-TLS\n(TLS client_hello)->\n                        <- EAP-Request/\n                        EAP-Type=EAP-TLS\n                        (TLS server_hello,\n                         TLS certificate,\n                         [TLS server_key_exchange,]\n                         TLS certificate_request,\n                         TLS server_hello_done)\nEAP-Response/\nEAP-Type=EAP-TLS\n(TLS certificate,\n TLS client_key_exchange,\n TLS certificate_verify,\n TLS change_cipher_spec,\n TLS finished) ->\n                        <- EAP-Request/\n                        EAP-Type=EAP-TLS\n                        (TLS change_cipher_spec,\n                         TLS finished)\nEAP-Response/\nEAP-Type=EAP-TLS ->\n                        <- EAP-Success",
      "raw": true
    },
    {
      "indent": 24,
      "text": "Figure 3: EAP-TLS Exchange",
      "ja": "図3：EAP-TLS交換"
    },
    {
      "indent": 3,
      "text": "The guidance in this document also applies to the use of EAP-TLS for network access authentication. An IoT device using a network access authentication solution based on TLS can reuse most parts of the code for the use of DTLS/TLS at the application layer, thereby saving a significant amount of flash memory. Note, however, that the credentials used for network access authentication and those used for application-layer security are very likely different.",
      "ja": "このドキュメントのガイダンスは、ネットワークアクセス認証のためのEAP-TLSの使用に適用されます。 TLSに基づいて、ネットワークアクセス認証溶液を用いてのIoTデバイスは、それによって、フラッシュメモリのかなりの量を節約し、アプリケーション層でDTLS / TLSを使用するためのコードの大部分を再利用することができます。ネットワークアクセス認証に使用する資格情報とアプリケーション層のセキュリティのために使用されるものは非常に可能性が異なっていること、しかし、注意してください。"
    },
    {
      "indent": 0,
      "text": "3.2.1.1.2. CoAP-Based Data Exchange Example",
      "section_title": true,
      "ja": "3.2.1.1.2。 CoAPベースのデータ交換例"
    },
    {
      "indent": 3,
      "text": "When a constrained client uploads sensor data to a server infrastructure, it may use CoAP by pushing the data via a POST message to a preconfigured endpoint on the server. In certain circumstances, this might be too limiting and additional functionality is needed, as shown in Figures 4 and 5, where the IoT device itself runs a CoAP server hosting the resource that is made accessible to other entities. Despite running a CoAP server on the IoT device, it is still the DTLS client on the IoT device that initiates the interaction with the non-constrained resource server in our scenario.",
      "ja": "サーバーインフラストラクチャにクライアントアップロードセンサデータを制約する場合は、サーバ上の事前設定されたエンドポイントにPOSTメッセージを介してデータを押すことによってCoAPを使用することができます。特定の状況では、これはあまりにも制限したIoTデバイス自体が他のエンティティにアクセス可能になり、リソースをホストしているCoAPサーバを実行し、図4および図5に示すように、追加の機能が、必要とされているかもしれません。 IoTデバイス上CoAPサーバーを実行しているにもかかわらず、それはまだ私達のシナリオで非拘束されたリソースサーバとの対話を開始したIoTデバイス上のDTLSクライアントです。"
    },
    {
      "indent": 3,
      "text": "Figure 4 shows a sensor starting a DTLS exchange with a resource directory and uses CoAP to register available resources in Figure 5. [CoRE-RD] defines the resource directory (RD) as a web entity that stores information about web resources and implements Representational State Transfer (REST) interfaces for registration and lookup of those resources. Note that the described exchange is borrowed from the Open Mobile Alliance (OMA) Lightweight Machine-to-Machine (LWM2M) specification [LWM2M] that uses RD but adds proxy functionality.",
      "ja": "図4は、ウェブリソースに関する情報を格納し、表象状態を実現するウェブエンティティとしてリソースディレクトリ（RD）を定義[CORE-RD]リソースディレクトリとDTLS交換を開始するセンサーを示し、図5における利用可能なリソースを登録するCoAPを使用しますこれらのリソースの登録と検索のための転送（REST）インターフェース。説明交換RDを使用するが、プロキシ機能を追加オープンモバイルアライアンス（OMA）軽量マシン・ツー・マシン（LWM2M）仕様[LWM2M]から借用されることに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "The initial DTLS interaction between the sensor, acting as a DTLS client, and the resource directory, acting as a DTLS server, will be a full DTLS handshake. Once this handshake is complete, both parties have established the DTLS record layer. Subsequently, the CoAP client can securely register at the resource directory.",
      "ja": "DTLSクライアントとして動作するセンサー、およびリソースディレクトリ間の初期DTLSの相互作用は、DTLSサーバとして動作し、フルDTLS握手になります。このハンドシェイクが完了すると、両当事者は、DTLS記録層を確立しています。その後、CoAPクライアントが確実にリソースディレクトリに登録することができます。"
    },
    {
      "indent": 3,
      "text": "After some time (assuming that the client regularly refreshes its registration), the resource directory receives a request from an application to retrieve the temperature information from the sensor. This request is relayed by the resource directory to the sensor using a GET message exchange. The already established DTLS record layer can be used to secure the message exchange.",
      "ja": "（クライアントは、定期的にその登録をリフレッシュすると仮定して）いくつかの時間後に、リソースディレクトリには、センサからの温度情報を取得するためのアプリケーションからの要求を受け取ります。この要求は、GETメッセージ交換を使用してセンサーにリソースディレクトリによって中継されます。すでに確立さDTLS記録層は、メッセージ交換を保護するために使用することができます。"
    },
    {
      "indent": 7,
      "text": "                                             Resource\nSensor                                       Directory\n------                                       ---------",
      "raw": true
    },
    {
      "indent": 4,
      "text": " +---\n |\n | ClientHello             -------->\n | #client_certificate_type#\nF| #server_certificate_type#\nU|\nL|                         <-------    HelloVerifyRequest\nL|\n | ClientHello             -------->\nD| #client_certificate_type#\nT| #server_certificate_type#\nL|\nS|                                            ServerHello\n |                               #client_certificate_type#\nH|                               #server_certificate_type#\nA|                                            Certificate\nN|                                      ServerKeyExchange\nD|                                     CertificateRequest\nS|                         <--------      ServerHelloDone\nH|\nA| Certificate\nK| ClientKeyExchange\nE| CertificateVerify\n | [ChangeCipherSpec]\n | Finished                -------->\n |\n |                                     [ChangeCipherSpec]\n |                         <--------             Finished\n +---",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Note: Extensions marked with \"#\" were introduced with RFC 7250.",
      "ja": "注：「＃」でマークされた拡張機能は、RFC 7250で導入されました。"
    },
    {
      "indent": 10,
      "text": "Figure 4: DTLS/CoAP Exchange Using Resource Directory:\n               Part 1 -- DTLS Handshake",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Figure 5 shows the DTLS-secured communication between the sensor and the resource directory using CoAP.",
      "ja": "図5は、センサとCoAPを使用して、リソースディレクトリ間DTLSで保護された通信を示しています。"
    },
    {
      "indent": 7,
      "text": "                                             Resource\nSensor                                       Directory\n------                                       ---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "[[==============DTLS-Secured Communication===================]]",
      "raw": true
    },
    {
      "indent": 4,
      "text": " +---                                                  ///+\nC|                                                        \\ D\nO| Req: POST coap://rd.example.com/rd?ep=node1            \\ T\nA| Payload:                                               \\ L\nP| </temp>;ct=41;                                         \\ S\n |    rt=\"temperature-c\";if=\"sensor\",                     \\\nR| </light>;ct=41;                                        \\ R\nD|    rt=\"light-lux\";if=\"sensor\"                          \\ E\n |                         -------->                      \\ C\nR|                                                        \\ O\nE|                                                        \\ R\nG|                                     Res: 2.01 Created  \\ D\n |                         <--------  Location: /rd/4521  \\\n |                                                        \\ L\n +---                                                     \\ A\n                                                          \\ Y\n                          *                               \\ E\n                          * (time passes)                 \\ R\n                          *                               \\\n +---                                                     \\ P\nC|                                                        \\ R\nO|              Req: GET coaps://sensor.example.com/temp  \\ O\nA|                         <--------                      \\ T\nP|                                                        \\ E\n | Res:  2.05 Content                                     \\ C\nG| Payload:                                               \\ T\nE| 25.5                     -------->                     \\ E\nT|                                                        \\ D\n +---                                                  ///+",
      "raw": true
    },
    {
      "indent": 10,
      "text": "Figure 5: DTLS/CoAP Exchange Using Resource Directory:\n              Part 2 -- CoAP/RD Exchange",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Note that the CoAP GET message transmitted from the resource server is protected using the previously established DTLS record layer.",
      "ja": "リソースサーバから送信さCoAP GETメッセージは、以前に確立されたDTLS記録層を使用して保護されていることに注意してください。"
    },
    {
      "indent": 0,
      "text": "3.2.2. Constrained TLS/DTLS Servers",
      "section_title": true,
      "ja": "3.2.2。制約TLS / DTLSサーバー"
    },
    {
      "indent": 3,
      "text": "Section 3.2.1 illustrates a deployment model where the TLS/DTLS client is constrained and efforts need to be taken to improve memory utilization, bandwidth consumption, reduce performance impacts, etc. In this section, we assume a scenario where constrained devices run TLS/DTLS servers to secure access to application-layer services running on top of CoAP, HTTP, or other protocols. Figure 6 illustrates a possible deployment whereby a number of constrained servers are waiting for regular clients to access their resources. The entire process is likely, but not necessarily, controlled by a third party, the authentication and authorization server. This authentication and authorization server is responsible for holding authorization policies that govern the access to resources and distribution of keying material.",
      "ja": "3.2.1は、TLS / DTLSクライアントが制約されていると努力は、メモリ使用率、帯域幅の消費を改善するこのセクションでなど、パフォーマンスへの影響を減らすために取られる必要が展開モデルを示し、我々は制約されたデバイスがTLSを実行するシナリオを想定/ CoAP、HTTP、または他のプロトコルの上で動作するアプリケーション層のサービスへのアクセスを確保するためにDTLSサーバ。図6は、通常のクライアントがリソースにアクセスするために制約のあるサーバーの数が待っていることにより、有効な配置を示しています。プロセス全体がそうであるが、必ずしもそうではない、第三者の認証と認可サーバによって制御されます。この認証と認可サーバは、資源や素材をキーイングの分布へのアクセスを管理する認可ポリシーを保持する責任があります。"
    },
    {
      "indent": 3,
      "text": "         +////////////////////////////////////+\n         |          Configuration             |\n         |////////////////////////////////////|\n         | Credentials                        |\n         |    Client A  -> Public Key         |\n         |    Server S1 -> Symmetric Key      |\n         |    Server S2 -> Certificate        |\n         |    Server S3 -> Public Key         |\n         | Trust Anchor Store                 |\n         | Access Control Lists               |\n         |    Resource X: Client A / GET      |\n         |    Resource Y: Client A / PUT      |\n         +------------------------------------+\n             oo\n       oooooo\n      o\n+---------------+                +-----------+\n|Authentication |      +-------->|TLS/DTLS   |\n|& Authorization|      |         |Client A   |\n|Server         |      |         +-----------+\n+---------------+     ++\n             ^        |                  +-----------+\n              \\       |                  |Constrained|\n               \\  ,-------.              | Server S1 |\n                ,'         `.            +-----------+\n               /    Local    \\\n              (    Network    )\n               \\             /        +-----------+\n                `.         ,'         |Constrained|\n                  '---+---'           | Server S2 |\n                      |               +-----------+\n                      |\n                      |                   +-----------+\n                      +-----------------> |Constrained|\n                                          | Server S3 |\n                                          +-----------+",
      "raw": true
    },
    {
      "indent": 19,
      "text": "Figure 6: Constrained Server Profile",
      "ja": "図6：制約Serverプロファイル"
    },
    {
      "indent": 3,
      "text": "A deployment with constrained servers has to overcome several challenges. Below we explain how these challenges can be solved with CoAP, as an example. Other protocols may offer similar capabilities. While the requirements for the TLS/DTLS protocol profile change only slightly when run on a constrained server (in comparison to running it on a constrained client), several other ecosystem factors will impact deployment.",
      "ja": "拘束されたサーバーでの展開は、いくつかの課題を克服しなければなりません。私たちは、これらの課題は、一例として、CoAPで解決することができる方法を説明し、以下の。他のプロトコルは同様の機能を提供することがあります。 TLS / DTLSプロトコルプロファイルの変更のための要件はわずかに（制約クライアント上でそれを実行していると比較して）制約のサーバー上で実行するとしながら、他のいくつかの生態系の要因は、展開に影響を与えます。"
    },
    {
      "indent": 3,
      "text": "There are several challenges that need to be addressed:",
      "ja": "対処する必要のあるいくつかの課題があります。"
    },
    {
      "indent": 3,
      "text": "Discovery and Reachability:",
      "ja": "ディスカバリーおよび到達可能性："
    },
    {
      "indent": 6,
      "text": "A client must first and foremost discover the server before initiating a connection to it. Once it has been discovered, reachability to the device needs to be maintained.",
      "ja": "クライアントは、まず第一に、それへの接続を開始する前に、サーバーを検出する必要があります。それが発見されたら、デバイスへの到達性を維持する必要があります。"
    },
    {
      "indent": 6,
      "text": "In CoAP, the discovery of resources offered by servers is accomplished by sending a unicast or multicast CoAP GET to a well-known URI. The Constrained RESTful Environments (CoRE) Link Format specification [RFC6690] describes the use case (see Section 1.2.1) and reserves the URI (see Section 7.1). Section 7 of the CoAP specification [RFC7252] describes the discovery procedure. [RFC7390] describes the use case for discovering CoAP servers using multicast (see Section 3.3) and specifies the protocol processing rules for CoAP group communications (see Section 2.7).",
      "ja": "CoAPでは、サーバによって提供される資源の発見は、ユニキャストまたはマルチキャストCoAP、よく知られたURIにGETを送信することによって達成されます。制約RESTfulな環境（コア）リンク・フォーマット仕様[RFC6690]は、ユースケースを記述する（第1.2.1項を参照）、URIを（7.1節を参照）を保有しています。 CoAP仕様[RFC7252]のセクション7は、発見手順を説明します。 [RFC7390]はマルチキャストを使用CoAPサーバを発見するためのユースケースを説明し（3.3節を参照）、（セクション2.7を参照）CoAPグループ通信のためのプロトコル処理ルールを指定します。"
    },
    {
      "indent": 6,
      "text": "The use of RD [CoRE-RD] is yet another possibility for discovering registered servers and their resources. Since RD is usually not a proxy, clients can discover links registered with the RD and then access them directly.",
      "ja": "RD [CORE-RD]の使用はまだ登録サーバーとその資源を発見するためのもう一つの可能​​性です。 RDは通常、プロキシではないので、クライアントはRDに登録されたリンクを発見して、それらを直接アクセスすることができます。"
    },
    {
      "indent": 3,
      "text": "Authentication:",
      "ja": "認証："
    },
    {
      "indent": 6,
      "text": "The next challenge concerns the provisioning of authentication credentials to the clients as well as servers. In Section 3.2.1, we assume that credentials (and other configuration information) are provisioned to the device, and that those can be used with the authorization servers. Of course, this leads to a very static relationship between the clients and their server-side infrastructure but poses fewer challenges from a deployment point of view, as described in Section 2 of [RFC7452]. In any case, engineers and product designers have to determine how the relevant credentials are distributed to the respective parties. For example, shared secrets may need to be provisioned to clients and the constrained servers for subsequent use of TLS/DTLS PSK. In other deployments, certificates, private keys, and trust anchors for use with certificate-based authentication may need to be utilized.",
      "ja": "次の課題は、クライアントへの認証資格情報のプロビジョニングと同様に、サーバに関するものです。 3.2.1項では、資格証明書（およびその他の設定情報）をデバイスにプロビジョニング、および認証サーバで使用することができ、これらのことをしていることを前提としています。もちろん、これはクライアントとそのサーバー側のインフラストラクチャとの間に非常に静的な関係につながるが、[RFC7452]のセクション2で説明したように、ビューの展開ポイントから少数の課題を提起します。いずれの場合も、エンジニアやプロダクトデザイナーは、関連する資格情報は、各関係者に配布されている方法を決定する必要があります。例えば、共有秘密は、クライアントおよびTLS / DTLS PSKのその後の使用のために制約のあるサーバーにプロビジョニングする必要があるかもしれません。他の展開、証明書、秘密鍵、および証明書ベースの認証で使用するためのトラストアンカーで利用する必要があるかもしれません。"
    },
    {
      "indent": 6,
      "text": "Practical solutions use either pairing (also called imprinting) or a trusted third party. With pairing, two devices execute a special protocol exchange that is unauthenticated to establish a shared key (for example, using an unauthenticated Diffie-Hellman (DH) exchange). To avoid man-in-the-middle attacks, an out-of-band channel is used to verify that nobody has tampered with the exchanged protocol messages. This out-of-band channel can come in many forms, including:",
      "ja": "実用的なソリューションは、ペアリング（また、インプリンティングと呼ばれる）、または信頼できる第三者のいずれかを使用します。ペアリングと、2つのデバイス（例えば、認証されていないディフィー・ヘルマン（DH）交換を使用して）共有鍵を確立するために認証されていない特殊なプロトコル交換を実行します。 man-in-the-middle攻撃を回避するために、アウトオブバンドチャネルは、誰もが交換プロトコルメッセージを改ざんしていないことを確認するために使用されます。このアウトオブバンドチャネルは、以下を含む多くの形で来ることができます。"
    },
    {
      "indent": 6,
      "text": "* Human involvement by comparing hashed keys, entering passkeys, and scanning QR codes",
      "ja": "、ハッシュキーを比較パスキーを入力し、QRコードをスキャンして*人間の関与"
    },
    {
      "indent": 6,
      "text": "* The use of alternative wireless communication channels (e.g., infrared communication in addition to Wi-Fi)",
      "ja": "*別の無線通信チャネルの使用（例えば、のWi-Fiに加えて、赤外線通信）"
    },
    {
      "indent": 6,
      "text": "* Proximity-based information",
      "ja": "*近接ベースの情報"
    },
    {
      "indent": 6,
      "text": "More details about these different pairing/imprinting techniques can be found in the Smart Object Security Workshop report [RFC7397] and various position papers submitted on that topic, such as [ImprintingSurvey]. The use of a trusted third party follows a different approach and is subject to ongoing standardization efforts in the Authentication and Authorization for Constrained Environments (ACE) working group [ACE-WG].",
      "ja": "これらの異なるペアリング/インプリンティング技術に関する詳細は、スマートオブジェクトのセキュリティワークショップ報告書[RFC7397]や、[ImprintingSurvey]として、そのトピックに提示されたさまざまな位置の論文、で見つけることができます。信頼できるサードパーティの使用は、異なるアプローチに従い、認証および制約のある環境の権限（ACE）ワーキンググループ[ACE-WG]で進行中の標準化努力の主題です。"
    },
    {
      "indent": 3,
      "text": "Authorization",
      "ja": "認定"
    },
    {
      "indent": 6,
      "text": "The last challenge is the ability for the constrained server to make an authorization decision when clients access protected resources. Pre-provisioning access control information to constrained servers may be one option but works only in a small scale, less dynamic environment. For a finer-grained and more dynamic access control solution, the reader is referred to the ongoing work in the IETF ACE working group.",
      "ja": "最後の課題は、クライアントが保護されたリソースへのアクセス許可の決定を行うための制約サーバーの機能です。事前プロビジョニングに制約のあるサーバーへのアクセス制御情報は、1つの選択肢かもしれないが、唯一の小規模であまり動的な環境で動作します。より細かい、よりダイナミックなアクセス制御ソリューションのために、読者はIETF ACEワーキンググループで進行中の作業と呼ばれます。"
    },
    {
      "indent": 3,
      "text": "Figure 7 shows an example interaction whereby a device, a thermostat in our case, searches in the local network for discoverable resources and accesses those. The thermostat starts the procedure using a link-local discovery message using the \"All CoAP Nodes\" multicast address by utilizing the link format per RFC 6690 [RFC6690]. The IPv6 multicast address used for CoAP link-local discovery is FF02::FD. As a result, a temperature sensor and a fan respond. These responses allow the thermostat to subsequently read temperature information from the temperature sensor with a CoAP GET request issued to the previously learned endpoint. In this example we assume that accessing the temperature sensor readings and controlling the fan requires authentication and authorization of the thermostat and TLS is used to authenticate both endpoints and to secure the communication.",
      "ja": "装置、我々の場合にサーモスタットが、発見リソースのローカルネットワーク内で検索し、それらにアクセスすることにより、図7は、例示的な相互作用を示しています。サーモスタットは、RFC 6690 [RFC6690]あたりのリンク形式を利用して「すべてのCoAPノード」マルチキャストアドレスを使用してリンクローカルディスカバリメッセージを使用して手順を開始します。 CoAPリンクローカル発見のために使用されたIPv6マルチキャストアドレスはFF02 :: FDです。その結果、温度センサーとファン応答として。これらの応答は、サーモスタットが、その後以前にエンドポイントを学んだに発行されCoAP GETリクエストに温度センサからの温度情報を読み取ることができます。この例では、温度センサの読みにアクセスして、ファンを制御するサーモスタットの認証と承認を必要とTLSの両方のエンドポイントを認証し、通信を保護するために使用されると仮定する。"
    },
    {
      "indent": 5,
      "text": "                            Temperature\nThermostat                     Sensor              Fan\n----------                   ---------             ---",
      "raw": true
    },
    {
      "indent": 7,
      "text": "Discovery\n-------------------->\nGET coap://[FF02::FD]/.well-known/core",
      "raw": true
    },
    {
      "indent": 6,
      "text": "               CoAP 2.05 Content\n<-------------------------------\n</3303/0/5700>;rt=\"temperature\";\n               if=\"sensor\"",
      "raw": true
    },
    {
      "indent": 6,
      "text": "                                  CoAP 2.05 Content\n<--------------------------------------------------\n                     </fan>;rt=\"fan\";if=\"actuation\"",
      "raw": true
    },
    {
      "indent": 3,
      "text": "+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+\n\\ Protocol steps to obtain access token or keying        /\n\\ material for access to the temperature sensor and fan. /\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Read Sensor Data\n(authenticated/authorized)\n------------------------------->\nGET /3303/0/5700",
      "raw": true
    },
    {
      "indent": 5,
      "text": "               CoAP 2.05 Content\n<-------------------------------\n                          22.5 C",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Configure Actuator\n(authenticated/authorized)\n------------------------------------------------->\nPUT /fan?on-off=true\n                                 CoAP 2.04 Changed\n<-------------------------------------------------",
      "raw": true
    },
    {
      "indent": 15,
      "text": "Figure 7: Local Discovery and Resource Access",
      "ja": "図7：ローカル検索とリソースアクセス"
    },
    {
      "indent": 0,
      "text": "3.3. The Ciphersuite Concept",
      "section_title": true,
      "ja": "3.3。 Ciphersuiteコンセプト"
    },
    {
      "indent": 3,
      "text": "TLS (and consequently DTLS) support ciphersuites, and an IANA registry [IANA-TLS] was created to register the suites. A ciphersuite (and the specification that defines it) contains the following information:",
      "ja": "TLS（ひいてはDTLS）支持暗号スイート、およびIANAレジストリ[IANA-TLS]は、スイートを登録するために作成されました。暗号スイート（およびそれを定義する仕様）は、以下の情報が含まれています。"
    },
    {
      "indent": 3,
      "text": "o Authentication and key exchange algorithm (e.g., PSK)",
      "ja": "O認証及び鍵交換アルゴリズム（例えば、PSK）"
    },
    {
      "indent": 3,
      "text": "o Cipher and key length (e.g., Advanced Encryption Standard (AES) with 128-bit keys [AES])",
      "ja": "O暗号及び鍵の長さ（例えば、高度暗号化標準（AES）128ビットキー[AES]）"
    },
    {
      "indent": 3,
      "text": "o Mode of operation (e.g., Counter with CBC-MAC (CCM) mode for AES) [RFC3610]",
      "ja": "Oモードの動作（例えば、CBC-MAC（CCM）AESのためのモードを有するカウンタ）[RFC3610]"
    },
    {
      "indent": 3,
      "text": "o Hash algorithm for integrity protection, such as the Secure Hash Algorithm (SHA) in combination with Keyed-Hashing for Message Authentication (HMAC) (see [RFC2104] and [RFC6234])",
      "ja": "そのようなメッセージ認証（HMAC）のための鍵付きハッシュと組み合わせたセキュアハッシュアルゴリズム（SHA）のような完全性保護、（[RFC2104]及び[RFC6234]を参照）Oハッシュアルゴリズム"
    },
    {
      "indent": 3,
      "text": "o Hash algorithm for use with pseudorandom functions (e.g., HMAC with the SHA-256)",
      "ja": "擬似ランダム関数で使用するためのOハッシュアルゴリズム（例えば、SHA-256とHMAC）"
    },
    {
      "indent": 3,
      "text": "o Misc information (e.g., length of authentication tags)",
      "ja": "Oその他の情報（例えば、認証タグの長さ）"
    },
    {
      "indent": 3,
      "text": "o Information whether the ciphersuite is suitable for DTLS or only for TLS",
      "ja": "暗号スイートは、DTLSまたはTLSのみに適しているかどうかの情報O"
    },
    {
      "indent": 3,
      "text": "The TLS ciphersuite TLS_PSK_WITH_AES_128_CCM_8, for example, uses a pre-shared authentication and key exchange algorithm. [RFC6655] defines this ciphersuite. It uses the AES encryption algorithm, which is a block cipher. Since the AES algorithm supports different key lengths (such as 128, 192, and 256 bits), this information has to be specified as well, and the selected ciphersuite supports 128-bit keys. A block cipher encrypts plaintext in fixed-size blocks, and AES operates on a block size of 128 bits. For messages exceeding 128 bits, the message is partitioned into 128-bit blocks, and the AES cipher is applied to these input blocks with appropriate chaining, which is called mode of operation.",
      "ja": "TLS暗号スイートTLS_PSK_WITH_AES_128_CCM_8は、例えば、事前共有認証・鍵交換アルゴリズムを使用します。 [RFC6655]は、この暗号スイートを定義します。これは、ブロック暗号であるAES暗号化アルゴリズムを使用しています。 AESアルゴリズムは、異なるキー（例えば128など、192、および256ビット）の長さをサポートしているので、この情報も指定する必要があり、そして選択された暗号スイートは、128ビットのキーをサポートします。ブロック暗号は、固定サイズのブロックに平文を暗号化し、AESは、128ビットのブロックサイズで動作します。 128ビットを超えるメッセージの場合、メッセージは、128ビットのブロックに分割され、AES暗号は、動作モードと呼ばれる適切な連鎖、これらの入力ブロックに適用されます。"
    },
    {
      "indent": 3,
      "text": "TLS 1.2 introduced Authenticated Encryption with Associated Data (AEAD) ciphersuites (see [RFC5116] and [RFC6655]). AEAD is a class of block cipher modes that encrypt (parts of) the message and authenticate the message simultaneously. AES-CCM [RFC6655] is an example of such a mode.",
      "ja": "TLS関連するデータ（AEAD）暗号スイートと1.2導入認証暗号化（[RFC5116]と[RFC6655]を参照）。 AEADメッセージ（の部分）を暗号化ブロック暗号モードのクラスであると同時にメッセージを認証します。 AES-CCM [RFC6655]は、このような形態の一例です。"
    },
    {
      "indent": 3,
      "text": "Some AEAD ciphersuites have shorter authentication tags (i.e., message authentication codes) and are therefore more suitable for networks with low bandwidth where small message size matters. The",
      "ja": "一部AEADの暗号スイートは、より短い認証タグ（すなわち、メッセージ認証コード）を有し、したがって、低帯域幅の小さなメッセージサイズの問題とネットワークにより適しています。ザ・"
    },
    {
      "indent": 3,
      "text": "TLS_PSK_WITH_AES_128_CCM_8 ciphersuite that ends in \"_8\" has an 8-octet authentication tag, while the regular CCM ciphersuites have, at the time of writing, 16-octet authentication tags. The design of CCM and the security properties are described in [CCM].",
      "ja": "通常のCCMの暗号スイートは、執筆時点では、16オクテットの認証タグを持っている一方で、8オクテットの認証タグを持っている「_8」で終わるTLS_PSK_WITH_AES_128_CCM_8暗号スイート。 CCMの設計およびセキュリティプロパティは、[CCM]に記載されています。"
    },
    {
      "indent": 3,
      "text": "TLS 1.2 also replaced the combination of MD5/SHA-1 hash functions in the TLS pseudorandom function (PRF) used in earlier versions of TLS with ciphersuite-specified PRFs. For this reason, authors of more recent TLS 1.2 ciphersuite specifications explicitly indicate the MAC algorithm and the hash functions used with the TLS PRF.",
      "ja": "TLS 1.2はまた、暗号スイートが指定のPRFとTLSの以前のバージョンで使用されるTLSの擬似ランダム関数（PRF）にMD5 / SHA-1ハッシュ関数の組み合わせを置き換えます。このため、より多くの最近のTLS 1.2暗号スイート仕様の著者は、明示的にMACアルゴリズムとTLS PRFで使用されるハッシュ関数を示しています。"
    },
    {
      "indent": 0,
      "text": "4. Credential Types",
      "section_title": true,
      "ja": "4.クレデンシャルタイプ"
    },
    {
      "indent": 3,
      "text": "The mandatory-to-implement functionality will depend on the credential type used with IoT devices. The subsections below describe the implications of three different credential types, namely pre-shared secrets, raw public keys, and certificates.",
      "ja": "実装に必須の機能は、上記IoTデバイスで使用クレデンシャルタイプによって異なります。以下のサブセクションは、3つの異なるクレデンシャルタイプの意味、すなわち、事前共有秘密、生の公開鍵、および証明書について説明します。"
    },
    {
      "indent": 0,
      "text": "4.1. Preconditions",
      "section_title": true,
      "ja": "4.1。前提条件"
    },
    {
      "indent": 3,
      "text": "All exchanges described in the subsequent sections assume that some information has been distributed before the TLS/DTLS interaction starts. The credentials are used to authenticate the client to the server, and vice versa. What information items have to be distributed depends on the chosen credential types. In all cases, the IoT device needs to know what algorithms to prefer, particularly if there are multiple algorithm choices available as part of the implemented ciphersuites, as well as information about the other communication endpoint (for example, in the form of a URI) a particular credential has to be used with.",
      "ja": "次のセクションで説明されているすべての交換はTLS / DTLSの対話を開始する前に、いくつかの情報が配信されていることを前提としています。資格情報は、サーバー、およびその逆に、クライアントを認証するために使用されています。どのような情報項目を分散する必要が選ばれたクレデンシャルタイプによって異なります。全ての場合において、のIoTデバイスは、複数のアルゴリズムの実装暗号スイートの一部として利用可能な選択肢、ならびに（例えば、URIの形で）他の通信エンドポイントに関する情報がある場合は特に、優先するものアルゴリズムを知っている必要があります特定の資格を一緒に使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "Pre-Shared Secrets: In this case, a shared secret together with an identifier needs to be made available to the device as well as to the other communication party.",
      "ja": "事前共有秘密は、この場合には、識別子と共に共有秘密は、通信相手のと同様の装置に利用可能にする必要があります。"
    },
    {
      "indent": 3,
      "text": "Raw Public Keys: A public key together with a private key are stored on the device and typically associated with some identifier. To authenticate the other communication party, the appropriate credential has to be known. If the other end uses raw public keys as well, then their public key needs to be provisioned (out of band) to the device.",
      "ja": "生の公開鍵：秘密鍵と一緒に、公開鍵は、デバイス上に保存され、典型的には、いくつかの識別子に関連付けられています。通信相手を認証するには、適切な資格は知られていなければなりません。もう一方の端は、同様に生の公開鍵を使用する場合、その公開鍵は、デバイスに（帯域外）にプロビジョニングする必要があります。"
    },
    {
      "indent": 3,
      "text": "Certificates: The use of certificates requires the device to store the public key (as part of the certificate) as well as the private key. The certificate will contain the identifier of the device as well as various other attributes. Both communication parties are assumed to be in possession of a trust anchor store that contains CA certificates and, in case of certificate pinning, end-entity certificates. Similar to the other credentials, the IoT device needs information about which entity to use which certificate with. Without a trust anchor store on the IoT device, it will not be possible to perform certificate validation.",
      "ja": "証明書：証明書の使用は、公開鍵（証明書の一部として）と同様に、秘密鍵を格納するためのデバイスが必要です。証明書は、デバイスの識別子だけでなく、様々な他の属性が含まれます。両方の通信当事者が証明書のピニング、エンドエンティティ証明書の場合には、CA証明書を含むトラストアンカーストアの所持にあると仮定しています。他の資格情報と同様に、のIoTデバイスが持つどの証明書を使用したエンティティに関する情報を必要とします。 IoTデバイス上のトラストアンカーストアがなければ、証明書の検証を実行することはできません。"
    },
    {
      "indent": 3,
      "text": "We call the above-listed information \"device credentials\" and these device credentials may be provisioned to the device already during the manufacturing time or later in the process, depending on the envisioned business and deployment model. These initial credentials are often called \"root of trust\". Whatever process is chosen for generating these initial device credentials, it MUST be ensured that a different key pair is provisioned for each device and installed in as secure a manner as possible. For example, it is preferable to generate public/private keys on the IoT device itself rather than generating them outside the device. Since an IoT device is likely to interact with various other parties, the initial device credential may only be used with some dedicated entities, and configuring further configuration and credentials to the device is left to a separate interaction. An example of a dedicated protocol used to distribute credentials, access control lists, and configure information is the LWM2M protocol [LWM2M].",
      "ja": "私たちは、「デバイスクレデンシャル」上に挙げた情報を呼び出し、これらのデバイスクレデンシャルは、想定のビジネスと展開モデルに応じて、後工程での製造時間の間、すでにデバイスにプロビジョニングまたはすることができます。これらの初期の資格情報は、多くの場合、「信頼のルート」と呼ばれています。これらの初期のデバイスクレデンシャルを生成するために選択されるどのようなプロセスは、異なる鍵のペアは、各デバイスにプロビジョニングし、できるだけ安全な方法でインストールされていることを保証しなければなりません。例えば、装置外部、それらを生成するのではなく、のIoTデバイス自体に公開/秘密鍵を生成することが好ましいです。 IoTデバイスは、他のさまざまな関係者と相互作用する可能性があるので、最初のデバイスクレデンシャルは、いくつかの専用のエンティティと使用することができ、デバイスにさらに構成や資格情報を設定するには、別の相互作用に委ねられています。専用認証情報を配布するために使用されるプロトコル、アクセス制御リスト、および情報を設定する例は、[LWM2M] LWM2Mプロトコルです。"
    },
    {
      "indent": 3,
      "text": "For all the credentials listed above, there is a chance that those may need to be replaced or deleted. While separate protocols have been developed to check the status of these credentials and to manage these credentials, such as the Trust Anchor Management Protocol (TAMP) [RFC5934], their usage is, however, not envisioned in the IoT context so far. IoT devices are assumed to have a software update mechanism built-in, and it will allow updates of low-level device information, including credentials and configuration parameters. This document does, however, not mandate a specific software/firmware update protocol.",
      "ja": "上記のすべての資格情報については、それらを交換したり、削除する必要があるかもしれないという可能性があります。別のプロトコルはこれらの証明書の状態を確認し、このようなトラストアンカー管理プロトコル（TAMP）[RFC5934]のようにこれらの資格情報を、管理するために開発されてきたが、その使用は、しかし、これまでのIoTコンテキストでは想定されていません。 IoTデバイスは内蔵のソフトウェア更新メカニズムを持っていると仮定され、それが資格情報と設定パラメータを含む低レベルのデバイス情報の更新を、できるようになります。この文書では、しかし、特定のソフトウェア/ファームウェアのアップデートプロトコルを強制しません。"
    },
    {
      "indent": 3,
      "text": "With all credentials used as input to TLS/DTLS authentication, it is important that these credentials have been generated with care. When using a pre-shared secret, a critical consideration is using sufficient entropy during the key generation, as discussed in [RFC4086]. Deriving a shared secret from a password, some device identifiers, or other low-entropy sources is not secure. A low-entropy secret, or password, is subject to dictionary attacks. Attention also has to be paid when generating public/private key pairs since the lack of randomness can result in the same key pair being used in many devices. This topic is also discussed in Section 12 since keys are generated during the TLS/DTLS exchange itself as well, and the same considerations apply.",
      "ja": "TLS / DTLS認証への入力として使用されているすべての資格情報を使用すると、これらの資格情報は注意して生成されていることが重要です。事前共有秘密を使用する場合、重要な考慮事項は、[RFC4086]で説明したように、鍵生成中に十分なエントロピーを使用しています。パスワード、一部のデバイス識別子、または他の低エントロピーソースから共有秘密を導出することは安全ではありません。低エントロピー秘密、またはパスワードが、辞書攻撃の対象となります。注意また、公開鍵/秘密鍵のペアを生成するときにランダム性の欠如は、多くのデバイスで使用されている同じキーペアになりますので、支払う必要があります。キーが同様にTLS / DTLS交換自体の中に生成されるので、ここでは、また、セクション12で説明され、同じ考慮事項が当てはまります。"
    },
    {
      "indent": 0,
      "text": "4.2. Pre-Shared Secret",
      "section_title": true,
      "ja": "4.2。事前共有秘密"
    },
    {
      "indent": 3,
      "text": "The use of pre-shared secrets is one of the most basic techniques for TLS/DTLS since it is both computationally efficient and bandwidth conserving. Authentication based on pre-shared secrets was introduced to TLS in RFC 4279 [RFC4279].",
      "ja": "それは両方の計算効率と帯域幅の節約であるため、事前共有秘密を使用すると、TLS / DTLSのための最も基本的な技術の一つです。事前共有秘密に基づく認証は、RFC 4279 [RFC4279]にTLSに導入しました。"
    },
    {
      "indent": 3,
      "text": "Figure 8 illustrates the DTLS exchange including the cookie exchange. While the server is not required to initiate a cookie exchange with every handshake, the client is required to implement and to react on it when challenged, as defined in RFC 6347 [RFC6347]. The cookie exchange allows the server to react to flooding attacks.",
      "ja": "図8は、クッキー交換を含むDTLS交換を示す図です。サーバはすべてのハンドシェイクでクッキー交換を開始するために必要とされていないが、クライアントは、RFC 6347 [RFC6347]で定義されるように、実装し、挑戦したときにそれに反応することが必要です。クッキー交換はサーバがフラッド攻撃に対応することができます。"
    },
    {
      "indent": 9,
      "text": "Client                                               Server\n------                                               ------\nClientHello                 -------->",
      "raw": true
    },
    {
      "indent": 37,
      "text": "<--------    HelloVerifyRequest\n              (contains cookie)",
      "raw": true
    },
    {
      "indent": 9,
      "text": "ClientHello                  -------->\n(with cookie)\n                                                ServerHello\n                                         *ServerKeyExchange\n                             <--------      ServerHelloDone\nClientKeyExchange\nChangeCipherSpec\nFinished                     -------->\n                                           ChangeCipherSpec\n                             <--------             Finished",
      "raw": true
    },
    {
      "indent": 9,
      "text": "Application Data             <------->     Application Data",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Legend:",
      "ja": "伝説："
    },
    {
      "indent": 3,
      "text": "* indicates an optional message payload",
      "ja": "*オプションのメッセージ・ペイロードを示し"
    },
    {
      "indent": 6,
      "text": "Figure 8: DTLS PSK Authentication Including the Cookie Exchange",
      "ja": "図8：DTLS PSK認証Cookieの交換を含みます"
    },
    {
      "indent": 3,
      "text": "Note that [RFC4279] used the term \"PSK identity\" to refer to the identifier used to refer to the appropriate secret. While \"identifier\" would be more appropriate in this context, we reuse the terminology defined in RFC 4279 to avoid confusion. RFC 4279 does not mandate the use of any particular type of PSK identity, and the client and server have to agree on the identities and keys to be used. The UTF-8 encoding of identities described in Section 5.1 of RFC 4279 aims to improve interoperability for those cases where the identity is configured by a human using some management interface provided by a web browser. However, many IoT devices do not have a user interface, and most of their credentials are bound to the device rather than to the user. Furthermore, credentials are often provisioned into hardware modules or provisioned alongside with firmware. As such, the encoding considerations are not applicable to this usage environment. For use with this profile, the PSK identities SHOULD NOT assume a structured format (such as domain names, distinguished names, or IP addresses), and a byte-by-byte comparison operation MUST be used by the server for any operation related to the PSK identity. These types of identifiers are called \"absolute\" per RFC 6943 [RFC6943].",
      "ja": "[RFC4279]は適切な秘密を指すために使用される識別子を参照するために用語「PSK同一性」を使用することに留意されたいです。 「識別子」は、この文脈では、より適切であろうが、我々は混乱を避けるために、RFC 4279で定義された用語を再利用します。 RFC 4279は、PSKの身元の特定のタイプの使用を強制しないと、クライアントとサーバが使用されるIDとキーに同意する必要があります。 RFC 4279のセクション5.1に記載のアイデンティティのUTF-8エンコーディングは、IDがWebブラウザによって提供されるいくつかの管理インターフェースを使用して、人間によって構成されているような場合のための相互運用性を改善することを目的とします。しかし、多くのIoTデバイスは、ユーザーインターフェイスを持っていない、と自分の資格情報のほとんどがデバイスにではなく、ユーザーにバインドされています。さらに、資格情報は、多くの場合、ハードウェアモジュールにプロビジョニングまたはファームウェアと一緒にプロビジョニングされています。そのため、符号化の考慮事項は、この使用環境には適用されません。このプロファイルで使用する場合は、PSKのアイデンティティが構造化形式を仮定するべきではありませんし、バイト単位の比較演算（例えばドメイン名、識別名、またはIPアドレスなど）に関連するすべての操作のために、サーバによって使用されなければなりませんPSKアイデンティティ。識別子のこれらのタイプは、RFC 6943 [RFC6943]あたりの「絶対」と呼ばれています。"
    },
    {
      "indent": 3,
      "text": "Protocol-wise, the client indicates which key it uses by including a \"PSK identity\" in the ClientKeyExchange message. As described in Section 3.2, clients may have multiple pre-shared keys with a single server, for example, in a hosting context. The TLS Server Name Indication (SNI) extension allows the client to convey the name of the server it is contacting. A server implementation needs to guide the selection based on a received SNI value from the client.",
      "ja": "プロトコルごと、クライアントはClientKeyExchangeメッセージで「PSKのアイデンティティ」を含むことにより、使用するキーを示しています。セクション3.2で説明したように、クライアントは、ホスティング文脈において、例えば、単一のサーバで複数の事前共有キーを有していてもよいです。 TLSサーバー名の表示（SNI）拡張は、クライアントは、それが接触しているサーバーの名前を伝えることができます。サーバーの実装は、クライアントから受け取ったSNI値に基づいて選択をガイドする必要があります。"
    },
    {
      "indent": 3,
      "text": "RFC 4279 requires TLS implementations supporting PSK ciphersuites to support arbitrary PSK identities up to 128 octets in length and arbitrary PSKs up to 64 octets in length. This is a useful assumption for TLS stacks used in the desktop and mobile environments where management interfaces are used to provision identities and keys. Implementations in compliance with this profile MAY use PSK identities up to 128 octets in length and arbitrary PSKs up to 64 octets in length. The use of shorter PSK identities is RECOMMENDED.",
      "ja": "RFC 4279は、PSKの暗号スイートをサポートするTLSの実装は長さが64オクテットまでの長さと任意PSKs 128オクテットまでの任意のPSK IDをサポートするために必要です。これは、管理インターフェイスを提供アイデンティティ及びキーに使用されているデスクトップおよびモバイル環境で使用されるTLSスタックのために有用な仮定です。このプロファイルに準拠した実装は128、長さオクテット、長さが64オクテットまでの任意のPSKsまでPSKアイデンティティを使用するかもしれません。短いPSK IDの使用が推奨されます。"
    },
    {
      "indent": 3,
      "text": "\"The Constrained Application Protocol (CoAP)\" [RFC7252] currently specifies TLS_PSK_WITH_AES_128_CCM_8 as the mandatory-to-implement ciphersuite for use with shared secrets. This ciphersuite uses the AES algorithm with 128 bit keys and CCM as the mode of operation. The label \"_8\" indicates that an 8-octet authentication tag is used. Note that the shorted authentication tag increases the chance that an adversary with no knowledge of the secret key can present a message with a MAC that will pass the verification procedure. The likelihood of accepting forged data is explained in Section 5.3.5 of [SP800-107-rev1] and depends on the lengths of the authentication tag and allowed numbers of MAC verifications using a given key.",
      "ja": "「制約アプリケーションプロトコル（CoAP）」[RFC7252]は、現在の共有秘密で使用するために強制的に実装暗号スイートとしてTLS_PSK_WITH_AES_128_CCM_8を指定します。この暗号スイートは、動作モードとして128ビットキーとCCMとAESアルゴリズムを使用します。ラベル「_8は」8オクテットの認証タグが使用されていることを示しています。短絡認証タグが秘密鍵の知識を有する敵対者は、検証手順を通過するMACとメッセージを提示することができる可能性を増加させることに留意されたいです。偽造データを受け入れる可能性が[SP800-107-REV1]のセクション5.3.5で説明した認証タグの長さに依存し、与えられたキーを使用して、MACの検証の数が許容されます。"
    },
    {
      "indent": 3,
      "text": "This ciphersuite makes use of the default TLS 1.2 PRF, which uses an HMAC with the SHA-256 hash function. Note: Starting with TLS 1.2 (and consequently DTLS 1.2), ciphersuites have to specify the PRF. RFC 5246 states that \"New cipher suites MUST explicitly specify a PRF and, in general, SHOULD use the TLS PRF with SHA-256 or a stronger standard hash function.\" The ciphersuites recommended in this document use the SHA-256 construct defined in Section 5 of RFC 5246.",
      "ja": "この暗号スイートは、SHA-256ハッシュ関数でHMACを使用するデフォルトのTLS 1.2 PRFを利用します。注意：TLS 1.2以降で（その結果、1.2 DTLS）、暗号スイートは、PRFを指定する必要があります。 RFC 5246には、「新しい暗号スイートを明示的にPRFを指定しなければならないと、一般的には、SHA-256とTLS PRFまたはより強力な標準ハッシュ関数を使用すべきである。」と述べていますこのドキュメントで推奨暗号スイートは、RFC 5246のセクション5で定義されたSHA-256構文を使用します。"
    },
    {
      "indent": 3,
      "text": "A device compliant with the profile in this section MUST implement TLS_PSK_WITH_AES_128_CCM_8 and follow the guidance from this section.",
      "ja": "このセクションでは、プロファイルに準拠したデバイスは、TLS_PSK_WITH_AES_128_CCM_8を実装し、このセクションの指導に従わなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.3. Raw Public Key",
      "section_title": true,
      "ja": "4.3。生の公開鍵"
    },
    {
      "indent": 3,
      "text": "The use of raw public keys with TLS/DTLS, as defined in [RFC7250], is the first entry point into public key cryptography without having to pay the price of certificates and a public key infrastructure (PKI). The specification reuses the existing Certificate message to convey the raw public key encoded in the SubjectPublicKeyInfo structure. To indicate support, two new extensions had been defined, as shown in Figure 9, namely the server_certificate_type and the client_certificate_type.",
      "ja": "[RFC7250]で定義されるようにTLS / DTLSと生の公開鍵の使用は、証明書の価格と公開鍵インフラストラクチャ（PKI）を支払うことなく、公開鍵暗号への最初のエントリポイントです。仕様はSubjectPublicKeyInfoで構造で符号化された生の公開鍵を伝えるために、既存の証明書のメッセージを再利用します。図9、すなわちserver_certificate_typeとclient_certificate_typeに示すように、支持を示すために、二つの新しい機能拡張は、定義されていました。"
    },
    {
      "indent": 4,
      "text": "Client                                          Server\n------                                          ------",
      "raw": true
    },
    {
      "indent": 4,
      "text": "ClientHello             -------->\n#client_certificate_type#\n#server_certificate_type#",
      "raw": true
    },
    {
      "indent": 28,
      "text": "                   ServerHello\n     #client_certificate_type#\n     #server_certificate_type#\n                   Certificate\n             ServerKeyExchange\n            CertificateRequest\n<--------      ServerHelloDone",
      "raw": true
    },
    {
      "indent": 4,
      "text": "Certificate\nClientKeyExchange\nCertificateVerify\n[ChangeCipherSpec]\nFinished                -------->",
      "raw": true
    },
    {
      "indent": 28,
      "text": "            [ChangeCipherSpec]\n<--------             Finished",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Note: Extensions marked with \"#\" were introduced with RFC 7250.",
      "ja": "注：「＃」でマークされた拡張機能は、RFC 7250で導入されました。"
    },
    {
      "indent": 18,
      "text": "Figure 9: DTLS Raw Public Key Exchange",
      "ja": "図9：DTLS生の公開鍵交換"
    },
    {
      "indent": 3,
      "text": "The CoAP-recommended ciphersuite for use with this credential type is TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 [RFC7251]. This AES-CCM TLS ciphersuite based on elliptic curve cryptography (ECC) uses the Ephemeral Elliptic Curve Diffie-Hellman (ECDHE) as the key establishment mechanism and an Elliptic Curve Digital Signature",
      "ja": "この資格タイプで使用するためCoAP推奨暗号スイートはTLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 [RFC7251]です。楕円曲線暗号（ECC）に基づいて、このAES-CCM TLSの暗号スイートは、鍵確立機構としてエフェメラル楕円曲線ディフィ - ヘルマン（ECDHE）と楕円曲線デジタル署名を使用し"
    },
    {
      "indent": 3,
      "text": "Algorithm (ECDSA) for authentication. The named DH groups [FFDHE-TLS] are not applicable to this profile since it relies on the ECC-based counterparts. This ciphersuite makes use of the AEAD capability in DTLS 1.2 and utilizes an 8-octet authentication tag. The use of a DH key exchange provides perfect forward secrecy (PFS). More details about PFS can be found in Section 9.",
      "ja": "認証のためのアルゴリズム（ECDSA）。それはECCベースの対応に依存していることから名付けられDHグループ[FFDHE-TLS]は、このプロファイルには適用されません。この暗号スイートは、DTLS 1.2でAEAD機能を利用し、8オクテットの認証タグを利用しています。 DH鍵交換の使用は完全転送秘密（PFS）を提供します。 PFSについての詳細は、第9章で見つけることができます。"
    },
    {
      "indent": 3,
      "text": "[RFC6090] provides valuable information for implementing ECC algorithms, particularly for choosing methods that have been available in the literature for a long time (i.e., 20 years and more).",
      "ja": "[RFC6090]は、特に長い時間（すなわち、20年以上）のために、文献に利用されてきた方法を選択するため、ECCアルゴリズムを実装するための貴重な情報を提供します。"
    },
    {
      "indent": 3,
      "text": "A device compliant with the profile in this section MUST implement TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 and follow the guidance from this section.",
      "ja": "このセクションでは、プロファイルに準拠したデバイスは、TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8を実装し、このセクションの指導に従わなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.4. Certificates",
      "section_title": true,
      "ja": "4.4。証明書"
    },
    {
      "indent": 3,
      "text": "The use of mutual certificate-based authentication is shown in Figure 10, which makes use of the \"cached_info\" extension [RFC7924]. Support of the \"cached_info\" extension is REQUIRED. Caching certificate chains allows the client to reduce the communication overhead significantly, otherwise the server would provide the end-entity certificate and the certificate chain with every full DTLS handshake.",
      "ja": "相互証明書ベースの認証の使用は、「cached_info」拡張[RFC7924]を利用し、図10に示されています。 「cached_info」拡張子のサポートが必要です。キャッシュ証明書チェーンそれ以外のサーバは、すべてフルDTLS握手して、エンドエンティティ証明書と証明書チェーンを提供する、クライアントが大幅に通信オーバーヘッドを削減することができます。"
    },
    {
      "indent": 4,
      "text": "Client                                          Server\n------                                          ------",
      "raw": true
    },
    {
      "indent": 4,
      "text": "ClientHello             -------->\n*cached_info*",
      "raw": true
    },
    {
      "indent": 28,
      "text": "                   ServerHello\n                 *cached_info*\n                   Certificate\n             ServerKeyExchange\n            CertificateRequest\n<--------      ServerHelloDone",
      "raw": true
    },
    {
      "indent": 4,
      "text": "Certificate\nClientKeyExchange\nCertificateVerify\n[ChangeCipherSpec]\nFinished                -------->",
      "raw": true
    },
    {
      "indent": 28,
      "text": "            [ChangeCipherSpec]\n<--------             Finished",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Note: Extensions marked with \"*\" were introduced with RFC 7924.",
      "ja": "注意：でマークされた拡張機能を「*」RFC 7924で導入されました。"
    },
    {
      "indent": 10,
      "text": "Figure 10: DTLS Mutual Certificate-Based Authentication",
      "ja": "図10：DTLS相互証明書ベースの認証"
    },
    {
      "indent": 3,
      "text": "TLS/DTLS offers a lot of choices when selecting ECC-based ciphersuites. This document restricts the use to named curves defined in RFC 4492 [RFC4492]. At the time of writing, the recommended curve is secp256r1, and the use of uncompressed points follows the recommendation in CoAP. Note that standardization for Curve25519 (for ECDHE) is ongoing (see [RFC7748]), and support for this curve will likely be required in the future.",
      "ja": "TLS / DTLSはECCベースの暗号群を選択する選択肢の多くを提供しています。この文書は、RFC 4492 [RFC4492]で定義された名前の曲線への使用を制限します。執筆時点では、推奨される曲線はsecp256r1あり、かつ非圧縮ポイントの使用はCoAPにおける勧告に従っています。 （ECDHE用）Curve25519ための標準化は、（[RFC7748]を参照）進行中であり、そしてこの曲線のためのサポートはおそらく将来的に必要とされることに注意してください。"
    },
    {
      "indent": 3,
      "text": "A device compliant with the profile in this section MUST implement TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 and follow the guidance from this section.",
      "ja": "このセクションでは、プロファイルに準拠したデバイスは、TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8を実装し、このセクションの指導に従わなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.4.1. Certificates Used by Servers",
      "section_title": true,
      "ja": "4.4.1。サーバーで使用される証明書"
    },
    {
      "indent": 3,
      "text": "The algorithm for verifying the service identity, as described in RFC 6125 [RFC6125], is essential for ensuring proper security when certificates are used. As a summary, the algorithm contains the following steps:",
      "ja": "RFC 6125 [RFC6125]で説明したように、サービスの身元を確認するためのアルゴリズムは、証明書が使用されるときに、適切なセキュリティを確保するために不可欠です。まとめとして、アルゴリズムは、次の手順が含まれています。"
    },
    {
      "indent": 3,
      "text": "1. The client constructs a list of acceptable reference identifiers based on the source domain and, optionally, the type of service to which the client is connecting.",
      "ja": "1.クライアントは、必要に応じて、ソースドメインに基づいており、許容される参照識別子のリスト、クライアントが接続されているサービスのタイプを構築します。"
    },
    {
      "indent": 3,
      "text": "2. The server provides its identifiers in the form of a PKIX certificate.",
      "ja": "2.サーバは、PKIX証明書の形でその識別子を提供します。"
    },
    {
      "indent": 3,
      "text": "3. The client checks each of its reference identifiers against the presented identifiers for the purpose of finding a match.",
      "ja": "3.クライアントは、一致を見つけるために提示識別子に対するその参照識別子の各々をチェックします。"
    },
    {
      "indent": 3,
      "text": "4. When checking a reference identifier against a presented identifier, the client matches the source domain of the identifiers and, optionally, their application service type.",
      "ja": "提示された識別子に対する参照識別子をチェックするとき4.クライアントは、ソース識別子のドメインと、必要に応じて、それらのアプリケーションサービスタイプと一致します。"
    },
    {
      "indent": 3,
      "text": "For various terms used in the algorithm shown above, consult RFC 6125. It is important to highlight that comparing the reference identifier against the presented identifier obtained from the certificate is required to ensure the client is communicating with the intended server.",
      "ja": "上に示したアルゴリズムで使用される種々の用語のために、証明書から取得提示識別子に対する参照識別子を比較すると、クライアントは、目的のサーバーと通信している保証するために必要であることを強調することが重要であるRFC 6125を参照してください。"
    },
    {
      "indent": 3,
      "text": "It is worth noting that the algorithm description and the text in RFC 6125 assumes that fully qualified DNS domain names are used. If a server node is provisioned with a fully qualified DNS domain, then the server certificate MUST contain the fully qualified DNS domain name or \"FQDN\" as dNSName [RFC5280]. For CoAP, the coaps URI scheme is described in Section 6.2 of [RFC7252]. This FQDN is stored in the SubjectAltName or in the leftmost Common Name (CN) component of the subject name, as explained in Section 9.1.3.3 of [RFC7252], and used by the client to match it against the FQDN used during the lookup process, as described in [RFC6125]. For other protocols, the appropriate URI scheme specification has to be consulted.",
      "ja": "アルゴリズム記述およびRFC 6125のテキストは、完全修飾DNSドメイン名が使用されていることを前提としていることは注目に値します。サーバ・ノードは、完全修飾DNSドメインでプロビジョニングされている場合は、サーバ証明書は、完全修飾DNSドメイン名またはのdNSName [RFC5280]として「FQDN」を含まなければなりません。 CoAPため、coaps URIスキームは[RFC7252]のセクション6.2に記載されています。このFQDNは、[RFC7252]のセクション9.1.3.3で説明したように、サブジェクト名の（CN）成分のSubjectAltNameまたは左端共通名に格納され、ルックアッププロセス中に使用されるFQDNに対してそれを一致させるためにクライアントによって使用されます、[RFC6125]に記載されているように。他のプロトコルの場合は、適切なURIスキーム仕様は相談する必要があります。"
    },
    {
      "indent": 3,
      "text": "The following recommendation is provided:",
      "ja": "以下の推奨事項が提供されます。"
    },
    {
      "indent": 3,
      "text": "1. Certificates MUST NOT use DNS domain names in the CN of certificates and instead use the subjectAltName attribute, as described in the previous paragraph.",
      "ja": "前の段落で説明したように1証明書は、証明書のCNにDNSドメイン名を使用し、代わりのsubjectAltName属性を使用してはなりません。"
    },
    {
      "indent": 3,
      "text": "2. Certificates MUST NOT contain domain names with wildcard characters.",
      "ja": "2.証明書は、ワイルドカード文字を使用したドメイン名を含めることはできません。"
    },
    {
      "indent": 3,
      "text": "3. Certificates MUST NOT contain multiple names (e.g., more than one dNSName field).",
      "ja": "3.証明書は、複数の名前（例えば、複数のdNSNameフィールド）を含んでいてはなりません。"
    },
    {
      "indent": 3,
      "text": "Note that there will be servers that are not provisioned for use with DNS domain names, for example, IoT devices that offer resources to nearby devices in a local area network, as shown in Figure 7. When such constrained servers are used, then the use of certificates as described in Section 4.4.2 is applicable. Note that the SNI extension cannot be used in this case since SNI does not offer the ability to convey a 64-bit Extended Unique Identifier (EUI-64) [EUI64]. Note that this document does not recommend use of IP addresses in certificates nor does it discuss the implications of placing IP addresses in certificates.",
      "ja": "例えばDNSドメイン名を使用するためにプロビジョニングされていないサーバーは、そのような制約のあるサーバーが使用されている場合は、図7に示すように、ローカル・エリア・ネットワークに近くのデバイスにリソースを提供する、のIoTデバイス、そして使用が可能になることに注意してくださいセクションで説明したように、証明書の4.4.2を適用することが可能です。 SNIは、64ビット拡張固有識別子（EUI64）を伝達する能力を提供しないので、[EUI64] SNI拡張はこの場合に使用することができないことに留意されたいです。この文書は、証明書内のIPアドレスの使用はお勧めしません。また、証明書にIPアドレスを置くことの意味を話し合うないことに注意してください。"
    },
    {
      "indent": 0,
      "text": "4.4.2. Certificates Used by Clients",
      "section_title": true,
      "ja": "4.4.2。クライアントが使用する証明書"
    },
    {
      "indent": 3,
      "text": "For client certificates, the identifier used in the SubjectAltName or in the leftmost CN component of subject name MUST be an EUI-64.",
      "ja": "クライアント証明書のために、のSubjectAltNameまたはサブジェクト名の左端CNコンポーネントで使用される識別子は、EUI-64でなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.4.3. Certificate Revocation",
      "section_title": true,
      "ja": "4.4.3。証明書失効"
    },
    {
      "indent": 3,
      "text": "For certificate revocation, neither the Online Certificate Status Protocol (OCSP) nor Certificate Revocation Lists (CRLs) are used. Instead, this profile relies on a software update mechanism to provision information about revoked certificates. While multiple OCSP stapling [RFC6961] has recently been introduced as a mechanism to piggyback OCSP request/responses inside the DTLS/TLS handshake (to avoid the cost of a separate protocol handshake), further investigations are needed to determine its suitability for the IoT environment.",
      "ja": "証明書の失効については、オンライン証明書状態プロトコル（OCSP）も証明書失効リスト（CRL）のどちらが使用されています。その代わり、このプロファイルは、失効した証明書に関する提供情報へのソフトウェア更新メカニズムに依存しています。 [RFC6961]をステープル複数OCSP最近DTLS / TLSハンドシェイク内部OCSP要求/応答を（別のプロトコルハンドシェイクのコストを回避するため）ピギーバックするためのメカニズムとして導入されてきたが、更なる研究がのIoT環境に対するその適合性を決定するために必要とされます。"
    },
    {
      "indent": 3,
      "text": "As stated earlier in this section, modifications to the trust anchor store depends on a software update mechanism as well. There are limitations to the use of a software update mechanism because of the potential inability to change certain types of keys, such as those provisioned during manufacturing. For this reason, manufacturer-provisioned credentials are typically employed only to obtain further certificates (for example, via a key distribution server) for use with servers the IoT device is finally communicating with.",
      "ja": "このセクションですでに述べたように、トラストアンカーストアへの変更は、同様に、ソフトウェアの更新のメカニズムに依存します。なぜなら、このような製造時にプロビジョニングされるようなキーの特定の種類を変更する可能性不能のソフトウェア更新メカニズムの使用に制限があります。この理由から、製造業者プロビジョニング資格情報は、典型的には、唯一のIoTデバイスが最後に通信しているサーバーで使用するための（鍵配信サーバを経由して例えば、）さらに証明書を取得するために使用されます。"
    },
    {
      "indent": 0,
      "text": "4.4.4. Certificate Content",
      "section_title": true,
      "ja": "4.4.4。証明書の内容"
    },
    {
      "indent": 3,
      "text": "All certificate elements listed in Table 1 MUST be implemented by clients and servers claiming support for certificate-based authentication. No other certificate elements are used by this specification.",
      "ja": "表1に記載されているすべての証明書の要素は、証明書ベースの認証のサポートを主張し、クライアントとサーバーで実装されなければなりません。他の証明書の要素は、本明細書で使用されていません。"
    },
    {
      "indent": 3,
      "text": "When using certificates, IoT devices MUST provide support for a server certificate chain of at least 3, not including the trust anchor, and MAY reject connections from servers offering chains longer than 3. IoT devices MAY have client certificate chains of any length. Obviously, longer chains require more digital signature verification operations to perform and lead to larger certificate messages in the TLS handshake.",
      "ja": "証明書を使用する場合、のIoTデバイスはありませんトラストアンカーを含む、および3のIoTデバイスは、任意の長さのクライアント証明書チェーンを持っているよりも長い鎖を提供するサーバーからの接続を拒否するかもしれ、少なくとも3のサーバ証明書チェーンのサポートを提供しなければなりません。明らかに、より長い鎖を行い、TLSハンドシェイクが大きく証明書メッセージにつながる複数のデジタル署名の検証作業が必要です。"
    },
    {
      "indent": 3,
      "text": "Table 1 provides a summary of the elements in a certificate for use with this profile.",
      "ja": "表1は、このプロファイルで使用する証明書の要素の概要を提供します。"
    },
    {
      "indent": 3,
      "text": "+----------------------+--------------------------------------------+\n|       Element        |                   Notes                    |\n+----------------------+--------------------------------------------+\n|       version        |  This profile uses X.509 v3 certificates   |\n|                      |                 [RFC5280].                 |\n|                      |                                            |\n|     serialNumber     |  Positive integer unique per certificate.  |\n|                      |                                            |\n|      signature       |     This field contains the signature      |\n|                      |  algorithm, and this profile uses ecdsa-   |\n|                      |     with-SHA256 or stronger [RFC5758].     |\n|                      |                                            |\n|        issuer        |     Contains the DN of the issuing CA.     |\n|                      |                                            |\n|       validity       | Values expressed as UTC time in notBefore  |\n|                      |  and notAfter fields.  No validity period  |\n|                      |                 mandated.                  |\n|                      |                                            |\n|       subject        |    See rules outlined in this section.     |\n|                      |                                            |\n| subjectPublicKeyInfo |     The SubjectPublicKeyInfo structure     |\n|                      | indicates the algorithm and any associated |\n|                      |  parameters for the ECC public key.  This  |\n|                      | profile uses the id-ecPublicKey algorithm  |\n|                      |  identifier for ECDSA signature keys, as   |\n|                      |    defined and specified in [RFC5480].     |\n|                      |                                            |\n|  signatureAlgorithm  | The ECDSA signature algorithm with ecdsa-  |\n|                      |          with-SHA256 or stronger.          |\n|                      |                                            |\n|    signatureValue    |     Bit string containing the digital      |\n|                      |                 signature.                 |\n|                      |                                            |",
      "raw": true
    },
    {
      "indent": 3,
      "text": "|      Extension:      |    See rules outlined in this section.     |\n|    subjectAltName    |                                            |\n|                      |                                            |\n|      Extension:      |    Indicates whether the subject of the    |\n|   BasicConstraints   | certificate is a CA and the maximum depth  |\n|                      | of valid certification paths that include  |\n|                      | this certificate.  This extension is used  |\n|                      |  for CA certs only, and then the value of  |\n|                      |    the \"cA\" field is set to TRUE.  The     |\n|                      |             default is FALSE.              |\n|                      |                                            |\n| Extension: Key Usage | The KeyUsage field MAY have the following  |\n|                      |   values in the context of this profile:   |\n|                      |     digitalSignature or keyAgreement,      |\n|                      |  keyCertSign for verifying signatures on   |\n|                      |          public key certificates.          |\n|                      |                                            |\n| Extension: Extended  |  The ExtKeyUsageSyntax field MAY have the  |\n|      Key Usage       |    following values in context of this     |\n|                      |    profile: id-kp-serverAuth for server    |\n|                      |    authentication, id-kp-clientAuth for    |\n|                      |  client authentication, id-kp-codeSigning  |\n|                      |   for code signing (for software update    |\n|                      |   mechanism), and id-kp-OCSPSigning for    |\n|                      |         future OCSP usage in TLS.          |\n+----------------------+--------------------------------------------+",
      "raw": true
    },
    {
      "indent": 23,
      "text": "Table 1: Certificate Content",
      "ja": "表1：証明書の内容"
    },
    {
      "indent": 3,
      "text": "There are various cryptographic algorithms available to sign digital certificates; those algorithms include RSA, the Digital Signature Algorithm (DSA), and ECDSA. As Table 1 shows, certificates are signed using ECDSA in this profile. This is not only true for the end-entity certificates but also for all other certificates in the chain, including CA certificates. This profiling reduces the amount of flash memory needed on an IoT device to store the code of several algorithm implementations due to the smaller number of options.",
      "ja": "デジタル証明書に署名するために利用できる様々な暗号化アルゴリズムがあります。これらのアルゴリズムは、RSAデジタル署名アルゴリズム（DSA）、およびECDSAを含みます。表1に示すように、証明書は、このプロファイルにECDSAを使用して署名されます。これは、エンドエンティティ証明書だけでなく、CA証明書を含む、チェーン内の他のすべての証明書、のためだけではなく、真実です。このプロファイルは、オプションの少ない数に起因するいくつかのアルゴリズムの実装のコードを格納するためのIoTデバイスに必要なフラッシュ・メモリの量を減少させます。"
    },
    {
      "indent": 3,
      "text": "Further details about X.509 certificates can be found in Section 9.1.3.3 of [RFC7252].",
      "ja": "X.509証明書についての詳細は[RFC7252]のセクション9.1.3.3に記載されています。"
    },
    {
      "indent": 0,
      "text": "4.4.5. Client Certificate URLs",
      "section_title": true,
      "ja": "4.4.5。クライアント証明書のURL"
    },
    {
      "indent": 3,
      "text": "RFC 6066 [RFC6066] allows the sending of client-side certificates to be avoided and uses URLs instead. This reduces the over-the-air transmission. Note that the TLS \"cached_info\" extension does not provide any help with caching client certificates.",
      "ja": "RFC 6066 [RFC6066]は、クライアント側の証明書の送信を回避することが可能となり、代わりにURLを使用しています。これは、空中伝送を低減します。 TLS「cached_info」拡張子がキャッシュクライアント証明書を持つ任意のヘルプを提供しないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "TLS/DTLS clients MUST implement support for client certificate URLs for those environments where client-side certificates are used and the server-side is not constrained. For constrained servers this functionality is NOT RECOMMENDED since it forces the server to execute an additional protocol exchange, potentially using a protocol it does not even support. The use of this extension also increases the risk of a DoS attack against the constrained server due to the additional workload.",
      "ja": "TLS / DTLSクライアントは、クライアント側の証明書が使用され、サーバー側が制約されていないこれらの環境のためのクライアント証明書のURLのサポートを実装しなければなりません。それは潜在的にそれもサポートしていないプロトコルを使用して、追加のプロトコル交換を実行するために、サーバーを強制ので、拘束されたサーバの場合、この機能は推奨されません。この拡張機能の使用はまた、追加のワークロードに拘束サーバに対してDoS攻撃のリスクを増大させます。"
    },
    {
      "indent": 0,
      "text": "4.4.6. Trusted CA Indication",
      "section_title": true,
      "ja": "4.4.6。信頼できるCAの表示"
    },
    {
      "indent": 3,
      "text": "RFC 6066 [RFC6066] allows clients to indicate what trust anchor they support. With certificate-based authentication, a DTLS server conveys its end-entity certificate to the client during the DTLS handshake. Since the server does not necessarily know what trust anchors the client has stored, to facilitate certification path construction and validation, it includes intermediate CA certs in the certificate payload.",
      "ja": "RFC 6066 [RFC6066]はクライアントがサポートするものを信頼アンカーを示すことができます。証明書ベースの認証では、DTLSサーバは、DTLSハンドシェイク中にクライアントにそのエンドエンティティ証明書を伝えます。サーバーは必ずしもクライアントを固定するものを信頼知りませんが、証明書パスの構築と検証を容易にするため、保存されているので、それは証明書のペイロード内の中間CA証明書が含まれています。"
    },
    {
      "indent": 3,
      "text": "Today, in most IoT deployments there is a fairly static relationship between the IoT device (and the software running on them) and the server-side infrastructure. For these deployments where IoT devices interact with a fixed, preconfigured set of servers, this extension is NOT RECOMMENDED.",
      "ja": "今日では、ほとんどのIoTでのIoTデバイス（およびその上で動作するソフトウェア）とサーバー側のインフラストラクチャの間にかなりの静的な関係があるデプロイメント。 IoTデバイスはサーバの固定された、事前に構成セットと対話するこれらの展開では、この拡張機能は推奨されません。"
    },
    {
      "indent": 3,
      "text": "In cases where clients interact with dynamically discovered TLS/DTLS servers, for example, in the use cases described in Section 3.2.2, the use of this extension is RECOMMENDED.",
      "ja": "クライアントが動的に検出TLS / DTLSサーバとの対話例では、例えば、3.2.2項で説明したユースケースでは、この拡張の使用が推奨されます。"
    },
    {
      "indent": 0,
      "text": "5. Signature Algorithm Extension",
      "section_title": true,
      "ja": "5.署名アルゴリズム拡張"
    },
    {
      "indent": 3,
      "text": "The \"signature_algorithms\" extension, defined in Section 7.4.1.4.1 of RFC 5246 [RFC5246], allows the client to indicate to the server which signature/hash algorithm pairs may be used in digital signatures. The client MUST send this extension to select the use of SHA-256, otherwise if this extension is absent, RFC 5246 defaults to SHA-1 / ECDSA for the ECDH_ECDSA and the ECDHE_ECDSA key exchange algorithms.",
      "ja": "RFC 5246のセクション7.4.1.4.1 [RFC5246]で定義された「signature_algorithms」拡張は、クライアントは、署名/ハッシュアルゴリズム対がデジタル署名に使用することができるサーバに指示することを可能にします。クライアントは、RFC、この拡張が存在しないそうでない場合には、SHA-256の使用を選択するECDH_ECDSAとECDHE_ECDSA鍵交換アルゴリズムのSHA-1 / ECDSAに5246のデフォルトはこの拡張を送らなければなりません。"
    },
    {
      "indent": 3,
      "text": "The \"signature_algorithms\" extension is not applicable to the PSK-based ciphersuite described in Section 4.2.",
      "ja": "「signature_algorithms」拡張は、セクション4.2で説明PSKベースの暗号スイートには適用できません。"
    },
    {
      "indent": 0,
      "text": "6. Error Handling",
      "section_title": true,
      "ja": "6.エラー処理"
    },
    {
      "indent": 3,
      "text": "TLS/DTLS uses the alert protocol to convey errors and specifies a long list of error types. However, not all error messages defined in the TLS/DTLS specification are applicable to this profile. In general, there are two categories of errors (as defined in Section 7.2 of RFC 5246), namely fatal errors and warnings. Alert",
      "ja": "TLS / DTLSは、エラーを伝えるために、警告プロトコルを使用して、エラーの種類の長いリストを指定します。しかし、TLS / DTLS仕様で定義されたすべてのエラーメッセージは、このプロファイルには適用されません。一般的に、エラーの二つのカテゴリー（RFC 5246のセクション7.2で定義されるように）、即ち、致命的なエラーおよび警告があります。警戒"
    },
    {
      "indent": 3,
      "text": "messages with a level of \"fatal\" result in the immediate termination of the connection. If possible, developers should try to develop strategies to react to those fatal errors, such as restarting the handshake or informing the user using the (often limited) user interface. Warnings may be ignored by the application since many IoT devices will have either limited ways to log errors or no ability at all. In any case, implementers have to carefully evaluate the impact of errors and ways to remedy the situation since a commonly used approach for delegating decision making to users is difficult (or impossible) to accomplish in a timely fashion.",
      "ja": "接続の即時終了で「致命的な」結果のレベルを持つメッセージ。可能ならば、開発者は、このようなハンドシェイクを再起動するか、（多くの場合、制限された）ユーザー・インターフェースを使用してユーザーに通知するように、これらの致命的なエラーに反応する戦略を開発しようとする必要があります。多くのIoTデバイスがエラーまたはまったく能力をログに記録する限られた方法のいずれかを持っていますので、警告は、アプリケーションによって無視されることがあります。ユーザーに意思決定を委任するために一般的に使用されるアプローチは、タイムリーに実現することは困難（または不可能）であるため、いずれの場合も、実装者は慎重に状況を改善するために、エラーや方法の影響を評価する必要があります。"
    },
    {
      "indent": 3,
      "text": "All error messages marked as RESERVED are only supported for backwards compatibility with the Secure Socket Layer (SSL) and MUST NOT be used with this profile. Those include decryption_failed_RESERVED, no_certificate_RESERVED, and export_restriction_RESERVED.",
      "ja": "RESERVEDとマークされたすべてのエラーメッセージは、唯一のSecure Socket Layer（SSL）との後方互換性のためにサポートされており、このプロファイルで使用してはいけません。これらはdecryption_failed_RESERVED、no_certificate_RESERVED、およびexport_restriction_RESERVEDが含まれます。"
    },
    {
      "indent": 3,
      "text": "A number of the error messages MUST only be used for certificate-based ciphersuites. Hence, the following error messages MUST NOT be used with PSK and raw public key authentication:",
      "ja": "エラーメッセージの数は、証明書ベースの暗号群を使用しなければなりません。したがって、次のエラーメッセージがPSKと生公開鍵認証で使用することはできません。"
    },
    {
      "indent": 3,
      "text": "o bad_certificate,",
      "ja": "bad_certificate O、"
    },
    {
      "indent": 3,
      "text": "o unsupported_certificate,",
      "ja": "unsupported_certificate O、"
    },
    {
      "indent": 3,
      "text": "o certificate_revoked,",
      "ja": "O certificate_revoked、"
    },
    {
      "indent": 3,
      "text": "o certificate_expired,",
      "ja": "、certificate_expired O"
    },
    {
      "indent": 3,
      "text": "o certificate_unknown,",
      "ja": "certificate_unknown O、"
    },
    {
      "indent": 3,
      "text": "o unknown_ca, and",
      "ja": "、unknown_ca Oと"
    },
    {
      "indent": 3,
      "text": "o access_denied.",
      "ja": "O ACCESS_DENIED。"
    },
    {
      "indent": 3,
      "text": "Since this profile does not make use of compression at the TLS layer, the decompression_failure error message MUST NOT be used either.",
      "ja": "このプロファイルは、TLS層での圧縮を使用しないので、decompression_failureのエラーメッセージのいずれか使用してはいけません。"
    },
    {
      "indent": 3,
      "text": "RFC 4279 introduced the new alert message \"unknown_psk_identity\" for PSK ciphersuites. As stated in Section 2 of RFC 4279, the decrypt_error error message may also be used instead. For this profile, the TLS server MUST return the decrypt_error error message instead of the unknown_psk_identity since the two mechanisms exist and provide the same functionality.",
      "ja": "RFC 4279は、PSKの暗号スイートのための新たな警告メッセージ「unknown_psk_identity」を導入しました。 RFC 4279の2節で述べたように、decrypt_errorエラーメッセージもまた用いてもよいです。このプロファイルのために、TLSサーバは、二つのメカニズムが存在するので、代わりunknown_psk_identityのdecrypt_errorエラーメッセージを返すと同じ機能を提供しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Furthermore, the following errors should not occur with devices and servers supporting this specification, but implementations MUST be prepared to process these errors to deal with servers that are not compliant to the profiles in this document:",
      "ja": "さらに、次のエラーがこの仕様をサポートするデバイスやサーバでは発生しませんが、実装はこの文書のプロファイルに準拠していないサーバに対処するために、これらのエラーを処理するために準備しなければなりません。"
    },
    {
      "indent": 3,
      "text": "protocol_version: While this document focuses only on one version of the TLS/DTLS protocol, namely version 1.2, ongoing work on TLS/ DTLS 1.3 is in progress at the time of writing.",
      "ja": "PROTOCOL_VERSION：この文書は唯一のTLS / DTLSプロトコルの1つのバージョン、つまり、バージョン1.2に焦点を当てているが、TLS / DTLS 1.3で進行中の作業は、執筆時点で進行中です。"
    },
    {
      "indent": 3,
      "text": "insufficient_security: This error message indicates that the server requires ciphers to be more secure. This document specifies only one ciphersuite per profile, but it is likely that additional ciphersuites will get added over time.",
      "ja": "insufficient_security：このエラーメッセージは、サーバがより安全になるように暗号が必要であることを示しています。この文書では、プロファイルごとに1つだけの暗号スイートを指定しますが、追加の暗号スイートは、時間をかけて追加されます可能性が高いです。"
    },
    {
      "indent": 3,
      "text": "user_canceled: Many IoT devices are unattended and hence this error message is unlikely to occur.",
      "ja": "user_canceled：多くのIoTデバイスが無人であるので、このエラーメッセージが発生しにくいです。"
    },
    {
      "indent": 0,
      "text": "7. Session Resumption",
      "section_title": true,
      "ja": "7.セッション再開"
    },
    {
      "indent": 3,
      "text": "Session resumption is a feature of the core TLS/DTLS specifications that allows a client to continue with an earlier established session state. The resulting exchange is shown in Figure 11. In addition, the server may choose not to do a cookie exchange when a session is resumed. Still, clients have to be prepared to do a cookie exchange with every handshake. The cookie exchange is not shown in the figure.",
      "ja": "セッション再開は、クライアントが以前に確立されたセッションの状態を継続することを可能にするコアTLS / DTLS仕様の機能です。得られた交換はまた、サーバは、セッションが再開されたときにクッキー交換を実行しないことを選んでもよい。図11に示されています。それでも、クライアントは、すべてのハンドシェークのクッキー交換を行うために準備する必要があります。クッキー交換は、図に示されていません。"
    },
    {
      "indent": 9,
      "text": "Client                                               Server\n------                                               ------",
      "raw": true
    },
    {
      "indent": 9,
      "text": "ClientHello                   -------->\n                                                 ServerHello\n                                          [ChangeCipherSpec]\n                              <--------             Finished\n[ChangeCipherSpec]\nFinished                      -------->\nApplication Data              <------->     Application Data",
      "raw": true
    },
    {
      "indent": 20,
      "text": "Figure 11: DTLS Session Resumption",
      "ja": "図11：DTLSセッション再開"
    },
    {
      "indent": 3,
      "text": "Constrained clients MUST implement session resumption to improve the performance of the handshake. This will lead to a reduced number of message exchanges, lower computational overhead (since only symmetric cryptography is used during a session resumption exchange), and session resumption requires less bandwidth.",
      "ja": "制約付きのクライアントは握手のパフォーマンスを向上させるために、セッションの再開を実装しなければなりません。これは、メッセージ交換の数の減少、（唯一の対称暗号セッション再開交換中に使用されるので）より低い計算オーバーヘッドにつながる、セッション再開は、より少ない帯域幅を必要とします。"
    },
    {
      "indent": 3,
      "text": "For cases where the server is constrained (but not the client), the client MUST implement RFC 5077 [RFC5077]. Note that the constrained",
      "ja": "サーバは、（クライアントではない）に制約される場合のために、クライアントは、RFC 5077 [RFC5077]を実装しなければなりません。制約のことに注意してください"
    },
    {
      "indent": 3,
      "text": "server refers to a device that has limitations in terms of RAM and flash memory, which place restrictions on the amount of TLS/DTLS security state information that can be stored on such a device. RFC 5077 specifies a version of TLS/DTLS session resumption that does not require per-session state information to be maintained by the constrained server. This is accomplished by using a ticket-based approach.",
      "ja": "サーバは、RAM、フラッシュメモリの点で制限を有するデバイスは、そのようなデバイスに記憶することができるTLS / DTLSセキュリティ状態情報の量に場所の制限を意味します。 RFC 5077は、拘束されたサーバーによって維持されるように、セッションごとの状態情報を必要としないTLS / DTLSセッション再開のバージョンを指定します。これは、チケットベースのアプローチを使用することによって達成されます。"
    },
    {
      "indent": 3,
      "text": "If both the client and the server are constrained devices, both devices SHOULD implement RFC 5077 and MUST implement basic session resumption. Clients that do not want to use session resumption are always able to send a ClientHello message with an empty session_id to revert to a full handshake.",
      "ja": "クライアントとサーバーの両方がデバイスを拘束されている場合は、両方のデバイスは、RFC 5077を実装する必要がありますし、基本的なセッション再開を実装しなければなりません。セッション再開を使用しないクライアントは、常に完全な握手に戻すために、空のsession_idでClientHelloメッセージを送信することができます。"
    },
    {
      "indent": 0,
      "text": "8. Compression",
      "section_title": true,
      "ja": "8.圧縮"
    },
    {
      "indent": 3,
      "text": "Section 3.3 of [RFC7525] recommends disabling TLS-/DTLS-level compression due to attacks, such as CRIME [CRIME]. For IoT applications, compression at the TLS/DTLS layer is not needed since application-layer protocols are highly optimized, and the compression algorithms at the DTLS layer increases code size and complexity.",
      "ja": "[RFC7525]のセクション3.3は、そのような犯罪[犯罪]などの攻撃にTLS- / DTLSレベルの圧縮を無効にすることをお勧めします。 IoTアプリケーションのために、アプリケーション層のプロトコルは、高度に最適化されているので、TLS / DTLS層における圧縮が必要とされない、及びDTLS層における圧縮アルゴリズムは、コードサイズおよび複雑さを増大させます。"
    },
    {
      "indent": 3,
      "text": "TLS/DTLS layer compression is NOT RECOMMENDED by this TLS/DTLS profile.",
      "ja": "TLS / DTLS層の圧縮は、このTLS / DTLSプロファイルによって推奨されません。"
    },
    {
      "indent": 0,
      "text": "9. Perfect Forward Secrecy",
      "section_title": true,
      "ja": "9.完全転送秘密"
    },
    {
      "indent": 3,
      "text": "PFS is a property that preserves the confidentiality of past protocol interactions even in situations where the long-term secret is compromised.",
      "ja": "PFSは、さらに長期的な秘密が侵害された状況では過去のプロトコルの相互作用の機密性を保持するプロパティです。"
    },
    {
      "indent": 3,
      "text": "The PSK ciphersuite recommended in Section 4.2 does not offer this property since it does not utilize a DH exchange. New ciphersuites that support PFS for PSK-based authentication, such as proposed in [PSK-AES-CCM-TLS], might become available as a standardized ciphersuite in the (near) future. The recommended PSK-based ciphersuite offers excellent performance, a very small memory footprint, and has the lowest on the wire overhead at the expense of not using any public cryptography. For deployments where public key cryptography is acceptable, the use of raw public keys might offer a middle ground between the PSK ciphersuite in terms of out-of-band validation and the functionality offered by asymmetric cryptography.",
      "ja": "それはDH交換を利用していないため、4.2節で推奨PSK暗号スイートは、このプロパティを提供していません。 PSKベース認証のためのPFSをサポートする新たな暗号スイートは、[PSK-AES-CCM-TLS]で提案されているような、（近い）将来に標準化された暗号スイートとして利用可能になるかもしれません。推奨PSKベースの暗号スイートは、優れた性能、非常に小さなメモリフットプリントを提供し、あらゆる公共の暗号を使用していないを犠牲にして、ワイヤのオーバーヘッドの最低を持っています。公開鍵暗号が許容される展開では、生の公開鍵を使用することは、アウトオブバンドの検証および非対称暗号によって提供される機能性の観点からPSK暗号スイートの間で妥協点を提供するかもしれません。"
    },
    {
      "indent": 3,
      "text": "Physical attacks create additional opportunities to gain access to the crypto material stored on IoT devices. A PFS ciphersuite prevents an attacker from obtaining the communication content exchanged prior to a successful long-term key compromise; however, an implementation that (for performance or energy efficiency reasons) has been reusing the same ephemeral DH keys over multiple different sessions partially defeats PFS, thus increasing the damage extent. For this reason, implementations SHOULD NOT reuse ephemeral DH keys over multiple protocol exchanges.",
      "ja": "物理的な攻撃は、上記IoTデバイスに格納されている暗号材料へのアクセスを得るための追加の機会を作成します。 PFSの暗号スイートは、成功した長期キー妥協する前に交換し、通信コンテンツを取得からの攻撃を阻止します。しかし、複数の異なるセッションにわたって同じ短命DHキーを再利用されている（性能またはエネルギー効率の理由のために）部分的にこのような損傷の程度を増加させる、PFSを無効にすることを実現。このため、実装は複数のプロトコル交換を超える短命のDHキーを再利用すべきではありません。"
    },
    {
      "indent": 3,
      "text": "The impact of the disclosure of past communication interactions and the desire to increase the cost for pervasive monitoring (as demanded by [RFC7258]) has to be taken into account when selecting a ciphersuite that does not support the PFS property.",
      "ja": "過去の通信の相互作用の開示の影響およびパーベイシブ監視のためのコストを増大させる要望が（[RFC7258]によって要求されるように）PFSのプロパティをサポートしていない暗号スイートを選択する際に考慮しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Client implementations claiming support of this profile MUST implement the ciphersuites listed in Section 4 according to the selected credential type.",
      "ja": "このプロファイルのサポートを主張クライアントインプリメンテーションは、選択された信任状タイプに応じて、セクション4に記載されている暗号スイートを実装しなければなりません。"
    },
    {
      "indent": 0,
      "text": "10. Keep-Alive",
      "section_title": true,
      "ja": "10.キープアライブ"
    },
    {
      "indent": 3,
      "text": "Application-layer communication may create state at the endpoints, and this state may expire at some time. For this reason, applications define ways to refresh state, if necessary. While the application-layer exchanges are largely outside the scope of the underlying TLS/DTLS exchange, similar state considerations also play a role at the level of TLS/DTLS. While TLS/DTLS also creates state in the form of a security context (see the security parameter described in Appendix A.6 in RFC 5246) at the client and the server, this state information does not expire. However, network intermediaries may also allocate state and require this state to be kept alive. Failure to keep state alive at a stateful packet filtering firewall or at a NAT may result in the inability for one node to reach the other since packets will get blocked by these middleboxes. Periodic keep-alive messages exchanged between the TLS/ DTLS client and server keep state at these middleboxes alive. According to measurements described in [HomeGateway], there is some variance in state management practices used in residential gateways, but the timeouts are heavily impacted by the choice of the transport-layer protocol: timeouts for UDP are typically much shorter than those for TCP.",
      "ja": "アプリケーション層の通信は、エンドポイントの状態を作成することが、この状態は、ある時点で有効期限が切れることができます。このため、アプリケーションは、必要に応じて、状態をリフレッシュする方法を定義します。アプリケーション層の交流が大きく下地TLS / DTLS交換の範囲外であるが、同様の状態の考慮はまた、TLS / DTLSのレベルで役割を果たしています。 TLS / DTLSは、セキュリティコンテキストの形で状態を作成しますが、クライアントとサーバーでの（RFC 5246の付録A.6に記載したセキュリティパラメータを参照）、この状態情報は有効期限はありません。しかし、ネットワークの仲介も状態を割り当て、生き続けなければ、この状態が必要な場合があります。ステートフルパケットフィルタリングファイアウォールで、またはNATで生きている状態を保つために失敗すると、パケットがこれらのミドルボックスによってブロックされてしまいますので、他に到達するために1つのノードに対してできなくなることがあります。定期的なキープアライブメッセージは、生きているこれらのミドルボックスの状態を保つTLS / DTLSクライアントとサーバ間で交換しました。 [HomeGateway]で説明した測定結果によると、住宅用ゲートウェイで使用される状態管理慣行のいくつかのばらつきがありますが、タイムアウトが重く、トランスポート層プロトコルの選択によって影響を受ける：UDPのタイムアウトは、通常、TCPのためのものよりはるかに短いです。"
    },
    {
      "indent": 3,
      "text": "RFC 6520 [RFC6520] defines a heartbeat mechanism to test whether the other peer is still alive. As an additional feature, the same mechanism can also be used to perform Path Maximum Transmission Unit (MTU) Discovery.",
      "ja": "RFC 6520 [RFC6520]は、他のピアがまだ生きているかどうかをテストするためのハートビート機構を定義します。追加の特徴として、同一の機構もパスの最大伝送単位（MTU）ディスカバリを実行するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "A recommendation about the use of RFC 6520 depends on the type of message exchange an IoT device performs and the number of messages the application needs to exchange as part of their application functionality. There are three types of exchanges that need to be analyzed:",
      "ja": "RFC 6520の使用に関する推奨は、メッセージ交換のタイプに依存するのIoT装置が実行し、メッセージの数は、アプリケーションは、そのアプリケーションの機能の一部として交換する必要があります。分析する必要があるの交流の3つのタイプがあります。"
    },
    {
      "indent": 3,
      "text": "Client-Initiated, One-Shot Messages",
      "ja": "クライアントが開始し、ワンショット・メッセージ"
    },
    {
      "indent": 6,
      "text": "This is a common communication pattern where IoT devices upload data to a server on the Internet on an irregular basis. The communication may be triggered by specific events, such as opening a door.",
      "ja": "これは、のIoTデバイスは、不定期に、インターネット上のサーバにデータをアップロードし、共通の通信パターンです。通信は、ドアを開けるなどの特定のイベントによってトリガされてもよいです。"
    },
    {
      "indent": 6,
      "text": "The DTLS handshake may need to be restarted (ideally using session resumption, if possible) in case of an IP address change.",
      "ja": "DTLSハンドシェイクは、IPアドレスの変更の場合には（理想的に可能であれば、セッション再開を使用して）再起動する必要があります。"
    },
    {
      "indent": 6,
      "text": "In this case, there is no use for a keep-alive extension for this scenario.",
      "ja": "この場合、このシナリオのためのキープアライブ拡張のための使用はありません。"
    },
    {
      "indent": 3,
      "text": "Client-Initiated, Regular Data Uploads",
      "ja": "クライアントが開始し、通常のデータアップロード"
    },
    {
      "indent": 6,
      "text": "This is a variation of the previous case whereby data gets uploaded on a regular basis, for example, based on frequent temperature readings. If neither NAT bindings nor IP address changes occurred, then the record layer will not notice any changes. For the case where the IP address and port number changes, it is necessary to recreate the record layer using session resumption.",
      "ja": "これは、例えば、頻繁な温度読み取り値に基づいてデータを定期的にアップロードされますれる前のケースの変形です。どちらもNATバインディングやIPアドレスの変更が発生した場合は、記録層には、すべての変更を気付くことはありません。 IPアドレスとポート番号を変更する場合には、セッション再開を使用して記録層を再作成する必要があります。"
    },
    {
      "indent": 6,
      "text": "In this scenario, there is no use for a keep-alive extension. It is also very likely that the device will enter a sleep cycle in between data transmissions to keep power consumption low.",
      "ja": "このシナリオでは、キープアライブ拡張のための使用はありません。また、デバイスは、低消費電力を維持するために、データ伝送の間に睡眠サイクルに入る可能性が非常に高いです。"
    },
    {
      "indent": 3,
      "text": "Server-Initiated Messages",
      "ja": "サーバ起動メッセージ"
    },
    {
      "indent": 6,
      "text": "In the two previous scenarios, the client initiates the protocol interaction and maintains it. Since messages to the client may get blocked by middleboxes, the initial connection setup is triggered by the client and then kept alive by the server.",
      "ja": "前の2つのシナリオでは、クライアントは、プロトコルの対話を開始し、それを維持します。クライアントへのメッセージは、ミドルボックスによってブロックされるかもしれませんので、初期接続設定は、クライアントによってトリガし、サーバーによって生かされています。"
    },
    {
      "indent": 6,
      "text": "For this message exchange pattern, the use of DTLS heartbeat messages is quite useful but may have to be coordinated with application exchanges (for example, when the CoAP resource directory is used) to avoid redundant keep-alive message exchanges. The MTU discovery mechanism, which is also part of [RFC6520], is less likely to be relevant since for many IoT deployments, the most constrained link is the wireless interface between the IoT device and the network itself (rather than some links along the end-to-end path). Only in more complex network topologies, such as multi-hop mesh networks, path MTU discovery might be appropriate. It also has to be noted that DTLS itself already provides a basic path discovery mechanism (see Section 4.1.1.1 of RFC 6347) by using the fragmentation capability of the handshake protocol.",
      "ja": "このメッセージ交換パターンのため、DTLSハートビートメッセージを使用することは非常に有用であるが、冗長なキープアライブメッセージ交換を回避するために、（CoAPリソースディレクトリが使用され、例えば、）アプリケーション交換と協調しなければならないかもしれません。多くのIoT展開のため、ほとんどの拘束リンクのIoTデバイスおよびネットワーク自体（よりむしろ端に沿っていくつかのリンクとの間の無線インターフェースであるため、また、[RFC6520]の一部であるMTU発見メカニズムは、関連する可能性が低いです-to-エンドパス）。のみ、このようなマルチホップメッシュネットワークなどのより複雑なネットワークトポロジで、パスMTUディスカバリーが適切かもしれません。また、ハンドシェイクプロトコルの断片化能力を用いて、（RFC 6347のセクション4.1.1.1を参照）DTLS自体は既に基本的な経路発見機構を提供することに留意しなければなりません。"
    },
    {
      "indent": 3,
      "text": "For server-initiated messages, the heartbeat extension is RECOMMENDED.",
      "ja": "サーバーが開始したメッセージの場合、ハートビートの拡張子を推奨します。"
    },
    {
      "indent": 0,
      "text": "11. Timeouts",
      "section_title": true,
      "ja": "11.タイムアウト"
    },
    {
      "indent": 3,
      "text": "A variety of wired and wireless technologies are available to connect devices to the Internet. Many of the low-power radio technologies, such as IEEE 802.15.4 or Bluetooth Smart, only support small frame sizes (e.g., 127 bytes in case of IEEE 802.15.4 as explained in [RFC4919]). Other radio technologies, such as the Global System for Mobile Communications (GSM) using the short messaging service (SMS), have similar constraints in terms of payload sizes, such as 140 bytes without the optional segmentation and reassembly scheme known as \"Concatenated SMS\", but show higher latency.",
      "ja": "有線および無線技術の様々なインターネットにデバイスを接続するために使用できます。例えばIEEE 802.15.4またはBluetoothスマートなどの低電力無線技術の多くは、（[RFC4919]で説明したように、例えば、IEEE 802.15.4の場合には127バイト）だけ小さいフレームサイズをサポートします。ショートメッセージサービス（SMS）を使用して、移動体通信用グローバルシステム（GSM）のような他の無線技術は、ペイロードサイズの点で同様の制約が、例えば140バイトとして「連結SMS」として知られている任意のセグメンテーションとリアセンブリスキーム無ししかし、より長い待ち時間を示しています。"
    },
    {
      "indent": 3,
      "text": "The DTLS handshake protocol adds a fragmentation and reassembly mechanism to the TLS handshake protocol since each DTLS record must fit within a single transport layer datagram, as described in Section 4.2.3 of [RFC6347]. Since handshake messages are potentially bigger than the maximum record size, the mechanism fragments a handshake message over a number of DTLS records, each of which can be transmitted separately.",
      "ja": "[RFC6347]のセクション4.2.3に記載したように各DTLSレコードは、単一のトランスポート層データグラム内に収まらなければならないので、DTLSハンドシェイクプロトコルは、TLSハンドシェイクプロトコルにフラグメンテーションおよび再組み立て機構を付加します。ハンドシェークメッセージは最大レコード・サイズよりも潜在的に大きくしているので、機構が別々に送信されることができるそれぞれがDTLSレコードの数を超えるハンドシェイクメッセージを断片化。"
    },
    {
      "indent": 3,
      "text": "To deal with the unreliable message delivery provided by UDP, DTLS adds timeouts and \"per-flight\" retransmissions, as described in Section 4.2.4 of [RFC6347]. Although the timeout values are implementation specific, recommendations are provided in Section 4.2.4.1 of [RFC6347], with an initial timer value of 1 second and double the value at each retransmission, up to no less than 60 seconds.",
      "ja": "[RFC6347]のセクション4.2.4で説明したようにUDPが提供する信頼性のないメッセージ配信に対処するために、DTLSは、タイムアウトや「あたり飛行」の再送を追加します。タイムアウト値は実装特有であるが、推奨はない60秒未満まで、各再送で1秒の初期タイマ値と二重値と、[RFC6347]のセクション4.2.4.1に設けられています。"
    },
    {
      "indent": 3,
      "text": "TLS protocol steps can take longer due to higher processing time on the constrained side. On the other hand, the way DTLS handles retransmission, which is per-flight instead of per-segment, tends to interact poorly with low-bandwidth networks.",
      "ja": "TLSプロトコル手順は、制約された側に起因する高い処理時間に時間がかかることがあります。一方、DTLSはフライトごとの代わりごとのセグメントで再送を、処理する方法は、低帯域幅のネットワークと悪い対話する傾向があります。"
    },
    {
      "indent": 3,
      "text": "For these reasons, it's essential that the probability of a spurious retransmit is minimized and, on timeout, the sending endpoint does not react too aggressively. The latter is particularly relevant when the Wireless Sensor Network (WSN) is temporarily congested: if lost packets are reinjected too quickly, congestion worsens.",
      "ja": "これらの理由から、それはタイムアウトで、送信エンドポイントがあまりにも積極的に反応せず、スプリアス再送の確率が最小化されることが不可欠だと。失われたパケットがあまりにも急速に再注入されている場合、輻輳が悪化：後者は、ワイヤレスセンサネットワーク（WSN）が一時的に混雑している時に特に関連があります。"
    },
    {
      "indent": 3,
      "text": "An initial timer value of 9 seconds with exponential back off up to no less then 60 seconds is therefore RECOMMENDED.",
      "ja": "劣らず、その後60秒にバックアップをオフ指数と9秒の初期タイマ値は、したがって、推奨されます。"
    },
    {
      "indent": 3,
      "text": "This value is chosen big enough to absorb large latency variance due to either slow computation on constrained endpoints or intrinsic network characteristics (e.g., GSM-SMS), as well as to produce a low number of retransmission events and relax the pacing between them. Its worst case wait time is the same as using 1s timeout (i.e., 63s), while triggering less than half of the retransmissions (2 instead of 5).",
      "ja": "この値が原因制約エンドポイントまたは固有ネットワーク特性に遅い計算のいずれかに大きなレイテンシ変動を吸収するのに十分な大きさに選択される（例えば、GSM-SMS）、ならびに再送信イベントの低い数を生成し、それらの間にペーシングを緩和します。 （2の代わりに5）再送の半分未満トリガしながら、その最悪の場合の待機時間は、1秒のタイムアウト（即ち、63S）を使用した場合と同じです。"
    },
    {
      "indent": 3,
      "text": "In order to minimize the wake time during DTLS handshake, sleepy nodes might decide to select a lower threshold and, consequently, a smaller initial timeout value. If this is the case, the implementation MUST keep into account the considerations about network stability described in this section.",
      "ja": "DTLSハンドシェイク中に覚醒時間を最小限に抑えるために、眠いのノードが低いしきい値と、その結果として、より小さな初期タイムアウト値を選択することを決定するかもしれません。この場合、実装は考慮に入れ、このセクションで説明するネットワークの安定性についての考慮事項を保持しなければなりません。"
    },
    {
      "indent": 0,
      "text": "12. Random Number Generation",
      "section_title": true,
      "ja": "12.乱数生成"
    },
    {
      "indent": 3,
      "text": "The TLS/DTLS protocol requires random numbers to be available during the protocol run. For example, during the ClientHello and the ServerHello exchange, the client and the server exchange random numbers. Also, the use of the DH exchange requires random numbers during the key pair generation.",
      "ja": "TLS / DTLSプロトコルは、プロトコルの実行中に利用できるように乱数を必要とします。例えば、のClientHelloとServerHelloメッセージ交換、クライアントとサーバーの交換の乱数中。また、DH交換を使用すると、鍵ペアの生成時に乱数が必要です。"
    },
    {
      "indent": 3,
      "text": "It is important to note that sources contributing to the randomness pool on laptops or desktop PCs are not available on many IoT devices, such as mouse movement, timing of keystrokes, air turbulence on the movement of hard drive heads, etc. Other sources have to be found or dedicated hardware has to be added.",
      "ja": "ラップトップやデスクトップPC上のランダムプールに貢献ソースがなど他のソースはに持って、マウスの動き、キーストロークのタイミング、ハードドライブのヘッドの動きに空気の乱れ、など多くのIoTデバイス上で利用可能ではないことに注意することが重要です見つからないか、専用のハードウェアを追加する必要があること。"
    },
    {
      "indent": 3,
      "text": "Lacking sources of randomness in an embedded system may lead to the same keys generated again and again.",
      "ja": "組み込みシステムにおいてランダム源を欠いている何度も発生した同じキーにつながる可能性があります。"
    },
    {
      "indent": 3,
      "text": "The ClientHello and the ServerHello messages contain the \"Random\" structure, which has two components: gmt_unix_time and a sequence of 28 random bytes. gmt_unix_time holds the current time and date in standard UNIX 32-bit format (seconds since the midnight starting Jan 1, 1970, GMT). Since many IoT devices do not have access to an accurate clock, it is RECOMMENDED that the receiver of a ClientHello or ServerHello does not assume that the value in \"Random.gmt_unix_time\" is an accurate representation of the current time and instead treats it as an opaque random string.",
      "ja": "gmt_unix_timeと28回のランダムなバイトのシーケンス：のClientHelloとのServerHelloメッセージは、2つのコンポーネントがあり、「ランダム」の構造を、含まれています。 gmt_unix_timeは（1970年1月1日、GMTを開始午前0時からの秒）の標準的なUNIX 32ビットフォーマットで現在の日付と時刻を保持しています。多くのIoTデバイスは、正確なクロックへのアクセスを持っていないので、のClientHelloやServerHelloメッセージの受信機は「Random.gmt_unix_time」の値は、現在の時間の正確な表現で、代わりとして、それを扱うことを前提としないことが推奨されます不透明なランダムな文字列。"
    },
    {
      "indent": 3,
      "text": "When TLS is used with certificate-based authentication, the availability of time information is needed to check the validity of a certificate. Higher-layer protocols may provide secure time information. The gmt_unix_time component of the ServerHello is not used for this purpose.",
      "ja": "TLSは、証明書ベースの認証を使用する場合は、時間情報の可用性は、証明書の有効性を確認するために必要とされています。上位層プロトコルは、セキュアな時刻情報を提供することができます。 ServerHelloのgmt_unix_timeコンポーネントは、この目的のために使用されていません。"
    },
    {
      "indent": 3,
      "text": "IoT devices using TLS/DTLS must offer ways to generate quality random numbers. There are various implementation choices for integrating a hardware-based random number generator into a product: an implementation inside the microcontroller itself is one option, but dedicated crypto chips are also reasonable choices. The best choice will depend on various factors outside the scope of this document. Guidelines and requirements for random number generation can be found in RFC 4086 [RFC4086] and in the NIST Special Publication 800-90a [SP800-90A].",
      "ja": "TLS / DTLSを使用してのIoTデバイスは、品質の乱数を生成する方法を提供しなければなりません。製品にハードウェアベースの乱数発生器を統合するためのさまざまな実装の選択肢がありますマイクロコントローラ自体の内部実装は一つの選択肢であるが、専用の暗号化チップも妥当な選択肢です。最良の選択は、この文書の範囲外の様々な要因に依存します。乱数生成のためのガイドラインと要件は、RFC 4086 [RFC4086]にしては、NIST Special Publication 800-90a [SP800-90A]で見つけることができます。"
    },
    {
      "indent": 3,
      "text": "Chip manufacturers are highly encouraged to provide sufficient documentation of their design for random number generators so that customers can have confidence about the quality of the generated random numbers. The confidence can be increased by providing information about the procedures that have been used to verify the randomness of numbers generated by the hardware modules. For example, NIST Special Publication 800-22b [SP800-22b] describes statistical tests that can be used to verify random number generators.",
      "ja": "チップのメーカーは非常に顧客が生成された乱数の品質について自信を持つことができるように、乱数生成のための設計の十分なドキュメントを提供することが奨励されています。自信がハードウェアモジュールによって生成された数字のランダム性を検証するために使用されている手順についての情報を提供することにより、増加させることができます。例えば、は、NIST Special Publication 800-22b [SP800-22b]は、乱数発生器を検証するために使用することができる統計的検定を記載しています。"
    },
    {
      "indent": 0,
      "text": "13. Truncated MAC and Encrypt-then-MAC Extension",
      "section_title": true,
      "ja": "13.切り捨てMACおよび暗号化-THEN-MAC拡張"
    },
    {
      "indent": 3,
      "text": "The truncated MAC extension was introduced in RFC 6066 [RFC6066] with the goal to reduce the size of the MAC used at the record layer. This extension was developed for TLS ciphersuites that used older modes of operation where the MAC and the encryption operation were performed independently.",
      "ja": "切り捨てられたMAC拡張は、記録層に使用されるMACのサイズを小さくするために目標とRFC 6066 [RFC6066]に導入しました。この拡張は、MACおよび暗号化操作を独立して実行された操作の古いモードを使用したTLS暗号スイートのために開発されました。"
    },
    {
      "indent": 3,
      "text": "The recommended ciphersuites in this document use the newer AEAD construct, namely the CCM mode with 8-octet authentication tags, and are therefore not applicable to the truncated MAC extension.",
      "ja": "このドキュメントの推奨暗号スイートは、8オクテットの認証タグと新しいAEAD構造物、すなわちCCMモードを使用するため、切り詰められたMAC拡張には適用されません。"
    },
    {
      "indent": 3,
      "text": "RFC 7366 [RFC7366] introduced the encrypt-then-MAC extension (instead of the previously used MAC-then-encrypt) since the MAC-then-encrypt mechanism has been the subject of a number of security vulnerabilities. RFC 7366 is, however, also not applicable to the AEAD ciphers recommended in this document.",
      "ja": "RFC 7366 [RFC7366]はMAC-次いで、暗号化機構は、セキュリティの脆弱性の数の対象となっているので（代わりに、以前に使用MAC-次いで、暗号化の）暗号-THEN-MACの拡張を導入しました。 RFC 7366はまた、しかし、この文書で推奨AEAD暗号には適用されません。"
    },
    {
      "indent": 3,
      "text": "Implementations conformant to this specification MUST use AEAD ciphers. RFC 7366 (\"encrypt-then-MAC\") and RFC 6066 (\"truncated MAC extension\") are not applicable to this specification and MUST NOT be used.",
      "ja": "この仕様に準拠する実装はAEAD暗号を使用しなければなりません。 RFC 7366（「次に-MAC暗号化」）およびRFC 6066（「切り捨てられたMAC拡張」）は本明細書には適用されず、使用してはいけません。"
    },
    {
      "indent": 0,
      "text": "14. Server Name Indication (SNI)",
      "section_title": true,
      "ja": "14.サーバー名の表示（SNI）"
    },
    {
      "indent": 3,
      "text": "The SNI extension [RFC6066] defines a mechanism for a client to tell a TLS/DTLS server the name of the server it wants to contact. This is a useful extension for many hosting environments where multiple virtual servers are run on a single IP address.",
      "ja": "SNI拡張[RFC6066]は、クライアントがTLS / DTLSサーバにそれを連絡したいサーバーの名前を教えられるようにするための機構を定義します。これは、複数の仮想サーバーが単一のIPアドレス上で実行されている多くのホスティング環境のための便利な拡張機能です。"
    },
    {
      "indent": 3,
      "text": "Implementing the Server Name Indication extension is REQUIRED unless it is known that a TLS/DTLS client does not interact with a server in a hosting environment.",
      "ja": "TLS / DTLSクライアントは、ホスティング環境でのサーバーと相互作用しないことが知られていない限りサーバ名の表示の拡張機能を実装する必要があります。"
    },
    {
      "indent": 0,
      "text": "15. Maximum Fragment Length Negotiation",
      "section_title": true,
      "ja": "15.最大フラグメント長交渉"
    },
    {
      "indent": 3,
      "text": "This RFC 6066 extension lowers the maximum fragment length support needed for the record layer from 2^14 bytes to 2^9 bytes.",
      "ja": "このRFC 6066拡張は、2 ^ 9バイトに2 ^ 14バイトから記録層に必要な最大の断片長支持を低下させます。"
    },
    {
      "indent": 3,
      "text": "This is a very useful extension that allows the client to indicate to the server how much maximum memory buffers it uses for incoming messages. Ultimately, the main benefit of this extension is to allow client implementations to lower their RAM requirements since the client does not need to accept packets of large size (such as 16K packets as required by plain TLS/DTLS).",
      "ja": "これは、クライアントが着信メッセージを使用していますどのくらいの最大メモリバッファサーバーに指示することを可能にする非常に便利な拡張機能です。最終的に、この拡張の主な利点は、クライアントが大きなサイズのパケット（プレーンTLS / DTLSによって要求されるような16Kパケット）を受け入れる必要がないので、クライアントの実装は、そのRAM要件を下げることができるようにすることです。"
    },
    {
      "indent": 3,
      "text": "Client implementations MUST support this extension.",
      "ja": "クライアントの実装は、この拡張機能をサポートしなければなりません。"
    },
    {
      "indent": 0,
      "text": "16. Session Hash",
      "section_title": true,
      "ja": "16.セッションハッシュ"
    },
    {
      "indent": 3,
      "text": "In order to begin connection protection, the Record Protocol requires specification of a suite of algorithms, a master secret, and the client and server random values. The algorithm for computing the master secret is defined in Section 8.1 of RFC 5246, but it only includes a small number of parameters exchanged during the handshake and does not include parameters like the client and server identities. This can be utilized by an attacker to mount a man-in-the-middle attack since the master secret is not guaranteed to be unique across sessions, as discovered in the \"triple handshake\" attack [Triple-HS].",
      "ja": "接続保護を開始するためには、レコードプロトコルは、アルゴリズムのスイート、マスターシークレット、およびクライアントとサーバーのランダムな値を指定する必要があります。マスターシークレットを計算するためのアルゴリズムは、RFC 5246のセクション8.1で定義されているが、それは唯一のハンドシェイク中に交換少数のパラメータが含まれており、クライアントとサーバのIDなどのパラメータが含まれていません。 「トリプルハンドシェイク」攻撃[トリプル-HS]で発見されたとして、マスターシークレットは、セッション間で一意であることが保証されていないので、これはman-in-the-middle攻撃をマウントするために、攻撃者が利用することができます。"
    },
    {
      "indent": 3,
      "text": "[RFC7627] defines a TLS extension that binds the master secret to a log of the full handshake that computes it, thus preventing such attacks.",
      "ja": "[RFC7627]は、したがって、そのような攻撃を防ぐ、それを計算し、完全なハンドシェイクのログにマスタシークレットを結合TLS拡張を定義します。"
    },
    {
      "indent": 3,
      "text": "Client implementations SHOULD implement this extension even though the ciphersuites recommended by this profile are not vulnerable to this attack. For DH-based ciphersuites, the keying material is contributed by both parties and in case of the pre-shared secret key ciphersuite, both parties need to be in possession of the shared secret to ensure that the handshake completes successfully. It is, however, possible that some application-layer protocols will tunnel other authentication protocols on top of DTLS making this attack relevant again.",
      "ja": "クライアントの実装は、このプロファイルが推奨する暗号スイートは、この攻撃に対して脆弱ではありませんにもかかわらず、この拡張機能を実装する必要があります。 DHベースの暗号群の場合は、鍵素材は、両当事者によって寄与され、事前共有秘密鍵暗号スイートの場合には、両当事者は、ハンドシェイクが正常に完了したことを確認するために、共有秘密を所持している必要があります。いくつかのアプリケーション層のプロトコルはDTLSの上にトンネル他の認証プロトコルは、再びこの攻撃が関連することになるということ、しかし、可能です。"
    },
    {
      "indent": 0,
      "text": "17. Renegotiation Attacks",
      "section_title": true,
      "ja": "17.再交渉攻撃"
    },
    {
      "indent": 3,
      "text": "TLS/DTLS allows a client and a server that already have a TLS/DTLS connection to negotiate new parameters, generate new keys, etc., by using the renegotiation feature. Renegotiation happens in the existing connection, with the new handshake packets being encrypted along with application data. Upon completion of the renegotiation procedure, the new channel replaces the old channel.",
      "ja": "TLS / DTLSは、クライアントとすでに再ネゴシエーション機能を使用して、新しいパラメータを交渉するなど、新たなキーを生成するためにTLS / DTLS接続を持ってサーバーを可能にします。新しいハンドシェイクパケットをアプリケーションデータと一緒に暗号化された状態で再ネゴシエーションは、既存の接続で行われます。再ネゴシエーション手順が完了すると、新しいチャンネルが古いチャネルを置き換えます。"
    },
    {
      "indent": 3,
      "text": "As described in RFC 5746 [RFC5746], there is no cryptographic binding between the two handshakes, although the new handshake is carried out using the cryptographic parameters established by the original handshake.",
      "ja": "RFC 5746 [RFC5746]に記載されているように新しいハンドシェイクが元のハンドシェークによって確立された暗号化パラメータを用いて行われるが、2つのハンドシェイクの間の結合ない暗号は、存在しません。"
    },
    {
      "indent": 3,
      "text": "To prevent the renegotiation attack [RFC5746], this specification REQUIRES the TLS renegotiation feature to be disabled. Clients MUST respond to server-initiated renegotiation attempts with an alert message (no_renegotiation), and clients MUST NOT initiate them.",
      "ja": "再交渉の攻撃[RFC5746]を防ぐために、この仕様は無効にするTLS再ネゴシエーション機能が必要です。クライアントは、警告メッセージ（no_renegotiation）でのサーバ起動再ネゴシエーションの試行に応答しなければならない、とクライアントがそれらを開始してはなりません。"
    },
    {
      "indent": 0,
      "text": "18. Downgrading Attacks",
      "section_title": true,
      "ja": "18.ダウングレード攻撃"
    },
    {
      "indent": 3,
      "text": "When a client sends a ClientHello with a version higher than the highest version known to the server, the server is supposed to reply with ServerHello.version equal to the highest version known to the server, and then the handshake can proceed. This behavior is known as version tolerance. Version intolerance is when the server (or a middlebox) breaks the handshake when it sees a ClientHello.version higher than what it knows about. This is the behavior that leads some clients to rerun the handshake with a lower version. As a result, a potential security vulnerability is introduced when a system is running an old TLS/SSL version (e.g., because of the need to integrate with legacy systems). In the worst case, this allows an attacker to downgrade the protocol handshake to SSL 3.0. SSL 3.0 is so broken that there is no secure cipher available for it (see [RFC7568]).",
      "ja": "クライアントがサーバに知られている最も高いバージョンよりも新しいバージョンでのClientHelloを送信すると、サーバーは、サーバーに知られている最も高いバージョンに等しいServerHello.versionで応答することになって、その後、握手を進めることができます。この動作は、バージョンの許容範囲として知られています。バージョン不耐症は、サーバ（またはミドルは）それはそれは知っているものよりも高いClientHello.versionを見て握手を壊したときです。これは、下位バージョンとのハンドシェイクを再実行するためにいくつかのクライアントをリード動作です。システムが（理由はレガシーシステムと統合する必要性など、）古いTLS / SSLのバージョンを実行しているときその結果、潜在的なセキュリティの脆弱性が導入されます。最悪の場合、これは、攻撃者がSSL 3.0にプロトコルのハンドシェイクをダウングレードすることができます。 SSL 3.0はそれのために利用可能なセキュアな暗号が存在しないことを壊れている（[RFC7568]を参照）。"
    },
    {
      "indent": 3,
      "text": "The above-described downgrade vulnerability is solved by the TLS Fallback Signaling Cipher Suite Value (SCSV) [RFC7507] extension. However, the solution is not applicable to implementations conforming to this profile since the version negotiation MUST use TLS/DTLS version 1.2 (or higher). More specifically, this implies:",
      "ja": "上記ダウングレード脆弱性は、TLSフォールバックシグナリング暗号スイート値（SCSV）[RFC7507]拡張によって解決されます。バージョンネゴシエーションがTLS / DTLSバージョン1.2（またはそれ以上）を使用しなければならないので、解決策は、このプロファイルに適合する実装には適用できません。具体的には、これは意味します："
    },
    {
      "indent": 3,
      "text": "o Clients MUST NOT send a TLS/DTLS version lower than version 1.2 in the ClientHello.",
      "ja": "OクライアントはのClientHelloで、バージョン1.2よりも低くTLS / DTLSバージョンを送ってはいけません。"
    },
    {
      "indent": 3,
      "text": "o Clients MUST NOT retry a failed negotiation offering a TLS/DTLS version lower than 1.2.",
      "ja": "Oクライアントは1.2よりも低いTLS / DTLSのバージョンを提供して失敗した交渉を再試行してはなりません。"
    },
    {
      "indent": 3,
      "text": "o Servers MUST fail the handshake by sending a protocol_version fatal alert if a TLS/DTLS version >= 1.2 cannot be negotiated. Note that the aborted connection is non-resumable.",
      "ja": "OサーバはTLS / DTLSバージョン> = 1.2がネゴシエートできない場合PROTOCOL_VERSION致命的なアラートを送信することにより、ハンドシェイクに失敗しなければなりません。中止された接続が非再開可能であることに注意してください。"
    },
    {
      "indent": 0,
      "text": "19. Crypto Agility",
      "section_title": true,
      "ja": "19.暗号アジリティ"
    },
    {
      "indent": 3,
      "text": "This document recommends that software and chip manufacturers implement AES and the CCM mode of operation. This document references the CoAP-recommended ciphersuite choices, which have been selected based on implementation and deployment experience from the IoT community. Over time, the preference for algorithms will, however, change. Not all components of a ciphersuite are likely to change at the same speed. Changes are more likely expected for ciphers, the mode of operation, and the hash algorithms. The recommended key lengths have to be adjusted over time as well. Some deployment environments will also be impacted by local regulation, which might dictate a certain algorithm and key size combination. Ongoing discussions regarding the choice of specific ECC curves will also likely impact implementations. Note that this document does not recommend or mandate a specific ECC curve.",
      "ja": "このドキュメントは、ソフトウェアやチップのメーカーは、AESや操作のCCMモードを実装することをお勧めします。この文書では、実装とのIoTコミュニティーからの展開の経験に基づいて選択されていますCoAP推奨暗号スイートの選択を参照します。時間が経つにつれて、アルゴリズムの好みは、しかし、変更されます。暗号スイートのすべてのコンポーネントは、同じ速度で変更される可能性がありません。変更は、より可能性の高い暗号、動作モード、およびハッシュアルゴリズムのために期待されています。推奨されるキーの長さは、同様に時間をかけて調整しなければなりません。いくつかのデプロイメント環境は、特定のアルゴリズムとキーサイズの組み合わせが決まるかもしれない地元の規制によって影響を受けます。特定のECC曲線の選択意志もありそうなインパクトの実装に関する継続的な議論。この文書は、特定のECC曲線を推奨したり強制しないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "The following recommendations can be made to chip manufacturers:",
      "ja": "以下の推奨事項は、チップ製造業者に行うことができます。"
    },
    {
      "indent": 3,
      "text": "o Make any AES hardware-based crypto implementation accessible to developers working on security implementations at higher layers in the protocol stack. Sometimes hardware implementations are added to microcontrollers to offer support for functionality needed at the link layer and are only available to the on-chip link-layer protocol implementation. Such a setup does not allow application developers to reuse the hardware-based AES implementation.",
      "ja": "Oプロトコルスタックの上位層でのセキュリティの実装に取り​​組んで開発者に任意のAESハードウェアベース暗号の実装にアクセスできるようにします。時にはハードウェア実装は、リンク層で必要な機能のサポートを提供するためにマイクロコントローラに加えて、オンチップのリンク層プロトコルの実装にのみ利用できます。このような設定は、アプリケーション開発者は、ハードウェアベースのAESの実装を再利用することはできません。"
    },
    {
      "indent": 3,
      "text": "o Provide flexibility for the use of the crypto function with future extensibility in mind. For example, making an AES-CCM implementation available to developers is a first step but such an implementation may not be usable due to parameter differences between an AES-CCM implementation. AES-CCM in IEEE 802.15.4 and Bluetooth Smart use a nonce length of 13 octets while DTLS uses a nonce length of 12 octets. Hardware implementations of AES-CCM for IEEE 802.15.4 and Bluetooth Smart are therefore not reusable by a DTLS stack.",
      "ja": "O念頭に置いて、将来の拡張性を持つ暗号機能を使用するための柔軟性を提供します。例えば、開発者にAES-CCM実装が利用可能にする最初のステップであるが、そのようなインプリメンテーションが原因AES-CCMの実装間のパラメータの差に使用できないかもしれません。 DTLSは、12オクテットの長さナンスを使用しながら、IEEE 802.15.4でAES-CCMおよびBluetoothスマート13オクテットの長さナンスを使用します。 IEEE 802.15.4およびBluetoothスマート用AES-CCMのハードウェア実装は、したがって、DTLSスタックによって再利用可能ではありません。"
    },
    {
      "indent": 3,
      "text": "o Offer access to building blocks in addition (or as an alternative) to the complete functionality. For example, a chip manufacturer who gives developers access to the AES crypto function can use it to build an efficient AES-GCM implementation. Another example is to make a special instruction available that increases the speed of speed-up carryless multiplications.",
      "ja": "O完全な機能に加えて、ビルディングブロックへのアクセス（または代替として）を提供します。例えば、開発者はAES暗号化機能へのアクセスを提供するチップのメーカーは、効率的なAES-GCMの実装を構築するためにそれを使用することができます。別の例は、スピードアップcarrylessの乗算の速度を増加させる特別な命令が利用できるようにすることです。"
    },
    {
      "indent": 3,
      "text": "As a recommendation for developers and product architects, we suggest that sufficient headroom is provided to allow an upgrade to a newer cryptographic algorithm over the lifetime of the product. As an example, while AES-CCM is recommended throughout this specification, future products might use the ChaCha20 cipher in combination with the Poly1305 authenticator [RFC7539]. The assumption is made that a robust software update mechanism is offered.",
      "ja": "開発者や製品設計者のための勧告として、我々は十分なヘッドルームは、製品の寿命にわたって新しい暗号アルゴリズムへのアップグレードを可能にするために設けられていることを示唆しています。 AES-CCMは、本明細書を通して推奨しながら、一例として、将来の製品はPoly1305認証[RFC7539]と組み合わせてChaCha20暗号を使用するかもしれません。仮定は、堅牢なソフトウェアの更新メカニズムが提供されていることをされています。"
    },
    {
      "indent": 0,
      "text": "20. Key Length Recommendations",
      "section_title": true,
      "ja": "20.キーの長さの推奨事項"
    },
    {
      "indent": 3,
      "text": "RFC 4492 [RFC4492] gives approximate comparable key sizes for symmetric- and asymmetric-key cryptosystems based on the best-known algorithms for attacking them. While other publications suggest slightly different numbers, such as [Keylength], the approximate relationship still holds true. Figure 12 illustrates the comparable key sizes in bits.",
      "ja": "RFC 4492 [RFC4492]は、それらを攻撃するための最もよく知られたアルゴリズムに基づいてsymmetric-と非対称鍵暗号のためのおおよその同等のキーサイズを与えます。他の出版物は、このような[キー長]のように、わずかに異なる番号を、示唆していますが、おおよその関係はまだ当てはまります。図12は、ビット単位で比較可能なキーサイズを示します。"
    },
    {
      "indent": 22,
      "text": " Symmetric  |   ECC   |  DH/DSA/RSA\n------------+---------+-------------\n     80     |   163   |     1024\n    112     |   233   |     2048\n    128     |   283   |     3072\n    192     |   409   |     7680\n    256     |   571   |    15360",
      "raw": true
    },
    {
      "indent": 8,
      "text": "Figure 12: Comparable Key Sizes (in Bits) Based on RFC 4492",
      "ja": "RFC 4492に基づいて、比較可能な鍵のサイズ（ビット単位）：図12"
    },
    {
      "indent": 3,
      "text": "At the time of writing, the key size recommendations for use with TLS-based ciphers found in [RFC7525] recommend DH key lengths of at least 2048 bits, which corresponds to a 112-bit symmetric key and a 233-bit ECC key. These recommendations are roughly in line with those from other organizations, such as the National Institute of Standards and Technology (NIST) or the European Network and Information Security Agency (ENISA). The authors of [ENISA-Report2013] add that a 80-bit symmetric key is sufficient for legacy applications for the coming years, but a 128-bit symmetric key is the minimum requirement for new systems being deployed. The authors further note that one needs to also take into account the length of time data needs to be kept secure for. The use of 80-bit symmetric keys for transactional data may be acceptable for the near future while one has to insist on 128-bit symmetric keys for long-lived data.",
      "ja": "書き込み時には、[RFC7525]に見出さTLSベース暗号で使用するための鍵サイズの推奨は、DH鍵112ビット対称キーに対応する少なくとも2048ビットの長さと、233ビットのECCキーをお勧めします。これらの提言は、おおよそ、このようなアメリカ国立標準技術研究所（NIST）や、欧州ネットワーク情報セキュリティ庁（ENISA）などの他の組織、からのものと一致しています。著者[ENISA-Report2013] 80ビットの対称鍵は、今後数年間のためのレガシーアプリケーションのために十分であることを追加しますが、128ビットの対称鍵が展開されている新しいシステムの最小要件です。著者はさらに、1つも考慮に入れたデータを用安全に保管する必要があり、時間の長さを取る必要があることに注意してください。一つは長寿命データの128ビット対称鍵を主張しなければならないしながら、取引データのための80ビットの対称鍵の使用は、近い将来のために許容可能であり得ます。"
    },
    {
      "indent": 3,
      "text": "Note that the recommendations for 112-bit symmetric keys are chosen conservatively under the assumption that IoT devices have a long expected lifetime (such as 10+ years) and that this key length recommendation refers to the long-term keys used for device authentication. Keys, which are provisioned dynamically, for the protection of transactional data (such as ephemeral DH keys used in various TLS/DTLS ciphersuites) may be shorter considering the sensitivity of the exchanged data.",
      "ja": "112ビットの対称鍵のおすすめはのIoTデバイスが長い期待寿命（例えば10年以上）を有する仮定の下で、このキーの長さの推薦は、デバイス認証に使用される長期キーを指すことを控えめに選択されることに留意されたいです。 （様々なTLS / DTLSの暗号スイートで使用されるエフェメラルDHキーなど）トランザクションデータの保護のため、動的にプロビジョニングされたキーは、交換されるデータの感度を考慮して短くてもよいです。"
    },
    {
      "indent": 0,
      "text": "21. False Start",
      "section_title": true,
      "ja": "21.不正スタート"
    },
    {
      "indent": 3,
      "text": "A full TLS handshake as specified in [RFC5246] requires two full protocol rounds (four flights) before the handshake is complete and the protocol parties may begin to send application data.",
      "ja": "ハンドシェイクが完了し、プロトコル当事者がアプリケーションデータを送信し始めることができる前に、[RFC5246]で指定されるように、完全なTLSハンドシェイクは、2つの完全なプロトコルラウンド（4便）を必要とします。"
    },
    {
      "indent": 3,
      "text": "An abbreviated handshake (resuming an earlier TLS session) is complete after three flights, thus adding just one round-trip time if the client sends application data first.",
      "ja": "（以前のTLSセッションを再開）簡略ハンドシェイクは、このように、クライアントが最初のアプリケーションデータを送信する場合だけで1往復時間を加算し、3便後に完了する。"
    },
    {
      "indent": 3,
      "text": "If the conditions outlined in [TLS-FALSESTART] are met, application data can be transmitted when the sender has sent its own \"ChangeCipherSpec\" and \"Finished\" messages. This achieves an improvement of one round-trip time for full handshakes if the client sends application data first and for abbreviated handshakes if the server sends application data first.",
      "ja": "[TLS-FALSESTART]に概説された条件が満たされている場合、送信者は、自身の「ChangeCipherSpecを」および「終了」メッセージを送信した場合、アプリケーションデータを送信することができます。サーバーは、最初のアプリケーションデータを送信する場合、クライアントは最初と略さ握手のためのアプリケーションデータを送信する場合、これは完全なハンドシェイクのために1往復時間の改善を実現しています。"
    },
    {
      "indent": 3,
      "text": "The conditions for using the TLS False Start mechanism are met by the public-key-based ciphersuites in this document. In summary, the conditions are:",
      "ja": "TLS不正スタートメカニズムを使用するための条件は、この文書の公開キーベースの暗号群によって満たされています。要約すると、条件は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "o Modern symmetric ciphers with an effective key length of 128 bits, such as AES-128-CCM",
      "ja": "そのようなAES-128-CCMのような128ビットの有効なキーの長さを持つ現代の対称暗号、O"
    },
    {
      "indent": 3,
      "text": "o Client certificate types, such as ecdsa_sign",
      "ja": "このようecdsa_signなどのクライアント証明書の種類、O"
    },
    {
      "indent": 3,
      "text": "o Key exchange methods, such as ECDHE_ECDSA",
      "ja": "このようECDHE_ECDSAなどの主要な交換方法は、O"
    },
    {
      "indent": 3,
      "text": "Based on the improvement over a full round-trip for the full TLS/DTLS exchange, this specification RECOMMENDS the use of the False Start mechanism when clients send application data first.",
      "ja": "フルTLS / DTLS交換のための完全な往復を超える改善に基づいて、この仕様は、クライアントが最初のアプリケーションデータを送信する不正スタートメカニズムの使用を推奨しています。"
    },
    {
      "indent": 0,
      "text": "22. Privacy Considerations",
      "section_title": true,
      "ja": "22.プライバシーに関する注意事項"
    },
    {
      "indent": 3,
      "text": "The DTLS handshake exchange conveys various identifiers, which can be observed by an on-path eavesdropper. For example, the DTLS PSK exchange reveals the PSK identity, the supported extensions, the session ID, algorithm parameters, etc. When session resumption is used, then individual TLS sessions can be correlated by an on-path adversary. With many IoT deployments, it is likely that keying material and their identifiers are persistent over a longer period of time due to the cost of updating software on these devices.",
      "ja": "DTLSハンドシェーク交換オンパス盗聴者によって観察することができる様々な識別子を搬送します。例えば、DTLS PSK交換はPSKの同一性を明らかにする、サポートされている拡張機能、セッションID、アルゴリズムパラメータなどのセッション再開を使用する場合、個々のTLSセッションは、オン経路敵によって相関させることができます。多くのIoTの展開と、材料をキーイングし、その識別子が原因これらのデバイス上のソフトウェアを更新するコストに時間の長い期間にわたって永続的であると思われます。"
    },
    {
      "indent": 3,
      "text": "User participation poses a challenge in many IoT deployments since many of the IoT devices operate unattended, even though they are initially provisioned by a human. The ability to control data sharing and to configure preferences will have to be provided at a system level rather than at the level of the DTLS exchange itself, which is the scope of this document. Quite naturally, the use of DTLS with mutual authentication will allow a TLS server to collect authentication information about the IoT device (likely over a long period of time). While this strong form of authentication will prevent misattribution, it also allows strong identification. Device-related data collection (e.g., sensor recordings) associated with other data types will prove to be truly useful, but this extra data might include personal information about the owner of the device or data about the environment it senses. Consequently, the data stored on the server side will be vulnerable to stored data compromise. For the communication between the client and the server, this specification prevents eavesdroppers from gaining access to the communication content. While the PSK-based ciphersuite does not provide PFS, the asymmetric versions do. This prevents an adversary from obtaining past communication content when access to a long-term secret has been gained. Note that no extra effort to make traffic analysis more difficult is provided by the recommendations made in this document.",
      "ja": "IoTデバイスの多くは無人で動作するので、ユーザーの参加は、彼らが最初に人間によってプロビジョニングされていても、多くのIoTの展開に挑戦を提起します。データ共有を制御し、プリファレンスを設定する機能は、システムレベルではなく、本文書の範囲であるDTLS交換自体のレベルで提供されなければなりません。当然のことながら、相互認証とDTLSを使用すると、TLSサーバは、（長期間にわたる可能性が高い）のIoTデバイスに関する認証情報を収集することができます。認証のこの強力なフォームは出所の混同を防ぐことができますが、それはまた、強力な同定を可能にします。他のデータ型に関連付けられているデバイスに関連するデータの収集（例えば、センサー録画）が真に有用であることが証明されますが、この余分なデータは、それが感知し、環境に関するデバイスやデータの所有者に関する個人情報が含まれる場合があります。これにより、サーバ側に格納されたデータが格納されたデータの妥協に対して脆弱であろう。クライアントとサーバ間の通信のために、この仕様は、通信コンテンツへのアクセスを獲得する盗聴を防止します。 PSKベースの暗号スイートは、PFSを提供していませんが、非対称のバージョンが行います。これは、長期的な秘密へのアクセスが得られているとき、過去の通信内容を取得するから敵を防ぐことができます。トラフィック解析をより困難にするために余分な努力が、この文書で勧告によって提供されていないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "Note that the absence or presence of communication itself might reveal information to an adversary. For example, a presence sensor may initiate messaging when a person enters a building. While TLS/ DTLS would offer confidentiality protection of the transmitted information, it does not help to conceal all communication patterns. Furthermore, the IP header, which is not protected by TLS/DTLS, additionally reveals information about the other communication endpoint. For applications where such privacy concerns exist, additional safeguards are required, such as injecting dummy traffic and onion routing. A detailed treatment of such solutions is outside the scope of this document and requires a system-level view.",
      "ja": "通信自体の有無が敵に情報を明らかにする可能性があることに留意されたいです。人は建物に入るとき例えば、プレゼンスセンサは、メッセージングを開始することができます。 TLS / DTLSが送信された情報の機密性保護を提供するだろうが、それはすべての通信パターンを隠すためには役立ちません。また、TLS / DTLSで保護されていないIPヘッダは、さらに他の通信エンドポイントに関する情報を明らかにする。そのようなプライバシーの問題が存在するアプリケーションでは、追加の保護手段は、ダミートラフィックとオニオンルーティングを注入すると、必要とされます。このようなソリューションの詳細な処理は、この文書の範囲外であるとシステム・レベルのビューを必要とします。"
    },
    {
      "indent": 0,
      "text": "23. Security Considerations",
      "section_title": true,
      "ja": "23.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "This entire document is about security.",
      "ja": "この全体のドキュメントはセキュリティに関するものです。"
    },
    {
      "indent": 3,
      "text": "We would also like to point out that designing a software update mechanism into an IoT system is crucial to ensure that both functionality can be enhanced and that potential vulnerabilities can be fixed. This software update mechanism is important for changing configuration information, for example, trust anchors and other keying-related information. Such a suitable software update mechanism is available with the LWM2M protocol published by the OMA [LWM2M].",
      "ja": "また、IoTをシステムにソフトウェアの更新メカニズムを設計することは、両方の機能が強化され、潜在的な脆弱性を修正することができることをできることを保証するために不可欠であることを指摘したいと思います。このソフトウェア更新メカニズムは、構成情報、例えば、トラストアンカーと他のキーに関連した情報変更のために重要です。このような適切なソフトウェア更新機構は、OMA [LWM2M]によって発行LWM2Mプロトコルで利用可能です。"
    },
    {
      "indent": 0,
      "text": "24. References",
      "section_title": true,
      "ja": "24.参考文献"
    },
    {
      "indent": 0,
      "text": "24.1. Normative References",
      "section_title": true,
      "ja": "24.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[EUI64] IEEE, \"Guidelines for 64-bit Global Identifier (EUI-64)\", Registration Authority, <https://standards.ieee.org/regauth/ oui/tutorials/EUI64.html>.",
      "ja": "[EUI64] IEEE、 \"64ビットのグローバル識別子（EUI64）のためのガイドライン\"、登録機関、<https://standards.ieee.org/regauth/ OUI /チュートリアル/ EUI64.html>。"
    },
    {
      "indent": 3,
      "text": "[GSM-SMS] ETSI, \"3rd Generation Partnership Project; Technical Specification Group Core Network and Terminals; Technical realization of the Short Message Service (SMS) (Release 13)\", 3GPP TS 23.040 V13.1.0, March 2016.",
      "ja": "[GSM-SMS] ETSI、 \"第3世代パートナーシッププロジェクト;技術仕様グループコアネットワークと端末、ショートメッセージサービス（SMS）（13）リリースの技術的実現\"、3GPP TS 23.040 V13.1.0、2016年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<http://www.rfc-editor.org/info/ RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC4279] Eronen, P., Ed. and H. Tschofenig, Ed., \"Pre-Shared Key Ciphersuites for Transport Layer Security (TLS)\", RFC 4279, DOI 10.17487/RFC4279, December 2005, <http://www.rfc-editor.org/info/rfc4279>.",
      "ja": "[RFC4279] Eronen、P.、エド。そして、H. Tschofenig、エド。、 \"事前共有鍵暗号の組み合わせトランスポート層セキュリティ（TLS）のために\"、RFC 4279、DOI 10.17487 / RFC4279、2005年12月、<http://www.rfc-editor.org/info/rfc4279 >。"
    },
    {
      "indent": 3,
      "text": "[RFC5246] Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS) Protocol Version 1.2\", RFC 5246, DOI 10.17487/RFC5246, August 2008, <http://www.rfc-editor.org/info/rfc5246>.",
      "ja": "[RFC5246]ダークス、T.およびE.レスコラ、 \"トランスポート層セキュリティ（TLS）プロトコルバージョン1.2\"、RFC 5246、DOI 10.17487 / RFC5246、2008年8月、<http://www.rfc-editor.org/info / RFC5246>。"
    },
    {
      "indent": 3,
      "text": "[RFC5746] Rescorla, E., Ray, M., Dispensa, S., and N. Oskov, \"Transport Layer Security (TLS) Renegotiation Indication Extension\", RFC 5746, DOI 10.17487/RFC5746, February 2010, <http://www.rfc-editor.org/info/rfc5746>.",
      "ja": "[RFC5746]レスコラ、E.、レイ、M.、Dispensa、S.、およびN. Oskov、 \"トランスポート層セキュリティ（TLS）再ネゴシエーション表示拡張\"、RFC 5746、DOI 10.17487 / RFC5746、2010年2月、<のhttp：/ /www.rfc-editor.org/info/rfc5746>。"
    },
    {
      "indent": 3,
      "text": "[RFC6066] Eastlake 3rd, D., \"Transport Layer Security (TLS) Extensions: Extension Definitions\", RFC 6066, DOI 10.17487/RFC6066, January 2011, <http://www.rfc-editor.org/info/rfc6066>.",
      "ja": "[RFC6066]イーストレイク3日、D.、 \"トランスポート層セキュリティ（TLS）拡張機能：拡張定義\"、RFC 6066、DOI 10.17487 / RFC6066、2011年1月、<http://www.rfc-editor.org/info/rfc6066> 。"
    },
    {
      "indent": 3,
      "text": "[RFC6125] Saint-Andre, P. and J. Hodges, \"Representation and Verification of Domain-Based Application Service Identity within Internet Public Key Infrastructure Using X.509 (PKIX) Certificates in the Context of Transport Layer Security (TLS)\", RFC 6125, DOI 10.17487/RFC6125, March 2011, <http://www.rfc-editor.org/info/rfc6125>.",
      "ja": "[RFC6125]サンアンドレ、P.およびJ.ホッジス、「表現およびTransport Layer Security（TLS）の文脈でインターネット公開鍵インフラストラクチャの使用X.509内のドメインベースのアプリケーションサービスのアイデンティティの検証（PKIX）証明書」、 RFC 6125、DOI 10.17487 / RFC6125、2011年3月、<http://www.rfc-editor.org/info/rfc6125>。"
    },
    {
      "indent": 3,
      "text": "[RFC6347] Rescorla, E. and N. Modadugu, \"Datagram Transport Layer Security Version 1.2\", RFC 6347, DOI 10.17487/RFC6347, January 2012, <http://www.rfc-editor.org/info/rfc6347>.",
      "ja": "[RFC6347]レスコラ、E.およびN. Modadugu、 \"データグラムトランスポート層セキュリティバージョン1.2\"、RFC 6347、DOI 10.17487 / RFC6347、2012年1月、<http://www.rfc-editor.org/info/rfc6347>。"
    },
    {
      "indent": 3,
      "text": "[RFC6520] Seggelmann, R., Tuexen, M., and M. Williams, \"Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS) Heartbeat Extension\", RFC 6520, DOI 10.17487/RFC6520, February 2012, <http://www.rfc-editor.org/info/rfc6520>.",
      "ja": "[RFC6520] Seggelmann、R.、Tuexen、M.、およびM.ウィリアムズ、 \"トランスポート層セキュリティ（TLS）およびデータグラムトランスポート層セキュリティ（DTLS）ハートビート拡張\"、RFC 6520、DOI 10.17487 / RFC6520、2012年2月、<HTTP ：//www.rfc-editor.org/info/rfc6520>。"
    },
    {
      "indent": 3,
      "text": "[RFC7250] Wouters, P., Ed., Tschofenig, H., Ed., Gilmore, J., Weiler, S., and T. Kivinen, \"Using Raw Public Keys in Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)\", RFC 7250, DOI 10.17487/RFC7250, June 2014, <http://www.rfc-editor.org/info/rfc7250>.",
      "ja": "[RFC7250] WOUTERS、P.、エド。、Tschofenig、H.、エド。、ギルモア、J.、ワイラー、S.、およびT. Kivinen、「生の公共トランスポート層セキュリティにおけるキー（TLS）を使用し、データグラムトランスポート層セキュリティ（DTLS）」、RFC 7250、DOI 10.17487 / RFC7250、2014年6月、<http://www.rfc-editor.org/info/rfc7250>。"
    },
    {
      "indent": 3,
      "text": "[RFC7251] McGrew, D., Bailey, D., Campagna, M., and R. Dugal, \"AES-CCM Elliptic Curve Cryptography (ECC) Cipher Suites for TLS\", RFC 7251, DOI 10.17487/RFC7251, June 2014, <http://www.rfc-editor.org/info/rfc7251>.",
      "ja": "[RFC7251]マグリュー、D.、ベイリー、D.、カンパーニャ、M.、およびR. Dugal、 \"TLSのためのAES-CCM楕円曲線暗号（ECC）暗号スイート\"、RFC 7251、DOI 10.17487 / RFC7251、2014年6月、 <http://www.rfc-editor.org/info/rfc7251>。"
    },
    {
      "indent": 3,
      "text": "[RFC7627] Bhargavan, K., Ed., Delignat-Lavaud, A., Pironti, A., Langley, A., and M. Ray, \"Transport Layer Security (TLS) Session Hash and Extended Master Secret Extension\", RFC 7627, DOI 10.17487/RFC7627, September 2015, <http://www.rfc-editor.org/info/rfc7627>.",
      "ja": "[RFC7627] Bhargavan、K.、エド。、Delignat-Lavaud、A.、Pironti、A.、ラングレー、A.、およびM.レイ、 \"トランスポート層セキュリティ（TLS）セッションハッシュおよび拡張マスターシークレット拡張\"、RFC 7627、DOI 10.17487 / RFC7627、2015年9月、<http://www.rfc-editor.org/info/rfc7627>。"
    },
    {
      "indent": 3,
      "text": "[RFC7924] Santesson, S. and H. Tschofenig, \"Transport Layer Security (TLS) Cached Information Extension\", RFC 7924, DOI 10.17487/RFC7924, July 2016, <http://www.rfc-editor.org/info/rfc7924>.",
      "ja": "[RFC7924] Santesson、S.およびH. Tschofenig、 \"トランスポート層セキュリティ（TLS）キャッシュされた情報拡張\"、RFC 7924、DOI 10.17487 / RFC7924、2016年7月、<http://www.rfc-editor.org/info/ rfc7924>。"
    },
    {
      "indent": 3,
      "text": "[WAP-WDP] Open Mobile Alliance, \"Wireless Datagram Protocol\", Wireless Application Protocol, WAP-259-WDP, June 2001.",
      "ja": "[WAP-WDP]オープン・モバイル・アライアンス、 \"ワイヤレスデータグラムプロトコル\"、ワイヤレスアプリケーションプロトコル、WAP-259-WDP、2001年6月。"
    },
    {
      "indent": 0,
      "text": "24.2. Informative References",
      "section_title": true,
      "ja": "24.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[ACE-WG] IETF, \"Authentication and Authorization for Constrained Environments (ACE) Working Group\", <https://datatracker.ietf.org/wg/ace/charter>.",
      "ja": "<https://datatracker.ietf.org/wg/ace/charter> [ACE-WG] IETF、 \"制約のある環境（ACE）ワーキンググループのための認証と承認\"。"
    },
    {
      "indent": 3,
      "text": "[AES] National Institute of Standards and Technology, \"Advanced Encryption Standard (AES)\", NIST FIPS PUB 197, November 2001, <http://csrc.nist.gov/publications/fips/fips197/ fips-197.pdf>.",
      "ja": "[AES]米国国立標準技術研究所、 \"高度暗号化標準（AES）\"、NIST FIPS PUBの197、2001年11月、<http://csrc.nist.gov/publications/fips/fips197/ FIPS-197.pdf> 。"
    },
    {
      "indent": 3,
      "text": "[CCM] National Institute of Standards and Technology, \"Recommendation for Block Cipher Modes of Operation: The CCM Mode for Authentication and Confidentiality\", NIST Special Publication 800-38C, May 2004, <http://csrc.nist.gov/publications/nistpubs/800-38C/ SP800-38C_updated-July20_2007.pdf>.",
      "ja": "[CCM]米国国立標準技術研究所、「オペレーションのブロック暗号モードのための推薦：認証と機密保持のためのCCMモード」、NIST特別出版800-38C、2004年5月、<http://csrc.nist.gov/publications / nistpubs / 800-38C / SP800-38C_updated-July20_2007.pdf>。"
    },
    {
      "indent": 3,
      "text": "[COAP-TCP-TLS] Bormann, C., Lemay, S., Tschofenig, H., Hartke, K., Silverajan, B., and B. Raymor, \"CoAP (Constrained Application Protocol) over TCP, TLS, and WebSockets\", Work in Progress, draft-ietf-core-coap-tcp-tls-03, July 2016.",
      "ja": "[COAP-TCP-TLS]ボルマン、C.、ルメイ、S.、Tschofenig、H.、HARTKE、K.、Silverajan、B.、およびTCP、TLS上B. Raymor、「CoAP（制約アプリケーションプロトコル）、及びWebSocketを」進行中で働いて、ドラフト-IETF-コアcoap-TCP-TLS-03、2016年7月。"
    },
    {
      "indent": 3,
      "text": "[CoRE-RD] Shelby, Z., Koster, M., Bormann, C., and P. Stok, \"CoRE Resource Directory\", Work in Progress, draft-ietf-core-resource-directory-08, July 2016.",
      "ja": "[CORE-RD]シェルビー、Z.、コスター、M.、ボルマン、C.、およびP. STOK、 \"コアリソースディレクトリ\" が進行中で働いて、ドラフト-IETF-コア・リソース・ディレクトリ-08、2016年7月。"
    },
    {
      "indent": 3,
      "text": "[CRIME] Wikipedia, \"CRIME\", May 2016, <https://en.wikipedia.org/w/ index.php?title=CRIME&oldid=721665716>.",
      "ja": "[犯罪]ウィキペディア、 \"CRIME\"、2016年5月、<https://en.wikipedia.org/w/のindex.php？タイトル=犯罪＆oldid = 721665716>。"
    },
    {
      "indent": 3,
      "text": "[ENISA-Report2013] ENISA, \"Algorithms, Key Sizes and Parameters Report - 2013\", October 2013, <https://www.enisa.europa.eu/ activities/identity-and-trust/library/deliverables/ algorithms-key-sizes-and-parameters-report>.",
      "ja": "[ENISA-Report2013] ENISA、 \"アルゴリズム、キーのサイズとパラメータReport2013\"、2013年10月、<https://www.enisa.europa.eu/活動/アイデンティティ・アンド・トラスト/ライブラリ/成果/アルゴリズムキー> -sizes-およびパラメータ - レポート。"
    },
    {
      "indent": 3,
      "text": "[FFDHE-TLS] Gillmor, D., \"Negotiated Finite Field Diffie-Hellman Ephemeral Parameters for TLS\", Work in Progress, draft-ietf-tls-negotiated-ff-dhe-10, June 2015.",
      "ja": "[FFDHE-TLS] Gillmor氏、D.、 \"TLSのための有限フィールドのDiffie-Hellmanのエフェメラルパラメータを交渉\" が進行中で働いて、ドラフト-IETF-TLSは交渉-FF-DHE-10、2015年6月。"
    },
    {
      "indent": 3,
      "text": "[HomeGateway] Eggert, L., Hatoen, S., Kojo, M., Nyrhinen, A., Sarolahti, P., and S. Strowes, \"An Experimental Study of Home Gateway Characteristics\", In Proceedings of the 10th ACM SIGCOMM conference on Internet measurement, DOI 10.1145/1879141.1879174, 2010, <http://conferences.sigcomm.org/imc/2010/papers/p260.pdf>.",
      "ja": "【HomeGateway]エッゲルト、L.、Hatoen、S.、古城、M.、Nyrhinen、A.、Sarolahti、P.、およびS. Strowes、第10回ACM SIGCOMMの議事録では、 \"ホームゲートウェイ特性の実験的研究\"、インターネット測定に関する会議、DOI 10.1145 / 1879141.1879174、2010年、<http://conferences.sigcomm.org/imc/2010/papers/p260.pdf>。"
    },
    {
      "indent": 3,
      "text": "[IANA-TLS] IANA, \"Transport Layer Security (TLS) Parameters\", <https://www.iana.org/assignments/tls-parameters>.",
      "ja": "[IANA-TLS] IANA、 \"トランスポート層セキュリティ（TLS）パラメータ\"、<https://www.iana.org/assignments/tls-parameters>。"
    },
    {
      "indent": 3,
      "text": "[ImprintingSurvey] Chilton, E., \"A Brief Survey of Imprinting Options for Constrained Devices\", March 2012, <http://www.lix.polytechnique.fr/hipercom/ SmartObjectSecurity/papers/EricRescorla.pdf>.",
      "ja": "[ImprintingSurvey]チルトン、E.、 \"制限があるデバイスのためのインプリンティングオプションの簡単な調査\"、2012年3月、<http://www.lix.polytechnique.fr/hipercom/ SmartObjectSecurity /論文/ EricRescorla.pdf>。"
    },
    {
      "indent": 3,
      "text": "[Keylength] Giry, D., \"Cryptographic Key Length Recommendations\", September 2015, <http://www.keylength.com>.",
      "ja": "[KEYLENGTH] Giry、D.、 \"暗号化キーの長さの推奨事項\"、2015年9月、<http://www.keylength.com>。"
    },
    {
      "indent": 3,
      "text": "[LWM2M] Open Mobile Alliance, \"Lightweight Machine-to-Machine Requirements\", Candidate Version 1.0, OMA-RD-LightweightM2M-V1_0-20131210-C, December 2013, <http://openmobilealliance.org/about-oma/work-program/ m2m-enablers>.",
      "ja": "[LWM2M]オープン・モバイル・アライアンス、 \"軽量マシン・ツー・マシンの要件\"、候補バージョン1.0、OMA-RD-LightweightM2M-V1_0-20131210-C、2013年12月、<http://openmobilealliance.org/about-oma/work -program / M2M・イネーブラー>。"
    },
    {
      "indent": 3,
      "text": "[PSK-AES-CCM-TLS] Schmertmann, L. and C. Bormann, \"ECDHE-PSK AES-CCM Cipher Suites with Forward Secrecy for Transport Layer Security (TLS)\", Work in Progress, draft-schmertmann-dice-ccm-psk-pfs-01, August 2014.",
      "ja": "[PSK-AES-CCM-TLS] Schmertmann、L.およびC.ボルマン、 \"転送秘密とECDHE-PSK AES-CCM暗号スイートトランスポート層セキュリティ（TLS）のために\" が進行中で働いて、ドラフトschmertmann-サイコロ-CCM -PSK-PFS-01、2014年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC1981] McCann, J., Deering, S., and J. Mogul, \"Path MTU Discovery for IP version 6\", RFC 1981, DOI 10.17487/RFC1981, August 1996, <http://www.rfc-editor.org/info/rfc1981>.",
      "ja": "[RFC1981]マッキャン、J.、デアリング、S.、およびJ.ムガール人、RFC 1981 \"IPバージョン6のパスMTUディスカバリー\"、DOI 10.17487 / RFC1981、1996年8月、<のhttp：//www.rfc-editor。組織/情報/ rfc1981>。"
    },
    {
      "indent": 3,
      "text": "[RFC2104] Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, DOI 10.17487/RFC2104, February 1997, <http://www.rfc-editor.org/info/rfc2104>.",
      "ja": "[RFC2104] Krawczyk、H.、ベラー、M.、およびR.カネッティ、 \"HMAC：メッセージ認証のための鍵付きハッシュ化\"、RFC 2104、DOI 10.17487 / RFC2104、1997年2月、<HTTP：//www.rfc-editor .ORG /情報/ RFC2104>。"
    },
    {
      "indent": 3,
      "text": "[RFC2865] Rigney, C., Willens, S., Rubens, A., and W. Simpson, \"Remote Authentication Dial In User Service (RADIUS)\", RFC 2865, DOI 10.17487/RFC2865, June 2000, <http://www.rfc-editor.org/info/rfc2865>.",
      "ja": "[RFC2865] Rigney、C.、ウィレンス、S.、ルーベン、A.、およびW.シンプソン、RFC 2865 \"ユーザーサービス（RADIUS）でリモート認証ダイヤル\"、DOI 10.17487 / RFC2865、2000年6月、<のhttp：/ /www.rfc-editor.org/info/rfc2865>。"
    },
    {
      "indent": 3,
      "text": "[RFC3610] Whiting, D., Housley, R., and N. Ferguson, \"Counter with CBC-MAC (CCM)\", RFC 3610, DOI 10.17487/RFC3610, September 2003, <http://www.rfc-editor.org/info/rfc3610>.",
      "ja": "[RFC3610]ホワイティング、D.、Housley氏、R.、およびN.ファーガソン、 \"CBC-MAC（CCM）とカウンター\"、RFC 3610、DOI 10.17487 / RFC3610、2003年9月、<のhttp：//www.rfc-editor .ORG /情報/ rfc3610>。"
    },
    {
      "indent": 3,
      "text": "[RFC3748] Aboba, B., Blunk, L., Vollbrecht, J., Carlson, J., and H. Levkowetz, Ed., \"Extensible Authentication Protocol (EAP)\", RFC 3748, DOI 10.17487/RFC3748, June 2004, <http://www.rfc-editor.org/info/rfc3748>.",
      "ja": "[RFC3748] Aboba、B.、ブルンク、L.、Vollbrecht、J.、カールソン、J.、およびH. Levkowetz、編、 \"拡張認証プロトコル（EAP）\"、RFC 3748、DOI 10.17487 / RFC3748、2004年6月、<http://www.rfc-editor.org/info/rfc3748>。"
    },
    {
      "indent": 3,
      "text": "[RFC4086] Eastlake 3rd, D., Schiller, J., and S. Crocker, \"Randomness Requirements for Security\", BCP 106, RFC 4086, DOI 10.17487/RFC4086, June 2005, <http://www.rfc-editor.org/info/rfc4086>.",
      "ja": "[RFC4086]イーストレーク3日、D.、シラー、J.、およびS.クロッカー、 \"セキュリティのためにランダム要件\"、BCP 106、RFC 4086、DOI 10.17487 / RFC4086、2005年6月、<HTTP：//www.rfc-editor .ORG /情報/ RFC4086>。"
    },
    {
      "indent": 3,
      "text": "[RFC4492] Blake-Wilson, S., Bolyard, N., Gupta, V., Hawk, C., and B. Moeller, \"Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS)\", RFC 4492, DOI 10.17487/RFC4492, May 2006, <http://www.rfc-editor.org/info/rfc4492>.",
      "ja": "[RFC4492]ブレイク・ウィルソン、S.、Bolyard、N.、グプタ、V.、ホーク、C.、​​およびB.メラー、 \"楕円曲線暗号（ECC）暗号スイートトランスポート層セキュリティ（TLS）のための\"、RFC 4492 、DOI 10.17487 / RFC4492、2006年5月、<http://www.rfc-editor.org/info/rfc4492>。"
    },
    {
      "indent": 3,
      "text": "[RFC4821] Mathis, M. and J. Heffner, \"Packetization Layer Path MTU Discovery\", RFC 4821, DOI 10.17487/RFC4821, March 2007, <http://www.rfc-editor.org/info/rfc4821>.",
      "ja": "[RFC4821]マシス、M.とJ. Heffner、 \"パケット化レイヤのパスMTUディスカバリ\"、RFC 4821、DOI 10.17487 / RFC4821、2007年3月、<http://www.rfc-editor.org/info/rfc4821>。"
    },
    {
      "indent": 3,
      "text": "[RFC4919] Kushalnagar, N., Montenegro, G., and C. Schumacher, \"IPv6 over Low-Power Wireless Personal Area Networks (6LoWPANs): Overview, Assumptions, Problem Statement, and Goals\", RFC 4919, DOI 10.17487/RFC4919, August 2007, <http://www.rfc-editor.org/info/rfc4919>.",
      "ja": "[RFC4919]クシャルナガル、N.、モンテネグロ、G.、およびC.シューマッハ、 \"低消費電力無線パーソナルエリアネットワーク上のIPv6（6LoWPANs）：概要、仮定、問題文、および目標\"、RFC 4919、DOI 10.17487 / RFC4919 2007年8月、<http://www.rfc-editor.org/info/rfc4919>。"
    },
    {
      "indent": 3,
      "text": "[RFC5077] Salowey, J., Zhou, H., Eronen, P., and H. Tschofenig, \"Transport Layer Security (TLS) Session Resumption without Server-Side State\", RFC 5077, DOI 10.17487/RFC5077, January 2008, <http://www.rfc-editor.org/info/rfc5077>.",
      "ja": "[RFC5077] Salowey、J.、周、H.、Eronen、P.、およびH. Tschofenig、 \"トランスポート層セキュリティ（TLS）セッション再開サーバ側の状態なし\"、RFC 5077、DOI 10.17487 / RFC5077、2008年1月、 <http://www.rfc-editor.org/info/rfc5077>。"
    },
    {
      "indent": 3,
      "text": "[RFC5116] McGrew, D., \"An Interface and Algorithms for Authenticated Encryption\", RFC 5116, DOI 10.17487/RFC5116, January 2008, <http://www.rfc-editor.org/info/rfc5116>.",
      "ja": "[RFC5116]マグリュー、D.、 \"認証暗号化のためのインタフェースとアルゴリズム\"、RFC 5116、DOI 10.17487 / RFC5116、2008年1月、<http://www.rfc-editor.org/info/rfc5116>。"
    },
    {
      "indent": 3,
      "text": "[RFC5216] Simon, D., Aboba, B., and R. Hurst, \"The EAP-TLS Authentication Protocol\", RFC 5216, DOI 10.17487/RFC5216, March 2008, <http://www.rfc-editor.org/info/rfc5216>.",
      "ja": "[RFC5216]サイモン、D.、Aboba、B.、およびR.ハースト、 \"EAP-TLS認証プロトコル\"、RFC 5216、DOI 10.17487 / RFC5216、2008年3月<http://www.rfc-editor.org /情報/ rfc5216>。"
    },
    {
      "indent": 3,
      "text": "[RFC5247] Aboba, B., Simon, D., and P. Eronen, \"Extensible Authentication Protocol (EAP) Key Management Framework\", RFC 5247, DOI 10.17487/RFC5247, August 2008, <http://www.rfc-editor.org/info/rfc5247>.",
      "ja": "[RFC5247] Aboba、B.、サイモン、D.、およびP. Eronen、 \"拡張認証プロトコル（EAP）鍵管理フレームワーク\"、RFC 5247、DOI 10.17487 / RFC5247、2008年8月、<のhttp：//www.rfc- editor.org/info/rfc5247>。"
    },
    {
      "indent": 3,
      "text": "[RFC5280] Cooper, D., Santesson, S., Farrell, S., Boeyen, S., Housley, R., and W. Polk, \"Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile\", RFC 5280, DOI 10.17487/RFC5280, May 2008, <http://www.rfc-editor.org/info/rfc5280>.",
      "ja": "[RFC5280]クーパー、D.、Santesson、S.、ファレル、S.、Boeyen、S.、Housley氏、R.、およびW.ポーク、「インターネットX.509公開鍵暗号基盤証明書と証明書失効リスト（CRL）のプロフィール」、RFC 5280、DOI 10.17487 / RFC5280、2008年5月、<http://www.rfc-editor.org/info/rfc5280>。"
    },
    {
      "indent": 3,
      "text": "[RFC5288] Salowey, J., Choudhury, A., and D. McGrew, \"AES Galois Counter Mode (GCM) Cipher Suites for TLS\", RFC 5288, DOI 10.17487/RFC5288, August 2008, <http://www.rfc-editor.org/info/rfc5288>.",
      "ja": "[RFC5288] Salowey、J.、チョードリー、A.、およびD.マグリュー、 \"AESガロアカウンタモード（GCM）TLSの暗号スイート\"、RFC 5288、DOI 10.17487 / RFC5288、2008年8月、<のhttp：// WWW。 rfc-editor.org/info/rfc5288>。"
    },
    {
      "indent": 3,
      "text": "[RFC5480] Turner, S., Brown, D., Yiu, K., Housley, R., and T. Polk, \"Elliptic Curve Cryptography Subject Public Key Information\", RFC 5480, DOI 10.17487/RFC5480, March 2009, <http://www.rfc-editor.org/info/rfc5480>.",
      "ja": "[RFC5480]ターナー、S.、ブラ​​ウン、D.、耀輝、K.、Housley氏、R.、およびT.ポーク、 \"楕円曲線暗号件名公開鍵情報\"、RFC 5480、DOI 10.17487 / RFC5480、2009年3月、< http://www.rfc-editor.org/info/rfc5480>。"
    },
    {
      "indent": 3,
      "text": "[RFC5758] Dang, Q., Santesson, S., Moriarty, K., Brown, D., and T. Polk, \"Internet X.509 Public Key Infrastructure: Additional Algorithms and Identifiers for DSA and ECDSA\", RFC 5758, DOI 10.17487/RFC5758, January 2010, <http://www.rfc-editor.org/info/rfc5758>.",
      "ja": "[RFC5758]ダン、Q.、Santesson、S.、モリアーティ、K.、ブラウン、D.、およびT.ポーク、 \"インターネットX.509公開鍵インフラストラクチャ：DSAとECDSAのための追加のアルゴリズムと識別子\"、RFC 5758、 DOI 10.17487 / RFC5758、2010年1月、<http://www.rfc-editor.org/info/rfc5758>。"
    },
    {
      "indent": 3,
      "text": "[RFC5934] Housley, R., Ashmore, S., and C. Wallace, \"Trust Anchor Management Protocol (TAMP)\", RFC 5934, DOI 10.17487/RFC5934, August 2010, <http://www.rfc-editor.org/info/rfc5934>.",
      "ja": "[RFC5934] Housley氏、R.、アシュモア、S.、およびC.ウォレス、 \"トラストアンカー管理プロトコル（TAMP）\"、RFC 5934、DOI 10.17487 / RFC5934、2010年8月、<のhttp：//www.rfc-editor。組織/情報/ rfc5934>。"
    },
    {
      "indent": 3,
      "text": "[RFC6024] Reddy, R. and C. Wallace, \"Trust Anchor Management Requirements\", RFC 6024, DOI 10.17487/RFC6024, October 2010, <http://www.rfc-editor.org/info/rfc6024>.",
      "ja": "[RFC6024]レディ、R.とC.ウォレス、 \"トラストアンカーの管理の要件\"、RFC 6024、DOI 10.17487 / RFC6024、2010年10月、<http://www.rfc-editor.org/info/rfc6024>。"
    },
    {
      "indent": 3,
      "text": "[RFC6090] McGrew, D., Igoe, K., and M. Salter, \"Fundamental Elliptic Curve Cryptography Algorithms\", RFC 6090, DOI 10.17487/RFC6090, February 2011, <http://www.rfc-editor.org/info/rfc6090>.",
      "ja": "[RFC6090]マグリュー、D.、Igoe、K.、およびM.ソルター、 \"基礎楕円曲線暗号アルゴリズム\"、RFC 6090、DOI 10.17487 / RFC6090、2011年2月、<http://www.rfc-editor.org/情報/ rfc6090>。"
    },
    {
      "indent": 3,
      "text": "[RFC6234] Eastlake 3rd, D. and T. Hansen, \"US Secure Hash Algorithms (SHA and SHA-based HMAC and HKDF)\", RFC 6234, DOI 10.17487/RFC6234, May 2011, <http://www.rfc-editor.org/info/rfc6234>.",
      "ja": "[RFC6234]イーストレイク3日、D.とT.ハンセン、 \"米国のセキュアハッシュアルゴリズム（SHAとHMACとHKDF SHAベース）\"、RFC 6234、DOI 10.17487 / RFC6234、2011年5月、<のhttp：//www.rfc- editor.org/info/rfc6234>。"
    },
    {
      "indent": 3,
      "text": "[RFC6655] McGrew, D. and D. Bailey, \"AES-CCM Cipher Suites for Transport Layer Security (TLS)\", RFC 6655, DOI 10.17487/RFC6655, July 2012, <http://www.rfc-editor.org/info/rfc6655>.",
      "ja": "[RFC6655]マグリュー、D.とD.ベイリー、 \"AES-CCM暗号スイートトランスポート層セキュリティ（TLS）のために\"、RFC 6655、DOI 10.17487 / RFC6655、2012年7月、<http://www.rfc-editor.org /情報/ rfc6655>。"
    },
    {
      "indent": 3,
      "text": "[RFC6690] Shelby, Z., \"Constrained RESTful Environments (CoRE) Link Format\", RFC 6690, DOI 10.17487/RFC6690, August 2012, <http://www.rfc-editor.org/info/rfc6690>.",
      "ja": "[RFC6690]シェルビー、Z.、 \"制約RESTfulな環境（コア）リンク・フォーマット\"、RFC 6690、DOI 10.17487 / RFC6690、2012年8月、<http://www.rfc-editor.org/info/rfc6690>。"
    },
    {
      "indent": 3,
      "text": "[RFC6733] Fajardo, V., Ed., Arkko, J., Loughney, J., and G. Zorn, Ed., \"Diameter Base Protocol\", RFC 6733, DOI 10.17487/RFC6733, October 2012, <http://www.rfc-editor.org/info/rfc6733>.",
      "ja": "[RFC6733]ファハルド、V.、エド、Arkko、J.、Loughney、J.、およびG.ゾルン、編、 \"直径ベースプロトコル\"、RFC 6733、DOI 10.17487 / RFC6733、2012年10月、<HTTP：/ /www.rfc-editor.org/info/rfc6733>。"
    },
    {
      "indent": 3,
      "text": "[RFC6943] Thaler, D., Ed., \"Issues in Identifier Comparison for Security Purposes\", RFC 6943, DOI 10.17487/RFC6943, May 2013, <http://www.rfc-editor.org/info/rfc6943>.",
      "ja": "[RFC6943]ターラー、D.編、 \"セキュリティ目的のための識別子の比較では問題\"、RFC 6943、DOI 10.17487 / RFC6943、2013年5月、<http://www.rfc-editor.org/info/rfc6943>。"
    },
    {
      "indent": 3,
      "text": "[RFC6961] Pettersen, Y., \"The Transport Layer Security (TLS) Multiple Certificate Status Request Extension\", RFC 6961, DOI 10.17487/RFC6961, June 2013, <http://www.rfc-editor.org/info/rfc6961>.",
      "ja": "[RFC6961]ペター、Y.、 \"トランスポート層セキュリティ（TLS）複数の証明書ステータス要求拡張\"、RFC 6961、DOI 10.17487 / RFC6961、2013年6月、<http://www.rfc-editor.org/info/rfc6961 >。"
    },
    {
      "indent": 3,
      "text": "[RFC7228] Bormann, C., Ersue, M., and A. Keranen, \"Terminology for Constrained-Node Networks\", RFC 7228, DOI 10.17487/RFC7228, May 2014, <http://www.rfc-editor.org/info/rfc7228>.",
      "ja": "[RFC7228]ボルマン、C.、Ersue、M.、およびA. Keranen、 \"制約ノードのネットワークのための用語\"、RFC 7228、DOI 10.17487 / RFC7228、2014年5月、<http://www.rfc-editor.org /情報/ rfc7228>。"
    },
    {
      "indent": 3,
      "text": "[RFC7252] Shelby, Z., Hartke, K., and C. Bormann, \"The Constrained Application Protocol (CoAP)\", RFC 7252, DOI 10.17487/RFC7252, June 2014, <http://www.rfc-editor.org/info/rfc7252>.",
      "ja": "[RFC7252]シェルビー、Z.、HARTKE、K.、およびC.ボルマン、 \"制約アプリケーションプロトコル（CoAP）\"、RFC 7252、DOI 10.17487 / RFC7252、2014年6月、<HTTP：//www.rfc-editor。組織/情報/ rfc7252>。"
    },
    {
      "indent": 3,
      "text": "[RFC7258] Farrell, S. and H. Tschofenig, \"Pervasive Monitoring Is an Attack\", BCP 188, RFC 7258, DOI 10.17487/RFC7258, May 2014, <http://www.rfc-editor.org/info/rfc7258>.",
      "ja": "[RFC7258]ファレル、S.およびH. Tschofenig、BCP 188 \"パーベイシブモニタリングが攻撃である\"、RFC 7258、DOI 10.17487 / RFC7258、2014年5月、<http://www.rfc-editor.org/info/rfc7258 >。"
    },
    {
      "indent": 3,
      "text": "[RFC7366] Gutmann, P., \"Encrypt-then-MAC for Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)\", RFC 7366, DOI 10.17487/RFC7366, September 2014, <http://www.rfc-editor.org/info/rfc7366>.",
      "ja": "[RFC7366] Gutmann氏、P.、 \"トランスポート層セキュリティ（TLS）およびデータグラムトランスポート層セキュリティ（DTLS）のために、そして-MACを暗号化\"、RFC 7366、DOI 10.17487 / RFC7366、2014年9月、<のhttp：//www.rfc -editor.org/info/rfc7366>。"
    },
    {
      "indent": 3,
      "text": "[RFC7390] Rahman, A., Ed. and E. Dijk, Ed., \"Group Communication for the Constrained Application Protocol (CoAP)\", RFC 7390, DOI 10.17487/RFC7390, October 2014, <http://www.rfc-editor.org/info/rfc7390>.",
      "ja": "[RFC7390]ラーマン、A.編。そしてE.ダイク、エド。、 \"制約アプリケーションプロトコル（CoAP）のためのグループ通信\"、RFC 7390、DOI 10.17487 / RFC7390、2014年10月、<http://www.rfc-editor.org/info/rfc7390>。"
    },
    {
      "indent": 3,
      "text": "[RFC7397] Gilger, J. and H. Tschofenig, \"Report from the Smart Object Security Workshop\", RFC 7397, DOI 10.17487/RFC7397, December 2014, <http://www.rfc-editor.org/info/rfc7397>.",
      "ja": "[RFC7397] Gilger、J.とH. Tschofenig、 \"スマートオブジェクトのセキュリティワークショップからの報告書\"、RFC 7397、DOI 10.17487 / RFC7397、2014年12月、<http://www.rfc-editor.org/info/rfc7397> 。"
    },
    {
      "indent": 3,
      "text": "[RFC7400] Bormann, C., \"6LoWPAN-GHC: Generic Header Compression for IPv6 over Low-Power Wireless Personal Area Networks (6LoWPANs)\", RFC 7400, DOI 10.17487/RFC7400, November 2014, <http://www.rfc-editor.org/info/rfc7400>.",
      "ja": "[RFC7400]ボルマン、C.、 \"6LoWPAN-GHC：低電力無線パーソナルエリアネットワーク上のIPv6（6LoWPANs）のための一般ヘッダー圧縮\"、RFC 7400、DOI 10.17487 / RFC7400、2014年11月、<のhttp：//www.rfc -editor.org/info/rfc7400>。"
    },
    {
      "indent": 3,
      "text": "[RFC7452] Tschofenig, H., Arkko, J., Thaler, D., and D. McPherson, \"Architectural Considerations in Smart Object Networking\", RFC 7452, DOI 10.17487/RFC7452, March 2015, <http://www.rfc-editor.org/info/rfc7452>.",
      "ja": "[RFC7452] Tschofenig、H.、Arkko、J.、ターラー、D.、およびD.マクファーソン、 \"スマートオブジェクト・ネットワーキングの建築に関する注意事項\"、RFC 7452、DOI 10.17487 / RFC7452、2015年3月、<のhttp：// WWW。 rfc-editor.org/info/rfc7452>。"
    },
    {
      "indent": 3,
      "text": "[RFC7465] Popov, A., \"Prohibiting RC4 Cipher Suites\", RFC 7465, DOI 10.17487/RFC7465, February 2015, <http://www.rfc-editor.org/info/rfc7465>.",
      "ja": "[RFC7465]ポポフ、A.、 \"の禁止RC4暗号スイート\"、RFC 7465、DOI 10.17487 / RFC7465、2015年2月、<http://www.rfc-editor.org/info/rfc7465>。"
    },
    {
      "indent": 3,
      "text": "[RFC7507] Moeller, B. and A. Langley, \"TLS Fallback Signaling Cipher Suite Value (SCSV) for Preventing Protocol Downgrade Attacks\", RFC 7507, DOI 10.17487/RFC7507, April 2015, <http://www.rfc-editor.org/info/rfc7507>.",
      "ja": "[RFC7507]メラー、B.とA.ラングレー、RFC 7507 \"TLSフォールバックシグナリング暗号スイート値（SCSV）プロトコルダウングレード攻撃の防止のために\"、DOI 10.17487 / RFC7507、2015年4月、<のhttp：//www.rfc-editor .ORG /情報/ rfc7507>。"
    },
    {
      "indent": 3,
      "text": "[RFC7525] Sheffer, Y., Holz, R., and P. Saint-Andre, \"Recommendations for Secure Use of Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)\", BCP 195, RFC 7525, DOI 10.17487/RFC7525, May 2015, <http://www.rfc-editor.org/info/rfc7525>.",
      "ja": "[RFC7525]シェファー、Y.、ホルツ、R.、およびP.サンアンドレ、 \"トランスポート層セキュリティ（TLS）およびデータグラムトランスポート層セキュリティ（DTLS）のセキュアな利用のための提言\"、BCP 195、RFC 7525、DOI 10.17487 / RFC7525、2015年5月、<http://www.rfc-editor.org/info/rfc7525>。"
    },
    {
      "indent": 3,
      "text": "[RFC7539] Nir, Y. and A. Langley, \"ChaCha20 and Poly1305 for IETF Protocols\", RFC 7539, DOI 10.17487/RFC7539, May 2015, <http://www.rfc-editor.org/info/rfc7539>.",
      "ja": "[RFC7539]ニール、Y.及びA.ラングレー、 \"IETFプロトコルのためのChaCha20とPoly1305\"、RFC 7539、DOI 10.17487 / RFC7539、2015年5月、<http://www.rfc-editor.org/info/rfc7539>。"
    },
    {
      "indent": 3,
      "text": "[RFC7568] Barnes, R., Thomson, M., Pironti, A., and A. Langley, \"Deprecating Secure Sockets Layer Version 3.0\", RFC 7568, DOI 10.17487/RFC7568, June 2015, <http://www.rfc-editor.org/info/rfc7568>.",
      "ja": "[RFC7568]バーンズ、R.、トムソン、M.、Pironti、A.、およびA.ラングレー、RFC 7568 \"のSecure Sockets Layerバージョン3.0を非推奨\"、DOI 10.17487 / RFC7568、2015年6月、<のhttp：// WWW。 rfc-editor.org/info/rfc7568>。"
    },
    {
      "indent": 3,
      "text": "[RFC7748] Langley, A., Hamburg, M., and S. Turner, \"Elliptic Curves for Security\", RFC 7748, DOI 10.17487/RFC7748, January 2016, <http://www.rfc-editor.org/info/rfc7748>.",
      "ja": "[RFC7748]ラングレー、A.、ハンブルク、M.、およびS.ターナー、 \"セキュリティのための楕円曲線\"、RFC 7748、DOI 10.17487 / RFC7748、2016年1月、<http://www.rfc-editor.org/info / rfc7748>。"
    },
    {
      "indent": 3,
      "text": "[SP800-107-rev1] National Institute of Standards and Technology, \"Recommendation for Applications Using Approved Hash Algorithms\", NIST Special Publication 800-107, Revision 1, DOI 10.6028/NIST.SP.800-107r1, August 2012, <http://csrc.nist.gov/publications/nistpubs/800-107-rev1/ sp800-107-rev1.pdf>.",
      "ja": "[SP800-107-REV1]米国国立標準技術研究所、 \"承認済みハッシュアルゴリズムを使用したアプリケーションのための勧告\"、は、NIST Special Publication 800から107、リビジョン1、DOI 10.6028 / NIST.SP.800-107r1、2012年8月、<HTTP ：//csrc.nist.gov/publications/nistpubs/800-107-rev1/ sp800-107-rev1.pdf>。"
    },
    {
      "indent": 3,
      "text": "[SP800-22b] National Institute of Standards and Technology, \"A Statistical Test Suite for Random and Pseudorandom Number Generators for Cryptographic Applications\", NIST Special Publication 800-22, Revision 1a, April 2010, <http://csrc.nist.gov/publications/nistpubs/800-22-rev1a/ SP800-22rev1a.pdf>.",
      "ja": "[SP800-22b]アメリカ国立標準技術研究所、「ランダムのための統計テストスイートおよび暗号アプリケーションのための擬似乱数ジェネレータ」、は、NIST Special Publication 800-22、改訂1aを、2010年4月、<のhttp：//csrc.nist。 GOV /出版/ nistpubs / 800-22-rev1a / SP800-22rev1a.pdf>。"
    },
    {
      "indent": 3,
      "text": "[SP800-90A] National Institute of Standards and Technology, \"Recommendation for Random Number Generation Using Deterministic Random Bit Generators\", NIST Special Publication 800-90A Revision 1, DOI 10.6028/NIST.SP.800-90Ar1, June 2015, <http://csrc.nist.gov/publications/drafts/800-90/ sp800-90a_r1_draft_november2014_ver.pdf>.",
      "ja": "[SP800-90A]米国国立標準技術研究所、 \"確定的ランダムビットジェネレータを使用して乱数生成のための勧告\"、は、NIST Special Publication 800-90A改訂1、DOI 10.6028 / NIST.SP.800-90Ar1、2015年6月、<HTTP ：//csrc.nist.gov/publications/drafts/800-90/ sp800-90a_r1_draft_november2014_ver.pdf>。"
    },
    {
      "indent": 3,
      "text": "[TLS-FALSESTART] Langley, A., Modadugu, N., and B. Moeller, \"Transport Layer Security (TLS) False Start\", Work in Progress, draft-ietf-tls-falsestart-02, May 2016.",
      "ja": "[TLS-FALSESTART]ラングレー、A.、Modadugu、N.、およびB.メラー、 \"トランスポート層セキュリティ（TLS）不正スタート\" が進行中で働いて、ドラフト-IETF-TLS-falsestart-02、2016年5月には。"
    },
    {
      "indent": 3,
      "text": "[Triple-HS] Bhargavan, K., Delignat-Lavaud, C., Pironti, A., and P. Yves Strub, \"Triple Handshakes and Cookie Cutters: Breaking and Fixing Authentication over TLS\", In Proceedings of the IEEE Symposium on Security and Privacy, Pages 98-113, DOI 10.1109/SP.2014.14, 2014.",
      "ja": "[トリプルHS] Bhargavan、K.、Delignat-Lavaud、C.、Pironti、A.、およびP.イヴStrub、 \"トリプル握手とクッキーカッター：ブレイキング及びTLS上固定認証\"、IEEEシンポジウムの議事録におけるオンセキュリティとプライバシー、ページ98から113、DOI 10.1109 / SP.2014.14、2014。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Conveying DTLS over SMS",
      "ja": "SMS経由DTLSを伝える付録A."
    },
    {
      "indent": 3,
      "text": "This section is normative for the use of DTLS over SMS. Timer recommendations are already outlined in Section 11 and also applicable to the transport of DTLS over SMS.",
      "ja": "このセクションでは、SMS経由DTLSを使用するための規範です。タイマーの推奨事項は、すでに第11節で概説し、SMS経由DTLSの輸送にも適用されます。"
    },
    {
      "indent": 3,
      "text": "This section requires readers to be familiar with the terminology and concepts described in [GSM-SMS] and [WAP-WDP].",
      "ja": "このセクションでは、[GSM-SMS]および[WAP-WDP]に記載の用語と概念に精通している読者を必要とします。"
    },
    {
      "indent": 3,
      "text": "The remainder of this section assumes Mobile Stations are capable of producing and consuming Transport Protocol Data Units (TPDUs) encoded as 8-bit binary data.",
      "ja": "このセクションの残りの部分は、移動局が8ビットのバイナリデータとして符号化トランスポートプロトコルデータユニット（のTPDUs）を製造し、消費することが可能である前提。"
    },
    {
      "indent": 0,
      "text": "A.1. Overview",
      "ja": "A.1。概要"
    },
    {
      "indent": 3,
      "text": "DTLS adds an additional round-trip to the TLS [RFC5246] handshake to serve as a return-routability test for protection against certain types of DoS attacks. Thus, a full-blown DTLS handshake comprises up to 6 \"flights\" (i.e., logical message exchanges), each of which is then mapped on to one or more DTLS records using the segmentation and reassembly (SaR) scheme described in Section 4.2.3 of [RFC6347]. The overhead for said scheme is 6 bytes per handshake message which, given a realistic 10+ messages handshake, would amount to around 60 bytes across the whole handshake sequence.",
      "ja": "DTLSは、DoS攻撃の特定の種類に対する保護のためのリターン・ルータビリティ・テストとして機能するTLS [RFC5246]握手に追加往復が追加されます。したがって、本格DTLSハンドシェイクは、次に、セクション4.2に記載のセグメンテーションとリアセンブリ（SAR）方式を使用して1つまたは複数のDTLSレコードへマッピングされ、それぞれが6「便」（すなわち、論理メッセージ交換）まで含みます。 [RFC6347]の3。前記スキームのためのオーバーヘッドは全体のハンドシェイクシーケンスを横切って約60バイトに達するであろう、現実的10+メッセージはハンドシェイク所与、ハンドシェイクメッセージごとに6バイトです。"
    },
    {
      "indent": 3,
      "text": "Note that the DTLS SaR scheme is defined for handshake messages only. In fact, DTLS records are never fragmented and MUST fit within a single transport layer datagram.",
      "ja": "DTLS SARスキームのみ握手メッセージに対して定義されていることに注意してください。実際には、DTLSレコードが断片化されることはありませんし、単一のトランスポート層データグラム内に適合しなければなりません。"
    },
    {
      "indent": 3,
      "text": "SMS provides an optional segmentation and reassembly scheme as well, known as Concatenated short messages (see Section 9.2.3.24.1 of [GSM-SMS]). However, since the SaR scheme in DTLS cannot be circumvented, the Concatenated short messages mechanism SHOULD NOT be used during handshake to avoid redundant overhead. Before starting the handshake phase (either actively or passively), the DTLS implementation MUST be explicitly configured with the Path MTU (PMTU) of the SMS transport in order to correctly instrument its SaR function. The PMTU SHALL be 133 bytes if multiplexing based on the Wireless Datagram Protocol (WDP) is used (see Appendix A.3); 140 bytes otherwise.",
      "ja": "SMSは、連結ショートメッセージ（セクション9.2.3.24.1参照[GSM-SMS]）としても知られている、ならびに任意のセグメンテーションとリアセンブリスキームを提供します。 DTLSにおけるSARスキームを回避することはできませんので、連結ショートメッセージのメカニズムは、冗長なオーバーヘッドを回避するためのハンドシェイク中に使用されるべきではありません。ハンドシェークフェーズ（いずれかの能動的または受動的）を開始する前に、DTLS実装は、明示的に正しく、機器のSAR機能するために、SMS輸送のパスMTU（PMTU）を設定する必要があります。ワイヤレスデータグラムプロトコル（WDP）に基づいて、多重化が使用される場合PMTUは133バイトでなければならない（付録A.3を参照）。そうでない場合は140バイト。"
    },
    {
      "indent": 3,
      "text": "It is RECOMMENDED that the established security context over the longest possible period be used (possibly until a Closure Alert message is received or after a very long inactivity timeout) to avoid the expensive re-establishment of the security association.",
      "ja": "可能な限り長い期間にわたって確立されたセキュリティコンテキストが、セキュリティアソシエーションの高価な再確立を避けるために（おそらく閉鎖警告メッセージが受信されるまで、または非常に長い非アクティブタイムアウト後に）使用することを推奨しています。"
    },
    {
      "indent": 0,
      "text": "A.2. Message Segmentation and Reassembly",
      "ja": "A.2。メッセージセグメンテーションと再構築"
    },
    {
      "indent": 3,
      "text": "The content of an SMS message is carried in the TP-UserData field, and its size may be up to 140 bytes. As already mentioned in Appendix A.1, longer (i.e., up to 34170 bytes) messages can be sent using Concatenated SMS.",
      "ja": "SMSメッセージの内容は、TP-UserDataのフィールドで運ばれ、そのサイズは、140バイトまでとすることができます。既に付録A.1で述べたように、より長い（即ち、34170バイトまでの）メッセージは、連結SMSを使用して送信することができます。"
    },
    {
      "indent": 3,
      "text": "This scheme consumes 6-7 bytes (depending on whether the short or long segmentation format is used) of the TP-UserData field, thus reducing the space available for the actual content of the SMS message to 133-134 bytes per TPDU.",
      "ja": "このスキームは、従って、133-134バイト当たりTPDUにSMSメッセージの実際の内容のために利用可能なスペースを減らす、TP-UserDataのフィールドの（短い又は長いセグメント化形式が使用されているかどうかに応じて）6-7バイトを消費します。"
    },
    {
      "indent": 3,
      "text": "Though in principle a PMTU value higher than 140 bytes could be used, which may look like an appealing option given its more efficient use of the transport, there are disadvantages to consider. First, there is an additional overhead of 7 bytes per TPDU to be paid to the SaR function (which is in addition to the overhead introduced by the DTLS SaR mechanism. Second, some networks only partially support the Concatenated SMS function, and others do not support it at all.",
      "ja": "原則的には140バイトよりも高いPMTU値は、輸送のそのより効率的に使用与えられた魅力的な選択肢のように見えることがある、使用することができますが、考慮すべき欠点があります。まず、DTLS SARメカニズムにより導入されたオーバーヘッドに追加されたSAR機能（に支払われるTPDU当たり7バイトの追加のオーバーヘッドがあります。第二に、いくつかのネットワークは、部分的にしか連結SMSの機能をサポートし、他にはありませんすべてでそれをサポートしています。"
    },
    {
      "indent": 3,
      "text": "For these reasons, the Concatenated short messages mechanism SHOULD NOT be used, and it is RECOMMENDED to leave the same PMTU settings used during the handshake phase, i.e., 133 bytes if WDP-based multiplexing is enabled; 140 bytes otherwise.",
      "ja": "これらの理由から、連結ショートメッセージメカニズムが使用されるべきではなく、WDPに基づく多重化が有効になっている場合、即ち、133バイトのハンドシェイクフェーズ中に使用したのと同じPMTU設定を残してお勧めします。そうでない場合は140バイト。"
    },
    {
      "indent": 3,
      "text": "Note that, after the DTLS handshake has completed, any fragmentation and reassembly logic that pertains the application layer (e.g., segmenting CoAP messages into DTLS records and reassembling them after the crypto operations have been successfully performed) needs to be handled by the application that uses the established DTLS tunnel.",
      "ja": "DTLSハンドシェイクが完了した後に、アプリケーション層を関係する任意の断片化と再組み立てロジック（例えば、DTLSレコードにCoAPメッセージをセグメント化し、暗号化操作が正常に実行された後にそれらを再構築する）使用するアプリケーションによって処理される必要があることに注意してください確立されたDTLSトンネル。"
    },
    {
      "indent": 0,
      "text": "A.3. Multiplexing Security Associations",
      "ja": "A.3。多重セキュリティアソシエーション"
    },
    {
      "indent": 3,
      "text": "Unlike IPsec Encapsulating Security Payload (ESP) / Authentication Header (AH), DTLS records do not contain any association identifiers. Applications must arrange to multiplex between associations on the same endpoint which, when using UDP/IP, is usually done with the host/port number.",
      "ja": "IPsecのカプセル化セキュリティペイロード（ESP）/認証ヘッダー（AH）とは異なり、DTLSレコードは、任意の関連識別子を含んでいません。アプリケーションは、UDP / IPを使用して、同じエンドポイント上の組合との間で多重化するように設定する必要があり、通常はホスト/ポート番号で行われます。"
    },
    {
      "indent": 3,
      "text": "If the DTLS server allows more than one client to be active at any given time, then the Wireless Application Protocol (WAP) User Datagram Protocol [WAP-WDP] can be used to achieve multiplexing of the different security associations. (The use of WDP provides the additional benefit that upper-layer protocols can operate independently of the underlying wireless network, hence achieving application-agnostic transport handover.)",
      "ja": "DTLSサーバは複数のクライアントは、任意の時点でアクティブにすることができます場合は、ワイヤレスアプリケーションプロトコル（WAP）ユーザーデータグラムプロトコル[WAP-WDP]は異なるセキュリティアソシエーションの多重化を達成するために使用することができます。 （WDPの使用は、上位層プロトコルは、したがって、アプリケーションに依存しないトランスポート・ハンドオーバを達成する、基礎をなす無線ネットワークから独立して動作することができるという追加の利点を提供します。）"
    },
    {
      "indent": 3,
      "text": "The total overhead cost for encoding the WDP source and destination ports is either 5 or 7 bytes out of the total available for the SMS content depending on if 1-byte or 2-byte port identifiers are used, as shown in Figures 13 and 14.",
      "ja": "図13および図14に示すようにWDPの送信元ポートと宛先ポートを符号化するための総オーバーヘッドコストは、1バイトまたは2バイトのポート識別子が使用される場合に応じてSMSコンテンツの利用可能な合計のうち5または7バイトです。"
    },
    {
      "indent": 3,
      "text": "0        1        2        3        4\n+--------+--------+--------+--------+--------+\n| ...    | 0x04   | 2      | ...    | ...    |\n+--------+--------+--------+--------+--------+\n  UDH      IEI      IE       Dest     Source\n  Length            Length   Port     Port",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Legend: UDH = user data header IEI = information element identifier",
      "ja": "凡例：UDH =ユーザデータヘッダIEI =情報要素識別子"
    },
    {
      "indent": 7,
      "text": "Figure 13: Application Port Addressing Scheme (8-Bit Address)",
      "ja": "図13：アプリケーションポートアドレッシング方式（8ビットアドレス）"
    },
    {
      "indent": 3,
      "text": "0        1        2        3        4        5        6\n+--------+--------+--------+--------+--------+--------+--------+\n| ...    | 0x05   | 4      |       ...       |       ...       |\n+--------+--------+--------+--------+--------+--------+--------+\n  UDH      IEI      IE       Dest              Source\n  Length            Length   Port              Port",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Figure 14: Application Port Addressing Scheme (16-Bit Address)",
      "ja": "図14：アプリケーションポートアドレッシング方式（16ビットアドレス）"
    },
    {
      "indent": 3,
      "text": "The receiving side of the communication gets the source address from the originator address (TP-OA) field of the SMS-DELIVER TPDU. This way, a unique 4-tuple identifying the security association can be reconstructed at both ends. (When replying to its DTLS peer, the sender will swap the TP-OA and destination address (TP-DA) parameters and the source and destination ports in the WDP.)",
      "ja": "通信の受信側は、SMS-DELIVER TPDUの発信元アドレス（TP-OA）フィールドから送信元アドレスを取得します。このように、セキュリティアソシエーションを識別する一意の4タプルは、両端で再構成することができます。 （そのDTLSピアに返信するとき、送信者は、TP-OAと宛先アドレス（TP-DA）パラメータおよびWDPで送信元ポートと宛先ポートをスワップします。）"
    },
    {
      "indent": 0,
      "text": "A.4. Timeout",
      "ja": "A.4。タイムアウト"
    },
    {
      "indent": 3,
      "text": "If SMS-STATUS-REPORT messages are enabled, their receipt is not to be interpreted as the signal that the specific handshake message has been acted upon by the receiving party. Therefore, it MUST NOT be taken into account by the DTLS timeout and retransmission function.",
      "ja": "SMS-STATUS-REPORTメッセージが有効になっている場合は、その領収書は、特定のハンドシェイクメッセージが受信者によって作用されたことを信号として解釈されるべきではありません。したがって、DTLSタイムアウトと再送信機能により考慮されてはなりません。"
    },
    {
      "indent": 3,
      "text": "Handshake messages MUST carry a validity period (TP-VP parameter in a SMS-SUBMIT TPDU) that is not less than the current value of the retransmission timeout. In order to avoid persisting messages in the network that will be discarded by the receiving party, handshake messages SHOULD carry a validity period that is the same as, or just slightly higher than, the current value of the retransmission timeout.",
      "ja": "ハンドシェイクメッセージは、再送タイムアウトの現在の値以上である有効期間（SMS-SUBMIT TPDUの中のTP-VPパラメータ）を運ばなければなりません。受信側で破棄されるネットワークでメッセージを永続化を避けるためには、ハンドシェイクメッセージが再送タイムアウトの現在の値と同じ、またはよりわずかに高い有効期間を運ぶべきです。"
    },
    {
      "indent": 0,
      "text": "Appendix B. DTLS Record Layer Per-Packet Overhead",
      "ja": "付録B. DTLSレコード層パケット単位のオーバーヘッド"
    },
    {
      "indent": 3,
      "text": "Figure 15 shows the overhead for the DTLS record layer for protecting data traffic when AES-128-CCM with an 8-octet Integrity Check Value (ICV) is used.",
      "ja": "図15は、使用されるAES-128-CCMは、8オクテットと整合性チェック値データトラフィック（ICV）を保護するためのDTLS記録層のためのオーバーヘッドを示しています。"
    },
    {
      "indent": 3,
      "text": "DTLS Record Layer Header................13 bytes\nNonce (Explicit).........................8 bytes\nICV..................................... 8 bytes\n------------------------------------------------\nOverhead................................29 bytes\n------------------------------------------------",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Figure 15: AES-128-CCM-8 DTLS Record Layer Per-Packet Overhead",
      "ja": "図15：AES-CCM-128から8 DTLSレコード層ごとのオーバーヘッドパケット"
    },
    {
      "indent": 3,
      "text": "The DTLS record layer header has 13 octets and consists of:",
      "ja": "DTLS記録層ヘッダは13個のオクテットを有しており、で構成されています。"
    },
    {
      "indent": 3,
      "text": "o 1-octet content type field,",
      "ja": "O 1オクテットのコンテンツタイプフィールド、"
    },
    {
      "indent": 3,
      "text": "o 2-octet version field,",
      "ja": "O 2オクテットのバージョンフィールド、"
    },
    {
      "indent": 3,
      "text": "o 2-octet epoch field,",
      "ja": "O 2オクテットのエポックフィールド、"
    },
    {
      "indent": 3,
      "text": "o 6-octet sequence number, and",
      "ja": "O 6オクテットのシーケンス番号、及び"
    },
    {
      "indent": 3,
      "text": "o 2-octet length field.",
      "ja": "O 2オクテットの長さフィールド。"
    },
    {
      "indent": 3,
      "text": "The \"nonce\" input to the AEAD algorithm is exactly that of [RFC5288], i.e., 12 bytes long. It consists of two values, namely a 4-octet salt and an 8-octet nonce_explicit:",
      "ja": "AEADアルゴリズムに「ナンス」入力は正確に[RFC5288]の、すなわち、12バイト長です。それは、2つの値、すなわち、4オクテットの塩と8オクテットnonce_explicitで構成されています。"
    },
    {
      "indent": 6,
      "text": "The salt is the \"implicit\" part and is not sent in the packet. Instead, the salt is generated as part of the handshake process.",
      "ja": "塩は、「暗黙的」な部分であり、パケットには送信されません。その代わりに、塩は、ハンドシェイクプロセスの一部として生成されます。"
    },
    {
      "indent": 6,
      "text": "The nonce_explicit value is 8 octets long and it is chosen by the sender and carried in each TLS record. RFC 6655 [RFC6655] allows the nonce_explicit to be a sequence number or something else. This document makes this use more restrictive for use with DTLS: the 64-bit none_explicit value MUST be the 16-bit epoch concatenated with the 48-bit seq_num. The sequence number component of the nonce_explicit field at the AES-CCM layer is an exact copy of the sequence number in the record layer header field. This leads to a duplication of 8-bytes per record.",
      "ja": "nonce_explicit値は8つのオクテットの長さであり、それは、送信者によって選ばれ、各TLSレコードで運ばれます。 RFC 6655 [RFC6655]はnonce_explicitシーケンス番号または何か他のものにすることができます。この文書では、DTLSで使用するためのこの使用は、より限定的になり：64ビットnone_explicit値は、48ビットSEQ_NUMと連結された16ビットのエポックでなければなりません。 AES-CCM層におけるnonce_explicitフィールドのシーケンス番号コンポーネントは、記録層ヘッダフィールド内のシーケンス番号の正確なコピーです。これは、レコードごとに8バイトの重複につながります。"
    },
    {
      "indent": 6,
      "text": "To avoid this 8-byte duplication, RFC 7400 [RFC7400] provides help with the use of the generic header compression technique for IPv6 over Low-Power Wireless Personal Area Networks (6LoWPANs). Note that this header compression technique is not available when DTLS is exchanged over transports that do not use IPv6 or 6LoWPAN, such as the SMS transport described in Appendix A of this document.",
      "ja": "この8バイトの重複を避けるために、RFC 7400 [RFC7400]は、低消費電力無線パーソナルエリアネットワーク（6LoWPANs）経由のIPv6のための一般的なヘッダ圧縮技術を使用してヘルプを提供します。 DTLSは、本書の付録Aに記載されたSMSトランスポートとしてのIPv6または6LoWPANを使用していないトランスポートを介して交換されたときに、このヘッダ圧縮技術が利用可能でないことに留意されたいです。"
    },
    {
      "indent": 0,
      "text": "Appendix C. DTLS Fragmentation",
      "ja": "付録C.フラグメンテーションDTLS"
    },
    {
      "indent": 3,
      "text": "Section 4.2.3 of [RFC6347] advises DTLS implementations to not produce overlapping fragments. However, it requires receivers to be able to cope with them. The need for the latter requisite is explained in Section 4.1.1.1 of [RFC6347]: accurate PMTU estimation may be traded for shorter handshake completion time.",
      "ja": "[RFC6347]のセクション4.2.3には、重複断片を生成しないようにDTLS実装を助言します。しかし、それはそれらに対処できるように受信機を必要とします。後者の必要の必要性は、[RFC6347]のセクション4.1.1.1に説明されて：正確PMTU推定が短いハンドシェイク完了時刻と交換することができます。"
    },
    {
      "indent": 3,
      "text": "In many cases, the cost of handling fragment overlaps has proved to be unaffordable for constrained implementations, particularly because of the increased complexity in buffer management.",
      "ja": "多くの場合、断片の重複を処理するコストは、特にためのバッファ管理における増大した複雑で、制約の実装のために手が届かないことが証明されています。"
    },
    {
      "indent": 3,
      "text": "In order to reduce the likelihood of producing different fragment sizes and consequent overlaps within the same handshake, this document RECOMMENDs:",
      "ja": "同じハンドシェーク内の異なる断片サイズとその結果として重複を生成する可能性を低減するために、この文書は、お勧めします。"
    },
    {
      "indent": 3,
      "text": "o clients (handshake initiators) to use reliable PMTU information for the intended destination; and",
      "ja": "Oクライアント（ハンドシェイクイニシエータ）意図した目的地のための信頼性のPMTU情報を使用します。そして"
    },
    {
      "indent": 3,
      "text": "o servers to mirror the fragment size selected by their clients.",
      "ja": "Oサーバは、クライアントによって選択されたフラグメントサイズをミラーリングします。"
    },
    {
      "indent": 3,
      "text": "The PMTU information comes from either a \"fresh enough\" discovery performed by the client [RFC1981] [RFC4821] or some other reliable out-of-band channel.",
      "ja": "PMTU情報は、クライアント[RFC1981] [RFC4821]や他のいくつかの信頼性の高いアウトオブバンドチャネルにより実行される「新鮮十分な」発見のいずれかから来ています。"
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Thanks to Derek Atkins, Paul Bakker, Olaf Bergmann, Carsten Bormann, Ben Campbell, Brian Carpenter, Robert Cragie, Spencer Dawkins, Russ Housley, Rene Hummen, Jayaraghavendran K, Sye Loong Keoh, Matthias Kovatsch, Sandeep Kumar, Barry Leiba, Simon Lemay, Alexey Melnikov, Gabriel Montenegro, Manuel Pegourie-Gonnard, Akbar Rahman, Eric Rescorla, Michael Richardson, Ludwig Seitz, Zach Shelby, Michael StJohns, Rene Struik, Tina Tsou, and Sean Turner for their helpful comments and discussions that have shaped the document.",
      "ja": "デレク・アトキンス、ポール・バッカー、オラフ・バーグマン、カルステンボルマン、ベン・キャンベル、ブライアン・カーペンター、ロバートCragie、スペンサードーキンス、ラスHousley、ルネHummen、Jayaraghavendran KとsyeルーンKeoh、マティアスKovatsch、サンディープ・クマール、バリー・レイバ、サイモン・ルメイのおかげで、アレクセイ・メルニコフ、ガブリエルモンテネグロ、文書を形作ってきた彼らの有益なコメントや議論のためのマヌエルPegourie-Gonnard、アクバル・ラーマン、エリックレスコラ、マイケル・リチャードソン、ルートヴィヒ・サイツ、ザックシェルビー、マイケルStJohns、ルネStruik、ティナツオウ、そしてショーン・ターナー。"
    },
    {
      "indent": 3,
      "text": "A big thanks also to Klaus Hartke, who wrote the initial draft version of this document.",
      "ja": "また、このドキュメントの最初のドラフト版を書いたクラウスHARTKEに大きな感謝。"
    },
    {
      "indent": 3,
      "text": "Finally, we would like to thank our area director (Stephen Farrell) and our working group chairs (Zach Shelby and Dorothy Gellert) for their support.",
      "ja": "最後に、私たちは私たちの地域ディレクター（スティーブン・ファレル）と彼らのサポートのために私たちのワーキンググループチェア（ザック・シェルビーとドロシーゲラート）を感謝したいと思います。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Hannes Tschofenig (editor) ARM Ltd. 110 Fulbourn Rd Cambridge CB1 9NJ United Kingdom",
      "ja": "ハンネスTschofenig（エディタ）ARM社110 Fulbourn RdのケンブリッジCB1 9NJイギリス"
    },
    {
      "indent": 3,
      "text": "Email: Hannes.tschofenig@gmx.net URI: http://www.tschofenig.priv.at",
      "ja": "メール：Hannes.tschofenig@gmx.net URI：http://www.tschofenig.priv.at"
    },
    {
      "indent": 3,
      "text": "Thomas Fossati Nokia 3 Ely Road Milton, Cambridge CB24 6DD United Kingdom",
      "ja": "トーマス・フォッサーティノキア3エリー道路ミルトン、ケンブリッジCB24 6DDイギリス"
    },
    {
      "indent": 3,
      "text": "Email: thomas.fossati@nokia.com",
      "ja": "メール：thomas.fossati@nokia.com"
    }
  ]
}