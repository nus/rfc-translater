{
  "title": {
    "text": "RFC 7787 - Distributed Node Consensus Protocol",
    "ja": "RFC 7787 - 分散ノード合意プロトコル"
  },
  "number": 7787,
  "created_at": "2019-11-02 10:12:55.073579+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                       M. Stenberg\nRequest for Comments: 7787                                      S. Barth\nCategory: Standards Track                                    Independent\nISSN: 2070-1721                                               April 2016",
      "raw": true
    },
    {
      "indent": 18,
      "text": "Distributed Node Consensus Protocol",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document describes the Distributed Node Consensus Protocol (DNCP), a generic state synchronization protocol that uses the Trickle algorithm and hash trees. DNCP is an abstract protocol and must be combined with a specific profile to make a complete implementable protocol.",
      "ja": "この文書では、分散ノード合意プロトコル（DNCP）、トリクルアルゴリズムとハッシュ木を使用して、一般的な状態同期プロトコルを記述します。 DNCPは抽象プロトコルであり、完全な実行可能なプロトコルを作るために特定のプロファイルと組み合わせる必要があります。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 5741のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7787.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7787で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2016 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2016 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3\n  1.1.  Applicability . . . . . . . . . . . . . . . . . . . . . .   4\n2.  Terminology . . . . . . . . . . . . . . . . . . . . . . . . .   6\n  2.1.  Requirements Language . . . . . . . . . . . . . . . . . .   8\n3.  Overview  . . . . . . . . . . . . . . . . . . . . . . . . . .   8\n4.  Operation . . . . . . . . . . . . . . . . . . . . . . . . . .   9\n  4.1.  Hash Tree . . . . . . . . . . . . . . . . . . . . . . . .   9\n    4.1.1.  Calculating Network State and Node Data Hashes  . . .  10\n    4.1.2.  Updating Network State and Node Data Hashes . . . . .  10\n  4.2.  Data Transport  . . . . . . . . . . . . . . . . . . . . .  10\n  4.3.  Trickle-Driven Status Updates . . . . . . . . . . . . . .  12\n  4.4.  Processing of Received TLVs . . . . . . . . . . . . . . .  13\n  4.5.  Discovering, Adding, and Removing Peers . . . . . . . . .  15\n  4.6.  Data Liveliness Validation  . . . . . . . . . . . . . . .  16\n5.  Data Model  . . . . . . . . . . . . . . . . . . . . . . . . .  17\n6.  Optional Extensions . . . . . . . . . . . . . . . . . . . . .  19\n  6.1.  Keep-Alives . . . . . . . . . . . . . . . . . . . . . . .  19\n    6.1.1.  Data Model Additions  . . . . . . . . . . . . . . . .  20\n    6.1.2.  Per-Endpoint Periodic Keep-Alives . . . . . . . . . .  20\n    6.1.3.  Per-Peer Periodic Keep-Alives . . . . . . . . . . . .  20\n    6.1.4.  Received TLV Processing Additions . . . . . . . . . .  21\n    6.1.5.  Peer Removal  . . . . . . . . . . . . . . . . . . . .  21\n  6.2.  Support for Dense Multicast-Enabled Links . . . . . . . .  21\n7.  Type-Length-Value Objects . . . . . . . . . . . . . . . . . .  22\n  7.1.  Request TLVs  . . . . . . . . . . . . . . . . . . . . . .  23\n    7.1.1.  Request Network State TLV . . . . . . . . . . . . . .  23\n    7.1.2.  Request Node State TLV  . . . . . . . . . . . . . . .  24\n  7.2.  Data TLVs . . . . . . . . . . . . . . . . . . . . . . . .  24\n    7.2.1.  Node Endpoint TLV . . . . . . . . . . . . . . . . . .  24\n    7.2.2.  Network State TLV . . . . . . . . . . . . . . . . . .  25\n    7.2.3.  Node State TLV  . . . . . . . . . . . . . . . . . . .  25\n  7.3.  Data TLVs within Node State TLV . . . . . . . . . . . . .  26\n    7.3.1.  Peer TLV  . . . . . . . . . . . . . . . . . . . . . .  26\n    7.3.2.  Keep-Alive Interval TLV . . . . . . . . . . . . . . .  27\n8.  Security and Trust Management . . . . . . . . . . . . . . . .  27\n  8.1.  Trust Method Based on Pre-Shared Key  . . . . . . . . . .  27\n  8.2.  PKI-Based Trust Method  . . . . . . . . . . . . . . . . .  28\n  8.3.  Certificate-Based Trust Consensus Method  . . . . . . . .  28\n    8.3.1.  Trust Verdicts  . . . . . . . . . . . . . . . . . . .  28\n    8.3.2.  Trust Cache . . . . . . . . . . . . . . . . . . . . .  29\n    8.3.3.  Announcement of Verdicts  . . . . . . . . . . . . . .  30\n    8.3.4.  Bootstrap Ceremonies  . . . . . . . . . . . . . . . .  31\n9.  DNCP Profile-Specific Definitions . . . . . . . . . . . . . .  32\n10. Security Considerations . . . . . . . . . . . . . . . . . . .  34\n11. IANA Considerations . . . . . . . . . . . . . . . . . . . . .  35",
      "raw": true
    },
    {
      "indent": 3,
      "text": "12. References  . . . . . . . . . . . . . . . . . . . . . . . . .  36\n  12.1.  Normative References . . . . . . . . . . . . . . . . . .  36\n  12.2.  Informative References . . . . . . . . . . . . . . . . .  36\nAppendix A.  Alternative Modes of Operation . . . . . . . . . . .  38\n  A.1.  Read-Only Operation . . . . . . . . . . . . . . . . . . .  38\n  A.2.  Forwarding Operation  . . . . . . . . . . . . . . . . . .  38\nAppendix B.  DNCP Profile Additional Guidance . . . . . . . . . .  38\n  B.1.  Unicast Transport -- UDP or TCP?  . . . . . . . . . . . .  38\n  B.2.  (Optional) Multicast Transport  . . . . . . . . . . . . .  39\n  B.3.  (Optional) Transport Security . . . . . . . . . . . . . .  39\nAppendix C.  Example Profile  . . . . . . . . . . . . . . . . . .  40\nAcknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  41\nAuthors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  41",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "DNCP is designed to provide a way for each participating node to publish a small set of TLV (Type-Length-Value) tuples (at most 64 KB) and to provide a shared and common view about the data published by every currently bidirectionally reachable DNCP node in a network.",
      "ja": "DNCPは、各参加ノードが（ほとんどの64キロバイトで）TLV（タイプ - 長さ - 値）タプルの小さなセットを公開するための方法を提供し、すべての現在双方向に到達DNCPによって公表されたデータについて共有し、共通のビューを提供するように設計されてネットワーク内のノード。"
    },
    {
      "indent": 3,
      "text": "For state synchronization, a hash tree is used. It is formed by first calculating a hash for the data set published by each node, called node data, and then calculating another hash over those node data hashes. The single resulting hash, called network state hash, is transmitted using the Trickle algorithm [RFC6206] to ensure that all nodes share the same view of the current state of the published data within the network. The use of Trickle with only short network state hashes sent infrequently (in steady state, once the maximum Trickle interval per link or unicast connection has been reached) makes DNCP very thrifty when updates happen rarely.",
      "ja": "状態同期では、ハッシュツリーが使用されています。なお、第1のノードデータと呼ばれる各ノードによって公表されたデータセットのハッシュを計算し、それらのノード・データ・ハッシュを介して別のハッシュを計算することにより形成されています。ネットワーク状態ハッシュと呼ばれる単一の結果のハッシュは、すべてのノードがネットワーク内の公開されたデータの現在の状態の同じビューを共有することを保証するために、トリクルアルゴリズム[RFC6206]を使用して送信されます。更新はめったに起こらないとき（リンクまたはユニキャスト接続あたりの最大トリクル間隔に達した後、定常状態で）あまり頻繁に送信されるだけの短いネットワーク状態のハッシュとトリクルの使用はDNCPは非常に倹約なります。"
    },
    {
      "indent": 3,
      "text": "For maintaining liveliness of the topology and the data within it, a combination of Trickled network state, keep-alives, and \"other\" means of ensuring reachability are used. The core idea is that if every node ensures its peers are present, transitively, the whole network state also stays up to date.",
      "ja": "トポロジーとその中のデータ、細流ネットワーク状態の組み合わせ、キープアライブ、および到達可能性を保証する「他の」手段の活気を維持するために使用されます。核となるアイデアは、すべてのノードがそのピアが存在している保証している場合、推移、ネットワーク全体の状態も最新の状態にとどまるということです。"
    },
    {
      "indent": 0,
      "text": "1.1. Applicability",
      "section_title": true,
      "ja": "1.1. 適用性"
    },
    {
      "indent": 3,
      "text": "DNCP is useful for cases like autonomous bootstrapping, discovery, and negotiation of embedded network devices like routers. Furthermore, it can be used as a basis to run distributed algorithms like [RFC7596] or use cases as described in Appendix C. DNCP is abstract, which allows it to be tuned to a variety of applications by defining profiles. These profiles include choices of:",
      "ja": "DNCPは自律ブートストラップ、発見、およびルータなどの組み込みネットワーク機器の交渉ような場合に便利です。また、[RFC7596]のような分散アルゴリズムを実行するか、付録C. DNCPに記載されているような場合に使用するための基礎として使用することができ、それはプロファイルを定義することにより、様々な用途に同調することを可能にする、抽象的です。これらのプロファイルは、の選択肢が含まれています。"
    },
    {
      "indent": 3,
      "text": "- unicast transport: a datagram or stream-oriented protocol (e.g., TCP, UDP, or the Stream Control Transmission Protocol (SCTP)) for generic protocol operation.",
      "ja": " - ユニキャストトランスポート：汎用プロトコル動作のためのデータグラムまたはストリーム指向のプロトコル（例えば、TCP、UDP、又はストリーム制御伝送プロトコル（SCTP））。"
    },
    {
      "indent": 3,
      "text": "- optional transport security: whether and when to use security based on Transport Layer Security (TLS) or Datagram Transport Layer Security (DTLS), if supported over the chosen transport.",
      "ja": " - オプションのトランスポート・セキュリティ：かどうか、およびトランスポート層セキュリティ（TLS）またはデータグラムトランスポート層セキュリティ（DTLS）に基づいたセキュリティを使用する際に、選択したトランスポート上でサポートされている場合。"
    },
    {
      "indent": 3,
      "text": "- optional multicast transport: a multicast-capable protocol like UDP allowing autonomous peer discovery or more efficient use of multiple access links.",
      "ja": " - 任意マルチキャストトランスポート：UDP自律ピア発見または複数のアクセスリンクのより効率的な使用を可能にするようなマルチキャスト対応プロトコル。"
    },
    {
      "indent": 3,
      "text": "- communication scopes: using either hop by hop only relying on link-local addressing (e.g., for LANs), addresses with broader scopes (e.g., over WANs or the Internet) relying on an existing routing infrastructure, or a combination of both (e.g., to exchange state between multiple LANs over a WAN or the Internet).",
      "ja": " - 通信スコープ：によってのみ既存のルーティングインフラストラクチャ、またはその両方の組み合わせに依存する広いスコープ（例えば、WAN上またはインターネット）とリンクローカル（例えば、LANの）アドレッシング、アドレスに依存ホップホップのいずれかで使用して（例えば、WANまたはインターネット）を介して複数のLAN間の状態を交換します。"
    },
    {
      "indent": 3,
      "text": "- payloads: additional specific payloads (e.g., IANA standardized, enterprise-specific, or private use).",
      "ja": " - ペイロード：追加の特定のペイロード（例えば、IANA標準化された、企業固有の、または私的使用）。"
    },
    {
      "indent": 3,
      "text": "- extensions: possible protocol extensions, either as predefined in this document or specific for a particular use case.",
      "ja": " - 拡張：可能なプロトコル拡張、いずれか本書で事前定義または特定の使用の場合に特異的です。"
    },
    {
      "indent": 3,
      "text": "However, there are certain cases where the protocol as defined in this document is a less suitable choice. This list provides an overview while the following paragraphs provide more detailed guidance on the individual matters.",
      "ja": "しかしながら、本文書で定義されたプロトコルはあまり適切な選択である特定の場合があります。次の段落は、個々の事項について、より詳細なガイダンスを提供しながら、このリストには、概要を説明します。"
    },
    {
      "indent": 3,
      "text": "- large amounts of data: nodes are limited to 64 KB of published data.",
      "ja": " - 大量のデータ：ノードが公開されたデータの64キロバイトに制限されています。"
    },
    {
      "indent": 3,
      "text": "- very dense unicast-only networks: nodes include information about all immediate neighbors as part of their published data.",
      "ja": " - 非常に密なユニキャストのみのネットワーク：ノードは、公表データの一部として、すべてのすぐ隣の情報が含まれています。"
    },
    {
      "indent": 3,
      "text": "- predominantly minimal data changes: node data is always transported as is, leading to a relatively large transmission overhead for changes affecting only a small part of it.",
      "ja": " - 主に最小のデータ変更：ノードデータは常にそれのほんの一部に影響を与える変化を、比較的大きな伝送オーバヘッドにつながる、そのまま搬送されます。"
    },
    {
      "indent": 3,
      "text": "- frequently changing data: DNCP with its use of Trickle is optimized for the steady state and less efficient otherwise.",
      "ja": " - 頻繁に変化するデータ：トリクルの使用とDNCPは、そうでなければ、定常状態と低効率のために最適化されます。"
    },
    {
      "indent": 3,
      "text": "- large amounts of very constrained nodes: DNCP requires each node to store the entirety of the data published by all nodes.",
      "ja": " - 非常に制約されたノードの大量：DNCPすべてのノードによって公表されたデータの全体を格納するために各ノードを必要とします。"
    },
    {
      "indent": 3,
      "text": "The topology of the devices is not limited and automatically discovered. When relying on link-local communication exclusively, all links having DNCP nodes need to be at least transitively connected by routers running the protocol on multiple endpoints in order to form a connected network. However, there is no requirement for every device in a physical network to run the protocol. Especially if globally scoped addresses are used, DNCP peers do not need to be on the same or even neighboring physical links. Autonomous discovery features are usually used in local network scenarios; however, with security enabled, DNCP can also be used over unsecured public networks. Network size is restricted merely by the capabilities of the devices, i.e., each DNCP node needs to be able to store the entirety of the data published by all nodes. The data associated with each individual node identifier is limited to about 64 KB in this document; however, protocol extensions could be defined to mitigate this or other protocol limitations if the need arises.",
      "ja": "デバイスのトポロジは限定されず、自動的に発見しました。排他的にリンクローカル通信に頼る場合、DNCPノードを有するすべてのリンクは、少なくとも過渡的に接続されたネットワークを形成するために複数のエンドポイント上でプロトコルを実行するルータによって接続する必要があります。しかし、プロトコルを実行するための物理ネットワーク内のすべてのデバイスのための必要はありません。グローバルスコープのアドレスが使用されている場合は特に、DNCPピアは同じ、あるいは近隣の物理リンク上にある必要はありません。自律ディスカバリ機能は、通常、ローカルネットワークのシナリオで使用されています。しかし、セキュリティが有効で、DNCPは保護されていない公共ネットワーク経由でも使用することができます。ネットワークのサイズはデバイスの機能だけで制限されている、すなわち、各DNCPノードは、すべてのノードによって公表されたデータの全体を記憶することができる必要があります。各個々のノード識別子に関連付けられたデータは、この文書で約64 KBに制限されています。しかし、プロトコル拡張は、必要が生じた場合は、このまたは他のプロトコルの制限を緩和するように定義することができます。"
    },
    {
      "indent": 3,
      "text": "DNCP is most suitable for data that changes only infrequently to gain the maximum benefit from using Trickle. As the network of nodes grows, or the frequency of data changes per node increases, Trickle is eventually used less and less, and the benefit of using DNCP diminishes. In these cases, Trickle just provides extra complexity within the specification and little added value.",
      "ja": "DNCPはトリクルを使用することから最大の利益を得るためにまれにしか変更されるデータのために最も適しています。ノードのネットワークが成長する、またはノード増加あたりのデータ変更の頻度として、トリクルは、最終的に少なく使用され、そしてDNCPを使用することの利点は、減少します。これらのケースでは、トリクルはちょうど仕様と少し付加価値の中の余分な複雑さを提供します。"
    },
    {
      "indent": 3,
      "text": "The suitability of DNCP for a particular application can be roughly evaluated by considering the expected average network-wide state change interval A_NC_I; it is computed by dividing the mean interval at which a node originates a new TLV set by the number of participating nodes. If keep-alives are used, A_NC_I is the minimum of the computed A_NC_I and the keep-alive interval. If A_NC_I is less than the (application-specific) Trickle minimum interval, DNCP is most likely unsuitable for the application as Trickle will not be utilized most of the time.",
      "ja": "特定の用途のためDNCPの適合性は概ね予想される平均的なネットワーク全体の状態変化間隔A_NC_Iを考慮することによって評価することができます。これは、ノードが参加ノードの数によって設定された新たなTLVを発信した時の平均間隔を割ることによって計算されます。キープアライブを使用する場合は、A_NC_Iは、計算A_NC_Iとキープアライブ間隔の最小値です。 A_NC_Iは（アプリケーション固有）トリクル最小間隔より小さい場合、DNCPはおそらく不適切トリクルは、ほとんどの時間を利用することがないので、アプリケーションのためのものです。"
    },
    {
      "indent": 3,
      "text": "If constant rapid state changes are needed, the preferable choice is to use an additional point-to-point channel whose address or locator is published using DNCP. Nevertheless, if doing so does not raise A_NC_I above the (sensibly chosen) Trickle interval parameters for a particular application, using DNCP is probably not suitable for the application.",
      "ja": "一定の急激な状態変化が必要な場合は、望ましい選択肢は、そのアドレスまたはロケータDNCPを使用して公開された追加のポイント・ツー・ポイントのチャネルを使用することです。それにもかかわらず、そうする場合は（賢明に選ばれた）DNCPはおそらくアプリケーションに適していない使用して、特定のアプリケーションのためのインターバルのパラメータをトリクル上A_NC_Iは発生しません。"
    },
    {
      "indent": 3,
      "text": "Another consideration is the size of the published TLV set by a node compared to the size of deltas in the TLV set. If the TLV set published by a node is very large, and has frequent small changes, DNCP as currently specified in this specification may be unsuitable as it lacks a delta synchronization scheme to keep implementation simple.",
      "ja": "別の考慮事項は、TLVセット内のデルタのサイズに比べノードによって設定された公開されたTLVのサイズです。ノードによって発行TLVセットが非常に大きく、頻繁な小さな変化を持っている場合は、実装をシンプルに保つために、デルタ同期スキームを欠くように、現在、本明細書で指定DNCPが不適切であってもよいです。"
    },
    {
      "indent": 3,
      "text": "DNCP can be used in networks where only unicast transport is available. While DNCP uses the least amount of bandwidth when multicast is utilized, even in pure unicast mode, the use of Trickle (ideally with k < 2) results in a protocol with an exponential backoff timer and fewer transmissions than a simpler protocol not using Trickle.",
      "ja": "DNCPのみユニキャストトランスポートが利用可能であるネットワークで使用することができます。 DNCPマルチキャストが利用される帯域幅の最小量を使用しながらも純粋なユニキャストモードでは、トリクルの使用は、（理想的にはkを有する<2）指数バックオフ・タイマとトリクルを使用しない単純なプロトコルよりも少ない送信とプロトコルになります。"
    },
    {
      "indent": 0,
      "text": "2. Terminology",
      "section_title": true,
      "ja": "2.用語"
    },
    {
      "indent": 3,
      "text": "DNCP profile the values for the set of parameters given in Section 9. They are prefixed with DNCP_ in this document. The profile also specifies the set of optional DNCP extensions to be used. For a simple example DNCP profile, see Appendix C.",
      "ja": "彼らは、この文書でDNCP_が付いている第9節で与えられたパラメータのセットの値をプロファイルDNCP。プロファイルはまた、オプションのDNCPの拡張セットを使用するように指定します。簡単な例をDNCPプロファイルについては、付録Cを参照してください。"
    },
    {
      "indent": 3,
      "text": "DNCP-based a protocol that provides a DNCP profile, according protocol to Section 9, and zero or more TLV assignments from the per-DNCP profile TLV registry as well as their processing rules.",
      "ja": "セクション9、およびゼロまたはそれ以上のTLVの割り当てごとDNCPプロファイルTLVレジストリから、ならびにそれらの処理ルールのプロトコルに従って、DNCPプロファイルを提供するプロトコルをDNCPがベース。"
    },
    {
      "indent": 3,
      "text": "DNCP node a single node that runs a DNCP-based protocol.",
      "ja": "DNCPはDNCPベースのプロトコルを実行する単一ノードをノード。"
    },
    {
      "indent": 3,
      "text": "Link a link-layer media over which directly connected nodes can communicate.",
      "ja": "直接接続されたノードが通信することができる上に、リンク層媒体をリンクします。"
    },
    {
      "indent": 3,
      "text": "DNCP network a set of DNCP nodes running a DNCP-based protocol(s) with a matching DNCP profile(s). The set consists of nodes that have discovered each other using the transport method defined in the DNCP profile, via multicast on local links, and/or by using unicast communication.",
      "ja": "DNCPネットワーク整合DNCPプロファイル（S）とDNCPベースのプロトコル（単数または複数）を実行DNCPノードのセット。セットは、ローカルリンク上でマルチキャストを介して、及び/又はユニキャスト通信を使用して、DNCPプロファイルに定義された転送方法を使用して互いを発見したノードで構成されています。"
    },
    {
      "indent": 3,
      "text": "Node identifier an opaque fixed-length identifier consisting of DNCP_NODE_IDENTIFIER_LENGTH bytes that uniquely identifies a DNCP node within a DNCP network.",
      "ja": "ノード識別子一意DNCPネットワーク内DNCPノードを識別するDNCP_NODE_IDENTIFIER_LENGTHバイトからなる不透明な固定長の識別子。"
    },
    {
      "indent": 3,
      "text": "Interface a node's attachment to a particular link.",
      "ja": "特定のリンクへのノードの添付ファイルをインターフェイス。"
    },
    {
      "indent": 3,
      "text": "Address an identifier used as the source or destination of a DNCP message flow, e.g., a tuple (IPv6 address, UDP port) for an IPv6 UDP transport.",
      "ja": "DNCPメッセージフローの送信元または宛先として使用される識別子を扱う、例えば、IPv6のUDPトランスポートのタプル（IPv6アドレス、UDPポート）。"
    },
    {
      "indent": 3,
      "text": "Endpoint a locally configured termination point for (potential or established) DNCP message flows. An endpoint is the source and destination for separate unicast message flows to individual nodes and optionally for multicast messages to all thereby reachable nodes (e.g., for node discovery). Endpoints are usually in one of the transport modes specified in Section 4.2.",
      "ja": "エンドポイントのローカルに設定終端点（電位または確立）DNCPメッセージが流れます。エンドポイントが別のユニキャストメッセージの送信元と送信先が（ノードの発見のために、例えば）全てそれによって到達可能なノードにマルチキャストメッセージのために必要に応じて個々のノードに流入しています。エンドポイントは、4.2節で指定されたトランスポートモードのいずれかであるのが普通です。"
    },
    {
      "indent": 3,
      "text": "Endpoint a 32-bit opaque and locally unique value, which identifier identifies a particular endpoint of a particular DNCP node. The value 0 is reserved for DNCP and DNCP-based protocol purposes and not used to identify an actual endpoint. This definition is in sync with the interface index definition in [RFC3493], as the non-zero small positive integers should comfortably fit within 32 bits.",
      "ja": "エンドポイント識別子は、特定のDNCPノードの特定のエンドポイントを識別する32ビットの不透明とローカルで一意の値、。値0はDNCPとDNCPベースのプロトコルのために予約され、実際のエンドポイントを識別するために使用されていません。この定義は、非ゼロの小さな正の整数で快適32ビット内に収まるべきであるように、[RFC3493]にインターフェースインデックス定義と同期しています。"
    },
    {
      "indent": 3,
      "text": "Peer another DNCP node with which a DNCP node communicates using at least one particular local and remote endpoint pair.",
      "ja": "DNCPノードは、少なくとも一つの特定のローカルおよびリモートエンドポイントのペアを使用して通信する別のDNCPノードをピア。"
    },
    {
      "indent": 3,
      "text": "Node data a set of TLVs published and owned by a node in the DNCP network. Other nodes pass it along as is, even if they cannot fully interpret it.",
      "ja": "ノードデータDNCPネットワーク内のノードから発行され、所有しているのTLVのセット。であるように、他のノードは、彼らは完全にそれを解釈できない場合でも、それに沿って渡します。"
    },
    {
      "indent": 3,
      "text": "Origination time the (estimated) time when the node data set with the current sequence number was published.",
      "ja": "発信時刻現在のシーケンス番号と設定されたノードのデータが公開された（推定）時間。"
    },
    {
      "indent": 3,
      "text": "Node state a set of metadata attributes for node data. It includes a sequence number for versioning, a hash value for comparing equality of stored node data, and a timestamp indicating the time passed since its last publication (i.e., since the origination time). The hash function and the length of the hash value are defined in the DNCP profile.",
      "ja": "ノードの状態は、メタデータのセットは、ノードデータの属性。それはバージョンのシーケンス番号、格納されたノードデータの同一性を比較するためのハッシュ値、及び（即ち、発信時から）その最後の出版からの経過時間を示すタイムスタンプを含みます。ハッシュ関数およびハッシュ値の長さはDNCPプロファイルに定義されています。"
    },
    {
      "indent": 3,
      "text": "Network state a hash value that represents the current state of hash the network. The hash function and the length of the hash value are defined in the DNCP profile. Whenever a node is added, removed, or updates its published node data, this hash value changes as well. For calculation, please see Section 4.1.",
      "ja": "ネットワークは、ハッシュの現在の状態のネットワークを表すハッシュ値を述べます。ハッシュ関数およびハッシュ値の長さはDNCPプロファイルに定義されています。ノードが追加されるたびに、削除、または同様の公表ノードデータ、このハッシュ値の変更を更新します。計算では、4.1節を参照してください。"
    },
    {
      "indent": 3,
      "text": "Trust verdict a statement about the trustworthiness of a certificate announced by a node participating in the certificate-based trust consensus mechanism.",
      "ja": "トラスト判決証明書ベースの信頼コンセンサスメカニズムに参加するノードによって発表された証明書の信頼性についての声明。"
    },
    {
      "indent": 3,
      "text": "Effective trust the trust verdict with the highest priority within verdict the set of trust verdicts announced for the certificate in the DNCP network.",
      "ja": "判決の中で一番高い優先度DNCPネットワーク内の証明書の発表された信頼評決のセットで効果的な信頼関係の信頼評決。"
    },
    {
      "indent": 3,
      "text": "Topology graph the undirected graph of DNCP nodes produced by retaining only bidirectional peer relationships between nodes.",
      "ja": "ノード間の唯一の双方向のピア関係を保持することにより生成DNCPノードの無向グラフグラフトポロジー。"
    },
    {
      "indent": 3,
      "text": "Bidirectionally a peer is locally unidirectionally reachable if a reachable consistent multicast or any unicast DNCP message has been received by the local node (see Section 4.5). If said peer in return also considers the local node unidirectionally reachable, then bidirectionally reachability is established. As this process is based on publishing peer relationships and evaluating the resulting topology graph as described in Section 4.6, this information is available to the whole DNCP network.",
      "ja": "到達可能な一貫したマルチキャストまたはユニキャストDNCPメッセージがローカルノードによって受信された場合に双方向ピアが局所的に一方向に到達可能である（4.5節を参照）。リターンにおける前記ピアは、ローカルノードが一方向に到達可能と見なした場合、双方向到達可能性が確立されます。このプロセスは、ピア関係を公開し、セクション4.6に記載したように得られたトポロジーグラフを評価することに基づいているように、この情報は、全体DNCPネットワークに利用可能です。"
    },
    {
      "indent": 3,
      "text": "Trickle instance a distinct Trickle [RFC6206] algorithm state kept by a node (Section 5) and related to an endpoint or a particular (peer, endpoint) tuple with Trickle variables I, t, and c. See Section 4.3.",
      "ja": "インスタンスを別個トリクル[RFC6206]アルゴリズムの状態ノード（セクション5）によって保持され、エンドポイントまたはトリクル変数I、T、およびCを有する特定の（ピアエンドポイント）タプルに関連トリクル。 4.3節を参照してください。"
    },
    {
      "indent": 0,
      "text": "2.1. Requirements Language",
      "section_title": true,
      "ja": "2.1. 要件言語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [RFC2119].",
      "ja": "キーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、 \"SHALL\"、 \"SHOULD\"、 \"ないもの\"、 \"推奨\" \"ない（SHOULD NOT）\"、 \"MAY\"、 \"推奨NOT\"、および「OPTIONAL RFC 2119 [RFC2119]に記載されているように「この文書に解釈されるべきです。"
    },
    {
      "indent": 0,
      "text": "3. Overview",
      "section_title": true,
      "ja": "3.概要"
    },
    {
      "indent": 3,
      "text": "DNCP operates primarily using unicast exchanges between nodes, and it may use multicast for Trickle-based shared state dissemination and topology discovery. If used in pure unicast mode with unreliable transport, Trickle is also used between peers.",
      "ja": "DNCPは、主に、ノード間のユニキャストの交換を使用して動作し、それはトリクルベースの共有状態の普及とトポロジー発見のためにマルチキャストを使用することができます。信頼性の低いトランスポートを持つ純粋なユニキャストモードで使用する場合は、トリクルもピア間で使用されています。"
    },
    {
      "indent": 3,
      "text": "DNCP is based on exchanging TLVs (Section 7) and defines a set of mandatory and optional ones for its operation. They are categorized into TLVs for requesting information (Section 7.1), transmitting data (Section 7.2), and being published as data (Section 7.3). DNCP-based protocols usually specify additional ones to extend the capabilities.",
      "ja": "DNCPはのTLV（セクション7）の交換に基づいており、その動作のために必須と任意のもののセットを定義しています。彼らは（7.2節）データを送信し、（7.1節）の情報を要求するためのTLVに分類され、データ（7.3節）として公開されています。 DNCPベースのプロトコルは、通常、機能を拡張するための追加のものを指定します。"
    },
    {
      "indent": 3,
      "text": "DNCP discovers the topology of the nodes in the DNCP network and maintains the liveliness of published node data by ensuring that the publishing node is bidirectionally reachable. New potential peers can be discovered autonomously on multicast-enabled links; their addresses may be manually configured or they may be found by some other means defined in the particular DNCP profile. The DNCP profile may specify, for example, a well-known anycast address or provision the remote address to contact via some other protocol such as DHCPv6 [RFC3315].",
      "ja": "DNCPはDNCPネットワークにおけるノードのトポロジーを検出し、公開ノードが双方向に到達可能であることを保証することにより公表ノードデータの活気を維持します。新しい潜在的なピアは、マルチキャスト対応のリンクを自律的に発見することができます。それらのアドレスは、手動で設定してもよく、またはそれらは特定のDNCPプロファイルで定義されたいくつかの他の手段によって求めることができます。 DNCPプロファイルは、例えば、よく知られているエニーキャストアドレスまたは提供そのようなDHCPv6の[RFC3315]などのいくつかの他のプロトコルを介して接触するリモートアドレスを指定することができます。"
    },
    {
      "indent": 3,
      "text": "A hash tree of height 1, rooted in itself, is maintained by each node to represent the state of all currently reachable nodes (see Section 4.1), and the Trickle algorithm is used to trigger synchronization (see Section 4.3). The need to check peer nodes for state changes is thereby determined by comparing the current root of their respective hash trees, i.e., their individually calculated network state hashes.",
      "ja": "（4.3節を参照のこと）自体に根ざした高さ1のハッシュツリーは、すべての現在到達可能なノード（節4.1を参照）の状態を表すために、各ノードによって維持され、トリクルアルゴリズムは、同期をトリガするために使用されます。状態の変化のために、ピア・ノードをチェックする必要があり、それによって、すなわち、それらの個々に算出ネットワーク状態ハッシュをそれぞれのハッシュツリーの現在のルートを比較することによって決定されます。"
    },
    {
      "indent": 3,
      "text": "Before joining a DNCP network, a node starts with a hash tree that has only one leaf if the node publishes some TLVs, and no leaves otherwise. It then announces the network state hash calculated from the hash tree by means of the Trickle algorithm on all its configured endpoints.",
      "ja": "DNCPネットワークに参加する前に、ノードは、ノードがいくつかTLVを発行した場合にのみ、1つのリーフを持つハッシュツリーで始まりませんし、何がそうでない場合は残します。それは、そのすべての構成されたエンドポイント上のトリクルアルゴリズムによってハッシュツリーから算出したネットワーク状態のハッシュを発表しました。"
    },
    {
      "indent": 3,
      "text": "When an update is detected by a node (e.g., by receiving a different network state hash from a peer), the originator of the event is requested to provide a list of the state of all nodes, i.e., all the information it uses to calculate its own hash tree. The node uses the list to determine whether its own information is outdated and -- if necessary -- requests the actual node data that has changed.",
      "ja": "更新は、（ピアから別のネットワーク状態のハッシュを受信することにより、例えば）ノードによって検出された場合、イベントの発信元は、すべてのノードの状態のリストを提供するように要求され、すなわち、それは計算に使用するすべての情報独自のハッシュツリー。必要に応じて -   - 変更された実際のノードのデータを要求するノードは、自身の情報が古くなっているか否かを判断するためにリストを使用します。"
    },
    {
      "indent": 3,
      "text": "Whenever a node's local copy of any node data and its hash tree are updated (e.g., due to its own or another node's node state changing or due to a peer being added or removed), its Trickle instances are reset, which eventually causes any update to be propagated to all of its peers.",
      "ja": "任意のノードデータのノードのローカルコピーとそのハッシュツリーは、（追加または削除されているため、ピアに自身の、または別のノードのノード状態が変化したりするなど、原因）が更新されるたびに、そのトリクルインスタンスは、最終的にすべての更新を引き起こす、リセットされすべてのピアに伝播します。"
    },
    {
      "indent": 0,
      "text": "4. Operation",
      "section_title": true,
      "ja": "4.操作"
    },
    {
      "indent": 0,
      "text": "4.1. Hash Tree",
      "section_title": true,
      "ja": "4.1. ハッシュツリー"
    },
    {
      "indent": 3,
      "text": "Each DNCP node maintains an arbitrary width hash tree of height 1. The root of the tree represents the overall network state hash and is used to determine whether the view of the network of two or more nodes is consistent and shared. Each leaf represents one bidirectionally reachable DNCP node. Every time a node is added or removed from the topology graph (Section 4.6), it is likewise added or removed as a leaf. At any time, the leaves of the tree are ordered in ascending order of the node identifiers of the nodes they represent.",
      "ja": "各DNCPノードは、ツリーのルート1高さの任意の幅ハッシュツリーはネットワーク全体の状態ハッシュを表し、二つ以上のノードのネットワークのビューが一貫して共有されているかどうかを決定するために使用されている維持します。各リーフは1双方向到達可能DNCPノードを表します。ノードは、トポロジーグラフ（セクション4.6）から追加または削除されるたびに、それは、同様に追加またはリーフとして除去されます。いつでも、ツリーの葉は、それらが表すノードのノード識別子の昇順に並べられています。"
    },
    {
      "indent": 0,
      "text": "4.1.1. Calculating Network State and Node Data Hashes",
      "section_title": true,
      "ja": "4.1.1. ネットワークの状態やノードデータのハッシュを計算します"
    },
    {
      "indent": 3,
      "text": "The network state hash and the node data hashes are calculated using the hash function defined in the DNCP profile (Section 9) and truncated to the number of bits specified therein.",
      "ja": "ネットワーク状態ハッシュ及びノードデータハッシュは、ハッシュ関数DNCPプロファイル（セクション9）で定義され、その中指定されたビットの数に切り捨てを使用して計算されます。"
    },
    {
      "indent": 3,
      "text": "Individual node data hashes are calculated by applying the function and truncation on the respective node's node data as published in the Node State TLV. Such node data sets are always ordered as defined in Section 7.2.3.",
      "ja": "個々のノードのデータのハッシュは、ノードの状態TLVに発表されたように、それぞれのノードのノードデータ上の機能と切り捨てを適用して計算されています。 7.2.3項で定義されるようなノードデータセットは常に順序付けられています。"
    },
    {
      "indent": 3,
      "text": "The network state hash is calculated by applying the function and truncation on the concatenated network state. This state is formed by first concatenating each node's sequence number (in network byte order) with its node data hash to form a per-node datum for each node. These per-node data are then concatenated in ascending order of the respective node's node identifier, i.e., in the order that the nodes appear in the hash tree.",
      "ja": "ネットワーク状態ハッシュは、連結ネットワーク状態に機能し、切り捨てを適用することによって計算されます。この状態は、最初、各ノードごとのノードのデータを形成するために、そのノードデータハッシュと（ネットワークバイト順で）各ノードのシーケンス番号を連結することによって形成されています。これらの単位のノードデータは、ノードは、ハッシュツリーに表示される順序で、各ノードのノード識別子、すなわちの昇順に連結されています。"
    },
    {
      "indent": 0,
      "text": "4.1.2. Updating Network State and Node Data Hashes",
      "section_title": true,
      "ja": "4.1.2. ネットワークの状態やノードデータのハッシュを更新"
    },
    {
      "indent": 3,
      "text": "The network state hash and the node data hashes are updated on-demand and whenever any locally stored per-node state changes. This includes local unidirectional reachability encoded in the published Peer TLVs (Section 7.3.1) and -- when combined with remote data -- results in awareness of bidirectional reachability changes.",
      "ja": "ネットワーク状態ハッシュ及びノードデータハッシュは、オンデマンド更新されるたび任意のローカルに格納されたノードごとの状態が変化しています。リモート・データと組み合わさ -   - 双方向の可到達性の変化の意識の結果これは、公開されたピアのTLV（セクション7.3.1）とで符号化されたローカル一方向の到達可能性を含みます。"
    },
    {
      "indent": 0,
      "text": "4.2. Data Transport",
      "section_title": true,
      "ja": "4.2. 発送日"
    },
    {
      "indent": 3,
      "text": "DNCP has few requirements for the underlying transport; it requires some way of transmitting either a unicast datagram or stream data to a peer and, if used in multicast mode, a way of sending multicast datagrams. As multicast is used only to identify potential new DNCP nodes and to send status messages that merely notify that a unicast exchange should be triggered, the multicast transport does not have to be secured. If unicast security is desired and one of the built-in security methods is to be used, support for some TLS-derived transport scheme -- such as TLS [RFC5246] on top of TCP or DTLS [RFC6347] on top of UDP -- is also required. They provide for integrity protection and confidentiality of the node data, as well as authentication and authorization using the schemes defined in \"Security and Trust Management\" (Section 8). A specific definition of the transport(s) in use and its parameters MUST be provided by the DNCP profile.",
      "ja": "DNCPは、基礎となるトランスポートのためのいくつかの要件があります。それはピアにユニキャストデータグラムまたはストリームのいずれかのデータを送信するいくつかの方法を必要とし、マルチキャストモードで使用される場合、マルチキャストデータグラムを送信する方法。マルチキャストは、潜在的な新しいDNCPノードを識別するために、単にユニキャスト交換がトリガされる必要があることを知らせるステータスメッセージを送信するためにのみ使用されるので、マルチキャスト輸送を確保する必要はありません。ユニキャストセキュリティは、所望と内蔵のセキュリティ方法の一つは、いくつかのTLS由来の輸送方式のサポートに使用されるべきである場合 -   - 例えばTLS TCPまたはDTLSの上に[RFC5246]、[RFC6347] UDPの上などを必要です。彼らは、「セキュリティと信頼の管理」（第8節）で定義された方式を使用して完全性保護と機密保持ノードデータのと同様に、認証および承認を提供します。使用中のトランスポート（S）とそのパラメータの具体的な定義はDNCPプロファイルによって提供されなければなりません。"
    },
    {
      "indent": 3,
      "text": "TLVs (Section 7) are sent across the transport as is, and they SHOULD be sent together where, e.g., MTU considerations do not recommend sending them in multiple batches. DNCP does not fragment or reassemble TLVs; thus, it MUST be ensured that the underlying transport performs these operations should they be necessary. If this document indicates sending one or more TLVs, then the sending node does not need to keep track of the packets sent after handing them over to the respective transport, i.e., reliable DNCP operation is ensured merely by the explicitly defined timers and state machines such as Trickle (Section 4.3). TLVs in general are handled individually and statelessly (and thus do not need to be sent in any particular order) with one exception: To form bidirectional peer relationships, DNCP requires identification of the endpoints used for communication. As bidirectional peer relationships are required for validating liveliness of published node data as described in Section 4.6, a DNCP node MUST send a Node Endpoint TLV (Section 7.2.1). When it is sent varies, depending on the underlying transport, but conceptually it should be available whenever processing a Network State TLV:",
      "ja": "TLV（第7節）があるとして、トランスポート経由で送信され、そして、彼らはどこ一緒に送ってください、例えば、MTUの考慮事項は、複数のバッチでそれらを送信することはお勧めしません。 DNCPはTLVを断片化または再組み立てしません。従って、基本的な輸送は、彼らが必要であるべきで、これらの動作を行うことを保証しなければなりません。この文書は、一つ以上のTLVを送信して示している場合は、送信ノードは、それぞれの輸送にそれらを引き渡した後、送信されたパケットを追跡する必要はありません、すなわち、信頼性の高いDNCP操作は明示的に定義されたタイマーと、このようなステートマシンだけで確保されていますトリクルとして（4.3節）。 TLVは、一般的に個々にステートレスに処理される（したがって、任意の特定の順序で送信する必要がない）一つの例外を除いて双方向ピア関係を形成するために、DNCPは、通信に使用するエンドポイントの識別を必要とします。双方向ピア関係は、セクション4.6で説明したように公開されたノードデータの生存性を検証するために必要とされるように、DNCPのノードはエンドポイントTLV（7.2.1）を送信しなければなりません。それが送信されると、基礎となるトランスポートによって異なりますが、ネットワークの状態TLVを処理するたびに、概念的にそれが利用可能であるべきです："
    },
    {
      "indent": 3,
      "text": "o If using a stream transport, the TLV MUST be sent at least once per connection but SHOULD NOT be sent more than once.",
      "ja": "Oストリームトランスポートを使用している場合、TLVは、接続ごとに少なくとも一度送らなければなりませんが、複数回送るべきではありません。"
    },
    {
      "indent": 3,
      "text": "o If using a datagram transport, it MUST be included in every datagram that also contains a Network State TLV (Section 7.2.2) and MUST be located before any such TLV. It SHOULD also be included in any other datagram to speed up initial peer detection.",
      "ja": "Oデータグラムトランスポートを使用している場合、それはまた、ネットワークの状態TLV（7.2.2）を含み、そのようなTLVの前に置かれている必要があり、すべてのデータグラムに含まれなければなりません。また、初期ピア検出をスピードアップするために、他のデータグラムに含まれるべきです。"
    },
    {
      "indent": 3,
      "text": "Given the assorted transport options as well as potential endpoint configuration, a DNCP endpoint may be used in various transport modes:",
      "ja": "各種輸送オプション、並びに潜在的エンドポイント構成を考慮すると、DNCPエンドポイントは、様々な輸送モードで使用することができます。"
    },
    {
      "indent": 3,
      "text": "Unicast:",
      "ja": "ユニキャスト："
    },
    {
      "indent": 6,
      "text": "* If only reliable unicast transport is used, Trickle is not used at all. Whenever the locally calculated network state hash changes, a single Network State TLV (Section 7.2.2) is sent to every unicast peer. Additionally, recently changed Node State TLVs (Section 7.2.3) MAY be included.",
      "ja": "唯一の信頼できるユニキャストトランスポートが使用されている場合は*、トリクルは一切使用しておりません。たびにローカルで計算ネットワーク状態ハッシュ変更、単一のネットワーク状態TLV（7.2.2項）は、すべてのユニキャストピアに送信されます。また、最近、ノード状態のTLV（7.2.3）が含まれるかもしれ変更。"
    },
    {
      "indent": 6,
      "text": "* If only unreliable unicast transport is used, Trickle state is kept per peer, and it is used to send Network State TLVs intermittently, as specified in Section 4.3.",
      "ja": "*唯一の信頼性のないユニキャストトランスポートが使用されている場合は、トリクル状態は、ピアごとに維持され、4.3節で指定されたとして、断続的にネットワークの状態TLVを送信するために使用されます。"
    },
    {
      "indent": 3,
      "text": "Multicast+Unicast: If multicast datagram transport is available on an endpoint, Trickle state is only maintained for the endpoint as a whole. It is used to send Network State TLVs periodically, as specified in Section 4.3. Additionally, per-endpoint keep-alives MAY be defined in the DNCP profile, as specified in Section 6.1.2.",
      "ja": "マルチキャスト+ユニキャスト：マルチキャストデータグラムトランスポートエンドポイントで利用可能である場合、状態をトリクルだけ全体としてのエンドポイントのために維持されます。 4.3節で指定されているように、定期的にネットワークの状態TLVを送信するために使用されます。 6.1.2項で指定されているように加え、当たりのエンドポイントキープアライブは、DNCPプロファイル内で定義することができます。"
    },
    {
      "indent": 3,
      "text": "MulticastListen+Unicast: Just like unicast, except multicast transmissions are listened to in order to detect changes of the highest node identifier. This mode is used only if the DNCP profile supports dense multicast-enabled link optimization (Section 6.2).",
      "ja": "MulticastListen +ユニキャスト：ちょうどマルチキャスト伝送が最高のノード識別子の変化を検出するために、耳を傾けている以外、ユニキャストのように。このモードはDNCPプロファイルが密集マルチキャスト対応リンクの最適化（6.2節）をサポートしている場合にのみ使用されます。"
    },
    {
      "indent": 0,
      "text": "4.3. Trickle-Driven Status Updates",
      "section_title": true,
      "ja": "4.3. トリクル・ドリブン・ステータスの更新"
    },
    {
      "indent": 3,
      "text": "The Trickle algorithm [RFC6206] is used to ensure protocol reliability over unreliable multicast or unicast transports. For reliable unicast transports, its actual algorithm is unnecessary and omitted (Section 4.2). DNCP maintains multiple Trickle states as defined in Section 5. Each such state can be based on different parameters (see below) and is responsible for ensuring that a specific peer or all peers on the respective endpoint are regularly provided with the node's current locally calculated network state hash for state comparison, i.e., to detect potential divergence in the perceived network state.",
      "ja": "トリクルアルゴリズム[RFC6206]は信頼できないマルチキャストまたはユニキャストトランスポートプロトコル上の信頼性を確保するために使用されます。信頼できるユニキャストトランスポートのために、その実際のアルゴリズムが不要と省略（セクション4.2）です。 DNCPは、このような各状態が異なるパラメータに基づくことができ、セクション5で定義されるように（下記参照）は、複数のトリクル状態を維持し、特定のピアまたは各エンドポイント上のすべてのピアを定期的にノードの現在のローカルで計算ネットワークを備えていることを保証する責任があります状態を比較するための状態ハッシュ、すなわち、認識されるネットワーク状態の潜在的な相違を検出します。"
    },
    {
      "indent": 3,
      "text": "Trickle defines 3 parameters: Imin, Imax, and k. Imin and Imax represent the minimum value for I and the maximum number of doublings of Imin, where I is the time interval during which at least k Trickle updates must be seen on an endpoint to prevent local state transmission. The actual suggested Trickle algorithm parameters are DNCP profile specific, as described in Section 9.",
      "ja": "Iminを、Imaxを、そしてK：トリクルは、3つのパラメータを定義します。 IMINとImaxがIの最小値およびIは、少なくともk個のトリクル更新がローカル状態の透過を防止するために、エンドポイント上で見なければならない時間間隔であるIMINの倍加の最大数を表します。セクション9に記載されているように、実際の提案トリクルアルゴリズムパラメータは、DNCPプロファイルに特異的です。"
    },
    {
      "indent": 3,
      "text": "The Trickle state for all Trickle instances defined in Section 5 is considered inconsistent and reset if and only if the locally calculated network state hash changes. This occurs either due to a change in the local node's own node data or due to the receipt of more recent data from another node as explained in Section 4.1. A node MUST NOT reset its Trickle state merely based on receiving a Network State TLV (Section 7.2.2) with a network state hash that is different from its locally calculated one.",
      "ja": "セクション5で定義されているすべてのトリクルインスタンスのトリクル状態が矛盾とみなされた場合にリセットされ、局所的にのみ算出ネットワーク状態ハッシュが変更された場合。 4.1節で説明したようにこれは、ローカル・ノードの自ノードデータの変更や原因別のノードからのより多くの最近のデータの受信のいずれかに発生します。ノードは単にそのローカルで計算とは異なるネットワーク状態ハッシュとネットワーク状態TLV（7.2.2項）を受信に基づいてトリクル状態をリセットしてはいけません。"
    },
    {
      "indent": 3,
      "text": "Every time a particular Trickle instance indicates that an update should be sent, the node MUST send a Network State TLV (Section 7.2.2) if and only if:",
      "ja": "特定のトリクルインスタンスは更新が送られるべきであることを示しているたびに、ノードは、ネットワークの状態TLV（7.2.2）の場合に限りを送らなければなりません。"
    },
    {
      "indent": 3,
      "text": "o the endpoint is in Multicast+Unicast transport mode, in which case the TLV MUST be sent over multicast.",
      "ja": "Oエンドポイントは、TLVがマルチキャストを介して送信されなければならない場合にマルチキャスト+ユニキャストトランスポートモードです。"
    },
    {
      "indent": 3,
      "text": "o the endpoint is NOT in Multicast+Unicast transport mode, and the unicast transport is unreliable, in which case the TLV MUST be sent over unicast.",
      "ja": "エンドポイントoをマルチキャスト+ユニキャストトランスポート・モードではない、およびユニキャスト輸送はTLVは、ユニキャストを介して送信されなければならない場合には、信頼性がありません。"
    },
    {
      "indent": 3,
      "text": "A (sub)set of all Node State TLVs (Section 7.2.3) MAY also be included, unless it is defined as undesirable for some reason by the DNCP profile or to avoid exposure of the node state TLVs by transmitting them within insecure multicast when using secure unicast.",
      "ja": "すべてのノードの状態のTLV（セクション7.2.3）の（サブ）セットは、それがDNCPプロファイルによって何らかの理由で望ましくないと定義されていない限り、また、含まれてもよく、または場合に安全でないマルチキャスト内でそれらを送信することによって、ノード状態のTLVの暴露を避けるために安全なユニキャストを使用しました。"
    },
    {
      "indent": 0,
      "text": "4.4. Processing of Received TLVs",
      "section_title": true,
      "ja": "4.4. 受信のTLVの処理"
    },
    {
      "indent": 3,
      "text": "This section describes how received TLVs are processed. The DNCP profile may specify when to ignore particular TLVs, e.g., to modify security properties -- see Section 9 for what may be safely defined to be ignored in a profile. Any 'reply' mentioned in the steps below denotes the sending of the specified TLV(s) to the originator of the TLV being processed. All such replies MUST be sent using unicast. If the TLV being replied to was received via multicast and it was sent to a multiple access link, the reply MUST be delayed by a random time span in [0, Imin/2], to avoid potential simultaneous replies that may cause problems on some links, unless specified differently in the DNCP profile. The sending of replies MAY also be rate limited or omitted for a short period of time by an implementation. However, if the TLV is not forbidden by the DNCP profile, an implementation MUST reply to retransmissions of the TLV with a non-zero probability to avoid starvation, which would break the state synchronization.",
      "ja": "このセクションでは、受信のTLVが処理される方法を説明します。特定のTLVを無視する場合DNCPプロファイルは、セキュリティプロパティを変更するために、例えば、指定することができる - 安全プロファイルに無視されるように定義することができるものについては、セクション9を参照されたいです。以下の手順に記載された任意の「応答」は、処理されるTLVの発信元に指定されたTLV（S）の送信を意味します。そのようなすべての返信がユニキャストを使用させなければなりません。 TLVは、マルチキャストを介して受信され、それが複数のアクセスリンクに送られた、応答がいくつかに問題を引き起こす可能性がある潜在的な同時応答を避けるために、[0、Iminを/ 2]内のランダムな時間間隔だけ遅延させなければならないに回答されている場合DNCPプロファイルで異なる指定がない限り、リンク、。応答の送信があってもよい率限定または実装によって短時間省略する。 TLVはDNCPプロファイルによって禁止されていない場合は、実装は、状態の同期を破る飢餓を避けるために非ゼロの確率でTLVの再送信に返答しなければなりません。"
    },
    {
      "indent": 3,
      "text": "A DNCP node MUST process TLVs received from any valid (e.g., correctly scoped) address, as specified by the DNCP profile and the configuration of a particular endpoint, whether this address is known to be the address of a peer or not. This provision satisfies the needs of monitoring or other host software that needs to discover the DNCP topology without adding to the state in the network.",
      "ja": "DNCPプロファイルおよび特定のエンドポイントの構成によって指定さDNCPノードのTLVは、任意の有効から受信処理しなければなりません。このアドレスはピアかのアドレスであることが知られているかどうかを、アドレス（例えば、正しくスコープ）。この規定は、監視やネットワーク状態を追加することなく、DNCPトポロジを検出する必要がある他のホストソフトウェアのニーズを満たします。"
    },
    {
      "indent": 3,
      "text": "Upon receipt of:",
      "ja": "を受信すると："
    },
    {
      "indent": 3,
      "text": "o Request Network State TLV (Section 7.1.1): The receiver MUST reply with a Network State TLV (Section 7.2.2) and a Node State TLV (Section 7.2.3) for each node data used to calculate the network state hash. The Node State TLVs SHOULD NOT contain the optional node data part to avoid redundant transmission of node data, unless explicitly specified in the DNCP profile.",
      "ja": "Oネットワーク状態TLV（セクション7.1.1）を要求：受信機は、ネットワーク状態のハッシュを計算するために使用される各ノードデータのネットワーク状態TLV（セクション7.2.2）とノード状態TLV（7.2.3）で応答しなければなりません。ノードの状態のTLVは、明示的にDNCPプロファイルに指定しない限り、ノードデータの冗長伝送を避けるために、オプションのノードデータの一部を含むべきではありません。"
    },
    {
      "indent": 3,
      "text": "o Request Node State TLV (Section 7.1.2): If the receiver has node data for the corresponding node, it MUST reply with a Node State TLV (Section 7.2.3) for the corresponding node. The optional node data part MUST be included in the TLV.",
      "ja": "O要求ノード状態TLV（セクション7.1.2）：受信機は、対応するノードのノードデータがある場合は、対応するノードのノード状態TLV（7.2.3）で応答しなければなりません。任意のノードのデータ部分は、TLVに含まれなければなりません。"
    },
    {
      "indent": 3,
      "text": "o Network State TLV (Section 7.2.2): If the network state hash differs from the locally calculated network state hash, and the receiver is unaware of any particular node state differences with the sender, the receiver MUST reply with a Request Network State TLV (Section 7.1.1). These replies MUST be rate limited to only at most one reply per link per unique network state hash within Imin. The simplest way to ensure this rate limit is a timestamp indicating requests and sending at most one Request Network State TLV (Section 7.1.1) per Imin. To facilitate faster state synchronization, if a Request Network State TLV is sent in a reply, a local, current Network State TLV MAY also be sent.",
      "ja": "Oネットワーク状態TLV（セクション7.2.2）：ネットワーク状態ハッシュをローカルで計算ネットワーク状態ハッシュとは異なり、受信者が送信者との任意の特定のノードの状態の違いを認識しない場合、受信機は、Requestネットワーク状態TLVで応答しなければなりません（7.1.1項）。これらの応答は、Iminの内で一意のネットワーク状態のハッシュごとのリンクあたりだけで、ほとんど1件の返信されないように制限されなければなりません。このレート制限を確保するための最も簡単な方法は、タイムスタンプ要求を示すとIminからにつき最大1つのリクエストネットワークの状態TLV（セクション7.1.1）を送ることです。リクエストネットワークの状態TLVは、応答で送信された場合、より高速な状態の同期化を容易にするために、ローカル、現在のネットワークの状態TLVも送るかもしれません。"
    },
    {
      "indent": 3,
      "text": "o Node State TLV (Section 7.2.3):",
      "ja": "Oノードの状態TLV（7.2.3）："
    },
    {
      "indent": 6,
      "text": "* If the node identifier matches the local node identifier and the TLV has a greater sequence number than its current local value, or the same sequence number and a different hash, the node SHOULD republish its own node data with a sequence number significantly greater than the received one (e.g., 1000) to reclaim the node identifier. This difference is needed in order to ensure that it is higher than any potentially lingering copies of the node state in the network. This may occur normally once due to the local node restarting and not storing the most recently used sequence number. If this occurs more than once or for nodes not republishing their own node data, the DNCP profile MUST provide guidance on how to handle these situations as it indicates the existence of another active node with the same node identifier.",
      "ja": "ノード識別子はローカルノード識別子と一致し、TLVは、その現在のローカル値よりも大きいシーケンス番号を有するか、または同じシーケンス番号と異なるハッシュ場合*、ノードはより有意に大きいシーケンス番号を自ノードのデータを再発行すべきですノード識別子を再利用するために、1つ（例えば、1000）を受けました。この差は、ネットワーク内のノードの状態の任意の潜在的に残るコピー以上であることを確実にするために必要とされます。これは、ローカル・ノードが再起動すると、最近使用したシーケンス番号を格納しないように、通常は一度発生する可能性があります。これは一度か、自分のノードのデータを再発行しませノードに対する以上発生した場合、それは同じノード識別子を持つ別のアクティブなノードの存在を示すよう、DNCPプロファイルは、これらの状況を処理する方法についてのガイダンスを提供しなければなりません。"
    },
    {
      "indent": 6,
      "text": "* If the node identifier does not match the local node identifier, and one or more of the following conditions are true:",
      "ja": "*ノード識別子は、ローカル・ノード識別子と一致していないし、次の条件の1つ以上が当てはまる場合："
    },
    {
      "indent": 9,
      "text": "+ The local information is outdated for the corresponding node (the local sequence number is less than that within the TLV).",
      "ja": "+ローカル情報は、（ローカルシーケンス番号はTLV内それ未満である）は、対応するノードの時代遅れです。"
    },
    {
      "indent": 9,
      "text": "+ The local information is potentially incorrect (the local sequence number matches but the node data hash differs).",
      "ja": "+ローカル情報が潜在的に間違っている（ローカルシーケンス番号は、ノード・データ・ハッシュが異なるが一致します）。"
    },
    {
      "indent": 9,
      "text": "+ There is no data for that node altogether.",
      "ja": "+完全にそのノードのデータがありません。"
    },
    {
      "indent": 9,
      "text": "Then:",
      "ja": "その後："
    },
    {
      "indent": 9,
      "text": "+ If the TLV contains the Node Data field, it SHOULD also be verified by ensuring that the locally calculated hash of the node data matches the content of the H(Node Data) field within the TLV. If they differ, the TLV SHOULD be ignored and not processed further.",
      "ja": "+ TLVは、ノード・データフィールドが含まれている場合、それはまた、ノードデータの局所的に計算されたハッシュは、TLV内H（ノードデータ）フィールドの内容と一致することを確実にすることによって検証されるべきです。それらが異なる場合は、TLVは無視され、さらに処理されてはいけません。"
    },
    {
      "indent": 9,
      "text": "+ If the TLV does not contain the Node Data field, and the H(Node Data) field within the TLV differs from the local node data hash for that node (or there is none), the receiver MUST reply with a Request Node State TLV (Section 7.1.2) for the corresponding node.",
      "ja": "TLVは、ノードデータフィールドが含まれていない、及びTLV内のH（ノードデータ）フィールドは、そのノードのローカルノードデータのハッシュは異なる（又はどれも存在しない）場合は+、受信機は、要求ノード状態TLVで応答しなければなりません対応するノードのために（セクション7.1.2）。"
    },
    {
      "indent": 9,
      "text": "+ Otherwise, the receiver MUST update its locally stored state for that node (node data based on the Node Data field if present, sequence number, and relative time) to match the received TLV.",
      "ja": "+そうでなければ、受信機は、受信されたTLVに一致するように（現在、シーケンス番号、及び相対時間あれば、ノードデータフィールドに基づいて、ノードデータ）そのノードに対してそのローカルに格納された状態を更新する必要があります。"
    },
    {
      "indent": 6,
      "text": "For comparison purposes of the sequence number, a looping comparison function MUST be used to avoid problems in case of overflow. The comparison function a < b <=> ((a - b) % (2^32)) & (2^31) != 0 where (a % b) represents the remainder of a modulo b and (a & b) represents bitwise conjunction of a and b is RECOMMENDED unless the DNCP profile defines another.",
      "ja": "シーケンス番号の比較のために、ループの比較関数は、オーバーフローの場合の問題を回避するために使用されなければなりません。比較関数<B <=>（（ -  B）％（2 ^ 32））・（2 ^ 31）=（％B）はモジュロBの残りを表し、0（A＆B）！ aとbのビット単位の論理積を表すDNCPプロファイルが別の定義がない限り推奨されています。"
    },
    {
      "indent": 3,
      "text": "o Any other TLV: TLVs not recognized by the receiver MUST be silently ignored unless they are sent within another TLV (for example, TLVs within the Node Data field of a Node State TLV). TLVs within the Node Data field of the Node State TLV not recognized by the receiver MUST be retained for distribution to other nodes and for calculation of the node data hash as described in Section 7.2.3 but are ignored for other purposes.",
      "ja": "O任意の他のTLV：のTLVは、それらが別のTLV内で送信されない限り、無視されなければならない受信機によって認識されない（例えば、TLVのノード状態TLVのノードデータフィールド内）。 7.2.3項で説明さが、他の目的のために無視されるように、受信機によって認識されないノード状態TLVのノードデータフィールド内のTLVは、他のノードに配布するために、ノード・データ・ハッシュの計算のために保持しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If secure unicast transport is configured for an endpoint, any Node State TLVs received over insecure multicast MUST be silently ignored.",
      "ja": "安全なユニキャストトランスポートがエンドポイントに設定されている場合、任意のノード状態のTLVを無視しなければならない安全でないマルチキャストを介して受信しました。"
    },
    {
      "indent": 0,
      "text": "4.5. Discovering, Adding, and Removing Peers",
      "section_title": true,
      "ja": "4.5. ピアを、発見の追加、および削除"
    },
    {
      "indent": 3,
      "text": "Peer relations are established between neighbors using one or more mutually connected endpoints. Such neighbors exchange information about network state and published data directly, and through transitivity, this information then propagates throughout the network.",
      "ja": "ピア関係は、一つ以上の相互接続されたエンドポイントを使用してネイバー間で確立されています。このような隣人は、ネットワークの状態についての情報を交換して直接データを公表し、推移性により、この情報は、ネットワーク全体に伝播します。"
    },
    {
      "indent": 3,
      "text": "New peers are discovered using the regular unicast or multicast transport defined in the DNCP profile (Section 9). This process is not distinguished from peer addition, i.e., an unknown peer is simply discovered by receiving regular DNCP protocol TLVs from it, and dedicated discovery messages or TLVs do not exist. For unicast-only transports, the individual node's transport addresses are preconfigured or obtained using an external service discovery protocol. In the presence of a multicast transport, messages from unknown peers are handled in the same way as multicast messages from peers that are already known; thus, new peers are simply discovered when sending their regular DNCP protocol TLVs using multicast.",
      "ja": "新しいピアはDNCPプロファイル（セクション9）で定義された正規のユニキャストまたはマルチキャストトランスポートを使用して発見されます。このプロセスは、ピア加え区別しないで、すなわち、未知のピアは単にそれから、通常のDNCPプロトコルTLVを受信することによって発見され、専用のディスカバリメッセージまたはTLVが存在しません。ユニキャストのみのトランスポートのために、個々のノードのトランスポート・アドレスは、事前設定された、または外部サービス発見プロトコルを使用して得られます。マルチキャスト輸送の存在下で、未知のピアからのメッセージは、既に知られているピアからのマルチキャストメッセージと同じ方法で処理されます。マルチキャストを使用して、通常のDNCPプロトコルTLVを送信するときにこのように、新しい仲間が単に発見されています。"
    },
    {
      "indent": 3,
      "text": "When receiving a Node Endpoint TLV (Section 7.2.1) on an endpoint from an unknown peer:",
      "ja": "未知のピアからエンドポイントにノードエンドポイントTLV（7.2.1）を受信した場合："
    },
    {
      "indent": 3,
      "text": "o If received over unicast, the remote node MUST be added as a peer on the endpoint, and a Peer TLV (Section 7.3.1) MUST be created for it.",
      "ja": "ユニキャストを介して受信した場合、O、リモートノードは、エンドポイント上のピア、及びそれを作成する必要がありピアTLV（セクション7.3.1）として追加する必要があります。"
    },
    {
      "indent": 3,
      "text": "o If received over multicast, the node MAY be sent a (possibly rate-limited) unicast Request Network State TLV (Section 7.1.1).",
      "ja": "マルチキャストを介して受信した場合、O、ノードが（おそらくは速度制限）ユニキャスト・リクエストネットワーク状態TLV（セクション7.1.1）送ってもよいです。"
    },
    {
      "indent": 3,
      "text": "If keep-alives specified in Section 6.1 are NOT sent by the peer (either the DNCP profile does not specify the use of keep-alives or the particular peer chooses not to send keep-alives), some other existing local transport-specific means (such as Ethernet carrier detection or TCP keep-alive) MUST be used to ensure its presence. If the peer does not send keep-alives, and no means to verify presence of the peer are available, the peer MUST be considered no longer present, and it SHOULD NOT be added back as a peer until it starts sending keep-alives again. When the peer is no longer present, the Peer TLV and the local DNCP peer state MUST be removed. DNCP does not define an explicit message or TLV for indicating the termination of DNCP operation by the terminating node; however, a derived protocol could specify an extension, if the need arises.",
      "ja": "6.1節で指定されたキープアライブは、ピアによって送信されない場合（DNCPプロファイルはキープアライブの使用を指定していないか、または特定のピアがキープアライブを送信しないことを選択したいずれか）、他のいくつかの既存のローカルトランスポート固有の手段（イーサネットキャリア検出やTCPキープアライブ）としてその存在を確実にするために使用されなければなりません。ピアの存在を確認するために、キープアライブ、および決してを送信しないピアが利用可能な場合、ピアはもはや存在とみなされてはならない、そしてそれが再びキープアライブの送信を開始するまでには、ピアとして戻って追加しないでください。ピアがもはや存在している場合、ピアTLV及びローカルDNCPピア状態が除去されてはなりません。 DNCPは、終端ノードによってDNCP動作の終了を示すための明示的なメッセージまたはTLVを定義しません。必要が生じた場合は、派生したプロトコルは、拡張子を指定することもできます。"
    },
    {
      "indent": 3,
      "text": "If the local endpoint is in the Multicast-Listen+Unicast transport mode, a Peer TLV (Section 7.3.1) MUST NOT be published for the peers not having the highest node identifier.",
      "ja": "ローカルエンドポイントがマルチキャスト聞く+ユニキャスト転送モードになっている場合は、ピアTLV（7.3.1）は、最も高いノード識別子を持っていないピアのために公開してはなりません。"
    },
    {
      "indent": 0,
      "text": "4.6. Data Liveliness Validation",
      "section_title": true,
      "ja": "4.6. データにぎわいの検証"
    },
    {
      "indent": 3,
      "text": "Maintenance of the hash tree (Section 4.1) and thereby network state hash updates depend on up-to-date information on bidirectional node reachability derived from the contents of a topology graph. This graph changes whenever nodes are added to or removed from the network or when bidirectional connectivity between existing nodes is established or lost. Therefore, the graph MUST be updated either immediately or with a small delay shorter than the DNCP profile-defined Trickle Imin whenever:",
      "ja": "ハッシュツリー（セクション4.1）、それによってネットワーク状態ハッシュ更新の維持は、トポロジーグラフの内容に由来する、双方向ノードの到達可能性に関する最新の情報に依存します。ノードが追加またはネットワーク場合や既存のノード間の双方向接続が確立されるか失われるから除去されるたびに、このグラフは、変化します。したがって、グラフは、直ちにまたはDNCPプロファイル定義トリクルIminをいつでもより短い小さな遅延で更新する必要があります。"
    },
    {
      "indent": 3,
      "text": "o A Peer TLV or a whole node is added or removed, or",
      "ja": "ピアTLVまたは全ノードが追加または削除されている、O、又は"
    },
    {
      "indent": 3,
      "text": "o The origination time (in milliseconds) of some node's node data is less than current time - 2^32 + 2^15.",
      "ja": "2 ^ 32 + 2 ^ 15  -  O一部のノードのノードデータの（ミリ秒単位）発信時刻が現在時刻よりも小さいです。"
    },
    {
      "indent": 3,
      "text": "The artificial upper limit for the origination time is used to gracefully avoid overflows of the origination time and allow for the node to republish its data as noted in Section 7.2.3.",
      "ja": "発信時間の人工上限は、正常に発信時間のオーバーフローを回避し、7.2.3項で述べたように、そのデータを公開するノードを可能にするために使用されます。"
    },
    {
      "indent": 3,
      "text": "The topology graph update starts with the local node marked as reachable and all other nodes marked as unreachable. Other nodes are then iteratively marked as reachable using the following algorithm: A candidate not-yet-reachable node N with an endpoint NE is marked as reachable if there is a reachable node R with an endpoint RE that meets all of the following criteria:",
      "ja": "トポロジ・グラフの更新が到達可能マークされたローカル・ノードで始まり、他のすべてのノードが到達不能としてマークされました。次の基準のすべてを満たしているエンドポイントREと到達可能なノードRが存在する場合のように到達可能とマークされたエンドポイントNEと候補まだ到達できないノードN：他のノードは、次に、繰り返し次のアルゴリズムを使用して到達可能マークされています。"
    },
    {
      "indent": 3,
      "text": "o The origination time (in milliseconds) of R's node data is greater than current time - 2^32 + 2^15.",
      "ja": "2 ^ 32 + 2 ^ 15  -  O Rのノードデータの（ミリ秒単位）発信時刻が現在時刻よりも大きいです。"
    },
    {
      "indent": 3,
      "text": "o R publishes a Peer TLV with:",
      "ja": "O Rは、ピアTLVとをパブリッシュします。"
    },
    {
      "indent": 6,
      "text": "* Peer Node Identifier = N's node identifier",
      "ja": "*ピアノード識別子= Nのノード識別子"
    },
    {
      "indent": 6,
      "text": "* Peer Endpoint Identifier = NE's endpoint identifier",
      "ja": "*ピアエンドポイント識別子= NEのエンドポイント識別子"
    },
    {
      "indent": 6,
      "text": "* Endpoint Identifier = RE's endpoint identifier",
      "ja": "*エンドポイント識別子= REのエンドポイント識別子"
    },
    {
      "indent": 3,
      "text": "o N publishes a Peer TLV with:",
      "ja": "O Nは、ピアTLVとをパブリッシュします。"
    },
    {
      "indent": 6,
      "text": "* Peer Node Identifier = R's node identifier",
      "ja": "*ピアノード識別子= Rのノード識別子"
    },
    {
      "indent": 6,
      "text": "* Peer Endpoint Identifier = RE's endpoint identifier",
      "ja": "*ピアエンドポイント識別子= REのエンドポイント識別子"
    },
    {
      "indent": 6,
      "text": "* Endpoint Identifier = NE's endpoint identifier",
      "ja": "*エンドポイント識別子= NEのエンドポイント識別子"
    },
    {
      "indent": 3,
      "text": "The algorithm terminates when no more candidate nodes fulfilling these criteria can be found.",
      "ja": "これらの基準を満たす、それ以上の候補ノードが見つからないときアルゴリズムは終了します。"
    },
    {
      "indent": 3,
      "text": "DNCP nodes that have not been reachable in the most recent topology graph traversal MUST NOT be used for calculation of the network state hash, be provided to any applications that need to use the whole TLV graph, or be provided to remote nodes. They MAY be forgotten immediately after the topology graph traversal; however, it is RECOMMENDED to keep them at least briefly to improve the speed of DNCP network state convergence. This reduces the number of queries needed to reconverge during both initial network convergence and when a part of the network loses and regains bidirectional connectivity within that time period.",
      "ja": "最新のトポロジーグラフトラバーサルに到達できていないDNCPノードはネットワーク状態のハッシュの計算に使用してはいけません、全体TLVグラフを使用する必要があるすべてのアプリケーションに提供すること、またはリモート・ノードに提供されます。彼らはすぐにトポロジグラフトラバーサルの後に忘れられてもよく;しかし、DNCPネットワーク状態の収束速度を向上させるために、少なくとも簡単にそれらを維持することをお勧めします。これは、両方の初期ネットワークコンバージェンス中に再収束するために必要なクエリの数を削減し、ネットワークの一部が失われ、その期間内の双方向の接続性を回復するとき。"
    },
    {
      "indent": 0,
      "text": "5. Data Model",
      "section_title": true,
      "ja": "5.データモデル"
    },
    {
      "indent": 3,
      "text": "This section describes the local data structures a minimal implementation might use. This section is provided only as a convenience for the implementor. Some of the optional extensions (Section 6) describe additional data requirements, and some optional parts of the core protocol may also require more.",
      "ja": "このセクションでは、最小限の実装が使用する可能性がありますローカルのデータ構造を説明しています。このセクションでは、唯一の実装のための便宜のために提供されます。オプションの拡張（第6節）の一部は、追加のデータ要件を記述し、コアプロトコルのいくつかのオプションパーツも多くを必要とするかもしれません。"
    },
    {
      "indent": 3,
      "text": "A DNCP node has:",
      "ja": "DNCPノードがあります。"
    },
    {
      "indent": 3,
      "text": "o A data structure containing data about the most recently sent Request Network State TLVs (Section 7.1.1). The simplest option is keeping a timestamp of the most recent request (required to fulfill reply rate limiting specified in Section 4.4).",
      "ja": "O最近送られたリクエストのネットワーク状態のTLV（7.1.1項）に関するデータを含むデータ構造。最も簡単なオプションは、最新のリクエストのタイムスタンプを保っている（セクション4.4で指定された制限が返信率を満たすために必要）。"
    },
    {
      "indent": 3,
      "text": "A DNCP node has the following for every DNCP node in the DNCP network:",
      "ja": "DNCPノードはDNCPネットワーク内のすべてのDNCPノードに対して次があります。"
    },
    {
      "indent": 3,
      "text": "o Node identifier: the unique identifier of the node. The length, how it is produced, and how collisions are handled is up to the DNCP profile.",
      "ja": "Oノードの識別子：ノードの一意の識別子。それが生成され、どのように衝突の処理方法を長さは、DNCPプロファイルまでです。"
    },
    {
      "indent": 3,
      "text": "o Node data: the set of TLV tuples published by that particular node. As they are transmitted in a particular order (see Node State TLV (Section 7.2.3) for details), maintaining the order within the data structure here may be reasonable.",
      "ja": "Oノードのデータ：その特定のノードによって公開されTLVタプルのセット。それらは（詳細については、ノード状態TLV（7.2.3）を参照）、特定の順序で送信されるように、ここでデータ構造内の順序を維持することは合理的であってもよいです。"
    },
    {
      "indent": 3,
      "text": "o Latest sequence number: the 32-bit sequence number that is incremented any time the TLV set is published. The comparison function used to compare them is described in Section 4.4.",
      "ja": "O最新のシーケンス番号：TLVセットが公開されるたびにインクリメントされる32ビットのシーケンス番号。それらを比較する比較関数は、4.4節に記述されています。"
    },
    {
      "indent": 3,
      "text": "o Origination time: the (estimated) time when the current TLV set with the current sequence number was published. It is used to populate the Milliseconds Since Origination field in a Node State TLV (Section 7.2.3). Ideally, it also has millisecond accuracy.",
      "ja": "Oオリジ時間：現在のシーケンス番号と、現在のTLVセットが公開された（推定）の時間。ノードの状態TLV（7.2.3）でのオリジネーションフィールドからのミリ秒を移入するために使用されます。理想的には、それはまた、ミリ秒の精度を持っています。"
    },
    {
      "indent": 3,
      "text": "Additionally, a DNCP node has a set of endpoints for which DNCP is configured to be used. For each such endpoint, a node has:",
      "ja": "また、DNCPノードはDNCPが使用されるように構成されているエンドポイントのセットを有します。このような各エンドポイントのために、ノードがあります。"
    },
    {
      "indent": 3,
      "text": "o Endpoint identifier: the 32-bit opaque locally unique value identifying the endpoint within a node. It SHOULD NOT be reused immediately after an endpoint is disabled.",
      "ja": "Oエンドポイント識別子：ノード内のエンドポイントを識別する32ビットの不透明ローカルで一意の値。エンドポイントが無効にされた後、それはすぐに再利用されるべきではありません。"
    },
    {
      "indent": 3,
      "text": "o Trickle instance: the endpoint's Trickle instance with parameters I, T, and c (only on an endpoint in Multicast+Unicast transport mode).",
      "ja": "Oインスタンスをトリクル：パラメータI、T、及び（のみマルチキャスト+ユニキャストトランスポートモードでエンドポイントの）Cとエンドポイントのトリクルインスタンス。"
    },
    {
      "indent": 3,
      "text": "and one (or more) of the following:",
      "ja": "そして、次の1つ（またはそれ以上）："
    },
    {
      "indent": 3,
      "text": "o Interface: the assigned local network interface.",
      "ja": "Oインタフェース：割り当てられたローカルネットワークインタフェース。"
    },
    {
      "indent": 3,
      "text": "o Unicast address: the DNCP node it should connect with.",
      "ja": "Oユニキャストアドレス：それはと接続する必要がありDNCPノード。"
    },
    {
      "indent": 3,
      "text": "o Set of addresses: the DNCP nodes from which connections are accepted.",
      "ja": "接続が受け入れられるからDNCPノード：Oアドレスのセット。"
    },
    {
      "indent": 3,
      "text": "For each remote (peer, endpoint) pair detected on a local endpoint, a DNCP node has:",
      "ja": "ローカルエンドポイントで検出された各リモート（ピアエンドポイント）ペアについて、DNCPノードがあります。"
    },
    {
      "indent": 3,
      "text": "o Node identifier: the unique identifier of the peer.",
      "ja": "Oノードの識別子：ピアの一意の識別子。"
    },
    {
      "indent": 3,
      "text": "o Endpoint identifier: the unique endpoint identifier used by the peer.",
      "ja": "Oエンドポイント識別子：ピアによって使用される一意のエンドポイント識別子。"
    },
    {
      "indent": 3,
      "text": "o Peer address: the most recently used address of the peer (authenticated and authorized, if security is enabled).",
      "ja": "Oピアアドレス：ピアの最も最近使用されたアドレス（セキュリティが有効になっている場合、認証および承認）。"
    },
    {
      "indent": 3,
      "text": "o Trickle instance: the particular peer's Trickle instance with parameters I, T, and c (only on an endpoint in unicast mode, when using an unreliable unicast transport).",
      "ja": "（信頼性のないユニキャストトランスポートを使用する場合、ユニキャストモードでエンドポイントの）Iは、パラメータを使用してTを特定のピアのトリクルインスタンスを、そしてC：Oインスタンスをトリクル。"
    },
    {
      "indent": 0,
      "text": "6. Optional Extensions",
      "section_title": true,
      "ja": "6.オプションの拡張機能"
    },
    {
      "indent": 3,
      "text": "This section specifies extensions to the core protocol that a DNCP profile may specify to be used.",
      "ja": "このセクションでは、DNCPプロファイルが使用されることを指定することができるコアプロトコルへの拡張を指定します。"
    },
    {
      "indent": 0,
      "text": "6.1. Keep-Alives",
      "section_title": true,
      "ja": "6.1. キープアライブ"
    },
    {
      "indent": 3,
      "text": "While DNCP provides mechanisms for discovery and adding new peers on an endpoint (Section 4.5), as well as state change notifications, another mechanism may be needed to get rid of old, no longer valid peers if the transport or lower layers do not provide one as noted in Section 4.6.",
      "ja": "DNCPを発見するためのメカニズムを提供し、新しいエンドポイント（4.5節）の仲間だけでなく、状態の変更通知を追加する際の輸送や下位層が1つを提供しない場合は、別のメカニズムが古い、もはや有効なピアを取り除くために必要とすることができます4.6節で述べたように。"
    },
    {
      "indent": 3,
      "text": "If keep-alives are not specified in the DNCP profile, the rest of this subsection MUST be ignored.",
      "ja": "キープアライブがDNCPプロファイルに指定されていない場合は、このサブセクションの残りの部分は無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "A DNCP profile MAY specify either per-endpoint (sent using multicast to all DNCP nodes connected to a multicast-enabled link) or per-peer (sent using unicast to each peer individually) keep-alive support.",
      "ja": "DNCPプロファイルは、（個々のピアへのユニキャストを使用して送信される）エンドポイントごとに（マルチキャスト対応リンクに接続されたすべてのDNCPノードにマルチキャストを使用して送信）またはごとピアキープアライブのサポートをいずれかを指定するかもしれません。"
    },
    {
      "indent": 3,
      "text": "For every endpoint that a keep-alive is specified for in the DNCP profile, the endpoint-specific keep-alive interval MUST be maintained. By default, it is DNCP_KEEPALIVE_INTERVAL. If there is a local value that is preferred for that for any reason (configuration, energy conservation, media type, ...), it can be substituted instead. If a non-default keep-alive interval is used on any endpoint, a DNCP node MUST publish an appropriate Keep-Alive Interval TLV(s) (Section 7.3.2) within its node data.",
      "ja": "キープアライブがDNCPプロファイル内に指定​​されているすべてのエンドポイントの場合、エンドポイント固有のキープアライブ間隔を維持しなければなりません。デフォルトでは、DNCP_KEEPALIVE_INTERVALです。何らかの理由（設定、省エネ、メディア・タイプ、...）のために、そのために好ましい局所値が存在する場合、それは代わりに置換することができます。デフォルト以外のキープアライブ間隔は任意のエンドポイントで使用されている場合、DNCPノードは、そのノードのデータの中に、適切なキープアライブ間隔TLV（s）は（セクション7.3.2）を公開する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.1.1. Data Model Additions",
      "section_title": true,
      "ja": "6.1.1. データモデルの追加"
    },
    {
      "indent": 3,
      "text": "The following additions to the Data Model (Section 5) are needed to support keep-alives:",
      "ja": "データモデル（第5節）へ次の追加は、キープアライブをサポートするために必要されています。"
    },
    {
      "indent": 3,
      "text": "For each configured endpoint that has per-endpoint keep-alives enabled:",
      "ja": "有効ごとのエンドポイントキープアライブを持つ各設定されたエンドポイントの場合："
    },
    {
      "indent": 3,
      "text": "o Last sent: If a timestamp that indicates the last time a Network State TLV (Section 7.2.2) was sent over that interface.",
      "ja": "O最終送ら：もしネットワークの状態TLV（セクション7.2.2）は、そのインタフェースを介して送信された最後の時間を示すタイムスタンプ。"
    },
    {
      "indent": 3,
      "text": "For each remote (peer, endpoint) pair detected on a local endpoint, a DNCP node has:",
      "ja": "ローカルエンドポイントで検出された各リモート（ピアエンドポイント）ペアについて、DNCPノードがあります。"
    },
    {
      "indent": 3,
      "text": "o Last contact timestamp: A timestamp that indicates the last time a consistent Network State TLV (Section 7.2.2) was received from the peer over multicast or when anything was received over unicast. Failing to update it for a certain amount of time as specified in Section 6.1.5 results in the removal of the peer. When adding a new peer, it is initialized to the current time.",
      "ja": "O最後の接触のタイムスタンプ：何がユニキャストを介して受信されたときに、一貫したネットワーク状態TLV（セクション7.2.2）は、マルチキャストを介してピアから受信したりして最後の時間を示すタイムスタンプ。ピアの除去セクション6.1.5結果で指定されるように一定時間のためにそれを更新することができません。新しいピアを追加する場合は、現在の時刻に初期化されます。"
    },
    {
      "indent": 3,
      "text": "o Last sent: If per-peer keep-alives are enabled, a timestamp that indicates the last time a Network State TLV (Section 7.2.2) was sent to that point-to-point peer. When adding a new peer, it is initialized to the current time.",
      "ja": "O最終送ら：あたりピアキープアライブが有効になっている場合は、ネットワークの状態TLV（セクション7.2.2）がそのポイント・ツー・ポイントのピアに送信された最後の時間を示すタイムスタンプを。新しいピアを追加する場合は、現在の時刻に初期化されます。"
    },
    {
      "indent": 0,
      "text": "6.1.2. Per-Endpoint Periodic Keep-Alives",
      "section_title": true,
      "ja": "6.1.2. ごとのエンドポイント定期的なキープアライブ"
    },
    {
      "indent": 3,
      "text": "If per-endpoint keep-alives are enabled on an endpoint in Multicast+Unicast transport mode, and if no traffic containing a Network State TLV (Section 7.2.2) has been sent to a particular endpoint within the endpoint-specific keep-alive interval, a Network State TLV (Section 7.2.2) MUST be sent on that endpoint, and a new Trickle interval started, as specified in step 2 of Section 4.2 of [RFC6206]. The actual sending time SHOULD be further delayed by a random time span in [0, Imin/2].",
      "ja": "ごとのエンドポイントキープアライブは、マルチキャスト+ユニキャストトランスポートモードでのエンドポイントで有効になっている場合、およびネットワークの状態TLV（7.2.2）を含むトラフィックは、エンドポイント固有のキープアライブ間隔内の特定のエンドポイントに送信されていない場合[RFC6206]のセクション4.2のステップ2で指定されるように、ネットワーク状態TLV（セクション7.2.2）は、そのエンドポイントに送らなければなりません、そして新しいトリクル間隔が開始しました。実際の送信時間は、さらに[0、値Imin / 2]においてランダム時間間隔だけ遅延されるべきです。"
    },
    {
      "indent": 0,
      "text": "6.1.3. Per-Peer Periodic Keep-Alives",
      "section_title": true,
      "ja": "6.1.3. ピアごとの定期的なキープアライブ"
    },
    {
      "indent": 3,
      "text": "If per-peer keep-alives are enabled on a unicast-only endpoint, and if no traffic containing a Network State TLV (Section 7.2.2) has been sent to a particular peer within the endpoint-specific keep-alive interval, a Network State TLV (Section 7.2.2) MUST be sent to the peer, and a new Trickle interval started, as specified in step 2 of Section 4.2 of [RFC6206].",
      "ja": "ネットワークの状態TLVを含むトラフィック（7.2.2）は、エンドポイント固有のキープアライブ間隔内の特定のピア、ネットワークに送信されていない場合、ピアごとのキープアライブは、ユニキャスト専用のエンドポイント上で有効になり、されている場合[RFC6206]のセクション4.2のステップ2で指定され、状態TLV（セクション7.2.2）ピアに送信する必要があり、新たなトリクル間隔が開始しました。"
    },
    {
      "indent": 0,
      "text": "6.1.4. Received TLV Processing Additions",
      "section_title": true,
      "ja": "6.1.4. 受信TLV処理の追加"
    },
    {
      "indent": 3,
      "text": "If a TLV is received over unicast from the peer, the Last contact timestamp for the peer MUST be updated.",
      "ja": "TLVは、ピアからのユニキャストを介して受信される場合は、ピアの最終接触タイムスタンプを更新する必要があります。"
    },
    {
      "indent": 3,
      "text": "On receipt of a Network State TLV (Section 7.2.2) that is consistent with the locally calculated network state hash, the Last contact timestamp for the peer MUST be updated in order to maintain it as a peer.",
      "ja": "ローカルで計算ネットワーク状態のハッシュと一致しているネットワークの状態TLV（セクション7.2.2）を受信すると、ピアの最終接触タイムスタンプがピアとして、それを維持するために更新されなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.1.5. Peer Removal",
      "section_title": true,
      "ja": "6.1.5. ピアの取り外し"
    },
    {
      "indent": 3,
      "text": "For every peer on every endpoint, the endpoint-specific keep-alive interval must be calculated by looking for Keep-Alive Interval TLVs (Section 7.3.2) published by the node, and if none exist, use the default value of DNCP_KEEPALIVE_INTERVAL. If the peer's Last contact timestamp has not been updated for at least a locally chosen potentially endpoint-specific keep-alive multiplier (defaults to DNCP_KEEPALIVE_MULTIPLIER) times the peer's endpoint-specific keep-alive interval, the Peer TLV for that peer and the local DNCP peer state MUST be removed.",
      "ja": "すべてのエンドポイント上のすべてのピアのために、エンドポイント固有のキープアライブ間隔は、ノードによって公開キープアライブインターバルのTLV（7.3.2項）を探すことにより計算されなければならない、と何も存在しない場合は、DNCP_KEEPALIVE_INTERVALのデフォルト値を使用します。ピアの最後の接触のタイムスタンプは、少なくともそのピアのためにローカルに選ばれた可能性のエンドポイント固有のキープアライブ乗数（DNCP_KEEPALIVE_MULTIPLIERデフォルト）倍ピアのエンドポイント固有のキープアライブ間隔、ピアTLVとローカルDNCPのために更新されていない場合ピア状態が除去されなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.2. Support for Dense Multicast-Enabled Links",
      "section_title": true,
      "ja": "6.2. 高密度マルチキャスト対応リンクのサポート"
    },
    {
      "indent": 3,
      "text": "This optimization is needed to avoid a state space explosion. Given a large set of DNCP nodes publishing data on an endpoint that uses multicast on a link, every node will add a Peer TLV (Section 7.3.1) for each peer. While Trickle limits the amount of traffic on the link in stable state to some extent, the total amount of data that is added to and maintained in the DNCP network given N nodes on a multicast-enabled link is O(N^2). Additionally, if per-peer keep-alives are used, there will be O(N^2) keep-alives running on the link if the liveliness of peers is not ensured using some other way (e.g., TCP connection lifetime, Layer 2 notification, or per-endpoint keep-alive).",
      "ja": "この最適化は、状態空間の爆発を避けるために必要とされます。 DNCPの大規模なセット所与のリンク上でマルチキャストを使用するエンドポイントにパブリッシュデータをノード、各ノードは、各ピアのピアTLV（7.3.1項）を追加します。トリクルがある程度安定した状態で、リンク上のトラフィックの量を制限しながら、マルチキャスト対応のリンク上でN個のノードを所与DNCPネットワーク内に添加し、そして維持されるデータの合計量はO（N ^ 2）です。ピアごとのキープアライブが使用されている場合は、ピアの活気が他の方法を使用して確保されていない場合はさらに、リンク上で実行されているO（N ^ 2）キープアライブがあるだろう（例えば、TCPコネクションの寿命、レイヤ2通知、またはごとのエンドポイントキープアライブ）。"
    },
    {
      "indent": 3,
      "text": "An upper bound for the number of peers that are allowed for a particular type of link that an endpoint in Multicast+Unicast transport mode is used on SHOULD be provided by a DNCP profile, but it MAY also be chosen at runtime. The main consideration when selecting a bound (if any) for a particular type of link should be whether it supports multicast traffic and whether a too large number of peers case is likely to happen during the use of that DNCP profile on that particular type of link. If neither is likely, there is little point specifying support for this for that particular link type.",
      "ja": "マルチキャスト+ユニキャストトランスポート・モードでエンドポイントが上に使用されることリンクの特定のタイプに許可されるピアの数の上限はDNCPプロファイルによって提供されなければならないが、それはまた、実行時に選択することができます。主な考慮事項には、マルチキャストトラフィックをサポートしているかどうか、ピアの例が大きすぎる数は、リンクのその特定の種類のことDNCPプロファイルの使用中に発生する可能性があるかどうかである必要があり、リンクの特定のタイプのために（もしあれば）バウンドを選択した場合。どちらの可能性があるない場合は、その特定のリンクタイプのため、このためのサポートを指定して、ほとんどのポイントがあります。"
    },
    {
      "indent": 3,
      "text": "If a DNCP profile does not support this extension at all, the rest of this subsection MUST be ignored. This is because when this extension is used, the state within the DNCP network only contains a subset of the full topology of the network. Therefore, every node must be aware of the potential of it being used in a particular DNCP profile.",
      "ja": "DNCPプロファイルは全くこの拡張をサポートしていない場合、このサブセクションの残りの部分は無視しなければなりません。この拡張機能を使用する場合、DNCPネットワーク内の状態は唯一のネットワークの完全なトポロジーのサブセットが含まれているためです。したがって、各ノードは、特定DNCPプロファイルで使用されていることの可能性を知っていなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the specified upper bound is exceeded for some endpoint in Multicast+Unicast transport mode and if the node does not have the highest node identifier on the link, it SHOULD treat the endpoint as a unicast endpoint connected to the node that has the highest node identifier detected on the link, therefore transitioning to Multicast-listen+Unicast transport mode. See Section 4.2 for implications on the specific endpoint behavior. The nodes in Multicast-listen+Unicast transport mode MUST keep listening to multicast traffic to both receive messages from the node(s) still in Multicast+Unicast mode and react to nodes with a greater node identifier appearing. If the highest node identifier present on the link changes, the remote unicast address of the endpoints in Multicast-Listen+Unicast transport mode MUST be changed. If the node identifier of the local node is the highest one, the node MUST switch back to, or stay in, Multicast+Unicast mode and form peer relationships with all peers as specified in Section 4.5.",
      "ja": "指定された上限は、マルチキャスト+ユニキャストトランスポートモードでは、いくつかのエンドポイントを超えていると、ノードがリンク上で最も高いノード識別子を持っていない場合、それは最高のノード識別子を持つノードに接続されたユニキャストエンドポイントとしてエンドポイントを扱う必要がある場合したがって、マルチキャスト試聴+ユニキャストトランスポートモードへの移行、リンク上で検出されました。特定のエンドポイントの振る舞いにも影響については、セクション4.2を参照してください。マルチキャストリッスン+ユニキャストトランスポート・モードのノードは、マルチキャスト+ユニキャストモードのままノード（S）からメッセージを受信し、出現大きいノード識別子がノードに反応の両方にマルチキャストトラフィックを聞く続けなければなりません。リンク変更の最高ノード識別子存在する場合、マルチキャストリッスン+ユニキャストトランスポート・モードでエンドポイントの遠隔ユニキャストアドレスを変更しなければなりません。ローカル・ノードのノード識別子が最も高いものである場合、セクション4.5で指定されているように、ノードは、バックに切り替える、またはに滞在、すべてのピアとのマルチキャスト+ユニキャストモードとフォームのピア関係しなければなりません。"
    },
    {
      "indent": 0,
      "text": "7. Type-Length-Value Objects",
      "section_title": true,
      "ja": "7.長-値オブジェクト"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|            Type               |           Length              |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|               Value (if any) (+padding (if any))              |\n..\n|                     (variable # of bytes)                     |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                     (optional nested TLVs)                    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Each TLV is encoded as:",
      "ja": "各TLVは次のようにコード化されています。"
    },
    {
      "indent": 3,
      "text": "o a 2-byte Type field",
      "ja": "O 2バイトタイプフィールド"
    },
    {
      "indent": 3,
      "text": "o a 2-byte Length field, which contains the length of the Value field in bytes; 0 means no value",
      "ja": "バイト単位で値フィールドの長さを含む2バイトの長さフィールド、O。 0は値を意味していません"
    },
    {
      "indent": 3,
      "text": "o the value itself (if any)",
      "ja": "O値自体（もしあれば）"
    },
    {
      "indent": 3,
      "text": "o padding bytes with a value of zero up to the next 4-byte boundary if the Length is not divisible by 4",
      "ja": "次の4バイト境界までゼロの値を持つOパディングバイト長が4で割り切れない場合"
    },
    {
      "indent": 3,
      "text": "While padding bytes MUST NOT be included in the number stored in the Length field of the TLV, if the TLV is enclosed within another TLV, then the padding is included in the enclosing TLV's Length value.",
      "ja": "パディングバイトがTLVの長さフィールドに格納された番号に含まれていない必要があるがTLVは別のTLV内に封入されている場合、その後、パディングが封入TLVの長さの値に含まれています。"
    },
    {
      "indent": 3,
      "text": "Each TLV that does not define optional fields or variable-length content MAY be sent with additional sub-TLVs appended after the TLV to allow for extensibility. When handling such TLV types, each node MUST accept received TLVs that are longer than the fixed fields specified for the particular type and ignore the sub-TLVs with either unknown types or types not supported within that particular TLV. If any sub-TLVs are present, the Length field of the TLV describes the number of bytes from the first byte of the TLV's own Value (if any) to the last (padding) byte of the last sub-TLV.",
      "ja": "オプションフィールド又は可変長のコンテンツを定義していない各TLVは、拡張性を可能にするためにTLV後の添付追加のサブのTLVを用いて送信することができます。そのようなTLVタイプを取り扱う場合、各ノードは、特定のタイプのために指定された固定フィールドよりも長い受信TLVを受け入れ、その特定のTLV内でサポートされていない未知のタイプ又は種類のいずれかでサブTLVを無視しなければなりません。任意のサブのTLVが存在する場合、TLVの長さフィールドは最後のサブTLVの最後（パディング）バイトにTLV自身の価値の最初のバイトからのバイト数（もしあれば）について説明します。"
    },
    {
      "indent": 3,
      "text": "For example, type=123 (0x7b) TLV with value 'x' (120 = 0x78) is encoded as: 007B 0001 7800 0000. If it were to have a sub-TLV of type=124 (0x7c) with value 'y', it would be encoded as 007B 000C 7800 0000 007C 0001 7900 0000.",
      "ja": "それはサブTLVタイプ= 124（0x7c）のを有するようにした場合007B 0001 7800 0000の値を有する 'Y'：例えば、値のタイプ= 123（0x7Bと）TLV 'X'（120 = 0x78とは）として符号化されます、それは007B 000C 7800 0000 007C 0001 7900 0000としてエンコードされます。"
    },
    {
      "indent": 3,
      "text": "In this section, the following special notation is used:",
      "ja": "このセクションでは、以下の特別な表記法が使用されます。"
    },
    {
      "indent": 6,
      "text": ".. = octet string concatenation operation.",
      "ja": ".. =オクテット文字列の連結演算。"
    },
    {
      "indent": 6,
      "text": "H(x) = non-cryptographic hash function specified by the DNCP profile.",
      "ja": "H DNCPプロファイルで指定された（X）=非暗号ハッシュ関数。"
    },
    {
      "indent": 3,
      "text": "In addition to the TLV types defined in this document, TLV Types 11-31 and 512-767 are unassigned and may be sequentially registered, starting at 11, by Standards Action [RFC5226] by extensions to DNCP that may be applicable in multiple DNCP profiles.",
      "ja": "この文書で定義されたTLVタイプに加えて、TLVタイプ11-31および512から767が割り当てられていないと順次複数DNCPプロファイルに適用することができるDNCPの拡張によって標準化行動[RFC5226]で、11から始まる、登録されていてもよいです。"
    },
    {
      "indent": 0,
      "text": "7.1. Request TLVs",
      "section_title": true,
      "ja": "7.1.  TLVをリクエストします"
    },
    {
      "indent": 0,
      "text": "7.1.1. Request Network State TLV",
      "section_title": true,
      "ja": "7.1.1. ネットワークの状態TLVをリクエスト"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|Type: Request network state (1)|          Length: >= 0         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This TLV is used to request response with a Network State TLV (Section 7.2.2) and all Node State TLVs (Section 7.2.3) (without node data).",
      "ja": "このTLVは、ネットワーク状態TLV（セクション7.2.2）と（ノードデータなし）、すべてのノードの状態のTLV（7.2.3）との応答を要求するために使用されます。"
    },
    {
      "indent": 0,
      "text": "7.1.2. Request Node State TLV",
      "section_title": true,
      "ja": "7.1.2. ノードの状態TLVをリクエスト"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Type: Request node state (2)  |          Length: > 0          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        Node Identifier                        |\n|                  (length fixed in DNCP profile)               |\n...\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This TLV is used to request a Node State TLV (Section 7.2.3) (including node data) for the node with the matching node identifier.",
      "ja": "このTLVは、一致するノード識別子を有するノードのため（ノードデータを含む）ノード状態TLV（7.2.3）を要求するために使用されます。"
    },
    {
      "indent": 0,
      "text": "7.2. Data TLVs",
      "section_title": true,
      "ja": "7.2. データのTLV"
    },
    {
      "indent": 0,
      "text": "7.2.1. Node Endpoint TLV",
      "section_title": true,
      "ja": "7.2.1. ノードのエンドポイントTLV"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Type: Node endpoint (3)     |          Length: > 4          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        Node Identifier                        |\n|                  (length fixed in DNCP profile)               |\n...\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      Endpoint Identifier                      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This TLV identifies both the local node's node identifier, as well as the particular endpoint's endpoint identifier. Section 4.2 specifies when it is sent.",
      "ja": "このTLVは、ローカルノードのノード識別子、ならびに特定のエンドポイントのエンドポイント識別子の両方を識別する。それが送信されるときに4.2節で指定します。"
    },
    {
      "indent": 0,
      "text": "7.2.2. Network State TLV",
      "section_title": true,
      "ja": "7.2.2. ネットワークの状態TLV"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|    Type: Network state (4)    |          Length: > 0          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     H(sequence number of node 1 .. H(node data of node 1) ..  |\n|    .. sequence number of node N .. H(node data of node N))    |\n|                  (length fixed in DNCP profile)               |\n...\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This TLV contains the current network state hash calculated by its sender (Section 4.1 describes the algorithm).",
      "ja": "このTLVは、その送信者によって計算され、現在のネットワーク状態のハッシュが含まれています（セクション4.1はアルゴリズムを記述します）。"
    },
    {
      "indent": 0,
      "text": "7.2.3. Node State TLV",
      "section_title": true,
      "ja": "7.2.3. ノードの状態TLV"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|      Type: Node state (5)     |          Length: > 8          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        Node Identifier                        |\n|                  (length fixed in DNCP profile)               |\n...\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                       Sequence Number                         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                Milliseconds Since Origination                 |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                         H(Node Data)                          |\n|                  (length fixed in DNCP profile)               |\n...\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       (optionally) Node Data (a set of nested TLVs)           |\n...\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This TLV represents the local node's knowledge about the published state of a node in the DNCP network identified by the Node Identifier field in the TLV.",
      "ja": "このTLVは、TLVにおけるノード識別子フィールドで識別DNCPネットワーク内のノードの公開された状態について、ローカル・ノードの知識を表します。"
    },
    {
      "indent": 3,
      "text": "Every node, including the node publishing the node data, MUST update the Milliseconds Since Origination whenever it sends a Node State TLV based on when the node estimates the data was originally published. This is, e.g., to ensure that any relative timestamps contained within the published node data can be correctly offset and interpreted. Ultimately, what is provided is just an approximation, as transmission delays are not accounted for.",
      "ja": "それはノードがデータが最初に出版されたと推定するときに基づいてノードの状態TLVを送信するたびにノードデータを公開ノードを含むすべてのノードは、オリジネーションからのミリ秒を更新する必要があります。これは、公開されたノードデータ内に含まれる任意の相対的なタイムスタンプが正しくオフセットと解釈することができることを確実にするために、例えば、です。伝送遅延が考慮されていないと最終的には、提供されるのは、単なる近似です。"
    },
    {
      "indent": 3,
      "text": "Absent any changes, if the originating node notices that the 32-bit Milliseconds Since Origination value would be close to overflow (greater than 2^32 - 2^16), the node MUST republish its TLVs even if there is no change. In other words, absent any other changes, the TLV set MUST be republished roughly every 48 days.",
      "ja": "発信値は、（2 ^ 32より大きい -  2 ^ 16）オーバーフローに近いことになるので存在しないすべての変更は、その32ビットミリ秒発信ノード通知場合、ノードは、変化がない場合でも、そのTLVを再発行しなければなりません。換言すれば、他の変更がなけれ、TLVセットは、すべての48日おおよそ再発行しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The actual node data of the node may be included within the TLV as well as in the optional Node Data field. The set of TLVs MUST be strictly ordered based on ascending binary content (including TLV type and length). This enables, e.g., efficient state delta processing and no-copy indexing by TLV type by the recipient. The node data content MUST be passed along exactly as it was received. It SHOULD be also verified on receipt that the locally calculated H(Node Data) matches the content of the field within the TLV, and if the hash differs, the TLV SHOULD be ignored.",
      "ja": "ノードの実際のノードデータはTLV内ならびに任意のノードデータフィールドに含まれていてもよいです。 TLVのセットは、厳密（TLVタイプと長さを含む）は、バイナリコンテンツを昇順に基づいて順序付けされなければなりません。これは、受信者によってTLVのタイプによって、例えば、効率的な状態デルタ処理なしコピーインデクシングを可能にします。それは受信されたように、ノードデータ内容を正確に沿って通過しなければなりません。また、局所的に計算さH（ノードデータ）TLV内のフィールドの内容と一致し、ハッシュが異なる場合、TLVを無視するように受信時に確認する必要があります。"
    },
    {
      "indent": 0,
      "text": "7.3. Data TLVs within Node State TLV",
      "section_title": true,
      "ja": "7.3. ノードの状態TLV内のデータのTLV"
    },
    {
      "indent": 3,
      "text": "These TLVs are published by the DNCP nodes and are therefore only encoded in the Node Data field of Node State TLVs. If encountered outside Node State TLV, they MUST be silently ignored.",
      "ja": "これらのTLVはDNCPノードによって公開されているので、唯一のノードの状態のTLVのノードデータフィールドに符号化されています。ノードの状態TLV外に遭遇した場合、彼らは黙って無視しなければなりません。"
    },
    {
      "indent": 0,
      "text": "7.3.1. Peer TLV",
      "section_title": true,
      "ja": "7.3.1.  TLVピア"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       Type: Peer (8)          |          Length: > 8          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      Peer Node Identifier                     |\n|                  (length fixed in DNCP profile)               |\n...\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                    Peer Endpoint Identifier                   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                   (Local) Endpoint Identifier                 |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This TLV indicates that the node in question vouches that the specified peer is reachable by it on the specified local endpoint. The presence of this TLV at least guarantees that the node publishing it has received traffic from the peer recently. For guaranteed up-to-date bidirectional reachability, the existence of both nodes' matching Peer TLVs needs to be checked.",
      "ja": "このTLVは、問題のノードが指定されたピアが指定したローカルエンドポイントで、それによって到達可能であることを保証することを示しています。このTLVの存在は、少なくともそれを公開したノードは、最近、ピアからのトラフィックを受信したことを保証します。保証最新の双方向到達可能性のために、両方のノードのマッチングピアのTLVの存在は確認する必要があります。"
    },
    {
      "indent": 0,
      "text": "7.3.2. Keep-Alive Interval TLV",
      "section_title": true,
      "ja": "7.3.2. キープアライブ間隔TLV"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Type: Keep-alive interval (9) |          Length: >= 8         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      Endpoint Identifier                      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                           Interval                            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This TLV indicates a non-default interval being used to send keep-alives as specified in Section 6.1.",
      "ja": "このTLVは、セクション6.1で指定されたキープアライブを送信するために使用されているデフォルト以外の区間を示しています。"
    },
    {
      "indent": 3,
      "text": "Endpoint identifier is used to identify the particular (local) endpoint for which the interval applies on the sending node. If 0, it applies for ALL endpoints for which no specific TLV exists.",
      "ja": "エンドポイント識別子は、間隔が送信ノードに適用される特定の（ローカル）エンドポイントを識別するために使用されます。 0の場合、それは特定のTLVが存在しないすべてのエンドポイントに適用されます。"
    },
    {
      "indent": 3,
      "text": "Interval specifies the interval in milliseconds at which the node sends keep-alives. A value of zero means no keep-alives are sent at all; in that case, some lower-layer mechanism that ensures the presence of nodes MUST be available and used.",
      "ja": "間隔は、ノードがキープアライブを送信するに間隔をミリ秒単位で指定します。ゼロの値は、キープアライブが全く送信されないこと。その場合には、ノードの存在を保証するいくつかの下層の機構が利用可能であり、使用されなければなりません。"
    },
    {
      "indent": 0,
      "text": "8. Security and Trust Management",
      "section_title": true,
      "ja": "8.セキュリティと信頼の管理"
    },
    {
      "indent": 3,
      "text": "If specified in the DNCP profile, either DTLS [RFC6347] or TLS [RFC5246] may be used to authenticate and encrypt either some (if specified optional in the profile) or all unicast traffic. The following methods for establishing trust are defined, but it is up to the DNCP profile to specify which ones may, should, or must be supported.",
      "ja": "DNCPプロファイルで指定されている場合、DTLS [RFC6347]またはTLS [RFC5246]のいずれかは、いくつかの（プロファイルに任意指定されている場合）またはすべてのユニキャストトラフィックのいずれかを認証し、暗号化するために使用されてもよいです。信頼を確立するための以下のメソッドが定義され、それがどれを指定するDNCPプロファイルに任されている、またはサポートされなければならない必要があることがあります。"
    },
    {
      "indent": 0,
      "text": "8.1. Trust Method Based on Pre-Shared Key",
      "section_title": true,
      "ja": "8.1. 事前共有キーに基づいたトラスト法"
    },
    {
      "indent": 3,
      "text": "A trust model based on Pre-Shared Key (PSK) is a simple security management mechanism that allows an administrator to deploy devices to an existing network by configuring them with a predefined key, similar to the configuration of an administrator password or Wi-Fi Protected Access (WPA) key. Although limited in nature, it is useful to provide a user-friendly security mechanism for smaller networks.",
      "ja": "事前共有キー（PSK）に基づいた信頼モデルは、管理者のパスワードまたは保護のWi-Fiの構成と同様、管理者が事前に定義されたキーでそれらを設定することにより、既存のネットワークにデバイスを配置することができるシンプルなセキュリティ管理メカニズムであり、アクセス（WPA）キーを押します。自然の中で制限されますが、小規模ネットワークのためのユーザーフレンドリーなセキュリティメカニズムを提供することが有用です。"
    },
    {
      "indent": 0,
      "text": "8.2. PKI-Based Trust Method",
      "section_title": true,
      "ja": "8.2.  PKIベースのトラスト法"
    },
    {
      "indent": 3,
      "text": "A PKI-based trust model enables more advanced management capabilities at the cost of increased complexity and bootstrapping effort. However, it allows trust to be managed in a centralized manner and is therefore useful for larger networks with a need for an authoritative trust management.",
      "ja": "PKIベースの信頼モデルは複雑化し、ブートストラップ努力のコストで、より高度な管理機能を可能にします。しかし、それは信頼が一元的に管理することが可能となり、権威信頼管理の必要性を持つ大規模なネットワークのために有用です。"
    },
    {
      "indent": 0,
      "text": "8.3. Certificate-Based Trust Consensus Method",
      "section_title": true,
      "ja": "8.3. 証明書ベースの信頼コンセンサス方式"
    },
    {
      "indent": 3,
      "text": "For some scenarios -- such as bootstrapping a mostly unmanaged network -- the methods described above may not provide a desirable trade-off between security and user experience. This section includes guidance for implementing an opportunistic security [RFC7435] method that DNCP profiles can build upon and adapt for their specific requirements.",
      "ja": "このような主に管理されていないネットワークをブートストラップとして -   - いくつかのシナリオで上記の方法は、セキュリティとユーザ経験の間の望ましいトレードオフを提供することができません。このセクションでは、DNCPプロファイルは上に構築し、その特定の要件のために適合させることができ日和見セキュリティ[RFC7435]方法を実施するためのガイダンスが含まれています。"
    },
    {
      "indent": 3,
      "text": "The certificate-based consensus model is designed to be a compromise between trust management effort and flexibility. It is based on X.509 certificates and allows each DNCP node to provide a trust verdict on any other certificate, and a consensus is found to determine whether a node using this certificate or any certificate signed by it is to be trusted.",
      "ja": "証明書ベースのコンセンサスモデルは、信託管理の労力と柔軟性の間の妥協になるように設計されています。これは、X.509証明書に基づいて、各DNCPノードは、他の証明書の信頼判定を提供することができ、そしてコンセンサスがそれによって署名されたこの証明書または証明書を使用してノードが信頼されるべきかどうかを決定するために発見されています。"
    },
    {
      "indent": 3,
      "text": "A DNCP node not using this security method MUST ignore all announced trust verdicts and MUST NOT announce any such verdicts by itself, i.e., any other normative language in this subsection does not apply to it.",
      "ja": "このセキュリティ方式を使用していないDNCPノードがすべて発表された信頼の評決を無視しなければなりませんし、自分自身でそのような評決を発表してはならない、すなわち、このサブセクション内の他の規範的な言語は、それには適用されません。"
    },
    {
      "indent": 3,
      "text": "The current effective trust verdict for any certificate is defined as the one with the highest priority from all trust verdicts announced for said certificate at the time.",
      "ja": "すべての証明書の現在の効果的な信頼の評決がために発表されたすべての信頼評決から最も優先度の高いものとして定義された時点で証明書は述べています。"
    },
    {
      "indent": 0,
      "text": "8.3.1. Trust Verdicts",
      "section_title": true,
      "ja": "8.3.1. トラスト判定と"
    },
    {
      "indent": 3,
      "text": "Trust verdicts are statements of DNCP nodes about the trustworthiness of X.509 certificates. There are 5 possible trust verdicts in order of ascending priority:",
      "ja": "トラスト判決は、X.509証明書の信頼性についてDNCPノードの文です。昇順優先順位の順に5件の可能な信頼評決があります。"
    },
    {
      "indent": 6,
      "text": "0 (Neutral): no trust verdict exists, but the DNCP network should determine one.",
      "ja": "0（ニュートラル）：全く信頼評決は存在しないが、DNCPネットワークは、一つを決定しなければなりません。"
    },
    {
      "indent": 6,
      "text": "1 (Cached Trust): the last known effective trust verdict was Configured or Cached Trust.",
      "ja": "1（キャッシュ信託）：最後の既知の効果的な信頼評決が設定またはキャッシュされた信頼されました。"
    },
    {
      "indent": 6,
      "text": "2 (Cached Distrust): the last known effective trust verdict was Configured or Cached Distrust.",
      "ja": "2（キャッシュ不信）：最後の既知の効果的な信頼評決が設定またはキャッシュ不信ました。"
    },
    {
      "indent": 6,
      "text": "3 (Configured Trust): trustworthy based upon an external ceremony or configuration.",
      "ja": "3（設定されている信頼）：外部式または設定に基づいて信頼できます。"
    },
    {
      "indent": 6,
      "text": "4 (Configured Distrust): not trustworthy based upon an external ceremony or configuration.",
      "ja": "4（設定不信）：外部式または設定に基づいて、信頼できません。"
    },
    {
      "indent": 3,
      "text": "Trust verdicts are differentiated in 3 groups:",
      "ja": "トラスト判決は、3つのグループに区別されています。"
    },
    {
      "indent": 3,
      "text": "o Configured verdicts are used to announce explicit trust verdicts a node has based on any external trust bootstrap or predefined relations a node has formed with a given certificate.",
      "ja": "O構成さ判決は、明示的な信頼関係は、ノードは、ノードが指定された証明書を用いて形成されている任意の外部の信頼ブートストラップまたは事前定義された関係に基づいた判決アナウンスするために使用されます。"
    },
    {
      "indent": 3,
      "text": "o Cached verdicts are used to retain the last known trust state in case all nodes with configured verdicts about a given certificate have been disconnected or turned off.",
      "ja": "Oキャッシュ判決が切断またはオフにされている指定された証明書についての構成判決の場合のすべてのノードを、最後の既知の信頼状態を保持するために使用されます。"
    },
    {
      "indent": 3,
      "text": "o The Neutral verdict is used to announce a new node intending to join the network, so a final verdict for it can be found.",
      "ja": "Oニュートラル評決は、ネットワークに参加しようとする新しいノードを発表するために使用されているので、それのための最終的な判決を求めることができます。"
    },
    {
      "indent": 3,
      "text": "The current effective trust verdict for any certificate is defined as the one with the highest priority within the set of trust verdicts announced for the certificate in the DNCP network. A node MUST be trusted for participating in the DNCP network if and only if the current effective trust verdict for its own certificate or any one in its certificate hierarchy is (Cached or Configured) Trust, and none of the certificates in its hierarchy have an effective trust verdict of (Cached or Configured) Distrust. In case a node has a configured verdict, which is different from the current effective trust verdict for a certificate, the current effective trust verdict takes precedence in deciding trustworthiness. Despite that, the node still retains and announces its configured verdict.",
      "ja": "すべての証明書の現在の効果的な信頼の評決はDNCPネットワーク内の証明書の発表された信頼評決のセットの中で一番高い優先度を持つものとして定義されます。そして、自身の証明書の現在の有効な信頼評決またはその証明書階層内のいずれかが（キャッシュまたは設定）されている場合にのみ場合にノードが信頼DNCPネットワークに参加するために信頼されている必要があり、その階層内の証明書のどれも有効を持っていません（キャッシュまたは設定済み）の信頼評決不信。ノードは、証明書の現在の有効な信頼評決異なる構成評決を有する場合には、現在有効な信頼評決は、信頼性を決定する際に優先されます。それにもかかわらず、ノードがまだ保持しており、その構成された評決を発表しました。"
    },
    {
      "indent": 0,
      "text": "8.3.2. Trust Cache",
      "section_title": true,
      "ja": "8.3.2. トラストキャッシュ"
    },
    {
      "indent": 3,
      "text": "Each node SHOULD maintain a trust cache containing the current effective trust verdicts for all certificates currently announced in the DNCP network. This cache is used as a backup of the last known state in case there is no node announcing a configured verdict for a known certificate. It SHOULD be saved to a non-volatile memory at reasonable time intervals to survive a reboot or power outage.",
      "ja": "各ノードは、現在DNCPネットワークに発表されたすべての証明書の現在の効果的な信頼の評決を含む信頼キャッシュを維持する必要があります。このキャッシュは、既知の証明書のために構成された判定を発表ノードが存在しない場合に、最後の既知の状態のバックアップとして使用されます。再起動や停電を乗り切るために、合理的な時間間隔で、不揮発性メモリに保存する必要があります。"
    },
    {
      "indent": 3,
      "text": "Every time a node (re)joins the network or detects the change of an effective trust verdict for any certificate, it will synchronize its cache, i.e., store new effective trust verdicts overwriting any previously cached verdicts. Configured verdicts are stored in the cache as their respective cached counterparts. Neutral verdicts are never stored and do not override existing cached verdicts.",
      "ja": "たびにノードが（再）ネットワークに参加するか、いずれかの証明書のための有効な信頼判決の変更を検出し、それはすなわち、以前にキャッシュされた評決を上書きする新しい効果的な信頼の評決を格納し、そのキャッシュを同期させます。構成された評決は、それぞれのキャッシュされたカウンターパートとしてキャッシュに格納されています。中性評決が保存されることはありませんし、既存のキャッシュされた評決を上書きしません。"
    },
    {
      "indent": 0,
      "text": "8.3.3. Announcement of Verdicts",
      "section_title": true,
      "ja": "8.3.3. 判定とのお知らせ"
    },
    {
      "indent": 3,
      "text": "A node SHOULD always announce any configured verdicts it has established by itself, and it MUST do so if announcing the configured verdict leads to a change in the current effective trust verdict for the respective certificate. In absence of configured verdicts, it MUST announce Cached Trust verdicts it has stored in its trust cache, if one of the following conditions applies:",
      "ja": "ノードは常にそれ自体によって確立された任意の構成された評決を発表すべきである、と構成された評決を発表することは、それぞれの証明書の現在の有効な信頼評決の変化につながるかどうかは、そうしなければなりません。構成された評決がない場合には、それがキャッシュされた信託は、次のいずれかの条件に当てはまる場合には、その信頼キャッシュに保存された評決を発表しなければなりません："
    },
    {
      "indent": 3,
      "text": "o The stored trust verdict is Cached Trust, and the current effective trust verdict for the certificate is Neutral or does not exist.",
      "ja": "O格納された信頼評決は、キャッシュされた信託であり、証明書の現在の有効な信頼評決は、中性であるか、または存在しません。"
    },
    {
      "indent": 3,
      "text": "o The stored trust verdict is Cached Distrust, and the current effective trust verdict for the certificate is Cached Trust.",
      "ja": "O格納された信頼評決は不信をキャッシュし、証明書の現在の有効な信頼評決は、キャッシュされた信頼されます。"
    },
    {
      "indent": 3,
      "text": "A node rechecks these conditions whenever it detects changes of announced trust verdicts anywhere in the network.",
      "ja": "ノードは、それがどこでもネットワークに発表した信頼評決の変化を検出するたびに、これらの条件を再チェック。"
    },
    {
      "indent": 3,
      "text": "Upon encountering a node with a hierarchy of certificates for which there is no effective trust verdict, a node adds a Neutral Trust-Verdict TLV to its node data for all certificates found in the hierarchy and publishes it until an effective trust verdict different from Neutral can be found for any of the certificates, or a reasonable amount of time (10 minutes is suggested) with no reaction and no further authentication attempts has passed. Such trust verdicts SHOULD also be limited in rate and number to prevent denial-of-service attacks.",
      "ja": "有効な信頼判定がないいる証明書の階層を有するノードに遭遇すると、ノードは、階層にあるすべての証明書のためにそのノードデータ中性トラスト評決TLVを追加し、ニュートラル缶異なる有効な信頼評決までを公開します通過した証明書、または全く反応を妥当な時間（10分が提案されている）、それ以上の認証の試行のいずれかのために見つけること。このような信頼の評決はまた、サービス拒否攻撃を防ぐためにレートや数に限定されるべきです。"
    },
    {
      "indent": 3,
      "text": "Trust verdicts are announced using Trust-Verdict TLVs:",
      "ja": "トラスト判決は、トラスト・評決のTLVを使用して発表しています。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Type: Trust-Verdict (10)    |        Length: > 36           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|    Verdict    |                 (reserved)                    |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n|                                                               |\n|                                                               |\n|                      SHA-256 Fingerprint                      |\n|                                                               |\n|                                                               |\n|                                                               |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                          Common Name                          |",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Verdict represents the numerical index of the trust verdict.",
      "ja": "評決は、信頼評決の数値インデックスを表します。"
    },
    {
      "indent": 6,
      "text": "(reserved) is reserved for future additions and MUST be set to 0 when creating TLVs and ignored when parsing them.",
      "ja": "（予約）は、将来の追加のために予約されており、それらを解析する際のTLVを作成するときに0に設定され、無視されなければなりません。"
    },
    {
      "indent": 6,
      "text": "SHA-256 Fingerprint contains the SHA-256 [RFC6234] hash value of the certificate in DER format.",
      "ja": "SHA-256指紋は、DER形式の証明書のSHA-256 [RFC6234]ハッシュ値を含みます。"
    },
    {
      "indent": 6,
      "text": "Common name contains the variable-length (1-64 bytes) common name of the certificate.",
      "ja": "一般的な名前は、可変長（1-64バイト）証明書の共通名が含まれています。"
    },
    {
      "indent": 0,
      "text": "8.3.4. Bootstrap Ceremonies",
      "section_title": true,
      "ja": "8.3.4. ブートストラップセレモニー"
    },
    {
      "indent": 3,
      "text": "The following non-exhaustive list of methods describes possible ways to establish trust relationships between DNCP nodes and node certificates. Trust establishment is a two-way process in which the existing network must trust the newly added node, and the newly added node must trust at least one of its peer nodes. It is therefore necessary that both the newly added node and an already trusted node perform such a ceremony to successfully introduce a node into the DNCP network. In all cases, an administrator MUST be provided with external means to identify the node belonging to a certificate based on its fingerprint and a meaningful common name.",
      "ja": "メソッドの以下の非網羅的なリストは、DNCPノードとノード証明書との間に信頼関係を確立することが可能な方法を説明します。信頼確立は、既存のネットワークに新たに追加されたノードを信頼する必要があり、新たに追加されたノードがピア・ノードの少なくとも一つを信頼する必要がある双方向のプロセスです。新たに追加されたノードと既に信頼できるノードの両方が正常DNCPネットワークにノードを導入するために、このような儀式を行うことが必要です。全ての場合において、管理者は、その指紋と意味の共通名に基づいて証明書に属するノードを識別するための外部手段を備えていなければなりません。"
    },
    {
      "indent": 0,
      "text": "8.3.4.1. Trust by Identification",
      "section_title": true,
      "ja": "8.3.4.1。識別による信頼"
    },
    {
      "indent": 3,
      "text": "A node implementing certificate-based trust MUST provide an interface to retrieve the current set of effective trust verdicts, fingerprints, and names of all certificates currently known and set configured verdicts to be announced. Alternatively, it MAY provide a companion DNCP node or application with these capabilities with which it has a pre-established trust relationship.",
      "ja": "証明書ベースの信頼を実装するノードは、効果的な信頼の評決、指紋、及び現在知られていると発表されるように構成された評決を設定するすべての証明書の名前の現在のセットを取得するためのインタフェースを提供しなければなりません。また、それは事前に確立された信頼関係を有するこれらの機能を備えたコンパニオンDNCPノードやアプリケーションを提供することができます。"
    },
    {
      "indent": 0,
      "text": "8.3.4.2. Preconfigured Trust",
      "section_title": true,
      "ja": "8.3.4.2。事前設定された信託"
    },
    {
      "indent": 3,
      "text": "A node MAY be preconfigured to trust a certain set of node or CA certificates. However, such trust relationships MUST NOT result in unwanted or unrelated trust for nodes not intended to be run inside the same network (e.g., all other devices by the same manufacturer).",
      "ja": "ノードは、ノードまたはCA証明書の特定のセットを信頼するように事前設定されるかもしれません。しかしながら、このような信頼関係がなく、同じネットワーク内で実行されることを意図したノードのために望ましくないまたは無関係な信頼をもたらすてはいけません（例えば、同じ製造業者によって他のすべてのデバイス）。"
    },
    {
      "indent": 0,
      "text": "8.3.4.3. Trust on Button Press",
      "section_title": true,
      "ja": "8.3.4.3。ボタンを押して上のトラスト"
    },
    {
      "indent": 3,
      "text": "A node MAY provide a physical or virtual interface to put one or more of its internal network interfaces temporarily into a mode in which it trusts the certificate of the first DNCP node it can successfully establish a connection with.",
      "ja": "ノードは、一時的に、それが正常との接続を確立することができる第一DNCPノードの証明書を信頼するモードに、内部ネットワークインタフェースの一つ以上を置く物理または仮想インタフェースを提供することができます。"
    },
    {
      "indent": 0,
      "text": "8.3.4.4. Trust on First Use",
      "section_title": true,
      "ja": "8.3.4.4。まず、使用上の信頼"
    },
    {
      "indent": 3,
      "text": "A node that is not associated with any other DNCP node MAY trust the certificate of the first DNCP node it can successfully establish a connection with. This method MUST NOT be used when the node has already associated with any other DNCP node.",
      "ja": "他DNCPノードに関連付けられていないノードは、それが成功したとの接続を確立することができます最初のDNCPノードの証明書を信頼するかもしれません。ノードが既に他DNCPノードに関連付けられている場合、この方法を使用してはいけません。"
    },
    {
      "indent": 0,
      "text": "9. DNCP Profile-Specific Definitions",
      "section_title": true,
      "ja": "9. DNCPプロファイル固有の定義"
    },
    {
      "indent": 3,
      "text": "Each DNCP profile MUST specify the following aspects:",
      "ja": "各DNCPプロファイルは、次のような特徴を指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "o Unicast and optionally a multicast transport protocol(s) to be used. If a multicast-based node and status discovery is desired, a datagram-based transport supporting multicast has to be available.",
      "ja": "Oユニキャストおよび任意マルチキャストトランスポートプロトコル（単数または複数）が使用されます。マルチキャストベースノードおよび状態検出が所望される場合、マルチキャストをサポートするデータグラムベースのトランスポートが使用可能でなければなりません。"
    },
    {
      "indent": 3,
      "text": "o How the chosen transport(s) is secured: Not at all, optionally, or always with the TLS scheme defined here using one or more of the methods, or with something else. If the links with DNCP nodes can be sufficiently secured or isolated, it is possible to run DNCP in a secure manner without using any form of authentication or encryption.",
      "ja": "いずれかの方法を使用して、ここで定義されたTLS方式に、または何か他のもので、常に必要に応じて、すべてではない、または：Oどのように選ばれたトランスポート（S）が確保されています。 DNCPノードとのリンクが十分に確保または単離することができるならば、認証や暗号化のいずれかの形式を使用せずに安全な方法でDNCPを実行することが可能です。"
    },
    {
      "indent": 3,
      "text": "o Transport protocols' parameters such as port numbers to be used or multicast addresses to be used. Unicast, multicast, and secure unicast may each require different parameters, if applicable.",
      "ja": "ポート番号などOトランスポートプロトコルパラメータが使用されるか、マルチキャストアドレスを使用します。該当する場合、ユニキャスト、マルチキャスト、および安全なユニキャストは、それぞれ、異なるパラメータを必要とし得ます。"
    },
    {
      "indent": 3,
      "text": "o When receiving TLVs, what sort of TLVs are ignored in addition -- as specified in Section 4.4 -- e.g., for security reasons. While the security of the node data published within the Node State TLVs is already ensured by the base specification (if secure unicast transport is used, Node State TLVs are sent only via unicast as multicast ones are ignored on receipt), if a profile adds TLVs that are sent outside the node data, a profile should indicate whether or not those TLVs should be ignored if they are received via multicast or non-secured unicast. A DNCP profile may define the following DNCP TLVs to be safely ignored:",
      "ja": "TLVを受信すると、O、のTLVがどんなものなのかは、ほかでは無視されます - セクション4.4で指定されるように - 例えば、セキュリティ上の理由から。ノード状態のTLV内で公開されたノードデータのセキュリティが既に基本仕様によって保証されている間プロファイルはTLVを追加する場合、（安全なユニキャストトランスポートが使用される場合、マルチキャストものが領収書の上で無視されるように、ノード状態のTLVは、ユニキャストを介してのみ送信されます）ノードデータの外に送信される、プロファイルは、それらがマルチキャストまたは非セキュアユニキャストを介して受信された場合、これらのTLVを無視するかどうかを示すべきです。 DNCPプロファイルは無視されるように、次のDNCP TLVを定義することができます。"
    },
    {
      "indent": 6,
      "text": "* Anything received over multicast, except Node Endpoint TLV (Section 7.2.1) and Network State TLV (Section 7.2.2).",
      "ja": "*ものはノードのエンドポイントTLV（7.2.1）とネットワーク状態TLV（7.2.2項）を除いて、マルチキャストを介して受信します。"
    },
    {
      "indent": 6,
      "text": "* Any TLVs received over unreliable unicast or multicast at a rate that is that is too high; Trickle will ensure eventual convergence given the rate slows down at some point.",
      "ja": "*任意のTLVは、それが高すぎるレートで信頼性のないユニキャストまたはマルチキャストを介して受信しました。トリクルレートはいくつかの点で遅く与えられた最終的な収束を保証します。"
    },
    {
      "indent": 3,
      "text": "o How to deal with node identifier collision as described in Section 4.4. Main options are either for one or both nodes to assign new node identifiers to themselves or to notify someone about a fatal error condition in the DNCP network.",
      "ja": "4.4節で説明したように、Oノード識別子の衝突に対処する方法。主なオプションは、1つまたは自分自身に新しいノードの識別子を割り当てることかDNCPネットワーク内の致命的なエラー状態についての誰かに通知するために、両方のノードのためのものです。"
    },
    {
      "indent": 3,
      "text": "o Imin, Imax, and k ranges to be suggested for implementations to be used in the Trickle algorithm. The Trickle algorithm does not require these to be the same across all implementations for it to work, but similar orders of magnitude help implementations of a DNCP profile to behave more consistently and to facilitate estimation of lower and upper bounds for convergence behavior of the network.",
      "ja": "O Iminを、Imaxを、kはトリクルアルゴリズムで使用する実装のために提案される範囲です。それを動作させるためにトリクルアルゴリズムは、すべての実装間で同じになるようにこれらを必要としませんが、DNCPプロファイルの大きさのヘルプの実装の同様の受注はより一貫振る舞うように、ネットワークの収束挙動のための下限と上限の推定を容易にします。"
    },
    {
      "indent": 3,
      "text": "o Hash function H(x) to be used, and how many bits of the output are actually used. The chosen hash function is used to handle both hashing of node data and producing network state hash, which is a hash of node data hashes. SHA-256 defined in [RFC6234] is the recommended default choice, but a non-cryptographic hash function could be used as well. If there is a hash collision in the network state hash, the network will effectively be partitioned to partitions that believe they are up to date but are actually no longer converged. The network will converge either when some node data anywhere in the network changes or when conflicting Node State TLVs get transmitted across the partition (either caused by \"Trickle-Driven Status Updates\" (Section 4.3) or as part of the \"Processing of Received TLVs\" (Section 4.4)). If a node publishes",
      "ja": "Oハッシュ関数H（x）を使用すると、どのように多くの出力のビットが実際に使用されます。選択されたハッシュ関数は、ノードデータのハッシュとノードデータのハッシュのハッシュであり、ネットワーク状態ハッシュを生成両方を処理するために使用されます。 [RFC6234]で定義されたSHA-256は、推奨されるデフォルトの選択肢であるが、非暗号ハッシュ関数は、同様に使用することができます。ネットワーク状態のハッシュにおけるハッシュ衝突がある場合は、ネットワークを効果的に彼らが最新ではないが、実際にはもはや収束していると考えているパーティションに分割されます。ネットワークが収束するかとき、いくつかのノードネットワークの変更でどこでもデータまたはノードの状態のTLVは「トリクル・ドリブンのステータス更新」（4.3節）によって、または受信のTLVの「処理の一環として、パーティションにわたって送信（どちらかの原因を取得矛盾するとき「（セクション4.4））。ノードが発行していた場合"
    },
    {
      "indent": 6,
      "text": "node data with a hash that collides with any previously published node data, the update may not be (fully) propagated, and the old version of node data may be used instead.",
      "ja": "以前に公開されたノードデータと衝突ハッシュとノードデータは、更新がないかもしれない（完全に）伝播、及びノードデータの古いバージョンの代わりに使用してもよいです。"
    },
    {
      "indent": 3,
      "text": "o DNCP_NODE_IDENTIFIER_LENGTH: The fixed length of a node identifier (in bytes).",
      "ja": "O DNCP_NODE_IDENTIFIER_LENGTH：（バイト単位）は、ノード識別子の固定長。"
    },
    {
      "indent": 3,
      "text": "o Whether to send keep-alives, and if so, whether it is per-endpoint (requires multicast transport) or per-peer. Keep-alive also has associated parameters:",
      "ja": "キープアライブを送信するかどうか、O、およびそれがエンドポイントごとに（マルチキャスト転送を必要とする）またはごとのピアであるかどうか、もしそうなら。キープアライブもパラメータが関連付けられています："
    },
    {
      "indent": 6,
      "text": "* DNCP_KEEPALIVE_INTERVAL: How often keep-alives are to be sent by default (if enabled).",
      "ja": "* DNCP_KEEPALIVE_INTERVAL：（有効な場合）、デフォルトで送信されるようにどのくらいの頻度でキープアライブをしています。"
    },
    {
      "indent": 6,
      "text": "* DNCP_KEEPALIVE_MULTIPLIER: How many times the DNCP_KEEPALIVE_INTERVAL (or peer-supplied keep-alive interval value) node may not be heard from to be considered still valid. This is just a default used in absence of any other configuration information or particular per-endpoint configuration.",
      "ja": "* DNCP_KEEPALIVE_MULTIPLIER：DNCP_KEEPALIVE_INTERVAL（またはピアが提供するキープアライブ間隔値）ノードがまだ有効と見なされるためにから聞いたことがないかもしれませんどのように多くの時間。これは、他の構成情報や、特定ごとのエンドポイントの構成が存在しない場合に使用されるデフォルトです。"
    },
    {
      "indent": 3,
      "text": "o Whether to support dense multicast-enabled link optimization (Section 6.2) or not.",
      "ja": "密なマルチキャスト対応リンクの最適化（6.2節）かをサポートするかどうかO。"
    },
    {
      "indent": 3,
      "text": "For some guidance on choosing transport and security options, please see Appendix B.",
      "ja": "トランスポートとセキュリティオプションを選択する上でいくつかのガイダンスについては、付録Bを参照してください。"
    },
    {
      "indent": 0,
      "text": "10. Security Considerations",
      "section_title": true,
      "ja": "10.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "DNCP-based protocols may use multicast to indicate DNCP state changes and for keep-alive purposes. However, no actual published data TLVs will be sent across that channel. Therefore, an attacker may only learn hash values of the state within DNCP and may be able to trigger unicast synchronization attempts between nodes on a local link this way. A DNCP node MUST therefore rate limit its reactions to multicast packets.",
      "ja": "DNCPベースのプロトコルは、DNCP状態の変化を示し、キープアライブの目的のためにするためにマルチキャストを使用することができます。しかし、実際の公表されたデータのTLVは、そのチャネルを介して送信されません。したがって、攻撃者のみDNCP内状態のハッシュ値を学習することができるし、このように、ローカルリンク上のノード間のユニキャストの同期試行をトリガすることができるかもしれません。 DNCPノードは、従って、マルチキャストパケットに、その反応をレート制限しなければなりません。"
    },
    {
      "indent": 3,
      "text": "When using DNCP to bootstrap a network, PKI-based solutions may have issues when validating certificates due to potentially unavailable accurate time or due to the inability to use the network to either check Certificate Revocation Lists or perform online validation.",
      "ja": "ネットワークをブートストラップするDNCPを使用する場合は証明書失効リストを確認するか、オンライン検証を実行するか、ネットワークを使用できないことに起因する潜在的に利用できない正確な時間にかによる証明書の検証時に、PKIベースのソリューションは、問題がある場合があります。"
    },
    {
      "indent": 3,
      "text": "The Certificate-based trust consensus mechanism defined in this document allows for a consenting revocation; however, in case of a compromised device, the trust cache may be poisoned before the actual revocation happens allowing the distrusted device to rejoin the network using a different identity. Stopping such an attack might require physical intervention and flushing of the trust caches.",
      "ja": "この文書で定義された証明書ベースの信頼コンセンサスメカニズムは同意撤回することができます。実際の失効が信頼できないデバイスは、異なるアイデンティティを使用してネットワークに再度参加することを可能に起こる前しかし、損なわ装置の場合には、信頼キャッシュが被毒されてもよいです。このような攻撃を停止すると、信頼のキャッシュの物理的な介入フラッシングが必要な場合があります。"
    },
    {
      "indent": 0,
      "text": "11. IANA Considerations",
      "section_title": true,
      "ja": "11. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "IANA has set up a registry for the (decimal 16-bit) \"DNCP TLV Types\" under \"Distributed Node Consensus Protocol (DNCP)\". The registration procedure is Standards Action [RFC5226]. The initial contents are:",
      "ja": "IANAは、「分散ノード合意プロトコル（DNCP）」の下で（小数点以下16ビット）「DNCP TLVタイプ」のレジストリを設定しています。登録手続きは、標準アクション[RFC5226]です。初期の内容は以下のとおりです。"
    },
    {
      "indent": 6,
      "text": "0: Reserved",
      "ja": "0：予約済み"
    },
    {
      "indent": 6,
      "text": "1: Request network state",
      "ja": "1：ネットワークの状態をリクエスト"
    },
    {
      "indent": 6,
      "text": "2: Request node state",
      "ja": "2：要求ノード状態"
    },
    {
      "indent": 6,
      "text": "3: Node endpoint",
      "ja": "3：ノードのエンドポイント"
    },
    {
      "indent": 6,
      "text": "4: Network state",
      "ja": "4：ネットワーク状態"
    },
    {
      "indent": 6,
      "text": "5: Node state",
      "ja": "5：ノードの状態"
    },
    {
      "indent": 6,
      "text": "6: Reserved for future use (was: Custom)",
      "ja": "6：将来の使用のために予約（だった：カスタム）"
    },
    {
      "indent": 6,
      "text": "7: Reserved for future use (was: Fragment count)",
      "ja": "7：将来の使用のために予約は（だった：フラグメント数）"
    },
    {
      "indent": 6,
      "text": "8: Peer",
      "ja": "8：ピア"
    },
    {
      "indent": 6,
      "text": "9: Keep-alive interval",
      "ja": "9：キープアライブ間隔"
    },
    {
      "indent": 6,
      "text": "10: Trust-Verdict",
      "ja": "10：トラスト評決"
    },
    {
      "indent": 6,
      "text": "11-31: Unassigned",
      "ja": "11-31：未割り当て"
    },
    {
      "indent": 6,
      "text": "32-511: Reserved for per-DNCP profile use",
      "ja": "32から511：ごとのDNCPプロファイルの使用のために予約"
    },
    {
      "indent": 6,
      "text": "512-767: Unassigned",
      "ja": "512から767：割り当てられていません"
    },
    {
      "indent": 6,
      "text": "768-1023: Reserved for Private Use [RFC5226]",
      "ja": "768-1023：貸切予約[RFC5226]"
    },
    {
      "indent": 6,
      "text": "1024-65535: Reserved for future use",
      "ja": "1024〜65535：将来の使用のために予約"
    },
    {
      "indent": 0,
      "text": "12. References",
      "section_title": true,
      "ja": "12.参考文献"
    },
    {
      "indent": 0,
      "text": "12.1. Normative References",
      "section_title": true,
      "ja": "12.1. 引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<http://www.rfc-editor.org/info/ RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC5226] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 5226, DOI 10.17487/RFC5226, May 2008, <http://www.rfc-editor.org/info/rfc5226>.",
      "ja": "[RFC5226] Narten氏、T.とH. Alvestrand、 \"RFCsにIANA問題部に書くためのガイドライン\"、BCP 26、RFC 5226、DOI 10.17487 / RFC5226、2008年5月、<http://www.rfc-editor.org /情報/ RFC5226>。"
    },
    {
      "indent": 3,
      "text": "[RFC6206] Levis, P., Clausen, T., Hui, J., Gnawali, O., and J. Ko, \"The Trickle Algorithm\", RFC 6206, DOI 10.17487/RFC6206, March 2011, <http://www.rfc-editor.org/info/rfc6206>.",
      "ja": "[RFC6206]リーバイス、P.、クラウゼン、T.、ホイ、J.、Gnawali、O.、およびJ.コ、 \"トリクルアルゴリズム\"、RFC 6206、DOI 10.17487 / RFC6206、2011年3月、<のhttp：// www.rfc-editor.org/info/rfc6206>。"
    },
    {
      "indent": 3,
      "text": "[RFC6234] Eastlake 3rd, D. and T. Hansen, \"US Secure Hash Algorithms (SHA and SHA-based HMAC and HKDF)\", RFC 6234, DOI 10.17487/RFC6234, May 2011, <http://www.rfc-editor.org/info/rfc6234>.",
      "ja": "[RFC6234]イーストレイク3日、D.とT.ハンセン、 \"米国のセキュアハッシュアルゴリズム（SHAとHMACとHKDF SHAベース）\"、RFC 6234、DOI 10.17487 / RFC6234、2011年5月、<のhttp：//www.rfc- editor.org/info/rfc6234>。"
    },
    {
      "indent": 0,
      "text": "12.2. Informative References",
      "section_title": true,
      "ja": "12.2. 参考文献"
    },
    {
      "indent": 3,
      "text": "[RFC3315] Droms, R., Ed., Bound, J., Volz, B., Lemon, T., Perkins, C., and M. Carney, \"Dynamic Host Configuration Protocol for IPv6 (DHCPv6)\", RFC 3315, DOI 10.17487/RFC3315, July 2003, <http://www.rfc-editor.org/info/rfc3315>.",
      "ja": "[RFC3315] Droms、R.、編、バウンド、J.、フォルツ、B.、レモン、T.、パーキンス、C.、およびM.カーニー、 \"IPv6のための動的ホスト構成プロトコル（DHCPv6）\"、RFC 3315 、DOI 10.17487 / RFC3315、2003年7月、<http://www.rfc-editor.org/info/rfc3315>。"
    },
    {
      "indent": 3,
      "text": "[RFC3493] Gilligan, R., Thomson, S., Bound, J., McCann, J., and W. Stevens, \"Basic Socket Interface Extensions for IPv6\", RFC 3493, DOI 10.17487/RFC3493, February 2003, <http://www.rfc-editor.org/info/rfc3493>.",
      "ja": "[RFC3493]ギリガン、R.、トムソン、S.、バウンド、J.、マッキャン、J.、およびW.スティーブンス、 \"IPv6の基本的なソケットインタフェース拡張\"、RFC 3493、DOI 10.17487 / RFC3493、2003年2月、<HTTP ：//www.rfc-editor.org/info/rfc3493>。"
    },
    {
      "indent": 3,
      "text": "[RFC5246] Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS) Protocol Version 1.2\", RFC 5246, DOI 10.17487/RFC5246, August 2008, <http://www.rfc-editor.org/info/rfc5246>.",
      "ja": "[RFC5246]ダークス、T.およびE.レスコラ、 \"トランスポート層セキュリティ（TLS）プロトコルバージョン1.2\"、RFC 5246、DOI 10.17487 / RFC5246、2008年8月、<http://www.rfc-editor.org/info / RFC5246>。"
    },
    {
      "indent": 3,
      "text": "[RFC6347] Rescorla, E. and N. Modadugu, \"Datagram Transport Layer Security Version 1.2\", RFC 6347, DOI 10.17487/RFC6347, January 2012, <http://www.rfc-editor.org/info/rfc6347>.",
      "ja": "[RFC6347]レスコラ、E.およびN. Modadugu、 \"データグラムトランスポート層セキュリティバージョン1.2\"、RFC 6347、DOI 10.17487 / RFC6347、2012年1月、<http://www.rfc-editor.org/info/rfc6347>。"
    },
    {
      "indent": 3,
      "text": "[RFC7435] Dukhovni, V., \"Opportunistic Security: Some Protection Most of the Time\", RFC 7435, DOI 10.17487/RFC7435, December 2014, <http://www.rfc-editor.org/info/rfc7435>.",
      "ja": "[RFC7435] Dukhovni、V.、 \"日和見セキュリティ：時間のいくつかの保護ほとんど\"、RFC 7435、DOI 10.17487 / RFC7435、2014年12月、<http://www.rfc-editor.org/info/rfc7435>。"
    },
    {
      "indent": 3,
      "text": "[RFC7596] Cui, Y., Sun, Q., Boucadair, M., Tsou, T., Lee, Y., and I. Farrer, \"Lightweight 4over6: An Extension to the Dual-Stack Lite Architecture\", RFC 7596, DOI 10.17487/RFC7596, July 2015, <http://www.rfc-editor.org/info/rfc7596>.",
      "ja": "[RFC7596]崔、Y.、日、Q.、Boucadair、M.、ツオウ、T.、リー、Y.、およびI.ファラー、 \"軽量4over6：デュアルスタックLiteのアーキテクチャへの拡張\"、RFC 7596 、DOI 10.17487 / RFC7596、2015年7月、<http://www.rfc-editor.org/info/rfc7596>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Alternative Modes of Operation",
      "ja": "操作の付録A.代替モード"
    },
    {
      "indent": 3,
      "text": "Beyond what is described in the main text, the protocol allows for other uses. These are provided as examples.",
      "ja": "メインテキストで説明されているもの以外にも、プロトコルは、他の用途が可能になります。これらは、例として提供されています。"
    },
    {
      "indent": 0,
      "text": "A.1. Read-Only Operation",
      "ja": "A.1。読み取り専用の操作"
    },
    {
      "indent": 3,
      "text": "If a node uses just a single endpoint and does not need to publish any TLVs, full DNCP node functionality is not required. Such a limited node can acquire and maintain a view of the TLV space by implementing the processing logic as specified in Section 4.4. Such node would not need Trickle, peer-maintenance, or even keep-alives at all, as the DNCP nodes' use of it would guarantee eventual receipt of network state hashes, and synchronization of node data, even in the presence of unreliable transport.",
      "ja": "ノードが1つだけのエンドポイントを使用して、任意のTLVを公開する必要がない場合には、フルDNCPノードの機能は必要ありません。そのような制限されたノードは、セクション4.4で指定されるように処理ロジックを実装することにより、TLV空間のビューを取得して維持することができます。それのDNCPのノードの使用でも信頼性の低い輸送の存在下で、最終的なネットワーク状態ハッシュの領収書、およびノー​​ドデータの同期を保証するようなノードは、キープアライブを全てでさえトリクル、ピア・メンテナンスを必要としない、またはでしょう。"
    },
    {
      "indent": 0,
      "text": "A.2. Forwarding Operation",
      "ja": "A.2。転送操作"
    },
    {
      "indent": 3,
      "text": "If a node with a pair of endpoints does not need to publish any TLVs, it can detect (for example) nodes with the highest node identifier on each of the endpoints (if any). Any TLVs received from one of them would be forwarded verbatim as unicast to the other node with the highest node identifier.",
      "ja": "エンドポイントのペアを有するノードは、任意のTLVを公開する必要がない場合は、エンドポイントのそれぞれに最も高いノード識別子を有する（例えば）ノード（もしあれば）を検出することができます。 TLVは、それらのいずれかから受信した、最も高いノード識別子を有する他のノードへのユニキャストとしてそのまま転送されます。"
    },
    {
      "indent": 3,
      "text": "Any tinkering with the TLVs would remove guarantees of this scheme working; however, passive monitoring would obviously be fine. This type of simple forwarding cannot be chained, as it does not send anything proactively.",
      "ja": "TLVをいじり、いずれもこの方式の作業の保証を削除します。しかし、パッシブモニタリングは明らかに罰金だろう。それは積極的に何かを送信しないような単純な転送のこのタイプは、連鎖させることはできません。"
    },
    {
      "indent": 0,
      "text": "Appendix B. DNCP Profile Additional Guidance",
      "ja": "付録B. DNCPプロファイル追加のガイダンス"
    },
    {
      "indent": 3,
      "text": "This appendix explains implications of design choices made when specifying the DNCP profile to use particular transport or security options.",
      "ja": "この付録では、特定のトランスポートまたはセキュリティオプションを使用するようにDNCPプロファイルを指定するときに作られたデザインの選択肢の意味を説明しています。"
    },
    {
      "indent": 0,
      "text": "B.1. Unicast Transport -- UDP or TCP?",
      "ja": "B.1。ユニキャスト交通 -  UDPまたはTCP？"
    },
    {
      "indent": 3,
      "text": "The node data published by a DNCP node is limited to 64 KB due to the 16-bit size of the length field of the TLV it is published within. Some transport choices may decrease this limit; if using, e.g., UDP datagrams for unicast transport, the upper bound of the node data size is whatever the nodes and the underlying network can pass to each other as DNCP does not define its own fragmentation scheme. A profile that chooses UDP has to be limited to small node data (e.g., somewhat smaller than IPv6 default MTU if using IPv6) or specify a minimum that all nodes have to support. Even then, if using non-link-local communications, there is some concern about what middleboxes do to fragmented packets. Therefore, the use of stream transport such as TCP is probably a good idea if either non-link-local communication is desired or fragmentation is expected to cause problems.",
      "ja": "DNCPノードによって公表されたノードデータは、それが内部に公開されたTLVの長さフィールドの16ビットサイズに起因64キロバイトに制限されています。いくつかの輸送の選択肢は、この制限を減少させることができます。ユニキャスト輸送のための、例えば、UDPデータグラムを使用した場合、ノードデータサイズの上限はDNCPが自身の断片化スキームを定義しないようにノードとその下のネットワークが相互に通過することができるものは何でもです。 UDPを選択したプロファイルは、（IPv6を使用している場合IPv6デフォルトMTUよりも幾分小さく、例えば、）小さなノードデータに限定されるもの又はすべてのノードがサポートしなければならないこと最小を指定しなければなりません。その後も、非リンクローカル通信を使用している場合、断片化されたパケットにやるのMiddleboxesかについて、いくつかの懸念があります。そのため、TCPのようなストリームトランスポートの使用は、おそらくどちらかの非リンクローカル通信が要求されるか、断片化が問題を引き起こすことが予想される場合は良い考えです。"
    },
    {
      "indent": 3,
      "text": "TCP also provides some other facilities, such as a relatively long built-in keep-alive, which in conjunction with connection closes occurring from eventual failed retransmissions may be sufficient to avoid the use of in-protocol keep-alive defined in Section 6.1. Additionally, it is reliable, so there is no need for Trickle on such unicast connections.",
      "ja": "TCPは、接続と一緒に最終的な障害が発生した再送から発生することで、プロトコルのキープアライブセクション6.1で定義されているの使用を回避するのに十分かもしれ閉じ、このような比較的長いビルトインのようないくつかの他の施設、キープアライブを、提供します。さらに、それは信頼性があるので、このようなユニキャスト接続にトリクルする必要はありません。"
    },
    {
      "indent": 3,
      "text": "The major downside of using TCP instead of UDP with DNCP-based profiles lies in the loss of control over the time at which TLVs are received; while unreliable UDP datagrams also have some delay, TLVs within reliable stream transport may be delayed significantly due to retransmissions. This is not a problem if no relative time-dependent information is stored within the TLVs in the DNCP-based protocol; for such a protocol, TCP is a reasonable choice for unicast transport if it is available.",
      "ja": "DNCPベースのプロファイルとUDPの代わりにTCPを使用しての主な欠点は、のTLVが受信される時間にわたる制御の喪失です。信頼性のないUDPデータグラムはまた、いくつかの遅延を持っている一方で、信頼性の高いストリーム・トランスポート内のTLVが原因の再送信に大幅に遅れる場合があります。相対的な時間依存情報がDNCPベースのプロトコルでのTLV内に格納されていない場合、これは問題ではありません。それが利用可能な場合、そのようなプロトコルのために、TCPは、ユニキャスト輸送のための合理的な選択です。"
    },
    {
      "indent": 0,
      "text": "B.2. (Optional) Multicast Transport",
      "ja": "B.2。 （オプション）マルチキャスト転送"
    },
    {
      "indent": 3,
      "text": "Multicast is needed for dynamic peer discovery and to trigger unicast exchanges; for that, unreliable datagram transport (=typically UDP) is the only transport option defined within this specification, although DNCP-based protocols may themselves define some other transport or peer discovery mechanism (e.g., based on Multicast DNS (mDNS) or DNS).",
      "ja": "マルチキャストは、動的ピア発見及びユニキャスト交換をトリガするために必要とされます。そのためDNCPベースのプロトコル自体がいくつかの他の輸送またはピア発見メカニズムを定義することができるが、信頼性のないデータグラム輸送（=典型的にUDP）は、本明細書内で定義された唯一のトランスポートオプションである（例えば、マルチキャストDNS（mDNSの）またはDNSに基づいて）。"
    },
    {
      "indent": 3,
      "text": "If multicast is used, a well-known address should be specified and for, e.g., IPv6, respectively, the desired address scopes. In most cases, link-local and possibly site-local are useful scopes.",
      "ja": "マルチキャストを使用する場合、既知のアドレスが指定されなければならない、のための例えば、IPv6の、それぞれ、所望のアドレススコープ。ほとんどの場合、リンクローカルおよびおそらくサイトローカルに便利スコープです。"
    },
    {
      "indent": 0,
      "text": "B.3. (Optional) Transport Security",
      "ja": "B.3。 （オプション）トランスポート・セキュリティ"
    },
    {
      "indent": 3,
      "text": "In terms of provided security, DTLS and TLS are equivalent; they also consume a similar amount of state on the devices. While TLS is on top of a stream protocol, using DTLS also requires relatively long session caching within the DTLS layer to avoid expensive reauthentication/authorization steps if and when any state within the DNCP network changes or per-peer keep-alive (if enabled) is sent.",
      "ja": "提供されるセキュリティの面では、DTLSとTLSは同等です。彼らはまた、デバイス上で状態の同様の量を消費します。 TLSは、ストリームプロトコルの上ですが、DTLSを使用することもあれば、高価な再認証/承認ステップを回避したときにDNCPネットワークの変更内またはピアごとのいずれかの状態がキープアライブ（有効な場合）するDTLS層内の比較的長いセッションキャッシングが必要です送信されます。"
    },
    {
      "indent": 3,
      "text": "TLS implementations (at the time of writing the specification) seem more mature and available (as open source) than DTLS ones. This may be due to a long history of use with HTTPS.",
      "ja": "（仕様書を書く時）TLSの実装は、DTLSのものよりもより成熟し、（オープンソースとして）利用できるようです。これは、HTTPSでの使用の長い歴史に起因する可能性があります。"
    },
    {
      "indent": 3,
      "text": "Some libraries seem not to support multiplexing between insecure and secure communication on the same port, so specifying distinct ports for secured and unsecured communication may be beneficial.",
      "ja": "いくつかのライブラリはとても有益であるかもしれ確保し、無担保の通信のための異なるポートを指定して、同じポート上のセキュアでないと安全な通信の間の多重化をサポートすることではないようです。"
    },
    {
      "indent": 0,
      "text": "Appendix C. Example Profile",
      "ja": "付録C.例のプロフィール"
    },
    {
      "indent": 3,
      "text": "This is the DNCP profile of SHSP, an experimental (and for the purposes of this document fictional) home automation protocol. The protocol itself is used to make a key-value store published by each of the nodes available to all other nodes for distributed monitoring and control of a home infrastructure. It defines only one additional TLV type: a key=value TLV that contains a single key=value assignment for publication.",
      "ja": "これはSHSPのDNCPプロファイル、（と架空このドキュメントの目的のために）実験的なホームオートメーションプロトコルです。プロトコル自体は、ホーム・インフラストラクチャの分散型監視および制御するための他のすべてのノードに利用可能なノードの各々によって公開キーと値のストアを作成するために使用されます。単一のキーを含むキー=値TLV =パブリケーションの値の割り当て：これは、唯一つの追加のTLVタイプを定義します。"
    },
    {
      "indent": 3,
      "text": "o Unicast transport: IPv6 TCP on port EXAMPLE-P1 since only absolute timestamps are used within the key=value data and since it focuses primarily on Linux-based nodes that support both protocols as well. Connections from and to non-link-local addresses are ignored to avoid exposing this protocol outside the secure links.",
      "ja": "Oユニキャストトランスポート：IPv6のTCPポート例-P1にのみ絶対タイムスタンプは、key = valueのデータ内に、それは同様に両方のプロトコルをサポートするLinuxベースのノードに主に焦点を当てるために使用されるからです。非リンクローカルアドレスへの接続は、セキュアリンクの外に、このプロトコルの公開を回避するために無視されます。"
    },
    {
      "indent": 3,
      "text": "o Multicast transport: IPv6 UDP on port EXAMPLE-P2 to link-local scoped multicast address ff02:EXAMPLE. At least one node per link in the home is assumed to facilitate node discovery without depending on any other infrastructure.",
      "ja": "例：リンクローカルスコープのマルチキャストアドレスFF02にポート例-P2のIPv6 UDP：Oマルチキャスト輸送。家庭内のリンクごとに少なくとも1つのノードは、他のインフラに依存することなく、ノードの発見を容易にするために、想定されます。"
    },
    {
      "indent": 3,
      "text": "o Security: None. It is to be used only on trusted links (WPA2-x wireless, physically secure wired links).",
      "ja": "Oのセキュリティ：なし。これは、信頼できるリンク（WPA2-Xの無線、物理的にセキュアな有線リンク）に使用されます。"
    },
    {
      "indent": 3,
      "text": "o Additional TLVs to be ignored: None. No DNCP security is specified, and no new TLVs are defined outside of node data.",
      "ja": "無視するO追加のTLV：なし。いいえDNCPセキュリティが指定されていない、と新しいのTLVは、ノードデータの外部で定義されていません。"
    },
    {
      "indent": 3,
      "text": "o Node identifier length (DNCP_NODE_IDENTIFIER_LENGTH): 32 bits that are randomly generated.",
      "ja": "Oノード識別子の長さ（DNCP_NODE_IDENTIFIER_LENGTH）：ランダムに生成される32ビット。"
    },
    {
      "indent": 3,
      "text": "o Node identifier collision handling: Pick new random node identifier.",
      "ja": "Oノード識別子の衝突の取り扱い：新しいランダムなノード識別子を選択してください。"
    },
    {
      "indent": 3,
      "text": "o Trickle parameters: Imin = 200 ms, Imax = 7, k = 1. It means at least one multicast per link in 25 seconds in stable state (0.2 * 2^7).",
      "ja": "Oパラメータをトリクル：値Iminは、それが安定した状態で25秒間にリンクあたり少なくとも一つのマルチキャスト（0.2 * 2 ^ 7）を意味する200ミリ秒、値Imax = 7、K = 1を=。"
    },
    {
      "indent": 3,
      "text": "o Hash function H(x) + length: SHA-256, only 128 bits used. It's relatively fast, and 128 bits should be plenty to prevent random conflicts (64 bits would most likely be sufficient, too).",
      "ja": "Oハッシュ関数H（X）+長さ：SHA-256、唯一の128ビットが使用。これは、比較的高速だし、128ビット（64ビットが最も可能性も十分であろう）、ランダムな衝突を防ぐために十分でなければなりません。"
    },
    {
      "indent": 3,
      "text": "o No in-protocol keep-alives (Section 6.1); TCP keep-alive is to be used. In practice, TCP keep-alive is seldom encountered anyway, as changes in network state cause packets to be sent on the unicast connections, and those that fail sufficiently many retransmissions are dropped much before the keep-alive actually would fire.",
      "ja": "ノーOにおけるプロトコルキープアライブ（6.1節）。 TCPキープアライブを使用することです。実際にはネットワーク状態の原因パケットの変化は、ユニキャスト接続上で送信されるように、TCPキープアライブはほとんど、とにかく遭遇していない、とキープアライブが実際に発射するだろう前に、十分に多くの再送信に失敗するものが多くを落としています。"
    },
    {
      "indent": 3,
      "text": "o No support for dense multicast-enabled link optimization (Section 6.2); SHSP is a simple protocol for a few nodes (network wide, not even to mention on a single link) and therefore would not provide any benefit.",
      "ja": "O密なマルチキャスト対応リンクの最適化（セクション6.2）のサポートはありません。 SHSPは（いなくても、単一のリンクに言及し、ネットワークワイド）、したがって、任意の利益を提供しないであろういくつかのノードのための単純なプロトコルです。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Thanks to Ole Troan, Pierre Pfister, Mark Baugher, Mark Townsley, Juliusz Chroboczek, Jiazi Yi, Mikael Abrahamsson, Brian Carpenter, Thomas Clausen, DENG Hui, and Margaret Cullen for their contributions to the document.",
      "ja": "文書への貢献のためにオレTroan、ピエール・フィスター、マーク・Baugher、マークTownsley、はJuliusz Chroboczek、Jiazi李、ミカエルAbrahamsson、ブライアン・カーペンター、トーマス・クラウゼン、DENGホイ、マーガレットカレンに感謝します。"
    },
    {
      "indent": 3,
      "text": "Thanks to Kaiwen Jin and Xavier Bonnetain for their related research work.",
      "ja": "それらに関連する研究活動のためのKaiwenジンとザビエルBonnetainに感謝します。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Markus Stenberg Independent Helsinki 00930 Finland",
      "ja": "マルクスステンバーグ独立ヘルシンキ00930、フィンランド"
    },
    {
      "indent": 3,
      "text": "Email: markus.stenberg@iki.fi",
      "ja": "メール：markus.stenberg@iki.fi"
    },
    {
      "indent": 3,
      "text": "Steven Barth Independent Halle 06114 Germany",
      "ja": "スティーブン・バルト独立ハレ06114ドイツ"
    },
    {
      "indent": 3,
      "text": "Email: cyrus@openwrt.org",
      "ja": "メール：cyrus@openwrt.org"
    }
  ]
}