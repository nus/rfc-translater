{
  "title": {
    "text": "RFC 7486 - HTTP Origin-Bound Authentication (HOBA)",
    "ja": "RFC 7486 - HTTP起源結合型認証（HOBA）"
  },
  "number": 7486,
  "created_at": "2019-11-02 19:57:31.536719+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                        S. Farrell\nRequest for Comments: 7486                        Trinity College Dublin\nCategory: Experimental                                        P. Hoffman\nISSN: 2070-1721                                           VPN Consortium\n                                                               M. Thomas\n                                                               Phresheez\n                                                              March 2015",
      "raw": true
    },
    {
      "indent": 16,
      "text": "HTTP Origin-Bound Authentication (HOBA)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "HTTP Origin-Bound Authentication (HOBA) is a digital-signature-based design for an HTTP authentication method. The design can also be used in JavaScript-based authentication embedded in HTML. HOBA is an alternative to HTTP authentication schemes that require passwords and therefore avoids all problems related to passwords, such as leakage of server-side password databases.",
      "ja": "HTTP起源結合型認証（HOBA）はHTTP認証方式のためのデジタル署名ベースの設計です。デザインもHTMLに埋め込まれたJavaScriptベースの認証に使用することができます。 HOBAは、パスワードを必要とし、したがって、そのようなサーバー側のパスワードデータベースの漏洩など、パスワード、に関連するすべての問題を回避HTTP認証方式に代わるものです。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for examination, experimental implementation, and evaluation.",
      "ja": "このドキュメントはインターネット標準化過程仕様ではありません。それは、検査、実験的な実装、および評価のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document defines an Experimental Protocol for the Internet community. This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are a candidate for any level of Internet Standard; see Section 2 of RFC 5741.",
      "ja": "この文書は、インターネットコミュニティのためにExperimentalプロトコルを定義します。このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。 IESGによって承認されていないすべての文書がインターネットStandardのどんなレベルの候補です。 RFC 5741のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7486.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7486で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2015 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2015 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3\n  1.1.  Interfacing to Applications (Cookies) . . . . . . . . . .   4\n  1.2.  Terminology . . . . . . . . . . . . . . . . . . . . . . .   5\n  1.3.  Step-by-Step Overview of HOBA-http  . . . . . . . . . . .   6\n2.  The HOBA Authentication Scheme  . . . . . . . . . . . . . . .   6\n3.  Introduction to the HOBA-http Mechanism . . . . . . . . . . .   9\n4.  Introduction to the HOBA-js Mechanism . . . . . . . . . . . .  10\n5.  HOBA's Authentication Process . . . . . . . . . . . . . . . .  11\n  5.1.  CPK Preparation Phase . . . . . . . . . . . . . . . . . .  11\n  5.2.  Signing Phase . . . . . . . . . . . . . . . . . . . . . .  11\n  5.3.  Authentication Phase  . . . . . . . . . . . . . . . . . .  11\n6.  Other Parts of the HOBA Process . . . . . . . . . . . . . . .  12\n  6.1.  Registration  . . . . . . . . . . . . . . . . . . . . . .  13\n    6.1.1.  Hobareg Definition  . . . . . . . . . . . . . . . . .  14\n  6.2.  Associating Additional Keys to an Existing Account  . . .  16\n    6.2.1.  Moving Private Keys . . . . . . . . . . . . . . . . .  16\n    6.2.2.  Human-Memorable One-Time Password (Don't Do This One)  16\n    6.2.3.  Out-of-Band URL . . . . . . . . . . . . . . . . . . .  17\n  6.3.  Logging Out . . . . . . . . . . . . . . . . . . . . . . .  17\n  6.4.  Getting a Fresh Challenge . . . . . . . . . . . . . . . .  17\n7.  Mandatory-to-Implement Algorithms . . . . . . . . . . . . . .  18\n8.  Security Considerations . . . . . . . . . . . . . . . . . . .  18\n  8.1.  Privacy Considerations  . . . . . . . . . . . . . . . . .  18\n  8.2.  localStorage Security for JavaScript  . . . . . . . . . .  19\n  8.3.  Multiple Accounts on One User Agent . . . . . . . . . . .  20\n  8.4.  Injective Mapping for HOBA-TBS  . . . . . . . . . . . . .  20\n9.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  21\n  9.1.  HOBA Authentication Scheme  . . . . . . . . . . . . . . .  21\n  9.2.  .well-known URI . . . . . . . . . . . . . . . . . . . . .  21\n  9.3.  Algorithm Names . . . . . . . . . . . . . . . . . . . . .  21\n  9.4.  Key Identifier Types  . . . . . . . . . . . . . . . . . .  22",
      "raw": true
    },
    {
      "indent": 3,
      "text": "  9.5.  Device Identifier Types . . . . . . . . . . . . . . . . .  22\n  9.6.  Hobareg HTTP Header Field . . . . . . . . . . . . . . . .  23\n10. References  . . . . . . . . . . . . . . . . . . . . . . . . .  23\n  10.1.  Normative References . . . . . . . . . . . . . . . . . .  23\n  10.2.  Informative References . . . . . . . . . . . . . . . . .  24\nAppendix A.  Problems with Passwords  . . . . . . . . . . . . . .  26\nAppendix B.  Example  . . . . . . . . . . . . . . . . . . . . . .  27\nAcknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  28\nAuthors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  28",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "HTTP Origin-Bound Authentication (HOBA) is an authentication design that can be used as an HTTP authentication scheme [RFC7235] and for JavaScript-based authentication embedded in HTML. The main goal of HOBA is to offer an easy-to-implement authentication scheme that is not based on passwords but that can easily replace HTTP or HTML forms-based password authentication. Deployment of HOBA can reduce or eliminate password entries in databases, with potentially significant security benefits.",
      "ja": "HTTP起源結合型認証（HOBA）はHTTP認証スキーム[RFC7235]のようにHTMLに埋め込まれたJavaScriptベースの認証のために使用することができる認証設計です。 HOBAの主な目標は、パスワードに基づいていない簡単に実装する認証方式を提供することですが、それは簡単にHTTPまたはHTMLフォームベースのパスワード認証に置き換えることができます。 HOBAの展開は、潜在的に重大なセキュリティ上の利点と、データベースにパスワードエントリを減らすか、または排除することができます。"
    },
    {
      "indent": 3,
      "text": "HOBA is an HTTP authentication mechanism that complies with the framework for such schemes [RFC7235]. As a JavaScript design, HOBA demonstrates a way for clients and servers to interact using the same credentials that are used by the HTTP authentication scheme.",
      "ja": "HOBAは、このようなスキームのためのフレームワーク[RFC7235]に準拠したHTTP認証メカニズムです。 JavaScriptのデザインとして、HOBAは、クライアントとサーバは、HTTP認証方式で使用されるのと同じ資格情報を使用して対話するための方法を示しています。"
    },
    {
      "indent": 3,
      "text": "Current username/password authentication methods such as HTTP Basic, HTTP Digest, and web forms have been in use for many years but are susceptible to theft of server-side password databases. Instead of passwords, HOBA uses digital signatures in a challenge-response scheme as its authentication mechanism. HOBA also adds useful features such as credential management and session logout. In HOBA, the client creates a new public-private key pair for each host (\"web origin\" [RFC6454]) to which it authenticates. These keys are used in HOBA for HTTP clients to authenticate themselves to servers in the HTTP protocol or in a JavaScript authentication program.",
      "ja": "このようHTTPベーシック、HTTPダイジェスト、およびWebフォームなどの現在のユーザー名/パスワードの認証方法は、長年にわたって使用されてきたが、サーバー側のパスワードデータベースの盗難を受けやすいいます。パスワードの代わりに、HOBAは、その認証メカニズムとしてチャレンジレスポンス方式でデジタル署名を使用しています。 HOBAはまた、資格管理、セッションのログアウトなど便利な機能が追加されます。 HOBAでは、クライアントは、それが認証すると、各ホストのための新しい公開鍵と秘密鍵のペア（「ウェブ起源」[RFC6454]）を作成します。これらのキーは、HTTPプロトコルまたはJavaScriptの認証プログラム内のサーバーに自分自身を認証するためにHTTPクライアントに対してHOBAに使用されています。"
    },
    {
      "indent": 3,
      "text": "HOBA session management is identical to username/password session management, with a server-side session management tool or script inserting a session cookie [RFC6265] into the output to the browser. Use of Transport Layer Security (TLS) for the HTTP session is still necessary to prevent session cookie hijacking.",
      "ja": "HOBAセッション管理は、サーバー側のセッション管理ツールまたはスクリプトがブラウザへの出力にセッションクッキー[RFC6265]を挿入すると、ユーザー名/パスワードのセッション管理と同じです。 HTTPセッションのためのトランスポート層セキュリティ（TLS）を使用すると、セッションCookieハイジャックを防ぐために依然として必要です。"
    },
    {
      "indent": 3,
      "text": "HOBA keys are \"bare keys\", so there is no need for the semantic overhead of X.509 public key certificates, particularly with respect to naming and trust anchors. The Client Public Key (CPK) structures in HOBA do not have any publicly visible identifier for the user who possesses the corresponding private key, nor the web origin with which the client is using the CPK.",
      "ja": "HOBAキーは「裸の鍵」であるため、特にアンカーに名前を付けると信頼に関してX.509公開鍵証明書、の意味オーバーヘッドは必要ありません。 HOBAのクライアント公開鍵（CPK）の構造は、対応する秘密鍵を所有するユーザー、またクライアントは、CPKを使用しているウェブ起源のための任意の一般に公開識別子を持っていません。"
    },
    {
      "indent": 3,
      "text": "HOBA also defines some services that are needed for modern HTTP authentication:",
      "ja": "HOBAも、現代のHTTP認証のために必要とされるいくつかのサービスを定義します。"
    },
    {
      "indent": 3,
      "text": "o Servers can bind a CPK with an identifier, such as an account name. Servers using HOBA define their own policies for binding CPKs with accounts during account registration.",
      "ja": "Oサーバは、このようなアカウント名として、識別子とCPKをバインドすることができます。 HOBAを使用するサーバはアカウント登録時にアカウントを持つCPKsを結合するための独自のポリシーを定義します。"
    },
    {
      "indent": 3,
      "text": "o Users are likely to use more than one device or User Agent (UA) for the same HTTP-based service, so HOBA gives a way to associate more than one CPK to the same account without having to register for each separately.",
      "ja": "Oユーザーが同じHTTPベースのサービスのために複数のデバイスまたはユーザーエージェント（UA）を使用する可能性があるので、HOBAは個別に登録することなく、同じアカウントに複数のCPKを関連付ける方法を提供します。"
    },
    {
      "indent": 3,
      "text": "o Logout features can be useful for UAs, so HOBA defines a way to close a current HTTP \"session\".",
      "ja": "HOBAは、現在のHTTP「セッション」をクローズする方法を定義するように、Oのログアウト機能は、UAのに役立ちます。"
    },
    {
      "indent": 3,
      "text": "o Digital signatures can be expensive to compute, so HOBA defines a way for HTTP servers to indicate how long a given challenge value is valid, and a way for UAs to fetch a fresh challenge at any time.",
      "ja": "Oデジタル署名を計算するために高価になることができますので、HOBAは、HTTPサーバが与えられたチャレンジ値が有効である時間の長さを示すための方法、およびUAがいつでも新鮮な挑戦を取得する方法を定義します。"
    },
    {
      "indent": 3,
      "text": "Users are also likely to lose a private key, or the client's memory of which key pair is associated with which origin, such as when a user loses the computer or mobile device in which state is stored. HOBA does not define a mechanism for deleting the association between an existing CPK and an account. Such a mechanism can be implemented at the application layer.",
      "ja": "また、ユーザーは鍵ペアが、そのようなユーザは、状態が保存されているパソコンや携帯端末を紛失したときのように、その起源に関連しているのプライベートキー、またはクライアントのメモリを失う可能性があります。 HOBA既存CPKとアカウントの間の関連付けを削除するためのメカニズムを定義していません。そのような機構は、アプリケーション層で実現することができます。"
    },
    {
      "indent": 3,
      "text": "The HOBA scheme is far from new; for example, the basic idea is pretty much identical to the first two messages from \"Mechanism R\" on page 6 of [MI93], which predates HOBA by 20 years.",
      "ja": "HOBA方式は、はるかに新しいからです。例えば、基本的な考え方はかなり同じ「メカニズムR」から最初の二つのメッセージに20年HOBAを先行し、[MI93]、の6ページです。"
    },
    {
      "indent": 0,
      "text": "1.1. Interfacing to Applications (Cookies)",
      "section_title": true,
      "ja": "1.1. アプリケーションへのインタフェース（クッキー）"
    },
    {
      "indent": 3,
      "text": "HOBA can be used as a drop-in replacement for password-based user authentication schemes used in common web applications. The simplest way is to (re)direct the UA to a HOBA \"Login\" URL and for the response to a successful HTTP request containing a HOBA signature to set a session cookie [RFC6265]. Further interactions with the web application will then be secured via the session cookie, as is commonly done today.",
      "ja": "HOBAは、一般的なWebアプリケーションで使用されるパスワードベースのユーザ認証スキームのドロップイン置換として使用することができます。最も簡単な方法は、（再）HOBA「ログイン」URLにUAを向けると、セッションクッキー[RFC6265]を設定するHOBA署名を含む成功したHTTPリクエストに対する応答です。現在一般的に行われているように、Webアプリケーションとのさらなる相互作用は、その後、セッションクッキーを経由して確保されます。"
    },
    {
      "indent": 3,
      "text": "While cookies are bearer tokens, and thus weaker than HOBA signatures, they are currently ubiquitously used. If non-bearer token session continuation schemes are developed in the future in the IETF or elsewhere, then those can interface to HOBA as easily as with any password-based authentication scheme.",
      "ja": "クッキーは、ベアラトークン、およびHOBA署名よりもので、弱いですが、彼らは現在、普遍的に使用されています。非ベアラトークンセッション継続方式が他の場所IETFまたは将来に開発されている場合、それらは、任意のパスワードベースの認証方式と同じように簡単HOBAにインターフェースすることができます。"
    },
    {
      "indent": 0,
      "text": "1.2. Terminology",
      "section_title": true,
      "ja": "1.2. 用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [RFC2119].",
      "ja": "キーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、 \"SHALL\"、 \"SHOULD\"、 \"ないもの\"、 \"推奨\" \"ない（SHOULD NOT）\"、 \"MAY\"、 \"推奨NOT\"、および「OPTIONAL RFC 2119 [RFC2119]に記載されているように「この文書に解釈されるべきです。"
    },
    {
      "indent": 3,
      "text": "This specification uses the Augmented Backus-Naur Form (ABNF) notation of [RFC5234].",
      "ja": "この仕様は、[RFC5234]の増補バッカス - ナウアフォーム（ABNF）の表記を使用します。"
    },
    {
      "indent": 3,
      "text": "Account: The term \"account\" is (loosely) used to refer to whatever data structure(s) the server maintains that are associated with an identity. That will contain at least one CPK and a web origin; it will also optionally include an HTTP \"realm\" as defined in the HTTP authentication specification [RFC7235]. It might also involve many other non-standard pieces of data that the server accumulates as part of account creation processes. An account may have many CPKs that are considered equivalent in terms of being usable for authentication, but the meaning of \"equivalent\" is really up to the server and is not defined here.",
      "ja": "アカウント：用語「アカウント」される（緩く）は、サーバがIDに関連付けられていると主張しているどんなデータ構造（複数可）を参照するために使用されます。それは、少なくとも一つのCPKとウェブ起源が含まれています。 HTTP認証仕様[RFC7235]で定義されるように、それはまた、必要に応じてHTTP「レルム」を含むであろう。また、サーバーは、アカウント作成プロセスの一部として蓄積したデータの他の多くの非標準的な部品を必要とするかもしれません。アカウントが認証のために使用可能であるという点で同等であると考えられる多くのCPKsがあるかもしれませんが、「同等」の意味は、サーバまで実際にあるとここで定義されていません。"
    },
    {
      "indent": 3,
      "text": "Client public key (CPK): A CPK is the public key and associated cryptographic parameters needed for a server to validate a signature.",
      "ja": "クライアント公開鍵（CPK）：CPKは、公開鍵と署名を検証するサーバーに必要な関連する暗号パラメータです。"
    },
    {
      "indent": 3,
      "text": "HOBA-http: We use this term when describing something that is specific to HOBA as an HTTP authentication mechanism.",
      "ja": "HOBA-HTTP：HTTP認証メカニズムとしてHOBAに固有の何かを説明するときに我々は、この用語を使用しています。"
    },
    {
      "indent": 3,
      "text": "HOBA-js: We use this term when describing something that is unrelated to HOBA-http but is relevant for HOBA as a design pattern that can be implemented in a browser in JavaScript.",
      "ja": "HOBA-JS：HOBA-HTTPとは無関係ですが、JavaScriptでブラウザに実装することができるデザインパターンとしてHOBAに関連する何かを説明するときに我々は、この用語を使用しています。"
    },
    {
      "indent": 3,
      "text": "User agent (UA): typically, but not always, a web browser.",
      "ja": "ユーザーエージェント（UA）：通常、常にではないが、Webブラウザ。"
    },
    {
      "indent": 3,
      "text": "User: a person who is running a UA. In this document, \"user\" does not mean \"user name\" or \"account name\".",
      "ja": "ユーザー：UAを実行している人。この文書では、「ユーザ」、「ユーザ名」または「アカウント名」を意味するものではありません。"
    },
    {
      "indent": 3,
      "text": "Web client: the content and JavaScript code that run within the context of a single UA instance (such as a tab in a web browser).",
      "ja": "（例えばWebブラウザでタブとして）単一UAインスタンスのコンテキスト内で実行コンテンツおよびJavaScriptコード：Webクライアント。"
    },
    {
      "indent": 0,
      "text": "1.3. Step-by-Step Overview of HOBA-http",
      "section_title": true,
      "ja": "1.3. ステップバイステップのHOBA-HTTPの概要"
    },
    {
      "indent": 3,
      "text": "Step-by-step, a typical HOBA-http registration and authentication flow might look like this:",
      "ja": "ステップバイステップ、典型的なHOBA-HTTPの登録と認証の流れは次のようになります。"
    },
    {
      "indent": 3,
      "text": "1. The client connects to the server and makes a request, and the server's response includes a WWW-Authenticate header field that contains the \"HOBA\" auth-scheme, along with associated parameters (see Section 3).",
      "ja": "1.クライアントがサーバに接続要求を行い、サーバの応答は、関連するパラメータ（セクション3を参照）とともに、「HOBA」AUTH-スキームを含んWWW-Authenticateヘッダフィールドを含みます。"
    },
    {
      "indent": 3,
      "text": "2. If the client was not already registered with the web origin and realm it is trying to access, the \"joining\" process is invoked (see Section 6.1). This creates a key pair and makes the CPK known to the server so that the server can carry out the account creation processes required.",
      "ja": "2.クライアントはすでにそれがアクセスしようとしているウェブ起源とレルムに登録されていない場合は、「参加する」プロセスは、（6.1節を参照）が呼び出されます。これは、鍵のペアを作成し、サーバが必要なアカウントの作成プロセスを実行できるように、サーバーに知られているCPKします。"
    },
    {
      "indent": 3,
      "text": "3. The client uses the challenge from the HOBA auth-scheme parameters, along with other information it knows about the web origin and realm, to create and sign a HOBA to-be-signed (HOBA-TBS) string (see Section 2).",
      "ja": "3.クライアントは、それがウェブ起源およびレルムについて知っている他の情報と一緒に、署名されHOBAを作成し、署名する（HOBA-TBS）の文字列をHOBAのauth-スキームのパラメータからのチャレンジを使用しています（第2章を参照してください） 。"
    },
    {
      "indent": 3,
      "text": "4. The client creates a HOBA client-result (HOBA-RES), using the signed HOBA-TBS for the \"sig\" value (see Section 2).",
      "ja": "4.クライアントは、 \"SIG\" の値（セクション2を参照）のために署名HOBA-TBSを用いて、HOBAクライアント結果（HOBA-RES）を作成します。"
    },
    {
      "indent": 3,
      "text": "5. The client includes the Authorization header field in its next request, using the \"HOBA\" auth-scheme and putting the HOBA client-result in an auth-param named \"result\" (see Section 3).",
      "ja": "5.クライアントが「HOBA」AUTH-スキームを使用し、「結果」という名前のauth-PARAMにHOBAクライアント結果を入れ、その次のリクエストにAuthorizationヘッダフィールドを含む（セクション3を参照）。"
    },
    {
      "indent": 3,
      "text": "6. The server authenticates the HOBA client-result (see Section 5.1).",
      "ja": "6.サーバーは、HOBAクライアント-結果を（5.1節を参照）を認証します。"
    },
    {
      "indent": 3,
      "text": "7. Typically, the server's response includes a session cookie that allows the client to indicate its authentication state in future requests (see Section 1.1).",
      "ja": "7.一般的には、サーバの応答は、クライアントが将来の要求（1.1項を参照）にその認証状態を示すことができますセッションCookieが含まれています。"
    },
    {
      "indent": 0,
      "text": "2. The HOBA Authentication Scheme",
      "section_title": true,
      "ja": "2. HOBA認証スキームに"
    },
    {
      "indent": 3,
      "text": "A UA that implements HOBA maintains a list of web origins and realms. The UA also maintains one or more client credentials for each web origin/realm combination for which it has created a CPK.",
      "ja": "HOBAを実装UAは、ウェブ起源とレルムのリストを維持します。 UAはまた、CPKを作成しているため、各ウェブ起源/レルムの組み合わせのために1つ以上のクライアントの資格情報を保持します。"
    },
    {
      "indent": 3,
      "text": "On receipt of a challenge (and optional realm) from a server, the client marshals a HOBA-TBS blob that includes a client generated nonce, the web origin, the realm, an identifier for the CPK, and the challenge string, and signs that blob with the private key corresponding to the CPK for that web origin. The formatting chosen for this TBS blob is chosen so as to make server-side signature verification as simple as possible for a wide range of current server tooling.",
      "ja": "サーバーからの挑戦（およびオプション領域）を受信すると、クライアントは、クライアントがナンス、ウェブ起源、分野、CPKの識別子、およびチャレンジ文字列、および徴候生成含みHOBA-TBSブロブをマーシャリングそのWeb起源のためCPKに対応する秘密鍵でブロブ。書式このTBSブロブのために選択されるが、現在のサーバーツーリング広範囲のできるだけ単純にサーバ側の署名検証を行うように選択されます。"
    },
    {
      "indent": 3,
      "text": "Figure 1 specifies the ABNF for the signature input. The term \"unreserved\" means that the field does not have a specific format defined and allows the characters specified in Section 2.3 of [RFC3986].",
      "ja": "図1は、署名入力のためのABNFを指定します。 「予約されていない」という用語は、フィールドが特定のフォーマットは、[RFC3986]のセクション2.3で指定された文字を定義し、可能にしていないことを意味します。"
    },
    {
      "indent": 6,
      "text": "HOBA-TBS = len \":\" nonce len \":\" alg len \":\" origin len \":\" [ realm ] len \":\" kid len \":\" challenge len = 1*DIGIT nonce = 1*base64urlchars alg = 1*2DIGIT origin = scheme \"://\" authority \":\" port ; scheme, etc., are from RFC 3986 realm = unreserved ; realm is to be treated as in Section 2.2 of RFC 7235 kid = 1*base64urlchars challenge = 1*base64urlchars ; Characters for Base64URL encoding from Table 2 of RFC 4648 ; all of which are US-ASCII (see RFC 20) base64urlchars = %x30-39 ; Digits / %x41-5A ; Uppercase letters / %x61-7A ; Lowercase letters / \"-\" / \"_\" / \"=\" ; Special characters",
      "ja": "HOBA-TBS = LEN \"：\" ナンスLEN \"：\" ALGさlen \"：\" 原点LEN \"：\" [領域] LEN \"：\" 子供lenは \"：\" 挑戦がlen = 1 * DIGITのナンスは= 1 * base64urlchars ALG = 1 * 2DIGIT起源=スキーム「：//」権威「：」ポート。スキームなど、予約されていないRFC 3986レルム=からのものです。レルムはRFC 7235の子供の2.2節と同様に処理される= 1 * base64urlcharsの挑戦= 1 * base64urlchars。 RFC 4648の表2からBase64URL符号化のための文字。それらの全ては、US-ASCII（RFC 20を参照）base64urlchars =％x30-39です。桁数/％x41-5A。大文字/％のx61-7A。英小文字/ \" - \" / \"_\" / \"=\";特殊文字"
    },
    {
      "indent": 19,
      "text": "Figure 1: To-Be-Signed Data for HOBA",
      "ja": "図1：HOBAために、署名されたデータ"
    },
    {
      "indent": 3,
      "text": "The fields above contain the following:",
      "ja": "上記のフィールドには、次が含まれています。"
    },
    {
      "indent": 3,
      "text": "o len: Each field is preceded by the number of octets of the following field, expressed as a decimal number in ASCII [RFC20]. Lengths are separated from field values by a colon character. So if a nonce with the value \"ABCD\" were used, then that would be preceeded by \"4:\" (see the example in Appendix B for details).",
      "ja": "O LEN：各フィールドは次のフィールドのオクテット数が先行する、[RFC20] ASCII 10進数として表現。長さはコロン文字によってフィールド値から分離されています。値「ABCD」とノンスを使用したのであれば、それはによって先行されるであろう「4」（詳細は付録Bの例を参照します）。"
    },
    {
      "indent": 3,
      "text": "o nonce: a random value chosen by the UA and MUST be base64url encoded before being included in the HOBA-TBS value. (base64url encoding is defined in [RFC4648]; guidelines for randomness are given in [RFC4086].) UAs MUST be able to use at least 32 bits of randomness in generating a nonce. UAs SHOULD be able to use 64 or more bits of randomness for nonces.",
      "ja": "Oナンス：及びUAによって選択されたランダム値がbase64urlはHOBA-TBS値に含まれる前に符号化されなければなりません。 （base64url符号化は[RFC4648]で定義され、ランダム性のためのガイドラインは、[RFC4086]に記載されている。）UAはnonceを生成する際にランダム性の少なくとも32ビットを使用できなければなりません。 UAは一回だけのためにランダムの64ビット以上を使用することができるはずです。"
    },
    {
      "indent": 3,
      "text": "o alg: specifies the signature algorithm being used. See Section 7 for details of algorithm support requirements. The IANA-registered algorithm values (see Section 9.3) are encoded as one-or two-digit ASCII numbers. For example, RSA-SHA256 (number 0) is encoded as the ASCII character \"0\" (0x30), while a future algorithm registered as number 17 would be encoded as the ASCII characters \"17\" (0x3137).",
      "ja": "ALG O：使用される署名アルゴリズムを指定します。アルゴリズムのサポート要件の詳細については、セクション7を参照してください。 IANAに登録アルゴリズム値（セクション9.3を参照）一または2桁のASCII番号として符号化されます。番号17として登録将来アルゴリズムはASCII文字「17」（0x3137）として符号化されるであろうしながら、例えば、RSA-SHA256（番号0）は、ASCII文字「0」（0x30から）として符号化されます。"
    },
    {
      "indent": 3,
      "text": "o origin: the web origin expressed as the concatenation of the scheme, authority, and port from [RFC3986]. These are not base64 encoded, as they will be most readily available to the server in plain text. For example, if accessing the URL \"https://www.example.com:8080/foo\", then the bytes input to the signature process will be \"https://www.example.com:8080\". There is no default for the port number, and the port number MUST be present.",
      "ja": "O起源：[RFC3986]からスキーム、権限、およびポートの連結として表現ウェブ原点。彼らはプレーンテキストでサーバに最も容易に利用できるようになりますように、これらは、base64エンコードではありません。例えば、「https://www.example.com:8080/foo」URLにアクセスする場合、署名処理にバイト入力が「https://www.example.com:8080」であろう。そこポート番号にはデフォルトはありません、とポート番号が存在しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o realm: a string with the syntactic restrictions defined in [RFC7235]. If no realm is specified for this authentication, then this is absent but is preceeded by a length of zero (\"0:\"). Recall that both sides know when this needs to be there, independent of the encoding via a zero length.",
      "ja": "O分野：[RFC7235]で定義された構文の制約を持つ文字列。何レルムはこの認証のために指定されていない場合、これは存在しないが、ゼロ（「0」）の長さだけ先行しています。ゼロ長さを介して符号化とは無関係に、これは存在する必要がある場合に双方が知っていることを思い出してください。"
    },
    {
      "indent": 3,
      "text": "o kid: a key identifier. This MUST be a base64url-encoded value that is presented to the server in the HOBA client result (see below).",
      "ja": "Oの子供：キー識別子。これは、HOBAクライアントの結果（下記参照）でサーバに提示されbase64urlエンコードされた値でなければなりません。"
    },
    {
      "indent": 3,
      "text": "o challenge: MUST be a base64url-encoded challenge value that the server chose to send to the client. The challenge MUST be chosen so that it is infeasible to guess and SHOULD be indistinguishable from (the base64url encoding of) a random string that is at least 128 bits long.",
      "ja": "Oの挑戦：サーバーがクライアントに送信することを選んだbase64urlエンコードされたチャレンジ値でなければなりません。推測することが不可能であると（のbase64url符号化）と区別できないになるような課題は、少なくとも128ビット長で、ランダムな文字列を選択しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The HOBA-TBS string is the input to the client's signing process but is not itself sent over the network since some fields are already inherent in the HTTP exchange. The challenge, however, is sent over the network so as to reduce the amount of state that needs to be maintained by servers. (One form of stateless challenge might be a ciphertext that the server decrypts and checks, but that is an implementation detail.) The value that is sent over the network by the UA is the HOBA \"client result\", which we now define.",
      "ja": "HOBA-TBS文字列は、クライアントの署名プロセスに入力されているが、いくつかのフィールドがすでにHTTP交換に固有のものであるため、それ自体は、ネットワークを介して送信されていません。サーバによって維持される必要がある状態の量を減少させるような課題は、しかし、ネットワークを介して送信されます。 （ステートレスな挑戦の一つの形態では、サーバが解読し、チェックした暗号文であるかもしれないが、それは実装の詳細である。）UAによってネットワーク上で送信される値は、我々が今定義HOBA「クライアント結果」、です。"
    },
    {
      "indent": 3,
      "text": "The HOBA \"client result\" is a dot-separated string that includes the signature and is sent in the HTTP Authorization header field value using the value syntax defined in Figure 2. The \"sig\" value is the base64url-encoded version of the binary output of the signing process. The kid, challenge, and nonce are as defined above and are also base64url encoded.",
      "ja": "HOBA「クライアント結果が」バイナリ出力のbase64url符号化されたバージョンの署名を含み、図2の「SIG」値で定義された値の構文を使用してHTTP Authorizationヘッダフィールド値で送信され、ドットで区切られた文字列であります署名プロセスの。子供、挑戦、およびナンスは、上記で定義した通りであり、またbase64urlエンコードされています。"
    },
    {
      "indent": 6,
      "text": "HOBA-RES = kid \".\" challenge \".\" nonce \".\" sig sig = 1*base64urlchars",
      "ja": "HOBA-RES =キッド \"\"挑戦「」ナンス「」 SIG SIG = 1 * base64urlchars"
    },
    {
      "indent": 20,
      "text": "Figure 2: HOBA Client Result Value",
      "ja": "図2：HOBAクライアントの結果値"
    },
    {
      "indent": 3,
      "text": "If a malformed message of any kind is received by a server, the server MUST fail authentication. If a malformed message of any kind is received by a client, the client MUST abandon that authentication attempt. (The client is, of course, free to start another authentication attempt if it desires.)",
      "ja": "あらゆる種類の不正な形式のメッセージは、サーバによって受信された場合、サーバーは認証が失敗しなければなりません。あらゆる種類の不正な形式のメッセージがクライアントによって受信された場合、クライアントはその認証の試みを放棄しなければなりません。 （クライアントは、それが希望する場合は、別の認証の試みを開始するには、もちろん、無料です。）"
    },
    {
      "indent": 0,
      "text": "3. Introduction to the HOBA-http Mechanism",
      "section_title": true,
      "ja": "HOBA-HTTPメカニズム3.入門"
    },
    {
      "indent": 3,
      "text": "An HTTP server that supports HOBA authentication includes the \"HOBA\" auth-scheme value in a WWW-Authenticate header field when it wants the client to authenticate with HOBA. Note that the HOBA auth-scheme might not be the only one that the server includes in a WWW-Authenticate header.",
      "ja": "それは、クライアントがHOBAで認証したい場合HOBA認証をサポートしているHTTPサーバがWWW-Authenticateヘッダフィールドに「HOBA」のauth-スキーム値を含んでいます。 HOBAのAUTH-スキームは、サーバがWWW-Authenticateヘッダに含むだけではないかもしれないことに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "The HOBA scheme has two REQUIRED attributes (challenge and max-age) and one OPTIONAL attribute (realm):",
      "ja": "HOBAスキーム2つの必須属性（挑戦とmax-歳）と1つのオプション属性（レルム）があります。"
    },
    {
      "indent": 3,
      "text": "o The \"challenge\" attribute MUST be included. The challenge is the string made up of the base64url-encoded octets that the server wants the client to sign in its response. The challenge MUST be unique for every 401 HTTP response in order to prevent replay attacks from passive observers.",
      "ja": "O「挑戦」属性を含まなければなりません。課題は、サーバは、クライアントがその応答に署名することを望んでいるbase64urlエンコードされたオクテットで構成された文字列です。課題は、受動的なオブザーバーからのリプレイ攻撃を防止するために、すべての401 HTTP応答のためのユニークでなければなりません。"
    },
    {
      "indent": 3,
      "text": "o A \"max-age\" attribute MUST be included. It specifies the number of seconds from the time the HTTP response is emitted for which responses to this challenge can be accepted; for example, \"max-age: 10\" would indicate ten seconds. If max-age is set to zero, then that means that only one signature will be accepted for this challenge.",
      "ja": "o「の最大エージング」属性を含まなければなりません。これは、この課題への対応を受け入れることができたためにHTTPレスポンスが放出された時からの秒数を指定します。例えば、「最大エージング：10は」10秒を示すことになります。最大エージングがゼロに設定されている場合は、それが唯一の署名がこの挑戦のために受理されることを意味します。"
    },
    {
      "indent": 3,
      "text": "o A \"realm\" attribute MAY be included to indicate the scope of protection in the manner described in HTTP/1.1, Authentication [RFC7235]. The \"realm\" attribute MUST NOT appear more than once.",
      "ja": "O「レルム」属性は、HTTP / 1.1、認証[RFC7235]に記載された方法で保護の範囲を示すために含まれるかもしれません。 「領域」属性が複数回出現することはできません。"
    },
    {
      "indent": 3,
      "text": "When the \"client response\" is created, the UA encodes the HOBA client-result and returns that in the Authorization header. The client-result is a string matching the HOBA-RES production in Figure 2 as an auth-param with the name \"result\".",
      "ja": "「クライアント応答が」作成されたときに、UAは、HOBAクライアント結果を符号化し、Authorizationヘッダにそれを返します。クライアントの結果は、名前「結果」でのauth-のparamとして図2のHOBA-RES生産にマッチする文字列です。"
    },
    {
      "indent": 3,
      "text": "The server MUST check the cryptographic correctness of the signature based on a public key it knows for the kid in the signatures, and if the server cannot do that, or if the signature fails cryptographic checks, then validation has failed. The server can use any additional mechanisms to validate the signature. If the validation fails, or if the server chooses to reject the signature for any reason whatsoever, the server fails the request with a 401 Unauthorized HTTP response.",
      "ja": "その後、検証が失敗した、サーバはそれが署名にいる子供のために知っている公開鍵に基づいて署名の暗号正しさをチェックしなければなりませんし、サーバーはそれを行うことができない場合、または署名、暗号化のチェックを失敗した場合。サーバは、署名を検証するために追加のメカニズムを使用することができます。検証が失敗した場合、またはサーバがいかなる理由で署名を拒否することを選択した場合、サーバは401権限HTTP応答で要求を失敗した場合。"
    },
    {
      "indent": 3,
      "text": "The server MUST check that the same web origin is used in all of the server's TLS server certificates, the URL being accessed, and the HOBA signature. If any of those checks fail, the server treats the signature as being cryptographically incorrect.",
      "ja": "サーバーは、同じWeb原点は、サーバーのTLSサーバ証明書、アクセスされているURL、およびHOBA署名のすべてで使用されていることをチェックしなければなりません。これらのチェックのいずれかが失敗した場合、サーバーは、暗号不正確であるとして署名を扱います。"
    },
    {
      "indent": 3,
      "text": "Note that a HOBA signature is good for however long a non-zero max-age parameter allows. This means that replay is possible within the time window specified by the \"max-age\" value chosen by the server. Servers can attempt to detect any such replay (via caching if they so choose) and MAY react to such replays by responding with a second (or subsequent) 401 HTTP response containing a new challenge.",
      "ja": "HOBA署名が非ゼロの最大エージングパラメータができますが長いために良好であることに注意してください。これは、リプレイがサーバによって選ばれた「MAX-年齢」の値によって指定された時間ウィンドウ内で可能であることを意味しています。サーバは（彼らがそう選択した場合、キャッシュを経由して）、そのようなリプレイの検出を試みることができ、新たな挑戦を含む第二（またはそれ以降）401 HTTPレスポンスで応答することにより、このようなリプレイに反応することができます。"
    },
    {
      "indent": 3,
      "text": "To optimize their use of challenges, UAs MAY prefetch a challenge value, for example, after (max-age)/2 seconds have elapsed, using the \".well-known/hoba/getchal\" scheme described later in this document. This also allows for precalculation of HOBA signatures, if that is required in order to produce a responsive user interface.",
      "ja": "課題の使用を最適化するために、UAはチャレンジ値をプリフェッチ、例えば、（最大エージング）/ 2までの秒は、このドキュメントで後述する「.well知ら/ HOBA / getchal」スキームを使用して、経過しています。それが応答し、ユーザインタフェースを生成するために必要とされる場合にも、HOBA署名の事前計算を可能にします。"
    },
    {
      "indent": 0,
      "text": "4. Introduction to the HOBA-js Mechanism",
      "section_title": true,
      "ja": "HOBA-jsのメカニズム4.入門"
    },
    {
      "indent": 3,
      "text": "Web sites using JavaScript can also perform origin-bound authentication without needing to involve the HTTP layer and by inference not needing HOBA-http support in browsers. HOBA-js is not an on-the-wire protocol like HOBA-http is; instead, it is a design pattern that can be realized completely in JavaScript served in normal HTML pages.",
      "ja": "JavaScriptを使用してWebサイトもブラウザでHOBA-HTTPはサポートを必要としないHTTP層が関与しなくても、と推論によって、原点結合認証を行うことができます。 HOBA-jsがHOBA-HTTPのようなオン・ザ・ワイヤプロトコルではありません。代わりに、それは通常のHTMLページで提供していますJavaScriptで完全に実現することが可能な設計パターンです。"
    },
    {
      "indent": 3,
      "text": "One thing that is highly desirable for HOBA-js is WebCrypto (see <http://www.w3.org/TR/WebCryptoAPI>), which is (at the time of writing) starting to see deployment. In lieu of WebCrypto, JavaScript crypto libraries can be employed with the known deficiencies of their pseudo-random number generators and the general immaturity of those libraries.",
      "ja": "HOBA-jsのために非常に望ましいことの一つは、展開を見始め（執筆時点で）であるWebCrypto（<http://www.w3.org/TR/WebCryptoAPI>参照）、です。 WebCryptoの代わりに、JavaScriptの暗号ライブラリは、その擬似乱数生成器の既知の欠陥およびそれらのライブラリの一般的な未熟さで使用することができます。"
    },
    {
      "indent": 3,
      "text": "Without Webcrypto, one element is required for HOBA-js; localStorage (see <http://www.w3.org/TR/webstorage/>) from HTML5 can be used for persistent key storage. For example, an implementation would store a dictionary account identifier as well as public key and private key tuples in the origin's localStorage for subsequent authentication requests. How this information is actually stored in localStorage is an implementation detail. This type of key storage relies on the security properties of the same-origin policy that localStorage enforces. See the security considerations for discussion about attacks on localStorage. Note that IndexedDB (see <http://www.w3.org/TR/IndexedDB/>) is an alternative to localStorage that can also be used here and that is used by WebCrypto.",
      "ja": "Webcryptoがなければ、一つの要素は、HOBA-jsのために必要です。 HTML5のlocalStorageからは（<http://www.w3.org/TR/webstorage/>参照）永続的な鍵保管のために使用することができます。例えば、実装は、後続の認証要求の発信元ののlocalStorageで辞書アカウント識別子だけでなく、公開鍵と秘密鍵の組を格納します。この情報は実際のlocalStorageに保存されているどのように実装の詳細です。キーストレージのこのタイプのlocalStorageが強制同一生成元ポリシーのセキュリティ特性に依存しています。 localStorageへの攻撃についての議論のためのセキュリティの考慮事項を参照してください。 IndexedDBは（<http://www.w3.org/TR/IndexedDB/>参照）もここで使用でき、WebCryptoで使用されているのlocalStorageに代わるものであることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Because of JavaScript's same-origin policy, scripts from subdomains do not have access to the same localStorage that scripts in their parent domains do. For larger or more complex sites, this could be an issue that requires enrollment into subdomains, which could be difficult for users. One way to get around this is to use session cookies because they can be used across subdomains. That is, with HOBA-js, the user might log in using a single well-known domain, and then session cookies are used whilst the user navigates around the site.",
      "ja": "JavaScriptの者の同一生成元ポリシーのなので、サブドメインからのスクリプトは、親ドメイン内のスクリプトが行うのと同じのlocalStorageにアクセスすることはできません。より大きなまたはより複雑なサイトの場合、これはユーザーのために困難になる可能性がサブドメインに登録を必要とする問題である可能性があります。これを回避する一つの方法は、彼らがサブドメインにまたがって使用することができますので、セッションクッキーを使用することです。それはHOBA-JSと、ユーザーは単一のよく知られたドメインを使用してログイン可能性があり、ユーザーがサイトを中心にナビゲートしながら、セッションクッキーが使用されている、です。"
    },
    {
      "indent": 0,
      "text": "5. HOBA's Authentication Process",
      "section_title": true,
      "ja": "5. HOBAの認証プロセス"
    },
    {
      "indent": 3,
      "text": "This section describes how clients and servers use HOBA for authentication. The interaction between an HTTP client and HTTP server using HOBA happens in three phases: the CPK preparation phase, the signing phase, and the authentication phase. This section also covers the actions that give HOBA features similar to today's password-based schemes.",
      "ja": "このセクションでは、クライアントとサーバが認証にHOBAを使用する方法について説明します。 CPKの準備段階、署名相、および認証フェーズ：HOBAを使用してHTTPクライアントとHTTPサーバの間の相互作用は、3つのフェーズで発生します。また、このセクションでは、HOBAは、今日のパスワードベースのスキームと同様の特徴与えるアクションをカバーしています。"
    },
    {
      "indent": 0,
      "text": "5.1. CPK Preparation Phase",
      "section_title": true,
      "ja": "5.1.  CPK準備フェーズ"
    },
    {
      "indent": 3,
      "text": "In the CPK preparation phase, the client determines if it already has a CPK for the web origin with which it needs to authenticate. If the client has a CPK, the client will use it; if the client does not have a CPK, it generates one in anticipation of the server asking for one.",
      "ja": "それはすでにそれが認証する必要のあるウェブ原点CPKを持っている場合CPK準備フェーズでは、クライアントが決定します。クライアントは、CPKを持っている場合、クライアントはそれを使用します。クライアントは、CPKを持っていない場合、それは1を求めてサーバーを見越して1を生成します。"
    },
    {
      "indent": 0,
      "text": "5.2. Signing Phase",
      "section_title": true,
      "ja": "5.2. 署名フェーズ"
    },
    {
      "indent": 3,
      "text": "In the signing phase, the client connects to the server, the server asks for HOBA-based authentication, and the client authenticates by signing a blob of information as described in the previous sections.",
      "ja": "署名フェーズでは、クライアントがサーバに接続し、サーバは、HOBAベースの認証を要求し、クライアントは、前のセクションで説明したように情報のブロブに署名することによって認証します。"
    },
    {
      "indent": 0,
      "text": "5.3. Authentication Phase",
      "section_title": true,
      "ja": "5.3. 認証フェーズ"
    },
    {
      "indent": 3,
      "text": "The authentication phase is completely dependent on the policies and practices of the server. That is, this phase involves no standardized protocol in HOBA-http; in HOBA-js, there is no suggested interaction template.",
      "ja": "認証フェーズでは、サーバーの政策や慣行に完全に依存しています。すなわち、この段階は、HOBA-HTTPには標準化されたプロトコルを伴いません。 HOBA-jsの中で、推奨される相互作用のテンプレートはありません。"
    },
    {
      "indent": 3,
      "text": "In the authentication phase, the server uses the key identifier (kid) to determine the CPK from the signing phase and decides if it recognizes the CPK. If the server recognizes the CPK, the server may finish the client authentication process.",
      "ja": "認証フェーズでは、サーバは、署名相からCPKを決定するためにキー識別子（子供）を使用し、それがCPKを認識した場合を決定します。サーバーは、CPKを認識した場合、サーバはクライアントの認証プロセスを終了してもよいです。"
    },
    {
      "indent": 3,
      "text": "If this stage of the process involves additional information for authentication, such as asking the user which account she wants to use (in the case where a UA is used for multiple accounts on a site), the server can prompt the user for account identifying information, or the user could choose based on HTML offered by the server before the 401 response is triggered. None of this is standardized: it all follows the server's security policy and session flow. At the end of this, the server probably assigns or updates a session cookie for the client.",
      "ja": "プロセスのこの段階は、そのような彼女が（UAは、サイト上で複数のアカウントのために使用されている場合）を使用したいアカウントをユーザに問い合わせるなどの認証のための追加的な情報を、必要とする場合は、サーバーは、アカウント識別情報の入力をユーザーに促すことができます、またはユーザーが401応答がトリガされる前に、サーバーによって提供されるHTMLに基づいて選択することができます。これのどれも標準化されていない：それはすべてのサーバーのセキュリティポリシーおよびセッションの流れに従っています。このの終わりには、サーバーはおそらく割り当てまたはクライアントのセッションCookieを更新します。"
    },
    {
      "indent": 3,
      "text": "During the authentication phase, if the server cannot determine the correct CPK, it could use HTML and JavaScript to ask the user if they are really a new user or want to associate this new CPK with another CPK. The server can then use some out-of-band method (such as a confirmation email round trip, SMS, or a UA that is already enrolled) to verify that the \"new\" user is the same as the already-enrolled one. Thus, logging in on a new UA is identical to logging in with an existing account.",
      "ja": "サーバーが正しいCPKを判断できない場合は、認証フェーズの間、それは彼らが本当に新しいユーザーであるか、または別のCPKと、この新しいCPKを関連付けたい場合は、ユーザーに依頼するHTMLとJavaScriptを使用することができます。その後、サーバは、「新しい」ユーザーが既に登録したものと同じであることを確認するために（例えば、既に登録されて確認メールの往復、SMS、またはUAなど）いくつかのアウトオブバンド方式を使用することができます。このように、新しいUAにログインすると、既存のアカウントでログインすると同じです。"
    },
    {
      "indent": 3,
      "text": "If the server does not recognize the CPK, the server might send the client through either a join or login-new-UA (see below) process. This process is completely up to the server and probably entails using HTML and JavaScript to ask the user some questions in order to assess whether or not the server wants to give the client an account. Completion of the joining process might require confirmation by email, SMS, CAPTCHA, and so on.",
      "ja": "サーバーは、CPKを認識しない場合は、サーバーのいずれかに参加またはログイン新しい-UA（下記参照）のプロセスを介してクライアントに送信することがあります。このプロセスは完全にサーバーまでですと、おそらく、サーバーがクライアントにアカウントを与えることを望んでいるかどうかを評価するために、ユーザにいくつかの質問をするHTMLとJavaScriptを使用して伴います。接合プロセスの完了はように、電子メール、SMS、CAPTCHAによる確認を必要とすることがあります。"
    },
    {
      "indent": 3,
      "text": "Note that there is no necessity for the server to initiate a joining or login process upon completion of the signing phase. Indeed, the server may desire to challenge the UA even for unprotected resources and set a session cookie for later use in a join or login process as it becomes necessary. For example, a server might only want to offer an account to someone who had been to a few pages on the web site; in such a case, the server could use the CPK from an associated session cookie as a way of building reputation for the user until the server wants the user to join.",
      "ja": "署名フェーズの完了時に接合またはログインプロセスを開始するサーバーの必要がないことに留意されたいです。確かに、サーバーでも保護されていないリソースのためのUAに挑戦し、それが必要になるとして参加したり、ログイン後のプロセスで使用するためにセッションクッキーを設定することを望むかもしれません。例えば、サーバは、Webサイト上のいくつかのページになっていた誰かにアカウントを提供する場合があります。サーバは、ユーザが参加することを望んでいるまで、このような場合には、サーバはユーザのための評判を構築する方法として、関連するセッションクッキーからCPKを使用することができます。"
    },
    {
      "indent": 0,
      "text": "6. Other Parts of the HOBA Process",
      "section_title": true,
      "ja": "HOBAプロセス6.その他のパーツ"
    },
    {
      "indent": 3,
      "text": "The authentication process is more than just the act of authentication. In password-based authentication and HOBA, there are other processes that are needed both before and after an authentication step. This section covers those processes. Where possible, it combines practices of HOBA-http and HOBA-js; where that is not possible, the differences are called out.",
      "ja": "認証プロセスは、認証だけの行為以上のものです。パスワードベースの認証とHOBAでは、認証ステップの前と後の両方に必要とされている他のプロセスがあります。このセクションでは、これらのプロセスをカバーしています。可能であれば、それはHOBA-httpとHOBA-jsからの実践を兼ね備え、それが不可能な場合は、違いが出て呼ばれています。"
    },
    {
      "indent": 3,
      "text": "All HOBA interactions other than those defined in Section 5 MUST be performed in TLS-protected sessions [RFC5246]. If the current HTTP traffic is not running under TLS, a new session is started before any of the actions described here are performed.",
      "ja": "セクション5で定義されたもの以外の全てのHOBA相互作用はTLSで保護されたセッション[RFC5246]で行われなければなりません。現在のHTTPトラフィックがTLSで実行されていない場合は、ここで説明されているアクションのいずれかが実行される前に、新しいセッションが開始されます。"
    },
    {
      "indent": 3,
      "text": "HOBA-http uses a well-known URI [RFC5785] \"hoba\" as a base URI for performing many tasks: \"https://www.example.com/.well-known/hoba\". These URIs are based on the name of the host that the HTTP client is accessing.",
      "ja": "HOBA-HTTP多くのタスクを行うためのベースURIとしてよく知られているURI [RFC5785] \"HOBA\" を使用しています： \"https://www.example.com/.well-known/hoba\" を。これらのURIは、HTTPクライアントがアクセスしているホストの名前に基づいています。"
    },
    {
      "indent": 3,
      "text": "There are many use cases for these URLs to redirect to other URLs: a site that does registration through a federated site, a site that only does registration under HTTPS, and so on. Like any HTTP client, HOBA-http clients have to be able to handle redirection of these requests. However, as that would potentially cause security issues when a re-direct brings the client to a different web origin, servers implementing HOBA-http SHOULD NOT redirect to a different web origin from below \".well-known/hoba\" URLs. The above is considered sufficient to allow experimentation with HOBA, but if at some point HOBA is placed on the Standards Track, then a full analysis of off-origin redirections would need to be documented.",
      "ja": "これらのURLは他のURLにリダイレクトするための多くのユースケースがありますので、上の連合サイトを通じて登録を行い、サイト、HTTPSのみに基づく登録を行い、サイト、および。任意のHTTPクライアントのように、HOBA-HTTPクライアントは、これらの要求のリダイレクトを処理できるようにする必要があります。リダイレクトが異なるウェブ原点にクライアントをもたらしたときには、潜在的にセキュリティ上の問題を引き起こすようしかし、HOBA-HTTPを実装したサーバは、「.well知ら/ HOBA」のURLの下から別のWeb原点にリダイレクトすべきではありません。上記HOBAでの実験を可能にするのに十分と考えられているが、いくつかの点でHOBAが標準化過程の上に置かれた場合、その後、オフ原点リダイレクトの完全な分析を文書化する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.1. Registration",
      "section_title": true,
      "ja": "6.1. 登録"
    },
    {
      "indent": 3,
      "text": "Normally, a registration (also called \"joining\") is expected to happen after a UA receives a 401 response for a web origin and realm (for HOBA-http) or on demand (for HOBA-js) for which it has no associated CPK. The process of registration for a HOBA account on a server is relatively lightweight. The UA generates a new key pair and associates it with the web origin/realm in question.",
      "ja": "通常は、（また、「参加する」と呼ばれる）の登録は、UAが（HOBA-JSのために）（HOBA-HTTP用）ウェブ起源とレルムまたはオンデマンドで401応答を受信した後に発生することが予想され、それには関連するCPKを持たないために。サーバー上のHOBAアカウントの登録のプロセスは比較的軽量です。 UAは、新しい鍵ペアを生成し、問題のウェブ起源/領域に関連付けます。"
    },
    {
      "indent": 3,
      "text": "Note that if the UA has a CPK associated with the web origin, but not for the realm concerned, then a new registration is REQUIRED. If the server did not wish for that outcome, then it ought to use the same or no realm.",
      "ja": "UAは、ウェブの原点に関連付けられているCPKを持っていますが、関係するレルムの後、新規登録が要求されない場合があります。サーバーは、その結果をご希望されなかった場合、それは同じ、あるいは全くレルムを使用するべきです。"
    },
    {
      "indent": 3,
      "text": "The registration message for HOBA-http is sent as a POST message to the URL \".well-known/hoba/register\" with an HTML form (x-www-form-encoded, see <http://www.w3.org/TR/2014/REC-html5-20141028/ forms.html#url-encoded-form-data>), described below. The registration message for HOBA-js can be in any format specified by the server, but it could be the same as the one described here for HOBA-http. It is up to the server to decide what kind of user interaction is required before the account is finally set up. When the server's chosen registration flow is completed successfully, the server MUST add a Hobareg HTTP header (see Section 6.1.1) to the HTTP response message that completes the registration flow.",
      "ja": "HOBA-HTTPの登録メッセージはHTMLフォームで \".well知ら/ HOBA /登録\" URLにPOSTメッセージとして送信される（X-WWW-形態エンコード、参照<http://www.w3.org / TR / 2014 / REC-html5-20141028 / forms.html＃URLエンコード形式データ>）、以下に説明します。 HOBA-jsからの登録メッセージは、サーバによって指定された任意の形式にすることができますが、それはHOBA-HTTPのために、ここで説明したものと同じである可能性があります。これは、アカウントが最終的に設定される前に必要とされるユーザインタラクションの種類を決定するために、サーバー次第です。サーバの選択された登録フローが正常に完了すると、サーバは、登録フローを終了するHTTP応答メッセージに（セクション6.1.1参照）Hobareg HTTPヘッダーを追加しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The registration message sent to the server has one mandatory field (pub) and some optional fields that allow the UA to specify the type and value of key and device identifiers that the UA wishes to use.",
      "ja": "サーバに送信された登録メッセージは、1つの必須フィールド（パブ）とUAは、UAが使用したいキーとデバイス識別子の型と値を指定することができ、いくつかのオプションのフィールドを有しています。"
    },
    {
      "indent": 3,
      "text": "o pub: a mandatory field containing the Privacy Enhanced Mail (PEM) formatted public key of the client. See Appendix C of [RFC6376] for an example of how to generate this key format.",
      "ja": "Oパブ：プライバシー強化メール（PEM）を含む必須フィールドは、クライアントの公開鍵をフォーマットされました。このキーフォーマットを生成する方法の例については、付録Cの[RFC6376]を参照。"
    },
    {
      "indent": 3,
      "text": "o kidtype: contains the type of key identifier. This is a numeric value intended to contain one of the values from Section 9.4. If this is not present, then the mandatory-to-implement hashed public key option MUST be used.",
      "ja": "Oのkidtypeは：キー識別子の種類が含まれています。これは、セクション9.4からの値のいずれかを含むことを意図した数値です。これが存在しない場合、実装に必須のハッシュされた公開鍵のオプションを使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o kid: contains the key identifier as a base64url-encoded string that is of the type indicated in the kidtype. If the kid is a hash of a public key, then the correct (base64url-encoded) hash value MUST be provided and the server SHOULD check that and refuse the registration if an incorrect value was supplied.",
      "ja": "O子供は：kidtypeに示されるタイプのものであるbase64urlエンコードされた文字列としてキー識別子を含みます。子供は、公開鍵のハッシュである場合には、正しい（base64urlエンコードされた）ハッシュ値を提供しなければなりませんし、サーバーはそれをチェックし、不正な値が指定された場合は、登録を拒否すべきです。"
    },
    {
      "indent": 3,
      "text": "o didtype: specifies a kind of device identifier intended to contain one of the values from Section 9.5. If absent, then the \"string\" form of device identifier defined in Section 9.5 MUST be used.",
      "ja": "didtype O：9.5節からの値のいずれかを含むように意図されたデバイス識別子の種類を指定します。存在しない場合には、セクション9.5で定義されたデバイス識別子の「文字列」の形式を使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o did: a UTF-8 string that specifies the device identifier. This can be used to help a user be confident that authentication has worked, e.g., following authentication, some web content might say \"You last logged in from device 'did' at time T.\"",
      "ja": "Oました：デバイス識別子を指定するUTF-8文字列を。これにより、ユーザは認証が認証以下、例えば、働いていることを確信することを支援するために使用することができ、いくつかのWebコンテンツは、「時間Tであなたが最後のデバイスからログイン 『でした』」と言うかもしれません"
    },
    {
      "indent": 3,
      "text": "Note that replay of registration (and other HOBA) messages is quite possible. That, however, can be counteracted if challenge freshness is ensured. See Section 2 for details. Note also that with HOBA-http, the HOBA signature does not cover the POST message body. If that is required, then HOBA-JS may be a better fit for registration and other account management actions.",
      "ja": "登録（および他のHOBA）メッセージの再生が十分に可能であることに注意してください。チャレンジ新鮮さが確保された場合には、しかし、相殺することができます。詳細については、第2節を参照してください。また、HOBA-HTTPとなお、HOBA署名は、POSTメッセージ本体を覆っていません。それが必要な場合は、HOBA-JSは、登録および他のアカウント管理操作のためのより良いフィットかもしれません。"
    },
    {
      "indent": 0,
      "text": "6.1.1. Hobareg Definition",
      "section_title": true,
      "ja": "6.1.1.  Hobareg定義"
    },
    {
      "indent": 3,
      "text": "Since registration can often be a multi-step process, e.g., requiring a user to fill in contact details, the initial response to the HTTP POST message defined above may not be the end of the registration process even though the HTTP response has a 200 OK status. This creates an issue for the UA since, during the registration process (e.g., while dealing with interstitial pages), the UA doesn't yet know whether the CPK is good for that web origin or not.",
      "ja": "登録はしばしばコンタクトの詳細を入力するようにユーザに要求する、例えば、多段階プロセスであることができるので、上記で定義されたHTTP POSTメッセージに対する最初の応答はHTTP応答がOK 200を有しているにもかかわらず、登録プロセスの終わりではないかもしれません状態。これは、以来、UAのための問題を作成し、登録プロセス（例えば、間質ページに対処しながら、）の間に、UAはまだCPKは、そのウェブ原点か良いかどうかを知りません。"
    },
    {
      "indent": 3,
      "text": "For this reason, the server MUST add a header field to the response message when the registration has succeeded in order to indicate the new state. The header to be used is \"Hobareg\", and the value when registration has succeeded is to be \"regok\". When registration is in an intermediate state (e.g., on an HTTP response for an interstitial page), the server MAY add this header with a value of \"reginwork\". See Section 9.6 for the relevant IANA registration of this header field.",
      "ja": "登録が新しい状態を示すために、成功したときに、このような理由から、サーバが応答メッセージにヘッダフィールドを追加しなければなりません。使用されるべきヘッダが「Hobareg」であり、登録が成功した値が「regok」となります。登録が中間状態にあるとき（例えば、インタースティシャルページに対するHTTP応答に）、サーバは「reginwork」の値と、このヘッダを加えるかもしれ。このヘッダフィールドの関連するIANA登録については、セクション9.6を参照してください。"
    },
    {
      "indent": 3,
      "text": "For interstitial pages, the client MAY include a HOBA Authorization header. This is not considered a \"MUST\", as that might needlessly complicate client implementations, but is noted here in case a server implementer assumes that all registration messages contain a HOBA Authorization header.",
      "ja": "間質ページの場合、クライアントは、HOBA Authorizationヘッダーを含むかもしれません。これは、それが不クライアントの実装を複雑かもしれないとして、「MUST」とはみなされませんが、サーバーの実装は、すべての登録メッセージがHOBA Authorizationヘッダーが含まれていることを前提とした場合には、ここで注目されます。"
    },
    {
      "indent": 6,
      "text": "Hobareg-val = \"regok\" / \"reginwork\"",
      "ja": "Hobareg-WAL = \"Regok\" / \"Reginwark\""
    },
    {
      "indent": 17,
      "text": "Figure 3: Hobareg Header Field Definition",
      "ja": "図3：Hobaregヘッダーフィールドの定義"
    },
    {
      "indent": 3,
      "text": "Figure 3 provides an ABNF definition for the values allowed in the Hobareg header field. Note that these (and the header field name) are case insensitive. Section 8.3.1 of [RFC7231] calls for documenting the following details for this new header field:",
      "ja": "図3は、Hobaregヘッダフィールドで許可値についてABNFの定義を提供します。これらの（ヘッダフィールド名）が大文字小文字を区別しないことに留意されたいです。 [RFC7231]のセクション8.3.1は、この新しいヘッダフィールドに次の詳細を文書化するために呼び出します。"
    },
    {
      "indent": 3,
      "text": "o Only one single value is allowed in a Hobareg header field. Should more than one (a list) be encountered, or any other ABNF-invalid value, that SHOULD be interpreted as being the same as \"reginwork\".",
      "ja": "Oつだけの単一値をHobaregヘッダフィールドで許可されています。複数（リスト）に遭遇すること、または「reginwork」と同じものとして解釈されるべきであり、他のABNF-無効な値、すべきです。"
    },
    {
      "indent": 3,
      "text": "o The Hobareg header field can only be used in HTTP responses.",
      "ja": "O Hobaregヘッダフィールドは、HTTP応答に使用することができます。"
    },
    {
      "indent": 3,
      "text": "o Since Hobareg is only meant for responses, it ought not appear in requests.",
      "ja": "Hobaregが回答だけのためのものですので、O、それは要求には表示されないはずです。"
    },
    {
      "indent": 3,
      "text": "o The HTTP response code does affect the interpretation of Hobareg. Registration is only considered to have succeeded if the regok value is seen in a 2xx response. 4xx and other errors mean that registration has failed regardless of the value of Hobareg seen. The request method has no influence on the interpretation of Hobareg.",
      "ja": "O HTTPレスポンスコードがHobaregの解釈に影響を与えません。登録は唯一regok値が2xx応答で見られる場合は成功したと考えられています。 4XXや他のエラーは、登録に関係なく見Hobaregの値を失敗したことを意味します。リクエストメソッドはHobaregの解釈に影響を与えません。"
    },
    {
      "indent": 3,
      "text": "o Intermediaries never insert, delete, or modify a Hobareg header field.",
      "ja": "O仲介は、挿入しないで、削除、またはHobaregヘッダフィールドを変更しません。"
    },
    {
      "indent": 3,
      "text": "o As a response-only header field, it is not appropriate to list a Hobareg in a Vary response header field.",
      "ja": "O応答専用ヘッダフィールドとして、変化レスポンスヘッダフィールドにHobaregを一覧表示することは適切ではありません。"
    },
    {
      "indent": 3,
      "text": "o Hobareg is allowed in trailers.",
      "ja": "O Hobaregはトレーラーで許可されています。"
    },
    {
      "indent": 3,
      "text": "o As a response-only header field, Hobareg will not be preserved across re-directs.",
      "ja": "応答専用ヘッダフィールドとしてO、Hobaregはリダイレクトを横切って保存されません。"
    },
    {
      "indent": 3,
      "text": "o Hobareg itself discloses little security- or privacy-sensitive information. If an attacker can somehow detect that a Hobareg header field is being added, then that attacker would know that the UA is in the process of registration, which could be significant. However, it is likely that the set of messages between the UA and server would expose this information in many cases, regardless of whether or not TLS is used. Using TLS is still, however, a good plan.",
      "ja": "O Hobareg自体がほとんどないセキュリティやプライバシーに機密情報を開示しています。攻撃者が何らかの方法Hobaregヘッダフィールドが追加されていることを検出することができる場合、その攻撃者が重要である可能性があり、UAが登録中であることを知っているであろう。しかし、UAとサーバー間のメッセージのセットに関係なくTLSが使用されているかどうかの、多くの場合、この情報を公開するだろうと思われます。 TLSを使用すると、しかし、まだ良いプランです。"
    },
    {
      "indent": 0,
      "text": "6.2. Associating Additional Keys to an Existing Account",
      "section_title": true,
      "ja": "6.2. 既存のアカウントに追加キーの関連付け"
    },
    {
      "indent": 3,
      "text": "From the user perspective, the UA having a CPK for a web origin will often appear to be the same as having a way to sign in to an account at that web site. Since users often have more than one UA, and since the CPKs are, in general, UA specific, that raises the question of how the user can sign in to that account from different UAs. And from the server perspective, that turns into the question of how to safely bind different CPKs to one account. In this section, we describe some ways in which this can be done, as well as one way in which this ought not be done.",
      "ja": "ユーザーの観点からは、ウェブ起源のためのCPKを持つUAは、多くの場合、そのウェブサイトでアカウントにログインする方法を持つと同じように見えます。ユーザー以来、多くの場合、複数のUAを持っている、とCPKsであるため、一般的には、UAは、特定の、それはユーザーが別のUAからそのアカウントにサインインすることができる方法の問題を提起します。そして、サーバの観点から、それは安全に1つのアカウントに異なるCPKsをバインドする方法の問題になります。このセクションでは、我々はいくつかのこれを行うことができる方法と同様に、これを行うことはないはず1つの方法について説明します。"
    },
    {
      "indent": 3,
      "text": "Note that the context here is usually that the user has succeeded in registering with one or more UAs (for the purposes of this section, we call this \"the first UA\" below) and can use HOBA with those, and the user is now adding another UA. The newest UA might or might not have a CPK for the site in question. Since it is in fact trivial, we assume that the site is able to put in place some appropriate, quicker, easier registration for a CPK for the newest UA. The issue then becomes one of binding the CPK from the newest UA with those of other UAs bound to the account.",
      "ja": "ここでのコンテキストは、ユーザーが1つのまたは複数のUAの登録に成功している（本項の目的のために、私たちは以下のこの「最初のUA」と呼ぶ）と、それらとHOBAを使用することができ、ユーザーが今追加していることは通常であることに注意してください別のUA。最新のUAは、または問題のサイトのためのCPKを持っていない場合があります。それは実際には簡単ですので、私たちは、サイトは、最新のUAのためのCPKのための場所では、いくつかの適切な、より速く、より簡単に登録を置くことができることを前提としています。問題は、そのアカウントにバインドされた他のUAのものと最新のUAからのCPKの結合の一つとなります。"
    },
    {
      "indent": 0,
      "text": "6.2.1. Moving Private Keys",
      "section_title": true,
      "ja": "6.2.1. 秘密鍵を移動します"
    },
    {
      "indent": 3,
      "text": "It is common for a user to have multiple UAs and to want all those UAs to be able to authenticate to a single account. One method to allow a user who has an existing account to be able to authenticate on a second device is to securely transport the private and public keys and the origin information from the first device to the second. If this approach is taken, then there is no impact on the HOBA-http or HOBA-js, so this is a pure UA implementation issue and not discussed further.",
      "ja": "ユーザが複数のUAを持っているし、それらすべてのUAが単一のアカウントへの認証できるようにすることが一般的です。既存のアカウントを持っているユーザが第2のデバイス上で認証できるようにすることを可能にする一つの方法は、安全に秘密鍵と公開鍵と第二の最初のデバイスから原点情報を輸送することです。このアプローチが取られている場合、そこHOBA-HTTPまたはHOBA-JSには影響がなく、これは純粋なUAの実装上の問題であり、さらに説明しません。"
    },
    {
      "indent": 0,
      "text": "6.2.2. Human-Memorable One-Time Password (Don't Do This One)",
      "section_title": true,
      "ja": "6.2.2. 人間思い出に残るワンタイムパスワード（このいずれかを実行しないでください）"
    },
    {
      "indent": 3,
      "text": "It will be tempting for implementers to use a human-memorable One-Time Password (OTP) in order to \"authenticate\" binding CPKs to the same account. The workflow here would likely be something along the lines of some server administrative utility generating a human- memorable OTP such as \"1234\" and sending that to the user out of band for the user to enter at two web pages, each authenticated via the relevant CPK. While this seems obvious enough and could even be secure enough in some limited cases, we consider that this is too risky to use in the Internet, and so servers SHOULD NOT provide such a mechanism. The reason this is so dangerous is that it would be trivial for an automated client to guess such tokens and \"steal\" the binding intended for some other user. At any scale, there would always be some in-process bindings so that even with only a trickle of guesses (and hence not being detectable via message volume), an attacker would have a high probability of succeeding in registering a binding with the attacker's CPK.",
      "ja": "実装者は、同じアカウントへの結合CPKsを「認証」するために、人間の記憶に残るワンタイムパスワード（OTP）を使用することは魅力的になります。ここでのワークフローの可能性が高いように「1234」と人間の記憶に残るOTPを生成し、2つのWebページで入力するユーザのための帯域外のユーザーにそれを送信する一部のサーバー管理ユーティリティの線に沿って何かになり、それぞれが関連を介して認証しますCPK。これは十分に明白なようで、さらにいくつかの限られたケースでは十分に安全である可能性がありますが、私たちは、これは、インターネットで使用するにはあまりにも危険であることを考えると、そのサーバは、そのようなメカニズムを提供すべきではありません。これは非常に危険である理由は、自動化されたクライアントは、このようなトークンを推測し、他のユーザーのために意図バインディング「盗む」することは些細なことであろうということです。推測のみトリクル（したがってメッセージボリュームを介して検出されていない）と、攻撃者は攻撃者のCPKとの結合を登録に成功の高い確率を有するであろうように、任意のスケールで、常にいくつかの工程内のバインディングが存在するであろう。"
    },
    {
      "indent": 3,
      "text": "This method of binding CPKs together is therefore NOT RECOMMENDED.",
      "ja": "一緒にCPKsを結合したがって、この方法はお勧めしません。"
    },
    {
      "indent": 0,
      "text": "6.2.3. Out-of-Band URL",
      "section_title": true,
      "ja": "6.2.3. アウトオブバンドURL"
    },
    {
      "indent": 3,
      "text": "One easy binding method is to simply provide a web page where, using the first UA, the user can generate a URL (containing some \"unguessable\" cryptographically generated value) that the user then later dereferences on the newest UA. The user could email that URL to herself, for example, or the web server accessed at the first UA could automatically do that.",
      "ja": "一つの簡単な結合方法は、単純に、ユーザは、（いくつかの「推測できない」、暗号生成された値を含む）URLを生成することができます最初のUAを使用して、Webページを提供することで、最新のUA上でユーザー後でデリファレンスは。ユーザは、例えば、自分自身にそのURLを電子メールで送信でき、または最初のUAでアクセスされたウェブサーバーが自動的にそれを行うことができます。"
    },
    {
      "indent": 3,
      "text": "Such a URL SHOULD contain at least the equivalent of 128 bits of randomness.",
      "ja": "そのようなURLは、ランダムの128ビットの少なくとも同等のものを含むべきです。"
    },
    {
      "indent": 0,
      "text": "6.3. Logging Out",
      "section_title": true,
      "ja": "6.3. ログアウト"
    },
    {
      "indent": 3,
      "text": "The user can tell the server it wishes to log out. With HOBA-http, this is done by sending a HOBA-authenticated POST message to the URL \".well-known/hoba/logout\" on the site in question. The UA SHOULD also delete session cookies associated with the session so that the user's state is no longer \"logged in.\"",
      "ja": "ユーザーは、それがログアウトしたいサーバーを伝えることができます。 HOBA-HTTPで、これは、問題のサイトのURL「.well知ら/ HOBA /ログアウト」にHOBA認証POSTメッセージを送信することにより行われます。利用者の状態はもはやなるように、UAは、セッションに関連するセッションクッキーを削除してはならない「に記録されます。」"
    },
    {
      "indent": 3,
      "text": "The server MUST NOT allow TLS session resumption for any logged out session.",
      "ja": "いずれかのセッションをログアウトするためにサーバがTLSセッション再開を許してはなりません。"
    },
    {
      "indent": 3,
      "text": "The server SHOULD also revoke or delete any cookies associated with the session.",
      "ja": "また、サーバは、セッションに関連するすべてのクッキーを取り消すか、削除してください。"
    },
    {
      "indent": 0,
      "text": "6.4. Getting a Fresh Challenge",
      "section_title": true,
      "ja": "6.4. 新鮮なチャレンジを取得"
    },
    {
      "indent": 3,
      "text": "The UA can get a \"fresh\" challenge from the server. In HOBA-http, it sends a POST message to \".well-known/hoba/getchal\". If successful, the response MUST contain a fresh (base64url-encoded) HOBA challenge for this origin in the body of the response. Whitespace in the response MUST be ignored.",
      "ja": "UAは、サーバーからの「フレッシュ」挑戦を得ることができます。 HOBA-HTTPでは、それは \"/ HOBA / getchal .well知られている\" にPOSTメッセージを送信します。成功した場合、応答は、応答のボディにこの原点新鮮（base64urlエンコードされた）HOBAチャレンジを含まなければなりません。応答での空白は無視しなければなりません。"
    },
    {
      "indent": 0,
      "text": "7. Mandatory-to-Implement Algorithms",
      "section_title": true,
      "ja": "7.実装に必須のアルゴリズム"
    },
    {
      "indent": 3,
      "text": "RSA-SHA256 MUST be supported. HOBA implementations MUST use RSA-SHA256 if it is provided by the underlying cryptographic libraries. RSA-SHA1 MAY be used. RSA modulus lengths of at least 2048 bits SHOULD be used. RSA indicates the RSASSA-PKCS1-v1_5 algorithm defined in Section 8.2 of [RFC3447], and SHA-1 and SHA-256 are defined in [SHS]. Keys with moduli shorter than 2048 bits SHOULD only be used in cases where generating 2048-bit (or longer) keys is impractical, e.g., on very constrained or old devices.",
      "ja": "RSA-SHA256をサポートしなければなりません。それは根本的な暗号化ライブラリで提供されている場合HOBA実装はRSA-SHA256を使用しなければなりません。 RSA-SHA1を使用することができます。少なくとも2048ビットのRSAモジュラスの長さが使用されるべきです。 RSAは、[RFC3447]のセクション8.2で定義されたRSASSA-PKCS1-v1_5のアルゴリズムを示しており、SHA-1、SHA-256 [SHS]で定義されています。非常に制約されたまたは古いデバイス上、例えば、非実用的であるキーを2048ビットを生成する（以上）ここで2048ビットより短いモジュラスを持つキーは、唯一のケースで使用されるべきです。"
    },
    {
      "indent": 0,
      "text": "8. Security Considerations",
      "section_title": true,
      "ja": "8.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "Binding my CPK with someone else's account would be fun and profitable so SHOULD be appropriately hard. In particular, URLs or other values generated by the server as part of any CPK binding process MUST be hard to guess, for whatever level of difficulty is chosen by the server. The server SHOULD NOT allow a random guess to reveal whether or not an account exists.",
      "ja": "他人のアカウントを使用して、私のCPKをバインドする楽しさと有益だろうので、適切にハードであるべきです。具体的には、任意のCPK結合プロセスの一部として、サーバによって生成されたURLまたは他の値は、サーバによって選択されたどのような難易度のため、推測するのは困難でなければなりません。サーバーは、ランダムな推測がアカウントが存在するかどうかを明らかにすることを許してはなりません。"
    },
    {
      "indent": 3,
      "text": "If key binding was server selected, then a bad actor could bind different accounts belonging to the user from the network with possible bad consequences, especially if one of the private keys was compromised somehow.",
      "ja": "キーバインディングは、サーバーを選択した場合、その後の悪い俳優は秘密鍵の一つが何らかの形で侵害された場合は特に、可能性悪い結果とのネットワークからユーザーに属する別のアカウントを結合することができます。"
    },
    {
      "indent": 3,
      "text": "When the max-age parameter is not zero, then a HOBA signature has a property that is like a bearer token for the relevant number of seconds: it can be replayed for a server-selected duration. Similarly, for HOBA-js, signatures might be replayable depending on the specific implementation. The security considerations of [RFC6750] therefore apply in any case where the HOBA signature can be replayed. Server administrators can set the max-age to the minimum acceptable value in such cases, which would often be expected to be just a few seconds. There seems to be no reason to ever set the max-age more than a few minutes; the value ought also decrease over time as device capabilities improve. The administrator will most likely want to set the max-age to something that is not too short for the slowest signing device that is significant for that site.",
      "ja": "最大エージングパラメータがゼロでない場合は、その後、HOBA署名は、秒の関連する数のベアラトークンのようなものである性質を持っている：それは、サーバが選択した期間に再生することができます。同様に、HOBA-JSのため、シグネチャは、特定の実装に応じて再生可能であるかもしれません。 [RFC6750]のセキュリティ問題は、したがって、HOBA署名を再生することができるいずれの場合にも当てはまります。サーバー管理者は、多くの場合、わずか数秒であることが予想されるような場合に最小許容値に最大エージングを設定することができます。これまでに数分以上最大エージングを設定する理由はないように思えます。デバイスの機能が改善された値はまた、時間の経過とともに減少するはずです。管理者は、最も可能性が高いそのサイトにとって重要である最も遅い署名装置用短すぎない何かに最大エージングを設定することになるでしょう。"
    },
    {
      "indent": 0,
      "text": "8.1. Privacy Considerations",
      "section_title": true,
      "ja": "8.1. プライバシーの考慮事項"
    },
    {
      "indent": 3,
      "text": "HOBA does, to some extent, impact privacy and could be considered to represent a super-cookie to the server or to any entity on the path from UA to HTTP server that can see the HOBA signature. This is because we need to send a key identifier as part of the signature and that will not vary for a given key. For this reason, and others, it is strongly RECOMMENDED to only use HOBA over server-authenticated TLS and to migrate web sites using HOBA to only use \"https\" URLs.",
      "ja": "HOBAは、ある程度、ないインパクトのプライバシーおよびサーバまたはHOBA署名を見ることができるHTTPサーバへのUAからのパス上の任意のエンティティにスーパークッキーを表現するために考えることができます。私たちは署名の一部としてキー識別子を送信する必要があり、それが与えられたキーに対して変化しないためです。このため、その他の場合は、それを強くのみ、サーバー認証TLS上HOBAを使用してのみ「https」のURLを使用するようにHOBAを使用してWebサイトを移行することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "UAs SHOULD provide users a way to manage their CPKs. Ideally, there would be a way for a user to maintain their HOBA details for a site while at the same time deleting other site information such as cookies or non-HOBA HTML5 localStorage. However, as this is likely to be complex, and appropriate user interfaces counterintuitive, we expect that UAs that implement HOBA will likely treat HOBA information as just some more site data that would disappear should the user choose to \"forget\" that site.",
      "ja": "UAはユーザーが自分のCPKsを管理する方法を提供する必要があります。理想的には、同時に、このようなクッキーや非HOBA HTML5のlocalStorageなど他のサイトの情報を削除しながら、サイトの彼らのHOBAの詳細を維持するために、ユーザのための方法があるでしょう。これは複雑である可能性が高い、と適切なユーザーインターフェース直感に反するとしてしかし、私たちは、HOBAを実装するUAはおそらく、ユーザーがそのサイトを「忘れる」ことを選択する必要があります消えてしまうだけでいくつかのより多くのサイトデータとしてHOBA情報を処理することを期待しています。"
    },
    {
      "indent": 3,
      "text": "Device identifiers are intended to specify classes of device in a way that can assist with registration and with presentation to the user of information about previous sessions, e.g., last login time. Device identifier types MUST NOT be privacy sensitive, with values that would allow tracking a user in unexpected ways. In particular, using a device identifier type that is analogous to the International Mobile Equipment Identifier (IMEI) would be a really bad idea and is the reason for the \"MUST NOT\" above. In that case, \"mobile phone\" could be an acceptable choice.",
      "ja": "デバイス識別子は、登録して、前のセッションに関する情報をユーザに提示する、例えば、最終ログイン時刻を支援できるように、デバイスのクラスを指定することを意図しています。デバイス識別子の種類は、予期しない方法でユーザーを追跡できるようになる値で、プライバシーに敏感にすることはできません。具体的には、国際移動体装置識別子（IMEI）に類似したデバイス識別子のタイプを使用すると、本当に悪い考えと「MUST NOT」上記の理由であるでしょう。その場合は、「携帯電話が」許容できる選択肢である可能性があります。"
    },
    {
      "indent": 3,
      "text": "If possible, implementations ought to encourage the use of device identifier values that are not personally identifying except for the user concerned; for example, \"Alice's mobile\" is likely to be chosen and is somewhat identifying, but \"Alice's phone: UUID 1234-5567- 89abc-def0\" would be a very bad choice.",
      "ja": "可能な場合は、実装は、個人的に関係するユーザを除いて識別されていないデバイス識別子値の使用を奨励するべきです。例えば、「アリスのモバイルは、」選択される可能性が高いとやや識別されるが、「アリスの電話：UUID 1234-5567- 89abc-DEF0は」非常に悪い選択です。"
    },
    {
      "indent": 0,
      "text": "8.2. localStorage Security for JavaScript",
      "section_title": true,
      "ja": "8.2.  JavaScriptのためのlocalStorageセキュリティ"
    },
    {
      "indent": 3,
      "text": "The use of localStorage (likely with a non-WebCrypto implementation of HOBA-js) will undoubtedly be a cause for concern. localStorage uses the same-origin model that says that the scheme, domain, and port define a localStorage instance. Beyond that, any code executing will have access to private keying material. Of particular concern are Cross-Site Scripting (XSS) attacks, which could conceivably take the keying material and use it to create UAs under the control of an attacker. XSS attacks are, in reality, devastating across the board since they can and do steal credit card information, passwords, perform illicit acts, etc. It's not evident that we are introducing unique threats from which cleartext passwords don't already suffer.",
      "ja": "（HOBA-JSの非WebCrypto実装とそう）のlocalStorageの使用は、間違いなく懸念の原因となります。 localStorageはスキーム、ドメイン、およびポートがのlocalStorageインスタンスを定義することを述べている同一生成元のモデルを使用しています。それ以上に、実行するコードは、プライベート鍵素材にアクセスする必要があります。特に懸念されるの考えの鍵材料を取り、攻撃者の制御下でのUAを作成するためにそれを使用することができ、クロスサイトスクリプティング（XSS）攻撃は、あります。 XSS攻撃は、それは我々が平文パスワードがすでに苦しむことはない、そこから独特の脅威を導入していることは明らかではないなど、彼らができるので、軒並み壊滅的な、現実には、あると不正行為を行い、クレジットカード情報、パスワードを盗むん。"
    },
    {
      "indent": 3,
      "text": "Another source of concern is local access to the keys. That is, if an attacker has access to the UA itself, they could snoop on the key through a JavaScript console or find the file(s) that implement localStorage on the host computer. Again, it's not clear that we are worse in this regard because the same attacker could get at browser password files, etc., too. One possible mitigation is to encrypt the keystore with a password/PIN that the user supplies. This may sound counterintuitive, but the object here is to keep passwords off of servers to mitigate the multiplier effect of a large-scale compromise (e.g., [ThreatReport]) because of shared passwords across sites.",
      "ja": "懸念のもう1つの原因は、キーへのローカルアクセスです。これは、攻撃者がUA自体へのアクセス権を持っている場合、彼らはJavaScriptコンソールを通じてキーをスヌーピングまたはホストコンピュータ上のlocalStorageを実装するファイル（複数可）を見つけることができる、です。ここでも、同じ攻撃者はなど、ブラウザのパスワード・ファイルを得ることができるので、我々はあまりにも、この点で悪化していることは明らかではありません。一つの可能​​な緩和策は、ユーザー用品そのパスワード/ PINをキーストアを暗号化することです。これは直感に反する聞こえるかもしれませんが、ここではオブジェクトがあるためサイト間で共有パスワードの（例えば、[ThreatReport]）大規模な妥協の乗数効果を緩和するために、サーバのオフにパスワードを維持することです。"
    },
    {
      "indent": 3,
      "text": "It's worth noting that HOBA uses asymmetric keys and not passwords when evaluating threats. As various password database leaks have shown, the real threat of a password breach is not just to the site that was breached, it's also to all of the sites on which a user used the same password. That is, the collateral damage is severe because password reuse is common. Storing a password in localStorage would also have a similar multiplier effect for an attacker, though perhaps on a smaller scale than a server-side compromise: one successful crack gains the attacker potential access to hundreds if not thousands of sites the user visits. HOBA does not suffer from that attack multiplier since each asymmetric key pair is unique per site/UA/user.",
      "ja": "それは脅威を評価するときにHOBAは非対称鍵ではなくパスワードを使用していることは注目に値します。様々なパスワードデータベースのリークが示されてきたように、パスワード侵害の本当の脅威はちょうど破られたサイトにはない、それはユーザーが同じパスワードを使用したサイトのすべてにもあります。これは、パスワードの再利用が一般的であるため、巻き添え被害が深刻である、です。 localStorageでパスワードを保存するにもかかわらず、おそらく、サーバー側の妥協よりも小さい規模で、攻撃者のための同様の相乗効果を持っているでしょう：1つの成功した亀裂は、サイト利用者の訪問の数百いない場合は数千人に攻撃者が潜在的なアクセスを得ます。各非対称鍵ペアは、サイト/ UA /ユーザーごとに一意であるため、HOBAはその攻撃乗数悩まされることはありません。"
    },
    {
      "indent": 0,
      "text": "8.3. Multiple Accounts on One User Agent",
      "section_title": true,
      "ja": "8.3.  1つのユーザーエージェントで複数のアカウント"
    },
    {
      "indent": 3,
      "text": "A shared UA with multiple accounts is possible if the account identifier is stored along with the asymmetric key pair binding them to one another. Multiple entries can be kept, one for each account, and selected by the current user. This, of course, is fraught with the possibility for abuse, since a server is potentially enrolling the device for a long period and the user may not want to have to be responsible for the credential for that long. To alleviate this problem, the user could request that the credential be erased from the browser. Similarly, during the enrollment phase, a user could request that the key pair only be kept for a certain amount of time or that it not be stored beyond the current browser session. However, all such features really ought to be part of the operating system or platform and not part of a HOBA implementation, so those are not discussed further.",
      "ja": "複数のアカウントを持つ共有UAアカウント識別子が相互にそれらを結合非対称鍵ペアと一緒に格納されている場合に可能です。複数のエントリは、各アカウントのいずれかを保持し、現在のユーザによって選択することができます。サーバは潜在的に長期間にわたってデバイスを登録され、ユーザはその長いの資格のために責任があるしたくないかもしれないので、これは当然のことながら、虐待の可能性をはらんでいます。この問題を軽減するために、ユーザーは資格がブラウザから消去することを要求することができます。同様に、登録段階の間に、ユーザがキーペアのみ一定時間又はそれが現在のブラウザセッションを超えて保存されないことを維持することを要求することができます。しかし、そのようなすべての機能が本当にオペレーティングシステムまたはプラットフォームとHOBA実装の一部ではないの一部であるべきなので、それらはさらに議論されていません。"
    },
    {
      "indent": 0,
      "text": "8.4. Injective Mapping for HOBA-TBS",
      "section_title": true,
      "ja": "8.4.  HOBA-TBSのための単射のマッピング"
    },
    {
      "indent": 3,
      "text": "The repeated length fields in the HOBA-TBS structure are present in order to ensure that there is no possibility that the catenation of different input values can cause confusion that might lead to an attack, either against HOBA as specified here, or else an attack against some other protocol that reused this to-be-signed structure. Those fields ensure that the mapping from input fields to the HOBA-TBS string is an injective mapping.",
      "ja": "他の攻撃に対して、ここで指定した、またはとしてHOBA-TBS構造の繰り返し長さフィールドは、いずれかのHOBAに対して、異なる入力値のカートネーションが攻撃につながる可能性がある混乱を引き起こす可能性があることを可能性がないことを確実にするために存在しています被署名される構造、これを再利用するいくつかの他のプロトコル。これらのフィールドは、HOBA-TBS列に入力フィールドからマッピングは単射写像であることを確認します。"
    },
    {
      "indent": 0,
      "text": "9. IANA Considerations",
      "section_title": true,
      "ja": "9. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "IANA has made registrations and created new registries as described below.",
      "ja": "IANAは登録を行い、以下に説明するように、新しいレジストリを作成しました。"
    },
    {
      "indent": 3,
      "text": "All new registries have been placed beneath a new \"HTTP Origin-Bound Authentication (HOBA) Parameters\" category.",
      "ja": "すべての新しいレジストリは、新たな「HTTP原点バウンド認証（HOBA）パラメータ」カテゴリの下に配置されています。"
    },
    {
      "indent": 0,
      "text": "9.1. HOBA Authentication Scheme",
      "section_title": true,
      "ja": "9.1.  HOBA認証スキーム"
    },
    {
      "indent": 3,
      "text": "A new scheme has been registered in the HTTP Authentication Scheme Registry as follows:",
      "ja": "次のように新しいスキームは、HTTP認証スキームのレジストリに登録されています。"
    },
    {
      "indent": 3,
      "text": "Authentication Scheme Name: HOBA",
      "ja": "認証スキーム名：HOBA"
    },
    {
      "indent": 3,
      "text": "Reference: Section 3 of RFC 7486",
      "ja": "参考：RFC 7486のセクション3"
    },
    {
      "indent": 3,
      "text": "Notes (optional): The HOBA scheme can be used with either HTTP servers or proxies. When used in response to a 407 Proxy Authentication Required indication, the appropriate proxy authentication header fields are used instead, as with any other HTTP authentication scheme.",
      "ja": "ノート（オプション）：HOBA方式はHTTPサーバーやプロキシのいずれかで使用することができます。 407プロキシ認証が必要指示に応答して使用される場合、適切なプロキシ認証ヘッダフィールドは、他のHTTP認証方式と同様に、代わりに使用されています。"
    },
    {
      "indent": 0,
      "text": "9.2. .well-known URI",
      "section_title": true,
      "ja": "9.2.  .well知られているURI"
    },
    {
      "indent": 3,
      "text": "A new .well-known URI has been registered in the Well-Known URIs registry as described below.",
      "ja": "後述のように新しい.well知られているURIは、よく知られているURIをレジストリに登録されています。"
    },
    {
      "indent": 3,
      "text": "URI Suffix: hoba",
      "ja": "うり すっふぃｘ： ほば"
    },
    {
      "indent": 3,
      "text": "Change Controller: IETF",
      "ja": "変更コントローラ：IETF"
    },
    {
      "indent": 3,
      "text": "Reference: Section 6 of RFC 7486",
      "ja": "参考：RFC 7486のセクション6"
    },
    {
      "indent": 3,
      "text": "Related Information: N/A",
      "ja": "関連情報：N / A"
    },
    {
      "indent": 0,
      "text": "9.3. Algorithm Names",
      "section_title": true,
      "ja": "9.3. アルゴリズムの名前"
    },
    {
      "indent": 3,
      "text": "A new HOBA signature algorithms registry has been created as follows, with Specification Required as the registration procedure. New HOBA signature algorithms SHOULD be in use with other IETF Standards Track protocols before being added to this registry.",
      "ja": "登録手続きとして必要な仕様で、以下のように新しいHOBA署名アルゴリズムレジストリが作成されました。新HOBAの署名アルゴリズムは、このレジストリに追加される前に他のIETF標準化過程プロトコルで使用するにする必要があります。"
    },
    {
      "indent": 3,
      "text": "Number       Meaning                         Reference\n-----------  ------------------------------  ------------\n0            RSA-SHA256                      RFC 7486\n1            RSA-SHA1                        RFC 7486",
      "raw": true
    },
    {
      "indent": 3,
      "text": "RSA is defined in Section 8.2 of [RFC3447], and SHA-1 and SHA-256 are defined in [SHS].",
      "ja": "RSAは、[RFC3447]のセクション8.2で定義され、SHA-1、SHA-256 [SHS]で定義されています。"
    },
    {
      "indent": 3,
      "text": "For this registry, the number column should contain a small positive integer. Following the ABNF in Figure 1, the maximum value for this is decimal 99.",
      "ja": "このレジストリのために、番号欄には小さな正の整数が含まれている必要があります。図1のABNF以下、この最大値は、小数点以下99です。"
    },
    {
      "indent": 0,
      "text": "9.4. Key Identifier Types",
      "section_title": true,
      "ja": "9.4. キー識別子の種類"
    },
    {
      "indent": 3,
      "text": "A new HOBA Key Identifier Types registry has been created as follows, with Specification Required as the registration procedure.",
      "ja": "登録手続きとして必要な仕様で、以下のように新しいHOBAキー識別子の種類レジストリが作成されました。"
    },
    {
      "indent": 3,
      "text": "Number       Meaning                         Reference\n-----------  ------------------------------  ------------\n0            a hashed public key             [RFC6698]\n1            a URI                           [RFC3986]\n2            an unformatted string, at the   RFC 7486\n             user's/UA's whim",
      "raw": true
    },
    {
      "indent": 3,
      "text": "For the number 0, hashed public keys are as done in DNS-Based Authentication of Named Entities (DANE) [RFC6698].",
      "ja": "番号0のため、公開鍵は、名前付きエンティティとして（DANE）[RFC6698]のDNSベースの認証で行われるハッシュ。"
    },
    {
      "indent": 3,
      "text": "For this registry, the number column should contain a small positive integer.",
      "ja": "このレジストリのために、番号欄には小さな正の整数が含まれている必要があります。"
    },
    {
      "indent": 0,
      "text": "9.5. Device Identifier Types",
      "section_title": true,
      "ja": "9.5. デバイス識別子の種類"
    },
    {
      "indent": 3,
      "text": "A new HOBA Device Identifier Types registry has been created as follows, with Specification Required as the registration procedure.",
      "ja": "登録手続きとして必要な仕様で、以下のように新しいHOBAデバイス識別子タイプレジストリが作成されています。"
    },
    {
      "indent": 3,
      "text": "The designated expert for this registry is to carefully pay attention to the notes on this field in Section 8.1, in particular, the \"MUST NOT\" stated therein.",
      "ja": "このレジストリの指定専門家は慎重に、特に、8.1節では、この分野での注意事項に注意を払うことで、その中で述べた「てはなりません」。"
    },
    {
      "indent": 3,
      "text": "Number       Meaning                         Reference\n-----------  ------------------------------  -----------\n0            an unformatted string, at the   RFC 7486\n             user's/UA's whim",
      "raw": true
    },
    {
      "indent": 3,
      "text": "For this registry, the number column should contain a small positive integer.",
      "ja": "このレジストリのために、番号欄には小さな正の整数が含まれている必要があります。"
    },
    {
      "indent": 0,
      "text": "9.6. Hobareg HTTP Header Field",
      "section_title": true,
      "ja": "9.6.  Hobareg HTTPヘッダーフィールド"
    },
    {
      "indent": 3,
      "text": "A new identifier has been registered in the Permanent Message Header Field Names registry as described below.",
      "ja": "後述のように新しい識別子が恒久メッセージヘッダフィールド名レジストリに登録されています。"
    },
    {
      "indent": 3,
      "text": "Header Field Name: Hobareg",
      "ja": "ヘッダーフィールド名：Hobareg"
    },
    {
      "indent": 3,
      "text": "Protocol: http (RFC 7230)",
      "ja": "プロトコル：HTTP（RFC 7230）"
    },
    {
      "indent": 3,
      "text": "Status: experimental",
      "ja": "ステータス：実験"
    },
    {
      "indent": 3,
      "text": "Author/Change controller: IETF",
      "ja": "著者/変更コントローラ：IETF"
    },
    {
      "indent": 3,
      "text": "Reference: Section 6.1.1 of RFC 7486",
      "ja": "参考：RFC 7486の6.1.1項"
    },
    {
      "indent": 3,
      "text": "Related information: N/A",
      "ja": "関連情報：N / A"
    },
    {
      "indent": 0,
      "text": "10. References",
      "section_title": true,
      "ja": "10.参考文献"
    },
    {
      "indent": 0,
      "text": "10.1. Normative References",
      "section_title": true,
      "ja": "10.1. 引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC20] Cerf, V., \"ASCII format for network interchange\", STD 80, RFC 20, October 1969, <http://www.rfc-editor.org/info/rfc20>.",
      "ja": "[RFC20]サーフ、V.、 \"ネットワークの交換のためのASCIIフォーマット\"、STD 80、RFC 20、1969年10月、<http://www.rfc-editor.org/info/rfc20>。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月、<http://www.rfc-editor.org/info/rfc2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC3447] Jonsson, J. and B. Kaliski, \"Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1\", RFC 3447, February 2003, <http://www.rfc-editor.org/info/rfc3447>.",
      "ja": "[RFC3447]ジョンソン、J.とB. Kaliski、 \"公開鍵暗号規格（PKCS）＃1：RSA暗号仕様バージョン2.1\"、RFC 3447、2003年2月、<http://www.rfc-editor.org/情報/ RFC3447>。"
    },
    {
      "indent": 3,
      "text": "[RFC3986] Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform Resource Identifier (URI): Generic Syntax\", STD 66, RFC 3986, January 2005, <http://www.rfc-editor.org/info/rfc3986>.",
      "ja": "[RFC3986]バーナーズ - リー、T.、フィールディング、R.、およびL. Masinter、 \"ユニフォームリソース識別子（URI）：汎用構文\"、STD 66、RFC 3986、2005年1月<HTTP：//www.rfc- editor.org/info/rfc3986>。"
    },
    {
      "indent": 3,
      "text": "[RFC4648] Josefsson, S., \"The Base16, Base32, and Base64 Data Encodings\", RFC 4648, October 2006, <http://www.rfc-editor.org/info/rfc4648>.",
      "ja": "[RFC4648] Josefsson氏、S.、 \"Base16、Base32、およびBase64でデータエンコーディング\"、RFC 4648、2006年10月、<http://www.rfc-editor.org/info/rfc4648>。"
    },
    {
      "indent": 3,
      "text": "[RFC5234] Crocker, D., Ed. and P. Overell, \"Augmented BNF for Syntax Specifications: ABNF\", STD 68, RFC 5234, January 2008, <http://www.rfc-editor.org/info/rfc5234>.",
      "ja": "[RFC5234]クロッカー、D.、エド。そして、P. Overell、 \"構文仕様のための増大しているBNF：ABNF\"、STD 68、RFC 5234、2008年1月、<http://www.rfc-editor.org/info/rfc5234>。"
    },
    {
      "indent": 3,
      "text": "[RFC5246] Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS) Protocol Version 1.2\", RFC 5246, August 2008, <http://www.rfc-editor.org/info/rfc5246>.",
      "ja": "[RFC5246]ダークス、T.およびE.レスコラ、 \"トランスポート層セキュリティ（TLS）プロトコルバージョン1.2\"、RFC 5246、2008年8月、<http://www.rfc-editor.org/info/rfc5246>。"
    },
    {
      "indent": 3,
      "text": "[RFC5785] Nottingham, M. and E. Hammer-Lahav, \"Defining Well-Known Uniform Resource Identifiers (URIs)\", RFC 5785, April 2010, <http://www.rfc-editor.org/info/rfc5785>.",
      "ja": "[RFC5785]ノッティンガム、M.およびE.ハンマーLahav、 \"既知のUniform Resource Identifier（URI）を定義\"、RFC 5785、2010年4月<http://www.rfc-editor.org/info/rfc5785> 。"
    },
    {
      "indent": 3,
      "text": "[RFC6454] Barth, A., \"The Web Origin Concept\", RFC 6454, December 2011, <http://www.rfc-editor.org/info/rfc6454>.",
      "ja": "[RFC6454]バース、A.、 \"ウェブ起源コンセプト\"、RFC 6454、2011年12月、<http://www.rfc-editor.org/info/rfc6454>。"
    },
    {
      "indent": 3,
      "text": "[RFC6698] Hoffman, P. and J. Schlyter, \"The DNS-Based Authentication of Named Entities (DANE) Transport Layer Security (TLS) Protocol: TLSA\", RFC 6698, August 2012, <http://www.rfc-editor.org/info/rfc6698>.",
      "ja": "[RFC6698]ホフマン、P.およびJ. Schlyter、 \"名前付きエンティティのDNSベースの認証（DANE）トランスポート層セキュリティ（TLS）プロトコル：TLSA\"、RFC 6698、2012年8月、<のhttp：//www.rfc- editor.org/info/rfc6698>。"
    },
    {
      "indent": 3,
      "text": "[RFC6750] Jones, M. and D. Hardt, \"The OAuth 2.0 Authorization Framework: Bearer Token Usage\", RFC 6750, October 2012, <http://www.rfc-editor.org/info/rfc6750>.",
      "ja": "[RFC6750]ジョーンズ、M.とD.ハルト、 \"OAuth 2.0の認証フレームワーク：ベアラートークンの使用\"、RFC 6750、2012年10月、<http://www.rfc-editor.org/info/rfc6750>。"
    },
    {
      "indent": 3,
      "text": "[RFC7231] Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content\", RFC 7231, June 2014, <http://www.rfc-editor.org/info/rfc7231>.",
      "ja": "[RFC7231]フィールディング、R.、エド。そして、J. Reschke、エド、 \"ハイパーテキスト転送プロトコル（HTTP / 1.1）：セマンティクスおよびコンテンツ\"、RFC 7231、2014年6月、<http://www.rfc-editor.org/info/rfc7231>。"
    },
    {
      "indent": 3,
      "text": "[RFC7235] Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Authentication\", RFC 7235, June 2014, <http://www.rfc-editor.org/info/rfc7235>.",
      "ja": "[RFC7235]フィールディング、R.、エド。そして、J. Reschke、エド、 \"ハイパーテキスト転送プロトコル（HTTP / 1.1）：認証\"、RFC 7235、2014年6月、<http://www.rfc-editor.org/info/rfc7235>。"
    },
    {
      "indent": 3,
      "text": "[SHS] NIST, \"Secure Hash Standard (SHS)\", FIPS PUB 180-4, March 2012.",
      "ja": "[SHS] NIST、FIPS PUB 180-4の、2012年3月 \"ハッシュ規格（SHS）を固定します\"。"
    },
    {
      "indent": 0,
      "text": "10.2. Informative References",
      "section_title": true,
      "ja": "10.2. 参考文献"
    },
    {
      "indent": 3,
      "text": "[Bonneau] Bonneau, J., \"The Science of Guessing: Analyzing an Anonymized Corpus of 70 Million Passwords\", IEEE Symposium on Security and Privacy 538-552, 2012.",
      "ja": "[ボノー]ボノー、J.、「推測の科学：70百万のパスワードの匿名化コーパス分析」セキュリティとプライバシー538から552、2012年、IEEEシンポジウムを。"
    },
    {
      "indent": 3,
      "text": "[MI93] Mitchell, C. and A. Thomas, \"Standardising authentication protocols based on public key techniques\", Journal of Computer Security Volume 2, 23-36, 1993.",
      "ja": "[MI93]ミッチェル、C.とA.トーマス、コンピュータセキュリティの2巻のジャーナル、23-36、1993「公開鍵技術に基づく認証プロトコルを標準化します」。"
    },
    {
      "indent": 3,
      "text": "[RFC4086] Eastlake 3rd, D., Schiller, J., and S. Crocker, \"Randomness Requirements for Security\", BCP 106, RFC 4086, June 2005, <http://www.rfc-editor.org/info/rfc4086>.",
      "ja": "[RFC4086]イーストレーク3日、D.、シラー、J.、およびS.クロッカー、 \"セキュリティのためのランダム要件\"、BCP 106、RFC 4086、2005年6月、<http://www.rfc-editor.org/info/ RFC4086>。"
    },
    {
      "indent": 3,
      "text": "[RFC6265] Barth, A., \"HTTP State Management Mechanism\", RFC 6265, April 2011, <http://www.rfc-editor.org/info/rfc6265>.",
      "ja": "[RFC6265]バース、A.、 \"HTTP状態管理機構\"、RFC 6265、2011年4月、<http://www.rfc-editor.org/info/rfc6265>。"
    },
    {
      "indent": 3,
      "text": "[RFC6376] Crocker, D., Ed., Hansen, T., Ed., and M. Kucherawy, Ed., \"DomainKeys Identified Mail (DKIM) Signatures\", STD 76, RFC 6376, September 2011, <http://www.rfc-editor.org/info/rfc6376>.",
      "ja": "[RFC6376]クロッカー、D.、編、ハンセン、T.、エド、及びM. Kucherawy、エド、 \"ドメインキー・アイデンティファイド・メール（DKIM）署名\"、STD 76、RFC 6376、2011年9月、<HTTP：。。。/ /www.rfc-editor.org/info/rfc6376>。"
    },
    {
      "indent": 3,
      "text": "[ThreatReport] Sophos, \"Security Threat Report 2013\", January 2013, <http://www.sophos.com/en-us/medialibrary/pdfs/other/ sophossecuritythreatreport2013.pdf>.",
      "ja": "[ThreatReport]ソフォス、 \"セキュリティ脅威レポート2013\"、2013年1月、<http://www.sophos.com/en-us/medialibrary/pdfs/other/ sophossecuritythreatreport2013.pdf>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Problems with Passwords",
      "ja": "パスワード付き付録A.問題"
    },
    {
      "indent": 3,
      "text": "By far, the most common mechanism for web authentication is passwords that can be remembered by the user, called \"human-memorable passwords\". There is plenty of good research on how users typically use human-memorable passwords (e.g., see [Bonneau]), but some of the highlights are that users typically try hard to reuse passwords on as many web sites as possible, and that web sites often use either email addresses or users' names as the identifiers that go with these passwords.",
      "ja": "遠くでは、Web認証のための最も一般的なメカニズムは、ユーザによって記憶させることができ、パスワード、いわゆる「人間の記憶に残るパスワード」です。そのウェブサイトがあり、ユーザーは通常、人間の記憶に残るパスワードを使う方法についての良い研究の多くは、（例えば、[ボノー]を参照）ですが、ハイライトのいくつかは、ユーザーが一般的に可能な限り多くのウェブサイトでパスワードを再利用するために努力していることであり、多くの場合、これらのパスワードで行く識別子としての電子メールアドレスまたはユーザー名のいずれかを使用します。"
    },
    {
      "indent": 3,
      "text": "If an attacker gets access to the database of memorizable passwords, that attacker can impersonate any of the users. Even if the breach is discovered, the attacker can still impersonate users until every password is changed. Even if all the passwords are changed or at least made unusable, the attacker now possesses a list of likely username/password pairs that might exist on other sites.",
      "ja": "攻撃者は記憶可能なパスワードのデータベースへのアクセス権を取得した場合、その攻撃者は、ユーザーのいずれかを偽装することができます。違反が発見された場合でも、すべてのパスワードが変更されるまで、攻撃者はまだユーザーを偽装することができます。すべてのパスワードが変更または少なくとも使用不可とされている場合でも、攻撃者は現在、他のサイトに存在する可能性がある可能性が高いユーザー名/パスワードのペアのリストを持っています。"
    },
    {
      "indent": 3,
      "text": "Using memorizable passwords on unencrypted channels also poses risks to the users. If a web site uses either the HTTP Basic authentication method, or an HTML form that does no cryptographic protection of the password in transit, a passive attacker can see the password and immediately impersonate the user. If a hash-based authentication scheme such as HTTP Digest authentication is used, a passive attacker still has a high chance of being able to determine the password using a dictionary of known passwords.",
      "ja": "暗号化されていないチャンネルに記憶可能なパスワードを使用すると、ユーザーに危険をもたらします。ウェブサイトは、HTTP基本認証方法、または輸送中のパスワードのない暗号保護しませんHTMLフォームのいずれかを使用している場合は、受動的攻撃者がパスワードを見ると、すぐにユーザーを偽装することができます。そのようなHTTPダイジェスト認証などのハッシュベースの認証方式を使用する場合は、受動的攻撃者は、まだ知られているパスワードの辞書を使用してパスワードを決定することができるという可能性が高くなります。"
    },
    {
      "indent": 3,
      "text": "Note that passwords that are not human-memorable are still subject to database attack, though they are of course unlikely to be reused across many systems. Similarly, database attacks of some form or other will work against any password-based authentication scheme, regardless of the cryptographic protocol used. So for example, zero-knowledge or Password-Authenticated Key Exchange (PAKE) schemes, though making use of elegant cryptographic protocols, remain as vulnerable to what is clearly the most common exploit seen when it comes to passwords. HOBA is, however, not vulnerable to database theft.",
      "ja": "彼らはもちろん、多くのシステムで再利用されそうにないものの、人間が記憶に残るではありませんパスワードは、まだデータベースの攻撃を受けていることに注意してください。同様に、いくつかのフォームまたは他のデータベース攻撃に関係なく使用される暗号化プロトコルの、任意のパスワードベースの認証方式に対して動作します。だから、例えば、ゼロ知識やパスワード認証鍵交換（PAKE）スキームは、エレガントな暗号プロトコルを利用しているが、明確に最も一般的にはそれがパスワードに来るとき見悪用しているものにのように脆弱なまま。 HOBAは、しかし、データベースの盗難に対して脆弱ではありません。"
    },
    {
      "indent": 0,
      "text": "Appendix B. Example",
      "ja": "付録B.例"
    },
    {
      "indent": 3,
      "text": "The following values show an example of HOBA-http authentication to the origin \"https://example.com:443\". Carriage returns have been added and need to be removed to validate the example.",
      "ja": "次の値が「https://example.com:443」の原点にHOBA-HTTP認証の例を示しています。改行が追加され、一例を検証するために除去する必要がされています。"
    },
    {
      "indent": 3,
      "text": "Public Key:",
      "ja": "公開鍵："
    },
    {
      "indent": 3,
      "text": "-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAviE8fMrGIPZN9up94M28\n6o38B99fsz5cUqYHXXJlnHIi6gGKjqLgn3P7n4snUSQswLExrkhSr0TPhRDuPH_t\nfXLKLBbh17ofB7t7shnPKxmyZ69hCLbe7pB1HvaBzTxPC2KOqskDiDBOQ6-JLHQ8\negXB14W-641RQt0CsC5nXzo92kPCdV4NZ45MW0ws3twCIUDCH0nibIG9SorrBbCl\nDPHQZS5Dk5pgS7P5hrAr634Zn4bzXhUnm7cON2x4rv83oqB3lRqjF4T9exEMyZBS\nL26m5KbK860uSOKywI0xp4ymnHMc6Led5qfEMnJC9PEI90tIMcgdHrmdHC_vpldG\nDQIDAQAB\n-----END PUBLIC KEY-----",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Origin: https://example.com:443",
      "ja": "原産地：https://example.com:443"
    },
    {
      "indent": 3,
      "text": "Key Identifier: vesscamS2Kze4FFOg3e2UyCJPhuQ6_3_gzN-k_L6t3w",
      "ja": "キー識別子：vesscamS2Kze4FFOg3e2UyCJPhuQ6_3_gzN-k_L6t3w"
    },
    {
      "indent": 3,
      "text": "Challenge: pUE77w0LylHypHKhBqAiQHuGC751GiOVv4/7pSlo9jc=",
      "ja": "チャレンジ：pUE77w0LylHypHKhBqAiQHuGC751GiOVv4 / 7pSlo9jc ="
    },
    {
      "indent": 3,
      "text": "Signature algorithm: RSA-SHA256 (\"0\")",
      "ja": "署名アルゴリズム：RSA-SHA256（ \"0\"）"
    },
    {
      "indent": 3,
      "text": "Nonce: Pm3yUW-sW5Q",
      "ja": "使節：Pm3yUW-sW5Q"
    },
    {
      "indent": 3,
      "text": "Signature:",
      "ja": "署名："
    },
    {
      "indent": 3,
      "text": "VD-0LGVBVEVjfq4xEd35FjnOrIqzJ2OQMx5w8E52dgVvxFD6R0ryEsHcD31ykh0i 4YIzIHXirx7bE4x9yP-9fMBCEwnHJsYwYQhfRpmScwAz-Ih1Hn4yORTb-U66miUz q04ZgTHm4jAj45afU20wYpGXY2r3W-FRKc6J6Glv_zI_ROghERalxgXG-QVGZrKP tG0V593Yf9IPnFSpLyW6fnxscCMWUA9T-4NjMdypI-Ze4HsC9J06tRTOunQdofr9 6ZJ2i9LE6uKSUDLCD2oeEeSEvUR--4OGtrgjzYysHZkdVSxAi7OoQBK34EUWg9kI S13qQA43m4IMExkbApqrSg",
      "ja": "CEO 0LGVBVEVjfq4xEd35FjnOrIqzJ2OQMx5w8E52dgVvxFD6R0ryEsHcD31ykh0i 4YIzIHXirx7bE4x9yP-9fMBCEwnHJsYwYQhfRpmScwAz-Ih1Hn4yORTb-U66miUz q04ZgTHm4jAj45afU20wYpGXY2r3W-FRKc6J6Glv_zI_ROghERalxgXG-QVGZrKP tG0V593Yf9IPnFSpLyW6fnxscCMWUA9T-4NjMdypI-Ze4HsC9J06tRTOunQdofr9 6ZJ2i9LE6uKSUDLCD2oeEeSEvUR  -  4OGtrgjzYysHZkdVSxAi7OoQBK34EUWg9kI S13qQA43m4IMExkbApqrSg"
    },
    {
      "indent": 3,
      "text": "Authorization Header:",
      "ja": "認証ヘッダー："
    },
    {
      "indent": 3,
      "text": "Authorization: HOBA result=\"vesscamS2Kze4FFOg3e2UyCJPhuQ6_3_gzN-k_L6t3w.pUE77w0LylHypHKhBqAiQHuGC751GiOVv4/7pSlo9jc=.Pm3yUW-sW5Q .VD-0LGVBVEVjfq4xEd35FjnOrIqzJ2OQMx5w8E52dgVvxFD6R0ryEsHcD31ykh0 i4YIzIHXirx7bE4x9yP-9fMBCEwnHJsYwYQhfRpmScwAz-Ih1Hn4yORTb-U66miU zq04ZgTHm4jAj45afU20wYpGXY2r3W-FRKc6J6Glv_zI_ROghERalxgXG-QVGZrK PtG0V593Yf9IPnFSpLyW6fnxscCMWUA9T-4NjMdypI-Ze4HsC9J06tRTOunQdofr 96ZJ2i9LE6uKSUDLCD2oeEeSEvUR--4OGtrgjzYysHZkdVSxAi7OoQBK34EUWg9k IS13qQA43m4IMExkbApqrSg\"",
      "ja": "認可：HOBA結果= \"vesscamS2Kze4FFOg3e2UyCJPhuQ6_3_gzN-k_L6t3w.pUE77w0LylHypHKhBqAiQHuGC751GiOVv4 / 7pSlo9jc = .Pm3yUW-sW5Q .VD-0LGVBVEVjfq4xEd35FjnOrIqzJ2OQMx5w8E52dgVvxFD6R0ryEsHcD31ykh0 i4YIzIHXirx7bE4x9yP-9fMBCEwnHJsYwYQhfRpmScwAz-Ih1Hn4yORTb-U66miU zq04ZgTHm4jAj45afU20wYpGXY2r3W-FRKc6J6Glv_zI_ROghERalxgXG-QVGZrK PtG0V593Yf9IPnFSpLyW6fnxscCMWUA9T-4NjMdypI-Ze4HsC9J06tRTOunQdofr 96ZJ2i9LE6uKSUDLCD2oeEeSEvUR  -  4OGtrgjzYysHZkdVSxAi7OoQBK34EUWg9k IS13qQA43m4IMExkbApqrSg\""
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Thanks to the following for good comments received during the preparation of this specification: Richard Barnes, David Black, Alissa Cooper, Donald Eastlake, Amos Jeffries, Benjamin Kaduk, Watson Ladd, Barry Leiba, Matt Lepinski, Ilari Liusvaara, James Manger, Alexey Melnikov, Kathleen Moriarty, Yoav Nir, Mark Nottingham, Julian Reschke, Pete Resnick, Michael Richardson, Yaron Sheffer, and Michael Sweet. All errors and stupidities are of course the editors' fault.",
      "ja": "この仕様書の作成中に受信良いコメントを次のようにありがとう：リチャード・バーンズ、デヴィッド・ブラック、アリッサ・クーパー、ドナルドイーストレイク、アモスジェフリーズ、ベンジャミンKaduk、ワトソンラッド、バリー・レイバ、マット・Lepinski、Ilari Liusvaara、ジェームス・マンジェ、アレクセイ・メルニコフ、キャスリーン・モリアーティ、ヨアフニール、マーク・ノッティンガム、ジュリアンReschke、ピート・レズニック、マイケル・リチャードソン、ヤロンシェファー、そしてマイケル・スウィート。すべてのエラーと愚かはもちろん編集者の障害です。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Stephen Farrell Trinity College Dublin Dublin 2 Ireland",
      "ja": "スティーブン・ファレルトリニティ・カレッジ・ダブリンダブリンアイルランド"
    },
    {
      "indent": 3,
      "text": "Phone: +353-1-896-2354 EMail: stephen.farrell@cs.tcd.ie",
      "ja": "電話：+ 353-1-896-2354 Eメール：stephen.farrell@cs.tcd.ie"
    },
    {
      "indent": 3,
      "text": "Paul Hoffman VPN Consortium",
      "ja": "ポール・ホフマンVPNコンソーシアム"
    },
    {
      "indent": 3,
      "text": "EMail: paul.hoffman@vpnc.org",
      "ja": "メールアドレス：paul.hoffman@vpnc.org"
    },
    {
      "indent": 3,
      "text": "Michael Thomas Phresheez",
      "ja": "トーマスmincayela phresijha"
    },
    {
      "indent": 3,
      "text": "EMail: mike@phresheez.com",
      "ja": "メールアドレス：mike@phresheez.com"
    }
  ]
}