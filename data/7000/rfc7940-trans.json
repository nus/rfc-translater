{
  "title": {
    "text": "RFC 7940 - Representing Label Generation Rulesets Using XML",
    "ja": "RFC 7940 - XMLを使用したラベル生成ルールセットを表します"
  },
  "number": 7940,
  "created_at": "2019-11-02 09:44:00.444309+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                         K. Davies\nRequest for Comments: 7940                                         ICANN\nCategory: Standards Track                                     A. Freytag\nISSN: 2070-1721                                              ASMUS, Inc.\n                                                             August 2016",
      "raw": true
    },
    {
      "indent": 12,
      "text": "Representing Label Generation Rulesets Using XML",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document describes a method of representing rules for validating identifier labels and alternate representations of those labels using Extensible Markup Language (XML). These policies, known as \"Label Generation Rulesets\" (LGRs), are used for the implementation of Internationalized Domain Names (IDNs), for example. The rulesets are used to implement and share that aspect of policy defining which labels and Unicode code points are permitted for registrations, which alternative code points are considered variants, and what actions may be performed on labels containing those variants.",
      "ja": "このドキュメントは、識別子ラベルやXML（Extensible Markup Language）を用いて、これらのラベルの代替表現を検証するためのルールを表現する方法を記載しています。 「ラベル生成ルールセット」（LGRs）、として知られているこれらのポリシーは、例えば、国際化ドメイン名（IDNの）の実装に使用されています。ルールセットは、別のコード・ポイントは、変異体とみなされ、そしてどのようなアクションは、それらの変異体を含むラベルに実行することができるラベルとUnicodeコードポイントを登録するために許可されているポリシー定義のその側面を実装し、共有するために使用されます。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 7841のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7940.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7940で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2016 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2016 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................4\n2. Design Goals ....................................................5\n3. Normative Language ..............................................6\n4. LGR Format ......................................................6\n   4.1. Namespace ..................................................7\n   4.2. Basic Structure ............................................7\n   4.3. Metadata ...................................................8\n        4.3.1. The \"version\" Element ...............................8\n        4.3.2. The \"date\" Element ..................................9\n        4.3.3. The \"language\" Element ..............................9\n        4.3.4. The \"scope\" Element ................................10\n        4.3.5. The \"description\" Element ..........................10\n        4.3.6. The \"validity-start\" and \"validity-end\" Elements ...11\n        4.3.7. The \"unicode-version\" Element ......................11\n        4.3.8. The \"references\" Element ...........................12\n5. Code Points and Variants .......................................13\n   5.1. Sequences .................................................14\n   5.2. Conditional Contexts ......................................15\n   5.3. Variants ..................................................16\n        5.3.1. Basic Variants .....................................16\n        5.3.2. The \"type\" Attribute ...............................17\n        5.3.3. Null Variants ......................................18\n        5.3.4. Variants with Reflexive Mapping ....................19\n        5.3.5. Conditional Variants ...............................20\n   5.4. Annotations ...............................................22\n        5.4.1. The \"ref\" Attribute ................................22\n        5.4.2. The \"comment\" Attribute ............................23\n   5.5. Code Point Tagging ........................................23",
      "raw": true
    },
    {
      "indent": 3,
      "text": "6. Whole Label and Context Evaluation .............................23\n   6.1. Basic Concepts ............................................23\n   6.2. Character Classes .........................................25\n        6.2.1. Declaring and Invoking Named Classes ...............25\n        6.2.2. Tag-Based Classes ..................................26\n        6.2.3. Unicode Property-Based Classes .....................26\n        6.2.4. Explicitly Declared Classes ........................28\n        6.2.5. Combined Classes ...................................29\n   6.3. Whole Label and Context Rules .............................30\n        6.3.1. The \"rule\" Element .................................31\n        6.3.2. The Match Operators ................................32\n        6.3.3. The \"count\" Attribute ..............................33\n        6.3.4. The \"name\" and \"by-ref\" Attributes .................34\n        6.3.5. The \"choice\" Element ...............................34\n        6.3.6. Literal Code Point Sequences .......................35\n        6.3.7. The \"any\" Element ..................................35\n        6.3.8. The \"start\" and \"end\" Elements .....................35\n        6.3.9. Example Context Rule from IDNA Specification .......36\n   6.4. Parameterized Context or When Rules .......................37\n        6.4.1. The \"anchor\" Element ...............................37\n        6.4.2. The \"look-behind\" and \"look-ahead\" Elements ........38\n        6.4.3. Omitting the \"anchor\" Element ......................40\n7. The \"action\" Element ...........................................40\n   7.1. The \"match\" and \"not-match\" Attributes ....................41\n   7.2. Actions with Variant Type Triggers ........................41\n        7.2.1. The \"any-variant\", \"all-variants\", and\n               \"only-variants\" Attributes .........................41\n        7.2.2. Example from Tables in the Style of RFC 3743 .......44\n   7.3. Recommended Disposition Values ............................45\n   7.4. Precedence ................................................45\n   7.5. Implied Actions ...........................................45\n   7.6. Default Actions ...........................................46\n8. Processing a Label against an LGR ..............................47\n   8.1. Determining Eligibility for a Label .......................47\n        8.1.1. Determining Eligibility Using Reflexive\n               Variant Mappings ...................................47\n   8.2. Determining Variants for a Label ..........................48\n   8.3. Determining a Disposition for a Label or Variant Label ....49\n   8.4. Duplicate Variant Labels ..................................50\n   8.5. Checking Labels for Collision .............................50\n9. Conversion to and from Other Formats ...........................51\n10. Media Type ....................................................51\n11. IANA Considerations ...........................................52\n   11.1. Media Type Registration ..................................52\n   11.2. URN Registration .........................................53\n   11.3. Disposition Registry .....................................53",
      "raw": true
    },
    {
      "indent": 3,
      "text": "12. Security Considerations .......................................54\n   12.1. LGRs Are Only a Partial Remedy for Problem Space .........54\n   12.2. Computational Expense of Complex Tables ..................54\n13. References ....................................................55\n   13.1. Normative References .....................................55\n   13.2. Informative References ...................................56\nAppendix A. Example Tables ........................................58\nAppendix B. How to Translate Tables Based on RFC 3743 into the\n            XML Format ............................................63\nAppendix C. Indic Syllable Structure Example ......................68\n   C.1. Reducing Complexity .......................................70\nAppendix D. RELAX NG Compact Schema ...............................71\nAcknowledgements ..................................................82\nAuthors' Addresses ................................................82",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "This document specifies a method of using Extensible Markup Language (XML) to describe Label Generation Rulesets (LGRs). LGRs are algorithms used to determine whether, and under what conditions, a given identifier label is permitted, based on the code points it contains and their context. These algorithms comprise a list of permissible code points, variant code point mappings, and a set of rules that act on the code points and mappings. LGRs form part of an administrator's policies. In deploying Internationalized Domain Names (IDNs), they have also been known as IDN tables or variant tables.",
      "ja": "このドキュメントでは、ラベル生成ルールセット（LGRs）を記述するためにXML（Extensible Markup Language）を使用する方法を指定します。 LGRsかどうか、そしてどのような条件の下で決定するために使用されるアルゴリズムは、与えられた識別子ラベルは、コードが含まれている点と、それらのコンテキストに基づいて、許可されています。これらのアルゴリズムは、許容コードポイント、バリアントコードポイントのマッピングのリスト、およびコードポイントおよびマッピングに作用するルールのセットを含みます。 LGRsは、管理者の政策の一部を形成します。国際化ドメイン名（IDNのを）展開では、彼らはまた、IDNテーブルまたはバリアントテーブルとして知られています。"
    },
    {
      "indent": 3,
      "text": "There are other kinds of policies relating to labels that are not normally covered by LGRs and are therefore not necessarily representable by the XML format described here. These include, but are not limited to, policies around trademarks, or prohibition of fraudulent or objectionable words.",
      "ja": "通常LGRsでカバーされていないので、必ずしもここに記述されたXML形式で表現されていないラベルに関連する政策の他の種類があります。これらには、商標に関するポリシー、または詐欺的または不快な言葉の禁止が、これらに限定されません。"
    },
    {
      "indent": 3,
      "text": "Administrators of the zones for top-level domain registries have historically published their LGRs using ASCII text or HTML. The formatting of these documents has been loosely based on the format used for the Language Variant Table described in [RFC3743]. [RFC4290] also provides a \"model table format\" that describes a similar set of functionality. Common to these formats is that the algorithms used to evaluate the data therein are implicit or specified elsewhere.",
      "ja": "トップレベルドメインのレジストリのゾーンの管理者は、歴史的にASCIIテキストまたはHTMLを使用してLGRsを公開しています。これらの文書の書式設定は緩く[RFC3743]に記載の言語バリアントテーブルの使用形式に基づいています。 [RFC4290]は、また、機能の類似のセットを記述する「モデルテーブル形式」を提供します。これらのフォーマットに共通のデータを評価するために使用されるアルゴリズムは、その中に暗黙的または他の場所に指定されていることです。"
    },
    {
      "indent": 3,
      "text": "Through the first decade of IDN deployment, experience has shown that LGRs derived from these formats are difficult to consistently implement and compare, due to their differing formats. A universal format, such as one using a structured XML format, will assist by improving machine readability, consistency, reusability, and maintainability of LGRs.",
      "ja": "IDNの展開の最初の十年を経て、経験がこ​​れらのフォーマットから派生LGRsがそれらの異なる形式のために、一貫して実施し、比較することは困難であることが示されています。ユニバーサルフォーマット、構造化されたXMLフォーマットを使用するものなどは、機械可読性、一貫性、再利用性、およびLGRsの保守性を向上させることにより支援します。"
    },
    {
      "indent": 3,
      "text": "When used to represent a simple list of permitted code points, the format is quite straightforward. At the cost of some complexity in the resulting file, it also allows for an implementation of more sophisticated handling of conditional variants that reflects the known requirements of current zone administrator policies.",
      "ja": "許可コードポイントの単純なリストを表すために使用される場合、フォーマットは非常に簡単です。結果のファイルにいくつかの複雑さを犠牲にし、それはまた、現在のゾーン管理者ポリシーの既知の要件を反映して、条件付きの変異体より洗練されたハンドリングを実現することができます。"
    },
    {
      "indent": 3,
      "text": "Another feature of this format is that it allows many of the algorithms to be made explicit and machine implementable. A remaining small set of implicit algorithms is described in this document to allow commonality in implementation.",
      "ja": "この形式のもう一つの特徴は、それがアルゴリズムの多くは、明示的および機械実行可能な行うことを可能にするということです。暗黙的なアルゴリズムの残りの小さなセットが実装で共通性を可能にするために、この文書に記載されています。"
    },
    {
      "indent": 3,
      "text": "While the predominant usage of this specification is to represent IDN label policy, the format is not limited to IDN usage and may also be used for describing ASCII domain name label rulesets, or other types of identifier labels beyond those used for domain names.",
      "ja": "本明細書の主な使用は、IDNラベルポリシーを表現することであるが、フォーマットは、IDNの使用に限定されるものではなく、ASCIIドメイン名ラベルルールセット、またはドメイン名に使用されるものを超え識別子ラベルの他のタイプを記述するために使用することができます。"
    },
    {
      "indent": 0,
      "text": "2. Design Goals",
      "section_title": true,
      "ja": "2.設計目標"
    },
    {
      "indent": 3,
      "text": "The following goals informed the design of this format:",
      "ja": "次の目標は、この形式の設計を知らさ："
    },
    {
      "indent": 3,
      "text": "o The format needs to be implementable in a reasonably straightforward manner in software.",
      "ja": "O形式は、ソフトウェアで合理的に簡単な方法で実装可能である必要があります。"
    },
    {
      "indent": 3,
      "text": "o The format should be able to be automatically checked for formatting errors, so that common mistakes can be caught.",
      "ja": "フォーマットは、一般的なミスをキャッチすることができるように、自動的に、書式設定のエラーをチェックすることができるはずですoを。"
    },
    {
      "indent": 3,
      "text": "o An LGR needs to be able to express the set of valid code points that are allowed for registration under a specific administrator's policies.",
      "ja": "O LGRは、特定の管理者の方針の下で、登録のために許可されている有効なコードポイントのセットを表現できるようにする必要があります。"
    },
    {
      "indent": 3,
      "text": "o An LGR needs to be able to express computed alternatives to a given identifier based on mapping relationships between code points, whether one-to-one or many-to-many. These computed alternatives are commonly known as \"variants\".",
      "ja": "O LGRは、コード・ポイントとの間のマッピング関係に基づいて、指定された識別子に計算された代替案を表現できるようにする必要があるかどうか一対一又は多対多。これらの計算された選択肢は、一般的に「バリアント」として知られています。"
    },
    {
      "indent": 3,
      "text": "o Variant code points should be able to be tagged with explicit dispositions or categories that can be used to support registry policy (such as whether to allocate the computed variant or to merely block it from usage or registration).",
      "ja": "Oバリアントコードポイントは、（例えば、計算された変異体を割り当てるため、または単に使用又は登録からそれをブロックするかどうかなど）のレジストリポリシーをサポートするために使用することができ、明示的な処分またはカテゴリでタグ付けすることができなければなりません。"
    },
    {
      "indent": 3,
      "text": "o Variants and code points must be able to be stipulated based on contextual information. For example, some variants may only be applicable when they follow a certain code point or when the code point is displayed in a specific presentation form.",
      "ja": "O変異体およびコード・ポイントは、コンテキスト情報に基づいて定めることができなければなりません。それらが特定のコードポイントに従うとき、例えば、いくつかの変異体のみ適用可能であり得るか、コード・ポイントは、特定のプレゼンテーション形式で表示されている場合。"
    },
    {
      "indent": 3,
      "text": "o The data contained within an LGR must be able to be interpreted unambiguously, so that independent implementations that utilize the contents will arrive at the same results.",
      "ja": "O LGR内に含まれるデータは、コンテンツを利用する独立した実装が同じ結果に到達するように、明確に解釈することができなければなりません。"
    },
    {
      "indent": 3,
      "text": "o To the largest extent possible, policy rules should be able to be specified in the XML format without relying on hidden or built-in algorithms in implementations.",
      "ja": "可能な最大範囲に対するO、ポリシールールは、実装に隠され、またはビルトインアルゴリズムに頼ることなく、XML形式で指定することができなければなりません。"
    },
    {
      "indent": 3,
      "text": "o LGRs should be suitable for comparison and reuse, such that one could easily compare the contents of two or more to see the differences, to merge them, and so on.",
      "ja": "O LGRsは1つが簡単ようにそれらをマージするため、違いを確認するために、2つ以上の内容を比較し、可能性があり、そのようなことを、比較して再利用するために適しているはずです。"
    },
    {
      "indent": 3,
      "text": "o As many existing IDN tables as practicable should be able to be migrated to the LGR format with all applicable interpretation logic retained.",
      "ja": "O実行可能な限り多くの既存のIDNテーブルが保持し、適用されるすべての解釈ロジックとLGR形式に移行することができるはずです。"
    },
    {
      "indent": 3,
      "text": "These requirements are partly derived from reviewing the existing corpus of published IDN tables, plus the requirements of ICANN's work to implement an LGR for the DNS root zone [LGR-PROCEDURE]. In particular, Section B of that document identifies five specific requirements for an LGR methodology.",
      "ja": "これらの要件は、部分的に公表されIDNテーブルの既存のコーパスを見直しから導出され、プラスICANNの仕事の要件は、DNSのルートゾーン[LGR-PROCEDURE]のためのLGRを実装します。具体的には、そのドキュメントのセクションBは、LGR方法論のための5つの固有の要件を特定します。"
    },
    {
      "indent": 3,
      "text": "The syntax and rules in [RFC5892] and [RFC3743] were also reviewed.",
      "ja": "[RFC5892]と[RFC3743]での構文やルールも検討しました。"
    },
    {
      "indent": 3,
      "text": "It is explicitly not the goal of this format to stipulate what code points should be listed in an LGR by a zone administrator. Which registration policies are used for a particular zone are outside the scope of this memo.",
      "ja": "明示的にコードポイントは、ゾーン管理者によってLGRに記載されているべきであるものを規定するために、このフォーマットの目的ではありません。特定のゾーンに使用されている登録ポリシーは、このメモの範囲外です。"
    },
    {
      "indent": 0,
      "text": "3. Normative Language",
      "section_title": true,
      "ja": "3.規範言語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はあります[RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "4. LGR Format",
      "section_title": true,
      "ja": "4.フォーマットLGR"
    },
    {
      "indent": 3,
      "text": "An LGR is expressed as a well-formed XML document [XML] that conforms to the schema defined in Appendix D.",
      "ja": "LGRは付録Dで定義されたスキーマに準拠する整形式XML文書[XML]のように表現されます"
    },
    {
      "indent": 3,
      "text": "As XML is case sensitive, an LGR must be authored with the correct casing. For example, the XML element names MUST be in lowercase as described in this specification, and matching of attribute values is only performed in a case-sensitive manner.",
      "ja": "XMLは大文字と小文字が区別されますと、LGRは正しいケースでオーサリングされなければなりません。本明細書に記載され、属性値のマッチングのみ大文字と小文字を区別ように行われているように、例えば、XML要素名は小文字でなければなりません。"
    },
    {
      "indent": 3,
      "text": "A document that is not well-formed, is non-conforming, or violates other constraints specified in this specification MUST be rejected.",
      "ja": "整形されていない文書は、不適合であるか、またはこの仕様書で指定された他の制約を拒絶しなければなりません違反します。"
    },
    {
      "indent": 0,
      "text": "4.1. Namespace",
      "section_title": true,
      "ja": "4.1. 名前空間"
    },
    {
      "indent": 3,
      "text": "The XML Namespace URI is \"urn:ietf:params:xml:ns:lgr-1.0\".",
      "ja": "XML名前空間URIは、 \"URN：IETF：のparams：XML：NS：LGR-1.0\" です。"
    },
    {
      "indent": 3,
      "text": "See Section 11.2 for more information.",
      "ja": "詳細は項11.2を参照してください。"
    },
    {
      "indent": 0,
      "text": "4.2. Basic Structure",
      "section_title": true,
      "ja": "4.2. 基本構造"
    },
    {
      "indent": 3,
      "text": "The basic XML framework of the document is as follows:",
      "ja": "次のように文書の基本的なXMLフレームワークは、次のとおりです。"
    },
    {
      "indent": 7,
      "text": "<?xml version=\"1.0\"?>\n<lgr xmlns=\"urn:ietf:params:xml:ns:lgr-1.0\">\n    ...\n</lgr>",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The \"lgr\" element contains up to three sub-elements or sections. First is an optional \"meta\" element that contains all metadata associated with the LGR, such as its authorship, what it is used for, implementation notes, and references. This is followed by a required \"data\" element that contains the substantive code point data. Finally, an optional \"rules\" element contains information on rules for evaluating labels, if any, along with \"action\" elements providing for the disposition of labels and computed variant labels.",
      "ja": "「LGR」要素は、以下の3つのサブ要素またはセクションまでを含みます。まずLGRに関連するすべてのメタデータを含む、オプションの「メタ」の要素があり、そのようなそのそれがために使用されているものの原作者、実装ノート、およびリファレンスとして。これは実質的なコードポイントデータを含む必要な「データ」エレメントが続きます。最後に、オプションの「ルール」要素は、ラベルと計算された変異体ラベルの配置を提供する「アクション」の要素と共に、もしあれば、ラベルを評価するための規則に関する情報を含みます。"
    },
    {
      "indent": 7,
      "text": "<?xml version=\"1.0\"?>\n<lgr xmlns=\"urn:ietf:params:xml:ns:lgr-1.0\">\n    <meta>\n        ...\n    </meta>\n    <data>\n        ...\n    </data>\n    <rules>\n        ...\n    </rules>\n</lgr>",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A document MUST contain exactly one \"lgr\" element. Each \"lgr\" element MUST contain zero or one \"meta\" element, exactly one \"data\" element, and zero or one \"rules\" element; and these three elements MUST be in that order.",
      "ja": "文書は、1つの「LGR」要素を含まなければなりません。各「LGR」要素は、0または1「メタ」要素、正確に一つの「データ」要素、およびゼロまたは1「ルール」要素を含まなければなりません。これら3つの要素は、この順序でなければなりません。"
    },
    {
      "indent": 3,
      "text": "Some elements that are direct or nested child elements of the \"rules\" element MUST be placed in a specific relative order to other elements for the LGR to be valid. An LGR that violates these constraints MUST be rejected. In other cases, changing the ordering would result in a valid, but different, specification.",
      "ja": "「ルール」要素の直接またはネストされた子要素であり、いくつかの要素が有効であるとLGRのために他の要素に特定の相対的な順序に置かなければなりません。これらの制約に違反するLGRを拒絶しなければなりません。他の例では、順序を変更することは有効ではなく、異なる、仕様になります。"
    },
    {
      "indent": 3,
      "text": "In the following descriptions, required, non-repeating elements or attributes are generally not called out explicitly, in contrast to \"OPTIONAL\" ones, or those that \"MAY\" be repeated. For attributes that take lists as values, the elements MUST be space-separated.",
      "ja": "以下の説明では、必要に応じ、非反復要素や属性は、一般的に明示的に呼び出されていない、「オプション」のものとは対照的に、または繰り返すことが「MAY」もの。値としてリストをとる属性の場合、要素はスペースで区切る必要があります。"
    },
    {
      "indent": 0,
      "text": "4.3. Metadata",
      "section_title": true,
      "ja": "4.3. メタデータ"
    },
    {
      "indent": 3,
      "text": "The \"meta\" element expresses metadata associated with the LGR, and the element SHOULD be included so that the associated metadata are available as part of the LGR and cannot become disassociated. The following subsections describe elements that may appear within the \"meta\" element.",
      "ja": "「メタ」要素は、LGRに関連付けられたメタデータを表し、要素は、関連するメタデータはLGRの一部として利用可能であり、解離なることができないように含まれるべきです。以下のサブセクションでは、「メタ」要素内に表示されることがあり要素について説明します。"
    },
    {
      "indent": 3,
      "text": "The \"meta\" element can be used to identify the author or relevant contact person, explain the intended usage of the LGR, and provide implementation notes as well as references. Detailed metadata allow the LGR document to become self-documenting -- for example, if rendered in a human-readable format by an appropriate tool.",
      "ja": "「メタ」の要素は、作者または関連する担当者を識別LGRの使用目的を説明し、実装ノートなどの参照を提供するために使用することができます。詳細メタデータは、LGR文書は自己文書化になることを可能に - 例えば、適切な工具により人間が読める形式でレンダリング場合。"
    },
    {
      "indent": 3,
      "text": "Providing metadata pertaining to the date and version of the LGR is particularly encouraged to make it easier for interoperating consumers to ensure that they are using the correct LGR.",
      "ja": "日付とLGRのバージョンに関連するメタデータを提供することは、特に彼らは正しいLGRを使用していることを確認するために、消費者を相互運用するためにそれを容易にすることが推奨されます。"
    },
    {
      "indent": 3,
      "text": "With the exception of the \"unicode-version\" element, the data contained within is not required by software consuming the LGR in order to calculate valid labels or to calculate variants. If present, the \"unicode-version\" element MUST be used by a consumer of the table to identify that it has the correct Unicode property data to perform operations on the table. This ensures that possible differences in code point properties between editions of the Unicode Standard do not impact the product of calculations utilizing an LGR.",
      "ja": "「ユニコード・バージョン」の要素を除いて、中に含まれるデータは、有効なラベルを計算するか、バリアントを計算するために、LGRを消費するソフトウェアによって必要とされていません。存在する場合、「ユニコードバージョン」エレメントは、それがテーブルの上に操作を実行するための正しいUnicodeの特性データを有していることを識別するために、テーブルの消費者によって使用されなければなりません。これは、Unicode標準のエディションの間のコードポイントのプロパティが異なる可能性がLGRを利用した計算の製品に影響を与えないことを保証します。"
    },
    {
      "indent": 0,
      "text": "4.3.1. The \"version\" Element",
      "section_title": true,
      "ja": "4.3.1.  「バージョン」の要素"
    },
    {
      "indent": 3,
      "text": "The \"version\" element is OPTIONAL. It is used to uniquely identify each version of the LGR. No specific format is required, but it is RECOMMENDED that it be the decimal representation of a single positive integer, which is incremented with each revision of the file.",
      "ja": "「バージョン」要素はオプションです。一意LGRの各バージョンを識別するために使用されます。特別なフォーマットが必要とされないが、それがファイルの各リビジョンでインクリメントされ、単一の正の整数の10進表現であることが推奨されます。"
    },
    {
      "indent": 3,
      "text": "An example of a typical first edition of a document:",
      "ja": "文書の典型的な初版の例："
    },
    {
      "indent": 7,
      "text": "<version>1</version>",
      "ja": "<バージョン> 1 </バージョン>"
    },
    {
      "indent": 3,
      "text": "The \"version\" element may have an OPTIONAL \"comment\" attribute.",
      "ja": "「バージョン」要素はオプション「コメント」の属性を有することができます。"
    },
    {
      "indent": 7,
      "text": "<version comment=\"draft\">1</version>",
      "ja": "<バージョンコメント= \"ドラフト\"> 1 </バージョン>"
    },
    {
      "indent": 0,
      "text": "4.3.2. The \"date\" Element",
      "section_title": true,
      "ja": "4.3.2.  「日付」要素"
    },
    {
      "indent": 3,
      "text": "The OPTIONAL \"date\" element is used to identify the date the LGR was posted. The contents of this element MUST be a valid ISO 8601 \"full-date\" string as described in [RFC3339].",
      "ja": "オプション「日付」要素は、LGRが掲載された日付を識別するために使用されます。 [RFC3339]で説明したように、この要素の内容は、有効なISO 8601「のフル日」文字列でなければなりません。"
    },
    {
      "indent": 3,
      "text": "Example of a date:",
      "ja": "日付の例："
    },
    {
      "indent": 7,
      "text": "<date>2009-11-01</date>",
      "ja": "<日時> 2009年11月1日</日>"
    },
    {
      "indent": 0,
      "text": "4.3.3. The \"language\" Element",
      "section_title": true,
      "ja": "4.3.3.  「言語」の要素"
    },
    {
      "indent": 3,
      "text": "Each OPTIONAL \"language\" element identifies a language or script for which the LGR is intended. The value of the \"language\" element MUST be a valid language tag as described in [RFC5646]. The tag may refer to a script plus undefined language if the LGR is not intended for a specific language.",
      "ja": "各オプション「言語」の要素は、LGRが意図されている言語やスクリプトを識別します。 [RFC5646]に記載されているように「言語」要素の値は、有効な言語タグでなければなりません。 LGRは、特定の言語のために意図されていない場合、タグはスクリプトプラス未定義の言語を参照してもよいです。"
    },
    {
      "indent": 3,
      "text": "Example of an LGR for the English language:",
      "ja": "英語のためのLGRの例："
    },
    {
      "indent": 7,
      "text": "<language>en</language>",
      "ja": "<言語>専用</言語>"
    },
    {
      "indent": 3,
      "text": "If the LGR applies to a script rather than a specific language, the \"und\" language tag SHOULD be used followed by the relevant script subtag from [RFC5646]. For example, for a Cyrillic script LGR:",
      "ja": "LGRがスクリプトではなく、特定の言語に適用される場合、「ウント」言語タグは、[RFC5646]から関連するスクリプトサブタグ続いて使用されるべきです。たとえば、キリル文字のLGRのために："
    },
    {
      "indent": 7,
      "text": "<language>und-Cyrl</language>",
      "ja": "<言語>と-Cyrl </言語>"
    },
    {
      "indent": 3,
      "text": "If the LGR covers a set of multiple languages or scripts, the \"language\" element MAY be repeated. However, for cases of a script-specific LGR exhibiting insignificant admixture of code points from other scripts, it is RECOMMENDED to use a single \"language\" element identifying the predominant script. In the exceptional case of a multi-script LGR where no script is predominant, use Zyyy (Common):",
      "ja": "LGRは、複数の言語やスクリプトのセットをカバーする場合は、「言語」の要素を繰り返すことができます。しかしながら、他のスクリプトからコードポイントの有意でない混合物を示すスクリプト固有LGRの場合について、優勢なスクリプトを識別する単一の「言語」要素を使用することが推奨されます。いかなるスクリプトが支配的でないマルチスクリプトLGRの例外的な場合には、Zyyy（共通）を使用します。"
    },
    {
      "indent": 7,
      "text": "<language>und-Zyyy</language>",
      "ja": "<言語>と-Zyyy </言語>"
    },
    {
      "indent": 0,
      "text": "4.3.4. The \"scope\" Element",
      "section_title": true,
      "ja": "4.3.4.  「スコープ」の要素"
    },
    {
      "indent": 3,
      "text": "This OPTIONAL element refers to a scope, such as a domain, to which this policy is applied. The \"type\" attribute specifies the type of scope being defined. A type of \"domain\" means that the scope is a domain that represents the apex of the DNS zone to which the LGR is applied. For that type, the content of the \"scope\" element MUST be a domain name written relative to the root zone, in presentation format with no trailing dot. However, in the unique case of the DNS root zone, it is represented as \".\".",
      "ja": "この任意の要素は、このポリシーが適用されるドメインなど、範囲を指します。 「タイプ」属性が定義されているスコープのタイプを指定します。 「ドメイン」のタイプは、範囲がLGRが適用されたDNSゾーンの頂点を表すドメインであることを意味します。その型は、「スコープ」元素の含有量は、末尾のドットとプレゼンテーション形式で、ルートゾーンに対して書かれたドメイン名でなければなりません。しかし、DNSのルートゾーンのユニークな場合には、それは次のように表現され、「」。"
    },
    {
      "indent": 7,
      "text": "<scope type=\"domain\">example.com</scope>",
      "ja": "<スコープタイプ= \"ドメイン\"> example.com </スコープ>"
    },
    {
      "indent": 3,
      "text": "There may be multiple \"scope\" tags used -- for example, to reflect a list of domains to which the LGR is applied.",
      "ja": "使用される複数の「スコープ」タグが存在してもよい - 例えば、LGRが適用されるドメインのリストを反映します。"
    },
    {
      "indent": 3,
      "text": "No other values of the \"type\" attribute are defined by this specification; however, this specification can be used for applications other than domain names. Implementers of LGRs for applications other than domain names SHOULD define the scope extension grammar in an IETF specification or use XML namespaces to distinguish their scoping mechanism distinctly from the base LGR namespace. An explanation of any custom usage of the scope in the \"description\" element is RECOMMENDED.",
      "ja": "「タイプ」属性の他の値は、この仕様で定義されていません。しかし、この仕様は、ドメイン名以外の用途に使用することができます。ドメイン名以外の用途のためにLGRsの実装は、IETF仕様スコープ拡張文法を定義したり、ベースLGR名前空間から明らかにそのスコープ機構を区別するために、XML名前空間を使用すべきです。 「説明」要素内のスコープのいずれかのカスタム使用状況の説明が推奨されます。"
    },
    {
      "indent": 7,
      "text": "<scope xmlns=\"http://example.com/ns/scope/1.0\">\n    ... content per alternate namespace ...\n</scope>",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.3.5. The \"description\" Element",
      "section_title": true,
      "ja": "4.3.5.  「説明」の要素"
    },
    {
      "indent": 3,
      "text": "The \"description\" element is an OPTIONAL, free-form element that contains any additional relevant description that is useful for the user in its interpretation. Typically, this field contains authorship information, as well as additional context on how the LGR was formulated and how it applies, such as citations and references that apply to the LGR as a whole.",
      "ja": "「説明」の要素は、その解釈でユーザーのために有用な任意の追加の関連する記述が含まれているオプション、自由形式の要素です。通常、このフィールドはLGRが策定された方法に著者情報だけでなく、追加のコンテキストが含まれており、そのような全体としてLGRに適用されます引用や参照として、どのように適用されます。"
    },
    {
      "indent": 3,
      "text": "This field should not be relied upon for providing instructions on how to parse or utilize the data contained elsewhere in the specification. Authors of tables should expect that software applications that parse and use LGRs will not use the \"description\" element to condition the application of the LGR's data and rules.",
      "ja": "このフィールドは、明細書の他の箇所に含まれるデータを解析したり、活用する方法についての指示を提供するために依存すべきではありません。テーブルの作成者は、解析し、LGRのデータとルールの適用を調整するために、「説明」の要素を使用しませんLGRsを使用しているソフトウェアアプリケーションを期待するべきです。"
    },
    {
      "indent": 3,
      "text": "The element has an OPTIONAL \"type\" attribute, which refers to the Internet media type [RFC2045] of the enclosed data. Typical types would be \"text/plain\" or \"text/html\". The attribute SHOULD be a valid media type. If supplied, it will be assumed that the contents are of that media type. If the description lacks a \"type\" value, it will be assumed to be plain text (\"text/plain\").",
      "ja": "要素は、囲まれたデータのインターネットメディアタイプ[RFC2045]を指すOPTIONAL「type」属性を有しています。典型的なタイプは \"text / plain\" や \"text / html\" とすると、。属性は、有効なメディアタイプでなければなりません。指定した場合、内容がそのメディアタイプであることが想定されます。説明は「タイプ」値を欠いている場合、プレーンテキスト（「text / plainの」）であると仮定されます。"
    },
    {
      "indent": 0,
      "text": "4.3.6. The \"validity-start\" and \"validity-end\" Elements",
      "section_title": true,
      "ja": "4.3.6.  「有効性・スタート」と「有効性エンド」の要素"
    },
    {
      "indent": 3,
      "text": "The \"validity-start\" and \"validity-end\" elements are OPTIONAL elements that describe the time period from which the contents of the LGR become valid (are used in registry policy) and time when the contents of the LGR cease to be used, respectively.",
      "ja": "「有効性・スタート」と「有効性エンド」の要素は、LGRの内容はLGRの中止の内容は、使用する有効な（レジストリポリシーで使用されている）と、時間になったから、期間を記述するオプションの要素ですそれぞれ。"
    },
    {
      "indent": 3,
      "text": "The dates MUST conform to the \"full-date\" format described in Section 5.6 of [RFC3339].",
      "ja": "日付は、[RFC3339]のセクション5.6に記載された「完全な日付」形式に従わなければなりません。"
    },
    {
      "indent": 7,
      "text": "<validity-start>2014-03-12</validity-start>",
      "ja": "<有効期間開始> 2014年3月12日</妥当性、スタート>"
    },
    {
      "indent": 0,
      "text": "4.3.7. The \"unicode-version\" Element",
      "section_title": true,
      "ja": "4.3.7.  「ユニコード・バージョン」の要素"
    },
    {
      "indent": 3,
      "text": "Whenever an LGR depends on character properties from a given version of the Unicode Standard, the version number used in creating the LGR MUST be listed in the form x.y.z, where x, y, and z are positive decimal integers (see [Unicode-Versions]). If any software processing the table does not have access to character property data of the requisite version, it MUST NOT perform any operations relating to whole-label evaluation relying on Unicode character properties (Section 6.2.3).",
      "ja": "LGRは、Unicode標準の所与のバージョンから文字特性に依存するたびに、LGRを作成する際に使用されるバージョン番号は、x、y、zは正の10進整数である形式のXYZ、（[ユニコードバージョン]を参照にリストされなければなりません）。テーブルを処理するソフトウェアが必要なバージョンの文字属性データへのアクセスを持っていない場合は、Unicode文字プロパティ（6.2.3項）に頼る全体ラベルの評価に関連するすべての操作を実行してはなりません。"
    },
    {
      "indent": 3,
      "text": "The value of a given Unicode character property may change between versions of the Unicode Character Database [UAX44], unless such change has been explicitly disallowed in [Unicode-Stability]. It is RECOMMENDED to only reference properties defined as stable or immutable. As an alternative to referencing the property, the information can be presented explicitly in the LGR.",
      "ja": "このような変化は、明示的[ユニコード安定]で許可されていない限り、指定されたUnicode文字プロパティの値は、Unicode文字データベースのバージョン間[UAX44]を変更してもよいです。これは、安定または不変として定義のみ参照プロパティすることが推奨されます。プロパティを参照する代わりに、情報がLGRで明示的に提示することができます。"
    },
    {
      "indent": 7,
      "text": "<unicode-version>6.3.0</unicode-version>",
      "ja": "<ユニコード・バージョン> 6.3.0 </ユニコード・バージョン>"
    },
    {
      "indent": 3,
      "text": "It is not necessary to include a \"unicode-version\" element for LGRs that do not make use of Unicode character properties; however, it is RECOMMENDED.",
      "ja": "Unicode文字プロパティを使用しないLGRsのための「ユニコード・バージョン」の要素を含める必要はありません。しかし、それが推奨されます。"
    },
    {
      "indent": 0,
      "text": "4.3.8. The \"references\" Element",
      "section_title": true,
      "ja": "4.3.8.  「参照」要素"
    },
    {
      "indent": 3,
      "text": "An LGR may define a list of references that are used to associate various individual elements in the LGR to one or more normative references. A common use for references is to annotate that code points belong to an externally defined collection or standard or to give normative references for rules.",
      "ja": "LGRは、一つ以上の引用規格にLGRにおける様々な個々の要素を関連付けるために使用されている参考文献のリストを定義することができます。参照のための一般的な用途は、外部で定義されたコレクションまたは標準にポイントが属しているコードに注釈を付けるか、ルールの引用規格を与えることです。"
    },
    {
      "indent": 3,
      "text": "References are specified in an OPTIONAL \"references\" element containing one or more \"reference\" elements, each with a unique \"id\" attribute. It is RECOMMENDED that the \"id\" attribute be a zero-based integer; however, in addition to digits 0-9, it MAY contain uppercase letters A-Z, as well as a period, hyphen, colon, or underscore. The value of each \"reference\" element SHOULD be the citation of a standard, dictionary, or other specification in any suitable format. In addition to an \"id\" attribute, a \"reference\" element MAY have a \"comment\" attribute for an optional free-form annotation.",
      "ja": "参照は、1つまたは複数の「参照」要素、ユニークな「id」属性と、それぞれを含むオプション「参照」要素で指定されています。 「id」属性は、ゼロベースの整数ことが推奨されます。しかし、0-9桁の数字に加えて、それが大文字-Z、ならびに期間、ハイフン、コロン、または下線を含むかもしれません。各「基準」要素の値は、任意の適切な形式で標準、辞書、または他の仕様の引用であるべきです。 「id」属性に加えて、「参照」要素は、オプションの自由形式の注釈のための「コメント」属性を持っているかもしれません。"
    },
    {
      "indent": 7,
      "text": "<references>\n  <reference id=\"0\">The Unicode Consortium.  The Unicode\n    Standard, Version 8.0.0, (Mountain View, CA: The Unicode\n    Consortium, 2015.  ISBN 978-1-936213-10-8)\n    http://www.unicode.org/versions/Unicode8.0.0/</reference>\n  <reference id=\"1\">Big-5: Computer Chinese Glyph and Character\n     Code Mapping Table, Technical Report C-26, 1984</reference>\n  <reference id=\"2\" comment=\"synchronized with Unicode 6.1\">\n     ISO/IEC\n     10646:2012 3rd edition</reference>\n  ...\n</references>\n...\n<data>\n  <char cp=\"0620\" ref=\"0 2\" />\n  ...\n</data>",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A reference is associated with an element by using its id as part of an optional \"ref\" attribute (see Section 5.4.1). The \"ref\" attribute may be used with many kinds of elements in the \"data\" or \"rules\" sections of the LGR, most notably those defining code points, variants, and rules. However, a \"ref\" attribute may not occur in certain kinds of elements, including references to named character classes or rules. See below for the description of these elements.",
      "ja": "参照は、任意の「REF」属性（セクション5.4.1を参照）の一部として、そのIDを使用して、要素に関連付けられています。 「REF」属性は、「データ」またはLGRの「ルール」セクション内の要素の多くの種類、最も顕著それら定義するコードポイント、変異体、およびルールを使用してもよいです。しかし、「参照」属性は、名前の文字クラスやルールへの参照を含む要素の特定の種類、で発生しないことがあります。これらの要素の説明については以下を参照してください。"
    },
    {
      "indent": 0,
      "text": "5. Code Points and Variants",
      "section_title": true,
      "ja": "5.コードポイントとバリアント"
    },
    {
      "indent": 3,
      "text": "The bulk of an LGR is a description of which set of code points is eligible for a given label. For rulesets that perform operations that result in potential variants, the code point-level relationships between variants need to also be described.",
      "ja": "LGRの大部分は、コード・ポイントのセットが与えられたラベルの対象となっている記述です。潜在的な変異体をもたらす動作を行うルールセットのために、変異体の間のコードポイントレベルの関係も説明する必要があります。"
    },
    {
      "indent": 3,
      "text": "The code point data is collected within the \"data\" element. Within this element, a series of \"char\" and \"range\" elements describe eligible code points or ranges of code points, respectively. Collectively, these are known as the repertoire.",
      "ja": "コードポイントデータは「データ」エレメント内に収集されます。この要素内に、「チャー」と「範囲」要素のシリーズは、それぞれ、対象コードポイントまたはコードポイントの範囲を記載しています。総称して、これらをレパートリーとして知られています。"
    },
    {
      "indent": 3,
      "text": "Discrete permissible code points or code point sequences (see Section 5.1) are declared with a \"char\" element. Here is a minimal example declaration for a single code point, with the code point value given in the \"cp\" attribute:",
      "ja": "離散許容コードポイントまたはコードポイント配列は（セクション5.1を参照）、「チャー」要素で宣言されています。ここで、「CP」属性に指定されたコードポイント値を有する単一のコードポイントの最小の例の宣言は、次のとおりです。"
    },
    {
      "indent": 7,
      "text": "<char cp=\"002D\"/>",
      "ja": "<チャーCP = \"002D\" />"
    },
    {
      "indent": 3,
      "text": "As described below, a full declaration for a \"char\" element, whether or not it is used for a single code point or for a sequence (see Section 5.1), may have optional child elements defining variants. Both the \"char\" and \"range\" elements can take a number of optional attributes for conditional inclusion, commenting, cross-referencing, and character tagging, as described below.",
      "ja": "以下に説明するように、「チャー」要素の完全な宣言は、それが単一のコードポイントまたはシーケンスのために使用されているか否か、（セクション5.1を参照）の変異体を定義するオプションの子要素を有していてもよいです。以下に説明するように、「チャー」と「範囲」の両方の要素は、相互参照、および文字タグをコメント、条件付き含めるためのオプションの属性の数を取ることができます。"
    },
    {
      "indent": 3,
      "text": "Ranges of permissible code points may be declared with a \"range\" element, as in this minimal example:",
      "ja": "許容コードポイントの範囲は、この最小の例のように、「範囲」要素で宣言されてもよいです。"
    },
    {
      "indent": 7,
      "text": "<range first-cp=\"0030\" last-cp=\"0039\"/>",
      "ja": "<範囲第-CP = \"0030\" 最後-CP = \"0039\" />"
    },
    {
      "indent": 3,
      "text": "The range is inclusive of the first and last code points. Any additional attributes defined for a \"range\" element act as if applied to each code point within. A \"range\" element has no child elements.",
      "ja": "範囲は、最初と最後のコードポイントを含むあります。内の各コードポイントに適用されるかのように「範囲」要素の行為のために定義された任意の追加属性。 「範囲」要素は、子要素はありません。"
    },
    {
      "indent": 3,
      "text": "It is always possible to substitute a list of individually specified code points for a \"range\" element. The reverse is not necessarily the case. Whenever such a substitution is possible, it makes no difference in processing the data. Tools reading or writing the LGR format are free to aggregate sequences of consecutive code points of the same properties into \"range\" elements.",
      "ja": "「範囲」要素ごとに個別に指定されたコードポイントのリストを代用することは常に可能です。逆は必ずしもそうではありません。このような置換が可能であるときはいつでも、それはデータの処理に違いはありません。読み取りまたはLGRフォーマットを書き込みツールは、「範囲」要素に同じ特性の連続的なコードポイントの集合体配列に含みません。"
    },
    {
      "indent": 3,
      "text": "Code points MUST be represented according to the standard Unicode convention but without the prefix \"U+\": they are expressed in uppercase hexadecimal and are zero-padded to a minimum of 4 digits.",
      "ja": "コードポイントは、標準的なユニコード規則に従って表されるが、接頭辞「U +」なしでなければならない：それらは大文字進数で表現し、4桁の最小値にゼロパディングされています。"
    },
    {
      "indent": 3,
      "text": "The rationale for not allowing other encoding formats, including native Unicode encoding in XML, is explored in [UAX42]. The XML conventions used in this format, such as element and attribute names, mirror this document where practical and reasonable to do so. It is RECOMMENDED to list all \"char\" elements in ascending order of the \"cp\" attribute. Not doing so makes it unnecessarily difficult for authors and reviewers to check for errors, such as duplications, or to review and compare against listing of code points in other documents and specifications.",
      "ja": "XMLにおけるネイティブUnicodeエンコーディングを含む他の符号化フォーマットを許可しないための理論的根拠は、[UAX42]で検討されています。 XMLのような要素として、この形式で使用されている表記規則、および属性名、ミラー本書そうすることが実用的かつ合理的。 「CP」属性の昇順ですべての「文字」の要素をリストアップすることをお勧めします。著者と査読は、重複などのエラー、チェックするために、または検討し、他の文書や仕様のコードポイントのリストと比較するために行っていないので、それが不必要に難しくなります。"
    },
    {
      "indent": 3,
      "text": "All \"char\" elements in the \"data\" section MUST have distinct \"cp\" attributes. The \"range\" elements MUST NOT specify code point ranges that overlap either another range or any single code point \"char\" elements. An LGR that defines the same code point more than once by any combination of \"char\" or \"range\" elements MUST be rejected.",
      "ja": "「データ」セクションのすべての「CHAR」の要素が明確な「CP」は属性を持たなければなりません。 「範囲」要素は、他の範囲または任意の単一のコードポイント「チャー」要素のいずれかと重なるコードポイント範囲を指定してはなりません。 「チャー」または「範囲」の要素の任意の組み合わせによって複数回同じコードポイントを定義LGRは拒絶されなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.1. Sequences",
      "section_title": true,
      "ja": "5.1. シーケンス"
    },
    {
      "indent": 3,
      "text": "A sequence of two or more code points may be specified in an LGR -- for example, when defining the source for n:m variant mappings. Another use of sequences would be in cases when the exact sequence of code points is required to occur in order for the constituent elements to be eligible, such as when some code point is only eligible when preceded or followed by a certain code point. The following would define the eligibility of the MIDDLE DOT (U+00B7) only when both preceded and followed by the LATIN SMALL LETTER L (U+006C):",
      "ja": "二つ以上のコードポイントのシーケンスがLGRで指定されてもよい - 例えば、n個のソースを定義する：Mバリアントマッピング。コード・ポイントの正確な配列は、構成要素は、特定のコードポイントに先行又は続く場合、いくつかのコードポイントのみが対象である場合のように、適格であるために発生する必要がある場合の配列の別の使用は、ケースであろう。以下は、両方の前とSMALLラテン文字L（U + 006C）、続いてのみMIDDLE DOT（U + 00B7）の適格性を定義します。"
    },
    {
      "indent": 7,
      "text": "<char cp=\"006C 00B7 006C\" comment=\"Catalan middle dot\"/>",
      "ja": "<文字CPは= \"006C 00B7 006C\" コメント= \"カタロニア語中ドット\" />"
    },
    {
      "indent": 3,
      "text": "All sequences defined this way must be distinct, but sub-sequences may be defined. Thus, the sequence defined here may coexist with single code point definitions such as:",
      "ja": "このように定義されたすべての配列は別個でなければならないが、サブシーケンスを定義することができます。したがって、ここで定義された配列のような単一のコードポイントの定義と共存できます。"
    },
    {
      "indent": 7,
      "text": "<char cp=\"006C\" />",
      "ja": "<チャーCP = \"006C\" />"
    },
    {
      "indent": 3,
      "text": "As an alternative to using sequences to define a required context, a \"char\" or \"range\" element may specify a conditional context using an optional \"when\" attribute as described below in Section 5.2. Using a conditional context is more flexible because a context is not limited to a specific sequence of code points. In addition, using a context allows the choice of specifying either a prohibited or a required context.",
      "ja": "第5.2節で以下に説明するように「いつ」属性に必要なコンテキストを定義するために配列を使用する代わりに、「チャー」または「範囲」要素は、オプションを使用して条件付きのコンテキストを指定することができます。コンテキストがコードポイントの特定の配列に限定されるものではないので、条件付きコンテキストを使用して、より柔軟です。また、コンテキストを使用して、禁止または必要なコンテキストのいずれかの指定を選択することができます。"
    },
    {
      "indent": 0,
      "text": "5.2. Conditional Contexts",
      "section_title": true,
      "ja": "5.2. 条件付きコンテキスト"
    },
    {
      "indent": 3,
      "text": "A conditional context is specified by a rule that must be satisfied (or, alternatively, must not be satisfied) for a code point in a given label, often at a particular location in a label.",
      "ja": "条件付きのコンテキストは、しばしば、ラベルの特定の位置で、所定のラベルのコードポイントのために（または、代替的に、満足されてはならない）を満足しなければならないルールで指定されています。"
    },
    {
      "indent": 3,
      "text": "To specify a conditional context, either a \"when\" or \"not-when\" attribute may be used. The value of each \"when\" or \"not-when\" attribute is a context rule as described below in Section 6.3. This rule can be a rule evaluating the whole label or a parameterized context rule. The context condition is met when the rule specified in the \"when\" attribute is matched or when the rule in the \"not-when\" attribute fails to match. It is an error to reference a rule that is not actually defined in the \"rules\" element.",
      "ja": "、条件付きのコンテキストを指定するにはいずれかの「とき」または「-ないときは、」属性を使用することができます。 6.3節で以下に説明するように、それぞれ「a」又は「未とき」属性の値は、コンテキスト・ルールです。この規則は、ラベル全体またはパラメータコンテキストルールを評価ルールすることができます。ルールは属性が一致したとき、または「ない-」属性が一致しないで、ルールは「とき」に指定されたときに、コンテキスト条件が満たされています。実際に、「ルール」の要素で定義されていないルールを参照するエラーです。"
    },
    {
      "indent": 3,
      "text": "A parameterized context rule (see Section 6.4) defines the context immediately surrounding a given code point; unlike a sequence, the context is not limited to a specific fixed code point but, for example, may designate any member of a certain character class or a code point that has a certain Unicode character property.",
      "ja": "パラメータ化されたコンテキスト・ルール（セクション6.4を参照）を直ちに所定のコードポイントを取り巻くコンテキストを定義します。配列とは異なり、コンテキストは、特定の固定されたコードポイントに限定されるものではなく、例えば、特定の文字クラスの任意のメンバーまたは特定のUnicode文字プロパティを持つコードポイントを指定することができます。"
    },
    {
      "indent": 3,
      "text": "Given a suitable definition of a parameterized context rule named \"follows-virama\", this example specifies that a ZERO WIDTH JOINER (U+200D) is restricted to immediately follow any of several code points classified as virama:",
      "ja": "「-ヴィラーマを次の」という名前のパラメータ化コンテキストルールを適切に定義を考えると、この例では、ZERO WIDTH JOINER（U + 200D）は、直ちにヴィラーマとして分類いくつかのコードポイントのいずれかに従うことを制限されていることを指定します。"
    },
    {
      "indent": 7,
      "text": "<char cp=\"200D\" when=\"follows-virama\" />",
      "ja": "<チャーCP = \"200D\" = \"は、以下-ヴィラーマ\" />"
    },
    {
      "indent": 3,
      "text": "For a complete example, see Appendix A.",
      "ja": "完全な例については、付録Aを参照してください。"
    },
    {
      "indent": 3,
      "text": "In contrast, a whole label rule (see Section 6.3) specifies a condition to be met by the entire label -- for example, that it must contain at least one code point from a given script anywhere in the label. In the following example, no digit from either range may occur in a label that mixes digits from both ranges:",
      "ja": "対照的に、全体のラベルルール（セクション6.3を参照）をラベル全体が満たすべき条件を指定する - 例えば、それはどこでもラベルで指定されたスクリプトから少なくとも1つのコードポイントを含んでいなければならないこと。次の例では、いずれかの範囲からの桁は両方の範囲から数字を混合ラベルで発生しなくてもよいです。"
    },
    {
      "indent": 7,
      "text": "<data>\n   <range first-cp=\"0660\" last-cp=\"0669\" not-when=\"mixed-digits\"\n          tag=\"arabic-indic-digits\" />\n   <range first-cp=\"06F0\" last-cp=\"06F9\" not-when=\"mixed-digits\"\n          tag=\"extended-arabic-indic-digits\" />\n</data>",
      "raw": true
    },
    {
      "indent": 3,
      "text": "(See Section 6.3.9 for an example of the \"mixed-digits\" rule.)",
      "ja": "（「混合桁」ルールの例については、セクション6.3.9を参照）。"
    },
    {
      "indent": 3,
      "text": "The OPTIONAL \"when\" or \"not-when\" attributes are mutually exclusive. They MAY be applied to both \"char\" and \"range\" elements in the \"data\" element, including \"char\" elements defining sequences of code points, as well as to \"var\" elements (see Section 5.3.5).",
      "ja": "オプションは、「いつ」か「ない - とき」属性は相互に排他的です。彼らは、「チャー」とコードポイントのシーケンスを定義する「チャー」要素を含む「データ」要素の「範囲」の要素、の両方に、ならびに「VAR」要素（セクション5.3.5を参照）にも適用することができます。"
    },
    {
      "indent": 3,
      "text": "If a label contains one or more code points that fail to satisfy a conditional context, the label is invalid (see Section 7.5). For variants, the conditional context restricts the definition of the variant to the case where the condition is met. Outside the specified context, a variant is not defined.",
      "ja": "ラベル条件コンテキストを満たさない1つ以上のコードポイントが含まれている場合、ラベルは（セクション7.5を参照）は無効です。変異体のために、条件付きのコンテキストは、条件が満たされた場合にバリアントの定義を制限します。指定されたコンテキスト外では、バリアントが定義されていません。"
    },
    {
      "indent": 0,
      "text": "5.3. Variants",
      "section_title": true,
      "ja": "5.3. バリアント"
    },
    {
      "indent": 3,
      "text": "Most LGRs typically only determine simple code point eligibility, and for them, the elements described so far would be the only ones required for their \"data\" section. Others additionally specify a mapping of code points to other code points, known as \"variants\". What constitutes a variant code point is a matter of policy and varies for each implementation. The following examples are intended to demonstrate the syntax; they are not necessarily typical.",
      "ja": "ほとんどのLGRsは通常、単純なコードポイントの適格性を決定し、彼らのために、これまでに説明した要素は、彼らの「データ」セクションに必要なものだけになります。その他は、さらに、「変異体」として知られている他のコードポイントにコードポイントのマッピングを指定します。何バリアントコード・ポイントを構成することは政策の問題であり、各実装によって異なります。次の例では、構文を実証することを意図しています。彼らは必ずしも一般的ではないです。"
    },
    {
      "indent": 0,
      "text": "5.3.1. Basic Variants",
      "section_title": true,
      "ja": "5.3.1. ベーシックバリアント"
    },
    {
      "indent": 3,
      "text": "Variant code points are specified using one of more \"var\" elements as children of a \"char\" element. The target mapping is specified using the \"cp\" attribute. Other, optional attributes for the \"var\" element are described below.",
      "ja": "変異体のコードポイントは「チャー」要素の子としての複数の「VAR」要素のいずれかを使用して指定されます。ターゲット・マッピングは、「CP」属性を使用して指定されます。 「VAR」要素の他、オプションの属性は、以下に記載されています。"
    },
    {
      "indent": 3,
      "text": "For example, to map LATIN SMALL LETTER V (U+0076) as a variant of LATIN SMALL LETTER U (U+0075):",
      "ja": "例えば、ラテン小文字U（U + 0075）の変形例としてラテン小文字V（U + 0076）をマッピングします。"
    },
    {
      "indent": 7,
      "text": "<char cp=\"0075\">\n    <var cp=\"0076\"/>\n</char>",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A sequence of multiple code points can be specified as a variant of a single code point. For example, the sequence of LATIN SMALL LETTER O (U+006F) then LATIN SMALL LETTER E (U+0065) might hypothetically be specified as a variant for a LATIN SMALL LETTER O WITH DIAERESIS (U+00F6) as follows:",
      "ja": "複数のコード・ポイントのシーケンスは、単一のコードポイントの変異体として指定することができます。例えば以下のように、ラテン小文字O（U + 006F）の配列次いでラテン小文字E（U + 0065）仮定分音符号（U + 00F6）付きラテン小文字Oのバリアントとして指定されるかもしれません。"
    },
    {
      "indent": 7,
      "text": "<char cp=\"00F6\">\n    <var cp=\"006F 0065\"/>\n</char>",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The source and target of a variant mapping may both be sequences but not ranges.",
      "ja": "変異マッピングのソースとターゲットが両方の配列ではなく、範囲であってもよいです。"
    },
    {
      "indent": 3,
      "text": "If the source of one mapping is a prefix sequence of the source for another, both variant mappings will be considered at the same location in the input label when generating permuted variant labels. If poorly designed, an LGR containing such an instance of a prefix relation could generate multiple instances of the same variant label for the same original label, but with potentially different dispositions. Any duplicate variant labels encountered MUST be treated as an error (see Section 8.4).",
      "ja": "1つのマッピングのソースは、別のソースのプレフィックスシーケンスである場合、順列変異体のラベルを生成するときに、両方の変異のマッピングは、入力ラベルに同じ位置で考慮されます。設計が不十分な場合は、接頭辞関係のようなインスタンスを含むLGRは、同じ元のラベルの同じ変異ラベルの複数のインスタンスを生成するが、潜在的に異なる処分を有する可能性があります。遭遇重複変異型ラベルはエラーとして扱わなければならない（8.4節を参照してください）。"
    },
    {
      "indent": 3,
      "text": "The \"var\" element specifies variant mappings in only one direction, even though the variant relation is usually considered symmetric; that is, if A is a variant of B, then B should also be a variant of A. The format requires that the inverse of the variant be given explicitly to fully specify symmetric variant relations in the LGR. This has the beneficial side effect of making the symmetry explicit:",
      "ja": "「VAR」の要素は、変異体の関係は、通常は対称と考えられているにもかかわらず、一方向にのみ変異型のマッピングを指定します。すなわち、AはBの変異体である場合、Bはまた、フォーマットは変異体の逆数が完全LGR対称バリアント関係を指定する明示的に指定されることを必要Aの変異体であるべきです。これは、対称性が明示的にすることの有益な副作用があります。"
    },
    {
      "indent": 7,
      "text": "<char cp=\"006F 0065\">\n    <var cp=\"00F6\"/>\n</char>",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Variant relations are normally not only symmetric but also transitive. If A is a variant of B and B is a variant of C, then A is also a variant of C. As with symmetry, these transitive relations are only part of the LGR if spelled out explicitly. Implementations that require an LGR to be symmetric and transitive should verify this mechanically.",
      "ja": "バリアントの関係は、通常、対称だけでなく、推移的ではありません。 AはBの変異体であり、BはCの変異体である場合、Aはまた、対称性と同様にCの変異体であり、これらの推移の関係を明示的に綴られている場合LGRの一部のみです。対称と推移するLGRが必要な実装は、機械的にこれを確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "All variant mappings are unique. For a given \"char\" element, all \"var\" elements MUST have a unique combination of \"cp\", \"when\", and \"not-when\" attributes. It is RECOMMENDED to list the \"var\" elements in ascending order of their target code point sequence. (For \"when\" and \"not-when\" attributes, see Section 5.3.5.)",
      "ja": "すべてのバリアントのマッピングは一意です。与えられた「文字」要素については、すべて「VAR」の要素は、「CP」、「」のユニークな組み合わせを持たなければならない、と「ではない - とき」の属性。彼らのターゲット・コード・ポイント列の昇順に「VAR」の要素をリストアップすることをお勧めします。 （セクション5.3.5を参照してください、「いつ」と「ない - とき」属性の場合。）"
    },
    {
      "indent": 0,
      "text": "5.3.2. The \"type\" Attribute",
      "section_title": true,
      "ja": "5.3.2.  「タイプ」属性"
    },
    {
      "indent": 3,
      "text": "Variants may be tagged with an OPTIONAL \"type\" attribute. The value of the \"type\" attribute may be any non-empty value not starting with an underscore and not containing spaces. This value is used to resolve the disposition of any variant labels created using a given variant. (See Section 7.2.)",
      "ja": "バリアントは、オプションの「タイプ」属性でタグ付けすることができます。 「タイプ」属性の値が空でない値を下線で始まらない、スペースを含まないとすることができます。この値は、指定されたバリアントを使用して作成した任意の変形のラベルの配置を解決するために使用されます。 （7.2節を参照してください。）"
    },
    {
      "indent": 3,
      "text": "By default, the values of the \"type\" attribute directly describe the target policy status (disposition) for a variant label that was generated using a particular variant, with any variant label being assigned a disposition corresponding to the most restrictive variant type. Several conventional disposition values are predefined below in Section 7. Whenever these values can represent the desired policy, they SHOULD be used.",
      "ja": "デフォルトでは、「タイプ」属性の値は、直接任意の変異体ラベルは最も制限バリアント型に対応する配置を割り当てられると、特定の変異体を使用して生成された変異体ラベルのターゲットポリシー状態（配置）を記述する。これらの値は、それらが使用されるべき、所望のポリシーを表すことができるたびに、いくつかの従来の配置値はセクション7で以下に事前に定義されています。"
    },
    {
      "indent": 7,
      "text": "<char cp=\"767C\">\n    <var cp=\"53D1\" type=\"allocatable\"/>\n    <var cp=\"5F42\" type=\"blocked\"/>\n    <var cp=\"9AEA\" type=\"blocked\"/>\n    <var cp=\"9AEE\" type=\"blocked\"/>\n</char>",
      "raw": true
    },
    {
      "indent": 3,
      "text": "By default, if a variant label contains any instance of one of the variants of type \"blocked\", the label would be blocked, but if it contained only instances of variants to be allocated, it could be allocated. See the discussion about implied actions in Section 7.6.",
      "ja": "デフォルトでは、バリアントのラベルは「ブロック」タイプの変異体の1の任意のインスタンスが含まれている場合、ラベルはブロックされるが、それは割り当てられる変異型のインスタンスのみが含まれている場合、それは割り当てることができます。 7.6節で暗黙のアクションに関する説明を参照してください。"
    },
    {
      "indent": 3,
      "text": "The XML format for the LGR makes the relation between the values of the \"type\" attribute on variants and the resulting disposition of variant labels fully explicit. See the discussion in Section 7.2. Making this relation explicit allows a generalization of the \"type\" attribute from directly reflecting dispositions to a more differentiated intermediate value that is then used in the resolution of label disposition. Instead of the default action of applying the most restrictive disposition to the entire label, such a generalized resolution can be used to achieve additional goals, such as limiting the set of allocatable variant labels or implementing other policies found in existing LGRs (see, for example, Appendix B).",
      "ja": "LGRのためのXMLフォーマットは、バリアントの「タイプ」属性の値と完全に明示的なバリアントラベルの結果として処分との関係を作ります。 7.2節での議論を参照してください。この関係は、明示的な製造は、ラベルの配置の解像度で使用されるより分化の中間値に直接反映処分から「タイプ」属性の一般化を可能にします。代わりに、ラベル全体に最も制限処分を適用するデフォルトのアクションでは、そのような一般化解像度は、例えば、割り当て可能なバリアントラベルのセットを制限するか、参照して、既存のLGRs（で見つかった他の政策の実施などの追加の目標を達成するために使用することができます付録B）。"
    },
    {
      "indent": 3,
      "text": "Because variant mappings MUST be unique, it is not possible to define the same variant for the same \"char\" element with different \"type\" attributes (however, see Section 5.3.5).",
      "ja": "バリアントのマッピングは一意でなければならないため、それは別の「タイプ」属性と同じに「char」要素のために同じバリアントを定義することはできません（ただし、セクション5.3.5を参照してください）。"
    },
    {
      "indent": 0,
      "text": "5.3.3. Null Variants",
      "section_title": true,
      "ja": "5.3.3. ヌル変異"
    },
    {
      "indent": 3,
      "text": "A null variant is a variant string that maps to no code point. This is used when a particular code point sequence is considered discretionary in the context of a whole label. To specify a null variant, use an empty \"cp\" attribute. For example, to mark a string with a ZERO WIDTH NON-JOINER (U+200C) to the same string without the ZERO WIDTH NON-JOINER:",
      "ja": "ヌルバリアントはありませんコードポイントにマップバリアント文字列です。特定のコードポイントシーケンスはラベル全体の文脈において裁量であると考えられる場合に使用されます。ヌルバリアントを指定するには、空の「CP」属性を使用します。例えば、ZERO WIDTH NON-JOINERない同じ列にZERO WIDTH NON-JOINER（U + 200C）を用いて文字列をマークします。"
    },
    {
      "indent": 7,
      "text": "<char cp=\"200C\">\n    <var cp=\"\"/>\n</char>",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This is useful in expressing the intent that some code points in a label are to be mapped away when generating a canonical variant of the label. However, in tables that are designed to have symmetric variant mappings, this could lead to combinatorial explosion if not handled carefully.",
      "ja": "これは、ラベルの一部のコードポイントは、ラベルの標準バリアントを生成する際に離れてマッピングされることを意図を発現するのに有用です。慎重に取り扱っていない場合は、対称バリアントのマッピングを持つように設計されているテーブルに、これは、組み合わせ爆発につながる可能性があります。"
    },
    {
      "indent": 3,
      "text": "The symmetric form of a null variant is expressed as follows:",
      "ja": "次のようにヌル変異体の対称形に表されます。"
    },
    {
      "indent": 7,
      "text": "<char cp=\"\">\n    <var cp=\"200C\" type=\"invalid\" />\n</char>",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A \"char\" element with an empty \"cp\" attribute MUST specify at least one variant mapping. It is strongly RECOMMENDED to use a type of \"invalid\" or equivalent when defining variant mappings from null sequences, so that variant mappings from null sequences are removed in variant label generation (see Section 5.3.2).",
      "ja": "空の「CP」属性と「CHAR」要素は、少なくとも一つの変形マッピングを指定しなければなりません。ヌルシーケンスからバリアントマッピングはバリアントラベル生成に削除されるように、強く（5.3.2項を参照）、ヌル配列からバリアントマッピングを定義するときに「無効」または同等のタイプを使用することをお勧めします。"
    },
    {
      "indent": 0,
      "text": "5.3.4. Variants with Reflexive Mapping",
      "section_title": true,
      "ja": "5.3.4. 再帰マッピングとバリアント"
    },
    {
      "indent": 3,
      "text": "At first glance, there seems to be no call for adding variant mappings for which source and target code points are the same -- that is, for which the mapping is reflexive, or, in other words, an identity mapping. Yet, such reflexive mappings occur frequently in LGRs that follow [RFC3743].",
      "ja": "一見すると、そのソースの変異のマッピングを追加するためのないコールすることなく、コードポイントを標的とするように思わ同じである - すなわち、マッピングが反射的、又は、換言すれば、IDマッピングされている、です。しかし、そのような再帰マッピングは、[RFC3743]を辿るLGRsで頻繁に発生します。"
    },
    {
      "indent": 3,
      "text": "Adding a \"var\" element allows both a type and a reference id to be specified for it. While the reference id is not used in processing, the type of the variant can be used to trigger actions. In permuting the label to generate all possible variants, the type associated with a reflexive variant mapping is applied to any of the permuted labels containing the original code point.",
      "ja": "「VAR」要素を追加するタイプと基準IDの両方がそれを指定することを可能にします。参照IDを処理に使用されていないが、変異の種類は、アクションをトリガするために使用することができます。全ての可能な変異体を生成するために、ラベルを置換では、再帰変異マッピングに関連付けられているタイプは、元のコードポイントを含む置換ラベルのいずれにも適用されます。"
    },
    {
      "indent": 3,
      "text": "In the following example, let's assume that the goal is to allocate only those labels that contain a variant that is considered \"preferred\" in some way. As defined in the example, the code point U+3473 exists both as a variant of U+3447 and as a variant of itself (reflexive mapping). Assuming an original label of \"U+3473 U+3447\", the permuted variant \"U+3473 U+3473\" would consist of the reflexive variant of U+3473 followed by a variant of U+3447. Given the variant mappings as defined here, the types for both of the variant mappings used to generate that particular permutation would have the value \"preferred\":",
      "ja": "次の例では、の目標は、何らかの方法で「望ましい」と考えられている変種が含まれているもののみのラベルを割り当てることであると仮定しましょう。一例で定義されているように、コード・ポイントU + 3473は、U + 3447の変形例として、それ自体の変異体（再帰マッピング）の両方として存在します。 「U + 3473 U + 3447」、置換変異体の元のラベルを想定「U + 3473 U + 3473」+ 3447 Uの変形続くU + 3473の再帰的変異体から成るであろう。ここで定義されている変異型のマッピングを考えると、その特定の順列を生成するために使用される変異型マッピングの両方の型は値が「好ましい」だろう。"
    },
    {
      "indent": 7,
      "text": "<char cp=\"3447\" ref=\"0\">\n  <var cp=\"3473\" type=\"preferred\" ref=\"1 3\" />\n</char>\n<char cp=\"3473\" ref=\"0\">\n  <var cp=\"3447\" type=\"blocked\" ref=\"1 3\" />\n  <var cp=\"3473\" type=\"preferred\" ref=\"0\" />\n</char>",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Having established the variant types in this way, a set of actions could be defined that return a disposition of \"allocatable\" or \"activated\" for a label consisting exclusively of variants with type \"preferred\", for example. (For details on how to define actions based on variant types, see Section 7.2.1.)",
      "ja": "このようにバリアント型を確立した、アクションのセットは、例えば、「好ましい」タイプの変種で、もっぱらからなるラベルに「割り当て可能」または「活性化」の処分を返すように定義することができます。 （バリアント型に基づいてアクションを定義する方法の詳細については、7.2.1項を参照してください。）"
    },
    {
      "indent": 3,
      "text": "In general, using reflexive variant mappings in this manner makes it possible to calculate disposition values using a uniform approach for all labels, whether they consist of mapped variant code points, original code points, or a mixture of both. In particular, the dispositions for two otherwise identical labels may differ based on which variant mappings were executed in order to generate each of them. (For details on how to generate variants and evaluate dispositions, see Section 8.)",
      "ja": "一般に、このように反射的変異のマッピングを使用することにより、それらがマップされた変異体のコードポイントは、元のコードポイント、または両方の混合物からなるかどうか、すべてのラベルのための一様なアプローチを用いて、配置値を計算することができます。具体的には、2つの他の点では同一のラベルの処分は、マッピングは、それらの各々を生成するために実行された変異体に基づいて異なっていてもよいです。 （変異体を作製し、処分を評価する方法の詳細については、8章を参照してください）"
    },
    {
      "indent": 3,
      "text": "Another useful convention that uses reflexive variants is described below in Section 7.2.1.",
      "ja": "反射的バリアントを使用して別の有用な規則は、7.2.1項に説明されます。"
    },
    {
      "indent": 0,
      "text": "5.3.5. Conditional Variants",
      "section_title": true,
      "ja": "5.3.5. 条件付きバリアント"
    },
    {
      "indent": 3,
      "text": "Fundamentally, variants are mappings between two sequences of code points. However, in some instances, for a variant relationship to exist, some context external to the code point sequence must also be considered. For example, a positional context may determine whether two code point sequences are variants of each other.",
      "ja": "基本的に、変異体は、コード・ポイントの二つの配列間のマッピングです。しかし、いくつかの例では、存在する変異体の関係を、コードポイント配列の外部いくつかのコンテキストも考慮しなければなりません。例えば、位置コンテキストは、2つのコード・ポイントの配列が互いの変異体であるか否かを判断することができます。"
    },
    {
      "indent": 3,
      "text": "An example of that are Arabic code points, which can have different forms based on position, with some code points sharing forms, thus making them variants in the positions corresponding to those forms. Such positional context cannot be solely derived from the code point by itself, as the code point would be the same for the various forms.",
      "ja": "その一例は、従って、それらは、それらのフォームに対応する位置に変異体を作製する、フォームを共有するいくつかのコードポイントとの位置に基づいて異なる形態を有することができ、アラビア語コード・ポイントです。コード・ポイントは、様々な形態のために同じになるような位置コンテキストは単独で、それ自体でコードポイントから誘導することができません。"
    },
    {
      "indent": 3,
      "text": "As described in Section 5.2, an OPTIONAL \"when\" or \"not-when\" attribute may be given for any \"var\" element to specify required or prohibited contextual conditions under which the variant is defined.",
      "ja": "5.2節で説明したように、OPTIONAL「いつ」または「未とき」属性はバリアントが定義されているの下で要求又は禁止文脈条件を指定するための任意の「VAR」要素に対して与えられてもよいです。"
    },
    {
      "indent": 3,
      "text": "Assuming that the \"rules\" element contains suitably defined rules for \"arabic-isolated\" and \"arabic-final\", the following example shows how to mark ARABIC LETTER ALEF WITH WAVY HAMZA BELOW (U+0673) as a variant of ARABIC LETTER ALEF WITH HAMZA BELOW (U+0625), but only when it appears in its isolated or final forms:",
      "ja": "「ルール」要素は、「孤立アラビア」と「アラビア決勝」の適宜定義されたルールが含まれていることを仮定すると、次の例では、ARABIC LETTER ALEFの変形として以下WAVYハムザ（U + 0673）でARABIC LETTERのALEFをマークする方法を示してBELOWハムザ（U + 0625）で、それは、その単離された又は最終的な形で表示された場合にのみ。"
    },
    {
      "indent": 7,
      "text": "<char cp=\"0625\">\n    <var cp=\"0673\" when=\"arabic-isolated\"/>\n    <var cp=\"0673\" when=\"arabic-final\"/>\n</char>",
      "raw": true
    },
    {
      "indent": 3,
      "text": "While a \"var\" element MUST NOT contain multiple conditions (it is only allowed a single \"when\" or \"not-when\" attribute), multiple \"var\" elements using the same mapping MAY be specified with different \"when\" or \"not-when\" attributes. The combination of mapping and conditional context defines a unique variant.",
      "ja": "「VAR」の要素は、複数の条件を含めることはできませんしながら、「いつ」か「ない、同じマッピングを使用して、複数の「VAR」の要素が異なると指定することができます（単一の「とき」または「ない - とき」属性のみ許可されます） -when」属性。マッピングおよび条件コンテキストの組み合わせは、ユニークな変異体を定義します。"
    },
    {
      "indent": 3,
      "text": "For each variant label, care must be taken to ensure that at most one of the contextual conditions is met for variants with the same mapping; otherwise, duplicate variant labels would be created for the same input label. Any such duplicate variant labels MUST be treated as an error; see Section 8.4.",
      "ja": "各バリアントのラベルについては、注意が文脈条件の最大1つが同じマッピングを持つ変異体を満たしていることを保証するために注意する必要があります。それ以外の場合は、重複した変異型ラベルは、同じ入力ラベルのために作成されます。任意のこのような重複変異体ラベルはエラーとして扱われなければなりません。 8.4節を参照してください。"
    },
    {
      "indent": 3,
      "text": "Two contexts may be complementary, as in the following example, which shows ARABIC LETTER TEH MARBUTA (U+0629) as a variant of ARABIC LETTER HEH (U+0647), but with two different types.",
      "ja": "二つのコンテキストはARABIC LETTER HEH（U + 0647）の変形例として、2つの異なるタイプのARABIC LETTER TEH MARBUTA（U + 0629）を示しており、以下の例のように、相補的であってもよいです。"
    },
    {
      "indent": 7,
      "text": "<char cp=\"0647\" >\n  <var cp=\"0629\" not-when=\"arabic-final\" type=\"blocked\" />\n  <var cp=\"0629\" when=\"arabic-final\" type=\"allocatable\" />\n</char>",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The intent is that a label that uses U+0629 instead of U+0647 in a final position should be considered essentially the same label and, therefore, allocatable to the same entity, while the same substitution in a non-final position leads to labels that are different, but considered confusable, so that either one, but not both, should be delegatable.",
      "ja": "意図は、非最終位置に同じ置換がラベルにつながるながら最終位置にU + 0629の代わりにU + 0647を使用してラベルが、従って、同じエンティティに割り当て本質的に同じラベルとみなされなければならないということですそれは異なっているが、そのいずれか1ので、混同しやすいと考えられ、両方ではなく、委任可能でなければなりません。"
    },
    {
      "indent": 3,
      "text": "For symmetry, the reverse mappings must exist and must agree in their \"when\" or \"not-when\" attributes. However, symmetry does not apply to the other attributes. For example, these are potential reverse mappings for the above:",
      "ja": "対称性のために、逆のマッピングが存在している必要があり、その「とき」または「ない - とき」属性に同意する必要があります。しかし、対称性は、他の属性には適用されません。例えば、これらは、上記の潜在的な逆マッピングは、次のとおりです。"
    },
    {
      "indent": 7,
      "text": "<char cp=\"0629\" >\n  <var cp=\"0647\" not-when=\"arabic-final\" type=\"allocatable\" />\n  <var cp=\"0647\" when=\"arabic-final\" type=\"allocatable\" />\n</char>",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Here, both variants have the same \"type\" attribute. While it is tempting to recognize that, in this instance, the \"when\" and \"not-when\" attributes are complementary; therefore, between them they cover every single possible context, it is strongly RECOMMENDED to use the format shown in the example that makes the symmetry easily verifiable by parsers and tools. (The same applies to entries created for transitivity.)",
      "ja": "ここでは、両方の変異体は、同じ「タイプ」属性を持っています。それは、この例では、それを認識することは魅力的ですが、「いつ」と「ない - とき」属性が相補的です。そのため、それらの間、彼らはすべての単一の可能なコンテキストをカバー、強くパーサおよびツールで簡単に検証可能な対称性を作るの例に示すようなフォーマットを使用することをお勧めします。 （同じことは、推移のために作成されたエントリに適用されます。）"
    },
    {
      "indent": 3,
      "text": "Arabic is an example of a script for which such conditional variants have been implemented based on the joining contexts for Arabic code points. The mechanism defined here supports other forms of conditional variants that may be required by other scripts.",
      "ja": "アラビア語は、そのような条件付きの変異体は、アラビア語のコードポイントの参加状況に基づいて実装されているため、スクリプトの一例です。ここで定義されたメカニズムは、他のスクリプトが必要とする条件付きの変異体の他の形式をサポートしています。"
    },
    {
      "indent": 0,
      "text": "5.4. Annotations",
      "section_title": true,
      "ja": "5.4. 注釈"
    },
    {
      "indent": 3,
      "text": "Two attributes, the \"ref\" and \"comment\" attributes, can be used to annotate individual elements in the LGR. They are ignored in machine-processing of the LGR. The \"ref\" attribute is intended for formal annotations and the \"comment\" attribute for free-form annotations. The latter can be applied more widely.",
      "ja": "二つの属性、「REF」と「コメント」属性は、LGRの個々の要素に注釈を付けるために使用することができます。彼らはLGRの機械加工では無視されます。 「参照」属性は、正式な注釈と自由形式の注釈のための「コメント」属性を対象としています。後者は、より広く適用することができます。"
    },
    {
      "indent": 0,
      "text": "5.4.1. The \"ref\" Attribute",
      "section_title": true,
      "ja": "5.4.1.  「参照」属性"
    },
    {
      "indent": 3,
      "text": "Reference information MAY optionally be specified by a \"ref\" attribute consisting of a space-delimited sequence of reference identifiers (see Section 4.3.8).",
      "ja": "参照情報は、必要に応じて参照識別子のスペースで区切られた配列からなる「REF」属性（セクション4.3.8を参照）によって指定することができます。"
    },
    {
      "indent": 7,
      "text": "<char cp=\"5220\" ref=\"0\">\n    <var cp=\"5220\" ref=\"5\"/>\n    <var cp=\"522A\" ref=\"2 3\"/>\n</char>",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This facility is typically used to give source information for code points or variant relations. This information is ignored when machine-processing an LGR. If applied to a range, the \"ref\" attribute applies to every code point in the range. All reference identifiers MUST be from the set declared in the \"references\" element (see Section 4.3.8). It is an error to repeat a reference identifier in the same \"ref\" attribute. It is RECOMMENDED that identifiers be listed in ascending order.",
      "ja": "この機能は、典型的には、コード・ポイントまたは変異体関係のソース情報を提供するために使用されます。とき、機械加工LGRこの情報は無視されます。範囲に適用された場合は、「参照」属性は、範囲内のすべてのコードポイントに適用されます。すべての参照識別子は、「リファレンス」の要素（セクション4.3.8を参照）で宣言されたセットからでなければなりません。同じ「参照」属性で参照識別子を繰り返すエラーです。識別子は、昇順にリストされることが推奨されます。"
    },
    {
      "indent": 3,
      "text": "In addition to \"char\", \"range\", and \"var\" elements in the \"data\" section, a \"ref\" attribute may be present for a number of element types contained in the \"rules\" element as described below: actions and literals (\"char\" inside a rule), as well as for definitions of rules and classes, but not for references to named character classes or rules using the \"by-ref\" attribute defined below. (The use of the \"by-ref\" and \"ref\" attributes is mutually exclusive.) None of the elements in the metadata take a \"ref\" attribute; to provide additional information, use the \"description\" element instead.",
      "ja": "また、「文字」、「範囲」に、そして「データ」セクションの「VAR」要素、「REF」属性は、後述するように、「ルール」要素に含まれる要素の種類の数のために存在していてもよい：アクションとリテラル（ルール内の「CHAR」）、などのためのルールやクラスの定義ではなく、以下に定義する「バイ・参照」属性を使用して、指定された文字クラスやルールへの参照のために。 （「バイREF」の使用および「REF」は相互に排他的である属性。）メタデータの要素のいずれもが「REF」属性を取りません。追加情報を提供するために、代わりに「説明」の要素を使用しています。"
    },
    {
      "indent": 0,
      "text": "5.4.2. The \"comment\" Attribute",
      "section_title": true,
      "ja": "5.4.2.  「コメント」属性"
    },
    {
      "indent": 3,
      "text": "Any \"char\", \"range\", or \"variant\" element in the \"data\" section may contain an OPTIONAL \"comment\" attribute. The contents of a \"comment\" attribute are free-form plain text. Comments are ignored in machine processing of the table. \"comment\" attributes MAY also be placed on all elements in the \"rules\" section of the document, such as actions and match operators, as well as definitions of classes and rules, but not on child elements of the \"class\" element. Finally, in the metadata, only the \"version\" and \"reference\" elements MAY have \"comment\" attributes (to match the syntax in [RFC3743]).",
      "ja": "「データ」のいずれかの「CHAR」、「範囲」、または「変異体」要素はオプション「コメント」属性が含まれていてもよいです。 「コメント」属性の内容は自由形式のプレーンテキストです。コメントは、テーブルの機械加工では無視されます。 「コメント」属性はまた、「クラス」要素の子要素にそのような行動と一致オペレーターだけでなく、クラスやルールの定義として、文書の「ルール」セクション内のすべての要素、上に置かれますが、なくてもよいです。最後に、メタデータでは、唯一の「バージョン」と「参照」の要素は、「コメント」の属性（[RFC3743]の構文に一致するように）を有していてもよいです。"
    },
    {
      "indent": 0,
      "text": "5.5. Code Point Tagging",
      "section_title": true,
      "ja": "5.5. コードポイントタギング"
    },
    {
      "indent": 3,
      "text": "Typically, LGRs are used to explicitly designate allowable code points, where any label that contains a code point not explicitly listed in the LGR is considered an ineligible label according to the ruleset.",
      "ja": "LGRsが明示的に許容可能なコードポイントを指定するために使用され、典型的には、ここで明示的LGRに記載されていないコードポイントを含む任意のラベルは、ルールセットに従って資格ラベル考えられます。"
    },
    {
      "indent": 3,
      "text": "For more-complex registry rules, there may be a need to discern one or more subsets of code points. This can be accomplished by applying an OPTIONAL \"tag\" attribute to \"char\" or \"range\" elements that are child elements of the \"data\" element. By collecting code points that share the same tag value, character classes may be defined (see Section 6.2.2) that can then be used in parameterized context or whole label rules (see Section 6.3.2).",
      "ja": "より複雑なレジストリルールのため、コード・ポイントのうちの1つまたは複数のサブセットを識別する必要があるかもしれません。これは、「チャー」または「データ」要素の子要素である「範囲」要素にOPTIONAL「タグ」属性を適用することによって達成することができます。同じタグ値を共有するコードポイントを収集することによって、文字クラスは、次いで、パラメータ化されたコンテキストまたは全体ラベルルール（セクション6.3.2を参照）で使用することができる（セクション6.2.2を参照）を定義することができます。"
    },
    {
      "indent": 3,
      "text": "Each \"tag\" attribute MAY contain multiple values separated by white space. A tag value is an identifier that may also include certain punctuation marks, such as a colon. Formally, it MUST correspond to the XML 1.0 Nmtoken (Name token) production (see [XML] Section 2.3). It is an error to duplicate a value within the same \"tag\" attribute. A \"tag\" attribute for a \"range\" element applies to all code points in the range. Because code point sequences are not proper members of a set of code points, a \"tag\" attribute MUST NOT be present in a \"char\" element defining a code point sequence.",
      "ja": "各「タグ」属性が空白で区切られた複数の値が含まれる場合があります。タグ値はまた、結腸のような特定の句読点を含むことができる識別子です。正式に、それはXML 1.0のNmtoken（名前トークン）生産に対応しなければならない（[XML]のセクション2.3を参照）。同じ「タグ」属性内の値を複製するとエラーになります。 「範囲」要素の「タグ」属性は、範囲内のすべてのコード・ポイントに適用されます。コードポイント配列はコードポイントの集合の適切なメンバーではないので、「タグ」属性は、コード・ポイント・シーケンスを定義する「チャー」要素に存在してはなりません。"
    },
    {
      "indent": 0,
      "text": "6. Whole Label and Context Evaluation",
      "section_title": true,
      "ja": "6.ラベル全体とコンテキスト評価"
    },
    {
      "indent": 0,
      "text": "6.1. Basic Concepts",
      "section_title": true,
      "ja": "6.1. 基本概念"
    },
    {
      "indent": 3,
      "text": "The \"rules\" element contains the specification of both context-based and whole label rules. Collectively, these are known as Whole Label Evaluation (WLE) rules (Section 6.3). The \"rules\" element also contains the character classes (Section 6.2) that they depend on, and any actions (Section 7) that assign dispositions to labels based on rules or variant mappings.",
      "ja": "「ルール」要素はコンテキストベースとラベル全体ルールの両方の仕様が含まれています。まとめると、これらは、ラベル全体の評価（WLE）のルール（6.3節）として知られています。 「ルール」の要素はまた、彼らはに依存していることを文字クラス（セクション6.2）、および規則または変異体のマッピングに基づいてラベルに処分を割り当てる任意のアクション（7節）が含まれています。"
    },
    {
      "indent": 3,
      "text": "A whole label rule is applied to the whole label. It is used to validate both original labels and any variant labels computed from them.",
      "ja": "ラベル全体のルールは、ラベル全体に適用されます。元のラベルとそれらから計算された任意の変形のラベルの両方を検証するために使用されます。"
    },
    {
      "indent": 3,
      "text": "A rule implementing a conditional context as discussed in Section 5.2 does not necessarily apply to the whole label but may be specific to the context around a single code point or code point sequence. Certain code points in a label sometimes need to satisfy context-based rules -- for example, for the label to be considered valid, or to satisfy the context for a variant mapping (see the description of the \"when\" attribute in Section 6.4).",
      "ja": "セクション5.2で議論するように、条件付きコンテキストを実装するルールは、必ずしも全体のラベルには適用されないが、単一のコードポイントまたはコード点列の周りコンテキストに特異的であってもよいです。 （「」セクション6.4での属性の説明を参照してください）ラベルが有効と見なされるために、例えば、または変異体のマッピングのためのコンテキストを満たすために - ラベル内の一部のコードポイントは時々、コンテキストベースのルールを満たす必要があります。"
    },
    {
      "indent": 3,
      "text": "For example, if a rule is referenced in the \"when\" attribute of a variant mapping, it is used to describe the conditional context under which the particular variant mapping is defined to exist.",
      "ja": "ルールが「いつ」変異マッピングの属性で参照されている場合、例えば、特定のバリアントマッピングが存在するように定義されている下の条件コンテキストを記述するために使用されます。"
    },
    {
      "indent": 3,
      "text": "Each rule is defined in a \"rule\" element. A rule may contain the following as child elements:",
      "ja": "各ルールは、「ルール」の要素で定義されています。ルールは、子要素として、以下が含まれる場合があります。"
    },
    {
      "indent": 3,
      "text": "o literal code points or code point sequences",
      "ja": "リテラルコードポイントまたはコード点列O"
    },
    {
      "indent": 3,
      "text": "o character classes, which define sets of code points to be used for context comparisons",
      "ja": "コードポイントのセットを定義O文字クラスは、コンテキストの比較のために使用されます"
    },
    {
      "indent": 3,
      "text": "o context operators, which define when character classes and literals may appear",
      "ja": "文字クラスとリテラルが表示される場合があります時に定義Oコンテキスト演算子、"
    },
    {
      "indent": 3,
      "text": "o nested rules, whether defined in place or invoked by reference",
      "ja": "O場所で定義または参照によって呼び出されるかどうかを、ルールをネスト"
    },
    {
      "indent": 3,
      "text": "Collectively, these are called \"match operators\" and are listed in Section 6.3.2. An LGR containing rules or match operators that",
      "ja": "まとめると、これらは「マッチ演算子」と呼ばれ、6.3.2項に記載されています。そのルールや試合の演算子を含むLGR"
    },
    {
      "indent": 3,
      "text": "1. are incorrectly defined or nested,",
      "section_title": true,
      "ja": "1.誤って定義またはネストされています、"
    },
    {
      "indent": 3,
      "text": "2. have invalid attributes, or",
      "section_title": true,
      "ja": "2.無効な属性を持っている、または"
    },
    {
      "indent": 3,
      "text": "3. have invalid or undefined attribute values",
      "section_title": true,
      "ja": "3.無効または未定義の属性値を持っています"
    },
    {
      "indent": 3,
      "text": "MUST be rejected. Note that not all of the constraints defined here are validated by the schema.",
      "ja": "拒絶しなければなりません。ここで定義された制約のないすべてはスキーマによって検証されることに注意してください。"
    },
    {
      "indent": 0,
      "text": "6.2. Character Classes",
      "section_title": true,
      "ja": "6.2. 文字クラス"
    },
    {
      "indent": 3,
      "text": "Character classes are sets of characters that often share a particular property. While they function like sets in every way, even supporting the usual set operators, they are called \"character classes\" here in a nod to the use of that term in regular expression syntax. (This also avoids confusion with the term \"character set\" in the sense of character encoding.)",
      "ja": "文字クラスは、多くの場合、特定のプロパティを共有する文字のセットです。彼らも普通の集合演算子をサポートし、あらゆる方法でセットのように機能しますが、それらはここでは、正規表現構文におけるその用語の使用にうなずきで「文字クラス」と呼ばれています。 （これはまた、文字エンコーディングの意味での用語「文字セット」との混同を避けることができます。）"
    },
    {
      "indent": 3,
      "text": "Character classes can be specified in several ways:",
      "ja": "文字クラスは、いくつかの方法で指定することができます。"
    },
    {
      "indent": 3,
      "text": "o by defining the class via matching a tag in the code point data. All characters with the same \"tag\" attribute are part of the same class;",
      "ja": "コードポイントデータにタグをマッチングを介してクラスを定義することによって、O。同じ「タグ」属性を持つすべての文字は、同じクラスの一部です。"
    },
    {
      "indent": 3,
      "text": "o by referencing a value of one of the Unicode character properties defined in the Unicode Character Database;",
      "ja": "OのUnicode文字データベースで定義されたUnicode文字プロパティの1つの値を参照することにより、"
    },
    {
      "indent": 3,
      "text": "o by explicitly listing all the code points in the class; or",
      "ja": "明示的にクラス内のすべてのコードポイントをリストアップすることにより、O。または"
    },
    {
      "indent": 3,
      "text": "o by defining the class as a set combination of any number of other classes.",
      "ja": "他のクラスの任意の数のセットの組み合わせとしてクラスを定義することによって、O。"
    },
    {
      "indent": 0,
      "text": "6.2.1. Declaring and Invoking Named Classes",
      "section_title": true,
      "ja": "6.2.1. 名前のクラスの宣言と呼び出し"
    },
    {
      "indent": 3,
      "text": "A character class has an OPTIONAL \"name\" attribute consisting of a single identifier not containing spaces. All names for classes must be unique. If the \"name\" attribute is omitted, the class is anonymous and exists only inside the rule or combined class where it is defined. A named character class is defined independently and can be referenced by name from within any rules or as part of other character class definitions.",
      "ja": "文字クラスは、スペースを含まない単一の識別子からなるオプション「名前」属性を持っています。クラスのためのすべての名前は一意でなければなりません。 「name」属性が省略された場合、クラスが匿名であり、唯一それが定義されたルールまたは組み合わせたクラス内に存在します。名前付き文字クラスが独立して定義され、任意のルール内から、または他の文字クラス定義の一部として、名前で参照することができます。"
    },
    {
      "indent": 7,
      "text": "<class name=\"example\" comment=\"an example class definition\">\n    0061 4E00\n</class>\n...\n<rule>\n    <class by-ref=\"example\" />\n</rule>",
      "raw": true
    },
    {
      "indent": 3,
      "text": "An empty \"class\" element with a \"by-ref\" attribute is a reference to an existing named class. The \"by-ref\" attribute MUST NOT be used in the same \"class\" element with any of these attributes: \"name\", \"from-tag\", \"property\", or \"ref\". The \"name\" attribute MUST be present if and only if the class is a direct child element of the \"rules\" element. It is an error to reference a named class for which the definition has not been seen.",
      "ja": "「バイ・参照」属性を持つ空の「クラス」の要素は、既存の名前付きクラスへの参照です。 「名前」、「からタグ」、「プロパティ」、または「参照」：「バイ参照」属性は、これらの属性のいずれかと同じ「クラス」要素に使用してはいけません。そしてクラスが「ルール」要素の直接の子要素である場合にだけ、「名前」属性が存在しなければなりません。定義が見られなかったためという名前のクラスを参照するとエラーになります。"
    },
    {
      "indent": 0,
      "text": "6.2.2. Tag-Based Classes",
      "section_title": true,
      "ja": "6.2.2. タグベースのクラス"
    },
    {
      "indent": 3,
      "text": "The \"char\" or \"range\" elements that are child elements of the \"data\" element MAY contain a \"tag\" attribute that consists of one or more space-separated tag values; for example:",
      "ja": "「チャー」または「データ」要素の子要素である「範囲」の要素は、一つ以上のスペースで区切られたタグ値から成る「タグ」属性を含むかもしれません。例えば："
    },
    {
      "indent": 7,
      "text": "<char cp=\"0061\" tag=\"letter lower\"/>\n<char cp=\"4E00\" tag=\"letter\"/>",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This defines two tags for use with code point U+0061, the tag \"letter\" and the tag \"lower\". Use",
      "ja": "これは、コード・ポイントU + 0061と共に使用するための2個のタグ、タグ「文字」とタグ「下」を定義します。つかいます"
    },
    {
      "indent": 7,
      "text": "<class name=\"letter\" from-tag=\"letter\" />\n<class name=\"lower\" from-tag=\"lower\" />",
      "raw": true
    },
    {
      "indent": 3,
      "text": "to define two named character classes, \"letter\" and \"lower\", containing all code points with the respective tags, the first with 0061 and 4E00 as elements, and the latter with 0061 but not 4E00 as an element. The \"name\" attribute may be omitted for an anonymous in-place definition of a nested, tag-based class.",
      "ja": "各タグ、要素として4E00 0061と第一及び4E00要素として、および0061と後者ではないと、すべてのコードポイントを含む、2つの名前付き文字クラス、「文字」および「低級」を定義します。 「name」属性は、ネストされた、タグベースクラスの匿名のインプレース定義のために省略してもよいです。"
    },
    {
      "indent": 3,
      "text": "Tag values are typically identifiers, with the addition of a few punctuation symbols, such as a colon. Formally, they MUST correspond to the XML 1.0 Nmtoken production. While a \"tag\" attribute may contain a list of tag values, the \"from-tag\" attribute MUST always contain a single tag value.",
      "ja": "タグの値は、コロンなど、いくつかの区切り記号のほかに、通常の識別子です。正式には、彼らは、XML 1.0のNmtoken生産に対応しなければなりません。 「タグ」属性は、タグ値のリストを含んでいてもよいが、「からタグ」属性は常に単一のタグ値を含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the document contains no \"char\" or \"range\" elements with a corresponding tag, the character class represents the empty set. This is valid, to allow a common \"rules\" element to be shared across files. However, it is RECOMMENDED that implementations allow for a warning to ensure that referring to an undefined tag in this way is intentional.",
      "ja": "文書がない「チャー」または対応するタグと「範囲」要素が含まれていない場合、文字クラスは、空集合を表します。これは一般的な「ルール」要素は、ファイル間で共有できるようにするために、有効です。しかし、実装は、このように未定義のタグを参照することは意図的であることを保証するために警告を可能にすることを推奨されます。"
    },
    {
      "indent": 0,
      "text": "6.2.3. Unicode Property-Based Classes",
      "section_title": true,
      "ja": "6.2.3.  Unicodeのプロパティベースのクラス"
    },
    {
      "indent": 3,
      "text": "A class is defined in terms of Unicode properties by giving the Unicode property alias and the property value or property value alias, separated by a colon.",
      "ja": "クラスは、コロンで区切られ、Unicodeプロパティの別名とプロパティ値またはプロパティ値のエイリアスを与えることによって、Unicodeの特性の観点から定義されています。"
    },
    {
      "indent": 7,
      "text": "<class name=\"virama\" property=\"ccc:9\" />",
      "ja": "<クラス名= \"ヴィラーマ\" プロパティ= \"CCC：9\" />"
    },
    {
      "indent": 3,
      "text": "The example above selects all code points for which the Unicode Canonical Combining Class (ccc) value is 9. This value of the ccc is assigned to all code points that encode viramas.",
      "ja": "上記の例は、Unicode正規のクラス（CCC）値を結合するすべてのコードポイントを選択し、CCCのこの値はviramasをコードする全てのコードポイントに割り当てられている9です。"
    },
    {
      "indent": 3,
      "text": "Unicode property values MUST be designated via a composite of the attribute name and value as defined for the property value in [UAX42], separated by a colon. Loose matching of property values and names as described in [UAX44] is not appropriate for an XML schema and is not supported; it is likewise not supported in the XML representation [UAX42] of the Unicode Character Database itself.",
      "ja": "[UAX42]、コロンで区切らにおけるプロパティ値に対して定義されたようにUnicodeのプロパティ値は、属性名と値の複合を介して指定されなければなりません。プロパティ値と[UAX44]に記載されているように名前の緩いマッチングは、XMLスキーマに対して適切ではなく、サポートされていません。それは、同様に、ユニコード文字データベース自体のXML表現[UAX42]ではサポートされていません。"
    },
    {
      "indent": 3,
      "text": "A property-based class MAY be anonymous, or, when defined as an immediate child of the \"rules\" element, it MAY be named to relate a formal property definition to its usage, such as the use of the value 9 for ccc to designate a virama (or halant) in various scripts.",
      "ja": "プロパティベースクラスが匿名であってもよいし、「ルール」要素の直接の子として定義されたときに、そのような指定するCCCの値9を使用すると、その使用に正式なプロパティ定義を関連付けるために命名されるかもしれません様々なスクリプトでヴィラーマ（またはhalant）。"
    },
    {
      "indent": 3,
      "text": "Unicode properties may, in principle, change between versions of the Unicode Standard. However, the values assigned for a given version are fixed. If Unicode properties are used, a Unicode version MUST be declared in the \"unicode-version\" element in the header. (Note: Some Unicode properties are by definition stable across versions and do not change once assigned; see [Unicode-Stability].)",
      "ja": "Unicodeの特性は、原理的には、Unicode標準のバージョン間で変更することができます。しかし、所与のバージョンに割り当てられた値が固定されています。 Unicodeプロパティを使用する場合、Unicodeバージョンは、ヘッダ内の「ユニコードバージョン」エレメント内で宣言されなければなりません。 （注：一部のUnicodeプロパティは、バージョン間で定義により安定しており、一度割り当ては変更されません。[ユニコード-安定性]を参照してください。）"
    },
    {
      "indent": 3,
      "text": "All implementations processing LGR files SHOULD provide support for the following minimal set of Unicode properties:",
      "ja": "LGRファイルを処理するすべての実装はUnicodeプロパティの以下の最小セットのサポートを提供する必要があります。"
    },
    {
      "indent": 3,
      "text": "o General Category (gc)",
      "ja": "O一般的なカテゴリ（GC）"
    },
    {
      "indent": 3,
      "text": "o Script (sc)",
      "ja": "Oスクリプト（SC）"
    },
    {
      "indent": 3,
      "text": "o Canonical Combining Class (ccc)",
      "ja": "Oカノニカルは、クラス（CCC）を組み合わせます"
    },
    {
      "indent": 3,
      "text": "o Bidi Class (bc)",
      "ja": "O双方向クラス（BC）"
    },
    {
      "indent": 3,
      "text": "o Arabic Joining Type (jt)",
      "ja": "タイプへの参加Oアラビア語（JT）"
    },
    {
      "indent": 3,
      "text": "o Indic Syllabic Category (InSC)",
      "ja": "Oインド語音節カテゴリ（NSC）"
    },
    {
      "indent": 3,
      "text": "o Deprecated (Dep)",
      "ja": "O非推奨（DEP）"
    },
    {
      "indent": 3,
      "text": "The short name for each property is given in parentheses.",
      "ja": "各プロパティの短い名前は括弧内に与えられています。"
    },
    {
      "indent": 3,
      "text": "If a program that is using an LGR to determine the validity of a label encounters a property that it does not support, it MUST abort with an error.",
      "ja": "ラベルの有効性を判断するためにLGRを使用しているプログラムは、それがサポートされていないプロパティを見つけたら、それはエラーで中止しなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.2.4. Explicitly Declared Classes",
      "section_title": true,
      "ja": "6.2.4. 明示的に宣言されたクラス"
    },
    {
      "indent": 3,
      "text": "A class of code points may also be declared by listing all code points that are members of the class. This is useful when tagging cannot be used because code points are not listed individually as part of the eligible set of code points for the given LGR -- for example, because they only occur in code point sequences.",
      "ja": "コードポイントのクラスは、クラスのメンバーであるすべてのコード・ポイントをリストして宣言することができます。例えば、それらは唯一のコードポイント配列で発生するので、 - コードポイントが与えられたLGRのコードポイントの対象セットの一部として個別に記載されていないため、タグを使用することができない場合に有用です。"
    },
    {
      "indent": 3,
      "text": "To define a class in terms of an explicit list of code points, use a space-separated list of hexadecimal code point values:",
      "ja": "コードポイントの明示的なリストの点でクラスを定義するために、16進コードポイント値のスペースで区切られたリストを使用します。"
    },
    {
      "indent": 7,
      "text": "<class name=\"abcd\">0061 0062 0063 0064</class>",
      "ja": "<クラス名= \"ABCD\"> 0062 0063 0064 0061 </クラス>"
    },
    {
      "indent": 3,
      "text": "This defines a class named \"abcd\" containing the code points for characters \"a\", \"b\", \"c\", and \"d\". The ordering of the code points is not material, but it is RECOMMENDED to list them in ascending order; not doing so makes it unnecessarily difficult for users to detect errors such as duplicates or to compare and review these classes against other specifications.",
      "ja": "これは、文字「A」、「B」、「C」及び「D」のコードポイントを含む「ABCD」という名前のクラスを定義します。コード・ポイントの順序は重要ではないが、昇順でそれらを一覧表示するお勧めします。ユーザーは、重複などのエラーを検出したり、比較やその他の仕様に対して、これらのクラスを確認するために行っていないので、それが不必要に難しくなります。"
    },
    {
      "indent": 3,
      "text": "In a class definition, ranges of code points are represented by a hexadecimal start and end value separated by a hyphen. The following declaration is equivalent to the preceding:",
      "ja": "クラス定義では、コードポイントの範囲はハイフンで区切られた16進開始および終了値で表されます。次の宣言は、前と同等です。"
    },
    {
      "indent": 7,
      "text": "<class name=\"abcd\">0061-0064</class>",
      "ja": "<クラス名= \"ABCD\"> 0061から0064 </クラス>"
    },
    {
      "indent": 3,
      "text": "Range and code point declarations can be freely intermixed:",
      "ja": "レンジとコードポイントの宣言を自由に混在させることができます。"
    },
    {
      "indent": 7,
      "text": "<class name=\"abcd\">0061 0062-0063 0064</class>",
      "ja": "<クラス名= \"ABCD\"> 0062から0063 0064 0061 </クラス>"
    },
    {
      "indent": 3,
      "text": "The contents of a class differ from a repertoire in that the latter MAY contain sequences as elements, while the former MUST NOT. Instead, they closely resemble character classes as found in regular expressions.",
      "ja": "クラスの内容は、前者ではないなければならないが、後者は、要素として配列を含んでもよいことでレパートリーは異なります。正規表現で見られるような代わりに、彼らは密接に文字クラスに似ています。"
    },
    {
      "indent": 0,
      "text": "6.2.5. Combined Classes",
      "section_title": true,
      "ja": "6.2.5. 組み合わせクラス"
    },
    {
      "indent": 3,
      "text": "Classes may be combined using operators for set complement, union, intersection, difference (elements of the first class that are not in the second), and symmetric difference (elements in either class but not both). Because classes fundamentally function like sets, the union of several character classes is itself a class, for example.",
      "ja": "クラスが設定された補体、組合、交差点、差（第二にない第1のクラスの要素）、及び対称差（いずれかのクラスではなく、両方の要素）のための演算子を使用して組み合わせることができます。クラスは基本的にセットのように機能するので、いくつかの文字クラスの労働組合は、例えば、クラス自体です。"
    },
    {
      "indent": 3,
      "text": "+-------------------+----------------------------------------------+\n| Logical Operation | Example                                      |\n+-------------------+----------------------------------------------+\n| Complement        | <complement><class by-ref=\"xxx\"></complement>|\n+-------------------+----------------------------------------------+\n| Union             | <union>                                      |\n|                   |    <class by-ref=\"class-1\"/>                 |\n|                   |    <class by-ref=\"class-2\"/>                 |\n|                   |    <class by-ref=\"class-3\"/>                 |\n|                   | </union>                                     |\n+-------------------+----------------------------------------------+\n| Intersection      | <intersection>                               |\n|                   |    <class by-ref=\"class-1\"/>                 |\n|                   |    <class by-ref=\"class-2\"/>                 |\n|                   | </intersection>                              |\n+-------------------+----------------------------------------------+\n| Difference        | <difference>                                 |\n|                   |    <class by-ref=\"class-1\"/>                 |\n|                   |    <class by-ref=\"class-2\"/>                 |\n|                   | </difference>                                |\n+-------------------+----------------------------------------------+\n| Symmetric         | <symmetric-difference>                       |\n| Difference        |    <class by-ref=\"class-1\"/>                 |\n|                   |    <class by-ref=\"class-2\"/>                 |\n|                   | </symmetric-difference>                      |\n+-------------------+----------------------------------------------+",
      "raw": true
    },
    {
      "indent": 31,
      "text": "Set Operators",
      "ja": "集合演算子"
    },
    {
      "indent": 3,
      "text": "The elements from this table may be arbitrarily nested inside each other, subject to the following restriction: a \"complement\" element MUST contain precisely one \"class\" or one of the operator elements, while an \"intersection\", \"symmetric-difference\", or \"difference\" element MUST contain precisely two, and a \"union\" element MUST contain two or more of these elements.",
      "ja": "このテーブルの要素を任意に以下の制限を受け、互いに内部に入れ子にすることができる：「交差点」、「対称差分」ながら「補体」要素は、正確に1つの「クラス」またはオペレータ要素のいずれかを含まなければなりません、あるいは「違い」要素は、正確に2を含まなければならない、と「労働組合」の要素は、これらの要素の2つ以上を含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "An anonymous combined class can be defined directly inside a rule or any of the match operator elements that allow child elements (see Section 6.3.2) by using the set combination as the outer element.",
      "ja": "匿名複合クラスは、外側の要素として設定された組み合わせを使用して（セクション6.3.2を参照）ルールまたは子要素を可能にマッチオペレータ要素のいずれかの内部に直接定義することができます。"
    },
    {
      "indent": 7,
      "text": "<rule>\n    <union>\n        <class by-ref=\"xxx\"/>\n        <class by-ref=\"yyy\"/>\n    </union>\n</rule>",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The example shows the definition of an anonymous combined class that represents the union of classes \"xxx\" and \"yyy\". There is no need to wrap this union inside another \"class\" element, and, in fact, set combination elements MUST NOT be nested inside a \"class\" element.",
      "ja": "例では、クラス「XXX」と「YYY」の和集合を表し、匿名複合クラスの定義を示しています。実際には、セットの組み合わせ要素は、「クラス」要素内にネストしてはならない、そこに別の「クラス」要素内に、この組合をラップする必要がない、と。"
    },
    {
      "indent": 3,
      "text": "Lastly, to create a named combined class that can be referenced in other classes or in rules as <class by-ref=\"xxxyyy\"/>, add a \"name\" attribute to the set combination element -- for example, <union name=\"xxxyyy\" /> -- and place it at the top level immediately below the \"rules\" element (see Section 6.2.1).",
      "ja": "<、組合名を例えば - 最後に、他のクラスでは<クラスによって-REF =「xxxyyy」/>、セットの組み合わせの要素に「名前」属性を追加するなどのルールで参照することができるという名前を組み合わせたクラスを作成するには=「xxxyyy」/>  - と、すぐに「ルール」要素以下のトップレベルでそれを置く（6.2.1項を参照してください）。"
    },
    {
      "indent": 7,
      "text": "<rules>\n   <union name=\"xxxyyy\">\n       <class by-ref=\"xxx\"/>\n       <class by-ref=\"yyy\"/>\n   </union>\n     ...\n</rules>",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Because (as for ordinary sets) a combination of classes is itself a class, no matter by what combinations of set operators a combined class is created, a reference to it always uses the \"class\" element as described in Section 6.2.1. That is, a named class is always referenced via an empty \"class\" element using the \"by-ref\" attribute containing the name of the class to be referenced.",
      "ja": "クラスの組み合わせは、クラス自体である（通常のセットのためのような）ので、セクション6.2.1で説明したように、複合クラスが作成された集合演算子のどの組み合わせによって関係なく、それへの参照は、常に「クラス」要素を使用しています。これは、名前のクラスが常に参照されるクラスの名前を含む「バイ参照」属性を使用して、空の「クラス」要素を介して参照されています。"
    },
    {
      "indent": 0,
      "text": "6.3. Whole Label and Context Rules",
      "section_title": true,
      "ja": "6.3. ラベル全体とコンテキストルール"
    },
    {
      "indent": 3,
      "text": "Each rule comprises a series of matching operators that must be satisfied in order to determine whether a label meets a given condition. Rules may reference other rules or character classes defined elsewhere in the table.",
      "ja": "各ルールは、ラベルが所定の条件を満たしているかどうかを決定するために満たされなければならない一致オペレータの系列を含みます。ルールは、テーブル内の他の場所で定義された他のルールや文字クラスを参照することがあります。"
    },
    {
      "indent": 0,
      "text": "6.3.1. The \"rule\" Element",
      "section_title": true,
      "ja": "6.3.1.  「ルール」の要素"
    },
    {
      "indent": 3,
      "text": "A matching rule is defined by a \"rule\" element, the child elements of which are one of the match operators from Section 6.3.2. In evaluating a rule, each child element is matched in order. \"rule\" elements MAY be nested inside each other and inside certain match operators.",
      "ja": "マッチングルールが「ルール」要素によって定義される、の子要素は、セクション6.3.2からの一致演算子の一つです。ルールの評価では、それぞれの子要素が順番にマッチしています。 「ルール」の要素が互いに内側と特定の一致演算子内にネストされるかもしれません。"
    },
    {
      "indent": 3,
      "text": "A simple rule to match a label where all characters are members of some class called \"preferred-codepoint\":",
      "ja": "：すべての文字が「優先-コードポイント」と呼ばれるいくつかのクラスのメンバーであるラベルと一致するように、単純なルール"
    },
    {
      "indent": 7,
      "text": "<rule name=\"preferred-label\">\n    <start />\n    <class by-ref=\"preferred-codepoint\" count=\"1+\"/>\n    <end />\n</rule>",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Rules are paired with explicit and implied actions, triggering these actions when a rule matches a label. For example, a simple explicit action for the rule shown above would be:",
      "ja": "ルールはルールがラベルと一致したときにこれらのアクションをトリガーする、明示的および暗黙のアクションとペアになっています。たとえば、上に示した規則のための簡単な明示的なアクションは次のようになります。"
    },
    {
      "indent": 7,
      "text": "<action disp=\"allocatable\" match=\"preferred-label\" />",
      "ja": "<アクションDISP =「割当可能な」一致=「優先ラベル」/>"
    },
    {
      "indent": 3,
      "text": "The rule in this example would have the effect of setting the policy disposition for a label made up entirely of preferred code points to \"allocatable\". Explicit actions are further discussed in Section 7 and implicit actions in Section 7.5. Another use of rules is in defining conditional contexts for code points and variants as discussed in Sections 5.2 and 5.3.5.",
      "ja": "この例のルールは、ラベルのポリシー処分を設定した場合の効果は、「割り当て可能」に有利なコードポイントのみで構成されているでしょう。明示的なアクションは、さらに第7及びセクション7.5で暗黙のアクションに記載されています。ルールの別の使用は、セクション5.2および5.3.5で説明したように、コードポイントと変異体の条件コンテキストを定義しています。"
    },
    {
      "indent": 3,
      "text": "A rule that is an immediate child element of the \"rules\" element MUST be named using a \"name\" attribute containing a single identifier string with no spaces. A named rule may be incorporated into another rule by reference and may also be referenced by an \"action\" element, \"when\" attribute, or \"not-when\" attribute. If the \"name\" attribute is omitted, the rule is anonymous and MUST be nested inside another rule or match operator.",
      "ja": "「ルール」要素の直接の子要素であるルールは、スペースなしの単一の識別子の文字列を含む「名前」属性を使用して名前を付ける必要があります。命名規則は、参照することにより、別のルールに組み込むことができる、また、「アクション」要素、「」属性、又は「未」属性によって参照されてもよいです。 「name」属性が省略された場合、ルールは匿名で、別のルールや試合オペレータ内にネストされなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.3.2. The Match Operators",
      "section_title": true,
      "ja": "6.3.2. マッチ演算子"
    },
    {
      "indent": 3,
      "text": "The child elements of a rule are a series of match operators, which are listed here by type and name and with a basic example or two.",
      "ja": "ルールの子要素は、タイプと名前でかつ基本的な例または2でここにリストされているマッチ演算子、一連のです。"
    },
    {
      "indent": 3,
      "text": "+------------+-------------+------------------------------------+\n| Type       | Operator    | Examples                           |\n+------------+-------------+------------------------------------+\n| logical    | any         | <any />                            |\n|            +-------------+------------------------------------+\n|            | choice      | <choice>                           |\n|            |             |  <rule by-ref=\"alternative1\"/>     |\n|            |             |  <rule by-ref=\"alternative2\"/>     |\n|            |             | </choice>                          |\n+--------------------------+------------------------------------+\n| positional | start       | <start />                          |\n|            +-------------+------------------------------------+\n|            | end         | <end />                            |\n+--------------------------+------------------------------------+\n| literal    | char        | <char cp=\"0061 0062 0063\" />       |\n+--------------------------+------------------------------------+\n| set        | class       | <class by-ref=\"class1\" />          |\n|            |             | <class>0061 0064-0065</class>      |\n+--------------------------+------------------------------------+\n| group      | rule        | <rule by-ref=\"rule1\" />            |\n|            |             | <rule><any /></rule>               |\n+--------------------------+------------------------------------+\n| contextual | anchor      | <anchor />                         |\n|            +-------------+------------------------------------+\n|            | look-ahead  | <look-ahead><any /></look-ahead>   |\n|            +-------------+------------------------------------+\n|            | look-behind | <look-behind><any /></look-behind> |\n+--------------------------+------------------------------------+",
      "raw": true
    },
    {
      "indent": 30,
      "text": "Match Operators",
      "ja": "マッチ演算子"
    },
    {
      "indent": 3,
      "text": "Any element defining an anonymous class can be used as a match operator, including any of the set combination operators (see Section 6.2.5) as well as references to named classes.",
      "ja": "匿名クラスを定義する任意の要素がセットの組み合わせ演算子（6.2.5項を参照）と同様に名前のクラスへの参照のいずれかを含む、マッチ演算子として使用することができます。"
    },
    {
      "indent": 3,
      "text": "All match operators shown as empty elements in the Examples column of the table above do not support child elements of their own; otherwise, match operators MAY be nested. In particular, anonymous \"rule\" elements can be used for grouping.",
      "ja": "上記の表の例列内の空の要素として示されているすべてのマッチ演算子は、自分の子要素をサポートしていません。それ以外の場合は、マッチ演算子は入れ子にすることができます。具体的には、匿名の「ルール」の要素がグループ化に使用することができます。"
    },
    {
      "indent": 0,
      "text": "6.3.3. The \"count\" Attribute",
      "section_title": true,
      "ja": "6.3.3.  「カウント」属性"
    },
    {
      "indent": 3,
      "text": "The OPTIONAL \"count\" attribute, when present, specifies the minimally required or maximal permitted number of times a match operator is used to match input. If the \"count\" attribute is",
      "ja": "オプション「カウント」属性は、存在する場合、マッチオペレータが入力を一致させるために使用される回の最低限必要なまたは最大許容数を指定します。 「カウント」属性がある場合"
    },
    {
      "indent": 3,
      "text": "n the match operator matches the input exactly n times, where n is 1 or greater.",
      "ja": "Nマッチオペレータが正確にn回、nは1以上である場合、入力に一致します。"
    },
    {
      "indent": 3,
      "text": "n+ the match operator matches the input at least n times, where n is 0 or greater.",
      "ja": "nは0以上である場合、N +一致演算子は、少なくともn回の入力に一致します。"
    },
    {
      "indent": 3,
      "text": "n:m the match operator matches the input at least n times, where n is 0 or greater, but matches the input up to m times in total, where m > n. If m = n and n > 0, the match operator matches the input exactly n times.",
      "ja": "N：Nは0以上であるが、合計、M> Nでm回までの入力に一致する場合、一致演算子は、少なくとも入力をn回一致mです。もしM = Nとn> 0、マッチオペレータが正確に入力をn回一致します。"
    },
    {
      "indent": 3,
      "text": "If there is no \"count\" attribute, the match operator matches the input exactly once.",
      "ja": "何の「カウント」属性が存在しない場合、マッチ演算子は正確に一度の入力に一致します。"
    },
    {
      "indent": 3,
      "text": "In matching, greedy evaluation is used in the sense defined for regular expressions: beyond the required number or times, the input is matched as many times as possible, but not so often as to prevent a match of the remainder of the rule.",
      "ja": "必要な数又は時間を超えて、入力が可能な回数として一致している、ではないので、多くの場合、ルールの残りの試合を防止する：マッチングでは、貪欲評価は、正規表現のために定義された意味で使用されています。"
    },
    {
      "indent": 3,
      "text": "A \"count\" attribute MUST NOT be applied to any element that contains a \"name\" attribute but MAY be applied to operators such as \"class\" that declare anonymous classes (including combined classes) or invoke any predefined classes by reference. The \"count\" attribute MUST NOT be applied to any \"class\" element, or element defining a combined class, when it is nested inside a combined class.",
      "ja": "属性には、「名前」属性が含まれていますが（組み合わせクラスを含む）匿名クラスを宣言するか、参照することにより任意の事前に定義されたクラスを呼び出すように「クラス」として事業者にも適用することができる任意の要素に適用してはならない「カウント」。 「カウント」属性は、任意の「クラス」の要素に適用される、またはそれを組み合わせたクラス内にネストされたときの要素は、複合クラスを定義してはなりません。"
    },
    {
      "indent": 3,
      "text": "A \"count\" attribute MUST NOT be applied to match operators of type \"start\", \"end\", \"anchor\", \"look-ahead\", or \"look-behind\" or to any operators, such as \"rule\" or \"choice\", that contain a nested instance of them. This limitation applies recursively and irrespective of whether a \"rule\" element containing these nested instances is declared in place or used by reference.",
      "ja": "「先読み」、属性が「終わり」、「アンカー」、「開始」タイプの演算子を一致させるために適用してはならない「カウント」、または「ルックビハインド」または「ルール」などの任意の演算子、または \"選択」、それらのネストされたインスタンスが含まれています。この制限は、再帰的にかかわらず、これらのネストされたインスタンスを含む「規則」要素が適所に宣言または参照によって使用されているかどうかの適用します。"
    },
    {
      "indent": 3,
      "text": "However, the \"count\" attribute MAY be applied to any other instances of either an anonymous \"rule\" element or a \"choice\" element, including those instances nested inside other match operators. It MAY also be applied to the elements \"any\" and \"char\", when used as match operators.",
      "ja": "しかし、「カウント」属性は、他の試合の事業者の中にネストされたそれらのインスタンスを含む匿名の「ルール」要素または「選択」要素のいずれかの他のインスタンスに適用することができます。一致演算子として使用される場合、それはまた、「任意」と「文字」の要素に適用することができます。"
    },
    {
      "indent": 0,
      "text": "6.3.4. The \"name\" and \"by-ref\" Attributes",
      "section_title": true,
      "ja": "6.3.4.  「名前」と「バイrefの」属性"
    },
    {
      "indent": 3,
      "text": "Like classes (see Section 6.2.1), rules declared as immediate child elements of the \"rules\" element MUST be named using a unique \"name\" attribute, and all other instances MUST NOT be named. Anonymous rules and classes or references to named rules and classes can be nested inside other match operators by reference.",
      "ja": "クラス（6.2.1項を参照）と同様に、「ルール」要素の直接の子要素として宣言されたルールには、一意の「名前」属性を使用して名前を付ける必要があり、そして他のすべてのインスタンスは、指定されてはなりません。匿名のルールとクラスまたは名前付きのルールとクラスへの参照は、参照することにより、他のマッチ演算子の中にネストすることができます。"
    },
    {
      "indent": 3,
      "text": "To reference a named rule or class inside a rule or match operator, use a \"rule\" or \"class\" element with an OPTIONAL \"by-ref\" attribute containing the name of the referenced element. It is an error to reference a rule or class for which the complete definition has not been seen. In other words, it is explicitly not possible to define recursive rules or class definitions. The \"by-ref\" attribute MUST NOT appear in the same element as the \"name\" attribute or in an element that has any child elements.",
      "ja": "ルールまたはマッチオペレータ内部命名規則またはクラスを参照するために、参照される要素の名前を含むオプション「によって-REF」属性と「ルール」または「クラス」要素を使用します。完全な定義は見られなかったため、ルールやクラスを参照するとエラーになります。言い換えれば、再帰的なルールやクラス定義を定義するには、明示的に不可能です。 「バイ・参照」属性が「名前」属性と同じ要素または任意の子要素を持つ要素に現れてはいけません。"
    },
    {
      "indent": 3,
      "text": "The example shows several named classes and a named rule referencing some of them by name.",
      "ja": "一例では、いくつかの名前のクラスと名前によってそれらのいくつかを参照するという名前のルールを示しています。"
    },
    {
      "indent": 7,
      "text": "<class name=\"letter\" property=\"gc:L\"/>\n<class name=\"combining-mark\" property=\"gc:M\"/>\n<class name=\"digit\" property=\"gc:Nd\" />\n<rule name=\"letter-grapheme\">\n   <class by-ref=\"letter\" count=\"1+\"/>\n   <class by-ref=\"combining-mark\" count=\"0+\"/>\n</rule>",
      "raw": true
    },
    {
      "indent": 0,
      "text": "6.3.5. The \"choice\" Element",
      "section_title": true,
      "ja": "6.3.5.  「選択」の要素"
    },
    {
      "indent": 3,
      "text": "The \"choice\" element is used to represent a list of two or more alternatives:",
      "ja": "「選択」の要素は、2つの以上の選択肢のリストを表すために使用されます。"
    },
    {
      "indent": 7,
      "text": "<rule name=\"ldh\">\n   <choice count=\"1+\">\n       <class by-ref=\"letter\"/>\n       <class by-ref=\"digit\"/>\n       <char cp=\"002D\" comment=\"literal HYPHEN\"/>\n   </choice>\n</rule>",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Each child element of a \"choice\" element represents one alternative. The first matching alternative determines the match for the \"choice\" element. To express a choice where an alternative itself consists of a sequence of elements, the sequence must be wrapped in an anonymous rule.",
      "ja": "「選択」要素のそれぞれの子要素には、1つの代替を表しています。最初に一致した選択肢は、「選択」要素の一致を決定します。代替自体は要素のシーケンスで構成されて選択肢を表現するために、シーケンスは、匿名のルールに包まれている必要があります。"
    },
    {
      "indent": 0,
      "text": "6.3.6. Literal Code Point Sequences",
      "section_title": true,
      "ja": "6.3.6. リテラルコードポイントシーケンス"
    },
    {
      "indent": 3,
      "text": "A literal code point sequence matches a single code point or a sequence. It is defined by a \"char\" element, with the code point or sequence to be matched given by the \"cp\" attribute. When used as a literal, a \"char\" element MAY contain a \"count\" attribute in addition to the \"cp\" attribute and OPTIONAL \"comment\" or \"ref\" attributes. No other attributes or child elements are permitted.",
      "ja": "リテラルコードポイントシーケンスは、単一のコードポイントまたはシーケンスにマッチします。 「CP」属性によって与え一致するコードポイント又は配列と、「CHAR」要素によって定義されます。リテラルとして使用する場合は、「CHAR」要素は、「CP」属性およびOPTIONAL「コメント」または「参照」に加えて「カウント」属性が含まれている可能性のある属性。他の属性や子要素は許可されません。"
    },
    {
      "indent": 0,
      "text": "6.3.7. The \"any\" Element",
      "section_title": true,
      "ja": "6.3.7.  「任意の」要素"
    },
    {
      "indent": 3,
      "text": "The \"any\" element is an empty element that matches any single code point. It MAY have a \"count\" attribute. For an example, see Section 6.3.9.",
      "ja": "「任意の」要素は、任意の単一のコードポイントと一致する空要素です。これは、「カウント」属性を持っているかもしれません。たとえば、6.3.9項を参照してください。"
    },
    {
      "indent": 3,
      "text": "Unlike a literal, the \"any\" element MUST NOT have a \"ref\" attribute.",
      "ja": "リテラルとは異なり、「任意の」要素は、「参照」属性を持ってはいけません。"
    },
    {
      "indent": 0,
      "text": "6.3.8. The \"start\" and \"end\" Elements",
      "section_title": true,
      "ja": "6.3.8.  「開始」と「終了」の要素"
    },
    {
      "indent": 3,
      "text": "To match the beginning or end of a label, use the \"start\" or \"end\" element. An empty label would match this rule:",
      "ja": "ラベルの先頭や末尾にマッチするには、「開始」または「終了」要素を使用します。空のラベルには、このルールに一致します。"
    },
    {
      "indent": 7,
      "text": "<rule name=\"empty-label\">\n    <start/>\n    <end/>\n</rule>",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Conceptually, whole label rules evaluate the label as a whole, but in practice, many rules do not actually need to be specified to match the entire label. For example, to express a requirement of not starting a label with a digit, a rule needs to describe only the initial part of a label.",
      "ja": "概念的には、ラベル全体のルールは、全体としてラベルを評価するが、実際には、多くのルールは、実際にラベル全体と一致するように指定する必要はありません。例えば、数字でラベルを開始しないという要件を表現するために、ルールはラベルのみ最初の部分を記述する必要があります。"
    },
    {
      "indent": 3,
      "text": "This example uses the previously defined rules, together with \"start\" and \"end\" elements, to define a rule that requires that an entire label be well-formed. For this example, that means that it must start with a letter and that it contains no leading digits or combining marks nor combining marks placed on digits.",
      "ja": "この例では、ラベル全体が整形式であることを必要とするルールを定義するために、一緒に「開始」および「終了」要素と、以前に定義されたルールを使用します。この例では、それはそれは文字で開始し、それは大手の数字が含まれていないか、マークを組み合わせることも数字の上に置かれたマークを組み合わせることをしなければならないことを意味します。"
    },
    {
      "indent": 7,
      "text": "<rule name=\"leading-letter\" >\n  <start />\n  <rule by-ref=\"letter-grapheme\" count=\"1\"/>\n  <choice count=\"0+\">\n    <rule by-ref=\"letter-grapheme\" count=\"0+\"/>\n    <class by-ref=\"digit\" count=\"0+\"/>\n  </choice>\n  <end />\n</rule>",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Each \"start\" or \"end\" element occurs at most once in a rule, except if nested inside a \"choice\" element in such a way that in matching each alternative at most one occurrence of each is encountered. Otherwise, the result is an error, as is any case where a \"start\" or \"end\" element is not encountered as the first or last element to be matched, respectively, in matching a rule. \"start\" and \"end\" elements are empty elements that do not have a \"count\" attribute or any other attribute other than \"comment\". It is an error for any match operator enclosing a nested \"start\" or \"end\" element to have a \"count\" attribute.",
      "ja": "それぞれ、「開始」または「終了」の要素は、それぞれの最大で1つの発生時に各選択肢のマッチングに遭遇されるように、「選択」要素内にネストされている場合を除いて、ルールに高々1回発生します。 「開始」または最初または最後の要素は、ルールを合わせて、それぞれ、一致するように、「終了」要素に遭遇していない任意の場合のようにそうでなければ、結果は、誤りです。 「開始」と「終了」の要素は、「カウント」属性や「コメント」以外の他の属性を持っていない空要素です。これは、「カウント」属性を持つように、ネストされた「終了」、「開始」または要素を囲む任意のマッチ演算子はエラーです。"
    },
    {
      "indent": 0,
      "text": "6.3.9. Example Context Rule from IDNA Specification",
      "section_title": true,
      "ja": "6.3.9.  IDNA仕様から例コンテキストルール"
    },
    {
      "indent": 3,
      "text": "This is an example of the WLE rule from [RFC5892] forbidding the mixture of the Arabic-Indic and extended Arabic-Indic digits in the same label. It is implemented as a whole label rule associated with the code point ranges using the \"not-when\" attribute, which defines an impermissible context. The example also demonstrates several instances of the use of anonymous rules for grouping.",
      "ja": "これは、同じラベルにアラビアインド拡張アラビア - インド数字の混合物を禁止[RFC5892]からWLEルールの一例です。これは、許容できないコンテキストを定義「でない場合、」属性を使用してコードポイント範囲に関連付けられたラベル全体ルールとして実装されます。例では、グループ化のための匿名の規則の使用のいくつかの例を示しています。"
    },
    {
      "indent": 7,
      "text": "<data>\n   <range first-cp=\"0660\" last-cp=\"0669\" not-when=\"mixed-digits\"\n          tag=\"arabic-indic-digits\" />\n   <range first-cp=\"06F0\" last-cp=\"06F9\" not-when=\"mixed-digits\"\n          tag=\"extended-arabic-indic-digits\" />\n</data>\n<rules>\n   <rule name=\"mixed-digits\">\n      <choice>\n        <rule>\n            <class from-tag=\"arabic-indic-digits\"/>\n            <any count=\"0+\"/>\n            <class from-tag=\"extended-arabic-indic-digits\"/>\n         </rule>\n         <rule>\n            <class from-tag=\"extended-arabic-indic-digits\"/>\n            <any count=\"0+\"/>\n            <class from-tag=\"arabic-indic-digits\"/>\n         </rule>\n      </choice>\n   </rule>\n</rules>",
      "raw": true
    },
    {
      "indent": 3,
      "text": "As specified in the example, a label containing a code point from either of the two digit ranges is invalid for any label matching the \"mixed-digits\" rule, that is, any time that a code point from the other range is also present. Note that invalidating the label is not the same as invalidating the definition of the \"range\" elements; in particular, the definition of the tag values does not depend on the \"when\" attribute.",
      "ja": "例で指定されているように、2桁の範囲のいずれかからのコードポイントを含むラベルは、「混合桁」ルールに一致するラベル、すなわち、他の範囲からコードポイントも存在している任意の時間には無効です。ラベルを無効にする「範囲」の要素の定義を無効と同じではないことに留意されたいです。具体的には、タグ値の定義は、「いつ」属性に依存しません。"
    },
    {
      "indent": 0,
      "text": "6.4. Parameterized Context or When Rules",
      "section_title": true,
      "ja": "6.4. パラメータ化されたコンテキストまたはルール"
    },
    {
      "indent": 3,
      "text": "To recap: When a rule is intended to provide a context for evaluating the validity of a code point or variant mapping, it is invoked by the \"when\" or \"not-when\" attributes described in Section 5.2. For \"char\" and \"range\" elements, an action implied by a context rule always has a disposition of \"invalid\" whenever the rule given by the \"when\" attribute is not matched (see Section 7.5). Conversely, a \"not-when\" attribute results in a disposition of \"invalid\" whenever the rule is matched. When a rule is used in this way, it is called a context or \"when\" rule.",
      "ja": "要約すると：ルールは、コード・ポイントまたは変異体のマッピングの妥当性を評価するためのコンテキストを提供することを意図している、それが「いつ」か「ない - と、」5.2節で説明した属性によって呼び出されます。ルールが「いつ」属性が一致していない（7.5節を参照）によって与えられるたびに「チャー」と「範囲」要素に対して、コンテキストルールによって暗示アクションは常に「無効」の配置を有します。逆に、「ない - とき」ルールが一致するたびに「無効」の処分で結果を属性。ルールはこのように使用されている場合、それはコンテキストまたは「」ルールと呼ばれています。"
    },
    {
      "indent": 3,
      "text": "The example in the previous section shows a whole label rule used as a context rule, essentially making the whole label the context. The next sections describe several match operators that can be used to provide a more specific specification of a context, allowing a parameterized context rule. See Section 7 for an alternative method of defining an invalid disposition for a label not matching a whole label rule.",
      "ja": "前節の例は、本質的に全体ラベルコンテキストを作成、コンテキストルールとして使用される全ラベルのルールを示しています。次のセクションでは、パラメータ化されたコンテキストルールを可能に、コンテキストのより具体的な仕様を提供するために使用できるいくつかのマッチ演算子を記載しています。ラベルは、ラベル全体のルールに一致しないため、無効な処分を定義する別の方法については、セクション7を参照してください。"
    },
    {
      "indent": 0,
      "text": "6.4.1. The \"anchor\" Element",
      "section_title": true,
      "ja": "6.4.1.  「アンカー」の要素"
    },
    {
      "indent": 3,
      "text": "Such parameterized context rules are rules that contain a special placeholder represented by an \"anchor\" element. As each When Rule is evaluated, if an \"anchor\" element is present, it is replaced by a literal corresponding to the \"cp\" attribute of the element containing the \"when\" (or \"not-when\") attribute. The match to the \"anchor\" element must be at the same position in the label as the code point or variant mapping triggering the When Rule.",
      "ja": "そのようなパラメータ化されたコンテキスト規則は「アンカー」要素によって表される特別なプレースホルダが含まれているルールです。ルールが評価される場合、「アンカー」要素が存在する場合、各として、それは「」（または「未とき」）属性を含む要素の「CP」属性に対応する文字に置き換えられています。 「アンカー」要素に一致いつルールトリガコードポイントまたは変異マッピングなどのラベルの同じ位置になければなりません。"
    },
    {
      "indent": 3,
      "text": "For example, the Greek lower numeral sign is invalid if not immediately preceding a character in the Greek script. This is most naturally addressed with a parameterized When Rule using \"look-ahead\":",
      "ja": "すぐにギリシャのスクリプト内の文字の前にいない場合たとえば、ギリシャ語の下の数字記号が無効です。これが最も自然に「先読み」を使用してパラメータ化するときのルールでアドレスです。"
    },
    {
      "indent": 7,
      "text": "<char cp=\"0375\" when=\"preceding-greek\"/>\n...\n<class name=\"greek-script\" property=\"sc:Grek\"/>\n<rule name=\"preceding-greek\">\n    <anchor/>\n    <look-ahead>\n        <class by-ref=\"greek-script\"/>\n    </look-ahead>\n</rule>",
      "raw": true
    },
    {
      "indent": 3,
      "text": "In evaluating this rule, the \"anchor\" element is treated as if it was replaced by a literal",
      "ja": "それは文字通りに置き換えられたかのように、この規則を評価するには、「アンカー」の要素が処理されます"
    },
    {
      "indent": 7,
      "text": "<char cp=\"0375\"/>",
      "ja": "<シャアのCP = \"0375\" />"
    },
    {
      "indent": 3,
      "text": "but only the instance of U+0375 at the given position is evaluated. If a label had two instances of U+0375 with the first one matching the rule and the second not, then evaluating the When Rule MUST succeed for the first instance and fail for the second.",
      "ja": "しかし、所定の位置にU + 0375のインスタンスのみが評価されます。ラベルはその後、評価ルールに一致する最初のものと第二ではない、とU + 0375の2つのインスタンスを持っていた場合、ルールは、最初のインスタンスのために成功し、第二のために失敗しなければならないとき。"
    },
    {
      "indent": 3,
      "text": "Unlike other rules, rules containing an \"anchor\" element MUST only be invoked via the \"when\" or \"not-when\" attributes on code points or variants; otherwise, their \"anchor\" elements cannot be evaluated. However, it is possible to invoke rules not containing an \"anchor\" element from a \"when\" or \"not-when\" attribute. (See Section 6.4.3.)",
      "ja": "他のルールとは異なり、「アンカー」要素を含むルールのみを介して呼び出さなければなりません「と、」または「ではない場合、」コード・ポイントまたは変異体の属性。そうでない場合は、彼らの「アンカー」の要素は評価できません。しかし、「いつ」か「ない - とき」属性から「アンカー」の要素を含まないルールを呼び出すことが可能です。 （第6.4.3項を参照してください。）"
    },
    {
      "indent": 3,
      "text": "The \"anchor\" element is an empty element, with no attributes permitted except \"comment\".",
      "ja": "「アンカー」要素は、「コメント」を除いて許可されていない属性を持つ、空の要素です。"
    },
    {
      "indent": 0,
      "text": "6.4.2. The \"look-behind\" and \"look-ahead\" Elements",
      "section_title": true,
      "ja": "6.4.2.  「ルックビハインド」と「先読み」の要素"
    },
    {
      "indent": 3,
      "text": "Context rules use the \"look-behind\" and \"look-ahead\" elements to define context before and after the code point sequence matched by the \"anchor\" element. If the \"anchor\" element is omitted, neither the \"look-behind\" nor the \"look-ahead\" element may be present in a rule.",
      "ja": "コンテキストルールは「アンカー」の要素にマッチしたコード・ポイント列の前後にコンテキストを定義するには、「背後ルック」と「先読み」の要素を使用しています。 「アンカー」の要素が省略されている場合は、どちらも「背後ルック」や「先読み」要素がルールに存在することができます。"
    },
    {
      "indent": 3,
      "text": "Here is an example of a rule that defines an \"initial\" context for an Arabic code point:",
      "ja": "ここで、アラビア語コード・ポイントは、「初期」コンテキストを定義するルールの例を示します。"
    },
    {
      "indent": 7,
      "text": "<class name=\"transparent\" property=\"jt:T\"/>\n<class name=\"right-joining\" property=\"jt:R\"/>\n<class name=\"left-joining\" property=\"jt:L\"/>\n<class name=\"dual-joining\" property=\"jt:D\"/>\n<class name=\"non-joining\" property=\"jt:U\"/>\n<rule name=\"Arabic-initial\">\n  <look-behind>\n    <choice>\n      <start/>\n      <rule>\n        <class by-ref=\"transparent\" count=\"0+\"/>\n        <class by-ref=\"non-joining\"/>\n      </rule>\n    </choice>\n  </look-behind>\n  <anchor/>\n  <look-ahead>\n    <class by-ref=\"transparent\" count=\"0+\" />\n    <choice>\n      <class by-ref=\"right-joining\" />\n      <class by-ref=\"dual-joining\" />\n    </choice>\n  </look-ahead>\n</rule>",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A \"when\" rule (or context rule) is a named rule that contains any combination of \"look-behind\", \"anchor\", and \"look-ahead\" elements, in that order. Each of these elements occurs at most once, except if nested inside a \"choice\" element in such a way that in matching each alternative at most one occurrence of each is encountered. Otherwise, the result is undefined. None of these elements takes a \"count\" attribute, nor does any enclosing match operator; otherwise, the result is undefined. If a context rule contains a \"look-ahead\" or \"look-behind\" element, it MUST contain an \"anchor\" element. If, because of a \"choice\" element, a required anchor is not actually encountered, the results are undefined.",
      "ja": "「とき」のルール（またはコンテキストルール）「ルックビハインド」、「アンカー」の任意の組み合わせが含まれているという名前のルールであり、そのために「先読み」の要素、。これらの各要素は、それぞれの最大で1つの発生時に各選択肢のマッチングに遭遇されるように、「選択」要素内にネストされている場合を除いて、ほとんど一度に起こります。そうでなければ、結果は未定義です。これらの要素はいずれも、「カウント」属性を取らず、また任意の外側のマッチ演算子を行います。そうでない場合、結果は未定義です。コンテキストルールは「先読み」や「ルックビハインド」の要素が含まれている場合、それは「アンカー」要素を含まなければなりません。 「選択」要素のため、必要なアンカーが実際に遭遇していない、場合、結果は未定義です。"
    },
    {
      "indent": 0,
      "text": "6.4.3. Omitting the \"anchor\" Element",
      "section_title": true,
      "ja": "6.4.3.  「アンカー」の要素を省略"
    },
    {
      "indent": 3,
      "text": "If the \"anchor\" element is omitted, the evaluation of the context rule is not tied to the position of the code point or sequence associated with the \"when\" attribute.",
      "ja": "「アンカー」要素が省略された場合、コンテキストルールの評価は、「いつ」属性に関連付けられたコード・ポイントまたは配列の位置に関連付けられていません。"
    },
    {
      "indent": 3,
      "text": "According to [RFC5892], the Katakana middle dot is invalid in any label not containing at least one Japanese character anywhere in the label. Because this requirement is independent of the position of the middle dot, the rule does not require an \"anchor\" element.",
      "ja": "[RFC5892]によると、カタカナ中ドットはどこでもラベルに少なくとも1つの日本語の文字を含まない任意のラベルには無効です。この要件は、中ドットの位置とは独立しているので、ルールは「アンカー」の要素を必要としません。"
    },
    {
      "indent": 7,
      "text": "<char cp=\"30FB\" when=\"japanese-in-label\"/>\n<rule name=\"japanese-in-label\">\n    <union>\n        <class property=\"sc:Hani\"/>\n        <class property=\"sc:Kata\"/>\n        <class property=\"sc:Hira\"/>\n    </union>\n</rule>",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The Katakana middle dot is used only with Han, Katakana, or Hiragana. The corresponding When Rule requires that at least one code point in the label be in one of these scripts, but the position of that code point is independent of the location of the middle dot; therefore, no anchor is required. (Note that the Katakana middle dot itself is of script Common, that is, \"sc:Zyyy\".)",
      "ja": "カタカナ中ドットのみが漢、カタカナ、またはひらがなで使用されています。ルールはラベル内の少なくとも1つのコード・ポイントは、これらのスクリプトのいずれかであってもよいが、そのコードポイントの位置は中ドットの位置とは無関係であることを必要とする場合に対応します。そのため、何のアンカーは必要ありません。 （つまり、「SC：Zyyy」、カタカナミドルドット自体は、スクリプト共通であることに注意してください。）"
    },
    {
      "indent": 0,
      "text": "7. The \"action\" Element",
      "section_title": true,
      "ja": "7.「アクション」の要素"
    },
    {
      "indent": 3,
      "text": "The purpose of an action is to assign a disposition to a label in response to being triggered by the label meeting a specified condition. Often, the action simply results in blocking or invalidating a label that does not match a rule. An example of an action invalidating a label because it does not match a rule named \"leading-letter\" is as follows:",
      "ja": "アクションの目的は、ラベル会指定の条件によってトリガされることに応答して、ラベルに処分を割り当てることです。多くの場合、アクションは、単にルールに一致しないラベルを遮断するか、無効になります。以下のように、それは「主要な文字」という名前のルールと一致しないため、ラベルを無効にする行為の例は以下のとおりです。"
    },
    {
      "indent": 7,
      "text": "<action disp=\"invalid\" not-match=\"leading-letter\"/>",
      "ja": "<アクションDISP =「無効」ではない一致=「リーディング文字」/>"
    },
    {
      "indent": 3,
      "text": "If an action is to be triggered on matching a rule, a \"match\" attribute is used instead. Actions are evaluated in the order that they appear in the XML file. Once an action is triggered by a label, the disposition defined in the \"disp\" attribute is assigned to the label and no other actions are evaluated for that label.",
      "ja": "アクションがルールに一致でトリガする場合は、「一致」属性が代わりに使用されます。アクションは、それらがXMLファイルに表示される順序で評価されます。アクションがラベルによってトリガーされると、「DISP」属性で定義された処分は、ラベルに割り当てられ、他のアクションは、そのラベルのために評価されていません。"
    },
    {
      "indent": 3,
      "text": "The goal of the LGR is to identify all labels and variant labels and to assign them disposition values. These dispositions are then fed into a further process that ultimately implements all aspects of policy. To allow this specification to be used with the widest range of policies, the permissible values for the \"disp\" attribute are neither defined nor restricted. Nevertheless, a set of commonly used disposition values is RECOMMENDED. (See Section 7.3.)",
      "ja": "LGRの目標は、すべてのラベルとバリアントのラベルを識別し、それらを処分値を割り当てることです。これらの処分は、その後、最終的にポリシーのすべての側面を実装するさらなる工程に供給されます。この仕様は、ポリシーの最も広い範囲で使用できるようにするために、「DISP」属性の許容値は、どちらも定義されていないにも制限されています。それにもかかわらず、一般的に使用される処分値のセットをお勧めします。 （7.3節を参照してください。）"
    },
    {
      "indent": 0,
      "text": "7.1. The \"match\" and \"not-match\" Attributes",
      "section_title": true,
      "ja": "7.1.  「一致」と「ないマッチ」属性"
    },
    {
      "indent": 3,
      "text": "An OPTIONAL \"match\" or \"not-match\" attribute specifies a rule that must be matched or not matched as a condition for triggering an action. Only a single rule may be named as the value of a \"match\" or \"not-match\" attribute. Because rules may be composed of other rules, this restriction to a single attribute value does not impose any limitation on the contexts that can trigger an action.",
      "ja": "オプション「一致」または「ない試合」属性が一致するか、アクションをトリガするための条件として一致していないしなければならないルールを指定します。唯一のルールは「一致」または「ないマッチ」属性の値として指定することができます。ルールが他のルールで構成されてもよいので、単一の属性値にこの制限は、アクションをトリガすることができるコンテキストにいかなる制限も課しません。"
    },
    {
      "indent": 3,
      "text": "An action MUST NOT contain both a \"match\" and a \"not-match\" attribute, and the value of either attribute MUST be the name of a previously defined rule; otherwise, the document MUST be rejected. An action without any attributes is triggered by all labels unconditionally. For a very simple LGR, the following action would allocate all labels that match the repertoire:",
      "ja": "アクションは、「一致」と「ないマッチ」属性の両方を含んではならない、とのいずれかの属性の値は、事前に定義されたルールの名前でなければなりません。そうでない場合は、文書を拒絶しなければなりません。すべての属性のないアクションは無条件ですべてのラベルによってトリガーされます。非常に単純なLGRの場合は、以下のアクションがレパートリーに一致するすべてのラベルを割り当てます："
    },
    {
      "indent": 7,
      "text": "<action disp=\"allocatable\" />",
      "ja": "<アクションDISP = \"割り当て可能\" />"
    },
    {
      "indent": 3,
      "text": "Since rules are evaluated for all labels, whether they are the original label or computed by permuting the defined and valid variant mappings for the label's code points, actions based on matching or not matching a rule may be triggered for both original and variant labels, but the rules are not affected by the disposition attributes of the variant mappings. To trigger any actions based on these dispositions requires the use of additional optional attributes for actions described next.",
      "ja": "ルールは、彼らがオリジナルのラベルされているか、ラベルのコードポイントのために定義され、有効なバリアントのマッピングを置換することにより計算するかどうか、すべてのラベルのために評価されているので、一致するかのルールに一致していないに基づいてアクションは、オリジナルとバリアントの両方のラベルにトリガすることができるが、ルールは、変異型のマッピングの配置属性の影響を受けません。これらの処分に基づいて任意のアクションをトリガするには、次の記述の行動のための追加のオプション属性を使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "7.2. Actions with Variant Type Triggers",
      "section_title": true,
      "ja": "7.2. バリアント型のトリガーとアクション"
    },
    {
      "indent": 0,
      "text": "7.2.1. The \"any-variant\", \"all-variants\", and \"only-variants\" Attributes",
      "ja": "7.2.1.  「任意のバリアント」、「全変異体」、および「唯一の変種」属性"
    },
    {
      "indent": 3,
      "text": "An action may contain one of the OPTIONAL attributes \"any-variant\", \"all-variants\", or \"only-variants\" defining triggers based on variant types. The permitted value for these attributes consists of one or more variant type values, separated by spaces. These MAY include type values that are not used in any \"var\" element in the LGR. When a variant label is generated, these variant type values are compared to the set of type values on the variant mappings used to generate the particular variant label (see Section 8).",
      "ja": "アクションは、オプションの属性「任意のバリアント」、「すべての変種」、またはバリアント型に基づいてトリガを定義する「だけ-変異体」の1含まれていてもよいです。これらの属性の許容値は、スペースで区切られた1つ以上の変異型の値からなります。これらは、LGRのいずれかの「VAR」の要素で使用されていないタイプの値を含んでいてもよいです。変異ラベルが生成されると、これらの変異型の値は、特定の変異体ラベルを生成するために使用される変異のマッピング上のタイプの値のセットと比較される（セクション8を参照）。"
    },
    {
      "indent": 3,
      "text": "Any single match may trigger an action that contains an \"any-variant\" attribute, while for an \"all-variants\" or \"only-variants\" attribute, the variant type for all variant code points must match one or several of the type values specified in the attribute to trigger the action. There is no requirement that the entire list of variant type values be matched, as long as all variant code points match at least one of the values.",
      "ja": "「全変異体」または「のみ、バリアント」属性について、すべてのバリアントコードポイントのバリアント型は、型の値のいずれかまたは複数と一致している必要がありながら、任意の単一のマッチは、「任意のバリアント」属性が含まれているアクションをトリガーすることがありアクションをトリガーする属性で指定されました。バリアント型の値のリスト全体を一致させる必要は限り、すべての変異体のコードポイントは値の少なくとも1つに一致するように、存在しません。"
    },
    {
      "indent": 3,
      "text": "An \"only-variants\" attribute will trigger the action only if all code points of the variant label have variant mappings from the original code points. In other words, the label contains no original code points other than those with a reflexive mapping (see Section 5.3.4).",
      "ja": "「唯一の変種」属性は、バリアントラベルのすべてのコードポイントは、元のコード・ポイントからのバリアントのマッピングを持っている場合にのみ、アクションをトリガーします。換言すれば、ラベルは再帰マッピングを有するもの以外の元のコードポイントが含まれていない（セクション5.3.4を参照）。"
    },
    {
      "indent": 7,
      "text": "<char cp=\"0078\" comment=\"x\">\n    <var cp=\"0078\" type=\"allocatable\" comment=\"reflexive\" />\n    <var cp=\"0079\" type=\"blocked\" />\n</char>\n<char cp=\"0079\" comment=\"y\">\n    <var cp=\"0078\" type=\"allocatable\" />\n</char>\n...\n<action disp=\"blocked\" any-variant=\"blocked\" />\n<action disp=\"allocatable\" only-variants=\"allocatable\" />\n<action disp=\"some-disp\" any-variant=\"allocatable\" />",
      "raw": true
    },
    {
      "indent": 3,
      "text": "In the example above, the label \"xx\" would have variant labels \"xx\", \"xy\", \"yx\", and \"yy\". The first action would result in blocking any variant label containing \"y\", because the variant mapping from \"x\" to \"y\" is of type \"blocked\", triggering the \"any-variant\" condition. Because in this example \"x\" has a reflexive variant mapping to itself of type \"allocatable\", the original label \"xx\" has a reflexive variant \"xx\" that would trigger the \"only-variants\" condition on the second action.",
      "ja": "上記の例では、ラベルは、バリアントのラベルを持つことになり、「XX」、「XY」、「YX」、および「YY」を「XX」。 「X」からの変異のマッピングに「Y」が「任意バリアント」状態をトリガ、「ブロック」型であるため、最初のアクションは、「Y」を含む任意の変異体ラベルをブロッキングをもたらすであろう。この例では、「x」は「割り当て可能」タイプの自分自身への再帰バリアントマッピングを持っているので、オリジナルのラベル「xx」は2番目のアクションに「唯一の変種」の条件をトリガーする反射的変種「XX」を持っています。"
    },
    {
      "indent": 3,
      "text": "A label \"yy\" would have the variants \"xy\", \"yx\", and \"xx\". Because the variant mapping from \"y\" to \"x\" is of type \"allocatable\" and a mapping from \"y\" to \"y\" is not defined, the labels \"xy\" and \"yx\" trigger the \"any-variant\" condition on the third label. The variant \"xx\", being generated using the mapping from \"y\" to \"x\" of type \"allocatable\", would trigger the \"only-variants\" condition on the section action. As there is no reflexive variant \"yy\", the original label \"yy\" cannot trigger any variant type triggers. However, it could still trigger an action defined as matching or not matching a rule.",
      "ja": "ラベル「yyは」変異体「XY」、「YX」、および「XX」を持っているでしょう。なぜなら、「Y」を「Y」に定義されていない、ラベル「X-Y」と「任意のバリアントを」トリガー「YX」状態から「Y」に「X」型である「割り当て」とマッピングから変異のマッピング第三ラベルに。タイプの「X」と「Y」からのマッピングを使用して生成される変異体「XX」、「割り当て」は、セクションアクションの「のみ、変異体」状態をトリガします。無反射的変種「YY」がないため、オリジナルのラベル「YY」は、任意のバリアント型のトリガーをトリガーすることはできません。しかし、それはまだ一致するかのルールに一致しないものとして定義されたアクションを引き起こす可能性があります。"
    },
    {
      "indent": 3,
      "text": "In each action, one variant type trigger may be present by itself or in conjunction with an attribute matching or not matching a rule. If variant triggers and rule-matching triggers are used together, the label MUST \"match\" or respectively \"not-match\" the specified rule AND satisfy the conditions on the variant type values given by the \"any-variant\", \"all-variants\", or \"only-variants\" attribute.",
      "ja": "各アクションで、一変形型トリガそれ自体で、または一致またはルールに一致しない属性と一緒に存在してもよいです。変異トリガーとルール一致トリガを併用する場合、ラベルは「一致」又はそれぞれ「不一致」指定されたルールなければならず、「全変異体「は、任意のバリアント」によって指定されたバリアント型の値に条件を満たし」、または 『のみ、バリアント』属性。"
    },
    {
      "indent": 3,
      "text": "A useful convention combines the \"any-variant\" trigger with reflexive variant mappings (Section 5.3.4). This convention is used, for example, when multiple LGRs are defined within the same registry and for overlapping repertoire. In some cases, the delegation of a label from one LGR must prohibit the delegation of another label in some other LGR. This can be done using a variant of type \"blocked\" as in this example from an Armenian LGR, where the Armenian, Latin, and Cyrillic letters all look identical:",
      "ja": "便利な規則は、再帰バリアントマッピング（5.3.4）で「すべてのバリアント」トリガーを兼ね備えています。複数LGRsを同じレジストリ内及びレパートリーを重複のために定義されている場合、この規則は、例えば、使用されます。いくつかのケースでは、1つのLGRからラベルの代表団は、他のいくつかのLGRに別のラベルの委任を禁止しなければなりません。これはアルメニア語、ラテン語、およびキリル文字はすべて同じに見えるアルメニアLGR、からこの例のように「ブロック」タイプのバリアントを使用して行うことができます。"
    },
    {
      "indent": 7,
      "text": "<char cp=\"0570\" comment=\"ARMENIAN SMALL LETTER HO\">\n  <var cp=\"0068\" type=\"blocked\" comment=\"LATIN SMALL LETTER H\" />\n  <var cp=\"04BB\" type=\"blocked\"\n       comment=\"CYRILLIC SMALL LETTER SHHA\" />\n</char>",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The issue is that the target code points for these two variants are both outside the Armenian repertoire. By using a reflexive variant with the following convention:",
      "ja": "問題は、これらの二つの変形のためのターゲット・コード・ポイントはアルメニアレパートリー外の両方であるということです。次の規則で反射的バリアントを使用することにより："
    },
    {
      "indent": 7,
      "text": "<char cp=\"0068\" comment=\"not part of repertoire\">\n  <var cp=\"0068\" type=\"out-of-repertoire-var\"\n       comment=\"reflexive mapping\" />\n  <var cp=\"04BB\" type=\"blocked\" />\n  <var cp=\"0570\" type=\"blocked\" />\n</char>\n  ...",
      "raw": true
    },
    {
      "indent": 3,
      "text": "and associating this with an action of the form:",
      "ja": "そして、フォームのアクションでこれを関連付けます："
    },
    {
      "indent": 7,
      "text": "<action disp=\"invalid\" any-variant=\"out-of-repertoire-var\" />",
      "ja": "<アクションDISP = \"無効\" 任意のバリアント= \"アウト・オブ・レパートリー-VAR\" />"
    },
    {
      "indent": 3,
      "text": "it is possible to list the symmetric and transitive variant mappings in the LGR even where they involve out-of-repertoire code points. By associating the action shown with the special type for these reflexive mappings, any original labels containing one or more of the out-of-repertoire code points are filtered out, just as if these code points had not been listed in the LGR in the first place. Nevertheless, they do participate in the permutation of variant labels for n-repertoire labels (Armenian in the example), and these permuted variants can be used to detect collisions with out-of-repertoire labels (see Section 8).",
      "ja": "彼らが外のレパートリーコードポイントを伴う場合であってもLGRに対称と推移バリアントのマッピングを一覧表示することが可能です。これらの再帰マッピングのための特別なタイプで示すアクションを関連付けることによって、アウト・オブ・レパートリーコードポイントの一つ以上を含む任意のオリジナルラベルは、これらのコードポイントが最初にLGRにリストされていなかったかのように、除外され場所。それにもかかわらず、彼らは（この例でアルメニア）のn-レパートリーラベルのバリアントラベルの順列に参加しないと、これらの並べ替えの変異体は、アウト・オブ・レパートリーラベル（セクション8を参照）との衝突を検出するために使用することができます。"
    },
    {
      "indent": 1,
      "text": "7.2.2. Example from Tables in the Style of",
      "section_title": true,
      "ja": "7.2.2. のスタイルのテーブルからの例"
    },
    {
      "indent": 3,
      "text": "This section gives an example of using variant type triggers, combined with variants with reflexive mappings (Section 5.3.4), to achieve LGRs that implement tables like those defined according to [RFC3743] where the goal is to allow as variants only labels that consist entirely of simplified or traditional variants, in addition to the original label.",
      "ja": "このセクションでは、目標は構成さだけラベル変種として可能にすることである[RFC3743]に従って定義されたもののようなテーブルを実装LGRsを達成するために、再帰マッピング（5.3.4項）を有する変異体と組み合わせた変異型トリガを使用する例を与えます完全に簡略化や伝統的な変種の、オリジナルのラベルに加えてインチ"
    },
    {
      "indent": 3,
      "text": "This example assumes an LGR where all variants have been given suitable \"type\" attributes of \"blocked\", \"simplified\", \"traditional\", or \"both\", similar to the ones discussed in Appendix B. Given such an LGR, the following example actions evaluate the disposition for the variant label:",
      "ja": "この例では、全ての変異体は、「ブロック」の適切な「タイプ」属性が与えられているLGRは、「簡略」前提「伝統的な」、または「両方」は、LGR考える付録Bで説明したものと同様、以下例のアクションは、バリアントラベルの配置を評価します："
    },
    {
      "indent": 7,
      "text": "<action disp=\"blocked\" any-variant=\"blocked\" />\n<action disp=\"allocatable\" only-variants=\"simplified both\" />\n<action disp=\"allocatable\" only-variants=\"traditional both\" />\n<action disp=\"blocked\" all-variants=\"simplified traditional\" />\n<action disp=\"allocatable\" />",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The first action matches any variant label for which at least one of the code point variants is of type \"blocked\". The second matches any variant label for which all of the code point variants are of type \"simplified\" or \"both\" -- in other words, an all-simplified label. The third matches any label for which all variants are of type \"traditional\" or \"both\" -- that is, all traditional. These two actions are not triggered by any variant labels containing some original code points, unless each of those code points has a variant defined with a reflexive mapping (Section 5.3.4).",
      "ja": "最初のアクションは、コードポイント変異体の少なくとも一方が「ブロック」型のものである任意の変種のラベルと一致します。換言すれば、全ての簡略ラベル - 第二は、コード点変異体の全てのタイプの「単純化された」または「両方」であるため、任意の変異体ラベルと一致します。つまり、すべての伝統的 - 第三は、全ての変異体タイプの「伝統的な」または「両方」であるために任意のラベルと一致します。これら二つのアクションは、それらのコードポイントの各々が反射的マッピング（5.3.4項）で定義された変異体を持っていない限り、いくつかの元のコードポイントを含む任意の変異体ラベルによってトリガされません。"
    },
    {
      "indent": 3,
      "text": "The final two actions rely on the fact that actions are evaluated in sequence and that the first action triggered also defines the final disposition for a variant label (see Section 7.4). They further rely on the assumption that the only variants with type \"both\" are also reflexive variants.",
      "ja": "最後の二つのアクションは、アクションが順番にし、最初のアクションもトリガーバリアントラベル（7.4節を参照）ため、最終的な処分を規定していると評価されているという事実に依存しています。彼らは、さらにまた、反射的変異体である「両方」のタイプを持つ唯一の変種という仮定に依存しています。"
    },
    {
      "indent": 3,
      "text": "Given these assumptions, any remaining simplified or traditional variants must then be part of a mixed label and so are blocked; all labels surviving to the last action are original code points only (that is, the original label). The example assumes that an original label may be a mixed label; if that is not the case, the disposition for the last action would be set to \"blocked\".",
      "ja": "これらの仮定を考えると、残りの簡略化や伝統的な変異体は、ついで混合ラベルの一部でなければならないので、ブロックされています。最後のアクションに生き残ったすべてのラベルは、元のコード・ポイント（つまり、オリジナルのラベルです）です。例では、元のラベルが混在ラベルであってもよいことを想定します。それがない場合は、最後のアクションのための処分は、「ブロック」に設定されます。"
    },
    {
      "indent": 3,
      "text": "There are exceptions where the assumption on reflexive mappings made above does not hold, so this basic scheme needs some refinements to cover all cases. For a more complete example, see Appendix B.",
      "ja": "そこ上記製の再帰マッピングの仮定が成立しない例外があるので、この基本的なスキームは、すべてのケースをカバーするためにいくつかの改良が必要です。より完全な例については、付録Bを参照してください。"
    },
    {
      "indent": 0,
      "text": "7.3. Recommended Disposition Values",
      "section_title": true,
      "ja": "7.3. 推奨処分値"
    },
    {
      "indent": 3,
      "text": "The precise nature of the policy action taken in response to a disposition and the name of the corresponding \"disp\" attributes are only partially defined here. It is strongly RECOMMENDED to use the following dispositions only in their conventional sense.",
      "ja": "配置に対応して取られた政策行動の正確な性質とそれに対応する「DISP」の属性の名前は、部分的にしかここで定義されています。強くのみ、その従来の意味で、次の処分を使用することを推奨します。"
    },
    {
      "indent": 3,
      "text": "invalid The resulting string is not a valid label. This disposition may be assigned implicitly; see Section 7.5. No variant labels should be generated from a variant mapping with this type.",
      "ja": "結果の文字列が有効なラベルではありません無効。この配置は、暗黙的に割り当ててもよいです。 7.5節を参照してください。いいえバリアントラベルは、このタイプの変種マッピングから生成されるべきではありません。"
    },
    {
      "indent": 3,
      "text": "blocked The resulting string is a valid label but should be blocked from registration. This would typically apply for a derived variant that is undesirable due to having no practical use or being confusingly similar to some other label.",
      "ja": "結果の文字列が有効なラベルですが、登録からブロックされるべきブロックされました。これは、一般的により実用的な用途を有していないか、他のいくつかのラベルと紛らわしいことに望ましくない派生バリアントのために適用されます。"
    },
    {
      "indent": 3,
      "text": "allocatable The resulting string should be reserved for use by the same operator of the origin string but not automatically allocated for use.",
      "ja": "割り当て結果の文字列は起源列の同一のオペレータによって使用するために予約が、自動的に使用するために割り当てられていないしなければなりません。"
    },
    {
      "indent": 3,
      "text": "activated The resulting string should be activated for use. (This is the same as a Preferred Variant [RFC3743].)",
      "ja": "結果の文字列を使用するために有効にする必要があります活性化しました。 （これは、好ましい変形[RFC3743]と同じです。）"
    },
    {
      "indent": 3,
      "text": "valid The resultant string is a valid label. (This is the typical default action if no dispositions are defined.)",
      "ja": "有効な結果の文字列は有効なラベルです。 （何の処分が定義されていない場合、これは、一般的なデフォルトのアクションです。）"
    },
    {
      "indent": 0,
      "text": "7.4. Precedence",
      "section_title": true,
      "ja": "7.4. 順位"
    },
    {
      "indent": 3,
      "text": "Actions are applied in the order of their appearance in the file. This defines their relative precedence. The first action triggered by a label defines the disposition for that label. To define the order of precedence, list the actions in the desired order. The conventional order of precedence for the actions defined in Section 7.3 is \"invalid\", \"blocked\", \"allocatable\", \"activated\", and then \"valid\". This default precedence is used for the default actions defined in Section 7.6.",
      "ja": "アクションは、ファイル内の出現順に適用されます。これは、それらの相対的な優先度を定義します。ラベルによってトリガ最初のアクションは、そのラベルの配置を定義します。優先順位を定義するには、所望の順序でアクションをリストします。 7.3節で定義されているアクションの優先従来の順序が「無効」である、「ブロック」、「割り当て可能」、「活性化」し、「有効」。このデフォルトの優先順位は、7.6節で定義されたデフォルトのアクションのために使用されています。"
    },
    {
      "indent": 0,
      "text": "7.5. Implied Actions",
      "section_title": true,
      "ja": "7.5. 暗黙のアクション"
    },
    {
      "indent": 3,
      "text": "The context rules on code points (\"not-when\" or \"when\" rules) carry an implied action with a disposition of \"invalid\" (not eligible) if a \"when\" context is not satisfied or a \"not-when\" context is matched, respectively. These rules are evaluated at the time the code points for a label or its variant labels are checked for validity (see Section 8). In other words, they are evaluated before any of the actions are applied, and with higher precedence. The context rules for variant mappings are evaluated when variants are generated and/or when variant tables are made symmetric and transitive. They have an implied action with a disposition of \"invalid\", which means that a putative variant mapping does not exist whenever the given context matches a \"not-when\" rule or fails to match a \"when\" rule specified for that mapping. The result of that disposition is that the variant mapping is ignored in generating variant labels and the value is therefore not accessible to trigger any explicit actions.",
      "ja": "もし「いつ」は、文脈が満たされていないか「未とき」コンテキストコードポイントのコンテキストルール（「未場合」または「」ルール）が「無効」（対象外）の配置と暗黙の行動を運びますそれぞれ、一致しています。これらのルールは、ラベルまたはその変異ラベルのコードポイントが有効性をチェックしている時に評価されている（セクション8を参照）。言い換えれば、彼らは、アクションのいずれかが適用される前に評価し、優先順位の高いされています。変異体が生成されるとき、および/またはバリアントテーブルが対称と推移行われたときにバリアントマッピングのコンテキストルールが評価されます。彼らは、指定されたコンテキストが「ない - と、」ルールに一致するか、そのマッピングに指定された「とき」のルールに一致するように失敗したときに推定される変異型のマッピングが存在しないことを意味し、「無効」の処分との暗黙のアクションを、持っています。その処分の結果は、変異体マッピングがバリアントのラベルを生成する際に無視され、値はそのための明示的なアクションをトリガするのにアクセスできないことです。"
    },
    {
      "indent": 3,
      "text": "Note that such non-existing variant mapping is different from a blocked variant, which is a variant code point mapping that exists but results in a label that may not be allocated.",
      "ja": "このような非存在バリアントマッピングが割り当てられないことがあり、ラベルに結果に過ぎない存在バリアントコードポイントマッピングである遮断変異体とは異なることに留意されたいです。"
    },
    {
      "indent": 0,
      "text": "7.6. Default Actions",
      "section_title": true,
      "ja": "7.6. デフォルトのアクション"
    },
    {
      "indent": 3,
      "text": "If a label does not trigger any of the actions defined explicitly in the LGR, the following implicitly defined default actions are evaluated. They are shown below in their relative order of precedence (see Section 7.4). Default actions have a lower order of precedence than explicit actions (see Section 8.3).",
      "ja": "ラベルはLGRで明示的に定義されたアクションのいずれかをトリガしていない場合は、以下の暗黙的に定義されたデフォルトのアクションが評価されます。それらは優先順位のそれらの相対的な順序で以下に示されている（セクション7.4を参照）。デフォルトのアクションは、明示的なアクション（8.3節を参照）よりも優先の下位を持っています。"
    },
    {
      "indent": 3,
      "text": "The default actions for variant labels are defined as follows. The first set is triggered based on the standard variant type values of \"invalid\", \"blocked\", \"allocatable\", and \"activated\":",
      "ja": "次のようにバリアントのラベルのデフォルトのアクションが定義されています。最初のセットは、「割り当て」、及び「活性化」、「無効」、「ブロック」の標準バリアントタイプの値に基づいてトリガされます。"
    },
    {
      "indent": 7,
      "text": "<action disp=\"invalid\" any-variant=\"invalid\"/>\n<action disp=\"blocked\" any-variant=\"blocked\"/>\n<action disp=\"allocatable\" any-variant=\"allocatable\"/>\n<action disp=\"activated\" all-variants=\"activated\"/>",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A final default action sets the disposition to \"valid\" for any label matching the repertoire for which no other action has been triggered. This \"catch-all\" action also matches all remaining variant labels from variants that do not have a type value.",
      "ja": "最後のデフォルトのアクションは、他のアクションがトリガされないされたレパートリーをマッチング任意のラベルのための「有効」に配置を設定します。この「キャッチオール」のアクションもタイプ値を持たない変種から残りのすべてのバリエーションラベルと一致します。"
    },
    {
      "indent": 7,
      "text": "<action disp=\"valid\" comment=\"Catch-all if other rules not met\"/>",
      "ja": "<アクションDISP =「有効」コメント=「キャッチ他のすべてのルールが満たされていない場合は」/>"
    },
    {
      "indent": 3,
      "text": "Conceptually, the implicitly defined default actions act just like a block of \"action\" elements that is added (virtually) beyond the last of the user-supplied actions. Any label not processed by the user-supplied actions would thus be processed by the default actions as if they were present in the LGR. As the last default action is a \"catch-all\", all processing is guaranteed to end with a definite disposition for the label.",
      "ja": "概念的には、暗黙的に定義されたデフォルトのアクションは、単にユーザーが提供するアクションの最後を超えて（事実上）追加され、「アクション」の要素のブロックのように振る舞います。彼らはLGR中に存在していたかのようにユーザが提供するアクションで処理されていない任意のラベルは、このようにデフォルトのアクションによって処理されるだろう。最後のデフォルトのアクションは、「キャッチオール」であるため、すべての処理は、ラベルのための明確な処分で終わることが保証されます。"
    },
    {
      "indent": 0,
      "text": "8. Processing a Label against an LGR",
      "section_title": true,
      "ja": "8. LGRに対するラベルの処理"
    },
    {
      "indent": 0,
      "text": "8.1. Determining Eligibility for a Label",
      "section_title": true,
      "ja": "8.1. ラベルのための資格の決定"
    },
    {
      "indent": 3,
      "text": "In order to test a given label for membership in the LGR, a consumer of the LGR must iterate through each code point within a given label and test that each instance of a code point is a member of the LGR. If any instance of a code point is not a member of the LGR, the label shall be deemed invalid.",
      "ja": "LGRのメンバーに与えられたラベルをテストするために、LGRの消費者は、コードポイントの各インスタンスはLGRのメンバーであり、所与の標識および試験内の各コードポイントを反復しなければなりません。コードポイントの任意のインスタンスは、LGRのメンバーでない場合、ラベルは無効とみなします。"
    },
    {
      "indent": 3,
      "text": "An individual instance of a code point is deemed a member of the LGR when it is listed using a \"char\" element, or is part of a range defined with a \"range\" element, and all necessary conditions in any \"when\" or \"not-when\" attributes are correctly satisfied for that instance.",
      "ja": "コードポイントの個々のインスタンスは、「それは「チャー」要素を使用して記載されている場合LGRのメンバーとみなさ、または「範囲」要素で定義された範囲の一部であり、任意に必要なすべての条件「が」またはさない - とき」属性が正しく、そのインスタンスのために満足しています。"
    },
    {
      "indent": 3,
      "text": "Alternatively, an instance of a code point is also deemed a member of the LGR when it forms part of a sequence that corresponds to a sequence listed using a \"char\" element for which the \"cp\" attribute defines a sequence, and all necessary conditions in any \"when\" or \"not-when\" attributes are correctly satisfied for that instance of the sequence.",
      "ja": "あるいは、コード・ポイントのインスタンスはまた、「CP」属性は、シーケンスを定義するための「チャー」要素を使用して列挙された配列に対応する配列の一部を形成するLGRのメンバー、およびすべての必要条件であると考えられます任意の「とき」または「ない - とき」に属性が正しく配列のインスタンスのために満足しています。"
    },
    {
      "indent": 3,
      "text": "In determining eligibility, at each position the longest possible sequence of code points is evaluated first. If that sequence matches a sequence defined in the LGR and satisfies any required context at that position, the instances of its constituent code points are deemed members of the LGR and evaluation proceeds with the next code point following the sequence. If the sequence does not match a defined sequence or does not satisfy the required context, successively shorter sequences are evaluated until only a single code point remains. The eligibility of that code point is determined as described above for an individual code point instance.",
      "ja": "適格性を決定する際に、各位置でのコード・ポイントの最長の可能なシーケンスが最初に評価されます。その配列は、LGRを満たすその位置に必要なコンテキストで定義された配列と一致した場合、それを構成するコード・ポイントのインスタンスは、シーケンスの次のコードポイントとLGRと評価進行のメンバーとみなされています。シーケンスが定義された順序と一致していないか、必要なコンテキストを満たしていない場合のみ、単一のコードポイントが残るまで、連続的により短い配列が評価されています。個々のコードポイント、例えば、上記のように、そのコードポイントの適格性が決定されます。"
    },
    {
      "indent": 3,
      "text": "A label must also not trigger any action that results in a disposition of \"invalid\"; otherwise, it is deemed not eligible. (This step may need to be deferred until variant code point dispositions have been determined.)",
      "ja": "ラベルはまた、「無効」の処分をもたらす任意のアクションをトリガしてはなりません。それ以外の場合は対象外とみなされます。 （このステップは、バリアントコードポイント処分が決定されるまで延期される必要があるかもしれません。）"
    },
    {
      "indent": 0,
      "text": "8.1.1. Determining Eligibility Using Reflexive Variant Mappings",
      "section_title": true,
      "ja": "8.1.1. 再帰バリアントマッピングを使用した資格の決定"
    },
    {
      "indent": 3,
      "text": "For LGRs that contain reflexive variant mappings (defined in Section 5.3.4), the final evaluation of eligibility for the label must be deferred until variants are generated. In essence, LGRs that use this feature treat the original label as the (identity) variant of itself. For such LGRs, the ordinary determination of eligibility described here is but a first step that generally excludes only a subset of invalid labels.",
      "ja": "変異体が生成されるまで（5.3.4項で定義された）再帰バリアントマッピングを含むLGRsするために、ラベルの資格の最終評価を延期しなければなりません。本質的には、この機能を使用LGRsは、自身の（アイデンティティ）の変異体として、オリジナルラベルを扱います。そのようなLGRsために、ここで説明した資格の通常の決意は、一般的に無効ラベルのサブセットのみを除外する最初のステップに過ぎません。"
    },
    {
      "indent": 3,
      "text": "To further check the validity of a label with reflexive mappings, it is not necessary to generate all variant labels. Only a single variant needs to be created, where any reflexive variants are applied for each code point, and the label disposition is evaluated (as described in Section 8.3). A disposition of \"invalid\" results in the label being not eligible. (In the exceptional case where context rules are present on reflexive mappings, multiple reflexive variants may be defined, but for each original label, at most one of these can be valid at each code position. However, see Section 8.4.)",
      "ja": "さらに反射的マッピングでラベルの有効性を確認するために、すべてのバリエーションラベルを生成する必要はありません。単一の変異体は、任意の再帰変異体は、各コードポイントに適用される場合、作成する必要があり、（8.3節に記載されているように）ラベル配置が評価されます。 「無効」の結果の処分は、ラベルには資格がないという。 （コンテキストルールは再帰マッピングに存在している例外的な場合では、複数の再帰的変異体は、定義されてもよいが、各オリジナルラベル、これらの多くても1つは、各コード位置で有効であることができる。しかし、8.4節を参照します。）"
    },
    {
      "indent": 0,
      "text": "8.2. Determining Variants for a Label",
      "section_title": true,
      "ja": "8.2. ラベルのためのバリアントを決定"
    },
    {
      "indent": 3,
      "text": "For a given eligible label, the set of variant labels is deemed to consist of each possible permutation of original code points and substituted code points or sequences defined in \"var\" elements, whereby all \"when\" and \"not-when\" attributes are correctly satisfied for each \"char\" or \"var\" element in the given permutation and all applicable whole label rules are satisfied as follows:",
      "ja": "所与の対象ラベルに、変異体ラベルのセットは、「VAR」の要素、それによってすべての「a」および「未場合」属性がある正確に定義された元のコードポイントと置換されたコードポイントまたは配列の各々の可能な順列から成ると考えられます次のように与えられた順列と、該当するすべてのラベル全体のルール内の各「文字」または「VAR」要素の満足は満たされています："
    },
    {
      "indent": 3,
      "text": "1. Create each possible permutation of a label by substituting each code point or code point sequence in turn by any defined variant mapping (including any reflexive mappings).",
      "ja": "1.（任意再帰マッピングを含む）任意の定義された変異型マッピングによって順番に各コードポイントまたはコードポイント配列を置換することにより、ラベルのそれぞれの可能な順列を作成します。"
    },
    {
      "indent": 3,
      "text": "2. Apply variant mappings with \"when\" or \"not-when\" attributes only if the conditions are satisfied; otherwise, they are not defined.",
      "ja": "2.の条件が満たされた場合にのみ、属性が「いつ」か「ない - とき」とバリアントのマッピングを適用します。そうでない場合は、それらが定義されていません。"
    },
    {
      "indent": 3,
      "text": "3. Record each of the \"type\" values on the variant mappings used in creating a given variant label in a disposition set; for any unmapped code point, record the \"type\" value of any reflexive variant (see Section 5.3.4).",
      "ja": "3.録音配置セットに与えられた変異体ラベルを作成する際に使用される変異のマッピングの「タイプ」値の各;任意のマップされていないコードポイントのために、任意の再帰的変異体の「タイプ」値を記録する（セクション5.3.4を参照）。"
    },
    {
      "indent": 3,
      "text": "4. Determine the disposition for each variant label per Section 8.3.",
      "section_title": true,
      "ja": "4.セクション8.3あたりの各バリアントのラベルの配置を決定します。"
    },
    {
      "indent": 3,
      "text": "5. If the disposition is \"invalid\", remove the label from the set.",
      "section_title": true,
      "ja": "5.処分が「無効」である場合は、セットからラベルを削除します。"
    },
    {
      "indent": 3,
      "text": "6. If final evaluation of the disposition for the unpermuted label per Section 8.3 results in a disposition of \"invalid\", remove all associated variant labels from the set.",
      "ja": "6.セクションごとunpermutedラベル「無効」の処分で8.3結果のための処分の最終評価した場合、セットから、関連するすべてのバリエーションラベルを削除します。"
    },
    {
      "indent": 3,
      "text": "The number of potential permutations can be very large. In practice, implementations would use suitable optimizations to avoid having to actually create all permutations (see Section 8.5).",
      "ja": "潜在的な順列の数は非常に大きくなることがあります。実際には、実装は実際にすべての順列（セクション8.5を参照）を作成することを避けるために、適切な最適化を使用します。"
    },
    {
      "indent": 3,
      "text": "In determining the permuted set of variant labels in step (1) above, all eligible partitions into sequences must be evaluated. A label \"ab\" that matches a sequence \"ab\" defined in the LGR but also matches the sequence of individual code points \"a\" and \"b\" (both defined in the LGR) must be permuted using any defined variant mappings for both the sequence \"ab\" and the code points \"a\" and \"b\" individually.",
      "ja": "ステップにおける変異ラベルの順列セットを決定する際に、上記（1）配列へのすべての適格なパーティションが評価されなければなりません。またLGRで定義された配列「AB」と一致するが、ラベル「AB」は、個々のコードポイントのシーケンスに一致「a」および「b」（いずれもLGRで定義されている）の両方のために、任意の定義されたバリアントマッピングを使用して置換する必要があります配列「AB」とコードポイント個々に「a」および「b」。"
    },
    {
      "indent": 0,
      "text": "8.3. Determining a Disposition for a Label or Variant Label",
      "section_title": true,
      "ja": "8.3. ラベルまたはバリアントラベルのための処分を決定"
    },
    {
      "indent": 3,
      "text": "For a given label (variant or original), its disposition is determined by evaluating, in order of their appearance, all actions for which the label or variant label satisfies the conditions.",
      "ja": "与えられたラベル（変異体または元）のために、その配置は、その外観のために、ラベルまたは変異体ラベルが条件を満たしているすべてのアクションを評価することによって決定されます。"
    },
    {
      "indent": 3,
      "text": "1. For any label that contains code points or sequences not defined in the repertoire, or does not satisfy the context rules on all of its code points and variants, the disposition is \"invalid\".",
      "ja": "レパートリーで定義されていないコードポイントまたは配列を含む、または処分が「無効」で、そのコードポイントとバリアントのすべてのコンテキストルールを満たしていない任意のラベル1.。"
    },
    {
      "indent": 3,
      "text": "2. For all other labels, the disposition is given by the value of the \"disp\" attribute for the first action triggered by the label. An action is triggered if all of the following are true:",
      "ja": "他のすべてのラベルの2は、処分はラベルによってトリガ最初のアクションのための「DISP」属性の値で与えられます。次のすべてに該当する場合、アクションがトリガーされます。"
    },
    {
      "indent": 7,
      "text": "*  the label matches the whole label rule given in the \"match\"\n   attribute for that action;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "* the label does not match the whole label rule given in the \"not-match\" attribute for that action;",
      "ja": "*ラベルは、そのアクションのため「ではない試合」属性で指定したラベル全体のルールと一致していません。"
    },
    {
      "indent": 7,
      "text": "* any of the recorded variant types for a variant label match the types given in the \"any-variant\" attribute for that action;",
      "ja": "*バリエーションラベルの記録バリアント型のいずれかは、そのアクションの「任意のバリアント」属性で指定したタイプに一致します。"
    },
    {
      "indent": 7,
      "text": "* all of the recorded variant types for a variant label match the types given in the \"all-variants\" or \"only-variants\" attribute given for that action;",
      "ja": "*バリエーションラベルの記録バリアントタイプのすべては、そのアクションのために与えられた「全変異体」または「唯一の変種」属性で指定したタイプに一致します。"
    },
    {
      "indent": 7,
      "text": "* in case of an \"only-variants\" attribute, the label contains only code points that are the target of applied variant mappings;",
      "ja": "*「のみ、バリアント」属性の場合には、ラベルが適用される変異型のマッピングの対象とされている唯一のコードポイントが含まれています。"
    },
    {
      "indent": 7,
      "text": "or",
      "ja": "または"
    },
    {
      "indent": 7,
      "text": "* the action does not contain any \"match\", \"not-match\", \"any-variant\", \"all-variants\", or \"only-variants\" attributes: catch-all.",
      "ja": "キャッチオール：*アクションは、任意の「一致」、「いない一致」、「いずれかのバリアント」、「全変異体」、または「のみ-変異体」属性が含まれていません。"
    },
    {
      "indent": 3,
      "text": "3. For any remaining variant label, assign the variant label the disposition using the default actions defined in Section 7.6. For this step, variant types outside the predefined recommended set (see Section 7.3) are ignored.",
      "ja": "3.残りのバリアントのラベルについては、7.6節で定義されたデフォルトのアクションを使用して、バリアントラベルに処分を割り当てます。このステップでは、事前に定義された推奨セット以外のバリアント型は無視されます（7.3節を参照してください）。"
    },
    {
      "indent": 3,
      "text": "4. For any remaining label, set the disposition to \"valid\".",
      "section_title": true,
      "ja": "残りのラベル4.は、「有効」に配置を設定します。"
    },
    {
      "indent": 0,
      "text": "8.4. Duplicate Variant Labels",
      "section_title": true,
      "ja": "8.4. バリアントラベルを複製"
    },
    {
      "indent": 3,
      "text": "For a poorly designed LGR, it is possible to generate duplicate variant labels from the same input label, but with different, and potentially conflicting, dispositions. Implementations MUST treat any duplicate variant labels encountered as an error, irrespective of their dispositions.",
      "ja": "設計が不十分なLGRの場合は、同じ入力ラベルから重複バリアントのラベルを生成することが可能であるが、異なる、および潜在的に競合し、処分を持ちます。実装は、その処分にかかわらず、エラーとして発生した重複変異型のラベルを扱わなければなりません。"
    },
    {
      "indent": 3,
      "text": "This situation can arise in two ways. One is described in Section 5.3.5 and involves defining the same variant mapping with two context rules that are formally distinct but nevertheless overlap so that they are not mutually exclusive for the same label.",
      "ja": "この状況は、2つの方法で発生する可能性があります。一つは、セクション5.3.5に記載されており、正式に異なっているが、それらは、同じラベルの相互に排他的ではないようにもかかわらず、重なる2つのコンテキスト・ルールと同じバリアントマッピングを定義することを含むされます。"
    },
    {
      "indent": 3,
      "text": "The other case involves variants defined for sequences, where one sequence is a prefix of another (see Section 5.3.1). The following shows such an example resulting in conflicting reflexive variants:",
      "ja": "他の場合には一つの配列が別の接頭辞（セクション5.3.1を参照）の配列に対して定義された変異体を含みます。そのような例では、競合再帰変異体が得られ、次のショー。"
    },
    {
      "indent": 7,
      "text": "<char cp=\"0061\">\n  <var cp=\"0061\" type=\"allocatable\"/>\n</char>\n<char cp=\"0062\"/>\n<char cp=\"0061 0062\">\n  <var cp=\"0061 0062\" type=\"blocked\"/>\n</char>",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A label \"ab\" would generate the variant labels \"{a}{b}\" and \"{ab}\" where the curly braces show the sequence boundaries as they were applied during variant mapping. The result is a duplicate variant label \"ab\", one based on a variant of type \"allocatable\" plus an original code point \"b\" that has no variant, and another one based on a single variant of type \"blocked\", thus creating two variant labels with conflicting dispositions.",
      "ja": "変異体のラベルを生成するラベル「AB」「{A}、{B}」と「{AB}」それらは変異マッピング中に適用されたように中括弧は、配列の境界を示してあります。結果は、型の変形に基づく重複変異ラベル「AB」は、1つである「割り当て」に加えて元のコードポイントない変異体を持たない「B」、および「ブロック」型の単一変異体に基づいて別の、従って作成競合処分を持つ2つのバリエーションラベル。"
    },
    {
      "indent": 3,
      "text": "In the general case, it is difficult to impossible to prove by mechanical inspection of the LGR that duplicate variant labels will never occur, so implementations have to be prepared to detect this error during variant label generation. The condition is easily avoided by careful design of context rules and special attention to the relation among code point sequences with variants.",
      "ja": "実装はバリアントラベル生成時にこのエラーを検出するために準備する必要があるので、一般的なケースでは、それは、決して起こらないバリアントのラベルを複製LGRの機械的な検査によって証明することは不可能に困難です。条件は簡単に変形して、コード・ポイントの配列間関係にコンテキストルールの慎重な設計と特別な注意によって回避されます。"
    },
    {
      "indent": 0,
      "text": "8.5. Checking Labels for Collision",
      "section_title": true,
      "ja": "8.5. 衝突のラベルをチェックします"
    },
    {
      "indent": 3,
      "text": "The obvious method for checking for collision between labels is to generate the fully permuted set of variants for one of them and see whether it contains the other label as a member. As discussed above, this can be prohibitive and is not necessary.",
      "ja": "ラベル間の衝突をチェックする明白な方法は、それらのいずれかの変種の完全順列セットを生成し、それがメンバーとして他のラベルが含まれているかどうかを確認することです。上述したように、これは法外であると不要であることができます。"
    },
    {
      "indent": 3,
      "text": "Because of symmetry and transitivity, all variant mappings form disjoint sets. In each of these sets, the source and target of each mapping are also variants of the sources and targets of all the other mappings. However, members of two different sets are never variants of each other.",
      "ja": "そのため対称性と推移性のため、すべてのバリアントマッピングが互いに素な集合を形成します。これらのセットのそれぞれにおいて、各マッピングのソースとターゲットは、他のすべてのマッピングのソースとターゲットの変異体です。しかし、2つの異なるセットのメンバーがお互いの変異体は決してありません。"
    },
    {
      "indent": 3,
      "text": "If two labels have code points at the same position that are members of two different variant mapping sets, any variant labels of one cannot be variant labels of the other: the sets of their variant labels are likewise disjoint. Instead of generating all permutations to compare all possible variants, it is enough to find out whether code points at the same position belong to the same variant set or not.",
      "ja": "2つのラベルが2つの異なる変異マッピングセットのメンバーで同じ位置にコードポイントを使用している場合、一方の任意の変異体ラベルは、他の変異体標識することができない。その変異体ラベルのセットは、同様に互いに素です。代わりに、すべての可能な変形を比較するために、すべての順列を生成する、同じ位置のコードポイントが設定されていないか、同じバリアントに属しているかどうかを確認するのに十分です。"
    },
    {
      "indent": 3,
      "text": "For that, it is sufficient to substitute an \"index\" mapping that identifies the set. This index mapping could be, for example, the variant mapping for which the target code point (or sequence) comes first in some sorting order. This index mapping would, in effect, identify the set of variant mappings for that position.",
      "ja": "そのため、セットを識別する「インデックス」マッピングを置換するのに十分です。このインデックスのマッピングは、例えば、変異体マッピングは、ターゲット・コード・ポイント（または配列）は、いくつかのソート順で最初に来るれる、とすることができます。このインデックスマッピングは、実際には、その位置のためのバリアントマッピングのセットを識別します。"
    },
    {
      "indent": 3,
      "text": "To check for collision then means generating a single variant label from the original by substituting the respective \"index\" value for each code point. This results in an \"index label\". Two labels collide whenever the index labels for them are the same.",
      "ja": "衝突をチェックするためには、各コードポイントのそれぞれの「インデックス」値を代入することにより原稿からの単一変異体ラベルを生成します。これは、「インデックスラベル」になります。それらのインデックスラベルが同じ場合は常に2つのラベルが衝突します。"
    },
    {
      "indent": 0,
      "text": "9. Conversion to and from Other Formats",
      "section_title": true,
      "ja": "その他のフォーマットへと変換から9"
    },
    {
      "indent": 3,
      "text": "Both [RFC3743] and [RFC4290] provide different grammars for IDN tables. The formats in those documents are unable to fully support the increased requirements of contemporary IDN variant policies.",
      "ja": "[RFC3743]及び[RFC4290]の両方が、IDNテーブルの異なる文法を提供します。それらの文書でのフォーマットは完全に現代的なIDNバリアント政策の増加要件をサポートすることはできません。"
    },
    {
      "indent": 3,
      "text": "This specification is a superset of functionality provided by the older IDN table formats; thus, any table expressed in those formats can be expressed in this new format. Automated conversion can be conducted between tables conformant with the grammar specified in each document.",
      "ja": "この仕様は古いIDNテーブル形式で提供される機能のスーパーセットです。従って、これらの形式で表現任意のテーブルは、この新しい形式で表現することができます。自動化された変換は、各文書に指定された文法に準拠テーブルとの間に行うことができます。"
    },
    {
      "indent": 3,
      "text": "For notes on how to translate a table in the style of RFC 3743, see Appendix B.",
      "ja": "RFC 3743のスタイルでテーブルを変換する方法についての注意事項については、付録Bを参照してください。"
    },
    {
      "indent": 0,
      "text": "10. Media Type",
      "section_title": true,
      "ja": "10.メディアタイプ"
    },
    {
      "indent": 3,
      "text": "Well-formed LGRs that comply with this specification SHOULD be transmitted with a media type of \"application/lgr+xml\". This media type will signal to an LGR-aware client that the content is designed to be interpreted as an LGR.",
      "ja": "この仕様に準拠して整形LGRsは、「アプリケーション/ LGR + XML」のメディアタイプで送信されるべきです。このメディアタイプは、コンテンツがLGRと解釈されるように設計されたLGR対応のクライアントに通知します。"
    },
    {
      "indent": 0,
      "text": "11. IANA Considerations",
      "section_title": true,
      "ja": "11. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "IANA has completed the following actions:",
      "ja": "IANAは、次のアクションを完了しました。"
    },
    {
      "indent": 0,
      "text": "11.1. Media Type Registration",
      "section_title": true,
      "ja": "11.1. メディアタイプ登録"
    },
    {
      "indent": 3,
      "text": "The media type \"application/lgr+xml\" has been registered to denote transmission of LGRs that are compliant with this specification, in accordance with [RFC6838].",
      "ja": "メディアタイプ「アプリケーション/ LGR + XMLは、」[RFC6838]に従って、この仕様に準拠しLGRsの送信を示すために登録されています。"
    },
    {
      "indent": 3,
      "text": "Type name: application",
      "ja": "型名：アプリケーション"
    },
    {
      "indent": 3,
      "text": "Subtype name: lgr+xml",
      "ja": "サブタイプ名：LGR + xmlの"
    },
    {
      "indent": 3,
      "text": "Required parameters: N/A",
      "ja": "必須パラメータ：N / A"
    },
    {
      "indent": 3,
      "text": "Optional parameters: charset (as for application/xml per [RFC7303])",
      "ja": "オプションのパラメータ：文字セット（[RFC7303]あたりのアプリケーション/ XMLのような）"
    },
    {
      "indent": 3,
      "text": "Security considerations: See the security considerations for application/xml in [RFC7303] and the specific security considerations for Label Generation Rulesets (LGRs) in RFC 7940",
      "ja": "セキュリティの考慮事項：RFC 7940で[RFC7303]でアプリケーション/ XMLのセキュリティの考慮事項とラベル生成ルールセット（LGRs）に関する特定のセキュリティの考慮事項を参照してください。"
    },
    {
      "indent": 3,
      "text": "Interoperability considerations: As for application/xml per [RFC7303]",
      "ja": "相互運用性に関する注意事項：[RFC7303]あたりのアプリケーション/ XMLについて"
    },
    {
      "indent": 3,
      "text": "Published specification: See RFC 7940",
      "ja": "公開された仕様：RFC 7940を参照してください。"
    },
    {
      "indent": 3,
      "text": "Applications that use this media type: Software using LGRs for international identifiers, such as IDNs, including registry applications and client validators.",
      "ja": "このメディアタイプを使用するアプリケーション：レジストリアプリケーションとクライアントのバリデータを含むなどのIDNなどの国際識別子、のためのソフトウェア使用LGRs。"
    },
    {
      "indent": 3,
      "text": "Additional information:",
      "ja": "追加情報："
    },
    {
      "indent": 6,
      "text": "Deprecated alias names for this type: N/A",
      "ja": "このタイプの非推奨別名：N / A"
    },
    {
      "indent": 6,
      "text": "Magic number(s): N/A",
      "ja": "マジックナンバー（S）：N / A"
    },
    {
      "indent": 6,
      "text": "File extension(s): .lgr",
      "ja": "ファイルの拡張子（S）：.lgr"
    },
    {
      "indent": 6,
      "text": "Macintosh file type code(s): N/A",
      "ja": "Macintoshのファイルタイプコード（S）：N / A"
    },
    {
      "indent": 3,
      "text": "Person & email address to contact for further information:",
      "ja": "詳細のために連絡する人とEメールアドレス："
    },
    {
      "indent": 6,
      "text": "Kim Davies <kim.davies@icann.org>",
      "ja": "キム・デイヴィス<kim.davies@icann.org>"
    },
    {
      "indent": 6,
      "text": "Asmus Freytag <asmus@unicode.org>",
      "ja": "Asmusフライターク<asmus@unicode.org>"
    },
    {
      "indent": 3,
      "text": "Intended usage: COMMON",
      "ja": "意図している用法：COMMON"
    },
    {
      "indent": 3,
      "text": "Restrictions on usage: N/A",
      "ja": "使用に関する制限事項：N / A"
    },
    {
      "indent": 3,
      "text": "Author:",
      "ja": "著者："
    },
    {
      "indent": 6,
      "text": "Kim Davies <kim.davies@icann.org>",
      "ja": "キム・デイヴィス<kim.davies@icann.org>"
    },
    {
      "indent": 6,
      "text": "Asmus Freytag <asmus@unicode.org>",
      "ja": "Asmusフライターク<asmus@unicode.org>"
    },
    {
      "indent": 3,
      "text": "Change controller: IESG",
      "ja": "変更コントローラ：IESG"
    },
    {
      "indent": 3,
      "text": "Provisional registration? (standards tree only): No",
      "ja": "仮登録？ （規格木のみ）：いいえ"
    },
    {
      "indent": 0,
      "text": "11.2. URN Registration",
      "section_title": true,
      "ja": "11.2.  URN登録"
    },
    {
      "indent": 3,
      "text": "This specification uses a URN to describe the XML namespace, in accordance with [RFC3688].",
      "ja": "この仕様は、[RFC3688]に従って、XML名前空間を記述するためにURNを使用します。"
    },
    {
      "indent": 3,
      "text": "URI: urn:ietf:params:xml:ns:lgr-1.0",
      "ja": "URI：URN：IETF：のparams：XML：NS：LGR-1.0"
    },
    {
      "indent": 3,
      "text": "Registrant Contact: See the Authors of this document.",
      "ja": "登録者連絡先：このドキュメントの著者を参照してください。"
    },
    {
      "indent": 3,
      "text": "XML: None.",
      "ja": "XML：なし。"
    },
    {
      "indent": 0,
      "text": "11.3. Disposition Registry",
      "section_title": true,
      "ja": "11.3. 処分レジストリ"
    },
    {
      "indent": 3,
      "text": "This document establishes a vocabulary of \"Label Generation Ruleset Dispositions\", which has been reflected as a new IANA registry. This registry is divided into two subregistries:",
      "ja": "この文書は、新しいIANAレジストリとして反映されてきた「ラベル生成ルールセット処分」の語彙を確立します。このレジストリは、2 subregistriesに分かれています。"
    },
    {
      "indent": 3,
      "text": "o Standard Dispositions - This registry lists dispositions that have been defined in published specifications, i.e., the eligibility for such registrations is \"Specification Required\" [RFC5226]. The initial set of registrations are the five dispositions in this document described in Section 7.3.",
      "ja": "O規格の処分 - このレジストリが公表仕様で定義されている処分を示しています、すなわち、そのような登録のための適格性は、「仕様が必要」[RFC5226]です。登録の最初のセットは、7.3節で説明したこの文書に記載されている5処分されています。"
    },
    {
      "indent": 3,
      "text": "o Private Dispositions - This registry lists dispositions that have been registered \"First Come First Served\" [RFC5226] by third parties with the IANA. Such dispositions must take the form \"entity:disposition\" where the entity is a domain name that uniquely identifies the private user of the namespace. For example, \"example.org:reserved\" could be a private extension used by the example organization to denote a disposition relating to reserved labels. These extensions are not intended to be interoperable, but registration is designed to minimize potential conflicts. It is strongly recommended that any new dispositions that require interoperability and have applicability beyond a single organization be defined as Standard Dispositions.",
      "ja": "プライベート処分O  - このレジストリは登録されている処分は、IANAと第三者による[RFC5226]を「まず第一に役立ってくる」一覧表示されます。エンティティは一意の名前空間のプライベートユーザを特定するドメイン名は次のとおりです。「処分の実体」このような処分は次の形式を取る必要があります。たとえば、予約されたラベルに関連する処分を示すために例の組織で使用するプライベート拡張することができ、「example.org:reserved」。これらの拡張機能は、相互運用できるように意図されていませんが、登録は潜在的な競合を最小限に抑えるように設計されています。これは、相互運用性を必要とし、標準的な処分として定義される単一の組織を超えて適用可能性を持っている任意の新しい処分することを強くお勧めです。"
    },
    {
      "indent": 3,
      "text": "In order to distinguish them from Private Dispositions, Standard Dispositions MUST NOT contain the \":\" character. All disposition names shall be in lowercase ASCII.",
      "ja": "「：」文字プライベート処分と区別するために、標準的な処分は含んではなりません。すべて処分名は小文字のASCIIにしなければなりません。"
    },
    {
      "indent": 3,
      "text": "The IANA registry provides data on the name of the disposition, the intended purposes, and the registrant or defining specification for the disposition.",
      "ja": "IANAレジストリは、処分のための処分、意図された目的、および登録者または定義する仕様の名前にデータを提供します。"
    },
    {
      "indent": 0,
      "text": "12. Security Considerations",
      "section_title": true,
      "ja": "12.セキュリティの考慮事項"
    },
    {
      "indent": 0,
      "text": "12.1. LGRs Are Only a Partial Remedy for Problem Space",
      "section_title": true,
      "ja": "12.1.  LGRsは問題空間のために部分的にしか救済措置です"
    },
    {
      "indent": 3,
      "text": "Substantially unrestricted use of non-ASCII characters in security-relevant identifiers such as domain name labels may cause user confusion and invite various types of attacks. In many languages, in particular those using complex or large scripts, an attacker has an opportunity to divert or confuse users as a result of different code points with identical appearance or similar semantics.",
      "ja": "実質的に、このようなドメイン名のラベルなどのセキュリティ関連の識別子に非ASCII文字を無制限に使用することは、ユーザーの混乱を引き起こし、攻撃のさまざまなタイプを招くことがあります。多くの言語では、複雑で大規模なスクリプトを使用して、それらの特定には、攻撃者が同じ外観や同じような意味を持つ異なるコード・ポイントの結果として、ユーザーをそらすか、混乱する機会を持っています。"
    },
    {
      "indent": 3,
      "text": "The use of an LGR provides a partial remedy for these risks by supplying a framework for prohibiting inappropriate code points or sequences from being registered at all and for permitting \"variant\" code points to be grouped together so that labels containing them may be mutually exclusive or registered only to the same owner.",
      "ja": "LGRの使用は、それらを含むラベルは相互に排他的であってもよいように、すべてに登録されることから、不適切なコードポイントまたはシーケンスを禁止するため、一緒にグループ化される「変異体」のコードポイントを可能にするためのフレームワークを供給することによって、これらのリスクのための部分的な救済を提供し、または唯一、同じ所有者に登録されました。"
    },
    {
      "indent": 3,
      "text": "In addition, by being fully machine processable the format may enable automated checks for known weaknesses in label generation rules. However, the use of this format, or compliance with this specification, by itself does not ensure that the LGRs expressed in this format are free of risk. Additional approaches may be considered, depending on the acceptable trade-off between flexibility and risk for a given application. One method of managing risk may involve a case-by-case evaluation of a proposed label in context with already-registered labels -- for example, when reviewing labels for their degree of visual confusability.",
      "ja": "加えて、完全に機械であることによってフォーマットがラベル生成ルールで既知の弱点のための自動検査を可能にすることができる加工。しかし、それだけでこのフォーマットの使用、またはこの仕様の遵守は、この形式で表現LGRsはリスクがないことを保証するものではありません。さらなるアプローチは、所与の用途のための柔軟性とリスクとの間に許容可能なトレードオフに応じて、考慮することができます。リスクを管理するための一つの方法は、既に登録済みのラベルを使用してコンテキストで提案されているラベルのケースバイケースの評価を含むことができる - 例えば、視覚的な混同の程度のラベルを検討する際。"
    },
    {
      "indent": 0,
      "text": "12.2. Computational Expense of Complex Tables",
      "section_title": true,
      "ja": "12.2. 複雑な表の計算コスト"
    },
    {
      "indent": 3,
      "text": "A naive implementation attempting to generate all variant labels for a given label could lead to the possibility of exhausting the resources on the machine running the LGR processor, potentially causing denial-of-service consequences. For many operations, brute-force generation can be avoided by optimization, and if needed, the number of permuted labels can be estimated more cheaply ahead of time.",
      "ja": "指定したラベルのすべてのバリエーションラベルを生成しようと素朴な実装では、潜在的にサービス拒否の影響を引き起こし、LGRのプロセッサを実行しているマシン上のリソースを消耗する可能性につながる可能性があります。多くの操作では、ブルートフォース世代は、最適化することで回避することができ、必要に応じて、順列ラベルの数は、より安く、事前に予測することができます。"
    },
    {
      "indent": 3,
      "text": "The implementation of WLE rules, using certain backtracking algorithms, can take exponential time for pathological rules or labels and exhaust stack resources. This can be mitigated by proper implementation and enforcing the restrictions on permissible label length.",
      "ja": "特定のバックトラッキングアルゴリズムを使用して、WLEルールの実装は、病理学的規則またはラベルと排気スタックリソースの指数関数的な時間を取ることができます。これは、適切な実装と許容ラベルの長さに制限を強制することによって軽減することができます。"
    },
    {
      "indent": 0,
      "text": "13. References",
      "section_title": true,
      "ja": "13.参考文献"
    },
    {
      "indent": 0,
      "text": "13.1. Normative References",
      "section_title": true,
      "ja": "13.1. 引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC2045] Freed, N. and N. Borenstein, \"Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies\", RFC 2045, DOI 10.17487/RFC2045, November 1996, <http://www.rfc-editor.org/info/rfc2045>.",
      "ja": "[RFC2045]解放され、N.とN. Borenstein、 \"マルチパーパスインターネットメールエクステンション（MIME）第一部：インターネットメッセージ本体のフォーマット\"、RFC 2045、DOI 10.17487 / RFC2045、1996年11月、<のhttp：//www.rfc- editor.org/info/rfc2045>。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<http://www.rfc-editor.org/info/ RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC3339] Klyne, G. and C. Newman, \"Date and Time on the Internet: Timestamps\", RFC 3339, DOI 10.17487/RFC3339, July 2002, <http://www.rfc-editor.org/info/rfc3339>.",
      "ja": "[RFC3339] Klyne、G.とC.ニューマン、 \"インターネット上の日付と時刻：タイムスタンプ\"、RFC 3339、DOI 10.17487 / RFC3339、2002年7月、<http://www.rfc-editor.org/info/rfc3339 >。"
    },
    {
      "indent": 3,
      "text": "[RFC5646] Phillips, A., Ed., and M. Davis, Ed., \"Tags for Identifying Languages\", BCP 47, RFC 5646, DOI 10.17487/RFC5646, September 2009, <http://www.rfc-editor.org/info/rfc5646>.",
      "ja": "[RFC5646]フィリップス、A.、エド、とM.デイヴィス、エド、 \"言語を識別するためのタグ\"、BCP 47、RFC 5646、DOI 10.17487 / RFC5646、2009年9月、<のhttp：。。//www.rfc-editor .ORG /情報/ rfc5646>。"
    },
    {
      "indent": 3,
      "text": "[UAX42] The Unicode Consortium, \"Unicode Character Database in XML\", May 2016, <http://unicode.org/reports/tr42/>.",
      "ja": "[UAX42]はUnicodeコンソーシアム、 \"XMLのUnicode文字データベース\"、2016年5月、<http://unicode.org/reports/tr42/>。"
    },
    {
      "indent": 3,
      "text": "[Unicode-Stability] The Unicode Consortium, \"Unicode Encoding Stability Policy, Property Value Stability\", April 2015, <http://www.unicode.org/policies/ stability_policy.html#Property_Value>.",
      "ja": "[ユニコード-安定性]のUnicodeコンソーシアム、 \"Unicodeのエンコーディング安定政策、プロパティ値の安定性\"、2015年4月、<http://www.unicode.org/policies/ stability_policy.html＃PROPERTY_VALUE>。"
    },
    {
      "indent": 3,
      "text": "[Unicode-Versions] The Unicode Consortium, \"Unicode Version Numbering\", June 2016, <http://unicode.org/versions/#Version_Numbering>.",
      "ja": "[ユニコード・バージョン]のUnicodeコンソーシアム、 \"Unicodeバージョン番号\"、2016年6月、<http://unicode.org/versions/#Version_Numbering>。"
    },
    {
      "indent": 3,
      "text": "[XML] Bray, T., Paoli, J., Sperberg-McQueen, M., Maler, E., and F. Yergeau, \"Extensible Markup Language (XML) 1.0 (Fifth Edition)\", World Wide Web Consortium, November 2008, <http://www.w3.org/TR/REC-xml/>.",
      "ja": "[XML]ブレイ、T.、パオリ、J.、Sperberg-マックイーン、M.、MALER、E.、およびF. Yergeau、 \"拡張マークアップ言語（XML）1.0（第5版）\"、ワールドワイドウェブコンソーシアム11月2008年、<http://www.w3.org/TR/REC-xml/>。"
    },
    {
      "indent": 0,
      "text": "13.2. Informative References",
      "section_title": true,
      "ja": "13.2. 参考文献"
    },
    {
      "indent": 3,
      "text": "[ASIA-TABLE] DotAsia Organisation, \".ASIA ZH IDN Language Table\", February 2012, <http://www.dot.asia/policies/ASIA-ZH-1.2.pdf>.",
      "ja": "[ASIA-TABLE] DotAsia組織、 \".ASIA ZH IDN言語表\"、2012年2月、<http://www.dot.asia/policies/ASIA-ZH-1.2.pdf>。"
    },
    {
      "indent": 3,
      "text": "[LGR-PROCEDURE] Internet Corporation for Assigned Names and Numbers, \"Procedure to Develop and Maintain the Label Generation Rules for the Root Zone in Respect of IDNA Labels\", December 2012, <http://www.icann.org/en/resources/idn/ draft-lgr-procedure-07dec12-en.pdf>.",
      "ja": "割り当てられた名前と番号のための[LGR-PROCEDURE]インターネット株式会社、「IDNAラベルの尊重にルートゾーン用ラベル生成ルールを開発し、維持するための手順」、2012年12月、<http://www.icann.org/en/リソース/ IDN /ドラフト-LGR-手順-07dec12-en.pdf>。"
    },
    {
      "indent": 3,
      "text": "[RELAX-NG] The Organization for the Advancement of Structured Information Standards (OASIS), \"RELAX NG Compact Syntax\", November 2002, <https://www.oasis-open.org/committees/ relax-ng/compact-20021121.html>.",
      "ja": "[RELAX-NG]を構造化情報標準促進のための組織（OASIS）、 \"NGコンパクト構文をRELAX\"、2002年11月、<https://www.oasis-open.org/committees/コンパクト-20021121 /-ngのリラックス.htmlを>。"
    },
    {
      "indent": 3,
      "text": "[RFC3688] Mealling, M., \"The IETF XML Registry\", BCP 81, RFC 3688, DOI 10.17487/RFC3688, January 2004, <http://www.rfc-editor.org/info/rfc3688>.",
      "ja": "[RFC3688] Mealling、M.、 \"IETF XMLレジストリ\"、BCP 81、RFC 3688、DOI 10.17487 / RFC3688、2004年1月、<http://www.rfc-editor.org/info/rfc3688>。"
    },
    {
      "indent": 3,
      "text": "[RFC3743] Konishi, K., Huang, K., Qian, H., and Y. Ko, \"Joint Engineering Team (JET) Guidelines for Internationalized Domain Names (IDN) Registration and Administration for Chinese, Japanese, and Korean\", RFC 3743, DOI 10.17487/RFC3743, April 2004, <http://www.rfc-editor.org/info/rfc3743>.",
      "ja": "[RFC3743]小西、K.、黄、K.、銭、H.、およびY.コ、 \"国際化ドメイン名のための共同エンジニアリングチーム（JET）ガイドライン中国語、日本語、韓国語用（IDN）登録と管理\"、 RFC 3743、DOI 10.17487 / RFC3743、2004年4月、<http://www.rfc-editor.org/info/rfc3743>。"
    },
    {
      "indent": 3,
      "text": "[RFC4290] Klensin, J., \"Suggested Practices for Registration of Internationalized Domain Names (IDN)\", RFC 4290, DOI 10.17487/RFC4290, December 2005, <http://www.rfc-editor.org/info/rfc4290>.",
      "ja": "[RFC4290] Klensin、J.、 \"国際化ドメイン名（IDN）の登録のための推奨プラクティス\"、RFC 4290、DOI 10.17487 / RFC4290、2005年12月、<http://www.rfc-editor.org/info/rfc4290> 。"
    },
    {
      "indent": 3,
      "text": "[RFC5226] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 5226, DOI 10.17487/RFC5226, May 2008, <http://www.rfc-editor.org/info/rfc5226>.",
      "ja": "[RFC5226] Narten氏、T.とH. Alvestrand、 \"RFCsにIANA問題部に書くためのガイドライン\"、BCP 26、RFC 5226、DOI 10.17487 / RFC5226、2008年5月、<http://www.rfc-editor.org /情報/ RFC5226>。"
    },
    {
      "indent": 3,
      "text": "[RFC5564] El-Sherbiny, A., Farah, M., Oueichek, I., and A. Al-Zoman, \"Linguistic Guidelines for the Use of the Arabic Language in Internet Domains\", RFC 5564, DOI 10.17487/RFC5564, February 2010, <http://www.rfc-editor.org/info/rfc5564>.",
      "ja": "[RFC5564]エルSherbiny、A.、ファラー、M.、Oueichek、I.、およびA.アルZoman、 \"インターネットドメイン内のアラビア言語の使用のための言語のガイドライン\"、RFC 5564、DOI 10.17487 / RFC5564、 2010年2月、<http://www.rfc-editor.org/info/rfc5564>。"
    },
    {
      "indent": 3,
      "text": "[RFC5891] Klensin, J., \"Internationalized Domain Names in Applications (IDNA): Protocol\", RFC 5891, DOI 10.17487/RFC5891, August 2010, <http://www.rfc-editor.org/info/rfc5891>.",
      "ja": "[RFC5891] Klensin、J.、 \"アプリケーション（IDNA）で国際化ドメイン名：プロトコル\"、RFC 5891、DOI 10.17487 / RFC5891、2010年8月、<http://www.rfc-editor.org/info/rfc5891>。"
    },
    {
      "indent": 3,
      "text": "[RFC5892] Faltstrom, P., Ed., \"The Unicode Code Points and Internationalized Domain Names for Applications (IDNA)\", RFC 5892, DOI 10.17487/RFC5892, August 2010, <http://www.rfc-editor.org/info/rfc5892>.",
      "ja": "[RFC5892] Faltstrom、P.、エド。、 \"Unicodeのコードポイントとアプリケーションのための国際化ドメイン名（IDNA）\"、RFC 5892、DOI 10.17487 / RFC5892、2010年8月、<http://www.rfc-editor.org /情報/ rfc5892>。"
    },
    {
      "indent": 3,
      "text": "[RFC6838] Freed, N., Klensin, J., and T. Hansen, \"Media Type Specifications and Registration Procedures\", BCP 13, RFC 6838, DOI 10.17487/RFC6838, January 2013, <http://www.rfc-editor.org/info/rfc6838>.",
      "ja": "[RFC6838]解放され、N.、Klensin、J.、およびT.ハンセン、 \"メディアタイプの仕様と登録手順\"、BCP 13、RFC 6838、DOI 10.17487 / RFC6838、2013年1月、<のhttp：//www.rfc- editor.org/info/rfc6838>。"
    },
    {
      "indent": 3,
      "text": "[RFC7303] Thompson, H. and C. Lilley, \"XML Media Types\", RFC 7303, DOI 10.17487/RFC7303, July 2014, <http://www.rfc-editor.org/info/rfc7303>.",
      "ja": "[RFC7303]トンプソン、H.およびC.リリー、 \"XMLのメディアタイプ\"、RFC 7303、DOI 10.17487 / RFC7303、2014年7月、<http://www.rfc-editor.org/info/rfc7303>。"
    },
    {
      "indent": 3,
      "text": "[TDIL-HINDI] Technology Development for Indian Languages (TDIL) Programme, \"Devanagari Script Behaviour for Hindi Ver2.0\", <http://tdil-dc.in/index.php?option=com_download&task=show resourceDetails&toolid=1625&lang=en>.",
      "ja": "[TDIL-ヒンディー語]インドの言語のための技術開発（TDIL）プログラム、 \"ヒンディー語Ver2.0用デーヴァナーガリースクリプトの動作\"、<http://tdil-dc.in/index.php?option=com_download&task=show resourceDetails＆toolid = 1625＆LANG =エン>。"
    },
    {
      "indent": 3,
      "text": "[UAX44] The Unicode Consortium, \"Unicode Character Database\", June 2016, <http://unicode.org/reports/tr44/>.",
      "ja": "[UAX44]はUnicodeコンソーシアム、 \"Unicode文字データベース\"、2016年6月、<http://unicode.org/reports/tr44/>。"
    },
    {
      "indent": 3,
      "text": "[WLE-RULES] Internet Corporation for Assigned Names and Numbers, \"Whole Label Evaluation (WLE) Rules\", August 2016, <https://community.icann.org/download/ attachments/43989034/WLE-Rules.pdf>.",
      "ja": "割り当てられた名前と番号のための[WLE-RULES]インターネット株式会社、 \"ラベル全体の評価（WLE）規則\"、2016年8月、<https://community.icann.org/download/添付ファイル/ 43989034 / WLE-Rules.pdf>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Example Tables",
      "ja": "付録A.例表"
    },
    {
      "indent": 3,
      "text": "The following presents a minimal LGR table defining the lowercase LDH (letters, digits, hyphen) repertoire and containing no rules or metadata elements. Many simple LGR tables will look quite similar, except that they would contain some metadata.",
      "ja": "以下は、最小のLGRテーブル小文字LDH（文字、数字、ハイフン）レパートリーを定義しないルールやメタデータ要素を含まないを提示します。多くの単純なLGRテーブルは、彼らはいくつかのメタデータが含まれているということを除いて、非常に似ています。"
    },
    {
      "indent": 3,
      "text": "<?xml version=\"1.0\" encoding=\"utf-8\"?> <lgr xmlns=\"urn:ietf:params:xml:ns:lgr-1.0\"> <data> <char cp=\"002D\" comment=\"HYPHEN (-)\" /> <range first-cp=\"0030\" last-cp=\"0039\" comment=\"DIGIT ZERO - DIGIT NINE\" /> <range first-cp=\"0061\" last-cp=\"007A\" comment=\"LATIN SMALL LETTER A - LATIN SMALL LETTER Z\" /> </data> </lgr>",
      "ja": "<？xml version = \"1.0\" エンコード= \"UTF-8\"？> <LGRのxmlns = \"壷：IETF：のparams：XML：NS：LGR-1.0\"> <データ> <文字CP = \"002D\" コメント=」 HYPHEN（ - ）」/> <及ぶ最初-CP = \"0030\" 最後-CP = \"0039\" コメント= \"DIGIT ZERO  -  DIGIT NINE\" /> <及ぶ最初-CP = \"0061\" 最後-CP = \"007A\"コメント= \"LATIN SMALL LETTER A  -  LATIN SMALL LETTER Z\" /> </データ> </ LGR>"
    },
    {
      "indent": 3,
      "text": "In practice, any LGR that includes the hyphen might also contain rules invalidating any labels beginning with a hyphen, ending with a hyphen, and containing consecutive hyphens in the third and fourth positions as required by [RFC5891].",
      "ja": "実際には、ハイフンを含む任意のLGRはまた、[RFC5891]によって必要とされる、ハイフンで始まるラベルを無効にハイフンで終わる、第3及び第4の位置で連続ハイフンを含むルールが含まれているかもしれません。"
    },
    {
      "indent": 3,
      "text": "<?xml version=\"1.0\" encoding=\"utf-8\"?> <lgr xmlns=\"urn:ietf:params:xml:ns:lgr-1.0\"> <data> <char cp=\"002D\" not-when=\"hyphen-minus-disallowed\" /> <range first-cp=\"0030\" last-cp=\"0039\" /> <range first-cp=\"0061\" last-cp=\"007A\" /> </data> <rules> <rule name=\"hyphen-minus-disallowed\" comment=\"RFC5891 restrictions on U+002D\"> <choice> <rule comment=\"no leading hyphen\"> <look-behind> <start /> </look-behind> <anchor /> </rule> <rule comment=\"no trailing hyphen\"> <anchor /> <look-ahead> <end /> </look-ahead> </rule>",
      "ja": "<？xml version = \"1.0\" エンコード= \"UTF-8\"？> <LGRのxmlns = \"URN：IETF：paramsは：XML：NS：LGR-1.0\"> <データ> <チャーCP = \"002D\" ではありません、 = \"ハイフンマイナス-許可\" /> <範囲第-CP = \"0030\" 最後-CP = \"0039\" /> <範囲第-CP = \"0061\" 最後-CP = \"007A\" /> </データ> <ルール> <ルール名= \"ハイフンマイナス-禁止\" コメント= \"U + 002D上のRFC5891の制限\"> <ルールコメント= \"ノーリードハイフン\"> <選択肢>が<見てビハインド> <開始/> </探します-behind> <アンカー/> </ルール> <ルールコメント= \"なし末尾のハイフン\"> <アンカー/> <先読み> <エンド/> </ルックアヘッド> </ルール>"
    },
    {
      "indent": 3,
      "text": " <rule comment=\"no consecutive hyphens in third and fourth positions\"> <look-behind> <start /> <any /> <any /> <char cp=\"002D\" comment=\"hyphen-minus\" /> </look-behind> <anchor /> </rule> </choice> </rule> </rules> </lgr>",
      "ja": "<ルールのコメント= \"第三及び第四の位置にいない連続したハイフン\"> <見てビハインド> <開始/> <任意の/> <任意の/> <文字CP = \"002D\" コメント= \"ハイフンマイナス\" /> </見てビハインド> <アンカー/> </ルール> </選択> </ルール> </ルール> </ LGR>"
    },
    {
      "indent": 3,
      "text": "The following sample LGR shows a more complete collection of the elements and attributes defined in this specification in a somewhat typical context.",
      "ja": "次のサンプルLGRは幾分一般的文脈において本明細書中に定義された要素および属性のより完全なコレクションを示しています。"
    },
    {
      "indent": 3,
      "text": "<?xml version=\"1.0\" encoding=\"utf-8\"?>",
      "ja": "<？xml version = \"1.0\" エンコード= \"UTF-8\"？>"
    },
    {
      "indent": 3,
      "text": "<!-- This example uses a large subset of the features of this specification. It does not include every set operator, match operator element, or action trigger attribute, their use being largely parallel to the ones demonstrated. -->",
      "ja": "<！ - この例では、この仕様の機能の大規模なサブセットを使用しています。これは、それらの使用が実証されたものとほぼ平行で、すべての集合演算子、マッチ演算子要素、またはアクションのトリガー属性が含まれていません。 - >"
    },
    {
      "indent": 3,
      "text": "<lgr xmlns=\"urn:ietf:params:xml:ns:lgr-1.0\"> <!-- meta element with all optional elements --> <meta> <version comment=\"initial version\">1</version> <date>2010-01-01</date> <language>sv</language> <scope type=\"domain\">example.com</scope> <validity-start>2010-01-01</validity-start> <validity-end>2013-12-31</validity-end> <description type=\"text/html\"> <![CDATA[ This language table was developed with the <a href=\"http://swedish.example/\">Swedish examples institute</a>. ]]> </description>",
      "ja": "<LGRのxmlns = \"壷：IETF：のparams：XML：NS：LGR-1.0\"> <！ - すべてのオプションの要素を持つmeta要素 - > <メタ> <バージョンコメント= \"初期バージョン\"> 1 </バージョン> <日> 2010-01-01 </日付> <言語> SV </言語> <スコープタイプ= \"ドメイン\"> example.com </スコープ> <妥当性-スタート> 2010-01-01 </妥当性開始！> <有効性エンド> 2013年12月31日</有効性エンド> <記述タイプ= \"text / htmlのは\"> <[CDATA [この言語テーブルは、<のhref = \"httpで開発されました：//スウェーデン。例/ \">スウェーデンの例研究所</a>に。 ]]> </説明>"
    },
    {
      "indent": 4,
      "text": " <unicode-version>6.3.0</unicode-version> <references> <reference id=\"0\" comment=\"the most recent\" >The Unicode Standard 9.0</reference> <reference id=\"1\" >RFC 5892</reference> <reference id=\"2\" >Big-5: Computer Chinese Glyph and Character Code Mapping Table, Technical Report C-26, 1984</reference> </references> </meta>",
      "ja": "<ユニコードバージョン> 6.3.0 </ユニコードバージョン> <参考文献> <参照ID = \"0\" コメント= \"最新の\"> Unicode標準9.0 </参照> <参照ID = \"1\"> RFC 5892 </参照> <参照のid = \"2\">ビッグ-5：コンピュータ中国のグリフと文字コードのマッピング表、テクニカルレポートC-26、1984 </参照> </参照> </メタ>"
    },
    {
      "indent": 4,
      "text": "<!-- the \"data\" section describing the repertoire --> <data> <!-- single code point \"char\" element --> <char cp=\"002D\" ref=\"1\" comment=\"HYPHEN\" />",
      "ja": "<！ -  \"データ\" セクションでは、レパートリーを記述 - > <データ> <！ - 単一のコードポイント \"CHAR\" 要素 - > <チャーCP = \"002D\" REF = \"1\" コメント= \"ハイフン\" / >"
    },
    {
      "indent": 7,
      "text": "<!-- \"range\" elements for contiguous code points, with tags --> <range first-cp=\"0030\" last-cp=\"0039\" ref=\"1\" tag=\"digit\" /> <range first-cp=\"0061\" last-cp=\"007A\" ref =\"1\" tag=\"letter\" />",
      "ja": "<！ -  \"範囲\" の連続コードポイントの要素を、タグと - > <範囲第-CP = \"0030\" 最後-CP = \"0039\" REF = \"1\" タグ= \"数字\" /> <範囲初段CP = \"0061\" 最後-CP = \"007A\" REF = \"1\" タグ= \"文字\" />"
    },
    {
      "indent": 7,
      "text": "<!-- code point sequence --> <char cp=\"006C 00B7 006C\" comment=\"Catalan middle dot\" />",
      "ja": "<！ - コードポイント列 - > <文字CP = \"006C 00B7 006C\" のコメントは= \"カタロニア語中ドット\" />"
    },
    {
      "indent": 7,
      "text": "<!-- alternatively, use a When Rule --> <char cp=\"00B7\" when=\"catalan-middle-dot\" />",
      "ja": "<！ - 代わりに、ときにルールを使用 - > <文字CPを= \"00B7\" とき= \"カタロニア語、中間ドット\" />"
    },
    {
      "indent": 7,
      "text": " <!-- code point with context rule --> <char cp=\"200D\" when=\"joiner\" ref=\"2\" />",
      "ja": "<！ - コンテキストルールとコード・ポイント - > <文字CP = \"200D\" とき= \"指物師\" REF = \"2\" />"
    },
    {
      "indent": 5,
      "text": " <!-- code points with variants --> <char cp=\"4E16\" tag=\"preferred\" ref=\"0\"> <var cp=\"4E17\" type=\"blocked\" ref=\"2\" /> <var cp=\"534B\" type=\"allocatable\" ref=\"2\" /> </char> <char cp=\"4E17\" ref=\"0\"> <var cp=\"4E16\" type=\"allocatable\" ref=\"2\" /> <var cp=\"534B\" type=\"allocatable\" ref=\"2\" /> </char> <char cp=\"534B\" ref=\"0\"> <var cp=\"4E16\" type=\"allocatable\" ref=\"2\" /> <var cp=\"4E17\" type=\"blocked\" ref=\"2\" /> </char> </data>",
      "ja": "<！ - コードポイント変異体との - > <チャーCP = \"4E16\" タグ= \"好ましい\" REF = \"0\"> <VAR CP = \"4E17\" タイプ= \"遮断\" REF = \"2\" /> <VAR CP = \"534B\" タイプ= \"割り当て\" REF = \"2\" /> </チャー> <チャーCP = \"4E17\" REF = \"0\"> <VARのCP = \"4E16\" タイプ= \"割り当て\" REF = \"2 \"/> <VAR CP =\" 534B \"タイプ= \"割り当て\" REF = \"2\"/> </チャー> <チャーCP = \"534B\" REF = \"0\"> <VARのCP = \"4E16\" タイプ=\" 割り当て\"REF =\" 2\" /> <VARのCP = \"4E17\" タイプ= \"遮断\" refは= \"2\" /> </チャー> </データ>"
    },
    {
      "indent": 5,
      "text": "<!-- Context and whole label rules --> <rules> <!-- Require the given code point to be between two 006C code points --> <rule name=\"catalan-middle-dot\" ref=\"0\"> <look-behind> <char cp=\"006C\" /> </look-behind> <anchor /> <look-ahead> <char cp=\"006C\" /> </look-ahead> </rule>",
      "ja": "<！ - コンテキスト全体ラベルルール - > <ルール> <！ -  2つの006Cコードポイントの間になるように所定のコードポイントが必要 - > <ルール名=「カタロニア語、中ドット」REF =「0」 > <ルックの背後にある> <char型のCP = \"006C\" /> </ルックの背後にある> <アンカー/> <先読み> <文字CP = \"006C\" /> </ルックアヘッド> </ルール>"
    },
    {
      "indent": 7,
      "text": "<!-- example of a context rule based on property --> <class name=\"virama\" property=\"ccc:9\" /> <rule name=\"joiner\" ref=\"1\" > <look-behind> <class by-ref=\"virama\" /> </look-behind> <anchor /> </rule>",
      "ja": "<！ - プロパティに基づいて、コンテキストルールの例 - > <クラス名= \"ヴィラーマ\" プロパティ= \"CCC：9\" /> <ルール名= \"指物師\" REF = \"1\"> <ルックの背後にあります> <クラス別-REF = \"ヴィラーマ\" /> </ルックの背後にある> <アンカー/> </ルール>"
    },
    {
      "indent": 7,
      "text": "<!-- example of using set operators -->",
      "ja": "<！ - 集合演算子を使用した例 - >"
    },
    {
      "indent": 7,
      "text": "<!-- Subtract vowels from letters to get consonant, demonstrating the different set notations and the difference operator --> <difference name=\"consonants\"> <class comment=\"all letters\">0061-007A</class> <class comment=\"all vowels\"> 0061 0065 0069 006F 0075 </class> </difference>",
      "ja": "<！ - 異なるセット表記と差分演算子実証し、子音を取得するために手紙から母音を引く - > <差異名=「子音」> <クラスコメント=「すべての文字を」> 0061-007A </クラス> <クラスコメント= \"すべての母音\"> 0061 0065 0069 006F 0075 </クラス> </違い>"
    },
    {
      "indent": 7,
      "text": " <!-- by using the start and end, rule matches whole label --> <rule name=\"three-or-more-consonants\"> <start /> <!-- reference the class defined by the difference, and require three or more matches --> <class by-ref=\"consonants\" count=\"3+\" /> <end /> </rule>",
      "ja": "<！ - 開始と終了を使用することによって、ルールが全体のラベルに一致 - > <ルール名=「3-または-以上-子音」> <開始/> <！ - 、差によって定義されたクラスを参照し、必要三個の以上の一致 - > <クラス別-REF = \"子音\" カウント= \"3+\" /> <エンド/> </ルール>"
    },
    {
      "indent": 7,
      "text": "<!-- rule for negative matching --> <rule name=\"non-preferred\" comment=\"matches any non-preferred code point\"> <complement comment=\"non-preferred\" > <class from-tag=\"preferred\" /> </complement> </rule>",
      "ja": "<！ - ネガティブマッチングのルール - > <ルール名は=「非優先」コメント=「任意の非優先コードポイントにマッチする」> <補足コメントは=「非優先」> <からタグクラスは、= \"優先\"/> </補数> </ルール>"
    },
    {
      "indent": 3,
      "text": " <!-- actions triggered by matching rules and/or variant types --> <action disp=\"invalid\" match=\"three-or-more-consonants\" /> <action disp=\"blocked\" any-variant=\"blocked\" /> <action disp=\"allocatable\" all-variants=\"allocatable\" not-match=\"non-preferred\" /> </rules> </lgr>",
      "ja": "<！ - 一致規則および/またはバリアント型によってトリガアクション - > <アクションDISP =「無効」に一致=「3-または-以上-子音」/> <アクションDISP =「ブロックされた」任意のバリアントは= \"ブロックされました\"/> <アクションDISP =\" 割り当て可能な」全バリアント= \"割り当て可能\" ではない一致= \"非優先\" /> </ルール> </ LGR>"
    },
    {
      "indent": 0,
      "text": "Appendix B. How to Translate Tables Based on into the XML Format",
      "ja": "XMLフォーマットに基づいてテーブルを翻訳する方法付録B."
    },
    {
      "indent": 3,
      "text": "As background, the rules specified in [RFC3743] work as follows:",
      "ja": "次のように背景として、[RFC3743]で指定されたルールが動作します。"
    },
    {
      "indent": 3,
      "text": "1. The original (requested) label is checked to make sure that all the code points are a subset of the repertoire.",
      "ja": "1.元（要求）ラベルは、すべてのコード・ポイントは、レパートリーのサブセットであることを確認するためにチェックされています。"
    },
    {
      "indent": 3,
      "text": "2. If it passes the check, the original label is allocatable.",
      "section_title": true,
      "ja": "2.それはチェックをパスすると、オリジナルのラベルが割り当て可能です。"
    },
    {
      "indent": 3,
      "text": "3. Generate the all-simplified and all-traditional variant labels (union of all the labels generated using all the simplified variants of the code points) for allocation.",
      "ja": "3.すべての単純化および全伝統的な変異体ラベル割り当てに（コードポイントのすべての簡略化された変異体を使用して生成されたすべてのラベルの和集合）を生成します。"
    },
    {
      "indent": 3,
      "text": "To illustrate by example, here is one of the more complicated set of variants:",
      "ja": "例で説明するために、ここで変異型のより複雑なセットの1つです。"
    },
    {
      "indent": 7,
      "text": "U+4E7E\nU+4E81\nU+5E72\nU+5E79\nU+69A6\nU+6F27",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The following shows the relevant section of the Chinese language table published by the .ASIA registry [ASIA-TABLE]. Its entries read:",
      "ja": "以下は、.ASIAレジストリ[ASIA-TABLE]によって公開中国語テーブルの関連セクションを示しています。そのエントリを読みます："
    },
    {
      "indent": 4,
      "text": "<codepoint>;<simpl-variant(s)>;<trad-variant(s)>;<other-variant(s)>",
      "ja": "<コードポイント>; <SIMPLバリアント（S）>; <トラッドバリアント（S）>; <他のバリアント（S）>"
    },
    {
      "indent": 3,
      "text": "These are the lines corresponding to the set of variants listed above:",
      "ja": "これらは、上記の変異型のセットに対応する線です。"
    },
    {
      "indent": 3,
      "text": "U+4E7E;U+4E7E,U+5E72;U+4E7E;U+4E81,U+5E72,U+6F27,U+5E79,U+69A6 U+4E81;U+5E72;U+4E7E;U+5E72,U+6F27,U+5E79,U+69A6 U+5E72;U+5E72;U+5E72,U+4E7E,U+5E79;U+4E7E,U+4E81,U+69A6,U+6F27 U+5E79;U+5E72;U+5E79;U+69A6,U+4E7E,U+4E81,U+6F27 U+69A6;U+5E72;U+69A6;U+5E79,U+4E7E,U+4E81,U+6F27 U+6F27;U+4E7E;U+6F27;U+4E81,U+5E72,U+5E79,U+69A6",
      "ja": "U + 4E7E; U + 4E7E、U + 5E72; U + 4E7E; U + 4E81、U + 5E72、U + 6F27、U + 5E79、U + 69A6 U + 4E81; U + 5E72; U + 4E7E; U + 5E72 、U + 6F27、U + 5E79、U + 69A6 U + 5E72; U + 5E72; U + 5E72、U + 4E7E、U + 5E79; U + 4E7E、U + 4E81、U + 69A6、U + 6F27 U + 5E79 ; U + 5E72; U + 5E79; U + 69A6、U + 4E7E、U + 4E81、U + 6F27 U + 69A6、U + 5E72; U + 69A6、U + 5E79、U + 4E7E、U + 4E81、U + 6F27 U + 6F27; U + 4E7E; U + 6F27; U + 4E81、U + 5E72、U + 5E79、U + 69A6"
    },
    {
      "indent": 3,
      "text": "The corresponding \"data\" section XML format would look like this:",
      "ja": "対応する「データ」セクションのXMLフォーマットは、次のようになります。"
    },
    {
      "indent": 5,
      "text": "<data> <char cp=\"4E7E\"> <var cp=\"4E7E\" type=\"both\" comment=\"identity\" /> <var cp=\"4E81\" type=\"blocked\" /> <var cp=\"5E72\" type=\"simp\" /> <var cp=\"5E79\" type=\"blocked\" /> <var cp=\"69A6\" type=\"blocked\" /> <var cp=\"6F27\" type=\"blocked\" /> </char> <char cp=\"4E81\"> <var cp=\"4E7E\" type=\"trad\" /> <var cp=\"5E72\" type=\"simp\" /> <var cp=\"5E79\" type=\"blocked\" /> <var cp=\"69A6\" type=\"blocked\" /> <var cp=\"6F27\" type=\"blocked\" /> </char> <char cp=\"5E72\"> <var cp=\"4E7E\" type=\"trad\"/> <var cp=\"4E81\" type=\"blocked\"/> <var cp=\"5E72\" type=\"both\" comment=\"identity\"/> <var cp=\"5E79\" type=\"trad\"/> <var cp=\"69A6\" type=\"blocked\"/> <var cp=\"6F27\" type=\"blocked\"/> </char> <char cp=\"5E79\"> <var cp=\"4E7E\" type=\"blocked\"/> <var cp=\"4E81\" type=\"blocked\"/> <var cp=\"5E72\" type=\"simp\"/> <var cp=\"5E79\" type=\"trad\" comment=\"identity\"/> <var cp=\"69A6\" type=\"blocked\"/> <var cp=\"6F27\" type=\"blocked\"/> </char> <char cp=\"69A6\"> <var cp=\"4E7E\" type=\"blocked\"/> <var cp=\"4E81\" type=\"blocked\"/> <var cp=\"5E72\" type=\"simp\"/> <var cp=\"5E79\" type=\"blocked\"/> <var cp=\"69A6\" type=\"trad\" comment=\"identity\"/> <var cp=\"6F27\" type=\"blocked\"/> </char>",
      "ja": "<データ> <文字CP = \"4E7E\"> <VAR CP = \"4E7E\" タイプ= \"両方\" コメント= \"アイデンティティ\" /> <VARのCP = \"4E81\" タイプ= \"ブロックされた\" /> <VARのCP = \"5E72 \"TYPE =\" 簡体字」/> <VAR CP = \"5E79\" タイプ= \"遮断\" /> <VAR CP = \"69A6\" タイプ= \"遮断\" /> <VAR CP = \"6F27\" タイプ= \"遮断\" /> </チャー> <チャーCP = \"4E81\"> <VAR CP = \"4E7E\" タイプ= \"トラッド\" /> <VAR CP = \"5E72\" タイプ= \"簡体字\" /> <VAR CP = \"5E79\" タイプ=」ブロックされた \"/> <VARのCP = \"69A6\" タイプ= \"遮断\"/> <VARのCP = \"6F27\" タイプ= \"遮断\"/> </チャー> <チャーCP = \"5E72\"> <VARのCP =\" 4E7E \"タイプ=\" トラッド \"/> <VAR CP =\" 4E81\" タイプ= \"ブロックされた\" /> <VAR CP = \"5E72\" タイプ= \"両方\" コメント= \"アイデンティティ\" /> <VAR CP = \"5E79\" タイプ= \"トラッド\" /> <VARのCP = \"69A6\" タイプ= \"遮断\" /> <VARのCP = \"6F27\" タイプ= \"遮断\" /> </チャー> <チャーCP = \"5E79\"> <VARのCP =」 4E7E」タイプ= \"ブロックされた\" /> <VAR CP = \"4E81\" タイプ= \"ブロックされた\" /> <VAR CP = \"5E72\" タイプ= \"簡体字\" /> <VAR CP = \"5E79\" タイプ= \"トラッド\" のコメント= \"同一性\" /> <VARのCP = \"69A6\" タイプ= \"遮断\" /> <VARのCP = \"6F27\" タイプ= \"遮断\" /> </チャー> <チャーCP = \"69A6\"> <VARのCP = \"4E7E\" タイプ= \"遮断\" /> <VARのCP = \"4E81\" タイプ= \"遮断\" /> <VAR CPは= \"5E72\" タイプ= \"簡体字\" /> <VARのC P = \"5E79\" タイプ= \"ブロックされた\" /> <VAR CP = \"69A6\" タイプ= \"トラッド\" コメント= \"アイデンティティ\" /> <VAR CP = \"6F27\" タイプ= \"ブロックされた\" /> </ CHAR>"
    },
    {
      "indent": 5,
      "text": " <char cp=\"6F27\"> <var cp=\"4E7E\" type=\"simp\"/> <var cp=\"4E81\" type=\"blocked\"/> <var cp=\"5E72\" type=\"blocked\"/> <var cp=\"5E79\" type=\"blocked\"/> <var cp=\"69A6\" type=\"blocked\"/> <var cp=\"6F27\" type=\"trad\" comment=\"identity\"/> </char> </data>",
      "ja": "<チャーCP = \"6F27\"> <VAR CP = \"4E7E\" タイプ= \"簡体字\" /> <VARのCP = \"4E81\" タイプ= \"遮断\" /> <VARのCP = \"5E72\" タイプ= \"遮断\" /> <VARのCP = \"69A6\" タイプ= \"ブロックされた\" /> <VARのCP = \"6F27\" タイプ= \"トラッド\" コメント= \"アイデンティティ\" /> </文字<VARのCP = \"5E79\" タイプは、/ \"ブロック\" => > </データ>"
    },
    {
      "indent": 3,
      "text": "Here, the simplified variants have been given a type of \"simp\" and the traditional variants one of \"trad\", and all other ones are given \"blocked\".",
      "ja": "ここでは、単純化された変異体は「ブロック」「簡体字」と伝統的な変種「トラッド」の一つであり、他のすべてのものが与えられているのタイプを与えられています。"
    },
    {
      "indent": 3,
      "text": "Because some variant mappings show in more than one column, while the XML format allows only a single type value, they have been given the type of \"both\".",
      "ja": "XML形式は、単一のタイプの値を可能にしながら、いくつかの変種のマッピングは、複数の列で表示するので、彼らは「両方」のタイプを与えられています。"
    },
    {
      "indent": 3,
      "text": "Note that some variant mappings map to themselves (identity); that is, the mapping is reflexive (see Section 5.3.4). In creating the permutation of all variant labels, these mappings have no effect, other than adding a value to the variant type list for the variant label containing them.",
      "ja": "いくつかの変種マッピングは自分自身（アイデンティティ）にマッピングされることに注意してください。つまり、マッピングは反射的である（5.3.4項を参照してください）。すべてのバリエーションラベルの順列を作成するには、これらのマッピングは、それらを含むバリアントラベルのバリアント型のリストに値を追加すること以外に何の効果も持っていません。"
    },
    {
      "indent": 3,
      "text": "In the example so far, all of the entries with type=\"both\" are also mappings where source and target are identical. That is, they are reflexive mappings as defined in Section 5.3.4.",
      "ja": "ソースとターゲットが同一である場合の例ではこれまで、型を持つエントリのすべては=「両方」もマッピングされています。つまり、彼らは、5.3.4項で定義されるように反射的マッピングがあります。"
    },
    {
      "indent": 3,
      "text": "Given a label \"U+4E7E U+4E81\", the following labels would be ruled allocatable per [RFC3743], based on how that standard is commonly implemented in domain registries:",
      "ja": "ラベル「U + 4E7E U + 4E81」を考えると、次のラベルは、その基準は、一般的に、ドメインのレジストリで実装されている方法に基づいて、[RFC3743]あたりの割当可能な判決を下したことになります。"
    },
    {
      "indent": 7,
      "text": "Original label:     U+4E7E U+4E81\nSimplified label 1: U+4E7E U+5E72\nSimplified label 2: U+5E72 U+5E72\nTraditional label:  U+4E7E U+4E7E",
      "raw": true
    },
    {
      "indent": 3,
      "text": "However, if allocatable labels were generated simply by a straight permutation of all variants with type other than type=\"blocked\" and without regard to the simplified and traditional variants, we would end up with an extra allocatable label of \"U+5E72 U+4E7E\". This label is composed of both a Simplified Chinese character and a Traditional Chinese code point and therefore shouldn't be allocatable.",
      "ja": "しかし、割り当て可能なラベルが簡単にタイプを持つすべてのバリアントのストレート順列によってタイプ以外の生成された場合、=「ブロック」と簡略化し、伝統的な変種に関係なく、私たちは「U + 5E72 U +の余分な割り当て可能なラベルで終わるでしょう4E7E」。このラベルは、簡体字中国語の文字および中国語（繁体字）コード・ポイントの両方で構成されているため、割り当て可能であってはなりません。"
    },
    {
      "indent": 3,
      "text": "To more fully resolve the dispositions requires several actions to be defined, as described in Section 7.2.2, that will override the default actions from Section 7.6. After blocking all labels that contain a variant with type \"blocked\", these actions will set to \"allocatable\" labels based on the following variant types: \"simp\", \"trad\", and \"both\". Note that these variant types do not directly relate to dispositions for the variant label, but that the actions will resolve them to the Standard Dispositions on labels, i.e., \"blocked\" and \"allocatable\".",
      "ja": "より完全処分を解決するには、セクション7.6からデフォルトのアクションを上書きします7.2.2項で説明したように、定義するいくつかのアクションが必要です。 「ブロック」タイプのバリエーションが含まれているすべてのラベルをブロックした後、これらのアクションは、以下のバリアント型に基づいて、「割り当て可能」のラベルに設定されます：「簡体字」、「トラッド」、および「両方」。これらのバリアント型は直接バリアントラベルの処分とは関係ありませんが、アクションは、ラベル上の標準的な処分にそれらを解決すること、すなわち、「ブロックされた」ことに注意し、「割り当て可能」。"
    },
    {
      "indent": 3,
      "text": "To resolve label dispositions requires five actions to be defined (in the \"rules\" section of the XML document in question); these actions apply in order, and the first one triggered defines the disposition for the label. The actions are as follows:",
      "ja": "ラベルの処分を解決するには、（問題のXMLドキュメントの「ルール」セクションで）定義する5つの操作が必要です。これらのアクションは順番に適用され、最初の1は、ラベルの配置を定義するトリガ。次のようにアクションは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "1. Block all variant labels containing at least one blocked variant.",
      "section_title": true,
      "ja": "1.ブロック少なくとも一つのブロックされた変種を含むすべてのバリアントのラベル。"
    },
    {
      "indent": 3,
      "text": "2. Allocate all labels that consist entirely of variants that are \"simp\" or \"both\".",
      "ja": "2.「簡体字」または「両方」の変法完全に構成され、すべてのラベルを割り当てます。"
    },
    {
      "indent": 3,
      "text": "3. Also allocate all labels that are entirely \"trad\" or \"both\".",
      "section_title": true,
      "ja": "3.また、完全に「トラッド」または「両方」であるすべてのラベルを割り当てます。"
    },
    {
      "indent": 3,
      "text": "4. Block all surviving labels containing any one of the dispositions \"simp\" or \"trad\" or \"both\", because they are now known to be part of an undesirable mixed simplified/traditional label.",
      "ja": "彼らは今、望ましくない混合簡略化/伝統的なラベルの一部であることが知られているので、処分のいずれかを含む4ブロック全ての生存のラベルは、「簡体字」または「トラッド」または「両方」。"
    },
    {
      "indent": 3,
      "text": "5. Allocate any remaining label; the original label would be such a label.",
      "ja": "5.残りのラベルを割り当てます。オリジナルラベルは、ラベルになります。"
    },
    {
      "indent": 3,
      "text": "The rules declarations would be represented as:",
      "ja": "ルールの宣言は次のように表現されます。"
    },
    {
      "indent": 5,
      "text": "<rules> <!--\"action\" elements - order defines precedence--> <action disp=\"blocked\" any-variant=\"blocked\" /> <action disp=\"allocatable\" only-variants=\"simp both\" /> <action disp=\"allocatable\" only-variants=\"trad both\" /> <action disp=\"blocked\" any-variant=\"simp trad\" /> <action disp=\"allocatable\" comment=\"catch-all\" /> </rules>",
      "ja": "<ルール> <！ -  \"アクション\" 要素 - 順序が優先定義 - > <アクションDISP = \"ブロックされた\" 任意のバリアント= \"ブロックされた\" /> <アクションDISP = \"割り当て可能\" のみ-変異体は= / \"の両方の簡体字\" > <アクションDISP =「割り当て可能」のみ、バリアント=「トラッド両方」/> <アクションDISP =「ブロックされた」任意のバリアント=「SIMPトラッド」/> <アクションDISP =「割り当て可能」コメント=「キャッチオール」/ > </ルール>"
    },
    {
      "indent": 3,
      "text": "Up to now, variants with type \"both\" have occurred only associated with reflexive variant mappings. The \"action\" elements defined above rely on the assumption that this is always the case. However, consider the following set of variants:",
      "ja": "今までは、「両方」のみ再帰バリアントのマッピングに関連付けられて発生しているタイプでバリアント。上記で定義された「アクション」の要素は、これは常にそうであるという仮定に依存しています。しかし、変異体の次のセットを考慮してください。"
    },
    {
      "indent": 7,
      "text": "U+62E0;U+636E;U+636E;U+64DA\nU+636E;U+636E;U+64DA;U+62E0\nU+64DA;U+636E;U+64DA;U+62E0",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The corresponding XML would be:",
      "ja": "対応するXMLは次のようになります。"
    },
    {
      "indent": 7,
      "text": "<char cp=\"62E0\">\n<var cp=\"636E\" type=\"both\" comment=\"both, but not reflexive\" />\n<var cp=\"64DA\" type=\"blocked\" />\n</char>\n<char cp=\"636E\">\n<var cp=\"636E\" type=\"simp\" comment=\"reflexive, but not both\" />\n<var cp=\"64DA\" type=\"trad\" />\n<var cp=\"62E0\" type=\"blocked\" />\n</char>\n<char cp=\"64DA\">\n<var cp=\"636E\" type=\"simp\" />\n<var cp=\"64DA\" type=\"trad\" comment=\"reflexive\" />\n<var cp=\"62E0\" type=\"blocked\" />\n</char>",
      "raw": true
    },
    {
      "indent": 3,
      "text": "To make such variant sets work requires a way to selectively trigger an action based on whether a variant type is associated with an identity or reflexive mapping, or is associated with an ordinary variant mapping. This can be done by adding a prefix \"r-\" to the \"type\" attribute on reflexive variant mappings. For example, the \"trad\" for code point U+64DA in the preceding figure would become \"r-trad\".",
      "ja": "そのような変異体セットを動作させるためには、選択的変異型は、同一又は再帰マッピングに関連付けられているか、または通常の変異のマッピングに関連付けられているかどうかに基づいてアクションをトリガする方法を必要とします。これは、再帰バリアントマッピングの「タイプ」属性に「R-」の接頭辞を追加することによって行うことができます。前の図のコードポイントU + 64DAたとえば、「トラッド」は、「R-トラッド」となります。"
    },
    {
      "indent": 3,
      "text": "With the dispositions prepared in this way, only a slight modification to the actions is needed to yield the correct set of allocatable labels:",
      "ja": "このようにして調製した処分で、アクションへのわずかな変更が割り当て可能なラベルの正しいセットを得るために必要とされています。"
    },
    {
      "indent": 3,
      "text": "<action disp=\"blocked\" any-variant=\"blocked\" /> <action disp=\"allocatable\" only-variants=\"simp r-simp both r-both\" /> <action disp=\"allocatable\" only-variants=\"trad r-trad both r-both\" /> <action disp=\"blocked\" all-variants=\"simp trad both\" /> <action disp=\"allocatable\" />",
      "ja": "<アクションDISP = \"ブロック\" は、任意のバリアント= \"遮断\" /> <アクションDISP = \"割り当て\" のみ、変異体= \"SIMPのR-簡体字R-双方共に\" /> <アクションDISPは= \"割り当て\" のみ、変異体= \"トラッドR-トラッドR-双方共に\" /> <アクションDISPは= \"ブロックされた\" 全変異体= \"SIMPトラッド双方\" /> <アクションDISP = \"割り当て\" />"
    },
    {
      "indent": 3,
      "text": "The first three actions get triggered by the same labels as before.",
      "ja": "最初の3つのアクションは、前と同じラベルによってトリガーされます。"
    },
    {
      "indent": 3,
      "text": "The fourth action blocks any label that combines an original code point with any mix of ordinary variant mappings; however, no labels that are a combination of only original code points (code points having either no variant mappings or a reflexive mapping) would be affected. These are the original labels, and they are allocated in the last action.",
      "ja": "第四のアクションブロック通常バリアントマッピングの任意の混合物と元のコードポイントを組み合わせる任意のラベル。しかし、唯一の元のコードポイント（無変異マッピング又は再帰マッピングのいずれかを有していないコードポイント）の組み合わせであるいかなるラベルが影響を受けないであろう。これらは、元のラベルであり、彼らは最後のアクションに割り当てられています。"
    },
    {
      "indent": 3,
      "text": "Using this scheme of assigning types to ordinary and reflexive variants, all tables in the style of RFC 3743 can be converted to XML. By defining a set of actions as outlined above, the LGR will yield the correct set of allocatable variants: all variants consisting completely of variant code points preferred for simplified or traditional, respectively, will be allocated, as will be the original label. All other variant labels will be blocked.",
      "ja": "普通と反射的変異体のタイプを割り当てるこの方式を使用して、RFC 3743のスタイル内のすべてのテーブルには、XMLに変換することができます。上記で概説したように一連のアクションを定義することによって、LGRが割り当て変異体の正しいセットもたらす：オリジナルラベルになるように完全に簡略化された又は従来のために好ましいバリアントコードポイントから成る全ての変異体を、それぞれ、割り当てられます。他のすべてのバリアントのラベルがブロックされます。"
    },
    {
      "indent": 0,
      "text": "Appendix C. Indic Syllable Structure Example",
      "ja": "付録C.インド語の音節構造の例"
    },
    {
      "indent": 3,
      "text": "In LGRs for Indic scripts, it may be desirable to restrict valid labels to sequences of valid Indic syllables, or aksharas. This appendix gives a sample set of rules designed to enforce this restriction.",
      "ja": "インド語スクリプトのLGRsでは、有効なインド語音節、またはaksharasの配列に対して有効なラベルを制限することが望ましいことがあります。この付録では、この制限を強制するように設計されたルールのサンプルセットを提供します。"
    },
    {
      "indent": 3,
      "text": "Below is an example of BNF for an akshara, which has been published in \"Devanagari Script Behaviour for Hindi\" [TDIL-HINDI]. The rules for other languages and scripts used in India are expected to be generally similar.",
      "ja": "以下は「ヒンディー語デーヴァナーガリースクリプトの動作」に掲載されましたakshara、[TDIL-ヒンディー語]のためのBNFの一例です。インドで使用される他の言語やスクリプトのルールは一般的に類似であると予想されます。"
    },
    {
      "indent": 3,
      "text": "For Hindi, the BNF has the form:",
      "ja": "ヒンディー語の場合、BNF形式は次のとおりです。"
    },
    {
      "indent": 7,
      "text": "V[m]|{C[N]H}C[N](H|[v][m])",
      "ja": "V [M] | {C [N] H} C [N]（H | [V] [M]）"
    },
    {
      "indent": 3,
      "text": "Where:",
      "ja": "どこ："
    },
    {
      "indent": 3,
      "text": "V (uppercase) is any independent vowel",
      "ja": "V（大文字）は、任意独立母音であります"
    },
    {
      "indent": 3,
      "text": "m is any vowel modifier (Devanagari Anusvara, Visarga, and Candrabindu)",
      "ja": "私は阿仁vovelのmodiphairです（デーヴァナーガリーのアヌスヴァーラ、ヴィサルガ、およびcandrabindu）"
    },
    {
      "indent": 3,
      "text": "C is any consonant (with inherent vowel)",
      "ja": "Cは、（固有の母音で）任意の子音であります"
    },
    {
      "indent": 3,
      "text": "N is Nukta",
      "ja": "NはNuktaです"
    },
    {
      "indent": 3,
      "text": "H is a halant (or virama)",
      "ja": "Hはhalant（またはヴィラーマ）"
    },
    {
      "indent": 3,
      "text": "v (lowercase) is any dependent vowel sign (matra)",
      "ja": "V（小文字）は、任意の従属母音記号（MATRA）であります"
    },
    {
      "indent": 3,
      "text": "{} encloses items that may be repeated one or more times",
      "ja": "{}を1回以上繰り返すことができるアイテムを取り囲ん"
    },
    {
      "indent": 3,
      "text": "[ ] encloses items that may or may not be present",
      "ja": "[]または存在してもしなくてもよい項目を取り囲ん"
    },
    {
      "indent": 3,
      "text": "| separates items, out of which only one can be present",
      "ja": "|アイテムを分離し、唯一そのうち一つは存在することができます"
    },
    {
      "indent": 3,
      "text": "By using the Unicode character property \"InSC\" or \"Indic_Syllabic_Category\", which corresponds rather directly to the classification of characters in the BNF above, we can translate the BNF into a set of WLE rules matching the definition of an akshara.",
      "ja": "上記のBNFでの文字の分類にむしろ直接対応「InSC」または「Indic_Syllabic_Category」を、Unicode文字プロパティを使用することにより、我々はaksharaの定義に合致するWLEルールのセットにBNFを翻訳することができます。"
    },
    {
      "indent": 5,
      "text": "<rules> <!--Character class definitions go here--> <class name=\"halant\" property=\"InSC:Virama\" /> <union name=\"vowel-modifier\"> <class property=\"InSC:Visarga\" /> <class property=\"InSC:Bindu\" comment=\"includes anusvara\" /> </union> <!--Whole label evaluation and context rules go here--> <rule name=\"consonant-with-optional-nukta\"> <class by-ref=\"InSC:Consonant\" /> <class by-ref=\"InSC:Nukta\" count=\"0:1\"/> </rule> <rule name=\"independent-vowel-with-optional-modifier\"> <class by-ref=\"InSC:Vowel_Independent\" /> <class by-ref=\"vowel-modifier\" count=\"0:1\" /> </rule> <rule name=\"optional-dependent-vowel-with-opt-modifier\" > <class by-ref=\"InSC:Vowel_Dependent\" count=\"0:1\" /> <class by-ref=\"vowel-modifier\" count=\"0:1\" /> </rule> <rule name=\"consonant-cluster\"> <rule count=\"0+\"> <rule by-ref=\"consonant-with-optional-nukta\" /> <class by-ref=\"halant\" /> </rule> <rule by-ref=\"consonant-with-optional-nukta\" /> <choice> <class by-ref=\"halant\" /> <rule by-ref=\"optional-dependent-vowel-with-opt-modifier\" /> </choice> </rule> <rule name=\"akshara\"> <choice> <rule by-ref=\"independent-vowel-with-optional-modifier\" /> <rule by-ref=\"consonant-cluster\" /> </choice> </rule>",
      "ja": "<ルール> <！ -  Characterクラスの定義は、ここに入ります - > <クラス名= \"halant\" プロパティ= \"InSC：ヴィラーマ\" /> <組合名= \"母音-修飾子\"> <クラスプロパティ= \"InSC：ヴィサルガ\" /> <クラスプロパティ= \"InSC：ビンドゥ\" コメント= \"アヌスヴァーラが含ま\" /> </組合> < - ラベル全体の評価とコンテキストのルールがここに入ります - > <ルール名= \"子音と-オプション-nukta！ \"> <クラス別-REF =\" InSC：子音 \"/> <クラス別-REF = \"InSC：Nukta\" カウント= \"0：1\"/> </ルール> <ルール名=\" 独立-母音-with-オプションの改質剤 \"> <クラス別-REF =\" InSC：Vowel_Independent \"/> <クラス別-REF = \"母音-修飾語\" カウント= \"0：1\"/> </ルール> <ルール名=\" オプションの依存-vowel-と-OPT-修飾子」> <クラス別-REF = \"InSC：Vowel_Dependent 0\" =カウント \"：1\" /> <クラス別-REF = \"母音-修飾語\" カウント= \"0：1\" /> </ルール> <ルール名= \"子音クラスタ\"> <ルール・カウント= \"0 +\"> <ルールによって-REF = \"子音と-オプション-nukta\" /> <クラス別-REF = \"halant\" / > </ルール> <ルールによって-REF = \"子音と-オプション-nukta\" /> <選択> <クラス別-REF = \"halant\" /> <ルールによって-REF = \"オプションの依存-母音と-opt-修飾子\"/> </選択> </ルール> <ルール名=\" akshara \"> <選択> <ルールによって-REF =\" 独立-母音と-オプション-修飾子 \"/> <ルールによって-REF =\" consonant-クラスタ」/> </選択> </ルール>"
    },
    {
      "indent": 5,
      "text": " <rule name=\"WLE-akshara-or-other\" comment=\"series of one or more aksharas, possibly alternating with other types of code points such as digits\"> <start /> <choice count=\"1+\"> <class property=\"InSC:other\" /> <rule by-ref=\"akshara\" /> </choice> <end /> </rule> <!--\"action\" elements go here - order defines precedence--> <action disp=\"invalid\" not-match=\"WLE-akshara-or-other\" /> </rules>",
      "ja": "<ルール名=「WLE-akshara  - または - 他の」コメント=「おそらく、このような数字のようなコードポイントの他のタイプと交互に一つ以上のaksharasのシリーズは、」> <開始/> <選択カウント=「1 +」> <クラスプロパティ= \"InSC：その他\" /> <ルールによって-REF = \"akshara\" /> </選択> <エンド/> </ルール> < -  \"アクション\" の要素がここに入ります - 順序が優先さを定義します - >！ <アクションDISP = \"無効\" ではない一致= \"WLE-akshara・オア・その他\" /> </ルール>"
    },
    {
      "indent": 3,
      "text": "With the rules and classes as defined above, the final action assigns a disposition of \"invalid\" to all labels that are not composed of a sequence of well-formed aksharas, optionally interspersed with other characters, perhaps digits, for example.",
      "ja": "上記で定義されたルールとクラスと、最終的なアクションが整形aksharasの配列で構成されていないすべてのラベルに「無効」の配置を割り当て、必要に応じて例えば他の文字、数字、おそらく、が点在。"
    },
    {
      "indent": 3,
      "text": "The relevant Unicode character property could be replicated by tagging repertoire values directly in the LGR; this would remove the dependency on any specific version of the Unicode Standard.",
      "ja": "関連のUnicode文字プロパティはLGRで直接レパートリー値をタグ付けすることによって複製することができ、これは、Unicode標準の任意の特定のバージョンに依存関係を削除します。"
    },
    {
      "indent": 3,
      "text": "Generally, dependent vowels may only follow consonant expressions; however, for some scripts, like Bengali, the Unicode Standard supports sequences of dependent vowels or their application on independent vowels. This makes the definition of akshara less restrictive.",
      "ja": "一般的に、従属母音は子音のみの式に従うことができます。しかし、いくつかのスクリプトのために、ベンガル語のように、Unicode標準は、従属母音または独立母音に自分のアプリケーションのシーケンスをサポートしています。これはaksharaの定義は、以下の制限になります。"
    },
    {
      "indent": 0,
      "text": "C.1. Reducing Complexity",
      "ja": "C.1。複雑さを軽減"
    },
    {
      "indent": 3,
      "text": "As presented in this example, the rules are rather complex -- although useful in demonstrating the features of the XML format, such complexity would be an undesirable feature in an actual LGR.",
      "ja": "この例で提示されるように、ルールはかなり複雑である -  XML形式の特徴を示すのに有用であるが、そのような複雑さは、実際のLGRにおいて望ましくない特徴であろう。"
    },
    {
      "indent": 3,
      "text": "It is possible to reduce the complexity of the rules in this example by defining alternate rules that simply define the permissible pair-wise context of adjacent code points by character class, such as a rule that a halant can only follow a (nuktated) consonant. Such pair-wise contexts are easier to understand, implement, and verify, and have the additional benefit of allowing tools to better pinpoint why a label failed to validate. They also tend to correspond more directly to the kind of well-formedness requirements that are most relevant to DNS security, like the requirement to limit the application of a combining mark (such as a vowel modifier) to only selected base characters (in this case, vowels). (See the example and discussion in [WLE-RULES].)",
      "ja": "単に、このようなhalantのみ子音（nuktated）に従うことができることを原則として、文字クラスによって隣接するコードポイントの許容ペアワイズコンテキストを定義する代替の規則を定義することによって、この例では、ルールの複雑さを低減することができます。このようなペアワイズコンテキストは、理解し、実装、検証、およびラベルは検証に失敗した理由のツールは、より良い突き止めるすることを可能にする追加の利点を持つことが容易です。彼らはまた、この場合に（のみ選択された基地文字（例えば母音剤として）結合マークの適用を制限するための要件と同様に、DNSセキュリティに最も関連する整形式の要求の種類により直接的に対応する傾向があります、母音）。 （[WLE-RULES]の例と議論を参照）。"
    },
    {
      "indent": 0,
      "text": "Appendix D. RELAX NG Compact Schema",
      "ja": "付録D.はNGコンパクトスキーマをRELAX"
    },
    {
      "indent": 3,
      "text": "This schema is provided in RELAX NG Compact format [RELAX-NG].",
      "ja": "このスキーマは、NGコンパクト形式[RELAX-NG]をRELAXに設けられています。"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS> # # LGR XML Schema 1.0 #",
      "ja": "<CODEが始まる> ## LGRのXML Schema 1.0＃"
    },
    {
      "indent": 3,
      "text": "default namespace = \"urn:ietf:params:xml:ns:lgr-1.0\"",
      "ja": "デフォルトの名前空間= \"壷：IETF：のparams：XML：NS：LGR-1.0\""
    },
    {
      "indent": 3,
      "text": "# # SIMPLE TYPES #",
      "ja": "##単純型＃"
    },
    {
      "indent": 3,
      "text": "# RFC 5646 language tag (e.g., \"de\", \"und-Latn\") language-tag = xsd:token",
      "ja": "＃RFC 5646の言語タグ（E. G.、 \"ド\"、 \"アンド・LATN\"）言語タグ= XSD：トークン"
    },
    {
      "indent": 3,
      "text": "# The scope to which the LGR applies. For the \"domain\" scope type, # it should be a fully qualified domain name. scope-value = xsd:token { minLength = \"1\" }",
      "ja": "＃LGRが適用される範囲。 「ドメイン」スコープタイプ、＃の場合には、完全修飾ドメイン名でなければなりません。スコープ値= XSD：トークン{はminLength = \"1\"}"
    },
    {
      "indent": 3,
      "text": "## a single code point code-point = xsd:token { pattern = \"[0-9A-F]{4,6}\" }",
      "ja": "##単一のコードポイントコードポイント= XSD：トークン{パターン= \"[0-9A-F] {4,6}\"}"
    },
    {
      "indent": 3,
      "text": "## a space-separated sequence of code points code-point-sequence = xsd:token { pattern = \"[0-9A-F]{4,6}( [0-9A-F]{4,6})+\" }",
      "ja": "##コードポイントのスペース区切りのシーケンスコードポイントシーケンス= XSD：トークン{パターン=「[0-9A-F] {4,6}（[0-9A-F] {4,6}）+ \"}"
    },
    {
      "indent": 3,
      "text": "## single code point, or a sequence of code points, or empty string code-point-literal = code-point | code-point-sequence | \"\"",
      "ja": "##単一のコードポイント、またはコードポイントのシーケンス、または空の文字列コードポイントリテラル=コードポイント|コード・ポイント・シーケンス| 「」"
    },
    {
      "indent": 3,
      "text": "## code point or sequence only non-empty-code-point-literal = code-point | code-point-sequence",
      "ja": "##コード・ポイントまたはシーケンスのみ非空コード・ポイント・リテラル=コードポイント|コード・ポイント・シーケンス"
    },
    {
      "indent": 3,
      "text": "## code point sent represented in short form code-point-set-shorthand = xsd:token { pattern = \"([0-9A-F]{4,6}|[0-9A-F]{4,6}-[0-9A-F]{4,6})\" ~ \"( ([0-9A-F]{4,6}|[0-9A-F]{4,6}-[0-9A-F]{4,6}))*\" }",
      "ja": "| [0-9A-F] {4,6} {トークンパターン=「（[0-9A-F] {4,6}：ショートフォームコード・ポイント・セット速記= XSDで表さ送ら##コード・ポイント -  [0-9A-F] {4,6}） \"〜\"（（[0-9A-F] {4,6} | [0-9A-F] {4,6}  -  [0-9A- F] {4,6}））*」}"
    },
    {
      "indent": 3,
      "text": "## dates are used in information fields in the meta ## section (\"YYYY-MM-DD\") date-pattern = xsd:token { pattern = \"\\d{4}-\\d\\d-\\d\\d\" }",
      "ja": "トークン{パターン= \" -  \\ D \\ D- \\ D \\ D \\ dの{4}\"：##日付が日付パターン= XSDメタ##部（ \"YYYY-MM-DD\"）に情報フィールドで使用されています}"
    },
    {
      "indent": 3,
      "text": "## variant type ## the variant type MUST be non-empty and MUST NOT ## start with a \"_\"; using xsd:NMTOKEN here because ## we need space-separated lists of them variant-type = xsd:NMTOKEN",
      "ja": "バリアント型が空でなければならないと##「_」で始めることはできません## ##バリアント型。 XSDを使用して：NMTOKENはここ##ので、我々はそれらのスペースで区切られたリストを必要とするバリアント型=のxsd：NMTOKEN"
    },
    {
      "indent": 3,
      "text": "## variant type list for action triggers ## the list MUST NOT be empty, and entries MUST NOT ## start with a \"_\" variant-type-list = xsd:NMTOKENS",
      "ja": "##アクションのバリアント型のリストは、リストが空にすることはできません##トリガ、およびエントリは##「_」バリアント型リストで始めることはできません=のxsd：NMTOKENS"
    },
    {
      "indent": 3,
      "text": "## reference to a rule name (used in \"when\" and \"not-when\" ## attributes, as well as the \"by-ref\" attribute of the \"rule\" ## element). rule-ref = xsd:IDREF",
      "ja": "##ルール（「いつ」で使用され、「未」##の属性、ならびに「ルール」##要素の「バイREF」属性）の名前への参照を。ルール-REF =のxsd：IDREF"
    },
    {
      "indent": 3,
      "text": "## a space-separated list of tags. Tags should generally follow ## xsd:Name syntax. However, we are using the xsd:NMTOKENS here ## because there is no native XSD datatype for space-separated ## xsd:Name tags = xsd:NMTOKENS",
      "ja": "##タグのスペースで区切られたリストが。名前の構文：タグは、一般的に## XSDに従うべきです。しかし、我々は、XSDを使用している：NMTOKENSここ##スペースで区切られた##のxsdネイティブXSDデータ型がないので：名前タグ=のxsd：NMTOKENS"
    },
    {
      "indent": 3,
      "text": "## The value space of a \"from-tag\" attribute. Although it is closer ## to xsd:IDREF lexically and semantically, tags are not unique in ## the document. As such, we are unable to take advantage of ## facilities provided by a validator. xsd:NMTOKEN is used instead ## of the stricter xsd:Names here so as to be consistent with ## the above. tag-ref = xsd:NMTOKEN",
      "ja": "「からタグ」属性の値がスペース##。それは、XSDに##近いですが：IDREFは、字句及び意味的には、タグは##文書内で一意ではありません。そのため、我々はバリが提供する機能##を利用することができません。 xsd：NMTOKENは厳しいXSDの##の代わりに使用されます。名前、ここで##以上と整合するように。タグ-REF =のxsd：NMTOKEN"
    },
    {
      "indent": 3,
      "text": "## an identifier type (used by \"name\" attributes). identifier = xsd:ID",
      "ja": "（「名前」属性によって使用される）##の識別子タイプ。識別子=のxsd：ID"
    },
    {
      "indent": 3,
      "text": "## used in the class \"by-ref\" attribute to reference another class of ## the same \"name\" attribute value. class-ref = xsd:IDREF",
      "ja": "同じ「名前」属性値##の別のクラスを参照するために##「によって-REF」クラスで使用される属性。クラス-REF =のxsd：IDREF"
    },
    {
      "indent": 3,
      "text": "## \"count\" attribute pattern (\"n\", \"n+\", or \"n:m\") count-pattern = xsd:token { pattern = \"\\d+(\\+|:\\d+)?\" }",
      "ja": "カウントパターン= XSD：トークン{パターン= ##属性パターン（ \"N\"、 \"N +\" または \"M N\"） \"カウント\" \"\\ dが+？（\\ + |：\\ D +）\" を}"
    },
    {
      "indent": 3,
      "text": "## \"ref\" attribute pattern ## space-separated list of \"id\" attribute values for ## \"reference\" elements. These reference ids ## must be declared in a \"reference\" element ## before they can be used in a \"ref\" attribute ref-pattern = xsd:token { pattern = \"[\\-_.:0-9A-Z]+( [\\-_.:0-9A-Z]+)*\" }",
      "ja": "##「REF」属性パターン##のための##「参照」要素「id」属性値のスペースで区切られたリスト。トークン{パターン=「[\\ -_：0-9A-Z]：彼らは「REF」属性REF-パターン= XSDで使用することができる前に、これらの参照IDは## ##「参照」要素内で宣言されなければなりません+（[\\ -_：0-9A-Z] +）*」}"
    },
    {
      "indent": 3,
      "text": "# # STRUCTURES #",
      "ja": "##構造体＃"
    },
    {
      "indent": 3,
      "text": "## Representation of a single code point or a sequence of code ## points char = element char { attribute cp { code-point-literal }, attribute comment { text }?, attribute when { rule-ref }?, attribute not-when { rule-ref }?, attribute tag { tags }?, attribute ref { ref-pattern }?, variant* }",
      "ja": "単一のコードポイントまたはコード##点チャー=エレメントチャー{属性CP {コードポイントリテラル}、属性コメント{テキスト} ?,属性場合{ルール-REF}？属性の配列の##表現not-場合{ルール-REF}？属性タグ{タグ} ?, REF {REF-パターン}？バリアント*を}属性"
    },
    {
      "indent": 3,
      "text": "## Representation of a range of code points range = element range { attribute first-cp { code-point }, attribute last-cp { code-point }, attribute comment { text }?, attribute when { rule-ref }?, attribute not-when { rule-ref }?, attribute tag { tags }?, attribute ref { ref-pattern }? }",
      "ja": "##コードポイントの範囲の表現は=エレメント範囲{最初-CP {コードポイント属性}、最後-CP {コードポイントを}属性、属性コメント{テキスト} ?,属性場合{ルール-REFを}の範囲？ -ないときは、{ルール-REF}？属性タグ{タグ} ?, REF {REF-パターンを}属性属性？ }"
    },
    {
      "indent": 3,
      "text": "## Representation of a variant code point or sequence variant = element var { attribute cp { code-point-literal }, attribute type { xsd:NMTOKEN }?, attribute when { rule-ref }?, attribute not-when { rule-ref }?, attribute comment { text }?, attribute ref { ref-pattern }? }",
      "ja": "##バリアントコードポイントまたは配列変異体の表現=素子VAR {属性CP {コードポイントリテラル}、属性タイプ{XSD：NMTOKEN} ?,属性場合{ルール-refは}？ない-場合{rule-属性REF} ?,属性コメント{テキスト} ?,属性REF {REF-パターン}？ }"
    },
    {
      "indent": 3,
      "text": "# # Classes #",
      "ja": "＃ ＃ クラス ＃"
    },
    {
      "indent": 3,
      "text": "## a \"class\" element that references the name of another \"class\" ## (or set-operator like \"union\") defined elsewhere. ## If used as a matcher (appearing under a \"rule\" element), ## the \"count\" attribute may be present. class-invocation = element class { class-invocation-content }",
      "ja": "他の場所で定義された（「ユニオン」のようなまたはセットオペレータ）別の「クラス」##の名前を参照する##「クラス」要素。 （「ルール」要素の下に現れる）マッチャーとして使用した場合##、##「カウント」属性が存在してもよいです。クラス呼び出し=要素クラス{クラスの呼び出しコンテンツ}"
    },
    {
      "indent": 3,
      "text": "class-invocation-content = attribute by-ref { class-ref }, attribute count { count-pattern }?, attribute comment { text }?",
      "ja": "クラスの呼び出し-コンテンツは=属性によって-REF {クラス-REF}、？、属性コメント{テキスト} {パターンカウント}カウント属性？"
    },
    {
      "indent": 3,
      "text": "## defines a new class (set of code points) using Unicode property ## or code points of the same tag value or code point literals class-declaration = element class { class-declaration-content }",
      "ja": "##（コードポイントのセット）のUnicodeプロパティ##または同一のタグ値またはコードポイントリテラルクラス宣言=要素クラス{クラス宣言コンテンツ}のコードポイントを使用して、新しいクラスを定義"
    },
    {
      "indent": 3,
      "text": "class-declaration-content = # \"name\" attribute MUST be present if this is a \"top-level\" # class declaration, i.e., appearing directly under the \"rules\" # element. Otherwise, it MUST be absent. attribute name { identifier }?, # If used as a matcher (appearing in a \"rule\" element, but not # when nested inside a set-operator or class), the \"count\" # attribute may be present. Otherwise, it MUST be absent. attribute count { count-pattern }?, attribute comment { text }?, attribute ref { ref-pattern }?, ( # define the class by property (e.g., property=\"sc:Latn\"), OR attribute property { xsd:NMTOKEN } # define the class by tagged code points, OR | attribute from-tag { tag-ref } # text node to allow for shorthand notation # e.g., \"0061 0062-0063\" | code-point-set-shorthand )",
      "ja": "これは、「トップレベル」＃クラス宣言である場合、クラス宣言コンテンツ=＃「name」属性が存在しなければならない、すなわち、「ルール」＃要素の下に直接現れます。そうでなければ、それは存在してはなりません。 （セットオペレータまたはクラス内にネストされたときに「ルール」要素に現れなく、＃）マッチャーとして使用する場合名{識別子}？＃属性、「カウント」＃属性が存在してもよいです。そうでなければ、それは存在してはなりません。 ）、またはプロパティ{XSD属性：＃プロパティにより、クラス（例えば、プロパティ= \"LATN SC\" を定義（？、？、属性のコメント{テキスト}参照{REF-パターンを}属性?, {-パターンはカウント}カウント属性NMTOKEN}＃タグ付けされたコードポイント、ORによってクラスを定義|）コード・ポイント・セット速記|「0062から0063 0061」、速記表記＃1などを可能にするために、属性からタグ{タグ-REF}＃テキスト・ノード"
    },
    {
      "indent": 3,
      "text": "class-invocation-or-declaration = element class { class-invocation-content | class-declaration-content }",
      "ja": "クラス呼び出し、または宣言=要素クラス{クラスの呼び出しコンテンツ|クラス宣言コンテンツ}"
    },
    {
      "indent": 3,
      "text": "class-or-set-operator-nested = class-invocation-or-declaration | set-operator",
      "ja": "クラスまたはセットオペレータネスト=クラスの呼び出し-または宣言|セット演算子"
    },
    {
      "indent": 3,
      "text": "class-or-set-operator-declaration = # a \"class\" element or set-operator (effectively defining a class) # directly in the \"rules\" element. class-declaration | set-operator",
      "ja": "クラスまたはセット・オペレータ宣言=＃「クラス」要素またはセットオペレータが「ルール」要素に直接＃（効果的にクラスを定義します）。クラス宣言|セット演算子"
    },
    {
      "indent": 3,
      "text": "# # set-operators #",
      "ja": "##セット演算子＃"
    },
    {
      "indent": 3,
      "text": "complement-operator = element complement { attribute name { identifier }?, attribute comment { text }?, attribute ref { ref-pattern }?, # \"count\" attribute MUST only be used when this set-operator is # used as a matcher (i.e., nested in a \"rule\" element but not # inside a set-operator or class) attribute count { count-pattern }?, class-or-set-operator-nested }",
      "ja": "補体演算子=エレメント補体{属性名{識別子}？属性コメント{テキスト} ?,属性REF {REF-パターン}？＃セットオペレータが整合として使用＃とき属性にのみ使用しなければならない「カウント」 （すなわち、「ルール」要素にネストが、セットオペレータまたはクラス内部ではない＃）} {カウントパターン}カウント？クラスまたはセット・オペレータネストされた属性"
    },
    {
      "indent": 3,
      "text": "union-operator = element union { attribute name { identifier }?, attribute comment { text }?, attribute ref { ref-pattern }?, # \"count\" attribute MUST only be used when this set-operator is # used as a matcher (i.e., nested in a \"rule\" element but not # inside a set-operator or class) attribute count { count-pattern }?, class-or-set-operator-nested, # needs two or more child elements class-or-set-operator-nested+ } intersection-operator = element intersection { attribute name { identifier }?, attribute comment { text }?, attribute ref { ref-pattern }?, # \"count\" attribute MUST only be used when this set-operator is # used as a matcher (i.e., nested in a \"rule\" element but not # inside a set-operator or class) attribute count { count-pattern }?, class-or-set-operator-nested, class-or-set-operator-nested }",
      "ja": "組合オペレータ=要素の組合は、{名前{識別子}？属性コメント{テキスト}属性?, REF {REF-パターン}？＃属性セットオペレータが＃整合器として使用する場合、属性のみを使用しなければなりません「カウント」 （すなわち、「ルール」要素にネストが、セットオペレータまたはクラス内部ではない＃）{カウントパターン}カウント？クラスまたはセット・オペレータネスト属性、＃は、二つ以上の子要素のクラスまたは必要-setオペレータネスト+}交差点オペレータ=要素の交点が属性のみを使用しなければなりません「カウント」REF {REF-パターン}？＃属性？？属性コメント{テキスト} {名前{識別子属性}ときに、このセット - オペレータが整合として使用＃（すなわち、セットオペレータまたはクラス内の＃「ルール」要素にネストではなく）{カウントパターン}カウント？クラスまたはセットオペレータネスト、クラス、または属性-setオペレータネスト}"
    },
    {
      "indent": 3,
      "text": "difference-operator = element difference { attribute name { identifier }?, attribute comment { text }?, attribute ref { ref-pattern }?, # \"count\" attribute MUST only be used when this set-operator is # used as a matcher (i.e., nested in a \"rule\" element but not # inside a set-operator or class) attribute count { count-pattern }?, class-or-set-operator-nested, class-or-set-operator-nested }",
      "ja": "差分演算子=エレメント差{属性?,名{識別子}？属性コメント{テキスト}属性REF {REF-パターン}？＃セットオペレータが整合として使用＃とき属性にのみ使用しなければならない「カウント」 （すなわち、「ルール」要素にネストが、セットオペレータまたはクラス内部ではない＃）{カウントパターン}カウント？クラスまたはセット・オペレータネスト、クラスまたはセットオペレータネストを}属性"
    },
    {
      "indent": 3,
      "text": "symmetric-difference-operator = element symmetric-difference { attribute name { identifier }?, attribute comment { text }?, attribute ref { ref-pattern }?, # \"count\" attribute MUST only be used when this set-operator is # used as a matcher (i.e., nested in a \"rule\" element but not # inside a set-operator or class) attribute count { count-pattern }?, class-or-set-operator-nested, class-or-set-operator-nested }",
      "ja": "対称差分演算子=要素の対称差{属性名{識別子}？属性コメント{テキスト} ?, REF {REF-パターンを}属性？＃このセットオペレータは＃とき属性にのみ使用しなければならない「カウント」整合器として使用される（すなわち、「ルール」要素にネストが、セットオペレータまたはクラス内部ではない＃）{パターンをカウント}カウント？クラスまたはセット・オペレータネスト属性、クラス、または、セット - オペレータネスト}"
    },
    {
      "indent": 3,
      "text": "## operators that transform class(es) into a new class. set-operator = complement-operator | union-operator | intersection-operator | difference-operator | symmetric-difference-operator",
      "ja": "##新しいクラスにクラス（複数可）変換演算子。セット演算子=補数演算子|組合演算子|交差点、演算子|差分演算子|対称差オペレータ"
    },
    {
      "indent": 3,
      "text": "# # Match operators (matchers) #",
      "ja": "##マッチ演算子（マッチャ）＃"
    },
    {
      "indent": 3,
      "text": "any-matcher = element any { attribute count { count-pattern }?, attribute comment { text }? }",
      "ja": "任意のマッチャー=要素の任意{属性数{カウントパターン} ?,属性コメント{テキスト}？ }"
    },
    {
      "indent": 3,
      "text": "choice-matcher = element choice { ## \"count\" attribute MUST only be used when the choice-matcher ## contains no nested \"start\", \"end\", \"anchor\", \"look-behind\", ## or \"look-ahead\" operators and no nested rule-matchers ## containing any of these elements attribute count { count-pattern }?, attribute comment { text }?, # two or more match operators match-operator-choice, match-operator-choice+ }",
      "ja": "選択マッチャー=要素の選択{##属性は、ときにのみ選択-マッチャーを使用しなければならない「カウント」##ネストされた、「ルックビハインド」、「終了」、「アンカー」、「起動しない」##や「ルック含まれていこれらの要素のいずれかを含む-ahead」演算子となしネストされたルールのmatcherは、##カウント{カウントパターン}？属性コメント{テキスト}？＃二つ以上の一致オペレータがマッチオペレータ選択、マッチオペレータの選択肢+属性}"
    },
    {
      "indent": 3,
      "text": "char-matcher = # for use as a matcher - like \"char\" but without a \"tag\" attribute element char { attribute cp { non-empty-code-point-literal }, # If used as a matcher (appearing in a \"rule\" element), the # \"count\" attribute may be present. Otherwise, it MUST be # absent. attribute count { count-pattern }?, attribute comment { text }?, attribute ref { ref-pattern }? }",
      "ja": "チャー整合=マッチャーとして使用するための＃ - 「文字」等が、「タグ」属性要素チャー{属性CPは{空でないコード・ポイントリテラル}せず、＃整合器として使用する場合（ \"に登場ルール」要素）、＃は 『カウント』属性が存在することができます。それ以外の場合は、＃に存在してはなりません。属性?,？、属性コメント{テキスト} {パターンを数える} {REF REF-パターンを}カウント属性？ }"
    },
    {
      "indent": 3,
      "text": "start-matcher = element start { attribute comment { text }? }",
      "ja": "=要素の開始{属性コメント{テキスト}マッチャーを開始？ }"
    },
    {
      "indent": 3,
      "text": "end-matcher = element end { attribute comment { text }? }",
      "ja": "エンド・マッチャー=素子端{属性コメント{テキスト}？ }"
    },
    {
      "indent": 3,
      "text": "anchor-matcher = element anchor { attribute comment { text }? } look-ahead-matcher = element look-ahead { attribute comment { text }?, match-operators-non-pos } look-behind-matcher = element look-behind { attribute comment { text }?, match-operators-non-pos }",
      "ja": "アンカーマッチャー=要素アンカー{属性コメント{テキスト}？ }先読みマッチャー=要素先読み{属性コメント{テキスト} ?,マッチ演算子非POS}見てビハインド・マッチャー=要素ルックビハインド{属性コメント{テキスト} ?,マッチ演算子、非-pos}"
    },
    {
      "indent": 3,
      "text": "## non-positional match operator that can be used as a direct child ## element of the choice-matcher. match-operator-choice = ( any-matcher | choice-matcher | start-matcher | end-matcher | char-matcher | class-or-set-operator-nested | rule-matcher )",
      "ja": "##の選択肢マッチャーの直接の子要素##として使用できる非位置マッチ演算子。マッチ演算子-選択肢=（任意のマッチャー|選択肢マッチャー|スタートマッチャー|エンド・マッチャー|チャーマッチャー|クラスまたはセット・オペレータにネスト|ルールマッチャー）"
    },
    {
      "indent": 3,
      "text": "## non-positional match operators do not contain any \"anchor\", ## \"look-behind\", or \"look-ahead\" elements. match-operators-non-pos = ( start-matcher?, (any-matcher | choice-matcher | char-matcher | class-or-set-operator-nested | rule-matcher)*, end-matcher? )",
      "ja": "##非位置マッチ演算子は、任意の「アンカー」が含まれていません##「ルックビハインド」、または「先読み」の要素。マッチ演算子非POS =（？マッチャーを開始する（任意のマッチャー|選択肢マッチャー|チャーマッチャー|クラスまたはセット・オペレータにネスト|ルールマッチャー）*、エンドマッチャ？）"
    },
    {
      "indent": 3,
      "text": "## positional match operators have an \"anchor\" element, which may be ## preceded by a \"look-behind\" element, or followed by a \"look-ahead\" ## element, or both. match-operators-pos = look-behind-matcher?, anchor-matcher, look-ahead-matcher?",
      "ja": "##位置マッチ演算子は「アンカー」##「ルックビハインド」要素が先行し、又は「ルックアヘッド」を##要素が続くことができる要素、またはその両方を有します。マッチ演算子-POS =ルックの背後にマッチャー?,アンカー・マッチャー、先読みマッチャー？"
    },
    {
      "indent": 3,
      "text": "match-operators = match-operators-non-pos | match-operators-pos",
      "ja": "マッチ演算子=マッチ演算子非POS |マッチ演算子-POS"
    },
    {
      "indent": 3,
      "text": "# # Rules #",
      "ja": "##ルール＃"
    },
    {
      "indent": 3,
      "text": "# top-level rule must have \"name\" attribute rule-declaration-top = element rule { attribute name { identifier }, attribute comment { text }?, attribute ref { ref-pattern }?, match-operators }",
      "ja": "＃トップレベルのルールは、{？属性名{識別子}、属性コメント{テキスト} REF {REF-パターンを}属性？マッチ演算子}「name」属性ルール宣言トップ=要素のルールを有していなければなりません"
    },
    {
      "indent": 3,
      "text": "## \"rule\" element used as a matcher (either \"by-ref\" or contains ## other match operators itself) rule-matcher = element rule { ## \"count\" attribute MUST only be used when the rule-matcher ## contains no nested \"start\", \"end\", \"anchor\", \"look-behind\", ## or \"look-ahead\" operators and no nested rule-matchers ## containing any of these elements attribute count { count-pattern }?, attribute comment { text }?, attribute ref { ref-pattern }?, (attribute by-ref { rule-ref } | match-operators) }",
      "ja": "##整合器として使用される「ルール」要素（いずれかの「バイREF」又は含ま##の他のマッチ演算子自体）ルール整合=エレメントルール{##属性場合にのみルール整合を使用しなければなりません「カウント」##これらの要素のいずれかを含む##、「ルックビハインド」、「終了」、「アンカー」、「開始」##または「先読み」の演算子なしネストされたルールにマッチャネストされたが含まれていない属性{パターンカウント}カウント？、属性コメント{テキスト} ?,参照{REF-パターン} ?,（属性によって-REF {ルール-REF} |マッチ演算子）属性}"
    },
    {
      "indent": 3,
      "text": "# # Actions #",
      "ja": "＃ ＃ 行動 ＃"
    },
    {
      "indent": 3,
      "text": "action-declaration = element action { attribute comment { text }?, attribute ref { ref-pattern }?, # dispositions are often named after variant types or vice versa attribute disp { variant-type }, ( attribute match { rule-ref } | attribute not-match { rule-ref } )?, ( attribute any-variant { variant-type-list } | attribute all-variants { variant-type-list } | attribute only-variants { variant-type-list } )? }",
      "ja": "アクション宣言=エレメントアクション{属性コメント{テキスト} ?, REF {REF-パターンを}属性？＃処分は、しばしば、変異型、またはその逆にちなんで命名されたDISP {変異型を}属性（属性一致{ルール-REF} |属性ではありません一致{ルール-REF}）？（任意のバリアント{バリアント型リストを}属性|すべてのバリアント{バリアント型リストを}属性|属性のみ、バリアント{バリアント型リスト}） ？ }"
    },
    {
      "indent": 3,
      "text": "# DOCUMENT STRUCTURE",
      "ja": "＃文書構造"
    },
    {
      "indent": 3,
      "text": "start = lgr lgr = element lgr { meta-section?, data-section, rules-section? }",
      "ja": "= LGR LGR =素子LGR {メタセクション？データセクション、ルール・セクションを開始？ }"
    },
    {
      "indent": 3,
      "text": "## Meta section - information recorded with an LGR that generally ## does not affect machine processing (except for \"unicode-version\"). ## However, if any \"class-declaration\" uses the \"property\" attribute, ## a \"unicode-version\" element MUST be present. meta-section = element meta { element version { attribute comment { text }?, text }? & element date { date-pattern }? & element language { language-tag }* & element scope { # type may by \"domain\" or an application-defined value attribute type { xsd:NCName }, scope-value }* & element validity-start { date-pattern }? & element validity-end { date-pattern }? & element unicode-version { xsd:token { pattern = \"\\d+\\.\\d+\\.\\d+\" } }? & element description { # this SHOULD be a valid MIME type attribute type { text }?, text }?",
      "ja": "##メタセクション - 一般に##（「ユニコードバージョン」を除く）の機械処理に影響を与えないLGRで記録された情報。任意の「クラス宣言は、」「プロパティ」属性を使用している場合##しかし、##「ユニコード・バージョン」の要素が存在しなければなりません。メタセクション=要素メタ{要素のバージョン{属性コメント{テキスト} ?,テキスト}？ ＆素子日{日付パターン}？ ＆素子言語{言語タグ} *＆素子スコープ{＃タイプが「ドメイン」又はアプリケーション定義値属性タイプ{XSDによってもよい：NCNameで}、スコープ、値} *＆エレメント有効開始{日付パターン}？ ＆要素の有効性エンド{日付パターン}？ ＆素子ユニコードバージョン{XSD：トークン{パターン=} \"\\ D + \\ \\ D + \\ \\ D +。。\"}？ ＆要素の説明{＃これは有効なMIMEタイプ属性タイプ{テキスト} ?,テキストであるべきですか}？"
    },
    {
      "indent": 3,
      "text": " & element references { element reference { attribute id { xsd:token { # limit \"id\" attribute to uppercase letters, # digits, and a few punctuation marks; use of # integers is RECOMMENDED pattern = \"[\\-_.:0-9A-Z]*\" minLength = \"1\" } }, attribute comment { text }?, text }* }? }",
      "ja": "＆素子参照{素子参照{属性ID {XSD：大文字、＃数字、およびいくつかの句読点にトークン{＃制限「id」属性。 ＃整数の使用パターンを推奨されている= \"[\\ -_：0-9A-Z] *\" はminLength = \"1\"}}、属性コメント{テキスト} ?,テキスト} *}？ }"
    },
    {
      "indent": 3,
      "text": "data-section = element data { (char | range)+ }",
      "ja": "データセクション=要素データ{（CHAR |範囲）+}"
    },
    {
      "indent": 3,
      "text": "## Note that action declarations are strictly order dependent. ## class-or-set-operator-declaration and rule-declaration-top ## are weakly order dependent; they must precede first use of the ## identifier via \"by-ref\". rules-section = element rules { ( class-or-set-operator-declaration | rule-declaration-top | action-declaration)* }",
      "ja": "##そのアクション宣言は厳密に依存ご注文されることに注意してください。 ##クラスまたはセット・オペレータ宣言とルール宣言トップ##弱く依存注文されています。彼らは、「バイ・参照」を経由して##識別子の最初の使用の前に置く必要があります。ルールセクション=エレメントルール{（クラス又はセットオペレータ宣言|ルール宣言トップ|アクション宣言）*}"
    },
    {
      "indent": 3,
      "text": "<CODE ENDS>",
      "ja": "<CODEはENDS>"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "This format builds upon the work on documenting IDN tables by many different registry operators. Notably, a comprehensive language table for Chinese, Japanese, and Korean was developed by the \"Joint Engineering Team\" [RFC3743]; this table is the basis of many registry policies. Also, a set of guidelines for Arabic script registrations [RFC5564] was published by the Arabic-language community.",
      "ja": "この形式は、多くの異なるレジストリ事業者がIDNテーブルを文書化の作業に基づいて構築します。特に、中国語、日本語、韓国語のための包括的な言語テーブルは、「共同エンジニアリングチーム」[RFC3743]によって開発されました。この表には、多くのレジストリ政策の基礎となっています。また、アラビア文字の登録[RFC5564]のためのガイドラインのセットは、アラビア語のコミュニティによって公開されていました。"
    },
    {
      "indent": 3,
      "text": "Contributions that have shaped this document have been provided by Francisco Arias, Julien Bernard, Mark Davis, Martin Duerst, Paul Hoffman, Sarmad Hussain, Barry Leiba, Alexander Mayrhofer, Alexey Melnikov, Nicholas Ostler, Thomas Roessler, Audric Schiltknecht, Steve Sheng, Michel Suignard, Andrew Sullivan, Wil Tan, and John Yunker.",
      "ja": "このドキュメントを形作ってきた貢献はフランシスコ・アリアス、ジュリアン・バーナード、マーク・デイビス、マーティンDuerst、ポール・ホフマン、Sarmadフセイン、バリー・レイバ、アレクサンダーMayrhofer、アレクセイ・メルニコフ、ニコラス・オストラ、トーマスレスラー、Audric Sc​​hiltknecht、スティーブ盛、ミシェルによって提供されていますSuignard、アンドリュー・サリバン、ウィルタン、ジョンユンケル。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Kim Davies Internet Corporation for Assigned Names and Numbers 12025 Waterfront Drive Los Angeles, CA 90094 United States of America",
      "ja": "キム・デイヴィスインターネット株割り当てられた名前と番号12025ウォーターフロントドライブロサンゼルス、CAアメリカの90094米国の"
    },
    {
      "indent": 3,
      "text": "Phone: +1 310 301 5800 Email: kim.davies@icann.org URI: http://www.icann.org/",
      "ja": "電話：+1 310 301 5800 Eメール：kim.davies@icann.org URI：http://www.icann.org/"
    },
    {
      "indent": 3,
      "text": "Asmus Freytag ASMUS, Inc.",
      "ja": "AsmusフライタークASMUS株式会社"
    },
    {
      "indent": 3,
      "text": "Email: asmus@unicode.org",
      "ja": "メール：asmus@unicode.org"
    }
  ]
}