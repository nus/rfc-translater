{
  "title": {
    "text": "RFC 7693 - The BLAKE2 Cryptographic Hash and Message Authentication Code (MAC)",
    "ja": "RFC 7693 - BLAKE2暗号化ハッシュとメッセージ認証コード（MAC）"
  },
  "number": 7693,
  "created_at": "2019-11-01 06:59:55.433598+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Independent Submission                                M-J. Saarinen, Ed.\nRequest for Comments: 7693                    Queen's University Belfast\nCategory: Informational                                    J-P. Aumasson\nISSN: 2070-1721                                        Kudelski Security\n                                                           November 2015",
      "raw": true
    },
    {
      "indent": 2,
      "text": "The BLAKE2 Cryptographic Hash and Message Authentication Code (MAC)",
      "ja": "BLAKE2暗号化ハッシュとメッセージ認証コード（MAC）"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document describes the cryptographic hash function BLAKE2 and makes the algorithm specification and C source code conveniently available to the Internet community. BLAKE2 comes in two main flavors: BLAKE2b is optimized for 64-bit platforms and BLAKE2s for smaller architectures. BLAKE2 can be directly keyed, making it functionally equivalent to a Message Authentication Code (MAC).",
      "ja": "この文書は、暗号学的ハッシュ関数BLAKE2を説明し、インターネットコミュニティにアルゴリズムの仕様とCのソースコードは、便利な利用できるようになります。 BLAKE2は、主に2つの種類があります：BLAKE2bは小さいアーキテクチャの64ビット・プラットフォームとBLAKE2sのために最適化されています。 BLAKE2直接メッセージ認証コード（MAC）と、それが機能的に同等の製造、キー止めすることができます。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "ja": "このドキュメントはインターネット標準化過程仕様ではありません。それは、情報提供の目的のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This is a contribution to the RFC Series, independently of any other RFC stream. The RFC Editor has chosen to publish this document at its discretion and makes no statement about its value for implementation or deployment. Documents approved for publication by the RFC Editor are not a candidate for any level of Internet Standard; see Section 2 of RFC 5741.",
      "ja": "これは、独立して、他のRFCストリームの、RFCシリーズへの貢献です。 RFC Editorはその裁量でこの文書を公開することを選択し、実装や展開のためにその値についての声明を出すていません。 RFC編集者によって公表のために承認されたドキュメントは、インターネット標準の任意のレベルの候補ではありません。 RFC 5741のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7693.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7693で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2015 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2015 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction and Terminology  . . . . . . . . . . . . . . . .   3\n2.  Conventions, Variables, and Constants . . . . . . . . . . . .   4\n  2.1.  Parameters  . . . . . . . . . . . . . . . . . . . . . . .   4\n  2.2.  Other Constants and Variables . . . . . . . . . . . . . .   4\n  2.3.  Arithmetic Notation . . . . . . . . . . . . . . . . . . .   4\n  2.4.  Little-Endian Interpretation of Words as Bytes  . . . . .   5\n  2.5.  Parameter Block . . . . . . . . . . . . . . . . . . . . .   5\n  2.6.  Initialization Vector . . . . . . . . . . . . . . . . . .   6\n  2.7.  Message Schedule SIGMA  . . . . . . . . . . . . . . . . .   6\n3.  BLAKE2 Processing . . . . . . . . . . . . . . . . . . . . . .   7\n  3.1.  Mixing Function G . . . . . . . . . . . . . . . . . . . .   7\n  3.2.  Compression Function F  . . . . . . . . . . . . . . . . .   8\n  3.3.  Padding Data and Computing a BLAKE2 Digest  . . . . . . .   9\n4.  Standard Parameter Sets and Algorithm Identifiers . . . . . .  10\n5.  Security Considerations . . . . . . . . . . . . . . . . . . .  11\n6.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  11\n  6.1.  Normative References  . . . . . . . . . . . . . . . . . .  11\n  6.2.  Informative References  . . . . . . . . . . . . . . . . .  11\nAppendix A.  Example of BLAKE2b Computation . . . . . . . . . . .  13\nAppendix B.  Example of BLAKE2s Computation . . . . . . . . . . .  15\nAppendix C.  BLAKE2b Implementation C Source  . . . . . . . . . .  16\n  C.1.  blake2b.h . . . . . . . . . . . . . . . . . . . . . . . .  16\n  C.2.  blake2b.c . . . . . . . . . . . . . . . . . . . . . . . .  17\nAppendix D.  BLAKE2s Implementation C Source  . . . . . . . . . .  21\n  D.1.  blake2s.h . . . . . . . . . . . . . . . . . . . . . . . .  21\n  D.2.  blake2s.c . . . . . . . . . . . . . . . . . . . . . . . .  22\nAppendix E.  BLAKE2b and BLAKE2s Self-Test Module C Source  . . .  26\nAcknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  29\nAuthors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  30",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction and Terminology",
      "section_title": true,
      "ja": "1.はじめと用語"
    },
    {
      "indent": 3,
      "text": "The BLAKE2 cryptographic hash function [BLAKE2] was designed by Jean-Philippe Aumasson, Samuel Neves, Zooko Wilcox-O'Hearn, and Christian Winnerlein.",
      "ja": "BLAKE2暗号ハッシュ関数は、[BLAKE2]ジャン・フィリップAumasson、サミュエルネベス、ズック・ウィルコックス・オハーン、およびクリスチャンWinnerleinによって設計されました。"
    },
    {
      "indent": 3,
      "text": "BLAKE2 comes in two basic flavors:",
      "ja": "BLAKE2は、2つの基本的な種類があります："
    },
    {
      "indent": 3,
      "text": "o BLAKE2b (or just BLAKE2) is optimized for 64-bit platforms and produces digests of any size between 1 and 64 bytes.",
      "ja": "O BLAKE2b（または単にBLAKE2）は、64ビットプラットフォーム用に最適化され、1と64バイトとの間の任意のサイズのダイジェストを生成します。"
    },
    {
      "indent": 3,
      "text": "o BLAKE2s is optimized for 8- to 32-bit platforms and produces digests of any size between 1 and 32 bytes.",
      "ja": "O BLAKE2sは、8〜32ビットプラットフォーム用に最適化され、1と32バイトとの間の任意のサイズのダイジェストを生成します。"
    },
    {
      "indent": 3,
      "text": "Both BLAKE2b and BLAKE2s are believed to be highly secure and perform well on any platform, software, or hardware. BLAKE2 does not require a special \"HMAC\" (Hashed Message Authentication Code) construction for keyed message authentication as it has a built-in keying mechanism.",
      "ja": "BLAKE2bとBLAKE2sの両方が、非常に安全であると、任意のプラットフォーム、ソフトウェア、またはハードウェア上でうまく実行すると考えられています。それが内蔵されているように仕組みをキーイングBLAKE2は鍵付きメッセージ認証のための特別な「HMAC」（ハッシュメッセージ認証コード）工事を必要としません。"
    },
    {
      "indent": 3,
      "text": "The BLAKE2 hash function may be used by digital signature algorithms and message authentication and integrity protection mechanisms in applications such as Public Key Infrastructure (PKI), secure communication protocols, cloud storage, intrusion detection, forensic suites, and version control systems.",
      "ja": "BLAKE2ハッシュ関数は、公開鍵基盤（PKI）などのアプリケーションでデジタル署名アルゴリズムとメッセージ認証と完全性保護機構、セキュア通信プロトコル、クラウドストレージ、侵入検出、法医学スイート、バージョン管理システムによって使用されてもよいです。"
    },
    {
      "indent": 3,
      "text": "The BLAKE2 suite provides a more efficient alternative to US Secure Hash Algorithms SHA and HMAC-SHA [RFC6234]. BLAKE2s-128 is especially suited as a fast and more secure drop-in replacement to MD5 and HMAC-MD5 in legacy applications [RFC6151].",
      "ja": "BLAKE2スイートは、米国セキュアハッシュアルゴリズムSHAとHMAC-SHA [RFC6234]に、より効率的な代替手段を提供します。 BLAKE2s-128は、高速かつより安全なドロップイン置換MD5とHMAC-MD5にレガシーアプリケーション[RFC6151]のように特に適しています。"
    },
    {
      "indent": 3,
      "text": "To aid implementation, we provide a trace of BLAKE2b-512 hash computation in Appendix A and a trace of BLAKE2s-256 hash computation in Appendix B. Due to space constraints, this document does not contain a full set of test vectors for BLAKE2.",
      "ja": "実装を支援するために、我々はスペースの制約BLAKE2b-512ハッシュ付録Aでの計算と付録BでBLAKE2s-256ハッシュ計算のトレースのトレースを提供し、この文書はBLAKE2のためのテストベクトルのフルセットが含まれていません。"
    },
    {
      "indent": 3,
      "text": "A reference implementation in C programming language for BLAKE2b can be found in Appendix C and for BLAKE2s in Appendix D of this document. These implementations MAY be validated with the more exhaustive Test Module contained in Appendix E.",
      "ja": "BLAKE2bためのCプログラミング言語のリファレンス実装は、付録Cに、このドキュメントの付録DにBLAKE2sために見出すことができます。これらの実装は、付録Eに含まれる、より徹底的なテストモジュールで検証されるかもしれません"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はあります[RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "2. Conventions, Variables, and Constants",
      "section_title": true,
      "ja": "2.規則、変数、定数"
    },
    {
      "indent": 0,
      "text": "2.1. Parameters",
      "section_title": true,
      "ja": "2.1. パラメーター"
    },
    {
      "indent": 3,
      "text": "The following table summarizes various parameters and their ranges:",
      "ja": "次の表は、さまざまなパラメータとその範囲を要約したものです。"
    },
    {
      "indent": 14,
      "text": "              | BLAKE2b          | BLAKE2s          |\n--------------+------------------+------------------+\n Bits in word | w = 64           | w = 32           |\n Rounds in F  | r = 12           | r = 10           |\n Block bytes  | bb = 128         | bb = 64          |\n Hash bytes   | 1 <= nn <= 64    | 1 <= nn <= 32    |\n Key bytes    | 0 <= kk <= 64    | 0 <= kk <= 32    |\n Input bytes  | 0 <= ll < 2**128 | 0 <= ll < 2**64  |\n--------------+------------------+------------------+\n G Rotation   | (R1, R2, R3, R4) | (R1, R2, R3, R4) |\n  constants = | (32, 24, 16, 63) | (16, 12,  8,  7) |\n--------------+------------------+------------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "2.2. Other Constants and Variables",
      "section_title": true,
      "ja": "2.2. その他の定数と変数"
    },
    {
      "indent": 3,
      "text": "These variables are used in the algorithm description:",
      "ja": "これらの変数は、アルゴリズムの説明で使用されています。"
    },
    {
      "indent": 3,
      "text": "IV[0..7] Initialization Vector (constant).",
      "ja": "IV [0..7]初期化ベクトル（定数）。"
    },
    {
      "indent": 3,
      "text": "SIGMA[0..9] Message word permutations (constant).",
      "ja": "SIGMA [0..9]メッセージワードの順列（定数）。"
    },
    {
      "indent": 3,
      "text": "p[0..7] Parameter block (defines hash and key sizes).",
      "ja": "P [0..7]パラメータブロック（ハッシュと鍵のサイズを定義します）。"
    },
    {
      "indent": 3,
      "text": "m[0..15] Sixteen words of a single message block.",
      "ja": "単一のメッセージブロックの16のワードは、[0..15] mです。"
    },
    {
      "indent": 3,
      "text": "h[0..7] Internal state of the hash.",
      "ja": "ハッシュのHは[0..7]内部状態。"
    },
    {
      "indent": 3,
      "text": "d[0..dd-1] Padded input blocks. Each has \"bb\" bytes.",
      "ja": "D [0..dd-1]パッド入り入力ブロック。それぞれ「BB」のバイトを持っています。"
    },
    {
      "indent": 3,
      "text": "t Message byte offset at the end of the current block.",
      "ja": "現在のブロックの終わりにオフセットトンメッセージバイト。"
    },
    {
      "indent": 3,
      "text": "f Flag indicating the last block.",
      "ja": "最後のブロックであることを示すフラグf。"
    },
    {
      "indent": 0,
      "text": "2.3. Arithmetic Notation",
      "section_title": true,
      "ja": "2.3. 算術表記"
    },
    {
      "indent": 3,
      "text": "For real-valued x, we define the following functions:",
      "ja": "実数xに対して、我々は次の関数を定義します。"
    },
    {
      "indent": 3,
      "text": "floor(x) Floor, the largest integer <= x.",
      "ja": "フロア（x）の床、最大の整数<= xで。"
    },
    {
      "indent": 3,
      "text": "ceil(x) Ceiling, the smallest integer >= x.",
      "ja": "CEIL（X）天井、最小の整数> = X。"
    },
    {
      "indent": 3,
      "text": "frac(x) Positive fractional part of x, frac(x) = x - floor(x).",
      "ja": "FRAC（x）はxの正の小数部分、FRAC（X）= Xの - フロア（x）です。"
    },
    {
      "indent": 3,
      "text": "Operator notation in pseudocode:",
      "ja": "擬似コードでオペレータ表記："
    },
    {
      "indent": 3,
      "text": "2**n = 2 to the power \"n\". 2**0=1, 2**1=2, 2**2=4, 2**3=8, etc.",
      "ja": "電源 \"n\" は2 ** N = 2。 2 ** 0 = 1、** 1 = 2 2、** 2 = 4 2、** 3 = 8 2、等"
    },
    {
      "indent": 3,
      "text": "a ^ b = Bitwise exclusive-or operation between \"a\" and \"b\".",
      "ja": "「A」と「B」との間の^ B =ビットごとの排他的論理和演算。"
    },
    {
      "indent": 3,
      "text": "a mod b = Remainder \"a\" modulo \"b\", always in range [0, b-1].",
      "ja": "常に範囲内のMOD B =剰余 \"\" モジュロ \"B\"、[0、B-1]。"
    },
    {
      "indent": 3,
      "text": "x >> n = floor(x / 2**n). Logical shift \"x\" right by \"n\" bits.",
      "ja": "X >> N =フロア（X / 2 ** N）。論理シフトは、「N」ビット右に「×」。"
    },
    {
      "indent": 3,
      "text": "x << n = (x * 2**n) mod (2**w). Logical shift \"x\" left by \"n\".",
      "ja": "X << N =（X * 2 ** N）MOD（** W 2）。 「N」で論理左シフト「×」。"
    },
    {
      "indent": 3,
      "text": "x >>> n = (x >> n) ^ (x << (w - n)). Rotate \"x\" right by \"n\".",
      "ja": "X >>> N =（X >> N）^（X <<（W  -  N））。右の「N」で「X」を回転させます。"
    },
    {
      "indent": 0,
      "text": "2.4. Little-Endian Interpretation of Words as Bytes",
      "section_title": true,
      "ja": "2.4. バイトなどの単語のリトルエンディアン解釈"
    },
    {
      "indent": 3,
      "text": "All mathematical operations are on 64-bit words in BLAKE2b and on 32-bit words in BLAKE2s.",
      "ja": "全ての数学的演算はBLAKE2b 64ビットワードに及びBLAKE2sにおける32ビットワードです。"
    },
    {
      "indent": 3,
      "text": "We may also perform operations on vectors of words. Vector indexing is zero based; the first element of an n-element vector \"v\" is v[0] and the last one is v[n - 1]. All elements are denoted by v[0..n-1].",
      "ja": "また、単語のベクトルに動作を実行することができます。ベクトルインデックスはゼロベースです。 N要素ベクトル「V」の最初の要素は、V [0]と最後のものは、V [N  -  1]です。すべての要素が[0..N-1] Vで示されています。"
    },
    {
      "indent": 3,
      "text": "Byte (octet) streams are interpreted as words in little-endian order, with the least-significant byte first. Consider this sequence of eight hexadecimal bytes:",
      "ja": "バイト（オクテット）ストリームは、第最下位バイトと、リトルエンディアン順に単語として解釈されます。 8進数バイトのこのシーケンスを考えてみます。"
    },
    {
      "indent": 8,
      "text": "x[0..7] = 0x01 0x23 0x45 0x67 0x89 0xAB 0xCD 0xEF",
      "ja": "X [0..7] = 0x01の0x23 0x45 0x67 0x89 0xAB 0xCD 0xEFという"
    },
    {
      "indent": 3,
      "text": "When interpreted as a 32-bit word from the beginning memory address, x[0..3] has a numerical value of 0x67452301 or 1732584193.",
      "ja": "開始メモリアドレスからの32ビット・ワードとして解釈するとき、X [0..3]は0x67452301または1732584193の数値を有します。"
    },
    {
      "indent": 3,
      "text": "When interpreted as a 64-bit word, bytes x[0..7] have a numerical value of 0xEFCDAB8967452301 or 17279655951921914625.",
      "ja": "バイト×64ビット・ワードとして解釈するとき[0..7] 0xEFCDAB8967452301又は17279655951921914625の数値を有します。"
    },
    {
      "indent": 0,
      "text": "2.5. Parameter Block",
      "section_title": true,
      "ja": "2.5. パラメータブロック"
    },
    {
      "indent": 3,
      "text": "We specify the parameter block words p[0..7] as follows:",
      "ja": "次のように私たちは、パラメータブロックワードのP [0..7]を指定します。"
    },
    {
      "indent": 8,
      "text": "byte offset:    3 2 1 0     (otherwise zero)\n      p[0] = 0x0101kknn     p[1..7] = 0",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Here the \"nn\" byte specifies the hash size in bytes. The second (little-endian) byte of the parameter block, \"kk\", specifies the key size in bytes. Set kk = 00 for unkeyed hashing. Bytes 2 and 3 are set as 01. All other bytes in the parameter block are set as zero.",
      "ja": "ここでは「NN」のバイトは、バイト単位でハッシュサイズを指定します。パラメータブロックの第二（リトルエンディアン）バイト、「KK」は、バイト単位でのキーサイズを指定します。キーなしハッシュの設定KK = 00。バイト2及び3は、パラメータブロック内の全ての他のバイトはゼロに設定されている01のように設定されています。"
    },
    {
      "indent": 3,
      "text": "Note: [BLAKE2] defines additional variants of BLAKE2 with features such as salting, personalized hashes, and tree hashing. These OPTIONAL features use fields in the parameter block that are not defined in this document.",
      "ja": "注：[BLAKE2】このような塩漬けなどの機能、パーソナライズされたハッシュ、および木のハッシュとBLAKE2の追加バリアントを定義します。これらのオプション機能は、このドキュメントで定義されていないパラメータブロック内のフィールドを使用します。"
    },
    {
      "indent": 0,
      "text": "2.6. Initialization Vector",
      "section_title": true,
      "ja": "2.6. 初期化ベクトル"
    },
    {
      "indent": 3,
      "text": "We define the Initialization Vector constant IV mathematically as:",
      "ja": "私たちは、数学のように初期化ベクトル定数IVを定義します。"
    },
    {
      "indent": 10,
      "text": "IV[i] = floor(2**w * frac(sqrt(prime(i+1)))), where prime(i)\nis the i:th prime number ( 2, 3, 5, 7, 11, 13, 17, 19 )\nand sqrt(x) is the square root of x.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The numerical values of IV can also be found in implementations in Appendices C and D for BLAKE2b and BLAKE2s, respectively.",
      "ja": "IVの数値は、それぞれ、BLAKE2bとBLAKE2sため付録CおよびDにおける実装に見出すことができます。"
    },
    {
      "indent": 3,
      "text": "Note: BLAKE2b IV is the same as SHA-512 IV, and BLAKE2s IV is the same as SHA-256 IV; see [RFC6234].",
      "ja": "注：BLAKE2b IVは、SHA-512 IVと同じであり、BLAKE2s IVは、SHA-256 IVと同じです。 [RFC6234]を参照してください。"
    },
    {
      "indent": 0,
      "text": "2.7. Message Schedule SIGMA",
      "section_title": true,
      "ja": "2.7. メッセージスケジュールSIGMA"
    },
    {
      "indent": 3,
      "text": "Message word schedule permutations for each round of both BLAKE2b and BLAKE2s are defined by SIGMA. For BLAKE2b, the two extra permutations for rounds 10 and 11 are SIGMA[10..11] = SIGMA[0..1].",
      "ja": "BLAKE2bとBLAKE2s両方の各ラウンドのメッセージワードスケジュール順列はSIGMAによって定義されます。 BLAKE2bため、ラウンド10および11のための2つの追加の置換がSIGMA [10..11] = SIGMA [0..1]です。"
    },
    {
      "indent": 8,
      "text": "  Round   |  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 |\n----------+-------------------------------------------------+\n SIGMA[0] |  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 |\n SIGMA[1] | 14 10  4  8  9 15 13  6  1 12  0  2 11  7  5  3 |\n SIGMA[2] | 11  8 12  0  5  2 15 13 10 14  3  6  7  1  9  4 |\n SIGMA[3] |  7  9  3  1 13 12 11 14  2  6  5 10  4  0 15  8 |\n SIGMA[4] |  9  0  5  7  2  4 10 15 14  1 11 12  6  8  3 13 |\n SIGMA[5] |  2 12  6 10  0 11  8  3  4 13  7  5 15 14  1  9 |\n SIGMA[6] | 12  5  1 15 14 13  4 10  0  7  6  3  9  2  8 11 |\n SIGMA[7] | 13 11  7 14 12  1  3  9  5  0 15  4  8  6  2 10 |\n SIGMA[8] |  6 15 14  9 11  3  0  8 12  2 13  7  1  4 10  5 |\n SIGMA[9] | 10  2  8  4  7  6  1  5 15 11  9 14  3 12 13  0 |\n----------+-------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3. BLAKE2 Processing",
      "section_title": true,
      "ja": "3. BLAKE2処理"
    },
    {
      "indent": 0,
      "text": "3.1. Mixing Function G",
      "section_title": true,
      "ja": "3.1. ミキシング機能G"
    },
    {
      "indent": 3,
      "text": "The G primitive function mixes two input words, \"x\" and \"y\", into four words indexed by \"a\", \"b\", \"c\", and \"d\" in the working vector v[0..15]. The full modified vector is returned. The rotation constants (R1, R2, R3, R4) are given in Section 2.1.",
      "ja": "G原始関数は、作業ベクトルv [0..15]の「A」、「B」、「C」、および「D」によって索引付け4つの単語に二つの入力の単語、「X」と「Y」を、混合します。完全な修正ベクトルが返されます。回転定数（R1、R2、R3、R4）は、セクション2.1に記載されています。"
    },
    {
      "indent": 7,
      "text": "FUNCTION G( v[0..15], a, b, c, d, x, y )\n|\n|   v[a] := (v[a] + v[b] + x) mod 2**w\n|   v[d] := (v[d] ^ v[a]) >>> R1\n|   v[c] := (v[c] + v[d])     mod 2**w\n|   v[b] := (v[b] ^ v[c]) >>> R2\n|   v[a] := (v[a] + v[b] + y) mod 2**w\n|   v[d] := (v[d] ^ v[a]) >>> R3\n|   v[c] := (v[c] + v[d])     mod 2**w\n|   v[b] := (v[b] ^ v[c]) >>> R4\n|\n|   RETURN v[0..15]\n|\nEND FUNCTION.",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.2. Compression Function F",
      "section_title": true,
      "ja": "3.2. 圧縮関数F"
    },
    {
      "indent": 3,
      "text": "Compression function F takes as an argument the state vector \"h\", message block vector \"m\" (last block is padded with zeros to full block size, if required), 2w-bit offset counter \"t\", and final block indicator flag \"f\". Local vector v[0..15] is used in processing. F returns a new state vector. The number of rounds, \"r\", is 12 for BLAKE2b and 10 for BLAKE2s. Rounds are numbered from 0 to r - 1.",
      "ja": "圧縮関数Fは、メッセージブロックのベクトル「M」（必要であれば、最後のブロックは、フルブロックサイズにゼロが埋め込まれている）、2ワットビットオフセットカウンタ「T」、および最終ブロックインジケータフラグ、引数として、状態ベクトル「H」にかかり\"F\"。ローカルベクトルvは[0..15]の処理に使用されます。 Fは、新しい状態ベクトルを返します。ラウンド数は、「r」は、BLAKE2sためBLAKE2b 12及び10です。 1  - ラウンドR 0から番号付けされています。"
    },
    {
      "indent": 7,
      "text": "FUNCTION F( h[0..7], m[0..15], t, f )\n|\n|      // Initialize local work vector v[0..15]\n|      v[0..7] := h[0..7]              // First half from state.\n|      v[8..15] := IV[0..7]            // Second half from IV.\n|\n|      v[12] := v[12] ^ (t mod 2**w)   // Low word of the offset.\n|      v[13] := v[13] ^ (t >> w)       // High word.\n|\n|      IF f = TRUE THEN                // last block flag?\n|      |   v[14] := v[14] ^ 0xFF..FF   // Invert all bits.\n|      END IF.\n|\n|      // Cryptographic mixing\n|      FOR i = 0 TO r - 1 DO           // Ten or twelve rounds.\n|      |\n|      |   // Message word selection permutation for this round.\n|      |   s[0..15] := SIGMA[i mod 10][0..15]\n|      |\n|      |   v := G( v, 0, 4,  8, 12, m[s[ 0]], m[s[ 1]] )\n|      |   v := G( v, 1, 5,  9, 13, m[s[ 2]], m[s[ 3]] )\n|      |   v := G( v, 2, 6, 10, 14, m[s[ 4]], m[s[ 5]] )\n|      |   v := G( v, 3, 7, 11, 15, m[s[ 6]], m[s[ 7]] )\n|      |\n|      |   v := G( v, 0, 5, 10, 15, m[s[ 8]], m[s[ 9]] )\n|      |   v := G( v, 1, 6, 11, 12, m[s[10]], m[s[11]] )\n|      |   v := G( v, 2, 7,  8, 13, m[s[12]], m[s[13]] )\n|      |   v := G( v, 3, 4,  9, 14, m[s[14]], m[s[15]] )\n|      |\n|      END FOR\n|\n|      FOR i = 0 TO 7 DO               // XOR the two halves.\n|      |   h[i] := h[i] ^ v[i] ^ v[i + 8]\n|      END FOR.\n|\n|      RETURN h[0..7]                  // New state.\n|\nEND FUNCTION.",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.3. Padding Data and Computing a BLAKE2 Digest",
      "section_title": true,
      "ja": "3.3. パディングデータおよびコンピューティングBLAKE2ダイジェスト"
    },
    {
      "indent": 3,
      "text": "We refer the reader to Appendices C and D for reference C language implementations of BLAKE2b and BLAKE2s, respectively.",
      "ja": "我々は、それぞれ、BLAKE2bとBLAKE2sの基準C言語の実装のために付録CおよびDを読者に参照します。"
    },
    {
      "indent": 3,
      "text": "Key and data input are split and padded into \"dd\" message blocks d[0..dd-1], each consisting of 16 words (or \"bb\" bytes).",
      "ja": "キーとデータ入力は、それぞれが16ワード（または「BB」バイト）からなる、「DD」メッセージブロックD [0..dd-1]に分割し、埋め込まれています。"
    },
    {
      "indent": 3,
      "text": "If a secret key is used (kk > 0), it is padded with zero bytes and set as d[0]. Otherwise, d[0] is the first data block. The final data block d[dd-1] is also padded with zero to \"bb\" bytes (16 words).",
      "ja": "秘密鍵が使用される場合（KK> 0）には、ゼロバイトでパディングおよびDとして設定されている[0]。そうでない場合は、D [0]は最初のデータブロックです。最終的なデータ・ブロックD [DD-1]また、「BB」バイト（16ワード）にゼロで埋められます。"
    },
    {
      "indent": 3,
      "text": "The number of blocks is therefore dd = ceil(kk / bb) + ceil(ll / bb). However, in the special case of an unkeyed empty message (kk = 0 and ll = 0), we still set dd = 1 and d[0] consists of all zeros.",
      "ja": "ブロックの数は、従って、DD = CEIL（KK / BB）+ CEIL（LL / BB）です。しかし、キーなし空のメッセージ（KK = 0及びLL = 0）、我々まだ設定DD = 1、Dの特殊な場合に[0]がすべてゼロで構成されています。"
    },
    {
      "indent": 3,
      "text": "The following procedure processes the padded data blocks into an \"nn\"-byte final hash value. See Section 2 for a description of various variables and constants used.",
      "ja": "次の手順は、「NN」-byte最終ハッシュ値にパディングされたデータ・ブロックを処理します。使用される様々な変数や定数の説明については、セクション2を参照してください。"
    },
    {
      "indent": 8,
      "text": "FUNCTION BLAKE2( d[0..dd-1], ll, kk, nn )\n|\n|     h[0..7] := IV[0..7]          // Initialization Vector.\n|\n|     // Parameter block p[0]\n|     h[0] := h[0] ^ 0x01010000 ^ (kk << 8) ^ nn\n|\n|     // Process padded key and data blocks\n|     IF dd > 1 THEN\n|     |       FOR i = 0 TO dd - 2 DO\n|     |       |       h := F( h, d[i], (i + 1) * bb, FALSE )\n|     |       END FOR.\n|     END IF.\n|\n|     // Final block.\n|     IF kk = 0 THEN\n|     |       h := F( h, d[dd - 1], ll, TRUE )\n|     ELSE\n|     |       h := F( h, d[dd - 1], ll + bb, TRUE )\n|     END IF.\n|\n|     RETURN first \"nn\" bytes from little-endian word array h[].\n|\nEND FUNCTION.",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4. Standard Parameter Sets and Algorithm Identifiers",
      "section_title": true,
      "ja": "4.標準パラメータセットとアルゴリズムの識別子"
    },
    {
      "indent": 3,
      "text": "An implementation of BLAKE2b and/or BLAKE2s MAY support the following digest size parameters for interoperability (e.g., digital signatures), as long as a sufficient level of security is attained by the parameter selections. These parameters and identifiers are intended to be suitable as drop-in replacements to MD5 and corresponding SHA algorithms.",
      "ja": "BLAKE2b及び/又はBLAKE2sの実装であれば、セキュリティの十分なレベルがパラメータの選択によって達成されるように、相互運用性（例えば、デジタル署名）のサイズパラメータをダイジェスト以下をサポートするかもしれません。これらのパラメータおよび識別子はMD5にドロップイン代替品と対応SHAアルゴリズムとして好適であることが意図されます。"
    },
    {
      "indent": 3,
      "text": "Developers adapting BLAKE2 to ASN.1-based message formats SHOULD use the OID tree at x = 1.3.6.1.4.1.1722.12.2. The same OID can be used for both keyed and unkeyed hashing since in the latter case the key simply has zero length.",
      "ja": "ASN.1ベースのメッセージフォーマットにBLAKE2を適応開発者は、x = 1.3.6.1.4.1.1722.12.2でOIDのツリーを使用すべきです。後者の場合、キーは、単にゼロの長さを有しているので、同じOIDはキー付きとキーなしの両方のハッシュのために使用することができます。"
    },
    {
      "indent": 11,
      "text": " Algorithm     | Target | Collision | Hash | Hash ASN.1 |\n    Identifier |  Arch  |  Security |  nn  | OID Suffix |\n---------------+--------+-----------+------+------------+\n id-blake2b160 | 64-bit |   2**80   |  20  |   x.1.5    |\n id-blake2b256 | 64-bit |   2**128  |  32  |   x.1.8    |\n id-blake2b384 | 64-bit |   2**192  |  48  |   x.1.12   |\n id-blake2b512 | 64-bit |   2**256  |  64  |   x.1.16   |\n---------------+--------+-----------+------+------------+\n id-blake2s128 | 32-bit |   2**64   |  16  |   x.2.4    |\n id-blake2s160 | 32-bit |   2**80   |  20  |   x.2.5    |\n id-blake2s224 | 32-bit |   2**112  |  28  |   x.2.7    |\n id-blake2s256 | 32-bit |   2**128  |  32  |   x.2.8    |\n---------------+--------+-----------+------+------------+",
      "raw": true
    },
    {
      "indent": 10,
      "text": "hashAlgs OBJECT IDENTIFIER ::= {\n    iso(1) identified-organization(3) dod(6) internet(1)\n    private(4) enterprise(1) kudelski(1722) cryptography(12) 2\n}\nmacAlgs OBJECT IDENTIFIER ::= {\n    iso(1) identified-organization(3) dod(6) internet(1)\n    private(4) enterprise(1) kudelski(1722) cryptography(12) 3\n}",
      "raw": true
    },
    {
      "indent": 10,
      "text": "-- the two BLAKE2 variants --\nblake2b OBJECT IDENTIFIER ::= { hashAlgs 1 }\nblake2s OBJECT IDENTIFIER ::= { hashAlgs 2 }",
      "raw": true
    },
    {
      "indent": 10,
      "text": "-- BLAKE2b Identifiers --\nid-blake2b160 OBJECT IDENTIFIER ::= { blake2b 5 }\nid-blake2b256 OBJECT IDENTIFIER ::= { blake2b 8 }\nid-blake2b384 OBJECT IDENTIFIER ::= { blake2b 12 }\nid-blake2b512 OBJECT IDENTIFIER ::= { blake2b 16 }",
      "raw": true
    },
    {
      "indent": 10,
      "text": "-- BLAKE2s Identifiers --\nid-blake2s128 OBJECT IDENTIFIER ::= { blake2s 4 }\nid-blake2s160 OBJECT IDENTIFIER ::= { blake2s 5 }\nid-blake2s224 OBJECT IDENTIFIER ::= { blake2s 7 }\nid-blake2s256 OBJECT IDENTIFIER ::= { blake2s 8 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "5. Security Considerations",
      "section_title": true,
      "ja": "5.セキュリティについての考慮事項"
    },
    {
      "indent": 3,
      "text": "This document is intended to provide convenient open-source access by the Internet community to the BLAKE2 cryptographic hash algorithm. We wish to make no independent assertion to its security in this document. We refer the reader to [BLAKE] and [BLAKE2] for detailed cryptanalytic rationale behind its design.",
      "ja": "このドキュメントは、BLAKE2暗号化ハッシュアルゴリズムにインターネットコミュニティによって、便利なオープンソースへのアクセスを提供することを意図しています。私たちは、この文書では、セキュリティへの独立の主張をしないことを望みます。私たちは、[BLAKE]にし、[BLAKE2]その設計の背後にある詳細な暗号解読根拠のためのリーダーを参照してください。"
    },
    {
      "indent": 3,
      "text": "In order to avoid bloat, the reference implementations in Appendices C and D may not erase all sensitive data (such as secret keys) immediately from process memory after use. Such cleanup can be added if needed.",
      "ja": "肥大化を避けるために、付録CおよびDにおけるリファレンス実装は、使用後すぐにプロセスメモリから（例えば秘密鍵のような）すべての機密データを消去しなくてもよいです。必要であれば、このようなクリーンアップを追加することができます。"
    },
    {
      "indent": 0,
      "text": "6. References",
      "section_title": true,
      "ja": "6.参照"
    },
    {
      "indent": 0,
      "text": "6.1. Normative References",
      "section_title": true,
      "ja": "6.1. 引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<http://www.rfc-editor.org/info/ RFC2119>。"
    },
    {
      "indent": 0,
      "text": "6.2. Informative References",
      "section_title": true,
      "ja": "6.2. 参考文献"
    },
    {
      "indent": 3,
      "text": "[BLAKE] Aumasson, J-P., Meier, W., Phan, R., and L. Henzen, \"The Hash Function BLAKE\", January 2015, <https://131002.net/blake/book>.",
      "ja": "[BLAKE] Aumasson、J-P。、マイヤー、W.、Phanさん、R.、およびL. Henzen、 \"ハッシュ関数BLAKE\"、2015年1月、<https://131002.net/blake/book>。"
    },
    {
      "indent": 3,
      "text": "[BLAKE2] Aumasson, J-P., Neves, S., Wilcox-O'Hearn, Z., and C. Winnerlein, \"BLAKE2: simpler, smaller, fast as MD5\", January 2013, <https://blake2.net/blake2.pdf>.",
      "ja": "【BLAKE2] Aumasson、JP、ネベス、S.、ウィルコックス・O'Hearn、Z.、およびC. Winnerlein、 \"BLAKE2：高速MD5など、単純な小さい\"、2013年1月、<https://blake2.net /blake2.pdf>。"
    },
    {
      "indent": 3,
      "text": "[FIPS140-2IG] NIST, \"Implementation Guidance for FIPS PUB 140-2 and the Cryptographic Module Validation Program\", September 2015, <http://csrc.nist.gov/groups/STM/cmvp/documents/fips140-2/ FIPS1402IG.pdf/>.",
      "ja": "[FIPS140-2IG] NIST、 \"FIPS PUB 140-2の暗号モジュール検証プログラムの適用指針\"、2015年9月、<http://csrc.nist.gov/groups/STM/cmvp/documents/fips140-2/ FIPS1402IG.pdf />。"
    },
    {
      "indent": 3,
      "text": "[RFC6151] Turner, S. and L. Chen, \"Updated Security Considerations for the MD5 Message-Digest and the HMAC-MD5 Algorithms\", RFC 6151, DOI 10.17487/RFC6151, March 2011, <http://www.rfc-editor.org/info/rfc6151>.",
      "ja": "[RFC6151]ターナー、S.とL.チェン、 \"MD5メッセージダイジェストとHMAC-MD5アルゴリズムのための更新されたセキュリティ上の考慮事項\"、RFC 6151、DOI 10.17487 / RFC6151、2011年3月、<のhttp：//www.rfc- editor.org/info/rfc6151>。"
    },
    {
      "indent": 3,
      "text": "[RFC6234] Eastlake 3rd, D. and T. Hansen, \"US Secure Hash Algorithms (SHA and SHA-based HMAC and HKDF)\", RFC 6234, DOI 10.17487/RFC6234, May 2011, <http://www.rfc-editor.org/info/rfc6234>.",
      "ja": "[RFC6234]イーストレイク3日、D.とT.ハンセン、 \"米国のセキュアハッシュアルゴリズム（SHAとHMACとHKDF SHAベース）\"、RFC 6234、DOI 10.17487 / RFC6234、2011年5月、<のhttp：//www.rfc- editor.org/info/rfc6234>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Example of BLAKE2b Computation",
      "ja": "BLAKE2b計算の付録A.例"
    },
    {
      "indent": 3,
      "text": "We compute the unkeyed hash of three ASCII bytes \"abc\" with BLAKE2b-512 and show internal values during computation.",
      "ja": "私たちは、3つのASCIIのキーなしハッシュがBLAKE2b-512で「ABC」のバイト計算し、計算中に内部値を示しています。"
    },
    {
      "indent": 10,
      "text": "m[16] = 0000000000636261 0000000000000000 0000000000000000\n        0000000000000000 0000000000000000 0000000000000000\n        0000000000000000 0000000000000000 0000000000000000\n        0000000000000000 0000000000000000 0000000000000000\n        0000000000000000 0000000000000000 0000000000000000\n        0000000000000000",
      "raw": true
    },
    {
      "indent": 3,
      "text": "(i= 0) v[16] = 6A09E667F2BDC948 BB67AE8584CAA73B 3C6EF372FE94F82B A54FF53A5F1D36F1 510E527FADE682D1 9B05688C2B3E6C1F 1F83D9ABFB41BD6B 5BE0CD19137E2179 6A09E667F3BCC908 BB67AE8584CAA73B 3C6EF372FE94F82B A54FF53A5F1D36F1 510E527FADE682D2 9B05688C2B3E6C1F E07C265404BE4294 5BE0CD19137E2179",
      "ja": "（I = 0）V [16] = 6A09E667F2BDC948 BB67AE8584CAA73B 3C6EF372FE94F82B A54FF53A5F1D36F1 510E527FADE682D1 9B05688C2B3E6C1F 1F83D9ABFB41BD6B 5BE0CD19137E2179 6A09E667F3BCC908 BB67AE8584CAA73B 3C6EF372FE94F82B A54FF53A5F1D36F1 510E527FADE682D2 9B05688C2B3E6C1F E07C265404BE4294 5BE0CD19137E2179"
    },
    {
      "indent": 3,
      "text": "(i= 1) v[16] = 86B7C1568029BB79 C12CBCC809FF59F3 C6A5214CC0EACA8E 0C87CD524C14CC5D 44EE6039BD86A9F7 A447C850AA694A7E DE080F1BB1C0F84B 595CB8A9A1ACA66C BEC3AE837EAC4887 6267FC79DF9D6AD1 FA87B01273FA6DBE 521A715C63E08D8A E02D0975B8D37A83 1C7B754F08B7D193 8F885A76B6E578FE 2318A24E2140FC64",
      "ja": "（I = 1）V [16] = 86B7C1568029BB79 C12CBCC809FF59F3 C6A5214CC0EACA8E 0C87CD524C14CC5D 44EE6039BD86A9F7 A447C850AA694A7E DE080F1BB1C0F84B 595CB8A9A1ACA66C BEC3AE837EAC4887 6267FC79DF9D6AD1 FA87B01273FA6DBE 521A715C63E08D8A E02D0975B8D37A83 1C7B754F08B7D193 8F885A76B6E578FE 2318A24E2140FC64"
    },
    {
      "indent": 3,
      "text": "(i= 2) v[16] = 53281E83806010F2 3594B403F81B4393 8CD63C7462DE0DFF 85F693F3DA53F974 BAABDBB2F386D9AE CA5425AEC65A10A8 C6A22E2FF0F7AA48 C6A56A51CB89C595 224E6A3369224F96 500E125E58A92923 E9E4AD0D0E1A0D48 85DF9DC143C59A74 92A3AAAA6D952B7F C5FDF71090FAE853 2A8A40F15A462DD0 572D17EFFDD37358",
      "ja": "（I = 2）V [16] = 53281E83806010F2 3594B403F81B4393 8CD63C7462DE0DFF 85F693F3DA53F974 BAABDBB2F386D9AE CA5425AEC65A10A8 C6A22E2FF0F7AA48 C6A56A51CB89C595 224E6A3369224F96 500E125E58A92923 E9E4AD0D0E1A0D48 85DF9DC143C59A74 92A3AAAA6D952B7F C5FDF71090FAE853 2A8A40F15A462DD0 572D17EFFDD37358"
    },
    {
      "indent": 3,
      "text": "(i= 3) v[16] = 60ED96AA7AD41725 E46A743C71800B9D 1A04B543A01F156B A2F8716E775C4877 DA0A61BCDE4267EA B1DD230754D7BDEE 25A1422779E06D14 E6823AE4C3FF58A5 A1677E19F37FD5DA 22BDCE6976B08C51 F1DE8696BEC11BF1 A0EBD586A4A1D2C8 C804EBAB11C99FA9 8E0CEC959C715793 7C45557FAE0D4D89 716343F52FDD265E",
      "ja": "（I = 3）V [16] = 60ED96AA7AD41725 E46A743C71800B9D 1A04B543A01F156B A2F8716E775C4877 DA0A61BCDE4267EA B1DD230754D7BDEE 25A1422779E06D14 E6823AE4C3FF58A5 A1677E19F37FD5DA 22BDCE6976B08C51 F1DE8696BEC11BF1 A0EBD586A4A1D2C8 C804EBAB11C99FA9 8E0CEC959C715793 7C45557FAE0D4D89 716343F52FDD265E"
    },
    {
      "indent": 3,
      "text": "(i= 4) v[16] = BB2A77D3A8382351 45EB47971F23B103 98BE297F6E45C684 A36077DEE3370B89 8A03C4CB7E97590A 24192E49EBF54EA0 4F82C9401CB32D7A 8CCD013726420DC4 A9C9A8F17B1FC614 55908187977514A0 5B44273E66B19D27 B6D5C9FCA2579327 086092CFB858437E 5C4BE2156DBEECF9 2EFEDE99ED4EFF16 3E7B5F234CD1F804",
      "ja": "（I = 4）V [16] = BB2A77D3A8382351 45EB47971F23B103 98BE297F6E45C684 A36077DEE3370B89 8A03C4CB7E97590A 24192E49EBF54EA0 4F82C9401CB32D7A 8CCD013726420DC4 A9C9A8F17B1FC614 55908187977514A0 5B44273E66B19D27 B6D5C9FCA2579327 086092CFB858437E 5C4BE2156DBEECF9 2EFEDE99ED4EFF16 3E7B5F234CD1F804"
    },
    {
      "indent": 3,
      "text": "(i= 5) v[16] = C79C15B3D423B099 2DA2224E8DA97556 77D2B26DF1C45C55 8934EB09A3456052 0F6D9EEED157DA2A 6FE66467AF88C0A9 4EB0B76284C7AAFB 299C8E725D954697 B2240B59E6D567D3 2643C2370E49EBFD 79E02EEF20CDB1AE 64B3EED7BB602F39 B97D2D439E4DF63D C718E755294C9111 1F0893F2772BB373 1205EA4A7859807D",
      "ja": "（I = 5）V [16] = C79C15B3D423B099 2DA2224E8DA97556 77D2B26DF1C45C55 8934EB09A3456052 0F6D9EEED157DA2A 6FE66467AF88C0A9 4EB0B76284C7AAFB 299C8E725D954697 B2240B59E6D567D3 2643C2370E49EBFD 79E02EEF20CDB1AE 64B3EED7BB602F39 B97D2D439E4DF63D C718E755294C9111 1F0893F2772BB373 1205EA4A7859807D"
    },
    {
      "indent": 3,
      "text": "(i= 6) v[16] = E58F97D6385BAEE4 7640AA9764DA137A DEB4C7C23EFE287E 70F6F41C8783C9F6 7127CD48C76A7708 9E472AF0BE3DB3F6 0F244C62DDF71788 219828AA83880842 41CCA9073C8C4D0D 5C7912BC10DF3B4B A2C3ABBD37510EE2 CB5668CC2A9F7859 8733794F07AC1500 C67A6BE42335AA6F ACB22B28681E4C82 DB2161604CBC9828",
      "ja": "（I = 6）V [16] = E58F97D6385BAEE4 7640AA9764DA137A DEB4C7C23EFE287E 70F6F41C8783C9F6 7127CD48C76A7708 9E472AF0BE3DB3F6 0F244C62DDF71788 219828AA83880842 41CCA9073C8C4D0D 5C7912BC10DF3B4B A2C3ABBD37510EE2 CB5668CC2A9F7859 8733794F07AC1500 C67A6BE42335AA6F ACB22B28681E4C82 DB2161604CBC9828"
    },
    {
      "indent": 3,
      "text": "(i= 7) v[16] = 6E2D286EEADEDC81 BCF02C0787E86358 57D56A56DD015EDF 55D899D40A5D0D0A 819415B56220C459 B63C479A6A769F02 258E55E0EC1F362A 3A3B4EC60E19DFDC 04D769B3FCB048DB B78A9A33E9BFF4DD 5777272AE1E930C0 5A387849E578DBF6 92AAC307CF2C0AFC 30AACCC4F06DAFAA 483893CC094F8863 E03C6CC89C26BF92",
      "ja": "（I = 7）V [16] = 6E2D286EEADEDC81 BCF02C0787E86358 57D56A56DD015EDF 55D899D40A5D0D0A 819415B56220C459 B63C479A6A769F02 258E55E0EC1F362A 3A3B4EC60E19DFDC 04D769B3FCB048DB B78A9A33E9BFF4DD 5777272AE1E930C0 5A387849E578DBF6 92AAC307CF2C0AFC 30AACCC4F06DAFAA 483893CC094F8863 E03C6CC89C26BF92"
    },
    {
      "indent": 3,
      "text": "(i= 8) v[16] = FFC83ECE76024D01 1BE7BFFB8C5CC5F9 A35A18CBAC4C65B7 B7C2C7E6D88C285F 81937DA314A50838 E1179523A2541963 3A1FAD7106232B8F 1C7EDE92AB8B9C46 A3C2D35E4F685C10 A53D3F73AA619624 30BBCC0285A22F65 BCEFBB6A81539E5D 3841DEF6F4C9848A 98662C85FBA726D4 7762439BD5A851BD B0B9F0D443D1A889",
      "ja": "（I = 8）V [16] = FFC83ECE76024D01 1BE7BFFB8C5CC5F9 A35A18CBAC4C65B7 B7C2C7E6D88C285F 81937DA314A50838 E1179523A2541963 3A1FAD7106232B8F 1C7EDE92AB8B9C46 A3C2D35E4F685C10 A53D3F73AA619624 30BBCC0285A22F65 BCEFBB6A81539E5D 3841DEF6F4C9848A 98662C85FBA726D4 7762439BD5A851BD B0B9F0D443D1A889"
    },
    {
      "indent": 3,
      "text": "(i= 9) v[16] = 753A70A1E8FAEADD 6B0D43CA2C25D629 F8343BA8B94F8C0B BC7D062B0DB5CF35 58540EE1B1AEBC47 63C5B9B80D294CB9 490870ECAD27DEBD B2A90DDF667287FE 316CC9EBEEFAD8FC 4A466BCD021526A4 5DA7F7638CEC5669 D9C8826727D306FC 88ED6C4F3BD7A537 19AE688DDF67F026 4D8707AAB40F7E6D FD3F572687FEA4F1",
      "ja": "（I = 9）V [16] = 753A70A1E8FAEADD 6B0D43CA2C25D629 F8343BA8B94F8C0B BC7D062B0DB5CF35 58540EE1B1AEBC47 63C5B9B80D294CB9 490870ECAD27DEBD B2A90DDF667287FE 316CC9EBEEFAD8FC 4A466BCD021526A4 5DA7F7638CEC5669 D9C8826727D306FC 88ED6C4F3BD7A537 19AE688DDF67F026 4D8707AAB40F7E6D FD3F572687FEA4F1"
    },
    {
      "indent": 3,
      "text": "(i=10) v[16] = E630C747CCD59C4F BC713D41127571CA 46DB183025025078 6727E81260610140 2D04185EAC2A8CBA 5F311B88904056EC 40BD313009201AAB 0099D4F82A2A1EAB 6DD4FBC1DE60165D B3B0B51DE3C86270 900AEE2F233B08E5 A07199D87AD058D8 2C6B25593D717852 37E8CA471BEAA5F8 2CFC1BAC10EF4457 01369EC18746E775",
      "ja": "（I = 10）V [16] = E630C747CCD59C4F BC713D41127571CA 46DB183025025078 6727E81260610140 2D04185EAC2A8CBA 5F311B88904056EC 40BD313009201AAB 0099D4F82A2A1EAB 6DD4FBC1DE60165D B3B0B51DE3C86270 900AEE2F233B08E5 A07199D87AD058D8 2C6B25593D717852 37E8CA471BEAA5F8 2CFC1BAC10EF4457 01369EC18746E775"
    },
    {
      "indent": 3,
      "text": "(i=11) v[16] = E801F73B9768C760 35C6D22320BE511D 306F27584F65495E B51776ADF569A77B F4F1BE86690B3C34 3CC88735D1475E4B 5DAC67921FF76949 1CDB9D31AD70CC4E 35BA354A9C7DF448 4929CBE45679D73E 733D1A17248F39DB 92D57B736F5F170A 61B5C0A41D491399 B5C333457E12844A BD696BE010D0D889 02231E1A917FE0BD",
      "ja": "（I = 11）V [16] = E801F73B9768C760 35C6D22320BE511D 306F27584F65495E B51776ADF569A77B F4F1BE86690B3C34 3CC88735D1475E4B 5DAC67921FF76949 1CDB9D31AD70CC4E 35BA354A9C7DF448 4929CBE45679D73E 733D1A17248F39DB 92D57B736F5F170A 61B5C0A41D491399 B5C333457E12844A BD696BE010D0D889 02231E1A917FE0BD"
    },
    {
      "indent": 3,
      "text": "(i=12) v[16] = 12EF8A641EC4F6D6 BCED5DE977C9FAF5 733CA476C5148639 97DF596B0610F6FC F42C16519AD5AFA7 AA5AC1888E10467E 217D930AA51787F3 906A6FF19E573942 75AB709BD3DCBF24 EE7CE1F345947AA4 F8960D6C2FAF5F5E E332538A36B6D246 885BEF040EF6AA0B A4939A417BFB78A3 646CBB7AF6DCE980 E813A23C60AF3B82",
      "ja": "（I = 12）V [16] = 12EF8A641EC4F6D6 BCED5DE977C9FAF5 733CA476C5148639 97DF596B0610F6FC F42C16519AD5AFA7 AA5AC1888E10467E 217D930AA51787F3 906A6FF19E573942 75AB709BD3DCBF24 EE7CE1F345947AA4 F8960D6C2FAF5F5E E332538A36B6D246 885BEF040EF6AA0B A4939A417BFB78A3 646CBB7AF6DCE980 E813A23C60AF3B82"
    },
    {
      "indent": 11,
      "text": "h[8] = 0D4D1C983FA580BA E9F6129FB697276A B7C45A68142F214C\n       D1A2FFDB6FBB124B 2D79AB2A39C5877D 95CC3345DED552C2\n       5A92F1DBA88AD318 239900D4ED8623B9",
      "raw": true
    },
    {
      "indent": 3,
      "text": "BLAKE2b-512(\"abc\") = BA 80 A5 3F 98 1C 4D 0D 6A 27 97 B6 9F 12 F6 E9 4C 21 2F 14 68 5A C4 B7 4B 12 BB 6F DB FF A2 D1 7D 87 C5 39 2A AB 79 2D C2 52 D5 DE 45 33 CC 95 18 D3 8A A8 DB F1 92 5A B9 23 86 ED D4 00 99 23",
      "ja": "BLAKE2b-512（ \"ABC\"）= BA 80 A5 3F 98 1C 4D 0D 6A 27 97 B6 9F 12 F6 E9 4C 21 2F 14 68（a）のC4のB7 4B 12 BB 6F DB FF A2 D1 7D 87 C5 39 2A AB 79 2D C2 52 D5 DE 45 33 CC 95 18 D3 8A A8 DB F1 92（a）のB9 23 86 ED D4 00 99 23"
    },
    {
      "indent": 0,
      "text": "Appendix B. Example of BLAKE2s Computation",
      "ja": "BLAKE2s計算の付録B.例"
    },
    {
      "indent": 3,
      "text": "We compute the unkeyed hash of three ASCII bytes \"abc\" with BLAKE2s-256 and show internal values during computation.",
      "ja": "私たちは、3つのASCIIのキーなしハッシュがBLAKE2s-256で「ABC」のバイト計算し、計算中に内部値を示しています。"
    },
    {
      "indent": 10,
      "text": "m[16] = 00636261 00000000 00000000 00000000 00000000 00000000\n        00000000 00000000 00000000 00000000 00000000 00000000\n        00000000 00000000 00000000 00000000",
      "raw": true
    },
    {
      "indent": 3,
      "text": "(i=0) v[16] = 6B08E647 BB67AE85 3C6EF372 A54FF53A 510E527F 9B05688C 1F83D9AB 5BE0CD19 6A09E667 BB67AE85 3C6EF372 A54FF53A 510E527C 9B05688C E07C2654 5BE0CD19",
      "ja": "（N = 0）= vyu16sch shV08E647 BV67AE85 3K6EF372 A54FF53A 510E527F 9B05688S 1F83D9AB 5BE0SD19 shA09E667 BB67AE85 3K6EF372 A54FF53A 510E527S 9B05688S E07TS2654 5BE0SD19"
    },
    {
      "indent": 3,
      "text": "(i=1) v[16] = 16A3242E D7B5E238 CE8CE24B 927AEDE1 A7B430D9 93A4A14E A44E7C31 41D4759B 95BF33D3 9A99C181 608A3A6B B666383E 7A8DD50F BE378ED7 353D1EE6 3BB44C6B",
      "ja": "（S = 1）= C16 16A3242E D7B5E238 E8E24B 927AEDE1 A7B430D9 93A4A14E A44E731 41D4759B 95BF33D3 9A99181 608A3A6B B666383E 7A8DD50F BE378ED7 353D1EE6 ZBBCHCHTSSHB"
    },
    {
      "indent": 3,
      "text": "(i=2) v[16] = 3AE30FE3 0982A96B E88185B4 3E339B16 F24338CD 0E66D326 E005ED0C D591A277 180B1F3A FCF43914 30DB62D6 4847831C 7F00C58E FB847886 C544E836 524AB0E2",
      "ja": "（S = 2）= C16 3AE30FE3 0982A96B E88185B4 3E339B16 F24338D 0E66D326 E005ED0 D591A277 180B1F3A FF43914 30DB62D6 4847831 7F0058E FB847886 544E836 524AB0E2"
    },
    {
      "indent": 3,
      "text": "(i=3) v[16] = 7A3BE783 997546C1 D45246DF EDB5F821 7F98A742 10E864E2 D4AB70D0 C63CB1AB 6038DA9E 414594B0 F2C218B5 8DA0DCB7 D7CD7AF5 AB4909DF 85031A52 C4EDFC98",
      "ja": "（I = H）C16 = 7A3BE783 9975461 D45246DF EDB5F821 7F98A742 10E864E2 D4AB70D0 63B1AB 6038DA9E 414594B0 F2218B5 8DA0DB7 D7D7AF5 AB4909DF 85031A52 4EDF98"
    },
    {
      "indent": 3,
      "text": "(i=4) v[16] = 2A8B8CB7 1ACA82B2 14045D7F CC7258ED 383CF67C E090E7F9 3025D276 57D04DE4 994BACF0 F0982759 F17EE300 D48FC2D5 DC854C10 523898A9 C03A0F89 47D6CD88",
      "ja": "（I = X）= C16 2A8B8B7 1AA82B2 14045D7F 7258ED 383F67 E090E7F9 3025D276 57D04DE4 994BAF0 F0982759 F17EE300 D48F2D5 D85410 523898A9 03A0F89 47D6D88"
    },
    {
      "indent": 3,
      "text": "(i=5) v[16] = C4AA2DDB 111343A3 D54A700A 574A00A9 857D5A48 B1E11989 6F5C52DF DD2C53A3 678E5F8E 9718D4E9 622CB684 92976076 0E41A517 359DC2BE 87A87DDD 643F9CEC",
      "ja": "（S = 5）C16 = 4AA2DDB 111343A3 D54A700A 574A00A9 857D5A48 B1E11989 6F552DF DD253A3 678E5F8E 9718D4E9 622B684 92976076 0E41A517 359D2BE 87A87DDD SHCHZFYATSETS"
    },
    {
      "indent": 3,
      "text": "(i=6) v[16] = 3453921C D7595EE1 592E776D 3ED6A974 4D997CB3 DE9212C3 35ADF5C9 9916FD65 96562E89 4EAD0792 EBFC2712 2385F5B2 F34600FB D7BC20FB EB452A7B ECE1AA40",
      "ja": "（I = Y）C16 = 3453921 D7595EE1 592E776D ZEDSHAYASHTCH CHDYAYASHTTSBZ DE92123 35ADF59 9916FD65 96562E89 4EAD0792 EBF2712 2385F5B2 F34600FB D7B20FB EB452A7B EE1AA40"
    },
    {
      "indent": 3,
      "text": "(i=7) v[16] = BE851B2D A85F6358 81E6FC3B 0BB28000 FA55A33A 87BE1FAD 4119370F 1E2261AA A1318FD3 F4329816 071783C2 6E536A8D 9A81A601 E7EC80F1 ACC09948 F849A584",
      "ja": "（S = Z）= C16 BE851B2D A85F6358 81E6F3B 0BB28000 FA55A33A 87BE1FAD 4119370F 1E2261AA A1318FD3 F4329816 0717832 6E536A8D 9A81A601 E7E80F1 A09948 F849A584"
    },
    {
      "indent": 3,
      "text": "(i=8) v[16] = 07E5B85A 069CC164 F9DE3141 A56F4680 9E440AD2 9AB659EA 3C84B971 21DBD9CF 46699F8C 765257EC AF1D998C 75E4C3B6 523878DC 30715015 397FEE81 4F1FA799",
      "ja": "（S = 8）C16 = 07E5B85A 069164 F9DE3141 A56F4680 9E440AD2 9AB659EA 384B971 21DBD9F 46699F8 765257E AF1D998 75E43B6 523878D 30715015 397FEE81 4F1FA799"
    },
    {
      "indent": 3,
      "text": "(i=9) v[16] = 435148C4 A5AA2D11 4B354173 D543BC9E BDA2591C BF1D2569 4FCB3120 707ADA48 565B3FDE 32C9C916 EAF4A1AB B1018F28 8078D978 68ADE4B5 9778FDA3 2863B92E",
      "ja": "（S =秒）C16 = 4351484 A5AA2D11 4B354173 D543B9E BDA2591 BF1D2569 4FB3120 707ADA48 565B3FDE 329916 EAF4A1AB B1018F28 8078D978 68ADE4B5 9778FDA3 2863B92E"
    },
    {
      "indent": 3,
      "text": "(i=10) v[16] = D9C994AA CFEC3AA6 700D0AB2 2C38670E AF6A1F66 1D023EF3 1D9EC27D 945357A5 3E9FFEBD 969FE811 EF485E21 A632797A DEEF082E AF3D80E1 4E86829B 4DEAFD3A",
      "ja": "（N = 10）= vyu16sch DyaK994AA KFEKzAA6 700D0AB2 2S38670E AFshA1F66 1D02zEF3 1D9EK27D 945357A5 zEyaFFEBD 969FE811 EF485E21 A632797A DEF082E AF3D80E1 chE86829B 4DEAFD3A"
    },
    {
      "indent": 11,
      "text": "h[8] = 8C5E8C50 E2147C32 A32BA7E1 2F45EB4E 208B4537 293AD69E\n       4C9B994D 82596786",
      "raw": true
    },
    {
      "indent": 3,
      "text": "BLAKE2s-256(\"abc\") = 50 8C 5E 8C 32 7C 14 E2 E1 A7 2B A3 4E EB 45 2F 37 45 8B 20 9E D6 3A 29 4D 99 9B 4C 86 67 59 82",
      "ja": "Balkasikht（ \"APEC\"）= 50（c）（e）（c）32 7C 14 E2 E1 A7 2B A3 4E EB 45 2F 37 45 8B 20 9E D6 3A 29 4D 99（b）（c）86 67 59 82"
    },
    {
      "indent": 0,
      "text": "Appendix C. BLAKE2b Implementation C Source",
      "ja": "付録C. BLAKE2b実装Cソース"
    },
    {
      "indent": 0,
      "text": "C.1. blake2b.h",
      "ja": "C.1。 blake2b.h"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS> // blake2b.h // BLAKE2b Hashing Context and API Prototypes",
      "ja": "// // blake2b.h BLAKE2bハッシュコンテキストおよびAPIプロトタイプ<CODEが開始されます>を"
    },
    {
      "indent": 3,
      "text": "#ifndef BLAKE2B_H #define BLAKE2B_H",
      "ja": "#ifndefのBLAKE2B_Hの#define BLAKE2B_H"
    },
    {
      "indent": 3,
      "text": "#include <stdint.h> #include <stddef.h>",
      "ja": "書式#include <stdint.h>の#include <STDDEF.H>"
    },
    {
      "indent": 3,
      "text": "// state context\ntypedef struct {\n    uint8_t b[128];                     // input buffer\n    uint64_t h[8];                      // chained state\n    uint64_t t[2];                      // total number of bytes\n    size_t c;                           // pointer for b[]\n    size_t outlen;                      // digest size\n} blake2b_ctx;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "// Initialize the hashing context \"ctx\" with optional key \"key\". // 1 <= outlen <= 64 gives the digest size in bytes. // Secret key (also <= 64 bytes) is optional (keylen = 0). int blake2b_init(blake2b_ctx *ctx, size_t outlen, const void *key, size_t keylen); // secret key",
      "ja": "//ハッシュコンテキストオプションのキー「キー」と「CTX」を初期化します。 // 1 <= outlenは<= 64バイトでダイジェストサイズを与えます。 //秘密キー（また<= 64バイト）（KEYLEN = 0）はオプションです。 int型blake2b_init（blake2b_ctx * CTX、size_tのoutlenは、CONST void *型のキー、size_tのKEYLEN）。 //秘密鍵"
    },
    {
      "indent": 3,
      "text": "// Add \"inlen\" bytes from \"in\" into the hash. void blake2b_update(blake2b_ctx *ctx, // context const void *in, size_t inlen); // data to be hashed",
      "ja": "//ハッシュに「中」からのバイト「inlen」を追加します。空blake2b_update（blake2b_ctx * CTX、//コンテキストのconst void *型では、size_tのinlen）。 //データをハッシュ化します"
    },
    {
      "indent": 3,
      "text": "// Generate the message digest (size given in init). // Result placed in \"out\". void blake2b_final(blake2b_ctx *ctx, void *out);",
      "ja": "//メッセージダイジェスト（INITに与えられた大きさ）を生成します。 //「アウト」に置い結果。空blake2b_final（blake2b_ctx * CTX、無効*アウト）。"
    },
    {
      "indent": 3,
      "text": "// All-in-one convenience function. int blake2b(void *out, size_t outlen, // return buffer for digest const void *key, size_t keylen, // optional secret key const void *in, size_t inlen); // data to be hashed",
      "ja": "//オールインワンの便利な機能。 int型blake2b（void *型アウト、CONST void *型のキー、size_tのKEYLEN、//オプションの秘密鍵のconstボイドを消化するためにで*バッファを返す//、outlenはsize_t型、size_tのinlen）。 //データをハッシュ化します"
    },
    {
      "indent": 3,
      "text": "#endif <CODE ENDS>",
      "ja": "#endifの<CODEは終了します>"
    },
    {
      "indent": 0,
      "text": "C.2. blake2b.c",
      "ja": "C.2。 blake2b.c"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS> // blake2b.c // A simple BLAKE2b Reference Implementation.",
      "ja": "// // blake2b.cシンプルBLAKE2bリファレンス実装<CODEが開始されます>。"
    },
    {
      "indent": 3,
      "text": "#include \"blake2b.h\"",
      "ja": "#include \"blake2b.h\""
    },
    {
      "indent": 3,
      "text": "// Cyclic right rotation.",
      "ja": "//巡回右回転。"
    },
    {
      "indent": 3,
      "text": "#ifndef ROTR64 #define ROTR64(x, y) (((x) >> (y)) ^ ((x) << (64 - (y)))) #endif",
      "ja": "#ifndefのに#define ROTR64 ROTR64（x、y）は（（（X）>>（Y））+（（X）<<（64  - （Y））））#endifの"
    },
    {
      "indent": 3,
      "text": "// Little-endian byte access.",
      "ja": "//リトルエンディアンバイトアクセス。"
    },
    {
      "indent": 3,
      "text": "#define B2B_GET64(p) \\ (((uint64_t) ((uint8_t *) (p))[0]) ^ \\ (((uint64_t) ((uint8_t *) (p))[1]) << 8) ^ \\ (((uint64_t) ((uint8_t *) (p))[2]) << 16) ^ \\ (((uint64_t) ((uint8_t *) (p))[3]) << 24) ^ \\ (((uint64_t) ((uint8_t *) (p))[4]) << 32) ^ \\ (((uint64_t) ((uint8_t *) (p))[5]) << 40) ^ \\ (((uint64_t) ((uint8_t *) (p))[6]) << 48) ^ \\ (((uint64_t) ((uint8_t *) (p))[7]) << 56))",
      "ja": "#define B2B_GET64（P）\\（（（uint64_tを）（（uint8_t *）（P））[0]）^ \\（（（uint64_tを）（（uint8_t *）（P））[1]）<< 8）^ \\（（（uint64_tを）（（uint8_t *）（P））[2]）<< 16）^ \\（（（uint64_tを）（（uint8_t *）（P））[3]）<< 24）^（\\ （（uint64_tを）（（uint8_t *）（P））[4]）<< 32）^ \\（（（uint64_tを）（（uint8_t *）（P））[5]）<< 40）^ \\（（（ uint64_tを）（（uint8_t *）（P））[6]）<< 48）^ \\（（（uint64_tを）（（uint8_t *）（P））[7]）<< 56））"
    },
    {
      "indent": 3,
      "text": "// G Mixing function.",
      "ja": "// Gは、機能をミキシング。"
    },
    {
      "indent": 3,
      "text": "#define B2B_G(a, b, c, d, x, y) { \\ v[a] = v[a] + v[b] + x; \\ v[d] = ROTR64(v[d] ^ v[a], 32); \\ v[c] = v[c] + v[d]; \\ v[b] = ROTR64(v[b] ^ v[c], 24); \\ v[a] = v[a] + v[b] + y; \\ v[d] = ROTR64(v[d] ^ v[a], 16); \\ v[c] = v[c] + v[d]; \\ v[b] = ROTR64(v[b] ^ v[c], 63); }",
      "ja": "#define B2B_G（A、B、C、D、X、Y）{\\ V [A] = V [A] + V [B] + X。 \\ V [D] = ROTR64（V [D] ^ V [A]、32）。 \\ V [C] = V [C] + V [D]。 \\ V [B] = ROTR64（V [B] ^ V [C]、24）。 \\ V [A]、V [A] + Vが= [B] + Y。 \\ V [D] = ROTR64（V [D] ^ V [A]、16）。 \\ V [C] = V [C] + V [D]。 \\ V [B] = ROTR64（V [B] ^ V [C]、63）。 }"
    },
    {
      "indent": 3,
      "text": "// Initialization Vector.",
      "ja": "//初期化ベクトル。"
    },
    {
      "indent": 3,
      "text": "static const uint64_t blake2b_iv[8] = { 0x6A09E667F3BCC908, 0xBB67AE8584CAA73B, 0x3C6EF372FE94F82B, 0xA54FF53A5F1D36F1, 0x510E527FADE682D1, 0x9B05688C2B3E6C1F, 0x1F83D9ABFB41BD6B, 0x5BE0CD19137E2179 };",
      "ja": "blake2b_iv uint64_tを静的定数[8] = {0x6A09E667F3BCC908、0xBB67AE8584CAA73B、0x3C6EF372FE94F82B、0xA54FF53A5F1D36F1、0x510E527FADE682D1、0x9B05688C2B3E6C1F、0x1F83D9ABFB41BD6B、0x5BE0CD19137E2179}。"
    },
    {
      "indent": 3,
      "text": "// Compression function. \"last\" flag indicates last block.",
      "ja": "//圧縮機能。 「最後」フラグが最後のブロックを示しています。"
    },
    {
      "indent": 3,
      "text": "static void blake2b_compress(blake2b_ctx *ctx, int last)\n{\n    const uint8_t sigma[12][16] = {\n        { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 },\n        { 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3 },\n        { 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4 },\n        { 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8 },\n        { 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13 },\n        { 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9 },\n        { 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11 },\n        { 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10 },\n        { 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5 },\n        { 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0 },\n        { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 },\n        { 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3 }\n    };\n    int i;\n    uint64_t v[16], m[16];",
      "raw": true
    },
    {
      "indent": 7,
      "text": "for (i = 0; i < 8; i++) {           // init work variables\n    v[i] = ctx->h[i];\n    v[i + 8] = blake2b_iv[i];\n} v[12] ^= ctx->t[0];                 // low 64 bits of offset\nv[13] ^= ctx->t[1];                 // high 64 bits\nif (last)                           // last block flag set ?\n    v[14] = ~v[14];",
      "raw": true
    },
    {
      "indent": 7,
      "text": "for (i = 0; i < 16; i++) // get little-endian words m[i] = B2B_GET64(&ctx->b[8 * i]);",
      "ja": "用（i = 0; iは<16; iは++）は、リトルエンディアン単語mを取得// [I] = B2B_GET64（＆ctx-> B [8 * I]）。"
    },
    {
      "indent": 7,
      "text": "for (i = 0; i < 12; i++) {          // twelve rounds\n    B2B_G( 0, 4,  8, 12, m[sigma[i][ 0]], m[sigma[i][ 1]]);\n    B2B_G( 1, 5,  9, 13, m[sigma[i][ 2]], m[sigma[i][ 3]]);\n    B2B_G( 2, 6, 10, 14, m[sigma[i][ 4]], m[sigma[i][ 5]]);\n    B2B_G( 3, 7, 11, 15, m[sigma[i][ 6]], m[sigma[i][ 7]]);\n    B2B_G( 0, 5, 10, 15, m[sigma[i][ 8]], m[sigma[i][ 9]]);\n    B2B_G( 1, 6, 11, 12, m[sigma[i][10]], m[sigma[i][11]]);\n    B2B_G( 2, 7,  8, 13, m[sigma[i][12]], m[sigma[i][13]]);\n    B2B_G( 3, 4,  9, 14, m[sigma[i][14]], m[sigma[i][15]]);\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": " for( i = 0; i < 8; ++i ) ctx->h[i] ^= v[i] ^ v[i + 8]; }",
      "ja": "用（i = 0; iは<8; ++ I）ctx-> H [i]は^ = V [i]は^ V [I + 8]。 }"
    },
    {
      "indent": 3,
      "text": "// Initialize the hashing context \"ctx\" with optional key \"key\". // 1 <= outlen <= 64 gives the digest size in bytes. // Secret key (also <= 64 bytes) is optional (keylen = 0).",
      "ja": "//ハッシュコンテキストオプションのキー「キー」と「CTX」を初期化します。 // 1 <= outlenは<= 64バイトでダイジェストサイズを与えます。 //秘密キー（また<= 64バイト）（KEYLEN = 0）はオプションです。"
    },
    {
      "indent": 3,
      "text": "int blake2b_init(blake2b_ctx *ctx, size_t outlen, const void *key, size_t keylen) // (keylen=0: no key) { size_t i;",
      "ja": "int型blake2b_init（blake2b_ctx * CTX、outlenはsize_t型、CONST void *型のキー、size_tのKEYLEN）//（KEYLEN = 0：キーなし）{size_tの私。"
    },
    {
      "indent": 7,
      "text": "if (outlen == 0 || outlen > 64 || keylen > 64)\n    return -1;                      // illegal parameters",
      "raw": true
    },
    {
      "indent": 7,
      "text": "for (i = 0; i < 8; i++)             // state, \"param block\"\n    ctx->h[i] = blake2b_iv[i];\nctx->h[0] ^= 0x01010000 ^ (keylen << 8) ^ outlen;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "ctx->t[0] = 0; // input count low word ctx->t[1] = 0; // input count high word ctx->c = 0; // pointer within buffer ctx->outlen = outlen;",
      "ja": "ctx-> T [0] = 0。 //入力低い単語カウントctx-> T [1] = 0; //入力の高い単語を数えるctx-> C = 0; //> outlenは= outlenはctx-バッファ内のポインタ。"
    },
    {
      "indent": 7,
      "text": "for (i = keylen; i < 128; i++)      // zero input block\n    ctx->b[i] = 0;\nif (keylen > 0) {\n    blake2b_update(ctx, key, keylen);\n    ctx->c = 128;                   // at the end\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": " return 0; }",
      "ja": "0を返します。 }"
    },
    {
      "indent": 3,
      "text": "// Add \"inlen\" bytes from \"in\" into the hash.",
      "ja": "//ハッシュに「中」からのバイト「inlen」を追加します。"
    },
    {
      "indent": 3,
      "text": "void blake2b_update(blake2b_ctx *ctx, const void *in, size_t inlen) // data bytes { size_t i;",
      "ja": "ボイドblake2b_update（blake2b_ctx * CTX、CONSTボイド*において、size_tのinlen）//データバイト{size_tのI。"
    },
    {
      "indent": 3,
      "text": " for (i = 0; i < inlen; i++) { if (ctx->c == 128) { // buffer full ? ctx->t[0] += ctx->c; // add counters if (ctx->t[0] < ctx->c) // carry overflow ? ctx->t[1]++; // high word blake2b_compress(ctx, 0); // compress (not last) ctx->c = 0; // counter to zero } ctx->b[ctx->c++] = ((const uint8_t *) in)[i]; } }",
      "ja": "用（i = 0; iは<inlen; iは++）{IF（ctx-> Cの== 128）{//バッファフル？ ctx-> T [0] + = ctx-> C。 （ctx-> T [0] <ctx-> C）場合//キャリーオーバーフローカウンタを追加しますか？ ctx-> T [1] ++; //高いワードblake2b_compress（CTX、0）; //圧縮（最後ではない）ctx-> C = 0; //ゼロにカウンタ} ctx-> [ctx-> C ++] = B [i]は（（CONST uint8_t *）で）。 }}"
    },
    {
      "indent": 3,
      "text": "// Generate the message digest (size given in init). // Result placed in \"out\".",
      "ja": "//メッセージダイジェスト（INITに与えられた大きさ）を生成します。 //「アウト」に置い結果。"
    },
    {
      "indent": 3,
      "text": "void blake2b_final(blake2b_ctx *ctx, void *out) { size_t i;",
      "ja": "空blake2b_final（blake2b_ctx * CTX、無効*アウト）{size_tの私。"
    },
    {
      "indent": 7,
      "text": "ctx->t[0] += ctx->c;                // mark last block offset\nif (ctx->t[0] < ctx->c)             // carry overflow\n    ctx->t[1]++;                    // high word",
      "raw": true
    },
    {
      "indent": 7,
      "text": "while (ctx->c < 128) // fill up with zeros ctx->b[ctx->c++] = 0; blake2b_compress(ctx, 1); // final block flag = 1",
      "ja": "（ctx-> C <128）//ながらゼロctx-> B [ctx-> C ++] = 0で埋めます。 blake2b_compress（CTX、1）。 //最終ブロックフラグ= 1"
    },
    {
      "indent": 3,
      "text": " // little endian convert and store for (i = 0; i < ctx->outlen; i++) { ((uint8_t *) out)[i] = (ctx->h[i >> 3] >> (8 * (i & 7))) & 0xFF; } }",
      "ja": "用//リトルエンディアン変換およびストア（i = 0; I <ctx-> outlenは、iが++）{（（uint8_t *）アウト）[I] =（ctx-> H [I >> 3] >>（8 * （I＆7）））＆0xFFで、 }}"
    },
    {
      "indent": 3,
      "text": "// Convenience function for all-in-one computation.",
      "ja": "//オールインワン計算のための便利な機能。"
    },
    {
      "indent": 3,
      "text": "int blake2b(void *out, size_t outlen, const void *key, size_t keylen, const void *in, size_t inlen) { blake2b_ctx ctx;",
      "ja": "blake2b_ctx CTX int型blake2b（void *型アウト、size_tのoutlenは、CONST void *型のキー、size_tのKEYLEN、CONST void *型では、size_tのinlen）{;"
    },
    {
      "indent": 7,
      "text": "if (blake2b_init(&ctx, outlen, key, keylen))\n    return -1;\nblake2b_update(&ctx, in, inlen);\nblake2b_final(&ctx, out);",
      "raw": true
    },
    {
      "indent": 3,
      "text": " return 0; } <CODE ENDS>",
      "ja": "0を返します。 } <CODEを終了します>"
    },
    {
      "indent": 0,
      "text": "Appendix D. BLAKE2s Implementation C Source",
      "ja": "付録D. BLAKE2s実装Cソース"
    },
    {
      "indent": 0,
      "text": "D.1. blake2s.h",
      "ja": "D.1。 blake2s.h"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS> // blake2s.h // BLAKE2s Hashing Context and API Prototypes",
      "ja": "// // blake2s.h BLAKE2sハッシュコンテキストおよびAPIプロトタイプ<CODEが開始されます>を"
    },
    {
      "indent": 3,
      "text": "#ifndef BLAKE2S_H #define BLAKE2S_H",
      "ja": "#ifndefのBLAKE2S_Hの#define BLAKE2S_H"
    },
    {
      "indent": 3,
      "text": "#include <stdint.h> #include <stddef.h>",
      "ja": "書式#include <stdint.h>の#include <STDDEF.H>"
    },
    {
      "indent": 3,
      "text": "// state context\ntypedef struct {\n    uint8_t b[64];                      // input buffer\n    uint32_t h[8];                      // chained state\n    uint32_t t[2];                      // total number of bytes\n    size_t c;                           // pointer for b[]\n    size_t outlen;                      // digest size\n} blake2s_ctx;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "// Initialize the hashing context \"ctx\" with optional key \"key\". // 1 <= outlen <= 32 gives the digest size in bytes. // Secret key (also <= 32 bytes) is optional (keylen = 0). int blake2s_init(blake2s_ctx *ctx, size_t outlen, const void *key, size_t keylen); // secret key",
      "ja": "//ハッシュコンテキストオプションのキー「キー」と「CTX」を初期化します。 // 1 <= outlenは<= 32バイトでダイジェストサイズを与えます。 //秘密キー（また<= 32バイト）（KEYLEN = 0）はオプションです。 int型blake2s_init（blake2s_ctx * CTX、size_tのoutlenは、CONST void *型のキー、size_tのKEYLEN）。 //秘密鍵"
    },
    {
      "indent": 3,
      "text": "// Add \"inlen\" bytes from \"in\" into the hash. void blake2s_update(blake2s_ctx *ctx, // context const void *in, size_t inlen); // data to be hashed",
      "ja": "//ハッシュに「中」からのバイト「inlen」を追加します。空blake2s_update（blake2s_ctx * CTX、//コンテキストのconst void *型では、size_tのinlen）。 //データをハッシュ化します"
    },
    {
      "indent": 3,
      "text": "// Generate the message digest (size given in init). // Result placed in \"out\". void blake2s_final(blake2s_ctx *ctx, void *out);",
      "ja": "//メッセージダイジェスト（INITに与えられた大きさ）を生成します。 //「アウト」に置い結果。空blake2s_final（blake2s_ctx * CTX、無効*アウト）。"
    },
    {
      "indent": 3,
      "text": "// All-in-one convenience function. int blake2s(void *out, size_t outlen, // return buffer for digest const void *key, size_t keylen, // optional secret key const void *in, size_t inlen); // data to be hashed",
      "ja": "//オールインワンの便利な機能。 int型blake2s（void *型アウト、CONST void *型のキー、size_tのKEYLEN、//オプションの秘密鍵のconstボイドを消化するためにで*バッファを返す//、outlenはsize_t型、size_tのinlen）。 //データをハッシュ化します"
    },
    {
      "indent": 3,
      "text": "#endif <CODE ENDS>",
      "ja": "#endifの<CODEは終了します>"
    },
    {
      "indent": 0,
      "text": "D.2. blake2s.c",
      "ja": "D.2。 blake2s.c"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS> // blake2s.c // A simple blake2s Reference Implementation.",
      "ja": "// // blake2s.cシンプルblake2sリファレンス実装<CODEが開始されます>。"
    },
    {
      "indent": 3,
      "text": "#include \"blake2s.h\"",
      "ja": "#include \"blake2s.h\""
    },
    {
      "indent": 3,
      "text": "// Cyclic right rotation.",
      "ja": "//巡回右回転。"
    },
    {
      "indent": 3,
      "text": "#ifndef ROTR32 #define ROTR32(x, y) (((x) >> (y)) ^ ((x) << (32 - (y)))) #endif",
      "ja": "#ifndefのに#define ROTR32 ROTR32（x、y）は（（（X）>>（Y））+（（X）<<（32  - （Y））））#endifの"
    },
    {
      "indent": 3,
      "text": "// Little-endian byte access.",
      "ja": "//リトルエンディアンバイトアクセス。"
    },
    {
      "indent": 3,
      "text": "#define B2S_GET32(p) \\ (((uint32_t) ((uint8_t *) (p))[0]) ^ \\ (((uint32_t) ((uint8_t *) (p))[1]) << 8) ^ \\ (((uint32_t) ((uint8_t *) (p))[2]) << 16) ^ \\ (((uint32_t) ((uint8_t *) (p))[3]) << 24))",
      "ja": "#define B2S_GET32（P）\\（（（のuint32_t）（（uint8_t *）（P））[0]）^ \\（（（のuint32_t）（（uint8_t *）（P））[1]）<< 8）^ \\（（（のuint32_t）（（uint8_t *）（P））[2]）<< 16）^ \\（（（のuint32_t）（（uint8_t *）（P））[3]）<< 24））"
    },
    {
      "indent": 3,
      "text": "// Mixing function G.",
      "ja": "//ミキシング機能G."
    },
    {
      "indent": 3,
      "text": "#define B2S_G(a, b, c, d, x, y) { \\ v[a] = v[a] + v[b] + x; \\ v[d] = ROTR32(v[d] ^ v[a], 16); \\ v[c] = v[c] + v[d]; \\ v[b] = ROTR32(v[b] ^ v[c], 12); \\ v[a] = v[a] + v[b] + y; \\ v[d] = ROTR32(v[d] ^ v[a], 8); \\ v[c] = v[c] + v[d]; \\ v[b] = ROTR32(v[b] ^ v[c], 7); }",
      "ja": "#define B2S_G（A、B、C、D、X、Y）{\\ V [A] = V [A] + V [B] + X。 \\ V [D] = ROTR32（V [D] ^ V [A]、16）。 \\ V [C] = V [C] + V [D]。 \\ V [B] = ROTR32（V [B] ^ V [C]、12）。 \\ V [A]、V [A] + Vが= [B] + Y。 \\ V [D] = ROTR32（V [D] ^ V [A]、8）。 \\ V [C] = V [C] + V [D]。 \\ V [B] = ROTR32（V [B] ^ V [C]、7）。 }"
    },
    {
      "indent": 3,
      "text": "// Initialization Vector.",
      "ja": "//初期化ベクトル。"
    },
    {
      "indent": 3,
      "text": "static const uint32_t blake2s_iv[8] = { 0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A, 0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19 };",
      "ja": "blake2s_ivのuint32_t静的定数[8] = {0x6A09E667、0xBB67AE85、0x3C6EF372、0xA54FF53A、0x510E527F、0x9B05688C、0x1F83D9AB、0x5BE0CD19}。"
    },
    {
      "indent": 3,
      "text": "// Compression function. \"last\" flag indicates last block.",
      "ja": "//圧縮機能。 「最後」フラグが最後のブロックを示しています。"
    },
    {
      "indent": 3,
      "text": "static void blake2s_compress(blake2s_ctx *ctx, int last)\n{\n    const uint8_t sigma[10][16] = {\n        { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 },\n        { 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3 },\n        { 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4 },\n        { 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8 },\n        { 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13 },\n        { 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9 },\n        { 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11 },\n        { 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10 },\n        { 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5 },\n        { 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0 }\n    };\n    int i;\n    uint32_t v[16], m[16];",
      "raw": true
    },
    {
      "indent": 7,
      "text": "for (i = 0; i < 8; i++) {           // init work variables\n    v[i] = ctx->h[i];\n    v[i + 8] = blake2s_iv[i];\n}",
      "raw": true
    },
    {
      "indent": 7,
      "text": "v[12] ^= ctx->t[0]; // low 32 bits of offset v[13] ^= ctx->t[1]; // high 32 bits if (last) // last block flag set ? v[14] = ~v[14];",
      "ja": "V [12] ^ = ctx-> T [0]。オフセットVの//下位32ビット[13] ^ = ctx-> T [1]。 //高い32ビット（最後の）//最後のブロックフラグのセットであれば？ V [14] =〜V [14]。"
    },
    {
      "indent": 7,
      "text": "for (i = 0; i < 16; i++) // get little-endian words m[i] = B2S_GET32(&ctx->b[4 * i]);",
      "ja": "用（i = 0; iは<16; iは++）は、リトルエンディアン単語mを取得// [I] = B2S_GET32（＆ctx-> B [4 * I]）。"
    },
    {
      "indent": 7,
      "text": "for (i = 0; i < 10; i++) {          // ten rounds\n    B2S_G( 0, 4,  8, 12, m[sigma[i][ 0]], m[sigma[i][ 1]]);\n    B2S_G( 1, 5,  9, 13, m[sigma[i][ 2]], m[sigma[i][ 3]]);\n    B2S_G( 2, 6, 10, 14, m[sigma[i][ 4]], m[sigma[i][ 5]]);\n    B2S_G( 3, 7, 11, 15, m[sigma[i][ 6]], m[sigma[i][ 7]]);\n    B2S_G( 0, 5, 10, 15, m[sigma[i][ 8]], m[sigma[i][ 9]]);\n    B2S_G( 1, 6, 11, 12, m[sigma[i][10]], m[sigma[i][11]]);\n    B2S_G( 2, 7,  8, 13, m[sigma[i][12]], m[sigma[i][13]]);\n    B2S_G( 3, 4,  9, 14, m[sigma[i][14]], m[sigma[i][15]]);\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": " for( i = 0; i < 8; ++i ) ctx->h[i] ^= v[i] ^ v[i + 8]; }",
      "ja": "用（i = 0; iは<8; ++ I）ctx-> H [i]は^ = V [i]は^ V [I + 8]。 }"
    },
    {
      "indent": 3,
      "text": "// Initialize the hashing context \"ctx\" with optional key \"key\". // 1 <= outlen <= 32 gives the digest size in bytes. // Secret key (also <= 32 bytes) is optional (keylen = 0).",
      "ja": "//ハッシュコンテキストオプションのキー「キー」と「CTX」を初期化します。 // 1 <= outlenは<= 32バイトでダイジェストサイズを与えます。 //秘密キー（また<= 32バイト）（KEYLEN = 0）はオプションです。"
    },
    {
      "indent": 3,
      "text": "int blake2s_init(blake2s_ctx *ctx, size_t outlen, const void *key, size_t keylen) // (keylen=0: no key) { size_t i;",
      "ja": "int型blake2s_init（blake2s_ctx * CTX、outlenはsize_t型、CONST void *型のキー、size_tのKEYLEN）//（KEYLEN = 0：キーなし）{size_tの私。"
    },
    {
      "indent": 7,
      "text": "if (outlen == 0 || outlen > 32 || keylen > 32)\n    return -1;                      // illegal parameters",
      "raw": true
    },
    {
      "indent": 7,
      "text": "for (i = 0; i < 8; i++)             // state, \"param block\"\n    ctx->h[i] = blake2s_iv[i];\nctx->h[0] ^= 0x01010000 ^ (keylen << 8) ^ outlen;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "ctx->t[0] = 0; // input count low word ctx->t[1] = 0; // input count high word ctx->c = 0; // pointer within buffer ctx->outlen = outlen;",
      "ja": "ctx-> T [0] = 0。 //入力低い単語カウントctx-> T [1] = 0; //入力の高い単語を数えるctx-> C = 0; //> outlenは= outlenはctx-バッファ内のポインタ。"
    },
    {
      "indent": 7,
      "text": "for (i = keylen; i < 64; i++)       // zero input block\n    ctx->b[i] = 0;\nif (keylen > 0) {\n    blake2s_update(ctx, key, keylen);\n    ctx->c = 64;                    // at the end\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": " return 0; }",
      "ja": "0を返します。 }"
    },
    {
      "indent": 3,
      "text": "// Add \"inlen\" bytes from \"in\" into the hash.",
      "ja": "//ハッシュに「中」からのバイト「inlen」を追加します。"
    },
    {
      "indent": 3,
      "text": "void blake2s_update(blake2s_ctx *ctx, const void *in, size_t inlen) // data bytes { size_t i;",
      "ja": "ボイドblake2s_update（blake2s_ctx * CTX、CONSTボイド*において、size_tのinlen）//データバイト{size_tのI。"
    },
    {
      "indent": 3,
      "text": " for (i = 0; i < inlen; i++) { if (ctx->c == 64) { // buffer full ? ctx->t[0] += ctx->c; // add counters if (ctx->t[0] < ctx->c) // carry overflow ? ctx->t[1]++; // high word blake2s_compress(ctx, 0); // compress (not last) ctx->c = 0; // counter to zero } ctx->b[ctx->c++] = ((const uint8_t *) in)[i]; } }",
      "ja": "用（i = 0; iは<inlen; iが++）{（ctx-場合> Cの== 64）{//バッファフル？ ctx-> T [0] + = ctx-> C。 （ctx-> T [0] <ctx-> C）場合//キャリーオーバーフローカウンタを追加しますか？ ctx-> T [1] ++; //高いワードblake2s_compress（CTX、0）; //圧縮（最後ではない）ctx-> C = 0; //ゼロにカウンタ} ctx-> [ctx-> C ++] = B [i]は（（CONST uint8_t *）で）。 }}"
    },
    {
      "indent": 3,
      "text": "// Generate the message digest (size given in init). // Result placed in \"out\".",
      "ja": "//メッセージダイジェスト（INITに与えられた大きさ）を生成します。 //「アウト」に置い結果。"
    },
    {
      "indent": 3,
      "text": "void blake2s_final(blake2s_ctx *ctx, void *out) { size_t i;",
      "ja": "空blake2s_final（blake2s_ctx * CTX、無効*アウト）{size_tの私。"
    },
    {
      "indent": 7,
      "text": "ctx->t[0] += ctx->c;                // mark last block offset\nif (ctx->t[0] < ctx->c)             // carry overflow\n    ctx->t[1]++;                    // high word",
      "raw": true
    },
    {
      "indent": 7,
      "text": "while (ctx->c < 64) // fill up with zeros ctx->b[ctx->c++] = 0; blake2s_compress(ctx, 1); // final block flag = 1",
      "ja": "（ctx-> C <64）//ながらゼロctx-> B [ctx-> C ++] = 0で埋めます。 blake2s_compress（CTX、1）。 //最終ブロックフラグ= 1"
    },
    {
      "indent": 3,
      "text": " // little endian convert and store for (i = 0; i < ctx->outlen; i++) { ((uint8_t *) out)[i] = (ctx->h[i >> 2] >> (8 * (i & 3))) & 0xFF; } }",
      "ja": "用//リトルエンディアン変換およびストア（i = 0; I <ctx-> outlenは、iが++）{（（uint8_t *）アウト）[I] =（ctx-> H [I >> 2] >>（8 * （I＆3）））＆0xFFで、 }}"
    },
    {
      "indent": 3,
      "text": "// Convenience function for all-in-one computation.",
      "ja": "//オールインワン計算のための便利な機能。"
    },
    {
      "indent": 3,
      "text": "int blake2s(void *out, size_t outlen, const void *key, size_t keylen, const void *in, size_t inlen) { blake2s_ctx ctx;",
      "ja": "blake2s（void *型アウト、size_tのoutlenは、CONST void *型のキー、size_tのKEYLEN、CONST void *型では、size_tのinlen）{blake2s_ctx CTXをint型。"
    },
    {
      "indent": 7,
      "text": "if (blake2s_init(&ctx, outlen, key, keylen))\n    return -1;\nblake2s_update(&ctx, in, inlen);\nblake2s_final(&ctx, out);",
      "raw": true
    },
    {
      "indent": 3,
      "text": " return 0; } <CODE ENDS>",
      "ja": "0を返します。 } <CODEを終了します>"
    },
    {
      "indent": 0,
      "text": "Appendix E. BLAKE2b and BLAKE2s Self-Test Module C Source",
      "ja": "付録E. BLAKE2bとBLAKE2sセルフテストモジュールのCソース"
    },
    {
      "indent": 3,
      "text": "This module computes a series of keyed and unkeyed hashes from deterministically generated pseudorandom data and computes a hash over those results. This is a fairly exhaustive, yet compact and fast method for verifying that the hashing module is functioning correctly.",
      "ja": "このモジュールは、決定論的に生成擬似ランダムデータからキー付きとキーなしハッシュのシリーズを計算し、それらの結果の上のハッシュを計算します。これは、ハッシュモジュールが正しく機能していることを検証するため、かなり網羅、まだコンパクトで高速な方法です。"
    },
    {
      "indent": 3,
      "text": "Such testing is RECOMMENDED, especially when compiling the implementation for a new a target platform configuration. Furthermore, some security standards, such as FIPS-140, may require a Power-On Self Test (POST) to be performed every time the cryptographic module is loaded [FIPS140-2IG].",
      "ja": "新しいターゲットプラットフォーム構成の実装をコンパイルする場合は特に、このようなテストは、推奨されます。さらに、そのようなFIPS-140のようないくつかのセキュリティ基準は、暗号モジュールが[FIPS140-2IG]ロードされるたびに実行されるパワーオンセルフテスト（POST）を必要とするかもしれません。"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS> // test_main.c // Self test Modules for BLAKE2b and BLAKE2s -- and a stub main().",
      "ja": "メインスタブ（） -  // test_main.c //セルフテストBLAKE2bとBLAKE2sためのモジュール<CODEが開始されます>を。"
    },
    {
      "indent": 3,
      "text": "#include <stdio.h>",
      "ja": "書式#include <stdio.hに>"
    },
    {
      "indent": 3,
      "text": "#include \"blake2b.h\" #include \"blake2s.h\"",
      "ja": "#include \"blake2b.h\" の#include \"blake2s.h\""
    },
    {
      "indent": 3,
      "text": "// Deterministic sequences (Fibonacci generator).",
      "ja": "//決定論的系列（フィボナッチジェネレータ）。"
    },
    {
      "indent": 3,
      "text": "static void selftest_seq(uint8_t *out, size_t len, uint32_t seed)\n{\n    size_t i;\n    uint32_t t, a , b;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "a = 0xDEAD4BAD * seed;              // prime\nb = 1;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "for (i = 0; i < len; i++) {         // fill the buf\n    t = a + b;\n    a = b;\n    b = t;\n    out[i] = (t >> 24) & 0xFF;\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "}",
      "ja": "｝"
    },
    {
      "indent": 3,
      "text": "// BLAKE2b self-test validation. Return 0 when OK.",
      "ja": "// BLAKE2bセルフテストの検証。たら、[OK] 0を返します。"
    },
    {
      "indent": 3,
      "text": "int blake2b_selftest()\n{\n    // grand hash of hash results\n    const uint8_t blake2b_res[32] = {\n        0xC2, 0x3A, 0x78, 0x00, 0xD9, 0x81, 0x23, 0xBD,\n        0x10, 0xF5, 0x06, 0xC6, 0x1E, 0x29, 0xDA, 0x56,\n        0x03, 0xD7, 0x63, 0xB8, 0xBB, 0xAD, 0x2E, 0x73,\n        0x7F, 0x5E, 0x76, 0x5A, 0x7B, 0xCC, 0xD4, 0x75\n    };\n    // parameter sets\n    const size_t b2b_md_len[4] = { 20, 32, 48, 64 };\n    const size_t b2b_in_len[6] = { 0, 3, 128, 129, 255, 1024 };",
      "raw": true
    },
    {
      "indent": 7,
      "text": "size_t i, j, outlen, inlen;\nuint8_t in[1024], md[64], key[64];\nblake2b_ctx ctx;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "// 256-bit hash for testing if (blake2b_init(&ctx, 32, NULL, 0)) return -1;",
      "ja": "テスト用// 256ビットのハッシュ（blake2b_init（＆CTX、32、NULL、0））を返す場合は-1。"
    },
    {
      "indent": 7,
      "text": "for (i = 0; i < 4; i++) {\n    outlen = b2b_md_len[i];\n    for (j = 0; j < 6; j++) {\n        inlen = b2b_in_len[j];",
      "raw": true
    },
    {
      "indent": 15,
      "text": "selftest_seq(in, inlen, inlen);     // unkeyed hash\nblake2b(md, outlen, NULL, 0, in, inlen);\nblake2b_update(&ctx, md, outlen);   // hash the hash",
      "raw": true
    },
    {
      "indent": 7,
      "text": " selftest_seq(key, outlen, outlen); // keyed hash blake2b(md, outlen, key, outlen, in, inlen); blake2b_update(&ctx, md, outlen); // hash the hash } }",
      "ja": "selftest_seq（キー、outlenは、outlenは）; //鍵付きハッシュblake2b（MD、outlenは、キー、outlenは、inlen、IN）。 blake2b_update（＆CTX、MD、outlenは）。 //}}ハッシュハッシュ"
    },
    {
      "indent": 7,
      "text": "// compute and compare the hash of hashes\nblake2b_final(&ctx, md);\nfor (i = 0; i < 32; i++) {\n    if (md[i] != blake2b_res[i])\n        return -1;\n}",
      "raw": true
    },
    {
      "indent": 7,
      "text": "return 0;",
      "ja": "0を返します。"
    },
    {
      "indent": 3,
      "text": "}",
      "ja": "｝"
    },
    {
      "indent": 3,
      "text": "// BLAKE2s self-test validation. Return 0 when OK.",
      "ja": "// BLAKE2sセルフテストの検証。たら、[OK] 0を返します。"
    },
    {
      "indent": 3,
      "text": "int blake2s_selftest()\n{\n    // Grand hash of hash results.\n    const uint8_t blake2s_res[32] = {\n        0x6A, 0x41, 0x1F, 0x08, 0xCE, 0x25, 0xAD, 0xCD,\n        0xFB, 0x02, 0xAB, 0xA6, 0x41, 0x45, 0x1C, 0xEC,\n        0x53, 0xC5, 0x98, 0xB2, 0x4F, 0x4F, 0xC7, 0x87,\n        0xFB, 0xDC, 0x88, 0x79, 0x7F, 0x4C, 0x1D, 0xFE\n    };\n    // Parameter sets.\n    const size_t b2s_md_len[4] = { 16, 20, 28, 32 };\n    const size_t b2s_in_len[6] = { 0,  3,  64, 65, 255, 1024 };",
      "raw": true
    },
    {
      "indent": 7,
      "text": "size_t i, j, outlen, inlen;\nuint8_t in[1024], md[32], key[32];\nblake2s_ctx ctx;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "// 256-bit hash for testing. if (blake2s_init(&ctx, 32, NULL, 0)) return -1;",
      "ja": "テスト用// 256ビットのハッシュ。 IF（blake2s_init（＆CTX、32、NULL、0））-1を返します。"
    },
    {
      "indent": 7,
      "text": "for (i = 0; i < 4; i++) {\n    outlen = b2s_md_len[i];\n    for (j = 0; j < 6; j++) {\n        inlen = b2s_in_len[j];",
      "raw": true
    },
    {
      "indent": 15,
      "text": "selftest_seq(in, inlen, inlen);     // unkeyed hash\nblake2s(md, outlen, NULL, 0, in, inlen);\nblake2s_update(&ctx, md, outlen);   // hash the hash",
      "raw": true
    },
    {
      "indent": 7,
      "text": " selftest_seq(key, outlen, outlen); // keyed hash blake2s(md, outlen, key, outlen, in, inlen); blake2s_update(&ctx, md, outlen); // hash the hash } }",
      "ja": "selftest_seq（キー、outlenは、outlenは）; //鍵付きハッシュblake2s（MD、outlenは、キー、outlenは、inlen、IN）。 blake2s_update（＆CTX、MD、outlenは）。 //}}ハッシュハッシュ"
    },
    {
      "indent": 7,
      "text": "// Compute and compare the hash of hashes.\nblake2s_final(&ctx, md);\nfor (i = 0; i < 32; i++) {\n    if (md[i] != blake2s_res[i])\n        return -1;\n}",
      "raw": true
    },
    {
      "indent": 7,
      "text": "return 0;",
      "ja": "0を返します。"
    },
    {
      "indent": 3,
      "text": "}",
      "ja": "｝"
    },
    {
      "indent": 3,
      "text": "// Test driver.",
      "ja": "//テストドライバー。"
    },
    {
      "indent": 3,
      "text": "int main(int argc, char **argv)\n{\n    printf(\"blake2b_selftest() = %s\\n\",\n         blake2b_selftest() ? \"FAIL\" : \"OK\");\n    printf(\"blake2s_selftest() = %s\\n\",\n         blake2s_selftest() ? \"FAIL\" : \"OK\");",
      "raw": true
    },
    {
      "indent": 3,
      "text": " return 0; } <CODE ENDS>",
      "ja": "0を返します。 } <CODEを終了します>"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "The editor wishes to thank the [BLAKE2] team for their encouragement: Jean-Philippe Aumasson, Samuel Neves, Zooko Wilcox-O'Hearn, and Christian Winnerlein. We have borrowed passages from [BLAKE] and [BLAKE2] with permission.",
      "ja": "ジャン=フィリップ・Aumasson、サミュエル・ネヴェス、ズック・ウィルコックス・オハーン、およびキリスト教のWinnerlein：エディタは彼らの励ましのために[BLAKE2]チームに感謝したいです。私たちは、許可を得て[BLAKE2] [BLAKE]から通路を借りています。"
    },
    {
      "indent": 3,
      "text": "[BLAKE2] is based on the SHA-3 proposal [BLAKE], designed by Jean-Philippe Aumasson, Luca Henzen, Willi Meier, and Raphael C.-W. Phan. BLAKE2, like BLAKE, relies on a core algorithm borrowed from the ChaCha stream cipher, designed by Daniel J. Bernstein.",
      "ja": "【BLAKE2]ジャン・フィリップAumasson、ルカHenzen、ウィリマイヤー、及びラファエルC.-W.によって設計されたSHA-3案[BLAKE]、に基づいていますPhanさん。 BLAKE2は、BLAKEように、ダニエル・バーンスタインによって設計ChaChaのストリーム暗号、から借りコアアルゴリズムに依存しています。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Markku-Juhani O. Saarinen (editor) Queen's University Belfast Centre for Secure Information Technologies, ECIT Northern Ireland Science Park Queen's Road, Queen's Island Belfast BT3 9DT United Kingdom",
      "ja": "セキュアな情報技術のためのマルック・Juhani O.サーリネン（エディタ）クイーンズ大学ベルファストセンター、ECIT北アイルランドサイエンスパーククイーンズ・ロード、女王の島ベルファストBT3 9DTイギリス"
    },
    {
      "indent": 3,
      "text": "Email: m.saarinen@qub.ac.uk URI: http://www.csit.qub.ac.uk",
      "ja": "メール：m.saarinen@qub.ac.uk URI：http://www.csit.qub.ac.uk"
    },
    {
      "indent": 3,
      "text": "Jean-Philippe Aumasson Kudelski Security 22-24, Route de Geneve Case Postale 134 Cheseaux 1033 Switzerland",
      "ja": "ジャン=フィリップ・Aumasson Kudelskiセキュリティ22-24、道路私書箱134ジュネーブ1033スイスCheseaux"
    },
    {
      "indent": 3,
      "text": "Email: jean-philippe.aumasson@nagra.com URI: https://www.kudelskisecurity.com",
      "ja": "メール：jean-philippe.aumasson@nagra.com URI：https://www.kudelskisecurity.com"
    }
  ]
}