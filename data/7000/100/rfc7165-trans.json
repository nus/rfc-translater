{
  "title": {
    "text": "RFC 7165 - Use Cases and Requirements for JSON Object Signing and Encryption (JOSE)",
    "ja": "RFC 7165 - JSONオブジェクトの署名と暗号化のためのケースと要件を使用します（JOSE）"
  },
  "number": 7165,
  "created_at": "2019-10-29 12:55:53.723198+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                         R. Barnes\nRequest for Comments: 7165                                       Mozilla\nCategory: Informational                                       April 2014\nISSN: 2070-1721",
      "raw": true
    },
    {
      "indent": 15,
      "text": "      Use Cases and Requirements for\nJSON Object Signing and Encryption (JOSE)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "Many Internet applications have a need for object-based security mechanisms in addition to security mechanisms at the network layer or transport layer. For many years, the Cryptographic Message Syntax (CMS) has provided a binary secure object format based on ASN.1. Over time, binary object encodings such as ASN.1 have become less common than text-based encodings, such as the JavaScript Object Notation (JSON). This document defines a set of use cases and requirements for a secure object format encoded using JSON, drawn from a variety of application security mechanisms currently in development.",
      "ja": "多くのインターネットアプリケーションは、ネットワーク層やトランスポート層でのセキュリティメカニズムに加えて、オブジェクトベースのセキュリティ・メカニズムを必要としています。長年にわたり、暗号メッセージ構文（CMS）は、ASN.1に基づくバイナリセキュアなオブジェクト形式を提供してきました。時間が経つにつれて、ASN.1などのバイナリオブジェクトのエンコーディングには、JavaScriptのObject Notation（JSON）形式などのテキストベースのエンコーディング、より少ない一般的になってきました。この文書は、現在開発中のアプリケーションのセキュリティメカニズムの多様から引き出されたJSONを使用して符号化セキュアなオブジェクト形式のためのユースケースと要件のセットを定義します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "ja": "このドキュメントはインターネット標準化過程仕様ではありません。それは、情報提供の目的のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are a candidate for any level of Internet Standard; see Section 2 of RFC 5741.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。 IESGによって承認されていないすべての文書がインターネットStandardのどんなレベルの候補です。 RFC 5741のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7165.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7165で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2014 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2014 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3\n2.  Definitions . . . . . . . . . . . . . . . . . . . . . . . . .   4\n3.  Basic Requirements  . . . . . . . . . . . . . . . . . . . . .   5\n4.  Requirements on Application Protocols . . . . . . . . . . . .   6\n5.  Use Cases . . . . . . . . . . . . . . . . . . . . . . . . . .   7\n  5.1.  Security Tokens . . . . . . . . . . . . . . . . . . . . .   7\n  5.2.  OAuth . . . . . . . . . . . . . . . . . . . . . . . . . .   7\n  5.3.  OpenID Connect  . . . . . . . . . . . . . . . . . . . . .   9\n  5.4.  XMPP  . . . . . . . . . . . . . . . . . . . . . . . . . .  10\n  5.5.  ALTO  . . . . . . . . . . . . . . . . . . . . . . . . . .  12\n  5.6.  Emergency Alerting  . . . . . . . . . . . . . . . . . . .  13\n  5.7.  Web Cryptography  . . . . . . . . . . . . . . . . . . . .  15\n  5.8.  Constrained Devices . . . . . . . . . . . . . . . . . . .  16\n    5.8.1.  Example: MAC Based on ECDH-Derived Key  . . . . . . .  16\n    5.8.2.  Object Security for CoAP  . . . . . . . . . . . . . .  17\n6.  Requirements  . . . . . . . . . . . . . . . . . . . . . . . .  18\n  6.1.  Functional Requirements . . . . . . . . . . . . . . . . .  18\n  6.2.  Security Requirements . . . . . . . . . . . . . . . . . .  19\n  6.3.  Desiderata  . . . . . . . . . . . . . . . . . . . . . . .  20\n7.  Security Considerations . . . . . . . . . . . . . . . . . . .  20\n8.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  21\n  8.1.  Normative References  . . . . . . . . . . . . . . . . . .  21\n  8.2.  Informative References  . . . . . . . . . . . . . . . . .  21\nAppendix A.  Acknowledgements . . . . . . . . . . . . . . . . . .  25",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "Internet applications rest on the layered architecture of the Internet and take advantage of security mechanisms at all layers. Many applications rely primarily on channel-based security technologies such as IPsec and Transport Layer Security (TLS), which create a secure channel at the IP layer or transport layer over which application data can flow [RFC4301] [RFC5246]. These mechanisms, however, cannot provide end-to-end security in some cases. For example, in protocols with application-layer intermediaries, channel-based security protocols would protect messages from attackers between intermediaries, but not from the intermediaries themselves. These cases require object-based security technologies, which embed application data within a secure object that can be safely handled by untrusted entities.",
      "ja": "インターネットアプリケーションは、インターネットの階層化アーキテクチャに載ると、すべての層でのセキュリティ・メカニズムを活用します。多くのアプリケーションは、アプリケーションデータが[RFC4301] [RFC5246]を流れることができる上、IPレイヤまたはトランスポート層で保護されたチャネルを作成し、このようなIPsecとトランスポート層セキュリティ（TLS）などのチャネルベースのセキュリティ技術、に主に依存しています。これらのメカニズムは、しかし、いくつかのケースでは、エンドツーエンドのセキュリティを提供することができません。例えば、アプリケーション層の仲介とプロトコルで、チャネルベースのセキュリティプロトコルはなく、仲介業者自身から、仲介間の攻撃者からのメッセージを保護します。これらの例は、安全に信頼できないエンティティが扱うことができ、安全なオブジェクト内のアプリケーション・データを埋め込みオブジェクトベースのセキュリティ技術を、必要としています。"
    },
    {
      "indent": 3,
      "text": "The most well-known example of such a protocol today is the use of Secure/Multipurpose Internet Mail Extensions (S/MIME) protections within the email system [RFC5751] [RFC5322]. An email message typically passes through a series of intermediate Mail Transfer Agents (MTAs) en route to its destination. While these MTAs often apply channel-based security protections to their interactions (e.g., STARTTLS [RFC3207]), these protections do not prevent the MTAs from interfering with the message. In order to provide end-to-end security protections in the presence of untrusted MTAs, mail users can use S/MIME to embed message bodies in a secure object format that can provide confidentiality, integrity, and data origin authentication.",
      "ja": "そのようなプロトコルの最もよく知られた例は、今日では、電子メールシステム[RFC5751]、[RFC5322]内の多目的インターネットメール拡張（S / MIME）/セキュアな保護の使用です。電子メールメッセージは、典型的には、その目的地への途中の中間メール転送エージェント（MTA）のシリーズを通過します。これらのMTAは、しばしば、それらの相互作用（例えば、STARTTLS [RFC3207]）にチャネルベースのセキュリティ保護を適用しながら、これらの保護は、メッセージに干渉のMTAを妨げません。信頼されていないのMTAの存在下でのエンドツーエンドのセキュリティ保護を提供するために、メールユーザーは、機密性、完全性、およびデータ発信元認証を提供することができ、安全なオブジェクト形式でメッセージ本文を埋め込むためにS / MIMEを使用することができます。"
    },
    {
      "indent": 3,
      "text": "S/MIME is based on the Cryptographic Message Syntax (CMS) for secure objects [RFC5652]. CMS is defined using Abstract Syntax Notation 1 (ASN.1) and typically encoded using the ASN.1 Distinguished Encoding Rules (DER), which define a binary encoding of the protected message and associated parameters [ITU.X690.2002]. In recent years, usage of ASN.1 has decreased (along with other binary encodings for general objects), while more applications have come to rely on text-based formats such as the Extensible Markup Language (XML) [W3C.REC-xml] or the JavaScript Object Notation (JSON) [RFC7159].",
      "ja": "S / MIMEは、安全なオブジェクト[RFC5652]のための暗号メッセージ構文（CMS）に基づいています。 CMSは、抽象構文記法1（ASN.1）を使用して定義され、典型的には保護されたメッセージと関連するパラメータ[ITU.X690.2002]のバイナリエンコーディングを定義するASN.1識別符号化規則（DER）を用いて符号化されます。より多くのアプリケーションは、拡張マークアップ言語（XML）[W3C.REC-XML]などのテキストベースのフォーマットに頼るようになっているが、近年では、ASN.1の使用量は、（一般的な目的のために他のバイナリエンコーディングと一緒に）減少していますまたはJavaScriptオブジェクト表記（JSON）[RFC7159]。"
    },
    {
      "indent": 3,
      "text": "Many current applications thus have much more robust support for processing objects in these text-based formats than ASN.1 objects; indeed, many lack the ability to process ASN.1 objects at all. To simplify the addition of object-based security features to these applications, the IETF JSON Object Signing and Encryption (JOSE) working group has been chartered to develop a secure object format based on JSON. While the basic requirements for this object format are straightforward -- namely, confidentiality and integrity mechanisms encoded in JSON -- discussions in the working group indicated that different applications hoping to use the formats defined by JOSE have different requirements. This document summarizes the use cases for JOSE envisioned by those potential applications and the resulting requirements for security mechanisms and object encodings.",
      "ja": "現在の多くのアプリケーションでは、このようにASN.1オブジェクトよりもこれらのテキストベースのフォーマットでオブジェクトを処理するためのはるかに強力なサポートを備えています。確かに、多くは全くASN.1オブジェクトを処理する能力を欠いています。これらのアプリケーションにオブジェクトベースのセキュリティ機能の追加を簡素化するために、IETF JSONオブジェクトの署名と暗号化（JOSE）ワーキンググループはJSONに基づくセキュアオブジェクトフォーマットを開発するためにチャーターされました。このオブジェクトフォーマットのための基本的な要件は単純ですが - すなわち、JSONでエンコードされた機密性と整合性のメカニズム - ワーキンググループでの議論は、JOSEによって定義されたフォーマットを使用することを望んで異なるアプリケーションは異なる要件を持っていることが示されました。この文書では、これらの潜在的なアプリケーションとセキュリティメカニズムとオブジェクトのエンコーディングの結果の要件によって想定されるJOSEためのユースケースをまとめたもの。"
    },
    {
      "indent": 3,
      "text": "Some systems that use XML have specified the use of XML-based security mechanisms for object security, namely XML Digital Signatures and XML Encryption [W3C.xmldsig-core] [W3C.xmlenc-core]. These mechanisms are used by several security token systems (e.g., Security Assertion Markup Language (SAML) [OASIS.saml-core-2.0-os], Web Services Federation [WS-Federation]), and the Common Alerting Protocol (CAP) emergency alerting format [CAP]. In practice, however, XML-based secure object formats introduce similar levels of complexity to ASN.1 (e.g., due to the need for XML canonicalization), so developers that lack the tools or motivation to handle ASN.1 aren't likely to use XML security either. This situation motivates the creation of a JSON-based secure object format that is simple enough to implement and deploy that it can be easily adopted by developers with minimal effort and tools.",
      "ja": "XMLを使用するいくつかのシステムは、オブジェクトのセキュリティ、すなわち、XMLデジタル署名とXML暗号化[W3C.xmldsigコア] [W3C.xmlencコア]のためのXMLベースのセキュリティメカニズムの使用を指定しています。これらのメカニズムは、いくつかのセキュリティトークンシステムで使用されている（例えば、のSAML（Security Assertion Markup Language）[OASIS.samlコア-2.0-OS]、Webサービス連盟[WS-Federationの]）、および共通アラート・プロトコル（CAP）緊急警告フォーマット[CAP]。 ASN.1を処理するためのツールや意欲に欠け、開発者がしにくいので、しかし実際には、XMLベースのセキュアなオブジェクトフォーマットは、（XMLの標準化の必要性に起因する例えば、）ASN.1に複雑同様のレベルを導入しますいずれかのXMLセキュリティを使用しています。この状況は、実装し、それが簡単に最小限の労力やツールを開発者によって採用されることを展開するために十分に簡単ですJSONベースのセキュアなオブジェクトフォーマットの作成を動機付けます。"
    },
    {
      "indent": 0,
      "text": "2. Definitions",
      "section_title": true,
      "ja": "2.定義"
    },
    {
      "indent": 3,
      "text": "This document makes extensive use of standard security terminology [RFC4949]. In addition, because the use cases for JOSE and CMS are similar, we will sometimes make analogies to some CMS concepts [RFC5652].",
      "ja": "この文書では、標準的なセキュリティ用語[RFC4949]を多用します。 JOSEとCMSのためのユースケースが類似しているので、また、私たちは時々、いくつかのCMSの概念[RFC5652]へのアナロジーを行います。"
    },
    {
      "indent": 3,
      "text": "The JOSE working group charter calls for the group to define three basic JSON object formats:",
      "ja": "JOSEワーキンググループ憲章は、3つの基本的なJSONオブジェクトの形式を定義するためのグループのために呼び出します。"
    },
    {
      "indent": 3,
      "text": "1. Integrity-protected object format",
      "section_title": true,
      "ja": "1.インテグリティ保護オブジェクト・フォーマット"
    },
    {
      "indent": 3,
      "text": "2. Confidentiality-protected object format",
      "section_title": true,
      "ja": "前記機密保護オブジェクト・フォーマット"
    },
    {
      "indent": 3,
      "text": "3. A format for expressing keys",
      "section_title": true,
      "ja": "3.キーを発現するためのフォーマット"
    },
    {
      "indent": 3,
      "text": "In this document, we will refer to these as the \"signed object format\", the \"encrypted object format\", and the \"key format\", respectively. The JOSE working group items intended to describe these formats are JSON Web Signature [JWS], JSON Web Encryption [JWE], and JSON Web Key [JWK], respectively. Algorithms and algorithm identifiers used by JWS, JWE, and JWK are defined in JSON Web Algorithms [JWA].",
      "ja": "この文書では、我々はそれぞれ、「署名オブジェクトフォーマット」、「暗号化されたオブジェクトフォーマット」、および「キーフォーマット」としてこれらを参照してくださいます。これらのフォーマットを説明することを意図JOSEワーキンググループの項目は、それぞれ、JSONウェブ署名[JWS]、JSONウェブ暗号[JWE]、およびJSONウェブキー[JWK]です。 JWS、JWE、及びJWKによって使用されるアルゴリズムとアルゴリズム識別子はJSONウェブアルゴリズム[JWA]で定義されています。"
    },
    {
      "indent": 3,
      "text": "In general, where there is no need to distinguish between asymmetric and symmetric operations, we will use the terms \"signing\", \"signature\", etc., to denote both true digital signatures involving asymmetric cryptography as well as Message Authentication Codes (MACs) using symmetric keys.",
      "ja": "非対称および対称操作を区別する必要がない場合、一般的に、我々は、非対称暗号、並びにメッセージ認証コードを含む両方の真のデジタル署名を表すために用語「署名」、「署名」など、使用する（MACS）対称鍵を使用して。"
    },
    {
      "indent": 3,
      "text": "In the lifespan of a secure object, there are two basic roles, an entity that creates the object (e.g., encrypting or signing a payload) and an entity that uses the object (decrypting and verifying). We will refer to these roles as \"sender\" and \"recipient\", respectively. Note that while some requirements and use cases may refer to these as single entities, each object may have multiple entities in each role. For example, a message may be signed by multiple senders or decrypted by multiple recipients.",
      "ja": "安全なオブジェクトの寿命では、二つの基本的な役割、オブジェクト（例えば、ペイロードの暗号化または署名）および（復号化と検証）オブジェクトを使用してエンティティを作成するエンティティが存在します。私たちは、それぞれ、「差出人」と「受け手」として、これらの役割を指します。いくつかの要件とユースケースは、単一のエンティティとしてこれらを参照してもよい一方で、各オブジェクトは、それぞれの役割に複数のエンティティを持っていることに注意してください。例えば、メッセージは、複数の送信者によって署名されてもよいし、複数の受信者によって解読します。"
    },
    {
      "indent": 0,
      "text": "3. Basic Requirements",
      "section_title": true,
      "ja": "3.基本的な要件"
    },
    {
      "indent": 3,
      "text": "For the encrypted and signed object formats, the necessary protections will be created using appropriate cryptographic mechanisms: symmetric or asymmetric encryption for confidentiality and MACs or digital signatures for integrity protection. In both cases, it is necessary for the JOSE format to support both symmetric and asymmetric operations.",
      "ja": "機密性と完全性保護のためのMACまたはデジタル署名のための対称または非対称暗号化：暗号化され署名されたオブジェクトフォーマットのために、必要な保護は、適切な暗号化メカニズムを使用して作成されます。 JOSE形式は対称および非対称の両方の動作をサポートするための両方の場合において、それが必要です。"
    },
    {
      "indent": 3,
      "text": "o The JOSE encrypted object format must support object encryption in the case where the sender and receiver share a symmetric key.",
      "ja": "O JOSE暗号化されたオブジェクトの形式は、送信者と受信者は、対称鍵を共有する場合には、オブジェクトの暗号化をサポートしている必要があります。"
    },
    {
      "indent": 3,
      "text": "o The JOSE encrypted object format must support object encryption in the case where the sender has only a public key for the receiver.",
      "ja": "O JOSE暗号化されたオブジェクトのフォーマットは、送信者が受信者のための唯一の公開鍵を持っている場合には、オブジェクトの暗号化をサポートしている必要があります。"
    },
    {
      "indent": 3,
      "text": "o The JOSE signed object format must support integrity protection using MACs, for the case where the sender and receiver share only a symmetric key.",
      "ja": "O JOSE署名されたオブジェクトのフォーマットは、ケース送信側と受信側のシェアのみ対称鍵のために、MACを使用して完全性保護をサポートしなければなりません。"
    },
    {
      "indent": 3,
      "text": "o The JOSE signed object format must support integrity protection using digital signatures, for the case where the receiver has only a public key for the sender.",
      "ja": "O JOSE署名されたオブジェクトの形式は、受信者が送信者のための唯一の公開鍵を有する場合の、デジタル署名を使用して完全性保護をサポートしなければなりません。"
    },
    {
      "indent": 3,
      "text": "In some applications, the key used to process a JOSE object is indicated by application context, instead of directly in the JOSE object. However, in order to avoid confusion, endpoints that lack the necessary context need to be able to recognize this and fail cleanly. Other than keys, JOSE objects do not support pre-negotiation; all cryptographic parameters must be expressed directly in the JOSE object.",
      "ja": "いくつかの用途では、JOSEオブジェクトを処理するために使用されるキーは、JOSEオブジェクトに代わり、直接の、アプリケーションのコンテキストで示されています。しかし、混乱を避けるために、必要なコンテキストを持たないエンドポイントはこれを認識し、きれいに失敗することができるようにする必要があります。キー以外に、JOSEオブジェクトは、事前折衝をサポートしていません。すべての暗号化パラメータはJOSEオブジェクト内で直接発現されなければなりません。"
    },
    {
      "indent": 3,
      "text": "o The JOSE signed and encrypted object formats must define the process by which an implementation recognizes whether it has the key required to process a given object, whether the key is specified by the object or by some out-of-band mechanism.",
      "ja": "O JOSEは署名され、暗号化されたオブジェクトのフォーマットは実装がキーオブジェクトまたはいくつかのアウトオブバンド機構によって指定されているかどうか、それは、指定されたオブジェクトを処理するために必要なキーを持っているかどうかを認識するプロセスを定義する必要があります。"
    },
    {
      "indent": 3,
      "text": "o Each algorithm used for JOSE must define which parameters are required to be present in a JOSE object using that algorithm.",
      "ja": "O JOSEために使用される各アルゴリズムは、そのアルゴリズムを使用してJOSE物中に存在することが必要とされるパラメータを定義しなければなりません。"
    },
    {
      "indent": 3,
      "text": "In cases where two entities are going to be exchanging several JOSE objects, it might be helpful to pre-negotiate some parameters so that they do not have to be signaled in every JOSE object. However, so as not to confuse endpoints that do not support pre-negotiation, it is useful to signal when pre-negotiated parameters are in use in those cases.",
      "ja": "2つのエンティティが、いくつかのJOSEオブジェクトを交換しようとしているケースでは、彼らがすべてのJOSEオブジェクトに通知する必要がないように、いくつかのパラメータを事前に交渉すると便利かもしれません。事前折衝をサポートしていないエンドポイントを混同しないようにしかし、事前に交渉さのパラメータは、これらの例で使用されているときに信号するのに便利です。"
    },
    {
      "indent": 3,
      "text": "o It should be possible to extend the base JOSE signed and encrypted object formats to indicate that pre-negotiated parameters are to be used to process the object. This extension should also provide a means of indicating which parameters are to be used.",
      "ja": "O事前交渉パラメータは、オブジェクトを処理するために使用されていることを示すためにJOSE署名ベースと暗号化されたオブジェクトのフォーマットを拡張することが可能であるべきです。この拡張はまた、パラメータが使用されるかを示す手段を提供すべきです。"
    },
    {
      "indent": 3,
      "text": "The purpose of the key format is to provide the recipient with sufficient information to use the encoded key to process cryptographic messages. Thus, it is sometimes necessary to include additional parameters along with the bare key.",
      "ja": "キーフォーマットの目的は、暗号化メッセージを処理するために符号化された鍵を使用するために十分な情報を受信者に提供することです。したがって、裸のキーと一緒に追加のパラメータを含める必要がある場合があります。"
    },
    {
      "indent": 3,
      "text": "o The JOSE key format must enable inclusion of all algorithm parameters necessary to use the encoded key, including an identifier for the algorithm with which the key is used as well as any additional parameters required by the algorithm (e.g., elliptic curve parameters).",
      "ja": "O JOSEキーフォーマットは、キーはアルゴリズム（例えば、楕円曲線パラメータ）によって要求される追加のパラメータと同様に使用されるアルゴリズムの識別子を含む、符号化された鍵を使用することが必要なすべてのアルゴリズムパラメータを含めることを可能にしなければなりません。"
    },
    {
      "indent": 0,
      "text": "4. Requirements on Application Protocols",
      "section_title": true,
      "ja": "アプリケーションプロトコル上の4要件"
    },
    {
      "indent": 3,
      "text": "The JOSE secure object formats describe how cryptographic processing is done on secured content, ensuring that the recipient of an object is able to properly decrypt an encrypted object or verify a signature. In order to make use of JOSE, however, applications will need to specify several aspects of how JOSE is to be used:",
      "ja": "JOSE安全なオブジェクトフォーマットは、オブジェクトの受信者が正しく暗号化されたオブジェクトを復号化または署名を検証することが可能であることを確認して、保護されたコンテンツにどのように行われるか暗号処理について説明します。 JOSEを利用するために、しかし、アプリケーションはJOSEを使用する方法のいくつかの側面を指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "o What application content is to be protected",
      "ja": "Oどのようなアプリケーション、コンテンツ、保護されるべきです"
    },
    {
      "indent": 3,
      "text": "o Which cryptographic algorithms are to be used",
      "ja": "暗号化アルゴリズムであるOが使用されます"
    },
    {
      "indent": 3,
      "text": "o How application protocol entities establish keys",
      "ja": "Oアプリケーションプロトコルエンティティが鍵を確立する方法"
    },
    {
      "indent": 3,
      "text": "o Whether keys are to be explicitly indicated in JOSE objects or associated by application context",
      "ja": "Oキーが明示的JOSEオブジェクトで示さまたはアプリケーション・コンテキストによって関連するかどうか"
    },
    {
      "indent": 3,
      "text": "o Which serialization(s) of JOSE objects are to be used",
      "ja": "O JOSEオブジェクトのうちどれシリアライゼーション（S）使用されます"
    },
    {
      "indent": 0,
      "text": "5. Use Cases",
      "section_title": true,
      "ja": "5.ユースケース"
    },
    {
      "indent": 3,
      "text": "Several IETF working groups developing application-layer protocols have expressed a desire to use the JOSE data formats in their designs for end-to-end security features. In this section, we summarize the use cases proposed by these groups and discuss the requirements that they imply for the JOSE object formats.",
      "ja": "アプリケーション層のプロトコルを開発するいくつかのIETFワーキンググループは、エンドツーエンドのセキュリティ機能のために自分たちのデザインでJOSEデータ・フォーマットを使用したいと表明しています。このセクションでは、これらのグループによって提案されたユースケースを要約し、それらがJOSEオブジェクト形式の意味するものでは要件を議論します。"
    },
    {
      "indent": 0,
      "text": "5.1. Security Tokens",
      "section_title": true,
      "ja": "5.1。セキュリティトークン"
    },
    {
      "indent": 3,
      "text": "Security tokens are a common use case for object-based security, for example, SAML assertions [OASIS.saml-core-2.0-os]. Security tokens are used to convey information about a subject entity (\"claims\" or \"assertions\") from an issuer to a recipient. The security features of a token format enable the recipient to verify that the claims came from the issuer and, if the object is confidentiality protected, that they were not visible to other parties.",
      "ja": "セキュリティトークンは、例えば、SAMLアサーション[OASIS.samlコア-2.0-OS]オブジェクトベースのセキュリティのための一般的な使用例です。セキュリティトークンを受信者に発行者から対象エンティティ（「クレーム」または「アサーション」）に関する情報を伝えるために使用されます。トークン形式のセキュリティ機能は、オブジェクトが、彼らが他の当事者には見えなかったこと、機密保護されている場合の請求は、発行者から来ていることを確認するために、受信者を有効にします。"
    },
    {
      "indent": 3,
      "text": "Security tokens are used in federation protocols such as SAML 2.0 [OASIS.saml-core-2.0-os], WS-Federation [WS-Federation], Mozilla Persona [Persona], and OpenID Connect [OpenID.Core], as well as in resource authorization protocols such as OAuth 2.0 [RFC6749], including for OAuth bearer tokens [RFC6750]. In some cases, security tokens are used for client authentication and for access control [JWT-BEARER] [SAML2].",
      "ja": "セキュリティトークンは、ならびにそのようなSAML 2.0 [OASIS.samlコア-2.0-OS]、WS-Federationの[WS-Federationの]、Mozillaのペルソナ[ペルソナ]、およびOpenIDの接続[OpenID.Core]、としてフェデレーションプロトコルで使用されていますそのようなOAuthのベアラトークン[RFC6750]を含めOAuth 2.0の[RFC6749]などのリソース認証プロトコルです。いくつかのケースでは、セキュリティトークンは、クライアント認証のためにと[JWT-BEARER] [SAML2]アクセス制御に使用されています。"
    },
    {
      "indent": 3,
      "text": "JSON Web Token [JWT] is a security token format based on JSON and JOSE. It is used with Mozilla Persona, OpenID Connect, and OAuth. Because JWTs are often used in contexts with limited space (e.g., HTTP query parameters), it is a core requirement for JWTs, and thus JOSE, to have a compact, URL-safe representation.",
      "ja": "JSONウェブトークン[JWT]はJSONとJOSEに基づいてセキュリティトークン形式です。これは、Mozillaのペルソナ、OpenIDの接続、およびOAuthのに使用されています。 JWTsはしばしば限られたスペースでのコンテキスト（例えば、HTTPクエリパラメータ）で使用されているので、コンパクトで、URLセーフ表現を有すること、JWTsのコア要件であるので、JOSE。"
    },
    {
      "indent": 0,
      "text": "5.2. OAuth",
      "section_title": true,
      "ja": "5.2。 OAuthの"
    },
    {
      "indent": 3,
      "text": "The OAuth protocol defines a mechanism for distributing and using authorization tokens using HTTP [RFC6749]. A client that wishes to access a protected resource requests authorization from the resource owner. If the resource owner allows this access, he directs an authorization server to issue an access token to the client. When the client wishes to access the protected resource, he presents the token to the relevant resource server, which verifies the validity of the token before providing access to the protected resource.",
      "ja": "OAuthプロトコルは、配布と[RFC6749]を使用して、HTTP許可トークンを使用するための機構を定義します。保護されたリソースにアクセスしたいクライアントは、リソースの所有者から承諾を要求します。リソースの所有者がこのアクセスを許可している場合、彼はクライアントにアクセストークンを発行する認証サーバを指示します。クライアントが保護されたリソースにアクセスしたいとき、彼は保護されたリソースへのアクセスを提供する前に、トークンの有効性を検証し、関連するリソースサーバにトークンを提示します。"
    },
    {
      "indent": 17,
      "text": "+---------------+          +---------------+\n|               |          |               |\n|   Resource    |<........>| Authorization |\n|    Server     |          |     Server    |\n|               |          |               |\n+---------------+          +---------------+\n             ^                |\n             |                |\n             |                |\n             |                |\n             |                |\n+------------|--+          +--|------------+\n|            +----------------+            |\n|               |          |   Resource    |\n|     Client    |          |     Owner     |\n|               |          |               |\n+---------------+          +---------------+",
      "raw": true
    },
    {
      "indent": 24,
      "text": "Figure 1: The OAuth Process",
      "ja": "図1：OAuthのプロセス"
    },
    {
      "indent": 3,
      "text": "In effect, this process moves the token from the authorization server (as a sender of the object) to the resource server (recipient) via the client as well as the resource owner (the latter because of the HTTP mechanics underlying the protocol). As with email, we have a case where an application object is transported via untrusted intermediaries.",
      "ja": "実際には、このプロセスは、クライアントを介して、リソースサーバ（受信者）ならびにリソース所有者（なぜならプロトコルの基礎となるHTTP力学の後者）に（オブジェクトの送信者など）認証サーバからトークンを移動させます。電子メールと同じように、私たちは、アプリケーションオブジェクトが信頼できない仲介者を経由して輸送される場合があります。"
    },
    {
      "indent": 3,
      "text": "This application has two essential security requirements: integrity and data origin authentication. Integrity protection is required so that the resource owner and the client cannot modify the permission encoded in the token. Although the resource owner is ultimately the entity that grants authorization, it is not trusted to modify the authorization token, since this could, for example, grant access to resources not owned by the resource owner.",
      "ja": "整合性とデータ発信元認証：このアプリケーションは、2つの重要なセキュリティ要件があります。リソースの所有者とクライアントがトークンでエンコードされたアクセス権を変更できないように、完全性保護が必要とされます。リソースの所有者が最終的に許可を付与するエンティティですが、これは、例えば、リソースの所有者が所有していないリソースへのアクセスを許可する可能性があるので、認証トークンを変更するために信頼されていません。"
    },
    {
      "indent": 3,
      "text": "Data origin authentication is required so that the resource server can verify that the token was issued by a trusted authorization server.",
      "ja": "リソースサーバーは、トークンは、信頼できる認証サーバによって発行されたことを確認できるように、データ発信元認証が必要です。"
    },
    {
      "indent": 3,
      "text": "Confidentiality protection may also be needed if the authorization server is concerned about the visibility of permissions information to the resource owner or client. For example, permissions related to social networking might be considered private information. Note, however, that OAuth already requires that the underlying HTTP transactions be protected by TLS, so tokens are already confidentiality protected from entities other than the resource owner and client.",
      "ja": "認証サーバはリソースの所有者やクライアントへのアクセス権情報の可視性を懸念している場合には機密性の保護が必要になる場合もあります。例えば、ソーシャルネットワーキングに関連する権限は、個人情報と考えられるかもしれません。トークンは既にリソースの所有者とクライアント以外のエンティティから保護機密性になるようにOAuthはすでに、根本的なHTTPトランザクションがTLSによって保護されることが必要であること、しかし、注意してください。"
    },
    {
      "indent": 3,
      "text": "The confidentiality and integrity needs are met by the basic requirements for signed and encrypted object formats, whether the signing and encryption are provided using asymmetric or symmetric cryptography. The choice of which mechanism is applied will depend on the relationship between the two servers, namely whether they share a symmetric key or only public keys.",
      "ja": "署名と暗号化が非対称または対称暗号化を使用して提供されているかどうかを機密性と整合性のニーズは、署名および暗号化されたオブジェクトフォーマットのための基本的な要件によって満たされています。メカニズムが適用されるの選択は、彼らが対称鍵または公開鍵だけを共有する、すなわちかどうか、2つのサーバ間の関係に依存します。"
    },
    {
      "indent": 3,
      "text": "Authentication requirements will also depend on deployment characteristics. Where there is a relatively strong binding between the resource server and the authorization server, it may suffice for the authorization server issuing a token to be identified by the key used to sign the token. This requires that the protocol carry either the public key of the authorization server or an identifier for the public or symmetric key. In OAuth, the \"client_id\" parameter (external to the token) identifies the key to be used.",
      "ja": "認証要件も展開特性に依存します。リソースサーバと認証サーバとの間に比較的強い結合がある場合、それはトークンに署名するために使用されるキーで識別されるトークンを発行する認証サーバのために十分です。これは、プロトコルが認証サーバの公開鍵または公開または対称鍵の識別子のいずれかを実行する必要があります。 OAuthのでは、「CLIENT_ID」パラメータ（トークンの外部）が使用されるキーを識別する。"
    },
    {
      "indent": 3,
      "text": "There may also be more advanced cases where the authorization server's key is not known in advance to the resource server. This may happen, for instance, if an entity instantiated a collection of authorization servers (say for load balancing), each of which has an independent key pair. In these cases, it may be necessary to also include a certificate or certificate chain for the authorization server, so that the resource server can verify that the authorization server is an entity that it trusts.",
      "ja": "また、認証サーバのキーがリソースサーバに事前に知られていない、より高度な例があるかもしれません。エンティティは、独立した鍵のペアを持っているそれぞれの認証サーバ（負荷分散のために言う）のコレクションをインスタンス化する場合、これは、例えば、発生する可能性があります。これらの場合には、リソースサーバが認証サーバは、それが信頼するエンティティであることを確認することができるように、また、認証サーバの証明書または証明書チェーンを含むことが必要であり得ます。"
    },
    {
      "indent": 3,
      "text": "The HTTP transport for OAuth imposes a particular constraint on the encoding. In the OAuth protocol, tokens frequently need to be passed as query parameters in HTTP URIs [RFC2616] after having been base64url encoded [RFC4648]. While there is no specified limit on the length of URIs (and thus of query parameters), in practice, URIs of more than 2,048 characters are rejected by some user agents. So this use case requires that JOSE objects be sufficiently small, even after being signed and possibly encrypted.",
      "ja": "OAuthのた​​めのHTTPトランスポートは、符号化に特定の制約を課します。 OAuthプロトコルでは、頻繁に[RFC4648] base64url符号化された後に[RFC2616] HTTP URIは、クエリパラメータとして渡される必要トークン。 （クエリパラメータをこうしてと）URIの長さに指定された制限はないが、実際には、以上2,048文字のURIは、いくつかのユーザエージェントによって拒否されています。したがって、このユースケースは、JOSEオブジェクトも署名し、おそらく暗号化された後、十分に小さいことが必要です。"
    },
    {
      "indent": 0,
      "text": "5.3. OpenID Connect",
      "section_title": true,
      "ja": "5.3。 OpenIDの接続"
    },
    {
      "indent": 3,
      "text": "The OpenID Connect protocol [OpenID.Core] is a simple, REST/JSON-based identity federation protocol layered on OAuth 2.0. It uses the JWT and JOSE formats both to represent security tokens and to provide security for other protocol messages (performing signing and optionally encryption). OpenID Connect negotiates the algorithms to be used and distributes information about the keys to be used using protocol elements that are not part of the JWT and JOSE header parameters.",
      "ja": "OpenIDの接続プロトコル[OpenID.Core] OAuth 2.0の上に積層簡単、REST / JSONベースのIDフェデレーションプロトコルです。これはJWTとJOSEは、セキュリティトークンを表現し、他のプロトコルメッセージ（実行署名および任意に暗号化）のためのセキュリティを提供することの両方をフォーマットする使用します。 OpenIDの接続は、使用するアルゴリズムをネゴシエートし、JWTとJOSEヘッダパラメータの一部ではないプロトコル要素を使用して、使用するキーに関する情報を配信します。"
    },
    {
      "indent": 3,
      "text": "In the OpenID Connect context, it is possible for the recipient of a JWT to accept it without integrity protection in the JWT itself. In such cases, the recipient chooses to rely on transport security rather than object security. For example, if the payload is delivered over a TLS-protected channel, the recipient may regard the protections provided by TLS as sufficient, so JOSE protection would not be required.",
      "ja": "OpenIDの接続コンテキストでは、JWTの受信者がJWT自体が完全性保護なしで、それを受け入れることが可能です。このような場合には、受信者は、トランスポート・セキュリティではなく、オブジェクトのセキュリティに依存することを選択します。ペイロードはTLSで保護されたチャネルを介して配信される場合JOSE保護が必要とされないように、例えば、受信者は、十分ようTLSによって提供される保護を考えることができます。"
    },
    {
      "indent": 3,
      "text": "However, even in this case, it is desirable to associate some metadata with the JWT payload (claim set), such as the content type, or other application-specific metadata. In a signed or encrypted object, these metadata values could be carried in a header with other metadata required for signing or encryption. It would thus simplify the design of OpenID Connect if there could be a JOSE object format that does not apply cryptographic protections to its payload, but allows a header to be attached to the payload in the same way as a signed or encrypted object.",
      "ja": "しかし、この場合であっても、そのようなコンテンツタイプ、または他のアプリケーション固有のメタデータとして、JWTペイロード（クレームセット）を用いて、いくつかのメタデータを関連付けることが望ましいです。署名または暗号化されたオブジェクトでは、これらのメタデータの値は、署名または暗号化するために必要な他のメタデータとヘッダで搬送することができます。従って、そのペイロードに暗号保護を適用しないJOSEオブジェクトフォーマットが存在し得る場合のOpenID接続の設計を簡素化するが、ヘッダは、署名または暗号化されたオブジェクトと同じ方法でペイロードに取り付けることを可能にするであろう。"
    },
    {
      "indent": 0,
      "text": "5.4. XMPP",
      "section_title": true,
      "ja": "5.4。 XMPP"
    },
    {
      "indent": 3,
      "text": "The Extensible Messaging and Presence Protocol (XMPP) routes messages from one end client to another by way of XMPP servers [RFC6120]. There are typically two servers involved in delivering any given message: The first client (Alice) sends a message for another client (Bob) to her server (A). Server A uses Bob's identity and the DNS to locate the server for Bob's domain (B) and then delivers the message to that server. Server B then routes the message to Bob.",
      "ja": "XMPPサーバ[RFC6120]を介して別のエンドクライアントから拡張メッセージングおよびプレゼンスプロトコル（XMPP）ルーティングメッセージ。任意のメッセージを配信に関与する2台のサーバーは、一般的にあります。最初のクライアント（アリス）は、彼女のサーバー（A）に別のクライアント（ボブ）のためのメッセージを送信します。サーバーAは、ボブのドメイン（B）用のサーバーを見つけるために、ボブのアイデンティティとDNSを使用して、そのサーバーにメッセージを配信します。サーバBは、その後、ルートボブへメッセージ。"
    },
    {
      "indent": 12,
      "text": "+-------+   +----------+   +----------+   +-----+\n| Alice |-->| Server A |-->| Server B |-->| Bob |\n+-------+   +----------+   +----------+   +-----+",
      "raw": true
    },
    {
      "indent": 19,
      "text": "Figure 2: Delivering an XMPP Message",
      "ja": "図2：XMPPのメッセージを配信"
    },
    {
      "indent": 3,
      "text": "The untrusted-intermediary problems are especially acute for XMPP because in many current deployments, the holder of an XMPP domain outsources the operation of the domain's servers to a different entity. In this environment, there is a clear risk of exposing the domain holder's private information to the domain operator. XMPP already has a defined mechanism for end-to-end security using S/MIME, but it has failed to gain widespread deployment [RFC3923], in part because of key management challenges and in part because of the difficulty of processing S/MIME objects.",
      "ja": "現在の多くの展開で、XMPPドメインの所有者が異なるエンティティにドメインのサーバーの操作を委託しているため、信頼できない、中間の問題はXMPPのために特に深刻です。この環境では、ドメインのオペレータにドメイン保有者の個人情報をさらすの明確なリスクがあります。 XMPPはすでにS / MIMEを使用したエンドツーエンドのセキュリティのために定義されたメカニズムを持っていますが、それはので、S / MIMEオブジェクトを処理することの難しさの一部であるため、キー管理の問題の一部は、広範囲の展開[RFC3923]を得るために失敗しました。"
    },
    {
      "indent": 3,
      "text": "The XMPP working group is in the process of developing a new end-to-end encryption system with an encoding based on JOSE and a clearer key management system [XMPP-E2E]. The process of sending an encrypted message in this system involves two steps: First, the sender generates a symmetric Session Master Key (SMK), encrypts the message content (including a per-message Content Master Key), and sends the encrypted message to the desired set of recipients.",
      "ja": "XMPPワーキンググループはJOSEに基づいて符号化及び明確鍵管理システム[XMPP-E2E]で新しいエンドツーエンド暗号化システムを開発中です。このシステムで暗号化されたメッセージを送信するプロセスは、2つの手順があります。まず、送信者は対称セッションマスターキー（SMK）を生成し、（メッセージごとのコンテンツマスターキーを含む）メッセージの内容を暗号化し、に暗号化されたメッセージを送ります受信者の所望のセット。"
    },
    {
      "indent": 3,
      "text": "Second, each recipient \"dials back\" to the sender, providing his public key. The sender then responds with the relevant SMK, wrapped with the recipient's public key.",
      "ja": "第二に、各受信者は、自分の公開鍵を提供し、送信者に「バックダイヤル」。送信者は、受信者の公開鍵で包まれ、関連するSMKで応答します。"
    },
    {
      "indent": 12,
      "text": "+-------+   +----------+   +----------+   +-----+\n| Alice |<->| Server A |<->| Server B |<->| Bob |\n+-------+   +----------+   +----------+   +-----+\n    |             |              |           |\n    |------------Encrypted message---------->|\n    |             |              |           |\n    |<---------------Public key--------------|\n    |             |              |           |\n    |---------------Wrapped SMK------------->|\n    |             |              |           |",
      "raw": true
    },
    {
      "indent": 16,
      "text": "Figure 3: Delivering a Secure XMPP Message",
      "ja": "図3：セキュアXMPPメッセージを配信"
    },
    {
      "indent": 3,
      "text": "The main thing that this system requires from the JOSE formats is confidentiality protection via content encryption, plus an integrity check via a MAC derived from the same symmetric key. The separation of the key exchange from the transmission of the encrypted content, however, requires that the JOSE encrypted object format allow wrapped symmetric keys to be carried separately from the encrypted payload. In addition, the encrypted object will need to have a tag for the key that was used to encrypt the content, so that the recipient (Bob) can present the tag to the sender (Alice) when requesting the wrapped key.",
      "ja": "このシステムはJOSE形式から必要とすることに主なものは、コンテンツの暗号化を経由して機密性の保護に加え、同じ対称鍵から導出MACを経由して整合性チェックです。暗号化されたコンテンツを送信してから鍵交換の分離は、しかしながら、JOSE暗号化されたオブジェクトのフォーマットは、ラップされた対称鍵は、暗号化されたペイロードは別に実施することを可能にすることを必要とします。また、暗号化されたオブジェクトは、ラップされた鍵を要求するとき、受信者（ボブ）は、送信者（アリス）にタグを提示することができるように、コンテンツを暗号化するために使用されたキーのタグを持っている必要があります。"
    },
    {
      "indent": 3,
      "text": "Another important feature of XMPP is that it allows for the simultaneous delivery of a message to multiple recipients. In the diagrams above, Server A could deliver the message not only to Server B (for Bob) but also to Servers C, D, E, etc., for other users. In such cases, to avoid the multiple \"dial back\" transactions implied by the above mechanism, XMPP systems will likely reuse a given SMK for multiple individual messages, refreshing the SMK on a periodic and/or event-driven basis (e.g., when the recipient's presence changes). They might also cache public keys for end recipients, so that wrapped keys can be sent along with content on future messages. This implies that the JOSE encrypted object format must support the provision of multiple versions of the same wrapped SMK (much as a CMS EnvelopedData structure can include multiple RecipientInfo structures).",
      "ja": "XMPPのもう一つの重要な特徴は、複数の受信者へのメッセージの同時配信を可能にすることです。上記の図では、サーバーAは、他のユーザのために、サーバBへ（ボブのため）だけでなく、サーバC、D、E、等のみならず、メッセージを届けることができました。このような場合には、複数のを避けるために、上記のメカニズムによって暗黙のトランザクションを「バックダイヤル」、XMPPシステムは、おそらく（例えば、時に定期的および/またはイベント駆動型ベースでSMKをリフレッシュ、複数の個々のメッセージのために与えられたSMKを再利用します受信者のプレゼンスの変更）。包まれたキーは、今後のメッセージ上のコンテンツと一緒に送ることができるように、彼らはまた、最終受信者の公開鍵をキャッシュすることがあります。これはJOSE暗号化されたオブジェクト形式が同じラップSMK（CMS EnvelopedDataの構造など多くが複数のRecipientInfo構造を含めることができる）の複数のバージョンの提供をサポートしなければならないことを意味します。"
    },
    {
      "indent": 3,
      "text": "In the current draft of the XMPP end-to-end security system, each party is authenticated by virtue of the other party's trust in the XMPP message routing system. The sender is authenticated to the receiver because he can receive messages for the identifier \"Alice\" (in particular, the request for wrapped keys) and can originate messages for that identifier (the wrapped key). Likewise, the receiver is authenticated to the sender because he received the original encrypted message and originated the request for a wrapped key. So, the authentication here requires not only that XMPP routing be done properly, but also that TLS be used on every hop. Moreover, it requires that the TLS channels have strong authentication, since a man in the middle on any of the three hops can masquerade as Bob and obtain the key material for an encrypted message.",
      "ja": "XMPPエンドツーエンドのセキュリティ・システムの現在のドラフトでは、各当事者は、XMPPメッセージルーティングシステム内の他のパーティの信頼によって認証されます。彼は（特に、包まれたキーの要求）、「アリス」識別子のメッセージを受け取ることができて、その識別子（ラップされた鍵）のメッセージを発信することができますので、送信者が受信者に認証されます。彼は、元の暗号化されたメッセージを受信し、ラップされた鍵の要求を発したので、同様に、受信側は送信側に認証されています。だから、ここ認証は、XMPPルーティングが適切に行われていることだけでなく必要ですが、また、そのTLSはすべてのホップに使用すること。また、3つのホップの任意の中央に人がボブになりすますと暗号化されたメッセージのための鍵材料を得ることができるので、TLSチャネルは、強力な認証を有することを必要とします。"
    },
    {
      "indent": 3,
      "text": "Because this authentication is quite weak (depending on the use of TLS on three hops) and unverifiable by the endpoints, it is possible that the XMPP working group will integrate some sort of credentials for end recipients, in which case there would need to be a way to associate these credentials with JOSE objects.",
      "ja": "この認証はかなり（3つのホップにTLSの用途に応じて）弱いと終点による検証不可能であるので、XMPPワーキンググループがあることが必要と思われる場合には、エンド受信者の資格情報のいくつかの並べ替えを、統合することは可能ですJOSEオブジェクトでこれらの資格情報を関連付ける方法。"
    },
    {
      "indent": 3,
      "text": "Finally, it's worth noting that XMPP is based on XML, not JSON. So by using JOSE, XMPP will be carrying JSON objects within XML. It is thus a desirable property for JOSE objects to be encoded in such a way as to be safe for inclusion in XML. Otherwise, an explicit CDATA indication must be given to the parser to indicate that it is not to be parsed as XML. One way to meet this requirement would be to apply base64url encoding, but for XMPP messages of medium-to-large size, this could impose a fair degree of overhead.",
      "ja": "最後に、それはXMPPは、XML、JSONではないに基づいていることは注目に値します。だから、JOSE、XMPPを使用してXML内JSONオブジェクトを運ぶことになります。したがって、XMLに含めるために安全であるような方法で符号化するJOSEオブジェクトにとって望ましい特性です。それ以外の場合は、明示的なCDATA表示は、それがXMLとして解析されるようにされていないことを示すために、パーサに与えられなければなりません。この要件を満たすための一つの方法は、base64urlエンコーディングを適用することであろうが、中規模から大規模のXMPPメッセージのために、これはオーバーヘッドのかなりの程度を課すことができます。"
    },
    {
      "indent": 0,
      "text": "5.5. ALTO",
      "section_title": true,
      "ja": "5.5。 ALTO"
    },
    {
      "indent": 3,
      "text": "Application-Layer Traffic Optimization (ALTO) is a system for distributing network topology information to end devices, so that those devices can modify their behavior to have a lower impact on the network [RFC6708]. The ALTO protocol distributes topology information in the form of JSON objects carried in HTTP [RFC2616] [ALTO]. The basic version of ALTO is simply a client-server protocol, so simple use of HTTPS suffices for this case [RFC2818]. However, there is beginning to be some discussion of use cases for ALTO in which these JSON objects will be distributed through a collection of intermediate servers before reaching the client, while still preserving the ability of the client to authenticate the original source of the object. Even the base ALTO protocol notes that \"ALTO Clients obtaining ALTO information through redistribution must be able to validate the received ALTO information\" to ensure that it was generated by an appropriate ALTO server.",
      "ja": "アプリケーションレイヤトラフィック最適化（ALTO）は、これらのデバイスは、ネットワーク[RFC6708]に低い影響を有するように、それらの動作を変更することができるように、デバイスを終了するために、ネットワークトポロジー情報を配信するためのシステムです。 ALTOプロトコルはHTTP [RFC2616] [ALTO]で運ばJSONオブジェクトの形にトポロジー情報を配信します。 ALTOの基本的なバージョンは、単にクライアントサーバプロトコルである、HTTPSのように単純な使用は、この場合、[RFC2818]のために十分です。しかし、まだオブジェクトの元のソースを認証するためのクライアントの能力を維持しながら、これらのJSONオブジェクトがクライアントに到達する前に、中間サーバーの集合を通じて配布されるにALTOの利用例いくつかの議論があるように始めています。ベースALTOプロトコルは、それが適切なALTOサーバによって生成されたことを確認するために、「再分配を通じてALTO情報を取得ALTOクライアントは、受信ALTO情報を検証することができなければならない」と述べています。"
    },
    {
      "indent": 3,
      "text": "In this case, the security requirements are straightforward. JOSE objects carrying ALTO payloads will need to bear digital signatures from the originating servers, which will be bound to certificates attesting to the identities of the servers. There is no requirement for confidentiality in this case, since ALTO information is generally public.",
      "ja": "この場合、セキュリティ要件は簡単です。 ALTOペイロードを運ぶJOSEオブジェクトは、サーバの身元を証明する証明書にバインドされる、元のサーバーからのデジタル署名を負担する必要があります。 ALTO情報は一般公開されているので、この場合、機密保持のための要件は、ありません。"
    },
    {
      "indent": 3,
      "text": "The more interesting questions are encoding questions. ALTO objects are likely to be much larger than payloads in the two cases above, with sizes of up to several megabytes. Processing of such large objects can be done more quickly if it can be done in a single pass, which may be possible if JOSE objects require specific orderings of fields within the JSON structure.",
      "ja": "より興味深い質問が質問をコードしています。 ALTOオブジェクトは、数メガバイトまでのサイズで、上記2つの場合のペイロードよりもはるかに大きくなる可能性があります。それはJOSEオブジェクトはJSON構造内のフィールドの特定の順序が必要な場合は可能であってもよい単一のパスで行うことができれば、このような大きなオブジェクトの処理をより迅速に行うことができます。"
    },
    {
      "indent": 3,
      "text": "In addition, because ALTO objects are also encoded as JSON, they are already safe for inclusion in a JOSE object. Signed JOSE objects will likely carry the signed data in a string alongside the signature. JSON objects have the property that they can be safely encoded in JSON strings. All they require is that unnecessary white space be removed, a much simpler transformation than, say, base64url encoding. This raises the question of whether it might be possible to optimize the JOSE encoding for certain \"JSON-safe\" cases.",
      "ja": "ALTOオブジェクトはまた、JSONとしてエンコードされているのでさらに、彼らは既にJOSEオブジェクトに含めるために安全です。署名付きJOSEオブジェクトは、おそらく署名と一緒に文字列に署名されたデータを運ぶでしょう。 JSONオブジェクトは、彼らが安全にJSON文字列にエンコードすることができる性質を持っています。彼らが必要とするすべては、不要な空白を削除することbase64urlエンコーディング、たとえば、よりはるかに簡単変換です。特定の「JSON-安全な」例のためJOSEエンコーディングを最適化することが可能であるかもしれないかどうかの問題を提起します。"
    },
    {
      "indent": 3,
      "text": "Finally, it may be desirable for ALTO to have a \"detached signature\" mechanism, that is, a way to encode signature information separate from the protected content. This would allow the ALTO protocol to include the signature in an HTTPS header, with the signed content as the HTTPS entity body.",
      "ja": "ALTO、即ち、保護されたコンテンツから分離した署名情報を符号化する方法を「分離署名」メカニズムを持っているため、最終的に、それは望ましいかもしれません。これはALTOプロトコルがHTTPSエンティティ体として署名付きコンテンツに、HTTPSヘッダに署名を含めることを可能にします。"
    },
    {
      "indent": 0,
      "text": "5.6. Emergency Alerting",
      "section_title": true,
      "ja": "5.6。緊急アラート"
    },
    {
      "indent": 3,
      "text": "Emergency alerting is an emerging use case for IP networks [ALERT-REQ]. Alerting systems allow authorities to warn users of impending danger by sending alert messages to connected devices. For example, in the event of a hurricane or tornado, alerts might be sent to all devices in the path of the storm.",
      "ja": "緊急時のアラートは、IPネットワーク[ALERT-REQ]のための新たな使用事例です。アラートシステムは、当局が接続されたデバイスに警告メッセージを送信することにより、差し迫った危険のユーザーに警告することができます。例えば、ハリケーンや竜巻が発生した場合に、アラートは嵐のパス内のすべてのデバイスに送信される可能性があります。"
    },
    {
      "indent": 3,
      "text": "The most critical security requirement for alerting systems is that it must not be possible for an attacker to send false alerts to devices. Such a capability would potentially allow an attacker to create wide-spread panic. In practice, alert systems prevent these attacks both by controls on sending messages at points where alerts are originated, and by having recipients of alerts verify that the alert was sent by an authorized source. The former type of control is implemented with local security on hosts from which alerts can be originated. The latter type is implemented by digital signatures on alert messages (using channel-based or object-based mechanisms). With an object-based mechanism, the signature value is encoded in a secure object. With a channel-based mechanism, the alert is \"signed\" by virtue of being sent over an authenticated, integrity-protected channel.",
      "ja": "システムを警告するための最も重要なセキュリティ要件は、攻撃者がデバイスに偽の警告を送信することが可能であってはならないということです。このような機能は、攻撃者が広範囲にパニックを作成することができます。実際には、警報システムは、アラートが発信されているポイントでメッセージを送信上のコントロールの両方でこれらの攻撃を防ぎ、およびアラートの受信者を持つことにより、アラートが許可されたソースによって送信されたことを確認します。コントロールの前者は、警告が発信可能なホスト上でローカルセキュリティを用いて実施されます。後者のタイプは、（チャネルベースまたはオブジェクトベースのメカニズムを使用して）警告メッセージにデジタル署名することにより実現されます。オブジェクトベース機構と、署名値は、セキュアオブジェクトに符号化されます。チャネルベースのメカニズムと、アラートが認証され、完全性保護チャネルを介して送信されることによって「署名」されています。"
    },
    {
      "indent": 3,
      "text": "Alerts typically reach end recipients via a series of intermediaries. For example, while a national weather service might originate a hurricane alert, it might first be delivered to a national gateway and then to network operators, who broadcast it to end subscribers.",
      "ja": "アラートは、通常の仲介のシリーズを介してエンドの受信者に到達します。全国の天気サービスはハリケーン警報を発するかもしれないが、例えば、それは、初の全国ゲートウェイにして、加入者を終了するには、それを放送するネットワーク事業者に配信されることがあります。"
    },
    {
      "indent": 11,
      "text": "+------------+    +------------+    +------------+\n| Originator |    | Originator |    | Originator |\n+------------+    +------------+    +------------+\n      |                 .                 .\n      +-----------------+..................\n                        |\n                        V\n                   +---------+\n                   | Gateway |\n                   +---------+\n                        |\n           +------------+------------+\n           |                         |\n           V                         V\n      +---------+               +---------+\n      | Network |               | Network |\n      +---------+               +---------+\n           |                         |\n    +------+-----+            +------+-----+\n    |            |            |            |\n    V            V            V            V\n+--------+   +--------+   +--------+   +--------+\n| Device |   | Device |   | Device |   | Device |\n+--------+   +--------+   +--------+   +--------+",
      "raw": true
    },
    {
      "indent": 18,
      "text": "Figure 4: Delivering an Emergency Alert",
      "ja": "図4：緊急警報を配信します"
    },
    {
      "indent": 3,
      "text": "In order to verify alert signatures, recipients must be provisioned with the proper public keys for trusted alert authorities. This trust may be \"piece-wise\" along the path the alert takes. For example, the alert relays operated by networks might have a full set of certificates for all alert originators, while end devices may only trust their local alert relay. Or, devices might require that a device be signed by an authorized originator and by its local network's relay.",
      "ja": "アラートの署名を検証するために、受信者は、信頼できるアラートの当局のための適切な公開鍵をプロビジョニングする必要があります。この信頼は、「ピース単位」のアラートが取る道に沿っていてもよいです。エンドデバイスのみが地元の警報リレーを信頼している間たとえば、ネットワークが運営する警報リレーは、すべてのアラート発信元の証明書のフルセットを持っているかもしれません。あるいは、デバイスは、デバイスが認可さ創始により、そのローカルネットワークのリレーによって署名されていることが必要になる場合があります。"
    },
    {
      "indent": 3,
      "text": "This scenario creates a need for multiple signatures on alert documents, so that an alert can bear signatures from any or all of the entities that processed it along the path. In order to minimize complexity, these signatures should be \"modular\" in the sense that a new signature can be added without a need to alter or recompute previous signatures.",
      "ja": "アラートは、パスに沿って、それを処理したエンティティのいずれかまたは全てから署名を負担することができるように、このシナリオでは、警告の文書に複数の署名の必要性を作成します。複雑さを最小限にするために、これらのシグネチャは、新しい署名が前の署名を変更または再計算することなく追加することができるという意味で「モジュラー」であるべきです。"
    },
    {
      "indent": 0,
      "text": "5.7. Web Cryptography",
      "section_title": true,
      "ja": "5.7。ウェブ暗号化"
    },
    {
      "indent": 3,
      "text": "The W3C Web Cryptography API defines a standard cryptographic API for the Web [WebCrypto]. If a browser exposes this API, then JavaScript provided as part of a Web page can ask the browser to perform cryptographic operations, such as digest, MAC, encryption, or digital signing.",
      "ja": "W3CのWeb暗号化APIは、Web [WebCrypto]のための標準的な暗号化APIを定義します。ブラウザがこのAPIを公開する場合は、Webページの一部として提供されるJavaScriptは、このようなダイジェスト、MAC、暗号化、またはデジタル署名など、暗号化操作を実行するためにブラウザを依頼することができます。"
    },
    {
      "indent": 3,
      "text": "One of the key reasons to have the browser perform cryptographic operations is to avoid allowing JavaScript code to access the keying material used for these operations. For example, this separation would prevent code injected through a cross-site scripting (XSS) attack from reading and exfiltrating keys stored within a browser. While the malicious code could still use the key while running in the browser, this vulnerability can only be exercised while the malicious code is active in a user's browser.",
      "ja": "ブラウザが暗号化操作を実行するために持っている主な理由の一つは、これらの操作に使用する鍵素材にアクセスすることを可能にするJavaScriptコードを避けるためです。例えば、この分離は、ブラウザ内に格納されたキーを読み取ってexfiltratingからクロスサイトスクリプティング（XSS）攻撃を介して挿入されたコードを防止します。ブラウザで実行中に悪質なコードはまだキーを使用することができますが、この脆弱性は、悪意のあるコードがユーザーのブラウザでアクティブである間に行使することができます。"
    },
    {
      "indent": 3,
      "text": "However, the Web Cryptography API also provides a key export functionality, which can allow JavaScript to extract a key from the API in wrapped form. For example, JavaScript code might provide a public key for which the corresponding private key is held by another device. The wrapped key provided by the API could then be used to safely transport the key to the new device. While this could potentially allow malicious code to export a key, the need for an explicit export operation provides a control point, allowing for user notification or consent verification.",
      "ja": "ただし、Web暗号化APIもJavaScriptがラップ形式のAPIからキーを抽出できるようにすることができ、キーのエクスポート機能を提供します。例えば、JavaScriptコードは対応する秘密鍵が別のデバイスで開催された公開鍵を提供するかもしれません。 APIが提供するラップされた鍵は、安全に、新しいデバイスへの鍵を運ぶために使用することができます。これは潜在的に悪意のあるコードがキーをエクスポートする可能性がありますが、明示的なエクスポート操作の必要性は、ユーザー通知または同意の確認を可能に、制御点を提供します。"
    },
    {
      "indent": 3,
      "text": "The Web Cryptography API also allows browsers to impose limitations on the usage of the keys it handles. For example, a symmetric key might be marked as usable only for encryption, and not for MAC. When a key is exported in wrapped form, these attributes should be carried along with it.",
      "ja": "ウェブ暗号化APIもブラウザがそれが扱うキーの使用に制限を課すことができます。例えば、対称鍵は、暗号化のために使用可能な、およびないMAC用としてマークされる可能性があります。キーがラップ形式でエクスポートすると、これらの属性は、それに沿って行ってください。"
    },
    {
      "indent": 3,
      "text": "The Web Cryptography API thus requires formats to express several forms of keys. Obviously, the public key from an asymmetric key pair can be freely imported to and exported from the browser, so there needs to be a format for public keys. There is also a need for a format to express private keys and symmetric keys. For non-public keys, the primary need is for a wrapped form, where the confidentiality and integrity of the key is assured cryptographically; these protections should also apply to any attributes of the key. It may also be useful to define a direct, unwrapped format for use within a security boundary.",
      "ja": "ウェブ暗号化APIは、このように、キーのいくつかの形を表現するためにフォーマットする必要があります。明らかに、非対称鍵ペアの公開鍵は自由に輸入され、ブラウザからエクスポートし、その公開鍵のフォーマットが必要であることができます。秘密鍵と対称鍵を表現する形式も必要です。非公開鍵の場合、主必要性はキーの機密性と完全性を暗号的に保証されているラップ形式のためのものです。これらの保護は、キーのいずれかの属性に適用されるべきです。また、セキュリティの境界内で使用するために、直接、開封されたフォーマットを定義することが有用であり得ます。"
    },
    {
      "indent": 0,
      "text": "5.8. Constrained Devices",
      "section_title": true,
      "ja": "5.8。制約のあるデバイス"
    },
    {
      "indent": 3,
      "text": "This section describes use cases for constrained devices as defined in [CONSTRAINED]. Typical issues with this type of device are limited memory, limited power supply, low processing power, and severe message size limitations for the communication protocols.",
      "ja": "このセクションでは、[CONSTRAINED]で定義されるように制約のあるデバイスのためのユースケースを説明しています。デバイスのこのタイプの典型的な問題は、通信プロトコルのための限られたメモリと、限られた電源、低処理能力、および重度のメッセージサイズの制限があります。"
    },
    {
      "indent": 0,
      "text": "5.8.1. Example: MAC Based on ECDH-Derived Key",
      "section_title": true,
      "ja": "5.8.1。例：ECDH由来キーに基づいてMAC"
    },
    {
      "indent": 3,
      "text": "Suppose a small, low power device maker has decided on using the output of the JOSE working group as their encryption and authentication framework. The device maker has a limited budget for both gates and power. For this reason there are a number of short cuts and design decisions that have been made in order to minimize these needs.",
      "ja": "小型、低消費電力のデバイスメーカーは、彼らの暗号化と認証フレームワークとしてJOSEワーキンググループの出力を使用することに決定しましたとします。デバイスメーカーは、ゲートと電力の両方のための限られた予算を持っています。このため、これらのニーズを最小限にするために行われている短いカットとデザインの決定がいくつかあります。"
    },
    {
      "indent": 3,
      "text": "The design team has determined that the use of MACs is going to be sufficient to provide the necessary authentication. However, although a MAC is going to be used, they do not want to use a single long-term shared secret. Instead, they have adopted the following proposal for computing a shared secret that can be validated:",
      "ja": "設計チームは、MACの使用が必要な認証を提供するのに十分であることを行っていると判断しました。 MACが使用されようとしているものの、それらは単一の長期共有秘密を使用する必要はありません。その代わりに、検証することができる共有シークレットを計算するため、以下の提案を採用しています："
    },
    {
      "indent": 3,
      "text": "o An Elliptic-Curve Diffie-Hellman (ECDH) key pair is generated for the device at the time of manufacturing. (Or, as part of the configuration process during installation.)",
      "ja": "O楕円カーブディフィー・ヘルマン（ECDH）鍵ペアは、製造時のデバイスのために生成されます。 （インストール時の設定プロセスの一部として、または、。）"
    },
    {
      "indent": 3,
      "text": "o An ECDH public key for the controller is configured at the time of configuration.",
      "ja": "OコントローラのECDH公開鍵は、構成時に構成されています。"
    },
    {
      "indent": 3,
      "text": "o The configuration system performs the ECDH computation and configures the device with the resulting shared secret. This process eliminates the need for the device to be able to perform the required ECDH processing. The security requirements on protecting this computed shared secret are the same as the requirements on protecting the private ECDH key.",
      "ja": "OコンフィギュレーションシステムはECDH計算を行い、得られた共有秘密を有する装置を構成します。このプロセスは、デバイスが必要とECDH処理を実行できるようにする必要がなくなります。この計算された共有秘密を保護する上でのセキュリティ要件は、プライベートECDHキーを保護する上での要件と同じです。"
    },
    {
      "indent": 3,
      "text": "o A counter and an increment value are configured onto the device.",
      "ja": "Oカウンタとインクリメント値は、デバイス上に構成されています。"
    },
    {
      "indent": 3,
      "text": "o When a message is to be sent by the device, the counter is incremented and a new MAC key is computed from the ECDH secret and the counter value. A custom Key Derivation Function (KDF) based on AES-CBC is used to derive the required MAC key. The MAC key is then used to compute the MAC value for the message.",
      "ja": "メッセージは、デバイスによって送信される場合、O、カウンタが増分され、新しいMACキーはECDH秘密カウンタ値から計算されます。 AES-CBCに基づくカスタム鍵導出関数（KDF）は、必要なMACキーを導出するために使用されます。 MACキーは、メッセージのためのMAC値を計算するために使用されます。"
    },
    {
      "indent": 3,
      "text": "In a similar manner, the KDF function can be used to compute an Authenticated Encryption with Associated Data (AEAD) algorithm key when the system needs to provide confidentiality for the message. The controller, being a larger device, will perform the ECDH step and use a random number generator to generate the sender nonce value.",
      "ja": "同様に、KDF関数は、システムがメッセージの機密性を提供する必要がある場合、関連するデータ（AEAD）アルゴリズムの鍵を使用して認証された暗号化を計算するために使用することができます。コントローラは、より大きなデバイスである、ECDHステップを実行し、送信者ノンス値を生成する乱数発生器を使用します。"
    },
    {
      "indent": 0,
      "text": "5.8.2. Object Security for CoAP",
      "section_title": true,
      "ja": "5.8.2。 CoAPのためのオブジェクトセキュリティ"
    },
    {
      "indent": 3,
      "text": "This use case deals with constrained devices of class C0/C1 (see [CONSTRAINED]). These devices communicate using RESTful requests and responses transferred using the Constrained Application Protocol [CoAP]. To simplify matters, all communication is assumed to be unicast; i.e., these security measures don't cover multicast or broadcast.",
      "ja": "このユースケースは、クラスC0 / C1（[CONSTRAINED]を参照）の拘束装置を扱います。これらのデバイスは、制約されたアプリケーションプロトコル[CoAP]を使用して転送RESTfulな要求と応答を使用して通信します。問題を単純化するために、すべての通信は、ユニキャストであると仮定されます。すなわち、これらのセキュリティ対策は、マルチキャストまたはブロードキャストをカバーしていません。"
    },
    {
      "indent": 3,
      "text": "In this type of setting, it may be too costly to use session-based security (e.g., to run a 4-pass authentication protocol) since receiving and in particular sending consumes a lot of power, especially for wireless devices. Therefore, to just secure the CoAP payload by replacing a plaintext payload of a request or response with a JWE object is an important alternative solution, which allows a trade-off between protection (the CoAP headers are not protected) and performance.",
      "ja": "このタイプの設定では、特に無線装置のために、多くの電力受信ので、特に送信消費（4パス認証プロトコルを実行するために、例えば）セッションベースのセキュリティを使用するにはあまりにも高価であり得ます。したがって、単にJWEオブジェクトにリクエスト又はレスポンスの平文ペイロードを置き換えることによってCoAPペイロードを確保すること保護（CoAPヘッダが保護されていない）と性能の間のトレードオフを可能にする重要な代替案です。"
    },
    {
      "indent": 3,
      "text": "In a simple setting, consider the payload of a CoAP GET response from a sensor type device. The information in a sensor reading may be privacy or business sensitive and needs both integrity protection and encryption.",
      "ja": "簡単な設定では、センサタイプのデバイスからCoAPのGET応答のペイロードを考えます。センサーの読み取り中の情報は、プライバシーやビジネス敏感であると完全性保護と暗号化の両方を必要とする場合があります。"
    },
    {
      "indent": 3,
      "text": "However, some sensor readings are very short, say, a few bytes, and in this case, default encryption and integrity protection algorithms (such as 128-bit AES-CBC with HMAC_SHA256) may cause a dramatic expansion of the payload, even disregarding JWE headers.",
      "ja": "しかし、いくつかのセンサーの測定値は、たとえば、数バイトが非常に短く、この場合には、（そのようHMAC_SHA256と128ビットのAES-CBCなど）は、デフォルトの暗号化および完全性保護アルゴリズムがさえJWEを無視し、ペイロードの劇的な拡大を引き起こす可能性がありヘッダ。"
    },
    {
      "indent": 3,
      "text": "Also, the value of certain sensor readings may decline rapidly, e.g., traffic or environmental measurements, so it must be possible to reduce the security overhead.",
      "ja": "また、一定のセンサ読取値の値は、例えば、急速にトラフィックまたは環境測定値を拒否することができるので、セキュリティ上のオーバーヘッドを低減することが可能でなければなりません。"
    },
    {
      "indent": 3,
      "text": "This leads to the following requirements that could be covered by specific JWE/JWS profiles:",
      "ja": "これは、特定のJWE / JWSプロファイルでカバーすることができ、次の要件につながります："
    },
    {
      "indent": 3,
      "text": "o The size of the secure object shall be as small as possible. Receiving an object may cost orders of magnitude more in terms of power than performing, say, public key cryptography on the object, in particular in a wireless setting.",
      "ja": "O安全なオブジェクトのサイズはできるだけ小さくなければなりません。オブジェクトを受信すると、無線設定では特に、オブジェクト上で、たとえば、公開鍵暗号を実行するよりも、消費電力の点でより桁違いの費用がかかることがあります。"
    },
    {
      "indent": 3,
      "text": "o Integrity protection: The object shall be able to support integrity protection, i.e., have a field containing a digital signature, both public key signatures and keyed MACs shall be supported.",
      "ja": "Oインテグリティ保護：オブジェクトは、公開鍵署名と鍵付きのMACの両方をサポートしなければならない、すなわち、デジタル署名を含むフィールドを持って、完全性保護をサポートすることができなければなりません。"
    },
    {
      "indent": 3,
      "text": "o Encryption: The object shall be able to support encryption as an optional addition to integrity protection. It shall be possible to exclude certain fields from encryption, which are needed before verifying integrity or decrypting the object.",
      "ja": "O暗号化：オブジェクトは、完全性保護へのオプションの追加として暗号化をサポートすることができなければなりません。整合性を検証したり、オブジェクトを復号化する前に必要な暗号化、から特定のフィールドを除外することが可能でなければなりません。"
    },
    {
      "indent": 3,
      "text": "o Cipher suites: It should be possible to support a variety of cipher suites to support the constrained devices' use cases. For example:",
      "ja": "暗号スイートO：制約デバイスのユースケースをサポートする暗号スイートの様々なサポートすることが可能です。例えば："
    },
    {
      "indent": 6,
      "text": "* Block ciphers with block sizes of, e.g., 96 bits, in addition to the standard 128 bits.",
      "ja": "*標準の128ビットに加えのブロックサイズ、例えば、96ビットを有するブロック暗号。"
    },
    {
      "indent": 6,
      "text": "* Modes of operation for block ciphers that do not expand the message size to a block boundary, such as AES-GCM.",
      "ja": "*このようAES-GCMとして、ブロック境界にメッセージのサイズを拡張していないブロック暗号のためのオペレーションのモード。"
    },
    {
      "indent": 6,
      "text": "* Cipher suites that support combined encryption and MAC calculation (i.e., AEAD modes for block ciphers).",
      "ja": "合わせた暗号化及びMAC計算（ブロック暗号のために、すなわち、AEADモード）をサポート*暗号スイート。"
    },
    {
      "indent": 0,
      "text": "6. Requirements",
      "section_title": true,
      "ja": "6.要件"
    },
    {
      "indent": 3,
      "text": "This section summarizes the requirements from the above use cases and lists further requirements not directly derived from the above use cases. There are also some constraints that are not hard requirements but that are still desirable properties for the JOSE system to have.",
      "ja": "このセクションでは、上記のユースケースから要件をまとめて、直接上記のユースケースから派生していない更なる要件を示しています。ハード要件はありませんが、それはまだ持っているJOSEシステムに望ましい性質であるいくつかの制約もあります。"
    },
    {
      "indent": 0,
      "text": "6.1. Functional Requirements",
      "section_title": true,
      "ja": "6.1。機能要件"
    },
    {
      "indent": 3,
      "text": "F1 Define formats for secure objects that provide the following security properties:",
      "ja": "F1は、次のセキュリティ特性を提供するセキュアなオブジェクトのためのフォーマットを定義します。"
    },
    {
      "indent": 6,
      "text": "* Digital signature (integrity/authentication under an asymmetric key pair)",
      "ja": "*デジタル署名（整合性/非対称鍵ペアの下での認証）"
    },
    {
      "indent": 6,
      "text": "* Message authentication (integrity/authentication under a symmetric key)",
      "ja": "*メッセージ認証（対称キーの下インテグリティ/認証）"
    },
    {
      "indent": 6,
      "text": "* Authenticated encryption",
      "ja": "*認証された暗号化"
    },
    {
      "indent": 3,
      "text": "F2 Define a format for public keys and private keys for asymmetric cryptographic algorithms, with associated attributes, including a wrapped form for private keys.",
      "ja": "F2は、秘密鍵のために包まれたフォームを含む関連する属性と、非対称暗号化アルゴリズムの公開鍵と秘密鍵のフォーマットを定義します。"
    },
    {
      "indent": 3,
      "text": "F3 Define a format for symmetric keys with associated attributes, allowing for both wrapped and unwrapped keys.",
      "ja": "F3は、両包み、開封されたキーを可能にする、関連する属性との対称鍵のフォーマットを定義します。"
    },
    {
      "indent": 3,
      "text": "F4 Define a JSON serialization for each of the above objects. An object in this encoding must be valid according to the JSON ABNF syntax [RFC7159].",
      "ja": "F4は、上記の各オブジェクトのためのJSONのシリアル化を定義します。この符号化でオブジェクトがJSON ABNF構文[RFC7159]に従って有効でなければなりません。"
    },
    {
      "indent": 3,
      "text": "F5 Define a compact, URL-safe text serialization for the encrypted and signed object formats.",
      "ja": "F5は、暗号化と署名オブジェクトフォーマット用のコンパクト、URLセーフテキストのシリアル化を定義します。"
    },
    {
      "indent": 3,
      "text": "F6 Allow for attributes associated to wrapped keys to be bound to them cryptographically.",
      "ja": "F6は、暗号それらに拘束されることに包まれたキーに関連付けられた属性を許可します。"
    },
    {
      "indent": 3,
      "text": "F7 Allow for wrapped keys to be separated from a secure object that uses a symmetric key. In such cases, cryptographic components of the secure object other than the wrapped key (e.g., ciphertext, MAC values) must be independent of the wrapped form of the key. For example, if an encrypted object is prepared for multiple recipients, then only the wrapped key may vary, not the ciphertext.",
      "ja": "F7は、対称鍵を使用して、安全なオブジェクトから分離するために包まれたキーを許可します。このような場合には、ラップされた鍵（例えば、暗号文、MAC値）以外の安全なオブジェクトの暗号化構成要素は、鍵のラップされた形態とは無関係でなければなりません。暗号化されたオブジェクトが複数の受信者のために準備されている場合、例えば、その後だけラップされた鍵は暗号文ではなく、変化してもよいです。"
    },
    {
      "indent": 3,
      "text": "F8 Do not impose more overhead than is required to meet the requirements in this document, especially when a large amount of application content is being protected.",
      "ja": "F8は、アプリケーションの大量のコンテンツが保護されています場合は特に、この文書の要件を満たすために必要とされるよりも多くのオーバーヘッドを課すしないでください。"
    },
    {
      "indent": 0,
      "text": "6.2. Security Requirements",
      "section_title": true,
      "ja": "6.2。セキュリティ要件"
    },
    {
      "indent": 3,
      "text": "S1 Provide mechanisms to avoid repeated use of the same symmetric key for encryption or MAC computation. Instead, long-lived keys should be used only for key wrapping, not for direct encryption/ MAC. It should be possible to use any of the key management techniques provided in CMS [RFC5652]:",
      "ja": "S1は、暗号化やMAC計算のための同じ対称鍵を繰り返し使用を避けるためのメカニズムを提供します。代わりに、長命のキーがない、直接、暗号化/ MACのために、唯一の鍵ラッピング用に使用する必要があります。 CMS [RFC5652]で提供鍵管理技術のいずれかを使用することが可能でなければなりません。"
    },
    {
      "indent": 6,
      "text": "* Key transport (wrapping for a public key)",
      "ja": "*主な輸送（公開鍵のラッピング）"
    },
    {
      "indent": 6,
      "text": "* Key encipherment (wrapping for a symmetric key)",
      "ja": "*鍵暗号化（対称鍵用ラッピング）"
    },
    {
      "indent": 6,
      "text": "* Key agreement (wrapping for a Diffie-Hellman (DH) public key)",
      "ja": "*キー契約（ディフィー・ヘルマン（DH）公開鍵のためのラップ）"
    },
    {
      "indent": 6,
      "text": "* Password-based encryption (wrapping under a key derived from a password)",
      "ja": "*パスワードベースの暗号化（パスワードから派生キーの下ラッピング）"
    },
    {
      "indent": 3,
      "text": "S2 Where long-lived symmetric keys are used directly for cryptographic operations (i.e., where requirement S1 is not met), provide deployment guidance on key management practices, such as the need to limit key lifetimes.",
      "ja": "長寿命の対称鍵を暗号化操作のために直接使用されたS2は（S1要件が満たされていない、すなわち、ここで）、そのようなキーの有効期間を制限する必要性などの鍵管理方法、に展開ガイダンスを提供します。"
    },
    {
      "indent": 3,
      "text": "S3 Use cryptographic algorithms in a manner compatible with major validation processes. For example, if typical validation standards allow algorithm A to be used for purpose X but not purpose Y, then JOSE should not recommend using algorithm A for purpose Y.",
      "ja": "主要な検証プロセスと互換性のある方法で、S3を使用する暗号化アルゴリズム。典型的な検証基準は、アルゴリズムAは、目的のXのために使用することが可能ではなく、目的Y場合たとえば、その後、JOSEは、目的のY.のためのアルゴリズムAを使用することをお勧めしてはなりません"
    },
    {
      "indent": 3,
      "text": "S4 Support operation with or without pre-negotiation. It must be possible to create or process secure objects without any configuration beyond key provisioning. If it is possible for keys to be derived from application context, it must be possible for a recipient to recognize when it does not have the appropriate key.",
      "ja": "とや事前交渉なしS4サポート操作。キーのプロビジョニングを超えた設定がなくても安全なオブジェクトを作成したり、処理することが可能でなければなりません。キーはアプリケーションコンテキストから導出されることは可能であるならば、それは適切なキーを持たない場合、受信者が認識することが可能でなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.3. Desiderata",
      "section_title": true,
      "ja": "6.3。要望"
    },
    {
      "indent": 3,
      "text": "D1 Maximize compatibility with the W3C Web Crypto specifications, e.g., by coordinating with the Web Crypto working group to encourage alignment of algorithms and algorithm identifiers.",
      "ja": "W3Cウェブ暗号仕様とD1最大化との互換性は、例えば、ウェブ暗号ワーキンググループと連携することによりアルゴリズムとアルゴリズム識別子の整列を促進します。"
    },
    {
      "indent": 3,
      "text": "D2 Avoid JSON canonicalization to the extent possible. That is, all other things being equal, techniques that rely on fixing a serialization of an object (e.g., by encoding it with base64url) are preferred over those that require converting an object to a canonical form.",
      "ja": "D2は、可能な範囲でJSONの正規化を避けてください。それは、他のすべてのものが等しい、（base64urlでそれを符号化することにより、例えば）オブジェクトのシリアライゼーションを固定に頼る技術は標準形式にオブジェクトを変換する必要とするものよりも好ましいれます。"
    },
    {
      "indent": 3,
      "text": "D3 Maximize the extent to which the inputs and outputs of JOSE cryptographic operations can be controlled by the applications, as opposed to involving processing specific to JOSE. This allows JOSE the flexibility to address the needs of many cryptographic protocols. For example, in some cases, it might allow JOSE objects to be translated to legacy formats such as CMS without the need for re-encryption or re-signing.",
      "ja": "D3はJOSEの具体的な処理関与とは対照的にJOSE暗号操作の入力および出力は、アプリケーションによって制御可能な範囲を最大化。これはJOSEに多くの暗号プロトコルのニーズに対応するための柔軟性を可能にします。例えば、いくつかのケースでは、それはJOSEオブジェクトが再暗号化または再署名を必要とせずに、このようなCMSなどのレガシーフォーマットに変換することを可能にするかもしれません。"
    },
    {
      "indent": 0,
      "text": "7. Security Considerations",
      "section_title": true,
      "ja": "7.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "The primary focus of this document is the requirements for a JSON-based secure object format. At the level of general security considerations for object-based security technologies, the security considerations for this format are the same as for CMS [RFC5652]. The primary difference between the JOSE format and CMS is that JOSE is based on JSON, which does not have a canonical representation. The lack of a canonical form means that it is difficult to determine whether two JSON objects represent the same information, which could lead to vulnerabilities in some usages of JOSE.",
      "ja": "この文書の主な焦点は、JSONベースの安全なオブジェクトフォーマットの要件です。オブジェクトベースのセキュリティ技術の一般的なセキュリティ問題のレベルでは、この形式のセキュリティ問題は、CMS [RFC5652]と同じです。 JOSEフォーマットとCMSの間の主な違いは、JOSEが正規表現を持たないJSON、に基づいていることです。標準形式の欠如は、2つのJSONオブジェクトがJOSEのいくつかの用途において、脆弱性につながる同じ情報を表すかどうかを決定することは困難であることを意味します。"
    },
    {
      "indent": 0,
      "text": "8. References",
      "section_title": true,
      "ja": "8.参照文献"
    },
    {
      "indent": 0,
      "text": "8.1. Normative References",
      "section_title": true,
      "ja": "8.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC4949] Shirey, R., \"Internet Security Glossary, Version 2\", RFC 4949, August 2007.",
      "ja": "[RFC4949] Shirey、R.、 \"インターネットセキュリティ用語集、バージョン2\"、RFC 4949、2007年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC5652] Housley, R., \"Cryptographic Message Syntax (CMS)\", STD 70, RFC 5652, September 2009.",
      "ja": "[RFC5652] Housley氏、R.、 \"暗号メッセージ構文（CMS）\"、STD 70、RFC 5652、2009年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC6120] Saint-Andre, P., \"Extensible Messaging and Presence Protocol (XMPP): Core\", RFC 6120, March 2011.",
      "ja": "[RFC6120]サンアンドレ、P.、 \"拡張メッセージングおよびプレゼンスプロトコル（XMPP）：コア\"、RFC 6120、2011年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC6708] Kiesel, S., Previdi, S., Stiemerling, M., Woundy, R., and Y. Yang, \"Application-Layer Traffic Optimization (ALTO) Requirements\", RFC 6708, September 2012.",
      "ja": "[RFC6708]キーセル、S.、Previdi、S.、Stiemerling、M.、Woundy、R.、およびY.ヤン、 \"アプリケーションレイヤトラフィックの最適化（ALTO）要件\"、RFC 6708、2012年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC6749] Hardt, D., \"The OAuth 2.0 Authorization Framework\", RFC 6749, October 2012.",
      "ja": "[RFC6749]ハルト、D.、 \"OAuth 2.0の認証フレームワーク\"、RFC 6749、2012年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC7159] Bray, T., \"The JavaScript Object Notation (JSON) Data Interchange Format\", RFC 7159, March 2014.",
      "ja": "[RFC7159]ブレイ、T.、 \"JavaScriptのObject Notation（JSON）形式のデータ交換フォーマット\"、RFC 7159、2014年3月。"
    },
    {
      "indent": 3,
      "text": "[W3C.REC-xml] Bray, T., Maler, E., Paoli, J., and C. Sperberg-McQueen, \"Extensible Markup Language (XML) 1.0 (Fifth Edition)\", W3C Recommendation, November 2008, <http://www.w3.org/TR/2008/REC-xml-20081126/>.",
      "ja": "[W3C.REC-XML]ブレイ、T.、MALER、E.、パオリ、J.、およびC. Sperberg-マックイーン、 \"拡張マークアップ言語（XML）1.0（第5版）\"、W3C勧告、2008年11月< http://www.w3.org/TR/2008/REC-xml-20081126/>。"
    },
    {
      "indent": 3,
      "text": "[WebCrypto] Dahl, D. and R. Sleevi, \"Web Cryptography API\", W3C Working Draft, January 2013, <http://www.w3.org/TR/2013/WD-WebCryptoAPI-20130108/>.",
      "ja": "[WebCrypto]ダール、D.とR. Sleevi、 \"ウェブ暗号化API\"、W3Cワーキングドラフト、2013年1月、<http://www.w3.org/TR/2013/WD-WebCryptoAPI-20130108/>。"
    },
    {
      "indent": 0,
      "text": "8.2. Informative References",
      "section_title": true,
      "ja": "8.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[ALERT-REQ] Schulzrinne, H., Norreys, S., Rosen, B., and H. Tschofenig, \"Requirements, Terminology and Framework for Exigent Communications\", Work in Progress, March 2012.",
      "ja": "[ALERT-REQ] Schulzrinneと、H.、Norreys、S.、ローゼン、B.、およびH. Tschofenig、 \"緊急の通信のための要件の用語とフレームワーク\" が進歩、2012年3月に働いています。"
    },
    {
      "indent": 3,
      "text": "[ALTO] Alimi, R., Ed., Penno, R., Ed., and Y. Yang, Ed., \"ALTO Protocol\", Work in Progress, March 2014.",
      "ja": "[ALTO] Alimi、R.、エド。、Penno、R.、エド。、およびY.ヤン、エド。、 \"ALTO議定書\"、進歩、2014年3月での作業。"
    },
    {
      "indent": 3,
      "text": "[CAP] Botterell, A. and E. Jones, \"Common Alerting Protocol, v1.1\", OASIS Standard CAP-V1.1, October 2005, <http://www.oasis-open.org/committees/download.php/15135/ emergency-CAPv1.1-Corrected_DOM.pdf>.",
      "ja": "[CAP] Botterell、A.とE.ジョーンズ、 \"共通アラートプロトコル、V1.1\"、OASIS標準CAP-V1.1、2005年10月、<http://www.oasis-open.org/committees/download。 PHP / 15135 /緊急CAPv1.1-Corrected_DOM.pdf>。"
    },
    {
      "indent": 3,
      "text": "[CONSTRAINED] Bormann, C., Ersue, M., and A. Keranen, \"Terminology for Constrained Node Networks\", Work in Progress, March 2014.",
      "ja": "[CONSTRAINED]ボルマン、C.、Ersue、M.、およびA. Keranen、 \"制約ノードネットワークの用語\"、進歩、2014年3月での作業。"
    },
    {
      "indent": 3,
      "text": "[CoAP] Shelby, Z., Hartke, K., and C. Bormann, \"Constrained Application Protocol (CoAP)\", Work in Progress, June 2013.",
      "ja": "【CoAP]シェルビー、Z.、HARTKE、K.、およびC.ボルマン、 \"制約アプリケーションプロトコル（CoAP）\"、進歩、2013年6月に働いています。"
    },
    {
      "indent": 3,
      "text": "[ITU.X690.2002] International Telecommunications Union, \"Information Technology - ASN.1 encoding rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER)\", ITU-T Recommendation X.690, July 2002.",
      "ja": "[ITU.X690.2002]国際電気通信連合、 \"情報技術 -  ASN.1エンコーディング規則：基本符号化規則（BER）、Canonicalの符号化規則（CER）、および顕著な符号化規則（DER）の仕様\"、ITU-T勧告X 0.690、2002年7月。"
    },
    {
      "indent": 3,
      "text": "[JWA] Jones, M., \"JSON Web Algorithms (JWA)\", Work in Progress, March 2014.",
      "ja": "[JOY]ジョーンズ、M.、 \"JSONのWeb暗号（JOY）\"、進歩、2014年3月での作業。"
    },
    {
      "indent": 3,
      "text": "[JWE] Jones, M. and J. Hildebrand, \"JSON Web Encryption (JWE)\", Work in Progress, March 2014.",
      "ja": "【JWE】ジョーンズ、M.及びJ.ヒルデブランド、 \"JSONウェブ暗号化（JWE）\"、進歩、2014年3月に働いています。"
    },
    {
      "indent": 3,
      "text": "[JWK] Jones, M., \"JSON Web Key (JWK)\", Work in Progress, March 2014.",
      "ja": "[JWK]ジョーンズ、M.、 \"JSONのWebキー（JWK）\"、進歩、2014年3月での作業。"
    },
    {
      "indent": 3,
      "text": "[JWS] Jones, M., Bradley, J., and N. Sakimura, \"JSON Web Signature (JWS)\", Work in Progress, March 2014.",
      "ja": "【JWS】ジョーンズ、M.、ブラッドリー、J。、およびN. Sakimura、 \"JSONウェブ署名（JWS）\"、進歩、2014年3月に働いています。"
    },
    {
      "indent": 3,
      "text": "[JWT-BEARER] Jones, M., Campbell, B., and C. Mortimore, \"JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and Authorization Grants\", Work in Progress, March 2014.",
      "ja": "[JWTベアラ]ジョーンズ、M.、キャンベル、B.、およびC. Mortimore、 \"OAuth 2.0のクライアント認証と認可グラントのためのJSONウェブトークン（JWT）プロファイル\"、進歩、2014年3月に働いています。"
    },
    {
      "indent": 3,
      "text": "[JWT] Jones, M., Bradley, J., and N. Sakimura, \"JSON Web Token (JWT)\", Work in Progress, March 2014.",
      "ja": "【JWT]ジョーンズ、M.、ブラッドリー、J。、およびN. Sakimura、 \"JSONウェブトークン（JWT）\"、進歩、2014年3月に働いています。"
    },
    {
      "indent": 3,
      "text": "[OASIS.saml-core-2.0-os] Cantor, S., Kemp, J., Maler, E., and R. Philpott, \"Assertions and Protocols for the OASIS Security Assertion Markup Language (SAML) V2.0\", Oasis Standard, March 2005, <http://docs.oasis-open.org/security/saml/v2.0/ saml-core-2.0-os.pdf>.",
      "ja": "[OASIS.samlコア-2.0-OS]カントール、S.、ケンプ、J.、MALER、E.、およびR.フィルポット、 \"OASISセキュリティアサーションマークアップ言語（SAML）V2.0のためのアサーションとプロトコル\"、 OASIS標準、2005年3月、<http://docs.oasis-open.org/security/saml/v2.0/ SAML-コア-2.0-os.pdf>。"
    },
    {
      "indent": 3,
      "text": "[OpenID.Core] Bradley, J., de Medeiros, B., Jones, M., Mortimore, C., and N. Sakimura, \"OpenID Connect Core 1.0\", December 2013, <http://openid.net/specs/openid-connect-core-1_0.html>.",
      "ja": "【OpenID.Core]ブラッドリー、J.、デメデイロス、B.、ジョーンズ、M.、Mortimore、C.、およびN. Sakimura、 \"OpenIDの接続コア1.0\"、2013年12月、<http://openid.net/スペック/ OpenIDのコネクト・コア・1_0.html>。"
    },
    {
      "indent": 3,
      "text": "[Persona] Mozilla Developer Network, \"Mozilla Persona\", April 2013, <https://developer.mozilla.org/en-US/docs/Persona>.",
      "ja": "[人] Mozillaの開発者ネットワーク、 \"Mozillaのペルソナ\"、2013年4月<https://developer.mozilla.org/en-US/docs/Persona>。"
    },
    {
      "indent": 3,
      "text": "[RFC2616] Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P., and T. Berners-Lee, \"Hypertext Transfer Protocol -- HTTP/1.1\", RFC 2616, June 1999.",
      "ja": "[RFC2616]フィールディング、R.、ゲティス、J.、モーグル、J.、Frystyk、H.、Masinter、L.、リーチ、P.、およびT.バーナーズ - リー、 \"ハイパーテキスト転送プロトコル -  HTTP / 1.1\" 、RFC 2616、1999年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC2818] Rescorla, E., \"HTTP Over TLS\", RFC 2818, May 2000.",
      "ja": "[RFC2818]レスコラ、E.、 \"TLSオーバーHTTP\"、RFC 2818、2000年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC3207] Hoffman, P., \"SMTP Service Extension for Secure SMTP over Transport Layer Security\", RFC 3207, February 2002.",
      "ja": "[RFC3207]ホフマン、P.、 \"トランスポート層セキュリティの安全なSMTPのためのSMTPサービス拡張子\"、RFC 3207、2002年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC3923] Saint-Andre, P., \"End-to-End Signing and Object Encryption for the Extensible Messaging and Presence Protocol (XMPP)\", RFC 3923, October 2004.",
      "ja": "[RFC3923]サンアンドレ、P.、「エンド・ツー・エンドの拡張メッセージングおよびプレゼンスプロトコル（XMPP）のための署名とオブジェクトの暗号化」、RFC 3923、2004年10月に。"
    },
    {
      "indent": 3,
      "text": "[RFC4301] Kent, S. and K. Seo, \"Security Architecture for the Internet Protocol\", RFC 4301, December 2005.",
      "ja": "[RFC4301]ケント、S.とK. Seo、 \"インターネットプロトコルのためのセキュリティアーキテクチャ\"、RFC 4301、2005年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC4648] Josefsson, S., \"The Base16, Base32, and Base64 Data Encodings\", RFC 4648, October 2006.",
      "ja": "[RFC4648] Josefsson氏、S.、 \"Base16、Base32、およびBase64でデータエンコーディング\"、RFC 4648、2006年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC5246] Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS) Protocol Version 1.2\", RFC 5246, August 2008.",
      "ja": "[RFC5246]ダークス、T.およびE.レスコラ、 \"トランスポート層セキュリティ（TLS）プロトコルバージョン1.2\"、RFC 5246、2008年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC5322] Resnick, P., Ed., \"Internet Message Format\", RFC 5322, October 2008.",
      "ja": "[RFC5322]レズニック、P.、エド。、 \"インターネットメッセージ形式\"、RFC 5322、2008年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC5751] Ramsdell, B. and S. Turner, \"Secure/Multipurpose Internet Mail Extensions (S/MIME) Version 3.2 Message Specification\", RFC 5751, January 2010.",
      "ja": "[RFC5751] Ramsdell、B.、およびS.ターナー、 \"/セキュア多目的インターネットメール拡張（S / MIME）バージョン3.2メッセージ仕様\"、RFC 5751、2010年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC6750] Jones, M. and D. Hardt, \"The OAuth 2.0 Authorization Framework: Bearer Token Usage\", RFC 6750, October 2012.",
      "ja": "[RFC6750]ジョーンズ、M.とD.ハルト、 \"OAuth 2.0の認証フレームワーク：ベアラートークンの使用\"、RFC 6750、2012年10月。"
    },
    {
      "indent": 3,
      "text": "[SAML2] Campbell, B., Mortimore, C., and M. Jones, \"SAML 2.0 Profile for OAuth 2.0 Client Authentication and Authorization Grants\", Work in Progress, March 2014.",
      "ja": "[SAML2]キャンベル、B.、Mortimore、C.、およびM.ジョーンズ、 \"OAuth 2.0のクライアント認証と認可グラントのためにSAML 2.0プロファイル\"、進歩、2014年3月に働いています。"
    },
    {
      "indent": 3,
      "text": "[W3C.xmldsig-core] Eastlake, D., Reagle, J., and D. Solo, \"XML-Signature Syntax and Processing\", W3C Recommendation, June 2008, <http://www.w3.org/TR/2008/REC-xmldsig-core-20080610/>.",
      "ja": "[W3C.xmldsigコア]イーストレーク、D.、Reagle、J.、およびD.ソロ、 \"XML-署名構文と処理\"、W3C勧告、2008年6月<http://www.w3.org/TR/ 2008 / REC-XMLDSIG-コア-20080610 />。"
    },
    {
      "indent": 3,
      "text": "[W3C.xmlenc-core] Eastlake, D. and J. Reagle, \"XML Encryption Syntax and Processing\", W3C Candidate Recommendation, December 2002, <http://www.w3.org/TR/2002/REC-xmlenc-core-20021210/>.",
      "ja": "[W3C.xmlencコア]イーストレイク、D.とJ. Reagle、 \"XML暗号化構文と処理\"、W3C勧告候補、2002年12月、<http://www.w3.org/TR/2002/REC-xmlenc-コア-20021210 />。"
    },
    {
      "indent": 3,
      "text": "[WS-Federation] Goodner, M., Kaler, C., McIntosh, M., and A. Nadalin, \"Web Services Federation Language (WS-Federation) Version 1.2\", Oasis Standard, May 2009, <http://docs.oasis-open.org/ wsfed/federation/v1.2/os/ws-federation-1.2-spec-os.html>.",
      "ja": "[WS-Federationの] Goodner、M.、Kaler、C.、マッキントッシュ、M.、およびA. Nadalin、 \"Webサービス連盟言語（WS-Federationの）バージョン1.2\"、OASIS標準、2009年5月、<のhttp：// docs.oasis-open.org/ wsfed /フェデレーション/ V1.2 / OS / WS-Federationの-1.2-SPEC-os.html>。"
    },
    {
      "indent": 3,
      "text": "[XMPP-E2E] Miller, M., \"End-to-End Object Encryption and Signatures for the Extensible Messaging and Presence Protocol (XMPP)\", Work in Progress, June 2013.",
      "ja": "[XMPP-E2E]ミラー、M.、「拡張メッセージングおよびプレゼンスプロトコル（XMPP）のためのエンドツーエンドのオブジェクトの暗号化と署名」、進歩、2013年6月での作業。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Acknowledgements",
      "ja": "付録A.謝辞"
    },
    {
      "indent": 3,
      "text": "Thanks to Matt Miller for discussions related to the XMPP end-to-end security model and to Mike Jones for considerations related to security tokens and XML security. Thanks to Mark Watson for raising the need for representing symmetric keys and binding attributes to them. Thanks to Ludwig Seitz for contributing the constrained device use case.",
      "ja": "セキュリティトークンとXMLのセキュリティに関連する考慮事項についてはXMPPのエンドツーエンドのセキュリティモデルにし、マイク・ジョーンズに関連した議論のためのMatt Miller氏に感謝します。対称鍵を表現し、それらに属性を結合するための必要性を上げるためのマーク・ワトソンに感謝します。制約のあるデバイスのユースケースを貢献するためのルートヴィヒサイツに感謝します。"
    },
    {
      "indent": 0,
      "text": "Author's Address",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Richard Barnes Mozilla 331 E. Evelyn Ave. Mountain View, CA 94041 US",
      "ja": "リチャード・バーンズMozillaの331 E.イヴリン・アベニュー。マウンテンビュー、カリフォルニア州94041米国"
    },
    {
      "indent": 3,
      "text": "EMail: rlb@ipv.sx",
      "ja": "メールアドレス：rlb@ipv.sx"
    }
  ]
}