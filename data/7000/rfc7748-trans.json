{
  "title": {
    "text": "RFC 7748 - Elliptic Curves for Security",
    "ja": "RFC 7748 - セキュリティのための楕円曲線"
  },
  "number": 7748,
  "created_at": "2019-11-01 22:09:45.094838+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Research Task Force (IRTF)                           A. Langley\nRequest for Comments: 7748                                        Google\nCategory: Informational                                       M. Hamburg\nISSN: 2070-1721                             Rambus Cryptography Research\n                                                               S. Turner\n                                                                   sn3rd\n                                                            January 2016",
      "raw": true
    },
    {
      "indent": 22,
      "text": "Elliptic Curves for Security",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This memo specifies two elliptic curves over prime fields that offer a high level of practical security in cryptographic applications, including Transport Layer Security (TLS). These curves are intended to operate at the ~128-bit and ~224-bit security level, respectively, and are generated deterministically based on a list of required properties.",
      "ja": "このメモは、トランスポート層セキュリティ（TLS）などの暗号アプリケーションで実用的な高レベルのセキュリティを提供するプライムフィールド上の2つの楕円曲線を指定します。これらの曲線は、それぞれ、〜128ビットと〜224ビットのセキュリティ・レベルで動作するように意図され、そして必要とされる特性のリストに基づいて、決定論的に生成されます。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "ja": "このドキュメントはインターネット標準化過程仕様ではありません。それは、情報提供の目的のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Research Task Force (IRTF). The IRTF publishes the results of Internet-related research and development activities. These results might not be suitable for deployment. This RFC represents the consensus of the Crypto Forum Research Group of the Internet Research Task Force (IRTF). Documents approved for publication by the IRSG are not a candidate for any level of Internet Standard; see Section 2 of RFC 5741.",
      "ja": "この文書はインターネットResearch Task Force（IRTF）の製品です。 IRTFはインターネット関連の研究開発活動の成果を公表しています。これらの結果は、展開に適していない可能性があります。このRFCはインターネットResearch Task Force（IRTF）の暗号化フォーラム研究グループのコンセンサスを表しています。 IRSGによって公表のために承認されたドキュメントは、インターネット標準の任意のレベルの候補ではありません。 RFC 5741のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7748.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7748で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2016 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2016 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   2\n2.  Requirements Language . . . . . . . . . . . . . . . . . . . .   3\n3.  Notation  . . . . . . . . . . . . . . . . . . . . . . . . . .   3\n4.  Recommended Curves  . . . . . . . . . . . . . . . . . . . . .   4\n  4.1.  Curve25519  . . . . . . . . . . . . . . . . . . . . . . .   4\n  4.2.  Curve448  . . . . . . . . . . . . . . . . . . . . . . . .   5\n5.  The X25519 and X448 Functions . . . . . . . . . . . . . . . .   7\n  5.1.  Side-Channel Considerations . . . . . . . . . . . . . . .  10\n  5.2.  Test Vectors  . . . . . . . . . . . . . . . . . . . . . .  11\n6.  Diffie-Hellman  . . . . . . . . . . . . . . . . . . . . . . .  14\n  6.1.  Curve25519  . . . . . . . . . . . . . . . . . . . . . . .  14\n  6.2.  Curve448  . . . . . . . . . . . . . . . . . . . . . . . .  15\n7.  Security Considerations . . . . . . . . . . . . . . . . . . .  15\n8.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  16\n  8.1.  Normative References  . . . . . . . . . . . . . . . . . .  16\n  8.2.  Informative References  . . . . . . . . . . . . . . . . .  17\nAppendix A.  Deterministic Generation . . . . . . . . . . . . . .  19\n  A.1.  p = 1 mod 4 . . . . . . . . . . . . . . . . . . . . . . .  20\n  A.2.  p = 3 mod 4 . . . . . . . . . . . . . . . . . . . . . . .  21\n  A.3.  Base Points . . . . . . . . . . . . . . . . . . . . . . .  21\nAcknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  22\nAuthors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  22",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "Since the initial standardization of Elliptic Curve Cryptography (ECC [RFC6090]) in [SEC1], there has been significant progress related to both efficiency and security of curves and implementations. Notable examples are algorithms protected against certain side-channel attacks, various \"special\" prime shapes that allow faster modular arithmetic, and a larger set of curve models from which to choose. There is also concern in the community regarding the generation and potential weaknesses of the curves defined by NIST [NIST].",
      "ja": "[SEC1]における楕円曲線暗号（ECC [RFC6090]）の初期標準化するので、曲線及び実装の効率とセキュリティの両方に関連する重要な進展がありました。顕著な例は、特定のサイドチャネル攻撃、高速剰余演算を可能にする様々な「特別な」素数形状、及びそこから選択する曲線モデルの大きな集合から保護アルゴリズムです。 [NIST] NISTによって定義された曲線の生成および潜在的な弱点に関するコミュニティの懸念もあります。"
    },
    {
      "indent": 3,
      "text": "This memo specifies two elliptic curves (\"curve25519\" and \"curve448\") that lend themselves to constant-time implementation and an exception-free scalar multiplication that is resistant to a wide range of side-channel attacks, including timing and cache attacks. They are Montgomery curves (where v^2 = u^3 + A*u^2 + u) and thus have birationally equivalent Edwards versions. Edwards curves support the fastest (currently known) complete formulas for the elliptic-curve group operations, specifically the Edwards curve x^2 + y^2 = 1 + d*x^2*y^2 for primes p when p = 3 mod 4, and the twisted Edwards curve -x^2 + y^2 = 1 + d*x^2*y^2 when p = 1 mod 4. The maps to/from the Montgomery curves to their (twisted) Edwards equivalents are also given.",
      "ja": "このメモは、二つの楕円曲線定数時実装とタイミングとキャッシュ攻撃など、サイドチャネル攻撃の広い範囲に耐性のある例外を含まないスカラー倍算に役立つ（「curve25519」および「curve448」）を指定します。彼らは、モンゴメリ曲線（V ^ 2 = U ^ 3 + *のU ^ 2 + U）であり、従ってbirationally等価エドワーズバージョンを持っています。素数pのエドワーズ曲線が楕円曲線群操作のための最速（現在知られている）は、完全な式をサポートし、具体エドワーズ曲線のx ^ 2 + y ^ 2 = 1 + D * X ^ 2 * y ^ 2とき、P = 3 MOD 4、およびねじれエドワーズ曲線マップ4 -x ^ 2 + y ^ 2 = 1 + D * X ^ 2 * y ^ 2、P = 1つのMODへ/モンゴメリー曲線からの（ねじれ）エドワーズ当量でありますまた、与えられました。"
    },
    {
      "indent": 3,
      "text": "This memo also specifies how these curves can be used with the Diffie-Hellman protocol for key agreement.",
      "ja": "また、このメモは、これらの曲線は、鍵合意のためのDiffie-Hellmanプロトコルで使用することができる方法を指定します。"
    },
    {
      "indent": 0,
      "text": "2. Requirements Language",
      "section_title": true,
      "ja": "2.必要な言語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [RFC2119].",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はRFC 2119 [RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "3. Notation",
      "section_title": true,
      "ja": "3.表記"
    },
    {
      "indent": 3,
      "text": "Throughout this document, the following notation is used:",
      "ja": "本書では、以下の表記が使用されます。"
    },
    {
      "indent": 3,
      "text": "p Denotes the prime number defining the underlying field.",
      "ja": "pは基本フィールドを定義する素数を表します。"
    },
    {
      "indent": 3,
      "text": "GF(p) The finite field with p elements.",
      "ja": "GF（p）はp要素を持つ有限体。"
    },
    {
      "indent": 3,
      "text": "A An element in the finite field GF(p), not equal to -2 or 2.",
      "ja": "-2又は2に等しくない有限体GF（p）は、の要素。"
    },
    {
      "indent": 3,
      "text": "d A non-zero element in the finite field GF(p), not equal to 1, in the case of an Edwards curve, or not equal to -1, in the case of a twisted Edwards curve.",
      "ja": "D有限体GF（p）内の非ゼロ要素、エドワーズ曲線の場合には、1に等しくない、又はねじれエドワーズ曲線の場合には、-1に等しくありません。"
    },
    {
      "indent": 3,
      "text": "order The order of the prime-order subgroup.",
      "ja": "プライム次のサブグループの順番を注文。"
    },
    {
      "indent": 3,
      "text": "P A generator point defined over GF(p) of prime order.",
      "ja": "プライムためのGF（p）上で定義されたPジェネレータ点。"
    },
    {
      "indent": 3,
      "text": "U(P) The u-coordinate of the elliptic curve point P on a Montgomery curve.",
      "ja": "U（P）モンゴメリ曲線上の楕円曲線点PのU座標。"
    },
    {
      "indent": 3,
      "text": "V(P) The v-coordinate of the elliptic curve point P on a Montgomery curve.",
      "ja": "V（P）モンゴメリ曲線上の楕円曲線点PのV座標。"
    },
    {
      "indent": 3,
      "text": "X(P) The x-coordinate of the elliptic curve point P on a (twisted) Edwards curve.",
      "ja": "X（P）（ねじれ）エドワーズ曲線上の楕円曲線点Pのx座標。"
    },
    {
      "indent": 3,
      "text": "Y(P) The y-coordinate of the elliptic curve point P on a (twisted) Edwards curve.",
      "ja": "Y（P）は（ねじれ）エドワーズ曲線上の楕円曲線点Pのy座標。"
    },
    {
      "indent": 3,
      "text": "u, v Coordinates on a Montgomery curve.",
      "ja": "U、Vは、モンゴメリ曲線上の座標。"
    },
    {
      "indent": 3,
      "text": "x, y Coordinates on a (twisted) Edwards curve.",
      "ja": "X、Yは、（ねじれ）エドワーズ曲線上の座標。"
    },
    {
      "indent": 0,
      "text": "4. Recommended Curves",
      "section_title": true,
      "ja": "4.推奨曲線"
    },
    {
      "indent": 0,
      "text": "4.1. Curve25519",
      "section_title": true,
      "ja": "4.1。 Curve25519"
    },
    {
      "indent": 3,
      "text": "For the ~128-bit security level, the prime 2^255 - 19 is recommended for performance on a wide range of architectures. Few primes of the form 2^c-s with s small exist between 2^250 and 2^521, and other choices of coefficient are not as competitive in performance. This prime is congruent to 1 mod 4, and the derivation procedure in Appendix A results in the following Montgomery curve v^2 = u^3 + A*u^2 + u, called \"curve25519\":",
      "ja": "〜128ビットのセキュリティレベル、プライム2 ^ 255の場合 -  19アーキテクチャの広い範囲でのパフォーマンスのために推奨されます。 S 2 ^ 250及び2 ^ 521の間の小さな存在し、係数の他の選択肢を持つフォーム2 ^ C-Sの数素数は、性能に競合的ではありません。この素数は1つのMOD 4、及び以下モンゴメリ曲線Vの付録A結果の導出手順と合同である^ 2 = U ^ 3 + A * U ^ 2 + U、 \"curve25519\" と呼ばれます。"
    },
    {
      "indent": 3,
      "text": "p 2^255 - 19",
      "ja": "19  -  P 2 ^ 255"
    },
    {
      "indent": 3,
      "text": "A 486662",
      "ja": "486662"
    },
    {
      "indent": 3,
      "text": "order 2^252 + 0x14def9dea2f79cd65812631a5cf5d3ed",
      "ja": "オーダー2 ^ 252 + 0x14def9dea2f79cd65812631a5cf5d3ed"
    },
    {
      "indent": 3,
      "text": "cofactor 8",
      "ja": "補因子8"
    },
    {
      "indent": 3,
      "text": "U(P) 9",
      "ja": "U（P）9"
    },
    {
      "indent": 3,
      "text": "V(P) 147816194475895447910205935684099868872646061346164752889648818 37755586237401",
      "ja": "V（P）147816194475895447910205935684099868872646061346164752889648818 37755586237401"
    },
    {
      "indent": 3,
      "text": "The base point is u = 9, v = 1478161944758954479102059356840998688726 4606134616475288964881837755586237401.",
      "ja": "ベースポイントは、U = 9、V = 1478161944758954479102059356840998688726 4606134616475288964881837755586237401あります。"
    },
    {
      "indent": 3,
      "text": "This curve is birationally equivalent to a twisted Edwards curve -x^2 + y^2 = 1 + d*x^2*y^2, called \"edwards25519\", where:",
      "ja": "この曲線は、ねじれエドワーズ曲線-x ^ 2 + y ^ 2 = 1 + D * X ^ 2 * y ^ 2、いわゆる \"edwards25519\" にbirationally等価です。"
    },
    {
      "indent": 3,
      "text": "p 2^255 - 19",
      "ja": "19  -  P 2 ^ 255"
    },
    {
      "indent": 3,
      "text": "d 370957059346694393431380835087545651895421138798432190163887855330 85940283555",
      "ja": "D 370957059346694393431380835087545651895421138798432190163887855330 85940283555"
    },
    {
      "indent": 3,
      "text": "order 2^252 + 0x14def9dea2f79cd65812631a5cf5d3ed",
      "ja": "オーダー2 ^ 252 + 0x14def9dea2f79cd65812631a5cf5d3ed"
    },
    {
      "indent": 3,
      "text": "cofactor 8",
      "ja": "補因子8"
    },
    {
      "indent": 3,
      "text": "X(P) 151122213495354007725011514095885315114540126930418572060461132 83949847762202",
      "ja": "X（P）151122213495354007725011514095885315114540126930418572060461132 83949847762202"
    },
    {
      "indent": 3,
      "text": "Y(P) 463168356949264781694283940034751631413079938662562256157830336 03165251855960",
      "ja": "Y（P）463168356949264781694283940034751631413079938662562256157830336 03165251855960"
    },
    {
      "indent": 3,
      "text": "The birational maps are:",
      "ja": "双有理マップは以下のとおりです。"
    },
    {
      "indent": 5,
      "text": "(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x) (x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))",
      "ja": "（U、V）=（（1つの+ Y）/（1-Y）、SQRT（-486664）* U / X）（X、Y）=（SQRT（-486664）* U / V、（U-1 ）/（U + 1））"
    },
    {
      "indent": 3,
      "text": "The Montgomery curve defined here is equal to the one defined in [curve25519], and the equivalent twisted Edwards curve is equal to the one defined in [ed25519].",
      "ja": "ここで定義されたモンゴメリ曲線は[curve25519]で定義されたものと同じであり、同等のねじれエドワーズ曲線は[ed25519]で定義されたものと同じです。"
    },
    {
      "indent": 0,
      "text": "4.2. Curve448",
      "section_title": true,
      "ja": "4.2。 Curve448"
    },
    {
      "indent": 3,
      "text": "For the ~224-bit security level, the prime 2^448 - 2^224 - 1 is recommended for performance on a wide range of architectures. This prime is congruent to 3 mod 4, and the derivation procedure in Appendix A results in the following Montgomery curve, called \"curve448\":",
      "ja": "2 ^ 224  -   - 〜224ビットのセキュリティレベル、プライム2 ^ 448の場合は1のアーキテクチャの広い範囲でのパフォーマンスのために推奨されます。この首相は3 MOD 4、および「curve448」と呼ばれる以下のモンゴメリーカーブ、付録A結果の導出手順に合同であります："
    },
    {
      "indent": 3,
      "text": "p 2^448 - 2^224 - 1",
      "ja": "1  -  P 2 ^ 448から2 ^ 224"
    },
    {
      "indent": 3,
      "text": "A 156326",
      "ja": "156326"
    },
    {
      "indent": 3,
      "text": "order 2^446 - 0x8335dc163bb124b65129c96fde933d8d723a70aadc873d6d54a7bb0d",
      "ja": "オーダー2 ^ 446  -  0x8335dc163bb124b65129c96fde933d8d723a70aadc873d6d54a7bb0d"
    },
    {
      "indent": 3,
      "text": "cofactor 4",
      "ja": "補因子4"
    },
    {
      "indent": 3,
      "text": "U(P) 5",
      "ja": "U（P）5"
    },
    {
      "indent": 3,
      "text": "V(P) 355293926785568175264127502063783334808976399387714271831880898 435169088786967410002932673765864550910142774147268105838985595290 606362",
      "ja": "V（P）355293926785568175264127502063783334808976399387714271831880898 435169088786967410002932673765864550910142774147268105838985595290 606362"
    },
    {
      "indent": 3,
      "text": "This curve is birationally equivalent to the Edwards curve x^2 + y^2 = 1 + d*x^2*y^2 where:",
      "ja": "この曲線は、x ^ 2 + y ^ 2 = 1 + D * X ^ 2 * y ^ 2エドワーズ曲線にbirationally等価です。"
    },
    {
      "indent": 3,
      "text": "p 2^448 - 2^224 - 1",
      "ja": "1  -  P 2 ^ 448から2 ^ 224"
    },
    {
      "indent": 3,
      "text": "d 611975850744529176160423220965553317543219696871016626328968936415 087860042636474891785599283666020414768678979989378147065462815545 017",
      "ja": "D 611975850744529176160423220965553317543219696871016626328968936415 087860042636474891785599283666020414768678979989378147065462815545 017"
    },
    {
      "indent": 3,
      "text": "order 2^446 - 0x8335dc163bb124b65129c96fde933d8d723a70aadc873d6d54a7bb0d",
      "ja": "オーダー2 ^ 446  -  0x8335dc163bb124b65129c96fde933d8d723a70aadc873d6d54a7bb0d"
    },
    {
      "indent": 3,
      "text": "cofactor 4",
      "ja": "補因子4"
    },
    {
      "indent": 3,
      "text": "X(P) 345397493039729516374008604150537410266655260075183290216406970 281645695073672344430481787759340633221708391583424041788924124567 700732",
      "ja": "X（P）345397493039729516374008604150537410266655260075183290216406970 281645695073672344430481787759340633221708391583424041788924124567 700732"
    },
    {
      "indent": 3,
      "text": "Y(P) 363419362147803445274661903944002267176820680343659030140745099 590306164083365386343198191849338272965044442230921818680526749009 182718",
      "ja": "Y（P）363419362147803445274661903944002267176820680343659030140745099 590306164083365386343198191849338272965044442230921818680526749009 182718"
    },
    {
      "indent": 3,
      "text": "The birational maps are:",
      "ja": "双有理マップは以下のとおりです。"
    },
    {
      "indent": 5,
      "text": "(u, v) = ((y-1)/(y+1), sqrt(156324)*u/x) (x, y) = (sqrt(156324)*u/v, (1+u)/(1-u))",
      "ja": "（U、V）=（（Y-1）/（Y + 1）、SQRT（156324）* U / X）（X、Y）=（SQRT（156324）* U / V、（1 + U）/ （1-U））"
    },
    {
      "indent": 3,
      "text": "Both of those curves are also 4-isogenous to the following Edwards curve x^2 + y^2 = 1 + d*x^2*y^2, called \"edwards448\", where:",
      "ja": "これらの曲線の両方はまた、以下のエドワーズ曲線のx ^ 2 + y ^ 2 = 1 + D * X ^ 2 * y ^ 2、いわゆる \"edwards448\"、4-isogenousあります。"
    },
    {
      "indent": 3,
      "text": "p 2^448 - 2^224 - 1",
      "ja": "1  -  P 2 ^ 448から2 ^ 224"
    },
    {
      "indent": 3,
      "text": "d -39081",
      "ja": "D -39081"
    },
    {
      "indent": 3,
      "text": "order 2^446 - 0x8335dc163bb124b65129c96fde933d8d723a70aadc873d6d54a7bb0d",
      "ja": "オーダー2 ^ 446  -  0x8335dc163bb124b65129c96fde933d8d723a70aadc873d6d54a7bb0d"
    },
    {
      "indent": 3,
      "text": "cofactor 4",
      "ja": "補因子4"
    },
    {
      "indent": 3,
      "text": "X(P) 224580040295924300187604334099896036246789641632564134246125461 686950415467406032909029192869357953282578032075146446173674602635 247710",
      "ja": "X（P）224580040295924300187604334099896036246789641632564134246125461 686950415467406032909029192869357953282578032075146446173674602635 247710"
    },
    {
      "indent": 3,
      "text": "Y(P) 298819210078481492676017930443930673437544040154080242095928241 372331506189835876003536878655418784733982303233503462500531545062 832660",
      "ja": "Y（P）298819210078481492676017930443930673437544040154080242095928241 372331506189835876003536878655418784733982303233503462500531545062 832660"
    },
    {
      "indent": 3,
      "text": "The 4-isogeny maps between the Montgomery curve and this Edwards curve are:",
      "ja": "モンゴメリーの曲線と、このエドワーズ曲線と4-同種写像マップは、次のとおりです。"
    },
    {
      "indent": 5,
      "text": "(u, v) = (y^2/x^2, (2 - x^2 - y^2)*y/x^3) (x, y) = (4*v*(u^2 - 1)/(u^4 - 2*u^2 + 4*v^2 + 1), -(u^5 - 2*u^3 - 4*u*v^2 + u)/ (u^5 - 2*u^2*v^2 - 2*u^3 - 2*v^2 + u))",
      "ja": "（U、V）=（y ^ 2 / X ^ 2（2×^ 2  -  y ^ 2）* Y / X ^ 3）（X、Y）=（4 *のV×（U ^ 2  -  1）/ （U ^ 4  -  2 * U ^ 2 + 4 * V ^ 2 + 1）、 - （U ^ 5  -  2 * U ^ 3  -  4 * U *は、V ^ 2 + U）/（U ^ 5  -  2 * U ^ 2 * V ^ 2から2 * U ^ 3から2 *のV ^ 2 + U））"
    },
    {
      "indent": 3,
      "text": "The curve edwards448 defined here is also called \"Goldilocks\" and is equal to the one defined in [goldilocks].",
      "ja": "ここで定義された曲線edwards448は、「ゴルディロックス」と呼ばれ、[びき]で定義されたものと同じです。"
    },
    {
      "indent": 0,
      "text": "5. The X25519 and X448 Functions",
      "section_title": true,
      "ja": "5. X25519およびX448機能"
    },
    {
      "indent": 3,
      "text": "The \"X25519\" and \"X448\" functions perform scalar multiplication on the Montgomery form of the above curves. (This is used when implementing Diffie-Hellman.) The functions take a scalar and a u-coordinate as inputs and produce a u-coordinate as output. Although the functions work internally with integers, the inputs and outputs are 32-byte strings (for X25519) or 56-byte strings (for X448) and this specification defines their encoding.",
      "ja": "「X25519」と「X448」機能は、上記曲線のモンゴメリ形態でスカラー乗法を行います。 （ディフィー・ヘルマンを実装するときに使用します。）関数は、スカラーを取り、入力としてのu座標と出力として座標Uを生成します。関数は整数で内部動作が、入力と出力は、（X25519用）32バイトの文字列または（X448用）56バイトの文字列であり、本明細書は、それらの符号化を定義します。"
    },
    {
      "indent": 3,
      "text": "The u-coordinates are elements of the underlying field GF(2^255 - 19) or GF(2^448 - 2^224 - 1) and are encoded as an array of bytes, u, in little-endian order such that u[0] + 256*u[1] + 256^2*u[2] + ... + 256^(n-1)*u[n-1] is congruent to the value modulo p and u[n-1] is minimal. When receiving such an array, implementations of X25519 (but not X448) MUST mask the most significant bit in the final byte. This is done to preserve compatibility with point formats that reserve the sign bit for use in other protocols and to increase resistance to implementation fingerprinting.",
      "ja": "リトルエンディアン順ようにUで、Uおよびバイトのアレイとして符号化されるか、またはGF（2 ^ 448  -  2  -  2 ^ 224） -  U座標は、下にあるフィールドGF（19 2 ^ 255）の要素であります[0] + 256 * U [1] + 256 ^ 2 * U [2] + ... + 256 ^（N-1）* Uを[N-1]が値モジュロPと合同であり、U [N- 1]最小です。そのようなアレイを受信した場合、X25519（ただし、X448）の実装は、最後のバイトの最上位ビットをマスクしなければなりません。これは他のプロトコルで使用するために符号ビットを予約し、実装指紋に対する抵抗性を増加させるためにポイント・フォーマットとの互換性を保つために行われます。"
    },
    {
      "indent": 3,
      "text": "Implementations MUST accept non-canonical values and process them as if they had been reduced modulo the field prime. The non-canonical values are 2^255 - 19 through 2^255 - 1 for X25519 and 2^448 - 2^224 - 1 through 2^448 - 1 for X448.",
      "ja": "実装は非標準的な値を受け入れ、彼らはフィールドプライムを法として削減されたかのようにそれらを処理しなければなりません。 X448のための1  -  2 ^ 448を介して、1  -  X25519 1及び2 ^ 448  -   -  2 ^ 224 2 ^ 255を介して19  - 非標準的な値は255 ^ 2です。"
    },
    {
      "indent": 3,
      "text": "The following functions implement this in Python, although the Python code is not intended to be performant nor side-channel free. Here, the \"bits\" parameter should be set to 255 for X25519 and 448 for X448:",
      "ja": "Pythonコードのパフォーマンスもサイドチャネルないことを意図するものではないが、以下の機能は、Pythonでこれを実装します。ここで、「ビット」パラメータは、X25519とX448のための448のために255に設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS> def decodeLittleEndian(b, bits): return sum([b[i] << 8*i for i in range((bits+7)/8)])",
      "ja": "DEF decodeLittleEndian（B、ビット）<CODEが始まる>：（[Iの範囲内（（ビット+ 7）/ 8）のためのB [I] << 8 * i]）とリターン和"
    },
    {
      "indent": 3,
      "text": "def decodeUCoordinate(u, bits): u_list = [ord(b) for b in u] # Ignore any unused bits. if bits % 8: u_list[-1] &= (1<<(bits%8))-1 return decodeLittleEndian(u_list, bits)",
      "ja": "DEF decodeUCoordinate（U、ビット）：＃は未使用のビットを無視u_list = [UにおけるBのORD（B）]。もしビット％8：u_list [-1]＆=（1 <<（ビット％8）） -  1戻りdecodeLittleEndian（u_list、ビット）"
    },
    {
      "indent": 3,
      "text": "def encodeUCoordinate(u, bits): u = u % p return ''.join([chr((u >> 8*i) & 0xff) for i in range((bits+7)/8)]) <CODE ENDS>",
      "ja": "DEF encodeUCoordinate（U、ビット）：U = U％P戻り '' .join（[CHR（（U >> 8 * I）＆0xffの）Iの範囲内の（（ビット+ 7）/ 8）用]）<CODE ENDS>"
    },
    {
      "indent": 3,
      "text": "Scalars are assumed to be randomly generated bytes. For X25519, in order to decode 32 random bytes as an integer scalar, set the three least significant bits of the first byte and the most significant bit of the last to zero, set the second most significant bit of the last byte to 1 and, finally, decode as little-endian. This means that the resulting integer is of the form 2^254 plus eight times a value between 0 and 2^251 - 1 (inclusive). Likewise, for X448, set the two least significant bits of the first byte to 0, and the most significant bit of the last byte to 1. This means that the resulting integer is of the form 2^447 plus four times a value between 0 and 2^445 - 1 (inclusive).",
      "ja": "スカラーは、ランダムに生成されたバイトであると仮定されます。 X25519のために、整数のスカラーとして32のランダムバイトを復号するために、ゼロに最初のバイトと最後の最上位ビットの3つの最下位ビットを設定し、1に最後のバイトの第二の最上位ビットを設定し、最後に、としてリトルエンディアンをデコードします。 1（含む） - これは、得られた整数は、0と2 ^ 251の間にフォーム2 ^ 254プラス8倍の値であることを意味します。同様に、X448は、これは、結果として得られる整数の形式は0〜^ 447 2を加えた値の4倍であることを意味する1に0の最初のバイトの2つの最下位ビット、および最後のバイトの最上位ビットをセットそして2 ^ 445から1（包括的）。"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS> def decodeScalar25519(k): k_list = [ord(b) for b in k] k_list[0] &= 248 k_list[31] &= 127 k_list[31] |= 64 return decodeLittleEndian(k_list, 255)",
      "ja": "<CODE BEGINS> DEF decodeScalar25519（K）：k_list = [KにおけるBのORD（B）] k_list [0]＆= 248 k_list [31]＆= 127 k_list [31] | = 64リターンdecodeLittleEndian（k_list、255）"
    },
    {
      "indent": 3,
      "text": "def decodeScalar448(k): k_list = [ord(b) for b in k] k_list[0] &= 252 k_list[55] |= 128 return decodeLittleEndian(k_list, 448) <CODE ENDS>",
      "ja": "DEF decodeScalar448（K）：k_list = [KにおけるBのORD（B）] k_list [0]＆= 252 k_list [55] | = 128リターンdecodeLittleEndian（k_list、448）<CODEが終了>"
    },
    {
      "indent": 3,
      "text": "To implement the X25519(k, u) and X448(k, u) functions (where k is the scalar and u is the u-coordinate), first decode k and u and then perform the following procedure, which is taken from [curve25519] and based on formulas from [montgomery]. All calculations are performed in GF(p), i.e., they are performed modulo p. The constant a24 is (486662 - 2) / 4 = 121665 for curve25519/X25519 and (156326 - 2) / 4 = 39081 for curve448/X448.",
      "ja": "【curve25519から取得され、次の手順を、X25519（K、U）およびX448（K、U）機能を実装（kはスカラーであり、Uは、U座標）U、第1デコードkとし、次に実行します]及び[モンゴメリー]から式に基づきます。すべての計算は、すなわち、それらが実行モジュロpは、GF（p）で行われます。 curve448 / X448のための/ 4 = 39081  -  / curve25519 / X25519 4 = 121665（2 156326） - 定数A24（2 486662）です。"
    },
    {
      "indent": 3,
      "text": "x_1 = u x_2 = 1 z_2 = 0 x_3 = u z_3 = 1 swap = 0",
      "ja": "X_1 = U X_2 = 1 Z_2 = 0 X_3 = U Z_3 = 1つのスワップ= 0"
    },
    {
      "indent": 3,
      "text": "For t = bits-1 down to 0: k_t = (k >> t) & 1 swap ^= k_t // Conditional swap; see text below. (x_2, x_3) = cswap(swap, x_2, x_3) (z_2, z_3) = cswap(swap, z_2, z_3) swap = k_t",
      "ja": "Tに対する=ビット-1 0まで：K_T =（K >> T）＆^ = K_T //条件スワップ1つのスワップ。下記のテキストを参照してください。 （X_2、X_3）= cswap（スワップ、X_2、X_3）（Z_2、Z_3）= cswap（スワップ、Z_2、Z_3）スワップ= K_T"
    },
    {
      "indent": 7,
      "text": "A = x_2 + z_2\nAA = A^2\nB = x_2 - z_2\nBB = B^2\nE = AA - BB\nC = x_3 + z_3\nD = x_3 - z_3\nDA = D * A\nCB = C * B\nx_3 = (DA + CB)^2\nz_3 = x_1 * (DA - CB)^2\nx_2 = AA * BB\nz_2 = E * (AA + a24 * E)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "// Conditional swap; see text below. (x_2, x_3) = cswap(swap, x_2, x_3) (z_2, z_3) = cswap(swap, z_2, z_3) Return x_2 * (z_2^(p - 2))",
      "ja": "//条件付きスワップ。下記のテキストを参照してください。 （X_2、X_3）= cswap（スワップ、X_2、X_3）（Z_2、Z_3）= cswap（スワップ、Z_2、Z_3）*（ -  2）Z_2 ^（P）X_2を返し"
    },
    {
      "indent": 3,
      "text": "(Note that these formulas are slightly different from Montgomery's original paper. Implementations are free to use any correct formulas.)",
      "ja": "（これらの式は、モンゴメリの原論文とは若干異なることに注意してください。実装は任意の正しい数式を自由に使用できます。）"
    },
    {
      "indent": 3,
      "text": "Finally, encode the resulting value as 32 or 56 bytes in little-endian order. For X25519, the unused, most significant bit MUST be zero.",
      "ja": "最後に、リトルエンディアン順に32のまたは56バイトとして得られた値を符号化します。 X25519の場合は、未使用、最上位ビットがゼロでなければなりません。"
    },
    {
      "indent": 3,
      "text": "The cswap function SHOULD be implemented in constant time (i.e., independent of the swap argument). For example, this can be done as follows:",
      "ja": "cswap機能（スワップ引数即ち、独立した）一定の時間内に実施されるべきです。たとえば、次のようにこれを行うことができます。"
    },
    {
      "indent": 3,
      "text": "cswap(swap, x_2, x_3): dummy = mask(swap) AND (x_2 XOR x_3) x_2 = x_2 XOR dummy x_3 = x_3 XOR dummy Return (x_2, x_3)",
      "ja": "cswap（スワップ、X_2、X_3）：ダミー=マスク（スワップ）AND（X_2 XOR X_3）X_2 = X_2 XORダミーX_3 = X_3 XORダミー復路（X_2、X_3）"
    },
    {
      "indent": 3,
      "text": "Where mask(swap) is the all-1 or all-0 word of the same length as x_2 and x_3, computed, e.g., as mask(swap) = 0 - swap.",
      "ja": "スワップ - マスク（スワップ）は、マスク（スワップ）= 0のような例えば計算X_2とX_3、同じ長さの全て1または全て0のワードは、です。"
    },
    {
      "indent": 0,
      "text": "5.1. Side-Channel Considerations",
      "section_title": true,
      "ja": "5.1。サイドチャネルの考慮事項"
    },
    {
      "indent": 3,
      "text": "X25519 and X448 are designed so that fast, constant-time implementations are easier to produce. The procedure above ensures that the same sequence of field operations is performed for all values of the secret key, thus eliminating a common source of side-channel leakage. However, this alone does not prevent all side-channels by itself. It is important that the pattern of memory accesses and jumps not depend on the values of any of the bits of k. It is also important that the arithmetic used not leak information about the integers modulo p, for example by having b*c be distinguishable from c*c. On some architectures, even primitive machine instructions, such as single-word division, can have variable timing based on their inputs.",
      "ja": "速い、一定時間の実装では、製造が容易になるように、X25519とX448が設計されています。手順は、上記フィールドの動作の同じシーケンスは、このようにサイドチャネル漏洩の共通ソースを排除する、秘密鍵のすべての値に対して実行されることを保証します。しかし、これだけでは、それ自体で、すべてのサイドチャネルを防ぐことはできません。メモリのパターンがアクセスしてkのビットのいずれかの値に依存しないジャンプことが重要です。 b *表Cは、C * Cから区別可能有することにより、例えば、使用される演算は、pを法とする整数の情報を漏洩しないことも重要です。いくつかのアーキテクチャでは、このような単一ワード部門としても、原始的な機械語命令は、それらの入力に基づいて、可変タイミングを持つことができます。"
    },
    {
      "indent": 3,
      "text": "Side-channel attacks are an active research area that still sees significant, new results. Implementors are advised to follow this research closely.",
      "ja": "サイドチャネル攻撃は、まだ重要な、新しい結果を見て、アクティブな研究分野です。実装者は密接にこの研究に従うことをお勧めします。"
    },
    {
      "indent": 0,
      "text": "5.2. Test Vectors",
      "section_title": true,
      "ja": "5.2。テストベクトル"
    },
    {
      "indent": 3,
      "text": "Two types of tests are provided. The first is a pair of test vectors for each function that consist of expected outputs for the given inputs. The inputs are generally given as 64 or 112 hexadecimal digits that need to be decoded as 32 or 56 binary bytes before processing.",
      "ja": "テストの二種類が用意されています。最初は、与えられた入力に対する期待出力から成り、各機能のためのテストベクトルのペアです。入力は、一般に、処理前に32または56バイトバイナリとしてデコードする必要が64または112の16進数として与えられます。"
    },
    {
      "indent": 3,
      "text": "X25519:",
      "ja": "X25519："
    },
    {
      "indent": 3,
      "text": "Input scalar: a546e36bf0527c9d3b16154b82465edd62144c0ac1fc5a18506a2244ba449ac4 Input scalar as a number (base 10): 31029842492115040904895560451863089656 472772604678260265531221036453811406496 Input u-coordinate: e6db6867583030db3594c1a424b15f7c726624ec26b3353b10a903a6d0ab1c4c Input u-coordinate as a number (base 10): 34426434033919594451155107781188821651 316167215306631574996226621102155684838 Output u-coordinate: c3da55379de9c6908e94ea4df28d084f32eccf03491c71f754b4075577a28552",
      "ja": "入力スカラー：数（ベース10）としてa546e36bf0527c9d3b16154b82465edd62144c0ac1fc5a18506a2244ba449ac4入力スカラー：31029842492115040904895560451863089656 472772604678260265531221036453811406496入力U座標：34426434033919594451155107781188821651 316167215306631574996226621102155684838出力U座標：c3da55379de9c6908e94ea4df28d084f32eccf03491c71f754b4075577a28552 e6db6867583030db3594c1a424b15f7c726624ec26b3353b10a903a6d0ab1c4c入力数（ベース10）のようにU座標"
    },
    {
      "indent": 3,
      "text": "Input scalar: 4b66e9d4d1b4673c5ad22691957d6af5c11b6421e0ea01d42ca4169e7918ba0d Input scalar as a number (base 10): 35156891815674817266734212754503633747 128614016119564763269015315466259359304 Input u-coordinate: e5210f12786811d3f4b7959d0538ae2c31dbe7106fc03c3efc4cd549c715a493 Input u-coordinate as a number (base 10): 88838573511839298940907593866106493194 17338800022198945255395922347792736741 Output u-coordinate: 95cbde9476e8907d7aade45cb4b873f88b595a68799fa152e6f8f7647aac7957",
      "ja": "入力スカラー：数（ベース10）として4b66e9d4d1b4673c5ad22691957d6af5c11b6421e0ea01d42ca4169e7918ba0d入力スカラー：35156891815674817266734212754503633747 128614016119564763269015315466259359304入力u座標：88838573511839298940907593866106493194 17338800022198945255395922347792736741出力U座標：95cbde9476e8907d7aade45cb4b873f88b595a68799fa152e6f8f7647aac7957 e5210f12786811d3f4b7959d0538ae2c31dbe7106fc03c3efc4cd549c715a493入力数（ベース10）のようにU座標"
    },
    {
      "indent": 3,
      "text": "X448:",
      "ja": "X448："
    },
    {
      "indent": 3,
      "text": "Input scalar: 3d262fddf9ec8e88495266fea19a34d28882acef045104d0d1aae121 700a779c984c24f8cdd78fbff44943eba368f54b29259a4f1c600ad3 Input scalar as a number (base 10): 599189175373896402783756016145213256157230856 085026129926891459468622403380588640249457727 683869421921443004045221642549886377526240828 Input u-coordinate: 06fce640fa3487bfda5f6cf2d5263f8aad88334cbd07437f020f08f9 814dc031ddbdc38c19c6da2583fa5429db94ada18aa7a7fb4ef8a086 Input u-coordinate as a number (base 10): 382239910814107330116229961234899377031416365 240571325148346555922438025162094455820962429 142971339584360034337310079791515452463053830 Output u-coordinate: ce3e4ff95a60dc6697da1db1d85e6afbdf79b50a2412d7546d5f239f e14fbaadeb445fc66a01b0779d98223961111e21766282f73dd96b6f",
      "ja": "入力スカラー：599189175373896402783756016145213256157230856 085026129926891459468622403380588640249457727 683869421921443004045221642549886377526240828 U座標入力：数（ベース10）として3d262fddf9ec8e88495266fea19a34d28882acef045104d0d1aae121 700a779c984c24f8cdd78fbff44943eba368f54b29259a4f1c600ad3入力スカラー382239910814107330116229961234899377031416365 240571325148346555922438025162094455820962429 142971339584360034337310079791515452463053830出力U座標：ce3e4ff95a60dc6697da1db1d85e6afbdf79b50a2412d7546d5f239f e14fbaadeb445fc66a01b0779d98223961111e21766282f73dd96b6f 06fce640fa3487bfda5f6cf2d5263f8aad88334cbd07437f020f08f9 814dc031ddbdc38c19c6da2583fa5429db94ada18aa7a7fb4ef8a086入力数（ベース10）のようにU座標"
    },
    {
      "indent": 3,
      "text": "Input scalar: 203d494428b8399352665ddca42f9de8fef600908e0d461cb021f8c5 38345dd77c3e4806e25f46d3315c44e0a5b4371282dd2c8d5be3095f Input scalar as a number (base 10): 633254335906970592779259481534862372382525155 252028961056404001332122152890562527156973881 968934311400345568203929409663925541994577184 Input u-coordinate: 0fbcc2f993cd56d3305b0b7d9e55d4c1a8fb5dbb52f8e9a1e9b6201b 165d015894e56c4d3570bee52fe205e28a78b91cdfbde71ce8d157db Input u-coordinate as a number (base 10): 622761797758325444462922068431234180649590390 024811299761625153767228042600197997696167956 134770744996690267634159427999832340166786063 Output u-coordinate: 884a02576239ff7a2f2f63b2db6a9ff37047ac13568e1e30fe63c4a7 ad1b3ee3a5700df34321d62077e63633c575c1c954514e99da7c179d",
      "ja": "入力スカラー：U座標633254335906970592779259481534862372382525155 252028961056404001332122152890562527156973881 968934311400345568203929409663925541994577184入力：数（ベース10）として203d494428b8399352665ddca42f9de8fef600908e0d461cb021f8c5 38345dd77c3e4806e25f46d3315c44e0a5b4371282dd2c8d5be3095f入力スカラー622761797758325444462922068431234180649590390 024811299761625153767228042600197997696167956 134770744996690267634159427999832340166786063出力U座標：884a02576239ff7a2f2f63b2db6a9ff37047ac13568e1e30fe63c4a7 ad1b3ee3a5700df34321d62077e63633c575c1c954514e99da7c179d 0fbcc2f993cd56d3305b0b7d9e55d4c1a8fb5dbb52f8e9a1e9b6201b 165d015894e56c4d3570bee52fe205e28a78b91cdfbde71ce8d157dbの入力数（ベース10）のようにU座標"
    },
    {
      "indent": 3,
      "text": "The second type of test vector consists of the result of calling the function in question a specified number of times. Initially, set k and u to be the following values:",
      "ja": "テストベクトルの第二のタイプは、質問に指定回数の関数を呼び出した結果で構成されています。当初は、Kを設定し、uは、以下の値であることが："
    },
    {
      "indent": 3,
      "text": "For X25519: 0900000000000000000000000000000000000000000000000000000000000000 For X448: 05000000000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000000000",
      "ja": "X448用0900000000000000000000000000000000000000000000000000000000000000：X25519用05000000000000000000000000000000000000000000000000000000 00000000000000000000000000000000000000000000000000000000"
    },
    {
      "indent": 3,
      "text": "For each iteration, set k to be the result of calling the function and u to be the old value of k. The final result is the value left in k.",
      "ja": "各反復のために、kの古い値とする関数を呼び出すとUの結果であるとのkを設定します。最終結果は、Kに残った値です。"
    },
    {
      "indent": 3,
      "text": "X25519:",
      "ja": "X25519："
    },
    {
      "indent": 3,
      "text": "After one iteration: 422c8e7a6227d7bca1350b3e2bb7279f7897b87bb6854b783c60e80311ae3079 After 1,000 iterations: 684cf59ba83309552800ef566f2f4d3c1c3887c49360e3875f2eb94d99532c51 After 1,000,000 iterations: 7c3911e0ab2586fd864497297e575e6f3bc601c0883c30df5f4dd2d24f665424",
      "ja": "一回の反復後：422c8e7a6227d7bca1350b3e2bb7279f7897b87bb6854b783c60e80311ae3079千回の反復後：684cf59ba83309552800ef566f2f4d3c1c3887c49360e3875f2eb94d99532c51 1,000,000回の反復後：7c3911e0ab2586fd864497297e575e6f3bc601c0883c30df5f4dd2d24f665424"
    },
    {
      "indent": 3,
      "text": "X448:",
      "ja": "X448："
    },
    {
      "indent": 3,
      "text": "After one iteration: 3f482c8a9f19b01e6c46ee9711d9dc14fd4bf67af30765c2ae2b846a 4d23a8cd0db897086239492caf350b51f833868b9bc2b3bca9cf4113 After 1,000 iterations: aa3b4749d55b9daf1e5b00288826c467274ce3ebbdd5c17b975e09d4 af6c67cf10d087202db88286e2b79fceea3ec353ef54faa26e219f38 After 1,000,000 iterations: 077f453681caca3693198420bbe515cae0002472519b3e67661a7e89 cab94695c8f4bcd66e61b9b9c946da8d524de3d69bd9d9d66b997e37",
      "ja": "3f482c8a9f19b01e6c46ee9711d9dc14fd4bf67af30765c2ae2b846a 4d23a8cd0db897086239492caf350b51f833868b9bc2b3bca9cf4113千回の反復後：：1,000,000回反復した後aa3b4749d55b9daf1e5b00288826c467274ce3ebbdd5c17b975e09d4 af6c67cf10d087202db88286e2b79fceea3ec353ef54faa26e219f38：077f453681caca3693198420bbe515cae0002472519b3e67661a7e89 cab94695c8f4bcd66e61b9b9c946da8d524de3d69bd9d9d66b997e37一回の反復の後"
    },
    {
      "indent": 0,
      "text": "6. Diffie-Hellman",
      "section_title": true,
      "ja": "6.ディフィー・ヘルマン"
    },
    {
      "indent": 0,
      "text": "6.1. Curve25519",
      "section_title": true,
      "ja": "6.1。 Curve25519"
    },
    {
      "indent": 3,
      "text": "The X25519 function can be used in an Elliptic Curve Diffie-Hellman (ECDH) protocol as follows:",
      "ja": "次のようにX25519機能は、楕円曲線ディフィ - ヘルマン（ECDH）プロトコルで使用することができます。"
    },
    {
      "indent": 3,
      "text": "Alice generates 32 random bytes in a[0] to a[31] and transmits K_A = X25519(a, 9) to Bob, where 9 is the u-coordinate of the base point and is encoded as a byte with value 9, followed by 31 zero bytes.",
      "ja": "アリスは、[31]に[0]に32のランダムバイトを生成しK_A 9は、ベース点のu座標値9のバイトとして符号化され、続いてボブへ= X25519（9）を送信します31ゼロのバイトによる。"
    },
    {
      "indent": 3,
      "text": "Bob similarly generates 32 random bytes in b[0] to b[31], computes K_B = X25519(b, 9), and transmits it to Alice.",
      "ja": "ボブは同様にBで32のランダムバイトを生成する[0] Bに[31]、K_Bは= X25519（B、9）計算し、アリスに送信します。"
    },
    {
      "indent": 3,
      "text": "Using their generated values and the received input, Alice computes X25519(a, K_B) and Bob computes X25519(b, K_A).",
      "ja": "その生成された値と受信された入力を使用して、アリスはX25519（K_B）を計算し、ボブは、X25519（B、K_A）を計算します。"
    },
    {
      "indent": 3,
      "text": "Both now share K = X25519(a, X25519(b, 9)) = X25519(b, X25519(a, 9)) as a shared secret. Both MAY check, without leaking extra information about the value of K, whether K is the all-zero value and abort if so (see below). Alice and Bob can then use a key-derivation function that includes K, K_A, and K_B to derive a symmetric key.",
      "ja": "双方は現在、K = X25519（X25519（B、9））= X25519（B、X25519（9））などの共有秘密を共有します。両方がKは、全てゼロの値であるか否かを、Kの値についての追加情報を漏洩することなく、チェックしそうであれば（下記参照）中止することができます。アリスとボブは、次に、対称鍵を導出するためにK、K_A、及びK_Bを含むキー導出関数を使用することができます。"
    },
    {
      "indent": 3,
      "text": "The check for the all-zero value results from the fact that the X25519 function produces that value if it operates on an input corresponding to a point with small order, where the order divides the cofactor of the curve (see Section 7). The check may be performed by ORing all the bytes together and checking whether the result is zero, as this eliminates standard side-channels in software implementations.",
      "ja": "それは順序が曲線の補因子を分割小さいため、との点に対応する入力で動作する場合X25519関数は、その値を生成することから、全てゼロ値の結果のチェック（セクション7参照します）。チェックは、一緒にすべてのバイトの論理和、これはソフトウェア実装において標準サイドチャネルを排除するように結果がゼロであるか否かをチェックすることによって行われてもよいです。"
    },
    {
      "indent": 3,
      "text": "Test vector:",
      "ja": "テストベクトル："
    },
    {
      "indent": 3,
      "text": "Alice's private key, a: 77076d0a7318a57d3c16c17251b26645df4c2f87ebc0992ab177fba51db92c2a Alice's public key, X25519(a, 9): 8520f0098930a754748b7ddcb43ef75a0dbf3a0d26381af4eba4a98eaa9b4e6a Bob's private key, b: 5dab087e624a8a4b79e17f8b83800ee66f3bb1292618b6fd1c2f8b27ff88e0eb Bob's public key, X25519(b, 9): de9edb7d7b7dc1b4d35b61c2ece435373f8343c85b78674dadfc7e146f882b4f Their shared secret, K: 4a5d9d5ba4ce2de1728e3bf480350f25e07e21c947d19e3376f09b3c1e161742",
      "ja": "アリスの秘密鍵、：77076d0a7318a57d3c16c17251b26645df4c2f87ebc0992ab177fba51db92c2aアリスの公開鍵、X25519（9）：8520f0098930a754748b7ddcb43ef75a0dbf3a0d26381af4eba4a98eaa9b4e6aボブの秘密鍵、B：5dab087e624a8a4b79e17f8b83800ee66f3bb1292618b6fd1c2f8b27ff88e0ebボブの公開鍵、X25519（B、9）：彼らの共有秘密、K de9edb7d7b7dc1b4d35b61c2ece435373f8343c85b78674dadfc7e146f882b4f：4a5d9d5ba4ce2de1728e3bf480350f25e07e21c947d19e3376f09b3c1e161742"
    },
    {
      "indent": 0,
      "text": "6.2. Curve448",
      "section_title": true,
      "ja": "6.2。 Curve448"
    },
    {
      "indent": 3,
      "text": "The X448 function can be used in an ECDH protocol very much like the X25519 function.",
      "ja": "X448の機能は非常にX25519機能などのECDHプロトコルで使用することができます。"
    },
    {
      "indent": 3,
      "text": "If X448 is to be used, the only differences are that Alice and Bob generate 56 random bytes (not 32) and calculate K_A = X448(a, 5) or K_B = X448(b, 5), where 5 is the u-coordinate of the base point and is encoded as a byte with value 5, followed by 55 zero bytes.",
      "ja": "X448を使用する場合、唯一の違いは、アリスとボブが56ランダムバイト（不32）を生成し、5がU座標K_A = X448（5）又はK_B = X448（B、5）、計算することです基点の55ゼロバイトに続く値5とバイトとして符号化されます。"
    },
    {
      "indent": 3,
      "text": "As with X25519, both sides MAY check, without leaking extra information about the value of K, whether the resulting shared K is the all-zero value and abort if so.",
      "ja": "X25519と同様に、両側は、得られる共有Kは、全てゼロの値であり、そうであれば中断するかどうか、Kの値についての追加情報を漏洩することなく、確認することができます。"
    },
    {
      "indent": 3,
      "text": "Test vector:",
      "ja": "テストベクトル："
    },
    {
      "indent": 3,
      "text": "Alice's private key, a: 9a8f4925d1519f5775cf46b04b5800d4ee9ee8bae8bc5565d498c28d d9c9baf574a9419744897391006382a6f127ab1d9ac2d8c0a598726b Alice's public key, X448(a, 5): 9b08f7cc31b7e3e67d22d5aea121074a273bd2b83de09c63faa73d2c 22c5d9bbc836647241d953d40c5b12da88120d53177f80e532c41fa0 Bob's private key, b: 1c306a7ac2a0e2e0990b294470cba339e6453772b075811d8fad0d1d 6927c120bb5ee8972b0d3e21374c9c921b09d1b0366f10b65173992d Bob's public key, X448(b, 5): 3eb7a829b0cd20f5bcfc0b599b6feccf6da4627107bdb0d4f345b430 27d8b972fc3e34fb4232a13ca706dcb57aec3dae07bdc1c67bf33609 Their shared secret, K: 07fff4181ac6cc95ec1c16a94a0f74d12da232ce40a77552281d282b b60c0b56fd2464c335543936521c24403085d59a449a5037514a879d",
      "ja": "アリスの秘密鍵、：9a8f4925d1519f5775cf46b04b5800d4ee9ee8bae8bc5565d498c28d d9c9baf574a9419744897391006382a6f127ab1d9ac2d8c0a598726bアリスの公開鍵、X448（5）：9b08f7cc31b7e3e67d22d5aea121074a273bd2b83de09c63faa73d2c 22c5d9bbc836647241d953d40c5b12da88120d53177f80e532c41fa0ボブの秘密鍵、B：6927c120bb5ee8972b0d3e21374c9c921b09d1b0366f10b65173992dボブの公開鍵を1c306a7ac2a0e2e0990b294470cba339e6453772b075811d8fad0d1d、X448（B、5）：3eb7a829b0cd20f5bcfc0b599b6feccf6da4627107bdb0d4f345b430 27d8b972fc3e34fb4232a13ca706dcb57aec3dae07bdc1c67bf33609彼らの共有秘密、K：07fff4181ac6cc95ec1c16a94a0f74d12da232ce40a77552281d282b b60c0b56fd2464c335543936521c24403085d59a449a5037514a879d"
    },
    {
      "indent": 0,
      "text": "7. Security Considerations",
      "section_title": true,
      "ja": "7.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "The security level (i.e., the number of \"operations\" needed for a brute-force attack on a primitive) of curve25519 is slightly under the standard 128-bit level. This is acceptable because the standard security levels are primarily driven by much simpler, symmetric primitives where the security level naturally falls on a power of two. For asymmetric primitives, rigidly adhering to a power-of-two security level would require compromises in other parts of the design, which we reject. Additionally, comparing security levels between types of primitives can be misleading under common threat models where multiple targets can be attacked concurrently [bruteforce].",
      "ja": "セキュリティレベル（すなわち、プリミティブにブルートフォース攻撃のために必要な「操作」の数）curve25519のは、標準的な128ビットのレベルの下にわずかです。標準的なセキュリティレベルは、主にセキュリティレベルが自然に2のべき乗に落ちるずっと単純、対称プリミティブによって駆動されるので、これは許容可能です。非対称プリミティブについて、厳格に2のべき乗のセキュリティレベルに付着することは、我々が拒否し、デザインの他の部分で妥協が必要となります。さらに、プリミティブのタイプの間のセキュリティレベルを比較すると、複数のターゲットを同時に[ブルートフォース】攻撃することができる一般的な脅威モデルの下で、誤解を招くことができます。"
    },
    {
      "indent": 3,
      "text": "The ~224-bit security level of curve448 is a trade-off between performance and paranoia. Large quantum computers, if ever created, will break both curve25519 and curve448, and reasonable projections of the abilities of classical computers conclude that curve25519 is perfectly safe. However, some designs have relaxed performance requirements and wish to hedge against some amount of analytical advance against elliptic curves and thus curve448 is also provided.",
      "ja": "curve448の〜224ビットのセキュリティレベルは、パフォーマンスと妄想の間のトレードオフです。大規模な量子コンピュータは、これまでに作成した場合、curve25519とcurve448の両方を破るだろう、と古典コンピュータの能力の合理的な予測はcurve25519が完全に安全であると結論付けています。しかし、いくつかの設計では、性能要件を緩和し、楕円曲線に対する分析、事前のいくつかの量をヘッジしたいので、curve448も提供されています。"
    },
    {
      "indent": 3,
      "text": "Protocol designers using Diffie-Hellman over the curves defined in this document must not assume \"contributory behaviour\". Specially, contributory behaviour means that both parties' private keys contribute to the resulting shared key. Since curve25519 and curve448 have cofactors of 8 and 4 (respectively), an input point of small order will eliminate any contribution from the other party's private key. This situation can be detected by checking for the all-zero output, which implementations MAY do, as specified in Section 6. However, a large number of existing implementations do not do this.",
      "ja": "この文書で定義された曲線上のDiffie-Hellmanのを使用してプロトコルの設計者は、「寄与行動」を仮定してはいけません。特に、拠出挙動は、両方の当事者の秘密鍵が生成された共有キーに寄与することを意味します。 curve25519とcurve448が8と4（それぞれ）の補因子を持っているので、小さなオーダーの入力点は、他の当事者の秘密鍵からの寄与を除去することができます。しかし、第6節で指定されている。このような状況は、実装が行う可能性のあるすべてのゼロ出力、をチェックすることにより検出することができ、既存の実装の多くはこれをしません。"
    },
    {
      "indent": 3,
      "text": "Designers using these curves should be aware that for each public key, there are several publicly computable public keys that are equivalent to it, i.e., they produce the same shared secrets. Thus using a public key as an identifier and knowledge of a shared secret as proof of ownership (without including the public keys in the key derivation) might lead to subtle vulnerabilities.",
      "ja": "これらの曲線を使用する設計者は、すなわち、彼らは同じ共有秘密を生成、各公開鍵のために、それに相当しているいくつかの公的に計算公開鍵があることに注意する必要があります。したがって微妙な脆弱性につながる可能性識別子と所有権の証拠として（鍵導出に公開鍵を含めずに）共有の秘密の知識として公開鍵を使用して。"
    },
    {
      "indent": 3,
      "text": "Designers should also be aware that implementations of these curves might not use the Montgomery ladder as specified in this document, but could use generic, elliptic-curve libraries instead. These implementations could reject points on the twist and could reject non-minimal field elements. While not recommended, such implementations will interoperate with the Montgomery ladder specified here but may be trivially distinguishable from it. For example, sending a non-canonical value or a point on the twist may cause such implementations to produce an observable error while an implementation that follows the design in this text would successfully produce a shared key.",
      "ja": "また、設計者は、この文書で指定されているこれらの曲線の実装はモンゴメリーのはしごを使用しない可能性があることを認識する必要がありますが、その代わりに、一般的な、楕円曲線のライブラリを使用することができます。これらの実装は、ツイスト上の点を拒否可能性があり、非最小限のフィールド要素を拒否することができます。推奨されていないが、そのような実装は、ここで指定されたモンゴメリラダーと相互運用しますが、それから自明区別できるかもしれません。例えば、ねじれに非標準値またはポイントを送信することは、このテキストで設計を以下の実装がうまく共有鍵を生成するが、このような実装が観察エラーを生成させてもよいです。"
    },
    {
      "indent": 0,
      "text": "8. References",
      "section_title": true,
      "ja": "8.参照文献"
    },
    {
      "indent": 0,
      "text": "8.1. Normative References",
      "section_title": true,
      "ja": "8.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<http://www.rfc-editor.org/info/ RFC2119>。"
    },
    {
      "indent": 0,
      "text": "8.2. Informative References",
      "section_title": true,
      "ja": "8.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[brainpool] ECC Brainpool, \"ECC Brainpool Standard Curves and Curve Generation\", October 2005, <http://www.ecc-brainpool.org/download/ Domain-parameters.pdf>.",
      "ja": "[brainpool] ECC Brainpool、 \"ECC Brainpool標準曲線と曲線の生成\"、2005年10月、<http://www.ecc-brainpool.org/download/ドメインparameters.pdf>。"
    },
    {
      "indent": 3,
      "text": "[bruteforce] Bernstein, D., \"Understanding brute force\", April 2005, <http://cr.yp.to/snuffle/bruteforce-20050425.pdf>.",
      "ja": "[ブルートフォース]バーンスタイン、D.、 \"ブルートフォースの理解\" を、2005年4月、<http://cr.yp.to/snuffle/bruteforce-20050425.pdf>。"
    },
    {
      "indent": 3,
      "text": "[curve25519] Bernstein, D., \"Curve25519: new Diffie-Hellman speed records\", 2006, <http://www.iacr.org/cryptodb/archive/2006/ PKC/3351/3351.pdf>.",
      "ja": "[curve25519]バーンスタイン、D.、 \"Curve25519：新しいDiffie-Hellman速記録\"、2006年、<http://www.iacr.org/cryptodb/archive/2006/ PKC / 3351 / 3351.pdf>。"
    },
    {
      "indent": 3,
      "text": "[ed25519] Bernstein, D., Duif, N., Lange, T., Schwabe, P., and B. Yang, \"High-Speed High-Security Signatures\", 2011, <http://link.springer.com/ chapter/10.1007/978-3-642-23951-9_9>.",
      "ja": "[ed25519]バーンスタイン、D.、ダイフ、N.、ランゲ、T.、シュワーベ、P.、およびB.ヤン、 \"高速高セキュリティ署名\"、2011年、<http://link.springer.com /チャプター/ 10.1007 / 978-3-642-23951-9_9>。"
    },
    {
      "indent": 3,
      "text": "[goldilocks] Hamburg, M., \"Ed448-Goldilocks, a new elliptic curve\", 2015, <http://eprint.iacr.org/2015/625.pdf>.",
      "ja": "【びき]ハンブルグ、M.、 \"Ed448-びき、新しい楕円曲線\" 2015年、<http://eprint.iacr.org/2015/625.pdf>。"
    },
    {
      "indent": 3,
      "text": "[montgomery] Montgomery, P., \"Speeding the Pollard and Elliptic Curve Methods of Factorization\", January 1987, <http://www.ams.org/journals/mcom/1987-48-177/ S0025-5718-1987-0866113-7/S0025-5718-1987-0866113-7.pdf>.",
      "ja": "[モンゴメリー]モンゴメリー、P.、「因数分解のポラードと楕円曲線法を高速化」、1987年1月、<http://www.ams.org/journals/mcom/1987-48-177/ S0025-5718-1987- 0866113から7 / S0025-5718-1987-0866113-7.pdf>。"
    },
    {
      "indent": 3,
      "text": "[NIST] National Institute of Standards, \"Recommended Elliptic Curves for Federal Government Use\", July 1999, <http://csrc.nist.gov/groups/ST/toolkit/documents/dss/ NISTReCur.pdf>.",
      "ja": "標準の[NIST]国立研究所、「連邦政府における推奨楕円曲線」、1999年7月、<http://csrc.nist.gov/groups/ST/toolkit/documents/dss/ NISTReCur.pdf>。"
    },
    {
      "indent": 3,
      "text": "[reducing] Menezes, A., Okamoto, T., and S. Vanstone, \"Reducing elliptic curve logarithms to logarithms in a finite field\", DOI 10.1109/18.259647, 1993, <http://ieeexplore.ieee.org/xpl/ articleDetails.jsp?arnumber=259647>.",
      "ja": "[還元]メネゼス、A.、岡本、T.、およびS. Vanstone著、 \"有限体に対数に楕円曲線対数を削減\"、DOI 10.1109 / 18.259647、1993、<http://ieeexplore.ieee.org/xpl / articleDetails.jsp？arnumber = 259647>。"
    },
    {
      "indent": 3,
      "text": "[RFC6090] McGrew, D., Igoe, K., and M. Salter, \"Fundamental Elliptic Curve Cryptography Algorithms\", RFC 6090, DOI 10.17487/RFC6090, February 2011, <http://www.rfc-editor.org/info/rfc6090>.",
      "ja": "[RFC6090]マグリュー、D.、Igoe、K.、およびM.ソルター、 \"基礎楕円曲線暗号アルゴリズム\"、RFC 6090、DOI 10.17487 / RFC6090、2011年2月、<http://www.rfc-editor.org/情報/ rfc6090>。"
    },
    {
      "indent": 3,
      "text": "[safecurves] Bernstein, D. and T. Lange, \"SafeCurves: choosing safe curves for elliptic-curve cryptography\", Oct 2013, <http://safecurves.cr.yp.to/>.",
      "ja": "【safecurves】バーンスタイン、D.およびT.ランゲ、「SafeCurves：楕円曲線暗号のための安全な曲線を選択する」、2013年10月、<http://safecurves.cr.yp.to/>。"
    },
    {
      "indent": 3,
      "text": "[satoh] Satoh, T. and K. Araki, \"Fermat quotients and the polynomial time discrete log algorithm for anomalous elliptic curves\", 1998.",
      "ja": "[佐藤]佐藤、T.及びK.荒木、「フェルマー商と異常楕円曲線のための多項式時間離散対数アルゴリズム」、1998。"
    },
    {
      "indent": 3,
      "text": "[SEC1] Certicom Research, \"SEC 1: Elliptic Curve Cryptography\", September 2000, <http://www.secg.org/sec1-v2.pdf>.",
      "ja": "[SEC1] Certicomの研究、 \"SEC 1：楕円曲線暗号\"、2000年9月、<http://www.secg.org/sec1-v2.pdf>。"
    },
    {
      "indent": 3,
      "text": "[semaev] Semaev, I., \"Evaluation of discrete logarithms on some elliptic curves\", 1998, <http://www.ams.org/journals/ mcom/1998-67-221/S0025-5718-98-00887-4/ S0025-5718-98-00887-4.pdf>.",
      "ja": "【semaev] Semaev、I.、 \"いくつかの楕円曲線上の離散対数の評価\"、1998、<http://www.ams.org/journals/ MCOM / 1998-67-221 / S0025-5718-98-00887- 4 / S0025-5718-98-00887-4.pdf>。"
    },
    {
      "indent": 3,
      "text": "[smart] Smart, N., \"The Discrete Logarithm Problem on Elliptic Curves of Trace One\", 1999, <http://www.hpl.hp.com/techreports/97/HPL-97-128.pdf>.",
      "ja": "[スマート]スマート、N.、<http://www.hpl.hp.com/techreports/97/HPL-97-128.pdf>、1999年、「トレース一つの楕円曲線上の離散対数問題」。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Deterministic Generation",
      "ja": "付録A.決定論ジェネレーション"
    },
    {
      "indent": 3,
      "text": "This section specifies the procedure that was used to generate the above curves; specifically, it defines how to generate the parameter A of the Montgomery curve y^2 = x^3 + A*x^2 + x. This procedure is intended to be as objective as can reasonably be achieved so that it's clear that no untoward considerations influenced the choice of curve. The input to this process is p, the prime that defines the underlying field. The size of p determines the amount of work needed to compute a discrete logarithm in the elliptic curve group, and choosing a precise p depends on many implementation concerns. The performance of the curve will be dominated by operations in GF(p), so carefully choosing a value that allows for easy reductions on the intended architecture is critical. This document does not attempt to articulate all these considerations.",
      "ja": "このセクションでは、上記曲線を生成するために使用された手順を指定します。具体的には、モンゴメリ曲線y ^ 2 = X ^ 3 + A * X ^ 2 + xのパラメータAを生成する方法を定義します。この手順は、それは厄介な考慮事項は、曲線の選択に影響を与えないことは明らかだように、合理的に達成可能な限り客観的であることを意図しています。このプロセスへの入力は、p、基になるフィールドを定義する素数です。 Pの大きさは、楕円曲線群における離散対数を計算するのに必要な作業の量を決定し、かつ正確Pを選択することは、多くの実装上の問題に依存します。曲線のパフォーマンスはとても慎重に意図されたアーキテクチャ上で簡単に削減することができます値を選択、GF（p）の中での操作によって支配される非常に重要です。この文書では、これらすべての考慮事項を明確にしようとしません。"
    },
    {
      "indent": 3,
      "text": "The value (A-2)/4 is used in several of the elliptic curve point arithmetic formulas. For simplicity and performance reasons, it is beneficial to make this constant small, i.e., to choose A so that (A-2) is a small integer that is divisible by four.",
      "ja": "値（A-2）/ 4楕円曲線点演算式のいくつかで使用されています。単純さとパフォーマンスの理由から、それは、これが一定小さくすることが有益である、すなわち、そのように（A-2）を選択すると、4で割り切れる小さい整数です。"
    },
    {
      "indent": 3,
      "text": "For each curve at a specific security level:",
      "ja": "特定のセキュリティレベルでの各曲線の場合："
    },
    {
      "indent": 3,
      "text": "1. The trace of Frobenius MUST NOT be in {0, 1} in order to rule out the attacks described in [smart], [satoh], and [semaev], as in [brainpool] and [safecurves].",
      "ja": "1フロベニウスのトレースは、[スマート]に記載の攻撃を排除するために、[佐藤]、および[semaev]、[brainpool]および[safecurves]と{1,0}にあってはなりません。"
    },
    {
      "indent": 3,
      "text": "2. MOV Degree [reducing]: the embedding degree MUST be greater than (order - 1) / 100, as in [brainpool] and [safecurves].",
      "ja": "2. MOV度[還元]：埋め込み次数は（順 -  1）よりも大きくなければならない[safecurves] [brainpool]におけるとして、/ 100。"
    },
    {
      "indent": 3,
      "text": "3. CM Discriminant: discriminant D MUST be greater than 2^100, as in [safecurves].",
      "ja": "3. CM判別：判別式Dが[safecurves]のように、^ 100 2よりも大きくなければなりません。"
    },
    {
      "indent": 0,
      "text": "A.1. p = 1 mod 4",
      "ja": "A.1。 P = 1つのMOD 4"
    },
    {
      "indent": 3,
      "text": "For primes congruent to 1 mod 4, the minimal cofactors of the curve and its twist are either {4, 8} or {8, 4}. We choose a curve with the latter cofactors so that any algorithms that take the cofactor into account don't have to worry about checking for points on the twist, because the twist cofactor will be the smaller of the two.",
      "ja": "1つのMOD 4と合同素数のために、曲線とそのねじれの最小補因子は、{4,8}または{8,4}のいずれかです。アカウントに補因子を取る任意のアルゴリズムは、ツイスト補因子は、2つの小さい方になりますので、ツイスト上の点をチェック心配する必要がないように私たちは後者の補因子でカーブを選択してください。"
    },
    {
      "indent": 3,
      "text": "To generate the Montgomery curve, we find the minimal, positive A value such that A > 2 and (A-2) is divisible by four and where the cofactors are as desired. The find1Mod4 function in the following Sage script returns this value given p:",
      "ja": "モンゴメリ曲線を生成するために、我々は最小の正の値を見つけるA> 2及び（A-2）は、4つおよび補因子が所望されるで割り切れるようになっています。次セージスクリプト内find1Mod4機能は、p与えられ、この値を返します。"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS> def findCurve(prime, curveCofactor, twistCofactor): F = GF(prime)",
      "ja": "F = GF（プライム）：DEF findCurve（プライム、curveCofactor、twistCofactor）<CODEが始まります>"
    },
    {
      "indent": 7,
      "text": "for A in xrange(3, int(1e9)):\n    if (A-2) % 4 != 0:\n      continue",
      "raw": true
    },
    {
      "indent": 11,
      "text": "try:\n  E = EllipticCurve(F, [0, A, 0, 1, 0])\nexcept:\n  continue",
      "raw": true
    },
    {
      "indent": 11,
      "text": "groupOrder = E.order() twistOrder = 2*(prime+1)-groupOrder",
      "ja": "groupOrder = E.order（）twistOrder = 2 *（プライム+ 1）-groupOrder"
    },
    {
      "indent": 11,
      "text": "if (groupOrder % curveCofactor == 0 and is_prime(groupOrder // curveCofactor) and twistOrder % twistCofactor == 0 and is_prime(twistOrder // twistCofactor)): return A",
      "ja": "（groupOrder％curveCofactor == 0とis_prime（groupOrder // curveCofactor）とtwistOrder％twistCofactor == 0とis_prime（twistOrder // twistCofactor））の場合：戻ります"
    },
    {
      "indent": 3,
      "text": "def find1Mod4(prime): assert((prime % 4) == 1) return findCurve(prime, 8, 4) <CODE ENDS>",
      "ja": "DEF find1Mod4（プライム）：アサート（（プライム％4）== 1）findCurveを返す（プライム、8、4）<CODEを終了します>"
    },
    {
      "indent": 19,
      "text": "Generating a curve where p = 1 mod 4",
      "ja": "P = 1つのMOD 4曲線を生成します"
    },
    {
      "indent": 0,
      "text": "A.2. p = 3 mod 4",
      "ja": "A.2。 P = 3 MOD 4"
    },
    {
      "indent": 3,
      "text": "For a prime congruent to 3 mod 4, both the curve and twist cofactors can be 4, and this is minimal. Thus, we choose the curve with these cofactors and minimal, positive A such that A > 2 and (A-2) is divisible by four. The find3Mod4 function in the following Sage script returns this value given p:",
      "ja": "3 MOD 4にプライム合同のために、両方の曲線とねじれ補因子が4であることができ、これは最小です。したがって、我々はこれらの補因子の曲線を選択し、最小の正のようにA> 2及び（A-2）は、4で割り切れます。次セージスクリプト内find3Mod4機能は、p与えられ、この値を返します。"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS> def find3Mod4(prime): assert((prime % 4) == 3) return findCurve(prime, 4, 4) <CODE ENDS>",
      "ja": "DEF find3Mod4（プライム）<CODEが始まる>：<CODEが終了>（4、プライム、4）findCurveを返す（（プライム％4）== 3）をアサート"
    },
    {
      "indent": 19,
      "text": "Generating a curve where p = 3 mod 4",
      "ja": "P = 3 MOD 4曲線を生成します"
    },
    {
      "indent": 0,
      "text": "A.3. Base Points",
      "ja": "A.3。ベースポイント"
    },
    {
      "indent": 3,
      "text": "The base point for a curve is the point with minimal, positive u value that is in the correct subgroup. The findBasepoint function in the following Sage script returns this value given p and A:",
      "ja": "曲線の基点は、正しいサブグループである最小の正のU値を持つ点です。次セージスクリプト内findBasepoint機能はpとA与えられ、この値を返します。"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS> def findBasepoint(prime, A): F = GF(prime) E = EllipticCurve(F, [0, A, 0, 1, 0])",
      "ja": "F = GF（プライム）E = EllipticCurve（F、[0、A、0、1、0]）：DEF findBasepoint（プライム、A）<CODEが始まります>"
    },
    {
      "indent": 7,
      "text": "for uInt in range(1, 1e3):\n  u = F(uInt)\n  v2 = u^3 + A*u^2 + u\n  if not v2.is_square():\n    continue\n  v = v2.sqrt()",
      "raw": true
    },
    {
      "indent": 3,
      "text": " point = E(u, v) pointOrder = point.order() if pointOrder > 8 and pointOrder.is_prime(): return point <CODE ENDS>",
      "ja": "点E =（U、V）pointOrder = point.order（）pointOrder> 8とpointOrder.is_prime（）場合：戻り点<CODEが終了>"
    },
    {
      "indent": 25,
      "text": "Generating the base point",
      "ja": "基点の生成"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "This document is the result of a combination of draft-black-rpgecc-01 and draft-turner-thecurve25519function-01. The following authors of those documents wrote much of the text and figures but are not listed as authors on this document: Benjamin Black, Joppe W. Bos, Craig Costello, Patrick Longa, Michael Naehrig, Watson Ladd, and Rich Salz.",
      "ja": "この文書は、ドラフトブラックrpgecc-01及びドラフトターナーthecurve25519function-01の組み合わせの結果です。それらの文書の次の著者は、テキストや図形の多くを書いたが、この文書の著者として記載されていない：ベンジャミン・ブラック、Joppe W.ボス、クレイグ・コステロ、パトリック・ロンガ、マイケルNaehrig、ワトソンラッド、およびリッチ・サルズ。"
    },
    {
      "indent": 3,
      "text": "The authors would also like to thank Tanja Lange, Rene Struik, Rich Salz, Ilari Liusvaara, Deirdre Connolly, Simon Josefsson, Stephen Farrell, Georg Nestmann, Trevor Perrin, and John Mattsson for their reviews and contributions.",
      "ja": "著者はまた、彼らのレビューと貢献のためのターニャ・ラング、ルネStruik、リッチ・サルズ、Ilari Liusvaara、ディアドラ・コノリー、サイモンJosefsson氏、スティーブン・ファレル、ゲオルクNestmann、トレバー・ペラン、そしてジョン・マットソンに感謝したいと思います。"
    },
    {
      "indent": 3,
      "text": "The X25519 function was developed by Daniel J. Bernstein in [curve25519].",
      "ja": "【curve25519]でX25519機能はダニエル・バーンスタインによって開発されました。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Adam Langley Google 345 Spear Street San Francisco, CA 94105 United States",
      "ja": "アダム・ラングレーGoogleの345スピアストリートサンフランシスコ、CA 94105米国"
    },
    {
      "indent": 3,
      "text": "Email: agl@google.com",
      "ja": "メール：agl@google.com"
    },
    {
      "indent": 3,
      "text": "Mike Hamburg Rambus Cryptography Research 425 Market Street, 11th Floor San Francisco, CA 94105 United States",
      "ja": "マイク・ハンブルクラムバス暗号技術425マーケットストリート、11階サンフランシスコ、CA 94105米国"
    },
    {
      "indent": 3,
      "text": "Email: mike@shiftleft.org",
      "ja": "メール：mike@shiftleft.org"
    },
    {
      "indent": 3,
      "text": "Sean Turner sn3rd",
      "ja": "ショーン・ターナーsn3rd"
    },
    {
      "indent": 3,
      "text": "Email: sean@sn3rd.com",
      "ja": "メール：sean@sn3rd.com"
    }
  ]
}