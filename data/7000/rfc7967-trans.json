{
  "title": {
    "text": "RFC 7967 - Constrained Application Protocol (CoAP) Option for No Server Response",
    "ja": "RFC 7967 - 制約アプリケーションプロトコル（CoAP）いいえサーバーの応答をオプション"
  },
  "number": 7967,
  "created_at": "2019-11-02 19:19:53.226509+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Independent Submission                                  A. Bhattacharyya\nRequest for Comments: 7967                              S. Bandyopadhyay\nCategory: Informational                                           A. Pal\nISSN: 2070-1721                                                  T. Bose\n                                          Tata Consultancy Services Ltd.\n                                                             August 2016",
      "raw": true
    },
    {
      "indent": 1,
      "text": "Constrained Application Protocol (CoAP) Option for No Server Response",
      "ja": "制約アプリケーションプロトコル（CoAP）いいえサーバーの応答をオプション"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "There can be machine-to-machine (M2M) scenarios where server responses to client requests are redundant. This kind of open-loop exchange (with no response path from the server to the client) may be desired to minimize resource consumption in constrained systems while updating many resources simultaneously or performing high-frequency updates. CoAP already provides Non-confirmable (NON) messages that are not acknowledged by the recipient. However, the request/response semantics still require the server to respond with a status code indicating \"the result of the attempt to understand and satisfy the request\", per RFC 7252.",
      "ja": "クライアントの要求に対するサーバの応答が重複しているマシン・ツー・マシン（M2M）のシナリオが存在する場合があります。 （サーバからクライアントへの応答がない経路で）開ループ交換のこの種は、同時に多くのリソースを更新するか、高周波数の更新を行いながら拘束システムのリソース消費を最小化することが望ましいです。 CoAPは、すでに受信者によって確認されていない非確認できる（NON）メッセージを提供します。しかし、要求/応答セマンティクスはまだRFC 7252ごとに、「要求を理解し、満足しようとする試みの結果」を示すステータスコードで応答するサーバーが必要です。"
    },
    {
      "indent": 3,
      "text": "This specification introduces a CoAP option called 'No-Response'. Using this option, the client can explicitly express to the server its disinterest in all responses against the particular request. This option also provides granular control to enable expression of disinterest to a particular response class or a combination of response classes. The server MAY decide to suppress the response by not transmitting it back to the client according to the value of the No-Response option in the request. This option may be effective for both unicast and multicast requests. This document also discusses a few examples of applications that benefit from this option.",
      "ja": "この仕様は、「無応答」と呼ばれていないCoAPオプションを紹介します。このオプションを使用すると、クライアントが明示的に特定の要求に対するすべての応答で、サーバーへの無関心を表現することができます。このオプションは、特定の応答クラスまたは応答のクラスの組み合わせに無関心の発現を可能にするために、きめ細かな制御を提供します。サーバーは、要求で無応答オプションの値に応じて、それをクライアントに戻って送信しないことによって応答を抑制するように決定することができます。このオプションは、ユニキャストとマルチキャストの両方の要求に対して有効です。このドキュメントには、このオプションの恩恵を受けるアプリケーションのいくつかの例を説明します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "ja": "このドキュメントはインターネット標準化過程仕様ではありません。それは、情報提供の目的のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This is a contribution to the RFC Series, independently of any other RFC stream. The RFC Editor has chosen to publish this document at its discretion and makes no statement about its value for implementation or deployment. Documents approved for publication by the RFC Editor are not a candidate for any level of Internet Standard; see Section 2 of RFC 7841.",
      "ja": "これは、独立して、他のRFCストリームの、RFCシリーズへの貢献です。 RFC Editorはその裁量でこの文書を公開することを選択し、実装や展開のためにその値についての声明を出すていません。 RFC編集者によって公表のために承認されたドキュメントは、インターネット標準の任意のレベルの候補ではありません。 RFC 7841のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7967.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7967で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2016 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2016 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................3\n   1.1. Potential Benefits .........................................4\n   1.2. Terminology ................................................4\n2. Option Definition ...............................................5\n   2.1. Granular Control over Response Suppression .................5\n   2.2. Method-Specific Applicability Considerations ...............8\n3. Miscellaneous Aspects ...........................................9\n   3.1. Reusing Tokens .............................................9\n   3.2. Taking Care of Congestion Control and Server-Side\n        Flow Control ..............................................10\n   3.3. Considerations regarding Caching of Responses .............11\n   3.4. Handling the No-Response Option for a HTTP-to-CoAP\n        Reverse Proxy .............................................11\n4. Application Scenarios ..........................................12\n   4.1. Frequent Update of Geolocation from Vehicles to\n        Backend Server ............................................12\n        4.1.1. Using No-Response with PUT .........................13\n        4.1.2. Using No-Response with POST ........................14\n               4.1.2.1. POST Updating a Fixed Target Resource .....14\n               4.1.2.2. POST Updating through Query String ........15\n   4.2. Multicasting Actuation Command from a Handheld Device\n        to a Group of Appliances ..................................15\n        4.2.1. Using Granular Response Suppression ................16\n5. IANA Considerations ............................................16\n6. Security Considerations ........................................16\n7. References .....................................................16\n   7.1. Normative References ......................................16\n   7.2. Informative References ....................................17\nAcknowledgments ...................................................18\nAuthors' Addresses ................................................18",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "This specification defines a new option for the Constrained Application Protocol (CoAP) [RFC7252] called 'No-Response'. This option enables clients to explicitly express their disinterest in receiving responses back from the server. The disinterest can be expressed at the granularity of response classes (e.g., 2.xx) or a combination of classes (e.g., 2.xx and 5.xx). By default, this option indicates interest in all response classes. The server MAY decide to suppress the response by not transmitting it back to the client according to the value of the No-Response option in the request.",
      "ja": "この仕様は、「無応答」と呼ばれていない制約アプリケーションプロトコル（CoAP）[RFC7252]のための新しいオプションを定義します。このオプションは、明示的にサーバーからの応答を受信して​​自分の無関心を表現するために、クライアントを可能にします。無関心は、応答クラス（例えば、2.xxの）またはクラス（例えば、2.xxのと5.XX）の組み合わせの単位で表すことができます。デフォルトでは、このオプションは、すべての応答クラスに関心を示しています。サーバーは、要求で無応答オプションの値に応じて、それをクライアントに戻って送信しないことによって応答を抑制するように決定することができます。"
    },
    {
      "indent": 3,
      "text": "Along with the technical details, this document presents some practical application scenarios that highlight the usefulness of this option. [ITS-LIGHT] and [CoAP-ADAPT] contain the background research for this document.",
      "ja": "技術的な詳細とともに、この文書では、このオプションの有用性を強調いくつかの実用的なアプリケーションシナリオを提示します。 [ITS-LIGHT]と[CoAP-ADAPT]は、この文書の背景研究が含まれています。"
    },
    {
      "indent": 3,
      "text": "In this document, when it is mentioned that a request from a client is with No-Response, the intended meaning is that the client expresses its disinterest for all or some selected classes of responses.",
      "ja": "クライアントからの要求が無反応であることを言及する場合、この文書では、意図した意味は、クライアントは応答の全部または一部の選択したクラスのためにその無関心を表現するということです。"
    },
    {
      "indent": 0,
      "text": "1.1. Potential Benefits",
      "section_title": true,
      "ja": "1.1. 潜在的な利点"
    },
    {
      "indent": 3,
      "text": "The use of the No-Response option should be driven by typical application requirements and, particularly, characteristics of the information to be updated. If this option is opportunistically used in a fitting M2M application, then the concerned system may benefit in the following aspects. (However, note that this option is elective, and servers can simply ignore the preference expressed by the client.)",
      "ja": "無応答オプションの使用は、特に、情報の特性が更新される典型的なアプリケーションの要件と、によって駆動されなければなりません。このオプションは日和見フィッティングM2Mのアプリケーションで使用される場合、当該システムは、以下の態様で利益を得ることができます。 （ただし、このオプションは選択科目で、サーバは単にクライアントによって表現好みを無視することができることに注意してください。）"
    },
    {
      "indent": 6,
      "text": "* Reduction in network congestion due to effective reduction of the overall traffic.",
      "ja": "*トラフィック全体の効果的な減少によるネットワークの混雑の削減。"
    },
    {
      "indent": 6,
      "text": "* Reduction in server-side load by relieving the server from responding to requests for which responses are not necessary.",
      "ja": "*応答は必要のないもの要求に応答からサーバーを軽減することにより、サーバ側の負荷軽減。"
    },
    {
      "indent": 6,
      "text": "* Reduction in battery consumption at the constrained endpoint(s).",
      "ja": "*制約エンドポイント（複数可）でのバッテリ消費の削減。"
    },
    {
      "indent": 6,
      "text": "* Reduction in overall communication cost.",
      "ja": "*全体的な通信コストの削減。"
    },
    {
      "indent": 0,
      "text": "1.2. Terminology",
      "section_title": true,
      "ja": "1.2. 用語"
    },
    {
      "indent": 3,
      "text": "The terms used in this document are in conformance with those defined in [RFC7252].",
      "ja": "本書で使用される用語は、[RFC7252]で定義されたものに準拠しています。"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はあります[RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "2. Option Definition",
      "section_title": true,
      "ja": "2.オプション定義"
    },
    {
      "indent": 3,
      "text": "The properties of the No-Response option are given in Table 1. In this table, the C, U, N, and R columns indicate the properties Critical, Unsafe, NoCacheKey, and Repeatable, respectively.",
      "ja": "この表では、表1に示されている無応答オプションのプロパティ、C、U、N、およびRの列は、それぞれ、重大な危険、NoCacheKey、かつ再現特性を示します。"
    },
    {
      "indent": 3,
      "text": "+--------+---+---+---+---+-------------+--------+--------+---------+\n| Number | C | U | N | R |   Name      | Format | Length | Default |\n+--------+---+---+---+---+-------------+--------+--------+---------+\n|   258  |   | X | - |   | No-Response |  uint  |  0-1   |    0    |\n+--------+---+---+---+---+-------------+--------+--------+---------+",
      "raw": true
    },
    {
      "indent": 23,
      "text": "Table 1: Option Properties",
      "ja": "表1：オプションのプロパティ"
    },
    {
      "indent": 3,
      "text": "This option is a request option. It is elective and not repeatable. This option is Unsafe-to-Forward, as the intermediary MUST know how to interpret this option. Otherwise, the intermediary (without knowledge about the special unidirectional nature of the request) would wait for responses.",
      "ja": "このオプションは、要求のオプションです。それは選択科目と再現ではありません。仲介は、このオプションを解釈する方法を知っている必要があり、このオプションでは、危険・ツー・フォワードです。それ以外の場合は、（リクエストの特別な一方向の性質についての知識がなくても）仲介は、応答を待つでしょう。"
    },
    {
      "indent": 3,
      "text": "Note: Since CoAP maintains a clear separation between the request/response and the message sub-layer, this option does not have any dependency on the type of message (Confirmable/Non-confirmable). So, even the absence of a message sub-layer (e.g., CoAP over TCP [CoAP-TCP-TLS]) should have no effect on the interpretation of this option. However, considering the CoAP-over-UDP scenario [RFC7252], NON messages are best suited to this option because of the expected benefits. Using No-Response with NON messages gets rid of any kind of reverse traffic, and the interaction becomes completely open loop.",
      "ja": "注：CoAPは、要求/応答メッセージとサブ層との間の明確な分離を維持するので、このオプションは、メッセージの種類（確認可能/非確認できる）上の任意の依存関係を持ちません。だから、メッセージサブ層のも存在しない（例えば、TCP上CoAP [CoAP-TCP-TLS]）は、このオプションの解釈に影響を及ぼさないはずです。しかし、CoAPオーバーUDPシナリオ[RFC7252]を考慮すると、NONのメッセージがあるため期待される利益のこのオプションに最も適しています。 NONメッセージで無応答を使用していないことは、逆方向トラフィックのいずれかの種類を取り除く、との相互作用は完全にオープンループとなります。"
    },
    {
      "indent": 6,
      "text": "Using this option with CON requests may not serve the desired purpose if piggybacked responses are triggered. But, if the server responds with a separate response (which, perhaps, the client does not care about), then this option can be useful. Suppressing the separate response reduces traffic by one additional CoAP message in this case.",
      "ja": "ピギーバック応答がトリガされた場合CON要求にこのオプションを使用すると、所望の目的を果たすことがありません。サーバが別々の応答（おそらく、クライアントは気にしない、）で応答した場合でも、このオプションは便利です。別の応答を抑制することは、この場合、一つの追加CoAPメッセージによってトラフィックを削減します。"
    },
    {
      "indent": 3,
      "text": "This option contains values to indicate disinterest in all or a particular class or combination of classes of responses as described in Section 2.1.",
      "ja": "このオプションは、セクション2.1で説明したように、すべてまたは応答のクラスの特定のクラス、または組み合わせて無関心を示すために、値が含まれています。"
    },
    {
      "indent": 0,
      "text": "2.1. Granular Control over Response Suppression",
      "section_title": true,
      "ja": "2.1. 応答抑制をきめ細かくコントロール"
    },
    {
      "indent": 3,
      "text": "This option enables granular control over response suppression by allowing the client to express its disinterest in a typical class or combination of classes of responses. For example, a client may explicitly tell the receiver that no response is required unless something 'bad' happens and a response of class 4.xx or 5.xx is to be fed back to the client. No response of the class 2.xx is required in such case.",
      "ja": "このオプションは、クライアントが応答のクラスの代表的なクラス、または組み合わせてその無関心を表現できるようにすることで、応答抑制をきめ細かく制御を可能にします。例えば、クライアントが明示的に「悪い」何かが起こるとクラス4.XXまたは5.XXの応答は、クライアントに供給すべきでない限り、何の応答が必要とされないことを受信者に伝えることがあります。クラス2.xxのの応答なしは、このような場合には必要ありません。"
    },
    {
      "indent": 3,
      "text": "Note: Section 2.7 of [RFC7390] describes a scheme where a server in the multicast group may decide on its own to suppress responses for group communication with granular control. The client does not have any knowledge about that. However, on the other hand, the No-Response option enables the client to explicitly inform the servers about its disinterest in responses. Such explicit control on the client side may be helpful for debugging network resources. An example scenario is described in Section 4.2.1.",
      "ja": "注：[RFC7390]のセクション2.7は、マルチキャスト・グループ内のサーバは、粒状対照とグループ通信のための応答を抑制するために独自に決定することができる方式を説明しています。クライアントは、そのことについて知識を持っていません。しかし、一方で、無応答オプションは、明示的応答におけるその無関心についてサーバに通知するためにクライアントを可能にします。クライアント側でこのような明示的な制御は、ネットワークリソースのデバッグに役立つかもしれません。例示的なシナリオは、セクション4.2.1に記載されています。"
    },
    {
      "indent": 3,
      "text": "The server MUST send back responses of the classes for which the client has not expressed any disinterest. There may be instances where a server, on its own, decides to suppress responses. An example is suppression of responses by multicast servers as described in Section 2.7 of [RFC7390]. If such a server receives a request with a No-Response option showing 'interest' in specific response classes (i.e., not expressing disinterest for these options), then any default behavior of suppressing responses, if present, MUST be overridden to deliver those responses that are of interest to the client.",
      "ja": "サーバーは、クライアントが任意の無関心を表明しなかったため、クラスの応答を返送しなければなりません。サーバは、独自に、応答を抑制することを決定した事例があるかもしれません。 [RFC7390]のセクション2.7に記載されているように、例えば、マルチキャストサーバによる応答の抑制です。そのようなサーバが応答を抑制するの特定の応答クラス内の関心 '（すなわち、これらのオプションの無関心を発現していない）、その後、任意のデフォルトの動作を示す無応答オプションで要求を受信した場合に存在する場合、それらの応答を提供するために上書きされなければなりませんクライアントにとって関心のあること。"
    },
    {
      "indent": 3,
      "text": "So, for example, suppose a multicast server suppresses all responses by default and receives a request with a No-Response option expressing disinterest in 2.xx (success) responses only. Note that the option value naturally expresses interest in error responses 4.xx and 5.xx in this case. Thus, the server must send back a response if the concerned request caused an error.",
      "ja": "したがって、たとえば、マルチキャストサーバは、デフォルトですべての応答を抑制し、唯一の2.xxの（成功）応答に無関心を表す無応答オプションを指定して要求を受け取るとします。オプションの値は、当然、この場合のエラー応答の4.XXと5.XXの関心を表現することに注意してください。心配要求がエラーを起こした場合はこのように、サーバが応答を返送しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The option value is defined as a bit map (Table 2) to achieve granular suppression. Its length can be 0 bytes (empty) or 1 byte.",
      "ja": "オプションの値は、粒状抑制を達成するために、ビットマップ（表2）として定義されます。その長さは0バイト（空）または1バイトであることができます。"
    },
    {
      "indent": 3,
      "text": "+-------+-----------------------+-----------------------------------+\n| Value | Binary Representation |          Description              |\n+-------+-----------------------+-----------------------------------+\n|   0   |      <empty>          | Interested in all responses.      |\n+-------+-----------------------+-----------------------------------+\n|   2   |      00000010         | Not interested in 2.xx responses. |\n+-------+-----------------------+-----------------------------------+\n|   8   |      00001000         | Not interested in 4.xx responses. |\n+-------+-----------------------+-----------------------------------+\n|  16   |      00010000         | Not interested in 5.xx responses. |\n+-------+-----------------------+-----------------------------------+",
      "raw": true
    },
    {
      "indent": 26,
      "text": "Table 2: Option Values",
      "ja": "表2：オプション値"
    },
    {
      "indent": 3,
      "text": "The conventions used in deciding the option values are:",
      "ja": "オプションの値を決定する際に使用される表記規則は、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "1. To suppress an individual class: Set bit number (n-1) starting from the least significant bit (bit number 0) to suppress all responses belonging to class n.xx. So,",
      "ja": "個々のクラス抑制するために1：設定されたビット数（N-1）クラスn.xx.に属するすべての応答を抑制するために最下位ビット（ビット番号0）から始まりますそう、"
    },
    {
      "indent": 15,
      "text": "option value to suppress n.xx class = 2**(n-1)",
      "ja": "n.xxクラス= 2 **（N-1）を抑制するためのオプション値"
    },
    {
      "indent": 3,
      "text": "2. To suppress a combination of classes: Set each corresponding bit according to point 1 above. Example: The option value will be 18 (binary: 00010010) to suppress both 2.xx and 5.xx responses. This is essentially bitwise OR of the corresponding individual values for suppressing 2.xx and 5.xx. The \"CoAP Response Codes\" registry (see Section 12.1.2 of [RFC7252]) defines 2.xx, 4.xx, and 5.xx responses. So, an option value of 26 (binary: 00011010) will request to suppress all response codes defined in [RFC7252].",
      "ja": "2.クラスの組合せを抑制する：上記の点1に記載の各対応するビットを設定します。例：2.xxのと5.XX応答の両方を抑制する：オプションの値は、18（00010010二進）であろう。これは本質的にビット単位のOR抑制2.xxのと5.xx.に対応する個々の値であります\"CoAP応答コード\" レジストリは、（[RFC7252]のセクション12.1.2を参照）2.xxの、4.XX、および5.XX応答を定義します。だから、26（バイナリ：00011010）のオプションの値は、[RFC7252]で定義されたすべての応答コードを抑制するために要求します。"
    },
    {
      "indent": 3,
      "text": "Note: When No-Response is used with value 26 in a request, the client endpoint SHOULD cease listening to response(s) to the particular request. On the other hand, showing interest in at least one class of response means that the client endpoint can no longer completely cease listening activity and must be configured to listen during some application specific time-out period for the particular request. The client endpoint never knows whether the present request will be a success or a failure. Thus, for example, if the client decides to open up the response for errors (4.xx and 5.xx), then it has to wait for the entire time-out period -- even for the instances where the request is successful (and the server is not supposed to send back a response). Note that in this context there may be situations when the response to errors might get lost. In such a situation, the client would wait during the time-out period but would not receive any response. However, this should not give the client the impression that the request was necessarily successful. In other words, in this case, the client cannot distinguish between response suppression and message loss. The application designer needs to tackle this situation. For example, while performing frequent updates, the client may strategically interweave requests without No-Response option into a series of requests with No-Response to check periodically that things are fine at the server end and the server is actively responding.",
      "ja": "注意：無応答が要求に値26で使用されていない場合は、クライアントのエンドポイントは、特定の要求に対する応答（複数可）を聞いて停止すべきです。一方、応答の少なくとも1つのクラスに関心を示すことはクライアントエンドポイントは、もはや完全にリスニング活動を中止することはできませんし、特定の要求のためのいくつかのアプリケーション固有のタイムアウト期間の間に待機するように構成されなければならないことを意味します。クライアントエンドポイントは、現在の要求が成功したか失敗するかどうかを知っていることはありません。 （でも、リクエストが成功したインスタンスのために - クライアントがエラー（4.XXと5.XX）の応答を開くことを決定した場合このように、例えば、それは全体のタイムアウト時間を待つ必要がありますそして、サーバ）は、応答を返送することになっていません。エラーへの応答が失われる可能性がある場合、この文脈での状況があるかもしれないことに注意してください。このような状況では、クライアントはタイムアウト期間内に待機していましたが、応答を受信しないでしょう。ただし、これはクライアントにリクエストが必ずしも成功したという印象を与えるべきではありません。換言すれば、この場合には、クライアントは、応答の抑制とメッセージの損失とを区別することができません。アプリケーション設計者は、このような状況に取り組む必要があります。頻繁に更新を行いながら、例えば、クライアントは、戦略的に物事が、サーバー側での細かいあり、サーバが積極的に応答していることを定期的にチェックするために無応答との一連の要求への無応答オプションを指定せずに要求を織り交ぜることがあります。"
    },
    {
      "indent": 0,
      "text": "2.2. Method-Specific Applicability Considerations",
      "section_title": true,
      "ja": "2.2. メソッド固有の適用の考慮事項"
    },
    {
      "indent": 3,
      "text": "The following table provides a ready reference on the possible applicability of this option with four REST methods. This table is for the type of possible interactions foreseen at the time of preparing this specification. The key words from RFC 2119 such as \"SHOULD NOT\", etc., deliberately have not been used in this table because it only contains suggestions.",
      "ja": "次の表は、4つのRESTの方法と、このオプションの可能な適用に準備リファレンスを提供します。この表は、この明細書の調製時に予見可能な相互作用のタイプのためのものです。それが唯一の提案が含まれているため、このような、「べきではない」などとして、RFC 2119からのキーワードは、故意にこの表で使用されていません。"
    },
    {
      "indent": 3,
      "text": "+-------------+----------------------------------------------------+\n| Method Name |              Remarks on Applicability              |\n+-------------+----------------------------------------------------+\n|             | This should not be used with a conventional GET    |\n|             | request when the client requests the contents      |\n|             | of a resource.  However, this option may be useful |\n|             | for exceptional cases where GET requests have side |\n|     GET     | effects.  For instance, the proactive cancellation |\n|             | procedure for observing a request [RFC7641]        |\n|             | requires a client to issue a GET request with the  |\n|             | Observe option set to 1 ('deregister').  If it is  |\n|             | more efficient to use this deregistration instead  |\n|             | of reactive cancellation (rejecting the next       |\n|             | notification with RST), the client MAY express its |\n|             | disinterest in the response to such a GET request. |\n+-------------+----------------------------------------------------+\n|             | Suitable for frequent updates (particularly in NON |\n|             | messages) on existing resources.  Might not be     |\n|             | useful when PUT is used to create a new resource,  |\n|             | as it may be important for the client to know that |\n|     PUT     | the resource creation was actually successful in   |\n|             | order to carry out future actions.  Also, it may be|\n|             | important to ensure that a resource was actually   |\n|             | created rather than updating an existing resource. |\n+-------------+----------------------------------------------------+\n|             | If POST is used to update a target resource,       |\n|             | then No-Response can be used in the same manner as |\n|             | in PUT.  This option may also be useful while      |\n|     POST    | updating through query strings rather than updating|\n|             | a fixed target resource (see Section 4.1.2.2 for an|\n|             | example).                                          |\n+-------------+----------------------------------------------------+\n|             | Deletion is usually a permanent action.  If the    |\n|    DELETE   | client wants to ensure that the deletion request   |\n|             | was properly executed, then this option should not |\n|             | be used with the request.                          |\n+-------------+----------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 4,
      "text": "Table 3: Suggested Applicability of No-Response with REST Methods",
      "ja": "表3：REST方式で無応答の推奨適用性"
    },
    {
      "indent": 0,
      "text": "3. Miscellaneous Aspects",
      "section_title": true,
      "ja": "3.その他の側面"
    },
    {
      "indent": 3,
      "text": "This section further describes important implementation aspects worth considering while using the No-Response option. The following discussion contains guidelines and requirements (derived by combining [RFC7252], [RFC7390], and [RFC5405]) for the application developer.",
      "ja": "このセクションでは、さらに無応答オプションを使用しながら、検討する価値の重要な実装の側面について説明します。以下の説明は、アプリケーション開発者のために（[RFC7252]、[RFC7390]及び[RFC5405]を組み合わせることによって誘導される）のガイドラインおよび要件を含んでいます。"
    },
    {
      "indent": 0,
      "text": "3.1. Reusing Tokens",
      "section_title": true,
      "ja": "3.1. 再利用トークン"
    },
    {
      "indent": 3,
      "text": "Tokens provide a matching criteria between a request and the corresponding response. The life of a Token starts when it is assigned to a request and ends when the final matching response is received. Then, the Token can again be reused. However, a request with No-Response typically does not have any guaranteed response path. So, the client has to decide on its own about when it can retire a Token that has been used in an earlier request so that the Token can be reused in a future request. Since the No-Response option is 'elective', a server that has not implemented this option will respond back. This leads to the following two scenarios:",
      "ja": "トークンは、要求と対応する応答との間の一致基準を提供します。トークンの寿命は、それが要求に割り当てられている場合を開始し、最終的なマッチングの応答を受信したときに終了します。その後、トークンは再び再利用することができます。しかし、無応答との要求は、典型的には、任意の保証応答パスを持っていません。だから、クライアントは、トークンが将来の要求で再利用できるように、以前の要求で使用されてきたトークンを引退することができるときについて自分自身で決めることがあります。無応答オプションは、「選択科目」であるので、このオプションを実装していないサーバが応答を返します。これは、次の2つのシナリオにつながります："
    },
    {
      "indent": 3,
      "text": "The first scenario is when the client is never going to care about any response coming back or about relating the response to the original request. In that case, it MAY reuse the Token value at liberty.",
      "ja": "クライアントがバックまたは元の要求に対する応答を関係について今後どのレスポンスを気にするつもりはありませんされたときに最初のシナリオです。その場合には、自由にトークン値を再利用することができます。"
    },
    {
      "indent": 3,
      "text": "However, as a second scenario, let us consider that the client sends two requests where the first request is with No-Response and the second request (with the same Token) is without No-Response. In this case, a delayed response to the first one can be interpreted as a response to the second request (client needs a response in the second case) if the time interval between using the same Token is not long enough. This creates a problem in the request-response semantics.",
      "ja": "しかし、第2のシナリオとして、私たちは、クライアントが最初の要求が無反応であると（同じトークンで）2番目の要求が無反応なしで2つの要求を送信することを検討してみましょう。この場合、第1の応答遅れは、同じトークンを使用して、時間間隔が十分に長くない場合（クライアントが第二の場合の応答を必要とする）は、第2の要求に対する応答として解釈することができます。これは、要求と応答の意味で問題を作成します。"
    },
    {
      "indent": 3,
      "text": "The most ideal solution would be to always use a unique Token for requests with No-Response. But if a client wants to reuse a Token, then in most practical cases the client implementation SHOULD implement an application-specific reuse time after which it can reuse the Token. A minimum reuse time for Tokens with a similar expression as in Section 2.5 of [RFC7390] SHOULD be used:",
      "ja": "最も理想的な解決策は、常に無応答と要求のためのユニークなトークンを使用することです。クライアントはトークンを再利用したい場合しかし、その後、最も実用的な例では、クライアントの実装は、それがトークンを再利用することができた後に、アプリケーション固有の再使用時間を実装する必要があります。 [RFC7390]のセクション2.5と同様の発現を有するトークンの最小の再使用時間は、使用されるべきです。"
    },
    {
      "indent": 3,
      "text": "TOKEN_REUSE_TIME = NON_LIFETIME + MAX_SERVER_RESPONSE_DELAY + MAX_LATENCY",
      "ja": "TOKEN_REUSE_TIME = NON_LIFETIME + MAX_SERVER_RESPONSE_DELAY + MAX_LATENCY"
    },
    {
      "indent": 3,
      "text": "NON_LIFETIME and MAX_LATENCY are defined in Section 4.8.2 of [RFC7252]. MAX_SERVER_RESPONSE_DELAY has the same interpretation as in Section 2.5 of [RFC7390] for a multicast request. For a unicast request, since the message is sent to only one server, MAX_SERVER_RESPONSE_DELAY means the expected maximum response delay from the particular server to that client that sent the request. For multicast requests, MAX_SERVER_RESPONSE_DELAY has the same interpretation as in Section 2.5 of [RFC7390]. So, for multicast it is the expected maximum server response delay \"over all servers that the client can send a multicast request to\", per [RFC7390]. This response delay for a given server includes its specific Leisure period; where Leisure is defined in Section 8.2 of [RFC7252]. In general, the Leisure for a server may not be known to the client. A lower bound for Leisure, lb_Leisure, is defined in [RFC7252], but not an upper bound as is needed in this case. Therefore, the upper bound can be estimated by taking N (N>>1) times the lower bound lb_Leisure:",
      "ja": "NON_LIFETIMEとMAX_LATENCYは[RFC7252]のセクション4.8.2で定義されています。 MAX_SERVER_RESPONSE_DELAYマルチキャスト要求のために[RFC7390]のセクション2.5と同様の解釈を有します。メッセージが一つのサーバに送信されるので、ユニキャスト要求のために、MAX_SERVER_RESPONSE_DELAYは、要求を送信し、そのクライアントに特定のサーバからの予想される最大応答遅延を意味します。マルチキャスト要求のために、MAX_SERVER_RESPONSE_DELAYは[RFC7390]のセクション2.5と同様の解釈を有します。だから、マルチキャストのためには、[RFC7390]あたりに、「クライアントがマルチキャスト要求を送信することができ、すべてのサーバーより」予想される最大サーバの応答遅延があります。所与のサーバに対してこの応答遅れは、その特定のレジャー期間を含みます。レジャーは、[RFC7252]のセクション8.2で定義されます。一般的には、サーバのレジャーは、クライアントに知られないことがあります。レジャー、lb_Leisureの下限、[RFC7252]で定義されているが、この場合に必要とされるように上限はありません。そのため、上限は、（1 N >>）倍下限lb_Leisure Nを取ることによって推定することができます。"
    },
    {
      "indent": 26,
      "text": "lb_Leisure = S * G / R",
      "ja": "lb_Leisure = C * D / P"
    },
    {
      "indent": 3,
      "text": "where S = estimated response size G = group size estimate R = data transfer rate",
      "ja": "S =推定された応答の大きさG =グループサイズ推定R =データ転送速度"
    },
    {
      "indent": 3,
      "text": "Any estimate of MAX_SERVER_RESPONSE_DELAY MUST be larger than DEFAULT_LEISURE, as defined in [RFC7252].",
      "ja": "[RFC7252]で定義されるようMAX_SERVER_RESPONSE_DELAYの任意の推定値は、DEFAULT_LEISUREより大きくなければなりません。"
    },
    {
      "indent": 3,
      "text": "Note: If it is not possible for the client to get a reasonable estimate of the MAX_SERVER_RESPONSE_DELAY, then the client, to be safe, SHOULD use a unique Token for each stream of messages.",
      "ja": "注意：クライアントはMAX_SERVER_RESPONSE_DELAYの合理的な見積りを取得することができない場合は、クライアント、安全のために、メッセージの各ストリームのためのユニークなトークンを使用すべきです。"
    },
    {
      "indent": 0,
      "text": "3.2. Taking Care of Congestion Control and Server-Side Flow Control",
      "section_title": true,
      "ja": "3.2. 輻輳制御の世話をし、サーバー側フロー制御"
    },
    {
      "indent": 3,
      "text": "This section provides guidelines for basic congestion control. Better congestion control mechanisms can be designed as future work.",
      "ja": "このセクションでは、基本的な輻輳制御のためのガイドラインを提供します。より良い輻輳制御機構は、将来の仕事として設計することができます。"
    },
    {
      "indent": 3,
      "text": "If this option is used with NON messages, then the interaction becomes completely open loop. The absence of any feedback from the server-end affects congestion-control mechanisms. In this case, the communication pattern maps to the scenario where the application cannot maintain an RTT estimate as described in Section 3.1.2 of [RFC5405]. Hence, per [RFC5405], a 3-second interval is suggested as the minimum interval between successive updates, and it is suggested to use an even less aggressive rate when possible. However, in case of a higher rate of updates, the application MUST have some knowledge about the channel, and an application developer MUST interweave occasional closed-loop exchanges (e.g., NON messages without No-Response, or CON messages) to get an RTT estimate between the endpoints.",
      "ja": "このオプションはNONメッセージで使用されている場合、その相互作用は完全にオープンループとなります。サーバエンドからのフィードバックの欠如は、輻輳制御機構に影響を与えます。この場合、通信パターンは、[RFC5405]のセクション3.1.2に記載したように、アプリケーションは、RTT推定値を維持することができないシナリオにマッピング。したがって、[RFC5405]あたり、3秒間隔で連続する更新の間の最小間隔として提案され、可能な場合も少なく積極的なレートを使用することが提案されています。ただし、アップデートの高いレートの場合、アプリケーションはチャネルに関するある程度の知識を持っている必要があり、アプリケーション開発者は、RTTを取得するために、時折閉ループ交換（例えば、NON無応答のないメッセージ、またはCONメッセージ）を織り合わせなければなりません。エンドポイント間の推定。"
    },
    {
      "indent": 3,
      "text": "Interweaving requests without No-Response is a MUST in case of an aggressive request rate for applications where server-side flow control is necessary. For example, as proposed in [CoAP-PUBSUB], a",
      "ja": "無応答なしの織り成す要求は、サーバー側のフロー制御が必要であるアプリケーションのための積極的な要求レートの場合はMUSTです。例えば、[CoAP-のpubsub]に提案されているように、"
    },
    {
      "indent": 3,
      "text": "broker MAY return 4.29 (Too Many Requests) in order to request a client to slow down the request rate. Interweaving requests without No-Response allows the client to listen to such a response.",
      "ja": "ブローカーは要求レートを遅くするクライアントを要求するために、4.29（あまりにも多くの要求を）返してもよいです。無応答なしの要求を織り交ぜ、クライアントがそのような応答を聞くことができます。"
    },
    {
      "indent": 0,
      "text": "3.3. Considerations regarding Caching of Responses",
      "section_title": true,
      "ja": "3.3. 応答のキャッシングについての考慮事項"
    },
    {
      "indent": 3,
      "text": "The cacheability of CoAP responses does not depend on the request method, but it depends on the Response Code. The No-Response option does not lead to any impact on cacheability of responses. If a request containing No-Response triggers a cacheable response, then the response MUST be cached. However, the response MAY not be transmitted considering the value of the No-Response option in the request.",
      "ja": "CoAPレスポンスのキャッシュ可能性は、リクエストメソッドには依存しませんが、応答コードに依存します。無応答オプションは、応答のキャッシュ可能性への影響にはつながりません。無応答を含まない要求がキャッシュ可能な応答をトリガーする場合は、応答がキャッシュされなければなりません。しかし、応答は要求における無応答オプションの値を考慮し、送信することはできません。"
    },
    {
      "indent": 3,
      "text": "For example, if a request with No-Response triggers a cacheable response of 4.xx class with Max-Age not equal to 0, then the response must be cached. The cache will return the response to subsequent similar requests without No-Response as long as the Max-Age has not elapsed.",
      "ja": "無応答と要求が0に等しくない最大年齢とともに4.XXクラスのキャッシュ可能な応答をトリガする場合、例えば、その応答がキャッシュされなければなりません。キャッシュは限り最大エイジが経過していないとして、無応答せず、その後の同様の要求への応答を返します。"
    },
    {
      "indent": 0,
      "text": "3.4. Handling the No-Response Option for a HTTP-to-CoAP Reverse Proxy",
      "section_title": true,
      "ja": "3.4.  HTTPツーCoAPリバースプロキシのための無応答オプションの取り扱い"
    },
    {
      "indent": 3,
      "text": "A HTTP-to-CoAP reverse proxy MAY translate an incoming HTTP request to a corresponding CoAP request indicating that no response is required (showing disinterest in all classes of responses) based on some application-specific requirement. In this case, it is RECOMMENDED that the reverse proxy generate an HTTP response with status code 204 (No Content) when such response is allowed. The generated response is sent after the proxy has successfully sent out the CoAP request.",
      "ja": "HTTPツーCoAPリバースプロキシは、応答は、いくつかのアプリケーション特有の要件に基づいて（応答のすべてのクラスに無関心を示す）必要とされないことを示す対応CoAP要求に着信HTTP要求を変換することができます。この場合には、そのような応答が許可されたときに、リバースプロキシは、ステータスコード204（いいえコンテンツ）とHTTPレスポンスを生成することが推奨されます。プロキシが正常にCoAP要求を送出した後に生成された応答が送信されます。"
    },
    {
      "indent": 3,
      "text": "If the reverse proxy applies No-Response for one or more classes of responses, it will wait for responses up to an application-specific maximum time (T_max) before responding to the HTTP side. If a response of a desired class is received within T_max, then the response gets translated to HTTP as defined in [HTTP-to-CoAP]. However, if the proxy does not receive any response within T_max, it is RECOMMENDED that the reverse Proxy send an HTTP response with status code 204 (No Content) when allowed for the specific HTTP request method.",
      "ja": "リバースプロキシは、応答の1つ以上のクラスのための無応答が適用されない場合は、HTTP側に応答する前に、アプリケーション固有の最大時間（T_maxを）までの応答を待ちます。所望のクラスの応答がT_maxを内に受信した場合[HTTPツーCoAP]で定義されるように、その後、応答はHTTPに変換されます。プロキシがT_maxを内の任意の応答を受信しない場合は、特定のHTTPリクエストメソッドのために許容される場合、リバースプロキシは、ステータスコード204（いいえコンテンツ）とHTTPレスポンスを送信することが推奨されます。"
    },
    {
      "indent": 0,
      "text": "4. Application Scenarios",
      "section_title": true,
      "ja": "4.アプリケーションシナリオ"
    },
    {
      "indent": 3,
      "text": "This section describes some examples of application scenarios that may potentially benefit from the use of the No-Response option.",
      "ja": "このセクションでは、潜在的に無応答オプションを使用することから利益を得ることができるアプリケーション・シナリオの例をいくつか説明します。"
    },
    {
      "indent": 0,
      "text": "4.1. Frequent Update of Geolocation from Vehicles to Backend Server",
      "section_title": true,
      "ja": "4.1. 車からバックエンドサーバーへの地理位置情報の頻繁な更新"
    },
    {
      "indent": 3,
      "text": "Let us consider an intelligent traffic system (ITS) consisting of vehicles equipped with a sensor gateway comprising sensors like GPS and accelerometer sensors. The sensor gateway acts as a CoAP client. It connects to the Internet using a low-bandwidth cellular connection (e.g., General Packet Radio Service (GPRS)). The GPS coordinates of the vehicle are periodically updated to the backend server.",
      "ja": "私たちは、インテリジェント交通システムを考える（ITS）GPSと加速度センサなどのセンサを含むセンサゲートウェイを備えた車両からなります。センサゲートウェイはCoAPクライアントとして機能します。これは、低帯域セルラ接続（例えば、汎用パケット無線サービス（GPRS））を使用してインターネットに接続しています。車両のGPS座標は、定期的にバックエンドサーバに更新されます。"
    },
    {
      "indent": 3,
      "text": "While performing frequent location updates, retransmitting (through the CoAP CON mechanism) a location coordinate that the vehicle has already left is not efficient as it adds redundant traffic to the network. Therefore, the updates are done using NON messages. However, given the huge number of vehicles updating frequently, the NON exchange will also trigger a huge number of responses from the backend. Thus, the cumulative load on the network will be quite significant. Also, the client in this case may not be interested in getting responses to location update requests for a location it has already passed and when the next location update is imminent.",
      "ja": "頻繁に位置更新を行いながら、ネットワークに冗長なトラフィックを追加したように、位置は、車両が既に去ったことを座標（CoAPのCON機構を介して）再送信することは効率的ではありません。そのため、更新はNONメッセージを使用して行われます。しかし、頻繁に更新車の膨大な数を考えると、NON交換はまた、バックエンドからの応答の膨大な数をトリガします。このように、ネットワーク上の累積負荷が非常に重要になります。また、この場合、クライアントは、それがすでに経過していると、次の位置更新が差し迫っているとき、場所の位置更新要求に対する応答を得ることに興味がないかもしれません。"
    },
    {
      "indent": 3,
      "text": "On the contrary, if the client endpoints on the vehicles explicitly declare that they do not need any status response back from the server, then load will be reduced significantly. The assumption is that the high rate of updates will compensate for the stray losses in geolocation reports.",
      "ja": "車上のクライアントエンドポイントが明示的に彼らが戻ってサーバからのステータス応答を必要としないことを宣言した場合、逆に、その後、負荷が大幅に軽減されます。仮定は、更新率の高さは、地理位置情報、レポートの浮遊損失を補償することです。"
    },
    {
      "indent": 3,
      "text": "Note: It may be argued that the above example application can also be implemented using the Observe option [RFC7641] with NON notifications. But, in practice, implementing with Observe would require lot of bookkeeping at the data collection endpoint at the backend (observer). The observer needs to maintain all the observe relationships with each vehicle. The data collection endpoint may be unable to know all its data sources beforehand. The client endpoints at vehicles may go offline or come back online randomly. In the case of Observe, the onus is always on the data collection endpoint to establish an observe relationship with each data source. On the other hand, implementation will be much simpler if initiating is left to the data source to carry out updates using the No-Response option. Another way of looking at it is that the implementation choice depends on where there is interest to initiate the update. In an Observe scenario, the interest is expressed by the data consumer. In contrast, the classic update case applies when the interest is from the data producer. The No-Response option makes classic updates consume even less resources.",
      "ja": "注：上記の例のアプリケーションはまた、非通知と観察オプション[RFC7641]を使用して実施することができると主張することができます。しかし、実際には、観察を実装するバックエンド（オブザーバー）でのデータ収集のエンドポイントでの簿記の多くを必要とします。観察者は各車両を持つすべての観察の関係を維持する必要があります。データ収集のエンドポイントは、あらかじめ、そのすべてのデータソースを知ることができない場合があります。車でのクライアントエンドポイントがオフラインまたはランダムにオンラインに戻ってくることがあります。観察の場合、責任は各データソースとの観測関係を確立するために、データ収集のエンドポイントに常にあります。開始が無応答オプションを使用してアップデートを実行するために、データソースに残されている一方、実装がはるかに簡単になります。それを見てのもう一つの方法は、実装の選択は更新を開始するために関心がある場合に依存していることです。観察シナリオでは、対象は、データ消費者によって表現されます。関心がデータ生産からのものである場合は対照的に、古典的な更新のケースが適用されます。無応答オプションは、古典的な更新がさらに少ないリソースを消費します。"
    },
    {
      "indent": 3,
      "text": "The following subsections illustrate some sample exchanges based on the application described above.",
      "ja": "以下のサブセクションでは、上述したアプリケーションに基づいて、いくつかのサンプルの交換を示します。"
    },
    {
      "indent": 0,
      "text": "4.1.1. Using No-Response with PUT",
      "section_title": true,
      "ja": "4.1.1.  PUTで無応答を使用していません"
    },
    {
      "indent": 3,
      "text": "Each vehicle is assigned a dedicated resource \"vehicle-stat-<n>\", where <n> can be any string uniquely identifying the vehicle. The update requests are sent using NON messages. The No-Response option causes the server not to respond back.",
      "ja": "各車両は、専用リソース「車両stat- <N>」、<n>は一意の車両を識別する任意の文字列であってもよいが割り当てられます。更新要求は、NONメッセージを使用して送信されます。無応答のオプションが戻って応答しないサーバーが発生します。"
    },
    {
      "indent": 3,
      "text": "Client Server\n|      |\n|      |\n+----->| Header: PUT (T=NON, Code=0.03, MID=0x7d38)\n| PUT  | Token: 0x53\n|      | Uri-Path: \"vehicle-stat-00\"\n|      | Content Type: text/plain\n|      | No-Response: 26\n|      | Payload:\n|      | \"VehID=00&RouteID=DN47&Lat=22.5658745&Long=88.4107966667&\n|      | Time=2013-01-13T11:24:31\"\n|      |\n[No response from the server.  Next update in 20 s.]\n|      |\n+----->| Header: PUT (T=NON, Code=0.03, MID=0x7d39)\n| PUT  | Token: 0x54\n|      | Uri-Path: \"vehicle-stat-00\"\n|      | Content Type: text/plain\n|      | No-Response: 26\n|      | Payload:\n|      | \"VehID=00&RouteID=DN47&Lat=22.5649015&Long=88.4103511667&\n|      | Time=2013-01-13T11:24:51\"",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Figure 1: Example of Unreliable Update with No-Response Option Using PUT",
      "ja": "図1：PUTを使用した無応答オプションと信頼性の低い更新の例"
    },
    {
      "indent": 0,
      "text": "4.1.2. Using No-Response with POST",
      "section_title": true,
      "ja": "4.1.2.  POSTで無応答を使用していません"
    },
    {
      "indent": 0,
      "text": "4.1.2.1. POST Updating a Fixed Target Resource",
      "section_title": true,
      "ja": "4.1.2.1。 POSTは、固定目標リソースの更新します"
    },
    {
      "indent": 3,
      "text": "In this case, POST acts the same way as PUT. The exchanges are the same as above. The updated values are carried as payload of POST as shown in Figure 2.",
      "ja": "この場合、POSTは、PUTと同じように動作します。交換は上記と同様です。図2に示すように、更新された値は、POSTのペイロードとして運ばれます。"
    },
    {
      "indent": 3,
      "text": "Client Server\n|      |\n|      |\n+----->| Header: POST (T=NON, Code=0.02, MID=0x7d38)\n| POST | Token: 0x53\n|      | Uri-Path: \"vehicle-stat-00\"\n|      | Content Type: text/plain\n|      | No-Response: 26\n|      | Payload:\n|      | \"VehID=00&RouteID=DN47&Lat=22.5658745&Long=88.4107966667&\n|      | Time=2013-01-13T11:24:31\"\n|      |\n[No response from the server.  Next update in 20 s.]\n|      |\n+----->| Header: POST (T=NON, Code=0.02, MID=0x7d39)\n| POST | Token: 0x54\n|      | Uri-Path: \"vehicle-stat-00\"\n|      | Content Type: text/plain\n|      | No-Response: 26\n|      | Payload:\n|      | \"VehID=00&RouteID=DN47&Lat=22.5649015&Long=88.4103511667&\n|      | Time=2013-01-13T11:24:51\"",
      "raw": true
    },
    {
      "indent": 4,
      "text": "Figure 2: Example of Unreliable Update with No-Response Option Using POST as the Update Method",
      "ja": "図2：更新方法としてPOSTを使用した無応答オプションを有する信頼性の低い更新の例"
    },
    {
      "indent": 0,
      "text": "4.1.2.2. POST Updating through Query String",
      "section_title": true,
      "ja": "4.1.2.2。クエリ文字列を通じて更新POST"
    },
    {
      "indent": 3,
      "text": "It may be possible that the backend infrastructure deploys a dedicated database to store the location updates. In such a case, the client can update through a POST by sending a query string in the URI. The query string contains the name/value pairs for each update. No-Response can be used in the same manner as for updating fixed resources. The scenario is depicted in Figure 3.",
      "ja": "バックエンドインフラストラクチャが位置更新を格納するために専用のデータベースを展開することを可能とすることができます。このような場合、クライアントは、URIでクエリ文字列を送信することにより、POSTを更新することができます。クエリ文字列には、各アップデートの名前/値のペアが含まれています。無応答は、固定されたリソースを更新するためのと同じように使用することはできません。シナリオは図3に示されています。"
    },
    {
      "indent": 3,
      "text": "Client Server\n|      |\n|      |\n+----->| Header: POST (T=NON, Code=0.02, MID=0x7d38)\n| POST | Token: 0x53\n|      | Uri-Path: \"updateOrInsertInfo\"\n|      | Uri-Query: \"VehID=00\"\n|      | Uri-Query: \"RouteID=DN47\"\n|      | Uri-Query: \"Lat=22.5658745\"\n|      | Uri-Query: \"Long=88.4107966667\"\n|      | Uri-Query: \"Time=2013-01-13T11:24:31\"\n|      | No-Response: 26\n|      |\n[No response from the server.  Next update in 20 s.]\n|      |\n+----->| Header: POST (T=NON, Code=0.02, MID=0x7d39)\n| POST | Token: 0x54\n|      | Uri-Path: \"updateOrInsertInfo\"\n|      | Uri-Query: \"VehID=00\"\n|      | Uri-Query: \"RouteID=DN47\"\n|      | Uri-Query: \"Lat=22.5649015\"\n|      | Uri-Query: \"Long=88.4103511667\"\n|      | Uri-Query: \"Time=2013-01-13T11:24:51\"\n|      | No-Response: 26\n|      |",
      "raw": true
    },
    {
      "indent": 4,
      "text": "Figure 3: Example of Unreliable Update with No-Response Option Using POST with a Query String to Insert Update Information into the Backend Database",
      "ja": "図3：バックエンドデータベースに更新情報を挿入するためのクエリ文字列とPOSTを使用した無応答オプションと信頼性の低い更新の例"
    },
    {
      "indent": 0,
      "text": "4.2. Multicasting Actuation Command from a Handheld Device to a Group of Appliances",
      "ja": "4.2. ハンドヘルドデバイスからのアプライアンスのグループにマルチキャスト作動コマンド"
    },
    {
      "indent": 3,
      "text": "A handheld device (e.g., a smart phone) may be programmed to act as an IP-enabled switch to remotely operate on one or more IP-enabled appliances. For example, a multicast request to switch on/off all the lights of a building can be sent. In this case, the IP switch application can use the No-Response option in a NON request message to reduce the traffic generated due to simultaneous CoAP responses from all the lights.",
      "ja": "ハンドヘルドデバイス（例えば、スマートフォン）は、リモート1つ以上のIP対応機器上で動作するIP対応のスイッチとして動作するようにプログラムすることができます。たとえば、マルチキャスト要求は、建物のすべてのライトを送信することができますオン/オフを切り替えます。この場合、NON要求メッセージに無応答オプションを使用することができますIPスイッチアプリケーションは、すべてのライトからの同時CoAP応答に起因して発生するトラフィックを削減します。"
    },
    {
      "indent": 3,
      "text": "Thus, No-Response helps in reducing overall communication cost and the probability of network congestion in this case.",
      "ja": "このように、無応答は、全体的な通信コストと、このケースでは、ネットワークの輻輳の確率を減らすのに役立ちますありません。"
    },
    {
      "indent": 0,
      "text": "4.2.1. Using Granular Response Suppression",
      "section_title": true,
      "ja": "4.2.1. 粒状応答の抑制を使用して"
    },
    {
      "indent": 3,
      "text": "The IP switch application may optionally use granular response suppression such that the error responses are not suppressed. In that case, the lights that could not execute the request would respond back and be readily identified. Thus, explicit suppression of option classes by the multicast client may be useful to debug the network and the application.",
      "ja": "IPスイッチアプリケーションは、必要に応じて、エラー応答が抑制されないように粒状応答抑制を使用することができます。その場合には、要求を実行できませんでしたライトはバック反応するだろうと容易に識別されます。このように、マルチキャストクライアントによるオプションクラスの明示的な抑制は、ネットワークとアプリケーションのデバッグに有用である可能性があります。"
    },
    {
      "indent": 0,
      "text": "5. IANA Considerations",
      "section_title": true,
      "ja": "5. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "The IANA had previously assigned number 284 to this option in the \"CoAP Option Numbers\" registry. IANA has updated this as shown below:",
      "ja": "IANAは、以前に「CoAPオプション番号」レジストリでこのオプションに番号284を割り当てられていました。以下に示すようにIANAはこれを更新しました："
    },
    {
      "indent": 12,
      "text": "+--------+--------------+-------------+\n| Number |     Name     |  Reference  |\n+--------+--------------+-------------+\n|   258  | No-Response  |  RFC 7967   |\n+--------+--------------+-------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "6. Security Considerations",
      "section_title": true,
      "ja": "6.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "The No-Response option defined in this document presents no security considerations beyond those in Section 11 of the base CoAP specification [RFC7252].",
      "ja": "この文書で定義された無応答オプションは、基本CoAP仕様[RFC7252]のセクション11でものを超えてはセキュリティ上の考慮事項を提示していません。"
    },
    {
      "indent": 0,
      "text": "7. References",
      "section_title": true,
      "ja": "7.参考"
    },
    {
      "indent": 0,
      "text": "7.1. Normative References",
      "section_title": true,
      "ja": "7.1. 引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<http://www.rfc-editor.org/info/ RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC7252] Shelby, Z., Hartke, K., and C. Bormann, \"The Constrained Application Protocol (CoAP)\", RFC 7252, DOI 10.17487/RFC7252, June 2014, <http://www.rfc-editor.org/info/rfc7252>.",
      "ja": "[RFC7252]シェルビー、Z.、HARTKE、K.、およびC.ボルマン、 \"制約アプリケーションプロトコル（CoAP）\"、RFC 7252、DOI 10.17487 / RFC7252、2014年6月、<HTTP：//www.rfc-editor。組織/情報/ rfc7252>。"
    },
    {
      "indent": 0,
      "text": "7.2. Informative References",
      "section_title": true,
      "ja": "7.2. 参考文献"
    },
    {
      "indent": 3,
      "text": "[CoAP-ADAPT] Bandyopadhyay, S., Bhattacharyya, A., and A. Pal, \"Adapting protocol characteristics of CoAP using sensed indication for vehicular analytics\", 11th ACM Conference on Embedded Networked Sensor Systems (SenSys '13), DOI 10.1145/2517351.2517422, November 2013.",
      "ja": "[CoAP-ADAPT] Bandyopadhyay、S.、バタチャリヤ、A.、およびA.パル、組み込みネットワークセンサシステムに第11回ACM会議（SENSYS '13）、DOI 10.1145 \"車両分析のために検出された指標を用いてCoAPのプロトコル特性を適応\" /2517351.2517422、2013年11月。"
    },
    {
      "indent": 3,
      "text": "[CoAP-PUBSUB] Koster, M., Keranen, A., and J. Jimenez, \"Publish-Subscribe Broker for the Constrained Application Protocol (CoAP)\", Work in Progress, draft-koster-core-coap-pubsub-05, July 2016.",
      "ja": "[CoAP-のpubsub]コスター、M.、Keranen、A.、およびJ.ヒメネス、 \"パブリッシュ・サブスクライブ・ブローカを制約アプリケーションプロトコル（CoAP）は、\" 進歩、ドラフト・コスター・コアcoap-のpubsub-05でワーク、2016年7月。"
    },
    {
      "indent": 3,
      "text": "[CoAP-TCP-TLS] Bormann, C., Lemay, S., Tschofenig, H., Hartke, K., Silverajan, B., and B. Raymor, Ed., \"CoAP (Constrained Application Protocol) over TCP, TLS, and WebSockets\", Work in Progress, draft-ietf-core-coap-tcp-tls-04, August 2016.",
      "ja": "[CoAP-TCP-TLS]ボルマン、C.、ルメイ、S.、Tschofenig、H.、HARTKE、K.、Silverajan、B.、およびB. Raymor、エド。、「TCP上CoAP（制約アプリケーションプロトコル）、 TLS、およびWebSocketを」進行中で働いて、ドラフト-IETF-コアcoap-TCP-TLS-04、2016年8月。"
    },
    {
      "indent": 3,
      "text": "[HTTP-to-CoAP] Castellani, A., Loreto, S., Rahman, A., Fossati, T., and E. Dijk, \"Guidelines for HTTP-to-CoAP Mapping Implementations\", Work in Progress, draft-ietf-core-http-mapping-13, July 2016.",
      "ja": "[HTTPツーCoAP]カステラーニ、A.、ロレート、S.、ラーマン、A.、フォッサーティ、T.、およびE.ダイク \"のガイドラインHTTPツーCoAPマッピング実装\"、進行中で働いて、draft- IETF-コア-HTTP-マッピング-13、2016年7月。"
    },
    {
      "indent": 3,
      "text": "[ITS-LIGHT] Bhattacharyya, A., Bandyopadhyay, S., and A. Pal, \"ITS-light: Adaptive lightweight scheme to resource optimize intelligent transportation tracking system (ITS) - Customizing CoAP for opportunistic optimization\", 10th International Conference on Mobile and Ubiquitous Systems: Computing, Networking and Services (MobiQuitous 2013), DOI 10.1007/978-3-319-11569-6_58, December 2013.",
      "ja": "[ITS-LIGHT]バタチャリヤ、A.、Bandyopadhyay、S.、およびA.パル、 \"ITS-光：インテリジェント輸送追跡システムを最適化リソースに適応軽量スキーム（ITS） - 日和見最適化のためのカスタマイズCoAP\"、第10回国際会議にモバイルやユビキタスシステム：コンピューティング、ネットワーキング・サービス（MobiQuitous 2013）、DOI 10.1007 / 978-3-319-11569-6_58、2013年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC5405] Eggert, L. and G. Fairhurst, \"Unicast UDP Usage Guidelines for Application Designers\", BCP 145, RFC 5405, DOI 10.17487/RFC5405, November 2008, <http://www.rfc-editor.org/info/rfc5405>.",
      "ja": "[RFC5405]エッゲルト、L.とG. Fairhurst、 \"アプリケーションデザイナーのためのユニキャストUDPの使用上の注意事項\"、BCP 145、RFC 5405、DOI 10.17487 / RFC5405、2008年11月、<http://www.rfc-editor.org/info / rfc5405>。"
    },
    {
      "indent": 3,
      "text": "[RFC7390] Rahman, A., Ed., and E. Dijk, Ed., \"Group Communication for the Constrained Application Protocol (CoAP)\", RFC 7390, DOI 10.17487/RFC7390, October 2014, <http://www.rfc-editor.org/info/rfc7390>.",
      "ja": "[RFC7390]ラーマン、A.、エド、およびE.ダイク、エド、 \"グループ通信制約アプリケーションプロトコル（CoAP）について\"、RFC 7390、DOI 10.17487 / RFC7390、2014年10月、<HTTP：// WWW。 rfc-editor.org/info/rfc7390>。"
    },
    {
      "indent": 3,
      "text": "[RFC7641] Hartke, K., \"Observing Resources in the Constrained Application Protocol (CoAP)\", RFC 7641, DOI 10.17487/RFC7641, September 2015, <http://www.rfc-editor.org/info/rfc7641>.",
      "ja": "[RFC7641] HARTKE、K.、 \"制約アプリケーションプロトコル（CoAP）で観測資源\"、RFC 7641、DOI 10.17487 / RFC7641、2015年9月、<http://www.rfc-editor.org/info/rfc7641>。"
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Thanks to Carsten Bormann, Matthias Kovatsch, Esko Dijk, Bert Greevenbosch, Akbar Rahman, and Klaus Hartke for their valuable input.",
      "ja": "彼らの貴重な入力のためのカルステンボルマン、マティアスKovatsch、エスコダイク、バートGreevenbosch、アクバル・ラーマン、そしてクラウスHARTKEに感謝します。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Abhijan Bhattacharyya Tata Consultancy Services Ltd. Kolkata, India",
      "ja": "ltidを六神通バッタチャリヤとタタ・コンサルタンシー・サービシズ。コルカタ、インド"
    },
    {
      "indent": 3,
      "text": "Email: abhijan.bhattacharyya@tcs.com",
      "ja": "メール：abhijan.bhattacharyya@tcs.com"
    },
    {
      "indent": 3,
      "text": "Soma Bandyopadhyay Tata Consultancy Services Ltd. Kolkata, India",
      "ja": "相馬Bandyopadhyayタタ・コンサルタンシー・サービシズ株式会社コルカタ、インド"
    },
    {
      "indent": 3,
      "text": "Email: soma.bandyopadhyay@tcs.com",
      "ja": "メール：soma.bandyopadhyay@tcs.com"
    },
    {
      "indent": 3,
      "text": "Arpan Pal Tata Consultancy Services Ltd. Kolkata, India",
      "ja": "Arpanパルタタ・コンサルタンシー・サービシズ株式会社コルカタ、インド"
    },
    {
      "indent": 3,
      "text": "Email: arpan.pal@tcs.com",
      "ja": "メール：arpan.pal@tcs.com"
    },
    {
      "indent": 3,
      "text": "Tulika Bose Tata Consultancy Services Ltd. Kolkata, India",
      "ja": "Tulikaボーズタタ・コンサルタンシー・サービシズ株式会社コルカタ、インド"
    },
    {
      "indent": 3,
      "text": "Email: tulika.bose@tcs.com",
      "ja": "メール：tulika.bose@tcs.com"
    }
  ]
}