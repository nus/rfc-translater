{
  "title": {
    "text": "RFC 7950 - The YANG 1.1 Data Modeling Language",
    "ja": "RFC 7950 - YANG 1.1データモデリング言語"
  },
  "number": 7950,
  "created_at": "2019-11-02 13:06:18.055789+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                 M. Bjorklund, Ed.\nRequest for Comments: 7950                                Tail-f Systems\nCategory: Standards Track                                    August 2016\nISSN: 2070-1721",
      "raw": true
    },
    {
      "indent": 18,
      "text": "The YANG 1.1 Data Modeling Language",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "YANG is a data modeling language used to model configuration data, state data, Remote Procedure Calls, and notifications for network management protocols. This document describes the syntax and semantics of version 1.1 of the YANG language. YANG version 1.1 is a maintenance release of the YANG language, addressing ambiguities and defects in the original specification. There are a small number of backward incompatibilities from YANG version 1. This document also specifies the YANG mappings to the Network Configuration Protocol (NETCONF).",
      "ja": "YANGは、ネットワーク管理プロトコルの構成データ、状態データ、リモートプロシージャコール、および通知をモデル化するために使用されるデータモデリング言語です。この文書では、YANG言語のバージョン1.1の構文と意味を説明しています。 YANGバージョン1.1元の仕様に曖昧さや欠陥に対処、YANG言語のメンテナンスリリースです。この文書では、ネットワーク構成プロトコル（NETCONF）にYANGマッピングを指定するYANGバージョン1から後方非互換性の小さな数があります。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 7841のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7950.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7950で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2016 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2016 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 3,
      "text": "This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.",
      "ja": "この材料の一部がIETFトラストにこのような材料の変更を許可する権利を与えられていない可能性がありますにこの文書は、2008年、IETFドキュメントまたは11月10日以前に発行または公開さIETF貢献から著作権を支配する者（複数可）材料を含んでいてもよいですIETF標準化プロセスの外。そのような材料の著作権を管理者（単数または複数）から適切なライセンスを取得することなく、この文書は、IETF標準化過程の外側修正されないかもしれません、そして、それの派生物は、IETF標準化過程の外側に作成されない場合があり、それをフォーマットする以外出版RFCとして、英語以外の言語に翻訳します。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................9\n   1.1. Summary of Changes from RFC 6020 ..........................10\n2. Key Words ......................................................12\n3. Terminology ....................................................12\n   3.1. A Note on Examples ........................................16\n4. YANG Overview ..................................................16\n   4.1. Functional Overview .......................................16\n   4.2. Language Overview .........................................18\n        4.2.1. Modules and Submodules .............................18\n        4.2.2. Data Modeling Basics ...............................19\n        4.2.3. Configuration and State Data .......................23\n        4.2.4. Built-In Types .....................................24\n        4.2.5. Derived Types (typedef) ............................25\n        4.2.6. Reusable Node Groups (grouping) ....................25\n        4.2.7. Choices ............................................27\n        4.2.8. Extending Data Models (augment) ....................28\n        4.2.9. Operation Definitions ..............................29\n        4.2.10. Notification Definitions ..........................31\n5. Language Concepts ..............................................32\n   5.1. Modules and Submodules ....................................32\n        5.1.1. Import and Include by Revision .....................33\n        5.1.2. Module Hierarchies .................................34\n   5.2. File Layout ...............................................36\n   5.3. XML Namespaces ............................................36\n        5.3.1. YANG XML Namespace .................................36\n   5.4. Resolving Grouping, Type, and Identity Names ..............37\n   5.5. Nested Typedefs and Groupings .............................37\n   5.6. Conformance ...............................................38\n        5.6.1. Basic Behavior .....................................38\n        5.6.2. Optional Features ..................................38\n        5.6.3. Deviations .........................................39\n        5.6.4. Announcing Conformance Information in NETCONF ......40\n        5.6.5. Implementing a Module ..............................40\n   5.7. Datastore Modification ....................................44\n6. YANG Syntax ....................................................44\n   6.1. Lexical Tokenization ......................................45\n        6.1.1. Comments ...........................................45\n        6.1.2. Tokens .............................................45\n        6.1.3. Quoting ............................................45\n   6.2. Identifiers ...............................................47\n        6.2.1. Identifiers and Their Namespaces ...................47\n   6.3. Statements ................................................48\n        6.3.1. Language Extensions ................................48\n   6.4. XPath Evaluations .........................................49\n        6.4.1. XPath Context ......................................50\n   6.5. Schema Node Identifier ....................................54",
      "raw": true
    },
    {
      "indent": 3,
      "text": "7. YANG Statements ................................................55\n   7.1. The \"module\" Statement ....................................55\n        7.1.1. The module's Substatements .........................56\n        7.1.2. The \"yang-version\" Statement .......................57\n        7.1.3. The \"namespace\" Statement ..........................57\n        7.1.4. The \"prefix\" Statement .............................57\n        7.1.5. The \"import\" Statement .............................58\n        7.1.6. The \"include\" Statement ............................59\n        7.1.7. The \"organization\" Statement .......................60\n        7.1.8. The \"contact\" Statement ............................60\n        7.1.9. The \"revision\" Statement ...........................60\n        7.1.10. Usage Example .....................................61\n   7.2. The \"submodule\" Statement .................................62\n        7.2.1. The submodule's Substatements ......................63\n        7.2.2. The \"belongs-to\" Statement .........................63\n        7.2.3. Usage Example ......................................64\n   7.3. The \"typedef\" Statement ...................................65\n        7.3.1. The typedef's Substatements ........................65\n        7.3.2. The typedef's \"type\" Statement .....................65\n        7.3.3. The \"units\" Statement ..............................65\n        7.3.4. The typedef's \"default\" Statement ..................66\n        7.3.5. Usage Example ......................................66\n   7.4. The \"type\" Statement ......................................66\n        7.4.1. The type's Substatements ...........................67\n   7.5. The \"container\" Statement .................................67\n        7.5.1. Containers with Presence ...........................67\n        7.5.2. The container's Substatements ......................68\n        7.5.3. The \"must\" Statement ...............................69\n        7.5.4. The must's Substatements ...........................70\n        7.5.5. The \"presence\" Statement ...........................71\n        7.5.6. The container's Child Node Statements ..............71\n        7.5.7. XML Encoding Rules .................................71\n        7.5.8. NETCONF <edit-config> Operations ...................72\n        7.5.9. Usage Example ......................................72\n   7.6. The \"leaf\" Statement ......................................73\n        7.6.1. The leaf's Default Value ...........................74\n        7.6.2. The leaf's Substatements ...........................75\n        7.6.3. The leaf's \"type\" Statement ........................75\n        7.6.4. The leaf's \"default\" Statement .....................75\n        7.6.5. The leaf's \"mandatory\" Statement ...................76\n        7.6.6. XML Encoding Rules .................................76\n        7.6.7. NETCONF <edit-config> Operations ...................76\n        7.6.8. Usage Example ......................................77\n   7.7. The \"leaf-list\" Statement .................................77\n        7.7.1. Ordering ...........................................78\n        7.7.2. The leaf-list's Default Values .....................79\n        7.7.3. The leaf-list's Substatements ......................80\n        7.7.4. The leaf-list's \"default\" Statement ................80",
      "raw": true
    },
    {
      "indent": 6,
      "text": "     7.7.5. The \"min-elements\" Statement .......................80\n     7.7.6. The \"max-elements\" Statement .......................81\n     7.7.7. The \"ordered-by\" Statement .........................81\n     7.7.8. XML Encoding Rules .................................82\n     7.7.9. NETCONF <edit-config> Operations ...................82\n     7.7.10. Usage Example .....................................83\n7.8. The \"list\" Statement ......................................84\n     7.8.1. The list's Substatements ...........................85\n     7.8.2. The list's \"key\" Statement .........................85\n     7.8.3. The list's \"unique\" Statement ......................86\n     7.8.4. The list's Child Node Statements ...................87\n     7.8.5. XML Encoding Rules .................................88\n     7.8.6. NETCONF <edit-config> Operations ...................88\n     7.8.7. Usage Example ......................................90\n7.9. The \"choice\" Statement ....................................93\n     7.9.1. The choice's Substatements .........................94\n     7.9.2. The choice's \"case\" Statement ......................94\n     7.9.3. The choice's \"default\" Statement ...................96\n     7.9.4. The choice's \"mandatory\" Statement .................98\n     7.9.5. XML Encoding Rules .................................98\n     7.9.6. Usage Example ......................................99\n7.10. The \"anydata\" Statement .................................100\n     7.10.1. The anydata's Substatements ......................100\n     7.10.2. XML Encoding Rules ...............................101\n     7.10.3. NETCONF <edit-config> Operations .................101\n     7.10.4. Usage Example ....................................101\n7.11. The \"anyxml\" Statement ..................................102\n     7.11.1. The anyxml's Substatements .......................103\n     7.11.2. XML Encoding Rules ...............................103\n     7.11.3. NETCONF <edit-config> Operations .................103\n     7.11.4. Usage Example ....................................104\n7.12. The \"grouping\" Statement ................................104\n     7.12.1. The grouping's Substatements .....................105\n     7.12.2. Usage Example ....................................105\n7.13. The \"uses\" Statement ....................................106\n     7.13.1. The uses's Substatements .........................106\n     7.13.2. The \"refine\" Statement ...........................106\n     7.13.3. XML Encoding Rules ...............................107\n     7.13.4. Usage Example ....................................107\n7.14. The \"rpc\" Statement .....................................108\n     7.14.1. The rpc's Substatements ..........................109\n     7.14.2. The \"input\" Statement ............................109\n     7.14.3. The \"output\" Statement ...........................110\n     7.14.4. NETCONF XML Encoding Rules .......................111\n     7.14.5. Usage Example ....................................112",
      "raw": true
    },
    {
      "indent": 3,
      "text": "   7.15. The \"action\" Statement ..................................113\n        7.15.1. The action's Substatements .......................114\n        7.15.2. NETCONF XML Encoding Rules .......................114\n        7.15.3. Usage Example ....................................115\n   7.16. The \"notification\" Statement ............................116\n        7.16.1. The notification's Substatements .................117\n        7.16.2. NETCONF XML Encoding Rules .......................117\n        7.16.3. Usage Example ....................................118\n   7.17. The \"augment\" Statement .................................119\n        7.17.1. The augment's Substatements ......................121\n        7.17.2. XML Encoding Rules ...............................121\n        7.17.3. Usage Example ....................................122\n   7.18. The \"identity\" Statement ................................124\n        7.18.1. The identity's Substatements .....................124\n        7.18.2. The \"base\" Statement .............................124\n        7.18.3. Usage Example ....................................125\n   7.19. The \"extension\" Statement ...............................126\n        7.19.1. The extension's Substatements ....................126\n        7.19.2. The \"argument\" Statement .........................127\n        7.19.3. Usage Example ....................................127\n   7.20. Conformance-Related Statements ..........................128\n        7.20.1. The \"feature\" Statement ..........................128\n        7.20.2. The \"if-feature\" Statement .......................130\n        7.20.3. The \"deviation\" Statement ........................131\n   7.21. Common Statements .......................................134\n        7.21.1. The \"config\" Statement ...........................134\n        7.21.2. The \"status\" Statement ...........................135\n        7.21.3. The \"description\" Statement ......................136\n        7.21.4. The \"reference\" Statement ........................136\n        7.21.5. The \"when\" Statement .............................136\n8. Constraints ...................................................138\n   8.1. Constraints on Data ......................................138\n   8.2. Configuration Data Modifications .........................139\n   8.3. NETCONF Constraint Enforcement Model .....................139\n        8.3.1. Payload Parsing ...................................139\n        8.3.2. NETCONF <edit-config> Processing ..................140\n        8.3.3. Validation ........................................141\n9. Built-In Types ................................................141\n   9.1. Canonical Representation .................................141\n   9.2. The Integer Built-In Types ...............................142\n        9.2.1. Lexical Representation ............................142\n        9.2.2. Canonical Form ....................................143\n        9.2.3. Restrictions ......................................143\n        9.2.4. The \"range\" Statement .............................143\n        9.2.5. Usage Example .....................................144",
      "raw": true
    },
    {
      "indent": 6,
      "text": "9.3. The decimal64 Built-In Type ..............................144\n     9.3.1. Lexical Representation ............................145\n     9.3.2. Canonical Form ....................................145\n     9.3.3. Restrictions ......................................145\n     9.3.4. The \"fraction-digits\" Statement ...................145\n     9.3.5. Usage Example .....................................146\n9.4. The string Built-In Type .................................146\n     9.4.1. Lexical Representation ............................146\n     9.4.2. Canonical Form ....................................147\n     9.4.3. Restrictions ......................................147\n     9.4.4. The \"length\" Statement ............................147\n     9.4.5. The \"pattern\" Statement ...........................148\n     9.4.6. The \"modifier\" Statement ..........................148\n     9.4.7. Usage Example .....................................149\n9.5. The boolean Built-In Type ................................150\n     9.5.1. Lexical Representation ............................150\n     9.5.2. Canonical Form ....................................150\n     9.5.3. Restrictions ......................................150\n9.6. The enumeration Built-In Type ............................150\n     9.6.1. Lexical Representation ............................150\n     9.6.2. Canonical Form ....................................151\n     9.6.3. Restrictions ......................................151\n     9.6.4. The \"enum\" Statement ..............................151\n     9.6.5. Usage Example .....................................152\n9.7. The bits Built-In Type ...................................154\n     9.7.1. Restrictions ......................................154\n     9.7.2. Lexical Representation ............................154\n     9.7.3. Canonical Form ....................................154\n     9.7.4. The \"bit\" Statement ...............................155\n     9.7.5. Usage Example .....................................156\n9.8. The binary Built-In Type .................................157\n     9.8.1. Restrictions ......................................157\n     9.8.2. Lexical Representation ............................157\n     9.8.3. Canonical Form ....................................157\n9.9. The leafref Built-In Type ................................157\n     9.9.1. Restrictions ......................................158\n     9.9.2. The \"path\" Statement ..............................158\n     9.9.3. The \"require-instance\" Statement ..................159\n     9.9.4. Lexical Representation ............................159\n     9.9.5. Canonical Form ....................................159\n     9.9.6. Usage Example .....................................159\n9.10. The identityref Built-In Type ...........................163\n     9.10.1. Restrictions .....................................163\n     9.10.2. The identityref's \"base\" Statement ...............163\n     9.10.3. Lexical Representation ...........................163\n     9.10.4. Canonical Form ...................................164\n     9.10.5. Usage Example ....................................164",
      "raw": true
    },
    {
      "indent": 3,
      "text": "   9.11. The empty Built-In Type .................................165\n        9.11.1. Restrictions .....................................165\n        9.11.2. Lexical Representation ...........................165\n        9.11.3. Canonical Form ...................................165\n        9.11.4. Usage Example ....................................166\n   9.12. The union Built-In Type .................................166\n        9.12.1. Restrictions .....................................166\n        9.12.2. Lexical Representation ...........................166\n        9.12.3. Canonical Form ...................................167\n        9.12.4. Usage Example ....................................167\n   9.13. The instance-identifier Built-In Type ...................168\n        9.13.1. Restrictions .....................................168\n        9.13.2. Lexical Representation ...........................169\n        9.13.3. Canonical Form ...................................169\n        9.13.4. Usage Example ....................................169\n10. XPath Functions ..............................................170\n   10.1. Function for Node Sets ..................................170\n        10.1.1. current() ........................................170\n   10.2. Function for Strings ....................................170\n        10.2.1. re-match() .......................................170\n   10.3. Function for the YANG Types \"leafref\" and\n         \"instance-identifier\" ...................................171\n        10.3.1. deref() ..........................................171\n   10.4. Functions for the YANG Type \"identityref\" ...............172\n        10.4.1. derived-from() ...................................172\n        10.4.2. derived-from-or-self() ...........................174\n   10.5. Function for the YANG Type \"enumeration\" ................174\n        10.5.1. enum-value() .....................................174\n   10.6. Function for the YANG Type \"bits\" .......................175\n        10.6.1. bit-is-set() .....................................175\n11. Updating a Module ............................................176\n12. Coexistence with YANG Version 1 ..............................179\n13. YIN ..........................................................179\n   13.1. Formal YIN Definition ...................................180\n        13.1.1. Usage Example ....................................182\n14. YANG ABNF Grammar ............................................184\n15. NETCONF Error Responses for YANG-Related Errors ..............211\n   15.1. Error Message for Data That Violates a \"unique\"\n         Statement ...............................................211\n   15.2. Error Message for Data That Violates a\n         \"max-elements\" Statement ................................211\n   15.3. Error Message for Data That Violates a\n         \"min-elements\" Statement ................................211\n   15.4. Error Message for Data That Violates a \"must\"\n         Statement ...............................................212\n   15.5. Error Message for Data That Violates a\n         \"require-instance\" Statement ............................212",
      "raw": true
    },
    {
      "indent": 3,
      "text": "   15.6. Error Message for Data That Violates a Mandatory\n         \"choice\" Statement ......................................212\n   15.7. Error Message for the \"insert\" Operation ................212\n16. IANA Considerations ..........................................213\n17. Security Considerations ......................................213\n18. References ...................................................214\n   18.1. Normative References ....................................214\n   18.2. Informative References ..................................215\nAcknowledgements .................................................217\nContributors .....................................................217\nAuthor's Address .................................................217",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "YANG is a data modeling language originally designed to model configuration and state data manipulated by the Network Configuration Protocol (NETCONF), NETCONF Remote Procedure Calls, and NETCONF notifications [RFC6241]. Since the publication of YANG version 1 [RFC6020], YANG has been used or proposed to be used for other protocols (e.g., RESTCONF [RESTCONF] and the Constrained Application Protocol (CoAP) Management Interface (CoMI) [CoMI]). Further, encodings other than XML have been proposed (e.g., JSON [RFC7951]).",
      "ja": "YANGはもともとネットワーク構成プロトコル（NETCONF）、NETCONFリモートプロシージャコール、およびNETCONF通知[RFC6241]で操作した構成と状​​態データをモデル化するために設計されたデータモデリング言語です。 YANGバージョン1 [RFC6020]の出版以来、YANGは、使用されるか、または他のプロトコルのために使用することが提案されている（例えば、RESTCONF [RESTCONF]と制約アプリケーションプロトコル（CoAP）管理インターフェイス（COMI）COMI]）。さらに、XML以外のエンコーディングが提案されている（例えば、JSON [RFC7951]）。"
    },
    {
      "indent": 3,
      "text": "This document describes the syntax and semantics of version 1.1 of the YANG language. It also describes how a data model defined in a YANG module is encoded in the Extensible Markup Language (XML) [XML] and how NETCONF operations are used to manipulate the data. Other protocols and encodings are possible but are out of scope for this specification.",
      "ja": "この文書では、YANG言語のバージョン1.1の構文と意味を説明しています。また、[XML] YANGモジュールで定義されたデータモデルを拡張マークアップ言語（XML）で符号化される方法を説明し、データを操作するために使用される方法NETCONF操作。他のプロトコルとエンコーディングが可能であるが、この仕様の範囲外です。"
    },
    {
      "indent": 3,
      "text": "In terms of developing YANG data models, [YANG-Guidelines] provides some guidelines and recommendations.",
      "ja": "YANGデータモデルの開発の面では、[YANG-ガイドライン]いくつかのガイドラインと推奨事項を提供します。"
    },
    {
      "indent": 3,
      "text": "Note that this document does not obsolete RFC 6020 [RFC6020].",
      "ja": "この文書は時代遅れRFC 6020 [RFC6020]をしないことに注意してください。"
    },
    {
      "indent": 1,
      "text": "1.1. Summary of Changes from",
      "section_title": true,
      "ja": "1.1. からの変更点の概要"
    },
    {
      "indent": 3,
      "text": "This document defines version 1.1 of the YANG language. YANG version 1.1 is a maintenance release of the YANG language, addressing ambiguities and defects in the original specification [RFC6020].",
      "ja": "この文書では、YANG言語のバージョン1.1を定義します。 YANGバージョン1.1は、オリジナルの仕様[RFC6020]で曖昧と欠陥に対処する、YANG言語のメンテナンスリリースです。"
    },
    {
      "indent": 3,
      "text": "The following changes are not backward compatible with YANG version 1:",
      "ja": "次の変更はありませんYANGバージョン1との下位互換性があります。"
    },
    {
      "indent": 3,
      "text": "o Changed the rules for the interpretation of escaped characters in double-quoted strings. This is a backward-incompatible change from YANG version 1. When updating a YANG version 1 module to 1.1 and the module uses a character sequence that is now illegal, the string must be changed to match the new rules. See Section 6.1.3 for details.",
      "ja": "O二重引用符で囲まれた文字列内のエスケープ文字の解釈のルールを変更しました。これは、1.1にYANGバージョン1モジュールを更新し、モジュールは今違法である文字列を使用する場合、文字列は新しいルールに一致するように変更する必要がありYANGバージョン1から下位互換性のない変更です。詳細については、6.1.3項を参照してください。"
    },
    {
      "indent": 3,
      "text": "o An unquoted string cannot contain any single or double quote characters. This is a backward-incompatible change from YANG version 1. When updating a YANG version 1 module to 1.1 and the module uses such quote characters, the string must be changed to match the new rules. See Section 6.1.3 for details.",
      "ja": "O引用符で囲まれていない文字列は、任意の単一または二重引用符を含めることはできません。これは、1.1にYANGバージョン1モジュールを更新し、モジュールは、このような引用符を使用する場合、文字列は新しいルールに一致するように変更する必要がありYANGバージョン1から下位互換性のない変更です。詳細については、6.1.3項を参照してください。"
    },
    {
      "indent": 3,
      "text": "o Made \"when\" and \"if-feature\" illegal on list keys. This is a backward-incompatible change from YANG version 1. When updating a YANG version 1 module to 1.1 and the module uses these constructs, they must be removed to match the new rules.",
      "ja": "O製「とき」と「IF-機能」リストキー上の違法。これは、1.1にYANGバージョン1モジュールを更新し、モジュールは、これらの構造を使用すると、彼らは新しいルールに一致するために除去しなければならないYANGバージョン1から下位互換性のない変更です。"
    },
    {
      "indent": 3,
      "text": "o Defined the legal characters in YANG modules. When updating a YANG version 1 module to 1.1, any characters that are now illegal must be removed. See Section 6 for details.",
      "ja": "O YANGモジュールで有効な文字を定義しました。 1.1にYANGバージョン1モジュールを更新する場合、今違法な文字を削除する必要があります。詳細については、第6章を参照してください。"
    },
    {
      "indent": 3,
      "text": "o Made noncharacters illegal in the built-in type \"string\". This change affects the runtime behavior of YANG-based protocols.",
      "ja": "Oビルトイン型「string」で違法noncharactersを作りました。この変更は、YANGベースのプロトコルの実行時の動作に影響を与えます。"
    },
    {
      "indent": 3,
      "text": "The following additional changes have been done to YANG:",
      "ja": "次の追加の変更がYANGに行われています。"
    },
    {
      "indent": 3,
      "text": "o Changed the YANG version from \"1\" to \"1.1\".",
      "ja": "O「1.1」に「1」からYANGバージョンを変更しました。"
    },
    {
      "indent": 3,
      "text": "o Made the \"yang-version\" statement mandatory in YANG version \"1.1\".",
      "ja": "O「1.1」YANGバージョンで必須「ヤン・バージョン」声明を発表しました。"
    },
    {
      "indent": 3,
      "text": "o Extended the \"if-feature\" syntax to be a boolean expression over feature names.",
      "ja": "O機能名以上のブール式であることを、「IF-機能」構文を拡張。"
    },
    {
      "indent": 3,
      "text": "o Allow \"if-feature\" in \"bit\", \"enum\", and \"identity\".",
      "ja": "O「ビット」、「列挙型」、および「アイデンティティ」の「場合-機能」を許可。"
    },
    {
      "indent": 3,
      "text": "o Allow \"if-feature\" in \"refine\".",
      "ja": "o「の場合、機能」の「リファイン」を許可。"
    },
    {
      "indent": 3,
      "text": "o Allow \"choice\" as a shorthand \"case\" statement (see Section 7.9.2).",
      "ja": "O速記「ケース」の文（7.9.2項を参照）のように、「選択」を許可します。"
    },
    {
      "indent": 3,
      "text": "o Added a new substatement \"modifier\" to the \"pattern\" statement (see Section 9.4.6).",
      "ja": "O（9.4.6項を参照してください）「パターン」文に新しいサブステートメント「修飾子」を追加しました。"
    },
    {
      "indent": 3,
      "text": "o Allow \"must\" in \"input\", \"output\", and \"notification\".",
      "ja": "O「必要」で「入力」、「出力」、および「通知」を許可します。"
    },
    {
      "indent": 3,
      "text": "o Allow \"require-instance\" in leafref.",
      "ja": "O leafrefで「インスタンスを必要とする」許可。"
    },
    {
      "indent": 3,
      "text": "o Allow \"description\" and \"reference\" in \"import\" and \"include\".",
      "ja": "O「インポート」の「説明」と「参照」を許可し、「含みます」。"
    },
    {
      "indent": 3,
      "text": "o Allow imports of multiple revisions of a module.",
      "ja": "Oモジュールの複数のリビジョンの輸入を許可します。"
    },
    {
      "indent": 3,
      "text": "o Allow \"augment\" to add conditionally mandatory nodes (see Section 7.17).",
      "ja": "O条件付き必須ノード（セクション7.17を参照）を追加する「強化」を許可。"
    },
    {
      "indent": 3,
      "text": "o Added a set of new XML Path Language (XPath) functions in Section 10.",
      "ja": "Oセクション10に新しいXMLパス言語（XPath）関数のセットを追加しました。"
    },
    {
      "indent": 3,
      "text": "o Clarified the XPath context's tree in Section 6.4.1.",
      "ja": "O 6.4.1項でXPathコンテキストのツリーを明らかにしました。"
    },
    {
      "indent": 3,
      "text": "o Defined the string value of an identityref in XPath expressions (see Section 9.10).",
      "ja": "O（セクション9.10を参照）XPath式でidentityrefの文字列値を定義しました。"
    },
    {
      "indent": 3,
      "text": "o Clarified what unprefixed names mean in leafrefs in typedefs (see Sections 6.4.1 and 9.9.2).",
      "ja": "Oのtypedefでleafrefs（セクション6.4.1と9.9.2を参照）に接頭辞を何名の意味を明確にしました。"
    },
    {
      "indent": 3,
      "text": "o Allow identities to be derived from multiple base identities (see Sections 7.18 and 9.10).",
      "ja": "O（セクション7.18および9.10を参照）のアイデンティティは、複数の基地アイデンティティに由来することを許可します。"
    },
    {
      "indent": 3,
      "text": "o Allow enumerations and bits to be subtyped (see Sections 9.6 and 9.7).",
      "ja": "O列挙及びビットは（セクション9.6および9.7を参照）サブタイプを許可します。"
    },
    {
      "indent": 3,
      "text": "o Allow leaf-lists to have default values (see Section 7.7.2).",
      "ja": "O（セクション7.7.2を参照）リーフリストは、デフォルト値を持つことができるようにします。"
    },
    {
      "indent": 3,
      "text": "o Allow non-unique values in non-configuration leaf-lists (see Section 7.7).",
      "ja": "O（7.7節を参照）は、非コンフィギュレーション・リーフリストの非一意の値を許可。"
    },
    {
      "indent": 3,
      "text": "o Use syntax for case-sensitive strings (as per [RFC7405]) in the grammar.",
      "ja": "O文法で（[RFC7405]の通り）、大文字と小文字を区別した文字列の構文を使用します。"
    },
    {
      "indent": 3,
      "text": "o Changed the module advertisement mechanism (see Section 5.6.4).",
      "ja": "Oモジュール広告機構（5.6.4項を参照）を変更しました。"
    },
    {
      "indent": 3,
      "text": "o Changed the scoping rules for definitions in submodules. A submodule can now reference all definitions in all submodules that belong to the same module, without using the \"include\" statement.",
      "ja": "Oサブモジュール内の定義のためのスコープ規則を変更しました。サブモジュールは現在、「含める」ステートメントを使用せずに、同じモジュールに属するすべてのサブモジュール内のすべての定義を参照することができます。"
    },
    {
      "indent": 3,
      "text": "o Added a new statement \"action\", which is used to define operations tied to data nodes.",
      "ja": "Oデータノードに結び付け操作を定義するために使用される新しいステートメント「アクション」を、追加しました。"
    },
    {
      "indent": 3,
      "text": "o Allow notifications to be tied to data nodes.",
      "ja": "O通知はデータノードに接続することを許可します。"
    },
    {
      "indent": 3,
      "text": "o Added a new data definition statement \"anydata\" (see Section 7.10), which is RECOMMENDED to be used instead of \"anyxml\" when the data can be modeled in YANG.",
      "ja": "OデータがYANGでモデル化することができたときに代わりに「AnyXMLで」の使用が推奨されている新しいデータ定義文「ANYDATAを」（7.10節を参照）、追加しました。"
    },
    {
      "indent": 3,
      "text": "o Allow types \"empty\" and \"leafref\" in unions.",
      "ja": "Oタイプの「空」と労働組合の「leafref」許可。"
    },
    {
      "indent": 3,
      "text": "o Allow type \"empty\" in a key.",
      "ja": "Oキーを入力し、「空」を許可。"
    },
    {
      "indent": 3,
      "text": "o Removed the restriction that identifiers could not start with the characters \"xml\".",
      "ja": "O識別子は文字「XML」で始めることができなかった制約を削除しました。"
    },
    {
      "indent": 3,
      "text": "The following changes have been done to the NETCONF mapping:",
      "ja": "次の変更は、NETCONFマッピングに行われています。"
    },
    {
      "indent": 3,
      "text": "o A server advertises support for YANG 1.1 modules by using ietf-yang-library [RFC7895] instead of listing them as capabilities in the <hello> message.",
      "ja": "サーバーoをIETF-ヤン・ライブラリー[RFC7895]を使用する代わりに、<ハロー>メッセージ内の機能としてそれらをリストすることによってYANG 1.1モジュールのサポートをアドバタイズします。"
    },
    {
      "indent": 0,
      "text": "2. Key Words",
      "section_title": true,
      "ja": "2.キーワード"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119].",
      "ja": "キーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、 \"SHALL\"、 \"SHOULD\"、 \"ないもの\"、 \"推奨\" \"ない（SHOULD NOT）\"、 \"MAY\"、 \"推奨NOT\"、および「OPTIONAL BCP 14 [RFC2119]に記載されているように「この文書に解釈されるべきです。"
    },
    {
      "indent": 0,
      "text": "3. Terminology",
      "section_title": true,
      "ja": "3.用語"
    },
    {
      "indent": 3,
      "text": "The following terms are used within this document:",
      "ja": "以下の用語は、この文書内で使用されています。"
    },
    {
      "indent": 3,
      "text": "o action: An operation defined for a node in the data tree.",
      "ja": "Oアクション：データツリー内のノードに対して定義された操作。"
    },
    {
      "indent": 3,
      "text": "o anydata: A data node that can contain an unknown set of nodes that can be modeled by YANG, except anyxml.",
      "ja": "ANYDATA O：AnyXMLで除き、YANGによってモデル化することができるノードの未知のセットを含むことができるデータ・ノード。"
    },
    {
      "indent": 3,
      "text": "o anyxml: A data node that can contain an unknown chunk of XML data.",
      "ja": "O AnyXMLで：XMLデータの未知のチャンクを含むことができ、データノード。"
    },
    {
      "indent": 3,
      "text": "o augment: Adds new schema nodes to a previously defined schema node.",
      "ja": "O増強：以前に定義されたスキーマのノードに新しいスキーマノードを追加します。"
    },
    {
      "indent": 3,
      "text": "o base type: The type from which a derived type was derived, which may be either a built-in type or another derived type.",
      "ja": "O基本型：派生型が由来したタイプ、内蔵型または他の派生型のいずれであってもよいです。"
    },
    {
      "indent": 3,
      "text": "o built-in type: A YANG data type defined in the YANG language, such as uint32 or string.",
      "ja": "O内蔵型：YANG言語で定義されYANGデータ型などUINT32またはストリング。"
    },
    {
      "indent": 3,
      "text": "o choice: A schema node where only one of a number of identified alternatives is valid.",
      "ja": "Oの選択：のみ1つの識別された選択肢の数のが有効であるスキーマノード。"
    },
    {
      "indent": 3,
      "text": "o client: An entity that can access YANG-defined data on a server, over some network management protocol.",
      "ja": "Oクライアント：一部のネットワーク管理プロトコルを介して、サーバー上YANG定義のデータにアクセスすることができますエンティティ。"
    },
    {
      "indent": 3,
      "text": "o conformance: A measure of how accurately a server follows a data model.",
      "ja": "O適合：サーバがデータモデルを、以下の方法を正確に測定します。"
    },
    {
      "indent": 3,
      "text": "o container: An interior data node that exists in at most one instance in the data tree. A container has no value, but rather a set of child nodes.",
      "ja": "Oコンテナ：データツリー内で多くても1つのインスタンス内に存在する内部データ・ノード。コンテナは値ではなく、子ノードのセットを持っていません。"
    },
    {
      "indent": 3,
      "text": "o data definition statement: A statement that defines new data nodes. One of \"container\", \"leaf\", \"leaf-list\", \"list\", \"choice\", \"case\", \"augment\", \"uses\", \"anydata\", and \"anyxml\".",
      "ja": "Oデータ定義文：新しいデータノードを定義する声明。 「コンテナ」、「葉」、「リーフリスト」、「リスト」、「選択」、「ケース」、「強化」、「用途」、「ANYDATA」、および「AnyXMLで」の一つ。"
    },
    {
      "indent": 3,
      "text": "o data model: A data model describes how data is represented and accessed.",
      "ja": "Oデータモデル：データモデルはデータを表現し、アクセスされる方法を説明します。"
    },
    {
      "indent": 3,
      "text": "o data node: A node in the schema tree that can be instantiated in a data tree. One of container, leaf, leaf-list, list, anydata, and anyxml.",
      "ja": "Oデータノード：データツリーでインスタンス化することができるスキーマ・ツリー内のノード。コンテナ、葉、葉、リスト、リスト、ANYDATA、およびAnyXMLでの一つ。"
    },
    {
      "indent": 3,
      "text": "o data tree: An instantiated tree of any data modeled with YANG, e.g., configuration data, state data, combined configuration and state data, RPC or action input, RPC or action output, or notification.",
      "ja": "Oデータ・ツリー：YANGでモデル化する任意のデータのインスタンス化された木、例えば、構成データ、状態データ、複合構成と状態データ、RPCまたはアクション入力、RPCまたはアクション出力、または通知。"
    },
    {
      "indent": 3,
      "text": "o derived type: A type that is derived from a built-in type (such as uint32) or another derived type.",
      "ja": "O構造型：ビルトインタイプ（例えばUINT32など）、または他の構造型に由来するタイプ。"
    },
    {
      "indent": 3,
      "text": "o extension: An extension attaches non-YANG semantics to statements. The \"extension\" statement defines new statements to express these semantics.",
      "ja": "O拡張：拡張機能は、書類の非YANGセマンティクスを添付する。 「拡張子」の文では、これらのセマンティクスを表現するために新しいステートメントを定義します。"
    },
    {
      "indent": 3,
      "text": "o feature: A mechanism for marking a portion of the model as optional. Definitions can be tagged with a feature name and are only valid on servers that support that feature.",
      "ja": "O機能：オプションとして、モデルの部分をマーキングするための機構。定義は機能名でタグ付けし、その機能をサポートするサーバー上でのみ有効であることができます。"
    },
    {
      "indent": 3,
      "text": "o grouping: A reusable set of schema nodes, which may be used locally in the module and by other modules that import from it. The \"grouping\" statement is not a data definition statement and, as such, does not define any nodes in the schema tree.",
      "ja": "Oグルーピング：モジュールで、そこからインポート他のモジュールによって局所的に使用することができるスキーマ・ノードの再利用可能なセット。 「グループ化」の文は、次のような、スキーマツリーの任意のノードを定義していない、データ定義文ではありませんと。"
    },
    {
      "indent": 3,
      "text": "o identifier: A string used to identify different kinds of YANG items by name.",
      "ja": "O識別子：名でYANG項目の種類を識別するために使用される文字列。"
    },
    {
      "indent": 3,
      "text": "o identity: A globally unique, abstract, and untyped name.",
      "ja": "Oアイデンティティ：グローバル、ユニークな抽象的、および型なし名前。"
    },
    {
      "indent": 3,
      "text": "o instance identifier: A mechanism for identifying a particular node in a data tree.",
      "ja": "Oインスタンス識別子：データツリー内の特定のノードを識別するためのメカニズム。"
    },
    {
      "indent": 3,
      "text": "o interior node: Nodes within a hierarchy that are not leaf nodes.",
      "ja": "内部ノードO：リーフノードでない階層内のノード。"
    },
    {
      "indent": 3,
      "text": "o leaf: A data node that exists in at most one instance in the data tree. A leaf has a value but no child nodes.",
      "ja": "O葉：データツリー内で多くても1つのインスタンス内に存在するデータノード。葉は、値ではなく、子ノードを持っています。"
    },
    {
      "indent": 3,
      "text": "o leaf-list: Like the leaf node but defines a set of uniquely identifiable nodes rather than a single node. Each node has a value but no child nodes.",
      "ja": "Oリーフリスト：リーフノードと同様なく一意に識別可能なノードのセットではなく、単一のノードを定義します。各ノードは、値ではなく、子ノードを持っています。"
    },
    {
      "indent": 3,
      "text": "o list: An interior data node that may exist in multiple instances in the data tree. A list has no value, but rather a set of child nodes.",
      "ja": "Oリスト：データツリー内の複数のインスタンス内に存在し得る内部データ・ノード。リストは値ではなく、子ノードのセットを持っていません。"
    },
    {
      "indent": 3,
      "text": "o mandatory node: A mandatory node is one of:",
      "ja": "O必須ノード：必須のノードは次のいずれかです。"
    },
    {
      "indent": 6,
      "text": "* A leaf, choice, anydata, or anyxml node with a \"mandatory\" statement with the value \"true\".",
      "ja": "*「真」の値を持つ「必須」の文と葉、選択肢、ANYDATA、またはAnyXMLでノード。"
    },
    {
      "indent": 6,
      "text": "* A list or leaf-list node with a \"min-elements\" statement with a value greater than zero.",
      "ja": "*ゼロよりも大きい値を有する「MIN-要素」文を使用してリストまたはリーフノードリスト。"
    },
    {
      "indent": 6,
      "text": "* A container node without a \"presence\" statement and that has at least one mandatory node as a child.",
      "ja": "「プレゼンス」の文なし*コンテナノードとその子のように、少なくとも1つの必須のノードを持っています。"
    },
    {
      "indent": 3,
      "text": "o module: A YANG module defines hierarchies of schema nodes. With its definitions and the definitions it imports or includes from elsewhere, a module is self-contained and \"compilable\".",
      "ja": "Oモジュール：YANGモジュールは、スキーマ・ノードの階層を定義します。その定義と、それは他の場所からの輸入または含ま定義で、モジュールは、自己完結型と「コンパイル」です。"
    },
    {
      "indent": 3,
      "text": "o non-presence container: A container that has no meaning of its own, existing only to contain child nodes.",
      "ja": "O非存在コンテナ：子ノードを格納するだけで、既存の、それ自身の意味を持たないコンテナ。"
    },
    {
      "indent": 3,
      "text": "o presence container: A container where the presence of the container itself carries some meaning.",
      "ja": "Oプレゼンスコンテナ：コンテナ自体の存在は、いくつかの意味を運ぶ容器。"
    },
    {
      "indent": 3,
      "text": "o RPC: A Remote Procedure Call.",
      "ja": "OのRPC：リモートプロシージャコール。"
    },
    {
      "indent": 3,
      "text": "o RPC operation: A specific Remote Procedure Call.",
      "ja": "OのRPC操作：特定のリモートプロシージャコール。"
    },
    {
      "indent": 3,
      "text": "o schema node: A node in the schema tree. One of action, container, leaf, leaf-list, list, choice, case, rpc, input, output, notification, anydata, and anyxml.",
      "ja": "Oスキーマノード：スキーマ・ツリー内のノード。アクション、コンテナ、葉、葉、リスト、リスト、選択、場合、RPC、入力、出力、通知、ANYDATA、およびAnyXMLでの一つ。"
    },
    {
      "indent": 3,
      "text": "o schema node identifier: A mechanism for identifying a particular node in the schema tree.",
      "ja": "Oスキーマノード識別子：スキーマ・ツリー内の特定のノードを識別するためのメカニズム。"
    },
    {
      "indent": 3,
      "text": "o schema tree: The definition hierarchy specified within a module.",
      "ja": "Oスキーマツリー：モジュール内で指定された定義の階層。"
    },
    {
      "indent": 3,
      "text": "o server: An entity that provides access to YANG-defined data to a client, over some network management protocol.",
      "ja": "Oサーバ：一部のネットワーク管理プロトコルを介して、クライアントへYANG、定義されたデータへのアクセスを提供するエンティティ。"
    },
    {
      "indent": 3,
      "text": "o server deviation: A failure of the server to implement a module faithfully.",
      "ja": "Oサーバ偏差：忠実モジュールを実装するサーバの障害。"
    },
    {
      "indent": 3,
      "text": "o submodule: A partial module definition that contributes derived types, groupings, data nodes, RPCs, actions, and notifications to a module. A YANG module can be constructed from a number of submodules.",
      "ja": "Oサブモジュール：モジュールに派生タイプ、グループ、データノード、のRPC、アクション、および通知に寄与する部分モジュール定義。 YANGモジュールは、サブモジュールの数から構成することができます。"
    },
    {
      "indent": 3,
      "text": "o top-level data node: A data node where there is no other data node between it and a \"module\" or \"submodule\" statement.",
      "ja": "Oトップレベル・データ・ノード：ITと「モジュール」または「サブモジュール」ステートメントの間には他のデータノードが存在しないデータ・ノード。"
    },
    {
      "indent": 3,
      "text": "o uses: The \"uses\" statement is used to instantiate the set of schema nodes defined in a \"grouping\" statement. The instantiated nodes may be refined and augmented to tailor them to any specific needs.",
      "ja": "oは使用：文は「グルーピング」ステートメントで定義されたスキーマ・ノードのセットをインスタンス化するために使用される「使用します」。インスタンス化されたノードは、洗練さと任意の特定のニーズにそれらを調整するように拡張することができます。"
    },
    {
      "indent": 3,
      "text": "o value space: For a data type; the set of values permitted by the data type. For a leaf or leaf-list instance; the value space of its data type.",
      "ja": "O値空間：データ・タイプについて、データタイプによって許可された値のセット。葉または葉のリストたとえば、そのデータ型の値空間。"
    },
    {
      "indent": 3,
      "text": "The following terms are defined in [RFC6241]:",
      "ja": "以下の用語は[RFC6241]で定義されています。"
    },
    {
      "indent": 3,
      "text": "o configuration data",
      "ja": "O構成データ"
    },
    {
      "indent": 3,
      "text": "o configuration datastore",
      "ja": "O構成データストア"
    },
    {
      "indent": 3,
      "text": "o datastore",
      "ja": "Oデータストア"
    },
    {
      "indent": 3,
      "text": "o state data",
      "ja": "O状態データ"
    },
    {
      "indent": 3,
      "text": "When modeled with YANG, a datastore is realized as an instantiated data tree.",
      "ja": "YANGでモデル化する場合、データストアは、インスタンス化されたデータツリーとして実現されています。"
    },
    {
      "indent": 3,
      "text": "When modeled with YANG, a configuration datastore is realized as an instantiated data tree with configuration data.",
      "ja": "YANGでモデル化すると、構成データストアは、構成データでインスタンス化データツリーとして実現されます。"
    },
    {
      "indent": 0,
      "text": "3.1. A Note on Examples",
      "section_title": true,
      "ja": "3.1. 例上の注意事項"
    },
    {
      "indent": 3,
      "text": "Throughout this document, there are many examples of YANG statements. These examples are supposed to illustrate certain features and are not supposed to be complete, valid YANG modules.",
      "ja": "本書では、YANG文の多くの例があります。これらの例は、特定の機能を説明することになっていると、完全な、有効なYANGモジュールであることを想定されていません。"
    },
    {
      "indent": 0,
      "text": "4. YANG Overview",
      "section_title": true,
      "ja": "4. THAT概要"
    },
    {
      "indent": 3,
      "text": "This non-normative section is intended to give a high-level overview of YANG to first-time readers.",
      "ja": "この非標準部が初めて読者にYANGの高レベルの概要を与えることを意図しています。"
    },
    {
      "indent": 0,
      "text": "4.1. Functional Overview",
      "section_title": true,
      "ja": "4.1. 機能の概要"
    },
    {
      "indent": 3,
      "text": "YANG is a language originally designed to model data for the NETCONF protocol. A YANG module defines hierarchies of data that can be used for NETCONF-based operations, including configuration, state data, RPCs, and notifications. This allows a complete description of all data sent between a NETCONF client and server. Although out of scope for this specification, YANG can also be used with protocols other than NETCONF.",
      "ja": "YANGはもともとNETCONFプロトコルのデータをモデル化するために設計された言語です。 YANGモジュールは、設定、状態データ、のRPC、および通知を含むNETCONFベースの操作に用いることができるデータの階層を定義します。これは、NETCONFクライアントとサーバ間で送信されるすべてのデータの完全な記述を可能にします。本明細書の範囲外が、YANGもNETCONF以外のプロトコルで使用することができます。"
    },
    {
      "indent": 3,
      "text": "YANG models the hierarchical organization of data as a tree in which each node has a name, and either a value or a set of child nodes. YANG provides clear and concise descriptions of the nodes, as well as the interaction between those nodes.",
      "ja": "YANGモデルの各ノードは、名前を有する、木、及び値のいずれか、または子ノードのセットとしてデータの階層構造。 YANGは、明確かつ簡潔なノードの記述、ならびにそれらのノードとの間の相互作用を提供します。"
    },
    {
      "indent": 3,
      "text": "YANG structures data models into modules and submodules. A module can import definitions from other external modules and can include definitions from submodules. The hierarchy can be augmented, allowing one module to add data nodes to the hierarchy defined in another module. This augmentation can be conditional, with new nodes appearing only if certain conditions are met.",
      "ja": "モジュールおよびサブモジュールにYANG構造のデータモデル。モジュールは、他の外部モジュールから定義をインポートすることができ、サブモジュールの定義を含むことができます。階層は、一つのモジュールが他のモジュールで定義された階層にデータノードを追加することを可能にする、増強することができます。この増加は、特定の条件が満たされた場合にのみ登場する新しいノードで、条件を付けることができます。"
    },
    {
      "indent": 3,
      "text": "YANG data models can describe constraints to be enforced on the data, restricting the presence or value of nodes based on the presence or value of other nodes in the hierarchy. These constraints are enforceable by either the client or the server.",
      "ja": "YANGデータモデルは、階層内の他のノードの存在又は値に基づいて存在またはノードの値を制限し、データに適用される制約を記述することができます。これらの制約は、クライアントまたはサーバによって強制力があります。"
    },
    {
      "indent": 3,
      "text": "YANG defines a set of built-in types and has a type mechanism through which additional types may be defined. Derived types can restrict their base type's set of valid values using mechanisms like range or pattern restrictions that can be enforced by clients or servers. They can also define usage conventions for use of the derived type, such as a string-based type that contains a hostname.",
      "ja": "YANGは、組み込み型のセットを定義し、追加のタイプを定義することができるスルー型機構を有します。派生型は、クライアントまたはサーバによって強制できる範囲やパターンの制約などのメカニズムを使用して、有効な値の彼らの基本型のセットを制限することができます。彼らはまた、そのようなホスト名を含む文字列ベースの型として派生型の使用のための使用規則を定義することができます。"
    },
    {
      "indent": 3,
      "text": "YANG permits the definition of reusable groupings of nodes. The usage of these groupings can refine or augment the nodes, allowing it to tailor the nodes to its particular needs. Derived types and groupings can be defined in one module and used in either the same module or another module that imports it.",
      "ja": "YANGは、ノードの再利用可能なグループの定義が可能になります。これらのグループの使用は、その特定のニーズにノードを調整することができ、ノードを絞り込むまたは拡張することができます。派生型とグループ化は、一つのモジュールで定義されており、同一のモジュールまたはそれをインポートする別のモジュールのいずれかで使用することができます。"
    },
    {
      "indent": 3,
      "text": "YANG data hierarchy constructs include defining lists where list entries are identified by keys that distinguish them from each other. Such lists may be defined as either sorted by user or automatically sorted by the system. For user-sorted lists, operations are defined for manipulating the order of the list entries.",
      "ja": "YANGデータの階層構造は、リストのエントリは、互いに区別キーで識別される定義のリストが含まれます。ユーザによってソートまたはシステムによって自動的にソートのいずれかとして、このようなリストが定義されてもよいです。ユーザーソートリストでは、操作は、リストのエントリの順序を操作するために定義されています。"
    },
    {
      "indent": 3,
      "text": "YANG modules can be translated into an equivalent XML syntax called YANG Independent Notation (YIN) (Section 13), allowing applications using XML parsers and Extensible Stylesheet Language Transformations (XSLT) scripts to operate on the models. The conversion from YANG to YIN is semantically lossless, so content in YIN can be round-tripped back into YANG.",
      "ja": "YANGモジュールは、モデル上で動作するためにXMLパーサを使用して、アプリケーションや拡張スタイルシート言語変換（XSLT）スクリプトを許可する、YANG独立表記（YIN）（第13条）と呼ばれる同等のXML構文に変換することができます。 YINへYANGからの変換は、意味的に可逆であるので、YINにおける含有量は、バックYANGへのラウンドトリップであってもよいです。"
    },
    {
      "indent": 3,
      "text": "YANG is an extensible language, allowing extensions to be defined by standards bodies, vendors, and individuals. The statement syntax allows these extensions to coexist with standard YANG statements in a natural way, while extensions in a YANG module stand out sufficiently for the reader to notice them.",
      "ja": "YANGは、拡張機能が標準化団体、ベンダー、および個人によって定義することができるように、拡張可能な言語です。 YANGモジュール内の拡張子がそれらに気づくために、読者のために十分に目立つ一方、文の構文は、これらの拡張機能は、自然な方法で標準YANG文と共存することができます。"
    },
    {
      "indent": 3,
      "text": "YANG resists the tendency to solve all possible problems, limiting the problem space to allow expression of data models for network management protocols such as NETCONF, not arbitrary XML documents or arbitrary data models.",
      "ja": "YANGは、NETCONFなどのネットワーク管理プロトコルではなく、任意のXML文書または任意のデータモデルのデータモデルの発現を可能にする問題空間を制限し、可能なすべての問題を解決する傾向に抵抗します。"
    },
    {
      "indent": 3,
      "text": "To the extent possible, YANG maintains compatibility with the Simple Network Management Protocol's (SNMP's) SMIv2 (Structure of Management Information version 2 [RFC2578] [RFC2579]). SMIv2-based MIB modules can be automatically translated into YANG modules for read-only access [RFC6643]. However, YANG is not concerned with reverse translation from YANG to SMIv2.",
      "ja": "可能な限り、YANGは、簡易ネットワーク管理プロトコルの（SNMPの）のSMIv2（経営情報バージョン2の構造[RFC2578] [RFC2579]）との互換性を維持します。 SMIv2のベースMIBモジュールは自動的に読み取り専用のアクセス[RFC6643]のためのYANGモジュールに変換することができます。しかし、YANGはYANGからのSMIv2への逆変換と心配していないです。"
    },
    {
      "indent": 0,
      "text": "4.2. Language Overview",
      "section_title": true,
      "ja": "4.2. 言語の概要"
    },
    {
      "indent": 3,
      "text": "This section introduces some important constructs used in YANG that will aid in the understanding of the language specifics in later sections.",
      "ja": "このセクションでは、後のセクションでは、言語仕様の理解を助けるだろうYANGで使用されるいくつかの重要な構成要素を紹介します。"
    },
    {
      "indent": 0,
      "text": "4.2.1. Modules and Submodules",
      "section_title": true,
      "ja": "4.2.1. モジュールおよびサブモジュール"
    },
    {
      "indent": 3,
      "text": "YANG data models are defined in modules. A module contains a collection of related definitions.",
      "ja": "YANGデータモデルは、モジュールで定義されています。モジュールは、関連定義の集合が含まれています。"
    },
    {
      "indent": 3,
      "text": "A module contains three types of statements: module header statements, \"revision\" statements, and definition statements. The module header statements describe the module and give information about the module itself, the \"revision\" statements give information about the history of the module, and the definition statements are the body of the module where the data model is defined.",
      "ja": "モジュールヘッダ文、「改訂」文、定義文：モジュールは、3つの文のタイプを含みます。モジュールヘッダ文はモジュールを記述し、モジュール自体に関する情報を提供し、「改訂」ステートメントは、モジュールの履歴に関する情報を与え、定義文は、データ・モデルが定義されているモジュールの本体です。"
    },
    {
      "indent": 3,
      "text": "A server may implement a number of modules, allowing multiple views of the same data or multiple views of disjoint subsections of the server's data. Alternatively, the server may implement only one module that defines all available data.",
      "ja": "サーバは、同一のデータまたはサーバのデータの互いに素なサブセクションの複数のビューの複数のビューを可能にする、多数のモジュールを実装することができます。代替的に、サーバは、利用可能なすべてのデータを定義する唯一のモジュールを実装することができます。"
    },
    {
      "indent": 3,
      "text": "A module may have portions of its definitions separated into submodules, based on the needs of the module designer. The external view remains that of a single module, regardless of the presence or size of its submodules.",
      "ja": "モジュールは、モジュール設計者のニーズに基づいて、サブモジュールに分け、その定義の部分を有していてもよいです。外観に関係なく、そのサブモジュールの存在または大きさの、単一のモジュールのままです。"
    },
    {
      "indent": 3,
      "text": "The \"import\" statement allows a module or submodule to reference definitions defined in other modules.",
      "ja": "「インポート」ステートメントは、モジュールまたはサブモジュールが他のモジュールで定義された定義を参照することを可能にします。"
    },
    {
      "indent": 3,
      "text": "The \"include\" statement is used in a module to identify each submodule that belongs to it.",
      "ja": "「含める」ステートメントは、それに属する各サブモジュールを識別するためのモジュールで使用されています。"
    },
    {
      "indent": 0,
      "text": "4.2.2. Data Modeling Basics",
      "section_title": true,
      "ja": "4.2.2. データモデリングの基礎"
    },
    {
      "indent": 3,
      "text": "YANG defines four main types of data nodes for data modeling. In each of the following subsections, the examples show the YANG syntax as well as a corresponding XML encoding. The syntax of YANG statements is defined in Section 6.3.",
      "ja": "YANGは、データ・モデリングのためのデータノードの4つの主要なタイプを定義します。以下のサブセクションの各々において、実施例は、YANG構文ならびに対応するXMLエンコーディングを示します。 YANG文の構文はセクション6.3で定義されています。"
    },
    {
      "indent": 0,
      "text": "4.2.2.1. Leaf Nodes",
      "section_title": true,
      "ja": "4.2.2.1。リーフノード"
    },
    {
      "indent": 3,
      "text": "A leaf instance contains simple data like an integer or a string. It has exactly one value of a particular type and no child nodes.",
      "ja": "葉のインスタンスは、整数や文字列などの単純なデータが含まれています。これは、1つの特定の型の値と子ノードを持っています。"
    },
    {
      "indent": 3,
      "text": "YANG Example:",
      "ja": "例："
    },
    {
      "indent": 5,
      "text": "leaf host-name {\n  type string;\n  description\n    \"Hostname for this system.\";\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "XML Encoding Example:",
      "ja": "XMLエンコーディング例："
    },
    {
      "indent": 5,
      "text": "<host-name>my.example.com</host-name>",
      "ja": "<ホスト名> my.example.com </ホスト名>"
    },
    {
      "indent": 3,
      "text": "The \"leaf\" statement is covered in Section 7.6.",
      "ja": "「リーフ」の文は、7.6節で覆われています。"
    },
    {
      "indent": 0,
      "text": "4.2.2.2. Leaf-List Nodes",
      "section_title": true,
      "ja": "4.2.2.2。リーフ・リストのノード"
    },
    {
      "indent": 3,
      "text": "A leaf-list defines a sequence of values of a particular type.",
      "ja": "リーフリストは、特定タイプの値のシーケンスを定義します。"
    },
    {
      "indent": 3,
      "text": "YANG Example:",
      "ja": "例："
    },
    {
      "indent": 5,
      "text": "leaf-list domain-search {\n  type string;\n  description\n    \"List of domain names to search.\";\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "XML Encoding Example:",
      "ja": "XMLエンコーディング例："
    },
    {
      "indent": 5,
      "text": "<domain-search>high.example.com</domain-search> <domain-search>low.example.com</domain-search> <domain-search>everywhere.example.com</domain-search>",
      "ja": "<ドメイン検索> high.example.com </ドメイン検索> <ドメイン検索> low.example.com </ドメイン検索> <ドメイン検索> everywhere.example.com </ドメイン検索>"
    },
    {
      "indent": 3,
      "text": "The \"leaf-list\" statement is covered in Section 7.7.",
      "ja": "「リーフリスト」文は、セクション7.7に覆われています。"
    },
    {
      "indent": 0,
      "text": "4.2.2.3. Container Nodes",
      "section_title": true,
      "ja": "4.2.2.3。コンテナノード"
    },
    {
      "indent": 3,
      "text": "A container is used to group related nodes in a subtree. A container has only child nodes and no value. A container may contain any number of child nodes of any type (leafs, lists, containers, leaf-lists, actions, and notifications).",
      "ja": "容器は、サブツリー内のグループに関連するノードに使用されます。コンテナは、唯一の子ノードと無価値を持っています。コンテナは、任意のタイプ（葉、リスト、コンテナ、リーフリスト、アクション、および通知）の子ノードの任意の数を含めることができます。"
    },
    {
      "indent": 3,
      "text": "YANG Example:",
      "ja": "例："
    },
    {
      "indent": 5,
      "text": "container system {\n  container login {\n    leaf message {\n      type string;\n      description\n        \"Message given at start of login session.\";\n    }\n  }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "XML Encoding Example:",
      "ja": "XMLエンコーディング例："
    },
    {
      "indent": 5,
      "text": "<system> <login> <message>Good morning</message> </login> </system>",
      "ja": "<システム> <ログイン> <メッセージ>おはよう</メッセージ> </ LOGIN> </システム>"
    },
    {
      "indent": 3,
      "text": "The \"container\" statement is covered in Section 7.5.",
      "ja": "「コンテナ」の文は、7.5節で覆われています。"
    },
    {
      "indent": 0,
      "text": "4.2.2.4. List Nodes",
      "section_title": true,
      "ja": "4.2.2.4。リストノード"
    },
    {
      "indent": 3,
      "text": "A list defines a sequence of list entries. Each entry is like a container and is uniquely identified by the values of its key leafs if it has any key leafs defined. A list can define multiple key leafs and may contain any number of child nodes of any type (including leafs, lists, containers, etc.).",
      "ja": "リストは、リストのエントリのシーケンスを定義します。各エントリは、コンテナのようであり、それは定義された任意のキー葉を持っている場合、一意のキーリーフの値によって識別されます。リストには、複数のキー葉を定義することができ、（リーフ、リスト、コンテナ等を含む）任意のタイプの子ノードの任意の数を含んでいてもよいです。"
    },
    {
      "indent": 3,
      "text": "YANG Example:",
      "ja": "例："
    },
    {
      "indent": 5,
      "text": "list user {\n  key \"name\";\n  leaf name {\n    type string;\n  }\n  leaf full-name {\n    type string;\n  }\n  leaf class {\n    type string;\n  }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "XML Encoding Example:",
      "ja": "XMLエンコーディング例："
    },
    {
      "indent": 5,
      "text": "<user> <name>glocks</name> <full-name>Goldie Locks</full-name> <class>intruder</class> </user> <user> <name>snowey</name> <full-name>Snow White</full-name> <class>free-loader</class> </user> <user> <name>rzell</name> <full-name>Rapun Zell</full-name> <class>tower</class> </user>",
      "ja": "<ユーザー> <名前> glocks </名前> <フルネーム>ゴールディロック</フル名> <クラス>侵入者</クラス> </ユーザー> <ユーザー> <名前> snowey </名前> <フル名前>白雪姫</フル名> <クラス>フリーローダー</クラス> </ユーザー> <ユーザー> <名前> rzell </名前> <フルネーム> Rapunツェル</フル名> <クラス>タワー</クラス> </ユーザー>"
    },
    {
      "indent": 3,
      "text": "The \"list\" statement is covered in Section 7.8.",
      "ja": "「リスト」文は7.8節で覆われています。"
    },
    {
      "indent": 0,
      "text": "4.2.2.5. Example Module",
      "section_title": true,
      "ja": "4.2.2.5。例モジュール"
    },
    {
      "indent": 3,
      "text": "These statements are combined to define the module:",
      "ja": "これらのステートメントは、モジュールを定義するために組み合わされます。"
    },
    {
      "indent": 5,
      "text": "// Contents of \"example-system.yang\"\nmodule example-system {\n  yang-version 1.1;\n  namespace \"urn:example:system\";\n  prefix \"sys\";",
      "raw": true
    },
    {
      "indent": 7,
      "text": "organization \"Example Inc.\";\ncontact \"joe@example.com\";\ndescription\n  \"The module for entities implementing the Example system.\";",
      "raw": true
    },
    {
      "indent": 7,
      "text": "revision 2007-06-09 { description \"Initial revision.\"; }",
      "ja": "リビジョン2007-06-09 {説明「初期リビジョン。」; }"
    },
    {
      "indent": 7,
      "text": "container system {\n  leaf host-name {\n    type string;\n    description\n      \"Hostname for this system.\";\n  }",
      "raw": true
    },
    {
      "indent": 9,
      "text": "leaf-list domain-search {\n  type string;\n  description\n    \"List of domain names to search.\";\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "    container login {\n      leaf message {\n        type string;\n        description\n          \"Message given at start of login session.\";\n      } list user {\n        key \"name\";\n        leaf name {\n          type string;\n        }\n        leaf full-name {\n          type string;\n        }\n        leaf class {\n          type string;\n        }\n      }\n    }\n  }\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.2.3. Configuration and State Data",
      "section_title": true,
      "ja": "4.2.3. 設定と状態データ"
    },
    {
      "indent": 3,
      "text": "YANG can model state data, as well as configuration data, based on the \"config\" statement. When a node is tagged with \"config false\", its subhierarchy is flagged as state data. If it is tagged with \"config true\", its subhierarchy is flagged as configuration data. Parent containers, lists, and key leafs are reported also, giving the context for the state data.",
      "ja": "YANGは、「設定」の文に基づいて、状態データ、並びに構成データをモデル化することができます。ノードは「設定偽」でタグ付けされた場合、その下位階層は、状態データとしてフラグが立てられます。それは「本当の設定」でタグ付けされている場合は、そのサブ階層は、構成データとしてフラグが立てられています。親コンテナ、リスト、およびキー葉は、状態データのコンテキストを与えることも報告されています。"
    },
    {
      "indent": 3,
      "text": "In this example, two leafs are defined for each interface, a configured speed and an observed speed.",
      "ja": "この例では、2つのリーフは、各インターフェイス、設定された速度と観測速度のために定義されています。"
    },
    {
      "indent": 5,
      "text": "list interface {\n  key \"name\";\n  config true;",
      "raw": true
    },
    {
      "indent": 5,
      "text": "  leaf name {\n    type string;\n  }\n  leaf speed {\n    type enumeration {\n      enum 10m;\n      enum 100m;\n      enum auto;\n    }\n  }\n  leaf observed-speed {\n    type uint32;\n    config false;\n  }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The \"config\" statement is covered in Section 7.21.1.",
      "ja": "「設定」の文は、セクション7.21.1に覆われています。"
    },
    {
      "indent": 0,
      "text": "4.2.4. Built-In Types",
      "section_title": true,
      "ja": "4.2.4. 組み込み型"
    },
    {
      "indent": 3,
      "text": "YANG has a set of built-in types, similar to those of many programming languages, but with some differences due to special requirements of network management. The following table summarizes the built-in types discussed in Section 9:",
      "ja": "YANGは、多くのプログラミング言語と同様のビルトインタイプのセットを、持っていますが、ネットワーク管理の特殊な要件のためにいくつかの違いで。次の表は、第9章で述べたビルトインタイプを要約したものです。"
    },
    {
      "indent": 7,
      "text": "+---------------------+-------------------------------------+\n| Name                | Description                         |\n+---------------------+-------------------------------------+\n| binary              | Any binary data                     |\n| bits                | A set of bits or flags              |\n| boolean             | \"true\" or \"false\"                   |\n| decimal64           | 64-bit signed decimal number        |\n| empty               | A leaf that does not have any value |\n| enumeration         | One of an enumerated set of strings |\n| identityref         | A reference to an abstract identity |\n| instance-identifier | A reference to a data tree node     |\n| int8                | 8-bit signed integer                |\n| int16               | 16-bit signed integer               |\n| int32               | 32-bit signed integer               |\n| int64               | 64-bit signed integer               |\n| leafref             | A reference to a leaf instance      |\n| string              | A character string                  |\n| uint8               | 8-bit unsigned integer              |\n| uint16              | 16-bit unsigned integer             |\n| uint32              | 32-bit unsigned integer             |\n| uint64              | 64-bit unsigned integer             |\n| union               | Choice of member types              |\n+---------------------+-------------------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The \"type\" statement is covered in Section 7.4.",
      "ja": "「タイプ」の文は、7.4節で覆われています。"
    },
    {
      "indent": 0,
      "text": "4.2.5. Derived Types (typedef)",
      "section_title": true,
      "ja": "4.2.5. 派生型（のtypedef）"
    },
    {
      "indent": 3,
      "text": "YANG can define derived types from base types using the \"typedef\" statement. A base type can be either a built-in type or a derived type, allowing a hierarchy of derived types.",
      "ja": "YANGは「typedefの」ステートメントを使用して、基本型から派生型を定義することができます。基本型は、派生型の階層構造を可能にする内蔵型または派生型のいずれであってもよいです。"
    },
    {
      "indent": 3,
      "text": "A derived type can be used as the argument for the \"type\" statement.",
      "ja": "派生型は、「タイプ」の文の引数として使用することができます。"
    },
    {
      "indent": 3,
      "text": "YANG Example:",
      "ja": "例："
    },
    {
      "indent": 5,
      "text": "typedef percent { type uint8 { range \"0 .. 100\"; } }",
      "ja": "typedefのパーセント{型UINT8 {範囲 \"0 .. 100\"。 }}"
    },
    {
      "indent": 5,
      "text": "leaf completed { type percent; }",
      "ja": "葉完了{型パーセント。 }"
    },
    {
      "indent": 3,
      "text": "XML Encoding Example:",
      "ja": "XMLエンコーディング例："
    },
    {
      "indent": 5,
      "text": "<completed>20</completed>",
      "ja": "<完成> 20 </完成>"
    },
    {
      "indent": 3,
      "text": "The \"typedef\" statement is covered in Section 7.3.",
      "ja": "「typedefは」文は7.3節で覆われています。"
    },
    {
      "indent": 0,
      "text": "4.2.6. Reusable Node Groups (grouping)",
      "section_title": true,
      "ja": "4.2.6. 再使用可能なノードグループ（グループ化）"
    },
    {
      "indent": 3,
      "text": "Groups of nodes can be assembled into reusable collections using the \"grouping\" statement. A grouping defines a set of nodes that are instantiated with the \"uses\" statement.",
      "ja": "ノードのグループは、「グループ化」ステートメントを使用して、再利用可能なコレクションに組み立てることができます。グルーピングは、「使用」文を使用してインスタンス化されたノードのセットを定義します。"
    },
    {
      "indent": 3,
      "text": "YANG Example:",
      "ja": "例："
    },
    {
      "indent": 5,
      "text": "grouping target {\n  leaf address {\n    type inet:ip-address;\n    description \"Target IP address.\";\n  }\n  leaf port {\n    type inet:port-number;\n     description \"Target port number.\";\n  }\n} container peer {\n  container destination {\n    uses target;\n  }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "XML Encoding Example:",
      "ja": "XMLエンコーディング例："
    },
    {
      "indent": 5,
      "text": "<peer> <destination> <address>2001:db8::2</address> <port>830</port> </destination> </peer>",
      "ja": "<ピア> <宛先> <アドレス> 2001：DB8 :: 2 </アドレス>、<ポート> 830 </ポート> </宛先> </ピア>"
    },
    {
      "indent": 3,
      "text": "The grouping can be refined as it is used, allowing certain statements to be overridden. In this example, the description is refined:",
      "ja": "それが使用されるグループは、特定の文が上書きされることを可能にする、改良することができます。この例では、説明が精製されます。"
    },
    {
      "indent": 5,
      "text": "container connection {\n  container source {\n    uses target {\n      refine \"address\" {\n        description \"Source IP address.\";\n      }\n      refine \"port\" {\n        description \"Source port number.\";\n      }\n    }\n  }\n  container destination {\n    uses target {\n      refine \"address\" {\n        description \"Destination IP address.\";\n      }\n      refine \"port\" {\n        description \"Destination port number.\";\n      }\n    }\n  }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The \"grouping\" statement is covered in Section 7.12.",
      "ja": "「グループ化」文は、セクション7.12で覆われています。"
    },
    {
      "indent": 0,
      "text": "4.2.7. Choices",
      "section_title": true,
      "ja": "4.2.7. 選択肢"
    },
    {
      "indent": 3,
      "text": "YANG allows the data model to segregate incompatible nodes into distinct choices using the \"choice\" and \"case\" statements. The \"choice\" statement contains a set of \"case\" statements that define sets of schema nodes that cannot appear together. Each \"case\" may contain multiple nodes, but each node may appear in only one \"case\" under a \"choice\".",
      "ja": "YANGは、データモデルは、「選択」と「ケース」ステートメントを使用して明確な選択肢に互換性のないノードを分離することができます。 「選択」ステートメントが一緒に表示することはできません、スキーマ・ノードのセットを定義する「ケース」ステートメントのセットが含まれています。各「ケース」は、複数のノードを含んでいてもよいが、各ノードは、「選択」の下に一つだけ「ケース」で表示されてもよいです。"
    },
    {
      "indent": 3,
      "text": "The choice and case nodes appear only in the schema tree and not in the data tree. The additional levels of hierarchy are not needed beyond the conceptual schema. The presence of a case is indicated by the presence of one or more of the nodes within it.",
      "ja": "選択とケースのノードが唯一のスキーマツリーではなくデータツリーに表示されます。階層の追加レベルは概念スキーマを超えて必要とされていません。ケースの存在は、その内のノードのうちの1つまたは複数の存在によって示されます。"
    },
    {
      "indent": 3,
      "text": "Since only one of the choice's cases can be valid at any time, when a node from one case is created in the data tree, all nodes from all other cases are implicitly deleted. The server handles the enforcement of the constraint, preventing incompatibilities from existing in the configuration.",
      "ja": "選択肢の例だけが任意の時点で有効であることができるので、1ケースからのノードがデータツリーに作成されたとき、他のすべてのケースからのすべてのノードが暗黙のうちに削除されます。サーバは、コンフィギュレーション内の既存の非互換性を防止し、制約の施行を処理します。"
    },
    {
      "indent": 3,
      "text": "YANG Example:",
      "ja": "例："
    },
    {
      "indent": 5,
      "text": "container food {\n  choice snack {\n    case sports-arena {\n      leaf pretzel {\n        type empty;\n      }\n      leaf beer {\n        type empty;\n      }\n    }\n    case late-night {\n      leaf chocolate {\n        type enumeration {\n          enum dark;\n          enum milk;\n          enum first-available;\n        }\n      }\n    }\n  }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "XML Encoding Example:",
      "ja": "XMLエンコーディング例："
    },
    {
      "indent": 5,
      "text": "<food> <pretzel/> <beer/> </food>",
      "ja": "<食べ物> <プレッツェル/> <ビール/> </食品>"
    },
    {
      "indent": 3,
      "text": "The \"choice\" statement is covered in Section 7.9.",
      "ja": "「選択」文は7.9節で覆われています。"
    },
    {
      "indent": 0,
      "text": "4.2.8. Extending Data Models (augment)",
      "section_title": true,
      "ja": "4.2.8. 拡張データ・モデル（オーグメント）"
    },
    {
      "indent": 3,
      "text": "YANG allows a module to insert additional nodes into data models, including both the current module (and its submodules) and an external module. This is useful, for example, for vendors to add vendor-specific parameters to standard data models in an interoperable way.",
      "ja": "YANGは、モジュールが現在のモジュール（およびそのサブモジュール）と外部モジュールの両方を含むデータモデルに追加ノードを挿入することを可能にします。ベンダーが相互運用可能な方法で標準データモデルにベンダー固有のパラメータを追加するためにこれは、例えば、便利です。"
    },
    {
      "indent": 3,
      "text": "The \"augment\" statement defines the location in the data model hierarchy where new nodes are inserted, and the \"when\" statement defines the conditions when the new nodes are valid.",
      "ja": "「増強」ステートメントは、新しいノードが挿入されているデータモデル階層内の位置を定義し、新しいノードが有効である場合にステートメントが条件を定義する「いつ」。"
    },
    {
      "indent": 3,
      "text": "When a server implements a module containing an \"augment\" statement, that implies that the server's implementation of the augmented module contains the additional nodes.",
      "ja": "サーバは「強化」の文を含むモジュールを実装する場合、それは、拡張モジュールのサーバの実装が追加のノードが含まれていることを意味します。"
    },
    {
      "indent": 3,
      "text": "YANG Example:",
      "ja": "例："
    },
    {
      "indent": 5,
      "text": "augment /system/login/user {\n  when \"class != 'wheel'\";\n  leaf uid {\n    type uint16 {\n      range \"1000 .. 30000\";\n    }\n  }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This example defines a \"uid\" node that is valid only when the user's \"class\" is not \"wheel\".",
      "ja": "この例では、ユーザーの「クラス」は「車輪」でない場合にのみ有効である「UID」ノードを定義します。"
    },
    {
      "indent": 3,
      "text": "If a module augments another module, the XML elements that are added to the encoding are in the namespace of the augmenting module. For example, if the above augmentation were in a module with prefix \"other\", the XML would look like:",
      "ja": "モジュールが別のモジュールを増強する場合、符号化に追加されたXML要素が増強モジュールの名前空間にあります。上記の増強は、「その他」の接頭辞モジュールにあった場合、例えば、XMLは次のようになります。"
    },
    {
      "indent": 3,
      "text": "XML Encoding Example:",
      "ja": "XMLエンコーディング例："
    },
    {
      "indent": 5,
      "text": "<user> <name>alicew</name> <full-name>Alice N. Wonderland</full-name> <class>drop-out</class> <other:uid>1024</other:uid> </user>",
      "ja": "<ユーザー> <名前> alicew </名前> <フルネーム>アリスN.ワンダーランド</フル名> <クラス>ドロップアウト</クラス> <他ます。uid> 1024 </その他ます。uid> </ユーザー>"
    },
    {
      "indent": 3,
      "text": "The \"augment\" statement is covered in Section 7.17.",
      "ja": "「オーグメント」文は、セクション7.17で覆われています。"
    },
    {
      "indent": 0,
      "text": "4.2.9. Operation Definitions",
      "section_title": true,
      "ja": "4.2.9. 操作の定義"
    },
    {
      "indent": 3,
      "text": "YANG allows the definition of operations. The operations' names, input parameters, and output parameters are modeled using YANG data definition statements. Operations on the top level in a module are defined with the \"rpc\" statement. Operations can also be tied to a container or list data node. Such operations are defined with the \"action\" statement.",
      "ja": "YANGは、操作の定義を可能にします。事業者名、入力パラメータ、出力パラメータがYANGデータ定義ステートメントを使用してモデル化されています。モジュールのトップレベルでの操作は、「RPC」ステートメントで定義されています。操作は、コンテナまたはリストのデータノードに接続することができます。このような操作は、「アクション」ステートメントで定義されています。"
    },
    {
      "indent": 3,
      "text": "YANG Example for an operation at the top level:",
      "ja": "トップレベルでの動作のためのYANG例："
    },
    {
      "indent": 5,
      "text": "rpc activate-software-image {\n  input {\n    leaf image-name {\n      type string;\n    }\n  }\n  output {\n    leaf status {\n      type string;\n    }\n  }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "NETCONF XML Example:",
      "ja": "NETCONF XMLの例："
    },
    {
      "indent": 5,
      "text": "<rpc message-id=\"101\" xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\"> <activate-software-image xmlns=\"http://example.com/system\"> <image-name>example-fw-2.3</image-name> </activate-software-image> </rpc>",
      "ja": "<RPCメッセージID = \"101\" のxmlns = \"URN：IETF：paramsは：XML：NS：NETCONF：塩基：1.0\"> <アクティブ・ソフトウェア・イメージのxmlns = \"http://example.com/system\"> <イメージ名>例-FW-2.3 </画像名> </アクティブ・ソフトウェア・イメージ> </ RPC>"
    },
    {
      "indent": 5,
      "text": "<rpc-reply message-id=\"101\" xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\"> <status xmlns=\"http://example.com/system\"> The image example-fw-2.3 is being installed. </status> </rpc-reply>",
      "ja": "<RPC返信メッセージID = \"101\" のxmlns = \"URN：IETF：paramsは：XML：NS：NETCONF：塩基：1.0\"> <ステータスのxmlns = \"http://example.com/system\">画像例-fw-2.3がインストールされています。 </ステータス> </ RPC-返信>"
    },
    {
      "indent": 3,
      "text": "YANG Example for an operation tied to a list data node:",
      "ja": "リストデータノードに結合操作の例YANG："
    },
    {
      "indent": 5,
      "text": "list interface { key \"name\";",
      "ja": "リストインターフェース{キー「名前」。"
    },
    {
      "indent": 7,
      "text": "leaf name { type string; }",
      "ja": "葉名{文字列型。 }"
    },
    {
      "indent": 5,
      "text": "  action ping {\n    input {\n      leaf destination {\n        type inet:ip-address;\n      }\n    }\n    output {\n      leaf packet-loss {\n        type uint8;\n      }\n    }\n  }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "NETCONF XML Example:",
      "ja": "NETCONF XMLの例："
    },
    {
      "indent": 5,
      "text": "<rpc message-id=\"102\" xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\"> <action xmlns=\"urn:ietf:params:xml:ns:yang:1\"> <interface xmlns=\"http://example.com/system\"> <name>eth1</name> <ping> <destination>192.0.2.1</destination> </ping> </interface> </action> </rpc>",
      "ja": "<RPCメッセージID = \"102\" のxmlns = \"URN：IETF：paramsは：XML：NS：NETCONF：塩基：1.0\"> <アクションのxmlns = \"URN：IETF：paramsは：XML：NS：陽：1\"> <インターフェースのxmlns = \"http://example.com/system\"> <名前> eth1の</名前> <ピング> <宛先> 192.0.2.1 </宛先> </ピング> </インターフェイス> </アクション> </ RPC>"
    },
    {
      "indent": 5,
      "text": "<rpc-reply message-id=\"102\" xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\" xmlns:sys=\"http://example.com/system\"> <sys:packet-loss>60</sys:packet-loss> </rpc-reply>",
      "ja": "<RPC返信メッセージID = \"102\" のxmlns = \"URN：IETF：paramsは：XML：NS：NETCONF：塩基：1.0\" のxmlns：SYS = \"http://example.com/system\">は<sys：パケット-loss> 60 </ SYS：パケット損失> </ RPC返信>"
    },
    {
      "indent": 3,
      "text": "The \"rpc\" statement is covered in Section 7.14, and the \"action\" statement is covered in Section 7.15.",
      "ja": "「RPC」文は、セクション7.14で覆われており、「アクション」の文は、7.15項で覆われています。"
    },
    {
      "indent": 0,
      "text": "4.2.10. Notification Definitions",
      "section_title": true,
      "ja": "4.2.10. 通知の定義"
    },
    {
      "indent": 3,
      "text": "YANG allows the definition of notifications. YANG data definition statements are used to model the content of the notification.",
      "ja": "YANGは、通知を定義できます。 YANGデータ定義文は、通知の内容をモデル化するために使用されています。"
    },
    {
      "indent": 3,
      "text": "YANG Example:",
      "ja": "例："
    },
    {
      "indent": 5,
      "text": "notification link-failure {\n  description\n    \"A link failure has been detected.\";\n  leaf if-name {\n    type leafref {\n      path \"/interface/name\";\n    }\n  }\n  leaf if-admin-status {\n    type admin-status;\n  }\n  leaf if-oper-status {\n    type oper-status;\n  }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "NETCONF XML Example:",
      "ja": "NETCONF XMLの例："
    },
    {
      "indent": 5,
      "text": "<notification xmlns=\"urn:ietf:params:netconf:capability:notification:1.0\"> <eventTime>2007-09-01T10:00:00Z</eventTime> <link-failure xmlns=\"urn:example:system\"> <if-name>so-1/2/3.0</if-name> <if-admin-status>up</if-admin-status> <if-oper-status>down</if-oper-status> </link-failure> </notification>",
      "ja": "<通知のxmlns = \"URN：IETF：paramsは：NETCONF：機能：通知：1.0\"> <イベント時刻> 2007-09-01T10：00：00Z </イベント時刻> <リンク障害のxmlns = \"URN：例：システム\"> <IF-name>のように-1/2 / 3.0 </ IF-名> <IF-管理ステータス>アップ</ IF-adminのステータス> <IF-OPER-状態> </ IF-OPERステータス>ダウン</リンク障害> </通知>"
    },
    {
      "indent": 3,
      "text": "The \"notification\" statement is covered in Section 7.16.",
      "ja": "「通知」の文は、7.16項で覆われています。"
    },
    {
      "indent": 0,
      "text": "5. Language Concepts",
      "section_title": true,
      "ja": "5.言語の概念"
    },
    {
      "indent": 0,
      "text": "5.1. Modules and Submodules",
      "section_title": true,
      "ja": "5.1. モジュールおよびサブモジュール"
    },
    {
      "indent": 3,
      "text": "The module is the base unit of definition in YANG. A module defines a single data model. A module can also augment an existing data model with additional nodes.",
      "ja": "モジュールは、YANGで定義の基本単位です。モジュールは、単一のデータモデルを定義します。モジュールはまた、追加のノードで既存のデータモデルを増強することができます。"
    },
    {
      "indent": 3,
      "text": "Submodules are partial modules that contribute definitions to a module. A module may include any number of submodules, but each submodule may belong to only one module.",
      "ja": "サブモジュールは、モジュールに定義を貢献する部分のモジュールです。モジュールは、サブモジュールの任意の数を含んでいてもよいが、各サブモジュールは、一つのモジュールに属していてもよいです。"
    },
    {
      "indent": 3,
      "text": "Developers of YANG modules and submodules are RECOMMENDED to choose names for their modules that will have a low probability of colliding with standard or other enterprise modules, e.g., by using the enterprise or organization name as a prefix for the module name. Within a server, all module names MUST be unique.",
      "ja": "YANGモジュールおよびサブモジュールの開発者は、モジュール名の接頭辞として、企業や組織名を使用することにより、例えば、標準または他のエンタープライズ・モジュールと衝突する確率が低いだろう彼らのモジュールの名前を選択することをお勧めします。サーバー内では、すべてのモジュール名は一意でなければなりません。"
    },
    {
      "indent": 3,
      "text": "A module uses the \"include\" statement to list all its submodules. A module, or submodule belonging to that module, can reference definitions in the module and all submodules included by the module.",
      "ja": "モジュールは、そのすべてのサブモジュールを一覧表示する「を含む」ステートメントを使用しています。そのモジュールに属するモジュール、またはサブモジュールは、モジュール内の定義およびモジュールが含まれるすべてのサブモジュールを参照することができます。"
    },
    {
      "indent": 3,
      "text": "A module or submodule uses the \"import\" statement to reference external modules. Statements in the module or submodule can reference definitions in the external module using the prefix specified in the \"import\" statement.",
      "ja": "モジュールまたはサブモジュールは、外部モジュールを参照するために、「インポート」ステートメントを使用しています。モジュールまたはサブモジュール内の文は、「インポート」文で指定された接頭辞を使用して外部モジュール内の定義を参照することができます。"
    },
    {
      "indent": 3,
      "text": "For backward compatibility with YANG version 1, a submodule MAY use the \"include\" statement to reference other submodules within its module, but this is not necessary in YANG version 1.1. A submodule can reference any definition in the module it belongs to and in all submodules included by the module. A submodule MUST NOT include different revisions of other submodules than the revisions that its module includes.",
      "ja": "YANGバージョン1との下位互換性のために、サブモジュールは、そのモジュール内の他のサブモジュールを参照するために、「含む（include）」ステートメントを使用できるが、これはYANGバージョン1.1に必要ではありません。サブモジュールは、それが、モジュールによって含まれるすべてのサブモジュールに属するモジュールの任意の定義を参照することができます。サブモジュールは、そのモジュールは、改訂以外のサブモジュールの異なるリビジョンを含んではいけません。"
    },
    {
      "indent": 3,
      "text": "A module or submodule MUST NOT include submodules from other modules, and a submodule MUST NOT import its own module.",
      "ja": "モジュールまたはサブモジュールは他のモジュールのサブモジュールを含んではいけません、そしてサブモジュールは、独自のモジュールをインポートしてはいけません。"
    },
    {
      "indent": 3,
      "text": "The \"import\" and \"include\" statements are used to make definitions available from other modules:",
      "ja": "「インポート」と文は、他のモジュールからの定義を利用できるようにするために使用されている「含めます」："
    },
    {
      "indent": 3,
      "text": "o For a module or submodule to reference definitions in an external module, the external module MUST be imported.",
      "ja": "O外部モジュールにおける基準定義のモジュールまたはサブモジュールは、外部モジュールをインポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "o A module MUST include all its submodules.",
      "ja": "Oモジュールは、そのすべてのサブモジュールを含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "o A module, or submodule belonging to that module, MAY reference definitions in the module and all submodules included by the module.",
      "ja": "Oそのモジュールに属するモジュール、またはサブモジュールは、モジュール内の定義およびモジュールが含まれるすべてのサブモジュールを参照することができます。"
    },
    {
      "indent": 3,
      "text": "There MUST NOT be any circular chains of imports. For example, if module \"a\" imports module \"b\", \"b\" cannot import \"a\".",
      "ja": "輸入のいずれかの円形チェーンがあってはなりません。例えば、モジュール「」輸入モジュール「B」、「B」は「A」をインポートすることができない場合。"
    },
    {
      "indent": 3,
      "text": "When a definition in an external module is referenced, a locally defined prefix MUST be used, followed by a colon (\":\") and then the external identifier. References to definitions in the local module MAY use the prefix notation. Since built-in data types do not belong to any module and have no prefix, references to built-in data types (e.g., int32) cannot use the prefix notation. The syntax for a reference to a definition is formally defined by the rule \"identifier-ref\" in Section 14.",
      "ja": "外部モジュール内の定義が参照される場合、局所的に定義されたプレフィックスは、使用されるコロン（「：」）が続く必要があり、その後、外部識別子。ローカルモジュール内の定義への参照は、接頭表記法を使用するかもしれません。組み込みのためのデータ型の任意のモジュールに属し、接頭辞、組み込みデータ型（例えば、Int32）を接頭表記法を使用することはできませんへの参照を持っていません。定義への参照のための構文は、正式に第14で「識別子-REF」ルールによって定義されます。"
    },
    {
      "indent": 0,
      "text": "5.1.1. Import and Include by Revision",
      "section_title": true,
      "ja": "5.1.1. 改訂によりインポートとインクルード"
    },
    {
      "indent": 3,
      "text": "Published modules evolve independently over time. In order to allow for this evolution, modules can be imported using specific revisions. Initially, a module imports the revisions of other modules that are current when the module is written. As future revisions of the imported modules are published, the importing module is unaffected and its contents are unchanged. When the author of the module is prepared to move to the most recently published revision of an imported module, the module is republished with an updated \"import\" statement. By republishing with the new revision, the authors explicitly indicate their acceptance of any changes in the imported module.",
      "ja": "公開されたモジュールは、時間の経過とともに独立して進化します。この進化を可能にするために、モジュールは、特定のリビジョンを使用してインポートすることができます。最初に、モジュールは、モジュールが書き込まれたときに現在ある他のモジュールのリビジョンをインポートします。インポートされたモジュールの将来の改訂が公開されると、インポートモジュールは影響を受けず、その内容は変更されません。モジュールの作者は、インポートされたモジュールの最も最近発表されたリビジョンに移動する用意がある場合は、モジュールが更新され、「インポート」ステートメントを使用して再発行されます。新しいリビジョンを再発行することで、著者は明示的にインポートされたモジュールの変更の彼らの受け入れを示しています。"
    },
    {
      "indent": 3,
      "text": "For submodules, the issue is related but simpler. A module or submodule that includes submodules may specify the revision of the included submodules. If a submodule changes, any module or submodule that includes it by revision needs to be updated to reference the new revision.",
      "ja": "サブモジュールの場合、問題が関連しているが簡単です。サブモジュールを含むモジュールまたはサブモジュールが含まれるサブモジュールのリビジョンを指定することができます。サブモジュールが変更された場合、改正により、それを含む任意のモジュールまたはサブモジュールは、新しいリビジョンを参照するように更新する必要があります。"
    },
    {
      "indent": 3,
      "text": "For example, module \"b\" imports module \"a\".",
      "ja": "例えば、モジュール「B」インポートモジュール「A」。"
    },
    {
      "indent": 5,
      "text": "module a {\n  yang-version 1.1;\n  namespace \"urn:example:a\";\n  prefix \"a\";",
      "raw": true
    },
    {
      "indent": 5,
      "text": " revision 2008-01-01 { ... } grouping a { leaf eh { .... } } }",
      "ja": "リビジョン2008-01-01 {...} {葉をEH {...}}}グルーピング"
    },
    {
      "indent": 5,
      "text": "module b {\n  yang-version 1.1;\n  namespace \"urn:example:b\";\n  prefix \"b\";",
      "raw": true
    },
    {
      "indent": 7,
      "text": "import a {\n  prefix \"p\";\n  revision-date 2008-01-01;\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": " container bee { uses p:a; } }",
      "ja": "容器蜂は、{Pを使用します。 }}"
    },
    {
      "indent": 3,
      "text": "When the author of \"a\" publishes a new revision, the changes may not be acceptable to the author of \"b\". If the new revision is acceptable, the author of \"b\" can republish with an updated revision in the \"import\" statement.",
      "ja": "著者は「」新しいリビジョンを公開すると、変更内容は、「B」の作者に許容できない場合があります。新しいリビジョンが受け入れ可能である場合は、「B」の著者は、「インポート」文で更新リビジョンを再発行することができます。"
    },
    {
      "indent": 3,
      "text": "If a module is not imported with a specific revision, it is undefined which revision is used.",
      "ja": "モジュールは、特定のリビジョンにインポートされていない場合は、使用されているリビジョン未定義です。"
    },
    {
      "indent": 0,
      "text": "5.1.2. Module Hierarchies",
      "section_title": true,
      "ja": "5.1.2. モジュールの階層"
    },
    {
      "indent": 3,
      "text": "YANG allows modeling of data in multiple hierarchies, where data may have more than one top-level node. Each top-level data node in a module defines a separate hierarchy. Models that have multiple top-level nodes are sometimes convenient and are supported by YANG.",
      "ja": "YANGは、データが複数のトップレベルのノードを有していてもよく、複数の階層のデータのモデリングを可能にします。モジュール内の各トップレベル・データ・ノードは、別の階層を定義します。複数のトップレベルのノードを有するモデルは時々便利であり、YANGによって支持されています。"
    },
    {
      "indent": 0,
      "text": "5.1.2.1. NETCONF XML Encoding",
      "section_title": true,
      "ja": "5.1.2.1。 NETCONFのXMLエンコーディング"
    },
    {
      "indent": 3,
      "text": "NETCONF is capable of carrying any XML content as the payload in the <config> and <data> elements. The top-level nodes of YANG modules are encoded as child elements, in any order, within these elements. This encapsulation guarantees that the corresponding NETCONF messages are always well-formed XML documents.",
      "ja": "NETCONFは、<設定>と<データ>要素内のペイロードのような任意のXMLコンテンツを搬送することが可能です。 YANGモジュールのトップレベルのノードは、これらの要素内で、任意の順序で、子要素として符号化されます。このカプセル化は、対応するNETCONFメッセージは常に整形式XML文書であることを保証します。"
    },
    {
      "indent": 3,
      "text": "For example, an instance of:",
      "ja": "例えば、インスタンスの："
    },
    {
      "indent": 5,
      "text": "module example-config {\n  yang-version 1.1;\n  namespace \"urn:example:config\";\n  prefix \"co\";",
      "raw": true
    },
    {
      "indent": 5,
      "text": " container system { ... } container routing { ... } }",
      "ja": "容器システム{...}コンテナルーティング{...}}"
    },
    {
      "indent": 3,
      "text": "could be encoded in NETCONF as:",
      "ja": "NETCONFにとしてエンコードすることができます："
    },
    {
      "indent": 5,
      "text": "<rpc message-id=\"101\" xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\" xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\"> <edit-config> <target> <running/> </target> <config> <system xmlns=\"urn:example:config\"> <!-- system data here --> </system> <routing xmlns=\"urn:example:config\"> <!-- routing data here --> </routing> </config> </edit-config> </rpc>",
      "ja": "<RPCメッセージID = \"101\" のxmlns = \"URN：IETF：paramsは：XML：NS：NETCONF：塩基：1.0\" のxmlns：NC = \"URN：IETF：paramsは：XML：NS：NETCONF：塩基：1.0\"> <編集-config>の<対象> <ランニング/> </ target>を<config>の<システムのxmlns = \"壷：例：コンフィグ\"> <！ - ここでは、システムデータ - > </システム> <ルーティングのxmlns =」 URN：例：コンフィグ \"> < - ここでのルーティングデータ - > </ルーティング> </ config>の</編集-config>の</ RPC>！"
    },
    {
      "indent": 0,
      "text": "5.2. File Layout",
      "section_title": true,
      "ja": "5.2. ファイルのレイアウト"
    },
    {
      "indent": 3,
      "text": "YANG modules and submodules are typically stored in files, one \"module\" or \"submodule\" statement per file. The name of the file SHOULD be of the form:",
      "ja": "YANGモジュールおよびサブモジュールは、一般的に、ファイル内の一つの「モジュール」またはファイルごとに「サブモジュール」文を格納しています。ファイルの名前は次の形式にする必要があります。"
    },
    {
      "indent": 5,
      "text": "module-or-submodule-name ['@' revision-date] ( '.yang' / '.yin' )",
      "ja": "モジュールまたは - サブモジュール名[「@」改訂日付]（「.yang」/」.yin'）"
    },
    {
      "indent": 3,
      "text": "\"module-or-submodule-name\" is the name of the module or submodule, and the optional \"revision-date\" is the latest revision of the module or submodule, as defined by the \"revision\" statement (Section 7.1.9).",
      "ja": "「モジュール・オア・サブモジュール名が」モジュールまたはサブモジュールの名前で、オプションの「リビジョン日付は」「改正」文で定義されているように、モジュールまたはサブモジュールの最新版である（セクション7.1.9） 。"
    },
    {
      "indent": 3,
      "text": "The file extension \".yang\" denotes that the contents of the file are written with YANG syntax (Section 6), and \".yin\" denotes that the contents of the file are written with YIN syntax (Section 13).",
      "ja": "ファイル拡張子「.yang」は、ファイルの内容はYANG構文（第6節）と書かれていることを示し、そして「.yin」は、ファイルの内容はYIN構文（セクション13）と書かれていることを意味します。"
    },
    {
      "indent": 3,
      "text": "YANG parsers can find imported modules and included submodules via this convention.",
      "ja": "YANGパーサは、インポートされたモジュールを見つけて、この大会を経てサブモジュールを含むことができます。"
    },
    {
      "indent": 0,
      "text": "5.3. XML Namespaces",
      "section_title": true,
      "ja": "5.3.  XML名前空間"
    },
    {
      "indent": 3,
      "text": "All YANG definitions are specified within a module. Each module is bound to a distinct XML namespace [XML-NAMES], which is a globally unique URI [RFC3986]. A NETCONF client or server uses the namespace during XML encoding of data.",
      "ja": "すべてYANG定義は、モジュール内で指定されています。各モジュールは、グローバルに一意のURI [RFC3986]で個別のXML名前空間[XML-NAMES]にバインドされています。 NETCONFクライアントまたはサーバは、データのXMLエンコード時の名前空間を使用しています。"
    },
    {
      "indent": 3,
      "text": "XML namespaces for modules published in RFC streams [RFC4844] MUST be assigned by IANA; see Section 14 in [RFC6020].",
      "ja": "RFCストリーム[RFC4844]に掲載されたモジュールのXML名前空間はIANAによって割り当てられなければなりません。 [RFC6020]でセクション14を参照してください。"
    },
    {
      "indent": 3,
      "text": "XML namespaces for private modules are assigned by the organization owning the module without a central registry. Namespace URIs MUST be chosen so they cannot collide with standard or other enterprise namespaces -- for example, by using the enterprise or organization name in the namespace.",
      "ja": "プライベートモジュールのXML名前空間は、中央レジストリせずにモジュールを所有している組織によって割り当てられます。例えば、名前空間に企業や組織名を使用して - それは、標準またはその他の企業の名前空間と衝突することができないので、名前空間URIを選択しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The \"namespace\" statement is covered in Section 7.1.3.",
      "ja": "「名前空間」文は、セクション7.1.3で覆われています。"
    },
    {
      "indent": 0,
      "text": "5.3.1. YANG XML Namespace",
      "section_title": true,
      "ja": "5.3.1.  XML名前空間"
    },
    {
      "indent": 3,
      "text": "YANG defines an XML namespace for NETCONF <edit-config> operations, <error-info> content, and the <action> element. The name of this namespace is \"urn:ietf:params:xml:ns:yang:1\".",
      "ja": "YANGは、NETCONF <編集-config>の操作、<エラー情報>コンテンツ、および<action>要素のXML名前空間を定義します。この名前空間の名前は \"URN：IETF：のparams：XML：NS：陽：1\"。"
    },
    {
      "indent": 0,
      "text": "5.4. Resolving Grouping, Type, and Identity Names",
      "section_title": true,
      "ja": "5.4. 解決グループ、タイプ、およびアイデンティティの名前"
    },
    {
      "indent": 3,
      "text": "Grouping, type, and identity names are resolved in the context in which they are defined, rather than the context in which they are used. Users of groupings, typedefs, and identities are not required to import modules or include submodules to satisfy all references made by the original definition. This behaves like static scoping in a conventional programming language.",
      "ja": "グループ、タイプ、および識別名は、彼らはむしろ、それらが使用される文脈よりも、定義されているコンテキストで解決されています。グループ、のtypedef、およびアイデンティティのユーザーはモジュールをインポートしたり、元の定義によって行われたすべての参照を満たすためにサブモジュールを含める必要はありません。これは、従来のプログラミング言語の静的スコープのように振る舞います。"
    },
    {
      "indent": 3,
      "text": "For example, if a module defines a grouping in which a type is referenced, when the grouping is used in a second module, the type is resolved in the context of the original module, not the second module. There is no ambiguity if both modules define the type.",
      "ja": "モジュールは、グループ化が第二のモジュールで使用されるときタイプが、参照されたグループを定義している場合、例えば、タイプは、元のモジュールではなく、第二のモジュールのコンテキストで解決されます。両方のモジュールタイプを定義した場合に曖昧さはありません。"
    },
    {
      "indent": 0,
      "text": "5.5. Nested Typedefs and Groupings",
      "section_title": true,
      "ja": "5.5. ネストされたtypedefとグループ化"
    },
    {
      "indent": 3,
      "text": "Typedefs and groupings may appear nested under many YANG statements, allowing these to be lexically scoped by the statement hierarchy under which they appear. This allows types and groupings to be defined near where they are used, rather than placing them at the top level of the hierarchy. The close proximity increases readability.",
      "ja": "typedefとグループは、これらが辞書的にそれらが現れる下の文の階層によってスコープすることができ、多くのYANG文の下にネストされて表示されることがあります。これは、種類やグループではなく、階層の最上位レベルでそれらを置くよりも、それらが使用されている場所の近くに定義することができます。近接は、読みやすさを向上させます。"
    },
    {
      "indent": 3,
      "text": "Scoping also allows types to be defined without concern for naming conflicts between types in different submodules. Type names can be specified without adding leading strings designed to prevent name collisions within large modules.",
      "ja": "スコープもタイプが異なるサブモジュール内の型間の競合を命名するために気にせずに定義することができます。タイプ名は、大規模なモジュール内の名前の衝突を防ぐために設計された主要な文字列を追加することなく、指定することができます。"
    },
    {
      "indent": 3,
      "text": "Finally, scoping allows the module author to keep types and groupings private to their module or submodule, preventing their reuse. Since only top-level types and groupings (i.e., those appearing as substatements to a \"module\" or \"submodule\" statement) can be used outside the module or submodule, the developer has more control over what pieces of their module are presented to the outside world, supporting the need to hide internal information and maintaining a boundary between what is shared with the outside world and what is kept private.",
      "ja": "最後に、スコープはその再利用を防止し、そのモジュールまたはサブモジュールにプライベート型とグループ化を維持するためのモジュールの作者が可能になります。唯一のトップレベルのタイプおよびグルーピング（すなわち、「モジュール」または「サブモジュール」ステートメントにサブステートメントとして現れるもの）モジュールまたはサブモジュールの外部で使用することができるので、開発者は、に提示されているもの、そのモジュールの部分をより詳細に制御することが外の世界では、内部情報を非表示にする必要性をサポートし、どのような外の世界と共有されており、どのような秘密に保たれているとの間の境界を維持します。"
    },
    {
      "indent": 3,
      "text": "Scoped definitions MUST NOT shadow definitions at a higher scope. A type or grouping cannot be defined if a higher level in the statement hierarchy has a definition with a matching identifier.",
      "ja": "スコープ定義は高いスコープで定義シャドウてはなりません。ステートメント階層のより高いレベルが、一致する識別子との定義を有する場合タイプまたはグループを定義することができません。"
    },
    {
      "indent": 3,
      "text": "A reference to an unprefixed type or grouping, or one that uses the prefix of the current module, is resolved by locating the matching \"typedef\" or \"grouping\" statement among the immediate substatements of each ancestor statement.",
      "ja": "接頭辞タイプまたはグループ、または現在のモジュールの接頭辞を使用するものへの言及は、各祖先文の即時サブステートメントのうちマッチング「のtypedef」または「グループ」ステートメントを配置することによって解決されます。"
    },
    {
      "indent": 0,
      "text": "5.6. Conformance",
      "section_title": true,
      "ja": "5.6. 準拠"
    },
    {
      "indent": 3,
      "text": "Conformance to a model is a measure of how accurately a server follows the model. Generally speaking, servers are responsible for implementing the model faithfully, allowing applications to treat servers that implement the model identically. Deviations from the model can reduce the utility of the model and increase the fragility of applications that use it.",
      "ja": "モデルへの適合性は、サーバモデルを以下の方法を正確にの尺度です。一般的に言えば、サーバは、アプリケーションが同一のモデルを実装してサーバを治療することができ、忠実にモデルを実装するための責任があります。モデルからの逸脱は、モデルの有用性を削減し、それを使用するアプリケーションの脆弱性を高めることができます。"
    },
    {
      "indent": 3,
      "text": "YANG modelers have three mechanisms for conformance:",
      "ja": "YANGモデラーは、適合性のための3つのメカニズムがあります。"
    },
    {
      "indent": 3,
      "text": "o the basic behavior of the model",
      "ja": "モデルの基本的な振る舞いO"
    },
    {
      "indent": 3,
      "text": "o optional features that are part of the model",
      "ja": "モデルの一部であるオプション機能O"
    },
    {
      "indent": 3,
      "text": "o deviations from the model",
      "ja": "モデルからのO偏差"
    },
    {
      "indent": 3,
      "text": "We will consider each of these in sequence.",
      "ja": "私たちは、順番にこれらのそれぞれを検討します。"
    },
    {
      "indent": 0,
      "text": "5.6.1. Basic Behavior",
      "section_title": true,
      "ja": "5.6.1. 基本的な行動"
    },
    {
      "indent": 3,
      "text": "The model defines a contract between a YANG-based client and server; this contract allows both parties to have faith that the other knows the syntax and semantics behind the modeled data. The strength of YANG lies in the strength of this contract.",
      "ja": "モデルはYANGベースのクライアントとサーバの間の契約を定義します。この契約は、両当事者が他のモデル化されたデータの後ろの構文と意味を知っている信仰を持つことができます。 YANGの強さは、この契約の強さです。"
    },
    {
      "indent": 0,
      "text": "5.6.2. Optional Features",
      "section_title": true,
      "ja": "5.6.2. オプション機能"
    },
    {
      "indent": 3,
      "text": "In many models, the modeler will allow sections of the model to be conditional. The server controls whether these conditional portions of the model are supported or valid for that particular server.",
      "ja": "多くのモデルでは、モデル作成者はモデルのセクションを条件付きにすることができます。サーバモデルこれらの条件部分は担持またはその特定のサーバに対して有効であるかどうかを制御します。"
    },
    {
      "indent": 3,
      "text": "For example, a syslog data model may choose to include the ability to save logs locally, but the modeler will realize that this is only possible if the server has local storage. If there is no local storage, an application should not tell the server to save logs.",
      "ja": "たとえば、syslogのデータモデルは、ローカルにログを保存する機能を含めることを選択するかもしれませんが、サーバーは、ローカルストレージを持っている場合、モデラーは、これが唯一の可能であることを理解するであろう。ローカルストレージがない場合、アプリケーションは、ログを保存するサーバーを教えてはいけません。"
    },
    {
      "indent": 3,
      "text": "YANG supports this conditional mechanism using a construct called \"feature\". Features give the modeler a mechanism for making portions of the module conditional in a manner that is controlled by the server. The model can express constructs that are not universally present in all servers. These features are included in the model definition, allowing a consistent view and allowing applications to learn which features are supported and tailor their behavior to the server.",
      "ja": "YANGは、「機能」と呼ばれる構造を使用して、この条件付きのメカニズムをサポートしています。機能がモデラーにサーバによって制御されるように、条件付きモジュールの部分を製造するためのメカニズムを与えます。モデルは普遍のすべてのサーバーに存在しない構造を表現することができます。これらの機能は、一貫性のあるビューを可能とするアプリケーションは、機能がサポートされているかを学習し、サーバに彼らの行動を調整することができ、モデルの定義に含まれます。"
    },
    {
      "indent": 3,
      "text": "A module may declare any number of features, identified by simple strings, and may make portions of the module optional based on those features. If the server supports a feature, then the corresponding portions of the module are valid for that server. If the server doesn't support the feature, those parts of the module are not valid, and applications should behave accordingly.",
      "ja": "モジュールは単純な文字列によって識別された特徴の任意の数を宣言することができ、これらの特徴に基づいて、モジュールの任意の部分を行うことができます。サーバが機能をサポートしている場合は、モジュールの対応する部分には、そのサーバーに対して有効です。サーバが機能をサポートしていない場合は、モジュールの部分は有効ではなく、アプリケーションはそれに応じて振る舞うべき。"
    },
    {
      "indent": 3,
      "text": "Features are defined using the \"feature\" statement. Definitions in the module that are conditional to the feature are noted by the \"if-feature\" statement.",
      "ja": "特長は、「機能」ステートメントを使用して定義されています。機能への条件としているモジュール内の定義は、「IF-機能」文で指摘されています。"
    },
    {
      "indent": 3,
      "text": "Further details are available in Section 7.20.1.",
      "ja": "詳細は、セクション7.20.1でご利用いただけます。"
    },
    {
      "indent": 0,
      "text": "5.6.3. Deviations",
      "section_title": true,
      "ja": "5.6.3. 偏差"
    },
    {
      "indent": 3,
      "text": "In an ideal world, all servers would be required to implement the model exactly as defined, and deviations from the model would not be allowed. But in the real world, servers are often not able or designed to implement the model as written. For YANG-based automation to deal with these server deviations, a mechanism must exist for servers to inform applications of the specifics of such deviations.",
      "ja": "理想的な世界では、すべてのサーバが定義されたとおりにモデルを実装するために必要とされるであろうし、モデルからの偏差が許可されません。しかし、現実の世界では、サーバは、しばしばことや書かれたモデルを実装するために設計されていません。これらのサーバー偏差に対処するためYANG・ベースの自動化のために、この機構は、このような偏差の仕様のアプリケーションに通知するサーバーに対して存在している必要があります。"
    },
    {
      "indent": 3,
      "text": "For example, a BGP module may allow any number of BGP peers, but a particular server may only support 16 BGP peers. Any application configuring the 17th peer will receive an error. While an error may suffice to let the application know it cannot add another peer, it would be far better if the application had prior knowledge of this limitation and could prevent the user from starting down the path that could not succeed.",
      "ja": "例えば、BGPモジュールは、BGPピアの任意の数のを可能にすることができるが、特定のサーバーでのみ16個のBGPピアをサポートすることができます。第17回ピアを設定する任意のアプリケーションがエラーを受信します。エラーは、アプリケーションが、それは別のピアを追加することはできません知っているようには十分かもしれないが、アプリケーションがこの制限の事前知識を持っていたし、成功することができませんでした道を開始するからユーザーを防ぐことができれば、それははるかに良いでしょう。"
    },
    {
      "indent": 3,
      "text": "Server deviations are declared using the \"deviation\" statement, which takes as its argument a string that identifies a node in the schema tree. The contents of the statement detail the manner in which the server implementation deviates from the contract as defined in the module.",
      "ja": "サーバーの偏差は、引数としてスキーマツリー内のノードを識別する文字列を取る「ずれ」の文を、使用して宣言されています。文の詳細の内容はモジュールで定義されているサーバの実装が契約から逸脱する様子。"
    },
    {
      "indent": 3,
      "text": "Further details are available in Section 7.20.3.",
      "ja": "詳細は、セクション7.20.3でご利用いただけます。"
    },
    {
      "indent": 0,
      "text": "5.6.4. Announcing Conformance Information in NETCONF",
      "section_title": true,
      "ja": "5.6.4.  NETCONFでの適合性情報を発表"
    },
    {
      "indent": 3,
      "text": "This document defines the following mechanism for announcing conformance information. Other mechanisms may be defined by future specifications.",
      "ja": "この文書では、適合性情報を発表するために、以下のメカニズムを定義します。他のメカニズムは、将来の仕様によって定義することができます。"
    },
    {
      "indent": 3,
      "text": "A NETCONF server MUST announce the modules it implements (see Section 5.6.5) by implementing the YANG module \"ietf-yang-library\" defined in [RFC7895] and listing all implemented modules in the \"/modules-state/module\" list.",
      "ja": "NETCONFサーバは[RFC7895]で定義されており、「/モジュール状態/モジュール」リスト内のすべての実装されたモジュールをリストアップし、「IETF-ヤン・ライブラリー」YANGモジュールを実装することで（5.6.5項を参照）、それは実装モジュールを発表しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The server also MUST advertise the following capability in the <hello> message (line breaks and whitespaces are used for formatting reasons only):",
      "ja": "また、サーバは、<ハロー>メッセージ（改行や空白だけの理由をフォーマットするために使用されている）で、以下の機能をアドバタイズする必要があります："
    },
    {
      "indent": 5,
      "text": "urn:ietf:params:netconf:capability:yang-library:1.0? revision=<date>&module-set-id=<id>",
      "ja": "URN：IETF：のparams：NETCONF：機能：ヤン・ライブラリー：1.0？リビジョン= <日付>・モジュール・セットID = <ID>"
    },
    {
      "indent": 3,
      "text": "The parameter \"revision\" has the same value as the revision date of the \"ietf-yang-library\" module implemented by the server. This parameter MUST be present.",
      "ja": "パラメータ「改正」は、サーバによって実装「IETF-ヤン・ライブラリー」モジュールの改訂日と同じ値を持っています。このパラメータが存在しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The parameter \"module-set-id\" has the same value as the leaf \"/modules-state/module-set-id\" from \"ietf-yang-library\". This parameter MUST be present.",
      "ja": "パラメータ「モジュール・セットID」は、「IETF陽ライブラリー」からの葉「/モジュールステート/モジュール・セットID」と同じ値を有します。このパラメータが存在しなければなりません。"
    },
    {
      "indent": 3,
      "text": "With this mechanism, a client can cache the supported modules for a server and only update the cache if the \"module-set-id\" value in the <hello> message changes.",
      "ja": "このメカニズムでは、クライアントがサーバーに対してサポートされているモジュールをキャッシュしての「モジュール・セットID」の値が<こんにちは>メッセージが変更された場合のみ、キャッシュを更新することができます。"
    },
    {
      "indent": 0,
      "text": "5.6.5. Implementing a Module",
      "section_title": true,
      "ja": "5.6.5. モジュールの実装"
    },
    {
      "indent": 3,
      "text": "A server implements a module if it implements the module's data nodes, RPCs, actions, notifications, and deviations.",
      "ja": "それはモジュールのデータ・ノード、RPCの、アクション、通知、および偏差を実装している場合、サーバーモジュールを実装しています。"
    },
    {
      "indent": 3,
      "text": "A server MUST NOT implement more than one revision of a module.",
      "ja": "サーバーは、モジュールの複数のリビジョンを実装してはなりません。"
    },
    {
      "indent": 3,
      "text": "If a server implements a module A that imports a module B, and A uses any node from B in an \"augment\" or \"path\" statement that the server supports, then the server MUST implement a revision of module B that has these nodes defined. This is regardless of whether module B is imported by revision or not.",
      "ja": "サーバがモジュールBをインポートモジュールAを実装し、Aが「増強」またはサーバがサポートしていることを「パス」ステートメントにおけるBからの任意のノードを使用する場合、サーバは、これらのノードは、定義されたモジュールBのリビジョンを実装しなければなりません。これは関係なく、モジュールBが改正によってインポートされたか否かにあります。"
    },
    {
      "indent": 3,
      "text": "If a server implements a module A that imports a module C without specifying the revision date of module C and the server does not implement C (e.g., if C only defines some typedefs), the server MUST list module C in the \"/modules-state/module\" list from \"ietf-yang-library\" [RFC7895], and it MUST set the leaf \"conformance-type\" to \"import\" for this module.",
      "ja": "サーバは、モジュールCの改訂日付を指定せずにモジュールCをインポートし、モジュールAを実装し、（Cのみがいくつかのtypedefを定義する場合など、）サーバはCを実装していない場合は、サーバーは「/ modules-にモジュールCをリストする必要があります状態/モジュールIETF-ヤン・ライブラリー」からリスト 『』 [RFC7895]、およびそれが葉を設定しなければならない 『適合型をこのモジュールのインポート『』へ』。"
    },
    {
      "indent": 3,
      "text": "If a server lists a module C in the \"/modules-state/module\" list from \"ietf-yang-library\" and there are other modules Ms listed that import C without specifying the revision date of module C, the server MUST use the definitions from the most recent revision of C listed for modules Ms.",
      "ja": "サーバは、「IETF-ヤン・ライブラリー」から「/モジュール状態/モジュール」リストにモジュールCを一覧表示し、Msは、モジュールCの改訂日付を指定せずにその輸入Cを記載されている他のモジュールがある場合は、サーバが使用しなければなりませんモジュールさんのためにリストされているCの最新のリビジョンの定義"
    },
    {
      "indent": 3,
      "text": "The reason for these rules is that clients need to be able to know the specific data model structure and types of all leafs and leaf-lists implemented in a server.",
      "ja": "これらのルールの理由は、クライアントがサーバに実装されているすべての葉と葉のリストの固有のデータモデルの構造や種類を知ることができるようにする必要があるということです。"
    },
    {
      "indent": 3,
      "text": "For example, with these modules:",
      "ja": "例えば、これらのモジュールと："
    },
    {
      "indent": 5,
      "text": "module a {\n  yang-version 1.1;\n  namespace \"urn:example:a\";\n  prefix \"a\";",
      "raw": true
    },
    {
      "indent": 7,
      "text": "import b {\n  revision-date 2015-01-01;\n}\nimport c;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "revision 2015-01-01;",
      "ja": "改訂2015年1月1日;"
    },
    {
      "indent": 7,
      "text": "feature foo;",
      "ja": "フィーチャーfooという。"
    },
    {
      "indent": 7,
      "text": "augment \"/b:x\" { if-feature foo;",
      "ja": "増強 \"/ B：X\" {IF-特徴FOO。"
    },
    {
      "indent": 7,
      "text": " leaf y { type b:myenum; } }",
      "ja": "リーフY {式B：myenum。 }}"
    },
    {
      "indent": 5,
      "text": "  container a {\n    leaf x {\n      type c:bar;\n    }\n  }\n} module b {\n  yang-version 1.1;\n  namespace \"urn:example:b\";\n  prefix \"b\";",
      "raw": true
    },
    {
      "indent": 7,
      "text": "revision 2015-01-01;",
      "ja": "改訂2015年1月1日;"
    },
    {
      "indent": 7,
      "text": "typedef myenum {\n  type enumeration {\n    enum zero;\n  }\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": " container x { } }",
      "ja": "容器X {}}"
    },
    {
      "indent": 5,
      "text": "module b {\n  yang-version 1.1;\n  namespace \"urn:example:b\";\n  prefix \"b\";",
      "raw": true
    },
    {
      "indent": 7,
      "text": "revision 2015-04-04;\nrevision 2015-01-01;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "typedef myenum {\n  type enumeration {\n    enum zero; // added in 2015-01-01\n    enum one;  // added in 2015-04-04\n  }\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": " container x { // added in 2015-01-01 container y; // added in 2015-04-04 } }",
      "ja": "2015年1月1日容器yに添加容器X {//。 //}} 2015年4月4日に添加"
    },
    {
      "indent": 5,
      "text": "module c {\n  yang-version 1.1;\n  namespace \"urn:example:c\";\n  prefix \"c\";",
      "raw": true
    },
    {
      "indent": 7,
      "text": "revision 2015-02-02;",
      "ja": "改訂2015年2月2日;"
    },
    {
      "indent": 5,
      "text": "  typedef bar {\n    ...\n  }\n} module c {\n  yang-version 1.1;\n  namespace \"urn:example:c\";\n  prefix \"c\";",
      "raw": true
    },
    {
      "indent": 7,
      "text": "revision 2015-03-03;\nrevision 2015-02-02;",
      "raw": true
    },
    {
      "indent": 5,
      "text": " typedef bar { ... } }",
      "ja": "typedefのバー{...}}"
    },
    {
      "indent": 3,
      "text": "A server that implements revision \"2015-01-01\" of module \"a\" and supports feature \"foo\" can implement revision \"2015-01-01\" or \"2015-04-04\" of module \"b\". Since \"b\" was imported by revision, the type of leaf \"/b:x/a:y\" is the same, regardless of which revision of \"b\" the server implements.",
      "ja": "モジュールの改正「2015年1月1日を」実装「」と機能「foo」をサポートするサーバは、改訂版「2015年1月1日」または「2015年4月4日」モジュールの「b」を実装することができます。 「B」はリビジョンによってインポートされたので、葉「/ B：X / A：Y」の種類にかかわらず、「B」のサーバ実装のどのリビジョンが、同じです。"
    },
    {
      "indent": 3,
      "text": "A server that implements module \"a\" but does not support feature \"foo\" does not have to implement module \"b\".",
      "ja": "モジュールを実装し、サーバは「」が、機能「foo」をサポートしていないモジュール「b」を実装する必要はありません。"
    },
    {
      "indent": 3,
      "text": "A server that implements revision \"2015-01-01\" of module \"a\" picks any revision of module \"c\" and lists it in the \"/modules-state/module\" list from \"ietf-yang-library\".",
      "ja": "モジュールの改正「2015年1月1日」を実装し、サーバは、「モジュール」、「C」のいずれかのリビジョンをピックアップし、「IETF-ヤン・ライブラリー」から「/モジュール状態/モジュール」リストでそれを示しています。"
    },
    {
      "indent": 3,
      "text": "The following XML encoding example shows valid data for the \"/modules-state/module\" list for a server that implements module \"a\":",
      "ja": "次のXMLエンコーディングの例では、モジュール「A」を実装してサーバの「/モジュール状態/モジュール」リストの有効なデータを示しています。"
    },
    {
      "indent": 5,
      "text": "<modules-state xmlns=\"urn:ietf:params:xml:ns:yang:ietf-yang-library\"> <module-set-id>ee1ecb017370cafd</module-set-id> <module> <name>a</name> <revision>2015-01-01</revision> <namespace>urn:example:a</namespace> <feature>foo</feature> <conformance-type>implement</conformance-type> </module> <module> <name>b</name> <revision>2015-04-04</revision> <namespace>urn:example:b</namespace> <conformance-type>implement</conformance-type> </module>",
      "ja": "<モジュール状態のxmlns = \"URN：IETF：paramsは：XML：NS：陽：IETF-陽ライブラリ\"> <モジュール・セットID> ee1ecb017370cafd </モジュール・セットID> <モジュール> <名前> A < /名前> <リビジョン> 2015年1月1日</改訂> <名前空間> URN：例：</名前空間> <特徴> FOO </機能> <準拠型>実装</適合型> </モジュール> <モジュール> <名前> B </名前> <リビジョン> 2015年4月4日</改訂> <名前空間> URN：例：B </名前空間> <適合型>実装</適合型> </モジュール>"
    },
    {
      "indent": 5,
      "text": " <module> <name>c</name> <revision>2015-02-02</revision> <namespace>urn:example:c</namespace> <conformance-type>import</conformance-type> </module> </modules-state>",
      "ja": "<モジュール> <名前> C </名前> <リビジョン> 2015年2月2日</改訂> <名前空間> URN：例：C </名前空間> <適合型>インポート</適合型> </モジュール> </モジュール状態>"
    },
    {
      "indent": 0,
      "text": "5.7. Datastore Modification",
      "section_title": true,
      "ja": "5.7. データストアの変更"
    },
    {
      "indent": 3,
      "text": "Data models may allow the server to alter the configuration datastore in ways not explicitly directed via network management protocol messages. For example, a data model may define leafs that are assigned system-generated values when the client does not provide one. A formal mechanism for specifying the circumstances where these changes are allowed is out of scope for this specification.",
      "ja": "データモデルは、サーバーが明示的にネットワーク管理プロトコルメッセージを介して向けられていない方法で、構成データストアを変更することを可能にします。例えば、データ・モデルは、クライアントが1つを提供しない場合、システム生成された値が割り当てられているリーフを定義することができます。これらの変更が許可されている状況を指定するための正式な機構は、本明細書の範囲外です。"
    },
    {
      "indent": 0,
      "text": "6. YANG Syntax",
      "section_title": true,
      "ja": "6.シンタックス"
    },
    {
      "indent": 3,
      "text": "The YANG syntax is similar to that of SMIng [RFC3780] and programming languages like C and C++. This C-like syntax was chosen specifically for its readability, since YANG values the time and effort of the readers of models above those of modules writers and YANG tool-chain developers. This section introduces the YANG syntax.",
      "ja": "YANG構文はSMIng [RFC3780]とCとC ++のようなプログラミング言語の場合と同様です。 YANG、モジュールライターとYANGツールチェーンの開発のものの上にモデルの読者の時間と労力値ので、このCのような構文は、その読みやすさのために特別に選ばれました。このセクションでは、YANG構文を紹介します。"
    },
    {
      "indent": 3,
      "text": "Legal characters in YANG modules are the Unicode and ISO/IEC 10646 [ISO.10646] characters, including tab, carriage return, and line feed but excluding the other C0 control characters, the surrogate blocks, and the noncharacters. The character syntax is formally defined by the rule \"yang-char\" in Section 14.",
      "ja": "YANGモジュールで有効な文字は、タブ、改行、改行を含むUnicodeとISO / IEC 10646 [ISO.10646]文字、ですが、他のC0制御文字、サロゲートブロック、およびnoncharactersを除きます。文字の構文は正式に第14内のルール「ヤン-CHAR」によって定義されます。"
    },
    {
      "indent": 3,
      "text": "YANG modules and submodules are stored in files using the UTF-8 [RFC3629] character encoding.",
      "ja": "YANGモジュールおよびサブモジュールはUTF-8 [RFC3629]文字エンコーディングを使用してファイルに保存されます。"
    },
    {
      "indent": 3,
      "text": "Lines in a YANG module end with a carriage return-line feed combination or with a line feed alone. A carriage return that is not followed by a line feed may only appear inside a quoted string (Section 6.1.3). Note that carriage returns and line feeds that appear inside quoted strings become part of the value of the string without modification; the value of a multi-line quoted string contains the same form of line ends as those lines of the YANG module.",
      "ja": "キャリッジリターンラインフィードの組み合わせで、または単独で改行とYANGモジュールの端のライン。ラインフィードが続かないキャリッジリターンは、引用符で囲まれた文字列（セクション6.1.3）内に表示してもよいです。内部の引用符で囲まれた文字列を変更することなく、文字列の値の一部となって現れることキャリッジリターンとラインフィードに注意してください。マルチライン引用符で囲まれた文字列の値は、ラインの同じフォームがYANGモジュールのこれらのラインとして終了含ま。"
    },
    {
      "indent": 0,
      "text": "6.1. Lexical Tokenization",
      "section_title": true,
      "ja": "6.1. 字句トークン化"
    },
    {
      "indent": 3,
      "text": "YANG modules are parsed as a series of tokens. This section details the rules for recognizing tokens from an input stream. YANG tokenization rules are both simple and powerful. The simplicity is driven by a need to keep the parsers easy to implement, while the power is driven by the fact that modelers need to express their models in readable formats.",
      "ja": "YANGモジュールは、一連のトークンとして解析されます。このセクションでは、入力ストリームからトークンを認識するための規則を詳述します。 YANGのトークン化ルールはシンプルかつパワフルな両方です。シンプルさは、電源をモデラーが読める形式で自分のモデルを表現する必要があるという事実によって駆動される一方で、実装が容易パーサを維持する必要性によって駆動されます。"
    },
    {
      "indent": 0,
      "text": "6.1.1. Comments",
      "section_title": true,
      "ja": "6.1.1. 注釈"
    },
    {
      "indent": 3,
      "text": "Comments are C++ style.  A single line comment starts with \"//\" and\nends at the end of the line.  A block comment starts with \"/*\" and\nends with the nearest following \"*/\".",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Note that inside a quoted string (Section 6.1.3), these character pairs are never interpreted as the start or end of a comment.",
      "ja": "引用符で囲まれた文字列（6.1.3項）の内部で、これらの文字ペアは、コメントの開始または終了として解釈されることはありません。"
    },
    {
      "indent": 0,
      "text": "6.1.2. Tokens",
      "section_title": true,
      "ja": "6.1.2. トークン"
    },
    {
      "indent": 3,
      "text": "A token in YANG is either a keyword, a string, a semicolon (\";\"), or braces (\"{\" or \"}\"). A string can be quoted or unquoted. A keyword is either one of the YANG keywords defined in this document, or a prefix identifier, followed by a colon (\":\"), followed by a language extension keyword. Keywords are case sensitive. See Section 6.2 for a formal definition of identifiers.",
      "ja": "YANGにおけるトークンは、キーワード、文字列、セミコロン（「;」）のいずれかであるか、または括弧（「{」または「}」）。文字列を引用符で囲むか、引用符で囲まれていないことができます。キーワードはどちらかであるYANGの一つは、コロン（「：」）に続いて、この文書、またはプレフィックス識別子で定義されたキーワード、言語拡張キーワードが続きます。キーワードは大文字と小文字が区別されます。識別子の正式な定義については、セクション6.2を参照してください。"
    },
    {
      "indent": 0,
      "text": "6.1.3. Quoting",
      "section_title": true,
      "ja": "6.1.3. 引用"
    },
    {
      "indent": 3,
      "text": "An unquoted string is any sequence of characters that does not\ncontain any space, tab, carriage return, or line feed characters, a\nsingle or double quote character, a semicolon (\";\"), braces (\"{\" or\n\"}\"), or comment sequences (\"//\", \"/*\", or \"*/\").",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Note that any keyword can legally appear as an unquoted string.",
      "ja": "いずれかのキーワードが法的に引用符で囲まれていない文字列として表示されることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Within an unquoted string, every character is preserved. Note that this means that the backslash character does not have any special meaning in an unquoted string.",
      "ja": "引用符で囲まれていない文字列の中で、すべての文字が保存されます。これは、バックスラッシュ文字は引用符で囲まれていない文字列に特別な意味を持っていないことを意味することに注意してください。"
    },
    {
      "indent": 3,
      "text": "If a double-quoted string contains a line break followed by space or tab characters that are used to indent the text according to the layout in the YANG file, this leading whitespace is stripped from the string, up to and including the column of the starting double quote character, or to the first non-whitespace character, whichever occurs first. Any tab character in a succeeding line that must be examined for stripping is first converted into 8 space characters.",
      "ja": "二重引用符で囲まれた文字列は、YANGファイル内のレイアウトに応じてテキストをインデントするために使用されているスペースやタブ文字が続く改行が含まれている場合は、この先頭の空白は、開始の列までを含む、文字列から取り除かれます二重引用符、またはいずれか早い方最初の非空白文字に。ストリッピングのために検討されている必要があり、後続の行の任意のタブ文字は、最初の8つの空白文字に変換されます。"
    },
    {
      "indent": 3,
      "text": "If a double-quoted string contains space or tab characters before a line break, this trailing whitespace is stripped from the string.",
      "ja": "二重引用符で囲まれた文字列が改行の前にスペースまたはタブ文字が含まれている場合は、この末尾の空白は文字列から取り除かれます。"
    },
    {
      "indent": 3,
      "text": "A single-quoted string (enclosed within ' ') preserves each character within the quotes. A single quote character cannot occur in a single-quoted string, even when preceded by a backslash.",
      "ja": "（「'で囲まれた）の単一引用符で囲まれた文字列は引用符内の各文字を保持します。単一引用符文字はバックスラッシュが先行した場合であっても、単一引用符で囲まれた文字列で発生することはできません。"
    },
    {
      "indent": 3,
      "text": "Within a double-quoted string (enclosed within \" \"), a backslash character introduces a representation of a special character, which depends on the character that immediately follows the backslash:",
      "ja": "二重引用符で囲まれた文字列（「\"で囲まれた）の中では、バックスラッシュ文字はすぐにバックスラッシュの後に続く文字に依存の特殊文字の表現を紹介します。"
    },
    {
      "indent": 4,
      "text": "\\n newline \\t a tab character \\\" a double quote \\\\ a single backslash",
      "ja": "\\ nは改行\\ Tタブ文字\\」二重引用符\\\\単一のバックスラッシュ"
    },
    {
      "indent": 3,
      "text": "The backslash MUST NOT be followed by any other character.",
      "ja": "バックスラッシュは他の文字が続いてはなりません。"
    },
    {
      "indent": 3,
      "text": "If a quoted string is followed by a plus character (\"+\"), followed by another quoted string, the two strings are concatenated into one string, allowing multiple concatenations to build one string. Whitespace, line breaks, and comments are allowed between the quoted strings and the plus character.",
      "ja": "引用符で囲まれた文字列は、プラス記号（「+」​​）が続いている場合は、別の引用符で囲まれた文字列が続き、二つの文字列は、複数の連結は、1つの文字列を構築することができ、1つの文字列に連結されています。空白、改行、およびコメントが引用符で囲まれた文字列とプラス文字の間で許可されています。"
    },
    {
      "indent": 3,
      "text": "In double-quoted strings, whitespace trimming is done before substitution of backslash-escaped characters. Concatenation is performed as the last step.",
      "ja": "二重引用符で囲まれた文字列では、空白の切捨ては、バックスラッシュでエスケープ文字の置換の前に行われます。連結は、最後のステップとして実行されます。"
    },
    {
      "indent": 0,
      "text": "6.1.3.1. Quoting Examples",
      "section_title": true,
      "ja": "6.1.3.1。例を引用"
    },
    {
      "indent": 3,
      "text": "The following strings are equivalent:",
      "ja": "以下の文字列は等価です。"
    },
    {
      "indent": 5,
      "text": "hello \"hello\" 'hello' \"hel\" + \"lo\" 'hel' + \"lo\"",
      "ja": "「ハロー」ハロー「こんにちは」「全体」+「イオ」「たくさん」+「イオ」"
    },
    {
      "indent": 3,
      "text": "The following examples show some special strings:",
      "ja": "次の例では、いくつかの特別な文字列を示しています。"
    },
    {
      "indent": 5,
      "text": "\"\\\"\" - string containing a double quote '\"' - string containing a double quote \"\\n\" - string containing a newline character '\\n' - string containing a backslash followed by the character n",
      "ja": "「\\」「 - 二重引用符を含む文字列「」」を - 二重引用符を含む文字列 『\\ n』を - 文字nはバックスラッシュを含む文字列 - 改行文字 『\\ n個』を含む文字列"
    },
    {
      "indent": 3,
      "text": "The following examples show some illegal strings:",
      "ja": "次の例では、いくつかの違法な文字列を示しています。"
    },
    {
      "indent": 5,
      "text": "'''' - a single-quoted string cannot contain single quotes \"\"\" - a double quote must be escaped in a double-quoted string",
      "ja": "「」「」 - 単一引用符で囲まれた文字列は、単一引用符を含めることはできません「」」 - 二重引用符は、二重引用符で囲まれた文字列にエスケープする必要があります"
    },
    {
      "indent": 3,
      "text": "The following strings are equivalent:",
      "ja": "以下の文字列は等価です。"
    },
    {
      "indent": 9,
      "text": "\"first line\n   second line\"",
      "raw": true
    },
    {
      "indent": 5,
      "text": "\"first line\\n\" + \" second line\"",
      "ja": "「最初の行\\ n」+「セカンドライン」"
    },
    {
      "indent": 0,
      "text": "6.2. Identifiers",
      "section_title": true,
      "ja": "6.2. 識別子"
    },
    {
      "indent": 3,
      "text": "Identifiers are used to identify different kinds of YANG items by name. Each identifier starts with an uppercase or lowercase ASCII letter or an underscore character, followed by zero or more ASCII letters, digits, underscore characters, hyphens, and dots. Implementations MUST support identifiers up to 64 characters in length and MAY support longer identifiers. Identifiers are case sensitive. The identifier syntax is formally defined by the rule \"identifier\" in Section 14. Identifiers can be specified as quoted or unquoted strings.",
      "ja": "識別子は名前でYANGアイテムの種類を識別するために使用されています。各識別子は、ゼロ個以上のASCII文字に続く大文字または小文字のASCII文字またはアンダースコア文字で始まり、数字は、文字、ハイフン、ドットを強調する。実装は、長さは64文字までの識別子をサポートしなければならないと長い識別子をサポートするかもしれません。識別子は大文字と小文字が区別されます。識別子の構文は、正式に14識別子が引用されたか、引用符で囲まれていない文字列として指定することができ、セクション内のルール「識別子」によって定義されます。"
    },
    {
      "indent": 0,
      "text": "6.2.1. Identifiers and Their Namespaces",
      "section_title": true,
      "ja": "6.2.1. 識別子とその名前空間"
    },
    {
      "indent": 3,
      "text": "Each identifier is valid in a namespace that depends on the type of the YANG item being defined. All identifiers defined in a namespace MUST be unique.",
      "ja": "各識別子は定義されているYANGアイテムの種類によって異なり、ネームスペースで有効です。名前空間で定義されたすべての識別子はユニークでなければなりません。"
    },
    {
      "indent": 3,
      "text": "o All module and submodule names share the same global module identifier namespace.",
      "ja": "Oすべてのモジュールおよびサブモジュール名が同じグローバルモジュール識別子の名前空間を共有しています。"
    },
    {
      "indent": 3,
      "text": "o All extension names defined in a module and its submodules share the same extension identifier namespace.",
      "ja": "Oモジュールとそのサブモジュールで定義されたすべての拡張子名は同じ拡張識別子の名前空間を共有しています。"
    },
    {
      "indent": 3,
      "text": "o All feature names defined in a module and its submodules share the same feature identifier namespace.",
      "ja": "Oモジュールとそのサブモジュールで定義されたすべての機能名は、同じ機能の識別子の名前空間を共有しています。"
    },
    {
      "indent": 3,
      "text": "o All identity names defined in a module and its submodules share the same identity identifier namespace.",
      "ja": "Oモジュールとそのサブモジュールで定義されたすべてのID名が同じID識別子の名前空間を共有しています。"
    },
    {
      "indent": 3,
      "text": "o All derived type names defined within a parent node or at the top level of the module or its submodules share the same type identifier namespace. This namespace is scoped to all descendant nodes of the parent node or module. This means that any descendant node may use that typedef, and it MUST NOT define a typedef with the same name.",
      "ja": "O親ノード内またはモジュールまたはサブモジュールのトップレベルで定義されたすべての派生型の名前は、同じタイプの識別子の名前空間を共有します。この名前空間は、親ノードまたはモジュールのすべての子孫ノードにスコープされます。これは、任意の子孫ノードは、そのtypedefをを使用することができ、そしてそれは同じ名前でのtypedefを定義してはならないことを意味します。"
    },
    {
      "indent": 3,
      "text": "o All grouping names defined within a parent node or at the top level of the module or its submodules share the same grouping identifier namespace. This namespace is scoped to all descendant nodes of the parent node or module. This means that any descendant node may use that grouping, and it MUST NOT define a grouping with the same name.",
      "ja": "O親ノード内またはモジュールまたはサブモジュールのトップレベルで定義されたすべてのグループ名が同じグループ識別子の名前空間を共有します。この名前空間は、親ノードまたはモジュールのすべての子孫ノードにスコープされます。これは、任意の子孫ノードがそのグループ化を使用することができ、それは、同じ名前のグループを定義してはならないことを意味します。"
    },
    {
      "indent": 3,
      "text": "o All leafs, leaf-lists, lists, containers, choices, rpcs, actions, notifications, anydatas, and anyxmls defined (directly or through a \"uses\" statement) within a parent node or at the top level of the module or its submodules share the same identifier namespace. This namespace is scoped to the parent node or module, unless the parent node is a case node. In that case, the namespace is scoped to the closest ancestor node that is not a case or choice node.",
      "ja": "O定義されたすべての葉、葉、リスト、リスト、コンテナ、選択肢、RPCの、アクション、通知、anydatas、およびanyxmls親ノード内またはモジュールまたはそのサブモジュールのトップレベルに（直接または経由で文を「使用しています」）同じ識別子の名前空間を共有しています。親ノードは、ケースノードでない限り、この名前空間は、親ノードまたはモジュールにスコープされています。その場合には、名前空間は、ケースまたは選択ノードではない、最も近い祖先ノードにスコープされます。"
    },
    {
      "indent": 3,
      "text": "o All cases within a choice share the same case identifier namespace. This namespace is scoped to the parent choice node.",
      "ja": "O選択内のすべての例は、同じケース識別子の名前空間を共有しています。この名前空間は、親の選択ノードにスコープされます。"
    },
    {
      "indent": 3,
      "text": "Forward references are allowed in YANG.",
      "ja": "前方参照はYANGで許可されています。"
    },
    {
      "indent": 0,
      "text": "6.3. Statements",
      "section_title": true,
      "ja": "6.3. ステートメント"
    },
    {
      "indent": 3,
      "text": "A YANG module contains a sequence of statements. Each statement starts with a keyword, followed by zero or one argument, followed by either a semicolon (\";\") or a block of substatements enclosed within braces (\"{ }\"):",
      "ja": "YANGモジュールは、一連の文が含まれています。各ステートメントは、0または1の引数に続く、キーワードで始まりセミコロン（「;」）のいずれかに続いて、または中括弧で囲まれサブステートメントのブロック（「{}」）。"
    },
    {
      "indent": 5,
      "text": "statement = keyword [argument] (\";\" / \"{\" *statement \"}\")",
      "ja": "文=キーワード[引数]（ \";\" / \"{\" *ステートメント \"}\"）"
    },
    {
      "indent": 3,
      "text": "The argument is a string, as defined in Section 6.1.2.",
      "ja": "6.1.2項で定義されるように引数は、文字列です。"
    },
    {
      "indent": 0,
      "text": "6.3.1. Language Extensions",
      "section_title": true,
      "ja": "6.3.1. 言語拡張機能"
    },
    {
      "indent": 3,
      "text": "A module can introduce YANG extensions by using the \"extension\" keyword (see Section 7.19). The extensions can be imported by other modules with the \"import\" statement (see Section 7.1.5). When an imported extension is used, the extension's keyword MUST be qualified using the prefix with which the extension's module was imported. If an extension is used in the module where it is defined, the extension's keyword MUST be qualified with the prefix of this module.",
      "ja": "モジュールは、「拡張子」のキーワード（セクション7.19を参照）を使用してYANG拡張を導入することができます。拡張子が「インポート」文を使用して、他のモジュールによってインポートすることができます（7.1.5項を参照してください）。インポートされた拡張子を使用する場合は、拡張機能のキーワードは、拡張機能のモジュールがインポートされたとの接頭辞を使用して修飾する必要があります。拡張は、それが定義されているモジュールで使用されている場合、拡張機能のキーワードは、このモジュールの接頭辞で修飾する必要があります。"
    },
    {
      "indent": 3,
      "text": "The processing of extensions depends on whether support for those extensions is claimed for a given YANG parser or the tool set in which it is embedded. An unsupported extension appearing in a YANG module as an unknown-statement (see Section 14) MAY be ignored in its entirety. Any supported extension MUST be processed in accordance with the specification governing that extension.",
      "ja": "拡張機能の処理は、これらの拡張機能のサポートが与えられたYANGパーサまたはそれが埋め込まれているツールセットのために記載されているかどうかに依存します。未知の文としてYANGモジュールに登場する、サポートされていない拡張機能は、その全体が無視されるかもしれません（セクション14を参照します）。サポートされている任意の拡張子は、その拡張子を支配する仕様に従って処理しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Care must be taken when defining extensions so that modules that use the extensions are meaningful also for applications that do not support the extensions.",
      "ja": "拡張機能を使用モジュールは拡張をサポートしないアプリケーションのためにも意味があるように拡張を定義するときには注意する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.4. XPath Evaluations",
      "section_title": true,
      "ja": "6.4.  XPathの評価"
    },
    {
      "indent": 3,
      "text": "YANG relies on XML Path Language (XPath) 1.0 [XPATH] as a notation for specifying many inter-node references and dependencies. An implementation is not required to implement an XPath interpreter but MUST ensure that the requirements encoded in the data model are enforced. The manner of enforcement is an implementation decision. The XPath expressions MUST be syntactically correct, and all prefixes used MUST be present in the XPath context (see Section 6.4.1). An implementation may choose to implement them by hand, rather than using the XPath expression directly.",
      "ja": "YANGは、多くのノード間の参照および依存関係を指定するための表記法として、XMLパス言語（XPath）1.0 [XPATH]に依存しています。実装は、XPathインタプリタを実装するために必要とされていないが、データ・モデルで符号化された要件が適用されていることを確認しなければなりません。執行の方法は、実装決定です。 XPath式は、構文的に正しくなければならない、およびXPathのコンテキスト内に存在していなければなりません使用されるすべてのプレフィックス（セクション6.4.1を参照します）。実装ではなく、直接XPath式を使用するよりも、手でそれらを実装することもできます。"
    },
    {
      "indent": 3,
      "text": "The data model used in the XPath expressions is the same as that used in XPath 1.0 [XPATH], with the same extension for root node children as used by XSLT 1.0 (see Section 3.1 in [XSLT]). Specifically, it means that the root node may have any number of element nodes as its children.",
      "ja": "XSLT 1.0（[XSLT]でセクション3.1を参照）で使用されるXPath式で使用されるデータモデルは、ルートノードの子のための同じ拡張子で、XPath 1.0の[XPATH]で使用したものと同じです。具体的には、ルート・ノードは、その子として要素の任意の数のノードを有することができることを意味します。"
    },
    {
      "indent": 3,
      "text": "The data tree has no concept of document order. An implementation needs to choose some document order, but how it is done is an implementation decision. This means that XPath expressions in YANG modules SHOULD NOT rely on any specific document order.",
      "ja": "データツリーは、文書順序の概念がありません。実装には、いくつかのドキュメントの順序を選択する必要がありますが、どのようにそれが行われることは実装上の決定です。これは、YANGモジュールでXPath式が任意の特定の文書の順序に依存してはならないことを意味します。"
    },
    {
      "indent": 3,
      "text": "Numbers in XPath 1.0 are IEEE 754 [IEEE754-2008] double-precision floating-point values; see Section 3.5 in [XPATH]. This means that some values of int64, uint64, and decimal64 types (see Sections 9.2 and 9.3) cannot be exactly represented in XPath expressions. Therefore, due caution should be exercised when using nodes with 64-bit numeric values in XPath expressions. In particular, numerical comparisons involving equality may yield unexpected results.",
      "ja": "XPath 1.0の中の数字は、IEEE 754 [IEEE754-2008]倍精度浮動小数点値です。 [XPATH]でセクション3.5を参照してください。これはint64型、uint64型、およびdecimal64種類のいくつかの値が正確にXPath式で表すことができない（セクション9.2と9.3を参照）ことを意味します。 XPath式では64ビットの数値を持つノードを使用する場合にそのため、注意が払われるべきです。具体的には、平等に関わる数値比較は予期しない結果をもたらす可能性があります。"
    },
    {
      "indent": 3,
      "text": "For example, consider the following definition:",
      "ja": "たとえば、次のような定義を考えてみます。"
    },
    {
      "indent": 5,
      "text": "leaf lxiv {\n  type decimal64 {\n    fraction-digits 18;\n  }\n  must \". <= 10\";\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "An instance of the \"lxiv\" leaf having the value of 10.0000000000000001 will then successfully pass validation.",
      "ja": "10.0000000000000001の値を有する「LXIV」の葉のインスタンスは、成功した検証を通過します。"
    },
    {
      "indent": 0,
      "text": "6.4.1. XPath Context",
      "section_title": true,
      "ja": "6.4.1.  XPathのコンテキスト"
    },
    {
      "indent": 3,
      "text": "All YANG XPath expressions share the following XPath context definition:",
      "ja": "すべてYANG XPath式は、次のXPathコンテキスト定義を共有します："
    },
    {
      "indent": 3,
      "text": "o The set of namespace declarations is the set of all \"import\" statements' prefix and namespace pairs in the module where the XPath expression is specified, and the \"prefix\" statement's prefix for the \"namespace\" statement's URI.",
      "ja": "O名前空間宣言のセットは、XPath式が指定されたモジュール内のすべての「インポート」文プレフィックスと名前空間のペアのセット、および 『名前空間』のステートメントのURIのための 『接頭辞』文の接頭辞があります。"
    },
    {
      "indent": 3,
      "text": "o Names without a namespace prefix belong to the same namespace as the identifier of the current node. Inside a grouping, that namespace is affected by where the grouping is used (see Section 7.13). Inside a typedef, that namespace is affected by where the typedef is referenced. If a typedef is defined and referenced within a grouping, the namespace is affected by where the grouping is used (see Section 7.13).",
      "ja": "名前空間接頭辞なしのO名前は、現在のノードの識別子と同じ名前空間に属します。グループ内では、その名前空間は、グループ化を使用した場合の影響を受けている（セクション7.13を参照してください）。 typedefの内部では、その名前空間は、typedefのが参照された場合の影響を受けています。 typedefのが定義され、グループ内で参照されている場合は、名前空間がグルーピングを使用する場合に影響される（セクション7.13を参照）。"
    },
    {
      "indent": 3,
      "text": "o The function library is the core function library defined in [XPATH] and the functions defined in Section 10.",
      "ja": "関数ライブラリO [XPATH]で定義されたコア関数ライブラリであり、セクション10で定義された関数。"
    },
    {
      "indent": 3,
      "text": "o The set of variable bindings is empty.",
      "ja": "O変数バインディングのセットは空です。"
    },
    {
      "indent": 3,
      "text": "The mechanism for handling unprefixed names is adopted from XPath 2.0 [XPATH2.0] and helps simplify XPath expressions in YANG. No ambiguity may ever arise, because YANG node identifiers are always qualified names with a non-null namespace URI.",
      "ja": "接頭辞名を処理するための機構は、XPath 2.0 [XPATH2.0]から採用し、YANGでXPath式を簡素化されています。 YANGノード識別子は常にnull以外の名前空間URIを持つ修飾名であるため、いかなる曖昧さは、これまで、発生しないことがあります。"
    },
    {
      "indent": 3,
      "text": "The accessible tree depends on where the statement with the XPath expression is defined:",
      "ja": "アクセスツリーは、XPath式と文が定義されている場所によって異なります。"
    },
    {
      "indent": 3,
      "text": "o If the XPath expression is defined in a substatement to a data node that represents configuration, the accessible tree is the data in the datastore where the context node exists. The root node has all top-level configuration data nodes in all modules as children.",
      "ja": "XPath式は、コンフィギュレーションを表すデータノードにサプで定義されている場合、O、アクセスツリーは、コンテキスト・ノードが存在するデータストア内のデータです。ルートノードは子としてすべてのモジュール内のすべてのトップレベルのコンフィギュレーションデータノードを有します。"
    },
    {
      "indent": 3,
      "text": "o If the XPath expression is defined in a substatement to a data node that represents state data, the accessible tree is all state data in the server, and the running configuration datastore. The root node has all top-level data nodes in all modules as children.",
      "ja": "XPath式は、状態データを表すデータノードにサプで定義されている場合、O、アクセス可能なツリーは、サーバ内のすべての状態データ、および実行コンフィギュレーションデータストアです。ルートノードは子としてすべてのモジュール内のすべてのトップレベル・データ・ノードを有します。"
    },
    {
      "indent": 3,
      "text": "o If the XPath expression is defined in a substatement to a \"notification\" statement, the accessible tree is the notification instance, all state data in the server, and the running configuration datastore. If the notification is defined on the top level in a module, then the root node has the node representing the notification being defined and all top-level data nodes in all modules as children. Otherwise, the root node has all top-level data nodes in all modules as children.",
      "ja": "XPath式は、「通知」文のサブステートメントで定義されている場合は、O、アクセスツリーが通知インスタンスで、サーバー内のすべての状態データ、および実行コンフィギュレーションデータストア。通知は、モジュール内の最上位レベルで定義されている場合、ルートノードは、定義された通知や子供などのすべてのモジュール内のすべてのトップレベルのデータノードを表すノードを有します。そうでなければ、ルートノードは子としてすべてのモジュール内のすべてのトップレベル・データ・ノードを有します。"
    },
    {
      "indent": 3,
      "text": "o If the XPath expression is defined in a substatement to an \"input\" statement in an \"rpc\" or \"action\" statement, the accessible tree is the RPC or action operation instance, all state data in the server, and the running configuration datastore. The root node has top-level data nodes in all modules as children. Additionally, for an RPC, the root node also has the node representing the RPC operation being defined as a child. The node representing the operation being defined has the operation's input parameters as children.",
      "ja": "XPath式は、「RPC」または「アクション」声明の中で「入力」声明にサブステートメントで定義されている場合は、O、アクセスツリーは、RPCやアクション操作インスタンス、サーバー内のすべての状態データ、および実行コンフィギュレーションデータストアがあります。ルートノードは子としてすべてのモジュールのトップレベル・データ・ノードを有します。加えて、RPCのために、ルートノードは、子として定義されるRPC操作を表すノードを有します。定義されている操作を表すノードは、子供のように、操作者の入力パラメータがあります。"
    },
    {
      "indent": 3,
      "text": "o If the XPath expression is defined in a substatement to an \"output\" statement in an \"rpc\" or \"action\" statement, the accessible tree is the RPC or action operation instance, all state data in the server, and the running configuration datastore. The root node has top-level data nodes in all modules as children. Additionally, for an RPC, the root node also has the node representing the RPC operation being defined as a child. The node representing the operation being defined has the operation's output parameters as children.",
      "ja": "XPath式は、「RPC」または「アクション」声明で「出力」ステートメントにサブステートメントで定義されている場合は、O、アクセスツリーは、RPCやアクション操作インスタンス、サーバー内のすべての状態データ、および実行コンフィギュレーションデータストアがあります。ルートノードは子としてすべてのモジュールのトップレベル・データ・ノードを有します。加えて、RPCのために、ルートノードは、子として定義されるRPC操作を表すノードを有します。定義されている操作を表すノードは、子供のように操作の出力パラメータがあります。"
    },
    {
      "indent": 3,
      "text": "In the accessible tree, all leafs and leaf-lists with default values in use exist (see Sections 7.6.1 and 7.7.2).",
      "ja": "アクセスツリーで、使用中のデフォルト値で、すべての葉と葉のリストは、（セクション7.6.1と7.7.2を参照）が存在します。"
    },
    {
      "indent": 3,
      "text": "If a node that exists in the accessible tree has a non-presence container as a child, then the non-presence container also exists in the accessible tree.",
      "ja": "アクセスツリーに存在するノードは子として非存在コンテナを持っている場合は、非存在のコンテナにもアクセス可能ツリーに存在しています。"
    },
    {
      "indent": 3,
      "text": "The context node varies with the YANG XPath expression and is specified where the YANG statement with the XPath expression is defined.",
      "ja": "コンテキストノードがYANG XPath式と異なり、XPath式とYANG文が定義される指定されています。"
    },
    {
      "indent": 0,
      "text": "6.4.1.1. Examples",
      "section_title": true,
      "ja": "6.4.1.1。例"
    },
    {
      "indent": 3,
      "text": "Given the following module:",
      "ja": "以下のモジュールを考えます："
    },
    {
      "indent": 5,
      "text": "module example-a {\n  yang-version 1.1;\n  namespace urn:example:a;\n  prefix a;",
      "raw": true
    },
    {
      "indent": 5,
      "text": "  container a {\n    list b {\n      key id;\n      leaf id {\n        type string;\n      }\n      notification down {\n        leaf reason {\n          type string;\n        }\n      }\n      action reset {\n        input {\n          leaf delay {\n            type uint32;\n          }\n        }\n        output {\n          leaf result {\n            type string;\n          }\n        }\n      }\n    }\n  }\n  notification failure {\n    leaf b-ref {\n      type leafref {\n        path \"/a/b/id\";\n      }\n    }\n  }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "and given the following data tree, specified in XML:",
      "ja": "そしてXMLで指定され、以下のデータツリーを与えられました："
    },
    {
      "indent": 5,
      "text": "<a xmlns=\"urn:example:a\"> <b> <id>1</id> </b> <b> <id>2</id> </b> </a>",
      "ja": "<a xmlns=\"urn:example:a\"> <B> 1 </ ID> </ B> <ID> <B> <ID> 2 </ ID> </ B>する</a>"
    },
    {
      "indent": 3,
      "text": "The accessible tree for a notification \"down\" on /a/b[id=\"2\"] is:",
      "ja": "/ A / Bに通知 \"ダウン\" のアクセスツリー[ID = \"2\"]です。"
    },
    {
      "indent": 5,
      "text": "<a xmlns=\"urn:example:a\"> <b> <id>1</id> </b> <b> <id>2</id> <down> <reason>error</reason> </down> </b> </a> // possibly other top-level nodes here",
      "ja": "<a xmlns=\"urn:example:a\"> <B> <ID> 1 </ ID> </ B> <B> <ID> 2 </ ID> <ダウン> <理由>誤り</理由> <ここで/ダウン> </ b>の</a>を//おそらく他のトップレベルのノード"
    },
    {
      "indent": 3,
      "text": "The accessible tree for an action invocation of \"reset\" on /a/b[id=\"1\"] with the \"when\" parameter set to \"10\" would be:",
      "ja": "：「」を「10」に設定パラメータがあろうと[ID =「1」] / A / Bの「リセット」のアクションの呼び出しのためにアクセス可能なツリー"
    },
    {
      "indent": 5,
      "text": "<a xmlns=\"urn:example:a\"> <b> <id>1</id> <reset> <delay>10</delay> </reset> </b> <b> <id>2</id> </b> </a> // possibly other top-level nodes here",
      "ja": "<a xmlns=\"urn:example:a\"> <B> <ID> 1 </ ID> <リセット> <遅延時間> 10 </遅延> </リセット> </ B> <B> <ID> 2 <ここで/ ID> </ B> </a>の//おそらく他のトップレベルノード"
    },
    {
      "indent": 3,
      "text": "The accessible tree for the action output of this action is:",
      "ja": "この行動の行動出力のためにアクセスツリーは次のとおりです。"
    },
    {
      "indent": 5,
      "text": "<a xmlns=\"urn:example:a\"> <b> <id>1</id> <reset> <result>ok</result> </reset> </b> <b> <id>2</id> </b> </a> // possibly other top-level nodes here",
      "ja": "<a xmlns=\"urn:example:a\"> <B> <ID> 1 </ ID> <リセット> <結果> OK </結果> </リセット> </ B> <B> <ID> 2 <ここで/ ID> </ B> </a>の//おそらく他のトップレベルノード"
    },
    {
      "indent": 3,
      "text": "The accessible tree for a notification \"failure\" could be:",
      "ja": "通知「失敗」のためにアクセスツリーは以下のようになります。"
    },
    {
      "indent": 5,
      "text": "<a xmlns=\"urn:example:a\"> <b> <id>1</id> </b> <b> <id>2</id> </b> </a> <failure> <b-ref>2</b-ref> </failure> // possibly other top-level nodes here",
      "ja": "<a xmlns=\"urn:example:a\"> <B> <ID> 1 </ ID> </ B> <B> <ID> 2 </ ID> </ B> </a>の<不良> <ここでB-REF> 2 </ B-ref>を</障害> //おそらく他のトップレベルノード"
    },
    {
      "indent": 0,
      "text": "6.5. Schema Node Identifier",
      "section_title": true,
      "ja": "6.5. スキームノード識別子"
    },
    {
      "indent": 3,
      "text": "A schema node identifier is a string that identifies a node in the schema tree. It has two forms, \"absolute\" and \"descendant\", defined by the rules \"absolute-schema-nodeid\" and \"descendant-schema-nodeid\" in Section 14, respectively. A schema node identifier consists of a path of identifiers, separated by slashes (\"/\"). In an absolute schema node identifier, the first identifier after the leading slash is any top-level schema node in the local module or in an imported module.",
      "ja": "スキーマノード識別子は、スキーマ・ツリー内のノードを識別する文字列です。これは、それぞれのセクション14のルール「絶対スキーマNODEID」および「子孫-スキーマNODEID」によって定義された2つの形態、「絶対」及び「子孫」を有します。スキーマノード識別子は、スラッシュで区切られた識別子のパス（「/」）から成ります。絶対的なスキーマのノード識別子は、スラッシュの後の最初の識別子は、ローカル・モジュールまたはインポートされたモジュール内の任意の最上位スキーマノードです。"
    },
    {
      "indent": 3,
      "text": "References to identifiers defined in external modules MUST be qualified with appropriate prefixes, and references to identifiers defined in the current module and its submodules MAY use a prefix.",
      "ja": "外部モジュールで定義された識別子への参照は、適切な接頭辞で修飾する必要があり、かつ現在のモジュールで定義された識別子とそのサブモジュールへの参照は、接頭辞を使用するかもしれません。"
    },
    {
      "indent": 3,
      "text": "For example, to identify the child node \"b\" of top-level node \"a\", the string \"/a/b\" can be used.",
      "ja": "例えば、トップレベルノード「A」の子ノードを識別するために、「B」、文字列「/ A / B」を使用することができます。"
    },
    {
      "indent": 0,
      "text": "7. YANG Statements",
      "section_title": true,
      "ja": "7.ステートメント"
    },
    {
      "indent": 3,
      "text": "The following sections describe all of the YANG statements.",
      "ja": "次のセクションでは、YANG文のすべてを説明します。"
    },
    {
      "indent": 3,
      "text": "Note that even a statement that does not have any substatements defined in YANG can have vendor-specific extensions as substatements. For example, the \"description\" statement does not have any substatements defined in YANG, but the following is legal:",
      "ja": "YANGで定義されたすべてのサブステートメントを持っていなくても文がサブステートメントとしてベンダー固有の拡張機能を持つことができることに注意してください。たとえば、「説明」の文は、YANGで定義されたすべてのサブステートメントはありませんが、以下が有効です。"
    },
    {
      "indent": 5,
      "text": "description \"Some text.\" { ex:documentation-flag 5; }",
      "ja": "説明「いくつかのテキスト。」 {例：文書フラグ5。 }"
    },
    {
      "indent": 0,
      "text": "7.1. The \"module\" Statement",
      "section_title": true,
      "ja": "7.1.  「モジュール」声明"
    },
    {
      "indent": 3,
      "text": "The \"module\" statement defines the module's name and groups all statements that belong to the module together. The \"module\" statement's argument is the name of the module, followed by a block of substatements that holds detailed module information. The module name is an identifier (see Section 6.2).",
      "ja": "「モジュール」のステートメントは、モジュールの名前と一緒にグループモジュールに属するすべてのステートメントを定義します。 「モジュール」文の引数には、詳細なモジュール情報を保持しているサブステートメントのブロックに続いて、モジュールの名前です。モジュール名は、識別子（6.2節を参照）です。"
    },
    {
      "indent": 3,
      "text": "Names of modules published in RFC streams [RFC4844] MUST be assigned by IANA; see Section 14 in [RFC6020].",
      "ja": "RFCストリーム[RFC4844]に掲載されたモジュールの名前は、IANAによって割り当てられなければなりません。 [RFC6020]でセクション14を参照してください。"
    },
    {
      "indent": 3,
      "text": "Private module names are assigned by the organization owning the module without a central registry. See Section 5.1 for recommendations on how to name modules.",
      "ja": "プライベートモジュール名は、中央レジストリせずにモジュールを所有している組織によって割り当てられます。モジュールに名前を付ける方法に関する推奨事項については、5.1節を参照してください。"
    },
    {
      "indent": 3,
      "text": "A module typically has the following layout:",
      "ja": "モジュールは、一般的に次のようなレイアウトになっています。"
    },
    {
      "indent": 5,
      "text": "module <module-name> {",
      "ja": "モジュール<モジュール名> {"
    },
    {
      "indent": 7,
      "text": "// header information <yang-version statement> <namespace statement> <prefix statement>",
      "ja": "//ヘッダ情報<ヤン・バージョン声明> <名前空間のステートメント> <接頭辞書>"
    },
    {
      "indent": 7,
      "text": "// linkage statements <import statements> <include statements>",
      "ja": "//リンケージ文<import文> <include文を>"
    },
    {
      "indent": 7,
      "text": "// meta-information <organization statement> <contact statement> <description statement> <reference statement>",
      "ja": "//メタ情報<組織声明> <接触声明> <説明書> <参考書>"
    },
    {
      "indent": 7,
      "text": "// revision history <revision statements>",
      "ja": "//改訂履歴<改正文>"
    },
    {
      "indent": 5,
      "text": " // module definitions <other statements> }",
      "ja": "//モジュール定義<他の文>}"
    },
    {
      "indent": 0,
      "text": "7.1.1. The module's Substatements",
      "section_title": true,
      "ja": "7.1.1. モジュールのサブステートメント"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| anydata      | 7.10    | 0..n        |\n| anyxml       | 7.11    | 0..n        |\n| augment      | 7.17    | 0..n        |\n| choice       | 7.9     | 0..n        |\n| contact      | 7.1.8   | 0..1        |\n| container    | 7.5     | 0..n        |\n| description  | 7.21.3  | 0..1        |\n| deviation    | 7.20.3  | 0..n        |\n| extension    | 7.19    | 0..n        |\n| feature      | 7.20.1  | 0..n        |\n| grouping     | 7.12    | 0..n        |\n| identity     | 7.18    | 0..n        |\n| import       | 7.1.5   | 0..n        |\n| include      | 7.1.6   | 0..n        |\n| leaf         | 7.6     | 0..n        |\n| leaf-list    | 7.7     | 0..n        |\n| list         | 7.8     | 0..n        |\n| namespace    | 7.1.3   | 1           |\n| notification | 7.16    | 0..n        |\n| organization | 7.1.7   | 0..1        |\n| prefix       | 7.1.4   | 1           |\n| reference    | 7.21.4  | 0..1        |\n| revision     | 7.1.9   | 0..n        |\n| rpc          | 7.14    | 0..n        |\n| typedef      | 7.3     | 0..n        |\n| uses         | 7.13    | 0..n        |\n| yang-version | 7.1.2   | 1           |\n+--------------+---------+-------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.1.2. The \"yang-version\" Statement",
      "section_title": true,
      "ja": "7.1.2.  「ヤン・バージョン」声明"
    },
    {
      "indent": 3,
      "text": "The \"yang-version\" statement specifies which version of the YANG language was used in developing the module. The statement's argument is a string. It MUST contain the value \"1.1\" for YANG modules defined based on this specification.",
      "ja": "「ヤン・バージョン」のステートメントは、モジュールの開発に使用されたYANG言語のバージョンを指定します。文の引数は文字列です。これは、この仕様に基づいて定義さYANGモジュールの値「1.1」を含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "A module or submodule that doesn't contain the \"yang-version\" statement, or one that contains the value \"1\", is developed for YANG version 1, defined in [RFC6020].",
      "ja": "「ヤン・バージョン」ステートメント、または値「1」を含むものが含まれていないモジュールまたはサブモジュールは、[RFC6020]で定義され、YANGバージョン1のために開発されています。"
    },
    {
      "indent": 3,
      "text": "Handling of the \"yang-version\" statement for versions other than \"1.1\" (the version defined here) is out of scope for this specification. Any document that defines a higher version will need to define the backward compatibility of such a higher version.",
      "ja": "「1.1」以外のバージョンについては、「ヤン・バージョン」文（ここで定義されたバージョン）の取り扱いについては、この仕様の範囲外です。より高いバージョンを定義する任意の文書は、そのようなより高いバージョンの下位互換性を定義する必要があります。"
    },
    {
      "indent": 3,
      "text": "For compatibility between YANG versions 1 and 1.1, see Section 12.",
      "ja": "YANGバージョン1と1.1の間の互換性のために、セクション12を参照してください。"
    },
    {
      "indent": 0,
      "text": "7.1.3. The \"namespace\" Statement",
      "section_title": true,
      "ja": "7.1.3.  「名前空間」声明"
    },
    {
      "indent": 3,
      "text": "The \"namespace\" statement defines the XML namespace that all identifiers defined by the module are qualified by in the XML encoding, with the exception of identifiers for data nodes, action nodes, and notification nodes defined inside a grouping (see Section 7.13 for details). The argument to the \"namespace\" statement is the URI of the namespace.",
      "ja": "「名前空間」は文がグループ内で定義されたデータノード、アクション・ノード、および通知ノードの識別子を除いて、モジュールによって定義された全ての識別子は、XMLエンコーディング中で修飾されたXML名前空間を定義する（詳細については、セクション7.13を参照） 。 「名前空間」の文への引数は、名前空間のURIです。"
    },
    {
      "indent": 3,
      "text": "See also Section 5.3.",
      "ja": "また、5.3節を参照してください。"
    },
    {
      "indent": 0,
      "text": "7.1.4. The \"prefix\" Statement",
      "section_title": true,
      "ja": "7.1.4.  「接頭辞」声明"
    },
    {
      "indent": 3,
      "text": "The \"prefix\" statement is used to define the prefix associated with the module and its namespace. The \"prefix\" statement's argument is the prefix string that is used as a prefix to access a module. The prefix string MAY be used with the module to refer to definitions contained in the module, e.g., \"if:ifName\". A prefix is an identifier (see Section 6.2).",
      "ja": "「接頭辞」文はモジュールとその名前空間に関連付けられている接頭辞を定義するために使用されます。 「接頭辞」文の引数には、モジュールにアクセスするための接頭辞として使用されるプレフィックス文字列です。接頭文字列は、「：のifName場合」、例えば、モジュールに含まれる定義を参照するためにモジュールと共に使用することができます。プレフィックスは、識別子（6.2節を参照）です。"
    },
    {
      "indent": 3,
      "text": "When used inside the \"module\" statement, the \"prefix\" statement defines the prefix suggested to be used when this module is imported.",
      "ja": "「モジュール」文の中で使用する場合、「接頭辞」の文は、接頭辞は、このモジュールをインポートするときに使用されることが示唆定義します。"
    },
    {
      "indent": 3,
      "text": "To improve readability of the NETCONF XML, a NETCONF client or server that generates XML or XPath that uses prefixes SHOULD use the prefix defined by the module as the XML namespace prefix, unless there is a conflict.",
      "ja": "NETCONFのXML、競合がある場合を除き、XML名前空間接頭辞としてモジュールで定義された接頭辞を使用すべきである接頭辞を使用してXMLまたはXPathを生成NETCONFクライアントまたはサーバの読みやすさを改善するために。"
    },
    {
      "indent": 3,
      "text": "When used inside the \"import\" statement, the \"prefix\" statement defines the prefix to be used when accessing definitions inside the imported module. When a reference to an identifier from the imported module is used, the prefix string for the imported module followed by a colon (\":\") and the identifier is used, e.g., \"if:ifIndex\". To improve readability of YANG modules, the prefix defined by a module SHOULD be used when the module is imported, unless there is a conflict. If there is a conflict, i.e., two different modules that both have defined the same prefix are imported, at least one of them MUST be imported with a different prefix.",
      "ja": "「インポート」文の中で使用する場合、「接頭辞」の文は、インポートされたモジュール内の定義にアクセスするときに使用する接頭辞を定義します。インポートモジュールから識別子への参照が使用される場合、コロン（「：」）、続いて、インポートモジュールの接頭文字列と識別子は、例えば、「：ifIndexの場合」が使用されます。モジュールをインポートするときに競合がある場合を除きYANGモジュールの可読性を向上させるために、モジュールによって定義されたプレフィックスを使用すべきです。競合がある場合、すなわち、両方が同じプレフィックスを定義している二つの異なるモジュールがインポートされ、それらの少なくとも1つは、異なる接頭辞でインポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "All prefixes, including the prefix for the module itself, MUST be unique within the module or submodule.",
      "ja": "モジュール自体のプレフィックスを含むすべてのプレフィックスは、モジュールまたはサブモジュール内で一意でなければなりません。"
    },
    {
      "indent": 0,
      "text": "7.1.5. The \"import\" Statement",
      "section_title": true,
      "ja": "7.1.5.  「インポート」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"import\" statement makes definitions from one module available inside another module or submodule. The argument is the name of the module to import, and the statement is followed by a block of substatements that holds detailed import information. When a module is imported, the importing module may:",
      "ja": "「インポート」の文は、別のモジュールまたはサブモジュール内の一つのモジュールからの定義を使用できるようになります。引数には、インポートするモジュールの名前で、文は、詳細なインポート情報を保持しているサブステートメントのブロックが続いています。モジュールをインポートすると、インポートモジュールは、可能性があります。"
    },
    {
      "indent": 3,
      "text": "o use any grouping and typedef defined at the top level in the imported module or its submodules.",
      "ja": "Oインポートモジュールまたはサブモジュールのトップレベルで定義された任意のグループとのtypedefを使用します。"
    },
    {
      "indent": 3,
      "text": "o use any extension, feature, and identity defined in the imported module or its submodules.",
      "ja": "Oインポートモジュールまたはサブモジュールで定義された拡張、機能、およびアイデンティティを使用します。"
    },
    {
      "indent": 3,
      "text": "o use any node in the imported module's schema tree in \"must\", \"path\", and \"when\" statements, or as the target node in \"augment\" and \"deviation\" statements.",
      "ja": "Oでインポートモジュールのスキーマ・ツリー内の任意のノードを使用して「必要」、「パス」、および「いつ」文、または「増強」と「ずれ」ステートメント内のターゲットノードとして。"
    },
    {
      "indent": 3,
      "text": "The mandatory \"prefix\" substatement assigns a prefix for the imported module that is scoped to the importing module or submodule. Multiple \"import\" statements may be specified to import from different modules.",
      "ja": "必須の「接頭辞」サプは、インポートモジュールまたはサブモジュールにスコープされ、インポートモジュールのプレフィックスを割り当てます。複数の「インポート」ステートメントが別のモジュールからインポートする指定することができます。"
    },
    {
      "indent": 3,
      "text": "When the optional \"revision-date\" substatement is present, any typedef, grouping, extension, feature, and identity referenced by definitions in the local module are taken from the specified revision of the imported module. It is an error if the specified revision of the imported module does not exist. If no \"revision-date\" substatement is present, it is undefined from which revision of the module they are taken.",
      "ja": "オプションの「改訂日付」サプが存在する場合、ローカルモジュールの定義によって参照される任意のtypedef、グループ化、拡張、機能、及び同一性は、インポートモジュールの指定されたリビジョンから取られます。インポートされたモジュールの指定されたリビジョンが存在しない場合は、エラーになります。何の「改訂日付」サブステートメントが存在しない場合、それは彼らが撮影されているモジュールのどのリビジョンから定義されていません。"
    },
    {
      "indent": 3,
      "text": "Multiple revisions of the same module can be imported, provided that different prefixes are used.",
      "ja": "同じモジュールの複数のリビジョンが異なるプレフィックスが使用されていることを条件とする、インポートすることができます。"
    },
    {
      "indent": 17,
      "text": "+---------------+---------+-------------+\n| substatement  | section | cardinality |\n+---------------+---------+-------------+\n| description   | 7.21.3  | 0..1        |\n| prefix        | 7.1.4   | 1           |\n| reference     | 7.21.4  | 0..1        |\n| revision-date | 7.1.5.1 | 0..1        |\n+---------------+---------+-------------+",
      "raw": true
    },
    {
      "indent": 24,
      "text": "The import's Substatements",
      "ja": "インポートのサブステートメント"
    },
    {
      "indent": 0,
      "text": "7.1.5.1. The import's \"revision-date\" Statement",
      "section_title": true,
      "ja": "7.1.5.1。インポートの「改訂日付」文"
    },
    {
      "indent": 3,
      "text": "The import's \"revision-date\" statement is used to specify the version of the module to import.",
      "ja": "インポートの「改訂日付」文はインポートするモジュールのバージョンを指定するために使用されます。"
    },
    {
      "indent": 0,
      "text": "7.1.6. The \"include\" Statement",
      "section_title": true,
      "ja": "7.1.6.  「含める」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"include\" statement is used to make content from a submodule available to that submodule's parent module. The argument is an identifier that is the name of the submodule to include. Modules are only allowed to include submodules that belong to that module, as defined by the \"belongs-to\" statement (see Section 7.2.2).",
      "ja": "「含める」ステートメントは、そのサブモジュールの親モジュールが利用可能なサブモジュールからのコンテンツを作るために使用されます。引数が含まれるようにサブモジュールの名前である識別子です。モジュールは、唯一の「所属-に」（7.2.2項を参照）文によって定義されるように、そのモジュールに属しているサブモジュールを含めることが許可されています。"
    },
    {
      "indent": 3,
      "text": "When a module includes a submodule, it incorporates the contents of the submodule into the node hierarchy of the module.",
      "ja": "モジュールは、サブモジュールを含む場合、それはモジュールのノード階層にサブモジュールの内容を組み込みます。"
    },
    {
      "indent": 3,
      "text": "For backward compatibility with YANG version 1, a submodule is allowed to include another submodule belonging to the same module, but this is not necessary in YANG version 1.1 (see Section 5.1).",
      "ja": "YANGバージョン1との下位互換性のために、サブモジュールは、同じモジュールに属する他のサブモジュールを含むことが許され、これはYANGバージョン1.1（セクション5.1を参照）に必要ではありません。"
    },
    {
      "indent": 3,
      "text": "When the optional \"revision-date\" substatement is present, the specified revision of the submodule is included in the module. It is an error if the specified revision of the submodule does not exist. If no \"revision-date\" substatement is present, it is undefined which revision of the submodule is included.",
      "ja": "オプションの「改訂日付」サプが存在する場合、サブモジュールの指定されたリビジョンは、モジュールに含まれています。サブモジュールの指定されたリビジョンが存在しない場合は、エラーになります。何の「改訂日付」サブステートメントが存在しない場合には、サブモジュールのリビジョンが含まれている定義されていません。"
    },
    {
      "indent": 3,
      "text": "Multiple revisions of the same submodule MUST NOT be included.",
      "ja": "同じサブモジュールの複数のリビジョンを含んではいけません。"
    },
    {
      "indent": 17,
      "text": "+---------------+---------+-------------+\n| substatement  | section | cardinality |\n+---------------+---------+-------------+\n| description   | 7.21.3  | 0..1        |\n| reference     | 7.21.4  | 0..1        |\n| revision-date | 7.1.5.1 | 0..1        |\n+---------------+---------+-------------+",
      "raw": true
    },
    {
      "indent": 23,
      "text": "The includes's Substatements",
      "ja": "サブステートメントを含んでいます"
    },
    {
      "indent": 0,
      "text": "7.1.7. The \"organization\" Statement",
      "section_title": true,
      "ja": "7.1.7.  「組織」声明"
    },
    {
      "indent": 3,
      "text": "The \"organization\" statement defines the party responsible for this module. The argument is a string that is used to specify a textual description of the organization(s) under whose auspices this module was developed.",
      "ja": "「組織」の文は、このモジュールの責任者を定義します。引数には、このモジュールが開発されたその後援の下、組織（複数可）のテキスト記述を指定するために使用される文字列です。"
    },
    {
      "indent": 0,
      "text": "7.1.8. The \"contact\" Statement",
      "section_title": true,
      "ja": "7.1.8.  「接触」声明"
    },
    {
      "indent": 3,
      "text": "The \"contact\" statement provides contact information for the module. The argument is a string that is used to specify contact information for the person or persons to whom technical queries concerning this module should be sent, such as their name, postal address, telephone number, and electronic mail address.",
      "ja": "「連絡先」のステートメントは、モジュールの連絡先情報を提供します。引数には、自分の名前、住所、電話番号、電子メールアドレスとして、送信されるべき人や、このモジュールに関する技術的な問い合わせを誰に人のための連絡先情報を指定するために使用される文字列です。"
    },
    {
      "indent": 0,
      "text": "7.1.9. The \"revision\" Statement",
      "section_title": true,
      "ja": "7.1.9.  「改正」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"revision\" statement specifies the editorial revision history of the module, including the initial revision. A series of \"revision\" statements detail the changes in the module's definition. The argument is a date string in the format \"YYYY-MM-DD\", followed by a block of substatements that holds detailed revision information. A module SHOULD have at least one \"revision\" statement. For every published editorial change, a new one SHOULD be added in front of the revisions sequence so that all revisions are in reverse chronological order.",
      "ja": "「改正」の文は、最初のリビジョンを含むモジュールの編集改訂履歴を、指定します。 「改正」ステートメントの詳細一連のモジュールの定義の変更。引数には、詳細なリビジョン情報を保持しているサブステートメントのブロックが続くフォーマット「YYYY-MM-DD」の日付文字列です。モジュールは、少なくとも1つの「改正」の文を持っているべきです。すべてのリビジョンが新しい順になるように、すべての出版され社説変更のために、新しいものがリビジョンシーケンスの前に追加する必要があります。"
    },
    {
      "indent": 0,
      "text": "7.1.9.1. The revision's Substatements",
      "section_title": true,
      "ja": "7.1.9.1。リビジョンのサブステートメント"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| description  | 7.21.3  | 0..1        |\n| reference    | 7.21.4  | 0..1        |\n+--------------+---------+-------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.1.10. Usage Example",
      "section_title": true,
      "ja": "7.1.10. 使用例"
    },
    {
      "indent": 3,
      "text": "The following example relies on [RFC6991].",
      "ja": "次の例は、[RFC6991]に依存しています。"
    },
    {
      "indent": 5,
      "text": "module example-system {\n  yang-version 1.1;\n  namespace \"urn:example:system\";\n  prefix \"sys\";",
      "raw": true
    },
    {
      "indent": 7,
      "text": "import ietf-yang-types {\n  prefix \"yang\";\n  reference \"RFC 6991: Common YANG Data Types\";\n}",
      "raw": true
    },
    {
      "indent": 7,
      "text": "include example-types;",
      "ja": "例えば、タイプを含みます。"
    },
    {
      "indent": 7,
      "text": "organization \"Example Inc.\"; contact \"Joe L. User",
      "ja": "組織「例株式会社」。 「ジョーL.ユーザーに連絡"
    },
    {
      "indent": 10,
      "text": "Example Inc. 42 Anywhere Drive Nowhere, CA 95134 USA",
      "ja": "どこどこにもドライブしない例（株）42、CA 95134 USA"
    },
    {
      "indent": 10,
      "text": "Phone: +1 800 555 0100 Email: joe@example.com\";",
      "ja": "電話：+1 800 555 0100 Eメール：joe@example.com \";"
    },
    {
      "indent": 7,
      "text": "description \"The module for entities implementing the Example system.\";",
      "ja": "説明「例のシステムを実装するエンティティのためのモジュール。」;"
    },
    {
      "indent": 7,
      "text": "revision 2007-06-09 { description \"Initial revision.\"; }",
      "ja": "リビジョン2007-06-09 {説明「初期リビジョン。」; }"
    },
    {
      "indent": 5,
      "text": " // definitions follow... }",
      "ja": "//定義は} ...続きます"
    },
    {
      "indent": 0,
      "text": "7.2. The \"submodule\" Statement",
      "section_title": true,
      "ja": "7.2.  「サブモジュール」声明"
    },
    {
      "indent": 3,
      "text": "While the primary unit in YANG is a module, a YANG module can itself be constructed out of several submodules. Submodules allow a module designer to split a complex model into several pieces where all the submodules contribute to a single namespace, which is defined by the module that includes the submodules.",
      "ja": "YANG一次ユニットがモジュールであるが、YANGモジュールは、それ自体がいくつかのサブモジュールから構成することができます。サブモジュールは、モジュールの設計者は、すべてのサブモジュールは、サブモジュールを含むモジュールによって定義される単一の名前空間に寄与するいくつかの部分に複雑なモデルを分割することを可能にします。"
    },
    {
      "indent": 3,
      "text": "The \"submodule\" statement defines the submodule's name, and it groups all statements that belong to the submodule together. The \"submodule\" statement's argument is the name of the submodule, followed by a block of substatements that holds detailed submodule information. The submodule name is an identifier (see Section 6.2).",
      "ja": "「サブモジュール」の文は、サブモジュールの名前を定義し、それを一緒にグループサブモジュールに属するすべてのステートメント。 「サブモジュール」文の引数には、詳細なサブモジュールの情報を保持しているサブステートメントのブロックが続き、サブモジュールの名前です。サブモジュール名は識別子（セクション6.2を参照）です。"
    },
    {
      "indent": 3,
      "text": "Names of submodules published in RFC streams [RFC4844] MUST be assigned by IANA; see Section 14 in [RFC6020].",
      "ja": "RFCストリームに掲載されたサブモジュールの名前[RFC4844]はIANAによって割り当てなければなりません。 [RFC6020]でセクション14を参照してください。"
    },
    {
      "indent": 3,
      "text": "Private submodule names are assigned by the organization owning the submodule without a central registry. See Section 5.1 for recommendations on how to name submodules.",
      "ja": "プライベートサブモジュール名は、中央レジストリせずにサブモジュールを所有している組織によって割り当てられます。サブモジュールに名前を付ける方法に関する推奨事項については、5.1節を参照してください。"
    },
    {
      "indent": 3,
      "text": "A submodule typically has the following layout:",
      "ja": "サブモジュールは、一般的に次のようなレイアウトになっています。"
    },
    {
      "indent": 5,
      "text": "submodule <module-name> {",
      "ja": "サブモジュール<モジュール名> {"
    },
    {
      "indent": 7,
      "text": "<yang-version statement>",
      "ja": "<文・バージョン>"
    },
    {
      "indent": 7,
      "text": "// module identification <belongs-to statement>",
      "ja": "//モジュールの識別<所属-に声明>"
    },
    {
      "indent": 7,
      "text": "// linkage statements <import statements>",
      "ja": "//リンケージ文は、<import文を>"
    },
    {
      "indent": 7,
      "text": "// meta-information <organization statement> <contact statement> <description statement> <reference statement>",
      "ja": "//メタ情報<組織声明> <接触声明> <説明書> <参考書>"
    },
    {
      "indent": 7,
      "text": "// revision history <revision statements>",
      "ja": "//改訂履歴<改正文>"
    },
    {
      "indent": 5,
      "text": " // module definitions <other statements> }",
      "ja": "//モジュール定義<他の文>}"
    },
    {
      "indent": 0,
      "text": "7.2.1. The submodule's Substatements",
      "section_title": true,
      "ja": "7.2.1. サブモジュールのサブステートメント"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| anydata      | 7.10    | 0..n        |\n| anyxml       | 7.11    | 0..n        |\n| augment      | 7.17    | 0..n        |\n| belongs-to   | 7.2.2   | 1           |\n| choice       | 7.9     | 0..n        |\n| contact      | 7.1.8   | 0..1        |\n| container    | 7.5     | 0..n        |\n| description  | 7.21.3  | 0..1        |\n| deviation    | 7.20.3  | 0..n        |\n| extension    | 7.19    | 0..n        |\n| feature      | 7.20.1  | 0..n        |\n| grouping     | 7.12    | 0..n        |\n| identity     | 7.18    | 0..n        |\n| import       | 7.1.5   | 0..n        |\n| include      | 7.1.6   | 0..n        |\n| leaf         | 7.6     | 0..n        |\n| leaf-list    | 7.7     | 0..n        |\n| list         | 7.8     | 0..n        |\n| notification | 7.16    | 0..n        |\n| organization | 7.1.7   | 0..1        |\n| reference    | 7.21.4  | 0..1        |\n| revision     | 7.1.9   | 0..n        |\n| rpc          | 7.14    | 0..n        |\n| typedef      | 7.3     | 0..n        |\n| uses         | 7.13    | 0..n        |\n| yang-version | 7.1.2   | 1           |\n+--------------+---------+-------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.2.2. The \"belongs-to\" Statement",
      "section_title": true,
      "ja": "7.2.2.  「所属-に」文"
    },
    {
      "indent": 3,
      "text": "The \"belongs-to\" statement specifies the module to which the submodule belongs. The argument is an identifier that is the name of the module.",
      "ja": "「所属-に」文はサブモジュールが属するモジュールを指定します。引数には、モジュールの名前である識別子です。"
    },
    {
      "indent": 3,
      "text": "A submodule MUST only be included by either the module to which it belongs or another submodule that belongs to that module.",
      "ja": "サブモジュールは、それが属するモジュールまたはそのモジュールに属する別のサブモジュールのいずれかに含まれなければなりません。"
    },
    {
      "indent": 3,
      "text": "The mandatory \"prefix\" substatement assigns a prefix for the module to which the submodule belongs. All definitions in the module that the submodule belongs to and all its submodules can be accessed by using the prefix.",
      "ja": "必須の「接頭辞」サプサブモジュールが属するモジュールのプレフィックスを割り当てます。サブモジュールが属するとそのすべてのサブモジュールは、接頭辞を使用してアクセスすることができ、モジュールのすべての定義。"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| prefix       | 7.1.4   | 1           |\n+--------------+---------+-------------+",
      "raw": true
    },
    {
      "indent": 23,
      "text": "The belongs-to's Substatement",
      "ja": "所属-にSubステートメント"
    },
    {
      "indent": 0,
      "text": "7.2.3. Usage Example",
      "section_title": true,
      "ja": "7.2.3. 使用例"
    },
    {
      "indent": 5,
      "text": "submodule example-types {\n  yang-version 1.1;\n  belongs-to \"example-system\" {\n    prefix \"sys\";\n  }",
      "raw": true
    },
    {
      "indent": 7,
      "text": "import ietf-yang-types { prefix \"yang\"; }",
      "ja": "インポートIETF-ヤン・タイプ{接頭辞「陽」。 }"
    },
    {
      "indent": 7,
      "text": "organization \"Example Inc.\"; contact \"Joe L. User",
      "ja": "組織「例株式会社」。 「ジョーL.ユーザーに連絡"
    },
    {
      "indent": 10,
      "text": "Example Inc. 42 Anywhere Drive Nowhere, CA 95134 USA",
      "ja": "どこどこにもドライブしない例（株）42、CA 95134 USA"
    },
    {
      "indent": 10,
      "text": "Phone: +1 800 555 0100 Email: joe@example.com\";",
      "ja": "電話：+1 800 555 0100 Eメール：joe@example.com \";"
    },
    {
      "indent": 7,
      "text": "description \"This submodule defines common Example types.\";",
      "ja": "説明は「このサブモジュールは、一般的な例タイプを定義します。」;"
    },
    {
      "indent": 7,
      "text": "revision \"2007-06-09\" { description \"Initial revision.\"; }",
      "ja": "リビジョン「2007-06-09」{説明「初期リビジョン。」; }"
    },
    {
      "indent": 5,
      "text": " // definitions follow... }",
      "ja": "//定義は} ...続きます"
    },
    {
      "indent": 0,
      "text": "7.3. The \"typedef\" Statement",
      "section_title": true,
      "ja": "7.3.  「typedefの」文"
    },
    {
      "indent": 3,
      "text": "The \"typedef\" statement defines a new type that may be used locally in the module or submodule, and by other modules that import from it, according to the rules in Section 5.5. The new type is called the \"derived type\", and the type from which it was derived is called the \"base type\". All derived types can be traced back to a YANG built-in type.",
      "ja": "「typedefの」ステートメントは、セクション5.5の規則に従って、モジュールまたはサブモジュールに、及びそこからインポート他のモジュールによって局所的に使用することができる新しいタイプを定義します。新しいタイプは、「派生型」と呼ばれ、それが由来したタイプは、「基本型」と呼ばれています。すべての派生型はバックYANGビルトイン型に遡ることができます。"
    },
    {
      "indent": 3,
      "text": "The \"typedef\" statement's argument is an identifier that is the name of the type to be defined and MUST be followed by a block of substatements that holds detailed typedef information.",
      "ja": "「typedefが」文の引数が定義するタイプの名前であり、情報のtypedef詳細保持しているサブステートメントのブロックが続かなければならない識別子です。"
    },
    {
      "indent": 3,
      "text": "The name of the type MUST NOT be one of the YANG built-in types. If the typedef is defined at the top level of a YANG module or submodule, the name of the type to be defined MUST be unique within the module.",
      "ja": "タイプの名前は、YANGビルトインタイプのいずれかにすることはできません。 typedefがYANGモジュールまたはサブモジュールのトップレベルで定義されている場合、定義されるタイプの名前は、モジュール内で一意でなければなりません。"
    },
    {
      "indent": 0,
      "text": "7.3.1. The typedef's Substatements",
      "section_title": true,
      "ja": "7.3.1.  typedefのサブステートメント"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| default      | 7.3.4   | 0..1        |\n| description  | 7.21.3  | 0..1        |\n| reference    | 7.21.4  | 0..1        |\n| status       | 7.21.2  | 0..1        |\n| type         | 7.3.2   | 1           |\n| units        | 7.3.3   | 0..1        |\n+--------------+---------+-------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.3.2. The typedef's \"type\" Statement",
      "section_title": true,
      "ja": "7.3.2.  typedefの「タイプ」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"type\" statement, which MUST be present, defines the base type from which this type is derived. See Section 7.4 for details.",
      "ja": "存在しなければならない「タイプ」の文では、このタイプが由来する塩基の種類を定義します。詳細については、7.4節を参照してください。"
    },
    {
      "indent": 0,
      "text": "7.3.3. The \"units\" Statement",
      "section_title": true,
      "ja": "7.3.3.  「単位」声明"
    },
    {
      "indent": 3,
      "text": "The \"units\" statement, which is optional, takes as an argument a string that contains a textual definition of the units associated with the type.",
      "ja": "オプションである「単位」の文では、引数としてタイプに関連付けられているユニットのテキスト定義を含む文字列を取ります。"
    },
    {
      "indent": 0,
      "text": "7.3.4. The typedef's \"default\" Statement",
      "section_title": true,
      "ja": "7.3.4.  typedefでの「デフォルト」声明"
    },
    {
      "indent": 3,
      "text": "The \"default\" statement takes as an argument a string that contains a default value for the new type.",
      "ja": "「デフォルト」の文は、引数として新しいタイプのデフォルト値を含む文字列を取ります。"
    },
    {
      "indent": 3,
      "text": "The value of the \"default\" statement MUST be valid according to the type specified in the \"type\" statement.",
      "ja": "「デフォルト」の文の値は、「タイプ」文で指定された型に応じて有効である必要があります。"
    },
    {
      "indent": 3,
      "text": "If the base type has a default value and the new derived type does not specify a new default value, the base type's default value is also the default value of the new derived type.",
      "ja": "基本型は、デフォルト値を持っており、新たな派生型が新しいデフォルト値を指定しない場合は、基本型のデフォルト値は、新しい派生型のデフォルト値です。"
    },
    {
      "indent": 3,
      "text": "If the type's default value is not valid according to the new restrictions specified in a derived type or leaf definition, the derived type or leaf definition MUST specify a new default value compatible with the restrictions.",
      "ja": "型のデフォルト値は派生型や葉の定義で指定された新しい制限に応じて有効でない場合は、派生型や葉の定義が制約と互換性のある新しいデフォルト値を指定する必要があります。"
    },
    {
      "indent": 0,
      "text": "7.3.5. Usage Example",
      "section_title": true,
      "ja": "7.3.5. 使用例"
    },
    {
      "indent": 5,
      "text": "typedef listen-ipv4-address {\n  type inet:ipv4-address;\n  default \"0.0.0.0\";\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.4. The \"type\" Statement",
      "section_title": true,
      "ja": "7.4.  「タイプ」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"type\" statement takes as an argument a string that is the name of a YANG built-in type (see Section 9) or a derived type (see Section 7.3), followed by an optional block of substatements that is used to put further restrictions on the type.",
      "ja": "「タイプ」は文が引数としてビルトインタイプYANGの名前である文字列を受け取り、さらに置くために使用されるサブステートメントの任意のブロックに続いて、（セクション9を参照）、または派生型は、（7.3節を参照してください）種類の制限。"
    },
    {
      "indent": 3,
      "text": "The restrictions that can be applied depend on the type being restricted. The restriction statements for all built-in types are described in the subsections of Section 9.",
      "ja": "適用可能な制限が制限されているタイプによって異なります。すべてのビルトインタイプのための制限文は、第9のサブセクションで説明されています。"
    },
    {
      "indent": 0,
      "text": "7.4.1. The type's Substatements",
      "section_title": true,
      "ja": "7.4.1. タイプのサブステートメント"
    },
    {
      "indent": 15,
      "text": "+------------------+---------+-------------+\n| substatement     | section | cardinality |\n+------------------+---------+-------------+\n| base             | 7.18.2  | 0..n        |\n| bit              | 9.7.4   | 0..n        |\n| enum             | 9.6.4   | 0..n        |\n| fraction-digits  | 9.3.4   | 0..1        |\n| length           | 9.4.4   | 0..1        |\n| path             | 9.9.2   | 0..1        |\n| pattern          | 9.4.5   | 0..n        |\n| range            | 9.2.4   | 0..1        |\n| require-instance | 9.9.3   | 0..1        |\n| type             | 7.4     | 0..n        |\n+------------------+---------+-------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.5. The \"container\" Statement",
      "section_title": true,
      "ja": "7.5.  「コンテナ」声明"
    },
    {
      "indent": 3,
      "text": "The \"container\" statement is used to define an interior data node in the schema tree. It takes one argument, which is an identifier, followed by a block of substatements that holds detailed container information.",
      "ja": "「コンテナ」の文は、スキーマツリー内の内部データノードを定義するために使用されます。これは、詳細なコンテナ情報を保持するサブステートメントのブロックが続く識別子であり、一つの引数を取ります。"
    },
    {
      "indent": 3,
      "text": "A container node does not have a value, but it has a list of child nodes in the data tree. The child nodes are defined in the container's substatements.",
      "ja": "コンテナノードは値を持ちませんが、それはデータツリー内の子ノードのリストを持っています。子ノードは、コンテナのサブステートメントで定義されています。"
    },
    {
      "indent": 0,
      "text": "7.5.1. Containers with Presence",
      "section_title": true,
      "ja": "7.5.1. 存在感のあるコンテナ"
    },
    {
      "indent": 3,
      "text": "YANG supports two styles of containers, those that exist only for organizing the hierarchy of data nodes and those whose presence in the data tree has an explicit meaning.",
      "ja": "YANGは、容器の2つのスタイル、データノードの階層を整理するためだけに存在するものと、その存在がデータツリー内の明示的な意味を持っていたものをサポートしています。"
    },
    {
      "indent": 3,
      "text": "In the first style, the container has no meaning of its own, existing only to contain child nodes. In particular, the presence of the container node with no child nodes is semantically equivalent to the absence of the container node. YANG calls this style a \"non-presence container\". This is the default style.",
      "ja": "最初のスタイルでは、コンテナは、子ノードを格納するだけで、既存の、それ自身の意味がありません。具体的には、子ノードとコンテナノードの存在は、コンテナノードが存在しないと意味的に等価です。 YANGは「非存在コンテナ」このスタイルを呼び出します。これはデフォルトのスタイルです。"
    },
    {
      "indent": 3,
      "text": "For example, the set of scrambling options for Synchronous Optical Network (SONET) interfaces may be placed inside a \"scrambling\" container to enhance the organization of the configuration hierarchy and to keep these nodes together. The \"scrambling\" node itself has no meaning, so removing the node when it becomes empty relieves the user from performing this task.",
      "ja": "例えば、同期光ネットワーク（SONET）インターフェイスのオプションをスクランブリングのセットは、構成階層の組織を強化するために、一緒にこれらのノードを維持するために、「スクランブル」容器内に配置することができます。 「スクランブル」ノード自体が意味を持たないので、それが空になったときにノードを除去してこのタスクを実行することからユーザを解放します。"
    },
    {
      "indent": 3,
      "text": "In the second style, the presence of the container itself carries some meaning, representing a single bit of data.",
      "ja": "第二の様式において、容器自体の存在は、データの単一ビットを表す、いくつかの意味を運びます。"
    },
    {
      "indent": 3,
      "text": "For configuration data, the container acts as both a configuration knob and a means of organizing related configuration nodes. These containers are explicitly created and deleted.",
      "ja": "構成データは、構成ノブと関連する構成ノードを編成する手段の両方としてコンテナ作用します。これらの容器は、明示的に作成され、削除されます。"
    },
    {
      "indent": 3,
      "text": "YANG calls this style a \"presence container\", and it is indicated using the \"presence\" statement, which takes as its argument a text string indicating what the presence of the node means.",
      "ja": "YANGは、「プレゼンスコンテナ」このスタイルを呼び出し、それがその引数としてノードの存在が何を意味するのかを示すテキスト文字列を受け取り、「プレゼンス」の文を、使用して示されています。"
    },
    {
      "indent": 3,
      "text": "For example, an \"ssh\" container may turn on the ability to log into the server using Secure SHell (SSH) but can also contain any SSH-related configuration knobs, such as connection rates or retry limits.",
      "ja": "例えば、「SSH」コンテナは、セキュアシェル（SSH）を使用してサーバにログインする機能をオンにすることができるだけでなく、接続速度のような任意のSSH関連の設定ノブを含むまたは制限を再試行することができます。"
    },
    {
      "indent": 3,
      "text": "The \"presence\" statement (see Section 7.5.5) is used to give semantics to the existence of the container in the data tree.",
      "ja": "「プレゼンス」の文（7.5.5項を参照）は、データツリー内のコンテナの存在に意味を与えるために使用されます。"
    },
    {
      "indent": 0,
      "text": "7.5.2. The container's Substatements",
      "section_title": true,
      "ja": "7.5.2. コンテナのサブステートメント"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| action       | 7.15    | 0..n        |\n| anydata      | 7.10    | 0..n        |\n| anyxml       | 7.11    | 0..n        |\n| choice       | 7.9     | 0..n        |\n| config       | 7.21.1  | 0..1        |\n| container    | 7.5     | 0..n        |\n| description  | 7.21.3  | 0..1        |\n| grouping     | 7.12    | 0..n        |\n| if-feature   | 7.20.2  | 0..n        |\n| leaf         | 7.6     | 0..n        |\n| leaf-list    | 7.7     | 0..n        |\n| list         | 7.8     | 0..n        |\n| must         | 7.5.3   | 0..n        |\n| notification | 7.16    | 0..n        |\n| presence     | 7.5.5   | 0..1        |\n| reference    | 7.21.4  | 0..1        |\n| status       | 7.21.2  | 0..1        |\n| typedef      | 7.3     | 0..n        |\n| uses         | 7.13    | 0..n        |\n| when         | 7.21.5  | 0..1        |\n+--------------+---------+-------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.5.3. The \"must\" Statement",
      "section_title": true,
      "ja": "7.5.3.  「しなければならない」声明"
    },
    {
      "indent": 3,
      "text": "The \"must\" statement, which is optional, takes as an argument a string that contains an XPath expression (see Section 6.4). It is used to formally declare a constraint on valid data. The constraint is enforced according to the rules in Section 8.",
      "ja": "オプションである「しなければならない」文は、引数としてXPath式を（6.4節を参照）を含む文字列を取ります。正式に有効なデータ上の制約を宣言するために使用されます。制約は、第8章の規則に従って実施されます。"
    },
    {
      "indent": 3,
      "text": "When a datastore is validated, all \"must\" constraints are conceptually evaluated once for each node in the accessible tree (see Section 6.4.1).",
      "ja": "データストアが確認された場合、すべての制約は、概念的にアクセス可能ツリー内の各ノードに対して一度だけ評価され、「しなければならない」（6.4.1項を参照してください）。"
    },
    {
      "indent": 3,
      "text": "All such constraints MUST evaluate to \"true\" for the data to be valid.",
      "ja": "データが有効であるためには、すべてのそのような制約は、「真」に評価される必要があります。"
    },
    {
      "indent": 3,
      "text": "The XPath expression is conceptually evaluated in the following context, in addition to the definition in Section 6.4.1:",
      "ja": "XPath式は、概念的6.4.1における定義に加えて、次のコンテキストで評価されています。"
    },
    {
      "indent": 3,
      "text": "o If the \"must\" statement is a substatement of a \"notification\" statement, the context node is the node representing the notification in the accessible tree.",
      "ja": "「しなければならない」文は「通知」の文のサブステートメントである場合は、O、コンテキストノードがアクセスできるツリー内の通知を表すノードです。"
    },
    {
      "indent": 3,
      "text": "o If the \"must\" statement is a substatement of an \"input\" statement, the context node is the node representing the operation in the accessible tree.",
      "ja": "「しなければならない」文は、「入力」の文のサブステートメントである場合は、O、コンテキストノードがアクセスできるツリーの動作を表すノードです。"
    },
    {
      "indent": 3,
      "text": "o If the \"must\" statement is a substatement of an \"output\" statement, the context node is the node representing the operation in the accessible tree.",
      "ja": "「しなければならない」文は、「出力」の文のサブステートメントである場合は、O、コンテキストノードがアクセスできるツリーの動作を表すノードです。"
    },
    {
      "indent": 3,
      "text": "o Otherwise, the context node is the node in the accessible tree for which the \"must\" statement is defined.",
      "ja": "Oそれ以外の場合は、コンテキストノードが「必要」文が定義されているアクセスツリー内のノードです。"
    },
    {
      "indent": 3,
      "text": "The result of the XPath expression is converted to a boolean value using the standard XPath rules.",
      "ja": "XPath式の結果は、標準のXPathルールを使用して、ブール値に変換されます。"
    },
    {
      "indent": 3,
      "text": "Note that since all leaf values in the data tree are conceptually stored in their canonical form (see Section 9.1), any XPath comparisons are done on the canonical value.",
      "ja": "データツリーのすべてのリーフ値を概念的に（セクション9.1を参照）、その正規の形式で格納されているので、任意のXPath比較は正規値で行われることに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "Also note that the XPath expression is conceptually evaluated. This means that an implementation does not have to use an XPath evaluator in the server. How the evaluation is done in practice is an implementation decision.",
      "ja": "また、XPath式を概念的に評価されることに注意してください。これは、実装は、サーバーでのXPath評価を使用する必要がないことを意味します。評価は、実際に行われているどのような実装決定です。"
    },
    {
      "indent": 0,
      "text": "7.5.4. The must's Substatements",
      "section_title": true,
      "ja": "7.5.4. 必見のサブステートメント"
    },
    {
      "indent": 17,
      "text": "+---------------+---------+-------------+\n| substatement  | section | cardinality |\n+---------------+---------+-------------+\n| description   | 7.21.3  | 0..1        |\n| error-app-tag | 7.5.4.2 | 0..1        |\n| error-message | 7.5.4.1 | 0..1        |\n| reference     | 7.21.4  | 0..1        |\n+---------------+---------+-------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.5.4.1. The \"error-message\" Statement",
      "section_title": true,
      "ja": "7.5.4.1。 「エラーメッセージ」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"error-message\" statement, which is optional, takes a string as an argument. If the constraint evaluates to \"false\", the string is passed as <error-message> in the <rpc-error> in NETCONF.",
      "ja": "オプションである「エラーメッセージ」の文では、引数として文字列を取ります。制約は「偽」と評価された場合、文字列はNETCONFで、<RPCエラー>に<エラーメッセージ>として渡されます。"
    },
    {
      "indent": 0,
      "text": "7.5.4.2. The \"error-app-tag\" Statement",
      "section_title": true,
      "ja": "7.5.4.2。 「エラーアプリ内タグ」声明"
    },
    {
      "indent": 3,
      "text": "The \"error-app-tag\" statement, which is optional, takes a string as an argument. If the constraint evaluates to \"false\", the string is passed as <error-app-tag> in the <rpc-error> in NETCONF.",
      "ja": "オプションである「エラーアプリ内タグ」の文では、引数として文字列を取ります。制約が \"false\" に評価された場合、文字列はNETCONFで、<RPC-エラー>内の<error-APP-タグ>として渡されます。"
    },
    {
      "indent": 0,
      "text": "7.5.4.3. Usage Example of must and error-message",
      "section_title": true,
      "ja": "7.5.4.3。必須とエラー・メッセージの使用例"
    },
    {
      "indent": 5,
      "text": "container interface {\n  leaf ifType {\n    type enumeration {\n      enum ethernet;\n      enum atm;\n    }\n  }\n  leaf ifMTU {\n    type uint32;\n  }\n  must 'ifType != \"ethernet\" or ifMTU = 1500' {\n    error-message \"An Ethernet MTU must be 1500\";\n  }\n  must 'ifType != \"atm\" or'\n     + ' (ifMTU <= 17966 and ifMTU >= 64)' {\n    error-message \"An ATM MTU must be 64 .. 17966\";\n  }\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.5.5. The \"presence\" Statement",
      "section_title": true,
      "ja": "7.5.5.  「プレゼンス」声明"
    },
    {
      "indent": 3,
      "text": "The \"presence\" statement assigns a meaning to the presence of a container in the data tree. It takes as an argument a string that contains a textual description of what the node's presence means.",
      "ja": "「プレゼンス」のステートメントは、データツリー内のコンテナの存在に意味を割り当てます。これは、引数として、ノードの存在が何を意味するのかの説明テキストを含む文字列を取ります。"
    },
    {
      "indent": 3,
      "text": "If a container has the \"presence\" statement, the container's existence in the data tree carries some meaning. Otherwise, the container is used to give some structure to the data, and it carries no meaning by itself.",
      "ja": "コンテナは、「プレゼンス」の文を持っている場合は、データツリー内のコンテナの存在は、いくつかの意味を運びます。そうしないと、コンテナは、データに何らかの構造を与えるために使用され、それはそれ自体では意味を運びません。"
    },
    {
      "indent": 3,
      "text": "See Section 7.5.1 for additional information.",
      "ja": "追加情報については、セクション7.5.1を参照してください。"
    },
    {
      "indent": 0,
      "text": "7.5.6. The container's Child Node Statements",
      "section_title": true,
      "ja": "7.5.6. コンテナの子ノード文"
    },
    {
      "indent": 3,
      "text": "Within a container, the \"container\", \"leaf\", \"list\", \"leaf-list\", \"uses\", \"choice\", \"anydata\", and \"anyxml\" statements can be used to define child nodes to the container.",
      "ja": "コンテナ、「コンテナ」、「葉」、「リスト」、「リーフリスト」、「用途」、「選択」、「ANYDATA」、および「AnyXMLで」ステートメント内でコンテナに子ノードを定義するために使用することができます。"
    },
    {
      "indent": 0,
      "text": "7.5.7. XML Encoding Rules",
      "section_title": true,
      "ja": "7.5.7.  XML符号化規則"
    },
    {
      "indent": 3,
      "text": "A container node is encoded as an XML element. The element's local name is the container's identifier, and its namespace is the module's XML namespace (see Section 7.1.3).",
      "ja": "コンテナノードは、XML要素として符号化されます。要素のローカル名は、コンテナの識別子であり、その名前空間は、モジュールのXML名前空間（セクション7.1.3を参照）です。"
    },
    {
      "indent": 3,
      "text": "The container's child nodes are encoded as subelements to the container element. If the container defines RPC or action input or output parameters, these subelements are encoded in the same order as they are defined within the \"container\" statement. Otherwise, the subelements are encoded in any order.",
      "ja": "コンテナの子ノードは、コンテナ要素のサブ要素としてエンコードされています。容器は、RPCまたはアクションの入力または出力パラメータを定義している場合、これらのサブエレメントは、それらが「コンテナ」ステートメント内で定義されているのと同じ順序で符号化されます。それ以外の場合は、サブ要素は任意の順序で符号化されています。"
    },
    {
      "indent": 3,
      "text": "Any whitespace between the subelements to the container is insignificant, i.e., an implementation MAY insert whitespace characters between subelements.",
      "ja": "容器のサブ要素間の空白は重要ではない、すなわち、実装はサブ要素間の空白文字を挿入することができます。"
    },
    {
      "indent": 3,
      "text": "If a non-presence container does not have any child nodes, the container may or may not be present in the XML encoding.",
      "ja": "非存在容器は、任意の子ノードを持たない場合、容器は、またはXMLエンコーディング中に存在してもしなくてもよいです。"
    },
    {
      "indent": 0,
      "text": "7.5.8. NETCONF <edit-config> Operations",
      "section_title": true,
      "ja": "7.5.8.  NETCONF <編集-config>の操作"
    },
    {
      "indent": 3,
      "text": "Containers can be created, deleted, replaced, and modified through <edit-config> by using the \"operation\" attribute (see Section 7.2 in [RFC6241]) in the container's XML element.",
      "ja": "コンテナは、コンテナのXML要素に（[RFC6241]でセクション7.2を参照）を作成、削除、置き換え、および「操作」属性を使用して、<編集-config>のを介して変更することができます。"
    },
    {
      "indent": 3,
      "text": "If a container does not have a \"presence\" statement and the last child node is deleted, the NETCONF server MAY delete the container.",
      "ja": "コンテナは、「プレゼンス」の文と最後の子ノードが削除されていない場合は、NETCONFサーバは、コンテナを削除することができます。"
    },
    {
      "indent": 3,
      "text": "When a NETCONF server processes an <edit-config> request, the elements of procedure for the container node are as follows:",
      "ja": "NETCONFサーバは<編集設定>要求を処理するときに、以下のように、コンテナノードの手順の要素は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o If the operation is \"merge\" or \"replace\", the node is created if it does not exist.",
      "ja": "操作は「マージ」または「置換」である場合は、それが存在しない場合は、O、ノードが作成されます。"
    },
    {
      "indent": 3,
      "text": "o If the operation is \"create\", the node is created if it does not exist. If the node already exists, a \"data-exists\" error is returned.",
      "ja": "操作は、「作成」である場合は、それが存在しない場合は、O、ノードが作成されます。ノードがすでに存在する場合は、「データが存在する」エラーが返されます。"
    },
    {
      "indent": 3,
      "text": "o If the operation is \"delete\", the node is deleted if it exists. If the node does not exist, a \"data-missing\" error is returned.",
      "ja": "操作は「削除」である場合は、それが存在する場合は、O、ノードが削除されます。ノードが存在しない場合は、「データ・行方不明」エラーが返されます。"
    },
    {
      "indent": 0,
      "text": "7.5.9. Usage Example",
      "section_title": true,
      "ja": "7.5.9. 使用例"
    },
    {
      "indent": 3,
      "text": "Given the following container definition:",
      "ja": "次のコンテナの定義を考えます："
    },
    {
      "indent": 5,
      "text": "container system {\n  description\n    \"Contains various system parameters.\";\n  container services {\n    description\n      \"Configure externally available services.\";\n    container \"ssh\" {\n      presence \"Enables SSH\";\n      description\n        \"SSH service-specific configuration.\";\n      // more leafs, containers, and stuff here...\n    }\n  }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A corresponding XML instance example:",
      "ja": "対応するXMLインスタンスの例："
    },
    {
      "indent": 5,
      "text": "<system> <services> <ssh/> </services> </system>",
      "ja": "<システム> <サービス> <SSH /> </サービス> </システム>"
    },
    {
      "indent": 3,
      "text": "Since the <ssh> element is present, SSH is enabled.",
      "ja": "<SSH>要素が存在しているので、SSHが有効になっています。"
    },
    {
      "indent": 3,
      "text": "To delete a container with an <edit-config>:",
      "ja": "<編集-config>の持つコンテナを削除するには："
    },
    {
      "indent": 5,
      "text": "<rpc message-id=\"101\" xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\" xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\"> <edit-config> <target> <running/> </target> <config> <system xmlns=\"urn:example:config\"> <services> <ssh nc:operation=\"delete\"/> </services> </system> </config> </edit-config> </rpc>",
      "ja": "<RPCメッセージID = \"101\" のxmlns = \"URN：IETF：paramsは：XML：NS：NETCONF：塩基：1.0\" のxmlns：NC = \"URN：IETF：paramsは：XML：NS：NETCONF：塩基：1.0\"> <編集-config>の<対象> <ランニング/> </ target>を<config>の<システムのxmlns = \"壷：例：コンフィグ\"> <サービス> <SSH NC：操作= \"削除\" /> </サービス> < /システム> </ config>の</編集-config>の</ RPC>"
    },
    {
      "indent": 0,
      "text": "7.6. The \"leaf\" Statement",
      "section_title": true,
      "ja": "7.6.  「リーフ」声明"
    },
    {
      "indent": 3,
      "text": "The \"leaf\" statement is used to define a leaf node in the schema tree. It takes one argument, which is an identifier, followed by a block of substatements that holds detailed leaf information.",
      "ja": "「リーフ」の文は、スキーマツリー内のリーフ・ノードを定義するために使用されます。これは、詳細な葉の情報を保持するサブステートメントのブロックが続く識別子であり、一つの引数を取ります。"
    },
    {
      "indent": 3,
      "text": "A leaf node has a value, but no child nodes, in the data tree. Conceptually, the value in the data tree is always in the canonical form (see Section 9.1).",
      "ja": "リーフノードは、データツリーで、値、ない子ノードを持っています。概念的には、データツリーの値が正規の形式で常にある（9.1節を参照してください）。"
    },
    {
      "indent": 3,
      "text": "A leaf node exists in zero or one instance in the data tree.",
      "ja": "リーフ・ノードは、データツリー内のゼロまたは1つのインスタンス内に存在します。"
    },
    {
      "indent": 3,
      "text": "The \"leaf\" statement is used to define a scalar variable of a particular built-in or derived type.",
      "ja": "「リーフ」の文は、特定の内蔵または派生型のスカラ変数を定義するために使用されます。"
    },
    {
      "indent": 0,
      "text": "7.6.1. The leaf's Default Value",
      "section_title": true,
      "ja": "7.6.1. 葉のデフォルト値"
    },
    {
      "indent": 3,
      "text": "The default value of a leaf is the value that the server uses if the leaf does not exist in the data tree. The usage of the default value depends on the leaf's closest ancestor node in the schema tree that is not a non-presence container (see Section 7.5.1):",
      "ja": "葉のデフォルト値は、葉がデータツリーに存在しない場合、サーバーが使用する値です。デフォルト値の使用が非存在のコンテナではありませんスキーマツリーのリーフの最も近い祖先ノードに依存します（第7.5.1項を参照してください）："
    },
    {
      "indent": 3,
      "text": "o If no such ancestor exists in the schema tree, the default value MUST be used.",
      "ja": "そのような祖先は、スキーマ・ツリーに存在しない場合はO、デフォルト値が使用されなければなりません。"
    },
    {
      "indent": 3,
      "text": "o Otherwise, if this ancestor is a case node, the default value MUST be used if any node from the case exists in the data tree or the case node is the choice's default case, and if no nodes from any other case exist in the data tree.",
      "ja": "この祖先は、ケースノードである場合、Oそうでなければ、ケースから任意のノードは、データツリー内に存在する場合やノードが選択のデフォルトの場合であれば、デフォルト値が使用されなければならない、そして、他のケースからのノードがデータ内に存在しない場合木。"
    },
    {
      "indent": 3,
      "text": "o Otherwise, the default value MUST be used if the ancestor node exists in the data tree.",
      "ja": "祖先ノードがデータツリー内に存在する場合にOそうでない場合、デフォルト値が使用されなければなりません。"
    },
    {
      "indent": 3,
      "text": "In these cases, the default value is said to be in use.",
      "ja": "これらのケースでは、デフォルト値が使用中であると言われています。"
    },
    {
      "indent": 3,
      "text": "Note that if the leaf or any of its ancestors has a \"when\" condition or \"if-feature\" expression that evaluates to \"false\", then the default value is not in use.",
      "ja": "葉またはその祖先のいずれかが「いつ」状態または「偽」と評価され、「IF-機能」という表現を持っている場合は、デフォルト値が使用されていないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "When the default value is in use, the server MUST operationally behave as if the leaf was present in the data tree with the default value as its value.",
      "ja": "デフォルト値が使用されている場合は、サーバが運用葉がその値としてデフォルト値を持つデータツリーに存在したかのように振る舞う必要があります。"
    },
    {
      "indent": 3,
      "text": "If a leaf has a \"default\" statement, the leaf's default value is the value of the \"default\" statement. Otherwise, if the leaf's type has a default value and the leaf is not mandatory, then the leaf's default value is the type's default value. In all other cases, the leaf does not have a default value.",
      "ja": "葉は「デフォルト」の文を持っている場合は、葉のデフォルト値は、「デフォルト」の文の値です。葉の形は、デフォルト値を持っており、葉は必須ではありませんそれ以外の場合、その後、葉のデフォルト値は、型のデフォルト値です。他のすべての場合で、葉はデフォルト値はありません。"
    },
    {
      "indent": 0,
      "text": "7.6.2. The leaf's Substatements",
      "section_title": true,
      "ja": "7.6.2. 葉のサブステートメント"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| config       | 7.21.1  | 0..1        |\n| default      | 7.6.4   | 0..1        |\n| description  | 7.21.3  | 0..1        |\n| if-feature   | 7.20.2  | 0..n        |\n| mandatory    | 7.6.5   | 0..1        |\n| must         | 7.5.3   | 0..n        |\n| reference    | 7.21.4  | 0..1        |\n| status       | 7.21.2  | 0..1        |\n| type         | 7.6.3   | 1           |\n| units        | 7.3.3   | 0..1        |\n| when         | 7.21.5  | 0..1        |\n+--------------+---------+-------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.6.3. The leaf's \"type\" Statement",
      "section_title": true,
      "ja": "7.6.3. 葉の「タイプ」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"type\" statement, which MUST be present, takes as an argument the name of an existing built-in or derived type. The optional substatements specify restrictions on this type. See Section 7.4 for details.",
      "ja": "存在しなければならない「タイプ」ステートメントは、引数として既存の内蔵または派生型の名前を取ります。オプションのサブステートメントは、このタイプの制限を指定します。詳細については、7.4節を参照してください。"
    },
    {
      "indent": 0,
      "text": "7.6.4. The leaf's \"default\" Statement",
      "section_title": true,
      "ja": "7.6.4. 葉の「デフォルト」声明"
    },
    {
      "indent": 3,
      "text": "The \"default\" statement, which is optional, takes as an argument a string that contains a default value for the leaf.",
      "ja": "オプションである「デフォルト」の文では、引数として葉のデフォルト値を含む文字列を取ります。"
    },
    {
      "indent": 3,
      "text": "The value of the \"default\" statement MUST be valid according to the type specified in the leaf's \"type\" statement.",
      "ja": "「デフォルト」の文の値は、葉の「タイプ」文で指定された型に応じて有効である必要があります。"
    },
    {
      "indent": 3,
      "text": "The \"default\" statement MUST NOT be present on nodes where \"mandatory\" is \"true\".",
      "ja": "「デフォルト」の文では「必須」は「真」であるノード上に存在してはなりません。"
    },
    {
      "indent": 3,
      "text": "The definition of the default value MUST NOT be marked with an \"if-feature\" statement. For example, the following is illegal:",
      "ja": "デフォルト値の定義は、「IF-機能」の文が付いてはなりません。例えば、以下は違法です。"
    },
    {
      "indent": 5,
      "text": "leaf color { type enumeration { enum blue { if-feature blue; } ... } default blue; // illegal - enum value is conditional }",
      "ja": "葉色{型列挙{列挙ブルー{IF-特徴ブルー; } ...}青デフォルト。 //不正 - 列挙値が条件付きです}"
    },
    {
      "indent": 0,
      "text": "7.6.5. The leaf's \"mandatory\" Statement",
      "section_title": true,
      "ja": "7.6.5. 葉の「必須」声明"
    },
    {
      "indent": 3,
      "text": "The \"mandatory\" statement, which is optional, takes as an argument the string \"true\" or \"false\" and puts a constraint on valid data. If not specified, the default is \"false\".",
      "ja": "オプションである「必須」の文では、引数の文字列「true」または「false」として受け取り、有効なデータに制約を置きます。指定しない場合、デフォルトは「false」です。"
    },
    {
      "indent": 3,
      "text": "If \"mandatory\" is \"true\", the behavior of the constraint depends on the type of the leaf's closest ancestor node in the schema tree that is not a non-presence container (see Section 7.5.1):",
      "ja": "「必須」は「真」である場合には、制約の動作は非存在コンテナではありませんスキーマツリーのリーフの最も近い祖先ノードの種類によって異なります（第7.5.1項を参照してください）："
    },
    {
      "indent": 3,
      "text": "o If no such ancestor exists in the schema tree, the leaf MUST exist.",
      "ja": "そのような祖先がスキーマツリーに存在しない場合は、O、葉が存在しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o Otherwise, if this ancestor is a case node, the leaf MUST exist if any node from the case exists in the data tree.",
      "ja": "この祖先がケースノードである場合にケースから任意のノードは、データツリーに存在する場合、Oそうでない場合、リーフが存在しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o Otherwise, the leaf MUST exist if the ancestor node exists in the data tree.",
      "ja": "祖先ノードがデータツリー内に存在する場合にOそうでない場合には、リーフが存在しなければなりません。"
    },
    {
      "indent": 3,
      "text": "This constraint is enforced according to the rules in Section 8.",
      "ja": "この制約は、第8章の規則に従って実施されます。"
    },
    {
      "indent": 0,
      "text": "7.6.6. XML Encoding Rules",
      "section_title": true,
      "ja": "7.6.6.  XML符号化規則"
    },
    {
      "indent": 3,
      "text": "A leaf node is encoded as an XML element. The element's local name is the leaf's identifier, and its namespace is the module's XML namespace (see Section 7.1.3).",
      "ja": "リーフノードは、XML要素として符号化されます。要素のローカル名は、葉の識別子であり、その名前空間は、モジュールのXML名前空間（セクション7.1.3を参照）です。"
    },
    {
      "indent": 3,
      "text": "The value of the leaf node is encoded to XML according to the type and is sent as character data in the element.",
      "ja": "リーフノードの値は、種類に応じてXMLにエンコードされ、要素内の文字データとして送信されます。"
    },
    {
      "indent": 3,
      "text": "See Section 7.6.8 for an example.",
      "ja": "例えば、セクション7.6.8を参照してください。"
    },
    {
      "indent": 0,
      "text": "7.6.7. NETCONF <edit-config> Operations",
      "section_title": true,
      "ja": "7.6.7.  NETCONF <編集-config>の操作"
    },
    {
      "indent": 3,
      "text": "When a NETCONF server processes an <edit-config> request, the elements of procedure for the leaf node are as follows:",
      "ja": "NETCONFサーバは<編集設定>要求を処理するときに、以下のように、リーフノードの手順の要素は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o If the operation is \"merge\" or \"replace\", the node is created if it does not exist, and its value is set to the value found in the XML RPC data.",
      "ja": "操作は「マージ」または「置換」である場合には、O、それが存在しない場合、ノードが作成され、その値は、XML RPCデータで見つかった値に設定されています。"
    },
    {
      "indent": 3,
      "text": "o If the operation is \"create\", the node is created if it does not exist. If the node already exists, a \"data-exists\" error is returned.",
      "ja": "操作は、「作成」である場合は、それが存在しない場合は、O、ノードが作成されます。ノードがすでに存在する場合は、「データが存在する」エラーが返されます。"
    },
    {
      "indent": 3,
      "text": "o If the operation is \"delete\", the node is deleted if it exists. If the node does not exist, a \"data-missing\" error is returned.",
      "ja": "操作は「削除」である場合は、それが存在する場合は、O、ノードが削除されます。ノードが存在しない場合は、「データ・行方不明」エラーが返されます。"
    },
    {
      "indent": 0,
      "text": "7.6.8. Usage Example",
      "section_title": true,
      "ja": "7.6.8. 使用例"
    },
    {
      "indent": 3,
      "text": "Given the following \"leaf\" statement, placed in the previously defined \"ssh\" container (see Section 7.5.9):",
      "ja": "以前に定義された「SSH」の容器に入れ、以下の「リーフ」の文を、与えられた（セクション7.5.9を参照してください）："
    },
    {
      "indent": 5,
      "text": "leaf port {\n  type inet:port-number;\n  default 22;\n  description\n    \"The port to which the SSH server listens.\";\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A corresponding XML instance example:",
      "ja": "対応するXMLインスタンスの例："
    },
    {
      "indent": 5,
      "text": "<port>2022</port>",
      "ja": "2022 <ポート> </ポート>"
    },
    {
      "indent": 3,
      "text": "To set the value of a leaf with an <edit-config>:",
      "ja": "<編集-config>のと葉の値を設定するには："
    },
    {
      "indent": 5,
      "text": "<rpc message-id=\"101\" xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\" xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\"> <edit-config> <target> <running/> </target> <config> <system xmlns=\"urn:example:config\"> <services> <ssh> <port>2022</port> </ssh> </services> </system> </config> </edit-config> </rpc>",
      "ja": "<RPCメッセージID = \"101\" のxmlns = \"URN：IETF：paramsは：XML：NS：NETCONF：塩基：1.0\" のxmlns：NC = \"URN：IETF：paramsは：XML：NS：NETCONF：塩基：1.0\"> <編集-config>の<対象> <ランニング/> </ target>を<config>の<システムのxmlns = \"壷：例：コンフィグ\"> <サービス> <SSH> <ポート> 2022 </ポート> </ SSH> < /サービス> </システム> </ config>の</編集-config>の</ RPC>"
    },
    {
      "indent": 0,
      "text": "7.7. The \"leaf-list\" Statement",
      "section_title": true,
      "ja": "7.7.  「リーフリスト」声明"
    },
    {
      "indent": 3,
      "text": "Where the \"leaf\" statement is used to define a simple scalar variable of a particular type, the \"leaf-list\" statement is used to define an array of a particular type. The \"leaf-list\" statement takes one argument, which is an identifier, followed by a block of substatements that holds detailed leaf-list information.",
      "ja": "「リーフ」文は、特定のタイプの単純なスカラー変数を定義するために使用される場合、「リーフリスト」の文は、特定の型の配列を定義するために使用されます。 「リーフリスト」の文では、詳細なリーフリスト情報を保持しているサブステートメントのブロックが続く識別子、1つの引数を取ります。"
    },
    {
      "indent": 3,
      "text": "In configuration data, the values in a leaf-list MUST be unique.",
      "ja": "コンフィギュレーション・データでは、リーフリストの値は一意である必要があります。"
    },
    {
      "indent": 3,
      "text": "The definitions of the default values MUST NOT be marked with an \"if-feature\" statement.",
      "ja": "デフォルト値の定義は、「IF-機能」の文が付いてはなりません。"
    },
    {
      "indent": 3,
      "text": "Conceptually, the values in the data tree MUST be in the canonical form (see Section 9.1).",
      "ja": "概念的には、データツリーの値が正規の形式でなければなりません（セクション9.1を参照）。"
    },
    {
      "indent": 0,
      "text": "7.7.1. Ordering",
      "section_title": true,
      "ja": "7.7.1. 発注"
    },
    {
      "indent": 3,
      "text": "YANG supports two styles for ordering the entries within lists and leaf-lists. In many lists, the order of list entries does not impact the implementation of the list's configuration, and the server is free to sort the list entries in any reasonable order. The \"description\" string for the list may suggest an order to the server implementor. YANG calls this style of list \"system ordered\"; such lists are indicated with the statement \"ordered-by system\".",
      "ja": "YANGは、リストや葉のリスト内のエントリを注文するための2つのスタイルをサポートしています。多くのリストでは、リストのエントリの順序は、リストの設定の実装に影響を与えないと、サーバは、任意の合理的な順序でリストのエントリをソートして自由です。リストについては、「説明」列には、サーバーの実装に順序を提案することができます。 YANGは、「注文したシステム」リストのこのスタイルを呼び出します。このようなリストは、「注文-によりシステム」声明で示されています。"
    },
    {
      "indent": 3,
      "text": "For example, a list of valid users would typically be sorted alphabetically, since the order in which the users appeared in the configuration would not impact the creation of those users' accounts.",
      "ja": "ユーザーが設定で登場する順番は、それらのユーザーのアカウントの作成に影響を与えないためたとえば、有効なユーザのリストは、一般的に、アルファベット順にソートされます。"
    },
    {
      "indent": 3,
      "text": "In the other style of lists, the order of list entries matters for the implementation of the list's configuration and the user is responsible for ordering the entries, while the server maintains that order. YANG calls this style of list \"user ordered\"; such lists are indicated with the statement \"ordered-by user\".",
      "ja": "リストの他のスタイルでは、リストの順序は、リストの設定を実装するための事項をエントリし、サーバがその順序を維持しながら、ユーザは、エントリを注文する責任があります。 YANG「は、ユーザが発注した」リストのこのスタイルを呼び出します。このようなリストは、「注文-によってユーザー」声明で示されています。"
    },
    {
      "indent": 3,
      "text": "For example, the order in which packet filter entries are applied to incoming traffic may affect how that traffic is filtered. The user would need to decide if the filter entry that discards all TCP traffic should be applied before or after the filter entry that allows all traffic from trusted interfaces. The choice of order would be crucial.",
      "ja": "例えば、パケットフィルタエントリが着信トラフィックに適用される順序は、そのトラフィックがフィルタリングされる方法に影響を与えることができます。ユーザーは、すべてのTCPトラフィックを破棄フィルタエントリは、信頼できるインターフェイスからのすべてのトラフィックを許可するフィルタエントリの前または後に適用すべきかどうかを決定する必要があります。順序の選択が非常に重要になります。"
    },
    {
      "indent": 3,
      "text": "YANG provides a rich set of facilities within NETCONF's <edit-config> operation that allows the order of list entries in user-ordered lists to be controlled. List entries may be inserted or rearranged, positioned as the first or last entry in the list, or positioned before or after another specific entry.",
      "ja": "YANGは、ユーザーが注文したリストのリスト項目の順序を制御することを可能にするNETCONFの<編集-config>の操作内の施設の豊富なセットを提供します。リストのエントリは、挿入または再配置され、リストの最初または最後のエントリとして配置、又は他の特定のエントリの前または後に配置することができます。"
    },
    {
      "indent": 3,
      "text": "The \"ordered-by\" statement is covered in Section 7.7.7.",
      "ja": "「注文・バイ」文は、セクション7.7.7で覆われています。"
    },
    {
      "indent": 0,
      "text": "7.7.2. The leaf-list's Default Values",
      "section_title": true,
      "ja": "7.7.2. リーフリストのデフォルト値"
    },
    {
      "indent": 3,
      "text": "The default values of a leaf-list are the values that the server uses if the leaf-list does not exist in the data tree. The usage of the default values depends on the leaf-list's closest ancestor node in the schema tree that is not a non-presence container (see Section 7.5.1):",
      "ja": "リーフリストのデフォルト値は、リーフリストは、データツリーに存在しない場合、サーバーが使用する値です。デフォルト値の使用が非存在のコンテナではありませんスキーマツリーのリーフ・リストの最も近い祖先ノードに依存します（第7.5.1項を参照してください）："
    },
    {
      "indent": 3,
      "text": "o If no such ancestor exists in the schema tree, the default values MUST be used.",
      "ja": "そのような祖先は、スキーマ・ツリーに存在しない場合はO、デフォルト値が使用されなければなりません。"
    },
    {
      "indent": 3,
      "text": "o Otherwise, if this ancestor is a case node, the default values MUST be used if any node from the case exists in the data tree or the case node is the choice's default case, and if no nodes from any other case exist in the data tree.",
      "ja": "この祖先は、ケースノードである場合、Oそうでなければ、ケースから任意のノードは、データツリー内に存在する場合やノードが選択のデフォルトの場合であれば、デフォルト値が使用されなければならない、そして、他のケースからのノードがデータ内に存在しない場合木。"
    },
    {
      "indent": 3,
      "text": "o Otherwise, the default values MUST be used if the ancestor node exists in the data tree.",
      "ja": "祖先ノードがデータツリー内に存在する場合にOそうでない場合、デフォルト値が使用されなければなりません。"
    },
    {
      "indent": 3,
      "text": "In these cases, the default values are said to be in use.",
      "ja": "これらのケースでは、デフォルト値が使用中であると言われています。"
    },
    {
      "indent": 3,
      "text": "Note that if the leaf-list or any of its ancestors has a \"when\" condition or \"if-feature\" expression that evaluates to \"false\", then the default values are not in use.",
      "ja": "その祖先の葉、リストまたはいずれかが「偽」と評価された「とき」の状態または「IF-機能」という表現を持っている場合は、デフォルト値が使用されていないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "When the default values are in use, the server MUST operationally behave as if the leaf-list was present in the data tree with the default values as its values.",
      "ja": "デフォルト値が使用されている場合は、サーバが運用リーフリストは、その値としてデフォルト値でデータツリーに存在したかのように振る舞う必要があります。"
    },
    {
      "indent": 3,
      "text": "If a leaf-list has one or more \"default\" statements, the leaf-list's default values are the values of the \"default\" statements, and if the leaf-list is user ordered, the default values are used in the order of the \"default\" statements. Otherwise, if the leaf-list's type has a default value and the leaf-list does not have a \"min-elements\" statement with a value greater than or equal to one, then the leaf-list's default value is one instance of the type's default value. In all other cases, the leaf-list does not have any default values.",
      "ja": "リーフリストは、1つまたは複数の「デフォルト」の文を持っている場合は、リーフリストのデフォルト値は「デフォルト」の文の値であり、リーフリストは、ユーザ注文された場合、デフォルト値が順に使用されています「デフォルト」の文。リーフリストのタイプがデフォルト値を持っているし、そうでない場合、リーフリストは1以上の値を持つ「MIN-要素」文を持っていない、そしてリーフリストのデフォルト値は、タイプの1つのインスタンスでありますデフォルト値。他のすべての例では、リーフリストは、デフォルト値を持っていません。"
    },
    {
      "indent": 0,
      "text": "7.7.3. The leaf-list's Substatements",
      "section_title": true,
      "ja": "7.7.3. リーフリストのサブステートメント"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| config       | 7.21.1  | 0..1        |\n| default      | 7.7.4   | 0..n        |\n| description  | 7.21.3  | 0..1        |\n| if-feature   | 7.20.2  | 0..n        |\n| max-elements | 7.7.6   | 0..1        |\n| min-elements | 7.7.5   | 0..1        |\n| must         | 7.5.3   | 0..n        |\n| ordered-by   | 7.7.7   | 0..1        |\n| reference    | 7.21.4  | 0..1        |\n| status       | 7.21.2  | 0..1        |\n| type         | 7.4     | 1           |\n| units        | 7.3.3   | 0..1        |\n| when         | 7.21.5  | 0..1        |\n+--------------+---------+-------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.7.4. The leaf-list's \"default\" Statement",
      "section_title": true,
      "ja": "7.7.4. リーフリストの「デフォルト」声明"
    },
    {
      "indent": 3,
      "text": "The \"default\" statement, which is optional, takes as an argument a string that contains a default value for the leaf-list.",
      "ja": "オプションである「デフォルト」の文では、引数としてリーフリストのデフォルト値を含む文字列を取ります。"
    },
    {
      "indent": 3,
      "text": "The value of the \"default\" statement MUST be valid according to the type specified in the leaf-list's \"type\" statement.",
      "ja": "「デフォルト」の文の値は、リーフ・リストの「タイプ」文で指定された型に応じて有効である必要があります。"
    },
    {
      "indent": 3,
      "text": "The \"default\" statement MUST NOT be present on nodes where \"min-elements\" has a value greater than or equal to one.",
      "ja": "「デフォルト」の文では「MIN-要素」は1以上の値を有するノードに存在してはなりません。"
    },
    {
      "indent": 0,
      "text": "7.7.5. The \"min-elements\" Statement",
      "section_title": true,
      "ja": "7.7.5.  「最小要素」声明"
    },
    {
      "indent": 3,
      "text": "The \"min-elements\" statement, which is optional, takes as an argument a non-negative integer that puts a constraint on valid list entries. A valid leaf-list or list MUST have at least min-elements entries.",
      "ja": "オプションである「最小要素」文は、引数として有効なリスト項目に制約を置く非負の整数をとります。有効なリーフリストまたはリストには、少なくとも最小の要素エントリを持たなければなりません。"
    },
    {
      "indent": 3,
      "text": "If no \"min-elements\" statement is present, it defaults to zero.",
      "ja": "ない「最小の要素」文は、ゼロがデフォルト、存在しない場合。"
    },
    {
      "indent": 3,
      "text": "The behavior of the constraint depends on the type of the leaf-list's or list's closest ancestor node in the schema tree that is not a non-presence container (see Section 7.5.1):",
      "ja": "制約の動作は、リーフ・リストのまたは非存在コンテナではありませんスキーマツリー内のリストの最も近い祖先ノードの種類によって異なります（第7.5.1項を参照してください）："
    },
    {
      "indent": 3,
      "text": "o If no such ancestor exists in the schema tree, the constraint is enforced.",
      "ja": "そのような祖先がスキーマツリーに存在しない場合は、O、制約が適用されます。"
    },
    {
      "indent": 3,
      "text": "o Otherwise, if this ancestor is a case node, the constraint is enforced if any other node from the case exists.",
      "ja": "この祖先がケースノードである場合にケースから他のノードが存在する場合にOそうでない場合、制約が適用されます。"
    },
    {
      "indent": 3,
      "text": "o Otherwise, it is enforced if the ancestor node exists.",
      "ja": "先祖ノードが存在する場合にOそうでない場合、それが適用されます。"
    },
    {
      "indent": 3,
      "text": "The constraint is further enforced according to the rules in Section 8.",
      "ja": "制約は、さらに、第8章の規則に従って実施されます。"
    },
    {
      "indent": 0,
      "text": "7.7.6. The \"max-elements\" Statement",
      "section_title": true,
      "ja": "7.7.6.  「MAX-要素」声明"
    },
    {
      "indent": 3,
      "text": "The \"max-elements\" statement, which is optional, takes as an argument a positive integer or the string \"unbounded\", which puts a constraint on valid list entries. A valid leaf-list or list always has at most max-elements entries.",
      "ja": "オプションである「MAX-要素」文は、引数として正の整数または有効なリスト項目に制約を置く「無制限」の文字列を取ります。有効なリーフリストまたはリストは、常に、最大max-要素のエントリがあります。"
    },
    {
      "indent": 3,
      "text": "If no \"max-elements\" statement is present, it defaults to \"unbounded\".",
      "ja": "何の「MAX-要素」文は、デフォルト「無制限」に存在しない場合。"
    },
    {
      "indent": 3,
      "text": "The \"max-elements\" constraint is enforced according to the rules in Section 8.",
      "ja": "「MAX-要素」制約は、第8章の規則に従って実施されます。"
    },
    {
      "indent": 0,
      "text": "7.7.7. The \"ordered-by\" Statement",
      "section_title": true,
      "ja": "7.7.7.  「注文-で」文"
    },
    {
      "indent": 3,
      "text": "The \"ordered-by\" statement defines whether the order of entries within a list are determined by the user or the system. The argument is one of the strings \"system\" or \"user\". If not present, ordering defaults to \"system\".",
      "ja": "「注文-で」文は、リスト内のエントリの順序は、ユーザまたはシステムによって決定されているかどうかを定義します。引数は、文字列「システム」または「ユーザー」の一つです。存在しない場合は、「システム」にデフォルトを注文します。"
    },
    {
      "indent": 3,
      "text": "This statement is ignored if the list represents state data, RPC output parameters, or notification content.",
      "ja": "リストには、状態データ、RPC出力パラメータ、または通知内容を表す場合、この文は無視されます。"
    },
    {
      "indent": 3,
      "text": "See Section 7.7.1 for additional information.",
      "ja": "詳細については、7.7.1項を参照してください。"
    },
    {
      "indent": 0,
      "text": "7.7.7.1. ordered-by system",
      "section_title": true,
      "ja": "7.7.7.1。注文-することにより、システム"
    },
    {
      "indent": 3,
      "text": "The entries in the list are ordered according to an order determined by the system. The \"description\" string for the list may suggest an order to the server implementor. If not, an implementation is free to order the entries in any order. An implementation SHOULD use the same order for the same data, regardless of how the data were created. Using a deterministic order will make comparisons possible using simple tools like \"diff\".",
      "ja": "リスト内のエントリは、システムによって決められた順序に従って順序付けされています。リストについては、「説明」列には、サーバーの実装に順序を提案することができます。そうでない場合、実装は任意の順序でエントリを注文して自由です。実装は関係なく、データが作成されたかの、同じデータに対して同じ順序を使用すべきです。決定論的順序を使用すると、「差分」のような簡単なツールを使用して比較が可能になります。"
    },
    {
      "indent": 3,
      "text": "This is the default order.",
      "ja": "これがデフォルトの順序です。"
    },
    {
      "indent": 0,
      "text": "7.7.7.2. ordered-by user",
      "section_title": true,
      "ja": "7.7.7.2。注文-によってユーザー"
    },
    {
      "indent": 3,
      "text": "The entries in the list are ordered according to an order defined by the user. In NETCONF, this order is controlled by using special XML attributes in the <edit-config> request. See Section 7.7.9 for details.",
      "ja": "リスト内のエントリは、ユーザーによって定義された順序に従って順序付けされています。 NETCONFでは、この順序は、<編集-config>の要求に特別なXML属性を使用することによって制御されています。詳細については、セクション7.7.9を参照してください。"
    },
    {
      "indent": 0,
      "text": "7.7.8. XML Encoding Rules",
      "section_title": true,
      "ja": "7.7.8.  XML符号化規則"
    },
    {
      "indent": 3,
      "text": "A leaf-list node is encoded as a series of XML elements. Each element's local name is the leaf-list's identifier, and its namespace is the module's XML namespace (see Section 7.1.3).",
      "ja": "リーフ・リストのノードは、XML要素の系列として符号化されます。各要素のローカル名は、リーフ・リストの識別子であり、その名前空間は、モジュールのXML名前空間（セクション7.1.3を参照）です。"
    },
    {
      "indent": 3,
      "text": "The value of each leaf-list entry is encoded to XML according to the type and is sent as character data in the element.",
      "ja": "各リーフ・リストのエントリの値は、種類に応じてXMLにエンコードされ、要素内の文字データとして送信されます。"
    },
    {
      "indent": 3,
      "text": "The XML elements representing leaf-list entries MUST appear in the order specified by the user if the leaf-list is \"ordered-by user\"; otherwise, the order is implementation dependent. The XML elements representing leaf-list entries MAY be interleaved with elements for siblings of the leaf-list, unless the leaf-list defines RPC or action input or output parameters.",
      "ja": "葉のリストは、「注文-によってユーザー」されている場合、リーフ・リストのエントリを表すXML要素は、ユーザーが指定した順序で表示されなければなりません。そうでない場合は、順序は実装依存です。リーフリストは、RPCまたはアクションの入力または出力パラメータを定義しない限り、リーフ・リスト・エントリを表すXML要素は、リーフリストの兄弟のための要素とインタリーブされるかもしれません。"
    },
    {
      "indent": 3,
      "text": "See Section 7.7.10 for an example.",
      "ja": "例えば、セクション7.7.10を参照してください。"
    },
    {
      "indent": 0,
      "text": "7.7.9. NETCONF <edit-config> Operations",
      "section_title": true,
      "ja": "7.7.9.  NETCONF <編集-config>の操作"
    },
    {
      "indent": 3,
      "text": "Leaf-list entries can be created and deleted, but not modified, through <edit-config>, by using the \"operation\" attribute in the leaf-list entry's XML element.",
      "ja": "リーフ・リストのエントリは、<編集-config>の通じ、葉リストエントリのXML要素に「操作」属性を使用して、作成され、削除されたが、修正されないことができます。"
    },
    {
      "indent": 3,
      "text": "In an \"ordered-by user\" leaf-list, the attributes \"insert\" and \"value\" in the YANG XML namespace (Section 5.3.1) can be used to control where in the leaf-list the entry is inserted. These can be used during \"create\" operations to insert a new leaf-list entry, or during \"merge\" or \"replace\" operations to insert a new leaf-list entry or move an existing one.",
      "ja": "「ユーザ順序付けバイ」リーフリストに、YANG XML名前空間（セクション5.3.1）の属性「挿入」と「値」がリーフリストにエントリが挿入される場所を制御するために使用することができます。これらは、新しい葉リストエントリを挿入する操作を「作成」、または「マージ」や新葉リストエントリを挿入するか、既存のものを移動するための操作を「置き換え」の間に間に使用することができます。"
    },
    {
      "indent": 3,
      "text": "The \"insert\" attribute can take the values \"first\", \"last\", \"before\", and \"after\". If the value is \"before\" or \"after\", the \"value\" attribute MUST also be used to specify an existing entry in the leaf-list.",
      "ja": "属性が「最後」、「前」、および「後」、「最初」の値を取ることができ、「挿入」。値が「前」または「後」である場合は、「値」属性もリーフリストの既存のエントリを指定するために使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If no \"insert\" attribute is present in the \"create\" operation, it defaults to \"last\".",
      "ja": "何の「挿入」属性が「作成」操作中に存在しない場合は、デフォルトの「最後」。"
    },
    {
      "indent": 3,
      "text": "If several entries in an \"ordered-by user\" leaf-list are modified in the same <edit-config> request, the entries are modified one at a time, in the order of the XML elements in the request.",
      "ja": "「注文-により、ユーザ」リーフリスト内の複数のエントリは同じ<編集-config>の要求に変更された場合は、エントリは、要求内のXML要素の順序で、一度に一つを修正しています。"
    },
    {
      "indent": 3,
      "text": "In a <copy-config> or in an <edit-config> with a \"replace\" operation that covers the entire leaf-list, the leaf-list order is the same as the order of the XML elements in the request.",
      "ja": "<コピー設定>または<編集-config>の中で全体の葉のリストをカバーして、「置換」操作で、リーフリストの順序は、要求内のXML要素の順序と同じです。"
    },
    {
      "indent": 3,
      "text": "When a NETCONF server processes an <edit-config> request, the elements of procedure for a leaf-list node are as follows:",
      "ja": "NETCONFサーバは<編集-config>の要求を処理すると、以下のように、リーフリストノードのための手順の要素は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o If the operation is \"merge\" or \"replace\", the leaf-list entry is created if it does not exist.",
      "ja": "操作は「マージ」または「置換」である場合は、それが存在しない場合は、O、葉リストエントリが作成されます。"
    },
    {
      "indent": 3,
      "text": "o If the operation is \"create\", the leaf-list entry is created if it does not exist. If the leaf-list entry already exists, a \"data-exists\" error is returned.",
      "ja": "操作は、「作成」である場合は、それが存在しない場合は、O、葉リストエントリが作成されます。リーフリストのエントリがすでに存在する場合は、「データが存在する」エラーが返されます。"
    },
    {
      "indent": 3,
      "text": "o If the operation is \"delete\", the entry is deleted from the leaf-list if it exists. If the leaf-list entry does not exist, a \"data-missing\" error is returned.",
      "ja": "操作は「削除」である場合は、それが存在する場合は、O、エントリがリーフリストから削除されます。リーフリストのエントリが存在しない場合は、「データ・行方不明」エラーが返されます。"
    },
    {
      "indent": 0,
      "text": "7.7.10. Usage Example",
      "section_title": true,
      "ja": "7.7.10. 使用例"
    },
    {
      "indent": 5,
      "text": "leaf-list allow-user {\n  type string;\n  description\n    \"A list of user name patterns to allow.\";\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A corresponding XML instance example:",
      "ja": "対応するXMLインスタンスの例："
    },
    {
      "indent": 5,
      "text": "<allow-user>alice</allow-user> <allow-user>bob</allow-user>",
      "ja": "<許可ユーザ>アリス</許可ユーザ> <許可ユーザ>ボブ</許可ユーザ>"
    },
    {
      "indent": 3,
      "text": "To create a new element in this list, using the default <edit-config> operation \"merge\":",
      "ja": "このリストに新しい要素を作成するには、デフォルトを使用して、<編集-config>の操作は、「マージ」："
    },
    {
      "indent": 5,
      "text": "<rpc message-id=\"101\" xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\" xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\"> <edit-config> <target> <running/> </target> <config> <system xmlns=\"urn:example:config\"> <services> <ssh> <allow-user>eric</allow-user> </ssh> </services> </system> </config> </edit-config> </rpc>",
      "ja": "<RPCメッセージID = \"101\" のxmlns = \"URN：IETF：paramsは：XML：NS：NETCONF：塩基：1.0\" のxmlns：NC = \"URN：IETF：paramsは：XML：NS：NETCONF：塩基：1.0\"> <編集-config>の<対象> <ランニング/> </ target>を<config>の<システムのxmlns = \"壷：例：コンフィグ\"> <サービス> <SSH> <許可ユーザ>エリック</許可するユーザーを> < / SSH> </サービス> </システム> </ config>の</編集-config>の</ RPC>"
    },
    {
      "indent": 3,
      "text": "Given the following ordered-by user leaf-list:",
      "ja": "与えられた次の順序の-により、ユーザーの葉-リスト："
    },
    {
      "indent": 5,
      "text": "leaf-list cipher {\n  type string;\n  ordered-by user;\n  description\n    \"A list of ciphers.\";\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The following would be used to insert a new cipher \"blowfish-cbc\" after \"3des-cbc\":",
      "ja": "以下は、「3DES-CBC」の後に新しい暗号「フグ-CBC」を挿入するために使用されます。"
    },
    {
      "indent": 5,
      "text": "<rpc message-id=\"102\" xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\" xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\" xmlns:yang=\"urn:ietf:params:xml:ns:yang:1\"> <edit-config> <target> <running/> </target> <config> <system xmlns=\"urn:example:config\"> <services> <ssh> <cipher nc:operation=\"create\" yang:insert=\"after\" yang:value=\"3des-cbc\">blowfish-cbc</cipher> </ssh> </services> </system> </config> </edit-config> </rpc>",
      "ja": "<RPCメッセージID = \"102\" のxmlns = \"URN：IETF：paramsは：XML：NS：NETCONF：塩基：1.0\" のxmlns：NC = \"URN：IETF：paramsは：XML：NS：NETCONF：塩基：1.0\" のxmlns ：陽= \"URN：IETF：paramsは：XML：NS：陽：1\"> <編集設定> <ターゲット> <実行/> </標的> <設定> <システムのxmlns = \"URN：例：設定\"> <サービス> <SSH> <暗号NC：オペレーション=陽 \"を作成\" を挿入=陽 \"の後に\" 値= \"3DES-CBC\">ふぐ-CBC </暗号> </ SSH> </サービス> </システム> </ config>の</編集-config>の</ RPC>"
    },
    {
      "indent": 0,
      "text": "7.8. The \"list\" Statement",
      "section_title": true,
      "ja": "7.8.  「リスト」声明"
    },
    {
      "indent": 3,
      "text": "The \"list\" statement is used to define an interior data node in the schema tree. A list node may exist in multiple instances in the data tree. Each such instance is known as a list entry. The \"list\" statement takes one argument, which is an identifier, followed by a block of substatements that holds detailed list information.",
      "ja": "「リスト」の文は、スキーマツリー内の内部データノードを定義するために使用されます。リスト・ノードは、データツリーの複数のインスタンス内に存在してもよいです。このような各インスタンスは、リストのエントリとして知られています。 「リスト」の文では、詳細なリスト情報を保持しているサブステートメントのブロックが続く識別子、1つの引数を取ります。"
    },
    {
      "indent": 3,
      "text": "A list entry is uniquely identified by the values of the list's keys, if defined.",
      "ja": "定義されている場合、リストのエントリを一意に、リストのキーの値によって識別されます。"
    },
    {
      "indent": 0,
      "text": "7.8.1. The list's Substatements",
      "section_title": true,
      "ja": "7.8.1. リストのサブステートメント"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| action       | 7.15    | 0..n        |\n| anydata      | 7.10    | 0..n        |\n| anyxml       | 7.11    | 0..n        |\n| choice       | 7.9     | 0..n        |\n| config       | 7.21.1  | 0..1        |\n| container    | 7.5     | 0..n        |\n| description  | 7.21.3  | 0..1        |\n| grouping     | 7.12    | 0..n        |\n| if-feature   | 7.20.2  | 0..n        |\n| key          | 7.8.2   | 0..1        |\n| leaf         | 7.6     | 0..n        |\n| leaf-list    | 7.7     | 0..n        |\n| list         | 7.8     | 0..n        |\n| max-elements | 7.7.6   | 0..1        |\n| min-elements | 7.7.5   | 0..1        |\n| must         | 7.5.3   | 0..n        |\n| notification | 7.16    | 0..n        |\n| ordered-by   | 7.7.7   | 0..1        |\n| reference    | 7.21.4  | 0..1        |\n| status       | 7.21.2  | 0..1        |\n| typedef      | 7.3     | 0..n        |\n| unique       | 7.8.3   | 0..n        |\n| uses         | 7.13    | 0..n        |\n| when         | 7.21.5  | 0..1        |\n+--------------+---------+-------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.8.2. The list's \"key\" Statement",
      "section_title": true,
      "ja": "7.8.2. リストの「キー」声明"
    },
    {
      "indent": 3,
      "text": "The \"key\" statement, which MUST be present if the list represents configuration and MAY be present otherwise, takes as an argument a string that specifies a space-separated list of one or more leaf identifiers of this list. A leaf identifier MUST NOT appear more than once in the key. Each such leaf identifier MUST refer to a child leaf of the list. The leafs can be defined directly in substatements to the list or in groupings used in the list.",
      "ja": "リストには、コンフィギュレーションを表し、それ以外の場合は存在する可能性がある場合存在しなければならない「キー」の文では、引数としてこのリストの一の以上のリーフ識別子のスペース区切りのリストを指定する文字列を取ります。葉の識別子は、一度キーでより多く見えてはいけません。そのようなそれぞれの葉の識別子は、リストの子葉を参照する必要があります。リーフリストにサブステートメントまたはリストで使用グルーピングで直接定義することができます。"
    },
    {
      "indent": 3,
      "text": "The combined values of all the leafs specified in the key are used to uniquely identify a list entry. All key leafs MUST be given values when a list entry is created. Thus, any default values in the key leafs or their types are ignored. Any \"mandatory\" statements in the key leafs are ignored.",
      "ja": "キーで指定されたすべてのリーフの合成値は一意リストエントリを識別するために使用されます。リストのエントリが作成されたときにすべてのキーのリーフは、値を指定しなければなりません。このように、キー葉またはそれらの型のいずれかのデフォルト値は無視されます。キー葉内の任意の「必須」の文は無視されます。"
    },
    {
      "indent": 3,
      "text": "A leaf that is part of the key can be of any built-in or derived type.",
      "ja": "キーの一部であり、葉は、任意の組み込みまたは派生タイプのものとすることができます。"
    },
    {
      "indent": 3,
      "text": "All key leafs in a list MUST have the same value for their \"config\" as the list itself.",
      "ja": "リスト内のすべてのキーのリーフは、リスト自体としての「設定」の同じ値を持たなければなりません。"
    },
    {
      "indent": 3,
      "text": "The key string syntax is formally defined by the rule \"key-arg\" in Section 14.",
      "ja": "キー文字列の構文は、正式ルール第14条では、「キーのarg」によって定義されます。"
    },
    {
      "indent": 0,
      "text": "7.8.3. The list's \"unique\" Statement",
      "section_title": true,
      "ja": "7.8.3. リストの「ユニーク」声明"
    },
    {
      "indent": 3,
      "text": "The \"unique\" statement is used to put constraints on valid list entries. It takes as an argument a string that contains a space-separated list of schema node identifiers, which MUST be given in the descendant form (see the rule \"descendant-schema-nodeid\" in Section 14). Each such schema node identifier MUST refer to a leaf.",
      "ja": "「ユニークな」文は、有効なリスト項目に制約を置くために使用されています。これは引数として子孫の形で与えられなければならないスキーマノード識別子、のスペースで区切られたリストを含む文字列をとる（第14規則「子孫-スキーマNODEID」を参照）。このような各スキーマのノード識別子は、リーフを参照しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If one of the referenced leafs represents configuration data, then all of the referenced leafs MUST represent configuration data.",
      "ja": "参照されるリーフの一方はコンフィギュレーションデータを表す場合、参照されるリーフの全ては、構成データを表現しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The \"unique\" constraint specifies that the combined values of all the leaf instances specified in the argument string, including leafs with default values, MUST be unique within all list entry instances in which all referenced leafs exist or have default values. The constraint is enforced according to the rules in Section 8.",
      "ja": "「ユニークな」制約は、デフォルト値を持つ葉を含む引数文字列で指定されたすべてのリーフインスタンスの結合値は、参照されるすべての葉が存在するか、デフォルト値を持っているすべてのリストエントリのインスタンス内で一意でなければならないことを指定します。制約は、第8章の規則に従って実施されます。"
    },
    {
      "indent": 3,
      "text": "The unique string syntax is formally defined by the rule \"unique-arg\" in Section 14.",
      "ja": "一意の文字列の構文は正式に第14内のルール「ユニーク-argに」で定義されています。"
    },
    {
      "indent": 0,
      "text": "7.8.3.1. Usage Example",
      "section_title": true,
      "ja": "7.8.3.1。使用例"
    },
    {
      "indent": 3,
      "text": "With the following list:",
      "ja": "以下のリストの場合："
    },
    {
      "indent": 5,
      "text": "list server {\n  key \"name\";\n  unique \"ip port\";\n  leaf name {\n    type string;\n  }\n  leaf ip {\n    type inet:ip-address;\n  }\n  leaf port {\n    type inet:port-number;\n  }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "the following configuration is not valid:",
      "ja": "以下の設定は有効ではありません。"
    },
    {
      "indent": 5,
      "text": "<server> <name>smtp</name> <ip>192.0.2.1</ip> <port>25</port> </server>",
      "ja": "<サーバー> <名前> SMTP </名前> <IP> 192.0.2.1 </ IP> <ポート> 25 </ポート> </サーバ>"
    },
    {
      "indent": 5,
      "text": "<server> <name>http</name> <ip>192.0.2.1</ip> <port>25</port> </server>",
      "ja": "<サーバー> <名前> HTTP </名前> <IP> 192.0.2.1 </ IP> <ポート> 25 </ポート> </サーバ>"
    },
    {
      "indent": 3,
      "text": "The following configuration is valid, since the \"http\" and \"ftp\" list entries do not have a value for all referenced leafs and are thus not taken into account when the \"unique\" constraint is enforced:",
      "ja": "「http」と「FTP」リストのエントリは、すべての参照のリーフの値を持っていないと「ユニーク」の制約が適用されているときのように考慮されませんので、以下の設定は、有効です。"
    },
    {
      "indent": 5,
      "text": "<server> <name>smtp</name> <ip>192.0.2.1</ip> <port>25</port> </server>",
      "ja": "<サーバー> <名前> SMTP </名前> <IP> 192.0.2.1 </ IP> <ポート> 25 </ポート> </サーバ>"
    },
    {
      "indent": 5,
      "text": "<server> <name>http</name> <ip>192.0.2.1</ip> </server>",
      "ja": "<サーバー> <名前> HTTP </名前> <IP> 192.0.2.1 </ IP> </サーバー>"
    },
    {
      "indent": 5,
      "text": "<server> <name>ftp</name> <ip>192.0.2.1</ip> </server>",
      "ja": "<サーバー> <名前> FTP </名前> <IP> 192.0.2.1 </ IP> </サーバー>"
    },
    {
      "indent": 0,
      "text": "7.8.4. The list's Child Node Statements",
      "section_title": true,
      "ja": "7.8.4. リストの子ノード文"
    },
    {
      "indent": 3,
      "text": "Within a list, the \"container\", \"leaf\", \"list\", \"leaf-list\", \"uses\", \"choice\", \"anydata\", and \"anyxml\" statements can be used to define child nodes to the list.",
      "ja": "リスト、「コンテナ」、「葉」、「リスト」、「リーフリスト」、「用途」、「選択」、「ANYDATA」、および「AnyXMLで」文の中で、リストに子ノードを定義するために使用することができます。"
    },
    {
      "indent": 0,
      "text": "7.8.5. XML Encoding Rules",
      "section_title": true,
      "ja": "7.8.5.  XML符号化規則"
    },
    {
      "indent": 3,
      "text": "A list is encoded as a series of XML elements, one for each entry in the list. Each element's local name is the list's identifier, and its namespace is the module's XML namespace (see Section 7.1.3). There is no XML element surrounding the list as a whole.",
      "ja": "リストは、XML要素、リストの各エントリのための1つの系列として符号化されます。各要素のローカル名は、リストの識別子であり、その名前空間は、モジュールのXML名前空間（セクション7.1.3を参照）です。全体として、リストを囲む全くXML要素がありません。"
    },
    {
      "indent": 3,
      "text": "The list's key nodes are encoded as subelements to the list's identifier element, in the same order as they are defined within the \"key\" statement.",
      "ja": "リストのキーのノードは、それらが「鍵」ステートメント内に定義されているのと同じ順番で、リストの識別子要素にサブ要素としてエンコードされています。"
    },
    {
      "indent": 3,
      "text": "The rest of the list's child nodes are encoded as subelements to the list element, after the keys. If the list defines RPC or action input or output parameters, the subelements are encoded in the same order as they are defined within the \"list\" statement. Otherwise, the subelements are encoded in any order.",
      "ja": "リストの子ノードの残りの部分は、キーの後に、リスト要素のサブ要素としてエンコードされています。リストには、RPCまたはアクションの入力または出力パラメータを定義している場合、サブ要素は、それらが「リスト」ステートメント内に定義されているのと同じ順序で符号化されます。それ以外の場合は、サブ要素は任意の順序で符号化されています。"
    },
    {
      "indent": 3,
      "text": "Any whitespace between the subelements to the list entry is insignificant, i.e., an implementation MAY insert whitespace characters between subelements.",
      "ja": "リストエントリへのサブ要素間の空白は軽微であり、すなわち、実装はサブ要素の間に空白文字を挿入することができます。"
    },
    {
      "indent": 3,
      "text": "The XML elements representing list entries MUST appear in the order specified by the user if the list is \"ordered-by user\"; otherwise, the order is implementation dependent. The XML elements representing list entries MAY be interleaved with elements for siblings of the list, unless the list defines RPC or action input or output parameters.",
      "ja": "リストは、「注文-によってユーザー」された場合は、リスト項目を表すXML要素は、ユーザーが指定した順序で表示されなければなりません。そうでない場合は、順序は実装依存です。リストは、RPCまたはアクションの入力または出力パラメータを定義しない限り、リストのエントリを表すXML要素は、リストの兄弟のための要素とインタリーブされるかもしれません。"
    },
    {
      "indent": 0,
      "text": "7.8.6. NETCONF <edit-config> Operations",
      "section_title": true,
      "ja": "7.8.6.  NETCONF <編集-config>の操作"
    },
    {
      "indent": 3,
      "text": "List entries can be created, deleted, replaced, and modified through <edit-config> by using the \"operation\" attribute in the list's XML element. In each case, the values of all keys are used to uniquely identify a list entry. If all keys are not specified for a list entry, a \"missing-element\" error is returned.",
      "ja": "リストのエントリは、作成、削除、置き換え、およびリストのXML要素に「操作」属性を使用して、<編集-config>のを介して変更することができます。それぞれの場合に、すべてのキーの値は一意にリストエントリを識別するために使用されます。すべてのキーがリストのエントリに指定されていない場合は、「不足している要素」エラーが返されます。"
    },
    {
      "indent": 3,
      "text": "In an \"ordered-by user\" list, the attributes \"insert\" and \"key\" in the YANG XML namespace (Section 5.3.1) can be used to control where in the list the entry is inserted. These can be used during \"create\" operations to insert a new list entry, or during \"merge\" or \"replace\" operations to insert a new list entry or move an existing one.",
      "ja": "「順序付け-によってユーザ」リストに、属性「インサート」とYANG XML名前空間に「キー」（セクション5.3.1）リスト内のエントリが挿入される場所を制御するために使用することができます。これらは、新しいリスト項目を挿入する操作を「作成」、または「マージ」、または新しいリストエントリを挿入するか、既存のものを移動するための操作を「置き換え」の間に間に使用することができます。"
    },
    {
      "indent": 3,
      "text": "The \"insert\" attribute can take the values \"first\", \"last\", \"before\", and \"after\". If the value is \"before\" or \"after\", the \"key\" attribute MUST also be used, to specify an existing element in the list. The value of the \"key\" attribute is the key predicates of the full instance identifier (see Section 9.13) for the list entry.",
      "ja": "属性が「最後」、「前」、および「後」、「最初」の値を取ることができ、「挿入」。値が「前」または「後」である場合は、「キー」属性は、リスト内の既存の要素を指定するために、使用しなければなりません。 「キー」属性の値は、リストのエントリのために（セクション9.13を参照）のフルインスタンス識別子の重要な述語です。"
    },
    {
      "indent": 3,
      "text": "If no \"insert\" attribute is present in the \"create\" operation, it defaults to \"last\".",
      "ja": "何の「挿入」属性が「作成」操作中に存在しない場合は、デフォルトの「最後」。"
    },
    {
      "indent": 3,
      "text": "If several entries in an \"ordered-by user\" list are modified in the same <edit-config> request, the entries are modified one at a time, in the order of the XML elements in the request.",
      "ja": "「ユーザー命じ・バイ」リスト内の複数のエントリは同じ<編集-config>の要求に変更された場合は、エントリは、要求内のXML要素の順序で、一度に一つを修正しています。"
    },
    {
      "indent": 3,
      "text": "In a <copy-config> or in an <edit-config> with a \"replace\" operation that covers the entire list, the list entry order is the same as the order of the XML elements in the request.",
      "ja": "<コピー設定>または<編集-config>の中で、リスト全体をカバーして、「置換」操作で、リストのエントリの順序は、要求内のXML要素の順序と同じです。"
    },
    {
      "indent": 3,
      "text": "When a NETCONF server processes an <edit-config> request, the elements of procedure for a list node are as follows:",
      "ja": "NETCONFサーバは<編集設定>要求を処理するときに、以下のように、リスト・ノードのための手順の要素は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o If the operation is \"merge\" or \"replace\", the list entry is created if it does not exist. If the list entry already exists and the \"insert\" and \"key\" attributes are present, the list entry is moved according to the values of the \"insert\" and \"key\" attributes. If the list entry exists and the \"insert\" and \"key\" attributes are not present, the list entry is not moved.",
      "ja": "操作は「マージ」または「置換」である場合は、それが存在しない場合は、O、リストのエントリが作成されます。リストのエントリがすでに存在し、「挿入」と「キー」の属性が存在している場合は、リストの項目が「挿入」と「キー」の値に応じて移動される属性。リストのエントリが存在し、「挿入」と「キー」の属性が存在しない場合は、リストのエントリが移動されません。"
    },
    {
      "indent": 3,
      "text": "o If the operation is \"create\", the list entry is created if it does not exist. If the list entry already exists, a \"data-exists\" error is returned.",
      "ja": "操作は、「作成」である場合は、それが存在しない場合は、O、リストのエントリが作成されます。リストエントリがすでに存在する場合は、「データが存在する」エラーが返されます。"
    },
    {
      "indent": 3,
      "text": "o If the operation is \"delete\", the entry is deleted from the list if it exists. If the list entry does not exist, a \"data-missing\" error is returned.",
      "ja": "操作は「削除」である場合は、それが存在する場合は、O、エントリがリストから削除されます。リストのエントリが存在しない場合は、「データ・行方不明」エラーが返されます。"
    },
    {
      "indent": 0,
      "text": "7.8.7. Usage Example",
      "section_title": true,
      "ja": "7.8.7. 使用例"
    },
    {
      "indent": 3,
      "text": "Given the following list:",
      "ja": "以下のリストを考えます："
    },
    {
      "indent": 5,
      "text": "list user {\n  key \"name\";\n  config true;\n  description\n    \"This is a list of users in the system.\";",
      "raw": true
    },
    {
      "indent": 5,
      "text": "  leaf name {\n    type string;\n  }\n  leaf type {\n    type string;\n  }\n  leaf full-name {\n    type string;\n  }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A corresponding XML instance example:",
      "ja": "対応するXMLインスタンスの例："
    },
    {
      "indent": 5,
      "text": "<user> <name>fred</name> <type>admin</type> <full-name>Fred Flintstone</full-name> </user>",
      "ja": "<ユーザー> <名前>フレッド</名前> <タイプ>管理者</入力> <フルネーム>フレッド・フリントストーン</フルネーム> </ユーザー>"
    },
    {
      "indent": 3,
      "text": "To create a new user \"barney\":",
      "ja": "新しいユーザー「バーニー」を作成するには："
    },
    {
      "indent": 5,
      "text": "<rpc message-id=\"101\" xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\" xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\"> <edit-config> <target> <running/> </target> <config> <system xmlns=\"urn:example:config\"> <user nc:operation=\"create\"> <name>barney</name> <type>admin</type> <full-name>Barney Rubble</full-name> </user> </system> </config> </edit-config> </rpc>",
      "ja": "<RPCメッセージID = \"101\" のxmlns = \"URN：IETF：paramsは：XML：NS：NETCONF：塩基：1.0\" のxmlns：NC = \"URN：IETF：paramsは：XML：NS：NETCONF：塩基：1.0\"> <編集設定> <ターゲット> <実行/> </ターゲット> <設定> <システムのxmlns = \"URN：例：コンフィグ\"> <ユーザNC：オペレーション= \"作成\"> <名前>バーニー</名前> <タイプ>管理者</>タイプ<フルネーム>バーニー瓦礫</フルネーム> </ユーザー> </システム> </ config>の</編集-config>の</ RPC>"
    },
    {
      "indent": 3,
      "text": "To change the type of \"fred\" to \"superuser\":",
      "ja": "「スーパーユーザ」に「フレッド」の種類を変更するには："
    },
    {
      "indent": 5,
      "text": "<rpc message-id=\"102\" xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\" xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\"> <edit-config> <target> <running/> </target> <config> <system xmlns=\"urn:example:config\"> <user> <name>fred</name> <type>superuser</type> </user> </system> </config> </edit-config> </rpc>",
      "ja": "<RPCメッセージID = \"102\" のxmlns = \"URN：IETF：paramsは：XML：NS：NETCONF：塩基：1.0\" のxmlns：NC = \"URN：IETF：paramsは：XML：NS：NETCONF：塩基：1.0\"> <編集-config>の<対象> <ランニング/> </ target>を<config>の<システムのxmlns = \"壷：例：コンフィグ\"> <ユーザー> <名前>フレッド</名前> <タイプ>スーパー</タイプ> </ USER> </システム> </ config>の</編集-config>の</ RPC>"
    },
    {
      "indent": 3,
      "text": "Given the following ordered-by user list:",
      "ja": "以下は、注文した-でユーザーリストを考えます："
    },
    {
      "indent": 5,
      "text": "list user {\n  description\n    \"This is a list of users in the system.\";\n  ordered-by user;\n  config true;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "key \"first-name surname\";",
      "ja": "キー「最初の名姓」。"
    },
    {
      "indent": 5,
      "text": "  leaf first-name {\n    type string;\n  }\n  leaf surname {\n    type string;\n  }\n  leaf type {\n    type string;\n  }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The following would be used to insert a new user \"barney rubble\" after the user \"fred flintstone\":",
      "ja": "以下は、新しいユーザー「バーニーのがれき」ユーザーの後に「フレッドフリントストーン」を挿入するために使用されます。"
    },
    {
      "indent": 5,
      "text": "<rpc message-id=\"101\" xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\" xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\" xmlns:yang=\"urn:ietf:params:xml:ns:yang:1\"> <edit-config> <target> <running/> </target> <config> <system xmlns=\"urn:example:config\" xmlns:ex=\"urn:example:config\"> <user nc:operation=\"create\" yang:insert=\"after\" yang:key=\"[ex:first-name='fred'] [ex:surname='flintstone']\"> <first-name>barney</first-name> <surname>rubble</surname> <type>admin</type> </user> </system> </config> </edit-config> </rpc>",
      "ja": "<RPCメッセージID = \"101\" のxmlns = \"URN：IETF：paramsは：XML：NS：NETCONF：塩基：1.0\" のxmlns：NC = \"URN：IETF：paramsは：XML：NS：NETCONF：塩基：1.0\" のxmlns ：陽= \"URN：IETF：paramsは：XML：NS：陽：1\"> <編集設定> <ターゲット> <実行/> </標的> <設定> <システムのxmlns = \"URN：例：コンフィグ\" のxmlns ：EX = \"URN：例：コンフィグ\"> <ユーザNC：動作= \"作成\" 陽：挿入= \"の後に\" 陽：キー= \"[例：ファーストネーム= 'フレッド'] [例：姓= 'フリントストーン「] \"> <ファーストネーム>バーニー</一名> <姓>瓦礫</姓> <タイプ>管理者</タイプ> </ユーザー> </システム> </ config>の</編集設定> </ RPC>"
    },
    {
      "indent": 3,
      "text": "The following would be used to move the user \"barney rubble\" before the user \"fred flintstone\":",
      "ja": "次のユーザーを移動するために使用される「バーニーのがれき」ユーザー「フレッド・フリントストーン」の前に："
    },
    {
      "indent": 5,
      "text": "<rpc message-id=\"102\" xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\" xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\" xmlns:yang=\"urn:ietf:params:xml:ns:yang:1\"> <edit-config> <target> <running/> </target> <config> <system xmlns=\"urn:example:config\" xmlns:ex=\"urn:example:config\"> <user nc:operation=\"merge\" yang:insert=\"before\" yang:key=\"[ex:name='fred'] [ex:surname='flintstone']\"> <first-name>barney</first-name> <surname>rubble</surname> </user> </system> </config> </edit-config> </rpc>",
      "ja": "<RPCメッセージID = \"102\" のxmlns = \"URN：IETF：paramsは：XML：NS：NETCONF：塩基：1.0\" のxmlns：NC = \"URN：IETF：paramsは：XML：NS：NETCONF：塩基：1.0\" のxmlns ：陽= \"URN：IETF：paramsは：XML：NS：陽：1\"> <編集設定> <ターゲット> <実行/> </標的> <設定> <システムのxmlns = \"URN：例：コンフィグ\" のxmlns ：EX = \"URN：例：コンフィグ\"> <ユーザNC：オペレーション= \"マージ\" 陽：挿入= \"前\" 陽：キー= \"[例：名前= 'フレッド'] [例：姓= 'フリントストーン'] 「> <ファーストネーム>バーニー</一名> <姓>瓦礫</姓> </ユーザー> </システム> </ config>の</編集-config>の</ RPC>"
    },
    {
      "indent": 0,
      "text": "7.9. The \"choice\" Statement",
      "section_title": true,
      "ja": "7.9.  「選択」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"choice\" statement defines a set of alternatives, only one of which may be present in any one data tree. The argument is an identifier, followed by a block of substatements that holds detailed choice information. The identifier is used to identify the choice node in the schema tree. A choice node does not exist in the data tree.",
      "ja": "「選択」文は、いずれかのデータツリーに存在することができるそのうち一つだけを選択肢の集合を定義します。引数は、詳細な選択情報を保持するサブステートメントのブロック続いて、識別子です。識別子は、スキーマツリーで選択ノードを識別するために使用されます。選択ノードは、データツリーには存在しません。"
    },
    {
      "indent": 3,
      "text": "A choice consists of a number of branches, each defined with a \"case\" substatement. Each branch contains a number of child nodes. The nodes from at most one of the choice's branches exist at the same time.",
      "ja": "選択は枝の数、「ケース」のサブステートメントで定義された各構成されています。各ブランチは、子ノードの数が含まれています。選択肢の支店の多​​くても1つのノードが同時に存在します。"
    },
    {
      "indent": 3,
      "text": "Since only one of the choice's cases can be valid at any time in the data tree, the creation of a node from one case implicitly deletes all nodes from all other cases. If a request creates a node from a case, the server will delete any existing nodes that are defined in other cases inside the choice.",
      "ja": "選択肢の例のみがデータツリー内の任意の時点で有効であることができるので、1ケースからのノードの作成は暗黙のうちに他のすべてのケースからすべてのノードを削除します。リクエストがケースからノードを作成する場合、サーバは、選択内の他の例で定義されているすべての既存のノードを削除します。"
    },
    {
      "indent": 0,
      "text": "7.9.1. The choice's Substatements",
      "section_title": true,
      "ja": "7.9.1. 選択肢のサブステートメント"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| anydata      | 7.10    | 0..n        |\n| anyxml       | 7.11    | 0..n        |\n| case         | 7.9.2   | 0..n        |\n| choice       | 7.9     | 0..n        |\n| config       | 7.21.1  | 0..1        |\n| container    | 7.5     | 0..n        |\n| default      | 7.9.3   | 0..1        |\n| description  | 7.21.3  | 0..1        |\n| if-feature   | 7.20.2  | 0..n        |\n| leaf         | 7.6     | 0..n        |\n| leaf-list    | 7.7     | 0..n        |\n| list         | 7.8     | 0..n        |\n| mandatory    | 7.9.4   | 0..1        |\n| reference    | 7.21.4  | 0..1        |\n| status       | 7.21.2  | 0..1        |\n| when         | 7.21.5  | 0..1        |\n+--------------+---------+-------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.9.2. The choice's \"case\" Statement",
      "section_title": true,
      "ja": "7.9.2. 選択肢の「ケース」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"case\" statement is used to define branches of the choice. It takes as an argument an identifier, followed by a block of substatements that holds detailed case information.",
      "ja": "「ケース」文は、選択した枝を定義するために使用されます。これは引数として、詳細なケースの情報を保持するサブステートメントのブロックが続く識別子をとります。"
    },
    {
      "indent": 3,
      "text": "The identifier is used to identify the case node in the schema tree. A case node does not exist in the data tree.",
      "ja": "識別子は、スキーマツリーのケースノードを識別するために使用されます。ケースノードは、データツリーに存在しません。"
    },
    {
      "indent": 3,
      "text": "Within a \"case\" statement, the \"anydata\", \"anyxml\", \"choice\", \"container\", \"leaf\", \"list\", \"leaf-list\", and \"uses\" statements can be used to define child nodes to the case node. The identifiers of all these child nodes MUST be unique within all cases in a choice. For example, the following is illegal:",
      "ja": "「ケース」声明、「ANYDATA」、「AnyXMLで」、「選択」、「コンテナ」、「葉」、「リスト」、「リーフリスト」、および内のステートメントは、子ノードを定義するために使用することができ、「使用しています」ケースノードに。これらすべての子ノードの識別子は、選択中のすべてのケース内で一意でなければなりません。例えば、以下は違法です。"
    },
    {
      "indent": 5,
      "text": "choice interface-type { // This example is illegal YANG case a { leaf ethernet { ... } } case b { container ethernet { ...} } }",
      "ja": "選択インタフェース型{//この例では、違法YANGの場合は{リーフイーサネット{...}}ケースb {容器イーサネット{...}}}"
    },
    {
      "indent": 3,
      "text": "As a shorthand, the \"case\" statement can be omitted if the branch contains a single \"anydata\", \"anyxml\", \"choice\", \"container\", \"leaf\", \"list\", or \"leaf-list\" statement. In this case, the case node still exists in the schema tree, and its identifier is the same as the identifier of the child node. Schema node identifiers (Section 6.5) MUST always explicitly include case node identifiers. The following example:",
      "ja": "ブランチは、単一の「ANYDATA」、「AnyXMLで」、「選択」、「コンテナ」、「葉」、「リスト」、または「リーフリスト」のステートメントが含まれている場合は省略形として、「ケース」文は省略することができます。この場合、ケースノードが依然としてスキーマ・ツリー内に存在し、その識別子は、子ノードの識別子と同じです。スキーマのノード識別子（セクション6.5）は、常に明示的にケースのノード識別子を含まなければなりません。次の例："
    },
    {
      "indent": 5,
      "text": "choice interface-type { container ethernet { ... } }",
      "ja": "選択インタフェース型{容器イーサネット{...}}"
    },
    {
      "indent": 3,
      "text": "is equivalent to:",
      "ja": "と同等です。"
    },
    {
      "indent": 5,
      "text": "choice interface-type { case ethernet { container ethernet { ... } } }",
      "ja": "選択インタフェース型{ケースイーサネット{容器イーサネット{...}}}"
    },
    {
      "indent": 3,
      "text": "The case identifier MUST be unique within a choice.",
      "ja": "ケース識別子は、選択内で一意でなければなりません。"
    },
    {
      "indent": 0,
      "text": "7.9.2.1. The case's Substatements",
      "section_title": true,
      "ja": "7.9.2.1。ケースのサブステートメント"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| anydata      | 7.10    | 0..n        |\n| anyxml       | 7.11    | 0..n        |\n| choice       | 7.9     | 0..n        |\n| container    | 7.5     | 0..n        |\n| description  | 7.21.3  | 0..1        |\n| if-feature   | 7.20.2  | 0..n        |\n| leaf         | 7.6     | 0..n        |\n| leaf-list    | 7.7     | 0..n        |\n| list         | 7.8     | 0..n        |\n| reference    | 7.21.4  | 0..1        |\n| status       | 7.21.2  | 0..1        |\n| uses         | 7.13    | 0..n        |\n| when         | 7.21.5  | 0..1        |\n+--------------+---------+-------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.9.3. The choice's \"default\" Statement",
      "section_title": true,
      "ja": "7.9.3. 選択肢の「デフォルト」声明"
    },
    {
      "indent": 3,
      "text": "The \"default\" statement indicates if a case should be considered as the default if no child nodes from any of the choice's cases exist. The argument is the identifier of the default \"case\" statement. If the \"default\" statement is missing, there is no default case.",
      "ja": "選択の例の任意の子ノードが存在しない場合場合は、デフォルトとして考慮されるべきである場合、「デフォルト」の文を示します。引数には、デフォルトの「ケース」の文の識別子です。 「デフォルト」の文が欠落している場合は、デフォルトの場合はありません。"
    },
    {
      "indent": 3,
      "text": "The \"default\" statement MUST NOT be present on choices where \"mandatory\" is \"true\".",
      "ja": "「デフォルト」の文では「必須」は「真」である選択肢に存在してはなりません。"
    },
    {
      "indent": 3,
      "text": "The default case is only important when considering the \"default\" statements of nodes under the cases (i.e., default values of leafs and leaf-lists, and default cases of nested choices). The default values and nested default cases under the default case are used if none of the nodes under any of the cases are present.",
      "ja": "例下のノードの「デフォルト」の文を検討する際に、デフォルトの場合にのみ重要である（すなわち、葉と葉のリスト、およびネストされた選択肢のデフォルトの例デフォルト値）。いずれの場合も下のノードのいずれも存在しない場合は、デフォルトケースの下のデフォルト値と、ネストされたデフォルトのケースが使用されています。"
    },
    {
      "indent": 3,
      "text": "There MUST NOT be any mandatory nodes (Section 3) directly under the default case.",
      "ja": "直接デフォルトのケースの下で任意の必須ノード（第3節）があってはなりません。"
    },
    {
      "indent": 3,
      "text": "Default values for child nodes under a case are only used if one of the nodes under that case is present or if that case is the default case. If none of the nodes under a case are present and the case is not the default case, the default values of the cases' child nodes are ignored.",
      "ja": "その場合は、デフォルトの場合であれば、その場合下のいずれかのノードが存在する場合や、ケースの下の子ノードのデフォルト値にのみ使用されます。ケースの下のノードのどれもが存在しないと場合は、デフォルトでない場合、例子ノードのデフォルト値は無視されます。"
    },
    {
      "indent": 3,
      "text": "In this example, the choice defaults to \"interval\", and the default value will be used if none of \"daily\", \"time-of-day\", or \"manual\" are present. If \"daily\" is present, the default value for \"time-of-day\" will be used.",
      "ja": "この例では、「間隔」、およびデフォルト値に選択のデフォルトが使用される場合、「毎日」、「時刻」、または「手動」存在しているのなし。 「毎日」が存在する場合は、「時間帯」のデフォルト値が使用されます。"
    },
    {
      "indent": 5,
      "text": "container transfer {\n  choice how {\n    default interval;\n    case interval {\n      leaf interval {\n        type uint16;\n        units minutes;\n        default 30;\n      }\n    }\n    case daily {\n      leaf daily {\n        type empty;\n      }\n      leaf time-of-day {\n        type string;\n        units 24-hour-clock;\n        default \"01.00\";\n      }\n    }\n    case manual {\n      leaf manual {\n        type empty;\n      }\n    }\n  }\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.9.4. The choice's \"mandatory\" Statement",
      "section_title": true,
      "ja": "7.9.4. 選択肢の「必須」声明"
    },
    {
      "indent": 3,
      "text": "The \"mandatory\" statement, which is optional, takes as an argument the string \"true\" or \"false\" and puts a constraint on valid data. If \"mandatory\" is \"true\", at least one node from exactly one of the choice's case branches MUST exist.",
      "ja": "オプションである「必須」の文では、引数の文字列「true」または「false」として受け取り、有効なデータに制約を置きます。 「必須」は「真」である場合は、選択肢のケースの枝のちょうど1から少なくとも1つのノードが存在しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If not specified, the default is \"false\".",
      "ja": "指定しない場合、デフォルトは「false」です。"
    },
    {
      "indent": 3,
      "text": "The behavior of the constraint depends on the type of the choice's closest ancestor node in the schema tree that is not a non-presence container (see Section 7.5.1):",
      "ja": "制約の動作は非存在コンテナではありませんスキーマツリーでの選択の最も近い祖先ノードの種類によって異なります（第7.5.1項を参照してください）："
    },
    {
      "indent": 3,
      "text": "o If no such ancestor exists in the schema tree, the constraint is enforced.",
      "ja": "そのような祖先がスキーマツリーに存在しない場合は、O、制約が適用されます。"
    },
    {
      "indent": 3,
      "text": "o Otherwise, if this ancestor is a case node, the constraint is enforced if any other node from the case exists.",
      "ja": "この祖先がケースノードである場合にケースから他のノードが存在する場合にOそうでない場合、制約が適用されます。"
    },
    {
      "indent": 3,
      "text": "o Otherwise, it is enforced if the ancestor node exists.",
      "ja": "先祖ノードが存在する場合にOそうでない場合、それが適用されます。"
    },
    {
      "indent": 3,
      "text": "The constraint is further enforced according to the rules in Section 8.",
      "ja": "制約は、さらに、第8章の規則に従って実施されます。"
    },
    {
      "indent": 0,
      "text": "7.9.5. XML Encoding Rules",
      "section_title": true,
      "ja": "7.9.5.  XML符号化規則"
    },
    {
      "indent": 3,
      "text": "The choice and case nodes are not visible in XML.",
      "ja": "選択とケースのノードは、XMLには表示されません。"
    },
    {
      "indent": 3,
      "text": "The child nodes of the selected \"case\" statement MUST be encoded in the same order as they are defined in the \"case\" statement if they are part of an RPC or action input or output parameter definition. Otherwise, the subelements are encoded in any order.",
      "ja": "選択された「ケース」ステートメントの子ノードは、それらがRPCまたはアクションの入力または出力パラメータ定義の一部である場合、それらは「ケース」ステートメントで定義されているのと同じ順序で符号化されなければなりません。それ以外の場合は、サブ要素は任意の順序で符号化されています。"
    },
    {
      "indent": 0,
      "text": "7.9.6. Usage Example",
      "section_title": true,
      "ja": "7.9.6. 使用例"
    },
    {
      "indent": 3,
      "text": "Given the following choice:",
      "ja": "以下の選択肢を考えます："
    },
    {
      "indent": 5,
      "text": "container protocol {\n  choice name {\n    case a {\n      leaf udp {\n        type empty;\n      }\n    }\n    case b {\n      leaf tcp {\n        type empty;\n      }\n    }\n  }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A corresponding XML instance example:",
      "ja": "対応するXMLインスタンスの例："
    },
    {
      "indent": 5,
      "text": "<protocol> <tcp/> </protocol>",
      "ja": "<プロトコル> <TCP /> </プロトコル>"
    },
    {
      "indent": 3,
      "text": "To change the protocol from TCP to UDP:",
      "ja": "TCPからUDPにプロトコルを変更するには："
    },
    {
      "indent": 5,
      "text": "<rpc message-id=\"101\" xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\" xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\"> <edit-config> <target> <running/> </target> <config> <system xmlns=\"urn:example:config\"> <protocol> <udp nc:operation=\"create\"/> </protocol> </system> </config> </edit-config> </rpc>",
      "ja": "<RPCメッセージID = \"101\" のxmlns = \"URN：IETF：paramsは：XML：NS：NETCONF：塩基：1.0\" のxmlns：NC = \"URN：IETF：paramsは：XML：NS：NETCONF：塩基：1.0\"> <編集設定> <ターゲット> <実行/> </標的> <設定> <システムのxmlns = \"URN：例：コンフィグ\"> <プロトコル> <UDP NC：オペレーション= \"作成\" /> </プロトコル> < /システム> </ config>の</編集-config>の</ RPC>"
    },
    {
      "indent": 0,
      "text": "7.10. The \"anydata\" Statement",
      "section_title": true,
      "ja": "7.10.  「ANYDATA」文"
    },
    {
      "indent": 3,
      "text": "The \"anydata\" statement defines an interior node in the schema tree. It takes one argument, which is an identifier, followed by a block of substatements that holds detailed anydata information.",
      "ja": "「ANYDATA」の文は、スキーマツリーの内部ノードを定義します。これは、詳細なANYDATA情報を保持するサブステートメントのブロックが続く識別子であり、一つの引数を取ります。"
    },
    {
      "indent": 3,
      "text": "The \"anydata\" statement is used to represent an unknown set of nodes that can be modeled with YANG, except anyxml, but for which the data model is not known at module design time. It is possible, though not required, for the data model for anydata content to become known through protocol signaling or other means that are outside the scope of this document.",
      "ja": "「ANYDATA」文がAnyXMLで除き、YANGでモデル化することができますが、データモデルは、モジュールの設計時に知られていないされているノードの未知の集合を表すために使用されます。これは、プロトコルシグナリングまたはこの文書の範囲外である他の手段によって知られるようになっするANYDATAコンテンツのデータモデルのために、必要ではないが、可能です。"
    },
    {
      "indent": 3,
      "text": "An example of where anydata can be useful is a list of received notifications where the specific notifications are not known at design time.",
      "ja": "ANYDATAが有用であることができる場所の例は、特定の通知が設計時に知られていない受信通知のリストです。"
    },
    {
      "indent": 3,
      "text": "An anydata node cannot be augmented (see Section 7.17).",
      "ja": "ANYDATAノード（セクション7.17を参照）を増強することができません。"
    },
    {
      "indent": 3,
      "text": "An anydata node exists in zero or one instance in the data tree.",
      "ja": "ANYDATAノードは、データツリー内のゼロまたは1つのインスタンス内に存在します。"
    },
    {
      "indent": 3,
      "text": "An implementation may or may not know the data model used to model a specific instance of an anydata node.",
      "ja": "実装は、またはANYDATAノードの特定のインスタンスをモデル化するために使用されるデータモデルを知らなくてもよいです。"
    },
    {
      "indent": 3,
      "text": "Since the use of anydata limits the manipulation of the content, the \"anydata\" statement SHOULD NOT be used to define configuration data.",
      "ja": "ANYDATAの使用は、コンテンツの操作を制限しているので、「ANYDATA」の文は、コンフィギュレーション・データを定義するために使用しないでください。"
    },
    {
      "indent": 0,
      "text": "7.10.1. The anydata's Substatements",
      "section_title": true,
      "ja": "7.10.1.  ANYDATAのサブステートメント"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| config       | 7.21.1  | 0..1        |\n| description  | 7.21.3  | 0..1        |\n| if-feature   | 7.20.2  | 0..n        |\n| mandatory    | 7.6.5   | 0..1        |\n| must         | 7.5.3   | 0..n        |\n| reference    | 7.21.4  | 0..1        |\n| status       | 7.21.2  | 0..1        |\n| when         | 7.21.5  | 0..1        |\n+--------------+---------+-------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.10.2. XML Encoding Rules",
      "section_title": true,
      "ja": "7.10.2.  XML符号化規則"
    },
    {
      "indent": 3,
      "text": "An anydata node is encoded as an XML element. The element's local name is the anydata's identifier, and its namespace is the module's XML namespace (see Section 7.1.3). The value of the anydata node is a set of nodes, which are encoded as XML subelements to the anydata element.",
      "ja": "ANYDATAノードは、XML要素として符号化されます。要素のローカル名は、ANYDATAの識別子であり、その名前空間は、モジュールのXML名前空間（セクション7.1.3を参照）です。 ANYDATAノードの値は、ANYDATA要素にXMLサブ要素として符号化されたノードの集合です。"
    },
    {
      "indent": 0,
      "text": "7.10.3. NETCONF <edit-config> Operations",
      "section_title": true,
      "ja": "7.10.3.  NETCONF <編集-config>の操作"
    },
    {
      "indent": 3,
      "text": "An anydata node is treated as an opaque chunk of data. This data can be modified in its entirety only.",
      "ja": "ANYDATAノードはデータの不透明なチャンクとして処理されます。このデータは、全体的に変更することができます。"
    },
    {
      "indent": 3,
      "text": "Any \"operation\" attributes present on subelements of an anydata node are ignored by the NETCONF server.",
      "ja": "任意の「動作」がNETCONFサーバによって無視されANYDATAノードのサブエレメントに存在する属性。"
    },
    {
      "indent": 3,
      "text": "When a NETCONF server processes an <edit-config> request, the elements of procedure for the anydata node are as follows:",
      "ja": "NETCONFサーバは<編集設定>要求を処理するときに、以下のように、ANYDATAノードの手順の要素は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o If the operation is \"merge\" or \"replace\", the node is created if it does not exist, and its value is set to the subelements of the anydata node found in the XML RPC data.",
      "ja": "操作は「マージ」または「置換」である場合には、O、それが存在しない場合、ノードが作成され、その値は、XML RPCデータで見つかったANYDATAノードの下位要素に設定されています。"
    },
    {
      "indent": 3,
      "text": "o If the operation is \"create\", the node is created if it does not exist, and its value is set to the subelements of the anydata node found in the XML RPC data. If the node already exists, a \"data-exists\" error is returned.",
      "ja": "操作は、「作成」である場合には、O、それが存在しない場合、ノードが作成され、その値は、XML RPCデータで見つかったANYDATAノードの下位要素に設定されています。ノードがすでに存在する場合は、「データが存在する」エラーが返されます。"
    },
    {
      "indent": 3,
      "text": "o If the operation is \"delete\", the node is deleted if it exists. If the node does not exist, a \"data-missing\" error is returned.",
      "ja": "操作は「削除」である場合は、それが存在する場合は、O、ノードが削除されます。ノードが存在しない場合は、「データ・行方不明」エラーが返されます。"
    },
    {
      "indent": 0,
      "text": "7.10.4. Usage Example",
      "section_title": true,
      "ja": "7.10.4. 使用例"
    },
    {
      "indent": 3,
      "text": "Given the following \"anydata\" statement:",
      "ja": "以下の「ANYDATA」の文を考えます："
    },
    {
      "indent": 5,
      "text": "list logged-notification {\n  key time;\n  leaf time {\n    type yang:date-and-time;\n  }\n  anydata data;\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The following is a valid encoding of such a list instance:",
      "ja": "以下は、そのようなリストのインスタンスの有効なエンコーディングです。"
    },
    {
      "indent": 5,
      "text": "<logged-notification> <time>2014-07-29T13:43:12Z</time> <data> <notification xmlns=\"urn:ietf:params:xml:ns:netconf:notification:1.0\"> <eventTime>2014-07-29T13:43:01Z</eventTime> <event xmlns=\"urn:example:event\"> <event-class>fault</event-class> <reporting-entity> <card>Ethernet0</card> </reporting-entity> <severity>major</severity> </event> </notification> </data> </logged-notification>",
      "ja": "<ログイン通知> <時間> 2014-07-29T13：43：12Z </時刻> <データ> <通知のxmlns = \"URN：IETF：paramsは：XML：NS：NETCONF：通知：1.0\"> <イベント時刻> 2014 -07-29T13：43：01Z </イベント時刻> <イベントのxmlns = \"壷：例：イベント\"> <イベント-class>の障害</イベント・クラス> <報告-エンティティ> <カード> Ethernet0に</カード> < /レポーティング・エンティティ> <重要度>主要</重症度> </イベント> </通知> </データ> </ログイン通知>"
    },
    {
      "indent": 0,
      "text": "7.11. The \"anyxml\" Statement",
      "section_title": true,
      "ja": "7.11.  「AnyXMLで」文"
    },
    {
      "indent": 3,
      "text": "The \"anyxml\" statement defines an interior node in the schema tree. It takes one argument, which is an identifier, followed by a block of substatements that holds detailed anyxml information.",
      "ja": "「AnyXMLで」文は、スキーマツリーの内部ノードを定義します。これは、詳細AnyXMLで情報を保持するサブステートメントのブロックが続く識別子であり、一つの引数を取ります。"
    },
    {
      "indent": 3,
      "text": "The \"anyxml\" statement is used to represent an unknown chunk of XML. No restrictions are placed on the XML. This can be useful, for example, in RPC replies. An example is the <filter> parameter in the <get-config> operation in NETCONF.",
      "ja": "「AnyXMLで」文はXMLの未知のチャンクを表すために使用されます。何の制限は、XMLの上に置かれていません。これは、RPCの応答で、例えば、便利です。例では、NETCONFで<GET-config>の操作で<フィルタ>パラメータです。"
    },
    {
      "indent": 3,
      "text": "An anyxml node cannot be augmented (see Section 7.17).",
      "ja": "AnyXMLでノード（セクション7.17を参照）を増強することができません。"
    },
    {
      "indent": 3,
      "text": "An anyxml node exists in zero or one instance in the data tree.",
      "ja": "AnyXMLでノードがデータツリー内のゼロまたは1つのインスタンス内に存在します。"
    },
    {
      "indent": 3,
      "text": "Since the use of anyxml limits the manipulation of the content, the \"anyxml\" statement SHOULD NOT be used to define configuration data.",
      "ja": "AnyXMLでの使用は、コンテンツの操作を制限しているので、「AnyXMLで」文は、コンフィギュレーション・データを定義するために使用しないでください。"
    },
    {
      "indent": 3,
      "text": "It should be noted that in YANG version 1, \"anyxml\" was the only statement that could model an unknown hierarchy of data. In many cases, this unknown hierarchy of data is actually modeled in YANG, but the specific YANG data model is not known at design time. In these situations, it is RECOMMENDED to use \"anydata\" (Section 7.10) instead of \"anyxml\".",
      "ja": "YANGバージョン1で、「AnyXMLでは、」データの未知の階層をモデル化することができる唯一の声明だったことに留意すべきです。多くの場合、データのこの未知の階層は、実際にYANGでモデル化されていますが、特定のYANGデータモデルは、設計時に知られていません。このような状況では、代わりに「AnyXMLで」の「ANYDATA」（7.10）を使用することをお勧めします。"
    },
    {
      "indent": 0,
      "text": "7.11.1. The anyxml's Substatements",
      "section_title": true,
      "ja": "7.11.1.  AnyXMLでのサブステートメント"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| config       | 7.21.1  | 0..1        |\n| description  | 7.21.3  | 0..1        |\n| if-feature   | 7.20.2  | 0..n        |\n| mandatory    | 7.6.5   | 0..1        |\n| must         | 7.5.3   | 0..n        |\n| reference    | 7.21.4  | 0..1        |\n| status       | 7.21.2  | 0..1        |\n| when         | 7.21.5  | 0..1        |\n+--------------+---------+-------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.11.2. XML Encoding Rules",
      "section_title": true,
      "ja": "7.11.2.  XML符号化規則"
    },
    {
      "indent": 3,
      "text": "An anyxml node is encoded as an XML element. The element's local name is the anyxml's identifier, and its namespace is the module's XML namespace (see Section 7.1.3). The value of the anyxml node is encoded as XML content of this element.",
      "ja": "AnyXMLでノードは、XML要素として符号化されます。要素のローカル名はAnyXMLでの識別子であり、その名前空間は、モジュールのXML名前空間（セクション7.1.3を参照）です。 AnyXMLでノードの値は、この要素のXMLコンテンツとして符号化されます。"
    },
    {
      "indent": 3,
      "text": "Note that any XML prefixes used in the encoding are local to each instance encoding. This means that the same XML may be encoded differently by different implementations.",
      "ja": "符号化に使用される任意のXMLプレフィックスは、各インスタンスのエンコーディングに対してローカルであることに留意されたいです。これは、同じXMLは、異なる実装によって異なって符号化することができることを意味します。"
    },
    {
      "indent": 0,
      "text": "7.11.3. NETCONF <edit-config> Operations",
      "section_title": true,
      "ja": "7.11.3.  NETCONF <編集-config>の操作"
    },
    {
      "indent": 3,
      "text": "An anyxml node is treated as an opaque chunk of data. This data can be modified in its entirety only.",
      "ja": "AnyXMLでノードがデータの不透明なチャンクとして処理されます。このデータは、全体的に変更することができます。"
    },
    {
      "indent": 3,
      "text": "Any \"operation\" attributes present on subelements of an anyxml node are ignored by the NETCONF server.",
      "ja": "任意の「動作」がNETCONFサーバによって無視されAnyXMLでノードのサブエレメントに存在する属性。"
    },
    {
      "indent": 3,
      "text": "When a NETCONF server processes an <edit-config> request, the elements of procedure for the anyxml node are as follows:",
      "ja": "NETCONFサーバは<編集設定>要求を処理するときに、以下のように、AnyXMLでノードの手順の要素は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o If the operation is \"merge\" or \"replace\", the node is created if it does not exist, and its value is set to the XML content of the anyxml node found in the XML RPC data.",
      "ja": "操作は「マージ」または「置換」である場合には、O、それが存在しない場合、ノードが作成され、その値は、XML RPCデータで見つかったAnyXMLでノードのXMLコンテンツに設定されています。"
    },
    {
      "indent": 3,
      "text": "o If the operation is \"create\", the node is created if it does not exist, and its value is set to the XML content of the anyxml node found in the XML RPC data. If the node already exists, a \"data-exists\" error is returned.",
      "ja": "操作は、「作成」である場合には、O、それが存在しない場合、ノードが作成され、その値は、XML RPCデータで見つかったAnyXMLでノードのXMLコンテンツに設定されています。ノードがすでに存在する場合は、「データが存在する」エラーが返されます。"
    },
    {
      "indent": 3,
      "text": "o If the operation is \"delete\", the node is deleted if it exists. If the node does not exist, a \"data-missing\" error is returned.",
      "ja": "操作は「削除」である場合は、それが存在する場合は、O、ノードが削除されます。ノードが存在しない場合は、「データ・行方不明」エラーが返されます。"
    },
    {
      "indent": 0,
      "text": "7.11.4. Usage Example",
      "section_title": true,
      "ja": "7.11.4. 使用例"
    },
    {
      "indent": 3,
      "text": "Given the following \"anyxml\" statement:",
      "ja": "以下の「AnyXMLで」文を考えます："
    },
    {
      "indent": 5,
      "text": "anyxml html-info;",
      "ja": "AnyXMLでのhtml-情報。"
    },
    {
      "indent": 3,
      "text": "The following are two valid encodings of the same anyxml value:",
      "ja": "同じAnyXMLで値の2つの有効なエンコーディングは、次のとおりです。"
    },
    {
      "indent": 6,
      "text": "<html-info> <p xmlns=\"http://www.w3.org/1999/xhtml\"> This is <em>very</em> cool. </p> </html-info>",
      "ja": "<HTML-インフォメーション> <p個ののxmlns = \"http://www.w3.org/1999/xhtml\">これは<em>の非常に</ em>のクールです。 </ P> </ htmlの-インフォメーション>"
    },
    {
      "indent": 6,
      "text": "<html-info> <x:p xmlns:x=\"http://www.w3.org/1999/xhtml\"> This is <x:em>very</x:em> cool. </x:p> </html-info>",
      "ja": "<HTML-インフォメーション> <X：Pののxmlns：X = \"http://www.w3.org/1999/xhtml\">これは<X：em>の非常に</ X：em>の涼しいです。 </ X：P> </ htmlの-インフォメーション>"
    },
    {
      "indent": 0,
      "text": "7.12. The \"grouping\" Statement",
      "section_title": true,
      "ja": "7.12.  「グループ化」声明"
    },
    {
      "indent": 3,
      "text": "The \"grouping\" statement is used to define a reusable block of nodes, which may be used locally in the module or submodule, and by other modules that import from it, according to the rules in Section 5.5. It takes one argument, which is an identifier, followed by a block of substatements that holds detailed grouping information.",
      "ja": "「グルーピング」ステートメントは、セクション5.5の規則に従って、モジュール又はサブモジュール、およびそれからインポート他のモジュールによって局所的に使用することができるノードの再利用可能なブロックを定義するために使用されます。これは、詳細なグルーピング情報を保持しているサブステートメントのブロックが続く識別子であり、一つの引数を取ります。"
    },
    {
      "indent": 3,
      "text": "The \"grouping\" statement is not a data definition statement and, as such, does not define any nodes in the schema tree.",
      "ja": "「グループ化」の文は、次のような、スキーマツリーの任意のノードを定義していない、データ定義文ではありませんと。"
    },
    {
      "indent": 3,
      "text": "A grouping is like a \"structure\" or a \"record\" in conventional programming languages.",
      "ja": "グルーピングは、「構造」または従来のプログラミング言語で「記録」のようなものです。"
    },
    {
      "indent": 3,
      "text": "Once a grouping is defined, it can be referenced in a \"uses\" statement (see Section 7.13). A grouping MUST NOT reference itself, neither directly nor indirectly through a chain of other groupings.",
      "ja": "グループが定義されると、それは「使用する」文で参照することができます（セクション7.13を参照してください）。グループ化は、他のグループのチェーンを介しても直接でも間接的に自分自身を参照してはなりません。"
    },
    {
      "indent": 3,
      "text": "If the grouping is defined at the top level of a YANG module or submodule, the grouping's identifier MUST be unique within the module.",
      "ja": "グルーピングがYANGモジュールまたはサブモジュールのトップレベルで定義されている場合、グループの識別子は、モジュール内で一意でなければなりません。"
    },
    {
      "indent": 3,
      "text": "A grouping is more than just a mechanism for textual substitution; it also defines a collection of nodes. Identifiers appearing inside the grouping are resolved relative to the scope in which the grouping is defined, not where it is used. Prefix mappings, type names, grouping names, and extension usage are evaluated in the hierarchy where the \"grouping\" statement appears. For extensions, this means that extensions defined as direct children to a \"grouping\" statement are applied to the grouping itself.",
      "ja": "グループ分けは、テキスト置換のための単なるメカニズム以上のものです。それはまた、ノードのコレクションを定義します。グルーピング内部に現れる識別子は、グループが定義されている、ではない、それがどこで使用される範囲に対して解決されます。プレフィックスのマッピング、タイプ名、グループ名、および拡張の使用量は、「グループ化」文が表示された階層で評価されています。拡張機能の場合、これは「グループ化」ステートメントに直接の子として定義された拡張機能がグループ自体に適用されることを意味します。"
    },
    {
      "indent": 3,
      "text": "Note that if a grouping defines an action or a notification node in its hierarchy, then it cannot be used in all contexts. For example, it cannot be used in an rpc definition. See Sections 7.15 and 7.16.",
      "ja": "グルーピングは、その階層内のアクションまたは通知ノードを定義する場合、それはすべてのコンテキストで使用することができないことに留意されたいです。例えば、それは、RPC定義で使用することはできません。セクション7.15と7.16を参照してください。"
    },
    {
      "indent": 0,
      "text": "7.12.1. The grouping's Substatements",
      "section_title": true,
      "ja": "7.12.1. グループのサブステートメント"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| action       | 7.15    | 0..n        |\n| anydata      | 7.10    | 0..n        |\n| anyxml       | 7.11    | 0..n        |\n| choice       | 7.9     | 0..n        |\n| container    | 7.5     | 0..n        |\n| description  | 7.21.3  | 0..1        |\n| grouping     | 7.12    | 0..n        |\n| leaf         | 7.6     | 0..n        |\n| leaf-list    | 7.7     | 0..n        |\n| list         | 7.8     | 0..n        |\n| notification | 7.16    | 0..n        |\n| reference    | 7.21.4  | 0..1        |\n| status       | 7.21.2  | 0..1        |\n| typedef      | 7.3     | 0..n        |\n| uses         | 7.13    | 0..n        |\n+--------------+---------+-------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.12.2. Usage Example",
      "section_title": true,
      "ja": "7.12.2. 使用例"
    },
    {
      "indent": 5,
      "text": "import ietf-inet-types {\n  prefix \"inet\";\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "grouping endpoint {\n  description \"A reusable endpoint group.\";\n  leaf ip {\n    type inet:ip-address;\n  }\n  leaf port {\n    type inet:port-number;\n  }\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.13. The \"uses\" Statement",
      "section_title": true,
      "ja": "7.13. 文「を使用しています」"
    },
    {
      "indent": 3,
      "text": "The \"uses\" statement is used to reference a \"grouping\" definition. It takes one argument, which is the name of the grouping.",
      "ja": "声明は、「グループ化」の定義を参照するために使用され、「使用しています」。これは、グループの名前を1つの引数を取ります。"
    },
    {
      "indent": 3,
      "text": "The effect of a \"uses\" reference to a grouping is that the nodes defined by the grouping are copied into the current schema tree and are then updated according to the \"refine\" and \"augment\" statements.",
      "ja": "グループへの参照を「使用」の効果は、グループによって定義されたノードが現在のスキーマ・ツリーにコピーされ、その後、「絞り込み」及び「増強」ステートメントに応じて更新されることです。"
    },
    {
      "indent": 3,
      "text": "The identifiers defined in the grouping are not bound to a namespace until the contents of the grouping are added to the schema tree via a \"uses\" statement that does not appear inside a \"grouping\" statement, at which point they are bound to the namespace of the current module.",
      "ja": "グループ分けの内容がスキーマツリーに追加されるまで、グループで定義された識別子は、それらが名前空間にバインドされた時点で、「グループ化」文の中に表示されない文を、「使用する」を経由して名前空間にバインドされていません現在のモジュールの。"
    },
    {
      "indent": 0,
      "text": "7.13.1. The uses's Substatements",
      "section_title": true,
      "ja": "7.13.1. 用途のサブステートメント"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| augment      | 7.17    | 0..n        |\n| description  | 7.21.3  | 0..1        |\n| if-feature   | 7.20.2  | 0..n        |\n| reference    | 7.21.4  | 0..1        |\n| refine       | 7.13.2  | 0..n        |\n| status       | 7.21.2  | 0..1        |\n| when         | 7.21.5  | 0..1        |\n+--------------+---------+-------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.13.2. The \"refine\" Statement",
      "section_title": true,
      "ja": "7.13.2.  「洗練」声明"
    },
    {
      "indent": 3,
      "text": "Some of the properties of each node in the grouping can be refined with the \"refine\" statement. The argument is a string that identifies a node in the grouping. This node is called the refine's target node. If a node in the grouping is not present as a target node of a \"refine\" statement, it is not refined and thus is used exactly as it was defined in the grouping.",
      "ja": "グループ内の各ノードのプロパティの一部は、「洗練」声明で精製することができます。引数は、グループ内のノードを識別する文字列です。このノードは、絞り込みの対象ノードと呼ばれています。グループ内のノードは、「絞り込み」ステートメントのターゲットノードとして存在しない場合、それが精製されていないので、それはグループで定義されたとおりに使用されています。"
    },
    {
      "indent": 3,
      "text": "The argument string is a descendant schema node identifier (see Section 6.5).",
      "ja": "引数文字列が子孫スキーマノード識別子（セクション6.5を参照）です。"
    },
    {
      "indent": 3,
      "text": "The following refinements can be done:",
      "ja": "以下の改良を行うことができます。"
    },
    {
      "indent": 3,
      "text": "o A leaf or choice node may get a default value, or a new default value if it already had one.",
      "ja": "それは既に1を持っていた場合、O葉または選択ノードには、デフォルト値、または新しいデフォルト値を得ることができます。"
    },
    {
      "indent": 3,
      "text": "o A leaf-list node may get a set of default values, or a new set of default values if it already had defaults; i.e., the set of refined default values replaces the defaults already given.",
      "ja": "Oリーフリストノードは、デフォルト値のセット、またはそれがすでにデフォルトを持っていた場合は、デフォルト値の新しいセットを得ることができます。つまりは、洗練されたデフォルト値のセットは、すでに与えられたデフォルト値を置き換えます。"
    },
    {
      "indent": 3,
      "text": "o Any node may get a specialized \"description\" string.",
      "ja": "O任意のノードは、専用の「説明」の文字列を取得することがあります。"
    },
    {
      "indent": 3,
      "text": "o Any node may get a specialized \"reference\" string.",
      "ja": "O任意のノードは、専用の「参照」の文字列を取得することがあります。"
    },
    {
      "indent": 3,
      "text": "o Any node may get a different \"config\" statement.",
      "ja": "O任意のノードは異なる「設定」の文を得ることができます。"
    },
    {
      "indent": 3,
      "text": "o A leaf, anydata, anyxml, or choice node may get a different \"mandatory\" statement.",
      "ja": "O葉、ANYDATA、AnyXMLで、または選択ノードが異なる「必須」の文を得ることができます。"
    },
    {
      "indent": 3,
      "text": "o A container node may get a \"presence\" statement.",
      "ja": "Oコンテナノードは、「プレゼンス」の文を得ることができます。"
    },
    {
      "indent": 3,
      "text": "o A leaf, leaf-list, list, container, anydata, or anyxml node may get additional \"must\" expressions.",
      "ja": "葉、葉、リスト、リスト、コンテナ、ANYDATA、またはAnyXMLでノードoを追加「しなければならない」の表現を得ることができます。"
    },
    {
      "indent": 3,
      "text": "o A leaf-list or list node may get a different \"min-elements\" or \"max-elements\" statement.",
      "ja": "Oリーフリストまたはリストのノードが異なる「MIN-要素」または「MAX-要素」文を得ることができます。"
    },
    {
      "indent": 3,
      "text": "o A leaf, leaf-list, list, container, choice, case, anydata, or anyxml node may get additional \"if-feature\" expressions.",
      "ja": "葉、葉、リスト、リスト、コンテナ、選択、ケース、ANYDATA O、またはAnyXMLでノードが追加の「IF-機能」の表現を得ることができます。"
    },
    {
      "indent": 3,
      "text": "o Any node can get refined extensions, if the extension allows refinement. See Section 7.19 for details.",
      "ja": "拡張子が洗練を許可する場合、O、任意のノードは、洗練された機能拡張を得ることができます。詳細については、セクション7.19を参照してください。"
    },
    {
      "indent": 0,
      "text": "7.13.3. XML Encoding Rules",
      "section_title": true,
      "ja": "7.13.3.  XML符号化規則"
    },
    {
      "indent": 3,
      "text": "Each node in the grouping is encoded as if it was defined inline, even if it is imported from another module with another XML namespace.",
      "ja": "それはインラインで定義されたかのようにグループ内の各ノードは、それが別のXML名前空間を持つ別のモジュールからインポートされた場合でも、符号化されます。"
    },
    {
      "indent": 0,
      "text": "7.13.4. Usage Example",
      "section_title": true,
      "ja": "7.13.4. 使用例"
    },
    {
      "indent": 3,
      "text": "To use the \"endpoint\" grouping defined in Section 7.12.2 in a definition of an HTTP server in some other module, we can do:",
      "ja": "グループ化するいくつかの他のモジュール内のHTTPサーバの定義にセクション7.12.2で定義された「エンドポイント」を使用するには、我々は行うことができます。"
    },
    {
      "indent": 5,
      "text": "import example-system { prefix \"sys\"; }",
      "ja": "例えば、システム{接頭辞「SYS」を読み込みます。 }"
    },
    {
      "indent": 5,
      "text": "container http-server {\n  leaf name {\n    type string;\n  }\n  uses sys:endpoint;\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A corresponding XML instance example:",
      "ja": "対応するXMLインスタンスの例："
    },
    {
      "indent": 5,
      "text": "<http-server> <name>extern-web</name> <ip>192.0.2.1</ip> <port>80</port> </http-server>",
      "ja": "<HTTPサーバ> <名前>はextern-ウェブ</名前> <IP> 192.0.2.1 </ IP> <ポート> 80 </ポート> </ HTTPサーバ>"
    },
    {
      "indent": 3,
      "text": "If port 80 should be the default for the HTTP server, a default can be added:",
      "ja": "ポート80はHTTPサーバのデフォルトにする必要がある場合は、デフォルトでは、追加することができます。"
    },
    {
      "indent": 5,
      "text": "container http-server {\n  leaf name {\n    type string;\n  }\n  uses sys:endpoint {\n    refine port {\n      default 80;\n    }\n  }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "If we want to define a list of servers and each server has \"ip\" and \"port\" as keys, we can do:",
      "ja": "私たちは、サーバのリストを定義したいと、各サーバは、「IP」とキーとして「ポート」を持っている場合、我々は行うことができます。"
    },
    {
      "indent": 5,
      "text": "list server {\n  key \"ip port\";\n  leaf name {\n    type string;\n  }\n  uses sys:endpoint;\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The following is an error:",
      "ja": "次はエラーです。"
    },
    {
      "indent": 5,
      "text": "container http-server {\n  uses sys:endpoint;\n  leaf ip {          // illegal - same identifier \"ip\" used twice\n    type string;\n  }\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.14. The \"rpc\" Statement",
      "section_title": true,
      "ja": "7.14.  「RPC」声明"
    },
    {
      "indent": 3,
      "text": "The \"rpc\" statement is used to define an RPC operation. It takes one argument, which is an identifier, followed by a block of substatements that holds detailed rpc information. This argument is the name of the RPC.",
      "ja": "「RPC」文がRPC操作を定義するために使用されます。これは、詳細なRPC情報を保持するサブステートメントのブロックが続く識別子であり、一つの引数を取ります。この引数は、RPCの名前です。"
    },
    {
      "indent": 3,
      "text": "The \"rpc\" statement defines an rpc node in the schema tree. Under the rpc node, a schema node with the name \"input\" and a schema node with the name \"output\" are also defined. The nodes \"input\" and \"output\" are defined in the module's namespace.",
      "ja": "「RPC」の文は、スキーマツリー内のRPCノードを定義します。 RPCノードの下に、名前「入力」及び名前「出力」のスキーマノードとスキーマノードは、定義されています。ノード「入力」と「出力」は、モジュールの名前空間で定義されています。"
    },
    {
      "indent": 0,
      "text": "7.14.1. The rpc's Substatements",
      "section_title": true,
      "ja": "7.14.1.  RPCのサブステートメント"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| description  | 7.21.3  | 0..1        |\n| grouping     | 7.12    | 0..n        |\n| if-feature   | 7.20.2  | 0..n        |\n| input        | 7.14.2  | 0..1        |\n| output       | 7.14.3  | 0..1        |\n| reference    | 7.21.4  | 0..1        |\n| status       | 7.21.2  | 0..1        |\n| typedef      | 7.3     | 0..n        |\n+--------------+---------+-------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.14.2. The \"input\" Statement",
      "section_title": true,
      "ja": "7.14.2.  「入力」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"input\" statement, which is optional, is used to define input parameters to the operation. It does not take an argument. The substatements to \"input\" define nodes under the operation's input node.",
      "ja": "オプションである「入力」ステートメントは、操作の入力パラメータを定義するために使用されます。これは、引数を取りません。サブステートメントは、「入力」は、操作者の入力ノードの下のノードを定義します。"
    },
    {
      "indent": 3,
      "text": "If a leaf in the input tree has a \"mandatory\" statement with the value \"true\", the leaf MUST be present in an RPC invocation.",
      "ja": "入力ツリーのリーフが値「真」と「必須」の文を持っている場合、葉は、RPCの呼び出し中に存在しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If a leaf in the input tree has a default value, the server MUST use this value in the same cases as those described in Section 7.6.1. In these cases, the server MUST operationally behave as if the leaf was present in the RPC invocation with the default value as its value.",
      "ja": "入力ツリーのリーフは、デフォルト値を持っている場合、サーバは7.6.1項で説明したものと同じ場合に、この値を使用する必要があります。これらのケースでは、サーバが運用葉がその値としてデフォルト値を持つRPC呼び出しに存在したかのように振る舞う必要があります。"
    },
    {
      "indent": 3,
      "text": "If a leaf-list in the input tree has one or more default values, the server MUST use these values in the same cases as those described in Section 7.7.2. In these cases, the server MUST operationally behave as if the leaf-list was present in the RPC invocation with the default values as its values.",
      "ja": "入力ツリーのリーフリストは、1つまたは複数のデフォルト値を持っている場合、サーバは7.7.2項で説明したものと同じ例で、これらの値を使用しなければなりません。これらのケースでは、サーバが運用リーフリストは、その値としてデフォルト値でRPC呼び出しに存在したかのように振る舞う必要があります。"
    },
    {
      "indent": 3,
      "text": "Since the input tree is not part of any datastore, all \"config\" statements for nodes in the input tree are ignored.",
      "ja": "入力ツリーは任意のデータストアの一部ではないので、入力ツリー内のノードに対する全ての「設定」の文は無視されます。"
    },
    {
      "indent": 3,
      "text": "If any node has a \"when\" statement that would evaluate to \"false\", then this node MUST NOT be present in the input tree.",
      "ja": "いずれかのノードが「偽」と評価されてしまうからです「と、」ステートメントを持っている場合、このノードは入力ツリーに存在してはなりません。"
    },
    {
      "indent": 0,
      "text": "7.14.2.1. The input's Substatements",
      "section_title": true,
      "ja": "7.14.2.1。入力のサブステートメント"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| anydata      | 7.10    | 0..n        |\n| anyxml       | 7.11    | 0..n        |\n| choice       | 7.9     | 0..n        |\n| container    | 7.5     | 0..n        |\n| grouping     | 7.12    | 0..n        |\n| leaf         | 7.6     | 0..n        |\n| leaf-list    | 7.7     | 0..n        |\n| list         | 7.8     | 0..n        |\n| must         | 7.5.3   | 0..n        |\n| typedef      | 7.3     | 0..n        |\n| uses         | 7.13    | 0..n        |\n+--------------+---------+-------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.14.3. The \"output\" Statement",
      "section_title": true,
      "ja": "7.14.3.  「出力」声明"
    },
    {
      "indent": 3,
      "text": "The \"output\" statement, which is optional, is used to define output parameters to the RPC operation. It does not take an argument. The substatements to \"output\" define nodes under the operation's output node.",
      "ja": "オプションである「出力」文は、RPC操作に出力パラメータを定義するために使用されます。これは、引数を取りません。 「出力」へのサブステートメントは、操作の出力ノードの下のノードを定義します。"
    },
    {
      "indent": 3,
      "text": "If a leaf in the output tree has a \"mandatory\" statement with the value \"true\", the leaf MUST be present in an RPC reply.",
      "ja": "出力ツリーのリーフが値「真」と「必須」の文を持っている場合は、葉がRPC応答中に存在しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If a leaf in the output tree has a default value, the client MUST use this value in the same cases as those described in Section 7.6.1. In these cases, the client MUST operationally behave as if the leaf was present in the RPC reply with the default value as its value.",
      "ja": "出力ツリーのリーフは、デフォルト値を持っている場合、クライアントは、7.6.1項で説明したものと同じ場合に、この値を使用する必要があります。これらのケースでは、クライアントは、運用上の葉は、その値としてデフォルト値を持つRPC応答に存在したかのように振る舞う必要があります。"
    },
    {
      "indent": 3,
      "text": "If a leaf-list in the output tree has one or more default values, the client MUST use these values in the same cases as those described in Section 7.7.2. In these cases, the client MUST operationally behave as if the leaf-list was present in the RPC reply with the default values as its values.",
      "ja": "出力ツリーのリーフリストは、1つまたは複数のデフォルト値を持っている場合、クライアントは、7.7.2項で説明したものと同じ例で、これらの値を使用しなければなりません。これらのケースでは、クライアントは、運用リーフリストは、その値としてデフォルト値でRPC応答に存在したかのように振る舞う必要があります。"
    },
    {
      "indent": 3,
      "text": "Since the output tree is not part of any datastore, all \"config\" statements for nodes in the output tree are ignored.",
      "ja": "出力ツリーは、任意のデータストアの一部ではないので、出力ツリー内のノードのためのすべての「設定」の文は無視されます。"
    },
    {
      "indent": 3,
      "text": "If any node has a \"when\" statement that would evaluate to \"false\", then this node MUST NOT be present in the output tree.",
      "ja": "いずれかのノードが「偽」と評価されてしまうからです「と、」ステートメントを持っている場合、このノードは、出力ツリーに存在してはなりません。"
    },
    {
      "indent": 0,
      "text": "7.14.3.1. The output's Substatements",
      "section_title": true,
      "ja": "7.14.3.1。出力のサブステートメント"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| anydata      | 7.10    | 0..n        |\n| anyxml       | 7.11    | 0..n        |\n| choice       | 7.9     | 0..n        |\n| container    | 7.5     | 0..n        |\n| grouping     | 7.12    | 0..n        |\n| leaf         | 7.6     | 0..n        |\n| leaf-list    | 7.7     | 0..n        |\n| list         | 7.8     | 0..n        |\n| must         | 7.5.3   | 0..n        |\n| typedef      | 7.3     | 0..n        |\n| uses         | 7.13    | 0..n        |\n+--------------+---------+-------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.14.4. NETCONF XML Encoding Rules",
      "section_title": true,
      "ja": "7.14.4.  NETCONF XML符号化規則"
    },
    {
      "indent": 3,
      "text": "An rpc node is encoded as a child XML element to the <rpc> element, as designated by the substitution group \"rpcOperation\" in [RFC6241]. The element's local name is the rpc's identifier, and its namespace is the module's XML namespace (see Section 7.1.3).",
      "ja": "[RFC6241]に置換基「rpcOperation」によって指定されたRPCノードは、<RPC>要素の子のXML要素として符号化されます。要素のローカル名は、RPCの識別子であり、その名前空間は、モジュールのXML名前空間（セクション7.1.3を参照）です。"
    },
    {
      "indent": 3,
      "text": "Input parameters are encoded as child XML elements to the rpc node's XML element, in the same order as they are defined within the \"input\" statement.",
      "ja": "入力パラメータは、それらが「入力」ステートメント内に定義されているのと同じ順序で、RPCノードのXML要素の子のXML要素としてエンコードされています。"
    },
    {
      "indent": 3,
      "text": "If the RPC operation invocation succeeded and no output parameters are returned, the <rpc-reply> contains a single <ok/> element defined in [RFC6241]. If output parameters are returned, they are encoded as child elements to the <rpc-reply> element defined in [RFC6241], in the same order as they are defined within the \"output\" statement.",
      "ja": "RPC操作呼び出しが成功しない出力パラメータが返されない場合は、<RPC返信>は、[RFC6241]で定義された単一の<OK />要素を含んでいます。出力パラメータが返された場合、それらはそれらが「出力」ステートメント内で定義されているのと同じ順序で、[RFC6241]で定義された<RPC返信>要素の子要素として符号化されます。"
    },
    {
      "indent": 0,
      "text": "7.14.5. Usage Example",
      "section_title": true,
      "ja": "7.14.5. 使用例"
    },
    {
      "indent": 3,
      "text": "The following example defines an RPC operation:",
      "ja": "次の例は、RPCの動作を定義します。"
    },
    {
      "indent": 5,
      "text": "module example-rock {\n  yang-version 1.1;\n  namespace \"urn:example:rock\";\n  prefix \"rock\";",
      "raw": true
    },
    {
      "indent": 5,
      "text": " rpc rock-the-house { input { leaf zip-code { type string; } } } }",
      "ja": "RPCロック・ハウス{入力{葉ジップコード{string型。 }}}}"
    },
    {
      "indent": 3,
      "text": "A corresponding XML instance example of the complete rpc and rpc-reply:",
      "ja": "完全RPCおよびRPC-応答の対応するXMLインスタンスの例："
    },
    {
      "indent": 5,
      "text": "<rpc message-id=\"101\" xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\"> <rock-the-house xmlns=\"urn:example:rock\"> <zip-code>27606-0100</zip-code> </rock-the-house> </rpc>",
      "ja": "<RPCメッセージID = \"101\" のxmlns = \"URN：IETF：paramsは：XML：NS：NETCONF：塩基：1.0\"> <ロック・ハウスのxmlns = \"URN：例：ロック\"> <郵便番号> 27606-0100 </郵便番号> </ロック・ハウス> </ RPC>"
    },
    {
      "indent": 5,
      "text": "<rpc-reply message-id=\"101\" xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\"> <ok/> </rpc-reply>",
      "ja": "<RPC応答メッセージ-ID = \"101\" のxmlns = \"URN：IETF：paramsは：XML：NS：NETCONF：塩基：1.0\"> <OK /> </ RPC返信>"
    },
    {
      "indent": 0,
      "text": "7.15. The \"action\" Statement",
      "section_title": true,
      "ja": "7.15.  「アクション」声明"
    },
    {
      "indent": 3,
      "text": "The \"action\" statement is used to define an operation connected to a specific container or list data node. It takes one argument, which is an identifier, followed by a block of substatements that holds detailed action information. The argument is the name of the action.",
      "ja": "「アクション」ステートメントは、特定のコンテナまたはリストデータノードに接続された操作を定義するために使用されます。なお、詳細な動作情報を保持するサブステートメントのブロックが続く識別子であり、一つの引数を取ります。引数は、アクションの名前です。"
    },
    {
      "indent": 3,
      "text": "The \"action\" statement defines an action node in the schema tree. Under the action node, a schema node with the name \"input\" and a schema node with the name \"output\" are also defined. The nodes \"input\" and \"output\" are defined in the module's namespace.",
      "ja": "「アクション」の文は、スキーマツリー内のアクションノードを定義します。アクションノードの下に、名前「入力」と名の「出力」を持つスキーマノードを持つスキーマノードにも定義されています。ノード「入力」と「出力」は、モジュールの名前空間で定義されています。"
    },
    {
      "indent": 3,
      "text": "An action MUST NOT be defined within an rpc, another action, or a notification, i.e., an action node MUST NOT have an rpc, action, or a notification node as one of its ancestors in the schema tree. For example, this means that it is an error if a grouping that contains an action somewhere in its node hierarchy is used in a notification definition.",
      "ja": "アクションRPC内で定義されてはいけません、他のアクション、または通知は、すなわち、アクション・ノードは、スキーマ・ツリー内のその祖先の1つとして、RPC、アクション、または通知のノードを有してはなりません。例えば、これは、そのノードの階層内のどこかにアクションを含むグループが通知定義で使用される場合、それは誤りであることを意味します。"
    },
    {
      "indent": 3,
      "text": "An action MUST NOT have any ancestor node that is a list node without a \"key\" statement.",
      "ja": "アクションは、「キー」の文のないリストノードである任意の先祖ノードを持つことはできません。"
    },
    {
      "indent": 3,
      "text": "Since an action cannot be defined at the top level of a module or in a \"case\" statement, it is an error if a grouping that contains an action at the top of its node hierarchy is used at the top level of a module or in a case definition.",
      "ja": "動作は、モジュールの最上位レベルまたは「ケース」文で定義することができないため、そのノード階層の最上部にアクションを含むグループが、モジュールの最上位レベルまたはで使用される場合、それは誤りであります症例定義。"
    },
    {
      "indent": 3,
      "text": "The difference between an action and an rpc is that an action is tied to a node in the datastore, whereas an rpc is not. When an action is invoked, the node in the datastore is specified along with the name of the action and the input parameters.",
      "ja": "アクションとRPCの間の差は、RPCではないのに対し、アクションが、データストア内のノードに接続されることです。アクションが呼び出されたとき、データストア内のノードは、アクションの名前と、入力パラメータと共に指定されています。"
    },
    {
      "indent": 0,
      "text": "7.15.1. The action's Substatements",
      "section_title": true,
      "ja": "7.15.1. アクションのサブステートメント"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| description  | 7.21.3  | 0..1        |\n| grouping     | 7.12    | 0..n        |\n| if-feature   | 7.20.2  | 0..n        |\n| input        | 7.14.2  | 0..1        |\n| output       | 7.14.3  | 0..1        |\n| reference    | 7.21.4  | 0..1        |\n| status       | 7.21.2  | 0..1        |\n| typedef      | 7.3     | 0..n        |\n+--------------+---------+-------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.15.2. NETCONF XML Encoding Rules",
      "section_title": true,
      "ja": "7.15.2.  NETCONF XML符号化規則"
    },
    {
      "indent": 3,
      "text": "When an action is invoked, an element with the local name \"action\" in the namespace \"urn:ietf:params:xml:ns:yang:1\" (see Section 5.3.1) is encoded as a child XML element to the <rpc> element defined in [RFC6241], as designated by the substitution group \"rpcOperation\" in [RFC6241].",
      "ja": "アクションが呼び出されると、ローカル名、名前空間における「アクション」を持つ要素「壷：IETF：のparams：XML：NS：陽：1」は、子XML要素としてエンコードされた（5.3.1項を参照してください）< RPC> [RFC6241]に置換基 \"rpcOperation\" によって指定されたように[RFC6241]で定義された要素を、。"
    },
    {
      "indent": 3,
      "text": "The <action> element contains a hierarchy of nodes that identifies the node in the datastore. It MUST contain all containers and list nodes in the direct path from the top level down to the list or container containing the action. For lists, all key leafs MUST also be included. The innermost container or list contains an XML element that carries the name of the defined action. Within this element, the input parameters are encoded as child XML elements, in the same order as they are defined within the \"input\" statement.",
      "ja": "<action>要素は、データストア内のノードを識別するノードの階層を含んでいます。それはアクションを含むリストまたは容器までトップレベルからの直接経路内のすべてのコンテナとリストノードを含まなければなりません。リストでは、すべてのキーのリーフも含まれなければなりません。最も内側の容器またはリストは、定義されたアクションの名前を運ぶXML要素が含まれています。この要素内では、入力パラメータは、それらが「入力」ステートメント内に定義されているのと同じ順序で、子XML要素としてエンコードされています。"
    },
    {
      "indent": 3,
      "text": "Only one action can be invoked in one <rpc>. If more than one action is present in the <rpc>, the server MUST reply with a \"bad-element\" <error-tag> in the <rpc-error>.",
      "ja": "唯一のアクションは、1 <RPC>で呼び出すことができます。複数のアクションが中に存在している場合は、<RPC>、<RPCエラー>に「悪い要素」<エラータグ>で応答しなければならないサーバー。"
    },
    {
      "indent": 3,
      "text": "If the action operation invocation succeeded and no output parameters are returned, the <rpc-reply> contains a single <ok/> element defined in [RFC6241]. If output parameters are returned, they are encoded as child elements to the <rpc-reply> element defined in [RFC6241], in the same order as they are defined within the \"output\" statement.",
      "ja": "アクション操作の呼び出しが成功しない出力パラメータが返されない場合は、<RPC返信>は、[RFC6241]で定義された単一の<OK />要素を含んでいます。出力パラメータが返された場合、それらはそれらが「出力」ステートメント内で定義されているのと同じ順序で、[RFC6241]で定義された<RPC返信>要素の子要素として符号化されます。"
    },
    {
      "indent": 0,
      "text": "7.15.3. Usage Example",
      "section_title": true,
      "ja": "7.15.3. 使用例"
    },
    {
      "indent": 3,
      "text": "The following example defines an action to reset one server at a server farm:",
      "ja": "次の例では、サーバファームにあるサーバーをリセットするアクションを定義しています。"
    },
    {
      "indent": 5,
      "text": "module example-server-farm {\n  yang-version 1.1;\n  namespace \"urn:example:server-farm\";\n  prefix \"sfarm\";",
      "raw": true
    },
    {
      "indent": 7,
      "text": "import ietf-yang-types { prefix \"yang\"; }",
      "ja": "インポートIETF-ヤン・タイプ{接頭辞「陽」。 }"
    },
    {
      "indent": 6,
      "text": " list server {\n   key name;\n   leaf name {\n     type string;\n   }\n   action reset {\n     input {\n       leaf reset-at {\n         type yang:date-and-time;\n         mandatory true;\n        }\n      }\n      output {\n        leaf reset-finished-at {\n          type yang:date-and-time;\n          mandatory true;\n        }\n      }\n    }\n  }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A corresponding XML instance example of the complete rpc and rpc-reply:",
      "ja": "完全RPCおよびRPC-応答の対応するXMLインスタンスの例："
    },
    {
      "indent": 5,
      "text": "<rpc message-id=\"101\" xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\"> <action xmlns=\"urn:ietf:params:xml:ns:yang:1\"> <server xmlns=\"urn:example:server-farm\"> <name>apache-1</name> <reset> <reset-at>2014-07-29T13:42:00Z</reset-at> </reset> </server> </action> </rpc>",
      "ja": "<RPCメッセージID = \"101\" のxmlns = \"URN：IETF：paramsは：XML：NS：NETCONF：塩基：1.0\"> <アクションのxmlns = \"URN：IETF：paramsは：XML：NS：陽：1\"> <サーバのxmlns = \"URN：例：サーバファーム\"> <名前>はApache-1 </名前> <リセット> <リセット時> 2014-07-29T13：42：00Z </リセット時> </リセット> </サーバー> </アクション> </ RPC>"
    },
    {
      "indent": 5,
      "text": "<rpc-reply message-id=\"101\" xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\"> <reset-finished-at xmlns=\"urn:example:server-farm\"> 2014-07-29T13:42:12Z </reset-finished-at> </rpc-reply>",
      "ja": "<RPC応答メッセージ-ID = \"101\" のxmlns = \"URN：IETF：paramsは：XML：NS：NETCONF：塩基：1.0\"> <リセット完成時のxmlns = \"URN：例：サーバファーム\"> 2014 -07-29T13：42：12Z </リセット終了-で> </ RPC返信>"
    },
    {
      "indent": 0,
      "text": "7.16. The \"notification\" Statement",
      "section_title": true,
      "ja": "7.16.  「通知」声明"
    },
    {
      "indent": 3,
      "text": "The \"notification\" statement is used to define a notification. It takes one argument, which is an identifier, followed by a block of substatements that holds detailed notification information. The \"notification\" statement defines a notification node in the schema tree.",
      "ja": "「通知」の文は、通知を定義するために使用されます。これは、詳細な通知情報を保持しているサブステートメントのブロックが続く識別子であり、一つの引数を取ります。 「通知」の文は、スキーマツリーに通知ノードを定義します。"
    },
    {
      "indent": 3,
      "text": "A notification can be defined at the top level of a module, or connected to a specific container or list data node in the schema tree.",
      "ja": "通知は、モジュールのトップレベルで定義された、またはスキーマ・ツリー内の特定のコンテナまたはリストデータノードに接続することができます。"
    },
    {
      "indent": 3,
      "text": "A notification MUST NOT be defined within an rpc, action, or another notification, i.e., a notification node MUST NOT have an rpc, action, or a notification node as one of its ancestors in the schema tree. For example, this means that it is an error if a grouping that contains a notification somewhere in its node hierarchy is used in an rpc definition.",
      "ja": "通知は、RPC、アクション、あるいは別の通知内で定義されてはいけません、すなわち、通知ノードは、スキーマ・ツリー内のその祖先の1つとして、RPC、アクション、または通知のノードを有してはなりません。例えば、これは、そのノードの階層内のどこかの通知が含まグルーピングは、RPC定義で使用される場合、それは誤りであることを意味します。"
    },
    {
      "indent": 3,
      "text": "A notification MUST NOT have any ancestor node that is a list node without a \"key\" statement.",
      "ja": "通知は、「キー」の文のないリストノードである任意の先祖ノードを持つことはできません。"
    },
    {
      "indent": 3,
      "text": "Since a notification cannot be defined in a \"case\" statement, it is an error if a grouping that contains a notification at the top of its node hierarchy is used in a case definition.",
      "ja": "通知は「ケース」文で定義することができないため、そのノード階層の最上部に通知が含まれているグループは、ケースの定義で使用される場合、それはエラーです。"
    },
    {
      "indent": 3,
      "text": "If a leaf in the notification tree has a \"mandatory\" statement with the value \"true\", the leaf MUST be present in a notification instance.",
      "ja": "通知ツリーのリーフが値「真」と「必須」の文を持っている場合は、葉が通知インスタンス中に存在しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If a leaf in the notification tree has a default value, the client MUST use this value in the same cases as those described in Section 7.6.1. In these cases, the client MUST operationally behave as if the leaf was present in the notification instance with the default value as its value.",
      "ja": "通知ツリーのリーフは、デフォルト値を持っている場合、クライアントは、7.6.1項で説明したものと同じ場合に、この値を使用する必要があります。これらのケースでは、クライアントは、運用上の葉は、その値として、デフォルト値で通知インスタンスに存在したかのように振る舞う必要があります。"
    },
    {
      "indent": 3,
      "text": "If a leaf-list in the notification tree has one or more default values, the client MUST use these values in the same cases as those described in Section 7.7.2. In these cases, the client MUST operationally behave as if the leaf-list was present in the notification instance with the default values as its values.",
      "ja": "通知ツリーのリーフリストは、1つまたは複数のデフォルト値を持っている場合、クライアントは、7.7.2項で説明したものと同じ例で、これらの値を使用しなければなりません。これらのケースでは、クライアントは、運用リーフリストは、その値としてデフォルト値で通知インスタンスに存在したかのように振る舞う必要があります。"
    },
    {
      "indent": 3,
      "text": "Since the notification tree is not part of any datastore, all \"config\" statements for nodes in the notification tree are ignored.",
      "ja": "通知ツリーは任意のデータストアの一部ではないので、通知ツリー内のノードに対する全ての「設定」の文は無視されます。"
    },
    {
      "indent": 0,
      "text": "7.16.1. The notification's Substatements",
      "section_title": true,
      "ja": "7.16.1. 通知のサブステートメント"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| anydata      | 7.10    | 0..n        |\n| anyxml       | 7.11    | 0..n        |\n| choice       | 7.9     | 0..n        |\n| container    | 7.5     | 0..n        |\n| description  | 7.21.3  | 0..1        |\n| grouping     | 7.12    | 0..n        |\n| if-feature   | 7.20.2  | 0..n        |\n| leaf         | 7.6     | 0..n        |\n| leaf-list    | 7.7     | 0..n        |\n| list         | 7.8     | 0..n        |\n| must         | 7.5.3   | 0..n        |\n| reference    | 7.21.4  | 0..1        |\n| status       | 7.21.2  | 0..1        |\n| typedef      | 7.3     | 0..n        |\n| uses         | 7.13    | 0..n        |\n+--------------+---------+-------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.16.2. NETCONF XML Encoding Rules",
      "section_title": true,
      "ja": "7.16.2.  NETCONF XML符号化規則"
    },
    {
      "indent": 3,
      "text": "A notification node that is defined on the top level of a module is encoded as a child XML element to the <notification> element defined in \"NETCONF Event Notifications\" [RFC5277]. The element's local name is the notification's identifier, and its namespace is the module's XML namespace (see Section 7.1.3).",
      "ja": "モジュールのトップレベルで定義された通知ノードは、「NETCONFイベント通知」[RFC5277]で定義された<通知>要素の子のXML要素として符号化されます。要素のローカル名は、通知の識別子であり、その名前空間は、モジュールのXML名前空間（セクション7.1.3を参照）です。"
    },
    {
      "indent": 3,
      "text": "When a notification node is defined as a child to a data node, the <notification> element defined in [RFC5277] contains a hierarchy of nodes that identifies the node in the datastore. It MUST contain all containers and list nodes from the top level down to the list or container containing the notification. For lists, all key leafs MUST also be included. The innermost container or list contains an XML element that carries the name of the defined notification.",
      "ja": "通知ノードがデータノードの子として定義されている場合、[RFC5277]で定義された<通知>要素は、データストア内のノードを識別するノードの階層を含んでいます。これは、ダウン通知を含むリストまたは容器に最上位からすべてのコンテナとリストノードを含まなければなりません。リストでは、すべてのキーのリーフも含まれなければなりません。最も内側の容器またはリストは、定義された通知の名前を運ぶXML要素を含みます。"
    },
    {
      "indent": 3,
      "text": "The notification's child nodes are encoded as subelements to the notification node's XML element, in any order.",
      "ja": "通知の子ノードは、任意の順序で、通知ノードのXML要素にサブ要素として符号化されます。"
    },
    {
      "indent": 0,
      "text": "7.16.3. Usage Example",
      "section_title": true,
      "ja": "7.16.3. 使用例"
    },
    {
      "indent": 3,
      "text": "The following example defines a notification at the top level of a module:",
      "ja": "次の例では、モジュールの最上位レベルでの通知を定義します。"
    },
    {
      "indent": 5,
      "text": "module example-event {\n  yang-version 1.1;\n  namespace \"urn:example:event\";\n  prefix \"ev\";",
      "raw": true
    },
    {
      "indent": 5,
      "text": "  notification event {\n    leaf event-class {\n      type string;\n    }\n    leaf reporting-entity {\n      type instance-identifier;\n    }\n    leaf severity {\n      type string;\n    }\n  }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A corresponding XML instance example of the complete notification:",
      "ja": "完了通知の対応するXMLインスタンスの例："
    },
    {
      "indent": 5,
      "text": "<notification xmlns=\"urn:ietf:params:xml:ns:netconf:notification:1.0\"> <eventTime>2008-07-08T00:01:00Z</eventTime> <event xmlns=\"urn:example:event\"> <event-class>fault</event-class> <reporting-entity> /ex:interface[ex:name='Ethernet0'] </reporting-entity> <severity>major</severity> </event> </notification>",
      "ja": "<通知のxmlns = \"URN：IETF：paramsは：XML：NS：NETCONF：通知：1.0\"> <イベント時刻> 2008-07-08T00：01：00Z </イベント時刻> <イベントのxmlns = \"URN：例：イベント\"> <イベントクラス>障害</イベント・クラス> <報告-エンティティ> /例：インターフェース[例：名= 'Ethernet0に'] </レポーティング・エンティティ> <重要度>主要</重症度> </イベント> </通知>"
    },
    {
      "indent": 3,
      "text": "The following example defines a notification in a data node:",
      "ja": "次の例では、データノードに通知を定義します。"
    },
    {
      "indent": 5,
      "text": "module example-interface-module {\n  yang-version 1.1;\n  namespace \"urn:example:interface-module\";\n  prefix \"if\";",
      "raw": true
    },
    {
      "indent": 5,
      "text": "  container interfaces {\n    list interface {\n      key \"name\";\n      leaf name {\n        type string;\n      }\n      notification interface-enabled {\n        leaf by-user {\n          type string;\n        }\n      }\n    }\n  }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A corresponding XML instance example of the complete notification:",
      "ja": "完了通知の対応するXMLインスタンスの例："
    },
    {
      "indent": 5,
      "text": "<notification xmlns=\"urn:ietf:params:xml:ns:netconf:notification:1.0\"> <eventTime>2008-07-08T00:01:00Z</eventTime> <interfaces xmlns=\"urn:example:interface-module\"> <interface> <name>eth1</name> <interface-enabled> <by-user>fred</by-user> </interface-enabled> </interface> </interfaces> </notification>",
      "ja": "<通知のxmlns = \"URN：IETF：paramsは：XML：NS：NETCONF：通知：1.0\"> <イベント時刻> 2008-07-08T00：01：00Z </イベント時刻> <インターフェースのxmlns = \"URN：例：インターフェースモジュール「> <インターフェース> <名前> eth1の</名前> <インタフェース対応> <によってユーザー>フレッド</によるユーザー> </インタフェース対応> </インターフェイス> </インターフェイス> </通知>"
    },
    {
      "indent": 0,
      "text": "7.17. The \"augment\" Statement",
      "section_title": true,
      "ja": "7.17.  「強化」声明"
    },
    {
      "indent": 3,
      "text": "The \"augment\" statement allows a module or submodule to add to a schema tree defined in an external module, or in the current module and its submodules, and to add to the nodes from a grouping in a \"uses\" statement. The argument is a string that identifies a node in the schema tree. This node is called the augment's target node. The target node MUST be either a container, list, choice, case, input, output, or notification node. It is augmented with the nodes defined in the substatements that follow the \"augment\" statement.",
      "ja": "ステートメントは、モジュールまたはサブモジュールは、外部モジュールで定義されたスキーマ・ツリーに追加することができ、又は現在のモジュールとそのサブモジュールに、及び文を「使用」にグループからのノードに追加し、「増強」。引数は、スキーマツリー内のノードを識別する文字列です。このノードは、補填の対象ノードと呼ばれています。ターゲットノードは、コンテナ、リスト、選択、の場合、入力、出力、または通知ノードのいずれかでなければなりません。それは、「増やす」の文に続くサブステートメントで定義されたノードで拡張されます。"
    },
    {
      "indent": 3,
      "text": "The argument string is a schema node identifier (see Section 6.5). If the \"augment\" statement is on the top level in a module or submodule, the absolute form (defined by the rule \"absolute-schema-nodeid\" in Section 14) of a schema node identifier MUST be used. If the \"augment\" statement is a substatement to the \"uses\" statement, the descendant form (defined by the rule \"descendant-schema-nodeid\" in Section 14) MUST be used.",
      "ja": "引数文字列は、スキーマノード識別子（セクション6.5を参照）です。 「増強」ステートメントは、モジュール又はサブモジュールのトップレベルにある場合、スキーマ・ノード識別子（セクション14内のルール「絶対スキーマNODEID」によって定義される）絶対形式を使用しなければなりません。 「増強」ステートメントがステートメントを「使用」にサプである場合、（セクション14内のルール「子孫-スキーマNODEID」によって定義された）子孫形態が使用されなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the target node is a container, list, case, input, output, or notification node, the \"container\", \"leaf\", \"list\", \"leaf-list\", \"uses\", and \"choice\" statements can be used within the \"augment\" statement.",
      "ja": "ターゲット・ノードは、コンテナ、リスト、ケース、入力、出力、または通知ノードである場合は、「コンテナ」、「葉」、「リスト」、「リーフリスト」、「用途」、および「選択」のステートメントは、することができ「強化」声明の中で使用。"
    },
    {
      "indent": 3,
      "text": "If the target node is a container or list node, the \"action\" and \"notification\" statements can be used within the \"augment\" statement.",
      "ja": "ターゲット・ノードは、コンテナまたはリストのノード、「アクション」と「通知」の文である場合は、「増やす」ステートメントの中で使用することができます。"
    },
    {
      "indent": 3,
      "text": "If the target node is a choice node, the \"case\" statement or a shorthand \"case\" statement (see Section 7.9.2) can be used within the \"augment\" statement.",
      "ja": "ターゲットノードが選択ノードである場合は、「ケース」ステートメントまたは速記「ケース」の文は、（7.9.2項を参照）の文を「強化」内で使用することができます。"
    },
    {
      "indent": 3,
      "text": "The \"augment\" statement MUST NOT add multiple nodes with the same name from the same module to the target node.",
      "ja": "文は、同じモジュールからターゲット・ノードに同じ名前で複数のノードを追加してはならない「強化」。"
    },
    {
      "indent": 3,
      "text": "If the augmentation adds mandatory nodes (see Section 3) that represent configuration to a target node in another module, the augmentation MUST be made conditional with a \"when\" statement. Care must be taken when defining the \"when\" expression so that clients that do not know about the augmenting module do not break.",
      "ja": "増強は、他のモジュール内のターゲット・ノードへの設定を表す必須のノード（セクション3を参照）を追加した場合、増強は、「いつ」文を使用して、条件にしなければなりません。 「とき」という表現を定義するときに増強モジュールを知らないクライアントが壊れないように注意しなければなりません。"
    },
    {
      "indent": 3,
      "text": "In the following example, it is OK to augment the \"interface\" entry with \"mandatory-leaf\" because the augmentation depends on support for \"some-new-iftype\". The old client does not know about this type, so it would never select this type and would therefore not be adding a mandatory data node.",
      "ja": "増強「は、いくつかの新しい-のifType」のサポートに依存するため、以下の例では、「必須葉」と「インターフェース」のエントリを補強するためにOKです。古いクライアントは、このタイプについて知らないので、このタイプを選択することはないので、必須データノードを追加することはありません。"
    },
    {
      "indent": 5,
      "text": "module example-augment {\n  yang-version 1.1;\n  namespace \"urn:example:augment\";\n  prefix mymod;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "import ietf-interfaces { prefix if; }",
      "ja": "インポートIETF-インターフェイス{接頭場合、 }"
    },
    {
      "indent": 7,
      "text": "identity some-new-iftype {\n   base if:interface-type;\n} augment \"/if:interfaces/if:interface\" {\n   when 'derived-from-or-self(if:type, \"mymod:some-new-iftype\")';",
      "raw": true
    },
    {
      "indent": 5,
      "text": "     leaf mandatory-leaf {\n        mandatory true;\n        type string;\n     }\n  }\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.17.1. The augment's Substatements",
      "section_title": true,
      "ja": "7.17.1. オーグメントのサブステートメント"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| action       | 7.15    | 0..n        |\n| anydata      | 7.10    | 0..n        |\n| anyxml       | 7.11    | 0..n        |\n| case         | 7.9.2   | 0..n        |\n| choice       | 7.9     | 0..n        |\n| container    | 7.5     | 0..n        |\n| description  | 7.21.3  | 0..1        |\n| if-feature   | 7.20.2  | 0..n        |\n| leaf         | 7.6     | 0..n        |\n| leaf-list    | 7.7     | 0..n        |\n| list         | 7.8     | 0..n        |\n| notification | 7.16    | 0..n        |\n| reference    | 7.21.4  | 0..1        |\n| status       | 7.21.2  | 0..1        |\n| uses         | 7.13    | 0..n        |\n| when         | 7.21.5  | 0..1        |\n+--------------+---------+-------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.17.2. XML Encoding Rules",
      "section_title": true,
      "ja": "7.17.2.  XML符号化規則"
    },
    {
      "indent": 3,
      "text": "All data nodes defined in the \"augment\" statement are defined as XML elements in the XML namespace of the module where the \"augment\" is specified.",
      "ja": "「強化」文で定義されたすべてのデータノードが指定されている「増補」モジュールのXML名前空間内のXML要素として定義されています。"
    },
    {
      "indent": 3,
      "text": "When a node is augmented, the augmenting child nodes are encoded as subelements to the augmented node, in any order.",
      "ja": "ノードが拡張されると、増強子ノードは、任意の順序で、拡張ノードの下位要素として符号化されます。"
    },
    {
      "indent": 0,
      "text": "7.17.3. Usage Example",
      "section_title": true,
      "ja": "7.17.3. 使用例"
    },
    {
      "indent": 3,
      "text": "In namespace urn:example:interface-module, we have:",
      "ja": "例：名前空間のURNではインターフェース・モジュール、我々は持っています："
    },
    {
      "indent": 5,
      "text": "container interfaces { list ifEntry { key \"ifIndex\";",
      "ja": "コンテナインターフェイス{リストのifEntry {キー「のifIndex」。"
    },
    {
      "indent": 5,
      "text": "    leaf ifIndex {\n      type uint32;\n    }\n    leaf ifDescr {\n      type string;\n    }\n    leaf ifType {\n      type iana:IfType;\n    }\n    leaf ifMtu {\n      type int32;\n    }\n  }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Then, in namespace urn:example:ds0, we have:",
      "ja": "次に、名前空間骨壷に：例：DS0、我々は持っています："
    },
    {
      "indent": 5,
      "text": "import example-interface-module {\n  prefix \"if\";\n}\naugment \"/if:interfaces/if:ifEntry\" {\n  when \"if:ifType='ds0'\";\n  leaf ds0ChannelNumber {\n    type ChannelNumber;\n  }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "A corresponding XML instance example:",
      "ja": "対応するXMLインスタンスの例："
    },
    {
      "indent": 5,
      "text": "<interfaces xmlns=\"urn:example:interface-module\" xmlns:ds0=\"urn:example:ds0\"> <ifEntry> <ifIndex>1</ifIndex> <ifDescr>Flintstone Inc Ethernet A562</ifDescr> <ifType>ethernetCsmacd</ifType> <ifMtu>1500</ifMtu> </ifEntry> <ifEntry> <ifIndex>2</ifIndex> <ifDescr>Flintstone Inc DS0</ifDescr> <ifType>ds0</ifType> <ds0:ds0ChannelNumber>1</ds0:ds0ChannelNumber> </ifEntry> </interfaces>",
      "ja": "<インターフェースのxmlns = \"URN：例：インターフェースモジュール\" のxmlns：DS0 = \"URN：例：DS0\"> <ifEntryを> <ifIndexの> 1 </ ifIndexの> <のifDescr>フリントストーン社イーサネットA562 </のifDescr> <のifType> ethernetCsmacd </ ifTypeが> <ifMtu> 1500 </ ifMtu> </ ifEntryの> <のifEntry> <ifIndexの> 2 </ ifIndexの> <のifDescr>フリントストーン株式会社DS0 </のifDescr> <ifTypeが> DS0 </ ifTypeが> <DS0：ds0ChannelNumber > 1 </ DS0：ds0ChannelNumber> </ ifEntryを> </インターフェイス>"
    },
    {
      "indent": 3,
      "text": "As another example, suppose we have the choice defined in Section 7.9.6. The following construct can be used to extend the protocol definition:",
      "ja": "別の例として、我々は、セクション7.9.6で定義された選択肢を持っていると仮定します。以下の構文は、プロトコルの定義を拡張するために使用することができます。"
    },
    {
      "indent": 5,
      "text": "augment /ex:system/ex:protocol/ex:name { case c { leaf smtp { type empty; } } }",
      "ja": "増強/ EX：システム/ EX：プロトコル/ EX：名前{ケースc {葉SMTP {タイプ空。 }}}"
    },
    {
      "indent": 3,
      "text": "A corresponding XML instance example:",
      "ja": "対応するXMLインスタンスの例："
    },
    {
      "indent": 5,
      "text": "<ex:system> <ex:protocol> <ex:tcp/> </ex:protocol> </ex:system>",
      "ja": "<例：システム> <例：プロトコル> <例：TCP /> </ EX：プロトコル> </ EX：システム>"
    },
    {
      "indent": 3,
      "text": "or",
      "ja": "または"
    },
    {
      "indent": 5,
      "text": "<ex:system> <ex:protocol> <other:smtp/> </ex:protocol> </ex:system>",
      "ja": "<例：システム> <例：プロトコル> <その他：SMTP /> </ EX：プロトコル> </ EX：システム>"
    },
    {
      "indent": 0,
      "text": "7.18. The \"identity\" Statement",
      "section_title": true,
      "ja": "7.18.  「同一性」声明"
    },
    {
      "indent": 3,
      "text": "The \"identity\" statement is used to define a new globally unique, abstract, and untyped identity. The identity's only purpose is to denote its name, semantics, and existence. An identity can be either defined from scratch or derived from one or more base identities. The identity's argument is an identifier that is the name of the identity. It is followed by a block of substatements that holds detailed identity information.",
      "ja": "「アイデンティティ」文は、新しいグローバルにユニークな抽象的、および型なしアイデンティティを定義するために使用されます。身元の唯一の目的は、その名前、意味論、および存在を示すためにです。アイデンティティはどちらか最初から定義された1人のまたは複数のベースのアイデンティティに由来することができます。アイデンティティの引数は、アイデンティティの名前である識別子です。これは、詳細な識別情報を保持しているサブステートメントのブロックが続いています。"
    },
    {
      "indent": 3,
      "text": "The built-in datatype \"identityref\" (see Section 9.10) can be used to reference identities within a data model.",
      "ja": "組込みデータ型「identityrefは」（セクション9.10を参照）データモデル内で識別情報を参照するために使用することができます。"
    },
    {
      "indent": 0,
      "text": "7.18.1. The identity's Substatements",
      "section_title": true,
      "ja": "7.18.1. アイデンティティのサブステートメント"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| base         | 7.18.2  | 0..n        |\n| description  | 7.21.3  | 0..1        |\n| if-feature   | 7.20.2  | 0..n        |\n| reference    | 7.21.4  | 0..1        |\n| status       | 7.21.2  | 0..1        |\n+--------------+---------+-------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.18.2. The \"base\" Statement",
      "section_title": true,
      "ja": "7.18.2.  「ベース」声明"
    },
    {
      "indent": 3,
      "text": "The \"base\" statement, which is optional, takes as an argument a string that is the name of an existing identity, from which the new identity is derived. If no \"base\" statement is present, the identity is defined from scratch. If multiple \"base\" statements are present, the identity is derived from all of them.",
      "ja": "オプションである「ベース」の文では、引数として新しいアイデンティティが由来する既存のIDの名前である文字列を取ります。何の「ベース」文が存在しない場合、アイデンティティは最初から定義されています。複数の「ベース」の文が存在する場合、アイデンティティはそれらのすべてに由来しています。"
    },
    {
      "indent": 3,
      "text": "If a prefix is present on the base name, it refers to an identity defined in the module that was imported with that prefix, or the local module if the prefix matches the local module's prefix. Otherwise, an identity with the matching name MUST be defined in the current module or an included submodule.",
      "ja": "接頭辞がベース名に存在する場合、それはその接頭辞、または接頭辞がローカルモジュールのプレフィックスと一致した場合、ローカルモジュールをインポートされたモジュールで定義された同一性をいいます。そうでない場合は、一致する名前を持つアイデンティティは、現在のモジュールまたは含まサブモジュールで定義されなければなりません。"
    },
    {
      "indent": 3,
      "text": "An identity MUST NOT reference itself, neither directly nor indirectly through a chain of other identities.",
      "ja": "アイデンティティは、他のアイデンティティの連鎖を通じてどちらも直接にも間接的に、自分自身を参照してはなりません。"
    },
    {
      "indent": 3,
      "text": "The derivation of identities has the following properties:",
      "ja": "アイデンティティの導出は、次のプロパティがあります。"
    },
    {
      "indent": 3,
      "text": "o It is irreflexive, which means that an identity is not derived from itself.",
      "ja": "Oそれはアイデンティティが自身に由来するものではないことを意味し、非反射です。"
    },
    {
      "indent": 3,
      "text": "o It is transitive, which means that if identity B is derived from A and C is derived from B, then C is also derived from A.",
      "ja": "Oそれは、同一のBをAに由来し、CがBから誘導される場合、Cはまた、Aから誘導されることを意味推移、あります"
    },
    {
      "indent": 0,
      "text": "7.18.3. Usage Example",
      "section_title": true,
      "ja": "7.18.3. 使用例"
    },
    {
      "indent": 5,
      "text": "module example-crypto-base {\n  yang-version 1.1;\n  namespace \"urn:example:crypto-base\";\n  prefix \"crypto\";",
      "raw": true
    },
    {
      "indent": 7,
      "text": "identity crypto-alg { description \"Base identity from which all crypto algorithms are derived.\"; }",
      "ja": "同一の暗号ALG {説明「すべての暗号アルゴリズムが由来するベースアイデンティティ。」; }"
    },
    {
      "indent": 7,
      "text": "identity symmetric-key { description \"Base identity used to identify symmetric-key crypto algorithms.\"; }",
      "ja": "アイデンティティ対称鍵{説明「ベースアイデンティティは、対称鍵暗号化アルゴリズムを識別するために使用されます。」; }"
    },
    {
      "indent": 5,
      "text": " identity public-key { description \"Base identity used to identify public-key crypto algorithms.\"; } }",
      "ja": "アイデンティティの公開鍵{説明「ベースアイデンティティは、公開鍵暗号化アルゴリズムを識別するために使用されます。」; }}"
    },
    {
      "indent": 5,
      "text": "module example-des {\n  yang-version 1.1;\n  namespace \"urn:example:des\";\n  prefix \"des\";",
      "raw": true
    },
    {
      "indent": 7,
      "text": "import \"example-crypto-base\" { prefix \"crypto\"; }",
      "ja": "インポート「例、暗号ベース」{接頭辞「暗号」。 }"
    },
    {
      "indent": 5,
      "text": "  identity des {\n    base \"crypto:crypto-alg\";\n    base \"crypto:symmetric-key\";\n    description \"DES crypto algorithm.\";\n  } identity des3 {\n    base \"crypto:crypto-alg\";\n    base \"crypto:symmetric-key\";\n    description \"Triple DES crypto algorithm.\";\n  }\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.19. The \"extension\" Statement",
      "section_title": true,
      "ja": "7.19.  「拡張子」声明"
    },
    {
      "indent": 3,
      "text": "The \"extension\" statement allows the definition of new statements within the YANG language. This new statement definition can be imported and used by other modules.",
      "ja": "「拡張子」の文は、YANG言語内に新しいステートメントを定義できます。この新しい文の定義は、他のモジュールによってインポートして使用することができます。"
    },
    {
      "indent": 3,
      "text": "The \"extension\" statement's argument is an identifier that is the new keyword for the extension and must be followed by a block of substatements that holds detailed extension information. The purpose of the \"extension\" statement is to define a keyword so that it can be imported and used by other modules.",
      "ja": "「拡張子」文の引数には、拡張のための新しいキーワードである、詳細な拡張情報を保持しているサブステートメントのブロックが続かなければならない識別子です。 「拡張子」の文の目的は、それがインポートおよび他のモジュールで使用できるようにキーワードを定義することです。"
    },
    {
      "indent": 3,
      "text": "The extension can be used like a normal YANG statement, with the statement name followed by an argument if one is defined by the \"extension\" statement, and an optional block of substatements. The statement's name is created by combining the prefix of the module in which the extension was defined, a colon (\":\"), and the extension's keyword, with no interleaving whitespace. The substatements of an extension are defined by the \"extension\" statement, using some mechanism outside the scope of this specification. Syntactically, the substatements MUST be YANG statements, including extensions defined using \"extension\" statements. YANG statements in extensions MUST follow the syntactical rules in Section 14.",
      "ja": "拡張は、一方が「拡張」文、およびサブステートメントの任意のブロックによって定義されている場合、引数に続くステートメント名で、通常YANG文のように使用することができます。無インターリーブ空白で、（「」）、および拡張のキーワードステートメントの名前は、コロンを拡張子が定義されたモジュールの接頭辞を組み合わせて作成されます。拡張のサブステートメントは、本明細書の範囲外のいくつかのメカニズムを使用して、「拡張」ステートメントによって定義されています。構文的には、サブステートメントは、「拡張子」の文を使用して定義された拡張を含むYANG文でなければなりません。拡張子でYANG文は、セクション14で構文規則に従わなければなりません。"
    },
    {
      "indent": 3,
      "text": "An extension can allow refinement (see Section 7.13.2) and deviations (Section 7.20.3.2), but the mechanism for how this is defined is outside the scope of this specification.",
      "ja": "拡張は、リファインメント（セクション7.13.2を参照）との偏差（第7.20.3.2）を可能にすることができるが、これは定義されている方法のための機構は、本明細書の範囲外です。"
    },
    {
      "indent": 0,
      "text": "7.19.1. The extension's Substatements",
      "section_title": true,
      "ja": "7.19.1. 拡張機能のサブステートメント"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| argument     | 7.19.2  | 0..1        |\n| description  | 7.21.3  | 0..1        |\n| reference    | 7.21.4  | 0..1        |\n| status       | 7.21.2  | 0..1        |\n+--------------+---------+-------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.19.2. The \"argument\" Statement",
      "section_title": true,
      "ja": "7.19.2.  「引数」声明"
    },
    {
      "indent": 3,
      "text": "The \"argument\" statement, which is optional, takes as an argument a string that is the name of the argument to the keyword. If no \"argument\" statement is present, the keyword expects no argument when it is used.",
      "ja": "オプションである「引数」の文では、引数としてキーワードへの引数の名前である文字列を取ります。何の「引数」の文が存在しない場合は、キーワードは、それが使用されている引数を期待していません。"
    },
    {
      "indent": 3,
      "text": "The argument's name is used in the YIN mapping, where it is used as an XML attribute or element name, depending on the argument's \"yin-element\" statement.",
      "ja": "引数の名前は、引数の「陰の要素」文に応じて、それがXML属性または要素名として使用されYINマッピングで使用されています。"
    },
    {
      "indent": 0,
      "text": "7.19.2.1. The argument's Substatement",
      "section_title": true,
      "ja": "7.19.2.1。引数のサブステートメント"
    },
    {
      "indent": 17,
      "text": "+--------------+----------+-------------+\n| substatement | section  | cardinality |\n+--------------+----------+-------------+\n| yin-element  | 7.19.2.2 | 0..1        |\n+--------------+----------+-------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.19.2.2. The \"yin-element\" Statement",
      "section_title": true,
      "ja": "7.19.2.2。 「陰-要素」声明"
    },
    {
      "indent": 3,
      "text": "The \"yin-element\" statement, which is optional, takes as an argument the string \"true\" or \"false\". This statement indicates whether the argument is mapped to an XML element in YIN or to an XML attribute (see Section 13).",
      "ja": "オプションである「陰-要素」文は、引数として受け取り、文字列「true」または「false」。この文は、引数は（セクション13を参照）YINでのXML要素またはXML属性にマッピングされているかどうかを示します。"
    },
    {
      "indent": 3,
      "text": "If no \"yin-element\" statement is present, it defaults to \"false\".",
      "ja": "「偽」への「陰-要素」文が存在しない場合、それがデフォルトになります。"
    },
    {
      "indent": 0,
      "text": "7.19.3. Usage Example",
      "section_title": true,
      "ja": "7.19.3. 使用例"
    },
    {
      "indent": 3,
      "text": "To define an extension:",
      "ja": "拡張子を定義するには："
    },
    {
      "indent": 5,
      "text": "module example-extensions { yang-version 1.1; ...",
      "ja": "モジュール例、拡張{陽バージョン1.1。 ..."
    },
    {
      "indent": 5,
      "text": "  extension c-define {\n    description\n      \"Takes as an argument a name string.\n       Makes the code generator use the given name\n       in the #define.\";\n    argument \"name\";\n  }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "To use the extension:",
      "ja": "拡張機能を使用するには："
    },
    {
      "indent": 5,
      "text": "module example-interfaces { yang-version 1.1;",
      "ja": "モジュールの例として、インターフェース{陽バージョン1.1。"
    },
    {
      "indent": 7,
      "text": "... import example-extensions { prefix \"myext\"; } ...",
      "ja": "...インポート例 - 拡張{接頭辞「MYEXT」。 } ..."
    },
    {
      "indent": 5,
      "text": " container interfaces { ... myext:c-define \"MY_INTERFACES\"; } }",
      "ja": "容器インタフェース{... MYEXT：C-定義 \"MY_INTERFACES\"。 }}"
    },
    {
      "indent": 0,
      "text": "7.20. Conformance-Related Statements",
      "section_title": true,
      "ja": "7.20. 適合性、関連文"
    },
    {
      "indent": 3,
      "text": "This section defines statements related to conformance, as described in Section 5.6.",
      "ja": "このセクションは、セクション5.6で説明したように、適合性に関連した文を定義します。"
    },
    {
      "indent": 0,
      "text": "7.20.1. The \"feature\" Statement",
      "section_title": true,
      "ja": "7.20.1.  「機能」声明"
    },
    {
      "indent": 3,
      "text": "The \"feature\" statement is used to define a mechanism by which portions of the schema are marked as conditional. A feature name is defined that can later be referenced using the \"if-feature\" statement (see Section 7.20.2). Schema nodes tagged with an \"if-feature\" statement are ignored by the server unless the server supports the given feature expression. This allows portions of the YANG module to be conditional based on conditions in the server. The model can represent the abilities of the server within the model, giving a richer model that allows for differing server abilities and roles.",
      "ja": "「機能」ステートメントは、スキーマの一部が条件としてマークされるメカニズムを定義するために使用されます。機能名が後に「IF-機能」ステートメントを使用して参照できるように定義される（セクション7.20.2を参照してください）。サーバが指定された機能の発現を支持しない限り、「IF-機能」声明でタグ付けスキーマのノードがサーバーによって無視されます。これは、YANGモジュールの部分は、サーバ内の条件に基づいて、条件付きにすることができます。モデルは、サーバーの能力や役割の違いを可能にし、より豊かなモデルを与えて、モデル内のサーバの能力を表すことができます。"
    },
    {
      "indent": 3,
      "text": "The argument to the \"feature\" statement is the name of the new feature and follows the rules for identifiers in Section 6.2. This name is used by the \"if-feature\" statement to tie the schema nodes to the feature.",
      "ja": "「機能」文の引数には、新しい機能の名前で、セクション6.2で識別子の規則に従います。この名前は機能にスキーマノードを結びつけるために、「IF-機能」文で使用されています。"
    },
    {
      "indent": 3,
      "text": "In this example, a feature called \"local-storage\" represents the ability for a server to store syslog messages on local storage of some sort. This feature is used to make the \"local-storage-limit\" leaf conditional on the presence of some sort of local storage. If the server does not report that it supports this feature, the \"local-storage-limit\" node is not supported.",
      "ja": "この例では、「ローカル・ストレージ」と呼ばれる機能は、ある種のローカルストレージ上のsyslogメッセージを格納するためのサーバの能力を表しています。この機能は、ローカルストレージのいくつかの並べ替えの存在に「ローカルストレージ・リミット」の葉を条件付きにするために使用されます。サーバがこの機能をサポートしていることを報告しない場合は、「ローカルストレージ・リミット」ノードがサポートされていません。"
    },
    {
      "indent": 5,
      "text": "module example-syslog { yang-version 1.1;",
      "ja": "モジュール例-SYSLOG {陽バージョン1.1。"
    },
    {
      "indent": 7,
      "text": "... feature local-storage { description \"This feature means that the server supports local storage (memory, flash, or disk) that can be used to store syslog messages.\"; }",
      "ja": "...ローカルストレージ{記述を備えています「この機能は、サーバーがsyslogメッセージを格納するために使用することができ、ローカルストレージ（メモリ、フラッシュ、またはディスク）をサポートすることを意味します。」; }"
    },
    {
      "indent": 5,
      "text": "  container syslog {\n    leaf local-storage-limit {\n      if-feature local-storage;\n      type uint64;\n      units \"kilobyte\";\n      config false;\n      description\n        \"The amount of local storage that can be\n         used to hold syslog messages.\";\n    }\n  }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The \"if-feature\" statement can be used in many places within the YANG syntax. Definitions tagged with \"if-feature\" are ignored when the server does not support that feature.",
      "ja": "「IF-機能」の文は、YANG構文内の多くの場所で使用することができます。サーバがその機能をサポートしていないとき、「IF-機能」のタグが付いた定義は無視されます。"
    },
    {
      "indent": 3,
      "text": "A feature MUST NOT reference itself, neither directly nor indirectly through a chain of other features.",
      "ja": "機能は他の機能のチェーンを通じてどちらも直接にも間接的に、自分自身を参照してはなりません。"
    },
    {
      "indent": 3,
      "text": "In order for a server to support a feature that is dependent on any other features (i.e., the feature has one or more \"if-feature\" substatements), the server MUST also support all the dependent features.",
      "ja": "（すなわち、機能は、1つ以上の「IF-機能」サブステートメントを有する）任意の他の機能に依存している機能をサポートするサーバのために、サーバは、すべての従属機能をサポートしなければなりません。"
    },
    {
      "indent": 0,
      "text": "7.20.1.1. The feature's Substatements",
      "section_title": true,
      "ja": "7.20.1.1。機能のサブステートメント"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| description  | 7.21.3  | 0..1        |\n| if-feature   | 7.20.2  | 0..n        |\n| reference    | 7.21.4  | 0..1        |\n| status       | 7.21.2  | 0..1        |\n+--------------+---------+-------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.20.2. The \"if-feature\" Statement",
      "section_title": true,
      "ja": "7.20.2.  「IF-機能」声明"
    },
    {
      "indent": 3,
      "text": "The \"if-feature\" statement makes its parent statement conditional. The argument is a boolean expression over feature names. In this expression, a feature name evaluates to \"true\" if and only if the feature is supported by the server. The parent statement is implemented by servers where the boolean expression evaluates to \"true\".",
      "ja": "「IF-機能」の文は、その親ステートメントは、条件付きになります。引数には、機能名以上のブール式です。この式では、機能名があれば、「真」に評価し、機能はサーバによってサポートされている場合のみ。親文は、ブール式が「真」と評価され、サーバによって実装されます。"
    },
    {
      "indent": 3,
      "text": "The if-feature boolean expression syntax is formally defined by the rule \"if-feature-expr\" in Section 14. Parentheses are used to group expressions. When the expression is evaluated, the order of precedence is (highest precedence first): grouping (parentheses), \"not\", \"and\", \"or\".",
      "ja": "14.括弧は、グループ式に使用されている「場合、機能-exprの」セクションであれば、機能ブール式の構文は、正式にルールによって定義されます。式が評価される場合、優先順位は、（最初​​の最高の優先順位）である（括弧）、「しない」、「および」、「または」をグループ化します。"
    },
    {
      "indent": 3,
      "text": "If a prefix is present on a feature name in the boolean expression, the prefixed name refers to a feature defined in the module that was imported with that prefix, or the local module if the prefix matches the local module's prefix. Otherwise, a feature with the matching name MUST be defined in the current module or an included submodule.",
      "ja": "プレフィックスがブール式で機能名に存在する場合、接頭辞名はその接頭辞、または接頭辞がローカルモジュールのプレフィックスと一致した場合、ローカルモジュールをインポートされたモジュールで定義された機能を指します。そうでない場合は、一致する名前を持つ機能は、現在のモジュールまたは含まサブモジュールで定義されなければなりません。"
    },
    {
      "indent": 3,
      "text": "A leaf that is a list key MUST NOT have any \"if-feature\" statements.",
      "ja": "リストのキーである葉は、任意の「IF-機能」の文を持ってはいけません。"
    },
    {
      "indent": 0,
      "text": "7.20.2.1. Usage Example",
      "section_title": true,
      "ja": "7.20.2.1。使用例"
    },
    {
      "indent": 3,
      "text": "In this example, the container \"target\" is implemented if either the \"outbound-tls\" or \"outbound-ssh\" feature is supported by the server.",
      "ja": "「アウトバウンド-TLS」または「アウトバウンドSSH」機能のいずれかがサーバーによってサポートされている場合、この例では、容器「ターゲット」が実現されます。"
    },
    {
      "indent": 5,
      "text": "container target { if-feature \"outbound-tls or outbound-ssh\"; ... }",
      "ja": "容器ターゲット{IF-機能「アウトバウンド-TLSまたはアウトバウンドSSH」。 ...}"
    },
    {
      "indent": 3,
      "text": "The following examples are equivalent:",
      "ja": "次の例は等価です。"
    },
    {
      "indent": 5,
      "text": "if-feature \"not foo or bar and baz\";",
      "ja": "場合、機能「狛犬やバーやバズではありません」。"
    },
    {
      "indent": 5,
      "text": "if-feature \"(not foo) or (bar and baz)\";",
      "ja": "場合-機能「（fooではなく）または（バーとバズ）」。"
    },
    {
      "indent": 0,
      "text": "7.20.3. The \"deviation\" Statement",
      "section_title": true,
      "ja": "7.20.3.  「偏差」声明"
    },
    {
      "indent": 3,
      "text": "The \"deviation\" statement defines a hierarchy of a module that the server does not implement faithfully. The argument is a string that identifies the node in the schema tree where a deviation from the module occurs. This node is called the deviation's target node. The contents of the \"deviation\" statement give details about the deviation.",
      "ja": "「ずれ」の文では、サーバーが忠実に実装されていないモジュールの階層を定義します。引数は、モジュールからのずれが発生するスキーマ・ツリー内のノードを識別する文字列です。このノードは、偏差のターゲットノードと呼ばれています。 「ずれ」の文の内容は、偏差についての詳細を与えます。"
    },
    {
      "indent": 3,
      "text": "The argument string is an absolute schema node identifier (see Section 6.5).",
      "ja": "引数文字列は、絶対スキーマノード識別子（セクション6.5を参照）です。"
    },
    {
      "indent": 3,
      "text": "Deviations define the way a server or class of servers deviate from a standard. This means that deviations MUST never be part of a published standard, since they are the mechanism for learning how implementations vary from the standards.",
      "ja": "偏差は、サーバーまたはサーバーのクラスは標準から逸脱する方法を定義します。これは、彼らが実装は標準からどのように変化するかを学習するための仕組みであるため、偏差は、公表標準の一部にすることはできませんことを意味します。"
    },
    {
      "indent": 3,
      "text": "Server deviations are strongly discouraged and MUST only be used as a last resort. Telling the application how a server fails to follow a standard is no substitute for implementing the standard correctly. A server that deviates from a module is not fully compliant with the module.",
      "ja": "サーバーの偏差が強く推奨されており、最後の手段としてのみ使用しなければなりません。サーバが標準に従うことを失敗したかのアプリケーションを伝えることは正しく標準を実装するため代わるものではありません。モジュールから外れて、サーバーモジュールに完全に準拠していません。"
    },
    {
      "indent": 3,
      "text": "However, in some cases, a particular device may not have the hardware or software ability to support parts of a standard module. When this occurs, the server makes a choice to either treat attempts to configure unsupported parts of the module as an error that is reported back to the unsuspecting application or ignore those incoming requests. Neither choice is acceptable.",
      "ja": "しかし、いくつかのケースでは、特定のデバイスは、標準モジュールの一部をサポートするためのハードウェアまたはソフトウェアの能力を有していなくてもよいです。これが発生すると、サーバーはバック疑うことを知らないアプリケーションに報告されたエラーとしてモジュールのサポートされていない部分を設定したり、これらの着信要求を無視しようとする試みを治療するためのいずれかを選択します。どちらの選択が可能です。"
    },
    {
      "indent": 3,
      "text": "Instead, YANG allows servers to document portions of a base module that are not supported, or that are supported but with different syntax, by using the \"deviation\" statement.",
      "ja": "その代わり、YANGは、サーバは「ずれ」文を使用して、サポートされていない、またはそれがサポートされていますが、異なる構文を持つベースモジュールの一部を文書化することができます。"
    },
    {
      "indent": 3,
      "text": "After applying all deviations announced by a server, in any order, the resulting data model MUST still be valid.",
      "ja": "サーバーによって発表された全ての偏差を適用した後、任意の順序で、結果のデータ・モデルは、まだ有効でなければなりません。"
    },
    {
      "indent": 0,
      "text": "7.20.3.1. The deviation's Substatements",
      "section_title": true,
      "ja": "7.20.3.1。偏差のサブステートメント"
    },
    {
      "indent": 17,
      "text": "+--------------+----------+-------------+\n| substatement | section  | cardinality |\n+--------------+----------+-------------+\n| description  | 7.21.3   | 0..1        |\n| deviate      | 7.20.3.2 | 1..n        |\n| reference    | 7.21.4   | 0..1        |\n+--------------+----------+-------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.20.3.2. The \"deviate\" Statement",
      "section_title": true,
      "ja": "7.20.3.2。 「逸脱」声明"
    },
    {
      "indent": 3,
      "text": "The \"deviate\" statement defines how the server's implementation of the target node deviates from its original definition. The argument is one of the strings \"not-supported\", \"add\", \"replace\", or \"delete\".",
      "ja": "「逸脱」の文は、ターゲット・ノードのサーバーの実装は、元の定義から外れる方法を定義します。引数は、文字列「 - サポートされていません」の一つである「追加」、「置換」、または「削除」。"
    },
    {
      "indent": 3,
      "text": "The argument \"not-supported\" indicates that the target node is not implemented by this server.",
      "ja": "引数「-サポートされていませんが、」ターゲット・ノードが、このサーバーで実装されていないことを示しています。"
    },
    {
      "indent": 3,
      "text": "The argument \"add\" adds properties to the target node. The properties to add are identified by substatements to the \"deviate\" statement. If a property can only appear once, the property MUST NOT exist in the target node.",
      "ja": "「追加」引数は、ターゲット・ノードにプロパティを追加します。プロパティは「外れ」の文にサブステートメントで識別されている追加します。プロパティは1度だけ表示することができた場合は、プロパティがターゲットノードに存在してはなりません。"
    },
    {
      "indent": 3,
      "text": "The argument \"replace\" replaces properties of the target node. The properties to replace are identified by substatements to the \"deviate\" statement. The properties to replace MUST exist in the target node.",
      "ja": "引数「置き換え」は、対象ノードのプロパティを置き換えます。プロパティは「逸脱」声明へのサブステートメントで識別されている交換します。交換するプロパティは、ターゲット・ノードに存在しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The argument \"delete\" deletes properties from the target node. The properties to delete are identified by substatements to the \"delete\" statement. The substatement's keyword MUST match a corresponding keyword in the target node, and the argument's string MUST be equal to the corresponding keyword's argument string in the target node.",
      "ja": "引数「削除」は、対象ノードからプロパティを削除します。削除するプロパティは、「削除」ステートメントにサブステートメントによって識別されます。サプのキーワードがターゲットノードに対応するキーワードに一致しなければならない、引数の文字列がターゲットノードに対応するキーワードの引数文字列に等しくなければなりません。"
    },
    {
      "indent": 15,
      "text": "+--------------+--------------+-------------+\n| substatement | section      | cardinality |\n+--------------+--------------+-------------+\n| config       | 7.21.1       | 0..1        |\n| default      | 7.6.4, 7.7.4 | 0..n        |\n| mandatory    | 7.6.5        | 0..1        |\n| max-elements | 7.7.6        | 0..1        |\n| min-elements | 7.7.5        | 0..1        |\n| must         | 7.5.3        | 0..n        |\n| type         | 7.4          | 0..1        |\n| unique       | 7.8.3        | 0..n        |\n| units        | 7.3.3        | 0..1        |\n+--------------+--------------+-------------+",
      "raw": true
    },
    {
      "indent": 24,
      "text": "The deviate's Substatements",
      "ja": "ずれるのサブステートメント"
    },
    {
      "indent": 3,
      "text": "If the target node has a property defined by an extension, this property can be deviated if the extension allows deviations. See Section 7.19 for details.",
      "ja": "ターゲットノードが拡張することにより定義されたプロパティを有する場合拡張子が偏差を許可する場合、このプロパティがずれることができます。詳細については、セクション7.19を参照してください。"
    },
    {
      "indent": 0,
      "text": "7.20.3.3. Usage Example",
      "section_title": true,
      "ja": "7.20.3.3。使用例"
    },
    {
      "indent": 3,
      "text": "In this example, the server is informing client applications that it does not support the \"daytime\" service in the style of RFC 867.",
      "ja": "この例では、サーバはRFC 867のスタイルで「昼間」のサービスをサポートしていないクライアントアプリケーションに通知されます。"
    },
    {
      "indent": 5,
      "text": "module example-deviations {\n  yang-version 1.1;\n  namespace \"urn:example:deviations\";\n  prefix md;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "import example-base { prefix base; }",
      "ja": "例えば、基地{プレフィックスベースをインポートします。 }"
    },
    {
      "indent": 5,
      "text": " deviation /base:system/base:daytime { deviate not-supported; } ... }",
      "ja": "偏差/塩基：システム/ベース：昼間{サポートしない逸脱し。 } ...}"
    },
    {
      "indent": 3,
      "text": "A server would advertise both modules \"example-base\" and \"example-deviations\".",
      "ja": "サーバーは、両方のモジュール「例ベース」と「例-偏差」を宣伝します。"
    },
    {
      "indent": 3,
      "text": "The following example sets a server-specific default value to a leaf that does not have a default value defined:",
      "ja": "次の例では、定義されたデフォルト値を持っていない葉にサーバ固有のデフォルト値を設定します。"
    },
    {
      "indent": 5,
      "text": "deviation /base:system/base:user/base:type { deviate add { default \"admin\"; // new users are 'admin' by default } }",
      "ja": "偏差/塩基：システム/ベース：ユーザー/塩基：タイプ{{デフォルト「admin」を追加逸脱。 //新しいユーザーは、デフォルトでは「管理者」}}です"
    },
    {
      "indent": 3,
      "text": "In this example, the server limits the number of name servers to 3:",
      "ja": "この例では、サーバは3にネームサーバの数を制限します。"
    },
    {
      "indent": 5,
      "text": "deviation /base:system/base:name-server { deviate replace { max-elements 3; } }",
      "ja": "偏差/塩基：システム/ベース：ネームサーバ{{MAX-要素3を交換逸脱。 }}"
    },
    {
      "indent": 3,
      "text": "If the original definition is:",
      "ja": "オリジナルの定義がある場合："
    },
    {
      "indent": 5,
      "text": "container system { must \"daytime or time\"; ... }",
      "ja": "容器システム{しなければならない「昼間又は時間」。 ...}"
    },
    {
      "indent": 3,
      "text": "a server might remove this \"must\" constraint by doing:",
      "ja": "サーバが実行して、この「しなければならない」制約を削除することがあります。"
    },
    {
      "indent": 5,
      "text": "deviation /base:system { deviate delete { must \"daytime or time\"; } }",
      "ja": "偏差/塩基：システム{削除逸脱{しなければならない「昼間又は時間」。 }}"
    },
    {
      "indent": 0,
      "text": "7.21. Common Statements",
      "section_title": true,
      "ja": "7.21. 一般的なステートメント"
    },
    {
      "indent": 3,
      "text": "This section defines substatements common to several other statements.",
      "ja": "このセクションでは、いくつかの他の文に共通のサブステートメントを定義します。"
    },
    {
      "indent": 0,
      "text": "7.21.1. The \"config\" Statement",
      "section_title": true,
      "ja": "7.21.1.  「設定」声明"
    },
    {
      "indent": 3,
      "text": "The \"config\" statement takes as an argument the string \"true\" or \"false\". If \"config\" is \"true\", the definition represents configuration. Data nodes representing configuration are part of configuration datastores.",
      "ja": "「設定」の文は、引数として文字列を取り、「true」または「false」。 「設定」は「真」である場合には、定義が設定を表します。構成を表すデータノードは、構成データストアの一部です。"
    },
    {
      "indent": 3,
      "text": "If \"config\" is \"false\", the definition represents state data. Data nodes representing state data are not part of configuration datastores.",
      "ja": "「設定」は「偽」である場合には、定義が状態データを表します。状態データを表すデータノードは、構成データストアの一部ではありません。"
    },
    {
      "indent": 3,
      "text": "If \"config\" is not specified, the default is the same as the parent schema node's \"config\" value. If the parent node is a case node, the value is the same as the case node's parent choice node.",
      "ja": "「設定」が指定されていない場合、デフォルトでは親スキーマノードの「設定」の値と同じです。親ノードは、ケースのノードである場合、値はケースノードの親の選択ノードと同じです。"
    },
    {
      "indent": 3,
      "text": "If the top node does not specify a \"config\" statement, the default is \"true\".",
      "ja": "トップノードは、「設定」の文を指定しない場合、デフォルトは「true」です。"
    },
    {
      "indent": 3,
      "text": "If a node has \"config\" set to \"false\", no node underneath it can have \"config\" set to \"true\".",
      "ja": "ノードは「偽」に設定し、「設定」、それが「真」に設定し、「設定」を持つことができるの下にいないノードがある場合。"
    },
    {
      "indent": 0,
      "text": "7.21.2. The \"status\" Statement",
      "section_title": true,
      "ja": "7.21.2.  「ステータス」声明"
    },
    {
      "indent": 3,
      "text": "The \"status\" statement takes as an argument one of the strings \"current\", \"deprecated\", or \"obsolete\".",
      "ja": "「状態」の文では、引数の文字列「現在」の一つ、「非推奨」、または「時代遅れ」となります。"
    },
    {
      "indent": 3,
      "text": "o \"current\" means that the definition is current and valid.",
      "ja": "o「は、現在は」定義が現在、有効であることを意味しています。"
    },
    {
      "indent": 3,
      "text": "o \"deprecated\" indicates an obsolete definition, but it permits new/continued implementation in order to foster interoperability with older/existing implementations.",
      "ja": "O「非推奨」時代遅れの定義を示し、それは、古い/既存の実装との相互運用性を促進するために、継続的な/新しい実装を可能にします。"
    },
    {
      "indent": 3,
      "text": "o \"obsolete\" means that the definition is obsolete and SHOULD NOT be implemented and/or can be removed from implementations.",
      "ja": "o「は時代遅れ」と定義が廃止され、実装されてはならず、/または実装から除去することができることを意味します。"
    },
    {
      "indent": 3,
      "text": "If no status is specified, the default is \"current\".",
      "ja": "何の状態が指定されていない場合、デフォルトでは「現在」です。"
    },
    {
      "indent": 3,
      "text": "If a definition is \"current\", it MUST NOT reference a \"deprecated\" or \"obsolete\" definition within the same module.",
      "ja": "定義は、「現在」である場合は、同じモジュール内の「非推奨」または「時代遅れ」の定義を参照してはなりません。"
    },
    {
      "indent": 3,
      "text": "If a definition is \"deprecated\", it MUST NOT reference an \"obsolete\" definition within the same module.",
      "ja": "定義は、「非推奨」されている場合は、同じモジュール内で「時代遅れ」の定義を参照してはなりません。"
    },
    {
      "indent": 3,
      "text": "For example, the following is illegal:",
      "ja": "例えば、以下は違法です。"
    },
    {
      "indent": 5,
      "text": "typedef my-type {\n  status deprecated;\n  type int32;\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "leaf my-leaf { status current; type my-type; // illegal, since my-type is deprecated }",
      "ja": "葉私の葉{現在の状態。私のタイプを入力します。 }私のタイプは廃止されているので、//違法"
    },
    {
      "indent": 0,
      "text": "7.21.3. The \"description\" Statement",
      "section_title": true,
      "ja": "7.21.3.  「説明」声明"
    },
    {
      "indent": 3,
      "text": "The \"description\" statement takes as an argument a string that contains a human-readable textual description of this definition. The text is provided in a language (or languages) chosen by the module developer; for the sake of interoperability, it is RECOMMENDED to choose a language that is widely understood among the community of network administrators who will use the module.",
      "ja": "「説明」の文は、引数として、この定義の人間が読めるテキスト記述を含む文字列を取ります。テキストは、モジュール開発者が選択した言語（または言語）に設けられています。相互運用性のために、広くモジュールを使用するネットワーク管理者のコミュニティの中で理解されている言語を選択することをお勧めします。"
    },
    {
      "indent": 0,
      "text": "7.21.4. The \"reference\" Statement",
      "section_title": true,
      "ja": "7.21.4.  「参照」声明"
    },
    {
      "indent": 3,
      "text": "The \"reference\" statement takes as an argument a string that is a human-readable cross-reference to an external document -- either another module that defines related management information or a document that provides additional information relevant to this definition.",
      "ja": "関連する管理情報や、この定義に関連する追加情報を提供する文書を定義する他のモジュールのいずれか - 「参照」ステートメントは、引数として、外部文書への人間可読相互参照された文字列をとります。"
    },
    {
      "indent": 3,
      "text": "For example, a typedef for a \"uri\" data type could look like:",
      "ja": "たとえば、「URI」データ型のtypedefは、次のようになります。"
    },
    {
      "indent": 5,
      "text": "typedef uri {\n  type string;\n  reference\n    \"RFC 3986: Uniform Resource Identifier (URI): Generic Syntax\";\n  ...\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.21.5. The \"when\" Statement",
      "section_title": true,
      "ja": "7.21.5.  「いつ」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"when\" statement makes its parent data definition statement conditional. The node defined by the parent data definition statement is only valid when the condition specified by the \"when\" statement is satisfied. The statement's argument is an XPath expression (see Section 6.4), which is used to formally specify this condition. If the XPath expression conceptually evaluates to \"true\" for a particular instance, then the node defined by the parent data definition statement is valid; otherwise, it is not.",
      "ja": "「とき」の文は、条件付きの親データ定義文を作ります。親データ定義文で定義されたノードにのみ有効ですときで指定された条件文が成立している「とき」。文の引数には、正式にこの条件を指定するために使用されるXPath式（6.4節を参照）、です。 XPath式は、概念的に特定のインスタンスのための「真」に評価された場合、そのノードの親データ定義によって定義されたステートメントが有効です。それ以外の場合は、そうではありません。"
    },
    {
      "indent": 3,
      "text": "A leaf that is a list key MUST NOT have a \"when\" statement.",
      "ja": "リストのキーである葉は、「いつ」の文を持ってはいけません。"
    },
    {
      "indent": 3,
      "text": "If a key leaf is defined in a grouping that is used in a list, the \"uses\" statement MUST NOT have a \"when\" statement.",
      "ja": "キー葉がリストに使用されているグループに定義されている場合は、ステートメントを「使用する」「とき」の文を持ってはいけません。"
    },
    {
      "indent": 3,
      "text": "See Section 8.3.2 for additional information.",
      "ja": "追加情報については、8.3.2項を参照してください。"
    },
    {
      "indent": 3,
      "text": "The XPath expression is conceptually evaluated in the following context, in addition to the definition in Section 6.4.1:",
      "ja": "XPath式は、概念的6.4.1における定義に加えて、次のコンテキストで評価されています。"
    },
    {
      "indent": 3,
      "text": "o If the \"when\" statement is a child of an \"augment\" statement, then the context node is the augment's target node in the data tree, if the target node is a data node. Otherwise, the context node is the closest ancestor node to the target node that is also a data node. If no such node exists, the context node is the root node. The accessible tree is tentatively altered during the processing of the XPath expression by removing all instances (if any) of the nodes added by the \"augment\" statement.",
      "ja": "声明文を「増やす」の子である「と、」ターゲット・ノードがデータノードである場合、O場合は、コンテキストノードは、データツリー内のオーグメントのターゲット・ノードです。そうでない場合は、コンテキスト・ノードは、データノードであるターゲットノードに最も近い祖先ノードです。そのようなノードが存在しない場合、コンテキストノードがルートノードです。アクセスツリーは仮に「増強」ステートメントによって追加されたノードのすべてのインスタンス（もしあれば）を除去することにより、XPath式の処理中に変更されます。"
    },
    {
      "indent": 3,
      "text": "o If the \"when\" statement is a child of a \"uses\", \"choice\", or \"case\" statement, then the context node is the closest ancestor node to the node with the \"when\" statement that is also a data node. If no such node exists, the context node is the root node. The accessible tree is tentatively altered during the processing of the XPath expression by removing all instances (if any) of the nodes added by the \"uses\", \"choice\", or \"case\" statement.",
      "ja": "声明は「用途」、「選択」、または「ケース」の文の子である「と、」O、コンテキストノードは、データノードである「とき」の文のノードに最も近い祖先ノードである場合。そのようなノードが存在しない場合、コンテキストノードがルートノードです。アクセスツリーは仮に「用途」、「選択」、又は「ケース」ステートメントによって追加されたノードのすべてのインスタンス（もしあれば）を除去することにより、XPath式の処理中に変更されます。"
    },
    {
      "indent": 3,
      "text": "o If the \"when\" statement is a child of any other data definition statement, the accessible tree is tentatively altered during the processing of the XPath expression by replacing all instances of the data node for which the \"when\" statement is defined with a single dummy node with the same name, but with no value and no children. If no such instance exists, the dummy node is tentatively created. The context node is this dummy node.",
      "ja": "文は、他のデータ定義文の子である「と、」O、アクセスツリーが仮に「」文が単一で定義されたデータノードのすべてのインスタンスを置換することによって、XPath式の処理中に変更された場合ダミー同じ名前を持つノードが、無価値と子を持ちません。そのようなインスタンスが存在しない場合、ダミー・ノードが仮生成されます。コンテキストノードは、このダミーノードです。"
    },
    {
      "indent": 3,
      "text": "The result of the XPath expression is converted to a boolean value using the standard XPath rules.",
      "ja": "XPath式の結果は、標準のXPathルールを使用して、ブール値に変換されます。"
    },
    {
      "indent": 3,
      "text": "If the XPath expression references any node that also has associated \"when\" statements, those \"when\" expressions MUST be evaluated first. There MUST NOT be any circular dependencies among \"when\" expressions.",
      "ja": "XPath式はまた、「」文関連したすべてのノードを参照している場合、それらは「とき」の表現は、最初に評価されなければなりません。 「」式のうちいずれかの円形の依存関係があってはなりません。"
    },
    {
      "indent": 3,
      "text": "Note that the XPath expression is conceptually evaluated. This means that an implementation does not have to use an XPath evaluator in the server. The \"when\" statement can very well be implemented with specially written code.",
      "ja": "XPath式を概念的に評価されることに注意してください。これは、実装は、サーバーでのXPath評価を使用する必要がないことを意味します。 「とき」の文は非常によく、特別に書かれたコードで実現することができます。"
    },
    {
      "indent": 0,
      "text": "8. Constraints",
      "section_title": true,
      "ja": "8.制約"
    },
    {
      "indent": 0,
      "text": "8.1. Constraints on Data",
      "section_title": true,
      "ja": "8.1. データ上の制約"
    },
    {
      "indent": 3,
      "text": "Several YANG statements define constraints on valid data. These constraints are enforced in different ways, depending on what type of data the statement defines.",
      "ja": "いくつかのYANG文は有効なデータに制約を定義します。これらの制約は、文が定義するデータの種類に応じて、異なる方法で適用されます。"
    },
    {
      "indent": 3,
      "text": "o If the constraint is defined on configuration data, it MUST be true in a valid configuration data tree.",
      "ja": "制約が構成データに定義されている場合は、O、それは有効な構成データツリーに真でなければなりません。"
    },
    {
      "indent": 3,
      "text": "o If the constraint is defined on state data, it MUST be true in a valid state data tree.",
      "ja": "制約が状態データに定義されている場合は、O、それが有効な状態のデータツリーに真でなければなりません。"
    },
    {
      "indent": 3,
      "text": "o If the constraint is defined on notification content, it MUST be true in any notification data tree.",
      "ja": "制約は通知内容に定義されている場合は、O、それはどんな通知データツリーに真でなければなりません。"
    },
    {
      "indent": 3,
      "text": "o If the constraint is defined on RPC or action input parameters, it MUST be true in an invocation of the RPC or action operation.",
      "ja": "制約がRPCまたはアクションの入力パラメータに定義されている場合、Oは、RPCまたはアクション操作の呼び出しに真でなければなりません。"
    },
    {
      "indent": 3,
      "text": "o If the constraint is defined on RPC or action output parameters, it MUST be true in the RPC or action reply.",
      "ja": "制約がRPCまたはアクション出力パラメータで定義されている場合は、O、それはRPCやアクションの返信に真でなければなりません。"
    },
    {
      "indent": 3,
      "text": "The following properties are true in all data trees:",
      "ja": "次のプロパティは、すべてのデータの木に真であります："
    },
    {
      "indent": 3,
      "text": "o All leaf data values MUST match the type constraints for the leaf, including those defined in the type's \"range\", \"length\", and \"pattern\" properties.",
      "ja": "Oすべてのリーフのデータ値は、タイプの「レンジ」、「長さ」で定義されたもの、及び「パターン」プロパティを含む、葉の型制約と一致しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o All key leafs MUST be present for all list entries.",
      "ja": "Oすべてのキーのリーフは、すべてのリスト項目のために存在しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o Nodes MUST be present for at most one case branch in all choices.",
      "ja": "Oノードは、すべての選択肢で最大1つのケースのブランチのために存在しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o There MUST be no nodes tagged with \"if-feature\" present if the \"if-feature\" expression evaluates to \"false\" in the server.",
      "ja": "「IF-機能」という表現は、サーバ内の「偽」と評価された場合o「の場合、機能」現在のタグが付いどのノードがあってはなりません。"
    },
    {
      "indent": 3,
      "text": "o There MUST be no nodes tagged with \"when\" present if the \"when\" condition evaluates to \"false\" in the data tree.",
      "ja": "Oでタグ付けされたどのノードがあってはならない「と、」存在する場合の条件は、データツリーに「偽」と評価され「いつ」。"
    },
    {
      "indent": 3,
      "text": "The following properties are true in a valid data tree:",
      "ja": "次のプロパティは、有効なデータツリーに真であります："
    },
    {
      "indent": 3,
      "text": "o All \"must\" constraints MUST evaluate to \"true\".",
      "ja": "Oすべての制約は、「真」と評価されなければならない「しなければなりません」。"
    },
    {
      "indent": 3,
      "text": "o All referential integrity constraints defined via the \"path\" statement MUST be satisfied.",
      "ja": "O「パス」文を経由して定義されたすべての参照整合性制約を満たさなければなりません。"
    },
    {
      "indent": 3,
      "text": "o All \"unique\" constraints on lists MUST be satisfied.",
      "ja": "Oリストのすべての「ユニーク」の制約が満たさなければなりません。"
    },
    {
      "indent": 3,
      "text": "o The \"mandatory\" constraint is enforced for leafs and choices, unless the node or any of its ancestors has a \"when\" condition or \"if-feature\" expression that evaluates to \"false\".",
      "ja": "O「必須」制約はその祖先のノードまたはいずれかが「false」に評価され、「とき」の状態または「IF-機能」という表現を持っていない限り、葉や選択のために適用されます。"
    },
    {
      "indent": 3,
      "text": "o The \"min-elements\" and \"max-elements\" constraints are enforced for lists and leaf-lists, unless the node or any of its ancestors has a \"when\" condition or \"if-feature\" expression that evaluates to \"false\".",
      "ja": "「MIN-要素」と「MAX-要素」O制約は、リストやリーフリストに施行されたノードまたはその祖先は「false」に評価され、「とき」の状態または「IF-機能」という表現を持っていない限り、 。"
    },
    {
      "indent": 3,
      "text": "The running configuration datastore MUST always be valid.",
      "ja": "実行コンフィギュレーションデータストアは、常に有効である必要があります。"
    },
    {
      "indent": 0,
      "text": "8.2. Configuration Data Modifications",
      "section_title": true,
      "ja": "8.2. 構成データの変更"
    },
    {
      "indent": 3,
      "text": "o If a request creates configuration data nodes under a choice, any existing nodes from other case branches in the data tree are deleted by the server.",
      "ja": "リクエストは選択の下で、構成データノードを作成する場合は、O、データツリー内の他のケースの枝から既存のノードがサーバーによって削除されます。"
    },
    {
      "indent": 3,
      "text": "o If a request modifies a configuration data node such that any node's \"when\" expression becomes false, then the node in the data tree with the \"when\" expression is deleted by the server.",
      "ja": "O場合、要求は、任意のノードの「」表現「は」表現がサーバーによって削除されたとのデータツリーに虚偽、そのノードになるコンフィギュレーション・データ・ノードを変更します。"
    },
    {
      "indent": 0,
      "text": "8.3. NETCONF Constraint Enforcement Model",
      "section_title": true,
      "ja": "8.3.  NETCONF制約施行モデル"
    },
    {
      "indent": 3,
      "text": "For configuration data, there are three windows when constraints MUST be enforced:",
      "ja": "コンフィギュレーション・データの場合は、制約が適用されなければならない3つの窓があります。"
    },
    {
      "indent": 3,
      "text": "o during parsing of RPC payloads",
      "ja": "O RPCペイロードの解析中"
    },
    {
      "indent": 3,
      "text": "o during processing of the <edit-config> operation",
      "ja": "<編集-config>の演算の処理中にO"
    },
    {
      "indent": 3,
      "text": "o during validation",
      "ja": "検証中のO"
    },
    {
      "indent": 3,
      "text": "Each of these scenarios is considered in the following sections.",
      "ja": "これらのシナリオのそれぞれは、以下のセクションで考えられています。"
    },
    {
      "indent": 0,
      "text": "8.3.1. Payload Parsing",
      "section_title": true,
      "ja": "8.3.1. ペイロード解析"
    },
    {
      "indent": 3,
      "text": "When content arrives in RPC payloads, it MUST be well-formed XML, following the hierarchy and content rules defined by the set of models the server implements.",
      "ja": "コンテンツは、RPCペイロードに到着すると、それは、モデルのサーバ実装のセットによって定義された階層とコンテンツルール以下、整形式XMLでなければなりません。"
    },
    {
      "indent": 3,
      "text": "o If a leaf data value does not match the type constraints for the leaf, including those defined in the type's \"range\", \"length\", and \"pattern\" properties, the server MUST reply with an \"invalid-value\" <error-tag> in the <rpc-error>, and with the error-app-tag (Section 7.5.4.2) and error-message (Section 7.5.4.1) associated with the constraint, if any exist.",
      "ja": "O葉のデータ値は、タイプの「レンジ」、「長さ」に定義されたものを含む葉の型制約、及び「パターン」の特性と一致しない場合は、「無効値」で応答しなければならないサーバ<エラー - タグ> <RPCエラーで>、エラーアプリタグ（セクション7.5.4.2）とが存在する場合、制約に関連付けられたエラーメッセージ（セクション7.5.4.1）を有します。"
    },
    {
      "indent": 3,
      "text": "o If all keys of a list entry are not present, the server MUST reply with a \"missing-element\" <error-tag> in the <rpc-error>.",
      "ja": "リストのエントリのすべてのキーが存在しない場合は、O、サーバーは<RPCエラー>で「行方不明の要素」<エラータグ>と返答しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o If data for more than one case branch of a choice is present, the server MUST reply with a \"bad-element\" <error-tag> in the <rpc-error>.",
      "ja": "選択した複数のケースブランチのデータが存在する場合は、O、サーバーは<RPCエラー>で「悪い要素」<エラータグ>と返答しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o If data for a node tagged with \"if-feature\" is present and the \"if-feature\" expression evaluates to \"false\" in the server, the server MUST reply with an \"unknown-element\" <error-tag> in the <rpc-error>.",
      "ja": "O「IF-機能」でタグ付けされたノードのデータが存在し、「IF-機能」という表現は、サーバに「false」に評価された場合において、「未知の要素」<エラータグ>で応答しなければならないサーバ<RPCエラー>。"
    },
    {
      "indent": 3,
      "text": "o If data for a node tagged with \"when\" is present and the \"when\" condition evaluates to \"false\", the server MUST reply with an \"unknown-element\" <error-tag> in the <rpc-error>.",
      "ja": "Oノードのデータが存在し、「いつ」条件が「偽」、サーバは<RPCエラー>の<エラータグ>「未知要素」で応答しなければならないと評価「と、」タグが付いている場合。"
    },
    {
      "indent": 3,
      "text": "o For insert handling, if the values for the attributes \"before\" and \"after\" are not valid for the type of the appropriate key leafs, the server MUST reply with a \"bad-attribute\" <error-tag> in the <rpc-error>.",
      "ja": "挿入処理のためのO、属性の値であれば、「前」と適切なキー葉の種類は有効ではありません「の後に」、サーバーは「悪い属性」で返答しなければならない。<エラータグ> <RPCで-error>。"
    },
    {
      "indent": 3,
      "text": "o If the attributes \"before\" and \"after\" appear in any element that is not a list whose \"ordered-by\" property is \"user\", the server MUST reply with an \"unknown-attribute\" <error-tag> in the <rpc-error>.",
      "ja": "Oと「後」、「前」属性がリストではありません任意の要素に表示された場合は、「注文-で」プロパティ「ユーザー」、サーバは「未知の属性」で返答しなければならない。<エラータグ>であります<RPCエラー>。"
    },
    {
      "indent": 0,
      "text": "8.3.2. NETCONF <edit-config> Processing",
      "section_title": true,
      "ja": "8.3.2.  NETCONF <編集-config>の処理"
    },
    {
      "indent": 3,
      "text": "After the incoming data is parsed, the NETCONF server performs the <edit-config> operation by applying the data to the configuration datastore. During this processing, the following errors MUST be detected:",
      "ja": "着信データが解析された後に、NETCONFサーバは、コンフィギュレーションデータストアにデータを適用することによって、<編集設定>動作を行います。この処理中に、次のエラーが検出されなければなりません。"
    },
    {
      "indent": 3,
      "text": "o Delete requests for non-existent data.",
      "ja": "O存在しないデータの要求を削除します。"
    },
    {
      "indent": 3,
      "text": "o Create requests for existent data.",
      "ja": "既存のデータの要求を作成します。"
    },
    {
      "indent": 3,
      "text": "o Insert requests with \"before\" or \"after\" parameters that do not exist.",
      "ja": "Oまたはパラメータ「の後に」それは存在しない「前」とのリクエストを挿入します。"
    },
    {
      "indent": 3,
      "text": "o Modification requests for nodes tagged with \"when\", and the \"when\" condition evaluates to \"false\". In this case, the server MUST reply with an \"unknown-element\" <error-tag> in the <rpc-error>.",
      "ja": "「いつ」、および「とき」の条件が「偽」に評価してタグ付けされたノード用のO変更要求。この場合、サーバは、<RPCエラー>で「未知の要素」<エラータグ>と返答しなければなりません。"
    },
    {
      "indent": 0,
      "text": "8.3.3. Validation",
      "section_title": true,
      "ja": "8.3.3. バリデーション"
    },
    {
      "indent": 3,
      "text": "When datastore processing is complete, the final contents MUST obey all validation constraints. This validation processing is performed at differing times according to the datastore. If the datastore is \"running\" or \"startup\", these constraints MUST be enforced at the end of the <edit-config> or <copy-config> operation. If the datastore is \"candidate\", the constraint enforcement is delayed until a <commit> or <validate> operation takes place.",
      "ja": "データストアの処理が完了すると、最終的内容は、すべての検証の制約に従わなければなりません。この検証処理は、データストアに応じて異なる時間に実行されます。データストアは、「実行中」または「起動」されている場合は、これらの制約は、<編集-config設定>または<コピー-config>の操作の終了時に実施されなければなりません。データストアは、「候補」である場合は、<コミット>または<検証>まで、制約の執行が遅れた場合の動作が行われます。"
    },
    {
      "indent": 0,
      "text": "9. Built-In Types",
      "section_title": true,
      "ja": "9.組み込み型"
    },
    {
      "indent": 3,
      "text": "YANG has a set of built-in types, similar to those of many programming languages, but with some differences due to special requirements from the management information model.",
      "ja": "YANGは、多くのプログラミング言語と同様のビルトインタイプのセットを、持っていますが、管理情報モデルから特別な要求のためにいくつかの違いで。"
    },
    {
      "indent": 3,
      "text": "Additional types may be defined that are derived from those built-in types or from other derived types. Derived types may use subtyping to formally restrict the set of possible values.",
      "ja": "誘導される付加的なタイプ定義することができるもの、内蔵型または他の派生タイプから。派生型は、正式に可能な値のセットを制限するためにサブタイプを使用することができます。"
    },
    {
      "indent": 3,
      "text": "The different built-in types and their derived types allow different kinds of subtyping, namely length and regular expression restrictions of strings (Sections 9.4.4 and 9.4.5) and range restrictions of numeric types (Section 9.2.4).",
      "ja": "異なる内蔵型とその派生型はサブタイプ、すなわち、長さと文字列（セクション9.4.4と9.4.5）と数値型（セクション9.2.4）の範囲の制限の正規表現の制約の種類を許可します。"
    },
    {
      "indent": 3,
      "text": "The lexical representation of a value of a certain type is used in the XML encoding and when specifying default values and numerical ranges in YANG modules.",
      "ja": "YANGモジュールのデフォルト値と数値範囲を指定するとき、特定のタイプの値の字句表現は、XMLエンコーディングに使用されます。"
    },
    {
      "indent": 0,
      "text": "9.1. Canonical Representation",
      "section_title": true,
      "ja": "9.1.  Canonicalの表現"
    },
    {
      "indent": 3,
      "text": "For most types, there is a single canonical representation of the type's values. Some types allow multiple lexical representations of the same value; for example, the positive integer \"17\" can be represented as \"+17\" or \"17\". Implementations MUST support all lexical representations specified in this document.",
      "ja": "ほとんどのタイプでは、タイプの値の単一の標準表現があります。いくつかの種類が同じ値の複数の字句表現が可能。例えば、正の整数「17」を「17」または「17」のように表すことができます。実装は、この文書で指定されたすべての字句表現をサポートしなければなりません。"
    },
    {
      "indent": 3,
      "text": "When a server sends XML-encoded data, it MUST use the canonical form defined in this section. Other encodings may introduce alternate representations. Note, however, that values in the data tree are conceptually stored in the canonical representation as defined in this section. In particular, any XPath expression evaluations are done using the canonical form if the data type has a canonical form. If the data type does not have a canonical form, the format of the value MUST match the data type's lexical representation, but the exact format is implementation dependent.",
      "ja": "サーバは、XML符号化データを送信する場合、このセクションで定義された標準形式を使用しなければなりません。他のエンコーディングは、代替表現を導入することができます。このセクションで定義されるようなデータツリーの値が概念的に正規表現に格納されていること、しかし、注意してください。データ型は標準形を有する場合、特に、任意のXPath式の評価は、標準形式を使用して行われます。データ型が正規の形式を持っていない場合は、値のフォーマットは、データ型の字句表現に一致する必要がありますが、正確なフォーマットは実装依存です。"
    },
    {
      "indent": 3,
      "text": "Some types have a lexical representation that depends on the encoding, e.g., the XML context in which they occur. These types do not have a canonical form.",
      "ja": "いくつかのタイプは、彼らが発生した符号化、例えば、XMLコンテキストに依存する語彙表現を有しています。これらのタイプは、標準的な形式を持っていません。"
    },
    {
      "indent": 0,
      "text": "9.2. The Integer Built-In Types",
      "section_title": true,
      "ja": "9.2. 整数は組み込み型"
    },
    {
      "indent": 3,
      "text": "The integer built-in types are int8, int16, int32, int64, uint8, uint16, uint32, and uint64. They represent signed and unsigned integers of different sizes:",
      "ja": "組み込み型整数INT8、INT16、INT32、Int64の、UINT8、uint16の、UINT32、およびUINT64です。彼らは、異なるサイズの符号付きと符号なし整数を表します。"
    },
    {
      "indent": 3,
      "text": "int8 represents integer values between -128 and 127, inclusively.",
      "ja": "INT8は包括的に、-128と127の間の整​​数値を表します。"
    },
    {
      "indent": 3,
      "text": "int16 represents integer values between -32768 and 32767, inclusively.",
      "ja": "INT16は、包括的に、-32768から32767の間の整​​数値を表します。"
    },
    {
      "indent": 3,
      "text": "int32 represents integer values between -2147483648 and 2147483647, inclusively.",
      "ja": "INT32は、包括的に、-2147483648と2147483647の間の整​​数値を表します。"
    },
    {
      "indent": 3,
      "text": "int64 represents integer values between -9223372036854775808 and 9223372036854775807, inclusively.",
      "ja": "Int64のは、包括的、-9223372036854775808と9223372036854775807間の整数値を表します。"
    },
    {
      "indent": 3,
      "text": "uint8 represents integer values between 0 and 255, inclusively.",
      "ja": "UINT8は包括的に、0〜255の整数値を表します。"
    },
    {
      "indent": 3,
      "text": "uint16 represents integer values between 0 and 65535, inclusively.",
      "ja": "uint16のは、包括的に、0〜65535の整数値を表します。"
    },
    {
      "indent": 3,
      "text": "uint32 represents integer values between 0 and 4294967295, inclusively.",
      "ja": "UINT32は包括的に、0から4294967295までの整数値を表します。"
    },
    {
      "indent": 3,
      "text": "uint64 represents integer values between 0 and 18446744073709551615, inclusively.",
      "ja": "UINT64は包括的に、0と18446744073709551615の間の整数値を表します。"
    },
    {
      "indent": 0,
      "text": "9.2.1. Lexical Representation",
      "section_title": true,
      "ja": "9.2.1. 字句表現"
    },
    {
      "indent": 3,
      "text": "An integer value is lexically represented as an optional sign (\"+\" or \"-\"), followed by a sequence of decimal digits. If no sign is specified, \"+\" is assumed.",
      "ja": "整数値は、辞書的に任意の符号として表される（「+」または「 - 」）、桁のシーケンスが続きます。兆候が指定されていない場合は、「+」と想定されます。"
    },
    {
      "indent": 3,
      "text": "For convenience, when specifying a default value for an integer in a YANG module, an alternative lexical representation can be used that represents the value in a hexadecimal or octal notation. The hexadecimal notation consists of an optional sign (\"+\" or \"-\"), followed by the characters \"0x\", followed by a number of hexadecimal digits where letters may be uppercase or lowercase. The octal notation consists of an optional sign (\"+\" or \"-\"), followed by the character \"0\", followed by a number of octal digits.",
      "ja": "YANGモジュールの整数のデフォルト値を指定する際の便宜のために、代替的な語彙表現は、16進数または8進数の表記で値を表すことに使用することができます。文字が大文字または小文字とすることができる16進数字の数に続く文字「0X」、続いて、 -  16進表記は省略記号（「」「+」又は）からなります。進表記は、オプションの符号から成る（「+」または「 - 」）、8進数の数に続く文字「0」が続きます。"
    },
    {
      "indent": 3,
      "text": "Note that if a default value in a YANG module has a leading zero (\"0\"), it is interpreted as an octal number. In the XML encoding, an integer is always interpreted as a decimal number, and leading zeros are allowed.",
      "ja": "YANGモジュールであればデフォルト値は先行ゼロ（「0」）、それは進数として解釈されていることに留意されたいです。 XML符号化では、整数は常に10進数として解釈され、先行ゼロが許可されています。"
    },
    {
      "indent": 3,
      "text": "Examples:",
      "ja": "例："
    },
    {
      "indent": 5,
      "text": "// legal values +4711 // legal positive value 4711 // legal positive value -123 // legal negative value 0xf00f // legal positive hexadecimal value -0xf // legal negative hexadecimal value 052 // legal positive octal value",
      "ja": "//有効な値4711 //法的正の値4711 //法的正の値-123 //法的負値0xf00f //法的正の16進値-0xf //法的負の16進数値052 //法的正進値"
    },
    {
      "indent": 5,
      "text": "// illegal values - 1 // illegal intermediate space",
      "ja": "//不正な値 -  1つの//違法中間空間"
    },
    {
      "indent": 0,
      "text": "9.2.2. Canonical Form",
      "section_title": true,
      "ja": "9.2.2.  Canonicalのフォーム"
    },
    {
      "indent": 3,
      "text": "The canonical form of a positive integer does not include the sign \"+\". Leading zeros are prohibited. The value zero is represented as \"0\".",
      "ja": "正の整数の正規の形式は、記号「+」が含まれていません。先行ゼロは禁止されています。ゼロの値は「0」として表されます。"
    },
    {
      "indent": 0,
      "text": "9.2.3. Restrictions",
      "section_title": true,
      "ja": "9.2.3. 制限事項"
    },
    {
      "indent": 3,
      "text": "All integer types can be restricted with the \"range\" statement (Section 9.2.4).",
      "ja": "すべての整数型は、「範囲」の文（9.2.4項）で制限することができます。"
    },
    {
      "indent": 0,
      "text": "9.2.4. The \"range\" Statement",
      "section_title": true,
      "ja": "9.2.4.  「範囲」声明"
    },
    {
      "indent": 3,
      "text": "The \"range\" statement, which is an optional substatement to the \"type\" statement, takes as an argument a range expression string. It is used to restrict integer and decimal built-in types, or types derived from them.",
      "ja": "「タイプ」文とオプションのサブステートメントである「範囲」の文では、引数として範囲式の文字列を取ります。組み込み型、またはそれらに由来するタイプの整数と小数を制限するために使用されます。"
    },
    {
      "indent": 3,
      "text": "A range consists of an explicit value, or a lower-inclusive bound, two consecutive dots \"..\", and an upper-inclusive bound. Multiple values or ranges can be given, separated by \"|\". If multiple values or ranges are given, they all MUST be disjoint and MUST be in ascending order. If a range restriction is applied to a type that is already range-restricted, the new restriction MUST be equally limiting or more limiting, i.e., raising the lower bounds, reducing the upper bounds, removing explicit values or ranges, or splitting ranges into multiple ranges with intermediate gaps. Each explicit value and range boundary value given in the range expression MUST match the type being restricted or be one of the special values \"min\" or \"max\". \"min\" and \"max\" mean the minimum and maximum values accepted for the type being restricted, respectively.",
      "ja": "範囲は、「..」の明示的な値は、以下の包括的な結合し、二つの連続したドットで構成され、上部フルバウンド。 「|」は、複数の値または範囲を区切っ挙げることができます。複数の値または範囲が指定されている場合、それらはすべて互いに素でなければならないと昇順でなければなりません。範囲制限が既に制限範囲はタイプに適用した場合、新たな制限は等しく、明示的な値または範囲を除去し、制限以上の制限、すなわち、上限を減少させる、下限を上げなければなりません、または分割が複数に及びます中間ギャップを有する範囲です。範囲式で与えられるそれぞれの明示的な値及び範囲の境界値が制限されるタイプと一致または特別な値「分」または「最大」のいずれかでなければなりません。 「最小」および「最大」は、それぞれ、最小値を意味し、タイプのために受け入れた最大値が制限されます。"
    },
    {
      "indent": 3,
      "text": "The range expression syntax is formally defined by the rule \"range-arg\" in Section 14.",
      "ja": "範囲式の構文は、正式に第14内のルール「の範囲-argに」で定義されています。"
    },
    {
      "indent": 0,
      "text": "9.2.4.1. The range's Substatements",
      "section_title": true,
      "ja": "9.2.4.1。範囲のサブステートメント"
    },
    {
      "indent": 17,
      "text": "+---------------+---------+-------------+\n| substatement  | section | cardinality |\n+---------------+---------+-------------+\n| description   | 7.21.3  | 0..1        |\n| error-app-tag | 7.5.4.2 | 0..1        |\n| error-message | 7.5.4.1 | 0..1        |\n| reference     | 7.21.4  | 0..1        |\n+---------------+---------+-------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "9.2.5. Usage Example",
      "section_title": true,
      "ja": "9.2.5. 使用例"
    },
    {
      "indent": 5,
      "text": "typedef my-base-int32-type {\n  type int32 {\n    range \"1..4 | 10..20\";\n  }\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "typedef my-type1 { type my-base-int32-type { // legal range restriction range \"11..max\"; // 11..20 } }",
      "ja": "私-TYPE1のtypedef {私の塩基INT32型{//有効範囲の制限範囲 \"11..max\" と入力。 // 11..20}}"
    },
    {
      "indent": 5,
      "text": "typedef my-type2 { type my-base-int32-type { // illegal range restriction range \"11..100\"; } }",
      "ja": "MY-TYPE2のtypedef {私の塩基INT32型{//不正範囲の制限範囲 \"11..100\" を入力。 }}"
    },
    {
      "indent": 0,
      "text": "9.3. The decimal64 Built-In Type",
      "section_title": true,
      "ja": "9.3.  decimal64は、組み込み型"
    },
    {
      "indent": 3,
      "text": "The decimal64 built-in type represents a subset of the real numbers, which can be represented by decimal numerals. The value space of decimal64 is the set of numbers that can be obtained by multiplying a 64-bit signed integer by a negative power of ten, i.e., expressible as \"i x 10^-n\" where i is an integer64 and n is an integer between 1 and 18, inclusively.",
      "ja": "内蔵型decimal64は小数点の数字で表すことができる実数のサブセットを表しています。 decimal64の値空間iはinteger64であり、nは整数である「IX 10 ^ -n」として表現10の負のパワーにより64ビット符号付き整数を乗算して得られる数値のセット、すなわち、あります1〜18、包括。"
    },
    {
      "indent": 0,
      "text": "9.3.1. Lexical Representation",
      "section_title": true,
      "ja": "9.3.1. 字句表現"
    },
    {
      "indent": 3,
      "text": "A decimal64 value is lexically represented as an optional sign (\"+\" or \"-\"), followed by a sequence of decimal digits, optionally followed by a period ('.') as a decimal indicator and a sequence of decimal digits. If no sign is specified, \"+\" is assumed.",
      "ja": "decimal64値は字句オプションの符号として表される - （「」）（「+」または「an」）、桁のシーケンスが続く、任意に周期小数点インジケータと桁のシーケンスとして続きます。兆候が指定されていない場合は、「+」と想定されます。"
    },
    {
      "indent": 0,
      "text": "9.3.2. Canonical Form",
      "section_title": true,
      "ja": "9.3.2.  Canonicalのフォーム"
    },
    {
      "indent": 3,
      "text": "The canonical form of a positive decimal64 value does not include the sign \"+\". The decimal point is required. Leading and trailing zeros are prohibited, subject to the rule that there MUST be at least one digit before and after the decimal point. The value zero is represented as \"0.0\".",
      "ja": "正decimal64値の正規の形式は、記号「+」が含まれていません。小数点が必要です。先頭と末尾のゼロは、小数点の前後少なくとも一桁が存在しなければならないことルールに従う禁止されています。ゼロの値を「0.0」として表されます。"
    },
    {
      "indent": 0,
      "text": "9.3.3. Restrictions",
      "section_title": true,
      "ja": "9.3.3. 制限事項"
    },
    {
      "indent": 3,
      "text": "A decimal64 type can be restricted with the \"range\" statement (Section 9.2.4).",
      "ja": "decimal64タイプは「範囲」の文（9.2.4項）で制限することができます。"
    },
    {
      "indent": 0,
      "text": "9.3.4. The \"fraction-digits\" Statement",
      "section_title": true,
      "ja": "9.3.4.  「小数桁」声明"
    },
    {
      "indent": 3,
      "text": "The \"fraction-digits\" statement, which is a substatement to the \"type\" statement, MUST be present if the type is \"decimal64\". It takes as an argument an integer between 1 and 18, inclusively. It controls the size of the minimum difference between values of a decimal64 type by restricting the value space to numbers that are expressible as \"i x 10^-n\" where n is the fraction-digits argument.",
      "ja": "タイプが「decimal64」であれば「タイプ」の文にサブステートメントである「端数桁」の文では、存在しなければなりません。これは、包括的、引数として1と18の間の整数をとります。 nが小数桁引数である「私は10 ^ -nを×」とそれが発現されている番号に値空間を制限することによりdecimal64型の値との間の最小の差の大きさを制御します。"
    },
    {
      "indent": 3,
      "text": "The following table lists the minimum and maximum values for each fraction-digit value:",
      "ja": "次の表は、各画分桁の値の最小値と最大値を示します。"
    },
    {
      "indent": 5,
      "text": "+----------------+-----------------------+----------------------+\n| fraction-digit | min                   | max                  |\n+----------------+-----------------------+----------------------+\n| 1              | -922337203685477580.8 | 922337203685477580.7 |\n| 2              | -92233720368547758.08 | 92233720368547758.07 |\n| 3              | -9223372036854775.808 | 9223372036854775.807 |\n| 4              | -922337203685477.5808 | 922337203685477.5807 |\n| 5              | -92233720368547.75808 | 92233720368547.75807 |\n| 6              | -9223372036854.775808 | 9223372036854.775807 |\n| 7              | -922337203685.4775808 | 922337203685.4775807 |\n| 8              | -92233720368.54775808 | 92233720368.54775807 |\n| 9              | -9223372036.854775808 | 9223372036.854775807 |\n| 10             | -922337203.6854775808 | 922337203.6854775807 |\n| 11             | -92233720.36854775808 | 92233720.36854775807 |\n| 12             | -9223372.036854775808 | 9223372.036854775807 |\n| 13             | -922337.2036854775808 | 922337.2036854775807 |\n| 14             | -92233.72036854775808 | 92233.72036854775807 |\n| 15             | -9223.372036854775808 | 9223.372036854775807 |\n| 16             | -922.3372036854775808 | 922.3372036854775807 |\n| 17             | -92.23372036854775808 | 92.23372036854775807 |\n| 18             | -9.223372036854775808 | 9.223372036854775807 |\n+----------------+-----------------------+----------------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "9.3.5. Usage Example",
      "section_title": true,
      "ja": "9.3.5. 使用例"
    },
    {
      "indent": 5,
      "text": "typedef my-decimal {\n  type decimal64 {\n    fraction-digits 2;\n    range \"1 .. 3.14 | 10 | 20..max\";\n  }\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "9.4. The string Built-In Type",
      "section_title": true,
      "ja": "9.4. 文字列は、組み込み型"
    },
    {
      "indent": 3,
      "text": "The string built-in type represents human-readable strings in YANG. Legal characters are the Unicode and ISO/IEC 10646 [ISO.10646] characters, including tab, carriage return, and line feed but excluding the other C0 control characters, the surrogate blocks, and the noncharacters. The string syntax is formally defined by the rule \"yang-string\" in Section 14.",
      "ja": "ビルトインタイプの文字列は、YANGで判読可能な文字列を表します。有効な文字は、タブ、改行、改行を含むUnicodeとISO / IEC 10646 [ISO.10646]文字、ですが、他のC0制御文字、サロゲートブロック、およびnoncharactersを除きます。文字列の構文は、正式に第14内のルール「ヤン・文字列」によって定義されます。"
    },
    {
      "indent": 0,
      "text": "9.4.1. Lexical Representation",
      "section_title": true,
      "ja": "9.4.1. 字句表現"
    },
    {
      "indent": 3,
      "text": "A string value is lexically represented as character data in the XML encoding.",
      "ja": "文字列値は、辞書的にXMLのエンコーディングの文字データとして表現されます。"
    },
    {
      "indent": 0,
      "text": "9.4.2. Canonical Form",
      "section_title": true,
      "ja": "9.4.2.  Canonicalのフォーム"
    },
    {
      "indent": 3,
      "text": "The canonical form is the same as the lexical representation. No Unicode normalization of string values is performed.",
      "ja": "標準形式は、語彙表現と同じです。文字列値のないUnicodeの正規化は行われません。"
    },
    {
      "indent": 0,
      "text": "9.4.3. Restrictions",
      "section_title": true,
      "ja": "9.4.3. 制限事項"
    },
    {
      "indent": 3,
      "text": "A string can be restricted with the \"length\" (Section 9.4.4) and \"pattern\" (Section 9.4.5) statements.",
      "ja": "文字列は、「長さ」（9.4.4項）と「パターン」（第9.4.5項）文で制限することができます。"
    },
    {
      "indent": 0,
      "text": "9.4.4. The \"length\" Statement",
      "section_title": true,
      "ja": "9.4.4.  「長さ」声明"
    },
    {
      "indent": 3,
      "text": "The \"length\" statement, which is an optional substatement to the \"type\" statement, takes as an argument a length expression string. It is used to restrict the built-in types \"string\" and \"binary\" or types derived from them.",
      "ja": "「タイプ」文とオプションのサブステートメントである「長さ」の文では、引数の長さの表現文字列として取ります。組み込み型「文字列」と「バイナリ」またはそれらに由来種類を制限するために使用されます。"
    },
    {
      "indent": 3,
      "text": "A \"length\" statement restricts the number of Unicode characters in the string.",
      "ja": "「長さ」の文は、文字列内のUnicode文字の数を制限します。"
    },
    {
      "indent": 3,
      "text": "A length range consists of an explicit value, or a lower bound, two consecutive dots \"..\", and an upper bound. Multiple values or ranges can be given, separated by \"|\". Length-restricting values MUST NOT be negative. If multiple values or ranges are given, they all MUST be disjoint and MUST be in ascending order. If a length restriction is applied to a type that is already length-restricted, the new restriction MUST be equally limiting or more limiting, i.e., raising the lower bounds, reducing the upper bounds, removing explicit length values or ranges, or splitting ranges into multiple ranges with intermediate gaps. A length value is a non-negative integer or one of the special values \"min\" or \"max\". \"min\" and \"max\" mean the minimum and maximum lengths accepted for the type being restricted, respectively. An implementation is not required to support a length value larger than 18446744073709551615.",
      "ja": "長さの範囲は、「..」の明示的な値、または下限、二つの連続したドットで構成され、上限。 「|」は、複数の値または範囲を区切っ挙げることができます。長さ制限値が負であってはなりません。複数の値または範囲が指定されている場合、それらはすべて互いに素でなければならないと昇順でなければなりません。長さ制限が既に長制限されるタイプに適用した場合、新たな制限は等しく制限以上の制限されなければならない、すなわち、に明示的な長さの値または範囲、または分割範囲を除去し、上限を減少させる、下限を上げます中間ギャップを有する複数の範囲。長さの値は、非負整数または特別な値「分」または「最大」の一つです。 「最小」および「最大」は、それぞれ、最小およびタイプのために受け入れ最大長が制限されている意味します。実装は18446744073709551615より大きい長さの値をサポートするために必要とされません。"
    },
    {
      "indent": 3,
      "text": "The length expression syntax is formally defined by the rule \"length-arg\" in Section 14.",
      "ja": "長さの表現の構文は、正式に第14内のルール「長さ-argに」で定義されています。"
    },
    {
      "indent": 0,
      "text": "9.4.4.1. The length's Substatements",
      "section_title": true,
      "ja": "9.4.4.1。長さのサブステートメント"
    },
    {
      "indent": 17,
      "text": "+---------------+---------+-------------+\n| substatement  | section | cardinality |\n+---------------+---------+-------------+\n| description   | 7.21.3  | 0..1        |\n| error-app-tag | 7.5.4.2 | 0..1        |\n| error-message | 7.5.4.1 | 0..1        |\n| reference     | 7.21.4  | 0..1        |\n+---------------+---------+-------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "9.4.5. The \"pattern\" Statement",
      "section_title": true,
      "ja": "9.4.5.  「パターン」声明"
    },
    {
      "indent": 3,
      "text": "The \"pattern\" statement, which is an optional substatement to the \"type\" statement, takes as an argument a regular expression string, as defined in [XSD-TYPES]. It is used to restrict the built-in type \"string\", or types derived from \"string\", to values that match the pattern.",
      "ja": "[XSD-TYPES]で定義されるように、「タイプ」ステートメントの任意サプある「パターン」の文では、引数として正規表現文字列をとります。パターンに一致する値に内蔵型「string」、又は「ストリング」に由来するタイプを制限するために使用されます。"
    },
    {
      "indent": 3,
      "text": "If the type has multiple \"pattern\" statements, the expressions are ANDed together, i.e., all such expressions have to match.",
      "ja": "タイプは、複数の「パターン」の文を持っている場合、式はすなわち、そのようなすべての表現が一致する必要が、一緒にAND演算されています。"
    },
    {
      "indent": 3,
      "text": "If a pattern restriction is applied to a type that is already pattern-restricted, values must match all patterns in the base type, in addition to the new patterns.",
      "ja": "パターン制限が既にパターン制限されているタイプに適用した場合、値が新しいパターンに加えて、基本型のすべてのパターンに一致しなければなりません。"
    },
    {
      "indent": 0,
      "text": "9.4.5.1. The pattern's Substatements",
      "section_title": true,
      "ja": "9.4.5.1。パターンのサブステートメント"
    },
    {
      "indent": 17,
      "text": "+---------------+---------+-------------+\n| substatement  | section | cardinality |\n+---------------+---------+-------------+\n| description   | 7.21.3  | 0..1        |\n| error-app-tag | 7.5.4.2 | 0..1        |\n| error-message | 7.5.4.1 | 0..1        |\n| modifier      | 9.4.6   | 0..1        |\n| reference     | 7.21.4  | 0..1        |\n+---------------+---------+-------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "9.4.6. The \"modifier\" Statement",
      "section_title": true,
      "ja": "9.4.6.  「修飾子」声明"
    },
    {
      "indent": 3,
      "text": "The \"modifier\" statement, which is an optional substatement to the \"pattern\" statement, takes as an argument the string \"invert-match\".",
      "ja": "「パターン」文とオプションのサブステートメントである「修飾子」の文では、引数として文字列「反転一致」を取ります。"
    },
    {
      "indent": 3,
      "text": "If a pattern has the \"invert-match\" modifier present, the type is restricted to values that do not match the pattern.",
      "ja": "パターンが「反転一致」修飾子が存在している場合、型は、パターンに一致しない値に制限されています。"
    },
    {
      "indent": 0,
      "text": "9.4.7. Usage Example",
      "section_title": true,
      "ja": "9.4.7. 使用例"
    },
    {
      "indent": 3,
      "text": "With the following typedef:",
      "ja": "次のtypedefと："
    },
    {
      "indent": 5,
      "text": "typedef my-base-str-type { type string { length \"1..255\"; } }",
      "ja": "私の塩基STR型{型string {長さ「1 255」のtypedef。 }}"
    },
    {
      "indent": 3,
      "text": "the following refinement is legal:",
      "ja": "以下の微細化が有効です。"
    },
    {
      "indent": 5,
      "text": "type my-base-str-type { // legal length refinement length \"11 | 42..max\"; // 11 | 42..255 }",
      "ja": "タイプ私の塩基STR型{//法的長洗練長「11 | 42..max」。 // 11 | 42..255}"
    },
    {
      "indent": 3,
      "text": "and the following refinement is illegal:",
      "ja": "そして、次の改良が違法です："
    },
    {
      "indent": 5,
      "text": "type my-base-str-type { // illegal length refinement length \"1..999\"; }",
      "ja": "私の塩基STR型{//不正な長さの洗練長「1..999」と入力。 }"
    },
    {
      "indent": 3,
      "text": "With the following type:",
      "ja": "以下のタイプの場合："
    },
    {
      "indent": 5,
      "text": "type string {\n  length \"0..4\";\n  pattern \"[0-9a-fA-F]*\";\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "the following strings match:",
      "ja": "以下の文字列が一致します："
    },
    {
      "indent": 5,
      "text": "AB // legal 9A00 // legal",
      "ja": "AB //法的// 9A00法的"
    },
    {
      "indent": 3,
      "text": "and the following strings do not match:",
      "ja": "そして次の文字列が一致しません。"
    },
    {
      "indent": 5,
      "text": "00ABAB // illegal, too long xx00 // illegal, bad characters",
      "ja": "00ABAB //違法、長すぎるXX00 //違法、不正な文字"
    },
    {
      "indent": 3,
      "text": "With the following type:",
      "ja": "以下のタイプの場合："
    },
    {
      "indent": 5,
      "text": "type string {\n  length \"1..max\";\n  pattern '[a-zA-Z_][a-zA-Z0-9\\-_.]*';\n  pattern '[xX][mM][lL].*' {\n    modifier invert-match;\n  }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "the following string matches:",
      "ja": "次の文字列の一致："
    },
    {
      "indent": 5,
      "text": "enabled // legal",
      "ja": "法的//有効"
    },
    {
      "indent": 3,
      "text": "and the following strings do not match:",
      "ja": "そして次の文字列が一致しません。"
    },
    {
      "indent": 5,
      "text": "10-mbit // illegal, starts with a number xml-element // illegal, starts with illegal sequence",
      "ja": "違法10メガビット//は、違法な数のXML要素//で始まり、不正シーケンスで始まり"
    },
    {
      "indent": 0,
      "text": "9.5. The boolean Built-In Type",
      "section_title": true,
      "ja": "9.5. ブール値は、組み込み型"
    },
    {
      "indent": 3,
      "text": "The boolean built-in type represents a boolean value.",
      "ja": "ブールビルトインタイプは、ブール値を表します。"
    },
    {
      "indent": 0,
      "text": "9.5.1. Lexical Representation",
      "section_title": true,
      "ja": "9.5.1. 字句表現"
    },
    {
      "indent": 3,
      "text": "The lexical representation of a boolean value is a string with a value of \"true\" or \"false\". These values MUST be in lowercase.",
      "ja": "ブール値の字句表現は、「true」または「false」の値を持つ文字列です。これらの値は小文字でなければなりません。"
    },
    {
      "indent": 0,
      "text": "9.5.2. Canonical Form",
      "section_title": true,
      "ja": "9.5.2.  Canonicalのフォーム"
    },
    {
      "indent": 3,
      "text": "The canonical form is the same as the lexical representation.",
      "ja": "標準形式は、語彙表現と同じです。"
    },
    {
      "indent": 0,
      "text": "9.5.3. Restrictions",
      "section_title": true,
      "ja": "9.5.3. 制限事項"
    },
    {
      "indent": 3,
      "text": "A boolean cannot be restricted.",
      "ja": "ブール値を制限することはできません。"
    },
    {
      "indent": 0,
      "text": "9.6. The enumeration Built-In Type",
      "section_title": true,
      "ja": "9.6. 列挙は、組み込み型"
    },
    {
      "indent": 3,
      "text": "The enumeration built-in type represents values from a set of assigned names.",
      "ja": "内蔵型列挙は、割り当てられた名前のセットからの値を表します。"
    },
    {
      "indent": 0,
      "text": "9.6.1. Lexical Representation",
      "section_title": true,
      "ja": "9.6.1. 字句表現"
    },
    {
      "indent": 3,
      "text": "The lexical representation of an enumeration value is the assigned name string.",
      "ja": "列挙値の字句表現は、割り当てられた名前の文字列です。"
    },
    {
      "indent": 0,
      "text": "9.6.2. Canonical Form",
      "section_title": true,
      "ja": "9.6.2.  Canonicalのフォーム"
    },
    {
      "indent": 3,
      "text": "The canonical form is the assigned name string.",
      "ja": "正規の形式は、割り当てられた名前の文字列です。"
    },
    {
      "indent": 0,
      "text": "9.6.3. Restrictions",
      "section_title": true,
      "ja": "9.6.3. 制限事項"
    },
    {
      "indent": 3,
      "text": "An enumeration can be restricted with one or more \"enum\" (Section 9.6.4) statements, which enumerate a subset of the values for the base type.",
      "ja": "列挙は、1つ以上の「列挙」（セクション9.6.4）ベース型の値のサブセットを列挙ステートメントで制限することができます。"
    },
    {
      "indent": 0,
      "text": "9.6.4. The \"enum\" Statement",
      "section_title": true,
      "ja": "9.6.4.  「列挙型」声明"
    },
    {
      "indent": 3,
      "text": "The \"enum\" statement, which is a substatement to the \"type\" statement, MUST be present if the type is \"enumeration\". It is repeatedly used to specify each assigned name of an enumeration type. It takes as an argument a string that is the assigned name. The string MUST NOT be zero-length and MUST NOT have any leading or trailing whitespace characters (any Unicode character with the \"White_Space\" property). The use of Unicode control codes SHOULD be avoided.",
      "ja": "タイプが「列挙」であれば「タイプ」の文にサブステートメントである「列挙型」の文は、存在しなければなりません。これを繰り返し列挙型のそれぞれに割り当てられた名前を指定するために使用されます。これは、引数として割り当てられた名前である文字列を取ります。文字列が長さゼロにすることはできませんし、（「WHITE_SPACE」プロパティを持つ任意のUnicode文字）を先頭または末尾の空白文字があってはなりません。 Unicodeの制御コードの使用は避けるべきです。"
    },
    {
      "indent": 3,
      "text": "The statement is optionally followed by a block of substatements that holds detailed enum information.",
      "ja": "ステートメントは、必要に応じて詳細な列挙情報を保持するサブステートメントのブロックが続きます。"
    },
    {
      "indent": 3,
      "text": "All assigned names in an enumeration MUST be unique.",
      "ja": "列挙のすべての割り当てられた名前は固有でなければなりません。"
    },
    {
      "indent": 3,
      "text": "When an existing enumeration type is restricted, the set of assigned names in the new type MUST be a subset of the base type's set of assigned names. The value of such an assigned name MUST NOT be changed.",
      "ja": "既存の列挙型が制限されている場合は、新しいタイプで割り当てられた名前のセットは、割り当てられた名前の基本型のセットのサブセットである必要があります。このよう割り当てられた名前の値を変更してはいけません。"
    },
    {
      "indent": 0,
      "text": "9.6.4.1. The enum's Substatements",
      "section_title": true,
      "ja": "9.6.4.1。列挙型のサブステートメント"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| description  | 7.21.3  | 0..1        |\n| if-feature   | 7.20.2  | 0..n        |\n| reference    | 7.21.4  | 0..1        |\n| status       | 7.21.2  | 0..1        |\n| value        | 9.6.4.2 | 0..1        |\n+--------------+---------+-------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "9.6.4.2. The \"value\" Statement",
      "section_title": true,
      "ja": "9.6.4.2。 「値」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"value\" statement, which is optional, is used to associate an integer value with the assigned name for the enum. This integer value MUST be in the range -2147483648 to 2147483647, and it MUST be unique within the enumeration type.",
      "ja": "オプションである「値」文は、列挙型のために割り当てられた名前と整数値を関連付けるために使用されます。この整数値は2147483647の範囲-2147483648でなければなりません、そして、それは列挙型内で一意でなければなりません。"
    },
    {
      "indent": 3,
      "text": "If a value is not specified, then one will be automatically assigned. If the \"enum\" substatement is the first one defined, the assigned value is zero (0); otherwise, the assigned value is one greater than the current highest enum value (i.e., the highest enum value, implicit or explicit, prior to the current \"enum\" substatement in the parent \"type\" statement).",
      "ja": "値が指定されていない場合は、1が自動的に割り当てられます。 「列挙」サプが定義されている最初のものである場合は、割り当てられた値は、ゼロ（0）です。そうでない場合、割り当てられた値は、現在の最高の列挙値より1大きい（すなわち、暗黙的または明示的な最高列挙値、親「タイプ」ステートメントで現在の「列挙」サプ前）。"
    },
    {
      "indent": 3,
      "text": "Note that the presence of an \"if-feature\" statement in an \"enum\" statement does not affect the automatically assigned value.",
      "ja": "「列挙型」文で「IF-機能」文の存在が自動的に割り当てられた値に影響を与えないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "If the current highest value is equal to 2147483647, then an enum value MUST be specified for \"enum\" substatements following the one with the current highest value.",
      "ja": "現在の最高値は2147483647に等しい場合、列挙値は、現在の最高値とのいずれかを、以下、「列挙」サブステートメントに指定されなければなりません。"
    },
    {
      "indent": 3,
      "text": "When an existing enumeration type is restricted, the \"value\" statement MUST either have the same value as in the base type or not be present, in which case the value is the same as in the base type.",
      "ja": "既存の列挙型が制限される場合、「値」ステートメントは基本型と同じ値を持っているか、存在してはならないのいずれかで、その場合、値は基本タイプと同じです。"
    },
    {
      "indent": 0,
      "text": "9.6.5. Usage Example",
      "section_title": true,
      "ja": "9.6.5. 使用例"
    },
    {
      "indent": 5,
      "text": "leaf myenum {\n  type enumeration {\n    enum zero;\n    enum one;\n    enum seven {\n      value 7;\n    }\n  }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The lexical representation of the leaf \"myenum\" with value \"seven\" is:",
      "ja": "「7」の値を持つ葉「myenum」の字句表現は次のとおりです。"
    },
    {
      "indent": 5,
      "text": "<myenum>seven</myenum>",
      "ja": "<myenum> 7 </ myenum>"
    },
    {
      "indent": 3,
      "text": "With the following typedef:",
      "ja": "次のtypedefと："
    },
    {
      "indent": 5,
      "text": "typedef my-base-enumeration-type {\n  type enumeration {\n    enum white {\n      value 1;\n    }\n    enum yellow {\n      value 2;\n    }\n    enum red {\n      value 3;\n    }\n  }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "the following refinement is legal:",
      "ja": "以下の微細化が有効です。"
    },
    {
      "indent": 5,
      "text": "type my-base-enumeration-type {\n  // legal enum refinement\n  enum yellow;\n  enum red {\n    value 3;\n  }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "and the following refinement is illegal:",
      "ja": "そして、次の改良が違法です："
    },
    {
      "indent": 5,
      "text": "type my-base-enumeration-type { // illegal enum refinement enum yellow { value 4; // illegal value change } enum black; // illegal addition of new name }",
      "ja": "MY-ベース列挙型{//不正列挙リファイン列挙黄色{4値を入力します。 //不正な値の変化}ブラック列挙。新しい名前の//違法追加}"
    },
    {
      "indent": 3,
      "text": "The following example shows how an \"enum\" can be tagged with \"if-feature\", making the value legal only on servers that advertise the corresponding feature:",
      "ja": "次の例では、「列挙型」は、「IF-機能」のタグが付いのみ対応する機能を広告サーバー上で有効な値を作ることができる方法を示しています。"
    },
    {
      "indent": 5,
      "text": "type enumeration {\n  enum tcp;\n  enum ssh {\n    if-feature ssh;\n  }\n  enum tls {\n    if-feature tls;\n  }\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "9.7. The bits Built-In Type",
      "section_title": true,
      "ja": "9.7. ビットは、内蔵型"
    },
    {
      "indent": 3,
      "text": "The bits built-in type represents a bit set. That is, a bits value is a set of flags identified by small integer position numbers starting at 0. Each bit number has an assigned name.",
      "ja": "内蔵型ビットは、ビットセットを表します。つまり、ビット値は、各ビット数は0に割り当てられた名前を持つ開始小さな整数位置番号で識別フラグのセットです。"
    },
    {
      "indent": 3,
      "text": "When an existing bits type is restricted, the set of assigned names in the new type MUST be a subset of the base type's set of assigned names. The bit position of such an assigned name MUST NOT be changed.",
      "ja": "既存のビットタイプが制限されている場合は、新しいタイプで割り当てられた名前のセットは、割り当てられた名前の基本型のセットのサブセットである必要があります。このよう割り当てられた名前のビット位置を変更してはいけません。"
    },
    {
      "indent": 0,
      "text": "9.7.1. Restrictions",
      "section_title": true,
      "ja": "9.7.1. 制限事項"
    },
    {
      "indent": 3,
      "text": "A bits type can be restricted with the \"bit\" (Section 9.7.4) statement.",
      "ja": "ビットタイプが「ビット」（セクション9.7.4）の文で制限することができます。"
    },
    {
      "indent": 0,
      "text": "9.7.2. Lexical Representation",
      "section_title": true,
      "ja": "9.7.2. 字句表現"
    },
    {
      "indent": 3,
      "text": "The lexical representation of the bits type is a space-separated list of the names of the bits that are set. A zero-length string thus represents a value where no bits are set.",
      "ja": "ビットタイプの字句表現は、設定されたビットの名前のスペース区切りのリストです。長さゼロの文字列は、このように何ビットが設定されていない値を表します。"
    },
    {
      "indent": 0,
      "text": "9.7.3. Canonical Form",
      "section_title": true,
      "ja": "9.7.3.  Canonicalのフォーム"
    },
    {
      "indent": 3,
      "text": "In the canonical form, the bit values are separated by a single space character and they appear ordered by their position (see Section 9.7.4.2).",
      "ja": "標準的な形式で、ビット値は、単一の空白文字で区切られており、彼らは（セクション9.7.4.2を参照）の位置によって順序付けされて表示されます。"
    },
    {
      "indent": 0,
      "text": "9.7.4. The \"bit\" Statement",
      "section_title": true,
      "ja": "9.7.4.  「ビット」声明"
    },
    {
      "indent": 3,
      "text": "The \"bit\" statement, which is a substatement to the \"type\" statement, MUST be present if the type is \"bits\". It is repeatedly used to specify each assigned named bit of a bits type. It takes as an argument a string that is the assigned name of the bit. It is followed by a block of substatements that holds detailed bit information. The assigned name follows the same syntax rules as an identifier (see Section 6.2).",
      "ja": "タイプが「ビット」であれば「タイプ」ステートメントにサプある「ビット」の文では、存在しなければなりません。繰り返しビットタイプのそれぞれ割り当てられた名前のビットを指定するために使用されます。これは、引数としてビットの割り当てられた名前である文字列を取ります。なお、詳細なビットの情報を保持するサブステートメントのブロックが続きます。割り当てられた名前は、識別子と同じ構文規則に従う（セクション6.2を参照）。"
    },
    {
      "indent": 3,
      "text": "All assigned names in a bits type MUST be unique.",
      "ja": "ビットタイプのすべての割り当てられた名前は固有でなければなりません。"
    },
    {
      "indent": 0,
      "text": "9.7.4.1. The bit's Substatements",
      "section_title": true,
      "ja": "9.7.4.1。ビットのサブステートメント"
    },
    {
      "indent": 17,
      "text": "+--------------+---------+-------------+\n| substatement | section | cardinality |\n+--------------+---------+-------------+\n| description  | 7.21.3  | 0..1        |\n| if-feature   | 7.20.2  | 0..n        |\n| position     | 9.7.4.2 | 0..1        |\n| reference    | 7.21.4  | 0..1        |\n| status       | 7.21.2  | 0..1        |\n+--------------+---------+-------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "9.7.4.2. The \"position\" Statement",
      "section_title": true,
      "ja": "9.7.4.2。 「位置」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"position\" statement, which is optional, takes as an argument a non-negative integer value that specifies the bit's position within a hypothetical bit field. The position value MUST be in the range 0 to 4294967295, and it MUST be unique within the bits type.",
      "ja": "オプションである「位置」の文では、引数として仮想的なビットフィールド内のビットの位置を指定する非負の整数値をとります。位置の値は4294967295の範囲0でなければなりません、そして、それはビットタイプ内で一意でなければなりません。"
    },
    {
      "indent": 3,
      "text": "If a bit position is not specified, then one will be automatically assigned. If the \"bit\" substatement is the first one defined, the assigned value is zero (0); otherwise, the assigned value is one greater than the current highest bit position (i.e., the highest bit position, implicit or explicit, prior to the current \"bit\" substatement in the parent \"type\" statement).",
      "ja": "ビット位置が指定されていない場合は、1が自動的に割り当てられます。 「ビット」サプが定義されている最初のものである場合は、割り当てられた値は、ゼロ（0）です。そうでない場合、割り当てられた値は、最高の現在のビット位置より1大きい（すなわち、暗黙的または明示的な最上位のビット位置、親「タイプ」ステートメントで現在の「ビット」サプ前）。"
    },
    {
      "indent": 3,
      "text": "Note that the presence of an \"if-feature\" statement in a \"bit\" statement does not affect the automatically assigned position.",
      "ja": "「ビット」文で「IF-機能」の文の存在が自動的に割り当てられた位置には影響しないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "If the current highest bit position value is equal to 4294967295, then a position value MUST be specified for \"bit\" substatements following the one with the current highest position value.",
      "ja": "現在の最上位ビット位置値は4294967295に等しい場合、位置の値は、現在の最も高い位置の値を持つものを、以下「ビット」サブステートメントに指定されなければなりません。"
    },
    {
      "indent": 3,
      "text": "When an existing bits type is restricted, the \"position\" statement MUST either have the same value as in the base type or not be present, in which case the value is the same as in the base type.",
      "ja": "既存のビットのタイプが制限される場合、「位置」ステートメントは基本型と同じ値を持っているか、存在してはならないのいずれかで、その場合、値は基本タイプと同じです。"
    },
    {
      "indent": 0,
      "text": "9.7.5. Usage Example",
      "section_title": true,
      "ja": "9.7.5. 使用例"
    },
    {
      "indent": 3,
      "text": "Given the following typedef and leaf:",
      "ja": "次のtypedefと葉を考えます："
    },
    {
      "indent": 5,
      "text": "typedef mybits-type {\n  type bits {\n    bit disable-nagle {\n      position 0;\n    }\n    bit auto-sense-speed {\n      position 1;\n    }\n    bit ten-mb-only {\n      position 2;\n    }\n  }\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "leaf mybits {\n  type mybits-type;\n  default \"auto-sense-speed\";\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The lexical representation of this leaf with bit values disable-nagle and ten-mb-only set would be:",
      "ja": "ビットの値でこの葉の字句表現は-のNagleを無効にして、10-MB-のみのセットは次のようになります。"
    },
    {
      "indent": 5,
      "text": "<mybits>disable-nagle ten-mb-only</mybits>",
      "ja": "<MyBatisの>無効-ネーグル10-MB-のみ</ MyBatisの>"
    },
    {
      "indent": 3,
      "text": "The following example shows a legal refinement of this type:",
      "ja": "次の例では、この種の法律上の改善を示しています。"
    },
    {
      "indent": 5,
      "text": "type mybits-type {\n  // legal bit refinement\n  bit disable-nagle {\n    position 0;\n  }\n  bit auto-sense-speed {\n    position 1;\n  }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "and the following refinement is illegal:",
      "ja": "そして、次の改良が違法です："
    },
    {
      "indent": 5,
      "text": "type mybits-type { // illegal bit refinement bit disable-nagle { position 2; // illegal position change } bit hundred-mb-only; // illegal addition of new name }",
      "ja": "型mybits型{//不正ビットリファインメントビット無効-ネーグル{2位。 //不正位置変化は}百MB専用ビット。新しい名前の//違法追加}"
    },
    {
      "indent": 0,
      "text": "9.8. The binary Built-In Type",
      "section_title": true,
      "ja": "9.8. バイナリは、組み込み型"
    },
    {
      "indent": 3,
      "text": "The binary built-in type represents any binary data, i.e., a sequence of octets.",
      "ja": "内蔵型のバイナリは、任意のバイナリデータ、オクテット、すなわち、配列を表します。"
    },
    {
      "indent": 0,
      "text": "9.8.1. Restrictions",
      "section_title": true,
      "ja": "9.8.1. 制限事項"
    },
    {
      "indent": 3,
      "text": "A binary type can be restricted with the \"length\" (Section 9.4.4) statement. The length of a binary value is the number of octets it contains.",
      "ja": "バイナリ型は、「長さ」（9.4.4項）文で制限することができます。バイナリ値の長さは、それが含まれているオクテットの数です。"
    },
    {
      "indent": 0,
      "text": "9.8.2. Lexical Representation",
      "section_title": true,
      "ja": "9.8.2. 字句表現"
    },
    {
      "indent": 3,
      "text": "Binary values are encoded with the base64 encoding scheme (see Section 4 in [RFC4648]).",
      "ja": "バイナリ値（[RFC4648]セクション4を参照）BASE64符号化方式で符号化されます。"
    },
    {
      "indent": 0,
      "text": "9.8.3. Canonical Form",
      "section_title": true,
      "ja": "9.8.3.  Canonicalのフォーム"
    },
    {
      "indent": 3,
      "text": "The canonical form of a binary value follows the rules of \"Base 64 Encoding\" in [RFC4648].",
      "ja": "バイナリ値の標準形式は、[RFC4648]に「ベース64エンコーディング」の規則に従います。"
    },
    {
      "indent": 0,
      "text": "9.9. The leafref Built-In Type",
      "section_title": true,
      "ja": "9.9.  leafrefは、組み込み型"
    },
    {
      "indent": 3,
      "text": "The leafref built-in type is restricted to the value space of some leaf or leaf-list node in the schema tree and optionally further restricted by corresponding instance nodes in the data tree. The \"path\" substatement (Section 9.9.2) is used to identify the referred leaf or leaf-list node in the schema tree. The value space of the referring node is the value space of the referred node.",
      "ja": "leafrefビルトインタイプは、スキーマ・ツリー内のいくつかの葉または葉リストノードの値空間に制限し、必要に応じてさらなるデータツリー内のインスタンスノードを対応することによって制限されています。 「パス」サプ（セクション9.9.2）は、スキーマツリーでいう葉または葉リストノードを識別するために使用されます。参照ノードの値空間が呼ばノードの値空間です。"
    },
    {
      "indent": 3,
      "text": "If the \"require-instance\" property (Section 9.9.3) is \"true\", there MUST exist a node in the data tree, or a node with a default value in use (see Sections 7.6.1 and 7.7.2), of the referred schema tree leaf or leaf-list node with the same value as the leafref value in a valid data tree.",
      "ja": "「必要とするインスタンスの」プロパティ（セクション9.9.3）が「真」である場合、（セクション7.6.1および7.7.2を参照）は、データツリー内のノード、または使用中のデフォルト値を持つノードが存在しなければなりません、有効データツリーのleafref値と同じ値と呼ばれるスキーマ・ツリーの葉または葉リストノード。"
    },
    {
      "indent": 3,
      "text": "If the referring node represents configuration data and the \"require-instance\" property (Section 9.9.3) is \"true\", the referred node MUST also represent configuration.",
      "ja": "参照ノードは、コンフィギュレーションデータを表し、「必要インスタンスを」プロパティ（セクション9.9.3）が「真」である場合、呼ばれるノードは、構成を表現しなければなりません。"
    },
    {
      "indent": 3,
      "text": "There MUST NOT be any circular chains of leafrefs.",
      "ja": "leafrefsのいずれかの円形チェーンがあってはなりません。"
    },
    {
      "indent": 3,
      "text": "If the leaf that the leafref refers to is conditional based on one or more features (see Section 7.20.2), then the leaf with the leafref type MUST also be conditional based on at least the same set of features.",
      "ja": "leafrefが参照葉は、一つ以上の特徴に基づいて条件付きである場合（セクション7.20.2を参照）、次いでleafrefタイプの葉はまた、特徴の少なくとも同じセットに基づいて、条件付きでなければなりません。"
    },
    {
      "indent": 0,
      "text": "9.9.1. Restrictions",
      "section_title": true,
      "ja": "9.9.1. 制限事項"
    },
    {
      "indent": 3,
      "text": "A leafref can be restricted with the \"require-instance\" statement (Section 9.9.3).",
      "ja": "leafrefは「必要-インスタンスを」文（セクション9.9.3）で制限することができます。"
    },
    {
      "indent": 0,
      "text": "9.9.2. The \"path\" Statement",
      "section_title": true,
      "ja": "9.9.2.  「パス」ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"path\" statement, which is a substatement to the \"type\" statement, MUST be present if the type is \"leafref\". It takes as an argument a string that MUST refer to a leaf or leaf-list node.",
      "ja": "タイプが「leafref」であれば「タイプ」の文にサブステートメントである「パス」の文は、存在しなければなりません。これは、引数として、葉または葉-リストノードを参照する必要があります文字列を取ります。"
    },
    {
      "indent": 3,
      "text": "The syntax for a path argument is a subset of the XPath abbreviated syntax. Predicates are used only for constraining the values for the key nodes for list entries. Each predicate consists of exactly one equality test per key, and multiple adjacent predicates MAY be present if a list has multiple keys. The syntax is formally defined by the rule \"path-arg\" in Section 14.",
      "ja": "path引数の構文は、XPath省略構文のサブセットです。述語は、唯一のリストエントリのためのキーのノードの値を拘束するために使用されています。各述語は、キーごとに1つの平等のテストで構成されており、リストは複数のキーを持っている場合は、複数の隣接する述語が存在してもよいです。構文は正式に第14内のルール「パス引数」によって定義されます。"
    },
    {
      "indent": 3,
      "text": "The predicates are only used when more than one key reference is needed to uniquely identify a leaf instance. This occurs if a list has multiple keys or a reference to a leaf other than the key in a list is needed. In these cases, multiple leafrefs are typically specified, and predicates are used to tie them together.",
      "ja": "複数のキー参照を一意葉インスタンスを識別するために必要とされる場合述語にのみ使用されます。リストには、複数のキーまたは必要とされ、リスト内のキー以外のリーフへの参照を持っている場合に発生します。これらのケースでは、複数leafrefsは、典型的に指定され、述語は、それらを一緒に結ぶために使用されます。"
    },
    {
      "indent": 3,
      "text": "The \"path\" expression evaluates to a node set consisting of zero, one, or more nodes. If the \"require-instance\" property is \"true\", this node set MUST be non-empty.",
      "ja": "「経路」という表現は、ゼロ、1つ、または複数のノードからなるノードセットに評価します。 「必要-インスタンス」プロパティが「真」である場合、このノードセットが非空である必要があります。"
    },
    {
      "indent": 3,
      "text": "The \"path\" XPath expression is conceptually evaluated in the following context, in addition to the definition in Section 6.4.1:",
      "ja": "「パス」XPath式は、概念的6.4.1における定義に加えて、次のコンテキストで評価されています。"
    },
    {
      "indent": 3,
      "text": "o If the \"path\" statement is defined within a typedef, the context node is the leaf or leaf-list node in the data tree that references the typedef.",
      "ja": "「パス」文がtypedefの内で定義されている場合は、O、コンテキストノードは、typedefのを参照するデータツリーのリーフまたはリーフ・リストノードです。"
    },
    {
      "indent": 3,
      "text": "o Otherwise, the context node is the node in the data tree for which the \"path\" statement is defined.",
      "ja": "Oそれ以外の場合は、コンテキストノードが「パス」文が定義されているデータツリー内のノードです。"
    },
    {
      "indent": 0,
      "text": "9.9.3. The \"require-instance\" Statement",
      "section_title": true,
      "ja": "9.9.3.  「必要-インスタンスを」文"
    },
    {
      "indent": 3,
      "text": "The \"require-instance\" statement, which is a substatement to the \"type\" statement, MAY be present if the type is \"instance-identifier\" or \"leafref\". It takes as an argument the string \"true\" or \"false\". If this statement is not present, it defaults to \"true\".",
      "ja": "種別が「インスタンス識別子」または「leafref」であれば「タイプ」ステートメントにサプある「必要インスタンス」のステートメントは、存在してもよいです。これは、引数として文字列を取り、「true」または「false」。この文は、デフォルト値「真」に存在しない場合。"
    },
    {
      "indent": 3,
      "text": "If \"require-instance\" is \"true\", it means that the instance being referred to MUST exist for the data to be valid. This constraint is enforced according to the rules in Section 8.",
      "ja": "「インスタンスを必要とし、」「真」であれば、それはインスタンスが参照されることを意味したデータが有効であるために存在しなければなりません。この制約は、第8章の規則に従って実施されます。"
    },
    {
      "indent": 3,
      "text": "If \"require-instance\" is \"false\", it means that the instance being referred to MAY exist in valid data.",
      "ja": "「必要-インスタンスは、」「偽」である場合、それはインスタンスが有効なデータで存在することができるために参照されることを意味します。"
    },
    {
      "indent": 0,
      "text": "9.9.4. Lexical Representation",
      "section_title": true,
      "ja": "9.9.4. 字句表現"
    },
    {
      "indent": 3,
      "text": "A leafref value is lexically represented the same way as the leaf it references represents its value.",
      "ja": "leafref値は、字句が参照葉がその値を表すのと同じ方法で表されています。"
    },
    {
      "indent": 0,
      "text": "9.9.5. Canonical Form",
      "section_title": true,
      "ja": "9.9.5.  Canonicalのフォーム"
    },
    {
      "indent": 3,
      "text": "The canonical form of a leafref is the same as the canonical form of the leaf it references.",
      "ja": "leafrefの正規の形式は、それが参照する葉の正規の形式と同じです。"
    },
    {
      "indent": 0,
      "text": "9.9.6. Usage Example",
      "section_title": true,
      "ja": "9.9.6. 使用例"
    },
    {
      "indent": 3,
      "text": "With the following list:",
      "ja": "以下のリストの場合："
    },
    {
      "indent": 5,
      "text": "list interface {\n  key \"name\";\n  leaf name {\n    type string;\n  }\n  leaf admin-status {\n    type admin-status;\n  }\n  list address {\n    key \"ip\";\n    leaf ip {\n      type yang:ip-address;\n    }\n  }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "the following leafref refers to an existing interface:",
      "ja": "次leafrefは、既存のインタフェースを参照します。"
    },
    {
      "indent": 5,
      "text": "leaf mgmt-interface { type leafref { path \"../interface/name\"; } }",
      "ja": "葉MGMTインターフェイス{型leafref {パス「../interface/name」。 }}"
    },
    {
      "indent": 3,
      "text": "An example of a corresponding XML snippet:",
      "ja": "対応するXMLスニペットの例："
    },
    {
      "indent": 5,
      "text": "<interface> <name>eth0</name> </interface> <interface> <name>lo</name> </interface>",
      "ja": "<インターフェース> <名前>はeth0 </名前> </インターフェイス> <インターフェイス> <名前> LO </名前> </インターフェイス>"
    },
    {
      "indent": 5,
      "text": "<mgmt-interface>eth0</mgmt-interface>",
      "ja": "<MGMTインターフェイス> eth0の</ MGMTインターフェイス>"
    },
    {
      "indent": 3,
      "text": "The following leafrefs refer to an existing address of an interface:",
      "ja": "次leafrefsは、インターフェイスの既存のアドレスを参照してください。"
    },
    {
      "indent": 5,
      "text": "container default-address {\n  leaf ifname {\n    type leafref {\n      path \"../../interface/name\";\n    }\n  }\n  leaf address {\n    type leafref {\n      path \"../../interface[name = current()/../ifname]\"\n         + \"/address/ip\";\n    }\n  }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "An example of a corresponding XML snippet:",
      "ja": "対応するXMLスニペットの例："
    },
    {
      "indent": 5,
      "text": "<interface> <name>eth0</name> <admin-status>up</admin-status> <address> <ip>192.0.2.1</ip> </address> <address> <ip>192.0.2.2</ip> </address> </interface> <interface> <name>lo</name> <admin-status>up</admin-status> <address> <ip>127.0.0.1</ip> </address> </interface>",
      "ja": "<インターフェース> <名前>はeth0 </名前> </管理ステータス>アップ<管理ステータス> <アドレス> <IP> 192.0.2.1 </ IP> </アドレス> <アドレス> <IP> 192.0.2.2 < </管理ステータス> <アドレス> <IP> 127.0.0.1 </ IP> </アドレスアップ/ IP> </アドレス> </インターフェイス> <インターフェイス> <名前> LO </名前> <管理状況> > </インターフェイス>"
    },
    {
      "indent": 5,
      "text": "<default-address> <ifname>eth0</ifname> <address>192.0.2.2</address> </default-address>",
      "ja": "<デフォルト・アドレス> <ifnameの>はeth0 </ ifnameの> <アドレス> 192.0.2.2 </アドレス> </デフォルトアドレス>"
    },
    {
      "indent": 3,
      "text": "The following list uses a leafref for one of its keys. This is similar to a foreign key in a relational database.",
      "ja": "以下のリストは、そのキーのいずれかのためにleafrefを使用しています。これは、リレーショナル・データベースの外部キーに似ています。"
    },
    {
      "indent": 5,
      "text": "list packet-filter {\n  key \"if-name filter-id\";\n  leaf if-name {\n    type leafref {\n      path \"/interface/name\";\n    }\n  }\n  leaf filter-id {\n    type uint32;\n  }\n  ...\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "An example of a corresponding XML snippet:",
      "ja": "対応するXMLスニペットの例："
    },
    {
      "indent": 5,
      "text": "<interface> <name>eth0</name> <admin-status>up</admin-status> <address> <ip>192.0.2.1</ip> </address> <address> <ip>192.0.2.2</ip> </address> </interface>",
      "ja": "<インターフェース> <名前>はeth0 </名前> </管理ステータス>アップ<管理ステータス> <アドレス> <IP> 192.0.2.1 </ IP> </アドレス> <アドレス> <IP> 192.0.2.2 < / IP> </アドレス> </インターフェイス>"
    },
    {
      "indent": 5,
      "text": "<packet-filter> <if-name>eth0</if-name> <filter-id>1</filter-id> ... </packet-filter> <packet-filter> <if-name>eth0</if-name> <filter-id>2</filter-id> ... </packet-filter>",
      "ja": "<パケットフィルタ> <IF-名> eth0の</ IF-名> <フィルタ-ID> 1 </フィルタ-ID> ... </パケットフィルタ> <パケットフィルタ> <IF-名> eth0の< / IF-名> <フィルタ-ID> 2 </フィルタ-ID> ... </パケットフィルタ>"
    },
    {
      "indent": 3,
      "text": "The following notification defines two leafrefs to refer to an existing admin-status:",
      "ja": "次の通知は、既存の管理ステータスを参照するには、2つのleafrefsを定義しています。"
    },
    {
      "indent": 5,
      "text": "notification link-failure {\n  leaf if-name {\n    type leafref {\n      path \"/interface/name\";\n    }\n  }\n  leaf admin-status {\n    type leafref {\n      path \"/interface[name = current()/../if-name]\"\n         + \"/admin-status\";\n    }\n  }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "An example of a corresponding XML notification:",
      "ja": "対応するXML通知の例："
    },
    {
      "indent": 5,
      "text": "<notification xmlns=\"urn:ietf:params:xml:ns:netconf:notification:1.0\"> <eventTime>2008-04-01T00:01:00Z</eventTime> <link-failure xmlns=\"urn:example:system\"> <if-name>eth0</if-name> <admin-status>up</admin-status> </link-failure> </notification>",
      "ja": "<通知のxmlns = \"URN：IETF：paramsは：XML：NS：NETCONF：通知：1.0\"> <イベント時刻> 2008-04-01T00：01：00Z </イベント時刻> <リンク障害のxmlns = \"URN：例：システム「> <IF-名>はeth0 </ IF-名> </管理ステータスアップ<管理ステータス>> </リンク障害> </通知>"
    },
    {
      "indent": 0,
      "text": "9.10. The identityref Built-In Type",
      "section_title": true,
      "ja": "9.10.  identityrefは、組み込み型"
    },
    {
      "indent": 3,
      "text": "The identityref built-in type is used to reference an existing identity (see Section 7.18).",
      "ja": "内蔵型identityrefは、既存のアイデンティティ（セクション7.18を参照）を参照するために使用されます。"
    },
    {
      "indent": 0,
      "text": "9.10.1. Restrictions",
      "section_title": true,
      "ja": "9.10.1. 制限事項"
    },
    {
      "indent": 3,
      "text": "An identityref cannot be restricted.",
      "ja": "identityrefを制限することはできません。"
    },
    {
      "indent": 0,
      "text": "9.10.2. The identityref's \"base\" Statement",
      "section_title": true,
      "ja": "9.10.2.  identityrefの「ベース」声明"
    },
    {
      "indent": 3,
      "text": "The \"base\" statement, which is a substatement to the \"type\" statement, MUST be present at least once if the type is \"identityref\". The argument is the name of an identity, as defined by an \"identity\" statement. If a prefix is present on the identity name, it refers to an identity defined in the module that was imported with that prefix. Otherwise, an identity with the matching name MUST be defined in the current module or an included submodule.",
      "ja": "タイプが「identityref」であれば「タイプ」の文にサブステートメントである「ベース」の文では、少なくとも1回存在しなければなりません。 「アイデンティティ」の文で定義された引数は、アイデンティティーの名前です。接頭辞がID名に存在する場合、それはその接頭辞でインポートされたモジュールで定義された同一性をいいます。そうでない場合は、一致する名前を持つアイデンティティは、現在のモジュールまたは含まサブモジュールで定義されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Valid values for an identityref are any identities derived from all the identityref's base identities. On a particular server, the valid values are further restricted to the set of identities defined in the modules implemented by the server.",
      "ja": "identityrefの有効な値は、すべてのidentityrefの基本アイデンティティ由来の任意のIDです。特定のサーバーでは、有効な値は、さらに、サーバによって実装モジュールで定義されたアイデンティティのセットに制限されています。"
    },
    {
      "indent": 0,
      "text": "9.10.3. Lexical Representation",
      "section_title": true,
      "ja": "9.10.3. 字句表現"
    },
    {
      "indent": 3,
      "text": "An identityref is lexically represented as the referred identity's qualified name as defined in [XML-NAMES]. If the prefix is not present, the namespace of the identityref is the default namespace in effect on the element that contains the identityref value.",
      "ja": "[XML-NAMES]で定義されているようidentityrefは、辞書的に呼ばアイデンティティの修飾名として表されます。接頭辞が存在しない場合は、identityrefの名前空間はidentityref値が含まれている要素の影響で、既定の名前空間です。"
    },
    {
      "indent": 3,
      "text": "When an identityref is given a default value using the \"default\" statement, the identity name in the default value MAY have a prefix. If a prefix is present on the identity name, it refers to an identity defined in the module that was imported with that prefix, or the prefix for the current module if the identity is defined in the current module or one of its submodules. Otherwise, an identity with the matching name MUST be defined in the current module or one of its submodules.",
      "ja": "identityrefが「デフォルト」の文を使用してデフォルト値が与えられた場合、デフォルト値のID名は、接頭辞を持っているかもしれません。プレフィックスが識別名に存在する場合、同一性は、現在のモジュールまたはサブモジュールのいずれかで定義されている場合、その接頭辞でインポートされたモジュールで定義されたアイデンティティ、または現在のモジュールの接頭辞を指します。そうでない場合は、一致する名前を持つアイデンティティは、現在のモジュールまたはサブモジュールのいずれかで定義されなければなりません。"
    },
    {
      "indent": 3,
      "text": "The string value of a node of type \"identityref\" in a \"must\" or \"when\" XPath expression is the referred identity's qualified name with the prefix present. If the referred identity is defined in an imported module, the prefix in the string value is the prefix defined in the corresponding \"import\" statement. Otherwise, the prefix in the string value is the prefix for the current module.",
      "ja": "「しなければならない」または「」XPath式は接頭辞存在と呼ばアイデンティティの修飾名ですにおけるタイプのノードの文字列値「identityref」。呼ばアイデンティティがインポートされたモジュールで定義されている場合、文字列値の接頭辞は、対応する「インポート」文で定義された接頭辞です。それ以外の場合は、文字列値の接頭辞は、現在のモジュールの接頭辞です。"
    },
    {
      "indent": 0,
      "text": "9.10.4. Canonical Form",
      "section_title": true,
      "ja": "9.10.4.  Canonicalのフォーム"
    },
    {
      "indent": 3,
      "text": "Since the lexical form depends on the XML context in which the value occurs, this type does not have a canonical form.",
      "ja": "字句形式は、値が発生するXMLコンテキストに依存するため、このタイプの標準形を有していません。"
    },
    {
      "indent": 0,
      "text": "9.10.5. Usage Example",
      "section_title": true,
      "ja": "9.10.5. 使用例"
    },
    {
      "indent": 3,
      "text": "With the identity definitions in Section 7.18.3 and the following module:",
      "ja": "セクション7.18.3でのアイデンティティの定義と、次のモジュールでは："
    },
    {
      "indent": 5,
      "text": "module example-my-crypto {\n  yang-version 1.1;\n  namespace \"urn:example:my-crypto\";\n  prefix mc;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "import \"example-crypto-base\" { prefix \"crypto\"; }",
      "ja": "インポート「例、暗号ベース」{接頭辞「暗号」。 }"
    },
    {
      "indent": 7,
      "text": "identity aes { base \"crypto:crypto-alg\"; }",
      "ja": "アイデンティティAES {塩基「暗号：暗号-ALG」。 }"
    },
    {
      "indent": 7,
      "text": "leaf crypto { type identityref { base \"crypto:crypto-alg\"; } }",
      "ja": "リーフ暗号{型identityref {塩基「暗号：暗号-ALG」。 }}"
    },
    {
      "indent": 5,
      "text": " container aes-parameters { when \"../crypto = 'mc:aes'\"; ... } }",
      "ja": "容器AES-パラメータ{ \"../crypto = 'MC：AES'\"; ...}}"
    },
    {
      "indent": 3,
      "text": "the following is an example of how the leaf \"crypto\" can be encoded, if the value is the \"des3\" identity defined in the \"des\" module:",
      "ja": "値が「DES」モジュールで定義された「DES3」同一である場合、次のは、リーフ「暗号」が符号化することができる方法の例です。"
    },
    {
      "indent": 5,
      "text": "<crypto xmlns:des=\"urn:example:des\">des:des3</crypto>",
      "ja": "<暗号のxmlns：デ= \"壷：exemple：デ\">デ：DES3 </暗号>"
    },
    {
      "indent": 3,
      "text": "Any prefixes used in the encoding are local to each instance encoding. This means that the same identityref may be encoded differently by different implementations. For example, the following example encodes the same leaf as above:",
      "ja": "符号化に使用される任意の接頭辞は、各インスタンスのエンコーディングに対してローカルです。これは、同じidentityrefが異なる実装によって異なって符号化することができることを意味します。例えば、次の例では、上記と同じ葉をコード"
    },
    {
      "indent": 5,
      "text": "<crypto xmlns:x=\"urn:example:des\">x:des3</crypto>",
      "ja": "<暗号のxmlns：X = \"URN：例：DES\"> X：DES3 </暗号>"
    },
    {
      "indent": 3,
      "text": "If the \"crypto\" leaf's value is instead \"aes\", defined in the \"example-my-crypto\" module, it can be encoded as:",
      "ja": "「暗号」の葉の値ではなく、「例 - 私の-暗号」モジュールで定義された「AES」、であるならば、それは次のようにコード化することができます。"
    },
    {
      "indent": 5,
      "text": "<crypto xmlns:mc=\"urn:example:my-crypto\">mc:aes</crypto>",
      "ja": "<暗号のxmlns：MC = \"壷：例：私の-暗号\"> MC：AES </暗号>"
    },
    {
      "indent": 3,
      "text": "or, using the default namespace:",
      "ja": "または、デフォルトの名前空間を使用しました："
    },
    {
      "indent": 5,
      "text": "<crypto>aes</crypto>",
      "ja": "<暗号> AES </暗号>"
    },
    {
      "indent": 0,
      "text": "9.11. The empty Built-In Type",
      "section_title": true,
      "ja": "9.11. 空のビルトインタイプ"
    },
    {
      "indent": 3,
      "text": "The empty built-in type represents a leaf that does not have any value; it conveys information by its presence or absence.",
      "ja": "空のビルトインタイプは、任意の値を持っていない葉を表し、それは、その存在または不在により情報を伝達します。"
    },
    {
      "indent": 3,
      "text": "An empty type cannot have a default value.",
      "ja": "空のタイプは、デフォルト値を持つことができません。"
    },
    {
      "indent": 0,
      "text": "9.11.1. Restrictions",
      "section_title": true,
      "ja": "9.11.1. 制限事項"
    },
    {
      "indent": 3,
      "text": "An empty type cannot be restricted.",
      "ja": "空のタイプを制限することはできません。"
    },
    {
      "indent": 0,
      "text": "9.11.2. Lexical Representation",
      "section_title": true,
      "ja": "9.11.2. 字句表現"
    },
    {
      "indent": 3,
      "text": "Not applicable.",
      "ja": "適用できません。"
    },
    {
      "indent": 0,
      "text": "9.11.3. Canonical Form",
      "section_title": true,
      "ja": "9.11.3.  Canonicalのフォーム"
    },
    {
      "indent": 3,
      "text": "Not applicable.",
      "ja": "適用できません。"
    },
    {
      "indent": 0,
      "text": "9.11.4. Usage Example",
      "section_title": true,
      "ja": "9.11.4. 使用例"
    },
    {
      "indent": 3,
      "text": "With the following leaf:",
      "ja": "次の葉を持ちます："
    },
    {
      "indent": 5,
      "text": "leaf enable-qos { type empty; }",
      "ja": "リーフ有効-QOS {タイプ空。 }"
    },
    {
      "indent": 3,
      "text": "the following is an example of a valid encoding if the leaf exists:",
      "ja": "葉が存在する場合は、次は、有効なエンコーディングの例です。"
    },
    {
      "indent": 5,
      "text": "<enable-qos/>",
      "ja": "<有効-QOS />"
    },
    {
      "indent": 0,
      "text": "9.12. The union Built-In Type",
      "section_title": true,
      "ja": "9.12. 労働組合は、組み込み型"
    },
    {
      "indent": 3,
      "text": "The union built-in type represents a value that corresponds to one of its member types.",
      "ja": "内蔵型組合は、そのメンバーの種類のいずれかに対応する値を表しています。"
    },
    {
      "indent": 3,
      "text": "When the type is \"union\", the \"type\" statement (Section 7.4) MUST be present. It is repeatedly used to specify each member type of the union. It takes as an argument a string that is the name of a member type.",
      "ja": "タイプが「労働組合」である場合には、「タイプ」の文（7.4節）が存在しなければなりません。これを繰り返し組合の各メンバーの種類を指定するために使用されます。これは、引数としてメンバ型の名前である文字列を取ります。"
    },
    {
      "indent": 3,
      "text": "A member type can be of any built-in or derived type.",
      "ja": "メンバー型は、任意の組み込みまたは派生タイプのものとすることができます。"
    },
    {
      "indent": 3,
      "text": "When generating an XML encoding, a value is encoded according to the rules of the member type to which the value belongs. When interpreting an XML encoding, a value is validated consecutively against each member type, in the order they are specified in the \"type\" statement, until a match is found. The type that matched will be the type of the value for the node that was validated, and the encoding is interpreted according to the rules for that type.",
      "ja": "XMLエンコーディングを生成するときに、値が値が属するメンバータイプの規則に従って符号化されます。 XMLエンコーディングを解釈するとき、値が一致するものが見つかるまで、それらは、「タイプ」ステートメントで指定された順序で、各メンバーのタイプに対して連続的に検証されています。一致タイプは、検証されたノードの値の型となり、符号化されたタイプの規則に従って解釈されます。"
    },
    {
      "indent": 3,
      "text": "Any default value or \"units\" property defined in the member types is not inherited by the union type.",
      "ja": "メンバーの種類で定義されたデフォルト値または「単位」プロパティは、労働組合の種類によって継承されていません。"
    },
    {
      "indent": 0,
      "text": "9.12.1. Restrictions",
      "section_title": true,
      "ja": "9.12.1. 制限事項"
    },
    {
      "indent": 3,
      "text": "A union cannot be restricted. However, each member type can be restricted, based on the rules defined in Section 9.",
      "ja": "労働組合は、制限することはできません。しかし、各メンバーの種類は、セクション9で定義された規則に基づいて、制限することができます。"
    },
    {
      "indent": 0,
      "text": "9.12.2. Lexical Representation",
      "section_title": true,
      "ja": "9.12.2. 字句表現"
    },
    {
      "indent": 3,
      "text": "The lexical representation of a union is a value that corresponds to the representation of any one of the member types.",
      "ja": "組合の字句表現は、部材の種類のいずれかの表現に対応する値です。"
    },
    {
      "indent": 0,
      "text": "9.12.3. Canonical Form",
      "section_title": true,
      "ja": "9.12.3.  Canonicalのフォーム"
    },
    {
      "indent": 3,
      "text": "The canonical form of a union value is the same as the canonical form of the member type of the value.",
      "ja": "組合値の標準形式は、値のメンバー型の正規の形式と同じです。"
    },
    {
      "indent": 0,
      "text": "9.12.4. Usage Example",
      "section_title": true,
      "ja": "9.12.4. 使用例"
    },
    {
      "indent": 3,
      "text": "The following is a union of an int32 and an enumeration:",
      "ja": "以下は、INT32と列挙の労働組合です。"
    },
    {
      "indent": 5,
      "text": "type union {\n  type int32;\n  type enumeration {\n    enum \"unbounded\";\n  }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Care must be taken when a member type is a leafref where the \"require-instance\" property (Section 9.9.3) is \"true\". If a leaf of such a type refers to an existing instance, the leaf's value must be revalidated if the target instance is deleted. For example, with the following definitions:",
      "ja": "メンバーの種類が「必要-インスタンスを」プロパティ（セクション9.9.3）が「真」であるleafrefあるときには注意する必要があります。そのようなタイプの葉は、既存のインスタンスを参照する場合は、ターゲット・インスタンスが削除された場合、葉の値を再検証する必要があります。たとえば、次の定義を持ちます："
    },
    {
      "indent": 5,
      "text": "list filter {\n  key name;\n  leaf name {\n    type string;\n  }\n  ...\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "leaf outbound-filter {\n  type union {\n    type leafref {\n      path \"/filter/name\";\n    }\n    type enumeration {\n      enum default-filter;\n    }\n  }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "assume that there exists an entry in the filter list with the name \"http\" and that the outbound-filter leaf has this value:",
      "ja": "名前に「http」とフィルタリストのエントリが存在することとアウトバウンドフィルタの葉がこの値を持っていることを前提としています。"
    },
    {
      "indent": 5,
      "text": "<filter> <name>http</name> </filter> <outbound-filter>http</outbound-filter>",
      "ja": "<フィルタ> <名前> HTTP </名前> </フィルタ> <アウトバウンドフィルタ> HTTP </アウトバウンドフィルタ>"
    },
    {
      "indent": 3,
      "text": "If the filter entry \"http\" is removed, the outbound-filter leaf's value doesn't match the leafref, and the next member type is checked. The current value (\"http\") doesn't match the enumeration, so the resulting configuration is invalid.",
      "ja": "フィルタエントリは「http」が削除された場合、アウトバウンドフィルタの葉の値がleafrefと一致しないと、次のメンバータイプがチェックされます。電流値（「HTTP」）が列挙一致しないので、結果として得られる構成が無効です。"
    },
    {
      "indent": 3,
      "text": "If the second member type in the union had been of type \"string\" instead of an enumeration, the current value would have matched, and the resulting configuration would have been valid.",
      "ja": "組合における第二の部材の種類は、型「string」の代わりに列挙されていた場合は、現在の値が一致しているだろう、と結果の構成が有効であったであろう。"
    },
    {
      "indent": 0,
      "text": "9.13. The instance-identifier Built-In Type",
      "section_title": true,
      "ja": "9.13. 内蔵型インスタンス識別子"
    },
    {
      "indent": 3,
      "text": "The instance-identifier built-in type is used to uniquely identify a particular instance node in the data tree.",
      "ja": "内蔵型インスタンス識別子は、一意のデータ・ツリー内の特定のインスタンスのノードを識別するために使用されます。"
    },
    {
      "indent": 3,
      "text": "The syntax for an instance-identifier is a subset of the XPath abbreviated syntax, formally defined by the rule \"instance-identifier\" in Section 14. It is used to uniquely identify a node in the data tree. Predicates are used only for specifying the values for the key nodes for list entries, a value of a leaf-list entry, or a positional index for a list without keys. For identifying list entries with keys, each predicate consists of one equality test per key, and each key MUST have a corresponding predicate. If a key is of type \"empty\", it is represented as a zero-length string (\"\").",
      "ja": "インスタンス識別子の構文は正式にそれを一意のデータツリー内のノードを識別するために使用される第14のルール「インスタンス識別子」によって定義されたXPath省略構文のサブセットです。述語のみリストエントリ、リーフリストエントリの値、またはキーなしのリストのための位置インデックスのキーのノードの値を指定するために使用されます。キーを使用してリスト項目を識別するため、各述語は、キーごとに等価のテストで構成され、各キーは、対応する述語を持たなければなりません。鍵のタイプが「空」である場合、それはゼロ長の文字列（「」）として表されます。"
    },
    {
      "indent": 3,
      "text": "If the leaf with the instance-identifier type represents configuration data and the \"require-instance\" property (Section 9.9.3) is \"true\", the node it refers to MUST also represent configuration. Such a leaf puts a constraint on valid data. All such leaf nodes MUST reference existing nodes or leaf or leaf-list nodes with their default value in use (see Sections 7.6.1 and 7.7.2) for the data to be valid. This constraint is enforced according to the rules in Section 8.",
      "ja": "インスタンス識別子タイプの葉は、構成データを表し、「必要インスタンスを」プロパティ（セクション9.9.3）が「真」である場合、それが指すノードは、構成を表現しなければなりません。このような葉は、有効なデータに制約を置きます。このようなすべてのリーフノードが有効であるためにデータのために（セクション7.6.1と7.7.2を参照）、使用中のデフォルト値を持つ既存のノードまたは葉または葉・リストのノードを参照する必要があります。この制約は、第8章の規則に従って実施されます。"
    },
    {
      "indent": 3,
      "text": "The \"instance-identifier\" XPath expression is conceptually evaluated in the following context, in addition to the definition in Section 6.4.1:",
      "ja": "「インスタンス識別子」XPath式は、概念的セクション6.4.1で定義に加えて、次のコンテキストで評価されます。"
    },
    {
      "indent": 3,
      "text": "o The context node is the root node in the accessible tree.",
      "ja": "Oコンテキストノードがアクセス可能ツリーのルートノードがあります。"
    },
    {
      "indent": 0,
      "text": "9.13.1. Restrictions",
      "section_title": true,
      "ja": "9.13.1. 制限事項"
    },
    {
      "indent": 3,
      "text": "An instance-identifier can be restricted with the \"require-instance\" statement (Section 9.9.3).",
      "ja": "インスタンス識別子は、「必要-インスタンスを」文（セクション9.9.3）で制限することができます。"
    },
    {
      "indent": 0,
      "text": "9.13.2. Lexical Representation",
      "section_title": true,
      "ja": "9.13.2. 字句表現"
    },
    {
      "indent": 3,
      "text": "An instance-identifier value is lexically represented as a string. All node names in an instance-identifier value MUST be qualified with explicit namespace prefixes, and these prefixes MUST be declared in the XML namespace scope in the instance-identifier's XML element.",
      "ja": "インスタンス識別子の値は、字句文字列として表されます。インスタンス識別子の値のすべてのノード名は、明示的な名前空間接頭辞で修飾する必要があり、そしてこれらのプレフィックスは、インスタンス識別子のXML要素でXML名前空間のスコープ内で宣言されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Any prefixes used in the encoding are local to each instance encoding. This means that the same instance-identifier may be encoded differently by different implementations.",
      "ja": "符号化に使用される任意の接頭辞は、各インスタンスのエンコーディングに対してローカルです。これは、同じインスタンス識別子は、異なる実装によって異なって符号化することができることを意味します。"
    },
    {
      "indent": 0,
      "text": "9.13.3. Canonical Form",
      "section_title": true,
      "ja": "9.13.3.  Canonicalのフォーム"
    },
    {
      "indent": 3,
      "text": "Since the lexical form depends on the XML context in which the value occurs, this type does not have a canonical form.",
      "ja": "字句形式は、値が発生するXMLコンテキストに依存するため、このタイプの標準形を有していません。"
    },
    {
      "indent": 0,
      "text": "9.13.4. Usage Example",
      "section_title": true,
      "ja": "9.13.4. 使用例"
    },
    {
      "indent": 3,
      "text": "The following are examples of instance identifiers:",
      "ja": "以下は、インスタンス識別子の例です："
    },
    {
      "indent": 5,
      "text": "/* instance-identifier for a container */\n/ex:system/ex:services/ex:ssh",
      "raw": true
    },
    {
      "indent": 5,
      "text": "/* instance-identifier for a leaf */\n/ex:system/ex:services/ex:ssh/ex:port",
      "raw": true
    },
    {
      "indent": 5,
      "text": "/* instance-identifier for a list entry */\n/ex:system/ex:user[ex:name='fred']",
      "raw": true
    },
    {
      "indent": 5,
      "text": "/* instance-identifier for a leaf in a list entry */\n/ex:system/ex:user[ex:name='fred']/ex:type",
      "raw": true
    },
    {
      "indent": 5,
      "text": "/* instance-identifier for a list entry with two keys */\n/ex:system/ex:server[ex:ip='192.0.2.1'][ex:port='80']",
      "raw": true
    },
    {
      "indent": 5,
      "text": "/* instance-identifier for a list entry where the second\n   key (\"enabled\") is of type \"empty\" */\n/ex:system/ex:service[ex:name='foo'][ex:enabled='']",
      "raw": true
    },
    {
      "indent": 5,
      "text": "/* instance-identifier for a leaf-list entry */\n/ex:system/ex:services/ex:ssh/ex:cipher[.='blowfish-cbc']",
      "raw": true
    },
    {
      "indent": 5,
      "text": "/* instance-identifier for a list entry without keys */\n/ex:stats/ex:port[3]",
      "raw": true
    },
    {
      "indent": 0,
      "text": "10. XPath Functions",
      "section_title": true,
      "ja": "10. XPath関数"
    },
    {
      "indent": 3,
      "text": "This document defines two generic XPath functions and five YANG type-specific XPath functions. The function signatures are specified with the syntax used in [XPATH].",
      "ja": "この文書では、一般的な2つのXPath関数と5 YANGタイプ固有のXPath関数を定義します。関数シグネチャは、[XPATH]で使用される構文で指定されています。"
    },
    {
      "indent": 0,
      "text": "10.1. Function for Node Sets",
      "section_title": true,
      "ja": "10.1. ノードセットの機能"
    },
    {
      "indent": 0,
      "text": "10.1.1. current()",
      "section_title": true,
      "ja": "10.1.1. 現在（）"
    },
    {
      "indent": 5,
      "text": "node-set current()",
      "ja": "ノードセット電流（）"
    },
    {
      "indent": 3,
      "text": "The current() function takes no input parameters and returns a node set with the initial context node as its only member.",
      "ja": "現在の（）関数は、入力パラメータを取らず、その唯一のメンバーとして初期コンテキストノードとノードセットを返します。"
    },
    {
      "indent": 0,
      "text": "10.1.1.1. Usage Example",
      "section_title": true,
      "ja": "10.1.1.1。使用例"
    },
    {
      "indent": 3,
      "text": "With this list:",
      "ja": "このリストでは："
    },
    {
      "indent": 5,
      "text": "list interface {\n  key \"name\";\n  ...\n  leaf enabled {\n    type boolean;\n  }\n  ...\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "the following leaf defines a \"must\" expression that ensures that the referred interface is enabled:",
      "ja": "次葉が呼ばインターフェースが有効になっていることを確認し、「しなければならない」という表現を定義しています。"
    },
    {
      "indent": 5,
      "text": "leaf outgoing-interface {\n  type leafref {\n    path \"/interface/name\";\n  }\n  must '/interface[name=current()]/enabled = \"true\"';\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "10.2. Function for Strings",
      "section_title": true,
      "ja": "10.2. 弦楽のための機能"
    },
    {
      "indent": 0,
      "text": "10.2.1. re-match()",
      "section_title": true,
      "ja": "10.2.1. 再戦（）"
    },
    {
      "indent": 5,
      "text": "boolean re-match(string subject, string pattern)",
      "ja": "ブール再マッチ（文字列サブジェクト、文字列パターン）"
    },
    {
      "indent": 3,
      "text": "The re-match() function returns \"true\" if the \"subject\" string matches the regular expression \"pattern\"; otherwise, it returns \"false\".",
      "ja": "「対象」の文字列が、正規表現「パターン」と一致する場合、再試合（）関数は、「真」を返します。それ以外の場合は、「false」を返します。"
    },
    {
      "indent": 3,
      "text": "The re-match() function checks to see if a string matches a given regular expression. The regular expressions used are the XML Schema regular expressions [XSD-TYPES]. Note that this includes implicit anchoring of the regular expression at the head and tail.",
      "ja": "再試合（）関数は、文字列が与えられた正規表現と一致するかどうかを確認します。使用される正規表現は、XMLスキーマの正規表現[XSD-TYPES]です。これは、頭と尾での正規表現の暗黙のアンカーが含まれていることに注意してください。"
    },
    {
      "indent": 0,
      "text": "10.2.1.1. Usage Example",
      "section_title": true,
      "ja": "10.2.1.1。使用例"
    },
    {
      "indent": 3,
      "text": "The expression:",
      "ja": "表現："
    },
    {
      "indent": 5,
      "text": "re-match(\"1.22.333\", \"\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\")",
      "ja": "再マッチ（ \"1.22.333\"、 \"\\ D {1,3} \\ \\ D {1,3} \\ \\ D {1,3}\"）"
    },
    {
      "indent": 3,
      "text": "returns \"true\".",
      "ja": "\"true\" を返します。"
    },
    {
      "indent": 3,
      "text": "To count all logical interfaces called eth0.<number>, do:",
      "ja": "。はeth0と呼ばれるすべての論理インタフェースをカウントする<番号>、実行します。"
    },
    {
      "indent": 5,
      "text": "count(/interface[re-match(name, \"eth0\\.\\d+\")])",
      "ja": "（/インターフェース[再試合（名前、 \"eth0の\\。\\ dは+\"）]）カウント"
    },
    {
      "indent": 0,
      "text": "10.3. Function for the YANG Types \"leafref\" and \"instance-identifier\"",
      "section_title": true,
      "ja": "10.3.  YANGタイプ「leafref」と「インスタンス識別子」のための機能"
    },
    {
      "indent": 0,
      "text": "10.3.1. deref()",
      "section_title": true,
      "ja": "10.3.1.  DEREF（）"
    },
    {
      "indent": 5,
      "text": "node-set deref(node-set nodes)",
      "ja": "ノードセットDEREF（ノードセットのノード）"
    },
    {
      "indent": 3,
      "text": "The deref() function follows the reference defined by the first node in document order in the argument \"nodes\" and returns the nodes it refers to.",
      "ja": "DEREF（）関数は、引数「ノード」は、ドキュメント順で最初のノードによって定義される基準に従っており、それが指すノードを返します。"
    },
    {
      "indent": 3,
      "text": "If the first argument node is of type \"instance-identifier\", the function returns a node set that contains the single node that the instance identifier refers to, if it exists. If no such node exists, an empty node set is returned.",
      "ja": "最初の引数ノードはタイプ「インスタンス識別子」である場合、関数は、それが存在する場合、インスタンス識別子は、を意味する単一のノードを含むノードセットを返します。そのようなノードが存在しない場合、空のノードセットが返されます。"
    },
    {
      "indent": 3,
      "text": "If the first argument node is of type \"leafref\", the function returns a node set that contains the nodes that the leafref refers to. Specifically, this set contains the nodes selected by the leafref's \"path\" statement (Section 9.9.2) that have the same value as the first argument node.",
      "ja": "最初の引数ノードはタイプ「leafref」である場合、関数はleafrefが参照ノードを含むノードセットを返します。具体的には、このセットは、最初の引数ノードと同じ値を有するleafrefの「パス」ステートメント（セクション9.9.2）によって選択されたノードを含みます。"
    },
    {
      "indent": 3,
      "text": "If the first argument node is of any other type, an empty node set is returned.",
      "ja": "最初の引数のノードが他のタイプのものである場合、空のノードセットが返されます。"
    },
    {
      "indent": 0,
      "text": "10.3.1.1. Usage Example",
      "section_title": true,
      "ja": "10.3.1.1。使用例"
    },
    {
      "indent": 5,
      "text": "list interface {\n  key \"name type\";\n  leaf name { ... }\n  leaf type { ... }\n  leaf enabled {\n    type boolean;\n  }\n  ...\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": "container mgmt-interface {\n  leaf name {\n    type leafref {\n      path \"/interface/name\";\n    }\n  }\n  leaf type {\n    type leafref {\n      path \"/interface[name=current()/../name]/type\";\n    }\n    must 'deref(.)/../enabled = \"true\"' {\n      error-message\n        \"The management interface cannot be disabled.\";\n    }\n  }\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "10.4. Functions for the YANG Type \"identityref\"",
      "section_title": true,
      "ja": "10.4.  YANGタイプ「identityref」のための関数"
    },
    {
      "indent": 0,
      "text": "10.4.1. derived-from()",
      "section_title": true,
      "ja": "10.4.1. に由来する（）"
    },
    {
      "indent": 5,
      "text": "boolean derived-from(node-set nodes, string identity)",
      "ja": "派生からブール（ノードセットのノードは、文字列の同一性）"
    },
    {
      "indent": 3,
      "text": "The derived-from() function returns \"true\" if any node in the argument \"nodes\" is a node of type \"identityref\" and its value is an identity that is derived from (see Section 7.18.2) the identity \"identity\"; otherwise, it returns \"false\".",
      "ja": "引数「ノード」内の任意のノードが「identityref」タイプのノードであり、その値から導出されるアイデンティティ（セクション7.18.2を参照）アイデンティティ「同一」である場合、派生から（）関数は、「真」を返します;それ以外の場合は、「false」を返します。"
    },
    {
      "indent": 3,
      "text": "The parameter \"identity\" is a string matching the rule \"identifier-ref\" in Section 14. If a prefix is present on the identity, it refers to an identity defined in the module that was imported with that prefix, or the local module if the prefix matches the local module's prefix. If no prefix is present, the identity refers to an identity defined in the current module or an included submodule.",
      "ja": "パラメーター「同一性」プレフィックスが同一で存在している場合ならば、それはそのプレフィックスでインポートされたモジュールで定義されたアイデンティティ、またはローカルモジュールを指す項14にルール「識別子-REF」に一致する文字列でありますプレフィックスは、ローカルモジュールのプレフィックスに一致します。接頭辞が存在しない場合、同一性は、現在のモジュールまたは含まサブモジュールで定義された同一性をいいます。"
    },
    {
      "indent": 0,
      "text": "10.4.1.1. Usage Example",
      "section_title": true,
      "ja": "10.4.1.1。使用例"
    },
    {
      "indent": 5,
      "text": "module example-interface {\n  yang-version 1.1;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "... identity interface-type;",
      "ja": "...アイデンティティインターフェイス型。"
    },
    {
      "indent": 7,
      "text": "identity ethernet { base interface-type; }",
      "ja": "同一イーサネット{基本インタフェース型; }"
    },
    {
      "indent": 7,
      "text": "identity fast-ethernet { base ethernet; }",
      "ja": "アイデンティティ高速イーサネット{塩基イーサネット。 }"
    },
    {
      "indent": 7,
      "text": "identity gigabit-ethernet { base ethernet; }",
      "ja": "アイデンティティ・ギガビット・イーサネット{塩基イーサネット。 }"
    },
    {
      "indent": 7,
      "text": "list interface {\n  key name;\n  ...\n  leaf type {\n    type identityref {\n      base interface-type;\n    }\n  }\n  ...\n}",
      "raw": true
    },
    {
      "indent": 5,
      "text": " augment \"/interface\" { when 'derived-from(type, \"exif:ethernet\")'; // generic Ethernet definitions here } ... }",
      "ja": ";：{「派生から（タイプ、 『イーサネットEXIF』）」と、「/インターフェース」を増強//ここに一般的なイーサネットの定義} ...}"
    },
    {
      "indent": 0,
      "text": "10.4.2. derived-from-or-self()",
      "section_title": true,
      "ja": "10.4.2. 派生から、または自己（）"
    },
    {
      "indent": 5,
      "text": "boolean derived-from-or-self(node-set nodes, string identity)",
      "ja": "ブール派生から、または自己（ノードセットのノードは、文字列の同一性）"
    },
    {
      "indent": 3,
      "text": "The derived-from-or-self() function returns \"true\" if any node in the argument \"nodes\" is a node of type \"identityref\" and its value is an identity that is equal to or derived from (see Section 7.18.2) the identity \"identity\"; otherwise, it returns \"false\".",
      "ja": "引数「ノード」内の任意のノードが「identityref」タイプのノードであり、その値が等しいか（セクション7.18を参照に由来する同一である場合、派生から、または自己（）関数は、「真」を返します。 2）同一性「アイデンティティ」。それ以外の場合は、「false」を返します。"
    },
    {
      "indent": 3,
      "text": "The parameter \"identity\" is a string matching the rule \"identifier-ref\" in Section 14. If a prefix is present on the identity, it refers to an identity defined in the module that was imported with that prefix, or the local module if the prefix matches the local module's prefix. If no prefix is present, the identity refers to an identity defined in the current module or an included submodule.",
      "ja": "パラメーター「同一性」プレフィックスが同一で存在している場合ならば、それはそのプレフィックスでインポートされたモジュールで定義されたアイデンティティ、またはローカルモジュールを指す項14にルール「識別子-REF」に一致する文字列でありますプレフィックスは、ローカルモジュールのプレフィックスに一致します。接頭辞が存在しない場合、同一性は、現在のモジュールまたは含まサブモジュールで定義された同一性をいいます。"
    },
    {
      "indent": 0,
      "text": "10.4.2.1. Usage Example",
      "section_title": true,
      "ja": "10.4.2.1。使用例"
    },
    {
      "indent": 3,
      "text": "The module defined in Section 10.4.1.1 might also have:",
      "ja": "セクション10.4.1.1で定義されたモジュールも持っているかもしれません。"
    },
    {
      "indent": 7,
      "text": "augment \"/interface\" {\n  when 'derived-from-or-self(type, \"exif:fast-ethernet\");\n  // Fast-Ethernet-specific definitions here\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "10.5. Function for the YANG Type \"enumeration\"",
      "section_title": true,
      "ja": "10.5.  YANGタイプ「列挙」の機能"
    },
    {
      "indent": 0,
      "text": "10.5.1. enum-value()",
      "section_title": true,
      "ja": "10.5.1. 列挙型値（）"
    },
    {
      "indent": 5,
      "text": "number enum-value(node-set nodes)",
      "ja": "数列挙値（ノードセットのノード）"
    },
    {
      "indent": 3,
      "text": "The enum-value() function checks to see if the first node in document order in the argument \"nodes\" is a node of type \"enumeration\" and returns the enum's integer value. If the \"nodes\" node set is empty or if the first node in \"nodes\" is not of type \"enumeration\", it returns NaN (not a number).",
      "ja": "列挙型値（）関数は、引数「ノード」のドキュメント順で最初のノードはタイプ「列挙」のノードであり、列挙の整数値を返すかどうかを確認します。 「ノード」ノードセットが空であるか、または「ノード」の最初のノードは、タイプ「列挙」でない場合、それはNaN（非数）を返した場合。"
    },
    {
      "indent": 0,
      "text": "10.5.1.1. Usage Example",
      "section_title": true,
      "ja": "10.5.1.1。使用例"
    },
    {
      "indent": 3,
      "text": "With this data model:",
      "ja": "このデータモデルの場合："
    },
    {
      "indent": 5,
      "text": "list alarm {\n  ...\n  leaf severity {\n    type enumeration {\n      enum cleared {\n        value 1;\n      }\n      enum indeterminate {\n        value 2;\n      }\n      enum minor {\n        value 3;\n      }\n      enum warning {\n        value 4;\n      }\n      enum major {\n        value 5;\n      }\n      enum critical {\n        value 6;\n      }\n    }\n  }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "the following XPath expression selects only alarms that are of severity \"major\" or higher:",
      "ja": "次のXPath式は、重要度の「主要な」以上のみのアラームを選択します。"
    },
    {
      "indent": 5,
      "text": "/alarm[enum-value(severity) >= 5]",
      "ja": "/アラーム[列挙値（重症度）> = 5]"
    },
    {
      "indent": 0,
      "text": "10.6. Function for the YANG Type \"bits\"",
      "section_title": true,
      "ja": "10.6.  YANGタイプ「ビット」のための機能"
    },
    {
      "indent": 0,
      "text": "10.6.1. bit-is-set()",
      "section_title": true,
      "ja": "10.6.1.  ）（ビッ​​ト設定されています"
    },
    {
      "indent": 5,
      "text": "boolean bit-is-set(node-set nodes, string bit-name)",
      "ja": "ブールビット設定されている（ノード集合ノード、列ビット名）"
    },
    {
      "indent": 3,
      "text": "The bit-is-set() function returns \"true\" if the first node in document order in the argument \"nodes\" is a node of type \"bits\" and its value has the bit \"bit-name\" set; otherwise, it returns \"false\".",
      "ja": "引数「ノード」のドキュメント順で最初のノードタイプのノード「ビット」であり、その値はビット「ビット名」に設定している場合、ビット設定されている（）関数は、「真」を返します。それ以外の場合は、「false」を返します。"
    },
    {
      "indent": 0,
      "text": "10.6.1.1. Usage Example",
      "section_title": true,
      "ja": "10.6.1.1。使用例"
    },
    {
      "indent": 3,
      "text": "If an interface has this leaf:",
      "ja": "インターフェイスは、この葉を持っている場合："
    },
    {
      "indent": 5,
      "text": "leaf flags {\n  type bits {\n    bit UP;\n    bit PROMISCUOUS\n    bit DISABLED;\n  }\n }",
      "raw": true
    },
    {
      "indent": 3,
      "text": "the following XPath expression can be used to select all interfaces with the UP flag set:",
      "ja": "次のXPath式は、UPフラグが設定されたすべてのインターフェイスを選択するために使用することができます。"
    },
    {
      "indent": 5,
      "text": "/interface[bit-is-set(flags, \"UP\")]",
      "ja": "/インターフェイス[ビットであるセット（フラグ、「UP」）]"
    },
    {
      "indent": 0,
      "text": "11. Updating a Module",
      "section_title": true,
      "ja": "モジュールの更新11"
    },
    {
      "indent": 3,
      "text": "As experience is gained with a module, it may be desirable to revise that module. However, changes to published modules are not allowed if they have any potential to cause interoperability problems between a client using an original specification and a server using an updated specification.",
      "ja": "経験がモジュールで獲得されるので、そのモジュールを改訂することが望ましい場合があります。彼らは元の仕様と、更新の仕様を使用してサーバを使用して、クライアント間の相互運用性の問題を引き起こすあらゆる可能性を持っている場合は、公表されたモジュールへの変更は許可されていません。"
    },
    {
      "indent": 3,
      "text": "For any published change, a new \"revision\" statement (Section 7.1.9) MUST be included in front of the existing \"revision\" statements. If there are no existing \"revision\" statements, then one MUST be added to identify the new revision. Furthermore, any necessary changes MUST be applied to any metadata statements, including the \"organization\" and \"contact\" statements (Sections 7.1.7 and 7.1.8).",
      "ja": "任意の公表の変更については、新たに「改正」の文（セクション7.1.9）は、既存の「改正」の文の前に含めなければなりません。既存の「改正」の文が存在しない場合には、一つは新しいリビジョンを識別するために加えなければなりません。また、必要な変更は、「組織」と「接触」文（セクション7.1.7と7.1.8）を含む、任意のメタデータステートメントに適用されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Note that definitions contained in a module are available to be imported by any other module and are referenced in \"import\" statements via the module name. Thus, a module name MUST NOT be changed. Furthermore, the \"namespace\" statement MUST NOT be changed, since all XML elements are qualified by the namespace.",
      "ja": "モジュールに含まれる定義は、他のモジュールによってインポートされるために利用可能であり、モジュール名を経由して「インポート」ステートメントで参照されていることに注意してください。このように、モジュール名を変更してはいけません。すべてのXML要素が名前空間で修飾されているので、「名前空間」の文では、変更してはいけません。"
    },
    {
      "indent": 3,
      "text": "Obsolete definitions MUST NOT be removed from published modules, since their identifiers may still be referenced by other modules.",
      "ja": "その識別子は、まだ他のモジュールによって参照することができるので、廃止された定義は、公表されたモジュールから削除されてはなりません。"
    },
    {
      "indent": 3,
      "text": "A definition in a published module may be revised in any of the following ways:",
      "ja": "公表され、モジュール内の定義は、以下のいずれかの方法で変更することがあります。"
    },
    {
      "indent": 3,
      "text": "o An \"enumeration\" type may have new enums added, provided the old enums's values do not change. Note that inserting a new enum before an existing enum or reordering existing enums will result in new values for the existing enums, unless they have explicit values assigned to them.",
      "ja": "Oアン「列挙」タイプは、新しい列挙型が古い列挙型の値が変更されません提供、追加があります。彼らはそれらに割り当てられた明示的な値を持っていない限り、既存の列挙型の前に新しい列挙型を挿入するか、既存の列挙型を並べ替えることは、既存の列挙型の新しい値となることに注意して下さい。"
    },
    {
      "indent": 3,
      "text": "o A \"bits\" type may have new bits added, provided the old bit positions do not change. Note that inserting a new bit before an existing bit or reordering existing bits will result in new positions for the existing bits, unless they have explicit positions assigned to them.",
      "ja": "O「ビット」タイプが持っている可能性のある新しいビットは、追加の古いビット位置は変更されません提供しました。彼らはそれらに割り当てられた明示的な位置を持っていない限り、既存のビットの前に新しいビットを挿入するか、既存のビットの順序を変更することは、既存のビットのための新たな位置になることに注意して下さい。"
    },
    {
      "indent": 3,
      "text": "o A \"range\", \"length\", or \"pattern\" statement may expand the allowed value space.",
      "ja": "○「レンジ」、「長さ」、または「パターン」の文は、許容値の空間を拡張することができます。"
    },
    {
      "indent": 3,
      "text": "o A \"default\" statement may be added to a leaf that does not have a default value (either directly or indirectly through its type).",
      "ja": "O「デフォルト」の文は、（直接または間接的にそのタイプを介して）デフォルト値を持たない葉に添加してもよいです。"
    },
    {
      "indent": 3,
      "text": "o A \"units\" statement may be added.",
      "ja": "O「単位」の文を追加してもよいです。"
    },
    {
      "indent": 3,
      "text": "o A \"reference\" statement may be added or updated.",
      "ja": "O「参照」ステートメントが追加または更新することができます。"
    },
    {
      "indent": 3,
      "text": "o A \"must\" statement may be removed or its constraint relaxed.",
      "ja": "O文は削除してもよいし、その制約を緩和「しなければなりません」。"
    },
    {
      "indent": 3,
      "text": "o A \"when\" statement may be removed or its constraint relaxed.",
      "ja": "o「のとき」文を削除またはその制約を緩和することができます。"
    },
    {
      "indent": 3,
      "text": "o A \"mandatory\" statement may be removed or changed from \"true\" to \"false\".",
      "ja": "O「必須」文を削除または「false」を「true」に変更することができます。"
    },
    {
      "indent": 3,
      "text": "o A \"min-elements\" statement may be removed, or changed to require fewer elements.",
      "ja": "O「MIN-要素」ステートメントを除去し、又はより少ない要素を必要とするように変更することができます。"
    },
    {
      "indent": 3,
      "text": "o A \"max-elements\" statement may be removed, or changed to allow more elements.",
      "ja": "o「の最大要素」文を削除、または複数の要素を許可するように変更することができます。"
    },
    {
      "indent": 3,
      "text": "o A \"description\" statement may be added or changed without changing the semantics of the definition.",
      "ja": "O「DESCRIPTION」ステートメントは、定義の意味を変えることなく、追加または変更されてもよいです。"
    },
    {
      "indent": 3,
      "text": "o A \"base\" statement may be added to an \"identity\" statement.",
      "ja": "O「ベース」の文は、「アイデンティティ」の文に加えてもよいです。"
    },
    {
      "indent": 3,
      "text": "o A \"base\" statement may be removed from an \"identityref\" type, provided there is at least one \"base\" statement left.",
      "ja": "O「塩基」文が「identityref」型から除去することができるが、左の少なくとも1つの「塩基」文が提供されます。"
    },
    {
      "indent": 3,
      "text": "o New typedefs, groupings, rpcs, notifications, extensions, features, and identities may be added.",
      "ja": "O新しいtypedefは、グループ化、RPCを、通知、拡張、機能、およびアイデンティティを添加してもよいです。"
    },
    {
      "indent": 3,
      "text": "o New data definition statements may be added if they do not add mandatory nodes (Section 3) to existing nodes or at the top level in a module or submodule, or if they are conditionally dependent on a new feature (i.e., have an \"if-feature\" statement that refers to a new feature).",
      "ja": "O新しいデータ定義文は、彼らが既存のノードへのモジュールまたはサブモジュールのトップレベルで必須のノード（第3節）を追加、または彼らはすなわち新機能（上の条件付きで依存している場合は、「あれば持っていない場合は追加してもよいです新しい機能を指し-feature」文）。"
    },
    {
      "indent": 3,
      "text": "o A new \"case\" statement may be added.",
      "ja": "O新しい「ケース」の文を追加してもよいです。"
    },
    {
      "indent": 3,
      "text": "o A node that represented state data may be changed to represent configuration, provided it is not mandatory (Section 3).",
      "ja": "O状態のデータ構成を表すように変更されてもよい表されるノードが、それは必須ではない（セクション3）を得ました。"
    },
    {
      "indent": 3,
      "text": "o An \"if-feature\" statement may be removed, provided its node is not mandatory (Section 3).",
      "ja": "O「であれば、機能」ステートメントを除去することができる、そのノードは（セクション3）は必須ではないが提供されます。"
    },
    {
      "indent": 3,
      "text": "o A \"status\" statement may be added, or changed from \"current\" to \"deprecated\" or \"obsolete\", or changed from \"deprecated\" to \"obsolete\".",
      "ja": "O「状態」ステートメントを追加、または「非推奨」または「廃止」、または「廃止」と「非推奨」から変更する「現在」から変更することができます。"
    },
    {
      "indent": 3,
      "text": "o A \"type\" statement may be replaced with another \"type\" statement that does not change the syntax or semantics of the type. For example, an inline type definition may be replaced with a typedef, but an int8 type cannot be replaced by an int16, since the syntax would change.",
      "ja": "O「タイプ」の文は、型の構文や意味を変更しない別の「タイプ」の文に置き換えてもよいです。例えば、インラインタイプ定義はtypedefで置き換えてもよいが、INT8タイプは構文が変化するため、INT16で置き換えることができません。"
    },
    {
      "indent": 3,
      "text": "o Any set of data definition nodes may be replaced with another set of syntactically and semantically equivalent nodes. For example, a set of leafs may be replaced by a \"uses\" statement of a grouping with the same leafs.",
      "ja": "Oデータ定義ノードの任意のセットは、構文的および意味的に等価なノードの別のセットに置き換えてもよいです。例えば、葉のセットは、同じ葉でグループ化する「使用」の文に置き換えることができます。"
    },
    {
      "indent": 3,
      "text": "o A module may be split into a set of submodules or a submodule may be removed, provided the definitions in the module do not change in any way other than those allowed here.",
      "ja": "Oモジュールは、サブモジュールのセットに分割され得るか、またはサブモジュールを除去することができる、ここで許可されたもの以外の方法で変化しないモジュール内の定義を提供しました。"
    },
    {
      "indent": 3,
      "text": "o The \"prefix\" statement may be changed, provided all local uses of the prefix are also changed.",
      "ja": "「接頭辞」のステートメントを変更することができるO、接頭辞のすべてのローカルの使用も変更されました。"
    },
    {
      "indent": 3,
      "text": "Otherwise, if the semantics of any previous definition are changed (i.e., if a non-editorial change is made to any definition other than those specifically allowed above), then this MUST be achieved by a new definition with a new identifier.",
      "ja": "以前の定義のセマンティクスが変更された場合（非編集上の変更は、特に上記許可以外の任意の定義がなされた場合、すなわち、）そうでなければ、これは新しい識別子と新しい定義によって達成されなければなりません。"
    },
    {
      "indent": 3,
      "text": "In statements that have any data definition statements as substatements, those data definition substatements MUST NOT be reordered. If new data definition statements are added, they can be added anywhere in the sequence of existing substatements.",
      "ja": "サブステートメントとして任意のデータ定義文を持っている文では、これらのデータ定義のサブステートメントは、並べ替えてはなりません。新しいデータ定義文が追加されている場合は、既存のサブステートメントの順序で任意の場所に追加することができます。"
    },
    {
      "indent": 0,
      "text": "12. Coexistence with YANG Version 1",
      "section_title": true,
      "ja": "YANGバージョン1と12の共存"
    },
    {
      "indent": 3,
      "text": "A YANG version 1.1 module MUST NOT include a YANG version 1 submodule, and a YANG version 1 module MUST NOT include a YANG version 1.1 submodule.",
      "ja": "YANGバージョン1.1モジュールは、YANGバージョン1サブモジュールを含んではいけません、そしてYANGバージョン1モジュールは、YANGバージョン1.1サブモジュールを含んではいけません。"
    },
    {
      "indent": 3,
      "text": "A YANG version 1 module or submodule MUST NOT import a YANG version 1.1 module by revision.",
      "ja": "YANGバージョン1モジュールまたはサブモジュールは、改訂によりYANGバージョン1.1モジュールをインポートしてはいけません。"
    },
    {
      "indent": 3,
      "text": "A YANG version 1.1 module or submodule MAY import a YANG version 1 module by revision.",
      "ja": "YANGバージョン1.1モジュールまたはサブモジュールは、改訂によりYANGバージョン1モジュールをインポートすること。"
    },
    {
      "indent": 3,
      "text": "If a YANG version 1 module A imports module B without revision and module B is updated to YANG version 1.1, a server MAY implement both of these modules (A and B) at the same time. In such cases, a NETCONF server MUST advertise both modules using the rules defined in Section 5.6.4, and SHOULD advertise module A and the latest revision of module B that is specified with YANG version 1 according to the rules defined in [RFC6020].",
      "ja": "リビジョンとモジュールB無しYANGバージョン1つのモジュールAインポートモジュールBがYANGバージョン1.1に更新された場合、サーバは、同時にこれらのモジュール（AおよびB）の両方を実装することができます。このような場合、NETCONFサーバは、セクション5.6.4で定義された規則を使用して、両方のモジュールをアドバタイズする必要があり、モジュールAと[RFC6020]で定義された規則に従ってYANGバージョン1で指定されたモジュールBの最新版を広告すべきです。"
    },
    {
      "indent": 3,
      "text": "This rule exists in order to allow implementations of existing YANG version 1 modules together with YANG version 1.1 modules. Without this rule, updating a single module to YANG version 1.1 would have a cascading effect on modules that import it, requiring all of them to also be updated to YANG version 1.1, and so on.",
      "ja": "このルールは、YANGバージョン1.1モジュールと既存のYANGバージョン1つのモジュールの実装を一緒に可能にするために存在します。このルールがなければ、YANGバージョン1.1に単一のモジュールを更新することも、そうでYANGバージョン1.1にアップデートし、するためにそれらのすべてを必要とし、それをインポートするモジュールのカスケード効果を持っているでしょう。"
    },
    {
      "indent": 0,
      "text": "13. YIN",
      "section_title": true,
      "ja": "13.陰"
    },
    {
      "indent": 3,
      "text": "A YANG module can be translated into an alternative XML-based syntax called YIN. The translated module is called a YIN module. This section describes bidirectional mapping rules between the two formats.",
      "ja": "YANGモジュールはYINと呼ばれる代替XMLベースの構文に変換することができます。翻訳されたモジュールは、YINモジュールと呼ばれています。このセクションでは、2つのフォーマット間の双方向マッピングルールを説明します。"
    },
    {
      "indent": 3,
      "text": "The YANG and YIN formats contain equivalent information using different notations. The YIN notation enables developers to represent YANG data models in XML and therefore use the rich set of XML-based tools for data filtering and validation, automated generation of code and documentation, and other tasks. Tools like XSLT or XML validators can be utilized.",
      "ja": "YANGとYINフォーマットが異なる表記を使用して同等の情報が含まれています。 YIN表記はXMLでYANGデータモデルを表すため、データフィルタリングおよび検証のためのXMLベースのツールの豊富なセット、コードとドキュメントの自動生成、および他のタスクを使用するために開発を可能にします。 XSLTまたはXMLバリデータのようなツールを利用することができます。"
    },
    {
      "indent": 3,
      "text": "The mapping between YANG and YIN does not modify the information content of the model. Comments and whitespace are not preserved.",
      "ja": "陰と陽の間のマッピングは、モデルの情報内容は変更されません。コメントと空白は保持されません。"
    },
    {
      "indent": 0,
      "text": "13.1. Formal YIN Definition",
      "section_title": true,
      "ja": "13.1. フォーマルYIN定義"
    },
    {
      "indent": 3,
      "text": "There is a one-to-one correspondence between YANG keywords and YIN elements. The local name of a YIN element is identical to the corresponding YANG keyword. This means, in particular, that the document element (root) of a YIN document is always <module> or <submodule>.",
      "ja": "YANGキーワードとYIN要素との間には1対1で対応しています。 YIN要素のローカル名は、対応するYANGキーワードと同じです。これは、YIN文書の文書要素（ルート）が常に<モジュール>または<サブモジュール>であることを、特に意味します。"
    },
    {
      "indent": 3,
      "text": "YIN elements corresponding to the YANG keywords belong to the namespace whose associated URI is \"urn:ietf:params:xml:ns:yang:yin:1\".",
      "ja": "YANGキーワードに対応するYIN要素は、その関連するURI \"：IETF：のparams：XML：NS：陽：陰：1 URN\" である名前空間に属します。"
    },
    {
      "indent": 3,
      "text": "YIN elements corresponding to extension keywords belong to the namespace of the YANG module where the extension keyword is declared via the \"extension\" statement.",
      "ja": "拡張キーワードに対応するYIN要素は、拡張キーワードが「拡張子」の文で宣言されYANGモジュールの名前空間に属します。"
    },
    {
      "indent": 3,
      "text": "The names of all YIN elements MUST be properly qualified with their namespaces (as specified above) using the standard mechanisms of [XML-NAMES], i.e., \"xmlns\" and \"xmlns:xxx\" attributes.",
      "ja": "全てYIN要素の名前（上記で規定のように）[XML-NAMES]の標準的なメカニズムを使用して名前空間を適切に修飾する必要があり、即ち、「のxmlns」と「のxmlns：XXX」が属性。"
    },
    {
      "indent": 3,
      "text": "The argument of a YANG statement is represented in YIN as either an XML attribute or a subelement of the keyword element. Table 1 defines the mapping for the set of YANG keywords. For extensions, the argument mapping is specified within the \"extension\" statement (see Section 7.19). The following rules hold for arguments:",
      "ja": "YANG文の引数には、XML属性またはキーワード要素のサブ要素のいずれかとしYINで表されます。表1は、YANGキーワードのセットのマッピングを定義します。拡張機能の場合、引数のマッピングは、「拡張子」ステートメント内に指定されます（セクション7.19を参照してください）。次の規則は、引数のために保持します："
    },
    {
      "indent": 3,
      "text": "o If the argument is represented as an attribute, this attribute has no namespace.",
      "ja": "引数は属性として表現されている場合は、O、この属性には、名前空間を持っていません。"
    },
    {
      "indent": 3,
      "text": "o If the argument is represented as an element, it is qualified by the same namespace as its parent keyword element.",
      "ja": "引数が要素として表現されている場合は、O、それはその親キーワード要素と同じ名前空間で修飾されます。"
    },
    {
      "indent": 3,
      "text": "o If the argument is represented as an element, it MUST be the first child of the keyword element.",
      "ja": "引数が要素として表現されている場合は、O、それはキーワード要素の最初の子でなければなりません。"
    },
    {
      "indent": 3,
      "text": "Substatements of a YANG statement are represented as (additional) children of the keyword element, and their relative order MUST be the same as the order of substatements in YANG.",
      "ja": "YANG文のサブステートメントは、キーワード要素の（追加の）子として表現され、そしてそれらの相対的な順序は、YANGにおけるサブステートメントの順序と同じでなければなりません。"
    },
    {
      "indent": 3,
      "text": "Comments in YANG MAY be mapped to XML comments.",
      "ja": "YANG内のコメントは、XMLコメントにマッピングされてもよいです。"
    },
    {
      "indent": 12,
      "text": "+------------------+---------------+-------------+\n| keyword          | argument name | yin-element |\n+------------------+---------------+-------------+\n| action           | name          | false       |\n| anydata          | name          | false       |\n| anyxml           | name          | false       |\n| argument         | name          | false       |\n| augment          | target-node   | false       |\n| base             | name          | false       |\n| belongs-to       | module        | false       |\n| bit              | name          | false       |\n| case             | name          | false       |\n| choice           | name          | false       |\n| config           | value         | false       |\n| contact          | text          | true        |\n| container        | name          | false       |\n| default          | value         | false       |\n| description      | text          | true        |\n| deviate          | value         | false       |\n| deviation        | target-node   | false       |\n| enum             | name          | false       |\n| error-app-tag    | value         | false       |\n| error-message    | value         | true        |\n| extension        | name          | false       |\n| feature          | name          | false       |\n| fraction-digits  | value         | false       |\n| grouping         | name          | false       |\n| identity         | name          | false       |\n| if-feature       | name          | false       |\n| import           | module        | false       |\n| include          | module        | false       |\n| input            | <no argument> | n/a         |\n| key              | value         | false       |\n| leaf             | name          | false       |\n| leaf-list        | name          | false       |\n| length           | value         | false       |\n| list             | name          | false       |\n| mandatory        | value         | false       |\n| max-elements     | value         | false       |\n| min-elements     | value         | false       |\n| modifier         | value         | false       |\n| module           | name          | false       |\n| must             | condition     | false       |\n| namespace        | uri           | false       |\n| notification     | name          | false       |\n| ordered-by       | value         | false       |\n| organization     | text          | true        |\n| output           | <no argument> | n/a         |",
      "raw": true
    },
    {
      "indent": 12,
      "text": "| path             | value         | false       |\n| pattern          | value         | false       |\n| position         | value         | false       |\n| prefix           | value         | false       |\n| presence         | value         | false       |\n| range            | value         | false       |\n| reference        | text          | true        |\n| refine           | target-node   | false       |\n| require-instance | value         | false       |\n| revision         | date          | false       |\n| revision-date    | date          | false       |\n| rpc              | name          | false       |\n| status           | value         | false       |\n| submodule        | name          | false       |\n| type             | name          | false       |\n| typedef          | name          | false       |\n| unique           | tag           | false       |\n| units            | name          | false       |\n| uses             | name          | false       |\n| value            | value         | false       |\n| when             | condition     | false       |\n| yang-version     | value         | false       |\n| yin-element      | value         | false       |\n+------------------+---------------+-------------+",
      "raw": true
    },
    {
      "indent": 11,
      "text": "Table 1: Mapping of Arguments of the YANG Statements",
      "ja": "表1：YANG文の引数のマッピング"
    },
    {
      "indent": 0,
      "text": "13.1.1. Usage Example",
      "section_title": true,
      "ja": "13.1.1. 使用例"
    },
    {
      "indent": 3,
      "text": "The following YANG module:",
      "ja": "次YANGモジュール："
    },
    {
      "indent": 5,
      "text": "module example-foo {\n  yang-version 1.1;\n  namespace \"urn:example:foo\";\n  prefix \"foo\";",
      "raw": true
    },
    {
      "indent": 7,
      "text": "import example-extensions { prefix \"myext\"; }",
      "ja": "インポート例-拡張{接頭辞「MYEXT」。 }"
    },
    {
      "indent": 5,
      "text": "  list interface {\n    key \"name\";\n    leaf name {\n      type string;\n    } leaf mtu {\n      type uint32;\n      description \"The MTU of the interface.\";\n      myext:c-define \"MY_MTU\";\n    }\n  }\n}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "where the extension \"c-define\" is defined in Section 7.19.3, is translated into the following YIN:",
      "ja": "拡張子「C-定義」は、セクション7.19.3に定義されている場合、次のYINに翻訳されます。"
    },
    {
      "indent": 5,
      "text": "<module name=\"example-foo\" xmlns=\"urn:ietf:params:xml:ns:yang:yin:1\" xmlns:foo=\"urn:example:foo\" xmlns:myext=\"urn:example:extensions\">",
      "ja": "<モジュール名= \"例、FOO\" のxmlns = \"URN：IETF：paramsは：XML：NS：陽：陰：1\" のxmlns：FOO = \"URN：例：FOO\" のxmlns：MYEXT = \"URN：例：拡張子\" >"
    },
    {
      "indent": 7,
      "text": "<namespace uri=\"urn:example:foo\"/> <prefix value=\"foo\"/>",
      "ja": "<名前空間URI = \"壷：例：FOO\" /> <プレフィックス値= \"foo\" という/>"
    },
    {
      "indent": 7,
      "text": "<import module=\"example-extensions\"> <prefix value=\"myext\"/> </import>",
      "ja": "<インポートモジュール= \"例、拡張\"> <プレフィックス値= \"MYEXT\" /> </インポート>"
    },
    {
      "indent": 5,
      "text": " <list name=\"interface\"> <key value=\"name\"/> <leaf name=\"name\"> <type name=\"string\"/> </leaf> <leaf name=\"mtu\"> <type name=\"uint32\"/> <description> <text>The MTU of the interface.</text> </description> <myext:c-define name=\"MY_MTU\"/> </leaf> </list> </module>",
      "ja": "<リスト名= \"インターフェース\"> <キーの値= \"名前\" /> <葉名= \"名前\"> <型名= \"文字列\" /> </葉> <葉名= \"MTU\"> <タイプ名= \"UINT32\" /> <説明> <テキスト>インターフェースのMTU </テキスト> </記述> <MYEXT：C-定義名= \"MY_MTU\" /> </リーフ> </リスト> </モジュール>"
    },
    {
      "indent": 0,
      "text": "14. YANG ABNF Grammar",
      "section_title": true,
      "ja": "14. ABNF文法"
    },
    {
      "indent": 3,
      "text": "In YANG, almost all statements are unordered. The ABNF grammar [RFC5234] [RFC7405] defines the canonical order. To improve module readability, it is RECOMMENDED that clauses be entered in this order.",
      "ja": "YANGでは、ほとんどすべての文は順不同です。 ABNF文法[RFC5234]、[RFC7405]は標準的な順序を定義します。モジュールの読みやすさを改善するためには、節の順に入力することが推奨されます。"
    },
    {
      "indent": 3,
      "text": "Within the ABNF grammar, unordered statements are marked with comments.",
      "ja": "ABNF文法の中で、順序付けられていないステートメントは、コメントが付いています。"
    },
    {
      "indent": 3,
      "text": "This grammar assumes that the scanner replaces YANG comments with a single space character.",
      "ja": "この文法は、スキャナは、単一の空白文字でYANGコメントを置き換えることを想定しています。"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS> file \"yang.abnf\"",
      "ja": "<CODEが始まる>ファイル \"yang.abnf\""
    },
    {
      "indent": 3,
      "text": "module-stmt = optsep module-keyword sep identifier-arg-str optsep \"{\" stmtsep module-header-stmts linkage-stmts meta-stmts revision-stmts body-stmts \"}\" optsep",
      "ja": "モジュールSTMT = optsepモジュールキーワード9月識別子のarg-STR optsep \"{\" stmtsepモジュールヘッダSTMTS連携STMTSメタSTMTSリビジョンSTMTS体STMTS \"}\" optsep"
    },
    {
      "indent": 3,
      "text": "submodule-stmt = optsep submodule-keyword sep identifier-arg-str optsep \"{\" stmtsep submodule-header-stmts linkage-stmts meta-stmts revision-stmts body-stmts \"}\" optsep",
      "ja": "サブモジュール-STMT = optsepサブモジュールキーワード9月識別子のarg-STR optsep \"{\" stmtsepサブモジュール・ヘッダSTMTS連携STMTSメタSTMTSリビジョンSTMTS体STMTS \"}\" optsep"
    },
    {
      "indent": 3,
      "text": "module-header-stmts = ;; these stmts can appear in any order yang-version-stmt namespace-stmt prefix-stmt",
      "ja": "モジュールヘッダSTMTS = ;;これらSTMTSは、任意の順序ヤン・バージョンのstmt名前空間のstmtのプレフィックスのstmtに表示されます"
    },
    {
      "indent": 3,
      "text": "submodule-header-stmts = ;; these stmts can appear in any order yang-version-stmt belongs-to-stmt",
      "ja": "サブモジュール・ヘッダSTMTS = ;;これらSTMTSは、任意の順序ヤン・バージョンのstmtに表示でき属しツーのstmt"
    },
    {
      "indent": 3,
      "text": "meta-stmts = ;; these stmts can appear in any order [organization-stmt] [contact-stmt] [description-stmt] [reference-stmt]",
      "ja": "メタSTMTS = ;;これらSTMTSは、任意の順序で現れることができる[組織STMT] [非接触STMT] [説明-STMT] [参照STMT]"
    },
    {
      "indent": 3,
      "text": "linkage-stmts = ;; these stmts can appear in any order *import-stmt *include-stmt",
      "ja": "リンケージSTMTS = ;;これらSTMTSは、任意の順序*インポート-STMTに表示できる*含ま-のstmt"
    },
    {
      "indent": 3,
      "text": "revision-stmts = *revision-stmt",
      "ja": "改正-STMTS = *リビジョンのstmt"
    },
    {
      "indent": 3,
      "text": "body-stmts = *(extension-stmt / feature-stmt / identity-stmt / typedef-stmt / grouping-stmt / data-def-stmt / augment-stmt / rpc-stmt / notification-stmt / deviation-stmt)",
      "ja": "ボディSTMTS = *（拡張-STMT /特徴STMT /アイデンティティ-STMT / typedefは、STMT /グルーピング-STMT /データ-DEF-STMT /増強-STMT / RPC-STMT /通知STMT /偏差STMT）"
    },
    {
      "indent": 3,
      "text": "data-def-stmt = container-stmt / leaf-stmt / leaf-list-stmt / list-stmt / choice-stmt / anydata-stmt / anyxml-stmt / uses-stmt",
      "ja": "データ-DEF-のstmt =コンテナのstmt /リーフのstmt /リーフリストのstmt /リストのstmt /選択-のstmt / ANYDATA-のstmt / AnyXMLで-のstmt /は使用しています-のstmtを"
    },
    {
      "indent": 3,
      "text": "yang-version-stmt = yang-version-keyword sep yang-version-arg-str stmtend",
      "ja": "これは、バージョン間STMT =キーワードSEP--バージョンのArg-STRのstmtend"
    },
    {
      "indent": 3,
      "text": "yang-version-arg-str = < a string that matches the rule > < yang-version-arg >",
      "ja": "ヤン・バージョンのarg-STR = <ルールにマッチした文字列> <ヤン・バージョン、引数>"
    },
    {
      "indent": 3,
      "text": "yang-version-arg = \"1.1\"",
      "ja": "どのバージョン、引数=「1.1」"
    },
    {
      "indent": 3,
      "text": "import-stmt = import-keyword sep identifier-arg-str optsep \"{\" stmtsep ;; these stmts can appear in any order prefix-stmt [revision-date-stmt] [description-stmt] [reference-stmt] \"}\" stmtsep",
      "ja": "インポートSTMT =インポートキーワード9月識別子のarg-STR optsep \"{\" stmtsep ;;これらSTMTSは、任意の順序プレフィックス-STMT [改訂日付STMT] [説明-STMT] [参照STMT] \"}\" stmtsepに表示でき"
    },
    {
      "indent": 3,
      "text": "include-stmt = include-keyword sep identifier-arg-str optsep (\";\" / \"{\" stmtsep ;; these stmts can appear in any order [revision-date-stmt] [description-stmt] [reference-stmt] \"}\") stmtsep",
      "ja": "包含STMT =含むキーワード9月識別子のarg-STRのoptsep（ \";\" / \"{\" stmtsep ;;これらSTMTSは、任意の順序で現れることができる[改訂日付STMT] [説明-STMT] [参照STMT「 } \"）stmtsep"
    },
    {
      "indent": 3,
      "text": "namespace-stmt = namespace-keyword sep uri-str stmtend",
      "ja": "名前空間のstmt =名前空間キーワード9月のURI-STR stmtend"
    },
    {
      "indent": 3,
      "text": "uri-str = < a string that matches the rule > < URI in RFC 3986 >",
      "ja": "URI-STR = <RFC 3986にURI> <ルール一致する文字列>を"
    },
    {
      "indent": 3,
      "text": "prefix-stmt = prefix-keyword sep prefix-arg-str stmtend",
      "ja": "プレフィックスのstmt =プレフィックスキーワード9月接頭引数-STRのstmtend"
    },
    {
      "indent": 3,
      "text": "belongs-to-stmt = belongs-to-keyword sep identifier-arg-str optsep \"{\" stmtsep prefix-stmt \"}\" stmtsep",
      "ja": "所属ツーSTMT =属するツーキーワード9月識別子のarg-STR optsep \"{\" stmtsepプレフィックスSTMT \"}\" stmtsep"
    },
    {
      "indent": 3,
      "text": "organization-stmt = organization-keyword sep string stmtend",
      "ja": "組織のstmt =組織-キーワード9月の文字列stmtend"
    },
    {
      "indent": 3,
      "text": "contact-stmt = contact-keyword sep string stmtend",
      "ja": "非接触型のstmt =接触キーワード9月の文字列stmtend"
    },
    {
      "indent": 3,
      "text": "description-stmt = description-keyword sep string stmtend",
      "ja": "説明-のstmt =説明、キーワード9月の文字列stmtend"
    },
    {
      "indent": 3,
      "text": "reference-stmt = reference-keyword sep string stmtend",
      "ja": "参照のstmt =参照-キーワード9月の文字列stmtend"
    },
    {
      "indent": 3,
      "text": "units-stmt = units-keyword sep string stmtend",
      "ja": "単位-のstmt =単位-キーワード9月の文字列stmtend"
    },
    {
      "indent": 3,
      "text": "revision-stmt = revision-keyword sep revision-date optsep (\";\" / \"{\" stmtsep ;; these stmts can appear in any order [description-stmt] [reference-stmt] \"}\") stmtsep",
      "ja": "リビジョンSTMT =リビジョンキーワード9月改訂日付optsep（ \";\" / \"{\" stmtsep ;;これらSTMTSは任意の順序で現れることができる[説明-STMT] [参照STMT] \"}\"）stmtsep"
    },
    {
      "indent": 3,
      "text": "revision-date = date-arg-str",
      "ja": "改訂日付=日付-argを-STR"
    },
    {
      "indent": 3,
      "text": "revision-date-stmt = revision-date-keyword sep revision-date stmtend extension-stmt = extension-keyword sep identifier-arg-str optsep (\";\" / \"{\" stmtsep ;; these stmts can appear in any order [argument-stmt] [status-stmt] [description-stmt] [reference-stmt] \"}\") stmtsep",
      "ja": "改訂日付STMT =改訂日付キーワード月改訂日付stmtend延長-STMT =拡張キーワード月識別子のarg-STR optsep（ \";\" / \"{\" stmtsep ;;これらSTMTSは任意の順序で現れることができる[引数-stmt] [ステータス-STMT] [説明-STMT] [参照STMT] \"}\"）stmtsep"
    },
    {
      "indent": 3,
      "text": "argument-stmt = argument-keyword sep identifier-arg-str optsep (\";\" / \"{\" stmtsep [yin-element-stmt] \"}\") stmtsep",
      "ja": "引数STMT =引数キーワード9月識別子のarg-STR optsep（ \";\" / \"{\" stmtsep [陰元素STMT] \"}\"）stmtsep"
    },
    {
      "indent": 3,
      "text": "yin-element-stmt = yin-element-keyword sep yin-element-arg-str stmtend",
      "ja": "陰-要素のstmt =陰-要素キーワード9月陰-要素、引数-STRのstmtend"
    },
    {
      "indent": 3,
      "text": "yin-element-arg-str = < a string that matches the rule > < yin-element-arg >",
      "ja": "陰元素のarg-STR = <ルールに一致する文字列> <陰元素引数>"
    },
    {
      "indent": 3,
      "text": "yin-element-arg = true-keyword / false-keyword",
      "ja": "陰-要素、引数=真のキーワード/偽のキーワード"
    },
    {
      "indent": 3,
      "text": "identity-stmt = identity-keyword sep identifier-arg-str optsep (\";\" / \"{\" stmtsep ;; these stmts can appear in any order *if-feature-stmt *base-stmt [status-stmt] [description-stmt] [reference-stmt] \"}\") stmtsep",
      "ja": "アイデンティティSTMT =アイデンティティキーワード9月識別子のarg-STRのoptsep（ \";\" / \"{\" stmtsep ;;これらSTMTSは任意の順序で現れることができる* IF-特徴STMT *ベースSTMT [ステータス-STMT] [の説明 - STMT] [参照STMT] \"}\"）stmtsep"
    },
    {
      "indent": 3,
      "text": "base-stmt = base-keyword sep identifier-ref-arg-str stmtend",
      "ja": "ベースSTMT =ベースキーワード9月識別子-REF-のarg-STRのstmtend"
    },
    {
      "indent": 3,
      "text": "feature-stmt = feature-keyword sep identifier-arg-str optsep (\";\" / \"{\" stmtsep ;; these stmts can appear in any order *if-feature-stmt [status-stmt] [description-stmt] [reference-stmt] \"}\") stmtsep",
      "ja": "特徴STMT =機能キーワード9月識別子のarg-STR optsep（ \";\" / \"{\" stmtsep ;;これらSTMTS【説明-STMT] [ステータス-STMT] IF-特徴STMT *任意の順序で現れることができる[参照-stmt] \"}\"）stmtsep"
    },
    {
      "indent": 3,
      "text": "if-feature-stmt = if-feature-keyword sep if-feature-expr-str stmtend",
      "ja": "IF-機能-のstmt = IF-機能・キーワード9月IF-機能-exprの-STRのstmtend"
    },
    {
      "indent": 3,
      "text": "if-feature-expr-str = < a string that matches the rule > < if-feature-expr >",
      "ja": "IF-機能-exprの-STR = <IF-機能-exprの> <ルール一致する文字列>を"
    },
    {
      "indent": 3,
      "text": "if-feature-expr = if-feature-term [sep or-keyword sep if-feature-expr]",
      "ja": "IF-特徴はexpr = IF-特徴ターム[9月またはキーワード9月IF-特徴-expr]は"
    },
    {
      "indent": 3,
      "text": "if-feature-term = if-feature-factor [sep and-keyword sep if-feature-term]",
      "ja": "IF-特徴用語= IF-特徴因子[9月及びキーワード9月IF-特徴用語]"
    },
    {
      "indent": 3,
      "text": "if-feature-factor = not-keyword sep if-feature-factor / \"(\" optsep if-feature-expr optsep \")\" / identifier-ref-arg",
      "ja": "=未キーワード9月IF-特徴因子IF-特徴因子/ \"（\" optsep IF-特徴-exprをoptsep \"）\" /識別子-REF-引数"
    },
    {
      "indent": 3,
      "text": "typedef-stmt = typedef-keyword sep identifier-arg-str optsep \"{\" stmtsep ;; these stmts can appear in any order type-stmt [units-stmt] [default-stmt] [status-stmt] [description-stmt] [reference-stmt] \"}\" stmtsep",
      "ja": "typedefの-STMT = typedefのキーワード9月識別子のarg-STR optsep \"{\" stmtsep ;;これらSTMTSは、任意の順序のタイプSTMT [単位-STMT] [デフォルト-STMT] [ステータス-STMT] [説明-STMT] [参照STMT] \"}\" stmtsepに表示でき"
    },
    {
      "indent": 3,
      "text": "type-stmt = type-keyword sep identifier-ref-arg-str optsep (\";\" / \"{\" stmtsep [type-body-stmts] \"}\") stmtsep",
      "ja": "タイプSTMT =タイプキーワード9月識別子-REF-のarg-STR optsep（ \";\" / \"{\" stmtsep [型ボディSTMTS] \"}\"）stmtsep"
    },
    {
      "indent": 3,
      "text": "type-body-stmts = numerical-restrictions / decimal64-specification / string-restrictions / enum-specification / leafref-specification / identityref-specification / instance-identifier-specification / bits-specification / union-specification / binary-specification",
      "ja": "型ボディSTMTS =数値、制限/ decimal64仕様/文字列の制限/列挙仕様/ leafref仕様/ identityref仕様/インスタンス識別子仕様/ビット仕様/共用仕様/バイナリ仕様"
    },
    {
      "indent": 3,
      "text": "numerical-restrictions = [range-stmt]",
      "ja": "数値-制限= [レンジSTMT]"
    },
    {
      "indent": 3,
      "text": "range-stmt = range-keyword sep range-arg-str optsep (\";\" / \"{\" stmtsep ;; these stmts can appear in any order [error-message-stmt] [error-app-tag-stmt] [description-stmt] [reference-stmt] \"}\") stmtsep",
      "ja": "範囲-STMT =範囲キーワード9月範囲、引数-STR optsep（ \";\" / \"{\" stmtsep ;;これらSTMTSを表示できる任意の順序で[エラーメッセージSTMT] [エラーAPP-タグSTMT] [説明-stmt] [参照STMT] \"}\"）stmtsep"
    },
    {
      "indent": 3,
      "text": "decimal64-specification = ;; these stmts can appear in any order fraction-digits-stmt [range-stmt]",
      "ja": "decimal64仕様= ;;これらSTMTSは、任意の順序フラクション桁-STMT [レンジSTMT]に表示されることが"
    },
    {
      "indent": 3,
      "text": "fraction-digits-stmt = fraction-digits-keyword sep fraction-digits-arg-str stmtend",
      "ja": "小数桁-のstmt =小数桁キーワード9月小数桁-argを-STRのstmtend"
    },
    {
      "indent": 3,
      "text": "fraction-digits-arg-str = < a string that matches the rule > < fraction-digits-arg >",
      "ja": "小数桁-argを-STR = <ルールにマッチした文字列> <小数桁、引数>"
    },
    {
      "indent": 3,
      "text": "fraction-digits-arg = (\"1\" [\"0\" / \"1\" / \"2\" / \"3\" / \"4\" / \"5\" / \"6\" / \"7\" / \"8\"]) / \"2\" / \"3\" / \"4\" / \"5\" / \"6\" / \"7\" / \"8\" / \"9\"",
      "ja": "小数桁、引数=（ \"1\" [ \"0\" / \"1\" / \"2\" / \"3\" / \"4\" / \"5\" / \"6\" / \"7\" / \"8\"]）/ \" 2\" / \"3\" / \"4\" / \"5\" / \"6\" / \"7\" / \"8\" / \"9\""
    },
    {
      "indent": 3,
      "text": "string-restrictions = ;; these stmts can appear in any order [length-stmt] *pattern-stmt",
      "ja": "文字列の制限= ;;これらSTMTSは、任意の順序[長さのstmt] *パターンのstmtに表示されます"
    },
    {
      "indent": 3,
      "text": "length-stmt = length-keyword sep length-arg-str optsep (\";\" / \"{\" stmtsep ;; these stmts can appear in any order [error-message-stmt] [error-app-tag-stmt] [description-stmt] [reference-stmt] \"}\") stmtsep",
      "ja": "長STMT =長キーワード9月長さのarg-STR optsep（ \";\" / \"{\" stmtsep ;;これらSTMTSは任意の順序で現れることができる[エラーメッセージSTMT] [エラーAPP-タグSTMT] [説明-stmt] [参照STMT] \"}\"）stmtsep"
    },
    {
      "indent": 3,
      "text": "pattern-stmt = pattern-keyword sep string optsep (\";\" / \"{\" stmtsep ;; these stmts can appear in any order [modifier-stmt] [error-message-stmt] [error-app-tag-stmt] [description-stmt] [reference-stmt] \"}\") stmtsep",
      "ja": "パターンSTMT =パターンキーワード9月列optsep（ \";\" / \"{\" stmtsep ;;これらSTMTSは、任意の順序で現れることができる[修飾子-STMT] [エラーメッセージSTMT] [エラーAPP-タグSTMT] [説明-STMT] [参照STMT] \"}\"）stmtsep"
    },
    {
      "indent": 3,
      "text": "modifier-stmt = modifier-keyword sep modifier-arg-str stmtend",
      "ja": "stmtは=変更 - 変更 - 変更 -  9月のキーワードのarg-STRのstmtend"
    },
    {
      "indent": 3,
      "text": "modifier-arg-str = < a string that matches the rule > < modifier-arg >",
      "ja": "修飾子、引数-STR = <ルールにマッチした文字列> <修飾子、引数>"
    },
    {
      "indent": 3,
      "text": "modifier-arg = invert-match-keyword",
      "ja": "修飾子、引数=反転一致キーワード"
    },
    {
      "indent": 3,
      "text": "default-stmt = default-keyword sep string stmtend",
      "ja": "デフォルト-のstmt =デフォルト・キーワード9月の文字列stmtend"
    },
    {
      "indent": 3,
      "text": "enum-specification = 1*enum-stmt",
      "ja": "列挙型仕様= 1 *列挙-のstmt"
    },
    {
      "indent": 3,
      "text": "enum-stmt = enum-keyword sep string optsep (\";\" / \"{\" stmtsep ;; these stmts can appear in any order *if-feature-stmt [value-stmt] [status-stmt] [description-stmt] [reference-stmt] \"}\") stmtsep",
      "ja": "列挙-STMT =列挙キーワード9月列optsep（ \";\" / \"{\" stmtsep ;;これらSTMTSは、任意の順序で現れることができる* IF-特徴STMT [値-STMT] [ステータス-STMT] [説明-STMT] [基準STMT] \"}\"）stmtsep"
    },
    {
      "indent": 3,
      "text": "leafref-specification = ;; these stmts can appear in any order path-stmt [require-instance-stmt]",
      "ja": "leafref仕様= ;;これらSTMTSは、任意の順序パスSTMTの[必要インスタンス-STMT]に表示されることが"
    },
    {
      "indent": 3,
      "text": "path-stmt = path-keyword sep path-arg-str stmtend",
      "ja": "パスのstmt =パス・キーワード9月パス、引数-STRのstmtend"
    },
    {
      "indent": 3,
      "text": "require-instance-stmt = require-instance-keyword sep require-instance-arg-str stmtend",
      "ja": "stmtend-インスタンスのarg-STRの必要SEP必要-インスタンスのstmt =必要-インスタンスのキーワード"
    },
    {
      "indent": 3,
      "text": "require-instance-arg-str = < a string that matches the rule > < require-instance-arg >",
      "ja": "必要-インスタンス引数-STR = <ルールに一致する文字列> <必要-インスタンス引数>"
    },
    {
      "indent": 3,
      "text": "require-instance-arg = true-keyword / false-keyword instance-identifier-specification = [require-instance-stmt]",
      "ja": "必要-インスタンス引数=真キーワード/偽キーワードインスタンス識別子仕様= [必要インスタンス-STMT]"
    },
    {
      "indent": 3,
      "text": "identityref-specification = 1*base-stmt",
      "ja": "identityref仕様= 1 *ベースSTMT"
    },
    {
      "indent": 3,
      "text": "union-specification = 1*type-stmt",
      "ja": "組合仕様= 1 *タイプ-のstmt"
    },
    {
      "indent": 3,
      "text": "binary-specification = [length-stmt]",
      "ja": "バイナリ仕様= [長さSTMT]"
    },
    {
      "indent": 3,
      "text": "bits-specification = 1*bit-stmt",
      "ja": "ビット仕様= 1 *ビット-STMT"
    },
    {
      "indent": 3,
      "text": "bit-stmt = bit-keyword sep identifier-arg-str optsep (\";\" / \"{\" stmtsep ;; these stmts can appear in any order *if-feature-stmt [position-stmt] [status-stmt] [description-stmt] [reference-stmt] \"}\") stmtsep",
      "ja": "ビットSTMT =ビットキーワード9月識別子のarg-STR optsep（ \";\" / \"{\" stmtsep ;;これらSTMTSは任意の順序で現れることができる* IF-特徴STMT [位置STMT] [ステータス-STMT] [説明-stmt] [参照STMT] \"}\"）stmtsep"
    },
    {
      "indent": 3,
      "text": "position-stmt = position-keyword sep position-value-arg-str stmtend",
      "ja": "位置のstmt =位置-キーワード9月位置値、引数-STRのstmtend"
    },
    {
      "indent": 3,
      "text": "position-value-arg-str = < a string that matches the rule > < position-value-arg >",
      "ja": "位置値は、引数-STR = <ルールに一致する文字列> <位置値、引数>"
    },
    {
      "indent": 3,
      "text": "position-value-arg = non-negative-integer-value",
      "ja": "位置値は、引数=非負整数値"
    },
    {
      "indent": 3,
      "text": "status-stmt = status-keyword sep status-arg-str stmtend",
      "ja": "ステータスのstmt =ステータスキーワード9月の状態、引数-STR stmtend"
    },
    {
      "indent": 3,
      "text": "status-arg-str = < a string that matches the rule > < status-arg >",
      "ja": "状態、引数-STR = <ルールにマッチした文字列> <状況、引数>"
    },
    {
      "indent": 3,
      "text": "status-arg = current-keyword / obsolete-keyword / deprecated-keyword",
      "ja": "状態、引数=現在のキーワード/時代遅れ-キーワード/非推奨のキーワード"
    },
    {
      "indent": 3,
      "text": "config-stmt = config-keyword sep config-arg-str stmtend",
      "ja": "コンフィグ-のstmt = configのキーワード9月コンフィグ-argを-STR stmtend"
    },
    {
      "indent": 3,
      "text": "config-arg-str = < a string that matches the rule > < config-arg >",
      "ja": "コンフィグ-argを-STR = <ルールにマッチした文字列>の<config-argに>"
    },
    {
      "indent": 3,
      "text": "config-arg = true-keyword / false-keyword mandatory-stmt = mandatory-keyword sep mandatory-arg-str stmtend",
      "ja": "設定、引数=真のキーワード/偽キーワード必須-のstmt =必須キーワード9月必須-argを-STRのstmtend"
    },
    {
      "indent": 3,
      "text": "mandatory-arg-str = < a string that matches the rule > < mandatory-arg >",
      "ja": "必須-argを-STR = <ルールにマッチした文字列> <必須-argに>"
    },
    {
      "indent": 3,
      "text": "mandatory-arg = true-keyword / false-keyword",
      "ja": "必須、引数=真のキーワード/偽のキーワード"
    },
    {
      "indent": 3,
      "text": "presence-stmt = presence-keyword sep string stmtend",
      "ja": "プレゼンスのstmt =存在キーワード9月の文字列stmtend"
    },
    {
      "indent": 3,
      "text": "ordered-by-stmt = ordered-by-keyword sep ordered-by-arg-str stmtend",
      "ja": "注文したバイのstmt =注文・バイ・キーワード9月命じ-により、引数-STR stmtend"
    },
    {
      "indent": 3,
      "text": "ordered-by-arg-str = < a string that matches the rule > < ordered-by-arg >",
      "ja": "注文ごとの引数-STR = <ルールにマッチした文字列> <命じ-により、引数>"
    },
    {
      "indent": 3,
      "text": "ordered-by-arg = user-keyword / system-keyword",
      "ja": "注文ごとの引数=ユーザーのキーワード/システムのキーワード"
    },
    {
      "indent": 3,
      "text": "must-stmt = must-keyword sep string optsep (\";\" / \"{\" stmtsep ;; these stmts can appear in any order [error-message-stmt] [error-app-tag-stmt] [description-stmt] [reference-stmt] \"}\") stmtsep",
      "ja": "マストSTMT =マストキーワード月列optsep（ \";\" / \"{\" stmtsep ;;これらSTMTSは任意の順序で現れることができる[エラーメッセージSTMT] [エラーAPP-タグSTMT] [説明-STMT] [基準STMT] \"}\"）stmtsep"
    },
    {
      "indent": 3,
      "text": "error-message-stmt = error-message-keyword sep string stmtend",
      "ja": "エラー・メッセージのstmt =エラー・メッセージ・キーワード9月の文字列stmtend"
    },
    {
      "indent": 3,
      "text": "error-app-tag-stmt = error-app-tag-keyword sep string stmtend",
      "ja": "エラー・アプリ・タグのstmt =エラー - アプリ - タグ・キーワード9月の文字列stmtend"
    },
    {
      "indent": 3,
      "text": "min-elements-stmt = min-elements-keyword sep min-value-arg-str stmtend",
      "ja": "最小要素-STMT = MIN-要素キーワード9月最小値、引数、STR stmtend"
    },
    {
      "indent": 3,
      "text": "min-value-arg-str = < a string that matches the rule > < min-value-arg >",
      "ja": "最小値は、引数-STR = <ルールに一致する文字列> <最小値、引数>"
    },
    {
      "indent": 3,
      "text": "min-value-arg = non-negative-integer-value",
      "ja": "最小値は、引数=非負整数値"
    },
    {
      "indent": 3,
      "text": "max-elements-stmt = max-elements-keyword sep max-value-arg-str stmtend",
      "ja": "MAX-要素-のstmt = MAX-要素キーワード月の最大値、引数-STR stmtend"
    },
    {
      "indent": 3,
      "text": "max-value-arg-str = < a string that matches the rule > < max-value-arg >",
      "ja": "最大値、引数-STR = <ルールにマッチした文字列> <最大値、引数>"
    },
    {
      "indent": 3,
      "text": "max-value-arg = unbounded-keyword / positive-integer-value",
      "ja": "最大値、引数=無制限のキーワード/正の整数値"
    },
    {
      "indent": 3,
      "text": "value-stmt = value-keyword sep integer-value-str stmtend",
      "ja": "値-STMT =値キーワード9月整数値-STRのstmtend"
    },
    {
      "indent": 3,
      "text": "integer-value-str = < a string that matches the rule > < integer-value >",
      "ja": "整数値-STR = <ルールに一致する文字列> <整数値>"
    },
    {
      "indent": 3,
      "text": "grouping-stmt = grouping-keyword sep identifier-arg-str optsep (\";\" / \"{\" stmtsep ;; these stmts can appear in any order [status-stmt] [description-stmt] [reference-stmt] *(typedef-stmt / grouping-stmt) *data-def-stmt *action-stmt *notification-stmt \"}\") stmtsep",
      "ja": "グルーピング-STMT =グルーピングキーワード9月識別子のarg-STR optsep（ \";\" / \"{\" stmtsep ;;これらSTMTSは* [参照STMT] [説明-STMT] [ステータス-STMT]任意の順序で現れることができる（のtypedef -stmt /グルーピング-STMT）*データ-DEF-STMT *アクションSTMT *通知STMT \"}\"）stmtsep"
    },
    {
      "indent": 3,
      "text": "container-stmt = container-keyword sep identifier-arg-str optsep (\";\" / \"{\" stmtsep ;; these stmts can appear in any order [when-stmt] *if-feature-stmt *must-stmt [presence-stmt] [config-stmt] [status-stmt] [description-stmt] [reference-stmt] *(typedef-stmt / grouping-stmt) *data-def-stmt *action-stmt *notification-stmt \"}\") stmtsep",
      "ja": "コンテナSTMT =コンテナキーワード9月識別子のarg-STR optsep（ \";\" / \"{\" stmtsep ;;これらSTMTSは、[任意の順番[-STMT] * IF-特徴STMTの*マストSTMTに表示できますpresence- STMT] [CONFIG-STMT] [ステータス-STMT] [説明-STMT] [参照STMT] *（のtypedef-STMT /グルーピング-STMT）*データ-DEF-STMT *アクションSTMT *通知STMT \"}\"） stmtsep"
    },
    {
      "indent": 3,
      "text": "leaf-stmt = leaf-keyword sep identifier-arg-str optsep \"{\" stmtsep ;; these stmts can appear in any order [when-stmt] *if-feature-stmt type-stmt [units-stmt] *must-stmt [default-stmt] [config-stmt] [mandatory-stmt] [status-stmt] [description-stmt] [reference-stmt] \"}\" stmtsep",
      "ja": "リーフSTMT =リーフキーワード9月識別子のarg-STR optsep \"{\" stmtsep ;;型のstmt [単位-のstmt]素性のstmtの場合は、これらのSTMTSは、[ステータスのstmt] [必須-のstmt] [設定-のstmt]のマストのstmt [デフォルト-のstmt] * *任意の順序[-のstmt]に表示されます[説明-STMT] [参照STMT] \"}\" stmtsep"
    },
    {
      "indent": 3,
      "text": "leaf-list-stmt = leaf-list-keyword sep identifier-arg-str optsep \"{\" stmtsep ;; these stmts can appear in any order [when-stmt] *if-feature-stmt type-stmt stmtsep [units-stmt] *must-stmt *default-stmt [config-stmt] [min-elements-stmt] [max-elements-stmt] [ordered-by-stmt] [status-stmt] [description-stmt] [reference-stmt] \"}\" stmtsep",
      "ja": "リーフリストSTMT =リーフリストキーワード9月識別子のarg-STR optsep \"{\" stmtsep ;;これらSTMTS *は任意の順序[とき-のstmt]に表示されることがあれば、機能-のstmt型のstmtのstmtsep [単位-のstmt] *必要-のstmt *デフォルト-stmtは[設定-のstmt] [分-要素-のstmt] [MAX-要素-STMT] [順序付けバイSTMT] [ステータス-STMT] [説明-STMT] [参照STMT] \"}\" stmtsep"
    },
    {
      "indent": 3,
      "text": "list-stmt = list-keyword sep identifier-arg-str optsep \"{\" stmtsep ;; these stmts can appear in any order [when-stmt] *if-feature-stmt *must-stmt [key-stmt] *unique-stmt [config-stmt] [min-elements-stmt] [max-elements-stmt] [ordered-by-stmt] [status-stmt] [description-stmt] [reference-stmt] *(typedef-stmt / grouping-stmt) 1*data-def-stmt *action-stmt *notification-stmt \"}\" stmtsep",
      "ja": "リストSTMT =リストキーワード9月識別子のarg-STR optsep \"{\" stmtsep ;;これらSTMTSは、*は任意の順序[とき-のstmt]に表示されることがあれば、機能-のstmtの*なければならない - のstmt [キーのstmt] *ユニーク-stmtは[設定-のstmt] [分-要素-のstmt] [MAX-要素-のstmt] [順序付けバイSTMT] [ステータス-STMT] [説明-STMT] [参照STMT] *（のtypedef-STMT /グルーピング-STMT）1 *データ-DEF-STMT *アクションSTMT *通知STMT \"}\" stmtsep"
    },
    {
      "indent": 3,
      "text": "key-stmt = key-keyword sep key-arg-str stmtend",
      "ja": "キーのstmt =キーのキーワード9月キーのarg-STR stmtend"
    },
    {
      "indent": 3,
      "text": "key-arg-str = < a string that matches the rule > < key-arg >",
      "ja": "キーのarg-STR = <ルールにマッチした文字列> <キーのarg>"
    },
    {
      "indent": 3,
      "text": "key-arg = node-identifier *(sep node-identifier)",
      "ja": "キー引数=ノード識別子*（SEPノード識別子）"
    },
    {
      "indent": 3,
      "text": "unique-stmt = unique-keyword sep unique-arg-str stmtend",
      "ja": "ユニーク-のstmt =ユニークなキーワード月ユニーク-argを-STR stmtend"
    },
    {
      "indent": 3,
      "text": "unique-arg-str = < a string that matches the rule > < unique-arg >",
      "ja": "ユニーク-argを-STR = <ルールにマッチした文字列> <ユニーク-argに>"
    },
    {
      "indent": 3,
      "text": "unique-arg = descendant-schema-nodeid *(sep descendant-schema-nodeid)",
      "ja": "一意のarg =子孫-スキーマNODEIDの*（SEP子孫-スキーマNODEID）"
    },
    {
      "indent": 3,
      "text": "choice-stmt = choice-keyword sep identifier-arg-str optsep (\";\" / \"{\" stmtsep ;; these stmts can appear in any order [when-stmt] *if-feature-stmt [default-stmt] [config-stmt] [mandatory-stmt] [status-stmt] [description-stmt] [reference-stmt] *(short-case-stmt / case-stmt) \"}\") stmtsep",
      "ja": "選択-のstmt =選択-キーワード9月の識別子、引数-STR optsep（ \";\" / \"{\" stmtsep ;;これらSTMTSは、任意の順序[-のstmt]に表示されます*場合、機能-のstmt [デフォルト-のstmt] [設定-stmt] [必須-STMT] [ステータス-STMT] [説明-STMT] [参照STMT] *（短ケースSTMT /ケースSTMT） \"}\"）stmtsep"
    },
    {
      "indent": 3,
      "text": "short-case-stmt = choice-stmt / container-stmt / leaf-stmt / leaf-list-stmt / list-stmt / anydata-stmt / anyxml-stmt",
      "ja": "短いケースのstmt =選択-STMT /コンテナのstmt /リーフのstmt /リーフリストのstmt /リストのstmt / ANYDATA-のstmt / AnyXMLで-のstmt"
    },
    {
      "indent": 3,
      "text": "case-stmt = case-keyword sep identifier-arg-str optsep (\";\" / \"{\" stmtsep ;; these stmts can appear in any order [when-stmt] *if-feature-stmt [status-stmt] [description-stmt] [reference-stmt] *data-def-stmt \"}\") stmtsep",
      "ja": "ケースSTMT =ケースキーワード9月識別子のarg-STR optsep（ \";\" / \"{\" stmtsep ;;これらSTMTS任意の順序[-STMT]に表示されることができるが、* IF-特徴STMT [ステータス-STMT] [説明-stmt] [参照STMT] *データ-DEF-STMT \"}\"）stmtsep"
    },
    {
      "indent": 3,
      "text": "anydata-stmt = anydata-keyword sep identifier-arg-str optsep (\";\" / \"{\" stmtsep ;; these stmts can appear in any order [when-stmt] *if-feature-stmt *must-stmt [config-stmt] [mandatory-stmt] [status-stmt] [description-stmt] [reference-stmt] \"}\") stmtsep",
      "ja": "ANYDATA-STMT = ANYDATAキーワード9月識別子のarg-STR optsep（ \";\" / \"{\" stmtsep ;;これらSTMTS任意の順序[-STMT]に表示されることができる* IF-特徴STMTの*マストSTMT [CONFIG- STMT] [必須-STMT] [ステータス-STMT] [説明-STMT] [参照STMT] \"}\"）stmtsep"
    },
    {
      "indent": 3,
      "text": "anyxml-stmt = anyxml-keyword sep identifier-arg-str optsep (\";\" / \"{\" stmtsep ;; these stmts can appear in any order [when-stmt] *if-feature-stmt *must-stmt [config-stmt] [mandatory-stmt] [status-stmt] [description-stmt] [reference-stmt] \"}\") stmtsep",
      "ja": "AnyXMLで-STMT = AnyXMLでキーワード9月識別子のarg-STRのoptsep（ \";\" / \"{\" stmtsep ;;これらSTMTSは任意の順序で現れることができる[場合-STMT] * IF-特徴STMT *マストSTMT [CONFIG- STMT] [必須-STMT] [ステータス-STMT] [説明-STMT] [参照STMT] \"}\"）stmtsep"
    },
    {
      "indent": 3,
      "text": "uses-stmt = uses-keyword sep identifier-ref-arg-str optsep (\";\" / \"{\" stmtsep ;; these stmts can appear in any order [when-stmt] *if-feature-stmt [status-stmt] [description-stmt] [reference-stmt] *refine-stmt *uses-augment-stmt \"}\") stmtsep",
      "ja": "使用-STMTは=をSep識別子-REF-のarg-STR-キーワード使用optsep（ \";\" / \"{\" stmtsep ;;これらSTMTS任意の順序[-STMT]に表示されることができる* IF-特徴STMT [ステータス-STMT]を[説明-STMT] [参照STMT] *絞り込み-STMT *使用-増強-STMT \"}\"）stmtsep"
    },
    {
      "indent": 3,
      "text": "refine-stmt = refine-keyword sep refine-arg-str optsep \"{\" stmtsep ;; these stmts can appear in any order *if-feature-stmt *must-stmt [presence-stmt] *default-stmt [config-stmt] [mandatory-stmt] [min-elements-stmt] [max-elements-stmt] [description-stmt] [reference-stmt] \"}\" stmtsep",
      "ja": "絞り込み-STMT =絞り込みキーワード絞り込み、引数-STR SEP optsepを \"{\" stmtsep ;;これらSTMTSは*どのような順序で表示されることがあれば、機能-のstmt *なければならない-STMT [プレゼンスのstmt] *デフォルト-stmtは[設定-のstmt] [必須-のstmt] [分-要素-のstmt] [MAX-要素-のstmt] [説明-STMT] [参照STMT] \"}\" stmtsep"
    },
    {
      "indent": 3,
      "text": "refine-arg-str = < a string that matches the rule > < refine-arg >",
      "ja": "洗練-argを-STR = <ルールにマッチした文字列> <絞り込む-argに>"
    },
    {
      "indent": 3,
      "text": "refine-arg = descendant-schema-nodeid",
      "ja": "絞り込み、引数=子孫-スキーマNODEID"
    },
    {
      "indent": 3,
      "text": "uses-augment-stmt = augment-keyword sep uses-augment-arg-str optsep \"{\" stmtsep ;; these stmts can appear in any order [when-stmt] *if-feature-stmt [status-stmt] [description-stmt] [reference-stmt] 1*(data-def-stmt / case-stmt / action-stmt / notification-stmt) \"}\" stmtsep",
      "ja": "使用-増強-STMT = 9月キーワードが増強-使用-増強、引数-STR optsep \"{\" stmtsep ;;これらSTMTSは任意の順番[場合-STMT]に表示されることができる* IF-特徴STMT [ステータス-STMT] [説明-STMT] [参照STMT] 1 *（データ-DEF-STMT /ケースSTMT /アクションSTMT /通知STMT） \"}\" stmtsep"
    },
    {
      "indent": 3,
      "text": "uses-augment-arg-str = < a string that matches the rule > < uses-augment-arg >",
      "ja": "使用しています-オーグメント-argを-STR = <ルールに一致した文字列> <使用-オーグメント、引数>"
    },
    {
      "indent": 3,
      "text": "uses-augment-arg = descendant-schema-nodeid augment-stmt = augment-keyword sep augment-arg-str optsep \"{\" stmtsep ;; these stmts can appear in any order [when-stmt] *if-feature-stmt [status-stmt] [description-stmt] [reference-stmt] 1*(data-def-stmt / case-stmt / action-stmt / notification-stmt) \"}\" stmtsep",
      "ja": "使用-増強、引数=子孫-スキーマNODEID増強-STMT =増強キーワード増強、引数-STR SEP optsep \"{\" stmtsepを;;これらSTMTSは任意の順番[場合-STMT]に表示されることができる* IF-特徴STMT [ステータス-STMT] [説明-STMT] [参照STMT] 1 *（データ-DEF-STMT /ケースSTMT /アクションSTMT /通知STMT） \"}\" stmtsep"
    },
    {
      "indent": 3,
      "text": "augment-arg-str = < a string that matches the rule > < augment-arg >",
      "ja": "増補、引数-STR = <ルールにマッチした文字列> <オーグメント、引数>"
    },
    {
      "indent": 3,
      "text": "augment-arg = absolute-schema-nodeid",
      "ja": "増強、引数=絶対スキーマNODEID"
    },
    {
      "indent": 3,
      "text": "when-stmt = when-keyword sep string optsep (\";\" / \"{\" stmtsep ;; these stmts can appear in any order [description-stmt] [reference-stmt] \"}\") stmtsep",
      "ja": "場合-STMT =とき、キーワード9月列optsep（ \";\" / \"{\" stmtsep ;;これらSTMTSは任意の順序で現れることができる[説明-STMT] [参照STMT] \"}\"）stmtsep"
    },
    {
      "indent": 3,
      "text": "rpc-stmt = rpc-keyword sep identifier-arg-str optsep (\";\" / \"{\" stmtsep ;; these stmts can appear in any order *if-feature-stmt [status-stmt] [description-stmt] [reference-stmt] *(typedef-stmt / grouping-stmt) [input-stmt] [output-stmt] \"}\") stmtsep",
      "ja": "RPC-STMT = RPCキーワード9月識別子のarg-STR optsep（ \";\" / \"{\" stmtsep ;;これらSTMTSは任意の順序で現れることができる* IF-特徴STMT [ステータス-STMT] [説明-STMT] [参照-stmt] *（のtypedef-STMT /グループ化STMT）入力STMT] [出力STMT] \"}\"）stmtsep"
    },
    {
      "indent": 3,
      "text": "action-stmt = action-keyword sep identifier-arg-str optsep (\";\" / \"{\" stmtsep ;; these stmts can appear in any order *if-feature-stmt [status-stmt] [description-stmt] [reference-stmt] *(typedef-stmt / grouping-stmt) [input-stmt] [output-stmt] \"}\") stmtsep",
      "ja": "アクションSTMT =アクションキーワード9月識別子のarg-STRのoptsep（ \";\" / \"{\" stmtsep ;;これらSTMTSは任意の順序で現れることができる* IF-特徴STMT [ステータス-STMT] [説明-STMT] [参照-stmt] *（のtypedef-STMT /グループ化STMT）入力STMT] [出力STMT] \"}\"）stmtsep"
    },
    {
      "indent": 3,
      "text": "input-stmt = input-keyword optsep \"{\" stmtsep ;; these stmts can appear in any order *must-stmt *(typedef-stmt / grouping-stmt) 1*data-def-stmt \"}\" stmtsep",
      "ja": "入力STMT =入力キーワードoptsep \"{\" stmtsep ;;これらSTMTSは、任意の順序*マストSTMT×（のtypedef-STMT /グルーピング-STMT）1 *データ-DEF-STMT \"}\" stmtsepに表示でき"
    },
    {
      "indent": 3,
      "text": "output-stmt = output-keyword optsep \"{\" stmtsep ;; these stmts can appear in any order *must-stmt *(typedef-stmt / grouping-stmt) 1*data-def-stmt \"}\" stmtsep",
      "ja": "出力STMT =出力キーワードoptsep \"{\" stmtsep ;;これらSTMTSは、任意の順序*マストSTMT×（のtypedef-STMT /グルーピング-STMT）1 *データ-DEF-STMT \"}\" stmtsepに表示でき"
    },
    {
      "indent": 3,
      "text": "notification-stmt = notification-keyword sep identifier-arg-str optsep (\";\" / \"{\" stmtsep ;; these stmts can appear in any order *if-feature-stmt *must-stmt [status-stmt] [description-stmt] [reference-stmt] *(typedef-stmt / grouping-stmt) *data-def-stmt \"}\") stmtsep",
      "ja": "通知STMT =通知キーワード9月識別子のarg-STRのoptsep（ \";\" / \"{\" stmtsep ;;これらSTMTS *は任意の順序で現れることができれば、特徴STMT *マストSTMT [ステータス-STMT] [の説明 - STMT] [参照STMT] *（のtypedef-STMT /グルーピング-STMT）*データ-DEF-STMT \"}\"）stmtsep"
    },
    {
      "indent": 3,
      "text": "deviation-stmt = deviation-keyword sep deviation-arg-str optsep \"{\" stmtsep ;; these stmts can appear in any order [description-stmt] [reference-stmt] (deviate-not-supported-stmt / 1*(deviate-add-stmt / deviate-replace-stmt / deviate-delete-stmt)) \"}\" stmtsep",
      "ja": "偏差-STMT =偏差キーワード9月偏差のarg-STR optsep \"{\" stmtsep ;;これらSTMTSは任意の順序で現れることができる[説明-STMT] [参照STMT]（サポートしない逸脱-STMT / 1 *（ずれ-アドインSTMT /逸脱-置き換える-STMT /逸脱-DELETE-STMT））を「} 「stmtsep"
    },
    {
      "indent": 3,
      "text": "deviation-arg-str = < a string that matches the rule > < deviation-arg >",
      "ja": "偏差のarg-STR = <ルールに一致する文字列> <偏差、引数>"
    },
    {
      "indent": 3,
      "text": "deviation-arg = absolute-schema-nodeid",
      "ja": "偏差引数=絶対スキーマNODEID"
    },
    {
      "indent": 3,
      "text": "deviate-not-supported-stmt = deviate-keyword sep not-supported-keyword-str stmtend",
      "ja": " -   - サポートされていない - のstmtを逸脱=ずれる-キーワード9月 - サポートされていないキーワード-STRのstmtend"
    },
    {
      "indent": 3,
      "text": "deviate-add-stmt = deviate-keyword sep add-keyword-str optsep (\";\" / \"{\" stmtsep ;; these stmts can appear in any order [units-stmt] *must-stmt *unique-stmt *default-stmt [config-stmt] [mandatory-stmt] [min-elements-stmt] [max-elements-stmt] \"}\") stmtsep",
      "ja": "逸脱-アドインSTMT =ずれキーワード追加キーワード-STR optsep（SEP \";\" / \"{\" stmtsep ;;これらSTMTSは*任意の順序[単位-STMT] *マストSTMT *ユニーク-STMTに表示されることがdefault- STMT [CONFIG-STMT] [必須-STMT] [MIN-要素-STMT] [MAX-要素-STMT] \"}\"）stmtsep"
    },
    {
      "indent": 3,
      "text": "deviate-delete-stmt = deviate-keyword sep delete-keyword-str optsep (\";\" / \"{\" stmtsep ;; these stmts can appear in any order [units-stmt] *must-stmt *unique-stmt *default-stmt \"}\") stmtsep",
      "ja": "逸脱-DELETE-STMT =ずれキーワードは削除キーワード-STRのSEP optsep（ \";\" / \"{\" stmtsep ;;これらSTMTSは任意の順序で現れることができる[単位-STMT] *マストSTMT *ユニーク-STMT * default-をstmtは \"}\"）stmtsep"
    },
    {
      "indent": 3,
      "text": "deviate-replace-stmt = deviate-keyword sep replace-keyword-str optsep (\";\" / \"{\" stmtsep ;; these stmts can appear in any order [type-stmt] [units-stmt] [default-stmt] [config-stmt] [mandatory-stmt] [min-elements-stmt] [max-elements-stmt] \"}\") stmtsep",
      "ja": "逸脱-交換-STMT =ずれキーワード置き換えるキーワード-STRのSEP optsep（ \";\" / \"{\" stmtsep ;;これらSTMTSは任意の順序で現れることができるが、[タイプSTMT] [単位-STMT] [デフォルト-STMT] [ CONFIG-STMT] [必須-STMT] [MIN-要素-STMT] [MAX-要素-STMT] \"}\"）stmtsep"
    },
    {
      "indent": 3,
      "text": "not-supported-keyword-str = < a string that matches the rule > < not-supported-keyword >",
      "ja": " - サポートされていないキーワード-STR = <ルールにマッチした文字列> <-サポートされていないキーワード>"
    },
    {
      "indent": 3,
      "text": "add-keyword-str = < a string that matches the rule > < add-keyword >",
      "ja": "= STR-キーワードを-追加<ルールに一致する文字列>の<add-キーワード>"
    },
    {
      "indent": 3,
      "text": "delete-keyword-str = < a string that matches the rule > < delete-keyword >",
      "ja": "削除キーワード-STR = <削除-キーワード> <ルール一致する文字列>を"
    },
    {
      "indent": 3,
      "text": "replace-keyword-str = < a string that matches the rule > < replace-keyword >",
      "ja": "交換するキーワード-STR = <置き換え-キーワード> <ルール一致する文字列>を"
    },
    {
      "indent": 3,
      "text": ";; represents the usage of an extension unknown-statement = prefix \":\" identifier [sep string] optsep (\";\" / \"{\" optsep *((yang-stmt / unknown-statement) optsep) \"}\") stmtsep",
      "ja": ";;拡張未知文=接頭辞の使用を表す \"：\" 識別子[9月ストリング] optsep（ \";\" / \"{\" optsep×（（ヤン-STMT /未知文）optsep） \"}\"）stmtsep"
    },
    {
      "indent": 3,
      "text": "yang-stmt = action-stmt / anydata-stmt / anyxml-stmt / argument-stmt / augment-stmt / base-stmt / belongs-to-stmt / bit-stmt / case-stmt / choice-stmt / config-stmt / contact-stmt / container-stmt / default-stmt / description-stmt / deviate-add-stmt / deviate-delete-stmt / deviate-not-supported-stmt / deviate-replace-stmt / deviation-stmt / enum-stmt / error-app-tag-stmt / error-message-stmt / extension-stmt / feature-stmt / fraction-digits-stmt / grouping-stmt / identity-stmt / if-feature-stmt / import-stmt / include-stmt / input-stmt / key-stmt / leaf-list-stmt / leaf-stmt / length-stmt / list-stmt / mandatory-stmt / max-elements-stmt / min-elements-stmt / modifier-stmt / module-stmt / must-stmt / namespace-stmt / notification-stmt / ordered-by-stmt / organization-stmt / output-stmt / path-stmt / pattern-stmt / position-stmt / prefix-stmt / presence-stmt / range-stmt / reference-stmt / refine-stmt / require-instance-stmt / revision-date-stmt / revision-stmt / rpc-stmt / status-stmt / submodule-stmt / typedef-stmt / type-stmt / unique-stmt / units-stmt / uses-augment-stmt / uses-stmt / value-stmt / when-stmt / yang-version-stmt / yin-element-stmt",
      "ja": "陽-STMT =アクションSTMT / ANYDATA-STMT / AnyXMLで-STMT /引数STMT /増強-STMT /ベースSTMT /属するツーSTMT /ビットSTMT /ケースSTMT /選択-STMT / CONFIG-STMT /連絡-STMT /コンテナのstmt /デフォルト-のstmt /説明-のstmt /逸脱-アドオンのstmt /逸脱-削除-のstmt /逸脱-ないサポート-のstmt /逸脱-置き換える-のstmt /偏差-のstmt /列挙-のstmt /エラーアプリタグ-STMT /エラーメッセージSTMT /拡張STMT /特徴STMT /フラクション桁-STMT /グルーピング-STMT /アイデンティティ-STMT / IF-特徴STMT /インポートSTMT /包含STMT /入力STMT /キーSTMT /リーフリストSTMT /リーフSTMT /長STMT /リストSTMT /必須-STMT / MAX-要素-STMT /分の要素-STMT /修飾子-STMT /モジュールSTMT /マストSTMT /名前空間STMT /通知STMT /順序付けバイSTMT /組織STMT /出力STMT /パスSTMT /パターンSTMT /位置STMT /プレフィックスSTMT /プレゼンスSTMT /レンジSTMT /参照STMT /絞り込み-STMT /必要インスタンス-STMT /改訂日付-STMT /リビジョンSTMT / RPC-STMT /ステータスSTMT /サブモジュール-STMT / typedefは、STMT /タイプSTMT /ユニーク-STMT /単位-STMT /使用-増強-STMT /使用-STMT /価値STMT /場合-STMT /陽バージョン-STMT /陰元素STMT"
    },
    {
      "indent": 3,
      "text": ";; Ranges",
      "ja": ";;レンジ"
    },
    {
      "indent": 3,
      "text": "range-arg-str = < a string that matches the rule > < range-arg >",
      "ja": "レンジのarg-STR = <ルールに一致する文字列> <範囲、引数>"
    },
    {
      "indent": 3,
      "text": "range-arg = range-part *(optsep \"|\" optsep range-part)",
      "ja": "範囲、引数=レンジパート*（optsep「|」optsep範囲の部分）"
    },
    {
      "indent": 3,
      "text": "range-part = range-boundary [optsep \"..\" optsep range-boundary]",
      "ja": "範囲の部分=範囲境界[optsep「..」optsep範囲境界]"
    },
    {
      "indent": 3,
      "text": "range-boundary = min-keyword / max-keyword / integer-value / decimal-value",
      "ja": "範囲境界=分キーワード/ MAX-キーワード/整数値/ 10進値"
    },
    {
      "indent": 3,
      "text": ";; Lengths",
      "ja": ";;長さ"
    },
    {
      "indent": 3,
      "text": "length-arg-str = < a string that matches the rule > < length-arg >",
      "ja": "長さのarg-STR = <ルールに一致する文字列> <長さ引数>"
    },
    {
      "indent": 3,
      "text": "length-arg = length-part *(optsep \"|\" optsep length-part)",
      "ja": "長さは、引数=長さの部分から*（optsep「|」optsep長の部分）"
    },
    {
      "indent": 3,
      "text": "length-part = length-boundary [optsep \"..\" optsep length-boundary]",
      "ja": "長さの部分=長境界[optsep「..」optsep長境界]"
    },
    {
      "indent": 3,
      "text": "length-boundary = min-keyword / max-keyword / non-negative-integer-value",
      "ja": "長境界=分キーワード/ MAX-キーワード/非負整数値"
    },
    {
      "indent": 3,
      "text": ";; Date",
      "ja": ";;日付"
    },
    {
      "indent": 3,
      "text": "date-arg-str = < a string that matches the rule > < date-arg >",
      "ja": "日付引数-STR = <ルールにマッチした文字列> <日付引数>"
    },
    {
      "indent": 3,
      "text": "date-arg = 4DIGIT \"-\" 2DIGIT \"-\" 2DIGIT",
      "ja": "日付引数= 4 DIGIT \" - \" 2 DIGIT \" - \" 2 DIGIT"
    },
    {
      "indent": 3,
      "text": ";; Schema Node Identifiers",
      "ja": ";;スキーマのノード識別子"
    },
    {
      "indent": 3,
      "text": "schema-nodeid = absolute-schema-nodeid / descendant-schema-nodeid",
      "ja": "スキーマNODEID =絶対スキーマNODEID /子孫-スキーマNODEID"
    },
    {
      "indent": 3,
      "text": "absolute-schema-nodeid = 1*(\"/\" node-identifier) descendant-schema-nodeid = node-identifier [absolute-schema-nodeid]",
      "ja": "絶対スキーマNODEID = 1 *（ \"/\" ノード識別子）子孫-スキーマNODEID =ノード識別子[絶対スキーマNODEID]"
    },
    {
      "indent": 3,
      "text": "node-identifier = [prefix \":\"] identifier",
      "ja": "ノード識別子= [接頭辞「：」]識別子"
    },
    {
      "indent": 3,
      "text": ";; Instance Identifiers",
      "ja": ";;インスタンス識別子"
    },
    {
      "indent": 3,
      "text": "instance-identifier = 1*(\"/\" (node-identifier [1*key-predicate / leaf-list-predicate / pos]))",
      "ja": "インスタンス識別子= 1 *（ \"/\"（ノード識別子[1 *キー述語/リーフリスト述語/ POS]））"
    },
    {
      "indent": 3,
      "text": "key-predicate = \"[\" *WSP key-predicate-expr *WSP \"]\"",
      "ja": "キー述語= \"[\" * WSPキー述語-exprのの*のWSP \"]\""
    },
    {
      "indent": 3,
      "text": "key-predicate-expr = node-identifier *WSP \"=\" *WSP quoted-string",
      "ja": "キー述語-exprの=ノード識別子* WSP \"=\" * WSP引用符で囲まれた文字列"
    },
    {
      "indent": 3,
      "text": "leaf-list-predicate = \"[\" *WSP leaf-list-predicate-expr *WSP \"]\"",
      "ja": "リーフリスト述語= \"[\" * WSPの葉-リスト述語-exprのの*のWSP \"]\""
    },
    {
      "indent": 3,
      "text": "leaf-list-predicate-expr = \".\" *WSP \"=\" *WSP quoted-string",
      "ja": "リーフリスト述語-exprの= \"\" * WSP \"=\" * WSP引用符で囲まれた文字列"
    },
    {
      "indent": 3,
      "text": "pos = \"[\" *WSP positive-integer-value *WSP \"]\"",
      "ja": "POS = \"[\" * WSP正整数値* WSP \"]\""
    },
    {
      "indent": 3,
      "text": "quoted-string = (DQUOTE string DQUOTE) / (SQUOTE string SQUOTE)",
      "ja": "引用符で囲んだ文字列=（DQUOTE列DQUOTE）/（BQUOTE強いQUOTES）"
    },
    {
      "indent": 3,
      "text": ";; leafref path",
      "ja": ";; leafrefパス"
    },
    {
      "indent": 3,
      "text": "path-arg-str = < a string that matches the rule > < path-arg >",
      "ja": "パスのarg-STR = <ルールに一致する文字列> <パス引数>"
    },
    {
      "indent": 3,
      "text": "path-arg = absolute-path / relative-path",
      "ja": "パス引数=絶対パス/相対パス"
    },
    {
      "indent": 3,
      "text": "absolute-path = 1*(\"/\" (node-identifier *path-predicate))",
      "ja": "絶対パス= 1 *（「/」（ノード識別子*パス述語））"
    },
    {
      "indent": 3,
      "text": "relative-path = 1*(\"../\") descendant-path",
      "ja": "相対パス= 1 *（「../」）子孫パス"
    },
    {
      "indent": 3,
      "text": "descendant-path = node-identifier [*path-predicate absolute-path]",
      "ja": "子孫パス=ノード識別子[*パス述語絶対パス]"
    },
    {
      "indent": 3,
      "text": "path-predicate = \"[\" *WSP path-equality-expr *WSP \"]\"",
      "ja": "パス述語= \"[\" * WSPパス平等-exprのの*のWSP \"]\""
    },
    {
      "indent": 3,
      "text": "path-equality-expr = node-identifier *WSP \"=\" *WSP path-key-expr",
      "ja": "パス平等-exprの=ノード識別子* WSP \"=\" * WSPパス・キー式expr"
    },
    {
      "indent": 3,
      "text": "path-key-expr = current-function-invocation *WSP \"/\" *WSP rel-path-keyexpr",
      "ja": "パス-keyexpr =電流機能の呼び出し* WSP \"/\" * WSP相対パス-keyexpr"
    },
    {
      "indent": 3,
      "text": "rel-path-keyexpr = 1*(\"..\" *WSP \"/\" *WSP) *(node-identifier *WSP \"/\" *WSP) node-identifier",
      "ja": "REL-経路keyexpr = 1 *（ \"..\" * WSP \"/\" * WSP）*（*ノード識別子WSP \"/\" * WSP）ノード識別子"
    },
    {
      "indent": 3,
      "text": ";;; Keywords, using the syntax for case-sensitive strings (RFC 7405)",
      "ja": ";;;キーワード、大文字と小文字を区別した文字列の構文を使用して（RFC 7405）"
    },
    {
      "indent": 3,
      "text": ";; statement keywords action-keyword = %s\"action\" anydata-keyword = %s\"anydata\" anyxml-keyword = %s\"anyxml\" argument-keyword = %s\"argument\" augment-keyword = %s\"augment\" base-keyword = %s\"base\" belongs-to-keyword = %s\"belongs-to\" bit-keyword = %s\"bit\" case-keyword = %s\"case\" choice-keyword = %s\"choice\" config-keyword = %s\"config\" contact-keyword = %s\"contact\" container-keyword = %s\"container\" default-keyword = %s\"default\" description-keyword = %s\"description\" deviate-keyword = %s\"deviate\" deviation-keyword = %s\"deviation\" enum-keyword = %s\"enum\" error-app-tag-keyword = %s\"error-app-tag\" error-message-keyword = %s\"error-message\" extension-keyword = %s\"extension\" feature-keyword = %s\"feature\" fraction-digits-keyword = %s\"fraction-digits\" grouping-keyword = %s\"grouping\" identity-keyword = %s\"identity\" if-feature-keyword = %s\"if-feature\" import-keyword = %s\"import\" include-keyword = %s\"include\" input-keyword = %s\"input\" key-keyword = %s\"key\" leaf-keyword = %s\"leaf\" leaf-list-keyword = %s\"leaf-list\" length-keyword = %s\"length\" list-keyword = %s\"list\" mandatory-keyword = %s\"mandatory\" max-elements-keyword = %s\"max-elements\" min-elements-keyword = %s\"min-elements\" modifier-keyword = %s\"modifier\" module-keyword = %s\"module\" must-keyword = %s\"must\" namespace-keyword = %s\"namespace\" notification-keyword = %s\"notification\" ordered-by-keyword = %s\"ordered-by\" organization-keyword = %s\"organization\" output-keyword = %s\"output\" path-keyword = %s\"path\" pattern-keyword = %s\"pattern\" position-keyword = %s\"position\" prefix-keyword = %s\"prefix\" presence-keyword = %s\"presence\" range-keyword = %s\"range\" reference-keyword = %s\"reference\" refine-keyword = %s\"refine\" require-instance-keyword = %s\"require-instance\" revision-keyword = %s\"revision\" revision-date-keyword = %s\"revision-date\" rpc-keyword = %s\"rpc\" status-keyword = %s\"status\" submodule-keyword = %s\"submodule\" type-keyword = %s\"type\" typedef-keyword = %s\"typedef\" unique-keyword = %s\"unique\" units-keyword = %s\"units\" uses-keyword = %s\"uses\" value-keyword = %s\"value\" when-keyword = %s\"when\" yang-version-keyword = %s\"yang-version\" yin-element-keyword = %s\"yin-element\"",
      "ja": ";;文のキーワードアクション・キーワード=％sの「アクション」ANYDATAキーワード=％sの「ANYDATA」AnyXMLで、キーワード=％s「のAnyXMLで」引数キーワード=％s「の引数」増補キーワード=％sの「強化」ベース - キーワード=％S \"塩基\" 属するツーキーワード=％S \"に属するから\" ビットキーワード=％S \"ビット\" の場合、キーワード=％s \"の場合\" 選択キーワード=％S \"選択\" CONFIG-キーワード= ％S「設定」接触キーワード=％sの「接触」コンテナキーワード=％S「コンテナ」デフォルトキーワード=％sの「デフォルト」の説明キーワード=％S「説明」逸脱キーワードを=％S「逸脱」偏差キーワード=％sの「ずれ」列挙キーワード=％S「列挙」エラーアプリタグキーワード=％s「を誤りアプリタグ」エラーメッセージキーワード=％S「エラーメッセージ」EXTENSION- IF-機能キーワード=％sの \"拡張\" 機能、キーワード=％sの \"機能\" 小数桁キーワード=％s \"の端数桁\" グループ化、キーワード=％sの \"グループ化\" アイデンティティキーワード=％sの \"アイデンティティ\" -keyword =％s「の場合、機能」インポート・キーワード=％sの「輸入」などがキーワード=％S =入力キーワード=％sの「入力」キー、キーワード=％sの「キー」葉キーワード「が含まれます」 ％sの \"リーフ\" リーフリスト-キーワード=％s \"の葉-list」長キーワード=％sの \"長さ\" リストキーワード=％S \"リスト\" 必須のキーワード=％S \"必須\" MAX-要素キーワード=％s \"の最大要素\" MIN-要素キーワード=％ S \"MIN-要素\" という修飾キーワード=％S \"という修飾語\" モジュールキーワード=％sの \"モジュール\" しなければならないキーワード=％S \"必要\" 名前空間キーワード=％sの \"名前空間\" 通知キーワード=％s \"の通知\"順序付けバイキーワード=％S\" 順序付け-によって」組織キーワード=％S \"組織\" 出力キーワード=％S \"出力\" パスキーワード=％sの \"パス\" パターンキーワード=％S \"パターン\"位置キーワード=％S「位置」プレフィックスキーワード=％s「の接頭辞」プレゼンスキーワード=％S「プレゼンス」範囲キーワード=％s「の範囲」参照キーワード=％sの「参照」絞り込みキーワード=％ Sは「絞り込み」を必要とインスタンスキーワード=％S「を必要インスタンスを」リビジョンキーワード=％S「リビジョン」改訂日付、キーワード=％S「改訂日付」RPCキーワード=％S「RPC」ステータス - キーワード=％sの \"ステータス\" サブモジュールキーワード=％S \"サブモジュール\" タイプキーワード=％S \"タイプ\" typedefのキーワード=％S \"typedefの\" ユニークキーワード=％s \"のユニークな\" 単位キーワード=％sの」単位は」=％sのキーワードを使用しています値キーワード=％s「の値」キーワード=％S「」ヤン・バージョンキーワード=％S「ヤン・バージョン」陰元素キーワード=％S「陰要素を」「使用」"
    },
    {
      "indent": 3,
      "text": ";; other keywords",
      "ja": ";;他のキーワード"
    },
    {
      "indent": 3,
      "text": "add-keyword = %s\"add\" current-keyword = %s\"current\" delete-keyword = %s\"delete\" deprecated-keyword = %s\"deprecated\" false-keyword = %s\"false\" invert-match-keyword = %s\"invert-match\" max-keyword = %s\"max\" min-keyword = %s\"min\" not-supported-keyword = %s\"not-supported\" obsolete-keyword = %s\"obsolete\" replace-keyword = %s\"replace\" system-keyword = %s\"system\" true-keyword = %s\"true\" unbounded-keyword = %s\"unbounded\" user-keyword = %s\"user\" and-keyword = %s\"and\" or-keyword = %s\"or\" not-keyword = %s\"not\"",
      "ja": "追加キーワード=％sの「追加」現在、キーワード=％sの「現在」を削除、キーワード=％sの「削除」非推奨のキーワード=％sの「非推奨」偽キーワード=％sの「偽」反転一致キーワード=％S \"反転一致\" MAX-キーワード=％S \"MAX\" MIN-キーワード=％S \"MIN\"、サポートされていないキーワードは=％s \"は、サポートされていない\" 廃止キーワード=％S \"時代遅れ\" replace-キーワード=％sの \"置き換え\" システム-キーワード=％sの \"システム\" 真のキーワード=％sの \"真の\" 無限のキーワード=％sの \"無制限\" ユーザーのキーワード=％sの \"ユーザー\" と、キーワード=％sを」そして、」またはキーワード=％sの 『か』ではないキーワード=％s 『はありません』"
    },
    {
      "indent": 3,
      "text": "current-function-invocation = current-keyword *WSP \"(\" *WSP \")\"",
      "ja": "現在の機能-呼び出し=電流のキーワード*のWSP \"（\" * WSP \"）\""
    },
    {
      "indent": 3,
      "text": ";;; Basic Rules",
      "ja": ";;;基本的なルール"
    },
    {
      "indent": 3,
      "text": "prefix-arg-str = < a string that matches the rule > < prefix-arg >",
      "ja": "接頭引数-STR = <ルールにマッチした文字列> <接頭引数>"
    },
    {
      "indent": 3,
      "text": "prefix-arg = prefix",
      "ja": "接頭引数=接頭辞"
    },
    {
      "indent": 3,
      "text": "prefix = identifier",
      "ja": "接頭辞=識別子"
    },
    {
      "indent": 3,
      "text": "identifier-arg-str = < a string that matches the rule > < identifier-arg >",
      "ja": "識別子のarg-STR = <ルールに一致する文字列> <識別子、引数>"
    },
    {
      "indent": 3,
      "text": "identifier-arg = identifier",
      "ja": "ログイン-argを=ログイン"
    },
    {
      "indent": 3,
      "text": "identifier = (ALPHA / \"_\") *(ALPHA / DIGIT / \"_\" / \"-\" / \".\")",
      "ja": "識別子=（ALPHA / \"_\"）*（ALPHA / DIGIT / \"_\" / \" - \" / \"\"）"
    },
    {
      "indent": 3,
      "text": "identifier-ref-arg-str = < a string that matches the rule > < identifier-ref-arg >",
      "ja": "識別子-REF-のarg-STR = <ルールに一致する文字列> <識別子-REF-引数>"
    },
    {
      "indent": 3,
      "text": "identifier-ref-arg = identifier-ref",
      "ja": "識別子-REF-引数=識別子-REF"
    },
    {
      "indent": 3,
      "text": "identifier-ref = [prefix \":\"] identifier",
      "ja": "識別子-REF = [接頭辞 \"：\"]識別子"
    },
    {
      "indent": 3,
      "text": "string = < an unquoted string, as returned by > < the scanner, that matches the rule > < yang-string >",
      "ja": "ストリング= <によって返される文字列を引用符で囲まれていない、> <陽文字列> <ルール一致スキャナ、>を"
    },
    {
      "indent": 3,
      "text": "yang-string = *yang-char",
      "ja": "文字列= *-CHAR"
    },
    {
      "indent": 3,
      "text": ";; any Unicode or ISO/IEC 10646 character, including tab, carriage ;; return, and line feed but excluding the other C0 control ;; characters, the surrogate blocks, and the noncharacters yang-char = %x09 / %x0A / %x0D / %x20-D7FF / ; exclude surrogate blocks %xD800-DFFF %xE000-FDCF / ; exclude noncharacters %xFDD0-FDEF %xFDF0-FFFD / ; exclude noncharacters %xFFFE-FFFF %x10000-1FFFD / ; exclude noncharacters %x1FFFE-1FFFF %x20000-2FFFD / ; exclude noncharacters %x2FFFE-2FFFF %x30000-3FFFD / ; exclude noncharacters %x3FFFE-3FFFF %x40000-4FFFD / ; exclude noncharacters %x4FFFE-4FFFF %x50000-5FFFD / ; exclude noncharacters %x5FFFE-5FFFF %x60000-6FFFD / ; exclude noncharacters %x6FFFE-6FFFF %x70000-7FFFD / ; exclude noncharacters %x7FFFE-7FFFF %x80000-8FFFD / ; exclude noncharacters %x8FFFE-8FFFF %x90000-9FFFD / ; exclude noncharacters %x9FFFE-9FFFF %xA0000-AFFFD / ; exclude noncharacters %xAFFFE-AFFFF %xB0000-BFFFD / ; exclude noncharacters %xBFFFE-BFFFF %xC0000-CFFFD / ; exclude noncharacters %xCFFFE-CFFFF %xD0000-DFFFD / ; exclude noncharacters %xDFFFE-DFFFF %xE0000-EFFFD / ; exclude noncharacters %xEFFFE-EFFFF %xF0000-FFFFD / ; exclude noncharacters %xFFFFE-FFFFF %x100000-10FFFD ; exclude noncharacters %x10FFFE-10FFFF",
      "ja": ";;タブを含む任意のUnicodeまたはISO / IEC 10646文字、キャリッジ;;復帰、および改行が、他のC0制御を除く;;文字、サロゲートブロック、noncharacters陽-チャー=％X09 /％X0A /％x0D /％X20-D7FF /。サロゲートブロック％を除外xD800-DFFF％のxE000-FDCF /; noncharactersを除外％xFDD0-FDEF％のxFDF0-FFFD /; noncharactersを除外％xFFFE-FFFF％x10000-1FFFD /。 noncharactersを除外する％のx1FFFE-1FFFF％x20000-2FFFD /。 noncharactersを除外する％のx2FFFE-2FFFF％x30000-3FFFD /。 noncharactersを除外する％のx3FFFE-3FFFF％x40000-4FFFD /。 noncharactersを除外する％のx4FFFE-4FFFF％x50000-5FFFD /。 noncharactersを除外する％のx5FFFE-5FFFF％x60000-6FFFD /。 noncharactersを除外する％のx6FFFE-6FFFF％x70000-7FFFD /。 noncharactersを除外する％のx7FFFE-7FFFF％x80000-8FFFD /。 noncharactersを除外する％のx8FFFE-8FFFF％x90000-9FFFD /。 noncharactersを除外する％のx9FFFE-9FFFF％xA0000-AFFFD /; noncharactersを除外％xAFFFE-AFFFF％xB0000-BFFFD /; noncharactersを除外％xBFFFE-BFFFF％のxC0000-CFFFD /; noncharactersを除外する％のxCFFFE-CFFFF％xD0000-DFFFD /; noncharactersを除外する％のxDFFFE-DFFFF％xE0000-EFFFD /; noncharacters％xEFFFE-EFFFF％xF0000-FFFFDを/除外する。 noncharactersを除外％xFFFFE-FFFFF％x100000-10FFFD。 noncharacters％のx10FFFE-10FFFFを除外"
    },
    {
      "indent": 3,
      "text": "integer-value = (\"-\" non-negative-integer-value) / non-negative-integer-value",
      "ja": "整数値=（「 - 」非負整数値）/非負整数値"
    },
    {
      "indent": 3,
      "text": "non-negative-integer-value = \"0\" / positive-integer-value",
      "ja": "非負整数値=「0」/正の整数値"
    },
    {
      "indent": 3,
      "text": "positive-integer-value = (non-zero-digit *DIGIT)",
      "ja": "正の整数値=（非ゼロ桁*のDIGIT）"
    },
    {
      "indent": 3,
      "text": "zero-integer-value = 1*DIGIT",
      "ja": "ゼロ整数値= 1 * DIGIT"
    },
    {
      "indent": 3,
      "text": "stmtend = optsep (\";\" / \"{\" stmtsep \"}\") stmtsep",
      "ja": "stmtend = optsep（ \";\" / \"{\" stmtsep \"}\"）stmtsep"
    },
    {
      "indent": 3,
      "text": "sep = 1*(WSP / line-break) ; unconditional separator",
      "ja": "9月= 1 *（WSP /改行）;無条件のセパレータ"
    },
    {
      "indent": 3,
      "text": "optsep = *(WSP / line-break)",
      "ja": "optsep = *（WSP /改行）"
    },
    {
      "indent": 3,
      "text": "stmtsep = *(WSP / line-break / unknown-statement)",
      "ja": "stmtsep = *（WSP /改行/未知の文）"
    },
    {
      "indent": 3,
      "text": "line-break = CRLF / LF",
      "ja": "改行= CRLF / LF"
    },
    {
      "indent": 3,
      "text": "non-zero-digit = %x31-39",
      "ja": "非ゼロ桁=％x31-39"
    },
    {
      "indent": 3,
      "text": "decimal-value = integer-value (\".\" zero-integer-value)",
      "ja": "進値=整数値（「」ゼロ整数値）"
    },
    {
      "indent": 3,
      "text": "SQUOTE = %x27 ; single quote",
      "ja": "SQUOTE =％X27。単一引用符"
    },
    {
      "indent": 3,
      "text": ";;; core rules from RFC 5234",
      "ja": ";;; RFC 5234からコアルール"
    },
    {
      "indent": 3,
      "text": "ALPHA = %x41-5A / %x61-7A ; A-Z / a-z",
      "ja": "ALPHA =％x41-5A /％x61-7A。 -Z / Z-"
    },
    {
      "indent": 3,
      "text": "CR = %x0D ; carriage return",
      "ja": "CR =％x0D。キャリッジリターン"
    },
    {
      "indent": 3,
      "text": "CRLF = CR LF ; Internet standard newline",
      "ja": "CRLF = CR LF。インターネット標準の改行"
    },
    {
      "indent": 3,
      "text": "DIGIT = %x30-39 ; 0-9",
      "ja": "DIGIT =％x30-39。 0-9"
    },
    {
      "indent": 3,
      "text": "DQUOTE = %x22 ; double quote",
      "ja": "DQUOTE =％X22。二重引用符"
    },
    {
      "indent": 3,
      "text": "HTAB = %x09 ; horizontal tab",
      "ja": "HTAB =％X09。水平タブ"
    },
    {
      "indent": 3,
      "text": "LF = %x0A ; line feed",
      "ja": "LF =％X0A。改行"
    },
    {
      "indent": 3,
      "text": "SP = %x20 ; space",
      "ja": "SP =％のX20。スペース"
    },
    {
      "indent": 3,
      "text": "WSP = SP / HTAB ; whitespace",
      "ja": "WSP = SP / HTAB;空白"
    },
    {
      "indent": 3,
      "text": "<CODE ENDS>",
      "ja": "<CODEはENDS>"
    },
    {
      "indent": 0,
      "text": "15. NETCONF Error Responses for YANG-Related Errors",
      "section_title": true,
      "ja": "YANG関連のエラーのために15 NETCONFのエラー応答"
    },
    {
      "indent": 3,
      "text": "A number of NETCONF error responses are defined for error cases related to the data model handling. If the relevant YANG statement has an \"error-app-tag\" substatement, that overrides the default value specified below.",
      "ja": "NETCONFエラー応答の数は、データモデル取り扱いに関連するエラーの場合のために定義されています。関連YANG文は以下の指定されたデフォルト値を上書きします「というエラー・アプリ・タグ」サブステートメントを、持っている場合。"
    },
    {
      "indent": 0,
      "text": "15.1. Error Message for Data That Violates a \"unique\" Statement",
      "section_title": true,
      "ja": "15.1.  「ユニークな」声明を違反するデータのためのエラー・メッセージ"
    },
    {
      "indent": 3,
      "text": "If a NETCONF operation would result in configuration data where a \"unique\" constraint is invalidated, the following error MUST be returned:",
      "ja": "NETCONF操作は「ユニーク」制約が無効化された構成データにつながる場合は、次のエラーが返さなければなりません："
    },
    {
      "indent": 5,
      "text": "error-tag: operation-failed error-app-tag: data-not-unique error-info: <non-unique>: Contains an instance identifier that points to a leaf that invalidates the \"unique\" constraint. This element is present once for each non-unique leaf.",
      "ja": "エラータグ：操作して失敗したエラーアプリタグ：データ固有ではないエラー情報：<非ユニーク>：「ユニークな」制約を無効に葉を指すインスタンス識別子が含まれています。この要素は、各非ユニークな葉に一度存在しています。"
    },
    {
      "indent": 21,
      "text": "The <non-unique> element is in the YANG\nnamespace (\"urn:ietf:params:xml:ns:yang:1\").",
      "raw": true
    },
    {
      "indent": 0,
      "text": "15.2. Error Message for Data That Violates a \"max-elements\" Statement",
      "section_title": true,
      "ja": "15.2.  「MAX-要素」声明を違反するデータのためのエラー・メッセージ"
    },
    {
      "indent": 3,
      "text": "If a NETCONF operation would result in configuration data where a list or a leaf-list would have too many entries, the following error MUST be returned:",
      "ja": "NETCONF操作がリストまたはリーフリストは、あまりにも多くのエントリを持つことになり、構成データにつながる場合は、次のエラーが返さなければなりません："
    },
    {
      "indent": 5,
      "text": "error-tag: operation-failed error-app-tag: too-many-elements",
      "ja": "エラータグ：操作に失敗したエラーアプリタグ：あまりにも多くの要素"
    },
    {
      "indent": 3,
      "text": "This error is returned once, with the error-path identifying the list node, even if there is more than one extra child present.",
      "ja": "このエラーは、複数の余分な子が存在していても、リストのノードを特定するエラーパスで、一度返されます。"
    },
    {
      "indent": 0,
      "text": "15.3. Error Message for Data That Violates a \"min-elements\" Statement",
      "section_title": true,
      "ja": "15.3.  「最小要素」声明を違反するデータのためのエラー・メッセージ"
    },
    {
      "indent": 3,
      "text": "If a NETCONF operation would result in configuration data where a list or a leaf-list would have too few entries, the following error MUST be returned:",
      "ja": "NETCONF操作がリストまたはリーフ・リストが少なすぎるのエントリを持つことになり、構成データにつながる場合は、次のエラーが返さなければなりません："
    },
    {
      "indent": 5,
      "text": "error-tag: operation-failed error-app-tag: too-few-elements",
      "ja": "エラータグ：操作に失敗したエラーアプリタグ：あまりにもいくつかの要素"
    },
    {
      "indent": 3,
      "text": "This error is returned once, with the error-path identifying the list node, even if there is more than one child missing.",
      "ja": "このエラーは、不足している複数の子があっても、リストのノードを特定するエラーパスで、一度返されます。"
    },
    {
      "indent": 0,
      "text": "15.4. Error Message for Data That Violates a \"must\" Statement",
      "section_title": true,
      "ja": "15.4.  「しなければならない」声明を違反するデータのためのエラー・メッセージ"
    },
    {
      "indent": 3,
      "text": "If a NETCONF operation would result in configuration data where the restrictions imposed by a \"must\" statement are violated, the following error MUST be returned, unless a specific \"error-app-tag\" substatement is present for the \"must\" statement.",
      "ja": "NETCONF操作は「しなければならない」文によって課される制限に違反しているコンフィギュレーション・データにつながる場合は、特定の「エラー・アプリ - タグ」サブステートメントは「しなければならない」文の存在しない限り、次のエラーが返されなければなりません。"
    },
    {
      "indent": 5,
      "text": "error-tag: operation-failed error-app-tag: must-violation",
      "ja": "エラータグ：操作に失敗したエラーアプリタグ：必要があり、違反"
    },
    {
      "indent": 0,
      "text": "15.5. Error Message for Data That Violates a \"require-instance\" Statement",
      "ja": "15.5.  「必要-インスタンス」声明を違反するデータのためのエラー・メッセージ"
    },
    {
      "indent": 3,
      "text": "If a NETCONF operation would result in configuration data where a leaf of type \"instance-identifier\" or \"leafref\" marked with require-instance \"true\" refers to an instance that does not exist, the following error MUST be returned:",
      "ja": "NETCONF操作が付いたタイプ「インスタンス識別子」または「leafref」の葉が「真」が存在しないインスタンスを参照するインスタンスが必要とするコンフィギュレーションデータをもたらす場合には、次のエラーが返されなければなりません。"
    },
    {
      "indent": 5,
      "text": "error-tag: data-missing error-app-tag: instance-required error-path: Path to the instance-identifier or leafref leaf.",
      "ja": "エラータグ：データ欠落誤りアプリタグ：インスタンスに必要なエラーパス：インスタンス識別子またはleafref葉へのパス。"
    },
    {
      "indent": 0,
      "text": "15.6. Error Message for Data That Violates a Mandatory \"choice\" Statement",
      "ja": "15.6. 必須の「選択」ステートメントを違反するデータのためのエラー・メッセージ"
    },
    {
      "indent": 3,
      "text": "If a NETCONF operation would result in configuration data where no nodes exists in a mandatory choice, the following error MUST be returned:",
      "ja": "NETCONF操作にはノードが必須選択肢に存在しない構成データにつながる場合は、次のエラーが返さなければなりません："
    },
    {
      "indent": 5,
      "text": "error-tag: data-missing error-app-tag: missing-choice error-path: Path to the element with the missing choice. error-info: <missing-choice>: Contains the name of the missing mandatory choice.",
      "ja": "エラータグ：データ欠落誤りアプリタグ：行方不明の選択肢エラーパス：行方不明の選択肢を持つ要素へのパス。エラー情報：<欠落している-選択>：欠落している必須の選択肢の名前が含まれています。"
    },
    {
      "indent": 21,
      "text": "The <missing-choice> element is in the YANG\nnamespace (\"urn:ietf:params:xml:ns:yang:1\").",
      "raw": true
    },
    {
      "indent": 0,
      "text": "15.7. Error Message for the \"insert\" Operation",
      "section_title": true,
      "ja": "15.7.  「挿入」オペレーションのためのエラー・メッセージ"
    },
    {
      "indent": 3,
      "text": "If the \"insert\" and \"key\" or \"value\" attributes are used in an <edit-config> for a list or leaf-list node and the \"key\" or \"value\" refers to an instance that does not exist, the following error MUST be returned:",
      "ja": "「挿入」と「キー」または「値」属性がリストまたはリーフリストノードのための<編集-config>の中で使用されている場合と、「キー」または「値が」存在しないインスタンスを参照し、次のエラーが返さなければなりません："
    },
    {
      "indent": 5,
      "text": "error-tag: bad-attribute error-app-tag: missing-instance",
      "ja": "エラータグ：悪い属性エラーアプリタグ：欠落しているインスタンス"
    },
    {
      "indent": 0,
      "text": "16. IANA Considerations",
      "section_title": true,
      "ja": "16. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document registers one capability identifier URN from the \"Network Configuration Protocol (NETCONF) Capability URNs\" registry:",
      "ja": "この文書では、「ネットワーク構成プロトコル（NETCONF）能力壺」レジストリから1つの能力識別子URNを登録します。"
    },
    {
      "indent": 5,
      "text": "Index           Capability Identifier\n-------------   ---------------------------------------------------\n:yang-library   urn:ietf:params:netconf:capability:yang-library:1.0",
      "raw": true
    },
    {
      "indent": 0,
      "text": "17. Security Considerations",
      "section_title": true,
      "ja": "17.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document defines a language with which to write and read descriptions of management information. The language itself has no security impact on the Internet.",
      "ja": "この文書では、書き込みと管理情報の記述を読むことで言語を定義します。言語自体は、インターネット上ではセキュリティへの影響はありません。"
    },
    {
      "indent": 3,
      "text": "The same considerations are relevant as those for the base NETCONF protocol (see Section 9 in [RFC6241]).",
      "ja": "同じ考察は、ベースNETCONFプロトコルのものと関連している（[RFC6241]セクション9を参照）。"
    },
    {
      "indent": 3,
      "text": "Data modeled in YANG might contain sensitive information. RPCs or notifications defined in YANG might transfer sensitive information.",
      "ja": "YANGでモデル化されたデータは、機密情報が含まれている場合があります。 YANGで定義されたRPCまたは通知は、機密情報を転送することがあります。"
    },
    {
      "indent": 3,
      "text": "Security issues are related to the usage of data modeled in YANG. Such issues shall be dealt with in documents describing the data models and documents about the interfaces used to manipulate the data, e.g., the NETCONF documents.",
      "ja": "セキュリティの問題は、YANGでモデル化されたデータの利用に関連しています。そのような問題は、データ、例えば、NETCONF文書を操作するために使用されるインタフェースに関するデータ・モデルと文書を記述する文書で対処しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Data modeled in YANG is dependent upon:",
      "ja": "YANGでモデル化されたデータは、依存しています："
    },
    {
      "indent": 3,
      "text": "o the security of the transmission infrastructure used to send sensitive information.",
      "ja": "機密情報を送信するために使用される伝送インフラストラクチャのセキュリティO。"
    },
    {
      "indent": 3,
      "text": "o the security of applications that store or release such sensitive information.",
      "ja": "保存したり、そのような機密情報を公開するアプリケーションのセキュリティO。"
    },
    {
      "indent": 3,
      "text": "o adequate authentication and access control mechanisms to restrict the usage of sensitive data.",
      "ja": "O十分な認証およびアクセス制御メカニズムは、機密データの使用を制限します。"
    },
    {
      "indent": 3,
      "text": "YANG parsers need to be robust with respect to malformed documents. Reading malformed documents from unknown or untrusted sources could result in an attacker gaining the privileges of the user running the YANG parser. In an extreme situation, the entire machine could be compromised.",
      "ja": "YANGパーサは、不正な形式の文書に関しては堅牢にする必要があります。未知あるいは信頼できないソースからの不正な形式の文書を読むことYANGパーサを実行するユーザの権限を獲得し、攻撃者につながる可能性があります。極端な状況では、マシン全体が損なわれる可能性があります。"
    },
    {
      "indent": 0,
      "text": "18. References",
      "section_title": true,
      "ja": "18.参考文献"
    },
    {
      "indent": 0,
      "text": "18.1. Normative References",
      "section_title": true,
      "ja": "18.1. 引用規格"
    },
    {
      "indent": 3,
      "text": "[ISO.10646] International Organization for Standardization, \"Information Technology - Universal Multiple-Octet Coded Character Set (UCS)\", ISO Standard 10646:2014, 2014.",
      "ja": "[ISO.10646]国際標準化機構、 \"情報技術 - ユニバーサルマルチオクテット符号化文字セット（UCS）\"、ISO規格10646：2014、2014。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<http://www.rfc-editor.org/info/ RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC3629] Yergeau, F., \"UTF-8, a transformation format of ISO 10646\", STD 63, RFC 3629, DOI 10.17487/RFC3629, November 2003, <http://www.rfc-editor.org/info/rfc3629>.",
      "ja": "[RFC3629] Yergeau、F.、 \"UTF-8、ISO 10646の変換フォーマット\"、STD 63、RFC 3629、DOI 10.17487 / RFC3629、2003年11月、<http://www.rfc-editor.org/info/ RFC3629>。"
    },
    {
      "indent": 3,
      "text": "[RFC3986] Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform Resource Identifier (URI): Generic Syntax\", STD 66, RFC 3986, DOI 10.17487/RFC3986, January 2005, <http://www.rfc-editor.org/info/rfc3986>.",
      "ja": "[RFC3986]バーナーズ - リー、T.、フィールディング、R.、およびL. Masinter、 \"ユニフォームリソース識別子（URI）：汎用構文\"、STD 66、RFC 3986、DOI 10.17487 / RFC3986、2005年1月<HTTP：/ /www.rfc-editor.org/info/rfc3986>。"
    },
    {
      "indent": 3,
      "text": "[RFC4648] Josefsson, S., \"The Base16, Base32, and Base64 Data Encodings\", RFC 4648, DOI 10.17487/RFC4648, October 2006, <http://www.rfc-editor.org/info/rfc4648>.",
      "ja": "[RFC4648] Josefsson氏、S.、 \"Base16、Base32、およびBase64でデータエンコーディング\"、RFC 4648、DOI 10.17487 / RFC4648、2006年10月、<http://www.rfc-editor.org/info/rfc4648>。"
    },
    {
      "indent": 3,
      "text": "[RFC5234] Crocker, D., Ed., and P. Overell, \"Augmented BNF for Syntax Specifications: ABNF\", STD 68, RFC 5234, DOI 10.17487/RFC5234, January 2008, <http://www.rfc-editor.org/info/rfc5234>.",
      "ja": "\"構文仕様のための増大しているBNF：ABNF\" [RFC5234]クロッカー、D.、エド、およびP. Overell、。、STD 68、RFC 5234、DOI 10.17487 / RFC5234、2008年1月、<のhttp：//www.rfc-editor .ORG /情報/ RFC5234>。"
    },
    {
      "indent": 3,
      "text": "[RFC5277] Chisholm, S. and H. Trevino, \"NETCONF Event Notifications\", RFC 5277, DOI 10.17487/RFC5277, July 2008, <http://www.rfc-editor.org/info/rfc5277>.",
      "ja": "[RFC5277]チザム、S.およびH.トレビノ、 \"NETCONFイベント通知\"、RFC 5277、DOI 10.17487 / RFC5277、2008年7月、<http://www.rfc-editor.org/info/rfc5277>。"
    },
    {
      "indent": 3,
      "text": "[RFC6241] Enns, R., Ed., Bjorklund, M., Ed., Schoenwaelder, J., Ed., and A. Bierman, Ed., \"Network Configuration Protocol (NETCONF)\", RFC 6241, DOI 10.17487/RFC6241, June 2011, <http://www.rfc-editor.org/info/rfc6241>.",
      "ja": "[RFC6241]エンス、R.、編、Bjorklund、M.、編、Schoenwaelder、J.、編、及びA. Bierman、編、 \"ネットワーク構成プロトコル（NETCONF）\"、RFC 6241、DOI 10.17487 / RFC6241、2011年6月、<http://www.rfc-editor.org/info/rfc6241>。"
    },
    {
      "indent": 3,
      "text": "[RFC7405] Kyzivat, P., \"Case-Sensitive String Support in ABNF\", RFC 7405, DOI 10.17487/RFC7405, December 2014, <http://www.rfc-editor.org/info/rfc7405>.",
      "ja": "[RFC7405] Kyzivat、P.、 \"ABNFで、大文字と小文字を区別する文字列のサポート\"、RFC 7405、DOI 10.17487 / RFC7405、2014年12月、<http://www.rfc-editor.org/info/rfc7405>。"
    },
    {
      "indent": 3,
      "text": "[RFC7895] Bierman, A., Bjorklund, M., and K. Watsen, \"YANG Module Library\", RFC 7895, DOI 10.17487/RFC7895, June 2016, <http://www.rfc-editor.org/info/rfc7895>.",
      "ja": "[RFC7895] Bierman、A.、Bjorklund、M.、およびK. Watsen、 \"YANGモジュールライブラリ\"、RFC 7895、DOI 10.17487 / RFC7895、2016年6月、<http://www.rfc-editor.org/info/ rfc7895>。"
    },
    {
      "indent": 3,
      "text": "[XML] Bray, T., Paoli, J., Sperberg-McQueen, C., Maler, E., and F. Yergeau, \"Extensible Markup Language (XML) 1.0 (Fifth Edition)\", W3C Recommendation REC-xml-20081126, November 2008, <https://www.w3.org/TR/2008/REC-xml-20081126/>.",
      "ja": "[XML]ブレイ、T.、パオリ、J.、Sperberg-マックィーン、C.、MALER、E.、およびF. Yergeau、 \"拡張マークアップ言語（XML）1.0（第5版）\"、W3C勧告REC-XML- 20081126、2008年11月、<https://www.w3.org/TR/2008/REC-xml-20081126/>。"
    },
    {
      "indent": 3,
      "text": "[XML-NAMES] Bray, T., Hollander, D., Layman, A., Tobin, R., and H. Thompson, \"Namespaces in XML 1.0 (Third Edition)\", World Wide Web Consortium Recommendation REC-xml-names-20091208, December 2009, <http://www.w3.org/TR/2009/REC-xml-names-20091208>.",
      "ja": "[XML-NAMES]ブレイ、T.、オランダ、D.、素人、A.、トービン、R.、およびH.トンプソン、 \"XML 1.0での名前空間（第3版）\"、ワールドワイドウェブコンソーシアム勧告REC-XML-名前-20091208、2009年12月、<http://www.w3.org/TR/2009/REC-xml-names-20091208>。"
    },
    {
      "indent": 3,
      "text": "[XPATH] Clark, J. and S. DeRose, \"XML Path Language (XPath) Version 1.0\", World Wide Web Consortium Recommendation REC-xpath-19991116, November 1999, <http://www.w3.org/TR/1999/REC-xpath-19991116>.",
      "ja": "[XPATH]クラーク、J.とS. DeRose、 \"XMLパス言語（XPath）バージョン1.0\"、World Wide Web Consortium（W3C）の勧告REC-のxpath-19991116、1999年11月、<http://www.w3.org/TR/ 1999 / REC-のxpath-19991116>。"
    },
    {
      "indent": 3,
      "text": "[XSD-TYPES] Biron, P. and A. Malhotra, \"XML Schema Part 2: Datatypes Second Edition\", World Wide Web Consortium Recommendation REC-xmlschema-2-20041028, October 2004, <http://www.w3.org/TR/2004/REC-xmlschema-2-20041028>.",
      "ja": "[XSD-TYPES]ビロン、P.およびA.マルホトラ、 \"XMLスキーマパート2：データ型第二版\"、ワールドワイドウェブコンソーシアム勧告REC-XMLSCHEMA-2から20041028、2004年10月、<のhttp：//www.w3。 ORG / TR / 2004 / REC-XMLSCHEMA-2から20041028>。"
    },
    {
      "indent": 0,
      "text": "18.2. Informative References",
      "section_title": true,
      "ja": "18.2. 参考文献"
    },
    {
      "indent": 3,
      "text": "[CoMI] van der Stok, P. and A. Bierman, \"CoAP Management Interface\", Work in Progress, draft-vanderstok-core-comi-09, March 2016.",
      "ja": "[COMI]ファンデSTOK、P.およびA. Biermanを、 \"CoAP管理インターフェース\" が進行中で働いて、ドラフトvanderstokコア-COMI-09、2016年3月。"
    },
    {
      "indent": 3,
      "text": "[IEEE754-2008] IEEE, \"IEEE Standard for Floating-Point Arithmetic\", IEEE 754-2008, DOI 10.1109/IEEESTD.2008.4610935, 2008, <http://standards.ieee.org/findstds/ standard/754-2008.html>.",
      "ja": "[IEEE754-2008] IEEE、 \"浮動小数点演算のためのIEEE規格\"、IEEE 754-2008、DOI 10.1109 / IEEESTD.2008.4610935、2008年、<http://standards.ieee.org/findstds/標準/ 754-2008。 HTML>。"
    },
    {
      "indent": 3,
      "text": "[RESTCONF] Bierman, A., Bjorklund, M., and K. Watsen, \"RESTCONF Protocol\", Work in Progress, draft-ietf-netconf-restconf-16, August 2016.",
      "ja": "【RESTCONF] Bierman、A.、Bjorklund、M.、およびK. Watsen、 \"RESTCONFプロトコル\"、ProgressのWork、ドラフトIETF-NETCONF-restconf-16、2016年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC2578] McCloghrie, K., Ed., Perkins, D., Ed., and J. Schoenwaelder, Ed., \"Structure of Management Information Version 2 (SMIv2)\", STD 58, RFC 2578, DOI 10.17487/RFC2578, April 1999, <http://www.rfc-editor.org/info/rfc2578>.",
      "ja": "[RFC2578] McCloghrie、K.、エド。、パーキンス、D.、編、及びJ. Schoenwaelder、エド。DOI 10.17487 / RFC2578、STD 58、RFC 2578、 \"管理情報バージョン2（SMIv2）の構造\"、 1999年4月、<http://www.rfc-editor.org/info/rfc2578>。"
    },
    {
      "indent": 3,
      "text": "[RFC2579] McCloghrie, K., Ed., Perkins, D., Ed., and J. Schoenwaelder, Ed., \"Textual Conventions for SMIv2\", STD 58, RFC 2579, DOI 10.17487/RFC2579, April 1999, <http://www.rfc-editor.org/info/rfc2579>.",
      "ja": "[RFC2579] McCloghrie、K.、エド。、パーキンス、D.、編、及びJ. Schoenwaelder、エド。、 \"SMIv2のためのテキストの表記法\"、STD 58、RFC 2579、DOI 10.17487 / RFC2579、1999年4月、<HTTP ：//www.rfc-editor.org/info/rfc2579>。"
    },
    {
      "indent": 3,
      "text": "[RFC3780] Strauss, F. and J. Schoenwaelder, \"SMIng - Next Generation Structure of Management Information\", RFC 3780, DOI 10.17487/RFC3780, May 2004, <http://www.rfc-editor.org/info/rfc3780>.",
      "ja": "[RFC3780]シュトラウス、F.およびJ. Schoenwaelder、 \"SMIng  - 次の世代管理情報の構造\"、RFC 3780、DOI 10.17487 / RFC3780、2004年5月、<http://www.rfc-editor.org/info/rfc3780 >。"
    },
    {
      "indent": 3,
      "text": "[RFC4844] Daigle, L., Ed., and Internet Architecture Board, \"The RFC Series and RFC Editor\", RFC 4844, DOI 10.17487/RFC4844, July 2007, <http://www.rfc-editor.org/info/rfc4844>.",
      "ja": "[RFC4844] Daigle氏、L.、エド。、およびインターネットアーキテクチャ委員会、 \"RFCシリーズとRFCエディタ\"、RFC 4844、DOI 10.17487 / RFC4844、2007年7月、<http://www.rfc-editor.org/info / rfc4844>。"
    },
    {
      "indent": 3,
      "text": "[RFC6020] Bjorklund, M., Ed., \"YANG - A Data Modeling Language for the Network Configuration Protocol (NETCONF)\", RFC 6020, DOI 10.17487/RFC6020, October 2010, <http://www.rfc-editor.org/info/rfc6020>.",
      "ja": "[RFC6020] Bjorklund、M.、エド、 \"YANG  - ネットワーク構成プロトコルのためのデータモデリング言語（NETCONF）\"、RFC 6020、DOI 10.17487 / RFC6020、2010年10月、<のhttp：。//www.rfc-editor。組織/情報/ rfc6020>。"
    },
    {
      "indent": 3,
      "text": "[RFC6643] Schoenwaelder, J., \"Translation of Structure of Management Information Version 2 (SMIv2) MIB Modules to YANG Modules\", RFC 6643, DOI 10.17487/RFC6643, July 2012, <http://www.rfc-editor.org/info/rfc6643>.",
      "ja": "[RFC6643] Schoenwaelder、J.、RFC 6643 \"YANGモジュールに経営情報バージョン2（SMIv2）MIBモジュールの構造の翻訳\"、DOI 10.17487 / RFC6643、2012年7月、<http://www.rfc-editor.org /情報/ rfc6643>。"
    },
    {
      "indent": 3,
      "text": "[RFC6991] Schoenwaelder, J., Ed., \"Common YANG Data Types\", RFC 6991, DOI 10.17487/RFC6991, July 2013, <http://www.rfc-editor.org/info/rfc6991>.",
      "ja": "[RFC6991] Schoenwaelder、J.、エド。、 \"共通YANGデータ型\"、RFC 6991、DOI 10.17487 / RFC6991、2013年7月、<http://www.rfc-editor.org/info/rfc6991>。"
    },
    {
      "indent": 3,
      "text": "[RFC7951] Lhotka, L., \"JSON Encoding of Data Modeled with YANG\", RFC 7951, DOI 10.17487/RFC7951, August 2016, <http://www.rfc-editor.org/info/rfc7951>.",
      "ja": "[RFC7951] Lhotka、L.、RFC 7951、DOI 10.17487 / RFC7951、2016年8月、 \"YANGによるデータモデル化のJSONエンコーディング\" <http://www.rfc-editor.org/info/rfc7951>。"
    },
    {
      "indent": 3,
      "text": "[XPATH2.0] Berglund, A., Boag, S., Chamberlin, D., Fernandez, M., Kay, M., Robie, J., and J. Simeon, \"XML Path Language (XPath) 2.0 (Second Edition)\", World Wide Web Consortium Recommendation REC-xpath20-20101214, December 2010, <http://www.w3.org/TR/2010/REC-xpath20-20101214>.",
      "ja": "【XPATH2.0]ベルグルンド、A.、ボーグ、S.、チェン、D.、フェルナンデス、M.、ケイ、M.、Robie、J.、およびJ.シメオン、「XMLパス言語（XPath）2.0（第版）」、World Wide Web Consortium（W3C）の勧告REC-xpath20-20101214、2010年12月、<http://www.w3.org/TR/2010/REC-xpath20-20101214>。"
    },
    {
      "indent": 3,
      "text": "[XSLT] Clark, J., \"XSL Transformations (XSLT) Version 1.0\", World Wide Web Consortium Recommendation REC-xslt-19991116, November 1999, <http://www.w3.org/TR/1999/REC-xslt-19991116>.",
      "ja": "[XSLT]クラーク、J.、 \"XSL変換（XSLT）バージョン1.0\"、World Wide Web Consortium（W3C）の勧告REC-XSLT-19991116、1999年11月、<http://www.w3.org/TR/1999/REC-xslt -19991116>。"
    },
    {
      "indent": 3,
      "text": "[YANG-Guidelines] Bierman, A., \"Guidelines for Authors and Reviewers of YANG Data Model Documents\", Work in Progress, draft-ietf-netmod-rfc6087bis-07, July 2016.",
      "ja": "[YANG-ガイドライン] Bierman、A.、 \"YANGデータモデルドキュメントの著者と査読のためのガイドライン\"、進捗状況、ドラフト-IETF-netmod-rfc6087bis-07、2016年7月での作業。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "The editor wishes to thank the following individuals, who all provided helpful comments on various draft versions of this document: Mehmet Ersue, Washam Fan, Joel Halpern, Per Hedeland, Leif Johansson, Ladislav Lhotka, Lionel Morand, Gerhard Muenz, Peyman Owladi, Tom Petch, Randy Presuhn, David Reid, Jernej Tuljak, Kent Watsen, Bert Wijnen, Robert Wilton, and Dale Worley.",
      "ja": "メフメットErsue、Washamファン、ジョエル・ハルパーン、パーHedeland、レイフ・ヨハンソン、ラディスラフLhotka、ライオネル・モラン、ゲルハルトMuenz、Peyman Owladi、トム：エディタはすべて、この文書の様々なドラフトバージョンで有益なコメントを提供する以下の個人を、感謝したいですペッチ、ランディPresuhn、デイビット・リード、Jernej Tuljak、ケントWatsen、バートWijnen、ロバート・ウィルトン、そしてデールウォーリー。"
    },
    {
      "indent": 0,
      "text": "Contributors",
      "ja": "協力者"
    },
    {
      "indent": 3,
      "text": "The following people all contributed significantly to the initial YANG document:",
      "ja": "次の人はすべて、初期YANGの文書に大きく貢献しました。"
    },
    {
      "indent": 4,
      "text": "- Andy Bierman (YumaWorks) - Balazs Lengyel (Ericsson) - David Partain (Ericsson) - Juergen Schoenwaelder (Jacobs University Bremen) - Phil Shafer (Juniper Networks)",
      "ja": " - アンディBierman（YumaWorks） - バラージュLengyel（エリクソン） - デヴィッド・パーテイン（エリクソン） - ユルゲンSchoenwaelder（ジェイコブス大学ブレーメン） - フィル・シェーファー（ジュニパーネットワークス）"
    },
    {
      "indent": 0,
      "text": "Author's Address",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Martin Bjorklund (editor) Tail-f Systems",
      "ja": "マーティンBjorklund（編集者）テール-Fシステム"
    },
    {
      "indent": 3,
      "text": "Email: mbj@tail-f.com",
      "ja": "メール：mbj@tail-f.com"
    }
  ]
}