{
  "title": {
    "text": "RFC 7469 - Public Key Pinning Extension for HTTP",
    "ja": "RFC 7469 - HTTPのための公開鍵ピンニング拡張"
  },
  "number": 7469,
  "created_at": "2019-11-02 15:12:15.992028+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                          C. Evans\nRequest for Comments: 7469                                     C. Palmer\nCategory: Standards Track                                      R. Sleevi\nISSN: 2070-1721                                             Google, Inc.\n                                                              April 2015",
      "raw": true
    },
    {
      "indent": 17,
      "text": "Public Key Pinning Extension for HTTP",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document defines a new HTTP header that allows web host operators to instruct user agents to remember (\"pin\") the hosts' cryptographic identities over a period of time. During that time, user agents (UAs) will require that the host presents a certificate chain including at least one Subject Public Key Info structure whose fingerprint matches one of the pinned fingerprints for that host. By effectively reducing the number of trusted authorities who can authenticate the domain during the lifetime of the pin, pinning may reduce the incidence of man-in-the-middle attacks due to compromised Certification Authorities.",
      "ja": "この文書では、Webホスト事業者が（「ピン」）一定期間のホストの暗号アイデンティティを覚えているユーザーエージェントに指示することを可能にする新しいHTTPヘッダーを定義します。その間、ユーザーエージェント（UAは）ホストは、指紋、そのホストのための固定指紋のいずれかに一致する少なくとも一つのサブジェクト公開鍵情報構造を含む証明書チェーンを提示する必要があります。効果的にピンの存続期間中にドメインを認証することができ、信頼できる機関の数を減らすことにより、ピン留めによる妥協認証局へのman-in-the-middle攻撃の発生率を減らすことができます。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 5741のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7469.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7469で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2015 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2015 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   4\n  1.1.  Requirements Language . . . . . . . . . . . . . . . . . .   5\n2.  Server and Client Behavior  . . . . . . . . . . . . . . . . .   5\n  2.1.  Response Header Field Syntax  . . . . . . . . . . . . . .   5\n    2.1.1.  The Pin Directive . . . . . . . . . . . . . . . . . .   6\n    2.1.2.  The max-age Directive . . . . . . . . . . . . . . . .   7\n    2.1.3.  The includeSubDomains Directive . . . . . . . . . . .   7\n    2.1.4.  The report-uri Directive  . . . . . . . . . . . . . .   7\n    2.1.5.  Examples  . . . . . . . . . . . . . . . . . . . . . .   8\n  2.2.  Server Processing Model . . . . . . . . . . . . . . . . .   9\n    2.2.1.  HTTP-over-Secure-Transport Request Type . . . . . . .   9\n    2.2.2.  HTTP Request Type . . . . . . . . . . . . . . . . . .   9\n  2.3.  User Agent Processing Model . . . . . . . . . . . . . . .  10\n    2.3.1.  Public-Key-Pins Response Header Field Processing  . .  10\n    2.3.2.  Interaction of Public-Key-Pins and Public-Key-Pins-\n            Report-Only . . . . . . . . . . . . . . . . . . . . .  11\n    2.3.3.  Noting a Pinned Host - Storage Model  . . . . . . . .  11\n    2.3.4.  HTTP-Equiv <Meta> Element Attribute . . . . . . . . .  13\n  2.4.  Semantics of Pins . . . . . . . . . . . . . . . . . . . .  13\n  2.5.  Noting Pins . . . . . . . . . . . . . . . . . . . . . . .  14\n  2.6.  Validating Pinned Connections . . . . . . . . . . . . . .  15\n  2.7.  Interactions with Preloaded Pin Lists . . . . . . . . . .  16\n  2.8.  Pinning Self-Signed End Entities  . . . . . . . . . . . .  16\n3.  Reporting Pin Validation Failure  . . . . . . . . . . . . . .  16\n4.  Security Considerations . . . . . . . . . . . . . . . . . . .  19\n  4.1.  Maximum max-age . . . . . . . . . . . . . . . . . . . . .  19\n  4.2.  Using includeSubDomains Safely  . . . . . . . . . . . . .  20\n  4.3.  Backup Pins . . . . . . . . . . . . . . . . . . . . . . .  21\n  4.4.  Interactions With Cookie Scoping  . . . . . . . . . . . .  21\n  4.5.  Hostile Pinning . . . . . . . . . . . . . . . . . . . . .  21\n5.  Privacy Considerations  . . . . . . . . . . . . . . . . . . .  22\n6.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  24\n7.  Usability Considerations  . . . . . . . . . . . . . . . . . .  24\n8.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  24\n  8.1.  Normative References  . . . . . . . . . . . . . . . . . .  24\n  8.2.  Informative References  . . . . . . . . . . . . . . . . .  26\nAppendix A.  Fingerprint Generation . . . . . . . . . . . . . . .  27\nAppendix B.  Deployment Guidance  . . . . . . . . . . . . . . . .  27\nAcknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  28\nAuthors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  28",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "This document defines a new HTTP header that enables UAs to determine which Subject Public Key Info (SPKI) structures will be present in a web host's certificate chain in future Transport Layer Security (TLS) [RFC5246] connections.",
      "ja": "このドキュメントは、サブジェクト公開鍵情報（SPKI）構造は、将来のトランスポート層セキュリティ（TLS）[RFC5246]の接続でWebホストの証明書チェーンに存在するかを決定するためのUAを可能にする新しいHTTPヘッダーを定義します。"
    },
    {
      "indent": 3,
      "text": "Deploying Public Key Pinning (PKP) safely will require operational and organizational maturity due to the risk that hosts may make themselves unavailable by pinning to a set of SPKIs that becomes invalid (see Section 4). With care, host operators can greatly reduce the risk of man-in-the-middle (MITM) attacks and other false-authentication problems for their users without incurring undue risk.",
      "ja": "展開公開キーピン留め（PKP）は安全に無効ななりSPKIsのセット（セクション4を参照）に固定することによって、それ自体が使用できないことがありホストするリスクに運用し、組織の成熟度を必要とします。注意して、ホスト事業者が大幅に過度のリスクを負うことなく、そのユーザーのためのman-in-the-middle（MITM）攻撃や他の偽の認証の問題のリスクを減らすことができます。"
    },
    {
      "indent": 3,
      "text": "PKP is meant to be used together with HTTP Strict Transport Security (HSTS) [RFC6797], but it is possible to pin keys without requiring HSTS.",
      "ja": "PKPはHTTP厳格なトランスポート・セキュリティ（HSTS）[RFC6797]と一緒に使用されることを意味するが、HSTSを必要とせずに、キーを固定することが可能です。"
    },
    {
      "indent": 3,
      "text": "A Pin is a relationship between a hostname and a cryptographic identity (in this document, one or more of the public keys in a chain of X.509 certificates). Pin Validation is the process a UA performs to ensure that a host is in fact authenticated with its previously established Pin.",
      "ja": "ピンは、ホスト名と（このドキュメントでは、X.509証明書のチェーンにおける公開鍵の一つ以上）の暗号アイデンティティとの関係です。ピンの検証は、UAは、ホストが実際にその以前に確立されたピンで認証されていることを確実にするために実行するプロセスです。"
    },
    {
      "indent": 3,
      "text": "Key pinning is a trust-on-first-use (TOFU) mechanism. The first time a UA connects to a host, it lacks the information necessary to perform Pin Validation; UAs can only apply their normal cryptographic identity validation. (In this document, it is assumed that UAs apply X.509 certificate chain validation in accord with [RFC5280].)",
      "ja": "主なピニングは、信頼・オン・ファースト・使用（豆腐）メカニズムです。 UAは、ホストに接続する最初の時間は、それは、PIN検証を実行するために必要な情報を欠いています。 UAは唯一彼らの通常の暗号化身元確認を適用することができます。 （この文書では、UAは、[RFC5280]にあったX.509証明書チェーンの検証を適用するものとします。）"
    },
    {
      "indent": 3,
      "text": "The UA will not be able to detect and thwart a MITM attacking the UA's first connection to the host. (However, the requirement that the MITM provide an X.509 certificate chain that can pass the UA's validation requirements, without error, mitigates this risk somewhat.) Worse, such a MITM can inject its own PKP header into the HTTP stream, and pin the UA to its own keys. To avoid post facto detection, the attacker would have to be in a position to intercept all future requests to the host from that UA.",
      "ja": "UAは、ホストへのUAの最初の接続を攻撃MITMを検出して阻止することはできません。 （ただし、MITMがUAの検証要求を渡すことができるX.509証明書チェーンを提供する要件は、エラーなしで、幾分このリスクを軽減する。）さらに悪いことに、そのようなMITMはHTTPストリームに独自PKPヘッダを注入することができ、そしてピンUA独自のキーに。事後検出を回避するために、攻撃者はそのUAからホストに将来のすべての要求をインターセプトする立場になければならないであろう。"
    },
    {
      "indent": 3,
      "text": "Thus, key pinning as described in this document is not a perfect defense against MITM attackers capable of passing certificate chain validation procedures -- nothing short of pre-shared keys can be. However, it provides significant value by allowing host operators to limit the number of certification authorities that can vouch for the host's identity, and allows UAs to detect in-process MITM attacks after the initial communication.",
      "ja": "したがって、この文書で説明したように、キーピニングは、証明書チェーンの検証手順を通過可能なMITM攻撃者に対して完璧な防衛ではありません - 事前共有キーの短いものは何もすることはできません。しかし、それはホスト事業者がホストの身元を保証できる認証局の数を制限できるようにすることで、大きな価値を提供し、UAが、最初の連絡後、インプロセスMITM攻撃を検出することができます。"
    },
    {
      "indent": 0,
      "text": "1.1. Requirements Language",
      "section_title": true,
      "ja": "1.1。要件言語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [RFC2119].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はありますRFC 2119 [RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "2. Server and Client Behavior",
      "section_title": true,
      "ja": "2.サーバーとクライアントの動作"
    },
    {
      "indent": 0,
      "text": "2.1. Response Header Field Syntax",
      "section_title": true,
      "ja": "2.1。レスポンスヘッダーフィールドの構文"
    },
    {
      "indent": 3,
      "text": "The \"Public-Key-Pins\" and \"Public-Key-Pins-Report-Only\" header fields, also referred to within this specification as the PKP and PKP-RO header fields, respectively, are new response headers defined in this specification. They are used by a server to indicate that a UA should perform Pin Validation (Section 2.6) for the host emitting the response message, and to provide the necessary information for the UA to do so.",
      "ja": "「公開鍵ピン」ともPKPとPKP-ROヘッダフィールドとして、この仕様の範囲内にいう「公開鍵 - ピン・レポートのみの」ヘッダフィールド、それぞれ、この仕様で定義された新しいレスポンスヘッダです。これらは、UAは、ホストが応答メッセージを発するピン検証（2.6節）を行う必要があり、UAは、これを行うために必要な情報を提供することを示すためにサーバによって使用されます。"
    },
    {
      "indent": 3,
      "text": "Figure 1 describes the syntax (Augmented Backus-Naur Form) of the header fields, using the grammar defined in [RFC5234] and the rules defined in Section 3.2 of [RFC7230]. The field values of both header fields conform to the same rules.",
      "ja": "図1は、[RFC5234]で定義された文法と[RFC7230]のセクション3.2で定義されたルールを使用して、ヘッダフィールドの構文（増補バッカスナウア記法）を記述する。両方のヘッダフィールドのフィールド値が同一の規則に従います。"
    },
    {
      "indent": 3,
      "text": "Public-Key-Directives = directive *( OWS \";\" OWS directive )",
      "ja": "公開鍵ディレクティブ=ディレクティブ*（OWS「;」OWSディレクティブ）"
    },
    {
      "indent": 3,
      "text": "directive = directive-name [ \"=\" directive-value ] directive-name = token directive-value = token / quoted-string",
      "ja": "ディレクティブ=ディレクティブ名[「=」ディレクティブ値]ディレクティブ名=トークン指令値=トークン/引用符で囲まれた文字列"
    },
    {
      "indent": 23,
      "text": "Figure 1: HPKP Header Syntax",
      "ja": "図1：HPKPヘッダー構文"
    },
    {
      "indent": 3,
      "text": "Optional white space (OWS) is used as defined in Section 3.2.3 of [RFC7230]. token and quoted-string are used as defined in Section 3.2.6 of [RFC7230].",
      "ja": "[RFC7230]のセクション3.2.3で定義されるように、オプションのホワイトスペース（OWS）が使用されます。 [RFC7230]のセクション3.2.6で定義されたトークンと引用文字列が使用されます。"
    },
    {
      "indent": 3,
      "text": "The directives defined in this specification are described below. The overall requirements for directives are:",
      "ja": "本明細書で定義された指令は、以下に記載されています。ディレクティブのための全体的な要件は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "1. The order of appearance of directives is not significant.",
      "section_title": true,
      "ja": "1.ディレクティブの出現の順序は重要ではありません。"
    },
    {
      "indent": 3,
      "text": "2. With the exception of pin-directives with the same pin-directive-name (see below), a given directive MUST NOT appear more than once in a given header field. Directives are either optional or required, as stipulated in their definitions.",
      "ja": "同じピン指令名とピンディレクティブを除いて2（下記参照）、所定の指令が与えられたヘッダフィールドに複数回現れてはいけません。その定義に定めるディレクティブは、オプションまたは必須のどちらかです。"
    },
    {
      "indent": 3,
      "text": "3. Directive names are case insensitive.",
      "section_title": true,
      "ja": "3.指令名は大文字小文字を区別しません。"
    },
    {
      "indent": 3,
      "text": "4. UAs MUST ignore any header fields containing directives, or other header field value data, that do not conform to the syntax defined in this specification. In particular, UAs must not attempt to fix malformed header fields.",
      "ja": "4. UAは、本明細書で定義された構文に準拠しないディレクティブ、または他のヘッダフィールド値のデータを含む任意のヘッダフィールドを無視しなければなりません。特に、UAは不正なヘッダフィールドを修正しようとしてはなりません。"
    },
    {
      "indent": 3,
      "text": "5. If a header field contains any directive(s) the UA does not recognize, the UA MUST ignore those directives.",
      "ja": "5.ヘッダフィールドはUAが認識しない任意の指令（単数または複数）が含まれている場合、UAはそれらの指示を無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "6. If the PKP or PKP-RO header field otherwise satisfies the above requirements (1 through 5), the UA MUST process the directives it recognizes.",
      "ja": "PKPまたはPKP-ROヘッダフィールドは、そうでなければ、上記の要件（1〜5）を満たす場合6、UAは、それが認識するディレクティブを処理しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Additional directives extending the semantic functionality of the header fields can be defined in other specifications. The first such specification will need to define a registry for such directives. Such future directives will be ignored by UAs implementing only this specification, as well as by generally non-conforming UAs.",
      "ja": "ヘッダフィールドの意味機能を拡張する追加の指示は他の仕様で定義することができます。まず、このような仕様では、このようなディレクティブのレジストリを定義する必要があります。このような将来のディレクティブは、この仕様を実装するUAによるだけでなく、一般に非準拠のUAによって無視されます。"
    },
    {
      "indent": 3,
      "text": "When a connection passes Pin Validation using the UA's noted Pins for the host at the time, the host becomes a Known Pinned Host.",
      "ja": "接続が一度にホストのためのUAの指摘ピンを使用してピンの検証を通過すると、ホストは既知釘付けホストになります。"
    },
    {
      "indent": 0,
      "text": "2.1.1. The Pin Directive",
      "section_title": true,
      "ja": "2.1.1。ピン指令"
    },
    {
      "indent": 3,
      "text": "The pin directive specifies a way for web host operators to indicate a cryptographic identity that should be bound to a given web host. The syntax of a pin directive is as follows:",
      "ja": "ピンディレクティブは、Webホスト事業者が指定したWebホストにバインドする必要があり、暗号のアイデンティティを示すための方法を指定します。次のようにピンディレクティブの構文は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "pin-directive = pin-directive-name \"=\" pin-directive-value",
      "ja": "ピンディレクティブ=ピンディレクティブ名「=」ピン指令値"
    },
    {
      "indent": 3,
      "text": "pin-directive-name = \"pin-\" token pin-directive-value = quoted-string",
      "ja": "ピンディレクティブ名=「ピン互換」トークンピン指令値=引用符で囲まれた文字列"
    },
    {
      "indent": 22,
      "text": "Figure 2: Pin Directive Syntax",
      "ja": "図2：ピンディレクティブ構文"
    },
    {
      "indent": 3,
      "text": "In the pin-directive, the token is the name of a cryptographic hash algorithm. The only algorithm allowed at this time is \"sha256\", i.e., the hash algorithm SHA256 [RFC6234]; additional algorithms may be allowed for use in this context in the future. The quoted-string is a sequence of base 64 digits: the base64-encoded SPKI Fingerprint [RFC4648] (see Section 2.4).",
      "ja": "ピンディレクティブでは、トークンは、暗号化ハッシュアルゴリズムの名前です。この時点で許可される唯一のアルゴリズムでは、「SHA256」、すなわち、ハッシュアルゴリズムSHA256 [RFC6234]です。追加のアルゴリズムは、将来的には、この文脈での使用のために許可することができます。引用符で囲まれた文字列は、ベース64桁の配列である：base64エンコードSPKI指紋[RFC4648]（セクション2.4を参照します）。"
    },
    {
      "indent": 3,
      "text": "According to the processing rules of Section 2.1, the UA MUST ignore pin-directives with tokens naming hash algorithms it does not recognize. If the set of remaining effective pin-directives is empty, and if the host is a Known Pinned Host, the UA MUST cease to consider the host as a Known Pinned Host (the UA should fail open). The UA should indicate to users that the host is no longer a Known Pinned Host.",
      "ja": "セクション2.1の処理ルールによれば、UAは、それが認識しないハッシュアルゴリズムを命名トークンとピンディレクティブを無視しなければなりません。効果的なピン・ディレクティブを残りのセットは空で、ホストは既知のピンでとめホストである場合、UAは、既知のピンでとめホスト（UAがオープン故障した場合）などのホストを考えるのをやめる必要があります。 UAは、ホストがもはや既知のピンドホストであるユーザーに示す必要があります。"
    },
    {
      "indent": 3,
      "text": "Note, per the processing rules of Section 2.1, the pin-directive-name is case insensitive.",
      "ja": "セクション2.1の処理ルールごとに、ピン指令名は大文字小文字を区別しないで、注意してください。"
    },
    {
      "indent": 0,
      "text": "2.1.2. The max-age Directive",
      "section_title": true,
      "ja": "2.1.2。 MAX-ageディレクティブ"
    },
    {
      "indent": 3,
      "text": "The \"max-age\" directive specifies the number of seconds after the reception of the PKP header field during which the UA SHOULD regard the host (from whom the message was received) as a Known Pinned Host.",
      "ja": "「最大エージング」ディレクティブは、UAは、既知釘付けホストとして（メッセージを受信した人からの）ホストを考えるべきで、その間PKPヘッダフィールドの受信後の秒数を指定します。"
    },
    {
      "indent": 3,
      "text": "The \"max-age\" directive is REQUIRED to be present within a \"Public-Key-Pins\" header field. The \"max-age\" directive is meaningless within a \"Public-Key-Pins-Report-Only\" header field, and UAs MUST ignore it and not cache the header. See Section 2.3.3.",
      "ja": "「最大エージング」ディレクティブは、「公開鍵-Pinsの」ヘッダフィールド内に存在することが必要です。 「最大エージング」ディレクティブは、「公開鍵 - ピン・レポートのみの」ヘッダフィールド内で無意味であり、UAはそれを無視し、ヘッダをキャッシュしてはなりません。 2.3.3項を参照してください。"
    },
    {
      "indent": 3,
      "text": "The max-age directive is REQUIRED to have a directive value, for which the syntax (after quoted-string unescaping, if necessary) is defined as:",
      "ja": "MAX-ageディレクティブは、（必要であれば、引用符で囲まれた文字列のアンエスケープ後）指令値、の構文を持つ必要があるように定義されます。"
    },
    {
      "indent": 3,
      "text": "max-age-value = delta-seconds delta-seconds = 1*DIGIT",
      "ja": "最大エージング値=デルタ秒デルタ秒= 1 * DIGIT"
    },
    {
      "indent": 22,
      "text": "Figure 3: max-age Value Syntax",
      "ja": "図3：最大エージング値構文"
    },
    {
      "indent": 3,
      "text": "delta-seconds is used as defined in [RFC7234], Section 1.2.1.",
      "ja": "デルタ秒[RFC7234]、セクション1.2.1で定義されるように使用されています。"
    },
    {
      "indent": 3,
      "text": "See Section 2.3.3 for limitations on the range of values for max-age.",
      "ja": "最大エージングの値の範囲の制限については、セクション2.3.3を参照してください。"
    },
    {
      "indent": 0,
      "text": "2.1.3. The includeSubDomains Directive",
      "section_title": true,
      "ja": "2.1.3。 includeSubDomains指令"
    },
    {
      "indent": 3,
      "text": "The OPTIONAL includeSubDomains directive is a valueless directive that, if present (i.e., it is \"asserted\"), signals to the UA that the Pinning Policy applies to this Pinned Host as well as any subdomains of the host's domain name.",
      "ja": "オプションincludeSubDomainsディレクティブは、存在する場合（すなわち、それは「アサート」された）、無価値ディレクティブ、ピンニングポリシーは、このピンでとめホストだけでなく、ホストのドメイン名のいずれかのサブドメインに適用されることをUAへの信号です。"
    },
    {
      "indent": 0,
      "text": "2.1.4. The report-uri Directive",
      "section_title": true,
      "ja": "2.1.4。レポート-URI指令"
    },
    {
      "indent": 3,
      "text": "The OPTIONAL report-uri directive indicates the URI to which the UA SHOULD report Pin Validation failures (Section 2.6). The UA POSTs the reports to the given URI as described in Section 3.",
      "ja": "オプションレポート-URIディレクティブは、UAは、ピンの検証の失敗（2.6節）を報告しなければならないためにどのURIを示します。第3節で説明したように指定されたURIへのUAの投稿がレポート。"
    },
    {
      "indent": 3,
      "text": "When used in the PKP or PKP-RO headers, the presence of a report-uri directive indicates to the UA that in the event of Pin Validation failure it SHOULD POST a report to the report-uri. If the header is Public-Key-Pins, the UA should do this in addition to terminating the connection (as described in Section 2.6).",
      "ja": "PKPやPKP-ROヘッダーで使用した場合、レポート-URIディレクティブの存在は、ピンの検証に障害が発生した場合に、それがレポート-URIにレポートをPOSTべきであるUAに示します。ヘッダは公開鍵-Pinsのであれば、UAは（2.6節で説明したように）接続を終了するに加えて、これを行う必要があります。"
    },
    {
      "indent": 3,
      "text": "Hosts may set report-uris that use HTTP or HTTPS. If the scheme in the report-uri is one that uses TLS (e.g., HTTPS), UAs MUST perform Pinning Validation when the host in the report-uri is a Known Pinned Host; similarly, UAs MUST apply HSTS if the host in the report-uri is a Known HSTS Host.",
      "ja": "ホストは、HTTPまたはHTTPSを使用レポート-URIを設定することがあります。レポート-URI内のスキームはTLS（例えば、HTTPS）を使用するものであればレポート-URI内のホストは、既知のピン留めホストである場合、UAはピンニング検証を実行しなければなりません。レポート-URIでホストが既知のHSTSホストである場合も同様に、UAはHSTSを適用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Note that the report-uri need not necessarily be in the same Internet domain or web origin as the host being reported about.",
      "ja": "レポート-uriの必要性は必ずしもについて報告されているホストと同じインターネットドメインまたはWeb起源であることではないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "UAs SHOULD make their best effort to report Pin Validation failures to the report-uri, but they may fail to report in exceptional conditions. For example, if connecting the report-uri itself incurs a Pinning Validation failure or other certificate validation failure, the UA MUST cancel the connection. Similarly, if Known Pinned Host A sets a report-uri referring to Known Pinned Host B, and if B sets a report-uri referring to A, and if both hosts fail Pin Validation, the UA SHOULD detect and break the loop by failing to send reports to and about those hosts.",
      "ja": "UAは、レポート-URIにピン検証の失敗を報告するために最善の努力をする必要がありますが、彼らは例外的な条件に報告しないことがあります。レポート-URI自体を接続するピン止め検証障害または他の証明書の検証の失敗を招く場合など、UAは、接続を解除しなければなりません。同様に、既知の場合にピンホストAは、レポート-URI既知ピン留めホストBへの参照を設定し、Bはレポート-URI Aを参照すると設定し、両方のホストがピン検証を失敗した場合、UAはに失敗することによりループを検出し、破壊する必要がある場合それらのホストに関するレポートを送信します。"
    },
    {
      "indent": 3,
      "text": "In any case of report failure, the UA MAY attempt to re-send the report later.",
      "ja": "レポートの失敗のいずれの場合では、UAは、後でレポートを再送信しようとします。"
    },
    {
      "indent": 3,
      "text": "UAs SHOULD limit the rate at which they send reports. For example, it is unnecessary to send the same report to the same report-uri more than once per distinct set of declared Pins.",
      "ja": "UAは、彼らがレポートを送信する速度を制限する必要があります。例えば、それが同じレポートを送信する必要がなく、同じレポート-URI宣言ピンの明確なセットごとに複数回。"
    },
    {
      "indent": 0,
      "text": "2.1.5. Examples",
      "section_title": true,
      "ja": "2.1.5。例"
    },
    {
      "indent": 3,
      "text": "Figure 4 shows some example PKP and PKP-RO response header fields. (Lines are folded to fit.)",
      "ja": "図4は、いくつかの例PKPとPKP-RO応答ヘッダフィールドを示します。 （行が収まるように折り畳まれています。）"
    },
    {
      "indent": 3,
      "text": "Public-Key-Pins: max-age=3000;\n    pin-sha256=\"d6qzRu9zOECb90Uez27xWltNsj0e1Md7GkYYkVoZWmM=\";\n    pin-sha256=\"E9CZ9INDbd+2eRQozYqqbQ2yXLVKB9+xcprMF+44U1g=\"",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Public-Key-Pins: max-age=2592000;\n    pin-sha256=\"E9CZ9INDbd+2eRQozYqqbQ2yXLVKB9+xcprMF+44U1g=\";\n    pin-sha256=\"LPJNul+wow4m6DsqxbninhsWHlwfp0JecwQzYpOLmCQ=\"",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Public-Key-Pins: max-age=2592000;\n    pin-sha256=\"E9CZ9INDbd+2eRQozYqqbQ2yXLVKB9+xcprMF+44U1g=\";\n    pin-sha256=\"LPJNul+wow4m6DsqxbninhsWHlwfp0JecwQzYpOLmCQ=\";\n    report-uri=\"http://example.com/pkp-report\"",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Public-Key-Pins-Report-Only: max-age=2592000;\n    pin-sha256=\"E9CZ9INDbd+2eRQozYqqbQ2yXLVKB9+xcprMF+44U1g=\";\n    pin-sha256=\"LPJNul+wow4m6DsqxbninhsWHlwfp0JecwQzYpOLmCQ=\";\n    report-uri=\"https://other.example.net/pkp-report\"",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Public-Key-Pins:\n    pin-sha256=\"d6qzRu9zOECb90Uez27xWltNsj0e1Md7GkYYkVoZWmM=\";\n    pin-sha256=\"LPJNul+wow4m6DsqxbninhsWHlwfp0JecwQzYpOLmCQ=\";\n    max-age=259200",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Public-Key-Pins:\n    pin-sha256=\"d6qzRu9zOECb90Uez27xWltNsj0e1Md7GkYYkVoZWmM=\";\n    pin-sha256=\"E9CZ9INDbd+2eRQozYqqbQ2yXLVKB9+xcprMF+44U1g=\";\n    pin-sha256=\"LPJNul+wow4m6DsqxbninhsWHlwfp0JecwQzYpOLmCQ=\";\n    max-age=10000; includeSubDomains",
      "raw": true
    },
    {
      "indent": 9,
      "text": "Figure 4: HTTP Public Key Pinning (HPKP) Header Examples",
      "ja": "図4：HTTP公開キーピン留め（HPKP）ヘッダの例"
    },
    {
      "indent": 0,
      "text": "2.2. Server Processing Model",
      "section_title": true,
      "ja": "2.2。サーバー処理モデル"
    },
    {
      "indent": 3,
      "text": "This section describes the processing model that Pinned Hosts implement. The model has 2 parts: (1) the processing rules for HTTP request messages received over a secure transport (e.g., authenticated, non-anonymous TLS); and (2) the processing rules for HTTP request messages received over non-secure transports, such as TCP.",
      "ja": "このセクションでは、ピンのホストが実装する処理モデルについて説明します。モデルは2つの部分があります：（1）HTTPリクエストメッセージの処理ルールは、セキュアトランスポート（例えば、認証、非匿名TLS）を介して受信します。 （2）TCPのような非セキュアトランスポート上で受信したHTTPリクエストメッセージの処理ルール。"
    },
    {
      "indent": 0,
      "text": "2.2.1. HTTP-over-Secure-Transport Request Type",
      "section_title": true,
      "ja": "2.2.1。 HTTPオーバーセキュア・トランスポート要求タイプ"
    },
    {
      "indent": 3,
      "text": "When replying to an HTTP request that was conveyed over a secure transport, a Pinned Host SHOULD include in its response exactly one PKP header field, exactly one PKP-RO header field, or one of each. Each instance of either header field MUST satisfy the grammar specified in Section 2.1.",
      "ja": "セキュアなトランスポートを介して搬送されたHTTPリクエストへの応答時に、固定ホストは応答正確に一つPKPヘッダフィールド、正確に一つのPKP-ROヘッダフィールド、またはそれぞれの一つに含まれるべきです。いずれかのヘッダフィールドの各インスタンスは、セクション2.1で指定された文法を満たさなければなりません。"
    },
    {
      "indent": 3,
      "text": "Establishing a given host as a Known Pinned Host, in the context of a given UA, is accomplished as follows:",
      "ja": "次のように与えられたUAの文脈の中で、既知釘付けホストとして指定したホストを確立し、達成されています。"
    },
    {
      "indent": 3,
      "text": "1. Over the HTTP protocol running over secure transport, by correctly returning (per this specification) at least one valid PKP header field to the UA.",
      "ja": "正しくUAに（本明細書あたり）少なくとも一つの有効なPKPヘッダフィールドを返すことによって、安全なトランスポート上で動作するHTTPプロトコルを介して1。"
    },
    {
      "indent": 3,
      "text": "2. Through other mechanisms, such as a client-side preloaded Known Pinned Host List.",
      "ja": "そのような既知のピンでとめホストリストプリロードクライアント側などの他のメカニズムを介して、2。"
    },
    {
      "indent": 0,
      "text": "2.2.2. HTTP Request Type",
      "section_title": true,
      "ja": "2.2.2。 HTTPリクエストの種類"
    },
    {
      "indent": 3,
      "text": "Pinned Hosts SHOULD NOT include the PKP header field in HTTP responses conveyed over non-secure transport. UAs MUST ignore any PKP header received in an HTTP response conveyed over non-secure transport.",
      "ja": "固定ホストは非セキュアトランスポートを介して搬送HTTP応答のPKPヘッダフィールドを含むべきではありません。 UAは非セキュアトランスポートを介して搬送HTTP応答で受信したPKPヘッダを無視しなければなりません。"
    },
    {
      "indent": 0,
      "text": "2.3. User Agent Processing Model",
      "section_title": true,
      "ja": "2.3。ユーザエージェント処理モデル"
    },
    {
      "indent": 3,
      "text": "The UA processing model relies on parsing domain names. Note that internationalized domain names SHALL be canonicalized according to the scheme in Section 10 of [RFC6797].",
      "ja": "UA処理モデルは、ドメイン名を解析に依存しています。国際化ドメイン名は、[RFC6797]のセクション10におけるスキームに従って正規化するものと留意されたいです。"
    },
    {
      "indent": 0,
      "text": "2.3.1. Public-Key-Pins Response Header Field Processing",
      "section_title": true,
      "ja": "2.3.1。公開鍵-Pinsのレスポンスヘッダーフィールド処理"
    },
    {
      "indent": 3,
      "text": "If the UA receives, over a secure transport, an HTTP response that includes a PKP header field conforming to the grammar specified in Section 2.1, and there are no underlying secure transport errors or warnings (see Section 2.5), the UA MUST either:",
      "ja": "（セクション2.5を参照）UAが安全輸送、セクション2.1で指定された文法に準拠PKPヘッダフィールドを含むHTTPレスポンス上、受信、及び下にある安全なトランスポートエラーまたは警告ないがない場合、UAは、いずれかの必要があります。"
    },
    {
      "indent": 3,
      "text": "o Note the host as a Known Pinned Host if it is not already so noted (see Section 2.3.3),",
      "ja": "それはまだ述べていない場合、O（2.3.3項を参照）が知ら釘付けホストとしてホストに注意してください、"
    },
    {
      "indent": 3,
      "text": "or,",
      "ja": "または、"
    },
    {
      "indent": 3,
      "text": "o Update the UA's cached information for the Known Pinned Host if any of the max-age, includeSubDomains, or report-uri header field value directives convey information different from that already maintained by the UA.",
      "ja": "最大エージングのいずれか、includeSubDomains場合O既知釘付けホストのためのUAのキャッシュされた情報を更新し、またはレポート-URIヘッダフィールド値のディレクティブはすでにUAによって維持とは異なる情報を伝えます。"
    },
    {
      "indent": 3,
      "text": "The max-age value is essentially a \"time to live\" value relative to the time of the most recent observation of the PKP header field. If the max-age header field value token has a value of 0, the UA MUST remove its cached Pinning Policy information (including the includeSubDomains directive, if asserted) if the Pinned Host is Known, or, MUST NOT note this Pinned Host if it is not yet Known.",
      "ja": "最大エージング値は、基本的にPKPヘッダフィールドの最新の観測の時間に対する相対値を「生存時間」です。最大エージングヘッダフィールド値トークンの値が0の場合は（アサート場合includeSubDomainsディレクティブを含め、）釘付けホストが知られている、または、その場合は、このピン止めホストに注意してはならない場合、UAは、そのキャッシュされたピンニングポリシー情報を削除する必要がありますまだ知られていません。"
    },
    {
      "indent": 3,
      "text": "If a UA receives more than one PKP header field or more than one PKP-RO header field in an HTTP response message over secure transport, then the UA MUST process only the first PKP header field (if present) and only the first PKP-RO header field (if present).",
      "ja": "UAが安全なトランスポートを介してHTTP応答メッセージで複数のPKPヘッダフィールド又は複数のPKP-ROヘッダフィールドを受信した場合、UAは、最初PKPヘッダフィールド（存在する場合）にのみ第PKP-ROを処理しなければなりませんヘッダフィールド（存在する場合）。"
    },
    {
      "indent": 3,
      "text": "If the UA receives the HTTP response over insecure transport, or if the PKP header is not a Valid Pinning Header (see Section 2.5), the UA MUST ignore any present PKP header field(s). Similarly, if the UA receives the HTTP response over insecure transport, the UA MUST ignore any present PKP-RO header field(s). The UA MUST ignore any PKP or PKP-RO header fields not conforming to the grammar specified in Section 2.1.",
      "ja": "UAは、安全でないトランスポートを介してHTTPレスポンスを受信、またはPKPヘッダが有効なピンニングヘッダでない場合（2.5節を参照）場合、UAは、任意の本PKPヘッダフィールド（複数）を無視しなければなりません。 UAは、安全でないトランスポートを介してHTTPレスポンスを受信した場合、同様に、UAは、任意の本PKP-ROヘッダフィールド（複数）を無視しなければなりません。 UAは、セクション2.1で指定された文法に適合しない任意PKPまたはPKP-ROヘッダフィールドを無視しなければなりません。"
    },
    {
      "indent": 0,
      "text": "2.3.2. Interaction of Public-Key-Pins and Public-Key-Pins-Report-Only",
      "section_title": true,
      "ja": "2.3.2。公開鍵ピンと公開鍵ピン・レポートのみの相互作用"
    },
    {
      "indent": 3,
      "text": "A server MAY set both the \"Public-Key-Pins\" and \"Public-Key-Pins-Report-Only\" headers simultaneously. The headers do not interact with one another, but the UA MUST process the PKP header and SHOULD process both.",
      "ja": "サーバーは、同時に「公開鍵ピン」と「公開鍵 - ピン・レポートのみの」ヘッダの両方を設定することができます。ヘッダは、互いに相互作用しないが、UAは、PKPヘッダを処理しなければならないとの両方を処理しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The headers are processed according to Section 2.3.1.",
      "ja": "ヘッダは、第2.3.1項に従って処理されます。"
    },
    {
      "indent": 3,
      "text": "When the PKP-RO header is used with a report-uri, the UA SHOULD POST reports for Pin Validation failures to the indicated report-uri, although the UA MUST NOT enforce Pin Validation. That is, in the event of Pin Validation failure when the host has set the PKP-RO header, the UA performs Pin Validation to check whether or not it should POST a report, but not whether it should cause a connection failure.",
      "ja": "PKP-ROヘッダが報告-URIで使用される場合UAはピン検証を強制してはいけませんが、UAは、示されたレポート-URIにピン検証失敗のレポートをPOSTべきです。これは、ホストがPKP-ROヘッダを設定したピンの検証に障害が発生した場合においては、UAは、それが接続障害を起こすべきかどうかの報告をPOSTではなくすべきかどうかをチェックするためにピンの検証を行います。"
    },
    {
      "indent": 3,
      "text": "Note: There is no purpose to using the PKP-RO header without the report-uri directive. User Agents MAY discard such headers without interpreting them further.",
      "ja": "注意：レポート-uriの指示なしにPKP-ROヘッダを使用することに何の目的ではありません。ユーザエージェントは、さらにそれらを解釈せず、そのようなヘッダを捨てるかもしれ。"
    },
    {
      "indent": 3,
      "text": "When the PKP header is used with a report-uri, the UA SHOULD POST reports for Pin Validation failures to the indicated report-uri, as well as enforce Pin Validation.",
      "ja": "PKPヘッダが報告-URIと共に使用される場合、UAは、示されたレポート-URIにピン検証失敗のレポートを投稿、ならびにピンの検証を強制します。"
    },
    {
      "indent": 3,
      "text": "If a host sets the PKP-RO header, the UA SHOULD note the Pins and directives given in the PKP-RO header, ignoring any max-age directive. If the UA does note the Pins and directives in the PKP-RO header, it SHOULD evaluate the specified policy and SHOULD report any would-be Pin Validation failures that would occur if the report-only policy were enforced.",
      "ja": "ホストはPKP-ROヘッダを設定した場合、UAは、任意のMAX-ageディレクティブを無視して、PKP-ROヘッダに与えられたピンとディレクティブを注意してください。 UAは、PKP-ROヘッダにピンとディレクティブを注意しない場合は、指定したポリシーを評価すべきであるとの報告のみポリシーが適用された場合に生じるいかなる-だろうピンの検証の失敗を報告する必要があります。"
    },
    {
      "indent": 3,
      "text": "If a host sets both the PKP header and the PKP-RO header, the UA MUST note and enforce Pin Validation as specified by the PKP header, and SHOULD process the Pins and directives given in the PKP-RO header. If the UA does process the Pins and directives in the PKP-RO header, it SHOULD evaluate the specified policy and SHOULD report any would-be Pin Validation failures that would occur if the report-only policy were enforced.",
      "ja": "ホストはPKPヘッダーとPKP-ROヘッダの両方を設定した場合PKPヘッダによって指定され、ピンとPKP-ROヘッダで与えられた指令を処理するように、UAは、PIN検証に注意し施行しなければなりません。 UAは、PKP-ROヘッダにピンとディレクティブを処理した場合は、指定したポリシーを評価すべきであるとの報告のみポリシーが適用された場合に生じるいかなる-だろうピンの検証の失敗を報告する必要があります。"
    },
    {
      "indent": 0,
      "text": "2.3.3. Noting a Pinned Host - Storage Model",
      "section_title": true,
      "ja": "2.3.3。ストレージモデル - 釘付けホストに注目"
    },
    {
      "indent": 3,
      "text": "The Effective Pin Date of a Known Pinned Host is the time that the UA observed a Valid Pinning Header for the host. The Effective Expiration Date of a Known Pinned Host is the Effective Pin Date plus the max-age. A Known Pinned Host is \"expired\" if the Effective Expiration Date refers to a date in the past. The UA MUST ignore any expired Known Pinned Hosts in its cache.",
      "ja": "既知釘付けホストの有効ピン日付はUAがホストに対して有効なピン留めヘッダーを観察した時間です。既知釘付けホストの有効有効期限は発効ピン日プラス最大エージングです。有効期限の日付が過去の日付を参照する場合の既知のピン留めホストは、「有効期限が切れた」です。 UAは、そのキャッシュ内の有効期限が切れ既知のピン止めのホストを無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "For example, if a UA is beginning to perform Pin Validation for a Known Pinned Host and finds that the cached pinning information for the host indicates an Effective Expiration Date in the past, the UA MUST NOT continue with Pin Validation for the host, and MUST consider the host to no longer be a Known Pinned Host.",
      "ja": "UAは、既知のピンでとめホスト用のピンの検証を実行するために開始し、ホストのキャッシュされたのピニング情報は過去に効果的な有効期限を示すことを発見している場合たとえば、UAはピンホストの検証、およびMUSTを続けてはなりませんもはや既知のピンドホストがないようにホストを考えます。"
    },
    {
      "indent": 3,
      "text": "Known Pinned Hosts are identified only by domain names, and never IP addresses. If the substring matching the host production from the Request-URI (of the message to which the host responded) syntactically matches the IP-literal or IPv4address productions from Section 3.2.2 of [RFC3986], then the UA MUST NOT note this host as a Known Pinned Host.",
      "ja": "既知のピン止めのホストは、ドメイン名のみ、そして決してIPアドレスによって識別されます。 （ホストが応答するメッセージ）のRequest-URIからホスト生産にマッチサブストリングが構文的に[RFC3986]のセクション3.2.2からIP-リテラルまたはIPv4Addressを生産と一致する場合、UAは、このホストに注意してはいけません既知のピン止めホスト。"
    },
    {
      "indent": 3,
      "text": "Otherwise, if the substring does not congruently match an existing Known Pinned Host's domain name, per the matching procedure specified in Section 8.2 of [RFC6797], then the UA MUST add this host to the Known Pinned Host cache. The UA caches:",
      "ja": "それ以外の場合は、部分文字列が合同[RFC6797]のセクション8.2で指定されたマッチング手順ごとに、既存の既知釘付けホストのドメイン名と一致しない場合、UAは、既知のピンでとめホストキャッシュにこのホストを追加しなければなりません。 UAキャッシュ："
    },
    {
      "indent": 3,
      "text": "o the Pinned Host's domain name,",
      "ja": "ピンでとめホストのドメイン名O、"
    },
    {
      "indent": 3,
      "text": "o the Effective Expiration Date, or enough information to calculate it (the Effective Pin Date and the value of the max-age directive),",
      "ja": "有効期限の日付、またはそれを計算するのに十分な情報（有効ピン日付とmax-ageディレクティブの値）、O、"
    },
    {
      "indent": 3,
      "text": "o whether or not the includeSubDomains directive is asserted, and",
      "ja": "includeSubDomainsディレクティブがアサートされているかどうか、O、および"
    },
    {
      "indent": 3,
      "text": "o the value of the report-uri directive, if present.",
      "ja": "存在する場合、レポート-URIディレクティブの値O。"
    },
    {
      "indent": 3,
      "text": "If any other metadata from optional or future PKP header directives are present in the Valid Pinning Header, and the UA understands them, the UA MAY note them as well.",
      "ja": "オプション又は将来PKPヘッダディレクティブからの任意の他のメタデータが有効ピンニングヘッダに存在し、UAがそれらを理解している場合、UAは、同様にそれらを気づくかもしれません。"
    },
    {
      "indent": 3,
      "text": "UAs MAY set an upper limit on the value of max-age, so that UAs that have noted erroneous Pins (whether by accident or due to attack) have some chance of recovering over time. If the server sets a max-age greater than the UA's upper limit, the UA MAY behave as if the server set the max-age to the UA's upper limit. For example, if the UA caps max-age at 5,184,000 seconds (60 days), and a Pinned Host sets a max-age directive of 90 days in its Valid Pinning Header, the UA MAY behave as if the max-age were effectively 60 days. (One way to achieve this behavior is for the UA to simply store a value of 60 days instead of the 90-day value provided by the Pinned Host.) For UA implementation guidance on how to select a maximum max-age, see Section 4.1.",
      "ja": "誤ったピン（偶然かによる攻撃するかどうかを）指摘しているUAは時間の経過とともに回復のいくつかのチャンスを持っているように、UAは、最大エージングの値に上限を設定することができます。サーバはUAの上限よりも最大エージング大きい設定した場合、サーバーはUAの上限を最大エージングを設定するかのように、UAは動作をする場合があります。例えば、UAは5184000秒（60日）で、最大エージングキャップ、及び固定ホストは、その有効なピンニングヘッダの90日のMAX-ageディレクティブは、UAは、最大エージングが効果的に60だったかのように振る舞うかもしれない設定した場合日々。 （UAは、単に60日の値の代わりに釘付けホストが提供する90日間の値を格納するために、この動作を達成するための一つの方法です。）最大最大エージングを選択する方法についてUAの実装のガイダンスについては、4.1節を参照してください。"
    },
    {
      "indent": 3,
      "text": "The UA MUST NOT modify any pinning metadata of any superdomain matched Known Pinned Host.",
      "ja": "UAは、任意のスーパードメイン一致既知釘付けホストの任意のピン留めメタデータを変更してはいけません。"
    },
    {
      "indent": 3,
      "text": "The UA MUST NOT cache information derived from a PKP-RO header. (PKP-RO headers are useful only at the time of receipt and processing.)",
      "ja": "UAは、PKP-ROヘッダから導出される情報をキャッシュしてはいけません。 （PKP-ROヘッダのみ受信および処理時に有用です。）"
    },
    {
      "indent": 0,
      "text": "2.3.4. HTTP-Equiv <Meta> Element Attribute",
      "section_title": true,
      "ja": "2.3.4。 HTTP-当量の<META>要素の属性"
    },
    {
      "indent": 3,
      "text": "UAs MUST NOT heed http-equiv=\"Public-Key-Pins\" or http-equiv=\"Public-Key-Pins-Report-Only\" attribute settings on <meta> elements [W3C.REC-html401-19991224] in received content.",
      "ja": "UAは=「公開鍵ピン」またはhttp-当量の<meta>要素に=「公開鍵ピン-レポート専用」属性の設定[W3C.REC-html401-19991224]で受信したコンテンツのhttp-当量に耳を傾けてはなりません。"
    },
    {
      "indent": 0,
      "text": "2.4. Semantics of Pins",
      "section_title": true,
      "ja": "2.4。ピンのセマンティクス"
    },
    {
      "indent": 3,
      "text": "An SPKI Fingerprint is defined as the output of a known cryptographic hash algorithm whose input is the DER-encoded ASN.1 representation of the Subject Public Key Info (SPKI) of an X.509 certificate. A Pin is defined as the combination of the known algorithm identifier and the SPKI Fingerprint computed using that algorithm.",
      "ja": "SPKI指紋入力X.509証明書のサブジェクト公開鍵情報（SPKI）のDER符号化されたASN.1の表現で知られている暗号化ハッシュアルゴリズムの出力として定義されます。ピンは、既知のアルゴリズム識別子の組み合わせとして定義され、SPKI指紋は、そのアルゴリズムを使用して計算しました。"
    },
    {
      "indent": 3,
      "text": "The SPKI Fingerprint is encoded in base 64 for use in an HTTP header [RFC4648].",
      "ja": "SPKI指紋は、HTTPヘッダ[RFC4648]での使用のためにベース64で符号化されます。"
    },
    {
      "indent": 3,
      "text": "In this version of the specification, the known cryptographic hash algorithm is SHA-256, identified as \"sha256\" [RFC6234]. (Future specifications may add new algorithms and deprecate old ones.) UAs MUST ignore Pins for which they do not recognize the algorithm identifier. UAs MUST continue to process the rest of a PKP response header field and note Pins for algorithms they do recognize.",
      "ja": "仕様のこのバージョンでは、既知の暗号化ハッシュアルゴリズムは、「SHA256」[RFC6234]として同定され、SHA-256です。 （今後の仕様は、新しいアルゴリズムを追加し、古いものを廃止する。）UAは、彼らがアルゴリズム識別子を認識しないためにピンを無視しなければなりません。 UAはPKPレスポンスヘッダフィールドの残りの部分を処理し続け、彼らは認識しないアルゴリズムのためのピンに注意しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Figure 5 reproduces the definition of the SubjectPublicKeyInfo structure in [RFC5280].",
      "ja": "図5は、[RFC5280]にSubjectPublicKeyInfoで構造の定義を再生します。"
    },
    {
      "indent": 3,
      "text": "SubjectPublicKeyInfo  ::=  SEQUENCE  {\n    algorithm            AlgorithmIdentifier,\n    subjectPublicKey     BIT STRING  }",
      "raw": true
    },
    {
      "indent": 3,
      "text": "AlgorithmIdentifier  ::=  SEQUENCE  {\n    algorithm            OBJECT IDENTIFIER,\n    parameters           ANY DEFINED BY algorithm OPTIONAL  }",
      "raw": true
    },
    {
      "indent": 25,
      "text": "Figure 5: SPKI Definition",
      "ja": "図5：SPKIの定義"
    },
    {
      "indent": 3,
      "text": "If the certificate's Subject Public Key Info is incomplete when taken in isolation, such as when holding a DSA key without domain parameters, a public key pin cannot be formed.",
      "ja": "そのようなドメインパラメータを指定せずにDSAキーを押したときのように、単独で摂取した場合、証明書のサブジェクト公開鍵情報が不完全な場合は、公開鍵のピンを形成することができません。"
    },
    {
      "indent": 3,
      "text": "We pin public keys, rather than entire certificates, to enable operators to generate new certificates containing old public keys (see [why-pin-key]).",
      "ja": "私たちは、（参照[なぜピンキー]）古い公開鍵を含む新しい証明書を生成するための演算子を有効にするために、公開鍵、全体ではなく、証明書をピン。"
    },
    {
      "indent": 3,
      "text": "See Appendix A for an example non-normative program that generates SPKI Fingerprints from certificates.",
      "ja": "証明書からSPKI指紋を生成し、例えば、非規範的なプログラムについては、付録Aを参照してください。"
    },
    {
      "indent": 0,
      "text": "2.5. Noting Pins",
      "section_title": true,
      "ja": "2.5。ピンに注目"
    },
    {
      "indent": 3,
      "text": "Upon receipt of the PKP response header field, the UA notes the host as a Known Pinned Host, storing the Pins and their associated directives in non-volatile storage (for example, along with the HSTS metadata). The Pins and their associated directives are collectively known as Pinning Metadata.",
      "ja": "PKPレスポンスヘッダフィールドを受信すると、UAは、既知のピンドホストとして、（HSTSメタデータと一緒に、など）、不揮発性記憶装置のピンとそれに関連する指示を記憶するノート。ピンおよびそれに関連するディレクティブをまとめてピンニングメタデータとして知られています。"
    },
    {
      "indent": 3,
      "text": "The UA MUST note the Pins for a Host if and only if all three of the following conditions hold:",
      "ja": "UAは、ホストのピンに注意しなければならない場合にのみ、以下の3つの条件がすべて保持している場合："
    },
    {
      "indent": 3,
      "text": "o It received the PKP response header field over an error-free TLS connection. If the host is a Pinned Host, this includes the validation added in Section 2.6.",
      "ja": "Oそれは、エラーのないTLS接続を介してPKPレスポンスヘッダフィールドを受信しました。ホストがピンホストがある場合は、これは2.6節で追加の検証を含んでいます。"
    },
    {
      "indent": 3,
      "text": "o The TLS connection was authenticated with a certificate chain containing at least one of the SPKI structures indicated by at least one of the given SPKI Fingerprints (see Section 2.6).",
      "ja": "O TLS接続が所与SPKI指紋のうちの少なくとも1つによって示されるSPKI構造の少なくとも1つを含む証明書チェーンを用いて認証された（2.6節を参照）。"
    },
    {
      "indent": 3,
      "text": "o The given set of Pins contains at least one Pin that does NOT refer to an SPKI in the certificate chain. (That is, the host must set a Backup Pin; see Section 4.3.)",
      "ja": "Oピンの与えられたセットは、証明書チェーン内のSPKIを参照していない少なくとも1つのピンが含まれています。 （つまり、ホストは、バックアップピンを設定する必要があります;セクション4.3を参照してください。）"
    },
    {
      "indent": 3,
      "text": "If the PKP response header field does not meet all three of these criteria, the UA MUST NOT note the host as a Pinned Host. A PKP response header field that meets all these criteria is known as a Valid Pinning Header.",
      "ja": "PKPレスポンスヘッダフィールドは、これらの基準の3つのすべてを満たしていない場合、UAは、ピンホストとしてホストに注意してはなりません。これらのすべての基準を満たすPKPレスポンスヘッダフィールドは、有効なピン止めヘッダとして知られています。"
    },
    {
      "indent": 3,
      "text": "Whenever a UA receives a Valid Pinning Header, it MUST set its Pinning Metadata to the exact Pins, Effective Expiration Date (computed from max-age), and (if any) report-uri given in the most recently received Valid Pinning Header.",
      "ja": "UAが有効なピンニングヘッダーを受信するたびに、それは、正確なピンへのピン留めのメタデータを設定しなければなりません（最大 - 年齢から計算）有効有効期限、および（もしあれば）レポート-uriの最も最近の有効なピン留めヘッダーを受け取っに与えられました。"
    },
    {
      "indent": 3,
      "text": "For forward compatibility, the UA MUST ignore any unrecognized PKP and PKP-RO header directives, while still processing those directives it does recognize. Section 2.1 specifies the directives max-age, Pins, includeSubDomains, and report-uri, but future specifications and implementations might use additional directives.",
      "ja": "まだそれが認識しないこれらのディレクティブを処理している間に、前方互換性のために、UAは、未認識PKPとPKP-ROヘッダ指令を無視しなければなりません。セクション2.1は、ディレクティブの最大エージングを指定するピン、includeSubDomains、と報告し-URIが、将来の仕様と実装は、追加のディレクティブを使用する場合があります。"
    },
    {
      "indent": 3,
      "text": "Upon receipt of a PKP-RO response header field, the UA SHOULD evaluate the policy expressed in the field, and SHOULD generate and send a report (see Section 3). However, failure to validate the Pins in the field MUST have no effect on the validity or non-validity of the policy expressed in the PKP field or in previously noted Pins for the Known Pinned Host.",
      "ja": "PKP-RO応答ヘッダフィールドを受信すると、UAは、フィールド内で発現ポリシーを評価する必要があり、及び（3章を参照）レポートを生成して送信すべきです。しかし、フィールドでピンを検証するために、障害が政策の有効性や非有効性に影響を与えませんしなければならないPKPフィールドにまたはで表現以前から知られている釘付けホスト用のピンを指摘しました。"
    },
    {
      "indent": 3,
      "text": "The UA need not note any Pins or other policy expressed in the PKP-RO response header field, except for the purpose of determining that it has already sent a report for a given policy. UAs SHOULD make a best effort not to inundate report-uris with redundant reports.",
      "ja": "UAは、任意のピンまたは他のポリシーを注意する必要はないが、所与のポリシーのレポートを既に送信したことを決定する目的のために除いて、PKP-RO応答ヘッダフィールド内で発現。 UAは、冗長レポートで報告-URIを水浸しにしない最善の努力をするべきです。"
    },
    {
      "indent": 0,
      "text": "2.6. Validating Pinned Connections",
      "section_title": true,
      "ja": "2.6。ピン止め接続の検証"
    },
    {
      "indent": 3,
      "text": "When a UA connects to a Pinned Host using a TLS connection, if the TLS connection has errors, the UA MUST terminate the connection without allowing the user to proceed anyway. (This behavior is the same as that required by [RFC6797].)",
      "ja": "UAはTLS接続を使用してピン留めホストに接続するときにTLS接続がエラーを有する場合、UAは、ユーザがとにかく進行させずに接続を終了しなければなりません。 （この動作は、[RFC6797]によって必要とされるものと同じです。）"
    },
    {
      "indent": 3,
      "text": "If the connection has no errors, then the UA will determine whether to apply a new, additional correctness check: Pin Validation. A UA SHOULD perform Pin Validation whenever connecting to a Known Pinned Host, as soon as possible (e.g., immediately after receiving the Server Certificate message). It is acceptable to allow Pin Validation to be disabled for some Hosts according to local policy. For example, a UA may disable Pin Validation for Pinned Hosts whose validated certificate chain terminates at a user-defined trust anchor, rather than a trust anchor built-in to the UA (or underlying platform).",
      "ja": "ピン検証：接続にエラーがない場合、UAは新しい、追加の正当性チェックを適用するかどうかを決定します。既知のピンでとめホストに接続するたびUAは、できるだけ早く（例えば、すぐにサーバー証明書メッセージを受信した後）、ピンの検証を実行する必要があります。ピンの検証は、ローカルポリシーに従って、いくつかのホストのために無効にすることができるようにするために許容可能です。例えば、UAは、その検証証明書チェーンは、ユーザ定義のトラストアンカーではなく、内蔵UA（又は基礎となるプラットフォーム）にトラストアンカーで終了ピンドホストのピン検証を無効にしてもよいです。"
    },
    {
      "indent": 3,
      "text": "To perform Pin Validation, the UA will compute the SPKI Fingerprints for each certificate in the Pinned Host's validated certificate chain, using each supported hash algorithm for each certificate. (As described in Section 2.4, certificates whose SPKI cannot be taken in isolation cannot be pinned.) The UA MUST ignore superfluous certificates in the chain that do not form part of the validating chain. The UA will then check that the set of these SPKI Fingerprints intersects the set of SPKI Fingerprints in that Pinned Host's Pinning Metadata. If there is set intersection, the UA continues with the connection as normal. Otherwise, the UA MUST treat this Pin Validation failure as a non-recoverable error. Any procedure that matches the results of this Pin Validation procedure is considered equivalent.",
      "ja": "ピンの検証を実行するには、UAは、各証明書のためにサポートされている各ハッシュアルゴリズムを使用して、ピンホストの検証証明書チェーン内の各証明書のSPKI指紋を計算します。 （セクション2.4で説明したように、そのSPKI分離して取り出すことができない固定することができない。証明書）UAは、検証チェーンの一部を形成しないチェーン内の余分な証明書を無視しなければなりません。 UAは、これらのSPKI指紋のセットは、そのピンドホストのピンニングメタデータにSPKI指紋のセットと交差することを確認します。交差点が設定されている場合、UAは通常どおり接続を継続します。そうしないと、UAは回復不能なエラーとして、このピンの検証の失敗を扱わなければなりません。このピンの検証手順の結果と一致する任意の手順が同等とみなされます。"
    },
    {
      "indent": 3,
      "text": "A UA that has previously noted a host as a Known Pinned Host MUST perform Pin Validation when setting up the TLS session, before beginning an HTTP conversation over the TLS channel.",
      "ja": "TLSセッションを設定する際に以前から知られているピンでとめホストとしてホストを指摘しているUAはTLSチャネル上でHTTPの会話を開始する前に、ピンの検証を実行しなければなりません。"
    },
    {
      "indent": 3,
      "text": "UAs send validation failure reports only when Pin Validation is actually in effect. Pin Validation might not be in effect, e.g., because the user has elected to disable it, or because a presented certificate chain chains up to a user-defined trust anchor. In such cases, UAs SHOULD NOT send reports.",
      "ja": "ピンの検証が有効に実際にある場合にのみ、UAは、検証の失敗レポートを送信します。ユーザーがそれを無効にするには選出された、またはユーザー定義のトラストアンカーまで提示された証明書チェーンチェーンためているので、ピンの検証は、例えば、有効でないかもしれません。このような場合には、UAは、レポートを送るべきではありません。"
    },
    {
      "indent": 0,
      "text": "2.7. Interactions with Preloaded Pin Lists",
      "section_title": true,
      "ja": "2.7。プリロードピンリストとの相互作用"
    },
    {
      "indent": 3,
      "text": "UAs MAY choose to implement additional sources of pinning information, such as through built-in lists of pinning information. Such UAs should allow users to override such additional sources, including disabling them from consideration.",
      "ja": "UAは、このような情報をピン留めの組み込みのリストを介するなどのピニング情報の追加ソースを、実装することを選択できます。そのようなUAは考慮からそれらを無効にすることを含めて、ユーザーがこのような追加の情報源を上書きできるようにする必要があります。"
    },
    {
      "indent": 3,
      "text": "The effective policy for a Known Pinned Host that has both built-in Pins and Pins from previously observed PKP header response fields is implementation-defined.",
      "ja": "組み込まれている両方のピンとピン以前に観察PKPヘッダ応答フィールドから知らピン留めホストの有効なポリシーは、実装定義です。"
    },
    {
      "indent": 0,
      "text": "2.8. Pinning Self-Signed End Entities",
      "section_title": true,
      "ja": "2.8。自己署名エンドエンティティをピン留め"
    },
    {
      "indent": 3,
      "text": "If UAs accept hosts that authenticate themselves with self-signed end entity certificates, they MAY also allow hosts to pin the public keys in such certificates. The usability and security implications of this practice are outside the scope of this specification.",
      "ja": "UAが自己署名エンドエンティティ証明書を使用して自分自身を認証するホストを受け入れた場合、彼らはまた、ホストは、そのような証明書に公開鍵を固定することを可能にします。この練習の利便性とセキュリティの意味はこの仕様の範囲外です。"
    },
    {
      "indent": 0,
      "text": "3. Reporting Pin Validation Failure",
      "section_title": true,
      "ja": "3.ピン検証失敗を報告"
    },
    {
      "indent": 3,
      "text": "When a Known Pinned Host has set the report-uri directive, the UA SHOULD report Pin Validation failures to the indicated URI. The UA does this by POSTing a JSON [RFC7159] message to the URI; the JSON message takes this form:",
      "ja": "既知のピン止めホストがレポート-uriのディレクティブを設定している場合、UAは、示されたURIへのピンの検証の失敗を報告する必要があります。 UAは、URIにJSON [RFC7159]メッセージを投稿することによってこれを行います。 JSONメッセージは、この形式をとります。"
    },
    {
      "indent": 3,
      "text": "{\n  \"date-time\": date-time,\n  \"hostname\": hostname,\n  \"port\": port,\n  \"effective-expiration-date\": expiration-date,\n  \"include-subdomains\": include-subdomains,\n  \"noted-hostname\": noted-hostname,\n  \"served-certificate-chain\": [\n    pem1, ... pemN\n  ],\n  \"validated-certificate-chain\": [\n    pem1, ... pemN\n  ],\n  \"known-pins\": [\n    known-pin1, ... known-pinN\n  ]\n}",
      "raw": true
    },
    {
      "indent": 23,
      "text": "Figure 6: JSON Report Format",
      "ja": "図6：JSONレポート形式"
    },
    {
      "indent": 3,
      "text": "Whitespace outside of quoted strings is not significant. The key/ value pairs may appear in any order, but each MUST appear only once.",
      "ja": "引用符で囲まれた文字列の外側の空白は重要ではありません。キー/値のペアは、任意の順序で表示されることがありますが、それぞれが一度だけ現れなければなりません。"
    },
    {
      "indent": 3,
      "text": "The date-time indicates the time the UA observed the Pin Validation failure. It is provided as a string formatted according to Section 5.6, \"Internet Date/Time Format\", of [RFC3339].",
      "ja": "日時は、UAは、ピンの検証の失敗を観察した時刻を示しています。それは、[RFC3339]のセクション5.6、「インターネット日付/時刻形式」に従ってフォーマットされた文字列として提供されています。"
    },
    {
      "indent": 3,
      "text": "The hostname is the hostname to which the UA made the original request that failed Pin Validation. It is provided as a string.",
      "ja": "ホスト名は、UAは、ピンの検証に失敗した元の要求をした先のホスト名です。これは、文字列として提供されています。"
    },
    {
      "indent": 3,
      "text": "The port is the port to which the UA made the original request that failed Pin Validation. It is provided as an integer.",
      "ja": "ポートは、UAは、ピンの検証に失敗し、元の要求を行っているポートです。これは、整数として提供されます。"
    },
    {
      "indent": 3,
      "text": "The effective-expiration-date is the Effective Expiration Date for the noted Pins. It is provided as a string formatted according to Section 5.6, \"Internet Date/Time Format\", of [RFC3339].",
      "ja": "効果的な-満了日は指摘ピンのための効果的な有効期限です。それは、[RFC3339]のセクション5.6、「インターネット日付/時刻形式」に従ってフォーマットされた文字列として提供されています。"
    },
    {
      "indent": 3,
      "text": "include-subdomains indicates whether or not the UA has noted the includeSubDomains directive for the Known Pinned Host. It is provided as one of the JSON identifiers \"true\" or \"false\".",
      "ja": "含ま-サブドメインは、UAは、既知のピンでとめホストのincludeSubDomainsディレクティブを指摘しているかどうかを示します。これは、JSON識別子「true」または「false」の一つとして提供されます。"
    },
    {
      "indent": 3,
      "text": "noted-hostname indicates the hostname that the UA noted when it noted the Known Pinned Host. This field allows operators to understand why Pin Validation was performed for, e.g., foo.example.com when the noted Known Pinned Host was example.com with includeSubDomains set.",
      "ja": "注意ホスト名は、それが既知のピンでとめホストを指摘したときにUAが指摘したホスト名を示します。このフィールドは指摘既知釘付けホストがexample.comに設定includeSubDomainsとしたとき、ピンの検証がfoo.example.com、例えば、行った理由を事業者が理解することができます。"
    },
    {
      "indent": 3,
      "text": "The served-certificate-chain is the certificate chain, as served by the Known Pinned Host during TLS session setup. It is provided as an array of strings; each string pem1, ... pemN is the Privacy-Enhanced Mail (PEM) representation of each X.509 certificate as described in [RFC7468].",
      "ja": "TLSセッションのセットアップ時に既知釘付けホストによって提供を務めた証明書チェーンは、証明書チェーンです。これは、文字列の配列として提供されます。 [RFC7468]に記載されているように、各列PEM1は、... pemN各X.509証明書のプライバシー強化メール（PEM）です。"
    },
    {
      "indent": 3,
      "text": "The validated-certificate-chain is the certificate chain, as constructed by the UA during certificate chain verification. (This may differ from the served-certificate-chain.) It is provided as an array of strings; each string pem1, ... pemN is the PEM representation of each X.509 certificate as described in [RFC7468]. UAs that build certificate chains in more than one way during the validation process SHOULD send the last chain built. In this way, they can avoid keeping too much state during the validation process.",
      "ja": "証明書チェーンの検証中にUAによって構成された検証証明書チェーンは、証明書チェーンです。 （これは、配信証明書チェーン異なっていてもよい。）これは、文字列の配列として提供されます。 [RFC7468]に記載されているように、各列PEM1は、... pemN各X.509証明書のPEM表現です。検証プロセスの間に複数の方法で証明書チェーンを構築UAは、構築された最後のチェーンを送るべきです。このように、彼らは、検証プロセス中にあまりにも多くの状態を保つことを避けることができます。"
    },
    {
      "indent": 3,
      "text": "The known-pins are the Pins that the UA has noted for the Known Pinned Host. They are provided as an array of strings with the syntax:",
      "ja": "知られているピンは、UAは、既知のピンでとめホストのために指摘しているピンです。彼らは、構文を使用して文字列の配列として提供されています。"
    },
    {
      "indent": 3,
      "text": "known-pin = token \"=\" quoted-string",
      "ja": "知らピン=トークン「=」引用符で囲まれた文字列"
    },
    {
      "indent": 24,
      "text": "Figure 7: Known Pin Syntax",
      "ja": "図7：既知のピン構文"
    },
    {
      "indent": 3,
      "text": "As in Section 2.4, the token refers to the algorithm name, and the quoted-string refers to the base64 encoding of the SPKI Fingerprint. When formulating the JSON POST body, the UA MUST either use single-quoted JSON strings or use double-quoted JSON strings and backslash-escape the embedded double quotes in the quoted-string part of the known-pin.",
      "ja": "2.4節と同様に、トークンは、アルゴリズム名を参照し、引用符で囲まれた文字列は、SPKI指紋のbase64エンコードを指します。 JSON POST本体を策定する場合、UAは、単一引用符で囲まれたJSON文字列を使用するか、または二重引用符で囲まれたJSON文字列を使用して知られているピンの引用符で囲まれた文字列の部分に埋め込まれた二重引用符をバックスラッシュは、エスケープする必要があります。"
    },
    {
      "indent": 3,
      "text": "Figure 8 shows an example of a Pin Validation failure report. (PEM strings are shown on multiple lines for readability.)",
      "ja": "図8は、PIN検証障害レポートの例を示しています。 （PEM文字列は、読みやすいように複数行に表示されます。）"
    },
    {
      "indent": 2,
      "text": "{\n  \"date-time\": \"2014-04-06T13:00:50Z\",\n  \"hostname\": \"www.example.com\",\n  \"port\": 443,\n  \"effective-expiration-date\": \"2014-05-01T12:40:50Z\"\n  \"include-subdomains\": false,\n  \"served-certificate-chain\": [\n    \"-----BEGIN CERTIFICATE-----\\n\n    MIIEBDCCAuygAwIBAgIDAjppMA0GCSqGSIb3DQEBBQUAMEIxCzAJBgNVBAYTAlVT\\n\n    ...\n    HFa9llF7b1cq26KqltyMdMKVvvBulRP/F/A8rLIQjcxz++iPAsbw+zOzlTvjwsto\\n\n    WHPbqCRiOwY1nQ2pM714A5AuTHhdUDqB1O6gyHA43LL5Z/qHQF1hwFGPa4NrzQU6\\n\n    yuGnBXj8ytqU0CwIPX4WecigUCAkVDNx\\n\n    -----END CERTIFICATE-----\",\n    ...\n  ],\n  \"validated-certificate-chain\": [\n    \"-----BEGIN CERTIFICATE-----\\n\n    MIIEBDCCAuygAwIBAgIDAjppMA0GCSqGSIb3DQEBBQUAMEIxCzAJBgNVBAYTAlVT\\n\n    ...\n    HFa9llF7b1cq26KqltyMdMKVvvBulRP/F/A8rLIQjcxz++iPAsbw+zOzlTvjwsto\\n\n    WHPbqCRiOwY1nQ2pM714A5AuTHhdUDqB1O6gyHA43LL5Z/qHQF1hwFGPa4NrzQU6\\n\n    yuGnBXj8ytqU0CwIPX4WecigUCAkVDNx\\n\n    -----END CERTIFICATE-----\",\n    ...\n  ],\n  \"known-pins\": [\n    'pin-sha256=\"d6qzRu9zOECb90Uez27xWltNsj0e1Md7GkYYkVoZWmM=\"',\n    \"pin-sha256=\\\"E9CZ9INDbd+2eRQozYqqbQ2yXLVKB9+xcprMF+44U1g=\\\"\"\n  ]\n}",
      "raw": true
    },
    {
      "indent": 14,
      "text": "Figure 8: Pin Validation Failure Report Example",
      "ja": "図8：ピンの検証の失敗レポートの例"
    },
    {
      "indent": 0,
      "text": "4. Security Considerations",
      "section_title": true,
      "ja": "4.セキュリティについての考慮事項"
    },
    {
      "indent": 3,
      "text": "Pinning public keys helps hosts strongly assert their cryptographic identity even in the face of issuer error, malfeasance, or compromise. But, there is some risk that a host operator could lose (or lose control of) their host's private key (such as by operator error or host compromise). If the operator had pinned only the key of the host's end-entity certificate, the operator would not be able to serve their web site or application in a way that UAs would trust for the duration of their pin's max-age. (Recall that UAs MUST close the connection to a host upon Pin Failure.)",
      "ja": "公開鍵を確保すると、ホストが強くさえ発行者エラー、違法行為、または侵害の顔に自分の暗号アイデンティティを主張することができます。しかし、ホストオペレータが失われる（またはのコントロールを失う）（例えばオペレータエラーまたはホスト妥協によって）そのホストの秘密キーを可能性があり、いくつかのリスクがあります。オペレータは、ホストのエンドエンティティ証明書のキーだけを固定していた場合、オペレータは、UAがそのピンの最大エージングの期間信頼ような方法で自分のWebサイトやアプリケーションを提供することができません。 （UAがピン障害時にホストへの接続をクローズしなければならないことを思い出してください。）"
    },
    {
      "indent": 3,
      "text": "Therefore, there is a necessary trade-off between two competing goods: pin specificity and maximal reduction of the scope of issuers on the one hand; and flexibility and resilience of the host's cryptographic identity on the other hand. One way to resolve this trade-off is to compromise by pinning to the key(s) of the issuer(s) of the host's end-entity certificate(s). Often, a valid certificate chain will have at least two certificates above the end-entity certificate: the intermediate issuer and the trust anchor. Operators can pin any one or more of the public keys in this chain, and indeed MUST pin to issuers not in the chain (as, for example, a Backup Pin). Pinning to an intermediate issuer, or even to a trust anchor or root, still significantly reduces the number of issuers who can issue end-entity certificates for the Known Pinned Host, while still giving that host flexibility to change keys without a disruption of service.",
      "ja": "したがって、2つの競合品との間の必要なトレードオフが存在する：ピン特異性および一方発行者の範囲の最大の減少は、柔軟性と一方のホストの暗号アイデンティティの回復力。このトレードオフを解決する一つの方法は、ホストのエンドエンティティ証明書（複数可）の発行者（複数可）のキー（複数可）に固定することによって妥協することです。中間発行者およびトラストアンカー：多くの場合、有効な証明書チェーンは、エンドエンティティ証明書上の少なくとも2つの証明書を持っています。オペレータは、このチェーン内の公開鍵のいずれか一つ以上を固定することができ、実際に（バックアップピン、例えば、のような）チェーンにおける発行者しないようにピンなければなりません。中間発行者に、あるいはトラストアンカーまたはルートにピン留め、まだかなりまだサービスを中断することなく、キーを変更するには、そのホストの柔軟性を与えながら、既知のピン止めホストのエンドエンティティ証明書を発行することができ発行体の数を減らすことができます。"
    },
    {
      "indent": 0,
      "text": "4.1. Maximum max-age",
      "section_title": true,
      "ja": "4.1。最大最大エージング"
    },
    {
      "indent": 3,
      "text": "As mentioned in Section 2.3.3, UAs MAY cap the max-age value at some upper limit. There is a security trade-off in that low maximum values provide a narrow window of protection for users who visit the Known Pinned Host only infrequently, while high maximum values might result in a UA's inability to successfully perform Pin Validation for a Known Pinned Host if the UA's noted Pins and the host's true Pins diverge.",
      "ja": "2.3.3項で述べたように、UAは、いくつかの上限値で最大エージング値をキャップするかもしれません。その低い最大値のセキュリティのトレードオフがあり、高い最大値が正常ならば既知釘付けホスト用のピンの検証を実行するには、UAのできなくなるかもしれないが、まれにしか知られてピンでとめホストを訪問するユーザーのための保護の狭い窓を提供していますUAの指摘ピンとホストの真のピンを発散します。"
    },
    {
      "indent": 3,
      "text": "Such divergence could occur for several reasons, including: UA error; host operator error; network attack; or a Known Pinned Host that intentionally migrates all pinned keys, combined with a UA that has noted true Pins with a high max-age value and has not had a chance to observe the new true Pins for the host. (This last example underscores the importance for host operators to phase in new keys gradually and to set the max-age value in accordance with their planned key migration schedule.)",
      "ja": "このような相違は、以下を含む、いくつかの理由で発生する可能性があります：UAエラー。オペレータエラーをホストします。ネットワーク攻撃。または意図的に高い最大エージング値と真のピンを指摘しているし、ホストのための新しい真のピンを観察する機会がなかったUAと組み合わせて、すべての固定キーを、移行既知釘付けホスト。 （この最後の例では、ホスト事業者が徐々に新しいキーを中に相へとその計画の鍵移行スケジュールに合わせて最大エージング値を設定するための重要性を強調しています。）"
    },
    {
      "indent": 3,
      "text": "There is probably no ideal upper limit to the max-age directive that would satisfy all use cases. However, a value on the order of 60 days (5,184,000 seconds) may be considered a balance between the two competing security concerns.",
      "ja": "すべてのユースケースを満足させるのmax-ageディレクティブへの理想的な上限はおそらくありません。しかし、60日（5184000秒）程度の値が2つの競合するセキュリティ上の懸念のバランスとみなすことができます。"
    },
    {
      "indent": 0,
      "text": "4.2. Using includeSubDomains Safely",
      "section_title": true,
      "ja": "4.2。安全includeSubDomainsを使用して"
    },
    {
      "indent": 3,
      "text": "It may happen that Pinned Hosts whose hostnames share a parent domain use different Valid Pinning Headers. If a host whose hostname is a parent domain for another host sets the includeSubDomains directive, the two hosts' Pins may conflict with each other. For example, consider two Known Pinned Hosts, example.com and subdomain.example.com. Assume example.com sets a Valid Pinning Header such as this:",
      "ja": "これは、そのホスト名が異なる有効なピン留めヘッダを使用し、親ドメインを共有するピン止めホストが起こることがあります。そのホスト名を別のホストの親ドメインでホストがincludeSubDomainsディレクティブを設定した場合、2つのホストのピンが互いに競合する可能性があります。例えば、二つの既知釘付けホスト、example.comとsubdomain.example.comを検討してください。想定example.comは、このような有効なピン留めヘッダーを設定します。"
    },
    {
      "indent": 3,
      "text": "Public-Key-Pins: max-age=12000; pin-sha256=\"ABC...\"; pin-sha256=\"DEF...\"; includeSubDomains",
      "ja": "公開鍵ピン：最大エージング= 12000;ピン-SHA256 = \"ABC ...\"。ピン-SHA256 = \"DEF ...\"。 includeSubDomains"
    },
    {
      "indent": 16,
      "text": "Figure 9: example.com Valid Pinning Header",
      "ja": "図9：example.com有効なピンニングヘッダー"
    },
    {
      "indent": 3,
      "text": "Assume subdomain.example.com sets a Valid Pinning Header such as this:",
      "ja": "想定subdomain.example.comは、このような有効なピン留めヘッダーを設定します。"
    },
    {
      "indent": 3,
      "text": "Public-Key-Pins: pin-sha256=\"GHI...\"; pin-sha256=\"JKL...\"",
      "ja": "公開鍵ピン：ピン-SHA256 = \"GHI ...\"。ピン-SHA256 = \"JKL ...\""
    },
    {
      "indent": 11,
      "text": "Figure 10: subdomain.example.com Valid Pinning Header",
      "ja": "図10：subdomain.example.com有効なピンニングヘッダー"
    },
    {
      "indent": 3,
      "text": "Assume a UA that has not previously noted any Pins for either of these hosts. If the UA first contacts subdomain.example.com, it will note the Pins in the Valid Pinning Header, and perform Pin Validation as normal on subsequent connections. If the UA then contacts example.com, again it will note the Pins and perform Pin Validation on future connections.",
      "ja": "以前にこれらのホストのいずれかの任意のピンに注意していないUAを前提としています。 UA最初に接触subdomain.example.com場合は、それが有効なピンニングヘッダのピンに注意し、以降の接続に通常通りピンの検証を行います。 UAは、その後、連絡先example.comが、再び、それはピンに注意し、将来の接続にピンの検証を行います場合。"
    },
    {
      "indent": 3,
      "text": "However, if the UA happened to visit example.com before subdomain.example.com, the UA would, due to example.com's use of the includeSubDomains directive, attempt to perform Pin Validation for subdomain.example.com using the SPKI hashes ABC... and DEF..., which are not valid for the certificate chains subdomain.example.com (which uses certificates with SPKIs GHI... and JLK...). Thus, depending on the order in which the UA observes the Valid Pinning Headers for hosts example.com and subdomain.example.com, Pin Validation might or might not fail for subdomain.example.com, even if the certificate chain the UA receives for subdomain.example.com is perfectly valid.",
      "ja": "しかし、場合UAが原因includeSubDomainsディレクティブのexample.comの利用、SPKI ABCをハッシュを使用してsubdomain.example.com用ピンの検証を実行しようとする試みに、subdomain.example.com前にUAをexample.comを訪問するだろうが起こりました。 ...とDEF ...、subdomain.example.com証明書チェーンのために有効ではありません（SPKIs GHI ...とJLKで証明書を使用しています...）。したがって、UAは、example.comとsubdomain.example.comホストの有効なピン止めヘッダを観察した順序に応じて、ピン検証または証明書チェーンUAがために受信しても、subdomain.example.comために失敗しない場合がありますsubdomain.example.comは完全に有効です。"
    },
    {
      "indent": 3,
      "text": "Thus, Pinned Host operators must use the includeSubDomains directive with care. For example, they may choose to use overlapping pin sets for hosts under a parent domain that uses includeSubDomains, or to not use the includeSubDomains directive in their effective-second-level domains, or to simply use the same pin set for all hosts under a given parent domain.",
      "ja": "このように、ピンホスト事業者は注意してincludeSubDomainsディレクティブを使用する必要があります。例えば、それらはincludeSubDomainsを使用して、またはそれらの有効秒レベルドメインにincludeSubDomainsディレクティブを使用しないように、または単に下にあるすべてのホストに対して同じピンセットを使用するために親ドメインの下にホストに対して重複ピンのセットを使用することを選択することができます親ドメイン与えられました。"
    },
    {
      "indent": 0,
      "text": "4.3. Backup Pins",
      "section_title": true,
      "ja": "4.3。バックアップピン"
    },
    {
      "indent": 3,
      "text": "The primary way to cope with the risk of inadvertent Pin Validation failure is to keep a Backup Pin. A Backup Pin is a fingerprint for the public key of a secondary, not-yet-deployed key pair. The operator keeps the backup key pair offline, and sets a pin for it in the PKP header. Then, in case the operator loses control of their primary private key, they can deploy the backup key pair. UAs, who have had the backup key pair pinned (when it was set in previous Valid Pinning Headers), can connect to the host without error.",
      "ja": "不注意ピン検証失敗のリスクに対処するための主要な方法は、バックアップピンを維持することです。バックアップピンは、二次、未展開の鍵ペアの公開鍵のフィンガープリントです。オペレータは、バックアップ鍵ペアをオフラインに保持し、PKPヘッダにおけるそのためのピンをセットします。その後、ケースには、オペレータが彼らの主秘密鍵のコントロールを失い、彼らはバックアップ鍵ペアを展開することができます。固定バックアップ鍵ペアを持っていたUAは、（それは以前の有効なピンニングヘッダに設定されたとき）、エラーなしでホストに接続することができます。"
    },
    {
      "indent": 3,
      "text": "Because having a backup key pair is so important to recovery, UAs MUST require that hosts set a Backup Pin (see Section 2.5). The down side of keeping a not-yet-deployed key pair is that, if an attacker gains control of the private key, she will be able to perform a MITM attack without being discovered. Operators must take care to avoid leaking the key such as keeping it offline.",
      "ja": "バックアップキーのペアを持つことが回復に非常に重要であるため、UAはホストがバックアップピンを（2.5節を参照）を設定することを要求する必要があります。未展開の鍵ペアを保つの下側には、秘密鍵の攻撃者が制御すれば、彼女は発見されずにMITM攻撃を行うことができるようになります、ということです。オペレータは、このようなオフラインでそれを維持するように、キーを漏洩しないように注意する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.4. Interactions With Cookie Scoping",
      "section_title": true,
      "ja": "4.4。 Cookieのスコープとの相互作用"
    },
    {
      "indent": 3,
      "text": "HTTP cookies [RFC6265] set by a Known Pinned Host can be stolen by a network attacker who can forge web and DNS responses so as to cause a client to send the cookies to a phony subdomain of the host. To prevent this, hosts SHOULD set the \"secure\" attribute and precisely scope the \"domain\" attribute on all security-sensitive cookies, such as session cookies. These settings tell the browser that the cookie should only be sent back to the specific host(s) (and not, e.g., all subdomains of a given domain), and should only be sent over HTTPS (not HTTP).",
      "ja": "既知のピンドホストによって設定されたHTTPクッキー[RFC6265]は、クライアントがホストの偽のサブドメインにクッキーを送信させるようにウェブやDNS応答を偽造することができ、ネットワーク攻撃者によって盗まれたことができます。これを防ぐために、ホストは、このようなセッションクッキーなど、すべてのセキュリティに敏感なクッキー、上の「安全な」属性と正確にスコープ「ドメイン」属性を設定する必要があります。これらの設定は、（例えば、特定のドメインのすべてのサブドメインをしていない）場合にのみクッキーが戻って特定のホスト（複数可）に送信されるように、ブラウザを教え、そして唯一のHTTPS（HTTPではなく）上で送信される必要があります。"
    },
    {
      "indent": 0,
      "text": "4.5. Hostile Pinning",
      "section_title": true,
      "ja": "4.5。敵対的ピンニング"
    },
    {
      "indent": 3,
      "text": "An attacker who is able to obtain a valid certificate for a domain, either through misissuance by a Certification Authority or through other means, such as being the prior owner of a given domain, may attempt to perform 'hostile' pinning. In this scenario, the attacker provides a Valid Pinning Header that pins to a set of SPKIs of the attacker's choice. If a UA has not previously noted pins for that host, it may note the attacker's pins, preventing access to the legitimate site.",
      "ja": "ドメインのための有効な証明書を得ることができる攻撃者が、いずれかの認証局によって、またはそのような特定のドメインの前所有者であるような他の手段を介してmisissuanceを通して、「敵対」ピニングを行うように試みることができます。このシナリオでは、攻撃者は、攻撃者が選択したSPKIsのセットにピン有効なピン留めヘッダーを提供します。 UAが以前にそのホストのためのピンを指摘していない場合、それは正当なサイトへのアクセスを防止し、攻撃者のピンに注意して。"
    },
    {
      "indent": 3,
      "text": "This attack is mitigated through several means. Most prominently, the attack can only persist for the maximum max-age (see Section 4.1). Web host operators can reduce the opportunity for",
      "ja": "この攻撃は、いくつかの手段によって軽減されます。最も顕著に、攻撃が唯一最大の最大エージングのために持続することができます（4.1節を参照してください）。ウェブホスト事業者は機会を減らすことができます"
    },
    {
      "indent": 3,
      "text": "attack by working to preload the host's pins within the UA. Operators may further detect such misissuance through other means, such as certificate transparency ([RFC6962]).",
      "ja": "UA内のホストのピンをプリロードする作業による攻撃。オペレータはさらに、そのような証明書の透明度（[RFC6962]）のような他の手段を介してそのようなmisissuanceを検出することができます。"
    },
    {
      "indent": 0,
      "text": "5. Privacy Considerations",
      "section_title": true,
      "ja": "5.個人情報保護に関する注意事項"
    },
    {
      "indent": 3,
      "text": "Hosts can use HSTS or HPKP as a \"super-cookie\", by setting distinct policies for a number of subdomains. For example, assume example.com wishes to track distinct UAs without explicitly setting a cookie, or that a previously set cookie is deleted from the UA's cookie store. Here are two attack scenarios.",
      "ja": "ホストは、サブドメインの数に対して明確なポリシーを設定することで、「スーパークッキー」としてHSTSまたはHPKPを使用することができます。たとえば、example.comは、Cookieを明示的に設定することなく、個別のユーザエージェントを追跡することを希望する、または以前に設定されたCookieは、UAのCookieストアから削除されていることを前提としています。ここでは、2つの攻撃のシナリオです。"
    },
    {
      "indent": 3,
      "text": "o example.com can use report-uri and the ability to pin arbitrary identifiers to distinguish UAs.",
      "ja": "O example.comが報告-URIとUASを区別するために、任意の識別子を固定する機能を使用することができます。"
    },
    {
      "indent": 6,
      "text": "1. example.com sets a Valid Pinning Header in its response to requests. The header asserts the includeSubDomains directive and specifies a report-uri directive as well. Pages served by the host also include references to subresource https://bad.example.com/foo.png.",
      "ja": "1. example.comが要求への応答に有効なピン留めヘッダーを設定します。ヘッダはincludeSubDomainsディレクティブをアサートし、同様に報告-URIディレクティブを指定します。ホストによって提供されるページもhttps://bad.example.com/foo.pngをサブリソースへの参照が含まれています。"
    },
    {
      "indent": 6,
      "text": "2. The Valid Pinning Header includes a \"pin\" that is not really the hash of an SPKI but is instead an arbitrary distinguishing string sent only in response to a particular request. For each request, the host creates a new, distinct distinguishing string and sets it as if it were a pin.",
      "ja": "2.有効なピンニングヘッダは実際SPKIのハッシュではなく、代わりに、特定の要求に応答して送信される任意の区別文字列である「ピン」を含みます。各要求に対して、ホストが新しい、別個の区別文字列を作成し、それはピンであるかのように設定します。"
    },
    {
      "indent": 6,
      "text": "3. The certificate chain served by bad.example.com does not pass Pin Validation given the pin set the host asserted in step (1). The HPKP-conforming UA attempts to report the Pin Validation failure to the specified report-uri, including the certificate chain it observed and the SPKI hashes it expected to see. Among the SPKI hashes is the distinguishing string in step (2).",
      "ja": "3. bad.example.comによってサービス証明書チェーンは、ホストは、ステップ（1）にアサートされたセットピン所与ピン検証に合格しませんでした。 HPKP準拠のUAは、指定されたレポート-URI、それが認められ、SPKIはそれが見に期待ハッシュ証明書チェーンを含めへピン検証失敗を報告しようとします。 SPKIハッシュうち、工程（2）で区別文字列です。"
    },
    {
      "indent": 3,
      "text": "o Different site operators/origins can optionally collaborate by setting the report-uri to be in an origin they share administrative control of. UAs MAY, therefore, refuse to send reports outside of the origin that set the PKP or PKP-RO header.",
      "ja": "O別のサイト運営者/起源は、必要に応じて、彼らはの管理制御を共有し、原点にあるようにレポート-URIを設定することにより、共同作業を行うことができます。 UA MAYは、それゆえ、PKPやPKP-ROヘッダーを設定起源の外にレポートを送信することを拒否します。"
    },
    {
      "indent": 3,
      "text": "o example.com can use server name indication (SNI; [RFC3546]) and subdomains to distinguish UAs.",
      "ja": "UASを区別するためのサブドメイン; O example.comは、サーバ名表示（[RFC3546] SNI）を使用することができます。"
    },
    {
      "indent": 6,
      "text": "1. example.com sets a Valid Pinning Header in its response to requests. The header asserts the includeSubDomains directive.",
      "ja": "1. example.comが要求への応答に有効なピン留めヘッダーを設定します。ヘッダはincludeSubDomainsディレクティブをアサートします。"
    },
    {
      "indent": 6,
      "text": "2. On a subsequent page view, the host responds with a page including the subresource https://0.fingerprint.example.com/ foo.png, and the server responds using a certificate chain that does not pass Pin Validation for the pin-set defined in the Valid Pinning Header in step (1). The HPKP-conforming UA will close the connection, never completing the request to 0.fingerprint.example.com. The host may thus note that this particular UA had noted the (good) Pins for that subdomain.",
      "ja": "後続のページビュー2.、ホストはサブリソースhttps://0.fingerprint.example.com/ foo.pngを含むページで応答し、サーバは、ピン・ピンの検証に合格しない証明書チェーンを使用して応答します-setステップで有効ピニングヘッダに定義された（1）。 HPKP準拠のUAは0.fingerprint.example.comにリクエストを完了することはありません、接続を閉じます。ホストは、このように、この特定のUAは、そのサブドメインの（良い）ピンを指摘していたことに気づくかもしれません。"
    },
    {
      "indent": 6,
      "text": "3. example.com can distinguish 2^N UAs by serving Valid Pinning Headers from an arbitrary number N distinct subdomains. For any given subdomain n.fingerprint.example.com, the host may deliver a Valid Pinning Header to one UA, but not deliver it to a different UA. The server may then change the configuration for n.fingerprint.example.com. If the UA fails to connect, it was in the set of UAs that were pinned, which can be distinguished from the UAs that were not pinned, as they will succeed in connecting. The host may repeat this for a sufficient number of subdomains necessary to distinguish individual UAs.",
      "ja": "3. example.comは、任意の数N個の別個のサブドメインから有効なピン止めヘッダにサービスを提供することにより、2 ^ NのUAを区別することができます。任意のサブドメインn.fingerprint.example.comの場合、ホストは1 UAに有効なピン留めヘッダーを配信してもよいが、異なるUAに配信していません。次に、サーバーはn.fingerprint.example.comの設定を変更することがあります。 UAが接続に失敗した場合、それは彼らが接続に成功すると、固定されていなかったのUAと区別することができ、固定されたのUAのセットにしました。ホストは、個々のUAを区別するために必要なサブドメインの十分な数のためにこれを繰り返すことができます。"
    },
    {
      "indent": 3,
      "text": "o Conforming implementations (as well as implementations conforming to [RFC6797]) must store state about which domains have set policies, hence which domains the UA has contacted. Because these policies cause remotely detectable behaviors, it is advisable that UAs have a way for privacy-sensitive users to clear current Pins for Pinned Hosts and that UAs allow users to query the current state of Pinned Hosts. In addition, note that because pinning a host implies a degree of persistent state, an attacker with physical access to a device may be able to recover information about hosts a user has visited, even if the user has cleared other parts of the UA's state.",
      "ja": "O実装（ならびに[RFC6797]に準拠した実装）に準拠するドメインは、UAが接触したドメイン従ってポリシーを設定しているかについての状態を保存しなければなりません。これらのポリシーは、遠隔検出行動を起こすので、UAは、プライバシーに敏感なユーザーがピンホストの現在のピンをクリアし、UAが、ユーザーがピンホストの現在の状態を照会することができ、そのための方法を持っていることをお勧めします。また、ホストを固定すると、永続状態の程度を意味するので、デバイスに物理的にアクセスできる攻撃者は、ユーザーがUAの状態の他の部分をクリアした場合でも、ユーザーが訪問したホストに関する情報を回復することができる可能性があることに注意。"
    },
    {
      "indent": 3,
      "text": "o Pin reports, as noted in Section 3, contains information about the certificate chain that has failed pin validation. In some cases, such as organization-wide compromise of the end-to-end security of TLS, this may include information about the interception tools and design used by the organization that the organization would otherwise prefer not be disclosed.",
      "ja": "Oピンは、第3節で述べたように、ピンの検証に失敗した証明書チェーンに関する情報が含まれ、報告します。こうしたTLSのエンドツーエンドのセキュリティの組織的な妥協案として、いくつかのケースでは、これは、組織がそうでない場合は開示されない希望組織が使用傍受ツールや設計に関する情報を含むことができます。"
    },
    {
      "indent": 0,
      "text": "6. IANA Considerations",
      "section_title": true,
      "ja": "6. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "IANA has registered the response headers described in this document under \"Permanent Message Header Field Names\" in the \"Message Headers\" registry [message-headers] with the following parameters:",
      "ja": "IANAは、以下のパラメータを「メッセージヘッダ」レジストリ[メッセージヘッダー]で「永続的メッセージヘッダーフィールド名」の下に、この文書に記載された応答ヘッダを登録しました。"
    },
    {
      "indent": 3,
      "text": "o Header Field Names: Public-Key-Pins and Public-Key-Pins-Report-Only",
      "ja": "Oヘッダーフィールド名：公開鍵ピンと公開鍵ピン・レポートのみ"
    },
    {
      "indent": 3,
      "text": "o Protocol: http",
      "ja": "Oプロトコル：HTTP"
    },
    {
      "indent": 3,
      "text": "o Status: standard",
      "ja": "Oステータス：標準"
    },
    {
      "indent": 3,
      "text": "o Reference: RFC 7469",
      "ja": "Oリファレンス：RFC 7469"
    },
    {
      "indent": 0,
      "text": "7. Usability Considerations",
      "section_title": true,
      "ja": "7.ユーザビリティに関する注意事項"
    },
    {
      "indent": 3,
      "text": "When pinning works to detect impostor Pinned Hosts, users will experience denial of service. It is advisable for UAs to explain the reason why, i.e., that it was impossible to verify the confirmed cryptographic identity of the host.",
      "ja": "詐欺師釘付けホストを検出するために作品をピン留めすると、ユーザーがサービス拒否が発生します。 UAが理由を説明することは、ホストの確認暗号身元を確認することは不可能だったこと、すなわち、賢明です。"
    },
    {
      "indent": 3,
      "text": "It is advisable that UAs have a way for users to clear current Pins for Pinned Hosts and that UAs allow users to query the current state of Pinned Hosts.",
      "ja": "UAは、ユーザーがピンでとめホストの現在のピンをクリアし、UAが、ユーザーがピンホストの現在の状態を照会することができ、そのための方法を持っていることをお勧めします。"
    },
    {
      "indent": 0,
      "text": "8. References",
      "section_title": true,
      "ja": "8.参照文献"
    },
    {
      "indent": 0,
      "text": "8.1. Normative References",
      "section_title": true,
      "ja": "8.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月、<http://www.rfc-editor.org/info/rfc2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC3339] Klyne, G. and C. Newman, \"Date and Time on the Internet: Timestamps\", RFC 3339, July 2002, <http://www.rfc-editor.org/info/rfc3339>.",
      "ja": "[RFC3339] Klyne、G.とC.ニューマン、 \"インターネット上の日付と時刻：タイムスタンプ\"、RFC 3339、2002年7月、<http://www.rfc-editor.org/info/rfc3339>。"
    },
    {
      "indent": 3,
      "text": "[RFC3986] Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform Resource Identifier (URI): Generic Syntax\", STD 66, RFC 3986, January 2005, <http://www.rfc-editor.org/info/rfc3986>.",
      "ja": "[RFC3986]バーナーズ - リー、T.、フィールディング、R.、およびL. Masinter、 \"ユニフォームリソース識別子（URI）：汎用構文\"、STD 66、RFC 3986、2005年1月<HTTP：//www.rfc- editor.org/info/rfc3986>。"
    },
    {
      "indent": 3,
      "text": "[RFC4648] Josefsson, S., \"The Base16, Base32, and Base64 Data Encodings\", RFC 4648, October 2006, <http://www.rfc-editor.org/info/rfc4648>.",
      "ja": "[RFC4648] Josefsson氏、S.、 \"Base16、Base32、およびBase64でデータエンコーディング\"、RFC 4648、2006年10月、<http://www.rfc-editor.org/info/rfc4648>。"
    },
    {
      "indent": 3,
      "text": "[RFC5234] Crocker, D., Ed. and P. Overell, \"Augmented BNF for Syntax Specifications: ABNF\", STD 68, RFC 5234, January 2008, <http://www.rfc-editor.org/info/rfc5234>.",
      "ja": "[RFC5234]クロッカー、D.、エド。そして、P. Overell、 \"構文仕様のための増大しているBNF：ABNF\"、STD 68、RFC 5234、2008年1月、<http://www.rfc-editor.org/info/rfc5234>。"
    },
    {
      "indent": 3,
      "text": "[RFC5246] Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS) Protocol Version 1.2\", RFC 5246, August 2008, <http://www.rfc-editor.org/info/rfc5246>.",
      "ja": "[RFC5246]ダークス、T.およびE.レスコラ、 \"トランスポート層セキュリティ（TLS）プロトコルバージョン1.2\"、RFC 5246、2008年8月、<http://www.rfc-editor.org/info/rfc5246>。"
    },
    {
      "indent": 3,
      "text": "[RFC5280] Cooper, D., Santesson, S., Farrell, S., Boeyen, S., Housley, R., and W. Polk, \"Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile\", RFC 5280, May 2008, <http://www.rfc-editor.org/info/rfc5280>.",
      "ja": "[RFC5280]クーパー、D.、Santesson、S.、ファレル、S.、Boeyen、S.、Housley氏、R.、およびW.ポーク、「インターネットX.509公開鍵暗号基盤証明書と証明書失効リスト（CRL）のプロフィール」、RFC 5280、2008年5月、<http://www.rfc-editor.org/info/rfc5280>。"
    },
    {
      "indent": 3,
      "text": "[RFC6234] Eastlake 3rd, D. and T. Hansen, \"US Secure Hash Algorithms (SHA and SHA-based HMAC and HKDF)\", RFC 6234, May 2011, <http://www.rfc-editor.org/info/rfc6234>.",
      "ja": "[RFC6234]イーストレーク第3、D.とT.ハンセン、 \"米国のセキュアハッシュアルゴリズム（SHAとHMACとHKDF SHAベース）\"、RFC 6234、2011年5月、<http://www.rfc-editor.org/info / rfc6234>。"
    },
    {
      "indent": 3,
      "text": "[RFC6265] Barth, A., \"HTTP State Management Mechanism\", RFC 6265, April 2011, <http://www.rfc-editor.org/info/rfc6265>.",
      "ja": "[RFC6265]バース、A.、 \"HTTP状態管理機構\"、RFC 6265、2011年4月、<http://www.rfc-editor.org/info/rfc6265>。"
    },
    {
      "indent": 3,
      "text": "[RFC6797] Hodges, J., Jackson, C., and A. Barth, \"HTTP Strict Transport Security (HSTS)\", RFC 6797, November 2012, <http://www.rfc-editor.org/info/rfc6797>.",
      "ja": "[RFC6797]ホッジス、J.、ジャクソン、C.、およびA.バース、 \"HTTP厳格なトランスポート・セキュリティ（HSTS）\"、RFC 6797、2012年11月、<http://www.rfc-editor.org/info/rfc6797 >。"
    },
    {
      "indent": 3,
      "text": "[RFC7159] Bray, T., Ed., \"The JavaScript Object Notation (JSON) Data Interchange Format\", RFC 7159, March 2014, <http://www.rfc-editor.org/info/rfc7159>.",
      "ja": "[RFC7159]ブレイ、T.、エド。、 \"JavaScriptのObject Notation（JSON）形式のデータ交換フォーマット\"、RFC 7159、2014年3月、<http://www.rfc-editor.org/info/rfc7159>。"
    },
    {
      "indent": 3,
      "text": "[RFC7230] Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing\", RFC 7230, June 2014, <http://www.rfc-editor.org/info/rfc7230>.",
      "ja": "[RFC7230]フィールディング、R.、エド。 。及びJ. Reschke、編、 \"ハイパーテキスト転送プロトコル（HTTP / 1.1）：メッセージの構文およびルーティング\"、RFC 7230、2014年6月、<http://www.rfc-editor.org/info/rfc7230>。"
    },
    {
      "indent": 3,
      "text": "[RFC7234] Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Caching\", RFC 7234, June 2014, <http://www.rfc-editor.org/info/rfc7234>.",
      "ja": "[RFC7234]フィールディング、R.、エド、ノッティンガム、M.、エド、及びJ. Reschke、編、 \"ハイパーテキスト転送プロトコル（HTTP / 1.1）：キャッシュ\"。。。、RFC 7234、2014年6月、<HTTP：/ /www.rfc-editor.org/info/rfc7234>。"
    },
    {
      "indent": 3,
      "text": "[RFC7468] Josefsson, S. and S. Leonard, \"Textual Encodings of PKIX, PKCS, and CMS Structures\", RFC 7468, April 2015, <http://www.rfc-editor.org/info/rfc7468>.",
      "ja": "[RFC7468] Josefsson氏、S.とS.レナード、 \"PKIX、PKCS、およびCMS構造のテキストエンコーディング\"、RFC 7468、2015年4月、<http://www.rfc-editor.org/info/rfc7468>。"
    },
    {
      "indent": 3,
      "text": "[W3C.REC-html401-19991224] Raggett, D., Hors, A., and I. Jacobs, \"HTML 4.01 Specification\", World Wide Web Consortium Recommendation REC-html401-19991224, December 1999, <http://www.w3.org/TR/1999/REC-html401-19991224>.",
      "ja": "[W3C.REC-html401-19991224] Raggett、D.、オードブル、A.、およびI.ジェイコブス、 \"HTML 4.01仕様書\"、World Wide Web Consortium（W3C）の勧告REC-html401-19991224、1999年12月、<のhttp：// WWW .w3.org / TR / 1999 / REC-html401-19991224>。"
    },
    {
      "indent": 3,
      "text": "[message-headers] IANA, \"Message Headers\", <http://www.iana.org/assignments/message-headers/>.",
      "ja": "[メッセージヘッダー] IANA、 \"メッセージヘッダ\"、<http://www.iana.org/assignments/message-headers/>。"
    },
    {
      "indent": 0,
      "text": "8.2. Informative References",
      "section_title": true,
      "ja": "8.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[RFC3546] Blake-Wilson, S., Nystrom, M., Hopwood, D., Mikkelsen, J., and T. Wright, \"Transport Layer Security (TLS) Extensions\", RFC 3546, June 2003, <http://www.rfc-editor.org/info/rfc3546>.",
      "ja": "[RFC3546]ブレイク・ウィルソン、S.、Nystrom、M.、ホップウッド、D.、ミケルセン、J.、およびT.ライト、 \"トランスポート層セキュリティ（TLS）拡張機能\"、RFC 3546、2003年6月、<のhttp：/ /www.rfc-editor.org/info/rfc3546>。"
    },
    {
      "indent": 3,
      "text": "[RFC6962] Laurie, B., Langley, A., and E. Kasper, \"Certificate Transparency\", RFC 6962, June 2013, <http://www.rfc-editor.org/info/rfc6962>.",
      "ja": "[RFC6962]ローリー、B.、ラングレー、A.、およびE.カスパー、 \"証明書の透明性\"、RFC 6962、2013年6月、<http://www.rfc-editor.org/info/rfc6962>。"
    },
    {
      "indent": 3,
      "text": "[TACK] Marlinspike, M., \"Trust Assertions for Certificate Keys\", Work in Progress, draft-perrin-tls-tack-02, January 2013.",
      "ja": "[TACK] Marlinspike氏、M.、 \"証明書の鍵のための信託アサーション\" が進行中で働いて、ドラフト・ペリン-TLS-タック-02、2013年1月。"
    },
    {
      "indent": 3,
      "text": "[why-pin-key] Langley, A., \"Public Key Pinning\", Imperial Violet: Adam Langley's Weblog, May 2011, <https://www.imperialviolet.org/2011/05/04/pinning.html>.",
      "ja": "[なぜピンキー]ラングレー、A.、「公開鍵確保」、インペリアルバイオレット：アダム・ラングレーのウェブログ、2011年5月、<https://www.imperialviolet.org/2011/05/04/pinning.html>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Fingerprint Generation",
      "ja": "付録A.指紋ジェネレーション"
    },
    {
      "indent": 3,
      "text": "This Portable Operating System Interface (POSIX) shell program generates SPKI Fingerprints, suitable for use in pinning, from PEM-encoded certificates. It is non-normative.",
      "ja": "このポータブルオペレーティングシステムインタフェース（POSIX）シェルプログラムは、PEMエンコードされた証明書から、ピン止めでの使用に適したSPKIフィンガープリントを生成します。これは、非規範的です。"
    },
    {
      "indent": 3,
      "text": "openssl x509 -noout -in certificate.pem -pubkey | \\ openssl asn1parse -noout -inform pem -out public.key openssl dgst -sha256 -binary public.key | openssl enc -base64",
      "ja": "opensslのX509 -noout -in certificate.pem -pubkey | \\ opensslのasn1parse -noout -inform PEM -outは、public.key opensslのDGST -sha256 -binaryは、public.key | opensslのENC -base64"
    },
    {
      "indent": 12,
      "text": "Figure 11: Example SPKI Fingerprint Generation Code",
      "ja": "図11：例SPKI指紋の生成コード"
    },
    {
      "indent": 0,
      "text": "Appendix B. Deployment Guidance",
      "ja": "付録B.展開のガイダンス"
    },
    {
      "indent": 3,
      "text": "This section is non-normative guidance that may smooth the adoption of public key pinning.",
      "ja": "このセクションでは、公開鍵ピニングの採用を滑らかにする非規範的指針です。"
    },
    {
      "indent": 3,
      "text": "o Operators should get the backup public key signed by a different (root and/or intermediary) CA than their primary certificate, and store the backup key pair safely offline. The semantics of an SPKI Fingerprint do not require the issuance of a certificate to construct a valid Pin. However, in many deployment scenarios, in order to make a Backup Pin operational, the server operator will need to have a certificate to deploy TLS on the host. Failure to obtain a certificate through prior arrangement will leave clients that recognize the site as a Known Pinned Host unable to successfully perform Pin Validation until such a time as the operator can obtain a new certificate from their desired certificate issuer.",
      "ja": "O演算子は、彼らの主要な証明書とは異なる（ルートおよび/または仲介）CAによって署名されたバックアップ公開鍵を取得し、安全にオフラインバックアップ鍵のペアを格納する必要があります。 SPKI指紋のセマンティクスは有効なPINを構築するために、証明書の発行を必要としません。しかし、多くの展開シナリオでは、バックアップピンを正常に動作させるためには、サーバーのオペレータは、ホスト上でTLSを展開するための証明書を持っている必要があります。事前の取り決めを通じて証明書を取得するために、失敗は成功し、オペレータがその目的の証明書発行者から新しい証明書を取得することができますような時間まで、ピンの検証を行うことができない既知釘付けホストとしてサイトを認識し、クライアントを残すだろう。"
    },
    {
      "indent": 3,
      "text": "o It is most economical to have the backup certificate signed by a completely different signature chain than the live certificate, to maximize recoverability in the event of compromise of either the root or intermediary signer.",
      "ja": "Oルートまたは中間の署名者のいずれかの侵害が発生した場合に回収可能性を最大化するために、生きた証明書よりも完全に異なる署名チェーンによって署名されたバックアップ証明書を持っていることが最も経済的です。"
    },
    {
      "indent": 3,
      "text": "o Operators should periodically exercise their Backup Pin plan -- an untested backup is no backup at all.",
      "ja": "O演算子は、定期的にバックアップピン計画を行使すべきである - 未テストのバックアップはまったくバックアップされません。"
    },
    {
      "indent": 3,
      "text": "o Operators should start small. Operators should first deploy public key pinning by using the report-only mode together with a report-uri directive that points to a reliable report collection endpoint. When moving out of report-only mode, operators should start by setting a max-age of minutes or a few hours and gradually increase max-age as they gain confidence in their operational capability.",
      "ja": "O演算子は、小さな開始する必要があります。演算子は、最初の信頼性の高いレポートコレクションエンドポイントを指しレポート-uriのディレクティブと一緒にレポートのみのモードを使用することにより、公開鍵ピニングを展開する必要があります。レポートのみのモードの外に移動した場合、事業者は数分または数時間の最大エージングを設定することによって開始する必要があり、彼らは彼らの運用能力に自信を得るように徐々に最大エージングを高めます。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Thanks to Tobias Gondrom, Jeff Hodges, Paul Hoffman, Ivan Krstic, Adam Langley, Barry Leiba, Nicolas Lidzborski, SM, James Manger, Yoav Nir, Trevor Perrin, Eric Rescorla, Pete Resnick, Tom Ritter, and Yan Zhu for suggestions and edits that clarified the text.",
      "ja": "提案や編集のためのトビアスGondrom、ジェフ・ホッジス、ポール・ホフマン、イヴァン・クルスティッチ、アダム・ラングレー、バリー・レイバ、ニコラスLidzborski、SM、ジェームス・マンジェ、ヨアフニール、トレバー・ペラン、エリックレスコラ、ピート・レズニック、トム・リッター、とヤン朱のおかげでそれは、テキストを明らかにしました。"
    },
    {
      "indent": 3,
      "text": "TACK [TACK] is a fruitful source of alternative design considerations.",
      "ja": "TACK [TACK】代替設計上の考慮事項の実り源です。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Chris Evans Google, Inc. 1600 Amphitheatre Pkwy Mountain View, CA 94043 United States",
      "ja": "クリス・エヴァンスグーグル株式会社1600アンフィシアターパークウェイマウンテンビュー、CA 94043米国"
    },
    {
      "indent": 3,
      "text": "EMail: cevans@google.com",
      "ja": "メールアドレス：cevans@google.com"
    },
    {
      "indent": 3,
      "text": "Chris Palmer Google, Inc. 1600 Amphitheatre Pkwy Mountain View, CA 94043 United States",
      "ja": "クリス・パーマーグーグル株式会社1600アンフィシアターパークウェイマウンテンビュー、CA 94043米国"
    },
    {
      "indent": 3,
      "text": "EMail: palmer@google.com",
      "ja": "メールアドレス：palmer@google.com"
    },
    {
      "indent": 3,
      "text": "Ryan Sleevi Google, Inc. 1600 Amphitheatre Pkwy Mountain View, CA 94043 United States",
      "ja": "ライアンSleeviグーグル株式会社1600アンフィシアターパークウェイマウンテンビュー、CA 94043米国"
    },
    {
      "indent": 3,
      "text": "EMail: sleevi@google.com",
      "ja": "メールアドレス：sleevi@google.com"
    }
  ]
}