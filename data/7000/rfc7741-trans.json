{
  "title": {
    "text": "RFC 7741 - RTP Payload Format for VP8 Video",
    "ja": "RFC 7741 - VP8ビデオのためのRTPペイロードフォーマット"
  },
  "number": 7741,
  "created_at": "2019-11-01 20:13:06.534395+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                         P. Westin\nRequest for Comments: 7741                                     H. Lundin\nCategory: Standards Track                                         Google\nISSN: 2070-1721                                                M. Glover\n                                                                 Twitter\n                                                               J. Uberti\n                                                             F. Galligan\n                                                                  Google\n                                                              March 2016",
      "raw": true
    },
    {
      "indent": 20,
      "text": "RTP Payload Format for VP8 Video",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This memo describes an RTP payload format for the VP8 video codec. The payload format has wide applicability, as it supports applications from low-bitrate peer-to-peer usage to high-bitrate video conferences.",
      "ja": "このメモはVP8ビデオコーデックのためのRTPペイロード形式について説明します。それは、高ビットレートのビデオ会議に低ビットレートのピア・ツー・ピアの使用からアプリケーションをサポートしているとして、ペイロードフォーマットは、広い適用性を有します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 5741のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7741.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7741で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2016 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2016 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................3\n2. Conventions, Definitions, and Abbreviations .....................3\n3. Media Format Description ........................................4\n4. Payload Format ..................................................5\n   4.1. RTP Header Usage ...........................................6\n   4.2. VP8 Payload Descriptor .....................................7\n   4.3. VP8 Payload Header ........................................11\n   4.4. Aggregated and Fragmented Payloads ........................12\n   4.5. Example Algorithms ........................................13\n        4.5.1. Frame Reconstruction Algorithm .....................13\n        4.5.2. Partition Reconstruction Algorithm .................13\n   4.6. Examples of VP8 RTP Stream ................................14\n        4.6.1. Key Frame in a Single RTP Packet ...................14\n        4.6.2. Non-discardable VP8 Interframe in a Single\n               RTP Packet; No PictureID ...........................14\n        4.6.3. VP8 Partitions in Separate RTP Packets .............15\n        4.6.4. VP8 Frame Fragmented across RTP Packets ............16\n        4.6.5. VP8 Frame with Long PictureID ......................18\n5. Using VP8 with RPSI and SLI Feedback ...........................18\n   5.1. RPSI ......................................................18\n   5.2. SLI .......................................................19\n   5.3. Example ...................................................19\n6. Payload Format Parameters ......................................21\n   6.1. Media Type Definition .....................................21\n   6.2. SDP Parameters ............................................23\n        6.2.1. Mapping of Media Subtype Parameters to SDP .........23\n        6.2.2. Offer/Answer Considerations ........................23\n7. Security Considerations ........................................24\n8. Congestion Control .............................................24\n9. IANA Considerations ............................................24\n10. References ....................................................25\n   10.1. Normative References .....................................25\n   10.2. Informative References ...................................26\nAuthors' Addresses ................................................28",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "This memo describes an RTP payload specification applicable to the transmission of video streams encoded using the VP8 video codec [RFC6386]. The format described in this document can be used both in peer-to-peer and video-conferencing applications.",
      "ja": "このメモはVP8ビデオコーデック[RFC6386]を使用して符号化されたビデオストリームの伝送に適用可能なRTPペイロード仕様を記載しています。本書で記述されたフォーマットは、ピア・ツー・ピアおよびビデオ会議アプリケーションの両方を使用することができます。"
    },
    {
      "indent": 3,
      "text": "VP8 is based on the decomposition of frames into square sub-blocks of pixels known as \"macroblocks\" (see Section 2 of [RFC6386]). Prediction of such sub-blocks using previously constructed blocks, and adjustment of such predictions (as well as synthesis of unpredicted blocks) is done using a discrete cosine transform (hereafter abbreviated as DCT). In one special case, however, VP8 uses a \"Walsh-Hadamard\" transform (hereafter abbreviated as WHT) instead of a DCT. An encoded VP8 frame is divided into two or more partitions, as described in [RFC6386]. The first partition (prediction or mode) contains prediction mode parameters and motion vectors for all macroblocks. The remaining partitions all contain the quantized DCT/WHT coefficients for the residuals. There can be 1, 2, 4, or 8 DCT/WHT partitions per frame, depending on encoder settings.",
      "ja": "VP8は、（[RFC6386]のセクション2を参照）、「マクロブロック」として知られている画素の正方形のサブブロックへのフレームの分解に基づいています。以前に構築ブロック、及びそのような予測の調整を使用して、このようなサブブロックの予測（ならびに予測されないブロックの合成）（以下、DCTと略す）離散コサイン変換を使用して行われます。 1特殊なケースでは、しかし、VP8（以下WHTと略す）「ウォルシュ - アダマール」変換の代わりに、DCTを使用します。 [RFC6386]で説明されるように符号化されたVP8フレームは、二つ以上のパーティションに分割されています。最初のパーティション（又は予測モード）は、すべてのマクロブロックに対する予測モードパラメータおよび動きベクトルを含みます。残りのパーティションはすべて、残差のために、量子化DCT / WHT係数が含まれています。エンコーダの設定に応じて、フレーム当たり1、2、4、または8 DCT / WHTパーティションが存在することができます。"
    },
    {
      "indent": 3,
      "text": "In summary, the payload format described in this document enables a number of features in VP8, including:",
      "ja": "要約すると、この文書に記載されたペイロードフォーマットはVP8、などの機能の数を可能にします。"
    },
    {
      "indent": 3,
      "text": "o Taking partition boundaries into consideration, to improve loss robustness and facilitate efficient packet-loss concealment at the decoder.",
      "ja": "考慮パーティション境界をとるO、損失耐性を改善し、デコーダで効率的なパケット損失隠蔽を容易にします。"
    },
    {
      "indent": 3,
      "text": "o Temporal scalability.",
      "ja": "O時間スケーラビリティ。"
    },
    {
      "indent": 3,
      "text": "o Advanced use of reference frames to enable efficient error recovery.",
      "ja": "効率的なエラーリカバリを可能にするための参照フレームのOアドバンスト使用。"
    },
    {
      "indent": 3,
      "text": "o Marking of frames that have no impact on the decoding of any other frame, so that these non-reference frames can be discarded in a server or media-aware network element if needed.",
      "ja": "O必要に応じて、これらの非参照フレームがサーバまたはメディアアウェアネットワーク要素で廃棄することができるように、任意の他のフレームの復号に影響を与えないフレームのマーキング。"
    },
    {
      "indent": 0,
      "text": "2. Conventions, Definitions, and Abbreviations",
      "section_title": true,
      "ja": "2.規則、定義、および略語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はあります[RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 3,
      "text": "This document uses the definitions of [RFC6386]. In particular, the following terms are used.",
      "ja": "この文書では、[RFC6386]の定義を使用しています。具体的には、以下の用語が使用されています。"
    },
    {
      "indent": 3,
      "text": "Key frames: Frames that are decoded without reference to any other frame in a sequence (also called intraframes and I-frames).",
      "ja": "キーフレーム：シーケンス内の他のフレームを参照せずに復号化されるフレーム（また、イントラフレームとIフレームと呼ばれます）。"
    },
    {
      "indent": 3,
      "text": "Interframes: Frames that are encoded with reference to prior frames, specifically all prior frames up to and including the most recent key frame (also called prediction frames and P-frames).",
      "ja": "インター：前のフレームを参照して符号化されるフレーム、および最新のキーフレーム（別名予測フレームとPフレーム）を含むアップ具体すべての前フレーム。"
    },
    {
      "indent": 3,
      "text": "Golden and altref frames: alternate prediction frames. Blocks in an interframe may be predicted using blocks in the immediately previous frame as well as the most recent golden frame or altref frame. Every key frame is automatically golden and altref, and any interframe may optionally replace the most recent golden or altref frame.",
      "ja": "ゴールデンaltrefフレーム：代替予測フレーム。インター内のブロックは、直前のフレームだけでなく、最新の金色のフレームまたはaltrefフレーム内のブロックを用いて予測することができます。すべてのキーフレームが自動的に黄金とaltrefあり、そして任意のインターは、必要に応じて最新の黄金やaltrefフレームを交換することができます。"
    },
    {
      "indent": 3,
      "text": "Macroblock: a square array of pixels whose Y (luminance) dimensions are 16x16 pixels and whose U and V (chrominance) dimensions are 8x8 pixels.",
      "ja": "マクロ：Y（輝度）の寸法16×16画素であり、U及びV（色差）の寸法8×8画素である画素の正方形アレイ。"
    },
    {
      "indent": 3,
      "text": "Two definitions from [RFC4585] are also used in this document.",
      "ja": "[RFC4585]からの二つの定義もこの文書で使用されています。"
    },
    {
      "indent": 3,
      "text": "RPSI: Reference picture selection indication. A feedback message to let the encoder know that the decoder has correctly decoded a certain frame.",
      "ja": "RPSI：参照画像選択指示。フィードバック・メッセージは、エンコーダは、デコーダが正しく特定のフレームを復号したことを知らせることができます。"
    },
    {
      "indent": 3,
      "text": "SLI: Slice loss indication. A feedback message to let a decoder inform an encoder that it has detected the loss or corruption of one or several macroblocks.",
      "ja": "SLI：スライス損失兆候。フィードバック・メッセージは、デコーダは、それが1個のまたはいくつかのマクロブロックの損失または破損を検出したエンコーダに知らせるようにします。"
    },
    {
      "indent": 0,
      "text": "3. Media Format Description",
      "section_title": true,
      "ja": "3. Media形式の説明"
    },
    {
      "indent": 3,
      "text": "The VP8 codec uses three different reference frames for interframe prediction: the previous frame, the golden frame, and the altref frame. Blocks in an interframe may be predicted using blocks in the immediately previous frame as well as the most recent golden frame or altref frame. Every key frame is automatically golden and altref, and any interframe may optionally replace the most recent golden or altref frame. Golden frames and altref frames may also be used to increase the tolerance to dropped frames. The payload specification in this memo has elements that enable advanced use of the reference frames, e.g., for improved loss robustness.",
      "ja": "前フレーム、ゴールデンフレーム、及びaltrefフレーム：VP8コーデックは、フレーム間予測のための3つの異なる参照フレームを使用します。インター内のブロックは、直前のフレームだけでなく、最新の金色のフレームまたはaltrefフレーム内のブロックを用いて予測することができます。すべてのキーフレームが自動的に黄金とaltrefあり、そして任意のインターは、必要に応じて最新の黄金やaltrefフレームを交換することができます。金色のフレームとaltrefフレームはまた、フレーム落ちに対する耐性を増加させるために使用されてもよいです。このメモでペイロード仕様は、改良された損失耐性のために、例えば参照フレームの高度な使用を、有効要素を有します。"
    },
    {
      "indent": 3,
      "text": "One specific use case of the three reference frame types is temporal scalability. By setting up the reference hierarchy in the appropriate way, up to five temporal layers can be encoded. (How to set up the reference hierarchy for temporal scalability is not within the scope of this memo.) Support for temporal scalability is provided by the optional TL0PICIDX and TID/Y/KEYIDX fields described in Section 4.2. For a general description of temporal scalability for video coding, see [Sch07].",
      "ja": "3つの基準フレームタイプの一つの特定のユースケースは、時間的スケーラビリティです。 5時間レイヤまで、適切な方法で参照階層を設定することによって符号化することができます。 （時間スケーラビリティは、このメモの範囲内ではないためにどのように参照階層を設定する。）時間的スケーラビリティのサポートはオプションTL0PICIDX、セクション4.2で説明TID / Y / KEYIDXフィールドによって提供されます。ビデオ符号化のための時間的スケーラビリティの一般的な説明については、[Sch07]参照。"
    },
    {
      "indent": 3,
      "text": "Another property of the VP8 codec is that it applies data partitioning to the encoded data. Thus, an encoded VP8 frame can be divided into two or more partitions, as described in \"VP8 Data Format and Decoding Guide\" [RFC6386]. The first partition (prediction or mode) contains prediction mode parameters and motion vectors for all macroblocks. The remaining partitions all contain the transform coefficients for the residuals. The first partition is decodable without the remaining residual partitions. The subsequent partitions may be useful even if some part of the frame is lost. Accordingly, this document RECOMMENDS that the frame be packetized by the sender with each data partition in a separate packet or packets. This may be beneficial for decoder-side error concealment, and the payload format described in Section 4 provides fields that allow the partitions to be identified even if the first partition is not available. The sender can, alternatively, aggregate the data partitions into a single data stream and, optionally, split it into several packets without consideration of the partition boundaries. The receiver can use the length information in the first partition to identify the partitions during decoding.",
      "ja": "VP8コーデックの別の特性は、符号化されたデータにデータパーティショニングを適用することです。 「VP8データフォーマットおよび復号化ガイド」[RFC6386]で説明したように、符号化されたVP8フレームは、二つ以上のパーティションに分割することができます。最初のパーティション（又は予測モード）は、すべてのマクロブロックに対する予測モードパラメータおよび動きベクトルを含みます。残りのパーティションはすべて、残差のための変換係数を含んでいます。最初のパーティションは、残りの残余のパーティションなしで復号可能です。その後のパーティションは、フレームの一部が失われても有用である可能性があります。したがって、この文書は、フレームが別々のパケット又はパケット内の各データ・パーティションに送信者がパケット化することをお勧めします。これは、デコーダ側のエラー隠蔽のために有益であり得る、及びセクション4で説明ペイロードフォーマットはパーティションが最初のパーティションが利用できない場合であっても識別することを可能にするフィールドを提供します。送信者は、代わりに、単一のデータストリームにデータパーティションを集約し、必要に応じて、パーティション境界を考慮せずにいくつかのパケットに分割することができます。受信機は、復号中のパーティションを識別するために、最初のパーティションの長さ情報を使用することができます。"
    },
    {
      "indent": 3,
      "text": "The format specification is described in Section 4. In Section 5, a method to acknowledge receipt of reference frames using RTCP techniques is described.",
      "ja": "フォーマット仕様はセクション5セクション4に記載されている、RTCP技術を使用して参照フレームの受信を確認するための方法が記載されています。"
    },
    {
      "indent": 3,
      "text": "The payload partitioning and the acknowledging method both serve as motivation for three of the fields included in the payload format: the \"PID\", \"1st partition size\", and \"PictureID\" fields. The ability to encode a temporally scalable stream motivates the \"TL0PICIDX\" and \"TID\" fields.",
      "ja": "ペイロード・パーティションと認める方法は、フィールドの三ための動機として働く両方ペイロードフォーマットに含まれる：「PID」、「第1パーティションサイズ」、および「PictureID」フィールド。時間的にスケーラブルなストリームをエンコードする機能は、「TL0PICIDX」と「TID」フィールドに動機を与えます。"
    },
    {
      "indent": 0,
      "text": "4. Payload Format",
      "section_title": true,
      "ja": "4.ペイロードフォーマット"
    },
    {
      "indent": 3,
      "text": "This section describes how the encoded VP8 bitstream is encapsulated in RTP. To handle network losses, usage of RTP/AVPF [RFC4585] is RECOMMENDED. All integer fields in the specifications are encoded as unsigned integers in network octet order.",
      "ja": "このセクションでは、エンコードされたVP8ビットストリームは、RTPにカプセル化される方法を説明します。ネットワークの損失を処理するために、RTP / AVPF [RFC4585]の使用が推奨されます。仕様のすべての整数フィールドは、ネットワークオクテット順に符号なし整数としてエンコードされています。"
    },
    {
      "indent": 0,
      "text": "4.1. RTP Header Usage",
      "section_title": true,
      "ja": "4.1.  RTPヘッダーの使用"
    },
    {
      "indent": 3,
      "text": "The general RTP payload format for VP8 is depicted below.",
      "ja": "VP8のための一般的なRTPペイロードフォーマットを以下に示されています。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|V=2|P|X|  CC   |M|     PT      |       sequence number         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                           timestamp                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|           synchronization source (SSRC) identifier            |\n+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+\n|            contributing source (CSRC) identifiers             |\n|                             ....                              |\n+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+\n|            VP8 payload descriptor (integer #octets)           |\n:                                                               :\n|                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                               : VP8 payload header (3 octets) |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| VP8 pyld hdr  :                                               |\n+-+-+-+-+-+-+-+-+                                               |\n:                   Octets 4..N of VP8 payload                  :\n|                                                               |\n|                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                               :    OPTIONAL RTP padding       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The VP8 payload descriptor and VP8 payload header will be described in Sections 4.2 and 4.3. OPTIONAL RTP padding MUST NOT be included unless the P bit is set. The figure specifically shows the format for the first packet in a frame. Subsequent packets will not contain the VP8 payload header and will have later octets in the frame payload.",
      "ja": "VP8ペイロード記述及びVP8ペイロードヘッダは、セクション4.2および4.3に記載されます。 Pビットがセットされていない限り、オプションRTPパディングを含んではいけません。図は、具体的には、フレーム内の最初のパケットのフォーマットを示します。後続のパケットは、VP8ペイロードヘッダが含まれていないし、フレームペイロードの後のオクテットを有するであろう。"
    },
    {
      "indent": 33,
      "text": "Figure 1",
      "ja": "図1"
    },
    {
      "indent": 3,
      "text": "Marker bit (M): MUST be set for the very last packet of each encoded frame in line with the normal use of the M bit in video formats. This enables a decoder to finish decoding the picture, where it otherwise may need to wait for the next packet to explicitly know that the frame is complete.",
      "ja": "マーカービット（M）：ビデオフォーマットでMビットの通常の使用に合わせてそれぞれの符号化されたフレームの最後のパケットに設定されなければなりません。これは、そうでない場合は、明示的にフレームが完了したことを知っている次のパケットを待つ必要があるかもしれない画像を、デコード終了するデコーダを可能にします。"
    },
    {
      "indent": 3,
      "text": "Payload type (PT): The assignment of an RTP payload type for this packet format is outside the scope of this document and will not be specified here.",
      "ja": "ペイロードタイプ（PT）：このパケットフォーマットのためのRTPペイロードタイプの割り当ては、この文書の範囲外であり、ここで指定されません。"
    },
    {
      "indent": 3,
      "text": "Timestamp: The RTP timestamp indicates the time when the frame was sampled. The granularity of the clock is 90 kHz, so a delta of 1 represents 1/90,000 of a second.",
      "ja": "タイムスタンプ：RTPタイムスタンプは、フレームをサンプリングした時間を示します。クロックの精度は90 kHzであるので、1のデルタは、第二の1 / 90,000を表します。"
    },
    {
      "indent": 6,
      "text": "The remaining RTP Fixed Header Fields (V, P, X, CC, sequence number, SSRC, and CSRC identifiers) are used as specified in Section 5.1 of [RFC3550].",
      "ja": "[RFC3550]のセクション5.1で指定されるようにヘッダフィールド（V、P、X、CC、シーケンス番号、SSRC、およびCSRC識別子）固定されたままRTPが使用されます。"
    },
    {
      "indent": 0,
      "text": "4.2. VP8 Payload Descriptor",
      "section_title": true,
      "ja": "4.2.  VP8ペイロード記述子"
    },
    {
      "indent": 3,
      "text": "The first octets after the RTP header are the VP8 payload descriptor, with the following structure. The single-octet version of the PictureID is illustrated to the left (M bit set to 0), while the dual-octet version (M bit set to 1) is shown to the right.",
      "ja": "RTPヘッダの後の最初のオクテットは、以下の構造を有する、VP8ペイロード記述されています。デュアルオクテットバージョン（Mビットが1に設定）しながらPictureIDの単一オクテットのバージョンは、（Mビット0に設定）左側に示されている右側に示されています。"
    },
    {
      "indent": 3,
      "text": "      0 1 2 3 4 5 6 7                      0 1 2 3 4 5 6 7\n     +-+-+-+-+-+-+-+-+                   +-+-+-+-+-+-+-+-+\n     |X|R|N|S|R| PID | (REQUIRED)        |X|R|N|S|R| PID | (REQUIRED)\n     +-+-+-+-+-+-+-+-+                   +-+-+-+-+-+-+-+-+\nX:   |I|L|T|K| RSV   | (OPTIONAL)   X:   |I|L|T|K| RSV   | (OPTIONAL)\n     +-+-+-+-+-+-+-+-+                   +-+-+-+-+-+-+-+-+\nI:   |M| PictureID   | (OPTIONAL)   I:   |M| PictureID   | (OPTIONAL)\n     +-+-+-+-+-+-+-+-+                   +-+-+-+-+-+-+-+-+\nL:   |   TL0PICIDX   | (OPTIONAL)        |   PictureID   |\n     +-+-+-+-+-+-+-+-+                   +-+-+-+-+-+-+-+-+\nT/K: |TID|Y| KEYIDX  | (OPTIONAL)   L:   |   TL0PICIDX   | (OPTIONAL)\n     +-+-+-+-+-+-+-+-+                   +-+-+-+-+-+-+-+-+\n                                    T/K: |TID|Y| KEYIDX  | (OPTIONAL)\n                                         +-+-+-+-+-+-+-+-+\n                              Figure 2",
      "raw": true
    },
    {
      "indent": 3,
      "text": "X: Extended control bits present. When set to 1, the extension octet MUST be provided immediately after the mandatory first octet. If the bit is zero, all optional fields MUST be omitted. Note: this X bit is not to be confused with the X bit in the RTP header.",
      "ja": "X：拡張制御ビット存在します。 1に設定すると、拡張オクテットは、必須の最初のオクテットの直後に提供しなければなりません。ビットがゼロの場合、すべてのオプションフィールドを省略しなければなりません。注：このXビットは、RTPヘッダ内のXビットと混同されるべきではありません。"
    },
    {
      "indent": 3,
      "text": "R: Bit reserved for future use. MUST be set to 0 and MUST be ignored by the receiver.",
      "ja": "R：ビットは将来の使用のために予約。 0に設定しなければならなくて、受信機で無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "N: Non-reference frame. When set to 1, the frame can be discarded without affecting any other future or past frames. If the reference status of the frame is unknown, this bit SHOULD be set to 0 to avoid discarding frames needed for reference.",
      "ja": "N：非基準フレーム。 1に設定すると、フレームは、他の未来や過去のフレームに影響を与えずに破棄することができます。フレームの参照状況が不明の場合、このビットは、参考のために必要なフレームの廃棄を避けるために0に設定する必要があります。"
    },
    {
      "indent": 9,
      "text": "Informative note: This document does not describe how to\ndetermine if an encoded frame is non-reference.  The reference\nstatus of an encoded frame is preferably provided from the\nencoder implementation.",
      "raw": true
    },
    {
      "indent": 3,
      "text": "S: Start of VP8 partition. SHOULD be set to 1 when the first payload octet of the RTP packet is the beginning of a new VP8 partition, and MUST NOT be 1 otherwise. The S bit MUST be set to 1 for the first packet of each encoded frame.",
      "ja": "S：VP8パーティションのスタート。 RTPパケットの最初のペイロードのオクテットが新しいVP8パーティションの始まりで、それ以外の場合は1であってはなりません時に1に設定する必要があります。 Sビットは、各符号化フレームの最初のパケットのために1に設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "PID: Partition index. Denotes to which VP8 partition the first payload octet of the packet belongs. The first VP8 partition (containing modes and motion vectors) MUST be labeled with PID = 0. PID SHOULD be incremented by 1 for each subsequent partition, but it MAY be kept at 0 for all packets. PID cannot be larger than 7. If more than one packet in an encoded frame contains the same PID, the S bit MUST NOT be set for any packet other than the first packet with that PID.",
      "ja": "PID：パーティションのインデックス。意味パケットの最初のペイロードのオクテットが属するVP8パーティション。 PID = 0 PIDでラベル付けされなければならない（モードおよび動きベクトルを含む）第VP8パーティションは、後続の各パーティションについて1ずつインクリメントされるべきであり、それはすべてのパケットを0に維持することができます。符号化されたフレーム内の複数のパケットは、同じPIDが含まれている場合、PIDは7よりも大きくすることができない、SビットがそのPIDを持つ最初のパケット以外のパケットに設定してはいけません。"
    },
    {
      "indent": 3,
      "text": "When the X bit is set to 1 in the first octet, the Extended Control Bits field octet MUST be provided as the second octet. If the X bit is 0, the Extended Control Bits field octet MUST NOT be present, and no extensions (I, L, T, or K) are permitted.",
      "ja": "Xビットが最初のオクテットに1に設定されている場合、拡張制御ビットフィールドのオクテットが第2オクテットとして提供されなければなりません。 Xビットが0である場合、拡張制御ビットフィールドのオクテットが存在してはならない、と全く拡張（I、L、T、またはK）が許可されていません。"
    },
    {
      "indent": 3,
      "text": "I: PictureID present. When set to 1, the PictureID MUST be present after the extension bit field and specified as below. Otherwise, PictureID MUST NOT be present.",
      "ja": "I：PictureID存在。 1に設定すると、PictureIDは、拡張ビットフィールドの後に存在し、以下のように指定しなければなりません。それ以外の場合は、PictureIDは存在してはなりません。"
    },
    {
      "indent": 3,
      "text": "L: TL0PICIDX present. When set to 1, the TL0PICIDX MUST be present and specified as below, and the T bit MUST be set to 1. Otherwise, TL0PICIDX MUST NOT be present.",
      "ja": "L：TL0PICIDX存在。 1に設定すると、TL0PICIDXは以下のように存在し、指定する必要があり、そしてTビットはそうでなければ1に設定しなければなりません、TL0PICIDXは存在してはなりません。"
    },
    {
      "indent": 3,
      "text": "T: TID present. When set to 1, the TID/Y/KEYIDX octet MUST be present. The TID|Y part of the octet MUST be specified as below. If K (below) is set to 1 but T is set to 0, the TID/Y/KEYIDX octet MUST be present, but the TID field MUST be ignored. If neither T nor K is set to 1, the TID/Y/KEYIDX octet MUST NOT be present.",
      "ja": "T：TIDの存在。 1に設定すると、TID / Y / KEYIDXオクテットが存在しなければなりません。 TID |オクテットのY部分は、以下のように指定しなければなりません。 Kは（下記）1に設定されているが、Tが0に設定されている場合、TID / Y / KEYIDXオクテットが存在しなければならないが、TIDフィールドは無視しなければなりません。いずれもT Kが1に設定されている場合、TID / Y / KEYIDXオクテットが存在してはなりません。"
    },
    {
      "indent": 3,
      "text": "K: KEYIDX present. When set to 1, the TID/Y/KEYIDX octet MUST be present. The KEYIDX part of the octet MUST be specified as below. If T (above) is set to 1 but K is set to 0, the TID/Y/KEYIDX octet MUST be present, but the KEYIDX field MUST be ignored. If neither T nor K is set to 1, the TID/Y/KEYIDX octet MUST NOT be present.",
      "ja": "K：KEYIDX存在。 1に設定すると、TID / Y / KEYIDXオクテットが存在しなければなりません。オクテットのKEYIDX部分は、以下のように指定しなければなりません。 Tは、（上記）1に設定されているが、Kが0に設定されている場合、TID / Y / KEYIDXオクテットが存在しなければならないが、KEYIDXフィールドは無視しなければなりません。いずれもT Kが1に設定されている場合、TID / Y / KEYIDXオクテットが存在してはなりません。"
    },
    {
      "indent": 3,
      "text": "RSV: Bits reserved for future use. MUST be set to 0 and MUST be ignored by the receiver.",
      "ja": "RSV：ビットは将来の使用のために予約。 0に設定しなければならなくて、受信機で無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "After the extension bit field follow the extension data fields that are enabled.",
      "ja": "拡張ビットフィールドの後有効になっている拡張データフィールドに従ってください。"
    },
    {
      "indent": 3,
      "text": "The PictureID extension: If the I bit is set to 1, the PictureID extension field MUST be present, and it MUST NOT be present otherwise. The field consists of two parts:",
      "ja": "PictureID拡張：Iビットが1に設定されている場合は、PictureID拡張フィールドが存在しなければならない、そしてそれはそうあってはなりません。フィールドには、2つの部分から成ります："
    },
    {
      "indent": 6,
      "text": "M: The most significant bit of the first octet is an extension flag. If M is set, the remainder of the PictureID field MUST contain 15 bits, else it MUST contain 7 bits. Note: this M bit is not to be confused with the M bit in the RTP header.",
      "ja": "M：最初のオクテットの最上位ビットは拡張フラグです。 Mが設定されている場合、PictureIDフィールドの残りの部分は、それが7ビットを含まなければならない、そうでなければ15ビットを含まなければなりません。注：このMビットはRTPヘッダ内のMビットと混同されるべきではありません。"
    },
    {
      "indent": 6,
      "text": "PictureID: 7 or 15 bits (shown left and right, respectively, in Figure 2) not including the M bit. This is a running index of the frames, which MAY start at a random value, MUST increase by 1 for each subsequent frame, and MUST wrap to 0 after reaching the maximum ID (all bits set). The 7 or 15 bits of the PictureID go from most significant to least significant, beginning with the first bit after the M bit. The sender chooses a 7- or 15-bit index and sets the M bit accordingly. The receiver MUST NOT assume that the number of bits in PictureID stays the same through the session. Having sent a 7-bit PictureID with all bits set to 1, the sender may either wrap the PictureID to 0 or extend to 15 bits and continue incrementing.",
      "ja": "PictureID：7または15ビット（図示せ、図2に、それぞれ、左および右）のMビットを含みません。これは、ランダムな値で開始することができるフレームのランニングインデックスであり、後続の各フレームに対して1だけ増やす必要があり、最大IDを（全ビットが設定される）に達した後に0にラップする必要があります。 PictureIDの7つのまたは15ビットはMビットの後最初のビットで始まり、最上位から最下位の行きます。送信者は、7または15ビットのインデックスを選択し、それに応じてMビットをセットします。受信機はPictureIDのビット数がセッションを通じて同じままと仮定してはいけません。 1に設定されたすべてのビットを7ビットPictureIDを送信した、送信側は0にPictureIDをラップまたは15ビットに拡張し、インクリメントし続けることができるいずれか。"
    },
    {
      "indent": 3,
      "text": "The TL0PICIDX extension: If the L bit is set to 1, the TL0PICIDX extension field MUST be present, and it MUST NOT be present otherwise. The field consists of one part:",
      "ja": "TL0PICIDX延長：Lビットが1に設定されている場合は、TL0PICIDX拡張フィールドが存在しなければならない、そしてそれはそうあってはなりません。フィールドには、一つの部分で構成されています。"
    },
    {
      "indent": 6,
      "text": "TL0PICIDX: 8 bits temporal level zero index. TL0PICIDX is a running index for the temporal base layer frames, i.e., the frames with TID set to 0. If TID is larger than 0, TL0PICIDX indicates on which base-layer frame the current image depends. TL0PICIDX MUST be incremented when TID is 0. The index MAY start at a random value, and it MUST wrap to 0 after reaching the maximum number 255. Use of TL0PICIDX depends on the presence of TID. Therefore, it is RECOMMENDED that the TID be used whenever TL0PICIDX is.",
      "ja": "TL0PICIDX：8ビット時間レベルゼロインデックス。 TL0PICIDXは、時間ベースレイヤフレームのランニングインデックス、すなわち、TIDが0より大きい場合は0に設定TIDを持つフレームは、TL0PICIDX現在の画像が依存するベースレイヤフレーム上に示しています。 TIDが0インデックスはランダムな値で開始することができ、そしてそれはTL0PICIDXの最大数255を使用するが、TIDの存在に依存して到達した後に0にラップする必要がありますときTL0PICIDXが増加しなければなりません。したがって、TL0PICIDXがあるときはいつでもTIDを使用することが推奨されます。"
    },
    {
      "indent": 3,
      "text": "The TID/Y/KEYIDX extension: If either of the T or K bits are set to 1, the TID/Y/KEYIDX extension field MUST be present. It MUST NOT be present if both T and K are zero. The field consists of three parts:",
      "ja": "TID / Y / KEYIDX拡張：TまたはKビットのいずれかが1に設定されている場合、TID / Y / KEYIDX拡張フィールドが存在しなければなりません。 TとKの両方がゼロである場合には存在してはなりません。フィールドは、3つの部分から構成されています。"
    },
    {
      "indent": 6,
      "text": "TID: 2 bits temporal-layer index. The TID field MUST be ignored by the receiver when the T bit is set equal to 0. The TID field indicates which temporal layer the packet represents.",
      "ja": "TID：2ビットの時間レイヤインデックス。 Tビットが0に等しくセットTIDフィールドは、パケットが表す時間的な層を示しているときにTIDフィールドは受信機によって無視されなければなりません。"
    },
    {
      "indent": 9,
      "text": "The lowest layer, i.e., the base layer, MUST have the TID set to 0. Higher layers SHOULD increment the TID according to their position in the layer hierarchy.",
      "ja": "最下層には、即ち、ベース層は、層の階層内の位置に応じてTIDを増加すべきである0より上位のレイヤに設定TIDがなければなりません。"
    },
    {
      "indent": 6,
      "text": "Y: 1 layer sync bit. The Y bit SHOULD be set to 1 if the current frame depends only on the base layer (TID = 0) frame with TL0PICIDX equal to that of the current frame. The Y bit MUST be set to 0 if the current frame depends on any other frame than the base layer (TID = 0) frame with TL0PICIDX equal to that of the current frame. Additionally, the Y bit MUST be set to 0 if any frame following the current frame depends on a non-base-layer frame older than the base-layer frame with TL0PICIDX equal to that of the current frame. If the Y bit is set when the T bit is equal to 0, the current frame MUST only depend on a past base-layer (TID=0) key frame as signaled by a change in the KEYIDX field. Additionally, this frame MUST NOT depend on any of the three codec buffers (as defined by [RFC6386]) that have been updated since the last time the KEYIDX field was changed.",
      "ja": "Y：1層同期ビット。現在のフレームがベース層（TID = 0）は、現在のフレームと等しいTL0PICIDXのフレームにのみ依存する場合Yビットが1に設定されるべきです。現在のフレームが現在のフレームと等しいTL0PICIDXとベース層（TID = 0）フレーム以外のフレームに依存する場合Yビットが0に設定しなければなりません。現在フレームに続く任意のフレームが現在のフレームと等しいTL0PICIDX有するベースレイヤフレームより古い非ベースレイヤフレームに依存している場合、さらに、Yのビットが0に設定しなければなりません。 Tビットが0に等しいときYビットがセットされている場合、現在のフレームがKEYIDXフィールドの変化によって信号として（TID = 0）キーフレーム過去のベース層上のみに依存しなければなりません。また、このフレームはKEYIDXフィールドが変更された最後の時間以降に更新されました（[RFC6386]で定義されている）3つのコーデックのバッファのいずれかに依存してはなりません。"
    },
    {
      "indent": 9,
      "text": "Informative note: This document does not describe how to determine the dependency status for a frame; this information is preferably provided from the encoder implementation. In the case of unknown status, the Y bit can safely be set to 0.",
      "ja": "有益な注意：この文書は、フレームの依存状態を判断する方法については説明しません。この情報は、好ましくは、エンコーダの実装から提供されます。不明の場合には、Yビットが安全に0に設定することができます。"
    },
    {
      "indent": 6,
      "text": "KEYIDX: 5 bits temporal key frame index. The KEYIDX field MUST be ignored by the receiver when the K bit is set equal to 0. The KEYIDX field is a running index for key frames. KEYIDX MAY start at a random value, and it MUST wrap to 0 after reaching the maximum number 31. When in use, the KEYIDX SHOULD be present for both key frames and interframes. The sender MUST increment KEYIDX for key frames that convey parameter updates critical to the interpretation of subsequent frames, and it SHOULD leave the KEYIDX unchanged for key frames that do not contain these critical updates. If the KEYIDX is present, a receiver SHOULD NOT decode an interframe if it has not received and decoded a key frame with the same KEYIDX after the last KEYIDX wraparound.",
      "ja": "KEYIDX：5ビット時間のキーフレームインデックス。 KビットがKEYIDXフィールドは、キーフレームのランニングインデックスは0に等しく設定されている場合KEYIDXフィールドは受信機によって無視されなければなりません。 KEYIDXはランダムな値で開始してもよいし、使用時に、KEYIDXは、キーフレームとインターフレームの両方のために存在すべきときには、最大数31に達した後に0にラップする必要があります。送信者は、後続のフレームの解釈に重要なパラメータの更新を伝えるキーフレームのためKEYIDXを増やす必要があり、それはこれらの重要な更新プログラムが含まれていないキーフレームの変わらないKEYIDXを残すべきです。 KEYIDXが存在する場合、それが受信され、最後KEYIDXラップアラウンド後に同じKEYIDXとキーフレームを復号されなかった場合、受信機は、フレーム間を復号すべきではありません。"
    },
    {
      "indent": 9,
      "text": "Informative note: This document does not describe how to determine if a key frame updates critical parameters; this information is preferably provided from the encoder implementation. A sender that does not have this information may either omit the KEYIDX field (set K equal to 0) or increment the KEYIDX on every key frame. The benefit with the latter is that any key-frame loss will be detected by the receiver, which can signal for re-transmission or request a new key frame.",
      "ja": "有益な注意：この文書は、キーフレームが重要なパラメータを更新するかどうかを決定する方法については説明しません。この情報は、好ましくは、エンコーダの実装から提供されます。 KEYIDXフィールド（0に等しくセットK）を省略するか、すべてのキーフレームにKEYIDXを増加することができるいずれかの情報を有していない送信者。後者との利点は、任意のキーフレームの損失は、再送信のための信号または新しいキーフレームを要求することができる受信機によって検出されることです。"
    },
    {
      "indent": 3,
      "text": "Informative note: Implementations doing splicing of VP8 streams will have to make sure the rules for incrementing TL0PICIDX and KEYIDX are obeyed across the splice. This will likely require rewriting values of TL0PICIDX and KEYIDX after the splice.",
      "ja": "有益な注意：VP8ストリームのスプライシングを行う実装はTL0PICIDXとKEYIDXをインクリメントするための規則は、スプライス渡っ従っていることを確認する必要があります。これはおそらく、スプライス後TL0PICIDXとKEYIDXの値を書き換える必要があります。"
    },
    {
      "indent": 0,
      "text": "4.3. VP8 Payload Header",
      "section_title": true,
      "ja": "4.3.  VP8ペイロードヘッダー"
    },
    {
      "indent": 3,
      "text": "The beginning of an encoded VP8 frame is referred to as an \"uncompressed data chunk\" in Section 9.1 of [RFC6386], and it also serves as a payload header in this RTP format. The codec bitstream format specifies two different variants of the uncompressed data chunk: a 3-octet version for interframes and a 10-octet version for key frames. The first 3 octets are common to both variants. In the case of a key frame, the remaining 7 octets are considered to be part of the remaining payload in this RTP format. Note that the header is present only in packets that have the S bit equal to one and the PID equal to zero in the payload descriptor. Subsequent packets for the same frame do not carry the payload header.",
      "ja": "符号化されたVP8フレームの先頭は、[RFC6386]のセクション9.1の「非圧縮データチャンク」と呼ばれ、それはまた、このRTPフォーマットのペイロードのヘッダとして機能します。インターフレームのための3オクテットのバージョンとキーフレーム10オクテットのバージョン：コーデックビットストリームフォーマットは、非圧縮データチャンクの二つの異なる変異体を特定します。最初の3つのオクテットは両方のバリアントに共通です。キーフレームの場合には、残りの7つのオクテットは、このRTPフォーマットの残りのペイロードの一部であると考えられます。ヘッダのみが1に等しいSビット及びペイロード・ディスクリプタのゼロに等しいPIDを有するパケット内に存在することに留意されたいです。同じフレームの後続のパケットは、ペイロードヘッダを運びません。"
    },
    {
      "indent": 3,
      "text": "The length of the first partition can always be obtained from the first partition-size parameter in the VP8 payload header. The VP8 bitstream format [RFC6386] specifies that if multiple DCT/WHT partitions are produced, the location of each partition start is found at the end of the first (prediction or mode) partition. In this RTP payload specification, the location offsets are considered to be part of the first partition.",
      "ja": "最初のパーティションの長さは常にVP8ペイロードヘッダの最初のパーティションサイズパラメータから得ることができます。 VP8ビットストリーム形式[RFC6386]は、複数のDCT / WHTパーティションが生成される場合、各パーティションの開始位置は、最初の（予測又はモード）パーティションの末尾に見出されることを指定します。このRTPペイロード仕様では、位置オフセットは、最初のパーティションの一部であると考えられます。"
    },
    {
      "indent": 28,
      "text": " 0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+\n|Size0|H| VER |P|\n+-+-+-+-+-+-+-+-+\n|     Size1     |\n+-+-+-+-+-+-+-+-+\n|     Size2     |\n+-+-+-+-+-+-+-+-+\n| Octets 4..N of|\n| VP8 payload   |\n:               :\n+-+-+-+-+-+-+-+-+\n| OPTIONAL RTP  |\n| padding       |\n:               :\n+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 33,
      "text": "Figure 3",
      "ja": "図3"
    },
    {
      "indent": 3,
      "text": "A packetizer needs access to the P bit. The other fields are defined in [RFC6386], Section 9.1, and their meanings do not influence the packetization process. None of these fields are modified by the packetization process.",
      "ja": "パケタイザは、Pビットにアクセスする必要があります。他のフィールドは、セクション9.1、[RFC6386]で定義されており、その意味は、パケット化プロセスに影響を及ぼしません。これらのフィールドのいずれも、パケット化プロセスによって変更されていません。"
    },
    {
      "indent": 3,
      "text": "P: Inverse key frame flag. When set to 0, the current frame is a key frame. When set to 1, the current frame is an interframe. Defined in [RFC6386]",
      "ja": "P：逆キーフレームフラグ。 0に設定すると、現在のフレームがキーフレームです。 1に設定すると、現在のフレームがインターです。 [RFC6386]で定義されました"
    },
    {
      "indent": 0,
      "text": "4.4. Aggregated and Fragmented Payloads",
      "section_title": true,
      "ja": "4.4. 集約され、断片化されたペイロード"
    },
    {
      "indent": 3,
      "text": "An encoded VP8 frame can be divided into two or more partitions, as described in Section 1. It is OPTIONAL for a packetizer implementing this RTP specification to pay attention to the partition boundaries within an encoded frame. If packetization of a frame is done without considering the partition boundaries, the PID field MAY be set to 0 for all packets and the S bit MUST NOT be set to 1 for any other packet than the first.",
      "ja": "これは、符号化されたフレーム内のパーティションの境界に注意を払うように、このRTP仕様を実装し、パケット化のためのオプションである第1節で説明したようにエンコードされたVP8フレームは、二つ以上のパーティションに分割することができます。フレームのパケットは、パーティション境界を考慮せずに行われている場合は、PIDフィールドは、すべてのパケットのために0に設定されるかもしれませんし、Sビットが最初以外のパケットのために1に設定してはいけません。"
    },
    {
      "indent": 3,
      "text": "If the preferred usage suggested in Section 3 is followed, with each packet carrying data from exactly one partition, the S bit and PID fields described in Section 4.2 SHOULD be used to indicate what the packet contains. The PID field should indicate to which partition the first octet of the payload belongs and the S bit indicates that the packet starts on a new partition.",
      "ja": "好ましい使用量は第3節で提案場合は正確に一つのパーティションからデータを搬送する各パケットと、続いて、4.2節で説明したSビットとPIDフィールドは、パケットに含まれるかを示すために使用されるべきです。 PIDフィールドは、ペイロードの最初のオクテットが属するとSビットはパケットが新しいパーティションに開始したことを示しているパーティションに示す必要があります。"
    },
    {
      "indent": 3,
      "text": "If the packetizer does not pay attention to the partition boundaries, one packet can contain a fragment of a partition, a complete partition, or an aggregate of fragments and partitions. There is no explicit signaling of partition boundaries in the payload, and the partition lengths at the end of the first partition have to be used to identify the boundaries. Partitions MUST be aggregated in decoding order. Two fragments from different partitions MAY be aggregated into the same packet along with one or more complete partitions.",
      "ja": "パケタイザは、パーティションの境界に注意を払っていない場合は、1つのパケットは、パーティションのフラグメント、完全なパーティション、またはフラグメントおよびパーティションの集計を含めることができます。そこペイロード内のパーティション境界の明示的なシグナリングはなく、最初のパーティションの終了時分割長が境界を識別するために使用されなければなりません。パーティションは、復号順で集計されなければなりません。異なるパーティションからの二つの断片は、1つ以上の完全なパーティションと一緒に同じパケットに集約されるかもしれません。"
    },
    {
      "indent": 3,
      "text": "In all cases, the payload of a packet MUST contain data from only one video frame. Consequently, the set of packets carrying the data from a particular frame will contain exactly one VP8 Payload Header (see Section 4.3) carried in the first packet of the frame. The last, or only, packet carrying data for the frame MUST have the M bit set in the RTP header.",
      "ja": "全ての場合において、パケットのペイロードは、1ビデオフレームからデータを含まなければなりません。したがって、特定のフレームからのデータを搬送するパケットのセットは、フレームの最初のパケットで運ばれた（4.3節を参照）正確に一つのVP8ペイロードヘッダを含むであろう。最後、または唯一の、Mを持たなければならないフレームのためのデータを搬送するパケットは、RTPヘッダにビットセット。"
    },
    {
      "indent": 0,
      "text": "4.5. Example Algorithms",
      "section_title": true,
      "ja": "4.5. 例アルゴリズム"
    },
    {
      "indent": 0,
      "text": "4.5.1. Frame Reconstruction Algorithm",
      "section_title": true,
      "ja": "4.5.1. 再構成アルゴリズムをフレーム"
    },
    {
      "indent": 3,
      "text": "Example of frame reconstruction algorithm.",
      "ja": "フレーム再構成アルゴリズムの例。"
    },
    {
      "indent": 3,
      "text": "1: Collect all packets with a given RTP timestamp.",
      "ja": "1：与えられたRTPタイムスタンプを持つすべてのパケットを収集します。"
    },
    {
      "indent": 3,
      "text": "2: Go through packets in order, sorted by sequence numbers, if packets are missing, send NACK as defined in [RFC4585] or decode with missing partitions, see Section 4.5.2 below.",
      "ja": "2：パケットが欠落している場合は、以下のセクション4.5.2を参照してください、[RFC4585]で定義されたNACKを送信したり、不足しているパーティションでデコードし、シーケンス番号順にソート、順番にパケットを通過します。"
    },
    {
      "indent": 3,
      "text": "3: A frame is complete if the frame has no missing sequence numbers, the first packet in the frame contains S=1 with partId=0 and the last packet in the frame has the marker bit set.",
      "ja": "3：フレームはミッシングシーケンス番号を持たない場合、フレームが完了し、フレーム内の最初のパケットはpartId = 0とS = 1を含み、フレーム内の最後のパケットは、マーカービットがセットされています。"
    },
    {
      "indent": 0,
      "text": "4.5.2. Partition Reconstruction Algorithm",
      "section_title": true,
      "ja": "4.5.2. パーティションの再構成アルゴリズム"
    },
    {
      "indent": 3,
      "text": "Example of partition reconstruction algorithm. The algorithm only applies for the RECOMMENDED use case with partitions in separate packets.",
      "ja": "パーティションの再構成アルゴリズムの例。アルゴリズムは、別々のパケットでパーティションを推奨ユースケースに適用されます。"
    },
    {
      "indent": 3,
      "text": "1: Scan for the start of a new partition; S=1.",
      "ja": "1：新しいパーティションの開始をスキャンし、 S = 1。"
    },
    {
      "indent": 3,
      "text": "2: Continue scan to detect end of partition; hence, a new S=1 (previous packet was the end of the partition) is found or the marker bit is set. If a loss is detected before the end of the partition, abandon all packets in this partition and continue the scan repeating from step 1.",
      "ja": "2：パーティションの終了を検出するためにスキャンを続行。したがって、新しいS = 1見出される（前のパケットは、パーティションの終わりであった）またはマーカービットが設定されています。損失は​​パーティションの終了前に検出された場合、このパーティション内のすべてのパケットを破棄し、ステップ1から繰り返すスキャンを続けます。"
    },
    {
      "indent": 3,
      "text": "3: Store the packets in the complete partition, continue the scan repeating from step 1 until end of frame is reached.",
      "ja": "3：、完全なパーティション内のパケットを格納フレームの終端に到達するまで、ステップ1から繰り返しスキャンを続けます。"
    },
    {
      "indent": 3,
      "text": "4: Send all complete partitions to the decoder. If no complete partition is found discard the whole frame.",
      "ja": "4：デコーダにすべての完全なパーティションを送信します。何の完全なパーティションが見つからない場合はフレーム全体を廃棄します。"
    },
    {
      "indent": 0,
      "text": "4.6. Examples of VP8 RTP Stream",
      "section_title": true,
      "ja": "4.6.  VP8 RTPストリームの例"
    },
    {
      "indent": 3,
      "text": "A few examples of how the VP8 RTP payload can be used are included below.",
      "ja": "VP8 RTPペイロードを使用することができる方法のいくつかの例は以下に含まれています。"
    },
    {
      "indent": 0,
      "text": "4.6.1. Key Frame in a Single RTP Packet",
      "section_title": true,
      "ja": "4.6.1. シングルRTPパケットにキーフレーム"
    },
    {
      "indent": 5,
      "text": " 0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+\n|  RTP header   |\n|  M = 1        |\n+-+-+-+-+-+-+-+-+\n|1|0|0|1|0|0 0 0| X = 1; S = 1; PID = 0\n+-+-+-+-+-+-+-+-+\n|1|0|0|0|0 0 0 0| I = 1\n+-+-+-+-+-+-+-+-+\n|0 0 0 1 0 0 0 1| PictureID = 17\n+-+-+-+-+-+-+-+-+\n|Size0|1| VER |0| P = 0\n+-+-+-+-+-+-+-+-+\n|     Size1     |\n+-+-+-+-+-+-+-+-+\n|     Size2     |\n+-+-+-+-+-+-+-+-+\n| VP8 payload   |\n+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.6.2. Non-discardable VP8 Interframe in a Single RTP Packet; No PictureID",
      "ja": "4.6.2. シングルRTPパケット内の非廃棄VP8インター。ノーPictureID"
    },
    {
      "indent": 5,
      "text": " 0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+\n|  RTP header   |\n|  M = 1        |\n+-+-+-+-+-+-+-+-+\n|0|0|0|1|0|0 0 0| X = 0; S = 1; PID = 0\n+-+-+-+-+-+-+-+-+\n|Size0|1| VER |1| P = 1\n+-+-+-+-+-+-+-+-+\n|     Size1     |\n+-+-+-+-+-+-+-+-+\n|     Size2     |\n+-+-+-+-+-+-+-+-+\n| VP8 payload   |\n+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.6.3. VP8 Partitions in Separate RTP Packets",
      "section_title": true,
      "ja": "4.6.3. 別々のRTPパケットでVP8パーティション"
    },
    {
      "indent": 3,
      "text": "First RTP packet; complete first partition.",
      "ja": "最初のRTPパケット。最初のパーティションを完了します。"
    },
    {
      "indent": 5,
      "text": " 0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+\n|  RTP header   |\n|  M = 0        |\n+-+-+-+-+-+-+-+-+\n|1|0|0|1|0|0 0 0| X = 1; S = 1; PID = 0\n+-+-+-+-+-+-+-+-+\n|1|0|0|0|0 0 0 0| I = 1\n+-+-+-+-+-+-+-+-+\n|0 0 0 1 0 0 0 1| PictureID = 17\n+-+-+-+-+-+-+-+-+\n|Size0|1| VER |1| P = 1\n+-+-+-+-+-+-+-+-+\n|     Size1     |\n+-+-+-+-+-+-+-+-+\n|     Size2     |\n+-+-+-+-+-+-+-+-+\n| Octets 4..L of|\n| first VP8     |\n| partition     |\n:               :\n+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Second RTP packet; complete second partition.",
      "ja": "第二のRTPパケット。 2番目のパーティションを完了します。"
    },
    {
      "indent": 5,
      "text": " 0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+\n|  RTP header   |\n|  M = 1        |\n+-+-+-+-+-+-+-+-+\n|1|0|0|1|0|0 0 1| X = 1; S = 1; PID = 1\n+-+-+-+-+-+-+-+-+\n|1|0|0|0|0 0 0 0| I = 1\n+-+-+-+-+-+-+-+-+\n|0 0 0 1 0 0 0 1| PictureID = 17\n+-+-+-+-+-+-+-+-+\n| Remaining VP8 |\n| partitions    |\n:               :\n+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.6.4. VP8 Frame Fragmented across RTP Packets",
      "section_title": true,
      "ja": "4.6.4.  RTPパケット全体で断片化されたVP8フレーム"
    },
    {
      "indent": 3,
      "text": "First RTP packet; complete first partition.",
      "ja": "最初のRTPパケット。最初のパーティションを完了します。"
    },
    {
      "indent": 5,
      "text": " 0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+\n|  RTP header   |\n|  M = 0        |\n+-+-+-+-+-+-+-+-+\n|1|0|0|1|0|0 0 0| X = 1; S = 1; PID = 0\n+-+-+-+-+-+-+-+-+\n|1|0|0|0|0 0 0 0| I = 1\n+-+-+-+-+-+-+-+-+\n|0 0 0 1 0 0 0 1| PictureID = 17\n+-+-+-+-+-+-+-+-+\n|Size0|1| VER |1| P = 1\n+-+-+-+-+-+-+-+-+\n|     Size1     |\n+-+-+-+-+-+-+-+-+\n|     Size2     |\n+-+-+-+-+-+-+-+-+\n| Complete      |\n| first         |\n| partition     |\n:               :\n+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Second RTP packet; first fragment of second partition.",
      "ja": "第二のRTPパケット。第二パーティションの最初のフラグメント。"
    },
    {
      "indent": 5,
      "text": " 0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+\n|  RTP header   |\n|  M = 0        |\n+-+-+-+-+-+-+-+-+\n|1|0|0|1|0|0 0 1| X = 1; S = 1; PID = 1\n+-+-+-+-+-+-+-+-+\n|1|0|0|0|0 0 0 0| I = 1\n+-+-+-+-+-+-+-+-+\n|0 0 0 1 0 0 0 1| PictureID = 17\n+-+-+-+-+-+-+-+-+\n| First fragment|\n| of second     |\n| partition     |\n:               :\n+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Third RTP packet; second fragment of second partition.",
      "ja": "第三のRTPパケット。第二隔壁の第2の断片。"
    },
    {
      "indent": 5,
      "text": " 0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+\n|  RTP header   |\n|  M = 0        |\n+-+-+-+-+-+-+-+-+\n|1|0|0|0|0|0 0 1| X = 1; S = 0; PID = 1\n+-+-+-+-+-+-+-+-+\n|1|0|0|0|0 0 0 0| I = 1\n+-+-+-+-+-+-+-+-+\n|0 0 0 1 0 0 0 1| PictureID = 17\n+-+-+-+-+-+-+-+-+\n| Mid fragment  |\n| of second     |\n| partition     |\n:               :\n+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Fourth RTP packet; last fragment of second partition.",
      "ja": "第四に、RTPパケット。第二パーティションの最後の断片。"
    },
    {
      "indent": 5,
      "text": " 0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+\n|  RTP header   |\n|  M = 1        |\n+-+-+-+-+-+-+-+-+\n|1|0|0|0|0|0 0 1| X = 1; S = 0; PID = 1\n+-+-+-+-+-+-+-+-+\n|1|0|0|0|0 0 0 0| I = 1\n+-+-+-+-+-+-+-+-+\n|0 0 0 1 0 0 0 1| PictureID = 17\n+-+-+-+-+-+-+-+-+\n| Last fragment |\n| of second     |\n| partition     |\n:               :\n+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.6.5. VP8 Frame with Long PictureID",
      "section_title": true,
      "ja": "4.6.5. ロングPictureIDとVP8フレーム"
    },
    {
      "indent": 3,
      "text": "PictureID = 4711 = 001001001100111 binary (first 7 bits: 0010010, last 8 bits: 01100111).",
      "ja": "PictureID = 4711 = 001001001100111バイナリ（第7ビット：0010010、最後の8ビット：01100111）。"
    },
    {
      "indent": 5,
      "text": " 0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+\n|  RTP header   |\n|  M = 1        |\n+-+-+-+-+-+-+-+-+\n|1|0|0|1|0|0 0 0| X = 1; S = 1; PID = 0\n+-+-+-+-+-+-+-+-+\n|1|0|0|0|0 0 0 0| I = 1;\n+-+-+-+-+-+-+-+-+\n|1 0 0 1 0 0 1 0| Long PictureID flag = 1\n|0 1 1 0 0 1 1 1| PictureID = 4711\n+-+-+-+-+-+-+-+-+\n|Size0|1| VER |1|\n+-+-+-+-+-+-+-+-+\n|     Size1     |\n+-+-+-+-+-+-+-+-+\n|     Size2     |\n+-+-+-+-+-+-+-+-+\n| Octets 4..N of|\n| VP8 payload   |\n:               :\n+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "5. Using VP8 with RPSI and SLI Feedback",
      "section_title": true,
      "ja": "5. RPSIとSLIフィードバックとVP8を使用します"
    },
    {
      "indent": 3,
      "text": "The VP8 payload descriptor defined in Section 4.2 contains an optional PictureID parameter. This parameter is included mainly to enable use of reference picture selection indication (RPSI) and slice loss indication (SLI), both defined in [RFC4585].",
      "ja": "4.2節で定義されているVP8ペイロード記述子は、オプションのPictureIDパラメータが含まれています。このパラメータは、参照ピクチャ選択指示（RPSI）と、スライス損失表示（SLI）、[RFC4585]で定義された両方の使用を可能にするために主に含まれています。"
    },
    {
      "indent": 0,
      "text": "5.1. RPSI",
      "section_title": true,
      "ja": "5.1.  RPSI"
    },
    {
      "indent": 3,
      "text": "The RPSI is a payload-specific feedback message defined within the RTCP-based feedback format. The RPSI message is generated by a receiver and can be used in two ways. Either it can signal a preferred reference picture when a loss has been detected by the decoder -- preferably then a reference that the decoder knows is perfect -- or it can be used as positive feedback information to acknowledge correct decoding of certain reference pictures. The positive-feedback method is useful for VP8 used for point-to-point (unicast) communication. The use of RPSI for VP8 is preferably combined with a special update pattern of the codec's two special reference frames -- the golden frame and the altref frame -- in which they are updated in an alternating leapfrog fashion. When a receiver has received and correctly decoded a golden or altref frame, and that frame has a PictureID in the payload descriptor, the receiver can acknowledge this simply by sending an RPSI message back to the sender. The message body (i.e., the \"native RPSI bit string\" in [RFC4585]) is simply the PictureID of the received frame.",
      "ja": "RPSIはRTCPベースのフィードバックのフォーマット内に定義されたペイロード固有フィードバックメッセージです。 RPSIメッセージが受信機によって生成され、2つの方法で使用することができます。デコーダは、知っている基準が完全であることが好ましく、その後 -   - 損失は、復号器によって検出された場合には、好適な参照ピクチャをシグナリングするか、またはそれは特定の参照ピクチャの正しい復号化を確認するために正のフィードバック情報として使用することができます。正帰還方法は、ポイントツーポイント（ユニキャスト）通信のために使用VP8に有用です。金色のフレームとaltrefフレーム -   - それらは交互のリープフロッグ的に更新されるVP8ためRPSIの使用は、好ましくは、コーデックの二つの特別な参照フレームの特殊な更新パターンと組み合わされます。受信機が受信して正確に黄金やaltrefフレームをデコードし、そのフレームは、ペイロード・ディスクリプタにPictureIDを持っている場合、受信機は、単に送信者にRPSIメッセージを送信することにより、これを認めることができます。メッセージ本体（[RFC4585]で、すなわち、「ネイティブRPSIビット列」）は、単に受信したフレームのPictureIDあります。"
    },
    {
      "indent": 0,
      "text": "5.2. SLI",
      "section_title": true,
      "ja": "5.2.  SLI"
    },
    {
      "indent": 3,
      "text": "The SLI is another payload-specific feedback message defined within the RTCP-based feedback format. The SLI message is generated by the receiver when a loss or corruption is detected in a frame. The format of the SLI message is as follows [RFC4585]:",
      "ja": "SLIは、RTCPベースのフィードバックのフォーマット内に定義された別のペイロード固有フィードバックメッセージです。損失または破損がフレーム内で検出された場合SLIメッセージが受信機によって生成されます。 [RFC4585]を次のようにSLIメッセージの形式は次のとおりです。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|         First           |        Number           | PictureID |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 33,
      "text": "Figure 4",
      "ja": "図4"
    },
    {
      "indent": 3,
      "text": "Here, First is the macroblock address (in scan order) of the first lost block and Number is the number of lost blocks, as defined in [RFC4585]. PictureID is the six least significant bits of the codec-specific picture identifier in which the loss or corruption has occurred. For VP8, this codec-specific identifier is naturally the PictureID of the current frame, as read from the payload descriptor. If the payload descriptor of the current frame does not have a PictureID, the receiver MAY send the last received PictureID+1 in the SLI message. The receiver MAY set the First parameter to 0, and the Number parameter to the total number of macroblocks per frame, even though only part of the frame is corrupted. When the sender receives an SLI message, it can make use of the knowledge from the latest received RPSI message. Knowing that the last golden or altref frame was successfully received, it can encode the next frame with reference to that established reference.",
      "ja": "ここでは、まず最初に失われたブロックの（スキャン順に）マクロブロックアドレスであり、番号[RFC4585]で定義されるように、失われたブロックの数です。 PictureID損失または破損が発生したコーデックに固有の画像識別子の6つの最下位ビットです。 VP8のために、このコーデック固有の識別子は、ペイロード記述子から読み出すように、自然に現在のフレームのPictureIDあります。現在のフレームのペイロード記述子はPictureIDを持っていない場合、受信機は、SLIメッセージで最後に受信PictureID + 1を送信することができます。受信機は、フレームの一部のみが破損しているにもかかわらず、0の最初のパラメータ、およびフレーム当たりのマクロブロックの総数に番号パラメータを設定してもよいです。送信者がSLIメッセージを受信すると、最新の受信RPSIメッセージからの知識を利用することができます。最後黄金またはaltrefフレームが正常に受信されたことを知って、その確立された基準に基づいて次のフレームを符号化することができます。"
    },
    {
      "indent": 0,
      "text": "5.3. Example",
      "section_title": true,
      "ja": "5.3. 例"
    },
    {
      "indent": 3,
      "text": "The use of RPSI and SLI is best illustrated in an example. In this example, the encoder may not update the altref frame until the last sent golden frame has been acknowledged with an RPSI message. If an update is not received within some time, a new golden frame update is sent instead. Once the new golden frame is established and acknowledged, the same rule applies when updating the altref frame.",
      "ja": "RPSIとSLIを使用することが最良の例に示されています。最後に送信された金色のフレームがRPSIメッセージで確認応答されるまで、この例では、エンコーダはaltrefフレームを更新しなくてもよいです。更新は、いくつかの時間内に受信されない場合は、新しい金色のフレーム更新が代わりに送信されます。新しい金色のフレームが確立され、承認されたらaltrefフレームを更新する際、同じルールが適用されます。"
    },
    {
      "indent": 3,
      "text": "+-------+-------------------+-------------------------+-------------+\n| Event | Sender            | Receiver                | Established |\n|       |                   |                         | reference   |\n+-------+-------------------+-------------------------+-------------+\n| 1000  | Send golden frame |                         |             |\n|       | PictureID = 0     |                         |             |\n|       |                   |                         |             |\n|       |                   | Receive and decode      |             |\n|       |                   | golden frame            |             |\n|       |                   |                         |             |\n| 1001  |                   | Send RPSI(0)            |             |\n|       |                   |                         |             |\n| 1002  | Receive RPSI(0)   |                         | golden      |\n|       |                   |                         |             |\n| ...   | (sending regular  |                         |             |\n|       | frames)           |                         |             |\n|       |                   |                         |             |\n| 1100  | Send altref frame |                         |             |\n|       | PictureID = 100   |                         |             |\n|       |                   |                         |             |\n|       |                   | Altref corrupted or     | golden      |\n|       |                   | lost                    |             |\n|       |                   |                         |             |\n| 1101  |                   | Send SLI(100)           | golden      |\n|       |                   |                         |             |\n| 1102  | Receive SLI(100)  |                         |             |\n|       |                   |                         |             |\n| 1103  | Send frame with   |                         |             |\n|       | reference to      |                         |             |\n|       | golden            |                         |             |\n|       |                   |                         |             |\n|       |                   | Receive and decode      | golden      |\n|       |                   | frame (decoder state    |             |\n|       |                   | restored)               |             |\n|       |                   |                         |             |\n| ...   | (sending regular  |                         |             |\n|       | frames)           |                         |             |\n|       |                   |                         |             |\n| 1200  | Send altref frame |                         |             |\n|       | PictureID = 200   |                         |             |\n|       |                   |                         |             |\n|       |                   | Receive and decode      | golden      |\n|       |                   | altref frame            |             |\n|       |                   |                         |             |\n| 1201  |                   | Send RPSI(200)          |             |\n|       |                   |                         |             |\n| 1202  | Receive RPSI(200) |                         | altref      |\n|       |                   |                         |             |",
      "raw": true
    },
    {
      "indent": 3,
      "text": "| ...   | (sending regular  |                         |             |\n|       | frames)           |                         |             |\n|       |                   |                         |             |\n| 1300  | Send golden frame |                         |             |\n|       | PictureID = 300   |                         |             |\n|       |                   |                         |             |\n|       |                   | Receive and decode      | altref      |\n|       |                   | golden frame            |             |\n|       |                   |                         |             |\n| 1301  |                   | Send RPSI(300)          | altref      |\n|       |                   |                         |             |\n| 1302  | RPSI lost         |                         |             |\n|       |                   |                         |             |\n| 1400  | Send golden frame |                         |             |\n|       | PictureID = 400   |                         |             |\n|       |                   |                         |             |\n|       |                   | Receive and decode      | altref      |\n|       |                   | golden frame            |             |\n|       |                   |                         |             |\n| 1401  |                   | Send RPSI(400)          |             |\n|       |                   |                         |             |\n| 1402  | Receive RPSI(400) |                         | golden      |\n+-------+-------------------+-------------------------+-------------+",
      "raw": true
    },
    {
      "indent": 10,
      "text": "Table 1: Example Signaling between Sender and Receiver",
      "ja": "表1：例では送信側と受信側の間のシグナリング"
    },
    {
      "indent": 3,
      "text": "Note that the scheme is robust to loss of the feedback messages. If the RPSI is lost, the sender will try to update the golden (or altref) again after a while, without releasing the established reference. Also, if an SLI is lost, the receiver can keep sending SLI messages at any interval allowed by the RTCP sending timing restrictions as specified in [RFC4585], as long as the picture is corrupted.",
      "ja": "スキームはフィードバックメッセージの損失に対してロバストであることに注意してください。 RPSIが失われた場合、送信者が設定された基準を解放せず、しばらく後に再び黄金（またはaltref）を更新しようとします。 SLIが失われた場合も、受信機は限り画像が破損しているとして、[RFC4585]で指定されたタイミング制約を送信するRTCPによって許可された任意の間隔でSLIメッセージを送信し続けることができます。"
    },
    {
      "indent": 0,
      "text": "6. Payload Format Parameters",
      "section_title": true,
      "ja": "6.ペイロードフォーマットのパラメータ"
    },
    {
      "indent": 3,
      "text": "This payload format has two optional parameters.",
      "ja": "このペイロード形式は、2つのオプションのパラメータがあります。"
    },
    {
      "indent": 0,
      "text": "6.1. Media Type Definition",
      "section_title": true,
      "ja": "6.1. メディアタイプの定義"
    },
    {
      "indent": 3,
      "text": "This registration is done using the template defined in [RFC6838] and following [RFC4855].",
      "ja": "この登録は[RFC6838]で定義されたテンプレートを使用して、[RFC4855]以下で行われます。"
    },
    {
      "indent": 3,
      "text": "Type name: video",
      "ja": "型名：ビデオ"
    },
    {
      "indent": 3,
      "text": "Subtype name: VP8",
      "ja": "サブタイプ名：VP8"
    },
    {
      "indent": 3,
      "text": "Required parameters: None.",
      "ja": "必須パラメータ：なし。"
    },
    {
      "indent": 3,
      "text": "Optional parameters:",
      "ja": "オプションのパラメータ："
    },
    {
      "indent": 6,
      "text": "These parameters are used to signal the capabilities of a receiver implementation. If the implementation is willing to receive media, both parameters MUST be provided. These parameters MUST NOT be used for any other purpose.",
      "ja": "これらのパラメータは、受信機の実装の機能を知らせるために使用されます。実装がメディアを受信する意思がある場合は、両方のパラメータを提供しなければなりません。これらのパラメータは、他の目的に使用してはいけません。"
    },
    {
      "indent": 6,
      "text": "max-fr: The value of max-fr is an integer indicating the maximum frame rate in units of frames per second that the decoder is capable of decoding.",
      "ja": "MAX-FR：MAX-FRの値は、デコーダは、復号することが可能であること、毎秒フレーム単位での最大フレームレートを示す整数です。"
    },
    {
      "indent": 6,
      "text": "max-fs: The value of max-fs is an integer indicating the maximum frame size in units of macroblocks that the decoder is capable of decoding.",
      "ja": "MAX-FS：MAX-FSの値は、デコーダは、復号することが可能であるマクロブロック単位での最大フレームサイズを示す整数です。"
    },
    {
      "indent": 9,
      "text": "The decoder is capable of decoding this frame size as long as the width and height of the frame in macroblocks are less than int(sqrt(max-fs * 8)). For instance, a max-fs of 1200 (capable of supporting 640x480 resolution) will support widths and heights up to 1552 pixels (97 macroblocks).",
      "ja": "デコーダであれば、マクロブロック内のフレームの幅と高さがint（SQRT（MAX-FS * 8））未満であるように、このフレームサイズを復号することが可能です。例えば、1200のMAX-FS（640×480の解像度をサポートすることができる）が1552個の画素（97個のマクロブロック）までの幅と高さをサポートします。"
    },
    {
      "indent": 3,
      "text": "Encoding considerations: This media type is framed in RTP and contains binary data; see Section 4.8 of [RFC6838].",
      "ja": "エンコードの考慮事項：このメディアタイプは、RTPに囲まれ、バイナリデータが含まれています。 [RFC6838]のセクション4.8を参照してください。"
    },
    {
      "indent": 3,
      "text": "Security considerations: See Section 7 of RFC 7741.",
      "ja": "セキュリティの考慮事項：RFC 7741のセクション7を参照してください。"
    },
    {
      "indent": 3,
      "text": "Interoperability considerations: None.",
      "ja": "相互運用性に関する注意事項：なし。"
    },
    {
      "indent": 3,
      "text": "Published specification: VP8 bitstream format [RFC6386] and RFC 7741.",
      "ja": "公開された仕様：VP8ビットストリーム形式[RFC6386]及びRFC 7741。"
    },
    {
      "indent": 3,
      "text": "Applications that use this media type: For example: Video over IP, video conferencing.",
      "ja": "たとえば、次のように：IP上のビデオ、ビデオ会議、このメディアタイプを使用するアプリケーション。"
    },
    {
      "indent": 3,
      "text": "Fragment identifier considerations: N/A.",
      "ja": "フラグメント識別子の考慮事項：N / A。"
    },
    {
      "indent": 3,
      "text": "Additional information: None.",
      "ja": "追加情報：なし。"
    },
    {
      "indent": 3,
      "text": "Person & email address to contact for further information: Patrik Westin, patrik.westin@gmail.com",
      "ja": "人と詳細のために連絡する電子メールアドレス：パトリックウェスティン、patrik.westin@gmail.com"
    },
    {
      "indent": 3,
      "text": "Intended usage: COMMON",
      "ja": "意図している用法：COMMON"
    },
    {
      "indent": 3,
      "text": "Restrictions on usage: This media type depends on RTP framing, and hence it is only defined for transfer via RTP [RFC3550].",
      "ja": "使用上の制限：このメディアタイプは、RTPフレーミングに依存し、したがって、それが唯一のRTP [RFC3550]を介して転送するために定義されています。"
    },
    {
      "indent": 3,
      "text": "Author: Patrik Westin, patrik.westin@gmail.com",
      "ja": "著者：パトリックウェスティン、patrik.westin@gmail.com"
    },
    {
      "indent": 3,
      "text": "Change controller: IETF Payload Working Group delegated from the IESG.",
      "ja": "変更コントローラ：IETFペイロードワーキンググループはIESGから委任します。"
    },
    {
      "indent": 0,
      "text": "6.2. SDP Parameters",
      "section_title": true,
      "ja": "6.2.  SDPパラメータ"
    },
    {
      "indent": 3,
      "text": "The receiver MUST ignore any fmtp parameter unspecified in this memo.",
      "ja": "受信機は、このメモでは、不特定の任意のfmtpパラメータを無視しなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.2.1. Mapping of Media Subtype Parameters to SDP",
      "section_title": true,
      "ja": "6.2.1.  SDPのメディアサブタイプのパラメータのマッピング"
    },
    {
      "indent": 3,
      "text": "The media type video/VP8 string is mapped to fields in the Session Description Protocol (SDP) [RFC4566] as follows:",
      "ja": "次のようにメディアタイプビデオ/ VP8列は、セッション記述プロトコル（SDP）[RFC4566]のフィールドにマッピングされます。"
    },
    {
      "indent": 3,
      "text": "o The media name in the \"m=\" line of SDP MUST be video.",
      "ja": "メディア名O「M =」SDPのラインがビデオでなければなりません。"
    },
    {
      "indent": 3,
      "text": "o The encoding name in the \"a=rtpmap\" line of SDP MUST be VP8 (the media subtype).",
      "ja": "O SDPの「A = rtpmap」ラインでエンコーディング名でなければなりませんVP8（メディアサブタイプ）。"
    },
    {
      "indent": 3,
      "text": "o The clock rate in the \"a=rtpmap\" line MUST be 90000.",
      "ja": "O「A = rtpmap」行のクロックレートは90000でなければなりません。"
    },
    {
      "indent": 3,
      "text": "o The parameters \"max-fs\" and \"max-fr\" MUST be included in the \"a=fmtp\" line if the SDP is used to declare receiver capabilities. These parameters are expressed as a media subtype string, in the form of a semicolon-separated list of parameter=value pairs.",
      "ja": "SDPは、受信能力を宣言するために使用される場合、パラメータ「MAX-FS」および「MAX-FR」O「A =のfmtp」行に含まれなければなりません。これらのパラメータは、パラメータ=値のペアのセミコロンで区切られたリストの形式で、メディアサブタイプ文字列として表されます。"
    },
    {
      "indent": 0,
      "text": "6.2.1.1. Example",
      "section_title": true,
      "ja": "6.2.1.1。例"
    },
    {
      "indent": 3,
      "text": "An example of media representation in SDP is as follows:",
      "ja": "次のようにSDP内のメディア表現の例です。"
    },
    {
      "indent": 3,
      "text": "m=video 49170 RTP/AVPF 98 a=rtpmap:98 VP8/90000 a=fmtp:98 max-fr=30; max-fs=3600;",
      "ja": "M =ビデオ49170 RTP / AVPF 98 = rtpmap：98 VP8 / 90000 =のfmtp：98 MAX-FR = 30。 MAX-FS = 3600;"
    },
    {
      "indent": 0,
      "text": "6.2.2. Offer/Answer Considerations",
      "section_title": true,
      "ja": "6.2.2. オファー/回答の考慮事項"
    },
    {
      "indent": 3,
      "text": "The VP8 codec offers a decode complexity that is roughly linear with the number of pixels encoded. The parameters \"max-fr\" and \"max-fs\" are defined in Section 6.1, where the macroblock size is 16x16 pixels as defined in [RFC6386], the max-fs and max-fr parameters MUST be used to establish these limits.",
      "ja": "VP8コーデックは、概ね符号化された画素数と線形であるデコードの複雑性を提供します。パラメータ「MAX-FR」および「MAX-FS」は、[RFC6386]で定義されるように、マクロブロックサイズが16×16画素でセクション6.1で定義され、MAX-FSとmax-FRパラメータは、これらの制限を確立するために使用されなければなりません。"
    },
    {
      "indent": 0,
      "text": "7. Security Considerations",
      "section_title": true,
      "ja": "7.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "RTP packets using the payload format defined in this specification are subject to the security considerations discussed in the RTP specification [RFC3550], and in any applicable RTP profile such as RTP/AVP [RFC3551], RTP/AVPF [RFC4585], RTP/SAVP [RFC3711], or RTP/ SAVPF [RFC5124]. However, as \"Securing the RTP Protocol Framework: Why RTP Does Not Mandate a Single Media Security Solution\" [RFC7202] discusses, it is not an RTP payload format's responsibility to discuss or mandate what solutions are used to meet the basic security goals like confidentiality, integrity, and source authenticity for RTP in general. This responsibility lays on anyone using RTP in an application. They can find guidance on available security mechanisms and important considerations in \"Options for Securing RTP Sessions\" [RFC7201]. Applications SHOULD use one or more appropriate strong security mechanisms. The rest of this security consideration section discusses the security impacting properties of the payload format itself.",
      "ja": "本明細書で定義されたペイロードフォーマットを使用して、RTPパケットは、RTP仕様[RFC3550]で説明したセキュリティ問題を受けることがあり、そのようなRTP / AVP [RFC3551]、RTP / AVPF [RFC4585]、RTP / SAVPとして該当RTPプロファイルで[RFC3711]、またはRTP / SAVPF [RFC5124]。しかし、「確保RTPプロトコルのフレームワーク：RTPは、単一のメディアセキュリティソリューション強制しないのはなぜ」として[RFC7202]について説明し、議論したりソリューションは、機密性などの基本的なセキュリティ目標を達成するために使用されているものを義務付けるRTPペイロード形式の責任ではありません一般的にはRTPのため、完全性、およびソース信憑。この責任は、アプリケーションでRTPを使用して誰にも産みます。彼らは、「セキュアなRTPセッションのオプション」[RFC7201]で利用可能なセキュリティ・メカニズムと重要な検討事項に関するガイダンスを見つけることができます。アプリケーションは、1つまたは複数の適切な強力なセキュリティ・メカニズムを使用すべきです。このセキュリティ考慮セクションの残りの部分は、ペイロードフォーマット自体の特性に影響を与えるセキュリティについて説明します。"
    },
    {
      "indent": 3,
      "text": "This RTP payload format and its media decoder do not exhibit any significant difference in the receiver-side computational complexity for packet processing and, thus, are unlikely to pose a denial-of-service threat due to the receipt of pathological data. Nor does the RTP payload format contain any active content.",
      "ja": "このRTPペイロードフォーマットとメディアデコーダは、このように、原因病理学的データを受信すると、サービス拒否の脅威をもたらす可能性が低い、パケット処理のために受信側計算の複雑さの有意な差を示しません。 NOR RTPペイロード形式は、任意のアクティブコンテンツが含まれていません。"
    },
    {
      "indent": 0,
      "text": "8. Congestion Control",
      "section_title": true,
      "ja": "8.輻輳制御"
    },
    {
      "indent": 3,
      "text": "Congestion control for RTP SHALL be used in accordance with RFC 3550 [RFC3550] and with any applicable RTP profile; e.g., RFC 3551 [RFC3551]. The congestion control mechanism can, in a real-time encoding scenario, adapt the transmission rate by instructing the encoder to encode at a certain target rate. Media-aware network elements MAY use the information in the VP8 payload descriptor in Section 4.2 to identify non-reference frames and discard them in order to reduce network congestion. Note that discarding of non-reference frames cannot be done if the stream is encrypted (because the non-reference marker is encrypted).",
      "ja": "RTPのための輻輳制御は、RFC 3550 [RFC3550]に従って、任意の適用可能なRTPプロファイルで使用しなければなりません。例えば、RFC 3551 [RFC3551]。輻輳制御機構は、リアルタイム符号化シナリオでは、特定の目標レートで符号化するために符号器に指示することによって伝送レートを適応させることができます。メディア対応のネットワーク要素は、非基準フレームを特定し、ネットワークの輻輳を軽減するために、それらを廃棄するために4.2節でVP8ペイロード記述子に情報を使用することができます。 （非基準マーカが暗号化されているため）ストリームが暗号化されている場合、非基準フレームの廃棄を行うことができません。"
    },
    {
      "indent": 0,
      "text": "9. IANA Considerations",
      "section_title": true,
      "ja": "9. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "The IANA has registered a media type as described in Section 6.1.",
      "ja": "6.1節で説明したようにIANAはメディアタイプを登録しています。"
    },
    {
      "indent": 0,
      "text": "10. References",
      "section_title": true,
      "ja": "10.参考文献"
    },
    {
      "indent": 0,
      "text": "10.1. Normative References",
      "section_title": true,
      "ja": "10.1. 引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<http://www.rfc-editor.org/info/ RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC3550] Schulzrinne, H., Casner, S., Frederick, R., and V. Jacobson, \"RTP: A Transport Protocol for Real-Time Applications\", STD 64, RFC 3550, DOI 10.17487/RFC3550, July 2003, <http://www.rfc-editor.org/info/rfc3550>.",
      "ja": "[RFC3550] Schulzrinneと、H.、Casner、S.、フレデリック、R.、およびV.ヤコブソン、 \"RTP：リアルタイムアプリケーションのためのトランスポートプロトコル\"、STD 64、RFC 3550、DOI 10.17487 / RFC3550、2003年7月、 <http://www.rfc-editor.org/info/rfc3550>。"
    },
    {
      "indent": 3,
      "text": "[RFC3551] Schulzrinne, H. and S. Casner, \"RTP Profile for Audio and Video Conferences with Minimal Control\", STD 65, RFC 3551, DOI 10.17487/RFC3551, July 2003, <http://www.rfc-editor.org/info/rfc3551>.",
      "ja": "[RFC3551] Schulzrinneと、H.とS. Casner、 \"最小量のコントロールがあるオーディオとビデオ会議システムのためのRTPプロフィール\"、STD 65、RFC 3551、DOI 10.17487 / RFC3551、2003年7月、<のhttp：//www.rfc-editor。組織/情報/ RFC3551>。"
    },
    {
      "indent": 3,
      "text": "[RFC4566] Handley, M., Jacobson, V., and C. Perkins, \"SDP: Session Description Protocol\", RFC 4566, DOI 10.17487/RFC4566, July 2006, <http://www.rfc-editor.org/info/rfc4566>.",
      "ja": "[RFC4566]ハンドリー、M.、ヤコブソン、V.、およびC.パーキンス、 \"SDP：セッション記述プロトコル\"、RFC 4566、DOI 10.17487 / RFC4566、2006年7月、<http://www.rfc-editor.org/情報/ RFC4566>。"
    },
    {
      "indent": 3,
      "text": "[RFC4585] Ott, J., Wenger, S., Sato, N., Burmeister, C., and J. Rey, \"Extended RTP Profile for Real-time Transport Control Protocol (RTCP)-Based Feedback (RTP/AVPF)\", RFC 4585, DOI 10.17487/RFC4585, July 2006, <http://www.rfc-editor.org/info/rfc4585>.",
      "ja": "[RFC4585]オット、J.、ウェンガー、S.、佐藤、N.、Burmeister、C.、およびJ.レイ「ベースのフィードバック（RTP / AVPF）リアルタイムトランスポート制御プロトコル（RTCP）の拡張RTPプロファイル」、RFC 4585、DOI 10.17487 / RFC4585、2006年7月、<http://www.rfc-editor.org/info/rfc4585>。"
    },
    {
      "indent": 3,
      "text": "[RFC4855] Casner, S., \"Media Type Registration of RTP Payload Formats\", RFC 4855, DOI 10.17487/RFC4855, February 2007, <http://www.rfc-editor.org/info/rfc4855>.",
      "ja": "[RFC4855] Casner、S.、 \"RTPペイロード形式のメディアタイプ登録\"、RFC 4855、DOI 10.17487 / RFC4855、2007年2月、<http://www.rfc-editor.org/info/rfc4855>。"
    },
    {
      "indent": 3,
      "text": "[RFC6386] Bankoski, J., Koleszar, J., Quillio, L., Salonen, J., Wilkins, P., and Y. Xu, \"VP8 Data Format and Decoding Guide\", RFC 6386, DOI 10.17487/RFC6386, November 2011, <http://www.rfc-editor.org/info/rfc6386>.",
      "ja": "[RFC6386] Bankoski、J.、Koleszar、J.、Quillio、L.、サロネン、J.、ウィルキンス、P.、およびY.徐、 \"VP8データフォーマットおよび復号化ガイド\"、RFC 6386、DOI 10.17487 / RFC6386、 2011年11月、<http://www.rfc-editor.org/info/rfc6386>。"
    },
    {
      "indent": 3,
      "text": "[RFC6838] Freed, N., Klensin, J., and T. Hansen, \"Media Type Specifications and Registration Procedures\", BCP 13, RFC 6838, DOI 10.17487/RFC6838, January 2013, <http://www.rfc-editor.org/info/rfc6838>.",
      "ja": "[RFC6838]解放され、N.、Klensin、J.、およびT.ハンセン、 \"メディアタイプの仕様と登録手順\"、BCP 13、RFC 6838、DOI 10.17487 / RFC6838、2013年1月、<のhttp：//www.rfc- editor.org/info/rfc6838>。"
    },
    {
      "indent": 0,
      "text": "10.2. Informative References",
      "section_title": true,
      "ja": "10.2. 参考文献"
    },
    {
      "indent": 3,
      "text": "[RFC3711] Baugher, M., McGrew, D., Naslund, M., Carrara, E., and K. Norrman, \"The Secure Real-time Transport Protocol (SRTP)\", RFC 3711, DOI 10.17487/RFC3711, March 2004, <http://www.rfc-editor.org/info/rfc3711>.",
      "ja": "[RFC3711] Baugher、M.、マグリュー、D.、Naslund、M.、カララ、E.、およびK. Norrman、 \"セキュアリアルタイムトランスポートプロトコル（SRTP）\"、RFC 3711、DOI 10.17487 / RFC3711、マーチ2004年、<http://www.rfc-editor.org/info/rfc3711>。"
    },
    {
      "indent": 3,
      "text": "[RFC5124] Ott, J. and E. Carrara, \"Extended Secure RTP Profile for Real-time Transport Control Protocol (RTCP)-Based Feedback (RTP/SAVPF)\", RFC 5124, DOI 10.17487/RFC5124, February 2008, <http://www.rfc-editor.org/info/rfc5124>.",
      "ja": "[RFC5124]オット、J.およびE.カララ、RFC 5124、DOI 10.17487 / RFC5124、2008年2月、<HTTP \"リアルタイムトランスポート制御プロトコル（RTCP）ベースのフィードバック（RTP / SAVPF）にSecure RTPプロファイル拡張\" ：//www.rfc-editor.org/info/rfc5124>。"
    },
    {
      "indent": 3,
      "text": "[RFC7201] Westerlund, M. and C. Perkins, \"Options for Securing RTP Sessions\", RFC 7201, DOI 10.17487/RFC7201, April 2014, <http://www.rfc-editor.org/info/rfc7201>.",
      "ja": "[RFC7201]ウェスター、M.とC.パーキンス、 \"RTPセッションを確保するためのオプション\"、RFC 7201、DOI 10.17487 / RFC7201、2014年4月、<http://www.rfc-editor.org/info/rfc7201>。"
    },
    {
      "indent": 3,
      "text": "[RFC7202] Perkins, C. and M. Westerlund, \"Securing the RTP Framework: Why RTP Does Not Mandate a Single Media Security Solution\", RFC 7202, DOI 10.17487/RFC7202, April 2014, <http://www.rfc-editor.org/info/rfc7202>.",
      "ja": "[RFC7202]パーキンス、C.とM.ウェスター、 \"RTPフレームワークの保護：なぜ、RTPは、単一のメディアセキュリティソリューションを強制しない\"、RFC 7202、DOI 10.17487 / RFC7202、2014年4月、<のhttp：//www.rfc- editor.org/info/rfc7202>。"
    },
    {
      "indent": 3,
      "text": "[Sch07] Schwarz, H., Marpe, D., and T. Wiegand, \"Overview of the Scalable Video Coding Extension of the H.264/AVC Standard\", IEEE Transactions on Circuits and Systems for Video Technology, Volume 17: Issue 9, DOI 10.1109/TCSVT.2007.905532, September 2007, <http://dx.doi.org/10.1109/TCSVT.2007.905532>.",
      "ja": "[Sch07]シュワルツ、H.、Marpe、D.、およびT.ウィーガンド、ビデオ技術、17巻のための回路とシステム、IEEEトランザクション「H.264 / AVC規格の拡張を、スケーラブルビデオ符号化の概要」：問題9、DOI 10.1109 / TCSVT.2007.905532、2007年9月、<http://dx.doi.org/10.1109/TCSVT.2007.905532>。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Patrik Westin Google, Inc. 1600 Amphitheatre Parkway Mountain View, CA 94043 United States",
      "ja": "パトリックウェスティングーグル株式会社1600アンフィシアターパークウェイマウンテンビュー、CA 94043米国"
    },
    {
      "indent": 3,
      "text": "Email: patrik.westin@gmail.com",
      "ja": "メール：patrik.westin@gmail.com"
    },
    {
      "indent": 3,
      "text": "Henrik F Lundin Google, Inc. Kungsbron 2 Stockholm 11122 Sweden",
      "ja": "ヘンリク・Fランディングーグル社Kungsbron 2ストックホルム11122スウェーデン"
    },
    {
      "indent": 3,
      "text": "Email: hlundin@google.com",
      "ja": "メール：hlundin@google.com"
    },
    {
      "indent": 3,
      "text": "Michael Glover Twitter Boston 10 Hemlock Way Durham, NH 03824 United States",
      "ja": "マイケル・グローバーTwitterのボストン10ヘムロック・ウェイダーラム、NH 03824米国"
    },
    {
      "indent": 3,
      "text": "Email: michaelglover262@gmail.com",
      "ja": "メール：michaelglover262@gmail.com"
    },
    {
      "indent": 3,
      "text": "Justin Uberti Google, Inc. 747 6th Street South Kirkland, WA 98033 United States",
      "ja": "ジャスティンUbertiグーグル社747第六ストリート南カークランド、WA 98033米国"
    },
    {
      "indent": 3,
      "text": "Email: justin@uberti.name",
      "ja": "メール：justin@uberti.name"
    },
    {
      "indent": 3,
      "text": "Frank Galligan Google, Inc. 1600 Amphitheatre Parkway Mountain View, CA 94043 United States",
      "ja": "フランクGalliganグーグル株式会社1600アンフィシアターパークウェイマウンテンビュー、CA 94043米国"
    },
    {
      "indent": 3,
      "text": "Email: fgalligan@google.com",
      "ja": "メール：fgalligan@google.com"
    }
  ]
}