{
  "title": {
    "text": "RFC 7616 - HTTP Digest Access Authentication",
    "ja": "RFC 7616 - HTTPダイジェストアクセス認証"
  },
  "number": 7616,
  "created_at": "2019-10-31 07:20:44.294444+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)               R. Shekh-Yusef, Ed.\nRequest for Comments: 7616                                         Avaya\nObsoletes: 2617                                                D. Ahrens\nCategory: Standards Track                                    Independent\nISSN: 2070-1721                                                S. Bremer\n                                                             Netzkonform\n                                                          September 2015",
      "raw": true
    },
    {
      "indent": 19,
      "text": "HTTP Digest Access Authentication",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "The Hypertext Transfer Protocol (HTTP) provides a simple challenge-response authentication mechanism that may be used by a server to challenge a client request and by a client to provide authentication information. This document defines the HTTP Digest Authentication scheme that can be used with the HTTP authentication mechanism.",
      "ja": "ハイパーテキスト転送プロトコル（HTTP）は、認証情報を提供するために、クライアントの要求に挑戦するためにサーバによって、クライアントによって使用され得る単純なチャレンジ・レスポンス認証メカニズムを提供します。この文書では、HTTP認証機構を使用することができるHTTPダイジェスト認証方式を定義します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 5741のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7616.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7616で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2015 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2015 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 3,
      "text": "This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.",
      "ja": "この材料の一部がIETFトラストにこのような材料の変更を許可する権利を与えられていない可能性がありますにこの文書は、2008年、IETFドキュメントまたは11月10日以前に発行または公開さIETF貢献から著作権を支配する者（複数可）材料を含んでいてもよいですIETF標準化プロセスの外。そのような材料の著作権を管理者（単数または複数）から適切なライセンスを取得することなく、この文書は、IETF標準化過程の外側修正されないかもしれません、そして、それの派生物は、IETF標準化過程の外側に作成されない場合があり、それをフォーマットする以外出版RFCとして、英語以外の言語に翻訳します。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   4\n  1.1.  Terminology . . . . . . . . . . . . . . . . . . . . . . .   4\n2.  Syntax Convention . . . . . . . . . . . . . . . . . . . . . .   4\n  2.1.  Examples  . . . . . . . . . . . . . . . . . . . . . . . .   4\n  2.2.  ABNF  . . . . . . . . . . . . . . . . . . . . . . . . . .   4\n3.  Digest Access Authentication Scheme . . . . . . . . . . . . .   5\n  3.1.  Overall Operation . . . . . . . . . . . . . . . . . . . .   5\n  3.2.  Representation of Digest Values . . . . . . . . . . . . .   5\n  3.3.  The WWW-Authenticate Response Header Field  . . . . . . .   5\n  3.4.  The Authorization Header Field  . . . . . . . . . . . . .   9\n    3.4.1.  Response  . . . . . . . . . . . . . . . . . . . . . .  11\n    3.4.2.  A1  . . . . . . . . . . . . . . . . . . . . . . . . .  11\n    3.4.3.  A2  . . . . . . . . . . . . . . . . . . . . . . . . .  12\n    3.4.4.  Username Hashing  . . . . . . . . . . . . . . . . . .  12\n    3.4.5.  Parameter Values and Quoted-String  . . . . . . . . .  12\n    3.4.6.  Various Considerations  . . . . . . . . . . . . . . .  13\n  3.5.  The Authentication-Info and Proxy-Authentication-Info\n        Header Fields . . . . . . . . . . . . . . . . . . . . . .  14\n  3.6.  Digest Operation  . . . . . . . . . . . . . . . . . . . .  15\n  3.7.  Security Protocol Negotiation . . . . . . . . . . . . . .  16\n  3.8.  Proxy-Authenticate and Proxy-Authorization  . . . . . . .  17\n  3.9.  Examples  . . . . . . . . . . . . . . . . . . . . . . . .  18\n    3.9.1.  Example with SHA-256 and MD5  . . . . . . . . . . . .  18\n    3.9.2.  Example with SHA-512-256, Charset, and Userhash . . .  19\n4.  Internationalization Considerations . . . . . . . . . . . . .  20\n5.  Security Considerations . . . . . . . . . . . . . . . . . . .  21\n  5.1.  Limitations . . . . . . . . . . . . . . . . . . . . . . .  21\n  5.2.  Storing Passwords . . . . . . . . . . . . . . . . . . . .  21\n  5.3.  Authentication of Clients Using Digest Authentication . .  22\n  5.4.  Limited-Use Nonce Values  . . . . . . . . . . . . . . . .  23\n  5.5.  Replay Attacks  . . . . . . . . . . . . . . . . . . . . .  23\n  5.6.  Weakness Created by Multiple Authentication Schemes . . .  24\n  5.7.  Online Dictionary Attacks . . . . . . . . . . . . . . . .  24\n  5.8.  Man-in-the-Middle Attacks . . . . . . . . . . . . . . . .  25\n  5.9.  Chosen Plaintext Attacks  . . . . . . . . . . . . . . . .  25\n  5.10. Precomputed Dictionary Attacks  . . . . . . . . . . . . .  26\n  5.11. Batch Brute-Force Attacks . . . . . . . . . . . . . . . .  26\n  5.12. Parameter Randomness  . . . . . . . . . . . . . . . . . .  26\n  5.13. Summary . . . . . . . . . . . . . . . . . . . . . . . . .  26\n6.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  27\n  6.1.  Hash Algorithms for HTTP Digest Authentication  . . . . .  27\n  6.2.  Digest Scheme Registration  . . . . . . . . . . . . . . .  28\n7.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  28\n  7.1.  Normative References  . . . . . . . . . . . . . . . . . .  28\n  7.2.  Informative References  . . . . . . . . . . . . . . . . .  30\nAppendix A.  Changes from RFC 2617  . . . . . . . . . . . . . . .  31",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Acknowledgments . . . . . . . . . . . . . . . . . . . . . . . . .  31\nAuthors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  32",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "HTTP provides a simple challenge-response authentication mechanism that may be used by a server to challenge a client request and by a client to provide authentication information. This document defines the HTTP Digest Authentication scheme that can be used with the HTTP authentication mechanism.",
      "ja": "HTTPは認証情報を提供するために、クライアントの要求に挑戦するためにサーバによって使用され、クライアントによってすることができる簡単なチャレンジレスポンス認証メカニズムを提供します。この文書では、HTTP認証機構を使用することができるHTTPダイジェスト認証方式を定義します。"
    },
    {
      "indent": 3,
      "text": "This document extends but is generally backward compatible with [RFC2617]. See Appendix A for the new capabilities introduced by this specification.",
      "ja": "この文書では、延在するが、[RFC2617]と、一般的に下位互換性があります。この仕様で導入された新機能については、付録Aを参照してください。"
    },
    {
      "indent": 3,
      "text": "The details of the challenge-response authentication mechanism are specified in the \"Hypertext Transfer Protocol (HTTP/1.1): Authentication\" [RFC7235].",
      "ja": "[RFC7235]：チャレンジレスポンス認証メカニズムの詳細は、「認証ハイパーテキスト転送プロトコル（HTTP / 1.1）」に指定されています。"
    },
    {
      "indent": 3,
      "text": "The combination of this document with the definition of the \"Basic\" authentication scheme [RFC7617], \"HTTP Authentication-Info and Proxy-Authentication-Info Response Header Fields\" [RFC7615], and \"Hypertext Transfer Protocol (HTTP/1.1): Authentication\" [RFC7235] obsolete [RFC2617].",
      "ja": "認証：「基本」認証スキーム[RFC7617]、「HTTP認証-情報およびプロキシ認証 - インフォメーションレスポンスヘッダフィールド」[RFC7615]、および「ハイパーテキスト転送プロトコル（HTTP / 1.1）の定義と、この文書の組み合わせ\"[RFC7235]旧式の[RFC2617]。"
    },
    {
      "indent": 0,
      "text": "1.1. Terminology",
      "section_title": true,
      "ja": "1.1。用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "キーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、 \"SHALL\"、 \"SHOULD\"、 \"ないもの\"、 \"推奨\" \"ない（SHOULD NOT）\"、 \"MAY\"、 \"推奨NOT\"、および「OPTIONAL 「本書では[RFC2119]で説明されるように解釈されるべきです。"
    },
    {
      "indent": 0,
      "text": "2. Syntax Convention",
      "section_title": true,
      "ja": "2.構文条約"
    },
    {
      "indent": 0,
      "text": "2.1. Examples",
      "section_title": true,
      "ja": "2.1。例"
    },
    {
      "indent": 3,
      "text": "In the interest of clarity and readability, the extended parameters or the header fields and parameters in the examples in this document might be broken into multiple lines. Any line that is indented in this document is a continuation of the preceding line.",
      "ja": "明快さと読みやすさの利益のために、この文書の例では拡張パラメータ又はヘッダフィールドとパラメータが複数行に分割されるかもしれません。この文書にインデントされているすべての行は、前の行の続きです。"
    },
    {
      "indent": 0,
      "text": "2.2. ABNF",
      "section_title": true,
      "ja": "2.2。 ABNF"
    },
    {
      "indent": 3,
      "text": "This specification uses the Augmented Backus-Naur Form (ABNF) notation of [RFC5234] and the ABNF List Extension of [RFC7230].",
      "ja": "この仕様は[RFC5234]とのABNF一覧拡張[RFC7230]の増補バッカス - ナウアフォーム（ABNF）の表記を使用します。"
    },
    {
      "indent": 0,
      "text": "3. Digest Access Authentication Scheme",
      "section_title": true,
      "ja": "3.ダイジェストアクセス認証スキーム"
    },
    {
      "indent": 0,
      "text": "3.1. Overall Operation",
      "section_title": true,
      "ja": "3.1。全体動作"
    },
    {
      "indent": 3,
      "text": "The Digest scheme is based on a simple challenge-response paradigm. The Digest scheme challenges using a nonce value and might indicate that username hashing is supported. A valid response contains an unkeyed digest of the username, the password, the given nonce value, the HTTP method, and the requested URI. In this way, the password is never sent in the clear, and the username can be hashed, depending on the indication received from the server. The username and password must be prearranged in some fashion not addressed by this document.",
      "ja": "ダイジェストスキームは、単純なチャレンジ・レスポンスパラダイムに基づいています。ダイジェスト方式はナンス値を使って挑戦し、そのユーザ名のハッシュがサポートされている可能性があります。有効な応答は、ユーザ名のキーなしダイジェスト、パスワード、与えられたノンス値、HTTPメソッド、および要求されたURIが含まれています。このように、パスワードが平文で送信されることはありませんし、ユーザ名は、サーバから受信した指示に応じて、ハッシュ化することができます。ユーザ名とパスワードは、この文書で扱われていない何らかの方法で事前に決められなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.2. Representation of Digest Values",
      "section_title": true,
      "ja": "3.2。ダイジェスト値の表現"
    },
    {
      "indent": 3,
      "text": "An optional header field allows the server to specify the algorithm used to create the unkeyed digest or digest. This document adds SHA-256 and SHA-512/256 algorithms. To maintain backwards compatibility with [RFC2617], the MD5 algorithm is still supported but NOT RECOMMENDED.",
      "ja": "オプションのヘッダフィールドは、サーバがダイジェストまたはダイジェストキーなしを作成するために使用されるアルゴリズムを指定することを可能にします。この文書では、SHA-256とSHA-256分の512アルゴリズムが追加されます。 [RFC2617]との後方互換性を維持するために、MD5アルゴリズムは、まだサポートされていますが、推奨されません。"
    },
    {
      "indent": 3,
      "text": "The size of the digest depends on the algorithm used. The bits in the digest are converted from the most significant to the least significant bit, four bits at a time, to the ASCII representation as follows. Each sequence of four bits is represented by its familiar hexadecimal notation from the characters 0123456789abcdef; that is, binary 0000 is represented by the character '0', 0001 by '1' and so on up to the representation of 1111 as 'f'. If the MD5 algorithm is used to calculate the digest, then the MD5 digest will be represented as 32 hexadecimal characters, while SHA-256 and SHA-512/256 are represented as 64 hexadecimal characters.",
      "ja": "ダイジェストのサイズは、使用されるアルゴリズムに依存します。次のようにダイジェストのビットは、ASCII表現に、一度に、最下位ビットに最上位から4ビットに変換されます。 4ビットの各シーケンスは、文字0123456789ABCDEFからの馴染みの16進数で表されます。つまり、0000バイナリ文字で表される「0」、0001「1」というように「F」として1111表現までによって。 MD5アルゴリズムは、ダイジェストを計算するために使用される場合はSHA-256およびSHA-256分の512は、64進数文字として表されているが、その後、MD5ダイジェストは、32進文字として表現されます。"
    },
    {
      "indent": 0,
      "text": "3.3. The WWW-Authenticate Response Header Field",
      "section_title": true,
      "ja": "3.3。 WWW認証レスポンスヘッダーフィールド"
    },
    {
      "indent": 3,
      "text": "If a server receives a request for an access-protected object, and an acceptable Authorization header field is not sent, the server responds with a \"401 Unauthorized\" status code and a WWW-Authenticate header field with Digest scheme as per the framework defined above. The value of the header field can include parameters from the following list:",
      "ja": "サーバがアクセス保護されたオブジェクトのための要求を受信し、許容されるAuthorizationヘッダフィールドが送信されない場合、上記で定義の枠組みに従って、サーバは「401不正」ステータスコードとダイジェストスキームWWW-Authenticateヘッダフィールドで応答します。ヘッダーフィールドの値は次のリストからパラメータを含むことができます。"
    },
    {
      "indent": 3,
      "text": "realm",
      "ja": "分野"
    },
    {
      "indent": 6,
      "text": "A string to be displayed to users so they know which username and password to use. This string should contain at least the name of the host performing the authentication and might additionally indicate the collection of users who might have access. An example is \"registered_users@example.com\". (See Section 2.2 of [RFC7235] for more details.)",
      "ja": "彼らは、ユーザー名とパスワードを使用するかを知っているので、文字列がユーザーに表示されます。この文字列は、少なくとも認証を実行するホストの名前が含まれている必要があり、さらにアクセス権を持っている可能性があるユーザーの集合を示している可能性があります。例では、「registered_users@example.com」です。 （詳細については[RFC7235]のセクション2.2を参照）。"
    },
    {
      "indent": 3,
      "text": "domain",
      "ja": "ドメイン"
    },
    {
      "indent": 6,
      "text": "A quoted, space-separated list of URIs, as specified in [RFC3986], that define the protection space. If a URI is a path-absolute, it is relative to the canonical root URL. (See Section 2.2 of [RFC7235].) An absolute-URI in this list may refer to a different server than the web-origin [RFC6454]. The client can use this list to determine the set of URIs for which the same authentication information may be sent: any URI that has a URI in this list as a prefix (after both have been made absolute) MAY be assumed to be in the same protection space. If this parameter is omitted or its value is empty, the client SHOULD assume that the protection space consists of all URIs on the web-origin.",
      "ja": "[RFC3986]で指定されたURIの引用された、スペースで区切られたリスト、保護空間を定義します。 URIはパス絶対的である場合、それは正規のルートURLに相対的です。 （[RFC7235]のセクション2.2を参照。）このリスト内の絶対URIは、ウェブ原点[RFC6454]とは異なるサーバーを指すことができます。同じであると仮定することができる（いずれも絶対行われた後）の接頭辞としてこのリストにURIを持つ任意のURI：クライアントが同じ認証情報を送信することができるためURIの組を決定するために、このリストを使用することができ保護空間。このパラメータを省略するか、その値が空の場合、クライアントは保護空間は、Web-起源に関するすべてのURIで構成されていることを前提とすべきです。"
    },
    {
      "indent": 6,
      "text": "This parameter is not meaningful in Proxy-Authenticate header fields, for which the protection space is always the entire proxy; if present, it MUST be ignored.",
      "ja": "このパラメータは、保護空間は、常に全体のプロキシされたプロキシ認証ヘッダフィールドに意味がありません。存在する場合、それは無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "nonce",
      "ja": "使節"
    },
    {
      "indent": 6,
      "text": "A server-specified string which should be uniquely generated each time a 401 response is made. It is advised that this string be Base64 or hexadecimal data. Specifically, since the string is passed in the header field lines as a quoted string, the double-quote character is not allowed, unless suitably escaped.",
      "ja": "一意401応答が行われるたびに生成されるべきサーバが指定した文字列。この文字列はBase64でまたは16進数のデータであることをお勧めします。文字列は引用符で囲まれた文字列としてヘッダフィールドのラインで渡されているので、適切にエスケープしない限り、具体的には、二重引用符文字は、許可されていません。"
    },
    {
      "indent": 6,
      "text": "The contents of the nonce are implementation dependent. The quality of the implementation depends on a good choice. A nonce might, for example, be constructed as the Base64 encoding of",
      "ja": "ナンスの内容は実装に依存しています。実装の品質は良い選択に依存します。ノンスは、例えば、のBase64エンコードのように構成されるかもしれません"
    },
    {
      "indent": 12,
      "text": "timestamp H(timestamp \":\" ETag \":\" secret-data)",
      "ja": "タイムスタンプH（タイムスタンプ \"：\" ETagを \"：\" 秘密データ）"
    },
    {
      "indent": 6,
      "text": "where timestamp is a server-generated time, which preferably includes micro- or nanoseconds, or other non-repeating values; ETag is the value of the HTTP ETag header field associated with the requested entity; and secret-data is data known only to the server. With a nonce of this form, a server would recalculate the hash portion after receiving the client authentication header field and reject the request if it did not match the nonce from that header field or if the timestamp value is not recent enough. In this way, the server can limit the time of the nonce's validity. The inclusion of the ETag prevents a replay request for an updated version of the resource. Including the IP address of the client in the nonce would appear to offer the server the ability to limit the reuse of the nonce to the same client that originally got it. However, that would break because requests from a single user often go through different proxies. Also, IP address spoofing is not that hard.",
      "ja": "タイムスタンプは、好ましくは、マイクロまたはナノ秒、または他の非反復値を含むサーバで生成された時間、です。 ETagは要求されたエンティティに関連付けられたHTTP ETagヘッダフィールドの値です。そして、機密データはサーバだけに知られているデータです。この形式のナンスを使用すると、サーバーは、クライアント認証ヘッダフィールドを受信した後、ハッシュ部分を再計算し、それがそのヘッダフィールドからナンスが一致しなかった場合や、タイムスタンプ値が十分に最近でない場合は、要求を拒否します。このように、サーバはナンスの有効性の時間を制限することができます。 ETagの包含は、リソースの更新バージョン用の再生要求を阻止します。ナンスで、クライアントのIPアドレスを含めると、サーバーにもともとそれを得た同じクライアントにナンスの再利用を制限する機能を提供するように思われます。一人のユーザからの要求は、多くの場合、異なるプロキシを経由するので、しかし、それは壊れます。また、IPスプーフィングは難しいことではありません。"
    },
    {
      "indent": 6,
      "text": "An implementation might choose not to accept a previously used nonce or a previously used digest, in order to protect against a replay attack. Or, an implementation might choose to use one-time nonces or digests for POST or PUT requests and a timestamp for GET requests. For more details on the issues involved, see Section 5 of this document.",
      "ja": "実装は、リプレイ攻撃から保護するために、以前使用したnonceまたは以前に使用さダイジェストを受け入れない選択することがあります。または、実装は、POSTのためのワンタイムナンスやダイジェストを使用するか、または要求とGETリクエストのタイムスタンプを置くこともできます。関連する問題の詳細については、このドキュメントのセクション5を参照してください。"
    },
    {
      "indent": 6,
      "text": "The nonce is opaque to the client.",
      "ja": "ナンスは、クライアントには不透明です。"
    },
    {
      "indent": 3,
      "text": "opaque",
      "ja": "オペーク"
    },
    {
      "indent": 6,
      "text": "A string of data, specified by the server, that SHOULD be returned by the client unchanged in the Authorization header field of subsequent requests with URIs in the same protection space. It is RECOMMENDED that this string be Base64 or hexadecimal data.",
      "ja": "同じ保護空間内のURIを持つ以降のリクエストのAuthorizationヘッダフィールドにそのままクライアントによって返されるべきであるサーバーで指定されたデータの列、、。この文字列はBase64でまたは16進数のデータであることが推奨されます。"
    },
    {
      "indent": 3,
      "text": "stale",
      "ja": "古いです"
    },
    {
      "indent": 6,
      "text": "A case-insensitive flag indicating that the previous request from the client was rejected because the nonce value was stale. If stale is true, the client may wish to simply retry the request with a new encrypted response, without re-prompting the user for a new username and password. The server SHOULD only set stale to true if it receives a request for which the nonce is invalid. If stale is false, or anything other than true, or the stale parameter is not present, the username and/or password are invalid, and new values MUST be obtained.",
      "ja": "大文字と小文字を区別しないフラグのnonce値が古くなったため、クライアントからの前の要求が拒否されたことを示します。古いがtrueの場合、クライアントは単に新しいユーザのユーザ名とパスワードを再プロンプトを表示せず、新しい暗号化された応答でリクエストを再試行することを望むかもしれません。それはnonceが無効である要求を受信した場合、サーバーは、唯一の真に古い設定すべきです。古いがfalse、または真、または古いパラメータ以外の場合は、ユーザー名および/またはパスワードが無効であり、そして新しい値を取得する必要があり、存在しません。"
    },
    {
      "indent": 3,
      "text": "algorithm",
      "ja": "アルゴリズム"
    },
    {
      "indent": 6,
      "text": "A string indicating an algorithm used to produce the digest and an unkeyed digest. If this is not present, it is assumed to be \"MD5\". If the algorithm is not understood, the challenge SHOULD be ignored (and a different one used, if there is more than one).",
      "ja": "ダイジェストとキーなしダイジェストを生成するために使用されるアルゴリズムを示す文字列。これが存在しない場合は、「MD5」であると想定されます。アルゴリズムが理解されていない場合は、挑戦は無視されるべきである（と複数ある場合は、別の一つは、使用されます）。"
    },
    {
      "indent": 6,
      "text": "When used with the Digest mechanism, each one of the algorithms has two variants: Session variant and non-Session variant. The non-Session variant is denoted by \"<algorithm>\", e.g., \"SHA-256\", and the Session variant is denoted by \"<algorithm>-sess\", e.g., \"SHA-256-sess\".",
      "ja": "セッションの変種と非セッションバリアント：ダイジェスト機構を使用すると、アルゴリズムの各1は、二つの変種があります。非セッション変異体「は、<アルゴリズム>」、例えば、「SHA-256」で示され、そしてセッション変異体「は、<アルゴリズム> -sess」、例えば、「SHA-256のSES」と表記されています。"
    },
    {
      "indent": 6,
      "text": "In this document, the string obtained by applying the digest algorithm to the data \"data\" with secret \"secret\" will be denoted by KD(secret, data), and the string obtained by applying the unkeyed digest algorithm to the data \"data\" will be denoted H(data). KD stands for Keyed Digest, and the notation unq(X) means the value of the quoted-string X without the surrounding quotes and with quoting slashes removed.",
      "ja": "この文書では、ストリングが秘密「秘密」KDで示されるであろう（秘密データ）とデータ「データ」にダイジェストアルゴリズムを適用することによって得られ、データ「データ」にダイジェストアルゴリズムキーなし適用して得られた文字列H（データ）を表すことにします。 KDは、キー付きダイジェストを表し、表記UNQ（X）は、周囲の引用符なし除去スラッシュを引用と引用文字列Xの値を意味します。"
    },
    {
      "indent": 8,
      "text": "For \"<algorithm>\" and \"<algorithm>-sess\"",
      "ja": "\"<アルゴリズム>\" と \"<アルゴリズム> -sess\" のために"
    },
    {
      "indent": 12,
      "text": "H(data) = <algorithm>(data)",
      "ja": "H（データ）= <アルゴリズム>（データ）"
    },
    {
      "indent": 8,
      "text": "and",
      "ja": "そして"
    },
    {
      "indent": 12,
      "text": "KD(secret, data) = H(concat(secret, \":\", data))",
      "ja": "KD（秘密、データ）= H（CONCAT（秘密、 \"：\"、データ））"
    },
    {
      "indent": 6,
      "text": "For example:",
      "ja": "例えば："
    },
    {
      "indent": 8,
      "text": "For the \"SHA-256\" and \"SHA-256-sess\" algorithms",
      "ja": "\"SHA-256\" と \"SHA-256-SESの\" アルゴリズムの"
    },
    {
      "indent": 12,
      "text": "H(data) = SHA-256(data)",
      "ja": "H（データ）= SHA-256（データ）"
    },
    {
      "indent": 6,
      "text": "i.e., the digest is the \"<algorithm>\" of the secret concatenated with a colon concatenated with the data. The \"<algorithm>-sess\" is intended to allow efficient third-party authentication servers; for the difference in usage, see the description in Section 3.4.2.",
      "ja": "すなわち、ダイジェストは、データと連結結腸と連結秘密の「<アルゴリズム>」です。 「<アルゴリズム> -sessは、」効率的なサードパーティの認証サーバーを可能にすることを意図しています。用法の違いのために、3.4.2項で説明を参照してください。"
    },
    {
      "indent": 3,
      "text": "qop",
      "ja": "袋"
    },
    {
      "indent": 6,
      "text": "This parameter MUST be used by all implementations. It is a quoted string of one or more tokens indicating the \"quality of protection\" values supported by the server. The value \"auth\" indicates authentication; the value \"auth-int\" indicates authentication with integrity protection. See the descriptions below for calculating the response parameter value for the application of this choice. Unrecognized options MUST be ignored.",
      "ja": "このパラメータは、すべての実装で使用しなければなりません。これは、サーバーでサポートされている「品質保護の」値を示す1つの以上のトークンの引用符で囲まれた文字列です。値「AUTHは、」認証を示します。値「のauth-intが」完全性保護と認証を示します。この選択のアプリケーションの応答パラメータ値を計算するため、以下の説明を参照してください。認識できないオプションは無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "charset",
      "ja": "文字セット"
    },
    {
      "indent": 6,
      "text": "This is an OPTIONAL parameter that is used by the server to indicate the encoding scheme it supports. The only allowed value is \"UTF-8\".",
      "ja": "これは、それがサポートする符号化方式を示すために、サーバーによって使用されるオプションのパラメータです。唯一許可された値は「UTF-8」です。"
    },
    {
      "indent": 3,
      "text": "userhash",
      "ja": "userhash"
    },
    {
      "indent": 6,
      "text": "This is an OPTIONAL parameter that is used by the server to indicate that it supports username hashing. Valid values are: \"true\" or \"false\". Default value is \"false\".",
      "ja": "これは、ユーザ名のハッシュをサポートしていることを示すために、サーバーによって使用されるオプションのパラメータです。有効な値は以下のとおりです。「true」または「false」。デフォルト値は「false」です。"
    },
    {
      "indent": 3,
      "text": "For historical reasons, a sender MUST only generate the quoted string syntax values for the following parameters: realm, domain, nonce, opaque, and qop.",
      "ja": "領域、ドメイン、ナンス、不透明、とQOP：歴史的な理由により、送信者は、次のパラメータのための引用符で囲まれた文字列の構文値を生成しなければなりません。"
    },
    {
      "indent": 3,
      "text": "For historical reasons, a sender MUST NOT generate the quoted string syntax values for the following parameters: stale and algorithm.",
      "ja": "古いアルゴリズム：歴史的な理由により、送信者は、次のパラメータの引用符で囲まれた文字列の構文値を生成してはなりません。"
    },
    {
      "indent": 0,
      "text": "3.4. The Authorization Header Field",
      "section_title": true,
      "ja": "3.4。認証ヘッダーフィールド"
    },
    {
      "indent": 3,
      "text": "The client is expected to retry the request, passing an Authorization header field line with Digest scheme, which is defined according to the framework above. The values of the opaque and algorithm fields must be those supplied in the WWW-Authenticate response header field for the entity being requested.",
      "ja": "クライアントは、上記フレームワークに従って定義されるダイジェスト方式とAuthorizationヘッダフィールドラインを通過する、要求を再試行することが期待されます。不透明なアルゴリズムフィールドの値は、要求されたエンティティのWWW認証応答ヘッダフィールドに供給されるものでなければなりません。"
    },
    {
      "indent": 3,
      "text": "The request can include parameters from the following list:",
      "ja": "リクエストは、以下のリストからパラメータを含めることができます。"
    },
    {
      "indent": 3,
      "text": "response",
      "ja": "応答"
    },
    {
      "indent": 6,
      "text": "A string of the hex digits computed as defined below; it proves that the user knows a password.",
      "ja": "以下に定義されるように計算進数字のストリング。それは、ユーザーがパスワードを知っていることを証明します。"
    },
    {
      "indent": 3,
      "text": "username",
      "ja": "ユーザ名"
    },
    {
      "indent": 6,
      "text": "The user's name in the specified realm. The quoted string contains the name in plaintext or the hash code in hexadecimal notation. If the username contains characters not allowed inside the ABNF quoted-string production, the username* parameter can be used. Sending both username and username* in the same header option MUST be treated as an error.",
      "ja": "指定されたレルム内のユーザーの名前。引用符で囲まれた文字列は、平文で名前または16進数でハッシュコードを含みます。ユーザ名はABNF引用符で囲まれた文字列の生産の内側に許可されていない文字が含まれている場合、ユーザ名*パラメータを使用することができます。同じヘッダオプションでユーザ名とユーザ名*の両方を送信することはエラーとして扱われなければなりません。"
    },
    {
      "indent": 3,
      "text": "username*",
      "ja": "ユーザー名*"
    },
    {
      "indent": 6,
      "text": "If the userhash parameter value is set \"false\" and the username contains characters not allowed inside the ABNF quoted-string production, the user's name can be sent with this parameter, using the extended notation defined in [RFC5987].",
      "ja": "userhashパラメータ値を「false」に設定すると、ユーザー名がABNF引用符で囲まれた文字列の生産の内側に許可されていない文字が含まれている場合は、ユーザーの名前が[RFC5987]で定義された拡張された表記法を使用して、このパラメータを指定して送信することができます。"
    },
    {
      "indent": 3,
      "text": "realm",
      "ja": "分野"
    },
    {
      "indent": 6,
      "text": "See \"realm\" definition in Section 3.3.",
      "ja": "3.3節で「王国」の定義を参照してください。"
    },
    {
      "indent": 3,
      "text": "uri",
      "ja": "売り"
    },
    {
      "indent": 6,
      "text": "The Effective Request URI (Section 5.5 of [RFC7230]) of the HTTP request; duplicated here because proxies are allowed to change the request target (\"request-target\", Section 3.1.1 of [RFC7230]) in transit.",
      "ja": "HTTPリクエストの有効リクエストURI（[RFC7230]のセクション5.5）。プロキシが輸送中に要求の対象（「リクエスト・ターゲット」、[RFC7230]のセクション3.1.1）を変更することが許可されているので、ここでは重複。"
    },
    {
      "indent": 3,
      "text": "qop",
      "ja": "袋"
    },
    {
      "indent": 6,
      "text": "Indicates what \"quality of protection\" the client has applied to the message. Its value MUST be one of the alternatives the server indicated it supports in the WWW-Authenticate header field. These values affect the computation of the response. Note that this is a single token, not a quoted list of alternatives as in WWW-Authenticate.",
      "ja": "クライアントは、メッセージに適用したもの「保護の品質」を示します。この値は、サーバーが、それはWWW-Authenticateヘッダフィールドでサポートされてい示された選択肢のうちの1つでなければなりません。これらの値は、応答の計算に影響を与えます。これは単一のトークンではなく、WWW認証のように、代替の引用されたリストであることに注意してください。"
    },
    {
      "indent": 3,
      "text": "cnonce",
      "ja": "cnonce"
    },
    {
      "indent": 6,
      "text": "This parameter MUST be used by all implementations. The cnonce value is an opaque quoted ASCII-only string value provided by the client and used by both client and server to avoid chosen plaintext attacks, to provide mutual authentication, and to provide some message integrity protection. See the descriptions below of the calculation of the rspauth and response values.",
      "ja": "このパラメータは、すべての実装で使用しなければなりません。 cnonce値は、クライアントによって提供され、相互認証を提供する、といくつかのメッセージの完全性保護を提供するために、選択平文攻撃を避けるために、クライアントとサーバーの両方で使用される不透明な引用されASCIIのみの文字列値です。 rspauthと応答値の計算の下の説明を参照してください。"
    },
    {
      "indent": 3,
      "text": "nc",
      "ja": "NC"
    },
    {
      "indent": 6,
      "text": "This parameter MUST be used by all implementations. The nc parameter stands for \"nonce count\". The nc value is the hexadecimal count of the number of requests (including the current request) that the client has sent with the nonce value in this request. For example, in the first request sent in response to a given nonce value, the client sends \"nc=00000001\". The purpose of this parameter is to allow the server to detect request replays by maintaining its own copy of this count -- if the same nc value is seen twice, then the request is a replay. See the description below of the construction of the response value.",
      "ja": "このパラメータは、すべての実装で使用しなければなりません。 NCパラメータは、「ナンス・カウント」の略です。 NC値は、クライアントがこの要求にナンス値を送信したことを（現在の要求を含む）のリクエスト数を16進数です。例えば、所与のノンス値に応じて送信された最初の要求では、クライアントは「NC = 00000001」を送信します。その後、要求が再生され、同じNC値が二度見されている場合 - このパラメータの目的は、サーバーがこのカウントの独自のコピーを維持することによって、要求のリプレイを検出することができるようにすることです。応答値の建設の以下の説明を参照してください。"
    },
    {
      "indent": 3,
      "text": "userhash",
      "ja": "userhash"
    },
    {
      "indent": 6,
      "text": "This OPTIONAL parameter is used by the client to indicate that the username has been hashed. Valid values are: \"true\" or \"false\". Default value is \"false\".",
      "ja": "このオプションパラメータは、ユーザ名がハッシュ化されたことを示すために、クライアントによって使用されます。有効な値は以下のとおりです。「true」または「false」。デフォルト値は「false」です。"
    },
    {
      "indent": 3,
      "text": "For historical reasons, a sender MUST only generate the quoted string syntax for the following parameters: username, realm, nonce, uri, response, cnonce, and opaque.",
      "ja": "ユーザ名、分野、ナンス、URI、応答、cnonce、及び不透明：歴史的な理由により、送信者は、次のパラメータのための引用符で囲まれた文字列の構文を生成しなければなりません。"
    },
    {
      "indent": 3,
      "text": "For historical reasons, a sender MUST NOT generate the quoted string syntax for the following parameters: algorithm, qop, and nc.",
      "ja": "アルゴリズム、QOP、およびNC：歴史的な理由により、送信者は、次のパラメータの引用符で囲まれた文字列の構文を生成してはなりません。"
    },
    {
      "indent": 3,
      "text": "If a parameter or its value is improper, or required parameters are missing, the proper response is a 4xx error code. If the response is invalid, then a login failure SHOULD be logged, since repeated login failures from a single client may indicate an attacker attempting to guess passwords. The server implementation SHOULD be careful with the information being logged so that it won't put a cleartext password (e.g., entered into the username field) into the log.",
      "ja": "パラメータまたはその値が不適切である、または必要なパラメータが含まれていない場合、適切な応答が4xxのエラーコードです。応答が無効の場合は、単一のクライアントからの繰り返しのログイン失敗がパスワードを推測しようとする攻撃を示す可能性があるため、ログインの失敗は、ログインする必要があります。それは平文パスワードを入れないように、サーバの実装は、ログの中に（例えば、ユーザ名フィールドに入力された）情報が記録されていると注意する必要があります。"
    },
    {
      "indent": 3,
      "text": "The definition of the response above indicates the encoding for its value. The following definitions show how the value is computed.",
      "ja": "上記応答の定義は、その値が符号化を示しています。以下の定義は、値が計算される方法を示しています。"
    },
    {
      "indent": 0,
      "text": "3.4.1. Response",
      "section_title": true,
      "ja": "3.4.1。応答"
    },
    {
      "indent": 3,
      "text": "If the qop value is \"auth\" or \"auth-int\":",
      "ja": "QOP値は、 \"認証\" または \"のauth-int型\" の場合："
    },
    {
      "indent": 9,
      "text": "response = <\"> < KD ( H(A1), unq(nonce)\n                             \":\" nc\n                             \":\" unq(cnonce)\n                             \":\" unq(qop)\n                             \":\" H(A2)\n                    ) <\">",
      "raw": true
    },
    {
      "indent": 3,
      "text": "See below for the definitions for A1 and A2.",
      "ja": "A1とA2の定義については、以下を参照してください。"
    },
    {
      "indent": 0,
      "text": "3.4.2. A1",
      "section_title": true,
      "ja": "3.4.2。 A1"
    },
    {
      "indent": 3,
      "text": "If the algorithm parameter's value is \"<algorithm>\", e.g., \"SHA-256\", then A1 is:",
      "ja": "アルゴリズムパラメータの値が「<アルゴリズム>」、例えば、「SHA-256」の場合、A1は次のようになります。"
    },
    {
      "indent": 9,
      "text": "A1 = unq(username) \":\" unq(realm) \":\" passwd",
      "ja": "A1 = UNQ（ユーザー名） \"：\" UNQ（領域） \"：\" passwdの"
    },
    {
      "indent": 3,
      "text": "where",
      "ja": "どこ"
    },
    {
      "indent": 9,
      "text": "passwd = < user's password >",
      "ja": "passwdファイル= <ユーザのパスワード>"
    },
    {
      "indent": 3,
      "text": "If the algorithm parameter's value is \"<algorithm>-sess\", e.g., \"SHA-256-sess\", then A1 is calculated using the nonce value provided in the challenge from the server, and cnonce value from the request by the client following receipt of a WWW-Authenticate challenge from the server. It uses the server nonce from that challenge, herein called nonce-prime, and the client nonce value from the response, herein called cnonce-prime, to construct A1 as follows:",
      "ja": "アルゴリズムパラメータの値が「<アルゴリズム> -sess」、例えば、「SHA-256-のSES」の場合は、A1は、以下のクライアントによって要求から、サーバからの挑戦で提供ナンス値、およびcnonce値を使用して計算されますサーバからWWW認証チャレンジの受信。それは次のようにA1を構築するために、ここcnonceプライムと呼ばれ、ここナンスプライムと呼ばれ、その攻撃からサーバnonceを使用し、応答からクライアントナンス値："
    },
    {
      "indent": 9,
      "text": "A1       = H( unq(username) \":\" unq(realm) \":\" passwd )\n               \":\" unq(nonce-prime) \":\" unq(cnonce-prime)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This creates a \"session key\" for the authentication of subsequent requests and responses that is different for each \"authentication session\", thus limiting the amount of material hashed with any one key. (Note: see further discussion of the authentication session in Section 3.6.) Because the server needs only use the hash of the user credentials in order to create the A1 value, this construction could be used in conjunction with a third-party authentication service so that the web server would not need the actual password value. The specification of such a protocol is beyond the scope of this specification.",
      "ja": "これは、このようにいずれかのキーを使用してハッシュ材料の量を制限し、それぞれの「認証セッション」で異なり、後続の要求と応答の認証のための「セッションキー」を作成します。 （注意：セクション3.6での認証セッションの更なる議論を参照）、サーバが唯一のA1の値を作成するために、ユーザーの資格情報のハッシュを使用する必要があるため、この構造はとてもサードパーティの認証サービスと組み合わせて使用​​することができますWebサーバは、実際のパスワード値を必要としないこと。そのようなプロトコルの仕様は、本明細書の範囲外です。"
    },
    {
      "indent": 0,
      "text": "3.4.3. A2",
      "section_title": true,
      "ja": "A.4.a. AA"
    },
    {
      "indent": 3,
      "text": "If the qop parameter's value is \"auth\" or is unspecified, then A2 is:",
      "ja": "QOPパラメータの値が「認証」であるか、指定されていない場合は、A2は次のようになります。"
    },
    {
      "indent": 9,
      "text": "A2 = Method \":\" request-uri",
      "ja": "A2 =メソッド \"：\" 要求URI"
    },
    {
      "indent": 3,
      "text": "If the qop value is \"auth-int\", then A2 is:",
      "ja": "QOP値が「のauth-int型」の場合は、A2は次のようになります。"
    },
    {
      "indent": 9,
      "text": "A2 = Method \":\" request-uri \":\" H(entity-body)",
      "ja": "A2 =法 \"：\" リクエストURI \"：\" H（エンティティ本体）"
    },
    {
      "indent": 0,
      "text": "3.4.4. Username Hashing",
      "section_title": true,
      "ja": "3.4.4。ユーザー名ハッシュ"
    },
    {
      "indent": 3,
      "text": "To protect the transport of the username from the client to the server, the server SHOULD set the userhash parameter with the value of \"true\" in the WWW-Authentication header field.",
      "ja": "クライアントからサーバへのユーザ名の輸送を保護するために、サーバはWWW認証ヘッダフィールドにおける「真」の値を持つuserhashパラメータを設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the client supports the userhash parameter, and the userhash parameter value in the WWW-Authentication header field is set to \"true\", then the client MUST calculate a hash of the username after any other hash calculation and include the userhash parameter with the value of \"true\" in the Authorization header field. If the client does not provide the username as a hash value or the userhash parameter with the value of \"true\", the server MAY reject the request.",
      "ja": "クライアントはuserhashパラメータをサポートし、WWW認証ヘッダフィールド内userhashパラメータの値が「真」に設定されている場合、クライアントは、他のハッシュ計算後にユーザ名のハッシュを計算し、値を持つuserhashパラメータを含まなければならない場合Authorizationヘッダフィールドに「真」の。クライアントは、ハッシュ値または「真」の値を持つuserhashパラメータとしてユーザ名を提供しない場合、サーバーはその要求を拒否することがあります。"
    },
    {
      "indent": 3,
      "text": "The following is the operation that the client will perform to hash the username, using the same algorithm used to hash the credentials:",
      "ja": "以下は、クライアントが資格情報をハッシュするために使用したのと同じアルゴリズムを使用して、ユーザ名をハッシュするために実行される処理です。"
    },
    {
      "indent": 6,
      "text": "username = H( unq(username) \":\" unq(realm) )",
      "ja": "ユーザ名= H（UNQ（ユーザー名） \"：\" UNQ（領域））"
    },
    {
      "indent": 0,
      "text": "3.4.5. Parameter Values and Quoted-String",
      "section_title": true,
      "ja": "3.4.5。パラメータ値と引用符で囲まれた文字列、"
    },
    {
      "indent": 3,
      "text": "Note that the value of many of the parameters, such as username value, are defined as a \"quoted-string\". However, the \"unq\" notation indicates that surrounding quotation marks are removed in forming the string A1. Thus, if the Authorization header field includes the fields",
      "ja": "そのようなユーザ名値などのパラメータの多くの値は、「引用符で囲まれた文字列」として定義されていることに注意してください。しかし、「UNQ」表記は、周囲の引用符は、文字列A1を形成する際に除去されることを示しています。したがって、Authorizationヘッダフィールドは、フィールドが含まれる場合"
    },
    {
      "indent": 6,
      "text": "username=\"Mufasa\", realm=\"myhost@example.com\"",
      "ja": "ユーザ名= \"ムファサ\"、領域= \"myhost@example.com\""
    },
    {
      "indent": 3,
      "text": "and the user Mufasa has password \"Circle Of Life\", then H(A1) would be H(Mufasa:myhost@example.com:Circle Of Life) with no quotation marks in the digested string.",
      "ja": "消化された文字列の引用符なしで、ユーザームファサは「生命のサークル」パスワードを持っている、そしてH（A1）は、H（ライフサークル：myhost@example.comムファサ）になります。"
    },
    {
      "indent": 3,
      "text": "No white space is allowed in any of the strings to which the digest function H() is applied, unless that white space exists in the quoted strings or entity body whose contents make up the string to be digested. For example, the string A1 illustrated above must be",
      "ja": "そのホワイトスペースは、そのコンテンツの文字列を構成して消化される引用符で囲まれた文字列またはエンティティボディ内に存在しない限り、ホワイトスペースは、そのダイジェスト関数H（）が適用される文字列のいずれかで許可されていません。例えば、A1は、上に示した文字列でなければなりません"
    },
    {
      "indent": 6,
      "text": "Mufasa:myhost@example.com:Circle Of Life",
      "ja": "ムファサ：myhost@example.com：生命のサークル"
    },
    {
      "indent": 3,
      "text": "with no white space on either side of the colons, but with the white space between the words used in the password value. Likewise, the other strings digested by H() must not have white space on either side of the colons that delimit their fields, unless that white space was in the quoted strings or entity body being digested.",
      "ja": "コロンのいずれかの側で空白ではなく、パスワード値で使われる単語間の空白を持ちます。その空白が消化されている引用符で囲まれた文字列またはエンティティボディにあった場合を除き同様に、H（）によって消化された他の文字列は、そのフィールドを区切るコロンの両側に空白があってはなりません。"
    },
    {
      "indent": 3,
      "text": "Also, note that if integrity protection is applied (qop=auth-int), the H(entity-body) is the hash of the entity body, not the message body -- it is computed before any transfer encoding is applied by the sender and after it has been removed by the recipient. Note that this includes multipart boundaries and embedded header fields in each part of any multipart content-type.",
      "ja": "任意転送符号化が送信者によって適用される前にそれが計算される - も、完全性保護が（QOP = AUTH-INT）が適用される場合、H（エンティティボディ）はエンティティボディのハッシュではなく、メッセージ本体であることに注意そして後には、受信者によって削除されました。これは、マルチパート境界および任意のマルチコンテンツ・タイプの各部分に埋め込まれたヘッダフィールドを含むことに留意されたいです。"
    },
    {
      "indent": 0,
      "text": "3.4.6. Various Considerations",
      "section_title": true,
      "ja": "3.4.6。様々な考慮事項"
    },
    {
      "indent": 3,
      "text": "The \"Method\" value is the HTTP request method, in US-ASCII letters, as specified in Section 3.1.1 of [RFC7230]. The \"request-target\" value is the request-target from the request line as specified in Section 3.1.1 of [RFC7230]. This MAY be \"*\", an \"absolute-URI\", or an \"absolute-path\" as specified in Section 2.7 of [RFC7230], but it MUST agree with the request-target. In particular, it MUST be an \"absolute-URI\" if the request-target is an \"absolute-URI\". The cnonce value is a client-chosen value whose purpose is to foil chosen plaintext attacks.",
      "ja": "[RFC7230]のセクション3.1.1で指定されるように、「メソッド」値は、US-ASCII文字で、HTTPリクエストメソッドです。 [RFC7230]のセクション3.1.1で指定されるように「要求目標」値は、要求ラインからの要求対象です。 [RFC7230]のセクション2.7で指定されたように、これは、「*」、「絶対URI」、または「絶対パス」かもしれないが、それは、要求のターゲットと同意しなければなりません。リクエスト対象「は絶対URI」である場合に特に、それは、「絶対URI」でなければなりません。 cnonce値は、その目的は選ばれた平文攻撃を箔にあるクライアントに選択された値です。"
    },
    {
      "indent": 3,
      "text": "The authenticating server MUST assure that the resource designated by the \"uri\" parameter is the same as the resource specified in the Request-Line; if they are not, the server SHOULD return a 400 Bad Request error. (Since this may be a symptom of an attack, server implementers may want to consider logging such errors.) The purpose of duplicating information from the request URL in this field is to deal with the possibility that an intermediate proxy may alter the client's Request-Line. This altered (but presumably semantically equivalent) request would not result in the same digest as that calculated by the client.",
      "ja": "認証サーバは、「URI」パラメータで指定されたリソースが、リクエストラインで指定されたリソースと同じであることを保証しなければなりません。そうでない場合、サーバは400不正な要求エラーを返すべきです。 （これは攻撃の兆候かもしれないので、サーバーの実装者は、このようなエラーを記録することを検討してください。）このフィールドには、リクエストURLから情報を複製する目的は、中間プロキシが、クライアントの要求 - を変更することができるという可能性に対処するためでありますライン。この改変された（しかしおそらく意味的に等価な）要求が同じクライアントによって計算されるようなダイジェストをもたらさないであろう。"
    },
    {
      "indent": 3,
      "text": "Implementers should be aware of how authenticated transactions need to interact with shared caches (see [RFC7234]).",
      "ja": "実装者は、認証されたトランザクションが共有キャッシュ（[RFC7234]を参照）と対話する必要があるかを知っておく必要があります。"
    },
    {
      "indent": 0,
      "text": "3.5. The Authentication-Info and Proxy-Authentication-Info Header Fields",
      "ja": "3.5。認証-情報およびプロキシ認証 - 情報ヘッダフィールド"
    },
    {
      "indent": 3,
      "text": "The Authentication-Info header field and the Proxy-Authentication-Info header field [RFC7615] are generic fields that MAY be used by a server to communicate some information regarding the successful authentication of a client response.",
      "ja": "認証-Infoヘッダフィールドとプロキシ認証-Infoヘッダフィールド[RFC7615]クライアントの応答の成功した認証に関するいくつかの情報を通信するためにサーバによって使用されるかもしれ汎用フィールドです。"
    },
    {
      "indent": 3,
      "text": "The Digest Authentication scheme MAY add the Authentication-Info header field in the confirmation request and include parameters from the following list:",
      "ja": "ダイジェスト認証方式は、確認要求に認証-Infoヘッダーフィールドを追加し、以下のリストからパラメータを含むことができます。"
    },
    {
      "indent": 3,
      "text": "nextnonce",
      "ja": "nextnonce"
    },
    {
      "indent": 6,
      "text": "The value of the nextnonce parameter is the nonce the server wishes the client to use for a future authentication response. The server MAY send the Authentication-Info header field with a nextnonce field as a means of implementing one-time nonces or otherwise changing nonces. If the nextnonce field is present, the client SHOULD use it when constructing the Authorization header field for its next request. Failure of the client to do so MAY result in a request to re-authenticate from the server with the \"stale=true\".",
      "ja": "nextnonceパラメータの値は、サーバは、クライアントが将来の認証応答のために使用したいナンスです。サーバは、ワンタイムノンスを実装またはその他のナンスを変化させる手段としてnextnonceフィールドと認証-Infoヘッダフィールドを送ることができます。 nextnonceフィールドが存在する場合はその次の要求のためにAuthorizationヘッダフィールドを構築する際に、クライアントはそれを使用する必要があります。そうしないと、クライアントの失敗は、「古い= true」を持つサーバから再認証するように要求することがあります。"
    },
    {
      "indent": 9,
      "text": "Server implementations SHOULD carefully consider the performance implications of the use of this mechanism; pipelined requests will not be possible if every response includes a nextnonce parameter that MUST be used on the next request received by the server. Consideration SHOULD be given to the performance vs. security tradeoffs of allowing an old nonce value to be used for a limited time to permit request pipelining. Use of the nc parameter can retain most of the security advantages of a new server nonce without the deleterious effects on pipelining.",
      "ja": "サーバ実装は慎重にこのメカニズムの使用のパフォーマンスへの影響を考慮する必要があります。すべての応答は、サーバが受信した次のリクエストで使用する必要がありnextnonceパラメータが含まれている場合、パイプラインの要求はできません。対価は、要求パイプライン化を可能にするために、限られた時間のために使用される古いナンス値を可能にするセキュリティトレードオフのパフォーマンスに与えられるべきです。 NCパラメータを使用すると、パイプラインへの悪影響なしに新しいサーバナンスのセキュリティ上の利点のほとんどを維持することができます。"
    },
    {
      "indent": 3,
      "text": "qop",
      "ja": "袋"
    },
    {
      "indent": 6,
      "text": "Indicates the \"quality of protection\" options applied to the response by the server. The value \"auth\" indicates authentication; the value \"auth-int\" indicates authentication with integrity protection. The server SHOULD use the same value for the qop parameter in the response as was sent by the client in the corresponding request.",
      "ja": "サーバーの応答に適用される「保護の品質」のオプションを示します。値「AUTHは、」認証を示します。値「のauth-intが」完全性保護と認証を示します。対応する要求でクライアントから送信されたように、サーバーが応答してQOPパラメータに同じ値を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "rspauth",
      "ja": "rspauth"
    },
    {
      "indent": 6,
      "text": "The optional response digest in the rspauth parameter supports mutual authentication -- the server proves that it knows the user's secret, and with qop=auth-int also provides limited integrity protection of the response. The rspauth value is calculated as for the response in the Authorization header field, except that if qop is set to \"auth\" or is not specified in the Authorization header field for the request, A2 is",
      "ja": "オプションの応答rspauthパラメータでダイジェストは、相互認証をサポートしています - サーバーは、ユーザーの秘密を知っていることを証明し、QOP =のauth-int型でも、応答の限定された完全性保護を提供します。 QOPが「認証」に設定されているか、要求のAuthorizationヘッダフィールドで指定されていない場合rspauth値はことを除いては、Authorizationヘッダフィールドの応答のためのように計算され、A2は"
    },
    {
      "indent": 9,
      "text": "A2 = \":\" request-uri",
      "ja": "A2 = \"：\" 要求URI"
    },
    {
      "indent": 6,
      "text": "and if \"qop=auth-int\", then A2 is",
      "ja": "\"QOP =のauth-int型\" 場合と、その後、A2は、"
    },
    {
      "indent": 9,
      "text": "A2 = \":\" request-uri \":\" H(entity-body)",
      "ja": "A2 = \"：\" 要求URI \"：\" H（エンティティボディ）"
    },
    {
      "indent": 3,
      "text": "cnonce and nc",
      "ja": "cnonceとNC"
    },
    {
      "indent": 6,
      "text": "The cnonce value and nc value MUST be the ones for the client request to which this message is the response. The rspauth, cnonce, and nc parameters MUST be present if \"qop=auth\" or \"qop=auth-int\" is specified.",
      "ja": "cnonce値とNC値は、このメッセージが応答であるにクライアント要求のためのものでなければなりません。 \"QOP = AUTH\" または \"QOP = AUTH-INT\" が指定されている場合rspauth、cnonce、及びNCパラメータが存在しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The Authentication-Info header field is allowed in the trailer of an HTTP message transferred via chunked transfer coding.",
      "ja": "認証-Infoヘッダフィールドは、チャンク転送符号化を介して転送されたHTTPメッセージのトレーラーで許可されています。"
    },
    {
      "indent": 3,
      "text": "For historical reasons, a sender MUST only generate the quoted string syntax for the following parameters: nextnonce, rspauth, and cnonce.",
      "ja": "nextnonce、rspauth、およびcnonce：歴史的な理由により、送信者は、次のパラメータのための引用符で囲まれた文字列の構文を生成しなければなりません。"
    },
    {
      "indent": 3,
      "text": "For historical reasons, a sender MUST NOT generate the quoted string syntax for the following parameters: qop and nc.",
      "ja": "QOPとNC：歴史的な理由により、送信者は、次のパラメータの引用符で囲まれた文字列の構文を生成してはなりません。"
    },
    {
      "indent": 3,
      "text": "For historical reasons, the nc value MUST be exactly 8 hexadecimal digits.",
      "ja": "歴史的な理由のために、NC値は正確に8桁の16進数でなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.6. Digest Operation",
      "section_title": true,
      "ja": "3.6。ダイジェスト操作"
    },
    {
      "indent": 3,
      "text": "Upon receiving the Authorization header field, the server MAY check its validity by looking up the password that corresponds to the submitted username. Then, the server MUST perform the same digest operation (e.g., MD5, SHA-256) performed by the client and compare the result to the given response value.",
      "ja": "Authorizationヘッダフィールドを受信すると、サーバは、送信されたユーザ名に対応するパスワードを調べることによって、その有効性を確認することができます。次いで、サーバはダイジェスト操作（例えば、MD5、SHA-256）は、クライアントによって実行されると指定された応答値と結果を比較し、同じを実行しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Note that the HTTP server does not actually need to know the user's cleartext password. As long as H(A1) is available to the server, the validity of an Authorization header field can be verified.",
      "ja": "HTTPサーバは、実際のユーザーの平文パスワードを知っている必要はないことに注意してください。限り、H（A1）がサーバに利用可能であるように、Authorizationヘッダフィールドの妥当性を検証することができます。"
    },
    {
      "indent": 3,
      "text": "The client response to a WWW-Authenticate challenge for a protection space starts an authentication session with that protection space. The authentication session lasts until the client receives another WWW-Authenticate challenge from any server in the protection space. A client SHOULD remember the username, password, nonce, nonce count, and opaque values associated with an authentication session to use to construct the Authorization header field in future requests within that protection space. The Authorization header field MAY be included preemptively; doing so improves server efficiency and avoids extra round trips for authentication challenges. The server MAY choose to accept the old Authorization header field information, even though the nonce value included might not be fresh. Alternatively, the server MAY return a 401 response with a new nonce value in the WWW-Authenticate header field, causing the client to retry the request; by specifying \"stale=true\" with this response, the server tells the client to retry with the new nonce, but without prompting for a new username and password.",
      "ja": "保護空間のためのWWW認証チャレンジに対するクライアントの応答は、その保護空間との認証セッションを開始します。クライアントは、保護空間内の任意のサーバーから別のWWW認証チャレンジを受信するまで認証セッションが続きます。クライアントは、ユーザー名、パスワード、ナンス、ナンス数、およびその保護空間内の将来の要求にAuthorizationヘッダフィールドを構築するために使用する認証セッションに関連付けられた不透明な値を覚えておく必要があります。 Authorizationヘッダフィールドは、優先的に含まれるかもしれません。そうすることは、サーバーの効率を向上させ、認証チャレンジのための余分なラウンドトリップを回避します。サーバが含まナンス値が新鮮ではないかもしれないにもかかわらず、古いAuthorizationヘッダフィールド情報を受け入れることを選ぶかもしれません。代替的に、サーバは、クライアントが要求を再試行させ、WWW-Authenticateヘッダフィールドに新しいノンス値と401応答を返すかもしれ。この応答で、「古い= true」を指定することで、サーバは、新しいユーザ名とパスワードの入力を求めることなく、新しいナンスを再試行するようにクライアントに指示します。"
    },
    {
      "indent": 3,
      "text": "Because the client is required to return the value of the opaque parameter given to it by the server for the duration of a session, the opaque data can be used to transport authentication session state information. (Note that any such use can also be accomplished more easily and safely by including the state in the nonce.) For example, a server could be responsible for authenticating content that actually sits on another server. It would achieve this by having the first 401 response include a domain parameter whose value includes a URI on the second server, and an opaque parameter whose value contains the state information. The client will retry the request, at which time the server might respond with \"HTTP Redirection\" (Section 6.4 of [RFC7231]), pointing to the URI on the second server. The client will follow the redirection and pass an Authorization header field, including the <opaque> data.",
      "ja": "クライアントは、セッションの間、サーバによってそれに与えられた不透明なパラメータの値を返すために必要とされるため、不透明なデータは、認証セッション状態情報を転送するために使用することができます。 （そのような使用もナンス状態を含めることにより、より容易かつ安全に行うことができることに留意されたい。）例えば、サーバは、実際には別のサーバ上に座ったコンテンツを認証する責任を負うかもしれません。これは、最初の401応答は、その値が第二のサーバ上のURIを含むドメインパラメーター、およびその値の状態情報を含んでいる不透明なパラメータを含んで有することによって、これを達成するであろう。クライアントは、第二のサーバ上のURIを指し、サーバは「HTTPリダイレクト」（[RFC7231]の6.4節）で応答可能性がある時点で、要求を再試行します。クライアントは、リダイレクトに従い、<不透明>データを含む、Authorizationヘッダフィールドを通過します。"
    },
    {
      "indent": 3,
      "text": "Proxies MUST be completely transparent in the Digest access authentication scheme. That is, they MUST forward the WWW-Authenticate, Authentication-Info, and Authorization header fields untouched. If a proxy wants to authenticate a client before a request is forwarded to the server, it can be done using the Proxy-Authenticate and Proxy-Authorization header fields described in Section 3.8 below.",
      "ja": "プロキシは、ダイジェストアクセス認証スキームでは完全に透明でなければなりません。つまり、彼らはそのままWWW認証、認証、情報、およびAuthorizationヘッダフィールドを転送する必要があります。プロキシは、要求をサーバに転送される前にクライアントを認証したい場合は、プロキシ認証および以下のセクション3.8で説明したプロキシ認証ヘッダフィールドを使用して行うことができます。"
    },
    {
      "indent": 0,
      "text": "3.7. Security Protocol Negotiation",
      "section_title": true,
      "ja": "3.7。セキュリティプロトコルのネゴシエーション"
    },
    {
      "indent": 3,
      "text": "It is useful for a server to be able to know which security schemes a client is capable of handling.",
      "ja": "サーバは、クライアントが処理可能であるセキュリティ方式を知ることができることは便利です。"
    },
    {
      "indent": 3,
      "text": "It is possible that a server wants to require Digest as its authentication method, even if the server does not know that the client supports it. A client is encouraged to fail gracefully if the server specifies only authentication schemes it cannot handle.",
      "ja": "サーバーは、サーバーは、クライアントがそれをサポートしていることを知らなくても、その認証方法としてダイジェストを要求したいことも可能です。クライアントは、サーバが処理できない唯一の認証スキームを指定する場合は正常に失敗することが奨励されます。"
    },
    {
      "indent": 3,
      "text": "When a server receives a request to access a resource, the server might challenge the client by responding with \"401 Unauthorized\" response and include one or more WWW-Authenticate header fields. If the server responds with multiple challenges, then each one of these challenges MUST use a different digest algorithm. The server MUST add these challenges to the response in order of preference, starting with the most preferred algorithm, followed by the less preferred algorithm.",
      "ja": "サーバがリソースへのアクセス要求を受信すると、サーバは「401無許可」応答で応答することで、クライアントに挑戦し、一つ以上のWWW-Authenticateヘッダフィールドを含めることができます。サーバーが複数の課題に応答した場合、その後、これらの課題の一つ一つが異なるダイジェストアルゴリズムを使用する必要があります。サーバーは、あまり好ましいアルゴリズムが続く最も好ましいアルゴリズムで始まる、優先順に応答するこれらの課題を追加しなければなりません。"
    },
    {
      "indent": 3,
      "text": "This specification defines the following algorithms:",
      "ja": "この仕様は、次のアルゴリズムを定義します。"
    },
    {
      "indent": 3,
      "text": "o SHA2-256 (mandatory to implement)",
      "ja": "O SHA2-256（実装するために必須）"
    },
    {
      "indent": 3,
      "text": "o SHA2-512/256 (as a backup algorithm)",
      "ja": "O SHA2-512 / 256（バックアップ・アルゴリズムのような）"
    },
    {
      "indent": 3,
      "text": "o MD5 (for backward compatibility).",
      "ja": "MD5（下位互換性のため）O。"
    },
    {
      "indent": 3,
      "text": "When the client receives the first challenge, it SHOULD use the first challenge it supports, unless a local policy dictates otherwise.",
      "ja": "クライアントが最初のチャレンジを受信すると、ローカルポリシーが示されない限り、それは、それがサポートする最初の挑戦を使用すべきです。"
    },
    {
      "indent": 0,
      "text": "3.8. Proxy-Authenticate and Proxy-Authorization",
      "section_title": true,
      "ja": "3.8。プロキシ認証およびプロキシ認証"
    },
    {
      "indent": 3,
      "text": "The Digest Authentication scheme can also be used for authenticating users to proxies, proxies to proxies, or proxies to origin servers by use of the Proxy-Authenticate and Proxy-Authorization header fields. These header fields are instances of the Proxy-Authenticate and Proxy-Authorization header fields specified in Sections 4.3 and 4.4 of the HTTP/1.1 specification [RFC7235], and their behavior is subject to restrictions described there. The transactions for proxy authentication are very similar to those already described. Upon receiving a request that requires authentication, the proxy/server MUST issue the \"407 Proxy Authentication Required\" response with a \"Proxy-Authenticate\" header field. The digest-challenge used in the Proxy-Authenticate header field is the same as that for the WWW-Authenticate header field as defined above in Section 3.3.",
      "ja": "ダイジェスト認証方式は、プロキシ認証およびプロキシ認証ヘッダフィールドを用いてオリジンサーバに、プロキシにユーザを認証するためのプロキシにプロキシ、またはプロキシを使用することができます。これらのヘッダーフィールドは、セクション4.3およびHTTP / 1.1仕様書[RFC7235]の4.4に指定されたプロキシ認証およびプロキシ認証ヘッダフィールドのインスタンスであり、その動作は、そこに記載の制限を受けます。プロキシ認証のための取引は、すでに説明したものと非常によく似ています。認証を必要とする要求を受信すると、プロキシ/サーバは、「プロキシ認証」ヘッダフィールドと「407プロキシ認証が必要」の応答を発行しなければなりません。プロキシ認証ヘッダフィールドに使用されるダイジェストチャレンジは、セクション3.3で上記に定義したWWW-Authenticateヘッダフィールドと同じです。"
    },
    {
      "indent": 3,
      "text": "The client/proxy MUST then reissue the request with a Proxy-Authorization header field, with parameters as specified for the Authorization header field in Section 3.4 above.",
      "ja": "上記セクション3.4でAuthorizationヘッダフィールドに指定されたクライアント/プロキシは次いで、パラメータを用いて、Proxy-Authorizationヘッダフィールドで要求を再発行しなければなりません。"
    },
    {
      "indent": 3,
      "text": "On subsequent responses, the server sends Proxy-Authentication-Info with parameters the same as those for the Authentication-Info header field.",
      "ja": "その後の応答に、サーバは認証-Infoヘッダフィールドと同じパラメータを使用してプロキシ認証、情報を送信します。"
    },
    {
      "indent": 3,
      "text": "Note that, in principle, a client could be asked to authenticate itself to both a proxy and an end-server, but never in the same response.",
      "ja": "原則的に、クライアントは決して同じ応答では、プロキシとエンドサーバーの両方に自分自身を認証するように要求することができ、ことに注意してください。"
    },
    {
      "indent": 0,
      "text": "3.9. Examples",
      "section_title": true,
      "ja": "3.9。例"
    },
    {
      "indent": 0,
      "text": "3.9.1. Example with SHA-256 and MD5",
      "section_title": true,
      "ja": "3.9.1。 SHA-256およびMD5と実施例"
    },
    {
      "indent": 3,
      "text": "The following example assumes that an access-protected document is being requested from the server via a GET request. The URI of the document is \"http://www.example.org/dir/index.html\". Both client and server know that the username for this document is \"Mufasa\" and the password is \"Circle of Life\" (with one space between each of the three words).",
      "ja": "次の例では、アクセス保護された文書はGETリクエストを介してサーバから要求されていることを前提としています。文書のURIは「http://www.example.org/dir/index.html」です。クライアントとサーバの両方が、この文書のユーザー名は「ムファサ」で、パスワードは（三つの言葉のそれぞれの間に1つのスペースで）「生命のサークル」であることを知っています。"
    },
    {
      "indent": 3,
      "text": "The first time the client requests the document, no Authorization header field is sent, so the server responds with:",
      "ja": "クライアントがドキュメントを要求初めて、何のAuthorizationヘッダフィールドは送信されませんので、サーバがで応答します。"
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 401 Unauthorized WWW-Authenticate: Digest realm=\"http-auth@example.org\", qop=\"auth, auth-int\", algorithm=SHA-256, nonce=\"7ypf/xlj9XXwfDPEoM4URrv/xwf94BcCAzFZH4GiTo0v\", opaque=\"FQhe/qaU925kfnzjCev0ciny7QMkPqMAFRtzCUYo5tdS\" WWW-Authenticate: Digest realm=\"http-auth@example.org\", qop=\"auth, auth-int\", algorithm=MD5, nonce=\"7ypf/xlj9XXwfDPEoM4URrv/xwf94BcCAzFZH4GiTo0v\", opaque=\"FQhe/qaU925kfnzjCev0ciny7QMkPqMAFRtzCUYo5tdS\"",
      "ja": "HTTP / 1.1 401不正なWWW認証：ダイジェスト分野= \"http-auth@example.org\"、QOP = \"AUTH、AUTH-INT\"、アルゴリズム= SHA-256、ナンス= \"7ypf / xlj9XXwfDPEoM4URrv / xwf94BcCAzFZH4GiTo0v\"、不透明= \"FQHE / qaU925kfnzjCev0ciny7QMkPqMAFRtzCUYo5tdS\" WWW認証：ダイジェスト分野= \"http-auth@example.org\"、QOP = \"AUTH、AUTH-INT\"、アルゴリズム= MD5、ナンス= \"7ypf / xlj9XXwfDPEoM4URrv / xwf94BcCAzFZH4GiTo0v\"、= \"FQHE不透明/ qaU925kfnzjCev0ciny7QMkPqMAFRtzCUYo5tdS」"
    },
    {
      "indent": 3,
      "text": "The client can prompt the user for their username and password, after which it will respond with a new request, including the following Authorization header field if the client chooses MD5 digest:",
      "ja": "クライアントは、クライアントがMD5ダイジェストを選択した場合、それは以下のAuthorizationヘッダフィールドを含む新しい要求と応答する後、ユーザー名とパスワードの入力をユーザーに求めることができます。"
    },
    {
      "indent": 3,
      "text": "Authorization: Digest username=\"Mufasa\", realm=\"http-auth@example.org\", uri=\"/dir/index.html\", algorithm=MD5, nonce=\"7ypf/xlj9XXwfDPEoM4URrv/xwf94BcCAzFZH4GiTo0v\", nc=00000001, cnonce=\"f2/wE4q74E6zIJEtWaHKaf5wv/H5QzzpXusqGemxURZJ\", qop=auth, response=\"8ca523f5e9506fed4657c9700eebdbec\", opaque=\"FQhe/qaU925kfnzjCev0ciny7QMkPqMAFRtzCUYo5tdS\"",
      "ja": "認証：ダイジェストユーザ名= \"ムファサ\"、領域= \"http-auth@example.org\"、URI = \"/ DIR / index.htmlを\"、00000001を= NCアルゴリズム= MD5、ナンス= \"7ypf / xlj9XXwfDPEoM4URrv / xwf94BcCAzFZH4GiTo0v\"、 cnonce = \"F2 / wE4q74E6zIJEtWaHKaf5wv / H5QzzpXusqGemxURZJ\"、QOP = AUTH、レスポンス= \"8ca523f5e9506fed4657c9700eebdbec\"、不透明= \"FQHE / qaU925kfnzjCev0ciny7QMkPqMAFRtzCUYo5tdS\""
    },
    {
      "indent": 3,
      "text": "If the client chooses to use the SHA-256 algorithm for calculating the response, the client responds with a new request including the following Authorization header field:",
      "ja": "クライアントが応答を計算するためにSHA-256アルゴリズムを使用することを選択した場合、クライアントは以下のAuthorizationヘッダフィールドを含む新しい要求に応答します。"
    },
    {
      "indent": 3,
      "text": "Authorization: Digest username=\"Mufasa\", realm=\"http-auth@example.org\", uri=\"/dir/index.html\", algorithm=SHA-256, nonce=\"7ypf/xlj9XXwfDPEoM4URrv/xwf94BcCAzFZH4GiTo0v\", nc=00000001, cnonce=\"f2/wE4q74E6zIJEtWaHKaf5wv/H5QzzpXusqGemxURZJ\", qop=auth, response=\"753927fa0e85d155564e2e272a28d1802ca10daf449 6794697cf8db5856cb6c1\", opaque=\"FQhe/qaU925kfnzjCev0ciny7QMkPqMAFRtzCUYo5tdS\"",
      "ja": "認証：ダイジェストユーザ名= \"ムファサ\"、領域= \"http-auth@example.org\"、URI = \"/ DIR / index.htmlを\"、アルゴリズム= SHA-256、ナンス= \"7ypf / xlj9XXwfDPEoM4URrv / xwf94BcCAzFZH4GiTo0v\"、NC = 00000001、cnonce = \"F2 / wE4q74E6zIJEtWaHKaf5wv / H5QzzpXusqGemxURZJ\"、QOP = AUTH、レスポンス= \"753927fa0e85d155564e2e272a28d1802ca10daf449 6794697cf8db5856cb6c1\"、不透明= \"FQHE / qaU925kfnzjCev0ciny7QMkPqMAFRtzCUYo5tdS\""
    },
    {
      "indent": 0,
      "text": "3.9.2. Example with SHA-512-256, Charset, and Userhash",
      "section_title": true,
      "ja": "3.9.2。 SHA-512から256、文字セット、およびUserhashと実施例"
    },
    {
      "indent": 3,
      "text": "The following example assumes that an access-protected document is being requested from the server via a GET request. The URI for the request is \"http://api.example.org/doe.json\". Both client and server know the userhash of the username, support the UTF-8 character encoding scheme, and use the SHA-512-256 algorithm. The username for the request is a variation of \"Jason Doe\", where the 'a' actually is Unicode code point U+00E4 (\"LATIN SMALL LETTER A WITH DIAERESIS\"), and the first 'o' is Unicode code point U+00F8 (\"LATIN SMALL LETTER O WITH STROKE\"), leading to the octet sequence using the UTF-8 encoding scheme:",
      "ja": "次の例では、アクセス保護された文書はGETリクエストを介してサーバから要求されていることを前提としています。リクエストのURIは、「http://api.example.org/doe.json」です。クライアントとサーバの両方がUTF-8文字符号化方式をサポートし、ユーザ名のuserhashを知っている、とSHA-512から256のアルゴリズムを使用します。要求のためのユーザ名が「」、実際にUnicodeコード・ポイントU + 00E4（「分音記号付きラテン小文字A」）であり、第1の「O」はUnicodeコード・ポイントU +である「ジェイソンドウ」の変形であります00F8（「STROKE付きラテン小文字O」）、UTF-8符号化スキームを使用して、オクテット配列をもたらします。"
    },
    {
      "indent": 6,
      "text": "J U+00E4 s U+00F8 n D o e 4A C3A4 73 C3B8 6E 20 44 6F 65",
      "ja": "E 4A C3A4 73 C3B8 6E 20 44 6F 65 O J U + 00E4 S U + 00F8 N D"
    },
    {
      "indent": 3,
      "text": "The password is \"Secret, or not?\".",
      "ja": "パスワードは、「秘密の、かどうか？」です。"
    },
    {
      "indent": 3,
      "text": "The first time the client requests the document, no Authorization header field is sent, so the server responds with:",
      "ja": "クライアントがドキュメントを要求初めて、何のAuthorizationヘッダフィールドは送信されませんので、サーバがで応答します。"
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 401 Unauthorized WWW-Authenticate: Digest realm=\"api@example.org\", qop=\"auth\", algorithm=SHA-512-256, nonce=\"5TsQWLVdgBdmrQ0XsxbDODV+57QdFR34I9HAbC/RVvkK\", opaque=\"HRPCssKJSGjCrkzDg8OhwpzCiGPChXYjwrI2QmXDnsOS\", charset=UTF-8, userhash=true",
      "ja": "HTTP / 1.1 401不正WWW認証：レルム= \"api@example.org\"、QOP = \"認証\"、ダイジェストアルゴリズム= SHA-512から256、ノンス= \"5TsQWLVdgBdmrQ0XsxbDODV + 57QdFR34I9HAbC / RVvkK\"、不透明= \"HRPCssKJSGjCrkzDg8OhwpzCiGPChXYjwrI2QmXDnsOS\"、文字セット= UTF-8、userhash =真"
    },
    {
      "indent": 3,
      "text": "The client can prompt the user for the required credentials and send a new request with following Authorization header field:",
      "ja": "クライアントは必要な資格をユーザーに要求し、次のAuthorizationヘッダーフィールドを使用して、新しいリクエストを送信することができます。"
    },
    {
      "indent": 3,
      "text": "Authorization: Digest username=\"488869477bf257147b804c45308cd62ac4e25eb717 b12b298c79e62dcea254ec\", realm=\"api@example.org\", uri=\"/doe.json\", algorithm=SHA-512-256, nonce=\"5TsQWLVdgBdmrQ0XsxbDODV+57QdFR34I9HAbC/RVvkK\", nc=00000001, cnonce=\"NTg6RKcb9boFIAS3KrFK9BGeh+iDa/sm6jUMp2wds69v\", qop=auth, response=\"ae66e67d6b427bd3f120414a82e4acff38e8ecd9101d 6c861229025f607a79dd\", opaque=\"HRPCssKJSGjCrkzDg8OhwpzCiGPChXYjwrI2QmXDnsOS\", userhash=true",
      "ja": "認証：ダイジェストユーザ名= \"488869477bf257147b804c45308cd62ac4e25eb717 b12b298c79e62dcea254ec\"、レルム= \"api@example.org\"、URI = \"/ doe.json\"、アルゴリズム= SHA-512から256、ナンス= \"5TsQWLVdgBdmrQ0XsxbDODV + 57QdFR34I9HAbC / RVvkK\"、NC = 00000001 、cnonce = \"NTg6RKcb9boFIAS3KrFK9BGeh + IDA / sm6jUMp2wds69v\"、QOP = AUTH、応答= \"ae66e67d6b427bd3f120414a82e4acff38e8ecd9101d 6c861229025f607a79dd\"、不透明= \"HRPCssKJSGjCrkzDg8OhwpzCiGPChXYjwrI2QmXDnsOS\"、userhash =真"
    },
    {
      "indent": 3,
      "text": "If the client cannot provide a hashed username for any reason, the client can try a request with this Authorization header field:",
      "ja": "クライアントが何らかの理由でハッシュ化されたユーザ名を提供できない場合、クライアントは、このAuthorizationヘッダーフィールドで要求を試すことができます。"
    },
    {
      "indent": 3,
      "text": "Authorization: Digest username*=UTF-8''J%C3%A4s%C3%B8n%20Doe, realm=\"api@example.org\", uri=\"/doe.json\", algorithm=SHA-512-256, nonce=\"5TsQWLVdgBdmrQ0XsxbDODV+57QdFR34I9HAbC/RVvkK\", nc=00000001, cnonce=\"NTg6RKcb9boFIAS3KrFK9BGeh+iDa/sm6jUMp2wds69v\", qop=auth, response=\"ae66e67d6b427bd3f120414a82e4acff38e8ecd9101d 6c861229025f607a79dd\", opaque=\"HRPCssKJSGjCrkzDg8OhwpzCiGPChXYjwrI2QmXDnsOS\", userhash=false",
      "ja": "認証：ダイジェストユーザ名* = UTF-8''J％C3％A4S％C3％B8n％20Doe、領域= \"api@example.org\"、URI = \"/ doe.json\"、アルゴリズム= SHA-512から256、ナンス= \"5TsQWLVdgBdmrQ0XsxbDODV + 57QdFR34I9HAbC / RVvkK\"、NC = 00000001、cnonce = \"NTg6RKcb9boFIAS3KrFK9BGeh + IDA / sm6jUMp2wds69v\"、QOP = AUTH、レスポンス= \"ae66e67d6b427bd3f120414a82e4acff38e8ecd9101d 6c861229025f607a79dd\"、不透明= \"HRPCssKJSGjCrkzDg8OhwpzCiGPChXYjwrI2QmXDnsOS\"、userhash =偽"
    },
    {
      "indent": 0,
      "text": "4. Internationalization Considerations",
      "section_title": true,
      "ja": "4.国際化に関する注意事項"
    },
    {
      "indent": 3,
      "text": "In challenges, servers SHOULD use the \"charset\" authentication parameter (case-insensitive) to express the character encoding they expect the user agent to use when generating A1 (see Section 3.4.2) and username hashing (see Section 3.4.4).",
      "ja": "課題では、サーバは、（3.4.4を参照）、ユーザ名、ハッシュ（3.4.2項を参照）A1を生成するとき、彼らは、ユーザーエージェントが使用することを期待する文字エンコーディングを表現するために、「文字セット」認証パラメータ（大文字と小文字を区別しない）を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "The only allowed value is \"UTF-8\", to be matched case-insensitively (see Section 2.3 in [RFC2978]). It indicates that the server expects the username and password to be converted to Unicode Normalization Form C (\"NFC\", see Section 3 of [RFC5198]) and to be encoded into octets using the UTF-8 character encoding scheme [RFC3629].",
      "ja": "唯一許可された値は「UTF-8」、大文字と小文字を区別せずに照合する（[RFC2978]セクション2.3を参照）です。これは、サーバがユーザ名とパスワードは、Unicode正規化形式C（「NFC」、[RFC5198]のセクション3を参照）に変換すると、UTF-8文字符号化方式[RFC3629]を使用して、オクテットに符号化されることを期待することを示しています。"
    },
    {
      "indent": 3,
      "text": "For the username, recipients MUST support all characters defined in the \"UsernameCasePreserved\" profile defined in Section 3.3 of [RFC7613], with the exception of the colon (\":\") character.",
      "ja": "（「：」）文字のユーザー名の場合、受信者は、コロンを除いて、[RFC7613]の3.3節で定義された「UsernameCasePreserved」プロファイルに定義されたすべての文字をサポートしなければなりません。"
    },
    {
      "indent": 3,
      "text": "For the password, recipients MUST support all characters defined in the \"OpaqueString\" profile defined in Section 4.2 of [RFC7613].",
      "ja": "パスワードについては、受信者は、[RFC7613]のセクション4.2で定義された「OpaqueString」プロファイルに定義されたすべての文字をサポートしなければなりません。"
    },
    {
      "indent": 3,
      "text": "If the user agent does not support the encoding indicated by the server, it can fail the request.",
      "ja": "ユーザエージェントがサーバーによって示されたエンコーディングをサポートしていない場合、その要求を失敗する可能性があります。"
    },
    {
      "indent": 3,
      "text": "When usernames cannot be sent hashed and include non-ASCII characters, clients can include the username* parameter instead (using the value encoding defined in [RFC5987]).",
      "ja": "ユーザ名は、ハッシュ送信と非ASCII文字を含むことができない場合、クライアントは、ユーザ名を含むことができる*パラメータの代わりに（[RFC5987]で定義された値の符号化を使用して）。"
    },
    {
      "indent": 0,
      "text": "5. Security Considerations",
      "section_title": true,
      "ja": "5.セキュリティについての考慮事項"
    },
    {
      "indent": 0,
      "text": "5.1. Limitations",
      "section_title": true,
      "ja": "5.1。制限事項"
    },
    {
      "indent": 3,
      "text": "HTTP Digest Authentication, when used with human-memorable passwords, is vulnerable to dictionary attacks. Such attacks are much easier than cryptographic attacks on any widely used algorithm, including those that are no longer considered secure. In other words, algorithm agility does not make this usage any more secure.",
      "ja": "人間の記憶に残るパスワードで使用されるHTTPダイジェスト認証は、辞書攻撃に対して脆弱です。このような攻撃は、もはや安全と考えられるものを含む任意の広く使われているアルゴリズムで暗号攻撃、よりはるかに簡単です。言い換えれば、アルゴリズムの機敏性は、この使用法は任意のより安全なことはありません。"
    },
    {
      "indent": 3,
      "text": "As a result, Digest Authentication SHOULD be used only with passwords that have a reasonable amount of entropy, e.g., 128-bit or more. Such passwords typically cannot be memorized by humans but can be used for automated web services.",
      "ja": "結果として、ダイジェスト認証は、エントロピーの合理的な量を持っているパスワード、例えば、128ビット以上と一緒に使用されるべきです。このようなパスワードは通常、人間が記憶することはできませんが、自動化されたWebサービスのために使用することができます。"
    },
    {
      "indent": 3,
      "text": "If Digest Authentication is being used, it SHOULD be over a secure channel like HTTPS [RFC2818].",
      "ja": "ダイジェスト認証が使用されている場合は、HTTPS [RFC2818]のような安全なチャネル上であるべきです。"
    },
    {
      "indent": 0,
      "text": "5.2. Storing Passwords",
      "section_title": true,
      "ja": "5.2。パスワードの保存"
    },
    {
      "indent": 3,
      "text": "Digest Authentication requires that the authenticating agent (usually the server) store some data derived from the user's name and password in a \"password file\" associated with a given realm. Normally, this might contain pairs consisting of username and H(A1), where H(A1) is the digested value of the username, realm, and password as described above.",
      "ja": "ダイジェスト認証は、認証エージェント（通常はサーバー）が与えられたレルムに関連付けられ、「パスワードファイル」でユーザ名とパスワードから派生し、いくつかのデータを格納する必要があります。通常、これは、ユーザ名と上記のようにH（A1）は、ユーザ名、レルム、およびパスワードの消化された値であり、H（A1）からなるペアを含むかもしれません。"
    },
    {
      "indent": 3,
      "text": "The security implications of this are that if this password file is compromised, then an attacker gains immediate access to documents on the server using this realm. Unlike, say, a standard UNIX password file, this information needs not be decrypted in order to access documents in the server realm associated with this file. On the other hand, decryption, or more likely a brute-force attack, would be necessary to obtain the user's password. This is the reason that the realm is part of the digested data stored in the password file. It means that if one Digest Authentication password file is compromised, it does not automatically compromise others with the same username and password (though it does expose them to brute-force attack).",
      "ja": "このによるセキュリティへの影響は、このパスワード・ファイルが侵害された場合、攻撃者がこのレルムを使用して、サーバー上のドキュメントへの即時アクセスを得ることです。 、と言うとは異なり、標準UNIXパスワードファイルは、この情報は、このファイルに関連付けられたサーバーレルム内のドキュメントにアクセスするためには、復号化する必要はありません。一方、復号化、またはそれ以上の可能性がブルートフォース攻撃では、ユーザーのパスワードを取得する必要があります。これは、レルムがパスワードファイルに保存されている消化されるデータの一部である理由です。 （それはブルートフォース攻撃にそれらを公開していますが）これは、1つのダイジェスト認証のパスワードファイルが危険にさらされている場合、それは自動的に同じユーザー名とパスワードで他人を損なわないことを意味します。"
    },
    {
      "indent": 3,
      "text": "There are two important security consequences of this. First, the password file must be protected as if it contained unencrypted passwords, because, for the purpose of accessing documents in its realm, it effectively does.",
      "ja": "この2つの重要なセキュリティ上の影響があります。それは暗号化されていないパスワードが含まれているかのよう、その領域で文書にアクセスする目的のために、それが効果的に行いますので、まず、パスワード・ファイルは、保護されなければなりません。"
    },
    {
      "indent": 3,
      "text": "A second consequence of this is that the realm string SHOULD be unique among all realms that any single user is likely to use. In particular, a realm string SHOULD include the name of the host doing the authentication. The inability of the client to authenticate the server is a weakness of Digest Authentication.",
      "ja": "この第二の結果は、レルム文字列は、任意の単一のユーザが使用する可能性があるすべてのレルムの中で一意でなければならないということです。特に、realm文字列は、認証を行うホストの名前を含むべきです。サーバを認証するためのクライアントのできないことは、ダイジェスト認証の弱さです。"
    },
    {
      "indent": 0,
      "text": "5.3. Authentication of Clients Using Digest Authentication",
      "section_title": true,
      "ja": "5.3。ダイジェスト認証を使用するクライアントの認証"
    },
    {
      "indent": 3,
      "text": "Digest Authentication does not provide a strong authentication mechanism, when compared to public-key-based mechanisms, for example.",
      "ja": "例えば、公開鍵ベースのメカニズムと比較した場合、ダイジェスト認証は、強力な認証メカニズムを提供しません。"
    },
    {
      "indent": 3,
      "text": "However, it is significantly stronger than, e.g., CRAM-MD5, which has been proposed for use with Lightweight Directory Access Protocol (LDAP) [RFC4513] and IMAP/POP (see [RFC2195]). It was intended to replace the much weaker and even more dangerous Basic mechanism.",
      "ja": "しかし、ライトウェイトディレクトリアクセスプロトコル（LDAP）[RFC4513]とIMAP / POP（[RFC2195]を参照）で使用するために提案されている例えば、CRAM-MD5、より有意に強いです。それは、はるかに弱いとさらに危険の基本的なメカニズムを置き換えることを意図していました。"
    },
    {
      "indent": 3,
      "text": "Digest Authentication offers no confidentiality protection beyond protecting the actual username and password. All of the rest of the request and response are available to an eavesdropper.",
      "ja": "ダイジェスト認証は、実際のユーザー名とパスワードを保護する以上の機密保護を提供しています。リクエストとレスポンスの残りのすべては、盗聴者にご利用いただけます。"
    },
    {
      "indent": 3,
      "text": "Digest Authentication offers only limited integrity protection for the messages in either direction. If the \"qop=auth-int\" mechanism is used, those parts of the message used in the calculation of the WWW-Authenticate and Authorization header field response parameter values (see Section 3.2 above) are protected. Most header fields and their values could be modified as a part of a man-in-the-middle attack.",
      "ja": "ダイジェスト認証は、どちらの方向にもメッセージにのみ限定された完全性保護を提供しています。 「QOP = AUTH-INT」メカニズムが使用される場合、メッセージの部分は保護されてWWW認証及び認可ヘッダーフィールド応答パラメータ値（上記のセクション3.2を参照）の計算に使用されます。ほとんどのヘッダフィールドとその値は、man-in-the-middle攻撃の一環として変更することができます。"
    },
    {
      "indent": 3,
      "text": "Many needs for secure HTTP transactions cannot be met by Digest Authentication. For those needs, TLS is a more appropriate protocol. In particular, Digest Authentication cannot be used for any transaction requiring confidentiality protection. Nevertheless, many functions remain for which Digest Authentication is both useful and appropriate.",
      "ja": "セキュアなHTTPトランザクションのための多くのニーズがダイジェスト認証によって満たすことができません。これらのニーズのために、TLSは、より適切なプロトコルです。具体的には、ダイジェスト認証は、機密性の保護を必要とするすべてのトランザクションのために使用することはできません。それにもかかわらず、多くの機能がダイジェスト認証を有用かつ適切な両方であるために残ります。"
    },
    {
      "indent": 0,
      "text": "5.4. Limited-Use Nonce Values",
      "section_title": true,
      "ja": "5.4。限定使用ナンス値"
    },
    {
      "indent": 3,
      "text": "The Digest scheme uses a server-specified nonce to seed the generation of the response value (as specified in Section 3.4.1 above). As shown in the example nonce in Section 3.3, the server is free to construct the nonce such that it MAY only be used from a particular client, for a particular resource, for a limited period of time or number of uses, or any other restrictions. Doing so strengthens the protection provided against, for example, replay attacks (see Section 5.5). However, it should be noted that the method chosen for generating and checking the nonce also has performance and resource implications. For example, a server MAY choose to allow each nonce value to be used only once by maintaining a record of whether or not each recently issued nonce has been returned and sending a next-nonce parameter in the Authentication-Info header field of every response. This protects against even an immediate replay attack, but it has a high cost due to checking nonce values; perhaps more important, it will cause authentication failures for any pipelined requests (presumably returning a stale nonce indication). Similarly, incorporating a request-specific element such as the ETag value for a resource limits the use of the nonce to that version of the resource and also defeats pipelining. Thus, it MAY be useful to do so for methods with side effects but have unacceptable performance for those that do not.",
      "ja": "ダイジェストスキームは、（上記セクション3.4.1で指定されるように）応答値の生成をシードするサーバが指定nonceを使用します。セクション3.3例示的ナンスに示すように、サーバは、それが唯一の時間や使用回数、または任意の他の制約の限られた期間のために、特定のリソースのために、特定のクライアントから使用することができるようにナンスを構築するために自由です。そうすること（セクション5.5を参照）、例えば、リプレイ攻撃をに対して提供される保護を強化します。しかし、nonceを生成し、チェックするために選ばれた方法は、パフォーマンスとリソースの意味を持っていることに留意すべきです。例えば、サーバは、各ナンス値はそれぞれ最近発行されたnonceが返ってきたかどうかの記録を維持し、すべての応答の認証-Infoヘッダーフィールドに次ナンスパラメータを送信することにより、一度だけ使用を許可するように選択できます。これはさえ即時リプレイ攻撃から保護しますが、それは一回だけの値をチェックするため、高コストです。おそらくもっと重要なのは、それは（おそらく古いナンス表示を返す）任意のパイプライン化された要求の認証が失敗する原因になります。同様に、そのようなリソースのETag値として要求固有の要素を組み込むことは、リソースのそのバージョンに一回だけの使用を制限し、またパイプラインを破ります。したがって、副作用を持つメソッドのためにそうすることが有用であるが、そうでないもののために許容できないパフォーマンスを持っているかもしれません。"
    },
    {
      "indent": 0,
      "text": "5.5. Replay Attacks",
      "section_title": true,
      "ja": "5.5。リプレイ攻撃"
    },
    {
      "indent": 3,
      "text": "A replay attack against Digest Authentication would usually be pointless for a simple GET request since an eavesdropper would already have seen the only document he could obtain with a replay. This is because the URI of the requested document is digested in the client request, and the server will only deliver that document. By contrast, under Basic Authentication, once the eavesdropper has the user's password, any document protected by that password is open to him.",
      "ja": "ダイジェスト認証に対するリプレイ攻撃は通常、盗聴者は、すでに彼はリプレイで得ることができる唯一の文書を見ているであろうから、単純なGETリクエストのために無意味だろう。要求されたドキュメントのURIがクライアント要求に消化され、サーバが唯一のそのドキュメントをお届けするためです。盗聴者がユーザーのパスワードを持っていたら、これとは対照的に、基本認証の下で、そのパスワードで保護された文書は彼に開かれています。"
    },
    {
      "indent": 3,
      "text": "Thus, for some purposes, it is necessary to protect against replay attacks. A good Digest implementation can do this in various ways. The server-created \"nonce\" value is implementation dependent, but if it contains a digest of the client IP, a timestamp, the resource ETag, and a private server key (as recommended above), then a replay attack is not simple. An attacker must convince the server that the request is coming from a false IP address and must cause the server to deliver the document to an IP address different from the address to which it believes it is sending the document. An attack can only succeed in the period before the timestamp expires. Digesting the client IP and timestamp in the nonce permits an implementation that does not maintain state between transactions.",
      "ja": "このように、いくつかの目的のために、リプレイ攻撃から保護する必要があります。良いダイジェスト実装は、さまざまな方法でこれを行うことができます。サーバーが作成した「ナンス」値は実装に依存するが、（上記の推奨のように）それは、クライアントIP、タイムスタンプ、リソースのETag、およびプライベートサーバキーのダイジェストが含まれている場合は、リプレイ攻撃は簡単ではありません。攻撃者は、要求が偽のIPアドレスから来ていると、サーバは、それが文書を送信していると考えているためにアドレスとは異なるIPアドレスに文書を届けるために起こす必要があるサーバーを説得しなければなりません。タイムスタンプの有効期限が切れる前に攻撃が期間だけで成功することができます。ナンスで、クライアントのIPとタイムスタンプを消化することは、トランザクション間の状態を維持しない実装が可能になります。"
    },
    {
      "indent": 3,
      "text": "For applications where no possibility of replay attack can be tolerated, the server can use one-time nonce values that will not be honored for a second use. This requires the overhead of the server remembering which nonce values have been used until the nonce timestamp (and hence the digest built with it) has expired, but it effectively protects against replay attacks.",
      "ja": "リプレイ攻撃の可能性を許容できないアプリケーションでは、サーバーは、二次利用のために表彰されることはありません1回のナンス値を使用することができます。これは、一回だけのタイムスタンプが（ひいてはそれで構築されたダイジェスト）が期限切れになるまでのnonce値が使用されているサーバー思い出すのオーバーヘッドを必要とするが、それは効果的にリプレイ攻撃から保護します。"
    },
    {
      "indent": 3,
      "text": "An implementation must give special attention to the possibility of replay attacks with POST and PUT requests. Unless the server employs one-time or otherwise limited-use nonces and/or insists on the use of the integrity protection of \"qop=auth-int\", an attacker could replay valid credentials from a successful request with counterfeit data or other message body. Even with the use of integrity protection, most metadata in header fields is not protected. Proper nonce generation and checking provides some protection against replay of previously used valid credentials, but see Section 5.8.",
      "ja": "実装は、POSTとPUT要求にリプレイ攻撃の可能性に特別な注意を払う必要があります。サーバは、ワンタイムまたはその他の限定使用ナンスを採用し、および/または「QOP =のauth-INT」の完全性保護の使用を主張しない限り、攻撃者は、偽造データやその他のメッセージ本体に成功したリクエストから有効な資格情報を再生することができ。でも、完全性保護を使用して、ヘッダフィールドの中で最もメタデータは保護されていません。適切なノンス生成とチェックが以前に使用有効な資格情報のリプレイに対するいくつかの保護を提供しますが、セクション5.8を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.6. Weakness Created by Multiple Authentication Schemes",
      "section_title": true,
      "ja": "5.6。複数の認証方式によって作成された弱点"
    },
    {
      "indent": 3,
      "text": "An HTTP/1.1 server MAY return multiple challenges with a 401 (Authenticate) response, and each challenge MAY use a different auth-scheme. A user agent MUST choose to use the strongest auth-scheme it understands and request credentials from the user based upon that challenge.",
      "ja": "HTTP / 1.1サーバは401（認証）応答で複数の課題を返すことができ、各課題は、異なるのauth-方式を使用することができます。ユーザエージェントは、それが理解して最強のauth-スキームを使用し、その挑戦に基づいて、ユーザーの資格情報を要求するために選択する必要があります。"
    },
    {
      "indent": 3,
      "text": "When the server offers choices of authentication schemes using the WWW-Authenticate header field, the strength of the resulting authentication is only as good as that of the of the weakest of the authentication schemes. See Section 5.7 below for discussion of particular attack scenarios that exploit multiple authentication schemes.",
      "ja": "サーバがWWW-Authenticateヘッダフィールドを使用して認証方式の選択肢を提供すると、結果の認証の強度は、認証方式の最も弱いののそれと同じくらい良いです。複数の認証方式を利用する特定の攻撃シナリオの議論については、以下の5.7節を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.7. Online Dictionary Attacks",
      "section_title": true,
      "ja": "5.7。オンライン辞書攻撃"
    },
    {
      "indent": 3,
      "text": "If the attacker can eavesdrop, then it can test any overheard nonce/ response pairs against a list of common words. Such a list is usually much smaller than the total number of possible passwords. The cost of computing the response for each password on the list is paid once for each challenge.",
      "ja": "攻撃者が盗聴することができた場合、それは一般的な単語のリストに対して任意の耳にナンス/応答のペアをテストすることができます。このようなリストは、通常、可能なパスワードの総数よりもはるかに小さいです。リスト上の各パスワードの応答を計算するコストは、各チャレンジのために一度支払われます。"
    },
    {
      "indent": 3,
      "text": "The server can mitigate this attack by not allowing users to select passwords that are in a dictionary.",
      "ja": "サーバーは、ユーザーが辞書にあるパスワードを選択することができないことによって、この攻撃を軽減することができます。"
    },
    {
      "indent": 0,
      "text": "5.8. Man-in-the-Middle Attacks",
      "section_title": true,
      "ja": "5.8。 man-in-the-middle攻撃"
    },
    {
      "indent": 3,
      "text": "Digest Authentication is vulnerable to man-in-the-middle (MITM) attacks, for example, from a hostile or compromised proxy. Clearly, this would present all the problems of eavesdropping. But, it also offers some additional opportunities to the attacker.",
      "ja": "ダイジェスト認証は、敵対的または損なわプロキシから、例えば、マン・イン・ザ・ミドル（MITM）攻撃に対して脆弱です。明らかに、これは盗聴のすべての問題を提示します。しかし、それはまた、攻撃者にいくつかの追加の機会を提供しています。"
    },
    {
      "indent": 3,
      "text": "A possible man-in-the-middle attack would be to add a weak authentication scheme to the set of choices, hoping that the client will use one that exposes the user's credentials (e.g., password). For this reason, the client SHOULD always use the strongest scheme that it understands from the choices offered.",
      "ja": "可能man-in-the-middle攻撃は、クライアントがユーザーの資格情報（例えば、パスワード）を公開するものを使用することを期待して、選択肢のセットに弱い認証スキームを追加することです。このため、クライアントは常にそれが提供する選択肢の中から理解最強の方式を使用すべきです。"
    },
    {
      "indent": 3,
      "text": "An even better MITM attack would be to remove all offered choices, replacing them with a challenge that requests only Basic authentication, then uses the cleartext credentials from the Basic authentication to authenticate to the origin server using the stronger scheme it requested. A particularly insidious way to mount such a MITM attack would be to offer a \"free\" proxy caching service to gullible users.",
      "ja": "より良いMITM攻撃は、それが要求された強力な方式を使用して、オリジンサーバへの認証に基本認証から平文の資格情報を使用し、基本認証のみを要求挑戦に置き換える、提供されるすべての選択肢を削除することです。そのようなMITM攻撃を仕掛けるために特に油断のならない方法はだまされやすいユーザに「自由」プロキシキャッシングサービスを提供することです。"
    },
    {
      "indent": 3,
      "text": "User agents should consider measures such as presenting a visual indication at the time of the credentials request of what authentication scheme is to be used, or remembering the strongest authentication scheme ever requested by a server and producing a warning message before using a weaker one. It might also be a good idea for the user agent to be configured to demand Digest authentication in general or from specific sites.",
      "ja": "ユーザエージェントは、このような認証方式を使用するものの資格情報を要求時に視覚的表示を提示し、またはこれまでに、サーバから要求された最も強力な認証スキームを思い出し、弱いものを使用する前に、警告メッセージを生成するなどの対策を検討すべきです。ユーザーエージェントは、一般的にまたは特定のサイトからDigest認証を要求するように設定することも良い考えかもしれません。"
    },
    {
      "indent": 3,
      "text": "Or, a hostile proxy might spoof the client into making a request the attacker wanted rather than one the client wanted. Of course, this is still much harder than a comparable attack against Basic Authentication.",
      "ja": "または、敵対的なプロキシは、攻撃者が1つのクライアントが望んでいたのではなく、望んでいた要求を行うにクライアントを偽装することがあります。もちろん、これはまだ基本認証に対して同等の攻撃よりもはるかに困難です。"
    },
    {
      "indent": 0,
      "text": "5.9. Chosen Plaintext Attacks",
      "section_title": true,
      "ja": "5.9。選択平文攻撃"
    },
    {
      "indent": 3,
      "text": "With Digest Authentication, a MITM or a malicious server can arbitrarily choose the nonce that the client will use to compute the response. This is called a \"chosen plaintext\" attack. The ability to choose the nonce is known to make cryptanalysis much easier.",
      "ja": "ダイジェスト認証では、MITMあるいは悪意のあるサーバは、任意のクライアントが応答を計算するために使用するnonceを選択することができます。これは、「選択平文」攻撃と呼ばれています。 nonceを選択する能力がはるかに簡単に解読することが知られています。"
    },
    {
      "indent": 3,
      "text": "However, a method to analyze the one-way functions used by Digest using chosen plaintext is not currently known.",
      "ja": "しかし、選択された平文を使用してダイジェストが使用する一方向関数を分析する方法は、現在知られていません。"
    },
    {
      "indent": 3,
      "text": "The countermeasure against this attack is for clients to use the cnonce parameter; this allows the client to vary the input to the hash in a way not chosen by the attacker.",
      "ja": "この攻撃に対する対策はcnonceパラメータを使用するクライアント用です。これは、クライアントが攻撃者によって選ばれていない方法で、ハッシュへの入力を変化させることができます。"
    },
    {
      "indent": 0,
      "text": "5.10. Precomputed Dictionary Attacks",
      "section_title": true,
      "ja": "5.10。事前計算辞書攻撃"
    },
    {
      "indent": 3,
      "text": "With Digest Authentication, if the attacker can execute a chosen plaintext attack, the attacker can precompute the response for many common words to a nonce of its choice and store a dictionary of response/password pairs. Such precomputation can often be done in parallel on many machines. It can then use the chosen plaintext attack to acquire a response corresponding to that challenge and just look up the password in the dictionary. Even if most passwords are not in the dictionary, some might be. Since the attacker gets to pick the challenge, the cost of computing the response for each password on the list can be amortized over finding many passwords. A dictionary with 100 million password/response pairs would take about 3.2 gigabytes of disk storage.",
      "ja": "攻撃者が選択平文攻撃を実行できるかどうダイジェスト認証を使用すると、攻撃者は、その選択肢のナンスに多くの一般的な単語のための応答を事前に計算し、応答/パスワードのペアの辞書を格納することができます。このような事前計算は、多くの場合、多くのマシン上で並行して行うことができます。その後、その挑戦に対応する応答を取得し、ちょうど辞書にパスワードをルックアップするために選ばれた平文攻撃を使用することができます。ほとんどのパスワードが辞書にない場合でも、いくつかはあるかもしれません。攻撃者が挑戦を選ぶことを得るので、リスト上の各パスワードの応答を計算するコストは、多くのパスワードを見つけることで償却することができます。億パスワード/レスポンスのペアと辞書は、ディスクストレージのおよそ3.2ギガバイトを取るだろう。"
    },
    {
      "indent": 3,
      "text": "The countermeasure against this attack is for clients to use the cnonce parameter.",
      "ja": "クライアントはcnonceパラメータを使用するため、この攻撃対策です。"
    },
    {
      "indent": 0,
      "text": "5.11. Batch Brute-Force Attacks",
      "section_title": true,
      "ja": "5.11。バッチブルートフォース攻撃"
    },
    {
      "indent": 3,
      "text": "With Digest Authentication, a MITM can execute a chosen plaintext attack and can gather responses from many users to the same nonce. It can then find all the passwords within any subset of password space that would generate one of the nonce/response pairs in a single pass over that space. It also reduces the time to find the first password by a factor equal to the number of nonce/response pairs gathered. This search of the password space can often be done in parallel on many machines, and even a single machine can search large subsets of the password space very quickly -- reports exist of searching all passwords with six or fewer letters in a few hours.",
      "ja": "ダイジェスト認証では、MITMは選択平文攻撃を実行することができ、同じナンスに多くのユーザーからの応答を収集することができます。それは、そのスペース上の単一パスでナンス/応答のペアのいずれかを生成するパスワード空間の任意のサブセット内のすべてのパスワードを見つけることができます。また、集まったnonce /レスポンスペアの数に等しい係数による最初のパスワードを見つけるための時間が短縮されます。パスワードスペースのこの検索は、多くの場合、多くのマシン上で並行して行うことができ、さらに、単一のマシンは非常に迅速に、パスワードスペースの大部分集合を検索することができます - レポートは数時間で6文字以下で、すべてのパスワードを検索するので存在します。"
    },
    {
      "indent": 3,
      "text": "The countermeasure against this attack is for clients to use the cnonce parameter.",
      "ja": "クライアントはcnonceパラメータを使用するため、この攻撃対策です。"
    },
    {
      "indent": 0,
      "text": "5.12. Parameter Randomness",
      "section_title": true,
      "ja": "5.12。パラメータのランダム性"
    },
    {
      "indent": 3,
      "text": "The security of this protocol is critically dependent on the randomness of the randomly chosen parameters, such as client and server nonces. These should be generated by a strong random or properly seeded pseudorandom source (see [RFC4086]).",
      "ja": "このプロトコルのセキュリティは、クライアントとサーバのナンスとしてランダムに選択されたパラメータのランダム性に決定的に依存します。これらは、強いランダム又は適切に播種擬似ランダムソースによって生成されるべきである（[RFC4086]を参照）。"
    },
    {
      "indent": 0,
      "text": "5.13. Summary",
      "section_title": true,
      "ja": "5.13。概要"
    },
    {
      "indent": 3,
      "text": "By modern cryptographic standards, Digest Authentication is weak. But, for a large range of purposes, it is valuable as a replacement for Basic Authentication. It remedies some, but not all, weaknesses of Basic Authentication. Its strength may vary depending on the implementation. In particular, the structure of the nonce (which is dependent on the server implementation) may affect the ease of mounting a replay attack. A range of server options is appropriate since, for example, some implementations may be willing to accept the server overhead of one-time nonces or digests to eliminate the possibility of replay. Others may be satisfied with a nonce like the one recommended above, i.e., restricted to a single IP address and a single ETag or with a limited lifetime.",
      "ja": "現代暗号の標準規格では、ダイジェスト認証は弱いです。しかし、目的の広い範囲のために、それは基本認証の代替品として貴重です。この救済いくつかの、すべてではないが、基本認証の弱点。その強さは、実装によって異なる場合があります。具体的には、（サーバの実装に依存する）ナンスの構造は、リプレイ攻撃を搭載性に影響を及ぼし得ます。例えば、いくつかの実装は、再生の可能性を排除するために、ワンタイムノンス又はダイジェストのサーバーのオーバーヘッドを受け入れることができる、ので、サーバー・オプションの範囲が適当です。他のものは、単一のIPアドレスと単一のETagまたは限られた寿命で制限上記の推奨1、即ち、のようなナンスに満足することができます。"
    },
    {
      "indent": 3,
      "text": "The bottom line is that *any* compliant implementation will be relatively weak by cryptographic standards, but *any* compliant implementation will be far superior to Basic Authentication.",
      "ja": "一番下の行は、任意の*準拠した実装は、暗号化基準では比較的弱くなりますが、*は任意の*準拠した実装は、基本認証よりはるかに優れだろう*ということです。"
    },
    {
      "indent": 0,
      "text": "6. IANA Considerations",
      "section_title": true,
      "ja": "6. IANAの考慮事項"
    },
    {
      "indent": 0,
      "text": "6.1. Hash Algorithms for HTTP Digest Authentication",
      "section_title": true,
      "ja": "6.1。 HTTPダイジェスト認証のためのハッシュアルゴリズム"
    },
    {
      "indent": 3,
      "text": "This specification creates a new IANA registry named \"Hash Algorithms for HTTP Digest Authentication\" under the existing \"Hypertext Transfer Protocol (HTTP) Digest Algorithm Values\" category. This registry lists the hash algorithms that can be used in HTTP Digest Authentication.",
      "ja": "この仕様は、既存の「ハイパーテキスト転送プロトコル（HTTP）ダイジェストアルゴリズム値」カテゴリの下に「HTTPダイジェスト認証のためのハッシュアルゴリズム」という名前の新しいIANAレジストリを作成します。このレジストリは、HTTPダイジェスト認証で使用することができるハッシュアルゴリズムを示しています。"
    },
    {
      "indent": 3,
      "text": "When registering a new hash algorithm, the following information MUST be provided:",
      "ja": "新しいハッシュアルゴリズムを登録する場合、以下の情報を提供しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Hash Algorithm",
      "ja": "ハッシュアルゴリズム"
    },
    {
      "indent": 6,
      "text": "The textual name of the hash algorithm.",
      "ja": "ハッシュアルゴリズムのテキスト名。"
    },
    {
      "indent": 3,
      "text": "Digest Size",
      "ja": "ダイジェストサイズ"
    },
    {
      "indent": 6,
      "text": "The size of the algorithm's output in bits.",
      "ja": "ビットにおけるアルゴリズムの出力の大きさ。"
    },
    {
      "indent": 3,
      "text": "Reference",
      "ja": "参照"
    },
    {
      "indent": 6,
      "text": "A reference to the specification adding the algorithm to this registry.",
      "ja": "このレジストリにアルゴリズムを追加明細書を参照。"
    },
    {
      "indent": 3,
      "text": "The update policy for this registry shall be Specification Required [RFC5226].",
      "ja": "このレジストリの更新ポリシーは、仕様が必要である[RFC5226]でなければなりません。"
    },
    {
      "indent": 3,
      "text": "The initial registry contains the following entries:",
      "ja": "最初のレジストリには、次のエントリが含まれています。"
    },
    {
      "indent": 15,
      "text": "+----------------+-------------+-----------+\n| Hash Algorithm | Digest Size | Reference |\n+----------------+-------------+-----------+\n| \"MD5\"          | 128         | RFC 7616  |\n| \"SHA-512-256\"  | 256         | RFC 7616  |\n| \"SHA-256\"      | 256         | RFC 7616  |\n+----------------+-------------+-----------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Each one of the algorithms defined in the registry might have a \"-sess\" variant, e.g., MD5-sess, SHA-256-sess, etc.",
      "ja": "レジストリで定義されたアルゴリズムのそれぞれは、「-sess」変異体、例えば、MD5-SESの、SHA-256のSES、等があるかもしれません"
    },
    {
      "indent": 3,
      "text": "To clarify the purpose of the existing \"HTTP Digest Algorithm Values\" registry and to avoid confusion between the two registries, IANA has added the following description to the existing \"HTTP Digest Algorithm Values\" registry:",
      "ja": "既存の「HTTPダイジェストアルゴリズム値」レジストリの目的を明確にすると2つのレジストリの混同を避けるために、IANAは既存の「HTTPダイジェストアルゴリズム値」レジストリに以下の記述を追加しました："
    },
    {
      "indent": 6,
      "text": "This registry lists the algorithms that can be used when creating digests of an HTTP message body, as specified in RFC 3230.",
      "ja": "このレジストリは、HTTPメッセージボディのダイジェストを作成する際にRFC 3230で指定されるように、使用することができるアルゴリズムを示しています。"
    },
    {
      "indent": 0,
      "text": "6.2. Digest Scheme Registration",
      "section_title": true,
      "ja": "6.2。ダイジェストスキームの登録"
    },
    {
      "indent": 3,
      "text": "This specification updates the existing entry of the Digest scheme in the \"Hypertext Transfer Protocol (HTTP) Authentication Scheme Registry\" and adds a new reference to this specification.",
      "ja": "この仕様は、「ハイパーテキスト転送プロトコル（HTTP）認証スキームレジストリ」のダイジェストスキームの既存のエントリを更新し、この仕様への新しい参照を追加します。"
    },
    {
      "indent": 6,
      "text": "Authentication Scheme Name: Digest",
      "ja": "認証スキーム名：ダイジェスト"
    },
    {
      "indent": 6,
      "text": "Pointer to specification text: RFC 7616",
      "ja": "仕様のテキストへのポインタ：RFC 7616"
    },
    {
      "indent": 0,
      "text": "7. References",
      "section_title": true,
      "ja": "7.参考"
    },
    {
      "indent": 0,
      "text": "7.1. Normative References",
      "section_title": true,
      "ja": "7.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<http://www.rfc-editor.org/info/ RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC2978] Freed, N. and J. Postel, \"IANA Charset Registration Procedures\", BCP 19, RFC 2978, DOI 10.17487/RFC2978, October 2000, <http://www.rfc-editor.org/info/rfc2978>.",
      "ja": "[RFC2978]解放され、N.とJ.ポステル、 \"IANA文字セット登録手順\"、BCP 19、RFC 2978、DOI 10.17487 / RFC2978、2000年10月<http://www.rfc-editor.org/info/rfc2978> 。"
    },
    {
      "indent": 3,
      "text": "[RFC3629] Yergeau, F., \"UTF-8, a transformation format of ISO 10646\", STD 63, RFC 3629, DOI 10.17487/RFC3629, November 2003, <http://www.rfc-editor.org/info/rfc3629>.",
      "ja": "[RFC3629] Yergeau、F.、 \"UTF-8、ISO 10646の変換フォーマット\"、STD 63、RFC 3629、DOI 10.17487 / RFC3629、2003年11月、<http://www.rfc-editor.org/info/ RFC3629>。"
    },
    {
      "indent": 3,
      "text": "[RFC3986] Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform Resource Identifier (URI): Generic Syntax\", STD 66, RFC 3986, DOI 10.17487/RFC3986, January 2005, <http://www.rfc-editor.org/info/rfc3986>.",
      "ja": "[RFC3986]バーナーズ - リー、T.、フィールディング、R.、およびL. Masinter、 \"ユニフォームリソース識別子（URI）：汎用構文\"、STD 66、RFC 3986、DOI 10.17487 / RFC3986、2005年1月<HTTP：/ /www.rfc-editor.org/info/rfc3986>。"
    },
    {
      "indent": 3,
      "text": "[RFC4086] Eastlake 3rd, D., Schiller, J., and S. Crocker, \"Randomness Requirements for Security\", BCP 106, RFC 4086, DOI 10.17487/RFC4086, June 2005, <http://www.rfc-editor.org/info/rfc4086>.",
      "ja": "[RFC4086]イーストレーク3日、D.、シラー、J.、およびS.クロッカー、 \"セキュリティのためのランダム要件\"、BCP 106、RFC 4086、DOI 10.17487 / RFC4086、2005年6月、<HTTP：//www.rfc-editor .ORG /情報/ RFC4086>。"
    },
    {
      "indent": 3,
      "text": "[RFC5198] Klensin, J. and M. Padlipsky, \"Unicode Format for Network Interchange\", RFC 5198, DOI 10.17487/RFC5198, March 2008, <http://www.rfc-editor.org/info/rfc5198>.",
      "ja": "[RFC5198] Klensin、J.とM. Padlipsky、 \"ネットワークインターチェンジのUnicodeフォーマット\"、RFC 5198、DOI 10.17487 / RFC5198、2008年3月、<http://www.rfc-editor.org/info/rfc5198>。"
    },
    {
      "indent": 3,
      "text": "[RFC5234] Crocker, D., Ed. and P. Overell, \"Augmented BNF for Syntax Specifications: ABNF\", STD 68, RFC 5234, DOI 10.17487/RFC5234, January 2008, <http://www.rfc-editor.org/info/rfc5234>.",
      "ja": "[RFC5234]クロッカー、D.、エド。そして、P. Overell、 \"構文仕様のための増大しているBNF：ABNF\"、STD 68、RFC 5234、DOI 10.17487 / RFC5234、2008年1月、<http://www.rfc-editor.org/info/rfc5234>。"
    },
    {
      "indent": 3,
      "text": "[RFC5987] Reschke, J., \"Character Set and Language Encoding for Hypertext Transfer Protocol (HTTP) Header Field Parameters\", RFC 5987, DOI 10.17487/RFC5987, August 2010, <http://www.rfc-editor.org/info/rfc5987>.",
      "ja": "[RFC5987] Reschke、J.、 \"文字セットおよび言語エンコーディング転送プロトコル（HTTP）ヘッダフィールドパラメータハイパーテキストのための\"、RFC 5987、DOI 10.17487 / RFC5987、2010年8月、<http://www.rfc-editor.org/情報/ rfc5987>。"
    },
    {
      "indent": 3,
      "text": "[RFC6454] Barth, A., \"The Web Origin Concept\", RFC 6454, DOI 10.17487/RFC6454, December 2011, <http://www.rfc-editor.org/info/rfc6454>.",
      "ja": "[RFC6454]バース、A.、 \"ウェブ起源コンセプト\"、RFC 6454、DOI 10.17487 / RFC6454、2011年12月、<http://www.rfc-editor.org/info/rfc6454>。"
    },
    {
      "indent": 3,
      "text": "[RFC7230] Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing\", RFC 7230, DOI 10.17487/RFC7230, June 2014, <http://www.rfc-editor.org/info/rfc7230>.",
      "ja": "[RFC7230]フィールディング、R.、エド。及びJ. Reschke、編、 \"ハイパーテキスト転送プロトコル（HTTP / 1.1）：メッセージの構文およびルーティング\"、RFC 7230、DOI 10.17487 / RFC7230、2014年6月、<http://www.rfc-editor.org/info/ rfc7230>。"
    },
    {
      "indent": 3,
      "text": "[RFC7231] Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content\", RFC 7231, DOI 10.17487/RFC7231, June 2014, <http://www.rfc-editor.org/info/rfc7231>.",
      "ja": "[RFC7231]フィールディング、R.、エド。そして、J. Reschke、エド、 \"ハイパーテキスト転送プロトコル（HTTP / 1.1）：セマンティクスおよびコンテンツ\"、RFC 7231、DOI 10.17487 / RFC7231、2014年6月、<http://www.rfc-editor.org/info/rfc7231 >。"
    },
    {
      "indent": 3,
      "text": "[RFC7234] Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Caching\", RFC 7234, DOI 10.17487/RFC7234, June 2014, <http://www.rfc-editor.org/info/rfc7234>.",
      "ja": "[RFC7234]フィールディング、R.、エド、ノッティンガム、M.、エド、及びJ. Reschke、編、 \"ハイパーテキスト転送プロトコル（HTTP / 1.1）：キャッシュ\"。。。、RFC 7234、DOI 10.17487 / RFC7234、2014年6月、<http://www.rfc-editor.org/info/rfc7234>。"
    },
    {
      "indent": 3,
      "text": "[RFC7235] Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Authentication\", RFC 7235, DOI 10.17487/RFC7235, June 2014, <http://www.rfc-editor.org/info/rfc7235>.",
      "ja": "[RFC7235]フィールディング、R.、エド。及びJ. Reschke、編、 \"ハイパーテキスト転送プロトコル（HTTP / 1.1）：認証\"、RFC 7235、DOI 10.17487 / RFC7235、2014年6月、<http://www.rfc-editor.org/info/rfc7235>。"
    },
    {
      "indent": 3,
      "text": "[RFC7613] Saint-Andre, P. and A. Melnikov, \"Preparation, Enforcement, and Comparison of Internationalized Strings Representing Usernames and Passwords\", RFC 7613, DOI 10.17487/RFC7613, August 2015, <http://www.rfc-editor.org/info/rfc7613>.",
      "ja": "[RFC7613]サンアンドレ、P.およびA.メルニコフ、 \"準備、施行、およびユーザ名とパスワードを表現する国際化された文字列の比較\"、RFC 7613、DOI 10.17487 / RFC7613、2015年8月、<のhttp：//www.rfc- editor.org/info/rfc7613>。"
    },
    {
      "indent": 3,
      "text": "[RFC7615] Reschke, J., \"HTTP Authentication-Info and Proxy-Authentication-Info Response Header Fields\", RFC 7615, DOI 10.17487/RFC7615, September 2015, <http://www.rfc-editor.org/info/rfc7615>.",
      "ja": "[RFC7615] Reschke、J.、 \"HTTP認証-INFOとプロキシ認証-INFO応答ヘッダフィールド\"、RFC 7615、DOI 10.17487 / RFC7615、2015年9月、<http://www.rfc-editor.org/info/ rfc7615>。"
    },
    {
      "indent": 0,
      "text": "7.2. Informative References",
      "section_title": true,
      "ja": "7.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[RFC2195] Klensin, J., Catoe, R., and P. Krumviede, \"IMAP/POP AUTHorize Extension for Simple Challenge/Response\", RFC 2195, DOI 10.17487/RFC2195, September 1997, <http://www.rfc-editor.org/info/rfc2195>.",
      "ja": "[RFC2195] Klensin、J.、Catoe、R.、およびP. Krumviede、 \"IMAP / SIMPLEチャレンジ/レスポンスのためのPOP許可拡張子\"、RFC 2195、DOI 10.17487 / RFC2195、1997年9月、<HTTP：//www.rfc -editor.org/info/rfc2195>。"
    },
    {
      "indent": 3,
      "text": "[RFC2617] Franks, J., Hallam-Baker, P., Hostetler, J., Lawrence, S., Leach, P., Luotonen, A., and L. Stewart, \"HTTP Authentication: Basic and Digest Access Authentication\", RFC 2617, DOI 10.17487/RFC2617, June 1999, <http://www.rfc-editor.org/info/rfc2617>.",
      "ja": "[RFC2617]フランクス、J.、ハラム・ベイカー、P.、Hostetler、J.、ローレンス、S.、リーチ、P.、Luotonen、A.、およびL.スチュワート、 \"HTTP認証：基本とダイジェストアクセス認証\" 、RFC 2617、DOI 10.17487 / RFC2617、1999年6月、<http://www.rfc-editor.org/info/rfc2617>。"
    },
    {
      "indent": 3,
      "text": "[RFC2818] Rescorla, E., \"HTTP Over TLS\", RFC 2818, DOI 10.17487/RFC2818, May 2000, <http://www.rfc-editor.org/info/rfc2818>.",
      "ja": "[RFC2818]レスコラ、E.、 \"TLSオーバーHTTP\"、RFC 2818、DOI 10.17487 / RFC2818、2000年5月、<http://www.rfc-editor.org/info/rfc2818>。"
    },
    {
      "indent": 3,
      "text": "[RFC4513] Harrison, R., Ed., \"Lightweight Directory Access Protocol (LDAP): Authentication Methods and Security Mechanisms\", RFC 4513, DOI 10.17487/RFC4513, June 2006, <http://www.rfc-editor.org/info/rfc4513>.",
      "ja": "[RFC4513]ハリソン、R.、エド、。 \"のLDAP（Lightweight Directory Access Protocol）：認証方法とセキュリティメカニズム\"、RFC 4513、DOI 10.17487 / RFC4513、2006年6月、<http://www.rfc-editor.org /情報/ RFC4513>。"
    },
    {
      "indent": 3,
      "text": "[RFC5226] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 5226, DOI 10.17487/RFC5226, May 2008, <http://www.rfc-editor.org/info/rfc5226>.",
      "ja": "[RFC5226] Narten氏、T.とH. Alvestrand、 \"RFCsにIANA問題部に書くためのガイドライン\"、BCP 26、RFC 5226、DOI 10.17487 / RFC5226、2008年5月、<http://www.rfc-editor.org /情報/ RFC5226>。"
    },
    {
      "indent": 3,
      "text": "[RFC7617] Reschke, J., \"The 'Basic' HTTP Authentication Scheme\", RFC 7617, DOI 10.17487/RFC7617, September 2015, <http://www.rfc-editor.org/info/rfc7617>.",
      "ja": "[RFC7617] Reschke、J.、 \" '基本' HTTP認証スキーム\"、RFC 7617、DOI 10.17487 / RFC7617、2015年9月、<http://www.rfc-editor.org/info/rfc7617>。"
    },
    {
      "indent": 1,
      "text": "Appendix A. Changes from",
      "ja": "付録A.からの変更点"
    },
    {
      "indent": 3,
      "text": "This document introduces the following changes:",
      "ja": "このドキュメントは、以下の変更が導入されています。"
    },
    {
      "indent": 3,
      "text": "o Adds support for two new algorithms, SHA2-256 as mandatory and SHA2-512/256 as a backup, and defines the proper algorithm negotiation. The document keeps the MD5 algorithm support but only for backward compatibility.",
      "ja": "Oは、2つの新しいアルゴリズム、必須としてSHA2-256やバックアップなどSHA2-512 / 256のサポートを追加し、適切なアルゴリズムのネゴシエーションを定義します。文書には、だけで、下位互換性のためにMD5アルゴリズムのサポートを続けています。"
    },
    {
      "indent": 3,
      "text": "o Introduces the username hashing capability and the parameter associated with that, mainly for privacy reasons.",
      "ja": "oは主に、プライバシー上の理由から、ユーザ名のハッシュ機能とそれに関連するパラメータを紹介します。"
    },
    {
      "indent": 3,
      "text": "o Adds various internationalization considerations that impact the A1 calculation and username and password encoding.",
      "ja": "oはA1の計算と、ユーザー名とパスワードのエンコードに影響を与える様々な国際化の考慮事項を追加します。"
    },
    {
      "indent": 3,
      "text": "o Introduces a new IANA registry, \"Hash Algorithms for HTTP Digest Authentication\", that lists the hash algorithms that can be used in HTTP Digest Authentication.",
      "ja": "oはHTTPダイジェスト認証で使用することができるハッシュアルゴリズムを一覧表示する新しいIANAレジストリ、「HTTPダイジェスト認証用のハッシュアルゴリズム」を、紹介します。"
    },
    {
      "indent": 3,
      "text": "o Deprecates backward compatibility with RFC 2069.",
      "ja": "oはRFC 2069との下位互換性を廃止します。"
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "To provide a complete description for the Digest mechanism and its operation, this document borrows text heavily from [RFC2617]. The authors of this document would like to thank John Franks, Phillip M. Hallam-Baker, Jeffery L. Hostetler, Scott D. Lawrence, Paul J. Leach, Ari Luotonen, and Lawrence C. Stewart for their work on that specification.",
      "ja": "ダイジェストメカニズムとその動作のための完全な説明を提供するために、このドキュメントは[RFC2617]から多額のテキストを借ります。本書の著者は、その仕様上の自分の仕事のためにジョン・フランクス、フィリップM.ハラム - ベイカー、ジェフリーL. Hostetler、スコット・D.ローレンス、ポール・J.リーチ、アリ・ルオトナン、およびローレンスC.スチュワートに感謝したいと思います。"
    },
    {
      "indent": 3,
      "text": "Special thanks to Julian Reschke for his many reviews, comments, suggestions, and text provided to various areas in this document.",
      "ja": "この文書に記載されている様々な分野に提供する彼の多くのレビュー、コメント、提案、およびテキストのジュリアンReschkeに感謝します。"
    },
    {
      "indent": 3,
      "text": "The authors would like to thank Stephen Farrell, Yoav Nir, Phillip Hallam-Baker, Manu Sporny, Paul Hoffman, Yaron Sheffer, Sean Turner, Geoff Baskwill, Eric Cooper, Bjoern Hoehrmann, Martin Durst, Peter Saint-Andre, Michael Sweet, Daniel Stenberg, Brett Tate, Paul Leach, Ilari Liusvaara, Gary Mort, Alexey Melnikov, Benjamin Kaduk, Kathleen Moriarty, Francis Dupont, Hilarie Orman, and Ben Campbell for their careful review and comments.",
      "ja": "著者はスティーブン・ファレル、ヨアフニール、フィリップハラム - ベイカー、マヌーSporny、ポール・ホフマン、ヤロンシェファー、ショーン・ターナー、ジェフBaskwill、エリック・クーパー、ビョルンHoehrmann、マーティン・ダースト、ピーター・サン・アンドレ、マイケル・スウィート、ダニエルに感謝したいと思います彼らの慎重なレビューとコメントのためのステンバーグ、ブレット・テイト、ポールリーチ、Ilari Liusvaara、ゲイリー・モート、アレクセイ・メルニコフ、ベンジャミンKaduk、キャスリーン・モリアーティ、フランシスデュポン、ヒラリーオーマン、そしてベン・キャンベル。"
    },
    {
      "indent": 3,
      "text": "The authors would like to thank Jonathan Stoke, Nico Williams, Harry Halpin, and Phil Hunt for their comments on the mailing list when discussing various aspects of this document.",
      "ja": "作者はこのドキュメントのさまざまな側面を議論する際にメーリングリストで彼らのコメントのためにジョナサン・ストーク、ニコ・ウィリアムズ、ハリーハルピン、フィル・ハントに感謝したいと思います。"
    },
    {
      "indent": 3,
      "text": "The authors would like to thank Paul Kyzivat and Dale Worley for their careful review and feedback on some aspects of this document.",
      "ja": "作者はこのドキュメントのいくつかの側面上での慎重なレビューとフィードバックのためにポールKyzivatとデールウォーリーを感謝したいと思います。"
    },
    {
      "indent": 3,
      "text": "The authors would like to thank Barry Leiba for his help with the registry.",
      "ja": "著者は、レジストリを持つ彼の助けのためのバリー・レイバに感謝したいと思います。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Rifaat Shekh-Yusef (editor) Avaya 250 Sidney Street Belleville, Ontario Canada",
      "ja": "リファットシェイクユセフ（編集者）50シドニーストリートbellebhille abhaya、オンタリオ、カナダ"
    },
    {
      "indent": 3,
      "text": "Phone: +1-613-967-5267 Email: rifaat.ietf@gmail.com",
      "ja": "電話：+ 1-613-967-5267 Eメール：rifaat.ietf@gmail.com"
    },
    {
      "indent": 3,
      "text": "David Ahrens Independent California United States",
      "ja": "デビッド・アーレンス独立カリフォルニア州アメリカ合衆国"
    },
    {
      "indent": 3,
      "text": "Email: ahrensdc@gmail.com",
      "ja": "メール：ahrensdc@gmail.com"
    },
    {
      "indent": 3,
      "text": "Sophie Bremer Netzkonform Germany",
      "ja": "ソフィー・ブレマーNetzkonformドイツ"
    },
    {
      "indent": 3,
      "text": "Email: sophie.bremer@netzkonform.de",
      "ja": "メール：sophie.bremer@netzkonform.de"
    }
  ]
}