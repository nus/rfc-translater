{
  "title": {
    "text": "RFC 7423 - Diameter Applications Design Guidelines",
    "ja": "RFC 7423 - Diameterアプリケーション設計のガイドライン"
  },
  "number": 7423,
  "created_at": "2019-11-01 23:14:57.331202+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                    L. Morand, Ed.\nRequest for Comments: 7423                                   Orange Labs\nBCP: 193                                                      V. Fajardo\nCategory: Best Current Practice                           Fluke Networks\nISSN: 2070-1721                                            H. Tschofenig\n                                                           November 2014",
      "raw": true
    },
    {
      "indent": 16,
      "text": "Diameter Applications Design Guidelines",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "The Diameter base protocol provides facilities for protocol extensibility enabling the definition of new Diameter applications or modification of existing applications. This document is a companion document to the Diameter base protocol that further explains and clarifies the rules to extend Diameter. Furthermore, this document provides guidelines to Diameter application designers reusing/ defining Diameter applications or creating generic Diameter extensions.",
      "ja": "直径ベースプロトコルは、新しいDiameterアプリケーションまたは既存のアプリケーションの変更の定義を可能にするプロトコルの拡張のための設備を提供します。この文書は、さらに直径を拡張するためのルールを説明し、明確化のDiameterベース・プロトコルへの仲間ドキュメントです。さらに、このドキュメントはDiameterアプリケーションを定義するか、一般的な直径の拡張を作成/再利用するDiameterアプリケーションの設計者にガイドラインを提供しています。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This memo documents an Internet Best Current Practice.",
      "ja": "このメモはインターネット最も良い現在の練習を説明します。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on BCPs is available in Section 2 of RFC 5741.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。 BCPの詳細については、RFC 5741のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7423.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7423で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2014 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2014 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 3,
      "text": "This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.",
      "ja": "この材料の一部がIETFトラストにこのような材料の変更を許可する権利を与えられていない可能性がありますにこの文書は、2008年、IETFドキュメントまたは11月10日以前に発行または公開さIETF貢献から著作権を支配する者（複数可）材料を含んでいてもよいですIETF標準化プロセスの外。そのような材料の著作権を管理者（単数または複数）から適切なライセンスを取得することなく、この文書は、IETF標準化過程の外側修正されないかもしれません、そして、それの派生物は、IETF標準化過程の外側に作成されない場合があり、それをフォーマットする以外出版RFCとして、英語以外の言語に翻訳します。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   4\n2.  Terminology . . . . . . . . . . . . . . . . . . . . . . . . .   5\n3.  Overview  . . . . . . . . . . . . . . . . . . . . . . . . . .   5\n4.  Reusing Existing Diameter Applications  . . . . . . . . . . .   6\n  4.1.  Adding a New Command  . . . . . . . . . . . . . . . . . .   7\n  4.2.  Deleting an Existing Command  . . . . . . . . . . . . . .   8\n  4.3.  Reusing Existing Commands . . . . . . . . . . . . . . . .   8\n    4.3.1.  Adding AVPs to a Command  . . . . . . . . . . . . . .   8\n    4.3.2.  Deleting AVPs from a Command  . . . . . . . . . . . .  10\n    4.3.3.  Changing the Flag Settings of AVP in Existing\n            Commands  . . . . . . . . . . . . . . . . . . . . . .  11\n  4.4.  Reusing Existing AVPs . . . . . . . . . . . . . . . . . .  11\n    4.4.1.  Setting of the AVP Flags  . . . . . . . . . . . . . .  11\n    4.4.2.  Reuse of AVP of Type Enumerated . . . . . . . . . . .  12\n5.  Defining New Diameter Applications  . . . . . . . . . . . . .  12\n  5.1.  Introduction  . . . . . . . . . . . . . . . . . . . . . .  12\n  5.2.  Defining New Commands . . . . . . . . . . . . . . . . . .  12\n  5.3.  Use of Application Id in a Message  . . . . . . . . . . .  13\n  5.4.  Application-Specific Session State Machines . . . . . . .  14\n  5.5.  Session-Id AVP and Session Management . . . . . . . . . .  14\n  5.6.  Use of Enumerated Type AVPs . . . . . . . . . . . . . . .  15\n  5.7.  Application-Specific Message Routing  . . . . . . . . . .  17\n  5.8.  Translation Agents  . . . . . . . . . . . . . . . . . . .  18\n  5.9.  End-to-End Application Capabilities Exchange  . . . . . .  18\n  5.10. Diameter Accounting Support . . . . . . . . . . . . . . .  19\n  5.11. Diameter Security Mechanisms  . . . . . . . . . . . . . .  21\n6.  Defining Generic Diameter Extensions  . . . . . . . . . . . .  21\n7.  Guidelines for Registrations of Diameter Values . . . . . . .  23\n8.  Security Considerations . . . . . . . . . . . . . . . . . . .  25\n9.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  25\n  9.1.  Normative References  . . . . . . . . . . . . . . . . . .  25\n  9.2.  Informative References  . . . . . . . . . . . . . . . . .  25\nContributors . . . . . . . . . . . . . . . . . . . . . . . . . . . 28\nAcknowledgments . . . . . . . . . . . . . . . . . . . . . . . . .  28\nAuthors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  29",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "The Diameter base protocol [RFC6733] is intended to provide an Authentication, Authorization, and Accounting (AAA) framework for applications such as network access or IP mobility in both local and roaming situations. This protocol provides the ability for Diameter peers to exchange messages carrying data in the form of Attribute-Value Pairs (AVPs).",
      "ja": "直径ベースプロトコル[RFC6733]は、認証、認可、およびそのようなローカル及びローミング両方の状況において、ネットワークアクセス又はIPモビリティなどのアプリケーションに関する会計（AAA）フレームワークを提供することを目的とします。このプロトコルは、属性値ペア（AVPの）の形でデータを運ぶメッセージを交換するためのDiameterピアの能力を提供します。"
    },
    {
      "indent": 3,
      "text": "The Diameter base protocol provides facilities to extend Diameter (see Section 1.3 of [RFC6733]) to support new functionality. In the context of this document, extending Diameter means one of the following:",
      "ja": "直径ベースプロトコルは、新しい機能をサポートするために、（[RFC6733]のセクション1.3を参照）の直径を拡張する機能を提供します。この文書の文脈では、直径を拡張すると、次のいずれかを意味します。"
    },
    {
      "indent": 3,
      "text": "1. The addition of new functionality to an existing Diameter application without defining a new application.",
      "ja": "新しいアプリケーションを定義することなく、既存のDiameterアプリケーションに新しい機能の1添加。"
    },
    {
      "indent": 3,
      "text": "2. The addition of new functionality to an existing Diameter application that requires the definition of a new application.",
      "ja": "新しいアプリケーションを定義する必要があり、既存のDiameterアプリケーションへの新しい機能の追加2.。"
    },
    {
      "indent": 3,
      "text": "3. The definition of an entirely new Diameter application to offer functionality not supported by existing applications.",
      "ja": "3.全く新しいDiameterアプリケーションの定義は、既存のアプリケーションでサポートされていない機能を提供します。"
    },
    {
      "indent": 3,
      "text": "4. The definition of a new generic functionality that can be reused across different applications.",
      "ja": "4.別のアプリケーションで再利用することができ、新たな一般的な機能の定義。"
    },
    {
      "indent": 3,
      "text": "All of these extensions are design decisions that can be carried out by any combination of reusing existing or defining new commands, AVPs, or AVP values. However, application designers do not have complete freedom when making their design. A number of rules have been defined in [RFC6733] that place constraints on when an extension requires the allocation of a new Diameter application identifier or a new command code value. The objective of this document is the following:",
      "ja": "これらの拡張機能のすべては、既存または定義する新しいコマンド、のAVP、またはAVP値を再利用するの任意の組み合わせによって実施することができ、設計上の決定です。その設計を行う場合ただし、アプリケーション設計者は、完全な自由を持っていません。ルールの数は、拡張は、新しいDIAMETERアプリケーション識別子または新しいコマンドコード値の割り当てを必要とするときに、その場所の制約は、[RFC6733]で定義されています。このドキュメントの目的は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o Clarify the Diameter extensibility rules as defined in the Diameter base protocol.",
      "ja": "直径ベースプロトコルで定義されるようにO直径の拡張ルールを明確にします。"
    },
    {
      "indent": 3,
      "text": "o Discuss design choices and provide guidelines when defining new applications.",
      "ja": "Oデザインの選択肢を議論し、新しいアプリケーションを定義する際のガイドラインを提供します。"
    },
    {
      "indent": 3,
      "text": "o Present trade-off choices.",
      "ja": "O現在のトレードオフの選択肢。"
    },
    {
      "indent": 0,
      "text": "2. Terminology",
      "section_title": true,
      "ja": "2.用語"
    },
    {
      "indent": 3,
      "text": "This document reuses the terminology defined in [RFC6733]. Additionally, the following terms and acronyms are used in this application:",
      "ja": "この文書では、[RFC6733]で定義された用語を再利用します。また、以下の用語および略語は、このアプリケーションで使用されています。"
    },
    {
      "indent": 3,
      "text": "Application: Extension of the Diameter base protocol [RFC6733] via the addition of new commands or AVPs. Each application is uniquely identified by an IANA-allocated application identifier value.",
      "ja": "アプリケーション：新しいコマンドまたはのAVPの添加を介して直径ベースプロトコル[RFC6733]の拡張。各アプリケーションは、一意のIANAに割り当てられたアプリケーション識別子値によって識別されます。"
    },
    {
      "indent": 3,
      "text": "Command: Diameter request or answer carrying AVPs between Diameter endpoints. Each command is uniquely identified by an IANA-allocated Command Code value and is described by a Command Code Format (CCF) for an application.",
      "ja": "コマンド：直径エンドポイント間でのAVPを運ぶ直径要求または回答。各コマンドは、一意IANAに割り当てられたコマンドのコード値によって識別され、アプリケーションのためのコマンドコードフォーマット（CCF）により記載されています。"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はあります[RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "3. Overview",
      "section_title": true,
      "ja": "3.概要"
    },
    {
      "indent": 3,
      "text": "As designed, the Diameter base protocol [RFC6733] can be seen as a two-layer protocol. The lower layer is mainly responsible for managing connections between neighboring peers and for message routing. The upper layer is where the Diameter applications reside. This model is in line with a Diameter node having an application layer and a peer-to-peer delivery layer. The Diameter base protocol document defines the architecture and behavior of the message delivery layer and then provides the framework for designing Diameter applications on the application layer. This framework includes definitions of application sessions and accounting support (see Sections 8 and 9 of [RFC6733]). Accordingly, a Diameter node is seen in this document as a single instance of a Diameter message delivery layer and one or more Diameter applications using it.",
      "ja": "設計通りに、ダイアメータベースプロトコル[RFC6733]は二層プロトコルと見なすことができます。下部層は、隣接ピア間のメッセージルーティングのための接続を管理するための主な原因です。 Diameterアプリケーションが存在する場合、上部層です。このモデルは、アプリケーション層とピア・ツー・ピア配信層を有するDiameterノードに沿ったものです。直径ベースプロトコル文書は、メッセージ配信層のアーキテクチャおよび動作を定義し、アプリケーション層上のDiameterアプリケーションを設計するための枠組みを提供します。このフレームワークは、アプリケーション・セッションおよび課金サポートの定義を含む（セクション8および9を参照して、[RFC6733]）。したがって、Diameterノードは、Diameterメッセージ配信層と、それを使用して1つのまたは複数のDiameterアプリケーションの単一のインスタンスとしてこの文書に見られます。"
    },
    {
      "indent": 3,
      "text": "The Diameter base protocol is designed to be extensible and the principles are described in Section 1.3 of [RFC6733]. In summary, Diameter can be extended by the following:",
      "ja": "直径ベースプロトコルは拡張可能であるように設計されており、原理は、[RFC6733]のセクション1.3に記載されています。要約すると、直径は、以下のように拡張することができます。"
    },
    {
      "indent": 3,
      "text": "1. Defining new AVP values",
      "section_title": true,
      "ja": "新しいAVP値を定義する1"
    },
    {
      "indent": 3,
      "text": "2. Creating new AVPs",
      "section_title": true,
      "ja": "2.新しいAVPを作成します"
    },
    {
      "indent": 3,
      "text": "3. Creating new commands",
      "section_title": true,
      "ja": "3.新しいコマンドを作成します"
    },
    {
      "indent": 3,
      "text": "4. Creating new applications",
      "section_title": true,
      "ja": "4.新しいアプリケーションを作成します"
    },
    {
      "indent": 3,
      "text": "As a main guiding principle, application designers SHOULD comply with the following recommendation: \"try to reuse as much as possible!\". It will reduce the time to finalize specification writing, and it will lead to a smaller implementation effort as well as reduce the need for testing. In general, it is clever to avoid duplicate effort when possible.",
      "ja": "主な指導原則として、アプリケーション設計者は、次の推奨事項を遵守する必要があります。「可能な限り再利用してみてください！」。これは、仕様の書き込みを確定するための時間を短縮し、より小さな実装作業につながるだけでなく、試験の必要性を軽減します。一般的には、可能な場合、重複する手間を避けるために巧妙です。"
    },
    {
      "indent": 3,
      "text": "However, reuse is not appropriate when the existing functionality does not fit the new requirement and/or the reuse leads to ambiguity.",
      "ja": "既存の機能は、新しい要件に適合しないおよび/または再利用が曖昧につながるしかし、再利用は適切ではありません。"
    },
    {
      "indent": 3,
      "text": "The impact on extending existing applications can be categorized into two groups:",
      "ja": "既存のアプリケーションを拡張に対する影響は、2つのグループに分類することができます。"
    },
    {
      "indent": 3,
      "text": "Minor Extension: Enhancing the functional scope of an existing application by the addition of optional features to support it. Such enhancement has no backward-compatibility issue with the existing application.",
      "ja": "マイナー拡張：それをサポートするためのオプション機能の追加によって、既存のアプリケーションの機能範囲を強化。このような増強は、既存のアプリケーションとは下位互換性の問題を持っていません。"
    },
    {
      "indent": 6,
      "text": "A typical example would be the definition of a new optional AVP for use in an existing command. Diameter implementations supporting the existing application but not the new AVP will simply ignore it, without consequences for the Diameter message handling, as described in [RFC6733]. The standardization effort will be fairly small.",
      "ja": "典型的な例は、既存のコマンドで使用するための新しいオプションのAVPの定義になります。 [RFC6733]に記載されているようにDiameterメッセージを処理するための影響せずに新しいAVPは、単にそれを無視する既存のアプリケーションではないが、支持直径の実装、。標準化の努力はかなり小さくなります。"
    },
    {
      "indent": 3,
      "text": "Major Extension: Enhancing an application that requires the definition of a new Diameter application. Such enhancement causes a backward-compatibility issue with existing implementations supporting the application.",
      "ja": "主な拡張子：新しいDiameterアプリケーションの定義を必要とするアプリケーションを強化。そのような向上は、アプリケーションをサポートする既存の実装との下位互換性の問題を引き起こします。"
    },
    {
      "indent": 6,
      "text": "Typical examples would be the creation of a new command for providing functionality not supported by existing applications or the definition of a new AVP to be carried in an existing command with the M-bit set in the AVP flags (see Section 4.1 of [RFC6733] for definition of \"M-bit\"). For such an extension, a significant specification effort is required, and a careful approach is recommended.",
      "ja": "典型的な例は、（[RFC6733]のセクション4.1を参照して、既存のアプリケーション又はAVPフラグに設定されたMビットと既存のコマンドで搬送されるべき新たなAVPの定義によってサポートされない機能を提供するための新しいコマンドを作成するであろう「M-ビット」）の定義について。こうした拡張のために、重要な仕様の努力が必要であり、慎重なアプローチが推奨されます。"
    },
    {
      "indent": 0,
      "text": "4. Reusing Existing Diameter Applications",
      "section_title": true,
      "ja": "4.既存のDiameterアプリケーションの再利用"
    },
    {
      "indent": 3,
      "text": "An existing application may need to be enhanced to fulfill new requirements, and these modifications can be at the command level and/or at the AVP level. The following sections describe the possible modifications that can be performed on existing applications and their related impact.",
      "ja": "既存のアプリケーションは、新しい要件を満たすために強化する必要があるかもしれない、とこれらの変更は、コマンドレベルおよび/またはAVPレベルにすることができます。以下のセクションでは、既存のアプリケーションとその関連の影響に行うことができる可能な修飾を記載しています。"
    },
    {
      "indent": 0,
      "text": "4.1. Adding a New Command",
      "section_title": true,
      "ja": "4.1. 新しいコマンドを追加"
    },
    {
      "indent": 3,
      "text": "Adding a new command to an existing application is considered to be a major extension and requires a new Diameter application to be defined, as stated in Section 1.3.4 of [RFC6733]. The need for a new application is because a Diameter node that is not upgraded to support the new command(s) within the (existing) application would reject any unknown command with the protocol error DIAMETER_COMMAND_UNSUPPORTED and cause the failure of the transaction. The new application ensures that Diameter nodes only receive commands within the context of applications they support.",
      "ja": "既存のアプリケーションに新しいコマンドを追加する主要な拡張であると考えられ、[RFC6733]のセクション1.3.4で述べたように、定義する新しいDiameterアプリケーションを必要とします。 （既存の）アプリケーション内で新しいコマンド（複数可）をサポートするようにアップグレードされていないDiameterノードは、プロトコルエラーDIAMETER_COMMAND_UNSUPPORTEDと未知のコマンドを拒否し、トランザクションの障害を引き起こすため、新しいアプリケーションの必要性があります。新しいアプリケーションは、Diameterノードは彼らだけがサポートするアプリケーションのコンテキスト内でコマンドを受信することを保証します。"
    },
    {
      "indent": 3,
      "text": "Adding a new command means either defining a completely new command or importing the command's Command Code Format (CCF) syntax from another application whereby the new application inherits some or all of the functionality of the application from which the command came. In the former case, the decision to create a new application is straightforward, since this is typically a result of adding a new functionality that does not exist yet. For the latter, the decision to create a new application will depend on whether importing the command in a new application is more suitable than simply using the existing application as it is in conjunction with any other application.",
      "ja": "新しいコマンドを追加すると、完全に新しいコマンドを定義したり、新しいアプリケーションは、コマンドが来たから、アプリケーションの機能の一部または全てを継承することにより、別のアプリケーションからのコマンドのコマンドコードフォーマット（CCF）の構文をインポートのいずれかを意味します。これは、一般的にはまだ存在していない新しい機能を追加した結果であるため、前者の場合には、新しいアプリケーションを作成するという決定は、簡単です。後者の場合は、新しいアプリケーションを作成するという決定は、新しいアプリケーションにコマンドをインポートすると、それは他のアプリケーションと連動しているよう単に既存アプリケーションを使用するよりも適しているかどうかに依存します。"
    },
    {
      "indent": 3,
      "text": "An example considers the Diameter Extensible Authentication Protocol (EAP) application [RFC4072] and the Diameter Network Access Server application [RFC7155]. When network access authentication using EAP is required, the Diameter EAP commands (Diameter-EAP-Request/ Diameter-EAP-Answer) are used; otherwise, the Diameter Network Access Server application will be used. When the Diameter EAP application is used, the accounting exchanges defined in the Diameter Network Access Server may be used.",
      "ja": "例は、Diameter拡張認証プロトコル（EAP）アプリケーション[RFC4072]及び直径ネットワークアクセスサーバーアプリケーション[RFC7155]を考えます。 EAPを使用してネットワークアクセス認証が必要な場合、直径EAPコマンド（直径-EAP要求/直径-EAP-回答）が使用されています。それ以外の場合は、直径ネットワークアクセスサーバーアプリケーションが使用されます。直径EAPアプリケーションを用いた場合、直径ネットワークアクセスサーバで定義された課金交換を使用してもよいです。"
    },
    {
      "indent": 3,
      "text": "However, in general, it is difficult to come to a hard guideline, and so a case-by-case study of each application requirement should be applied. Before adding or importing a command, application designers should consider the following:",
      "ja": "しかし、一般的には、ハードガイドラインに来てすることは困難であり、したがって各アプリケーション要件のケース・バイ・ケーススタディが適用されるべきです。コマンドを追加またはインポートする前に、アプリケーションの設計者は次のことを考慮する必要があります。"
    },
    {
      "indent": 3,
      "text": "o Can the new functionality be fulfilled by creating a new command independent from any existing command? In this case, the resulting new application and the existing application can work independent of, but cooperating with, each other.",
      "ja": "oは新機能は、任意の既存のコマンドから独立した新しいコマンドを作成することによって成就することはできますか？この場合には、新たなアプリケーションとの独立して動作することができる既存のアプリケーションを得られるが、互いに、協働。"
    },
    {
      "indent": 3,
      "text": "o Can the existing command be reused without major extensions and, therefore, without the need for the definition of a new application, e.g., new functionality introduced by the creation of new optional AVPs.",
      "ja": "O既存のコマンドは、新しいアプリケーション、新しいオプションのAVPの創出によって導入など、新しい機能の定義を必要とせず、そのため、主要な拡張せずに再利用することができます。"
    },
    {
      "indent": 3,
      "text": "It is important to note that importing commands too liberally could result in a monolithic and hard-to-manage application supporting too many different features.",
      "ja": "あまりにも自由にコマンドをインポートすることはあまりにも多くのさまざまな機能をサポートするモノリシック、ハード・ツー・管理するアプリケーションが生じる可能性があることに注意することが重要です。"
    },
    {
      "indent": 0,
      "text": "4.2. Deleting an Existing Command",
      "section_title": true,
      "ja": "4.2. 既存のコマンドを削除します"
    },
    {
      "indent": 3,
      "text": "Although this process is not typical, removing a command from an application requires a new Diameter application to be defined, and then it is considered as a major extension. This is due to the fact that the reception of the deleted command would systematically result in a protocol error (i.e., DIAMETER_COMMAND_UNSUPPORTED).",
      "ja": "このプロセスは一般的ではないが、アプリケーションからコマンドを除去して定義される新しいDiameterアプリケーションを必要とし、それは主要な拡張として考えられています。これは、削除されたコマンドの受信が系統的プロトコルエラー（即ち、DIAMETER_COMMAND_UNSUPPORTED）をもたらすであろうという事実によるものです。"
    },
    {
      "indent": 3,
      "text": "It is unusual to delete an existing command from an application for the sake of deleting it or the functionality it represents. An exception might be if the intent of the deletion is to create a newer variance of the same application that is somehow simpler than the application initially specified.",
      "ja": "それか、それが表す機能を削除するために、アプリケーションから既存のコマンドを削除することは珍しいです。削除の目的は、当初指定されたアプリケーションよりも何とか簡単です同じアプリケーションの新しい分散を作成する場合は、例外はあるかもしれません。"
    },
    {
      "indent": 0,
      "text": "4.3. Reusing Existing Commands",
      "section_title": true,
      "ja": "4.3. 既存のコマンドを再利用"
    },
    {
      "indent": 3,
      "text": "This section discusses rules in adding and/or deleting AVPs from an existing command of an existing application. The cases described in this section may not necessarily result in the creation of new applications.",
      "ja": "このセクションでは、追加及び/又は既存のアプリケーションの既存のコマンドからAVPを削除するのルールを説明します。このセクションで説明する例は、必ずしも新しいアプリケーションが作成されることがありません。"
    },
    {
      "indent": 3,
      "text": "From a historical point of view, it is worth noting that there was a strong recommendation to reuse existing commands in [RFC3588] to prevent rapid depletion of code values available for vendor-specific commands. However, [RFC6733] has relaxed the allocation policy and enlarged the range of available code values for vendor-specific applications. Although reuse of existing commands is still RECOMMENDED, protocol designers can consider defining a new command when it provides a solution more suitable than the twisting of an existing command's use and applications.",
      "ja": "歴史的観点からは、ベンダー固有のコマンドのために利用可能なコード値の急速な枯渇を防ぐために[RFC3588]で既存のコマンドを再利用することが強く推奨があったことは注目に値します。しかしながら、[RFC6733]は割り当てポリシーを緩和し、ベンダー固有のアプリケーションのために利用できるコード値の範囲を拡大しています。既存のコマンドの再利用はまだお勧めしますが、プロトコルの設計者は、既存のコマンドの使用やアプリケーションのねじれよりも適切なソリューションを提供したときに新しいコマンドを定義することを検討することができます。"
    },
    {
      "indent": 0,
      "text": "4.3.1. Adding AVPs to a Command",
      "section_title": true,
      "ja": "4.3.1. コマンドへのAVPを追加します"
    },
    {
      "indent": 3,
      "text": "Based on the rules in [RFC6733], AVPs that are added to an existing command can be categorized as either:",
      "ja": "[RFC6733]のルールに基づいて、既存のコマンドに追加されたAVPのいずれかに分類することができます。"
    },
    {
      "indent": 3,
      "text": "o Mandatory (to understand) AVPs. As defined in [RFC6733], these are AVPs with the M-bit flag set in this command, which means that the Diameter node receiving them is required to understand not only their values but also their semantics. Failure to do so will cause a message handling error: either an error message with the result-code set to DIAMETER_AVP_UNSUPPORTED if the AVP is not understood in a request or an application-specific error handling if the given AVP is in an answer.",
      "ja": "O強制は、AVPを（理解します）。 [RFC6733]で定義されるように、これらは、それらを受信したDiameterノードは、それらの値だけでなく、その意味ではないだけを理解する必要があることを意味し、このコマンドに設定さMビットのフラグとのAVPです。 AVPは、要求または特定のAVPが答えである場合に扱うアプリケーション固有のエラーで理解されていない場合DIAMETER_AVP_UNSUPPORTEDに結果セット・コードとエラーメッセージのいずれか：そうしないと、メッセージ処理エラーが発生します。"
    },
    {
      "indent": 3,
      "text": "o Optional (to understand) AVPs. As defined in [RFC6733], these are AVPs with the M-bit flag cleared in this command. A Diameter node receiving these AVPs can simply ignore them if it does not support them.",
      "ja": "Oオプションは、AVPを（理解します）。 [RFC6733]で定義されるように、これらは、このコマンドでクリアMビットのフラグとのAVPです。それが彼らをサポートしていない場合は、これらのAVPを受け取るDiameterノードは、単にそれらを無視することができます。"
    },
    {
      "indent": 3,
      "text": "It is important to note that the definitions given above are independent of whether these AVPs are required or optional in the command as specified by the command's CCF syntax [RFC6733].",
      "ja": "コマンドのCCF構文[RFC6733]で指定された上記の定義は、これらのAVPが必要とされているかどうかとは無関係に、またはコマンドでオプションであることに注意することが重要です。"
    },
    {
      "indent": 6,
      "text": "NOTE: As stated in [RFC6733], the M-bit setting for a given AVP is relevant to an application and each command within that application that includes the AVP.",
      "ja": "注：[RFC6733]で述べたように、与えられたAVPの設定MビットアプリケーションとAVPを含み、そのアプリケーション内の各コマンドに関連しています。"
    },
    {
      "indent": 3,
      "text": "The rules are strict in the case where the AVPs to be added in an exiting command are mandatory to understand, i.e., they have the M-bit set. A mandatory AVP MUST NOT be added to an existing command without defining a new Diameter application, as stated in [RFC6733]. This falls into the \"Major Extensions\" category. Despite the clarity of the rule, ambiguity still arises when evaluating whether a new AVP being added should be mandatory to begin with. Application designers should consider the following questions when deciding about the M-bit for a new AVP:",
      "ja": "ルールは、終了コマンドに追加されるのAVPは、すなわち、それらはMビットが設定されている、理解することが必須である場合に厳密です。 [RFC6733]に記載の必須のAVPは、新しいDiameterアプリケーションを定義せずに、既存のコマンドに追加してはいけません。これは「メジャー拡張機能」カテゴリーに入ります。ルールの明確さにもかかわらず、曖昧さがまだ新しいAVPが追加されているかどうかを評価することで開始することが必須であるべきときに生じます。新しいAVPのためのMビットについて決定する際に、アプリケーションの設計者は、以下の質問を検討する必要があります。"
    },
    {
      "indent": 3,
      "text": "o Would it be required for the receiving side to be able to process and understand the AVP and its content?",
      "ja": "O AVPとそのコンテンツを処理し、理解できるように、受信側のために必要なことでしょうか？"
    },
    {
      "indent": 3,
      "text": "o Would the new AVPs change the state machine of the application?",
      "ja": "oが新しいのAVPは、アプリケーションのステートマシンを変更するだろうか？"
    },
    {
      "indent": 3,
      "text": "o Would the presence of the new AVP lead to a different number of round trips, effectively changing the state machine of the application?",
      "ja": "oは効果的にアプリケーションのステートマシンを変更し、ラウンドトリップの異なる多数の新しいAVP鉛の存在でしょうか？"
    },
    {
      "indent": 3,
      "text": "o Would the new AVP be used to differentiate between old and new variances of the same application whereby the two variances are not backward compatible?",
      "ja": "O新しいAVPは、二つの分散が下位互換性がありませんそれによって、同じアプリケーションの新旧の差異を区別するために使用されますか？"
    },
    {
      "indent": 3,
      "text": "o Would the new AVP have duality in meaning, i.e., be used to carry application-related information as well as to indicate that the message is for a new application?",
      "ja": "、すなわち、アプリケーション関連の情報を運ぶためだけでなく、メッセージは、新しいアプリケーションのためのものであることを示すために使用され、O、新たなAVPは意味での二重性を持っているでしょうか？"
    },
    {
      "indent": 3,
      "text": "If the answer to at least one of the questions is \"yes\", then the M-bit MUST be set for the new AVP, and a new Diameter application MUST be defined. This list of questions is non-exhaustive, and other criteria MAY be taken into account in the decision process.",
      "ja": "質問の少なくとも一方が「はい」で答えることがあれば、Mビットは、新しいAVPのために設定しなければならなくて、新しいDiameterアプリケーションを定義する必要があります。質問のこのリストは非網羅的であり、他の基準が決定プロセスにおいて考慮されるかもしれません。"
    },
    {
      "indent": 3,
      "text": "If application designers are instead contemplating the use of optional AVPs, i.e., with the M-bit cleared, there are still pitfalls that will cause interoperability problems; therefore, they must be avoided. Some examples of these pitfalls are as follows:",
      "ja": "アプリケーション設計者ではなく、オプションのAVPの使用を検討している場合はMビットをクリアして、すなわち、相互運用性の問題が発生します落とし穴が残っています。そのため、彼らは避けなければなりません。次のようにこれらの落とし穴のいくつかの例は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "o Use of optional AVPs with intersecting meaning. One AVP has partially the same usage and meaning as another AVP. The presence of both can lead to confusion.",
      "ja": "Oの意味を交差すると、オプションのAVPの使用。一つのAVPは、部分的に別のAVPと同じ用法と意味を持っています。両方の存在は混乱につながることができます。"
    },
    {
      "indent": 3,
      "text": "o Optional AVPs with dual purpose, i.e., to carry application data as well as to indicate support for one or more features. This has a tendency to introduce interpretation issues.",
      "ja": "O二重の目的を持つオプションのAVPは、すなわち、アプリケーションデータを運ぶだけでなく、一つ以上の機能のサポートを示すために。これは解釈の問題を導入する傾向があります。"
    },
    {
      "indent": 3,
      "text": "o Adding one or more optional AVPs and indicating (usually within descriptive text for the command) that at least one of them has to be understood by the receiver of the command. This would be equivalent to adding a mandatory AVP, i.e., an AVP with the M-bit set, to the command.",
      "ja": "O 1つ以上の任意のAVPを追加し、それらの少なくとも1つは、コマンドの受信機によって理解されなければならないこと（通常コマンドの説明テキスト内）を示します。これは、コマンドに、Mビットのセットで必須AVP、即ち、AVPを追加することと同じであろう。"
    },
    {
      "indent": 0,
      "text": "4.3.2. Deleting AVPs from a Command",
      "section_title": true,
      "ja": "4.3.2. コマンドからのAVPを削除します"
    },
    {
      "indent": 3,
      "text": "Application designers may want to reuse an existing command, but some of the AVPs present in the command's CCF syntax specification may be irrelevant for the functionality foreseen to be supported by this command. It may be then tempting to delete those AVPs from the command.",
      "ja": "アプリケーション設計者は、既存のコマンドを再利用することもできますが、予見機能は、このコマンドでサポートされるようにするためのコマンドのCCFの構文仕様に存在するのAVPのいくつかは無関係かもしれません。コマンドからこれらのAVPを削除したくても良いです。"
    },
    {
      "indent": 3,
      "text": "The impacts of deleting an AVP from a command depends on its Command Code format specification and M-bit setting:",
      "ja": "コマンドからのAVPの削除の影響は、そのコマンドコードフォーマット仕様とMビットの設定に依存します。"
    },
    {
      "indent": 3,
      "text": "o Case 1: Deleting an AVP that is indicated as a required AVP (noted as {AVP}) in the command's CCF syntax specification (regardless of the M-bit setting).",
      "ja": "oケース1：（かかわらず、Mビットの設定）コマンドのCCF構文仕様で必要なAVP（{AVP}と表記）として示されているAVPを削除します。"
    },
    {
      "indent": 6,
      "text": "In this case, a new Command Code, and subsequently a new Diameter application, MUST be specified.",
      "ja": "この場合、新しいコマンドコード、その後、新しいDiameterアプリケーションでは、指定されなければなりません。"
    },
    {
      "indent": 3,
      "text": "o Case 2: Deleting an AVP, which has the M-bit set, and is indicated as an optional AVP (noted as [AVP] in the command CCF) in the command's CCF syntax specification.",
      "ja": "oケース2：Mビットセットを有するAVPを、削除、およびコマンドのCCF構文仕様で任意AVP（コマンドCCFの[AVP]と表記）として示されています。"
    },
    {
      "indent": 6,
      "text": "In this case, no new Command Code has to be specified, but the definition of a new Diameter application is REQUIRED.",
      "ja": "この場合には、新しいコマンドコードを指定する必要がありませんが、新しいDiameterアプリケーションの定義が必要となります。"
    },
    {
      "indent": 3,
      "text": "o Case 3: Deleting an AVP, which has the M-bit cleared, and is indicated as [AVP] in the command's CCF syntax specification.",
      "ja": "oケース3：MビットがクリアされたAVPを、削除、およびコマンドのCCFの構文仕様に[AVP]として示されています。"
    },
    {
      "indent": 6,
      "text": "In this case, the AVP can be deleted without consequences.",
      "ja": "この場合、AVPは影響せずに削除することができます。"
    },
    {
      "indent": 3,
      "text": "Application designers SHOULD attempt to reuse the command's CCF syntax specification without modification and simply ignore (but not delete) any optional AVPs that will not be used. This is to maintain compatibility with existing applications that will not know about the new functionality as well as to maintain the integrity of existing dictionaries.",
      "ja": "アプリケーション設計者は使用されません任意のオプションのAVPを変更せずに、コマンドのCCFの構文仕様を再利用し、単に無視する（ただし、削除しない）を試みる必要があります。これは、新しい機能について知ることができませんだけでなく、既存の辞書の整合性を維持するために、既存のアプリケーションとの互換性を維持することです。"
    },
    {
      "indent": 0,
      "text": "4.3.3. Changing the Flag Settings of AVP in Existing Commands",
      "section_title": true,
      "ja": "4.3.3. 既存のコマンドでAVPのフラグ設定を変更します"
    },
    {
      "indent": 3,
      "text": "Although unusual, implementors may want to change the setting of the AVP flags a given AVP used in a command.",
      "ja": "珍しいが、実装者は、与えられたAVPは、コマンドで使用されるAVPフラグの設定を変更することもできます。"
    },
    {
      "indent": 3,
      "text": "Into an existing command, an AVP that was initially defined as a mandatory AVP to understand, i.e., an AVP with the M-bit flag set in the command MAY be safely turned to an optional AVP, i.e., with the M-bit cleared. Any node supporting the existing application will still understand the AVP, whatever the setting of the M-bit. On the contrary, an AVP initially defined as an optional AVP to understand, i.e., an AVP with the M-bit flag cleared in the command MUST NOT be changed into a mandatory AVP with the M-bit flag set without defining a new Diameter application. Setting the M-bit for an AVP that was defined as an optional AVP is equivalent to adding a new mandatory AVP to an existing command, and the rules given in Section 4.3.1 apply.",
      "ja": "Mビットをクリアしてコマンドで設定さMビットのフラグは安全に、即ち、任意AVPにターンオンされると、既存のコマンド、最初に理解するために必須のAVP、即ち、として定義されたAVP、AVPに。まだAVP、Mビットのどんな設定を理解する既存のアプリケーションをサポートする任意のノード。逆に、最初に理解するオプションAVPとして定義AVPは、すなわち、コマンドでクリアMビットフラグとAVPは、新しいDiameterアプリケーションを定義せずにMビットのフラグがセットされた必須のAVPに変更してはなりません。任意AVPとして定義されたAVPのためのMビットを設定すると、既存のコマンドに新しい必須AVPを追加すること、およびセクション4.3.1で指定されたルールが適用さと同等です。"
    },
    {
      "indent": 3,
      "text": "All other AVP flags (V-bit, P-bit, reserved bits) MUST remain unchanged.",
      "ja": "他のすべてのAVPフラグ（Vビット、Pビット、予約ビット）は不変のままでなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.4. Reusing Existing AVPs",
      "section_title": true,
      "ja": "4.4. 既存のAVPを再利用"
    },
    {
      "indent": 3,
      "text": "This section discusses rules in reusing existing AVPs when reusing an existing command or defining a new command in a new application.",
      "ja": "このセクションでは、既存のコマンドを再利用したり、新しいアプリケーションに新しいコマンドを定義するときに、既存のAVPを再利用するには、ルールを説明します。"
    },
    {
      "indent": 0,
      "text": "4.4.1. Setting of the AVP Flags",
      "section_title": true,
      "ja": "4.4.1.  AVPフラグの設定"
    },
    {
      "indent": 3,
      "text": "When reusing existing AVPs in a new application, application designers MUST specify the setting of the M-bit flag for a new Diameter application and, if necessary, for every command of the application that can carry these AVPs. In general, for AVPs defined outside of the Diameter base protocol, the characteristics of an AVP are tied to its role within a given application and the commands used in this application.",
      "ja": "新しいアプリケーションの既存のAVPを再利用する場合、必要に応じて、アプリケーション設計者は、これらのAVPを運ぶことができ、アプリケーションのすべてのコマンドのために、新しいDiameterアプリケーションのためのMビット・フラグの設定を指定しなければなりません。一般的に、直径ベースプロトコルの外で定義のAVPのために、AVPの特性は、所与のアプリケーション内でその役割に関連付けされたコマンドは、このアプリケーションで使用されます。"
    },
    {
      "indent": 3,
      "text": "All other AVP flags (V-bit, P-bit, reserved bits) MUST remain unchanged.",
      "ja": "他のすべてのAVPフラグ（Vビット、Pビット、予約ビット）は不変のままでなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.4.2. Reuse of AVP of Type Enumerated",
      "section_title": true,
      "ja": "4.4.2. タイプ列挙のAVPの再利用"
    },
    {
      "indent": 3,
      "text": "When reusing an AVP of type Enumerated in a command for a new application, it is RECOMMENDED to avoid modifying the set of valid values defined for this AVP. Modifying the set of Enumerated values includes adding a value or deprecating the use of a value defined initially for the AVP. Modifying the set of values will impact the application defining this AVP and all the applications using this AVP, causing potential interoperability issues: a value used by a peer that will not be recognized by all the nodes between the client and the server will cause an error response with the Result-Code AVP set to DIAMETER_INVALID_AVP_VALUE. When the full range of values defined for this Enumerated AVP is not suitable for the new application, it is RECOMMENDED that a new AVP be defined to avoid backward-compatibility issues with existing implementations.",
      "ja": "新しいアプリケーションのためのコマンドで列挙タイプのAVPを再利用する場合、このAVPのために定義された有効な値のセットを変更しないことをお勧めします。列挙された値のセットを変更する値を加算又はAVPのために最初に定義された値の使用を非推奨含みます。一連の値を変更すると、潜在的な相互運用性の問題を引き起こして、このAVPを定義するアプリケーションとこのAVPを使用しているすべてのアプリケーションに影響を与えます：クライアントとサーバー間のすべてのノードで認識されないピアで使用される値は、エラーが発生します結果 - コードAVPとの応答がDIAMETER_INVALID_AVP_VALUEに設定します。この列挙AVPのために定義された値の全範囲は、新たなアプリケーションには適していない場合には、新たなAVPは、既存の実装との下位互換性の問題を回避するために定義されることが推奨されます。"
    },
    {
      "indent": 0,
      "text": "5. Defining New Diameter Applications",
      "section_title": true,
      "ja": "5.定義新しいDiameterアプリケーション"
    },
    {
      "indent": 0,
      "text": "5.1. Introduction",
      "section_title": true,
      "ja": "5.1. 前書き"
    },
    {
      "indent": 3,
      "text": "This section discusses the case where new applications have requirements that cannot be fulfilled by existing applications and would require definition of completely new commands, AVPs, and/or AVP values. Typically, there is little ambiguity about the decision to create these types of applications. Some examples are the interfaces defined for the IP Multimedia Subsystem of 3GPP, e.g., Cx/Dx ([TS29.228] and [TS29.229]), Sh ([TS29.328] and [TS29.329]), etc.",
      "ja": "このセクションでは、新しいアプリケーションが既存のアプリケーションによって満たすことができないと、完全に新しいコマンド、のAVP、および/またはAVP値の定義を必要とする要件を持っている場合について説明します。一般的に、これらのタイプのアプリケーションを作成するための決定について少し曖昧さがあります。いくつかの例は、3GPPのIPマルチメディアサブシステム、例えば、Cxの/ Dxを（[TS29.228]と[TS29.229]）、のSh（[TS29.328]と[TS29.329]）、等のために定義されたインタフェースであります"
    },
    {
      "indent": 3,
      "text": "Application designers SHOULD try to import existing AVPs and AVP values for any newly defined commands. In certain cases where accounting will be used, the models described in Section 5.10 SHOULD also be considered.",
      "ja": "アプリケーション設計者は、新しく定義されたコマンドのために、既存のAVPおよびAVP値をインポートしてみてください。会計は使用される特定の例では、第5.10節で説明したモデルも考慮すべきです。"
    },
    {
      "indent": 3,
      "text": "Additional considerations are described in the following sections.",
      "ja": "その他の考慮事項は、次のセクションで説明されています。"
    },
    {
      "indent": 0,
      "text": "5.2. Defining New Commands",
      "section_title": true,
      "ja": "5.2. 新しいコマンドを定義します"
    },
    {
      "indent": 3,
      "text": "As a general recommendation, commands SHOULD NOT be defined from scratch. It is instead RECOMMENDED to reuse an existing command offering similar functionality and use it as a starting point. Code reuse leads to a smaller implementation effort as well as reduces the need for testing.",
      "ja": "一般的な推奨事項として、コマンドは最初から定義されるべきではありません。代わりに同様の機能を提供し、既存のコマンドを再利用し、出発点としてそれを使用することをお勧めします。コードの再利用は、小さな実装作業につながるだけでなく、テストの必要性を低減します。"
    },
    {
      "indent": 3,
      "text": "Moreover, the new command's CCF syntax specification SHOULD be carefully defined when considering applicability and extensibility of the application. If most of the AVPs contained in the command are indicated as fixed or required, it might be difficult to reuse the same command and, therefore, the same application in a slightly changed environment. Defining a command with most of the AVPs indicated as optional is considered as a good design choice in many cases, despite the flexibility it introduces in the protocol. Protocol designers MUST clearly state the reasons why these optional AVPs might or might not be present and properly define the corresponding behavior of the Diameter nodes when these AVPs are absent from the command.",
      "ja": "アプリケーションの適用性と拡張性を考慮した場合また、新しいコマンドのCCFの構文仕様は、慎重に定義する必要があります。固定または必要に応じて、コマンドに含まれるのAVPのほとんどが示されている場合、わずかに変更環境で同じアプリケーション従って、同じコマンドを再利用することは困難かもしれません。オプションとして示さのAVPのほとんどを使用して、コマンドを定義することは、それはプロトコルで紹介する柔軟性にもかかわらず、多くの場合、良いデザインの選択肢として考えられています。プロトコル設計者は、これらの任意のAVPは、または存在しても、適切にこれらのAVPは、コマンドから存在しない場合Diameterノードの対応する動作を定義していないかもしれないかもしれない理由を明確に述べなければなりません。"
    },
    {
      "indent": 6,
      "text": "NOTE: As a hint for protocol designers, it is not sufficient to just look at the command's CCF syntax specification. It is also necessary to carefully read through the accompanying text in the specification.",
      "ja": "注：プロトコル設計者のためのヒントとして、それだけで、コマンドのCCFの構文仕様を見てするのに十分ではありません。慎重仕様で添付テキストを読むためにも必要です。"
    },
    {
      "indent": 3,
      "text": "In the same way, the CCF syntax specification SHOULD be defined such that it will be possible to add any arbitrary optional AVPs with the M-bit cleared (including vendor-specific AVPs) without modifying the application. For this purpose, \"* [AVP]\" SHOULD be added in the command's CCF, which allows the addition of any arbitrary number of optional AVPs as described in [RFC6733].",
      "ja": "同様に、CCFの構文仕様は、アプリケーションを変更せずに（ベンダー固有のAVPを含む）をクリアMビットと任意の随意AVPを追加することが可能となるように定義されるべきです。この目的のために、「* [AVP]」[RFC6733]に記載されているように任意のAVPの任意の数の付加を可能にするコマンドのCCFに添加されるべきです。"
    },
    {
      "indent": 0,
      "text": "5.3. Use of Application Id in a Message",
      "section_title": true,
      "ja": "5.3. メッセージでのアプリケーションIDの使用"
    },
    {
      "indent": 3,
      "text": "When designing new applications, application designers SHOULD specify that the Application Id carried in all session-level messages is the Application Id of the application using those messages. This includes the session-level messages defined in the Diameter base protocol, i.e., Re-Auth-Request (RAR) / Re-Auth-Answer (RAA), Session-Termination-Request (STR) / Session-Termination-Answer (STA), Abort-Session-Request (ASR) / Abort-Session-Answer (ASA), and possibly Accounting-Request (ACR) / Accounting Answer (ACA) in the coupled accounting model; see Section 5.10. Some existing specifications do not adhere to this rule for historical reasons. However, this guidance SHOULD be followed by new applications to avoid routing problems.",
      "ja": "新しいアプリケーションを設計する場合、アプリケーション設計者は、すべてのセッション・レベルのメッセージで運ばれたアプリケーションIDは、それらのメッセージを使用したアプリケーションのアプリケーションIDであることを指定する必要があります。これは、Diameterベースのプロトコルで定義されたセッション・レベルのメッセージを含む、すなわち、再認証リクエスト（RAR）/再AUTH-回答（RAA）、セッ​​ション終了リクエスト（STR）/セッション終了-回答（STA ）、アボートセッション要求（ASR）/アボートセッション応答（ASA）、およびおそらくアカウンティング要求（ACR）を/アカウンティング回答（ACA）結合された会計モデルにおいて、 5.10を参照してください。いくつかの既存の仕様は、歴史的な理由のために、このルールに準拠していません。しかし、このガイダンスは、ルーティングの問題を回避するために、新しいアプリケーションを記述する必要があります。"
    },
    {
      "indent": 3,
      "text": "When a new application has been allocated with a new Application Id and it also reuses existing commands with or without modifications, the commands SHOULD use the newly allocated Application Id in the header and in all relevant Application-Id AVPs (Auth-Application-Id or Acct-Application-Id) present in the commands message body.",
      "ja": "新しいアプリケーションは、新しいアプリケーションIDに割り当てられており、それはまた、変更の有無にかかわらず、既存のコマンドを再利用する場合、コマンドは、ヘッダに関連するすべてのアプリケーション-IDのAVP（AUTH-アプリケーションIDまたはで新たに割り当てられたアプリケーションIDを使用する必要がありますACCT-アプリケーション-ID）コマンドメッセージの本文中に存在します。"
    },
    {
      "indent": 3,
      "text": "Additionally, application designers using a vendor-specific Application-Id AVP SHOULD NOT use the Vendor-Id AVP to further dissect or differentiate the vendor-specification Application Id. Diameter routing is not based on the Vendor Id. As such, the Vendor Id SHOULD NOT be used as an additional input for routing or delivery of messages. The Vendor-Id AVP is an informational AVP only and kept for backward compatibility reasons.",
      "ja": "また、使用するアプリケーションの設計者、ベンダー固有のアプリケーション-ID AVPはさらに切開またはベンダー仕様アプリケーションIDを区別するためにベンダーID AVPを使用しないでください。直径ルーティングは、ベンダーIDに基づいていません。このように、ベンダIDがルーティングまたはメッセージの配信のための追加の入力として使用することはできません。ベンダーID AVPは、情報提供のみをAVPであるとの後方互換性のために保持しました。"
    },
    {
      "indent": 0,
      "text": "5.4. Application-Specific Session State Machines",
      "section_title": true,
      "ja": "5.4. アプリケーション固有のセッション状態マシン"
    },
    {
      "indent": 3,
      "text": "Section 8 of [RFC6733] provides session state machines for AAA services, and these session state machines are not intended to cover behavior outside of AAA. If a new application cannot clearly be categorized into any of these AAA services, it is RECOMMENDED that the application define its own session state machine. Support for a server-initiated request is a clear example where an application-specific session state machine would be needed, for example, the Rw interface for the ITU-T push model (cf. [Q.3303.3]).",
      "ja": "[RFC6733]のセクション8は、AAAサービスのためのセッション・ステート・マシンを提供し、これらのセッション・ステート・マシンは、AAAの外の行動をカバーすることが意図されていません。新しいアプリケーションは明らかにこれらのAAAサービスのいずれかに分類することができない場合は、アプリケーションが独自のセッション・ステート・マシンを定義することをお勧めします。サーバ起動要求のサポートアプリケーション固有のセッション状態機械は、例えば、必要とされる明確な例であり、ITU-TプッシュモデルのRwとインタフェース（参照[Q.3303.3]）。"
    },
    {
      "indent": 0,
      "text": "5.5. Session-Id AVP and Session Management",
      "section_title": true,
      "ja": "5.5. セッションId AVPとセッション管理"
    },
    {
      "indent": 3,
      "text": "Diameter applications are usually designed with the aim of managing user sessions (e.g., Diameter Network Access Server (NAS) application [RFC4005]) or a specific service access session (e.g., Diameter SIP application [RFC4740]). In the Diameter base protocol, session state is referenced using the Session-Id AVP. All Diameter messages that use the same Session-Id will be bound to the same session. Diameter-based session management also implies that both the Diameter client and server (and potentially proxy agents along the path) maintain session state information.",
      "ja": "Diameterアプリケーションは、通常、ユーザセッション（例えば、直径ネットワークアクセスサーバ（NAS）アプリケーション[RFC4005]）、または特定のサービスへのアクセスセッションを管理する目的で設計されている（例えば、直径SIPアプリケーション[RFC4740]）。直径ベースプロトコルでは、セッション状態がセッションId AVPを使用して参照されます。同じセッションIDを使用するすべてのDiameterメッセージは、同じセッションにバインドされます。直径ベースのセッション管理はまた、Diameterクライアントとサーバー（およびパスに沿って、潜在的に、プロキシエージェント）の両方が、セッション状態情報を維持することを意味します。"
    },
    {
      "indent": 3,
      "text": "However, some applications may not need to rely on the Session-Id to identify and manage sessions because other information can be used instead to correlate Diameter messages. Indeed, the User-Name AVP or any other specific AVP can be present in every Diameter message and used, therefore, for message correlation. Some applications might not require the notion of the Diameter-session concept at all. For such applications, the Auth-Session-State AVP is usually set to NO_STATE_MAINTAINED in all Diameter messages, and these applications are, therefore, designed as a set of stand-alone transactions. Even if an explicit access session termination is required, application-specific commands are defined and used instead of the STR/STA or ASR/ ASA defined in the Diameter base protocol [RFC6733]. In such a case, the Session-Id is not significant.",
      "ja": "ただし、一部のアプリケーションでは、他の情報は、Diameterメッセージを相関させる代わりに使用することができますので、セッションを識別し、管理するためのセッションIdに依存する必要はないかもしれません。実際に、ユーザ名AVPまたは任意の他の特定のAVPは、メッセージ相関のため、従って、すべてのDiameterメッセージに存在し、使用することができます。一部のアプリケーションは、すべての直径セッション概念の概念を必要としない場合があります。このような用途のために、認証・セッション状態AVPは、通常、すべてのDiameterメッセージにNO_STATE_MAINTAINEDに設定され、これらのアプリケーションは、そのため、スタンドアローンのトランザクションのセットとして設計されています。明示的なアクセスセッション終了が必要な場合でも、アプリケーション固有のコマンドを代わりSTR / STAまたはDIAMETERベースプロトコル[RFC6733]で定義されたASR / ASAの定義および使用されています。そのような場合には、セッションIdは重要ではありません。"
    },
    {
      "indent": 3,
      "text": "Based on these considerations, protocol designers should carefully appraise whether the Diameter application being defined relies on the session management specified in the Diameter base protocol:",
      "ja": "これらの考慮事項に基づいて、プロトコル設計者は慎重に定義されているDiameterアプリケーションは、直径ベースプロトコルで指定されたセッション管理に依存しているかどうかを鑑定する必要があります。"
    },
    {
      "indent": 3,
      "text": "o If it is, the Diameter command defined for the new application MUST include the Session-Id AVP defined in the Diameter base protocol [RFC6733], and the Session-Id AVP MUST be used for correlation of messages related to the same session. Guidance on the use of the Auth-Session-State AVP is given in the Diameter base protocol [RFC6733].",
      "ja": "そうである場合、O、新しいアプリケーション用に定義された直径のコマンドは、AVPは直径ベースプロトコル[RFC6733]で定義され、そしてセッションId AVPは、同じセッションに関連するメッセージの相関のために使用されなければならないセッションIDを含める必要があります。 AUTH-セッション状態AVPの使用に関するガイダンスは、ダイアメータベースプロトコル[RFC6733]に記載されています。"
    },
    {
      "indent": 3,
      "text": "o Otherwise, because session management is not required or the application relies on its own session management mechanism, Diameter commands for the application need not include the Session-Id AVP. If any specific session management concept is supported by the application, the application documentation MUST clearly specify how the session is handled between the client and server (and possibly Diameter agents in the path). Moreover, because the application is not maintaining session state at the Diameter base protocol level, the Auth-Session-State AVP MUST be included in all Diameter commands for the application and MUST be set to NO_STATE_MAINTAINED.",
      "ja": "セッション管理が必要とされていないか、またはアプリケーションが独自のセッション管理メカニズムに依存しているため、Oそれ以外の場合は、アプリケーションのための直径コマンドは、セッションId AVPを含める必要はありません。任意の特定のセッション管理という概念がアプリケーションによってサポートされている場合、アプリケーションのドキュメントは明らかにセッションが（パスに、おそらく直径エージェント）クライアントとサーバの間で処理される方法を指定する必要があります。アプリケーションは直径ベースプロトコルレベルでセッション状態を維持されていないため、また、AUTH-セッション状態AVPは、アプリケーションのすべてのDiameterコマンドに含まれなければならないとNO_STATE_MAINTAINEDに設定しなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.6. Use of Enumerated Type AVPs",
      "section_title": true,
      "ja": "5.6. 列挙型のAVPの使用"
    },
    {
      "indent": 3,
      "text": "The type Enumerated was initially defined to provide a list of valid values for an AVP with their respective interpretation described in the specification. For instance, AVPs of type Enumerated can be used to provide further information on the reason for the termination of a session or a specific action to perform upon the reception of the request.",
      "ja": "列挙型が当初明細書に記載されたそれぞれの解釈とAVPのための有効な値のリストを提供するために定義されました。例えば、タイプ列挙ののAVPは、セッションの終了、または要求の受信時に実行する特定のアクションの理由に関する追加情報を提供するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "As described in Section 4.4.2 above, defining an AVP of type Enumerated presents some limitations in terms of extensibility and reusability. Indeed, the finite set of valid values defined in the definition of the AVP of type Enumerated cannot be modified in practice without causing backward-compatibility issues with existing implementations. As a consequence, AVPs of type Enumerated MUST NOT be extended by adding new values to support new capabilities. Diameter protocol designers SHOULD carefully consider before defining an Enumerated AVP whether the set of values will remain unchanged or new values may be required in the near future. If such an extension is foreseen or cannot be avoided, it is RECOMMENDED to define AVPs of type Unsigned32 or Unsigned64 in which the data field would contain an address space representing \"values\" that would have the same use of Enumerated values. Whereas only the initial values defined at the definition of the AVP of type Enumerated are valid as described in Section 4.4.2, any value from the address space from 0 to 2^32 - 1 for AVPs of type Unsigned32 or from 0 to 2^64 - 1 for AVPs of type Unsigned64 is valid at the Diameter base protocol level and will not cause interoperability issues for intermediary nodes between clients and servers. Only clients and servers will be able to process the values at the application layer.",
      "ja": "上記セクション4.4.2に記載したように、型のAVPを定義列挙は、拡張性と再利用の点でいくつかの制限を提示します。確かに、タイプ列挙のAVPの定義で定義された有効な値の有限集合は、既存の実装との下位互換性の問題を引き起こすことなく、実際に変更することはできません。その結果、タイプ列挙のAVPのは、新しい機能をサポートするために、新しい値を追加することによって拡張することはできません。 Diameterプロトコルの設計者は慎重値のセットは変わらないか、または新しい値が近い将来に必要とすることができるかどうかを列挙AVPを定義する前に検討すべきです。そのような拡張が予想されるまたは回避することができない場合は、データフィールドが列挙値の同じ使用を持っているでしょう「値」を表すアドレス空間を含んでいるでしょうするタイプUnsigned32のかUnsigned64にのAVPを定義することをお勧めします。タイプUnsigned32には0から2までのAVP 1 ^  - セクション4.4.2に記載のように列挙型のAVPの定義で定義されている唯一の初期値は、0から2 ^ 32のアドレス空間から任意の値有効であるのに対し64  - タイプUnsigned64にのAVPのための1は、Diameterベースのプロトコルレベルで有効であり、クライアントとサーバ間の中間ノードのための相互運用性の問題が発生することはありません。唯一のクライアントとサーバは、アプリケーション層で値を処理することができるようになります。"
    },
    {
      "indent": 3,
      "text": "For illustration, an AVP describing possible access networks would be defined as follows:",
      "ja": "次のように説明のために、可能なアクセスネットワークを記述するAVPが定義されます。"
    },
    {
      "indent": 4,
      "text": "Access-Network-Type AVP (XXX) is of type Unsigned32 and contains a 32-bit address space representing types of access networks. This application defines the following classes of access networks, all identified by the thousands digit in the decimal notation:",
      "ja": "アクセスネットワークタイプAVP（XXX）はタイプUnsigned32にあり、アクセスネットワークの種類を表す32ビットのアドレス空間を含んでいます。このアプリケーションは、10進数で数千の桁によって識別されたアクセスネットワークの次のクラスは、すべてを定義しています。"
    },
    {
      "indent": 4,
      "text": "o 1xxx (Mobile Access Networks)",
      "ja": "Oの1XXX（モバイルアクセスネットワーク）"
    },
    {
      "indent": 4,
      "text": "o 2xxx (Fixed Access Networks)",
      "ja": "Oの2XXX（固定アクセスネットワーク）"
    },
    {
      "indent": 4,
      "text": "o 3xxx (Wireless Access Networks)",
      "ja": "Oの3XXX（無線アクセスネットワーク）"
    },
    {
      "indent": 4,
      "text": "Values that fall within the Mobile Access Networks category are used to inform a peer that a request has been sent for a user attached to a mobile access network. The following values are defined in this application:",
      "ja": "モバイルアクセスネットワークのカテゴリに入る値は、要求は、モバイル・アクセス・ネットワークに接続されているユーザーのために送られた相手に知らせるために使用されています。次の値は、このアプリケーションで定義されています。"
    },
    {
      "indent": 4,
      "text": "1001: 3GPP-GERAN",
      "ja": "1001：Jbjra"
    },
    {
      "indent": 7,
      "text": "The user is attached to a Global System for Mobile Communications (GSM) Enhanced Data rates for GSM Evolution (EDGE) Radio Access Network.",
      "ja": "ユーザは、モバイル通信用グローバルシステム（GSM）GSMエボリューション（EDGE）無線アクセスネットワークのための拡張データレートに取り付けられています。"
    },
    {
      "indent": 4,
      "text": "1002: 3GPP-UTRAN-FDD",
      "ja": "1002：3GPP-UTRAN FDD"
    },
    {
      "indent": 7,
      "text": "The user is attached to a Universal Mobile Telecommunications System (UMTS) access network that uses frequency-division duplexing for duplexing.",
      "ja": "ユーザは、二重化のために周波数分割複信を使用ユニバーサル・モバイル・テレコミュニケーション・システム（UMTS）アクセスネットワークに接続されています。"
    },
    {
      "indent": 3,
      "text": "Unlike Enumerated AVP, any new value can be added in the address space defined by this Unsigned32 AVP without modifying the definition of the AVP. There is, therefore, no risk of backward-compatibility issues, especially when intermediate nodes may be present between Diameter endpoints.",
      "ja": "列挙AVPとは異なり、任意の新しい値はAVPの定義を変更することなく、このUnsigned32のAVPによって定義されたアドレス空間に追加することができます。下位互換性の問題の危険性は、中間ノードが直径エンドポイント間に存在してもよい場合は特に、したがって、存在しません。"
    },
    {
      "indent": 3,
      "text": "Along the same line, AVPs of type Enumerated are too often used as a simple Boolean flag, indicating, for instance, a specific permission or capability; therefore, only three values are defined, e.g., TRUE/ FALSE, AUTHORIZED/UNAUTHORIZED, or SUPPORTED/UNSUPPORTED. This is a sub-optimal design since it limits the extensibility of the application: any new capability/permission would have to be supported by a new AVP or new Enumerated value of the already-defined AVP, with the backward-compatibility issues described above. Instead of using an Enumerated AVP for a Boolean flag, protocol designers SHOULD use AVPs of type Unsigned32 or Unsigned64 in which the data field would be defined as a bit mask whose bit settings are described in the relevant Diameter application specification. Such AVPs can be reused and extended without major impact on the Diameter application. The bit mask SHOULD leave room for future additions. Examples of AVPs that use bit masks are the Session-Binding AVP defined in [RFC6733] and the MIP6-Feature-Vector AVP defined in [RFC5447].",
      "ja": "同じラインに沿って、列挙型のAVPは、あまりにも頻繁に、例えば、特定の許可又は能力を示す、単純なブール・フラグとして使用されます。従って、3つだけの値が定義され、例えば、TRUE / FALSE、AUTHORIZED /不正、またはサポートされている/サポートされていません。すべての新機能/許可は、上述の下位互換性の問題で、既に定義されたAVPの新しいAVPまたは新しい列挙値によってサポートされる必要があります：それはアプリケーションの拡張性を制限するので、これは次善のデザインです。代わりに、ブールフラグに列挙AVPを使用する、プロトコル設計者は、データ・フィールドは、そのビットの設定は、関連するDiameterアプリケーションの仕様に記載されているビットマスクとして定義されるであろうタイプUnsigned32の又はUnsigned64にのAVPを使用すべきです。そのようなのAVPを再利用し、Diameterアプリケーションに大きな影響を与えることなく拡張することができます。ビットマスクは、将来の追加のための余地を残すべきです。ビットマスクを使用するのAVPの例としては、[RFC6733]で定義されたセッション結合AVPと[RFC5447]で定義さMIP6-特徴ベクトルAVPです。"
    },
    {
      "indent": 0,
      "text": "5.7. Application-Specific Message Routing",
      "section_title": true,
      "ja": "5.7. アプリケーション固有のメッセージルーティング"
    },
    {
      "indent": 3,
      "text": "As described in [RFC6733], a Diameter request that needs to be sent to a home server serving a specific realm, but not to a specific server (such as the first request of a series of round trips), will contain a Destination-Realm AVP and no Destination-Host AVP.",
      "ja": "[RFC6733]に記載されているように、特定の領域にサービスを提供するホームサーバにではなく、（例えば、往復の一連の最初の要求のような）特定のサーバに送信する必要がある直径要求は、宛先領域を含有しますAVPなし宛先ホストAVP。"
    },
    {
      "indent": 3,
      "text": "For such a request, the message routing usually relies only on the Destination-Realm AVP and the Application Id present in the request message header. However, some applications may need to rely on the User-Name AVP or any other application-specific AVPs present in the request to determine the final destination of a request, e.g., to find the target AAA server hosting the authorization information for a given user when multiple AAA servers are addressable in the realm.",
      "ja": "このような要求に対して、通常、メッセージルーティングは、宛先レルムAVPと要求メッセージヘッダーのアプリケーションIDの存在に依存しています。ただし、一部のアプリケーションは、ユーザー名AVPまたは要求の最終目的地を決定するための要求に存在する他のアプリケーション固有のAVPに頼る必要があり、例えば、与えられたユーザの認証情報をホストしているターゲットAAAサーバを見つけるために複数のAAAサーバは、レルムにアドレス指定可能であるとき。"
    },
    {
      "indent": 3,
      "text": "In such a context, basic routing mechanisms described in [RFC6733] are not fully suitable, and additional application-level routing mechanisms MUST be described in the application documentation to provide such specific AVP-based routing. Such functionality will be basically hosted by an application-specific proxy agent that will be responsible for routing decisions based on the received specific AVPs.",
      "ja": "そのような状況では、[RFC6733]に記載の基本的なルーティングメカニズムは完全には適していない、および追加のアプリケーション・レベルのルーティングメカニズムは、そのような特定のAVPベースのルーティングを提供するために、アプリケーションのマニュアルに記載されなければなりません。このような機能は、基本的には、受信した特定のAVPに基づいてルーティング決定を担当するアプリケーション固有のプロキシエージェントによってホストされます。"
    },
    {
      "indent": 3,
      "text": "Examples of such application-specific routing functions can be found in the Cx/Dx applications ([TS29.228] and [TS29.229]) of the 3GPP IP Multimedia Subsystem, in which the proxy agent (Subscriber Location Function, aka SLF) uses specific application-level identities found in the request to determine the final destination of the message.",
      "ja": "そのようなアプリケーション固有のルーティング機能の例は、プロキシエージェント（加入者位置機能SLF別名）、3GPP IPマルチメディアサブシステム、のCxの/ Dxのアプリケーション（[TS29.228]と[TS29.229]）に見出すことができますメッセージの最終宛先を決定するために、リクエスト中に見出さ特定のアプリケーション・レベルのIDを使用します。"
    },
    {
      "indent": 3,
      "text": "Whatever the criteria used to establish the routing path of the request, the routing of the answer MUST follow the reverse path of the request, as described in [RFC6733], with the answer being sent to the source of the received request, using transaction states and hop-by-hop identifier matching. This ensures that the Diameter relay or proxy agents in the request routing path will be able to release the transaction state upon receipt of the corresponding answer, avoiding unnecessary failover. Moreover, especially in roaming cases, proxy agents in the path must be able to apply local policies when receiving the answer from the server during authentication/ authorization and/or accounting procedures and maintain up-to-date session state information by keeping track of all authorized active sessions. Therefore, application designers MUST NOT modify the answer-routing principles described in [RFC6733] when defining a new application.",
      "ja": "[RFC6733]に記載されているようにどのような要求のルーティングパスを確立するために使用される基準は、答えのルーティングは、トランザクションの状態を使用して、受信した要求の送信元に送信される回答で、リクエストの逆の経路に従わなければなりませんホップバイホップ識別子マッチング。これは、リクエストルーティング経路の直径リレーまたはプロキシエージェントが不要なフェールオーバーを回避、対応する回答を受信すると、トランザクション状態を解除することができるであろうことを保証します。また、特に例をローミングで、パス内のプロキシエージェントは、認証/認可および/または会計処理中にサーバーからの回答を受信したときにローカルポリシーを適用することができなければならないと、すべてのトラックを保つことによって、最新のセッション状態情報を維持しますアクティブなセッションを承認しました。新しいアプリケーションを定義するときにそのため、アプリケーション設計者は、[RFC6733]で説明した答えルーティング原則を変更してはいけません。"
    },
    {
      "indent": 0,
      "text": "5.8. Translation Agents",
      "section_title": true,
      "ja": "5.8. 翻訳エージェント"
    },
    {
      "indent": 3,
      "text": "As defined in [RFC6733], a translation agent is a device that provides interworking between Diameter and another AAA protocol, such as RADIUS.",
      "ja": "[RFC6733]で定義されるように、翻訳エージェントは、Diameter及びRADIUSなどの別のAAAプロトコル間のインターワーキングを提供するデバイスです。"
    },
    {
      "indent": 3,
      "text": "In the case of RADIUS, it was initially thought that defining the translation function would be straightforward by adopting a few basic principles, e.g., by the use of a shared range of code values for RADIUS attributes and Diameter AVPs. Guidelines for implementing a RADIUS-Diameter translation agent were put into the Diameter NAS Application [RFC4005].",
      "ja": "RADIUSの場合には、最初に翻訳機能を定義するRADIUS属性および直径のAVPのためのコード値の共有範囲を使用することによって、例えば、いくつかの基本的な原理を採用することにより、簡単であろうと考えられました。 RADIUS口径の翻訳エージェントを実装するためのガイドラインは、Diameter NASアプリケーション[RFC4005]に入れました。"
    },
    {
      "indent": 3,
      "text": "However, it was acknowledged that such a translation mechanism was not so obvious and deeper protocol analysis was required to ensure efficient interworking between RADIUS and Diameter. Moreover, the interworking requirements depend on the functionalities provided by the Diameter application under specification, and a case-by-case analysis is required. As a consequence, all the material related to RADIUS-to-Diameter translation is removed from the new version of the Diameter NAS Application specification [RFC7155], which deprecates RFC 4005 [RFC4005].",
      "ja": "しかし、このような変換メカニズムはそれほど明らかではなかったと深いプロトコル解析は、RADIUSと直径との効率的な相互動作を確保するために必要とされたことを認めました。また、インターワーキング要件は仕様下Diameterアプリケーションによって提供される機能に依存し、ケースバイケースの分析が必要です。その結果、RADIUS対直径翻訳に関連するすべての材料は、RFC 4005 [RFC4005]を廃止直径NASアプリケーション仕様の新しいバージョン[RFC7155]から除去されます。"
    },
    {
      "indent": 3,
      "text": "Therefore, protocol designers SHOULD NOT assume the availability of a \"standard\" Diameter-to-RADIUS gateway agent when planning to interoperate with the RADIUS infrastructure. They SHOULD specify the required translation mechanism along with the Diameter application, if needed. This recommendation applies for any kind of translation.",
      "ja": "RADIUSインフラストラクチャと相互運用することを計画したときにそのため、プロトコル設計者は、「標準」直径とRADIUSゲートウェイ・エージェントの利用可能性を仮定するべきではありません。必要に応じて彼らは、Diameterアプリケーションと一緒に必要な変換メカニズムを指定する必要があります。この勧告は、翻訳の任意の種類に適用されます。"
    },
    {
      "indent": 0,
      "text": "5.9. End-to-End Application Capabilities Exchange",
      "section_title": true,
      "ja": "5.9. エンドツーエンドのアプリケーション機能交換"
    },
    {
      "indent": 3,
      "text": "Diameter applications can rely on optional AVPs to exchange application-specific capabilities and features. These AVPs can be exchanged on an end-to-end basis at the application layer. Examples of this can be found with the MIP6-Feature-Vector AVP in [RFC5447] and the QoS-Capability AVP in [RFC5777].",
      "ja": "Diameterアプリケーションは、アプリケーション固有の機能と機能を交換するには、オプションのAVPに頼ることができます。これらのAVPは、アプリケーション層でのエンドツーエンドベースで交換することができます。この例は、[RFC5447]及び[RFC5777]でのQoS能力AVPにMIP6-特徴ベクトルAVPを発見することができます。"
    },
    {
      "indent": 3,
      "text": "End-to-end capabilities AVPs can be added as optional AVPs with the M-bit cleared to existing applications to announce support of new functionality. Receivers that do not understand these AVPs or the AVP values can simply ignore them, as stated in [RFC6733]. When supported, receivers of these AVPs can discover the additional functionality supported by the Diameter endpoint originating the request and behave accordingly when processing the request. Senders of these AVPs can safely assume the receiving endpoint does not support any functionality carried by the AVP if it is not present in the corresponding response. This is useful in cases where deployment choices are offered, and the generic design can be made available for a number of applications.",
      "ja": "エンドツーエンドの機能ののAVPは、新しい機能のサポートを発表する既存のアプリケーションにクリアMビットとオプションのAVPとして追加することができます。 [RFC6733]で述べたように、これらのAVPまたはAVP値を理解していない受信機は、単純に、それらを無視することができます。サポートされている場合、これらのAVPの受信機は、要求元直径エンドポイントによってサポートされる追加機能を発見することができ、要求を処理する際に振る舞います。これらのAVPの送信者は、安全には対応する応答に存在しない場合は受信エンドポイントは、AVPによって運ばれるすべての機能をサポートしていませんと仮定することができます。これは、展開の選択肢が提供されている場合に有用であり、一般的なデザインは、多くの用途に利用できるようにすることができます。"
    },
    {
      "indent": 3,
      "text": "When used in a new application, these end-to-end capabilities AVPs SHOULD be added as an optional AVP into the CCF of the commands used by the new application. Protocol designers SHOULD clearly specify this end-to-end capabilities exchange and the corresponding behavior of the Diameter nodes supporting the application.",
      "ja": "新しいアプリケーションで使用される場合、これらのエンドツーエンドの能力のAVPは、新規アプリケーションによって使用されるコマンドのCCFに任意AVPとして添加されるべきです。プロトコルの設計者は明らかに、このエンドツーエンドの機能交換とアプリケーションをサポートするDiameterノードの対応する動作を指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "It is also important to note that this end-to-end capabilities exchange relying on the use of optional AVPs is not meant as a generic mechanism to support extensibility of Diameter applications with arbitrary functionality. When the added features drastically change the Diameter application or when Diameter agents must be upgraded to support the new features, a new application SHOULD be defined, as recommended in [RFC6733].",
      "ja": "オプションのAVPの使用に依存する。このエンドツーエンドの機能交換を任意の機能を持つDiameterアプリケーションの拡張性をサポートするための汎用的なメカニズムとして意図されていないことに注意することも重要です。追加された機能を大幅Diameterアプリケーションを変更したときの直径剤は新しい機能をサポートするようにアップグレードする必要がある場合や、新しいアプリケーションは、[RFC6733]に推奨されているように、定義されるべきです。"
    },
    {
      "indent": 0,
      "text": "5.10. Diameter Accounting Support",
      "section_title": true,
      "ja": "5.10. 直径会計のサポート"
    },
    {
      "indent": 3,
      "text": "Accounting can be treated as an auxiliary application that is used in support of other applications. In most cases, accounting support is required when defining new applications. This document provides two possible models for using accounting:",
      "ja": "会計は、他のアプリケーションをサポートするために使用される補助アプリケーションとして取り扱うことができます。新しいアプリケーションを定義するときにほとんどの場合、会計のサポートが必要です。この文書では、会計を使用するための2つの可能なモデルを提供します。"
    },
    {
      "indent": 3,
      "text": "Split Accounting Model:",
      "ja": "スプリット会計モデル："
    },
    {
      "indent": 6,
      "text": "In this model, the accounting messages will use the Diameter base accounting Application Id (value of 3). The design implication for this is that the accounting is treated as an independent application, especially for Diameter routing. This means that accounting commands emanating from an application may be routed separately from the rest of the other application messages. This may also imply that the messages end up in a central accounting server. A split accounting model is a good design choice when:",
      "ja": "このモデルでは、アカウンティングメッセージは、アプリケーションID（3の値）を占め直径塩基を使用します。このための設計含意は、会計が特に直径ルーティングのために、独立したアプリケーションとして扱われることです。これは、アプリケーションから発せられる会計コマンドは、他のアプリケーションメッセージの残りの部分とは別に配線することができることを意味します。また、これは、メッセージが中央アカウンティングサーバに終わることを意味し得ます。スプリット会計モデルは、時に優れた設計上の選択であります："
    },
    {
      "indent": 6,
      "text": "* The application itself does not define its own accounting commands.",
      "ja": "*アプリケーション自体は、独自の会計コマンドを定義していません。"
    },
    {
      "indent": 6,
      "text": "* The overall system architecture permits the use of centralized accounting for one or more Diameter applications.",
      "ja": "*全体的なシステム・アーキテクチャは、一つ以上のDiameterアプリケーションのための集中管理会計を使用することが可能になります。"
    },
    {
      "indent": 6,
      "text": "Centralizing accounting may have advantages, but there are also drawbacks. The model assumes that the accounting server can differentiate received accounting messages. Since the received accounting messages can be for any application and/or service, the accounting server MUST have a method to match accounting messages with applications and/or services being accounted for. This may mean defining new AVPs; checking the presence, absence, or contents of existing AVPs; or checking the contents of the accounting record itself. One of these means could be to insert into the request sent to the accounting server an Auth-Application-Id AVP containing the identifier of the application for which the accounting request is sent. But in general, there is no clean and generic scheme for sorting these messages. Therefore, this model SHOULD NOT be used when all received accounting messages cannot be clearly identified and sorted. For most cases, the use of the Coupled Accounting Model is RECOMMENDED.",
      "ja": "集中会計は利点があるかもしれませんが、欠点もあります。モデルは、アカウンティングサーバが受信アカウンティングメッセージを区別できることを前提としています。受信アカウンティングメッセージは、任意のアプリケーションおよび/またはサービスのためにすることができますので、アカウンティングサーバを計上しているアプリケーションおよび/またはサービスとアカウンティングメッセージを一致させる方法を持たなければなりません。これは、新しいAVPを定める意味するかもしれません。既存のAVPの存在、不在、または内容を確認。またはアカウンティングレコード自体の内容を確認。これらの手段の一つは、課金サーバのアカウンティング要求が送信されたアプリケーションの識別子を含む認証、アプリケーションのId AVPに送信された要求に挿入することができました。しかし、一般的に、これらのメッセージをソートするには、清潔で、一般的なスキームがありません。全て受信アカウンティングメッセージを明確に識別し、ソートすることができないときしたがって、このモデルは使うべきではありません。ほとんどの場合、結合会計モデルの使用が推奨されます。"
    },
    {
      "indent": 3,
      "text": "Coupled Accounting Model:",
      "ja": "結合会計モデル："
    },
    {
      "indent": 6,
      "text": "In this model, the accounting messages will use the Application Id of the application using the accounting service. The design implication for this is that the accounting messages are tightly coupled with the application itself, meaning that accounting messages will be routed like the other application messages. It would then be the responsibility of the application server (application entity receiving the ACR message) to send the accounting records carried by the accounting messages to the proper accounting server. The application server is also responsible for formulating a proper response (ACA). A coupled accounting model is a good design choice when:",
      "ja": "このモデルでは、アカウンティングメッセージは、会計上のサービスを使用してアプリケーションのアプリケーションIDを使用します。このため、設計含意はアカウンティングメッセージがしっかりとアカウンティングメッセージを他のアプリケーションメッセージのようにルーティングされることを意味し、アプリケーション自体に結合されていることです。その後、適切なアカウンティングサーバにアカウンティングメッセージによって運ばアカウンティングレコードを送信するために、アプリケーション・サーバー（ACRメッセージを受信するアプリケーションエンティティ）の責任になります。アプリケーションサーバは、適切な応答（ACA）を策定する責任があります。結合会計モデルは、時に優れた設計上の選択であります："
    },
    {
      "indent": 6,
      "text": "* The system architecture or deployment does not provide an accounting server that supports Diameter. Consequently, the application server MUST be provisioned to use a different protocol to access the accounting server, e.g., via the Lightweight Directory Access Protocol (LDAP), SOAP, etc. This case includes the support of older accounting systems that are not Diameter aware.",
      "ja": "*システムアーキテクチャや展開は、Diameterをサポートしているアカウンティングサーバを提供していません。その結果、アプリケーションサーバ等のLDAP（Lightweight Directory Access Protocol）、SOAPを介して、例えば、アカウンティングサーバにアクセスするためのさまざまなプロトコルを使用するようにプロビジョニングされなければならない。この場合は、Diameter認識していない旧式の会計システムのサポートが含まれています。"
    },
    {
      "indent": 6,
      "text": "* The system architecture or deployment requires that the accounting service for the specific application should be handled by the application itself.",
      "ja": "*システムアーキテクチャや展開は、特定のアプリケーションのための会計サービスは、アプリケーション自体によって処理されるべきであることが必要です。"
    },
    {
      "indent": 6,
      "text": "In all cases above, there will generally be no direct Diameter access to the accounting server.",
      "ja": "上記のすべての場合において、一般会計サーバーに直接直径アクセスは存在しません。"
    },
    {
      "indent": 3,
      "text": "These models provide a basis for using accounting messages. Application designers may obviously deviate from these models provided that the factors being addressed here have also been taken into account. As a general recommendation, application designers SHOULD NOT define a new set of commands to carry application-specific accounting records.",
      "ja": "これらのモデルは、アカウンティングメッセージを使用するための基礎を提供します。アプリケーション設計者は、明らかにここで扱われているの要因も考慮されていることを提供し、これらのモデルから逸脱してもよいです。一般的な推奨事項として、アプリケーション設計者は、アプリケーション固有の会計記録を運ぶためにコマンドの新しいセットを定義するべきではありません。"
    },
    {
      "indent": 0,
      "text": "5.11. Diameter Security Mechanisms",
      "section_title": true,
      "ja": "5.11. 直径のセキュリティメカニズム"
    },
    {
      "indent": 3,
      "text": "As specified in [RFC6733], the Diameter message exchange SHOULD be secured between neighboring Diameter peers using Transport Layer Security (TLS) / TCP or Datagram Transport Layer Security (DTLS) / Stream Control Transmission Protocol (SCTP). However, IPsec MAY also be deployed to secure communication between Diameter peers. When IPsec is used instead of TLS or DTLS, the following recommendations apply.",
      "ja": "[RFC6733]で指定されるように、Diameterメッセージ交換は、トランスポート層セキュリティ（TLS）/ TCPまたはデータグラムトランスポート層セキュリティ（DTLS）/ストリーム制御伝送プロトコル（SCTP）を使用して、隣接する直径ピアとの間に固定されるべきです。しかし、IPsecはまた、直径ピア間の通信を確保するために展開されてもよいです。 IPsecは代わりに、TLSまたはDTLSを使用する場合は、以下の推奨事項が適用されます。"
    },
    {
      "indent": 3,
      "text": "IPsec Encapsulating Security Payload (ESP) [RFC4301] in transport mode with non-null encryption and authentication algorithms MUST be used to provide per-packet authentication, integrity protection, and confidentiality and to support the replay protection mechanisms of IPsec. Internet Key Exchange Protocol Version 2 (IKEv2) [RFC7296] SHOULD be used for performing mutual authentication and for establishing and maintaining security associations (SAs).",
      "ja": "IPsecのカプセル化セキュリティペイロード（ESP）null以外の暗号化および認証アルゴリズムとトランスポートモードでは、[RFC4301]はパケットごとの認証、完全性保護、および機密性を提供するとIPsecのリプレイ保護メカニズムをサポートするために使用されなければなりません。インターネット鍵交換プロトコルバージョン2（IKEv2の）[RFC7296]は、相互認証を実行するためのセキュリティアソシエーション（SA）を確立し、維持するために使用されるべきです。"
    },
    {
      "indent": 3,
      "text": "Version 1 of IKE (IKEv1), defined in [RFC2409], was initially used for peer authentication, negotiation of security associations, and key management in RFC 3588 [RFC3588]. For easier migration from the obsoleted implementations based on IKEv1 to IKEv2, both RSA digital signatures and pre-shared keys SHOULD be supported in IKEv2. However, if IKEv1 is used, implementors SHOULD follow the guidelines given in Section 13.1 of RFC 3588 [RFC3588].",
      "ja": "[RFC2409]で定義されたIKE（IKEv1の）のバージョン1は、最初にRFC 3588 [RFC3588]でピア認証、セキュリティアソシエーションのネゴシエーション、およびキー管理のために使用しました。 IKEv2のへのIKEv1に基づいて廃止実装から容易に移動、両方のRSAデジタル署名と事前共有鍵のためのIKEv2でサポートされるべきです。 IKEv1のが使用されている場合は、実装は、RFC 3588 [RFC3588]のセクション13.1で与えられたガイドラインに従ってください。"
    },
    {
      "indent": 0,
      "text": "6. Defining Generic Diameter Extensions",
      "section_title": true,
      "ja": "6.定義一般的な直径拡張"
    },
    {
      "indent": 3,
      "text": "Generic Diameter extensions are AVPs, commands, or applications that are designed to support other Diameter applications. They are auxiliary applications meant to improve or enhance the Diameter protocol itself or Diameter applications/functionality. Some examples include the extensions to support realm-based redirection of Diameter requests (see [RFC7075]), conveying a specific set of priority parameters influencing the distribution of resources (see [RFC6735]), and the support for QoS AVPs (see [RFC5777]).",
      "ja": "一般的な直径の拡張はのAVP、コマンド、または他のDiameterアプリケーションをサポートするように設計されたアプリケーションです。彼らは、Diameterプロトコル自体またはDiameterアプリケーション/機能を向上または増強することを意味補助アプリケーションです。いくつかの例は、リソースの配分に影響を与える優先パラメータの特定のセット（[RFC6735]を参照）、およびQoSのAVPのサポート（参照[RFC5777を搬送する、（[RFC7075]を参照）の直径の要求のレルムベースのリダイレクトをサポートするための拡張機能を含みます]）。"
    },
    {
      "indent": 3,
      "text": "Since generic extensions may cover many aspects of Diameter and Diameter applications, it is not possible to enumerate all scenarios. However, some of the most common considerations are as follows:",
      "ja": "一般的な拡張子は直径及び直径のアプリケーションの多くの側面を覆うことができるので、すべてのシナリオを列挙することはできません。次のようにしかし、最も一般的な考慮事項のいくつかは以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "Backward Compatibility:",
      "ja": "下位互換性："
    },
    {
      "indent": 6,
      "text": "When defining generic extensions designed to be supported by existing Diameter applications, protocol designers MUST consider the potential impacts of the introduction of the new extension on the behavior of the node that would not be yet upgraded to support/understand this new extension. Designers MUST also ensure that new extensions do not break expected message delivery layer behavior.",
      "ja": "既存のDiameterアプリケーションでサポートされるように設計され、一般的な拡張を定義する場合、プロトコル設計者は、まだ理解して/この新しい拡張機能をサポートするようにアップグレードされないノードの行動上の新しい拡張機能の導入の潜在的な影響を考慮しなければなりません。設計者はまた、新しい拡張が期待されるメッセージ配信層の挙動を壊さないようにする必要があります。"
    },
    {
      "indent": 3,
      "text": "Forward Compatibility:",
      "ja": "前方互換性："
    },
    {
      "indent": 6,
      "text": "Protocol designers MUST ensure that their design will not introduce undue restrictions for future applications.",
      "ja": "プロトコルの設計者は、彼らのデザインは、将来のアプリケーションのための不当な制限を導入しないことを保証しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Trade-off in Signaling:",
      "ja": "シグナリングにおけるトレードオフ："
    },
    {
      "indent": 6,
      "text": "Designers may have to choose between the use of optional AVPs piggybacked onto existing commands versus defining new commands and applications. Optional AVPs are simpler to implement and may not need changes to existing applications. However, this ties the sending of extension data to the application's transmission of a message. This has consequences if the application and the extensions have different timing requirements. The use of commands and applications solves this issue, but the trade-off is the additional complexity of defining and deploying a new application. It is left up to the designer to find a good balance among these trade-offs based on the requirements of the extension.",
      "ja": "設計者は、オプションのAVPの使用は、新しいコマンドやアプリケーションを定義に対する既存のコマンドにピギーバックの間で選択する必要があります。オプションのAVPは実装が簡単であり、既存のアプリケーションに変更を必要としない場合があります。しかし、これは、メッセージのアプリケーションの送信に拡張データの送信を結び付けます。アプリケーションや拡張が異なるタイミング要件を持っている場合、これは結果をもたらします。コマンドやアプリケーションの使用は、この問題を解決するが、トレードオフは、新しいアプリケーションを定義し、展開のさらなる複雑です。拡張の要件に基づいて、これらのトレードオフの間の良好なバランスを見つけるために、設計者に任されています。"
    },
    {
      "indent": 3,
      "text": "In practice, generic extensions often use optional AVPs because they are simple and non-intrusive to the application that would carry them. Peers that do not support the generic extensions need not understand nor recognize these optional AVPs. However, it is RECOMMENDED that the authors of the extension specify the context or usage of the optional AVPs. As an example, in the case that the AVP can be used only by a specific set of applications, then the specification MUST enumerate these applications and the scenarios when the optional AVPs will be used. In the case where the optional AVPs can be carried by any application, it should be sufficient to specify such a use case and perhaps provide specific examples of applications using them.",
      "ja": "彼らはそれらを運ぶアプリケーションに簡単かつ非侵入しているので、実際には、一般的な拡張子は、多くの場合、オプションのAVPを使用します。一般的な拡張をサポートしていないピアは理解しても、これらのオプションのAVPを認識する必要はありません。しかし、拡張の作者は、オプションのAVPのコンテキストまたは使用を指定することをお勧めします。任意のAVPが使用される場合、一例として、AVPは、アプリケーションの特定の組によってのみ使用することができた場合には、次に明細書は、これらのアプリケーションおよびシナリオを列挙しなければなりません。任意のAVPは、任意のアプリケーションによって実施することができる場合には、このようなユースケースを指定し、おそらくそれらを使用するアプリケーションの具体例を提供するのに十分であるべきです。"
    },
    {
      "indent": 3,
      "text": "In most cases, these optional AVPs piggybacked by applications would be defined as a Grouped AVP, and it would encapsulate all the functionality of the generic extension. In practice, it is not uncommon that the Grouped AVP will encapsulate an existing AVP that has previously been defined as mandatory ('M'-bit set), e.g., 3GPP IP Multimedia Subsystems (IMS) Cx/Dx interfaces ([TS29.228] and [TS29.229]).",
      "ja": "ほとんどの場合、アプリケーションによって背負わこれらのオプションのAVPは、グループ化されたAVPのように定義されるだろうし、それは一般的な拡張子のすべての機能をカプセル化します。実際には、グループ化AVPは、3GPP IPマルチメディアサブシステム（IMS）Cxの/ Dxのインターフェイス（[TS29.228以前に、例えば、（M'-ビットセット '）必須として定義されている既存のAVPをカプセル化することは珍しいことではありません]と[TS29.229]）。"
    },
    {
      "indent": 0,
      "text": "7. Guidelines for Registrations of Diameter Values",
      "section_title": true,
      "ja": "直径値の登録のための7のガイドライン"
    },
    {
      "indent": 3,
      "text": "As summarized in Section 3 of this document and further described in Section 1.3 of [RFC6733], there are four main ways to extend Diameter. The process for defining new functionality slightly varies based on the different extensions. This section provides protocol designers with some guidance regarding the definition of values for possible Diameter extensions and the necessary interaction with IANA to register the new functionality.",
      "ja": "このドキュメントのセクション3にまとめ、さらに、[RFC6733]のセクション1.3に記載されているように、直径を拡張する4つの主要な方法があります。新しい機能を定義するためのプロセスが若干異なる拡張子に基づいて変化します。このセクションでは、可能な直径の拡張機能や新機能を登録するIANAとの必要な相互作用のための値の定義に関するいくつかの指針とプロトコルの設計者に提供します。"
    },
    {
      "indent": 3,
      "text": "a. Defining New AVP Values",
      "ja": "A。新しいAVP値の定義"
    },
    {
      "indent": 6,
      "text": "The specifications defining AVPs and AVP values MUST provide guidance for defining new values and the corresponding policy for adding these values. For example, RFC 5777 [RFC5777] defines the Treatment-Action AVP, which contains a list of valid values corresponding to predefined actions (drop, shape, mark, permit). This set of values can be extended following the Specification Required policy defined in [RFC5226]. As a second example, the Diameter base specification [RFC6733] defines the Result-Code AVP that contains a 32-bit address space used to identity possible errors. According to Section 11.3.2 of [RFC6733], new values can be assigned by IANA via an IETF Review process [RFC5226].",
      "ja": "AVPおよびAVP値を定義する仕様は、新しい値とこれらの値を追加するための対応するポリシーを定義するためのガイダンスを提供しなければなりません。例えば、RFC 5777 [RFC5777]は予め定義されたアクション（ドロップ、形状、マーク、許可）に対応する有効な値のリストを含む治療アクションAVPを定義します。この値の組は、[RFC5226]で定義された仕様が必要ポリシー以下に拡張することができます。第2の例として、直径基本仕様[RFC6733]は識別可能なエラーに使用される32ビットアドレス空間を含む結果、コードAVPを定義します。 [RFC6733]のセクション11.3.2によると、新しい値がIETFレビュープロセス[RFC5226]を経由してIANAによって割り当てられることができます。"
    },
    {
      "indent": 3,
      "text": "b. Creating New AVPs",
      "ja": "B。新しいAVPを作成します"
    },
    {
      "indent": 6,
      "text": "Two different types of AVP Codes namespaces can be used to create a new AVP:",
      "ja": "AVPコードネームスペース2つの異なるタイプの新しいAVPを作成するために使用することができます。"
    },
    {
      "indent": 6,
      "text": "* IETF AVP Codes namespace.",
      "ja": "* IETF AVPコードネームスペース。"
    },
    {
      "indent": 6,
      "text": "* Vendor-specific AVP Codes namespace.",
      "ja": "*ベンダー固有AVPコードネームスペース。"
    },
    {
      "indent": 6,
      "text": "In the latter case, a vendor needs to be first assigned by IANA with a private enterprise number, which can be used within the Vendor-Id field of the vendor-specific AVP. This enterprise number delimits a private namespace in which the vendor is responsible for vendor-specific AVP code value assignment. The absence of a Vendor Id or a Vendor-Id value of zero (0) in the AVP header identifies standard AVPs from the IETF AVP Codes namespace managed by IANA. The allocation of code values from the IANA-managed namespace is conditioned by an Expert Review of the specification defining the AVPs or an IETF Review if a block of AVPs needs to be assigned. Moreover, the remaining bits of the AVP Flags field of the AVP header are also assigned via Standards Action if the creation of new AVP flags is desired.",
      "ja": "後者の場合には、ベンダーは、第ベンダー固有AVPのベンダーIDフィールド内で使用することができる民間企業番号とIANAによって割り当てられる必要があります。この企業の数は、ベンダーが、ベンダー固有のAVPコード値の割り当てを担当しているプラ​​イベート名前空間を区切ります。ベンダーID、またはゼロのベンダーID値が存在しない（0）AVPヘッダにIANAによって管理IETF AVPコードネームスペースから標準AVPを識別する。 AVPのブロックが割り当てられる必要がある場合IANA管理名前空間からコード値の割り当ては、AVPを定義する仕様のエキスパートレビューまたはIETFレビューによって調整されます。新しいAVPフラグの作成が望まれる場合また、AVPヘッダのAVPフラグフィールドの残りのビットはまた、標準アクションを介して割り当てられています。"
    },
    {
      "indent": 3,
      "text": "c. Creating New Commands",
      "ja": "C。新しいコマンドを作成します"
    },
    {
      "indent": 6,
      "text": "Unlike the AVP Codes namespace, the Command Code namespace is flat, but the range of values is subdivided into three chunks with distinct IANA registration policies:",
      "ja": "AVPコードネームスペースとは異なり、コマンドコードの名前空間は平坦であるが、値の範囲は明確なIANA登録ポリシーに3つのチャンクに分割されています。"
    },
    {
      "indent": 6,
      "text": "* A range of standard Command Code values that are allocated via IETF Review;",
      "ja": "* IETFレビューを経由して割り当てられている標準のコマンドコード値の範囲。"
    },
    {
      "indent": 6,
      "text": "* A range of vendor-specific Command Code values that are allocated on a first-come, first-served basis; and",
      "ja": "*先着順に割り当てられているベンダー固有のコマンドコード値の範囲。そして"
    },
    {
      "indent": 6,
      "text": "* A range of values reserved only for experimental and testing purposes.",
      "ja": "*のみの実験およびテストの目的のために予約された値の範囲。"
    },
    {
      "indent": 6,
      "text": "As for AVP flags, the remaining bits of the Command Flags field of the Diameter header are also assigned via a Standards Action to create new Command flags if required.",
      "ja": "AVPフラグのように、直径ヘッダのコマンドフラグフィールドの残りのビットはまた、必要に応じて新しいコマンドフラグを作成するために、標準化作用を介して割り当てられています。"
    },
    {
      "indent": 3,
      "text": "d. Creating New Applications",
      "ja": "D。新しいアプリケーションの作成"
    },
    {
      "indent": 6,
      "text": "Similarly, to the Command Code namespace, the Application-Id namespace is flat but divided into two distinct ranges:",
      "ja": "同様に、コマンドコードネームスペースに、アプリケーション-ID名前空間は平坦であるが、2つの異なる範囲に分割します："
    },
    {
      "indent": 6,
      "text": "* A range of values reserved for standard Application Ids, allocated after Expert Review of the specification defining the standard application.",
      "ja": "*標準のアプリケーションを定義する仕様のエキスパートレビューした後に割り当てられた標準的なアプリケーションIDのために予約される値の範囲、。"
    },
    {
      "indent": 6,
      "text": "* A range for values for vendor-specific applications, allocated by IANA on a first-come, first-served basis.",
      "ja": "*先着順でIANAによって割り当てられたベンダー固有の用途のための値の範囲は、。"
    },
    {
      "indent": 3,
      "text": "The IANA AAA parameters page can be found at <http://www.iana.org/assignments/aaa-parameters>, and the enterprise number IANA page is available at <http://www.iana.org/assignments/ enterprise-numbers>. More details on the policies followed by IANA for namespace management (e.g., first-come, first-served; Expert Review; IETF Review; etc.) can be found in [RFC5226].",
      "ja": "IANA AAAパラメータページが<http://www.iana.org/assignments/aaa-parameters>で見つけることができ、およびエンタープライズ番号IANAページが<http://www.iana.org/assignments/企業で利用可能です> -numbers。名前空間の管理のためにIANAに続く政策に関する詳細（例えば、先着順;エキスパートレビュー、IETFレビュー;など）は、[RFC5226]で見つけることができます。"
    },
    {
      "indent": 6,
      "text": "NOTE: When the same functionality/extension is used by more than one vendor, it is RECOMMENDED that a standard extension be defined. Moreover, a vendor-specific extension SHOULD be registered to avoid interoperability issues in the same network. With this aim, the registration policy of a vendor-specific extension has been simplified with the publication of [RFC6733], and the namespace reserved for vendor-specific extensions is large enough to avoid exhaustion.",
      "ja": "注：同じ機能/拡張機能は、複数のベンダーによって使用される場合、それは標準の拡張子を定義することをお勧めします。また、ベンダー固有の拡張子は同じネットワークで相互運用性の問題を回避するために登録する必要があります。この目的で、ベンダー固有の拡張の登録ポリシーは、[RFC6733]の出版で簡素化されていて、ベンダー固有の拡張のために予約の名前空間は枯渇を回避するのに十分な大きさです。"
    },
    {
      "indent": 0,
      "text": "8. Security Considerations",
      "section_title": true,
      "ja": "8.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document provides guidelines and considerations for extending Diameter and Diameter applications. Although such an extension may be related to a security functionality, the document does not explicitly give additional guidance on enhancing Diameter with respect to security. However, as a general guideline, it is recommended that any Diameter extension SHOULD NOT break the security concept given in [RFC6733]. In particular, it is reiterated here that any command defined or reused in a new Diameter application SHOULD be secured by using TLS [RFC5246] or DTLS/SCTP [RFC6083] and MUST NOT be used without one of the following: TLS, DTLS, or IPsec [RFC4301]. When defining a new Diameter extension, any possible impact of the existing security principles described in [RFC6733] MUST be carefully appraised and documented in the Diameter application specification.",
      "ja": "この文書では、直径と直径のアプリケーションを拡張するためのガイドラインと考慮事項を提供します。そのような拡張は、セキュリティ機能に関連している可能性がありますが、文書は、明示的なセキュリティに対する直径の向上に関する追加の指針を与えるものではありません。しかし、一般的なガイドラインとして、任意の直径の拡張子は[RFC6733]で与えられたセキュリティ概念を壊すべきではないことをお勧めします。特に、[RFC5246]新しいDiameterアプリケーションで定義された、または再利用任意のコマンドがTLSを使用して保護されるべきであることをここで繰り返されるか、またはDTLS / SCTP [RFC6083]と、次のいずれかせずに使用してはいけません：TLS、DTLS、又はIPsecの[RFC4301]。新しい直径拡張を定義する場合、[RFC6733]に記載の既存のセキュリティ原則の任意の可能な影響を慎重に評価さとDIAMETERアプリケーション仕様に文書化されなければなりません。"
    },
    {
      "indent": 0,
      "text": "9. References",
      "section_title": true,
      "ja": "9.参考文献"
    },
    {
      "indent": 0,
      "text": "9.1. Normative References",
      "section_title": true,
      "ja": "9.1. 引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月、<http://www.rfc-editor.org/info/rfc2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC6733] Fajardo, V., Arkko, J., Loughney, J., and G. Zorn, \"Diameter Base Protocol\", RFC 6733, October 2012, <http://www.rfc-editor.org/info/rfc6733>.",
      "ja": "[RFC6733]ファハルド、V.、Arkko、J.、Loughney、J.、およびG.ゾルン、 \"直径ベースプロトコル\"、RFC 6733、2012年10月、<http://www.rfc-editor.org/info/ rfc6733>。"
    },
    {
      "indent": 0,
      "text": "9.2. Informative References",
      "section_title": true,
      "ja": "9.2. 参考文献"
    },
    {
      "indent": 3,
      "text": "[Q.3303.3] International Telecommunications Union, \"Resource control protocol No. 3: Protocols at the Rw interface between the policy decision physical entity (PD-PE) and a policy enforcement physical entity (PE-PE): Diameter profile version 3\", ITU-T Recommendation Q.3303.3, August 2008.",
      "ja": "[Q.3303.3]国際電気通信連合、「リソース制御プロトコル番号3：直径プロファイルバージョン3：ポリシー決定物理的なエンティティ（PD-PE）およびポリシー施行物理エンティティ（PE-PE）の間Rwの界面におけるプロトコル」 、ITU-T勧告Q.3303.3、2008年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC2409] Harkins, D. and D. Carrel, \"The Internet Key Exchange (IKE)\", RFC 2409, November 1998, <http://xml.resource.org/public/rfc/info/rfc2409>.",
      "ja": "[RFC2409]ハーキンとD.とD.カレル、 \"インターネットキー交換（IKE）\"、RFC 2409、1998年11月、<http://xml.resource.org/public/rfc/info/rfc2409>。"
    },
    {
      "indent": 3,
      "text": "[RFC3588] Calhoun, P., Loughney, J., Guttman, E., Zorn, G., and J. Arkko, \"Diameter Base Protocol\", RFC 3588, September 2003, <http://www.rfc-editor.org/info/rfc3588>.",
      "ja": "[RFC3588]カルフーン、P.、Loughney、J.、ガットマン、E.、ゾルン、G.、およびJ. Arkko、 \"直径ベースプロトコル\"、RFC 3588、2003年9月、<HTTP：//www.rfc-editor .ORG /情報/ RFC3588>。"
    },
    {
      "indent": 3,
      "text": "[RFC4005] Calhoun, P., Zorn, G., Spence, D., and D. Mitton, \"Diameter Network Access Server Application\", RFC 4005, August 2005, <http://www.rfc-editor.org/info/rfc4005>.",
      "ja": "[RFC4005]カルフーン、P.、ツォルン、G.、スペンス、D.、およびD.ミトン、 \"直径ネットワークアクセスサーバーアプリケーション\"、RFC 4005、2005年8月、<http://www.rfc-editor.org/情報/ rfc4005>。"
    },
    {
      "indent": 3,
      "text": "[RFC4072] Eronen, P., Hiller, T., and G. Zorn, \"Diameter Extensible Authentication Protocol (EAP) Application\", RFC 4072, August 2005, <http://www.rfc-editor.org/info/rfc4072>.",
      "ja": "[RFC4072] Eronen、P.、ヒラー、T.、およびG.ゾルン、 \"直径拡張認証プロトコル（EAP）アプリケーション\"、RFC 4072、2005年8月、<http://www.rfc-editor.org/info/ rfc4072>。"
    },
    {
      "indent": 3,
      "text": "[RFC4301] Kent, S. and K. Seo, \"Security Architecture for the Internet Protocol\", RFC 4301, December 2005, <http://www.rfc-editor.org/info/rfc4301>.",
      "ja": "[RFC4301]ケント、S.とK. Seo、 \"インターネットプロトコルのためのセキュリティアーキテクチャ\"、RFC 4301、2005年12月、<http://www.rfc-editor.org/info/rfc4301>。"
    },
    {
      "indent": 3,
      "text": "[RFC4740] Garcia-Martin, M., Belinchon, M., Pallares-Lopez, M., Canales-Valenzuela, C., and K. Tammi, \"Diameter Session Initiation Protocol (SIP) Application\", RFC 4740, November 2006, <http://www.rfc-editor.org/info/rfc4740>.",
      "ja": "[RFC4740]ガルシア - マーチン、M.、Belinchon、M.、Pallares  - ロペス、M.、カナーレス-ヴァレンズエラ、C.、およびK. Tammi、 \"直径セッション開始プロトコル（SIP）アプリケーション\"、RFC 4740、2006年11月、<http://www.rfc-editor.org/info/rfc4740>。"
    },
    {
      "indent": 3,
      "text": "[RFC5226] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 5226, May 2008, <http://www.rfc-editor.org/info/rfc5226>.",
      "ja": "[RFC5226] Narten氏、T.とH. Alvestrand、 \"RFCsにIANA問題部に書くためのガイドライン\"、BCP 26、RFC 5226、2008年5月、<http://www.rfc-editor.org/info/rfc5226> 。"
    },
    {
      "indent": 3,
      "text": "[RFC5246] Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS) Protocol Version 1.2\", RFC 5246, August 2008, <http://www.rfc-editor.org/info/rfc5246>.",
      "ja": "[RFC5246]ダークス、T.およびE.レスコラ、 \"トランスポート層セキュリティ（TLS）プロトコルバージョン1.2\"、RFC 5246、2008年8月、<http://www.rfc-editor.org/info/rfc5246>。"
    },
    {
      "indent": 3,
      "text": "[RFC5447] Korhonen, J., Bournelle, J., Tschofenig, H., Perkins, C., and K. Chowdhury, \"Diameter Mobile IPv6: Support for Network Access Server to Diameter Server Interaction\", RFC 5447, February 2009, <http://www.rfc-editor.org/info/rfc5447>.",
      "ja": "[RFC5447] Korhonen、J.、Bournelle、J.、Tschofenig、H.、パーキンス、C.、およびK.チョードリ、 \"直径モバイルIPv6：直径サーバの対話へのネットワークアクセスサーバのサポート\"、RFC 5447、2009年2月、 <http://www.rfc-editor.org/info/rfc5447>。"
    },
    {
      "indent": 3,
      "text": "[RFC5777] Korhonen, J., Tschofenig, H., Arumaithurai, M., Jones, M., and A. Lior, \"Traffic Classification and Quality of Service (QoS) Attributes for Diameter\", RFC 5777, February 2010, <http://www.rfc-editor.org/info/rfc5777>.",
      "ja": "[RFC5777] Korhonen、J.、Tschofenig、H.、Arumaithurai、M.、ジョーンズ、M.、およびA. LIOR、 \"サービスのトラフィック分類および品質（QoS）の直径の属性\"、RFC 5777、2010年2月、< http://www.rfc-editor.org/info/rfc5777>。"
    },
    {
      "indent": 3,
      "text": "[RFC6083] Tuexen, M., Seggelmann, R., and E. Rescorla, \"Datagram Transport Layer Security (DTLS) for Stream Control Transmission Protocol (SCTP)\", RFC 6083, January 2011, <http://www.rfc-editor.org/info/rfc6083>.",
      "ja": "[RFC6083] Tuexen、M.、Seggelmann、R.、およびE.レスコラ、 \"ストリーム制御伝送プロトコル（SCTP）のためのデータグラムトランスポート層セキュリティ（DTLS）\"、RFC 6083、2011年1月、<のhttp：//www.rfc -editor.org/info/rfc6083>。"
    },
    {
      "indent": 3,
      "text": "[RFC6735] Carlberg, K. and T. Taylor, \"Diameter Priority Attribute-Value Pairs\", RFC 6735, October 2012, <http://www.rfc-editor.org/info/rfc6735>.",
      "ja": "[RFC6735]カールバーグ氏、K.およびT.テイラー、 \"直径プライオリティアトリビュートと値のペア\"、RFC 6735、2012年10月、<http://www.rfc-editor.org/info/rfc6735>。"
    },
    {
      "indent": 3,
      "text": "[RFC7075] Tsou, T., Hao, R., and T. Taylor, \"Realm-Based Redirection In Diameter\", RFC 7075, November 2013, <http://www.rfc-editor.org/info/rfc7075>.",
      "ja": "[RFC7075]ツオウ、T.、ハオ、R.、およびT.テイラー、 \"直径レルムベースのリダイレクション\"、RFC 7075、2013年11月、<http://www.rfc-editor.org/info/rfc7075> 。"
    },
    {
      "indent": 3,
      "text": "[RFC7155] Zorn, G., \"Diameter Network Access Server Application\", RFC 7155, April 2014, <http://www.rfc-editor.org/info/rfc7155>.",
      "ja": "[RFC7155]ソーン、G.、 \"直径ネットワークアクセスサーバーアプリケーション\"、RFC 7155、2014年4月、<http://www.rfc-editor.org/info/rfc7155>。"
    },
    {
      "indent": 3,
      "text": "[RFC7296] Kaufman, C., Hoffman, P., Nir, Y., Eronen, P., and T. Kivinen, \"Internet Key Exchange Protocol Version 2 (IKEv2)\", STD 79, RFC 7296, October 2014, <http://www.rfc-editor.org/info/rfc7296>.",
      "ja": "[RFC7296]カウフマン、C.、ホフマン、P.、ニール、Y.、Eronen、P.、およびT. Kivinen、 \"インターネット鍵交換プロトコルバージョン2（IKEv2の）\"、STD 79、RFC 7296、2014年10月、< http://www.rfc-editor.org/info/rfc7296>。"
    },
    {
      "indent": 3,
      "text": "[TS29.228] 3rd Generation Partnership Project, \"Technical Specification Group Core Network and Terminals; IP Multimedia (IM) Subsystem Cx and Dx Interfaces; Signalling flows and message contents\", 3GPP TS 29.228, September 2014, <http://www.3gpp.org/ftp/Specs/html-info/29228.htm>.",
      "ja": "[TS29.228]第3世代パートナーシッププロジェクト、 \"技術仕様グループコアネットワークと端末、IPマルチメディア（IM）サブシステムCxとし、Dxのインタフェース;シグナリングフローとメッセージの内容\"、3GPP TS 29.228、2014年9月、<のhttp：// WWW .3gpp.org / FTP /仕様/ HTML-情報/ 29228.htm>。"
    },
    {
      "indent": 3,
      "text": "[TS29.229] 3rd Generation Partnership Project, \"Technical Specification Group Core Network and Terminals; Cx and Dx interfaces based on the Diameter protocol; Protocol details\", 3GPP TS 29.229, September 2014, <http://www.3gpp.org/ftp/Specs/html-info/29229.htm>.",
      "ja": "[TS29.229]第3世代パートナーシッププロジェクト、「技術仕様グループコアネットワークと端末; Diameterプロトコルに基づくCxのとDxとのインタフェース、プロトコルの詳細」、3GPP TS 29.229、2014年9月、<http://www.3gpp.org /ftp/Specs/html-info/29229.htm>。"
    },
    {
      "indent": 3,
      "text": "[TS29.328] 3rd Generation Partnership Project, \"Technical Specification Group Core Network and Terminals; IP Multimedia (IM) Subsystem Sh interface; Signalling flows and message contents\", 3GPP TS 29.328, September 2014, <http://www.3gpp.org/ftp/Specs/html-info/29328.htm>.",
      "ja": "[TS29.328]第3世代パートナーシッププロジェクト、 \"技術仕様グループコアネットワークと端末、IPマルチメディア（IM）サブシステムShインタフェース;シグナリングフローやメッセージの内容\"、3GPP TS 29.328、2014年9月、<のhttp：//www.3gpp .ORG / FTP /仕様/ HTML-情報/ 29328.htm>。"
    },
    {
      "indent": 3,
      "text": "[TS29.329] 3rd Generation Partnership Project, \"Technical Specification Group Core Network and Terminals; Sh Interface based on the Diameter protocol; Protocol details\", 3GPP TS 29.329, September 2014, <http://www.3gpp.org/ftp/Specs/html-info/29329.htm>.",
      "ja": "[TS29.329]第3世代パートナーシッププロジェクト、「技術仕様グループコアネットワークと端末; ShインタフェースDiameterプロトコルに基づいて、プロトコルの詳細」、3GPP TS 29.329、2014年9月、<http://www.3gpp.org/ftp /Specs/html-info/29329.htm>。"
    },
    {
      "indent": 0,
      "text": "Contributors",
      "ja": "協力者"
    },
    {
      "indent": 3,
      "text": "The content of this document was influenced by a design team created to revisit the Diameter extensibility rules. The team was formed in February 2008 and finished its work in June 2008. In addition to those individuals listed in the Authors' Addresses section, the design team members were:",
      "ja": "このドキュメントの内容は、直径の拡張ルールを再検討するために作成された設計チームによって影響を受けました。チームは2008年2月に形成され、著者のアドレス]セクションに記載されているそれらの個人に加えて、2008年6月にその仕事を終えた、設計チームのメンバーは以下の通りでした。"
    },
    {
      "indent": 3,
      "text": "o Avi Lior",
      "ja": "ああアビLIOR"
    },
    {
      "indent": 3,
      "text": "o Glen Zorn",
      "ja": "グレンツォルンO"
    },
    {
      "indent": 3,
      "text": "o Jari Arkko",
      "ja": "OヤリArkko"
    },
    {
      "indent": 3,
      "text": "o Jouni Korhonen",
      "ja": "いいえJouni Korhonenありません"
    },
    {
      "indent": 3,
      "text": "o Mark Jones",
      "ja": "Oマーク・ジョーンズ"
    },
    {
      "indent": 3,
      "text": "o Tolga Asveren",
      "ja": "お とｌが あｓゔぇれん"
    },
    {
      "indent": 3,
      "text": "o Glenn McGregor",
      "ja": "グレン・マクレガーO"
    },
    {
      "indent": 3,
      "text": "o Dave Frascone",
      "ja": "デイブFrascone O"
    },
    {
      "indent": 3,
      "text": "We would like to thank Tolga Asveren, Glenn McGregor, and John Loughney for their contributions as coauthors to earlier versions of this document.",
      "ja": "私たちは、この文書の以前のバージョンに共著者としての貢献のためにトルガAsveren、グレン・マクレガー、ジョンLoughneyに感謝したいと思います。"
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "We greatly appreciate the insight provided by Diameter implementors who have highlighted the issues and concerns being addressed by this document. The authors would also like to thank Jean Mahoney, Ben Campbell, Sebastien Decugis, and Benoit Claise for their invaluable, detailed reviews and comments on this document.",
      "ja": "我々は非常にこの文書によって対処されている問題や懸念を強調している直径の実装が提供する洞察力に感謝します。著者らはまた、このドキュメントの彼らの貴重な、詳細なレビューやコメントのためにジャン・マホーニー、ベン・キャンベル、セバスチャンDecugis、およびブノワClaiseに感謝したいと思います。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Lionel Morand (editor) Orange Labs 38/40 rue du General Leclerc Issy-Les-Moulineaux Cedex 9 92794 France",
      "ja": "ライオネル・モラン（エディタ）オレンジ研究所38/40 RUEデュ一般ルクレールイシレムリノーセデックス9、フランス92794"
    },
    {
      "indent": 3,
      "text": "Phone: +33145296257 EMail: lionel.morand@orange.com",
      "ja": "電話番号：+33145296257 Eメール：lionel.morand@orange.com"
    },
    {
      "indent": 3,
      "text": "Victor Fajardo Fluke Networks",
      "ja": "ビクターファハルドフルーク・ネットワークス"
    },
    {
      "indent": 3,
      "text": "EMail: vf0213@gmail.com",
      "ja": "メールアドレス：vf0213@gmail.com"
    },
    {
      "indent": 3,
      "text": "Hannes Tschofenig Hall in Tirol 6060 Austria",
      "ja": "チロル6060オーストリアのハンネス・Tschofenigホール"
    },
    {
      "indent": 3,
      "text": "EMail: Hannes.Tschofenig@gmx.net URI: http://www.tschofenig.priv.at",
      "ja": "電子メール：Hannes.Tschofenig@gmx.net URI：http://www.tschofenig.priv.at"
    }
  ]
}