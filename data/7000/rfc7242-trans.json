{
  "title": {
    "text": "RFC 7242 - Delay-Tolerant Networking TCP Convergence-Layer Protocol",
    "ja": "RFC 7242 - 遅延耐性ネットワークTCPコンバージェンス層プロトコル"
  },
  "number": 7242,
  "created_at": "2019-10-30 15:37:53.868274+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Research Task Force (IRTF)                            M. Demmer\nRequest for Comments: 7242                                   UC Berkeley\nCategory: Experimental                                            J. Ott\nISSN: 2070-1721                                         Aalto University\n                                                            S. Perreault",
      "raw": true
    },
    {
      "indent": 63,
      "text": "June 2014",
      "raw": true
    },
    {
      "indent": 8,
      "text": "Delay-Tolerant Networking TCP Convergence-Layer Protocol",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document describes the protocol for the TCP-based convergence layer for Delay-Tolerant Networking (DTN). It is the product of the IRTF's DTN Research Group (DTNRG).",
      "ja": "この文書では、遅延耐性ネットワーク（DTN）のためのTCPベースのコンバージェンス層のプロトコルを記述しています。それはIRTFのDTN研究グループ（DTNRG）の製品です。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for examination, experimental implementation, and evaluation.",
      "ja": "このドキュメントはインターネット標準化過程仕様ではありません。それは、検査、実験的な実装、および評価のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document defines an Experimental Protocol for the Internet community. This document is a product of the Internet Research Task Force (IRTF). The IRTF publishes the results of Internet-related research and development activities. These results might not be suitable for deployment. This RFC represents the consensus of the Delay-Tolerant Networking Research Group of the Internet Research Task Force (IRTF). Documents approved for publication by the IRSG are not a candidate for any level of Internet Standard; see Section 2 of RFC 5741.",
      "ja": "この文書は、インターネットコミュニティのためにExperimentalプロトコルを定義します。この文書はインターネットResearch Task Force（IRTF）の製品です。 IRTFはインターネット関連の研究開発活動の成果を公表しています。これらの結果は、展開に適していない可能性があります。このRFCはインターネットリサーチタスクフォースの遅延耐性ネットワーク研究グループ（IRTF）のコンセンサスを表しています。 IRSGによって公表のために承認されたドキュメントは、インターネット標準の任意のレベルの候補ではありません。 RFC 5741のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7242.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7242で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2014 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2014 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................2\n2. Definitions .....................................................4\n   2.1. Definitions Specific to the TCPCL Protocol .................4\n3. General Protocol Description ....................................5\n   3.1. Bidirectional Use of TCP Connection ........................6\n   3.2. Example Message Exchange ...................................6\n4. Connection Establishment ........................................7\n   4.1. Contact Header .............................................8\n   4.2. Validation and Parameter Negotiation ......................10\n5. Established Connection Operation ...............................11\n   5.1. Message Type Codes ........................................11\n   5.2. Bundle Data Transmission (DATA_SEGMENT) ...................12\n   5.3. Bundle Acknowledgments (ACK_SEGMENT) ......................13\n   5.4. Bundle Refusal (REFUSE_BUNDLE) ............................14\n   5.5. Bundle Length (LENGTH) ....................................15\n   5.6. KEEPALIVE Feature (KEEPALIVE) .............................16\n6. Connection Termination .........................................17\n   6.1. Shutdown Message (SHUTDOWN) ...............................17\n   6.2. Idle Connection Shutdown ..................................18\n7. Security Considerations ........................................19\n8. IANA Considerations ............................................20\n   8.1. Port Number ...............................................20\n   8.2. Protocol Versions .........................................20\n   8.3. Message Types .............................................20\n   8.4. REFUSE_BUNDLE Reason Codes ................................21\n   8.5. SHUTDOWN Reason Codes .....................................21\n9. Acknowledgments ................................................21\n10. References ....................................................21\n   10.1. Normative References .....................................21\n   10.2. Informative References ...................................21",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "This document describes the TCP-based convergence-layer protocol for Delay-Tolerant Networking. Delay-Tolerant Networking is an end-to-end architecture providing communications in and/or through highly stressed environments, including those with intermittent connectivity, long and/or variable delays, and high bit error rates. More detailed descriptions of the rationale and capabilities of these networks can be found in \"Delay-Tolerant Network Architecture\" [RFC4838].",
      "ja": "この文書では、遅延耐性ネットワークのためのTCPベースのコンバージェンス層プロトコルを記述します。遅延耐性ネットワークの中におよび/または断続的な接続、長いおよび/または可変遅延、高いビット誤り率を有するものを含む高応力環境を介して通信を提供するエンドツーエンドのアーキテクチャです。根拠とこれらのネットワークの能力のより詳細な説明は、「ディレイトレラントネットワークアーキテクチャ」[RFC4838]で見つけることができます。"
    },
    {
      "indent": 3,
      "text": "An important goal of the DTN architecture is to accommodate a wide range of networking technologies and environments. The protocol used for DTN communications is the Bundle Protocol (BP) [RFC5050], an application-layer protocol that is used to construct a store-and- forward overlay network. As described in the Bundle Protocol specification [RFC5050], it requires the services of a \"convergence-layer adapter\" (CLA) to send and receive bundles using the service of some \"native\" link, network, or Internet protocol. This document describes one such convergence-layer adapter that uses the well-known Transmission Control Protocol (TCP). This convergence layer is referred to as TCPCL.",
      "ja": "DTNアーキテクチャの重要な目標は、ネットワーク技術と幅広い環境に対応するためにあります。 DTNの通信に使用されるプロトコルは、バンドルプロトコル（BP）[RFC5050]、ストア・アンド・フォワードオーバレイネットワークを構築するために使用されるアプリケーション層プロトコルです。バンドルプロトコル仕様[RFC5050]に記載されているように、それはいくつかの「天然」リンク、ネットワーク、またはインターネットプロトコルのサービスを使用してバンドルを送受信するために、「収束層アダプタ」（CLA）のサービスを必要とします。この文書では、よく知られた伝送制御プロトコル（TCP）を使用してそのような収束層アダプタについて説明します。この収束層はTCPCLと呼ばれています。"
    },
    {
      "indent": 3,
      "text": "The locations of the TCPCL and the BP in the Internet model protocol stack are shown in Figure 1. In particular, when BP is using TCP as its bearer with TCPCL as its convergence layer, both BP and TCPCL reside at the application layer of the Internet model.",
      "ja": "TCPCLとインターネットモデル・プロトコル・スタックにおけるBPの位置は、特に図1に示されているが、BPはその収束層としてTCPCLとのベアラとしてTCPを使用している場合、BP及びTCPCL両方は、インターネットのアプリケーション層に常駐します型。"
    },
    {
      "indent": 6,
      "text": "+-------------------------+\n|     DTN Application     | -\\\n+-------------------------|   |\n|  Bundle Protocol (BP)   |   -> Application Layer\n+-------------------------+   |\n| TCP Conv. Layer (TCPCL) | -/\n+-------------------------+\n|          TCP            | ---> Transport Layer\n+-------------------------+\n|           IP            | ---> Network Layer\n+-------------------------+\n|   Link-Layer Protocol   | ---> Link Layer\n+-------------------------+\n|    Physical Medium      | ---> Physical Layer\n+-------------------------+",
      "raw": true
    },
    {
      "indent": 8,
      "text": "Figure 1: The Locations of the Bundle Protocol and the TCP Convergence-Layer Protocol in the Internet Protocol Stack",
      "ja": "図1：バンドル議定書の場所とインターネットプロトコルスタックにおけるTCPコンバージェンス層プロトコル"
    },
    {
      "indent": 3,
      "text": "This document describes the format of the protocol data units passed between entities participating in TCPCL communications. This document does not address:",
      "ja": "この文書では、TCPCL通信に参加するエンティティ間で渡されたプロトコルデータユニットのフォーマットを記述する。この文書は対応していません。"
    },
    {
      "indent": 3,
      "text": "o The format of protocol data units of the Bundle Protocol, as those are defined elsewhere [RFC5050].",
      "ja": "[RFC5050]のものが他の場所で定義されたとおりである、バンドルプロトコルのプロトコルデータユニットのフォーマットO。"
    },
    {
      "indent": 3,
      "text": "o Mechanisms for locating or identifying other bundle nodes within an internet.",
      "ja": "インターネット内の他のバンドルノードを位置決めまたは同定するためのメカニズムO。"
    },
    {
      "indent": 3,
      "text": "Note that this document describes version 3 of the protocol. Versions 0, 1, and 2 were never specified in an Internet-Draft, RFC, or any other public document. These prior versions of the protocol were, however, implemented in the DTN reference implementation [DTNIMPL] in prior releases; hence, the current version number reflects the existence of those prior versions.",
      "ja": "この文書はプロトコルのバージョン3を説明することに注意してください。バージョン0、1、および2は、インターネットドラフト、RFC、またはその他の公共の文書で指定されませんでした。プロトコルのこれらの以前のバージョンは、しかし、以前のリリースでDTNリファレンス実装[DTNIMPL]に実装しました。したがって、現在のバージョン番号は、これらの以前のバージョンの存在を反映しています。"
    },
    {
      "indent": 3,
      "text": "This is an experimental protocol produced within the IRTF's Delay-Tolerant Networking Research Group (DTNRG). It represents the consensus of all active contributors to this group. If this protocol is used on the Internet, IETF standard protocols for security and congestion control should be used.",
      "ja": "これはIRTFの遅延耐性ネットワーク研究グループ（DTNRG）内で生成実験プロトコルです。これは、このグループのすべてのアクティブな貢献者のコンセンサスを表しています。このプロトコルは、インターネット上で使用されている場合は、セキュリティおよび輻輳制御のためのIETF標準プロトコルを使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "2. Definitions",
      "section_title": true,
      "ja": "2.定義"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はあります[RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 3,
      "text": "The terms defined in Section 3.1 of [RFC5050] are used extensively in this document.",
      "ja": "[RFC5050]のセクション3.1で定義された用語は、本書で広く使用されています。"
    },
    {
      "indent": 0,
      "text": "2.1. Definitions Specific to the TCPCL Protocol",
      "section_title": true,
      "ja": "2.1。 TCPCLプロトコルに固有の定義"
    },
    {
      "indent": 3,
      "text": "This section contains definitions that are interpreted to be specific to the operation of the TCPCL protocol, as described below.",
      "ja": "このセクションでは、以下に説明するように、TCPCLプロトコルの動作に特異的であると解釈される定義を含みます。"
    },
    {
      "indent": 3,
      "text": "TCP Connection -- A TCP connection refers to a transport connection using TCP as the transport protocol.",
      "ja": "TCP接続 -  TCP接続はトランスポートプロトコルとしてTCPを使用して、トランスポート接続を指します。"
    },
    {
      "indent": 3,
      "text": "TCPCL Connection -- A TCPCL connection (as opposed to a TCP connection) is a TCPCL communication relationship between two bundle nodes. The lifetime of a TCPCL connection is bound to the lifetime of an underlying TCP connection. Therefore, a TCPCL connection is initiated when a bundle node initiates a TCP connection to be established for the purposes of bundle communication. A TCPCL connection is terminated when the TCP connection ends, due either to one or both nodes actively terminating the TCP connection or due to network errors causing a failure of the TCP connection. For the remainder of this document, the term \"connection\" without the prefix \"TCPCL\" shall refer to a TCPCL connection.",
      "ja": "TCPCL接続 - （TCPコネクションとは対照的に）TCPCL接続は、2つの束のノード間TCPCL通信関係です。 TCPCL接続の寿命は基本的なTCPコネクションの寿命にバインドされています。バンドルノードがバンドル通信のために確立されるTCP接続を開始するときしたがって、TCPCL接続が開始されます。 TCPCL接続は、一方又は積極TCP接続を終了両方のノードまたはによるTCP接続の失敗を引き起こすネットワークエラーに起因し、TCP接続が終了したときに終了します。このドキュメントの残りの部分については、接頭辞「TCPCL」のない「接続」とはTCPCL接続を指すものとします。"
    },
    {
      "indent": 3,
      "text": "Connection parameters -- The connection parameters are a set of values used to affect the operation of the TCPCL for a given connection. The manner in which these parameters are conveyed to the bundle node and thereby to the TCPCL is implementation dependent. However, the mechanism by which two bundle nodes exchange and negotiate the values to be used for a given session is described in Section 4.2.",
      "ja": "接続パラメータ - 接続パラメータは、所与の接続のためのTCPCLの動作に影響を与えるために使用される値のセットです。これらのパラメータは、バンドル・ノードに搬送し、それによってTCPCLにされる方法は実装依存です。しかし、2つのバンドルは交換ノードと所与のセッションは、セクション4.2に記載されているために使用される値を交渉するメカニズム。"
    },
    {
      "indent": 3,
      "text": "Transmission -- Transmission refers to the procedures and mechanisms (described below) for conveyance of a bundle from one node to another.",
      "ja": "送信 - 送信は、別のノードから束搬送するための手順およびメカニズム（後述）を指します。"
    },
    {
      "indent": 0,
      "text": "3. General Protocol Description",
      "section_title": true,
      "ja": "3.一般的なプロトコル説明"
    },
    {
      "indent": 3,
      "text": "The service of this protocol is the transmission of DTN bundles over TCP. This document specifies the encapsulation of bundles, procedures for TCP setup and teardown, and a set of messages and node requirements. The general operation of the protocol is as follows.",
      "ja": "このプロトコルのサービスは、TCP経由DTNバンドルの送信です。この文書では、バンドル、TCPのセットアップとティアダウン、およびメッセージやノード要件のセットのための手続きのカプセル化を指定します。次のようにプロトコルの一般的な動作です。"
    },
    {
      "indent": 3,
      "text": "First, one node establishes a TCPCL connection to the other by initiating a TCP connection. After setup of the TCP connection is complete, an initial contact header is exchanged in both directions to set parameters of the TCPCL connection and exchange a singleton endpoint identifier for each node (not the singleton Endpoint Identifier (EID) of any application running on the node) to denote the bundle-layer identity of each DTN node. This is used to assist in routing and forwarding messages, e.g., to prevent loops.",
      "ja": "まず、1つのノードがTCP接続を開始することによって、他にTCPCL接続を確立します。 TCP接続のセットアップが完了した後、最初のコンタクトヘッダはノード上で実行されている任意のアプリケーションのシングルトンエンドポイント識別子（EID）（TCPCL接続のパラメータを設定し、各ノードのシングルトンエンドポイント識別子を交換するために両方向でない交換されます）各DTNノードの束層アイデンティティを意味します。これは、ループを防止するために、例えば、ルーティングおよび転送メッセージを補助するために使用されます。"
    },
    {
      "indent": 3,
      "text": "Once the TCPCL connection is established and configured in this way, bundles can be transmitted in either direction. Each bundle is transmitted in one or more logical segments of formatted bundle data. Each logical data segment consists of a DATA_SEGMENT message header, a Self-Delimiting Numeric Value (SDNV) as defined in [RFC5050] (see also [RFC6256]) containing the length of the segment, and finally the byte range of the bundle data. The choice of the length to use for segments is an implementation matter. The first segment for a bundle must set the 'start' flag, and the last one must set the 'end' flag in the DATA_SEGMENT message header.",
      "ja": "TCPCL接続が確立され、このように構成されると、バンドルはどちらの方向に送信することができます。各バンドルは、フォーマットされたバンドルデータの1つのまたは複数の論理セグメントで送信されます。 [RFC5050]（また、[RFC6256]を参照）、セグメントの長さを含む、バンドルデータの最後にバイトの範囲で定義されるように、各論理データセグメントはDATA_SEGMENTメッセージヘッダ、自己区切り数値（SDNV）から成ります。セグメントに使用する長さの選択は、実装の問題です。バンドルの最初のセグメントは「開始」フラグを設定する必要があり、最後の一つはDATA_SEGMENTメッセージヘッダに「終了」フラグを設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If multiple bundles are transmitted on a single TCPCL connection, they MUST be transmitted consecutively. Interleaving data segments from different bundles is not allowed. Bundle interleaving can be accomplished by fragmentation at the BP layer.",
      "ja": "複数のバンドルを単一のTCPCL接続で送信された場合は、連続して送信されなければなりません。別のバンドルからのインターリーブデータセグメントは許されません。バンドルインターリーブはBP層に断片化することによって達成することができます。"
    },
    {
      "indent": 3,
      "text": "An optional feature of the protocol is for the receiving node to send acknowledgments as bundle data segments arrive (ACK_SEGMENT). The rationale behind these acknowledgments is to enable the sender node to determine how much of the bundle has been received, so that in case the connection is interrupted, it can perform reactive fragmentation to avoid re-sending the already transmitted part of the bundle.",
      "ja": "プロトコルのオプション機能は、バンドルデータセグメントが（ACK_SEGMENT）に到着するように肯定応答を送信する受信ノードのためのものです。これらの確認応答の理論的根拠は、接続が中断された場合には、それはバンドルの送信済みの一部を再送信を避けるために反応性の断片化を行うことができるように、受信されているどのくらいのバンドルの決定するために、送信ノードを有効にすることです。"
    },
    {
      "indent": 3,
      "text": "When acknowledgments are enabled, then for each data segment that is received, the receiving node sends an ACK_SEGMENT code followed by an SDNV containing the cumulative length of the bundle that has been received. The sending node may transmit multiple DATA_SEGMENT messages without necessarily waiting for the corresponding ACK_SEGMENT responses. This enables pipelining of messages on a channel. In addition, there is no explicit flow control on the TCPCL layer.",
      "ja": "肯定応答が有効になっている場合、次に受信される各データ・セグメントに対して、受信ノードは、受信された束の累積長さを含むSDNV続いACK_SEGMENTコードを送信します。送信ノードは、必ずしも対応ACK_SEGMENT応答を待たずに複数DATA_SEGMENTメッセージを送信することができます。これは、チャネル上のメッセージのパイプライン化を可能にします。また、TCPCL層上の明示的なフロー制御はありません。"
    },
    {
      "indent": 3,
      "text": "Another optional feature is that a receiver may interrupt the transmission of a bundle at any point in time by replying with a REFUSE_BUNDLE message, which causes the sender to stop transmission of the current bundle, after completing transmission of a partially sent data segment. Note: This enables a cross-layer optimization in that it allows a receiver that detects that it already has received a certain bundle to interrupt transmission as early as possible and thus save transmission capacity for other bundles.",
      "ja": "別のオプション機能は、受信機は、部分的に送信されたデータセグメントの送信を完了した後、現在のバンドルの送信を停止する送信者を引き起こすREFUSE_BUNDLEメッセージで応答することにより、任意の時点でのバンドルの送信を中断することができるということです。注：それは既にできるだけ早く送信を中断し、したがって、他のバンドルの伝送容量を節約するために特定のバンドルを受信したことを検出する受信機を可能という点で、これは、クロスレイヤ最適化を可能にします。"
    },
    {
      "indent": 3,
      "text": "For connections that are idle, a KEEPALIVE message may optionally be sent at a negotiated interval. This is used to convey liveness information.",
      "ja": "アイドル状態にある接続の場合、KEEPALIVEメッセージは、必要に応じて交渉された間隔で送信されても​​よいです。これは、生存性情報を伝えるために使用されます。"
    },
    {
      "indent": 3,
      "text": "Finally, before connections close, a SHUTDOWN message is sent on the channel. After sending a SHUTDOWN message, the sender of this message may send further acknowledgments (ACK_SEGMENT or REFUSE_BUNDLE) but no further data messages (DATA_SEGMENT). A SHUTDOWN message may also be used to refuse a connection setup by a peer.",
      "ja": "最後に、近くに接続する前に、SHUTDOWNメッセージは、チャネル上で送信されます。 SHUTDOWNメッセージを送信した後、このメッセージの送信者は、さらに、肯定応答（ACK_SEGMENT又はREFUSE_BUNDLE）はないさらなるデータメッセージ（DATA_SEGMENT）を送信することができます。 SHUTDOWNメッセージは、ピアによって接続セットアップを拒否するために使用することができます。"
    },
    {
      "indent": 0,
      "text": "3.1. Bidirectional Use of TCP Connection",
      "section_title": true,
      "ja": "3.1。 TCPコネクションの双方向利用"
    },
    {
      "indent": 3,
      "text": "There are specific messages for sending and receiving operations (in addition to connection setup/teardown). TCPCL is symmetric, i.e., both sides can start sending data segments in a connection, and one side's bundle transfer does not have to complete before the other side can start sending data segments on its own. Hence, the protocol allows for a bi-directional mode of communication.",
      "ja": "（接続設定/ティアダウンに加えて）操作を送受信するための具体的なメッセージがあります。 TCPCLが対称である、即ち、両側の接続でデータセグメントの送信を開始することができ、片側のバンドルの転送は、他の側が独自にデータセグメントの送信を開始する前に完了する必要はありません。したがって、プロトコルは通信の双方向モードを可能にします。"
    },
    {
      "indent": 3,
      "text": "Note that in the case of concurrent bidirectional transmission, acknowledgment segments may be interleaved with data segments.",
      "ja": "同時双方向伝送の場合には、肯定応答セグメントは、データセグメントとインタリーブされてもよいことに留意されたいです。"
    },
    {
      "indent": 0,
      "text": "3.2. Example Message Exchange",
      "section_title": true,
      "ja": "3.2。例メッセージ交換"
    },
    {
      "indent": 3,
      "text": "The following figure visually depicts the protocol exchange for a simple session, showing the connection establishment and the transmission of a single bundle split into three data segments (of lengths L1, L2, and L3) from Node A to Node B.",
      "ja": "次の図は、視覚的にノードBにノードAから（長さL1、L2、およびL3の）接続の確立と、3つのデータセグメントに単一束分割の送信を示す、単純なセッションのためのプロトコル交換を示します"
    },
    {
      "indent": 3,
      "text": "Note that the sending node may transmit multiple DATA_SEGMENT messages without necessarily waiting for the corresponding ACK_SEGMENT responses. This enables pipelining of messages on a channel. Although this example only demonstrates a single bundle transmission, it is also possible to pipeline multiple DATA_SEGMENT messages for different bundles without necessarily waiting for ACK_SEGMENT messages to be returned for each one. However, interleaving data segments from different bundles is not allowed.",
      "ja": "送信ノードは、必ずしも対応ACK_SEGMENT応答を待たずに複数DATA_SEGMENTメッセージを送信してもよいことに留意されたいです。これは、チャネル上のメッセージのパイプライン化を可能にします。この例では、単一のバンドルの送信を示しているが、必ずしもそれぞれのために返されるACK_SEGMENTメッセージを待たずに、異なるバンドルのパイプラインの複数DATA_SEGMENTメッセージことが可能です。しかし、別のバンドルからのインターリーブデータセグメントは許されません。"
    },
    {
      "indent": 3,
      "text": "No errors or rejections are shown in this example.",
      "ja": "エラーや拒否は、この例で示されていません。"
    },
    {
      "indent": 18,
      "text": "Node A                              Node B\n======                              ======",
      "raw": true
    },
    {
      "indent": 8,
      "text": "+-------------------------+         +-------------------------+\n|     Contact Header      | ->   <- |     Contact Header      |\n+-------------------------+         +-------------------------+",
      "raw": true
    },
    {
      "indent": 8,
      "text": "+-------------------------+\n|   DATA_SEGMENT (start)  | ->\n|    SDNV length [L1]     | ->\n|  Bundle Data 0..(L1-1)  | ->\n+-------------------------+\n+-------------------------+         +-------------------------+\n|     DATA_SEGMENT        | ->   <- |       ACK_SEGMENT       |\n|    SDNV length [L2]     | ->   <- |     SDNV length [L1]    |\n|Bundle Data L1..(L1+L2-1)| ->      +-------------------------+\n+-------------------------+\n+-------------------------+         +-------------------------+\n|    DATA_SEGMENT (end)   | ->   <- |       ACK_SEGMENT       |\n|     SDNV length [L3]    | ->   <- |   SDNV length [L1+L2]   |\n|Bundle Data              | ->      +-------------------------+\n|    (L1+L2)..(L1+L2+L3-1)|\n+-------------------------+\n                                    +-------------------------+\n                                 <- |       ACK_SEGMENT       |\n                                 <- |  SDNV length [L1+L2+L3] |\n                                    +-------------------------+",
      "raw": true
    },
    {
      "indent": 8,
      "text": "+-------------------------+         +-------------------------+\n|       SHUTDOWN          | ->   <- |         SHUTDOWN        |\n+-------------------------+         +-------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Figure 2: A Simple Visual Example of the Flow of Protocol Messages on a Single TCP Session between Two Nodes (A and B)",
      "ja": "図2：2つのノード間の単一のTCPセッションでプロトコルメッセージの流れ（AとB）のシンプルなビジュアル例"
    },
    {
      "indent": 0,
      "text": "4. Connection Establishment",
      "section_title": true,
      "ja": "4.接続の確立"
    },
    {
      "indent": 3,
      "text": "For bundle transmissions to occur using the TCPCL, a TCPCL connection must first be established between communicating nodes. It is up to the implementation to decide how and when connection setup is triggered. For example, some connections may be opened proactively and maintained for as long as is possible given the network conditions, while other connections may be opened only when there is a bundle that is queued for transmission and the routing algorithm selects a certain next-hop node.",
      "ja": "バンドル伝送がTCPCLを使用して発生するため、TCPCL接続が第一通信ノードとの間で確立されなければなりません。それは、いつ、どのように接続設定がトリガされるかを決定するために、実装に任されています。送信のためにキューされるバンドルがある場合にのみ、他の接続が開かれてもよく、ルーティングアルゴリズムは、特定の次ホップノードを選択しながら、例えば、いくつかの接続は、限り、ネットワークの状態所与ことができるようにするために積極的に開いて維持することができます。"
    },
    {
      "indent": 3,
      "text": "To establish a TCPCL connection, a node must first establish a TCP connection with the intended peer node, typically by using the services provided by the operating system. Port number 4556 has been assigned by IANA as the well-known port number for the TCP convergence layer. Other port numbers MAY be used per local configuration. Determining a peer's port number (if different from the well-known TCPCL port) is up to the implementation.",
      "ja": "TCPCL接続を確立するには、ノードは、最初に、通常のオペレーティング・システムによって提供されるサービスを使用することにより、目的とするピア・ノードとのTCP接続を確立する必要があります。ポート番号4556は、TCPの収束層のためのよく知られたポート番号としてIANAによって割り当てられています。その他のポート番号は、ローカル設定ごとに使用されるかもしれません。ピアのポート番号（周知TCPCLポートと異なる場合）を決定することは実装次第です。"
    },
    {
      "indent": 3,
      "text": "If the node is unable to establish a TCP connection for any reason, then it is an implementation matter to determine how to handle the connection failure. A node MAY decide to re-attempt to establish the connection. If it does so, it MUST NOT overwhelm its target with repeated connection attempts. Therefore, the node MUST retry the connection setup only after some delay (a 1-second minimum is RECOMMENDED), and it SHOULD use a (binary) exponential backoff mechanism to increase this delay in case of repeated failures. In case a SHUTDOWN message specifying a reconnection delay is received, that delay is used as the initial delay. The default initial delay SHOULD be at least 1 second but SHOULD be configurable since it will be application and network type dependent.",
      "ja": "ノードが何らかの理由でTCPコネクションを確立することができないなら、接続障害を処理する方法を決定するために、実装の問題です。ノードが接続を確立するための試行を再することもできます。それはそうするならば、それを繰り返し接続の試行とそのターゲットを圧倒してはなりません。したがって、ノードは、（1秒の最小値を推奨）のみいくらかの遅延後に接続設定を再試行しなければなりません、そして、それは繰り返し失敗する場合には、この遅延を増加させる（バイナリ）指数バックオフ・メカニズムを使用すべきです。再接続遅延を指定SHUTDOWNメッセージを受信した場合に、その遅延は、初期遅延として使用されます。デフォルトの初期遅延は、少なくとも1秒であるべきであるが、それはアプリケーションに依存し、ネットワークタイプであるので、構成であるべきです。"
    },
    {
      "indent": 3,
      "text": "The node MAY declare failure after one or more connection attempts and MAY attempt to find an alternate route for bundle data. Such decisions are up to the higher layer (i.e., the BP).",
      "ja": "ノードは、1回のまたは複数の接続試行後に失敗を宣言することができる、バンドルデータのための代替ルートを見つけることを試みることができます。そのような決定は上位層（すなわち、BP）までです。"
    },
    {
      "indent": 3,
      "text": "Once a TCP connection is established, each node MUST immediately transmit a contact header over the TCP connection. The format of the contact header is described in Section 4.1.",
      "ja": "TCP接続が確立されると、各ノードは、直ちにTCP接続を介してコンタクトヘッダを送信しなければなりません。 Contactヘッダのフォーマットは、セクション4.1に記載されています。"
    },
    {
      "indent": 3,
      "text": "Upon receipt of the contact header, both nodes perform the validation and negotiation procedures defined in Section 4.2",
      "ja": "Contactヘッダを受信すると、両方のノードは、セクション4.2で定義された検証とネゴシエーション手順を実行します"
    },
    {
      "indent": 3,
      "text": "After receiving the contact header from the other node, either node MAY also refuse the connection by sending a SHUTDOWN message. If connection setup is refused, a reason MUST be included in the SHUTDOWN message.",
      "ja": "他のノードからのContactヘッダを受信した後、いずれかのノードは、シャットダウンメッセージを送信することによって、接続を拒否してもよいです。接続設定が拒否された場合、その理由は、SHUTDOWNメッセージに含まれなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.1. Contact Header",
      "section_title": true,
      "ja": "4.1。連絡先ヘッダー"
    },
    {
      "indent": 3,
      "text": "Once a TCP connection is established, both parties exchange a contact header. This section describes the format of the contact header and the meaning of its fields.",
      "ja": "TCP接続が確立されると、両当事者は、コンタクトヘッダを交換します。このセクションでは、コンタクトヘッダのフォーマットとそのフィールドの意味を説明しています。"
    },
    {
      "indent": 3,
      "text": "The format for the Contact Header is as follows:",
      "ja": "次のように連絡先ヘッダーの形式は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "                     1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+---------------+---------------+---------------+---------------+\n|                          magic='dtn!'                         |\n+---------------+---------------+---------------+---------------+\n|     version   |     flags     |      keepalive_interval       |\n+---------------+---------------+---------------+---------------+\n|                     local EID length (SDNV)                   |\n+---------------+---------------+---------------+---------------+\n|                                                               |\n+                      local EID (variable)                     +\n|                                                               |\n+---------------+---------------+---------------+---------------+",
      "raw": true
    },
    {
      "indent": 22,
      "text": "Figure 3: Contact Header Format",
      "ja": "図3：連絡先ヘッダー形式"
    },
    {
      "indent": 3,
      "text": "The fields of the contact header are:",
      "ja": "Contactヘッダのフィールドは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "magic: A four-byte field that always contains the byte sequence 0x64 0x74 0x6e 0x21, i.e., the text string \"dtn!\" in US-ASCII.",
      "ja": "魔法：常に0x64 0x74 0x6e 0x21で、すなわち、テキスト文字列のバイト配列を含む4バイトのフィールド「DTN！」 US-ASCIIインチ"
    },
    {
      "indent": 3,
      "text": "version: A one-byte field value containing the value 3 (current version of the protocol).",
      "ja": "バージョン：値3を含む1バイトのフィールド値（プロトコルの現在のバージョン）。"
    },
    {
      "indent": 3,
      "text": "flags: A one-byte field containing optional connection flags. The first four bits are unused and MUST be set to zero upon transmission and MUST be ignored upon reception. The last four bits are interpreted as shown in Table 1 below.",
      "ja": "フラグ：オプションの接続フラグを含む1バイトのフィールド。最初の4ビットは未使用であり、送信時にゼロに設定しなければならなくて、受信時に無視しなければなりません。最後の4ビットは、以下の表1に示すように解釈されます。"
    },
    {
      "indent": 3,
      "text": "keepalive_interval: A two-byte integer field containing the number of seconds between exchanges of KEEPALIVE messages on the connection (see Section 5.6). This value is in network byte order, as are all other multi-byte fields described in this protocol.",
      "ja": "keepalive_interval：接続にキープアライブメッセージの交換の間の秒数を含む2バイトの整数フィールド（セクション5.6を参照）。このプロトコールに記載されているすべての他のマルチバイト・フィールドであり、この値は、ネットワークバイト順です。"
    },
    {
      "indent": 3,
      "text": "local EID length: A variable-length SDNV field containing the length of the endpoint identifier (EID) for some singleton endpoint in which the sending node is a member. A four-byte SDNV is depicted for clarity of the figure.",
      "ja": "ローカルEID長：送信ノードがメンバーであるいくつかのシングルトンエンドポイントのエンドポイント識別子（EID）の長さを含む可変長SDNVフィールド。 4バイトのSDNVは、図の明確化のために描かれています。"
    },
    {
      "indent": 3,
      "text": "local EID: A byte string containing the EID of some singleton endpoint in which the sending node is a member, in the canonical format of <scheme name>:<scheme-specific part>. An eight-byte EID is shown for clarity of the figure.",
      "ja": "ローカルEID <スキーマ固有部分>：送信ノードは、<スキーム名>の正規の形式で、メンバーであるいくつかのシングルトンエンドポイントのEIDを含むバイトストリング。 8バイトのEIDは、図の明確化のために示されています。"
    },
    {
      "indent": 3,
      "text": "+----------+--------------------------------------------------------+\n|  Value   | Meaning                                                |\n+----------+--------------------------------------------------------+\n| 00000001 | Request acknowledgment of bundle segments.             |\n| 00000010 | Request enabling of reactive fragmentation.            |\n| 00000100 | Indicate support for bundle refusal.  This flag MUST   |\n|          | NOT be set to '1' unless support for acknowledgments   |\n|          | is also indicated.                                     |\n| 00001000 | Request sending of LENGTH messages.                    |\n+----------+--------------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 23,
      "text": "Table 1: Contact Header Flags",
      "ja": "表1：連絡先ヘッダーのフラグ"
    },
    {
      "indent": 3,
      "text": "The manner in which values are configured and chosen for the various flags and parameters in the contact header is implementation dependent.",
      "ja": "値は、Contactヘッダにおける各種フラグやパラメータのために構成および選択される方法は実装依存です。"
    },
    {
      "indent": 0,
      "text": "4.2. Validation and Parameter Negotiation",
      "section_title": true,
      "ja": "4.2。検証とパラメータのネゴシエーション"
    },
    {
      "indent": 3,
      "text": "Upon reception of the contact header, each node follows the following procedures to ensure the validity of the TCPCL connection and to negotiate values for the connection parameters.",
      "ja": "Contactヘッダを受信すると、各ノードはTCPCL接続の正当性を保証するために、接続パラメータの値を交渉するために、以下の手順に従います。"
    },
    {
      "indent": 3,
      "text": "If the magic string is not present or is not valid, the connection MUST be terminated. The intent of the magic string is to provide some protection against an inadvertent TCP connection by a different protocol than the one described in this document. To prevent a flood of repeated connections from a misconfigured application, a node MAY elect to hold an invalid connection open and idle for some time before closing it.",
      "ja": "魔法の文字列が存在しないか、有効でない場合、接続が終了しなければなりません。魔法の文字列の意図は、この文書で説明したものとは異なるプロトコルによって不注意TCPコネクションに対するいくつかの保護を提供することです。誤設定、アプリケーションから繰り返し接続の洪水を防ぐために、ノードは、それを閉じる前にいくつかの時間のためにオープンし、アイドル状態の無効な接続を保持するために選ぶことができます。"
    },
    {
      "indent": 3,
      "text": "If a node receives a contact header containing a version that is greater than the current version of the protocol that the node implements, then the node SHOULD interpret all fields and messages as it would normally. If a node receives a contact header with a version that is lower than the version of the protocol that the node implements, the node may either terminate the connection due to the version mismatch or may adapt its operation to conform to the older version of the protocol. This decision is an implementation matter.",
      "ja": "ノードは、通常どおり、そのノードはすべてのフィールドと、メッセージを解釈すべきノードが実装プロトコルの現在のバージョンよりも大きいバージョンを含むContactヘッダを受信した場合。ノードは、ノードが実装プロトコルのバージョンよりも低いバージョンのContactヘッダを受信した場合、ノードが原因バージョンの不一致への接続を終了させることができる一方またはプロトコルの古いバージョンに適合するようにその動作を適応させることができます。この決定は、実装上の問題です。"
    },
    {
      "indent": 3,
      "text": "A node calculates the parameters for a TCPCL connection by negotiating the values from its own preferences (conveyed by the contact header it sent) with the preferences of the peer node (expressed in the contact header that it received). This negotiation MUST proceed in the following manner: o The parameter for requesting acknowledgment of bundle segments is set to true iff the corresponding flag is set in both contact headers.",
      "ja": "ノードは、（それが受信されたコンタクトヘッダで表される）ピア・ノードのリファレンスで、それ自身の好み（それは送信されたコンタクトヘッダによって搬送）からの値を交渉することによってTCPCL接続のためのパラメータを算出します。このネゴシエーションは以下のように進行しなければならない：対応するフラグが共にコンタクトヘッダに設定されているときに限り束セグメントの肯定応答を要求するためのパラメータがtrueに設定されているoを。"
    },
    {
      "indent": 3,
      "text": "o The parameter for enabling reactive fragmentation is set to true iff the corresponding flag is set in both contact headers.",
      "ja": "O対応するフラグが共にコンタクトヘッダに設定されているときに限り反応性の断片化を可能にするためのパラメータがtrueに設定されています。"
    },
    {
      "indent": 3,
      "text": "o The bundle refusal capability is set to true if the corresponding flag is set in both contact headers and if segment acknowledgment has been enabled.",
      "ja": "O対応するフラグが共にコンタクトヘッダに設定されている場合、セグメントの肯定応答が有効になっている場合、バンドル拒否能力がtrueに設定されています。"
    },
    {
      "indent": 3,
      "text": "o The keepalive_interval parameter is set to the minimum value from both contact headers. If one or both contact headers contains the value zero, then the keepalive feature (described in Section 5.6) is disabled.",
      "ja": "O keepalive_intervalパラメータは、両方のコンタクトヘッダから最小値に設定されています。一方または両方のコンタクトヘッダが値ゼロが含まれている場合、（5.6節を参照）キープアライブ機能は無効です。"
    },
    {
      "indent": 3,
      "text": "o The flag requesting sending of LENGTH messages is handled as described in Section 5.5.",
      "ja": "セクション5.5で説明したように、O LENGTHメッセージの送信要求フラグが処理されます。"
    },
    {
      "indent": 3,
      "text": "Once this process of parameter negotiation is completed, the protocol defines no additional mechanism to change the parameters of an established connection; to effect such a change, the connection MUST be terminated and a new connection established.",
      "ja": "パラメータネゴシエーションのこの処理が完了すると、プロトコルが確立された接続のパラメータを変更するための追加のメカニズムを定義していません。このような変化をもたらすために、接続が終了し、新しい接続が確立されなければなりません。"
    },
    {
      "indent": 0,
      "text": "5. Established Connection Operation",
      "section_title": true,
      "ja": "5.確立された接続の操作"
    },
    {
      "indent": 3,
      "text": "This section describes the protocol operation for the duration of an established connection, including the mechanisms for transmitting bundles over the connection.",
      "ja": "このセクションでは、接続を介してバンドルを送信するためのメカニズムを含む確立された接続の継続時間のプロトコル動作を説明します。"
    },
    {
      "indent": 0,
      "text": "5.1. Message Type Codes",
      "section_title": true,
      "ja": "5.1。メッセージタイプコード"
    },
    {
      "indent": 3,
      "text": "After the initial exchange of a contact header, all messages transmitted over the connection are identified by a one-byte header with the following structure:",
      "ja": "Contactヘッダの最初の交換の後、接続を介して送信されるすべてのメッセージは以下の構造を有する1バイトのヘッダにより識別されます。"
    },
    {
      "indent": 28,
      "text": " 0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+\n| type  | flags |\n+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 14,
      "text": "Figure 4: Format of the One-Byte Message Header",
      "ja": "図4：半角のメッセージヘッダのフォーマット"
    },
    {
      "indent": 3,
      "text": "type: Indicates the type of the message as per Table 2 below",
      "ja": "タイプ：下記表2の通り、メッセージのタイプを示し"
    },
    {
      "indent": 3,
      "text": "flags: Optional flags defined based on message type.",
      "ja": "フラグ：メッセージタイプに基づいて定義されたオプションのフラグ。"
    },
    {
      "indent": 3,
      "text": "The types and values for the message type code are as follows.",
      "ja": "次のようにメッセージタイプコードの種類および値です。"
    },
    {
      "indent": 3,
      "text": "+----------------+---------+----------------------------------------+\n|      Type      | Code    | Description                            |\n+----------------+---------+----------------------------------------+\n|                | 0x0     | Reserved.                              |\n|                |         |                                        |\n|  DATA_SEGMENT  | 0x1     | Indicates the transmission of a        |\n|                |         | segment of bundle data, as described   |\n|                |         | in Section 5.2.                        |\n|                |         |                                        |\n|  ACK_SEGMENT   | 0x2     | Acknowledges reception of a data       |\n|                |         | segment, as described in Section 5.3   |\n|                |         |                                        |\n| REFUSE_BUNDLE  | 0x3     | Indicates that the transmission of the |\n|                |         | current bundle shall be stopped, as    |\n|                |         | described in Section 5.4.              |\n|                |         |                                        |\n|   KEEPALIVE    | 0x4     | KEEPALIVE message for the connection,  |\n|                |         | as described in Section 5.6.           |\n|                |         |                                        |\n|    SHUTDOWN    | 0x5     | Indicates that one of the nodes        |\n|                |         | participating in the connection wishes |\n|                |         | to cleanly terminate the connection,   |\n|                |         | as described in Section 6.             |\n|                |         |                                        |\n|     LENGTH     | 0x6     | Contains the length (in bytes) of the  |\n|                |         | next bundle, as described in Section   |\n|                |         | 5.5.                                   |\n|                |         |                                        |\n|                | 0x7-0xf | Unassigned.                            |\n|                |         |                                        |\n+----------------+---------+----------------------------------------+",
      "raw": true
    },
    {
      "indent": 23,
      "text": "Table 2: TCPCL Message Types",
      "ja": "表2：TCPCLメッセージタイプ"
    },
    {
      "indent": 0,
      "text": "5.2. Bundle Data Transmission (DATA_SEGMENT)",
      "section_title": true,
      "ja": "5.2。バンドルデータ送信（DATA_SEGMENT）"
    },
    {
      "indent": 3,
      "text": "Each bundle is transmitted in one or more data segments. The format of a DATA_SEGMENT message follows:",
      "ja": "各束は、1つまたは複数のデータセグメントで送信されます。 DATA_SEGMENTメッセージのフォーマットは次のとおりです。"
    },
    {
      "indent": 6,
      "text": "                     1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  0x1  |0|0|S|E|   length ...    |  contents....               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 17,
      "text": "Figure 5: Format of DATA_SEGMENT Messages",
      "ja": "図5：DATA_SEGMENTメッセージのフォーマット"
    },
    {
      "indent": 3,
      "text": "The type portion of the message header contains the value 0x1.",
      "ja": "メッセージヘッダーの型部分は、0x1の値を含んでいます。"
    },
    {
      "indent": 3,
      "text": "The flags portion of the message header byte contains two optional values in the two low-order bits, denoted 'S' and 'E' above. The 'S' bit MUST be set to one if it precedes the transmission of the first segment of a new bundle. The 'E' bit MUST be set to one when transmitting the last segment of a bundle.",
      "ja": "メッセージ・ヘッダ・バイトのフラグ部分は、下位2ビット、示さ「S」と、上記「E」で2つのオプション値を含みます。それは新しいバンドルの最初のセグメントの送信に先行する場合は「S」ビットが1に設定しなければなりません。バンドルの最後のセグメントを送信する際に「E」ビットが1に設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Following the message header, the length field is an SDNV containing the number of bytes of bundle data that are transmitted in this segment. Following this length is the actual data contents.",
      "ja": "メッセージヘッダ以下、長さフィールドは、このセグメントで送信されるバンドルデータのバイトの数を含むSDNVあります。この長さの後には、実際のデータ内容です。"
    },
    {
      "indent": 3,
      "text": "Determining the size of the segment is an implementation matter. In particular, a node may, based on local policy or configuration, only ever transmit bundle data in a single segment, in which case both the 'S' and 'E' bits MUST be set to one.",
      "ja": "セグメントのサイズを決定することは、実装上の問題です。具体的には、ノードは、ローカルポリシーまたは設定に基づいて、しか単一のセグメントでバンドルデータを送信することが可能で、その場合、「S」と「E」の両方のビットが1に設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "In the Bundle Protocol specification [RFC5050], a single bundle comprises a primary bundle block, a payload block, and zero or more additional bundle blocks. The relationship between the protocol blocks and the convergence-layer segments is an implementation-specific decision. In particular, a segment MAY contain more than one protocol block; alternatively, a single protocol block (such as the payload) MAY be split into multiple segments.",
      "ja": "バンドルプロトコル仕様[RFC5050]において、単一のバンドルは、一次バンドルブロック、ペイロード・ブロック、およびゼロまたはそれ以上の追加のバンドルブロックを含みます。プロトコルブロックと収束層セグメントとの関係は、実装固有の決定です。特に、セグメントは、複数のプロトコルのブロックを含むかもしれません。代替的に、単一のプロトコルブロック（例えばペイロードのような）複数のセグメントに分割することができます。"
    },
    {
      "indent": 3,
      "text": "However, a single segment MUST NOT contain data of more than a single bundle.",
      "ja": "しかし、単一のセグメントは、単一のバンドル以上のデータを含んではなりません。"
    },
    {
      "indent": 3,
      "text": "Once a transmission of a bundle has commenced, the node MUST only send segments containing sequential portions of that bundle until it sends a segment with the 'E' bit set.",
      "ja": "バンドルの送信を開始した後、それが「E」ビットが設定されたセグメントを送信するまで、ノードは、そのバンドルの連続部分を含むセグメントを送信しなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.3. Bundle Acknowledgments (ACK_SEGMENT)",
      "section_title": true,
      "ja": "5.3。バンドル謝辞（ACK_SEGMENT）"
    },
    {
      "indent": 3,
      "text": "Although the TCP transport provides reliable transfer of data between transport peers, the typical BSD sockets interface provides no means to inform a sending application of when the receiving application has processed some amount of transmitted data. Thus, after transmitting some data, a Bundle Protocol agent needs an additional mechanism to determine whether the receiving agent has successfully received the segment.",
      "ja": "TCPトランスポートは、トランスポートピア間のデータの信頼性の転送を提供するが、典型的なBSDソケットインタフェースは、受信側アプリケーションが送信したデータのいくつかの量を処理したときの送信アプリケーションに通知する手段を提供しません。したがって、いくつかのデータを送信した後、バンドルプロトコルエージェントは、受信エージェントは、セグメントを正常に受信したか否かを決定するために追加のメカニズムが必要です。"
    },
    {
      "indent": 3,
      "text": "To this end, the TCPCL protocol offers an optional feature whereby a receiving node transmits acknowledgments of reception of data segments. This feature is enabled if, and only if, during the exchange of contact headers, both parties set the flag to indicate that segment acknowledgments are enabled (see Section 4.1). If so, then the receiver MUST transmit a bundle acknowledgment message when it successfully receives each data segment.",
      "ja": "この目的のために、TCPCLプロトコルは、受信ノードがデータセグメントの受信の確認応答を送信することにより、オプションの機能を提供します。 、およびのみばコンタクトヘッダの交換時に、両当事者は肯定応答が有効になっていることセグメント（セクション4.1を参照）を示すフラグを設定した場合、この機能が有効になっています。もしそうであれば、それが正常に各データセグメントを受信した場合、受信機は、バンドル応答メッセージを送信しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The format of a bundle acknowledgment is as follows:",
      "ja": "次のようにバンドル確認応答の形式は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "                     1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  0x2  |0|0|0|0|   acknowledged length ...                     |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 17,
      "text": "Figure 6: Format of ACK_SEGMENT Messages",
      "ja": "図6：ACK_SEGMENTメッセージのフォーマット"
    },
    {
      "indent": 3,
      "text": "To transmit an acknowledgment, a node first transmits a message header with the ACK_SEGMENT type code and all flags set to zero, then transmits an SDNV containing the cumulative length in bytes of the received segment(s) of the current bundle. The length MUST fall on a segment boundary. That is, only full segments can be acknowledged.",
      "ja": "肯定応答を送信するため、ノードは最初ACK_SEGMENTタイプコードを有するメッセージヘッダと、ゼロに設定されたすべてのフラグを送信し、その後、現在のバンドルの受信セグメント（S）のバイト単位の累積長さを含むSDNVを送信します。長さは、セグメント境界上になければなりません。つまり、唯一のフルセグメントが認められることができます。"
    },
    {
      "indent": 3,
      "text": "For example, suppose the sending node transmits four segments of bundle data with lengths 100, 200, 500, and 1000, respectively. After receiving the first segment, the node sends an acknowledgment of length 100. After the second segment is received, the node sends an acknowledgment of length 300. The third and fourth acknowledgments are of length 800 and 1800, respectively.",
      "ja": "例えば、送信ノードは、それぞれ4つの長さ100とバンドルデータのセグメント、200、500、1000を送信すると仮定する。第二のセグメントが受信された後の最初のセグメントを受信した後、ノードは、長さ100の肯定応答を送信し、ノードは、第3及び第4の肯定応答は、それぞれ、長さ800〜1800である長さ300の肯定応答を送信します。"
    },
    {
      "indent": 0,
      "text": "5.4. Bundle Refusal (REFUSE_BUNDLE)",
      "section_title": true,
      "ja": "5.4。バンドル拒否（REFUSE_BUNDLE）"
    },
    {
      "indent": 3,
      "text": "As bundles may be large, the TCPCL supports an optional mechanisms by which a receiving node may indicate to the sender that it does not want to receive the corresponding bundle.",
      "ja": "束が大きくてもよいように、TCPCLは、受信ノードが、対応するバンドルを受信したくない送信者に示すことができることにより、任意のメカニズムをサポートします。"
    },
    {
      "indent": 3,
      "text": "To do so, upon receiving a DATA_SEGMENT message, the node MAY transmit a REFUSE_BUNDLE message. As data segments and acknowledgments may cross on the wire, the bundle that is being refused is implicitly identified by the sequence in which acknowledgements and refusals are received.",
      "ja": "DATA_SEGMENTメッセージを受信すると、これを行うために、ノードはREFUSE_BUNDLEメッセージを送信することができます。データセグメントと肯定応答がワイヤに交差することができるように、拒否されているバンドルは暗黙的確認応答と拒否が受信される順序によって識別されます。"
    },
    {
      "indent": 3,
      "text": "The format of the REFUSE_BUNDLE message is as follows:",
      "ja": "次のようにREFUSE_BUNDLEメッセージの形式は次のとおりです。"
    },
    {
      "indent": 30,
      "text": " 0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+\n|  0x3  | RCode |\n+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 16,
      "text": "Figure 7: Format of REFUSE_BUNDLE Messages",
      "ja": "図7：REFUSE_BUNDLEメッセージのフォーマット"
    },
    {
      "indent": 3,
      "text": "The RCode field, which stands for \"reason code\", contains a value indicating why the bundle was refused. The following table contains semantics for some values. Other values may be registered with IANA, as defined in Section 8.",
      "ja": "「理由コード」の略でRCODEフィールドは、バンドルが拒否された理由を示す値が含まれています。次の表は、いくつかの値のためのセマンティクスが含まれています。セクション8で定義されるように他の値は、IANAに登録されてもよいです。"
    },
    {
      "indent": 3,
      "text": "+---------+---------------------------------------------------------+\n|  RCode  | Semantics                                               |\n+---------+---------------------------------------------------------+\n|   0x0   | Reason for refusal is unknown or not specified.         |\n|   0x1   | The receiver now has the complete bundle.  The sender   |\n|         | may now consider the bundle as completely received.     |\n|   0x2   | The receiver's resources are exhausted.  The sender     |\n|         | SHOULD apply reactive bundle fragmentation before       |\n|         | retrying.                                               |\n|   0x3   | The receiver has encountered a problem that requires    |\n|         | the bundle to be retransmitted in its entirety.         |\n| 0x4-0x7 | Unassigned.                                             |\n| 0x8-0xf | Reserved for future usage.                              |\n+---------+---------------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 20,
      "text": "Table 3: REFUSE_BUNDLE Reason Codes",
      "ja": "表3：REFUSE_BUNDLE理由コード"
    },
    {
      "indent": 3,
      "text": "The receiver MUST, for each bundle preceding the one to be refused, have either acknowledged all DATA_SEGMENTs or refused the bundle. This allows the sender to identify the bundles accepted and refused by means of a simple FIFO list of segments and acknowledgments.",
      "ja": "受信機は、一つ前の各バンドルが拒否されるため、いずれかのすべてのDATA_SEGMENTsを認めまたはバンドルを拒否している必要があります。これは、送信者は、セグメントと確認応答のシンプルなFIFOリストによって受け入れられ、拒否したバンドルを識別することができます。"
    },
    {
      "indent": 3,
      "text": "The bundle refusal MAY be sent before the entire data segment is received. If a sender receives a REFUSE_BUNDLE message, the sender MUST complete the transmission of any partially sent DATA_SEGMENT message (so that the receiver stays in sync). The sender MUST NOT commence transmission of any further segments of the rejected bundle subsequently. Note, however, that this requirement does not ensure that a node will not receive another DATA_SEGMENT for the same bundle after transmitting a REFUSE_BUNDLE message since messages may cross on the wire; if this happens, subsequent segments of the bundle SHOULD also be refused with a REFUSE_BUNDLE message.",
      "ja": "全データセグメントが受信される前にバンドル拒絶を送ってもよいです。送信者がREFUSE_BUNDLEメッセージを受信した場合（受信機が同期に留まるように）、送信者は、任意の部分的に送信されたDATA_SEGMENTメッセージの送信を完了しなければなりません。送信者は、その後に拒否され、バンドルのいずれかの更なるセグメントの送信を開始してはなりません。ただし、この要求メッセージは、ワイヤ上で交差することができるので、ノードはREFUSE_BUNDLEメッセージを送信した後、同じバンドルの別のDATA_SEGMENTを受けないことを保証しないこと。この場合、バンドルの後続セグメントはまたREFUSE_BUNDLEメッセージで拒否されるべきです。"
    },
    {
      "indent": 3,
      "text": "Note: If a bundle transmission is aborted in this way, the receiver may not receive a segment with the 'E' flag set to '1' for the aborted bundle. The beginning of the next bundle is identified by the 'S' bit set to '1', indicating the start of a new bundle.",
      "ja": "注：バンドル伝送このように中断された場合、受信機は、中断されたバンドルの「1」と「E」フラグが設定されたセグメントを受信することができません。次の束の始まりは、新しいバンドルの開始を示す、「1」に設定「S」ビットによって識別されます。"
    },
    {
      "indent": 0,
      "text": "5.5. Bundle Length (LENGTH)",
      "section_title": true,
      "ja": "5.5。バンドルの長さ（LENGTH）"
    },
    {
      "indent": 3,
      "text": "The LENGTH message contains the total length, in bytes, of the next bundle, formatted as an SDNV. Its purpose is to allow nodes to preemptively refuse bundles that would exceed their resources. It is an optimization.",
      "ja": "LENGTHメッセージはSDNVとしてフォーマット、次のバンドルのバイト単位の全長を、含んでいます。その目的は、ノードが先制そのリソースを超えるバンドルを拒否できるようにすることです。これは、最適化です。"
    },
    {
      "indent": 3,
      "text": "The format of the LENGTH message is as follows:",
      "ja": "次のように長のメッセージの形式は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "                     1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  0x6  |0|0|0|0|     total bundle length ...                   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 20,
      "text": "Figure 8: Format of LENGTH Messages",
      "ja": "図8：LENGTHメッセージのフォーマット"
    },
    {
      "indent": 3,
      "text": "LENGTH messages MUST NOT be sent unless the corresponding flag bit is set in the contact header. If the flag bit is set, LENGTH messages MAY be sent at the sender's discretion. LENGTH messages MUST NOT be sent unless the next DATA_SEGMENT message has the 'S' bit set to \"1\" (i.e., just before the start of a new bundle).",
      "ja": "対応するフラグビットがContactヘッダに設定されていない限りLENGTHメッセージを送ってはいけません。フラグビットがセットされている場合、LENGTHメッセージは送信者の裁量で送るかもしれません。次のDATA_SEGMENTメッセージが（すなわち、ちょうど新しいバンドルの開始前に）「1」に設定「S」ビットを持っていない限り、LENGTHメッセージを送ってはいけません。"
    },
    {
      "indent": 3,
      "text": "A receiver MAY send a BUNDLE_REFUSE message as soon as it receives a LENGTH message without waiting for the next DATA_SEGMENT message. The sender MUST be prepared for this and MUST associate the refusal with the right bundle.",
      "ja": "それは次のDATA_SEGMENTメッセージを待たずにLENGTHメッセージを受信する受信機はすぐBUNDLE_REFUSEメッセージを送信することができます。送信者は、このために準備しなければならないと右のバンドルに拒否を関連付ける必要があります。"
    },
    {
      "indent": 0,
      "text": "5.6. KEEPALIVE Feature (KEEPALIVE)",
      "section_title": true,
      "ja": "5.6。キープアライブ機能（KEEPALIVE）"
    },
    {
      "indent": 3,
      "text": "The protocol includes a provision for transmission of KEEPALIVE messages over the TCP connection to help determine if the connection has been disrupted.",
      "ja": "プロトコルは、接続が中断されたかどうかを決定するのに役立つTCP接続でキープアライブメッセージを送信するための条項を含んでいます。"
    },
    {
      "indent": 3,
      "text": "As described in Section 4.1, one of the parameters in the contact header is the keepalive_interval. Both sides populate this field with their requested intervals (in seconds) between KEEPALIVE messages.",
      "ja": "セクション4.1で説明したように、コンタクトヘッダのパラメータの一つはkeepalive_intervalあります。双方は、キープアライブメッセージ間（秒）自分の要求された間隔で、このフィールドを移入します。"
    },
    {
      "indent": 3,
      "text": "The format of a KEEPALIVE message is a one-byte message type code of KEEPALIVE (as described in Table 2) with no additional data. Both sides SHOULD send a KEEPALIVE message whenever the negotiated interval has elapsed with no transmission of any message (KEEPALIVE or other).",
      "ja": "KEEPALIVEメッセージのフォーマットは、追加データとKEEPALIVEの1バイトのメッセージタイプコード（表2に記載）です。ネゴシエートされた間隔は、任意のメッセージ（KEEPALIVEまたは他の）のない送信に経過するたび両側キープアライブメッセージを送信すべきです。"
    },
    {
      "indent": 3,
      "text": "If no message (KEEPALIVE or other) has been received for at least twice the keepalive_interval, then either party MAY terminate the session by transmitting a one-byte SHUTDOWN message (as described in Table 2) and by closing the TCP connection.",
      "ja": "いかなるメッセージ（KEEPALIVEまたは他の）は少なくとも二回keepalive_intervalのために受信されていない場合、いずれかの当事者は、TCPコネクションを閉じることにより（表2に記載したように）1バイトのSHUTDOWNメッセージを送信することによってセッションを終了することができます。"
    },
    {
      "indent": 3,
      "text": "Note: The keepalive_interval should not be chosen too short as TCP retransmissions may occur in case of packet loss. Those will have to be triggered by a timeout (TCP retransmission timeout (RTO)), which is dependent on the measured RTT for the TCP connection so that KEEPALIVE messages may experience noticeable latency.",
      "ja": "注意：TCP再送信は、パケット損失の場合に起こり得るようなkeepalive_intervalが短すぎる選択すべきではありません。これらは、キープアライブメッセージが目立った遅延を経験することができるようにTCP接続のための測定されたRTTに依存しているタイムアウト（TCPの再送タイムアウト（RTO））によって起動する必要があります。"
    },
    {
      "indent": 0,
      "text": "6. Connection Termination",
      "section_title": true,
      "ja": "6.接続終了"
    },
    {
      "indent": 3,
      "text": "This section describes the procedures for ending a TCPCL connection.",
      "ja": "このセクションでは、TCPCL接続を終了するための手順を説明します。"
    },
    {
      "indent": 0,
      "text": "6.1. Shutdown Message (SHUTDOWN)",
      "section_title": true,
      "ja": "6.1。シャットダウンメッセージ（SHUTDOWN）"
    },
    {
      "indent": 3,
      "text": "To cleanly shut down a connection, a SHUTDOWN message MUST be transmitted by either node at any point following complete transmission of any other message. In case acknowledgments have been negotiated, a node SHOULD acknowledge all received data segments first and then shut down the connection.",
      "ja": "きれいな接続をシャットダウンするために、SHUTDOWNメッセージが他のメッセージの送信完了後の任意の時点でいずれかのノードによって送信されなければなりません。場合に肯定応答がネゴシエートされている、ノードはまず、受信したデータ・セグメントを確認し、接続を停止すべきです。"
    },
    {
      "indent": 3,
      "text": "The format of the SHUTDOWN message is as follows:",
      "ja": "次のようにSHUTDOWNメッセージの形式は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "                     1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  0x5  |0|0|R|D| reason (opt)  | reconnection delay (opt)      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 15,
      "text": "Figure 9: Format of Bundle SHUTDOWN Messages",
      "ja": "図9：バンドルSHUTDOWNメッセージのフォーマット"
    },
    {
      "indent": 3,
      "text": "It is possible for a node to convey additional information regarding the reason for connection termination. To do so, the node MUST set the 'R' bit in the message header flags and transmit a one-byte reason code immediately following the message header. The specified values of the reason code are:",
      "ja": "ノードが接続終了の原因に関する追加情報を伝えることが可能です。そうするために、ノードは、メッセージヘッダのフラグに「R」ビットをセットし、直ちにメッセージヘッダーを次の1バイトの理由コードを送信しなければなりません。理由コードの指定された値は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "+-----------+------------------+------------------------------------+\n|    Code   | Meaning          | Description                        |\n+-----------+------------------+------------------------------------+\n|    0x00   | Idle timeout     | The connection is being closed due |\n|           |                  | to idleness.                       |\n|           |                  |                                    |\n|    0x01   | Version mismatch | The node cannot conform to the     |\n|           |                  | specified TCPCL protocol version.  |\n|           |                  |                                    |\n|    0x02   | Busy             | The node is too busy to handle the |\n|           |                  | current connection.                |\n|           |                  |                                    |\n| 0x03-0xff |                  | Unassigned.                        |\n+-----------+------------------+------------------------------------+",
      "raw": true
    },
    {
      "indent": 22,
      "text": "Table 4: SHUTDOWN Reason Codes",
      "ja": "表4：SHUTDOWN理由コード"
    },
    {
      "indent": 3,
      "text": "It is also possible to convey a requested reconnection delay to indicate how long the other node must wait before attempting connection re-establishment. To do so, the node sets the 'D' bit in the message header flags and then transmits an SDNV specifying the requested delay, in seconds, following the message header (and optionally, the SHUTDOWN reason code). The value 0 SHALL be interpreted as an infinite delay, i.e., that the connecting node MUST NOT re-establish the connection. In contrast, if the node does not wish to request a delay, it SHOULD omit the reconnection delay field (and set the 'D' bit to zero). Note that in the figure above, the reconnection delay SDNV is represented as a two-byte field for convenience.",
      "ja": "他のノードが再確立接続を試みる前に待機する必要がありますどのくらいの時間を示すために要求された再接続遅延を伝えることも可能です。そうするために、ノードは、メッセージヘッダのフラグに「D」ビットを設定し、メッセージ・ヘッダーを次の秒で、要求された遅延を指定SDNVを送信する（および必要に応じて、SHUTDOWN理由コード）。値0は、接続ノードが接続を再確立してはいけませんことが無限の遅延、即ち、として解釈されるものとします。ノード遅延を要求することを望まない場合は対照的に、それは再接続遅延フィールドを省略すべきである（ゼロに「D」ビットをセット）。上図において、再接続遅延SDNVは便宜のための2つのバイトのフィールドとして表現されることに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "A connection shutdown MAY occur immediately after TCP connection establishment or reception of a contact header (and prior to any further data exchange). This may, for example, be used to notify that the node is currently not able or willing to communicate. However, a node MUST always send the contact header to its peer before sending a SHUTDOWN message.",
      "ja": "接続シャットダウンは直ちにTCP接続確立又は受信Contactヘッダの（前の任意のさらなるデータ交換に）後に行うことができます。これは、例えば、ノードが現在可能または通信する意思がないことを通知するために使用されてもよいです。しかし、ノードは常にSHUTDOWNメッセージを送信する前に、そのピアにContactヘッダを送らなければなりません。"
    },
    {
      "indent": 3,
      "text": "If either node terminates a connection prematurely in this manner, it SHOULD send a SHUTDOWN message and MUST indicate a reason code unless the incoming connection did not include the magic string. If a node does not want its peer to reopen the connection immediately, it SHOULD set the 'D' bit in the flags and include a reconnection delay to indicate when the peer is allowed to attempt another connection setup.",
      "ja": "いずれかのノードは、このように途中で接続が終了した場合は、SHUTDOWNメッセージを送るべきであると、着信接続が魔法の文字列が含まれていなかった場合を除き、理由コードを指定する必要があります。ノードはそのピアがすぐに接続を再開したくない場合は、フラグに「D」ビットを設定し、ピアは、別の接続設定を試みることが許可されているときを示すために再接続遅延を含むべきです。"
    },
    {
      "indent": 3,
      "text": "If a connection is to be terminated before another protocol message has completed, then the node MUST NOT transmit the SHUTDOWN message but still SHOULD close the TCP connection. In particular, if the connection is to be closed (for whatever reason) while a node is in the process of transmitting a bundle data segment, the receiving node is still expecting segment data and might erroneously interpret the SHUTDOWN message to be part of the data segment.",
      "ja": "接続は、別のプロトコルメッセージが完了する前に終了する場合は、そのノードは、SHUTDOWNメッセージを送信してはならないが、まだTCP接続を閉じる必要があります。具体的には、接続は、ノードがバンドルデータセグメントを送信するプロセスにある間に、受信ノードは依然としてセグメントデータを期待して（何らかの理由で）閉鎖されるべきであり、誤ったデータの一部であることがSHUTDOWNメッセージを解釈する可能性がある場合セグメント。"
    },
    {
      "indent": 0,
      "text": "6.2. Idle Connection Shutdown",
      "section_title": true,
      "ja": "6.2。アイドル接続のシャットダウン"
    },
    {
      "indent": 3,
      "text": "The protocol includes a provision for clean shutdown of idle TCP connections. Determining the length of time to wait before closing idle connections, if they are to be closed at all, is an implementation and configuration matter.",
      "ja": "プロトコルは、アイドル状態のTCP接続のクリーンシャットダウンのための引当金を含んでいます。彼らはすべてで閉じられるようにしている場合は、アイドル状態の接続を閉じる前に待機する時間の長さを決定し、実装と構成の問題です。"
    },
    {
      "indent": 3,
      "text": "If there is a configured time to close idle links and if no bundle data (other than KEEPALIVE messages) has been received for at least that amount of time, then either node MAY terminate the connection by transmitting a SHUTDOWN message indicating the reason code of 'Idle timeout' (as described in Table 4). After receiving a SHUTDOWN message in response, both sides may close the TCP connection.",
      "ja": "構成されたアイドル状態のリンクを閉じるための時間と（キープアライブメッセージ以外）は、バンドルデータは時間の少なくともその量のために受信されていない場合、そのノードのいずれかが 'の理由コードを示すSHUTDOWNメッセージを送信することによって接続を終了することがある場合（表4に記載されているように）アイドルタイムアウト」。応答してSHUTDOWNメッセージを受信した後、両側は、TCP接続を閉じることができます。"
    },
    {
      "indent": 0,
      "text": "7. Security Considerations",
      "section_title": true,
      "ja": "7.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "One security consideration for this protocol relates to the fact that nodes present their endpoint identifier as part of the connection header exchange. It would be possible for a node to fake this value and present the identity of a singleton endpoint in which the node is not a member, essentially masquerading as another DTN node. If this identifier is used without further verification as a means to determine which bundles are transmitted over the connection, then the node that has falsified its identity may be able to obtain bundles that it should not have. Therefore, a node SHALL NOT use the endpoint identifier conveyed in the TCPCL connection message to derive a peer node's identity unless it can ascertain it via other means.",
      "ja": "このプロトコルの一つのセキュリティの考慮事項は、接続ヘッダ交換の一部としてのエンドポイント識別子を提示ノード事実に関する。それは偽のノードは、この値のために可能であると本質的に別のDTNノードになりすまし、ノードがメンバではないであるシングルトンエンドポイントのアイデンティティを提示するであろう。この識別子は、接続を介して送信されたバンドルを決定するための手段としてさらに検証なしに使用されている場合は、そのアイデンティティを改竄したノードは、それが持つべきではない束を得ることができるかもしれません。それは他の手段を介してそれを確認することができる場合を除きしたがって、ノードは、ピア・ノードのアイデンティティを導出するTCPCL接続メッセージで搬送エンドポイント識別子を使用してはなりません。"
    },
    {
      "indent": 3,
      "text": "These concerns may be mitigated through the use of the Bundle Security Protocol [RFC6257]. In particular, the Bundle Authentication Block defines mechanism for secure exchange of bundles between DTN nodes. Thus, an implementation could delay trusting the presented endpoint identifier until the node can securely validate that its peer is in fact the only member of the given singleton endpoint.",
      "ja": "これらの懸念は、バンドルのセキュリティプロトコル[RFC6257]を使用することによって緩和することができます。特に、バンドル認証ブロックは、DTNノード間のバンドルを安全に交換するためのメカニズムを定義します。したがって、実装は、ノードが確実にそのピアが実際に与えられたシングルトンエンドポイントの唯一のメンバーであることを確認できるまで提示エンドポイント識別子を信頼遅らせることができました。"
    },
    {
      "indent": 3,
      "text": "In general, TCPCL does not provide any security services. The mechanisms defined in [RFC6257] are to be used instead.",
      "ja": "一般的には、TCPCLは、任意のセキュリティサービスを提供していません。 [RFC6257]で定義されたメカニズムが代わりに使用されます。"
    },
    {
      "indent": 3,
      "text": "Nothing in TCPCL prevents the use of the Transport Layer Security (TLS) protocol [RFC5246] to secure a connection.",
      "ja": "TCPCLには何も接続を確保するためのトランスポート層セキュリティ（TLS）プロトコル[RFC5246]の使用を妨げません。"
    },
    {
      "indent": 3,
      "text": "Another consideration for this protocol relates to denial-of-service attacks. A node may send a large amount of data over a TCP connection, requiring the receiving node to handle the data, attempt to stop the flood of data by sending a REFUSE_BUNDLE message, or forcibly terminate the connection. This burden could cause denial of service on other, well-behaving connections. There is also nothing to prevent a malicious node from continually establishing connections and repeatedly trying to send copious amounts of bundle data. A listening node MAY take countermeasures such as ignoring TCP SYN messages, closing TCP connections as soon as they are established, waiting before sending the contact header, sending a SHUTDOWN message quickly or with a delay, etc.",
      "ja": "このプロトコルのためのもう1つの考慮事項は、サービス拒否攻撃に関するものです。ノードは、データを処理REFUSE_BUNDLEメッセージを送信することによってデータの洪水を停止、または強制接続を終了しようとする受信ノードを必要とする、TCP接続を介して大量のデータを送信することができます。この負担は、他の、よく振る舞う接続でサービス拒否を引き起こす可能性があります。継続的な接続を確立し、繰り返しバンドルデータの大量を送信しようとしているから、悪意のあるノードを防ぐために何もありません。リスニングノードはなど、TCP SYNメッセージを無視するとすぐにそれらが確立されると、TCP接続を閉じて、接触ヘッダを送信する前に待機して、迅速または遅延でSHUTDOWNメッセージを送信するなどの対策をとることができ"
    },
    {
      "indent": 0,
      "text": "8. IANA Considerations",
      "section_title": true,
      "ja": "8. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "In this section, registration procedures are as defined in [RFC5226].",
      "ja": "このセクションでは、登録手続きは、[RFC5226]で定義される通りです。"
    },
    {
      "indent": 0,
      "text": "8.1. Port Number",
      "section_title": true,
      "ja": "8.1。ポート番号"
    },
    {
      "indent": 3,
      "text": "Port number 4556 has been assigned as the default port for the TCP convergence layer.",
      "ja": "ポート番号4556は、TCPの収束層のデフォルトポートとして割り当てられています。"
    },
    {
      "indent": 3,
      "text": "Service Name: dtn-bundle",
      "ja": "サービス名：DTN-バンドル"
    },
    {
      "indent": 3,
      "text": "Transport Protocol(s): TCP",
      "ja": "トランスポートプロトコル（S）：TCP"
    },
    {
      "indent": 3,
      "text": "Assignee: Simon Perreault <simon@per.reau.lt>",
      "ja": "譲受人：サイモン・ペロー<simon@per.reau.lt>"
    },
    {
      "indent": 3,
      "text": "Contact: Simon Perreault <simon@per.reau.lt>",
      "ja": "連絡先：サイモン・ペロー<simon@per.reau.lt>"
    },
    {
      "indent": 3,
      "text": "Description: DTN Bundle TCP CL Protocol",
      "ja": "説明：DTNバンドルTCPプロトコルCL"
    },
    {
      "indent": 3,
      "text": "Reference: [RFC7242]",
      "ja": "参考：[RFC7242]"
    },
    {
      "indent": 3,
      "text": "Port Number: 4556",
      "ja": "ポート番号：4556"
    },
    {
      "indent": 0,
      "text": "8.2. Protocol Versions",
      "section_title": true,
      "ja": "8.2。プロトコルのバージョン"
    },
    {
      "indent": 3,
      "text": "IANA has created, under the \"Bundle Protocol\" registry, a sub-registry titled \"Bundle Protocol TCP Convergence-Layer Version Numbers\" and initialized it with the following:",
      "ja": "IANAは、「バンドル議定書」のレジストリの下に、サブレジストリは「バンドルプロトコルTCPコンバージェンスレイヤのバージョン番号を」というタイトルを作成し、次でそれを初期化しています："
    },
    {
      "indent": 20,
      "text": "+-------+-------------+-----------+\n| Value | Description | Reference |\n+-------+-------------+-----------+\n|   0   | Reserved    | [RFC7242] |\n|   1   | Reserved    | [RFC7242] |\n|   2   | Reserved    | [RFC7242] |\n|   3   | TCPCL       | [RFC7242] |\n| 4-255 | Unassigned  | [RFC7242] |\n+-------+-------------+-----------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The registration procedure is RFC Required.",
      "ja": "登録手続きはRFC必要です。"
    },
    {
      "indent": 0,
      "text": "8.3. Message Types",
      "section_title": true,
      "ja": "8.3。メッセージタイプ"
    },
    {
      "indent": 3,
      "text": "IANA has created, under the \"Bundle Protocol\" registry, a sub-registry titled \"Bundle Protocol TCP Convergence-Layer Message Types\" and initialized it with the contents of Table 2. The registration procedure is RFC Required.",
      "ja": "IANAは、「バンドル議定書」のレジストリの下に、サブレジストリ名称「バンドルプロトコルTCPコンバージェンスレイヤメッセージのタイプ」を作成し、登録手続き2.表の内容とそれを初期化したRFC必要です。"
    },
    {
      "indent": 0,
      "text": "8.4. REFUSE_BUNDLE Reason Codes",
      "section_title": true,
      "ja": "8.4。 REFUSE_BUNDLE理由コード"
    },
    {
      "indent": 3,
      "text": "IANA has created, under the \"Bundle Protocol\" registry, a sub-registry titled \"Bundle Protocol TCP Convergence-Layer REFUSE_BUNDLE Reason Codes\" and initialized it with the contents of Table 3. The registration procedure is RFC Required.",
      "ja": "IANAは、「バンドル議定書」のレジストリの下に、サブレジストリ名称「バンドルプロトコルTCPコンバージェンスレイヤREFUSE_BUNDLE理由コード」を作成し、登録手続き3.表の内容とそれを初期化したRFC必要です。"
    },
    {
      "indent": 0,
      "text": "8.5. SHUTDOWN Reason Codes",
      "section_title": true,
      "ja": "8.5。 SHUTDOWN理由コード"
    },
    {
      "indent": 3,
      "text": "IANA has created, under the \"Bundle Protocol\" registry, a sub-registry titled \"Bundle Protocol TCP Convergence-Layer SHUTDOWN Reason Codes\" and initialized it with the contents of Table 4. The registration procedure is RFC Required.",
      "ja": "IANAは、「バンドル議定書」のレジストリの下に、サブレジストリ名称「バンドルプロトコルTCPコンバージェンスレイヤSHUTDOWN理由コード」を作成し、登録手続き4.表の内容とそれを初期化したRFC必要です。"
    },
    {
      "indent": 0,
      "text": "9. Acknowledgments",
      "section_title": true,
      "ja": "9.謝辞"
    },
    {
      "indent": 3,
      "text": "The authors would like to thank the following individuals who have participated in the drafting, review, and discussion of this memo: Alex McMahon, Brenton Walker, Darren Long, Dirk Kutscher, Elwyn Davies, Jean-Philippe Dionne, Joseph Ishac, Keith Scott, Kevin Fall, Lloyd Wood, Marc Blanchet, Peter Lovell, Scott Burleigh, Stephen Farrell, Vint Cerf, and William Ivancic.",
      "ja": "アレックス・マクマホン、ブレントン・ウォーカー、ダレン・ロング、ディルクKutscher、エルウィン・デイヴィス、ジャン=フィリップ・ディオンヌ、ジョセフIshac、キース・スコット、著者らは、起草、審査、およびこのメモの議論に参加した以下の個人に感謝したいと思いますケビン・秋、ロイド・ウッド、マーク・ブランシェ、ピーター・ラヴェル、スコット・バーレイ、スティーブン・ファレル、ヴィントン・サーフ、そしてウィリアムIvancic。"
    },
    {
      "indent": 0,
      "text": "10. References",
      "section_title": true,
      "ja": "10.参考文献"
    },
    {
      "indent": 0,
      "text": "10.1. Normative References",
      "section_title": true,
      "ja": "10.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC5050] Scott, K. and S. Burleigh, \"Bundle Protocol Specification\", RFC 5050, November 2007.",
      "ja": "[RFC5050]スコット、K.およびS.バーリー、 \"バンドルプロトコル仕様\"、RFC 5050、2007年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC5226] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 5226, May 2008.",
      "ja": "[RFC5226] Narten氏、T.とH. Alvestrand、 \"RFCsにIANA問題部に書くためのガイドライン\"、BCP 26、RFC 5226、2008年5月。"
    },
    {
      "indent": 0,
      "text": "10.2. Informative References",
      "section_title": true,
      "ja": "10.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[DTNIMPL] DTNRG, \"Delay-Tolerant Networking Reference Implementation\", <https://sites.google.com/site/ dtnresgroup/home/code>.",
      "ja": "[DTNIMPL] DTNRG、 \"遅延耐性ネットワークリファレンス実装\"、<https://sites.google.com/site/ dtnresgroup /ホーム/コード>。"
    },
    {
      "indent": 3,
      "text": "[RFC4838] Cerf, V., Burleigh, S., Hooke, A., Torgerson, L., Durst, R., Scott, K., Fall, K., and H. Weiss, \"Delay-Tolerant Networking Architecture\", RFC 4838, April 2007.",
      "ja": "[RFC4838]サーフ、V.、バーレイ、S.、フック、A.、Torgerson、L.、ダースト、R.、スコット、K.、秋、K.、およびH.ワイス、 \"遅延耐性ネットワークアーキテクチャ\" 、RFC 4838、2007年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC5246] Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS) Protocol Version 1.2\", RFC 5246, August 2008.",
      "ja": "[RFC5246]ダークス、T.およびE.レスコラ、 \"トランスポート層セキュリティ（TLS）プロトコルバージョン1.2\"、RFC 5246、2008年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC6256] Eddy, W. and E. Davies, \"Using Self-Delimiting Numeric Values in Protocols\", RFC 6256, May 2011.",
      "ja": "[RFC6256]エディ、W.およびE.デイヴィス、 \"プロトコルにおける自己区切りの数値の値を使用\"、RFC 6256、2011年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC6257] Symington, S., Farrell, S., Weiss, H., and P. Lovell, \"Bundle Security Protocol Specification\", RFC 6257, May 2011.",
      "ja": "[RFC6257]シミントン、S.、ファレル、S.、ワイス、H.、およびP.ラヴェル、 \"バンドルセキュリティプロトコル仕様\"、RFC 6257、2011年5月。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Michael J. Demmer University of California, Berkeley Computer Science Division 445 Soda Hall Berkeley, CA 94720-1776 US",
      "ja": "カリフォルニアのマイケル・J. Demmer大学バークレー校コンピュータサイエンス部門445ソーダホールバークレー、CA 94720から1776米"
    },
    {
      "indent": 3,
      "text": "EMail: demmer@cs.berkeley.edu",
      "ja": "メールアドレス：demmer@cs.berkeley.edu"
    },
    {
      "indent": 3,
      "text": "Joerg Ott Aalto University Department of Communications and Networking PO Box 13000 AALTO 02015 Finland",
      "ja": "コミュニケーションのイェルクオットアアルト大学学部およびネットワーキング私書箱13000 AALTO 02015フィンランド"
    },
    {
      "indent": 3,
      "text": "EMail: jo@netlab.tkk.fi",
      "ja": "メールアドレス：jo@netlab.tkk.fi"
    },
    {
      "indent": 3,
      "text": "Simon Perreault Quebec, QC Canada",
      "ja": "サイモン・ペローケベック、QCカナダ"
    },
    {
      "indent": 3,
      "text": "EMail: simon@per.reau.lt",
      "ja": "メールアドレス：simon@per.reau.lt"
    }
  ]
}