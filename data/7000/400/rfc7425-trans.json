{
  "title": {
    "text": "RFC 7425 - Adobe's RTMFP Profile for Flash Communication",
    "ja": "RFC 7425 - フラッシュ・コミュニケーションのためのAdobeのRTMFPプロフィール"
  },
  "number": 7425,
  "created_at": "2019-11-02 00:07:19.754610+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Independent Submission                                     M. Thornburgh\nRequest for Comments: 7425                                         Adobe\nCategory: Informational                                    December 2014\nISSN: 2070-1721",
      "raw": true
    },
    {
      "indent": 13,
      "text": "Adobe's RTMFP Profile for Flash Communication",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This memo describes how to use Adobe's Secure Real-Time Media Flow Protocol (RTMFP) to transport the video, audio, and data messages of Adobe Flash platform communications. Aspects of this application profile include cryptographic methods and data formats, flow metadata formats, and protocol details for client-server and peer-to-peer communication.",
      "ja": "このメモには、Adobe Flashプラットフォーム通信のビデオ、オーディオ、およびデータメッセージを転送するには、Adobeのセキュアリアルタイムメディアフロープロトコル（RTMFP）を使用する方法について説明します。このアプリケーションプロファイルの側面は、クライアント・サーバとピア・ツー・ピア通信のための暗号化方法およびデータフォーマット、フローメタデータフォーマット、及びプロトコルの詳細を含みます。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "ja": "このドキュメントはインターネット標準化過程仕様ではありません。それは、情報提供の目的のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This is a contribution to the RFC Series, independently of any other RFC stream. The RFC Editor has chosen to publish this document at its discretion and makes no statement about its value for implementation or deployment. Documents approved for publication by the RFC Editor are not a candidate for any level of Internet Standard; see Section 2 of RFC 5741.",
      "ja": "これは、独立して、他のRFCストリームの、RFCシリーズへの貢献です。 RFC Editorはその裁量でこの文書を公開することを選択し、実装や展開のためにその値についての声明を出すていません。 RFC編集者によって公表のために承認されたドキュメントは、インターネット標準の任意のレベルの候補ではありません。 RFC 5741のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7425.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7425で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2014 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2014 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。"
    },
    {
      "indent": 3,
      "text": "This document may not be modified, and derivative works of it may not be created, except to format it for publication as an RFC or to translate it into languages other than English.",
      "ja": "RFCとして公表のためにそれをフォーマットしたり、英語以外の言語に翻訳することを除いて、このドキュメントは変更されないことがあり、それの派生作品が作成されないことがあります。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................3\n2. Terminology .....................................................4\n3. Common Syntax Elements ..........................................4\n4. Cryptography Profile ............................................5\n   4.1. Default Session Key ........................................5\n   4.2. Diffie-Hellman Groups ......................................6\n   4.3. Certificates ...............................................6\n        4.3.1. Format ..............................................6\n        4.3.2. Fingerprint .........................................7\n        4.3.3. Options .............................................7\n               4.3.3.1. Hostname ...................................8\n               4.3.3.2. Accepts Ancillary Data .....................8\n               4.3.3.3. Extra Randomness ...........................8\n               4.3.3.4. Supported Ephemeral Diffie-Hellman Group ...9\n               4.3.3.5. Static Diffie-Hellman Public Key ...........9\n        4.3.4. Authenticity .......................................10\n        4.3.5. Signing and Verifying Messages .....................10\n               4.3.5.1. Options ...................................11\n                        4.3.5.1.1. Simple Password ................11\n        4.3.6. Glare Resolution ...................................13\n        4.3.7. Session Override ...................................13\n   4.4. Endpoint Discriminators ...................................13\n        4.4.1. Format .............................................14\n        4.4.2. Options ............................................14\n               4.4.2.1. Required Hostname .........................15\n               4.4.2.2. Ancillary Data ............................15\n               4.4.2.3. Fingerprint ...............................16\n        4.4.3. Certificate Selection ..............................16\n        4.4.4. Canonical Endpoint Discriminator ...................17\n   4.5. Session Keying Components .................................18\n        4.5.1. Format .............................................19\n        4.5.2. Options ............................................19\n               4.5.2.1. Ephemeral Diffie-Hellman Public Key .......20\n               4.5.2.2. Extra Randomness ..........................20\n               4.5.2.3. Diffie-Hellman Group Select ...............21\n               4.5.2.4. HMAC Negotiation ..........................21\n               4.5.2.5. Session Sequence Number Negotiation .......22\n   4.6. Session Key Computation ...................................23\n        4.6.1. Public Key Selection ...............................23\n               4.6.1.1. Initiator and Responder Ephemeral .........23\n               4.6.1.2. Initiator Ephemeral and Responder Static ..23\n               4.6.1.3. Initiator Static and Responder Ephemeral ..24\n               4.6.1.4. Initiator and Responder Static ............24\n        4.6.2. Diffie-Hellman Shared Secret .......................24\n        4.6.3. Packet Encrypt/Decrypt Keys ........................25\n        4.6.4. Packet HMAC Send/Receive Keys ......................25",
      "raw": true
    },
    {
      "indent": 3,
      "text": "        4.6.5. Session Nonces .....................................26\n        4.6.6. Session Sequence Number ............................26\n   4.7. Packet Encryption .........................................27\n        4.7.1. Cipher .............................................27\n        4.7.2. Format .............................................27\n        4.7.3. Verification .......................................29\n               4.7.3.1. Simple Checksum ...........................30\n               4.7.3.2. HMAC ......................................30\n               4.7.3.3. Session Sequence Number ...................31\n5. Flash Communication ............................................31\n   5.1. RTMP Messages .............................................31\n        5.1.1. Flow Metadata ......................................32\n        5.1.2. Message Mapping ....................................34\n   5.2. Flow Synchronization ......................................35\n   5.3. Client-to-Server Connection ...............................36\n        5.3.1. Connecting .........................................36\n        5.3.2. Server-to-Client Return Control Flow ...............37\n        5.3.3. setPeerInfo Command ................................37\n        5.3.4. Set Keepalive Timers Command .......................39\n        5.3.5. Additional Flows for Streams .......................40\n               5.3.5.1. To Server .................................40\n               5.3.5.2. From Server ...............................40\n               5.3.5.3. Closing Stream Flows ......................41\n        5.3.6. Closing the Connection .............................41\n        5.3.7. Example ............................................42\n   5.4. Direct Peer-to-Peer Streams ...............................43\n        5.4.1. Connecting .........................................43\n        5.4.2. Return Flows for Stream ............................43\n        5.4.3. Closing the Connection .............................44\n6. IANA Considerations ............................................44\n   6.1. RTMFP URI Scheme Registration .............................44\n7. Security Considerations ........................................46\n8. References .....................................................47\n   8.1. Normative References ......................................47\n   8.2. Informative References ....................................49\nAcknowledgements ..................................................49\nAuthor's Address ..................................................49",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "Adobe's Secure Real-Time Media Flow Protocol (RTMFP) [RFC7016] is a general-purpose transport service for real-time media and bulk data in IP networks, and it is suited to client-server and peer-to-peer (P2P) communication. RTMFP provides a generalized framework for securing its communications according to the needs of its application.",
      "ja": "Adobeのセキュアリアルタイムメディアフロープロトコル（RTMFP）[RFC7016]はリアルタイムメディアおよびIPネットワークにおけるバルク・データのための汎用的な輸送サービスであり、そしてそれは、クライアント - サーバおよびピア・ツー・ピア（P2P）に適していますコミュニケーション。 RTMFPは、そのアプリケーションのニーズに応じて、その通信を保護するための一般的なフレームワークを提供します。"
    },
    {
      "indent": 3,
      "text": "The Flash platform comprises the Flash runtime (including Flash Player) from Adobe Systems Incorporated, communication servers such as Adobe Media Server, and interoperable clients and servers provided by other parties.",
      "ja": "フラッシュプラットフォームは、Adobe Systems Incorporated（アドビシステムズ社）、などのAdobeメディアサーバー、および他の関係者が提供する相互運用可能クライアントとサーバの通信サーバから（Flash Playerを含む）のFlashランタイムを備えます。"
    },
    {
      "indent": 3,
      "text": "Real-time streaming network communication for the Flash platform of video, audio, and data typically uses Adobe's Real-Time Messaging Protocol (RTMP) [RTMP] messages. RTMP messages were originally designed to be transported over RTMP Chunk Stream in TCP [RTMP]; however, other transports (such as the one described in this memo) are possible.",
      "ja": "ビデオ、オーディオ、およびデータのフラッシュ・プラットフォームのためのリアルタイムストリーミングネットワーク通信は通常、アドビシステムズ社のリアルタイムメッセージングプロトコル（RTMP）[RTMP]のメッセージを使用しています。 RTMPメッセージは、もともとTCP [RTMP]でRTMPチャンクストリーム上で転送されるように設計されました。しかしながら、（例えば、このメモに記載のもののような）他のトランスポートが可能です。"
    },
    {
      "indent": 3,
      "text": "This memo specifies the syntax and semantics for transporting RTMP messages over RTMFP, and it extends Flash communication semantics to include direct P2P communication. This memo further specifies a concrete Cryptography Profile for RTMFP tailored to the application and cryptographic needs of Flash platform client-server and P2P communications.",
      "ja": "このメモは、RTMFP上でRTMPメッセージを輸送するための構文とセマンティクスを指定し、それが直接P2P通信を含めるようにフラッシュ通信セマンティクスを拡張します。このメモは、さらにアプリケーションとFlashプラットフォームのクライアント - サーバーとP2P通信の暗号化ニーズに合わせたRTMFPのための具体的な暗号化プロファイルを指定します。"
    },
    {
      "indent": 3,
      "text": "These protocols and profiles were developed by Adobe Systems Incorporated and are not the product of an IETF activity.",
      "ja": "これらのプロトコルとプロファイルは、Adobe Systems Incorporated（アドビシステムズ社）によって開発され、IETF活動の産物ではありませんました。"
    },
    {
      "indent": 0,
      "text": "2. Terminology",
      "section_title": true,
      "ja": "2.用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "キーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、 \"SHALL\"、 \"SHOULD\"、 \"ないもの\"、 \"推奨\" \"ない（SHOULD NOT）\"、 \"MAY\"、 \"推奨NOT\"、および「OPTIONAL 「本書では[RFC2119]で説明されるように解釈されるべきです。"
    },
    {
      "indent": 3,
      "text": "\"HMAC\" means the Keyed-Hash Message Authentication Code (HMAC) algorithm [RFC2104].",
      "ja": "「HMAC」は、鍵付きハッシュメッセージ認証コード（HMAC）アルゴリズム[RFC2104]を意味します。"
    },
    {
      "indent": 3,
      "text": "\"HMAC-SHA256\" means HMAC using the SHA-256 Secure Hash Algorithm [SHA256] [RFC6234].",
      "ja": "\"HMAC-SHA256\" SHA256セキュアハッシュアルゴリズム[SHA256] [RFC6234]を使用して、HMACを意味します。"
    },
    {
      "indent": 3,
      "text": "\"HMAC-SHA256(K, M)\" means the calculation of the HMAC-SHA256 of message M using key K.",
      "ja": "\"HMAC-SHA256（K、M）\" は鍵Kを使用してメッセージMのHMAC-SHA256の算出手段"
    },
    {
      "indent": 0,
      "text": "3. Common Syntax Elements",
      "section_title": true,
      "ja": "3.一般的な構文の要素"
    },
    {
      "indent": 3,
      "text": "Definitions of types and structures in this specification use traditional text diagrams paired with procedural descriptions using a C-like syntax. The C-like procedural descriptions SHALL be construed as definitive.",
      "ja": "本明細書における種類や構造の定義は、Cに似た構文を使用して、手続きの記述とペアになって、伝統的なテキスト・ダイアグラムを使用しています。 C-ような手続き記述は決定的なものと解釈されるものとする（SHALL）。"
    },
    {
      "indent": 3,
      "text": "Structures are packed to take only as many bytes as explicitly indicated. There is no 32-bit alignment constraint, and fields are not padded for alignment unless explicitly indicated or described. Text diagrams may include a bit ruler across the top; this is a convenience for counting bits in individual fields and does not necessarily imply field alignment on a multiple of the ruler width.",
      "ja": "構造はとして明示的に示されているだけのように多くのバイトを取るためにパックされています。そこには、32ビットのアライメント制約はなく、明示又は記載されない限りフィールドは、位置合わせのために埋め込まれていません。テキスト図は、上部にビット定規を含むことができます。これは、個々のフィールド内のビットをカウントするための便宜であり、必ずしも定規幅の複数のフィールドの配置を意味するものではありません。"
    },
    {
      "indent": 3,
      "text": "Unless specified otherwise, reserved fields SHOULD be set to 0 by a sender and MUST be ignored by a receiver.",
      "ja": "特に指定のない限り、予約フィールドは、送信者によって0に設定されるべきであり、受信機で無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The procedural syntax of this specification defines correct and error-free encoded inputs to a parser. The procedural syntax does not describe a fully featured parser, including error detection and handling. Implementations MUST include means to identify error circumstances, including truncations causing elementary or composed types not to fit inside containing structures, fields, or elements. Unless specified otherwise, an error circumstance SHALL abort the parsing and processing of an element and its enclosing elements.",
      "ja": "本明細書の手続き構文パーサに正しいとエラーフリー符号化入力を定義します。手続き型構文は、エラー検出および処理を含むフル機能のパーサーを、説明していません。実装は、構造、フィールド、または要素を含む内側にフィットしない基本または構成タイプを引き起こす切断などのエラー状況を識別するための手段を含まなければなりません。特に断らない限り、エラー状況は、要素とその囲み要素の解析および処理を中断します。"
    },
    {
      "indent": 3,
      "text": "This memo uses the elementary and composed types described in Section 2.1 of RFC 7016. The definitions of that section are incorporated by reference as though fully set forth here.",
      "ja": "このメモは、そのセクションの定義が完全にここに記載されているかのように参照により組み込まれるRFC 7016の2.1節で説明した基本となるタイプを使用します。"
    },
    {
      "indent": 0,
      "text": "4. Cryptography Profile",
      "section_title": true,
      "ja": "4.暗号プロフィール"
    },
    {
      "indent": 3,
      "text": "RTMFP defines a general security framework but delegates specifics, such as packet encryption ciphers and key agreement algorithms, to an application-defined Cryptography Profile.",
      "ja": "RTMFPは、アプリケーション定義の暗号プロファイルに、そのようなパケット暗号化方式と鍵合意アルゴリズムとして、一般的なセキュリティフレームワークが、委譲の仕様を規定しています。"
    },
    {
      "indent": 3,
      "text": "This section defines the RTMFP Cryptography Profile for Flash platform communication.",
      "ja": "このセクションでは、Flashプラットフォームの通信のためのRTMFP暗号化プロファイルを定義します。"
    },
    {
      "indent": 0,
      "text": "4.1. Default Session Key",
      "section_title": true,
      "ja": "4.1。セッションキーをデフォルト"
    },
    {
      "indent": 3,
      "text": "RTMFP uses a Default Session Key and associated default cipher configuration during session startup handshaking, where session-specific keys and ciphers are negotiated.",
      "ja": "RTMFPは、セッション固有のキーと暗号がネゴシエートされたセッションの起動ハンドシェイク、時のデフォルトのセッションキーと関連付けられているデフォルトの暗号設定を使用しています。"
    },
    {
      "indent": 3,
      "text": "The default cipher is the Advanced Encryption Standard [AES] with 128-bit keys operating in Cipher Block Chaining [CBC] mode, as described in Section 4.7.1. The Default Session Key is the 16 bytes of the string \"Adobe Systems 02\" encoded in UTF-8 [RFC3629]:",
      "ja": "セクション4.7.1に記載したように、デフォルトの暗号は、暗号ブロック連鎖[CBC]モードで動作する128ビットキーで[AES]高度暗号化標準です。デフォルトのセッションキーは、UTF-8 [RFC3629]でエンコードされた文字列「アドビシステムズ社02」の16バイトです。"
    },
    {
      "indent": 11,
      "text": "Hex: 41 64 6F 62 65 20 53 79 73 74 65 6D 73 20 30 32",
      "ja": "進：41 64 6F 62 65 20 53 79 73 74 65 6D 73 20 30 32"
    },
    {
      "indent": 3,
      "text": "The Default Session Key uses checksum mode for packet verification and does not use session sequence numbers (Section 4.7.3).",
      "ja": "デフォルトのセッションキーは、パケット検証のためのチェックサムモードを使用して、セッションのシーケンス番号（セクション4.7.3）を使用していません。"
    },
    {
      "indent": 0,
      "text": "4.2. Diffie-Hellman Groups",
      "section_title": true,
      "ja": "4.2。 Diffie-Hellmanのグループ"
    },
    {
      "indent": 3,
      "text": "Implementations conforming to this profile MUST support Diffie-Hellman [DH] modular exponentiation (MODP) group 2 (1024 bits) as defined in [RFC7296], and SHOULD support Diffie-Hellman MODP group 5 (1536 bits) and group 14 (2048 bits) as defined in [RFC3526]. Implementations MAY support additional groups.",
      "ja": "このプロファイルに適合する実装は、[RFC7296]で定義されるようにディフィー - ヘルマン[DH]べき乗剰余（MODP）グループ2（1024ビット）をサポートする必要があり、およびDiffie-HellmanのMODPグループ5（1536ビット）をサポートし、グループ14（2048ビットSHOULD ）[RFC3526]で定義されます。実装は、追加のグループをサポートするかもしれません。"
    },
    {
      "indent": 0,
      "text": "4.3. Certificates",
      "section_title": true,
      "ja": "4.3。証明書"
    },
    {
      "indent": 3,
      "text": "This section defines the certificate format for this Cryptography Profile, and the mapping to the abstract properties and semantics for RTMFP endpoint identities.",
      "ja": "このセクションでは、この暗号化プロファイルのための証明書形式、およびRTMFPエンドポイントのアイデンティティのための抽象的性質およびセマンティクスへのマッピングを定義します。"
    },
    {
      "indent": 0,
      "text": "4.3.1. Format",
      "section_title": true,
      "ja": "4.3.1。フォーマット"
    },
    {
      "indent": 3,
      "text": "A certificate in this profile is encoded as a sequence of zero or more RTMFP Options and Markers (Section 2.1.3 of RFC 7016). The first marker (if any) in the certificate separates the canonical section of the certificate from the remainder. Some options are ignored if they occur outside of the canonical section (that is, after the first marker).",
      "ja": "このプロファイルで証明書がゼロ以上RTMFPオプションおよびマーカー（RFC 7016のセクション2.1.3）のシーケンスとして符号化されます。証明書の最初のマーカーは、（もしあれば）残りから証明書の標準セクションを分離します。彼らは標準的なセクション（つまり、最初のマーカーの後に、である）の外で発生した場合、一部のオプションは無視されます。"
    },
    {
      "indent": 3,
      "text": "+~~~/~~~/~~~+   +~~~/~~~/~~~+~~~~~+~~~/~~~/~~~+   +~~~/~~~/~~~+\n| L \\ T \\ V |...| L \\ T \\ V |  0  | L \\ T \\ V |...| L \\ T \\ V |\n+~~~/~~~/~~~+   +~~~/~~~/~~~+~~~~~+~~~/~~~/~~~+   +~~~/~~~/~~~+\n^                           ^  ^  ^                           ^\n|  Zero or more non-empty   |  |  |   Zero or more Options    |\n|         Options           |  |  +------  or Markers  -------+\n|                           |  |\n+---  Canonical Section  ---+  +---- First Marker\n                                     (if present)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct certificate_t\n{\n    canonicalStart = remainder();\n    canonicalEnd = remainder();\n    markerFound = false;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "while(remainder() > 0)\n{\n    option_t option :variable*8;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "    if(0 == option.length)\n        markerFound = true;\n    else if(!markerFound)\n        canonicalEnd = remainder();\n};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "    canonicalSectionLength = canonicalStart - canonicalEnd;\n} :variable*8;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.3.2. Fingerprint",
      "section_title": true,
      "ja": "4.3.2。指紋"
    },
    {
      "indent": 3,
      "text": "A certificate's fingerprint is the SHA-256 hash [SHA256] of the canonical section of the certificate (that is, the hash of the first canonicalSectionLength bytes of the certificate).",
      "ja": "証明書のフィンガープリントは証明書の標準セクションのSHA256ハッシュ[SHA256（つまり、証明書の最初のcanonicalSectionLengthバイトのハッシュである）です。"
    },
    {
      "indent": 3,
      "text": "The certificate's fingerprint is also called the \"peer ID\".",
      "ja": "証明書のフィンガープリントはまた、「ピアID」と呼ばれています。"
    },
    {
      "indent": 0,
      "text": "4.3.3. Options",
      "section_title": true,
      "ja": "4.3.3。オプション"
    },
    {
      "indent": 3,
      "text": "This section lists options that can appear in a certificate. The following option type codes are defined:",
      "ja": "このセクションでは、証明書に表示できるオプションを示します。次のオプション・タイプ・コードが定義されています："
    },
    {
      "indent": 3,
      "text": "0x00: Hostname (must be in canonical section) (Section 4.3.3.1)",
      "ja": "$ 00：ホスト名（正規のセクションでなければなりません）（セクション4.3.3.1）"
    },
    {
      "indent": 3,
      "text": "0x0a: Accepts Ancillary Data (must be in canonical section) (Section 4.3.3.2)",
      "ja": "0x0Aを：補助データ（正規のセクションでなければなりません）（セクション4.3.3.2）を受け入れ"
    },
    {
      "indent": 3,
      "text": "0x0e: Extra Randomness (Section 4.3.3.3)",
      "ja": "0x0Eの：エクストラランダムネス（セクション4.3.3.3）"
    },
    {
      "indent": 3,
      "text": "0x15: Supported Ephemeral Diffie-Hellman Group (must be in canonical section) (Section 4.3.3.4)",
      "ja": "0x15の：サポートされているエフェメラルのDiffie-Hellmanのグループ（正規のセクションでなければなりません）（セクション4.3.3.4）"
    },
    {
      "indent": 3,
      "text": "0x1d: Static Diffie-Hellman Public Key (must be in canonical section) (Section 4.3.3.5)",
      "ja": "0x1Dの：静的のDiffie-Hellman公開鍵（正規のセクションでなければなりません）（セクション4.3.3.5）"
    },
    {
      "indent": 3,
      "text": "An implementation MUST ignore a certificate option type that is not understood.",
      "ja": "実装が理解されていない証明書のオプションタイプを無視しなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.3.3.1. Hostname",
      "section_title": true,
      "ja": "4.3.3.1。ホスト名"
    },
    {
      "indent": 3,
      "text": "This option gives an optional hostname for the endpoint. This option MUST be ignored if is not in the canonical section. This option MUST NOT occur more than once in a certificate.",
      "ja": "このオプションは、エンドポイントのための任意のホスト名を与えます。正規のセクションにない場合、このオプションは無視しなければなりません。このオプションは、証明書で複数回発生してはなりません。"
    },
    {
      "indent": 3,
      "text": "+-------------/-+-------------/-+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+\n|   length    \\ |     0x00    \\ |         hostname              |\n+-------------/-+-------------/-+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct hostnameCertOptionValue_t\n{\n    uint8_t hostname[remainder()];\n} :remainder()*8;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.3.3.2. Accepts Ancillary Data",
      "section_title": true,
      "ja": "4.3.3.2。補助データは受け入れ"
    },
    {
      "indent": 3,
      "text": "This option indicates that the endpoint will accept an Endpoint Discriminator encoding an Ancillary Data option (Section 4.4.2.2). This option MUST be ignored if it is not in the canonical section.",
      "ja": "このオプションは、エンドポイントが補助データオプション（セクション4.4.2.2）をコードするエンドポイント識別子を受け入れることを示しています。それは正規のセクションにない場合、このオプションは無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "+-------------/-+-------------/-+\n|   length    \\ |     0x0a    \\ |\n+-------------/-+-------------/-+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.3.3.3. Extra Randomness",
      "section_title": true,
      "ja": "4.3.3.3。エクストラランダム性"
    },
    {
      "indent": 3,
      "text": "This option can be used to add extra entropy or randomness to a certificate that doesn't have any other cryptographic pseudorandom members (such as a public key). This option is typically used so that endpoints using ephemeral Diffie-Hellman keying can have a unique certificate fingerprint.",
      "ja": "このオプションは、（公開鍵など）、他の暗号擬似乱数メンバーを持っていない証明書に余分なエントロピーやランダム性を追加するために使用することができます。はかないのDiffie-Hellman鍵を使用してエンドポイントが独自の証明書のフィンガープリントを持つことができるように、このオプションは、一般的に使用されています。"
    },
    {
      "indent": 3,
      "text": "+-------------/-+-------------/-+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+\n|   length    \\ |     0x0e    \\ |       extra randomness        |\n+-------------/-+-------------/-+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct extraRandomnessCertOptionValue_t\n{\n    uint_t extraRandomness[remainder()];\n} :remainder()*8;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.3.3.4. Supported Ephemeral Diffie-Hellman Group",
      "section_title": true,
      "ja": "4.3.3.4。サポートされているエフェメラルのDiffie-Hellmanのグループ"
    },
    {
      "indent": 3,
      "text": "This option specifies a Diffie-Hellman group ID that is supported for ephemeral keying. This option MUST be ignored if it is not in the canonical section. This option may occur more than once in the certificate; each instance indicates an additional group that is supported for key agreement.",
      "ja": "このオプションは、一時的なキーイングのためにサポートされているのDiffie-HellmanグループIDを指定します。それは正規のセクションにない場合、このオプションは無視しなければなりません。このオプションは、一度証明書よりも多く発生する可能性があります。各インスタンスは、鍵の合意のためにサポートされている追加のグループを示します。"
    },
    {
      "indent": 3,
      "text": "+-------------/-+-------------/-+-------------/-+\n|   length    \\ |     0x15    \\ |   group ID  \\ |\n+-------------/-+-------------/-+-------------/-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct ephemeralDHGroupCertOptionValue_t\n{\n    vlu_t groupID :variable*8;\n} :variable*8;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The presence of this option means that the certificate uses ephemeral Diffie-Hellman public keys only. The certificate MUST NOT contain a Static Diffie-Hellman public key (Section 4.3.3.5).",
      "ja": "このオプションの存在は証明書のみ短命のDiffie-Hellman公開鍵を使用することを意味します。証明書は、静的のDiffie-Hellman公開鍵（セクション4.3.3.5）を含めることはできません。"
    },
    {
      "indent": 0,
      "text": "4.3.3.5. Static Diffie-Hellman Public Key",
      "section_title": true,
      "ja": "4.3.3.5。静電気のDiffie-Hellman公開鍵"
    },
    {
      "indent": 3,
      "text": "This option specifies a Diffie-Hellman group ID and static public key in that group. This option MUST be ignored if it is not in the canonical section. This option MAY occur more than once in the certificate; however, this option SHOULD NOT occur more than once for each group ID. The behavior for specifying more than one public key per group ID is not defined.",
      "ja": "このオプションは、そのグループ内のDiffie-HellmanグループIDおよび静的な公開鍵を指定します。それは正規のセクションにない場合、このオプションは無視しなければなりません。このオプションは、一度証明書よりも起こり得ます。ただし、このオプションは、各グループIDに対して複数回発生しません。グループIDごとに複数の公開鍵を指定するための動作は定義されていません。"
    },
    {
      "indent": 3,
      "text": "+-------------/-+-------------/-+-------------/-+\n|   length    \\ |     0x1d    \\ |   group ID  \\ |\n+-------------/-+-------------/-+-------------/-+\n+------------------------------------------------------------------+\n|                  Diffie-Hellman Public Key                       |\n+------------------------------------------------------------------/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct staticDHPublicKeyCertOptionValue_t\n{\n    vlu_t   groupID :variable*8;\n    uintn_t publicKey :remainder()*8; // network byte order\n} :remainder()*8;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The presence of this option means that the certificate uses static Diffie-Hellman public keys only. The certificate MUST NOT contain any Supported Ephemeral Diffie-Hellman Group options (Section 4.3.3.4).",
      "ja": "このオプションの存在は証明書が静的なのDiffie-Hellman公開鍵を使用することを意味します。証明書はサポートされている任意のエフェメラルのDiffie-Hellmanのグループのオプション（セクション4.3.3.4）を含めることはできません。"
    },
    {
      "indent": 0,
      "text": "4.3.4. Authenticity",
      "section_title": true,
      "ja": "4.3.4。信憑性"
    },
    {
      "indent": 3,
      "text": "This profile does not use a public key infrastructure, nor are there signing keys present in certificates. Therefore, any properly encoded certificate is considered authentic according to Section 3.2 of RFC 7016.",
      "ja": "このプロファイルは、公開鍵インフラストラクチャを使用していない、また、証明書に存在するキーが署名されています。したがって、任意の適切に符号化された証明書は、RFC 7016のセクション3.2に従って真正であると考えられます。"
    },
    {
      "indent": 3,
      "text": "A certificate containing a static public key can only be used successfully for session communication if the holder of the certificate actually holds the private key associated with the public key. Authenticity of an identity and its peer ID (Section 4.3.2) having a certificate containing a static public key is implied by successful encrypted communication with the associated endpoint (Section 4.6).",
      "ja": "証明書の所有者が実際に公開鍵に関連付けられた秘密鍵を保持している場合、静的な公開鍵を含む証明書は、セッションのみの通信のために正常に使用することができます。同一性および静的公開鍵を含む証明書を有するピアID（4.3.2）の真正性は、関連するエンドポイント（セクション4.6）との成功した暗号化通信によって暗示されています。"
    },
    {
      "indent": 3,
      "text": "See Section 7 for further discussion of security issues related to identities.",
      "ja": "アイデンティティに関連したセキュリティ問題のさらなる議論については、セクション7を参照してください。"
    },
    {
      "indent": 0,
      "text": "4.3.5. Signing and Verifying Messages",
      "section_title": true,
      "ja": "4.3.5。メッセージの署名と検証"
    },
    {
      "indent": 3,
      "text": "RTMFP Initiator Initial Keying and Responder Initial Keying messages have a field for the sender's digital signature of the keying parameters (Sections 2.3.7 and 2.3.8 of RFC 7016). In this profile, the signature field of those messages is encoded as a sequence of zero or more RTMFP Options.",
      "ja": "RTMFPイニシエータ初期キーイングとResponderの初期キーイングメッセージは鍵パラメータ（セクション2.3.7およびRFC 7016の2.3.8）の送信者のデジタル署名のためのフィールドがあります。このプロファイルでは、それらのメッセージの署名フィールドは、ゼロ以上RTMFPオプションのシーケンスとして符号化されます。"
    },
    {
      "indent": 3,
      "text": "+~~~/~~~/~~~~~~~+               +~~~/~~~/~~~~~~~+\n| L \\ T \\   V   |...............| L \\ T \\   V   |\n+~~~/~~~/~~~~~~~+               +~~~/~~~/~~~~~~~+\n^                                               ^\n+-------------  Zero or more Options  ----------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct initialKeyingSignature_t\n{\n    while(remainder() > 0)\n        option_t option :variable*8;\n} :remainder()*8;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "If a signer has no signature options to send, it MAY encode a signature as a UTF-8 capital \"X\" (hex 58) or as empty. A verifier MUST interpret a malformed signature field or a signature field consisting only of a UTF-8 capital \"X\" as though it was empty.",
      "ja": "署名者は送るべき署名のオプションを持っていない場合は、UTF-8の首都「X」（16進58）として、または空として署名を符号化することができます。検証者は、不正な署名フィールドのみが空であったかのようにUTF-8資本「X」からなる署名フィールドを解釈しなければなりません。"
    },
    {
      "indent": 3,
      "text": "If a verifier does not require a signature, it SHALL consider any signature field (including an empty or malformed one) to be valid. A verifier MAY require a signature comprising one or more non-empty options that are valid according to their respective types.",
      "ja": "検証者が署名を必要としない場合、それが有効であると（空または不正な形式のものを含む）すべての署名フィールドを考慮しなければなりません。検証者は、それぞれのタイプに応じて有効である1つ以上の非空のオプションを含む署名を必要とするかもしれません。"
    },
    {
      "indent": 3,
      "text": "This profile does not use a public key infrastructure, nor are there signing keys present in certificates. Section 4.3.5.1.1 defines a simple ID/password credential system.",
      "ja": "このプロファイルは、公開鍵インフラストラクチャを使用していない、また、証明書に存在するキーが署名されています。セクション4.3.5.1.1は、単純なID /パスワード資格システムを定義します。"
    },
    {
      "indent": 0,
      "text": "4.3.5.1. Options",
      "section_title": true,
      "ja": "4.3.5.1。オプション"
    },
    {
      "indent": 3,
      "text": "This section lists options that can appear in an RTMFP Initial Keying signature field. The following option type code is defined:",
      "ja": "このセクションでは、RTMFP初期キーイング署名フィールドに表示できるオプションを示します。以下のオプションタイプコードが定義されています。"
    },
    {
      "indent": 3,
      "text": "0x1d: Simple Password (Section 4.3.5.1.1)",
      "ja": "0x1Dの：簡単なパスワード（セクション4.3.5.1.1）"
    },
    {
      "indent": 3,
      "text": "Future or derived profiles may define additional signature field options and semantics; therefore, a verifier SHOULD ignore option types that are not understood.",
      "ja": "将来または派生プロファイルは、追加の署名フィールドのオプションとセマンティクスを定義することができ、そのため、検証が理解されていないオプションタイプを無視します。"
    },
    {
      "indent": 0,
      "text": "4.3.5.1.1. Simple Password",
      "section_title": true,
      "ja": "4.3.5.1.1。単純なパスワード"
    },
    {
      "indent": 3,
      "text": "This option encodes a password identifier (such as a user name, or an application-specific or implementation-specific selector) and an HMAC over the signed parameters using the identified password as the HMAC key. This option can occur more than once (for example, to allow interoperation between a current and a previous version of an implementation using implementation-specific passwords).",
      "ja": "このオプションは、HMACキーとして識別されたパスワードを使用して署名されたパラメータを超えるとHMAC（例えば、ユーザ名、またはアプリケーション固有または実装固有のセレクタとして）パスワード識別子を符号化します。複数回発生する可能性があり、このオプションは、（例えば、現在および実装固有のパスワードを使用して、実装の前のバージョンとの間の相互運用を可能にします）。"
    },
    {
      "indent": 3,
      "text": "To support the versioning use case, a verifier SHOULD ignore a Simple Password option encoding an unrecognized password identifier. A verifier SHOULD treat the entire signature as invalid if any Simple Password option encodes a recognized password identifier with an invalid password HMAC.",
      "ja": "バージョン管理のユースケースをサポートするために、検証者は認識されないパスワード識別子をコード化する単純なパスワードオプションを無視します。任意の単純なパスワードのオプションが無効なパスワードHMACとの認識パスワード識別子をコードする場合、検証は、全体の署名が無効なものとして扱うべきです。"
    },
    {
      "indent": 3,
      "text": " 0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7\n+-------------/-+-------------/-+\n|   length    \\ |     0x1d    \\ |\n+-------------/-+-------------/-+\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n+ - - - - - - - + - - - - - - - + - - - - - - - + - - - - - - - +\n|                                                               |\n+ - - - - - - - + - - - - - - - + - - - - - - - + - - - - - - - +\n|                                                               |\n+ - - - - - - - + - - - - - - - + - - - - - - - + - - - - - - - +\n|                           hmacSHA256                          |\n+ - - - - - - - + - - - - - - - + - - - - - - - + - - - - - - - +\n|                                                               |\n+ - - - - - - - + - - - - - - - + - - - - - - - + - - - - - - - +\n|                                                               |\n+ - - - - - - - + - - - - - - - + - - - - - - - + - - - - - - - +\n|                                                               |\n+ - - - - - - - + - - - - - - - + - - - - - - - + - - - - - - - +\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+\n|                           passwordID                          |\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct simplePasswordSignatureOptionValue_t\n{\n    uint8_t hmacSHA256[32];\n    uint8_t passwordID[remainder()];\n} :remainder()*8;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "hmacSHA256: HMAC-SHA256(K, M), where K is the password associated with passwordID, and M is the signed parameters.",
      "ja": "HMACSHA256：HMAC-SHA256（K、M）は、KはpasswordIDに関連付けられたパスワードであり、そしてMは、署名されたパラメータです。"
    },
    {
      "indent": 3,
      "text": "passwordID: The identifier (such as a user name) for the password used as the HMAC key.",
      "ja": "passwordID：HMACキーとして使用されるパスワードについて（ユーザ名など）の識別子を。"
    },
    {
      "indent": 0,
      "text": "4.3.6. Glare Resolution",
      "section_title": true,
      "ja": "4.3.6。グレア解像度"
    },
    {
      "indent": 3,
      "text": "Glare occurs when two endpoints initiate a session each to the other concurrently.",
      "ja": "2つのエンドポイントが同時に相互に各セッションを開始するときにグレアが発生します。"
    },
    {
      "indent": 3,
      "text": "Compare the near end's certificate to the far end's with a binary lexicographic comparison, one byte at a time, up to the length of the shorter certificate. At the first corresponding byte from each certificate that is different, the certificate having the differing byte (treated as an unsigned 8-bit integer) with the lower value is ordered before the other certificate. If the certificates are not the same length and they are identical up to the length of the shorter certificate, then the shorter certificate is ordered before the longer.",
      "ja": "短い証明書の長さまで、一度に、バイナリ辞書式の比較で1つのバイトを遠端のへの近端の証明書を比較してください。異なる各証明書からの第一対応するバイトで、低い値を有する（符号なし8ビット整数として扱われる）異なるバイトを有する証明書は、他の証明書の前に順序付けされます。証明書は同じ長さではなく、彼らは短い証明書の長さまでは同じである場合、より短い証明書が長く前に注文しています。"
    },
    {
      "indent": 3,
      "text": "The near end prevails as the Initiator in case of glare if its certificate is ordered before, or is identical to, the certificate of the far end. Otherwise, the near end's certificate is ordered after the far end's certificate, and the near end assumes the role of Responder.",
      "ja": "近端は、その証明書が以前に注文された場合にグレアの場合の開始剤として支配する、または遠端の証明書、と同じです。それ以外の場合は、近端の証明書は、遠端の証明書の後に発注され、近端は、レスポンダの役割を前提としています。"
    },
    {
      "indent": 0,
      "text": "4.3.7. Session Override",
      "section_title": true,
      "ja": "4.3.7。セッションの上書き"
    },
    {
      "indent": 3,
      "text": "A new incoming session overrides an existing session only if the certificate for the new session is identical to the certificate for the existing session.",
      "ja": "新しい着信セッションは、新しいセッションのための証明書は、既存のセッションのための証明書と同じである場合にのみ、既存のセッションを無効にします。"
    },
    {
      "indent": 0,
      "text": "4.4. Endpoint Discriminators",
      "section_title": true,
      "ja": "4.4。エンドポイントディスクリミネータ"
    },
    {
      "indent": 3,
      "text": "This section describes the Endpoint Discriminator (EPD) (Section 3.2 of RFC 7016) format and semantics for this Cryptography Profile, and the mapping to RTMFP's abstract certificate and identity selection semantics.",
      "ja": "このセクションでは、エンドポイント識別子（EPD）この暗号のプロフィール形式と意味論（RFC 7016のセクション3.2）、およびRTMFPの抽象証明書とアイデンティティの選択セマンティクスへのマッピングを記述します。"
    },
    {
      "indent": 0,
      "text": "4.4.1. Format",
      "section_title": true,
      "ja": "4.4.1。フォーマット"
    },
    {
      "indent": 3,
      "text": "An EPD in this profile is encoded as a sequence of zero or more RTMFP Options.",
      "ja": "このプロファイルでEPDは、ゼロ以上RTMFPオプションのシーケンスとして符号化されます。"
    },
    {
      "indent": 3,
      "text": "+~~~/~~~/~~~~~~~+               +~~~/~~~/~~~~~~~+\n| L \\ T \\   V   |...............| L \\ T \\   V   |\n+~~~/~~~/~~~~~~~+               +~~~/~~~/~~~~~~~+\n^                                               ^\n+-------------  Zero or more Options  ----------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct endpointDiscriminator_t\n{\n    while(remainder() > 0)\n        option_t option :variable*8;\n} :remainder()*8;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.4.2. Options",
      "section_title": true,
      "ja": "4.4.2。オプション"
    },
    {
      "indent": 3,
      "text": "This section lists options that can appear in an EPD. The following option type codes are defined:",
      "ja": "このセクションでは、EPDに表示できるオプションを示します。次のオプション・タイプ・コードが定義されています："
    },
    {
      "indent": 3,
      "text": "0x00: Required Hostname (Section 4.4.2.1)",
      "ja": "$ 00：必要なホスト名（4.4.2.1項）"
    },
    {
      "indent": 3,
      "text": "0x0a: Ancillary Data (Section 4.4.2.2)",
      "ja": "0x0Aを：補助データ（セクション4.4.2.2）"
    },
    {
      "indent": 3,
      "text": "0x0f: Fingerprint (Section 4.4.2.3)",
      "ja": "0x0Fの：指紋（セクション4.4.2.3）"
    },
    {
      "indent": 3,
      "text": "The use of these options for selecting certificates is described in Section 4.4.3.",
      "ja": "証明書を選択するため、これらのオプションの使用は、セクション4.4.3に記載されています。"
    },
    {
      "indent": 3,
      "text": "An implementation MUST ignore EPD option types that are not understood.",
      "ja": "実装は理解されていないEPDオプションの種類を無視しなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.4.2.1. Required Hostname",
      "section_title": true,
      "ja": "4.4.2.1。必要なホスト名"
    },
    {
      "indent": 3,
      "text": "This option indicates the hostname to match against the certificate's Hostname option (Section 4.3.3.1).",
      "ja": "このオプションは、証明書のホスト名オプション（セクション4.3.3.1）と照合するホスト名を示します。"
    },
    {
      "indent": 3,
      "text": "+-------------/-+-------------/-+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+\n|   length    \\ |     0x00    \\ |         hostname              |\n+-------------/-+-------------/-+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct hostnameEPDOptionValue_t\n{\n    uint8_t hostname[remainder()];\n} :remainder()*8;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This option MUST NOT occur more than once in an EPD.",
      "ja": "このオプションは、EPDで複数回発生してはなりません。"
    },
    {
      "indent": 0,
      "text": "4.4.2.2. Ancillary Data",
      "section_title": true,
      "ja": "4.4.2.2。補助データ"
    },
    {
      "indent": 3,
      "text": "In this profile, this option indicates the server Uniform Resource Identifier (URI) [RFC3986] encoded in UTF-8 to which a client is connecting on this session, for example, \"rtmfp://server.example.com/app/instance\".",
      "ja": "このプロファイルでは、このオプションは、サーバURI（Uniform Resource Identifier）を示している[RFC3986]クライアントは、例えば、このセッションに接続されたUTF-8でエンコードされ、「RTMFP：//server.example.com/app/instance 」。"
    },
    {
      "indent": 3,
      "text": "+-------------/-+-------------/-+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+\n|   length    \\ |     0x0a    \\ |       ancillary data          |\n+-------------/-+-------------/-+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct ancillaryDataEPDOptionValue_t\n{\n    uint8_t ancillaryData[remainder()];\n} :remainder()*8;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This option MUST NOT occur more than once in an EPD.",
      "ja": "このオプションは、EPDで複数回発生してはなりません。"
    },
    {
      "indent": 0,
      "text": "4.4.2.3. Fingerprint",
      "section_title": true,
      "ja": "4.4.2.3。指紋"
    },
    {
      "indent": 3,
      "text": "This option indicates the 256-bit (32-byte) fingerprint (Section 4.3.2) of a certificate.",
      "ja": "このオプションは、証明書の256ビット（32バイト）指紋（4.3.2）を示します。"
    },
    {
      "indent": 3,
      "text": " 0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7\n+-------------/-+-------------/-+\n|   length    \\ |     0x0f    \\ |\n+-------------/-+-------------/-+\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n+ - - - - - - - + - - - - - - - + - - - - - - - + - - - - - - - +\n|                                                               |\n+ - - - - - - - + - - - - - - - + - - - - - - - + - - - - - - - +\n|                                                               |\n+ - - - - - - - + - - - - - - - + - - - - - - - + - - - - - - - +\n|                          fingerprint                          |\n+ - - - - - - - + - - - - - - - + - - - - - - - + - - - - - - - +\n|                                                               |\n+ - - - - - - - + - - - - - - - + - - - - - - - + - - - - - - - +\n|                                                               |\n+ - - - - - - - + - - - - - - - + - - - - - - - + - - - - - - - +\n|                                                               |\n+ - - - - - - - + - - - - - - - + - - - - - - - + - - - - - - - +\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct fingerprintEPDOptionValue_t\n{\n    uint8_t fingerprint[32];\n} :256;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This option MUST NOT occur more than once in an EPD.",
      "ja": "このオプションは、EPDで複数回発生してはなりません。"
    },
    {
      "indent": 0,
      "text": "4.4.3. Certificate Selection",
      "section_title": true,
      "ja": "4.4.3。証明書の選択"
    },
    {
      "indent": 3,
      "text": "This section describes the REQUIRED method of determining whether an EPD selects a certificate.",
      "ja": "このセクションでは、EPDは、証明書を選択するかどうかを決定する必要な方法を記載しています。"
    },
    {
      "indent": 3,
      "text": "An EPD MUST contain at least one of Fingerprint, Required Hostname, or Ancillary Data options to select any certificate.",
      "ja": "EPDは、すべての証明書を選択するために、指紋認証、必要なホスト名、または補助データのオプションを1つ以上含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "A Fingerprint EPD option selects or rejects a certificate no matter what other options are present.",
      "ja": "指紋EPDオプションに関係なく存在している他のどのようなオプションの証明書を選択していないか、拒否します。"
    },
    {
      "indent": 3,
      "text": "Without a Fingerprint option, a Required Hostname EPD option, if present, REQUIRES an identical Hostname option in the certificate.",
      "ja": "指紋オプションを指定しないと、必要なホスト名EPDオプションは、存在する場合、証明書で同じホスト名オプションが必要です。"
    },
    {
      "indent": 3,
      "text": "Without a Fingerprint option, an Ancillary Data EPD option, if present, REQUIRES that the certificate has an Accepts Ancillary Data option.",
      "ja": "指紋オプションを指定しないと、補助データEPDオプションは、存在する場合、証明書は、補助データオプションを受け入れている必要があります。"
    },
    {
      "indent": 3,
      "text": "if EPD contains a Fingerprint option: if certificate.fingerprint == option.fingerprint: certificate is selected. stop. else: certificate is not selected. stop. else: if EPD contains a Required Hostname option: if certificate contains a Hostname option: if certificate.hostname != option.hostname: certificate is not selected. stop. else: certificate is not selected. stop. if EPD contains an Ancillary Data option: if certificate doesn't have an Accepts Ancillary Data option: certificate is not selected. stop. else if EPD does not contain a Required Hostname option: certificate is not selected. stop. certificate is selected. stop.",
      "ja": "EPDは、指紋のオプションが含まれている場合：certificate.fingerprintは== option.fingerprint場合：証明書が選択されています。やめる。他：証明書が選択されていません。やめる。他：EPDが必要なホスト名オプションが含まれている場合：証明書はホスト名オプションが含まれているとします！証明書選択されていません。certificate.hostname = option.hostnameがあれば。やめる。他：証明書が選択されていません。やめる。 EPDは、補助データのオプションが含まれている場合：証明書は持っていない場合、補助データ・オプションを受け入れます。証明書が選択されていません。やめる。他のEPDは、必要なホスト名オプションが含まれていない場合：証明書が選択されていません。やめる。証明書が選択されています。やめる。"
    },
    {
      "indent": 5,
      "text": "Figure 1: Algorithm to Test Whether an EPD Selects a Certificate",
      "ja": "図1：アルゴリズムは、EPDは、証明書を選択するかどうかをテストします"
    },
    {
      "indent": 0,
      "text": "4.4.4. Canonical Endpoint Discriminator",
      "section_title": true,
      "ja": "4.4.4。 Canonicalのエンドポイント識別子"
    },
    {
      "indent": 3,
      "text": "In this profile, a Canonical Endpoint Discriminator (Section 3.2 of RFC 7016) contains only a Fingerprint option (Section 4.4.2.3) and no other options. The option length and type code MUST be encoded as 1-byte VLUs, even though VLU encoding allows those fields to be encoded in an arbitrary number of bytes. That is, the Canonical Endpoint Discriminator MUST be exactly 34 bytes long, with a length field of 0x21 encoded as one byte, a type code of 0x0f encoded as one byte, and 32 bytes of fingerprint.",
      "ja": "このプロファイルでは、Canonicalのエンドポイント識別子（RFC 7016のセクション3.2）のみ指紋オプション（セクション4.4.2.3）となし、他のオプションが含まれています。オプションの長さ及びタイプコードがVLU符号化はこれらのフィールドは、任意のバイト数で符号化することを可能にするにもかかわらず、1バイトのVLUとして符号化されなければなりません。つまり、正規エンドポイント識別子は1バイト、1バイトとして符号化0x0Fのタイプコード、及び指紋の32のバイトとして符号化0x21での長さフィールドと、正確に34バイトの長さでなければなりません。"
    },
    {
      "indent": 3,
      "text": " 0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     0x21      |     0x0f      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n+ - - - - - - - + - - - - - - - + - - - - - - - + - - - - - - - +\n|                                                               |\n+ - - - - - - - + - - - - - - - + - - - - - - - + - - - - - - - +\n|                                                               |\n+ - - - - - - - + - - - - - - - + - - - - - - - + - - - - - - - +\n|                          fingerprint                          |\n+ - - - - - - - + - - - - - - - + - - - - - - - + - - - - - - - +\n|                                                               |\n+ - - - - - - - + - - - - - - - + - - - - - - - + - - - - - - - +\n|                                                               |\n+ - - - - - - - + - - - - - - - + - - - - - - - + - - - - - - - +\n|                                                               |\n+ - - - - - - - + - - - - - - - + - - - - - - - + - - - - - - - +\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct canonicalEndpointDiscriminator_t\n{\n    uint8_t length = 0x21;\n    uint8_t type = 0x0f;\n    uint8_t fingerprint[32];\n} :272;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.5. Session Keying Components",
      "section_title": true,
      "ja": "4.5。セッションキーイングコンポーネント"
    },
    {
      "indent": 3,
      "text": "This section describes the format of the Session Key Initiator Component of the Initiator Initial Keying RTMFP chunk and the Session Key Responder Component of the Responder Initial Keying RTMFP chunk (Sections 2.3.7 and 2.3.8 of RFC 7016). The Initiator and Responder Session Keying Components have the same format.",
      "ja": "このセクションでは、イニシエータ初期キーイングRTMFPチャンクのセッションキーイニシエータコンポーネントとResponderのイニシャルキーイングRTMFPチャンクのセッションキーレスポンダコンポーネント（セクション2.3.7およびRFC 7016の2.3.8）の形式について説明します。イニシエータとレスポンダのセッションキーイングコンポーネントは、同じフォーマットを持っています。"
    },
    {
      "indent": 0,
      "text": "4.5.1. Format",
      "section_title": true,
      "ja": "4.5.1。フォーマット"
    },
    {
      "indent": 3,
      "text": "A Session Keying Component in this profile is encoded as a sequence of zero or more RTMFP Options.",
      "ja": "このプロファイルでセッションキーイングコンポーネントがゼロ以上RTMFPオプションのシーケンスとして符号化されます。"
    },
    {
      "indent": 3,
      "text": "+~~~/~~~/~~~~~~~+               +~~~/~~~/~~~~~~~+\n| L \\ T \\   V   |...............| L \\ T \\   V   |\n+~~~/~~~/~~~~~~~+               +~~~/~~~/~~~~~~~+\n^                                               ^\n+-------------  Zero or more Options  ----------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct sessionKeyingComponent_t\n{\n    while(remainder() > 0)\n        option_t option :variable*8;\n} :remainder()*8;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.5.2. Options",
      "section_title": true,
      "ja": "4.5.2。オプション"
    },
    {
      "indent": 3,
      "text": "This section lists options that can appear in a Session Keying Component. The following option type codes are defined:",
      "ja": "このセクションでは、セッションキーイングコンポーネントに表示できるオプションを示します。次のオプション・タイプ・コードが定義されています："
    },
    {
      "indent": 3,
      "text": "0x0d: Ephemeral Diffie-Hellman Public Key (Section 4.5.2.1)",
      "ja": "0x0Dを：エフェメラルのDiffie-Hellman公開鍵（セクション4.5.2.1）"
    },
    {
      "indent": 3,
      "text": "0x0e: Extra Randomness (Section 4.5.2.2)",
      "ja": "0x0Eの：エクストラランダムネス（セクション4.5.2.2）"
    },
    {
      "indent": 3,
      "text": "0x1d: Diffie-Hellman Group Select (Section 4.5.2.3)",
      "ja": "0x1Dの：のDiffie-Hellmanのグループを選択（セクション4.5.2.3）"
    },
    {
      "indent": 3,
      "text": "0x1a: HMAC Negotiation (Section 4.5.2.4)",
      "ja": "0x1a：HMAC交渉（セクション4.5.2.4）"
    },
    {
      "indent": 3,
      "text": "0x1e: Session Sequence Number Negotiation (Section 4.5.2.5)",
      "ja": "0x1eが表示：セッションシーケンス番号交渉（セクション4.5.2.5）"
    },
    {
      "indent": 3,
      "text": "An implementation MUST ignore a session keying component option type that is not understood.",
      "ja": "実装が理解されていないコンポーネントのオプションタイプをキーイングセッションを無視しなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.5.2.1. Ephemeral Diffie-Hellman Public Key",
      "section_title": true,
      "ja": "4.5.2.1。エフェメラルのDiffie-Hellman公開鍵"
    },
    {
      "indent": 3,
      "text": "This option specifies a Diffie-Hellman group ID and public key in that group. This option MUST NOT be sent if the sender's certificate has a static Diffie-Hellman public key. This option MUST be sent if the sender's certificate does not have a static Diffie-Hellman public key. This option MUST NOT be sent more than once.",
      "ja": "このオプションは、そのグループ内のDiffie-HellmanグループIDと公開鍵を指定します。送信者の証明書は、静的のDiffie-Hellman公開鍵を持っている場合は、このオプションは送ってはいけません。送信者の証明書は、静的のDiffie-Hellman公開鍵を持っていない場合、このオプションは送らなければなりません。このオプションは複数回送ってはいけません。"
    },
    {
      "indent": 3,
      "text": "+-------------/-+-------------/-+-------------/-+\n|   length    \\ |     0x0d    \\ |   group ID  \\ |\n+-------------/-+-------------/-+-------------/-+\n+------------------------------------------------------------------+\n|                  Diffie-Hellman Public Key                       |\n+------------------------------------------------------------------/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct ephemeralDHPublicKeyKeyingOptionValue_t\n{\n    vlu_t   groupID :variable*8;\n    uintn_t publicKey :remainder()*8; // network byte order\n} :remainder()*8;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.5.2.2. Extra Randomness",
      "section_title": true,
      "ja": "4.5.2.2。エクストラランダム性"
    },
    {
      "indent": 3,
      "text": "This option can be used to add extra entropy or randomness to a keying component, particularly when the sender uses a static public key. When used for that purpose, the extra randomness SHOULD be cryptographically strong pseudorandom bytes not less than 16 bytes (for cryptographically significant entropy) and not more than 64 bytes (the length of a SHA-256 input block) in length. The extra randomness serves as a salt when computing the session keys (Section 4.6).",
      "ja": "このオプションは、送信者は、静的な公開鍵を使用して場合は特に、キーイングコンポーネントに余分なエントロピーやランダム性を追加するために使用することができます。その目的のために使用される場合、余分なランダム性は、暗号強度の高い擬似ランダム以下16以上バイト（暗号重要エントロピー用）バイトと長さ以上64バイト（SHA-256入力ブロックの長さ）であるべきです。セッションキー（4.6節）を計算する際に余分なランダム性は、塩としての役割を果たす。"
    },
    {
      "indent": 3,
      "text": "+-------------/-+-------------/-+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+\n|   length    \\ |     0x0e    \\ |       extra randomness        |\n+-------------/-+-------------/-+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct extraRandomnessKeyingOptionValue_t\n{\n    uint_t extraRandomness[remainder()];\n} :remainder()*8;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.5.2.3. Diffie-Hellman Group Select",
      "section_title": true,
      "ja": "4.5.2.3。 Diffie-Hellmanのグループを選択"
    },
    {
      "indent": 3,
      "text": "This option is sent by the Initiator to specify which Diffie-Hellman group to use for key agreement. The Initiator MUST send this option when it advertises a static Diffie-Hellman public key in its certificate and MUST NOT send this option if it sends an ephemeral Diffie-Hellman public key. This option MUST NOT be sent more than once.",
      "ja": "このオプションは、キーの合意に使用するDiffie-Hellmanグループを指定するイニシエータによって送信されます。それはその証明書の静的のDiffie-Hellman公開鍵をアドバタイズし、それは短命のDiffie-Hellman公開鍵を送信する場合は、このオプションを送ってはいけませんときイニシエータは、このオプションを送らなければなりません。このオプションは複数回送ってはいけません。"
    },
    {
      "indent": 3,
      "text": "+-------------/-+-------------/-+-------------/-+\n|   length    \\ |     0x1d    \\ |   group ID  \\ |\n+-------------/-+-------------/-+-------------/-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct staticDHGroupSelectKeyingOptionValue_t\n{\n    vlu_t   groupID :variable*8;\n} :variable*8;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.5.2.4. HMAC Negotiation",
      "section_title": true,
      "ja": "4.5.2.4。 HMAC交渉"
    },
    {
      "indent": 3,
      "text": "This option is used to negotiate sending and receiving of an HMAC field for packet verification.",
      "ja": "このオプションは、送信とパケット検証のためのHMACフィールドの受信を交渉するために使用されます。"
    },
    {
      "indent": 3,
      "text": "                                |0 1 2 3 4 5 6 7|\n+-------------/-+-------------/-+-+-+-+-+-+-+-+-+-------------/-+\n|             \\ |             \\ |         |S|S|R|             \\ |\n|   length    / |     0x1a    / |   rsv   |N|O|E|  hmacLength / |\n|             \\ |             \\ |         |D|R|Q|             \\ |\n+-------------/-+-------------/-+-+-+-+-+-+-+-+-+-------------/-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct hmacNegotiationKeyingOptionValue_t\n{\n    uintn_t reserved :5;          // rsv\n    bool_t  willSendAlways :1;    // SND\n    bool_t  willSendOnRequest :1; // SOR\n    bool_t  request :1;           // REQ\n    vlu_t   hmacLength :variable*8;\n} :variable*8;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "willSendAlways: If set, the sender will send an HMAC on packets in this session.",
      "ja": "willSendAlways：設定されている場合、送信者はこのセッションでは、パケットにHMACを送信します。"
    },
    {
      "indent": 3,
      "text": "willSendOnRequest: If set, the sender will send an HMAC on packets in this session if the other end sets the request flag in its HMAC Negotiation.",
      "ja": "willSendOnRequest：設定した場合、もう一方の端は、そのHMAC交渉で要求フラグを設定した場合、送信者がこのセッションでは、パケットにHMACを送信します。"
    },
    {
      "indent": 3,
      "text": "request: If set, the sender would very much like the receiver to send an HMAC on its packets. If the other end doesn't send an HMAC on its packets, the session can fail.",
      "ja": "リクエスト：設定した場合、送信側はそのパケットにHMACを送信するために非常に多くの受信機たいと思います。もう一方の端は、そのパケットにHMACを送信しない場合、セッションは失敗する可能性があります。"
    },
    {
      "indent": 3,
      "text": "hmacLength: If the sender negotiates to send an HMAC on its packets, the HMAC field will be this many bytes long. This value MUST be between 4 and 32 inclusive, or 0 if and only if willSendAlways and willSendOnRequest are clear.",
      "ja": "hmacLength：送信者がそのパケットにHMACを送信するために交渉した場合は、HMACフィールドは、この多くのバイト長になります。この値があれば4と32包括、または0の間でなければなりませんとwillSendAlwaysとwillSendOnRequestは明確である場合にのみ。"
    },
    {
      "indent": 3,
      "text": "The handshake operational semantics for this option are described in Section 4.6.4.",
      "ja": "このオプションのハンドシェイク操作的意味論は、セクション4.6.4で説明されています。"
    },
    {
      "indent": 0,
      "text": "4.5.2.5. Session Sequence Number Negotiation",
      "section_title": true,
      "ja": "4.5.2.5。セッションシーケンス番号交渉"
    },
    {
      "indent": 3,
      "text": "This option is used to negotiate sending and receiving of the Session Sequence Number field for packet verification.",
      "ja": "このオプションは、送信とパケット検証のためのセッションシーケンス番号フィールドの受信を交渉するために使用されます。"
    },
    {
      "indent": 3,
      "text": "                                |0 1 2 3 4 5 6 7|\n+-------------/-+-------------/-+-+-+-+-+-+-+-+-+\n|             \\ |             \\ |         |S|S|R|\n|   length    / |     0x1e    / |   rsv   |N|O|E|\n|             \\ |             \\ |         |D|R|Q|\n+-------------/-+-------------/-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct sseqNegotiationKeyingOptionValue_t { uintn_t reserved :5; // rsv bool_t willSendAlways :1; // SND bool_t willSendOnRequest :1; // SOR bool_t request :1; // REQ } :8;",
      "ja": "構造体sseqNegotiationKeyingOptionValue_t {uintn_t予約：5。 //のRSVのbool_tのwillSendAlways：1; willSendOnRequestのbool_t // SND：1; // SORのbool_t要求：1。 // REQ}：8。"
    },
    {
      "indent": 3,
      "text": "willSendAlways: If set, the sender will send a session sequence number in packets in this session.",
      "ja": "willSendAlways：設定した場合、送信者はこのセッションでは、パケットのセッションシーケンス番号を送信します。"
    },
    {
      "indent": 3,
      "text": "willSendOnRequest: If set, the sender will send a session sequence number in packets in this session if the other end sets the request flag in its Session Sequence Number Negotiation.",
      "ja": "willSendOnRequest：設定した場合、もう一方の端は、そのセッションのシーケンス番号交渉で要求フラグを設定した場合、送信者がこのセッションでは、パケット内のセッションのシーケンス番号を送信します。"
    },
    {
      "indent": 3,
      "text": "request: If set, the sender would very much like the receiver to send a session sequence number in its packets. If the other end doesn't send a session sequence number in its packets, the session can fail.",
      "ja": "リクエスト：設定した場合、送信側はそのパケットのセッションシーケンス番号を送信するために非常に多くの受信機たいと思います。もう一方の端は、そのパケットのセッションシーケンス番号を送信しない場合、セッションは失敗する可能性があります。"
    },
    {
      "indent": 3,
      "text": "The handshake operational semantics for this option are described in Section 4.6.6.",
      "ja": "このオプションのハンドシェイク操作的意味論は、セクション4.6.6で説明されています。"
    },
    {
      "indent": 0,
      "text": "4.6. Session Key Computation",
      "section_title": true,
      "ja": "4.6。セッションキー計算"
    },
    {
      "indent": 3,
      "text": "This section describes how to compute the cryptographic keys and other settings for packet encryption and verification.",
      "ja": "このセクションでは、パケットの暗号化と検証のための暗号鍵やその他の設定を計算する方法について説明します。"
    },
    {
      "indent": 3,
      "text": "The Session Key Near Component (SKNC) means the keying component sent by the near end of the session; that is, it is the Session Key Initiator Component at the Initiator and the Session Key Responder Component at the Responder.",
      "ja": "セッション鍵の近く成分（SKNC）は、セッションの近端によって送信されたキーイング要素を意味します。つまり、それは、イニシエータのセッションキーイニシエータコンポーネントおよびレスポンダのセッションキーレスポンダコンポーネントです。"
    },
    {
      "indent": 3,
      "text": "The Session Key Far Component (SKFC) means the keying component sent by the far end of the session; that is, it is the Session Key Responder Component at the Initiator and the Session Key Initiator Component at the Responder.",
      "ja": "セッションキーファーコンポーネント（SKFC）は、セッションの遠端によって送信されたキー・コンポーネントを意味します。つまり、それは、イニシエータのセッションキーレスポンダコンポーネントおよびレスポンダのセッションキーイニシエータコンポーネントです。"
    },
    {
      "indent": 0,
      "text": "4.6.1. Public Key Selection",
      "section_title": true,
      "ja": "4.6.1。公開鍵の選択"
    },
    {
      "indent": 3,
      "text": "This section enumerates the public key selection methods for all possible combinations of static or ephemeral public key modes for each endpoint according to their certificate options (Section 4.3.3).",
      "ja": "このセクションでは、それらの証明書のオプション（4.3.3）に応じて、各エンドポイントの静的またはエフェメラルパブリックキーモードのすべての可能な組み合わせのための公開鍵の選択方法を列挙する。"
    },
    {
      "indent": 0,
      "text": "4.6.1.1. Initiator and Responder Ephemeral",
      "section_title": true,
      "ja": "4.6.1.1。イニシエータとレスポンダエフェメラル"
    },
    {
      "indent": 3,
      "text": "The Initiator and Responder list one or more Supported Ephemeral Diffie-Hellman Group options (Section 4.3.3.4) in their certificates. The Initiator sends exactly one Ephemeral Diffie-Hellman Public Key option (Section 4.5.2.1) in its Session Key Initiator Component, which selects one group from among those supported by the Responder and Initiator. Responder sends exactly one Ephemeral Diffie-Hellman Public Key option in its Session Key Responder Component, in the same group as indicated by the Initiator.",
      "ja": "その証明書でのイニシエータとレスポンダリスト1以上のサポートされている短命のDiffie-Hellmanのグループのオプション（セクション4.3.3.4）。イニシエータは、レスポンダとイニシエータでサポートされているものの中から一つのグループを選択し、そのセッションキーイニシエータコンポーネントに正確に一つのエフェメラルのDiffie-Hellman公開鍵オプション（セクション4.5.2.1）を送信します。レスポンダは、イニシエータによって示されるように、同じグループで、まさにそのセッションキーレスポンダコンポーネントの1エフェメラルのDiffie-Hellman公開鍵のオプションを送信します。"
    },
    {
      "indent": 0,
      "text": "4.6.1.2. Initiator Ephemeral and Responder Static",
      "section_title": true,
      "ja": "4.6.1.2。イニシエータエフェメラルとResponderの静的"
    },
    {
      "indent": 3,
      "text": "The Responder lists one or more Static Diffie-Hellman Public Key options (Section 4.3.3.5) in its certificate. The Initiator lists one or more Supported Ephemeral Diffie-Hellman Group options in its certificate. The Initiator sends exactly one Ephemeral Diffie-Hellman Public Key option in its Session Key Initiator Component, which selects one group from among those supported by the Responder and Initiator and the corresponding public key for the Responder. Responder uses its public key from the indicated group, and sends only an Extra Randomness option (Section 4.5.2.2) in its Session Key Responder Component to salt the session keys.",
      "ja": "レスポンダは、その証明書内の1つまたは複数の静的のDiffie-Hellman公開鍵のオプション（セクション4.3.3.5）を示しています。イニシエータは、その証明書内の1つまたは複数のサポートされている短命のDiffie-Hellmanのグループのオプションを示します。イニシエータは、レスポンダとイニシエータとレスポンダのための対応する公開鍵でサポートされているものの中から一つのグループを選択し、そのセッションキーイニシエータコンポーネント、正確に1エフェメラルのDiffie-Hellman公開鍵のオプションを送信します。レスポンダは、示された基からの公開鍵を使用し、塩にそのセッションキーレスポンダコンポーネントでのみエクストラ乱雑オプション（セクション4.5.2.2）セッションキーを送信します。"
    },
    {
      "indent": 0,
      "text": "4.6.1.3. Initiator Static and Responder Ephemeral",
      "section_title": true,
      "ja": "4.6.1.3。イニシエータ静的およびレスポンダエフェメラル"
    },
    {
      "indent": 3,
      "text": "The Responder lists one or more Supported Ephemeral Diffie-Hellman Group options in its certificate. The Initiator lists one or more Static Diffie-Hellman Public Key options in its certificate. The Initiator sends exactly one Diffie-Hellman Group Select option (Section 4.5.2.3) in its Session Key Initiator Component, which selects one group from among those supported by the Responder and Initiator and the corresponding public key for the Initiator, plus an Extra Randomness option to salt the session keys. The Responder sends an Ephemeral Diffie-Hellman Public Key option in its Session Key Responder Component in the same group as indicated by the Initiator.",
      "ja": "レスポンダは、その証明書内の1つまたは複数のサポートされている短命のDiffie-Hellmanのグループのオプションを示します。イニシエータは、その証明書内の1つまたは複数の静的のDiffie-Hellman公開鍵のオプションを示します。イニシエータは、レスポンダとイニシエータとイニシエータのための対応する公開鍵、プラスエクストラランダム性でサポートされているものの中から一つのグループを選択し、そのセッションキーイニシエータコンポーネントに正確に一つのDiffie-Hellmanのグループを選択オプション（セクション4.5.2.3）を送ります塩セッションキーのオプション。レスポンダは、イニシエータによって示されるように、同じグループ内のセッションキーレスポンダコンポーネントでエフェメラルのDiffie-Hellman公開鍵のオプションを送信します。"
    },
    {
      "indent": 0,
      "text": "4.6.1.4. Initiator and Responder Static",
      "section_title": true,
      "ja": "4.6.1.4。イニシエータとレスポンダ静的"
    },
    {
      "indent": 3,
      "text": "The Initiator and Responder each list one or more Static Diffie-Hellman Public Key options in their certificates. The Initiator sends exactly one Diffie-Hellman Group Select option in its Session Key Initiator Component, which selects one group and corresponding public keys from among those supported by the Responder and Initiator, and an Extra Randomness option to salt the session keys. The Responder sends an Extra Randomness option in its Session Key Responder Component to add its own salt to the session keys.",
      "ja": "イニシエータとレスポンダ各リスト、証明書内の1つまたは複数の静的のDiffie-Hellman公開鍵のオプション。イニシエータは、一つのグループを選択し、そのセッションキーイニシエータコンポーネントに正確に一つのDiffie-Hellmanのグループを選択]オプションを送信し、レスポンダ及びイニシエータでサポートされているものの中から、公開鍵に対応し、塩のセッションキーに余分なランダム性オプション。レスポンダは、セッションキーに、独自の塩を追加するためのセッションキーレスポンダコンポーネントに予備のランダム性のオプションを送信します。"
    },
    {
      "indent": 0,
      "text": "4.6.2. Diffie-Hellman Shared Secret",
      "section_title": true,
      "ja": "4.6.2。ディフィー・ヘルマン共有シークレット"
    },
    {
      "indent": 3,
      "text": "To be acceptable, a Diffie-Hellman public key MUST have all of the following properties:",
      "ja": "受け入れられるためには、のDiffie-Hellman公開鍵は、次のプロパティのすべてを持っている必要があります。"
    },
    {
      "indent": 3,
      "text": "o Be at least 16777216 (2^24);",
      "ja": "Oて少なくとも16777216（^ 24 2）。"
    },
    {
      "indent": 3,
      "text": "o Be at most the group's prime modulus minus 16777216;",
      "ja": "Oほとんどのグループのプライムモジュラスマイナス16777216でう。"
    },
    {
      "indent": 3,
      "text": "o Have at least 16 \"1\" bits;",
      "ja": "Oは少なくとも16「1」ビットを有します。"
    },
    {
      "indent": 3,
      "text": "o Have at least 16 \"0\" bits, not including leading zeros.",
      "ja": "O先行ゼロを含まない少なくとも16の「0」ビットを有します。"
    },
    {
      "indent": 3,
      "text": "An endpoint MUST NOT complete to an S_OPEN session with a far endpoint using a public key that is not acceptable according to these criteria.",
      "ja": "エンドポイントは、これらの基準に従って受け入れられない公開鍵を使用してはるかにエンドポイントとS_OPENセッションに完了してはなりません。"
    },
    {
      "indent": 3,
      "text": "Once the group and corresponding public key of the far end is determined, the far end's public key and the near end's private key are combined according to Diffie-Hellman [DH] to compute the Diffie-Hellman Shared Secret, an integer.",
      "ja": "グループと遠端の対応する公開鍵が決定されると、遠端の公開鍵と近端の秘密鍵は、ディフィー - ヘルマン共有シークレット、整数を計算するためにディフィー - ヘルマン[DH]に従って合成されます。"
    },
    {
      "indent": 3,
      "text": "In the following sections, DH_SECRET means the Diffie-Hellman Shared Secret encoded as a byte-aligned unsigned integer in network byte order with no leading zero bytes. For example, if the shared secret is 4886718345, DH_SECRET would be the five bytes:",
      "ja": "以下のセクションでは、DH_SECRETはない先行ゼロバイトのネットワークバイト順のバイト整列の符号なし整数として符号化ディフィー・ヘルマン共有シークレットを意味します。共有秘密が4886718345である場合、例えば、DH_SECRETは5バイトのようになります。"
    },
    {
      "indent": 28,
      "text": "Hex: 01 23 45 67 89",
      "ja": "進：01 23 45 67 89"
    },
    {
      "indent": 0,
      "text": "4.6.3. Packet Encrypt/Decrypt Keys",
      "section_title": true,
      "ja": "4.6.3。パケットの暗号化/復号化キー"
    },
    {
      "indent": 3,
      "text": "Packets are encrypted using a symmetric cipher, such as the Advanced Encryption Standard [AES]. Distinct keys are used for sending and receiving packets. Each end's sending (encrypt) key is the other end's receiving (decrypt) key.",
      "ja": "パケットは、高度暗号化標準[AES]のように、対称暗号を用いて暗号化されています。個別のキーは、パケットを送受信するために使用されています。各エンドの送信（暗号化）キーを押して、もう一方の端の受信（復号化）キーです。"
    },
    {
      "indent": 3,
      "text": "The raw keys computed in this section for encryption and decryption are transformed in a manner specific to the cipher with which they are to be used. In this profile, AES-128 is the only currently defined cipher. For this cipher, the first 128 bits (16 bytes) of the 256-bit output of the calculation are taken to be the AES-128 key.",
      "ja": "暗号化および復号化のために、このセクションで計算生のキーは、それらが使用されるべきで暗号に固有の方法で変換されます。このプロファイルでは、AES-128は、現在定義されている暗号です。この暗号のために、計算の256ビット出力の最初の128ビット（16バイト）は、AES-128鍵であるとみなされます。"
    },
    {
      "indent": 6,
      "text": "Set ENCRYPT_KEY = HMAC-SHA256(DH_SECRET, HMAC-SHA256(SKFC, SKNC));",
      "ja": "設定ENCRYPT_KEY = HMAC-SHA256（DH_SECRET、HMAC-SHA256（SKFC、SKNC））。"
    },
    {
      "indent": 6,
      "text": "Set DECRYPT_KEY = HMAC-SHA256(DH_SECRET, HMAC-SHA256(SKNC, SKFC));",
      "ja": "DECRYPT_KEY = HMAC-SHA256（DH_SECRET、HMAC-SHA256（SKNC、SKFC））を設定します。"
    },
    {
      "indent": 3,
      "text": "The full 256 bits of ENCRYPT_KEY and DECRYPT_KEY are used in the computations in the following sections.",
      "ja": "ENCRYPT_KEYとDECRYPT_KEYの完全な256ビットは、以下のセクションでの計算に使用されています。"
    },
    {
      "indent": 0,
      "text": "4.6.4. Packet HMAC Send/Receive Keys",
      "section_title": true,
      "ja": "4.6.4。パケットHMACキーを送信/受信"
    },
    {
      "indent": 3,
      "text": "Packets can be verified that they were not corrupted or modified by appending an HMAC to the packet. Whether to use an HMAC or a simple checksum is determined during the initial keying phase using the HMAC Negotiation option (Section 4.5.2.4). Distinct HMAC keys are used for sending and receiving packets. Each end's sending key is the other end's receiving key, and vice versa.",
      "ja": "パケットは、彼らが破損しているか、パケットにHMACを付加することにより修飾されていないことを確認することができます。 HMACまたは単純なチェックサムを使用するかどうかは、HMAC交渉オプション（セクション4.5.2.4）を使用して、最初のキーイング段階で決定されます。個別のHMACキーは、パケットを送受信するために使用されています。各エンドの送信キーがもう一方の端の受信キー、およびその逆です。"
    },
    {
      "indent": 6,
      "text": "Set HMAC_SEND_KEY = HMAC_SHA256(DH_SECRET, ENCRYPT_KEY);",
      "ja": "セットHMAC_SEND_KEY = HMAC_SHA256（DH_SECRET、ENCRYPT_KEY）。"
    },
    {
      "indent": 6,
      "text": "Set HMAC_RECV_KEY = HMAC_SHA256(DH_SECRET, DECRYPT_KEY);",
      "ja": "セットHMAC_RECV_KEY = HMAC_SHA256（DH_SECRET、DECRYPT_KEY）。"
    },
    {
      "indent": 3,
      "text": "If an endpoint sets the willSendAlways flag in its HMAC Negotiation option, then it MUST send an HMAC on packets it sends with this session key.",
      "ja": "エンドポイントがそのHMAC交渉オプションでwillSendAlwaysフラグを設定した場合、それはそれは、このセッションキーを送信するパケットにHMACを送らなければなりません。"
    },
    {
      "indent": 3,
      "text": "If an endpoint's willSendAlways flag is clear but its willSendOnRequest flag is set, then it MUST send an HMAC on packets it sends with this session key if and only if the other endpoint's request flag is set.",
      "ja": "エンドポイントのwillSendAlwaysフラグがクリアされているが、そのwillSendOnRequestフラグが設定されている場合、それがあれば、このセッションキーで送信し、他のエンドポイントの要求フラグが設定されている場合にのみ、パケットにHMACを送らなければなりません。"
    },
    {
      "indent": 3,
      "text": "If a sending endpoint's willSendAlways and willSendOnRequest flags are clear, then the receiving endpoint SHOULD reject that keying component if the receiving endpoint is configured to require the sending endpoint to send HMAC.",
      "ja": "送信エンドポイントのwillSendAlwaysとwillSendOnRequestフラグがクリアされている場合は、受信エンドポイントは、受信側エンドポイントがHMACを送信する送信エンドポイントを必要とするように構成されている場合、コンポーネントをキーイングすることを拒否すべきです。"
    },
    {
      "indent": 3,
      "text": "If HMAC is negotiated to be used, the corresponding hmacLength MUST be between 4 and 32 inclusive.",
      "ja": "HMACを使用するネゴシエートされた場合、対応するhmacLengthは4と32包括の間でなければなりません。"
    },
    {
      "indent": 3,
      "text": "If HMAC is negotiated not to be used, a simple checksum is used for packet verification.",
      "ja": "HMACを使用しないで交渉されている場合は、簡単なチェックサムは、パケットの検証に使用されています。"
    },
    {
      "indent": 3,
      "text": "The Default Session Key uses the simple checksum and does not use HMAC.",
      "ja": "デフォルトのセッションキーは、単純なチェックサムを使用し、HMACを使用していません。"
    },
    {
      "indent": 0,
      "text": "4.6.5. Session Nonces",
      "section_title": true,
      "ja": "4.6.5。セッションナンス"
    },
    {
      "indent": 3,
      "text": "Session nonces are per-session, cryptographically strong secret values known only to the two endpoints of the session. They can be used for application-layer cryptographic challenges (such as signing or password verification). These nonces are a convenience being pre-shared and pre-agreed-upon in a secure manner during the initial keying handshake.",
      "ja": "セッションナンスは、セッションごとのみのセッションの2つのエンドポイントに知られている暗号的に強い秘密の値です。彼らは、（署名またはパスワード検証など）アプリケーション層の暗号化の課題のために使用することができます。これらのナンスは、最初のキーイングハンドシェイク中に、安全な方法で事前共有と事前合意されたされている便利です。"
    },
    {
      "indent": 3,
      "text": "Each end's near nonce is the other end's far nonce, and vice versa.",
      "ja": "各エンドの近くナンスは、もう一方の端の遠くナンス、およびその逆です。"
    },
    {
      "indent": 6,
      "text": "Set NEAR_NONCE = HMAC_SHA256(DH_SECRET, SKNC);",
      "ja": "設定NEAR_NONCE = HMAC_SHA256（DH_SECRET、SKNC）。"
    },
    {
      "indent": 6,
      "text": "Set FAR_NONCE = HMAC_SHA256(DH_SECRET, SKFC);",
      "ja": "設定FAR_NONCE = HMAC_SHA256（DH_SECRET、SKFC）。"
    },
    {
      "indent": 0,
      "text": "4.6.6. Session Sequence Number",
      "section_title": true,
      "ja": "4.6.6。セッションシーケンス番号"
    },
    {
      "indent": 3,
      "text": "Duplicate packets can be detected and rejected by using an optional session sequence number inside the encrypted packets. The session sequence number is a monotonically increasing unbounded integer and does not wrap. Session sequence numbers SHOULD start at zero and SHOULD increment by one for each packet sent using that session key. Implementations MUST handle session sequence numbers with no less than 64 bits of range.",
      "ja": "重複したパケットが検出され、暗号化されたパケット内の任意のセッションのシーケンス番号を使用することによって排除することができます。セッションシーケンス番号は単調に増加する無限の整数で、折り返されません。セッションシーケンス番号は0から始まりすべきであり、そのセッションキーを使用して送信されたパケットごとに1ずつ増加すべきです。実装は、範囲のない64ビット未満でセッションシーケンス番号を処理する必要があります。"
    },
    {
      "indent": 3,
      "text": "If an endpoint's willSendAlways flag in its Session Sequence Number Negotiation option (Section 4.5.2.5) is set, then it MUST send a session sequence number in packets it sends with this session key.",
      "ja": "そのセッションシーケンス番号交渉オプション（セクション4.5.2.5）でのエンドポイントのwillSendAlwaysフラグが設定されている場合、それはこのセッションキーで送信したパケットのセッションシーケンス番号を送らなければなりません。"
    },
    {
      "indent": 3,
      "text": "If an endpoint's willSendAlways flag is clear but its willSendOnRequest flag is set, then it MUST send a session sequence number on packets it sends with this session key if and only if the other endpoint's request flag is set.",
      "ja": "エンドポイントのwillSendAlwaysフラグがクリアされているが、そのwillSendOnRequestフラグが設定されている場合、それがあれば、このセッションキーで送信し、他のエンドポイントの要求フラグが設定されている場合にのみ、パケットのセッションシーケンス番号を送らなければなりません。"
    },
    {
      "indent": 3,
      "text": "If a sending endpoint's willSendAlways and willSendOnRequest flags are clear, then the receiving endpoint SHOULD reject that keying component if the receiving endpoint is configured to require the sending endpoint to send session sequence numbers.",
      "ja": "送信エンドポイントのwillSendAlwaysとwillSendOnRequestフラグがクリアされている場合は、受信エンドポイントは、受信側エンドポイントがセッションシーケンス番号を送信する送信エンドポイントを必要とするように構成されている場合、コンポーネントをキーイングすることを拒否すべきです。"
    },
    {
      "indent": 3,
      "text": "The Default Session Key does not use session sequence numbers.",
      "ja": "デフォルトのセッションキーはセッションのシーケンス番号を使用していません。"
    },
    {
      "indent": 0,
      "text": "4.7. Packet Encryption",
      "section_title": true,
      "ja": "4.7。パケット暗号化"
    },
    {
      "indent": 3,
      "text": "This section describes the concrete syntax and operational semantics of RTMFP packet encryption for this Cryptography Profile.",
      "ja": "このセクションでは、この暗号化プロファイル用のRTMFPパケットの暗号化の具体的な構文と操作的意味論について説明します。"
    },
    {
      "indent": 0,
      "text": "4.7.1. Cipher",
      "section_title": true,
      "ja": "4.7.1。暗号"
    },
    {
      "indent": 3,
      "text": "This profile defines AES-128 [AES] in CBC [CBC] mode as the only cipher. Extensions to this profile can specify and negotiate additional ciphers and modes by defining certificate and keying component options and associated semantics.",
      "ja": "このプロファイルは、暗号としてAES-128 [AES] CBCにおける[CBC]モードを定義します。このプロファイルへの拡張は、証明書を定義し、コンポーネントのオプションと関連する意味をキーイングすることによって、追加の暗号およびモードを指定し、交渉することができます。"
    },
    {
      "indent": 3,
      "text": "For AES-128-CBC, the initialization vector (IV) for each packet is 16 zero bytes. The IV is not included in the packet.",
      "ja": "AES-128-CBCのために、各パケットのための初期化ベクトル（IV）は、16ゼロバイトです。 IVは、パケットに含まれていません。"
    },
    {
      "indent": 0,
      "text": "4.7.2. Format",
      "section_title": true,
      "ja": "4.7.2。フォーマット"
    },
    {
      "indent": 3,
      "text": "The Encrypted Packet is the encryptedPacket field of an RTMFP Multiplex packet (Section 2.2.2 of RFC 7016); that is, the portion of the Multiplex packet following the scrambled session ID. The Encrypted Packet has the following format:",
      "ja": "暗号化されたパケットは、RTMFP多重化パケット（RFC 7016のセクション2.2.2）のencryptedPacketフィールドです。すなわち、スクランブルセッションID次の多重化パケットの部分です。暗号化されたパケットの形式は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "+----------------+     +----------------+~~~~~~~~~~~~~~~~~~~~~~~+\n|  CBC Block 1   | ... |  CBC Block N   |     truncatedHMAC     |\n+----------------+     +----------------+~~~~~~~~~~~~~~~~~~~~~~~+\n^                                       ^                       ^\n|     Zero or more AES-128 chained      | hmacLength bytes long |\n+--------    cipher blocks   -----------+---  (may be zero)  ---+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct flashProfileEncryptedPacket_t\n{\n    if(HMAC is being used)\n        hmacLength = negotiated length;\n    else\n        hmacLength = 0;",
      "raw": true
    },
    {
      "indent": 7,
      "text": "struct\n{\n    iv[16 bytes] = { 0 };\n    blockCount = 0;\n    while((remainder() > hmacLength) && (remainder() >= 16))\n    {\n        uint8_t cbcBlock[16];\n        blockCount++;\n    }\n} chainedCipherBlocks :variable*16*8;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "    if(HMAC is being used)\n    {\n        if(remainder() == hmacLength)\n            uint8_t truncatedHMAC[hmacLength];\n        else\n            packetVerificationFailed();\n    }\n    else if(remainder() > 0)\n        packetVerificationFailed();\n} :encryptedPacket.length*8;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "cbcBlock: The next AES-128-CBC block.",
      "ja": "cbcBlock：次のAES-128-CBCブロック。"
    },
    {
      "indent": 3,
      "text": "chainedCipherBlocks: The concatenation of every cipher block in the packet (over which the HMAC is computed).",
      "ja": "chainedCipherBlocks：パケット内のすべての暗号ブロックの連結（HMACが計算される上）。"
    },
    {
      "indent": 3,
      "text": "truncatedHMAC: If HMAC was negotiated to be used (Section 4.5.2.4), this field is set to the first negotiated hmacLength bytes of the HMAC of the chainedCipherBlocks.",
      "ja": "truncatedHMACは：HMACは、（セクション4.5.2.4）を使用するネゴシエートされた場合、このフィールドはchainedCipherBlocksのHMACの最初のネゴシエートhmacLengthバイトに設定されています。"
    },
    {
      "indent": 3,
      "text": "The plaintext data before encryption or after decryption has the following format:",
      "ja": "暗号化前または復号後の平文データの形式は次のとおりです。"
    },
    {
      "indent": 3,
      "text": " 0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7\n+~~~~~~~~~~~~~/~+\n| SSEQ (opt.) \\ |\n+~~~~~~~~~~~~~/~+\n+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+\n|        Checksum (opt.)        |\n+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+\n|                        Plain RTMFP Packet                     |\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct flashProfilePlainPacket_t\n{\n    if(session sequence numbers being used)\n        vlu_t sessionSequenceNumber :variable*8; // SSEQ\n    if(HMAC not being used)\n        uint16_t checksum;\n    packet_t plainRTMFPPacket :variable*8;\n} :chainedCipherBlocks.blockCount*16*8;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "sessionSequenceNumber: If session sequence numbers were negotiated to be used (Section 4.6.6), this field is present and is the VLU session sequence number of this packet.",
      "ja": "sessionSequenceNumber：セッションシーケンス番号は（4.6.6）を使用するために交渉された場合は、このフィールドが存在し、このパケットのVLUセッションシーケンス番号です。"
    },
    {
      "indent": 3,
      "text": "checksum: If HMAC was not negotiated to be used, this field is present and is the simple checksum (Section 4.7.3.1) of the remaining bytes of this structure.",
      "ja": "チェックサムは：HMACを使用する交渉されなかった場合は、このフィールドが存在し、この構造の残りのバイトの単純なチェックサム（セクション4.7.3.1）です。"
    },
    {
      "indent": 3,
      "text": "plainRTMFPPacket: The (plain, unencrypted) RTMFP Packet (Section 2.2.4 of RFC 7016) plus any necessary padding.",
      "ja": "plainRTMFPPacket：プラス任意の必要なパディング（普通、暗号化されていない）RTMFPパケット（RFC 7016のセクション2.2.4）。"
    },
    {
      "indent": 3,
      "text": "When assembling this structure and prior to calculating the checksum (if present), if the structure's total length is not an integer multiple of 16 bytes (the AES cipher block size), pad the end of plainRTMFPPacket with as many bytes having a value of 0xff as are needed to bring the structure's total length to an integer multiple of 16 bytes. The receiver's RTMFP Packet parser (Section 2.2.4 of RFC 7016) will consume this padding.",
      "ja": "この構成及び従来構造の全長は16バイト（AES暗号ブロックサイズ）、パッドなどの多くのバイトが0xFFの値を有するplainRTMFPPacketの端の整数倍でない場合、（存在する場合）チェックサムを計算することを組み立てる際16バイトの整数倍に構造体の全体の長さをもたらすために必要とされます。レシーバのRTMFPパケットパーサ（RFC 7016のセクション2.2.4）は、このパディングを消費します。"
    },
    {
      "indent": 0,
      "text": "4.7.3. Verification",
      "section_title": true,
      "ja": "4.7.3。検証"
    },
    {
      "indent": 3,
      "text": "In RTMFP, the Cryptography Profile is responsible for packet verification. In this profile, packets are verified with an HMAC or a simple checksum, depending on the configuration of the endpoints, and optionally verified against replay or duplication using session sequence numbers. The simple checksum is inside the encrypted packet, so it becomes essentially a 16-bit cryptographic checksum.",
      "ja": "RTMFPでは、暗号化プロファイルは、パケット検証を担当しています。このプロファイルでは、パケットは、エンドポイントの構成に応じて、HMACまたは単純なチェックサムと検証され、そして必要に応じてセッションのシーケンス番号を使用して再生または複製に対して検証します。単純なチェックサムは暗号化されたパケットの内部にあるので、本質的に16ビットの暗号チェックサムとなります。"
    },
    {
      "indent": 0,
      "text": "4.7.3.1. Simple Checksum",
      "section_title": true,
      "ja": "4.7.3.1。シンプルなチェックサム"
    },
    {
      "indent": 3,
      "text": "The simple checksum is the 16-bit ones' complement of the 16-bit ones' complement sum of all 16-bit (2 bytes in network byte order) words to be checked. If there are an odd number of bytes to be checked, then for purposes of this checksum, treat the last byte as the lower 8 bits of a 16-bit word whose upper 8 bits are 0. This is also known as the \"Internet Checksum\" [RFC1071].",
      "ja": "単純なチェックサムがチェックされるすべての16ビット（ネットワークバイト順に2バイト）ワードの補数合計16ビットのもの、16ビットのものの相補体です。チェックされるべきバイトの奇数がある場合、このチェックサムの目的のために、上位8ビット0である。これはまた、「インターネットチェックサムとして知られている16ビット・ワードの下位8ビットとして最後のバイトを治療\"[RFC1071]。"
    },
    {
      "indent": 3,
      "text": "When present, the checksum is calculated over all bytes of the plaintext packet starting after the checksum field through the end of the plain packet. It cannot be calculated until the plain packet is padded, if necessary, to bring its length to an integer multiple of 16 bytes (the AES cipher block size). The session sequence number field, if present, and the checksum field itself are not included in the checksum.",
      "ja": "存在する場合、チェックサムはプレーンパケットの終了を介してチェックサムフィールドの後に開始平文パケットのすべてのバイトにわたって計算されます。普通パケットがパディングされるまで、必要に応じて、16バイト（AES暗号ブロックサイズ）の整数倍にその長さを持って、算出することができません。セッションシーケンス番号フィールドは、存在する場合、およびチェックサムフィールド自体は、チェックサムに含まれていません。"
    },
    {
      "indent": 3,
      "text": "On receiving a packet being verified with a checksum: calculate the checksum over all the bytes of the plaintext packet following the checksum field and compare the checksum to the value in the checksum field. If they match, the packet is verified; if they do not match, the packet is corrupt and MUST be discarded as though it was never received.",
      "ja": "チェックサムと検証されたパケットを受信する：チェックサムフィールド以下の平文パケットの全バイトにわたってチェックサムを計算し、チェックサムフィールドの値をチェックサムを比較します。それらが一致した場合、パケットが検証されます。それらが一致しない場合、パケットが破損していると、それが受信されなかったかのように捨てなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.7.3.2. HMAC",
      "section_title": true,
      "ja": "4.7.3.2。 HMAC"
    },
    {
      "indent": 3,
      "text": "When present, the HMAC field is the last hmacLength bytes of the packet and is calculated over all of the encrypted cipher blocks of the packet preceding the HMAC field. The value of the HMAC field is the first hmacLength bytes of the HMAC-SHA256 of the checked data, using the computed HMAC keys (Section 4.6.4) and negotiated hmacLength (Section 4.5.2.4). Note each endpoint independently specifies the length of the HMAC it will send via its hmacLength field.",
      "ja": "存在する場合、HMACフィールドは、パケットの最後hmacLengthバイトであり、HMACフィールドに先行するパケットの暗号化された暗号ブロックの全てに対して計算されます。 HMACフィールドの値は、計算されたHMACキー（セクション4.6.4）とネゴシエートhmacLength（セクション4.5.2.4）を使用して、チェックされたデータのHMAC-SHA256の第hmacLengthバイトです。各エンドポイントは、独立して、そのhmacLengthフィールドを経由して送信されますHMACの長さを指定してください。"
    },
    {
      "indent": 3,
      "text": "When an endpoint has negotiated to send an HMAC, it encrypts the data blocks, computes the HMAC over the encrypted data blocks using its HMAC_SEND_KEY, and appends the first hmacLength bytes of that hash after the final encrypted data block.",
      "ja": "エンドポイントはHMACを送信するようにネゴシエートした場合、それは、データブロックを暗号化し、そのHMAC_SEND_KEYを使用して暗号化されたデータ・ブロック上HMACを計算し、最終的な暗号化されたデータブロックの後に、そのハッシュの最初hmacLengthバイトを付加します。"
    },
    {
      "indent": 3,
      "text": "When an endpoint has negotiated to receive an HMAC, the endpoint computes the HMAC over the encrypted data blocks using its HMAC_RECV_KEY and then compares the first receive hmacLength bytes of the computed HMAC to the HMAC field in the packet. If they are identical, the packet is verified; if they are not identical, the packet is corrupt and MUST be discarded as though it was never received.",
      "ja": "エンドポイントがHMACを受信するようにネゴシエートした場合、エンドポイントはそのHMAC_RECV_KEYを使用して暗号化されたデータ・ブロック上HMACを計算した後、最初のパケットにHMACフィールドに計算されたHMACのhmacLengthバイトを受け取るとを比較します。それらが同一である場合、パケットが検証されます。それらが同一でない場合、パケットが破損していると、それが受信されなかったかのように捨てなければなりません。"
    },
    {
      "indent": 3,
      "text": "HMAC and simple checksum verification are mutually exclusive.",
      "ja": "HMACと簡単なチェックサム検証は、相互に排他的です。"
    },
    {
      "indent": 0,
      "text": "4.7.3.3. Session Sequence Number",
      "section_title": true,
      "ja": "4.7.3.3。セッションシーケンス番号"
    },
    {
      "indent": 3,
      "text": "Session sequence numbers are used to detect and reject a packet that was duplicated in the network or replayed by an attacker and to ensure the first chained cipher block of every packet is unique, in lieu of a full-block initialization vector. Sequence numbers start at zero, increase by one for each packet sent in the session, do not wrap, and do not repeat.",
      "ja": "セッションのシーケンス番号が検出し、攻撃者によってネットワークに複製または再生されたパケットを拒否し、すべてのパケットの最初の連鎖暗号ブロックは、フルブロック初期化ベクトルの代わりに、一意であることを確認するために使用されます。シーケンス番号は、セッションで送信されたパケットごとに1ずつ増加、0から始まり、ラップしていない、と繰り返さないでください。"
    },
    {
      "indent": 3,
      "text": "When session sequence numbers are negotiated to be used, the receiver MUST allow for packets to be reordered in the network by up to at least 32 sequence numbers; note, however, that reordering by more than three packets can trigger loss detection and retransmission by negative acknowledgement, just as with TCP, and is therefore not likely to occur in the real Internet.",
      "ja": "セッションシーケンス番号を使用するネゴシエートされた場合、受信機は、少なくとも32個のシーケンス番号まですることにより、ネットワークに並べ替えされるパケットを許容しなければなりません。ノートでは、しかし、以上の3つのパケットによってその並べ替えはちょうどTCPと同じように、否定応答による損失検出と再送をトリガすることができますので、実際のインターネットに発生する可能性はありません。"
    },
    {
      "indent": 3,
      "text": "[RFC4302], [RFC4303], and [RFC6479] describe Anti-Replay Window methods that can be employed to detect duplicate sequence numbers. Other methods are possible.",
      "ja": "[RFC4302]、[RFC4303]及び[RFC6479]重複するシーケンス番号を検出するために使用することができるアンチリプレイウィンドウの方法を記載しています。他の方法も可能です。"
    },
    {
      "indent": 3,
      "text": "Any packet received having a session sequence number that was already seen in that session, either directly or by being less than the lowest sequence number in the Anti-Replay Window, is a duplicate and MUST be discarded as though never received.",
      "ja": "任意のパケットが既に直接またはアンチリプレイウィンドウの最小シーケンス番号未満であることによって、そのセッションで見られたセッションのシーケンス番号を有する受信し、重複して受信したことがないかのように捨てなければなりません。"
    },
    {
      "indent": 0,
      "text": "5. Flash Communication",
      "section_title": true,
      "ja": "5.フラッシュ・コミュニケーション"
    },
    {
      "indent": 3,
      "text": "The Flash platform uses RTMP [RTMP] messages for media streaming and communication. This section describes how to transport RTMP messages over RTMFP flows and additional messages and semantics unique to this transport.",
      "ja": "フラッシュプラットフォームは、メディアストリーミングや通信のためのRTMP [RTMP]のメッセージを使用しています。このセクションでは、このトランスポートに固有のRTMFPフローや追加のメッセージと意味論上のRTMPメッセージを転送する方法について説明します。"
    },
    {
      "indent": 0,
      "text": "5.1. RTMP Messages",
      "section_title": true,
      "ja": "5.1。 RTMPメッセージ"
    },
    {
      "indent": 3,
      "text": "An RTMP message comprises a virtual header and a payload. The virtual header comprises a Message Type, a Payload Length, a Timestamp, and a Stream ID. The format of the payload is dependent on the type of message.",
      "ja": "RTMPメッセージは、仮想ヘッダおよびペイロードを含みます。仮想ヘッダは、メッセージタイプ、ペイロード長、タイムスタンプ、およびストリームIDを備えます。ペイロードの形式は、メッセージのタイプに依存しています。"
    },
    {
      "indent": 3,
      "text": "An RTMP message is mapped onto a lower transport layer, such as RTMP Chunk Stream [RTMP] or RTMFP. RTMP messages were initially designed along with, and for transport on, RTMP Chunk Stream. This design constrains the possible values of RTMP message header fields. In particular:",
      "ja": "RTMPメッセージは、RTMPチャンクストリーム[RTMP]またはRTMFPとして、下位のトランスポート層にマッピングされます。 RTMPメッセージは、最初に一緒に設計された、として、RTMPチャンクストリーム上の輸送のため。この設計は、RTMPメッセージヘッダーフィールドの可能な値を制約します。特に："
    },
    {
      "indent": 6,
      "text": "Message Type is 8 bits wide, and is therefore constrained to values from 0 to 255 inclusive;",
      "ja": "メッセージタイプは8ビット幅であるので、0から255までに値に制約されます。"
    },
    {
      "indent": 6,
      "text": "Payload Length is 24 bits wide, so messages can be at most 16777215 bytes long;",
      "ja": "メッセージは最大で16777215バイト長とすることができるので、ペイロード長は、24ビット幅です。"
    },
    {
      "indent": 6,
      "text": "Timestamp is 32 bits wide, so timestamps range from 0 to 4294967295 and wrap around;",
      "ja": "タイムスタンプは、0から4294967295までの範囲とラップアラウンドので、タイムスタンプは、32ビット幅です。"
    },
    {
      "indent": 6,
      "text": "Stream ID is 24 bits wide, and is therefore constrained to values from 0 to 16777215 inclusive.",
      "ja": "ストリームIDは24ビット幅であるので、0から16777215包括的なまでの値に制限されます。"
    },
    {
      "indent": 3,
      "text": "RTMP Chunk Stream Protocol Control messages (message types 1, 2, 3, 5, and 6) are not used when transporting RTMP messages in RTMFP flows. Messages of those types SHOULD NOT be sent and MUST be ignored.",
      "ja": "RTMPチャンクストリームプロトコル制御メッセージ（メッセージタイプ1、2、3、5、及び6）RTMFPフローにRTMPメッセージを搬送する際に使用されません。これらのタイプのメッセージを送るべきではありませんし、無視しなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.1.1. Flow Metadata",
      "section_title": true,
      "ja": "5.1.1。フローのメタデータ"
    },
    {
      "indent": 3,
      "text": "All messages in RTMFP are transported in flows. In this profile, an RTMFP flow for RTMP messages carries the messages for exactly one RTMP Stream ID. Multiple flows can carry messages for the same Stream ID; for example, the video and audio messages of a stream could be sent on separate flows, allowing the audio to be given higher transmission priority.",
      "ja": "RTMFPのすべてのメッセージが流れに輸送されます。このプロファイルでは、RTMPメッセージのRTMFPの流れは、1つのRTMPストリームIDのメッセージを運びます。複数のフローは同じストリームIDのメッセージを伝えることができます。例えば、ストリームの映像及び音声メッセージは、音声がより高い送信優先度を与えることを可能にする、別のフロー上で送信することができます。"
    },
    {
      "indent": 3,
      "text": "The User Metadata for flows in this profile begins with a distinct signature to distinguish among different kinds of flows. The User Metadata for a flow used for RTMP messages begins with the two-character signature \"TC\".",
      "ja": "このプロファイルでフローのユーザメタデータは、フローの異なる種類を区別するために異なるシグネチャから始まります。 RTMPメッセージのために使用されるフローのためのユーザメタデータは、2文字の署名「TC」で始まります。"
    },
    {
      "indent": 3,
      "text": "The Stream ID is encoded in the flow's User Metadata so that it doesn't need to be sent with each message.",
      "ja": "それはそれぞれのメッセージを送信する必要がないように、ストリームIDは、フローのユーザメタデータに符号化されています。"
    },
    {
      "indent": 3,
      "text": "The sender can have a priori knowledge about the kind of media it intends to send on a flow and its intended use and can give the receiver a hint as to whether messages should be delivered as soon as possible or in their original queuing order. For example, the sender might be sending real-time, delay-sensitive audio messages on a flow, and hint that the receiver should take delivery of the messages on that flow as soon as they arrive in the network, to reduce the end-to-end latency of the audio.",
      "ja": "送信者は、それが流れとその使用目的に送信しようとメッセージをできるだけ早くたり、元のキューイング順に配信するか否かを受信機にヒントを与えることができ、メディアの種類についての事前知識を持つことができます。例えば、送信者は、流れにリアルタイムで遅延に敏感な音声メッセージを送信し、受信機は、エンドツーエンドを減らすために、できるだけ早く彼らはネットワークに到着すると、そのフロー上のメッセージの配信を取るべきであるというヒントかもしれませんオーディオの末端の待ち時間。"
    },
    {
      "indent": 3,
      "text": "The receiver can choose to take delivery of messages on flows as soon as they arrive in the network or in the messages' original queuing order. A receiver that chooses to take delivery of messages as soon as they arrive in the network MUST be prepared for the messages to arrive out-of-order. For example, a receiver may choose not to render a newly received audio message having a timestamp earlier than the most recently rendered audio timestamp.",
      "ja": "受信機は、すぐに彼らはネットワークまたはメッセージの元のキューイング順に到着したフローにメッセージの配信を取ることを選択することができます。ネットワークにできるだけ早く彼らが到着すると、メッセージの配信を取ることを選択した受信機は、アウトオブオーダー到着するメッセージのために準備しなければなりません。例えば、受信機は、最近、レンダリングオーディオタイムスタンプより早いタイムスタンプを持つ新たに受信した音声メッセージをレンダリングしないことを選択することができます。"
    },
    {
      "indent": 3,
      "text": "The sender can choose to abandon a message that it has queued in a flow before the message has been delivered to the receiver. For example, the sender may abandon a real-time, delay-sensitive audio message that has not been delivered within one second, to avoid spending transmission resources on stale media that is no longer relevant.",
      "ja": "送信者は、メッセージが受信者に配信された前に、それは流れの中でキューに入れられたメッセージを放棄することを選択できます。例えば、送信者は、もはや関連している古いメディアへの支出の送信リソースを避けるために、1秒以内に配信されていないリアルタイム、遅延に敏感な音声メッセージを放棄することができます。"
    },
    {
      "indent": 3,
      "text": "Note: A gap will cause a delay at the receiver of at least one round-trip time if the receiver is taking delivery of messages in original queuing order.",
      "ja": "注意：受信機は、元のキューイング順序でメッセージの配信を取っている場合、ギャップは、少なくとも一つのラウンドトリップ時間の受信機での遅延が発生します。"
    },
    {
      "indent": 3,
      "text": " 0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+~~~~~~~~~~~~~/~+\n|               |               |         |S|r|R|             \\ |\n|   0x54  'T'   |   0x43  'C'   |   rsv   |I|s|X|   streamID  / |\n|               |               |         |D|v|I|             \\ |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+~~~~~~~~~~~~~/~+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct RTMPMetadata_t\n{\n    uint8_t signature[2] == { 'T', 'C' };\n    uintn_t reserved1       :5; // rsv\n    bool_t  streamIDPresent :1; // SID\n    uintn_t reserved2       :1; // rsv\n    uintn_t receiveIntent   :1; // RXI\n        // 0: original queuing order, 1: network arrival order\n    if(streamIDPresent)\n        vlu_t   streamID        :variable*8;\n} :variable*8;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "signature: Metadata signature for RTMP message flows, being the two UTF-8 coded characters \"TC\".",
      "ja": "署名：RTMPメッセージのメタデータ署名は、二つのUTF-8コード化された文字「TC」である、流れます。"
    },
    {
      "indent": 3,
      "text": "streamIDPresent: A boolean flag indicating whether the streamID field is present. In this profile, this flag MUST be set.",
      "ja": "streamIDPresent：streamIDでフィールドが存在するかどうかを示すブールフラグ。このプロファイルでは、このフラグを設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "receiveIntent: A hint by the sender as to the best order in which to take delivery of messages from the flow. A value of zero indicates a hint that the flow's messages should be received in the order they were originally queued by the sender (that is, in ascending sequence number order); a value of one indicates a hint that the flow's messages should be received in the order they arrive in the network, even if there are sequence number gaps or reordering. Network arrival order is typically hinted for live, delay-sensitive flows, such as for audio media. To take delivery of a message as soon as it arrives in the network: receive it from the receiving flow's RECV_BUFFER as soon as it becomes complete (Section 3.6.3.3 of RFC 7016), and remove it from the RECV_BUFFER. Section 3.6.3.3 of RFC 7016 describes how to take delivery of messages in original queuing order.",
      "ja": "receiveIntent：フローからのメッセージの配信を取るためにする最良の順序として送信者によってヒント。ゼロの値は、フローのメッセージは、それらが元々（即ち、シーケンス番号の昇順で）送信者によってキューに入れられた順序で受信されるべきであるというヒントを示しています。一方の値は、シーケンス番号のギャップまたは並べ替えが存在する場合でも、フローのメッセージは、それらがネットワークに到着順に受信されなければならないというヒントを示しています。ネットワーク到着順は、一般的なオーディオメディア用としてのライブ、遅延に敏感なフローのために示唆されます。すぐにそれがネットワークに到着すると、メッセージの配信を取るために：それは完全に（RFC 7016のセクション3.6.3.3）になるとすぐに受信フローのRECV_BUFFERからそれを受け取り、そしてRECV_BUFFERから取り外します。 RFC 7016のセクション3.6.3.3は、元のキューイング順序でメッセージの配信を取る方法について説明します。"
    },
    {
      "indent": 3,
      "text": "streamID: If the streamIDPresent flag is set, this field is present and is the RTMP stream ID to which the messages in this flow belong. In this profile, this field MUST be present.",
      "ja": "streamIDで：streamIDPresentフラグが設定されている場合は、このフィールドが存在し、この流れの中のメッセージが属するRTMPストリームIDです。このプロファイルでは、このフィールドが存在しなければなりません。"
    },
    {
      "indent": 3,
      "text": "A receiver SHOULD reject an RTMP message flow if its streamIDPresent flag is clear. This profile doesn't define a stream mapping for this case.",
      "ja": "そのstreamIDPresentフラグがクリアされている場合、受信機は、RTMPメッセージフローを拒否すべきです。このプロファイルは、この場合のストリームのマッピングを定義していません。"
    },
    {
      "indent": 3,
      "text": "Derived or composed profiles can define additional flow types and corresponding metadata signatures. A receiver SHOULD reject a flow having an unrecognized metadata signature.",
      "ja": "派生または構成プロファイルは、追加のフロータイプおよび対応するメタデータの署名を定義することができます。受信機は、認識されないメタデータの署名を有するフローを拒否すべきです。"
    },
    {
      "indent": 0,
      "text": "5.1.2. Message Mapping",
      "section_title": true,
      "ja": "5.1.2。メッセージマッピング"
    },
    {
      "indent": 3,
      "text": "This section describes the format of an RTMP message (Section 5.1) in an RTMFP flow.",
      "ja": "このセクションでは、RTMFPフローのRTMPメッセージ（セクション5.1）のフォーマットを記述する。"
    },
    {
      "indent": 3,
      "text": " 0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+\n|  messageType  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                           timestamp                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                         messagePayload                        |\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~/",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct RTMPMessage_t\n{\n    uint8_t  messageType;\n    uint32_t timestamp;\n    uint8_t  messagePayload[remainder()];\n} :flowMessageLength*8;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "messageType: The RTMP Message Type;",
      "ja": "messageType：RTMPメッセージタイプ。"
    },
    {
      "indent": 3,
      "text": "timestamp: The RTMP Timestamp, in network byte order;",
      "ja": "タイムスタンプ：RTMPタイムスタンプ、ネットワークバイト順で、"
    },
    {
      "indent": 3,
      "text": "messagePayload: The payload of the RTMP message;",
      "ja": "messagePayload：RTMPメッセージのペイロード。"
    },
    {
      "indent": 3,
      "text": "payload length: The RTMP message payload length is inferred from the length of the RTMFP message;",
      "ja": "ペイロード長：RTMPメッセージペイロード長がRTMFPメッセージの長さから推測されます。"
    },
    {
      "indent": 3,
      "text": "Stream ID: The Stream ID for this message is taken from the metadata of the flow on which this message was received.",
      "ja": "ストリームID：このメッセージのストリームIDは、このメッセージを受信したフローのメタデータから取られます。"
    },
    {
      "indent": 0,
      "text": "5.2. Flow Synchronization",
      "section_title": true,
      "ja": "5.2。フローの同期"
    },
    {
      "indent": 3,
      "text": "RTMFP flows are independent and have no inter-flow ordering guarantee. RTMP was designed for transport over a single, reliable, strictly ordered byte stream. Some RTMP message semantics take advantage of this ordering; for example, a Stream EOF User Control event must not be processed until after all media messages for the corresponding stream have been received. Flow Synchronization messages provide a barrier to align message delivery across flows when required by RTMP semantics.",
      "ja": "RTMFPの流れは独立しており、何の間の流れの順序保証がありません。 RTMPは、単一の、信頼性の高い、厳密に注文したバイトストリーム上での輸送のために設計されました。いくつかのRTMPメッセージの意味は、この順序付けを活用します。例えば、ストリームEOFユーザーコントロールのイベントは、対応するストリームのためのすべてのメディアメッセージが受信された後まで処理されてはなりません。フロー同期メッセージは、RTMPセマンティクスによって必要とされる場合のフローを横切ってメッセージ配信を整列するためのバリアを提供します。"
    },
    {
      "indent": 3,
      "text": "A Flow Synchronization message is coded as a User Control event message (Type 4) having Event Type 34. Message timestamps are ignored and MAY be set to 0.",
      "ja": "イベントの種類34.メッセージのタイムスタンプを有するユーザ制御イベントメッセージ（タイプ4）は無視され、0に設定されるようにフロー同期メッセージが符号化されます。"
    },
    {
      "indent": 3,
      "text": " 0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+\n|       4       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                           timestamp                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|         eventType = 34        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                             syncID                            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                             count                             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct flowSyncUserControlMessagePayload_t\n{\n    uint16_t eventType = 34;\n    uint32_t syncID;\n    uint32_t count;\n} :10*8;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "eventType: The RTMP User Control Message Event Type. Flow Synchronization messages have type 34 (0x22);",
      "ja": "eventTypeを：RTMPユーザーコントロールメッセージイベントの種類。フロー同期メッセージは、タイプ34（ただし0x22）を持っています。"
    },
    {
      "indent": 3,
      "text": "syncID: The identifier for this barrier;",
      "ja": "syncID：この障壁のための識別子。"
    },
    {
      "indent": 3,
      "text": "count: The number of flows being synchronized by syncID. This field MUST be at least 1 and SHOULD be at least 2.",
      "ja": "カウント：フロー数はsyncIDによって同期されています。このフィールドには、少なくとも1でなければなりませんし、少なくとも2であるべきです。"
    },
    {
      "indent": 3,
      "text": "On receipt of a Flow Synchronization message, a receiver SHOULD suspend receipt of further messages on that flow until count Flow Synchronization messages (including this one) with the same syncID have been received on flows in the same flow association tree.",
      "ja": "同じsyncIDと（これを含む）カウントフロー同期メッセージが同一のフロー関連ツリーにフロー上で受信されるまでのフロー同期化メッセージの受信時に、受信機は、そのフローにさらにメッセージの受信を中断すべきです。"
    },
    {
      "indent": 3,
      "text": "Example: Consider flows F1 and F2 in the same NetConnection carrying messages M, and let Sync(syncID,count) denote a Flow Synchronization message.",
      "ja": "例：検討はMメッセージを運ぶ同一のNetConnectionでF1とF2を流れ、同期（syncID、カウント）がフロー同期メッセージを示すものとします。"
    },
    {
      "indent": 13,
      "text": "                          |                |\nF1: M1  M2  M4  Sync(8,2) | Sync(13,2).....| M7\n                          |                |\nF2:   M3  Sync(8,2).......| M5  Sync(13,2) | M6\n                          |                |\n                      Barrier 8        Barrier 13",
      "raw": true
    },
    {
      "indent": 14,
      "text": "Figure 2: Example Flow Synchronization Barriers",
      "ja": "図2：例のフロー同期の障壁"
    },
    {
      "indent": 3,
      "text": "Flow Synchronization messages form a delivery barrier to impart at least a partial message ordering across flows. In this example, message M5 comes after M1..4 and before M6..7; however, M3 could be delivered before or after any of M1, M2, or M4, and M6 could come before or after M7.",
      "ja": "フロー同期メッセージは、流れを横切る少なくとも部分的なメッセージの順序を付与するために、送達障壁を形成します。この例では、メッセージM5はM1..4後とM6..7の前に来ます。しかし、M3はM1、M2、またはM4のいずれかの前または後にお届けすることができ、M6は、M7の前または後に来ることができました。"
    },
    {
      "indent": 3,
      "text": "Flow Synchronization can cause a priority inversion; therefore, it SHOULD NOT be used except when necessary to preserve RTMP ordering semantics.",
      "ja": "フロー同期は優先順位の逆転を引き起こす可能性があります。したがって、それはRTMP注文のセマンティクスを保護するために必要な場合を除き、使用されるべきではありません。"
    },
    {
      "indent": 0,
      "text": "5.3. Client-to-Server Connection",
      "section_title": true,
      "ja": "5.3。クライアントからサーバーへの接続"
    },
    {
      "indent": 3,
      "text": "The client connects to a server. The connection comprises one main control flow in each direction from client to server and from server to client for NetConnection messages, and zero or more flows in each direction for NetStream media messages. NetStream flows may come and go naturally over time according to media transport needs. An exception on a NetConnection control sending flow indicates the closure by the other end of the NetConnection and all associated NetStreams.",
      "ja": "クライアントがサーバに接続します。接続は、のNetConnectionメッセージのサーバに、サーバからクライアントへのクライアントから各方向に1つのメインの制御フロー、およびNetStreamメディアメッセージの各方向におけるゼロ以上のフローを含みます。 NetStreamのフローが来て、メディアの輸送ニーズに応じて時間をかけて自然になることがあります。フロー送信のNetConnectionコントロールの例外がNetConnectionオブジェクトと関連するすべてのNetStreamsの他端による閉鎖を示します。"
    },
    {
      "indent": 3,
      "text": "The client MUST NOT use the same client certificate for more than one server connection; that is, a client's peer ID MUST NOT be reused.",
      "ja": "クライアントは、複数のサーバーの接続のための同じクライアント証明書を使用してはなりません。つまり、クライアントのピアIDを再利用してはいけません。"
    },
    {
      "indent": 0,
      "text": "5.3.1. Connecting",
      "section_title": true,
      "ja": "5.3.1。接続"
    },
    {
      "indent": 3,
      "text": "The client desires a connection to a server having an RTMFP URI, for example, \"rtmfp://server.example.com/app/instance\". The client gathers one or more initial candidate addresses for the server named in the URI (for example, by using the Domain Name System (DNS)",
      "ja": "クライアントがRTMFP URI、例えば、「：//server.example.com/app/instance RTMFP」を持つサーバへの接続を望んでいます。クライアントは、（例えば、ドメインネームシステム（DNS）を使用して、URIで指定されたサーバーごとに1つのまたは複数の初期の候補アドレスを収集します"
    },
    {
      "indent": 3,
      "text": "[RFC1035]). The client creates an EPD having an Ancillary Data option (Section 4.4.2.2) encoding the URI. The client initiates an RTMFP session to the one or more candidate addresses using the EPD.",
      "ja": "[RFC1035]）。クライアントは、URIをエンコードする補助データオプション（セクション4.4.2.2）を有するEPDを作成します。クライアントは、EPDを使用して、1つのまたは複数の候補アドレスにRTMFPセッションを開始します。"
    },
    {
      "indent": 3,
      "text": "When the session transitions to the S_OPEN state, the client opens a new flow in that session for Stream ID 0 and Receive Intent 0 \"original queuing order\". This is the client's NetConnection main control flow. The client sends an RTMP \"connect\" command on the flow and waits for a response or exception.",
      "ja": "S_OPEN状態にセッション移行は、クライアントがストリームID 0のために、そのセッションで新しいフローを開き、テント0「元キューイング順序」を受信した場合。これは、クライアントのメインのNetConnection制御フローです。クライアントは、RTMPが応答または例外の流れを待ち上でコマンドを「接続」を送信します。"
    },
    {
      "indent": 0,
      "text": "5.3.2. Server-to-Client Return Control Flow",
      "section_title": true,
      "ja": "5.3.2。サーバーからクライアントへ戻る制御フロー"
    },
    {
      "indent": 3,
      "text": "The server, on accepting the client's NetConnection control flow, and receiving and accepting the \"connect\" command, opens one or more return flows to the client having Stream ID 0 and associated to the control flow from the client. Flows for Stream ID 0 are the server's NetConnection control flows. The server sends a \"_result\" or \"_error\" transaction response for the client's connect command.",
      "ja": "「接続」コマンドをクライアントのNetConnectionオブジェクトの制御の流れを受け入れ、そして受信して受け入れて上のサーバは、1つ以上のリターンがストリームID 0を持つし、クライアントからの制御フローに関連付けられているクライアントに流れる開きます。ストリームID 0のためのフローは、サーバののNetConnection制御フローです。サーバーは、「_result」またはクライアントのconnectコマンドのための「_error」トランザクション応答を送信します。"
    },
    {
      "indent": 3,
      "text": "When the client receives the first return flow from the server for Stream ID 0 and associated to the client's NetConnection control flow, the client assumes that flow is the canonical return NetConnection control flow from the server, to which all new client-to-server flows should be associated.",
      "ja": "クライアントがストリームID 0のため、サーバーから最初の戻りの流れを受けて、クライアントのNetConnectionオブジェクトの制御フローに関連付けられている場合は、クライアントはすべての新しいクライアント - サーバが流れると、流れはサーバーから正規のリターンたNetConnection制御フローであることを前提としてい関連付けられている必要があります。"
    },
    {
      "indent": 3,
      "text": "On receipt of a \"_result\" transaction response on Stream ID 0 for the client's connect command, the connection is up.",
      "ja": "クライアントのconnectコマンドのためのストリームID 0の「_result」トランザクション応答を受信すると、接続がアップしています。"
    },
    {
      "indent": 3,
      "text": "The client MAY open additional return control flows to the server on Stream ID 0, associated to the server's canonical NetConnection control flow.",
      "ja": "クライアントは、サーバの標準的なのNetConnection制御フローに関連付けられたストリームID 0上のサーバーに追加の復帰制御フローを開くことができます。"
    },
    {
      "indent": 0,
      "text": "5.3.3. setPeerInfo Command",
      "section_title": true,
      "ja": "5.3.3。 setPeerInfoコマンド"
    },
    {
      "indent": 3,
      "text": "The \"setPeerInfo\" command is sent by the client to the server over the NetConnection control flow to inform the server of candidate socket addresses through which the client might be reachable. This list SHOULD include all directly connected interface addresses and proxy addresses except as provided below. The list MAY be empty. The list need not include the address of the server, even if the server is to act as an introducer for the client. The list SHOULD NOT include link-local or loopback addresses.",
      "ja": "「setPeerInfo」コマンドは、クライアントが到達可能であるかもしれない、それを通して候補ソケットアドレスのサーバーに通知するためのNetConnection制御フロー上のクライアントからサーバーに送信されます。このリストは、以下に提供される以外のすべての直接接続されたインターフェイスアドレス及びプロキシアドレスを含むべきです。リストが空でもよいです。リストには、サーバがクライアントのためのイントロデューサとして機能する場合でも、サーバーのアドレスを含む必要はありません。リストには、リンクローカルまたはループバックアドレスを含めるべきではありません。"
    },
    {
      "indent": 3,
      "text": "This command is sent as a regular RTMP NetConnection command; that is, as an RTMP Type 20 Command Message or an RTMP Type 17 Command Extended Message on Stream ID 0. A Type 20 Command Message SHOULD be used if the object encoding negotiated during the \"connect\" and",
      "ja": "このコマンドは、通常のRTMPたNetConnectionコマンドとして送信されます。つまり、RTMPタイプ20コマンドメッセージまたはストリームID 0にRTMPタイプ17コマンド拡張メッセージとして、タイプ20コマンドメッセージを使用する必要がある場合、「接続」との間でネゴシエートオブジェクトエンコード"
    },
    {
      "indent": 3,
      "text": "\"_result\" handshake is AMF0 [AMF0], and a Type 17 Command Extended Message SHOULD be used if the negotiated object encoding is AMF3 [AMF3].",
      "ja": "「_result」ハンドシェークはAMF0 [AMF0]であり、かつネゴシエートオブジェクトエンコードがAMF3 [AMF3]であればタイプ17コマンド拡張メッセージを使用すべきです。"
    },
    {
      "indent": 3,
      "text": "Note: A Type 20 Command Message payload is a sequence of AMF objects encoded in AMF0.",
      "ja": "注：タイプ20コマンドメッセージペイロードはAMF0で符号化AMFオブジェクトの配列です。"
    },
    {
      "indent": 3,
      "text": "Note: A Type 17 Command Extended Message payload begins with a format selector byte, followed by a sequence of objects in a format-specific encoding. At the time of writing, only format 0 is defined; therefore, the format selector byte MUST be 0. Format 0 is a sequence of AMF objects, each encoded in AMF0 by default; AMF3 encoding for an object can be selected by prefixing it with an \"avmplus-object-marker\" (0x11) as defined in [AMF0].",
      "ja": "注：タイプ17コマンド拡張メッセージペイロードは、フォーマット固有の符号化におけるオブジェクトのシーケンスに続いて、フォーマット選択バイトで始まります。執筆の時点では、唯一のフォーマット0が定義されています。従って、フォーマットセレクタバイトは0フォーマット0は、それぞれがデフォルトでAMF0でエンコードAMFオブジェクトの配列でなければなりません。オブジェクトのAMF3エンコーディングは[AMF0]で定義されるように（0x11を）「avmplusオブジェクトマーカー」とそれを付けることによって選択することができます。"
    },
    {
      "indent": 3,
      "text": "To complete the RTMFP NetConnection handshake, an RTMFP client MUST send a setPeerInfo command to the server after receiving a successful response to the \"connect\" command.",
      "ja": "RTMFPのNetConnectionハンドシェイクを完了するために、RTMFPクライアントは、「接続」コマンドに成功した応答を受信した後、サーバーにsetPeerInfoコマンドを送らなければなりません。"
    },
    {
      "indent": 3,
      "text": "( \"setPeerInfo\", // AMF String, command name 0.0, // AMF Number, transaction ID NULL, // AMF Null, no command object ... // zero or more AMF Strings, each an address )",
      "ja": "（ \"setPeerInfo\"、// AMF文字列、コマンド名0.0、// AMF番号、トランザクションIDのNULL、// AMFヌル、無コマンドオブジェクト... //ゼロまたはそれ以上のAMFストリングス、各アドレス）"
    },
    {
      "indent": 3,
      "text": "Each listed socket address includes an IPv4 or IPv6 address in presentation format and a UDP port number in decimal, separated by a colon. Since the IPv6 address presentation format uses colons, IPv6 addresses are enclosed in square brackets [RFC3986].",
      "ja": "リストされた各ソケットアドレスは、コロンで区切られたプレゼンテーション形式のIPv4またはIPv6アドレスと小数でUDPポート番号を含みます。 IPv6のアドレスプレゼンテーションフォーマットはコロンを使用するため、IPv6アドレスは角括弧[RFC3986]で囲まれています。"
    },
    {
      "indent": 24,
      "text": "(\n    \"setPeerInfo\",\n    0.0,\n    NULL,\n    \"192.0.2.129:50001\",\n    \"[2001:db8:1::2]:50002\"\n)",
      "raw": true
    },
    {
      "indent": 19,
      "text": "Figure 3: Example setPeerInfo Command",
      "ja": "図3：例setPeerInfoコマンド"
    },
    {
      "indent": 3,
      "text": "A server SHOULD assume that the client is behind a Network Address Translator (NAT) if and only if the observed far endpoint address of the session for the flow on which this command was received does not appear in the setPeerInfo address list.",
      "ja": "サーバがあれば、クライアントはネットワークアドレス変換（NAT）の背後にあることを前提とすべきであり、このコマンドを受信したフローのためのセッションの観察遠い終点アドレスがsetPeerInfoアドレスリストに表示されない場合にのみ。"
    },
    {
      "indent": 0,
      "text": "5.3.4. Set Keepalive Timers Command",
      "section_title": true,
      "ja": "5.3.4。キープアライブタイマーコマンドを設定します"
    },
    {
      "indent": 3,
      "text": "The server can advise the client to set or change the client's session keepalive timer periods for its connection to the server and for its P2P connections. The server MAY choose keepalive periods based on static configuration, application- or deployment-specific circumstances, whether the client appears to be behind a NAT, or for any other reason.",
      "ja": "サーバーは、サーバーへの接続のために、そのP2P接続用のクライアントのセッションキープアライブタイマー期間を設定または変更するには、クライアントに助言することができます。サーバは、クライアントがNATの背後にある、またはその他の理由のように見えるかどうか、静的な設定に基づいて、キープアライブ期間、用途向けまたはデプロイメント固有の事情を選ぶかもしれません。"
    },
    {
      "indent": 3,
      "text": "The Set Keepalive Timers command is sent by the server to the client on Stream ID 0 as a User Control event message (Type 4) having Event Type 41. Message timestamps are ignored and MAY be set to 0.",
      "ja": "設定キープアライブタイマーコマンドは、イベントの種類41メッセージのタイムスタンプが無視され、0に設定されるかもしれ持つユーザーコントロールのイベントメッセージ（タイプ4）としてストリームID 0上のサーバからクライアントに送信されます。"
    },
    {
      "indent": 3,
      "text": " 0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7|0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+\n|       4       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                           timestamp                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|         eventType = 41        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                    serverKeepalivePeriodMsec                  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                     peerKeepalivePeriodMsec                   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "struct setKeepaliveUserControlMessagePayload_t\n{\n    uint16_t eventType = 41;\n    uint32_t serverKeepalivePeriodMsec;\n    uint32_t peerKeepalivePeriodMsec;\n} :10*8;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "eventType: The RTMP User Control Message Event Type. Set Keepalive Timers messages have type 41 (0x29);",
      "ja": "eventTypeを：RTMPユーザーコントロールメッセージイベントの種類。キープアライブタイマーメッセージはタイプ41（0x29）を持って設定します。"
    },
    {
      "indent": 3,
      "text": "serverKeepalivePeriodMsec: The keepalive period, in milliseconds, that the client is advised to set on its RTMFP session with the server;",
      "ja": "serverKeepalivePeriodMsec：ミリ秒単位のキープアライブ期間、クライアントがサーバーとのRTMFPセッションに設定することをお勧めされていること。"
    },
    {
      "indent": 3,
      "text": "peerKeepalivePeriodMsec: The keepalive period, in milliseconds, that the client is advised to use on its RTMFP sessions with any peer that is not the server.",
      "ja": "peerKeepalivePeriodMsec：ミリ秒単位のキープアライブ期間、クライアントがサーバではない任意のピアとそのRTMFPセッションで使用することをお勧めしていること。"
    },
    {
      "indent": 3,
      "text": "The client MUST define minimum values for these keepalive periods, below which it will not set them, regardless of the values in this message. The minimum keepalive timer periods SHOULD be at least five seconds. The client MAY define maximum values for these keepalive periods, above which it will not set them.",
      "ja": "クライアントは、それは関係なく、このメッセージの値の、それらを設定しませんそれ以下これらのキープアライブの期間、の最小値を定義する必要があります。最小キープアライブタイマー期間は、少なくとも5秒であるべきです。クライアントは、それが彼らを設定しませんそれを超えるとこれらのキープアライブの期間、の最大値を定義することができます。"
    },
    {
      "indent": 3,
      "text": "On receipt of this message from the server, a client SHOULD set its RTMFP server and peer keepalive timer periods to the indicated values subject to the client's minimum and maximum values. The server MAY send this message more than once, particularly if conditions that it uses to determine the timer periods change.",
      "ja": "サーバからのこのメッセージの受信時に、クライアントは、クライアントの最小値と最大値の対象に示された値にそのRTMFPサーバとピアキープアライブタイマー期間を設定する必要があります。サーバは、期間が変更タイマーを決定するために使用することが特に条件ならば、複数回このメッセージを送信することができます。"
    },
    {
      "indent": 0,
      "text": "5.3.5. Additional Flows for Streams",
      "section_title": true,
      "ja": "5.3.5。ストリームの追加フロー"
    },
    {
      "indent": 3,
      "text": "The client or server opens additional flows to the other side to carry messages for any stream. Additional flows are associated to the canonical NetConnection control flow from the other side.",
      "ja": "クライアントまたはサーバが任意のストリームのメッセージを運ぶために、他の側に追加のフローを開きます。追加のフローは反対側から正規のNetConnection制御フローに関連付けられています。"
    },
    {
      "indent": 9,
      "text": "Client                                            Server\n------>--C2S-Control-Flow------------------------->--+\n                                                     |\n   +--<------------------------S2C-Control-Flow---<--+\n   |                                                 |\n   |  <------------------------S2C-Stream-Flow-1--<--+\n   |                                  :              |\n   |  <------------------------S2C-Stream-Flow-M--<--+\n   |\n   +-->--C2S-Stream-Flow-1------------------------>\n   |               :\n   +-->--C2S-Stream-Flow-N------------------------>",
      "raw": true
    },
    {
      "indent": 7,
      "text": "Figure 4: Schematic Flow Association Tree for a NetConnection",
      "ja": "図4：NetConnectionオブジェクトのための概略的な流れ協会ツリー"
    },
    {
      "indent": 0,
      "text": "5.3.5.1. To Server",
      "section_title": true,
      "ja": "5.3.5.1。サーバーへ"
    },
    {
      "indent": 3,
      "text": "Additional flows from the client to the server for stream messages are opened with the Stream ID for that stream and associated in return to the server's canonical NetConnection control flow.",
      "ja": "ストリーム・メッセージのためのクライアントからサーバーへの追加のフローは、そのストリームのストリームIDを開き、サーバーの標準的なのNetConnection制御フローへの復帰に関連しています。"
    },
    {
      "indent": 3,
      "text": "The client MAY create as many flows as desired for any Stream ID (including Stream ID 0) at any time.",
      "ja": "任意の時点で（ストリームID 0を含む）任意のストリームIDのために所望のように、クライアントは、多くのフローを作成してもよいです。"
    },
    {
      "indent": 0,
      "text": "5.3.5.2. From Server",
      "section_title": true,
      "ja": "5.3.5.2。サーバーから"
    },
    {
      "indent": 3,
      "text": "Additional flows from the server to the client for stream messages are opened with the Stream ID for that stream, and associated in return to the client's NetConnection control flow.",
      "ja": "ストリーム・メッセージのためにサーバからクライアントへの追加の流れは、そのストリームのためのストリームIDで開かれ、そしてクライアントのNetConnectionオブジェクトの制御フローへの復帰に関連しています。"
    },
    {
      "indent": 3,
      "text": "The server MAY create as many flows as desired for any Stream ID (including Stream ID 0) at any time.",
      "ja": "任意の時点で（ストリームID 0を含む）任意のストリームIDのために所望のように、サーバは、多くのフローを作成してもよいです。"
    },
    {
      "indent": 0,
      "text": "5.3.5.3. Closing Stream Flows",
      "section_title": true,
      "ja": "5.3.5.3。閉会ストリーム・フロー"
    },
    {
      "indent": 3,
      "text": "Either end MAY close a sending flow that is not for Stream ID 0 at any time with no semantic meaning for the stream.",
      "ja": "どちらかの端には、ストリームの無セマンティックな意味でいつでもストリームID 0のためではありません送信の流れを閉じます。"
    },
    {
      "indent": 3,
      "text": "At any time, either end MAY reject a receiving flow that is not one of the other end's NetConnection control flows. No flow exception codes are defined by this profile, so the receiving end SHOULD use exception code 0 when rejecting the flow. The sending end, on notification of any exception for a stream flow, SHOULD NOT open a new flow to take the rejected flow's place for transport of messages for that stream. If an end rejects any flow for a stream, it SHOULD reject all the flows for that stream, otherwise Flow Synchronization messages (Section 5.2) that were in flight could be discarded and some flows might become or remain stuck in a suspended state.",
      "ja": "いつでも、どちらかの端には、もう一方の端のたNetConnection制御フローの一つではない受信フローを拒否することがあります。いいえフロー例外コードは、このプロファイルによって定義されていないので、流れを拒否する場合、受信側は、例外コード0を使用すべきです。送信側は、ストリームの流れのための例外の通知に、そのストリームのためのメッセージの輸送のために拒否されたフローの場所を取るために新しい流れを開くべきではありません。最後は、ストリームの任意の流れを拒否した場合、それは、そうでない場合は、飛行中だったフロー同期メッセージ（5.2節）を破棄することができ、一部のフローになる可能性があるか、一時停止状態で立ち往生したまま、そのストリームのすべてのフローを拒否すべきです。"
    },
    {
      "indent": 0,
      "text": "5.3.6. Closing the Connection",
      "section_title": true,
      "ja": "5.3.6。接続を閉じます"
    },
    {
      "indent": 3,
      "text": "The client or server can signal an orderly close of the connection by closing its NetConnection control sending flows and all stream sending flows. The other end, on receiving a close/complete notification for the canonical NetConnection control receiving flow, closes its sending flows. When both ends observe all receiving flows have closed and completed, the connection has cleanly terminated.",
      "ja": "クライアントまたはサーバは、フローとフローを送信するすべてのストリームを送信してのNetConnection制御を閉じて、接続の秩序近くに信号を送ることができます。他方の端部は、正規のNetConnection制御受信フローに対して近い/完了通知を受信すると、その送信の流れを閉じます。両端がすべての受信フローが閉鎖され、完了した観察すると、接続がきれいに終了しました。"
    },
    {
      "indent": 3,
      "text": "Either end can abruptly terminate the connection by rejecting the NetConnection control receiving flows or by closing the underlying RTMFP session. On notification of any exception on a NetConnection control sending flow, the end seeing the exception knows the other end has terminated abruptly, and can immediately close all sending and receiving flows for that connection.",
      "ja": "両端が急激に流れを受けたNetConnection制御を拒否するか、基礎となるRTMFPセッションを閉じて接続を終了することができます。流れを送るのNetConnection制御上の任意の例外の通知には、例外を見て最後にはもう一方の端が突然終了した、とすぐにその接続のために、すべての送信および受信の流れを閉じることができます知っています。"
    },
    {
      "indent": 0,
      "text": "5.3.7. Example",
      "section_title": true,
      "ja": "5.3.7。例"
    },
    {
      "indent": 5,
      "text": "            Client                    Server\n              |IHello (EPD:anc=URI)     |\n          -+- |------------------------>|\n           |  |                         |\n           |  |       RHello (RCert:anc)|\n     RTMFP |  |<------------------------|\n    Session|  |                         |\n     Hand- |  |IIKeying                 |\n     shake |  |------------------------>|\n           |  |                         |\n           |  |                 RIKeying|\n          -+- |<------------------------|\n              |                         |\n          -+- |\"connect\" command        |\n    (Str.ID=0)|-CFlow-0---------------->|\n           |  |                         |\n           |  |       \"_result\" response|\n     RTMP  |  |<----------------SFlow-0-|(Str.ID=0,\n    Connect|  |                         | Assoc=CFlow-0)\n     Hand- |  |\"setPeerInfo\" command    |\n     shake |  |-CFlow-0---------------->|\n          -+- |                         |\n              |\"createStream\" command   |\n          -+- |-CFlow-0---------------->|\n           |  |                         |\n           |  |     \"_result\" (str.ID=5)|\n           |  |<----------------SFlow-0-|\n           |  |                         |\n           |  |\"play\" command           |\n    (Str.ID=5,|-CFlow-1---------------->|\nAssoc=SFlow-0)|                         |\n           |  | StreamBegin User Control|\n           |  |<----------------SFlow-1-|(Str.ID=5,\n           |  |                         | Assoc=CFlow-0)\n           |  |  (RTMP stream events)   |\nStreaming  |  |<----------------SFlow-1-|\n           |  |                         |\n           |  |        Audio Data       |\n           |  |<----------------SFlow-2-|(Str.ID=5,\n           |  |                         | Assoc=CFlow-0)\n           |  |        Video Data       |\n           |  |<----------------SFlow-3-|(Str.ID=5,\n           |  |            :            | Assoc=CFlow-0)\n              |            :            |",
      "raw": true
    },
    {
      "indent": 13,
      "text": "Figure 5: Example NetConnection Message Exchange",
      "ja": "図5：例のNetConnectionメッセージ交換"
    },
    {
      "indent": 0,
      "text": "5.4. Direct Peer-to-Peer Streams",
      "section_title": true,
      "ja": "5.4。直接ピアツーピアストリーム"
    },
    {
      "indent": 3,
      "text": "Clients can connect directly to other clients for P2P streaming and data exchange. A client MAY have multiple separate P2P NetStreams with a peer in one RTMFP session, each a separate logical connection. P2P NetStreams are unidirectional, initiated by a subscriber (the side issuing the \"play\" command) to a publisher. The subscribing peer has a control flow to the publisher. The publisher has zero or more return flows to the subscriber associated to the subscriber's control flow, for the stream media and data.",
      "ja": "クライアントは、P2Pストリーミングとデータ交換のために、他のクライアントに直接接続することができます。クライアントは、1つのRTMFPセッションでのピアは、それぞれ別々の論理接続で複数の独立したP2PのNetStreamsを持っているかもしれません。 P2P NetStreamsは、加入者パブリッシャーに（「再生」コマンドを発行する側）によって開始され、単方向です。サブスクライブするピアは、出版社への制御フローを持っています。出版社は、ゼロまたはそれ以上のリターンは、ストリームメディアとデータのために、加入者の制御フローに関連する加入者に流れました。"
    },
    {
      "indent": 0,
      "text": "5.4.1. Connecting",
      "section_title": true,
      "ja": "5.4.1。接続"
    },
    {
      "indent": 3,
      "text": "A client desires to subscribe directly to a stream being published in P2P mode by a publishing peer. The client learns the peer ID of the publisher and the stream name through application-specific means.",
      "ja": "クライアントは、発行ピアがP2Pモードで公開されたストリームに直接サブスクライブすることを望みます。クライアントは、アプリケーション固有の手段を通じて出版社とストリーム名のピアIDを学習します。"
    },
    {
      "indent": 3,
      "text": "If the client does not already have an RTMFP session with that peer ID, it initiates a new session, creating an EPD containing a Fingerprint option (Section 4.4.2.3) for the publisher's peer ID and using the server session's DESTADDR as the initial candidate address for the session to the peer. The server acts as an Introducer (Section 3.5.1.6 of RFC 7016), using forward and redirect messages to help the client and the peer establish a session.",
      "ja": "クライアントがすでにそのピアIDを持つRTMFPセッションを持っていない場合、それは出版社のピアIDについて（セクション4.4.2.3）指紋認証オプションを含むEPDを作成し、初期候補アドレスとしてサーバー・セッションのDESTADDRを使用して、新しいセッションを開始しますピアへのセッションのために。サーバは、前方使用して、イントロデューサ（RFC 7016のセクション3.5.1.6）として動作し、クライアントとピアがセッションの確立を支援するために、メッセージをリダイレクトします。"
    },
    {
      "indent": 3,
      "text": "When an S_OPEN session exists to the desired peer, the client creates a new independent flow to that peer. The flow MUST have a non-zero Stream ID. The client sends an RTMP \"play\" command over the flow, giving the name of the desired stream at the publisher. This flow is the subscriber's control flow.",
      "ja": "S_OPENセッションが必要なピアに存在する場合、クライアントはそのピアへの新しい独立したフローを作成します。フローは、非ゼロのストリームIDを持たなければなりません。クライアントは、パブリッシャーで所望のストリームの名前を与え、流れの上にRTMP「遊び」コマンドを送信します。このフローは、加入者の制御フローです。"
    },
    {
      "indent": 0,
      "text": "5.4.2. Return Flows for Stream",
      "section_title": true,
      "ja": "5.4.2。戻り値は、ストリームのためのフロー"
    },
    {
      "indent": 3,
      "text": "The publisher, on accepting a new flow not indicating a return association with any of its sending flows and having a non-zero Stream ID, receives and processes the \"play\" command. If and when the request is acceptable to the publisher, it opens one or more return flows to the subscribing peer, associated to the subscriber's control flow and having the same Stream ID. The publisher sends a StreamBegin User Control message, appropriate RTMP status events, and the stream media over the one or more return flows.",
      "ja": "出版社は、その送信フローのいずれかとリターンの関連付けを示す非ゼロのストリームIDを有する新しいフローを受け入れないで、受信し、コマンドを「再生」処理します。要求がパブリッシャに許容される場合ならば、それは、一つ以上のリターンは、加入者の制御フローに関連付けられ、同一のストリームIDを有する、加入ピアに流れる開きます。出版社はStreamBeginユーザーコントロールメッセージ、適切なRTMPステータスイベント、および1つのまたはそれ以上のリターン・フローを超えるストリームメディアを送信します。"
    },
    {
      "indent": 3,
      "text": "The subscriber uses the return association of the media flows to the subscriber control flow to determine the stream to which the media belongs.",
      "ja": "加入者は、メディアの戻り関連メディアが属するストリームを決定するために、加入者の制御フローに流れる使用します。"
    },
    {
      "indent": 3,
      "text": "The publisher MAY open any number of media flows for the stream and close them at any time. The opening and closing of media flows has no semantic meaning for the stream, except that the opening of at least one flow and the reception of at least one media message or a StreamBegin User Control message indicates that the publisher is publishing the requested stream to the subscriber.",
      "ja": "出版社は、ストリームのメディアフローの任意の数を開いて、いつでもそれらを閉じます。メディアフローの開閉は、少なくとも1つのメディアメッセージまたはStreamBeginユーザーコントロールメッセージの少なくとも1つの流れと受信開口がパブリッシャがに要求されたストリームを公開していることを示すことを除いて、ストリームのための意味論的な意味を持ちません加入者。"
    },
    {
      "indent": 9,
      "text": "Subscriber                                     Publisher\n------>--Subscriber-Control-Flow------------------>--+\n                                                     |\n      <------------------Publisher-Stream-Flow-1--<--+\n                                     :               |\n      <------------------Publisher-Stream-Flow-N--<--+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Figure 6: Schematic Flow Association Tree for a P2P Direct Connection",
      "ja": "図6：概略フロー協会ツリーP2P直接接続するための"
    },
    {
      "indent": 0,
      "text": "5.4.3. Closing the Connection",
      "section_title": true,
      "ja": "5.4.3。接続を閉じます"
    },
    {
      "indent": 3,
      "text": "Either end can close the stream by closing or rejecting the subscriber's control flow. The publisher SHOULD close and unpublish to the subscriber on receipt of a close/complete of the control flow. The subscriber SHOULD consider the stream closed on notification of any exception on the control flow.",
      "ja": "どちらの終わりには、加入者の制御の流れを閉じるか、拒否することによって、ストリームを閉じることができます。出版社は閉鎖し、制御フローを完全に近い/の受信時に加入者に非公開にすべきです。加入者は、ストリームは、制御フロー上のすべての例外の通知に閉じ検討すべきです。"
    },
    {
      "indent": 0,
      "text": "6. IANA Considerations",
      "section_title": true,
      "ja": "6. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This memo specifies option type code values for Certificate fields (Section 4.3.3), Endpoint Discriminator fields (Section 4.4.2), and Session Keying Component fields (Section 4.5.2). It also specifies a flow metadata signature (Section 5.1.1). The type code values and signatures for this profile are assigned and maintained by Adobe, and therefore require no action from IANA.",
      "ja": "このメモは、証明書フィールド（4.3.3）、エンドポイント識別子フィールド（4.4.2）、およびセッションキーイングコンポーネントフィールド（4.5.2）用のオプションタイプコードの値を指定します。また、フロー・メタデータの署名（セクション5.1.1）を指定します。このプロファイルのタイプのコード値と署名が割り当てられ、Adobeが維持され、したがって、IANAからのアクションを必要としていません。"
    },
    {
      "indent": 0,
      "text": "6.1. RTMFP URI Scheme Registration",
      "section_title": true,
      "ja": "6.1。 RTMFP URIスキームの登録"
    },
    {
      "indent": 3,
      "text": "This memo describes use of an RTMFP URI scheme (Section 4.4.2.2, Section 5.3.1, Figure 5). Per this section, the \"rtmfp\" URI scheme has been registered by IANA.",
      "ja": "このメモはRTMFP URIスキーム（セクション4.4.2.2、セクション5.3.1、図5）の使用を記載しています。このセクションごとに、「RTMFP」URIスキームはIANAによって登録されています。"
    },
    {
      "indent": 3,
      "text": "The syntax and semantics of this URI scheme are described using the Augmented Backus-Naur Form (ABNF) [RFC5234] rules from RFC 3986.",
      "ja": "構文このURIスキームのセマンティクスは、拡張バッカス・ナウアフォーム（ABNF）[RFC5234] RFC 3986からのルールを使用して記載されています。"
    },
    {
      "indent": 3,
      "text": "URI scheme name: rtmfp",
      "ja": "URIのスキーム名：RTMFP"
    },
    {
      "indent": 3,
      "text": "Status: provisional",
      "ja": "ステータス：暫定"
    },
    {
      "indent": 3,
      "text": "URI scheme syntax:",
      "ja": "URIスキームの構文："
    },
    {
      "indent": 6,
      "text": "rtmfp-uri-scheme = \"rtmfp:\" / \"rtmfp://\" host [ \":\" port ] path-abempty",
      "ja": "RTMFP-URI-スキーム= \"RTMFP：\" / \"RTMFP：//\" ホスト[ \"：\" ポート]パスabempty"
    },
    {
      "indent": 3,
      "text": "URI scheme semantics: The first form is used in the APIs of some implementations to indicate instantiation of an RTMFP client according to this memo, but without connecting to a server. Such an instantiation might be used for pure peer-to-peer communication.",
      "ja": "URIスキームのセマンティクス：最初のフォームがなく、サーバに接続せずに、このメモに係るRTMFPクライアントのインスタンスを示すために、いくつかの実装のAPIのに使用されます。そのようなインスタンスは、純粋なピア・ツー・ピア通信に使用されるかもしれません。"
    },
    {
      "indent": 6,
      "text": "The second form provides location information for the server to which to connect and optional additional information to pass to the server. The only operation for this URI form is to connect to a server (initial candidate address(es) for which are named by host and port) according to Section 5.3. The UDP port for initial candidate addresses, if not specified, is 1935. If the host is a reg-name, the initial candidate address set SHOULD comprise all IPv4 and IPv6 addresses to which reg-name resolves. The semantics of path-abempty are specific to the server. Connections are made using RTMFP as specified by this memo.",
      "ja": "第2の形態は、サーバに渡す接続する先のサーバ及び任意の追加情報の位置情報を提供します。このURIフォームの動作のみが第5.3項に従って（ホストとポートによって命名される初期候補アドレス（ES））サーバに接続することです。最初の候補アドレスのUDPポートは、指定されていない場合、ホストはREG-名前である場合は、初期候補アドレスセットは、すべてのIPv4とIPv6がREG-名前解決されたアドレスを含むべきである1935年です。パスabemptyのセマンティクスは、サーバーに固有のものです。接続は、このメモで指定されたRTMFPを使用して作られています。"
    },
    {
      "indent": 3,
      "text": "Encoding considerations: The path-abempty component represents textual data consisting of characters from the Universal Character Set. This component SHOULD be encoded according to Section 2.5 of RFC 3986.",
      "ja": "符号化の考慮事項：パスabempty成分は、ユニバーサル文字セットの文字からなるテキストデータを表します。このコンポーネントは、RFC 3986のセクション2.5に従って符号化されるべきです。"
    },
    {
      "indent": 3,
      "text": "Applications/protocols that use this URI scheme name: The Flash runtime (including Flash Player) from Adobe Systems Incorporated, communication servers such as Adobe Media Server, and interoperable clients and servers provided by other parties, using RTMFP according to this memo.",
      "ja": "アプリケーションこのURIのスキーム名を使用/プロトコル：Adobe Systems Incorporated（アドビシステムズ社）から（Flash Playerを含む）のFlashランタイムを、そのようなアドビメディアサーバーなどの通信サーバ、および他の関係者が提供する相互運用可能クライアントとサーバ、このメモによるとRTMFP使用。"
    },
    {
      "indent": 3,
      "text": "Interoperability considerations: This scheme requires use of RTMFP as defined by RFC 7016 in the manner described by this memo.",
      "ja": "相互運用性の考慮事項：このメモで説明したように、RFC 7016によって定義されるこの方式はRTMFPの使用を必要とします。"
    },
    {
      "indent": 3,
      "text": "Security considerations: See Security Considerations (Section 7) in this memo.",
      "ja": "セキュリティの考慮事項：このメモでセキュリティ上の考慮事項（第7節）を参照してください。"
    },
    {
      "indent": 3,
      "text": "Contact: Michael Thornburgh, Adobe Systems Incorporated, <mthornbu@adobe.com>.",
      "ja": "連絡先：マイケルThornburgh、Adobe Systems Incorporated（アドビシステムズ社）、<mthornbu@adobe.com>。"
    },
    {
      "indent": 3,
      "text": "Author/Change controller: Michael Thornburgh, Adobe Systems Incorporated, <mthornbu@adobe.com>.",
      "ja": "著者/変更コントローラ：マイケルThornburgh、Adobe Systems Incorporated（アドビシステムズ社）、<mthornbu@adobe.com>。"
    },
    {
      "indent": 3,
      "text": "References: Thornburgh, M., \"Adobe's Secure Real-Time Media Flow Protocol\", RFC 7016, November 2013.",
      "ja": "参考文献：Thornburgh、M.、 \"Adobeのセキュアリアルタイムメディアフロープロトコル\"、RFC 7016、2013年11月。"
    },
    {
      "indent": 6,
      "text": "This memo.",
      "ja": "このメモ。"
    },
    {
      "indent": 0,
      "text": "7. Security Considerations",
      "section_title": true,
      "ja": "7.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "Section 4 details the cryptographic aspects of this profile.",
      "ja": "第4節では、このプロファイルの暗号化の側面を詳しく説明します。"
    },
    {
      "indent": 3,
      "text": "This profile does not define or use a Public Key Infrastructure (PKI). Clients SHOULD use static Diffie-Hellman keys in their certificates (Section 4.3.3.5). Clients MUST create a new certificate with a distinct fingerprint for each new NetConnection (Section 5.3). These constraints make client identities ephemeral but unable to be forged. A man-in-the-middle cannot successfully interpose itself in a connection to a target client addressed by its fingerprint/peer ID if the target client uses a static Diffie-Hellman public key.",
      "ja": "このプロファイルは、公開鍵基盤（PKI）を定義したり、使用していません。クライアントは、証明書（セクション4.3.3.5）で静的のDiffie-Hellman鍵を使用すべきです。クライアントは、それぞれの新しいNetConnectionオブジェクト（セクション5.3）のための明確な指紋を使用して新しい証明書を作成する必要があります。これらの制約は、クライアントのアイデンティティははかないけど偽造することができない作ります。 man-in-the-middleが正常にターゲットクライアントが静的のDiffie-Hellman公開鍵を使用している場合、その指紋/ピアIDによって対処ターゲット・クライアントへの接続に自分自身を挿入することはできません。"
    },
    {
      "indent": 3,
      "text": "Servers can have long-lived RTMFP instances, so they SHOULD use ephemeral Diffie-Hellman public keys for forward secrecy. This allows server peer IDs to be forged; however, clients do not connect to servers by peer ID, so this is irrelevant.",
      "ja": "サーバーは、長寿命のRTMFPのインスタンスを持つことができるので、彼らは前進の秘密保持のために短命のDiffie-Hellman公開鍵を使用すべきです。これは、サーバーピアIDを偽造することができます。ただし、クライアントは、ピアIDでサーバーに接続していないので、これは無関係です。"
    },
    {
      "indent": 3,
      "text": "When a client connects to a server, the client will accept the response of any endpoint claiming to be \"a server\". It is assumed that an attacker that can passively observe traffic on a network segment can also inject its own packets with any source or destination and any payload. An attacker can trick a client into connecting to a rogue server or man-in-the-middle, either by observing Initiator Hello packets from the client and responding earliest with a matching Responder Hello or by using tricks such as DNS spoofing or poisoning to direct a client to connect directly to the rogue. A TCP-based transport would be vulnerable to similar attacks. Since there is no PKI, this profile gives no guarantee that the client has actually connected to the desired server, versus a rogue or man-in-the-middle. In circumstances where assurance is required that the connection is directly to the desired server, the client can use the Session Nonces (Section 4.6.5) to challenge the server, for example, over a different channel having acceptable security properties (such as an HTTPS) to transitively establish the server's identity and verify that the end-to-end communication is private and authentic.",
      "ja": "クライアントがサーバーに接続すると、クライアントは「サーバー」であると主張する任意のエンドポイントの応答を受け入れます。受動ネットワークセグメント上のトラフィックを観察することができる攻撃者は、任意の送信元または宛先との任意のペイロードを持つ独自のパケットを注入することができることが想定されます。攻撃者は、クライアントからのイニシエータHelloパケットを観測し、こんにちはレスポンダまたは指示するようにDNSスプーフィングや中毒などのトリックを使用して、一致して早い応答のいずれかによって、不正なサーバまたはのman-in-the-middleへの接続にクライアントをだますことができます不正に直接接続するクライアント。 TCPベースのトランスポートは、同様の攻撃に対して脆弱になります。何のPKIがないので、このプロファイルは、クライアントが実際に不正またはman-in-the-middle対、目的のサーバに接続しているという保証を与えません。保証が接続を所望のサーバに直接あることが要求される状況では、クライアントは、HTTPSとして許容されるセキュリティ特性を（異なるチャネルを介して、例えば、サーバに挑戦するセッションナンス（4.6.5）を使用することができ）推移サーバのアイデンティティを確立し、エンド・ツー・エンドの通信がプライベートで本物であることを確認します。"
    },
    {
      "indent": 3,
      "text": "When session sequence numbers (Section 4.7.3.3) are not used, it is possible for an attacker to use traffic analysis techniques and record encrypted packets containing the start of a new flow, and later to replay those packets after the flow has closed, which can look to the receiver like a brand new flow. In circumstances where this can be detrimental, session sequence numbers SHOULD be used. Replay of packets for existing flows is not detrimental as the receiver detects and discards duplicate flow sequence numbers, and flow sequence numbers do not wrap or otherwise repeat.",
      "ja": "セッションシーケンス番号（セクション4.7.3.3）が使用されていない場合は、攻撃者がトラフィック分析技術を使用して、新しいフローの開始を含む暗号化されたパケットを記録し、以降のフローが閉じた後、それらのパケットを再生するためにすることが可能であり、そのブランドの新しい流れのような受信機に見ることができます。これは有害であることができる状況では、セッションのシーケンス番号を使用すべきです。受信機が検出し、破棄は、フローシーケンス番号を複製、およびフローシーケンス番号がラップするか、そうでなければ繰り返さないよう、既存のフローのためのパケットのリプレイは有害ではありません。"
    },
    {
      "indent": 3,
      "text": "Packet encryption uses CBC with the same (null) initialization vector for each packet. This can reveal to an observer whether two packets contain identical plaintext. However, the maximum-length RTMFP common header and User Data or Data Acknowledgement header, including flow sequence number, always fit within the first 16-byte cipher block, so each initial cipher block for most packets will already be unique even if timestamps are suppressed. Sending identical messages in a flow uses unique flow sequence numbers, so cipher blocks will be unique in this case. Keepalive pings and retransmission of lost data can result in identical cipher blocks; however, traffic analysis can also reveal likely keepalives or retransmissions, and retransmission only occurs as a result of observable network loss, so this is usually irrelevant. In circumstances where any identical cipher block is unacceptable, session sequence numbers SHOULD be used as they guarantee each initial cipher block will be unique.",
      "ja": "パケットの暗号化は、各パケットに対して同じ（ヌル）初期化ベクトルとCBCを使用します。これは、2つのパケットが同じ平文が含まれているかどうかを観察者に明らかにすることができます。しかし、ほとんどのパケットのフローシーケンス番号を含む共通ヘッダ及びユーザデータまたはデータ肯定応答ヘッダは、常に最初の16バイトの暗号ブロック内に収まるRTMFP最大長、したがって各初期暗号ブロックが既にタイムスタンプが抑制されている場合でもユニークであろう。流れの中で、同一のメッセージを送信すると、独自のフローシーケンス番号を使用するため、暗号ブロックが、この場合にユニークになります。キープアライブのpingや失われたデータの再送信は、同一の暗号ブロックにつながることができます。しかし、トラフィック分析も可能性がキープアライブまたは再送信を明らかにすることができ、再送は、観察ネットワーク損失の結果として発生するので、これは通常は無関係です。これらはそれぞれ初期暗号ブロックが一意であることを保証するような任意の同一の暗号ブロックが許容されない状況では、セッションのシーケンス番号を使用すべきです。"
    },
    {
      "indent": 3,
      "text": "Packet verification can use a 16-bit simple checksum (Section 4.7.3.1). The checksum is inside the encrypted packet, so for external packet modifications the checksum is equivalent to a 16-bit cryptographic digest. In circumstances where this is insufficient, HMAC verification (Section 4.7.3.2) SHOULD be used.",
      "ja": "パケット検証は、16ビットの単純なチェックサム（セクション4.7.3.1）を使用することができます。チェックサムは、16ビットの暗号ダイジェストと同等である外部のパケット変更のために、チェックサムは、暗号化されたパケット内にあります。これが不十分である状況では、HMAC認証（セクション4.7.3.2）が使用されるべきです。"
    },
    {
      "indent": 0,
      "text": "8. References",
      "section_title": true,
      "ja": "8.参照文献"
    },
    {
      "indent": 0,
      "text": "8.1. Normative References",
      "section_title": true,
      "ja": "8.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[AES] National Institute of Standards and Technology, \"Advanced Encryption Standard (AES)\", FIPS PUB 197, November 2001, <http://csrc.nist.gov/publications/fips/fips197/ fips-197.pdf>.",
      "ja": "[AES]米国国立標準技術研究所、 \"高度暗号化標準（AES）\"、FIPS PUBの197、2001年11月、<http://csrc.nist.gov/publications/fips/fips197/ FIPS-197.pdf>。"
    },
    {
      "indent": 3,
      "text": "[AMF0] Adobe Systems Incorporated, \"Action Message Format -- AMF 0\", December 2007, <http://www.adobe.com/go/spec_amf0>.",
      "ja": "[AMF0] Adob​​e Systems Incorporated（アドビシステムズ社）、 \"アクションメッセージフォーマット -  AMF 0\"、2007年12月、<http://www.adobe.com/go/spec_amf0>。"
    },
    {
      "indent": 3,
      "text": "[AMF3] Adobe Systems Incorporated, \"Action Message Format -- AMF 3\", January 2013, <http://www.adobe.com/go/spec_amf3>.",
      "ja": "[AMF3] Adob​​e Systems Incorporated（アドビシステムズ社）、 \"アクションメッセージフォーマット -  AMF 3\"、2013年1月、<http://www.adobe.com/go/spec_amf3>。"
    },
    {
      "indent": 3,
      "text": "[CBC] Dworkin, M., \"Recommendation for Block Cipher Modes of Operation\", NIST Special Publication 800-38A, December 2001, <http://csrc.nist.gov/publications/nistpubs/800-38a/ sp800-38a.pdf>.",
      "ja": "[CBC] Dworkin、M.、 \"操作のブロック暗号モードのための勧告\"、NIST特別出版800-38A、2001年12月、<http://csrc.nist.gov/publications/nistpubs/800-38a/ sp800-38a .PDF>。"
    },
    {
      "indent": 3,
      "text": "[DH] Diffie, W. and M. Hellman, \"New Directions in Cryptography\", IEEE Transactions on Information Theory, V. IT-22, n. 6, June 1977.",
      "ja": "[DH]ディフィー、W.とM.ヘルマン、 \"暗号に関する新\"、情報理論に関するIEEEトランザクション、V. IT-22、N。 6、1977年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC2104] Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, February 1997, <http://www.rfc-editor.org/info/rfc2104>.",
      "ja": "[RFC2104] Krawczyk、H.、ベラー、M.、およびR.カネッティ、 \"HMAC：メッセージ認証のための鍵付きハッシュ化\"、RFC 2104、1997年2月、<http://www.rfc-editor.org/info/ RFC2104>。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月、<http://www.rfc-editor.org/info/rfc2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC3526] Kivinen, T. and M. Kojo, \"More Modular Exponential (MODP) Diffie-Hellman groups for Internet Key Exchange (IKE)\", RFC 3526, May 2003, <http://www.rfc-editor.org/info/rfc3526>.",
      "ja": "[RFC3526] Kivinen、T.およびM.古城、 \"インターネット鍵交換のためのより多くのモジュラー指数（MODP）のDiffie-Hellmanグループ（IKE）\"、RFC 3526、2003年5月、<http://www.rfc-editor.org /情報/ rfc3526>。"
    },
    {
      "indent": 3,
      "text": "[RFC3629] Yergeau, F., \"UTF-8, a transformation format of ISO 10646\", STD 63, RFC 3629, November 2003, <http://www.rfc-editor.org/info/rfc3629>.",
      "ja": "[RFC3629] Yergeau、F.、 \"UTF-8、ISO 10646の変換フォーマット\"、STD 63、RFC 3629、2003年11月、<http://www.rfc-editor.org/info/rfc3629>。"
    },
    {
      "indent": 3,
      "text": "[RFC3986] Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform Resource Identifier (URI): Generic Syntax\", STD 66, RFC 3986, January 2005, <http://www.rfc-editor.org/info/rfc3986>.",
      "ja": "[RFC3986]バーナーズ - リー、T.、フィールディング、R.、およびL. Masinter、 \"ユニフォームリソース識別子（URI）：汎用構文\"、STD 66、RFC 3986、2005年1月<HTTP：//www.rfc- editor.org/info/rfc3986>。"
    },
    {
      "indent": 3,
      "text": "[RFC5234] Crocker, D. and P. Overell, \"Augmented BNF for Syntax Specifications: ABNF\", STD 68, RFC 5234, January 2008, <http://www.rfc-editor.org/info/rfc5234>.",
      "ja": "[RFC5234]クロッカー、D.、およびP. Overell、 \"構文仕様のための増大しているBNF：ABNF\"、STD 68、RFC 5234、2008年1月、<http://www.rfc-editor.org/info/rfc5234>。"
    },
    {
      "indent": 3,
      "text": "[RFC6234] Eastlake, D. and T. Hansen, \"US Secure Hash Algorithms (SHA and SHA-based HMAC and HKDF)\", RFC 6234, May 2011, <http://www.rfc-editor.org/info/rfc6234>.",
      "ja": "[RFC6234]イーストレイク、D.とT.ハンセン、 \"米国のセキュアハッシュアルゴリズム（SHAとSHAベースのHMACとHKDF）\"、RFC 6234、2011年5月、<http://www.rfc-editor.org/info/ rfc6234>。"
    },
    {
      "indent": 3,
      "text": "[RFC7016] Thornburgh, M., \"Adobe's Secure Real-Time Media Flow Protocol\", RFC 7016, November 2013, <http://www.rfc-editor.org/info/rfc7016>.",
      "ja": "[RFC7016] Thornburgh、M.、 \"Adobeのセキュアリアルタイムメディアフロープロトコル\"、RFC 7016、2013年11月、<http://www.rfc-editor.org/info/rfc7016>。"
    },
    {
      "indent": 3,
      "text": "[RFC7296] Kaufman, C., Hoffman, P., Nir, Y., Eronen, P., and T. Kivinen, \"Internet Key Exchange Protocol Version 2 (IKEv2)\", STD 79, RFC 7296, October 2014, <http://www.rfc-editor.org/info/rfc7296>.",
      "ja": "[RFC7296]カウフマン、C.、ホフマン、P.、ニール、Y.、Eronen、P.、およびT. Kivinen、 \"インターネット鍵交換プロトコルバージョン2（IKEv2の）\"、STD 79、RFC 7296、2014年10月、< http://www.rfc-editor.org/info/rfc7296>。"
    },
    {
      "indent": 3,
      "text": "[RTMP] Adobe Systems Incorporated, \"Real-Time Messaging Protocol (RTMP) specification\", December 2012, <http://www.adobe.com/go/spec_rtmp>.",
      "ja": "[RTMP] Adob​​e Systems Incorporated（アドビシステムズ社）、 \"リアルタイムメッセージングプロトコル（RTMP）の仕様\"、2012年12月、<http://www.adobe.com/go/spec_rtmp>。"
    },
    {
      "indent": 3,
      "text": "[SHA256] National Institute of Standards and Technology, \"Secure Hash Standard\", FIPS PUB 180-4, March 2012, <http://csrc.nist.gov/publications/fips/fips180-4/ fips-180-4.pdf>.",
      "ja": "[SHA256]アメリカ国立標準技術研究所、FIPS PUB 180-4の、2012年3月、<http://csrc.nist.gov/publications/fips/fips180-4/ FIPS-180-4 \"ハッシュ標準セキュア\"。 PDF>。"
    },
    {
      "indent": 0,
      "text": "8.2. Informative References",
      "section_title": true,
      "ja": "8.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[RFC1035] Mockapetris, P., \"Domain names - implementation and specification\", STD 13, RFC 1035, November 1987, <http://www.rfc-editor.org/info/rfc1035>.",
      "ja": "[RFC1035] Mockapetris、P.、 \"ドメイン名 - 実装及び仕様\"、STD 13、RFC 1035、1987年11月、<http://www.rfc-editor.org/info/rfc1035>。"
    },
    {
      "indent": 3,
      "text": "[RFC1071] Braden, R., Borman, D., Partridge, C., and W. Plummer, \"Computing the Internet checksum\", RFC 1071, September 1988, <http://www.rfc-editor.org/info/rfc1071>.",
      "ja": "[RFC1071]ブレーデン、R.、ボーマン、D.、ヤマウズラ、C.、およびW.プラマー、 \"インターネットチェックサムの計算\"、RFC 1071、1988年9月、<http://www.rfc-editor.org/info / rfc1071>。"
    },
    {
      "indent": 3,
      "text": "[RFC4302] Kent, S., \"IP Authentication Header\", RFC 4302, December 2005, <http://www.rfc-editor.org/info/rfc4302>.",
      "ja": "[RFC4302]ケント、S.、 \"IP認証ヘッダー\"、RFC 4302、2005年12月、<http://www.rfc-editor.org/info/rfc4302>。"
    },
    {
      "indent": 3,
      "text": "[RFC4303] Kent, S., \"IP Encapsulating Security Payload (ESP)\", RFC 4303, December 2005, <http://www.rfc-editor.org/info/rfc4303>.",
      "ja": "[RFC4303]ケント、S.、 \"IPカプセル化セキュリティペイロード（ESP）\"、RFC 4303、2005年12月、<http://www.rfc-editor.org/info/rfc4303>。"
    },
    {
      "indent": 3,
      "text": "[RFC6479] Zhang, X. and T. Tsou, \"IPsec Anti-Replay Algorithm without Bit Shifting\", RFC 6479, January 2012, <http://www.rfc-editor.org/info/rfc6479>.",
      "ja": "[RFC6479]チャン、X.とT.ツオウ、RFC 6479、2012年1月 \"のIPsecアンチリプレイアルゴリズムビットシフトなし\"、<http://www.rfc-editor.org/info/rfc6479>。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Special thanks go to Glenn Eguchi, Matthew Kaufman, and Adam Lane for their contributions to the design of this profile.",
      "ja": "特別な感謝は、このプロファイルの設計への貢献のためにグレン・江口、マシュー・カウフマン、そしてアダムレーンに行きます。"
    },
    {
      "indent": 3,
      "text": "Thanks to Philipp Hancke, Kevin Igoe, Paul Kyzivat, and Milos Trboljevac for their detailed reviews of this memo.",
      "ja": "このメモの詳細なレビューのためにフィリップ・Hancke、ケビンIgoe、ポールKyzivat、およびミロスTrboljevacに感謝します。"
    },
    {
      "indent": 0,
      "text": "Author's Address",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Michael C. Thornburgh Adobe Systems Incorporated 345 Park Avenue San Jose, CA 95110-2704 United States",
      "ja": "マイケルC. Thornburgh Adob​​e Systems Incorporated（アドビシステムズ社）345パークアベニューサンノゼ、CA 95110-2704米国"
    },
    {
      "indent": 3,
      "text": "Phone: +1 408 536 6000 EMail: mthornbu@adobe.com URI: http://www.adobe.com/",
      "ja": "電話：+1 408 536 6000 Eメール：mthornbu@adobe.com URI：http://www.adobe.com/"
    }
  ]
}