{
  "title": {
    "text": "RFC 7499 - Support of Fragmentation of RADIUS Packets",
    "ja": "RFC 7499 - RADIUSパケットの断片化のサポート"
  },
  "number": 7499,
  "created_at": "2019-11-03 00:24:51.510362+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)              A. Perez-Mendez, Ed.\nRequest for Comments: 7499                                R. Marin-Lopez\nCategory: Experimental                              F. Pereniguez-Garcia\nISSN: 2070-1721                                          G. Lopez-Millan\n                                                    University of Murcia\n                                                                D. Lopez\n                                                          Telefonica I+D\n                                                                A. DeKok\n                                                          Network RADIUS\n                                                              April 2015",
      "raw": true
    },
    {
      "indent": 15,
      "text": "Support of Fragmentation of RADIUS Packets",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "The Remote Authentication Dial-In User Service (RADIUS) protocol is limited to a total packet size of 4096 bytes. Provisions exist for fragmenting large amounts of authentication data across multiple packets, via Access-Challenge packets. No similar provisions exist for fragmenting large amounts of authorization data. This document specifies how existing RADIUS mechanisms can be leveraged to provide that functionality. These mechanisms are largely compatible with existing implementations, and they are designed to be invisible to proxies and \"fail-safe\" to legacy RADIUS Clients and Servers.",
      "ja": "リモート認証ダイヤルインユーザーサービス（RADIUS）プロトコルは、4096バイトの合計パケット・サイズに制限されます。引当金は、アクセスチャレンジパケットを経由して、複数のパケット間での認証大量のデータを断片化のために存在します。いいえ同様の規定は、許可、大量のデータを断片化するために存在しません。この文書では、既存のRADIUSメカニズムがその機能を提供するために活用することができる方法を指定します。これらのメカニズムは、既存の実装とほぼ互換性があり、それらはプロキシに見えないと、「フェイルセーフ」レガシーRADIUSクライアントとサーバーにするように設計されています。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for examination, experimental implementation, and evaluation.",
      "ja": "このドキュメントはインターネット標準化過程仕様ではありません。それは、検査、実験的な実装、および評価のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document defines an Experimental Protocol for the Internet community. This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are a candidate for any level of Internet Standard; see Section 2 of RFC 5741.",
      "ja": "この文書は、インターネットコミュニティのためにExperimentalプロトコルを定義します。このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。 IESGによって承認されていないすべての文書がインターネットStandardのどんなレベルの候補です。 RFC 5741のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7499.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7499で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2015 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2015 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................4\n   1.1. Requirements Language ......................................6\n2. Status of This Document .........................................6\n3. Scope of This Document ..........................................7\n4. Overview .......................................................10\n5. Fragmentation of Packets .......................................13\n   5.1. Pre-Authorization .........................................14\n   5.2. Post-Authorization ........................................18\n6. Chunk Size .....................................................21\n7. Allowed Large Packet Size ......................................22\n8. Handling Special Attributes ....................................23\n   8.1. Proxy-State Attribute .....................................23\n   8.2. State Attribute ...........................................24\n   8.3. Service-Type Attribute ....................................25\n   8.4. Rebuilding the Original Large Packet ......................25\n9. New T Flag for the Long Extended Type Attribute Definition .....26\n10. New Attribute Definition ......................................26\n   10.1. Frag-Status Attribute ....................................27\n   10.2. Proxy-State-Length Attribute .............................28\n   10.3. Table of Attributes ......................................29\n11. Operation with Proxies ........................................29\n   11.1. Legacy Proxies ...........................................29\n   11.2. Updated Proxies ..........................................29\n12. General Considerations ........................................31\n   12.1. T Flag ...................................................31\n   12.2. Violation of RFC 2865 ....................................32\n   12.3. Proxying Based on User-Name ..............................32\n   12.4. Transport Behavior .......................................33\n13. Security Considerations .......................................33\n14. IANA Considerations ...........................................34\n15. References ....................................................35\n   15.1. Normative References .....................................35\n   15.2. Informative References ...................................35\nAcknowledgements ..................................................37\nAuthors' Addresses ................................................37",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "The RADIUS [RFC2865] protocol carries authentication, authorization, and accounting information between a RADIUS Client and a RADIUS Server. Information is exchanged between them through RADIUS packets. Each RADIUS packet is composed of a header, and zero or more attributes, up to a maximum packet size of 4096 bytes. The protocol is a request/response protocol, as described in the operational model ([RFC6158], Section 3.1).",
      "ja": "RADIUS [RFC2865]プロトコルはRADIUSクライアントとRADIUSサーバ間の認証、許可、アカウンティング情報を運びます。情報は、RADIUSパケットを介してそれらの間で交換されます。各RADIUSパケットは、ヘッダで構成され、ゼロ以上の属性、4096バイトの最大パケットサイズまでです。運用モデル（[RFC6158]、セクション3.1）に記載のようなプロトコルは、要求/応答プロトコルです。"
    },
    {
      "indent": 3,
      "text": "The intention of the above packet size limitation was to avoid UDP fragmentation as much as possible. Back then, a size of 4096 bytes seemed large enough for any purpose. Now, new scenarios are emerging that require the exchange of authorization information exceeding this 4096-byte limit. For instance, the Application Bridging for Federated Access Beyond web (ABFAB) IETF working group defines the transport of Security Assertion Markup Language (SAML) statements from the RADIUS Server to the RADIUS Client [SAML-RADIUS]. This assertion is likely to be larger than 4096 bytes.",
      "ja": "上記のパケットサイズの制限の意図は、できるだけ多くのUDPの断片化を避けるためでした。当時、4096バイトの大きさは、いかなる目的のために十分な大きさに見えました。さて、新しいシナリオは、この4096バイトの制限を超えた認証情報の交換を必要とする浮上しています。例えば、アプリケーションは、フェデレーションアクセスを超えウェブ（ABFAB）のためのブリッジングIETFワーキンググループは、RADIUSサーバからのRADIUSクライアント[SAML-RADIUS]へのSAML（Security Assertion Markup Language）ステートメントの輸送を定義します。この主張は、4096バイトを超える可能性があります。"
    },
    {
      "indent": 3,
      "text": "This means that peers desiring to send large amounts of data must fragment it across multiple packets. For example, RADIUS-EAP [RFC3579] defines how an Extensible Authentication Protocol (EAP) exchange occurs across multiple Access-Request / Access-Challenge sequences. No such exchange is possible for accounting or authorization data. [RFC6158], Section 3.1 suggests that exchanging large amounts of authorization data is unnecessary in RADIUS. Instead, the data should be referenced by name. This requirement allows large policies to be pre-provisioned and then referenced in an Access-Accept. In some cases, however, the authorization data sent by the RADIUS Server is large and highly dynamic. In other cases, the RADIUS Client needs to send large amounts of authorization data to the RADIUS Server. Neither of these cases is met by the requirements in [RFC6158]. As noted in that document, the practical limit on RADIUS packet sizes is governed by the Path MTU (PMTU), which may be significantly smaller than 4096 bytes. The combination of the two limitations means that there is a pressing need for a method to send large amounts of authorization data between RADIUS Client and Server, with no accompanying solution.",
      "ja": "これは、大量のデータを送信することを望むピアは複数のパケットを渡ってそれを断片化しなければならないことを意味します。例えば、RADIUS-EAP [RFC3579]は拡張認証プロトコル（EAP）の交換は、複数のアクセス要求/アクセスチャレンジ配列を横切って発生する方法を定義します。そのような交換は、会計や承認データに対して可能ではありません。 [RFC6158]セクション3.1認可大量のデータを交換するRADIUSに不要であることを示唆しています。代わりに、データは名前で参照する必要があります。この要件は、大規模な政策が事前にプロビジョニングし、その後、受け入れのアクセスで参照することができます。しかし、場合によっては、RADIUSサーバによって送信された認証データは、大規模かつ非常に動的です。他の例では、RADIUSクライアントは、RADIUSサーバーに認証データを大量に送信する必要があります。これらの例どちらも、[RFC6158]で要件によって満たされます。その文書で述べたように、RADIUSパケットサイズに実用上の限界が4096バイトよりも大幅に小さくすることができるパスMTU（PMTU）によって支配されます。 2つの制限の組み合わせが伴わない溶液を用いて、RADIUSクライアントとサーバ間の認証の大量のデータを送信するための方法のための差し迫った必要性があることを意味します。"
    },
    {
      "indent": 3,
      "text": "[RFC6158], Section 3.1 recommends three approaches for the transmission of large amounts of data within RADIUS. However, they are not applicable to the problem statement of this document for the following reasons:",
      "ja": "[RFC6158]セクション3.1はRADIUS内で大量のデータを伝送するための3つのアプローチをお勧めします。しかし、彼らは次のような理由から、このドキュメントの問題声明には適用されません。"
    },
    {
      "indent": 3,
      "text": "o The first approach (utilization of a sequence of packets) does not talk about large amounts of data sent from the RADIUS Client to a RADIUS Server. Leveraging EAP (request/challenge) to send the data is not feasible, as EAP already fills packets to PMTU, and not all authentications use EAP. Moreover, as noted for the NAS-Filter-Rule attribute ([RFC4849]), this approach does not entirely solve the problem of sending large amounts of data from a RADIUS Server to a RADIUS Client, as many current RADIUS attributes are not permitted in Access-Challenge packets.",
      "ja": "最初のアプローチ（パケットのシーケンスの利用）○RADIUSサーバにRADIUSクライアントから送信された大量のデータについて話しません。 EAPはすでにPMTUにパケットを満たし、いないすべての認証は、EAPを使用してデータを送信するためにEAP（要求/挑戦を）活用することは、現実的ではありません。 NAS-FILTER-ルールの属性（[RFC4849]）のために述べたように、多くの現在のRADIUSアトリビュートがで許可されていないようまた、このアプローチは、完全に、RADIUSクライアントへのRADIUSサーバからの大量のデータを送信する問題が解決されませんアクセスチャレンジパケット。"
    },
    {
      "indent": 3,
      "text": "o The second approach (utilization of names rather than values) is not usable either, as using names rather than values is difficult when the nature of the data to be sent is highly dynamic (e.g., a SAML statement or NAS-Filter-Rule attributes). URLs could be used as a pointer to the location of the actual data, but their use would require them to be (a) dynamically created and modified, (b) securely accessed, and (c) accessible from remote systems. Satisfying these constraints would require the modification of several networking systems (e.g., firewalls and web servers). Furthermore, the setup of an additional trust infrastructure (e.g., Public Key Infrastructure (PKI)) would be required to allow secure retrieval of the information from the web server.",
      "ja": "送信されるデータの性質は、SAMLステートメントまたはNASフィルタルール属性、例えば、（非常に動的である場合むしろ値よりも名を使用することは困難であるように、第2のアプローチ（名前ではなく、値の利用）は、いずれか使用可能ではないoを）。 URLは実際のデータの場所へのポインタとして使用することができるが、それらの使用は、（b）に安全にアクセスし、リモートシステムからのアクセス（C）、これら（a）は、動的に作成、変更することが必要になります。これらの制約を満たすことは、いくつかのネットワークシステム（例えば、ファイアウォールやWebサーバ）の変更が必要となります。さらに、追加の信頼インフラストラクチャのセットアップ（例えば、公開鍵基盤（PKI））は、Webサーバからの情報のセキュアな検索を可能にするために必要とされるであろう。"
    },
    {
      "indent": 3,
      "text": "o PMTU discovery does not solve the problem, as it does not allow the sending of data larger than the minimum of (PMTU or 4096) bytes.",
      "ja": "O PMTU発見は、それが（PMTU又は4096）バイトの最小値よりも大きいデータの送信を許可しないように、問題を解決しません。"
    },
    {
      "indent": 3,
      "text": "This document provides a mechanism to allow RADIUS peers to exchange large amounts of authorization data exceeding the 4096-byte limit by fragmenting it across several exchanges. The proposed solution does not impose any additional requirements to the RADIUS system administrators (e.g., need to modify firewall rules, set up web servers, configure routers, or modify any application server). It maintains compatibility with intra-packet fragmentation mechanisms (like those defined in [RFC3579] or [RFC6929]). It is also transparent to existing RADIUS proxies, which do not implement this specification. The only systems needing to implement this RFC are the ones that either generate or consume the fragmented data being transmitted. Intermediate proxies just pass the packets without changes. Nevertheless, if a proxy supports this specification, it may reassemble the data in order to examine and/or modify it.",
      "ja": "このドキュメントでは、RADIUSピアは、いくつかの取引所を渡ってそれを断片化によって、4096バイトの制限を超えて、認可、大量のデータをやり取りできるようにするメカニズムを提供します。提案された解決策は、RADIUSのシステム管理者に追加の要件を課す（例えば、ファイアウォールのルールを変更する必要があり、Webサーバを設定し、ルータを設定、または任意のアプリケーション・サーバを変更）しません。これは、（[RFC3579]または[RFC6929]で定義されたもののような）イントラパケットフラグメンテーションメカニズムとの互換性を維持します。また、この仕様を実装していない既存のRADIUSプロキシに対して透明です。このRFCを実装するために必要とするだけのシステムは、送信されて断片化されたデータを生成又は消費のいずれかのものです。中間プロキシは単に変更せずにパケットを渡します。プロキシはこの仕様をサポートしている場合にもかかわらず、それは検討および/またはそれを修正するために、データを再構築します。"
    },
    {
      "indent": 3,
      "text": "A different approach to deal with RADIUS packets above the 4096-byte limit is described in [RADIUS-Larger-Pkts], which proposes to extend RADIUS over TCP by allowing the Length field in the RADIUS header to take values up to 65535 bytes. This provides a simpler operation, but it has the drawback of requiring every RADIUS proxy in the path between the RADIUS Client and the RADIUS Server to implement the extension as well.",
      "ja": "4096バイト制限より上のRADIUSパケットに対処するための別のアプローチは、65535バイトまでの値を取るためにRADIUSヘッダの長さフィールドを可能にすることによって、TCP上にRADIUSを拡張することを提案している、[RADIUS-大パケット数]に記載されています。これは簡単な操作を提供し、それは同様に拡張を実装するためにRADIUSクライアントとRADIUSサーバとの間の経路内のすべてのRADIUSプロキシを必要とするという欠点を有しています。"
    },
    {
      "indent": 0,
      "text": "1.1. Requirements Language",
      "section_title": true,
      "ja": "1.1。要件言語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [RFC2119]. When these words appear in lower case, they have their natural language meaning.",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はありますRFC 2119 [RFC2119]に記載されているように解釈されます。これらの単語は小文字で表示されたとき、彼らは自然言語の意味を持ちます。"
    },
    {
      "indent": 0,
      "text": "2. Status of This Document",
      "section_title": true,
      "ja": "このドキュメントの2ステータス"
    },
    {
      "indent": 3,
      "text": "This document is an Experimental RFC. It defines a proposal to allow the sending and receiving of data exceeding the 4096-byte limit in RADIUS packets imposed by [RFC2865], without requiring the modification of intermediary proxies.",
      "ja": "このドキュメントは、実験的なRFCです。これは、送信と中間プロキシの変更を必要とせずに、[RFC2865]によって課されたRADIUSパケット内の4096バイトの限界を超えるデータの送受信を可能にする提案を定義します。"
    },
    {
      "indent": 3,
      "text": "The experiment consists of verifying whether the approach is usable in a large-scale environment, by observing the uptake, usability, and operational behavior it shows in large-scale, real-life deployments. In that sense, so far the main use case for this specification is the transportation of large SAML statements defined within the ABFAB architecture [ABFAB-Arch]. Hence, it can be tested wherever an ABFAB deployment is being piloted.",
      "ja": "実験は、それが大規模な、現実の展開で示し取り込み、使いやすさ、および動作挙動を観察することによって、アプローチは、大規模な環境で使用可能であるかどうかを確認することで構成されています。その意味では、これまでに本明細書のための主要なユースケースはABFABアーキテクチャ内で定義された大SAMLステートメント[ABFAB-ARCH]の輸送です。 ABFABの展開が操縦されているところはどこでもしたがって、それを試験することができます。"
    },
    {
      "indent": 3,
      "text": "Besides, this proposal defines some experimental features that will need to be tested and verified before the document can be considered for the Standards Track. The first one of them is the requirement of updating [RFC2865] in order to relax the sentence defined in Section 4.1 of that document that states that \"An Access-Request MUST contain either a User-Password or a CHAP-Password or a State.\" This specification might generate Access-Request packets without any of these attributes. Although all known implementations have chosen the philosophy of \"be liberal in what you accept,\" we need to gain more operational experience to verify that unmodified proxies do not drop these types of packets. More details on this aspect can be found in Section 12.2.",
      "ja": "また、この提案は、文書が標準化過程のために考慮することができる前にテストおよび検証する必要がありますいくつかの実験的な機能を定義します。それらの最初のものは、アクセス要求は、ユーザーのパスワードやCHAP  - パスワードまたは状態のいずれかを含まなければならない」と述べている文書のセクション4.1で定義された文を緩和するために、[RFC2865]を更新する必要があることです。 \"この仕様は、これらの属性のいずれかなしのAccess-Requestパケットを生成することがあります。すべての既知の実装が哲学選ばれているが、「あなたが受け入れるものにリベラルなことを、」我々は、修飾されていないプロキシがパケットのこれらのタイプをドロップしていないことを確認するために、より多くの運用経験を積む必要があります。この点についての詳細は、セクション12.2で見つけることができます。"
    },
    {
      "indent": 3,
      "text": "Another experimental feature of this specification is that it requires proxies to base their routing decisions on the value of the RADIUS User-Name attribute. Our experience is that this is the common behavior; thus, no issues are expected. However, it needs to be confirmed after using different implementations of intermediate proxies. More details on this aspect can be found in Section 12.3.",
      "ja": "この仕様のもう一つの実験的な機能は、それがRADIUSのUser-Name属性の値に自分のルーティング決定をベースにプロキシを必要とすることです。私たちの経験では、これが一般的な動作であるということです。このように、何も問題は予想されません。しかし、それは中間プロキシの異なる実装を使用した後に確認する必要があります。この点についての詳細は、セクション12.3で見つけることができます。"
    },
    {
      "indent": 3,
      "text": "Moreover, this document requires two minor updates to Standards Track documents. First, it modifies the definition of the Reserved field of the Long Extended Type attribute [RFC6929] by allocating an additional flag called the T (Truncation) flag. No issues are expected with this update, although some proxies might drop packets that do not have the Reserved field set to 0. More details on this aspect can be found in Section 12.1.",
      "ja": "また、この文書は標準化過程文書には、2つのマイナーアップデートが必要です。まず、T（切り捨て）フラグと呼ばれる追加のフラグを割り当てることによってロング拡張型属性[RFC6929]のReservedフィールドの定義を修正します。いくつかのプロキシはこの点についての詳細は、12.1項に記載されています0に予約フィールドが設定されていないパケットをドロップする可能性があるが、何の問題は、この更新に期待されていません。"
    },
    {
      "indent": 3,
      "text": "The other Standards Track document that requires a minor update is [RFC6158]. It states that \"attribute designers SHOULD NOT assume that a RADIUS implementation can successfully process RADIUS packets larger than 4096 bytes,\" something no longer true if this document advances.",
      "ja": "マイナーアップデートを必要とし、他の標準化過程ドキュメントは[RFC6158]です。これは、このドキュメントの進歩であれば、もはや本当の何かを「設計者は、RADIUSの実装が正常にRADIUSが4096バイトを超えるパケットを処理できることを仮定するべきではありません属性」と述べています。"
    },
    {
      "indent": 3,
      "text": "A proper \"Updates\" clause will be included for these modifications when/if the experiment is successful and this document is reissued as a Standards Track document.",
      "ja": "実験が成功すると、この文書は標準化過程文書として再発行されている場合とき/適切な「アップデート」句は、これらの変更のために含まれます。"
    },
    {
      "indent": 0,
      "text": "3. Scope of This Document",
      "section_title": true,
      "ja": "このドキュメントの範囲3。"
    },
    {
      "indent": 3,
      "text": "This specification describes how a RADIUS Client and a RADIUS Server can exchange data exceeding the 4096-byte limit imposed by one packet. However, the mechanism described in this specification SHOULD NOT be used to exchange more than 100 kilobytes of data. Any more than this may turn RADIUS into a generic transport protocol, such as TCP or the Stream Control Transmission Protocol (SCTP), which is undesirable. Experience shows that attempts to transport bulk data across the Internet with UDP will inevitably fail, unless these transport attempts reimplement all of the behavior of TCP. The underlying design of RADIUS lacks the proper retransmission policies or congestion control mechanisms that would make it a competitor of TCP.",
      "ja": "この仕様は、RADIUSクライアントとRADIUSサーバは、1つのパケットによって課された4096バイトの制限を超えてデータを交換する方法について説明します。しかしながら、本明細書で説明されたメカニズムは、データの100以上キロバイト交換するために用いるべきではありません。これ以上は望ましくないようなTCP又はストリーム制御伝送プロトコル（SCTP）のような一般的なトランスポートプロトコル、にRADIUSを回すことができます。これらの輸送の試みは、TCPの振る舞いのすべてを再実装しない限り、UDPで、インターネット経由で大量のデータを転送しようとした経験が示すように、必然的に、失敗します。 RADIUSの基礎となる設計はTCPのライバルになるだろう、適切な再送ポリシーや輻輳制御メカニズムを欠いています。"
    },
    {
      "indent": 3,
      "text": "Therefore, RADIUS/UDP transport is by design unable to transport bulk data. It is both undesirable and impossible to change the protocol at this point in time. This specification is intended to allow the transport of more than 4096 bytes of data through existing RADIUS/UDP proxies. Other solutions such as RADIUS/TCP MUST be used when a \"green field\" deployment requires the transport of bulk data.",
      "ja": "したがって、RADIUS / UDPトランスポートは、大量のデータを転送することができない仕様です。この時点でプロトコルを変更することは望ましくないと不可能でもあります。この仕様は、既存のRADIUS / UDPプロキシを介してデータの4096のバイトを超えの輸送を可能にすることを意図しています。 「グリーンフィールド」の展開は、バルクデータの転送を必要とする場合に、このようなRADIUS / TCPなどの他のソリューションを使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Section 7, below, describes in further detail what is considered to be a reasonable amount of data and recommends that administrators adjust limitations on data transfer according to the specific capabilities of their existing systems in terms of memory and processing power.",
      "ja": "セクション7は、以下、データの合理的な量であると考えられるものにさらに詳細に説明し、管理者は、メモリと処理能力の点で、既存のシステムの特定の機能に係るデータ転送に制限を調整することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "Moreover, its scope is limited to the exchange of authorization data, as other exchanges do not require such a mechanism. In particular, authentication exchanges have already been defined to overcome this limitation (e.g., RADIUS-EAP). Moreover, as they represent the most critical part of a RADIUS conversation, it is preferable to not introduce into their operation any modification that may affect existing equipment.",
      "ja": "他の交換は、このような機構を必要としないので、また、その範囲は、認証データの交換に制限されます。具体的には、認証交換は、既にこの制限（例えば、RADIUS-EAP）を克服するために定義されています。彼らはRADIUSの会話の中で最も重要な部分を表してまた、彼らの操作に既存の機器に影響を与える可能性のある変更を導入しないことが好ましいです。"
    },
    {
      "indent": 3,
      "text": "There is no need to fragment accounting packets either. While the accounting process can send large amounts of data, that data is typically composed of many small updates. That is, there is no demonstrated need to send indivisible blocks of more than 4 kilobytes of data. The need to send large amounts of data per user session often originates from the need for flow-based accounting. In this use case, the RADIUS Client may send accounting data for many thousands of flows, where all those flows are tied to one user session. The existing Acct-Multi-Session-Id attribute defined in [RFC2866], Section 5.11 has been proven to work here.",
      "ja": "いずれかのアカウンティングパケットを断片化する必要はありません。課金処理は、大量のデータを送信することができますが、そのデータは、典型的には、多くの小さなアップデートで構成されています。つまり、データの以上4キロバイトの不可分のブロックを送信するために何を実証する必要がありません、です。ユーザー・セッションごとに大量のデータを送信する必要性は、多くの場合、フローベースの会計処理の必要性に由来します。このユースケースでは、RADIUSクライアントは、すべてのこれらのフローは、1つのユーザーセッションに関連付けられていますが流れ、数千のアカウンティングデータを送信することができます。 [RFC2866]で定義された既存のAcct-Multi-Session-Id属性、5.11はここで働くことが証明されました。"
    },
    {
      "indent": 3,
      "text": "Similarly, there is no need to fragment Change-of-Authorization (CoA) [RFC5176] packets. Instead, according to [RFC5176], the CoA client will send a CoA-Request packet containing session identification attributes, along with Service-Type = Additional-Authorization, and a State attribute. Implementations not supporting fragmentation will respond with a CoA-NAK and an Error-Cause of Unsupported-Service.",
      "ja": "同様に、チェンジ・オブ・認可（COA）[RFC5176]パケットを断片化する必要はありません。代わりに、[RFC5176]によると、CoAのクライアントは、サービスタイプ=追加承認、およびState属性と一緒に、セッション識別属性を含むアシルCoA-Requestパケットを送信します。断片化をサポートしない実装は、アシルCoA-NAKおよびサポートされていない、サービスのエラー、原因で応答します。"
    },
    {
      "indent": 3,
      "text": "The above requirement does not assume that the CoA client and the RADIUS Server are co-located. They may, in fact, be run on separate parts of the infrastructure, or even by separate administrators. There is, however, a requirement that the two communicate. We can see that the CoA client needs to send session identification attributes in order to send CoA packets. These attributes cannot be known a priori by the CoA client and can only come from the RADIUS Server. Therefore, even when the two systems are not co-located, they must be able to communicate in order to operate in unison. The alternative is for the two systems to have differing views of the users' authorization parameters; such a scenario would be a security disaster.",
      "ja": "上記の要件は、CoAのクライアントとRADIUSサーバは、同じ場所に配置されていることを前提としていません。彼らは、実際には、インフラの別々の部分に、あるいは別の管理者によって実行することができます。 2が通信要件は、しかし、があります。私たちは、CoAのクライアントがCoAのパケットを送信するために、セッション識別属性を送信する必要があることがわかります。これらの属性は、CoAのクライアントによって事前に知ることができないとだけRADIUSサーバから来ることができます。 2つのシステムが同じ場所に配置しない場合であってもそのため、それらは一斉に動作するために通信することができなければなりません。 2つのシステムは、ユーザーの許可パラメータの異なる見解を持つようにするための代替です。このようなシナリオは、セキュリティ上の災害となります。"
    },
    {
      "indent": 3,
      "text": "This specification does not allow for fragmentation of CoA packets. Allowing for fragmented CoA packets would involve changing multiple parts of the RADIUS protocol; such changes introduce the risk of implementation issues, mistakes, etc.",
      "ja": "この仕様は、CoAのパケットの断片化を許可していません。 RADIUSプロトコルの複数の部分を変更伴うだろう断片化のCoAパケットを可能にします。このような変化は、実装上の問題、ミスなどのリスクを紹介します"
    },
    {
      "indent": 3,
      "text": "Where CoA clients (i.e., RADIUS Servers) need to send large amounts of authorization data to a CoA server (i.e., RADIUS Client), they need only send a minimal CoA-Request packet containing a Service-Type of Authorize Only, as per [RFC5176], along with session identification attributes. This CoA packet serves as a signal to the RADIUS Client that the users' session requires re-authorization. When the RADIUS Client re-authorizes the user via Access-Request, the RADIUS Server can perform fragmentation and send large amounts of authorization data to the RADIUS Client.",
      "ja": "CoAのクライアント（すなわち、RADIUSサーバ）がCoAのサーバ（すなわち、RADIUSクライアント）は、彼らが唯一のとおり、オーサライズ時のみのサービスタイプを含む最小のCoA-Requestパケットを送信する必要があるため、許可大量のデータを送信する必要がある場合は[ RFC5176]、セッション識別属性と一緒。このCoAのパケットは、ユーザーのセッションが再認証を必要とするRADIUSクライアントへの信号となります。 RADIUSクライアントがアクセス要求を介してユーザを再認証する場合は、RADIUSサーバは、断片化を実行し、RADIUSクライアントに承認大量のデータを送信することができます。"
    },
    {
      "indent": 3,
      "text": "The assumption in the above scenario is that the CoA client and RADIUS Server are co-located, or at least strongly coupled. That is, the path from CoA client to CoA server SHOULD be the exact reverse of the path from RADIUS Client to RADIUS Server. The following diagram will hopefully clarify the roles:",
      "ja": "上記のシナリオでの仮定は、CoAのクライアントとRADIUSサーバが同じ場所に配置、または少なくとも強く結合されていることです。これは、CoAのサーバへのCoAクライアントからのパスがRADIUSサーバーへのRADIUSクライアントからのパスを正確に逆でなければならないです。次の図は、うまくいけば、役割を明確にします。"
    },
    {
      "indent": 17,
      "text": "             +----------------+\n             | RADIUS   CoA   |\n             | Client  Server |\n             +----------------+\n                |        ^\nAccess-Request  |        |   CoA-Request\n                v        |\n             +----------------+\n             | RADIUS   CoA   |\n             | Server  Client |\n             +----------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Where there is a proxy involved:",
      "ja": "どこに関与プロキシがあります："
    },
    {
      "indent": 17,
      "text": "             +----------------+\n             | RADIUS   CoA   |\n             | Client  Server |\n             +----------------+\n                |        ^\nAccess-Request  |        |   CoA-Request\n                v        |\n             +----------------+\n             | RADIUS   CoA   |\n             | Proxy   Proxy  |\n             +----------------+\n                |        ^\nAccess-Request  |        |   CoA-Request\n                v        |\n             +----------------+\n             | RADIUS   CoA   |\n             | Server  Client |\n             +----------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "That is, the RADIUS and CoA subsystems at each hop are strongly connected. Where they are not strongly connected, it will be impossible to use CoA-Request packets to transport large amounts of authorization data.",
      "ja": "これは、各ホップでRADIUSとCoAのサブシステムが強く接続されている、です。彼らは強く接続されていない場合は、承認大量のデータを転送するためのCoA-Requestパケットを使用することは不可能になります。"
    },
    {
      "indent": 3,
      "text": "This design is more complicated than allowing for fragmented CoA packets. However, the CoA client and the RADIUS Server must communicate even when not using this specification. We believe that standardizing that communication and using one method for exchange of large data are preferred to unspecified communication methods and multiple ways of achieving the same result. If we were to allow fragmentation of data over CoA packets, the size and complexity of this specification would increase significantly.",
      "ja": "このデザインは、断片化されたCoAのパケットを可能にするよりも複雑です。しかし、CoAのクライアントとRADIUSサーバは、この仕様を使用していない場合でも通信する必要があります。我々は、その通信を標準化し、大規模なデータの交換のための1つの方法を用いては、不特定の通信方式と同じ結果を達成する複数の方法に好適であると考えています。我々はCoAのパケットを超えるデータの断片化を許可した場合は、この仕様のサイズと複雑さが大幅に増加するであろう。"
    },
    {
      "indent": 3,
      "text": "The above requirement solves a number of issues. It clearly separates session identification from authorization. Without this separation, it is difficult to both identify a session and change its authorization using the same attribute. It also ensures that the authorization process is the same for initial authentication and for CoA.",
      "ja": "上記の要件は、多くの問題を解決します。これは明らかに、認可からセッション識別を分離します。この分離がなければ、セッションを識別し、同じ属性を使用して、その許可を変更するには、両方のは難しいです。また、許可プロセスは、初期認証のためとCoAのために同じであることを保証します。"
    },
    {
      "indent": 0,
      "text": "4. Overview",
      "section_title": true,
      "ja": "4.概要"
    },
    {
      "indent": 3,
      "text": "Authorization exchanges can occur either before or after end-user authentication has been completed. An authorization exchange before authentication allows a RADIUS Client to provide the RADIUS Server with information that MAY modify how the authentication process will be performed (e.g., it may affect the selection of the EAP method). An authorization exchange after authentication allows the RADIUS Server to provide the RADIUS Client with information about the end user, the results of the authentication process, and/or obligations to be enforced. In this specification, we refer to \"pre-authorization\" as the exchange of authorization information before the end-user authentication has started (from the RADIUS Client to the RADIUS Server), whereas the term \"post-authorization\" is used to refer to an authorization exchange happening after this authentication process (from the RADIUS Server to the RADIUS Client).",
      "ja": "認証交換は、エンドユーザの認証が完了する前または後に発生する可能性があります。認証前に承認交換は、RADIUSクライアントが認証プロセスが（例えば、それはEAP方式の選択に影響を与える可能性がある）を実行する方法を修正することができた情報とRADIUSサーバを提供することができます。認証後の認可交換は、認証プロセスの結果、および/または義務を強制するために、エンドユーザーに関する情報をRADIUSクライアントを提供するために、RADIUSサーバを可能にします。用語「ポスト認可が」を参照するために使用されるのに対し、エンドユーザ認証の前に認証情報の交換は、（RADIUSクライアントからRADIUSサーバに）開始されたとして、この明細書では、「事前承認」を参照してください。 （RADIUSクライアントへのRADIUSサーバからの）この認証プロセスの後に起こっ認証交換。"
    },
    {
      "indent": 3,
      "text": "In this specification, we refer to the \"size limit\" as the practical limit on RADIUS packet sizes. This limit is the minimum between 4096 bytes and the current PMTU. We define below a method that uses Access-Request and Access-Accept in order to exchange fragmented data. The RADIUS Client and Server exchange a series of Access-Request / Access-Accept packets, until such time as all of the fragmented data has been transported. Each packet contains a Frag-Status attribute, which lets the other party know if fragmentation is desired, ongoing, or finished. Each packet may also contain the fragmented data or may instead be an \"ACK\" to a previous fragment from the other party. Each Access-Request contains a User-Name attribute, allowing the packet to be proxied if necessary (see Section 11.1). Each Access-Request may also contain a State attribute, which serves to tie it to a previous Access-Accept. Each Access-Accept contains a State attribute, for use by the RADIUS Client in a later Access-Request. Each Access-Accept contains a Service-Type attribute with the \"Additional-Authorization\" value. This indicates that the service being provided is part of a fragmented exchange and that the Access-Accept should not be interpreted as providing network access to the end user.",
      "ja": "この仕様では、RADIUSパケットサイズに実用上の制限として「サイズ制限」を参照してください。この制限は、4096バイトと現在のPMTUの間で最小です。私たちは、アクセス要求と断片化されたデータを交換するために、アクセス承認を使用する方法の下に定義します。 RADIUSクライアントとサーバーの交換アクセス要求/アクセス - 受け入れ一連のパケット、断片化されたデータのすべてのような時間が搬送されてきたまで。各パケットはフラグメンテーションは、現在進行中の希望、または終了した場合、他の当事者は知ることができますFRAG-Status属性が含まれています。各パケットはまた、断片化されたデータを含んでいてもよく、または代わりに他の当事者から前のフラグメントに「ACK」であってもよいです。各アクセス要求が必要な場合は、パケットをプロキシすることができるように、User-Name属性が含まれています（11.1節を参照してください）。各アクセス要求は、以前のアクセス-受け入れるようにそれを結ぶのに役立つ州属性を含んでいてもよいです。各アクセス・受け入れは、後でアクセス要求内のRADIUSクライアントで使用するために、State属性が含まれています。各アクセス・受け入れは、「追加の承認」の値を持つservice-type属性が含まれています。これは、提供されるサービスは、断片化交換の一部であることと、接続許可をエンドユーザにネットワークアクセスを提供するものとして解釈されるべきではないことを示しています。"
    },
    {
      "indent": 3,
      "text": "When a RADIUS Client or RADIUS Server needs to send data that exceeds the size limit, the mechanism proposed in this document is used. Instead of encoding one large RADIUS packet, a series of smaller RADIUS packets of the same type are encoded. Each smaller packet is called a \"chunk\" in this specification, in order to distinguish it from traditional RADIUS packets. The encoding process is a simple linear walk over the attributes to be encoded. This walk preserves the order of the attributes of the same type, as required by [RFC2865]. The number of attributes encoded in a particular chunk depends on the size limit, the size of each attribute, the number of proxies between the RADIUS Client and RADIUS Server, and the overhead for fragmentation-signaling attributes. Specific details are given in Section 6. A new attribute called Frag-Status (Section 10.1) signals the fragmentation status.",
      "ja": "RADIUSクライアントまたはRADIUSサーバがサイズ制限を超えてデータを送信する必要がある場合、この文書で提案されたメカニズムが使用されています。代わりに一つの大きなRADIUSパケットを、同じタイプの小さいRADIUSパケットの系列を符号化する符号化されます。各小さなパケットは、伝統的なRADIUSパケットからそれを区別するために、本明細書では「チャンク」と呼ばれています。符号化プロセスは、符号化される属性の上に単純な線形徒歩です。このウォークは、[RFC2865]で必要に応じて、同じタイプの属性の順序を保持します。特定のチャンクに符号化属性の数は、サイズ制限、各属性のサイズ、RADIUSクライアントとRADIUSサーバとの間のプロキシの数、および断片化シグナル属性のオーバーヘッドに依存します。具体的な詳細はFRAG-ステータス（10.1節）と呼ばれる新しい属性が断片化の状態を知らせる第6節に記載されています。"
    },
    {
      "indent": 3,
      "text": "After the first chunk is encoded, it is sent to the other party. The packet is identified as a chunk via the Frag-Status attribute. The other party then requests additional chunks, again using the Frag-Status attribute. This process is repeated until all the attributes have been sent from one party to the other. When all the chunks have been received, the original list of attributes is reconstructed and processed as if it had been received in one packet.",
      "ja": "最初のチャンクがエンコードされた後、それが相手に送信されます。パケットは、FRAG-Status属性を経由してチャンクとして識別されます。相手が再びFRAG-Status属性を使用して、追加のチャンクを要求します。すべての属性が他に一方の当事者から送信されるまで、このプロセスが繰り返されます。すべてのチャンクが受信されたとき、属性の元のリストが再構築され、それが1つのパケットで受信されたかのように処理されます。"
    },
    {
      "indent": 3,
      "text": "The reconstruction process is performed by simply appending all of the chunks together. Unlike IPv4 fragmentation, there is no Fragment Offset field. The chunks in this specification are explicitly ordered, as RADIUS is a lock-step protocol, as noted in Section 12.4. That is, chunk N+1 cannot be sent until all of the chunks up to and including N have been received and acknowledged.",
      "ja": "再構成処理は、単に一緒にチャンクのすべてを追加することによって行われます。 IPv4の断片化とは異なり、フラグメントオフセットフィールドがありません。 RADIUSは、ロックステッププロトコルであるように、セクション12.4で述べたように、本明細書においてチャンクが明示的に、順序付けされます。これは、Nを含むまでのチャンクとの全てが受信され、認知されるまでのチャンクN + 1を送信することはできません、です。"
    },
    {
      "indent": 3,
      "text": "When multiple chunks are sent, a special situation may occur for Long Extended Type attributes as defined in [RFC6929]. The fragmentation process may split a fragmented attribute across two or more chunks, which is not permitted by that specification. We address this issue by using the newly defined T flag in the Reserved field of the Long Extended Type attribute format (see Section 9 for further details on this flag).",
      "ja": "複数のチャンクが送信される場合は、[RFC6929]で定義されるように、特殊な状況がロング拡張型属性の発生する可能性があります。断片化プロセスは、その仕様によって許可されていない二つ以上のチャンクにわたって断片化された属性を分割してもよいです。私たちは、ロング拡張型属性の形式（このフラグの詳細については、セクション9を参照）の予約フィールドに新たに定義されたTフラグを使用することによって、この問題に対処します。"
    },
    {
      "indent": 3,
      "text": "This last situation is expected to be the most common occurrence in chunks. Typically, packet fragmentation will occur as a consequence of a desire to send one or more large (and therefore fragmented) attributes. The large attribute will likely be split into two or more pieces. Where chunking does not split a fragmented attribute, no special treatment is necessary.",
      "ja": "この最後の状況はチャンクで最もよく発生することが予想されます。典型的には、パケットの断片化は、一つ以上大きい（したがって、断片化）を送信したいという要望の結果として発生する属性。大規模な属性は、おそらく2個以上に分割されます。チャンクが断片化属性を分割しない場合は、特別な治療は必要ありません。"
    },
    {
      "indent": 3,
      "text": "The setting of the T flag is the only case where the chunking process affects the content of an attribute. Even then, the Value fields of all attributes remain unchanged. Any per-packet security attributes, such as Message-Authenticator, are calculated for each chunk independently. Neither integrity checks nor security checks are performed on the \"original\" packet.",
      "ja": "Tフラグの設定は、チャンキングプロセスは、属性の内容に影響を与える場合のみです。それでも、すべての属性の値のフィールドは変更されません。そのようなメッセージ認証などの任意のパケットごとのセキュリティ属性は、独立して、各チャンクに対して計算されます。どちらも整合性チェックやセキュリティチェックは、「オリジナル」のパケット上で実行されています。"
    },
    {
      "indent": 3,
      "text": "Each RADIUS packet sent or received as part of the chunking process MUST be a valid packet, subject to all format and security requirements. This requirement ensures that a \"transparent\" proxy not implementing this specification can receive and send compliant packets. That is, a proxy that simply forwards packets without detailed examination or any modification will be able to proxy \"chunks\".",
      "ja": "チャンキングプロセスの一部として送信または受信される各RADIUSパケットは、すべてのフォーマットとセキュリティ要件の対象に有効なパケットでなければなりません。この要件は、この仕様を実装していない「透明」プロキシが受け取り、対応のパケットを送信できることを保証します。それは単に、詳細な検査やプロキシ「チャンク」のことができるようになり、そのままパケットを転送するプロキシです。"
    },
    {
      "indent": 0,
      "text": "5. Fragmentation of Packets",
      "section_title": true,
      "ja": "パケットのフラグメント化5。"
    },
    {
      "indent": 3,
      "text": "When the RADIUS Client or the RADIUS Server desires to send a packet that exceeds the size limit, it is split into chunks and sent via multiple client/server exchanges. The exchange is indicated via the Frag-Status attribute, which has value More-Data-Pending for all but the last chunk of the series. The chunks are tied together via the State attribute.",
      "ja": "RADIUSクライアントまたはRADIUSサーバがサイズ制限を超えるパケットを送信したい場合、それはチャンクに分割し、複数のクライアント/サーバ交換を経由して送信されます。交換は値より-DATA-保留シリーズの全てが、最後のチャンクのを持っているFRAG-Status属性を介して表示されます。チャンクはState属性を介して互いに接続されています。"
    },
    {
      "indent": 3,
      "text": "The delivery of a large fragmented RADIUS packet with authorization data can happen before or after the end user has been authenticated by the RADIUS Server. We can distinguish two phases, which can be omitted if there is no authorization data to be sent:",
      "ja": "認証データを持つ大規模な断片化されたRADIUSパケットの配信は、エンドユーザーの前または後に発生する可能性がRADIUSサーバによって認証されています。私たちは、送信する一切の権限データが存在しない場合は省略することができる2つのフェーズを、区別することができます。"
    },
    {
      "indent": 3,
      "text": "1. Pre-authorization. In this phase, the RADIUS Client MAY send a large packet with authorization information to the RADIUS Server before the end user is authenticated. Only the RADIUS Client is allowed to send authorization data during this phase.",
      "ja": "1.事前承認。エンドユーザーが認証される前に、この段階では、RADIUSクライアントは、RADIUSサーバーに認証情報を持つ大規模なパケットを送信することができます。唯一のRADIUSクライアントは、この段階認証データを送信することが許可されています。"
    },
    {
      "indent": 3,
      "text": "2. Post-authorization. In this phase, the RADIUS Server MAY send a large packet with authorization data to the RADIUS Client after the end user has been authenticated. Only the RADIUS Server is allowed to send authorization data during this phase.",
      "ja": "2.ポスト承認。エンドユーザーが認証された後、この段階では、RADIUSサーバは、RADIUSクライアントに認証データを持つ大規模なパケットを送信することができます。唯一のRADIUSサーバは、このフェーズで認証データを送信することが許可されています。"
    },
    {
      "indent": 3,
      "text": "The following subsections describe how to perform fragmentation for packets for these two phases. We give the packet type, along with a RADIUS Identifier, to indicate that requests and responses are connected. We then give a list of attributes. We do not give values for most attributes, as we wish to concentrate on the fragmentation behavior rather than packet contents. Attribute values are given for attributes relevant to the fragmentation process. Where \"long extended\" attributes are used, we indicate the M (More) and T (Truncation) flags as optional square brackets after the attribute name. As no \"long extended\" attributes have yet been defined, we use example attributes, named as \"Example-Long-1\", etc. For the sake of simplicity, the maximum chunk size is established in terms of the number of attributes (11).",
      "ja": "以下のサブセクションでは、これら二つのフェーズのためのパケットの断片化を実行する方法について説明します。私たちは、要求と応答が接続されていることを示すために、RADIUS識別子とともに、パケットの種類を与えます。私たちは、その後、属性のリストを与えます。私たちは、断片化の振る舞いではなく、パケットの内容に集中したいと私たちは、ほとんどの属性に値を与えることはありません。属性値は、断片化プロセスに関連する属性のために与えられています。 「長い拡張」属性が使用されている場合は、我々は、属性名の後に、オプションの角括弧としてM（より）とT（切り捨て）のフラグを示しています。いかなる「長い拡張」の属性がまだ定義されていないとして、我々は例を使用すると、簡単のため等、「例ロング-1」と命名し、属性、最大チャンクサイズは、属性の数で確立されている（11 ）。"
    },
    {
      "indent": 0,
      "text": "5.1. Pre-Authorization",
      "section_title": true,
      "ja": "5.1。事前承認"
    },
    {
      "indent": 3,
      "text": "When the RADIUS Client needs to send a large amount of data to the RADIUS Server, the data to be sent is split into chunks and sent to the RADIUS Server via multiple Access-Request / Access-Accept exchanges. The example below shows this exchange.",
      "ja": "RADIUSクライアントは、RADIUSサーバーに大量のデータを送信する必要がある場合、送信するデータをチャンクに分割し、複数のアクセス要求/アクセス - 受け入れ交流を経由してRADIUSサーバに送信されます。以下の例では、この交換を示しています。"
    },
    {
      "indent": 3,
      "text": "The following is an Access-Request that the RADIUS Client intends to send to a RADIUS Server. However, due to a combination of issues (PMTU, large attributes, etc.), the content does not fit into one Access-Request packet.",
      "ja": "以下は、RADIUSクライアントがRADIUSサーバに送信しようとアクセス要求です。しかし、問題（PMTU、大属性など）の組み合わせに、コンテンツが1のAccess-Requestパケットに収まりません。"
    },
    {
      "indent": 3,
      "text": "Access-Request User-Name NAS-Identifier Calling-Station-Id Example-Long-1 [M] Example-Long-1 [M] Example-Long-1 [M] Example-Long-1 [M] Example-Long-1 [M] Example-Long-1 [M] Example-Long-1 [M] Example-Long-1 [M] Example-Long-1 Example-Long-2 [M] Example-Long-2 [M] Example-Long-2",
      "ja": "アクセス要求ユーザ名NAS-識別子発信ステーション-ID例ロング-1 [M]例 - ロング1 [M]例 - ロング1 [M]例 - ロング1 [M]例 - 長期性1 [M]例 - ロング1 [M]例 - ロング1 [M]例 - ロング1 [M]例 - ロング1例-長期2 [M]例 - ロング2 [M]例-long-2"
    },
    {
      "indent": 21,
      "text": "Figure 1: Desired Access-Request",
      "ja": "図1：理想のアクセス要求"
    },
    {
      "indent": 3,
      "text": "The RADIUS Client therefore must send the attributes listed above in a series of chunks. The first chunk contains eight (8) attributes from the original Access-Request, and a Frag-Status attribute. Since the last attribute is \"Example-Long-1\" with the M flag set, the chunking process also sets the T flag in that attribute. The Access-Request is sent with a RADIUS Identifier field having value 23. The Frag-Status attribute has value More-Data-Pending, to indicate that the RADIUS Client wishes to send more data in a subsequent Access-Request. The RADIUS Client also adds a Service-Type attribute, which indicates that it is part of the chunking process. The packet is signed with the Message-Authenticator attribute, completing the maximum number of attributes (11).",
      "ja": "RADIUSクライアントは、したがって、一連のチャンクに、上記の属性を送信する必要があります。最初のチャンクは、8（8）オリジナルのアクセス要求、およびFRAG-Status属性から属性が含まれています。最後の属性は、「例 - ロング1」Mフラグが設定されているので、チャンキングプロセスは、その属性にTフラグをセットします。アクセス要求がRADIUS識別子フィールド持つ値23で送信されFRAG-Status属性は、RADIUSクライアントは、後続のアクセス要求に、より多くのデータを送信することを望んでいることを示す値より-DATA-保留を持っています。 RADIUSクライアントはまた、チャンキングプロセスの一部であることを示しservice-type属性を追加します。パケットは、属性の最大数（11）を完成、メッセージ認証属性を使用して署名されます。"
    },
    {
      "indent": 3,
      "text": "Access-Request (ID = 23) User-Name NAS-Identifier Calling-Station-Id Example-Long-1 [M] Example-Long-1 [M] Example-Long-1 [M] Example-Long-1 [M] Example-Long-1 [MT] Frag-Status = More-Data-Pending Service-Type = Additional-Authorization Message-Authenticator",
      "ja": "例 - ロング1 [M]例 - ロング1 [M]例 - ロング1 [M]例 - ロング1 [M-ステーション-IDを呼び出すアクセス要求（ID = 23）ユーザ名NAS-識別子]例 - ロング-1 [MT] FRAG-ステータス=もっと-DATA-保留サービスタイプ=追加の承認メッセージ認証"
    },
    {
      "indent": 20,
      "text": "Figure 2: Access-Request (Chunk 1)",
      "ja": "図2：アクセス要求（チャンク1）"
    },
    {
      "indent": 3,
      "text": "Compliant RADIUS Servers (i.e., servers implementing fragmentation) receiving this packet will see the Frag-Status attribute and will postpone all authorization and authentication handling until all of the chunks have been received. This postponement also applies to the verification that the Access-Request packet contains some kind of authentication attribute (e.g., User-Password, CHAP-Password, State, or other future attribute), as required by [RFC2865] (see Section 12.2 for more information on this).",
      "ja": "このパケットを受信準拠のRADIUSサーバ（断片化を実装する、すなわち、サーバ）FRAG-Status属性が表示され、チャンクの全てが受信されるまで、すべての認可および認証処理を延期します。 [RFC2865]で必要とされるように、この延期は、（よりについては、セクション12.2を参照してください、アクセス要求パケットが認証属性（例えば、ユーザー・パスワード、CHAP-パスワード、州、または他の将来の属性）のいくつかの種類が含まれていることを検証に適用されますこれに関する情報）。"
    },
    {
      "indent": 3,
      "text": "Non-compliant RADIUS Servers (i.e., servers not implementing fragmentation) should also see the Service-Type requesting provisioning for an unknown service and return Access-Reject. Other non-compliant RADIUS Servers may return an Access-Reject or Access-Challenge, or they may return an Access-Accept with a particular Service-Type other than Additional-Authorization. Compliant RADIUS Client implementations MUST treat these responses as if they had received Access-Reject instead.",
      "ja": "（すなわち、サーバは断片化を実装していない）非対応のRADIUSサーバはまた、サービスタイプが未知のサービスのプロビジョニングを要求して表示し、アクセス拒否を返す必要があります。その他の非準拠のRADIUSサーバーはアクセス拒否またはアクセスチャレンジを返すことがあり、または彼らは追加の承認以外の特定のサービスタイプにアクセス承認を返すことがあります。彼らは代わりに拒否アクセスを受けたかのように準拠したRADIUSクライアントの実装は、これらの応答を扱わなければなりません。"
    },
    {
      "indent": 3,
      "text": "Compliant RADIUS Servers who wish to receive all of the chunks will respond with the following packet. The value of the State here is arbitrary and serves only as a unique token for example purposes. We only note that it MUST be temporally unique to the RADIUS Server.",
      "ja": "チャンクの全てを受け取りたい準拠のRADIUSサーバには、次のパケットで応答します。ここで状態の値は任意であり、例示のみの目的のために一意のトークンとして働きます。私たちは、それがRADIUSサーバに一時的にユニークである必要があります。"
    },
    {
      "indent": 3,
      "text": "Access-Accept (ID = 23) Frag-Status = More-Data-Request Service-Type = Additional-Authorization State = 0xabc00001 Message-Authenticator",
      "ja": "アクセス・受け入れ（ID = 23）FRAG-ステータス=もっと-データ - 要求サービスタイプ=追加の承認状態= 0xabc00001メッセージ認証"
    },
    {
      "indent": 21,
      "text": "Figure 3: Access-Accept (Chunk 1)",
      "ja": "図3：アクセス承諾（チャンク1）"
    },
    {
      "indent": 3,
      "text": "The RADIUS Client will see this response and use the RADIUS Identifier field to associate it with an ongoing chunking session. Compliant RADIUS Clients will then continue the chunking process. Non-compliant RADIUS Clients will never see a response such as this, as they will never send a Frag-Status attribute. The Service-Type attribute is included in the Access-Accept in order to signal that the response is part of the chunking process. This packet therefore does not provision any network service for the end user.",
      "ja": "RADIUSクライアントは、この応答を確認し、継続的なチャンクのセッションに関連付けることがRADIUS Identifierフィールドを使用します。準拠のRADIUSクライアントは、その後、チャンキング・プロセスを継続します。彼らはFRAG-Status属性を送信することはありませんように、非準拠のRADIUSクライアントは、このような応答を見ることはありません。 service-type属性は、応答がチャンク・プロセスの一部であることを知らせるために、アクセス・受け入れに含まれています。このパケットは、したがって、提供、エンドユーザーのための任意のネットワークサービスをしません。"
    },
    {
      "indent": 3,
      "text": "The RADIUS Client continues the process by sending the next chunk, which includes an additional six (6) attributes from the original packet. It again includes the User-Name attribute, so that non-compliant proxies can process the packet (see Section 11.1). It sets the Frag-Status attribute to More-Data-Pending, as more data is pending. It includes a Service-Type, for the reasons described above. It includes the State attribute from the previous Access-Accept. It signs the packet with Message-Authenticator, as there are no authentication attributes in the packet. It uses a new RADIUS Identifier field.",
      "ja": "RADIUSクライアントは、次のチャンクを送信することによって処理を継続さらに6（6）オリジナルのパケットから属性。非準拠のプロキシがパケットを処理できること（11.1節を参照）ので、それは再び、User-Name属性が含まれています。より多くのデータが保留されているように、それは、より多くの-DATA-保留にFRAG-Status属性を設定します。これは、前述の理由により、サービスタイプを含んでいます。これは、以前のAccess-受け入れからState属性を含んでいます。パケットには認証属性が存在しないように、それは、メッセージ認証とパケットに署名します。これは、新しいRADIUS Identifierフィールドを使用しています。"
    },
    {
      "indent": 3,
      "text": "Access-Request (ID = 181) User-Name Example-Long-1 [M] Example-Long-1 [M] Example-Long-1 [M] Example-Long-1 Example-Long-2 [M] Example-Long-2 [MT] Frag-Status = More-Data-Pending Service-Type = Additional-Authorization State = 0xabc000001 Message-Authenticator",
      "ja": "アクセス要求（ID = 181）は、ユーザ名の例ロング-1 [M]例 - ロング1 [M]例 - ロング1 [M]例 - ロング1例 - ロング2 [M]例 - ロング-2 [MT] FRAG-ステータス=もっと-DATA-保留サービスタイプ=追加の承認状態= 0xabc000001メッセージ認証"
    },
    {
      "indent": 20,
      "text": "Figure 4: Access-Request (Chunk 2)",
      "ja": "図4：アクセス要求（チャンク2）"
    },
    {
      "indent": 3,
      "text": "Compliant RADIUS Servers receiving this packet will see the Frag-Status attribute and look for a State attribute. Since one exists and it matches a State sent in an Access-Accept, this packet is part of a chunking process. The RADIUS Server will associate the attributes with the previous chunk. Since the Frag-Status attribute has value More-Data-Request, the RADIUS Server will respond with an Access-Accept as before. It MUST include a State attribute, with a value different from the previous Access-Accept. This State MUST again be globally and temporally unique.",
      "ja": "このパケットを受信準拠のRADIUSサーバは、FRAG-Status属性を参照し、State属性を探します。 1が存在し、それがアクセス - 受け入れに送られた状態と一致しているので、このパケットは、チャンキングプロセスの一部です。 RADIUSサーバは、前のチャンクと属性を関連付けます。 FRAG-Status属性が値より-データ-Requestを持っているので、RADIUSサーバは、アクセス・受け入れなど前で応答します。これは、以前のAccess-受け入れ異なる値を持つ州属性を含まなければなりません。この状態は、再び世界的にかつ時間的にユニークでなければなりません。"
    },
    {
      "indent": 3,
      "text": "Access-Accept (ID = 181) Frag-Status = More-Data-Request Service-Type = Additional-Authorization State = 0xdef00002 Message-Authenticator",
      "ja": "アクセス・受け入れ（ID = 181）FRAG-ステータス=もっと-データ - 要求サービスタイプ=追加の承認状態= 0xdef00002メッセージ認証"
    },
    {
      "indent": 21,
      "text": "Figure 5: Access-Accept (Chunk 2)",
      "ja": "図5：アクセス承諾（チャンク2）"
    },
    {
      "indent": 3,
      "text": "The RADIUS Client will see this response and use the RADIUS Identifier field to associate it with an ongoing chunking session. The RADIUS Client continues the chunking process by sending the next chunk, with the final attribute(s) from the original packet, and again includes the original User-Name attribute. The Frag-Status attribute is not included in the next Access-Request, as no more chunks are available for sending. The RADIUS Client includes the State attribute from the previous Access-Accept. It signs the packet with Message-Authenticator, as there are no authentication attributes in the packet. It again uses a new RADIUS Identifier field.",
      "ja": "RADIUSクライアントは、この応答を確認し、継続的なチャンクのセッションに関連付けることがRADIUS Identifierフィールドを使用します。 RADIUSクライアントは、元のパケットからの最終的な属性（複数可）と、次のチャンクを送信することによって、チャンキング処理を継続し、再び元のUser-Name属性を含みます。これ以上チャンクが送信のために用意されていないようFRAG-Status属性は、次のアクセス要求に含まれていません。 RADIUSクライアントは、以前の-受け入れAccessから状態属性が含まれています。パケットには認証属性が存在しないように、それは、メッセージ認証とパケットに署名します。これは、再び新しいRADIUS Identifierフィールドを使用しています。"
    },
    {
      "indent": 3,
      "text": "Access-Request (ID = 241) User-Name Example-Long-2 State = 0xdef00002 Message-Authenticator",
      "ja": "アクセス要求（ID = 241）は、ユーザ名の例ロング-2ステート= 0xdef00002メッセージ認証"
    },
    {
      "indent": 20,
      "text": "Figure 6: Access-Request (Chunk 3)",
      "ja": "図6：アクセス要求（チャンク3）"
    },
    {
      "indent": 3,
      "text": "On reception of this last chunk, the RADIUS Server matches it with an ongoing session via the State attribute and sees that there is no Frag-Status attribute present. It then processes the received attributes as if they had been sent in one RADIUS packet. See Section 8.4 for further details on this process. It generates the appropriate response, which can be either Access-Accept or Access-Reject. In this example, we show an Access-Accept. The RADIUS Server MUST send a State attribute, which allows linking the received data with the authentication process.",
      "ja": "この最後のチャンクを受信すると、RADIUSサーバは、State属性を経由して、進行中のセッションと照合し、何FRAG-Statusが存在属性ないがあることを見ています。彼らは1つのRADIUSパケットで送信されたかのように、それは、受信した属性を処理します。このプロセスの詳細については、セクション8.4を参照してください。これは、接続許可またはアクセス拒否のいずれかとすることができる適切な応答を生成します。この例では、我々は、受け入れのアクセスを示しています。 RADIUSサーバは、認証プロセスで受信したデータをリンクすることができますState属性を送らなければなりません。"
    },
    {
      "indent": 3,
      "text": "Access-Accept (ID = 241) State = 0x98700003 Message-Authenticator",
      "ja": "アクセス・受け入れ（ID = 241）の状態= 0x98700003メッセージ認証"
    },
    {
      "indent": 21,
      "text": "Figure 7: Access-Accept (Chunk 3)",
      "ja": "図7：アクセス承諾（チャンク3）"
    },
    {
      "indent": 3,
      "text": "The above example shows in practice how the chunking process works. We reiterate the implementation and security requirements here.",
      "ja": "上記の例では、チャンキングプロセスがどのように動作するかを実際に示しています。ここでは、実装し、セキュリティ要件を改めて表明する。"
    },
    {
      "indent": 3,
      "text": "Each chunk is a valid RADIUS packet (see Section 12.2 for some considerations about this), and all RADIUS format and security requirements MUST be followed before any chunking process is applied.",
      "ja": "各チャンクは、有効なRADIUSパケットである（これについていくつかの考慮事項については12.2節を参照）、および任意のチャンキングプロセスが適用される前に、すべてのRADIUSフォーマットおよびセキュリティ要件に従わなければなりません。"
    },
    {
      "indent": 3,
      "text": "Every chunk except for the last one from a RADIUS Client MUST include a Frag-Status attribute, with value More-Data-Pending. The last chunk MUST NOT contain a Frag-Status attribute. Each chunk except for the last one from a RADIUS Client MUST include a Service-Type attribute, with value Additional-Authorization. Each chunk MUST include a User-Name attribute, which MUST be identical in all chunks. Each chunk except for the first one from a RADIUS Client MUST include a State attribute, which MUST be copied from a previous Access-Accept.",
      "ja": "RADIUSクライアントからの最後のものを除くすべてのチャンクは値より-DATA-保留して、FRAG-Status属性を含まなければなりません。最後のチャンクは、FRAG-Status属性を含めることはできません。 RADIUSクライアントからの最後のものを除いて、各チャンクは値の追加承認で、service-type属性を含まなければなりません。各チャンクは、すべてのチャンクで同じでなければならないUser-Name属性を含まなければなりません。 RADIUSクライアントからの最初のものを除いて、各チャンクは以前-受け入れAccessからコピーされなければならない状態の属性を含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "Each Access-Accept MUST include a State attribute. The value for this attribute MUST change in every new Access-Accept and MUST be globally and temporally unique.",
      "ja": "各アクセス・受け入れは、州属性を含まなければなりません。この属性の値は、すべての新しいアクセス-受け入れ、グローバルかつ時間的にユニークでなければならないのでは変更する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.2. Post-Authorization",
      "section_title": true,
      "ja": "5.2。ポストの認可"
    },
    {
      "indent": 3,
      "text": "When the RADIUS Server wants to send a large amount of authorization data to the RADIUS Client after authentication, the operation is very similar to the pre-authorization process. The presence of a Service-Type = Additional-Authorization attribute ensures that a RADIUS Client not supporting this specification will treat that unrecognized Service-Type as though an Access-Reject had been received instead ([RFC2865], Section 5.6). If the original large Access-Accept packet contained a Service-Type attribute, it will be included with its original value in the last transmitted chunk, to avoid confusion with the one used for fragmentation signaling. It is RECOMMENDED that RADIUS Servers include a State attribute in their original Access-Accept packets, even if fragmentation is not taking place, to allow the RADIUS Client to send additional authorization data in subsequent exchanges. This State attribute would be included in the last transmitted chunk, to avoid confusion with the ones used for fragmentation signaling.",
      "ja": "RADIUSサーバが認証した後、RADIUSクライアントに認証データを大量に送信したい場合は、操作が事前承認プロセスに非常によく似ています。サービスタイプの存在のアクセスが拒否かのように=追加の承認属性はRADIUSクライアントがこの仕様をサポートしていないことを保証し、認識されないサービスタイプという扱いますが（[RFC2865]、セクション5.6）の代わりに受信されていました。オリジナルの大型のAccess-受け入れパケットはservice-type属性が含まれていた場合、断片化シグナリングのために使用されるものとの混同を避けるために、最後に送信チャンク内の元の値が含まれます。 RADIUSサーバが元のAccess-受け入れRADIUSクライアントは、その後のやりとりで、追加の認証データを送信できるようにするために、断片化が行われていない場合でも、パケットの中にState属性を含めることをお勧めします。この状態属性は、断片化シグナリングのために使用されるものとの混同を避けるために、最後に送信チャンクに含まれることになります。"
    },
    {
      "indent": 3,
      "text": "Clients supporting this specification MUST include a Frag-Status = Fragmentation-Supported attribute in the first Access-Request sent to the RADIUS Server, in order to indicate that they would accept fragmented data from the server. This is not required if the pre-authorization process was carried out, as it is implicit.",
      "ja": "この仕様をサポートするクライアントは、サーバーからの断片化されたデータを受け入れることを示すために、RADIUSサーバーに送信された最初のアクセス要求でFRAG-ステータス=フラグメンテーションがサポートする属性を含まなければなりません。それは暗黙的であるとして事前承認プロセスは、実施した場合、これは必須ではありません。"
    },
    {
      "indent": 3,
      "text": "The following is an Access-Accept that the RADIUS Server intends to send to a RADIUS Client. However, due to a combination of issues (PMTU, large attributes, etc.), the content does not fit into one Access-Accept packet.",
      "ja": "以下は、RADIUSサーバは、RADIUSクライアントに送信するつもりであることを、受け入れのアクセスです。しかし、問題（PMTU、大属性など）の組み合わせに、コンテンツが1回のアクセス-受け入れパケットに収まりません。"
    },
    {
      "indent": 3,
      "text": "Access-Accept User-Name EAP-Message Service-Type = Login Example-Long-1 [M] Example-Long-1 [M] Example-Long-1 [M] Example-Long-1 [M] Example-Long-1 [M] Example-Long-1 [M] Example-Long-1 [M] Example-Long-1 [M] Example-Long-1 Example-Long-2 [M] Example-Long-2 [M] Example-Long-2 State = 0xcba00003",
      "ja": "ユーザー名EAP-Message Serviceのタイプをアクセス-受け入れ=ログインの例-ロング-1 [M]例 - ロング-1 [M]例 - ロング-1 [M]例 - ロング-1 [M]例 - 長期性1 [M]例 - ロング1 [M]例 - ロング1 [M]例 - ロング1 [M]例 - ロング1例-長期2 [M]例 - ロング2 [M]例-long-2ステート= 0xcba00003"
    },
    {
      "indent": 22,
      "text": "Figure 8: Desired Access-Accept",
      "ja": "図8：所望のアクセス - 受け入れ"
    },
    {
      "indent": 3,
      "text": "The RADIUS Server therefore must send the attributes listed above in a series of chunks. The first chunk contains seven (7) attributes from the original Access-Accept, and a Frag-Status attribute. Since the last attribute is \"Example-Long-1\" with the M flag set, the chunking process also sets the T flag in that attribute. The Access-Accept is sent with a RADIUS Identifier field having value 30, corresponding to a previous Access-Request not depicted. The Frag-Status attribute has value More-Data-Pending, to indicate that the RADIUS Server wishes to send more data in a subsequent Access-Accept. The RADIUS Server also adds a Service-Type attribute with value Additional-Authorization, which indicates that it is part of the chunking process. Note that the original Service-Type is not included in this chunk. Finally, a State attribute is included to allow matching subsequent requests with this conversation, and the packet is signed with the Message-Authenticator attribute, completing the maximum number of attributes (11).",
      "ja": "RADIUSサーバは、したがって、一連のチャンクに、上記の属性を送信する必要があります。最初のチャンクは、7（7）元のAccess-受け入れ、FRAG-Status属性から属性が含まれています。最後の属性は、「例 - ロング1」Mフラグが設定されているので、チャンキングプロセスは、その属性にTフラグをセットします。接続許可は示されていない以前のアクセス要求に対応し、値30を有するRADIUS Identifierフィールドで送信されます。 FRAG-Status属性は、RADIUSサーバーは、後続の-受け入れAccessでより多くのデータを送信したいことを示すために、値より-DATA-保留されています。 RADIUSサーバはまた、チャンキングプロセスの一部であることを示す値の追加承認、とservice-type属性を追加します。オリジナルのサービスタイプは、このチャンクに含まれていないことに注意してください。最後に、状態属性がこの会話で後続の要求に合致することを可能にするために含まれ、パケットが属性（11）の最大数を完了し、メッセージ認証属性を使用して署名されます。"
    },
    {
      "indent": 3,
      "text": "Access-Accept (ID = 30) User-Name EAP-Message Example-Long-1 [M] Example-Long-1 [M] Example-Long-1 [M] Example-Long-1 [M] Example-Long-1 [MT] Frag-Status = More-Data-Pending Service-Type = Additional-Authorization State = 0xcba00004 Message-Authenticator",
      "ja": "アクセス承諾（ID = 30）ユーザ名EAP-メッセージの例ロング-1 [M]例 - ロング1 [M]例 - ロング1 [M]例 - ロング1 [M]例 - 長期性1 [MT] FRAG-ステータス=もっと-DATA-保留サービスタイプ=追加の承認状態= 0xcba00004メッセージ認証"
    },
    {
      "indent": 21,
      "text": "Figure 9: Access-Accept (Chunk 1)",
      "ja": "図9：アクセス承諾（チャンク1）"
    },
    {
      "indent": 3,
      "text": "Compliant RADIUS Clients receiving this packet will see the Frag-Status attribute and suspend all authorization handling until all of the chunks have been received. Non-compliant RADIUS Clients should also see the Service-Type indicating the provisioning for an unknown service and will treat it as an Access-Reject.",
      "ja": "このパケットを受信準拠のRADIUSクライアントは、FRAG-Status属性を参照し、チャンクの全てが受信されるまで、すべての認証処理を中断します。非準拠のRADIUSクライアントも、未知のサービスのプロビジョニングを示すサービスタイプが表示されるはずですし、アクセス拒否として扱います。"
    },
    {
      "indent": 3,
      "text": "RADIUS Clients who wish to receive all of the chunks will respond with the following packet, where the value of the State attribute is taken from the received Access-Accept. They will also include the User-Name attribute so that non-compliant proxies can process the packet (Section 11.1).",
      "ja": "チャンクの全てを受け取りたいRADIUSクライアントは、State属性の値を受信し、受け入れAccessから取られ、次のパケットと応答します。非対応のプロキシがパケット（11.1節）を処理できるように、彼らはまた、ユーザー名属性が含まれます。"
    },
    {
      "indent": 3,
      "text": "Access-Request (ID = 131) User-Name Frag-Status = More-Data-Request Service-Type = Additional-Authorization State = 0xcba00004 Message-Authenticator",
      "ja": "アクセス要求（ID = 131）ユーザー名FRAG-ステータス=もっと-データ - 要求サービスタイプ=追加の承認状態= 0xcba00004メッセージ認証"
    },
    {
      "indent": 20,
      "text": "Figure 10: Access-Request (Chunk 1)",
      "ja": "図10：アクセス要求（チャンク1）"
    },
    {
      "indent": 3,
      "text": "The RADIUS Server receives this request and uses the State attribute to associate it with an ongoing chunking session. Compliant RADIUS Servers will then continue the chunking process. Non-compliant RADIUS Servers will never see a response such as this, as they will never send a Frag-Status attribute.",
      "ja": "RADIUSサーバは、この要求を受信して​​、継続的なチャンクのセッションに関連付けることがState属性を使用しています。準拠のRADIUSサーバは、チャンキングプロセスを継続します。彼らはFRAG-Status属性を送信することはありませんように、非準拠のRADIUSサーバーは、このような応答を見ることはありません。"
    },
    {
      "indent": 3,
      "text": "The RADIUS Server continues the chunking process by sending the next chunk, with the final attribute(s) from the original packet. The value of the Identifier field is taken from the received Access-Request. A Frag-Status attribute is not included in the next Access-Accept, as no more chunks are available for sending. The",
      "ja": "RADIUSサーバは、元のパケットからの最終的な属性（複数可）と、次のチャンクを送信することにより、チャンキング処理を継続します。識別子フィールドの値は、受信されたアクセス要求から取り出されます。これ以上チャンクが送信のために用意されていないようFRAG-Status属性は、次のAccess-受け入れには含まれていません。ザ・"
    },
    {
      "indent": 3,
      "text": "RADIUS Server includes the original State attribute to allow the RADIUS Client to send additional authorization data. The original Service-Type attribute is included as well.",
      "ja": "RADIUSサーバは、RADIUSクライアントは、追加の認証データを送信できるようにする元の状態属性が含まれています。元service-type属性も同様に含まれています。"
    },
    {
      "indent": 3,
      "text": "Access-Accept (ID = 131) Example-Long-1 [M] Example-Long-1 [M] Example-Long-1 [M] Example-Long-1 Example-Long-2 [M] Example-Long-2 [M] Example-Long-2 Service-Type = Login State = 0xfda000003 Message-Authenticator",
      "ja": "アクセス承諾（ID = 131）実施例-長期1 [M]例 - ロング1 [M]例 - ロング1 [M]例 - ロング1例-長期2 [M]例 - ロング2 [M]例 - ロング2サービスタイプ=ログイン状態= 0xfda000003メッセージ認証"
    },
    {
      "indent": 20,
      "text": "Figure 11: Access-Accept (Chunk 2)",
      "ja": "図11：アクセス承諾（チャンク2）"
    },
    {
      "indent": 3,
      "text": "On reception of this last chunk, the RADIUS Client matches it with an ongoing session via the Identifier field and sees that there is no Frag-Status attribute present. It then processes the received attributes as if they had been sent in one RADIUS packet. See Section 8.4 for further details on this process.",
      "ja": "この最後のチャンクを受信すると、RADIUSクライアントは、識別子フィールドを経由して、進行中のセッションと照合し、何FRAG-Statusが存在属性んがあることを見ています。彼らは1つのRADIUSパケットで送信されたかのように、それは、受信した属性を処理します。このプロセスの詳細については、セクション8.4を参照してください。"
    },
    {
      "indent": 0,
      "text": "6. Chunk Size",
      "section_title": true,
      "ja": "6.チャンクサイズ"
    },
    {
      "indent": 3,
      "text": "In an ideal scenario, each intermediate chunk would be exactly the size limit in length. In this way, the number of round trips required to send a large packet would be optimal. However, this is not possible for several reasons.",
      "ja": "理想的なシナリオでは、各中間チャンクの長さは正確にサイズ制限であろう。このように、大きなパケットを送信するために必要なラウンドトリップ数が最適でしょう。しかし、これはいくつかの理由では不可能です。"
    },
    {
      "indent": 3,
      "text": "1. RADIUS attributes have a variable length and must be included completely in a chunk. Thus, it is possible that, even if there is some free space in the chunk, it is not enough to include the next attribute. This can generate up to 254 bytes of spare space in every chunk.",
      "ja": "1. RADIUS属性は、変数の長さを有し、チャンクに完全に含まれている必要があります。したがって、チャンク内の一部の空きスペースがあっても、次の属性を含むのに十分ではない、ということも可能です。これは、すべてのチャンクでの予備領域の254のバイトまで生成することができます。"
    },
    {
      "indent": 3,
      "text": "2. RADIUS fragmentation requires the introduction of some extra attributes for signaling. Specifically, a Frag-Status attribute (7 bytes) is included in every chunk of a packet, except the last one. A RADIUS State attribute (from 3 to 255 bytes) is also included in most chunks, to allow the RADIUS Server to bind an Access-Request with a previous Access-Challenge. User-Name attributes (from 3 to 255 bytes) are included in every chunk the RADIUS Client sends, as they are required by the proxies to route the packet to its destination. Together, these attributes can generate from up to 13 to 517 bytes of signaling data, reducing the amount of payload information that can be sent in each chunk.",
      "ja": "2. RADIUSの断片化は、シグナリングのためのいくつかの余分な属性の導入が必要となります。具体的には、FRAG-Status属性（7バイト）は、最後の1を除いて、パケットのすべてのチャンクに含まれています。 （3〜255バイトから）RADIUS State属性は、以前のアクセスチャレンジとアクセス要求をバインドするためにRADIUSサーバを許可するように、ほとんどのチャンクに含まれています。ユーザー名（3〜255バイト）の属性、彼らがその宛先にパケットをルーティングするためにプロキシによって必要とされるRADIUSクライアントは、送信すべてのチャンクに含まれています。一緒に、これらの属性は、各チャンクで送信することができるペイロード情報の量を減少させる、シグナリングデータの517バイトまでに13から発生させることができます。"
    },
    {
      "indent": 3,
      "text": "3. RADIUS packets SHOULD be adjusted to avoid exceeding the network MTU. Otherwise, IP fragmentation may occur, with undesirable consequences. Hence, maximum chunk size would be decreased from 4096 to the actual MTU of the network.",
      "ja": "3. RADIUSパケットは、ネットワークMTUを超えないように調整されるべきです。そうでない場合は、IPフラグメンテーションは望ましくない結果で、発生する可能性があります。したがって、最大チャンクサイズは4096から、ネットワークの実際のMTUに減少されるであろう。"
    },
    {
      "indent": 3,
      "text": "4. The inclusion of Proxy-State attributes by intermediary proxies can decrease the availability of usable space in the chunk. This is described in further detail in Section 8.1.",
      "ja": "4.プロキシステートが仲介プロキシによって属性を含めることは、チャンク内の使用可能なスペースの利用可能性を減少させることができます。これは、8.1節にさらに詳細に記載されています。"
    },
    {
      "indent": 0,
      "text": "7. Allowed Large Packet Size",
      "section_title": true,
      "ja": "7.許可大型パケットサイズ"
    },
    {
      "indent": 3,
      "text": "There are no provisions for signaling how much data is to be sent via the fragmentation process as a whole. It is difficult to define what is meant by the \"length\" of any fragmented data. That data can be multiple attributes and can include RADIUS attribute header fields, or it can be one or more \"large\" attributes (more than 256 bytes in length). Proxies can also filter these attributes, to modify, add, or delete them and their contents. These proxies act on a \"packet by packet\" basis and cannot know what kind of filtering actions they will take on future packets. As a result, it is impossible to signal any meaningful value for the total amount of additional data.",
      "ja": "全体として、断片化プロセスを介して送信されるデータの量のシグナルについての規定はありません。任意の断片化されたデータの「長さ」が何を意味するかを定義することは困難です。そのデータは、複数の属性とすることができ、RADIUS属性ヘッダフィールドを含むことができ、またはそれは1つ以上の「大」（長さ以上256バイト）の属性とすることができます。プロキシはまた、変更、追加、または彼らとその内容を削除するために、これらの属性をフィルタリングすることができます。これらのプロキシは、「パケットパケットによる」基づいて行動し、彼らは将来のパケットを取るだろう、フィルタリングアクションの種類を知ることができません。その結果、追加データの総額のための任意の意味のある値をシグナリングすることは不可能です。"
    },
    {
      "indent": 3,
      "text": "Unauthenticated end users are permitted to trigger the exchange of large amounts of fragmented data between the RADIUS Client and the RADIUS Server, having the potential to allow denial-of-service (DoS) attacks. An attacker could initiate a large number of connections, each of which requests the RADIUS Server to store a large amount of data. This data could cause memory exhaustion on the RADIUS Server and result in authentic users being denied access. It is worth noting that authentication mechanisms are already designed to avoid exceeding the size limit.",
      "ja": "認証されていないエンドユーザーは、サービス拒否（DoS）攻撃を許可する可能性を持つ、RADIUSクライアントとRADIUSサーバ間で断片化された大量のデータのやり取りをトリガすることが許可されています。攻撃者は、大量のデータを格納するためにRADIUSサーバを要求各々が多数の接続を開始することができます。このデータは、RADIUSサーバ上のメモリの枯渇を引き起こし、アクセスを拒否されている本格的なユーザーにつながる可能性があります。これは、認証メカニズムがすでにサイズ制限を超えないように設計されていることは注目に値します。"
    },
    {
      "indent": 3,
      "text": "Hence, implementations of this specification MUST limit the total amount of data they send and/or receive via this specification. Its default value SHOULD be 100 kilobytes. Any more than this may turn RADIUS into a generic transport protocol, which is undesirable. This limit SHOULD be configurable, so that it can be changed if necessary.",
      "ja": "したがって、この仕様の実装は、それらが送信データの総量を制限し、および/または本明細書を介して受信しなければなりません。デフォルト値は100キロバイトであるべきです。これ以上は望ましくない、一般的なトランスポートプロトコル、にRADIUSを回すことがあります。必要であれば、それは変更することができるように、この制限は、設定可能であるべきです。"
    },
    {
      "indent": 3,
      "text": "Implementations of this specification MUST limit the total number of round trips used during the fragmentation process. Its default value SHOULD be 25. Any more than this may indicate an implementation error, misconfiguration, or DoS attack. This limit SHOULD be configurable, so that it can be changed if necessary.",
      "ja": "この仕様の実装は、断片化プロセス中に使用されるラウンドトリップの数を制限しなければなりません。これは実装エラー、設定ミス、またはDoS攻撃を示すことよりも、そのデフォルト値はどれより25であるべきです。必要であれば、それは変更することができるように、この制限は、設定可能であるべきです。"
    },
    {
      "indent": 3,
      "text": "For instance, let's imagine that the RADIUS Server wants to transport a SAML assertion that is 15000 bytes long to the RADIUS Client. In this hypothetical scenario, we assume that there are three intermediate proxies, each one inserting a Proxy-State attribute of 20 bytes. Also, we assume that the State attributes generated by the RADIUS Server have a size of 6 bytes and the User-Name attribute takes 50 bytes. Therefore, the amount of free space in a chunk for the transport of the SAML assertion attributes is as follows: Total (4096 bytes) - RADIUS header (20 bytes) - User-Name (50 bytes) - Frag-Status (7 bytes) - Service-Type (6 bytes) - State (6 bytes) - Proxy-State (20 bytes) - Proxy-State (20 bytes) - Proxy-State (20 bytes) - Message-Authenticator (18 bytes), resulting in a total of 3929 bytes. This amount of free space allows the transmission of up to 15 attributes of 255 bytes each.",
      "ja": "たとえば、のは、RADIUSサーバは、RADIUSクライアントに15000バイト長であるSAMLアサーションを輸送するために望んでいることを想像してみましょう。この仮定のシナリオでは、我々は、3つの中間プロキシ、20バイトのプロキシ状態属性を挿入各々が存在すると仮定する。また、私たちは、RADIUSサーバによって生成された状態の属性が6バイトのサイズを有し、User-Name属性が50バイトを取ることを前提としています。次のようにそのため、SAMLアサーション属性の輸送のためのチャンク内の空き領域の量は：総（4096バイト） -  RADIUSヘッダー（20バイト） - ユーザ名（50バイト） -  FRAG-ステータス（7バイト） - サービスタイプ（6バイト） - 状態（6バイト） - プロキシ・ステート（20バイト） - プロキシ・ステート（20バイト） - プロキシ・ステート（20バイト） - メッセージオーセンティケータ（18バイト）、その結果3929バイトの合計。空きスペースのこの量は、255バイトごとの最大15個の属性の伝送を可能にします。"
    },
    {
      "indent": 3,
      "text": "According to [RFC6929], a Long-Extended-Type provides a payload of 251 bytes. Therefore, the SAML assertion described above would result in 60 attributes, requiring four round trips to be completely transmitted.",
      "ja": "[RFC6929]によれば、長期拡張型は、251バイトのペイロードを提供します。したがって、上述したSAMLアサーションを完全に送信される4件のラウンドトリップを必要とする、60の属性をもたらすであろう。"
    },
    {
      "indent": 0,
      "text": "8. Handling Special Attributes",
      "section_title": true,
      "ja": "特別な属性の取り扱い8."
    },
    {
      "indent": 0,
      "text": "8.1. Proxy-State Attribute",
      "section_title": true,
      "ja": "8.1。プロキシ状態属性"
    },
    {
      "indent": 3,
      "text": "RADIUS proxies may introduce Proxy-State attributes into any Access-Request packet they forward. If they are unable to add this information to the packet, they may silently discard it rather than forward it to its destination; this would lead to DoS situations. Moreover, any Proxy-State attribute received by a RADIUS Server in an Access-Request packet MUST be copied into the corresponding reply packet. For these reasons, Proxy-State attributes require special treatment within the packet fragmentation mechanism.",
      "ja": "RADIUSプロキシはプロキシ国家がどのアクセス要求パケット彼ら前方に属性を導入することができます。彼らはパケットにこの情報を追加することができない場合、彼らは黙ってそれを捨てるのではなく、その先にそれを転送することができます。これは、DoS攻撃の状況をもたらすことになります。また、アクセス要求パケット内のRADIUSサーバによって受信された任意のプロキシ状態属性は、対応する応答パケットにコピーされなければなりません。これらの理由から、プロキシ状態属性は、パケットの断片化のメカニズム内の特別な処理を必要としています。"
    },
    {
      "indent": 3,
      "text": "When the RADIUS Server replies to an Access-Request packet as part of a conversation involving a fragmentation (either a chunk or a request for chunks), it MUST include every Proxy-State attribute received in the reply packet. This means that the RADIUS Server MUST take into account the size of these Proxy-State attributes in order to calculate the size of the next chunk to be sent.",
      "ja": "RADIUSサーバがフラグメンテーション（チャンクまたはチャンクの要求のいずれか）を含む会話の一部として、アクセス要求パケットに応答すると、それが応答パケットで受信されたすべてのプロキシ状態属性を含まなければなりません。これは、RADIUSサーバは、これらのプロキシ・ステートのサイズを送信する次のチャンクの大きさを計算するために、属性を考慮しなければならないことを意味します。"
    },
    {
      "indent": 3,
      "text": "However, while a RADIUS Server will always know how much space MUST be left in each reply packet for Proxy-State attributes (as they are directly included by the RADIUS Server), a RADIUS Client cannot know this information, as Proxy-State attributes are removed from the reply packet by their respective proxies before forwarding them back. Hence, RADIUS Clients need a mechanism to discover the amount of space required by proxies to introduce their Proxy-State attributes. In the following paragraphs, we describe a new mechanism to perform such a discovery:",
      "ja": "しかし、RADIUSサーバは常に（それらが直接RADIUSサーバによって含まれているとして）プロキシステート属性、RADIUSクライアントは、この情報を知ることができないためにプロキシ状態属性がそうであるように、それぞれの応答パケットに残さなければならないどのくらいのスペースを知っているだろうしながら、それらをバック転送する前に、それぞれのプロキシによって応答パケットから取り除きます。したがって、RADIUSクライアントはそのプロキシ状態属性を導入するためにプロキシによって必要なスペースの量を発見するためのメカニズムを必要としています。次の段落では、我々は、このような検出を実行するための新しいメカニズムを説明します。"
    },
    {
      "indent": 3,
      "text": "1. When a RADIUS Client does not know how much space will be required by intermediate proxies for including their Proxy-State attributes, it SHOULD start using a conservative value (e.g., 1024 bytes) as the chunk size.",
      "ja": "RADIUSクライアントは、それらのプロキシ状態属性を含むための中間プロキシによって必要とされるどのくらいのスペースを知っていない場合1、それはチャンクサイズとして控えめな値（例えば、1024バイト）を使用して開始する必要があります。"
    },
    {
      "indent": 3,
      "text": "2. When the RADIUS Server receives a chunk from the RADIUS Client, it can calculate the total size of the Proxy-State attributes that have been introduced by intermediary proxies along the path. This information MUST be returned to the RADIUS Client in the next reply packet, encoded into a new attribute called Proxy-State-Length. The RADIUS Server MAY artificially increase this quantity in order to handle situations where proxies behave inconsistently (e.g., they generate Proxy-State attributes with a different size for each packet) or where intermediary proxies remove Proxy-State attributes generated by other proxies. Increasing this value would make the RADIUS Client leave some free space for these situations.",
      "ja": "RADIUSサーバは、RADIUSクライアントからチャンクを受信2.は、それがパスに沿って、仲介プロキシによって導入されているプロキシ状態属性の合計サイズを計算することができます。この情報は、プロキシ・ステート長と呼ばれる新しい属性にエンコードされ、次の応答パケットでRADIUSクライアントに返さなければなりません。 RADIUSサーバは、人工的にプロキシが一貫性のない挙動（例えば、これらはプロキシ・ステートは、各パケットのために異なるサイズの属性生成）または中間プロキシは、プロキシの状態が他のプロキシによって生成された属性を削除する状況を処理するためにこの量を増加させることができます。この値を大きくすると、RADIUSクライアントは、これらの状況のた​​めのいくつかの空き領域を残すになるだろう。"
    },
    {
      "indent": 3,
      "text": "3. The RADIUS Client SHOULD respond to the reception of this attribute by adjusting the maximum size for the next chunk accordingly. However, as the Proxy-State-Length offers just an estimation of the space required by the proxies, the RADIUS Client MAY select a smaller amount in environments known to be problematic.",
      "ja": "3. RADIUSクライアントは、それに応じて次のチャンクの最大サイズを調整することによって、この属性の受信に応答する必要があります。プロキシ・ステート長は、プロキシが必要なスペースだけで見積もりを提供していますしかし、RADIUSクライアントは問題があることが知られている環境では、より少ない量を選択することができます。"
    },
    {
      "indent": 0,
      "text": "8.2. State Attribute",
      "section_title": true,
      "ja": "8.2。状態属性"
    },
    {
      "indent": 3,
      "text": "This RADIUS fragmentation mechanism makes use of the State attribute to link all the chunks belonging to the same fragmented packet. However, some considerations are required when the RADIUS Server is fragmenting a packet that already contains a State attribute for other purposes not related to the fragmentation. If the procedure described in Section 5 is followed, two different State attributes could be included in a single chunk. This is something explicitly forbidden in [RFC2865].",
      "ja": "このRADIUSの断片化のメカニズムは同じフラグメントパケットに属するすべてのチャンクをリンクするためのState属性を使用しています。 RADIUSサーバがすでに断片化に関連していない他の目的のためにState属性が含まれているパケットを断片化されている場合しかし、いくつかの考慮が必要です。第5節で説明する手順に従っている場合は、二つの異なる状態属性は単一のチャンクに含めることができます。これは、明示的に[RFC2865]で禁じものです。"
    },
    {
      "indent": 3,
      "text": "A straightforward solution consists of making the RADIUS Server send the original State attribute in the last chunk of the sequence (attributes can be reordered as specified in [RFC2865]). As the last chunk (when generated by the RADIUS Server) does not contain any State attribute due to the fragmentation mechanism, both situations described above are avoided.",
      "ja": "簡単な解決策は、RADIUSサーバがシーケンスの最後のチャンクで元の状態属性を（[RFC2865]で指定された属性を並べ替えることができる）を送信することで構成されています。 （RADIUSサーバによって生成された）最後のチャンクが原因断片化機構にどのような状態属性が含まれていませんので、上記の両方の状況が回避されます。"
    },
    {
      "indent": 3,
      "text": "Something similar happens when the RADIUS Client has to send a fragmented packet that contains a State attribute in it. The RADIUS Client MUST ensure that this original State is included in the first chunk sent to the RADIUS Server (as this one never contains any State attribute due to fragmentation).",
      "ja": "RADIUSクライアントがそれにState属性が含まれている断片化されたパケットを送信する必要がある場合にも、同様の何かが起こります。 RADIUSクライアントは（この1つは決して断片化に起因するいかなるState属性が含まれていないとして）この元の状態は、RADIUSサーバに送信された最初のチャンクに含まれていることを確認しなければなりません。"
    },
    {
      "indent": 0,
      "text": "8.3. Service-Type Attribute",
      "section_title": true,
      "ja": "8.3。 service-type属性"
    },
    {
      "indent": 3,
      "text": "This RADIUS fragmentation mechanism makes use of the Service-Type attribute to indicate that an Access-Accept packet is not granting access to the service yet, since an additional authorization exchange needs to be performed. Similarly to the State attribute, the RADIUS Server has to send the original Service-Type attribute in the last Access-Accept of the RADIUS conversation to avoid ambiguity.",
      "ja": "このRADIUSの断片化のメカニズムは、追加の許可の交換が行われる必要があるので、アクセス-受け入れパケットは、まだサービスへのアクセスを許可されていないことを示すために、service-type属性を使用しています。同様に州属性に、RADIUSサーバは、あいまいさを避けるために、RADIUSの会話の最後に受け入れAccessで元service-type属性を送信する必要があります。"
    },
    {
      "indent": 0,
      "text": "8.4. Rebuilding the Original Large Packet",
      "section_title": true,
      "ja": "8.4。オリジナルラージパケットの再構築"
    },
    {
      "indent": 3,
      "text": "The RADIUS Client stores the RADIUS attributes received in each chunk in a list, in order to be able to rebuild the original large packet after receiving the last chunk. However, some of these received attributes MUST NOT be stored in that list, as they have been introduced as part of the fragmentation signaling and hence are not part of the original packet.",
      "ja": "RADIUSクライアントは、最後のチャンクを受信した後に、元の大きなパケットを再構築できるようにするために、リスト内の各チャンクに受信されたRADIUS属性を記憶します。彼らは断片化シグナリングの一部として導入され、したがって、元のパケットの一部ではないされているようしかし、これらの受信属性のいくつかは、そのリストに格納されてはなりません。"
    },
    {
      "indent": 3,
      "text": "o State (except the one in the last chunk, if present)",
      "ja": "O状態（もし存在するならば、最後のチャンク内のものを除きます）"
    },
    {
      "indent": 3,
      "text": "o Service-Type = Additional-Authorization",
      "ja": "Oサービスタイプ=追加承認"
    },
    {
      "indent": 3,
      "text": "o Frag-Status",
      "ja": "Oのステータスを依頼"
    },
    {
      "indent": 3,
      "text": "o Proxy-State-Length",
      "ja": "Oプロキシ・ステート長"
    },
    {
      "indent": 3,
      "text": "Similarly, the RADIUS Server MUST NOT store the following attributes as part of the original large packet:",
      "ja": "同様に、RADIUSサーバは、元の大きなパケットの一部として、次の属性を格納してはなりません："
    },
    {
      "indent": 3,
      "text": "o State (except the one in the first chunk, if present)",
      "ja": "O状態（存在する場合、最初のチャンク内の1つを除きます）"
    },
    {
      "indent": 3,
      "text": "o Service-Type = Additional-Authorization",
      "ja": "Oサービスタイプ=追加承認"
    },
    {
      "indent": 3,
      "text": "o Frag-Status",
      "ja": "Oのステータスを依頼"
    },
    {
      "indent": 3,
      "text": "o Proxy-State (except the ones in the last chunk)",
      "ja": "Oプロキシ状態（最後のチャンクでものを除きます）"
    },
    {
      "indent": 3,
      "text": "o User-Name (except the one in the first chunk)",
      "ja": "（最初のチャンク内の1つを除く）Oユーザ名"
    },
    {
      "indent": 0,
      "text": "9. New T Flag for the Long Extended Type Attribute Definition",
      "section_title": true,
      "ja": "ロング拡張type属性の定義9.新しいT旗"
    },
    {
      "indent": 3,
      "text": "This document defines a new field in the Long Extended Type attribute format. This field is one bit in size and is called \"T\" for Truncation. It indicates that the attribute is intentionally truncated in this chunk and is to be continued in the next chunk of the sequence. The combination of the M flag and the T flag indicates that the attribute is fragmented (M flag) but that all the fragments are not available in this chunk (T flag). Proxies implementing [RFC6929] will see these attributes as invalid (they will not be able to reconstruct them), but they will still forward them, as Section 5.2 of [RFC6929] indicates that they SHOULD forward unknown attributes anyway.",
      "ja": "この文書では、ロング拡張型属性の形式で新しいフィールドを定義します。このフィールドは、1ビットのサイズであると切り捨てのための「T」と呼ばれています。これは、属性が意図的にこの塊に切り捨てられていることを示し、シーケンスの次のチャンクで継続します。 MフラグとTフラグの組み合わせは、（Mフラグ）属性が断片化されていることを示しているが、すべてのフラグメントは、このチャンク（Tフラグ）が利用できないこと。 [RFC6929]を実装するプロキシは、（彼らはそれらを再構築することはできません）無効として、これらの属性が表示されますが、[RFC6929]の5.2節は、彼らはとにかく、未知の属性を転送する必要があることを示して彼らはまだ、それらを転送します。"
    },
    {
      "indent": 3,
      "text": "As a consequence of this addition, the Reserved field is now 6 bits long (see Section 12.1 for some considerations). The following figure represents the new attribute format:",
      "ja": "この加算の結果として、予約フィールドは、（いくつかの考慮事項については、セクション12.1を参照してください）今6ビットの長さです。次の図は、新しい属性の形式を表しています。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     Type      |    Length     | Extended-Type |M|T| Reserved  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     Value ...\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 10,
      "text": "Figure 12: Updated Long Extended Type Attribute Format",
      "ja": "図12：更新ロング拡張タイプ属性のフォーマット"
    },
    {
      "indent": 0,
      "text": "10. New Attribute Definition",
      "section_title": true,
      "ja": "10.新しい属性定義"
    },
    {
      "indent": 3,
      "text": "This document proposes the definition of two new extended type attributes, called Frag-Status and Proxy-State-Length. The format of these attributes follows the indications for an Extended Type attribute defined in [RFC6929].",
      "ja": "この文書では、FRAG-ステータスおよびプロキシ・ステート長と呼ばれる2つの新しい拡張型属性の定義を、提案しています。これらの属性のフォーマットは、[RFC6929]で定義された拡張型属性の指示に従います。"
    },
    {
      "indent": 0,
      "text": "10.1. Frag-Status Attribute",
      "section_title": true,
      "ja": "10.1。 FRAG-status属性"
    },
    {
      "indent": 3,
      "text": "This attribute is used for fragmentation signaling, and its meaning depends on the code value transported within it. The following figure represents the format of the Frag-Status attribute:",
      "ja": "この属性は、断片化シグナリングに使用され、その意味は、その中に運ばコード値に依存します。次の図は、FRAG-Status属性の形式を表しています。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Type        |    Length     | Extended-Type |     Code\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                  Code (cont)                   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 23,
      "text": "Figure 13: Frag-Status Format",
      "ja": "図13：FRAG-ステータスフォーマット"
    },
    {
      "indent": 3,
      "text": "Type",
      "ja": "タイプ"
    },
    {
      "indent": 6,
      "text": "241",
      "ja": "２４１"
    },
    {
      "indent": 3,
      "text": "Length",
      "ja": "長さ"
    },
    {
      "indent": 6,
      "text": "7",
      "ja": "７"
    },
    {
      "indent": 3,
      "text": "Extended-Type",
      "ja": "拡張型"
    },
    {
      "indent": 6,
      "text": "1",
      "ja": "１"
    },
    {
      "indent": 3,
      "text": "Code",
      "ja": "コード"
    },
    {
      "indent": 6,
      "text": "4 bytes. Integer indicating the code. The values defined in this specification are:",
      "ja": "4バイト。コードを示す整数。この仕様で定義された値は次のとおりです。"
    },
    {
      "indent": 9,
      "text": "0 - Reserved",
      "ja": "0  - 予約"
    },
    {
      "indent": 9,
      "text": "1 - Fragmentation-Supported",
      "ja": "1  - 断片化、サポートされています"
    },
    {
      "indent": 9,
      "text": "2 - More-Data-Pending",
      "ja": "2  - より-DATA-保留"
    },
    {
      "indent": 9,
      "text": "3 - More-Data-Request",
      "ja": "3  - 詳細 - データ - 要求"
    },
    {
      "indent": 3,
      "text": "This attribute MAY be present in Access-Request, Access-Challenge, and Access-Accept packets. It MUST NOT be included in Access-Reject packets. RADIUS Clients supporting this specification MUST include a Frag-Status = Fragmentation-Supported attribute in the first Access-Request sent to the RADIUS Server, in order to indicate that they would accept fragmented data from the server.",
      "ja": "この属性は、アクセス要求、アクセスチャレンジに存在すること、およびAccess-AcceptパケットMAY。これは、アクセス拒否パケットに含まれてはいけません。この仕様をサポートするRADIUSクライアントは、サーバーからの断片化されたデータを受け入れることを示すために、RADIUSサーバーに送信された最初のアクセス要求でFRAG-ステータス=フラグメンテーションがサポートする属性を含まなければなりません。"
    },
    {
      "indent": 0,
      "text": "10.2. Proxy-State-Length Attribute",
      "section_title": true,
      "ja": "10.2。プロキシ・ステート・長さ属性"
    },
    {
      "indent": 3,
      "text": "This attribute indicates to the RADIUS Client the length of the Proxy-State attributes received by the RADIUS Server. This information is useful for adjusting the length of the chunks sent by the RADIUS Client. The format of this Proxy-State-Length attribute is as follows:",
      "ja": "この属性は、プロキシ国家の長さは、RADIUSサーバが受信した属性をRADIUSクライアントに示します。この情報は、RADIUSクライアントによって送信されたチャンクの長さを調整するのに有用です。次のようにこのプロキシ・ステート長属性の形式は次のとおりです。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Type        |    Length     | Extended-Type |     Value\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n            Value (cont)                        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 19,
      "text": "Figure 14: Proxy-State-Length Format",
      "ja": "図14：プロキシ・ステート長フォーマット"
    },
    {
      "indent": 3,
      "text": "Type",
      "ja": "タイプ"
    },
    {
      "indent": 6,
      "text": "241",
      "ja": "２４１"
    },
    {
      "indent": 3,
      "text": "Length",
      "ja": "長さ"
    },
    {
      "indent": 6,
      "text": "7",
      "ja": "７"
    },
    {
      "indent": 3,
      "text": "Extended-Type",
      "ja": "拡張型"
    },
    {
      "indent": 6,
      "text": "2",
      "ja": "２"
    },
    {
      "indent": 3,
      "text": "Value",
      "ja": "値"
    },
    {
      "indent": 6,
      "text": "4 bytes. Total length (in bytes) of received Proxy-State attributes (including headers). As the RADIUS Length field cannot take values over 4096 bytes, values of Proxy-State-Length MUST be less than that maximum length.",
      "ja": "4バイト。 （ヘッダを含む）を受信プロキシ状態属性の合計長さ（バイト単位）。 RADIUS Lengthフィールドは4096バイトを超える値を取ることができないように、プロキシ・ステート長の値は、その最大長さ未満でなければなりません。"
    },
    {
      "indent": 3,
      "text": "This attribute MAY be present in Access-Challenge and Access-Accept packets. It MUST NOT be included in Access-Request or Access-Reject packets.",
      "ja": "この属性は、アクセスチャレンジとアクセス - 受け入れパケット中に存在することができます。これは、アクセス要求またはアクセス拒否のパケットに含まれてはいけません。"
    },
    {
      "indent": 0,
      "text": "10.3. Table of Attributes",
      "section_title": true,
      "ja": "10.3。属性の表"
    },
    {
      "indent": 3,
      "text": "The following table shows the different attributes defined in this document, along with the types of RADIUS packets in which they can be present.",
      "ja": "以下の表は、それらが存在することができるRADIUSパケットのタイプと一緒に、この文書で定義された異なる属性を示しています。"
    },
    {
      "indent": 6,
      "text": "                      |     Type of Packet    |\n                      +-----+-----+-----+-----+\nAttribute Name        | Req | Acc | Rej | Cha |\n----------------------+-----+-----+-----+-----+\nFrag-Status           | 0-1 | 0-1 |  0  | 0-1 |\n----------------------+-----+-----+-----+-----+\nProxy-State-Length    | 0   | 0-1 |  0  | 0-1 |\n----------------------+-----+-----+-----+-----+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "11. Operation with Proxies",
      "section_title": true,
      "ja": "プロキシと11.の操作"
    },
    {
      "indent": 3,
      "text": "The fragmentation mechanism defined above is designed to be transparent to legacy proxies, as long as they do not want to modify any fragmented attribute. Nevertheless, updated proxies supporting this specification can even modify fragmented attributes.",
      "ja": "上記で定義された断片化メカニズムは、それらが任意の断片化属性を変更したくない限り、従来のプロキシに透明になるように設計されています。それにもかかわらず、この仕様をサポートする更新されたプロキシは、さらに断片化された属性を変更することができます。"
    },
    {
      "indent": 0,
      "text": "11.1. Legacy Proxies",
      "section_title": true,
      "ja": "11.1。従来のプロキシ"
    },
    {
      "indent": 3,
      "text": "As every chunk is indeed a RADIUS packet, legacy proxies treat them as they would the rest of the packets, routing them to their destination. Proxies can introduce Proxy-State attributes into Access-Request packets, even if they are indeed chunks. This will not affect how fragmentation is managed. The RADIUS Server will include all the received Proxy-State attributes in the generated response, as described in [RFC2865]. Hence, proxies do not distinguish between a regular RADIUS packet and a chunk.",
      "ja": "すべてのチャンクが実際にRADIUSパケットであるとして、彼らは、パケットの残りの部分と同じように、従来のプロキシは、その先にそれらをルーティング、それらを扱います。プロキシはプロキシのステートは、彼らが実際に塊であっても、アクセス要求パケットに属性を導入することができます。これは、断片化が管理されている方法に影響しません。 RADIUSサーバは、[RFC2865]に記載されているように、すべての受信されたProxy-Stateは、生成された応答の属性が含まれます。したがって、プロキシは、通常のRADIUSパケットとチャンクを区別しません。"
    },
    {
      "indent": 0,
      "text": "11.2. Updated Proxies",
      "section_title": true,
      "ja": "11.2。更新されたプロキシ"
    },
    {
      "indent": 3,
      "text": "Updated proxies can interact with RADIUS Clients and Servers in order to obtain the complete large packet before starting to forward it. In this way, proxies can manipulate (modify and/or remove) any attribute of the packet or introduce new attributes, without worrying about crossing the boundaries of the chunk size. Once the manipulated packet is ready, it is sent to the original destination using the fragmentation mechanism (if required). The example in Figure 15 shows how an updated proxy interacts with the RADIUS Client to (1) obtain a large Access-Request packet and (2) modify an attribute, resulting in an even larger packet. The proxy then interacts with the RADIUS Server to complete the transmission of the modified packet, as shown in Figure 16.",
      "ja": "更新されたプロキシは、それを転送するために開始する前に、完全な大規模なパケットを得るために、RADIUSクライアントとサーバーと対話することができます。このように、プロキシはチャンクサイズの境界を横断する心配をせずに、（修正および/または削除）パケットの任意の属性を操作したり、新しい属性を導入することができます。操作パケットの準備ができたら、それは断片化機構（必要な場合）を使用して、元の宛先に送信されます。図15の例では、更新されたプロキシがさらに大きなパケットで、その結果、（1）大アクセス要求パケットを取得し、（2）属性を変更するRADIUSクライアントと対話する方法を示しています。プロキシは、次いで、図16に示すように、変更されたパケットの送信を完了するためにRADIUSサーバと相互作用します。"
    },
    {
      "indent": 5,
      "text": "+-+-+-+-+-+                                          +-+-+-+-+-+\n| RADIUS  |                                          | RADIUS  |\n| Client  |                                          | Proxy   |\n+-+-+-+-+-+                                          +-+-+-+-+-+\n    |                                                    |\n    | Access-Request(1){User-Name,Calling-Station-Id,    |\n    |        Example-Long-1[M],Example-Long-1[M],        |\n    |        Example-Long-1[M],Example-Long-1[M],        |\n    |        Example-Long-1[MT],Frag-Status(MDP)}        |\n    |--------------------------------------------------->|\n    |                                                    |\n    |                     Access-Challenge(1){User-Name, |\n    |                           Frag-Status(MDR),State1} |\n    |<---------------------------------------------------|\n    |                                                    |\n    | Access-Request(2){User-Name,State1,                |\n    |        Example-Long-1[M],Example-Long-1[M],        |\n    |        Example-Long-1[M],Example-Long-1}           |\n    |--------------------------------------------------->|",
      "raw": true
    },
    {
      "indent": 14,
      "text": "Proxy Modifies Attribute Data, Increasing Its\n   Size from 9 Fragments to 11 Fragments",
      "raw": true
    },
    {
      "indent": 11,
      "text": "Figure 15: Updated Proxy Interacts with RADIUS Client",
      "ja": "図15：RADIUSクライアントとプロキシ間の相互対話を更新"
    },
    {
      "indent": 5,
      "text": "+-+-+-+-+-+                                          +-+-+-+-+-+\n| RADIUS  |                                          | RADIUS  |\n| Proxy   |                                          | Server  |\n+-+-+-+-+-+                                          +-+-+-+-+-+\n    |                                                    |\n    | Access-Request(3){User-Name,Calling-Station-Id,    |\n    |        Example-Long-1[M],Example-Long-1[M],        |\n    |        Example-Long-1[M],Example-Long-1[M],        |\n    |        Example-Long-1[MT],Frag-Status(MDP)}        |\n    |--------------------------------------------------->|\n    |                                                    |\n    |                     Access-Challenge(1){User-Name, |\n    |                           Frag-Status(MDR),State2} |\n    |<---------------------------------------------------|\n    |                                                    |\n    | Access-Request(4){User-Name,State2,                |\n    |        Example-Long-1[M],Example-Long-1[M],        |\n    |        Example-Long-1[M],Example-Long-1[M],        |\n    |        Example-Long-1[MT],Frag-Status(MDP)}        |\n    |--------------------------------------------------->|\n    |                                                    |\n    |                     Access-Challenge(1){User-Name, |\n    |                           Frag-Status(MDR),State3} |\n    |<---------------------------------------------------|\n    |                                                    |\n    | Access-Request(5){User-Name,State3,Example-Long-1} |\n    |--------------------------------------------------->|",
      "raw": true
    },
    {
      "indent": 11,
      "text": "Figure 16: Updated Proxy Interacts with RADIUS Server",
      "ja": "図16：RADIUSサーバで更新プロキシの相互対話"
    },
    {
      "indent": 0,
      "text": "12. General Considerations",
      "section_title": true,
      "ja": "12.一般的な考慮事項"
    },
    {
      "indent": 0,
      "text": "12.1. T Flag",
      "section_title": true,
      "ja": "12.1。 T旗"
    },
    {
      "indent": 3,
      "text": "As described in Section 9, this document modifies the definition of the Reserved field of the Long Extended Type attribute [RFC6929] by allocating an additional flag called the T flag. The meaning and position of this flag are defined in this document, and nowhere else. This might cause an issue if subsequent specifications want to allocate a new flag as well, as there would be no direct way for them to know which parts of the Reserved field have already been defined.",
      "ja": "セクション9に記載されているように、この文書は、Tフラグと呼ばれる追加のフラグを割り当てることによってロング拡張型属性[RFC6929]のReservedフィールドの定義を修正します。このフラグの意味と位置がどこにも、この文書で定義された、とされています。その後の仕様は、彼らが予約フィールドの一部がすでに定義されているかを知るための直接的な方法はないであろうと、同様に新しいフラグを割り当てたい場合、これは問題を引き起こす可能性があります。"
    },
    {
      "indent": 3,
      "text": "An immediate and reasonable solution for this issue would be declaring that this RFC updates [RFC6929]. In this way, [RFC6929] would include an \"Updated by\" clause that will point readers to this document. Another alternative would be creating an IANA registry for the Reserved field. However, the RADIUS Extensions (RADEXT) working group thinks that would be overkill, as a large number of specifications extending that field are not expected.",
      "ja": "この問題の迅速かつ合理的な解決策は、このRFCの更新[RFC6929]それを宣言することになります。このように、[RFC6929]は、この文書に読者を指します「によって更新」条項が含まれるであろう。別の方法としては、予約フィールドのためのIANAレジストリを作成することになります。そのフィールドを拡張仕様の多数が期待されていないただし、RADIUS拡張機能（RADEXT）ワーキンググループは、それはやり過ぎだろうと考えています。"
    },
    {
      "indent": 3,
      "text": "In the end, the proposed solution is that this experimental RFC should not update RFC 6929. Instead, we rely on the collective mind of the working group to remember that this T flag is being used as specified by this Experimental document. If the experiment is successful, the T flag will be properly assigned.",
      "ja": "最後に、提案された解決策は、この実験的RFCは代わりに、我々はこの実験の文書で指定されたこのTフラグが使用されていることを覚えておくことはワーキンググループの集合的な心に依存しているRFC 6929.を更新してはならないということです。実験が成功した場合、Tフラグが適切に割り当てられます。"
    },
    {
      "indent": 1,
      "text": "12.2. Violation of",
      "section_title": true,
      "ja": "12.2。違反"
    },
    {
      "indent": 3,
      "text": "Section 5.1 indicates that all authorization and authentication handling will be postponed until all the chunks have been received. This postponement also applies to the verification that the Access-Request packet contains some kind of authentication attribute (e.g., User-Password, CHAP-Password, State, or other future attribute), as required by [RFC2865]. This checking will therefore be delayed until the original large packet has been rebuilt, as some of the chunks may not contain any of them.",
      "ja": "5.1節では、すべてのチャンクが受信されるまで、すべての認可および認証処理が延期されることを示します。この延期はまた、[RFC2865]で必要に応じて、アクセス要求パケットが認証属性（例えば、ユーザー・パスワード、CHAP-パスワード、州、または他の将来の属性）のいくつかの種類が含まれていることを検証に適用されます。オリジナルの大きなパケットが再構築されるまでチャンクのいくつかはそれらのいずれかを含めることはできませんので、このチェックはそのため、延期されます。"
    },
    {
      "indent": 3,
      "text": "The authors acknowledge that this specification violates the \"MUST\" requirement of [RFC2865], Section 4.1 that states that \"An Access-Request MUST contain either a User-Password or a CHAP-Password or a State.\" We note that a proxy that enforces that requirement would be unable to support future RADIUS authentication extensions. Extensions to the protocol would therefore be impossible to deploy. All known implementations have chosen the philosophy of \"be liberal in what you accept.\" That is, they accept traffic that violates the requirement of [RFC2865], Section 4.1. We therefore expect to see no operational issues with this specification. After we gain more operational experience with this specification, it can be reissued as a Standards Track document and can update [RFC2865].",
      "ja": "著者はこの仕様は[RFC2865]の「MUST」の要件に違反することを認め、4.1節では、「アクセス要求は、ユーザーのパスワードやCHAP  - パスワードまたは状態のいずれかを含まなければならない。」と述べています私たちは、要件が今後のRADIUS認証の拡張機能をサポートすることができないであろうことを強制するプロキシことに注意してください。プロトコルへの拡張は、そのために展開することは不可能だろう。すべての既知の実装は哲学選んだ「あなたが受け入れるものにリベラルなことを。」すなわち、それらは[RFC2865]、セクション4.1の要件に違反するトラフィックを受け入れ、です。したがって、我々は、この仕様で何の操作上の問題を見ていないことを期待しています。私たちはこの仕様でより多くの運用経験を積むした後、それが標準化過程文書として再発行することができ、[RFC2865]を更新することができます。"
    },
    {
      "indent": 0,
      "text": "12.3. Proxying Based on User-Name",
      "section_title": true,
      "ja": "12.3。ユーザ名に基づいてプロキシ"
    },
    {
      "indent": 3,
      "text": "This proposal assumes that legacy proxies base their routing decisions on the value of the User-Name attribute. For this reason, every packet sent from the RADIUS Client to the RADIUS Server (either chunks or requests for more chunks) MUST contain a User-Name attribute.",
      "ja": "この提案は、従来のプロキシは、User-Name属性の値に自分のルーティング決定を基づかことを前提としています。このため、（チャンク以上のチャンクの要求のいずれか）RADIUSサーバにRADIUSクライアントから送信されたすべてのパケットは、User-Name属性を含まなければなりません。"
    },
    {
      "indent": 0,
      "text": "12.4. Transport Behavior",
      "section_title": true,
      "ja": "12.4。交通行動"
    },
    {
      "indent": 3,
      "text": "This proposal does not modify the way RADIUS interacts with the underlying transport (UDP). That is, RADIUS keeps following a lock-step behavior that requires receiving an explicit acknowledgement for each chunk sent. Hence, bursts of traffic that could congest links between peers are not an issue.",
      "ja": "この提案は、RADIUSは、基礎となるトランスポート（UDP）と対話する方法を変更しません。つまり、RADIUSが送信され、各チャンクの明示的な承認を受ける必要がロックステップ動作を以下に保ちます。したがって、ピア間のリンクを輻輳ができ、トラフィックのバーストは問題ではありません。"
    },
    {
      "indent": 3,
      "text": "Another benefit of the lock-step nature of RADIUS is that there are no security issues with overlapping fragments. Each chunk simply has a length, with no Fragment Offset field as with IPv4. The order of the fragments is determined by the order in which they are received. There is no ambiguity about the size or placement of each chunk, and therefore no security issues associated with overlapping chunks.",
      "ja": "RADIUSのロックステップの自然のもう1つの利点は、重複断片ではセキュリティ上の問題がないことです。各チャンクは単にIPv4の場合と同様に無フラグメントオフセットフィールドと、長さを有しています。断片の順序は、それらが受信された順序によって決定されます。サイズまたは各チャンクの配置、したがって、重複チャンクに関連付けられていないセキュリティ上の問題についての曖昧さはありません。"
    },
    {
      "indent": 0,
      "text": "13. Security Considerations",
      "section_title": true,
      "ja": "13.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "As noted in many earlier specifications ([RFC5080], [RFC6158], etc.), RADIUS security is problematic. This specification changes nothing related to the security of the RADIUS protocol. It requires that all Access-Request packets associated with fragmentation are authenticated using the existing Message-Authenticator attribute. This signature prevents forging and replay, to the limits of the existing security.",
      "ja": "多くの以前の仕様（[RFC5080]、[RFC6158]など）で述べたように、RADIUSセキュリティが問題です。この仕様は、RADIUSプロトコルのセキュリティに関連する何も変わりません。これは、断片化に関連付けられているすべてのAccess-Requestパケットが既存のMessage-Authenticatorアトリビュートを使用して認証されていることが必要です。このシグネチャは、既存のセキュリティの限界まで、鍛造やリプレイを防ぐことができます。"
    },
    {
      "indent": 3,
      "text": "The ability to send bulk data from one party to another creates new security considerations. RADIUS Clients and Servers may have to store large amounts of data per session. The amount of this data can be significant, leading to the potential for resource exhaustion. We therefore suggest that implementations limit the amount of bulk data stored per session. The exact method for this limitation is implementation-specific. Section 7 gives some indications of what could be reasonable limits.",
      "ja": "別の関係者から大量のデータを送信する機能は、新しいセキュリティの考慮事項を作成します。 RADIUSクライアントとサーバーはセッションごとに大量のデータを保存する必要があります。このデータの量は、資源の枯渇のための潜在的につながる、重要になります。したがって、我々は、実装がセッションごとに保存されたバルク・データの量を制限することを示唆しています。この制限のための正確な方法は実装固有です。第7節は、合理的な範囲何ができるかのいくつかの兆候を示します。"
    },
    {
      "indent": 3,
      "text": "The bulk data can often be pushed off to storage methods other than the memory of the RADIUS implementation. For example, it can be stored in an external database or in files. This approach mitigates the resource exhaustion issue, as RADIUS Servers today already store large amounts of accounting data.",
      "ja": "バルク・データは、多くの場合、RADIUS実装のメモリ以外の記憶方法に押し出されることができます。例えば、それは外部のデータベースまたはファイルに保存することができます。 RADIUSサーバは、今日はすでに会計データを大量に保存するように、このアプローチは、資源枯渇の問題を軽減します。"
    },
    {
      "indent": 0,
      "text": "14. IANA Considerations",
      "section_title": true,
      "ja": "14. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "The Internet Assigned Numbers Authority (IANA) has registered the Attribute Types and Attribute Values defined in this document in the RADIUS namespaces as described in the \"IANA Considerations\" section of [RFC3575], in accordance with BCP 26 [RFC5226]. For RADIUS packets, attributes, and registries created by this document, IANA has updated <http://www.iana.org/assignments/radius-types> accordingly.",
      "ja": "[RFC3575]の「IANAの考慮事項」の項で説明したように、インターネット割り当て番号機関（IANA）は、RADIUS名前空間内でこの文書で定義された属性タイプと属性値を登録した、BCP 26 [RFC5226]に従っています。このドキュメントで作成されたRADIUSパケット、属性、およびレジストリのために、IANAは<http://www.iana.org/assignments/radius-types>に応じて更新しました。"
    },
    {
      "indent": 3,
      "text": "In particular, this document defines two new RADIUS attributes, entitled \"Frag-Status\" (value 241.1) and \"Proxy-State-Length\" (value 241.2), which have been allocated from the short extended space as described in [RFC6929]:",
      "ja": "特に、このドキュメントは[RFC6929]に記載されているように、短い拡張空間から割り当てられている「FRAG-ステータス」（値241.1）および「プロキシ・ステート長」（値241.2）、と題する、二つの新しいRADIUS属性を定義します。"
    },
    {
      "indent": 3,
      "text": "Type     Name                 Length  Meaning\n----     ----                 ------  -------\n241.1    Frag-Status          7       Signals fragmentation\n241.2    Proxy-State-Length   7       Indicates the length of the\n                                      received Proxy-State attributes",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The Frag-Status attribute also defines an 8-bit \"Code\" field, for which IANA has created and now maintains a new sub-registry entitled \"Code Values for RADIUS Attribute 241.1, Frag-Status\". Initial values for the RADIUS Frag-Status \"Code\" registry are given below; future assignments are to be made through \"RFC Required\" [RFC5226]. Assignments consist of a Frag-Status \"Code\" name and its associated value.",
      "ja": "FRAG-Status属性もIANAが作成され、現在は「RADIUSのためのコード値は241.1、FRAG-ステータス属性」という新しいサブレジストリを維持しているため、8ビットの「コード」フィールドを定義します。 RADIUS FRAG-ステータス「コード」レジストリの初期値は以下の通りです。将来の割り当ては、「RFC必要」[RFC5226]を介して行われるべきです。割り当ては、FRAG-ステータス「コード」の名前とその値で構成されています。"
    },
    {
      "indent": 9,
      "text": "Value    Frag-Status Code Name           Definition\n----     ------------------------        ----------\n0        Reserved                        See Section 10.1\n1        Fragmentation-Supported         See Section 10.1\n2        More-Data-Pending               See Section 10.1\n3        More-Data-Request               See Section 10.1\n4-255    Unassigned",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Additionally, IANA has allocated a new Service-Type value for \"Additional-Authorization\".",
      "ja": "また、IANAは、「追加の承認」のための新しいサービスタイプ値を割り当てています。"
    },
    {
      "indent": 9,
      "text": "Value    Service Type Value              Definition\n----     ------------------------        ----------\n19       Additional-Authorization        See Section 5.1",
      "raw": true
    },
    {
      "indent": 0,
      "text": "15. References",
      "section_title": true,
      "ja": "15.参考文献"
    },
    {
      "indent": 0,
      "text": "15.1. Normative References",
      "section_title": true,
      "ja": "15.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月、<http://www.rfc-editor.org/info/rfc2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC2865] Rigney, C., Willens, S., Rubens, A., and W. Simpson, \"Remote Authentication Dial In User Service (RADIUS)\", RFC 2865, June 2000, <http://www.rfc-editor.org/ info/rfc2865>.",
      "ja": "[RFC2865] Rigney、C.、ウィレンス、S.、ルーベン、A.、およびW.シンプソン、RFC 2865、2000年6月 \"ユーザーサービス（RADIUS）でリモート認証ダイヤル\"、<のhttp：//www.rfc- editor.org/情報/ RFC2865>。"
    },
    {
      "indent": 3,
      "text": "[RFC3575] Aboba, B., \"IANA Considerations for RADIUS (Remote Authentication Dial In User Service)\", RFC 3575, July 2003, <http://www.rfc-editor.org/info/rfc3575>.",
      "ja": "[RFC3575] Aboba、B.、 \"RADIUSのためのIANAの考慮事項（ユーザサービスにおけるリモート認証ダイヤル）\"、RFC 3575、2003年7月、<http://www.rfc-editor.org/info/rfc3575>。"
    },
    {
      "indent": 3,
      "text": "[RFC5226] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 5226, May 2008, <http://www.rfc-editor.org/info/rfc5226>.",
      "ja": "[RFC5226] Narten氏、T.とH. Alvestrand、 \"RFCsにIANA問題部に書くためのガイドライン\"、BCP 26、RFC 5226、2008年5月、<http://www.rfc-editor.org/info/rfc5226> 。"
    },
    {
      "indent": 3,
      "text": "[RFC6158] DeKok, A., Ed., and G. Weber, \"RADIUS Design Guidelines\", BCP 158, RFC 6158, March 2011, <http://www.rfc-editor.org/info/rfc6158>.",
      "ja": "[RFC6158] DeKok、A.編、およびG.ウェーバー、 \"RADIUS設計ガイドライン\"、BCP 158、RFC 6158、2011年3月、<http://www.rfc-editor.org/info/rfc6158>。"
    },
    {
      "indent": 3,
      "text": "[RFC6929] DeKok, A. and A. Lior, \"Remote Authentication Dial In User Service (RADIUS) Protocol Extensions\", RFC 6929, April 2013, <http://www.rfc-editor.org/info/rfc6929>.",
      "ja": "[RFC6929] DeKok、A.とA. LIOR、RFC 6929、2013年4月、<http://www.rfc-editor.org/info/rfc6929> \"ユーザーサービス（RADIUS）プロトコル拡張でリモート認証ダイヤル\"。"
    },
    {
      "indent": 0,
      "text": "15.2. Informative References",
      "section_title": true,
      "ja": "15.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[ABFAB-Arch] Howlett, J., Hartman, S., Tschofenig, H., Lear, E., and J. Schaad, \"Application Bridging for Federated Access Beyond Web (ABFAB) Architecture\", Work in Progress, draft-ietf-abfab-arch-13, July 2014.",
      "ja": "[ABFAB-アーチ]ハウレット、J.、ハルトマン、S.、Tschofenig、H.、リア、E.、およびJ. Schaad、 \"フェデレーションアクセスを越えてウェブ（ABFAB）アーキテクチャのためのブリッジングアプリケーション\"、進行中で働いて、draft- IETF-abfabアーチ-13、2014年7月。"
    },
    {
      "indent": 3,
      "text": "[RADIUS-Larger-Pkts] Hartman, S., \"Larger Packets for RADIUS over TCP\", Work in Progress, draft-ietf-radext-bigger-packets-03, March 2015.",
      "ja": "[RADIUS-大パケット数]ハートマン、S.、 \"TCP上のRADIUSのための大きなパケット\" が進行中で働いて、ドラフト-IETF-radext-大きな-パケット-03、2015年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2866] Rigney, C., \"RADIUS Accounting\", RFC 2866, June 2000, <http://www.rfc-editor.org/info/rfc2866>.",
      "ja": "[RFC2866] Rigney、C.、 \"RADIUSアカウンティング\"、RFC 2866、2000年6月、<http://www.rfc-editor.org/info/rfc2866>。"
    },
    {
      "indent": 3,
      "text": "[RFC3579] Aboba, B. and P. Calhoun, \"RADIUS (Remote Authentication Dial In User Service) Support For Extensible Authentication Protocol (EAP)\", RFC 3579, September 2003, <http://www.rfc-editor.org/info/rfc3579>.",
      "ja": "[RFC3579] Aboba、B.およびP.カルフーン、 \"RADIUS（ユーザサービスにおけるリモート認証ダイヤル）拡張認証プロトコル（EAP）のサポート\"、RFC 3579、2003年9月、<http://www.rfc-editor.org /情報/ RFC3579>。"
    },
    {
      "indent": 3,
      "text": "[RFC4849] Congdon, P., Sanchez, M., and B. Aboba, \"RADIUS Filter Rule Attribute\", RFC 4849, April 2007, <http://www.rfc-editor.org/info/rfc4849>.",
      "ja": "[RFC4849] Congdon氏、P.、サンチェス、M.、およびB. Aboba、 \"RADIUSフィルタルール属性\"、RFC 4849、2007年4月、<http://www.rfc-editor.org/info/rfc4849>。"
    },
    {
      "indent": 3,
      "text": "[RFC5080] Nelson, D. and A. DeKok, \"Common Remote Authentication Dial In User Service (RADIUS) Implementation Issues and Suggested Fixes\", RFC 5080, December 2007, <http://www.rfc-editor.org/info/rfc5080>.",
      "ja": "[RFC5080]ネルソン、D.とA. DeKok、 \"修正推奨ユーザーサービス（RADIUS）実装の問題で共通のリモート認証ダイヤルと\"、RFC 5080、2007年12月、<http://www.rfc-editor.org/info / rfc5080>。"
    },
    {
      "indent": 3,
      "text": "[RFC5176] Chiba, M., Dommety, G., Eklund, M., Mitton, D., and B. Aboba, \"Dynamic Authorization Extensions to Remote Authentication Dial In User Service (RADIUS)\", RFC 5176, January 2008, <http://www.rfc-editor.org/info/rfc5176>.",
      "ja": "[RFC5176]千葉、M.、Dommety、G.、エクランド、M.、ミトン、D.、およびB. Aboba、 \"ダイナミックな承認拡張ユーザーサービス（RADIUS）でリモート認証ダイヤルへ\"、RFC 5176、2008年1月、 <http://www.rfc-editor.org/info/rfc5176>。"
    },
    {
      "indent": 3,
      "text": "[SAML-RADIUS] Howlett, J., Hartman, S., and A. Perez-Mendez, Ed., \"A RADIUS Attribute, Binding, Profiles, Name Identifier Format, and Confirmation Methods for SAML\", Work in Progress, draft-ietf-abfab-aaa-saml-10, February 2015.",
      "ja": "[SAML-RADIUS]ハウレット、J.、ハルトマン、S.、およびA.ペレス - メンデス、編、 \"RADIUS属性、結合、プロフィール、名前識別子フォーマット、およびSAMLの確認方法\"、進行中で働いて、ドラフト-ietf-abfab-AAA-SAML-10、2015年2月。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "The authors would like to thank the members of the RADEXT working group who have contributed to the development of this specification by either participating in the discussions on the mailing lists or sending comments about our RFC.",
      "ja": "著者は、どちらかのメーリングリストでの議論に参加したり、当社のRFCに関するコメントを送信することにより、この仕様の発展に貢献してきたRADEXTワーキンググループのメンバーに感謝したいと思います。"
    },
    {
      "indent": 3,
      "text": "The authors also thank David Cuenca (University of Murcia) for implementing a proof-of-concept implementation of this RFC that has been useful to improve the quality of the specification.",
      "ja": "著者らはまた、仕様の品質を向上させるために有用であった。このRFCの概念実証の実装を実現するためにデビッド・クエンカ（ムルシア大学を）感謝します。"
    },
    {
      "indent": 3,
      "text": "This work has been partly funded by the GEANT GN3+ SA5 and CLASSe (<http://www.um.es/classe/>) projects.",
      "ja": "この作品は、部分的にGEANT GN3 + SA5とCLASSE（<http://www.um.es/classe/>）のプロジェクトによって資金を供給されています。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Alejandro Perez-Mendez (editor) University of Murcia Campus de Espinardo S/N, Faculty of Computer Science Murcia 30100 Spain",
      "ja": "アレハンドロ・ペレス・メンデス（編集者）大学ムルシアのキャンパスデEspinardo S / N、学部コンピュータサイエンスムルシアの30100スペイン"
    },
    {
      "indent": 3,
      "text": "Phone: +34 868 88 46 44 EMail: alex@um.es",
      "ja": "電話：+34 868 88 46 44 Eメール：alex@um.es"
    },
    {
      "indent": 3,
      "text": "Rafa Marin-Lopez University of Murcia Campus de Espinardo S/N, Faculty of Computer Science Murcia 30100 Spain",
      "ja": "ムルシアキャンパスデEspinardo S / Nのラファ・マリン・ロペス大学、コンピュータサイエンスムルシア30100スペインの学部"
    },
    {
      "indent": 3,
      "text": "Phone: +34 868 88 85 01 EMail: rafa@um.es",
      "ja": "電話：+34 868 88 85 01 Eメール：rafa@um.es"
    },
    {
      "indent": 3,
      "text": "Fernando Pereniguez-Garcia University of Murcia Campus de Espinardo S/N, Faculty of Computer Science Murcia 30100 Spain",
      "ja": "ムルシアキャンパスデEspinardo S / N、学部コンピュータサイエンスムルシアの30100スペインのフェルナンド・Pereniguez、ガルシア大学"
    },
    {
      "indent": 3,
      "text": "Phone: +34 868 88 78 82 EMail: pereniguez@um.es",
      "ja": "電話：+34 868 88 78 82 Eメール：pereniguez@um.es"
    },
    {
      "indent": 3,
      "text": "Gabriel Lopez-Millan University of Murcia Campus de Espinardo S/N, Faculty of Computer Science Murcia 30100 Spain",
      "ja": "ムルシアキャンパスデEspinardo S / N、コンピュータサイエンスムルシア30100スペインの学部のガブリエル・ロペス、ミラン大学"
    },
    {
      "indent": 3,
      "text": "Phone: +34 868 88 85 04 EMail: gabilm@um.es",
      "ja": "電話：+34 868 88 85 04 Eメール：gabilm@um.es"
    },
    {
      "indent": 3,
      "text": "Diego R. Lopez Telefonica I+D Don Ramon de la Cruz, 84 Madrid 28006 Spain",
      "ja": "ディエゴ・R.ロペステレフォニカI + Dドン・ラモン・デ・ラ・クルス、84マドリード28006スペイン"
    },
    {
      "indent": 3,
      "text": "Phone: +34 913 129 041 EMail: diego@tid.es",
      "ja": "電話：+34 913 129 041 Eメール：diego@tid.es"
    },
    {
      "indent": 3,
      "text": "Alan DeKok Network RADIUS SARL 57bis Boulevard des Alpes Meylan 38240 France",
      "ja": "アランDeKokネットワークRADIUS SARL 57bis大通り・デ・ザルプ38240メランフランス"
    },
    {
      "indent": 3,
      "text": "EMail: aland@networkradius.com URI: http://networkradius.com",
      "ja": "電子メール：aland@networkradius.com URI：http://networkradius.com"
    }
  ]
}