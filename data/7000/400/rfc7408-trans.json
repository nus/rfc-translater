{
  "title": {
    "text": "RFC 7408 - Forwarding and Control Element Separation (ForCES) Model Extension",
    "ja": "RFC 7408 - 転送と制御要素の分離（のForCES）モデルの拡張"
  },
  "number": 7408,
  "created_at": "2019-11-01 18:06:54.425530+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                     E. Haleplidis\nRequest for Comments: 7408                          University of Patras\nUpdates: 5812                                              November 2014\nCategory: Standards Track\nISSN: 2070-1721",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Forwarding and Control Element Separation (ForCES) Model Extension",
      "ja": "転送と制御要素の分離（のForCES）モデルの拡張"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This memo extends the Forwarding and Control Element Separation (ForCES) model defined in RFC 5812 and updates that RFC to allow complex data types for metadata, optional default values for data types, and optional access types for structures. It also fixes an issue with Logical Functional Block (LFB) inheritance and introduces two new features: a new event condition called eventBecomesEqualTo and LFB properties. The changes introduced in this memo do not alter the protocol and retain backward compatibility with older LFB models.",
      "ja": "このメモはRFCは、構造物のメタデータのための複雑なデータ型、データ型のオプションのデフォルト値、およびオプションのアクセスタイプを許可するRFC 5812と更新で定義された転送と制御素子分離（のForCES）モデルを拡張します。また、論理機能ブロック（LFB）相続の問題を修正し、2つの新機能紹介：eventBecomesEqualToとLFBのプロパティと呼ばれる新しいイベント条件を。このメモで導入された変更は、プロトコルを変更し、古いLFBモデルとの後方互換性を保持しません。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 5741のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7408.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7408で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2014 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2014 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................2\n   1.1. Requirements Language ......................................3\n   1.2. Terminology ................................................3\n2. ForCES Model Extensions .........................................3\n   2.1. Complex Data Types for Metadata ............................3\n   2.2. Optional Default Values for Data Types .....................5\n   2.3. Optional Access Types for Structs ..........................8\n   2.4. New Event Condition: eventBecomesEqualTo ..................11\n   2.5. LFB Properties ............................................12\n   2.6. LFB Class Inheritance .....................................14\n   2.7. Enhancing XML Validation ..................................15\n3. XML Extension Schema for LFB Class Library Documents ...........15\n4. IANA Considerations ............................................29\n5. Security Considerations ........................................29\n6. References .....................................................30\n   6.1. Normative References ......................................30\n   6.2. Informative References ....................................30\nAcknowledgements ..................................................31\nAuthor's Address ..................................................31",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "The ForCES model [RFC5812] presents a formal way to define Forwarding Element (FE) Logical Functional Blocks (LFBs) using the eXtensible Markup Language (XML). [RFC5812] was published several years before this document, and experience with its use has demonstrated the need to add new modeling concepts and change existing ones.",
      "ja": "ForCESモデル[RFC5812]は拡張マークアップ言語（XML）を使用して、転送要素（FE）論理機能ブロック（LFBs）を定義するための正式な方法を提示しています。 [RFC5812]は、この文書の前に数年出版された、およびその使用の経験は、新たなモデリングの概念を追加し、既存のものを変更する必要性を実証してきました。"
    },
    {
      "indent": 3,
      "text": "Specifically, this document updates the ForCES model [RFC5812] to allow complex data types for metadata (Section 2.1), optional default values for data types (Section 2.2), and optional access types for structures (Section 2.3). It also fixes an issue with LFB class inheritance (Section 2.6). Additionally, the document introduces two new features: a new event condition named eventBecomesEqualTo (Section 2.4) and LFB properties (Section 2.5).",
      "ja": "具体的には、この文書は、メタデータのための複合データ型（セクション2.1）、データタイプ（2.2節）、および構造（セクション2.3）のためのオプションのアクセスタイプのオプションのデフォルト値を可能に力モデル[RFC5812]を更新します。また、LFBクラスの継承（2.6節）との問題が修正されます。 eventBecomesEqualToという名前の新しいイベント条件（2.4節）とLFBのプロパティ（2.5節）：また、ドキュメントは2つの新機能を紹介します。"
    },
    {
      "indent": 3,
      "text": "These extensions are an update to the ForCES model [RFC5812] and do not require any changes to the ForCES protocol [RFC5810] as they are simply changes to the schema definition. Additionally, backward compatibility is ensured as XML libraries produced with the earlier schema are still valid with the new one. In order for XML libraries produced by the new schema to be compatible with existing ForCES implementations, the XML libraries MUST NOT include any of the features described in this document.",
      "ja": "これらの拡張機能は、のForCESモデル[RFC5812]に更新されていると、彼らは単にスキーマ定義に変更されているようRFC5810]のForCESプロトコルを変更する必要はありません。以前のスキーマを使用して生成されたXMLライブラリはまだ新しいものに有効であるとして、また、下位互換性が確保されています。既存のForCES実装と互換性があるように新しいスキーマによって生成されるXMLライブラリのために、XMLライブラリーは、この文書で説明する機能のいずれかを含んではいけません。"
    },
    {
      "indent": 3,
      "text": "Extensions to the schema and excerpts of the schema include the tags <!-- Extension RFC 7408 --> and <!-- /Extension RFC 7408 -->, which designate the beginning and ending of extension text specified by this document in respect to the schema in the original ForCES model [RFC5812].",
      "ja": "点で、この文書で指定された拡張子テキストの開始と終了を指定し、スキーマの拡張とスキーマの抜粋タグを含める<！ - 拡張RFC 7408  - >と<！ -   -  /拡張RFC 7408>オリジナルのForCESモデル[RFC5812]のスキーマへ。"
    },
    {
      "indent": 0,
      "text": "1.1. Requirements Language",
      "section_title": true,
      "ja": "1.1。要件言語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はあります[RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "1.2. Terminology",
      "section_title": true,
      "ja": "1.2。用語"
    },
    {
      "indent": 3,
      "text": "This document uses the terminology defined in the ForCES model [RFC5812]. In particular, the reader is expected to be familiar with the following terms:",
      "ja": "この文書では、のForCESモデル[RFC5812]で定義された用語を使用しています。具体的には、読者は以下の用語に精通していることが予想されます。"
    },
    {
      "indent": 6,
      "text": "FE Model",
      "ja": "モデルでは"
    },
    {
      "indent": 6,
      "text": "LFB (Logical Functional Block) Class (or type)",
      "ja": "LFB（論理機能ブロック）、クラス（またはタイプ）"
    },
    {
      "indent": 6,
      "text": "LFB Instance",
      "ja": "LFBインスタンス"
    },
    {
      "indent": 6,
      "text": "LFB Model",
      "ja": "LFBモデル"
    },
    {
      "indent": 6,
      "text": "Element",
      "ja": "素子"
    },
    {
      "indent": 6,
      "text": "Attribute",
      "ja": "属性"
    },
    {
      "indent": 6,
      "text": "LFB Metadata",
      "ja": "LFBメタデータ"
    },
    {
      "indent": 6,
      "text": "ForCES Component",
      "ja": "ForCESコンポーネント"
    },
    {
      "indent": 6,
      "text": "LFB Class Library",
      "ja": "LFBクラスライブラリ"
    },
    {
      "indent": 0,
      "text": "2. ForCES Model Extensions",
      "section_title": true,
      "ja": "2.のForCESモデルの拡張"
    },
    {
      "indent": 0,
      "text": "2.1. Complex Data Types for Metadata",
      "section_title": true,
      "ja": "2.1。メタデータのための複雑なデータ型"
    },
    {
      "indent": 3,
      "text": "Section 4.6 (\"<metadataDefs> Element for Metadata Definitions\") of the ForCES model [RFC5812] limits the data type use in metadata to only atomic types. Figure 1 shows the XML schema excerpt where only typeRef and atomic are allowed for a metadata definition.",
      "ja": "ForCESモデルのセクション4.6（「メタデータ定義の<metadataDefs>要素」）[RFC5812]は唯一の原子タイプにメタデータのデータ型の使用を制限します。図1は、typeRef、原子のみがメタデータ定義のために許可されているXMLスキーマの抜粋を示します。"
    },
    {
      "indent": 5,
      "text": "<xsd:complexType name=\"metadataDefsType\"> <xsd:sequence> <xsd:element name=\"metadataDef\" maxOccurs=\"unbounded\"> <xsd:complexType> <xsd:sequence> <xsd:element name=\"name\" type=\"xsd:NMTOKEN\"/> <xsd:element ref=\"synopsis\"/> <xsd:element name=\"metadataID\" type=\"xsd:integer\"/> <xsd:element ref=\"description\" minOccurs=\"0\"/> <xsd:choice> <xsd:element name=\"typeRef\" type=\"typeRefNMTOKEN\"/> <xsd:element name=\"atomic\" type=\"atomicType\"/> </xsd:choice> </xsd:sequence> </xsd:complexType> </xsd:element> </xsd:sequence> </xsd:complexType>",
      "ja": "<XSD：complexTypeの名前= \"metadataDefsType\"> <XSD：配列> <XSD：要素名= \"metadataDef\" のmaxOccurs = \"無制限\"> <のxsd：complexTypeの> <XSD：配列> <XSD：要素名= \"名前\" タイプ= \"XSD：NMTOKEN\" /> <XSD：要素REF = \"概要\" /> <XSD：要素名= \"metadataID\" タイプ= \"XSD：整数\" /> <XSD：要素REF = \"説明\" のminOccurs = \"0 \"/> <XSD：選択>ます。<xsd：要素名=\" typeRef」タイプ= \"typeRefNMTOKEN\" /> <XSD：要素名= \"アトミック\" タイプ= \"atomicType\" /> </のxsd：選択> </のxsd：シーケンス> </のxsd：complexTypeの> </のxsd：element>の</のxsd：sequence>を</のxsd：complexTypeの>"
    },
    {
      "indent": 8,
      "text": "Figure 1: Initial metadataDefsType Definition in the Schema",
      "ja": "図1：スキーマにおける初期metadataDefsTypeの定義"
    },
    {
      "indent": 3,
      "text": "However, there are cases where complex metadata are used in the datapath: for example, two simple use cases are described in version 1.1.0 (and subsequent versions) of the OpenFlow Switch Specification [OpenFlowSpec1.1]:",
      "ja": "例えば、2つの簡単なユースケースは、オープンフロースイッチ仕様[OpenFlowSpec1.1]のバージョン1.1.0（およびそれ以降のバージョン）に記載されている：しかし、複雑なメタデータは、データパスで使用される場合があります。"
    },
    {
      "indent": 3,
      "text": "1. The Action Set metadata is an array of actions descriptors, which traverses the processing pipeline along with the packet data.",
      "ja": "1.アクションセットメタデータは、パケットデータと一緒に処理パイプラインを横断するアクション記述子のアレイです。"
    },
    {
      "indent": 3,
      "text": "2. When a packet is received from a controller, it may be accompanied by a list of actions, as metadata, to be performed on it prior to being sent on the processing pipeline. This list of actions is also an array.",
      "ja": "パケットがコントローラから受信されると2は、それがメタデータとして、前処理パイプラインに送られると、それに対して実行すべきアクションのリストを添付することができます。アクションのこのリストには、配列です。"
    },
    {
      "indent": 3,
      "text": "With the extension shown in Figure 2, complex data types are also allowed, specifically structs and arrays as metadata. The key declarations are required to check for validity of content keys in arrays and componentIDs in structs.",
      "ja": "図2に示されている拡張と、複合データ型は、メタデータとして、具体的には、構造体と配列を許可されています。キーの宣言は、構造体の内容配列のキーとcomponentIDsの妥当性をチェックするために必要とされています。"
    },
    {
      "indent": 5,
      "text": "<xsd:complexType name=\"metadataDefsType\"> <xsd:sequence> <xsd:element name=\"metadataDef\" maxOccurs=\"unbounded\"> <xsd:complexType> <xsd:sequence> <xsd:element name=\"name\" type=\"xsd:NMTOKEN\"/> <xsd:element ref=\"synopsis\"/> <xsd:element name=\"metadataID\" type=\"xsd:integer\"/> <xsd:element ref=\"description\" minOccurs=\"0\"/> <xsd:choice> <xsd:element name=\"typeRef\" type=\"typeRefNMTOKEN\"/> <xsd:element name=\"atomic\" type=\"atomicType\"/> <!-- Extension RFC 7408 --> <xsd:element name=\"array\" type=\"arrayType\"> <xsd:key name=\"contentKeyID1\"> <xsd:selector xpath=\"lfb:contentKey\"/> <xsd:field xpath=\"@contentKeyID\"/> </xsd:key> </xsd:element> <xsd:element name=\"struct\" type=\"structType\"> <xsd:key name=\"structComponentID1\"> <xsd:selector xpath=\"lfb:component\"/> <xsd:field xpath=\"@componentID\"/> </xsd:key> </xsd:element> <!-- /Extension RFC 7408 --> </xsd:choice> </xsd:sequence> </xsd:complexType> </xsd:element> </xsd:sequence> </xsd:complexType>",
      "ja": "<XSD：complexTypeの名前= \"metadataDefsType\"> <XSD：配列> <XSD：要素名= \"metadataDef\" のmaxOccurs = \"無制限\"> <のxsd：complexTypeの> <XSD：配列> <XSD：要素名= \"名前\" タイプ= \"XSD：NMTOKEN\" /> <XSD：要素REF = \"概要\" /> <XSD：要素名= \"metadataID\" タイプ= \"XSD：整数\" /> <XSD：要素REF = \"説明\" のminOccurs = \"0 \"/> <XSD：選択>ます。<xsd：要素名=\" typeRef」タイプ= \"typeRefNMTOKEN！\" /> <XSD：要素名= \"アトミック\" タイプ= \"atomicType\" /> < - 拡張RFC 7408  - > <XSD：要素名= \"アレイ\" タイプ= \"のarrayType\"> <XSD：キー名= \"contentKeyID1\"> <XSD：セレクタのXPath = \"LFB：コンテンツ鍵\" /> <XSD：フィールドのXPath = \"contentKeyID @\" /> </ XSD：キー> </ XSD：要素> <XSD：要素名= \"構造体\" タイプ= \"structType\"> <XSD：キー名= \"structComponentID1\"> <XSD：セレクタのXPath = \"LFB：成分\" />ます。<xsd：フィールドのxpath = \"@のCOMPONENTID\" /> </のxsd：キー> </のxsd：element>の<！ -  /拡張RFC 7408  - > </のxsd：選択> </のxsd：sequence>を</ XSD ：のcomplexType> </ XSD：要素> </ XSD：配列> </のxsd：complexTypeの>"
    },
    {
      "indent": 10,
      "text": "Figure 2: New metadataDefsType Definition in the Schema",
      "ja": "図2：スキーマの新metadataDefsTypeの定義"
    },
    {
      "indent": 0,
      "text": "2.2. Optional Default Values for Data Types",
      "section_title": true,
      "ja": "2.2。データ型のオプションのデフォルト値"
    },
    {
      "indent": 3,
      "text": "In the original schema, default values can only be defined for data types defined inside LFB components and not inside structures or arrays. Therefore, default values for data types that are constantly being reused, e.g., counters with default value of 0, have to be constantly respecified. Additionally, data types inside complex data types cannot be defined with a default value, e.g., a counter inside a struct that has a default value of 0.",
      "ja": "元のスキーマでは、デフォルト値のみLFB成分としない内部構造または配列内で定義されたデータタイプのために定義することができます。したがって、絶えず再利用されているデータ・タイプのデフォルト値は、例えば、0のデフォルト値を持つカウンタは、常にに対して再しなければなりません。さらに、複合データ型の内部データタイプがデフォルト値で定義することができない、例えば、0のデフォルト値を持つ構造体内部カウンタ。"
    },
    {
      "indent": 3,
      "text": "This extension allows the option to add default values to data types. These data types can then be referenced as simple components or within complex data types such as structs. A simple use case would be to have a struct component where one of the components is a counter with a default value of zero. To achieve that, the counter must first be defined as a data type with the required default value and then referenced in the struct. Default values MUST adhere the following formal restrictions:",
      "ja": "この拡張は、データ型にデフォルト値を追加するオプションができます。これらのデータ・タイプは、単純な構成要素として、またはそのような構造体などの複合データ型内で参照することができます。単純なユースケースは、成分の一つがゼロのデフォルト値とカウンタである構造体の成分を持つようになるであろう。それを達成するために、カウンタが最初に必要なデフォルト値を持つデータ型として定義され、構造体で参照されなければなりません。デフォルト値は、次の正式な制限を遵守しなければなりません："
    },
    {
      "indent": 3,
      "text": "1. Default values MUST be ignored if the data type is not an atomic or a base data type.",
      "ja": "データ型は、原子又は基本データ・タイプでない場合1.デフォルト値は無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "2. When a data type X with default value A is referenced from a data type Y with a default value B, the default value of the data type that references overrides the referenced default value, e.g., in this case, Y's default value will be B.",
      "ja": "2.デフォルト値Aとデータ型のXは、デフォルト値Bとデータ・タイプYから参照される場合、参照はこの場合には、例えば、参照デフォルト値をオーバーライドし、そのデータ型のデフォルト値は、Yのデフォルト値になりますB."
    },
    {
      "indent": 3,
      "text": "3. Default values of LFB components override any default value specified from the dataTypeDef definition.",
      "ja": "LFBコンポーネントの3デフォルト値はdataTypeDef定義から指定されたデフォルト値を上書きします。"
    },
    {
      "indent": 3,
      "text": "4. Default values of data types referenced in capabilities or metadata MUST be ignored.",
      "ja": "機能やメタデータに参照されるデータタイプの4デフォルト値は無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "This extension simply adds to the definition of dataTypeDefsType in the XML schema shown in Figure 3 to allow default values for dataTypeDefsType. The new definition is shown in Figure 4.",
      "ja": "この拡張は、単にdataTypeDefsTypeのデフォルト値を許可するように、図3に示されているXMLスキーマのdataTypeDefsTypeの定義に追加されます。新しい定義は、図4に示されています。"
    },
    {
      "indent": 5,
      "text": "<xsd:complexType name=\"dataTypeDefsType\"> <xsd:sequence> <xsd:element name=\"dataTypeDef\" maxOccurs=\"unbounded\"> <xsd:complexType> <xsd:sequence> <xsd:element name=\"name\" type=\"xsd:NMTOKEN\"/> <xsd:element name=\"derivedFrom\" type=\"xsd:NMTOKEN\" minOccurs=\"0\"/> <xsd:element ref=\"synopsis\"/> <xsd:element ref=\"description\" minOccurs=\"0\"/> <xsd:group ref=\"typeDeclarationGroup\"/> </xsd:sequence> </xsd:complexType> </xsd:element> </xsd:sequence> </xsd:complexType>",
      "ja": "<XSD：complexTypeの名前= \"dataTypeDefsType\"> <XSD：配列> <XSD：要素名= \"dataTypeDef\" のmaxOccurs = \"無制限\"> <のxsd：complexTypeの> <XSD：配列> <XSD：要素名= \"名前\" タイプ= \"XSD：NMTOKEN\" /> <XSD：要素名= \"derivedFrom\" タイプ= \"のxsd：NMTOKEN\" のminOccurs = \"0\" /> <XSD：要素REF = \"概要\" /> <XSD：要素REF = \"説明\"のminOccurs =\" 0 \"/> <XSD：グループREF =\" typeDeclarationGroup \"/> </ XSD：配列> </のxsd：complexTypeの> </ XSD：要素> </ XSD：配列> </のxsd：complexTypeの>"
    },
    {
      "indent": 6,
      "text": "Figure 3: Initial Excerpt of dataTypeDefsType Definition in the Schema",
      "ja": "図3：スキーマ内dataTypeDefsType定義の初期抜粋"
    },
    {
      "indent": 5,
      "text": "<xsd:complexType name=\"dataTypeDefsType\"> <xsd:sequence> <xsd:element name=\"dataTypeDef\" maxOccurs=\"unbounded\"> <xsd:complexType> <xsd:sequence> <xsd:element name=\"name\" type=\"xsd:NMTOKEN\"/> <xsd:element name=\"derivedFrom\" type=\"xsd:NMTOKEN\" minOccurs=\"0\"/> <xsd:element ref=\"synopsis\"/> <xsd:element ref=\"description\" minOccurs=\"0\"/> <xsd:group ref=\"typeDeclarationGroup\"/> <!-- Extension RFC 7408 --> <xsd:element name=\"defaultValue\" type=\"xsd:token\" minOccurs=\"0\"/> <!-- /Extension RFC 7408 --> </xsd:sequence> </xsd:complexType> </xsd:element> </xsd:sequence> </xsd:complexType>",
      "ja": "<XSD：complexTypeの名前= \"dataTypeDefsType\"> <XSD：配列> <XSD：要素名= \"dataTypeDef\" のmaxOccurs = \"無制限\"> <のxsd：complexTypeの> <XSD：配列> <XSD：要素名= \"名前\" タイプ= \"XSD：NMTOKEN\" /> <XSD：要素名= \"derivedFrom\" タイプ= \"のxsd：NMTOKEN\" のminOccurs = \"0\" /> <XSD：要素REF = \"概要\" /> <XSD：要素REF = \"説明\"minOccurs属性=\" 0 \"/> <XSD：グループREF =\" typeDeclarationGroup \"/> < - 拡張RFC 7408  - > <のxsd：！要素名=\" はdefaultValue」タイプ= \"のxsd：トークン\" のminOccurs = \"0\" ！/> < -  /拡張RFC 7408  - > </のxsd：sequence>を</のxsd：complexTypeの> </のxsd：element>の</のxsd：sequence>を</のxsd：complexTypeの>"
    },
    {
      "indent": 4,
      "text": "Figure 4: New Excerpt of dataTypeDefsType Definition in the Schema",
      "ja": "図4：スキーマで定義dataTypeDefsTypeの新抜粋"
    },
    {
      "indent": 3,
      "text": "Examples of using default values is depicted in Figure 5.",
      "ja": "デフォルト値を使用する例は、図5に示されています。"
    },
    {
      "indent": 5,
      "text": "<dataTypeDef> <name>ZeroCounter</name> <synopsis>A counter with default 0</synopsis> <typeRef>uint32</typeRef> <defaultValue>0</defaultValue> </dataTypeDef> <dataTypeDef> <name>CounterValues</name> <synopsis>Example default values in struct</synopsis> <struct> <component componentID=\"1\"> <name>GoodPacketCounter</name> <synopsis>A counter for good packets</synopsis> <typeRef>ZeroCounter</typeRef> </component> <component componentID=\"2\"> <name>BadPacketCounter</name> <synopsis>A counter for bad packets</synopsis> <typeRef>ZeroCounter</typeRef> </component> </struct> </dataTypeDef>",
      "ja": "<dataTypeDef> <名前> ZeroCounter </名前> <概要>デフォルト0 </あらすじ> <typeRef> UINT32 </ typeRef> <はdefaultValue> 0 </はdefaultValue> </ dataTypeDef> <dataTypeDef> <名前> CounterValuesとカウンタ</名前> <概要>実施例デフォルト値構造体で</概要> <構造体> <コンポーネントのComponentID = \"1\"> <名前> GoodPacketCounter </名前> <概要>良いパケットのカウンタ</シノプシス> <typeRef> ZeroCounter </ typeRef> </コンポーネント> <コンポーネントのComponentID = \"2\"> <名前> BadPacketCounter悪いパケットの</名前> <概要>対向</シノプシス> <typeRef> ZeroCounter </ typeRef> </成分> < /構造体> </ dataTypeDef>"
    },
    {
      "indent": 15,
      "text": "Figure 5: Example of Optional Default Values",
      "ja": "図5：オプションのデフォルト値の例"
    },
    {
      "indent": 0,
      "text": "2.3. Optional Access Types for Structs",
      "section_title": true,
      "ja": "2.3。構造体のためのオプションのアクセスタイプ"
    },
    {
      "indent": 3,
      "text": "In the original schema, the access type can only be defined on components of an LFB and not on components within structs or arrays. That means that when it is a struct data type, it is not possible to fine-tune access type per component within the struct. A simple use case would be to have a read-write struct component where one of the components is a counter with an access type that could be read-reset or read-only, e.g., a read-reset or a read-only counter inside a struct.",
      "ja": "元のスキーマでは、アクセス・タイプは、構造体またはアレイ内の構成要素にLFBとしないのコンポーネントに定義することができます。つまり、構造体のデータ型である場合、構造体の中にコンポーネントごとのアクセスタイプを微調整することができないことを意味します。単純なユースケースは、成分の一つは、カウンタ内部リセット読み取り又は読み取り専用ことができ、アクセスタイプ、例えば、リード・リセットまたは読み取り専用とカウンタで読み書き構造体成分を有することであろう構造体。"
    },
    {
      "indent": 3,
      "text": "This extension allows the definition of the access type for a struct component either in the data type definitions or in the LFB component definitions.",
      "ja": "この拡張は、データ型定義またはLFBのコンポーネント定義のいずれかの構造体コンポーネントのアクセス・タイプの定義を可能にします。"
    },
    {
      "indent": 3,
      "text": "When optional access types for components within a struct are defined, the access types for these components MUST override the access type of the struct. For example, if a struct has an access type of read-write but has a component that is a read-only counter, the counter's access type MUST be read-only.",
      "ja": "構造体の中のコンポーネントのオプションアクセスタイプが定義されている場合、これらのコンポーネントのアクセスタイプは、構造体のアクセスタイプをオーバーライドする必要があります。例えば、構造体は、読み書きのアクセスタイプを有するが、読み取り専用カウンタ、カウンタのアクセスタイプがなければならない読み取り専用である成分を有する場合。"
    },
    {
      "indent": 3,
      "text": "Per [RFC5812], the access type for a component in a capability is always read-only. If an access type is provided for a component in a capability, the access type MUST be ignored. Similarly, if an access type is provided for a struct in a metadata, the access type MUST be ignored.",
      "ja": "[RFC5812]あたり、能力のコンポーネントのアクセスタイプは、常に読み取り専用です。アクセスタイプは能力の構成要素のために提供される場合、アクセス・タイプは無視しなければなりません。アクセスタイプは、メタデータにおける構造体のために提供されている場合、同様に、アクセス・タイプは無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "This extension alters the definition of the struct in the XML schema from the initial definition shown in Figure 6 to the new shown in Figure 7.",
      "ja": "この拡張は、図7に示す新たに図6に示す初期定義のXMLスキーマの構造体の定義を変更します。"
    },
    {
      "indent": 5,
      "text": "<xsd:complexType name=\"structType\"> <xsd:sequence> <xsd:element name=\"derivedFrom\" type=\"typeRefNMTOKEN\" minOccurs=\"0\"/> <xsd:element name=\"component\" maxOccurs=\"unbounded\"> <xsd:complexType> <xsd:sequence> <xsd:element name=\"name\" type=\"xsd:NMTOKEN\"/> <xsd:element ref=\"synopsis\"/> <xsd:element ref=\"description\" minOccurs=\"0\"/> <xsd:element name=\"optional\" minOccurs=\"0\"/> <xsd:group ref=\"typeDeclarationGroup\"/> </xsd:sequence> <xsd:attribute name=\"componentID\" type=\"xsd:unsignedInt\" use=\"required\"/> </xsd:complexType> </xsd:element> </xsd:sequence> </xsd:complexType>",
      "ja": "<XSD：complexTypeの名= \"structType\"> <XSD：配列> <XSD：要素名= \"derivedFrom\" タイプ= \"typeRefNMTOKEN\" のminOccurs = \"0\" /> <XSD：要素名= \"コンポーネント\" のmaxOccurs = \"unbounded\" を> <XSD：のcomplexType> <XSD：配列> <XSD：要素名= \"名前\" タイプ= \"のxsd：NMTOKEN\" /> <XSD：要素REF = \"概要\" /> <XSD：要素REF = \"説明\" のminOccurs = \"0\" /> <XSD：要素名= \"任意\" のminOccurs = \"0\" /> <XSD：グループREF = \"typeDeclarationGroup\" /> </ XSD：配列> <XSD：属性名= \"COMPONENTID\" タイプ= \"XSD：unsignedInt型\" 使用= \"必須\" /> </のxsd：complexTypeの> </ XSD：要素> </ XSD：配列> </のxsd：complexTypeの>"
    },
    {
      "indent": 7,
      "text": "Figure 6: Initial XML for the Struct Definition in the Schema",
      "ja": "図6：スキーマで構造体定義の初期XML"
    },
    {
      "indent": 5,
      "text": "<xsd:complexType name=\"structType\"> <xsd:sequence> <xsd:element name=\"derivedFrom\" type=\"typeRefNMTOKEN\" minOccurs=\"0\"/> <xsd:element name=\"component\" maxOccurs=\"unbounded\"> <xsd:complexType> <xsd:sequence> <xsd:element name=\"name\" type=\"xsd:NMTOKEN\"/> <xsd:element ref=\"synopsis\"/> <xsd:element ref=\"description\" minOccurs=\"0\"/> <xsd:element name=\"optional\" minOccurs=\"0\"/> <xsd:group ref=\"typeDeclarationGroup\"/> </xsd:sequence> <!-- Extension RFC 7408 --> <xsd:attribute name=\"access\" use=\"optional\" default=\"read-write\"> <xsd:simpleType> <xsd:list itemType=\"accessModeType\"/> </xsd:simpleType> </xsd:attribute> <!-- /Extension RFC 7408 --> <xsd:attribute name=\"componentID\" type=\"xsd:unsignedInt\" use=\"required\"/> </xsd:complexType> </xsd:element> </xsd:sequence> </xsd:complexType>",
      "ja": "<XSD：complexTypeの名= \"structType\"> <XSD：配列> <XSD：要素名= \"derivedFrom\" タイプ= \"typeRefNMTOKEN\" のminOccurs = \"0\" /> <XSD：要素名= \"コンポーネント\" のmaxOccurs = \"unbounded\" を> <XSD：のcomplexType> <XSD：配列> <XSD：要素名= \"名前\" タイプ= \"のxsd：NMTOKEN\" /> <XSD：要素REF = \"概要\" /> <XSD：要素REF = \"説明\" のminOccurs = \"0\" /> <XSD：要素名= \"オプション\" のminOccurs = \"0\" /> <XSD：グループREF = \"typeDeclarationGroup\" /> </のxsd：！シーケンス> < - 拡張RFC 7408  - > < XSD：属性名= \"アクセス\" の使用は= \"オプションの\" デフォルト= \"読み書き\"> <のxsd：simpleTypeの> <XSD：リストitemTypeに= \"accessModeType\" /> </のxsd：simpleTypeの> </のxsd：属性> < ！ -  /拡張RFC 7408  - > <XSD：属性名= \"COMPONENTID\" タイプ= \"のxsd：unsignedInt型\" 使用= \"必要\" /> </のxsd：complexTypeの> </のxsd：element>の</のxsd：シーケンス> </のxsd：complexTypeの>"
    },
    {
      "indent": 9,
      "text": "Figure 7: New XML for the Struct Definition in the Schema",
      "ja": "図7：スキーマで構造体定義のための新しいXML"
    },
    {
      "indent": 3,
      "text": "An example of using optional access types for structs is depicted in Figure 8.",
      "ja": "構造体のためのオプションのアクセスタイプを使用した例を図8に示されています。"
    },
    {
      "indent": 6,
      "text": "<component componentID=\"1\" access=\"read-write\"> <name>PacketFlows</name> <synopsis>Packet Flows, match and counter</synopsis> <struct> <component componentID=\"1\"> <name>FlowMatch</name> <synopsis>Flow Match</synopsis> <typeRef>MatchType</typeRef> </component> <component componentID=\"2\" access=\"read-only\"> <name>MatchCounter</name> <synopsis>Packets matching the flow match</synopsis> <typeRef>ZeroCounter</typeRef> </component> </struct> </component>",
      "ja": "<成分COMPONENTID = \"1\" アクセス= \"読み取りと書き込み\"> <名前> PacketFlows </名前> <概要>パケットフロー、一致カウンタ</シノプシス> <構造体> <コンポーネントのComponentID = \"1\"> <名前> FlowMatch </名前> <概要>フローマッチ</概要> <typeRef> MatchType </ typeRef> </部品> <コンポーネントCOMPONENTID = \"2\" アクセス= \"読み取り専用\"> <名前> MatchCounter </名前> <概要>パケットフロー一致を一致</シノプシス> <typeRef> ZeroCounter </ typeRef> </成分> </構造体> </成分>"
    },
    {
      "indent": 11,
      "text": "Figure 8: Example of Optional Access Types for Struct",
      "ja": "図8：構造体のためのオプションのアクセスタイプの例"
    },
    {
      "indent": 0,
      "text": "2.4. New Event Condition: eventBecomesEqualTo",
      "section_title": true,
      "ja": "2.4。新規イベント条件：eventBecomesEqualTo"
    },
    {
      "indent": 3,
      "text": "This extension adds one more event condition in the model schema, eventBecomesEqualTo. eventBecomesEqualTo is different from eventGreaterThan and eventLessThan because the event is triggered when the value is exactly that of the eventBecomesEqualTo threshold. This event condition is particularly useful when there is a need to monitor one or more states of an LFB or the FE. For example, in the Control Element High Availability (CEHA) document [RFC7121], it may be useful for the master CE to know which backup CEs have just become associated in order to connect to them and begin synchronizing the state of the FE. The master CE could always poll for such information, but getting such an event will speed up the process, and the event may be useful in other cases as well for monitoring state.",
      "ja": "この拡張は、モデルスキーマ、eventBecomesEqualToにおけるもう一つのイベント条件を追加します。値が正確にeventBecomesEqualToしきい値のあるときにイベントがトリガされているのでeventBecomesEqualToはeventGreaterThanとeventLessThanは異なっています。 LFBやFEの1つの以上の状態を監視する必要があるときに、このイベント条件は特に便利です。例えば、制御要素高可用性（CEHA）ドキュメント[RFC7121]で、CEがちょうどそれらに接続し、FEの状態を同期を開始するために、関連するとなっているバックアップを知っているマスターCEのために有用である可能性があります。マスターCEは常にそのような情報のためにポーリングすることもできますが、このようなイベントを取得することは、プロセスをスピードアップし、イベントが状態を監視するためだけでなく、他の場合に有用である可能性があります。"
    },
    {
      "indent": 3,
      "text": "The event MUST be triggered only when the value of the targeted component becomes equal to the event condition value. Implementations MUST NOT generate subsequent events while the targeted component's value remains equal to the event condition's value.",
      "ja": "イベントは、標的成分の値は、イベント条件の値に等しくなった場合にのみトリガされなければなりません。目標コンポーネントの値は、イベント条件の値に等しいまま実装は、その後のイベントを発生させてはいけません。"
    },
    {
      "indent": 3,
      "text": "eventBecomesEqualTo is appended to the schema as shown in Figure 9.",
      "ja": "図9に示すようにeventBecomesEqualToスキーマに追加されます。"
    },
    {
      "indent": 5,
      "text": "<xsd:element name=\"eventBecomesEqualTo\" substitutionGroup=\"eventCondition\"/>",
      "ja": "ます。<xsd：要素名= \"eventBecomesEqualTo\" のsubstitutionGroup = \"eventCondition\" />"
    },
    {
      "indent": 7,
      "text": "Figure 9: New Excerpt of eventBecomesEqualTo Event Condition Definition in the Schema",
      "ja": "図9：スキーマ内eventBecomesEqualToイベント条件定義の新抜粋"
    },
    {
      "indent": 3,
      "text": "It can become useful for the CE to be notified when the state has changed once the eventBecomesEqualTo event has been triggered, e.g., the CE may need to know when a backup CE has lost association. Such an event can be generated either by defining a second event on the same component (namely, an eventChanged) or by simply reusing eventBecomesEqualTo and using event properties (in particular, eventHysteresis). We append the following definition to the eventHysteresis defined in Section 4.8.5.2 of [RFC5812], with V being the hysteresis value:",
      "ja": "eventBecomesEqualToイベントがトリガされた後の状態が変更されたときにCEを通知するために便利になることができ、例えば、CEは、バックアップCEは、関連付けを失った時に知っておく必要があるかもしれません。そのようなイベントは、同一の構成要素（すなわち、eventChanged）上に第2のイベントを定義することによって、または単にeventBecomesEqualToを再利用し、イベントの特性（特に、eventHysteresis）を用いてのいずれかで生成することができます。私たちは、Vは、ヒステリシス値であることと、[RFC5812]のセクション4.8.5.2で定義されたeventHysteresisに次の定義を追加します。"
    },
    {
      "indent": 3,
      "text": "o For an eventBecomesEqualTo condition, after the last notification, a new eventBecomesEqualTo notification MUST be generated only one time once the value has changed by +/- V.",
      "ja": "O eventBecomesEqualTo条件については、最後の通知後、新しいeventBecomesEqualTo通知は、値は+/- V.によって変更された後に一度だけ生成されなければなりません"
    },
    {
      "indent": 3,
      "text": "For example, using the value of 1 for V will, in effect, create a singular event that will notify the CE that the value has changed by at least 1.",
      "ja": "例えば、Vの場合は1の値を使用して、実際に、値は少なくとも1で変更されたCEに通知する特異イベントを作成します。"
    },
    {
      "indent": 3,
      "text": "A developer of a CE should consider using count or time filtering to avoid being overrun by messages, e.g., in the case of rapid state changes.",
      "ja": "CEの開発者が急激な状態変化の場合には、例えば、メッセージでオーバーランされないようにフィルタリング回数や時間を使用して検討すべきです。"
    },
    {
      "indent": 0,
      "text": "2.5. LFB Properties",
      "section_title": true,
      "ja": "2.5。 LFBのプロパティ"
    },
    {
      "indent": 3,
      "text": "The previous model definition specifies properties for components of LFBs. Experience has shown that, at least for debug reasons, it would be useful to have statistics per LFB instance to monitor sent and received messages and errors in communication between a CE and FE. These properties are read-only.",
      "ja": "以前のモデルの定義はLFBsのコンポーネントのプロパティを指定します。経験は、少なくともデバッグの理由から、送信され、CEとFEとの間の通信のメッセージとエラーを受信した監視するLFBインスタンスごとに統計を有することが有用であろう、ということを示しています。これらのプロパティは読み取り専用です。"
    },
    {
      "indent": 3,
      "text": "In order to avoid ambiguity on protocol path semantics, this document specifies that the LFB componentID 0 specifically MUST refer to LFB properties and ID 0 MUST NOT be used for any component definition. This disallowance is backward compatible as no known LFB definition uses an LFB componentID 0. Any command with a path starting from LFB componentID 0 refers to LFB properties. Figures 10 and 11 illustrate the change in the XML schema that disallows usage of LFB componentID 0:",
      "ja": "プロトコル経路セマンティクスに曖昧さを避けるために、この文書は、LFBのComponentID 0は、具体的にLFBのプロパティを参照する必要がありそしてID 0は、任意のコンポーネント定義のために使用してはならないことを指定します。既知LFB定義は、LFBのComponentID 0から始まるパスとLFB COMPONENTID 0任意のコマンドを使用しないように、この否認は、LFBの特性を指す下位互換性があります。 10及び11は、LFBのComponentID 0の使用を禁止するXMLスキーマの変化を示しています。"
    },
    {
      "indent": 6,
      "text": "<xsd:attribute name=\"componentID\" type=\"xsd:unsignedInt\" use=\"required\">",
      "ja": "<XSD：属性名= \"COMPONENTID\" タイプ= \"のxsd：unsignedInt型\" 使用= \"必要\">"
    },
    {
      "indent": 16,
      "text": "Figure 10: Initial XML for LFB componentIDs",
      "ja": "図10：LFB componentIDsの初期XML"
    },
    {
      "indent": 6,
      "text": "<!-- Extension added restriction to componentID --> <xsd:attribute name=\"componentID\" use=\"required\"> <xsd:simpleType> <xsd:restriction base=\"xsd:unsignedInt\"> <xsd:minExclusive value=\"0\"/> </xsd:restriction> </xsd:simpleType> </xsd:attribute> <!-- End of extension -->",
      "ja": "<！ -  COMPONENTIDへの拡張を追加制限 - > <XSD：属性名= \"COMPONENTID\" 使用= \"必要\"> <のxsd：simpleTypeの> <XSD：制限ベース= \"のxsd：unsignedInt型\"> <XSD：minExclusiveの値= \"0\" /> </のxsd：制限> </のxsd：simpleTypeの> </のxsd：！属性> < - 拡張の終わり - >"
    },
    {
      "indent": 9,
      "text": "Figure 11: New XML to Disallow Usage of LFB componentID 0",
      "ja": "図11：LFB COMPONENTID 0の使用を禁止する新しいXML"
    },
    {
      "indent": 3,
      "text": "The following data type definitions are to be used as properties for LFB instances.",
      "ja": "次のデータ型定義は、LFBインスタンスのプロパティとして使用されます。"
    },
    {
      "indent": 6,
      "text": "<dataTypeDef> <name>LFBProperties</name> <synopsis>LFB Properties definition</synopsis> <struct> <component componentID=\"1\"> <name>PacketsSentToCE</name> <synopsis>Packets sent to CE</synopsis> <typeRef>uint32</typeRef> </component> <component componentID=\"2\"> <name>SentErrorPacketsToCE</name> <synopsis>Error Packets sent to CE</synopsis> <typeRef>uint32</typeRef> </component> <component componentID=\"3\"> <name>BytesSentToCE</name> <synopsis>Bytes sent to CE</synopsis> <typeRef>uint32</typeRef> </component> <component componentID=\"4\"> <name>SentErrorBytesToCE</name> <synopsis>Error Bytes sent to CE</synopsis> <typeRef>uint32</typeRef> </component> <component componentID=\"5\"> <name>PacketsReceivedFromCE</name> <synopsis>Packets received from CE</synopsis> <typeRef>uint32</typeRef>",
      "ja": "<dataTypeDef> <名前> LFBProperties </名前> <概要> LFBプロパティ定義</シノプシス> <構造体> <コンポーネントのComponentID = \"1\"> <名前> PacketsSentToCE </名前> <概要>パケットはCEに送信</シノプシス> <typeRef> UINT32 </ typeRef> </コンポーネント> <コンポーネントのComponentID = \"2\"> <名前> SentErrorPacketsToCE </名前> <概要> CE <へ送信エラーパケット/概要> <typeRef> UINT32 </ typeRef> < /コンポーネント> <コンポーネントのComponentID = \"3\"> <名前> BytesSentToCE </名前> <概要> CEに送信されたバイト</シノプシス> <typeRef> UINT32 </ typeRef> </コンポーネント> <コンポーネントのComponentID = \"4\"> <名前> SentErrorBytesToCE </名前> <概要> CEに送信されたエラー・バイト</シノプシス> <typeRef> UINT32 </ typeRef> </コンポーネント> <コンポーネントのComponentID = \"5\"> <名前> PacketsReceivedFromCE </名前> <概要>パケットは</概要> <typeRef> UINT32 </ typeRef> CEから受信しました"
    },
    {
      "indent": 6,
      "text": " </component> <component componentID=\"6\"> <name>ReceivedErrorPacketsFromCE</name> <synopsis>Error Packets received from CE</synopsis> <typeRef>uint32</typeRef> </component> <component componentID=\"7\"> <name>BytesReceivedFromCE</name> <synopsis>Bytes received from CE</synopsis> <typeRef>uint32</typeRef> </component> <component componentID=\"8\"> <name>ReceivedErrorBytesFromCE</name> <synopsis>Error Bytes received from CE</synopsis> <typeRef>uint32</typeRef> </component> </struct> </dataTypeDef>",
      "ja": "</コンポーネント> <コンポーネントのComponentID = \"6\"> <名前> ReceivedErrorPacketsFromCE </名前> <概要>エラーパケットをCEから受信した</シノプシス> <typeRef> UINT32 </ typeRef> </コンポーネント> <コンポーネントのComponentID = \"7 \"> <名前> BytesReceivedFromCE </名前> <概要>バイトは、CEから受信した</シノプシス> <typeRef> UINT32 </ typeRef> </コンポーネント> <コンポーネントのComponentID =\" 8\" > <名前> ReceivedErrorBytesFromCE </名前> <概要>エラーバイト数</概要> <typeRef> UINT32 </ typeRef> </成分> </構造体> </ dataTypeDef> CEから受信しました"
    },
    {
      "indent": 18,
      "text": "Figure 12: Properties for LFB Instances",
      "ja": "図12：LFBインスタンスのプロパティ"
    },
    {
      "indent": 0,
      "text": "2.6. LFB Class Inheritance",
      "section_title": true,
      "ja": "2.6。 LFBクラスの継承"
    },
    {
      "indent": 3,
      "text": "The ForCES model [RFC5812] allows inheritance for LFB classes. However, the XML schema defines only the LFB class from which an LFB class inherits. Recent implementations have identified an issue where ambiguity rises when different versions of the parent LFB class exist. This document augments the derivedFrom part of the LFB class definition with an optional version attribute when the derivedFrom field is used.",
      "ja": "ForCESモデル[RFC5812]はLFBクラスの継承を可能にします。しかし、XMLスキーマは、LFBのクラスが継承するだけLFBクラスを定義します。最近の実装では、親LFBクラスの異なるバージョンが存在する場合にあいまいさが上昇する問題を特定しました。この文書では、derivedFromフィールドが使用されているオプションのバージョン属性を持つLFBクラス定義のderivedFrom部分を補強します。"
    },
    {
      "indent": 3,
      "text": "Having the version attribute as optional was a decision based on the need to maintain backward compatibility with the XML schema defined in [RFC5812]. However, if the version is omitted, then derivedFrom will always specify the first version of the parent LFB class, which usually is version 1.0.",
      "ja": "オプションとして、バージョン属性を持つことは、[RFC5812]で定義されたXMLスキーマとの後方互換性を維持する必要性に基づいて決定しました。バージョンが省略された場合は、その後、derivedFromは常に通常バージョン1.0である、親LFBクラスの最初のバージョンを指定します。"
    },
    {
      "indent": 3,
      "text": "This extension alters the definition of derivedFrom in the XML schema from the initial definition shown in Figure 13 to the new shown in Figure 14.",
      "ja": "この拡張は、図14に示す新たに図13に示す初期定義のXMLスキーマにderivedFromの定義を変更します。"
    },
    {
      "indent": 6,
      "text": "<xsd:element name=\"derivedFrom\" minOccurs=\"0\"/>",
      "ja": "ます。<xsd：要素名= \"derivedFrom\" のminOccurs = \"0\" />"
    },
    {
      "indent": 13,
      "text": "Figure 13: Initial XML for LFB Class Inheritance",
      "ja": "図13：LFBクラスの継承のための初期XML"
    },
    {
      "indent": 6,
      "text": "<xsd:element name=\"derivedFrom\" minOccurs=\"0\"> <xsd:complexType> <xsd:simpleContent> <xsd:extension base=\"xsd:NMTOKEN\"> <xsd:attribute name=\"version\" type=\"versionType\" use=\"optional\"/> </xsd:extension> </xsd:simpleContent> </xsd:complexType> </xsd:element>",
      "ja": "<XSD：要素名= \"derivedFrom\" のminOccurs = \"0\"> <のxsd：complexTypeの> <XSD：simpleContentを> <XSD：増設ベース= \"のxsd：NMTOKEN\"> <XSD：属性名= \"バージョン\" タイプ= \"versionType拡張> </ XSD：simpleContentを> </のxsd：complexTypeの> </ XSD：オプション \"/> </ XSD \"=使う\" 要素を>"
    },
    {
      "indent": 15,
      "text": "Figure 14: New XML for LFB Class Inheritance",
      "ja": "図14：LFBクラスの継承のための新しいXML"
    },
    {
      "indent": 3,
      "text": "An example of the use of the version attribute is given in Figure 15.",
      "ja": "バージョン属性の使用の例が図15に示されています。"
    },
    {
      "indent": 6,
      "text": "<derivedFrom version=\"1.0\">EtherPHYCop</derivedFrom>",
      "ja": "EthをPHYCop </由来> <バージョン= \"1.0\" から派生>"
    },
    {
      "indent": 6,
      "text": "Figure 15: Example of Use of New XML for LFB Class Inheritance",
      "ja": "図15：LFBクラスの継承のための新しいXMLの使用例"
    },
    {
      "indent": 0,
      "text": "2.7. Enhancing XML Validation",
      "section_title": true,
      "ja": "2.7。 XMLの検証を強化"
    },
    {
      "indent": 3,
      "text": "As specified earlier, this is not an extension but an enhancement of the schema to provide additional validation rules. This includes adding new key declarations to provide uniqueness as defined by the ForCES model [RFC5812]. Such validations work only within the same XML file.",
      "ja": "先に指定したように、これは拡張ではなく、スキーマの拡張は、追加の検証ルールを提供します。これは、のForCESモデル[RFC5812]で定義されるように一意性を提供する新しいキーの宣言を追加することが含まれます。このような検証は、同じXMLファイル内でのみ動作します。"
    },
    {
      "indent": 3,
      "text": "This document introduces the following validation rules that did not exist in the original schema in [RFC5812]:",
      "ja": "この文書では、[RFC5812]で元のスキーマに存在していなかった以下の検証ルールが導入されています。"
    },
    {
      "indent": 3,
      "text": "1. Each metadataID must be unique.",
      "section_title": true,
      "ja": "1.各metadataIDは一意である必要があります。"
    },
    {
      "indent": 3,
      "text": "2. LFBClassIDs must be unique.",
      "section_title": true,
      "ja": "2. LFBClassIDsは一意でなければなりません。"
    },
    {
      "indent": 3,
      "text": "3. componentID, capabilityID, and Event baseID must be unique per LFB.",
      "ja": "3. COMPONENTID、capabilityID、およびイベントbaseIDはLFBごとに一意である必要があります。"
    },
    {
      "indent": 3,
      "text": "4. eventIDs must be unique per LFB.",
      "section_title": true,
      "ja": "4. EVENTIDSはLFBごとに一意である必要があります。"
    },
    {
      "indent": 3,
      "text": "5. Special values in atomic data types must be unique per atomic data type.",
      "ja": "アトミックデータタイプで5.特別な値は、アトミックデータタイプごとに一意である必要があります。"
    },
    {
      "indent": 0,
      "text": "3. XML Extension Schema for LFB Class Library Documents",
      "section_title": true,
      "ja": "LFBクラスライブラリドキュメント3. XMLスキーマの拡張"
    },
    {
      "indent": 3,
      "text": "This section includes the new XML schema. Note that the namespace number has been updated from 1.0 to 1.1.",
      "ja": "このセクションでは、新しいXMLスキーマを含んでいます。名前空間の数は1.0から1.1に更新されていることに注意してください。"
    },
    {
      "indent": 3,
      "text": "The extensions described in this document are backwards compatible in terms of the operation of the ForCES protocol. In terms of the XML, any definitions that were valid under the old namespace are valid under the new namespace. It is to be noted that any auxiliary tools that are processing XML definitions written under both namespaces will need to be able to understand both.",
      "ja": "本書では説明拡張はのForCESプロトコルの動作の点で下位互換性があります。 XMLの面では、古い名前空間の下で有効であった任意の定義が新しい名前空間の下で有効です。これは、両方の名前空間の下に書かれたXML定義を処理している任意の補助ツールは、両方を理解することができるようにする必要がありますことに留意すべきです。"
    },
    {
      "indent": 0,
      "text": "<?xml version=\"1.0\" encoding=\"UTF-8\"?> <xsd:schema xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns=\"urn:ietf:params:xml:ns:forces:lfbmodel:1.1\" xmlns:lfb=\"urn:ietf:params:xml:ns:forces:lfbmodel:1.1\" targetNamespace=\"urn:ietf:params:xml:ns:forces:lfbmodel:1.1\" elementFormDefault=\"qualified\" attributeFormDefault=\"unqualified\"> <xsd:annotation> <xsd:documentation xml:lang=\"en\"> Schema for Defining LFB Classes and associated types (frames, data types for LFB attributes, and metadata). </xsd:documentation> </xsd:annotation> <xsd:element name=\"description\" type=\"xsd:string\"/> <xsd:element name=\"synopsis\" type=\"xsd:string\"/> <!-- Document root element: LFBLibrary --> <xsd:element name=\"LFBLibrary\"> <xsd:complexType> <xsd:sequence> <xsd:element ref=\"description\" minOccurs=\"0\"/> <xsd:element name=\"load\" type=\"loadType\" minOccurs=\"0\" maxOccurs=\"unbounded\"/> <xsd:element name=\"frameDefs\" type=\"frameDefsType\" minOccurs=\"0\"/> <xsd:element name=\"dataTypeDefs\" type=\"dataTypeDefsType\" minOccurs=\"0\"/> <xsd:element name=\"metadataDefs\" type=\"metadataDefsType\" minOccurs=\"0\"/> <xsd:element name=\"LFBClassDefs\" type=\"LFBClassDefsType\" minOccurs=\"0\"/> </xsd:sequence> <xsd:attribute name=\"provides\" type=\"xsd:Name\" use=\"required\"/> </xsd:complexType> <!-- Uniqueness constraints --> <xsd:key name=\"frame\"> <xsd:selector xpath=\"lfb:frameDefs/lfb:frameDef\"/> <xsd:field xpath=\"lfb:name\"/> </xsd:key> <xsd:key name=\"dataType\"> <xsd:selector xpath=\"lfb:dataTypeDefs/lfb:dataTypeDef\"/> <xsd:field xpath=\"lfb:name\"/>",
      "ja": "<？xml version = \"1.0\" エンコード= \"UTF-8\"？> <XSD：スキーマのxmlns：XSD = \"http://www.w3.org/2001/XMLSchema\" のxmlns = \"壷：IETF：のparams：XML ：NS：力：lfbmodel：1.1\" のxmlns：LFB = \"壷：IETF：のparams：XML：NS：力：lfbmodel：1.1\" のtargetNamespace = \"壷：IETF：のparams：XML：NS：力：lfbmodel：1.1\" のelementFormDefault = \"資格\" attributeFormDefault = \"非修飾\"> <のxsd：注釈> <XSD：ドキュメントのXML：LANG = \"EN\">の定義LFBクラスと関連するタイプ（フレーム、LFB属性、およびメタデータのためのデータ・タイプ）のスキーマ。 </ XSD：ドキュメンテーション> </のxsd：注釈> <のxsd：要素名= \"説明\" タイプ= \"のxsd：文字列\" /> <XSD：要素名= \"あらすじ\" タイプ= \"のxsd：文字列\" /> <！ - 文書のルート要素：LFBLibrary  - > <XSD：要素名= \"LFBLibrary\"> <のxsd：complexTypeの> <XSD：配列> <XSD：要素REF = \"説明\" のminOccurs = \"0\" /> <XSD：要素NAME = \"負荷\" タイプ= \"LOADTYPE\" のminOccurs = \"0\" のmaxOccurs = \"無制限\" /> <XSD：要素名= \"frameDefs\" タイプ= \"frameDefsType\" のminOccurs = \"0\" /> <XSD：要素名=」 dataTypeDefs」TYPE = \"dataTypeDefsType\" のminOccurs = \"0\" /> <XSD：要素名= \"metadataDefs\" タイプ= \"metadataDefsType\" のminOccurs = \"0\" /> <XSD：要素名= \"LFBClassDefs\" タイプ= \"LFBClassDefsType\" minOccurs属性= \"0\" /> </のxsd：シーケンスが> <のxsd：使用= \"必須\" /> </ XSD：属性名は=タイプ= \"名前のxsd\"： \"提供\"！のcomplexType> < - 一意性制約 - >を<XSD：キー名= \"フレーム\"> <XSD：セレクタのXPath = \"LFB：frameDefs / LFB：frameDef\" /> <XSD：フィールドのXPath = \"LFB：名\" /> </ XSD：キー> <XSD：キー名前= \"データ型\"> <のxsd：セレクタのxpath = \"LFB：dataTypeDefs / LFB：dataTypeDef\" /> <XSD：フィールドXPathの= \"LFB：名\" />"
    },
    {
      "indent": 3,
      "text": " </xsd:key> <xsd:key name=\"metadataDef\"> <xsd:selector xpath=\"lfb:metadataDefs/lfb:metadataDef\"/> <xsd:field xpath=\"lfb:name\"/> </xsd:key> <xsd:key name=\"metadataDefID\"> <xsd:selector xpath=\"lfb:metadataDefs/lfb:metadataDef\"/> <xsd:field xpath=\"lfb:metadataID\"/> </xsd:key> <xsd:key name=\"LFBClassDef\"> <xsd:selector xpath=\"lfb:LFBClassDefs/lfb:LFBClassDef\"/> <xsd:field xpath=\"lfb:name\"/> </xsd:key> <xsd:key name=\"LFBClassDefID\"> <xsd:selector xpath=\"lfb:LFBClassDefs/lfb:LFBClassDef\"/> <xsd:field xpath=\"@LFBClassID\"/> </xsd:key> </xsd:element> <xsd:complexType name=\"loadType\"> <xsd:attribute name=\"library\" type=\"xsd:Name\" use=\"required\"/> <xsd:attribute name=\"location\" type=\"xsd:anyURI\" use=\"optional\"/> </xsd:complexType> <xsd:complexType name=\"frameDefsType\"> <xsd:sequence> <xsd:element name=\"frameDef\" maxOccurs=\"unbounded\"> <xsd:complexType> <xsd:sequence> <xsd:element name=\"name\" type=\"xsd:NMTOKEN\"/> <xsd:element ref=\"synopsis\"/> <xsd:element ref=\"description\" minOccurs=\"0\"/> </xsd:sequence> </xsd:complexType> </xsd:element> </xsd:sequence> </xsd:complexType> <xsd:complexType name=\"dataTypeDefsType\"> <xsd:sequence> <xsd:element name=\"dataTypeDef\" maxOccurs=\"unbounded\"> <xsd:complexType> <xsd:sequence> <xsd:element name=\"name\" type=\"xsd:NMTOKEN\"/> <xsd:element name=\"derivedFrom\" type=\"xsd:NMTOKEN\" minOccurs=\"0\"/> <xsd:element ref=\"synopsis\"/> <xsd:element ref=\"description\" minOccurs=\"0\"/>",
      "ja": "</ XSD：キー> <XSD：キー名= \"metadataDef\"> <XSD：セレクタのXPath = \"LFB：metadataDefs / LFB：metadataDef\" /> <XSD：フィールドのXPath = \"LFB：名\" /> </ XSD：キー> <のxsd：キー名= \"metadataDefID\"> <のxsd：セレクタのxpath = \"LFB：metadataDefs / LFB：metadataDef\" /> <XSD：フィールドのxpath = \"LFB：metadataID\" /> </のxsd：キー> <XSD ：キー名= \"LFBClassDef\"> <XSD：セレクタは、XPath = \"LFB：LFBClassDefs / LFB：LFBClassDef\" /> <XSD：フィールドのXPath = \"LFB：名\" /> </ XSD：キー> <XSD：キー名= \"LFBClassDefID\"> <のxsd：セレクタのxpath = \"LFB：LFBClassDefs / LFB：LFBClassDef\" /> <XSD：フィールドのxpath = \"LFBClassID @\" /> </のxsd：キー> </のxsd：element>の<のxsd：complexTypeの名前= \"LOADTYPE\"> <XSD：属性名= \"ライブラリ\" タイプ= \"のxsd：名前\" 使用は= \"必要\" /> <XSD：属性名= \"場所\" タイプ= \"のxsd：anyURIの\" 使用= \"オプション\" / > </のxsd：complexTypeの> <のxsd：complexTypeの名前= \"frameDefsType\"> <XSD：配列> <XSD：要素名= \"frameDef\" のmaxOccurs = \"無制限\"> <のxsd：complexTypeの> <XSD：配列> <XSD。要素名= \"名前\" タイプ= \"のxsd：NMTOKEN\" /> <XSD：要素REF = \"概要\" /> <XSD：要素REF = \"説明\" のminOccurs = \"0\" /> </ XSD：配列uence> </のxsd：complexTypeの> </のxsd：element>の</のxsd：sequence>を</のxsd：complexTypeの> <XSD：complexTypeの名= \"dataTypeDefsType\"> <のxsd：sequence>を<のxsd：要素名= \"dataTypeDef\" maxOccurs = \"無制限\"> <のxsd：complexTypeの> <のxsd：sequence>を<のxsd：要素名= \"名前\" タイプ= \"のxsd：NMTOKEN\" /> <XSD：要素名= \"derivedFrom\" タイプ= \"のxsd：NMTOKEN\" minOccurs = \"0\" /> <XSD：要素REF = \"概要\" /> <XSD：要素REF = \"説明\" のminOccurs = \"0\" />"
    },
    {
      "indent": 3,
      "text": " <xsd:group ref=\"typeDeclarationGroup\"/> <!-- Extension RFC 7408 --> <xsd:element name=\"defaultValue\" type=\"xsd:token\" minOccurs=\"0\"/> <!-- /Extension RFC 7408 --> </xsd:sequence> </xsd:complexType> </xsd:element> </xsd:sequence> </xsd:complexType> <!-- Predefined (built-in) atomic data-types are: char, uchar, int16, uint16, int32, uint32, int64, uint64, string[N], string, byte[N], boolean, octetstring[N], float32, float64 --> <xsd:group name=\"typeDeclarationGroup\"> <xsd:choice> <xsd:element name=\"typeRef\" type=\"typeRefNMTOKEN\"/> <xsd:element name=\"atomic\" type=\"atomicType\"/> <xsd:element name=\"array\" type=\"arrayType\"> <!-- Extension RFC 7408 --> <!-- declare keys to have unique IDs --> <xsd:key name=\"contentKeyID\"> <xsd:selector xpath=\"lfb:contentKey\"/> <xsd:field xpath=\"@contentKeyID\"/> </xsd:key> <!-- /Extension RFC 7408 --> </xsd:element> <xsd:element name=\"struct\" type=\"structType\"> <!-- Extension RFC 7408 --> <!-- key declaration to make componentIDs unique in a struct --> <xsd:key name=\"structComponentID\"> <xsd:selector xpath=\"lfb:component\"/> <xsd:field xpath=\"@componentID\"/> </xsd:key> <!-- /Extension RFC 7408 --> </xsd:element> <xsd:element name=\"union\" type=\"structType\"/> <xsd:element name=\"alias\" type=\"typeRefNMTOKEN\"/> </xsd:choice> </xsd:group> <xsd:simpleType name=\"typeRefNMTOKEN\"> <xsd:restriction base=\"xsd:token\"> <xsd:pattern value=\"\\c+\"/> <xsd:pattern value=\"string\\[\\d+\\]\"/> <xsd:pattern value=\"byte\\[\\d+\\]\"/> <xsd:pattern value=\"octetstring\\[\\d+\\]\"/> </xsd:restriction> </xsd:simpleType>",
      "ja": "<XSD：グループREF = \"typeDeclarationGroup\" /> < - 拡張RFC 7408  - > <！のxsd：要素名= \"はdefaultValue\" タイプ= \"のxsd：トークン\" のminOccurs = \"0\" /> <！ -  /拡張RFC 7408  - > </のxsd：sequence>を</のxsd：complexTypeの> </のxsd：element>の</のxsd：sequence>を</のxsd：！complexTypeの> < - 定義済みの（ビルトイン）アトミックデータ型されています：チャー、UCHAR、INT16、uint16の、INT32、UINT32、Int64の、UINT64、文字列[N]、文字列、バイト[N]、ブール、OCTETSTRING [N]のfloat32、のfloat64  - > <XSD：グループ名= \"typeDeclarationGroup \"> <XSD：選択> <XSD：要素名=\" typeRef」タイプ= \"typeRefNMTOKEN\" /> <XSD：要素名= \"アトミック\" タイプ= \"atomicType\" /> <XSD：要素名= \"アレイ\" タイプ= ！ \"のarrayType\"> < - 拡張RFC 7408  - > < - 固有のIDを持つようにキーを宣言 - > <のxsd：！キー名= \"contentKeyID\"> <のxsd：セレクタのxpath = \"LFB：コンテンツ鍵\" />ます。<xsd：フィールドのxpath = \"contentKeyID @\" /> </のxsd：キー> <！ -  /拡張RFC 7408  - > </のxsd：element>の<のxsd：要素名= \"構造体\" タイプ= \"structType\"> <XSD < - 拡張RFC 7408  - > <！ -   - 構造体にcomponentIDsを一意にするための鍵宣言！>：KE Y名= \"structComponentID\"> <のxsd：セレクタのxpath = \"LFB：コンポーネント\" /> <XSD：フィールドのxpath = \"@ COMPONENTID\" /> </のxsd：！キー> < -  /拡張RFC 7408  - > < /のxsd：element>の<のxsd：要素名= \"ユニオン\" タイプ= \"structType\" /> <XSD：要素名= \"エイリアス\" タイプ= \"typeRefNMTOKEN\" /> </のxsd：選択> </のxsd：グループ> < XSD：単純型名= \"typeRefNMTOKEN\"> <XSD：制限基地= \"XSD：トークン\"> <XSD：パターン値= \"\\ C +\" /> <XSD：パターン値= \"文字列\\ [\\ D + \\]\" /> <XSD：パターン値= \"バイトの\\ [\\ D + \\]\" /> <XSD：パターン値= \"OctetStringには\\ [\\ D + \\]\" /> </ XSD：制限> </のxsd：simpleTypeの>"
    },
    {
      "indent": 3,
      "text": "<xsd:complexType name=\"atomicType\"> <xsd:sequence> <xsd:element name=\"baseType\" type=\"typeRefNMTOKEN\"/> <xsd:element name=\"rangeRestriction\" type=\"rangeRestrictionType\" minOccurs=\"0\"/> <xsd:element name=\"specialValues\" type=\"specialValuesType\" minOccurs=\"0\"> <!-- Extension RFC 7408 --> <xsd:key name=\"SpecialValue\"> <xsd:selector xpath=\"specialValue\"/> <xsd:field xpath=\"@value\"/> </xsd:key> <!-- /Extension RFC 7408 --> </xsd:element> </xsd:sequence> </xsd:complexType> <xsd:complexType name=\"rangeRestrictionType\"> <xsd:sequence> <xsd:element name=\"allowedRange\" maxOccurs=\"unbounded\"> <xsd:complexType> <xsd:attribute name=\"min\" type=\"xsd:integer\" use=\"required\"/> <xsd:attribute name=\"max\" type=\"xsd:integer\" use=\"required\"/> </xsd:complexType> </xsd:element> </xsd:sequence> </xsd:complexType> <xsd:complexType name=\"specialValuesType\"> <xsd:sequence> <xsd:element name=\"specialValue\" maxOccurs=\"unbounded\"> <xsd:complexType> <xsd:sequence> <xsd:element name=\"name\" type=\"xsd:NMTOKEN\"/> <xsd:element ref=\"synopsis\"/> </xsd:sequence> <xsd:attribute name=\"value\" type=\"xsd:token\"/> </xsd:complexType> </xsd:element> </xsd:sequence> </xsd:complexType> <xsd:complexType name=\"arrayType\"> <xsd:sequence> <xsd:group ref=\"typeDeclarationGroup\"/> <xsd:element name=\"contentKey\" minOccurs=\"0\" maxOccurs=\"unbounded\"> <xsd:complexType> <xsd:sequence>",
      "ja": "<XSD：complexTypeの名= \"atomicType\"> <XSD：配列> <XSD：要素名= \"baseType\" タイプ= \"typeRefNMTOKEN\" /> <XSD：要素名= \"rangeRestriction\" タイプ= \"rangeRestrictionType\" のminOccurs = \"0\" /> <XSD：要素名= \"specialValues\" タイプ= \"specialValuesType\" のminOccurs = \"0\"> < - 拡張RFC 7408  - > <のxsd：！キー名= \"SpecialValue\"> <のxsd：セレクタのxpath = \"specialValue \"/> <XSD：フィールドのxpath =\" @値 \"/> </のxsd：！キー> < -  /拡張RFC 7408  - > </のxsd：element>の</のxsd：sequence>を</のxsd：complexTypeの> <XSD：complexTypeの名前= \"rangeRestrictionType\"> <XSD：配列> <XSD：要素名= \"allowedRange\" のmaxOccurs = \"無制限\"> <のxsd：complexTypeの> <XSD：属性名= \"MIN\" タイプ= \"XSD：整数マックス」タイプ= \"のxsd：整数\" 使用= \"必須\" /> </のxsd：：必要な \"属性名= /> <XSD\" \"=を使用\" のcomplexType> </のxsd：element>の</のxsd：sequence>を< / XSD：のcomplexType> <のxsd：complexTypeの名前= \"specialValuesType\"> <XSD：配列> <XSD：要素名= \"specialValue\" のmaxOccurs = \"無制限\"> <のxsd：complexTypeの> <XSD：配列> <XSD：要素名= \"名前\" タイプ= \"のxsd：NMTOKEN\" /> <XSD：エルement REF = \"あらすじ\" /> </のxsd：sequence>を<XSD：属性名= \"値\" タイプ= \"のxsd：トークン\" /> </のxsd：complexTypeの> </のxsd：element>の</のxsd：シーケンス> </ XSD：のcomplexType> <のxsd：complexTypeの名前= \"のarrayType\"> <XSD：配列> <XSD：グループREF = \"typeDeclarationGroup\" /> <XSD：要素名= \"コンテンツ鍵\" のminOccurs = \"0\" のmaxOccurs = \"無限「> <のxsd：complexTypeの> <のxsd：シーケンス>"
    },
    {
      "indent": 3,
      "text": " <xsd:element name=\"contentKeyField\" type=\"xsd:string\" maxOccurs=\"unbounded\"/> </xsd:sequence> <xsd:attribute name=\"contentKeyID\" type=\"xsd:integer\" use=\"required\"/> </xsd:complexType> </xsd:element> </xsd:sequence> <xsd:attribute name=\"type\" use=\"optional\" default=\"variable-size\"> <xsd:simpleType> <xsd:restriction base=\"xsd:string\"> <xsd:enumeration value=\"fixed-size\"/> <xsd:enumeration value=\"variable-size\"/> </xsd:restriction> </xsd:simpleType> </xsd:attribute> <xsd:attribute name=\"length\" type=\"xsd:integer\" use=\"optional\"/> <xsd:attribute name=\"maxLength\" type=\"xsd:integer\" use=\"optional\"/> </xsd:complexType> <xsd:complexType name=\"structType\"> <xsd:sequence> <xsd:element name=\"derivedFrom\" type=\"typeRefNMTOKEN\" minOccurs=\"0\"/> <xsd:element name=\"component\" maxOccurs=\"unbounded\"> <xsd:complexType> <xsd:sequence> <xsd:element name=\"name\" type=\"xsd:NMTOKEN\"/> <xsd:element ref=\"synopsis\"/> <xsd:element ref=\"description\" minOccurs=\"0\"/> <xsd:element name=\"optional\" minOccurs=\"0\"/> <xsd:group ref=\"typeDeclarationGroup\"/> </xsd:sequence> <!-- Extension RFC 7408 --> <xsd:attribute name=\"access\" use=\"optional\" default=\"read-write\"> <xsd:simpleType> <xsd:list itemType=\"accessModeType\"/> </xsd:simpleType> </xsd:attribute> <!-- Extension RFC 7408 --> <xsd:attribute name=\"componentID\" type=\"xsd:unsignedInt\" use=\"required\"/> </xsd:complexType> </xsd:element> </xsd:sequence>",
      "ja": "ます。<xsd：要素名= \"contentKeyField\" タイプ= \"のxsd：文字列\" のmaxOccurs = \"無制限\" /> </のxsd：sequence>を<のxsd：属性名= \"contentKeyID\" タイプ= \"のxsd：整数\" 使用= \"必要\" /> </のxsd：complexTypeの> </のxsd：element>の</のxsd：sequence>を<のxsd：属性名= \"タイプ\" 使用= \"オプションの\" デフォルト= \"可変サイズ\"> <のxsd：simpleTypeの> <のxsd：制限ベース= \"XSD：文字列\"> <XSD：列挙値= \"固定サイズ\" /> <XSD：列挙値= \"可変サイズ\" /> </ XSD：制限> </のxsd：simpleTypeの> </ XSD ：属性> <XSD：属性名= \"長さ\" タイプ= \"XSD：整数\" 使用= \"オプション\" /> <XSD：属性名= \"maxLengthの\" タイプ= \"XSD：整数\" 使用= \"オプション\" /> < / XSD：のcomplexType> <のxsd：complexTypeの名前= \"structType\"> <XSD：配列> <XSD：要素名= \"derivedFrom\" タイプ= \"typeRefNMTOKEN\" のminOccurs = \"0\" /> <XSD：要素名= \"コンポーネント\" maxOccurs = \"無制限\"> <のxsd：complexTypeの> <のxsd：sequence>を<のxsd：要素名= \"名前\" タイプ= \"のxsd：NMTOKEN\" /> <XSD：要素REF = \"あらすじ\" /> <XSD：要素の参照= \"説明\" のminOccurs = \"0\" /> <XSD：要素名= \"任意\" のminOccurs = \"0\" /> <XSD。グループREF = \"typeDeclarationGroup\" /> </のxsd：sequence>を< - 拡張RFC 7408  - > <のxsd：！属性名= \"アクセス\" 使用= \"オプションの\" デフォルト= \"読み書き\"> <XSD：単純> <XSD：リストitemTypeに= \"accessModeType\" /> </のxsd：simpleTypeの> </のxsd：！属性> < - 拡張RFC 7408  - > <XSD：属性名= \"COMPONENTID\" タイプ= \"のxsd：unsignedInt型\"使用= \"必要\" /> </のxsd：complexTypeの> </のxsd：element>の</のxsd：シーケンス>"
    },
    {
      "indent": 3,
      "text": "</xsd:complexType> <xsd:complexType name=\"metadataDefsType\"> <xsd:sequence> <xsd:element name=\"metadataDef\" maxOccurs=\"unbounded\"> <xsd:complexType> <xsd:sequence> <xsd:element name=\"name\" type=\"xsd:NMTOKEN\"/> <xsd:element ref=\"synopsis\"/> <xsd:element name=\"metadataID\" type=\"xsd:integer\"/> <xsd:element ref=\"description\" minOccurs=\"0\"/> <xsd:choice> <xsd:element name=\"typeRef\" type=\"typeRefNMTOKEN\"/> <xsd:element name=\"atomic\" type=\"atomicType\"/> <!-- Extension RFC 7408 --> <xsd:element name=\"array\" type=\"arrayType\"> <!--declare keys to have unique IDs --> <xsd:key name=\"contentKeyID1\"> <xsd:selector xpath=\"lfb:contentKey\"/> <xsd:field xpath=\"@contentKeyID\"/> </xsd:key> <!-- /Extension RFC 7408 --> </xsd:element> <xsd:element name=\"struct\" type=\"structType\"> <!-- Extension RFC 7408 --> <!-- key declaration to make componentIDs unique in a struct --> <xsd:key name=\"structComponentID1\"> <xsd:selector xpath=\"lfb:component\"/> <xsd:field xpath=\"@componentID\"/> </xsd:key> <!-- /Extension RFC 7408 --> </xsd:element> </xsd:choice> </xsd:sequence> </xsd:complexType> </xsd:element> </xsd:sequence> </xsd:complexType> <xsd:complexType name=\"LFBClassDefsType\"> <xsd:sequence> <xsd:element name=\"LFBClassDef\" maxOccurs=\"unbounded\"> <xsd:complexType> <xsd:sequence> <xsd:element name=\"name\" type=\"xsd:NMTOKEN\"/> <xsd:element ref=\"synopsis\"/> <xsd:element name=\"version\" type=\"versionType\"/> <xsd:element name=\"derivedFrom\" minOccurs=\"0\">",
      "ja": "</ XSD：のcomplexType> <のxsd：complexTypeの名前= \"metadataDefsType\"> <XSD：配列> <XSD：要素名= \"metadataDef\" のmaxOccurs = \"無制限\"> <のxsd：complexTypeの> <XSD：配列> <XSD：要素NAME = \"名前\" タイプ= \"のxsd：NMTOKEN\" /> <XSD：要素REF = \"概要\" /> <XSD：要素名= \"metadataID\" タイプ= \"XSD：整数\" /> <XSD：要素REF =」説明」のminOccurs = \"0\" /> <XSD：選択>ます。<xsd：要素名= \"typeRef\" タイプ= \"typeRefNMTOKEN\" /> <XSD：要素名= \"アトミック\" タイプ= \"atomicType\" /> <！ - 拡張RFC 7408  - > <XSD：要素名は= \"アレイ\" タイプ= \"のarrayType\"> < - 固有のIDを持つようにキーを宣言 - > <のxsd：！キー名= \"contentKeyID1\"> <XSD：セレクタのxpath = \"LFB：コンテンツ鍵\" /> <XSD：フィールドのxpath = \"contentKeyID @\" /> </のxsd：！キー> < -  /拡張RFC 7408  - > </のxsd：element>の<のxsd：要素名= \"構造体\"タイプ=\" structType \"> < - 拡張RFC 7408  - > < - 構造体にcomponentIDsを一意にするためのキー宣言 - > <のxsd：！キー名=\" structComponentID1 \"> <のxsd：セレクタのxpath =\" LFB：コンポーネント \"/> <XSD：フィールドのxpath =\" @のCOMPONENTID \"/> </のxsd：キー> < -  /拡張RFC！ 7408  - > </のxsd：element>の</のxsd：選択> </のxsd：sequence>を</のxsd：complexTypeの> </のxsd：element>の</のxsd：sequence>を</のxsd：complexTypeの> <のxsd：complexTypeの名前= \"LFBClassDefsType\"> <のxsd：sequence>を<XSD：要素名= \"LFBClassDef\" のmaxOccurs = \"無制限\"> <のxsd：complexTypeの> <のxsd：sequence>を<XSD：要素名= \"名前\" タイプ= \"のxsd： NMTOKEN \"/> <XSD：要素REF =\" 概要 \"/> <XSD：要素名=\" バージョン」タイプ= \"versionType\" /> <XSD：要素名= \"derivedFrom\" のminOccurs = \"0\">"
    },
    {
      "indent": 12,
      "text": "        <xsd:complexType>\n          <xsd:simpleContent>\n            <xsd:extension base=\"xsd:NMTOKEN\">\n              <xsd:attribute name=\"version\"\n                type=\"versionType\" use=\"optional\"/>\n            </xsd:extension>\n          </xsd:simpleContent>\n        </xsd:complexType>\n      </xsd:element>\n      <xsd:element name=\"inputPorts\"\n       type=\"inputPortsType\" minOccurs=\"0\"/>\n      <xsd:element name=\"outputPorts\"\n       type=\"outputPortsType\" minOccurs=\"0\"/>\n      <xsd:element name=\"components\"\n       type=\"LFBComponentsType\" minOccurs=\"0\"/>\n      <xsd:element name=\"capabilities\"\n       type=\"LFBCapabilitiesType\" minOccurs=\"0\"/>\n      <xsd:element name=\"events\" type=\"eventsType\"\n         minOccurs=\"0\"/>\n      <xsd:element ref=\"description\"\n         minOccurs=\"0\"/>\n   </xsd:sequence>\n   <xsd:attribute name=\"LFBClassID\" type=\"xsd:unsignedInt\"\n      use=\"required\"/>\n</xsd:complexType>\n<!-- Key constraint to ensure unique attribute names\nwithin a class: -->\n<xsd:key name=\"components\">\n   <xsd:selector xpath=\"lfb:components/lfb:component\"/>\n   <xsd:field xpath=\"lfb:name\"/>\n</xsd:key>\n<xsd:key name=\"capabilities\">\n   <xsd:selector xpath=\"lfb:capabilities/lfb:capability\"/>\n   <xsd:field xpath=\"lfb:name\"/>\n</xsd:key>\n<xsd:key name=\"events\">\n   <xsd:selector xpath=\"lfb:events/lfb:event\"/>\n   <xsd:field xpath=\"lfb:name\"/>\n</xsd:key>\n<xsd:key name=\"eventsIDs\">\n   <xsd:selector xpath=\"lfb:events/lfb:event\"/>\n   <xsd:field xpath=\"@eventID\"/>\n</xsd:key>\n<xsd:key name=\"componentIDs\">\n   <xsd:selector xpath=\"lfb:components/lfb:component\"/>\n   <xsd:field xpath=\"@componentID\"/>\n</xsd:key>\n<xsd:key name=\"capabilityIDs\">",
      "raw": true
    },
    {
      "indent": 3,
      "text": " <xsd:selector xpath=\"lfb:capabilities/lfb:capability\"/> <xsd:field xpath=\"@componentID\"/> </xsd:key> <xsd:key name=\"ComponentCapabilityComponentIDUniqueness\"> <xsd:selector xpath=\"lfb:components/lfb:component| lfb:capabilities/lfb:capability|lfb:events\"/> <xsd:field xpath=\"@componentID|@baseID\"/> </xsd:key> </xsd:element> </xsd:sequence> </xsd:complexType> <xsd:simpleType name=\"versionType\"> <xsd:restriction base=\"xsd:NMTOKEN\"> <xsd:pattern value=\"[1-9][0-9]*\\.([1-9][0-9]*|0)\"/> </xsd:restriction> </xsd:simpleType> <xsd:complexType name=\"inputPortsType\"> <xsd:sequence> <xsd:element name=\"inputPort\" type=\"inputPortType\" maxOccurs=\"unbounded\"/> </xsd:sequence> </xsd:complexType> <xsd:complexType name=\"inputPortType\"> <xsd:sequence> <xsd:element name=\"name\" type=\"xsd:NMTOKEN\"/> <xsd:element ref=\"synopsis\"/> <xsd:element name=\"expectation\" type=\"portExpectationType\"/> <xsd:element ref=\"description\" minOccurs=\"0\"/> </xsd:sequence> <xsd:attribute name=\"group\" type=\"xsd:boolean\" use=\"optional\" default=\"0\"/> </xsd:complexType> <xsd:complexType name=\"portExpectationType\"> <xsd:sequence> <xsd:element name=\"frameExpected\" minOccurs=\"0\"> <xsd:complexType> <xsd:sequence> <!-- ref must refer to a name of a defined frame type --> <xsd:element name=\"ref\" type=\"xsd:string\" maxOccurs=\"unbounded\"/> </xsd:sequence> </xsd:complexType> </xsd:element> <xsd:element name=\"metadataExpected\" minOccurs=\"0\"> <xsd:complexType> <xsd:choice maxOccurs=\"unbounded\">",
      "ja": "ます。<xsd：セレクタのxpath = \"LFB：機能/ LFB：機能\" /> <XSD：フィールドのxpath = \"@ COMPONENTID\" /> </のxsd：キー>ます。<xsd：キー名= \"ComponentCapabilityComponentIDUniqueness\"> <XSD：セレクタのXPath = \"LFB：コンポーネント/ LFB：コンポーネント| LFB：機能/ LFB：機能| LFB：イベント\" /> <XSD：フィールドのxpath = \"@ COMPONENTID | @baseID\" /> </のxsd：キー> </のxsd：要素> </ XSD：配列> </のxsd：complexTypeの> <のxsd：simpleTypeの名前= \"versionType\"> <XSD：制限基地= \"のxsd：NMTOKEN\"> <XSD：パターン値= \"[1-9] [0- 9] * \\（[1-9] [0-9] * | 0）。 \"/> </ XSD：制限> </のxsd：simpleTypeの> <XSD：complexTypeの名=\" inputPortsType \"> <XSD：配列> <XSD：要素名= \"inputPort\" タイプ= \"inputPortType\" のmaxOccurs = \"無制限\" /> </ XSD：配列> </のxsd：complexTypeの> <XSD：complexTypeの名= \"inputPortType\"> <XSD：配列> <XSD ：要素名= \"名前\" タイプ= \"のxsd：NMTOKEN\" /> <XSD：要素REF = \"概要\" /> <XSD：要素名= \"期待\" タイプ= \"portExpectationType\" /> <XSD：要素REF =」説明 \"のminOccurs = \"0\"/> </ XSD：配列> <XSD：属性名= \"グループ\" タイプ= \"XSD：ブール\" 使用=\" オプション\"デフォルト=\" 0 \"/> </のxsd：complexTypeの> <XSD：complexTypeの名=\" portExpectationType \"> <のxsd：sequence>を<のxsd：要素名=\" frameExpected」のminOccurs = \"0\"> <のxsd：complexTypeの> < xsd：sequence>を< -  refの定義されたフレームタイプの名前を参照する必要があります - > <のxsd：！要素名= \"参照\" タイプ= \"のxsd：文字列\" のmaxOccurs = \"無制限\" /> </のxsd：シーケンス> </のxsd：complexTypeの> </のxsd：element>の<のxsd：要素名= \"metadataExpected\" のminOccurs = \"0\"> <のxsd：complexTypeの> <のxsd：選択肢のmaxOccurs = \"無制限\">"
    },
    {
      "indent": 3,
      "text": " <!--ref must refer to a name of a defined metadata--> <xsd:element name=\"ref\" type=\"metadataInputRefType\"/> <xsd:element name=\"one-of\" type=\"metadataInputChoiceType\"/> </xsd:choice> </xsd:complexType> </xsd:element> </xsd:sequence> </xsd:complexType> <xsd:complexType name=\"metadataInputChoiceType\"> <xsd:choice minOccurs=\"2\" maxOccurs=\"unbounded\"> <!-- ref must refer to a name of a defined metadata --> <xsd:element name=\"ref\" type=\"xsd:NMTOKEN\"/> <xsd:element name=\"one-of\" type=\"metadataInputChoiceType\"/> <xsd:element name=\"metadataSet\" type=\"metadataInputSetType\"/> </xsd:choice> </xsd:complexType> <xsd:complexType name=\"metadataInputSetType\"> <xsd:choice minOccurs=\"2\" maxOccurs=\"unbounded\"> <!-- ref must refer to a name of a defined metadata --> <xsd:element name=\"ref\" type=\"metadataInputRefType\"/> <xsd:element name=\"one-of\" type=\"metadataInputChoiceType\"/> </xsd:choice> </xsd:complexType> <xsd:complexType name=\"metadataInputRefType\"> <xsd:simpleContent> <xsd:extension base=\"xsd:NMTOKEN\"> <xsd:attribute name=\"dependency\" use=\"optional\" default=\"required\"> <xsd:simpleType> <xsd:restriction base=\"xsd:string\"> <xsd:enumeration value=\"required\"/> <xsd:enumeration value=\"optional\"/> </xsd:restriction> </xsd:simpleType> </xsd:attribute> <xsd:attribute name=\"defaultValue\" type=\"xsd:token\" use=\"optional\"/> </xsd:extension> </xsd:simpleContent> </xsd:complexType> <xsd:complexType name=\"outputPortsType\"> <xsd:sequence> <xsd:element name=\"outputPort\" type=\"outputPortType\" maxOccurs=\"unbounded\"/> </xsd:sequence> </xsd:complexType> <xsd:complexType name=\"outputPortType\">",
      "ja": "< -  REF定義されたメタデータの名前を参照する必要があります - > <！のxsd：要素名= \"参照\" タイプは、= \"metadataInputRefType\" /> <XSD：要素名= \"1-の\" タイプ= \"metadataInputChoiceType\" / > </のxsd：選択> </のxsd：complexTypeの> </のxsd：element>の</のxsd：sequence>を</のxsd：complexTypeの> <XSD：complexTypeの名= \"metadataInputChoiceType\"> <のxsd：選択肢のminOccurs = \"2\" maxOccurs = \"無制限\"> < -  refは定義されたメタデータの名前を参照する必要があります - > <のxsd：！要素名= \"参照\" タイプ= \"のxsd：NMTOKEN\" /> <XSD：要素名= \"ワン「タイプ= \"metadataInputChoiceTypeの\" /> <XSD：要素名= \"metadataSet\" タイプ= \"metadataInputSetType\" /> </のxsd：選択> </のxsd：complexTypeの> <XSD：complexTypeの名= \"metadataInputSetType\"> <XSD： ！要素名= \"参照\" タイプ= \"metadataInputRefType\" /> <のxsd：要素名選択のminOccurs = \"2\" のmaxOccurs = \"無制限\"> < - > <XSD  -  refは定義されたメタデータの名前を参照する必要があります=タイプ= \"metadataInputChoiceType\" /> </ XSD \"のワン\"：選択> </のxsd：complexTypeの> <XSD：complexTypeの名= \"metadataInputRefType\"> <のxsd：simpleContentを> <XSD：増設ベース= \"のxsd：NMTOKE N \"> <XSD：属性名=\" 依存」使用= \"オプションの\" デフォルト= \"必要\"> <のxsd：simpleTypeの> <XSD：制限ベース= \"のxsd：文字列\"> <XSD：列挙値= \"\" 必須/ > <XSD：列挙値= \"オプション\" /> </ XSD：制限> </のxsd：simpleTypeの> </ XSD：属性> <XSD：属性名= \"はdefaultValue\" タイプ= \"XSD：トークンが\" =」オプションを使用し\"/> </ XSD：拡張> </ XSD：simpleContentを> </のxsd：complexTypeの> <のxsd：complexTypeの名前=\" outputPortsType \"> <XSD：配列> <XSD：要素名=\" 出力ポート」タイプ= \"outputPortType\" maxOccurs = \"無制限\" /> </のxsd：sequence>を</のxsd：complexTypeの> <XSD：complexTypeの名= \"outputPortType\">"
    },
    {
      "indent": 3,
      "text": " <xsd:sequence> <xsd:element name=\"name\" type=\"xsd:NMTOKEN\"/> <xsd:element ref=\"synopsis\"/> <xsd:element name=\"product\" type=\"portProductType\"/> <xsd:element ref=\"description\" minOccurs=\"0\"/> </xsd:sequence> <xsd:attribute name=\"group\" type=\"xsd:boolean\" use=\"optional\" default=\"0\"/> </xsd:complexType> <xsd:complexType name=\"portProductType\"> <xsd:sequence> <xsd:element name=\"frameProduced\" minOccurs=\"0\"> <xsd:complexType> <xsd:sequence> <!-- ref must refer to a name of a defined frame type --> <xsd:element name=\"ref\" type=\"xsd:NMTOKEN\" maxOccurs=\"unbounded\"/> </xsd:sequence> </xsd:complexType> </xsd:element> <xsd:element name=\"metadataProduced\" minOccurs=\"0\"> <xsd:complexType> <xsd:choice maxOccurs=\"unbounded\"> <!-- ref must refer to a name of a defined metadata --> <xsd:element name=\"ref\" type=\"metadataOutputRefType\"/> <xsd:element name=\"one-of\" type=\"metadataOutputChoiceType\"/> </xsd:choice> </xsd:complexType> </xsd:element> </xsd:sequence> </xsd:complexType> <xsd:complexType name=\"metadataOutputChoiceType\"> <xsd:choice minOccurs=\"2\" maxOccurs=\"unbounded\"> <!-- ref must refer to a name of a defined metadata --> <xsd:element name=\"ref\" type=\"xsd:NMTOKEN\"/> <xsd:element name=\"one-of\" type=\"metadataOutputChoiceType\"/> <xsd:element name=\"metadataSet\" type=\"metadataOutputSetType\"/> </xsd:choice> </xsd:complexType> <xsd:complexType name=\"metadataOutputSetType\"> <xsd:choice minOccurs=\"2\" maxOccurs=\"unbounded\"> <!-- ref must refer to a name of a defined metadata --> <xsd:element name=\"ref\" type=\"metadataOutputRefType\"/> <xsd:element name=\"one-of\" type=\"metadataOutputChoiceType\"/>",
      "ja": "<XSD：配列> <XSD：要素名= \"名前\" タイプ= \"のxsd：NMTOKEN\" /> <XSD：要素REF = \"概要\" /> <XSD：要素名= \"製品\" タイプ= \"portProductType\" />ます。<xsd：要素REF = \"説明\" のminOccurs = \"0\" /> </のxsd：sequence>を<のxsd：属性名= \"グループ\" タイプ= \"のxsd：boolean型\" の使用は= \"オプションの\" デフォルト= \"0\" /> </ XSD：complexTypeの> <のxsd：complexTypeの名前= \"portProductType\"> <のxsd：sequence>を<XSD：要素名= \"frameProduced\" のminOccurs = \"0\"> <のxsd：complexTypeの> <！のxsd：sequence>を< - REFは、定義されたフレームタイプの名前を参照しなければならない - > <XSD：要素名= \"REF\" タイプ= \"のxsd：NMTOKEN\" のmaxOccurs = \"無制限\" /> </ XSD：配列> </のxsd：complexTypeの> < /のxsd：element>の<のxsd：要素名= \"metadataProduced\" のminOccurs = \"0\"> <のxsd：complexTypeの> <のxsd：！選択肢のmaxOccurs = \"無制限\"> < -  refは定義されたメタデータの名前を参照する必要があります -  - > <のxsd：選択> </のxsd：complexTypeの> </要素名= \"参照\" タイプ= \"metadataOutputRefType\" /> <XSD：=タイプ= \"metadataOutputChoiceType\" /> </ XSD \"ワンの\" 要素名xsd：element>の</のxsd：sequence>を</のxsd：complexTypeの> <XSD：complexTypeの名= \"私tadataOutputChoiceType \"> <のxsd：選択肢のminOccurs =\" 2\" のmaxOccurs = \"無制限\"> < -  refは定義されたメタデータの名前を参照する必要があります - > <のxsd：！要素名= \"参照\" タイプ= \"のxsd：NMTOKEN \"/> <XSD：要素名=\" 1-の」タイプ= \"metadataOutputChoiceType\" /> <XSD：要素名= \"metadataSet\" タイプ= \"metadataOutputSetType\" /> </のxsd：選択> </のxsd：complexTypeの> < xsd：complexTypeの名前= \"metadataOutputSetType\"> <のxsd：選択肢のminOccurs = \"2\" のmaxOccurs = \"無制限\"> < -  refは定義されたメタデータの名前を参照する必要があります - > <のxsd：！要素名= \"REFを\"タイプ= \"metadataOutputRefType\" /> <XSD：要素名= \"1-の\" タイプ= \"metadataOutputChoiceType\" />"
    },
    {
      "indent": 3,
      "text": " </xsd:choice> </xsd:complexType> <xsd:complexType name=\"metadataOutputRefType\"> <xsd:simpleContent> <xsd:extension base=\"xsd:NMTOKEN\"> <xsd:attribute name=\"availability\" use=\"optional\" default=\"unconditional\"> <xsd:simpleType> <xsd:restriction base=\"xsd:string\"> <xsd:enumeration value=\"unconditional\"/> <xsd:enumeration value=\"conditional\"/> </xsd:restriction> </xsd:simpleType> </xsd:attribute> </xsd:extension> </xsd:simpleContent> </xsd:complexType> <xsd:complexType name=\"LFBComponentsType\"> <xsd:sequence> <xsd:element name=\"component\" maxOccurs=\"unbounded\"> <xsd:complexType> <xsd:sequence> <xsd:element name=\"name\" type=\"xsd:NMTOKEN\"/> <xsd:element ref=\"synopsis\"/> <xsd:element ref=\"description\" minOccurs=\"0\"/> <xsd:element name=\"optional\" minOccurs=\"0\"/> <xsd:group ref=\"typeDeclarationGroup\"/> <xsd:element name=\"defaultValue\" type=\"xsd:token\" minOccurs=\"0\"/> </xsd:sequence> <xsd:attribute name=\"access\" use=\"optional\" default=\"read-write\"> <xsd:simpleType> <xsd:list itemType=\"accessModeType\"/> </xsd:simpleType> </xsd:attribute> <!-- Extension added restriction to componentID --> <xsd:attribute name=\"componentID\" use=\"required\"> <xsd:simpleType> <xsd:restriction base=\"xsd:unsignedInt\"> <xsd:minExclusive value=\"0\"/> </xsd:restriction> </xsd:simpleType> </xsd:attribute> <!-- End of extension --> </xsd:complexType> </xsd:element>",
      "ja": "</ XSD：選択> </のxsd：complexTypeの> <のxsd：complexTypeの名前= \"metadataOutputRefType\"> <のxsd：simpleContentを> <XSD：増設ベース= \"のxsd：NMTOKEN\"> <XSD：属性名= \"可用性\" 使用= \"任意\" デフォルト= \"無条件\"> <のxsd：simpleTypeの> <XSD：制限基地= \"XSD：文字列\"> <XSD：列挙値= \"無条件\" /> <XSD：列挙値= \"条件\" /> </ xsd：制限> </のxsd：simpleTypeの> </のxsd：属性> </ XSD：拡張> </のxsd：simpleContentを> </のxsd：complexTypeの> <XSD：complexTypeの名= \"LFBComponentsType\"> <のxsd：sequence>を< XSD：要素名= \"コンポーネント\" のmaxOccurs = \"無制限\"> <のxsd：complexTypeの> <XSD：配列> <XSD：要素名= \"名前\" タイプ= \"のxsd：NMTOKEN\" /> <XSD：要素REF = \"シノプシス\"/> <XSD：要素REF =\" 説明」のminOccurs = \"0\" /> <XSD：要素名= \"任意\" のminOccurs = \"0\" /> <XSD：グループREF = \"typeDeclarationGroup\" /> <XSD：要素名前= \"はdefaultValue\" タイプ= \"のxsd：トークン\" のminOccurs = \"0\" /> </のxsd：sequence>を<XSD：属性名= \"アクセス\" 使用= \"オプションの\" デフォルト= \"読み書き\"> <XSD：単純> <のxsd：リストitemTypeに= \"accessMod ETYPE \"/> </のxsd：simpleTypeの> </のxsd：！属性> < -  COMPONENTIDへの拡張を追加制限 - > <XSD：属性名=\" COMPONENTID」使用= \"必要\"> <のxsd：simpleTypeの> <XSD ：制限ベース= \"のxsd：unsignedInt型\"> <のxsd：minExclusiveの値= \"0\" /> </のxsd：制限> </のxsd：simpleTypeの> </のxsd：！属性> < - 拡張の終わり - > < / XSD：complexTypeの> </のxsd：element>の"
    },
    {
      "indent": 3,
      "text": " </xsd:sequence> </xsd:complexType> <xsd:simpleType name=\"accessModeType\"> <xsd:restriction base=\"xsd:NMTOKEN\"> <xsd:enumeration value=\"read-only\"/> <xsd:enumeration value=\"read-write\"/> <xsd:enumeration value=\"write-only\"/> <xsd:enumeration value=\"read-reset\"/> <xsd:enumeration value=\"trigger-only\"/> </xsd:restriction> </xsd:simpleType> <xsd:complexType name=\"LFBCapabilitiesType\"> <xsd:sequence> <xsd:element name=\"capability\" maxOccurs=\"unbounded\"> <xsd:complexType> <xsd:sequence> <xsd:element name=\"name\" type=\"xsd:NMTOKEN\"/> <xsd:element ref=\"synopsis\"/> <xsd:element ref=\"description\" minOccurs=\"0\"/> <xsd:element name=\"optional\" minOccurs=\"0\"/> <xsd:group ref=\"typeDeclarationGroup\"/> </xsd:sequence> <xsd:attribute name=\"componentID\" type=\"xsd:integer\" use=\"required\"/> </xsd:complexType> </xsd:element> </xsd:sequence> </xsd:complexType> <xsd:complexType name=\"eventsType\"> <xsd:sequence> <xsd:element name=\"event\" maxOccurs=\"unbounded\"> <xsd:complexType> <xsd:sequence> <xsd:element name=\"name\" type=\"xsd:NMTOKEN\"/> <xsd:element ref=\"synopsis\"/> <xsd:element name=\"eventTarget\" type=\"eventPathType\"/> <xsd:element ref=\"eventCondition\"/> <xsd:element name=\"eventReports\" type=\"eventReportsType\" minOccurs=\"0\"/> <xsd:element ref=\"description\" minOccurs=\"0\"/> </xsd:sequence> <xsd:attribute name=\"eventID\" type=\"xsd:integer\" use=\"required\"/> </xsd:complexType> </xsd:element>",
      "ja": "</ XSD：配列> </のxsd：complexTypeの> <のxsd：simpleTypeの名前= \"accessModeType\"> <XSD：制限基地= \"のxsd：NMTOKEN\"> <XSD：列挙値= \"読み取り専用\" /> <XSD。列挙値= \"読み書き\" /> <XSD：列挙値= \"書き込み専用\" /> <XSD：列挙値= \"読み取りリセット\" /> <XSD：列挙値= \"トリガーのみ\" /> < / XSD：制限> </のxsd：simpleTypeの> <XSD：complexTypeの名= \"LFBCapabilitiesType\"> <XSD：配列> <XSD：要素名= \"能力\" のmaxOccurs = \"無制限\"> <のxsd：complexTypeの> <XSD：配列> <XSD：要素名= \"名前\" タイプ= \"のxsd：NMTOKEN\" /> <XSD：要素REF = \"概要\" /> <XSD：要素REF = \"説明\" のminOccurs = \"0\" /> <XSD：要素名前= \"任意\" のminOccurs = \"0\" /> <XSD：グループREF = \"typeDeclarationGroup\" /> </ XSD：配列> <XSD：属性名= \"COMPONENTID\" タイプ= \"XSD：整数\" 使用= \"必要\" /> </のxsd：complexTypeの> </のxsd：element>の</のxsd：sequence>を</のxsd：complexTypeの> <のxsd：complexTypeの名前= \"eventsType\"> <のxsd：sequence>を<XSD：要素名= \"イベント\" maxOccurs = \"無制限\"> <のxsd：complexTypeの> <のxsd：sequence>を<XSD：要素名= \"名前\" タイプ= \"のxsd：NMTOKEN\" /> <XSD：要素REF = \"概要\" /> <XSD：要素名= \"のEventTarget\" タイプ= \"eventPathType\" /> <XSD：要素REF = \"eventCondition\" /> <XSD：要素名= \"eventReports\" タイプ= \"eventReportsType\" のminOccurs = \"0\" /> <XSD：要素REF = \"説明\" のminOccurs = \"0\" /> </ XSD：配列> <XSD：属性名=」 eventID」タイプ= \"XSD：整数\" 使用= \"必須\" /> </のxsd：complexTypeの> </ XSD：要素>"
    },
    {
      "indent": 0,
      "text": " </xsd:sequence> <xsd:attribute name=\"baseID\" type=\"xsd:integer\" use=\"optional\"/> </xsd:complexType> <!-- the substitution group for the event conditions --> <xsd:element name=\"eventCondition\" abstract=\"true\"/> <xsd:element name=\"eventCreated\" substitutionGroup=\"eventCondition\"/> <xsd:element name=\"eventDeleted\" substitutionGroup=\"eventCondition\"/> <xsd:element name=\"eventChanged\" substitutionGroup=\"eventCondition\"/> <xsd:element name=\"eventGreaterThan\" substitutionGroup=\"eventCondition\"/> <xsd:element name=\"eventLessThan\" substitutionGroup=\"eventCondition\"/> <!-- Extension RFC 7408 --> <xsd:element name=\"eventBecomesEqualTo\" substitutionGroup=\"eventCondition\"/> <!-- /Extension RFC 7408 --> <xsd:complexType name=\"eventPathType\"> <xsd:sequence> <xsd:element ref=\"eventPathPart\" maxOccurs=\"unbounded\"/> </xsd:sequence> </xsd:complexType> <!-- the substitution group for the event path parts --> <xsd:element name=\"eventPathPart\" type=\"xsd:string\" abstract=\"true\"/> <xsd:element name=\"eventField\" type=\"xsd:string\" substitutionGroup=\"eventPathPart\"/> <xsd:element name=\"eventSubscript\" type=\"xsd:string\" substitutionGroup=\"eventPathPart\"/> <xsd:complexType name=\"eventReportsType\"> <xsd:sequence> <xsd:element name=\"eventReport\" type=\"eventPathType\" maxOccurs=\"unbounded\"/> </xsd:sequence> </xsd:complexType> <xsd:simpleType name=\"booleanType\"> <xsd:restriction base=\"xsd:string\"> <xsd:enumeration value=\"0\"/> <xsd:enumeration value=\"1\"/> </xsd:restriction> </xsd:simpleType> </xsd:schema>",
      "ja": "</ XSD：シーケンス> <のxsd：属性名= \"baseID\" タイプ= \"のxsd：整数\" 使用= \"オプション\" /> </のxsd：complexTypeの> <！ - イベント条件の置換グループ - > < XSD：要素名= \"eventCondition\" 抽象= \"真\" /> <XSD：要素名= \"eventCreated\" のsubstitutionGroup = \"eventCondition\" /> <XSD：要素名= \"eventDeleted\" のsubstitutionGroup = \"eventCondition\" /> <XSD：要素名= \"eventChanged\" のsubstitutionGroup = \"eventCondition\" /> <XSD：要素名= \"eventGreaterThan\" のsubstitutionGroup = \"eventCondition\" /> <のxsd：！要素名= \"eventLessThan\" のsubstitutionGroup = \"eventCondition\" /> < - 拡張RFC 7408  - > <XSD：要素名= \"eventBecomesEqualTo\" のsubstitutionGroup = \"eventCondition\" /> < -  /拡張RFC 7408  - > <のxsd：！complexTypeの名= \"eventPathType\"> <のxsd：sequence>を<のxsd：要素REF = \"eventPathPart\" のmaxOccurs = \"無制限\" /> </のxsd：sequence>を</のxsd：complexTypeの> < - 置換グループイベントパス部品用 - > <のxsd：！要素名= \"eventPathPart\" タイプ= \"XSD：文字列\" 抽象= \"真\" /> <XSD：要素名= \"eventFiel D」タイプ= \"のxsd：文字列\" のsubstitutionGroup = \"eventPathPart\" /> <XSD：要素名= \"eventSubscript\" タイプ= \"のxsd：文字列\" のsubstitutionGroup = \"eventPathPart\" /> <XSD：complexTypeの名= \"eventReportsType\"> < xsd：sequence>を<XSD：要素名= \"eventReport\" タイプ= \"eventPathType\" のmaxOccurs = \"無制限\" /> </のxsd：sequence>を</のxsd：complexTypeの> <XSD：単純型名= \"booleanType\"> <XSD：制限ベース= \"XSD：文字列\"> <XSD：列挙値= \"0\" /> <XSD：列挙値= \"1\" /> </ XSD：制限> </のxsd：simpleTypeの> </ XSD：スキーマ>"
    },
    {
      "indent": 27,
      "text": "ForCES LFB XML Schema",
      "ja": "ForCES LFB XMLスキーマ"
    },
    {
      "indent": 0,
      "text": "4. IANA Considerations",
      "section_title": true,
      "ja": "4. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "IANA has registered a new XML namespace, as per the guidelines in RFC 3688 [RFC3688].",
      "ja": "IANAはRFC 3688 [RFC3688]のガイドラインに従って、新しいXML名前空間を登録しています。"
    },
    {
      "indent": 3,
      "text": "URI: The URI for this namespace is:",
      "ja": "URI：この名前空間のURIは以下のとおりです。"
    },
    {
      "indent": 6,
      "text": "urn:ietf:params:xml:ns:forces:lfbmodel:1.1",
      "ja": "URN：IETF：のparams：XML：NS：力：lfbmodel：1.1"
    },
    {
      "indent": 3,
      "text": "Registrant Contact: IESG",
      "ja": "登録者連絡先：IESG"
    },
    {
      "indent": 3,
      "text": "XML: none, this is an XML namespace",
      "ja": "XML：どれも、これはXML名前空間ではありません"
    },
    {
      "indent": 0,
      "text": "5. Security Considerations",
      "section_title": true,
      "ja": "5.セキュリティについての考慮事項"
    },
    {
      "indent": 3,
      "text": "This specification adds only a few constructs to the initial model defined in [RFC5812], namely, a new event, some new properties, and a way to define optional access types and complex metadata. In addition, this document addresses and clarifies an issue with the inheritance model by introducing the version of the derivedFrom LFB class. These constructs and the update to the inheritance model do not change the nature of the initial model.",
      "ja": "この仕様は、[RFC5812]で定義された初期モデルにわずか数の構造、すなわち、新しいイベント、いくつかの新しいプロパティ、およびオプションのアクセスの種類と複雑なメタデータを定義する方法を追加します。また、この文書アドレスとderivedFrom LFBクラスのバージョンを導入することにより、継承モデルとの問題を明確にしています。これらの構築物と継承モデルへの更新は、初期モデルの性質を変更しないでください。"
    },
    {
      "indent": 3,
      "text": "Thus, the security considerations defined in [RFC5812] apply to this specification as well, as the changes proposed here are simply constructs to write XML library definitions, as [RFC5812] does. These changes, as well as the clarification of the inheritance issue of the initial model, have no effect on the security semantics of the protocol.",
      "ja": "[RFC5812]は同じように、ここで提案された変更は、単に、XMLライブラリの定義を記述するために構築されているとしてこのように、[RFC5812]で定義されたセキュリティ上の考慮事項は、同様にこの仕様に適用されます。これらの変更だけでなく、初期モデルの継承問題の明確化は、プロトコルのセキュリティセマンティクスには影響しません。"
    },
    {
      "indent": 3,
      "text": "In regard to pervasive monitoring (PM), as discussed in [RFC7258], this specification defines ways to expose more complex information (namely, metadata) exchanged between LFBs and between CEs and FEs and a new event. These changes have very little or no effect in terms of making PM simpler or more effective to an attacker who controls the LFBs. The new metadata might make for slightly more elegant PM, but does not enable any new ways to (ab)use LFBs for PM. The same applies for the new event.",
      "ja": "[RFC7258]で議論するように普及監視（PM）に関しては、この仕様は、より複雑な情報を公開する方法を定義する（つまり、メタデータ）をLFBs間及びCEとFEと新しいイベントとの間で交換しました。これらの変更はLFBsを制御し、攻撃者に簡素以上の効果的なPMを作るという点で非常にほとんど、あるいはまったく効果があります。新しいメタデータは、もう少しエレガントPMのために作るかもしれないが、（A-B）への新たな方法を有効にしないPMのためのLFBsを使用しています。同じことが、新たなイベントのために適用されます。"
    },
    {
      "indent": 3,
      "text": "Finally, this document does not provide any protocol specification and, as such, does not specify how information will be transmitted between respective entities. Thus, PM mitigation for a passive attacker that simply wants to eavesdrop on the information exchanged is out of the scope of this document.",
      "ja": "最後に、この文書は、次のような、情報は、各エンティティ間で送信する方法を指定していない、任意のプロトコルの仕様を提供していません。したがって、単純に交換される情報を盗聴しようと受動的攻撃者のためのPMの緩和は、この文書の範囲外です。"
    },
    {
      "indent": 0,
      "text": "6. References",
      "section_title": true,
      "ja": "6.参照"
    },
    {
      "indent": 0,
      "text": "6.1. Normative References",
      "section_title": true,
      "ja": "6.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月、<http://www.rfc-editor.org/info/rfc2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC3688] Mealling, M., \"The IETF XML Registry\", BCP 81, RFC 3688, January 2004, <http://www.rfc-editor.org/info/rfc3688>.",
      "ja": "[RFC3688] Mealling、M.、 \"IETF XMLレジストリ\"、BCP 81、RFC 3688、2004年1月、<http://www.rfc-editor.org/info/rfc3688>。"
    },
    {
      "indent": 3,
      "text": "[RFC5810] Doria, A., Hadi Salim, J., Haas, R., Khosravi, H., Wang, W., Dong, L., Gopal, R., and J. Halpern, \"Forwarding and Control Element Separation (ForCES) Protocol Specification\", RFC 5810, March 2010, <http://www.rfc-editor.org/info/rfc5810>.",
      "ja": "[RFC5810]ドリア、A.、ハディサリム、J.、ハース、R.、Khosravi、H.、王、W.、ドン、L.、ゴパル、R.、およびJ.アルペルン、「転送および制御素子分離（のForCES）プロトコル仕様」、RFC 5810、2010年3月、<http://www.rfc-editor.org/info/rfc5810>。"
    },
    {
      "indent": 3,
      "text": "[RFC5812] Halpern, J. and J. Hadi Salim, \"Forwarding and Control Element Separation (ForCES) Forwarding Element Model\", RFC 5812, March 2010, <http://www.rfc-editor.org/info/rfc5812>.",
      "ja": "[RFC5812]アルペルン、J.およびJ.ハディサリム、 \"転送および制御素子分離（のForCES）転送要素モデル\"、RFC 5812、2010年3月<http://www.rfc-editor.org/info/rfc5812> 。"
    },
    {
      "indent": 3,
      "text": "[RFC7121] Ogawa, K., Wang, W., Haleplidis, E., and J. Hadi Salim, \"High Availability within a Forwarding and Control Element Separation (ForCES) Network Element\", RFC 7121, February 2014, <http://www.rfc-editor.org/info/rfc7121>.",
      "ja": "[RFC7121]小川、K.、王、W.、Haleplidis、E.、およびJ.ハディサリム、 \"転送および制御素子分離（のForCES）内の高可用性ネットワーク要素\"、RFC 7121、2014年2月、<HTTP： //www.rfc-editor.org/info/rfc7121>。"
    },
    {
      "indent": 3,
      "text": "[RFC7258] Farrell, S. and H. Tschofenig, \"Pervasive Monitoring Is an Attack\", BCP 188, RFC 7258, May 2014, <http://www.rfc-editor.org/info/rfc7258>.",
      "ja": "[RFC7258]ファレル、S.およびH. Tschofenig、 \"パーベイシブモニタリングが攻撃である\"、BCP 188、RFC 7258、2014年5月、<http://www.rfc-editor.org/info/rfc7258>。"
    },
    {
      "indent": 0,
      "text": "6.2. Informative References",
      "section_title": true,
      "ja": "6.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[OpenFlowSpec1.1] ONF, \"OpenFlow Switch Specification\", February 2011, <https://www.opennetworking.org/images/stories/downloads/ sdn-resources/onf-specifications/openflow/ openflow-spec-v1.1.0.pdf>.",
      "ja": "[OpenFlowSpec1.1] ONF、 \"オープンフロースイッチの仕様\"、2011年2月、<https://www.opennetworking.org/images/stories/downloads/ SDN-リソース/ ONF-仕様/ OpenFlowの/ OpenFlowの仕様-v1.1.0デベロッパー.PDF>。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "The author would like to acknowledge Joel Halpern, Jamal Hadi Salim, and Dave Hood for their comments and discussion that helped shape this document for the better. Special acknowledgements to Joel Halpern for resolving the issue with the default values, Adrian Farrel for his AD review, Ben Campbell for his Gen-ART review, and Tom Yu for his security review, all of which improved the quality of this document. Additionally, reviews and comments by the following members of the IESG shaped the final version of this document: Stephen Farrel, Barry Leiba, and Ted Lemon. Finally, the author would like to acknowledge Julian Reschke for input regarding the namespace change issue and Joel Halpern for helping to resolve it.",
      "ja": "著者はよりよいため、この文書を形作る助けた彼らのコメントや議論のためのジョエル・ハルパーン、ジャマル・ハディサリム、とDaveフードを確認したいと思います。デフォルト値で問題を解決するためのジョエル・ハルパーンに特別な謝辞、このドキュメントの品質を改善すべてが彼のセキュリティレビューのための彼のADのレビューのためのエードリアンファレル、彼のGen-ARTの見直しのためのベン・キャンベル、そしてトム・ユー、。スティーブン・ファレル、バリー・レイバ、およびテッドレモン：また、IESGの以下のメンバーによってレビューやコメントは、この文書の最終版を形。最後に、著者はそれを解決するために支援するための名前空間変動問題とジョエル・ハルパーンに関する入力のためのジュリアンReschkeを確認したいと思います。"
    },
    {
      "indent": 0,
      "text": "Author's Address",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Evangelos Haleplidis University of Patras Department of Electrical and Computer Engineering Patras 26500 Greece",
      "ja": "電気のパトラス専攻コンピュータ工学パトラス26500ギリシャのEvangelos Haleplidis大学"
    },
    {
      "indent": 3,
      "text": "EMail: ehalep@ece.upatras.gr",
      "ja": "メールアドレス：ehalep@ece.upatras.gr"
    }
  ]
}