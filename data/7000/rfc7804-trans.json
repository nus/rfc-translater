{
  "title": {
    "text": "RFC 7804 - Salted Challenge Response HTTP Authentication Mechanism",
    "ja": "RFC 7804 - 塩漬けチャレンジレスポンスHTTP認証メカニズム"
  },
  "number": 7804,
  "created_at": "2019-11-01 22:53:36.162796+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                       A. Melnikov\nRequest for Comments: 7804                                     Isode Ltd\nCategory: Experimental                                        March 2016\nISSN: 2070-1721",
      "raw": true
    },
    {
      "indent": 8,
      "text": "Salted Challenge Response HTTP Authentication Mechanism",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This specification describes a family of HTTP authentication mechanisms called the Salted Challenge Response Authentication Mechanism (SCRAM), which provides a more robust authentication mechanism than a plaintext password protected by Transport Layer Security (TLS) and avoids the deployment obstacles presented by earlier TLS-protected challenge response authentication mechanisms.",
      "ja": "この仕様は、TLSで保護され、以前から提示、展開の障害物をトランスポート層セキュリティ（TLS）で保護された平文のパスワードよりも堅牢な認証メカニズムを提供して塩漬けチャレンジレスポンス認証メカニズム（SCRAM）と呼ばれるHTTPの認証メカニズムの家族を、説明し、回避しますレスポンス認証メカニズムに挑戦。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for examination, experimental implementation, and evaluation.",
      "ja": "このドキュメントはインターネット標準化過程仕様ではありません。それは、検査、実験的な実装、および評価のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document defines an Experimental Protocol for the Internet community. This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are a candidate for any level of Internet Standard; see Section 2 of RFC 5741.",
      "ja": "この文書は、インターネットコミュニティのためにExperimentalプロトコルを定義します。このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。 IESGによって承認されていないすべての文書がインターネットStandardのどんなレベルの候補です。 RFC 5741のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7804.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7804で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2016 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2016 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   2\n2.  Conventions Used in This Document . . . . . . . . . . . . . .   3\n  2.1.  Terminology . . . . . . . . . . . . . . . . . . . . . . .   4\n  2.2.  Notation  . . . . . . . . . . . . . . . . . . . . . . . .   4\n3.  SCRAM Algorithm Overview  . . . . . . . . . . . . . . . . . .   6\n4.  SCRAM Mechanism Names . . . . . . . . . . . . . . . . . . . .   7\n5.  SCRAM Authentication Exchange . . . . . . . . . . . . . . . .   7\n  5.1.  One Round-Trip Reauthentication . . . . . . . . . . . . .  10\n6.  Use of the Authentication-Info Header Field with SCRAM  . . .  12\n7.  Formal Syntax . . . . . . . . . . . . . . . . . . . . . . . .  13\n8.  Security Considerations . . . . . . . . . . . . . . . . . . .  14\n9.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  15\n10. Design Motivations  . . . . . . . . . . . . . . . . . . . . .  15\n11. References  . . . . . . . . . . . . . . . . . . . . . . . . .  16\n  11.1.  Normative References . . . . . . . . . . . . . . . . . .  16\n  11.2.  Informative References . . . . . . . . . . . . . . . . .  17\nAcknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  18\nAuthor's Address  . . . . . . . . . . . . . . . . . . . . . . . .  18",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "The authentication mechanism most widely deployed and used by Internet application protocols is the transmission of clear-text passwords over a channel protected by Transport Layer Security (TLS). There are some significant security concerns with that mechanism, which could be addressed by the use of a challenge response authentication mechanism protected by TLS. Unfortunately, the HTTP Digest challenge response mechanism presently on the Standards Track failed widespread deployment and has had only limited success.",
      "ja": "最も広くインターネットアプリケーションプロトコルによって展開され、使用される認証メカニズムは、トランスポート層セキュリティ（TLS）によって保護されたチャネルを介してクリアテキストのパスワードを送信することです。 TLSで保護されたチャレンジ・レスポンス認証メカニズムを使用することによって対処することができ、そのメカニズムを持ついくつかの重要なセキュリティ上の問題があります。残念ながら、標準化過程の現在HTTPダイジェストチャレンジレスポンスメカニズムは、広範囲の展開を失敗し、限定的な成功しか収めていました。"
    },
    {
      "indent": 3,
      "text": "This specification describes a family of authentication mechanisms called the Salted Challenge Response Authentication Mechanism (SCRAM), which addresses the requirements necessary to deploy a challenge response mechanism more widely than past attempts (see [RFC5802]). In particular, it addresses some of the issues identified with HTTP Digest, as described in [RFC6331], such as the complexity of implementation and protection of the whole authentication exchange in order to protect against certain man-in-the-middle attacks.",
      "ja": "この仕様は、より広く、過去の試みよりチャレンジレスポンスメカニズムを展開するために必要な要件に対応塩漬けチャレンジレスポンス認証メカニズム（SCRAM）、（[RFC5802]を参照）と呼ばれる認証メカニズムのファミリーを記載しています。特に、特定のman-in-the-middle攻撃から保護するために、このような実装と全体の認証交換の保護の複雑さなど[RFC6331]で説明したように、HTTPダイジェストで特定された問題の一部に対処しています。"
    },
    {
      "indent": 3,
      "text": "HTTP SCRAM is an adaptation of [RFC5802] for use in HTTP. The SCRAM data exchanged is identical to what is defined in [RFC5802]. This document also adds a 1 round-trip reauthentication mode.",
      "ja": "HTTP SCRAMは、HTTPで使用するための[RFC5802]の適応です。交換SCRAMデータは、[RFC5802]で定義されているものと同一です。また、このドキュメントでは、1往復の再認証モードが追加されます。"
    },
    {
      "indent": 3,
      "text": "HTTP SCRAM provides the following protocol features:",
      "ja": "HTTP SCRAMは、以下のプロトコル機能を提供します。"
    },
    {
      "indent": 3,
      "text": "o The authentication information stored in the authentication database is not sufficient by itself (without a dictionary attack) to impersonate the client. The information is salted to make it harder to do a pre-stored dictionary attack if the database is stolen.",
      "ja": "O認証データベースに格納された認証情報は、クライアントを偽装する（辞書攻撃することなく）単独では不十分です。情報は、データベースが盗まれた場合、それは難しい予め記憶された辞書攻撃を行うために作るために塩漬けされます。"
    },
    {
      "indent": 3,
      "text": "o The server does not gain the ability to impersonate the client to other servers (with an exception for server-authorized proxies), unless it performs a dictionary attack.",
      "ja": "それは辞書攻撃を実行しない限り、Oサーバは、他のサーバに（サーバ・認可プロキシの例外を除いて）クライアントを偽装する能力を獲得していません。"
    },
    {
      "indent": 3,
      "text": "o The mechanism permits the use of a server-authorized proxy without requiring that proxy to have super-user rights with the back-end server.",
      "ja": "Oメカニズムは、バックエンドサーバーを持つスーパーユーザー権限を持つようにそのプロキシを必要とせずに、サーバー・認可プロキシを使用することが可能になります。"
    },
    {
      "indent": 3,
      "text": "o Mutual authentication is supported, but only the client is named (i.e., the server has no name).",
      "ja": "O相互認証がサポートされているが、唯一のクライアントが命名された（すなわち、サーバは名前がありません）。"
    },
    {
      "indent": 0,
      "text": "2. Conventions Used in This Document",
      "section_title": true,
      "ja": "この文書で使用される2.表記"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はあります[RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 3,
      "text": "Formal syntax is defined by [RFC5234] including the core rules defined in Appendix B of [RFC5234].",
      "ja": "正式な構文は[RFC5234]の付録Bで定義されたコア・ルールを含む[RFC5234]で定義されます。"
    },
    {
      "indent": 3,
      "text": "Example lines prefaced by \"C:\" are sent by the client and ones prefaced by \"S:\" by the server. If a single \"C:\" or \"S:\" label applies to multiple lines, then the line breaks between those lines are for editorial clarity only and are not part of the actual protocol exchange.",
      "ja": "「C：」で始まる例ラインはで始まるクライアントとものによって送信された「S：」サーバーで。シングル「C：」場合や「S：」ラベルは複数行に適用され、その後、これらの線の間の改行は編集上明確にするためであり、実際のプロトコル交換の一部ではありません。"
    },
    {
      "indent": 0,
      "text": "2.1. Terminology",
      "section_title": true,
      "ja": "2.1. 用語"
    },
    {
      "indent": 3,
      "text": "This document uses several terms defined in the \"Internet Security Glossary\" [RFC4949], including the following: authentication, authentication exchange, authentication information, brute force, challenge-response, cryptographic hash function, dictionary attack, eavesdropping, hash result, keyed hash, man-in-the-middle, nonce, one-way encryption function, password, replay attack, and salt. Readers not familiar with these terms should use that glossary as a reference.",
      "ja": "認証、認証交換、認証情報、ブルートフォース、チャレンジレスポンス、暗号学的ハッシュ関数、辞書攻撃、盗聴、ハッシュ結果、鍵付きハッシュ：このドキュメントは、次のような「インターネットセキュリティ用語集」[RFC4949]で定義されたいくつかの用語を使用しています、のman-in-the-middle、ナンス、一方向暗号化機能、パスワード、リプレイ攻撃、および塩。これらの用語に慣れていない読者は、参照としてその用語集を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "Some clarifications and additional definitions follow:",
      "ja": "いくつかの明確化と、追加の定義は、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o Authentication information: Information used to verify an identity claimed by a SCRAM client. The authentication information for a SCRAM identity consists of salt, iteration count, the StoredKey, and the ServerKey (as defined in the algorithm overview) for each supported cryptographic hash function.",
      "ja": "O認証情報：SCRAMクライアントによって要求されたアイデンティティを検証するために使用される情報。 SCRAMアイデンティティの認証情報は、サポートされている各暗号ハッシュ関数のために（アルゴリズムの概要で定義される）塩、繰り返し回数、StoredKey、およびサーバキーから構成されています。"
    },
    {
      "indent": 3,
      "text": "o Authentication database: The database used to look up the authentication information associated with a particular identity. For application protocols, LDAPv3 (see [RFC4510]) is frequently used as the authentication database. For lower-layer protocols such as PPP or 802.11x, the use of RADIUS [RFC2865] is more common.",
      "ja": "O認証データベース：特定のIDに関連付けられた認証情報を検索するために使用するデータベース。アプリケーションプロトコルのために、LDAPv3のはしばしば認証データベースとして使用される（[RFC4510]参照します）。そのようなPPPまたは802.11xのような下位層プロトコルは、RADIUS [RFC2865]の使用がより一般的です。"
    },
    {
      "indent": 3,
      "text": "o Base64: An encoding mechanism defined in Section 4 of [RFC4648] that converts an octet string input to a textual output string that can be easily displayed to a human. The use of base64 in SCRAM is restricted to the canonical form with no whitespace.",
      "ja": "Base64で○：容易にヒトに表示できるテキスト出力ストリングにオクテットストリング入力を変換[RFC4648]のセクション4で定義されたエンコードメカニズム。 SCRAMでbase64での使用はスペースなしで標準的な形式に制限されています。"
    },
    {
      "indent": 3,
      "text": "o Octet: An 8-bit byte.",
      "ja": "Oオクテット：8ビットバイト。"
    },
    {
      "indent": 3,
      "text": "o Octet string: A sequence of 8-bit bytes.",
      "ja": "Oオクテット文字列：8ビットバイトのシーケンス。"
    },
    {
      "indent": 3,
      "text": "o Salt: A random octet string that is combined with a password before applying a one-way encryption function. This value is used to protect passwords that are stored in an authentication database.",
      "ja": "O塩：一方向の暗号化機能を適用する前に、パスワードと組み合わせたランダムオクテット文字列。この値は、認証データベースに保存されたパスワードを保護するために使用されます。"
    },
    {
      "indent": 0,
      "text": "2.2. Notation",
      "section_title": true,
      "ja": "2.2. 表記法"
    },
    {
      "indent": 3,
      "text": "The pseudocode description of the algorithm uses the following notation:",
      "ja": "アルゴリズムの擬似コード記述は以下の表記を使用します。"
    },
    {
      "indent": 3,
      "text": "o \":=\": The variable on the left-hand side represents the octet string resulting from the expression on the right-hand side.",
      "ja": "O「：=」：左側の変数は右辺の発現に起因オクテットストリングを示しています。"
    },
    {
      "indent": 3,
      "text": "o \"+\": Octet string concatenation.",
      "ja": "\"+\" O：オクテット文字列の連結。"
    },
    {
      "indent": 3,
      "text": "o \"[ ]\": A portion of an expression enclosed in \"[\" and \"]\" is optional in the result under some circumstances. See the associated text for a description of those circumstances.",
      "ja": "O「[]」「[」と「]」で囲まれた表現の部分は、いくつかの状況下で、結果に任意です。このような状況の説明については、関連するテキストを参照してください。"
    },
    {
      "indent": 3,
      "text": "o Normalize(str): Apply the Preparation and Enforcement steps according to the OpaqueString profile (see [RFC7613]) to a UTF-8 [RFC3629] encoded \"str\". The resulting string is also in UTF-8. Note that implementations MUST either implement OpaqueString profile operations from [RFC7613] or disallow the use of non US-ASCII Unicode codepoints in \"str\". The latter is a particular case of compliance with [RFC7613].",
      "ja": "Oノーマライズ（STR）は、 \"STR\" 符号化されたUTF-8 [RFC3629]にOpaqueStringプロファイル（参照[RFC7613]）に従って調製および施行手順を適用します。結果の文字列はUTF-8でもあります。実装は[RFC7613]からのプロファイルの操作をOpaqueString実装または「STR」内の非US-ASCII Unicodeのコードポイントの使用を禁止しなければならないのいずれかのことに注意してください。後者は、[RFC7613]の遵守の特定の場合です。"
    },
    {
      "indent": 3,
      "text": "o HMAC(key, str): Apply the HMAC-keyed hash algorithm (defined in [RFC2104]) using the octet string represented by \"key\" as the key and the octet string \"str\" as the input string. The size of the result is the hash result size for the hash function in use. For example, it is 32 octets for SHA-256 and 20 octets for SHA-1 (see [RFC6234]).",
      "ja": "O HMAC（キー、STR）：入力文字列としてキーとオクテット列「STR」と「キー」で表されるオクテットストリングを使用して（[RFC2104]で定義される）HMAC-鍵付きハッシュアルゴリズムを適用します。結果のサイズは、使用されているハッシュ関数のハッシュ結果のサイズです。例えば、（[RFC6234]を参照）SHA-1、SHA-256および20オクテット32オクテットです。"
    },
    {
      "indent": 3,
      "text": "o H(str): Apply the cryptographic hash function to the octet string \"str\", producing an octet string as a result. The size of the result depends on the hash result size for the hash function in use.",
      "ja": "O H（STR）は：結果としてオクテットストリングを生成する、オクテットストリング「STR」に暗号ハッシュ関数を適用します。結果のサイズは、使用されているハッシュ関数のハッシュ結果のサイズに依存します。"
    },
    {
      "indent": 3,
      "text": "o XOR: Apply the exclusive-or operation to combine the octet string on the left of this operator with the octet string on the right of this operator. The length of the output and each of the two inputs will be the same for this use.",
      "ja": "XOR○：この演算子の右側のオクテット文字列で、この演算子の左側のオクテット文字列を結合する排他的論理和演算を適用します。出力の長さと2つの入力のそれぞれは、この用途のために同じです。"
    },
    {
      "indent": 3,
      "text": "o Hi(str, salt, i):",
      "ja": "こんにちはO（STR、塩、I）："
    },
    {
      "indent": 6,
      "text": "U1 := HMAC(str, salt + INT(1)) U2 := HMAC(str, U1) ... Ui-1 := HMAC(str, Ui-2) Ui := HMAC(str, Ui-1)",
      "ja": "U1 = U2 HMAC = HMAC（STR、U1）... UI-1 = HMAC（STR、UI-2）U = HMAC（STR、UI-1）（STR + INT（1）ジャンプ）"
    },
    {
      "indent": 6,
      "text": "Hi := U1 XOR U2 XOR ... XOR Ui",
      "ja": "こんにちは：= U1 XOR U2 XOR ... XOR宇井"
    },
    {
      "indent": 6,
      "text": "where \"i\" is the iteration count, \"+\" is the string concatenation operator, and INT(g) is a four-octet encoding of the integer g, most significant octet first.",
      "ja": "ここで、「i」は、反復回数が「+」の文字列連結演算子であり、INT（g）は、最初の整数gの4オクテットの符号化、最も重要なオクテットです。"
    },
    {
      "indent": 6,
      "text": "Hi() is, essentially, PBKDF2 [RFC2898] with HMAC() as the Pseudorandom Function (PRF) and with dkLen == output length of HMAC() == output length of H().",
      "ja": "HI（））、本質的に、PBKDF2 HMACと[RFC2898]（）擬似ランダム関数（PRF）やdkLenと== HMACの出力長（）Hの==出力長（あります。"
    },
    {
      "indent": 0,
      "text": "3. SCRAM Algorithm Overview",
      "section_title": true,
      "ja": "3. SCRAMアルゴリズムの概要"
    },
    {
      "indent": 3,
      "text": "The following is a description of a full HTTP SCRAM authentication exchange. Note that this section omits some details, such as client and server nonces. See Section 5 for more details.",
      "ja": "以下は、完全なHTTP SCRAMの認証交換の記述です。このセクションでは、クライアントとサーバのナンスなどいくつかの詳細を、省略することに注意してください。詳細は、第5章を参照してください。"
    },
    {
      "indent": 3,
      "text": "To begin with, the SCRAM client is in possession of a username and password, both encoded in UTF-8 [RFC3629] (or a ClientKey/ServerKey, or SaltedPassword). It sends the username to the server, which retrieves the corresponding authentication information: a salt, a StoredKey, a ServerKey, and an iteration count (\"i\"). (Note that a server implementation may choose to use the same iteration count for all accounts.) The server sends the salt and the iteration count to the client, which then computes the following values and sends a ClientProof to the server:",
      "ja": "まず、SCRAMクライアントは、ユーザ名とパスワードの両方のUTF-8 [RFC3629]（またはClientKey /サーバキー、又はSaltedPassword）でエンコードを保持しています。塩、StoredKey、サーバキー、および反復回数（「I」）：これは、対応する認証情報を取得し、サーバにユーザ名を送信します。 （サーバーの実装は、すべてのアカウントに同じ反復回数を使用するように選択することがあります。）サーバは、塩、その後、次の値を計算し、サーバにClientProofを送信し、クライアントへの反復回数を送信します。"
    },
    {
      "indent": 3,
      "text": "Informative Note: Implementors are encouraged to create test cases that use both usernames and passwords with non-ASCII codepoints. In particular, it is useful to test codepoints whose Unicode Normalization Canonical Composition (NFC) and Unicode Normalization Form Compatibility Composition (NFKC) are different (see [Unicode-UAX15]). Some examples of such codepoints include Vulgar Fraction One Half (U+00BD) and Acute Accent (U+00B4).",
      "ja": "有益な注意：実装者は、非ASCIIコードポイントでユーザー名とパスワードの両方を使用してテストケースを作成することをお勧めします。特に、そのユニコード正規化正規組成物（NFC）およびUnicode正規化形式の互換性組成物（NFKC）コードポイントをテストするのに有用である（[ユニコードUAX15]を参照）が異なります。そのようなコードポイントのいくつかの例は、常分数半分（U + 00BD）および急性アクセント（U + 00B4）が挙げられます。"
    },
    {
      "indent": 6,
      "text": "SaltedPassword := Hi(Normalize(password), salt, i) ClientKey := HMAC(SaltedPassword, \"Client Key\") StoredKey := H(ClientKey) AuthMessage := client-first-message-bare + \",\" + server-first-message + \",\" + client-final-message-without-proof ClientSignature := HMAC(StoredKey, AuthMessage) ClientProof := ClientKey XOR ClientSignature ServerKey := HMAC(SaltedPassword, \"Server Key\") ServerSignature := HMAC(ServerKey, AuthMessage)",
      "ja": "SaltedPassword：=こんにちは（ノーマライズ（パスワード）、塩、I）ClientKey：= HMAC（SaltedPassword、 \"クライアントキー\"）StoredKey：= H（ClientKey）AuthMessage：=クライアント・ファースト・メッセージ裸+ \"\" +サーバ - 最初のメッセージ+ \"\" +クライアント - 最終メッセージなしプルーフClientSignature：= HMAC（StoredKey、AuthMessage）ClientProof：= ClientKey XOR ClientSignatureサーバキー：= HMAC（SaltedPassword、 \"サーバキー\"）ServerSignature：= HMAC（サーバキー、AuthMessage）"
    },
    {
      "indent": 3,
      "text": "The server authenticates the client by computing the ClientSignature, exclusive-ORing that with the ClientProof to recover the ClientKey, and verifying the correctness of the ClientKey by applying the hash function and comparing the result to the StoredKey. If the ClientKey is correct, this proves that the client has access to the user's password.",
      "ja": "サーバーはClientProofでClientKeyを回復することClientSignature、排他的論理和を計算し、ハッシュ関数を適用し、StoredKeyに結果を比較することにより、ClientKeyの正しさを検証することにより、クライアントを認証します。 ClientKeyが正しければ、これは、クライアントがユーザーのパスワードへのアクセス権を持っていることを証明しています。"
    },
    {
      "indent": 3,
      "text": "Similarly, the client authenticates the server by computing the ServerSignature and comparing it to the value sent by the server. If the two are equal, this proves that the server had access to the user's ServerKey.",
      "ja": "同様に、クライアントはServerSignatureを計算し、サーバによって送信された値と比較することによって、サーバを認証します。 2が等しい場合、これは、サーバがユーザのサーバキーへのアクセス権を持っていたことを証明しています。"
    },
    {
      "indent": 3,
      "text": "For initial authentication, the AuthMessage is computed by concatenating decoded \"data\" attribute values from the authentication exchange. The format of each of these 3 decoded \"data\" attributes is defined in [RFC5802].",
      "ja": "初期認証のために、AuthMessageは、認証交換からの復号「データ」の属性値を連結することによって計算されます。これらの3つのそれぞれのフォーマットは、「データ」属性デコード[RFC5802]で定義されています。"
    },
    {
      "indent": 0,
      "text": "4. SCRAM Mechanism Names",
      "section_title": true,
      "ja": "4.スクラムメカニズム名"
    },
    {
      "indent": 3,
      "text": "A SCRAM mechanism name (authentication scheme) is a string \"SCRAM-\" followed by the uppercased name of the underlying hash function taken from the IANA \"Hash Function Textual Names\" registry (see <http://www.iana.org/assignments/hash-function-text-names>).",
      "ja": "スクラム機構名（認証方式）は、IANA「ハッシュ関数テキスト名」レジストリ（参照<http://www.iana.org/assignmentsから取られた基本的なハッシュ関数の大文字名が続く文字列「SCRAM-」であります/ハッシュ関数のテキスト名>）。"
    },
    {
      "indent": 3,
      "text": "For interoperability, all HTTP clients and servers supporting SCRAM MUST implement the SCRAM-SHA-256 authentication mechanism, i.e., an authentication mechanism from the SCRAM family that uses the SHA-256 hash function as defined in [RFC7677].",
      "ja": "相互運用性のため、SCRAMをサポートするすべてのHTTPクライアントとサーバは、[RFC7677]で定義されるようにSHA-256ハッシュ関数を使用SCRAMファミリーから、すなわち、認証メカニズム、SCRAM-SHA-256認証機構を実装しなければなりません。"
    },
    {
      "indent": 0,
      "text": "5. SCRAM Authentication Exchange",
      "section_title": true,
      "ja": "5. SCRAM認証交換"
    },
    {
      "indent": 3,
      "text": "HTTP SCRAM is an HTTP Authentication mechanism whose client response (<credentials-scram>) and server challenge (<challenge-scram>) messages are text-based messages containing one or more attribute-value pairs separated by commas. The messages and their attributes are described below and defined in Section 7.",
      "ja": "HTTP SCRAMは、そのクライアントの応答（<資格情報-スクラム>）HTTP認証メカニズムであり、サーバーの挑戦（<チャレンジ・スクラム>）メッセージカンマで区切られた1つ以上の属性と値のペアを含むテキストベースのメッセージです。メッセージとその属性は、以下に説明し、第7節で定義されています。"
    },
    {
      "indent": 4,
      "text": "challenge-scram = scram-name [1*SP 1#auth-param] ; Complies with <challenge> ABNF from RFC 7235. ; Included in the WWW-Authenticate header field.",
      "ja": "チャレンジ・スクラム=スクラム名[1つの* SP 1＃1のauth-PARAM]; <課題> RFC 7235.からABNFに準拠しています。 WWW-Authenticateヘッダフィールドに含まれています。"
    },
    {
      "indent": 4,
      "text": "credentials-scram = scram-name [1*SP 1#auth-param] ; Complies with <credentials> from RFC 7235. ; Included in the Authorization header field.",
      "ja": "資格情報 - スクラム=スクラム名[1つの* SP 1＃1のauth-PARAM]; RFC 7235.から<資格情報>に準拠しています。 Authorizationヘッダフィールドに含まれています。"
    },
    {
      "indent": 4,
      "text": "scram-name = \"SCRAM-SHA-256\" / \"SCRAM-SHA-1\" / other-scram-name ; SCRAM-SHA-256 and SCRAM-SHA-1 are registered by this RFC. ; ; SCRAM-SHA-1 is registered for database compatibility ; with implementations of RFC 5802 (such as IMAP or Extensible Messaging and Presence Protocol (XMPP) ; servers), but it is not recommended for new deployments.",
      "ja": "スクラム名= \"SCRAM-SHA-256\" / \"SCRAM-SHA-1\" /他の-スクラム名。 SCRAM-SHA-256とSCRAM-SHA-1は、このRFCによって登録されています。 ; ; SCRAM-SHA-1は、データベースの互換性のために登録されています。 （例えばIMAPまたは拡張メッセージングおよびプレゼンスプロトコル（XMPP）など;サーバ）RFC 5802の実装と、それは、新たな展開には推奨されません。"
    },
    {
      "indent": 4,
      "text": "other-scram-name = \"SCRAM-\" hash-name ; hash-name is a capitalized form of names from IANA. ; \"Hash Function Textual Names\" registry. ; Additional SCRAM names must be registered in both ; the IANA \"SASL Mechanisms\" registry ; and the IANA \"HTTP Authentication Schemes\" registry.",
      "ja": "他の-スクラム名= \"SCRAM-\" ハッシュ名;ハッシュ名は、IANAからの名前の大文字の形です。 ; 「ハッシュ関数テキスト名」レジストリ。 ;追加SCRAM名は、両方に登録する必要があります。 IANA「SASLメカニズム」のレジストリ。そしてIANA「HTTP認証スキーム」レジストリ。"
    },
    {
      "indent": 3,
      "text": "This is a simple example of a SCRAM-SHA-256 authentication exchange (no support for channel bindings, as this feature is not currently supported by HTTP). Username 'user' and password 'pencil' are used. Note that long lines are folded for readability.",
      "ja": "（この機能は、現在、HTTPでサポートされていないように、チャネルバインディングのサポートなし）これはSCRAM-SHA-256認証交換の簡単な例です。ユーザー名「ユーザー」とパスワード「鉛筆」が使用されています。長い行は読みやすくするために折り畳まれていることに注意してください。"
    },
    {
      "indent": 3,
      "text": "C: GET /resource HTTP/1.1 C: Host: server.example.com C: [...]",
      "ja": "C：GET /リソースのHTTP / 1.1 C：ホスト：server.example.comのC：[...]"
    },
    {
      "indent": 3,
      "text": "S: HTTP/1.1 401 Unauthorized S: WWW-Authenticate: Digest realm=\"realm1@example.com\", Digest realm=\"realm2@example.com\", Digest realm=\"realm3@example.com\", SCRAM-SHA-256 realm=\"realm3@example.com\", SCRAM-SHA-256 realm=\"testrealm@example.com\" S: [...]",
      "ja": "S：HTTP / 1.1 401不正なS：WWW認証：= \"realm1@example.com\"、ダイジェスト分野= \"realm2@example.com\"、ダイジェストレルム= \"realm3@example.com\" レルムをダイジェスト、SCRAM-SHA- 256レルム= \"realm3@example.com\"、SCRAM-SHA-256レルム= \"testrealm@example.com\" S：[...]"
    },
    {
      "indent": 3,
      "text": "C: GET /resource HTTP/1.1 C: Host: server.example.com C: Authorization: SCRAM-SHA-256 realm=\"testrealm@example.com\", data=biwsbj11c2VyLHI9ck9wck5HZndFYmVSV2diTkVrcU8K C: [...]",
      "ja": "C：GET /リソースHTTP / 1.1 C：ホスト：server.example.com C：認可：SCRAM-SHA-256レルム= \"testrealm@example.com\"、データ= biwsbj11c2VyLHI9ck9wck5HZndFYmVSV2diTkVrcU8K C：[...]"
    },
    {
      "indent": 3,
      "text": "S: HTTP/1.1 401 Unauthorized S: WWW-Authenticate: SCRAM-SHA-256 sid=AAAABBBBCCCCDDDD, data=cj1yT3ByTkdmd0ViZVJXZ2JORWtxTyVodllEcFdVYTJSYVRDQWZ1eEZJ bGopaE5sRixzPVcyMlphSjBTTlk3c29Fc1VFamI2Z1E9PSxpPTQwOTYK S: [...]",
      "ja": "S：HTTP / 1.1 401不正S：WWW認証：SCRAM-SHA-256 SID = AAAABBBBCCCCDDDD、データ= cj1yT3ByTkdmd0ViZVJXZ2JORWtxTyVodllEcFdVYTJSYVRDQWZ1eEZJ bGopaE5sRixzPVcyMlphSjBTTlk3c29Fc1VFamI2Z1E9PSxpPTQwOTYK S：[...]"
    },
    {
      "indent": 3,
      "text": "C: GET /resource HTTP/1.1 C: Host: server.example.com C: Authorization: SCRAM-SHA-256 sid=AAAABBBBCCCCDDDD, data=Yz1iaXdzLHI9ck9wck5HZndFYmVSV2diTkVrcU8laHZZRHBXVWEyUmFUQ 0FmdXhGSWxqKWhObEYscD1kSHpiWmFwV0lrNGpVaE4rVXRlOXl0YWc5empm TUhnc3FtbWl6N0FuZFZRPQo= C: [...]",
      "ja": "C：GET /リソースHTTP / 1.1 C：ホスト：server.example.com C：認可：SCRAM-SHA-256 SID = AAAABBBBCCCCDDDD、データ= Yz1iaXdzLHI9ck9wck5HZndFYmVSV2diTkVrcU8laHZZRHBXVWEyUmFUQ 0FmdXhGSWxqKWhObEYscD1kSHpiWmFwV0lrNGpVaE4rVXRlOXl0YWc5empm TUhnc3FtbWl6N0FuZFZRPQo = C：[...]"
    },
    {
      "indent": 3,
      "text": "S: HTTP/1.1 200 Ok S: Authentication-Info: sid=AAAABBBBCCCCDDDD, data=dj02cnJpVFJCaTIzV3BSUi93dHVwK21NaFVaVW4vZEI1bkxUSlJzamw5N Uc0PQo= S: [...Other header fields and resource body...]",
      "ja": "S：HTTP / 1.1 200 OK S：認証-情報：SID = AAAABBBBCCCCDDDD、データ= dj02cnJpVFJCaTIzV3BSUi93dHVwK21NaFVaVW4vZEI1bkxUSlJzamw5N Uc0PQo = S：[...他のヘッダフィールドとリソース本体...]"
    },
    {
      "indent": 3,
      "text": "In the above example, the first client request contains a \"data\" attribute that base64 decodes as follows:",
      "ja": "上記の例では、最初のクライアント要求は、次のようにbase64でデコードすることを「データ」属性が含まれています。"
    },
    {
      "indent": 6,
      "text": "n,,n=user,r=rOprNGfwEbeRWgbNEkqO",
      "ja": "N ,, N =ユーザー、R = rOprNGfwEbeRWgbNEkqO"
    },
    {
      "indent": 3,
      "text": "The server then responds with a \"data\" attribute that base64 decodes as follows:",
      "ja": "その後、サーバーは、次のようにbase64でデコードすることを「データ」属性を使用して応答します。"
    },
    {
      "indent": 6,
      "text": "r=rOprNGfwEbeRWgbNEkqO%hvYDpWUa2RaTCAfuxFIlj)hNlF,s=W22ZaJ0SNY7soE sUEjb6gQ==,i=4096",
      "ja": "R = rOprNGfwEbeRWgbNEkqO％hvYDpWUa2RaTCAfuxFIlj）HNLF、S = W22ZaJ0SNY7soE sUEjb6gQ ==、I = 4096"
    },
    {
      "indent": 3,
      "text": "The next client request contains a \"data\" attribute that base64 decodes as follows:",
      "ja": "次のクライアント要求は、次のようにbase64でデコードすることを「データ」属性が含まれています。"
    },
    {
      "indent": 6,
      "text": "c=biws,r=rOprNGfwEbeRWgbNEkqO%hvYDpWUa2RaTCAfuxFIlj)hNlF,p=dHzbZap WIk4jUhN+Ute9ytag9zjfMHgsqmmiz7AndVQ=",
      "ja": "C =紫、R = rOprNGfwEbeRWgbNEkqO％hvYDpWUa2RaTCAfuxFIlj）HNLF、P = dHzbZap WIk4jUhN + Ute9ytag9zjfMHgsqmmiz7AndVQ ="
    },
    {
      "indent": 3,
      "text": "The final server response contains a \"data\" attribute that base64 decodes as follows:",
      "ja": "最終サーバの応答は次のようにbase64でデコードすることを「データ」属性が含まれています。"
    },
    {
      "indent": 6,
      "text": "v=6rriTRBi23WpRR/wtup+mMhUZUn/dB5nLTJRsjl95G4=",
      "ja": "A = brriTRBi23VpRR / vtupuyu + muzon / dB5nLTRszhl95Zh4 ="
    },
    {
      "indent": 3,
      "text": "Note that in the example above, the client can also initiate SCRAM authentication without first being prompted by the server.",
      "ja": "上記の例では、クライアントはまた、最初のサーバが要求されることなくSCRAM認証を開始することができます。"
    },
    {
      "indent": 3,
      "text": "Initial \"SCRAM-SHA-256\" authentication starts with sending the Authorization request header field (defined by HTTP/1.1, Part 7 [RFC7235]) containing the \"SCRAM-SHA-256\" authentication scheme and the following attributes:",
      "ja": "初期「SCRAM-SHA-256」認証「は、SCRAM-SHA-256」認証スキームを含む、次の属性（HTTP / 1.1、パート7 [RFC7235]で定義される）承認リクエストヘッダフィールドの送信で始まります。"
    },
    {
      "indent": 3,
      "text": "o A \"realm\" attribute MAY be included to indicate the scope of protection in the manner described in HTTP/1.1, Part 7 [RFC7235]. As specified in [RFC7235], the \"realm\" attribute MUST NOT appear more than once. The \"realm\" attribute only appears in the first SCRAM message to the server and in the first SCRAM response from the server.",
      "ja": "O「レルム」属性は、HTTP / 1.1、パート7 [RFC7235]に記載された方法で保護の範囲を示すために含まれるかもしれません。 [RFC7235]で指定されているように、「領域」属性が複数回出現することはできません。 「領域」属性は、サーバーへの最初のスクラムメッセージに、サーバからの最初のスクラム応答に表示されます。"
    },
    {
      "indent": 3,
      "text": "o The client also includes the \"data\" attribute that contains the base64-encoded \"client-first-message\" [RFC5802] containing:",
      "ja": "クライアントは、base64エンコード「クライアント・ファースト・メッセージ」[RFC5802]を含む含む「データ」属性を含む（O）"
    },
    {
      "indent": 6,
      "text": "* a header consisting of a flag indicating whether channel binding is supported-but-not-used, not supported, or used. Note that this version of SCRAM doesn't support HTTP channel bindings, so this header always starts with \"n\"; otherwise, the message is invalid and authentication MUST fail.",
      "ja": "*チャネル結合がサポートされている、しかし、利用されていないかどうかを示すフラグからなるヘッダは、サポートされている、または使用されません。 SCRAMのこのバージョンは、HTTPチャネルバインディングをサポートしていないので、このヘッダは常に「N」で始まることに注意してください。そうでない場合、メッセージは無効であり、認証が失敗しなければなりません。"
    },
    {
      "indent": 6,
      "text": "* SCRAM username and a random, unique \"nonce\" attribute.",
      "ja": "*スクラムのユーザー名とランダムな、ユニークな「ナンス」属性。"
    },
    {
      "indent": 3,
      "text": "In an HTTP response, the server sends the WWW-Authenticate header field containing a unique session identifier (the \"sid\" attribute) plus the \"data\" attribute containing the base64-encoded \"server-first-message\" [RFC5802]. The \"server-first-message\" contains the user's iteration count i, the user's salt, and the nonce with a concatenation of the client-specified one (taken from the \"client-first-message\") with a freshly generated server nonce.",
      "ja": "HTTP応答で、サーバは、一意のセッション識別子（「SID」属性）を加えたbase64でエンコードされた「サーバ・ファースト・メッセージ」[RFC5802]を含む「データ」属性を含むWWW-Authenticateヘッダフィールドを送ります。 「サーバー・ファースト・メッセージには、」ユーザーの反復回数I、ユーザの塩、そして新鮮に生成されたサーバ・ナンスと（「クライアント・ファースト・メッセージ」から取られた）クライアント指定の1の連結とナンスが含まれています。"
    },
    {
      "indent": 3,
      "text": "The client then responds with another HTTP request with the Authorization header field, which includes the \"sid\" attribute received in the previous server response, together with the \"data\" attribute containing base64-encoded \"client-final-message\" data. The latter has the same nonce as in \"server-first-message\" and a ClientProof computed using the selected hash function (e.g., SHA-256) as explained earlier.",
      "ja": "クライアントは、次に一緒にbase64エンコード「クライアント最終メッセージ」データを含む「データ」属性で、以前のサーバーの応答で受信した「SID」属性を含むAuthorizationヘッダフィールドを持つ別のHTTP要求に応答します。先に説明したように、後者は、「サーバ・ファースト・メッセージ」とClientProofと同じノンスは、選択されたハッシュ関数（例えば、SHA-256）を用いて計算しました。"
    },
    {
      "indent": 3,
      "text": "The server verifies the nonce and the proof, and, finally, it responds with a 200 HTTP response with the Authentication-Info header field [RFC7615] containing the \"sid\" attribute (as received from the client) and the \"data\" attribute containing the base64-encoded \"server-final-message\", concluding the authentication exchange.",
      "ja": "サーバは、ノンスと証明を検証し、そして、最後に、それは「SID」属性（クライアントから受信される）とを含む「データ」属性を含む認証-Infoヘッダフィールド[RFC7615]と200 HTTPレスポンスで応答します認証交換を締結し、「サーバー・ファイナル・メッセージ」Base64エンコード。"
    },
    {
      "indent": 3,
      "text": "The client then authenticates the server by computing the ServerSignature and comparing it to the value sent by the server. If the two are different, the client MUST consider the authentication exchange to be unsuccessful, and it might have to drop the connection.",
      "ja": "その後、クライアントはServerSignatureを計算し、サーバーから送信された値と比較することによって、サーバーを認証します。 2が異なる場合、クライアントは認証交換が失敗であることを考慮しなければならない、そしてそれは、接続をドロップする必要がある場合があります。"
    },
    {
      "indent": 0,
      "text": "5.1. One Round-Trip Reauthentication",
      "section_title": true,
      "ja": "5.1.  1往復の再認証"
    },
    {
      "indent": 3,
      "text": "If the server supports SCRAM reauthentication, the server sends in its initial HTTP response a WWW-Authenticate header field containing the \"realm\" attribute (as defined earlier), the \"sr\" attribute that contains the server part of the \"r\" attribute (see s-nonce in [RFC5802]), and an optional \"ttl\" attribute (which contains the \"sr\" value validity in seconds).",
      "ja": "サーバはSCRAM再認証をサポートする場合、サーバは、その最初のHTTPレスポンスに「R」属性（のサーバーの一部が含まれている「レルム」属性（先に定義したように）、「SR」属性を含むWWW-Authenticateヘッダフィールドを送ります）[RFC5802]中のS-nonceを見て、数秒で「SR」値の妥当性を含むオプションの「TTL」属性（）。"
    },
    {
      "indent": 3,
      "text": "If the client has authenticated to the same realm before (i.e., it remembers \"i\" and \"s\" attributes for the user from earlier authentication exchanges with the server), it can respond to that with \"client-final-message\". When constructing the \"client-final-message\", the client constructs the c-nonce part of the \"r\" attribute as on initial authentication and the s-nonce part as follows: s-nonce is a concatenation of nonce-count and the \"sr\" attribute (in that order). The nonce-count is a positive integer that is equal to the user's \"i\" attribute on first reauthentication and is incremented by 1 on each successful reauthentication.",
      "ja": "クライアントが前に同じレルムに認証されている場合（すなわち、それは「I」と「s」は、サーバとの以前の認証交換からユーザーの属性を覚えている）、それは、「クライアント・ファイナル・メッセージ」とそれに対応することができます。 S-nonceがナンスカウントとを連結したものである：「クライアント・ファイナル・メッセージ」を構築する場合、以下のように、クライアントが初期認証とs-ナンス一部のように、「R」属性のC-ナンス一部を構成します（この順序で）「SR」属性。ナンスカウントは最初の再認証上のユーザーの「i」の属性と同じであり、各正常な再認証に1ずつインクリメントされる正の整数です。"
    },
    {
      "indent": 6,
      "text": "The purpose of the nonce-count is to allow the server to detect request replays by maintaining its own copy of this count -- if the same nonce-count value is seen twice, then the request is a replay.",
      "ja": "同じナンスカウント値が二度見された場合、その要求はリプレイである - ナンスカウントの目的は、サーバーがこのカウントの独自のコピーを維持することによって、要求のリプレイを検出することができるようにすることです。"
    },
    {
      "indent": 3,
      "text": "If the server considers the s-nonce part of the \"nonce\" attribute (the \"r\" attribute) to still be valid (i.e., the nonce-count part is as expected (see above) and the \"sr\" part is still fresh), it will provide access to the requested resource (assuming the client hash verifies correctly, of course). However, if the server considers that the server part of the nonce is stale (for example, if the \"sr\" value is used after the \"ttl\" seconds), the server returns \"401 Unauthorized\" containing the SCRAM mechanism name with the following attributes: a new \"sr\", \"stale=true\", and an optional \"ttl\". The \"stale\" attribute signals to the client that there is no need to ask the user for the password.",
      "ja": "サーバーは、「ナンス」属性（「R」属性）のS-ナンス部分はまだ（予想通りすなわち、ナンスカウント部分がある（上記参照）と「SR」の部分はまだ新鮮で有効であるとみなした場合）、それがクライアントハッシュを仮定して、要求されたリソース（へのアクセスを提供します）もちろん、正しく検証します。サーバはナンスのサーバ部分が失効していると考える場合（「SR」の値が「TTL」秒後に使用されている場合など）ただし、サーバは、以下でSCRAM機構名を含む「不正401」を返し属性：新しい「SR」、「真=古い」、およびオプションの「TTL」。 「古い」は、パスワードをユーザーに依頼する必要がないことをクライアントに信号を属性。"
    },
    {
      "indent": 6,
      "text": "Formally, the \"stale\" attribute is defined as a flag, indicating that the previous request from the client was rejected because the nonce value was stale. If stale is TRUE (case-insensitive), the client may wish to simply retry the request with a new encrypted response without reprompting the user for a new username and password. The server should only set stale to TRUE if it receives a request for which the nonce is invalid but with a valid digest for that nonce (indicating that the client knows the correct username/password). If stale is FALSE or anything other than TRUE, or the stale directive is not present, the username and/or password are invalid, and new values must be obtained.",
      "ja": "正式には、「古い」属性は、ノンス値が古くなったため、クライアントからの前の要求が拒否されたことを示すフラグとして定義されます。古くは（大文字と小文字を区別しない）TRUEの場合、クライアントは単に新しいユーザのユーザ名とパスワードをrepromptingことなく、新しい暗号化された応答で要求を再試行することを望むかもしれません。サーバーは（クライアントが正しいユーザ名/パスワードを知っていることを示す）そのナンスのために、それはnonceが無効である要求を受信した場合にTRUEに古い設定が、有効なダイジェストを持つ必要があります。古いがFALSEまたはTRUE以外のものである、または古いディレクティブが存在しない場合は、ユーザ名および/またはパスワードが無効であり、そして新しい値を取得する必要があります。"
    },
    {
      "indent": 3,
      "text": "When constructing AuthMessage (see Section 3) to be used for calculating client and server proofs, \"client-first-message-bare\" and \"server-first-message\" are reconstructed from data known to the client and the server.",
      "ja": "AuthMessageを構築する場合、クライアントとサーバ証明を計算するために使用される（セクション3を参照）、「クライアント・ファースト・メッセージ裸」および「サーバ・ファースト・メッセージ」は、クライアントとサーバに知られているデータから再構成されています。"
    },
    {
      "indent": 3,
      "text": "Reauthentication can look like this:",
      "ja": "再認証は次のようになります。"
    },
    {
      "indent": 3,
      "text": "C: GET /resource HTTP/1.1 C: Host: server.example.com C: [...]",
      "ja": "C：GET /リソースのHTTP / 1.1 C：ホスト：server.example.comのC：[...]"
    },
    {
      "indent": 3,
      "text": "S: HTTP/1.1 401 Unauthorized S: WWW-Authenticate: Digest realm=\"realm1@example.com\", Digest realm=\"realm2@example.com\", Digest realm=\"realm3@example.com\", SCRAM-SHA-256 realm=\"realm3@example.com\", SCRAM-SHA-256 realm=\"testrealm@example.com\", sr=%hvYDpWUa2RaTC AfuxFIlj)hNlF SCRAM-SHA-256 realm=\"testrealm2@example.com\", sr=AAABBBCCCDDD, ttl=120 S: [...]",
      "ja": "S：HTTP / 1.1 401不正なS：WWW認証：= \"realm1@example.com\"、ダイジェスト分野= \"realm2@example.com\"、ダイジェストレルム= \"realm3@example.com\" レルムをダイジェスト、SCRAM-SHA- 256レルム= \"realm3@example.com\"、SCRAM-SHA-256レルム= \"testrealm@example.com\"、SR =％hvYDpWUa2RaTC AfuxFIlj）HNLF SCRAM-SHA-256レルム= \"testrealm2@example.com\"、SR = AAABBBCCCDDD、TTL = 120 S：[...]"
    },
    {
      "indent": 3,
      "text": "[The client authenticates as usual to realm \"testrealm@example.com\"] [Some time later, client decides to reauthenticate. It will use the cached \"i\" (4096) and \"s\" (W22ZaJ0SNY7soEsUEjb6gQ==) from earlier exchanges. It will use the nonce-value of 4096 together with the server advertised \"sr\" value as the server part of the \"r\".]",
      "ja": "[クライアントレルム「testrealm@example.com」にいつものように認証を行う] [しばらくして、クライアントが再認証することを決定しました。これは、以前のやり取りから、キャッシュされた \"I\"（4096）と \"S\"（W22ZaJ0SNY7soEsUEjb6gQ ==）を使用します。これは、「R」のサーバー一部としての「SR」値アドバタイズサーバと共に4096のノンス値を使用します。]"
    },
    {
      "indent": 3,
      "text": "C: GET /resource HTTP/1.1 C: Host: server.example.com C: Authorization: SCRAM-SHA-256 realm=\"testrealm@example.com\", data=Yz1iaXdzLHI9ck9wck5HZndFYmVSV2diTkVrcU80MDk2JWh2WURwV1VhM lJhVENBZnV4RklsailoTmxGLHA9ZEh6YlphcFdJazRqVWhOK1V0ZTl5dGFnOX pqZk1IZ3NxbW1pejdBbmRWUT0K",
      "ja": "C：GET /リソースHTTP / 1.1 C：ホスト：server.example.com C：認可：SCRAM-SHA-256レルム= \"testrealm@example.com\"、データ= Yz1iaXdzLHI9ck9wck5HZndFYmVSV2diTkVrcU80MDk2JWh2WURwV1VhM lJhVENBZnV4RklsailoTmxGLHA9ZEh6YlphcFdJazRqVWhOK1V0ZTl5dGFnOX pqZk1IZ3NxbW1pejdBbmRWUT0K"
    },
    {
      "indent": 3,
      "text": "C: [...]",
      "ja": "C：[...]"
    },
    {
      "indent": 3,
      "text": "S: HTTP/1.1 200 Ok S: Authentication-Info: sid=AAAABBBBCCCCDDDD, data=dj02cnJpVFJCaTIzV3BSUi93dHVwK21NaFVaVW4vZEI1bkxUSlJzamw5N Uc0PQo= S: [...Other header fields and resource body...]",
      "ja": "S：HTTP / 1.1 200 OK S：認証-情報：SID = AAAABBBBCCCCDDDD、データ= dj02cnJpVFJCaTIzV3BSUi93dHVwK21NaFVaVW4vZEI1bkxUSlJzamw5N Uc0PQo = S：[...他のヘッダフィールドとリソース本体...]"
    },
    {
      "indent": 0,
      "text": "6. Use of the Authentication-Info Header Field with SCRAM",
      "section_title": true,
      "ja": "スクラムでの認証、情報ヘッダーフィールドの6."
    },
    {
      "indent": 3,
      "text": "When used with SCRAM, the Authentication-Info header field is allowed in the trailer of an HTTP message transferred via chunked transfer-coding.",
      "ja": "SCRAMと共に使用される場合、認証-Infoヘッダフィールドは、チャンク転送符号化を介して転送されるHTTPメッセージのトレーラーで許可されています。"
    },
    {
      "indent": 0,
      "text": "7. Formal Syntax",
      "section_title": true,
      "ja": "7.正式な構文"
    },
    {
      "indent": 3,
      "text": "The following syntax specification uses the Augmented Backus-Naur Form (ABNF) notation as specified in [RFC5234].",
      "ja": "以下の構文仕様は、[RFC5234]で指定された拡張バッカス・ナウアフォーム（ABNF）の表記を使用します。"
    },
    {
      "indent": 6,
      "text": "ALPHA = <as defined in RFC 5234 Appendix B.1> DIGIT = <as defined in RFC 5234 Appendix B.1>",
      "ja": "DIGIT = <RFC 5234、付録B.1で定義されるように> ALPHA = <RFC 5234付録B.1に定義されて>"
    },
    {
      "indent": 6,
      "text": "base64-char = ALPHA / DIGIT / \"/\" / \"+\"",
      "ja": "base64で文字= ALPHA / DIGIT / \"/\" / \"+\""
    },
    {
      "indent": 6,
      "text": "base64-4 = 4base64-char",
      "ja": "Bsi64-4 = 4 Bs64​​ 4"
    },
    {
      "indent": 6,
      "text": "base64-3 = 3base64-char \"=\"",
      "ja": "Basit4-3 = 3 Basit4-CHAR \"=\""
    },
    {
      "indent": 6,
      "text": "base64-2 = 2base64-char \"==\"",
      "ja": "Bsi64-2 = 2 Bs64​​ 4 \"==\""
    },
    {
      "indent": 6,
      "text": "base64 = *base64-4 [base64-3 / base64-2]",
      "ja": "BASE64 = * base64-4 [base64-3 / base64-2]"
    },
    {
      "indent": 6,
      "text": "sr = \"sr=\" s-nonce ;; s-nonce is defined in RFC 5802.",
      "ja": "SR = \"SR =\" S-ナンス;; S-ナンスは、RFC 5802で定義されています。"
    },
    {
      "indent": 6,
      "text": "data = \"data=\" base64 ;; The \"data\" attribute value is base64-encoded ;; SCRAM challenge or response defined in ;; RFC 5802.",
      "ja": "データ= \"データ=\" base64で;; 「データ」属性値はbase64エンコードです;;で定義されたスクラムチャレンジまたは応答;; RFC 5802。"
    },
    {
      "indent": 6,
      "text": "ttl = \"ttl=\" 1*DIGIT ;; \"sr\" value validity in seconds. ;; No leading 0s.",
      "ja": "TTL = \"TTL =\" 1 * DIGIT ;;秒単位の「SR」値の妥当性。 ;;いいえ大手0ません。"
    },
    {
      "indent": 6,
      "text": "reauth-s-nonce = nonce-count s-nonce",
      "ja": "REAUTH-S-ナンス=ナンスカウントS-ナンス"
    },
    {
      "indent": 6,
      "text": "nonce-count = posit-number ;; posit-number is defined in RFC 5802. ;; The initial value is taken from the \"i\" ;; attribute for the user and is incremented ;; by 1 on each successful reauthentication.",
      "ja": "ナンスカウント= POSIT番号;;断定-数はRFC 5802で定義されています;;初期値は「I」から取られ;;ユーザーの属性およびインクリメントされ;;成功するたびに再認証の1によります。"
    },
    {
      "indent": 6,
      "text": "sid = \"sid=\" token ;; See token definition in RFC 7235.",
      "ja": "SID = \"SID =\" トークン;; RFC 7235でトークン定義を参照してください。"
    },
    {
      "indent": 6,
      "text": "stale = \"stale=\" ( \"true\" / \"false\" )",
      "ja": "古い= \"陳腐=\"（ \"真\" / \"偽\"）"
    },
    {
      "indent": 6,
      "text": "realm = \"realm=\" <as defined in RFC 7235>",
      "ja": "<RFC 7235で定義されている>分野= \"分野=\""
    },
    {
      "indent": 0,
      "text": "8. Security Considerations",
      "section_title": true,
      "ja": "8.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "If the authentication exchange is performed without a strong session encryption (such as TLS with data confidentiality), then a passive eavesdropper can gain sufficient information to mount an offline dictionary or brute-force attack that can be used to recover the user's password. The amount of time necessary for this attack depends on the cryptographic hash function selected, the strength of the password, and the iteration count supplied by the server. SCRAM allows the server/server administrator to increase the iteration count over time in order to slow down the above attacks. (Note that a server that is only in possession of StoredKey and ServerKey can't automatically increase the iteration count upon successful authentication. Such an increase would require resetting the user's password.) An external security layer with strong encryption will prevent these attacks.",
      "ja": "認証交換が（そのようなデータの機密性とTLSなど）の強力なセッションの暗号化なしで実行されている場合は、受動的盗聴者は、ユーザーのパスワードを回復するために使用することができ、オフライン辞書やブルートフォース攻撃をマウントするのに十分な情報を得ることができます。この攻撃のために必要な時間の量は、選択された暗号ハッシュ関数、パスワードの強度、およびサーバから提供される反復回数に依存します。 SCRAMは、サーバ/サーバ管理者は、上記の攻撃を遅くするために、時間をかけて反復回数を増やすことができます。 （のみStoredKeyとサーバキーを所有しているサーバが自動的に認証が成功すると、反復回数を増やすことはできません。このような増加は、ユーザーのパスワードをリセットする必要になります。）強力な暗号化と外部のセキュリティ層は、これらの攻撃を防ぐことができます。"
    },
    {
      "indent": 3,
      "text": "If the authentication information is stolen from the authentication database, then an offline dictionary or brute-force attack can be used to recover the user's password. The use of salt mitigates this attack somewhat by requiring a separate attack on each password. Authentication mechanisms that protect against this attack are available (e.g., the Encrypted Key Exchange (EKE) class of mechanisms). RFC 2945 [RFC2945] is an example of such technology.",
      "ja": "認証情報が認証データベースから盗まれている場合は、オフライン辞書やブルートフォース攻撃は、ユーザーのパスワードを回復するために使用することができます。塩の使用は、各パスワードに別の攻撃を要求することによって、多少この攻撃を軽減します。この攻撃から守る認証メカニズムが用意されています（例えば、暗号化キー交換（EKE）のメカニズムのクラス）。 RFC 2945 [RFC2945]は、そのような技術の一例です。"
    },
    {
      "indent": 3,
      "text": "If an attacker obtains the authentication information from the authentication repository and either eavesdrops on one authentication exchange or impersonates a server, the attacker gains the ability to impersonate that user to all servers providing SCRAM access using the same hash function, password, iteration count, and salt. For this reason, it is important to use randomly generated salt values.",
      "ja": "攻撃者は、認証リポジトリから認証情報を取得し、いずれかの認証交換に盗聴またはサーバーを偽装した場合、攻撃者はすべて同じハッシュ関数を使用してSCRAMへのアクセスを提供するサーバー、パスワード、反復回数にそのユーザーを偽装する能力を獲得し、塩。このため、ランダムに生成されたsalt値を使用することが重要です。"
    },
    {
      "indent": 3,
      "text": "SCRAM does not negotiate which hash function to use. Hash function negotiation is left to the HTTP authentication mechanism negotiation. It is important that clients be able to sort a locally available list of mechanisms by preference so that the client may pick the most preferred of a server's advertised mechanism list. This preference order is not specified here as it is a local matter. The preference order should include objective and subjective notions of mechanism cryptographic strength (e.g., SCRAM with SHA-256 should be preferred over SCRAM with SHA-1).",
      "ja": "SCRAMは、使用するハッシュ関数を交渉していません。ハッシュ関数交渉はHTTP認証メカニズムの交渉に委ねられています。クライアントは、クライアントがサーバのアドバタイズされたメカニズムのリストの最も好ましいを選ぶことができるように好みによってメカニズムのローカルで利用可能なリストを並べ替えることができることが重要です。それはローカルの問題であるとして、この優先順位は、ここで指定されていません。優先順位は、機構暗号の強さ（例えば、SHA-256 SCRAMは、SHA-1とSCRAM好まれるべきである）の客観的および主観的概念を含むべきです。"
    },
    {
      "indent": 3,
      "text": "This document recommends use of SCRAM with SHA-256 hash. SCRAM-SHA-1 is registered for database compatibility with implementations of RFC 5802 (such as IMAP or XMPP servers) that want to also expose HTTP access to a related service, but it is not recommended for new deployments.",
      "ja": "この文書では、SHA-256ハッシュをSCRAMの使用を推奨しています。 SCRAM-SHA-1はまた、関連サービスへのHTTPアクセスを公開する（たとえば、IMAPやXMPPサーバなど）RFC 5802の実装とデータベースの互換性のために登録されているが、それは、新たな展開のために推奨されていません。"
    },
    {
      "indent": 3,
      "text": "A hostile server can perform a computational denial-of-service attack on clients by sending a big iteration count value. In order to defend against that, a client implementation can pick a maximum iteration count that it is willing to use and reject any values that exceed that threshold (in such cases, the client, of course, has to fail the authentication).",
      "ja": "敵対的なサーバは、大きな反復カウント値を送信することにより、クライアント上の計算サービス拒否攻撃を行うことができます。それに対して防御するために、クライアントの実装は、（そのような場合、クライアントは、もちろん、認証に失敗しなければならない）、その閾値を超える任意の値を使用し、拒絶する意思がある最大繰り返し回数を選択することができます。"
    },
    {
      "indent": 3,
      "text": "See [RFC4086] for more information about generating randomness.",
      "ja": "ランダム性の生成の詳細については、[RFC4086]を参照してください。"
    },
    {
      "indent": 0,
      "text": "9. IANA Considerations",
      "section_title": true,
      "ja": "9. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "New mechanisms in the SCRAM family are registered according to the IANA procedure specified in [RFC5802].",
      "ja": "SCRAMファミリーの新しいメカニズムは[RFC5802]で指定されたIANA手順に従って登録されています。"
    },
    {
      "indent": 3,
      "text": "Note to future \"SCRAM-\" mechanism designers: Each new \"SCRAM-\" HTTP authentication mechanism MUST be explicitly registered with IANA and MUST comply with \"SCRAM-\" mechanism naming convention defined in Section 4 of this document.",
      "ja": "将来の「SCRAM-」機構設計者への注意：それぞれの新しい「SCRAM-」HTTP認証メカニズムを明示的にIANAに登録しなければなりませんし、このドキュメントのセクション4で定義された「SCRAM-」機構命名規則を遵守しなければなりません。"
    },
    {
      "indent": 3,
      "text": "IANA has added the following entries to the \"HTTP Authentication Schemes\" registry defined in HTTP/1.1, Part 7 [RFC7235]:",
      "ja": "IANAは、HTTP / 1.1、パート7 [RFC7235]で定義された「HTTP認証方式」レジストリに次のエントリを追加しました。"
    },
    {
      "indent": 6,
      "text": "Authentication Scheme Name: SCRAM-SHA-256 Pointer to specification text: RFC 7804 Notes (optional): (none)",
      "ja": "認証スキーム名：SCRAM-SHA-256のポインタがテキスト仕様に：RFC 7804をノート（オプション）：（なし）"
    },
    {
      "indent": 6,
      "text": "Authentication Scheme Name: SCRAM-SHA-1 Pointer to specification text: RFC 7804 Notes (optional): (none)",
      "ja": "認証スキーム名：SCRAM-SHA-1ポインタがテキスト仕様に：RFC 7804をノート（オプション）：（なし）"
    },
    {
      "indent": 0,
      "text": "10. Design Motivations",
      "section_title": true,
      "ja": "10.デザイン動機"
    },
    {
      "indent": 3,
      "text": "The following design goals shaped this document. Note that some of the goals have changed since the initial draft version of the document.",
      "ja": "以下の設計目標は、この文書を形。目標のいくつかは、文書の最初のドラフト版から変更されていることに注意してください。"
    },
    {
      "indent": 3,
      "text": "o The HTTP authentication mechanism has all modern features: support for internationalized usernames and passwords.",
      "ja": "国際化ユーザ名とパスワードをサポートします。o HTTP認証メカニズムは、すべての現代的な機能を持っています。"
    },
    {
      "indent": 3,
      "text": "o The protocol supports mutual authentication.",
      "ja": "Oプロトコルは、相互認証をサポートしています。"
    },
    {
      "indent": 3,
      "text": "o The authentication information stored in the authentication database is not sufficient by itself to impersonate the client.",
      "ja": "O認証データベースに格納された認証情報は、クライアントを偽装するために単独では不十分です。"
    },
    {
      "indent": 3,
      "text": "o The server does not gain the ability to impersonate the client to other servers (with an exception for server-authorized proxies), unless such other servers allow SCRAM authentication and use the same salt and iteration count for the user.",
      "ja": "Oサーバーは、他のサーバーは、SCRAM認証を許可しない限り、他のサーバーへ（サーバー許可プロキシの例外を除いて）クライアントを偽装する能力を獲得し、ユーザーのために同じ塩と繰り返し回数を使用していません。"
    },
    {
      "indent": 3,
      "text": "o The mechanism is extensible, but (hopefully) not over-engineered in this respect.",
      "ja": "機構oを拡張可能であるが、（たぶん）は、この点においてオーバーエンジニアリング。"
    },
    {
      "indent": 3,
      "text": "o The mechanism is easier to implement than HTTP Digest in both clients and servers.",
      "ja": "Oメカニズムは、クライアントとサーバの両方でHTTPダイジェストよりも実装が容易です。"
    },
    {
      "indent": 3,
      "text": "o The protocol supports 1 round-trip reauthentication.",
      "ja": "Oプロトコルは、1往復の再認証をサポートしています。"
    },
    {
      "indent": 0,
      "text": "11. References",
      "section_title": true,
      "ja": "11.参考文献"
    },
    {
      "indent": 0,
      "text": "11.1. Normative References",
      "section_title": true,
      "ja": "11.1. 引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC2104] Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, DOI 10.17487/RFC2104, February 1997, <http://www.rfc-editor.org/info/rfc2104>.",
      "ja": "[RFC2104] Krawczyk、H.、ベラー、M.、およびR.カネッティ、 \"HMAC：メッセージ認証のための鍵付きハッシュ化\"、RFC 2104、DOI 10.17487 / RFC2104、1997年2月、<HTTP：//www.rfc-editor .ORG /情報/ RFC2104>。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<http://www.rfc-editor.org/info/ RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC3629] Yergeau, F., \"UTF-8, a transformation format of ISO 10646\", STD 63, RFC 3629, DOI 10.17487/RFC3629, November 2003, <http://www.rfc-editor.org/info/rfc3629>.",
      "ja": "[RFC3629] Yergeau、F.、 \"UTF-8、ISO 10646の変換フォーマット\"、STD 63、RFC 3629、DOI 10.17487 / RFC3629、2003年11月、<http://www.rfc-editor.org/info/ RFC3629>。"
    },
    {
      "indent": 3,
      "text": "[RFC4648] Josefsson, S., \"The Base16, Base32, and Base64 Data Encodings\", RFC 4648, DOI 10.17487/RFC4648, October 2006, <http://www.rfc-editor.org/info/rfc4648>.",
      "ja": "[RFC4648] Josefsson氏、S.、 \"Base16、Base32、およびBase64でデータエンコーディング\"、RFC 4648、DOI 10.17487 / RFC4648、2006年10月、<http://www.rfc-editor.org/info/rfc4648>。"
    },
    {
      "indent": 3,
      "text": "[RFC5234] Crocker, D., Ed. and P. Overell, \"Augmented BNF for Syntax Specifications: ABNF\", STD 68, RFC 5234, DOI 10.17487/RFC5234, January 2008, <http://www.rfc-editor.org/info/rfc5234>.",
      "ja": "[RFC5234]クロッカー、D.、エド。そして、P. Overell、 \"構文仕様のための増大しているBNF：ABNF\"、STD 68、RFC 5234、DOI 10.17487 / RFC5234、2008年1月、<http://www.rfc-editor.org/info/rfc5234>。"
    },
    {
      "indent": 3,
      "text": "[RFC5802] Newman, C., Menon-Sen, A., Melnikov, A., and N. Williams, \"Salted Challenge Response Authentication Mechanism (SCRAM) SASL and GSS-API Mechanisms\", RFC 5802, DOI 10.17487/RFC5802, July 2010, <http://www.rfc-editor.org/info/rfc5802>.",
      "ja": "[RFC5802]ニューマン、C.、メノンセン、A.、メルニコフ、A.、およびN.ウィリアムズ、 \"塩蔵チャレンジレスポンス認証メカニズム（SCRAM）SASLとGSS-APIメカニズム\"、RFC 5802、DOI 10.17487 / RFC5802、 2010年7月、<http://www.rfc-editor.org/info/rfc5802>。"
    },
    {
      "indent": 3,
      "text": "[RFC6234] Eastlake 3rd, D. and T. Hansen, \"US Secure Hash Algorithms (SHA and SHA-based HMAC and HKDF)\", RFC 6234, DOI 10.17487/RFC6234, May 2011, <http://www.rfc-editor.org/info/rfc6234>.",
      "ja": "[RFC6234]イーストレイク3日、D.とT.ハンセン、 \"米国のセキュアハッシュアルゴリズム（SHAとHMACとHKDF SHAベース）\"、RFC 6234、DOI 10.17487 / RFC6234、2011年5月、<のhttp：//www.rfc- editor.org/info/rfc6234>。"
    },
    {
      "indent": 3,
      "text": "[RFC7235] Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Authentication\", RFC 7235, DOI 10.17487/RFC7235, June 2014, <http://www.rfc-editor.org/info/rfc7235>.",
      "ja": "[RFC7235]フィールディング、R.、エド。及びJ. Reschke、編、 \"ハイパーテキスト転送プロトコル（HTTP / 1.1）：認証\"、RFC 7235、DOI 10.17487 / RFC7235、2014年6月、<http://www.rfc-editor.org/info/rfc7235>。"
    },
    {
      "indent": 3,
      "text": "[RFC7613] Saint-Andre, P. and A. Melnikov, \"Preparation, Enforcement, and Comparison of Internationalized Strings Representing Usernames and Passwords\", RFC 7613, DOI 10.17487/RFC7613, August 2015, <http://www.rfc-editor.org/info/rfc7613>.",
      "ja": "[RFC7613]サンアンドレ、P.およびA.メルニコフ、 \"準備、施行、およびユーザ名とパスワードを表現する国際化された文字列の比較\"、RFC 7613、DOI 10.17487 / RFC7613、2015年8月、<のhttp：//www.rfc- editor.org/info/rfc7613>。"
    },
    {
      "indent": 3,
      "text": "[RFC7615] Reschke, J., \"HTTP Authentication-Info and Proxy-Authentication-Info Response Header Fields\", RFC 7615, DOI 10.17487/RFC7615, September 2015, <http://www.rfc-editor.org/info/rfc7615>.",
      "ja": "[RFC7615] Reschke、J.、 \"HTTP認証-INFOとプロキシ認証-INFO応答ヘッダフィールド\"、RFC 7615、DOI 10.17487 / RFC7615、2015年9月、<http://www.rfc-editor.org/info/ rfc7615>。"
    },
    {
      "indent": 3,
      "text": "[RFC7677] Hansen, T., \"SCRAM-SHA-256 and SCRAM-SHA-256-PLUS Simple Authentication and Security Layer (SASL) Mechanisms\", RFC 7677, DOI 10.17487/RFC7677, November 2015, <http://www.rfc-editor.org/info/rfc7677>.",
      "ja": "[RFC7677]ハンセン、T.、 \"SCRAM-SHA-256とSCRAM-SHA-256-PLUS簡易認証セキュリティー層（SASL）のメカニズム\"、RFC 7677、DOI 10.17487 / RFC7677、2015年11月、<のhttp：// WWW .rfc-editor.org /情報/ rfc7677>。"
    },
    {
      "indent": 0,
      "text": "11.2. Informative References",
      "section_title": true,
      "ja": "11.2. 参考文献"
    },
    {
      "indent": 3,
      "text": "[RFC2865] Rigney, C., Willens, S., Rubens, A., and W. Simpson, \"Remote Authentication Dial In User Service (RADIUS)\", RFC 2865, DOI 10.17487/RFC2865, June 2000, <http://www.rfc-editor.org/info/rfc2865>.",
      "ja": "[RFC2865] Rigney、C.、ウィレンス、S.、ルーベン、A.、およびW.シンプソン、RFC 2865 \"ユーザーサービス（RADIUS）でリモート認証ダイヤル\"、DOI 10.17487 / RFC2865、2000年6月、<のhttp：/ /www.rfc-editor.org/info/rfc2865>。"
    },
    {
      "indent": 3,
      "text": "[RFC2898] Kaliski, B., \"PKCS #5: Password-Based Cryptography Specification Version 2.0\", RFC 2898, DOI 10.17487/RFC2898, September 2000, <http://www.rfc-editor.org/info/rfc2898>.",
      "ja": "[RFC2898] Kaliski、B.、 \"PKCS＃5：パスワードベースの暗号化仕様バージョン2.0\"、RFC 2898、DOI 10.17487 / RFC2898、2000年9月、<http://www.rfc-editor.org/info/rfc2898> 。"
    },
    {
      "indent": 3,
      "text": "[RFC2945] Wu, T., \"The SRP Authentication and Key Exchange System\", RFC 2945, DOI 10.17487/RFC2945, September 2000, <http://www.rfc-editor.org/info/rfc2945>.",
      "ja": "[RFC2945]呉、T.、 \"SRP認証と鍵交換システム\"、RFC 2945、DOI 10.17487 / RFC2945、2000年9月、<http://www.rfc-editor.org/info/rfc2945>。"
    },
    {
      "indent": 3,
      "text": "[RFC4086] Eastlake 3rd, D., Schiller, J., and S. Crocker, \"Randomness Requirements for Security\", BCP 106, RFC 4086, DOI 10.17487/RFC4086, June 2005, <http://www.rfc-editor.org/info/rfc4086>.",
      "ja": "[RFC4086]イーストレーク3日、D.、シラー、J.、およびS.クロッカー、 \"セキュリティのためのランダム要件\"、BCP 106、RFC 4086、DOI 10.17487 / RFC4086、2005年6月、<HTTP：//www.rfc-editor .ORG /情報/ RFC4086>。"
    },
    {
      "indent": 3,
      "text": "[RFC4510] Zeilenga, K., Ed., \"Lightweight Directory Access Protocol (LDAP): Technical Specification Road Map\", RFC 4510, DOI 10.17487/RFC4510, June 2006, <http://www.rfc-editor.org/info/rfc4510>.",
      "ja": "[RFC4510] Zeilenga、K.、エド、 \"ライトウェイトディレクトリアクセスプロトコル（LDAP）：技術仕様ロードマップ\"。、RFC 4510、DOI 10.17487 / RFC4510、2006年6月、<http://www.rfc-editor.org/情報/ rfc4510>。"
    },
    {
      "indent": 3,
      "text": "[RFC4949] Shirey, R., \"Internet Security Glossary, Version 2\", FYI 36, RFC 4949, DOI 10.17487/RFC4949, August 2007, <http://www.rfc-editor.org/info/rfc4949>.",
      "ja": "[RFC4949] Shirey、R.、 \"インターネットセキュリティ用語集、バージョン2\"、FYI 36、RFC 4949、DOI 10.17487 / RFC4949、2007年8月、<http://www.rfc-editor.org/info/rfc4949>。"
    },
    {
      "indent": 3,
      "text": "[RFC6331] Melnikov, A., \"Moving DIGEST-MD5 to Historic\", RFC 6331, DOI 10.17487/RFC6331, July 2011, <http://www.rfc-editor.org/info/rfc6331>.",
      "ja": "[RFC6331]メルニコフ、A.、 \"歴史的にDIGEST-MD5の移動\"、RFC 6331、DOI 10.17487 / RFC6331、2011年7月、<http://www.rfc-editor.org/info/rfc6331>。"
    },
    {
      "indent": 3,
      "text": "[Unicode-UAX15] The Unicode Consortium, \"Unicode Standard Annex #15: Unicode Normalization Forms\", June 2015, <http://www.unicode.org/reports/tr15/>.",
      "ja": "[ユニコードUAX15]ユニコードコンソーシアム、 \"Unicode規格付属書＃15：Unicode正規化フォーム\"、2015年6月、<http://www.unicode.org/reports/tr15/>。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "This document benefited from discussions on the mailing lists for the HTTPAuth, SASL, and Kitten working groups. The author would like to specially thank the co-authors of [RFC5802] from which lots of text was copied.",
      "ja": "この文書はHTTPAuth、SASLのためのメーリングリストでの議論、そして子猫ワーキンググループの恩恵を受けました。著者は、特別に大量のテキストがコピーされた[RFC5802]の共著者に感謝したいと思います。"
    },
    {
      "indent": 3,
      "text": "Thank you to Martin Thomson for the idea of adding the \"ttl\" attribute.",
      "ja": "「TTL」属性を追加するという考えのためにマーティン・トムソンに感謝します。"
    },
    {
      "indent": 3,
      "text": "Thank you to Julian F. Reschke for corrections regarding use of the Authentication-Info header field.",
      "ja": "認証-Infoヘッダーフィールドの使用に関する訂正のためのジュリアンF. Reschkeに感謝します。"
    },
    {
      "indent": 3,
      "text": "A special thank you to Tony Hansen for doing an early implementation and providing extensive comments on the document.",
      "ja": "特別には、早期実施を行うと、文書に関する広範なコメントを提供するためのトニー・ハンセンにお願いします。"
    },
    {
      "indent": 3,
      "text": "Thank you to Russ Housley, Stephen Farrell, Barry Leiba, and Tim Chown for doing detailed reviews of the document.",
      "ja": "ドキュメントの詳細なレビューを行うためのラスHousley、スティーブン・ファレル、バリー・レイバ、そしてティムCHOWNに感謝します。"
    },
    {
      "indent": 0,
      "text": "Author's Address",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Alexey Melnikov Isode Ltd",
      "ja": "アレクセイ・メルニコフISODE株式会社"
    },
    {
      "indent": 3,
      "text": "Email: Alexey.Melnikov@isode.com",
      "ja": "メール：Alexey.Melnikov@isode.com"
    }
  ]
}