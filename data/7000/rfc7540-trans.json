{
  "title": {
    "text": "RFC 7540 - Hypertext Transfer Protocol Version 2 (HTTP/2)",
    "ja": "RFC 7540 - ハイパーテキスト転送プロトコルバージョン2（HTTP / 2）"
  },
  "number": 7540,
  "created_at": "2019-10-30 03:03:57.120909+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                         M. Belshe\nRequest for Comments: 7540                                         BitGo\nCategory: Standards Track                                        R. Peon\nISSN: 2070-1721                                              Google, Inc\n                                                         M. Thomson, Ed.\n                                                                 Mozilla\n                                                                May 2015",
      "raw": true
    },
    {
      "indent": 13,
      "text": "Hypertext Transfer Protocol Version 2 (HTTP/2)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This specification describes an optimized expression of the semantics of the Hypertext Transfer Protocol (HTTP), referred to as HTTP version 2 (HTTP/2). HTTP/2 enables a more efficient use of network resources and a reduced perception of latency by introducing header field compression and allowing multiple concurrent exchanges on the same connection. It also introduces unsolicited push of representations from servers to clients.",
      "ja": "この仕様は、ハイパーテキスト転送プロトコル（HTTP）の意味論の最適化された発現を記述する、HTTPバージョン2（HTTP / 2）と呼ばれます。 HTTP / 2ヘッダフィールド圧縮を導入し、同じ接続上で複数の同時交換を可能にすることによって、ネットワークリソースとレイテンシの低減知覚のより効率的な使用を可能にします。また、サーバからクライアントへの表現の迷惑プッシュを紹介します。"
    },
    {
      "indent": 3,
      "text": "This specification is an alternative to, but does not obsolete, the HTTP/1.1 message syntax. HTTP's existing semantics remain unchanged.",
      "ja": "この仕様は、HTTP / 1.1メッセージの構文に代わるものですが、時代遅れません。 HTTPの既存のセマンティクスは変更されません。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 5741のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7540.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7540で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2015 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2015 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................4\n2. HTTP/2 Protocol Overview ........................................5\n   2.1. Document Organization ......................................6\n   2.2. Conventions and Terminology ................................6\n3. Starting HTTP/2 .................................................7\n   3.1. HTTP/2 Version Identification ..............................8\n   3.2. Starting HTTP/2 for \"http\" URIs ............................8\n        3.2.1. HTTP2-Settings Header Field .........................9\n   3.3. Starting HTTP/2 for \"https\" URIs ..........................10\n   3.4. Starting HTTP/2 with Prior Knowledge ......................10\n   3.5. HTTP/2 Connection Preface .................................11\n4. HTTP Frames ....................................................12\n   4.1. Frame Format ..............................................12\n   4.2. Frame Size ................................................13\n   4.3. Header Compression and Decompression ......................14\n5. Streams and Multiplexing .......................................15\n   5.1. Stream States .............................................16\n        5.1.1. Stream Identifiers .................................21\n        5.1.2. Stream Concurrency .................................22\n   5.2. Flow Control ..............................................22\n        5.2.1. Flow-Control Principles ............................23\n        5.2.2. Appropriate Use of Flow Control ....................24\n   5.3. Stream Priority ...........................................24\n        5.3.1. Stream Dependencies ................................25\n        5.3.2. Dependency Weighting ...............................26\n        5.3.3. Reprioritization ...................................26\n        5.3.4. Prioritization State Management ....................27\n        5.3.5. Default Priorities .................................28\n   5.4. Error Handling ............................................28\n        5.4.1. Connection Error Handling ..........................29\n        5.4.2. Stream Error Handling ..............................29",
      "raw": true
    },
    {
      "indent": 3,
      "text": "        5.4.3. Connection Termination .............................30\n   5.5. Extending HTTP/2 ..........................................30\n6. Frame Definitions ..............................................31\n   6.1. DATA ......................................................31\n   6.2. HEADERS ...................................................32\n   6.3. PRIORITY ..................................................34\n   6.4. RST_STREAM ................................................36\n   6.5. SETTINGS ..................................................36\n        6.5.1. SETTINGS Format ....................................38\n        6.5.2. Defined SETTINGS Parameters ........................38\n        6.5.3. Settings Synchronization ...........................39\n   6.6. PUSH_PROMISE ..............................................40\n   6.7. PING ......................................................42\n   6.8. GOAWAY ....................................................43\n   6.9. WINDOW_UPDATE .............................................46\n        6.9.1. The Flow-Control Window ............................47\n        6.9.2. Initial Flow-Control Window Size ...................48\n        6.9.3. Reducing the Stream Window Size ....................49\n   6.10. CONTINUATION .............................................49\n7. Error Codes ....................................................50\n8. HTTP Message Exchanges .........................................51\n   8.1. HTTP Request/Response Exchange ............................52\n        8.1.1. Upgrading from HTTP/2 ..............................53\n        8.1.2. HTTP Header Fields .................................53\n        8.1.3. Examples ...........................................57\n        8.1.4. Request Reliability Mechanisms in HTTP/2 ...........60\n   8.2. Server Push ...............................................60\n        8.2.1. Push Requests ......................................61\n        8.2.2. Push Responses .....................................63\n   8.3. The CONNECT Method ........................................64\n9. Additional HTTP Requirements/Considerations ....................65\n   9.1. Connection Management .....................................65\n        9.1.1. Connection Reuse ...................................66\n        9.1.2. The 421 (Misdirected Request) Status Code ..........66\n   9.2. Use of TLS Features .......................................67\n        9.2.1. TLS 1.2 Features ...................................67\n        9.2.2. TLS 1.2 Cipher Suites ..............................68\n10. Security Considerations .......................................69\n   10.1. Server Authority .........................................69\n   10.2. Cross-Protocol Attacks ...................................69\n   10.3. Intermediary Encapsulation Attacks .......................70\n   10.4. Cacheability of Pushed Responses .........................70\n   10.5. Denial-of-Service Considerations .........................70\n        10.5.1. Limits on Header Block Size .......................71\n        10.5.2. CONNECT Issues ....................................72\n   10.6. Use of Compression .......................................72\n   10.7. Use of Padding ...........................................73\n   10.8. Privacy Considerations ...................................73",
      "raw": true
    },
    {
      "indent": 3,
      "text": "11. IANA Considerations ...........................................74\n   11.1. Registration of HTTP/2 Identification Strings ............74\n   11.2. Frame Type Registry ......................................75\n   11.3. Settings Registry ........................................75\n   11.4. Error Code Registry ......................................76\n   11.5. HTTP2-Settings Header Field Registration .................77\n   11.6. PRI Method Registration ..................................78\n   11.7. The 421 (Misdirected Request) HTTP Status Code ...........78\n   11.8. The h2c Upgrade Token ....................................78\n12. References ....................................................79\n   12.1. Normative References .....................................79\n   12.2. Informative References ...................................81\nAppendix A. TLS 1.2 Cipher Suite Black List .......................83\nAcknowledgements ..................................................95\nAuthors' Addresses ................................................96",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "The Hypertext Transfer Protocol (HTTP) is a wildly successful protocol. However, the way HTTP/1.1 uses the underlying transport ([RFC7230], Section 6) has several characteristics that have a negative overall effect on application performance today.",
      "ja": "ハイパーテキスト転送プロトコル（HTTP）は、乱暴に成功したプロトコルです。しかしながら、HTTP / 1.1は、基礎となるトランスポート（[RFC7230]、セクション6）を使用する方法は、今日のアプリケーションのパフォーマンスに負の全体的な効果を持ついくつかの特性を有しています。"
    },
    {
      "indent": 3,
      "text": "In particular, HTTP/1.0 allowed only one request to be outstanding at a time on a given TCP connection. HTTP/1.1 added request pipelining, but this only partially addressed request concurrency and still suffers from head-of-line blocking. Therefore, HTTP/1.0 and HTTP/1.1 clients that need to make many requests use multiple connections to a server in order to achieve concurrency and thereby reduce latency.",
      "ja": "具体的には、HTTP / 1.0は、唯一の要求は、特定のTCP接続で同時に未解決であることを許可します。 HTTP / 1.1追加要求のパイプラインが、これは部分的にしか要求の同時実行に対処し、まだヘッドオブラインブロッキングに悩まされます。そのため、多くの要求をする必要があるHTTP / 1.0とHTTP / 1.1のクライアントは、並行処理を実現し、それによって、待ち時間を短縮するために、サーバーに複数の接続を使用します。"
    },
    {
      "indent": 3,
      "text": "Furthermore, HTTP header fields are often repetitive and verbose, causing unnecessary network traffic as well as causing the initial TCP [TCP] congestion window to quickly fill. This can result in excessive latency when multiple requests are made on a new TCP connection.",
      "ja": "さらに、HTTPヘッダフィールドは、不要なネットワークトラフィックを発生させるだけでなく、初期TCP [TCP]輻輳ウィンドウがすぐにいっぱいに引き起こし、しばしば反復的で冗長です。複数のリクエストが新しいTCP接続上で行われているとき、これは過度の待ち時間が発生することができます。"
    },
    {
      "indent": 3,
      "text": "HTTP/2 addresses these issues by defining an optimized mapping of HTTP's semantics to an underlying connection. Specifically, it allows interleaving of request and response messages on the same connection and uses an efficient coding for HTTP header fields. It also allows prioritization of requests, letting more important requests complete more quickly, further improving performance.",
      "ja": "HTTP / 2は、基になる接続にHTTPのセマンティクスの最適化されたマッピングを定義することにより、これらの問題に対処しています。具体的には、同じ接続上で要求及び応答メッセージのインターリーブを可能にし、HTTPヘッダフィールドのための効率的な符号化を使用します。また、さらにパフォーマンスを向上、より重要な要求はより迅速に完了させ、要求の優先順位付けを可能にします。"
    },
    {
      "indent": 3,
      "text": "The resulting protocol is more friendly to the network because fewer TCP connections can be used in comparison to HTTP/1.x. This means less competition with other flows and longer-lived connections, which in turn lead to better utilization of available network capacity.",
      "ja": "少数のTCP接続がHTTP / 1.1との比較で使用することができるので、結果としてプロトコルは、ネットワークに、より親しみやすいです。これは、他のフローと長い寿命の接続、ターンリードで利用可能なネットワーク容量の有効活用へと少ない競争を意味します。"
    },
    {
      "indent": 3,
      "text": "Finally, HTTP/2 also enables more efficient processing of messages through use of binary message framing.",
      "ja": "最後に、HTTP / 2はまた、バイナリメッセージフレーミングの使用を介してメッセージのより効率的な処理を可能にします。"
    },
    {
      "indent": 0,
      "text": "2. HTTP/2 Protocol Overview",
      "section_title": true,
      "ja": "2. HTTP / 2プロトコルの概要"
    },
    {
      "indent": 3,
      "text": "HTTP/2 provides an optimized transport for HTTP semantics. HTTP/2 supports all of the core features of HTTP/1.1 but aims to be more efficient in several ways.",
      "ja": "HTTP / 2 HTTPのセマンティクスのために最適化されたトランスポートを提供します。 HTTP / 2 HTTP / 1.1のコア機能のすべてをサポートしていますが、いくつかの点でより効率的になることを目指しています。"
    },
    {
      "indent": 3,
      "text": "The basic protocol unit in HTTP/2 is a frame (Section 4.1). Each frame type serves a different purpose. For example, HEADERS and DATA frames form the basis of HTTP requests and responses (Section 8.1); other frame types like SETTINGS, WINDOW_UPDATE, and PUSH_PROMISE are used in support of other HTTP/2 features.",
      "ja": "HTTP / 2の基本的なプロトコルユニットは、フレーム（セクション4.1）です。各フレームタイプは、異なる目的を果たします。例えば、ヘッダとデータフレームは、HTTP要求および応答（セクション8.1）の基礎を形成します。 SETTINGS、WINDOW_UPDATE、及びPUSH_PROMISEのような他のフレームタイプは、他のHTTP / 2機能のサポートに使用されています。"
    },
    {
      "indent": 3,
      "text": "Multiplexing of requests is achieved by having each HTTP request/ response exchange associated with its own stream (Section 5). Streams are largely independent of each other, so a blocked or stalled request or response does not prevent progress on other streams.",
      "ja": "要求の多重化は、それ自身のストリーム（セクション5）に関連付けられた各HTTP要求/応答交換を有することによって達成されます。ストリームは、互いにほぼ独立しているので、ブロックまたは他のストリームの進展を妨げない要求または応答を失速します。"
    },
    {
      "indent": 3,
      "text": "Flow control and prioritization ensure that it is possible to efficiently use multiplexed streams. Flow control (Section 5.2) helps to ensure that only data that can be used by a receiver is transmitted. Prioritization (Section 5.3) ensures that limited resources can be directed to the most important streams first.",
      "ja": "フロー制御と優先順位付けは、効率的に多重化ストリームを使用することが可能であることを確認してください。フロー制御（セクション5.2）は、受信機によって使用されることができるデータのみが送信されることを確実にするのに役立ちます。優先順位付け（5.3節）は、限られたリソースを最初に最も重要な流れに向けることができることを保証します。"
    },
    {
      "indent": 3,
      "text": "HTTP/2 adds a new interaction mode whereby a server can push responses to a client (Section 8.2). Server push allows a server to speculatively send data to a client that the server anticipates the client will need, trading off some network usage against a potential latency gain. The server does this by synthesizing a request, which it sends as a PUSH_PROMISE frame. The server is then able to send a response to the synthetic request on a separate stream.",
      "ja": "HTTP / 2は、サーバがクライアント（8.2節）への回答をプッシュすることができる新しい対話モードを追加します。サーバプッシュサーバが投機的にサーバはクライアントが潜在的な待ち時間のゲインに対するいくつかのネットワークの使用状況をトレードオフ、必要があるでしょう見込んでクライアントにデータを送信することができます。サーバーは、それがPUSH_PROMISEフレームとして送信要求を、合成することによってこれを行います。次に、サーバは別のストリームに合成要求に対する応答を送信することができます。"
    },
    {
      "indent": 3,
      "text": "Because HTTP header fields used in a connection can contain large amounts of redundant data, frames that contain them are compressed (Section 4.3). This has especially advantageous impact upon request sizes in the common case, allowing many requests to be compressed into one packet.",
      "ja": "接続に使用されるHTTPヘッダーフィールドは、冗長データを大量に含有することができるので、それらを含むフレーム（セクション4.3）に圧縮されます。これは、多くの要求が1つのパケットに圧縮することを可能にする、一般的な場合に要求サイズ際に特に有利な影響を有します。"
    },
    {
      "indent": 0,
      "text": "2.1. Document Organization",
      "section_title": true,
      "ja": "2.1. マニュアルの構成"
    },
    {
      "indent": 3,
      "text": "The HTTP/2 specification is split into four parts:",
      "ja": "HTTP / 2仕様は、4つの部分に分割されます。"
    },
    {
      "indent": 3,
      "text": "o Starting HTTP/2 (Section 3) covers how an HTTP/2 connection is initiated.",
      "ja": "O HTTP / 2（第3節）を起動すると、HTTP / 2接続が開始される方法を説明します。"
    },
    {
      "indent": 3,
      "text": "o The frame (Section 4) and stream (Section 5) layers describe the way HTTP/2 frames are structured and formed into multiplexed streams.",
      "ja": "フレーム（セクション4）と流れO（セクション5）の層は、HTTP / 2フレーム構造とストリーム多重に形成されている方法を記載しています。"
    },
    {
      "indent": 3,
      "text": "o Frame (Section 6) and error (Section 7) definitions include details of the frame and error types used in HTTP/2.",
      "ja": "Oフレーム（第6節）とエラー（セクション7）の定義は、HTTP / 2で使用されるフレームとエラーの種類の詳細を含みます。"
    },
    {
      "indent": 3,
      "text": "o HTTP mappings (Section 8) and additional requirements (Section 9) describe how HTTP semantics are expressed using frames and streams.",
      "ja": "O HTTPマッピング（セクション8）及び追加要件（セクション9）は、HTTPセマンティクスは、フレームを用いて表現し、ストリームである方法について説明します。"
    },
    {
      "indent": 3,
      "text": "While some of the frame and stream layer concepts are isolated from HTTP, this specification does not define a completely generic frame layer. The frame and stream layers are tailored to the needs of the HTTP protocol and server push.",
      "ja": "フレームおよびストリーム層の概念のいくつかは、HTTPから単離されているが、本明細書は完全に一般的なフレーム層を定義していません。フレームおよびストリーム層は、HTTPプロトコルとサーバプッシュのニーズに合わせて調整されています。"
    },
    {
      "indent": 0,
      "text": "2.2. Conventions and Terminology",
      "section_title": true,
      "ja": "2.2. 表記と用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [RFC2119].",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はRFC 2119 [RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 3,
      "text": "All numeric values are in network byte order. Values are unsigned unless otherwise indicated. Literal values are provided in decimal or hexadecimal as appropriate. Hexadecimal literals are prefixed with \"0x\" to distinguish them from decimal literals.",
      "ja": "すべての数値は、ネットワークバイト順です。特に断らない限り、値は符号なしです。リテラル値は、必要に応じて10進数または16進数で提供されます。進リテラルは、小数点リテラルと区別するために「0x」で始まります。"
    },
    {
      "indent": 3,
      "text": "The following terms are used:",
      "ja": "以下の用語が使用されます。"
    },
    {
      "indent": 3,
      "text": "client: The endpoint that initiates an HTTP/2 connection. Clients send HTTP requests and receive HTTP responses.",
      "ja": "クライアント：HTTP / 2接続を開始したエンドポイント。クライアントは、HTTPリクエストを送信し、HTTP応答を受け取ります。"
    },
    {
      "indent": 3,
      "text": "connection: A transport-layer connection between two endpoints.",
      "ja": "接続：2つのエンドポイント間のトランスポート層接続。"
    },
    {
      "indent": 3,
      "text": "connection error: An error that affects the entire HTTP/2 connection.",
      "ja": "接続エラー：全体HTTP / 2接続に影響を与えますエラー。"
    },
    {
      "indent": 3,
      "text": "endpoint: Either the client or server of the connection.",
      "ja": "エンドポイント：接続のクライアントまたはサーバのどちらか。"
    },
    {
      "indent": 3,
      "text": "frame: The smallest unit of communication within an HTTP/2 connection, consisting of a header and a variable-length sequence of octets structured according to the frame type.",
      "ja": "フレーム：フレームタイプに従って構造化ヘッダとオクテットの可変長の配列からなるHTTP / 2接続、内通信の最小単位。"
    },
    {
      "indent": 3,
      "text": "peer: An endpoint. When discussing a particular endpoint, \"peer\" refers to the endpoint that is remote to the primary subject of discussion.",
      "ja": "ピア：エンドポイント。特定のエンドポイントを議論するとき、「ピア」は議論の主要被写体へのリモートエンドポイントであることをいいます。"
    },
    {
      "indent": 3,
      "text": "receiver: An endpoint that is receiving frames.",
      "ja": "受信機：フレームを受信して​​いるエンドポイント。"
    },
    {
      "indent": 3,
      "text": "sender: An endpoint that is transmitting frames.",
      "ja": "送信者：フレームを送信しているエンドポイント。"
    },
    {
      "indent": 3,
      "text": "server: The endpoint that accepts an HTTP/2 connection. Servers receive HTTP requests and send HTTP responses.",
      "ja": "サーバー：HTTP / 2接続を受け入れるエンドポイント。サーバは、HTTPリクエストを受信し、HTTPレスポンスを送信します。"
    },
    {
      "indent": 3,
      "text": "stream: A bidirectional flow of frames within the HTTP/2 connection.",
      "ja": "ストリーム：HTTP / 2接続内のフレームの双方向の流れ。"
    },
    {
      "indent": 3,
      "text": "stream error: An error on the individual HTTP/2 stream.",
      "ja": "ストリームエラー：個々のHTTP / 2ストリームにエラーが発生しました。"
    },
    {
      "indent": 3,
      "text": "Finally, the terms \"gateway\", \"intermediary\", \"proxy\", and \"tunnel\" are defined in Section 2.3 of [RFC7230]. Intermediaries act as both client and server at different times.",
      "ja": "最後に、用語は、「中間」、「プロキシ」、「ゲートウェイ」、および「トンネル」は、[RFC7230]のセクション2.3で定義されています。仲介は、異なる時間に、クライアントとサーバーの両方として機能します。"
    },
    {
      "indent": 3,
      "text": "The term \"payload body\" is defined in Section 3.3 of [RFC7230].",
      "ja": "用語「ペイロード体」は、[RFC7230]のセクション3.3で定義されています。"
    },
    {
      "indent": 0,
      "text": "3. Starting HTTP/2",
      "section_title": true,
      "ja": "3. HTTP / 2の開始"
    },
    {
      "indent": 3,
      "text": "An HTTP/2 connection is an application-layer protocol running on top of a TCP connection ([TCP]). The client is the TCP connection initiator.",
      "ja": "HTTP / 2接続は、TCP接続（[TCP]）の上で実行されるアプリケーション層プロトコルです。クライアントは、TCP接続の開始剤です。"
    },
    {
      "indent": 3,
      "text": "HTTP/2 uses the same \"http\" and \"https\" URI schemes used by HTTP/1.1. HTTP/2 shares the same default port numbers: 80 for \"http\" URIs and 443 for \"https\" URIs. As a result, implementations processing requests for target resource URIs like \"http://example.org/foo\" or \"https://example.com/bar\" are required to first discover whether the upstream server (the immediate peer to which the client wishes to establish a connection) supports HTTP/2.",
      "ja": "HTTP / 2は、HTTP / 1.1で使用されるのと同じ \"http\" と \"https\" のURIスキームを使用しています。 HTTP / 2株と同じデフォルトのポート番号：「HTTP」URIと「https」のURIの443のための80。結果として、「http://example.org/foo」又は「https://example.com/bar」のようなターゲットリソースURIの実装処理要求が最初にアップストリームサーバ（即時ピアかどうかを発見するために必要とされますクライアントは、HTTP / 2をサポートしています）接続を確立することを希望します。"
    },
    {
      "indent": 3,
      "text": "The means by which support for HTTP/2 is determined is different for \"http\" and \"https\" URIs. Discovery for \"http\" URIs is described in Section 3.2. Discovery for \"https\" URIs is described in Section 3.3.",
      "ja": "HTTP / 2をサポートする手段は、「HTTP」と「HTTPS」のURIで異なる決定されます。ディスカバリー「HTTP」のURIは、セクション3.2に記載されています。 「https」のための発見は、URIは、セクション3.3に記載されています。"
    },
    {
      "indent": 0,
      "text": "3.1. HTTP/2 Version Identification",
      "section_title": true,
      "ja": "3.1.  HTTP / 2バージョンの識別"
    },
    {
      "indent": 3,
      "text": "The protocol defined in this document has two identifiers.",
      "ja": "この文書で定義されたプロトコルは、2つの識別子を持っています。"
    },
    {
      "indent": 3,
      "text": "o The string \"h2\" identifies the protocol where HTTP/2 uses Transport Layer Security (TLS) [TLS12]. This identifier is used in the TLS application-layer protocol negotiation (ALPN) extension [TLS-ALPN] field and in any place where HTTP/2 over TLS is identified.",
      "ja": "O文字列 \"H2\" は、HTTP / 2は、トランスポート層セキュリティ（TLS）[TLS12]を使用するプロトコルを識別する。この識別子は、TLSアプリケーション層のプロトコルのネゴシエーション（ALPN）拡張[TLS-ALPN]フィールドで識別されるHTTP / 2 TLS上の任意の場所で使用されています。"
    },
    {
      "indent": 6,
      "text": "The \"h2\" string is serialized into an ALPN protocol identifier as the two-octet sequence: 0x68, 0x32.",
      "ja": "0x68、0x32の「H2」の文字列は、2オクテットシーケンスとしてALPNプロトコル識別子にシリアライズされます。"
    },
    {
      "indent": 3,
      "text": "o The string \"h2c\" identifies the protocol where HTTP/2 is run over cleartext TCP. This identifier is used in the HTTP/1.1 Upgrade header field and in any place where HTTP/2 over TCP is identified.",
      "ja": "Oの文字列「H2Cは、」HTTP / 2は、平文のTCP上で実行されているプロトコルを識別します。この識別子は、HTTP / 1.1 Upgradeヘッダフィールドで識別されるHTTP / 2 TCP上の任意の場所で使用されています。"
    },
    {
      "indent": 6,
      "text": "The \"h2c\" string is reserved from the ALPN identifier space but describes a protocol that does not use TLS.",
      "ja": "「H2C」の文字列は、ALPN識別子空間から予約が、TLSを使用していないプロトコルを記述しています。"
    },
    {
      "indent": 3,
      "text": "Negotiating \"h2\" or \"h2c\" implies the use of the transport, security, framing, and message semantics described in this document.",
      "ja": "「H2」または「H2C」を交渉することは、この文書で説明した輸送、セキュリティ、フレーミング、およびメッセージのセマンティクスを使用することを意味します。"
    },
    {
      "indent": 0,
      "text": "3.2. Starting HTTP/2 for \"http\" URIs",
      "section_title": true,
      "ja": "3.2.  \"HTTP\" のURIのためにHTTP / 2を起動します"
    },
    {
      "indent": 3,
      "text": "A client that makes a request for an \"http\" URI without prior knowledge about support for HTTP/2 on the next hop uses the HTTP Upgrade mechanism (Section 6.7 of [RFC7230]). The client does so by making an HTTP/1.1 request that includes an Upgrade header field with the \"h2c\" token. Such an HTTP/1.1 request MUST include exactly one HTTP2-Settings (Section 3.2.1) header field.",
      "ja": "次のホップのHTTP / 2のサポートについての予備知識なしに「http」URIを要求するクライアントは、HTTPアップグレードメカニズム（[RFC7230]の6.7節）を使用しています。クライアントは、「H2C」トークンを持つUpgradeヘッダフィールドを含むHTTP / 1.1リクエストをすることによってそれを行います。そのようなHTTP / 1.1リクエストは、1つのHTTP2-設定（3.2.1）ヘッダフィールドを含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "For example:",
      "ja": "例えば："
    },
    {
      "indent": 5,
      "text": "GET / HTTP/1.1 Host: server.example.com Connection: Upgrade, HTTP2-Settings Upgrade: h2c HTTP2-Settings: <base64url encoding of HTTP/2 SETTINGS payload>",
      "ja": "GET / HTTP / 1.1ホスト：server.example.com接続：アップグレード、HTTP2-セッティングアップグレード：H2C HTTP2-セッティング：<HTTP / 2 SETTINGSペイロードのbase64urlエンコーディング>"
    },
    {
      "indent": 3,
      "text": "Requests that contain a payload body MUST be sent in their entirety before the client can send HTTP/2 frames. This means that a large request can block the use of the connection until it is completely sent.",
      "ja": "クライアントはHTTP / 2のフレームを送信することができます前に、ペイロード本体を含む要求は、その全体を送らなければなりません。これは、それが完全に送信されるまで大きな要求が接続の使用を阻止することができることを意味します。"
    },
    {
      "indent": 3,
      "text": "If concurrency of an initial request with subsequent requests is important, an OPTIONS request can be used to perform the upgrade to HTTP/2, at the cost of an additional round trip.",
      "ja": "その後の要求との最初のリクエストの同時実行が重要な場合は、OPTIONSリクエストは、追加の往復の費用で、HTTP / 2へのアップグレードを実行するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "A server that does not support HTTP/2 can respond to the request as though the Upgrade header field were absent:",
      "ja": "：Upgradeヘッダフィールドが存在しなかったかのようにHTTP / 2をサポートしていないサーバが要求に応答することができます"
    },
    {
      "indent": 5,
      "text": "HTTP/1.1 200 OK Content-Length: 243 Content-Type: text/html",
      "ja": "HTTP / 1.1 200 OKのContent-Length：243のContent-Type：text / htmlの"
    },
    {
      "indent": 5,
      "text": "...",
      "ja": "。。。"
    },
    {
      "indent": 3,
      "text": "A server MUST ignore an \"h2\" token in an Upgrade header field. Presence of a token with \"h2\" implies HTTP/2 over TLS, which is instead negotiated as described in Section 3.3.",
      "ja": "サーバがUpgradeヘッダフィールドに「H2」トークンを無視しなければなりません。 「H2」のトークンの存在は、セクション3.3に記載されるように代わりに交渉されるTLS上でHTTP / 2を意味しています。"
    },
    {
      "indent": 3,
      "text": "A server that supports HTTP/2 accepts the upgrade with a 101 (Switching Protocols) response. After the empty line that terminates the 101 response, the server can begin sending HTTP/2 frames. These frames MUST include a response to the request that initiated the upgrade.",
      "ja": "HTTP / 2をサポートするサーバは、101（プロトコル切り替え）応答でアップグレードを受け入れます。 101レスポンスを終了する空行後、サーバは、HTTP / 2フレームの送信を開始することができます。これらのフレームは、アップグレードを開始した要求に対する応答を含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "For example:",
      "ja": "例えば："
    },
    {
      "indent": 5,
      "text": "HTTP/1.1 101 Switching Protocols Connection: Upgrade Upgrade: h2c",
      "ja": "HTTP / 1.1 101は、プロトコル接続切替：アップグレードアップグレード：H2Cを"
    },
    {
      "indent": 5,
      "text": "[ HTTP/2 connection ...",
      "ja": "[HTTP / 2接続..."
    },
    {
      "indent": 3,
      "text": "The first HTTP/2 frame sent by the server MUST be a server connection preface (Section 3.5) consisting of a SETTINGS frame (Section 6.5). Upon receiving the 101 response, the client MUST send a connection preface (Section 3.5), which includes a SETTINGS frame.",
      "ja": "サーバによって送信された最初のHTTP / 2フレームは、設定フレーム（セクション6.5）からなるサーバ接続序文（セクション3.5）でなければなりません。 101応答を受信すると、クライアントは、設定フレームを含む、接続序文（3.5節）を送信しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The HTTP/1.1 request that is sent prior to upgrade is assigned a stream identifier of 1 (see Section 5.1.1) with default priority values (Section 5.3.5). Stream 1 is implicitly \"half-closed\" from the client toward the server (see Section 5.1), since the request is completed as an HTTP/1.1 request. After commencing the HTTP/2 connection, stream 1 is used for the response.",
      "ja": "アップグレード前に送信されるHTTP / 1.1リクエストは、デフォルトの優先値（セクション5.3.5）と（5.1.1項参照）1のストリーム識別子が割り当てられます。リクエストがHTTP / 1.1リクエストとして完成されているので、ストリーム1は、（セクション5.1を参照）、サーバに向けて、クライアントから暗黙的に「半閉」です。 HTTP / 2の接続を開始した後に、ストリーム1は、応答のために使用されます。"
    },
    {
      "indent": 0,
      "text": "3.2.1. HTTP2-Settings Header Field",
      "section_title": true,
      "ja": "3.2.1.  HTTP2-設定ヘッダーフィールド"
    },
    {
      "indent": 3,
      "text": "A request that upgrades from HTTP/1.1 to HTTP/2 MUST include exactly one \"HTTP2-Settings\" header field. The HTTP2-Settings header field is a connection-specific header field that includes parameters that govern the HTTP/2 connection, provided in anticipation of the server accepting the request to upgrade.",
      "ja": "HTTP / 2 HTTP / 1.1からアップグレード要求は、1つの「HTTP2-設定」ヘッダフィールドを含まなければなりません。 HTTP2-設定ヘッダフィールドは、アップグレードする要求を受け付けるサーバを見越して設けHTTP / 2接続を支配するパラメータを含む接続固有のヘッダフィールドです。"
    },
    {
      "indent": 5,
      "text": "HTTP2-Settings = token68",
      "ja": "HTTP2-設定= token68"
    },
    {
      "indent": 3,
      "text": "A server MUST NOT upgrade the connection to HTTP/2 if this header field is not present or if more than one is present. A server MUST NOT send this header field.",
      "ja": "このヘッダフィールドが存在するか2つ以上が存在している場合ではない場合、サーバーは、HTTP / 2への接続をアップグレードしてはなりません。サーバーは、このヘッダフィールドを送ってはいけません。"
    },
    {
      "indent": 3,
      "text": "The content of the HTTP2-Settings header field is the payload of a SETTINGS frame (Section 6.5), encoded as a base64url string (that is, the URL- and filename-safe Base64 encoding described in Section 5 of [RFC4648], with any trailing '=' characters omitted). The ABNF [RFC5234] production for \"token68\" is defined in Section 2.1 of [RFC7235].",
      "ja": "HTTP2-設定ヘッダフィールドの内容は、任意で、base64url列（すなわち、URL-あり、[RFC4648]のセクション5に記載されたファイル名セーフBase64エンコーディングとして符号化SETTINGSフレーム（セクション6.5）のペイロードであります「=」文字を末尾）は省略。 \"token68\" のABNF [RFC5234]の生産は[RFC7235]のセクション2.1で定義されています。"
    },
    {
      "indent": 3,
      "text": "Since the upgrade is only intended to apply to the immediate connection, a client sending the HTTP2-Settings header field MUST also send \"HTTP2-Settings\" as a connection option in the Connection header field to prevent it from being forwarded (see Section 6.1 of [RFC7230]).",
      "ja": "アップグレードが唯一の直接の接続に適用することを意図しているので、HTTP2-設定ヘッダフィールドを送信するクライアントにも転送されることから、それを防ぐために、Connectionヘッダフィールド内の接続オプションとして「HTTP2-設定」を送らなければなりません（セクション6.1を参照してください[RFC7230]）。"
    },
    {
      "indent": 3,
      "text": "A server decodes and interprets these values as it would any other SETTINGS frame. Explicit acknowledgement of these settings (Section 6.5.3) is not necessary, since a 101 response serves as implicit acknowledgement. Providing these values in the upgrade request gives a client an opportunity to provide parameters prior to receiving any frames from the server.",
      "ja": "それは他の設定のフレームと同じように、サーバは、これらの値をデコードし解釈します。 101応答は、暗黙の肯定応答として機能するので、これらの設定を明示的に肯定応答（セクション6.5.3）は、必要ではありません。アップグレード要求にこれらの値を提供することにより、クライアントにサーバーから任意のフレームを受信する前にパラメータを提供する機会を与えてくれます。"
    },
    {
      "indent": 0,
      "text": "3.3. Starting HTTP/2 for \"https\" URIs",
      "section_title": true,
      "ja": "3.3.  \"https\" のURIのHTTP / 2を起動します"
    },
    {
      "indent": 3,
      "text": "A client that makes a request to an \"https\" URI uses TLS [TLS12] with the application-layer protocol negotiation (ALPN) extension [TLS-ALPN].",
      "ja": "「HTTPS」を要求するクライアントは、URIは、アプリケーション層プロトコルのネゴシエーション（ALPN）拡張[TLS-ALPN]とTLS [TLS12]を使用します。"
    },
    {
      "indent": 3,
      "text": "HTTP/2 over TLS uses the \"h2\" protocol identifier. The \"h2c\" protocol identifier MUST NOT be sent by a client or selected by a server; the \"h2c\" protocol identifier describes a protocol that does not use TLS.",
      "ja": "TLS上HTTP / 2は、 \"H2\" プロトコル識別子を使用します。 「H2C」プロトコル識別子は、クライアントから送信されたか、サーバーによって選択されてはなりません。 「H2C」プロトコル識別子は、TLSを使用していないプロトコルを記述しています。"
    },
    {
      "indent": 3,
      "text": "Once TLS negotiation is complete, both the client and the server MUST send a connection preface (Section 3.5).",
      "ja": "TLSネゴシエーションが完了すると、クライアントとサーバの両方が接続序文（3.5節）を送らなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.4. Starting HTTP/2 with Prior Knowledge",
      "section_title": true,
      "ja": "3.4. 事前知識でHTTP / 2を起動します"
    },
    {
      "indent": 3,
      "text": "A client can learn that a particular server supports HTTP/2 by other means. For example, [ALT-SVC] describes a mechanism for advertising this capability.",
      "ja": "クライアントは、特定のサーバが他の手段でHTTP / 2をサポートしていることを学ぶことができます。たとえば、[ALT-SVCは、この機能をアドバタイズするためのメカニズムについて説明します。"
    },
    {
      "indent": 3,
      "text": "A client MUST send the connection preface (Section 3.5) and then MAY immediately send HTTP/2 frames to such a server; servers can identify these connections by the presence of the connection preface. This only affects the establishment of HTTP/2 connections over cleartext TCP; implementations that support HTTP/2 over TLS MUST use protocol negotiation in TLS [TLS-ALPN].",
      "ja": "クライアントが接続序文（3.5節）を送らなければなりませんし、その後すぐに、このようなサーバにHTTP / 2のフレームを送信することができ、サーバは、接続序文の存在により、これらの接続を識別することができます。これは、平文のTCP上のHTTP / 2接続の確立に影響します。 TLS上HTTP / 2をサポートする実装は、TLS [TLS-ALPN]のプロトコルネゴシエーションを使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Likewise, the server MUST send a connection preface (Section 3.5).",
      "ja": "同様に、サーバが接続序文（3.5節）を送らなければなりません。"
    },
    {
      "indent": 3,
      "text": "Without additional information, prior support for HTTP/2 is not a strong signal that a given server will support HTTP/2 for future connections. For example, it is possible for server configurations to change, for configurations to differ between instances in clustered servers, or for network conditions to change.",
      "ja": "追加情報がなければ、HTTP / 2用の従来のサポートは、指定されたサーバは、将来の接続に対してHTTP / 2をサポートすることを強いシグナルではありません。構成はクラスタ化されたサーバ内のインスタンス間で異なる、またはネットワークの状態を変更するためにするためのサーバー構成が、変更するために例えば、それが可能です。"
    },
    {
      "indent": 0,
      "text": "3.5. HTTP/2 Connection Preface",
      "section_title": true,
      "ja": "3.5.  HTTP / 2接続の序文"
    },
    {
      "indent": 3,
      "text": "In HTTP/2, each endpoint is required to send a connection preface as a final confirmation of the protocol in use and to establish the initial settings for the HTTP/2 connection. The client and server each send a different connection preface.",
      "ja": "HTTP / 2において、各エンドポイントは使用中のプロトコルの最終確認として接続序文を送信し、HTTP / 2接続するための初期設定を確立する必要があります。クライアントとサーバは、それぞれ異なる接続序文を送ります。"
    },
    {
      "indent": 3,
      "text": "The client connection preface starts with a sequence of 24 octets, which in hex notation is:",
      "ja": "クライアント接続の序文には、16進表記である、24オクテットのシーケンスを開始します。"
    },
    {
      "indent": 5,
      "text": "0x505249202a20485454502f322e300d0a0d0a534d0d0a0d0a",
      "ja": "0x505249202a20485454502f322e300d0a0d0a534d0d0a0d0a"
    },
    {
      "indent": 3,
      "text": "That is, the connection preface starts with the string \"PRI * HTTP/2.0\\r\\n\\r\\nSM\\r\\n\\r\\n\"). This sequence MUST be followed by a SETTINGS frame (Section 6.5), which MAY be empty. The client sends the client connection preface immediately upon receipt of a 101 (Switching Protocols) response (indicating a successful upgrade) or as the first application data octets of a TLS connection. If starting an HTTP/2 connection with prior knowledge of server support for the protocol, the client connection preface is sent upon connection establishment.",
      "ja": "すなわち、接続序文は、文字列で始まり、ある \"PRI * HTTP / 2.0 \\ R \\ n \\ R \\ NSM \\ R \\ n \\ rをする\\ n\"）。この配列は空であってもよいSETTINGSフレーム（セクション6.5）、続いてなければなりません。クライアントは、すぐに（アップグレードの成功を示す）101（スイッチングプロトコル）応答の受信時またはTLS接続の最初のアプリケーションデータオクテットとしてクライアント接続の序文を送信します。プロトコルのためのサーバーのサポートの予備知識を持つHTTP / 2接続を開始する場合は、クライアント接続の序文は、接続確立時に送信されます。"
    },
    {
      "indent": 6,
      "text": "Note: The client connection preface is selected so that a large proportion of HTTP/1.1 or HTTP/1.0 servers and intermediaries do not attempt to process further frames. Note that this does not address the concerns raised in [TALKING].",
      "ja": "注意：HTTP / 1.1またはHTTPの大部分は、/ 1.0のサーバとの仲介は、さらにフレームを処理しようとしないように、クライアント接続の序文が選択されています。これは[TALKING]で提起された懸念に対処しないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "The server connection preface consists of a potentially empty SETTINGS frame (Section 6.5) that MUST be the first frame the server sends in the HTTP/2 connection.",
      "ja": "サーバ接続序文は、サーバがHTTP / 2接続で送信する最初のフレームでなければなりません、潜在的に空のSETTINGSフレーム（セクション6.5）からなります。"
    },
    {
      "indent": 3,
      "text": "The SETTINGS frames received from a peer as part of the connection preface MUST be acknowledged (see Section 6.5.3) after sending the connection preface.",
      "ja": "接続序文の一部として、ピアから受信した設定フレームは接続序文を送信した後（セクション6.5.3を参照）を認めなければなりません。"
    },
    {
      "indent": 3,
      "text": "To avoid unnecessary latency, clients are permitted to send additional frames to the server immediately after sending the client connection preface, without waiting to receive the server connection preface. It is important to note, however, that the server connection preface SETTINGS frame might include parameters that necessarily alter how a client is expected to communicate with the server. Upon receiving the SETTINGS frame, the client is expected to honor any parameters established. In some configurations, it is possible for the server to transmit SETTINGS before the client sends additional frames, providing an opportunity to avoid this issue.",
      "ja": "不必要な遅延を避けるために、クライアントはサーバ接続序文を受け取るために待つことなく、すぐにクライアント接続の序文を送信した後に、サーバーへの追加のフレームを送信することが許可されています。サーバー接続序文のSETTINGSフレームは必ずしもクライアントがサーバーと通信することが期待される方法を変更するパラメータを含む可能性があること、しかし、注意することが重要です。 SETTINGSフレームを受信すると、クライアントは確立任意のパラメータを尊重することが期待されます。クライアントは、この問題を回避する機会を提供し、追加のフレームを送信する前に、サーバー設定を送信するためにいくつかの構成では、それが可能です。"
    },
    {
      "indent": 3,
      "text": "Clients and servers MUST treat an invalid connection preface as a connection error (Section 5.4.1) of type PROTOCOL_ERROR. A GOAWAY frame (Section 6.8) MAY be omitted in this case, since an invalid preface indicates that the peer is not using HTTP/2.",
      "ja": "クライアントとサーバーはタイプPROTOCOL_ERRORの接続エラー（5.4.1項）として、無効な接続序文を扱わなければなりません。無効序文ピアがHTTP / 2を使用していないことを示すためGOAWAYフレーム（セクション6.8）は、この場合では省略されてもよいです。"
    },
    {
      "indent": 0,
      "text": "4. HTTP Frames",
      "section_title": true,
      "ja": "4. HTTPのフレーム"
    },
    {
      "indent": 3,
      "text": "Once the HTTP/2 connection is established, endpoints can begin exchanging frames.",
      "ja": "HTTP / 2接続が確立されると、エンドポイントは、フレームを交換を開始することができます。"
    },
    {
      "indent": 0,
      "text": "4.1. Frame Format",
      "section_title": true,
      "ja": "4.1. フレーム形式"
    },
    {
      "indent": 3,
      "text": "All frames begin with a fixed 9-octet header followed by a variable-length payload.",
      "ja": "全てのフレームは、可変長のペイロードが続く固定9オクテットのヘッダで始まります。"
    },
    {
      "indent": 4,
      "text": "+-----------------------------------------------+\n|                 Length (24)                   |\n+---------------+---------------+---------------+\n|   Type (8)    |   Flags (8)   |\n+-+-------------+---------------+-------------------------------+\n|R|                 Stream Identifier (31)                      |\n+=+=============================================================+\n|                   Frame Payload (0...)                      ...\n+---------------------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 26,
      "text": "Figure 1: Frame Layout",
      "ja": "図1：フレームレイアウト"
    },
    {
      "indent": 3,
      "text": "The fields of the frame header are defined as:",
      "ja": "フレームヘッダのフィールドは以下のように定義されています。"
    },
    {
      "indent": 3,
      "text": "Length: The length of the frame payload expressed as an unsigned 24-bit integer. Values greater than 2^14 (16,384) MUST NOT be sent unless the receiver has set a larger value for SETTINGS_MAX_FRAME_SIZE.",
      "ja": "長さ：フレームペイロードの長さは、符号なし24ビット整数として表さ。受信機はSETTINGS_MAX_FRAME_SIZEためのより大きな値を設定していない限り、2より大きい^ 14（16,384）を送ってはいけません値。"
    },
    {
      "indent": 6,
      "text": "The 9 octets of the frame header are not included in this value.",
      "ja": "フレームヘッダの9つのオクテットは、この値には含まれません。"
    },
    {
      "indent": 3,
      "text": "Type: The 8-bit type of the frame. The frame type determines the format and semantics of the frame. Implementations MUST ignore and discard any frame that has a type that is unknown.",
      "ja": "タイプ：フレームの8ビットのタイプ。フレームタイプは、フレームのフォーマット及びセマンティクスを決定します。実装は無視して、未知の型を持つ任意のフレームを捨てなければなりません。"
    },
    {
      "indent": 3,
      "text": "Flags: An 8-bit field reserved for boolean flags specific to the frame type.",
      "ja": "フラグ：フレームタイプに固有のブーリアンフラグのために予約さ8ビットのフィールド。"
    },
    {
      "indent": 6,
      "text": "Flags are assigned semantics specific to the indicated frame type. Flags that have no defined semantics for a particular frame type MUST be ignored and MUST be left unset (0x0) when sending.",
      "ja": "フラグは、指示されたフレームタイプに固有のセマンティクスを割り当てています。特定のフレームタイプのための定義された意味を持っていないフラグを無視しなければなりませんし、送信するときに（0x0の）未設定のままにしなければなりません。"
    },
    {
      "indent": 3,
      "text": "R: A reserved 1-bit field. The semantics of this bit are undefined, and the bit MUST remain unset (0x0) when sending and MUST be ignored when receiving.",
      "ja": "R：予約1ビットのフィールド。このビットの意味は未定義であり、送受信時に無視されなければならない場合のビットは（0x0の）未設定のままでなければなりません。"
    },
    {
      "indent": 3,
      "text": "Stream Identifier: A stream identifier (see Section 5.1.1) expressed as an unsigned 31-bit integer. The value 0x0 is reserved for frames that are associated with the connection as a whole as opposed to an individual stream.",
      "ja": "ストリーム識別子：ストリーム識別子（セクション5.1.1を参照）符号なし31ビット整数として表さ。値0x0には、個々のストリームとは対照的に、全体としての接続に関連付けられたフレームのために予約されています。"
    },
    {
      "indent": 3,
      "text": "The structure and content of the frame payload is dependent entirely on the frame type.",
      "ja": "フレームのペイロードの構造と内容は、フレームタイプに完全に依存しています。"
    },
    {
      "indent": 0,
      "text": "4.2. Frame Size",
      "section_title": true,
      "ja": "4.2. フレームサイズ"
    },
    {
      "indent": 3,
      "text": "The size of a frame payload is limited by the maximum size that a receiver advertises in the SETTINGS_MAX_FRAME_SIZE setting. This setting can have any value between 2^14 (16,384) and 2^24-1 (16,777,215) octets, inclusive.",
      "ja": "フレームペイロードのサイズは、受信機がSETTINGS_MAX_FRAME_SIZE設定でアドバタイズ最大サイズによって制限されます。この設定は、2 ^ 14（16,384）と、2 ^ 24-1（16777215）オクテットの間に、包括的な任意の値を持つことができます。"
    },
    {
      "indent": 3,
      "text": "All implementations MUST be capable of receiving and minimally processing frames up to 2^14 octets in length, plus the 9-octet frame header (Section 4.1). The size of the frame header is not included when describing frame sizes.",
      "ja": "すべての実装は、2 ^ 14の長さのオクテット、プラス9オクテットのフレームヘッダ（セクション4.1）までの処理フレームを受信し、最小限可能でなければなりません。フレームサイズを説明する場合、フレームヘッダのサイズは含まれません。"
    },
    {
      "indent": 6,
      "text": "Note: Certain frame types, such as PING (Section 6.7), impose additional limits on the amount of payload data allowed.",
      "ja": "注：このようなPING（セクション6.7）のような特定のフレームタイプは、許可されたペイロードデータの量に追加の制限を課します。"
    },
    {
      "indent": 3,
      "text": "An endpoint MUST send an error code of FRAME_SIZE_ERROR if a frame exceeds the size defined in SETTINGS_MAX_FRAME_SIZE, exceeds any limit defined for the frame type, or is too small to contain mandatory frame data. A frame size error in a frame that could alter the state of the entire connection MUST be treated as a connection error (Section 5.4.1); this includes any frame carrying a header block (Section 4.3) (that is, HEADERS, PUSH_PROMISE, and CONTINUATION), SETTINGS, and any frame with a stream identifier of 0.",
      "ja": "フレームは、フレームタイプ用に定義された任意の制限を超え、SETTINGS_MAX_FRAME_SIZEで定義されたサイズを超え、または必須のフレームデータを含むには小さすぎる場合、エンドポイントはFRAME_SIZE_ERRORのエラーコードを送信しなければなりません。全体の接続の状態を変化させることができ、フレームのフレームサイズのエラーは、接続エラー（セクション5.4.1）として扱われなければなりません。これは、ヘッダブロック（セクション4.3）（すなわち、ヘッダ、PUSH_PROMISE、および継続である）、設定、および0のストリーム識別子を持つフレームを運ぶ任意のフレームを含みます。"
    },
    {
      "indent": 3,
      "text": "Endpoints are not obligated to use all available space in a frame. Responsiveness can be improved by using frames that are smaller than the permitted maximum size. Sending large frames can result in delays in sending time-sensitive frames (such as RST_STREAM, WINDOW_UPDATE, or PRIORITY), which, if blocked by the transmission of a large frame, could affect performance.",
      "ja": "エンドポイントは、フレーム内のすべての利用可能なスペースを使用する義務はありません。応答性が許容最大サイズよりも小さいフレームを使用することによって改善することができます。大きなフレームを送信すると、大きなフレームの送信によってブロックされた場合、パフォーマンスに影響を与える可能性があり（例えばRST_STREAM、WINDOW_UPDATE、または優先順位など）時間に敏感なフレームを、送信の遅延をもたらすことができます。"
    },
    {
      "indent": 0,
      "text": "4.3. Header Compression and Decompression",
      "section_title": true,
      "ja": "4.3. ヘッダ圧縮と解凍"
    },
    {
      "indent": 3,
      "text": "Just as in HTTP/1, a header field in HTTP/2 is a name with one or more associated values. Header fields are used within HTTP request and response messages as well as in server push operations (see Section 8.2).",
      "ja": "単にHTTP / 1のように、HTTP / 2のヘッダフィールドは、一つ以上の関連する値を持つ名前です。ヘッダーフィールドはHTTP要求と応答メッセージの中だけでなく、サーバープッシュ操作（8.2節を参照）で使用されています。"
    },
    {
      "indent": 3,
      "text": "Header lists are collections of zero or more header fields. When transmitted over a connection, a header list is serialized into a header block using HTTP header compression [COMPRESSION]. The serialized header block is then divided into one or more octet sequences, called header block fragments, and transmitted within the payload of HEADERS (Section 6.2), PUSH_PROMISE (Section 6.6), or CONTINUATION (Section 6.10) frames.",
      "ja": "ヘッダーリストはゼロ個以上のヘッダフィールドの集合です。接続を介して送信された場合、ヘッダリストはHTTPヘッダー圧縮[圧縮]を使用して、ヘッダブロックにシリアル化されます。シリアル化ヘッダブロックは、ヘッダブロック断片と呼ばれる、一つ以上のオクテットシーケンスに分割され、ヘッダのペイロード（セクション6.2）、PUSH_PROMISE（セクション6.6）、または継続（セクション6.10）フレーム内で送信されます。"
    },
    {
      "indent": 3,
      "text": "The Cookie header field [COOKIE] is treated specially by the HTTP mapping (see Section 8.1.2.5).",
      "ja": "Cookieヘッダフィールド[COOKIE]はHTTPマッピングによって特別に処理される（セクション8.1.2.5を参照）。"
    },
    {
      "indent": 3,
      "text": "A receiving endpoint reassembles the header block by concatenating its fragments and then decompresses the block to reconstruct the header list.",
      "ja": "受信エンドポイントはそのフラグメントを連結することによって、ヘッダブロックを再構成した後、ヘッダリストを再構築するためにブロックを解凍します。"
    },
    {
      "indent": 3,
      "text": "A complete header block consists of either:",
      "ja": "完全なヘッダブロックのいずれかで構成されています。"
    },
    {
      "indent": 3,
      "text": "o a single HEADERS or PUSH_PROMISE frame, with the END_HEADERS flag set, or",
      "ja": "O単一ヘッダーまたはPUSH_PROMISEフレーム、END_HEADERSフラグが設定され、又は"
    },
    {
      "indent": 3,
      "text": "o a HEADERS or PUSH_PROMISE frame with the END_HEADERS flag cleared and one or more CONTINUATION frames, where the last CONTINUATION frame has the END_HEADERS flag set.",
      "ja": "END_HEADERSフラグをヘッダまたはPUSH_PROMISEフレームがクリアされ、最後の連続フレームがEND_HEADERSフラグがセットされている一つまたはそれ以上の連続フレーム、O。"
    },
    {
      "indent": 3,
      "text": "Header compression is stateful. One compression context and one decompression context are used for the entire connection. A decoding error in a header block MUST be treated as a connection error (Section 5.4.1) of type COMPRESSION_ERROR.",
      "ja": "ヘッダ圧縮は、ステートフルです。 1つの圧縮コンテキストと1つの解凍コンテキストが全体の接続に使用されています。ヘッダブロックの復号エラーは、タイプCOMPRESSION_ERRORの接続エラー（セクション5.4.1）として扱われなければなりません。"
    },
    {
      "indent": 3,
      "text": "Each header block is processed as a discrete unit. Header blocks MUST be transmitted as a contiguous sequence of frames, with no interleaved frames of any other type or from any other stream. The last frame in a sequence of HEADERS or CONTINUATION frames has the",
      "ja": "各ヘッダブロックは、別個の単位として処理されます。ヘッダブロックは、任意の他の種類のないインターリーブフレームまたは任意の他のストリームから、フレームの連続配列として送信されなければなりません。ヘッダーまたは継続フレームのシーケンスの最後のフレームを持っています"
    },
    {
      "indent": 3,
      "text": "END_HEADERS flag set. The last frame in a sequence of PUSH_PROMISE or CONTINUATION frames has the END_HEADERS flag set. This allows a header block to be logically equivalent to a single frame.",
      "ja": "END_HEADERSフラグを設定します。 PUSH_PROMISEまたは継続フレームのシーケンスの最後のフレームはEND_HEADERSフラグが設定されています。これは、ヘッダブロックが単一のフレームと論理的に等価にすることができます。"
    },
    {
      "indent": 3,
      "text": "Header block fragments can only be sent as the payload of HEADERS, PUSH_PROMISE, or CONTINUATION frames because these frames carry data that can modify the compression context maintained by a receiver. An endpoint receiving HEADERS, PUSH_PROMISE, or CONTINUATION frames needs to reassemble header blocks and perform decompression even if the frames are to be discarded. A receiver MUST terminate the connection with a connection error (Section 5.4.1) of type COMPRESSION_ERROR if it does not decompress a header block.",
      "ja": "これらのフレームは、受信機によって維持圧縮コンテキストを変更することができ、データを運ぶため、ヘッダブロックフラグメントはヘッダのみ、PUSH_PROMISE、または継続フレームのペイロードとして送信することができます。ヘッダ、PUSH_PROMISE、または継続フレームを受信したエンドポイントは、ヘッダブロックを再構成し、フレームを廃棄する場合であっても減圧を行う必要があります。それはヘッダブロックを解凍していない場合、受信機は、タイプCOMPRESSION_ERRORの接続エラー（5.4.1）との接続を終了しなければなりません。"
    },
    {
      "indent": 0,
      "text": "5. Streams and Multiplexing",
      "section_title": true,
      "ja": "5.ストリームと多重化"
    },
    {
      "indent": 3,
      "text": "A \"stream\" is an independent, bidirectional sequence of frames exchanged between the client and server within an HTTP/2 connection. Streams have several important characteristics:",
      "ja": "「ストリーム」は、フレームとは無関係に、双方向配列がHTTP / 2接続内のクライアントとサーバの間で交換されます。ストリームは、いくつかの重要な特性があります。"
    },
    {
      "indent": 3,
      "text": "o A single HTTP/2 connection can contain multiple concurrently open streams, with either endpoint interleaving frames from multiple streams.",
      "ja": "単一のHTTP / 2接続は、複数のストリームからエンドポイントインターリーブフレームのいずれかを用いて、複数の並行オープンストリームを含むことができ、O。"
    },
    {
      "indent": 3,
      "text": "o Streams can be established and used unilaterally or shared by either the client or server.",
      "ja": "Oストリームを確立し、一方的に使用したり、クライアントまたはサーバで共有することができます。"
    },
    {
      "indent": 3,
      "text": "o Streams can be closed by either endpoint.",
      "ja": "Oストリームは、いずれかのエンドポイントで閉じることができます。"
    },
    {
      "indent": 3,
      "text": "o The order in which frames are sent on a stream is significant. Recipients process frames in the order they are received. In particular, the order of HEADERS and DATA frames is semantically significant.",
      "ja": "Oフレームは、ストリームで送信される順序は重要です。受信者は、受信された順にフレームを処理します。具体的には、ヘッダとデータフレームの順序は意味的に重要です。"
    },
    {
      "indent": 3,
      "text": "o Streams are identified by an integer. Stream identifiers are assigned to streams by the endpoint initiating the stream.",
      "ja": "Oストリームは整数によって識別されます。ストリーム識別子は、ストリームを開始するエンドポイントによって、ストリームに割り当てられています。"
    },
    {
      "indent": 0,
      "text": "5.1. Stream States",
      "section_title": true,
      "ja": "5.1. ストリームの状態"
    },
    {
      "indent": 3,
      "text": "The lifecycle of a stream is shown in Figure 2.",
      "ja": "ストリームのライフサイクルは、図2に示されています。"
    },
    {
      "indent": 7,
      "text": "                         +--------+\n                 send PP |        | recv PP\n                ,--------|  idle  |--------.\n               /         |        |         \\\n              v          +--------+          v\n       +----------+          |           +----------+\n       |          |          | send H /  |          |\n,------| reserved |          | recv H    | reserved |------.\n|      | (local)  |          |           | (remote) |      |\n|      +----------+          v           +----------+      |\n|          |             +--------+             |          |\n|          |     recv ES |        | send ES     |          |\n|   send H |     ,-------|  open  |-------.     | recv H   |\n|          |    /        |        |        \\    |          |\n|          v   v         +--------+         v   v          |\n|      +----------+          |           +----------+      |\n|      |   half   |          |           |   half   |      |\n|      |  closed  |          | send R /  |  closed  |      |\n|      | (remote) |          | recv R    | (local)  |      |\n|      +----------+          |           +----------+      |\n|           |                |                 |           |\n|           | send ES /      |       recv ES / |           |\n|           | send R /       v        send R / |           |\n|           | recv R     +--------+   recv R   |           |\n| send R /  `----------->|        |<-----------'  send R / |\n| recv R                 | closed |               recv R   |\n`----------------------->|        |<----------------------'\n                         +--------+",
      "raw": true
    },
    {
      "indent": 10,
      "text": "send: endpoint sends this frame recv: endpoint receives this frame",
      "ja": "送信：エンドポイントは、このフレームのrecvを送信します。エンドポイントはこのフレームを受信"
    },
    {
      "indent": 10,
      "text": "H: HEADERS frame (with implied CONTINUATIONs) PP: PUSH_PROMISE frame (with implied CONTINUATIONs) ES: END_STREAM flag R: RST_STREAM frame",
      "ja": "H：（暗黙継続付き）PUSH_PROMISEフレームES：（暗黙継続付き）ヘッダフレームPP END_STREAMフラグR：RST_STREAMフレーム"
    },
    {
      "indent": 26,
      "text": "Figure 2: Stream States",
      "ja": "図2：ストリームの状態"
    },
    {
      "indent": 3,
      "text": "Note that this diagram shows stream state transitions and the frames and flags that affect those transitions only. In this regard, CONTINUATION frames do not result in state transitions; they are effectively part of the HEADERS or PUSH_PROMISE that they follow.",
      "ja": "この図は、ストリームの状態遷移とのみの移行に影響を与えるフレームとフラグを示していることに注意してください。この点において、継続フレームは、状態遷移にはなりません。彼らは効果的に彼らが従うヘッダやPUSH_PROMISEの一部です。"
    },
    {
      "indent": 3,
      "text": "For the purpose of state transitions, the END_STREAM flag is processed as a separate event to the frame that bears it; a HEADERS frame with the END_STREAM flag set can cause two state transitions.",
      "ja": "状態遷移のために、END_STREAMフラグは、それを支持フレームに別のイベントとして処理されます。 END_STREAMフラグが設定されたHEADERSフレームは、2つの状態遷移を引き起こす可能性があります。"
    },
    {
      "indent": 3,
      "text": "Both endpoints have a subjective view of the state of a stream that could be different when frames are in transit. Endpoints do not coordinate the creation of streams; they are created unilaterally by either endpoint. The negative consequences of a mismatch in states are limited to the \"closed\" state after sending RST_STREAM, where frames might be received for some time after closing.",
      "ja": "両方のエンドポイントは、フレームが輸送中にあるときに異なる可能性があり、ストリームの状態の主観的な見解を持っています。エンドポイントは、ストリームの作成を調整しません。彼らはどちらかのエンドポイントによって一方的に作成されます。状態の不一致の負の影響は、フレームが閉じた後、いくつかの時間のために受信される可能性がありますRST_STREAMを、送信後に「閉」の状態に限定されています。"
    },
    {
      "indent": 3,
      "text": "Streams have the following states:",
      "ja": "ストリームは、次の状態があります。"
    },
    {
      "indent": 3,
      "text": "idle: All streams start in the \"idle\" state.",
      "ja": "アイドル：すべてのストリームは、「アイドル」状態で起動。"
    },
    {
      "indent": 6,
      "text": "The following transitions are valid from this state:",
      "ja": "以下の遷移は、この状態から有効です。"
    },
    {
      "indent": 6,
      "text": "* Sending or receiving a HEADERS frame causes the stream to become \"open\". The stream identifier is selected as described in Section 5.1.1. The same HEADERS frame can also cause a stream to immediately become \"half-closed\".",
      "ja": "* HEADERSフレームを送信または受信するストリームが「オープン」になるようにします。セクション5.1.1に記載したようにストリーム識別子が選択されます。同じHEADERSフレームは、ストリームはすぐに「ハーフクローズ」になることを引き起こす可能性があります。"
    },
    {
      "indent": 6,
      "text": "* Sending a PUSH_PROMISE frame on another stream reserves the idle stream that is identified for later use. The stream state for the reserved stream transitions to \"reserved (local)\".",
      "ja": "*別のストリームにPUSH_PROMISEフレームを送信すると、後で使用するために識別されたアイドルストリームを留保します。するために予約されたストリームの移行のためのストリーム状態「に予約（ローカル）」。"
    },
    {
      "indent": 6,
      "text": "* Receiving a PUSH_PROMISE frame on another stream reserves an idle stream that is identified for later use. The stream state for the reserved stream transitions to \"reserved (remote)\".",
      "ja": "*別のストリームにPUSH_PROMISEフレームを受信すると、後で使用するために識別されたアイドルストリームを留保します。予約ストリーム遷移のためのストリーム状態「（リモート）予約」します。"
    },
    {
      "indent": 6,
      "text": "* Note that the PUSH_PROMISE frame is not sent on the idle stream but references the newly reserved stream in the Promised Stream ID field.",
      "ja": "* PUSH_PROMISEフレームがアイドルストリームに送信されたが、約束のストリームIDフィールドに、新たに予約したストリームを参照されていないことに注意してください。"
    },
    {
      "indent": 6,
      "text": "Receiving any frame other than HEADERS or PRIORITY on a stream in this state MUST be treated as a connection error (Section 5.4.1) of type PROTOCOL_ERROR.",
      "ja": "この状態でストリームにヘッダまたはPRIORITY以外のフレームを受信するタイプPROTOCOL_ERRORの接続エラー（セクション5.4.1）として扱われなければなりません。"
    },
    {
      "indent": 3,
      "text": "reserved (local): A stream in the \"reserved (local)\" state is one that has been promised by sending a PUSH_PROMISE frame. A PUSH_PROMISE frame reserves an idle stream by associating the stream with an open stream that was initiated by the remote peer (see Section 8.2).",
      "ja": "予約（ローカル）：「予約済み（ローカル）」状態のストリームがPUSH_PROMISEフレームを送信することによって約束されたものです。 PUSH_PROMISEフレームがリモートピアによって開始されたオープンストリームとストリームを関連付けることによって、アイドルストリームを留保（セクション8.2を参照）。"
    },
    {
      "indent": 6,
      "text": "In this state, only the following transitions are possible:",
      "ja": "この状態では、唯一の次の遷移が可能です。"
    },
    {
      "indent": 6,
      "text": "* The endpoint can send a HEADERS frame. This causes the stream to open in a \"half-closed (remote)\" state.",
      "ja": "*エンドポイントはHEADERSフレームを送信することができます。これは、「半分閉じた（リモート）」の状態で開くようにストリームが発生します。"
    },
    {
      "indent": 6,
      "text": "* Either endpoint can send a RST_STREAM frame to cause the stream to become \"closed\". This releases the stream reservation.",
      "ja": "*どちらのエンドポイントは、ストリームが「閉」にさせるためにRST_STREAMフレームを送信することができます。これは、ストリームの予約を解放します。"
    },
    {
      "indent": 6,
      "text": "An endpoint MUST NOT send any type of frame other than HEADERS, RST_STREAM, or PRIORITY in this state.",
      "ja": "エンドポイントは、この状態では、ヘッダー、RST_STREAM、または優先順位以外のフレームのいずれかのタイプを送ってはいけません。"
    },
    {
      "indent": 6,
      "text": "A PRIORITY or WINDOW_UPDATE frame MAY be received in this state. Receiving any type of frame other than RST_STREAM, PRIORITY, or WINDOW_UPDATE on a stream in this state MUST be treated as a connection error (Section 5.4.1) of type PROTOCOL_ERROR.",
      "ja": "PRIORITYまたはWINDOW_UPDATEフレームは、この状態で受信されても​​よいです。 RST_STREAM以外のフレームの任意のタイプを受け、この状態でストリームを優先、またはWINDOW_UPDATEは型PROTOCOL_ERRORの接続エラー（セクション5.4.1）として扱われなければなりません。"
    },
    {
      "indent": 3,
      "text": "reserved (remote): A stream in the \"reserved (remote)\" state has been reserved by a remote peer.",
      "ja": "予約済み（リモート）：「予約済み（リモート）」状態のストリームがリモートピアによって予約されています。"
    },
    {
      "indent": 6,
      "text": "In this state, only the following transitions are possible:",
      "ja": "この状態では、唯一の次の遷移が可能です。"
    },
    {
      "indent": 6,
      "text": "* Receiving a HEADERS frame causes the stream to transition to \"half-closed (local)\".",
      "ja": "*ヘッダフレームを受信すると、「半閉（ローカル）」に移行する流れを引き起こします。"
    },
    {
      "indent": 6,
      "text": "* Either endpoint can send a RST_STREAM frame to cause the stream to become \"closed\". This releases the stream reservation.",
      "ja": "*どちらのエンドポイントは、ストリームが「閉」にさせるためにRST_STREAMフレームを送信することができます。これは、ストリームの予約を解放します。"
    },
    {
      "indent": 6,
      "text": "An endpoint MAY send a PRIORITY frame in this state to reprioritize the reserved stream. An endpoint MUST NOT send any type of frame other than RST_STREAM, WINDOW_UPDATE, or PRIORITY in this state.",
      "ja": "エンドポイントは予約済みストリームの優先順位を変更するために、この状態でPRIORITYフレームを送信することができます。エンドポイントは、この状態ではRST_STREAM、WINDOW_UPDATE以外のフレーム、または優先順位のいずれかのタイプを送ってはいけません。"
    },
    {
      "indent": 6,
      "text": "Receiving any type of frame other than HEADERS, RST_STREAM, or PRIORITY on a stream in this state MUST be treated as a connection error (Section 5.4.1) of type PROTOCOL_ERROR.",
      "ja": "この状態で、ストリームにヘッダ、RST_STREAM、または優先順位以外のフレームの任意のタイプの受信は、タイプPROTOCOL_ERRORの接続エラー（セクション5.4.1）として扱われなければなりません。"
    },
    {
      "indent": 3,
      "text": "open: A stream in the \"open\" state may be used by both peers to send frames of any type. In this state, sending peers observe advertised stream-level flow-control limits (Section 5.2).",
      "ja": "オープン：「オープン」状態のストリームは、任意のタイプのフレームを送信するために、両方のピアによって使用されてもよいです。この状態では、送信ピアは、アドバタイズされたストリーム・レベルのフロー制御限界（セクション5.2）を観察します。"
    },
    {
      "indent": 6,
      "text": "From this state, either endpoint can send a frame with an END_STREAM flag set, which causes the stream to transition into one of the \"half-closed\" states. An endpoint sending an",
      "ja": "この状態から、いずれかのエンドポイントは、「半閉」状態のいずれかに移行する流れを引き起こすEND_STREAMフラグセットを有するフレームを送信することができます。送信エンドポイント"
    },
    {
      "indent": 6,
      "text": "END_STREAM flag causes the stream state to become \"half-closed (local)\"; an endpoint receiving an END_STREAM flag causes the stream state to become \"half-closed (remote)\".",
      "ja": "END_STREAMフラグが「半閉（ローカル）」となるようにストリームの状態を引き起こします。 END_STREAMフラグを受信したエンドポイントは、「半閉（リモート）」となるようにストリームの状態を引き起こします。"
    },
    {
      "indent": 6,
      "text": "Either endpoint can send a RST_STREAM frame from this state, causing it to transition immediately to \"closed\".",
      "ja": "いずれかのエンドポイントは、それが「閉」に即座に移行させ、この状態からRST_STREAMフレームを送信することができます。"
    },
    {
      "indent": 3,
      "text": "half-closed (local): A stream that is in the \"half-closed (local)\" state cannot be used for sending frames other than WINDOW_UPDATE, PRIORITY, and RST_STREAM.",
      "ja": "半分閉じた（ローカル）：「半閉（ローカル）」状態にあるストリームがWINDOW_UPDATE、優先度、およびRST_STREAM以外のフレームを送信するために使用することができません。"
    },
    {
      "indent": 6,
      "text": "A stream transitions from this state to \"closed\" when a frame that contains an END_STREAM flag is received or when either peer sends a RST_STREAM frame.",
      "ja": "この状態からストリーム遷移が「閉じた」場合END_STREAMフラグを含むフレームを受信したとき、またはいずれかのピアがRST_STREAMフレームを送信します。"
    },
    {
      "indent": 6,
      "text": "An endpoint can receive any type of frame in this state. Providing flow-control credit using WINDOW_UPDATE frames is necessary to continue receiving flow-controlled frames. In this state, a receiver can ignore WINDOW_UPDATE frames, which might arrive for a short period after a frame bearing the END_STREAM flag is sent.",
      "ja": "エンドポイントは、この状態では、フレームのいずれかのタイプを受け取ることができます。 WINDOW_UPDATEフレームを使用してフロー制御クレジットを提供するフロー制御フレームを受信し続ける必要があります。この状態では、受信機はEND_STREAMフラグを担持するフレームが送信された後の短い期間のために到着する可能性があるWINDOW_UPDATEフレームを、無視することができます。"
    },
    {
      "indent": 6,
      "text": "PRIORITY frames received in this state are used to reprioritize streams that depend on the identified stream.",
      "ja": "この状態で受信PRIORITYフレームは、識別されたストリームに依存するストリームの優先順位を変更するために使用されます。"
    },
    {
      "indent": 3,
      "text": "half-closed (remote): A stream that is \"half-closed (remote)\" is no longer being used by the peer to send frames. In this state, an endpoint is no longer obligated to maintain a receiver flow-control window.",
      "ja": "半分閉じた（遠隔）：「半閉（リモート）」であり、ストリームがもはやフレームを送信するためにピアによって使用されています。この状態では、エンドポイントがもはや受信フロー制御ウィンドウを維持する義務がありません。"
    },
    {
      "indent": 6,
      "text": "If an endpoint receives additional frames, other than WINDOW_UPDATE, PRIORITY, or RST_STREAM, for a stream that is in this state, it MUST respond with a stream error (Section 5.4.2) of type STREAM_CLOSED.",
      "ja": "エンドポイントがこの状態にあるストリームに対して、WINDOW_UPDATE、PRIORITY、またはRST_STREAM以外の追加のフレームを受信した場合、それはタイプSTREAM_CLOSEDのストリームエラー（5.4.2項）で応答しなければなりません。"
    },
    {
      "indent": 6,
      "text": "A stream that is \"half-closed (remote)\" can be used by the endpoint to send frames of any type. In this state, the endpoint continues to observe advertised stream-level flow-control limits (Section 5.2).",
      "ja": "あるストリーム「半閉（遠隔）」は、任意のタイプのフレームを送信するために、エンドポイントで使用することができます。この状態で、エンドポイントは、広告されたストリーム・レベルのフロー制御限界（セクション5.2）を観察し続けます。"
    },
    {
      "indent": 6,
      "text": "A stream can transition from this state to \"closed\" by sending a frame that contains an END_STREAM flag or when either peer sends a RST_STREAM frame.",
      "ja": "ストリームはEND_STREAMフラグ場合、またはいずれかのピアがRST_STREAMフレームを送信を含むフレームを送信することによって、「閉」にこの状態から遷移することができます。"
    },
    {
      "indent": 3,
      "text": "closed: The \"closed\" state is the terminal state.",
      "ja": "閉じた：「閉」の状態は、端末の状態です。"
    },
    {
      "indent": 6,
      "text": "An endpoint MUST NOT send frames other than PRIORITY on a closed stream. An endpoint that receives any frame other than PRIORITY after receiving a RST_STREAM MUST treat that as a stream error (Section 5.4.2) of type STREAM_CLOSED. Similarly, an endpoint that receives any frames after receiving a frame with the END_STREAM flag set MUST treat that as a connection error (Section 5.4.1) of type STREAM_CLOSED, unless the frame is permitted as described below.",
      "ja": "エンドポイントは、閉じたストリームを優先以外のフレームを送ってはいけません。 RST_STREAMを受信した後に優先度よりも他の任意のフレームを受信したエンドポイントは、タイプSTREAM_CLOSEDのストリームエラー（5.4.2項）としてそれを処理しなければなりません。後述のようにフレームが許可されていない限り、同様に、END_STREAMフラグを設定してフレームを受信した後に任意のフレームを受信したエンドポイントは、タイプSTREAM_CLOSEDの接続エラー（セクション5.4.1）としてそれを処理しなければなりません。"
    },
    {
      "indent": 6,
      "text": "WINDOW_UPDATE or RST_STREAM frames can be received in this state for a short period after a DATA or HEADERS frame containing an END_STREAM flag is sent. Until the remote peer receives and processes RST_STREAM or the frame bearing the END_STREAM flag, it might send frames of these types. Endpoints MUST ignore WINDOW_UPDATE or RST_STREAM frames received in this state, though endpoints MAY choose to treat frames that arrive a significant time after sending END_STREAM as a connection error (Section 5.4.1) of type PROTOCOL_ERROR.",
      "ja": "END_STREAMフラグを含むデータ又はHEADERSフレームが送信された後WINDOW_UPDATEまたはRST_STREAMフレームは、短い期間この状態で受信することができます。リモートピアが受信しRST_STREAM又はEND_STREAMフラグを担持するフレームを処理するまで、それは、これらのタイプのフレームを送信するかもしれません。エンドポイントは型PROTOCOL_ERRORの接続エラー（5.4.1項）としてEND_STREAMを送信した後に、かなりの時間に到着するフレームを処理することを選択したかもしれませんがエンドポイントは、この状態で受信WINDOW_UPDATEまたはRST_STREAMフレームを無視しなければなりません。"
    },
    {
      "indent": 6,
      "text": "PRIORITY frames can be sent on closed streams to prioritize streams that are dependent on the closed stream. Endpoints SHOULD process PRIORITY frames, though they can be ignored if the stream has been removed from the dependency tree (see Section 5.3.4).",
      "ja": "PRIORITYフレームが閉じストリームに依存するストリームの優先順位を決定するために、閉じたストリーム上で送信することができます。ストリームは依存関係ツリーから削除された場合、彼らは（5.3.4項を参照）を無視することができてもエンドポイントは、PRIORITYフレームを処理する必要があります。"
    },
    {
      "indent": 6,
      "text": "If this state is reached as a result of sending a RST_STREAM frame, the peer that receives the RST_STREAM might have already sent -- or enqueued for sending -- frames on the stream that cannot be withdrawn. An endpoint MUST ignore frames that it receives on closed streams after it has sent a RST_STREAM frame. An endpoint MAY choose to limit the period over which it ignores frames and treat frames that arrive after this time as being in error.",
      "ja": "この状態はRST_STREAMフレームを送信した結果として到達した場合は、RST_STREAMを受けたピアは、すでに送信されたかもしれない - または送信するためにキューに入れられた - フレームを撤回することはできませんストリーム上。エンドポイントは、それがRST_STREAMフレームを送信した後、それが閉じたストリームに対して受信フレームを無視しなければなりません。エンドポイントは、それがフレームを無視する期間を制限し、エラーであるとして、この時間後に到着するフレームを処理するために選ぶかもしれません。"
    },
    {
      "indent": 6,
      "text": "Flow-controlled frames (i.e., DATA) received after sending RST_STREAM are counted toward the connection flow-control window. Even though these frames might be ignored, because they are sent before the sender receives the RST_STREAM, the sender will consider the frames to count against the flow-control window.",
      "ja": "フロー制御フレーム（すなわち、DATA）は、接続フロー制御ウィンドウに向かってカウントされRST_STREAMを送信後に受信しました。送信者がRST_STREAMを受信する前に、彼らが送信されるため、これらのフレームは、無視される可能性がありますにもかかわらず、送信者は、フロー制御ウィンドウに対してカウントするフレームを検討します。"
    },
    {
      "indent": 6,
      "text": "An endpoint might receive a PUSH_PROMISE frame after it sends RST_STREAM. PUSH_PROMISE causes a stream to become \"reserved\" even if the associated stream has been reset. Therefore, a RST_STREAM is needed to close an unwanted promised stream.",
      "ja": "それはRST_STREAMを送信した後、エンドポイントはPUSH_PROMISEフレームを受け取ることがあります。 PUSH_PROMISEは、関連付けられたストリームがリセットされた場合でも、「予約済み」になるためのストリームを引き起こします。したがって、RST_STREAMは不要約束したストリームをクローズするために必要とされます。"
    },
    {
      "indent": 3,
      "text": "In the absence of more specific guidance elsewhere in this document, implementations SHOULD treat the receipt of a frame that is not expressly permitted in the description of a state as a connection error (Section 5.4.1) of type PROTOCOL_ERROR. Note that PRIORITY can be sent and received in any stream state. Frames of unknown types are ignored.",
      "ja": "他の場所この文書のより具体的なガイダンスが存在しない場合、実装は、明示型PROTOCOL_ERRORの接続エラー（セクション5.4.1）のように状態の説明に許可されていないフレームの受信を扱うべきです。その優先順位はどのストリームの状態で送信され、受信することができます。未知のタイプのフレームは無視されます。"
    },
    {
      "indent": 3,
      "text": "An example of the state transitions for an HTTP request/response exchange can be found in Section 8.1. An example of the state transitions for server push can be found in Sections 8.2.1 and 8.2.2.",
      "ja": "HTTPリクエスト/応答交換のための状態遷移の一例は、8.1節に見出すことができます。サーバプッシュのための状態遷移の一例は、セクション8.2.1および8.2.2に見出すことができます。"
    },
    {
      "indent": 0,
      "text": "5.1.1. Stream Identifiers",
      "section_title": true,
      "ja": "5.1.1. ストリーム識別子"
    },
    {
      "indent": 3,
      "text": "Streams are identified with an unsigned 31-bit integer. Streams initiated by a client MUST use odd-numbered stream identifiers; those initiated by the server MUST use even-numbered stream identifiers. A stream identifier of zero (0x0) is used for connection control messages; the stream identifier of zero cannot be used to establish a new stream.",
      "ja": "ストリームは、符号なし31ビット整数で識別されます。クライアントによって開始されたストリームは、奇数ストリーム識別子を使用しなければなりません。サーバによって開始されたものは、偶数ストリーム識別子を使用しなければなりません。ゼロ（0x0の）のストリーム識別子は、接続制御メッセージのために使用されます。ゼロのストリーム識別子は、新しいストリームを確立するために使用することはできません。"
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 requests that are upgraded to HTTP/2 (see Section 3.2) are responded to with a stream identifier of one (0x1). After the upgrade completes, stream 0x1 is \"half-closed (local)\" to the client. Therefore, stream 0x1 cannot be selected as a new stream identifier by a client that upgrades from HTTP/1.1.",
      "ja": "HTTP / 2（3.2節を参照）にアップグレードされているHTTP / 1.1リクエストは、1（0x1の）のストリーム識別子で応答しています。アップグレードが完了したら、ストリーム0x1のは、クライアントに「半分閉じた（ローカル）」です。したがって、ストリーム0x1のは、HTTP / 1.1からのアップグレード、クライアントによって新しいストリーム識別子として選択することはできません。"
    },
    {
      "indent": 3,
      "text": "The identifier of a newly established stream MUST be numerically greater than all streams that the initiating endpoint has opened or reserved. This governs streams that are opened using a HEADERS frame and streams that are reserved using PUSH_PROMISE. An endpoint that receives an unexpected stream identifier MUST respond with a connection error (Section 5.4.1) of type PROTOCOL_ERROR.",
      "ja": "新しく設立されたストリームの識別子は、すべての開始エンドポイントがオープンまたは予約したことストリームよりも数値的に大きくなければなりません。これは、ヘッダフレームとPUSH_PROMISEを使用して予約されたストリームを使用して開かれているストリームを支配します。予想外のストリーム識別子を受信したエンドポイントは、タイプPROTOCOL_ERRORの接続エラー（5.4.1）で応答しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The first use of a new stream identifier implicitly closes all streams in the \"idle\" state that might have been initiated by that peer with a lower-valued stream identifier. For example, if a client sends a HEADERS frame on stream 7 without ever sending a frame on stream 5, then stream 5 transitions to the \"closed\" state when the first frame for stream 7 is sent or received.",
      "ja": "新しいストリーム識別子の最初の使用は、暗黙的に低値のストリーム識別子とそのピアによって開始された可能性があります「アイドル」状態にあるすべてのストリームを閉じます。クライアントが今までストリーム5にフレームを送信せずにストリーム7上のヘッダフレームを送信した場合、ストリーム7の最初のフレームが送信または受信された場合、例えば、次に「閉」状態に遷移5をストリーミングします。"
    },
    {
      "indent": 3,
      "text": "Stream identifiers cannot be reused. Long-lived connections can result in an endpoint exhausting the available range of stream identifiers. A client that is unable to establish a new stream identifier can establish a new connection for new streams. A server that is unable to establish a new stream identifier can send a GOAWAY frame so that the client is forced to open a new connection for new streams.",
      "ja": "ストリーム識別子は再利用することはできません。長命の接続は、ストリーム識別子の利用可能範囲を排出するエンドポイントになります。新しいストリームの識別子を確立することができないクライアントは、新たなストリームのための新しい接続を確立することができます。クライアントが新しいストリームのための新しい接続を開くことを余儀なくされるようにGOAWAYフレームを送信することができ、新たなストリーム識別子を確立することができませんサーバー。"
    },
    {
      "indent": 0,
      "text": "5.1.2. Stream Concurrency",
      "section_title": true,
      "ja": "5.1.2. ストリームの同時実行"
    },
    {
      "indent": 3,
      "text": "A peer can limit the number of concurrently active streams using the SETTINGS_MAX_CONCURRENT_STREAMS parameter (see Section 6.5.2) within a SETTINGS frame. The maximum concurrent streams setting is specific to each endpoint and applies only to the peer that receives the setting. That is, clients specify the maximum number of concurrent streams the server can initiate, and servers specify the maximum number of concurrent streams the client can initiate.",
      "ja": "ピアは、設定フレーム内（セクション6.5.2を参照）SETTINGS_MAX_CONCURRENT_STREAMSパラメータを使用して、同時にアクティブなストリームの数を制限することができます。最大同時ストリームの設定は、各エンドポイントに固有であり、唯一の設定を受け付けるピアに適用されます。つまり、クライアントは、サーバが開始できる同時ストリームの最大数を指定して、サーバは、クライアントが開始できる同時ストリームの最大数を指定します。"
    },
    {
      "indent": 3,
      "text": "Streams that are in the \"open\" state or in either of the \"half-closed\" states count toward the maximum number of streams that an endpoint is permitted to open. Streams in any of these three states count toward the limit advertised in the SETTINGS_MAX_CONCURRENT_STREAMS setting. Streams in either of the \"reserved\" states do not count toward the stream limit.",
      "ja": "「開」状態または「半閉」状態のいずれかであるストリームは、エンドポイントが開くことが許可されているストリームの最大数にカウント。これら三つの状態のいずれにおいても、ストリームはSETTINGS_MAX_CONCURRENT_STREAMS設定で広告の制限にカウントされます。 「予約済み」状態のいずれかでのストリームは、ストリームの制限にはカウントされません。"
    },
    {
      "indent": 3,
      "text": "Endpoints MUST NOT exceed the limit set by their peer. An endpoint that receives a HEADERS frame that causes its advertised concurrent stream limit to be exceeded MUST treat this as a stream error (Section 5.4.2) of type PROTOCOL_ERROR or REFUSED_STREAM. The choice of error code determines whether the endpoint wishes to enable automatic retry (see Section 8.1.4) for details).",
      "ja": "エンドポイントは、そのピアによって設定された制限を超えてはなりません。超えなければ、そのアドバタイズ同時ストリーム制限を引き起こすヘッダフレームを受信したエンドポイントは、タイプPROTOCOL_ERROR又はREFUSED_STREAMのストリームエラー（5.4.2項）としてこれを扱う必要があります。エラーコードの選択は、エンドポイントが自動再試行の詳細は（セクション8.1.4を参照））を有効にしたいかどうかを判断します。"
    },
    {
      "indent": 3,
      "text": "An endpoint that wishes to reduce the value of SETTINGS_MAX_CONCURRENT_STREAMS to a value that is below the current number of open streams can either close streams that exceed the new value or allow streams to complete.",
      "ja": "オープンストリーム新しい値を超えるか、ストリームが完了することを可能にするいずれかの近くのストリームの現在の数を下回る値にSETTINGS_MAX_CONCURRENT_STREAMSの値を小さくしたいエンドポイント。"
    },
    {
      "indent": 0,
      "text": "5.2. Flow Control",
      "section_title": true,
      "ja": "5.2. フロー制御"
    },
    {
      "indent": 3,
      "text": "Using streams for multiplexing introduces contention over use of the TCP connection, resulting in blocked streams. A flow-control scheme ensures that streams on the same connection do not destructively interfere with each other. Flow control is used for both individual streams and for the connection as a whole.",
      "ja": "多重化ストリームを使用してブロックされたストリームで、その結果、TCP接続の使用上の競合を導入します。フロー制御方式は、同じ接続上のストリームが破壊的に互いに干渉しないことを保証します。フロー制御は、両方の個々のストリームの全体としての接続のために使用されます。"
    },
    {
      "indent": 3,
      "text": "HTTP/2 provides for flow control through use of the WINDOW_UPDATE frame (Section 6.9).",
      "ja": "HTTP / 2 WINDOW_UPDATEフレーム（セクション6.9）の使用を介してフロー制御を提供します。"
    },
    {
      "indent": 0,
      "text": "5.2.1. Flow-Control Principles",
      "section_title": true,
      "ja": "5.2.1. フロー制御の原理"
    },
    {
      "indent": 3,
      "text": "HTTP/2 stream flow control aims to allow a variety of flow-control algorithms to be used without requiring protocol changes. Flow control in HTTP/2 has the following characteristics:",
      "ja": "HTTP / 2ストリームのフロー制御は、フロー制御アルゴリズムの様々なプロトコルの変更を必要とせずに使用できるようにすることを目的とします。 HTTP / 2でのフロー制御は、次の特性があります。"
    },
    {
      "indent": 3,
      "text": "1. Flow control is specific to a connection. Both types of flow control are between the endpoints of a single hop and not over the entire end-to-end path.",
      "ja": "1.フロー制御は、接続に固有です。フロー制御の両方のタイプは、シングルホップのエンドポイント間ではなく、全体のエンドツーエンドパス上にあります。"
    },
    {
      "indent": 3,
      "text": "2. Flow control is based on WINDOW_UPDATE frames. Receivers advertise how many octets they are prepared to receive on a stream and for the entire connection. This is a credit-based scheme.",
      "ja": "2.フロー制御はWINDOW_UPDATEフレームに基づいています。レシーバは、彼らがストリーム上で、全体の接続のために受信する用意があるどのように多くのオクテット宣伝します。これは、クレジットベースの方式です。"
    },
    {
      "indent": 3,
      "text": "3. Flow control is directional with overall control provided by the receiver. A receiver MAY choose to set any window size that it desires for each stream and for the entire connection. A sender MUST respect flow-control limits imposed by a receiver. Clients, servers, and intermediaries all independently advertise their flow-control window as a receiver and abide by the flow-control limits set by their peer when sending.",
      "ja": "3.フロー制御は、受信機によって提供される全体的な制御に指向です。受信機は、各ストリームのために、全体の接続のために希望する任意のウィンドウサイズを設定することを選択するかもしれません。送信側は受信側によって課されるフロー制御の制限を尊重しなければなりません。クライアント、サーバ、および仲介は、すべて独立して受信機としてのフロー制御ウィンドウを宣伝して送信するときに、そのピアによって設定されたフロー制御の制限を遵守します。"
    },
    {
      "indent": 3,
      "text": "4. The initial value for the flow-control window is 65,535 octets for both new streams and the overall connection.",
      "ja": "前記フロー制御ウィンドウの初期値は、新たなストリームと全体的な接続の両方のために65,535オクテットです。"
    },
    {
      "indent": 3,
      "text": "5. The frame type determines whether flow control applies to a frame. Of the frames specified in this document, only DATA frames are subject to flow control; all other frame types do not consume space in the advertised flow-control window. This ensures that important control frames are not blocked by flow control.",
      "ja": "5.フレームタイプは、フロー制御フレームに適用されるか否かを判定する。この文書で指定されたフレームの、唯一のデータフレームはフロー制御の対象です。他のすべてのフレームタイプは、アドバタイズされたフロー制御ウィンドウ内のスペースを消費しません。これは重要な制御フレームがフロー制御でブロックされていないことを保証します。"
    },
    {
      "indent": 3,
      "text": "6. Flow control cannot be disabled.",
      "section_title": true,
      "ja": "6.フロー制御は無効にすることはできません。"
    },
    {
      "indent": 3,
      "text": "7. HTTP/2 defines only the format and semantics of the WINDOW_UPDATE frame (Section 6.9). This document does not stipulate how a receiver decides when to send this frame or the value that it sends, nor does it specify how a sender chooses to send packets. Implementations are able to select any algorithm that suits their needs.",
      "ja": "7. HTTP / 2はWINDOW_UPDATEフレーム（セクション6.9）のみフォーマット及びセマンティクスを定義します。この文書では、このフレームまたはそれが送信した値を送信する際、受信機がどのように決定するか規定しておらず、送信者がパケットを送信することを選択する方法を指定しません。実装は、自分のニーズに合った任意のアルゴリズムを選択することができます。"
    },
    {
      "indent": 3,
      "text": "Implementations are also responsible for managing how requests and responses are sent based on priority, choosing how to avoid head-of-line blocking for requests, and managing the creation of new streams. Algorithm choices for these could interact with any flow-control algorithm.",
      "ja": "また、実装は、要求と応答を要求するためのヘッドオブラインブロッキングを回避する方法の選択、優先順位に基づいて送信され、新しいストリームの作成を管理している方法を管理する責任があります。これらのアルゴリズムの選択は、任意のフロー制御アルゴリズムと相互作用することができます。"
    },
    {
      "indent": 0,
      "text": "5.2.2. Appropriate Use of Flow Control",
      "section_title": true,
      "ja": "5.2.2. フロー制御の適切な使用"
    },
    {
      "indent": 3,
      "text": "Flow control is defined to protect endpoints that are operating under resource constraints. For example, a proxy needs to share memory between many connections and also might have a slow upstream connection and a fast downstream one. Flow-control addresses cases where the receiver is unable to process data on one stream yet wants to continue to process other streams in the same connection.",
      "ja": "フロー制御は、資源制約の下で動作しているエンドポイントを保護するために定義されています。たとえば、プロキシは、多くの接続の間でメモリを共有する必要があるとも遅い上流接続と高速下流の1を持っているかもしれません。受信機は、まだ一つのストリーム上のデータを処理することができませんフロー制御アドレスの場合は、同じ接続で他のストリームを処理していきたいと考えています。"
    },
    {
      "indent": 3,
      "text": "Deployments that do not require this capability can advertise a flow-control window of the maximum size (2^31-1) and can maintain this window by sending a WINDOW_UPDATE frame when any data is received. This effectively disables flow control for that receiver. Conversely, a sender is always subject to the flow-control window advertised by the receiver.",
      "ja": "最大サイズ（2 ^ 31-1）のフロー制御ウィンドウを宣伝することができ、この機能を必要とせず、任意のデータが受信されるとWINDOW_UPDATEフレームを送信することによって、このウィンドウを維持することができる展開。これは、効果的にその受信機のためのフロー制御を無効にします。逆に、送信側は常に受信機によって通知フロー制御ウィンドウの対象です。"
    },
    {
      "indent": 3,
      "text": "Deployments with constrained resources (for example, memory) can employ flow control to limit the amount of memory a peer can consume. Note, however, that this can lead to suboptimal use of available network resources if flow control is enabled without knowledge of the bandwidth-delay product (see [RFC7323]).",
      "ja": "制約されたリソース（例えば、メモリ）と展開は、ピアが消費できるメモリの量を制限するために、フロー制御を使用することができます。このフロー制御は、帯域幅遅延積の知識なしで有効になっている場合、利用可能なネットワークリソースの準最適利用をもたらすことができることは、注意してください（[RFC7323]を参照）。"
    },
    {
      "indent": 3,
      "text": "Even with full awareness of the current bandwidth-delay product, implementation of flow control can be difficult. When using flow control, the receiver MUST read from the TCP receive buffer in a timely fashion. Failure to do so could lead to a deadlock when critical frames, such as WINDOW_UPDATE, are not read and acted upon.",
      "ja": "でも、現在の帯域幅遅延積の完全な意識して、フロー制御の実装が困難な場合があります。フロー制御を使用する場合、受信機は、タイムリーに受信バッファをTCPから読まなければなりません。このようWINDOW_UPDATEなどの重要なフレームは、読んで作用していない時にこれを怠ると、デッドロックにつながる可能性があります。"
    },
    {
      "indent": 0,
      "text": "5.3. Stream Priority",
      "section_title": true,
      "ja": "5.3. ストリームの優先順位"
    },
    {
      "indent": 3,
      "text": "A client can assign a priority for a new stream by including prioritization information in the HEADERS frame (Section 6.2) that opens the stream. At any other time, the PRIORITY frame (Section 6.3) can be used to change the priority of a stream.",
      "ja": "クライアントは、ストリームをオープンしHEADERSフレーム（6.2節）での優先順位付けの情報を含めることにより、新しいストリームの優先順位を割り当てることができます。他の任意の時点で、PRIORITYフレーム（6.3）は、ストリームの優先順位を変更するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "The purpose of prioritization is to allow an endpoint to express how it would prefer its peer to allocate resources when managing concurrent streams. Most importantly, priority can be used to select streams for transmitting frames when there is limited capacity for sending.",
      "ja": "優先順位付けの目的は、同時ストリームを管理する際にリソースを割り当てるために、そのピアを好むだろうどのように表現するためにエンドポイントをできるようにすることです。最も重要なことは、優先順位は、送信するための限られた容量がある場合には、フレームを送信するためのストリームを選択するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "Streams can be prioritized by marking them as dependent on the completion of other streams (Section 5.3.1). Each dependency is assigned a relative weight, a number that is used to determine the relative proportion of available resources that are assigned to streams dependent on the same stream.",
      "ja": "ストリームは、他のストリーム（5.3.1項）の完了に依存するようにそれらをマークすることによって優先順位を付けることができます。各依存性は相対重量、同じストリームに依存ストリームに割り当てられている利用可能なリソースの相対的な割合を決定するために使用される番号が割り当てられます。"
    },
    {
      "indent": 3,
      "text": "Explicitly setting the priority for a stream is input to a prioritization process. It does not guarantee any particular processing or transmission order for the stream relative to any other stream. An endpoint cannot force a peer to process concurrent streams in a particular order using priority. Expressing priority is therefore only a suggestion.",
      "ja": "明示的ストリームの優先順位を設定する優先順位付けプロセスに入力されます。それは、他のストリームに対するストリームに対してための任意の特定の処理又は送信順序を保証しません。エンドポイントは、優先順位を使用して特定の順序で同時ストリームを処理するピアを強制することはできません。優先順位を表現するため、唯一の提案です。"
    },
    {
      "indent": 3,
      "text": "Prioritization information can be omitted from messages. Defaults are used prior to any explicit values being provided (Section 5.3.5).",
      "ja": "優先順位付け情報は、メッセージから省略することができます。明示的な値は（セクション5.3.5）に設けられているデフォルトは、従来使用されています。"
    },
    {
      "indent": 0,
      "text": "5.3.1. Stream Dependencies",
      "section_title": true,
      "ja": "5.3.1. ストリームの依存関係"
    },
    {
      "indent": 3,
      "text": "Each stream can be given an explicit dependency on another stream. Including a dependency expresses a preference to allocate resources to the identified stream rather than to the dependent stream.",
      "ja": "各ストリームは、別のストリーム上の明示的な依存関係を与えることができます。依存含めて識別されたストリームにではなく、依存ストリームにリソースを割り当てるための嗜好を表現します。"
    },
    {
      "indent": 3,
      "text": "A stream that is not dependent on any other stream is given a stream dependency of 0x0. In other words, the non-existent stream 0 forms the root of the tree.",
      "ja": "他のストリームに依存しないストリームは、0x0のストリーム依存性が与えられます。言い換えれば、存在しないストリーム0フォームツリーのルート。"
    },
    {
      "indent": 3,
      "text": "A stream that depends on another stream is a dependent stream. The stream upon which a stream is dependent is a parent stream. A dependency on a stream that is not currently in the tree -- such as a stream in the \"idle\" state -- results in that stream being given a default priority (Section 5.3.5).",
      "ja": "別のストリームに依存ストリームは依存ストリームです。ストリームが依存している時にストリームが親ストリームです。そのような「アイドル」状態にストリームとして -   - ツリーではない現在のストリームに依存そのストリームにおける結果は、デフォルトの優先度（5.3.5項）​​を与えられます。"
    },
    {
      "indent": 3,
      "text": "When assigning a dependency on another stream, the stream is added as a new dependency of the parent stream. Dependent streams that share the same parent are not ordered with respect to each other. For example, if streams B and C are dependent on stream A, and if stream D is created with a dependency on stream A, this results in a dependency order of A followed by B, C, and D in any order.",
      "ja": "別のストリームへの依存を割り当てる場合、ストリームは、親ストリームの新たな依存関係として追加されます。同じ親を共有従属ストリームは、互いに対して順序付けされていません。ストリームB及びCは、ストリームAに依存している場合、ストリームDは、ストリームAに依存して作成された場合、例えば、これは任意の順序でB、C、及びDに続くの依存関係の順序になります。"
    },
    {
      "indent": 5,
      "text": " A A / \\ ==> /|\\ B C B D C",
      "ja": "A / \\ ==> / | \\ B C B D C"
    },
    {
      "indent": 13,
      "text": "Figure 3: Example of Default Dependency Creation",
      "ja": "図3：デフォルトの依存関係の作成の例"
    },
    {
      "indent": 3,
      "text": "An exclusive flag allows for the insertion of a new level of dependencies. The exclusive flag causes the stream to become the sole dependency of its parent stream, causing other dependencies to become dependent on the exclusive stream. In the previous example, if stream D is created with an exclusive dependency on stream A, this results in D becoming the dependency parent of B and C.",
      "ja": "排他フラグは、依存関係の新たなレベルの挿入を可能にします。排他フラグは、他の依存関係が排他的な流れに依存するようになるさせ、その親ストリームの唯一の依存関係になるためにストリームが発生します。ストリームDは、ストリームAに排他的依存性を使用して作成された場合、前の例では、これはBとCの依存関係の親になってDになります"
    },
    {
      "indent": 5,
      "text": " A A | / \\ ==> D B C / \\ B C",
      "ja": "A | / \\ ==> D B C / \\ B C"
    },
    {
      "indent": 12,
      "text": "Figure 4: Example of Exclusive Dependency Creation",
      "ja": "図4：排他依存関係の作成の例"
    },
    {
      "indent": 3,
      "text": "Inside the dependency tree, a dependent stream SHOULD only be allocated resources if either all of the streams that it depends on (the chain of parent streams up to 0x0) are closed or it is not possible to make progress on them.",
      "ja": "それが依存するストリームのすべてが（親のチェーンが0x0にアップストリーム）閉鎖されているか、彼らの進捗状況を作成することはできませんいずれかの場合、依存関係ツリーの内部では、依存ストリームは、リソースのみを割り当てられるべきです。"
    },
    {
      "indent": 3,
      "text": "A stream cannot depend on itself. An endpoint MUST treat this as a stream error (Section 5.4.2) of type PROTOCOL_ERROR.",
      "ja": "ストリームは、それ自体に依存することはできません。エンドポイントは、タイプPROTOCOL_ERRORのストリームエラー（5.4.2項）としてこれを扱わなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.3.2. Dependency Weighting",
      "section_title": true,
      "ja": "5.3.2. 依存関係の重み付け"
    },
    {
      "indent": 3,
      "text": "All dependent streams are allocated an integer weight between 1 and 256 (inclusive).",
      "ja": "すべての依存ストリームは1〜256（両端を含む）の整数の重みを割り当てられます。"
    },
    {
      "indent": 3,
      "text": "Streams with the same parent SHOULD be allocated resources proportionally based on their weight. Thus, if stream B depends on stream A with weight 4, stream C depends on stream A with weight 12, and no progress can be made on stream A, stream B ideally receives one-third of the resources allocated to stream C.",
      "ja": "同じ親を持つストリームは、その重量に基づいて、比例リソースを割り当てられるべきです。ストリームBは、重量4とストリームAに依存している場合このように、ストリームCは、重量12を有するストリームAに依存し、全く進展がストリームA上に形成することができない、ストリームBは、理想的には、Cをストリームに割り当てられたリソースの3分の1を受け取ります"
    },
    {
      "indent": 0,
      "text": "5.3.3. Reprioritization",
      "section_title": true,
      "ja": "5.3.3.  Reprioritization"
    },
    {
      "indent": 3,
      "text": "Stream priorities are changed using the PRIORITY frame. Setting a dependency causes a stream to become dependent on the identified parent stream.",
      "ja": "ストリームの優先順位は、PRIORITYフレームを使用して変更されています。依存関係を設定すると、ストリームが識別される親ストリームに依存するようになるようにします。"
    },
    {
      "indent": 3,
      "text": "Dependent streams move with their parent stream if the parent is reprioritized. Setting a dependency with the exclusive flag for a reprioritized stream causes all the dependencies of the new parent stream to become dependent on the reprioritized stream.",
      "ja": "親が再び優先順位づけされた場合に依存ストリームは、その親ストリームに移動します。再び優先順位づけストリームのための排他的なフラグを使用して依存関係を設定すると、新しい親ストリームのすべての依存関係が再び優先順位づけストリームに依存するようになるようにします。"
    },
    {
      "indent": 3,
      "text": "If a stream is made dependent on one of its own dependencies, the formerly dependent stream is first moved to be dependent on the reprioritized stream's previous parent. The moved dependency retains its weight.",
      "ja": "ストリームは、独自の依存関係の1つに依存された場合、以前は依存ストリームは、最初に再び優先順位づけストリームの前の親に依存するように移動させられます。移動依存性は、その重量を保持します。"
    },
    {
      "indent": 3,
      "text": "For example, consider an original dependency tree where B and C depend on A, D and E depend on C, and F depends on D. If A is made dependent on D, then D takes the place of A. All other dependency relationships stay the same, except for F, which becomes dependent on A if the reprioritization is exclusive.",
      "ja": "AはDに依存されている場合たとえば、BとCはA、D及びEに依存して、元の依存関係ツリーがCに依存して考慮し、FはDに依存し、そしてDは、他のすべての依存関係が滞在A.の起こりreprioritizationが排他的であればAに依存するようになるF、を除いて、同じ。"
    },
    {
      "indent": 5,
      "text": " x x x x | / \\ | | A D A D D / \\ / / \\ / \\ | B C ==> F B C ==> F A OR A / \\ | / \\ /|\\ D E E B C B C F | | | F E E (intermediate) (non-exclusive) (exclusive)",
      "ja": "X X X X | / \\ | | D A D D / \\ / / \\ / \\ | BのC ==> F B C ==> F A OR A / \\ | / \\ / | \\ D E E B C B C F | | | F E E（非排他的）（中間体）（排他的）"
    },
    {
      "indent": 16,
      "text": "Figure 5: Example of Dependency Reordering",
      "ja": "図5：依存性の並べ替えの例"
    },
    {
      "indent": 0,
      "text": "5.3.4. Prioritization State Management",
      "section_title": true,
      "ja": "5.3.4. 優先順位付け状態管理"
    },
    {
      "indent": 3,
      "text": "When a stream is removed from the dependency tree, its dependencies can be moved to become dependent on the parent of the closed stream. The weights of new dependencies are recalculated by distributing the weight of the dependency of the closed stream proportionally based on the weights of its dependencies.",
      "ja": "ストリームは依存関係ツリーから削除された場合、その依存関係は、閉じたストリームの親に依存するようになるために移動することができます。新しい依存関係の重みは比例し、その依存関係の重みに基づいて、閉じたストリームの依存性の重量を分配することによって再計算されます。"
    },
    {
      "indent": 3,
      "text": "Streams that are removed from the dependency tree cause some prioritization information to be lost. Resources are shared between streams with the same parent stream, which means that if a stream in that set closes or becomes blocked, any spare capacity allocated to a stream is distributed to the immediate neighbors of the stream. However, if the common dependency is removed from the tree, those streams share resources with streams at the next highest level.",
      "ja": "依存関係ツリーから削除されたストリームは、いくつかの優先順位付けの情報が失われ。リソースは、そのセット内のストリームが閉じまたはブロックされた状態になる場合は、ストリームに割り当てられた予備容量は、ストリームのすぐ隣に配布されることを意味し、同じ親ストリームとストリーム間で共有されています。しかし、一般的な依存関係をツリーから削除された場合、次に高いレベルのストリームとそれらのストリームリソースを共有し。"
    },
    {
      "indent": 3,
      "text": "For example, assume streams A and B share a parent, and streams C and D both depend on stream A. Prior to the removal of stream A, if streams A and D are unable to proceed, then stream C receives all the resources dedicated to stream A. If stream A is removed from the tree, the weight of stream A is divided between streams C and D. If stream D is still unable to proceed, this results in stream C receiving a reduced proportion of resources. For equal starting weights, C receives one third, rather than one half, of available resources.",
      "ja": "例えば、ストリームA及びB株親を想定し、ストリームA及びDが進行することができない場合はCとDの両方が、前のストリームAの除去にストリームA.依存ストリームを、そのストリームCは、専用にすべてのリソースを受信しますストリームAがツリーから削除された場合、ストリームDは、依然として進行することができない場合、ストリームA.、ストリームAの重量は、ストリームCとDの間で分割され、これは資源の減少割合を受信ストリームCをもたらします。等しい開始量について、Cは、利用可能なリソースの、むしろ半分より、三分の一を受信します。"
    },
    {
      "indent": 3,
      "text": "It is possible for a stream to become closed while prioritization information that creates a dependency on that stream is in transit. If a stream identified in a dependency has no associated priority information, then the dependent stream is instead assigned a default priority (Section 5.3.5). This potentially creates suboptimal prioritization, since the stream could be given a priority that is different from what is intended.",
      "ja": "そのストリームへの依存を作成し、優先順位付け情報が転送中である間、ストリームがクローズになることが可能です。依存して識別されたストリームに関連付けられている優先度情報を有していない場合、依存ストリームではなく、デフォルトの優先順位（5.3.5項）​​が割り当てられます。ストリームが意図されているものと異なる優先順位を与えることができるので、これは潜在的に、次善の優先順位付けを作成します。"
    },
    {
      "indent": 3,
      "text": "To avoid these problems, an endpoint SHOULD retain stream prioritization state for a period after streams become closed. The longer state is retained, the lower the chance that streams are assigned incorrect or default priority values.",
      "ja": "ストリームがクローズになった後、これらの問題を回避するために、エンドポイントは、期間のため、ストリームの優先順位付けの状態を保持しなければなりません。長い状態が低く、ストリームが正しくないか、デフォルトの優先順位の値を割り当てられている可能性を保持しています。"
    },
    {
      "indent": 3,
      "text": "Similarly, streams that are in the \"idle\" state can be assigned priority or become a parent of other streams. This allows for the creation of a grouping node in the dependency tree, which enables more flexible expressions of priority. Idle streams begin with a default priority (Section 5.3.5).",
      "ja": "同様に、「アイドル」状態にあるストリームは、優先順位が割り当てられ、又は他のストリームの親になることができます。これは、優先順位のより柔軟な表現を可能にする依存ツリーのグループノードの作成を可能にします。アイドルストリームは、デフォルトの優先度（5.3.5）で始まります。"
    },
    {
      "indent": 3,
      "text": "The retention of priority information for streams that are not counted toward the limit set by SETTINGS_MAX_CONCURRENT_STREAMS could create a large state burden for an endpoint. Therefore, the amount of prioritization state that is retained MAY be limited.",
      "ja": "エンドポイントの大きい状態の負担を作成することができSETTINGS_MAX_CONCURRENT_STREAMSによって設定された制限にカウントされていないストリームの優先度情報を保持します。したがって、保持される優先順位付け状態の量が制限されてもよいです。"
    },
    {
      "indent": 3,
      "text": "The amount of additional state an endpoint maintains for prioritization could be dependent on load; under high load, prioritization state can be discarded to limit resource commitments. In extreme cases, an endpoint could even discard prioritization state for active or reserved streams. If a limit is applied, endpoints SHOULD maintain state for at least as many streams as allowed by their setting for SETTINGS_MAX_CONCURRENT_STREAMS. Implementations SHOULD also attempt to retain state for streams that are in active use in the priority tree.",
      "ja": "エンドポイントが優先順位付けのために維持して、追加の状態の量は負荷に依存し得ます。高負荷の下で、優先順位付けの状態は、リソースのコミットメントを制限するために、廃棄することができます。極端な場合には、エンドポイントがあっても、アクティブまたは予約ストリームの優先順位付け状態を破棄する可能性があります。制限が適用される場合SETTINGS_MAX_CONCURRENT_STREAMSのためのそれらの設定によって許可されるように、エンドポイントは、少なくともとして多くのストリームの状態を維持しなければなりません。実装はまた、優先ツリーでアクティブに使用されているストリームの状態を維持することを試みるべきです。"
    },
    {
      "indent": 3,
      "text": "If it has retained enough state to do so, an endpoint receiving a PRIORITY frame that changes the priority of a closed stream SHOULD alter the dependencies of the streams that depend on it.",
      "ja": "それはそうするのに十分な状態を保持している場合、閉じたストリームの優先度を変更PRIORITYフレームを受信したエンドポイントがそれに依存するストリームの依存関係を変更すべきです。"
    },
    {
      "indent": 0,
      "text": "5.3.5. Default Priorities",
      "section_title": true,
      "ja": "5.3.5. デフォルトの優先順位"
    },
    {
      "indent": 3,
      "text": "All streams are initially assigned a non-exclusive dependency on stream 0x0. Pushed streams (Section 8.2) initially depend on their associated stream. In both cases, streams are assigned a default weight of 16.",
      "ja": "すべてのストリームは、最初にストリームを0x0の非排他的な依存関係を割り当てられています。プッシュされたストリーム（8.2節）は、最初はそれに関連付けられたストリームに依存します。両方の場合において、ストリームは、16のデフォルトの重みが割り当てられます。"
    },
    {
      "indent": 0,
      "text": "5.4. Error Handling",
      "section_title": true,
      "ja": "5.4. エラー処理"
    },
    {
      "indent": 3,
      "text": "HTTP/2 framing permits two classes of error:",
      "ja": "HTTP / 2フレーミングは、エラーの2つのクラスを許可します："
    },
    {
      "indent": 3,
      "text": "o An error condition that renders the entire connection unusable is a connection error.",
      "ja": "O接続全体が使用不能エラー条件は、接続エラーです。"
    },
    {
      "indent": 3,
      "text": "o An error in an individual stream is a stream error.",
      "ja": "O個々のストリームにエラーがストリームエラーです。"
    },
    {
      "indent": 3,
      "text": "A list of error codes is included in Section 7.",
      "ja": "エラーコードのリストは、セクション7に含まれています。"
    },
    {
      "indent": 0,
      "text": "5.4.1. Connection Error Handling",
      "section_title": true,
      "ja": "5.4.1. 接続エラー処理"
    },
    {
      "indent": 3,
      "text": "A connection error is any error that prevents further processing of the frame layer or corrupts any connection state.",
      "ja": "接続エラーは、フレーム層のさらなる処理を防止するか、任意の接続状態が破損エラーです。"
    },
    {
      "indent": 3,
      "text": "An endpoint that encounters a connection error SHOULD first send a GOAWAY frame (Section 6.8) with the stream identifier of the last stream that it successfully received from its peer. The GOAWAY frame includes an error code that indicates why the connection is terminating. After sending the GOAWAY frame for an error condition, the endpoint MUST close the TCP connection.",
      "ja": "接続エラーが発生したエンドポイントは、最初、それが正常にピアから受信した最後のストリームのストリーム識別子でGOAWAYフレーム（6.8節）を送信すべきです。 GOAWAYフレームは、接続が終了された理由を示すエラーコードを含みます。エラー条件のためGOAWAYフレームを送信した後、エンドポイントは、TCP接続を閉じる必要があります。"
    },
    {
      "indent": 3,
      "text": "It is possible that the GOAWAY will not be reliably received by the receiving endpoint ([RFC7230], Section 6.6 describes how an immediate connection close can result in data loss). In the event of a connection error, GOAWAY only provides a best-effort attempt to communicate with the peer about why the connection is being terminated.",
      "ja": "（[RFC7230]は、セクション6.6、即時接続が近いデータ損失をもたらすことができる方法を説明）GOAWAYを確実に受信エンドポイントによって受信されないことが可能です。接続エラーが発生した場合には、GOAWAYは唯一の接続が終了されている理由について、ピアと通信するベストエフォート型試みを提供します。"
    },
    {
      "indent": 3,
      "text": "An endpoint can end a connection at any time. In particular, an endpoint MAY choose to treat a stream error as a connection error. Endpoints SHOULD send a GOAWAY frame when ending a connection, providing that circumstances permit it.",
      "ja": "エンドポイントは、いつでも接続を終了することができます。具体的には、エンドポイントは、接続エラーとしてストリームエラーを処理するために選ぶかもしれません。接続を終了するとき、エンドポイントは、状況がそれを許可することを提供し、GOAWAYフレームを送るべきです。"
    },
    {
      "indent": 0,
      "text": "5.4.2. Stream Error Handling",
      "section_title": true,
      "ja": "5.4.2. ストリームのエラー処理"
    },
    {
      "indent": 3,
      "text": "A stream error is an error related to a specific stream that does not affect processing of other streams.",
      "ja": "ストリームのエラーは、他のストリームの処理に影響を与えない特定のストリームに関連するエラーです。"
    },
    {
      "indent": 3,
      "text": "An endpoint that detects a stream error sends a RST_STREAM frame (Section 6.4) that contains the stream identifier of the stream where the error occurred. The RST_STREAM frame includes an error code that indicates the type of error.",
      "ja": "ストリームエラーを検出したエンドポイントは、エラーが発生したストリームのストリーム識別子を含むRST_STREAMフレーム（6.4節）を送信します。 RST_STREAMフレームは、エラーのタイプを示すエラーコードを含みます。"
    },
    {
      "indent": 3,
      "text": "A RST_STREAM is the last frame that an endpoint can send on a stream. The peer that sends the RST_STREAM frame MUST be prepared to receive any frames that were sent or enqueued for sending by the remote peer. These frames can be ignored, except where they modify connection state (such as the state maintained for header compression (Section 4.3) or flow control).",
      "ja": "RST_STREAMは、エンドポイントがストリームに送ることができる最後のフレームです。 RST_STREAMフレームを送信するピアは、リモートピアによって送信するための送信またはエンキューされた任意のフレームを受信するように準備しなければなりません。これらのフレームは、それらが接続状態（この状態は、ヘッダ圧縮のために維持されるよう（セクション4.3）、またはフロー制御）を変更する場合を除いて、無視することができます。"
    },
    {
      "indent": 3,
      "text": "Normally, an endpoint SHOULD NOT send more than one RST_STREAM frame for any stream. However, an endpoint MAY send additional RST_STREAM frames if it receives frames on a closed stream after more than a round-trip time. This behavior is permitted to deal with misbehaving implementations.",
      "ja": "通常、エンドポイントは、任意のストリームに対して複数のRST_STREAMフレームを送るべきではありません。それが往復時間よりも後に閉じられたストリーム上でフレームを受信した場合は、エンドポイントは追加RST_STREAMフレームを送信することができます。この動作は、誤動作の実装に対処するために許可されています。"
    },
    {
      "indent": 3,
      "text": "To avoid looping, an endpoint MUST NOT send a RST_STREAM in response to a RST_STREAM frame.",
      "ja": "ループを回避するために、エンドポイントはRST_STREAMフレームに対応してRST_STREAMを送ってはいけません。"
    },
    {
      "indent": 0,
      "text": "5.4.3. Connection Termination",
      "section_title": true,
      "ja": "5.4.3. 接続終了"
    },
    {
      "indent": 3,
      "text": "If the TCP connection is closed or reset while streams remain in \"open\" or \"half-closed\" state, then the affected streams cannot be automatically retried (see Section 8.1.4 for details).",
      "ja": "TCP接続がストリームは、「オープン」または「半閉」状態のままながら、その後、影響を受けたストリームが自動的に再試行することはできません閉じたりリセットされた場合（詳細はセクション8.1.4を参照してください）。"
    },
    {
      "indent": 0,
      "text": "5.5. Extending HTTP/2",
      "section_title": true,
      "ja": "5.5. 拡張HTTP / 2"
    },
    {
      "indent": 3,
      "text": "HTTP/2 permits extension of the protocol. Within the limitations described in this section, protocol extensions can be used to provide additional services or alter any aspect of the protocol. Extensions are effective only within the scope of a single HTTP/2 connection.",
      "ja": "HTTP / 2プロトコルの拡張を可能にします。このセクションで説明する制限内で、プロトコル拡張は、追加のサービスを提供したり、プロトコルの任意の態様を変更するために使用することができます。拡張機能は、単一のHTTP / 2接続の範囲内で効果的です。"
    },
    {
      "indent": 3,
      "text": "This applies to the protocol elements defined in this document. This does not affect the existing options for extending HTTP, such as defining new methods, status codes, or header fields.",
      "ja": "これは、この文書で定義されたプロトコル要素に適用されます。これは、新しいメソッド、ステータスコード、またはヘッダフィールドを定義するものとして、HTTPを拡張するための既存のオプションには影響を与えません。"
    },
    {
      "indent": 3,
      "text": "Extensions are permitted to use new frame types (Section 4.1), new settings (Section 6.5.2), or new error codes (Section 7). Registries are established for managing these extension points: frame types (Section 11.2), settings (Section 11.3), and error codes (Section 11.4).",
      "ja": "拡張は、新たなフレームタイプ（4.1節）、新しい設定（セクション6.5.2）、または新しいエラーコード（セクション7）を使用することが許可されています。フレームタイプ（セクション11.2）、設定（11.3）、およびエラー・コード（セクション11.4）：レジストリは、これらの拡張ポイントを管理するために確立されています。"
    },
    {
      "indent": 3,
      "text": "Implementations MUST ignore unknown or unsupported values in all extensible protocol elements. Implementations MUST discard frames that have unknown or unsupported types. This means that any of these extension points can be safely used by extensions without prior arrangement or negotiation. However, extension frames that appear in the middle of a header block (Section 4.3) are not permitted; these MUST be treated as a connection error (Section 5.4.1) of type PROTOCOL_ERROR.",
      "ja": "実装は、すべての拡張可能なプロトコル要素に未知の、またはサポートされない値を無視しなければなりません。実装は、未知またはサポートされていない型を持つフレームを捨てなければなりません。これは、これらの拡張ポイントのいずれかが安全に事前配置や交渉せずに拡張して使用することができることを意味しています。しかし、ヘッダブロック（セクション4.3）の中央に表示される拡張フレームが許可されていません。これらは、型PROTOCOL_ERRORの接続エラー（セクション5.4.1）として扱われなければなりません。"
    },
    {
      "indent": 3,
      "text": "Extensions that could change the semantics of existing protocol components MUST be negotiated before being used. For example, an extension that changes the layout of the HEADERS frame cannot be used until the peer has given a positive signal that this is acceptable. In this case, it could also be necessary to coordinate when the revised layout comes into effect. Note that treating any frames other than DATA frames as flow controlled is such a change in semantics and can only be done through negotiation.",
      "ja": "既存のプロトコルコンポーネントのセマンティクスを変えることができる拡張機能が使用される前に交渉しなければなりません。ピアが、これは許容可能であることが陽性シグナルを与えたまで、例えば、ヘッダフレームのレイアウトを変更する拡張を使用することはできません。この場合、また、改訂されたレイアウトが有効になると調整する必要がある可能性があります。流量が制御されるようなデータフレーム以外のフレームを処理することの意味で、このような変更であり、唯一の交渉を介して行うことができることに注意してください。"
    },
    {
      "indent": 3,
      "text": "This document doesn't mandate a specific method for negotiating the use of an extension but notes that a setting (Section 6.5.2) could be used for that purpose. If both peers set a value that indicates willingness to use the extension, then the extension can be used. If a setting is used for extension negotiation, the initial value MUST be defined in such a fashion that the extension is initially disabled.",
      "ja": "この文書では、拡張の使用を交渉するための具体的な方法を義務付けるが、設定（6.5.2項）は、その目的のために使用することができると指摘していません。両方のピアは、拡張を使用する意思を示す値を設定した場合、拡張を使用することができます。設定が延長交渉のために使用されている場合、初期値は、拡張子は、初期段階では無効にされるような形で定義する必要があります。"
    },
    {
      "indent": 0,
      "text": "6. Frame Definitions",
      "section_title": true,
      "ja": "6.フレームの定義"
    },
    {
      "indent": 3,
      "text": "This specification defines a number of frame types, each identified by a unique 8-bit type code. Each frame type serves a distinct purpose in the establishment and management either of the connection as a whole or of individual streams.",
      "ja": "この仕様は、それぞれが固有の8ビットのタイプ・コードによって識別されるフレームタイプの数を定義します。各フレームタイプは、全体として、または個々のストリームの接続の確立及び管理のいずれかの明確な目的を果たします。"
    },
    {
      "indent": 3,
      "text": "The transmission of specific frame types can alter the state of a connection. If endpoints fail to maintain a synchronized view of the connection state, successful communication within the connection will no longer be possible. Therefore, it is important that endpoints have a shared comprehension of how the state is affected by the use any given frame.",
      "ja": "特定のフレームタイプの送信は、接続の状態を変化させることができます。エンドポイントは、接続状態の同期ビューを維持するために失敗した場合、接続内で正常な通信ができなくなります。そのため、エンドポイントが状態は使用して任意のフレームをどのように影響されるかの共有理解を持っていることが重要です。"
    },
    {
      "indent": 0,
      "text": "6.1. DATA",
      "section_title": true,
      "ja": "6.1. データ"
    },
    {
      "indent": 3,
      "text": "DATA frames (type=0x0) convey arbitrary, variable-length sequences of octets associated with a stream. One or more DATA frames are used, for instance, to carry HTTP request or response payloads.",
      "ja": "データフレーム（種別= 0x0の）は、ストリームに関連付けられたオクテットの任意の可変長配列を伝えます。一つ以上のデータフレームは、HTTP要求または応答ペイロードを運ぶために、例えば、使用されています。"
    },
    {
      "indent": 3,
      "text": "DATA frames MAY also contain padding. Padding can be added to DATA frames to obscure the size of messages. Padding is a security feature; see Section 10.7.",
      "ja": "データフレームはまた、パディングを含むかもしれません。パディングは、メッセージのサイズをあいまいにデータフレームに追加することができます。パディングは、セキュリティ機能です。 10.7節を参照してください。"
    },
    {
      "indent": 4,
      "text": "+---------------+\n|Pad Length? (8)|\n+---------------+-----------------------------------------------+\n|                            Data (*)                         ...\n+---------------------------------------------------------------+\n|                           Padding (*)                       ...\n+---------------------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 23,
      "text": "Figure 6: DATA Frame Payload",
      "ja": "図6：データフレームのペイロード"
    },
    {
      "indent": 3,
      "text": "The DATA frame contains the following fields:",
      "ja": "データフレームは、以下のフィールドが含まれています。"
    },
    {
      "indent": 3,
      "text": "Pad Length: An 8-bit field containing the length of the frame padding in units of octets. This field is conditional (as signified by a \"?\" in the diagram) and is only present if the PADDED flag is set.",
      "ja": "パッド長さ：オクテットの単位でフレームパディングの長さを含む8ビットのフィールド。このフィールドは、条件付きである（図中「？」によって示されるように）パッド付きフラグが設定されている場合にのみ存在します。"
    },
    {
      "indent": 3,
      "text": "Data: Application data. The amount of data is the remainder of the frame payload after subtracting the length of the other fields that are present.",
      "ja": "データ：アプリケーションデータ。データの量は、存在する他のフィールドの長さを差し引いた後のフレームペイロードの残りの部分です。"
    },
    {
      "indent": 3,
      "text": "Padding: Padding octets that contain no application semantic value. Padding octets MUST be set to zero when sending. A receiver is not obligated to verify padding but MAY treat non-zero padding as a connection error (Section 5.4.1) of type PROTOCOL_ERROR.",
      "ja": "パディング：何のアプリケーションセマンティック値を含まないパディングオクテット。送信するときにパディングオクテットはゼロに設定しなければなりません。受信機は、パディングを検証する義務ではなく、型PROTOCOL_ERRORの接続エラー（セクション5.4.1）のような非ゼロパディングを扱うかもしれ。"
    },
    {
      "indent": 3,
      "text": "The DATA frame defines the following flags:",
      "ja": "データフレームは以下のフラグが定義されています。"
    },
    {
      "indent": 3,
      "text": "END_STREAM (0x1): When set, bit 0 indicates that this frame is the last that the endpoint will send for the identified stream. Setting this flag causes the stream to enter one of the \"half-closed\" states or the \"closed\" state (Section 5.1).",
      "ja": "END_STREAM（0x1の）セット、ビット0は、このフレームは、エンドポイントが識別されたストリームのために送信すること最後であることを示しています。このフラグを設定すると、「半分閉じた」状態または「閉」の状態（5.1節）のいずれかを入力するストリームを引き起こします。"
    },
    {
      "indent": 3,
      "text": "PADDED (0x8): When set, bit 3 indicates that the Pad Length field and any padding that it describes are present.",
      "ja": "PADDED（0x8という）：セットは、ビット3は、パッドの長さフィールドと、それが記述する任意のパディングが存在することを示しています。"
    },
    {
      "indent": 3,
      "text": "DATA frames MUST be associated with a stream. If a DATA frame is received whose stream identifier field is 0x0, the recipient MUST respond with a connection error (Section 5.4.1) of type PROTOCOL_ERROR.",
      "ja": "データフレームは、ストリームに関連付けられなければなりません。データフレームが受信された場合、そのストリーム識別子フィールドが0x0であり、受信者は、タイプPROTOCOL_ERRORの接続エラー（5.4.1）で応答しなければなりません。"
    },
    {
      "indent": 3,
      "text": "DATA frames are subject to flow control and can only be sent when a stream is in the \"open\" or \"half-closed (remote)\" state. The entire DATA frame payload is included in flow control, including the Pad Length and Padding fields if present. If a DATA frame is received whose stream is not in \"open\" or \"half-closed (local)\" state, the recipient MUST respond with a stream error (Section 5.4.2) of type STREAM_CLOSED.",
      "ja": "データフレームはフロー制御の対象であり、ストリームは、「開」または「半閉（リモート）」状態にある場合にのみ送信することができます。全データフレームペイロードが存在する場合にパッド長およびパディングフィールドを含む、フロー制御に含まれています。データフレームは、そのストリーム「オープン」または「半閉（ローカル）」状態でない受信された場合、受信者はSTREAM_CLOSEDタイプのストリームエラー（5.4.2項）で応答しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The total number of padding octets is determined by the value of the Pad Length field. If the length of the padding is the length of the frame payload or greater, the recipient MUST treat this as a connection error (Section 5.4.1) of type PROTOCOL_ERROR.",
      "ja": "パディングオクテットの総数は、パッドの長さフィールドの値によって決定されます。パディングの長さは、フレームペイロード以上の長さである場合、受信者は型PROTOCOL_ERRORの接続エラー（セクション5.4.1）としてこれを扱う必要があります。"
    },
    {
      "indent": 6,
      "text": "Note: A frame can be increased in size by one octet by including a Pad Length field with a value of zero.",
      "ja": "注：フレームは、ゼロの値を有するパッドの長さフィールドを含むことによって、1つのオクテットによって大型化することができます。"
    },
    {
      "indent": 0,
      "text": "6.2. HEADERS",
      "section_title": true,
      "ja": "6.2.  HEADERS"
    },
    {
      "indent": 3,
      "text": "The HEADERS frame (type=0x1) is used to open a stream (Section 5.1), and additionally carries a header block fragment. HEADERS frames can be sent on a stream in the \"idle\", \"reserved (local)\", \"open\", or \"half-closed (remote)\" state.",
      "ja": "ヘッダフレームは、（タイプ= 0x1の）ストリーム（セクション5.1）を開くために使用され、さらにヘッダブロックの断片を担持しています。ヘッダフレームは、「アイドル」「予約（ローカル）」、「開」または「半閉（リモート）」状態のストリーム上で送信することができます。"
    },
    {
      "indent": 4,
      "text": "+---------------+\n|Pad Length? (8)|\n+-+-------------+-----------------------------------------------+\n|E|                 Stream Dependency? (31)                     |\n+-+-------------+-----------------------------------------------+\n|  Weight? (8)  |\n+-+-------------+-----------------------------------------------+\n|                   Header Block Fragment (*)                 ...\n+---------------------------------------------------------------+\n|                           Padding (*)                       ...\n+---------------------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 22,
      "text": "Figure 7: HEADERS Frame Payload",
      "ja": "図7：HEADERSフレームペイロード"
    },
    {
      "indent": 3,
      "text": "The HEADERS frame payload has the following fields:",
      "ja": "HEADERSフレームのペイロードは、次のフィールドがあります。"
    },
    {
      "indent": 3,
      "text": "Pad Length: An 8-bit field containing the length of the frame padding in units of octets. This field is only present if the PADDED flag is set.",
      "ja": "パッド長さ：オクテットの単位でフレームパディングの長さを含む8ビットのフィールド。 PADDEDフラグが設定されている場合のみ、このフィールドが存在しています。"
    },
    {
      "indent": 3,
      "text": "E: A single-bit flag indicating that the stream dependency is exclusive (see Section 5.3). This field is only present if the PRIORITY flag is set.",
      "ja": "E：ストリーム依存性は排他的であることを示す単一ビットのフラグ（セクション5.3を参照）。優先フラグが設定されている場合のみ、このフィールドが存在しています。"
    },
    {
      "indent": 3,
      "text": "Stream Dependency: A 31-bit stream identifier for the stream that this stream depends on (see Section 5.3). This field is only present if the PRIORITY flag is set.",
      "ja": "ストリーム依存性：このストリームが依存するストリームのための31ビットのストリーム識別子（セクション5.3を参照）。優先フラグが設定されている場合のみ、このフィールドが存在しています。"
    },
    {
      "indent": 3,
      "text": "Weight: An unsigned 8-bit integer representing a priority weight for the stream (see Section 5.3). Add one to the value to obtain a weight between 1 and 256. This field is only present if the PRIORITY flag is set.",
      "ja": "重量：ストリームの優先重みを表す符号なし8ビット整数（セクション5.3を参照）。優先フラグが設定されている場合、このフィールドにのみ存在し、1と256との間の重量を得るための値に1を加えます。"
    },
    {
      "indent": 3,
      "text": "Header Block Fragment: A header block fragment (Section 4.3).",
      "ja": "ヘッダブロックフラグメント：ヘッダーブロック断片（セクション4.3）。"
    },
    {
      "indent": 3,
      "text": "Padding: Padding octets.",
      "ja": "パディング：パディングオクテット。"
    },
    {
      "indent": 3,
      "text": "The HEADERS frame defines the following flags:",
      "ja": "HEADERSフレームは、以下のフラグが定義されています。"
    },
    {
      "indent": 3,
      "text": "END_STREAM (0x1): When set, bit 0 indicates that the header block (Section 4.3) is the last that the endpoint will send for the identified stream.",
      "ja": "END_STREAM（0x1の）セット、0ビットは、ヘッダブロック（セクション4.3）エンドポイントが識別されたストリームのために送信すること最後であることを示しています。"
    },
    {
      "indent": 6,
      "text": "A HEADERS frame carries the END_STREAM flag that signals the end of a stream. However, a HEADERS frame with the END_STREAM flag set can be followed by CONTINUATION frames on the same stream. Logically, the CONTINUATION frames are part of the HEADERS frame.",
      "ja": "ヘッダフレームは、ストリームの終わりをEND_STREAMフラグを運びます。しかし、END_STREAMフラグが設定されたヘッダフレームは、同じストリーム上で連続フレームが続くことができます。論理的に、継続フレームヘッダーフレームの一部です。"
    },
    {
      "indent": 3,
      "text": "END_HEADERS (0x4): When set, bit 2 indicates that this frame contains an entire header block (Section 4.3) and is not followed by any CONTINUATION frames.",
      "ja": "END_HEADERS（0x4の）セット、ビット2は、このフレーム全体ヘッダブロック（セクション4.3）を含有し、任意の連続フレームが続いていないことを示します。"
    },
    {
      "indent": 6,
      "text": "A HEADERS frame without the END_HEADERS flag set MUST be followed by a CONTINUATION frame for the same stream. A receiver MUST treat the receipt of any other type of frame or a frame on a different stream as a connection error (Section 5.4.1) of type PROTOCOL_ERROR.",
      "ja": "END_HEADERSフラグが設定されていないヘッダフレームは、同じストリームに対する継続フレームが続かなければなりません。受信機は、フレームの任意の他のタイプまたはタイプPROTOCOL_ERRORの接続エラー（5.4.1）などの異なるストリーム上のフレームの受信を処理しなければなりません。"
    },
    {
      "indent": 3,
      "text": "PADDED (0x8): When set, bit 3 indicates that the Pad Length field and any padding that it describes are present.",
      "ja": "PADDED（0x8という）：セットは、ビット3は、パッドの長さフィールドと、それが記述する任意のパディングが存在することを示しています。"
    },
    {
      "indent": 3,
      "text": "PRIORITY (0x20): When set, bit 5 indicates that the Exclusive Flag (E), Stream Dependency, and Weight fields are present; see Section 5.3.",
      "ja": "PRIORITY（0x20の）セット、5ビットは、排他フラグ（E）、ストリーム依存性、および体重フィールドが存在することを示しています。 5.3節を参照してください。"
    },
    {
      "indent": 3,
      "text": "The payload of a HEADERS frame contains a header block fragment (Section 4.3). A header block that does not fit within a HEADERS frame is continued in a CONTINUATION frame (Section 6.10).",
      "ja": "ヘッダフレームのペイロードは、ヘッダブロック断片（セクション4.3）を含有します。ヘッダーフレームに収まらないヘッダブロックは、継続フレーム（セクション6.10）に継続されます。"
    },
    {
      "indent": 3,
      "text": "HEADERS frames MUST be associated with a stream. If a HEADERS frame is received whose stream identifier field is 0x0, the recipient MUST respond with a connection error (Section 5.4.1) of type PROTOCOL_ERROR.",
      "ja": "ヘッダフレームは、ストリームに関連付けられなければなりません。ヘッダフレームを受信した場合、そのストリーム識別子フィールドが0x0であり、受信者は、タイプPROTOCOL_ERRORの接続エラー（5.4.1）で応答しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The HEADERS frame changes the connection state as described in Section 4.3.",
      "ja": "セクション4.3で説明したようにヘッダフレームは、接続状態を変更します。"
    },
    {
      "indent": 3,
      "text": "The HEADERS frame can include padding. Padding fields and flags are identical to those defined for DATA frames (Section 6.1). Padding that exceeds the size remaining for the header block fragment MUST be treated as a PROTOCOL_ERROR.",
      "ja": "HEADERSフレームはパディングを含めることができます。パディングフィールド及びフラグはデータフレーム（セクション6.1）のために定義されたものと同一です。ヘッダブロックの断片の残りサイズを超えるパディングはPROTOCOL_ERRORとして扱わなければなりません。"
    },
    {
      "indent": 3,
      "text": "Prioritization information in a HEADERS frame is logically equivalent to a separate PRIORITY frame, but inclusion in HEADERS avoids the potential for churn in stream prioritization when new streams are created. Prioritization fields in HEADERS frames subsequent to the first on a stream reprioritize the stream (Section 5.3.3).",
      "ja": "ヘッダフレームにおける優先順位情報は、別個のPRIORITYフレームと論理的に等価であるが、新しいストリームが作成されるときにヘッダに含めることは、ストリームの優先順位付けに解約の可能性を回避します。ヘッダに優先順位フィールドは、ストリーム（セクション5.3.3）の優先順位を変更ストリームに最初に後続フレーム。"
    },
    {
      "indent": 0,
      "text": "6.3. PRIORITY",
      "section_title": true,
      "ja": "6.3. 優先"
    },
    {
      "indent": 3,
      "text": "The PRIORITY frame (type=0x2) specifies the sender-advised priority of a stream (Section 5.3). It can be sent in any stream state, including idle or closed streams.",
      "ja": "PRIORITYフレーム（種別= 0x2の）は、ストリーム（セクション5.3）の送信者助言の優先度を指定します。これは、アイドル状態または閉じストリームを含む、任意のストリーム状態で送信することができます。"
    },
    {
      "indent": 4,
      "text": "+-+-------------------------------------------------------------+\n|E|                  Stream Dependency (31)                     |\n+-+-------------+-----------------------------------------------+\n|   Weight (8)  |\n+-+-------------+",
      "raw": true
    },
    {
      "indent": 21,
      "text": "Figure 8: PRIORITY Frame Payload",
      "ja": "図8：PRIORITYフレームペイロード"
    },
    {
      "indent": 3,
      "text": "The payload of a PRIORITY frame contains the following fields:",
      "ja": "PRIORITYフレームのペイロードには、以下のフィールドが含まれています。"
    },
    {
      "indent": 3,
      "text": "E: A single-bit flag indicating that the stream dependency is exclusive (see Section 5.3).",
      "ja": "E：ストリーム依存性は排他的であることを示す単一ビットのフラグ（セクション5.3を参照）。"
    },
    {
      "indent": 3,
      "text": "Stream Dependency: A 31-bit stream identifier for the stream that this stream depends on (see Section 5.3).",
      "ja": "ストリーム依存性：このストリームが依存するストリームのための31ビットのストリーム識別子（セクション5.3を参照）。"
    },
    {
      "indent": 3,
      "text": "Weight: An unsigned 8-bit integer representing a priority weight for the stream (see Section 5.3). Add one to the value to obtain a weight between 1 and 256.",
      "ja": "重量：ストリームの優先重みを表す符号なし8ビット整数（セクション5.3を参照）。 1と256の間の重量を得るために、値に1を追加します。"
    },
    {
      "indent": 3,
      "text": "The PRIORITY frame does not define any flags.",
      "ja": "PRIORITYフレームは、任意のフラグを定義していません。"
    },
    {
      "indent": 3,
      "text": "The PRIORITY frame always identifies a stream. If a PRIORITY frame is received with a stream identifier of 0x0, the recipient MUST respond with a connection error (Section 5.4.1) of type PROTOCOL_ERROR.",
      "ja": "PRIORITYフレームは常にストリームを識別する。 PRIORITYフレームは、0x0ののストリーム識別子を用いて受信された場合、受信者は、タイプPROTOCOL_ERRORの接続エラー（5.4.1）で応答しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The PRIORITY frame can be sent on a stream in any state, though it cannot be sent between consecutive frames that comprise a single header block (Section 4.3). Note that this frame could arrive after processing or frame sending has completed, which would cause it to have no effect on the identified stream. For a stream that is in the \"half-closed (remote)\" or \"closed\" state, this frame can only affect processing of the identified stream and its dependent streams; it does not affect frame transmission on that stream.",
      "ja": "それは、単一のヘッダブロック（セクション4.3）を含む連続するフレームの間で送信することができないもののPRIORITYフレームは、任意の状態のストリーム上で送信することができます。それが識別されたストリームに影響を及ぼさないことが原因と思われる、処理またはフレームの送信が完了した後に、このフレームが到着する可能性があります。 「半閉（リモート）」または「閉」状態にあるストリームのために、このフレームは、識別されたストリームとその依存ストリームの処理に影響を与えることができます。それは、そのストリーム上のフレームの送信には影響を与えません。"
    },
    {
      "indent": 3,
      "text": "The PRIORITY frame can be sent for a stream in the \"idle\" or \"closed\" state. This allows for the reprioritization of a group of dependent streams by altering the priority of an unused or closed parent stream.",
      "ja": "PRIORITYフレームは、「アイドル」または「閉」状態のストリームのために送信することができます。これは、未使用または閉じ親ストリームの優先順位を変更することによって依存ストリームのグループのreprioritizationを可能にします。"
    },
    {
      "indent": 3,
      "text": "A PRIORITY frame with a length other than 5 octets MUST be treated as a stream error (Section 5.4.2) of type FRAME_SIZE_ERROR.",
      "ja": "5つのオクテット以外の長さのPRIORITYフレームは、タイプFRAME_SIZE_ERRORのストリームエラー（5.4.2項）として扱われなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.4. RST_STREAM",
      "section_title": true,
      "ja": "6.4.  RST_STREAM"
    },
    {
      "indent": 3,
      "text": "The RST_STREAM frame (type=0x3) allows for immediate termination of a stream. RST_STREAM is sent to request cancellation of a stream or to indicate that an error condition has occurred.",
      "ja": "RST_STREAMフレーム（種別= 0x3の）は、ストリームの即時終了を可能にします。 RST_STREAMは、ストリームの取り消しを要求するか、エラー状態が発生したことを示すために送信されます。"
    },
    {
      "indent": 4,
      "text": "+---------------------------------------------------------------+\n|                        Error Code (32)                        |\n+---------------------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 20,
      "text": "Figure 9: RST_STREAM Frame Payload",
      "ja": "図9：RST_STREAMフレームペイロード"
    },
    {
      "indent": 3,
      "text": "The RST_STREAM frame contains a single unsigned, 32-bit integer identifying the error code (Section 7). The error code indicates why the stream is being terminated.",
      "ja": "RST_STREAMフレームは、エラーコード（セクション7）を識別する単一の符号なし32ビット整数を含んでいます。ストリームが終了されている理由のエラーコードを示します。"
    },
    {
      "indent": 3,
      "text": "The RST_STREAM frame does not define any flags.",
      "ja": "RST_STREAMフレームは、任意のフラグを定義していません。"
    },
    {
      "indent": 3,
      "text": "The RST_STREAM frame fully terminates the referenced stream and causes it to enter the \"closed\" state. After receiving a RST_STREAM on a stream, the receiver MUST NOT send additional frames for that stream, with the exception of PRIORITY. However, after sending the RST_STREAM, the sending endpoint MUST be prepared to receive and process additional frames sent on the stream that might have been sent by the peer prior to the arrival of the RST_STREAM.",
      "ja": "RST_STREAMフレームは完全に参照されたストリームを終了し、それが「閉」状態に入るようになります。ストリーム上RST_STREAMを受けた後、受信機は、PRIORITYを除いて、そのストリーム用の追加フレームを送ってはいけません。しかし、RST_STREAMを送信した後、送信エンドポイントは、前RST_STREAMの到着にピアによって送信された可能性がありますストリームで送信された追加のフレームを受信して​​処理するために準備しなければなりません。"
    },
    {
      "indent": 3,
      "text": "RST_STREAM frames MUST be associated with a stream. If a RST_STREAM frame is received with a stream identifier of 0x0, the recipient MUST treat this as a connection error (Section 5.4.1) of type PROTOCOL_ERROR.",
      "ja": "RST_STREAMフレームは、ストリームに関連付けられなければなりません。 RST_STREAMフレームは、0x0ののストリーム識別子を用いて受信された場合、受信者は、タイプPROTOCOL_ERRORの接続エラー（セクション5.4.1）としてこれを扱う必要があります。"
    },
    {
      "indent": 3,
      "text": "RST_STREAM frames MUST NOT be sent for a stream in the \"idle\" state. If a RST_STREAM frame identifying an idle stream is received, the recipient MUST treat this as a connection error (Section 5.4.1) of type PROTOCOL_ERROR.",
      "ja": "RST_STREAMフレームは「アイドル」状態にストリームのために送ってはいけません。アイドルストリームを識別RST_STREAMフレームを受信した場合、受信者は、タイプPROTOCOL_ERRORの接続エラー（セクション5.4.1）としてこれを扱う必要があります。"
    },
    {
      "indent": 3,
      "text": "A RST_STREAM frame with a length other than 4 octets MUST be treated as a connection error (Section 5.4.1) of type FRAME_SIZE_ERROR.",
      "ja": "4つのオクテット以外の長さRST_STREAMフレームは、タイプFRAME_SIZE_ERRORの接続エラー（セクション5.4.1）として扱われなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.5. SETTINGS",
      "section_title": true,
      "ja": "6.5. 設定"
    },
    {
      "indent": 3,
      "text": "The SETTINGS frame (type=0x4) conveys configuration parameters that affect how endpoints communicate, such as preferences and constraints on peer behavior. The SETTINGS frame is also used to acknowledge the receipt of those parameters. Individually, a SETTINGS parameter can also be referred to as a \"setting\".",
      "ja": "SETTINGSフレーム（種別= 0x4に）は、ピア・行動上の好みや制約などのエンドポイントが通信する方法に影響を与える設定パラメータを伝えます。 SETTINGSフレームは、また、これらのパラメータの受信を確認するために使用されます。個別には、設定パラメータは、「設定」と呼ぶことができます。"
    },
    {
      "indent": 3,
      "text": "SETTINGS parameters are not negotiated; they describe characteristics of the sending peer, which are used by the receiving peer. Different values for the same parameter can be advertised by each peer. For example, a client might set a high initial flow-control window, whereas a server might set a lower value to conserve resources.",
      "ja": "SETTINGSパラメータがネゴシエートされていません。彼らは、受信ピアによって使用される送信ピアの特性を記述する。同じパラメータの異なる値は、各ピアによってアドバタイズすることができます。サーバがリソースを節約するために低い値を設定する可能性があるのに対し、例えば、クライアントは、高い初期フロー制御ウィンドウを設定できます。"
    },
    {
      "indent": 3,
      "text": "A SETTINGS frame MUST be sent by both endpoints at the start of a connection and MAY be sent at any other time by either endpoint over the lifetime of the connection. Implementations MUST support all of the parameters defined by this specification.",
      "ja": "SETTINGSフレームは、接続の開始時に両方のエンドポイントによって送信されなければならなくて、接続の寿命にわたっていずれかのエンドポイントによって他の時間で送信されるかもしれません。実装は、この仕様で定義されたパラメータのすべてをサポートしなければなりません。"
    },
    {
      "indent": 3,
      "text": "Each parameter in a SETTINGS frame replaces any existing value for that parameter. Parameters are processed in the order in which they appear, and a receiver of a SETTINGS frame does not need to maintain any state other than the current value of its parameters. Therefore, the value of a SETTINGS parameter is the last value that is seen by a receiver.",
      "ja": "SETTINGSフレーム内の各パラメータは、そのパラメータの既存の値を置き換えます。パラメータは、それらが現れる順序で処理され、設定フレームの受信機は、そのパラメータの現在の値以外の任意の状態を維持する必要はありません。したがって、設定パラメータの値は、受信機によって見られる最後の値です。"
    },
    {
      "indent": 3,
      "text": "SETTINGS parameters are acknowledged by the receiving peer. To enable this, the SETTINGS frame defines the following flag:",
      "ja": "SETTINGSパラメータは、受信側ピアによって確認されています。これを可能にするために、SETTINGSフレームは、次のフラグを定義しています。"
    },
    {
      "indent": 3,
      "text": "ACK (0x1): When set, bit 0 indicates that this frame acknowledges receipt and application of the peer's SETTINGS frame. When this bit is set, the payload of the SETTINGS frame MUST be empty. Receipt of a SETTINGS frame with the ACK flag set and a length field value other than 0 MUST be treated as a connection error (Section 5.4.1) of type FRAME_SIZE_ERROR. For more information, see Section 6.5.3 (\"Settings Synchronization\").",
      "ja": "ACK（0x1の）セットは、ビット0このフレームは、ピアの設定フレームの受信および適用を認めることを示しています。このビットが設定されている場合、SETTINGSフレームのペイロードは空でなければなりません。 ACKフラグを設定し、0以外の長さフィールド値とSETTINGSフレームの受信は、型FRAME_SIZE_ERRORの接続エラー（セクション5.4.1）として扱われなければなりません。詳細については、6.5.3項（「設定の同期」を参照してください）。"
    },
    {
      "indent": 3,
      "text": "SETTINGS frames always apply to a connection, never a single stream. The stream identifier for a SETTINGS frame MUST be zero (0x0). If an endpoint receives a SETTINGS frame whose stream identifier field is anything other than 0x0, the endpoint MUST respond with a connection error (Section 5.4.1) of type PROTOCOL_ERROR.",
      "ja": "SETTINGSフレームは常に接続、決して単一のストリームに適用されます。 SETTINGSフレームのストリーム識別子は、ゼロ（0x0の）でなければなりません。エンドポイントは、そのストリーム識別子フィールドでは0x0以外SETTINGSフレームを受信した場合、エンドポイントは型PROTOCOL_ERRORの接続エラー（5.4.1）で応答しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The SETTINGS frame affects connection state. A badly formed or incomplete SETTINGS frame MUST be treated as a connection error (Section 5.4.1) of type PROTOCOL_ERROR.",
      "ja": "SETTINGSフレームは、接続状態に影響を与えます。ひどく形成されたまたは不完全SETTINGSフレームは、タイプPROTOCOL_ERRORの接続エラー（セクション5.4.1）として扱われなければなりません。"
    },
    {
      "indent": 3,
      "text": "A SETTINGS frame with a length other than a multiple of 6 octets MUST be treated as a connection error (Section 5.4.1) of type FRAME_SIZE_ERROR.",
      "ja": "6つのオクテットの倍数以外の長さのSETTINGSフレームは、タイプFRAME_SIZE_ERRORの接続エラー（セクション5.4.1）として扱われなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.5.1. SETTINGS Format",
      "section_title": true,
      "ja": "6.5.1.  SETTINGSフォーマット"
    },
    {
      "indent": 3,
      "text": "The payload of a SETTINGS frame consists of zero or more parameters, each consisting of an unsigned 16-bit setting identifier and an unsigned 32-bit value.",
      "ja": "SETTINGSフレームのペイロードは、それぞれが符号なし16ビット設定識別子と符号なしの32ビット値から成る、ゼロ以上のパラメータから成ります。"
    },
    {
      "indent": 4,
      "text": "+-------------------------------+\n|       Identifier (16)         |\n+-------------------------------+-------------------------------+\n|                        Value (32)                             |\n+---------------------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 25,
      "text": "Figure 10: Setting Format",
      "ja": "図10：設定フォーマット"
    },
    {
      "indent": 0,
      "text": "6.5.2. Defined SETTINGS Parameters",
      "section_title": true,
      "ja": "6.5.2. 定義された設定パラメータ"
    },
    {
      "indent": 3,
      "text": "The following parameters are defined:",
      "ja": "以下のパラメータが定義されています。"
    },
    {
      "indent": 3,
      "text": "SETTINGS_HEADER_TABLE_SIZE (0x1): Allows the sender to inform the remote endpoint of the maximum size of the header compression table used to decode header blocks, in octets. The encoder can select any size equal to or less than this value by using signaling specific to the header compression format inside a header block (see [COMPRESSION]). The initial value is 4,096 octets.",
      "ja": "SETTINGS_HEADER_TABLE_SIZE（0x1の）は：送信者がオクテットに、ヘッダーブロックを復号するために使用されるヘッダ圧縮テーブルの最大サイズのリモートエンドポイントを通知することができます。エンコーダは、（[圧縮]参照）に等しいか、またはヘッダブロック内のヘッダ圧縮フォーマットに固有のシグナリング使用して、この値よりも小さい任意のサイズを選択することができます。初期値は4096オクテットです。"
    },
    {
      "indent": 3,
      "text": "SETTINGS_ENABLE_PUSH (0x2): This setting can be used to disable server push (Section 8.2). An endpoint MUST NOT send a PUSH_PROMISE frame if it receives this parameter set to a value of 0. An endpoint that has both set this parameter to 0 and had it acknowledged MUST treat the receipt of a PUSH_PROMISE frame as a connection error (Section 5.4.1) of type PROTOCOL_ERROR.",
      "ja": "SETTINGS_ENABLE_PUSH（0x2の）：この設定は、サーバープッシュ（8.2節）を無効にするために使用することができます。それは、0の値は、このパラメータを0に設定し、それが接続エラー（5.4節としてPUSH_PROMISEフレームの受信を扱わなければなりません認めてきた両方のエンドポイントに設定し、このパラメータを受信した場合、エンドポイントはPUSH_PROMISEフレームを送ってはいけません。 1）型のPROTOCOL_ERROR。"
    },
    {
      "indent": 6,
      "text": "The initial value is 1, which indicates that server push is permitted. Any value other than 0 or 1 MUST be treated as a connection error (Section 5.4.1) of type PROTOCOL_ERROR.",
      "ja": "初期値は、サーバプッシュを許可することを示し、1です。 0または1以外の値は、タイプPROTOCOL_ERRORの接続エラー（セクション5.4.1）として扱われなければなりません。"
    },
    {
      "indent": 3,
      "text": "SETTINGS_MAX_CONCURRENT_STREAMS (0x3): Indicates the maximum number of concurrent streams that the sender will allow. This limit is directional: it applies to the number of streams that the sender permits the receiver to create. Initially, there is no limit to this value. It is recommended that this value be no smaller than 100, so as to not unnecessarily limit parallelism.",
      "ja": "SETTINGS_MAX_CONCURRENT_STREAMS（0x3の）：送信者ができるようになると同時ストリームの最大数を示します。この制限は、指向である：それは、送信者が作成するための受信機を許可するストリームの数に適用されます。最初は、この値に制限はありません。不必要に並列性を制限しないように、この値は、100よりも小さくならないことが推奨されます。"
    },
    {
      "indent": 6,
      "text": "A value of 0 for SETTINGS_MAX_CONCURRENT_STREAMS SHOULD NOT be treated as special by endpoints. A zero value does prevent the creation of new streams; however, this can also happen for any limit that is exhausted with active streams. Servers SHOULD only set a zero value for short durations; if a server does not wish to accept requests, closing the connection is more appropriate.",
      "ja": "SETTINGS_MAX_CONCURRENT_STREAMSのための0の値は、エンドポイントによって、特別なものとして扱われるべきではありません。ゼロの値は、新しいストリームの作成を防ぐん。しかし、これはまた、アクティブなストリームで排出されるすべての制限のために発生する可能性があります。サーバーはほんの短い期間のためにゼロ値を設定する必要があります。サーバーが要求を受け入れることを希望しない場合は、接続を閉じることがより適切です。"
    },
    {
      "indent": 3,
      "text": "SETTINGS_INITIAL_WINDOW_SIZE (0x4): Indicates the sender's initial window size (in octets) for stream-level flow control. The initial value is 2^16-1 (65,535) octets.",
      "ja": "SETTINGS_INITIAL_WINDOW_SIZE（0x4には）：ストリームレベルのフロー制御のための（オクテットで）送信者の初期ウィンドウサイズを示します。初期値は2 ^ 16-1（65535）オクテットです。"
    },
    {
      "indent": 6,
      "text": "This setting affects the window size of all streams (see Section 6.9.2).",
      "ja": "この設定は、すべてのストリーム（6.9.2項を参照）のウィンドウサイズに影響します。"
    },
    {
      "indent": 6,
      "text": "Values above the maximum flow-control window size of 2^31-1 MUST be treated as a connection error (Section 5.4.1) of type FLOW_CONTROL_ERROR.",
      "ja": "2 ^ 31-1の最大フロー制御ウィンドウサイズ上記の値は、タイプFLOW_CONTROL_ERRORの接続エラー（セクション5.4.1）として扱われなければなりません。"
    },
    {
      "indent": 3,
      "text": "SETTINGS_MAX_FRAME_SIZE (0x5): Indicates the size of the largest frame payload that the sender is willing to receive, in octets.",
      "ja": "SETTINGS_MAX_FRAME_SIZE（0x5）は：オクテットで、送信者が受信する意思がある最大フレームペイロードのサイズを示します。"
    },
    {
      "indent": 6,
      "text": "The initial value is 2^14 (16,384) octets. The value advertised by an endpoint MUST be between this initial value and the maximum allowed frame size (2^24-1 or 16,777,215 octets), inclusive. Values outside this range MUST be treated as a connection error (Section 5.4.1) of type PROTOCOL_ERROR.",
      "ja": "初期値は2 ^ 14（16,384）オクテットです。エンドポイントによってアドバタイズされた値は、この初期値と最大許容フレームサイズ（2 ^ 24-1または16,777,215オクテット）、包括的でなければなりません。この範囲外の値はタイプPROTOCOL_ERRORの接続エラー（セクション5.4.1）として扱われなければなりません。"
    },
    {
      "indent": 3,
      "text": "SETTINGS_MAX_HEADER_LIST_SIZE (0x6): This advisory setting informs a peer of the maximum size of header list that the sender is prepared to accept, in octets. The value is based on the uncompressed size of header fields, including the length of the name and value in octets plus an overhead of 32 octets for each header field.",
      "ja": "SETTINGS_MAX_HEADER_LIST_SIZE（0x6に）：このアドバイザリ設定はオクテットで、送信者が受け入れる用意があることを見出しリストの最大サイズのピアに通知します。値は、オクテット内の名前と値の長さを加えた各ヘッダフィールドの32オクテットのオーバーヘッドを含むヘッダフィールドの圧縮されていない大きさに基づいています。"
    },
    {
      "indent": 6,
      "text": "For any given request, a lower limit than what is advertised MAY be enforced. The initial value of this setting is unlimited.",
      "ja": "任意の特定の要求のために、宣伝されているものよりも下限が実施される場合があります。この設定の初期値は無制限です。"
    },
    {
      "indent": 3,
      "text": "An endpoint that receives a SETTINGS frame with any unknown or unsupported identifier MUST ignore that setting.",
      "ja": "不明またはサポートされていない識別子とSETTINGSフレームを受信したエンドポイントはその設定を無視しなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.5.3. Settings Synchronization",
      "section_title": true,
      "ja": "6.5.3. 設定の同期"
    },
    {
      "indent": 3,
      "text": "Most values in SETTINGS benefit from or require an understanding of when the peer has received and applied the changed parameter values. In order to provide such synchronization timepoints, the recipient of a SETTINGS frame in which the ACK flag is not set MUST apply the updated parameters as soon as possible upon receipt.",
      "ja": "設定でほとんどの値が恩恵を受けるか、ピアが受信され、変更されたパラメータ値を適用したときの理解を必要としています。このような同期時点を提供するために、ACKフラグがセットされていないSETTINGSフレームの受信者は、受信時にできるだけ早く更新されたパラメータを適用する必要があります。"
    },
    {
      "indent": 3,
      "text": "The values in the SETTINGS frame MUST be processed in the order they appear, with no other frame processing between values. Unsupported parameters MUST be ignored. Once all values have been processed, the recipient MUST immediately emit a SETTINGS frame with the ACK flag set. Upon receiving a SETTINGS frame with the ACK flag set, the sender of the altered parameters can rely on the setting having been applied.",
      "ja": "SETTINGSフレームの値は、値の間に他のフレーム処理と、それらが現れる順序で処理されなければなりません。サポートされていないパラメータは無視しなければなりません。一度すべての値が処理された、受信者は直ちにACKフラグが設定されたSETTINGSフレームを放出しなければなりません。 ACKフラグが設定されたSETTINGSフレームを受信すると、変更されたパラメータの送信者は、適用された設定に依存することができます。"
    },
    {
      "indent": 3,
      "text": "If the sender of a SETTINGS frame does not receive an acknowledgement within a reasonable amount of time, it MAY issue a connection error (Section 5.4.1) of type SETTINGS_TIMEOUT.",
      "ja": "SETTINGSフレームの送信者が合理的な時間内の確認応答を受信しない場合、それはタイプSETTINGS_TIMEOUTの接続エラー（5.4.1）を発行することができます。"
    },
    {
      "indent": 0,
      "text": "6.6. PUSH_PROMISE",
      "section_title": true,
      "ja": "6.6.  PUSH_PROMISE"
    },
    {
      "indent": 3,
      "text": "The PUSH_PROMISE frame (type=0x5) is used to notify the peer endpoint in advance of streams the sender intends to initiate. The PUSH_PROMISE frame includes the unsigned 31-bit identifier of the stream the endpoint plans to create along with a set of headers that provide additional context for the stream. Section 8.2 contains a thorough description of the use of PUSH_PROMISE frames.",
      "ja": "PUSH_PROMISEフレーム（種別= 0x5）は、送信者が開始しようとするストリームの予めピアエンドポイントに通知するために使用されます。 PUSH_PROMISEフレームは、エンドポイントがストリームのための追加のコンテキストを提供するヘッダのセットとともに作成する予定ストリームの符号なし31ビット識別子を含みます。 8.2節ではPUSH_PROMISEフレームの使用の完全な説明が含まれています。"
    },
    {
      "indent": 4,
      "text": "+---------------+\n|Pad Length? (8)|\n+-+-------------+-----------------------------------------------+\n|R|                  Promised Stream ID (31)                    |\n+-+-----------------------------+-------------------------------+\n|                   Header Block Fragment (*)                 ...\n+---------------------------------------------------------------+\n|                           Padding (*)                       ...\n+---------------------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 18,
      "text": "Figure 11: PUSH_PROMISE Payload Format",
      "ja": "図11：PUSH_PROMISEペイロードフォーマット"
    },
    {
      "indent": 3,
      "text": "The PUSH_PROMISE frame payload has the following fields:",
      "ja": "PUSH_PROMISEフレームのペイロードは、次のフィールドがあります。"
    },
    {
      "indent": 3,
      "text": "Pad Length: An 8-bit field containing the length of the frame padding in units of octets. This field is only present if the PADDED flag is set.",
      "ja": "パッド長さ：オクテットの単位でフレームパディングの長さを含む8ビットのフィールド。 PADDEDフラグが設定されている場合のみ、このフィールドが存在しています。"
    },
    {
      "indent": 3,
      "text": "R: A single reserved bit.",
      "ja": "R：単一の予約ビット。"
    },
    {
      "indent": 3,
      "text": "Promised Stream ID: An unsigned 31-bit integer that identifies the stream that is reserved by the PUSH_PROMISE. The promised stream identifier MUST be a valid choice for the next stream sent by the sender (see \"new stream identifier\" in Section 5.1.1).",
      "ja": "PUSH_PROMISEによって予約されたストリームを識別する符号なし31ビット整数：ストリームIDを約束。約束したストリーム識別子は、送信者によって送信された次のストリームのための有効な選択肢（5.1.1項で「新しいストリーム識別子」を参照）でなければなりません。"
    },
    {
      "indent": 3,
      "text": "Header Block Fragment: A header block fragment (Section 4.3) containing request header fields.",
      "ja": "ヘッダブロックフラグメント：要求ヘッダフィールドを含むヘッダブロック断片（セクション4.3）。"
    },
    {
      "indent": 3,
      "text": "Padding: Padding octets.",
      "ja": "パディング：パディングオクテット。"
    },
    {
      "indent": 3,
      "text": "The PUSH_PROMISE frame defines the following flags:",
      "ja": "PUSH_PROMISEフレームは、以下のフラグが定義されています。"
    },
    {
      "indent": 3,
      "text": "END_HEADERS (0x4): When set, bit 2 indicates that this frame contains an entire header block (Section 4.3) and is not followed by any CONTINUATION frames.",
      "ja": "END_HEADERS（0x4の）セット、ビット2は、このフレーム全体ヘッダブロック（セクション4.3）を含有し、任意の連続フレームが続いていないことを示します。"
    },
    {
      "indent": 6,
      "text": "A PUSH_PROMISE frame without the END_HEADERS flag set MUST be followed by a CONTINUATION frame for the same stream. A receiver MUST treat the receipt of any other type of frame or a frame on a different stream as a connection error (Section 5.4.1) of type PROTOCOL_ERROR.",
      "ja": "END_HEADERSフラグが設定されていないPUSH_PROMISEフレームは、同じストリームに対する継続フレームが続かなければなりません。受信機は、フレームの任意の他のタイプまたはタイプPROTOCOL_ERRORの接続エラー（5.4.1）などの異なるストリーム上のフレームの受信を処理しなければなりません。"
    },
    {
      "indent": 3,
      "text": "PADDED (0x8): When set, bit 3 indicates that the Pad Length field and any padding that it describes are present.",
      "ja": "PADDED（0x8という）：セットは、ビット3は、パッドの長さフィールドと、それが記述する任意のパディングが存在することを示しています。"
    },
    {
      "indent": 3,
      "text": "PUSH_PROMISE frames MUST only be sent on a peer-initiated stream that is in either the \"open\" or \"half-closed (remote)\" state. The stream identifier of a PUSH_PROMISE frame indicates the stream it is associated with. If the stream identifier field specifies the value 0x0, a recipient MUST respond with a connection error (Section 5.4.1) of type PROTOCOL_ERROR.",
      "ja": "PUSH_PROMISEフレームは、「開」または「半閉（リモート）」状態のいずれかであるピア開始ストリーム上で送信されなければなりません。 PUSH_PROMISEフレームのストリーム識別子は、それが関連付けられているストリームを示します。ストリーム識別子フィールドの値が0x0のを指定した場合、受信者は、型PROTOCOL_ERRORの接続エラー（5.4.1）で応じなければなりません。"
    },
    {
      "indent": 3,
      "text": "Promised streams are not required to be used in the order they are promised. The PUSH_PROMISE only reserves stream identifiers for later use.",
      "ja": "約束のストリームは、彼らが約束されている順序で使用する必要はありません。 PUSH_PROMISEは後で使用するためのストリーム識別子を留保します。"
    },
    {
      "indent": 3,
      "text": "PUSH_PROMISE MUST NOT be sent if the SETTINGS_ENABLE_PUSH setting of the peer endpoint is set to 0. An endpoint that has set this setting and has received acknowledgement MUST treat the receipt of a PUSH_PROMISE frame as a connection error (Section 5.4.1) of type PROTOCOL_ERROR.",
      "ja": "PUSH_PROMISEピアエンドポイントのSETTINGS_ENABLE_PUSH設定が0に設定されている場合は、この設定を設定していると確認応答を受信したエンドポイントが型PROTOCOL_ERRORの接続エラー（セクション5.4.1）としてPUSH_PROMISEフレームの受信を処理しなければならない送ってはいけません。"
    },
    {
      "indent": 3,
      "text": "Recipients of PUSH_PROMISE frames can choose to reject promised streams by returning a RST_STREAM referencing the promised stream identifier back to the sender of the PUSH_PROMISE.",
      "ja": "PUSH_PROMISEフレームの受信者は、バックPUSH_PROMISEの送信者に約束したストリーム識別子を参照するRST_STREAMを返すことで約束したストリームを拒否することを選択することができます。"
    },
    {
      "indent": 3,
      "text": "A PUSH_PROMISE frame modifies the connection state in two ways. First, the inclusion of a header block (Section 4.3) potentially modifies the state maintained for header compression. Second, PUSH_PROMISE also reserves a stream for later use, causing the promised stream to enter the \"reserved\" state. A sender MUST NOT send a PUSH_PROMISE on a stream unless that stream is either \"open\" or \"half-closed (remote)\"; the sender MUST ensure that the promised stream is a valid choice for a new stream identifier (Section 5.1.1) (that is, the promised stream MUST be in the \"idle\" state).",
      "ja": "PUSH_PROMISEフレームは、2つの方法で接続状態を変更します。まず、ヘッダブロック（セクション4.3）の包含は、潜在的に、ヘッダ圧縮のために維持状態を変更します。第二に、PUSH_PROMISEも「予約」状態に入ることを約束した流れを引き起こして、後で使用するためのストリームを留保します。そのストリームは、いずれかの「半分閉じた（リモート）」「オープン」またはでない限り、送信者はストリーム上PUSH_PROMISEを送ってはいけません。送信者は、約束したストリームは、新たなストリーム識別子のための有効な選択肢（5.1.1項）（つまり、約束したストリームは、「アイドル」状態でなければならない）であることを保証しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Since PUSH_PROMISE reserves a stream, ignoring a PUSH_PROMISE frame causes the stream state to become indeterminate. A receiver MUST treat the receipt of a PUSH_PROMISE on a stream that is neither \"open\" nor \"half-closed (local)\" as a connection error (Section 5.4.1) of type PROTOCOL_ERROR. However, an endpoint that has sent RST_STREAM on the associated stream MUST handle PUSH_PROMISE frames that might have been created before the RST_STREAM frame is received and processed.",
      "ja": "PUSH_PROMISEストリームを留保しているので、PUSH_PROMISEフレームを無視すると、ストリームの状態が不定になることを引き起こします。受信機は、型PROTOCOL_ERRORの接続エラー（5.4.1項）として「半分閉じた（ローカル）」「オープン」でもでもない流れにPUSH_PROMISEの領収書を扱わなければなりません。ただし、関連付けられたストリームにRST_STREAMを送信したエンドポイントがRST_STREAMフレームを受信して​​処理される前に作成されている場合がありますPUSH_PROMISEフレームを処理する必要があります。"
    },
    {
      "indent": 3,
      "text": "A receiver MUST treat the receipt of a PUSH_PROMISE that promises an illegal stream identifier (Section 5.1.1) as a connection error (Section 5.4.1) of type PROTOCOL_ERROR. Note that an illegal stream identifier is an identifier for a stream that is not currently in the \"idle\" state.",
      "ja": "受信機は、タイプPROTOCOL_ERRORの接続エラー（5.4.1）などの違法ストリーム識別子（セクション5.1.1）約束PUSH_PROMISEの領収書を処理しなければなりません。違法ストリーム識別子が「アイドル」状態で、現在ではありませんストリームの識別子であることに注意してください。"
    },
    {
      "indent": 3,
      "text": "The PUSH_PROMISE frame can include padding. Padding fields and flags are identical to those defined for DATA frames (Section 6.1).",
      "ja": "PUSH_PROMISEフレームはパディングを含めることができます。パディングフィールド及びフラグはデータフレーム（セクション6.1）のために定義されたものと同一です。"
    },
    {
      "indent": 0,
      "text": "6.7. PING",
      "section_title": true,
      "ja": "6.7.  PING"
    },
    {
      "indent": 3,
      "text": "The PING frame (type=0x6) is a mechanism for measuring a minimal round-trip time from the sender, as well as determining whether an idle connection is still functional. PING frames can be sent from any endpoint.",
      "ja": "PINGフレーム（種別= 0x6に）が送信機から最小のラウンドトリップ時間を測定、ならびにアイドル状態の接続がまだ機能しているかどうかを決定するための機構です。 PINGフレームは、任意のエンドポイントから送信することができます。"
    },
    {
      "indent": 4,
      "text": "+---------------------------------------------------------------+\n|                                                               |\n|                      Opaque Data (64)                         |\n|                                                               |\n+---------------------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 22,
      "text": "Figure 12: PING Payload Format",
      "ja": "図12：PINGペイロードフォーマット"
    },
    {
      "indent": 3,
      "text": "In addition to the frame header, PING frames MUST contain 8 octets of opaque data in the payload. A sender can include any value it chooses and use those octets in any fashion.",
      "ja": "フレームヘッダに加えて、PINGフレームは、ペイロード内の不透明なデータの8つのオクテットを含まなければなりません。送信者は、それが選択した任意の値が含まれており、任意の方法でそれらのオクテットを使用することができます。"
    },
    {
      "indent": 3,
      "text": "Receivers of a PING frame that does not include an ACK flag MUST send a PING frame with the ACK flag set in response, with an identical payload. PING responses SHOULD be given higher priority than any other frame.",
      "ja": "ACKフラグが含まれていないPINGフレームの受信機は、同一のペイロードと、応じて設定ACKフラグでPINGフレームを送らなければなりません。 PING応答は、他のフレームよりも高い優先順位を与えられるべきです。"
    },
    {
      "indent": 3,
      "text": "The PING frame defines the following flags:",
      "ja": "PINGフレームは、以下のフラグが定義されています。"
    },
    {
      "indent": 3,
      "text": "ACK (0x1): When set, bit 0 indicates that this PING frame is a PING response. An endpoint MUST set this flag in PING responses. An endpoint MUST NOT respond to PING frames containing this flag.",
      "ja": "ACK（0x1の）セット、ビット0は、このPINGフレームがPING応答であることを示しています。エンドポイントは、PING応答では、このフラグを設定しなければなりません。エンドポイントは、このフラグを含むPINGフレームに応じてはいけません。"
    },
    {
      "indent": 3,
      "text": "PING frames are not associated with any individual stream. If a PING frame is received with a stream identifier field value other than 0x0, the recipient MUST respond with a connection error (Section 5.4.1) of type PROTOCOL_ERROR.",
      "ja": "PINGフレームは、任意の個々のストリームに関連付けられていません。 PINGフレームが0x0の以外のストリーム識別子フィールド値と受信された場合、受信者は、タイプPROTOCOL_ERRORの接続エラー（5.4.1）で応答しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Receipt of a PING frame with a length field value other than 8 MUST be treated as a connection error (Section 5.4.1) of type FRAME_SIZE_ERROR.",
      "ja": "8以外の長さフィールド値を持つPINGフレームの受信は、型FRAME_SIZE_ERRORの接続エラー（セクション5.4.1）として扱われなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.8. GOAWAY",
      "section_title": true,
      "ja": "6.8. どこかに行って"
    },
    {
      "indent": 3,
      "text": "The GOAWAY frame (type=0x7) is used to initiate shutdown of a connection or to signal serious error conditions. GOAWAY allows an endpoint to gracefully stop accepting new streams while still finishing processing of previously established streams. This enables administrative actions, like server maintenance.",
      "ja": "GOAWAYフレーム（種別= 0x7の）は、接続のシャットダウンを開始するか、または重大なエラー状態を通知するために使用されます。 GOAWAYエンドポイントが正常にまだ以前に確立されたストリームの処理を終了しつつ新ストリームの受け入れを停止することを可能にします。これは、サーバーのメンテナンスなどの管理アクションを可能にします。"
    },
    {
      "indent": 3,
      "text": "There is an inherent race condition between an endpoint starting new streams and the remote sending a GOAWAY frame. To deal with this case, the GOAWAY contains the stream identifier of the last peer-initiated stream that was or might be processed on the sending endpoint in this connection. For instance, if the server sends a GOAWAY frame, the identified stream is the highest-numbered stream initiated by the client.",
      "ja": "新しいストリームを開始するエンドポイントとGOAWAYフレームを送信するリモート間の固有の競合状態があります。このような場合に対処するために、GOAWAYがあったか、またはこれに関連して、送信エンドポイントで処理される可能性があります最後のピアが開始したストリームのストリーム識別子が含まれています。サーバはGOAWAYフレームを送信した場合例えば、識別されたストリームは、クライアントによって開始され、最も高い番号のストリームです。"
    },
    {
      "indent": 3,
      "text": "Once sent, the sender will ignore frames sent on streams initiated by the receiver if the stream has an identifier higher than the included last stream identifier. Receivers of a GOAWAY frame MUST NOT open additional streams on the connection, although a new connection can be established for new streams.",
      "ja": "送信された後、ストリームが含まれる最後のストリーム識別子よりも高い識別子を持っている場合、送信者は受信機によって開始されたストリーム上で送信されたフレームを無視します。新しい接続は、新しいストリームのために確立することができるが、GOAWAYフレームのレシーバは、接続上で追加のストリームを開いてはなりません。"
    },
    {
      "indent": 3,
      "text": "If the receiver of the GOAWAY has sent data on streams with a higher stream identifier than what is indicated in the GOAWAY frame, those streams are not or will not be processed. The receiver of the GOAWAY frame can treat the streams as though they had never been created at all, thereby allowing those streams to be retried later on a new connection.",
      "ja": "GOAWAYの受信機はGOAWAYフレームに示されているものよりも高いストリーム識別子にストリーム上でデータを送信した場合、それらのストリームはないか、または処理されません。彼らはそれによって、それらのストリームが新しい接続に後で再試行することができるように、まったく作成されていなかったかのようにGOAWAYフレームの受信機は、ストリームを扱うことができます。"
    },
    {
      "indent": 3,
      "text": "Endpoints SHOULD always send a GOAWAY frame before closing a connection so that the remote peer can know whether a stream has been partially processed or not. For example, if an HTTP client sends a POST at the same time that a server closes a connection, the client cannot know if the server started to process that POST request if the server does not send a GOAWAY frame to indicate what streams it might have acted on.",
      "ja": "リモートピアがストリームが部分的に処理されたかどうかを知ることができるように、エンドポイントは、常に接続を閉じる前GOAWAYフレームを送るべきです。 HTTPクライアントは、サーバーが接続を閉じると同時にPOSTを送信した場合、サーバーは、サーバーは、それが持っているかもしれないものストリームを示すためにGOAWAYフレームを送信しない場合にPOSTリクエストを処理するために開始した場合、クライアントは知ることができません行動しました。"
    },
    {
      "indent": 3,
      "text": "An endpoint might choose to close a connection without sending a GOAWAY for misbehaving peers.",
      "ja": "エンドポイントは、ピアの不正な動作のためのGOAWAYを送信せずに接続を閉じることを選択するかもしれません。"
    },
    {
      "indent": 3,
      "text": "A GOAWAY frame might not immediately precede closing of the connection; a receiver of a GOAWAY that has no more use for the connection SHOULD still send a GOAWAY frame before terminating the connection.",
      "ja": "GOAWAY枠はすぐに接続の閉鎖の前にいない可能性があります。これ以上はまだ接続を終了する前にGOAWAYフレームを送るべきである接続に使用しているGOAWAYの受信機。"
    },
    {
      "indent": 4,
      "text": "+-+-------------------------------------------------------------+\n|R|                  Last-Stream-ID (31)                        |\n+-+-------------------------------------------------------------+\n|                      Error Code (32)                          |\n+---------------------------------------------------------------+\n|                  Additional Debug Data (*)                    |\n+---------------------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 21,
      "text": "Figure 13: GOAWAY Payload Format",
      "ja": "図13：GOAWAYペイロードフォーマット"
    },
    {
      "indent": 3,
      "text": "The GOAWAY frame does not define any flags.",
      "ja": "GOAWAYフレームは、任意のフラグを定義していません。"
    },
    {
      "indent": 3,
      "text": "The GOAWAY frame applies to the connection, not a specific stream. An endpoint MUST treat a GOAWAY frame with a stream identifier other than 0x0 as a connection error (Section 5.4.1) of type PROTOCOL_ERROR.",
      "ja": "GOAWAYフレームは、接続ではなく、特定のストリームに適用されます。エンドポイントは、タイプPROTOCOL_ERRORの接続エラー（5.4.1）などを0x0以外のストリーム識別子とGOAWAYフレームを処理しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The last stream identifier in the GOAWAY frame contains the highest-numbered stream identifier for which the sender of the GOAWAY frame might have taken some action on or might yet take action on. All streams up to and including the identified stream might have been processed in some way. The last stream identifier can be set to 0 if no streams were processed.",
      "ja": "GOAWAYフレーム内の最後のストリーム識別子はGOAWAYフレームの送信元が上のいくつかのアクションをとっている可能性があるか、まだ上の行動をとる可能性があるため、最も高い番号のストリーム識別子が含まれています。識別されたストリームまでを含むすべてのストリームは、何らかの方法で処理されている可能性があります。何のストリームが処理されなかった場合は、最後のストリーム識別子は、0に設定することができます。"
    },
    {
      "indent": 6,
      "text": "Note: In this context, \"processed\" means that some data from the stream was passed to some higher layer of software that might have taken some action as a result.",
      "ja": "注：この文脈では、「処理」ストリームからいくつかのデータは、結果として何らかの行動をとっている可能性があるソフトウェアの一部の上位層に渡されたことを意味します。"
    },
    {
      "indent": 3,
      "text": "If a connection terminates without a GOAWAY frame, the last stream identifier is effectively the highest possible stream identifier.",
      "ja": "接続がGOAWAYフレームなしで終了した場合は、最後のストリーム識別子は、効果的に可能な限り最高のストリーム識別子です。"
    },
    {
      "indent": 3,
      "text": "On streams with lower- or equal-numbered identifiers that were not closed completely prior to the connection being closed, reattempting requests, transactions, or any protocol activity is not possible, with the exception of idempotent actions like HTTP GET, PUT, or DELETE. Any protocol activity that uses higher-numbered streams can be safely retried using a new connection.",
      "ja": "HTTP GETのような冪等のアクションを除いて、PUT、またはDELETE、リクエスト、トランザクションを再試行、または任意のプロトコル活性が不可能である、前の接続が閉じられるまで完全に閉じられなかった低級または等しい番号の識別子を持つストリームに関する。高い番号のストリームを使用するすべてのプロトコルの活動は、安全に、新しい接続を使用して再試行することができます。"
    },
    {
      "indent": 3,
      "text": "Activity on streams numbered lower or equal to the last stream identifier might still complete successfully. The sender of a GOAWAY frame might gracefully shut down a connection by sending a GOAWAY frame, maintaining the connection in an \"open\" state until all in-progress streams complete.",
      "ja": "ストリーム小さい番号または最後のストリーム識別子に等しいの活動はまだ正常に完了することがあります。 GOAWAYフレームの送信者は優雅に、進行中のすべてが完了するまで、ストリームの「開」状態で接続を維持し、GOAWAYフレームを送信することにより、接続をシャットダウンすることがあります。"
    },
    {
      "indent": 3,
      "text": "An endpoint MAY send multiple GOAWAY frames if circumstances change. For instance, an endpoint that sends GOAWAY with NO_ERROR during graceful shutdown could subsequently encounter a condition that requires immediate termination of the connection. The last stream identifier from the last GOAWAY frame received indicates which streams could have been acted upon. Endpoints MUST NOT increase the value they send in the last stream identifier, since the peers might already have retried unprocessed requests on another connection.",
      "ja": "状況が変わった場合、エンドポイントは、複数のGOAWAYフレームを送信することができます。例えば、正常なシャットダウン時にNO_ERRORでGOAWAYを送信するエンドポイントは、その後、接続の即時終了を必要とする状態に遭遇する可能性があります。フレームが受信された最後のGOAWAYから最後のストリーム識別子が作用されている可能性があるストリームを示します。ピアがすでに別の接続で未処理の要求を再試行している可能性があるので、エンドポイントは、彼らは最後のストリーム識別子に送る値を大きくしてはなりません。"
    },
    {
      "indent": 3,
      "text": "A client that is unable to retry requests loses all requests that are in flight when the server closes the connection. This is especially true for intermediaries that might not be serving clients using HTTP/2. A server that is attempting to gracefully shut down a connection SHOULD send an initial GOAWAY frame with the last stream identifier set to 2^31-1 and a NO_ERROR code. This signals to the client that a shutdown is imminent and that initiating further requests is prohibited. After allowing time for any in-flight stream creation (at least one round-trip time), the server can send another GOAWAY frame with an updated last stream identifier. This ensures that a connection can be cleanly shut down without losing requests.",
      "ja": "リクエストを再試行することができないクライアントは、サーバーが接続を閉じたときに飛行しているすべての要求を失います。これは、HTTP / 2を使用してクライアントにサービスを提供されない場合があります仲介に特に当てはまります。正常な接続をシャットダウンしようとしているサーバは、2 ^ 31-1に設定された最後のストリーム識別子とNO_ERRORコードで初期GOAWAYフレームを送るべきです。これは、シャットダウンが差し迫っているとさらに要求を開始することは禁止されていることをクライアントに通知します。どの機内ストリームの作成（少なくとも1つのラウンドトリップ時間）のための時間を与えた後、サーバが最後に更新ストリーム識別子を持つ別のGOAWAYフレームを送信することができます。これは、接続がきれいに要求を失わずにシャットダウンすることができるようになります。"
    },
    {
      "indent": 3,
      "text": "After sending a GOAWAY frame, the sender can discard frames for streams initiated by the receiver with identifiers higher than the identified last stream. However, any frames that alter connection state cannot be completely ignored. For instance, HEADERS, PUSH_PROMISE, and CONTINUATION frames MUST be minimally processed to ensure the state maintained for header compression is consistent (see Section 4.3); similarly, DATA frames MUST be counted toward the connection flow-control window. Failure to process these frames can cause flow control or header compression state to become unsynchronized.",
      "ja": "GOAWAYフレームを送信した後、送信者が識別される最後のストリームよりも高い識別子を有する受信機によって開始されたストリームのフレームを廃棄することができます。ただし、接続状態を変更するすべてのフレームが完全に無視することはできません。例えば、ヘッダは、PUSH_PROMISE、および継続フレームは、最小（4.3節を参照）一致しているヘッダ圧縮のために維持状態を確保するために処理されなければなりません。同様に、データフレームは、接続フロー制御ウィンドウにカウントされなければなりません。これらのフレームを処理する失敗は非同期となるように、流量制御又はヘッダ圧縮状態を引き起こす可能性があります。"
    },
    {
      "indent": 3,
      "text": "The GOAWAY frame also contains a 32-bit error code (Section 7) that contains the reason for closing the connection.",
      "ja": "GOAWAYフレームは、接続を閉じるための理由が含まれ、32ビットのエラーコード（セクション7）を含みます。"
    },
    {
      "indent": 3,
      "text": "Endpoints MAY append opaque data to the payload of any GOAWAY frame. Additional debug data is intended for diagnostic purposes only and carries no semantic value. Debug information could contain security-or privacy-sensitive data. Logged or otherwise persistently stored debug data MUST have adequate safeguards to prevent unauthorized access.",
      "ja": "エンドポイントは、任意のGOAWAYフレームのペイロードに不透明なデータを追加するかもしれません。追加のデバッグデータは、診断のみを目的としたものと全く意味値を運びません。デバッグ情報は、セキュリティやプライバシーに敏感なデータが含まれている可能性があります。ログに記録されたか、そうでない場合は永続的に保存されたデバッグデータは、不正アクセスを防止するための適切な保護手段を持たなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.9. WINDOW_UPDATE",
      "section_title": true,
      "ja": "6.9.  WINDOW_UPDATE"
    },
    {
      "indent": 3,
      "text": "The WINDOW_UPDATE frame (type=0x8) is used to implement flow control; see Section 5.2 for an overview.",
      "ja": "WINDOW_UPDATEフレーム（種別= 0x8という）は、フロー制御を実現するために使用されます。概要については、5.2節を参照してください。"
    },
    {
      "indent": 3,
      "text": "Flow control operates at two levels: on each individual stream and on the entire connection.",
      "ja": "フロー制御は二つのレベルで動作する：各個別のストリームに全体の接続に。"
    },
    {
      "indent": 3,
      "text": "Both types of flow control are hop by hop, that is, only between the two endpoints. Intermediaries do not forward WINDOW_UPDATE frames between dependent connections. However, throttling of data transfer by any receiver can indirectly cause the propagation of flow-control information toward the original sender.",
      "ja": "フロー制御の両方のタイプは、2つのエンドポイント間、すなわち、ホップバイホップされます。仲介は従属接続間WINDOW_UPDATEフレームを転送しません。しかしながら、任意の受信機によるデータ転送の調整は、間接的元の送信者に向かってフロー制御情報の伝達を引き起こすことができます。"
    },
    {
      "indent": 3,
      "text": "Flow control only applies to frames that are identified as being subject to flow control. Of the frame types defined in this document, this includes only DATA frames. Frames that are exempt from flow control MUST be accepted and processed, unless the receiver is unable to assign resources to handling the frame. A receiver MAY respond with a stream error (Section 5.4.2) or connection error (Section 5.4.1) of type FLOW_CONTROL_ERROR if it is unable to accept a frame.",
      "ja": "フロー制御は、フロー制御の対象であると特定されたフレームに適用されます。この文書で定義されたフレームタイプのうち、これが唯一のデータフレームを含んでいます。受信機は、フレームを処理にリソースを割り当てることができない場合を除き、フロー制御を免除されているフレームが、受け入れられ、処理されなければなりません。フレームを受け入れることができない場合、受信機は、ストリームエラー（5.4.2項）またはタイプFLOW_CONTROL_ERRORの接続エラー（5.4.1）で応答することができます。"
    },
    {
      "indent": 4,
      "text": "+-+-------------------------------------------------------------+\n|R|              Window Size Increment (31)                     |\n+-+-------------------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 18,
      "text": "Figure 14: WINDOW_UPDATE Payload Format",
      "ja": "図14：WINDOW_UPDATEペイロードフォーマット"
    },
    {
      "indent": 3,
      "text": "The payload of a WINDOW_UPDATE frame is one reserved bit plus an unsigned 31-bit integer indicating the number of octets that the sender can transmit in addition to the existing flow-control window. The legal range for the increment to the flow-control window is 1 to 2^31-1 (2,147,483,647) octets.",
      "ja": "WINDOW_UPDATEフレームのペイロードは、一つの予約ビットに加えて、送信者が既存のフロー制御ウィンドウに加えて、送信することができるオクテットの数を示す符号なし31ビット整数です。フロー制御ウィンドウをインクリメントするための法的範囲は、1（2,147,483,647）オクテット31-1 ^ 2です。"
    },
    {
      "indent": 3,
      "text": "The WINDOW_UPDATE frame does not define any flags.",
      "ja": "WINDOW_UPDATEフレームは、任意のフラグを定義していません。"
    },
    {
      "indent": 3,
      "text": "The WINDOW_UPDATE frame can be specific to a stream or to the entire connection. In the former case, the frame's stream identifier indicates the affected stream; in the latter, the value \"0\" indicates that the entire connection is the subject of the frame.",
      "ja": "WINDOW_UPDATEフレームは、ストリーム又は全体の接続に特定することができます。前者の場合、フレームのストリーム識別子は、影響を受けたストリームを示します。後者では、値「0」は、全体の接続は、フレームの対象であることを示しています。"
    },
    {
      "indent": 3,
      "text": "A receiver MUST treat the receipt of a WINDOW_UPDATE frame with an flow-control window increment of 0 as a stream error (Section 5.4.2) of type PROTOCOL_ERROR; errors on the connection flow-control window MUST be treated as a connection error (Section 5.4.1).",
      "ja": "受信機は、タイプPROTOCOL_ERRORのストリームエラー（5.4.2項）として0のフロー制御ウィンドウ増分でWINDOW_UPDATEフレームの受信を処理しなければなりません。接続フロー制御ウィンドウのエラーが接続エラー（セクション5.4.1）として扱われなければなりません。"
    },
    {
      "indent": 3,
      "text": "WINDOW_UPDATE can be sent by a peer that has sent a frame bearing the END_STREAM flag. This means that a receiver could receive a WINDOW_UPDATE frame on a \"half-closed (remote)\" or \"closed\" stream. A receiver MUST NOT treat this as an error (see Section 5.1).",
      "ja": "WINDOW_UPDATEはEND_STREAMフラグを担持するフレームを送信したピアによって送信することができます。これは、受信機が「半閉（リモート）」または「閉」ストリームにWINDOW_UPDATEフレームを受信することができることを意味します。受信機は、（セクション5.1を参照）、エラーとして扱いてはなりません。"
    },
    {
      "indent": 3,
      "text": "A receiver that receives a flow-controlled frame MUST always account for its contribution against the connection flow-control window, unless the receiver treats this as a connection error (Section 5.4.1). This is necessary even if the frame is in error. The sender counts the frame toward the flow-control window, but if the receiver does not, the flow-control window at the sender and receiver can become different.",
      "ja": "受信機が接続エラー（セクション5.4.1）として扱わない限り、フロー制御フレームを受信する受信機は常に、接続フロー制御ウィンドウに対するその寄与を考慮しなければなりません。これは、フレームにエラーがある場合にも必要です。送信者は、フロー制御窓に向かってフレームを数えますが、受信機がない場合は、送信者と受信者のフロー制御ウィンドウが異なってくることができます。"
    },
    {
      "indent": 3,
      "text": "A WINDOW_UPDATE frame with a length other than 4 octets MUST be treated as a connection error (Section 5.4.1) of type FRAME_SIZE_ERROR.",
      "ja": "4つのオクテット以外の長さWINDOW_UPDATEフレームは、タイプFRAME_SIZE_ERRORの接続エラー（セクション5.4.1）として扱われなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.9.1. The Flow-Control Window",
      "section_title": true,
      "ja": "6.9.1. フロー制御ウィンドウ"
    },
    {
      "indent": 3,
      "text": "Flow control in HTTP/2 is implemented using a window kept by each sender on every stream. The flow-control window is a simple integer value that indicates how many octets of data the sender is permitted to transmit; as such, its size is a measure of the buffering capacity of the receiver.",
      "ja": "HTTP / 2でのフロー制御は、すべてのストリーム上の各送信者が保管し、ウィンドウを使用して実装されています。フロー制御ウィンドウは、送信者が送信することを許可されているデータの何オクテットを示す単純な整数値です。など、そのサイズは、受信機の緩衝能の尺度です。"
    },
    {
      "indent": 3,
      "text": "Two flow-control windows are applicable: the stream flow-control window and the connection flow-control window. The sender MUST NOT send a flow-controlled frame with a length that exceeds the space available in either of the flow-control windows advertised by the receiver. Frames with zero length with the END_STREAM flag set (that is, an empty DATA frame) MAY be sent if there is no available space in either flow-control window.",
      "ja": "二つのフロー制御ウィンドウが適用されます。ストリームフロー制御ウィンドウと接続フロー制御ウィンドウ。送信側は受信側によって通知フロー制御ウィンドウのいずれかで利用可能なスペースを超える長さを有するフロー制御フレームを送信してはいけません。いずれかのフロー制御ウィンドウで利用可能なスペースがない場合END_STREAMフラグが設定された長さゼロのフレーム（すなわち、空のデータフレーム）で送信されるかもしれません。"
    },
    {
      "indent": 3,
      "text": "For flow-control calculations, the 9-octet frame header is not counted.",
      "ja": "フロー制御計算のため、9オクテットのフレームヘッダはカウントされません。"
    },
    {
      "indent": 3,
      "text": "After sending a flow-controlled frame, the sender reduces the space available in both windows by the length of the transmitted frame.",
      "ja": "フロー制御フレームを送信した後、送信者は送信されたフレームの長さで両方のウィンドウで利用可能な空間を減少させます。"
    },
    {
      "indent": 3,
      "text": "The receiver of a frame sends a WINDOW_UPDATE frame as it consumes data and frees up space in flow-control windows. Separate WINDOW_UPDATE frames are sent for the stream- and connection-level flow-control windows.",
      "ja": "それはデータを消費し、フロー制御ウィンドウ内のスペースを解放してフレームの受信機は、WINDOW_UPDATEフレームを送信します。別々のWINDOW_UPDATEフレームは、ストリームおよび接続レベルのフロー制御のウィンドウのために送信されます。"
    },
    {
      "indent": 3,
      "text": "A sender that receives a WINDOW_UPDATE frame updates the corresponding window by the amount specified in the frame.",
      "ja": "WINDOW_UPDATEフレームを受信した送信側は、フレーム内の指定された量だけ対応するウィンドウを更新します。"
    },
    {
      "indent": 3,
      "text": "A sender MUST NOT allow a flow-control window to exceed 2^31-1 octets. If a sender receives a WINDOW_UPDATE that causes a flow-control window to exceed this maximum, it MUST terminate either the stream or the connection, as appropriate. For streams, the sender sends a RST_STREAM with an error code of FLOW_CONTROL_ERROR; for the connection, a GOAWAY frame with an error code of FLOW_CONTROL_ERROR is sent.",
      "ja": "送信者は、フロー制御ウィンドウは2 ^ 31-1オクテットを超えないようにしなければなりません。送信者がこの最大値を超えフロー制御ウィンドウを引き起こすWINDOW_UPDATEを受信した場合、それは適宜、ストリームまたは接続のいずれかを終了しなければなりません。ストリームの場合、送信者はFLOW_CONTROL_ERRORのエラーコードでRST_STREAMを送信します。接続のために、FLOW_CONTROL_ERRORのエラーコードでGOAWAYフレームが送信されます。"
    },
    {
      "indent": 3,
      "text": "Flow-controlled frames from the sender and WINDOW_UPDATE frames from the receiver are completely asynchronous with respect to each other. This property allows a receiver to aggressively update the window size kept by the sender to prevent streams from stalling.",
      "ja": "受信機から送信側とWINDOW_UPDATEフレームからフロー制御フレームは、互いに対して完全に非同期です。このプロパティには、受信側が積極的に失速からのストリームを防ぐために、送信者が保管し、ウィンドウサイズを更新することができます。"
    },
    {
      "indent": 0,
      "text": "6.9.2. Initial Flow-Control Window Size",
      "section_title": true,
      "ja": "6.9.2. フロー制御に関する初期ウィンドウサイズ"
    },
    {
      "indent": 3,
      "text": "When an HTTP/2 connection is first established, new streams are created with an initial flow-control window size of 65,535 octets. The connection flow-control window is also 65,535 octets. Both endpoints can adjust the initial window size for new streams by including a value for SETTINGS_INITIAL_WINDOW_SIZE in the SETTINGS frame that forms part of the connection preface. The connection flow-control window can only be changed using WINDOW_UPDATE frames.",
      "ja": "HTTP / 2接続が最初に確立されると、新しいストリームは65,535オクテットの最初のフロー制御のウィンドウサイズで作成されます。コネクションフロー制御ウィンドウには、65,535オクテットです。両方のエンドポイントは、接続序文の一部を形成するSETTINGSフレーム内SETTINGS_INITIAL_WINDOW_SIZEの値を含めることによって、新たなストリームの初期ウィンドウサイズを調整することができます。接続フロー制御ウィンドウのみWINDOW_UPDATEフレームを使用して変更することができます。"
    },
    {
      "indent": 3,
      "text": "Prior to receiving a SETTINGS frame that sets a value for SETTINGS_INITIAL_WINDOW_SIZE, an endpoint can only use the default initial window size when sending flow-controlled frames. Similarly, the connection flow-control window is set to the default initial window size until a WINDOW_UPDATE frame is received.",
      "ja": "フロー制御フレームを送信する際SETTINGS_INITIAL_WINDOW_SIZEの値を設定SETTINGSフレームを受信する前に、エンドポイントは、デフォルトの初期ウィンドウサイズを使用することができます。 WINDOW_UPDATEフレームが受信されるまで、同様に、接続フロー制御ウィンドウはデフォルトの初期ウィンドウサイズに設定されています。"
    },
    {
      "indent": 3,
      "text": "In addition to changing the flow-control window for streams that are not yet active, a SETTINGS frame can alter the initial flow-control window size for streams with active flow-control windows (that is, streams in the \"open\" or \"half-closed (remote)\" state). When the value of SETTINGS_INITIAL_WINDOW_SIZE changes, a receiver MUST adjust the size of all stream flow-control windows that it maintains by the difference between the new value and the old value.",
      "ja": "まだアクティブではないストリームのフロー制御ウィンドウを変更することに加えて、SETTINGSフレームは、アクティブフロー制御ウィンドウを有するストリーム（すなわち、「オープン」または「半分のストリームの初期フロー制御ウィンドウサイズを変更することができ-closed（リモート）」状態）。ときSETTINGS_INITIAL_WINDOW_SIZE変化の値は、受信機は、それが新しい値と古い値の差で維持し、すべてのストリームのフロー制御ウィンドウのサイズを調整する必要があります。"
    },
    {
      "indent": 3,
      "text": "A change to SETTINGS_INITIAL_WINDOW_SIZE can cause the available space in a flow-control window to become negative. A sender MUST track the negative flow-control window and MUST NOT send new flow-controlled frames until it receives WINDOW_UPDATE frames that cause the flow-control window to become positive.",
      "ja": "SETTINGS_INITIAL_WINDOW_SIZEへの変更は、フロー制御ウィンドウで利用可能なスペースがマイナスになることがあります。送信者は、負のフロー制御ウィンドウを追跡する必要があり、それがポジティブになるためのフロー制御ウィンドウを引き起こすWINDOW_UPDATEフレームを受信するまで、新たなフロー制御フレームを送ってはいけません。"
    },
    {
      "indent": 3,
      "text": "For example, if the client sends 60 KB immediately on connection establishment and the server sets the initial window size to be 16 KB, the client will recalculate the available flow-control window to be -44 KB on receipt of the SETTINGS frame. The client retains a negative flow-control window until WINDOW_UPDATE frames restore the window to being positive, after which the client can resume sending.",
      "ja": "クライアントが接続確立に直ちに60キロバイトを送信し、サーバが初期ウィンドウサイズが16 KBであると設定した場合、クライアントは、設定フレームの受信に-44 KBであると利用可能なフロー制御ウィンドウを再計算します。 WINDOW_UPDATEフレームは、クライアントが送信を再開することができた後、ポジティブであることにウィンドウを復元するまで、クライアントは、負のフロー制御ウィンドウを保持します。"
    },
    {
      "indent": 3,
      "text": "A SETTINGS frame cannot alter the connection flow-control window.",
      "ja": "SETTINGSフレームは、接続フロー制御ウィンドウを変更することはできません。"
    },
    {
      "indent": 3,
      "text": "An endpoint MUST treat a change to SETTINGS_INITIAL_WINDOW_SIZE that causes any flow-control window to exceed the maximum size as a connection error (Section 5.4.1) of type FLOW_CONTROL_ERROR.",
      "ja": "エンドポイントは、タイプFLOW_CONTROL_ERRORの接続エラー（セクション5.4.1）のように最大サイズを超えて任意のフロー制御ウィンドウを引き起こすSETTINGS_INITIAL_WINDOW_SIZEへの変更を扱わなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.9.3. Reducing the Stream Window Size",
      "section_title": true,
      "ja": "6.9.3. ストリームウィンドウのサイズを小さく"
    },
    {
      "indent": 3,
      "text": "A receiver that wishes to use a smaller flow-control window than the current size can send a new SETTINGS frame. However, the receiver MUST be prepared to receive data that exceeds this window size, since the sender might send data that exceeds the lower limit prior to processing the SETTINGS frame.",
      "ja": "現在のサイズよりも小さいフロー制御ウィンドウを使用したい受信機は、新しい設定フレームを送信することができます。送信者がSETTINGSフレームを処理する前に下限を超えるデータを送信するかもしれないので、受信機は、このウィンドウのサイズを超えるデータを受信するように準備しなければなりません。"
    },
    {
      "indent": 3,
      "text": "After sending a SETTINGS frame that reduces the initial flow-control window size, a receiver MAY continue to process streams that exceed flow-control limits. Allowing streams to continue does not allow the receiver to immediately reduce the space it reserves for flow-control windows. Progress on these streams can also stall, since WINDOW_UPDATE frames are needed to allow the sender to resume sending. The receiver MAY instead send a RST_STREAM with an error code of FLOW_CONTROL_ERROR for the affected streams.",
      "ja": "初期フロー制御ウィンドウサイズを減少させるSETTINGSフレームを送信した後、受信機は、フロー制御限界を超えるストリームを処理し続けることができます。流れが継続できるようにすると、受信機はすぐにそれがフロー制御ウィンドウの留保スペースを小さくすることはできません。 WINDOW_UPDATEフレームは送信者が送信を再開できるようにするために必要とされているので、これらのストリームの進捗状況も、失速することができます。受信機ではなく、影響を受けたストリームのFLOW_CONTROL_ERRORのエラーコードでRST_STREAMを送信することができます。"
    },
    {
      "indent": 0,
      "text": "6.10. CONTINUATION",
      "section_title": true,
      "ja": "6.10. 継続"
    },
    {
      "indent": 3,
      "text": "The CONTINUATION frame (type=0x9) is used to continue a sequence of header block fragments (Section 4.3). Any number of CONTINUATION frames can be sent, as long as the preceding frame is on the same stream and is a HEADERS, PUSH_PROMISE, or CONTINUATION frame without the END_HEADERS flag set.",
      "ja": "連続フレーム（種別= 0x9）は、ヘッダブロック断片（セクション4.3）のシーケンスを継続するために使用されます。連続フレームの任意の数であれば、先行するフレームが同じストリーム上にあり、END_HEADERSフラグを設定せずにヘッダー、PUSH_PROMISE、または継続フレームであるとして、送信することができます。"
    },
    {
      "indent": 4,
      "text": "+---------------------------------------------------------------+\n|                   Header Block Fragment (*)                 ...\n+---------------------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 19,
      "text": "Figure 15: CONTINUATION Frame Payload",
      "ja": "図15：継続フレームペイロード"
    },
    {
      "indent": 3,
      "text": "The CONTINUATION frame payload contains a header block fragment (Section 4.3).",
      "ja": "連続フレームのペイロードは、ヘッダブロック断片（セクション4.3）を含有します。"
    },
    {
      "indent": 3,
      "text": "The CONTINUATION frame defines the following flag:",
      "ja": "連続フレームは、次のフラグを定義しています。"
    },
    {
      "indent": 3,
      "text": "END_HEADERS (0x4): When set, bit 2 indicates that this frame ends a header block (Section 4.3).",
      "ja": "END_HEADERS（0x4の）セット、ビット2は、このフレームは、ヘッダブロック（セクション4.3）を終了することを示しています。"
    },
    {
      "indent": 6,
      "text": "If the END_HEADERS bit is not set, this frame MUST be followed by another CONTINUATION frame. A receiver MUST treat the receipt of any other type of frame or a frame on a different stream as a connection error (Section 5.4.1) of type PROTOCOL_ERROR.",
      "ja": "END_HEADERSビットが設定されていない場合、このフレームは、別の継続フレームが続かなければなりません。受信機は、フレームの任意の他のタイプまたはタイプPROTOCOL_ERRORの接続エラー（5.4.1）などの異なるストリーム上のフレームの受信を処理しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The CONTINUATION frame changes the connection state as defined in Section 4.3.",
      "ja": "4.3節で定義された継続フレームは、接続状態を変更します。"
    },
    {
      "indent": 3,
      "text": "CONTINUATION frames MUST be associated with a stream. If a CONTINUATION frame is received whose stream identifier field is 0x0, the recipient MUST respond with a connection error (Section 5.4.1) of type PROTOCOL_ERROR.",
      "ja": "連続フレームがストリームに関連付けられなければなりません。継続フレームを受信した場合、そのストリーム識別子フィールドが0x0であり、受信者は、タイプPROTOCOL_ERRORの接続エラー（5.4.1）で応答しなければなりません。"
    },
    {
      "indent": 3,
      "text": "A CONTINUATION frame MUST be preceded by a HEADERS, PUSH_PROMISE or CONTINUATION frame without the END_HEADERS flag set. A recipient that observes violation of this rule MUST respond with a connection error (Section 5.4.1) of type PROTOCOL_ERROR.",
      "ja": "継続フレームはEND_HEADERSフラグを設定することなく、ヘッダ、PUSH_PROMISEまたは継続フレームが先行されなければなりません。このルールの違反を監視し、受信者は、型PROTOCOL_ERRORの接続エラー（5.4.1）で応じなければなりません。"
    },
    {
      "indent": 0,
      "text": "7. Error Codes",
      "section_title": true,
      "ja": "7.エラーコード"
    },
    {
      "indent": 3,
      "text": "Error codes are 32-bit fields that are used in RST_STREAM and GOAWAY frames to convey the reasons for the stream or connection error.",
      "ja": "エラーコードはRST_STREAMで使用される32ビットのフィールドであり、GOAWAYストリームまたは接続エラーの理由を伝えるためにフレーム。"
    },
    {
      "indent": 3,
      "text": "Error codes share a common code space. Some error codes apply only to either streams or the entire connection and have no defined semantics in the other context.",
      "ja": "エラーコードは、共通のコード空間を共有しています。いくつかのエラーコードは、ストリームや全体の接続のいずれかにのみ適用され、他のコンテキストには定義された意味を持っていません。"
    },
    {
      "indent": 3,
      "text": "The following error codes are defined:",
      "ja": "次のエラーコードが定義されています。"
    },
    {
      "indent": 3,
      "text": "NO_ERROR (0x0): The associated condition is not a result of an error. For example, a GOAWAY might include this code to indicate graceful shutdown of a connection.",
      "ja": "NO_ERROR（0x0の）関連する状態は、エラーの結果ではありません。例えば、GOAWAYは、接続の正常なシャットダウンを示すために、このコードが含まれる場合があります。"
    },
    {
      "indent": 3,
      "text": "PROTOCOL_ERROR (0x1): The endpoint detected an unspecific protocol error. This error is for use when a more specific error code is not available.",
      "ja": "PROTOCOL_ERROR（0x1の）エンドポイントは、非特異的プロトコルエラーを検出しました。より具体的なエラーコードが利用できない場合、このエラーは、使用するためのものです。"
    },
    {
      "indent": 3,
      "text": "INTERNAL_ERROR (0x2): The endpoint encountered an unexpected internal error.",
      "ja": "INTERNAL_ERROR（0x2の）：エンドポイントが予期しない内部エラーが発生しました。"
    },
    {
      "indent": 3,
      "text": "FLOW_CONTROL_ERROR (0x3): The endpoint detected that its peer violated the flow-control protocol.",
      "ja": "FLOW_CONTROL_ERROR（0x3の）エンドポイントは、そのピアがフロー制御プロトコルに違反していることを検出。"
    },
    {
      "indent": 3,
      "text": "SETTINGS_TIMEOUT (0x4): The endpoint sent a SETTINGS frame but did not receive a response in a timely manner. See Section 6.5.3 (\"Settings Synchronization\").",
      "ja": "SETTINGS_TIMEOUT（0x4の）：エンドポイントは、SETTINGSフレームを送ったが、タイムリーに応答を受信しませんでした。 6.5.3項（「設定の同期」）を参照してください。"
    },
    {
      "indent": 3,
      "text": "STREAM_CLOSED (0x5): The endpoint received a frame after a stream was half-closed.",
      "ja": "STREAM_CLOSED（0x5）：ストリームが半分閉じた後に、エンドポイントは、フレームを受信しました。"
    },
    {
      "indent": 3,
      "text": "FRAME_SIZE_ERROR (0x6): The endpoint received a frame with an invalid size.",
      "ja": "FRAME_SIZE_ERROR（0x6に）エンドポイントが無効なサイズのフレームを受信しました。"
    },
    {
      "indent": 3,
      "text": "REFUSED_STREAM (0x7): The endpoint refused the stream prior to performing any application processing (see Section 8.1.4 for details).",
      "ja": "REFUSED_STREAM（0x7の）エンドポイントは（詳細については、セクション8.1.4を参照）は、従来の任意のアプリケーション処理を実行するストリームを拒否しました。"
    },
    {
      "indent": 3,
      "text": "CANCEL (0x8): Used by the endpoint to indicate that the stream is no longer needed.",
      "ja": "CANCEL（0x8の）：エンドポイントで使用するには、ストリームがもはや必要とされていないことを示すように。"
    },
    {
      "indent": 3,
      "text": "COMPRESSION_ERROR (0x9): The endpoint is unable to maintain the header compression context for the connection.",
      "ja": "COMPRESSION_ERROR（0x9）：エンドポイントは、接続用のヘッダ圧縮コンテキストを維持することができません。"
    },
    {
      "indent": 3,
      "text": "CONNECT_ERROR (0xa): The connection established in response to a CONNECT request (Section 8.3) was reset or abnormally closed.",
      "ja": "CONNECT_ERROR（は0xa）：CONNECT要求（セクション8.3）に応答して確立された接続は、リセットまたは異常閉じました。"
    },
    {
      "indent": 3,
      "text": "ENHANCE_YOUR_CALM (0xb): The endpoint detected that its peer is exhibiting a behavior that might be generating excessive load.",
      "ja": "ENHANCE_YOUR_CALM（0xb）：エンドポイントは、そのピアが過負荷を発生する可能性がある挙動を示すことが検出されました。"
    },
    {
      "indent": 3,
      "text": "INADEQUATE_SECURITY (0xc): The underlying transport has properties that do not meet minimum security requirements (see Section 9.2).",
      "ja": "INADEQUATE_SECURITY（から0xC）：基礎となるトランスポートは、最低限のセキュリティ要件（9.2節を参照）を満たしていない特性を有しています。"
    },
    {
      "indent": 3,
      "text": "HTTP_1_1_REQUIRED (0xd): The endpoint requires that HTTP/1.1 be used instead of HTTP/2.",
      "ja": "HTTP_1_1_REQUIRED（の0xd）：エンドポイントは、HTTP / 1.1の代わりにHTTP / 2を用いることが必要です。"
    },
    {
      "indent": 3,
      "text": "Unknown or unsupported error codes MUST NOT trigger any special behavior. These MAY be treated by an implementation as being equivalent to INTERNAL_ERROR.",
      "ja": "不明またはサポートされていないエラー・コードは、特別な動作をトリガしてはなりません。これらは、INTERNAL_ERRORと同等のものとして実装することによって治療することができます。"
    },
    {
      "indent": 0,
      "text": "8. HTTP Message Exchanges",
      "section_title": true,
      "ja": "8. HTTPメッセージの交換"
    },
    {
      "indent": 3,
      "text": "HTTP/2 is intended to be as compatible as possible with current uses of HTTP. This means that, from the application perspective, the features of the protocol are largely unchanged. To achieve this, all request and response semantics are preserved, although the syntax of conveying those semantics has changed.",
      "ja": "HTTP / 2は、HTTPの現在の用途にできるだけ適合するように意図されています。これは、アプリケーションの観点から、プロトコルの機能が大幅に変更されていない、ということを意味します。それらの意味を伝えるの構文が変更されたものの、これを実現するために、すべての要求と応答の意味は、保存されています。"
    },
    {
      "indent": 3,
      "text": "Thus, the specification and requirements of HTTP/1.1 Semantics and Content [RFC7231], Conditional Requests [RFC7232], Range Requests [RFC7233], Caching [RFC7234], and Authentication [RFC7235] are applicable to HTTP/2. Selected portions of HTTP/1.1 Message Syntax and Routing [RFC7230], such as the HTTP and HTTPS URI schemes, are also applicable in HTTP/2, but the expression of those semantics for this protocol are defined in the sections below.",
      "ja": "したがって、明細書およびHTTP / 1.1セマンティクスとコンテンツ[RFC7231]、条件要求[RFC7232]、範囲要求の要件[RFC7233]、キャッシュ[RFC7234]、および認証[RFC7235]はHTTP / 2に適用可能です。 HTTPやHTTPS URIスキームとしてHTTP / 1.1メッセージ構文およびルーティング[RFC7230]の選択された部分は、HTTP / 2にも適用可能であるが、このプロトコルのためのそれらのセマンティクスの発現は、以下のセクションで定義されています。"
    },
    {
      "indent": 0,
      "text": "8.1. HTTP Request/Response Exchange",
      "section_title": true,
      "ja": "8.1.  HTTPリクエスト/レスポンス交換"
    },
    {
      "indent": 3,
      "text": "A client sends an HTTP request on a new stream, using a previously unused stream identifier (Section 5.1.1). A server sends an HTTP response on the same stream as the request.",
      "ja": "クライアントは、以前に未使用のストリーム識別子（セクション5.1.1）を使用して、新しいストリーム上のHTTPリクエストを送信します。サーバは要求と同じストリーム上のHTTP応答を送信します。"
    },
    {
      "indent": 3,
      "text": "An HTTP message (request or response) consists of:",
      "ja": "HTTPメッセージ（要求または応答）で構成されています。"
    },
    {
      "indent": 3,
      "text": "1. for a response only, zero or more HEADERS frames (each followed by zero or more CONTINUATION frames) containing the message headers of informational (1xx) HTTP responses (see [RFC7230], Section 3.2 and [RFC7231], Section 6.2),",
      "ja": "情報のメッセージ・ヘッダ（1XX）HTTPレスポンス（[RFC7230]、セクション3.2と[RFC7231]、セクション6.2を参照）を含むレスポンスのみ、ゼロ以上のヘッダフレーム（各々がゼロ以上の継続がフレームが続く）1."
    },
    {
      "indent": 3,
      "text": "2. one HEADERS frame (followed by zero or more CONTINUATION frames) containing the message headers (see [RFC7230], Section 3.2),",
      "ja": "メッセージヘッダーを含む（ゼロ個以上の連続フレームが続く）2. 1ヘッダフレームは、（[RFC7230]、セクション3.2を参照されたいです）"
    },
    {
      "indent": 3,
      "text": "3. zero or more DATA frames containing the payload body (see [RFC7230], Section 3.3), and",
      "ja": "ペイロード体を含む3ゼロ以上のデータフレーム（[RFC7230]、セクション3.3を参照）、および"
    },
    {
      "indent": 3,
      "text": "4. optionally, one HEADERS frame, followed by zero or more CONTINUATION frames containing the trailer-part, if present (see [RFC7230], Section 4.1.2).",
      "ja": "4.必要に応じて、トレーラ部を含むゼロ個以上の連続フレームに続く1つのヘッダフレームは、存在する場合（[RFC7230]セクション4.1.2を参照します）。"
    },
    {
      "indent": 3,
      "text": "The last frame in the sequence bears an END_STREAM flag, noting that a HEADERS frame bearing the END_STREAM flag can be followed by CONTINUATION frames that carry any remaining portions of the header block.",
      "ja": "シーケンスの最後のフレームはEND_STREAMフラグを担持するヘッダフレームは、ヘッダブロックの残りの部分を運ぶ連続フレームが続くことができることに留意、END_STREAMフラグを担います。"
    },
    {
      "indent": 3,
      "text": "Other frames (from any stream) MUST NOT occur between the HEADERS frame and any CONTINUATION frames that might follow.",
      "ja": "（任意のストリームからの）他のフレームはHEADERSフレームと続く可能性のある連続フレーム間で発生してはなりません。"
    },
    {
      "indent": 3,
      "text": "HTTP/2 uses DATA frames to carry message payloads. The \"chunked\" transfer encoding defined in Section 4.1 of [RFC7230] MUST NOT be used in HTTP/2.",
      "ja": "HTTP / 2は、メッセージペイロードを運ぶためにデータフレームを使用します。 [RFC7230]のセクション4.1で定義された転送符号化は、HTTP / 2で使用してはいけません「チャンク」。"
    },
    {
      "indent": 3,
      "text": "Trailing header fields are carried in a header block that also terminates the stream. Such a header block is a sequence starting with a HEADERS frame, followed by zero or more CONTINUATION frames, where the HEADERS frame bears an END_STREAM flag. Header blocks after the first that do not terminate the stream are not part of an HTTP request or response.",
      "ja": "後続ヘッダフィールドは、ストリームを終了し、ヘッダブロックで運ばれます。このようなヘッダブロックは、ヘッダーフレームがEND_STREAMフラグを担持ゼロまたはそれ以上の連続フレーム、続くヘッダフレームで始まるシーケンスです。ストリームを終了していない最初の後のヘッダブロックは、HTTP要求または応答の一部ではありません。"
    },
    {
      "indent": 3,
      "text": "A HEADERS frame (and associated CONTINUATION frames) can only appear at the start or end of a stream. An endpoint that receives a HEADERS frame without the END_STREAM flag set after receiving a final (non-informational) status code MUST treat the corresponding request or response as malformed (Section 8.1.2.6).",
      "ja": "ヘッダフレーム（および関連する継続フレーム）のみのストリームの開始または終了時に現れることができます。最終的な（非通知）ステータスコードを受信した後に設定END_STREAMフラグなしヘッダフレームを受信したエンドポイントは、不正な形式（セクション8.1.2.6）と対応する要求または応答を治療しなければなりません。"
    },
    {
      "indent": 3,
      "text": "An HTTP request/response exchange fully consumes a single stream. A request starts with the HEADERS frame that puts the stream into an \"open\" state. The request ends with a frame bearing END_STREAM, which causes the stream to become \"half-closed (local)\" for the client and \"half-closed (remote)\" for the server. A response starts with a HEADERS frame and ends with a frame bearing END_STREAM, which places the stream in the \"closed\" state.",
      "ja": "HTTPリクエスト/レスポンス交換は完全に単一のストリームを消費します。リクエストは「開」状態にストリームを置きますHEADERSフレームで始まります。要求は、サーバのクライアントおよび「半分閉じた（リモート）」「（ローカル）半閉」になるように流れを引き起こすEND_STREAM軸受フレームで終わります。応答は、ヘッダフレームで始まり、「閉」状態にストリームを配置するフレーム軸受END_STREAM、で終わります。"
    },
    {
      "indent": 3,
      "text": "An HTTP response is complete after the server sends -- or the client receives -- a frame with the END_STREAM flag set (including any CONTINUATION frames needed to complete a header block). A server can send a complete response prior to the client sending an entire request if the response does not depend on any portion of the request that has not been sent and received. When this is true, a server MAY request that the client abort transmission of a request without error by sending a RST_STREAM with an error code of NO_ERROR after sending a complete response (i.e., a frame with the END_STREAM flag). Clients MUST NOT discard responses as a result of receiving such a RST_STREAM, though clients can always discard responses at their discretion for other reasons.",
      "ja": "またはクライアントが受信する -   - （ヘッダブロックを完了するのに必要な任意の連続フレームを含む）END_STREAMフラグが設定されたフレームをサーバに送信した後、HTTP応答が完了しました。サーバが応答が送信され、受信されていない要求のいずれかの部分に依存していない場合は、全体のリクエストを送信し、クライアントに前に完全な応答を送信することができます。これが真である場合、サーバは、クライアントが完全な応答（END_STREAMフラグと、すなわち、フレーム）を送信した後NO_ERRORのエラーコードでRST_STREAMを送信することによって、エラーなしで要求の送信を中止することを要求することができます。クライアントは、常に他の理由のために自分の裁量で回答を捨てることができますが、クライアントは、そのようRST_STREAMを受信した結果としての応答を廃棄してはなりません。"
    },
    {
      "indent": 0,
      "text": "8.1.1. Upgrading from HTTP/2",
      "section_title": true,
      "ja": "8.1.1.  HTTP / 2からのアップグレード"
    },
    {
      "indent": 3,
      "text": "HTTP/2 removes support for the 101 (Switching Protocols) informational status code ([RFC7231], Section 6.2.2).",
      "ja": "HTTP / 2は101（スイッチングプロトコル）のサポート情報のステータスコード（[RFC7231]、セクション6.2.2）を除去します。"
    },
    {
      "indent": 3,
      "text": "The semantics of 101 (Switching Protocols) aren't applicable to a multiplexed protocol. Alternative protocols are able to use the same mechanisms that HTTP/2 uses to negotiate their use (see Section 3).",
      "ja": "101（スイッチングプロトコル）の意味は、多重化されたプロトコルには適用されません。代替プロトコルはHTTP / 2は、それらの使用を交渉するために使用するのと同じメカニズムを使用することができる（セクション3を参照）。"
    },
    {
      "indent": 0,
      "text": "8.1.2. HTTP Header Fields",
      "section_title": true,
      "ja": "8.1.2.  HTTPヘッダフィールド"
    },
    {
      "indent": 3,
      "text": "HTTP header fields carry information as a series of key-value pairs. For a listing of registered HTTP headers, see the \"Message Header Field\" registry maintained at <https://www.iana.org/assignments/ message-headers>.",
      "ja": "HTTPヘッダフィールドは、キーと値のペアの一連の情報を運びます。登録したHTTPヘッダのリストについては、<https://www.iana.org/assignments/メッセージヘッダ>に保た「メッセージヘッダーフィールド」のレジストリを参照してください。"
    },
    {
      "indent": 3,
      "text": "Just as in HTTP/1.x, header field names are strings of ASCII characters that are compared in a case-insensitive fashion. However, header field names MUST be converted to lowercase prior to their encoding in HTTP/2. A request or response containing uppercase header field names MUST be treated as malformed (Section 8.1.2.6).",
      "ja": "ただ、HTTP / 1.1のように、ヘッダーフィールド名は大文字と小文字を区別しない方法で比較されているASCII文字の文字列です。しかし、ヘッダフィールド名は、HTTP / 2での符号化の前に小文字に変換されなければなりません。大文字ヘッダフィールド名を含む要求または応答は、不正な形式（セクション8.1.2.6）として扱われなければなりません。"
    },
    {
      "indent": 0,
      "text": "8.1.2.1. Pseudo-Header Fields",
      "section_title": true,
      "ja": "8.1.2.1。擬似ヘッダフィールド"
    },
    {
      "indent": 3,
      "text": "While HTTP/1.x used the message start-line (see [RFC7230], Section 3.1) to convey the target URI, the method of the request, and the status code for the response, HTTP/2 uses special pseudo-header fields beginning with ':' character (ASCII 0x3a) for this purpose.",
      "ja": "HTTP / 1.1は、メッセージ開始ラインを使用しながら、ターゲットURI、要求の方法、および応答のステータスコードを搬送する（[RFC7230]、セクション3.1を参照）、HTTP / 2は、特別な疑似ヘッダフィールドを使用し始まる「：」文字（ASCIIの0x3a）を、この目的のために。"
    },
    {
      "indent": 3,
      "text": "Pseudo-header fields are not HTTP header fields. Endpoints MUST NOT generate pseudo-header fields other than those defined in this document.",
      "ja": "疑似ヘッダフィールドは、HTTPヘッダーフィールドはありません。エンドポイントは、この文書で定義されたもの以外の疑似ヘッダフィールドを生成してはいけません。"
    },
    {
      "indent": 3,
      "text": "Pseudo-header fields are only valid in the context in which they are defined. Pseudo-header fields defined for requests MUST NOT appear in responses; pseudo-header fields defined for responses MUST NOT appear in requests. Pseudo-header fields MUST NOT appear in trailers. Endpoints MUST treat a request or response that contains undefined or invalid pseudo-header fields as malformed (Section 8.1.2.6).",
      "ja": "擬似ヘッダフィールドは、定義されたコンテキスト内でのみ有効です。リクエストに対して定義された疑似ヘッダフィールドは、レスポンスにも現れてはなりません。応答のために定義された疑似ヘッダフィールドは、リクエストに現れてはいけません。擬似ヘッダフィールドは、トレーラーに現れてはいけません。エンドポイントは、不正な形式（セクション8.1.2.6）のような、未定義または無効疑似ヘッダフィールドを含む要求または応答を治療しなければなりません。"
    },
    {
      "indent": 3,
      "text": "All pseudo-header fields MUST appear in the header block before regular header fields. Any request or response that contains a pseudo-header field that appears in a header block after a regular header field MUST be treated as malformed (Section 8.1.2.6).",
      "ja": "すべての疑似ヘッダフィールドは、通常のヘッダフィールドの前にヘッダブロックに表示される必要があります。定期的なヘッダフィールドの後にヘッダブロックに表示される疑似ヘッダフィールドを含む任意の要求または応答は、不正な形式（セクション8.1.2.6）として扱われなければなりません。"
    },
    {
      "indent": 0,
      "text": "8.1.2.2. Connection-Specific Header Fields",
      "section_title": true,
      "ja": "8.1.2.2。接続固有のヘッダフィールド"
    },
    {
      "indent": 3,
      "text": "HTTP/2 does not use the Connection header field to indicate connection-specific header fields; in this protocol, connection-specific metadata is conveyed by other means. An endpoint MUST NOT generate an HTTP/2 message containing connection-specific header fields; any message containing connection-specific header fields MUST be treated as malformed (Section 8.1.2.6).",
      "ja": "HTTP / 2接続固有のヘッダフィールドを示すために、接続ヘッダフィールドを使用していません。このプロトコルでは、接続固有のメタデータは、他の手段によって搬送されます。エンドポイントは、接続固有のヘッダフィールドを含むHTTP / 2メッセージを生成してはいけません。接続固有のヘッダフィールドを含む任意のメッセージは、不正な形式（セクション8.1.2.6）として扱われなければなりません。"
    },
    {
      "indent": 3,
      "text": "The only exception to this is the TE header field, which MAY be present in an HTTP/2 request; when it is, it MUST NOT contain any value other than \"trailers\".",
      "ja": "これに対する唯一の例外は、HTTP / 2リクエスト中に存在しているかもしれTEヘッダフィールドです。それがあるとき、それは「トレーラー」以外の値を含めることはできません。"
    },
    {
      "indent": 3,
      "text": "This means that an intermediary transforming an HTTP/1.x message to HTTP/2 will need to remove any header fields nominated by the Connection header field, along with the Connection header field itself. Such intermediaries SHOULD also remove other connection-specific header fields, such as Keep-Alive, Proxy-Connection, Transfer-Encoding, and Upgrade, even if they are not nominated by the Connection header field.",
      "ja": "これは、HTTP / 2 HTTP / 1.xのメッセージを変換する中間の接続ヘッダフィールド自体とともに、接続ヘッダフィールドによって指名任意のヘッダフィールドを削除する必要があることを意味します。このような仲介はまた、彼らはConnectionヘッダフィールドによって指名されていない場合でも、そのようなキープアライブ、プロキシ接続、転送エンコードなどの他の接続固有のヘッダフィールドを、削除、およびアップグレードする必要があります。"
    },
    {
      "indent": 6,
      "text": "Note: HTTP/2 purposefully does not support upgrade to another protocol. The handshake methods described in Section 3 are believed sufficient to negotiate the use of alternative protocols.",
      "ja": "注：HTTP / 2意図的に別のプロトコルへのアップグレードをサポートしていません。セクション3に記載のハンドシェイク方法は、別のプロトコルの使用を交渉するのに十分と考えられます。"
    },
    {
      "indent": 0,
      "text": "8.1.2.3. Request Pseudo-Header Fields",
      "section_title": true,
      "ja": "8.1.2.3。擬似ヘッダフィールドをリクエスト"
    },
    {
      "indent": 3,
      "text": "The following pseudo-header fields are defined for HTTP/2 requests:",
      "ja": "以下の擬似ヘッダフィールドは、HTTP / 2要求のために定義されています。"
    },
    {
      "indent": 3,
      "text": "o The \":method\" pseudo-header field includes the HTTP method ([RFC7231], Section 4).",
      "ja": "○「：メソッド」擬似ヘッダフィールドは、HTTPメソッド（[RFC7231]、セクション4）を含みます。"
    },
    {
      "indent": 3,
      "text": "o The \":scheme\" pseudo-header field includes the scheme portion of the target URI ([RFC3986], Section 3.1).",
      "ja": "○「：スキーム」疑似ヘッダフィールドは、対象のスキーム部分を含むURI（[RFC3986]、セクション3.1）。"
    },
    {
      "indent": 6,
      "text": "\":scheme\" is not restricted to \"http\" and \"https\" schemed URIs. A proxy or gateway can translate requests for non-HTTP schemes, enabling the use of HTTP to interact with non-HTTP services.",
      "ja": "「：スキームは」に限定されるものではなく、「http」と「https」のURIが画策しました。プロキシまたはゲートウェイが非HTTPサービスと対話するためのHTTPの使用を可能にする、非HTTPスキームの要求を翻訳することができます。"
    },
    {
      "indent": 3,
      "text": "o The \":authority\" pseudo-header field includes the authority portion of the target URI ([RFC3986], Section 3.2). The authority MUST NOT include the deprecated \"userinfo\" subcomponent for \"http\" or \"https\" schemed URIs.",
      "ja": "○「：権限」疑似ヘッダフィールドは、対象の権限部分を含むURI（[RFC3986]、セクション3.2）。当局は非推奨「のuserinfo」サブコンポーネントを含んではいけません「http」または「https」URIを画策。"
    },
    {
      "indent": 6,
      "text": "To ensure that the HTTP/1.1 request line can be reproduced accurately, this pseudo-header field MUST be omitted when translating from an HTTP/1.1 request that has a request target in origin or asterisk form (see [RFC7230], Section 5.3). Clients that generate HTTP/2 requests directly SHOULD use the \":authority\" pseudo-header field instead of the Host header field. An intermediary that converts an HTTP/2 request to HTTP/1.1 MUST create a Host header field if one is not present in a request by copying the value of the \":authority\" pseudo-header field.",
      "ja": "起源またはアスタリスクフォーム（[RFC7230]、セクション5.3を参照）要求の対象を持つHTTP / 1.1リクエストから変換するときにHTTP / 1.1リクエストラインを正確に再現することができることを確実にするために、この疑似ヘッダフィールドを省略しなければなりません。代わりに、Hostヘッダフィールドの「権威」疑似ヘッダフィールドを直接HTTP / 2要求を生成するクライアントは使用すべきです。 「権限」疑似ヘッダフィールドつの値をコピーすることによって要求に存在しない場合はHTTPにHTTP / 2リクエストを変換する中間/ 1.1 Hostヘッダーフィールドを作成する必要があります。"
    },
    {
      "indent": 3,
      "text": "o The \":path\" pseudo-header field includes the path and query parts of the target URI (the \"path-absolute\" production and optionally a '?' character followed by the \"query\" production (see Sections 3.3 and 3.4 of [RFC3986]). A request in asterisk form includes the value '*' for the \":path\" pseudo-header field.",
      "ja": "O：「？」、「パス」は疑似ヘッダフィールドは「クエリ」の生産が続くターゲットURIのパスとクエリ部分（「パス絶対」生産および任意の文字を含む（セクション3.3を参照の3.4 [ 。「：パス」疑似ヘッダフィールドRFC3986]）アスタリスク状の要求は、値「*」を含みます。"
    },
    {
      "indent": 6,
      "text": "This pseudo-header field MUST NOT be empty for \"http\" or \"https\" URIs; \"http\" or \"https\" URIs that do not contain a path component MUST include a value of '/'. The exception to this rule is an OPTIONS request for an \"http\" or \"https\" URI that does not include a path component; these MUST include a \":path\" pseudo-header field with a value of '*' (see [RFC7230], Section 5.3.4).",
      "ja": "この疑似ヘッダフィールドが「http」または「https」URIの空にできません。 「/」の値を含まなければならないパスコンポーネントが含まれていない「http」または「https」のURI。この規則の例外は、パス成分を含まない「http」または「https」URIのためのOPTIONS要求です。 「パス」「*」の値を持つ疑似ヘッダフィールド（[RFC7230]、セクション5.3.4を参照）、これらを含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "All HTTP/2 requests MUST include exactly one valid value for the \":method\", \":scheme\", and \":path\" pseudo-header fields, unless it is a CONNECT request (Section 8.3). An HTTP request that omits mandatory pseudo-header fields is malformed (Section 8.1.2.6).",
      "ja": "それはCONNECT要求（セクション8.3）でない限り、疑似ヘッダフィールド、「方法」、「：スキーム」、および「パス」すべてのHTTP / 2要求者に正確に一つの有効な値を含まなければなりません。必須の疑似ヘッダフィールドを省略したHTTPリクエスト（セクション8.1.2.6）の形式が正しくありません。"
    },
    {
      "indent": 3,
      "text": "HTTP/2 does not define a way to carry the version identifier that is included in the HTTP/1.1 request line.",
      "ja": "HTTP / 2 HTTP / 1.1リクエストラインに含まれるバージョン識別子を搬送する方法を定義していません。"
    },
    {
      "indent": 0,
      "text": "8.1.2.4. Response Pseudo-Header Fields",
      "section_title": true,
      "ja": "8.1.2.4。レスポンス擬似ヘッダフィールド"
    },
    {
      "indent": 3,
      "text": "For HTTP/2 responses, a single \":status\" pseudo-header field is defined that carries the HTTP status code field (see [RFC7231], Section 6). This pseudo-header field MUST be included in all responses; otherwise, the response is malformed (Section 8.1.2.6).",
      "ja": "HTTP / 2応答を、単一「ステータス」疑似ヘッダフィールドは、（[RFC7231]、セクション6を参照）HTTPステータスコードフィールドを運ぶように定義されています。この疑似ヘッダフィールドは、すべての応答に含まれなければなりません。そうでない場合、応答は（セクション8.1.2.6）奇形れます。"
    },
    {
      "indent": 3,
      "text": "HTTP/2 does not define a way to carry the version or reason phrase that is included in an HTTP/1.1 status line.",
      "ja": "HTTP / 2 HTTP / 1.1ステータスラインに含まれているバージョンまたは理由フレーズを伝送する方法を定義していません。"
    },
    {
      "indent": 0,
      "text": "8.1.2.5. Compressing the Cookie Header Field",
      "section_title": true,
      "ja": "8.1.2.5。クッキーヘッダーフィールドの圧縮"
    },
    {
      "indent": 3,
      "text": "The Cookie header field [COOKIE] uses a semi-colon (\";\") to delimit cookie-pairs (or \"crumbs\"). This header field doesn't follow the list construction rules in HTTP (see [RFC7230], Section 3.2.2), which prevents cookie-pairs from being separated into different name-value pairs. This can significantly reduce compression efficiency as individual cookie-pairs are updated.",
      "ja": "クッキー・ペア（または「クラム」）を区切るために、クッキーヘッダフィールド[COOKIE]はセミコロン（「」）を使用します。このヘッダーフィールドは、別の名前と値のペアに分割されるのクッキー対を防止する、（[RFC7230]、セクション3.2.2を参照）HTTPにリスト構築規則に従いません。個々のクッキーペアが更新されているように、これは大幅に圧縮効率を減らすことができます。"
    },
    {
      "indent": 3,
      "text": "To allow for better compression efficiency, the Cookie header field MAY be split into separate header fields, each with one or more cookie-pairs. If there are multiple Cookie header fields after decompression, these MUST be concatenated into a single octet string using the two-octet delimiter of 0x3B, 0x20 (the ASCII string \"; \") before being passed into a non-HTTP/2 context, such as an HTTP/1.1 connection, or a generic HTTP server application.",
      "ja": "より良好な圧縮効率を可能にするために、Cookieヘッダフィールドは、別のヘッダフィールド、一つ以上のクッキー対とのそれぞれに分割することができます。解凍後の複数のCookieヘッダフィールドがある場合、これらは、0x3Bの2オクテットの区切り文字を使用して、単一のオクテット文字列に連結されなければならない、の0x20（ASCII文字列「;」）は、非HTTP / 2コンテキストに渡される前に、そのようなHTTP / 1.1接続、または一般的なHTTPサーバアプリケーションとして。"
    },
    {
      "indent": 3,
      "text": "Therefore, the following two lists of Cookie header fields are semantically equivalent.",
      "ja": "したがって、Cookieヘッダフィールドの次の二つのリストは、意味的に等価です。"
    },
    {
      "indent": 5,
      "text": "cookie: a=b; c=d; e=f",
      "ja": "クッキー：= B; C = D。 E = F"
    },
    {
      "indent": 5,
      "text": "cookie: a=b cookie: c=d cookie: e=f",
      "ja": "クッキー：= Bクッキー：C = Dクッキー：E = F"
    },
    {
      "indent": 0,
      "text": "8.1.2.6. Malformed Requests and Responses",
      "section_title": true,
      "ja": "8.1.2.6。不正なリクエストとレスポンス"
    },
    {
      "indent": 3,
      "text": "A malformed request or response is one that is an otherwise valid sequence of HTTP/2 frames but is invalid due to the presence of extraneous frames, prohibited header fields, the absence of mandatory header fields, or the inclusion of uppercase header field names.",
      "ja": "不正な要求または応答がHTTP / 2フレームのそうでなければ有効なシーケンスであるが、原因外来フレーム、禁止ヘッダフィールド、必須のヘッダーフィールドが存在しない、または大文字ヘッダフィールド名を含めるの存在のために無効であるものです。"
    },
    {
      "indent": 3,
      "text": "A request or response that includes a payload body can include a content-length header field. A request or response is also malformed if the value of a content-length header field does not equal the sum of the DATA frame payload lengths that form the body. A response that is defined to have no payload, as described in [RFC7230], Section 3.3.2, can have a non-zero content-length header field, even though no content is included in DATA frames.",
      "ja": "ペイロード本体を含む要求または応答は、Content-Lengthヘッダフィールドを含むことができます。 Content-Lengthヘッダフィールドの値は、ボディを形成するデータフレームペイロードの長さの和に等しくない場合、要求または応答も奇形です。 [RFC7230]に記載されているように、何のペイロードを持たないように定義される応答は、セクション3.3.2はないコンテンツは、データフレームに含まれていないにもかかわらず、非ゼロContent-Lengthヘッダフィールドを持つことができます。"
    },
    {
      "indent": 3,
      "text": "Intermediaries that process HTTP requests or responses (i.e., any intermediary not acting as a tunnel) MUST NOT forward a malformed request or response. Malformed requests or responses that are detected MUST be treated as a stream error (Section 5.4.2) of type PROTOCOL_ERROR.",
      "ja": "仲介プロセスのHTTP要求または応答（すなわち、任意の中間トンネルとして動作していない）は、不正なリクエストまたは応答を転送してはいけません。検出された不正な形式の要求または応答がタイプPROTOCOL_ERRORのストリームエラー（5.4.2項）として扱われなければなりません。"
    },
    {
      "indent": 3,
      "text": "For malformed requests, a server MAY send an HTTP response prior to closing or resetting the stream. Clients MUST NOT accept a malformed response. Note that these requirements are intended to protect against several types of common attacks against HTTP; they are deliberately strict because being permissive can expose implementations to these vulnerabilities.",
      "ja": "不正なリクエストのために、サーバは前のストリームを閉じたり、リセットにHTTPレスポンスを送信することができます。クライアントは、不正な形式の応答を受け入れてはいけません。これらの要件は、HTTPに対する一般的な攻撃のいくつかのタイプから保護することを意図していることに注意してください。寛容であることは、これらの脆弱性への実装を公開することができますので、彼らは意図的に厳しいです。"
    },
    {
      "indent": 0,
      "text": "8.1.3. Examples",
      "section_title": true,
      "ja": "8.1.3. 例"
    },
    {
      "indent": 3,
      "text": "This section shows HTTP/1.1 requests and responses, with illustrations of equivalent HTTP/2 requests and responses.",
      "ja": "このセクションでは、同等のHTTP / 2要求と応答のイラストとHTTP / 1.1リクエストとレスポンスを示しています。"
    },
    {
      "indent": 3,
      "text": "An HTTP GET request includes request header fields and no payload body and is therefore transmitted as a single HEADERS frame, followed by zero or more CONTINUATION frames containing the serialized block of request header fields. The HEADERS frame in the following has both the END_HEADERS and END_STREAM flags set; no CONTINUATION frames are sent.",
      "ja": "HTTP GETリクエストは、リクエストヘッダフィールド及びペイロードなし本体を含み、したがって、リクエストヘッダフィールドの直列ブロックを含むゼロ個以上の連続フレームに続く単一のヘッダフレームとして送信されます。以下のヘッダーフレームはEND_HEADERSとEND_STREAMフラグの両方が設定されています。何の継続フレームは送信されません。"
    },
    {
      "indent": 5,
      "text": "GET /resource HTTP/1.1 HEADERS Host: example.org ==> + END_STREAM Accept: image/jpeg + END_HEADERS :method = GET :scheme = https :path = /resource host = example.org accept = image/jpeg",
      "ja": "GET /リソースHTTP / 1.1ヘッダーホスト：example.org ==> + END_STREAM受け入れ：画像/ JPEG + END_HEADERS：方法= GET：スキーム= HTTPS：パス= /リソースホスト= example.org受け入れる=画像/ JPEG"
    },
    {
      "indent": 3,
      "text": "Similarly, a response that includes only response header fields is transmitted as a HEADERS frame (again, followed by zero or more CONTINUATION frames) containing the serialized block of response header fields.",
      "ja": "同様に、唯一の応答ヘッダフィールドを含む応答ヘッダーのフレームとして送信されるレスポンスヘッダフィールドの直列ブロックを含む（再び、ゼロまたはそれ以上の連続フレームが続きます）。"
    },
    {
      "indent": 5,
      "text": "HTTP/1.1 304 Not Modified HEADERS ETag: \"xyzzy\" ==> + END_STREAM Expires: Thu, 23 Jan ... + END_HEADERS :status = 304 etag = \"xyzzy\" expires = Thu, 23 Jan ...",
      "ja": "HTTP / 1.1 304はHEADERSのETagを変更していない： \"XYZZY\" ==> + END_STREAMが有効期限：木、1月23日には... + END_HEADERS：状態= 304のETag = \"XYZZYは\" =木、1月23日に期限が切れます..."
    },
    {
      "indent": 3,
      "text": "An HTTP POST request that includes request header fields and payload data is transmitted as one HEADERS frame, followed by zero or more CONTINUATION frames containing the request header fields, followed by one or more DATA frames, with the last CONTINUATION (or HEADERS) frame having the END_HEADERS flag set and the final DATA frame having the END_STREAM flag set:",
      "ja": "リクエストヘッダフィールド及びペイロードデータを含むHTTP POSTリクエストを有するゼロ以上の前回の続き（またはヘッダ）を有する1つの以上のデータフレームに続くリクエストヘッダフィールドを含む連続フレームフレームに続く一つヘッダフレームとして送信されます。 END_HEADERSフラグセットとEND_STREAMフラグセットを有する最終的なデータフレーム："
    },
    {
      "indent": 5,
      "text": "POST /resource HTTP/1.1 HEADERS Host: example.org ==> - END_STREAM Content-Type: image/jpeg - END_HEADERS Content-Length: 123 :method = POST :path = /resource {binary data} :scheme = https",
      "ja": "POST /リソースHTTP / 1.1ヘッダーホスト：example.org ==>  -  END_STREAMコンテンツタイプ：image / jpegの -  END_HEADERSのContent-Length：123：メソッド= POST：パス= /リソース{バイナリデータ}：スキーム= HTTPS"
    },
    {
      "indent": 38,
      "text": "CONTINUATION\n  + END_HEADERS\n    content-type = image/jpeg\n    host = example.org\n    content-length = 123",
      "raw": true
    },
    {
      "indent": 38,
      "text": "DATA + END_STREAM {binary data}",
      "ja": "DATA + END_STREAM {バイナリデータ}"
    },
    {
      "indent": 3,
      "text": "Note that data contributing to any given header field could be spread between header block fragments. The allocation of header fields to frames in this example is illustrative only.",
      "ja": "任意の所定のヘッダフィールドに貢献するデータは、ヘッダブロックの断片の間に広がることができることに留意されたいです。この例ではフレームのヘッダフィールドの割り当ては、単なる例示です。"
    },
    {
      "indent": 3,
      "text": "A response that includes header fields and payload data is transmitted as a HEADERS frame, followed by zero or more CONTINUATION frames, followed by one or more DATA frames, with the last DATA frame in the sequence having the END_STREAM flag set:",
      "ja": "END_STREAMフラグセットを有する配列内の最後のデータフレームと、一つ以上のデータフレームに続くゼロ以上の連続フレームに続くヘッダフレームとして送信されるヘッダフィールドとペイロードデータを含む応答："
    },
    {
      "indent": 5,
      "text": "HTTP/1.1 200 OK HEADERS Content-Type: image/jpeg ==> - END_STREAM Content-Length: 123 + END_HEADERS :status = 200 {binary data} content-type = image/jpeg content-length = 123",
      "ja": "HTTP / 1.1 200 OK HEADERSコンテンツタイプ：image / jpegの==>  -  END_STREAMのコンテンツ長：123 + END_HEADERS：ステータス= 200 {バイナリデータ}コンテンツタイプ=画像/ JPEGコンテンツ長= 123"
    },
    {
      "indent": 38,
      "text": "DATA\n  + END_STREAM\n{binary data}",
      "raw": true
    },
    {
      "indent": 3,
      "text": "An informational response using a 1xx status code other than 101 is transmitted as a HEADERS frame, followed by zero or more CONTINUATION frames.",
      "ja": "101以外の1xxステータスコードを使用して情報応答は、ゼロ個以上の連続フレームに続いて、ヘッダフレームとして送信されます。"
    },
    {
      "indent": 3,
      "text": "Trailing header fields are sent as a header block after both the request or response header block and all the DATA frames have been sent. The HEADERS frame starting the trailers header block has the END_STREAM flag set.",
      "ja": "後続ヘッダフィールドは、要求または応答のヘッダブロックの両方の後にヘッダブロックとして送信され、すべてのデータフレームが送信されてきました。トレーラーヘッダブロックを開始ヘッダフレームはEND_STREAMフラグが設定されています。"
    },
    {
      "indent": 3,
      "text": "The following example includes both a 100 (Continue) status code, which is sent in response to a request containing a \"100-continue\" token in the Expect header field, and trailing header fields:",
      "ja": "次の例では、期待ヘッダフィールドに「100続行」トークンを含むリクエストに応答して送信される100（続行）ステータスコードの両方を含み、ヘッダフィールド末尾。"
    },
    {
      "indent": 5,
      "text": "HTTP/1.1 100 Continue HEADERS Extension-Field: bar ==> - END_STREAM + END_HEADERS :status = 100 extension-field = bar",
      "ja": "HTTP / 1.1 100はHEADERS拡張-フィールドを続行：バー==>  -  END_STREAM + END_HEADERS：= 100拡張フィールド=バーのステータスを"
    },
    {
      "indent": 5,
      "text": "HTTP/1.1 200 OK HEADERS Content-Type: image/jpeg ==> - END_STREAM Transfer-Encoding: chunked + END_HEADERS Trailer: Foo :status = 200 content-length = 123 123 content-type = image/jpeg {binary data} trailer = Foo 0 Foo: bar DATA - END_STREAM {binary data}",
      "ja": "HTTP / 1.1 200 OK HEADERSコンテンツタイプ：image / jpegの==>  -  END_STREAM転送エンコード：チャンク+ END_HEADERSトレーラー：フー：ステータス= 200コンテンツ長= 123 123コンテンツタイプ=画像/ JPEG {バイナリデータ}トレーラー= 0はFooはFoo：バーDATA  -  END_STREAM {バイナリデータ}"
    },
    {
      "indent": 38,
      "text": "HEADERS\n  + END_STREAM\n  + END_HEADERS\n    foo = bar",
      "raw": true
    },
    {
      "indent": 0,
      "text": "8.1.4. Request Reliability Mechanisms in HTTP/2",
      "section_title": true,
      "ja": "8.1.4.  HTTP / 2で信頼性のメカニズムをリクエスト"
    },
    {
      "indent": 3,
      "text": "In HTTP/1.1, an HTTP client is unable to retry a non-idempotent request when an error occurs because there is no means to determine the nature of the error. It is possible that some server processing occurred prior to the error, which could result in undesirable effects if the request were reattempted.",
      "ja": "HTTP / 1.1では、HTTPクライアントは、エラーの性質を判断する手段がないため、エラーが発生した非冪等リクエストを再試行することができません。いくつかのサーバ処理要求が再試行された場合に望ましくない影響をもたらす可能性誤差、前に発生している可能性があります。"
    },
    {
      "indent": 3,
      "text": "HTTP/2 provides two mechanisms for providing a guarantee to a client that a request has not been processed:",
      "ja": "HTTP / 2は、リクエストが処理されていないことをクライアントに保証を提供するための2つのメカニズムを提供します。"
    },
    {
      "indent": 3,
      "text": "o The GOAWAY frame indicates the highest stream number that might have been processed. Requests on streams with higher numbers are therefore guaranteed to be safe to retry.",
      "ja": "O GOAWAYフレームが処理されている可能性があります最高のストリーム番号を示します。高い番号を持つストリーム上の要求は、したがって、再試行しても安全であることが保証されています。"
    },
    {
      "indent": 3,
      "text": "o The REFUSED_STREAM error code can be included in a RST_STREAM frame to indicate that the stream is being closed prior to any processing having occurred. Any request that was sent on the reset stream can be safely retried.",
      "ja": "O REFUSED_STREAMエラーコードは、ストリームは、任意の処理が発生した前に閉鎖されていることを示すためにRST_STREAMフレームに含めることができます。リセットストリームで送信されたすべての要求を安全に再試行することができます。"
    },
    {
      "indent": 3,
      "text": "Requests that have not been processed have not failed; clients MAY automatically retry them, even those with non-idempotent methods.",
      "ja": "処理されていない要求は失敗していません。クライアントが自動的にさえ、これらの非冪等の方法と、それらを再試行することができます。"
    },
    {
      "indent": 3,
      "text": "A server MUST NOT indicate that a stream has not been processed unless it can guarantee that fact. If frames that are on a stream are passed to the application layer for any stream, then REFUSED_STREAM MUST NOT be used for that stream, and a GOAWAY frame MUST include a stream identifier that is greater than or equal to the given stream identifier.",
      "ja": "サーバは、それがその事実を保証することができない限り、ストリームが処理されていないことを示してはいけません。ストリームにあるフレームは、任意のストリームのためのアプリケーション層に渡された場合、REFUSED_STREAMはそのストリームのために使用してはいけません、そしてGOAWAYフレームが指定されたストリーム識別子以上であるストリーム識別子を含まなければなりません。"
    },
    {
      "indent": 3,
      "text": "In addition to these mechanisms, the PING frame provides a way for a client to easily test a connection. Connections that remain idle can become broken as some middleboxes (for instance, network address translators or load balancers) silently discard connection bindings. The PING frame allows a client to safely test whether a connection is still active without sending a request.",
      "ja": "これらの機構に加えて、PINGフレームは、クライアントが簡単接続をテストするための方法を提供します。アイドル状態の接続がサイレント接続バインディングを破棄（例えば、ネットワークアドレス変換器または負荷バランサ）いくつかの中間装置破損になることができます。 PINGフレームは、クライアントが安全に接続要求を送信せずにまだアクティブであるかどうかをテストすることができます。"
    },
    {
      "indent": 0,
      "text": "8.2. Server Push",
      "section_title": true,
      "ja": "8.2. サーバープッシュ"
    },
    {
      "indent": 3,
      "text": "HTTP/2 allows a server to pre-emptively send (or \"push\") responses (along with corresponding \"promised\" requests) to a client in association with a previous client-initiated request. This can be useful when the server knows the client will need to have those responses available in order to fully process the response to the original request.",
      "ja": "HTTP / 2は、以前のクライアントが開始した要求に関連して、クライアントに（要求を「約束した」相当と一緒に）サーバがプリemptivelyする（または「プッシュ」）応答を送信することができます。サーバは、クライアントが完全に元の要求に対する応答を処理するために利用可能なものの応答を持っている必要があります知っている場合に便利です。"
    },
    {
      "indent": 3,
      "text": "A client can request that server push be disabled, though this is negotiated for each hop independently. The SETTINGS_ENABLE_PUSH setting can be set to 0 to indicate that server push is disabled.",
      "ja": "これは、それぞれ独立して、ホップのために交渉しているが、そのサーバープッシュを要求することができ、クライアントは、無効にすること。 SETTINGS_ENABLE_PUSH設定は、サーバープッシュが無効であることを示すために0に設定することができます。"
    },
    {
      "indent": 3,
      "text": "Promised requests MUST be cacheable (see [RFC7231], Section 4.2.3), MUST be safe (see [RFC7231], Section 4.2.1), and MUST NOT include a request body. Clients that receive a promised request that is not cacheable, that is not known to be safe, or that indicates the presence of a request body MUST reset the promised stream with a stream error (Section 5.4.2) of type PROTOCOL_ERROR. Note this could result in the promised stream being reset if the client does not recognize a newly defined method as being safe.",
      "ja": "約束の要求は（[RFC7231]、セクション4.2.1を参照）安全でなければならない、（[RFC7231]、セクション4.2.3を参照）キャッシュ可能でなければならない、とリクエストボディを含んではいけません。キャッシュ可能ではない約束要求を受信するクライアントは、それが安全であることが知られている、またはそれが型PROTOCOL_ERRORのストリームエラー（5.4.2項）と約束ストリームをリセットする必要があり、要求体の存在を示していません。クライアントが安全であるとして、新たに定義されたメソッドを認識しない場合、これはリセットされると約束したストリームにつながる可能性があります。"
    },
    {
      "indent": 3,
      "text": "Pushed responses that are cacheable (see [RFC7234], Section 3) can be stored by the client, if it implements an HTTP cache. Pushed responses are considered successfully validated on the origin server (e.g., if the \"no-cache\" cache response directive is present ([RFC7234], Section 5.2.2)) while the stream identified by the promised stream ID is still open.",
      "ja": "それはHTTPキャッシュを実装している場合、キャッシュ可能ですプッシュ応答は、（第3節、[RFC7234]を参照）、クライアントによって保存することができます。プッシュされた応答が正常にオリジンサーバで検証されると考えられる（例えば、「キャッシュなし」のキャッシュ応答ディレクティブが存在する場合（[RFC7234]、セクション5.2.2））約束したストリームIDによって識別されたストリームがまだ開いている間。"
    },
    {
      "indent": 3,
      "text": "Pushed responses that are not cacheable MUST NOT be stored by any HTTP cache. They MAY be made available to the application separately.",
      "ja": "キャッシュ可能ではありませんプッシュされた応答は、任意のHTTPキャッシュによって保存されてはなりません。彼らは、別途アプリケーションに利用できるようにすることができます。"
    },
    {
      "indent": 3,
      "text": "The server MUST include a value in the \":authority\" pseudo-header field for which the server is authoritative (see Section 10.1). A client MUST treat a PUSH_PROMISE for which the server is not authoritative as a stream error (Section 5.4.2) of type PROTOCOL_ERROR.",
      "ja": "（セクション10.1を参照）サーバが信頼されている：「権限」疑似ヘッダフィールドサーバは、の値を含まなければなりません。クライアントは、サーバがタイプPROTOCOL_ERRORのストリームエラー（5.4.2項）として権威されていないPUSH_PROMISEを扱わなければなりません。"
    },
    {
      "indent": 3,
      "text": "An intermediary can receive pushes from the server and choose not to forward them on to the client. In other words, how to make use of the pushed information is up to that intermediary. Equally, the intermediary might choose to make additional pushes to the client, without any action taken by the server.",
      "ja": "仲介者は、サーバーからのプッシュを受信して​​、クライアントにそれらを転送しないように選択することができます。言い換えれば、どのようにプッシュされた情報を利用するようにすると、その仲介者に任されています。同様に、仲介サーバによって取られた行動せずに、クライアントに追加のプッシュを作ることもできます。"
    },
    {
      "indent": 3,
      "text": "A client cannot push. Thus, servers MUST treat the receipt of a PUSH_PROMISE frame as a connection error (Section 5.4.1) of type PROTOCOL_ERROR. Clients MUST reject any attempt to change the SETTINGS_ENABLE_PUSH setting to a value other than 0 by treating the message as a connection error (Section 5.4.1) of type PROTOCOL_ERROR.",
      "ja": "クライアントは、プッシュすることはできません。したがって、サーバは、タイプPROTOCOL_ERRORの接続エラー（5.4.1）としてPUSH_PROMISEフレームの受信を処理しなければなりません。クライアントは、タイプPROTOCOL_ERRORの接続エラー（セクション5.4.1）のようにメッセージを処理することにより、0以外の値にSETTINGS_ENABLE_PUSH設定を変更しようとする試みを拒絶しなければなりません。"
    },
    {
      "indent": 0,
      "text": "8.2.1. Push Requests",
      "section_title": true,
      "ja": "8.2.1.  Push要求"
    },
    {
      "indent": 3,
      "text": "Server push is semantically equivalent to a server responding to a request; however, in this case, that request is also sent by the server, as a PUSH_PROMISE frame.",
      "ja": "サーバープッシュが要求に応答するサーバーと同じ意味です。ただし、この場合には、その要求もPUSH_PROMISEフレームとして、サーバによって送信されます。"
    },
    {
      "indent": 3,
      "text": "The PUSH_PROMISE frame includes a header block that contains a complete set of request header fields that the server attributes to the request. It is not possible to push a response to a request that includes a request body.",
      "ja": "PUSH_PROMISEフレームは、サーバが要求に属性をリクエストヘッダフィールドの完全なセットを含むヘッダブロックを含みます。リクエスト本体を含む要求に対する応答をプッシュすることはできません。"
    },
    {
      "indent": 3,
      "text": "Pushed responses are always associated with an explicit request from the client. The PUSH_PROMISE frames sent by the server are sent on that explicit request's stream. The PUSH_PROMISE frame also includes a promised stream identifier, chosen from the stream identifiers available to the server (see Section 5.1.1).",
      "ja": "プッシュ応答は常にクライアントからの明示的な要求と関連しています。サーバーから送信されたPUSH_PROMISEフレームはその明示的な要求のストリームに送信されます。 PUSH_PROMISEフレームは、サーバで使用可能なストリーム識別子から選択された約束ストリーム識別子を含む（セクション5.1.1を参照）。"
    },
    {
      "indent": 3,
      "text": "The header fields in PUSH_PROMISE and any subsequent CONTINUATION frames MUST be a valid and complete set of request header fields (Section 8.1.2.3). The server MUST include a method in the \":method\" pseudo-header field that is safe and cacheable. If a client receives a PUSH_PROMISE that does not include a complete and valid set of header fields or the \":method\" pseudo-header field identifies a method that is not safe, it MUST respond with a stream error (Section 5.4.2) of type PROTOCOL_ERROR.",
      "ja": "PUSH_PROMISEおよびその後連続フレームのヘッダフィールドは、リクエストヘッダフィールド（セクション8.1.2.3）の有効かつ完全に設定されなければなりません。安全かつキャッシュ可能である：「方法」疑似ヘッダフィールドサーバは、メソッドを含まなければなりません。クライアントはヘッダフィールドの完全かつ有効なセットや含まれていないPUSH_PROMISE受信した場合「：メソッドを」疑似ヘッダーフィールドは安全ではない方法を特定し、それがストリームエラー（5.4.2項）ので応じなければなりませんPROTOCOL_ERRORを入力します。"
    },
    {
      "indent": 3,
      "text": "The server SHOULD send PUSH_PROMISE (Section 6.6) frames prior to sending any frames that reference the promised responses. This avoids a race where clients issue requests prior to receiving any PUSH_PROMISE frames.",
      "ja": "サーバはPUSH_PROMISE（6.6節）が約束した回答を参照するすべてのフレームを送信する前にフレームを送るべきです。これは、クライアントの問題はどのPUSH_PROMISEフレームを受信する前に要求したレースを回避することができます。"
    },
    {
      "indent": 3,
      "text": "For example, if the server receives a request for a document containing embedded links to multiple image files and the server chooses to push those additional images to the client, sending PUSH_PROMISE frames before the DATA frames that contain the image links ensures that the client is able to see that a resource will be pushed before discovering embedded links. Similarly, if the server pushes responses referenced by the header block (for instance, in Link header fields), sending a PUSH_PROMISE before sending the header block ensures that clients do not request those resources.",
      "ja": "例えば、サーバは、複数の画像ファイルに埋め込まれたリンクを含む文書に対する要求を受け取ると、サーバはクライアントにこれらの追加画像をプッシュすることを選択し、画像へのリンクが含まれているデータフレームは、クライアントが可能であることを保証する前にPUSH_PROMISEフレームを送信した場合リソースが埋め込まれたリンクを発見する前にプッシュされることを確認します。サーバは、（例えば、リンクヘッダフィールドにおける）ヘッダブロックによって参照される応答を押すと同様に、ヘッダブロックを送信する前にPUSH_PROMISEを送信するクライアントは、それらのリソースを要求しないことを保証します。"
    },
    {
      "indent": 3,
      "text": "PUSH_PROMISE frames MUST NOT be sent by the client.",
      "ja": "PUSH_PROMISEフレームは、クライアントから送信されてはなりません。"
    },
    {
      "indent": 3,
      "text": "PUSH_PROMISE frames can be sent by the server in response to any client-initiated stream, but the stream MUST be in either the \"open\" or \"half-closed (remote)\" state with respect to the server. PUSH_PROMISE frames are interspersed with the frames that comprise a response, though they cannot be interspersed with HEADERS and CONTINUATION frames that comprise a single header block.",
      "ja": "PUSH_PROMISEフレームは、任意のクライアントが開始したストリームに応じてサーバによって送信することができますが、ストリームは、サーバーに関して「オープン」または「半分閉じた（リモート）」状態のいずれかでなければなりません。 PUSH_PROMISEフレームは、それらが単一のヘッダブロックを含むヘッダと継続フレームが散在することができないが、応答を含むフレームが散在しています。"
    },
    {
      "indent": 3,
      "text": "Sending a PUSH_PROMISE frame creates a new stream and puts the stream into the \"reserved (local)\" state for the server and the \"reserved (remote)\" state for the client.",
      "ja": "PUSH_PROMISEフレームを送信すると、新しいストリームを作成し、サーバーの「予約（ローカル）」の状態とクライアントのための「予約済み（リモート）」状態にストリームを置きます。"
    },
    {
      "indent": 0,
      "text": "8.2.2. Push Responses",
      "section_title": true,
      "ja": "8.2.2. プッシュ応答"
    },
    {
      "indent": 3,
      "text": "After sending the PUSH_PROMISE frame, the server can begin delivering the pushed response as a response (Section 8.1.2.4) on a server-initiated stream that uses the promised stream identifier. The server uses this stream to transmit an HTTP response, using the same sequence of frames as defined in Section 8.1. This stream becomes \"half-closed\" to the client (Section 5.1) after the initial HEADERS frame is sent.",
      "ja": "PUSH_PROMISEフレームを送信した後、サーバは、約束ストリーム識別子を使用してサーバ起動ストリーム上の応答（セクション8.1.2.4）としてプッシュ応答の配信を開始することができます。サーバは、セクション8.1で定義されるようにフレームの同じシーケンスを使用して、HTTP応答を送信するために、このストリームを使用します。初期HEADERSフレームが送信された後、このストリームは、クライアント（5.1節）に「半閉」になります。"
    },
    {
      "indent": 3,
      "text": "Once a client receives a PUSH_PROMISE frame and chooses to accept the pushed response, the client SHOULD NOT issue any requests for the promised response until after the promised stream has closed.",
      "ja": "クライアントがPUSH_PROMISEフレームを受信して​​、プッシュ応答を受け入れることを選択したら、クライアントは約束したストリームが閉じられた後まで約束した応答のためのすべての要求を発行するべきではありません。"
    },
    {
      "indent": 3,
      "text": "If the client determines, for any reason, that it does not wish to receive the pushed response from the server or if the server takes too long to begin sending the promised response, the client can send a RST_STREAM frame, using either the CANCEL or REFUSED_STREAM code and referencing the pushed stream's identifier.",
      "ja": "クライアントが判断した場合は、何らかの理由で、それはどちらかキャンセルするかREFUSED_STREAM使用して、サーバからのプッシュ応答を受信するためにサーバーが約束応答の送信を開始するために時間がかかりすぎる場合や、クライアントがRST_STREAMフレームを送信することができます希望していないことコードとプッシュストリームの識別子を参照します。"
    },
    {
      "indent": 3,
      "text": "A client can use the SETTINGS_MAX_CONCURRENT_STREAMS setting to limit the number of responses that can be concurrently pushed by a server. Advertising a SETTINGS_MAX_CONCURRENT_STREAMS value of zero disables server push by preventing the server from creating the necessary streams. This does not prohibit a server from sending PUSH_PROMISE frames; clients need to reset any promised streams that are not wanted.",
      "ja": "クライアントが同時にサーバーでプッシュすることができます応答の数を制限する設定SETTINGS_MAX_CONCURRENT_STREAMSを使用することができます。ゼロのSETTINGS_MAX_CONCURRENT_STREAMS値をアドバタイズする必要ストリームを作成からサーバーを防止することにより、サーバプッシュを無効にします。これはPUSH_PROMISEフレームを送信してからサーバーを禁止していません。クライアントが望んでいたされていない任意の約束したストリームをリセットする必要があります。"
    },
    {
      "indent": 3,
      "text": "Clients receiving a pushed response MUST validate that either the server is authoritative (see Section 10.1) or the proxy that provided the pushed response is configured for the corresponding request. For example, a server that offers a certificate for only the \"example.com\" DNS-ID or Common Name is not permitted to push a response for \"https://www.example.org/doc\".",
      "ja": "プッシュ応答を受信したクライアントは、サーバが権限のある（セクション10.1を参照）またはプッシュ応答を提供プロキシが対応する要求のために設定されているいずれかのことを検証しなければなりません。たとえば、唯一の「example.com」DNS-IDまたは共通名の証明書を提供するサーバーは、「https://www.example.org/doc」の応答をプッシュするために許可されていません。"
    },
    {
      "indent": 3,
      "text": "The response for a PUSH_PROMISE stream begins with a HEADERS frame, which immediately puts the stream into the \"half-closed (remote)\" state for the server and \"half-closed (local)\" state for the client, and ends with a frame bearing END_STREAM, which places the stream in the \"closed\" state.",
      "ja": "PUSH_PROMISEストリームに対する応答が直ちにクライアントに対してサーバの「半閉（リモート）」状態と「半分閉じた（ローカル）」状態にストリームを置くヘッダフレームで始まり、そしてフレームで終了します「閉」の状態にストリームを配置END_STREAMを、ベアリング。"
    },
    {
      "indent": 6,
      "text": "Note: The client never sends a frame with the END_STREAM flag for a server push.",
      "ja": "注意：クライアントは、サーバープッシュのためのEND_STREAMフラグでフレームを送信することはありません。"
    },
    {
      "indent": 0,
      "text": "8.3. The CONNECT Method",
      "section_title": true,
      "ja": "8.3.  CONNECTメソッド"
    },
    {
      "indent": 3,
      "text": "In HTTP/1.x, the pseudo-method CONNECT ([RFC7231], Section 4.3.6) is used to convert an HTTP connection into a tunnel to a remote host. CONNECT is primarily used with HTTP proxies to establish a TLS session with an origin server for the purposes of interacting with \"https\" resources.",
      "ja": "HTTP / 1.1において、擬似方法CONNECT（[RFC7231]、セクション4.3.6）は、リモートホストへのトンネルへのHTTP接続を変換するために使用されます。 CONNECTは、主に「https」のリソースとの相互作用の目的のためにオリジンサーバとのTLSセッションを確立するためにHTTPプロキシで使用されています。"
    },
    {
      "indent": 3,
      "text": "In HTTP/2, the CONNECT method is used to establish a tunnel over a single HTTP/2 stream to a remote host for similar purposes. The HTTP header field mapping works as defined in Section 8.1.2.3 (\"Request Pseudo-Header Fields\"), with a few differences. Specifically:",
      "ja": "HTTP / 2において、CONNECTメソッドは、同様の目的のためにリモート・ホストに単一のHTTP / 2ストリーム上にトンネルを確立するために使用されます。いくつかの違いと、セクション8.1.2.3（「リクエスト擬似ヘッダフィールド」）で定義されるようにHTTPヘッダフィールドのマッピングが働きます。具体的に："
    },
    {
      "indent": 3,
      "text": "o The \":method\" pseudo-header field is set to \"CONNECT\".",
      "ja": "O「：メソッド」擬似ヘッダフィールドは、「CONNECT」に設定されています。"
    },
    {
      "indent": 3,
      "text": "o The \":scheme\" and \":path\" pseudo-header fields MUST be omitted.",
      "ja": "○「：スキーム」と「パス」疑似ヘッダフィールドを省略しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o The \":authority\" pseudo-header field contains the host and port to connect to (equivalent to the authority-form of the request-target of CONNECT requests (see [RFC7230], Section 5.3)).",
      "ja": "O「：権限」疑似ヘッダフィールド（（[RFC7230]、セクション5.3）を参照CONNECT要求の要求対象の権限型に相当）に接続するためのホストとポートを含んでいます。"
    },
    {
      "indent": 3,
      "text": "A CONNECT request that does not conform to these restrictions is malformed (Section 8.1.2.6).",
      "ja": "これらの制限に適合していないCONNECT要求が（セクション8.1.2.6）奇形れます。"
    },
    {
      "indent": 3,
      "text": "A proxy that supports CONNECT establishes a TCP connection [TCP] to the server identified in the \":authority\" pseudo-header field. Once this connection is successfully established, the proxy sends a HEADERS frame containing a 2xx series status code to the client, as defined in [RFC7231], Section 4.3.6.",
      "ja": "「権限」疑似ヘッダフィールドCONNECTをサポートするプロキシがで識別されたサーバへのTCP接続の[TCP]を確立します。この接続が正常に確立されると、プロキシは[RFC7231]で定義されるように、クライアントへの2xxシリーズのステータスコードを含むヘッダフレームを送信セクション4.3.6。"
    },
    {
      "indent": 3,
      "text": "After the initial HEADERS frame sent by each peer, all subsequent DATA frames correspond to data sent on the TCP connection. The payload of any DATA frames sent by the client is transmitted by the proxy to the TCP server; data received from the TCP server is assembled into DATA frames by the proxy. Frame types other than DATA or stream management frames (RST_STREAM, WINDOW_UPDATE, and PRIORITY) MUST NOT be sent on a connected stream and MUST be treated as a stream error (Section 5.4.2) if received.",
      "ja": "各ピアによって送信された最初のヘッダフレームの後に、すべての後続のデータフレームは、TCP接続上で送信されるデータに対応します。クライアントから送信されたデータフレームのペイロードは、TCPサーバーへのプロキシによって送信されます。 TCPサーバから受信したデータは、プロキシによるデータフレームに組み立てられます。 DATAまたはストリーム管理フレーム（RST_STREAM、WINDOW_UPDATE、優先度）以外のフレームタイプは、接続されたストリーム上で送信してはいけませんし、受信したストリームエラー（5.4.2項）として扱われなければなりません。"
    },
    {
      "indent": 3,
      "text": "The TCP connection can be closed by either peer. The END_STREAM flag on a DATA frame is treated as being equivalent to the TCP FIN bit. A client is expected to send a DATA frame with the END_STREAM flag set after receiving a frame bearing the END_STREAM flag. A proxy that receives a DATA frame with the END_STREAM flag set sends the attached data with the FIN bit set on the last TCP segment. A proxy that receives a TCP segment with the FIN bit set sends a DATA frame with the END_STREAM flag set. Note that the final TCP segment or DATA frame could be empty.",
      "ja": "TCP接続は、どちらかのピアによって閉じることができます。 DATAフレーム上END_STREAMフラグがTCP FINビットに相当するものとして扱われます。クライアントはEND_STREAMフラグを担持するフレームを受信した後END_STREAMフラグが設定されたデータフレームを送信することが期待されます。 END_STREAMフラグを設定してデータフレームを受信したプロキシは、最後のTCPセグメントに設定されたFINビットを取り付けたデータを送信します。 FINビットが設定されたTCPセグメントを受信したプロキシがEND_STREAMフラグが設定されたデータフレームを送信します。最終的なTCPセグメントまたはデータフレームが空であることに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "A TCP connection error is signaled with RST_STREAM. A proxy treats any error in the TCP connection, which includes receiving a TCP segment with the RST bit set, as a stream error (Section 5.4.2) of type CONNECT_ERROR. Correspondingly, a proxy MUST send a TCP segment with the RST bit set if it detects an error with the stream or the HTTP/2 connection.",
      "ja": "TCP接続エラーがRST_STREAMで通知されます。プロキシは、タイプCONNECT_ERRORのストリームエラー（5.4.2項）として、RSTビットが設定されたTCPセグメントを受信することを含むTCP接続、任意のエラーを処理します。それはストリームまたはHTTP / 2接続でエラーを検出した場合RSTビットセットとそれに対応して、プロキシは、TCPセグメントを送信しなければなりません。"
    },
    {
      "indent": 0,
      "text": "9. Additional HTTP Requirements/Considerations",
      "section_title": true,
      "ja": "9.追加のHTTP要件/考慮事項"
    },
    {
      "indent": 3,
      "text": "This section outlines attributes of the HTTP protocol that improve interoperability, reduce exposure to known security vulnerabilities, or reduce the potential for implementation variation.",
      "ja": "このセクションでは、相互運用性を向上させるHTTPプロトコルの属性を概説し、既知のセキュリティの脆弱性への露出を減らす、または実装の変化の可能性を減らします。"
    },
    {
      "indent": 0,
      "text": "9.1. Connection Management",
      "section_title": true,
      "ja": "9.1. 接続管理"
    },
    {
      "indent": 3,
      "text": "HTTP/2 connections are persistent. For best performance, it is expected that clients will not close connections until it is determined that no further communication with a server is necessary (for example, when a user navigates away from a particular web page) or until the server closes the connection.",
      "ja": "HTTP / 2接続が永続的です。最高のパフォーマンスを得るために、それはサーバーとのこれ以上の通信は必要ないと判断されるまで（ユーザーが特定のWebページから移動例えば、場合）またはサーバーが接続を閉じるまで、クライアントはないでしょう近い接続することを期待されています。"
    },
    {
      "indent": 3,
      "text": "Clients SHOULD NOT open more than one HTTP/2 connection to a given host and port pair, where the host is derived from a URI, a selected alternative service [ALT-SVC], or a configured proxy.",
      "ja": "クライアントは、ホストがURI、選択された代替サービス[ALT-SVC]、または設定されたプロキシから誘導される特定のホストとポートのペアに複数のHTTP / 2接続を開くべきではありません。"
    },
    {
      "indent": 3,
      "text": "A client can create additional connections as replacements, either to replace connections that are near to exhausting the available stream identifier space (Section 5.1.1), to refresh the keying material for a TLS connection, or to replace connections that have encountered errors (Section 5.4.1).",
      "ja": "クライアントは、代替品として追加の接続を作成することができ、どちらか（TLS接続用の鍵素材をリフレッシュするために、またはエラーが発生した接続を置き換えるために、（セクション5.1.1）可能なストリーム識別子空間を排気に近いセクションです接続を交換します5.4.1）。"
    },
    {
      "indent": 3,
      "text": "A client MAY open multiple connections to the same IP address and TCP port using different Server Name Indication [TLS-EXT] values or to provide different TLS client certificates but SHOULD avoid creating multiple connections with the same configuration.",
      "ja": "クライアントは異なるサーバ名表示[TLS-EXT]の値を使用して、同じIPアドレスとTCPポートへの複数の接続を開くことができ、または異なるTLSクライアント証明書を提供するために、同じ構成で複数の接続を作成することは避けてください。"
    },
    {
      "indent": 3,
      "text": "Servers are encouraged to maintain open connections for as long as possible but are permitted to terminate idle connections if necessary. When either endpoint chooses to close the transport-layer TCP connection, the terminating endpoint SHOULD first send a GOAWAY (Section 6.8) frame so that both endpoints can reliably determine whether previously sent frames have been processed and gracefully complete or terminate any necessary remaining tasks.",
      "ja": "サーバーはできるだけ長くのためのオープン接続を維持することが推奨されるが、必要に応じてアイドル状態の接続を終了することが許可されています。エンドポイントのいずれかがトランスポート層のTCP接続を閉じることを選択した場合、両方のエンドポイントが確実に以前のフレームが処理されて送信され、正常に完了したか否かを判断又は必要な残りのタスクを終了することができるように、終端エンドポイントは、最初GOAWAY（セクション6.8）フレームを送信すべきです。"
    },
    {
      "indent": 0,
      "text": "9.1.1. Connection Reuse",
      "section_title": true,
      "ja": "9.1.1. 接続の再利用"
    },
    {
      "indent": 3,
      "text": "Connections that are made to an origin server, either directly or through a tunnel created using the CONNECT method (Section 8.3), MAY be reused for requests with multiple different URI authority components. A connection can be reused as long as the origin server is authoritative (Section 10.1). For TCP connections without TLS, this depends on the host having resolved to the same IP address.",
      "ja": "直接またはCONNECTメソッド（セクション8.3）を使用して作成されたトンネルを介して、オリジンサーバに対して行われる接続は、複数の異なるURIの権限コンポーネントと要求に対して再利用することができます。接続があればオリジンサーバ（セクション10.1）権限があるとして再利用することができます。 TLSなしのTCP接続の場合、これは、同じIPアドレスに解決したホストに依存します。"
    },
    {
      "indent": 3,
      "text": "For \"https\" resources, connection reuse additionally depends on having a certificate that is valid for the host in the URI. The certificate presented by the server MUST satisfy any checks that the client would perform when forming a new TLS connection for the host in the URI.",
      "ja": "「https」のリソースについては、接続の再利用は、さらにURI内のホストのための有効な証明書を持つに依存します。サーバーによって提示された証明書は、URI内のホストのための新たなTLS接続を形成する際に、クライアントが実行する任意のチェックを満たしている必要があります。"
    },
    {
      "indent": 3,
      "text": "An origin server might offer a certificate with multiple \"subjectAltName\" attributes or names with wildcards, one of which is valid for the authority in the URI. For example, a certificate with a \"subjectAltName\" of \"*.example.com\" might permit the use of the same connection for requests to URIs starting with \"https://a.example.com/\" and \"https://b.example.com/\".",
      "ja": "オリジンサーバは複数で証明書を提供するかもしれない「のsubjectAltNameは、」URIにおける権威のために有効な一つは、ワイルドカードを持つ属性または名前。たとえば、「* .example.comと」の「のsubjectAltName」との証明書は、「https://a.example.com/」と「httpsで始まるURIへの要求に同じ接続を使用することを許可するかもしれません：// b.example.com/」。"
    },
    {
      "indent": 3,
      "text": "In some deployments, reusing a connection for multiple origins can result in requests being directed to the wrong origin server. For example, TLS termination might be performed by a middlebox that uses the TLS Server Name Indication (SNI) [TLS-EXT] extension to select an origin server. This means that it is possible for clients to send confidential information to servers that might not be the intended target for the request, even though the server is otherwise authoritative.",
      "ja": "いくつかの展開では、複数の起源のための接続を再利用することは間違っているオリジンサーバに向けられているの要求につながることができます。例えば、TLS終端は、オリジンサーバを選択するためにTLSサーバー名表示（SNI）[TLS-EXT]拡張を使用するミドルボックスによって実行されるかもしれません。これは、クライアントがサーバがそれ以外の権威であっても、要求のために意図対象にならない可能性のあるサーバへの機密情報を送信することが可能であることを意味します。"
    },
    {
      "indent": 3,
      "text": "A server that does not wish clients to reuse connections can indicate that it is not authoritative for a request by sending a 421 (Misdirected Request) status code in response to the request (see Section 9.1.2).",
      "ja": "接続を再利用するようにクライアントを希望していないサーバは、要求（9.1.2項を参照）に応じて、421（間違った方向への要求）ステータスコードを送信することにより、要求に対して権限を持たないことを示すことができます。"
    },
    {
      "indent": 3,
      "text": "A client that is configured to use a proxy over HTTP/2 directs requests to that proxy through a single connection. That is, all requests sent via a proxy reuse the connection to the proxy.",
      "ja": "HTTP / 2上にプロキシを使用するように構成されているクライアントは、単一の接続を介してそのプロキシに要求を向けます。これは、プロキシへの接続を再利用し、プロキシを経由して送信されたすべての要求です。"
    },
    {
      "indent": 0,
      "text": "9.1.2. The 421 (Misdirected Request) Status Code",
      "section_title": true,
      "ja": "9.1.2.  421（間違った方向への要求）ステータスコード"
    },
    {
      "indent": 3,
      "text": "The 421 (Misdirected Request) status code indicates that the request was directed at a server that is not able to produce a response. This can be sent by a server that is not configured to produce responses for the combination of scheme and authority that are included in the request URI.",
      "ja": "421（間違った方向への要求）ステータスコードは、要求が応答を生成することができないサーバに向けられたことを示しています。これは、リクエストURIに含まれているスキームと権限の組み合わせのための応答を生成するように構成されていないサーバによって送信することができます。"
    },
    {
      "indent": 3,
      "text": "Clients receiving a 421 (Misdirected Request) response from a server MAY retry the request -- whether the request method is idempotent or not -- over a different connection. This is possible if a connection is reused (Section 9.1.1) or if an alternative service is selected [ALT-SVC].",
      "ja": "サーバーから421（間違った方向への要求）応答を受信したクライアントは、要求を再試行することができる - 要求メソッドは冪等であるかどうか - 異なる接続を介し。 [ALT-SVC]接続が再利用された場合（9.1.1項）、または代替サービスが選択されている場合、これは可能です。"
    },
    {
      "indent": 3,
      "text": "This status code MUST NOT be generated by proxies.",
      "ja": "このステータスコードは、プロキシによって生成されてはなりません。"
    },
    {
      "indent": 3,
      "text": "A 421 response is cacheable by default, i.e., unless otherwise indicated by the method definition or explicit cache controls (see Section 4.2.2 of [RFC7234]).",
      "ja": "そうでなければ、メソッド定義または明示的なキャッシュコントロール（[RFC7234]のセクション4.2.2を参照）で示さない限り、421応答は、すなわち、デフォルトでキャッシュ可能です。"
    },
    {
      "indent": 0,
      "text": "9.2. Use of TLS Features",
      "section_title": true,
      "ja": "9.2.  TLSの機能の使用"
    },
    {
      "indent": 3,
      "text": "Implementations of HTTP/2 MUST use TLS version 1.2 [TLS12] or higher for HTTP/2 over TLS. The general TLS usage guidance in [TLSBCP] SHOULD be followed, with some additional restrictions that are specific to HTTP/2.",
      "ja": "HTTP / 2の実装は、TLS上HTTP / 2 TLSバージョン1.2 [TLS12]以上を使用しなければなりません。 【TLSBCP]一般TLSの使用ガイダンスはHTTP / 2に特異的であり、いくつかの追加の制約が、続いされるべきです。"
    },
    {
      "indent": 3,
      "text": "The TLS implementation MUST support the Server Name Indication (SNI) [TLS-EXT] extension to TLS. HTTP/2 clients MUST indicate the target domain name when negotiating TLS.",
      "ja": "TLSの実装は、TLSのサーバ名表示（SNI）[TLS-EXT]拡張をサポートしなければなりません。 TLSをネゴシエートするときにHTTP / 2クライアントがターゲットドメイン名を指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Deployments of HTTP/2 that negotiate TLS 1.3 or higher need only support and use the SNI extension; deployments of TLS 1.2 are subject to the requirements in the following sections. Implementations are encouraged to provide defaults that comply, but it is recognized that deployments are ultimately responsible for compliance.",
      "ja": "のみSNI拡張をサポートして使用するTLS 1.3以上必要性を交渉するHTTP / 2の配備。 TLS 1.2の展開では、次のセクションの要件の対象となっています。実装は遵守デフォルトを提供することが奨励されていますが、展開は、コンプライアンスのための最終的な責任であると認識されています。"
    },
    {
      "indent": 0,
      "text": "9.2.1. TLS 1.2 Features",
      "section_title": true,
      "ja": "9.2.1.  TLS 1.2特長"
    },
    {
      "indent": 3,
      "text": "This section describes restrictions on the TLS 1.2 feature set that can be used with HTTP/2. Due to deployment limitations, it might not be possible to fail TLS negotiation when these restrictions are not met. An endpoint MAY immediately terminate an HTTP/2 connection that does not meet these TLS requirements with a connection error (Section 5.4.1) of type INADEQUATE_SECURITY.",
      "ja": "このセクションでは、HTTP / 2で使用することができTLS 1.2機能セットの制限を説明しています。展開制限による、これらの制限を満たしていないとき、TLSネゴシエーションに失敗することはできないかもしれません。エンドポイントは、すぐに型INADEQUATE_SECURITYの接続エラー（5.4.1）でこれらのTLSの要件を満たしていないHTTP / 2接続を終了することができます。"
    },
    {
      "indent": 3,
      "text": "A deployment of HTTP/2 over TLS 1.2 MUST disable compression. TLS compression can lead to the exposure of information that would not otherwise be revealed [RFC3749]. Generic compression is unnecessary since HTTP/2 provides compression features that are more aware of context and therefore likely to be more appropriate for use for performance, security, or other reasons.",
      "ja": "TLS 1.2を超えるHTTP / 2の展開は、圧縮を無効にする必要があります。 TLS圧縮は、そうでなければ、[RFC3749]を明らかにされないであろう情報の露出をもたらすことができます。 HTTP / 2がよりコンテキストを認識し、したがって、性能、セキュリティ、または他の理由のために使用するのがより適切である可能性が高い圧縮機能を提供するので、一般的な圧縮は不要です。"
    },
    {
      "indent": 3,
      "text": "A deployment of HTTP/2 over TLS 1.2 MUST disable renegotiation. An endpoint MUST treat a TLS renegotiation as a connection error (Section 5.4.1) of type PROTOCOL_ERROR. Note that disabling",
      "ja": "TLS 1.2を超えるHTTP / 2の展開は、再ネゴシエーションを無効にする必要があります。エンドポイントは、タイプPROTOCOL_ERRORの接続エラー（5.4.1項）としてTLS再ネゴシエーションを扱わなければなりません。無効にすることに注意してください"
    },
    {
      "indent": 3,
      "text": "renegotiation can result in long-lived connections becoming unusable due to limits on the number of messages the underlying cipher suite can encipher.",
      "ja": "再交渉が原因根底にある暗号スイートを暗号化することができますメッセージの数の制限に使用できなくなってきて長寿命の接続をもたらす可能性があります。"
    },
    {
      "indent": 3,
      "text": "An endpoint MAY use renegotiation to provide confidentiality protection for client credentials offered in the handshake, but any renegotiation MUST occur prior to sending the connection preface. A server SHOULD request a client certificate if it sees a renegotiation request immediately after establishing a connection.",
      "ja": "エンドポイントは、ハンドシェイクで提供されるクライアント資格情報の機密保護を提供するために再交渉を使用することができるが、任意の再ネゴシエーションは、接続序文を送信する前に行う必要があります。それはすぐに接続を確立した後、再交渉要求を見れば、サーバーは、クライアント証明書を要求する必要があります。"
    },
    {
      "indent": 3,
      "text": "This effectively prevents the use of renegotiation in response to a request for a specific protected resource. A future specification might provide a way to support this use case. Alternatively, a server might use an error (Section 5.4) of type HTTP_1_1_REQUIRED to request the client use a protocol that supports renegotiation.",
      "ja": "これは、効果的に、特定の保護されたリソースの要求に応じて、再ネゴシエーションの使用を防止します。将来の仕様では、このユースケースをサポートするための方法を提供するかもしれません。また、サーバは、クライアントが再ネゴシエーションをサポートしているプロトコルを使用する要求するタイプHTTP_1_1_REQUIREDの誤差（5.4節）を使用する場合があります。"
    },
    {
      "indent": 3,
      "text": "Implementations MUST support ephemeral key exchange sizes of at least 2048 bits for cipher suites that use ephemeral finite field Diffie-Hellman (DHE) [TLS12] and 224 bits for cipher suites that use ephemeral elliptic curve Diffie-Hellman (ECDHE) [RFC4492]. Clients MUST accept DHE sizes of up to 4096 bits. Endpoints MAY treat negotiation of key sizes smaller than the lower limits as a connection error (Section 5.4.1) of type INADEQUATE_SECURITY.",
      "ja": "実装は、はかない有限ディフィー・ヘルマン（DHE）を使用する暗号スイートのための少なくとも2048ビット[TLS12]とエフェメラル楕円曲線ディフィ - ヘルマン（ECDHE）[RFC4492]を使用する暗号スイートのための224ビットの短期キー交換サイズをサポートしなければなりません。クライアントは最大4096ビットのDHEサイズを受け入れなければなりません。エンドポイントは、タイプINADEQUATE_SECURITYの接続エラー（5.4.1）のように下限値よりも小さいキーのサイズの交渉を扱うかもしれ。"
    },
    {
      "indent": 0,
      "text": "9.2.2. TLS 1.2 Cipher Suites",
      "section_title": true,
      "ja": "9.2.2.  TLS 1.2暗号スイート"
    },
    {
      "indent": 3,
      "text": "A deployment of HTTP/2 over TLS 1.2 SHOULD NOT use any of the cipher suites that are listed in the cipher suite black list (Appendix A).",
      "ja": "TLS 1.2を超えるHTTP / 2の展開は、暗号スイートブラックリスト（付録A）でリストされている暗号スイートのいずれかを使用しないでください。"
    },
    {
      "indent": 3,
      "text": "Endpoints MAY choose to generate a connection error (Section 5.4.1) of type INADEQUATE_SECURITY if one of the cipher suites from the black list is negotiated. A deployment that chooses to use a black-listed cipher suite risks triggering a connection error unless the set of potential peers is known to accept that cipher suite.",
      "ja": "エンドポイントは、ブラックリストから暗号スイートのいずれかが交渉されている場合型INADEQUATE_SECURITYの接続エラー（5.4.1）を生成するために選ぶかもしれません。ブラックリストされている暗号スイートを使用することを選択した配備は、潜在的なピアのセットは、その暗号スイートを受け入れることが知られていない限り、接続エラーをトリガする危険があります。"
    },
    {
      "indent": 3,
      "text": "Implementations MUST NOT generate this error in reaction to the negotiation of a cipher suite that is not on the black list. Consequently, when clients offer a cipher suite that is not on the black list, they have to be prepared to use that cipher suite with HTTP/2.",
      "ja": "実装は、ブラックリストに含まれていない暗号スイートの交渉に反応して、このエラーを発生させてはいけません。クライアントがブラックリストに含まれていない暗号スイートを提供したときにその結果、彼らはHTTP / 2でその暗号スイートを使用するために準備する必要があります。"
    },
    {
      "indent": 3,
      "text": "The black list includes the cipher suite that TLS 1.2 makes mandatory, which means that TLS 1.2 deployments could have non-intersecting sets of permitted cipher suites. To avoid this problem causing TLS handshake failures, deployments of HTTP/2 that use TLS 1.2 MUST support TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 [TLS-ECDHE] with the P-256 elliptic curve [FIPS186].",
      "ja": "ブラックリストは、TLS 1.2の展開が許可されている暗号スイートの非交差セットを持っている可能性があることを意味し1.2が必須になりTLS暗号スイートが含まれています。 TLSハンドシェイクの失敗の原因とこの問題を回避するために、TLS 1.2を使用してHTTP / 2の展開は、P-256楕円曲線[FIPS186]でTLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 [TLS-ECDHE]をサポートしなければなりません。"
    },
    {
      "indent": 3,
      "text": "Note that clients might advertise support of cipher suites that are on the black list in order to allow for connection to servers that do not support HTTP/2. This allows servers to select HTTP/1.1 with a cipher suite that is on the HTTP/2 black list. However, this can result in HTTP/2 being negotiated with a black-listed cipher suite if the application protocol and cipher suite are independently selected.",
      "ja": "クライアントは、HTTP / 2をサポートしていないサーバへの接続を可能にするために、ブラックリストにある暗号スイートのサポートを宣伝かもしれないことに注意してください。これは、サーバがHTTP / 2のブラックリストに載っている暗号スイートとHTTP / 1.1を選択することができます。しかしながら、これは、アプリケーションプロトコル及び暗号スイートは、独立して選択された場合、HTTP / 2は、ブラックリストされた暗号スイートと交渉さをもたらすことができます。"
    },
    {
      "indent": 0,
      "text": "10. Security Considerations",
      "section_title": true,
      "ja": "10.セキュリティの考慮事項"
    },
    {
      "indent": 0,
      "text": "10.1. Server Authority",
      "section_title": true,
      "ja": "10.1. サーバー機関"
    },
    {
      "indent": 3,
      "text": "HTTP/2 relies on the HTTP/1.1 definition of authority for determining whether a server is authoritative in providing a given response (see [RFC7230], Section 9.1). This relies on local name resolution for the \"http\" URI scheme and the authenticated server identity for the \"https\" scheme (see [RFC2818], Section 3).",
      "ja": "HTTP / 2 HTTP /サーバが所与の応答を提供する権限があるかどうかを決定するための権限の定義1.1（[RFC7230]、セクション9.1を参照）に依存しています。これは、「HTTP」URIスキームと「https」のスキームのための認証されたサーバID（[RFC2818]、セクション3を参照）のためのローカルの名前解決に依存しています。"
    },
    {
      "indent": 0,
      "text": "10.2. Cross-Protocol Attacks",
      "section_title": true,
      "ja": "10.2. クロスプロトコル攻撃"
    },
    {
      "indent": 3,
      "text": "In a cross-protocol attack, an attacker causes a client to initiate a transaction in one protocol toward a server that understands a different protocol. An attacker might be able to cause the transaction to appear as a valid transaction in the second protocol. In combination with the capabilities of the web context, this can be used to interact with poorly protected servers in private networks.",
      "ja": "クロスプロトコル攻撃では、攻撃者は、異なるプロトコルを理解し、サーバに向かって1つのプロトコルでトランザクションを開始するために、クライアントの原因となります。攻撃者は、トランザクションが第二のプロトコルで有効なトランザクションとして出現させることができるかもしれません。 Webコンテキストの機能と組み合わせることで、これはプライベートネットワークに難保護されたサーバーと対話するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "Completing a TLS handshake with an ALPN identifier for HTTP/2 can be considered sufficient protection against cross-protocol attacks. ALPN provides a positive indication that a server is willing to proceed with HTTP/2, which prevents attacks on other TLS-based protocols.",
      "ja": "HTTP / 2 ALPN識別子を有するTLSハンドシェイクを完了すると、クロスプロトコル攻撃に対する十分な保護と考えることができます。 ALPNは、サーバが他のTLSベースのプロトコルへの攻撃を防止するHTTP / 2、を続行する意思があることを正の指標を提供します。"
    },
    {
      "indent": 3,
      "text": "The encryption in TLS makes it difficult for attackers to control the data that could be used in a cross-protocol attack on a cleartext protocol.",
      "ja": "TLSでの暗号化は、それが困難な攻撃者が平文のプロトコル上のクロスプロトコル攻撃で使用できるデータを制御できるようになります。"
    },
    {
      "indent": 3,
      "text": "The cleartext version of HTTP/2 has minimal protection against cross-protocol attacks. The connection preface (Section 3.5) contains a string that is designed to confuse HTTP/1.1 servers, but no special protection is offered for other protocols. A server that is willing to ignore parts of an HTTP/1.1 request containing an Upgrade header field in addition to the client connection preface could be exposed to a cross-protocol attack.",
      "ja": "HTTP / 2の平文バージョンは、クロスプロトコル攻撃に対する最小限の保護を持っています。接続序文（3.5節）は、HTTP / 1.1サーバを混同するように設計されていますが、特別な保護が他のプロトコルのために提供されていない文字列が含まれています。クライアント接続序文に加えてアップグレードヘッダフィールドを含むHTTP / 1.1リクエストの部分を無視しても構わないと思っているサーバは、クロスプロトコル攻撃にさらされることができます。"
    },
    {
      "indent": 0,
      "text": "10.3. Intermediary Encapsulation Attacks",
      "section_title": true,
      "ja": "10.3. 仲介カプセル化攻撃"
    },
    {
      "indent": 3,
      "text": "The HTTP/2 header field encoding allows the expression of names that are not valid field names in the Internet Message Syntax used by HTTP/1.1. Requests or responses containing invalid header field names MUST be treated as malformed (Section 8.1.2.6). An intermediary therefore cannot translate an HTTP/2 request or response containing an invalid field name into an HTTP/1.1 message.",
      "ja": "HTTP / 2ヘッダフィールド符号化は、HTTP / 1.1が使用するインターネットメッセージ構文で有効なフィールド名ではない名前の発現を可能にします。無効なヘッダーフィールド名を含む要求や応答は、不正な形式（セクション8.1.2.6）として扱われなければなりません。仲介は、したがって、HTTP / 1.1メッセージに無効なフィールド名を含むHTTP / 2要求または応答を翻訳することはできません。"
    },
    {
      "indent": 3,
      "text": "Similarly, HTTP/2 allows header field values that are not valid. While most of the values that can be encoded will not alter header field parsing, carriage return (CR, ASCII 0xd), line feed (LF, ASCII 0xa), and the zero character (NUL, ASCII 0x0) might be exploited by an attacker if they are translated verbatim. Any request or response that contains a character not permitted in a header field value MUST be treated as malformed (Section 8.1.2.6). Valid characters are defined by the \"field-content\" ABNF rule in Section 3.2 of [RFC7230].",
      "ja": "同様に、HTTP / 2が有効でないヘッダフィールド値を可能にします。符号化することができる値のほとんどは、ヘッダフィールドの解析、キャリッジリターン（CR、アスキーの0xd）を変更しないであろうが、ラインフィード（LF、ASCIIのは0xa）、ゼロ文字（NUL、アスキーは0x0）は、攻撃者によって悪用される可能性がありますそれらはそのままに翻訳されている場合。ヘッダフィールド値に許可されていない文字を含む任意の要求または応答は、不正な形式（セクション8.1.2.6）として扱われなければなりません。有効な文字は、[RFC7230]の3.2節に「フィールド・コンテンツ」ABNF規則によって定義されています。"
    },
    {
      "indent": 0,
      "text": "10.4. Cacheability of Pushed Responses",
      "section_title": true,
      "ja": "10.4. プッシュ応答のキャッシュ可能性"
    },
    {
      "indent": 3,
      "text": "Pushed responses do not have an explicit request from the client; the request is provided by the server in the PUSH_PROMISE frame.",
      "ja": "プッシュされた応答は、クライアントからの明示的な要求を持っていません。要求はPUSH_PROMISEフレーム内のサーバーによって提供されます。"
    },
    {
      "indent": 3,
      "text": "Caching responses that are pushed is possible based on the guidance provided by the origin server in the Cache-Control header field. However, this can cause issues if a single server hosts more than one tenant. For example, a server might offer multiple users each a small portion of its URI space.",
      "ja": "プッシュされるキャッシュ応答はCache-Controlヘッダフィールドにオリジンサーバが提供する指針に基づいて可能です。単一のサーバが複数のテナントをホストしている場合しかし、これは問題を引き起こす可能性があります。例えば、サーバは、各そのURI空間のごく一部複数のユーザーを提供するかもしれません。"
    },
    {
      "indent": 3,
      "text": "Where multiple tenants share space on the same server, that server MUST ensure that tenants are not able to push representations of resources that they do not have authority over. Failure to enforce this would allow a tenant to provide a representation that would be served out of cache, overriding the actual representation that the authoritative tenant provides.",
      "ja": "複数のテナントが同じサーバ上のスペースを共有する場合は、そのサーバーは、テナントは、彼らが権限を超える持たないリソースの表現をプッシュすることができないようにする必要があります。これを強制するために失敗すると、テナントは権威あるテナントが提供する実際の表現を上書きし、キャッシュから提供されるだろう表現を提供できるようになります。"
    },
    {
      "indent": 3,
      "text": "Pushed responses for which an origin server is not authoritative (see Section 10.1) MUST NOT be used or cached.",
      "ja": "オリジンサーバが権威されていないプッシュ回答（10.1節を参照）を使用したり、キャッシュしてはなりません。"
    },
    {
      "indent": 0,
      "text": "10.5. Denial-of-Service Considerations",
      "section_title": true,
      "ja": "10.5. サービス拒否の考慮事項"
    },
    {
      "indent": 3,
      "text": "An HTTP/2 connection can demand a greater commitment of resources to operate than an HTTP/1.1 connection. The use of header compression and flow control depend on a commitment of resources for storing a greater amount of state. Settings for these features ensure that memory commitments for these features are strictly bounded.",
      "ja": "HTTP / 2接続はHTTP / 1.1接続よりも動作するように資源のより大きなコミットメントを要求することができます。ヘッダ圧縮およびフロー制御を使用することは、状態のより大きな量を格納するためのリソースのコミットメントに依存します。これらの機能の設定は、これらの機能のためのメモリコミットメントを厳格に制限されていることを確認してください。"
    },
    {
      "indent": 3,
      "text": "The number of PUSH_PROMISE frames is not constrained in the same fashion. A client that accepts server push SHOULD limit the number of streams it allows to be in the \"reserved (remote)\" state. An excessive number of server push streams can be treated as a stream error (Section 5.4.2) of type ENHANCE_YOUR_CALM.",
      "ja": "PUSH_PROMISEフレームの数は、同様に制約されません。サーバ・プッシュを受け入れるクライアントは「予約済み（リモート）」状態にあることを可能にするストリームの数を制限する必要があります。サーバープッシュストリームの過剰な数は、タイプENHANCE_YOUR_CALMのストリームエラー（5.4.2項）として扱うことができます。"
    },
    {
      "indent": 3,
      "text": "Processing capacity cannot be guarded as effectively as state capacity.",
      "ja": "処理能力は、状態容量ほど効果的に守らすることはできません。"
    },
    {
      "indent": 3,
      "text": "The SETTINGS frame can be abused to cause a peer to expend additional processing time. This might be done by pointlessly changing SETTINGS parameters, setting multiple undefined parameters, or changing the same setting multiple times in the same frame. WINDOW_UPDATE or PRIORITY frames can be abused to cause an unnecessary waste of resources.",
      "ja": "SETTINGSフレームは、追加の処理時間を費やすためにピアを引き起こすために悪用されることができます。これは無意味に同じフレームで複数回、SETTINGSパラメータを変更する複数の未定義のパラメータを設定する、または同じ設定を変更することによって行うことがあります。 WINDOW_UPDATEまたはPRIORITYフレームは資源の無駄遣いを引き起こすために悪用されることができます。"
    },
    {
      "indent": 3,
      "text": "Large numbers of small or empty frames can be abused to cause a peer to expend time processing frame headers. Note, however, that some uses are entirely legitimate, such as the sending of an empty DATA or CONTINUATION frame at the end of a stream.",
      "ja": "小さなまたは空のフレームの多数は時間処理フレームヘッダを消費するピアを引き起こすために悪用することができます。いくつかの用途は、そのようなストリームの終わりに空のデータまたは継続フレームの送信のように、完全に正当であること、しかし、注意してください。"
    },
    {
      "indent": 3,
      "text": "Header compression also offers some opportunities to waste processing resources; see Section 7 of [COMPRESSION] for more details on potential abuses.",
      "ja": "ヘッダ圧縮は、処理リソースを無駄にするいくつかの機会を提供しています。潜在的な人権侵害についての詳細は、[COMPRESSION]のセクション7を参照してください。"
    },
    {
      "indent": 3,
      "text": "Limits in SETTINGS parameters cannot be reduced instantaneously, which leaves an endpoint exposed to behavior from a peer that could exceed the new limits. In particular, immediately after establishing a connection, limits set by a server are not known to clients and could be exceeded without being an obvious protocol violation.",
      "ja": "SETTINGSパラメータの制限は新しい限界を超える可能性がピアからの行動にさらされるエンドポイントを残す、瞬時に低減することができません。具体的には、すぐに接続を確立した後、サーバーで設定された制限は、クライアントに知られていないと明らかにプロトコル違反せずに超過することができます。"
    },
    {
      "indent": 3,
      "text": "All these features -- i.e., SETTINGS changes, small frames, header compression -- have legitimate uses. These features become a burden only when they are used unnecessarily or to excess.",
      "ja": "これらすべての機能は - すなわち、変更、小さなフレーム、ヘッダ圧縮を設定 - 正当な用途を有します。これらの機能は、彼らが不必要または過剰に使用されているだけの負担になります。"
    },
    {
      "indent": 3,
      "text": "An endpoint that doesn't monitor this behavior exposes itself to a risk of denial-of-service attack. Implementations SHOULD track the use of these features and set limits on their use. An endpoint MAY treat activity that is suspicious as a connection error (Section 5.4.1) of type ENHANCE_YOUR_CALM.",
      "ja": "この動作を監視していないエンドポイントは、サービス拒否攻撃の危険に自分自身を公開しています。実装は、これらの機能の使用を追跡し、その使用に制限を設定すべきです。エンドポイントは、タイプENHANCE_YOUR_CALMの接続エラー（5.4.1項）として疑わしい活動を扱うかもしれ。"
    },
    {
      "indent": 0,
      "text": "10.5.1. Limits on Header Block Size",
      "section_title": true,
      "ja": "10.5.1. ヘッダーブロックサイズの制限"
    },
    {
      "indent": 3,
      "text": "A large header block (Section 4.3) can cause an implementation to commit a large amount of state. Header fields that are critical for routing can appear toward the end of a header block, which prevents streaming of header fields to their ultimate destination. This ordering and other reasons, such as ensuring cache correctness, mean that an endpoint might need to buffer the entire header block. Since there is no hard limit to the size of a header block, some endpoints could be forced to commit a large amount of available memory for header fields.",
      "ja": "大ヘッダブロック（セクション4.3）状態を大量にコミットするために、実装を引き起こす可能性があります。ルーティングのために重要であるヘッダフィールドは、その最終的な宛先にヘッダフィールドのストリーミングを防止ヘッダブロックの端部に向かって現れることができます。この順序と、キャッシュ正確さを確保するなどの他の理由は、エンドポイントが全体ヘッダーブロックをバッファする必要があるかもしれないことを意味します。ヘッダブロックのサイズへのハード制限がないので、いくつかのエンドポイントは、ヘッダフィールドに利用可能な大量のメモリをコミットするように強制することができます。"
    },
    {
      "indent": 3,
      "text": "An endpoint can use the SETTINGS_MAX_HEADER_LIST_SIZE to advise peers of limits that might apply on the size of header blocks. This setting is only advisory, so endpoints MAY choose to send header blocks that exceed this limit and risk having the request or response being treated as malformed. This setting is specific to a connection, so any request or response could encounter a hop with a lower, unknown limit. An intermediary can attempt to avoid this problem by passing on values presented by different peers, but they are not obligated to do so.",
      "ja": "エンドポイントは、ヘッダブロックのサイズに適用される可能性のある制限のピアを助言するSETTINGS_MAX_HEADER_LIST_SIZEを使用することができます。エンドポイントがこの制限を超えるヘッダブロックを送信し、不正な形式として扱われる要求または応答を有するリスクを選ぶかもしれように、この設定は、唯一の顧問です。この設定は、接続に固有であるため、任意の要求または応答が低い、未知の限界とホップが発生する可能性があります。仲介は異なるピアによって提示された値を渡すことで、この問題を回避しようとすることができますが、彼らはそうする義務はありません。"
    },
    {
      "indent": 3,
      "text": "A server that receives a larger header block than it is willing to handle can send an HTTP 431 (Request Header Fields Too Large) status code [RFC6585]. A client can discard responses that it cannot process. The header block MUST be processed to ensure a consistent connection state, unless the connection is closed.",
      "ja": "ハンドルても構わないと思っているよりも大きなヘッダブロックを受信したサーバは、HTTP 431（リクエストヘッダフィールドが大きすぎ）ステータスコード[RFC6585]を送ることができます。クライアントは、それが処理できない応答を破棄することができます。ヘッダブロックは、接続が閉じられない限り、一貫性のある接続状態を確保するために処理されなければなりません。"
    },
    {
      "indent": 0,
      "text": "10.5.2. CONNECT Issues",
      "section_title": true,
      "ja": "10.5.2.  CONNECT問題"
    },
    {
      "indent": 3,
      "text": "The CONNECT method can be used to create disproportionate load on an proxy, since stream creation is relatively inexpensive when compared to the creation and maintenance of a TCP connection. A proxy might also maintain some resources for a TCP connection beyond the closing of the stream that carries the CONNECT request, since the outgoing TCP connection remains in the TIME_WAIT state. Therefore, a proxy cannot rely on SETTINGS_MAX_CONCURRENT_STREAMS alone to limit the resources consumed by CONNECT requests.",
      "ja": "TCP接続の作成と保守と比較した場合、ストリームの作成が比較的安価であるので、CONNECTメソッドは、プロキシに不均衡な負荷を作成するために使用することができます。プロキシは、発信TCP接続がTIME_WAIT状態のままであるため、CONNECT要求を運ぶストリームの閉鎖を超えたTCP接続のためにいくつかのリソースを維持する可能性があります。そのため、プロキシがCONNECT要求によって消費されるリソースを制限するために単独でSETTINGS_MAX_CONCURRENT_STREAMSに頼ることはできません。"
    },
    {
      "indent": 0,
      "text": "10.6. Use of Compression",
      "section_title": true,
      "ja": "10.6. 圧縮の使用"
    },
    {
      "indent": 3,
      "text": "Compression can allow an attacker to recover secret data when it is compressed in the same context as data under attacker control. HTTP/2 enables compression of header fields (Section 4.3); the following concerns also apply to the use of HTTP compressed content-codings ([RFC7231], Section 3.1.2.1).",
      "ja": "圧縮は、それが攻撃者の制御下にあるデータと同じ文脈で圧縮された場合、攻撃者が機密データを回復できるようにすることができます。 HTTP / 2ヘッダーフィールド（セクション4.3）の圧縮を可能にします。次の問題はまた、HTTP圧縮内容コーディング（[RFC7231]、セクション3.1.2.1）の使用にも適用されます。"
    },
    {
      "indent": 3,
      "text": "There are demonstrable attacks on compression that exploit the characteristics of the web (e.g., [BREACH]). The attacker induces multiple requests containing varying plaintext, observing the length of the resulting ciphertext in each, which reveals a shorter length when a guess about the secret is correct.",
      "ja": "ウェブの特性を利用する圧縮上の実証攻撃がある（例えば、[違反]）。攻撃者は、秘密について推測が正しい場合、より短い長さを明らかにするそれぞれにおいて得られた暗号文の長さを観察し、変化平文を含む複数の要求を誘発します。"
    },
    {
      "indent": 3,
      "text": "Implementations communicating on a secure channel MUST NOT compress content that includes both confidential and attacker-controlled data unless separate compression dictionaries are used for each source of data. Compression MUST NOT be used if the source of data cannot be reliably determined. Generic stream compression, such as that provided by TLS, MUST NOT be used with HTTP/2 (see Section 9.2).",
      "ja": "セキュアなチャネル上で通信実装は、別の圧縮辞書データの各ソースのために使用されていない限り、両方の機密と攻撃者が制御データを含むコンテンツを圧縮してはいけません。データのソースを確実に決定することができない場合は、圧縮を使用してはいけません。そのようなTLSによって提供されるような汎用のストリーム圧縮は、HTTP / 2を使用してはいけません（セクション9.2を参照）。"
    },
    {
      "indent": 3,
      "text": "Further considerations regarding the compression of header fields are described in [COMPRESSION].",
      "ja": "ヘッダフィールドの圧縮に関するさらなる考察は、[COMPRESSION]に記載されています。"
    },
    {
      "indent": 0,
      "text": "10.7. Use of Padding",
      "section_title": true,
      "ja": "10.7. パディングの使用"
    },
    {
      "indent": 3,
      "text": "Padding within HTTP/2 is not intended as a replacement for general purpose padding, such as might be provided by TLS [TLS12]. Redundant padding could even be counterproductive. Correct application can depend on having specific knowledge of the data that is being padded.",
      "ja": "HTTP / 2内のパディングが[TLS12] TLSによって提供されるかもしれないような、汎用パディングの代替として意図されていません。冗長パディングも、逆効果である可能性があります。正しいアプリケーションが埋め込まれているデータの特定の知識を有することに依存することができます。"
    },
    {
      "indent": 3,
      "text": "To mitigate attacks that rely on compression, disabling or limiting compression might be preferable to padding as a countermeasure.",
      "ja": "圧縮に頼る攻撃を軽減するために、無効化や圧縮を制限する対策として、パディングに望ましいかもしれません。"
    },
    {
      "indent": 3,
      "text": "Padding can be used to obscure the exact size of frame content and is provided to mitigate specific attacks within HTTP, for example, attacks where compressed content includes both attacker-controlled plaintext and secret data (e.g., [BREACH]).",
      "ja": "パディングは、フレームコンテンツの正確なサイズを不明瞭に使用することができ、例えば、HTTP内の特定の攻撃を軽減するために設けられ、圧縮されたコンテンツは、攻撃者が制御平文と秘密データ（例えば、[違反]）の両方を含む攻撃。"
    },
    {
      "indent": 3,
      "text": "Use of padding can result in less protection than might seem immediately obvious. At best, padding only makes it more difficult for an attacker to infer length information by increasing the number of frames an attacker has to observe. Incorrectly implemented padding schemes can be easily defeated. In particular, randomized padding with a predictable distribution provides very little protection; similarly, padding payloads to a fixed size exposes information as payload sizes cross the fixed-sized boundary, which could be possible if an attacker can control plaintext.",
      "ja": "パディングの使用はすぐに明らかに思えるかもしれないより少なく保護につながることができます。せいぜい、パディングは、それがより困難に攻撃者は、攻撃者が観察しているフレームの数を増やすことで長さ情報を推測できるようになります。正しく実装パディングスキームを簡単に無効にすることができます。具体的には、予測可能な分布との無作為化パディングは非常に少ないの保護を提供します。ペイロードサイズは、攻撃者が平文を制御することができる場合に可能とすることができる固定サイズの境界を横切ると同様に、固定サイズのパディングペイロードが情報を公開します。"
    },
    {
      "indent": 3,
      "text": "Intermediaries SHOULD retain padding for DATA frames but MAY drop padding for HEADERS and PUSH_PROMISE frames. A valid reason for an intermediary to change the amount of padding of frames is to improve the protections that padding provides.",
      "ja": "仲介は、データフレームのためのパディングを保持すべきであるが、ヘッダとPUSH_PROMISEフレームのパディングを低下することがあります。フレームのパディングの量を変更するには、仲介のための正当な理由は、パディングが提供する保護を改善することです。"
    },
    {
      "indent": 0,
      "text": "10.8. Privacy Considerations",
      "section_title": true,
      "ja": "10.8. プライバシーの考慮事項"
    },
    {
      "indent": 3,
      "text": "Several characteristics of HTTP/2 provide an observer an opportunity to correlate actions of a single client or server over time. These include the value of settings, the manner in which flow-control windows are managed, the way priorities are allocated to streams, the timing of reactions to stimulus, and the handling of any features that are controlled by settings.",
      "ja": "HTTP / 2のいくつかの特徴は、観察者に時間をかけて単一のクライアントまたはサーバの動作を相関させる機会を提供します。これらは、設定値、フロー制御ウィンドウが管理される方法、方法の優先順位は、ストリームに割り当てられて、刺激に対する反応のタイミング、および設定によって制御されている任意の機能の取り扱いを含みます。"
    },
    {
      "indent": 3,
      "text": "As far as these create observable differences in behavior, they could be used as a basis for fingerprinting a specific client, as defined in Section 1.8 of [HTML5].",
      "ja": "[HTML5]のセクション1.8で定義されている限り、これらは行動の観察可能な違いを作成すると、彼らは、特定のクライアントをフィンガープリントするための基礎として使用することができます。"
    },
    {
      "indent": 3,
      "text": "HTTP/2's preference for using a single TCP connection allows correlation of a user's activity on a site. Reusing connections for different origins allows tracking across those origins.",
      "ja": "単一のTCP接続を使用するためのHTTP / 2の好みは、サイト上でのユーザーの活動の相関を可能にします。異なる起源の接続を再利用すると、それらの起源渡って追跡することができます。"
    },
    {
      "indent": 3,
      "text": "Because the PING and SETTINGS frames solicit immediate responses, they can be used by an endpoint to measure latency to their peer. This might have privacy implications in certain scenarios.",
      "ja": "PINGとSETTINGSフレームはすぐに回答を求めるので、彼らは彼らのピアに遅延を測定するために、エンドポイントで使用することができます。これは、特定のシナリオでは、プライバシーへの影響があるかもしれません。"
    },
    {
      "indent": 0,
      "text": "11. IANA Considerations",
      "section_title": true,
      "ja": "11. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "A string for identifying HTTP/2 is entered into the \"Application-Layer Protocol Negotiation (ALPN) Protocol IDs\" registry established in [TLS-ALPN].",
      "ja": "HTTP / 2を識別するための文字列は、「アプリケーション層のプロトコルネゴシエーション（ALPN）プロトコルIDが」[TLS-ALPN]で確立レジストリに入力されます。"
    },
    {
      "indent": 3,
      "text": "This document establishes a registry for frame types, settings, and error codes. These new registries appear in the new \"Hypertext Transfer Protocol version 2 (HTTP/2) Parameters\" section.",
      "ja": "この文書では、フレームの種類、設定、およびエラー・コードのレジストリを確立します。これらの新しいレジストリは、新たな「ハイパーテキスト転送プロトコルバージョン2（HTTP / 2）パラメータ」セクションに表示されます。"
    },
    {
      "indent": 3,
      "text": "This document registers the HTTP2-Settings header field for use in HTTP; it also registers the 421 (Misdirected Request) status code.",
      "ja": "この文書では、HTTPで使用するためのHTTP2-設定ヘッダフィールドを登録します。それはまた、421（間違った方向への要求）ステータスコードを登録します。"
    },
    {
      "indent": 3,
      "text": "This document registers the \"PRI\" method for use in HTTP to avoid collisions with the connection preface (Section 3.5).",
      "ja": "この文書では、接続序文（3.5節）との衝突を回避するためにHTTPで使用する「PRI」メソッドを登録します。"
    },
    {
      "indent": 0,
      "text": "11.1. Registration of HTTP/2 Identification Strings",
      "section_title": true,
      "ja": "11.1.  HTTP / 2の識別文字列の登録"
    },
    {
      "indent": 3,
      "text": "This document creates two registrations for the identification of HTTP/2 (see Section 3.3) in the \"Application-Layer Protocol Negotiation (ALPN) Protocol IDs\" registry established in [TLS-ALPN].",
      "ja": "この文書では、[TLS-ALPN]で確立「アプリケーション層のプロトコルネゴシエーション（ALPN）プロトコルIDが」レジストリに（セクション3.3を参照）HTTP / 2の識別のための2つの登録を作成します。"
    },
    {
      "indent": 3,
      "text": "The \"h2\" string identifies HTTP/2 when used over TLS:",
      "ja": "TLS上で使用する場合、「H2」の文字列は、HTTP / 2を識別します。"
    },
    {
      "indent": 3,
      "text": "Protocol: HTTP/2 over TLS",
      "ja": "プロトコル：HTTP / 2 TLSを超えます"
    },
    {
      "indent": 3,
      "text": "Identification Sequence: 0x68 0x32 (\"h2\")",
      "ja": "企業識別コード：0x68 0x32の（ \"H2\"）"
    },
    {
      "indent": 3,
      "text": "Specification: This document",
      "ja": "仕様：このドキュメント"
    },
    {
      "indent": 3,
      "text": "The \"h2c\" string identifies HTTP/2 when used over cleartext TCP:",
      "ja": "クリアテキストのTCP上で使用する場合、「H2C」の文字列は、HTTP / 2を識別します。"
    },
    {
      "indent": 3,
      "text": "Protocol: HTTP/2 over TCP",
      "ja": "プロトコル：HTTP / 2 TCP経由"
    },
    {
      "indent": 3,
      "text": "Identification Sequence: 0x68 0x32 0x63 (\"h2c\")",
      "ja": "企業識別コード：0x68 0x32のは0x63（ \"H2C\"）"
    },
    {
      "indent": 3,
      "text": "Specification: This document",
      "ja": "仕様：このドキュメント"
    },
    {
      "indent": 0,
      "text": "11.2. Frame Type Registry",
      "section_title": true,
      "ja": "11.2. フレームタイプレジストリ"
    },
    {
      "indent": 3,
      "text": "This document establishes a registry for HTTP/2 frame type codes. The \"HTTP/2 Frame Type\" registry manages an 8-bit space. The \"HTTP/2 Frame Type\" registry operates under either of the \"IETF Review\" or \"IESG Approval\" policies [RFC5226] for values between 0x00 and 0xef, with values between 0xf0 and 0xff being reserved for Experimental Use.",
      "ja": "このドキュメントでは、HTTP / 2フレームタイプコードのレジストリを確立します。 「HTTP / 2フレームタイプ」レジストリは8ビット空間を管理します。 「HTTP / 2フレームタイプ」レジストリは0xF0がと0xffの実験的な使用のために予約されている間の値で、「IETFレビュー」または0x00から0xEFという間の値については、「IESG承認」政策[RFC5226]のいずれかで動作します。"
    },
    {
      "indent": 3,
      "text": "New entries in this registry require the following information:",
      "ja": "このレジストリ内の新しいエントリは、次の情報が必要です。"
    },
    {
      "indent": 3,
      "text": "Frame Type: A name or label for the frame type.",
      "ja": "フレームタイプ：フレームタイプの名前またはラベル。"
    },
    {
      "indent": 3,
      "text": "Code: The 8-bit code assigned to the frame type.",
      "ja": "コード：フレームタイプに割り当てられた8ビット・コード。"
    },
    {
      "indent": 3,
      "text": "Specification: A reference to a specification that includes a description of the frame layout, its semantics, and flags that the frame type uses, including any parts of the frame that are conditionally present based on the value of flags.",
      "ja": "仕様：フレームタイプがフラグの値に基づいて条件付きで存在するフレームの任意の部分を含めて、使用するフレームのレイアウト、そのセマンティクス、およびフラグの説明を含む明細書を参照。"
    },
    {
      "indent": 3,
      "text": "The entries in the following table are registered by this document.",
      "ja": "次の表のエントリはこの文書によって登録されています。"
    },
    {
      "indent": 3,
      "text": "+---------------+------+--------------+\n| Frame Type    | Code | Section      |\n+---------------+------+--------------+\n| DATA          | 0x0  | Section 6.1  |\n| HEADERS       | 0x1  | Section 6.2  |\n| PRIORITY      | 0x2  | Section 6.3  |\n| RST_STREAM    | 0x3  | Section 6.4  |\n| SETTINGS      | 0x4  | Section 6.5  |\n| PUSH_PROMISE  | 0x5  | Section 6.6  |\n| PING          | 0x6  | Section 6.7  |\n| GOAWAY        | 0x7  | Section 6.8  |\n| WINDOW_UPDATE | 0x8  | Section 6.9  |\n| CONTINUATION  | 0x9  | Section 6.10 |\n+---------------+------+--------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "11.3. Settings Registry",
      "section_title": true,
      "ja": "11.3. 設定レジストリ"
    },
    {
      "indent": 3,
      "text": "This document establishes a registry for HTTP/2 settings. The \"HTTP/2 Settings\" registry manages a 16-bit space. The \"HTTP/2 Settings\" registry operates under the \"Expert Review\" policy [RFC5226] for values in the range from 0x0000 to 0xefff, with values between and 0xf000 and 0xffff being reserved for Experimental Use.",
      "ja": "このドキュメントでは、HTTP / 2の設定のためのレジストリを確立します。 「HTTP / 2の設定」レジストリが16ビット空間を管理します。 「HTTP / 2の設定」のレジストリは、間と0XF000と実験的な使用のために予約されて0xffffの値で、0000から0xefffの範囲内の値の「エキスパートレビュー」ポリシー[RFC5226]の下で動作します。"
    },
    {
      "indent": 3,
      "text": "New registrations are advised to provide the following information:",
      "ja": "新規登録は、以下の情報を提供することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "Name: A symbolic name for the setting. Specifying a setting name is optional.",
      "ja": "名前：設定のシンボル名。設定名の指定はオプションです。"
    },
    {
      "indent": 3,
      "text": "Code: The 16-bit code assigned to the setting.",
      "ja": "コード：設定に割り当てられた16ビットコード。"
    },
    {
      "indent": 3,
      "text": "Initial Value: An initial value for the setting.",
      "ja": "初期値：設定の初期値。"
    },
    {
      "indent": 3,
      "text": "Specification: An optional reference to a specification that describes the use of the setting.",
      "ja": "仕様：設定の使用が記載されている仕様へのオプション参照。"
    },
    {
      "indent": 3,
      "text": "The entries in the following table are registered by this document.",
      "ja": "次の表のエントリはこの文書によって登録されています。"
    },
    {
      "indent": 3,
      "text": "+------------------------+------+---------------+---------------+\n| Name                   | Code | Initial Value | Specification |\n+------------------------+------+---------------+---------------+\n| HEADER_TABLE_SIZE      | 0x1  | 4096          | Section 6.5.2 |\n| ENABLE_PUSH            | 0x2  | 1             | Section 6.5.2 |\n| MAX_CONCURRENT_STREAMS | 0x3  | (infinite)    | Section 6.5.2 |\n| INITIAL_WINDOW_SIZE    | 0x4  | 65535         | Section 6.5.2 |\n| MAX_FRAME_SIZE         | 0x5  | 16384         | Section 6.5.2 |\n| MAX_HEADER_LIST_SIZE   | 0x6  | (infinite)    | Section 6.5.2 |\n+------------------------+------+---------------+---------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "11.4. Error Code Registry",
      "section_title": true,
      "ja": "11.4. エラーコードレジストリ"
    },
    {
      "indent": 3,
      "text": "This document establishes a registry for HTTP/2 error codes. The \"HTTP/2 Error Code\" registry manages a 32-bit space. The \"HTTP/2 Error Code\" registry operates under the \"Expert Review\" policy [RFC5226].",
      "ja": "このドキュメントでは、HTTP / 2エラーコードのレジストリを確立します。 「HTTP / 2エラーコード」レジストリは、32ビット空間を管理します。 「HTTP / 2エラーコード」レジストリは「エキスパートレビュー」ポリシー[RFC5226]の下で動作します。"
    },
    {
      "indent": 3,
      "text": "Registrations for error codes are required to include a description of the error code. An expert reviewer is advised to examine new registrations for possible duplication with existing error codes. Use of existing registrations is to be encouraged, but not mandated.",
      "ja": "エラーコードの登録はエラー・コードの記述を含むことが要求されます。専門家のレビューアは、既存のエラーコードで可能な複製用の新しい登録を検討することをお勧めします。既存の登録の使用が奨励されるが、義務ではありません。"
    },
    {
      "indent": 3,
      "text": "New registrations are advised to provide the following information:",
      "ja": "新規登録は、以下の情報を提供することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "Name: A name for the error code. Specifying an error code name is optional.",
      "ja": "名前：エラーコードの名前。エラーコード名の指定はオプションです。"
    },
    {
      "indent": 3,
      "text": "Code: The 32-bit error code value.",
      "ja": "コード：32ビットのエラーコード値。"
    },
    {
      "indent": 3,
      "text": "Description: A brief description of the error code semantics, longer if no detailed specification is provided.",
      "ja": "説明：エラーコードの意味の簡単な説明、もはや詳細な仕様が用意されていない場合。"
    },
    {
      "indent": 3,
      "text": "Specification: An optional reference for a specification that defines the error code.",
      "ja": "仕様：エラーコードを定義する仕様のオプション参照。"
    },
    {
      "indent": 3,
      "text": "The entries in the following table are registered by this document.",
      "ja": "次の表のエントリはこの文書によって登録されています。"
    },
    {
      "indent": 3,
      "text": "+---------------------+------+----------------------+---------------+\n| Name                | Code | Description          | Specification |\n+---------------------+------+----------------------+---------------+\n| NO_ERROR            | 0x0  | Graceful shutdown    | Section 7     |\n| PROTOCOL_ERROR      | 0x1  | Protocol error       | Section 7     |\n|                     |      | detected             |               |\n| INTERNAL_ERROR      | 0x2  | Implementation fault | Section 7     |\n| FLOW_CONTROL_ERROR  | 0x3  | Flow-control limits  | Section 7     |\n|                     |      | exceeded             |               |\n| SETTINGS_TIMEOUT    | 0x4  | Settings not         | Section 7     |\n|                     |      | acknowledged         |               |\n| STREAM_CLOSED       | 0x5  | Frame received for   | Section 7     |\n|                     |      | closed stream        |               |\n| FRAME_SIZE_ERROR    | 0x6  | Frame size incorrect | Section 7     |\n| REFUSED_STREAM      | 0x7  | Stream not processed | Section 7     |\n| CANCEL              | 0x8  | Stream cancelled     | Section 7     |\n| COMPRESSION_ERROR   | 0x9  | Compression state    | Section 7     |\n|                     |      | not updated          |               |\n| CONNECT_ERROR       | 0xa  | TCP connection error | Section 7     |\n|                     |      | for CONNECT method   |               |\n| ENHANCE_YOUR_CALM   | 0xb  | Processing capacity  | Section 7     |\n|                     |      | exceeded             |               |\n| INADEQUATE_SECURITY | 0xc  | Negotiated TLS       | Section 7     |\n|                     |      | parameters not       |               |\n|                     |      | acceptable           |               |\n| HTTP_1_1_REQUIRED   | 0xd  | Use HTTP/1.1 for the | Section 7     |\n|                     |      | request              |               |\n+---------------------+------+----------------------+---------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "11.5. HTTP2-Settings Header Field Registration",
      "section_title": true,
      "ja": "11.5.  HTTP2-設定ヘッダーフィールド登録"
    },
    {
      "indent": 3,
      "text": "This section registers the HTTP2-Settings header field in the \"Permanent Message Header Field Names\" registry [BCP90].",
      "ja": "このセクションでは、「永続的メッセージヘッダフィールド名」レジストリ[BCP90]でHTTP2-設定ヘッダフィールドを登録します。"
    },
    {
      "indent": 3,
      "text": "Header field name: HTTP2-Settings",
      "ja": "ヘッダフィールド名：HTTP2-設定"
    },
    {
      "indent": 3,
      "text": "Applicable protocol: http",
      "ja": "該当するプロトコル：HTTP"
    },
    {
      "indent": 3,
      "text": "Status: standard",
      "ja": "ステータス：標準"
    },
    {
      "indent": 3,
      "text": "Author/Change controller: IETF",
      "ja": "著者/変更コントローラ：IETF"
    },
    {
      "indent": 3,
      "text": "Specification document(s): Section 3.2.1 of this document",
      "ja": "仕様書（S）：このドキュメントのセクション3.2.1"
    },
    {
      "indent": 3,
      "text": "Related information: This header field is only used by an HTTP/2 client for Upgrade-based negotiation.",
      "ja": "関連情報：このヘッダーフィールドのみのアップグレードベースの交渉のためにHTTP / 2クライアントによって使用されます。"
    },
    {
      "indent": 0,
      "text": "11.6. PRI Method Registration",
      "section_title": true,
      "ja": "11.6.  PRIメソッドの登録"
    },
    {
      "indent": 3,
      "text": "This section registers the \"PRI\" method in the \"HTTP Method Registry\" ([RFC7231], Section 8.1).",
      "ja": "このセクションでは、「HTTPメソッドレジストリ」（[RFC7231]、8.1節）に「PRI」メソッドを登録します。"
    },
    {
      "indent": 3,
      "text": "Method Name: PRI",
      "ja": "メソッド名：PRI"
    },
    {
      "indent": 3,
      "text": "Safe: Yes",
      "ja": "金庫：はい"
    },
    {
      "indent": 3,
      "text": "Idempotent: Yes",
      "ja": "冪等：はい"
    },
    {
      "indent": 3,
      "text": "Specification document(s): Section 3.5 of this document",
      "ja": "仕様書（S）：このドキュメントのセクション3.5"
    },
    {
      "indent": 3,
      "text": "Related information: This method is never used by an actual client. This method will appear to be used when an HTTP/1.1 server or intermediary attempts to parse an HTTP/2 connection preface.",
      "ja": "関連情報：このメソッドは、実際のクライアントによって使用されることはありません。この方法は、HTTP / 1.1サーバ又は中間試みがHTTP / 2接続序文を解析する際に使用されるように表示されます。"
    },
    {
      "indent": 0,
      "text": "11.7. The 421 (Misdirected Request) HTTP Status Code",
      "section_title": true,
      "ja": "11.7.  421（間違った方向へのリクエスト）HTTPステータスコード"
    },
    {
      "indent": 3,
      "text": "This document registers the 421 (Misdirected Request) HTTP status code in the \"HTTP Status Codes\" registry ([RFC7231], Section 8.2).",
      "ja": "この文書では、「HTTPステータスコード」レジストリ（[RFC7231]、8.2節）で421（間違った方向へのリクエスト）HTTPステータスコードを登録します。"
    },
    {
      "indent": 3,
      "text": "Status Code: 421",
      "ja": "ステータスコード：421"
    },
    {
      "indent": 3,
      "text": "Short Description: Misdirected Request",
      "ja": "短い説明：見当違いのリクエスト"
    },
    {
      "indent": 3,
      "text": "Specification: Section 9.1.2 of this document",
      "ja": "仕様：このドキュメントのセクション9.1.2"
    },
    {
      "indent": 0,
      "text": "11.8. The h2c Upgrade Token",
      "section_title": true,
      "ja": "11.8.  H2Cは、トークンをアップグレード"
    },
    {
      "indent": 3,
      "text": "This document registers the \"h2c\" upgrade token in the \"HTTP Upgrade Tokens\" registry ([RFC7230], Section 8.6).",
      "ja": "この文書では、「H2C」のアップグレードトークンレジストリ（[RFC7230]、セクション8.6）「HTTPはトークンのアップグレード」を登録します。"
    },
    {
      "indent": 3,
      "text": "Value: h2c",
      "ja": "値：H2C"
    },
    {
      "indent": 3,
      "text": "Description: Hypertext Transfer Protocol version 2 (HTTP/2)",
      "ja": "説明：ハイパーテキスト転送プロトコルバージョン2（HTTP / 2）"
    },
    {
      "indent": 3,
      "text": "Expected Version Tokens: None",
      "ja": "期待されるバージョンのトークン：なし"
    },
    {
      "indent": 3,
      "text": "Reference: Section 3.2 of this document",
      "ja": "参考：このドキュメントのセクション3.2"
    },
    {
      "indent": 0,
      "text": "12. References",
      "section_title": true,
      "ja": "12.参考文献"
    },
    {
      "indent": 0,
      "text": "12.1. Normative References",
      "section_title": true,
      "ja": "12.1. 引用規格"
    },
    {
      "indent": 3,
      "text": "[COMPRESSION] Peon, R. and H. Ruellan, \"HPACK: Header Compression for HTTP/2\", RFC 7541, DOI 10.17487/RFC7541, May 2015, <http://www.rfc-editor.org/info/rfc7541>.",
      "ja": "[COMPRESSION]ペオン、R.およびH. Ruellan、 \"HPACK：HTTP / 2のヘッダ圧縮\"、RFC 7541、DOI 10.17487 / RFC7541、2015年5月、<http://www.rfc-editor.org/info/rfc7541 >。"
    },
    {
      "indent": 3,
      "text": "[COOKIE] Barth, A., \"HTTP State Management Mechanism\", RFC 6265, DOI 10.17487/RFC6265, April 2011, <http://www.rfc-editor.org/info/rfc6265>.",
      "ja": "[COOKIE]バース、A.、 \"HTTP状態管理機構\"、RFC 6265、DOI 10.17487 / RFC6265、2011年4月、<http://www.rfc-editor.org/info/rfc6265>。"
    },
    {
      "indent": 3,
      "text": "[FIPS186] NIST, \"Digital Signature Standard (DSS)\", FIPS PUB 186-4, July 2013, <http://dx.doi.org/10.6028/NIST.FIPS.186-4>.",
      "ja": "[FIPS186] NIST、 \"デジタル署名標準（DSS）\"、FIPSパブ186から4、2013年7月、<http://dx.doi.org/10.6028/NIST.FIPS.186-4>。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/ RFC2119, March 1997, <http://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<http://www.rfc-editor.org/info/ RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC2818] Rescorla, E., \"HTTP Over TLS\", RFC 2818, DOI 10.17487/ RFC2818, May 2000, <http://www.rfc-editor.org/info/rfc2818>.",
      "ja": "[RFC2818]レスコラ、E.、 \"TLSオーバーHTTP\"、RFC 2818、DOI 10.17487 / RFC2818、2000年5月、<http://www.rfc-editor.org/info/rfc2818>。"
    },
    {
      "indent": 3,
      "text": "[RFC3986] Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform Resource Identifier (URI): Generic Syntax\", STD 66, RFC 3986, DOI 10.17487/RFC3986, January 2005, <http://www.rfc-editor.org/info/rfc3986>.",
      "ja": "[RFC3986]バーナーズ - リー、T.、フィールディング、R.、およびL. Masinter、 \"ユニフォームリソース識別子（URI）：汎用構文\"、STD 66、RFC 3986、DOI 10.17487 / RFC3986、2005年1月<HTTP：/ /www.rfc-editor.org/info/rfc3986>。"
    },
    {
      "indent": 3,
      "text": "[RFC4648] Josefsson, S., \"The Base16, Base32, and Base64 Data Encodings\", RFC 4648, DOI 10.17487/RFC4648, October 2006, <http://www.rfc-editor.org/info/rfc4648>.",
      "ja": "[RFC4648] Josefsson氏、S.、 \"Base16、Base32、およびBase64でデータエンコーディング\"、RFC 4648、DOI 10.17487 / RFC4648、2006年10月、<http://www.rfc-editor.org/info/rfc4648>。"
    },
    {
      "indent": 3,
      "text": "[RFC5226] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 5226, DOI 10.17487/RFC5226, May 2008, <http://www.rfc-editor.org/info/rfc5226>.",
      "ja": "[RFC5226] Narten氏、T.とH. Alvestrand、 \"RFCsにIANA問題部に書くためのガイドライン\"、BCP 26、RFC 5226、DOI 10.17487 / RFC5226、2008年5月、<http://www.rfc-editor.org /情報/ RFC5226>。"
    },
    {
      "indent": 3,
      "text": "[RFC5234] Crocker, D., Ed. and P. Overell, \"Augmented BNF for Syntax Specifications: ABNF\", STD 68, RFC 5234, DOI 10.17487/ RFC5234, January 2008, <http://www.rfc-editor.org/info/rfc5234>.",
      "ja": "[RFC5234]クロッカー、D.、エド。そして、P. Overell、 \"構文仕様のための増大しているBNF：ABNF\"、STD 68、RFC 5234、DOI 10.17487 / RFC5234、2008年1月、<http://www.rfc-editor.org/info/rfc5234>。"
    },
    {
      "indent": 3,
      "text": "[RFC7230] Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing\", RFC 7230, DOI 10.17487/RFC7230, June 2014, <http://www.rfc-editor.org/info/rfc7230>.",
      "ja": "[RFC7230]フィールディング、R.、エド。及びJ. Reschke、編、 \"ハイパーテキスト転送プロトコル（HTTP / 1.1）：メッセージの構文およびルーティング\"、RFC 7230、DOI 10.17487 / RFC7230、2014年6月、<http://www.rfc-editor.org/info/ rfc7230>。"
    },
    {
      "indent": 3,
      "text": "[RFC7231] Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content\", RFC 7231, DOI 10.17487/RFC7231, June 2014, <http://www.rfc-editor.org/info/rfc7231>.",
      "ja": "[RFC7231]フィールディング、R.、エド。そして、J. Reschke、エド、 \"ハイパーテキスト転送プロトコル（HTTP / 1.1）：セマンティクスおよびコンテンツ\"、RFC 7231、DOI 10.17487 / RFC7231、2014年6月、<http://www.rfc-editor.org/info/rfc7231 >。"
    },
    {
      "indent": 3,
      "text": "[RFC7232] Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests\", RFC 7232, DOI 10.17487/RFC7232, June 2014, <http://www.rfc-editor.org/info/rfc7232>.",
      "ja": "[RFC7232]フィールディング、R.、エド。そして、J. Reschke、エド、 \"ハイパーテキスト転送プロトコル（HTTP / 1.1）：条件付きリクエスト\"、RFC 7232、DOI 10.17487 / RFC7232、2014年6月、<http://www.rfc-editor.org/info/rfc7232> 。"
    },
    {
      "indent": 3,
      "text": "[RFC7233] Fielding, R., Ed., Lafon, Y., Ed., and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Range Requests\", RFC 7233, DOI 10.17487/RFC7233, June 2014, <http://www.rfc-editor.org/info/rfc7233>.",
      "ja": "[RFC7233]フィールディング、R.、エド、ラフォン、Y.、エド、及びJ. Reschke、編、 \"ハイパーテキスト転送プロトコル（HTTP / 1.1）：範囲要求\"。。。、RFC 7233、DOI 10.17487 / RFC7233 6月2014年、<http://www.rfc-editor.org/info/rfc7233>。"
    },
    {
      "indent": 3,
      "text": "[RFC7234] Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Caching\", RFC 7234, DOI 10.17487/RFC7234, June 2014, <http://www.rfc-editor.org/info/rfc7234>.",
      "ja": "[RFC7234]フィールディング、R.、エド、ノッティンガム、M.、エド、及びJ. Reschke、編、 \"ハイパーテキスト転送プロトコル（HTTP / 1.1）：キャッシュ\"。。。、RFC 7234、DOI 10.17487 / RFC7234、2014年6月、<http://www.rfc-editor.org/info/rfc7234>。"
    },
    {
      "indent": 3,
      "text": "[RFC7235] Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Authentication\", RFC 7235, DOI 10.17487/RFC7235, June 2014, <http://www.rfc-editor.org/info/rfc7235>.",
      "ja": "[RFC7235]フィールディング、R.、エド。及びJ. Reschke、編、 \"ハイパーテキスト転送プロトコル（HTTP / 1.1）：認証\"、RFC 7235、DOI 10.17487 / RFC7235、2014年6月、<http://www.rfc-editor.org/info/rfc7235>。"
    },
    {
      "indent": 3,
      "text": "[TCP] Postel, J., \"Transmission Control Protocol\", STD 7, RFC 793, DOI 10.17487/RFC0793, September 1981, <http://www.rfc-editor.org/info/rfc793>.",
      "ja": "[TCP]ポステル、J.、 \"伝送制御プロトコル\"、STD 7、RFC 793、DOI 10.17487 / RFC0793、1981年9月、<http://www.rfc-editor.org/info/rfc793>。"
    },
    {
      "indent": 3,
      "text": "[TLS-ALPN] Friedl, S., Popov, A., Langley, A., and E. Stephan, \"Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension\", RFC 7301, DOI 10.17487/RFC7301, July 2014, <http://www.rfc-editor.org/info/rfc7301>.",
      "ja": "[TLS-ALPN] Friedlの、S.、ポポフ、A.、ラングレー、A.、およびE.ステファン、 \"トランスポート層セキュリティ（TLS）アプリケーション層プロトコルネゴシエーション拡張\"、RFC 7301、DOI 10.17487 / RFC7301、2014年7月、<http://www.rfc-editor.org/info/rfc7301>。"
    },
    {
      "indent": 3,
      "text": "[TLS-ECDHE] Rescorla, E., \"TLS Elliptic Curve Cipher Suites with SHA-256/384 and AES Galois Counter Mode (GCM)\", RFC 5289, DOI 10.17487/RFC5289, August 2008, <http://www.rfc-editor.org/info/rfc5289>.",
      "ja": "[TLS-ECDHE]レスコラ、E.、RFC 5289、DOI 10.17487 / RFC5289、2008年8月 \"SHA-256/384およびAESガロアカウンタモード（GCM）とTLS楕円曲線暗号スイート\"、<のhttp：// WWW。 rfc-editor.org/info/rfc5289>。"
    },
    {
      "indent": 3,
      "text": "[TLS-EXT] Eastlake 3rd, D., \"Transport Layer Security (TLS) Extensions: Extension Definitions\", RFC 6066, DOI 10.17487/RFC6066, January 2011, <http://www.rfc-editor.org/info/rfc6066>.",
      "ja": "[TLS-EXT]イーストレイク3日、D.、 \"トランスポート層セキュリティ（TLS）拡張機能：拡張定義\"、RFC 6066、DOI 10.17487 / RFC6066、2011年1月、<http://www.rfc-editor.org/info/ rfc6066>。"
    },
    {
      "indent": 3,
      "text": "[TLS12] Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS) Protocol Version 1.2\", RFC 5246, DOI 10.17487/ RFC5246, August 2008, <http://www.rfc-editor.org/info/rfc5246>.",
      "ja": "[TLS12]ダークス、T.およびE.レスコラ、 \"トランスポート層セキュリティ（TLS）プロトコルバージョン1.2\"、RFC 5246、DOI 10.17487 / RFC5246、2008年8月、<http://www.rfc-editor.org/info / RFC5246>。"
    },
    {
      "indent": 0,
      "text": "12.2. Informative References",
      "section_title": true,
      "ja": "12.2. 参考文献"
    },
    {
      "indent": 3,
      "text": "[ALT-SVC] Nottingham, M., McManus, P., and J. Reschke, \"HTTP Alternative Services\", Work in Progress, draft-ietf-httpbis-alt-svc-06, February 2015.",
      "ja": "[ALT-SVC]ノッティンガム、M.、マクマナス、P.、およびJ. Reschke、 \"HTTPオルタナティブ・サービス\" が進行中で働いて、ドラフト-IETF-httpbis-ALT-SVC-06、2015年2月。"
    },
    {
      "indent": 3,
      "text": "[BCP90] Klyne, G., Nottingham, M., and J. Mogul, \"Registration Procedures for Message Header Fields\", BCP 90, RFC 3864, September 2004, <http://www.rfc-editor.org/info/bcp90>.",
      "ja": "[BCP90] Klyne、G.、ノッティンガム、M.、およびJ.モーグル、 \"メッセージヘッダフィールドの登録手順\"、BCP 90、RFC 3864、2004年9月、<http://www.rfc-editor.org/info / bcp90>。"
    },
    {
      "indent": 3,
      "text": "[BREACH] Gluck, Y., Harris, N., and A. Prado, \"BREACH: Reviving the CRIME Attack\", July 2013, <http://breachattack.com/resources/ BREACH%20-%20SSL,%20gone%20in%2030%20seconds.pdf>.",
      "ja": "[違反]グルック、Y.、ハリス、N.、およびA.プラドは、 \"違反：CRIME攻撃を復活\"、2013年7月、<http://breachattack.com/resources/ブリーチ％20-％の20SSL％の20gone ％20IN％2030パーセント20seconds.pdf>。"
    },
    {
      "indent": 3,
      "text": "[HTML5] Hickson, I., Berjon, R., Faulkner, S., Leithead, T., Doyle Navara, E., O'Connor, E., and S. Pfeiffer, \"HTML5\", W3C Recommendation REC-html5-20141028, October 2014, <http://www.w3.org/TR/2014/REC-html5-20141028/>.",
      "ja": "【HTML5】ヒクソン、I.、ベルジョン、R.、フォークナー、S.、Leithead、T.、ドイルナバラ、E.、オコナー、E.、およびS.ファイファー、 \"HTML5\"、W3C勧告REC-HTML5 -20141028、2014年10月、<http://www.w3.org/TR/2014/REC-html5-20141028/>。"
    },
    {
      "indent": 3,
      "text": "[RFC3749] Hollenbeck, S., \"Transport Layer Security Protocol Compression Methods\", RFC 3749, DOI 10.17487/RFC3749, May 2004, <http://www.rfc-editor.org/info/rfc3749>.",
      "ja": "[RFC3749]ホレンベック、S.、 \"トランスポート層セキュリティプロトコル圧縮方法\"、RFC 3749、DOI 10.17487 / RFC3749、2004年5月、<http://www.rfc-editor.org/info/rfc3749>。"
    },
    {
      "indent": 3,
      "text": "[RFC4492] Blake-Wilson, S., Bolyard, N., Gupta, V., Hawk, C., and B. Moeller, \"Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS)\", RFC 4492, DOI 10.17487/RFC4492, May 2006, <http://www.rfc-editor.org/info/rfc4492>.",
      "ja": "[RFC4492]ブレイク・ウィルソン、S.、Bolyard、N.、グプタ、V.、ホーク、C.、​​およびB.メラー、 \"楕円曲線暗号（ECC）暗号スイートトランスポート層セキュリティ（TLS）のための\"、RFC 4492 、DOI 10.17487 / RFC4492、2006年5月、<http://www.rfc-editor.org/info/rfc4492>。"
    },
    {
      "indent": 3,
      "text": "[RFC6585] Nottingham, M. and R. Fielding, \"Additional HTTP Status Codes\", RFC 6585, DOI 10.17487/RFC6585, April 2012, <http://www.rfc-editor.org/info/rfc6585>.",
      "ja": "[RFC6585]ノッティンガム、M.とR.フィールディング、 \"追加のHTTPステータスコード\"、RFC 6585、DOI 10.17487 / RFC6585、2012年4月、<http://www.rfc-editor.org/info/rfc6585>。"
    },
    {
      "indent": 3,
      "text": "[RFC7323] Borman, D., Braden, B., Jacobson, V., and R. Scheffenegger, Ed., \"TCP Extensions for High Performance\", RFC 7323, DOI 10.17487/RFC7323, September 2014, <http://www.rfc-editor.org/info/rfc7323>.",
      "ja": "[RFC7323]ボーマン、D.、ブレーデン、B.、ヤコブソン、V.、およびR. Scheffenegger、エド、 \"ハイパフォーマンスのためのTCP拡張\"、RFC 7323、DOI 10.17487 / RFC7323、2014年9月、<のhttp：// www.rfc-editor.org/info/rfc7323>。"
    },
    {
      "indent": 3,
      "text": "[TALKING] Huang, L., Chen, E., Barth, A., Rescorla, E., and C. Jackson, \"Talking to Yourself for Fun and Profit\", 2011, <http://w2spconf.com/2011/papers/websocket.pdf>.",
      "ja": "[TALKING]黄、L.、チェン、E.、バース、A.、 \"楽しさと利益のために自分自身に話す\" レスコラ、E.、およびC.ジャクソン、2011年、<http://w2spconf.com/2011 /papers/websocket.pdf>。"
    },
    {
      "indent": 3,
      "text": "[TLSBCP] Sheffer, Y., Holz, R., and P. Saint-Andre, \"Recommendations for Secure Use of Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)\", BCP 195, RFC 7525, DOI 10.17487/RFC7525, May 2015, <http://www.rfc-editor.org/info/rfc7525>.",
      "ja": "[TLSBCP]シェファー、Y.、ホルツ、R.、およびP.サンアンドレ、 \"トランスポート層セキュリティ（TLS）およびデータグラムトランスポート層セキュリティ（DTLS）のセキュアな利用のための提言\"、BCP 195、RFC 7525、DOI 10.17487 / RFC7525、2015年5月、<http://www.rfc-editor.org/info/rfc7525>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. TLS 1.2 Cipher Suite Black List",
      "ja": "付録A. TLS 1.2暗号スイートのブラックリスト"
    },
    {
      "indent": 3,
      "text": "An HTTP/2 implementation MAY treat the negotiation of any of the following cipher suites with TLS 1.2 as a connection error (Section 5.4.1) of type INADEQUATE_SECURITY:",
      "ja": "HTTP / 2の実装は、型INADEQUATE_SECURITYの接続エラー（5.4.1項）としてTLS 1.2と、次の暗号スイートのいずれかの交渉を扱うことがあります。"
    },
    {
      "indent": 3,
      "text": "o TLS_NULL_WITH_NULL_NULL",
      "ja": "O TLS_NULL_WITH_NULL_NULL"
    },
    {
      "indent": 3,
      "text": "o TLS_RSA_WITH_NULL_MD5",
      "ja": "O TLS_RSA_WITH_NULL_MD5"
    },
    {
      "indent": 3,
      "text": "o TLS_RSA_WITH_NULL_SHA",
      "ja": "O TLS_RSA_WITH_NULL_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_RSA_EXPORT_WITH_RC4_40_MD5",
      "ja": "O TLS_RSA_EXPORT_WITH_RC4_40_MD5"
    },
    {
      "indent": 3,
      "text": "o TLS_RSA_WITH_RC4_128_MD5",
      "ja": "O TLS_RSA_WITH_RC4_128_MD5"
    },
    {
      "indent": 3,
      "text": "o TLS_RSA_WITH_RC4_128_SHA",
      "ja": "O TLS_RSA_WITH_RC4_128_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5",
      "ja": "O TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5"
    },
    {
      "indent": 3,
      "text": "o TLS_RSA_WITH_IDEA_CBC_SHA",
      "ja": "O TLS_RSA_WITH_IDEA_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_RSA_EXPORT_WITH_DES40_CBC_SHA",
      "ja": "O TLS_RSA_EXPORT_WITH_DES40_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_RSA_WITH_DES_CBC_SHA",
      "ja": "O TLS_RSA_WITH_DES_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_RSA_WITH_3DES_EDE_CBC_SHA",
      "ja": "O TLS_RSA_WITH_3DES_EDE_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA",
      "ja": "O TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_DH_DSS_WITH_DES_CBC_SHA",
      "ja": "O TLS_DH_DSS_WITH_DES_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA",
      "ja": "O TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA",
      "ja": "O TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_DH_RSA_WITH_DES_CBC_SHA",
      "ja": "O TLS_DH_RSA_WITH_DES_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA",
      "ja": "O TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA",
      "ja": "O TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_DHE_DSS_WITH_DES_CBC_SHA",
      "ja": "O TLS_DHE_DSS_WITH_DES_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA",
      "ja": "O TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA o TLS_DHE_RSA_WITH_DES_CBC_SHA",
      "ja": "O TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA O TLS_DHE_RSA_WITH_DES_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA",
      "ja": "O TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_DH_anon_EXPORT_WITH_RC4_40_MD5",
      "ja": "O TLS_DH_anon_EXPORT_WITH_RC4_40_MD5"
    },
    {
      "indent": 3,
      "text": "o TLS_DH_anon_WITH_RC4_128_MD5",
      "ja": "O TLS_DH_anon_WITH_RC4_128_MD5"
    },
    {
      "indent": 3,
      "text": "o TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA",
      "ja": "O TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_DH_anon_WITH_DES_CBC_SHA",
      "ja": "TLS_DH_anon_WITH_DES_CBC_SHAから"
    },
    {
      "indent": 3,
      "text": "o TLS_DH_anon_WITH_3DES_EDE_CBC_SHA",
      "ja": "O TLS_DH_anon_WITH_3DES_EDE_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_KRB5_WITH_DES_CBC_SHA",
      "ja": "O TLS_KRB5_WITH_DES_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_KRB5_WITH_3DES_EDE_CBC_SHA",
      "ja": "O TLS_KRB5_WITH_3DES_EDE_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_KRB5_WITH_RC4_128_SHA",
      "ja": "O TLS_KRB5_WITH_RC4_128_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_KRB5_WITH_IDEA_CBC_SHA",
      "ja": "O TLS_KRB5_WITH_IDEA_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_KRB5_WITH_DES_CBC_MD5",
      "ja": "O TLS_KRB5_WITH_DES_CBC_MD5"
    },
    {
      "indent": 3,
      "text": "o TLS_KRB5_WITH_3DES_EDE_CBC_MD5",
      "ja": "O TLS_KRB5_WITH_3DES_EDE_CBC_MD5"
    },
    {
      "indent": 3,
      "text": "o TLS_KRB5_WITH_RC4_128_MD5",
      "ja": "O TLS_KRB5_WITH_RC4_128_MD5"
    },
    {
      "indent": 3,
      "text": "o TLS_KRB5_WITH_IDEA_CBC_MD5",
      "ja": "O TLS_KRB5_WITH_IDEA_CBC_MD5"
    },
    {
      "indent": 3,
      "text": "o TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA",
      "ja": "O TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA",
      "ja": "O TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_KRB5_EXPORT_WITH_RC4_40_SHA",
      "ja": "O TLS_KRB5_EXPORT_WITH_RC4_40_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5",
      "ja": "O TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5"
    },
    {
      "indent": 3,
      "text": "o TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5",
      "ja": "O TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5"
    },
    {
      "indent": 3,
      "text": "o TLS_KRB5_EXPORT_WITH_RC4_40_MD5",
      "ja": "O TLS_KRB5_EXPORT_WITH_RC4_40_MD5"
    },
    {
      "indent": 3,
      "text": "o TLS_PSK_WITH_NULL_SHA",
      "ja": "O TLS_PSK_WITH_NULL_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_DHE_PSK_WITH_NULL_SHA",
      "ja": "O TLS_DHE_PSK_WITH_NULL_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_RSA_PSK_WITH_NULL_SHA o TLS_RSA_WITH_AES_128_CBC_SHA",
      "ja": "O TLS_RSA_PSK_WITH_NULL_SHA O TLS_RSA_WITH_AES_128_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_DH_DSS_WITH_AES_128_CBC_SHA",
      "ja": "O TLS_DH_DSS_WITH_AES_128_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_DH_RSA_WITH_AES_128_CBC_SHA",
      "ja": "O TLS_DH_RSA_WITH_AES_128_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_DHE_DSS_WITH_AES_128_CBC_SHA",
      "ja": "O TLS_DHE_RSA_WITH_AES_128_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_DHE_RSA_WITH_AES_128_CBC_SHA",
      "ja": "O TLS_DHE_RSA_WITH_AES_128_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_DH_anon_WITH_AES_128_CBC_SHA",
      "ja": "O TLS_DH_anon_WITH_AES_128_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_RSA_WITH_AES_256_CBC_SHA",
      "ja": "O TLS_RSA_WITH_AES_256_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_DH_DSS_WITH_AES_256_CBC_SHA",
      "ja": "O TLS_DH_DSS_WITH_AES_256_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_DH_RSA_WITH_AES_256_CBC_SHA",
      "ja": "O TLS_DHE_RSA_WITH_AES_256_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_DHE_DSS_WITH_AES_256_CBC_SHA",
      "ja": "O TLS_DHE_DSS_WITH_AES_256_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_DHE_RSA_WITH_AES_256_CBC_SHA",
      "ja": "O TLS_DHE_RSA_WITH_AES_256_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_DH_anon_WITH_AES_256_CBC_SHA",
      "ja": "O TLS_DH_anon_WITH_AES_256_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_RSA_WITH_NULL_SHA256",
      "ja": "O TLS_RSA_WITH_NULL_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_RSA_WITH_AES_128_CBC_SHA256",
      "ja": "O TLS_RSA_WITH_AES_128_CBC_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_RSA_WITH_AES_256_CBC_SHA256",
      "ja": "O TLS_RSA_WITH_AES_256_CBC_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_DH_DSS_WITH_AES_128_CBC_SHA256",
      "ja": "O TLS_DH_DSS_WITH_AES_128_CBC_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_DH_RSA_WITH_AES_128_CBC_SHA256",
      "ja": "O TLS_DHE_RSA_WITH_AES_128_CBC_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_DHE_DSS_WITH_AES_128_CBC_SHA256",
      "ja": "O TLS_DHE_DSS_WITH_AES_128_CBC_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_RSA_WITH_CAMELLIA_128_CBC_SHA",
      "ja": "O TLS_RSA_WITH_CAMELLIA_128_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA",
      "ja": "O TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA",
      "ja": "O TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA",
      "ja": "O TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA",
      "ja": "O TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA o TLS_DHE_RSA_WITH_AES_128_CBC_SHA256",
      "ja": "TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHAからTLS_DHE_RSA_WITH_AES_128_CBC_SHA256から"
    },
    {
      "indent": 3,
      "text": "o TLS_DH_DSS_WITH_AES_256_CBC_SHA256",
      "ja": "O TLS_DH_DSS_WITH_AES_256_CBC_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_DH_RSA_WITH_AES_256_CBC_SHA256",
      "ja": "O TLS_DHE_RSA_WITH_AES_256_CBC_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_DHE_DSS_WITH_AES_256_CBC_SHA256",
      "ja": "O TLS_DHE_DSS_WITH_AES_256_CBC_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_DHE_RSA_WITH_AES_256_CBC_SHA256",
      "ja": "O TLS_DHE_RSA_WITH_AES_256_CBC_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_DH_anon_WITH_AES_128_CBC_SHA256",
      "ja": "O TLS_DH_anon_WITH_AES_128_CBC_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_DH_anon_WITH_AES_256_CBC_SHA256",
      "ja": "O TLS_DH_anon_WITH_AES_256_CBC_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_RSA_WITH_CAMELLIA_256_CBC_SHA",
      "ja": "O TLS_RSA_WITH_CAMELLIA_256_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA",
      "ja": "O TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA",
      "ja": "O TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA",
      "ja": "O TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA",
      "ja": "O TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA",
      "ja": "O TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_PSK_WITH_RC4_128_SHA",
      "ja": "O TLS_PSK_WITH_RC4_128_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_PSK_WITH_3DES_EDE_CBC_SHA",
      "ja": "O TLS_PSK_WITH_3DES_EDE_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_PSK_WITH_AES_128_CBC_SHA",
      "ja": "O TLS_PSK_WITH_AES_128_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_PSK_WITH_AES_256_CBC_SHA",
      "ja": "O TLS_PSK_WITH_AES_256_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_DHE_PSK_WITH_RC4_128_SHA",
      "ja": "O TLS_DHE_PSK_WITH_RC4_128_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA",
      "ja": "O TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_DHE_PSK_WITH_AES_128_CBC_SHA",
      "ja": "O TLS_DHE_PSK_WITH_AES_128_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_DHE_PSK_WITH_AES_256_CBC_SHA",
      "ja": "O TLS_DHE_PSK_WITH_AES_256_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_RSA_PSK_WITH_RC4_128_SHA",
      "ja": "O TLS_RSA_PSK_WITH_RC4_128_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA",
      "ja": "O TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_RSA_PSK_WITH_AES_128_CBC_SHA o TLS_RSA_PSK_WITH_AES_256_CBC_SHA",
      "ja": "O TLS_RSA_PSK_WITH_AES_128_CBC_SHA O TLS_RSA_PSK_WITH_AES_256_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_RSA_WITH_SEED_CBC_SHA",
      "ja": "O TLS_RSA_WITH_SEED_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_DH_DSS_WITH_SEED_CBC_SHA",
      "ja": "O TLS_DH_DSS_WITH_SEED_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_DH_RSA_WITH_SEED_CBC_SHA",
      "ja": "O TLS_DH_RSA_WITH_SEED_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_DHE_DSS_WITH_SEED_CBC_SHA",
      "ja": "O TLS_DHE_DSS_WITH_SEED_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_DHE_RSA_WITH_SEED_CBC_SHA",
      "ja": "O TLS_DHE_RSA_WITH_SEED_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_DH_anon_WITH_SEED_CBC_SHA",
      "ja": "O TLS_DH_anon_WITH_SEED_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_RSA_WITH_AES_128_GCM_SHA256",
      "ja": "O TLS_RSA_WITH_AES_128_GCM_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_RSA_WITH_AES_256_GCM_SHA384",
      "ja": "O TLS_RSA_WITH_AES_256_GCM_SHA384"
    },
    {
      "indent": 3,
      "text": "o TLS_DH_RSA_WITH_AES_128_GCM_SHA256",
      "ja": "O TLS_DHE_RSA_WITH_AES_128_GCM_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_DH_RSA_WITH_AES_256_GCM_SHA384",
      "ja": "O TLS_DHE_RSA_WITH_AES_256_GCM_SHA384"
    },
    {
      "indent": 3,
      "text": "o TLS_DH_DSS_WITH_AES_128_GCM_SHA256",
      "ja": "O TLS_DH_DSS_WITH_AES_128_GCM_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_DH_DSS_WITH_AES_256_GCM_SHA384",
      "ja": "O TLS_DH_DSS_WITH_AES_256_GCM_SHA384"
    },
    {
      "indent": 3,
      "text": "o TLS_DH_anon_WITH_AES_128_GCM_SHA256",
      "ja": "O TLS_DH_anon_WITH_AES_128_GCM_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_DH_anon_WITH_AES_256_GCM_SHA384",
      "ja": "O TLS_DH_anon_WITH_AES_256_GCM_SHA384"
    },
    {
      "indent": 3,
      "text": "o TLS_PSK_WITH_AES_128_GCM_SHA256",
      "ja": "O TLS_PSK_WITH_AES_128_GCM_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_PSK_WITH_AES_256_GCM_SHA384",
      "ja": "O TLS_PSK_WITH_AES_256_GCM_SHA384"
    },
    {
      "indent": 3,
      "text": "o TLS_RSA_PSK_WITH_AES_128_GCM_SHA256",
      "ja": "O TLS_RSA_PSK_WITH_AES_128_GCM_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_RSA_PSK_WITH_AES_256_GCM_SHA384",
      "ja": "O TLS_RSA_PSK_WITH_AES_256_GCM_SHA384"
    },
    {
      "indent": 3,
      "text": "o TLS_PSK_WITH_AES_128_CBC_SHA256",
      "ja": "O TLS_PSK_WITH_AES_128_CBC_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_PSK_WITH_AES_256_CBC_SHA384",
      "ja": "O TLS_PSK_WITH_AES_256_CBC_SHA384"
    },
    {
      "indent": 3,
      "text": "o TLS_PSK_WITH_NULL_SHA256",
      "ja": "O TLS_PSK_WITH_NULL_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_PSK_WITH_NULL_SHA384",
      "ja": "O TLS_PSK_WITH_NULL_SHA384"
    },
    {
      "indent": 3,
      "text": "o TLS_DHE_PSK_WITH_AES_128_CBC_SHA256 o TLS_DHE_PSK_WITH_AES_256_CBC_SHA384",
      "ja": "O TLS_DHE_PSK_WITH_AES_128_CBC_SHA256 O TLS_DHE_PSK_WITH_AES_256_CBC_SHA384"
    },
    {
      "indent": 3,
      "text": "o TLS_DHE_PSK_WITH_NULL_SHA256",
      "ja": "O TLS_DHE_PSK_WITH_NULL_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_DHE_PSK_WITH_NULL_SHA384",
      "ja": "O TLS_DHE_PSK_WITH_NULL_SHA384"
    },
    {
      "indent": 3,
      "text": "o TLS_RSA_PSK_WITH_AES_128_CBC_SHA256",
      "ja": "O TLS_RSA_PSK_WITH_AES_128_CBC_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_RSA_PSK_WITH_AES_256_CBC_SHA384",
      "ja": "O TLS_RSA_PSK_WITH_AES_256_CBC_SHA384"
    },
    {
      "indent": 3,
      "text": "o TLS_RSA_PSK_WITH_NULL_SHA256",
      "ja": "O TLS_RSA_PSK_WITH_NULL_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_RSA_PSK_WITH_NULL_SHA384",
      "ja": "O TLS_RSA_PSK_WITH_NULL_SHA384"
    },
    {
      "indent": 3,
      "text": "o TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256",
      "ja": "O TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256",
      "ja": "O TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256",
      "ja": "O TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256",
      "ja": "O TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256",
      "ja": "O TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256",
      "ja": "O TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256",
      "ja": "O TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256",
      "ja": "O TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256",
      "ja": "O TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256",
      "ja": "O TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256",
      "ja": "O TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256",
      "ja": "O TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_EMPTY_RENEGOTIATION_INFO_SCSV",
      "ja": "O TLS_EMPTY_RENEGOTIATION_INFO_SCSV"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDH_ECDSA_WITH_NULL_SHA",
      "ja": "O TLS_ECDH_ECDSA_WITH_NULL_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDH_ECDSA_WITH_RC4_128_SHA",
      "ja": "O TLS_ECDH_ECDSA_WITH_RC4_128_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA",
      "ja": "O TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA o TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA",
      "ja": "O TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA O TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDHE_ECDSA_WITH_NULL_SHA",
      "ja": "O TLS_ECDHE_ECDSA_WITH_NULL_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDHE_ECDSA_WITH_RC4_128_SHA",
      "ja": "O TLS_ECDHE_ECDSA_WITH_RC4_128_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA",
      "ja": "O TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA",
      "ja": "O TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA",
      "ja": "O TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDH_RSA_WITH_NULL_SHA",
      "ja": "O TLS_ECDH_RSA_WITH_NULL_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDH_RSA_WITH_RC4_128_SHA",
      "ja": "O TLS_ECDHE_RSA_WITH_RC4_128_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA",
      "ja": "O TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDH_RSA_WITH_AES_128_CBC_SHA",
      "ja": "O TLS_ECDH_RSA_WITH_AES_128_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDH_RSA_WITH_AES_256_CBC_SHA",
      "ja": "O TLS_ECDH_RSA_WITH_AES_256_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDHE_RSA_WITH_NULL_SHA",
      "ja": "O TLS_ECDHE_RSA_WITH_NULL_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDHE_RSA_WITH_RC4_128_SHA",
      "ja": "O TLS_ECDHE_RSA_WITH_RC4_128_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA",
      "ja": "O TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA",
      "ja": "O TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA",
      "ja": "O TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDH_anon_WITH_NULL_SHA",
      "ja": "O TLS_ECDH_anon_WITH_NULL_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDH_anon_WITH_RC4_128_SHA",
      "ja": "O TLS_ECDH_anon_WITH_RC4_128_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA",
      "ja": "O TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDH_anon_WITH_AES_128_CBC_SHA",
      "ja": "O TLS_ECDH_anon_WITH_AES_128_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDH_anon_WITH_AES_256_CBC_SHA",
      "ja": "O TLS_ECDH_anon_WITH_AES_256_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA",
      "ja": "O TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA",
      "ja": "O TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA o TLS_SRP_SHA_WITH_AES_128_CBC_SHA",
      "ja": "O TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA O TLS_SRP_SHA_WITH_AES_128_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA",
      "ja": "O TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA",
      "ja": "O TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_SRP_SHA_WITH_AES_256_CBC_SHA",
      "ja": "O TLS_SRP_SHA_WITH_AES_256_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA",
      "ja": "O TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA",
      "ja": "O TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256",
      "ja": "O TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384",
      "ja": "O TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256",
      "ja": "O TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384",
      "ja": "O TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256",
      "ja": "O TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384",
      "ja": "O TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256",
      "ja": "O TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384",
      "ja": "O TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256",
      "ja": "O TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384",
      "ja": "O TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256",
      "ja": "O TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384",
      "ja": "O TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDHE_PSK_WITH_RC4_128_SHA",
      "ja": "O TLS_ECDHE_PSK_WITH_RC4_128_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA",
      "ja": "O TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA",
      "ja": "O TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA",
      "ja": "O TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256",
      "ja": "O TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384 o TLS_ECDHE_PSK_WITH_NULL_SHA",
      "ja": "O TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384 O TLS_ECDHE_PSK_WITH_NULL_SHA"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDHE_PSK_WITH_NULL_SHA256",
      "ja": "O TLS_ECDHE_PSK_WITH_NULL_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDHE_PSK_WITH_NULL_SHA384",
      "ja": "O TLS_ECDHE_PSK_WITH_NULL_SHA384"
    },
    {
      "indent": 3,
      "text": "o TLS_RSA_WITH_ARIA_128_CBC_SHA256",
      "ja": "O TLS_RSA_WITH_AES_128_CBC_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_RSA_WITH_ARIA_256_CBC_SHA384",
      "ja": "O TLS_RSA_WITH_ARIA_256_CBC_SHA384"
    },
    {
      "indent": 3,
      "text": "o TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256",
      "ja": "O TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384",
      "ja": "O TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384"
    },
    {
      "indent": 3,
      "text": "o TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256",
      "ja": "O TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384",
      "ja": "O TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384"
    },
    {
      "indent": 3,
      "text": "o TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256",
      "ja": "O TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384",
      "ja": "O TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384"
    },
    {
      "indent": 3,
      "text": "o TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256",
      "ja": "TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256から"
    },
    {
      "indent": 3,
      "text": "o TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384",
      "ja": "O TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384"
    },
    {
      "indent": 3,
      "text": "o TLS_DH_anon_WITH_ARIA_128_CBC_SHA256",
      "ja": "O TLS_DH_anon_WITH_ARIA_128_CBC_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_DH_anon_WITH_ARIA_256_CBC_SHA384",
      "ja": "O TLS_DH_anon_WITH_ARIA_256_CBC_SHA384"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256",
      "ja": "O TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384",
      "ja": "O TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256",
      "ja": "O TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384",
      "ja": "O TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256",
      "ja": "O TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384",
      "ja": "O TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256",
      "ja": "O TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384",
      "ja": "O TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384"
    },
    {
      "indent": 3,
      "text": "o TLS_RSA_WITH_ARIA_128_GCM_SHA256 o TLS_RSA_WITH_ARIA_256_GCM_SHA384",
      "ja": "O TLS_RSA_WITH_ARIA_128_GCM_SHA256 O TLS_RSA_WITH_ARIA_256_GCM_SHA384"
    },
    {
      "indent": 3,
      "text": "o TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256",
      "ja": "O TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384",
      "ja": "O TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384"
    },
    {
      "indent": 3,
      "text": "o TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256",
      "ja": "O TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384",
      "ja": "O TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384"
    },
    {
      "indent": 3,
      "text": "o TLS_DH_anon_WITH_ARIA_128_GCM_SHA256",
      "ja": "O TLS_DH_anon_WITH_ARIA_128_GCM_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_DH_anon_WITH_ARIA_256_GCM_SHA384",
      "ja": "O TLS_DH_anon_WITH_ARIA_256_GCM_SHA384"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256",
      "ja": "O TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384",
      "ja": "O TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256",
      "ja": "O TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384",
      "ja": "O TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384"
    },
    {
      "indent": 3,
      "text": "o TLS_PSK_WITH_ARIA_128_CBC_SHA256",
      "ja": "O TLS_PSK_WITH_ARIA_128_CBC_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_PSK_WITH_ARIA_256_CBC_SHA384",
      "ja": "O TLS_PSK_WITH_ARIA_256_CBC_SHA384"
    },
    {
      "indent": 3,
      "text": "o TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256",
      "ja": "O TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384",
      "ja": "O TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384"
    },
    {
      "indent": 3,
      "text": "o TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256",
      "ja": "O TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384",
      "ja": "O TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384"
    },
    {
      "indent": 3,
      "text": "o TLS_PSK_WITH_ARIA_128_GCM_SHA256",
      "ja": "O TLS_PSK_WITH_ARIA_128_GCM_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_PSK_WITH_ARIA_256_GCM_SHA384",
      "ja": "O TLS_PSK_WITH_ARIA_256_GCM_SHA384"
    },
    {
      "indent": 3,
      "text": "o TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256",
      "ja": "O TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384",
      "ja": "O TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256",
      "ja": "O TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384",
      "ja": "O TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 o TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384",
      "ja": "O TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 O TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256",
      "ja": "O TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384",
      "ja": "O TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256",
      "ja": "O TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384",
      "ja": "O TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256",
      "ja": "O TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384",
      "ja": "O TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384"
    },
    {
      "indent": 3,
      "text": "o TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256",
      "ja": "O TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384",
      "ja": "O TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384"
    },
    {
      "indent": 3,
      "text": "o TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256",
      "ja": "O TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384",
      "ja": "O TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384"
    },
    {
      "indent": 3,
      "text": "o TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256",
      "ja": "O TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384",
      "ja": "O TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384"
    },
    {
      "indent": 3,
      "text": "o TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256",
      "ja": "O TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384",
      "ja": "O TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256",
      "ja": "O TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384",
      "ja": "O TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256",
      "ja": "O TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384",
      "ja": "O TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384"
    },
    {
      "indent": 3,
      "text": "o TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256",
      "ja": "O TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384",
      "ja": "O TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384"
    },
    {
      "indent": 3,
      "text": "o TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256",
      "ja": "O TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384",
      "ja": "O TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384"
    },
    {
      "indent": 3,
      "text": "o TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256 o TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384",
      "ja": "O TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256 O TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384"
    },
    {
      "indent": 3,
      "text": "o TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256",
      "ja": "O TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384",
      "ja": "O TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384"
    },
    {
      "indent": 3,
      "text": "o TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256",
      "ja": "O TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384",
      "ja": "O TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256",
      "ja": "O TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256"
    },
    {
      "indent": 3,
      "text": "o TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384",
      "ja": "O TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384"
    },
    {
      "indent": 3,
      "text": "o TLS_RSA_WITH_AES_128_CCM",
      "ja": "O TLS_RSA_WITH_AES_128_CCM"
    },
    {
      "indent": 3,
      "text": "o TLS_RSA_WITH_AES_256_CCM",
      "ja": "O TLS_RSA_WITH_AES_256_CCM"
    },
    {
      "indent": 3,
      "text": "o TLS_RSA_WITH_AES_128_CCM_8",
      "ja": "O TLS_RSA_WITH_AES 128_CCM_8"
    },
    {
      "indent": 3,
      "text": "o TLS_RSA_WITH_AES_256_CCM_8",
      "ja": "O TLS_RSA_WITH_AES_256_CCM_8"
    },
    {
      "indent": 3,
      "text": "o TLS_PSK_WITH_AES_128_CCM",
      "ja": "O TLS_PSK_WITH_AES_128_CCM"
    },
    {
      "indent": 3,
      "text": "o TLS_PSK_WITH_AES_256_CCM",
      "ja": "O TLS_PSK_WITH_AES_256_CCM"
    },
    {
      "indent": 3,
      "text": "o TLS_PSK_WITH_AES_128_CCM_8",
      "ja": "O TLS_PSK_WITH_AES_128_CCM_8"
    },
    {
      "indent": 3,
      "text": "o TLS_PSK_WITH_AES_256_CCM_8",
      "ja": "O TLS_PSK_WITH_AES_256_CCM_8"
    },
    {
      "indent": 6,
      "text": "Note: This list was assembled from the set of registered TLS cipher suites at the time of writing. This list includes those cipher suites that do not offer an ephemeral key exchange and those that are based on the TLS null, stream, or block cipher type (as defined in Section 6.2.3 of [TLS12]). Additional cipher suites with these properties could be defined; these would not be explicitly prohibited.",
      "ja": "注：このリストは、執筆時点で登録TLS暗号スイートのセットから組み立てました。このリストは、短期キー交換およびTLSヌル、ストリーム、またはブロック暗号のタイプ（[TLS12]のセクション6.2.3で定義されるように）に基づいているものを提供していないそれらの暗号スイートを含みます。これらの性質を持つ追加の暗号スイートを定義できます。これらは、明示的に禁止されることはありません。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "This document includes substantial input from the following individuals:",
      "ja": "このドキュメントは、以下の個人からの実質的な入力が含まれています。"
    },
    {
      "indent": 3,
      "text": "o Adam Langley, Wan-Teh Chang, Jim Morrison, Mark Nottingham, Alyssa Wilk, Costin Manolache, William Chan, Vitaliy Lvin, Joe Chan, Adam Barth, Ryan Hamilton, Gavin Peters, Kent Alstad, Kevin Lindsay, Paul Amer, Fan Yang, and Jonathan Leighton (SPDY contributors).",
      "ja": "Oアダム・ラングレー、ワン・テー・チャン、ジム・モリソン、マーク・ノッティンガム、アリッサウィルク、コスティンManolache、ウィリアム・チャン、Vitaliy LVIN、ジョー・チャン、アダム・バース、ライアンハミルトン、ギャヴィン・ピーターズ、ケントAlstad、ケビン・リンゼイ、ポール・アメール、ファン・ヤン、とジョナサン・レイトン（SPDYの貢献）。"
    },
    {
      "indent": 3,
      "text": "o Gabriel Montenegro and Willy Tarreau (Upgrade mechanism).",
      "ja": "OガブリエルモンテネグロとウィリーTarreau（アップグレードメカニズム）。"
    },
    {
      "indent": 3,
      "text": "o William Chan, Salvatore Loreto, Osama Mazahir, Gabriel Montenegro, Jitu Padhye, Roberto Peon, and Rob Trace (Flow control).",
      "ja": "Oウィリアム・チャン、サルヴァトーレ・ロレート、オサマMazahir、ガブリエルモンテネグロ、Jitu Padhye、ロベルトペオン、ロブ・トレー​​ス（フロー制御）。"
    },
    {
      "indent": 3,
      "text": "o Mike Bishop (Extensibility).",
      "ja": "Oマイク・ビショップ（拡張性）。"
    },
    {
      "indent": 3,
      "text": "o Mark Nottingham, Julian Reschke, James Snell, Jeff Pinner, Mike Bishop, and Herve Ruellan (Substantial editorial contributions).",
      "ja": "Oマーク・ノッティンガム、ジュリアンReschke、ジェームズ・スネル、ジェフ・ピナー、マイク・ビショップ、そしてエルベRuellan（かなりの社説の貢献）。"
    },
    {
      "indent": 3,
      "text": "o Kari Hurtta, Tatsuhiro Tsujikawa, Greg Wilkins, Poul-Henning Kamp, and Jonathan Thackray.",
      "ja": "OカリHurtta、達広辻川、グレッグ・ウィルキンス、ポール・ヘンイング・カンプ、およびジョナサンサックリー。"
    },
    {
      "indent": 3,
      "text": "o Alexey Melnikov, who was an editor of this document in 2013.",
      "ja": "2013年にこの文書の編集者だったOアレクセイメルニコフ、。"
    },
    {
      "indent": 3,
      "text": "A substantial proportion of Martin's contribution was supported by Microsoft during his employment there.",
      "ja": "マーティンの貢献のかなりの割合は、そこに彼の雇用の間に、マイクロソフトによってサポートされていました。"
    },
    {
      "indent": 3,
      "text": "The Japanese HTTP/2 community provided invaluable contributions, including a number of implementations as well as numerous technical and editorial contributions.",
      "ja": "日本のHTTP / 2コミュニティは、実装の数だけでなく、多くの技術的および編集上の貢献など、非常に貴重な貢献をし、提供します。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Mike Belshe BitGo",
      "ja": "マイクBelshe BitGo"
    },
    {
      "indent": 3,
      "text": "EMail: mike@belshe.com",
      "ja": "メールアドレス：mike@belshe.com"
    },
    {
      "indent": 3,
      "text": "Roberto Peon Google, Inc",
      "ja": "ロベルトペオングーグル株式会社"
    },
    {
      "indent": 3,
      "text": "EMail: fenix@google.com",
      "ja": "メールアドレス：fenix@google.com"
    },
    {
      "indent": 3,
      "text": "Martin Thomson (editor) Mozilla 331 E Evelyn Street Mountain View, CA 94041 United States",
      "ja": "マーティン・トムソン（エディタ）Mozillaの331 Eイヴリン・ストリートマウンテンビュー、CA 94041米国"
    },
    {
      "indent": 3,
      "text": "EMail: martin.thomson@gmail.com",
      "ja": "メールアドレス：martin.thomson@gmail.com"
    }
  ]
}