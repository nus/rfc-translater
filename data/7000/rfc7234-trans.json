{
  "title": {
    "text": "RFC 7234 - Hypertext Transfer Protocol (HTTP/1.1): Caching",
    "ja": "RFC 7234 - ハイパーテキスト転送プロトコル（HTTP / 1.1）：キャッシング"
  },
  "number": 7234,
  "created_at": "2019-10-30 13:34:34.773856+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                  R. Fielding, Ed.\nRequest for Comments: 7234                                         Adobe\nObsoletes: 2616                                       M. Nottingham, Ed.\nCategory: Standards Track                                         Akamai\nISSN: 2070-1721                                          J. Reschke, Ed.\n                                                              greenbytes\n                                                               June 2014",
      "raw": true
    },
    {
      "indent": 12,
      "text": "Hypertext Transfer Protocol (HTTP/1.1): Caching",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems. This document defines HTTP caches and the associated header fields that control cache behavior or indicate cacheable response messages.",
      "ja": "ハイパーテキスト転送プロトコル（HTTP）は、分散、協調、ハイパーテキスト情報システムのためのステートレスなアプリケーションレベルのプロトコルです。この文書では、HTTPキャッシュとキャッシュの動作を制御したり、キャッシュ可能な応答メッセージを示す関連したヘッダーフィールドを定義します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "このメモのステータス"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準化過程文書です。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "ja": "このドキュメントはインターネットエンジニアリングタスクフォース（IETF）の製品です。これは、IETFコミュニティの総意を表しています。これは、公開レビューを受けており、インターネットエンジニアリング運営グループ（IESG）によって公表のために承認されています。インターネット標準の詳細については、RFC 5741のセクション2で利用可能です。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc7234.",
      "ja": "このドキュメントの現在の状態、任意の正誤表、そしてどのようにフィードバックを提供するための情報がhttp://www.rfc-editor.org/info/rfc7234で取得することができます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2014 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2014 IETF信託とドキュメントの作成者として特定の人物。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "この文書では、BCP 78と、この文書の発行日に有効なIETFドキュメント（http://trustee.ietf.org/license-info）に関連IETFトラストの法律の規定に従うものとします。彼らは、この文書に関してあなたの権利と制限を説明するように、慎重にこれらの文書を確認してください。コードコンポーネントは、トラスト法規定のセクションで説明4.eおよび簡体BSDライセンスで説明したように、保証なしで提供されているよう簡体BSDライセンスのテキストを含める必要があり、この文書から抽出されました。"
    },
    {
      "indent": 3,
      "text": "This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.",
      "ja": "この材料の一部がIETFトラストにこのような材料の変更を許可する権利を与えられていない可能性がありますにこの文書は、2008年、IETFドキュメントまたは11月10日以前に発行または公開さIETF貢献から著作権を支配する者（複数可）材料を含んでいてもよいですIETF標準化プロセスの外。そのような材料の著作権を管理者（単数または複数）から適切なライセンスを取得することなく、この文書は、IETF標準化過程の外側修正されないかもしれません、そして、それの派生物は、IETF標準化過程の外側に作成されない場合があり、それをフォーマットする以外出版RFCとして、英語以外の言語に翻訳します。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................4\n   1.1. Conformance and Error Handling .............................4\n   1.2. Syntax Notation ............................................4\n        1.2.1. Delta Seconds .......................................5\n2. Overview of Cache Operation .....................................5\n3. Storing Responses in Caches .....................................6\n   3.1. Storing Incomplete Responses ...............................7\n   3.2. Storing Responses to Authenticated Requests ................7\n   3.3. Combining Partial Content ..................................8\n4. Constructing Responses from Caches ..............................8\n   4.1. Calculating Secondary Keys with Vary .......................9\n   4.2. Freshness .................................................11\n        4.2.1. Calculating Freshness Lifetime .....................12\n        4.2.2. Calculating Heuristic Freshness ....................13\n        4.2.3. Calculating Age ....................................13\n        4.2.4. Serving Stale Responses ............................15\n   4.3. Validation ................................................16\n        4.3.1. Sending a Validation Request .......................16\n        4.3.2. Handling a Received Validation Request .............16",
      "raw": true
    },
    {
      "indent": 3,
      "text": "        4.3.3. Handling a Validation Response .....................18\n        4.3.4. Freshening Stored Responses upon Validation ........18\n        4.3.5. Freshening Responses via HEAD ......................19\n   4.4. Invalidation ..............................................20\n5. Header Field Definitions .......................................21\n   5.1. Age .......................................................21\n   5.2. Cache-Control .............................................21\n        5.2.1. Request Cache-Control Directives ...................22\n        5.2.2. Response Cache-Control Directives ..................24\n        5.2.3. Cache Control Extensions ...........................27\n   5.3. Expires ...................................................28\n   5.4. Pragma ....................................................29\n   5.5. Warning ...................................................29\n        5.5.1. Warning: 110 - \"Response is Stale\" .................31\n        5.5.2. Warning: 111 - \"Revalidation Failed\" ...............31\n        5.5.3. Warning: 112 - \"Disconnected Operation\" ............31\n        5.5.4. Warning: 113 - \"Heuristic Expiration\" ..............31\n        5.5.5. Warning: 199 - \"Miscellaneous Warning\" .............32\n        5.5.6. Warning: 214 - \"Transformation Applied\" ............32\n        5.5.7. Warning: 299 - \"Miscellaneous Persistent Warning\" ..32\n6. History Lists ..................................................32\n7. IANA Considerations ............................................32\n   7.1. Cache Directive Registry ..................................32\n        7.1.1. Procedure ..........................................32\n        7.1.2. Considerations for New Cache Control Directives ....33\n        7.1.3. Registrations ......................................33\n   7.2. Warn Code Registry ........................................34\n        7.2.1. Procedure ..........................................34\n        7.2.2. Registrations ......................................34\n   7.3. Header Field Registration .................................34\n8. Security Considerations ........................................35\n9. Acknowledgments ................................................36\n10. References ....................................................36\n   10.1. Normative References .....................................36\n   10.2. Informative References ...................................37\nAppendix A. Changes from RFC 2616 .................................38\nAppendix B. Imported ABNF .........................................39\nAppendix C. Collected ABNF ........................................39\nIndex .............................................................41",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "HTTP is typically used for distributed information systems, where performance can be improved by the use of response caches. This document defines aspects of HTTP/1.1 related to caching and reusing response messages.",
      "ja": "HTTPは、典型的には、性能が応答キャッシュを使用することによって改善することができる分散情報システムに使用されます。この文書では、キャッシングおよび応答メッセージを再利用に関連するHTTP / 1.1の側面を定義します。"
    },
    {
      "indent": 3,
      "text": "An HTTP cache is a local store of response messages and the subsystem that controls storage, retrieval, and deletion of messages in it. A cache stores cacheable responses in order to reduce the response time and network bandwidth consumption on future, equivalent requests. Any client or server MAY employ a cache, though a cache cannot be used by a server that is acting as a tunnel.",
      "ja": "HTTPキャッシュは、応答メッセージのローカルストアとその内のメッセージの保存、検索、および削除を制御するサブシステムです。キャッシュは、将来、同等の要求の応答時間とネットワーク帯域幅の消費量を削減するために、キャッシュ可能な応答を格納します。キャッシュはトンネルとして動作しているサーバーで使用することはできないものの、任意のクライアントまたはサーバは、キャッシュを使用することができます。"
    },
    {
      "indent": 3,
      "text": "A shared cache is a cache that stores responses to be reused by more than one user; shared caches are usually (but not always) deployed as a part of an intermediary. A private cache, in contrast, is dedicated to a single user; often, they are deployed as a component of a user agent.",
      "ja": "共有キャッシュは、複数のユーザによって再利用される応答を格納するキャッシュです。共有キャッシュは、通常は（常にではない）の仲介の一部として展開します。プライベートキャッシュは、対照的に、単一のユーザーに専用されています。多くの場合、それらはユーザーエージェントのコンポーネントとして配布されています。"
    },
    {
      "indent": 3,
      "text": "The goal of caching in HTTP/1.1 is to significantly improve performance by reusing a prior response message to satisfy a current request. A stored response is considered \"fresh\", as defined in Section 4.2, if the response can be reused without \"validation\" (checking with the origin server to see if the cached response remains valid for this request). A fresh response can therefore reduce both latency and network overhead each time it is reused. When a cached response is not fresh, it might still be reusable if it can be freshened by validation (Section 4.3) or if the origin is unavailable (Section 4.2.4).",
      "ja": "HTTP / 1.1におけるキャッシングの目的は大幅現在の要求を満たすために先立って応答メッセージを再使用することによってパフォーマンスを改善することです。 4.2節で定義された応答は、「検証」することなく、再利用することが可能ならば保存された応答は、（キャッシュされた応答は、この要求のために有効なままかどうかを確認するためにオリジンサーバに確認）、「新鮮な」と考えられています。新鮮な応答は、従って、それが再利用されるたびに、待ち時間、ネットワークのオーバーヘッドの両方を低減することができます。キャッシュされたレスポンスが新鮮でない場合には、それは検証（4.3節）によって、または、原点は（4.2.4項）使用できない場合にマイナーチェンジすることができれば、それはまだ再利用可能であるかもしれません。"
    },
    {
      "indent": 0,
      "text": "1.1. Conformance and Error Handling",
      "section_title": true,
      "ja": "1.1. 適合性とエラー処理"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はあります[RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 3,
      "text": "Conformance criteria and considerations regarding error handling are defined in Section 2.5 of [RFC7230].",
      "ja": "適合基準およびエラー処理についての考察は、[RFC7230]のセクション2.5で定義されています。"
    },
    {
      "indent": 0,
      "text": "1.2. Syntax Notation",
      "section_title": true,
      "ja": "1.2. 構文記法"
    },
    {
      "indent": 3,
      "text": "This specification uses the Augmented Backus-Naur Form (ABNF) notation of [RFC5234] with a list extension, defined in Section 7 of [RFC7230], that allows for compact definition of comma-separated lists using a '#' operator (similar to how the '*' operator indicates repetition). Appendix B describes rules imported from other documents. Appendix C shows the collected grammar with all list operators expanded to standard ABNF notation.",
      "ja": "この仕様は次のように「＃」演算子を使用して、カンマ区切りのリストのコンパクトな定義を可能にする[RFC7230]のセクション7で定義されたリストの拡張子、と[RFC5234]の増補バッカス - ナウアフォーム（ABNF）の表記を（使用しますどのように「*」オペレータ）は繰り返しを示します。付録Bは、他の文書からインポートルールを説明します。付録Cには、標準のABNF表記に展開すべてのリスト演算子で収集した文法を示しています。"
    },
    {
      "indent": 0,
      "text": "1.2.1. Delta Seconds",
      "section_title": true,
      "ja": "1.2.1. デルタ秒"
    },
    {
      "indent": 3,
      "text": "The delta-seconds rule specifies a non-negative integer, representing time in seconds.",
      "ja": "デルタ秒ルールは、秒単位の時間を表す非負の整数を指定します。"
    },
    {
      "indent": 5,
      "text": "delta-seconds = 1*DIGIT",
      "ja": "デルタ秒= 1 * DIGIT"
    },
    {
      "indent": 3,
      "text": "A recipient parsing a delta-seconds value and converting it to binary form ought to use an arithmetic type of at least 31 bits of non-negative integer range. If a cache receives a delta-seconds value greater than the greatest integer it can represent, or if any of its subsequent calculations overflows, the cache MUST consider the value to be either 2147483648 (2^31) or the greatest positive integer it can conveniently represent.",
      "ja": "受信者デルタ秒の値を解析し、バイナリ形式に変換するには、非負整数範囲の少なくとも31ビットの算術型を使用するべきです。キャッシュは、それが表すことができ、又はその後続の計算オーバーフローのいずれかの場合には、キャッシュ値は2147483648（2 ^ 31）、または、それが便利にす​​ることができる最大の正の整数のいずれかであることを考慮しなければならない最大の整数よりデルタ秒値より大きい受信した場合表します。"
    },
    {
      "indent": 6,
      "text": "Note: The value 2147483648 is here for historical reasons, effectively represents infinity (over 68 years), and does not need to be stored in binary form; an implementation could produce it as a canned string if any overflow occurs, even if the calculations are performed with an arithmetic type incapable of directly representing that number. What matters here is that an overflow be detected and not treated as a negative value in later calculations.",
      "ja": "注：値2147483648は、歴史的な理由のためにここであり、効果的に無限（68年以上）を表し、バイナリ形式で格納する必要がありません。オーバーフローが発生した場合、実装は、計算を直接その番号を表すことができない算術型で行っても、缶詰文字列として生成することができます。何ここで重要なのは、オーバーフローが検出され、後の計算で負の値として扱われないことがあります。"
    },
    {
      "indent": 0,
      "text": "2. Overview of Cache Operation",
      "section_title": true,
      "ja": "キャッシュ操作の2の概要"
    },
    {
      "indent": 3,
      "text": "Proper cache operation preserves the semantics of HTTP transfers ([RFC7231]) while eliminating the transfer of information already held in the cache. Although caching is an entirely OPTIONAL feature of HTTP, it can be assumed that reusing a cached response is desirable and that such reuse is the default behavior when no requirement or local configuration prevents it. Therefore, HTTP cache requirements are focused on preventing a cache from either storing a non-reusable response or reusing a stored response inappropriately, rather than mandating that caches always store and reuse particular responses.",
      "ja": "既にキャッシュに保持された情報の転送を排除しつつ、適切なキャッシュ操作は、HTTP転送（[RFC7231]）のセマンティクスを維持します。キャッシングは、HTTPの完全オプション機能であるが、キャッシュされた応答を再利用することが望ましい、そのような再利用がない要件またはローカル設定がそれを妨げるものはない場合、デフォルトの動作であると仮定することができます。したがって、HTTPキャッシュの要件は、非再使用可能な応答を記憶又は不適切に保存された応答を再利用するのではなく、キャッシュは常に特定の応答を保存し再利用することを義務付けるのいずれかからキャッシュを防ぐことに重点を置いています。"
    },
    {
      "indent": 3,
      "text": "Each cache entry consists of a cache key and one or more HTTP responses corresponding to prior requests that used the same key. The most common form of cache entry is a successful result of a retrieval request: i.e., a 200 (OK) response to a GET request, which contains a representation of the resource identified by the request target (Section 4.3.1 of [RFC7231]). However, it is also possible to cache permanent redirects, negative results (e.g., 404 (Not Found)), incomplete results (e.g., 206 (Partial Content)), and responses to methods other than GET if the method's definition allows such caching and defines something suitable for use as a cache key.",
      "ja": "各キャッシュエントリがキャッシュキーと同じキーを使用する前の要求に対応する1つ以上のHTTP応答で構成されています。キャッシュ・エントリの最も一般的な形態は、検索要求の成功した結果である：すなわち、要求対象（セクション4.3.1によって識別されたリソースの表現を含むGETリクエスト、200（OK）レスポンス[RFC7231] ）。メソッドの定義は、このようなキャッシュを許可した場合しかし、永久的なリダイレクト、陰性の結果（例えば、404（見つかりません））、不完全な結果（例えば、206（部分コンテンツ））、およびGET以外のメソッドへの応答をキャッシュすることも可能であり、キャッシュキーとして使用するのに適したものを定義します。"
    },
    {
      "indent": 3,
      "text": "The primary cache key consists of the request method and target URI. However, since HTTP caches in common use today are typically limited to caching responses to GET, many caches simply decline other methods and use only the URI as the primary cache key.",
      "ja": "一次キャッシュキーは、リクエストメソッドとターゲットURIで構成されています。一般的に使用されているHTTPキャッシュ今日は通常GETにキャッシュ応答に限定されているので、多くのキャッシュは、単に他の方法を辞退し、一次キャッシュキーとしてのみURIを使用します。"
    },
    {
      "indent": 3,
      "text": "If a request target is subject to content negotiation, its cache entry might consist of multiple stored responses, each differentiated by a secondary key for the values of the original request's selecting header fields (Section 4.1).",
      "ja": "要求対象コンテンツネゴシエーションの対象である場合、そのキャッシュ・エントリは、それぞれが元の要求の選択ヘッダフィールド（セクション4.1）の値に対するセカンダリキーによって区別、複数の記憶された応答から成るかもしれません。"
    },
    {
      "indent": 0,
      "text": "3. Storing Responses in Caches",
      "section_title": true,
      "ja": "3.キャッシュ内の応答を保存します"
    },
    {
      "indent": 3,
      "text": "A cache MUST NOT store a response to any request, unless:",
      "ja": "キャッシュがない限り、任意の要求に対する応答を格納してはなりません："
    },
    {
      "indent": 3,
      "text": "o The request method is understood by the cache and defined as being cacheable, and",
      "ja": "リクエストメソッドがキャッシュに理解及びキャッシュ可能であると定義され、O"
    },
    {
      "indent": 3,
      "text": "o the response status code is understood by the cache, and",
      "ja": "応答ステータスコードがキャッシュに理解され、O、及び"
    },
    {
      "indent": 3,
      "text": "o the \"no-store\" cache directive (see Section 5.2) does not appear in request or response header fields, and",
      "ja": "「無店舗」キャッシュディレクティブO（5.2節を参照）を要求または応答ヘッダフィールドに表示されない、と"
    },
    {
      "indent": 3,
      "text": "o the \"private\" response directive (see Section 5.2.2.6) does not appear in the response, if the cache is shared, and",
      "ja": "「プライベート」応答指示O（セクション5.2.2.6を参照）キャッシュが共有されている場合、応答には表示されません。また、"
    },
    {
      "indent": 3,
      "text": "o the Authorization header field (see Section 4.2 of [RFC7235]) does not appear in the request, if the cache is shared, unless the response explicitly allows it (see Section 3.2), and",
      "ja": "AuthorizationヘッダフィールドO（[RFC7235]のセクション4.2を参照）キャッシュが共有されている場合、応答は、明示的に（セクション3.2を参照）、それを可能にし、なければ、要求に表示されません"
    },
    {
      "indent": 3,
      "text": "o the response either:",
      "ja": "応答のいずれかO："
    },
    {
      "indent": 6,
      "text": "* contains an Expires header field (see Section 5.3), or",
      "ja": "*含まれているヘッダーフィールド（セクション5.3を参照）が経過、又は"
    },
    {
      "indent": 6,
      "text": "* contains a max-age response directive (see Section 5.2.2.8), or",
      "ja": "*最大エージング応答ディレクティブが含まれています（セクション5.2.2.8を参照）、または"
    },
    {
      "indent": 6,
      "text": "* contains a s-maxage response directive (see Section 5.2.2.9) and the cache is shared, or",
      "ja": "* S-MAXAGE応答ディレクティブが含まれています（セクション5.2.2.9を参照）、キャッシュが共有されている、または"
    },
    {
      "indent": 6,
      "text": "* contains a Cache Control Extension (see Section 5.2.3) that allows it to be cached, or",
      "ja": "*キャッシュ制御、それがキャッシュされることを可能にする拡張（5.2.3項を参照）、またはが含まれています"
    },
    {
      "indent": 6,
      "text": "* has a status code that is defined as cacheable by default (see Section 4.2.2), or",
      "ja": "*デフォルトでキャッシュ可能として定義されているステータスコードを有している（セクション4.2.2参照）、又は"
    },
    {
      "indent": 6,
      "text": "* contains a public response directive (see Section 5.2.2.5).",
      "ja": "*（セクション5.2.2.5を参照）公共応答ディレクティブが含まれています。"
    },
    {
      "indent": 3,
      "text": "Note that any of the requirements listed above can be overridden by a cache-control extension; see Section 5.2.3.",
      "ja": "上記の要件のいずれかが、キャッシュ制御拡張によって上書きすることができることに留意されたいです。 5.2.3項を参照してください。"
    },
    {
      "indent": 3,
      "text": "In this context, a cache has \"understood\" a request method or a response status code if it recognizes it and implements all specified caching-related behavior.",
      "ja": "それを認識し、指定されたすべてのキャッシュに関連する動作を実装する場合は、この文脈では、キャッシュは、要求メソッド又はレスポンスステータスコードを「理解」しています。"
    },
    {
      "indent": 3,
      "text": "Note that, in normal operation, some caches will not store a response that has neither a cache validator nor an explicit expiration time, as such responses are not usually useful to store. However, caches are not prohibited from storing such responses.",
      "ja": "そのような応答は、通常店舗に有用ではないとして、通常の操作では、いくつかのキャッシュは、キャッシュバリデータも明示的な有効期限もない応答を保存しないであろう、ということに注意してください。しかし、キャッシュはそのような応答を保存することは禁止されていません。"
    },
    {
      "indent": 0,
      "text": "3.1. Storing Incomplete Responses",
      "section_title": true,
      "ja": "3.1. 不完全な応答を保存します"
    },
    {
      "indent": 3,
      "text": "A response message is considered complete when all of the octets indicated by the message framing ([RFC7230]) are received prior to the connection being closed. If the request method is GET, the response status code is 200 (OK), and the entire response header section has been received, a cache MAY store an incomplete response message body if the cache entry is recorded as incomplete. Likewise, a 206 (Partial Content) response MAY be stored as if it were an incomplete 200 (OK) cache entry. However, a cache MUST NOT store incomplete or partial-content responses if it does not support the Range and Content-Range header fields or if it does not understand the range units used in those fields.",
      "ja": "メッセージフレーミングによって示されるオクテットのすべて（[RFC7230]）は接続がクローズされる前に受信されたときに応答メッセージが完了したと見なされます。リクエストメソッドがGETである場合、応答ステータスコード200（OK）であり、全体のレスポンスヘッダ部が受信されたキャッシュエントリが不完全として記録されている場合、キャッシュは不完全応答メッセージ本体を格納してもよいです。それは不完全200（OK）キャッシュエントリであるかのように同様に、206（部分コンテンツ）応答が格納されていてもよいです。しかし、それは範囲とContent-Rangeヘッダフィールドをサポートしていない場合はキャッシュが不完全または部分コンテンツ応答保存してはならないか、それは、これらの分野で使用される範囲の単位を理解していない場合。"
    },
    {
      "indent": 3,
      "text": "A cache MAY complete a stored incomplete response by making a subsequent range request ([RFC7233]) and combining the successful response with the stored entry, as defined in Section 3.3. A cache MUST NOT use an incomplete response to answer requests unless the response has been made complete or the request is partial and specifies a range that is wholly within the incomplete response. A cache MUST NOT send a partial response to a client without explicitly marking it as such using the 206 (Partial Content) status code.",
      "ja": "キャッシュは後続の範囲要求（[RFC7233]）を作製し、セクション3.3で定義されるように格納されたエントリで成功応答を、組み合わせて格納された不完全な応答を完了することができます。応答が完全に行われているか、要求が部分的であると完全に不完全な応答の中で範囲を指定しない限り、キャッシュが要求に答えるために、不完全な応答を使用してはなりません。キャッシュは、明示的に206（部分コンテンツ）ステータスコードを使用してそのようにマーキングすることなく、クライアントへの部分的な応答を送ってはいけません。"
    },
    {
      "indent": 0,
      "text": "3.2. Storing Responses to Authenticated Requests",
      "section_title": true,
      "ja": "3.2. 認証要求への応答を保存します"
    },
    {
      "indent": 3,
      "text": "A shared cache MUST NOT use a cached response to a request with an Authorization header field (Section 4.2 of [RFC7235]) to satisfy any subsequent request unless a cache directive that allows such responses to be stored is present in the response.",
      "ja": "共有キャッシュは、応答を格納することを可能にするキャッシュ指示がレスポンス内に存在しない限り、任意の後続の要求を満たすためにAuthorizationヘッダフィールド（[RFC7235]のセクション4.2）を用いて要求にキャッシュされた応答を使用してはいけません。"
    },
    {
      "indent": 3,
      "text": "In this specification, the following Cache-Control response directives (Section 5.2.2) have such an effect: must-revalidate, public, and s-maxage.",
      "ja": "公共、-再検証しなければならない、とs-MAXAGE：本明細書では、以下のCache-Control応答指令（5.2.2項）は、このような効果を持っています。"
    },
    {
      "indent": 3,
      "text": "Note that cached responses that contain the \"must-revalidate\" and/or \"s-maxage\" response directives are not allowed to be served stale (Section 4.2.4) by shared caches. In particular, a response with either \"max-age=0, must-revalidate\" or \"s-maxage=0\" cannot be used to satisfy a subsequent request without revalidating it on the origin server.",
      "ja": "「MUST-再検証」を含む、および/または「S-MAXAGE」応答ディレクティブは、共有キャッシュで古い（4.2.4項）を提供することが許可されていないキャッシュされたことに応答を注意してください。具体的には、どちらかと応答「= 0 MAXAGEは、マスト再検証」または「S-MAXAGE = 0」は、オリジンサーバにそれを再検証することなく、後続の要求を満たすために使用することができません。"
    },
    {
      "indent": 0,
      "text": "3.3. Combining Partial Content",
      "section_title": true,
      "ja": "3.3. 部分コンテンツを組み合わせます"
    },
    {
      "indent": 3,
      "text": "A response might transfer only a partial representation if the connection closed prematurely or if the request used one or more Range specifiers ([RFC7233]). After several such transfers, a cache might have received several ranges of the same representation. A cache MAY combine these ranges into a single stored response, and reuse that response to satisfy later requests, if they all share the same strong validator and the cache complies with the client requirements in Section 4.3 of [RFC7233].",
      "ja": "接続が早期に閉じた場合、または要求は、1つ以上の範囲指定子（[RFC7233]）を使用した場合、応答は、部分的にしか表現を転送するかもしれません。いくつかのような転送の後、キャッシュが同じ表現のいくつかの範囲を受け取っている場合があります。キャッシュは、単一の保存された応答にこれらの範囲を組み合わせ、そしてそれらはすべて同じ強力なバリデータを共有し、キャッシュは[RFC7233]のセクション4.3でクライアントの要件に準拠している場合、以降の要求を満たすためにその応答を再利用することができます。"
    },
    {
      "indent": 3,
      "text": "When combining the new response with one or more stored responses, a cache MUST:",
      "ja": "一つ以上の保存された応答、キャッシュMUSTで新しい応答を組み合わせる場合："
    },
    {
      "indent": 3,
      "text": "o delete any Warning header fields in the stored response with warn-code 1xx (see Section 5.5);",
      "ja": "O警告コード1XXと格納された応答に警告ヘッダフィールドを削除し（セクション5.5を参照）。"
    },
    {
      "indent": 3,
      "text": "o retain any Warning header fields in the stored response with warn-code 2xx; and,",
      "ja": "O警告コード2XXと格納された応答に警告ヘッダフィールドを保持します。そして、"
    },
    {
      "indent": 3,
      "text": "o use other header fields provided in the new response, aside from Content-Range, to replace all instances of the corresponding header fields in the stored response.",
      "ja": "O格納された応答に対応するヘッダフィールドのすべてのインスタンスを置換するコンテンツの範囲は別に、新たな応答して提供される他のヘッダフィールドを使用します。"
    },
    {
      "indent": 0,
      "text": "4. Constructing Responses from Caches",
      "section_title": true,
      "ja": "4.キャッシュからの応答を構築"
    },
    {
      "indent": 3,
      "text": "When presented with a request, a cache MUST NOT reuse a stored response, unless:",
      "ja": "要求を提示すると、キャッシュがない限り、保存された応答を再利用してはいけません。"
    },
    {
      "indent": 3,
      "text": "o The presented effective request URI (Section 5.5 of [RFC7230]) and that of the stored response match, and",
      "ja": "提示有効なリクエストURI（[RFC7230]のセクション5.5）Oおよび記憶された応答が一致すると、および"
    },
    {
      "indent": 3,
      "text": "o the request method associated with the stored response allows it to be used for the presented request, and",
      "ja": "保存された応答に関連するリクエストメソッドは、それが提示要求のために使用されることを可能にO、及び"
    },
    {
      "indent": 3,
      "text": "o selecting header fields nominated by the stored response (if any) match those presented (see Section 4.1), and",
      "ja": "保存された応答（もしあれば）に一致提示者によって指名ヘッダフィールドを選択O（4.1節を参照）、および"
    },
    {
      "indent": 3,
      "text": "o the presented request does not contain the no-cache pragma (Section 5.4), nor the no-cache cache directive (Section 5.2.1), unless the stored response is successfully validated (Section 4.3), and",
      "ja": "提示要求がキャッシュなしプラグマが含まれていませんO（5.4節）、またキャッシュなしのキャッシュディレクティブ（5.2.1）、保存された応答が正常に検証されない限り（4.3節）、および"
    },
    {
      "indent": 3,
      "text": "o the stored response does not contain the no-cache cache directive (Section 5.2.2.2), unless it is successfully validated (Section 4.3), and",
      "ja": "それが正常に検証されない限り、O保存された応答は、キャッシュなしのキャッシュディレクティブ（セクション5.2.2.2）が含まれていない（4.3節）、および"
    },
    {
      "indent": 3,
      "text": "o the stored response is either:",
      "ja": "O保存された応答のいずれかです："
    },
    {
      "indent": 6,
      "text": "* fresh (see Section 4.2), or",
      "ja": "*新鮮な（4.2節を参照）、または"
    },
    {
      "indent": 6,
      "text": "* allowed to be served stale (see Section 4.2.4), or",
      "ja": "*古い提供することを許可（4.2.4項を参照）、または"
    },
    {
      "indent": 6,
      "text": "* successfully validated (see Section 4.3).",
      "ja": "*成功した（4.3節を参照）を検証しました。"
    },
    {
      "indent": 3,
      "text": "Note that any of the requirements listed above can be overridden by a cache-control extension; see Section 5.2.3.",
      "ja": "上記の要件のいずれかが、キャッシュ制御拡張によって上書きすることができることに留意されたいです。 5.2.3項を参照してください。"
    },
    {
      "indent": 3,
      "text": "When a stored response is used to satisfy a request without validation, a cache MUST generate an Age header field (Section 5.1), replacing any present in the response with a value equal to the stored response's current_age; see Section 4.2.3.",
      "ja": "保存された応答を検証することなく、要求を満たすために使用される場合、キャッシュは、記憶された応答者てcurrent_ageに等しい値に応じて、任意に存在する置換、年齢ヘッダフィールド（5.1節）を生成しなければなりません。 4.2.3項を参照してください。"
    },
    {
      "indent": 3,
      "text": "A cache MUST write through requests with methods that are unsafe (Section 4.2.1 of [RFC7231]) to the origin server; i.e., a cache is not allowed to generate a reply to such a request before having forwarded the request and having received a corresponding response.",
      "ja": "キャッシュは、オリジンサーバへ（[RFC7231]のセクション4.2.1）安全でない方法と要求を介して書かなければなりません。すなわち、キャッシュは要求を転送したと対応する応答を受信する前に、このような要求に対する応答を生成することができません。"
    },
    {
      "indent": 3,
      "text": "Also, note that unsafe requests might invalidate already-stored responses; see Section 4.4.",
      "ja": "また、危険なリクエストが既に保存された応答を無効にする可能性があることに注意してください。 4.4節を参照してください。"
    },
    {
      "indent": 3,
      "text": "When more than one suitable response is stored, a cache MUST use the most recent response (as determined by the Date header field). It can also forward the request with \"Cache-Control: max-age=0\" or \"Cache-Control: no-cache\" to disambiguate which response to use.",
      "ja": "複数の適切な応答が記憶されている場合（Dateヘッダフィールドによって決定されるように）、キャッシュは、最新の応答を使用しなければなりません。使用する応答明確にするために：または「キャッシュなしのCache-Control」：それはまた、「MAX-年齢= 0のCache-Control」で要求を転送することができます。"
    },
    {
      "indent": 3,
      "text": "A cache that does not have a clock available MUST NOT use stored responses without revalidating them upon every use.",
      "ja": "利用可能なクロックを持っていないキャッシュは、すべての使用時にそれらを再検証せずに保存された応答を使用してはなりません。"
    },
    {
      "indent": 0,
      "text": "4.1. Calculating Secondary Keys with Vary",
      "section_title": true,
      "ja": "4.1. ヴァリとセカンダリキーを計算します"
    },
    {
      "indent": 3,
      "text": "When a cache receives a request that can be satisfied by a stored response that has a Vary header field (Section 7.1.4 of [RFC7231]), it MUST NOT use that response unless all of the selecting header fields nominated by the Vary header field match in both the original request (i.e., that associated with the stored response), and the presented request.",
      "ja": "キャッシュが変化ヘッダフィールドを有する保存された応答（[RFC7231]のセクション7.1.4）によって満たすことができる要求を受信したときに選択ヘッダフィールドの全てが変化ヘッダフィールドによって指名されない限り、その応答を使用してはいけません元のリクエスト（すなわち、記憶された応答に関連する）、及び提示要求の両方で一致。"
    },
    {
      "indent": 3,
      "text": "The selecting header fields from two requests are defined to match if and only if those in the first request can be transformed to those in the second request by applying any of the following:",
      "ja": "2つの要求から選択ヘッダフィールドが一致するように定義されている場合と、最初のリクエストのものは、以下のいずれかを適用することによって第2の要求のものに変換することができる場合にのみ。"
    },
    {
      "indent": 3,
      "text": "o adding or removing whitespace, where allowed in the header field's syntax",
      "ja": "ヘッダフィールドの構文で許容される空白を、追加または削除O"
    },
    {
      "indent": 3,
      "text": "o combining multiple header fields with the same field name (see Section 3.2 of [RFC7230])",
      "ja": "同じフィールド名を持つ複数のヘッダフィールドを組み合わせO（[RFC7230]のセクション3.2を参照されたいです）"
    },
    {
      "indent": 3,
      "text": "o normalizing both header field values in a way that is known to have identical semantics, according to the header field's specification (e.g., reordering field values when order is not significant; case-normalization, where values are defined to be case-insensitive)",
      "ja": "O正規同じ意味を有することが知られているように、両方のヘッダフィールド値を、ヘッダフィールドの仕様に応じて（例えば、順序が重要でない場合、フィールドの値を並べ替え、値は大文字と小文字を区別しないことと定義される場合正規化）"
    },
    {
      "indent": 3,
      "text": "If (after any normalization that might take place) a header field is absent from a request, it can only match another request if it is also absent there.",
      "ja": "（場所を取る可能性のある正規化後の）ヘッダーフィールドはリクエストから存在しない場合、それはそこにも存在しない場合には、それだけで別の要求を一致させることができます。"
    },
    {
      "indent": 3,
      "text": "A Vary header field-value of \"*\" always fails to match.",
      "ja": "Aは、「*」は常に一致しないのヘッダフィールド値を変更します。"
    },
    {
      "indent": 3,
      "text": "The stored response with matching selecting header fields is known as the selected response.",
      "ja": "選択ヘッダフィールドが一致する記憶された応答は、選択された応答として知られています。"
    },
    {
      "indent": 3,
      "text": "If multiple selected responses are available (potentially including responses without a Vary header field), the cache will need to choose one to use. When a selecting header field has a known mechanism for doing so (e.g., qvalues on Accept and similar request header fields), that mechanism MAY be used to select preferred responses; of the remainder, the most recent response (as determined by the Date header field) is used, as per Section 4.",
      "ja": "選択した複数の応答は（潜在的にヴァリヘッダフィールドのない応答を含む）利用可能な場合は、キャッシュが使用する1つを選択する必要があります。選択ヘッダフィールドがそうするための公知の機構を有する場合（例えば、受け入れ同様のリクエストヘッダフィールドにqvalues）、そのメカニズムは、好ましい応答を選択するために使用され得ます。残りの、最新の応答は、（Dateヘッダフィールドによって決定されるような）第4に従って、使用されています。"
    },
    {
      "indent": 3,
      "text": "If no selected response is available, the cache cannot satisfy the presented request. Typically, it is forwarded to the origin server in a (possibly conditional; see Section 4.3) request.",
      "ja": "何も選択された応答がない場合は、キャッシュが提示要求を満たすことができません。典型的には、原点サーバーに転送される（おそらく条件; 4.3節参照）の要求を。"
    },
    {
      "indent": 0,
      "text": "4.2. Freshness",
      "section_title": true,
      "ja": "4.2. 鮮度"
    },
    {
      "indent": 3,
      "text": "A fresh response is one whose age has not yet exceeded its freshness lifetime. Conversely, a stale response is one where it has.",
      "ja": "新鮮な応答は、年齢がまだその新鮮寿命を超えていないものです。逆に、古くなった応答は、それが有するものです。"
    },
    {
      "indent": 3,
      "text": "A response's freshness lifetime is the length of time between its generation by the origin server and its expiration time. An explicit expiration time is the time at which the origin server intends that a stored response can no longer be used by a cache without further validation, whereas a heuristic expiration time is assigned by a cache when no explicit expiration time is available.",
      "ja": "応答の鮮度寿命はオリジンサーバとその有効期限によって、その世代間の時間の長さです。明示的な有効期限は、オリジンサーバは明示的な有効期限が利用できない場合、ヒューリスティック有効期限がキャッシュによって割り当てられ、一方、保存された応答は、もはや、さらに検証することなく、キャッシュで使用できないことを意図した時間です。"
    },
    {
      "indent": 3,
      "text": "A response's age is the time that has passed since it was generated by, or successfully validated with, the origin server.",
      "ja": "レスポンスの年齢は、それが発生したことにより、または成功したオリジンサーバ、で検証してから経過した時間です。"
    },
    {
      "indent": 3,
      "text": "When a response is \"fresh\" in the cache, it can be used to satisfy subsequent requests without contacting the origin server, thereby improving efficiency.",
      "ja": "応答がキャッシュに「新鮮」である場合には、それによって効率を向上させること、オリジンサーバに接触することなく後続の要求を満たすために使用することができます。"
    },
    {
      "indent": 3,
      "text": "The primary mechanism for determining freshness is for an origin server to provide an explicit expiration time in the future, using either the Expires header field (Section 5.3) or the max-age response directive (Section 5.2.2.8). Generally, origin servers will assign future explicit expiration times to responses in the belief that the representation is not likely to change in a semantically significant way before the expiration time is reached.",
      "ja": "鮮度を決定するための主要なメカニズムは、いずれかのヘッダーフィールド（セクション5.3）または最大エージング応答指示（セクション5.2.2.8）を使用して有効期限、将来の明確な有効期限を提供するために、オリジンサーバのためのものです。一般的に、オリジンサーバは、表現が有効期限に達する前に、意味的に重要な方法で変更される可能性はないという信念で応答に将来の明示的な有効期限を割り当てます。"
    },
    {
      "indent": 3,
      "text": "If an origin server wishes to force a cache to validate every request, it can assign an explicit expiration time in the past to indicate that the response is already stale. Compliant caches will normally validate a stale cached response before reusing it for subsequent requests (see Section 4.2.4).",
      "ja": "オリジンサーバがすべての要求を検証するためにキャッシュを強制したい場合、それはレスポンスがすでに古くなっていることを示すために、過去に明示的に有効期限を割り当てることができます。準拠のキャッシュは通常、後続の要求（4.2.4項を参照）のためにそれを再利用する前に、古いキャッシュされた応答を検証します。"
    },
    {
      "indent": 3,
      "text": "Since origin servers do not always provide explicit expiration times, caches are also allowed to use a heuristic to determine an expiration time under certain circumstances (see Section 4.2.2).",
      "ja": "オリジンサーバは、常に明示的な有効期限を提供していないので、キャッシュはまた、特定の状況（4.2.2項を参照）の下で有効期限を決定するために、ヒューリスティックを使用することが許可されています。"
    },
    {
      "indent": 3,
      "text": "The calculation to determine if a response is fresh is:",
      "ja": "応答が新鮮であるかどうかを判断するための計算は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "response_is_fresh = (freshness_lifetime > current_age)",
      "ja": "response_is_fresh =（鮮度寿命> CURRENT_PAGE）"
    },
    {
      "indent": 3,
      "text": "freshness_lifetime is defined in Section 4.2.1; current_age is defined in Section 4.2.3.",
      "ja": "freshness_lifetimeは、4.2.1項で定義されています。 current_ageは、4.2.3項で定義されています。"
    },
    {
      "indent": 3,
      "text": "Clients can send the max-age or min-fresh cache directives in a request to constrain or relax freshness calculations for the corresponding response (Section 5.2.1).",
      "ja": "クライアントは、対応する応答（5.2.1）のための鮮度計算を拘束したり、リラックスするための要求で最大エージングまたはMIN-新鮮キャッシュディレクティブを送信することができます。"
    },
    {
      "indent": 3,
      "text": "When calculating freshness, to avoid common problems in date parsing:",
      "ja": "日付の解析に一般的な問題を回避するために、新鮮さを計算する場合："
    },
    {
      "indent": 3,
      "text": "o Although all date formats are specified to be case-sensitive, a cache recipient SHOULD match day, week, and time-zone names case-insensitively.",
      "ja": "すべての日付形式は大文字と小文字を区別するために指定されていますがO、キャッシュの受信者は、大文字と小文字を区別せずに日、週、およびタイムゾーン名と一致する必要があります。"
    },
    {
      "indent": 3,
      "text": "o If a cache recipient's internal implementation of time has less resolution than the value of an HTTP-date, the recipient MUST internally represent a parsed Expires date as the nearest time equal to or earlier than the received value.",
      "ja": "時間のキャッシュの受信者の内部実装は、HTTP-日付の値未満の解像度を有する場合にO、受信者は、内部解析されたに等しいか又は受信された値より前の最も近い時間と日付が有効期限表現しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o A cache recipient MUST NOT allow local time zones to influence the calculation or comparison of an age or expiration time.",
      "ja": "Oキャッシュの受信者は、ローカルタイムゾーンは年齢や有効期限の計算や比較に影響を与えるのを許してはなりません。"
    },
    {
      "indent": 3,
      "text": "o A cache recipient SHOULD consider a date with a zone abbreviation other than GMT or UTC to be invalid for calculating expiration.",
      "ja": "Oキャッシュの受信者は、有効期限を計算するため無効であるとGMTまたはUTC以外のゾーンの省略形で日付を検討すべきです。"
    },
    {
      "indent": 3,
      "text": "Note that freshness applies only to cache operation; it cannot be used to force a user agent to refresh its display or reload a resource. See Section 6 for an explanation of the difference between caches and history mechanisms.",
      "ja": "新鮮さが唯一のキャッシュ操作に適用されることに注意してください。その表示を更新したり、リソースを再ロードするためにユーザーエージェントを強制するために使用することはできません。キャッシュと履歴メカニズムの違いの説明については、第6章を参照してください。"
    },
    {
      "indent": 0,
      "text": "4.2.1. Calculating Freshness Lifetime",
      "section_title": true,
      "ja": "4.2.1. 鮮度の寿命の計算"
    },
    {
      "indent": 3,
      "text": "A cache can calculate the freshness lifetime (denoted as freshness_lifetime) of a response by using the first match of the following:",
      "ja": "キャッシュは、次の最初の一致を使用して応答（freshness_lifetimeとして示される）鮮度寿命を計算することができます。"
    },
    {
      "indent": 3,
      "text": "o If the cache is shared and the s-maxage response directive (Section 5.2.2.9) is present, use its value, or",
      "ja": "キャッシュを共有し、S-MAXAGE応答指示（セクション5.2.2.9）が存在している場合は、O、その値を使用するか、または"
    },
    {
      "indent": 3,
      "text": "o If the max-age response directive (Section 5.2.2.8) is present, use its value, or",
      "ja": "最大エージング応答ディレクティブ（セクション5.2.2.8）が存在する場合は、O、その値を使用するか、または"
    },
    {
      "indent": 3,
      "text": "o If the Expires response header field (Section 5.3) is present, use its value minus the value of the Date response header field, or",
      "ja": "その値がマイナス日レスポンスヘッダフィールドの値を使用して、レスポンスヘッダフィールド（5.3節）が存在している有効期限が切れた場合、O、又は"
    },
    {
      "indent": 3,
      "text": "o Otherwise, no explicit expiration time is present in the response. A heuristic freshness lifetime might be applicable; see Section 4.2.2.",
      "ja": "Oそれ以外の場合は、明示的な有効期限は対応して存在していません。ヒューリスティック鮮度寿命が適用されるかもしれません。 4.2.2項を参照してください。"
    },
    {
      "indent": 3,
      "text": "Note that this calculation is not vulnerable to clock skew, since all of the information comes from the origin server.",
      "ja": "すべての情報は、オリジンサーバから来ているので、この計算は、クロック・スキューに対して脆弱ではないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "When there is more than one value present for a given directive (e.g., two Expires header fields, multiple Cache-Control: max-age directives), the directive's value is considered invalid. Caches are encouraged to consider responses that have invalid freshness information to be stale.",
      "ja": "与えられた指令するための本つ以上の値（例えば、二つのヘッダ・フィールドは、複数のCache-Control有効期限：最大エージングディレクティブ）がある場合、指令の値が無効であると考えられます。キャッシュは古くなるように、無効な鮮度情報を持って対応を検討することが奨励されています。"
    },
    {
      "indent": 0,
      "text": "4.2.2. Calculating Heuristic Freshness",
      "section_title": true,
      "ja": "4.2.2. ヒューリスティック鮮度の計算"
    },
    {
      "indent": 3,
      "text": "Since origin servers do not always provide explicit expiration times, a cache MAY assign a heuristic expiration time when an explicit time is not specified, employing algorithms that use other header field values (such as the Last-Modified time) to estimate a plausible expiration time. This specification does not provide specific algorithms, but does impose worst-case constraints on their results.",
      "ja": "オリジンサーバは常に明示的に有効期限を提供していないため、キャッシュは、明示的な時間はもっともらしい有効期限を推定するために（例えば、最終更新時刻などの）他のヘッダフィールド値を使用するアルゴリズムを用いて、指定されていないヒューリスティック有効期限を割り当てることができます。この仕様は、特定のアルゴリズムを提供していませんが、その結果に最悪の場合の制約を課すん。"
    },
    {
      "indent": 3,
      "text": "A cache MUST NOT use heuristics to determine freshness when an explicit expiration time is present in the stored response. Because of the requirements in Section 3, this means that, effectively, heuristics can only be used on responses without explicit freshness whose status codes are defined as cacheable by default (see Section 6.1 of [RFC7231]), and those responses without explicit freshness that have been marked as explicitly cacheable (e.g., with a \"public\" response directive).",
      "ja": "キャッシュは、明示的に有効期限が格納されている応答に存在する場合に鮮度を決定するためのヒューリスティックを使用してはなりません。なぜなら第3の要求のため、これは、効果的に、ヒューリスティックのみ（[RFC7231]のセクション6.1を参照）ステータスコードデフォルトでキャッシュ可能として定義される明示的な鮮度無し応答に使用され、明示的な鮮度ないもの応答することができることを意味（「パブリック」応答ディレクティブで、例えば）キャッシュ可能として明示的にマークされています。"
    },
    {
      "indent": 3,
      "text": "If the response has a Last-Modified header field (Section 2.2 of [RFC7232]), caches are encouraged to use a heuristic expiration value that is no more than some fraction of the interval since that time. A typical setting of this fraction might be 10%.",
      "ja": "応答最終-Modifiedヘッダフィールド（[RFC7232]のセクション2.2）を有している場合、キャッシュは、その時以来、もはや間隔のある部分よりもヒューリスティック満了値を使用することが奨励されます。この画分の典型的な設定は10％であるかもしれません。"
    },
    {
      "indent": 3,
      "text": "When a heuristic is used to calculate freshness lifetime, a cache SHOULD generate a Warning header field with a 113 warn-code (see Section 5.5.4) in the response if its current_age is more than 24 hours and such a warning is not already present.",
      "ja": "ヒューリスティックは、鮮度の寿命を計算するために使用される場合、そのてcurrent_ageが24時間以上であり、そのような警報がすでに存在しない場合、キャッシュは、応答（セクション5.5.4を参照）113警告コードと警告ヘッダフィールドを生成する必要があります。"
    },
    {
      "indent": 6,
      "text": "Note: Section 13.9 of [RFC2616] prohibited caches from calculating heuristic freshness for URIs with query components (i.e., those containing '?'). In practice, this has not been widely implemented. Therefore, origin servers are encouraged to send explicit directives (e.g., Cache-Control: no-cache) if they wish to preclude caching.",
      "ja": "注：（「？」、すなわち、それらを含有する）クエリコンポーネントとURIのヒューリスティック鮮度を計算から[RFC2616]禁止キャッシュのセクション13.9。実際には、これは広く実装されていません。彼らはキャッシュ排除したい場合：したがって、オリジンサーバは明示的なディレクティブ（キャッシュなし例えば、のCache-Control）を送信することが推奨されています。"
    },
    {
      "indent": 0,
      "text": "4.2.3. Calculating Age",
      "section_title": true,
      "ja": "4.2.3. 計算エイジ"
    },
    {
      "indent": 3,
      "text": "The Age header field is used to convey an estimated age of the response message when obtained from a cache. The Age field value is the cache's estimate of the number of seconds since the response was generated or validated by the origin server. In essence, the Age value is the sum of the time that the response has been resident in each of the caches along the path from the origin server, plus the amount of time it has been in transit along network paths.",
      "ja": "年齢ヘッダフィールドは、キャッシュから取得したときに応答メッセージの推定年齢を伝えるために使用されます。 Ageフィールドの値は、応答が生成またはオリジンサーバによって検証されてからの秒数のキャッシュの推定値です。本質的に、年齢の値は、応答がオリジンサーバから経路に沿ってキャッシュのそれぞれに常駐していた時間の合計、プラス、それは、ネットワーク経路に沿って走行していた時間の量です。"
    },
    {
      "indent": 3,
      "text": "The following data is used for the age calculation:",
      "ja": "以下のデータは、年齢計算に使用されます。"
    },
    {
      "indent": 3,
      "text": "age_value",
      "ja": "age_value"
    },
    {
      "indent": 6,
      "text": "The term \"age_value\" denotes the value of the Age header field (Section 5.1), in a form appropriate for arithmetic operation; or 0, if not available.",
      "ja": "用語「age_value」は、演算に適した形態で、年齢ヘッダーフィールド（セクション5.1）の値を示します。または0、利用できない場合。"
    },
    {
      "indent": 3,
      "text": "date_value",
      "ja": "DATE_VALUE"
    },
    {
      "indent": 6,
      "text": "The term \"date_value\" denotes the value of the Date header field, in a form appropriate for arithmetic operations. See Section 7.1.1.2 of [RFC7231] for the definition of the Date header field, and for requirements regarding responses without it.",
      "ja": "用語「DATE_VALUE」は、算術演算に適した形態で、Dateヘッダーフィールドの値を表します。 Dateヘッダーフィールドの定義については、それなしで応答に関する要件については、[RFC7231]のセクション7.1.1.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "now",
      "ja": "今"
    },
    {
      "indent": 6,
      "text": "The term \"now\" means \"the current value of the clock at the host performing the calculation\". A host ought to use NTP ([RFC5905]) or some similar protocol to synchronize its clocks to Coordinated Universal Time.",
      "ja": "用語は、「今」「計算を行うホストのクロックの現在の値」を意味します。ホストは、協定世界時にそのクロックを同期するためにNTP（[RFC5905]）またはいくつかの同様のプロトコルを使用するべきです。"
    },
    {
      "indent": 3,
      "text": "request_time",
      "ja": "REQUEST_TIME"
    },
    {
      "indent": 6,
      "text": "The current value of the clock at the host at the time the request resulting in the stored response was made.",
      "ja": "保存された応答をもたらす要求が行われた時点で、ホストのクロックの現在の値。"
    },
    {
      "indent": 3,
      "text": "response_time",
      "ja": "反応時間"
    },
    {
      "indent": 6,
      "text": "The current value of the clock at the host at the time the response was received.",
      "ja": "応答が受信された時点で、ホストのクロックの現在の値。"
    },
    {
      "indent": 3,
      "text": "A response's age can be calculated in two entirely independent ways:",
      "ja": "レスポンスの年齢は、二つの完全に独立した方法で計算することができます。"
    },
    {
      "indent": 3,
      "text": "1. the \"apparent_age\": response_time minus date_value, if the local clock is reasonably well synchronized to the origin server's clock. If the result is negative, the result is replaced by zero.",
      "ja": "1.「apparent_age」：RESPONSE_TIMEマイナスDATE_VALUE、ローカルクロックが合理的にオリジンサーバのクロックに同期されている場合。結果が負の場合、結果はゼロに置き換えられます。"
    },
    {
      "indent": 3,
      "text": "2. the \"corrected_age_value\", if all of the caches along the response path implement HTTP/1.1. A cache MUST interpret this value relative to the time the request was initiated, not the time that the response was received.",
      "ja": "2.「corrected_age_value」、応答パスに沿ってのすべてのキャッシュがHTTP / 1.1を実装した場合。キャッシュは、要求が開始された時点ではなく、応答が受信された時刻に、この値を解釈する必要があります。"
    },
    {
      "indent": 5,
      "text": "apparent_age = max(0, response_time - date_value);",
      "ja": "apparent_age = MAX（0、RESPONSE_TIME  -  DATE_VALUE）。"
    },
    {
      "indent": 5,
      "text": "response_delay = response_time - request_time;\ncorrected_age_value = age_value + response_delay;",
      "raw": true
    },
    {
      "indent": 3,
      "text": "These are combined as",
      "ja": "これらは次のように組み合わされて"
    },
    {
      "indent": 5,
      "text": "corrected_initial_age = max(apparent_age, corrected_age_value);",
      "ja": "corrected_initial_age = MAX（apparent_age、corrected_age_value）。"
    },
    {
      "indent": 3,
      "text": "unless the cache is confident in the value of the Age header field (e.g., because there are no HTTP/1.0 hops in the Via header field), in which case the corrected_age_value MAY be used as the corrected_initial_age.",
      "ja": "corrected_age_valueがcorrected_initial_ageとして使用することができる場合には、（ViaヘッダーフィールドにはHTTP / 1.0ホップが存在しないので、例えば、）キャッシュは年齢ヘッダフィールドの値に確信している場合を除き。"
    },
    {
      "indent": 3,
      "text": "The current_age of a stored response can then be calculated by adding the amount of time (in seconds) since the stored response was last validated by the origin server to the corrected_initial_age.",
      "ja": "保存された応答てcurrent_ageは次に記憶された応答はcorrected_initial_ageにオリジンサーバによって最後に検証されてからの時間（秒）の量を加算することにより算出することができます。"
    },
    {
      "indent": 5,
      "text": "resident_time = now - response_time;\ncurrent_age = corrected_initial_age + resident_time;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "4.2.4. Serving Stale Responses",
      "section_title": true,
      "ja": "4.2.4. 古い応答をサービング"
    },
    {
      "indent": 3,
      "text": "A \"stale\" response is one that either has explicit expiry information or is allowed to have heuristic expiry calculated, but is not fresh according to the calculations in Section 4.2.",
      "ja": "「古い」応答は、明示的な有効期限情報を有するか、またはヒューリスティック有効期限を算出持たせているが、セクション4.2での計算によれば、新鮮ではないいずれかです。"
    },
    {
      "indent": 3,
      "text": "A cache MUST NOT generate a stale response if it is prohibited by an explicit in-protocol directive (e.g., by a \"no-store\" or \"no-cache\" cache directive, a \"must-revalidate\" cache-response-directive, or an applicable \"s-maxage\" or \"proxy-revalidate\" cache-response-directive; see Section 5.2.2).",
      "ja": "それは（明示的でプロトコルディレクティブで禁止されている場合は、キャッシュが古いレスポンスを生成してはならない例えば、「無店舗」または「キャッシュなし」のキャッシュディレクティブによるキャッシュ・レスポンスがディレクティブ「 - 再検証しなければなりません」、または該当する「S-MAXAGE」または「プロキシ再検証」キャッシュ・レスポンス・ディレクティブ; 5.2.2項を参照してください）。"
    },
    {
      "indent": 3,
      "text": "A cache MUST NOT send stale responses unless it is disconnected (i.e., it cannot contact the origin server or otherwise find a forward path) or doing so is explicitly allowed (e.g., by the max-stale request directive; see Section 5.2.1).",
      "ja": "それが切断されない限り、キャッシュが古くなったレスポンスを送ってはいけません（すなわち、それはオリジンサーバに連絡するか、そうでない場合は、フォワードパスを見つけることができない）か、そうすることは、明示的に許可されている（例えば、MAX-古い要求ディレクティブにより、5.2.1項を参照してください） 。"
    },
    {
      "indent": 3,
      "text": "A cache SHOULD generate a Warning header field with the 110 warn-code (see Section 5.5.1) in stale responses. Likewise, a cache SHOULD generate a 112 warn-code (see Section 5.5.3) in stale responses if the cache is disconnected.",
      "ja": "キャッシュ110は警告コードと警告ヘッダフィールドを生成する必要が失効応答に（セクション5.5.1参照）。同様に、キャッシュは、キャッシュが切断された場合失効応答に（セクション5.5.3参照）112警告コードを生成する必要があります。"
    },
    {
      "indent": 3,
      "text": "A cache SHOULD NOT generate a new Warning header field when forwarding a response that does not have an Age header field, even if the response is already stale. A cache need not validate a response that merely became stale in transit.",
      "ja": "レスポンスがすでに古くなっている場合でも、年齢ヘッダフィールドを持っていない応答を転送する際にキャッシュが新しいWarningヘッダーフィールドを生成するべきではありません。キャッシュは、単に輸送中に陳腐になった応答を検証する必要はありません。"
    },
    {
      "indent": 0,
      "text": "4.3. Validation",
      "section_title": true,
      "ja": "4.3. バリデーション"
    },
    {
      "indent": 3,
      "text": "When a cache has one or more stored responses for a requested URI, but cannot serve any of them (e.g., because they are not fresh, or one cannot be selected; see Section 4.1), it can use the conditional request mechanism [RFC7232] in the forwarded request to give the next inbound server an opportunity to select a valid stored response to use, updating the stored metadata in the process, or to replace the stored response(s) with a new response. This process is known as \"validating\" or \"revalidating\" the stored response.",
      "ja": "キャッシュは、要求されたURIのための1つまたは複数の保存された応答を持っていますが、（彼らは新鮮でない、または1つを選択することができないため、例えば、セクション4.1を参照）、それらのいずれかを果たすことができない場合には、それは条件付きの要求メカニズム[RFC7232]を使用することができます転送された要求プロセスに格納されているメタデータを更新し、次の受信サーバーに使用するには、有効な保存された応答を選択する機会を与えるために、または新しい応答で保存された応答（複数可）を交換するインチこのプロセスは、「検証」または保存された応答を「再検証」として知られています。"
    },
    {
      "indent": 0,
      "text": "4.3.1. Sending a Validation Request",
      "section_title": true,
      "ja": "4.3.1. 検証要求を送信します"
    },
    {
      "indent": 3,
      "text": "When sending a conditional request for cache validation, a cache sends one or more precondition header fields containing validator metadata from its stored response(s), which is then compared by recipients to determine whether a stored response is equivalent to a current representation of the resource.",
      "ja": "キャッシュ検証のための条件付き要求を送信する場合、キャッシュは、次に、記憶された応答は、リソースの現在の表現と等価であるかどうかを決定するために受信者によって比較され、その記憶された応答（S）からバリメタデータを含む1つ以上の前提条件ヘッダフィールドを送ります。"
    },
    {
      "indent": 3,
      "text": "One such validator is the timestamp given in a Last-Modified header field (Section 2.2 of [RFC7232]), which can be used in an If-Modified-Since header field for response validation, or in an If-Unmodified-Since or If-Range header field for representation selection (i.e., the client is referring specifically to a previously obtained representation with that timestamp).",
      "ja": "そのようなバリは、応答の検証のため、またはであれば、未修飾-ので又は場合であれば修飾-ので、ヘッダフィールドに使用することができる最終-Modifiedヘッダフィールド（[RFC7232]のセクション2.2）で与えられたタイムスタンプであります表現の選択のため-rangeヘッダフィールド（すなわち、クライアントは、そのタイムスタンプと、以前に得られた表現に特異的に参照されます）。"
    },
    {
      "indent": 3,
      "text": "Another validator is the entity-tag given in an ETag header field (Section 2.3 of [RFC7232]). One or more entity-tags, indicating one or more stored responses, can be used in an If-None-Match header field for response validation, or in an If-Match or If-Range header field for representation selection (i.e., the client is referring specifically to one or more previously obtained representations with the listed entity-tags).",
      "ja": "別のバリデータはETagヘッダフィールド（[RFC7232]のセクション2.3）で与えられたエンティティタグです。一つ以上の記憶された応答を示す1つまたは複数のエンティティタグは、応答の検証のためにIf-None-Matchヘッダフィールドで使用される場合、またはマッチまたは表現の選択のためのIf-Rangeヘッダフィールド（すなわち、クライアントすることができます）列挙されたエンティティタグを有する1つまたは複数の以前に得られた表現に特異的に言及されています。"
    },
    {
      "indent": 0,
      "text": "4.3.2. Handling a Received Validation Request",
      "section_title": true,
      "ja": "4.3.2. 受信した検証要求を処理"
    },
    {
      "indent": 3,
      "text": "Each client in the request chain may have its own cache, so it is common for a cache at an intermediary to receive conditional requests from other (outbound) caches. Likewise, some user agents make use of conditional requests to limit data transfers to recently modified representations or to complete the transfer of a partially retrieved representation.",
      "ja": "リクエスト・チェーン内の各クライアントは独自のキャッシュを有することができるので、仲介者のキャッシュは、他の（アウトバウンド）のキャッシュから条件付きの要求を受信することが一般的です。同様に、いくつかのユーザエージェントは、最近修正表現にデータ転送を制限する、または部分的に検索表現の転送を完了するために条件付きリクエストを利用します。"
    },
    {
      "indent": 3,
      "text": "If a cache receives a request that can be satisfied by reusing one of its stored 200 (OK) or 206 (Partial Content) responses, the cache SHOULD evaluate any applicable conditional header field preconditions received in that request with respect to the corresponding validators contained within the selected response. A cache MUST NOT evaluate conditional header fields that are only applicable to an origin server, found in a request with semantics that cannot be satisfied with a cached response, or applied to a target resource for which it has no stored responses; such preconditions are likely intended for some other (inbound) server.",
      "ja": "キャッシュは、その格納された200（OK）または206（部分コンテンツ）のいずれかの応答を再利用することによって満たすことができる要求を受信した場合、キャッシュは、前提条件が内に含まれる対応するバリデータに対してその要求で受信した任意の適用可能な条件付きヘッダフィールドを評価すべきです選択された応答。キャッシュは、キャッシュされた応答に満足し、またはそれは保存された応答を持たないため、ターゲットリソースに適用することができない意味を持つリクエストで見つかったオリジンサーバにのみ適用され、条件付きヘッダフィールドを、評価してはなりません。そのような前提条件は、おそらく他のいくつかの（インバウンド）サーバーのために意図されています。"
    },
    {
      "indent": 3,
      "text": "The proper evaluation of conditional requests by a cache depends on the received precondition header fields and their precedence, as defined in Section 6 of [RFC7232]. The If-Match and If-Unmodified-Since conditional header fields are not applicable to a cache.",
      "ja": "[RFC7232]のセクション6で定義されるようにキャッシュによる条件要求の適切な評価は、受信された前提条件ヘッダフィールドとその優先順位に依存します。もしマッチとIF-未修飾-ための条件付きヘッダフィールドはキャッシュに適用されません。"
    },
    {
      "indent": 3,
      "text": "A request containing an If-None-Match header field (Section 3.2 of [RFC7232]) indicates that the client wants to validate one or more of its own stored responses in comparison to whichever stored response is selected by the cache. If the field-value is \"*\", or if the field-value is a list of entity-tags and at least one of them matches the entity-tag of the selected stored response, a cache recipient SHOULD generate a 304 (Not Modified) response (using the metadata of the selected stored response) instead of sending that stored response.",
      "ja": "If-None-Matchヘッダフィールド（[RFC7232]のセクション3.2）を含む要求は、クライアントが格納された応答をキャッシュすることによって選択された方と比較して、自身の記憶された応答の一つ以上を検証したいことを示しています。フィールド値が「*」であるならば、またはフィールド値は、エンティティタグのリストであり、そのうちの少なくとも一方が選択された保存されたレスポンスのエンティティタグに一致する、キャッシュの受信者が（未修正304を生成する必要がある場合代わりに、その記憶された応答を送信するの選択された記憶された応答のメタデータを使用して）応答（）。"
    },
    {
      "indent": 3,
      "text": "When a cache decides to revalidate its own stored responses for a request that contains an If-None-Match list of entity-tags, the cache MAY combine the received list with a list of entity-tags from its own stored set of responses (fresh or stale) and send the union of the two lists as a replacement If-None-Match header field value in the forwarded request. If a stored response contains only partial content, the cache MUST NOT include its entity-tag in the union unless the request is for a range that would be fully satisfied by that partial stored response. If the response to the forwarded request is 304 (Not Modified) and has an ETag header field value with an entity-tag that is not in the client's list, the cache MUST generate a 200 (OK) response for the client by reusing its corresponding stored response, as updated by the 304 response metadata (Section 4.3.4).",
      "ja": "キャッシュは、エンティティタグの場合は、なしマッチリストを含む要求するための独自の保存された応答を再検証することを決定した場合は、キャッシュが新鮮な（応答の独自の保存されたセットからのエンティティタグのリストを受信したリストを組み合わせることができますまたは古い）と転送された要求で置き換えた場合 - なし - マッチヘッダーフィールド値として二つのリストの和集合を送信します。保存された応答は部分的にしかコンテンツが含まれている場合、要求は完全にその部分保存された応答によって満たされることになる範囲に対するものでなければ、キャッシュは組合にそのエンティティタグを含めることはできません。転送された要求に対する応答が304である（変更不可）とクライアントのリストにないエンティティタグとETagヘッダフィールドの値を持っている場合、キャッシュはその対応を再利用することで、クライアントのために200（OK）レスポンスを生成しなければなりません304応答のメタデータ（4.3.4項）によって更新されるように、応答を記憶します。"
    },
    {
      "indent": 3,
      "text": "If an If-None-Match header field is not present, a request containing an If-Modified-Since header field (Section 3.3 of [RFC7232]) indicates that the client wants to validate one or more of its own stored responses by modification date. A cache recipient SHOULD generate a 304 (Not Modified) response (using the metadata of the selected stored response) if one of the following cases is true: 1) the selected stored response has a Last-Modified field-value that is earlier than or equal to the conditional timestamp; 2) no Last-Modified field is present in the selected stored response, but it has a Date field-value that is earlier than or equal to the conditional timestamp; or, 3) neither Last-Modified nor Date is present in the selected stored response, but the cache recorded it as having been received at a time earlier than or equal to the conditional timestamp.",
      "ja": "If-None-Matchヘッダフィールドが存在しない場合、もし修飾-ので、ヘッダフィールド（[RFC7232]のセクション3.3）を含む要求は、クライアントが変更日付によって、自身の記憶された応答の一つ以上を検証したいことを示します。次の場合のいずれかに該当する場合、キャッシュ・受信者304（変更されていません）応答（選択された記憶された応答のメタデータを使用して）生成する必要があります：1）選択された記憶された応答がより早い最終修飾フィールド値を有するか、または条件付きのタイムスタンプに等しいです。 2）は、Last-Modifiedのフィールドは、選択された保存された応答に存在しないが、それは条件付きのタイムスタンプよりも早いかまたは等しい日付フィールド値を有します。または、3）最終変性いずれも日は、選択された保存された応答に存在するが、キャッシュは以前よりまたは条件タイムスタンプに等しい時刻に受信されたとして、それを記録しました。"
    },
    {
      "indent": 3,
      "text": "A cache that implements partial responses to range requests, as defined in [RFC7233], also needs to evaluate a received If-Range header field (Section 3.2 of [RFC7233]) with respect to its selected stored response.",
      "ja": "[RFC7233]で定義されるように、要求の範囲に部分的な応答を実現するキャッシュは、また、その選択された格納された応答に関して受信したレンジヘッダフィールド（[RFC7233]のセクション3.2）を評価する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.3.3. Handling a Validation Response",
      "section_title": true,
      "ja": "4.3.3. 検証レスポンスの取り扱い"
    },
    {
      "indent": 3,
      "text": "Cache handling of a response to a conditional request is dependent upon its status code:",
      "ja": "条件付きの要求に対する応答のキャッシュの取り扱いは、そのステータスコードに依存しています："
    },
    {
      "indent": 3,
      "text": "o A 304 (Not Modified) response status code indicates that the stored response can be updated and reused; see Section 4.3.4.",
      "ja": "O 304（未修正）応答ステータスコードが格納された応答が更新され、再利用することができることを示しています。 4.3.4項を参照してください。"
    },
    {
      "indent": 3,
      "text": "o A full response (i.e., one with a payload body) indicates that none of the stored responses nominated in the conditional request is suitable. Instead, the cache MUST use the full response to satisfy the request and MAY replace the stored response(s).",
      "ja": "完全応答（ペイロード本体と、すなわち、1）O条件要求に指名記憶された応答のいずれも適当ではないことを示しています。代わりに、キャッシュは、要求を満たすために、完全な応答を使用しなければならないし、保存された応答（複数可）を交換することができます。"
    },
    {
      "indent": 3,
      "text": "o However, if a cache receives a 5xx (Server Error) response while attempting to validate a response, it can either forward this response to the requesting client, or act as if the server failed to respond. In the latter case, the cache MAY send a previously stored response (see Section 4.2.4).",
      "ja": "Oただし、キャッシュはレスポンスを検証しようとしたときに、それが要求元のクライアントにこのレスポンスを転送するか、またはサーバが応答に失敗したかのように行動するの5xx（サーバーエラー）レスポンスを受信した場合。後者の場合、キャッシュは以前に保存された応答（セクション4.2.4を参照）を送信することができます。"
    },
    {
      "indent": 0,
      "text": "4.3.4. Freshening Stored Responses upon Validation",
      "section_title": true,
      "ja": "4.3.4. 検証時に保存された応答の清涼"
    },
    {
      "indent": 3,
      "text": "When a cache receives a 304 (Not Modified) response and already has one or more stored 200 (OK) responses for the same cache key, the cache needs to identify which of the stored responses are updated by this new response and then update the stored response(s) with the new information provided in the 304 response.",
      "ja": "キャッシュは304（未修正）応答を受信し、既に1を持っている以上の同じキャッシュ・キーのための200（OK）応答を保存した場合、キャッシュはこの新しい応答によって更新されて保存された応答のかを特定する必要があり、その後、保存された更新します304応答して提供された新しい情報で応答（S）。"
    },
    {
      "indent": 3,
      "text": "The stored response to update is identified by using the first match (if any) of the following:",
      "ja": "：更新に記憶された応答は、以下の最初の一致（もしあれば）を使用して識別されます"
    },
    {
      "indent": 3,
      "text": "o If the new response contains a strong validator (see Section 2.1 of [RFC7232]), then that strong validator identifies the selected representation for update. All of the stored responses with the same strong validator are selected. If none of the stored responses contain the same strong validator, then the cache MUST NOT use the new response to update any stored responses.",
      "ja": "新しい応答は、（[RFC7232]のセクション2.1を参照）、強力なバリデータが含まれている場合は、O、次いで強いバリデータは更新のために選択された表現を識別すること。同じ強いバリで保存された応答のすべてが選択されています。保存された応答のどれもが同じ強力なバリデータが含まれていない場合は、キャッシュは、任意の保存された応答を更新するために、新たな応答を使用してはなりません。"
    },
    {
      "indent": 3,
      "text": "o If the new response contains a weak validator and that validator corresponds to one of the cache's stored responses, then the most recent of those matching stored responses is selected for update.",
      "ja": "新しい応答が弱いバリデータが含まれており、そのバリデータがキャッシュの保存された応答のいずれかに該当する場合は、O、それらのマッチング保存された応答の最新の更新のために選択されています。"
    },
    {
      "indent": 3,
      "text": "o If the new response does not include any form of validator (such as in the case where a client generates an If-Modified-Since request from a source other than the Last-Modified response header field), and there is only one stored response, and that stored response also lacks a validator, then that stored response is selected for update.",
      "ja": "O新しい応答は、（例えば、クライアントはLast-Modifiedの応答ヘッダーフィールド以外のソースからのIF修飾-ための要求を生成する場合のように）バリの任意の形を含んでいない、一つだけ記憶された応答があった場合、および保存された応答はまた、その保存された応答は、更新のために選択されたバリを欠いています。"
    },
    {
      "indent": 3,
      "text": "If a stored response is selected for update, the cache MUST:",
      "ja": "保存された応答は、更新のために選択されている場合は、キャッシュする必要があります。"
    },
    {
      "indent": 3,
      "text": "o delete any Warning header fields in the stored response with warn-code 1xx (see Section 5.5);",
      "ja": "O警告コード1XXと格納された応答に警告ヘッダフィールドを削除し（セクション5.5を参照）。"
    },
    {
      "indent": 3,
      "text": "o retain any Warning header fields in the stored response with warn-code 2xx; and,",
      "ja": "O警告コード2XXと格納された応答に警告ヘッダフィールドを保持します。そして、"
    },
    {
      "indent": 3,
      "text": "o use other header fields provided in the 304 (Not Modified) response to replace all instances of the corresponding header fields in the stored response.",
      "ja": "O格納された応答に対応するヘッダフィールドのすべてのインスタンスを置き換えるために304（変更されていません）応答して提供される他のヘッダフィールドを使用します。"
    },
    {
      "indent": 0,
      "text": "4.3.5. Freshening Responses via HEAD",
      "section_title": true,
      "ja": "4.3.5.  HEAD経由清涼応答"
    },
    {
      "indent": 3,
      "text": "A response to the HEAD method is identical to what an equivalent request made with a GET would have been, except it lacks a body. This property of HEAD responses can be used to invalidate or update a cached GET response if the more efficient conditional GET request mechanism is not available (due to no validators being present in the stored response) or if transmission of the representation body is not desired even if it has changed.",
      "ja": "それは身体を欠い以外HEADメソッドへの応答は、GETで作られた同等の要求があったであろうものに同じです。 HEAD応答のこの特性は、より効率的な条件付きGETリクエスト機構（これは記憶されている応答に存在しないバリに）利用できない場合、キャッシュされたGET応答を無効化または更新するために使用することができ、または表現本体の送信があっても所望されていない場合それが変更された場合。"
    },
    {
      "indent": 3,
      "text": "When a cache makes an inbound HEAD request for a given request target and receives a 200 (OK) response, the cache SHOULD update or invalidate each of its stored GET responses that could have been selected for that request (see Section 4.1).",
      "ja": "キャッシュが与えられた要求の対象のためのインバウンドHEAD要求を行い、200（OK）応答を受信すると、キャッシュはその要求（4.1節を参照）のために選択されている可能性がその保存されたGET応答のそれぞれを更新するか、または無効にすべきです。"
    },
    {
      "indent": 3,
      "text": "For each of the stored responses that could have been selected, if the stored response and HEAD response have matching values for any received validator fields (ETag and Last-Modified) and, if the HEAD response has a Content-Length header field, the value of Content-Length matches that of the stored response, the cache SHOULD update the stored response as described below; otherwise, the cache SHOULD consider the stored response to be stale.",
      "ja": "HEAD応答は、値をContent-Lengthヘッダフィールドを有する場合格納された応答とHEAD応答は、任意の受信されたバリデータフィールド（Etag及び最終変性）の値と一致するとした場合、選択されている可能性が保存された応答の各々についてコンテンツの長さ以下に説明するように格納された応答の、キャッシュが格納されている応答を更新する必要があることを一致。そうでない場合は、キャッシュが保存された応答が古いことを検討すべきです。"
    },
    {
      "indent": 3,
      "text": "If a cache updates a stored response with the metadata provided in a HEAD response, the cache MUST:",
      "ja": "キャッシュはHEAD応答で提供されるメタデータで保存された応答を更新した場合は、キャッシュする必要があります。"
    },
    {
      "indent": 3,
      "text": "o delete any Warning header fields in the stored response with warn-code 1xx (see Section 5.5);",
      "ja": "O警告コード1XXと格納された応答に警告ヘッダフィールドを削除し（セクション5.5を参照）。"
    },
    {
      "indent": 3,
      "text": "o retain any Warning header fields in the stored response with warn-code 2xx; and,",
      "ja": "O警告コード2XXと格納された応答に警告ヘッダフィールドを保持します。そして、"
    },
    {
      "indent": 3,
      "text": "o use other header fields provided in the HEAD response to replace all instances of the corresponding header fields in the stored response and append new header fields to the stored response's header section unless otherwise restricted by the Cache-Control header field.",
      "ja": "別段のCache-Controlヘッダーフィールドによって制限されていない限り、O格納された応答に対応するヘッダフィールドのすべてのインスタンスを置換し、保存された応答のヘッダ部に新たなヘッダフィールドを追加するHEAD応答に提供される他のヘッダフィールドを使用します。"
    },
    {
      "indent": 0,
      "text": "4.4. Invalidation",
      "section_title": true,
      "ja": "4.4. 失効"
    },
    {
      "indent": 3,
      "text": "Because unsafe request methods (Section 4.2.1 of [RFC7231]) such as PUT, POST or DELETE have the potential for changing state on the origin server, intervening caches can use them to keep their contents up to date.",
      "ja": "そのため、このようなPUTなど危険な依頼方法（[RFC7231]のセクション4.2.1）、POSTまたはキャッシュが最新その内容を維持するためにそれらを使用することができ介在、オリジンサーバ上の状態を変更するための可能性を秘めているDELETE。"
    },
    {
      "indent": 3,
      "text": "A cache MUST invalidate the effective Request URI (Section 5.5 of [RFC7230]) as well as the URI(s) in the Location and Content-Location response header fields (if present) when a non-error status code is received in response to an unsafe request method.",
      "ja": "キャッシュが有効なリクエストURI（[RFC7230]のセクション5.5）、ならびに位置およびコンテンツロケーション応答ヘッダーフィールドにおけるURI（単数または複数）（存在する場合）、非エラーステータスコードがに応答して受信されたときに無効化しなければなりません危険なリクエストメソッド。"
    },
    {
      "indent": 3,
      "text": "However, a cache MUST NOT invalidate a URI from a Location or Content-Location response header field if the host part of that URI differs from the host part in the effective request URI (Section 5.5 of [RFC7230]). This helps prevent denial-of-service attacks.",
      "ja": "そのURIのホスト部分は有効なリクエストURI内のホスト部分と異なる場合は、キャッシュロケーションまたはコンテンツロケーション応答ヘッダフィールドからURIを無効にしてはいけません（[RFC7230]のセクション5.5）。これは、サービス拒否攻撃を防ぐのに役立ちます。"
    },
    {
      "indent": 3,
      "text": "A cache MUST invalidate the effective request URI (Section 5.5 of [RFC7230]) when it receives a non-error response to a request with a method whose safety is unknown.",
      "ja": "それは安全性は不明である方法を使用して要求に対する非エラー応答を受信した場合、キャッシュが有効なリクエストURI（[RFC7230]のセクション5.5）を無効にしなければなりません。"
    },
    {
      "indent": 3,
      "text": "Here, a \"non-error response\" is one with a 2xx (Successful) or 3xx (Redirection) status code. \"Invalidate\" means that the cache will either remove all stored responses related to the effective request URI or will mark these as \"invalid\" and in need of a mandatory validation before they can be sent in response to a subsequent request.",
      "ja": "ここで、「非エラー応答が」2XX（成功）または300番台（リダイレクト）状態コードを有するものです。 「無効化」とは、キャッシュが有効リクエストURIに関連するすべての保存された応答を削除するか、またはそれらは、後続の要求に応じて送信することができます前に、「無効」と必須の検証の必要があるとしてこれらをマークすることを意味します。"
    },
    {
      "indent": 3,
      "text": "Note that this does not guarantee that all appropriate responses are invalidated. For example, a state-changing request might invalidate responses in the caches it travels through, but relevant responses still might be stored in other caches that it has not.",
      "ja": "これは、すべての適切な対応が無効化されることを保証するものではないことに注意してください。例えば、状態変更要求は、それが通って移動キャッシュに応答を無効にする可能性があるが、関連する応答は、まだそれがなかったことを他のキャッシュに格納されるかもしれません。"
    },
    {
      "indent": 0,
      "text": "5. Header Field Definitions",
      "section_title": true,
      "ja": "5.ヘッダーフィールドの定義"
    },
    {
      "indent": 3,
      "text": "This section defines the syntax and semantics of HTTP/1.1 header fields related to caching.",
      "ja": "このセクションでは、キャッシュに関連するHTTP / 1.1ヘッダフィールドの構文と意味論を定義します。"
    },
    {
      "indent": 0,
      "text": "5.1. Age",
      "section_title": true,
      "ja": "５。１。 あげ"
    },
    {
      "indent": 3,
      "text": "The \"Age\" header field conveys the sender's estimate of the amount of time since the response was generated or successfully validated at the origin server. Age values are calculated as specified in Section 4.2.3.",
      "ja": "「年齢」ヘッダフィールドはレスポンスが生成されたり、正常オリジンサーバで検証されてからの時間の送信者の見積もりを伝えます。セクション4.2.3に指定されている年齢値を算出します。"
    },
    {
      "indent": 5,
      "text": "Age = delta-seconds",
      "ja": "年齢=デルタ - 秒"
    },
    {
      "indent": 3,
      "text": "The Age field-value is a non-negative integer, representing time in seconds (see Section 1.2.1).",
      "ja": "年齢フィールド値（セクション1.2.1を参照）を時間（秒）を表す非負整数です。"
    },
    {
      "indent": 3,
      "text": "The presence of an Age header field implies that the response was not generated or validated by the origin server for this request. However, lack of an Age header field does not imply the origin was contacted, since the response might have been received from an HTTP/1.0 cache that does not implement Age.",
      "ja": "年齢ヘッダフィールドの存在は、応答が生成され、またはこの要求のオリジンサーバによって検証されなかったことを意味します。応答が年齢を実装していないHTTP / 1.0キャッシュから受信された可能性がありますので、起源を意味するものではありません年齢ヘッダフィールドの欠如は、接触させました。"
    },
    {
      "indent": 0,
      "text": "5.2. Cache-Control",
      "section_title": true,
      "ja": "5.2.  Cache-Control"
    },
    {
      "indent": 3,
      "text": "The \"Cache-Control\" header field is used to specify directives for caches along the request/response chain. Such cache directives are unidirectional in that the presence of a directive in a request does not imply that the same directive is to be given in the response.",
      "ja": "「キャッシュ・コントロール」ヘッダフィールドは要求/応答チェーンに沿ってキャッシュのディレクティブを指定するために使用されます。リクエスト内のディレクティブの存在は同じディレクティブは対応して与えられることにあることを意味するものではないという点で、このようなキャッシュディレクティブは単方向です。"
    },
    {
      "indent": 3,
      "text": "A cache MUST obey the requirements of the Cache-Control directives defined in this section. See Section 5.2.3 for information about how Cache-Control directives defined elsewhere are handled.",
      "ja": "キャッシュは、このセクションで定義されたのCache-Controlディレクティブの要件に従わなければなりません。他の場所で定義されたのCache-Controlディレクティブの処理方法については、5.2.3項を参照してください。"
    },
    {
      "indent": 6,
      "text": "Note: Some HTTP/1.0 caches might not implement Cache-Control.",
      "ja": "注意：一部のHTTP / 1.0キャッシュはキャッシュ・コントロールを実装していない可能性があります。"
    },
    {
      "indent": 3,
      "text": "A proxy, whether or not it implements a cache, MUST pass cache directives through in forwarded messages, regardless of their significance to that application, since the directives might be applicable to all recipients along the request/response chain. It is not possible to target a directive to a specific cache.",
      "ja": "ディレクティブは、リクエスト/レスポンス連鎖上のすべての受信者に適用されるかもしれないので、プロキシは、それがキャッシュを実装しているか否か、に関係なく、その重要性のそのアプリケーションに、転送されたメッセージのキャッシュディレクティブを通過しなければなりません。特定のキャッシュにディレクティブをターゲットにすることはできません。"
    },
    {
      "indent": 3,
      "text": "Cache directives are identified by a token, to be compared case-insensitively, and have an optional argument, that can use both token and quoted-string syntax. For the directives defined below that define arguments, recipients ought to accept both forms, even if one is documented to be preferred. For any directive not defined by this specification, a recipient MUST accept both forms.",
      "ja": "キャッシュディレクティブは、大文字と小文字を区別せずに比較するために、トークンによって識別され、トークンや引用符で囲まれた文字列の構文の両方を使用することができ、オプションの引数を、持っています。その下に定義された指令は引数を定義するために、受信者は、一つが好ましいと記載されていても、両方の形態を受け入れるべきです。この仕様で定義されていない任意のディレクティブについては、受信者は両方の形式を受け入れなければなりません。"
    },
    {
      "indent": 5,
      "text": "Cache-Control = 1#cache-directive",
      "ja": "Cache-Control = 1＃キャッシュディレクティブ"
    },
    {
      "indent": 5,
      "text": "cache-directive = token [ \"=\" ( token / quoted-string ) ]",
      "ja": "キャッシュ・ディレクティブ=トークン[「=」（トークン/引用符で囲まれた文字列）]"
    },
    {
      "indent": 3,
      "text": "For the cache directives defined below, no argument is defined (nor allowed) unless stated otherwise.",
      "ja": "特に断りのない限り以下に定義されたキャッシュ・ディレクティブの場合は、引数が定義されていない（も可）されます。"
    },
    {
      "indent": 0,
      "text": "5.2.1. Request Cache-Control Directives",
      "section_title": true,
      "ja": "5.2.1. 要求のCache-Controlディレクティブ"
    },
    {
      "indent": 0,
      "text": "5.2.1.1. max-age",
      "section_title": true,
      "ja": "5.2.1.1。最大エージング"
    },
    {
      "indent": 3,
      "text": "Argument syntax:",
      "ja": "引数の構文："
    },
    {
      "indent": 6,
      "text": "delta-seconds (see Section 1.2.1)",
      "ja": "デルタ秒（1.2.1項を参照してください）"
    },
    {
      "indent": 3,
      "text": "The \"max-age\" request directive indicates that the client is unwilling to accept a response whose age is greater than the specified number of seconds. Unless the max-stale request directive is also present, the client is not willing to accept a stale response.",
      "ja": "「最大エージング」要求ディレクティブは、クライアントがその年齢指定された秒数よりも大きい応答を受け入れることが不本意であることを示しています。 MAX-古い要求ディレクティブも存在していない限り、クライアントは古くなったレスポンスを受け入れることを望んでいません。"
    },
    {
      "indent": 3,
      "text": "This directive uses the token form of the argument syntax: e.g., 'max-age=5' not 'max-age=\"5\"'. A sender SHOULD NOT generate the quoted-string form.",
      "ja": "例えば、「最大-年齢= 5」ではない「最大-年齢= 『5』」：このディレクティブは、引数構文のトークン形式を使用しています。送信者は、引用符で囲まれた文字列の形式を生成するべきではありません。"
    },
    {
      "indent": 0,
      "text": "5.2.1.2. max-stale",
      "section_title": true,
      "ja": "5.2.1.2。 MAX-古いです"
    },
    {
      "indent": 3,
      "text": "Argument syntax:",
      "ja": "引数の構文："
    },
    {
      "indent": 6,
      "text": "delta-seconds (see Section 1.2.1)",
      "ja": "デルタ秒（1.2.1項を参照してください）"
    },
    {
      "indent": 3,
      "text": "The \"max-stale\" request directive indicates that the client is willing to accept a response that has exceeded its freshness lifetime. If max-stale is assigned a value, then the client is willing to accept a response that has exceeded its freshness lifetime by no more than the specified number of seconds. If no value is assigned to max-stale, then the client is willing to accept a stale response of any age.",
      "ja": "「MAX-古い」リクエストディレクティブは、クライアントがその新鮮寿命を超えたレスポンスを受け入れる意志があることを示しています。 MAX-古いに値が割り当てられている場合、クライアントは、指定された秒数を超えないことによって、その新鮮寿命を超えたレスポンスを受け入れようです。値がMAX-陳腐に割り当てられていない場合は、クライアントはすべての年齢の古い応答を受け入れていく所存です。"
    },
    {
      "indent": 3,
      "text": "This directive uses the token form of the argument syntax: e.g., 'max-stale=10' not 'max-stale=\"10\"'. A sender SHOULD NOT generate the quoted-string form.",
      "ja": "例えば、「最大-古い= 10」ではない「最大-陳腐= 『10』」：このディレクティブは、引数構文のトークン形式を使用しています。送信者は、引用符で囲まれた文字列の形式を生成するべきではありません。"
    },
    {
      "indent": 0,
      "text": "5.2.1.3. min-fresh",
      "section_title": true,
      "ja": "Kh.o.1.a.放散します"
    },
    {
      "indent": 3,
      "text": "Argument syntax:",
      "ja": "引数の構文："
    },
    {
      "indent": 6,
      "text": "delta-seconds (see Section 1.2.1)",
      "ja": "デルタ秒（1.2.1項を参照してください）"
    },
    {
      "indent": 3,
      "text": "The \"min-fresh\" request directive indicates that the client is willing to accept a response whose freshness lifetime is no less than its current age plus the specified time in seconds. That is, the client wants a response that will still be fresh for at least the specified number of seconds.",
      "ja": "「MIN-新鮮な」要求ディレクティブは、クライアントがその新鮮生涯その現在の年齢プラス秒で指定された時間以上である応答を受け入れることを望んでいることを示しています。これは、クライアントがまだ秒の少なくとも指定された数のために新鮮になります応答を望んでいる、です。"
    },
    {
      "indent": 3,
      "text": "This directive uses the token form of the argument syntax: e.g., 'min-fresh=20' not 'min-fresh=\"20\"'. A sender SHOULD NOT generate the quoted-string form.",
      "ja": "例えば、「MIN-新鮮= 20」ではない「MIN-新鮮= 『20』」：このディレクティブは、引数構文のトークン形式を使用しています。送信者は、引用符で囲まれた文字列の形式を生成するべきではありません。"
    },
    {
      "indent": 0,
      "text": "5.2.1.4. no-cache",
      "section_title": true,
      "ja": "5.2.1.4。ノーキャッシュません"
    },
    {
      "indent": 3,
      "text": "The \"no-cache\" request directive indicates that a cache MUST NOT use a stored response to satisfy the request without successful validation on the origin server.",
      "ja": "「キャッシュなし」要求ディレクティブは、キャッシュがオリジンサーバに正常に検証せずに要求を満たすために保存された応答を使用してはならないことを示しています。"
    },
    {
      "indent": 0,
      "text": "5.2.1.5. no-store",
      "section_title": true,
      "ja": "５。２。１。５。 のーｓとれ"
    },
    {
      "indent": 3,
      "text": "The \"no-store\" request directive indicates that a cache MUST NOT store any part of either this request or any response to it. This directive applies to both private and shared caches. \"MUST NOT store\" in this context means that the cache MUST NOT intentionally store the information in non-volatile storage, and MUST make a best-effort attempt to remove the information from volatile storage as promptly as possible after forwarding it.",
      "ja": "「無店舗」要求ディレクティブは、キャッシュがこのリクエストやそれに対する応答のいずれかの任意の部分を格納してはならないことを示しています。このディレクティブは、プライベートと共有キャッシュの両方に適用されます。この文脈で「保存てはならない」キャッシュが意図的に不揮発性ストレージに情報を格納してはいけませんし、それを転送した後、できるだけ速やかに揮発性の記憶装置から情報を削除するにはベストエフォート型試みを作る必要があります。"
    },
    {
      "indent": 3,
      "text": "This directive is NOT a reliable or sufficient mechanism for ensuring privacy. In particular, malicious or compromised caches might not recognize or obey this directive, and communications networks might be vulnerable to eavesdropping.",
      "ja": "このディレクティブは、プライバシーを確​​保するための信頼できるか、十分なメカニズムではありません。特に、悪意のあるまたは妥協キャッシュは認識したり、このディレクティブを遵守し、通信ネットワークは盗聴に対して脆弱であるかもしれないではないかもしれません。"
    },
    {
      "indent": 3,
      "text": "Note that if a request containing this directive is satisfied from a cache, the no-store request directive does not apply to the already stored response.",
      "ja": "このディレクティブを含む要求がキャッシュから満たされた場合、無店舗要求ディレクティブは、既に保存された応答には適用されないことに注意してください。"
    },
    {
      "indent": 0,
      "text": "5.2.1.6. no-transform",
      "section_title": true,
      "ja": "5.2.1.6。無変換"
    },
    {
      "indent": 3,
      "text": "The \"no-transform\" request directive indicates that an intermediary (whether or not it implements a cache) MUST NOT transform the payload, as defined in Section 5.7.2 of [RFC7230].",
      "ja": "「無変換」要求指令は、[RFC7230]のセクション5.7.2で定義されるように、中間に（それがキャッシュを実装しているか否か）、ペイロード変換はならないことを示します。"
    },
    {
      "indent": 0,
      "text": "5.2.1.7. only-if-cached",
      "section_title": true,
      "ja": "5.2.1.7。キャッシュされただけ-IF-"
    },
    {
      "indent": 3,
      "text": "The \"only-if-cached\" request directive indicates that the client only wishes to obtain a stored response. If it receives this directive, a cache SHOULD either respond using a stored response that is consistent with the other constraints of the request, or respond with a 504 (Gateway Timeout) status code. If a group of caches is being operated as a unified system with good internal connectivity, a member cache MAY forward such a request within that group of caches.",
      "ja": "「のみ-場合、キャッシュされた」リクエストディレクティブはクライアントにのみ保存された応答を得るために望んでいることを示しています。それはこの指令を受信した場合、キャッシュは、いずれかの要求の他の制約と一致する格納された応答を用いて応答、または504（ゲートウェイタイムアウト）ステータスコードで応答すべきです。キャッシュのグループが良好な内部接続で統一されたシステムとして動作している場合、メンバー・キャッシュは、キャッシュのそのグループ内のこのような要求を転送することができます。"
    },
    {
      "indent": 0,
      "text": "5.2.2. Response Cache-Control Directives",
      "section_title": true,
      "ja": "5.2.2. 応答のCache-Controlディレクティブ"
    },
    {
      "indent": 0,
      "text": "5.2.2.1. must-revalidate",
      "section_title": true,
      "ja": "5.2.2.1。 - 再検証しなければなりません"
    },
    {
      "indent": 3,
      "text": "The \"must-revalidate\" response directive indicates that once it has become stale, a cache MUST NOT use the response to satisfy subsequent requests without successful validation on the origin server.",
      "ja": "「-再検証しなければならない」応答ディレクティブは、それが陳腐化した後、キャッシュがオリジンサーバに正常に検証せずに後続の要求を満たすために応答を使用してはならないことを示しています。"
    },
    {
      "indent": 3,
      "text": "The must-revalidate directive is necessary to support reliable operation for certain protocol features. In all circumstances a cache MUST obey the must-revalidate directive; in particular, if a cache cannot reach the origin server for any reason, it MUST generate a 504 (Gateway Timeout) response.",
      "ja": "必携再検証ディレクティブは、特定のプロトコル機能の信頼性の高い動作をサポートするために必要です。すべての状況ではキャッシュは必見-再検証指示に従わなければなりません。キャッシュが何らかの理由でオリジンサーバに到達できない場合は特に、それは504（ゲートウェイタイムアウト）応答を生成しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The must-revalidate directive ought to be used by servers if and only if failure to validate a request on the representation could result in incorrect operation, such as a silently unexecuted financial transaction.",
      "ja": "必携再検証ディレクティブは、表現上の要求を検証するために、障害が、そのような静かに未実行の金融取引として、誤動作が生じる可能性が場合に限り、サーバーによって使用されるべきです。"
    },
    {
      "indent": 0,
      "text": "5.2.2.2. no-cache",
      "section_title": true,
      "ja": "5.2.2.2。ノーキャッシュません"
    },
    {
      "indent": 3,
      "text": "Argument syntax:",
      "ja": "引数の構文："
    },
    {
      "indent": 6,
      "text": "#field-name",
      "ja": "＃フィールド名"
    },
    {
      "indent": 3,
      "text": "The \"no-cache\" response directive indicates that the response MUST NOT be used to satisfy a subsequent request without successful validation on the origin server. This allows an origin server to prevent a cache from using it to satisfy a request without contacting it, even by caches that have been configured to send stale responses.",
      "ja": "「キャッシュなし」応答ディレクティブはレスポンスがオリジンサーバに正常に検証せずに後続の要求を満たすために使用してはならないことを示しています。これは、オリジンサーバでも古くなったレスポンスを送信するように設定されているキャッシュによって、それに接触することなく、要求を満たすためにそれを使用してからキャッシュを防ぐことができます。"
    },
    {
      "indent": 3,
      "text": "If the no-cache response directive specifies one or more field-names, then a cache MAY use the response to satisfy a subsequent request, subject to any other restrictions on caching. However, any header fields in the response that have the field-name(s) listed MUST NOT be sent in the response to a subsequent request without successful revalidation with the origin server. This allows an origin server to prevent the re-use of certain header fields in a response, while still allowing caching of the rest of the response.",
      "ja": "キャッシュなし応答ディレクティブは、1つまたは複数のフィールド名を指定している場合、キャッシュは、キャッシュ上の他の制限を受ける後続の要求を満たすために応答を使用するかもしれません。しかし、リストされたフィールド名を有していて応答における任意のヘッダフィールドは、オリジンサーバとの正常な再検証することなく次の要求に応じて送信してはいけません。これは、まだ応答の残りのキャッシングを可能にしながら、応答における特定のヘッダフィールドの再使用を防止するために、オリジンサーバが可能になります。"
    },
    {
      "indent": 3,
      "text": "The field-names given are not limited to the set of header fields defined by this specification. Field names are case-insensitive.",
      "ja": "与えられたフィールド名は、この仕様で定義されたヘッダフィールドのセットに限定されません。フィールド名は大文字と小文字を区別しません。"
    },
    {
      "indent": 3,
      "text": "This directive uses the quoted-string form of the argument syntax. A sender SHOULD NOT generate the token form (even if quoting appears not to be needed for single-entry lists).",
      "ja": "このディレクティブは、引数構文の引用符で囲まれた文字列の形式を使用しています。送信者は、トークン形式を（引用は、シングルエントリーリストのために必要なことがないように見える場合でも）生成するべきではありません。"
    },
    {
      "indent": 3,
      "text": "Note: Although it has been back-ported to many implementations, some HTTP/1.0 caches will not recognize or obey this directive. Also, no-cache response directives with field-names are often handled by caches as if an unqualified no-cache directive was received; i.e., the special handling for the qualified form is not widely implemented.",
      "ja": "注：それは多くの実装にバックポートされているが、いくつかのHTTP / 1.0キャッシュはこのディレクティブを認識したり従わないであろう。修飾されていないキャッシュなしディレクティブを受信したかのようにまた、フィールドの名前を持つキャッシュなし応答ディレクティブは、多くの場合、キャッシュによって処理されます。すなわち、修飾形式のための特別な処理は、広く実装されていません。"
    },
    {
      "indent": 0,
      "text": "5.2.2.3. no-store",
      "section_title": true,
      "ja": "５。２。２。３。 のーｓとれ"
    },
    {
      "indent": 3,
      "text": "The \"no-store\" response directive indicates that a cache MUST NOT store any part of either the immediate request or response. This directive applies to both private and shared caches. \"MUST NOT store\" in this context means that the cache MUST NOT intentionally store the information in non-volatile storage, and MUST make a best-effort attempt to remove the information from volatile storage as promptly as possible after forwarding it.",
      "ja": "「無店舗」応答ディレクティブは、キャッシュが即時要求または応答のいずれかの任意の部分を格納してはならないことを示しています。このディレクティブは、プライベートと共有キャッシュの両方に適用されます。この文脈で「保存てはならない」キャッシュが意図的に不揮発性ストレージに情報を格納してはいけませんし、それを転送した後、できるだけ速やかに揮発性の記憶装置から情報を削除するにはベストエフォート型試みを作る必要があります。"
    },
    {
      "indent": 3,
      "text": "This directive is NOT a reliable or sufficient mechanism for ensuring privacy. In particular, malicious or compromised caches might not recognize or obey this directive, and communications networks might be vulnerable to eavesdropping.",
      "ja": "このディレクティブは、プライバシーを確​​保するための信頼できるか、十分なメカニズムではありません。特に、悪意のあるまたは妥協キャッシュは認識したり、このディレクティブを遵守し、通信ネットワークは盗聴に対して脆弱であるかもしれないではないかもしれません。"
    },
    {
      "indent": 0,
      "text": "5.2.2.4. no-transform",
      "section_title": true,
      "ja": "5.2.2.4。無変換"
    },
    {
      "indent": 3,
      "text": "The \"no-transform\" response directive indicates that an intermediary (regardless of whether it implements a cache) MUST NOT transform the payload, as defined in Section 5.7.2 of [RFC7230].",
      "ja": "「無変換」応答指令は、[RFC7230]のセクション5.7.2で定義されるように（かかわらず、それはキャッシュを実装しているかどうかの）仲介は、ペイロード変換はならないことを示します。"
    },
    {
      "indent": 0,
      "text": "5.2.2.5. public",
      "section_title": true,
      "ja": "5.2.2.5。公"
    },
    {
      "indent": 3,
      "text": "The \"public\" response directive indicates that any cache MAY store the response, even if the response would normally be non-cacheable or cacheable only within a private cache. (See Section 3.2 for additional details related to the use of public in response to a request containing Authorization, and Section 3 for details of how public affects responses that would normally not be stored, due to their status codes not being defined as cacheable by default; see Section 4.2.2.)",
      "ja": "「パブリック」応答ディレクティブは応答が正常にのみプライベートキャッシュ内の非キャッシュ可能またはキャッシュ可能になり場合でも、任意のキャッシュは、応答を格納することができることを示しています。 （認証を含む要求に応じて、公衆の使用に関連する追加の詳細については、セクション3.2、および公衆が通常はデフォルトでキャッシュ可能と定義されていないため、そのステータスコードに、保存されない応答をどのように影響するかの詳細については、第3節を参照してください。 ; 4.2.2項を参照してください）。"
    },
    {
      "indent": 0,
      "text": "5.2.2.6. private",
      "section_title": true,
      "ja": "5.2.2.6。民間"
    },
    {
      "indent": 3,
      "text": "Argument syntax:",
      "ja": "引数の構文："
    },
    {
      "indent": 6,
      "text": "#field-name",
      "ja": "＃フィールド名"
    },
    {
      "indent": 3,
      "text": "The \"private\" response directive indicates that the response message is intended for a single user and MUST NOT be stored by a shared cache. A private cache MAY store the response and reuse it for later requests, even if the response would normally be non-cacheable.",
      "ja": "「プライベート」応答ディレクティブは、応答メッセージは、単一のユーザーを対象とし、共有キャッシュによって保存されてはならないことを示しています。プライベートキャッシュは、応答が正常にキャッシュ不可能だろうしても、応答を保存し、後で要求のためにそれを再利用することができます。"
    },
    {
      "indent": 3,
      "text": "If the private response directive specifies one or more field-names, this requirement is limited to the field-values associated with the listed response header fields. That is, a shared cache MUST NOT store the specified field-names(s), whereas it MAY store the remainder of the response message.",
      "ja": "プライベート応答ディレクティブは、1つまたは複数のフィールド名を指定している場合、この要件が記載されているレスポンスヘッダフィールドに関連付けられたフィールドの値に制限されています。すなわち、共有キャッシュは、応答メッセージの残りの部分を格納することができるのに対し、指定されたフィールドの名前（複数可）を格納してはいけませんです。"
    },
    {
      "indent": 3,
      "text": "The field-names given are not limited to the set of header fields defined by this specification. Field names are case-insensitive.",
      "ja": "与えられたフィールド名は、この仕様で定義されたヘッダフィールドのセットに限定されません。フィールド名は大文字と小文字を区別しません。"
    },
    {
      "indent": 3,
      "text": "This directive uses the quoted-string form of the argument syntax. A sender SHOULD NOT generate the token form (even if quoting appears not to be needed for single-entry lists).",
      "ja": "このディレクティブは、引数構文の引用符で囲まれた文字列の形式を使用しています。送信者は、トークン形式を（引用は、シングルエントリーリストのために必要なことがないように見える場合でも）生成するべきではありません。"
    },
    {
      "indent": 3,
      "text": "Note: This usage of the word \"private\" only controls where the response can be stored; it cannot ensure the privacy of the message content. Also, private response directives with field-names are often handled by caches as if an unqualified private directive was received; i.e., the special handling for the qualified form is not widely implemented.",
      "ja": "注意：レスポンスを保存することができる単語「プライベート」のみのコントロールのこの使用法を、それは、メッセージ内容のプライバシーを確​​保することはできません。また、フィールド名を持つプライベート応答ディレクティブは、多くの場合、修飾されていないプライベートな指令を受信したかのように、キャッシュによって処理されます。すなわち、修飾形式のための特別な処理は、広く実装されていません。"
    },
    {
      "indent": 0,
      "text": "5.2.2.7. proxy-revalidate",
      "section_title": true,
      "ja": "5.2.2.7。プロキシ再検証"
    },
    {
      "indent": 3,
      "text": "The \"proxy-revalidate\" response directive has the same meaning as the must-revalidate response directive, except that it does not apply to private caches.",
      "ja": "「プロキシ・再検証」応答ディレクティブは、それが民間のキャッシュには適用されないことを除いて、必見再検証応答ディレクティブと同じ意味を持っています。"
    },
    {
      "indent": 0,
      "text": "5.2.2.8. max-age",
      "section_title": true,
      "ja": "5.2.2.8。最大エージング"
    },
    {
      "indent": 3,
      "text": "Argument syntax:",
      "ja": "引数の構文："
    },
    {
      "indent": 6,
      "text": "delta-seconds (see Section 1.2.1)",
      "ja": "デルタ秒（1.2.1項を参照してください）"
    },
    {
      "indent": 3,
      "text": "The \"max-age\" response directive indicates that the response is to be considered stale after its age is greater than the specified number of seconds.",
      "ja": "「最大エージング」応答ディレクティブは、その年齢が指定された秒数よりも大きくなった後、応答が無効と見なされるべきであることを示しています。"
    },
    {
      "indent": 3,
      "text": "This directive uses the token form of the argument syntax: e.g., 'max-age=5' not 'max-age=\"5\"'. A sender SHOULD NOT generate the quoted-string form.",
      "ja": "例えば、「最大-年齢= 5」ではない「最大-年齢= 『5』」：このディレクティブは、引数構文のトークン形式を使用しています。送信者は、引用符で囲まれた文字列の形式を生成するべきではありません。"
    },
    {
      "indent": 0,
      "text": "5.2.2.9. s-maxage",
      "section_title": true,
      "ja": "5.2.2.9。 S-MAXAGE"
    },
    {
      "indent": 3,
      "text": "Argument syntax:",
      "ja": "引数の構文："
    },
    {
      "indent": 6,
      "text": "delta-seconds (see Section 1.2.1)",
      "ja": "デルタ秒（1.2.1項を参照してください）"
    },
    {
      "indent": 3,
      "text": "The \"s-maxage\" response directive indicates that, in shared caches, the maximum age specified by this directive overrides the maximum age specified by either the max-age directive or the Expires header field. The s-maxage directive also implies the semantics of the proxy-revalidate response directive.",
      "ja": "「S-MAXAGE」応答指示は、共有キャッシュに、この指令で指定された最大年齢MAXAGEディレクティブまたは期限切れヘッダフィールドのいずれかによって指定された最大保存期間をオーバーライド、ことを示しています。 S-MAXAGEディレクティブはまた、プロキシ再検証応答ディレクティブの意味を暗示しています。"
    },
    {
      "indent": 3,
      "text": "This directive uses the token form of the argument syntax: e.g., 's-maxage=10' not 's-maxage=\"10\"'. A sender SHOULD NOT generate the quoted-string form.",
      "ja": "例えば、 'S-MAXAGE = 10' ではないの-MAXAGE = \"10\" '：このディレクティブは、引数構文のトークン形式を使用しています。送信者は、引用符で囲まれた文字列の形式を生成するべきではありません。"
    },
    {
      "indent": 0,
      "text": "5.2.3. Cache Control Extensions",
      "section_title": true,
      "ja": "5.2.3. キャッシュ制御拡張機能"
    },
    {
      "indent": 3,
      "text": "The Cache-Control header field can be extended through the use of one or more cache-extension tokens, each with an optional value. A cache MUST ignore unrecognized cache directives.",
      "ja": "キャッシュ制御ヘッダフィールドは任意の値を有する1つ以上のキャッシュ拡張トークン、それぞれの使用を通じて拡張することができます。キャッシュは認識されていないキャッシュディレクティブを無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Informational extensions (those that do not require a change in cache behavior) can be added without changing the semantics of other directives.",
      "ja": "情報の拡張（キャッシュの振る舞いの変更を必要としないもの）は、他のディレクティブの意味を変えずに追加することができます。"
    },
    {
      "indent": 3,
      "text": "Behavioral extensions are designed to work by acting as modifiers to the existing base of cache directives. Both the new directive and the old directive are supplied, such that applications that do not understand the new directive will default to the behavior specified by the old directive, and those that understand the new directive will recognize it as modifying the requirements associated with the old directive. In this way, extensions to the existing cache-control directives can be made without breaking deployed caches.",
      "ja": "行動拡張がキャッシュディレクティブの既存のベースへの修飾子として作用することによって動作するように設計されています。どちらも新しいディレクティブと古いディレクティブは、新しいディレクティブを理解していないアプリケーションでは、古いディレクティブで指定された動作がデフォルトになりますように、供給され、新しいディレクティブを理解しているものは、古いに関連付けられている要件を変更すると、それを認識します指令。このように、既存のキャッシュ制御ディレクティブへの拡張が展開され、キャッシュを壊すことなく行うことができます。"
    },
    {
      "indent": 3,
      "text": "For example, consider a hypothetical new response directive called \"community\" that acts as a modifier to the private directive: in addition to private caches, any cache that is shared only by members of the named community is allowed to cache the response. An origin server wishing to allow the UCI community to use an otherwise private response in their shared cache(s) could do so by including",
      "ja": "たとえば、プライベートディレクティブの修飾子として動作する「コミュニティ」と呼ばれる架空の新しい応答ディレクティブを考えてみます。プライベートのキャッシュに加えて、唯一の名前のコミュニティのメンバーによって共有されているすべてのキャッシュが応答をキャッシュすることが許可されています。 UCIコミュニティは彼らの共有キャッシュ（複数可）で特に民間応答を使用できるようにしたいオリジンサーバは、以下を含むことによって行うことができ"
    },
    {
      "indent": 5,
      "text": "Cache-Control: private, community=\"UCI\"",
      "ja": "Cache-Control：プライベート、コミュニティ= \"UCI\""
    },
    {
      "indent": 3,
      "text": "A cache that recognizes such a community cache-extension could broaden its behavior in accordance with that extension. A cache that does not recognize the community cache-extension would ignore it and adhere to the private directive.",
      "ja": "その拡張子に基づいて、その動作を広げることができ、このようなコミュニティのキャッシュ拡張を認識してキャッシュ。コミュニティのキャッシュ拡張子を認識しないキャッシュはそれを無視し、民間指令に準拠します。"
    },
    {
      "indent": 0,
      "text": "5.3. Expires",
      "section_title": true,
      "ja": "5.3. 有効期限"
    },
    {
      "indent": 3,
      "text": "The \"Expires\" header field gives the date/time after which the response is considered stale. See Section 4.2 for further discussion of the freshness model.",
      "ja": "ヘッダフィールドは、応答が古くなったとみなされた後の日付/時間を与える「有効期限」。鮮度モデルのさらなる議論については、セクション4.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "The presence of an Expires field does not imply that the original resource will change or cease to exist at, before, or after that time.",
      "ja": "有効期限フィールドの存在は、元のリソースを変更したりする前に、またはその時間の後、に存在しなくなることを意味するものではありません。"
    },
    {
      "indent": 3,
      "text": "The Expires value is an HTTP-date timestamp, as defined in Section 7.1.1.1 of [RFC7231].",
      "ja": "[RFC7231]のセクション7.1.1.1で定義されている有効期限値は、HTTP-日付スタンプです。"
    },
    {
      "indent": 5,
      "text": "Expires = HTTP-date",
      "ja": "= HTTP-日付有効期限"
    },
    {
      "indent": 3,
      "text": "For example",
      "ja": "例えば"
    },
    {
      "indent": 5,
      "text": "Expires: Thu, 01 Dec 1994 16:00:00 GMT",
      "ja": "有効期限：木、1994年12月1日16時00分00秒GMT"
    },
    {
      "indent": 3,
      "text": "A cache recipient MUST interpret invalid date formats, especially the value \"0\", as representing a time in the past (i.e., \"already expired\").",
      "ja": "キャッシュの受信者（すなわち、「すでに期限切れ」）過去の時間を表すものとして、特に値が「0」、無効な日付フォーマットを解釈する必要があります。"
    },
    {
      "indent": 3,
      "text": "If a response includes a Cache-Control field with the max-age directive (Section 5.2.2.8), a recipient MUST ignore the Expires field. Likewise, if a response includes the s-maxage directive (Section 5.2.2.9), a shared cache recipient MUST ignore the Expires field. In both these cases, the value in Expires is only intended for recipients that have not yet implemented the Cache-Control field.",
      "ja": "応答がMAX-ageディレクティブ（セクション5.2.2.8）とのCache-Controlフィールドが含まれている場合、受信者は、フィールドの有効期限無視しなければなりません。応答がS-MAXAGEディレクティブ（セクション5.2.2.9）が含まれている場合同様に、共有キャッシュの受信者は、フィールドの有効期限無視しなければなりません。どちらの場合も、有効期限内の値は唯一、まだのCache-Controlフィールドを実装していない受信者を対象としています。"
    },
    {
      "indent": 3,
      "text": "An origin server without a clock MUST NOT generate an Expires field unless its value represents a fixed time in the past (always expired) or its value has been associated with the resource by a system or user with a reliable clock.",
      "ja": "時計のないオリジンサーバは、その値が過去の一定時間を表している（常に期限切れ）またはその値は信頼性の高いクロックを持つシステムまたはユーザーによってリソースに関連付けられていない限り、フィールドの有効期限発生させてはいけません。"
    },
    {
      "indent": 3,
      "text": "Historically, HTTP required the Expires field-value to be no more than a year in the future. While longer freshness lifetimes are no longer prohibited, extremely large values have been demonstrated to cause problems (e.g., clock overflows due to use of 32-bit integers for time values), and many caches will evict a response far sooner than that.",
      "ja": "歴史的に、HTTPは、将来的に年を超えないために有効期限フィールド値を必要としていました。長く鮮度寿命はもはや禁止されていますが、非常に大きな値が問題を引き起こすことが実証されていない（例えば、時計は時間値の32ビット整数の使用に起因するオーバーフローし）、そして多くのキャッシュははるかに早くそれよりもレスポンスを追い出します。"
    },
    {
      "indent": 0,
      "text": "5.4. Pragma",
      "section_title": true,
      "ja": "5.4. 事"
    },
    {
      "indent": 3,
      "text": "The \"Pragma\" header field allows backwards compatibility with HTTP/1.0 caches, so that clients can specify a \"no-cache\" request that they will understand (as Cache-Control was not defined until HTTP/1.1). When the Cache-Control header field is also present and understood in a request, Pragma is ignored.",
      "ja": "クライアントは、彼らが理解する「キャッシュなし」要求（のCache-Controlは、HTTP / 1.1になるまで定義されていなかったとして）を指定することができるように、「プラグマ」ヘッダフィールドは、HTTP / 1.0キャッシュとの下位互換性を可能にします。キャッシュ制御ヘッダフィールドも存在し、リクエストで理解されている場合、プラグマは無視されます。"
    },
    {
      "indent": 3,
      "text": "In HTTP/1.0, Pragma was defined as an extensible field for implementation-specified directives for recipients. This specification deprecates such extensions to improve interoperability.",
      "ja": "HTTP / 1.0では、プラグマは、受信者の実装が指定指示するための拡張可能なフィールドとして定義しました。この仕様は、相互運用性を向上させるために、このような拡張を非難します。"
    },
    {
      "indent": 5,
      "text": "Pragma = 1#pragma-directive pragma-directive = \"no-cache\" / extension-pragma extension-pragma = token [ \"=\" ( token / quoted-string ) ]",
      "ja": "プラグマ= 1＃プラグマ指令プラグマ指令= \"ノーキャッシュ\" /拡張プラグマ拡張-プラグマ=トークン[ \"=\"（トークン/引用符で囲まれた文字列）]"
    },
    {
      "indent": 3,
      "text": "When the Cache-Control header field is not present in a request, caches MUST consider the no-cache request pragma-directive as having the same effect as if \"Cache-Control: no-cache\" were present (see Section 5.2.1).",
      "ja": "「のCache-Control：キャッシュなし」のCache-Controlヘッダフィールドは、リクエストに存在しない場合は、キャッシュはキャッシュなしの要求プラグマディレクティブの場合と同じ効果を持つなどを考慮しなければならない（5.2.1項を参照）存在していました。"
    },
    {
      "indent": 3,
      "text": "When sending a no-cache request, a client ought to include both the pragma and cache-control directives, unless Cache-Control: no-cache is purposefully omitted to target other Cache-Control response directives at HTTP/1.1 caches. For example:",
      "ja": "キャッシュなしの要求を送信する場合、クライアントはプラグマとキャッシュ制御ディレクティブの両方が含まれるべき、のCache-Controlない限り：ノーキャッシュは意図的にHTTP / 1.1キャッシュで他のCache-Controlレスポンス・ディレクティブをターゲットに省略されていません。例えば："
    },
    {
      "indent": 5,
      "text": "GET / HTTP/1.1 Host: www.example.com Cache-Control: max-age=30 Pragma: no-cache",
      "ja": "GET / HTTP / 1.1ホスト：www.example.comのCache-Control：MAX-年齢= 30プラグマ：キャッシュなし"
    },
    {
      "indent": 3,
      "text": "will constrain HTTP/1.1 caches to serve a response no older than 30 seconds, while precluding implementations that do not understand Cache-Control from serving a cached response.",
      "ja": "キャッシュされた応答を提供するからのCache-Controlを理解していない実装を排除しながら、30秒を超えない古い応答を提供するためにHTTP / 1.1キャッシュを制限します。"
    },
    {
      "indent": 6,
      "text": "Note: Because the meaning of \"Pragma: no-cache\" in responses is not specified, it does not provide a reliable replacement for \"Cache-Control: no-cache\" in them.",
      "ja": "注意：「プラグマ：キャッシュなし」の意味なので：それらにおける応答では、指定されていない、それは「キャッシュなしのCache-Control」のための信頼性の高い代替を提供していません。"
    },
    {
      "indent": 0,
      "text": "5.5. Warning",
      "section_title": true,
      "ja": "5.5. 警告"
    },
    {
      "indent": 3,
      "text": "The \"Warning\" header field is used to carry additional information about the status or transformation of a message that might not be reflected in the status code. This information is typically used to warn about possible incorrectness introduced by caching operations or transformations applied to the payload of the message.",
      "ja": "「警告」ヘッダフィールドはステータスコードに反映されないかもしれないメッセージのステータスまたは変換に関する追加情報を搬送するために使用されます。この情報は、典型的には、メッセージのペイロードに適用される操作または変換をキャッシュすることによって導入可能不正について警告するために使用されます。"
    },
    {
      "indent": 3,
      "text": "Warnings can be used for other purposes, both cache-related and otherwise. The use of a warning, rather than an error status code, distinguishes these responses from true failures.",
      "ja": "警告は、キャッシュ関連とそれ以外の両方の、他の目的に使用することができます。警告ではなく、エラーステータスコードの使用は、真の障害からこれらの応答を区別します。"
    },
    {
      "indent": 3,
      "text": "Warning header fields can in general be applied to any message, however some warn-codes are specific to caches and can only be applied to response messages.",
      "ja": "警告ヘッダフィールドは、一般に、しかしいくつかは、警告・コードがキャッシュに特異的であるとのみ応答メッセージに適用することができる、任意のメッセージにも適用することができます。"
    },
    {
      "indent": 5,
      "text": "Warning = 1#warning-value",
      "ja": "警告= 1＃警告値"
    },
    {
      "indent": 5,
      "text": "warning-value = warn-code SP warn-agent SP warn-text [ SP warn-date ]",
      "ja": "警告値=警告コードSP警告エージェントSP警告テキスト[SP警告日付]"
    },
    {
      "indent": 5,
      "text": "warn-code = 3DIGIT warn-agent = ( uri-host [ \":\" port ] ) / pseudonym ; the name or pseudonym of the server adding ; the Warning header field, for use in debugging ; a single \"-\" is recommended when agent unknown warn-text = quoted-string warn-date = DQUOTE HTTP-date DQUOTE",
      "ja": "警告コード= 3DIGIT警告エージェント=（URI-ホスト[ \"：\" ポート]）/仮名。追加するサーバーの名前または仮名。デバッグで使用するための警告ヘッダーフィールド、;シングルは、「 - 」エージェントの不明が警告テキスト=引用符で囲まれた文字列を警告日付= DQUOTE HTTP-日付DQUOTEお勧めします"
    },
    {
      "indent": 3,
      "text": "Multiple warnings can be generated in a response (either by the origin server or by a cache), including multiple warnings with the same warn-code number that only differ in warn-text.",
      "ja": "複数の警告は、警告テキストをにおける異なる同じ警告コードの番号を持つ複数の警告を含む応答（オリジンサーバによって、またはキャッシュのいずれかによって）、生成することができます。"
    },
    {
      "indent": 3,
      "text": "A user agent that receives one or more Warning header fields SHOULD inform the user of as many of them as possible, in the order that they appear in the response. Senders that generate multiple Warning header fields are encouraged to order them with this user agent behavior in mind. A sender that generates new Warning header fields MUST append them after any existing Warning header fields.",
      "ja": "一つ以上の警告ヘッダフィールドを受信するユーザエージェントは、それらが反応して現れるようにするために、可能な限りそれらの多くのユーザに知らせるべきです。複数のWarningヘッダーフィールドを生成する送信者が念頭に置いて、このユーザエージェントの行動でそれらを注文することをお勧めします。新しいWarningヘッダーフィールドを生成し、送信者は、既存のWarningヘッダーフィールドの後にそれらを追加しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Warnings are assigned three digit warn-codes. The first digit indicates whether the Warning is required to be deleted from a stored response after validation:",
      "ja": "警告は3桁の警告-コードが割り当てられています。最初の桁は、警告を確認した後、保存された応答から削除する必要があるかどうかを示します。"
    },
    {
      "indent": 3,
      "text": "o 1xx warn-codes describe the freshness or validation status of the response, and so they MUST be deleted by a cache after validation. They can only be generated by a cache when validating a cached entry, and MUST NOT be generated in any other situation.",
      "ja": "Oの1xxは警告-コードを応答の鮮度や検証状態を説明し、そのため彼らは、検証後、キャッシュによって削除されなければなりません。彼らは、キャッシュされたエントリを検証するときにのみ、キャッシュによって生成することができ、かつ他のどのような状況で生成されてはなりません。"
    },
    {
      "indent": 3,
      "text": "o 2xx warn-codes describe some aspect of the representation that is not rectified by a validation (for example, a lossy compression of the representation) and they MUST NOT be deleted by a cache after validation, unless a full response is sent, in which case they MUST be.",
      "ja": "O 2XXは、検証により整流されていない表現のいくつかの局面を記載コードは、警告（例えば、表現の非可逆圧縮）および完全応答が送信されない限りは、検証後にキャッシュすることによって削除されない必要があります彼らがしなければならない場合。"
    },
    {
      "indent": 3,
      "text": "If a sender generates one or more 1xx warn-codes in a message to be sent to a recipient known to implement only HTTP/1.0, the sender MUST include in each corresponding warning-value a warn-date that matches the Date header field in the message. For example:",
      "ja": "送信者がメッセージ内の1つまたは複数の1XX警告・コードを生成する場合のみHTTP / 1.0を実装することが知られている受信者に送信する、送信者は、対応する各警告値での日付ヘッダーフィールドに一致警告日付を含まなければなりませんメッセージ。例えば："
    },
    {
      "indent": 5,
      "text": "HTTP/1.1 200 OK Date: Sat, 25 Aug 2012 23:34:45 GMT Warning: 112 - \"network down\" \"Sat, 25 Aug 2012 23:34:45 GMT\"",
      "ja": "HTTP / 1.1 200 OK日付：土、2012年8月25日午前23時34分45秒GMT警告：112  -  \"ダウンネットワーク\" \"土、2012年8月25日午前23時34分45秒GMT\""
    },
    {
      "indent": 3,
      "text": "Warnings have accompanying warn-text that describes the error, e.g., for logging. It is advisory only, and its content does not affect interpretation of the warn-code.",
      "ja": "警告は警告するテキストのエラーを説明し、例えば、ログに付随しています。それが唯一の顧問であり、その内容は、警告コードの解釈に影響を与えることはありません。"
    },
    {
      "indent": 3,
      "text": "If a recipient that uses, evaluates, or displays Warning header fields receives a warn-date that is different from the Date value in the same message, the recipient MUST exclude the warning-value containing that warn-date before storing, forwarding, or using the message. This allows recipients to exclude warning-values that were improperly retained after a cache validation. If all of the warning-values are excluded, the recipient MUST exclude the Warning header field as well.",
      "ja": "使用する受信者が評価し、又はヘッダフィールド警告表示は、同じメッセージの日付値と異なる警告日付を受信した場合、受信者は、記憶、転送、または使用前に警告し、日付を含む警告値を除外しなければなりませんメッセージ。これは、受信者が不適切にキャッシュの検証後に保持された警告値を除外することができます。警告値の全てが除外されている場合、受信者は、同様に警告ヘッダフィールドを除外する必要があります。"
    },
    {
      "indent": 3,
      "text": "The following warn-codes are defined by this specification, each with a recommended warn-text in English, and a description of its meaning. The procedure for defining additional warn codes is described in Section 7.2.1.",
      "ja": "以下は、警告・コードをそれぞれ英語で推奨される警告テキスト、およびその意味の説明と、この仕様で定義されています。追加の警告コードを定義するための手順は、セクション7.2.1に記載されています。"
    },
    {
      "indent": 0,
      "text": "5.5.1. Warning: 110 - \"Response is Stale\"",
      "section_title": true,
      "ja": "5.5.1. 警告：110  - 「レスポンスが古くなっています」"
    },
    {
      "indent": 3,
      "text": "A cache SHOULD generate this whenever the sent response is stale.",
      "ja": "送信された応答が古くなっている時はいつでもキャッシュがこれを生成する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.5.2. Warning: 111 - \"Revalidation Failed\"",
      "section_title": true,
      "ja": "5.5.2. 警告：111  - 「再確認に失敗しました」"
    },
    {
      "indent": 3,
      "text": "A cache SHOULD generate this when sending a stale response because an attempt to validate the response failed, due to an inability to reach the server.",
      "ja": "応答を検証しようとする試みが失敗したため、原因のサーバーに到達することができないため、古くなったレスポンスを送信するときにキャッシュがこれを生成する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.5.3. Warning: 112 - \"Disconnected Operation\"",
      "section_title": true,
      "ja": "5.5.3. 警告：112  - 「切断操作」"
    },
    {
      "indent": 3,
      "text": "A cache SHOULD generate this if it is intentionally disconnected from the rest of the network for a period of time.",
      "ja": "それは意図的に一定の期間のために残りのネットワークから切断された場合、キャッシュは、これを生成する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.5.4. Warning: 113 - \"Heuristic Expiration\"",
      "section_title": true,
      "ja": "5.5.4. 警告：113  - 「ヒューリスティック有効期限」"
    },
    {
      "indent": 3,
      "text": "A cache SHOULD generate this if it heuristically chose a freshness lifetime greater than 24 hours and the response's age is greater than 24 hours.",
      "ja": "それは発見的に24時間以上新鮮寿命を選んだとレスポンスの年齢が24時間よりも大きい場合、キャッシュはこれを生成する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.5.5. Warning: 199 - \"Miscellaneous Warning\"",
      "section_title": true,
      "ja": "5.5.5. 警告：199  - 「その他の警告」"
    },
    {
      "indent": 3,
      "text": "The warning text can include arbitrary information to be presented to a human user or logged. A system receiving this warning MUST NOT take any automated action, besides presenting the warning to the user.",
      "ja": "警告テキストは人間のユーザに提示されるまたは記録する任意の情報を含むことができます。この警告を受けたシステムは、ユーザに警告を提示するほか、任意の自動化された行動をしてはなりません。"
    },
    {
      "indent": 0,
      "text": "5.5.6. Warning: 214 - \"Transformation Applied\"",
      "section_title": true,
      "ja": "5.5.6. 警告：214  - 「変革応用」"
    },
    {
      "indent": 3,
      "text": "This Warning code MUST be added by a proxy if it applies any transformation to the representation, such as changing the content-coding, media-type, or modifying the representation data, unless this Warning code already appears in the response.",
      "ja": "そのようなコンテンツコーディング、メディアタイプを変更すること、またはこの警告コードが既に応答して表示されていない限り、表現データを変更するように、表現に任意の変換を適用する場合は、この警告コードは、プロキシによって追加されなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.5.7. Warning: 299 - \"Miscellaneous Persistent Warning\"",
      "section_title": true,
      "ja": "5.5.7. 警告：299  - 「その他の永続的な警告」"
    },
    {
      "indent": 3,
      "text": "The warning text can include arbitrary information to be presented to a human user or logged. A system receiving this warning MUST NOT take any automated action.",
      "ja": "警告テキストは人間のユーザに提示されるまたは記録する任意の情報を含むことができます。この警告を受けたシステムは、任意の自動化された行動をしてはなりません。"
    },
    {
      "indent": 0,
      "text": "6. History Lists",
      "section_title": true,
      "ja": "6.履歴リスト"
    },
    {
      "indent": 3,
      "text": "User agents often have history mechanisms, such as \"Back\" buttons and history lists, that can be used to redisplay a representation retrieved earlier in a session.",
      "ja": "ユーザーエージェントは、多くの場合、以前のセッションで取得した表現を再表示するために使用することができ、そのような「戻る」ボタンと履歴リストなどの履歴メカニズムを、持っています。"
    },
    {
      "indent": 3,
      "text": "The freshness model (Section 4.2) does not necessarily apply to history mechanisms. That is, a history mechanism can display a previous representation even if it has expired.",
      "ja": "鮮度モデル（4.2節）は、必ずしも歴史メカニズムには適用されません。つまり、履歴メカニズムは、それが期限切れになった場合でも、以前の表現を表示することができます。"
    },
    {
      "indent": 3,
      "text": "This does not prohibit the history mechanism from telling the user that a view might be stale or from honoring cache directives (e.g., Cache-Control: no-store).",
      "ja": "これは、ビューが古いか称えるキャッシュディレクティブ（：無店舗例えば、のCache-Control）からかもしれないユーザーに伝えるから履歴メカニズムを禁止するものではありません。"
    },
    {
      "indent": 0,
      "text": "7. IANA Considerations",
      "section_title": true,
      "ja": "7. IANAの考慮事項"
    },
    {
      "indent": 0,
      "text": "7.1. Cache Directive Registry",
      "section_title": true,
      "ja": "7.1. キャッシュ指令レジストリ"
    },
    {
      "indent": 3,
      "text": "The \"Hypertext Transfer Protocol (HTTP) Cache Directive Registry\" defines the namespace for the cache directives. It has been created and is now maintained at <http://www.iana.org/assignments/http-cache-directives>.",
      "ja": "「ハイパーテキスト転送プロトコル（HTTP）キャッシュ指令レジストリは」キャッシュディレクティブの名前空間を定義します。これは、作成されており、現在、<http://www.iana.org/assignments/http-cache-directives>に維持されています。"
    },
    {
      "indent": 0,
      "text": "7.1.1. Procedure",
      "section_title": true,
      "ja": "7.1.1. 手順"
    },
    {
      "indent": 3,
      "text": "A registration MUST include the following fields:",
      "ja": "登録は、次のフィールドを含める必要があります。"
    },
    {
      "indent": 3,
      "text": "o Cache Directive Name o Pointer to specification text",
      "ja": "ポインタのキャッシュディレクティブ名O仕様のテキストに"
    },
    {
      "indent": 3,
      "text": "Values to be added to this namespace require IETF Review (see [RFC5226], Section 4.1).",
      "ja": "この名前空間に追加される値は、IETFレビュー（参照[RFC5226]、セクション4.1）が必要です。"
    },
    {
      "indent": 0,
      "text": "7.1.2. Considerations for New Cache Control Directives",
      "section_title": true,
      "ja": "7.1.2. 新しいキャッシュ制御指令のための考慮事項"
    },
    {
      "indent": 3,
      "text": "New extension directives ought to consider defining:",
      "ja": "新しい拡張ディレクティブは定義することを検討するべきです："
    },
    {
      "indent": 3,
      "text": "o What it means for a directive to be specified multiple times,",
      "ja": "それが複数回指定するディレクティブするための手段は何O、"
    },
    {
      "indent": 3,
      "text": "o When the directive does not take an argument, what it means when an argument is present,",
      "ja": "Oときディレクティブは引数が存在する場合、それは何を意味するのか、引数を取りません、"
    },
    {
      "indent": 3,
      "text": "o When the directive requires an argument, what it means when it is missing,",
      "ja": "Oときディレクティブはそれが欠けているとき、それが何を意味するか、引数を必要とし、"
    },
    {
      "indent": 3,
      "text": "o Whether the directive is specific to requests, responses, or able to be used in either.",
      "ja": "ディレクティブは、要求、応答、またはいずれかで使用することができ特有であるかどうかは、O。"
    },
    {
      "indent": 3,
      "text": "See also Section 5.2.3.",
      "ja": "また、5.2.3項を参照してください。"
    },
    {
      "indent": 0,
      "text": "7.1.3. Registrations",
      "section_title": true,
      "ja": "7.1.3. 登録"
    },
    {
      "indent": 3,
      "text": "The registry has been populated with the registrations below:",
      "ja": "レジストリは、下記の登録が移入されています。"
    },
    {
      "indent": 3,
      "text": "+------------------------+----------------------------------+\n| Cache Directive        | Reference                        |\n+------------------------+----------------------------------+\n| max-age                | Section 5.2.1.1, Section 5.2.2.8 |\n| max-stale              | Section 5.2.1.2                  |\n| min-fresh              | Section 5.2.1.3                  |\n| must-revalidate        | Section 5.2.2.1                  |\n| no-cache               | Section 5.2.1.4, Section 5.2.2.2 |\n| no-store               | Section 5.2.1.5, Section 5.2.2.3 |\n| no-transform           | Section 5.2.1.6, Section 5.2.2.4 |\n| only-if-cached         | Section 5.2.1.7                  |\n| private                | Section 5.2.2.6                  |\n| proxy-revalidate       | Section 5.2.2.7                  |\n| public                 | Section 5.2.2.5                  |\n| s-maxage               | Section 5.2.2.9                  |\n| stale-if-error         | [RFC5861], Section 4             |\n| stale-while-revalidate | [RFC5861], Section 3             |\n+------------------------+----------------------------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.2. Warn Code Registry",
      "section_title": true,
      "ja": "7.2. コードレジストリに警告"
    },
    {
      "indent": 3,
      "text": "The \"Hypertext Transfer Protocol (HTTP) Warn Codes\" registry defines the namespace for warn codes. It has been created and is now maintained at <http://www.iana.org/assignments/http-warn-codes>.",
      "ja": "レジストリは、コードを警告するための名前空間を定義し、「ハイパーテキスト転送プロトコル（HTTP）コードを警告します」。これは、作成されており、現在、<http://www.iana.org/assignments/http-warn-codes>に維持されています。"
    },
    {
      "indent": 0,
      "text": "7.2.1. Procedure",
      "section_title": true,
      "ja": "7.2.1. 手順"
    },
    {
      "indent": 3,
      "text": "A registration MUST include the following fields:",
      "ja": "登録は、次のフィールドを含める必要があります。"
    },
    {
      "indent": 3,
      "text": "o Warn Code (3 digits)",
      "ja": "Oコード（3桁）警告"
    },
    {
      "indent": 3,
      "text": "o Short Description",
      "ja": "O簡単な説明"
    },
    {
      "indent": 3,
      "text": "o Pointer to specification text",
      "ja": "Oポインターは、テキストを仕様に"
    },
    {
      "indent": 3,
      "text": "Values to be added to this namespace require IETF Review (see [RFC5226], Section 4.1).",
      "ja": "この名前空間に追加される値は、IETFレビュー（参照[RFC5226]、セクション4.1）が必要です。"
    },
    {
      "indent": 0,
      "text": "7.2.2. Registrations",
      "section_title": true,
      "ja": "7.2.2. 登録"
    },
    {
      "indent": 3,
      "text": "The registry has been populated with the registrations below:",
      "ja": "レジストリは、下記の登録が移入されています。"
    },
    {
      "indent": 3,
      "text": "+-----------+----------------------------------+---------------+\n| Warn Code | Short Description                | Reference     |\n+-----------+----------------------------------+---------------+\n| 110       | Response is Stale                | Section 5.5.1 |\n| 111       | Revalidation Failed              | Section 5.5.2 |\n| 112       | Disconnected Operation           | Section 5.5.3 |\n| 113       | Heuristic Expiration             | Section 5.5.4 |\n| 199       | Miscellaneous Warning            | Section 5.5.5 |\n| 214       | Transformation Applied           | Section 5.5.6 |\n| 299       | Miscellaneous Persistent Warning | Section 5.5.7 |\n+-----------+----------------------------------+---------------+",
      "raw": true
    },
    {
      "indent": 0,
      "text": "7.3. Header Field Registration",
      "section_title": true,
      "ja": "7.3. ヘッダーフィールドの登録"
    },
    {
      "indent": 3,
      "text": "HTTP header fields are registered within the \"Message Headers\" registry maintained at <http://www.iana.org/assignments/message-headers/>.",
      "ja": "HTTPヘッダフィールドは、<http://www.iana.org/assignments/message-headers/>に維持「メッセージヘッダ」レジストリ内に登録されています。"
    },
    {
      "indent": 3,
      "text": "This document defines the following HTTP header fields, so the \"Permanent Message Header Field Names\" registry has been updated accordingly (see [BCP90]).",
      "ja": "この文書は、次のHTTPヘッダーフィールドを定義するので、「永続的メッセージヘッダーフィールド名」レジストリ（[BCP90]参照）に応じて更新されました。"
    },
    {
      "indent": 3,
      "text": "+-------------------+----------+----------+-------------+\n| Header Field Name | Protocol | Status   | Reference   |\n+-------------------+----------+----------+-------------+\n| Age               | http     | standard | Section 5.1 |\n| Cache-Control     | http     | standard | Section 5.2 |\n| Expires           | http     | standard | Section 5.3 |\n| Pragma            | http     | standard | Section 5.4 |\n| Warning           | http     | standard | Section 5.5 |\n+-------------------+----------+----------+-------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The change controller is: \"IETF (iesg@ietf.org) - Internet Engineering Task Force\".",
      "ja": "変更コントローラは次のとおりです。「IETF（iesg@ietf.org） - インターネットエンジニアリングタスクフォース」。"
    },
    {
      "indent": 0,
      "text": "8. Security Considerations",
      "section_title": true,
      "ja": "8.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "This section is meant to inform developers, information providers, and users of known security concerns specific to HTTP caching. More general security considerations are addressed in HTTP messaging [RFC7230] and semantics [RFC7231].",
      "ja": "このセクションでは、開発者、情報提供者、およびHTTPキャッシングに固有の既知のセキュリティ上の懸念のユーザーに通知するものとします。もっと一般的なセキュリティ上の考慮事項は、HTTPメッセージ[RFC7230]と意味論[RFC7231]で扱われています。"
    },
    {
      "indent": 3,
      "text": "Caches expose additional potential vulnerabilities, since the contents of the cache represent an attractive target for malicious exploitation. Because cache contents persist after an HTTP request is complete, an attack on the cache can reveal information long after a user believes that the information has been removed from the network. Therefore, cache contents need to be protected as sensitive information.",
      "ja": "キャッシュの内容が悪質な搾取のための魅力的なターゲットを表しているのでキャッシュは、追加の潜在的な脆弱性を公開します。 HTTPリクエストが完了した後でキャッシュの内容が持続するので、キャッシュへの攻撃は、ユーザーが情報をネットワークから削除されたことを信じてずっと後に情報を明らかにすることができます。そのため、キャッシュの内容は、機密情報として保護する必要があります。"
    },
    {
      "indent": 3,
      "text": "In particular, various attacks might be amplified by being stored in a shared cache; such \"cache poisoning\" attacks use the cache to distribute a malicious payload to many clients, and are especially effective when an attacker can use implementation flaws, elevated privileges, or other techniques to insert such a response into a cache. One common attack vector for cache poisoning is to exploit differences in message parsing on proxies and in user agents; see Section 3.3.3 of [RFC7230] for the relevant requirements.",
      "ja": "特に、様々な攻撃は、共有キャッシュに格納されることによって増幅されるかもしれません。こうした「キャッシュポイズニング」攻撃は、多くのクライアントに悪意のあるペイロードを配布するためにキャッシュを使用し、攻撃者がキャッシュにこのような応答を挿入するために、実装上の欠陥、昇格した権限、または他の技術を使用することができたときに特に有効です。キャッシュポイズニングのための1つの一般的な攻撃ベクトルは、プロキシ上で、ユーザーエージェントにメッセージ解析の違いを利用することです。関連する要件については、[RFC7230]のセクション3.3.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "Likewise, implementation flaws (as well as misunderstanding of cache operation) might lead to caching of sensitive information (e.g., authentication credentials) that is thought to be private, exposing it to unauthorized parties.",
      "ja": "同様に、実装上の欠陥（だけでなく、キャッシュ操作の誤解）が権限のない者にそれを暴露する、プライベートであると考えられている機密情報（例えば、認証証明書）をキャッシュにつながる可能性があります。"
    },
    {
      "indent": 3,
      "text": "Furthermore, the very use of a cache can bring about privacy concerns. For example, if two users share a cache, and the first one browses to a site, the second may be able to detect that the other has been to that site, because the resources from it load more quickly, thanks to the cache.",
      "ja": "さらに、キャッシュの非常に使用することは、プライバシーの問題をもたらすことができます。 2人のユーザーがキャッシュを共有し、そして最初のものはサイトに閲覧した場合、それからの資源は、より迅速にキャッシュへの感謝をロードするので、例えば、第二は、他のは、そのサイトに行ったことを検出することができます。"
    },
    {
      "indent": 3,
      "text": "Note that the Set-Cookie response header field [RFC6265] does not inhibit caching; a cacheable response with a Set-Cookie header field can be (and often is) used to satisfy subsequent requests to caches. Servers who wish to control caching of these responses are encouraged to emit appropriate Cache-Control response header fields.",
      "ja": "Set-Cookieレスポンス・ヘッダー・フィールド[RFC6265]キャッシングを阻害しないことに留意されたいです。 Set-Cookieヘッダーフィールドを持つキャッシュ可能な応答があること（しばしばある）キャッシュへの後続の要求を満たすために使用することができます。これらの応答のキャッシュを制御したいサーバーが適切なのCache-Controlレスポンスヘッダフィールドを放出することをお勧めします。"
    },
    {
      "indent": 0,
      "text": "9. Acknowledgments",
      "section_title": true,
      "ja": "9.謝辞"
    },
    {
      "indent": 3,
      "text": "See Section 10 of [RFC7230].",
      "ja": "[RFC7230]のセクション10を参照してください。"
    },
    {
      "indent": 0,
      "text": "10. References",
      "section_title": true,
      "ja": "10.参考文献"
    },
    {
      "indent": 0,
      "text": "10.1. Normative References",
      "section_title": true,
      "ja": "10.1. 引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC5234] Crocker, D., Ed. and P. Overell, \"Augmented BNF for Syntax Specifications: ABNF\", STD 68, RFC 5234, January 2008.",
      "ja": "[RFC5234]クロッカー、D.、エド。そして、P. Overell、 \"構文仕様のための増大しているBNF：ABNF\"、STD 68、RFC 5234、2008年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC7230] Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing\", RFC 7230, June 2014.",
      "ja": "[RFC7230]フィールディング、R.、エド。 。とJ. Reschke、エド、 \"ハイパーテキスト転送プロトコル（HTTP / 1.1）：メッセージの構文とルーティング\"、RFC 7230、2014年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC7231] Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content\", RFC 7231, June 2014.",
      "ja": "[RFC7231]フィールディング、R.、エド。そして、J. Reschke、エド、 \"ハイパーテキスト転送プロトコル（HTTP / 1.1）：セマンティクスおよびコンテンツ\"、RFC 7231、2014年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC7232] Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests\", RFC 7232, June 2014.",
      "ja": "[RFC7232]フィールディング、R.、エド。 。とJ. Reschke、エド、 \"ハイパーテキスト転送プロトコル（HTTP / 1.1）：条件付きリクエスト\"、RFC 7232、2014年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC7233] Fielding, R., Ed., Lafon, Y., Ed., and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Range Requests\", RFC 7233, June 2014.",
      "ja": "[RFC7233]フィールディング、R.、エド、ラフォン、Y.、エド、及びJ. Reschke、編、 \"ハイパーテキスト転送プロトコル（HTTP / 1.1）：範囲要求\"。。。、RFC 7233、2014年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC7235] Fielding, R., Ed. and J. Reschke, Ed., \"Hypertext Transfer Protocol (HTTP/1.1): Authentication\", RFC 7235, June 2014.",
      "ja": "[RFC7235]フィールディング、R.、エド。そして、J. Reschke、エド、 \"ハイパーテキスト転送プロトコル（HTTP / 1.1）：認証\"、RFC 7235、2014年6月。"
    },
    {
      "indent": 0,
      "text": "10.2. Informative References",
      "section_title": true,
      "ja": "10.2. 参考文献"
    },
    {
      "indent": 3,
      "text": "[BCP90] Klyne, G., Nottingham, M., and J. Mogul, \"Registration Procedures for Message Header Fields\", BCP 90, RFC 3864, September 2004.",
      "ja": "[BCP90] Klyne、G.、ノッティンガム、M.、およびJ.モーグル、 \"メッセージヘッダフィールドの登録手順\"、BCP 90、RFC 3864、2004年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC2616] Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P., and T. Berners-Lee, \"Hypertext Transfer Protocol -- HTTP/1.1\", RFC 2616, June 1999.",
      "ja": "[RFC2616]フィールディング、R.、ゲティス、J.、モーグル、J.、Frystyk、H.、Masinter、L.、リーチ、P.、およびT.バーナーズ - リー、 \"ハイパーテキスト転送プロトコル -  HTTP / 1.1\" 、RFC 2616、1999年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC5226] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 5226, May 2008.",
      "ja": "[RFC5226] Narten氏、T.とH. Alvestrand、 \"RFCsにIANA問題部に書くためのガイドライン\"、BCP 26、RFC 5226、2008年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC5861] Nottingham, M., \"HTTP Cache-Control Extensions for Stale Content\", RFC 5861, April 2010.",
      "ja": "[RFC5861]ノッティンガム、M.、 \"古いコンテンツのためのHTTPのCache-Controlの拡張機能\"、RFC 5861、2010年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC5905] Mills, D., Martin, J., Ed., Burbank, J., and W. Kasch, \"Network Time Protocol Version 4: Protocol and Algorithms Specification\", RFC 5905, June 2010.",
      "ja": "[RFC5905]ミルズ、D.、マーティン、J.、エド、バーバンク、J.、およびW. Kasch、 \"ネットワークタイムプロトコルバージョン4：プロトコルとアルゴリズムの仕様\"、RFC 5905、2010年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC6265] Barth, A., \"HTTP State Management Mechanism\", RFC 6265, April 2011.",
      "ja": "[RFC6265]バース、A.、 \"HTTP状態管理機構\"、RFC 6265、2011年4月。"
    },
    {
      "indent": 1,
      "text": "Appendix A. Changes from",
      "ja": "付録A.からの変更点"
    },
    {
      "indent": 3,
      "text": "The specification has been substantially rewritten for clarity.",
      "ja": "仕様は、実質的に分かりやすくするために書き直されました。"
    },
    {
      "indent": 3,
      "text": "The conditions under which an authenticated response can be cached have been clarified. (Section 3.2)",
      "ja": "認証された応答をキャッシュできる条件は明らかにされています。 （3.2節）"
    },
    {
      "indent": 3,
      "text": "New status codes can now define that caches are allowed to use heuristic freshness with them. Caches are now allowed to calculate heuristic freshness for URIs with query components. (Section 4.2.2)",
      "ja": "新しいステータスコードは現在、キャッシュが彼らとヒューリスティック鮮度を使用することを許可されていることを定義することができます。キャッシュは現在、クエリコンポーネントを持つURIのヒューリスティック新鮮さを計算するのに許可されています。 （4.2.2）"
    },
    {
      "indent": 3,
      "text": "The algorithm for calculating age is now less conservative. Caches are now required to handle dates with time zones as if they're invalid, because it's not possible to accurately guess. (Section 4.2.3)",
      "ja": "年齢を計算するためのアルゴリズムは今あまり保守的です。彼らは無効だかのように正確に推測することはできませんので、キャッシュは今、タイムゾーンと日付を処理するために必要とされています。 （4.2.3）"
    },
    {
      "indent": 3,
      "text": "The Content-Location response header field is no longer used to determine the appropriate response to use when validating. (Section 4.3)",
      "ja": "コンテンツロケーションレスポンスヘッダフィールドは、もはや検証するときに使用する適切な応答を決定するために使用されません。 （4.3節）"
    },
    {
      "indent": 3,
      "text": "The algorithm for selecting a cached negotiated response to use has been clarified in several ways. In particular, it now explicitly allows header-specific canonicalization when processing selecting header fields. (Section 4.1)",
      "ja": "使用にキャッシュされ、ネゴシエート応答を選択するためのアルゴリズムは、いくつかの方法で明らかにされています。選択ヘッダフィールドを処理するとき、特に、それが明示的ヘッダ固有の正規化を可能にします。 （4.1節）"
    },
    {
      "indent": 3,
      "text": "Requirements regarding denial-of-service attack avoidance when performing invalidation have been clarified. (Section 4.4)",
      "ja": "無効化を実行する際に、サービス拒否攻撃の回避に関する要件が明らかにされています。 （4.4節）"
    },
    {
      "indent": 3,
      "text": "Cache invalidation only occurs when a successful response is received. (Section 4.4)",
      "ja": "正常な応答を受信したときにキャッシュの無効化にのみ発生します。 （4.4節）"
    },
    {
      "indent": 3,
      "text": "Cache directives are explicitly defined to be case-insensitive. Handling of multiple instances of cache directives when only one is expected is now defined. (Section 5.2)",
      "ja": "キャッシュディレクティブは、明示的に大文字と小文字を区別しないように定義されています。キャッシュディレクティブの複数のインスタンスの扱いだけが定義されましたが予想されるとき。 （5.2節）"
    },
    {
      "indent": 3,
      "text": "The \"no-store\" request directive doesn't apply to responses; i.e., a cache can satisfy a request with no-store on it and does not invalidate it. (Section 5.2.1.5)",
      "ja": "「無店舗」要求ディレクティブは、応答には適用されません。すなわち、キャッシュはその上に無店舗との要求を満たすことができますし、それが無効になることはありません。 （セクション5.2.1.5）"
    },
    {
      "indent": 3,
      "text": "The qualified forms of the private and no-cache cache directives are noted to not be widely implemented; for example, \"private=foo\" is interpreted by many caches as simply \"private\". Additionally, the meaning of the qualified form of no-cache has been clarified. (Section 5.2.2)",
      "ja": "民間の資格フォームやキャッシュディレクティブが広く実装されないように注意しているキャッシュなし。例えば、「プライベート= fooが」単に「プライベート」として多くのキャッシュによって解釈されます。また、キャッシュなしの修飾形式の意味が明らかにされています。 （5.2.2項）"
    },
    {
      "indent": 3,
      "text": "The \"no-cache\" response directive's meaning has been clarified. (Section 5.2.2.2)",
      "ja": "「キャッシュなし」応答ディレクティブの意味が明らかにされています。 （5.2.2.2項）"
    },
    {
      "indent": 3,
      "text": "The one-year limit on Expires header field values has been removed; instead, the reasoning for using a sensible value is given. (Section 5.3)",
      "ja": "ヘッダフィールド値を有効期限に一年間の制限は除去されています。代わりに、実用的な値を使用するための理由が与えられます。 （5.3節）"
    },
    {
      "indent": 3,
      "text": "The Pragma header field is now only defined for backwards compatibility; future pragmas are deprecated. (Section 5.4)",
      "ja": "Pragmaヘッダーフィールドは、現在だけ後方互換性のために定義されています。将来のプラグマは推奨されません。 （5.4節）"
    },
    {
      "indent": 3,
      "text": "Some requirements regarding production and processing of the Warning header fields have been relaxed, as it is not widely implemented. Furthermore, the Warning header field no longer uses RFC 2047 encoding, nor does it allow multiple languages, as these aspects were not implemented. (Section 5.5)",
      "ja": "それは広く実装されていないよう警告ヘッダフィールドの生産と加工に関するいくつかの要件が緩和されています。また、警告ヘッダーフィールドは、もはやRFC 2047符号化を使用しない、また、これらの態様が実施されなかったとして、それは、複数の言語を許可ありません。 （5.5節）"
    },
    {
      "indent": 3,
      "text": "This specification introduces the Cache Directive and Warn Code Registries, and defines considerations for new cache directives. (Section 7.1 and Section 7.2)",
      "ja": "この仕様は、キャッシュ指令を紹介し、コードのレジストリを警告して、新しいキャッシュ・ディレクティブのための考慮事項を定義します。 （第7.1節および第7.2節）"
    },
    {
      "indent": 0,
      "text": "Appendix B. Imported ABNF",
      "ja": "付録B.インポートABNF"
    },
    {
      "indent": 3,
      "text": "The following core rules are included by reference, as defined in Appendix B.1 of [RFC5234]: ALPHA (letters), CR (carriage return), CRLF (CR LF), CTL (controls), DIGIT (decimal 0-9), DQUOTE (double quote), HEXDIG (hexadecimal 0-9/A-F/a-f), LF (line feed), OCTET (any 8-bit sequence of data), SP (space), and VCHAR (any visible US-ASCII character).",
      "ja": "[RFC5234]の付録B.1で定義されるように以下のコアルールは、参照することにより含まれる：ALPHA（文字）、CR（キャリッジリターン）、CRLF（CR LF）、CTL（コントロール）、数字（小数0-9） 、DQUOTE（二重引用符）、HEXDIG（16進数0-9 / AF / AF）、LF（ラインフィード）、OCTET（データの8ビットシーケンス）、SP（空間）、及びVCHAR（目に見えるUS-ASCII文字）。"
    },
    {
      "indent": 3,
      "text": "The rules below are defined in [RFC7230]:",
      "ja": "以下[RFC7230]で定義されたルール。"
    },
    {
      "indent": 5,
      "text": "OWS = <OWS, see [RFC7230], Section 3.2.3> field-name = <field-name, see [RFC7230], Section 3.2> quoted-string = <quoted-string, see [RFC7230], Section 3.2.6> token = <token, see [RFC7230], Section 3.2.6>",
      "ja": "OWS = [RFC7230]を参照してください、引用符で囲んだ文字列= <引用符で囲まれた文字列<セクション3.2、[RFC7230]を参照して、フィールド名>フィールド名= <OWSは、セクション3.2.3、[RFC7230]を参照>、3.2.6項>トークン= <トークン、[RFC7230]を参照して、セクション3.2.6>"
    },
    {
      "indent": 5,
      "text": "port = <port, see [RFC7230], Section 2.7> pseudonym = <pseudonym, see [RFC7230], Section 5.7.1> uri-host = <uri-host, see [RFC7230], Section 2.7>",
      "ja": "ポート= <ポート、[RFC7230]を参照して、セクション2.7>仮名= <仮名、[RFC7230]を参照して、セクション5.7.1> URIホスト= <URIホスト、[RFC7230]を参照して、セクション2.7>"
    },
    {
      "indent": 3,
      "text": "The rules below are defined in other parts:",
      "ja": "以下の規則は、他の部分で定義されています。"
    },
    {
      "indent": 5,
      "text": "HTTP-date = <HTTP-date, see [RFC7231], Section 7.1.1.1>",
      "ja": "HTTP-日付= <HTTP-日付、[RFC7231]、セクション7.1.1.1を参照してください>"
    },
    {
      "indent": 0,
      "text": "Appendix C. Collected ABNF",
      "ja": "付録C.はABNFを収集しました"
    },
    {
      "indent": 3,
      "text": "In the collected ABNF below, list rules are expanded as per Section 1.2 of [RFC7230].",
      "ja": "以下収集ABNFにおいて、リストルールは、[RFC7230]のセクション1.2に従って展開されます。"
    },
    {
      "indent": 3,
      "text": "Age = delta-seconds",
      "ja": "年齢=デルタ - 秒"
    },
    {
      "indent": 3,
      "text": "Cache-Control = *( \",\" OWS ) cache-directive *( OWS \",\" [ OWS cache-directive ] )",
      "ja": "Cache-Control = *（ \"\" OWS）キャッシュ・ディレクティブ*（OWS \"\" [OWSキャッシュディレクティブ]）"
    },
    {
      "indent": 3,
      "text": "Expires = HTTP-date",
      "ja": "= HTTP-日付有効期限"
    },
    {
      "indent": 3,
      "text": "HTTP-date = <HTTP-date, see [RFC7231], Section 7.1.1.1>",
      "ja": "HTTP-日付= <HTTP-日付、[RFC7231]、セクション7.1.1.1を参照してください>"
    },
    {
      "indent": 3,
      "text": "OWS = <OWS, see [RFC7230], Section 3.2.3>",
      "ja": "OWS = <OWS、[RFC7230]を見てください、セクション3.2.3>"
    },
    {
      "indent": 3,
      "text": "Pragma = *( \",\" OWS ) pragma-directive *( OWS \",\" [ OWS pragma-directive ] )",
      "ja": "これは= *（ \"\" OOS） -  direktive *（OOS \"\" [OOS物-direktive]）"
    },
    {
      "indent": 3,
      "text": "Warning = *( \",\" OWS ) warning-value *( OWS \",\" [ OWS warning-value ] )",
      "ja": "警告= *（ \"\" OWS）警告値*（OWS \"\" [OWS警告値]）"
    },
    {
      "indent": 3,
      "text": "cache-directive = token [ \"=\" ( token / quoted-string ) ]",
      "ja": "キャッシュ・ディレクティブ=トークン[「=」（トークン/引用符で囲まれた文字列）]"
    },
    {
      "indent": 3,
      "text": "delta-seconds = 1*DIGIT",
      "ja": "デルタ秒= 1 * DIGIT"
    },
    {
      "indent": 3,
      "text": "extension-pragma = token [ \"=\" ( token / quoted-string ) ]",
      "ja": "エクステンション・プラグマ=トークン[「=」（トークン/引用符で囲まれた文字列）]"
    },
    {
      "indent": 3,
      "text": "field-name = <field-name, see [RFC7230], Section 3.2>",
      "ja": "フィールド名= <フィールド名、[RFC7230]を参照して、3.2節>"
    },
    {
      "indent": 3,
      "text": "port = <port, see [RFC7230], Section 2.7> pragma-directive = \"no-cache\" / extension-pragma pseudonym = <pseudonym, see [RFC7230], Section 5.7.1>",
      "ja": "ポート= <ポート、[RFC7230]を見てください、セクション2.7>プラグマディレクティブ= \"キャッシュなし\" /拡張プラグマ仮名= <仮名、[RFC7230]を見てください、セクション5.7.1>"
    },
    {
      "indent": 3,
      "text": "quoted-string = <quoted-string, see [RFC7230], Section 3.2.6>",
      "ja": "引用符で囲んだ文字列= <引用符で囲まれた文字列、[RFC7230]を見てください、セクション3.2.6>"
    },
    {
      "indent": 3,
      "text": "token = <token, see [RFC7230], Section 3.2.6>",
      "ja": "トークン= <トークン、[RFC7230]を見てください、セクション3.2.6>"
    },
    {
      "indent": 3,
      "text": "uri-host = <uri-host, see [RFC7230], Section 2.7>",
      "ja": "URI-ホスト= <URI-ホスト、[RFC7230]、セクション2.7を参照してください>"
    },
    {
      "indent": 3,
      "text": "warn-agent = ( uri-host [ \":\" port ] ) / pseudonym warn-code = 3DIGIT warn-date = DQUOTE HTTP-date DQUOTE warn-text = quoted-string warning-value = warn-code SP warn-agent SP warn-text [ SP warn-date ]",
      "ja": "警告エージェント=（URI-ホスト[ \"：\" ポート]）/仮名警告コード=警告-日3DIGIT = DQUOTE HTTP-日付DQUOTE警告テキスト=引用符で囲まれた文字列の警告値=警告コードSP警告エージェントSP警告テキスト[SP警告-日]"
    },
    {
      "indent": 0,
      "text": "Index",
      "ja": "指数"
    },
    {
      "indent": 3,
      "text": "1 110 (warn-code) 31 111 (warn-code) 31 112 (warn-code) 31 113 (warn-code) 31 199 (warn-code) 32",
      "ja": "1 110（警告コード）31 111（警告コード）31 112（警告コード）31 113（警告コード）31 199（警告コード）32"
    },
    {
      "indent": 3,
      "text": "2 214 (warn-code) 32 299 (warn-code) 32",
      "ja": "2 214（警告コード）32 299（警告コード）32"
    },
    {
      "indent": 3,
      "text": "A age 11 Age header field 21",
      "ja": "11歳の年齢のヘッダフィールド21"
    },
    {
      "indent": 3,
      "text": "C cache 4 cache entry 5 cache key 5-6 Cache-Control header field 21",
      "ja": "Cキャッシュ4キャッシュエントリ5キャッシュ鍵5-6のCache-Controlヘッダーフィールド21"
    },
    {
      "indent": 3,
      "text": "D Disconnected Operation (warn-text) 31",
      "ja": "D切断動作（警告テキスト）31"
    },
    {
      "indent": 3,
      "text": "E Expires header field 28 explicit expiration time 11",
      "ja": "Eは、ヘッダフィールド28の明示的な有効期限11を期限切れ"
    },
    {
      "indent": 3,
      "text": "F fresh 11 freshness lifetime 11",
      "ja": "F新鮮な11の新鮮寿命11"
    },
    {
      "indent": 3,
      "text": "G Grammar Age 21 Cache-Control 22 cache-directive 22 delta-seconds 5 Expires 28 extension-pragma 29 Pragma 29 pragma-directive 29 warn-agent 29 warn-code 29 warn-date 29 warn-text 29",
      "ja": "G文法年齢21のCache-Control 22キャッシュ・ディレクティブ22デルタ秒5は、警告・エージェント29に警告コード29を警告-日付29を警告・テキスト29の28の拡張、プラグマ29プラグマ29プラグマディレクティブ29の有効期限"
    },
    {
      "indent": 9,
      "text": "Warning  29\nwarning-value  29",
      "raw": true
    },
    {
      "indent": 3,
      "text": "H Heuristic Expiration (warn-text) 31 heuristic expiration time 11 M max-age (cache directive) 22, 26 max-stale (cache directive) 22 min-fresh (cache directive) 22 Miscellaneous Persistent Warning (warn-text) 32 Miscellaneous Warning (warn-text) 32 must-revalidate (cache directive) 24",
      "ja": "Hヒューリスティックの有効期限（警告テキスト）11 M MAX-年齢（キャッシュディレクティブ）22、26 MAX-失効（キャッシュディレクティブ）22分間、新鮮な（キャッシュディレクティブ）22その他の永続的警告（警告テキスト）32その他31ヒューリスティック有効期限警告（警告テキスト）32必携再検証（キャッシュディレクティブ）24"
    },
    {
      "indent": 3,
      "text": "N no-cache (cache directive) 23, 25 no-store (cache directive) 23, 24 no-transform (cache directive) 23, 25",
      "ja": "Nキャッシュなし（キャッシュディレクティブ）23、25無店舗（キャッシュディレクティブ）23、24無変換（キャッシュディレクティブ）23、25"
    },
    {
      "indent": 3,
      "text": "O only-if-cached (cache directive) 23",
      "ja": "Oのみ-IF-キャッシュされた（キャッシュディレクティブ）23"
    },
    {
      "indent": 3,
      "text": "P Pragma header field 29 private (cache directive) 25 private cache 4 proxy-revalidate (cache directive) 26 public (cache directive) 25",
      "ja": "Pプラグマヘッダフィールド29プライベート（キャッシュディレクティブ）25プライベートキャッシュ4プロキシ再検証（キャッシュディレクティブ）26公衆（キャッシュディレクティブ）25"
    },
    {
      "indent": 3,
      "text": "R Response is Stale (warn-text) 30 Revalidation Failed (warn-text) 31",
      "ja": "R応答（警告テキスト）30再検証は（警告テキスト）を31失敗失効しています"
    },
    {
      "indent": 3,
      "text": "S s-maxage (cache directive) 27 shared cache 4 stale 11 strong validator 18",
      "ja": "S、S-MAXAGE（キャッシュディレクティブ）27共有キャッシュ4陳腐11強いバリ18"
    },
    {
      "indent": 3,
      "text": "T Transformation Applied (warn-text) 32",
      "ja": "T変換応用（警告テキスト）32"
    },
    {
      "indent": 3,
      "text": "V validator 16",
      "ja": "バリ16"
    },
    {
      "indent": 3,
      "text": "W Warning header field 29",
      "ja": "W警告ヘッダーフィールド29"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Roy T. Fielding (editor) Adobe Systems Incorporated 345 Park Ave San Jose, CA 95110 USA",
      "ja": "ロイT.フィールディング（編集者）Adobe Systems Incorporated（アドビシステムズ社）345パークアベニューサンノゼ、CA 95110 USA"
    },
    {
      "indent": 3,
      "text": "EMail: fielding@gbiv.com URI: http://roy.gbiv.com/",
      "ja": "電子メール：fielding@gbiv.com URI：http://roy.gbiv.com/"
    },
    {
      "indent": 3,
      "text": "Mark Nottingham (editor) Akamai",
      "ja": "マーク・ノッティンガム（編集者）アカマイ"
    },
    {
      "indent": 3,
      "text": "EMail: mnot@mnot.net URI: http://www.mnot.net/",
      "ja": "電子メール：mnot@mnot.net URI：http://www.mnot.net/"
    },
    {
      "indent": 3,
      "text": "Julian F. Reschke (editor) greenbytes GmbH Hafenweg 16 Muenster, NW 48155 Germany",
      "ja": "ジュリアンF. Reschke（エディタ）greenbytes社Hafenweg 16ミュンスター、NW 48155ドイツ"
    },
    {
      "indent": 3,
      "text": "EMail: julian.reschke@greenbytes.de URI: http://greenbytes.de/tech/webdav/",
      "ja": "電子メール：julian.reschke@greenbytes.de URI：http://greenbytes.de/tech/webdav/"
    }
  ]
}