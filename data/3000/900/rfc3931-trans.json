{
  "title": {
    "text": "RFC 3931 - Layer Two Tunneling Protocol - Version 3 (L2TPv3)",
    "ja": "RFC 3931 - レイヤ2トンネリングプロトコル - バージョン3（L2TPv3の）"
  },
  "number": 3931,
  "created_at": "2019-10-25 10:25:04.358974+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                        J. Lau, Ed.\nRequest for Comments: 3931                              M. Townsley, Ed.\nCategory: Standards Track                                  Cisco Systems\n                                                          I. Goyret, Ed.\n                                                     Lucent Technologies\n                                                              March 2005",
      "raw": true
    },
    {
      "indent": 11,
      "text": "Layer Two Tunneling Protocol - Version 3 (L2TPv3)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "ja": "このメモの位置付け"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "ja": "この文書は、インターネットコミュニティのためのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態と状態への「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2005).",
      "ja": "著作権（C）インターネット協会（2005）。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document describes \"version 3\" of the Layer Two Tunneling Protocol (L2TPv3). L2TPv3 defines the base control protocol and encapsulation for tunneling multiple Layer 2 connections between two IP nodes. Additional documents detail the specifics for each data link type being emulated.",
      "ja": "この文書では、レイヤ2トンネリングプロトコル（L2TPv3の）の「バージョン3」を説明しています。 L2TPv3のは、2つのIPノード間で複数のレイヤ2接続をトンネリングするための基本制御プロトコルおよびカプセル化を定義します。追加の書類の詳細は、各データリンクタイプの詳細は、エミュレートされています。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  3\n    1.1.  Changes from RFC 2661. . . . . . . . . . . . . . . . . .  4\n    1.2.  Specification of Requirements. . . . . . . . . . . . . .  4\n    1.3.  Terminology. . . . . . . . . . . . . . . . . . . . . . .  5\n2.  Topology . . . . . . . . . . . . . . . . . . . . . . . . . . .  8\n3.  Protocol Overview. . . . . . . . . . . . . . . . . . . . . . .  9\n    3.1.  Control Message Types. . . . . . . . . . . . . . . . . . 10\n    3.2.  L2TP Header Formats. . . . . . . . . . . . . . . . . . . 11\n          3.2.1.  L2TP Control Message Header. . . . . . . . . . . 11\n          3.2.2.  L2TP Data Message. . . . . . . . . . . . . . . . 12\n    3.3.  Control Connection Management. . . . . . . . . . . . . . 13\n          3.3.1.  Control Connection Establishment . . . . . . . . 14\n          3.3.2.  Control Connection Teardown. . . . . . . . . . . 14\n    3.4.  Session Management . . . . . . . . . . . . . . . . . . . 15\n          3.4.1.  Session Establishment for an Incoming Call . . . 15\n          3.4.2.  Session Establishment for an Outgoing Call . . . 15",
      "raw": true
    },
    {
      "indent": 3,
      "text": "          3.4.3.  Session Teardown . . . . . . . . . . . . . . . . 16\n4.  Protocol Operation . . . . . . . . . . . . . . . . . . . . . . 16\n    4.1.  L2TP Over Specific Packet-Switched Networks (PSNs) . . . 16\n          4.1.1.  L2TPv3 over IP . . . . . . . . . . . . . . . . . 17\n          4.1.2.  L2TP over UDP. . . . . . . . . . . . . . . . . . 18\n          4.1.3.  L2TP and IPsec . . . . . . . . . . . . . . . . . 20\n          4.1.4.  IP Fragmentation Issues. . . . . . . . . . . . . 21\n    4.2.  Reliable Delivery of Control Messages. . . . . . . . . . 23\n    4.3.  Control Message Authentication . . . . . . . . . . . . . 25\n    4.4.  Keepalive (Hello). . . . . . . . . . . . . . . . . . . . 26\n    4.5.  Forwarding Session Data Frames . . . . . . . . . . . . . 26\n    4.6.  Default L2-Specific Sublayer . . . . . . . . . . . . . . 27\n          4.6.1.  Sequencing Data Packets. . . . . . . . . . . . . 28\n    4.7.  L2TPv2/v3 Interoperability and Migration . . . . . . . . 28\n          4.7.1.  L2TPv3 over IP . . . . . . . . . . . . . . . . . 29\n          4.7.2.  L2TPv3 over UDP. . . . . . . . . . . . . . . . . 29\n          4.7.3.  Automatic L2TPv2 Fallback. . . . . . . . . . . . 29\n5.  Control Message Attribute Value Pairs. . . . . . . . . . . . . 30\n    5.1.  AVP Format . . . . . . . . . . . . . . . . . . . . . . . 30\n    5.2.  Mandatory AVPs and Setting the M Bit . . . . . . . . . . 32\n    5.3.  Hiding of AVP Attribute Values . . . . . . . . . . . . . 33\n    5.4.  AVP Summary. . . . . . . . . . . . . . . . . . . . . . . 36\n          5.4.1.  General Control Message AVPs . . . . . . . . . . 36\n          5.4.2.  Result and Error Codes . . . . . . . . . . . . . 40\n          5.4.3.  Control Connection Management AVPs . . . . . . . 43\n          5.4.4.  Session Management AVPs. . . . . . . . . . . . . 48\n          5.4.5.  Circuit Status AVPs. . . . . . . . . . . . . . . 57\n6.  Control Connection Protocol Specification. . . . . . . . . . . 59\n    6.1.  Start-Control-Connection-Request (SCCRQ) . . . . . . . . 60\n    6.2.  Start-Control-Connection-Reply (SCCRP) . . . . . . . . . 60\n    6.3.  Start-Control-Connection-Connected (SCCCN) . . . . . . . 61\n    6.4.  Stop-Control-Connection-Notification (StopCCN) . . . . . 61\n    6.5.  Hello (HELLO). . . . . . . . . . . . . . . . . . . . . . 61\n    6.6.  Incoming-Call-Request (ICRQ) . . . . . . . . . . . . . . 62\n    6.7.  Incoming-Call-Reply (ICRP) . . . . . . . . . . . . . . . 63\n    6.8.  Incoming-Call-Connected (ICCN) . . . . . . . . . . . . . 63\n    6.9.  Outgoing-Call-Request (OCRQ) . . . . . . . . . . . . . . 64\n    6.10. Outgoing-Call-Reply (OCRP) . . . . . . . . . . . . . . . 65\n    6.11. Outgoing-Call-Connected (OCCN) . . . . . . . . . . . . . 65\n    6.12. Call-Disconnect-Notify (CDN) . . . . . . . . . . . . . . 66\n    6.13. WAN-Error-Notify (WEN) . . . . . . . . . . . . . . . . . 66\n    6.14. Set-Link-Info (SLI). . . . . . . . . . . . . . . . . . . 67\n    6.15. Explicit-Acknowledgement (ACK) . . . . . . . . . . . . . 67\n7.  Control Connection State Machines. . . . . . . . . . . . . . . 68\n    7.1.  Malformed AVPs and Control Messages. . . . . . . . . . . 68\n    7.2.  Control Connection States. . . . . . . . . . . . . . . . 69\n    7.3.  Incoming Calls . . . . . . . . . . . . . . . . . . . . . 71\n          7.3.1.  ICRQ Sender States . . . . . . . . . . . . . . . 72",
      "raw": true
    },
    {
      "indent": 3,
      "text": "          7.3.2.  ICRQ Recipient States. . . . . . . . . . . . . . 73\n    7.4.  Outgoing Calls . . . . . . . . . . . . . . . . . . . . . 74\n          7.4.1.  OCRQ Sender States . . . . . . . . . . . . . . . 75\n          7.4.2.  OCRQ Recipient (LAC) States. . . . . . . . . . . 76\n    7.5.  Termination of a Control Connection. . . . . . . . . . . 77\n8.  Security Considerations. . . . . . . . . . . . . . . . . . . . 78\n    8.1.  Control Connection Endpoint and Message Security . . . . 78\n    8.2.  Data Packet Spoofing . . . . . . . . . . . . . . . . . . 78\n9.  Internationalization Considerations. . . . . . . . . . . . . . 79\n10. IANA Considerations. . . . . . . . . . . . . . . . . . . . . . 80\n    10.1. Control Message Attribute Value Pairs (AVPs) . . . . . . 80\n    10.2. Message Type AVP Values. . . . . . . . . . . . . . . . . 81\n    10.3. Result Code AVP Values . . . . . . . . . . . . . . . . . 81\n    10.4. AVP Header Bits. . . . . . . . . . . . . . . . . . . . . 82\n    10.5. L2TP Control Message Header Bits . . . . . . . . . . . . 82\n    10.6. Pseudowire Types . . . . . . . . . . . . . . . . . . . . 83\n    10.7. Circuit Status Bits. . . . . . . . . . . . . . . . . . . 83\n    10.8. Default L2-Specific Sublayer bits. . . . . . . . . . . . 84\n    10.9. L2-Specific Sublayer Type. . . . . . . . . . . . . . . . 84\n    10.10 Data Sequencing Level. . . . . . . . . . . . . . . . . . 84\n11. References . . . . . . . . . . . . . . . . . . . . . . . . . . 85\n    11.1. Normative References . . . . . . . . . . . . . . . . . . 85\n    11.2. Informative References . . . . . . . . . . . . . . . . . 85\n12. Acknowledgments. . . . . . . . . . . . . . . . . . . . . . . . 87\nAppendix A: Control Slow Start and Congestion Avoidance. . . . . . 89\nAppendix B: Control Message Examples . . . . . . . . . . . . . . . 90\nAppendix C: Processing Sequence Numbers. . . . . . . . . . . . . . 91\nEditors' Addresses . . . . . . . . . . . . . . . . . . . . . . . . 93\nFull Copyright Statement . . . . . . . . . . . . . . . . . . . . . 94",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "The Layer Two Tunneling Protocol (L2TP) provides a dynamic mechanism for tunneling Layer 2 (L2) \"circuits\" across a packet-oriented data network (e.g., over IP). L2TP, as originally defined in RFC 2661, is a standard method for tunneling Point-to-Point Protocol (PPP) [RFC1661] sessions. L2TP has since been adopted for tunneling a number of other L2 protocols. In order to provide greater modularity, this document describes the base L2TP protocol, independent of the L2 payload that is being tunneled.",
      "ja": "レイヤ2トンネリングプロトコル（L2TP）がトンネリングレイヤ2（L2）（IPオーバー例えば、）パケット指向データ・ネットワークを介して「回路」のための動的機構を提供します。 L2TPは、元々RFC 2661で定義されるように、トンネルポイントツーポイントプロトコル（PPP）[RFC1661]セッションのための標準的な方法です。 L2TPは、以降の他のL2プロトコルの数をトンネリングするために採用されています。より高いモジュール性を提供するために、この文書は、トンネルされたL2ペイロードの独立基地L2TPプロトコルを記述する。"
    },
    {
      "indent": 3,
      "text": "The base L2TP protocol defined in this document consists of (1) the control protocol for dynamic creation, maintenance, and teardown of L2TP sessions, and (2) the L2TP data encapsulation to multiplex and demultiplex L2 data streams between two L2TP nodes across an IP network. Additional documents are expected to be published for each L2 data link emulation type (a.k.a. pseudowire-type) supported by L2TP (i.e., PPP, Ethernet, Frame Relay, etc.). These documents will contain any pseudowire-type specific details that are outside the scope of this base specification.",
      "ja": "この文書で定義された基本L2TPプロトコルは、多重化およびIP横切っ2つのL2TPノード間L2データストリームを逆多重化するために（1）の制御動的に作成、メンテナンスのためのプロトコル、およびL2TPセッションのティアダウン、及び（2）L2TPデータのカプセル化から成り通信網。追加ドキュメントは、L2TP（即ち、PPP、イーサネット（登録商標）、フレームリレー、等）によってサポートされる各L2データリンクエミュレーションタイプ（別名擬似回線型）のために公開されることが期待されます。これらの文書は、この基本仕様の範囲外にある任意の疑似回線タイプの具体的な詳細が含まれます。"
    },
    {
      "indent": 3,
      "text": "When the designation between L2TPv2 and L2TPv3 is necessary, L2TP as defined in RFC 2661 will be referred to as \"L2TPv2\", corresponding to the value in the Version field of an L2TP header. (Layer 2 Forwarding, L2F, [RFC2341] was defined as \"version 1\".) At times, L2TP as defined in this document will be referred to as \"L2TPv3\". Otherwise, the acronym \"L2TP\" will refer to L2TPv3 or L2TP in general.",
      "ja": "L2TPv2とL2TPv3の間の指定が必要である場合、L2TP RFC 2661で定義されるようにL2TPヘッダのバージョンフィールドの値に対応し、「L2TPv2」と呼ぶことにします。 （レイヤ2フォワーディング、L2F、[RFC2341]「バージョン1」とした。）時には、L2TP本文書で定義されている「とは、L2TPv3の」と呼ぶことにします。それ以外の場合は、頭文字「L2TP」は、一般にL2TPv3のか、L2TPを指します。"
    },
    {
      "indent": 1,
      "text": "1.1. Changes from",
      "section_title": true,
      "ja": "1.1。からの変更点"
    },
    {
      "indent": 3,
      "text": "Many of the protocol constructs described in this document are carried over from RFC 2661. Changes include clarifications based on years of interoperability and deployment experience as well as modifications to either improve protocol operation or provide a clearer separation from PPP. The intent of these modifications is to achieve a healthy balance between code reuse, interoperability experience, and a directed evolution of L2TP as it is applied to new tasks.",
      "ja": "この文書に記載されているプロトコル構築物の多くは、2661.変更は、相​​互運用性と展開長年の経験に基づいて明確化だけでなく、プロトコルの動作を改善したり、PPPからの明確な分離を提供のいずれかに変更が含まRFCから引き継がれています。これらの変更の目的は、それが新しいタスクに適用されるように、コードの再利用、相互運用性の経験、およびL2TPの指向性進化の間に健全なバランスを達成することです。"
    },
    {
      "indent": 3,
      "text": "Notable differences between L2TPv2 and L2TPv3 include the following:",
      "ja": "L2TPv2とL2TPv3の間の顕著な違いは次のとおりです。"
    },
    {
      "indent": 6,
      "text": "Separation of all PPP-related AVPs, references, etc., including a portion of the L2TP data header that was specific to the needs of PPP. The PPP-specific constructs are described in a companion document.",
      "ja": "PPPのニーズに特異的であったL2TPデータヘッダの部分を含むすべてのPPP関連のAVP、参考文献等の分離。 PPP固有の構築物は仲間ドキュメントに記述されています。"
    },
    {
      "indent": 6,
      "text": "Transition from a 16-bit Session ID and Tunnel ID to a 32-bit Session ID and Control Connection ID, respectively.",
      "ja": "それぞれ32ビットのセッションIDと制御コネクションID、16ビットのセッションIDとトンネルIDから移行。"
    },
    {
      "indent": 6,
      "text": "Extension of the Tunnel Authentication mechanism to cover the entire control message rather than just a portion of certain messages.",
      "ja": "トンネル認証機構の拡張は、特定のメッセージの一部だけではなく、全体の制御メッセージをカバーします。"
    },
    {
      "indent": 3,
      "text": "Details of these changes and a recommendation for transitioning to L2TPv3 are discussed in Section 4.7.",
      "ja": "これらの変化とのL2TPv3への移行のための勧告の詳細については、4.7節で議論されています。"
    },
    {
      "indent": 0,
      "text": "1.2. Specification of Requirements",
      "section_title": true,
      "ja": "1.2。要件の仕様"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はあります[RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "1.3. Terminology",
      "section_title": true,
      "ja": "1.3。用語"
    },
    {
      "indent": 3,
      "text": "Attribute Value Pair (AVP)",
      "ja": "属性値ペア（AVP）"
    },
    {
      "indent": 6,
      "text": "The variable-length concatenation of a unique Attribute (represented by an integer), a length field, and a Value containing the actual value identified by the attribute. Zero or more AVPs make up the body of control messages, which are used in the establishment, maintenance, and teardown of control connections. This basic construct is sometimes referred to as a Type-Length-Value (TLV) in some specifications. (See also: Control Connection, Control Message.)",
      "ja": "（整数で表される）固有の属性の可変長連結、長さフィールド、および属性によって識別される実際の値を含む値。ゼロまたはそれ以上のAVPは、制御接続の確立、維持、およびティアダウンで使用されている制御メッセージのボディを構成します。この基本的な構築物は、時々、いくつかの仕様なType-Length-Value（TLV）と呼ばれています。 （参照：制御接続、制御メッセージを。）"
    },
    {
      "indent": 3,
      "text": "Call (Circuit Up)",
      "ja": "コール（昇圧回路）"
    },
    {
      "indent": 6,
      "text": "The action of transitioning a circuit on an L2TP Access Concentrator (LAC) to an \"up\" or \"active\" state. A call may be dynamically established through signaling properties (e.g., an incoming or outgoing call through the Public Switched Telephone Network (PSTN)) or statically configured (e.g., provisioning a Virtual Circuit on an interface). A call is defined by its properties (e.g., type of call, called number, etc.) and its data traffic. (See also: Circuit, Session, Incoming Call, Outgoing Call, Outgoing Call Request.)",
      "ja": "「アップ」または「アクティブ」状態にL2TPアクセス・コンセントレータ（LAC）上の回路の移行の作用。コールが動的にシグナリング特性を介して確立されてもよい（例えば、公共介して着信または発信コールは電話網（PSTN））または静的（例えば、インターフェイス上の仮想回線のプロビジョニング）構成します。コールは、その特性（例えば、呼のタイプ、被呼番号、等）と、そのデータトラフィックによって定義されます。 （参照：サーキット、セッション、着信、発信コール、発信要求を。）"
    },
    {
      "indent": 3,
      "text": "Circuit",
      "ja": "回路"
    },
    {
      "indent": 6,
      "text": "A general term identifying any one of a wide range of L2 connections. A circuit may be virtual in nature (e.g., an ATM PVC, an IEEE 802 VLAN, or an L2TP session), or it may have direct correlation to a physical layer (e.g., an RS-232 serial line). Circuits may be statically configured with a relatively long-lived uptime, or dynamically established with signaling to govern the establishment, maintenance, and teardown of the circuit. For the purposes of this document, a statically configured circuit is considered to be essentially the same as a very simple, long-lived, dynamic circuit. (See also: Call, Remote System.)",
      "ja": "L2接続の広い範囲のいずれかを特定する一般的な用語。回路は、自然（例えば、ATM PVC、IEEE 802 VLAN、またはL2TPセッション）中に仮想であってもよいし、物理層（例えば、RS-232シリアルライン）に直接的な相関関係を有していてもよいです。回路は、静的に、比較的長い寿命アップタイムで設定、または動的に回路の確立、維持、およびティアダウンを管理するためにシグナリングを用いて確立することができます。本文書の目的のために、静的に構成された回路は非常に単純な、長寿命、ダイナミック回路と本質的に同じであると考えられます。 （参照：呼び出し、リモートシステムを。）"
    },
    {
      "indent": 3,
      "text": "Client",
      "ja": "クライアント"
    },
    {
      "indent": 6,
      "text": "(See Remote System.)",
      "ja": "（リモートシステムを参照してください。）"
    },
    {
      "indent": 3,
      "text": "Control Connection",
      "ja": "制御接続"
    },
    {
      "indent": 6,
      "text": "An L2TP control connection is a reliable control channel that is used to establish, maintain, and release individual L2TP sessions as well as the control connection itself. (See also: Control Message, Data Channel.)",
      "ja": "L2TPコントロール接続を確立、維持、および個々のL2TPセッションだけでなく、コントロール接続自体を解放するために使用される信頼性の高い制御チャネルです。 （参照：制御メッセージ、データチャネルを。）"
    },
    {
      "indent": 3,
      "text": "Control Message",
      "ja": "制御メッセージ"
    },
    {
      "indent": 6,
      "text": "An L2TP message used by the control connection. (See also: Control Connection.)",
      "ja": "制御接続によって使用されるL2TPメッセージ。 （参照：接続を制御します。）"
    },
    {
      "indent": 3,
      "text": "Data Message",
      "ja": "データメッセージ"
    },
    {
      "indent": 6,
      "text": "Message used by the data channel. (a.k.a. Data Packet, See also: Data Channel.)",
      "ja": "データチャネルで使用されるメッセージ。 （データパケットとしても知られ、参照：データチャネルを。）"
    },
    {
      "indent": 3,
      "text": "Data Channel",
      "ja": "データチャネル"
    },
    {
      "indent": 6,
      "text": "The channel for L2TP-encapsulated data traffic that passes between two LCCEs over a Packet-Switched Network (i.e., IP). (See also: Control Connection, Data Message.)",
      "ja": "パケット交換ネットワーク（すなわち、IP）にわたって2つのLCCEsの間を通過するL2TPでカプセル化データトラフィック用チャネル。 （参照：制御接続、データメッセージを。）"
    },
    {
      "indent": 3,
      "text": "Incoming Call",
      "ja": "電話の着信"
    },
    {
      "indent": 6,
      "text": "The action of receiving a call (circuit up event) on an LAC. The call may have been placed by a remote system (e.g., a phone call over a PSTN), or it may have been triggered by a local event (e.g., interesting traffic routed to a virtual interface). An incoming call that needs to be tunneled (as determined by the LAC) results in the generation of an L2TP ICRQ message. (See also: Call, Outgoing Call, Outgoing Call Request.)",
      "ja": "LAC上のコール（サーキットアップイベント）を受信するアクション。コールは、リモートシステム（例えば、PSTN上の電話）によって配置されていてもよい、または、ローカルイベント（仮想インターフェイスにルーティングされ、例えば、対象トラフィック）によってトリガされていてもよいです。トンネリングされる必要がある着信コールが（LACによって決定される）L2TP ICRQメッセージの生成をもたらします。 （参照：、発信コール、発信要求を呼び出します。）"
    },
    {
      "indent": 3,
      "text": "L2TP Access Concentrator (LAC)",
      "ja": "L2TPアクセスコンセントレータ（LAC）"
    },
    {
      "indent": 6,
      "text": "If an L2TP Control Connection Endpoint (LCCE) is being used to cross-connect an L2TP session directly to a data link, we refer to it as an L2TP Access Concentrator (LAC). An LCCE may act as both an L2TP Network Server (LNS) for some sessions and an LAC for others, so these terms must only be used within the context of a given set of sessions unless the LCCE is in fact single purpose for a given topology. (See also: LCCE, LNS.)",
      "ja": "L2TPコントロール接続のエンドポイント（LCCE）は、直接データリンクにクロスコネクトL2TPセッションに使用されている場合、我々は、L2TPアクセスコンセントレータ（LAC）として参照します。 LCCEは、いくつかのセッションを、他の詳細はLACのためにL2TPネットワークサーバー（LNS）の両方として作用することができるので、LCCEは、実際には、所与のトポロジの単一目的でない限り、これらの用語は、セッションの所定のセットのコンテキスト内で使用されなければなりません。 （参照：LCCE、LNSを。）"
    },
    {
      "indent": 3,
      "text": "L2TP Control Connection Endpoint (LCCE)",
      "ja": "L2TPコントロール接続のエンドポイント（LCCE）"
    },
    {
      "indent": 6,
      "text": "An L2TP node that exists at either end of an L2TP control connection. May also be referred to as an LAC or LNS, depending on whether tunneled frames are processed at the data link (LAC) or network layer (LNS). (See also: LAC, LNS.)",
      "ja": "L2TPコントロール接続の両端に存在するL2TPノード。また、LACまたはトンネリングフレームはデータリンク（LAC）またはネットワーク層（LNS）で処理されているかどうかに応じてLNSと呼んでもよいです。 （参照：LAC、LNSを。）"
    },
    {
      "indent": 3,
      "text": "L2TP Network Server (LNS)",
      "ja": "L2TPネットワークサーバ（LNS）"
    },
    {
      "indent": 6,
      "text": "If a given L2TP session is terminated at the L2TP node and the encapsulated network layer (L3) packet processed on a virtual interface, we refer to this L2TP node as an L2TP Network Server (LNS). A given LCCE may act as both an LNS for some sessions and an LAC for others, so these terms must only be used within the context of a given set of sessions unless the LCCE is in fact single purpose for a given topology. (See also: LCCE, LAC.)",
      "ja": "所与のL2TPセッションがL2TPノードと仮想インタフェース上で処理カプセル化されたネットワーク層（L3）パケットで終了した場合、我々は、L2TPネットワークサーバー（LNS）としてこのL2TPノードを指します。所与LCCEは、いくつかのセッションのLNSなどのためのLACの両方として作用することができるので、LCCEが所与のトポロジの事実単一目的でない限り、これらの用語は、セッションの所定のセットのコンテキスト内で使用されなければなりません。 （参照：LCCE、LACを。）"
    },
    {
      "indent": 3,
      "text": "Outgoing Call",
      "ja": "発信コール"
    },
    {
      "indent": 6,
      "text": "The action of placing a call by an LAC, typically in response to policy directed by the peer in an Outgoing Call Request. (See also: Call, Incoming Call, Outgoing Call Request.)",
      "ja": "通常、発信要求にピアが監督ポリシーに応じて、LACで電話をかけるのアクション。 （参照：通話、着信、発信要求を。）"
    },
    {
      "indent": 3,
      "text": "Outgoing Call Request",
      "ja": "発信要求"
    },
    {
      "indent": 6,
      "text": "A request sent to an LAC to place an outgoing call. The request contains specific information not known a priori by the LAC (e.g., a number to dial). (See also: Call, Incoming Call, Outgoing Call.)",
      "ja": "LACに送信された要求は、発信コールを配置します。要求は、LAC（例えば、ダイヤルする番号）によって先験的に知られていない特定の情報を含んでいます。 （参照：、着信、発信コールを呼び出します。）"
    },
    {
      "indent": 3,
      "text": "Packet-Switched Network (PSN)",
      "ja": "パケット交換ネットワーク（PSN）"
    },
    {
      "indent": 6,
      "text": "A network that uses packet switching technology for data delivery. For L2TPv3, this layer is principally IP. Other examples include MPLS, Frame Relay, and ATM.",
      "ja": "データ配信のためのパケットスイッチング技術を使用するネットワーク。 L2TPv3のために、この層は、主にIPです。他の例としては、MPLS、フレームリレー、ATMがあります。"
    },
    {
      "indent": 3,
      "text": "Peer",
      "ja": "仲間"
    },
    {
      "indent": 6,
      "text": "When used in context with L2TP, Peer refers to the far end of an L2TP control connection (i.e., the remote LCCE). An LAC's peer may be either an LNS or another LAC. Similarly, an LNS's peer may be either an LAC or another LNS. (See also: LAC, LCCE, LNS.)",
      "ja": "L2TPに関連して使用される場合、ピアは、L2TP制御コネクション（すなわち、リモートLCCE）の遠端を指します。 LACのピアは、LNSまたは別のLACのいずれであってもよいです。同様に、LNSのピアは、LACまたは別のLNSのいずれであってもよいです。 （参照：LAC、LCCE、LNSを。）"
    },
    {
      "indent": 3,
      "text": "Pseudowire (PW)",
      "ja": "Psefdoviri（PO）"
    },
    {
      "indent": 6,
      "text": "An emulated circuit as it traverses a PSN. There is one Pseudowire per L2TP Session. (See also: Packet-Switched Network, Session.)",
      "ja": "それはPSNを横断としてエミュレート回路。 L2TPセッションごとに1つの擬似回線があります。 （参照：パケット交換ネットワーク、セッションを。）"
    },
    {
      "indent": 3,
      "text": "Pseudowire Type",
      "ja": "疑似回線タイプ"
    },
    {
      "indent": 6,
      "text": "The payload type being carried within an L2TP session. Examples include PPP, Ethernet, and Frame Relay. (See also: Session.)",
      "ja": "ペイロードタイプは、L2TPセッション内で実施されます。例としては、PPP、イーサネット、およびフレームリレーが含まれます。 （参照：セッションを。）"
    },
    {
      "indent": 3,
      "text": "Remote System",
      "ja": "リモートシステム"
    },
    {
      "indent": 6,
      "text": "An end system or router connected by a circuit to an LAC.",
      "ja": "LACに回路で接続されたエンド・システムまたはルータ。"
    },
    {
      "indent": 3,
      "text": "Session",
      "ja": "セッション"
    },
    {
      "indent": 6,
      "text": "An L2TP session is the entity that is created between two LCCEs in order to exchange parameters for and maintain an emulated L2 connection. Multiple sessions may be associated with a single Control Connection.",
      "ja": "L2TPセッションのためのパラメータを交換し、エミュレートL2接続を維持するために、2つのLCCEsの間に作成されるエンティティです。複数のセッションは、単一の制御接続に関連付けられてもよいです。"
    },
    {
      "indent": 3,
      "text": "Zero-Length Body (ZLB) Message",
      "ja": "ゼロ長さボディ（ZLB）メッセージ"
    },
    {
      "indent": 6,
      "text": "A control message with only an L2TP header. ZLB messages are used only to acknowledge messages on the L2TP reliable control connection. (See also: Control Message.)",
      "ja": "のみL2TPヘッダと制御メッセージ。 ZLBメッセージは、L2TP信頼性の高い制御接続上のメッセージを確認するためにのみ使用されます。 （参照：制御メッセージを。）"
    },
    {
      "indent": 0,
      "text": "2. Topology",
      "section_title": true,
      "ja": "2.トポロジ"
    },
    {
      "indent": 3,
      "text": "L2TP operates between two L2TP Control Connection Endpoints (LCCEs), tunneling traffic across a packet network. There are three predominant tunneling models in which L2TP operates: LAC-LNS (or vice versa), LAC-LAC, and LNS-LNS. These models are diagrammed below. (Dotted lines designate network connections. Solid lines designate circuit connections.)",
      "ja": "L2TPは、二つのL2TPコントロール接続エンドポイント（LCCEsの）、パケットネットワークを介してトンネリング・トラフィックとの間で動作します。 LAC-LNS（またはその逆）、LAC-LAC、およびLNS-LNS：L2TPが動作する三の優勢なトンネリングモデルがあります。これらのモデルは、以下に示しています。 （点線は、ネットワーク接続を指定する。実線は回路接続を示します。）"
    },
    {
      "indent": 21,
      "text": "Figure 2.0: L2TP Reference Models",
      "ja": "図2.0：L2TPの参照モデル"
    },
    {
      "indent": 3,
      "text": "(a) LAC-LNS Reference Model: On one side, the LAC receives traffic from an L2 circuit, which it forwards via L2TP across an IP or other packet-based network. On the other side, an LNS logically terminates the L2 circuit locally and routes network traffic to the home network. The action of session establishment is driven by the LAC (as an incoming call) or the LNS (as an outgoing call).",
      "ja": "（a）は、LAC-LNS参照モデルは、一面では、LACは、IPまたは他のパケットベースのネットワークを介してL2TPを介して転送L2回路からのトラフィックを受信します。他の側では、LNSは、論理的にホームネットワークにネットワークトラフィックをローカルにL2回路を終了したルート。セッション確立の作用は（着信など）LACまたは（発呼など）LNSによって駆動されます。"
    },
    {
      "indent": 4,
      "text": "+-----+  L2  +-----+                        +-----+\n|     |------| LAC |.........[ IP ].........| LNS |...[home network]\n+-----+      +-----+                        +-----+\nremote\nsystem\n                   |<-- emulated service -->|\n      |<----------- L2 service ------------>|",
      "raw": true
    },
    {
      "indent": 3,
      "text": "(b) LAC-LAC Reference Model: In this model, both LCCEs are LACs. Each LAC forwards circuit traffic from the remote system to the peer LAC using L2TP, and vice versa. In its simplest form, an LAC acts as a simple cross-connect between a circuit to a remote system and an L2TP session. This model typically involves symmetric establishment; that is, either side of the connection may initiate a session at any time (or simultaneously, in which a tie breaking mechanism is utilized).",
      "ja": "（b）は、LAC-LAC参照モデル：このモデルでは、両方のLCCEsのはのLACあります。各LAC L2TPを用いたピア・LACへのリモートシステムから転送回線トラフィック、およびその逆。その最も単純な形態では、LACは、単純なリモートシステムに回路とL2TPセッションの間にクロスコネクトとして作用します。このモデルは、一般的に、対称確立を必要とします。つまり、接続の両側には、（タイブレイク機構を利用した同時または）任意の時点でセッションを開始することができます。"
    },
    {
      "indent": 3,
      "text": "+-----+  L2  +-----+                      +-----+  L2  +-----+\n|     |------| LAC |........[ IP ]........| LAC |------|     |\n+-----+      +-----+                      +-----+      +-----+\nremote                                                 remote\nsystem                                                 system\n                   |<- emulated service ->|\n      |<----------------- L2 service ----------------->|",
      "raw": true
    },
    {
      "indent": 3,
      "text": "(c) LNS-LNS Reference Model: This model has two LNSs as the LCCEs. A user-level, traffic-generated, or signaled event typically drives session establishment from one side of the tunnel. For example, a tunnel generated from a PC by a user, or automatically by customer premises equipment.",
      "ja": "（c）はLNS-LNS参照モデル：このモデルは、LCCEsのように2つのLNSを持っています。ユーザーレベル、トラフィック発生、またはシグナリングイベントは、典型的には、トンネルの一方の側からセッション確立を駆動します。例えば、トンネルは、ユーザがPCから生成された、又は自動的に顧客宅内機器によって。"
    },
    {
      "indent": 2,
      "text": "                 +-----+                      +-----+\n[home network]...| LNS |........[ IP ]........| LNS |...[home network]\n                 +-----+                      +-----+\n                       |<- emulated service ->|\n                       |<---- L2 service ---->|",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Note: In L2TPv2, user-driven tunneling of this type is often referred to as \"voluntary tunneling\" [RFC2809]. Further, an LNS acting as part of a software package on a host is sometimes referred to as an \"LAC Client\" [RFC2661].",
      "ja": "注：L2TPv2では、このタイプのユーザ主導のトンネリングは、しばしば「自発的トンネリング」[RFC2809]と呼ぶことにします。また、ホスト上のソフトウェア・パッケージの一部として機能するLNSは時々「LACクライアント」[RFC2661]と呼ばれています。"
    },
    {
      "indent": 0,
      "text": "3. Protocol Overview",
      "section_title": true,
      "ja": "3.プロトコルの概要"
    },
    {
      "indent": 3,
      "text": "L2TP is comprised of two types of messages, control messages and data messages (sometimes referred to as \"control packets\" and \"data packets\", respectively). Control messages are used in the establishment, maintenance, and clearing of control connections and sessions. These messages utilize a reliable control channel within L2TP to guarantee delivery (see Section 4.2 for details). Data messages are used to encapsulate the L2 traffic being carried over the L2TP session. Unlike control messages, data messages are not retransmitted when packet loss occurs.",
      "ja": "L2TPは、（時には、それぞれ、「制御パケット」および「データ・パケット」と称する）メッセージ、制御メッセージおよびデータメッセージの二種類で構成されています。制御メッセージはコントロール接続とセッションの確立、維持、及び決済に使用されています。これらのメッセージは、（詳細はセクション4.2を参照）の配信を保証するためにL2TP内で信頼性の高い制御チャネルを利用しています。データメッセージはL2TPセッションを介して行われているL2トラフィックをカプセル化するために使用されています。パケットロスが発生したときに、制御メッセージとは異なり、データメッセージが再送されていません。"
    },
    {
      "indent": 3,
      "text": "The L2TPv3 control message format defined in this document borrows largely from L2TPv2. These control messages are used in conjunction with the associated protocol state machines that govern the dynamic setup, maintenance, and teardown for L2TP sessions. The data message format for tunneling data packets may be utilized with or without the L2TP control channel, either via manual configuration or via other signaling methods to pre-configure or distribute L2TP session information. Utilization of the L2TP data message format with other signaling methods is outside the scope of this document.",
      "ja": "この文書で定義されたL2TPv3コントロールメッセージフォーマットは、L2TPv2から大きく借り。これらの制御メッセージは、L2TPセッションのための動的な設定、メンテナンス、およびティアダウンを支配する関連するプロトコルのステートマシンと組み合わせて使用​​されています。トンネルデータパケットのデータメッセージフォーマットは、設定を事前またはL2TPセッション情報を配布するために手動の構成を介して、または他のシグナリングの方法のいずれかを介して、L2TP制御チャネルの有無にかかわらず利用することができます。他のシグナリング方法とL2TPデータメッセージフォーマットの利用は、この文書の範囲外です。"
    },
    {
      "indent": 23,
      "text": "Figure 3.0: L2TPv3 Structure",
      "ja": "図3.0：L2TPv3の構造"
    },
    {
      "indent": 13,
      "text": "+-------------------+    +-----------------------+\n| Tunneled Frame    |    | L2TP Control Message  |\n+-------------------+    +-----------------------+\n| L2TP Data Header  |    | L2TP Control Header   |\n+-------------------+    +-----------------------+\n| L2TP Data Channel |    | L2TP Control Channel  |\n| (unreliable)      |    | (reliable)            |\n+-------------------+----+-----------------------+\n| Packet-Switched Network (IP, FR, MPLS, etc.)   |\n+------------------------------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Figure 3.0 depicts the relationship of control messages and data messages over the L2TP control and data channels, respectively. Data messages are passed over an unreliable data channel, encapsulated by an L2TP header, and sent over a Packet-Switched Network (PSN) such as IP, UDP, Frame Relay, ATM, MPLS, etc. Control messages are sent over a reliable L2TP control channel, which operates over the same PSN.",
      "ja": "図3.0は、それぞれ、L2TP制御及びデータチャネルを介して制御メッセージおよびデータメッセージの関係を示しています。データメッセージは、L2TPヘッダによってカプセル化、信頼性の低いデータチャネルを介して渡され、このようなIP、UDP、フレームリレー、ATM、MPLSなどの制御メッセージを信頼できるL2TPを介して送信されるパケット交換ネットワーク（PSN）を介して送信されます同じPSN上で動作する制御チャネル、。"
    },
    {
      "indent": 3,
      "text": "The necessary setup for tunneling a session with L2TP consists of two steps: (1) Establishing the control connection, and (2) establishing a session as triggered by an incoming call or outgoing call. An L2TP session MUST be established before L2TP can begin to forward session frames. Multiple sessions may be bound to a single control connection, and multiple control connections may exist between the same two LCCEs.",
      "ja": "（1）制御接続を確立し、着信または発信を契機に（2）セッションを確立：L2TPとのセッションをトンネリングするために必要なセットアップは、2つのステップから成ります。 L2TPセッションのフレームを転送し始めることができる前に、L2TPセッションが確立されなければなりません。複数のセッションは、単一の制御接続に結合されてもよいし、複数の制御接続が同じ2つのLCCEsの間に存在してもよいです。"
    },
    {
      "indent": 0,
      "text": "3.1. Control Message Types",
      "section_title": true,
      "ja": "3.1。制御メッセージの種類"
    },
    {
      "indent": 3,
      "text": "The Message Type AVP (see Section 5.4.1) defines the specific type of control message being sent.",
      "ja": "メッセージタイプAVP（セクション5.4.1参照）送信される制御メッセージの特定のタイプを定義します。"
    },
    {
      "indent": 3,
      "text": "This document defines the following control message types (see Sections 6.1 through 6.15 for details on the construction and use of each message):",
      "ja": "この文書は、次の制御メッセージのタイプを（各メッセージの構築および使用の詳細については、6.15を介してセクション6.1を参照）を定義します。"
    },
    {
      "indent": 3,
      "text": "Control Connection Management",
      "ja": "コントロール接続管理"
    },
    {
      "indent": 6,
      "text": " 0 (reserved) 1 (SCCRQ) Start-Control-Connection-Request 2 (SCCRP) Start-Control-Connection-Reply 3 (SCCCN) Start-Control-Connection-Connected 4 (StopCCN) Stop-Control-Connection-Notification 5 (reserved) 6 (HELLO) Hello 20 (ACK) Explicit Acknowledgement",
      "ja": "0（予約）1（SCCRQ）制御開始-接続要求2（SCCRP）スタートコントロール接続回答3（SCCCN）コントロール接続接続スタート4（StopCCN）を停止コントロール接続通知5（予約）6（ハロー）ハロー20（ACK）明示的な確認応答"
    },
    {
      "indent": 3,
      "text": "Call Management",
      "ja": "コール管理"
    },
    {
      "indent": 6,
      "text": " 7 (OCRQ) Outgoing-Call-Request 8 (OCRP) Outgoing-Call-Reply 9 (OCCN) Outgoing-Call-Connected 10 (ICRQ) Incoming-Call-Request 11 (ICRP) Incoming-Call-Reply 12 (ICCN) Incoming-Call-Connected 13 (reserved) 14 (CDN) Call-Disconnect-Notify",
      "ja": "7（OCRQ）発信コールリクエスト8（OCRP）発信コールリプライ9（OCCN）発信呼接続10（ICRQ）着信リクエスト11（ICRP）着信リプライ12（ICCN）着信-Call接続13（予約）14（CDN）は、コール切断、通知します"
    },
    {
      "indent": 3,
      "text": "Error Reporting",
      "ja": "エラー報告"
    },
    {
      "indent": 6,
      "text": "15 (WEN) WAN-Error-Notify",
      "ja": "15（WEN）WAN誤り通知"
    },
    {
      "indent": 3,
      "text": "Link Status Change Reporting",
      "ja": "リンクステータス変更報告"
    },
    {
      "indent": 6,
      "text": "16 (SLI) Set-Link-Info",
      "ja": "16（SLI）を設定し、リンク情報"
    },
    {
      "indent": 0,
      "text": "3.2. L2TP Header Formats",
      "section_title": true,
      "ja": "3.2。 L2TPヘッダーフォーマット"
    },
    {
      "indent": 3,
      "text": "This section defines header formats for L2TP control messages and L2TP data messages. All values are placed into their respective fields and sent in network order (high-order octets first).",
      "ja": "このセクションでは、L2TP制御メッセージとL2TPデータメッセージのヘッダ・フォーマットを定義します。すべての値は、それぞれのフィールドに配置し、（第一高次オクテット）ネットワークの順で送信されます。"
    },
    {
      "indent": 0,
      "text": "3.2.1. L2TP Control Message Header",
      "section_title": true,
      "ja": "3.2.1。 L2TPコントロールメッセージヘッダ"
    },
    {
      "indent": 3,
      "text": "The L2TP control message header provides information for the reliable transport of messages that govern the establishment, maintenance, and teardown of L2TP sessions. By default, control messages are sent over the underlying media in-band with L2TP data messages.",
      "ja": "L2TP制御メッセージヘッダは、L2TPセッションの確立、維持、およびティアダウンを支配メッセージの信頼性の輸送のための情報を提供します。デフォルトでは、制御メッセージは、L2TPデータメッセージとインバンド基礎となるメディアを介して送信されます。"
    },
    {
      "indent": 3,
      "text": "The L2TP control message header is formatted as follows:",
      "ja": "次のようにL2TP制御メッセージヘッダはフォーマットされます。"
    },
    {
      "indent": 17,
      "text": "Figure 3.2.1: L2TP Control Message Header",
      "ja": "図3.2.1：L2TPコントロールメッセージヘッダ"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|T|L|x|x|S|x|x|x|x|x|x|x|  Ver  |             Length            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                     Control Connection ID                     |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|               Ns              |               Nr              |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The T bit MUST be set to 1, indicating that this is a control message.",
      "ja": "Tビットは、これが制御メッセージであることを示す、1に設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The L and S bits MUST be set to 1, indicating that the Length field and sequence numbers are present.",
      "ja": "LとSビットは、長さフィールドとシーケンス番号が存在することを示し、1に設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The x bits are reserved for future extensions. All reserved bits MUST be set to 0 on outgoing messages and ignored on incoming messages.",
      "ja": "xビットは、将来の拡張のために予約されています。すべての予約ビットは、送信メッセージに0に設定すると、着信メッセージで無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The Ver field indicates the version of the L2TP control message header described in this document. On sending, this field MUST be set to 3 for all messages (unless operating in an environment that includes L2TPv2 [RFC2661] and/or L2F [RFC2341] as well, see Section 4.1 for details).",
      "ja": "版フィールドは、この文書に記載されたL2TP制御メッセージヘッダのバージョンを示します。送信時に、このフィールドは、すべてのメッセージ（L2TPv2を含む環境で動作していない限り、[RFC2661]及び/又はL2F [RFC2341]も、詳細については、セクション4.1を参照）3に設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The Length field indicates the total length of the message in octets, always calculated from the start of the control message header itself (beginning with the T bit).",
      "ja": "Lengthフィールドは、常に、（Tビットで始まる）制御メッセージヘッダ自体の開始から算出し、オクテット内のメッセージの全長を示します。"
    },
    {
      "indent": 3,
      "text": "The Control Connection ID field contains the identifier for the control connection. L2TP control connections are named by identifiers that have local significance only. That is, the same control connection will be given unique Control Connection IDs by each LCCE from within each endpoint's own Control Connection ID number space. As such, the Control Connection ID in each message is that of the intended recipient, not the sender. Non-zero Control Connection IDs are selected and exchanged as Assigned Control Connection ID AVPs during the creation of a control connection.",
      "ja": "コントロールコネクションIDフィールドは、制御接続のための識別子が含まれています。 L2TPコントロール接続は、ローカルな意味を持つ識別子によって命名されています。これは、同じコントロール接続は、各エンドポイントの独自のコントロールコネクションID番号空間内からの各LCCEによって独自の制御接続IDが与えられますされています。このように、各メッセージにおける制御コネクションIDは、意図された受信者ではなく、送信者のものです。非ゼロの制御接続のIDを選択し、制御接続の作成時に割り当てられた制御コネクションIDのAVPとして交換されます。"
    },
    {
      "indent": 3,
      "text": "Ns indicates the sequence number for this control message, beginning at zero and incrementing by one (modulo 2**16) for each message sent. See Section 4.2 for more information on using this field.",
      "ja": "NSは、ゼロで始まり、送信されたメッセージごとに1（モジュロ2 ** 16）によりインクリメント、この制御メッセージのシーケンス番号を示します。このフィールドを使用しての詳細については、セクション4.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Nr indicates the sequence number expected in the next control message to be received. Thus, Nr is set to the Ns of the last in-order message received plus one (modulo 2**16). See Section 4.2 for more information on using this field.",
      "ja": "NRは、受信される次の制御メッセージに期待シーケンス番号を示します。メッセージが受信さプラス1（モジュロ2 ** 16）に次したがって、Nrの最後のNs個に設定されています。このフィールドを使用しての詳細については、セクション4.2を参照してください。"
    },
    {
      "indent": 0,
      "text": "3.2.2. L2TP Data Message",
      "section_title": true,
      "ja": "3.2.2。 L2TPデータメッセージ"
    },
    {
      "indent": 3,
      "text": "In general, an L2TP data message consists of a (1) Session Header, (2) an optional L2-Specific Sublayer, and (3) the Tunnel Payload, as depicted below.",
      "ja": "以下に示すように、一般に、L2TPデータメッセージは、（1）セッションヘッダ、（2）任意のL2特有の副層、および（3）トンネルペイロードから成ります。"
    },
    {
      "indent": 18,
      "text": "Figure 3.2.2: L2TP Data Message Header",
      "ja": "図3.2.2：L2TPデータメッセージのヘッダー"
    },
    {
      "indent": 3,
      "text": "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      L2TP Session Header                      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      L2-Specific Sublayer                     |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        Tunnel Payload                      ...\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The L2TP Session Header is specific to the encapsulating PSN over which the L2TP traffic is delivered. The Session Header MUST provide (1) a method of distinguishing traffic among multiple L2TP data sessions and (2) a method of distinguishing data messages from control messages.",
      "ja": "L2TPセッションヘッダは、L2TPトラフィックが配信された上でカプセル化PSNに固有のものです。セッションヘッダーは、複数のL2TPデータセッションおよび制御メッセージからデータ・メッセージを識別する（2）メソッド間でトラフィックを区別する（1）メソッドを提供しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Each type of encapsulating PSN MUST define its own session header, clearly identifying the format of the header and parameters necessary to setup the session. Section 4.1 defines two session headers, one for transport over UDP and one for transport over IP.",
      "ja": "PSNを封入の各タイプは、明らかに、セットアップに必要なヘッダ及びパラメータセッションのフォーマットを識別する、独自のセッション・ヘッダを定義しなければなりません。 4.1節では2つのセッションヘッダ、UDP上でのデータ転送を行う1およびIP経由の輸送のための1つを定義します。"
    },
    {
      "indent": 3,
      "text": "The L2-Specific Sublayer is an intermediary layer between the L2TP session header and the start of the tunneled frame. It contains control fields that are used to facilitate the tunneling of each frame (e.g., sequence numbers or flags). The Default L2-Specific Sublayer for L2TPv3 is defined in Section 4.6.",
      "ja": "L2特有サブレイヤは、L2TPセッションヘッダとトンネリングフレームの開始との間の中間層です。これは、各フレーム（例えば、シーケンス番号またはフラグ）のトンネリングを容易にするために使用される制御フィールドを含みます。 L2TPv3のためのデフォルトL2特有のSublayerはセクション4.6で定義されています。"
    },
    {
      "indent": 3,
      "text": "The Data Message Header is followed by the Tunnel Payload, including any necessary L2 framing as defined in the payload-specific companion documents.",
      "ja": "データメッセージヘッダはペイロード固有コンパニオン文書で定義されるように必要なL2フレーミングを含む、トンネルペイロードが続きます。"
    },
    {
      "indent": 0,
      "text": "3.3. Control Connection Management",
      "section_title": true,
      "ja": "3.3。コントロール接続管理"
    },
    {
      "indent": 3,
      "text": "The L2TP control connection handles dynamic establishment, teardown, and maintenance of the L2TP sessions and of the control connection itself. The reliable delivery of control messages is described in Section 4.2.",
      "ja": "L2TP制御接続は、L2TPセッションのと制御接続自体の動的確立、解体、および保守を担当します。制御メッセージの信頼性の高い配信は、4.2節に記述されています。"
    },
    {
      "indent": 3,
      "text": "This section describes typical control connection establishment and teardown exchanges. It is important to note that, in the diagrams that follow, the reliable control message delivery mechanism exists independently of the L2TP state machine. For instance, Explicit Acknowledgement (ACK) messages may be sent after any of the control messages indicated in the exchanges below if an acknowledgment is not piggybacked on a later control message.",
      "ja": "このセクションでは、典型的な制御接続確立およびティアダウン交換を記載しています。以下の図では、信頼性のある制御メッセージ配信機構は、独立L2TP状態マシンの存在、ということに留意することが重要です。例えば、明示的な肯定応答（ACK）メッセージは、肯定応答が後で制御メッセージにピギーバックされていない場合、以下の交換に示す制御メッセージの後に送信されても​​よいです。"
    },
    {
      "indent": 3,
      "text": "LCCEs are identified during control connection establishment either by the Host Name AVP, the Router ID AVP, or a combination of the two (see Section 5.4.3). The identity of a peer LCCE is central to selecting proper configuration parameters (i.e., Hello interval, window size, etc.) for a control connection, as well as for determining how to set up associated sessions within the control connection, password lookup for control connection authentication, control connection level tie breaking, etc.",
      "ja": "LCCEsのホスト名AVP、ルータID AVP、またはこの2つの組合せ（セクション5.4.3を参照）のいずれかによって制御接続確立中に識別されます。ピアLCCEのアイデンティティは、制御用パスワード検索制御接続のためだけでなく、制御接続内の関連するセッションを設定する方法を決定するための適切な設定パラメータ（すなわち、ハロー間隔、ウィンドウサイズなど）を選択の中心であります接続認証、制御接続レベルタイブレーキング、等"
    },
    {
      "indent": 0,
      "text": "3.3.1. Control Connection Establishment",
      "section_title": true,
      "ja": "3.3.1。制御接続の確立"
    },
    {
      "indent": 3,
      "text": "Establishment of the control connection involves an exchange of AVPs that identifies the peer and its capabilities.",
      "ja": "制御接続の確立は、ピアとその機能を特定のAVPの交換を伴います。"
    },
    {
      "indent": 3,
      "text": "A three-message exchange is used to establish the control connection. The following is a typical message exchange:",
      "ja": "三メッセージ交換は、制御接続を確立するために使用されます。以下は、一般的なメッセージ交換です。"
    },
    {
      "indent": 6,
      "text": "LCCE A      LCCE B\n------      ------\nSCCRQ ->\n            <- SCCRP\nSCCCN ->",
      "raw": true
    },
    {
      "indent": 0,
      "text": "3.3.2. Control Connection Teardown",
      "section_title": true,
      "ja": "3.3.2。制御接続の切断"
    },
    {
      "indent": 3,
      "text": "Control connection teardown may be initiated by either LCCE and is accomplished by sending a single StopCCN control message. As part of the reliable control message delivery mechanism, the recipient of a StopCCN MUST send an ACK message to acknowledge receipt of the message and maintain enough control connection state to properly accept StopCCN retransmissions over at least a full retransmission cycle (in case the ACK message is lost). The recommended time for a full retransmission cycle is at least 31 seconds (see Section 4.2). The following is an example of a typical control message exchange:",
      "ja": "制御接続ティアダウンのいずれかLCCEによって開始されてもよく、単一StopCCN制御メッセージを送信することによって達成されます。信頼性の高い制御メッセージ配信機構の一部として、StopCCNの受信者はACKメッセージ場合には（メッセージの受信を確認し、適切には少なくとも完全再送周期にわたってStopCCN再送を受け入れるのに十分な制御接続状態を維持するためにACKメッセージを送らなければなりません）が失われます。フル再送周期のための推奨される時間は少なくとも31秒（4.2節を参照）です。以下は、一般的な制御メッセージ交換の一例です。"
    },
    {
      "indent": 6,
      "text": "LCCE A      LCCE B\n------      ------\nStopCCN ->\n(Clean up)",
      "raw": true
    },
    {
      "indent": 18,
      "text": "(Wait)\n(Clean up)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "An implementation may shut down an entire control connection and all sessions associated with the control connection by sending the StopCCN. Thus, it is not necessary to clear each session individually when tearing down the whole control connection.",
      "ja": "実装は、全体の制御接続とStopCCNを送信することにより、制御接続に関連付けられているすべてのセッションをシャットダウンしてもよいです。これにより、全体の制御接続を切断する際個別セッションをクリアする必要はありません。"
    },
    {
      "indent": 0,
      "text": "3.4. Session Management",
      "section_title": true,
      "ja": "3.4。セッション管理"
    },
    {
      "indent": 3,
      "text": "After successful control connection establishment, individual sessions may be created. Each session corresponds to a single data stream between the two LCCEs. This section describes the typical call establishment and teardown exchanges.",
      "ja": "成功した制御接続確立後は、個々のセッションを作成することができます。各セッションは、二つのLCCEsの間の単一のデータストリームに対応します。このセクションでは、一般的なコールの確立とティアダウンの交流を説明しています。"
    },
    {
      "indent": 0,
      "text": "3.4.1. Session Establishment for an Incoming Call",
      "section_title": true,
      "ja": "3.4.1。着信のためのセッション確立"
    },
    {
      "indent": 3,
      "text": "A three-message exchange is used to establish the session. The following is a typical sequence of events:",
      "ja": "3のメッセージ交換は、セッションを確立するために使用されます。以下は、イベントの典型的な配列です。"
    },
    {
      "indent": 6,
      "text": "LCCE A      LCCE B\n------      ------\n(Call\n Detected)",
      "raw": true
    },
    {
      "indent": 6,
      "text": "ICRQ -> <- ICRP (Call Accepted)",
      "ja": "ICRQ  - > < -  ICRP（受理を呼び出します）"
    },
    {
      "indent": 6,
      "text": "ICCN ->",
      "ja": "ICCN  - >"
    },
    {
      "indent": 0,
      "text": "3.4.2. Session Establishment for an Outgoing Call",
      "section_title": true,
      "ja": "3.4.2。発信コールのセッション確立"
    },
    {
      "indent": 3,
      "text": "A three-message exchange is used to set up the session. The following is a typical sequence of events:",
      "ja": "3のメッセージ交換は、セッションを設定するために使用されます。以下は、イベントの典型的な配列です。"
    },
    {
      "indent": 6,
      "text": "LCCE A      LCCE B\n------      ------\n           <- OCRQ\nOCRP ->",
      "raw": true
    },
    {
      "indent": 6,
      "text": "(Perform Call Operation)",
      "ja": "（通話操作を実行）"
    },
    {
      "indent": 6,
      "text": "OCCN ->",
      "ja": "OCCN  - >"
    },
    {
      "indent": 6,
      "text": "(Call Operation Completed Successfully)",
      "ja": "（操作が正常に完了したコール）"
    },
    {
      "indent": 0,
      "text": "3.4.3. Session Teardown",
      "section_title": true,
      "ja": "3.4.3。セッションのティアダウン"
    },
    {
      "indent": 3,
      "text": "Session teardown may be initiated by either the LAC or LNS and is accomplished by sending a CDN control message. After the last session is cleared, the control connection MAY be torn down as well (and typically is). The following is an example of a typical control message exchange:",
      "ja": "セッションティアダウンは、LACまたはLNSのどちらかによって開始することができ、CDN制御メッセージを送信することによって達成されます。最後のセッションがクリアされた後、制御接続は、同様に取り壊され（通常はある）であってもよいです。以下は、一般的な制御メッセージ交換の一例です。"
    },
    {
      "indent": 6,
      "text": "LCCE A      LCCE B\n------      ------\nCDN ->\n(Clean up)",
      "raw": true
    },
    {
      "indent": 18,
      "text": "(Clean up)",
      "ja": "（掃除）"
    },
    {
      "indent": 0,
      "text": "4. Protocol Operation",
      "section_title": true,
      "ja": "4.プロトコル動作"
    },
    {
      "indent": 0,
      "text": "4.1. L2TP Over Specific Packet-Switched Networks (PSNs)",
      "section_title": true,
      "ja": "4.1。 L2TP以上の特定のパケット交換ネットワーク（PSNが）"
    },
    {
      "indent": 3,
      "text": "L2TP may operate over a variety of PSNs. There are two modes described for operation over IP, L2TP directly over IP (see Section 4.1.1) and L2TP over UDP (see Section 4.1.2). L2TPv3 implementations MUST support L2TP over IP and SHOULD support L2TP over UDP for better NAT and firewall traversal, and for easier migration from L2TPv2.",
      "ja": "L2TPはのPSNの様々な上で動作することができます。 UDP（4.1.2項を参照）上に直接IP（4.1.1項を参照）、L2TP上でIP、L2TPでの動作が説明された2つのモードがあります。 L2TPv3の実装は、IP経由L2TPをサポートしなければならない、より良いNATやファイアウォール越えのため、およびL2TPv2からの容易な移行のためにUDPの上にL2TPをサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "L2TP over other PSNs may be defined, but the specifics are outside the scope of this document. Examples of L2TPv2 over other PSNs include [RFC3070] and [RFC3355].",
      "ja": "他のPSN上L2TPを定義することができるが、具体的には、この文書の範囲外です。他のPSN上L2TPv2の例は、[RFC3070]及び[RFC3355]を含みます。"
    },
    {
      "indent": 3,
      "text": "The following field definitions are defined for use in all L2TP Session Header encapsulations.",
      "ja": "以下のフィールド定義は、すべてのL2TPセッションヘッダのカプセル化での使用のために定義されています。"
    },
    {
      "indent": 3,
      "text": "Session ID",
      "ja": "セッションID"
    },
    {
      "indent": 6,
      "text": "A 32-bit field containing a non-zero identifier for a session. L2TP sessions are named by identifiers that have local significance only. That is, the same logical session will be given different Session IDs by each end of the control connection for the life of the session. When the L2TP control connection is used for session establishment, Session IDs are selected and exchanged as Local Session ID AVPs during the creation of a session. The Session ID alone provides the necessary context for all further packet processing, including the presence, size, and value of the Cookie, the type of L2-Specific Sublayer, and the type of payload being tunneled.",
      "ja": "セッションの非ゼロ識別子を含む32ビットのフィールド。 L2TPセッションは、ローカルな意味を持つ識別子によって命名されています。これは、同じ論理セッションは、セッションの生活のための制御接続の両端で異なるセッションIDが与えられますされています。 L2TPコントロール接続はセッション確立のために使用されている場合は、セッションIDを選択して、セッションの作成中にローカルセッションIDのAVPとして交換されています。セッションIDは、単独で、クッキー、L2特有の副層のタイプの存在、大きさ、および値を含むすべてのさらなるパケット処理に必要なコンテキストを提供し、ペイロードのタイプは、トンネルされます。"
    },
    {
      "indent": 3,
      "text": "Cookie",
      "ja": "クッキー"
    },
    {
      "indent": 6,
      "text": "The optional Cookie field contains a variable-length value (maximum 64 bits) used to check the association of a received data message with the session identified by the Session ID. The Cookie MUST be set to the configured or signaled random value for this session. The Cookie provides an additional level of guarantee that a data message has been directed to the proper session by the Session ID. A well-chosen Cookie may prevent inadvertent misdirection of stray packets with recently reused Session IDs, Session IDs subject to packet corruption, etc. The Cookie may also provide protection against some specific malicious packet insertion attacks, as described in Section 8.2.",
      "ja": "任意クッキーフィールドは、セッションIDによって識別されるセッションに受信されたデータ・メッセージの関連性を確認するために使用される可変長値（最大64ビット）を含みます。クッキーは、このセッションのために構成された、またはシグナリングランダムな値に設定しなければなりません。クッキーは、データ・メッセージは、セッションIDによって適切なセッションに指示された保証の追加レベルを提供します。適切に選択されたクッキーは、8.2節で説明したようにクッキーはまた、いくつかの特定の悪意のあるパケット挿入攻撃に対する保護を提供することができるなど、最近再利用セッションIDが、パケットの破損にセッションIDが対象と浮遊パケットの不注意によるミスディレクションを防ぐことができます。"
    },
    {
      "indent": 6,
      "text": "When the L2TP control connection is used for session establishment, random Cookie values are selected and exchanged as Assigned Cookie AVPs during session creation.",
      "ja": "L2TP制御接続はセッション確立のために使用される場合、ランダムクッキー値を選択し、セッションの作成時に割り当てられたクッキーのAVPとして交換されます。"
    },
    {
      "indent": 0,
      "text": "4.1.1. L2TPv3 over IP",
      "section_title": true,
      "ja": "4.1.1。 IP上のL2TPv3"
    },
    {
      "indent": 3,
      "text": "L2TPv3 over IP (both versions) utilizes the IANA-assigned IP protocol ID 115.",
      "ja": "IP上のL2TPv3（両方のバージョン）は、IANAによって割り当てられたIPプロトコルID 115を利用します。"
    },
    {
      "indent": 0,
      "text": "4.1.1.1. L2TPv3 Session Header Over IP",
      "section_title": true,
      "ja": "4.1.1.1。 L2TPv3のセッションヘッダオーバーIP"
    },
    {
      "indent": 3,
      "text": "Unlike L2TP over UDP, the L2TPv3 session header over IP is free of any restrictions imposed by coexistence with L2TPv2 and L2F. As such, the header format has been designed to optimize packet processing. The following session header format is utilized when operating L2TPv3 over IP:",
      "ja": "UDP上のL2TPとは異なり、IP上のL2TPv3セッションヘッダは、L2TPv2とL2Fとの共存による制限がありません。このように、ヘッダフォーマットは、パケット処理を最適化するように設計されています。 IP上のL2TPv3を動作させる場合は、次のセッションヘッダフォーマットが利用されます。"
    },
    {
      "indent": 15,
      "text": "Figure 4.1.1.1: L2TPv3 Session Header Over IP",
      "ja": "図4.1.1.1：L2TPv3のセッションヘッダオーバーIP"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                           Session ID                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|               Cookie (optional, maximum 64 bits)...\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                                                                |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The Session ID and Cookie fields are as defined in Section 4.1. The Session ID of zero is reserved for use by L2TP control messages (see Section 4.1.1.2).",
      "ja": "セクション4.1で定義されたセッションIDとクッキーのフィールドがあります。ゼロのセッションIDは、L2TP制御メッセージで使用するために予約されている（セクション4.1.1.2を参照）。"
    },
    {
      "indent": 0,
      "text": "4.1.1.2. L2TP Control and Data Traffic over IP",
      "section_title": true,
      "ja": "4.1.1.2。 IPを介したL2TP制御とデータトラフィック"
    },
    {
      "indent": 3,
      "text": "Unlike L2TP over UDP, which uses the T bit to distinguish between L2TP control and data packets, L2TP over IP uses the reserved Session ID of zero (0) when sending control messages. It is presumed that checking for the zero Session ID is more efficient -- both in header size for data packets and in processing speed for distinguishing between control and data messages -- than checking a single bit.",
      "ja": "L2TP制御パケットとデータパケットとを区別するためにTビットを使用してUDP上L2TPとは異なり、IP上L2TPは、ゼロ（0）を送信する制御メッセージの予約セッションIDを使用します。ゼロのセッションIDをチェックすることはより効率的であると推定される - データパケットのヘッダサイズ及び処理速度の両方の制御及びデータメッセージを区別するため - 単一ビットをチェックするより。"
    },
    {
      "indent": 3,
      "text": "The entire control message header over IP, including the zero session ID, appears as follows:",
      "ja": "次のようにゼロセッションIDを含むIP上全体制御メッセージヘッダは、表示されます。"
    },
    {
      "indent": 11,
      "text": "Figure 4.1.1.2: L2TPv3 Control Message Header Over IP",
      "ja": "図4.1.1.2：L2TPv3のコントロールメッセージヘッダーの上にIP"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      (32 bits of zeros)                       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|T|L|x|x|S|x|x|x|x|x|x|x|  Ver  |             Length            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                     Control Connection ID                     |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|               Ns              |               Nr              |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Named fields are as defined in Section 3.2.1. Note that the Length field is still calculated from the beginning of the control message header, beginning with the T bit. It does NOT include the \"(32 bits of zeros)\" depicted above.",
      "ja": "3.2.1節で定義された名前付きのフィールドがあります。 Lengthフィールドは、まだTビットで始まる、制御メッセージヘッダの先頭から計算されることに留意されたいです。これは、上に示した「（ゼロの32ビット）」を含んでいません。"
    },
    {
      "indent": 3,
      "text": "When operating directly over IP, L2TP packets lose the ability to take advantage of the UDP checksum as a simple packet integrity check, which is of particular concern for L2TP control messages. Control Message Authentication (see Section 4.3), even with an empty password field, provides for a sufficient packet integrity check and SHOULD always be enabled.",
      "ja": "IP上で直接動作する場合、L2TPパケットがL2TPコントロールメッセージのために特に懸念される単純なパケットの整合性チェック、としてUDPチェックサムを利用する能力を失います。でも、空のパスワードフィールドとコントロールメッセージ認証は（4.3節を参照）、十分なパケットの整合性チェックのために提供し、常に有効にする必要があります。"
    },
    {
      "indent": 0,
      "text": "4.1.2. L2TP over UDP",
      "section_title": true,
      "ja": "4.1.2。 UDP上のL2TP"
    },
    {
      "indent": 3,
      "text": "L2TPv3 over UDP must consider other L2 tunneling protocols that may be operating in the same environment, including L2TPv2 [RFC2661] and L2F [RFC2341].",
      "ja": "UDP上のL2TPv3はL2TPv2 [RFC2661]とL2F [RFC2341]を含むと同じ環境で動作することができる他のL2トンネリングプロトコルを、考慮しなければなりません。"
    },
    {
      "indent": 3,
      "text": "While there are efficiencies gained by running L2TP directly over IP, there are possible side effects as well. For instance, L2TP over IP is not as NAT-friendly as L2TP over UDP.",
      "ja": "直接IP上でL2TPを実行することによって得られる効率性がありますが、同様に可能な副作用があります。たとえば、IP上のL2TPはUDP上のL2TPとしてNATに優しいようではありません。"
    },
    {
      "indent": 0,
      "text": "4.1.2.1. L2TP Session Header Over UDP",
      "section_title": true,
      "ja": "4.1.2.1。 L2TPセッションヘッダーの上にUDP"
    },
    {
      "indent": 3,
      "text": "The following session header format is utilized when operating L2TPv3 over UDP:",
      "ja": "UDP上のL2TPv3を動作させる場合は、次のセッションヘッダフォーマットが利用されます。"
    },
    {
      "indent": 14,
      "text": "Figure 4.1.2.1: L2TPv3 Session Header over UDP",
      "ja": "図4.1.2.1：UDP上のL2TPv3セッションヘッダ"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|T|x|x|x|x|x|x|x|x|x|x|x|  Ver  |          Reserved             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                           Session ID                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|               Cookie (optional, maximum 64 bits)...\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                                                                |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The T bit MUST be set to 0, indicating that this is a data message.",
      "ja": "Tビットが、これはデータメッセージであることを示す、0に設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The x bits and Reserved field are reserved for future extensions. All reserved values MUST be set to 0 on outgoing messages and ignored on incoming messages.",
      "ja": "xビットと予約フィールドは将来の拡張のために予約されています。すべての予約値は、送信メッセージに0に設定すると、着信メッセージで無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The Ver field MUST be set to 3, indicating an L2TPv3 message.",
      "ja": "Ver分野は、L2TPv3のメッセージを示す、3に設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Note that the initial bits 1, 4, 6, and 7 have meaning in L2TPv2 [RFC2661], and are deprecated and marked as reserved in L2TPv3. Thus, for UDP mode on a system that supports both versions of L2TP, it is important that the Ver field be inspected first to determine the Version of the header before acting upon any of these bits.",
      "ja": "最初のビット1、4、6、及び7は、L2TPv2 [RFC2661]に意味を持ち、そしてL2TPv3のに確保非推奨とマークされていることに留意されたいです。したがって、L2TPの両方のバージョンをサポートするシステム上のUDPモードでは、版フィールドは、これらのビットのいずれかに作用する前に、ヘッダのバージョンを決定するために、第1検査することが重要です。"
    },
    {
      "indent": 3,
      "text": "The Session ID and Cookie fields are as defined in Section 4.1.",
      "ja": "セクション4.1で定義されたセッションIDとクッキーのフィールドがあります。"
    },
    {
      "indent": 0,
      "text": "4.1.2.2. UDP Port Selection",
      "section_title": true,
      "ja": "4.1.2.2。 UDPポートの選択"
    },
    {
      "indent": 3,
      "text": "The method for UDP Port Selection defined in this section is identical to that defined for L2TPv2 [RFC2661].",
      "ja": "このセクションで定義されたUDPポートの選択のための方法は、L2TPv2 [RFC2661]のために定義されたものと同一です。"
    },
    {
      "indent": 3,
      "text": "When negotiating a control connection over UDP, control messages MUST be sent as UDP datagrams using the registered UDP port 1701 [RFC1700]. The initiator of an L2TP control connection picks an available source UDP port (which may or may not be 1701) and sends to the desired destination address at port 1701. The recipient picks a free port on its own system (which may or may not be 1701) and sends its reply to the initiator's UDP port and address, setting its own source port to the free port it found.",
      "ja": "UDP上の制御接続を交渉する際に、制御メッセージが登録されたUDPポート1701 [RFC1700]を使用して、UDPデータグラムとして送信されなければなりません。 L2TPコントロール接続のイニシエータは、利用可能なソースUDPポート（または1701であってもなくてもよい）、ピック及び（又はこれにあってもなくてもよいポート1701受信者は、自身のシステム上の空きポートをピックアップで所望の送信先アドレスに送信します1701年）と、それが見つかった空きポートに、自身の送信元ポートを設定し、イニシエータのUDPポートとアドレスにその応答を送信します。"
    },
    {
      "indent": 3,
      "text": "Any subsequent traffic associated with this control connection (either control traffic or data traffic from a session established through this control connection) must use these same UDP ports.",
      "ja": "この制御接続（この制御接続を介して確立されたセッションからの制御トラフィックまたはデータ・トラフィックのいずれか）に関連付けられた任意の後続のトラフィックは、これらの同じUDPポートを使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "It has been suggested that having the recipient choose an arbitrary source port (as opposed to using the destination port in the packet initiating the control connection, i.e., 1701) may make it more difficult for L2TP to traverse some NAT devices. Implementations should consider the potential implication of this capability before choosing an arbitrary source port. A NAT device that can pass TFTP traffic with variant UDP ports should be able to pass L2TP UDP traffic since both protocols employ similar policies with regard to UDP port selection.",
      "ja": "（制御接続を開始するパケットの宛先ポートを使用してとは対照的に、即ち、1701）受信者は、任意の送信元ポートを選択して有することがより困難L2TPは、いくつかのNATデバイスをトラバースするために作ることができることが示唆されています。実装は、任意の送信元ポートを選択する前に、この機能の潜在的な意味合いを検討すべきです。変異UDPポートでTFTPトラフィックを渡すことができNATデバイスは、両方のプロトコルがUDPポート選択に関する同様のポリシーを採用するためL2TP UDPトラフィックを通過することができなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.1.2.3. UDP Checksum",
      "section_title": true,
      "ja": "4.1.2.3。 UDPチェックサム"
    },
    {
      "indent": 3,
      "text": "The tunneled frames that L2TP carry often have their own checksums or integrity checks, rendering the UDP checksum redundant for much of the L2TP data message contents. Thus, UDP checksums MAY be disabled in order to reduce the associated packet processing burden at the L2TP endpoints.",
      "ja": "トンネリングされたフレームは、L2TPが運ぶことを、多くの場合、L2TPデータメッセージの内容の大部分のための冗長UDPチェックサムをレンダリングし、自分自身のチェックサムまたは整合性チェックを持っています。したがって、UDPチェックサムは、L2TPエンドポイントに関連するパケット処理負担を軽減するために無効になることがあります。"
    },
    {
      "indent": 3,
      "text": "The L2TP header itself does not have its own checksum or integrity check. However, use of the L2TP Session ID and Cookie pair guards against accepting an L2TP data message if corruption of the Session ID or associated Cookie has occurred. When the L2-Specific Sublayer is present in the L2TP header, there is no built-in integrity check for the information contained therein if UDP checksums or some other integrity check is not employed. IPsec (see Section 4.1.3) may be used for strong integrity protection of the entire contents of L2TP data messages.",
      "ja": "L2TPヘッダ自体は、独自のチェックサムまたは整合性チェックを持っていません。しかし、セッションID又は関連するクッキーの破損が発生した場合L2TPデータメッセージを受け入れるに対するL2TPセッションIDとクッキー対ガードの使用。 L2特有サブレイヤはL2TPヘッダ内に存在する場合、内蔵なし、そこに含まれる情報の整合性チェックUDPチェックサムまたは他のいくつかの整合性チェックを用いない場合には存在しません。 IPsecは（4.1.3項を参照）L2TPデータメッセージの内容全体の強力な完全性保護のために使用することができます。"
    },
    {
      "indent": 3,
      "text": "UDP checksums MUST be enabled for L2TP control messages.",
      "ja": "UDPチェックサムは、L2TPコントロールメッセージのために有効にする必要があります。"
    },
    {
      "indent": 0,
      "text": "4.1.3. L2TP and IPsec",
      "section_title": true,
      "ja": "4.1.3。 L2TPとIPsec"
    },
    {
      "indent": 3,
      "text": "The L2TP data channel does not provide cryptographic security of any kind. If the L2TP data channel operates over a public or untrusted IP network where privacy of the L2TP data is of concern or sophisticated attacks against L2TP are expected to occur, IPsec [RFC2401] MUST be made available to secure the L2TP traffic.",
      "ja": "L2TPデータチャネルは、どのような種類の暗号化セキュリティを提供していません。 L2TPデータチャネルは、L2TPデータのプライバシーが心配やL2TPに対する高度な攻撃が発生すると予想されているのであるパブリックまたは信頼できないIPネットワーク上で動作する場合、IPsecの[RFC2401]はL2TPトラフィックを保護するために利用可能にする必要があります。"
    },
    {
      "indent": 3,
      "text": "Either L2TP over UDP or L2TP over IP may be secured with IPsec. [RFC3193] defines the recommended method for securing L2TPv2. L2TPv3 possesses identical characteristics to IPsec as L2TPv2 when running over UDP and implementations MUST follow the same recommendation. When operating over IP directly, [RFC3193] still applies, though references to UDP source and destination ports (in particular, those in Section 4, \"IPsec Filtering details when protecting L2TP\") may be ignored. Instead, the selectors used to identify L2TPv3 traffic are simply the source and destination IP addresses for the tunnel endpoints together with the L2TPv3 IP protocol type, 115.",
      "ja": "IP上のUDPまたはL2TPを超えるL2TPは、IPsecで保護することができるどちらか。 [RFC3193]はL2TPv2を固定するための推奨される方法を定義します。同じ推奨に従わなければならないUDP及び実装上で動作するときのL2TPv3はL2TPv2としてIPsecのと同じ特徴を有します。直接IP上で動作するときにUDP送信元ポートおよび宛先ポートへの参照は、（特に、第4のものは、「L2TPを保護する際のIPsecフィルタリング詳細」）は無視されてもよいが、[RFC3193]は依然として、適用されます。代わりに、L2TPv3のトラフィックを識別するために使用されるセレクタは単にのL2TPv3 IPプロトコルタイプ、115と一緒にトンネルエンドポイントのためのソースおよび宛先IPアドレスです。"
    },
    {
      "indent": 3,
      "text": "In addition to IP transport security, IPsec defines a mode of operation that allows tunneling of IP packets. The packet-level encryption and authentication provided by IPsec tunnel mode and that provided by L2TP secured with IPsec provide an equivalent level of security for these requirements.",
      "ja": "IPトランスポート・セキュリティに加えて、IPsecはIPパケットのトンネリングを可能にする動作モードを定義します。 IPsecトンネルモードによって提供されるパケットレベルの暗号化と認証およびIPsecで固定L2TPによって提供されるこれらの要求に対するセキュリティと同等レベルを提供します。"
    },
    {
      "indent": 3,
      "text": "IPsec also defines access control features that are required of a compliant IPsec implementation. These features allow filtering of packets based upon network and transport layer characteristics such as IP address, ports, etc. In the L2TP tunneling model, analogous filtering may be performed at the network layer above L2TP. These network layer access control features may be handled at an LCCE via vendor-specific authorization features, or at the network layer itself by using IPsec transport mode end-to-end between the communicating hosts. The requirements for access control mechanisms are not a part of the L2TP specification, and as such, are outside the scope of this document.",
      "ja": "IPsecはまた、準拠したIPsec実装に必要とされているアクセス制御機能を定義します。これらの機能は、類似フィルタリングL2TP上記ネットワーク層で実行されてもよい、L2TPトンネリングモデルで等IPアドレスなどのネットワークとトランスポート層の特性に基づいてパケットのフィルタリング、ポートを、可能にします。これらのネットワーク層のアクセス制御機能は、ベンダー固有の承認機能を介して、またはネットワーク層自体でのIPsecトランスポート・モード・エンド・ツー・エンドの通信ホスト間を使用してLCCEで処理されてもよいです。アクセス制御メカニズムのための要件は、L2TP仕様の一部ではなく、そのようなものとして、この文書の範囲外です。"
    },
    {
      "indent": 3,
      "text": "Protecting the L2TP packet stream with IPsec does, in turn, also protect the data within the tunneled session packets while transported from one LCCE to the other. Such protection must not be considered a substitution for end-to-end security between communicating hosts or applications.",
      "ja": "他に1つのLCCEから輸送ながらのIPsecとL2TPパケットストリームを保護することは、今度は、また、トンネリングセッションパケット内のデータを保護しません。このような保護は、通信中のホストやアプリケーション間のエンドツーエンドのセキュリティのための代用と考えてはいけません。"
    },
    {
      "indent": 0,
      "text": "4.1.4. IP Fragmentation Issues",
      "section_title": true,
      "ja": "4.1.4。 IPフラグメンテーションの問題"
    },
    {
      "indent": 3,
      "text": "Fragmentation and reassembly in network equipment generally require significantly greater resources than sending or receiving a packet as a single unit. As such, fragmentation and reassembly should be avoided whenever possible. Ideal solutions for avoiding fragmentation include proper configuration and management of MTU sizes among the Remote System, the LCCE, and the IP network, as well as adaptive measures that operate with the originating host (e.g., [RFC1191], [RFC1981]) to reduce the packet sizes at the source.",
      "ja": "ネットワーク機器におけるフラグメンテーション及び再組み立ては、一般的に単一のユニットとしてパケットを送信または受信よりも有意に大きいリソースを必要とします。そのため、断片化と再構築は可能な限り避けるべきです。断片化を回避するための理想的なソリューションは、適切な構成と管理MTUサイズのリモートシステム、LCCE、およびIPネットワークの中だけでなく、削減する元ホスト（例えば、[RFC1191]、[RFC1981]）で動作適応策を含めますパケットが送信元でサイズ。"
    },
    {
      "indent": 3,
      "text": "An LCCE MAY fragment a packet before encapsulating it in L2TP. For example, if an IPv4 packet arrives at an LCCE from a Remote System that, after encapsulation with its associated framing, L2TP, and IP, does not fit in the available path MTU towards its LCCE peer, the local LCCE may perform IPv4 fragmentation on the packet before tunnel encapsulation. This creates two (or more) L2TP packets, each carrying an IPv4 fragment with its associated framing. This ultimately has the effect of placing the burden of fragmentation on the LCCE, while reassembly occurs on the IPv4 destination host.",
      "ja": "LCCEはL2TPでそれをカプセル化する前に、パケットを断片化するかもしれません。たとえば、IPv4パケットは、それに関連するフレーミング、L2TP、およびIPでカプセル化した後、そのLCCEピアへの使用可能なパスMTUに収まらない、リモートシステムからのLCCEに到着した場合、ローカルLCCEは上のIPv4断片化を行うことができますトンネルカプセル化の前にパケット。これは、各々がその関連するフレーミングとのIPv4断片を担持する、2つ（またはそれ以上）のL2TPパケットを作成します。再組み立ては、IPv4宛先ホストで発生しながら、最終的に、LCCE上の断片化の負担を配置する効果を有します。"
    },
    {
      "indent": 3,
      "text": "If an IPv6 packet arrives at an LCCE from a Remote System that, after encapsulation with associated framing, L2TP and IP, does not fit in the available path MTU towards its L2TP peer, the Generic Packet Tunneling specification [RFC2473], Section 7.1 SHOULD be followed. In this case, the LCCE should either send an ICMP Packet Too Big message to the data source, or fragment the resultant L2TP/IP packet (for reassembly by the L2TP peer).",
      "ja": "IPv6のパケットが関連するフレーミング、L2TPおよびIPと共にカプセル化した後、そのL2TPピア、ジェネリックパケットトンネリング仕様[RFC2473]に向けて可能なパスMTUに収まらない、リモートシステムからのLCCEに到着した場合は、7.1節はする必要があります続きます。この場合、LCCEは、データ・ソースにICMPパケット過大メッセージを送信すべきか、（L2TPピアによって再構成のために）、得られたL2TP / IPパケットをフラグメント。"
    },
    {
      "indent": 3,
      "text": "If the amount of traffic requiring fragmentation and reassembly is rather light, or there are sufficiently optimized mechanisms at the tunnel endpoints, fragmentation of the L2TP/IP packet may be sufficient for accommodating mismatched MTUs that cannot be managed by more efficient means. This method effectively emulates a larger MTU between tunnel endpoints and should work for any type of L2- encapsulated packet. Note that IPv6 does not support \"in-flight\" fragmentation of data packets. Thus, unlike IPv4, the MTU of the path towards an L2TP peer must be known in advance (or the last resort IPv6 minimum MTU of 1280 bytes utilized) so that IPv6 fragmentation may occur at the LCCE.",
      "ja": "フラグメンテーションと再組立を必要とするトラフィックの量がかなり軽い場合、または十分に最適化されたメカニズムは、トンネルエンドポイントであり、L2TP / IPパケットの断片化は、より効率的な手段によって管理することができない不一致のMTUを収容するのに十分であってもよいです。この方法は、効果的にトンネルエンドポイントとの間のより大きなMTUをエミュレートし、L2-カプセル化されたパケットの任意のタイプのために働くべきです。 IPv6がデータパケットの「飛行中の」断片化をサポートしていないことに注意してください。 IPv6の断片化がLCCEで起こり得るようにこのように、IPv4のとは異なり、L2TPピアに向かう経路のMTUは、事前に知られている（または最後に利用1280バイトのIPv6の最小MTU）されなければなりません。"
    },
    {
      "indent": 3,
      "text": "In summary, attempting to control the source MTU by communicating with the originating host, forcing that an MTU be sufficiently large on the path between LCCE peers to tunnel a frame from any other interface without fragmentation, fragmenting IP packets before encapsulation with L2TP/IP, or fragmenting the resultant L2TP/IP packet between the tunnel endpoints, are all valid methods for managing MTU mismatches. Some are clearly better than others depending on the given deployment. For example, a passive monitoring application using L2TP would certainly not wish to have ICMP messages sent to a traffic source. Further, if the links connecting a set of LCCEs have a very large MTU (e.g., SDH/SONET) and it is known that the MTU of all links being tunneled by L2TP have smaller MTUs (e.g., 1500 bytes), then any IP fragmentation and reassembly enabled on the participating LCCEs would never be utilized. An implementation MUST implement at least one of the methods described in this section for managing mismatched MTUs, based on careful consideration of how the final product will be deployed.",
      "ja": "要約すると、L2TP / IPでカプセル化する前に、IPパケットを断片化、MTUはトンネルにLCCEピアとの間の経路上に断片化することなく、他のインタフェースからフレーム十分に大きいことが強制的に、送信元ホストと通信することによりソースMTUを制御しようとしますまたはトンネルエンドポイント間の結果のL2TP / IPパケットを断片化、MTUの不一致を管理するためのすべての有効な方法があります。いくつかは明らかに与えられた展開に応じて、他のものよりも優れています。たとえば、L2TPを使用して、パッシブ監視アプリケーションは確かにトラフィックソースに送信されたICMPメッセージを持ってしたくないでしょう。さらに、LCCEsのセットを接続するリンクは、非常に大きなMTU（例えば、SDH / SONET）を有し、L2TPによってトンネリングされるすべてのリンクのMTUは、次に任意のIPフラグメンテーション、小さいMTUを（例えば、1500バイト）を有することが知られている場合そして、参加LCCEsの上で有効になって再組み立てを利用することはないだろう。実装は、最終製品が展開されるかを慎重に考慮して、不一致のMTUを管理するために、このセクションで説明する方法のうちの少なくとも1つを実装しなければなりません。"
    },
    {
      "indent": 3,
      "text": "L2TP-specific fragmentation and reassembly methods, which may or may not depend on the characteristics of the type of link being tunneled (e.g., judicious packing of ATM cells), may be defined as well, but these methods are outside the scope of this document.",
      "ja": "L2TP特異的断片化と再アセンブリ方法、またはリンクの種類の特性に依存してもしなくてもよいトンネリングされる（例えば、ATMセルの賢明なパッキング）、同様に定義され、これらの方法は、この文書の範囲外であることができます。"
    },
    {
      "indent": 0,
      "text": "4.2. Reliable Delivery of Control Messages",
      "section_title": true,
      "ja": "4.2。制御メッセージの信頼できる配信"
    },
    {
      "indent": 3,
      "text": "L2TP provides a lower level reliable delivery service for all control messages. The Nr and Ns fields of the control message header (see Section 3.2.1) belong to this delivery mechanism. The upper level functions of L2TP are not concerned with retransmission or ordering of control messages. The reliable control messaging mechanism is a sliding window mechanism that provides control message retransmission and congestion control. Each peer maintains separate sequence number state for each control connection.",
      "ja": "L2TPはすべてのコントロールメッセージのためのより低いレベルの信頼性の高い配信サービスを提供しています。制御メッセージヘッダのNRおよびNsのフィールド（セクション3.2.1を参照）、この配信メカニズムに属します。 L2TPの上位機能は、再送信または制御メッセージの順序に関係していません。信頼性のある制御メッセージング機構は制御メッセージの再送と輻輳制御を提供するスライディングウィンドウメカニズムです。各ピアは、各制御接続のための別個のシーケンス番号状態を維持します。"
    },
    {
      "indent": 3,
      "text": "The message sequence number, Ns, begins at 0. Each subsequent message is sent with the next increment of the sequence number. The sequence number is thus a free-running counter represented modulo 65536. The sequence number in the header of a received message is considered less than or equal to the last received number if its value lies in the range of the last received number and the preceding 32767 values, inclusive. For example, if the last received sequence number was 15, then messages with sequence numbers 0 through 15, as well as 32784 through 65535, would be considered less than or equal. Such a message would be considered a duplicate of a message already received and ignored from processing. However, in order to ensure that all messages are acknowledged properly (particularly in the case of a lost ACK message), receipt of duplicate messages MUST be acknowledged by the reliable delivery mechanism. This acknowledgment may either piggybacked on a message in queue or sent explicitly via an ACK message.",
      "ja": "メッセージシーケンス番号、Nsが、各後続メッセージは、シーケンス番号の次の増分を用いて送信される0から始まります。シーケンス番号は、このようにフリーランニングカウンタは、その値が最後に受信した番号の範囲及び先行内にある場合、受信したメッセージのヘッダ内のシーケンス番号が、最後に受信した数以下であると考えられるモジュロ65536表されます。 32767の値は、包括的。最後に受信したシーケンス番号が15である場合、例えば、そのシーケンス番号0〜15、ならびに〜65535 32784のメッセージは、以下であると考えられます。そのようなメッセージが既に処理から受信し、無視メッセージの重複であると考えられます。しかし、すべてのメッセージが（特に失われたACKメッセージの場合に）適切に認められていることを保証するために、重複したメッセージの受信は、信頼性の高い配信メカニズムによって承認されなければなりません。この承認には、いずれかのキュー内のメッセージにピギーバックまたはACKメッセージを介して明示的に送られたことがあります。"
    },
    {
      "indent": 3,
      "text": "All control messages take up one slot in the control message sequence number space, except the ACK message. Thus, Ns is not incremented after an ACK message is sent.",
      "ja": "すべての制御メッセージは、ACKメッセージを除いて、制御メッセージのシーケンス番号空間内の1つのスロットを取ります。 ACKメッセージが送信された後にこのように、Nsがインクリメントされません。"
    },
    {
      "indent": 3,
      "text": "The last received message number, Nr, is used to acknowledge messages received by an L2TP peer. It contains the sequence number of the message the peer expects to receive next (e.g., the last Ns of a non-ACK message received plus 1, modulo 65536). While the Nr in a received ACK message is used to flush messages from the local retransmit queue (see below), the Nr of the next message sent is not updated by the Ns of the ACK message. Nr SHOULD be sanity-checked before flushing the retransmit queue. For instance, if the Nr received in a control message is greater than the last Ns sent plus 1 modulo 65536, the control message is clearly invalid.",
      "ja": "最後に受信したメッセージの数、Nrが、L2TPピアによって受信されたメッセージを確認するために使用されます。これは、ピアが次受信することを期待するメッセージのシーケンス番号が含まれている（例えば、非ACKメッセージの最後のNsが、モジュロ65536を受けプラス1）。受信されたACKメッセージ中のNRは、（下記参照）は、ローカル再送キューからメッセージを消去するために使用されているが、送信された次のメッセージのNr個のACKメッセージのNsとによって更新されません。 Nrが再送信キューをフラッシュする前に正気-チェックする必要があります。 Nrは制御メッセージで受信した最後のNsが送らプラス1つのモジュロ65536よりも大きい場合例えば、制御メッセージは明らかに無効です。"
    },
    {
      "indent": 3,
      "text": "The reliable delivery mechanism at a receiving peer is responsible for making sure that control messages are delivered in order and without duplication to the upper level. Messages arriving out-of-order may be queued for in-order delivery when the missing messages are received. Alternatively, they may be discarded, thus requiring a retransmission by the peer. When dropping out-of-order control packets, Nr MAY be updated before the packet is discarded.",
      "ja": "受信ピアで信頼性の高い配信メカニズムは、制御メッセージは、上位レベルに順番にし、重複することなく配信されていることを確認する責任があります。不足しているメッセージを受信したときアウト・オブ・オーダー到着したメッセージは、順序どおりの配信のためにキューイングすることができます。あるいは、それらは、このようにピアによって再送を要求する、廃棄することができます。アウトオブオーダー制御パケットをドロップすると、パケットが破棄される前に、Nrが更新されてもよいです。"
    },
    {
      "indent": 3,
      "text": "Each control connection maintains a queue of control messages to be transmitted to its peer. The message at the front of the queue is sent with a given Ns value and is held until a control message arrives from the peer in which the Nr field indicates receipt of this message. After a period of time (a recommended default is 1 second but SHOULD be configurable) passes without acknowledgment, the message is retransmitted. The retransmitted message contains the same Ns value, but the Nr value MUST be updated with the sequence number of the next expected message.",
      "ja": "各制御接続は、そのピアに送信される制御メッセージのキューを維持します。キューの先頭にあるメッセージは、指定されたNsの値を用いて送信され、制御メッセージがNRフィールドは、このメッセージを受信したことを示しているピアから到着するまで保持されます。一定期間後（推奨デフォルトは1秒であるが、設定されます）メッセージが再送され、肯定応答なしで通過します。再送メッセージは同じNsの値が含まれていますが、Nrの値は、次に予想されるメッセージのシーケンス番号で更新する必要があります。"
    },
    {
      "indent": 3,
      "text": "Each subsequent retransmission of a message MUST employ an exponential backoff interval. Thus, if the first retransmission occurred after 1 second, the next retransmission should occur after 2 seconds has elapsed, then 4 seconds, etc. An implementation MAY place a cap upon the maximum interval between retransmissions. This cap SHOULD be no less than 8 seconds per retransmission. If no peer response is detected after several retransmissions (a recommended default is 10, but MUST be configurable), the control connection and all associated sessions MUST be cleared. As it is the first message to establish a control connection, the SCCRQ MAY employ a different retransmission maximum than other control messages in order to help facilitate failover to alternate LCCEs in a timely fashion.",
      "ja": "メッセージの後続の各再送信は、指数バックオフ間隔を採用しなければなりません。最初の再送信が1秒後に発生した場合にこのように、次の再送は2秒が経過した後、次に4秒などの実装は再送信間の最大間隔にキャップを配置することができる起こるべきです。このキャップは再送信ごとに8秒以上であってはなりません。何のピア・レスポンスが（推奨デフォルトは10ですが、構成可能でなければなりません）、いくつかの再送信の後に検出されない場合は、コントロール接続と関連付けられているすべてのセッションがクリアされなければなりません。それは制御接続を確立するための最初のメッセージであるので、SCCRQは、タイムリーに、代替のLCCEsへのフェイルオーバーを促進するのを助けるために、他の制御メッセージとは異なる再送最大値を採用することができます。"
    },
    {
      "indent": 3,
      "text": "When a control connection is being shut down for reasons other than loss of connectivity, the state and reliable delivery mechanisms MUST be maintained and operated for the full retransmission interval after the final message StopCCN message has been sent (e.g., 1 + 2 + 4 + 8 + 8... seconds), or until the StopCCN message itself has been acknowledged.",
      "ja": "制御接続は、接続性の損失以外の理由でシャットダウンされているとき、状態および信頼できる配信メカニズムを維持しStopCCNメッセージが送信された最終的なメッセージの後に、完全な再送信間隔のために操作しなければならない（例えば、1 + 2 + 4 + 8 + 8 ...秒）、またはStopCCNメッセージ自体が認識されているまで。"
    },
    {
      "indent": 3,
      "text": "A sliding window mechanism is used for control message transmission and retransmission. Consider two peers, A and B. Suppose A specifies a Receive Window Size AVP with a value of N in the SCCRQ or SCCRP message. B is now allowed to have a maximum of N outstanding (i.e., unacknowledged) control messages. Once N messages have been sent, B must wait for an acknowledgment from A that advances the window before sending new control messages. An implementation may advertise a non-zero receive window as small or as large as it wishes, depending on its own ability to process incoming messages before sending an acknowledgement. Each peer MUST limit the number of unacknowledged messages it will send before receiving an acknowledgement by this Receive Window Size. The actual internal unacknowledged message send-queue depth may be further limited by local resource allocation or by dynamic slow-start and congestion-avoidance mechanisms.",
      "ja": "スライディングウィンドウメカニズムは、制御メッセージの送信および再送信のために使用されます。つのピアを考慮し、AおよびBは、AがSCCRQ、またはSCCRPメッセージにおけるNの値に受信ウィンドウサイズのAVPを特定すると仮定する。 Bは今N非凡（すなわち、未確認の）制御メッセージの最大値を持つことが許されます。 Nメッセージが送信されると、Bは、新たな制御メッセージを送信する前に、ウィンドウを進め、Aからの確認応答を待たなければなりません。実装は、非ゼロの肯定応答を送信する前に、着信メッセージを処理するための独自の能力に依存し、それは望むほど小さな又は大きな窓を受け取るアドバタイズすることができます。各ピアは、この受信ウィンドウサイズによって確認応答を受信する前に送信されます未確認のメッセージの数を制限しなければなりません。実際の内部未確認のメッセージ送信キューの深さは、さらにローカルリソース割り当てによって、または動的スロースタートと輻輳回避メカニズムによって制限され得ます。"
    },
    {
      "indent": 3,
      "text": "When retransmitting control messages, a slow start and congestion avoidance window adjustment procedure SHOULD be utilized. A recommended procedure is described in Appendix A. A peer MAY drop messages, but MUST NOT actively delay acknowledgment of messages as a technique for flow control of control messages. Appendix B contains examples of control message transmission, acknowledgment, and retransmission.",
      "ja": "制御メッセージを再送信する場合、スロースタートと輻輳回避窓調整手順が利用すべきです。推奨される手順は、ピアがメッセージをドロップするかもしれ付録Aに記載されているが、積極的に制御メッセージのフロー制御のための技術として、メッセージの確認応答を遅らせるてはなりません。付録Bは、制御メッセージの送信、確認応答、および再送の例を含んでいます。"
    },
    {
      "indent": 0,
      "text": "4.3. Control Message Authentication",
      "section_title": true,
      "ja": "4.3。制御メッセージ認証"
    },
    {
      "indent": 3,
      "text": "L2TP incorporates an optional authentication and integrity check for all control messages. This mechanism consists of a computed one-way hash over the header and body of the L2TP control message, a pre-configured shared secret, and a local and remote nonce (random value) exchanged via the Control Message Authentication Nonce AVP. This per-message authentication and integrity check is designed to perform a mutual authentication between L2TP nodes, perform integrity checking of all control messages, and guard against control message spoofing and replay attacks that would otherwise be trivial to mount.",
      "ja": "L2TPはすべてのコントロールメッセージのためのオプションの認証と整合性チェックが組み込まれています。このメカニズムは、制御メッセージ認証ノンスAVPを介して交換L2TP制御メッセージ、事前構成された共有秘密、ローカルおよびリモートのナンス（ランダム値）のヘッダ及び本体にわたって計算一方向ハッシュから成ります。このメッセージごとの認証と整合性チェックがL2TPノード間の相互認証を実行するように設計され、すべての制御メッセージの整合性チェックを実行し、そうでない場合はマウントするのは簡単だろう制御メッセージのなりすましやリプレイ攻撃を防ぎます。"
    },
    {
      "indent": 3,
      "text": "At least one shared secret (password) MUST exist between communicating L2TP nodes to enable Control Message Authentication. See Section 5.4.3 for details on calculation of the Message Digest and construction of the Control Message Authentication Nonce and Message Digest AVPs.",
      "ja": "少なくとも一つの共有シークレット（パスワード）は、制御メッセージ認証を可能にするために、L2TPの通信ノードの間に存在しなければなりません。メッセージダイジェストの計算及び制御メッセージ認証ナンスとメッセージダイジェストのAVPの構築についての詳細は、5.4.3項を参照してください。"
    },
    {
      "indent": 3,
      "text": "L2TPv3 Control Message Authentication is similar to L2TPv2 [RFC2661] Tunnel Authentication in its use of a shared secret and one-way hash calculation. The principal difference is that, instead of computing the hash over selected contents of a received control message (e.g., the Challenge AVP and Message Type) as in L2TPv2, the entire message is used in the hash in L2TPv3. In addition, instead of including the hash digest in just the SCCRP and SCCCN messages, it is now included in all L2TP messages.",
      "ja": "L2TPv3のコントロールメッセージ認証は、共有される秘密の使用にL2TPv2 [RFC2661]トンネル認証と一方向ハッシュ計算に類似しています。主な違いは、代わりに、受信した制御メッセージの選択されたコンテンツ上のハッシュを計算する（例えば、チャレンジAVP及びメッセージタイプ）L2TPv2のように、メッセージ全体がL2TPv3の内のハッシュに使用される、ということです。また、代わりにハッシュがちょうどSCCRPとSCCCNメッセージダイジェストを含むの、それは今、すべてのL2TPメッセージに含まれています。"
    },
    {
      "indent": 3,
      "text": "The Control Message Authentication mechanism is optional, and may be disabled if both peers agree. For example, if IPsec is already being used for security and integrity checking between the LCCEs, the function of the L2TP mechanism becomes redundant and may be disabled.",
      "ja": "制御メッセージ認証メカニズムはオプションであり、両方のピアが同意する場合は無効にすることができます。 IPsecは既にセキュリティと整合性がLCCEsの間にチェックするために使用されている場合、例えば、L2TP機構の機能は、冗長となり、無効にすることができます。"
    },
    {
      "indent": 3,
      "text": "Presence of the Control Message Authentication Nonce AVP in an SCCRQ or SCCRP message serves as indication to a peer that Control Message Authentication is enabled. If an SCCRQ or SCCRP contains a Control Message Authentication Nonce AVP, the receiver of the message MUST respond with a Message Digest AVP in all subsequent messages sent. Control Message Authentication is always bidirectional; either both sides participate in authentication, or neither does.",
      "ja": "SCCRQ、またはSCCRPメッセージでコントロールメッセージ認証ノンスAVPの存在は、制御メッセージの認証が有効になっているピアへの指示として役立ちます。 SCCRQかSCCRPコントロールメッセージ認証ナンスAVPが含まれている場合は、メッセージの受信者は、送信された後続のすべてのメッセージにメッセージダイジェストAVPで応じなければなりません。制御メッセージ認証は常に双方向です。いずれかの両側には、認証に参加、またはどちらも行いません。"
    },
    {
      "indent": 3,
      "text": "If Control Message Authentication is disabled, the Message Digest AVP still MAY be sent as an integrity check of the message. The integrity check is calculated as in Section 5.4.3, with an empty zero-length shared secret, local nonce, and remote nonce. If an invalid Message Digest is received, it should be assumed that the message has been corrupted in transit and the message dropped accordingly.",
      "ja": "制御メッセージ認証が無効になっている場合は、メッセージダイジェストAVPは、まだメッセージの整合性チェックとして送信されても​​よいです。整合性チェックは、空のゼロ長共有秘密、ローカルナンス、およびリモートナンスと、セクション5.4.3のように計算されます。無効なメッセージダイジェストを受信した場合、メッセージが転送中に破損したメッセージがそれに応じてドロップされたと想定されるべきです。"
    },
    {
      "indent": 3,
      "text": "Implementations MAY rate-limit control messages, particularly SCCRQ messages, upon receipt for performance reasons or for protection against denial of service attacks.",
      "ja": "実装はレート制限MAY受信時の制御メッセージ、特にSCCRQメッセージを、パフォーマンス上の理由からか、サービス拒否攻撃に対する保護のために。"
    },
    {
      "indent": 0,
      "text": "4.4. Keepalive (Hello)",
      "section_title": true,
      "ja": "4.4。キープアライブ（こんにちは）"
    },
    {
      "indent": 3,
      "text": "L2TP employs a keepalive mechanism to detect loss of connectivity between a pair of LCCEs. This is accomplished by injecting Hello control messages (see Section 6.5) after a period of time has elapsed since the last data message or control message was received on an L2TP session or control connection, respectively. As with any other control message, if the Hello message is not reliably delivered, the sending LCCE declares that the control connection is down and resets its state for the control connection. This behavior ensures that a connectivity failure between the LCCEs is detected independently by each end of a control connection.",
      "ja": "L2TPは、LCCEsの対の間の接続の喪失を検出するためのキープアライブ機構を採用しています。これはハロー制御メッセージ（セクション6.5を参照）最後のデータメッセージまたは制御メッセージは、それぞれ、L2TPセッションまたは制御接続上で受信されてから一定期間が経過した後に注入することによって達成されます。 Helloメッセージが確実に配信されていない場合は、他の制御メッセージと同じように、送信LCCEはコントロール接続がダウンしていると制御接続のためにその状態をリセットすることを宣言します。この現象は、LCCEsの間の接続障害は、制御接続の各端部により独立して検出されることを保証します。"
    },
    {
      "indent": 3,
      "text": "Since the control channel is operated in-band with data traffic over the PSN, this single mechanism can be used to infer basic data connectivity between a pair of LCCEs for all sessions associated with the control connection.",
      "ja": "制御チャネルがPSN上のデータトラフィックと帯域内で動作するので、この単一の機構が制御接続に関連付けられているすべてのセッションのLCCEsの対の間の基本的なデータ接続を推論するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "Periodic keepalive for the control connection MUST be implemented by sending a Hello if a period of time (a recommended default is 60 seconds, but MUST be configurable) has passed without receiving any message (data or control) from the peer. An LCCE sending Hello messages across multiple control connections between the same LCCE endpoints MUST employ a jittered timer mechanism to prevent grouping of Hello messages.",
      "ja": "制御接続のための周期的なキープアライブ期間（推奨デフォルトは60秒であるが、構成可能でなければならない）ピアからのすべてのメッセージ（データまたは制御）を受信することなく経過した場合にハローを送信することによって実現されなければなりません。同じLCCEのエンドポイント間の複数の制御接続間のHelloメッセージを送るLCCEは、Helloメッセージのグループ化を防止するためのジッタタイマーメカニズムを使わなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.5. Forwarding Session Data Frames",
      "section_title": true,
      "ja": "4.5。セッションデータフレームを転送"
    },
    {
      "indent": 3,
      "text": "Once session establishment is complete, circuit frames are received at an LCCE, encapsulated in L2TP (with appropriate attention to framing, as described in documents for the particular pseudowire type), and forwarded over the appropriate session. For every outgoing data message, the sender places the identifier specified in the Local Session ID AVP (received from peer during session establishment) in the Session ID field of the L2TP data header. In this manner, session frames are multiplexed and demultiplexed between a given pair of LCCEs. Multiple control connections may exist between a given pair of LCCEs, and multiple sessions may be associated with a given control connection.",
      "ja": "セッション確立が完了すると、回路フレームは、LCCEで受信される（特定の疑似回線タイプの文書に記載されているように、フレーミングに適切な注意を払って）L2TPでカプセル化され、そして適切なセッションを介して転送されます。すべての発信データメッセージのために、送信者は、L2TPデータヘッダのセッションIDフィールドにローカルセッションID AVP（セッション確立中にピアから受信した）で指定された識別子を配置します。このように、セッションフレームはLCCEsの所与の対の間で多重化および逆多重化されます。複数の制御接続がLCCEsの所与の対の間に存在してもよいし、複数のセッションは、所定の制御接続に関連付けられてもよいです。"
    },
    {
      "indent": 3,
      "text": "The peer LCCE receiving the L2TP data packet identifies the session with which the packet is associated by the Session ID in the data packet's header. The LCCE then checks the Cookie field in the data packet against the Cookie value received in the Assigned Cookie AVP during session establishment. It is important for implementers to note that the Cookie field check occurs after looking up the session context by the Session ID, and as such, consists merely of a value match of the Cookie field and that stored in the retrieved context. There is no need to perform a lookup across the Session ID and Cookie as a single value. Any received data packets that contain invalid Session IDs or associated Cookie values MUST be dropped. Finally, the LCCE either forwards the network packet within the tunneled frame (e.g., as an LNS) or switches the frame to a circuit (e.g., as an LAC).",
      "ja": "L2TPデータパケットを受信したピアLCCEは、パケットは、データパケットのヘッダのセッションIDによって関連付けられているセッションを識別する。 LCCEは、セッション確立時に割り当てられたクッキーAVPで受信されたクッキー値に対するデータパケットにクッキーフィールドをチェックします。これは、実装者は、クッキーフィールドのチェックは、セッションIDによってセッションコンテキストを検索した後に発生することに留意することが重要であり、そのようなものとして、単に、検索コンテキストに格納されている値のクッキーフィールドの一致とその構成されています。単一の値としてセッションIDとクッキー間でルックアップを実行する必要はありません。いずれかがドロップされなければならない無効なセッションIDまたは関連するクッキー値を含むデータパケットを受信しました。最後に、LCCEは、トンネルフレーム（例えば、LNSのような）内のネットワークパケットを転送するか、（例えば、LACなど）回路にフレームをスイッチのいずれか。"
    },
    {
      "indent": 0,
      "text": "4.6. Default L2-Specific Sublayer",
      "section_title": true,
      "ja": "4.6。デフォルトのL2特有の副層"
    },
    {
      "indent": 3,
      "text": "This document defines a Default L2-Specific Sublayer format (see Section 3.2.2) that a pseudowire may use for features such as sequencing support, L2 interworking, OAM, or other per-data-packet operations. The Default L2-Specific Sublayer SHOULD be used by a given PW type to support these features if it is adequate, and its presence is requested by a peer during session negotiation. Alternative sublayers MAY be defined (e.g., an encapsulation with a larger Sequence Number field or timing information) and identified for use via the L2-Specific Sublayer Type AVP.",
      "ja": "この文書では、疑似回線は、配列決定サポート、L2インターワーキング、OAM、または他の単位のデータパケットの操作などの機能のために使用することが既定L2特有のSublayer形式（セクション3.2.2を参照）を定義します。デフォルトL2特有のサブレイヤは、それが適切であれば、これらの機能をサポートするために与えられたPWタイプによって使用されるべきであり、その存在は、セッションネゴシエーション中にピアによって要求されています。代替副層（例えば、より大きなシーケンス番号フィールドを有するカプセルまたはタイミング情報）に定義され、L2特有のSublayerタイプAVPを介して使用するために識別することができます。"
    },
    {
      "indent": 14,
      "text": "Figure 4.6: Default L2-Specific Sublayer Format",
      "ja": "図4.6：デフォルトのL2特有のSublayerフォーマット"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|x|S|x|x|x|x|x|x|              Sequence Number                  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The S (Sequence) bit is set to 1 when the Sequence Number contains a valid number for this sequenced frame. If the S bit is set to zero, the Sequence Number contents are undefined and MUST be ignored by the receiver.",
      "ja": "シーケンス番号は、この配列決定フレームの有効な番号が含まれている場合S（シーケンス）ビットが1に設定されています。 Sビットがゼロに設定されている場合、シーケンス番号の内容は不定であり、受信機で無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The Sequence Number field contains a free-running counter of 2^24 sequence numbers. If the number in this field is valid, the S bit MUST be set to 1. The Sequence Number begins at zero, which is a valid sequence number. (In this way, implementations inserting sequence numbers do not have to \"skip\" zero when incrementing.) The sequence number in the header of a received message is considered less than or equal to the last received number if its value lies in the range of the last received number and the preceding (2^23-1) values, inclusive.",
      "ja": "シーケンス番号フィールドは、2 ^ 24シーケンス番号のフリーランニングカウンタが含まれています。この分野の番号が有効であれば、Sビットを1に設定しなければならないシーケンス番号は、有効なシーケンス番号である、ゼロから始まります。 （このように、シーケンス番号を挿入実装がインクリメントするときゼロを「スキップ」する必要はない。）受信したメッセージのヘッダ内のシーケンス番号が最後に受信した数以下であると考えられる、その値の範囲内にある場合最後に受信番号と先行（2 ^ 23-1）の値、包括。"
    },
    {
      "indent": 0,
      "text": "4.6.1. Sequencing Data Packets",
      "section_title": true,
      "ja": "4.6.1。シーケンシングデータパケット"
    },
    {
      "indent": 3,
      "text": "The Sequence Number field may be used to detect lost, duplicate, or out-of-order packets within a given session.",
      "ja": "シーケンス番号フィールドは、特定のセッション内で、または、アウトオブオーダーのパケットを、失われた検出複製するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "When L2 frames are carried over an L2TP-over-IP or L2TP-over-UDP/IP data channel, this part of the link has the characteristic of being able to reorder, duplicate, or silently drop packets. Reordering may break some non-IP protocols or L2 control traffic being carried by the link. Silent dropping or duplication of packets may break protocols that assume per-packet indications of error, such as TCP header compression. While a common mechanism for packet sequence detection is provided, the sequence dependency characteristics of individual protocols are outside the scope of this document.",
      "ja": "L2フレームがL2TPオーバーIPまたはL2TPオーバーUDP / IPデータチャネルを介して搬送されるときに、リンクのこの部分は、並べ替え、複製、または静かにパケットをドロップすることができるという特性を有しています。並べ替えは、いくつかの非IPプロトコルを破損したりL2制御トラフィックはリンクによって運ばれています。パケットのサイレントドロップまたは複製は、TCPヘッダー圧縮などのエラーのパケットごとの表示を、想定プロトコルを破ることができます。パケットシーケンス検出のための共通の機構が設けられているが、個々のプロトコルのシーケンス依存性は、この文書の範囲外です。"
    },
    {
      "indent": 3,
      "text": "If any protocol being transported by over L2TP data channels cannot tolerate misordering of data packets, packet duplication, or silent packet loss, sequencing may be enabled on some or all packets by using the S bit and Sequence Number field defined in the Default L2- Specific Sublayer (see Section 4.6). For a given L2TP session, each LCCE is responsible for communicating to its peer the level of sequencing support that it requires of data packets that it receives. Mechanisms to advertise this information during session negotiation are provided (see Data Sequencing AVP in Section 5.4.4).",
      "ja": "任意のプロトコルは、データパケットの誤った順序、パケットの複製、またはサイレントパケットロスを許容できないL2TPデータチャネルを介しによって輸送される場合、配列決定は、デフォルトで定義されたSビットとシーケンス番号フィールドを使用して一部またはすべてのパケット上で有効にされてもよいL2-特異サブレイヤ（4.6節を参照してください）。所与のL2TPセッションのために、各LCCEは、それが受信したデータパケットの必要とすることをそのピアに配列決定サポートのレベルを通信するための責任があります。セッションネゴシエーション中にこの情報を広告するメカニズムは、（5.4.4項でのデータシーケンスAVPを参照）が設けられています。"
    },
    {
      "indent": 3,
      "text": "When determining whether a packet is in or out of sequence, an implementation SHOULD utilize a method that is resilient to temporary dropouts in connectivity coupled with high per-session packet rates. The recommended method is outlined in Appendix C.",
      "ja": "パケットがシーケンスの中又は外にあるかどうかを決定する際に、実装が高いセッションごとのパケットレートとカップリング接続の一時的なドロップアウトに弾力性がある方法を利用すべきです。推奨される方法は、付録Cに概説されています。"
    },
    {
      "indent": 0,
      "text": "4.7. L2TPv2/v3 Interoperability and Migration",
      "section_title": true,
      "ja": "4.7。 L2TPv2 / v3の相互運用性と移行"
    },
    {
      "indent": 3,
      "text": "L2TPv2 and L2TPv3 environments should be able to coexist while a migration to L2TPv3 is made. Migration issues are discussed for each media type in this section. Most issues apply only to implementations that require both L2TPv2 and L2TPv3 operation.",
      "ja": "L2TPv2とL2TPv3の環境はのL2TPv3への移行が行われている間に共存することができなければなりません。移行の問題は、このセクションの各メディアタイプについて議論されています。ほとんどの問題は、L2TPv2とL2TPv3の動作の両方を必要とする実装にのみ適用されます。"
    },
    {
      "indent": 3,
      "text": "However, even L2TPv3-only implementations must at least be mindful of these issues in order to interoperate with implementations that support both versions.",
      "ja": "しかし、L2TPv3の専用の実装は、少なくとも両方のバージョンをサポートする実装と相互運用するためには、これらの問題に留意する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.7.1. L2TPv3 over IP",
      "section_title": true,
      "ja": "4.7.1。 IP上のL2TPv3"
    },
    {
      "indent": 3,
      "text": "L2TPv3 implementations running strictly over IP with no desire to interoperate with L2TPv2 implementations may safely disregard most migration issues from L2TPv2. All control messages and data messages are sent as described in this document, without normative reference to RFC 2661.",
      "ja": "L2TPv2の実装と相互運用するための欲求をIP上で厳密に実行されているのL2TPv3実装は安全にL2TPv2からのほとんどの移行の問題を無視することがあります。 RFC 2661に規定参照することなく、この文書で説明するように、すべての制御メッセージとデータメッセージが送信されます。"
    },
    {
      "indent": 3,
      "text": "If one wishes to tunnel PPP over L2TPv3, and fallback to L2TPv2 only if it is not available, then L2TPv3 over UDP with automatic fallback (see Section 4.7.3) MUST be used. There is no deterministic method for automatic fallback from L2TPv3 over IP to either L2TPv2 or L2TPv3 over UDP. One could infer whether L2TPv3 over IP is supported by sending an SCCRQ and waiting for a response, but this could be problematic during periods of packet loss between L2TP nodes.",
      "ja": "一つはL2TPv3の上にトンネルPPPしたい、それが利用可能でない場合にのみ、L2TPv2にフォールバックした場合、自動フォールバックとUDP上のL2TPv3（セクション4.7.3を参照）を使用しなければなりません。 UDPオーバーIP上のL2TPv3からL2TPv2かL2TPv3のどちらかへの自動フォールバックのための決定論的方法ではありません。一つは、IP上のL2TPv3がSCCRQを送信し、応答を待つことによってサポートされているかどうかを推測できたが、これはL2TPノード間のパケットロスの期間中に問題となる可能性があります。"
    },
    {
      "indent": 0,
      "text": "4.7.2. L2TPv3 over UDP",
      "section_title": true,
      "ja": "4.7.2。 UDP上のL2TPv3"
    },
    {
      "indent": 3,
      "text": "The format of the L2TPv3 over UDP header is defined in Section 4.1.2.1.",
      "ja": "UDPヘッダ上のL2TPv3のフォーマットはセクション4.1.2.1で定義されています。"
    },
    {
      "indent": 3,
      "text": "When operating over UDP, L2TPv3 uses the same port (1701) as L2TPv2 and shares the first two octets of header format with L2TPv2. The Ver field is used to distinguish L2TPv2 packets from L2TPv3 packets. If an implementation is capable of operating in L2TPv2 or L2TPv3 modes, it is possible to automatically detect whether a peer can support L2TPv2 or L2TPv3 and operate accordingly. The details of this fallback capability is defined in the following section.",
      "ja": "UDP上で動作するとき、L2TPv3のは、L2TPv2と同じポート（1701）を使用し、L2TPv2とヘッダフォーマットの最初の2つのオクテットを共有します。 Ver分野は、L2TPv3のパケットからL2TPv2パケットを区別するために使用されます。実装がL2TPv2またはL2TPv3のモードで動作することが可能である場合、自動的にピアがL2TPv2またはL2TPv3のをサポートし、それに応じて動作することができるかどうかを検出することができます。このフォールバック機能の詳細は、次のセクションで定義されています。"
    },
    {
      "indent": 0,
      "text": "4.7.3. Automatic L2TPv2 Fallback",
      "section_title": true,
      "ja": "4.7.3。自動L2TPv2フォールバック"
    },
    {
      "indent": 3,
      "text": "When running over UDP, an implementation may detect whether a peer is L2TPv3-capable by sending a special SCCRQ that is properly formatted for both L2TPv2 and L2TPv3. This is accomplished by sending an SCCRQ with its Ver field set to 2 (for L2TPv2), and ensuring that any L2TPv3-specific AVPs (i.e., AVPs present within this document and not defined within RFC 2661) in the message are sent with each M bit set to 0, and that all L2TPv2 AVPs are present as they would be for L2TPv2. This is done so that L2TPv3 AVPs will be ignored by an L2TPv2-only implementation. Note that, in both L2TPv2 and L2TPv3, the value contained in the space of the control message header utilized by the 32-bit Control Connection ID in L2TPv3, and the 16- bit Tunnel ID and",
      "ja": "UDP上で実行している場合、実装は、ピアが適切L2TPv2とL2TPv3の両方のためにフォーマットされた特別なSCCRQを送ることによってL2TPv3の対応であるかどうかを検出することができます。これは、メッセージ内の（この文書内に存在し、RFC 2661内に定義されていない、すなわち、のAVP）はそれぞれMで送信される（L2TPv2用）2へのVer分野セットでSCCRQを送信し、そして任意のL2TPv3特有のAVPことを保証することによって達成されます。ビットが0に設定され、すべてのL2TPv2ののAVPが存在していることを、彼らはL2TPv2のためになるよう。 L2TPv3のAVPのは、L2TPv2のみの実装によって無視されるように行われます。なお、L2TPv2とL2TPv3の、L2TPv3の32ビット制御コネクションIDによって利用される制御メッセージのヘッダの空間に含まれる値、及び16ビットのトンネルIDの両方にと"
    },
    {
      "indent": 3,
      "text": "16-bit Session ID in L2TPv2, are always 0 for an SCCRQ. This effectively hides the fact that there are a pair of 16-bit fields in L2TPv2, and a single 32-bit field in L2TPv3.",
      "ja": "L2TPv2で16ビットのセッションIDは、SCCRQのためには常に0です。これは、効果的にL2TPv2で16ビットフィールドのペア、および1つの32ビットのフィールドは、L2TPv3の中に存在するという事実を隠し。"
    },
    {
      "indent": 3,
      "text": "If the peer implementation is L2TPv3-capable, a control message with the Ver field set to 3 and an L2TPv3 header and message format will be sent in response to the SCCRQ. Operation may then continue as L2TPv3. If a message is received with the Ver field set to 2, it must be assumed that the peer implementation is L2TPv2-only, thus enabling fallback to L2TPv2 mode to safely occur.",
      "ja": "ピア実装がL2TPv3の対応であれば、3版フィールドセットとのL2TPv3ヘッダとメッセージフォーマットを有する制御メッセージはSCCRQに応答して送信されます。次に、動作はL2TPv3のよう継続してもよいです。メッセージが2に設定Ver分野で受信された場合、このように安全に発生するL2TPv2モードへのフォールバックを可能にする、ピア実装がL2TPv2専用であると仮定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Note Well: The L2TPv2/v3 auto-detection mode requires that all L2TPv3 implementations over UDP be liberal in accepting an SCCRQ control message with the Ver field set to 2 or 3 and the presence of L2TPv2- specific AVPs. An L2TPv3-only implementation MUST ignore all L2TPv2 AVPs (e.g., those defined in RFC 2661 and not in this document) within an SCCRQ with the Ver field set to 2 (even if the M bit is set on the L2TPv2-specific AVPs).",
      "ja": "さて注：L2TPv2 / V3自動検出モードはUDP上のすべてのL2TPv3実装が2又は3に設定版フィールドとSCCRQ制御メッセージとL2TPv2-特定のAVPの存在を受け入れるにリベラルであることを必要とします。 L2TPv3の専用の実装では、（MビットがL2TPv2特有のAVPに設定されている場合でも）2版フィールドが設定されているSCCRQ内のすべてのL2TPv2のAVP（例えば、RFC 2661ではなく、本文書で定義されたもの）を無視しなければなりません。"
    },
    {
      "indent": 0,
      "text": "5. Control Message Attribute Value Pairs",
      "section_title": true,
      "ja": "5.制御メッセージは、値のペアの属性"
    },
    {
      "indent": 3,
      "text": "To maximize extensibility while permitting interoperability, a uniform method for encoding message types is used throughout L2TP. This encoding will be termed AVP (Attribute Value Pair) for the remainder of this document.",
      "ja": "相互運用性を可能にしながら、拡張性を最大化するために、メッセージタイプを符号化するための統一された方法は、L2TP全体で使用されています。この符号化は、この文書の残りのAVP（属性値対）と呼ぶことにします。"
    },
    {
      "indent": 0,
      "text": "5.1. AVP Format",
      "section_title": true,
      "ja": "5.1。 AVPフォーマット"
    },
    {
      "indent": 3,
      "text": "Each AVP is encoded as follows:",
      "ja": "次のように各AVPが符号化されます。"
    },
    {
      "indent": 26,
      "text": "Figure 5.1: AVP Format",
      "ja": "図5.1：AVPフォーマット"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|M|H| rsvd  |      Length       |           Vendor ID           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|         Attribute Type        |        Attribute Value ...\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                    (until Length is reached)                   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The first six bits comprise a bit mask that describes the general attributes of the AVP. Two bits are defined in this document; the remaining bits are reserved for future extensions. Reserved bits MUST be set to 0 when sent and ignored upon receipt.",
      "ja": "最初の6ビットは、AVPの一般的な属性を記述するビットマスクを含みます。 2つのビットは、この文書で定義されています。残りのビットは将来の拡張のために予約されています。送信および受信時に無視されたときに予約済みビットを0に設定しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Mandatory (M) bit: Controls the behavior required of an implementation that receives an unrecognized AVP. The M bit of a given AVP MUST only be inspected and acted upon if the AVP is unrecognized (see Section 5.2).",
      "ja": "必須（M）ビット：認識されていないAVPを受信する実装に必要な動作を制御します。与えられたAVPのMビットのみを検査し、AVPが認識されない場合には（セクション5.2を参照）に作用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Hidden (H) bit: Identifies the hiding of data in the Attribute Value field of an AVP. This capability can be used to avoid the passing of sensitive data, such as user passwords, as cleartext in an AVP. Section 5.3 describes the procedure for performing AVP hiding.",
      "ja": "隠された（H）ビット：AVPの属性値フィールドのデータの隠蔽を識別します。この機能は、AVPでクリアテキストとして、そのようなユーザパスワードなどの機密データの受け渡しを回避するために使用することができます。 5.3節はAVP隠れることを実行するための手順を説明します。"
    },
    {
      "indent": 3,
      "text": "Length: Contains the number of octets (including the Overall Length and bit mask fields) contained in this AVP. The Length may be calculated as 6 + the length of the Attribute Value field in octets.",
      "ja": "長さ：このAVPに含まれている（全体長さとビットマスクフィールドを含む）のオクテットの数が含まれています。長さは、6 +としてオクテットの属性値フィールドの長さを計算することができます。"
    },
    {
      "indent": 3,
      "text": "The field itself is 10 bits, permitting a maximum of 1023 octets of data in a single AVP. The minimum Length of an AVP is 6. If the Length is 6, then the Attribute Value field is absent.",
      "ja": "フィールド自体は、単一のAVPデータ1023オクテットの最大を可能に、10ビットです。長さが6である場合にAVPの最小の長さは、次に、属性値フィールドが存在しない、6です。"
    },
    {
      "indent": 3,
      "text": "Vendor ID: The IANA-assigned \"SMI Network Management Private Enterprise Codes\" [RFC1700] value. The value 0, corresponding to IETF-adopted attribute values, is used for all AVPs defined within this document. Any vendor wishing to implement its own L2TP extensions can use its own Vendor ID along with private Attribute values, guaranteeing that they will not collide with any other vendor's extensions or future IETF extensions. Note that there are 16 bits allocated for the Vendor ID, thus limiting this feature to the first 65,535 enterprises.",
      "ja": "ベンダーID：IANAによって割り当てられた「SMIネットワークマネージメント私企業コード」[RFC1700]の値。 IETF-採用した属性値に対応する値0は、このドキュメント内で定義されたすべてのAVPのために使用されます。独自のL2TP拡張子を実装したい任意のベンダーは、彼らが他のベンダーの拡張や将来のIETFの拡張と衝突しないことを保証し、民間の属性値と一緒に、独自のベンダーIDを使用することができます。こうして第65,535企業にこの機能を制限し、ベンダーIDのために割り当てられた16ビットがあることに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "Attribute Type: A 2-octet value with a unique interpretation across all AVPs defined under a given Vendor ID.",
      "ja": "属性タイプ：与えられたベンダーIDの下で定義されたすべてのAVP全体でユニークな解釈と2オクテット値。"
    },
    {
      "indent": 3,
      "text": "Attribute Value: This is the actual value as indicated by the Vendor ID and Attribute Type. It follows immediately after the Attribute Type field and runs for the remaining octets indicated in the Length (i.e., Length minus 6 octets of header). This field is absent if the Length is 6.",
      "ja": "値属性：これは、ベンダーID及び属性タイプによって示されるように、実際の値です。これは、属性タイプフィールドの直後に続き、長さ（すなわち、長さマイナスヘッダの6つのオクテット）に示されている残りのオクテットのために実行されます。長さが6である場合、このフィールドは存在しません。"
    },
    {
      "indent": 3,
      "text": "In the event that the 16-bit Vendor ID space is exhausted, vendor-specific AVPs with a 32-bit Vendor ID MUST be encapsulated in the following manner:",
      "ja": "16ビットのベンダIDスペースが使い果たされた場合に、32ビットのベンダーIDとベンダー固有のAVPは、以下のようにカプセル化されなければなりません。"
    },
    {
      "indent": 17,
      "text": "Figure 5.2: Extended Vendor ID AVP Format",
      "ja": "図5.2：拡張ベンダーID AVPのフォーマット"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|M|H| rsvd  |      Length       |               0               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|              58               |       32-bit Vendor ID     ...\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                                |        Attribute Type         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      Attribute Value                       ...\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                 (until Length is reached)                      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "This AVP encodes a vendor-specific AVP with a 32-bit Vendor ID space within the Attribute Value field. Multiple AVPs of this type may exist in any message. The 16-bit Vendor ID MUST be 0, indicating that this is an IETF-defined AVP, and the Attribute Type MUST be 58, indicating that what follows is a vendor-specific AVP with a 32-bit Vendor ID code. This AVP MAY be hidden (the H bit MAY be 0 or 1). The M bit for this AVP MUST be set to 0. The Length of the AVP is 12 plus the length of the Attribute Value.",
      "ja": "このAVPは、属性値フィールド内の32ビットベンダID空間を持つベンダー固有AVPをコードします。このタイプの複数のAVPは、任意のメッセージで存在してもよいです。 16ビットのベンダIDは、これはIETF定義AVPであり、属性タイプは何以下は32ビットベンダIDコードとベンダー固有AVPであることを示し、58である必要があることを示す、0でなければなりません。このAVPは、（Hビットが0または1でもよい）隠すことができます。このAVPのためのMビットは、AVPの長さは12プラス属性値の長さを0に設定しなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.2. Mandatory AVPs and Setting the M Bit",
      "section_title": true,
      "ja": "5.2。必須のAVPとMビットをセット"
    },
    {
      "indent": 3,
      "text": "If the M bit is set on an AVP that is unrecognized by its recipient, the session or control connection associated with the control message containing the AVP MUST be shut down. If the control message containing the unrecognized AVP is associated with a session (e.g., an ICRQ, ICRP, ICCN, SLI, etc.), then the session MUST be issued a CDN with a Result Code of 2 and Error Code of 8 (as defined in Section 5.4.2) and shut down. If the control message containing the unrecognized AVP is associated with establishment or maintenance of a Control Connection (e.g., SCCRQ, SCCRP, SCCCN, Hello), then the associated Control Connection MUST be issued a StopCCN with Result Code of 2 and Error Code of 8 (as defined in Section 5.4.2) and shut down. If the M bit is not set on an unrecognized AVP, the AVP MUST be ignored when received, processing the control message as if the AVP were not present.",
      "ja": "Mビットは、その受信者によって認識されないAVPに設定されている場合、AVPを含む制御メッセージに関連付けられたセッションまたは制御接続を停止しなければなりません。認識されていないAVPを含む制御メッセージをセッション（例えば、ICRQ、ICRP、ICCN、SLIなど）に関連付けられている場合、セッションは2の結果コードでCDNを発行し、（8としてのエラーコードされなければなりません5.4.2項で定義される）、シャットダウン。認識されていないAVPを含む制御メッセージが制御接続の確立または維持（例えば、SCCRQ、SCCRP、SCCCN、こんにちは）に関連付けられている場合、関連する制御接続は、2の結果コードでStopCCNを発行し、8のエラーコードされなければなりません（セクション5.4.2で定義されるように）、シャットダウン。 Mビットが認識されていないAVPに設定されていない場合、受信時AVPが存在しないかのように、AVPは、制御メッセージを処理し、無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Receipt of an unrecognized AVP that has the M bit set is catastrophic to the session or control connection with which it is associated. Thus, the M bit should only be set for AVPs that are deemed crucial to proper operation of the session or control connection by the sender. AVPs that are considered crucial by the sender may vary by application and configured options. In no case shall a receiver of an AVP \"validate\" if the M bit is set on a recognized AVP. If the AVP is recognized (as all AVPs defined in this document MUST be for a compliant L2TPv3 specification), then by definition, the M bit is of no consequence.",
      "ja": "Mビットが設定されている認識されていないAVPの領収書は、それが関連付けられているセッションまたは制御接続に致命的です。これにより、Mビットは、送信者によってセッションまたは制御接続の適切な動作にとって重要と考えられるのAVPに設定されるべきです。送信者によって重要であると考えられているのAVPは、アプリケーションと設定されたオプションによって異なる場合があります。いかなる場合にAVPの受信機は、Mビットが認識AVPに設定されている場合、「検証」しなければなりません。 （本書で定義されたすべてのAVP準拠のL2TPv3仕様のなければならないので）AVPが認識された場合、定義により、Mビットがない結果です。"
    },
    {
      "indent": 3,
      "text": "The sender of an AVP is free to set its M bit to 1 or 0 based on whether the configured application strictly requires the value contained in the AVP to be recognized or not. For example, \"Automatic L2TPv2 Fallback\" in Section 4.7.3 requires the setting of the M bit on all new L2TPv3 AVPs to zero if fallback to L2TPv2 is supported and desired, and 1 if not.",
      "ja": "AVPの送信者は、設定されたアプリケーションが厳密に認識か否するAVPに含まれる値を必要とするかどうかに基づいて、1または0へのMビットを設定して自由です。例えば、「自動L2TPv2フォールバック」のセクション4.7.3でL2TPv2にフォールバックする場合は、ゼロにすべての新規のL2TPv3のAVPのMビットの設定が必要ない場合は、サポートと希望、そして1されます。"
    },
    {
      "indent": 3,
      "text": "The M bit is useful as extra assurance for support of critical AVP extensions. However, more explicit methods may be available to determine support for a given feature rather than using the M bit alone. For example, if a new AVP is defined in a message for which there is always a message reply (i.e., an ICRQ, ICRP, SCCRQ, or SCCRP message), rather than simply sending an AVP in the message with the M bit set, availability of the extension may be identified by sending an AVP in the request message and expecting a corresponding AVP in a reply message. This more explicit method, when possible, is preferred.",
      "ja": "Mビットは重要なAVPの拡張機能をサポートするための追加の保証として有用です。しかし、より明示的な方法は、単独でMビットを使用するのではなく、所定の機能に対するサポートを決定するために利用可能であってもよいです。例えば、新たなAVPは、メッセージ応答（すなわち、ICRQ、ICRP、SCCRQ、またはSCCRPメッセージ）が常に存在しているため、メッセージに定義されている場合ではなく、単にMビットセットとメッセージにAVPを送信し、拡張の可用性は、要求メッセージ内のAVPを送信し、応答メッセージに対応するAVPを期待することによって同定することができます。このより明示的な方法は、可能な場合に、好ましいです。"
    },
    {
      "indent": 3,
      "text": "The M bit also plays a role in determining whether or not a malformed or out-of-range value within an AVP should be ignored or should result in termination of a session or control connection (see Section 7.1 for more details).",
      "ja": "MビットもAVP内奇形または範囲外の値が（詳細はセクション7.1を参照）は無視されるべきか、セッションまたは制御接続の終了をもたらすかどうかを決定する上で役割を果たしています。"
    },
    {
      "indent": 0,
      "text": "5.3. Hiding of AVP Attribute Values",
      "section_title": true,
      "ja": "5.3。 AVP属性値の非表示"
    },
    {
      "indent": 3,
      "text": "The H bit in the header of each AVP provides a mechanism to indicate to the receiving peer whether the contents of the AVP are hidden or present in cleartext. This feature can be used to hide sensitive control message data such as user passwords, IDs, or other vital information.",
      "ja": "各AVPのヘッダ内のHビットは、AVPの内容が隠された又は平文で存在しているかどうかを受信ピアに示すためのメカニズムを提供します。この機能は、ユーザのパスワード、IDを、または他の重要な情報などの機密制御メッセージデータを隠すために使用することができます。"
    },
    {
      "indent": 3,
      "text": "The H bit MUST only be set if (1) a shared secret exists between the LCCEs and (2) Control Message Authentication is enabled (see Section 4.3). If the H bit is set in any AVP(s) in a given control message, at least one Random Vector AVP must also be present in the message and MUST precede the first AVP having an H bit of 1.",
      "ja": "Hビット（4.3節を参照のこと）（1）共有秘密がLCCEsの間に存在する場合にのみ設定されなければならない、（2）制御メッセージの認証が有効になっています。 Hビットが与えられた制御メッセージ内の任意のAVP（複数可）に設定されている場合、少なくとも一つのランダムベクトルAVPは、メッセージ中に存在しなければならず、1のHビットを有する第一のAVPに先行しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The shared secret between LCCEs is used to derive a unique shared key for hiding and unhiding calculations. The derived shared key is obtained via an HMAC-MD5 keyed hash [RFC2104], with the key consisting of the shared secret, and with the data being hashed consisting of a single octet containing the value 1.",
      "ja": "LCCEsの間の共有秘密を隠し、非表示解除の計算のためのユニークな共有キーを導出するために使用されます。誘導された共有鍵は、共有秘密からなる鍵と、値1を含む単一オクテットからなるハッシュ化されたデータと、HMAC-MD5鍵付きハッシュ[RFC2104]を介して得られます。"
    },
    {
      "indent": 9,
      "text": "shared_key = HMAC_MD5 (shared_secret, 1)",
      "ja": "shared_key = HMAC_MD5（shared_secret、1）"
    },
    {
      "indent": 3,
      "text": "Hiding an AVP value is done in several steps. The first step is to take the length and value fields of the original (cleartext) AVP and encode them into the Hidden AVP Subformat, which appears as follows:",
      "ja": "AVP値を非表示にすることは、いくつかのステップで行われます。最初のステップは、次のように表示される隠しAVP Subformatで、にそれらを元の（平文）AVPの長さおよび値フィールドを取り、符号化することです。"
    },
    {
      "indent": 21,
      "text": "Figure 5.3: Hidden AVP Subformat",
      "ja": "図5.3：隠しAVP Subformatで"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Length of Original Value    |   Original Attribute Value ...\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n               ...              |             Padding ...\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Length of Original Attribute Value: This is length of the Original Attribute Value to be obscured in octets. This is necessary to determine the original length of the Attribute Value that is lost when the additional Padding is added.",
      "ja": "オリジナル属性値の長さ：これは、オクテットで隠されるオリジナル属性値の長さです。これは、追加のパディングが追加されたときに失われた属性値の元の長さを決定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Original Attribute Value: Attribute Value that is to be obscured.",
      "ja": "オリジナル属性値：見えなくする属性値。"
    },
    {
      "indent": 3,
      "text": "Padding: Random additional octets used to obscure length of the Attribute Value that is being hidden.",
      "ja": "パディング：隠されている属性値の曖昧な長さに使用されるランダム追加オクテット。"
    },
    {
      "indent": 3,
      "text": "To mask the size of the data being hidden, the resulting subformat MAY be padded as shown above. Padding does NOT alter the value placed in the Length of Original Attribute Value field, but does alter the length of the resultant AVP that is being created. For example, if an Attribute Value to be hidden is 4 octets in length, the unhidden AVP length would be 10 octets (6 + Attribute Value length). After hiding, the length of the AVP would become 6 + Attribute Value length + size of the Length of Original Attribute Value field + Padding. Thus, if Padding is 12 octets, the AVP length would be 6 + 4 + 2 + 12 = 24 octets.",
      "ja": "上記のように隠されているデータのサイズをマスクするために、結果として得られるサブフォーマットが埋められることがあります。パディングオリジナル属性値フィールドの長さに置かれた値を変更しませんが、作成されている結果AVPの長さを変えるん。隠されるべき属性値が長さが4つのオクテットである場合、例えば、再表示AVP長さが10個のオクテット（6 +属性値の長さ）であろう。隠れた後、AVPの長さは6 +オリジナル属性値フィールド+パディングの長さの値の長さ+サイズ属性になります。パディングは12オクテットである場合したがって、AVP長さは6 + 4 + 2 + 12 = 24個のオクテットであろう。"
    },
    {
      "indent": 3,
      "text": "Next, an MD5 [RFC1321] hash is performed (in network byte order) on the concatenation of the following:",
      "ja": "次に、MD5 [RFC1321]ハッシュは、次の連結で（ネットワーク・バイト順で）行われます。"
    },
    {
      "indent": 9,
      "text": "+ the 2-octet Attribute number of the AVP\n+ the shared key\n+ an arbitrary length random vector",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The value of the random vector used in this hash is passed in the value field of a Random Vector AVP. This Random Vector AVP must be placed in the message by the sender before any hidden AVPs. The same random vector may be used for more than one hidden AVP in the same message, but not for hiding two or more instances of an AVP with the same Attribute Type unless the Attribute Values in the two AVPs are also identical. When a different random vector is used for the hiding of subsequent AVPs, a new Random Vector AVP MUST be placed in the control message before the first AVP to which it applies.",
      "ja": "このハッシュに使用されるランダムベクトルの値はランダムなベクトルAVPの値フィールドに渡されます。このランダムベクトルAVPは任意の隠されたAVPの前に、送信者がメッセージの中に置かなければなりません。 2つのAVPの属性値も同一でない限り、同じランダムベクトルが同じメッセージに複数の隠されたAVPのためではなく、同じ属性タイプとAVPの2つの以上のインスタンスを隠すために使用することができます。異なるランダムベクトルが、後続のAVPの隠蔽のために使用される場合、新しいランダムベクトルAVPは、それが適用される最初のAVPの前に制御メッセージに置かなければなりません。"
    },
    {
      "indent": 3,
      "text": "The MD5 hash value is then XORed with the first 16-octet (or less) segment of the Hidden AVP Subformat and placed in the Attribute Value field of the Hidden AVP. If the Hidden AVP Subformat is less than 16 octets, the Subformat is transformed as if the Attribute Value field had been padded to 16 octets before the XOR. Only the actual octets present in the Subformat are modified, and the length of the AVP is not altered.",
      "ja": "MD5ハッシュ値は、最初の16オクテット（又はそれ以下）とXOR隠しAVP Subformatでのセグメントと隠しAVPの属性値フィールドに置かれます。隠されたAVP Subformatが16の未満の八重奏であるならば属性値フィールドはXOR前に16個のオクテットに水増しされていたかのように、Subformatでは、形質転換されます。 Subformatで中に存在する唯一の実際のオクテットが変更され、AVPの長さは変更されません。"
    },
    {
      "indent": 3,
      "text": "If the Subformat is longer than 16 octets, a second one-way MD5 hash is calculated over a stream of octets consisting of the shared key followed by the result of the first XOR. That hash is XORed with the second 16-octet (or less) segment of the Subformat and placed in the corresponding octets of the Value field of the Hidden AVP.",
      "ja": "Subformatでは16オクテットより長い場合、第2の一方向MD5ハッシュは最初のXORの結果に続いて、共有鍵からなるオクテットのストリームを介して計算されます。そのハッシュは、第16オクテット（以下）SubformatでのセグメントとXORし、隠されたAVPのValueフィールドの対応するオクテットに配置されます。"
    },
    {
      "indent": 3,
      "text": "If necessary, this operation is repeated, with the shared key used along with each XOR result to generate the next hash to XOR the next segment of the value with.",
      "ja": "必要に応じて、この操作が持つ値の次のセグメントをXORする次のハッシュを生成するために、各XOR結果と共に使用される共有鍵を用いて、繰り返されます。"
    },
    {
      "indent": 3,
      "text": "The hiding method was adapted from [RFC2865], which was taken from the \"Mixing in the Plaintext\" section in the book \"Network Security\" by Kaufman, Perlman and Speciner [KPS]. A detailed explanation of the method follows:",
      "ja": "隠ぺい方法はカウフマン、パールマンとSpeciner [KPS]の著書「ネットワークセキュリティ」の「平文でミキシング」セクションから取られた[RFC2865]、から適応されました。この方法の詳細な説明は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Call the shared key S, the Random Vector RV, and the Attribute Type A. Break the value field into 16-octet chunks p_1, p_2, etc., with the last one padded at the end with random data to a 16-octet boundary. Call the ciphertext blocks c_1, c_2, etc. We will also define intermediate values b_1, b_2, etc.",
      "ja": "最後の1が16オクテット境界にランダムデータで終わりに埋められて、など、16オクテットのチャンクP_1にP_2を値フィールドをブレイク共有鍵Sを呼び出し、ランダムベクトルRV、および属性タイプA. 。我々はまた、などの中間値B_1、B_2を定義するなどの暗号文ブロックC_1、C_2を、コール"
    },
    {
      "indent": 6,
      "text": "b_1 = MD5 (A + S + RV) c_1 = p_1 xor b_1 b_2 = MD5 (S + c_1) c_2 = p_2 xor b_2 . . . . . . b_i = MD5 (S + c_i-1) c_i = p_i xor b_i",
      "ja": "B_1 = MD5（A + S + RV）C_1 = P_1 XOR B_1 B_2 = MD5（S + C_1）C_2 = P_2 XOR B_2。 。 。 。 。 。 b_i = MD5（S + C_I-1）C_I = P_I XOR b_i"
    },
    {
      "indent": 3,
      "text": "The String will contain c_1 + c_2 +...+ c_i, where \"+\" denotes concatenation.",
      "ja": "\"+\" は、連結を表す文字列は、C_1 + C_2 + ... + C_Iが含まれています。"
    },
    {
      "indent": 3,
      "text": "On receipt, the random vector is taken from the last Random Vector AVP encountered in the message prior to the AVP to be unhidden. The above process is then reversed to yield the original value.",
      "ja": "最後のランダムなベクトルAVPを再表示する前AVPへのメッセージで遭遇から受信すると、ランダムなベクトルが取られています。上記プロセスは、その後、元の値を得るために逆転されます。"
    },
    {
      "indent": 0,
      "text": "5.4. AVP Summary",
      "section_title": true,
      "ja": "5.4。 AVP概要"
    },
    {
      "indent": 3,
      "text": "The following sections contain a list of all L2TP AVPs defined in this document.",
      "ja": "次のセクションでは、この文書で定義されたすべてのL2TPのAVPのリストが含まれています。"
    },
    {
      "indent": 3,
      "text": "Following the name of the AVP is a list indicating the message types that utilize each AVP. After each AVP title follows a short description of the purpose of the AVP, a detail (including a graphic) of the format for the Attribute Value, and any additional information needed for proper use of the AVP.",
      "ja": "AVPの名前に続いて、各AVPを利用メッセージの種類を示すリストです。各AVPタイトル後AVP、属性値の形式、及びAVPの適切な使用のために必要な任意の追加情報（グラフィックを含む）詳細の目的の簡単な説明を以下。"
    },
    {
      "indent": 0,
      "text": "5.4.1. General Control Message AVPs",
      "section_title": true,
      "ja": "5.4.1。一般的な制御メッセージのAVP"
    },
    {
      "indent": 3,
      "text": "Message Type (All Messages)",
      "ja": "メッセージタイプ（すべてのメッセージ）"
    },
    {
      "indent": 6,
      "text": "The Message Type AVP, Attribute Type 0, identifies the control message herein and defines the context in which the exact meaning of the following AVPs will be determined.",
      "ja": "メッセージタイプAVP、属性タイプ0は、本明細書に制御メッセージを識別し、次のAVPの正確な意味が決定されるコンテキストを定義します。"
    },
    {
      "indent": 6,
      "text": "The Attribute Value field for this AVP has the following format:",
      "ja": "このAVPのためのAttribute Value分野には、以下の形式になっています。"
    },
    {
      "indent": 6,
      "text": " 0                   1\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|         Message Type          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "The Message Type is a 2-octet unsigned integer.",
      "ja": "メッセージタイプは、2オクテットの符号なし整数です。"
    },
    {
      "indent": 6,
      "text": "The Message Type AVP MUST be the first AVP in a message, immediately following the control message header (defined in Section 3.2.1). See Section 3.1 for the list of defined control message types and their identifiers.",
      "ja": "メッセージタイプAVPは、直ちに制御メッセージヘッダー（セクション3.2.1で定義されている）は、以下の、メッセージの最初のAVPでなければなりません。定義された制御メッセージの種類とその識別子のリストについては、セクション3.1を参照してください。"
    },
    {
      "indent": 6,
      "text": "The Mandatory (M) bit within the Message Type AVP has special meaning. Rather than an indication as to whether the AVP itself should be ignored if not recognized, it is an indication as to whether the control message itself should be ignored. If the M bit is set within the Message Type AVP and the Message Type is unknown to the implementation, the control connection MUST be cleared. If the M bit is not set, then the implementation may ignore an unknown message type. The M bit MUST be set to 1 for all message types defined in this document. This AVP MUST NOT be hidden (the H bit MUST be 0). The Length of this AVP is 8.",
      "ja": "メッセージタイプAVP内の必須（M）ビットは、特別な意味を持っています。むしろ、認識されない場合にAVP自体が無視されるべきか否かの指示よりも、制御メッセージ自体が無視されるべきかどうかの指標です。 MビットはメッセージタイプAVP内で設定し、メッセージタイプは、実装には不明であるされている場合は、コントロール接続をきれいにしなければなりません。 Mビットが設定されていない場合、実装は未知のメッセージタイプを無視することができます。 Mビットは、この文書で定義されたすべてのメッセージタイプのために1に設定しなければなりません。このAVPは、（Hビットは0でなければならない）隠されてはなりません。このAVPの長さは8です。"
    },
    {
      "indent": 6,
      "text": "A vendor-specific control message may be defined by setting the Vendor ID of the Message Type AVP to a value other than the IETF Vendor ID of 0 (see Section 5.1). The Message Type AVP MUST still be the first AVP in the control message.",
      "ja": "ベンダー固有の制御メッセージは0のIETFベンダーID（セクション5.1を参照）以外の値にメッセージタイプAVPのベンダーIDを設定することによって定義することができます。メッセージタイプAVPは、依然として制御メッセージの最初のAVPでなければなりません。"
    },
    {
      "indent": 3,
      "text": "Message Digest (All Messages)",
      "ja": "メッセージダイジェスト（すべてのメッセージ）"
    },
    {
      "indent": 6,
      "text": "The Message Digest AVP, Attribute Type 59 is used as an integrity and authentication check of the L2TP Control Message header and body.",
      "ja": "メッセージダイジェストAVP、属性タイプ59は、L2TP制御メッセージヘッダとボディの完全性及び認証チェックとして使用されます。"
    },
    {
      "indent": 6,
      "text": "The Attribute Value field for this AVP has the following format:",
      "ja": "このAVPのためのAttribute Value分野には、以下の形式になっています。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Digest Type  | Message Digest ...\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                                  ... (16 or 20 octets)         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Digest Type is a one-octet integer indicating the Digest calculation algorithm:",
      "ja": "ダイジェストタイプは、ダイジェスト計算アルゴリズムを示す1オクテットの整数です。"
    },
    {
      "indent": 9,
      "text": "0 HMAC-MD5 [RFC2104] 1 HMAC-SHA-1 [RFC2104]",
      "ja": "0 HMAC-MD5 [RFC2104] 1 HMAC-SHA-1 [RFC2104]"
    },
    {
      "indent": 6,
      "text": "Digest Type 0 (HMAC-MD5) MUST be supported, while Digest Type 1 (HMAC-SHA-1) SHOULD be supported.",
      "ja": "ダイジェストタイプ1（HMAC-SHA-1）がサポートされるべきであるダイジェストタイプ0（HMAC-MD5）は、サポートしなければなりません。"
    },
    {
      "indent": 6,
      "text": "The Message Digest is of variable length and contains the result of the control message authentication and integrity calculation. For Digest Type 0 (HMAC-MD5), the length of the digest MUST be 16 bytes. For Digest Type 1 (HMAC-SHA-1) the length of the digest MUST be 20 bytes.",
      "ja": "メッセージダイジェストは、可変長であり、制御メッセージの認証と完全性の計算の結果を含みます。ダイジェストタイプ0（HMAC-MD5）のために、ダイジェストの長さは16バイトでなければなりません。ダイジェストタイプ1（HMAC-SHA-1）ダイジェストの長さは20バイトでなければなりません。"
    },
    {
      "indent": 6,
      "text": "If Control Message Authentication is enabled, at least one Message Digest AVP MUST be present in all messages and MUST be placed immediately after the Message Type AVP. This forces the Message Digest AVP to begin at a well-known and fixed offset. A second Message Digest AVP MAY be present in a message and MUST be placed directly after the first Message Digest AVP.",
      "ja": "コントロールメッセージ認証が有効になっている場合は、少なくとも1つのメッセージダイジェストAVPは、すべてのメッセージ内に存在しなければならないとメッセージタイプAVP直後置かなければなりません。これはよく知られており、固定オフセットで開始するようにメッセージダイジェストAVPを強制します。第2のメッセージダイジェストAVPは、メッセージ中に存在してもよく、第一のMessage Digest AVP直後に置かなければなりません。"
    },
    {
      "indent": 6,
      "text": "The shared secret between LCCEs is used to derive a unique shared key for Control Message Authentication calculations. The derived shared key is obtained via an HMAC-MD5 keyed hash [RFC2104], with the key consisting of the shared secret, and with the data being hashed consisting of a single octet containing the value 2.",
      "ja": "LCCEsの間の共有秘密は、制御メッセージ認証計算のための一意の共有鍵を導出するために使用されます。誘導された共有鍵は、共有秘密からなる鍵と、値2を含む単一オクテットからなるハッシュ化されたデータと、HMAC-MD5鍵付きハッシュ[RFC2104]を介して得られます。"
    },
    {
      "indent": 9,
      "text": "shared_key = HMAC_MD5 (shared_secret, 2)",
      "ja": "shared_key = HMAC_MD5（shared_secret、2）"
    },
    {
      "indent": 6,
      "text": "Calculation of the Message Digest is as follows for all messages other than the SCCRQ (where \"+\" refers to concatenation):",
      "ja": "（「+」は、連結を指す）SCCRQ以外のすべてのメッセージのために次のようにメッセージダイジェストの計算です。"
    },
    {
      "indent": 9,
      "text": "Message Digest = HMAC_Hash (shared_key, local_nonce + remote_nonce + control_message)",
      "ja": "メッセージダイジェスト= HMAC_Hash（shared_key、local_nonce + remote_nonce + control_message）"
    },
    {
      "indent": 9,
      "text": "HMAC_Hash: HMAC Hashing algorithm identified by the Digest Type (MD5 or SHA1)",
      "ja": "HMAC_Hash：ダイジェストタイプ（MD5またはSHA1）によって識別されるHMACハッシュアルゴリズム"
    },
    {
      "indent": 9,
      "text": "local_nonce: Nonce chosen locally and advertised to the remote LCCE.",
      "ja": "local_nonce：nonceがローカルに選ばれた、リモートLCCEにアドバタイズ。"
    },
    {
      "indent": 9,
      "text": "remote_nonce: Nonce received from the remote LCCE",
      "ja": "remote_nonce：nonceがリモートLCCEから受け取りました"
    },
    {
      "indent": 9,
      "text": "(The local_nonce and remote_nonce are advertised via the Control Message Authentication Nonce AVP, also defined in this section.)",
      "ja": "（local_nonceとremote_nonceも、このセクションで定義された、制御メッセージ認証ノンスAVPを介して通知されます。）"
    },
    {
      "indent": 9,
      "text": "shared_key: Derived shared key for this control connection",
      "ja": "shared_key：この制御接続のための派生共有鍵"
    },
    {
      "indent": 9,
      "text": "control_message: The entire contents of the L2TP control message, including the control message header and all AVPs. Note that the control message header in this case begins after the all-zero Session ID when running over IP (see Section 4.1.1.2), and after the UDP header when running over UDP (see Section 4.1.2.1).",
      "ja": "control_message：制御メッセージヘッダとすべてのAVPを含むL2TP制御メッセージの内容全体を、。 IP（セクション4.1.1.2を参照）を介して実行するとき、およびUDPヘッダの後にUDP上で実行する場合、この場合の制御メッセージヘッダーがオールゼロセッションID後に始まることに注意してください（セクション4.1.2.1を参照）。"
    },
    {
      "indent": 6,
      "text": "When calculating the Message Digest, the Message Digest AVP MUST be present within the control message with the Digest Type set to its proper value, but the Message Digest itself set to zeros.",
      "ja": "メッセージダイジェストを計算するときに、メッセージダイジェストAVPは、その適切な値に設定ダイジェストタイプの制御メッセージ内に存在しなければならないが、メッセージダイジェスト自体がゼロに設定します。"
    },
    {
      "indent": 6,
      "text": "When receiving a control message, the contents of the Message Digest AVP MUST be compared against the expected digest value based on local calculation. This is done by performing the same digest calculation above, with the local_nonce and remote_nonce reversed. This message authenticity and integrity checking MUST be performed before utilizing any information contained within the control message. If the calculation fails, the message MUST be dropped.",
      "ja": "制御メッセージを受信すると、メッセージダイジェストAVPの内容がローカル計算に基づいて予測ダイジェスト値と比較しなければなりません。これは逆local_nonceとremote_nonceで、上記と同じダイジェストの計算を実行することによって行われます。このメッセージの信憑性と整合性チェックは、制御メッセージに含まれる情報を利用する前に実行しなければなりません。計算が失敗した場合、メッセージは削除されなければなりません。"
    },
    {
      "indent": 6,
      "text": "The SCCRQ has special treatment as it is the initial message commencing a new control connection. As such, there is only one nonce available. Since the nonce is present within the message itself as part of the Control Message Authentication Nonce AVP, there is no need to use it in the calculation explicitly. Calculation of the SCCRQ Message Digest is performed as follows:",
      "ja": "SCCRQは、新しいコントロール接続を開始する最初のメッセージであるような特別な治療があります。そのため、一つだけナンス利用可能です。ノンスは、コントロールメッセージ認証ノンスAVPの一部としてメッセージ自体内に存在するので、明示的に計算にそれを使用する必要はありません。次のようにSCCRQメッセージダイジェストの計算が実行されます。"
    },
    {
      "indent": 9,
      "text": "Message Digest = HMAC_Hash (shared_key, control_message)",
      "ja": "メッセージダイジェスト= HMAC_Hash（shared_key、c​​ontrol_message）"
    },
    {
      "indent": 6,
      "text": "To allow for graceful switchover to a new shared secret or hash algorithm, two Message Digest AVPs MAY be present in a control message, and two shared secrets MAY be configured for a given LCCE. If two Message Digest AVPs are received in a control message, the message MUST be accepted if either Message Digest is valid. If two shared secrets are configured, each (separately) MUST be used for calculating a digest to be compared to the Message Digest(s) received. When calculating a digest for a control message, the Value field for both of the Message Digest AVPs MUST be set to zero.",
      "ja": "新しい共有秘密またはハッシュアルゴリズムに優雅な切り替えを可能にするため、2つのメッセージダイジェストのAVPはコントロールメッセージに存在していてもよく、2つの共有秘密が与えられたLCCEのために構成することができます。 2つのメッセージダイジェストのAVPは、制御メッセージで受信している場合はどちらかのメッセージダイジェストが有効であれば、メッセージを受け入れなければなりません。 2つの共有秘密が設定されている場合、それぞれが（別々に）メッセージダイジェスト（S）受信と比較するダイジェストを計算するために使用されなければなりません。制御メッセージのダイジェストを計算するときに、メッセージダイジェストのAVPの両方の値フィールドはゼロに設定しなければなりません。"
    },
    {
      "indent": 6,
      "text": "This AVP MUST NOT be hidden (the H bit MUST be 0). The M bit for this AVP SHOULD be set to 1, but MAY vary (see Section 5.2). The Length is 23 for Digest Type 1 (HMAC-MD5), and 27 for Digest Type 2 (HMAC-SHA-1).",
      "ja": "このAVPは、（Hビットは0でなければならない）隠されてはなりません。このAVPのためのMビットが1に設定されるべきであるが、（セクション5.2を参照）変化してもよいです。長さは、ダイジェストタイプ1（HMAC-MD5）23、及びダイジェストタイプ2（HMAC-SHA-1）27です。"
    },
    {
      "indent": 3,
      "text": "Control Message Authentication Nonce (SCCRQ, SCCRP)",
      "ja": "制御メッセージ認証ノンス（SCCRQ、SCCRP）"
    },
    {
      "indent": 6,
      "text": "The Control Message Authentication Nonce AVP, Attribute Type 73, MUST contain a cryptographically random value [RFC1750]. This value is used for Control Message Authentication.",
      "ja": "制御メッセージ認証ノンスAVP、属性タイプ73は、暗号乱数値[RFC1750]を含まなければなりません。この値は、制御メッセージの認証に使用されます。"
    },
    {
      "indent": 6,
      "text": "The Attribute Value field for this AVP has the following format:",
      "ja": "このAVPのためのAttribute Value分野には、以下の形式になっています。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-++-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Nonce ... (arbitrary number of octets)\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-++-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "The Nonce is of arbitrary length, though at least 16 octets is recommended. The Nonce contains the random value for use in the Control Message Authentication hash calculation (see Message Digest AVP definition in this section).",
      "ja": "少なくとも16個のオクテットが推奨されてもnonceが、任意の長さです。 nonceが制御メッセージ認証ハッシュ計算に使用するためのランダム値を含む（このセクションのメッセージダイジェストAVP定義を参照のこと）。"
    },
    {
      "indent": 6,
      "text": "If Control Message Authentication is enabled, this AVP MUST be present in the SCCRQ and SCCRP messages.",
      "ja": "コントロールメッセージ認証が有効になっている場合は、このAVPはSCCRQとSCCRPメッセージに存在しなければなりません。"
    },
    {
      "indent": 6,
      "text": "This AVP MUST NOT be hidden (the H bit MUST be 0). The M bit for this AVP SHOULD be set to 1, but MAY vary (see Section 5.2). The Length of this AVP is 6 plus the length of the Nonce.",
      "ja": "このAVPは、（Hビットは0でなければならない）隠されてはなりません。このAVPのためのMビットが1に設定されるべきであるが、（セクション5.2を参照）変化してもよいです。このAVPの長さは6プラスノンスの長さです。"
    },
    {
      "indent": 3,
      "text": "Random Vector (All Messages)",
      "ja": "ランダムベクトル（すべてのメッセージ）"
    },
    {
      "indent": 6,
      "text": "The Random Vector AVP, Attribute Type 36, MUST contain a cryptographically random value [RFC1750]. This value is used for AVP Hiding.",
      "ja": "ランダムベクトルAVP、属性タイプ36は、暗号的にランダムな値[RFC1750]を含まなければなりません。この値は、AVP隠すために使用されます。"
    },
    {
      "indent": 6,
      "text": "The Attribute Value field for this AVP has the following format:",
      "ja": "このAVPのためのAttribute Value分野には、以下の形式になっています。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-++-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Random Octet String ... (arbitrary number of octets)\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-++-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "The Random Octet String is of arbitrary length, though at least 16 octets is recommended. The string contains the random vector for use in computing the MD5 hash to retrieve or hide the Attribute Value of a hidden AVP (see Section 5.3).",
      "ja": "少なくとも16個のオクテットが推奨されてもランダムオクテットストリングは、任意の長さです。文字列には、隠されたAVP（セクション5.3を参照）の属性値を取得したり、非表示にするにはMD5ハッシュを計算する際に使用するためにランダムなベクトルが含まれています。"
    },
    {
      "indent": 6,
      "text": "More than one Random Vector AVP may appear in a message, in which case a hidden AVP uses the Random Vector AVP most closely preceding it. As such, at least one Random Vector AVP MUST precede the first AVP with the H bit set.",
      "ja": "複数のランダムベクトルAVPは隠されたAVPは、それに先行する最も密接にランダムベクトルAVPを使用する場合には、メッセージに表示されてもよいです。このように、少なくとも一つのランダムベクトルAVPはHビットセットを有する第1のAVPに先行しなければなりません。"
    },
    {
      "indent": 6,
      "text": "This AVP MUST NOT be hidden (the H bit MUST be 0). The M bit for this AVP SHOULD be set to 1, but MAY vary (see Section 5.2). The Length of this AVP is 6 plus the length of the Random Octet String.",
      "ja": "このAVPは、（Hビットは0でなければならない）隠されてはなりません。このAVPのためのMビットが1に設定されるべきであるが、（セクション5.2を参照）変化してもよいです。このAVPの長さは6プラスランダムオクテット文字列の長さです。"
    },
    {
      "indent": 0,
      "text": "5.4.2. Result and Error Codes",
      "section_title": true,
      "ja": "5.4.2。結果とエラーコード"
    },
    {
      "indent": 3,
      "text": "Result Code (StopCCN, CDN)",
      "ja": "結果コード（StopCCN、CDN）"
    },
    {
      "indent": 6,
      "text": "The Result Code AVP, Attribute Type 1, indicates the reason for terminating the control connection or session.",
      "ja": "結果コードAVP、属性タイプ1は、制御接続またはセッションを終了する理由を示します。"
    },
    {
      "indent": 6,
      "text": "The Attribute Value field for this AVP has the following format:",
      "ja": "このAVPのためのAttribute Value分野には、以下の形式になっています。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Result Code          |     Error Code (optional)     |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Error Message ... (optional, arbitrary number of octets)      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "The Result Code is a 2-octet unsigned integer. The optional Error Code is a 2-octet unsigned integer. An optional Error Message can follow the Error Code field. Presence of the Error Code and Message is indicated by the AVP Length field. The Error Message contains an arbitrary string providing further (human-readable) text associated with the condition. Human-readable text in all error messages MUST be provided in the UTF-8 charset [RFC3629] using the Default Language [RFC2277].",
      "ja": "結果コードは、2オクテットの符号なし整数です。オプションのエラーコードは、2オクテットの符号なし整数です。オプションのエラーメッセージは、エラーコード欄に従うことができます。エラーコードとメッセージの存在はAVP Lengthフィールドによって示されます。エラーメッセージは、条件に関連付けられ、さらに（人間が読める）テキストを提供する任意の文字列が含まれています。すべてのエラーメッセージでは、人間が読めるテキストは、デフォルト言語[RFC2277]を使用してUTF-8文字セット[RFC3629]に提供しなければなりません。"
    },
    {
      "indent": 6,
      "text": "This AVP MUST NOT be hidden (the H bit MUST be 0). The M bit for this AVP SHOULD be set to 1, but MAY vary (see Section 5.2). The Length is 8 if there is no Error Code or Message, 10 if there is an Error Code and no Error Message, or 10 plus the length of the Error Message if there is an Error Code and Message.",
      "ja": "このAVPは、（Hビットは0でなければならない）隠されてはなりません。このAVPのためのMビットが1に設定されるべきであるが、（セクション5.2を参照）変化してもよいです。エラー・コードまたはメッセージが存在しない場合、エラーコード及びメッセージがある場合は、エラーコードとエラーメッセージ、または10に加え、エラーメッセージの長さがある場合は、長さは、10 8です。"
    },
    {
      "indent": 6,
      "text": "Defined Result Code values for the StopCCN message are as follows:",
      "ja": "次のようにStopCCNメッセージのための定義されたResult Code値は以下のとおりです。"
    },
    {
      "indent": 9,
      "text": "0 - Reserved. 1 - General request to clear control connection. 2 - General error, Error Code indicates the problem. 3 - Control connection already exists. 4 - Requester is not authorized to establish a control connection. 5 - The protocol version of the requester is not supported, Error Code indicates highest version supported. 6 - Requester is being shut down. 7 - Finite state machine error or timeout",
      "ja": "0  - 予約済み。 1  - コントロール接続をクリアする一般要求。 2  - 一般的なエラー、エラーコードは、問題を示しています。 3  - コントロール接続がすでに存在しています。 4  - リクエスタは、制御接続を確立するために許可されていません。 5  - 依頼者のプロトコルバージョンがサポートされていない、エラー・コードは、最も高いバージョンサポートを示しています。 6  - リクエスタがシャットダウンされています。 7  - 有限ステートマシンエラーまたはタイムアウト"
    },
    {
      "indent": 6,
      "text": "General Result Code values for the CDN message are as follows:",
      "ja": "次のようにCDNメッセージのための一般的な結果コードの値は次のとおりです。"
    },
    {
      "indent": 9,
      "text": "0 - Reserved. 1 - Session disconnected due to loss of carrier or circuit disconnect. 2 - Session disconnected for the reason indicated in Error Code. 3 - Session disconnected for administrative reasons. 4 - Session establishment failed due to lack of appropriate facilities being available (temporary condition).",
      "ja": "0  - 予約済み。 1  - によるキャリアまたは回路切断の損失に切断されたセッション。 2  - エラーコードで示された理由で切断されたセッション。 3  - 管理上の理由で切断されたセッション。 4  - セッションの確立は、利用可能な（一時的な状態）であること、適切な施設の不足のため失敗しました。"
    },
    {
      "indent": 8,
      "text": " 5 - Session establishment failed due to lack of appropriate facilities being available (permanent condition). 13 - Session not established due to losing tie breaker. 14 - Session not established due to unsupported PW type. 15 - Session not established, sequencing required without valid L2-Specific Sublayer. 16 - Finite state machine error or timeout.",
      "ja": "5  - セッションの確立は、利用可能な（永久的な状態）であること、適切な施設の不足のため失敗しました。 13  - によるタイブレーカーを失うことに確立されていないセッション。 14  - によりサポートされていないPWタイプに確立されていないセッション。 15  - 有効なL2特有の副層なしで必要なセッション確立されていない、シーケンシング。 16  - 有限状態機械誤りかタイムアウト。"
    },
    {
      "indent": 6,
      "text": "Additional service-specific Result Codes are defined outside this document.",
      "ja": "追加のサービス固有の結果コードは、このドキュメントの外で定義されています。"
    },
    {
      "indent": 6,
      "text": "The Error Codes defined below pertain to types of errors that are not specific to any particular L2TP request, but rather to protocol or message format errors. If an L2TP reply indicates in its Result Code that a General Error occurred, the General Error value should be examined to determine what the error was. The currently defined General Error codes and their meanings are as follows:",
      "ja": "以下に定義されるエラーコードは、任意の特定のL2TP要求に固有ではなく、プロトコルまたはメッセージフォーマットのエラーではないエラーの種類に関係します。 L2TPの回答が一般エラーが発生し、その結果コードに示されている場合、一般的なエラー値は、エラーが何であったかを決定するために検討されなければなりません。次のように現在定義されている一般的なエラーコードとその意味は以下のとおりです。"
    },
    {
      "indent": 6,
      "text": "0 - No General Error. 1 - No control connection exists yet for this pair of LCCEs. 2 - Length is wrong. 3 - One of the field values was out of range. 4 - Insufficient resources to handle this operation now. 5 - Invalid Session ID. 6 - A generic vendor-specific error occurred. 7 - Try another. If initiator is aware of other possible responder destinations, it should try one of them. This can be used to guide an LAC or LNS based on policy. 8 - The session or control connection was shut down due to receipt of an unknown AVP with the M bit set (see Section 5.2). The Error Message SHOULD contain the attribute of the offending AVP in (human-readable) text form. 9 - Try another directed. If an LAC or LNS is aware of other possible destinations, it should inform the initiator of the control connection or session. The Error Message MUST contain a comma-separated list of addresses from which the initiator may choose. If the L2TP data channel runs over IPv4, then this would be a comma-separated list of IP addresses in the canonical dotted-decimal format (e.g., \"192.0.2.1, 192.0.2.2, 192.0.2.3\") in the UTF-8 charset [RFC3629] using the Default Language [RFC2277]. If there are no servers for the LAC or LNS to suggest, then Error Code 7 should be used. For IPv4, the delimiter between addresses MUST be precisely a single comma and a single space. For IPv6, each literal address MUST be enclosed in \"[\" and \"]\" characters, following the encoding described in [RFC2732].",
      "ja": "0  - なし一般エラー。 1  - 無制御接続がLCCEsのこのペアに対してまだ存在しません。 2  - 長さが間違っています。 3  - フィールド値の1つが範囲外でした。 4  - 今、この操作を処理するためのリソースが不足。 5  - 無効なセッションID。 6  - 一般的なベンダー固有のエラーが発生しました。 7  - 別のものを試してみてください。イニシエータは他の可能な応答の送信先を認識している場合、それはそれらのいずれかを試してみてください。これは、ポリシーに基づいて、LACまたはLNSを誘導するために使用することができます。 8  -  Mビットセットとのセッションまたは制御接続が不明なAVPの受信にシャットダウンされた（5.2節を参照）。エラーメッセージは、（人間が読める）テキスト形式で問題のAVPの属性を含んでいます。 9  - 別の指示をお試しください。 LACまたはLNSは、他の可能な宛先を認識している場合、それはコントロール接続やセッションの開始者に通知する必要があります。エラーメッセージは、イニシエータが選択することができ、そこからアドレスのカンマ区切りリストを指定する必要があります。 L2TPデータチャンネルがIPv4上で実行されている場合、これはUTF-8での標準的なドット付き10進表記でのIPアドレスのカンマ区切りのリストを（例えば、「192.0.2.1、192.0.2.2、192.0.2.3」）になりますデフォルト言語[RFC2277]を使用して文字セット[RFC3629]。示唆するLACまたはLNSのためのサーバがない場合は、エラーコード7を使用する必要があります。 IPv4の場合、アドレス間の区切り文字を正確に単一コンマとシングルスペースでなければなりません。 IPv6のために、各リテラルアドレスは[RFC2732]で説明エンコーディング以下、「[」および「]」の文字で囲む必要があります。"
    },
    {
      "indent": 6,
      "text": "When a General Error Code of 6 is used, additional information about the error SHOULD be included in the Error Message field. A vendor-specific AVP MAY be sent to more precisely detail a vendor-specific problem.",
      "ja": "6の一般的なエラーコードが使用されている場合は、エラーに関する追加情報は、エラーメッセージフィールドに含まれるべきです。ベンダー固有のAVPは、より正確に詳しく、ベンダー固有の問題に送ってもよいです。"
    },
    {
      "indent": 0,
      "text": "5.4.3. Control Connection Management AVPs",
      "section_title": true,
      "ja": "5.4.3。コントロール接続管理のAVP"
    },
    {
      "indent": 3,
      "text": "Control Connection Tie Breaker (SCCRQ)",
      "ja": "制御接続タイブレーカー（SCCRQ）"
    },
    {
      "indent": 6,
      "text": "The Control Connection Tie Breaker AVP, Attribute Type 5, indicates that the sender desires a single control connection to exist between a given pair of LCCEs.",
      "ja": "コントロール接続タイブレーカAVP、属性タイプ5は、送信者がLCCEsの所与の対の間に存在する単一の制御接続を希望することを示しています。"
    },
    {
      "indent": 6,
      "text": "The Attribute Value field for this AVP has the following format:",
      "ja": "このAVPのためのAttribute Value分野には、以下の形式になっています。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Control Connection Tie Breaker Value ...\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                                           ... (64 bits)        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "The Control Connection Tie Breaker Value is an 8-octet random value that is used to choose a single control connection when two LCCEs request a control connection concurrently. The recipient of a SCCRQ must check to see if a SCCRQ has been sent to the peer; if so, a tie has been detected. In this case, the LCCE must compare its Control Connection Tie Breaker value with the one received in the SCCRQ. The lower value \"wins\", and the \"loser\" MUST discard its control connection. A StopCCN SHOULD be sent by the winner as an explicit rejection for the losing SCCRQ. In the case in which a tie breaker is present on both sides and the value is equal, both sides MUST discard their control connections and restart control connection negotiation with a new, random tie breaker value.",
      "ja": "コントロール接続タイ・ブレーカーの値は、2つのLCCEsの同時に制御接続を要求したとき、単一の制御接続を選択するために使用される8オクテットランダム値です。 SCCRQの受取人はSCCRQがピアに送信されたかどうかを確認する必要があります。もしそうなら、ネクタイが検出されました。この場合、LCCEはSCCRQに受信した1つを用いて、その制御接続タイ・ブレーカーの値を比較しなければなりません。低い値「勝ち」、および「敗者」はコントロール接続を捨てなければなりません。 StopCCNは負けSCCRQのための明示的な拒否として勝者によって送られるべきです。タイ・ブレーカーが両側に存在し、値が等しく、双方が彼らの制御接続を破棄して新しい、ランダムタイブレーカ値との制御接続ネゴシエーションを再起動する必要がある場合。"
    },
    {
      "indent": 6,
      "text": "If a tie breaker is received and an outstanding SCCRQ has no tie breaker value, the initiator that included the Control Connection Tie Breaker AVP \"wins\". If neither side issues a tie breaker, then two separate control connections are opened.",
      "ja": "タイ・ブレーカーが受信され、優れたSCCRQにはタイブレーカ値、制御接続タイ・ブレーカーのAVP「勝利」に含まれる開始剤を有していない場合。どちらの側がタイブレーカーを発行した場合、2つの別々の制御接続が開かれます。"
    },
    {
      "indent": 6,
      "text": "Applications that employ a distinct and well-known initiator have no need for tie breaking, and MAY omit this AVP or disable tie breaking functionality. Applications that require tie breaking also require that an LCCE be uniquely identifiable upon receipt of an SCCRQ. For L2TP over IP, this MUST be accomplished via the Router ID AVP.",
      "ja": "明確な、よく知られているイニシエータを採用するアプリケーションは、タイブレイクを必要としない、そしてこのAVPまたは無効にタイブレイクの機能を省略することができます。タイブレイクを必要とするアプリケーションもLCCEがSCCRQを受信すると一意に識別することが必要です。 IP上のL2TPの場合、これはルータID AVPを介して行われなければなりません。"
    },
    {
      "indent": 6,
      "text": "Note that in [RFC2661], this AVP is referred to as the \"Tie Breaker AVP\" and is applicable only to a control connection. In L2TPv3, the AVP serves the same purpose of tie breaking, but is applicable to a control connection or a session. The Control Connection Tie Breaker AVP (present only in Control Connection messages) and Session Tie Breaker AVP (present only in Session messages), are described separately in this document, but share the same Attribute type of 5.",
      "ja": "[RFC2661]で、このAVPは、「タイ・ブレーカーAVP」と呼ばれ、唯一の制御接続にも適用可能であることに留意されたいです。 L2TPv3のでは、AVPは、タイブレイクの同じ目的を果たすが、制御接続またはセッションに適用可能です。コントロール接続（のみ制御コネクションメッセージ内に存在する）タイブレーカAVPおよびセッションタイブレーカAVP（のみセッションメッセージ中に存在する）は、本文書に分けて説明するが、5の同じ属性タイプを共有しています。"
    },
    {
      "indent": 6,
      "text": "This AVP MUST NOT be hidden (the H bit MUST be 0). The M bit for this AVP SHOULD be set to 1, but MAY vary (see Section 5.2). The length of this AVP is 14.",
      "ja": "このAVPは、（Hビットは0でなければならない）隠されてはなりません。このAVPのためのMビットが1に設定されるべきであるが、（セクション5.2を参照）変化してもよいです。このAVPの長さは14です。"
    },
    {
      "indent": 3,
      "text": "Host Name (SCCRQ, SCCRP)",
      "ja": "ホスト名（SCCRQ、SCCRP）"
    },
    {
      "indent": 6,
      "text": "The Host Name AVP, Attribute Type 7, indicates the name of the issuing LAC or LNS, encoded in the US-ASCII charset.",
      "ja": "ホスト名AVP、属性タイプ7は、US-ASCII文字セットでエンコードされ、発行LACかLNSの名前を示します。"
    },
    {
      "indent": 6,
      "text": "The Attribute Value field for this AVP has the following format:",
      "ja": "このAVPのためのAttribute Value分野には、以下の形式になっています。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Host Name ... (arbitrary number of octets)\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "The Host Name is of arbitrary length, but MUST be at least 1 octet.",
      "ja": "ホスト名は、任意の長さであるが、少なくとも1オクテットでなければなりません。"
    },
    {
      "indent": 6,
      "text": "This name should be as broadly unique as possible; for hosts participating in DNS [RFC1034], a host name with fully qualified domain would be appropriate. The Host Name AVP and/or Router ID AVP MUST be used to identify an LCCE as described in Section 3.3.",
      "ja": "この名前は、できるだけ広くユニークである必要があります。 DNS [RFC1034]に参加するホストのために、完全修飾ドメインを持つホスト名が適切であろう。ホスト名AVPおよび/またはルータID AVPは、セクション3.3で説明したようにLCCEを識別するために使用されなければなりません。"
    },
    {
      "indent": 6,
      "text": "This AVP MUST NOT be hidden (the H bit MUST be 0). The M bit for this AVP SHOULD be set to 1, but MAY vary (see Section 5.2). The Length of this AVP is 6 plus the length of the Host Name.",
      "ja": "このAVPは、（Hビットは0でなければならない）隠されてはなりません。このAVPのためのMビットが1に設定されるべきであるが、（セクション5.2を参照）変化してもよいです。このAVPの長さは6プラスホスト名の長さです。"
    },
    {
      "indent": 3,
      "text": "Router ID (SCCRQ, SCCRP)",
      "ja": "ルータID（SCCRQ、SCCRP）"
    },
    {
      "indent": 6,
      "text": "The Router ID AVP, Attribute Type 60, is an identifier used to identify an LCCE for control connection setup, tie breaking, and/or tunnel authentication.",
      "ja": "ルータID AVP、属性タイプ60は、制御接続設定、タイブレーキング、及び/又はトンネル認証のためにLCCEを識別するための識別子です。"
    },
    {
      "indent": 6,
      "text": "The Attribute Value field for this AVP has the following format:",
      "ja": "このAVPのためのAttribute Value分野には、以下の形式になっています。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      Router Identifier                        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "The Router Identifier is a 4-octet unsigned integer. Its value is unique for a given LCCE, per Section 8.1 of [RFC2072]. The Host Name AVP and/or Router ID AVP MUST be used to identify an LCCE as described in Section 3.3.",
      "ja": "ルータ識別子は4オクテットの符号なし整数です。その値は[RFC2072]のセクション8.1当たり、所与LCCEに対して一意です。ホスト名AVPおよび/またはルータID AVPは、セクション3.3で説明したようにLCCEを識別するために使用されなければなりません。"
    },
    {
      "indent": 6,
      "text": "Implementations MUST NOT assume that Router Identifier is a valid IP address. The Router Identifier for L2TP over IPv6 can be obtained from an IPv4 address (if available) or via unspecified implementation-specific means.",
      "ja": "実装はルータ識別子が有効なIPアドレスであると仮定してはいけません。 IPv6を介したL2TP用のルータ識別子は、IPv4アドレス（使用可能な場合）から、または不特定の実装に固有の手段を介して取得することができます。"
    },
    {
      "indent": 6,
      "text": "This AVP MUST NOT be hidden (the H bit MUST be 0). The M bit for this AVP SHOULD be set to 1, but MAY vary (see Section 5.2). The Length of this AVP is 10.",
      "ja": "このAVPは、（Hビットは0でなければならない）隠されてはなりません。このAVPのためのMビットが1に設定されるべきであるが、（セクション5.2を参照）変化してもよいです。このAVPの長さは10です。"
    },
    {
      "indent": 3,
      "text": "Vendor Name (SCCRQ, SCCRP)",
      "ja": "ベンダー名（SCCRQ、SCCRP）"
    },
    {
      "indent": 6,
      "text": "The Vendor Name AVP, Attribute Type 8, contains a vendor-specific (possibly human-readable) string describing the type of LAC or LNS being used.",
      "ja": "ベンダー名AVP、属性タイプ8は、使用されるLACまたはLNSのタイプを記述するベンダー固有の（おそらく人間が読み取り可能な）文字列を含みます。"
    },
    {
      "indent": 6,
      "text": "The Attribute Value field for this AVP has the following format:",
      "ja": "このAVPのためのAttribute Value分野には、以下の形式になっています。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Vendor Name ... (arbitrary number of octets)\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "The Vendor Name is the indicated number of octets representing the vendor string. Human-readable text for this AVP MUST be provided in the US-ASCII charset [RFC1958, RFC2277].",
      "ja": "ベンダー名は、ベンダー文字列を表すオクテットの指示された数です。このAVPのために人間が読めるテキストは、US-ASCII文字セット[RFC1958、RFC2277]に提供しなければなりません。"
    },
    {
      "indent": 6,
      "text": "This AVP MAY be hidden (the H bit MAY be 0 or 1). The M bit for this AVP SHOULD be set to 0, but MAY vary (see Section 5.2). The Length (before hiding) of this AVP is 6 plus the length of the Vendor Name.",
      "ja": "このAVPは、（Hビットが0または1でもよい）隠すことができます。このAVPのためのMビットは0に設定されるべきであるが、（セクション5.2を参照）変化してもよいです。このAVPのLength（隠れることの前の）は、ベンダー名の6を加えた長さです。"
    },
    {
      "indent": 3,
      "text": "Assigned Control Connection ID (SCCRQ, SCCRP, StopCCN)",
      "ja": "割り当てられた制御コネクションID（SCCRQ、SCCRP、StopCCN）"
    },
    {
      "indent": 6,
      "text": "The Assigned Control Connection ID AVP, Attribute Type 61, contains the ID being assigned to this control connection by the sender.",
      "ja": "割り当てられた制御コネクションID AVP、属性タイプ61は、送信者によってこの制御コネクションに割り当てられるIDを含んでいます。"
    },
    {
      "indent": 6,
      "text": "The Attribute Value field for this AVP has the following format:",
      "ja": "このAVPのためのAttribute Value分野には、以下の形式になっています。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                Assigned Control Connection ID                 |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "The Assigned Control Connection ID is a 4-octet non-zero unsigned integer.",
      "ja": "割り当てられた制御コネクションIDは4オクテット非ゼロの符号なし整数です。"
    },
    {
      "indent": 6,
      "text": "The Assigned Control Connection ID AVP establishes the identifier used to multiplex and demultiplex multiple control connections between a pair of LCCEs. Once the Assigned Control Connection ID AVP has been received by an LCCE, the Control Connection ID specified in the AVP MUST be included in the Control Connection ID field of all control packets sent to the peer for the lifetime of the control connection. Before the Assigned Control Connection ID AVP is received from a peer, all control messages MUST be sent to that peer with a Control Connection ID value of 0 in the header. Because a Control Connection ID value of 0 is used in this special manner, the zero value MUST NOT be sent as an Assigned Control Connection ID value.",
      "ja": "割り当てられた制御コネクションID AVPはLCCEsの対の間の複数の制御接続を多重化及び逆多重化するために使用される識別子を確立します。割り当てられた制御コネクションID AVPはLCCEによって受信された後、AVPで指定された制御コネクションIDは、制御接続の存続期間中のピアに送信されるすべての制御パケットの制御コネクションIDフィールドに含まれなければなりません。割り当てられた制御コネクションID AVPがピアから受信される前に、すべての制御メッセージは、ヘッダ内の0の制御コネクションID値とそのピアに送信されなければなりません。 0の制御コネクションID値は、この特別な方法で使用されているので、ゼロ値が割り当てられた制御コネクションIDの値として送信してはいけません。"
    },
    {
      "indent": 6,
      "text": "Under certain circumstances, an LCCE may need to send a StopCCN to a peer without having yet received an Assigned Control Connection ID AVP from the peer (i.e., SCCRQ sent, no SCCRP received yet). In this case, the Assigned Control Connection ID AVP that had been sent to the peer earlier (i.e., in the SCCRQ) MUST be sent as the Assigned Control Connection ID AVP in the StopCCN. This policy allows the peer to try to identify the appropriate control connection via a reverse lookup.",
      "ja": "特定の状況下で、LCCEはまだ（つまり、SCCRQを送信、何SCCRPがまだ受信していない）ピアから割り当てられた制御コネクションID AVPを受信せずにピアにStopCCNを送信する必要があるかもしれません。この場合、（すなわち、SCCRQに）以前のピアに送信された割り当てられた制御コネクションID AVPはStopCCNに割り当てられた制御コネクションID AVPとして送らなければなりません。このポリシーは、ピアは、逆引き参照を経由して、適切なコントロール接続を特定しようとすることができます。"
    },
    {
      "indent": 6,
      "text": "This AVP MAY be hidden (the H bit MAY be 0 or 1). The M bit for this AVP SHOULD be set to 1, but MAY vary (see Section 5.2). The Length (before hiding) of this AVP is 10.",
      "ja": "このAVPは、（Hビットが0または1でもよい）隠すことができます。このAVPのためのMビットが1に設定されるべきであるが、（セクション5.2を参照）変化してもよいです。このAVPのLength（隠れることの前の）は10です。"
    },
    {
      "indent": 3,
      "text": "Receive Window Size (SCCRQ, SCCRP)",
      "ja": "受信ウィンドウサイズ（SCCRQ、SCCRP）"
    },
    {
      "indent": 6,
      "text": "The Receive Window Size AVP, Attribute Type 10, specifies the receive window size being offered to the remote peer.",
      "ja": "受信ウィンドウサイズのAVP、属性タイプ10は、リモートピアに提供されている受信ウィンドウサイズを指定します。"
    },
    {
      "indent": 6,
      "text": "The Attribute Value field for this AVP has the following format:",
      "ja": "このAVPのためのAttribute Value分野には、以下の形式になっています。"
    },
    {
      "indent": 6,
      "text": " 0                   1\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|         Window Size           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "The Window Size is a 2-octet unsigned integer.",
      "ja": "ウィンドウサイズは、2オクテットの符号なし整数です。"
    },
    {
      "indent": 6,
      "text": "If absent, the peer must assume a Window Size of 4 for its transmit window.",
      "ja": "存在しない場合、ピアは、その送信ウィンドウ4のウィンドウサイズを想定しなければなりません。"
    },
    {
      "indent": 6,
      "text": "The remote peer may send the specified number of control messages before it must wait for an acknowledgment. See Section 4.2 for more information on reliable control message delivery.",
      "ja": "それは確認応答を待機しなければならない前に、リモートピアは、制御メッセージの指定された数を送信することができます。信頼性の高い制御メッセージの配信の詳細については、セクション4.2を参照してください。"
    },
    {
      "indent": 6,
      "text": "This AVP MUST NOT be hidden (the H bit MUST be 0). The M bit for this AVP SHOULD be set to 1, but MAY vary (see Section 5.2). The Length of this AVP is 8.",
      "ja": "このAVPは、（Hビットは0でなければならない）隠されてはなりません。このAVPのためのMビットが1に設定されるべきであるが、（セクション5.2を参照）変化してもよいです。このAVPの長さは8です。"
    },
    {
      "indent": 3,
      "text": "Pseudowire Capabilities List (SCCRQ, SCCRP)",
      "ja": "スードワイヤ機能一覧（SCCRQ、SCCRP）"
    },
    {
      "indent": 6,
      "text": "The Pseudowire Capabilities List (PW Capabilities List) AVP, Attribute Type 62, indicates the L2 payload types the sender can support. The specific payload type of a given session is identified by the Pseudowire Type AVP.",
      "ja": "スードワイヤ機能一覧（PW機能一覧）AVP、タイプ62属性は、送信者がサポートできるL2ペイロードタイプを示します。特定のセッションの特定のペイロード・タイプは、疑似回線タイプAVPによって識別されます。"
    },
    {
      "indent": 6,
      "text": "The Attribute Value field for this AVP has the following format:",
      "ja": "このAVPのためのAttribute Value分野には、以下の形式になっています。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|           PW Type 0           |             ...               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|              ...              |          PW Type N            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Defined PW types that may appear in this list are managed by IANA and will appear in associated pseudowire-specific documents for each PW type.",
      "ja": "このリストに表示されることがあります定義されたPWタイプはIANAによって管理され、各PWタイプに関連付けられた疑似回線特定の文書に表示されます。"
    },
    {
      "indent": 6,
      "text": "If a sender includes a given PW type in the PW Capabilities List AVP, the sender assumes full responsibility for supporting that particular payload, such as any payload-specific AVPs, L2-Specific Sublayer, or control messages that may be defined in the appropriate companion document.",
      "ja": "送信者がPW機能リストAVPにおける所与PWタイプが含まれている場合、送信者は、適切なコンパニオンで定義することができる任意のペイロード特有のAVP、L2特有のSublayer、または制御メッセージとして、その特定のペイロードを支持するための完全な責任を負い資料。"
    },
    {
      "indent": 6,
      "text": "This AVP MAY be hidden (the H bit MAY be 0 or 1). The M bit for this AVP SHOULD be set to 1, but MAY vary (see Section 5.2). The Length (before hiding) of this AVP is 8 octets with one PW type specified, plus 2 octets for each additional PW type.",
      "ja": "このAVPは、（Hビットが0または1でもよい）隠すことができます。このAVPのためのMビットが1に設定されるべきであるが、（セクション5.2を参照）変化してもよいです。このAVPのLength（隠れることの前の）は、指定されPWタイプの8つのオクテット、プラス各追加PWタイプの2つのオクテットです。"
    },
    {
      "indent": 3,
      "text": "Preferred Language (SCCRQ, SCCRP)",
      "ja": "優先言語（SCCRQ、SCCRP）"
    },
    {
      "indent": 6,
      "text": "The Preferred Language AVP, Attribute Type 72, provides a method for an LCCE to indicate to the peer the language in which human-readable messages it sends SHOULD be composed. This AVP contains a single language tag or language range [RFC3066].",
      "ja": "優先言語AVP、属性タイプ72は、ピアに、それが送信する人間が読めるメッセージを構成すべき言語を示すためにLCCEするための方法を提供します。このAVPは、単一言語タグまたは言語範囲[RFC3066]を含んでいます。"
    },
    {
      "indent": 6,
      "text": "The Attribute Value field for this AVP has the following format:",
      "ja": "このAVPのためのAttribute Value分野には、以下の形式になっています。"
    },
    {
      "indent": 6,
      "text": "0                   1                   2                   3\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Preferred Language... (arbitrary number of octets)\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "The Preferred Language is the indicated number of octets representing the language tag or language range, encoded in the US-ASCII charset.",
      "ja": "優先言語はUS-ASCII文字セットでエンコード言語タグまたは言語範囲を表すオクテットの示された数です。"
    },
    {
      "indent": 6,
      "text": "It is not required to send a Preferred Language AVP. If (1) an LCCE does not signify a language preference by the inclusion of this AVP in the SCCRQ or SCCRP, (2) the Preferred Language AVP is unrecognized, or (3) the requested language is not supported by the peer LCCE, the default language [RFC2277] MUST be used for all internationalized strings sent by the peer.",
      "ja": "優先言語AVPを送信するために必要とされていません。 （1）LCCEがSCCRQ、またはSCCRPでこのAVPを含めることによって言語設定を意味するものではない場合、（2）優先言語AVPは認識されていない、または（3）要求された言語は、ピアLCCEによってサポートされていません、デフォルト言語[RFC2277]は、ピアから送信されたすべての国際化された文字列を使用しなければなりません。"
    },
    {
      "indent": 6,
      "text": "This AVP MAY be hidden (the H bit MAY be 0 or 1). The M bit for this AVP SHOULD be set to 0, but MAY vary (see Section 5.2). The Length (before hiding) of this AVP is 6 plus the length of the Preferred Language.",
      "ja": "このAVPは、（Hビットが0または1でもよい）隠すことができます。このAVPのためのMビットは0に設定されるべきであるが、（セクション5.2を参照）変化してもよいです。このAVPのLength（隠れることの前の）は、希望言語の6を加えた長さです。"
    },
    {
      "indent": 0,
      "text": "5.4.4. Session Management AVPs",
      "section_title": true,
      "ja": "5.4.4。セッション管理のAVP"
    },
    {
      "indent": 3,
      "text": "Local Session ID (ICRQ, ICRP, ICCN, OCRQ, OCRP, OCCN, CDN, WEN, SLI)",
      "ja": "ローカルセッションID（ICRQ、ICRP、ICCN、OCRQ、OCRP、OCCN、CDN、WEN、SLI）"
    },
    {
      "indent": 6,
      "text": "The Local Session ID AVP (analogous to the Assigned Session ID in L2TPv2), Attribute Type 63, contains the identifier being assigned to this session by the sender.",
      "ja": "ローカルセッションID AVP（L2TPv2で割り当てられたセッションIDに類似）、タイプ63属性、識別子は送信者によってこのセッションに割り当てられているが含まれています。"
    },
    {
      "indent": 6,
      "text": "The Attribute Value field for this AVP has the following format:",
      "ja": "このAVPのためのAttribute Value分野には、以下の形式になっています。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                       Local Session ID                        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "The Local Session ID is a 4-octet non-zero unsigned integer.",
      "ja": "ローカルセッションIDは4オクテット非ゼロの符号なし整数です。"
    },
    {
      "indent": 6,
      "text": "The Local Session ID AVP establishes the two identifiers used to multiplex and demultiplex sessions between two LCCEs. Each LCCE chooses any free value it desires, and sends it to the remote LCCE using this AVP. The remote LCCE MUST then send all data packets associated with this session using this value. Additionally, for all session-oriented control messages sent after this AVP is received (e.g., ICRP, ICCN, CDN, SLI, etc.), the remote LCCE MUST echo this value in the Remote Session ID AVP.",
      "ja": "ローカルセッションID AVPは2つのLCCEsの間のセッションを多重化し、逆多重化するために使用される二つの識別子を確立します。各LCCEはそれが望む任意の自由な値を選択して、このAVPを使用してリモートLCCEに送信します。リモートLCCEは、この値を使用して、このセッションに関連付けられたすべてのデータパケットを送信しなければなりません。また、このAVPを受信した後に送信されるすべてのセッション指向制御メッセージ（例えば、ICRP、ICCN、CDN、SLI、等）のために、リモートLCCEリモートセッションID AVPでこの値をエコーし​​なければなりません。"
    },
    {
      "indent": 6,
      "text": "Note that a Session ID value is unidirectional. Because each LCCE chooses its Session ID independent of its peer LCCE, the value does not have to match in each direction for a given session.",
      "ja": "セッションIDの値が単方向であることに注意してください。各LCCEがそのピアLCCEそのセッションIDの独立を選択するので、値は、所与のセッションのために各方向に一致させる必要はありません。"
    },
    {
      "indent": 6,
      "text": "See Section 4.1 for additional information about the Session ID.",
      "ja": "セッションIDの詳細については、セクション4.1を参照してください。"
    },
    {
      "indent": 6,
      "text": "This AVP MAY be hidden (the H bit MAY be 0 or 1). The M bit for this AVP SHOULD be 1 set to 1, but MAY vary (see Section 5.2). The Length (before hiding) of this AVP is 10.",
      "ja": "このAVPは、（Hビットが0または1でもよい）隠すことができます。このAVPのためのMビットは1〜1設定しなければならないが、（セクション5.2を参照）変化してもよいです。このAVPのLength（隠れることの前の）は10です。"
    },
    {
      "indent": 3,
      "text": "Remote Session ID (ICRQ, ICRP, ICCN, OCRQ, OCRP, OCCN, CDN, WEN, SLI)",
      "ja": "リモート・セッションID（ICRQ、ICRP、ICCN、OCRQ、OCRP、OCCN、CDN、WEN、SLI）"
    },
    {
      "indent": 6,
      "text": "The Remote Session ID AVP, Attribute Type 64, contains the identifier that was assigned to this session by the peer.",
      "ja": "リモート・セッションID AVP、属性タイプ64は、ピアでこのセッションに割り当てられた識別子が含まれています。"
    },
    {
      "indent": 6,
      "text": "The Attribute Value field for this AVP has the following format:",
      "ja": "このAVPのためのAttribute Value分野には、以下の形式になっています。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      Remote Session ID                        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "The Remote Session ID is a 4-octet non-zero unsigned integer.",
      "ja": "リモート・セッションIDは、4オクテットの非ゼロの符号なし整数です。"
    },
    {
      "indent": 6,
      "text": "The Remote Session ID AVP MUST be present in all session-level control messages. The AVP's value echoes the session identifier advertised by the peer via the Local Session ID AVP. It is the same value that will be used in all transmitted data messages by this side of the session. In most cases, this identifier is sufficient for the peer to look up session-level context for this control message.",
      "ja": "リモート・セッションID AVPは、すべてのセッションレベルの制御メッセージ中に存在しなければなりません。 AVPの値は、ローカルセッションIDのAVPを経由してピアによってアドバタイズセッション識別子をエコーし​​ます。これは、セッションのこちら側によって送信されるすべてのデータメッセージに使用される値と同じです。ピアは、この制御メッセージのセッション・レベルのコンテキストをルックアップするために、ほとんどの場合、この識別子は十分です。"
    },
    {
      "indent": 6,
      "text": "When a session-level control message must be sent to the peer before the Local Session ID AVP has been received, the value of the Remote Session ID AVP MUST be set to zero. Additionally, the Local Session ID AVP (sent in a previous control message for this session) MUST be included in the control message. The peer must then use the Local Session ID AVP to perform a reverse lookup to find its session context. Session-level control messages defined in this document that might be subject to a reverse lookup by a receiving peer include the CDN, WEN, and SLI.",
      "ja": "ローカルセッションID AVPを受信した前のセッション・レベル・コントロール・メッセージをピアに送信しなければならない場合、リモート・セッションID AVPの値をゼロに設定しなければなりません。また、（このセッションの前制御メッセージで送信された）ローカルセッションID AVPは、制御メッセージに含まれなければなりません。ピアは、そのセッションコンテキストを見つけるために、逆引き参照を実行するためにローカルセッションIDのAVPを使用する必要があります。受信ピアによって逆引き参照の対象かもしれない。この文書で定義されたセッション・レベル・コントロール・メッセージはCDN、WEN、およびSLIを含みます。"
    },
    {
      "indent": 6,
      "text": "This AVP MAY be hidden (the H bit MAY be 0 or 1). The M bit for this AVP SHOULD be set to 1, but MAY vary (see Section 5.2). The Length (before hiding) of this AVP is 10.",
      "ja": "このAVPは、（Hビットが0または1でもよい）隠すことができます。このAVPのためのMビットが1に設定されるべきであるが、（セクション5.2を参照）変化してもよいです。このAVPのLength（隠れることの前の）は10です。"
    },
    {
      "indent": 3,
      "text": "Assigned Cookie (ICRQ, ICRP, OCRQ, OCRP)",
      "ja": "割り当てられたクッキー（ICRQ、ICRP、OCRQ、OCRP）"
    },
    {
      "indent": 6,
      "text": "The Assigned Cookie AVP, Attribute Type 65, contains the Cookie value being assigned to this session by the sender.",
      "ja": "割り当てられたクッキーAVP、属性タイプ65は、送信者がこのセッションに割り当てられているCookieの値が含まれています。"
    },
    {
      "indent": 6,
      "text": "The Attribute Value field for this AVP has the following format:",
      "ja": "このAVPのためのAttribute Value分野には、以下の形式になっています。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|               Assigned Cookie (32 or 64 bits) ...\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "The Assigned Cookie is a 4-octet or 8-octet random value.",
      "ja": "割り当てられたクッキーは4オクテット又は8オクテットランダム値です。"
    },
    {
      "indent": 6,
      "text": "The Assigned Cookie AVP contains the value used to check the association of a received data message with the session identified by the Session ID. All data messages sent to a peer MUST use the Assigned Cookie sent by the peer in this AVP. The value's length (0, 32, or 64 bits) is obtained by the length of the AVP.",
      "ja": "割り当てられたクッキーAVPは、セッションIDによって識別されるセッションに受信されたデータ・メッセージの関連性を確認するために使用される値を含みます。ピアに送信されるすべてのデータメッセージがこのAVP内のピアによって送信された割り当てられたクッキーを使用しなければなりません。値の長さ（0、32、または64ビット）AVPの長さによって得られます。"
    },
    {
      "indent": 6,
      "text": "A missing Assigned Cookie AVP or Assigned Cookie Value of zero length indicates that the Cookie field should not be present in any data packets sent to the LCCE sending this AVP.",
      "ja": "欠落割り当てクッキーAVPまたはゼロ長の割り当てクッキー値は、クッキーフィールドはこのAVPを送るLCCEに送信されたデータパケット内に存在すべきではないことを示しています。"
    },
    {
      "indent": 6,
      "text": "See Section 4.1 for additional information about the Assigned Cookie.",
      "ja": "割り当てられたクッキーの詳細については、セクション4.1を参照してください。"
    },
    {
      "indent": 6,
      "text": "This AVP MAY be hidden (the H bit MAY be 0 or 1). The M bit for this AVP SHOULD be set to 1, but MAY vary (see Section 5.2). The Length (before hiding) of this AVP may be 6, 10, or 14 octets.",
      "ja": "このAVPは、（Hビットが0または1でもよい）隠すことができます。このAVPのためのMビットが1に設定されるべきであるが、（セクション5.2を参照）変化してもよいです。このAVPのLength（隠れることの前の）は、6、10、または14オクテットであってもよいです。"
    },
    {
      "indent": 3,
      "text": "Serial Number (ICRQ, OCRQ)",
      "ja": "シリアル番号（ICRQ、OCRQ）"
    },
    {
      "indent": 6,
      "text": "The Serial Number AVP, Attribute Type 15, contains an identifier assigned by the LAC or LNS to this session.",
      "ja": "シリアル番号AVP、属性タイプ15は、このセッションにLACまたはLNSによって割り当てられた識別子が含まれています。"
    },
    {
      "indent": 6,
      "text": "The Attribute Value field for this AVP has the following format:",
      "ja": "このAVPのためのAttribute Value分野には、以下の形式になっています。"
    },
    {
      "indent": 6,
      "text": " 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        Serial Number                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "The Serial Number is a 32-bit value.",
      "ja": "シリアル番号は、32ビット値です。"
    },
    {
      "indent": 6,
      "text": "The Serial Number is intended to be an easy reference for administrators on both ends of a control connection to use when investigating session failure problems. Serial Numbers should be set to progressively increasing values, which are likely to be unique for a significant period of time across all interconnected LNSs and LACs.",
      "ja": "シリアル番号は、セッション失敗問題を調査するときに使用する制御接続の両端の管理者にとって容易に参照することを意図しています。シリアル番号は、徐々に相互接続されたすべてのLNSとのLAC間でかなりの期間のためにユニークである可能性が高い値を増加するように設定する必要があります。"
    },
    {
      "indent": 6,
      "text": "Note that in RFC 2661, this value was referred to as the \"Call Serial Number AVP\". It serves the same purpose and has the same attribute value and composition.",
      "ja": "RFC 2661には、この値が「コールシリアル番号AVP」と呼ばれていたことに注意してください。これは、同じ目的を果たし、同じ属性値および組成を有します。"
    },
    {
      "indent": 6,
      "text": "This AVP MAY be hidden (the H bit MAY be 0 or 1). The M bit for this AVP SHOULD be set to 0, but MAY vary (see Section 5.2). The Length (before hiding) of this AVP is 10.",
      "ja": "このAVPは、（Hビットが0または1でもよい）隠すことができます。このAVPのためのMビットは0に設定されるべきであるが、（セクション5.2を参照）変化してもよいです。このAVPのLength（隠れることの前の）は10です。"
    },
    {
      "indent": 3,
      "text": "Remote End ID (ICRQ, OCRQ)",
      "ja": "リモートエンドID（ICRQ、OCRQ）"
    },
    {
      "indent": 6,
      "text": "The Remote End ID AVP, Attribute Type 66, contains an identifier used to bind L2TP sessions to a given circuit, interface, or bridging instance. It also may be used to detect session-level ties.",
      "ja": "リモートエンドID AVP、属性タイプ66は、与えられた回路、インターフェース、またはインスタンスをブリッジにL2TPセッションをバインドするために使用される識別子が含まれています。また、セッションレベルの関係を検出するために使用することができます。"
    },
    {
      "indent": 6,
      "text": "The Attribute Value field for this AVP has the following format:",
      "ja": "このAVPのためのAttribute Value分野には、以下の形式になっています。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Remote End Identifier ... (arbitrary number of octets)\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "The Remote End Identifier field is a variable-length field whose value is unique for a given LCCE peer, as described in Section 3.3.",
      "ja": "リモートエンド識別子フィールドは、その値が3.3節で説明したように、与えられたLCCEピアに固有の可変長フィールドです。"
    },
    {
      "indent": 6,
      "text": "A session-level tie is detected if an LCCE receives an ICRQ or OCRQ with an End ID AVP whose value matches that which was just sent in an outgoing ICRQ or OCRQ to the same peer. If the two values match, an LCCE recognizes that a tie exists (i.e., both LCCEs are attempting to establish sessions for the same circuit). The tie is broken by the Session Tie Breaker AVP.",
      "ja": "LCCEが値だけ同じピアに発信ICRQまたはOCRQで送信されたものと一致するエンドID AVPと共にICRQまたはOCRQを受信した場合、セッション・レベルのネクタイが検出されます。二つの値が一致した場合、LCCEはタイ（すなわち、両方のLCCEsは、同じ回路のためのセッションを確立しようとしている）が存在することを認識する。ネクタイは、セッションタイブレークAVPによって壊されます。"
    },
    {
      "indent": 6,
      "text": "By default, the LAC-LAC cross-connect application (see Section 2(b)) of L2TP over an IP network MUST utilize the Router ID AVP and Remote End ID AVP to associate a circuit to an L2TP session. Other AVPs MAY be used for LCCE or circuit identification as specified in companion documents.",
      "ja": "デフォルトでは、LAC-LACクロスコネクトアプリケーションは、IPネットワーク上でL2TPのL2TPセッションへの回路を関連付けるためにルータID AVPとリモートエンドIDのAVPを利用しなければならない（第2節（b）参照します）。コンパニオン文書に指定されている他のAVPはLCCEか回路識別のために使用されるかもしれません。"
    },
    {
      "indent": 6,
      "text": "This AVP MAY be hidden (the H bit MAY be 0 or 1). The M bit for this AVP SHOULD be set to 1, but MAY vary (see Section 5.2). The Length (before hiding) of this AVP is 6 plus the length of the Remote End Identifier value.",
      "ja": "このAVPは、（Hビットが0または1でもよい）隠すことができます。このAVPのためのMビットが1に設定されるべきであるが、（セクション5.2を参照）変化してもよいです。このAVPのLength（隠れることの前の）は6プラスリモートエンド識別子の値の長さです。"
    },
    {
      "indent": 3,
      "text": "Session Tie Breaker (ICRQ, OCRQ)",
      "ja": "セッションタイブレーカ（ICRQ、OCRQ）"
    },
    {
      "indent": 6,
      "text": "The Session Tie Breaker AVP, Attribute Type 5, is used to break ties when two peers concurrently attempt to establish a session for the same circuit.",
      "ja": "2つのピアが同時に同じ回路のためのセッションを確立しようとすると、セッションタイブレークAVP、属性タイプ5は、ネクタイを破るために使用されています。"
    },
    {
      "indent": 6,
      "text": "The Attribute Value field for this AVP has the following format:",
      "ja": "このAVPのためのAttribute Value分野には、以下の形式になっています。"
    },
    {
      "indent": 6,
      "text": "0                   1                   2                   3\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Session Tie Breaker Value ...\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                                           ... (64 bits)        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "The Session Tie Breaker Value is an 8-octet random value that is used to choose a session when two LCCEs concurrently request a session for the same circuit. A tie is detected by examining the peer's identity (described in Section 3.3) plus the per-session shared value communicated via the End ID AVP. In the case of a tie, the recipient of an ICRQ or OCRQ must compare the received tie breaker value with the one that it sent earlier. The LCCE with the lower value \"wins\" and MUST send a CDN with result code set to 13 (as defined in Section 5.4.2) in response to the losing ICRQ or OCRQ. In the case in which a tie is detected, tie breakers are sent by both sides, and the tie breaker values are equal, both sides MUST discard their sessions and restart session negotiation with new random tie breaker values.",
      "ja": "セッションタイ・ブレーカーの値は、2つのLCCEsのが同時に同じ回路のためのセッションを要求すると、セッションを選択するために使用される8オクテットランダム値です。タイは、ピアの（セクション3.3を参照）アイデンティティプラスエンドID AVPを介して通信セッションごとの共有値を調べることにより検出されます。同点の場合には、ICRQまたはOCRQの受信者は、それが以前に送信された一つと、受信しタイブレーカ値を比較しなければなりません。低い値「勝利」とLCCEとは失うICRQまたはOCRQに応答して（セクション5.4.2で定義されるように）13に結果コードセットとCDNを送らなければなりません。タイが検出された場合には、タイブレーカは両側によって送信され、タイ・ブレーカー値が等しい、両側は、そのセッションを破棄して新たなランダムタイ・ブレーカー値とのセッションネゴシエーションを再起動する必要があります。"
    },
    {
      "indent": 6,
      "text": "If a tie is detected but only one side sends a Session Tie Breaker AVP, the session initiator that included the Session Tie Breaker AVP \"wins\". If neither side issues a tie breaker, then both sides MUST tear down the session.",
      "ja": "ネクタイは、検出されたが、片側だけでは、セッションタイブレークAVP、セッションタイブレークAVP「勝利」を含むセッションイニシエータが送信された場合。どちらの側がタイブレーカーを発行した場合、両側には、セッションを切断しなければなりません。"
    },
    {
      "indent": 6,
      "text": "This AVP MUST NOT be hidden (the H bit MUST be 0). The M bit for this AVP SHOULD be set to 1, but MAY vary (see Section 5.2). The Length of this AVP is 14.",
      "ja": "このAVPは、（Hビットは0でなければならない）隠されてはなりません。このAVPのためのMビットが1に設定されるべきであるが、（セクション5.2を参照）変化してもよいです。このAVPの長さは14です。"
    },
    {
      "indent": 3,
      "text": "Pseudowire Type (ICRQ, OCRQ)",
      "ja": "擬似回線の種類（ICRQ、OCRQ）"
    },
    {
      "indent": 6,
      "text": "The Pseudowire Type (PW Type) AVP, Attribute Type 68, indicates the L2 payload type of the packets that will be tunneled using this L2TP session.",
      "ja": "疑似回線の種類（PWタイプ）AVP、タイプ68の属性は、このL2TPセッションを使用してトンネリングされるパケットのL2ペイロードタイプを示します。"
    },
    {
      "indent": 6,
      "text": "The Attribute Value field for this AVP has the following format:",
      "ja": "このAVPのためのAttribute Value分野には、以下の形式になっています。"
    },
    {
      "indent": 6,
      "text": " 0                   1\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|           PW Type             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "A peer MUST NOT request an incoming or outgoing call with a PW Type AVP specifying a value not advertised in the PW Capabilities List AVP it received during control connection establishment. Attempts to do so MUST result in the call being rejected via a CDN with the Result Code set to 14 (see Section 5.4.2).",
      "ja": "ピアは、PWタイプAVPは、それが制御接続確立中に受信PW機能リストAVPでアドバタイズしない値を指定して、着信または発信コールを要求してはいけません。そうしようとすると、（5.4.2項を参照）を14に設定する結果コードでCDNを経由して拒否されたコールをもたらさなければなりません。"
    },
    {
      "indent": 6,
      "text": "This AVP MAY be hidden (the H bit MAY be 0 or 1). The M bit for this AVP SHOULD be set to 1, but MAY vary (see Section 5.2). The Length (before hiding) of this AVP is 8.",
      "ja": "このAVPは、（Hビットが0または1でもよい）隠すことができます。このAVPのためのMビットが1に設定されるべきであるが、（セクション5.2を参照）変化してもよいです。このAVPのLength（隠れることの前の）は8です。"
    },
    {
      "indent": 3,
      "text": "L2-Specific Sublayer (ICRQ, ICRP, ICCN, OCRQ, OCRP, OCCN)",
      "ja": "L2特有のSublayer（ICRQ、ICRP、ICCN、OCRQ、OCRP、OCCN）"
    },
    {
      "indent": 6,
      "text": "The L2-Specific Sublayer AVP, Attribute Type 69, indicates the presence and format of the L2-Specific Sublayer the sender of this AVP requires on all incoming data packets for this L2TP session.",
      "ja": "L2特有のSublayer AVPは、69属性タイプ、このAVPの送信者は、このL2TPセッションのすべての着信データパケットに必要L2特有の副層の存在およびフォーマットを示します。"
    },
    {
      "indent": 6,
      "text": " 0                   1\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   L2-Specific Sublayer Type   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "The L2-Specific Sublayer Type is a 2-octet unsigned integer with the following values defined in this document:",
      "ja": "L2特有のSublayerタイプは、この文書で定義され、以下の値を持つ2オクテットの符号なし整数です。"
    },
    {
      "indent": 9,
      "text": "0 - There is no L2-Specific Sublayer present. 1 - The Default L2-Specific Sublayer (defined in Section 4.6) is used.",
      "ja": "0  - 何のL2特有のSublayer存在はありません。 1  - （セクション4.6で定義された）デフォルトのL2特有サブレイヤが使用されます。"
    },
    {
      "indent": 6,
      "text": "If this AVP is received and has a value other than zero, the receiving LCCE MUST include the identified L2-Specific Sublayer in its outgoing data messages. If the AVP is not received, it is assumed that there is no sublayer present.",
      "ja": "このAVPを受信し、ゼロ以外の値を持っている場合は、受信LCCEは、その発信データメッセージにおいて識別されたL2特有のSublayerを含まなければなりません。 AVPが受信されない場合、何の副層が存在しないと仮定されます。"
    },
    {
      "indent": 6,
      "text": "This AVP MAY be hidden (the H bit MAY be 0 or 1). The M bit for this AVP SHOULD be set to 1, but MAY vary (see Section 5.2). The Length (before hiding) of this AVP is 8.",
      "ja": "このAVPは、（Hビットが0または1でもよい）隠すことができます。このAVPのためのMビットが1に設定されるべきであるが、（セクション5.2を参照）変化してもよいです。このAVPのLength（隠れることの前の）は8です。"
    },
    {
      "indent": 3,
      "text": "Data Sequencing (ICRQ, ICRP, ICCN, OCRQ, OCRP, OCCN)",
      "ja": "データシーケンス（ICRQ、ICRP、ICCN、OCRQ、OCRP、OCCN）"
    },
    {
      "indent": 6,
      "text": "The Data Sequencing AVP, Attribute Type 70, indicates that the sender requires some or all of the data packets that it receives to be sequenced.",
      "ja": "データシーケンスAVP、属性タイプ70は、送信者は、それが配列決定される受信データパケットの一部またはすべてが必要であることを示しています。"
    },
    {
      "indent": 6,
      "text": "The Attribute Value field for this AVP has the following format:",
      "ja": "このAVPのためのAttribute Value分野には、以下の形式になっています。"
    },
    {
      "indent": 6,
      "text": " 0                   1\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     Data Sequencing Level     |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "The Data Sequencing Level is a 2-octet unsigned integer indicating the degree of incoming data traffic that the sender of this AVP wishes to be marked with sequence numbers.",
      "ja": "データシーケンシングのレベルは、このAVPの送信者は、シーケンス番号が付けられしたいの着信データトラフィックの度合いを示す2オクテットの符号なし整数です。"
    },
    {
      "indent": 6,
      "text": "Defined Data Sequencing Levels are as follows:",
      "ja": "次のように定義されたデータシーケンシングレベルは次のとおりです。"
    },
    {
      "indent": 9,
      "text": "0 - No incoming data packets require sequencing. 1 - Only non-IP data packets require sequencing. 2 - All incoming data packets require sequencing.",
      "ja": "0  - 着信データパケットは、シーケンシングを必要としません。 1  - 唯一の非IPデータパケットは、シーケンシングが必要です。 2  - すべての着信データパケットは、シーケンシングが必要です。"
    },
    {
      "indent": 6,
      "text": "If a Data Sequencing Level of 0 is specified, there is no need to send packets with sequence numbers. If sequence numbers are sent, they will be ignored upon receipt. If no Data Sequencing AVP is received, a Data Sequencing Level of 0 is assumed.",
      "ja": "0のデータシーケンシングレベルが指定されている場合は、シーケンス番号を持つパケットを送信する必要はありません。シーケンス番号が送信される場合は、受信時に無視されます。何のデータシーケンスAVPが受信されない場合、0のデータシーケンシングレベルを想定しています。"
    },
    {
      "indent": 6,
      "text": "If a Data Sequencing Level of 1 is specified, only non-IP traffic carried within the tunneled L2 frame should have sequence numbers applied. Non-IP traffic here refers to any packets that cannot be classified as an IP packet within their respective L2 framing (e.g., a PPP control packet or NETBIOS frame encapsulated by Frame Relay before being tunneled). All traffic that can be classified as IP MUST be sent with no sequencing (i.e., the S bit in the L2- Specific Sublayer is set to zero). If a packet is unable to be classified at all (e.g., because it has been compressed or encrypted at layer 2) or if an implementation is unable to perform such classification within L2 frames, all packets MUST be provided with sequence numbers (essentially falling back to a Data Sequencing Level of 2).",
      "ja": "1のデータをシークエンシングレベルが指定されている場合は、トンネリングされたL2フレームの中に運ば唯一の非IPトラフィックは、シーケンス番号が適用されている必要があります。ここで、非IPトラフィックが（例えば、PPP制御パケットまたはNetBIOSフレームをトンネリングされる前に、フレームリレーによってカプセル化された）それぞれのL2フレーミング内のIPパケットとして分類することができないすべてのパケットを指します。 IPのように分類することができるすべてのトラフィック（すなわち、L2-特異サブレイヤにおけるSビットがゼロに設定されている）のない配列決定を用いて送信されなければなりません。パケット（それがレイヤ2で圧縮または暗号化されているため、例えば）全てに分類されることができない、または実装がL2フレーム内にこのような分類を行うことができない場合、すべてのパケットは、（シーケンス番号を備えなければならない場合、本質的にフォールバック2のデータシーケンスレベルまで）。"
    },
    {
      "indent": 6,
      "text": "If a Data Sequencing Level of 2 is specified, all traffic MUST be sequenced.",
      "ja": "2のデータシーケンシングレベルが指定されている場合は、すべてのトラフィックが、配列決定されなければなりません。"
    },
    {
      "indent": 6,
      "text": "Data sequencing may only be requested when there is an L2-Specific Sublayer present that can provide sequence numbers. If sequencing is requested without requesting a L2-Specific Sublayer AVP, the session MUST be disconnected with a Result Code of 15 (see Section 5.4.2).",
      "ja": "シーケンス番号を提供することができるL2特有のSublayerが存在した場合にデータの順序付けは、要求されてもよいです。シークエンシングは、L2特有のSublayer AVPを要求することなく、要求された場合、セッションは15の結果コードを切断する必要があります（5.4.2項を参照してください）。"
    },
    {
      "indent": 6,
      "text": "This AVP MAY be hidden (the H bit MAY be 0 or 1). The M bit for this AVP SHOULD be set to 1, but MAY vary (see Section 5.2). The Length (before hiding) of this AVP is 8.",
      "ja": "このAVPは、（Hビットが0または1でもよい）隠すことができます。このAVPのためのMビットが1に設定されるべきであるが、（セクション5.2を参照）変化してもよいです。このAVPのLength（隠れることの前の）は8です。"
    },
    {
      "indent": 3,
      "text": "Tx Connect Speed (ICRQ, ICRP, ICCN, OCRQ, OCRP, OCCN)",
      "ja": "Txの接続速度（ICRQ、ICRP、ICCN、OCRQ、OCRP、OCCN）"
    },
    {
      "indent": 6,
      "text": "The Tx Connect Speed BPS AVP, Attribute Type 74, contains the speed of the facility chosen for the connection attempt.",
      "ja": "Txの接続速度BPS AVP、属性タイプ74は、接続試行のために選ばれた施設の速さが含まれています。"
    },
    {
      "indent": 6,
      "text": "The Attribute Value field for this AVP has the following format:",
      "ja": "このAVPのためのAttribute Value分野には、以下の形式になっています。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      Connect Speed in bps...\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                  ...Connect Speed in bps (64 bits)             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "The Tx Connect Speed BPS is an 8-octet value indicating the speed in bits per second. A value of zero indicates that the speed is indeterminable or that there is no physical point-to-point link.",
      "ja": "送信接続速度BPSはbps単位で速度を示す8オクテット値です。ゼロの値は、速度が不定であること、または物理的なポイントツーポイントリンクが存在しないことを示しています。"
    },
    {
      "indent": 6,
      "text": "When the optional Rx Connect Speed AVP is present, the value in this AVP represents the transmit connect speed from the perspective of the LAC (i.e., data flowing from the LAC to the remote system). When the optional Rx Connect Speed AVP is NOT present, the connection speed between the remote system and LAC is assumed to be symmetric and is represented by the single value in this AVP.",
      "ja": "任意のRx接続スピードAVPが存在する場合、このAVPの値は、送信がLACの観点から速度を接続表す（即ち、リモート・システムにLACから流れるデータ）。任意のRx接続スピードAVPが存在しない場合、リモートシステムとLACとの間の接続速度は、対称であると仮定され、このAVPに単一の値で表されます。"
    },
    {
      "indent": 6,
      "text": "This AVP MAY be hidden (the H bit MAY be 0 or 1). The M bit for this AVP SHOULD be set to 0, but MAY vary (see Section 5.2). The Length (before hiding) of this AVP is 14.",
      "ja": "このAVPは、（Hビットが0または1でもよい）隠すことができます。このAVPのためのMビットは0に設定されるべきであるが、（セクション5.2を参照）変化してもよいです。このAVPのLength（隠れることの前の）は14です。"
    },
    {
      "indent": 3,
      "text": "Rx Connect Speed (ICRQ, ICRP, ICCN, OCRQ, OCRP, OCCN)",
      "ja": "Rxの接続速度（ICRQ、ICRP、ICCN、OCRQ、OCRP、OCCN）"
    },
    {
      "indent": 6,
      "text": "The Rx Connect Speed AVP, Attribute Type 75, represents the speed of the connection from the perspective of the LAC (i.e., data flowing from the remote system to the LAC).",
      "ja": "Rxの接続スピードAVP、属性タイプ75は、LAC（LACにリモートシステムから流れるすなわち、データ）の観点からの接続の速度を表します。"
    },
    {
      "indent": 6,
      "text": "The Attribute Value field for this AVP has the following format:",
      "ja": "このAVPのためのAttribute Value分野には、以下の形式になっています。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      Connect Speed in bps...\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                  ...Connect Speed in bps (64 bits)             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Connect Speed BPS is an 8-octet value indicating the speed in bits per second. A value of zero indicates that the speed is indeterminable or that there is no physical point-to-point link.",
      "ja": "接続スピードBPSはbps単位で速度を示す8オクテット値です。ゼロの値は、速度が不定であること、または物理的なポイントツーポイントリンクが存在しないことを示しています。"
    },
    {
      "indent": 6,
      "text": "Presence of this AVP implies that the connection speed may be asymmetric with respect to the transmit connect speed given in the Tx Connect Speed AVP.",
      "ja": "このAVPの存在は、接続速度が送信接続スピードAVPに所定の速度を接続する送信に対して非対称であってもよいことを意味します。"
    },
    {
      "indent": 6,
      "text": "This AVP MAY be hidden (the H bit MAY be 0 or 1). The M bit for this AVP SHOULD be set to 0, but MAY vary (see Section 5.2). The Length (before hiding) of this AVP is 14.",
      "ja": "このAVPは、（Hビットが0または1でもよい）隠すことができます。このAVPのためのMビットは0に設定されるべきであるが、（セクション5.2を参照）変化してもよいです。このAVPのLength（隠れることの前の）は14です。"
    },
    {
      "indent": 3,
      "text": "Physical Channel ID (ICRQ, ICRP, OCRP)",
      "ja": "物理チャネルID（ICRQ、ICRP、OCRP）"
    },
    {
      "indent": 6,
      "text": "The Physical Channel ID AVP, Attribute Type 25, contains the vendor-specific physical channel number used for a call.",
      "ja": "物理チャネルID AVP、属性タイプ25は、通話に使用ベンダー固有の物理チャンネル番号が含まれています。"
    },
    {
      "indent": 6,
      "text": "The Attribute Value field for this AVP has the following format:",
      "ja": "このAVPのためのAttribute Value分野には、以下の形式になっています。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      Physical Channel ID                      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Physical Channel ID is a 4-octet value intended to be used for logging purposes only.",
      "ja": "物理チャネルIDは、ロギング目的のみに使用されることを意図4オクテット値です。"
    },
    {
      "indent": 6,
      "text": "This AVP MAY be hidden (the H bit MAY be 0 or 1). The M bit for this AVP SHOULD be set to 0, but MAY vary (see Section 5.2). The Length (before hiding) of this AVP is 10.",
      "ja": "このAVPは、（Hビットが0または1でもよい）隠すことができます。このAVPのためのMビットは0に設定されるべきであるが、（セクション5.2を参照）変化してもよいです。このAVPのLength（隠れることの前の）は10です。"
    },
    {
      "indent": 0,
      "text": "5.4.5. Circuit Status AVPs",
      "section_title": true,
      "ja": "5.4.5。回路状態のAVP"
    },
    {
      "indent": 3,
      "text": "Circuit Status (ICRQ, ICRP, ICCN, OCRQ, OCRP, OCCN, SLI)",
      "ja": "回路状態（ICRQ、ICRP、ICCN、OCRQ、OCRP、OCCN、SLI）"
    },
    {
      "indent": 6,
      "text": "The Circuit Status AVP, Attribute Type 71, indicates the initial status of or a status change in the circuit to which the session is bound.",
      "ja": "回路状態AVP、属性タイプ71は、初期の状態やセッションがバインドされている回路内の状態変化を示しています。"
    },
    {
      "indent": 6,
      "text": "The Attribute Value field for this AVP has the following format:",
      "ja": "このAVPのためのAttribute Value分野には、以下の形式になっています。"
    },
    {
      "indent": 6,
      "text": " 0                   1\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|         Reserved          |N|A|\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "The A (Active) bit indicates whether the circuit is up/active/ready (1) or down/inactive/not-ready (0).",
      "ja": "A（アクティブ）ビットは、回路がアップ/アクティブ/レディ（1）またはダウン/（0） - 準備ができていない/非アクティブであるかどうかを示します。"
    },
    {
      "indent": 6,
      "text": "The N (New) bit indicates whether the circuit status indication is for a new circuit (1) or an existing circuit (0). Links that have a similar mechanism available (e.g., Frame Relay) MUST map the setting of this bit to the associated signaling for that link. Otherwise, the New bit SHOULD still be set the first time the L2TP session is established after provisioning.",
      "ja": "N（新規）ビットは、回路状態指示は新しい回路（1）または既存の回路（0）のためであるかどうかを示します。利用可能な同様の機構（例えば、フレーム・リレー）を有するリンクは、そのリンクに関連付けられたシグナリングにこのビットの設定をマップする必要があります。そうでない場合は、新しいビットはまだL2TPセッションがプロビジョニング後に確立された最初の時間に設定する必要があります。"
    },
    {
      "indent": 6,
      "text": "The remaining bits are reserved for future use. Reserved bits MUST be set to 0 when sending and ignored upon receipt.",
      "ja": "残りのビットは将来の使用のために予約されています。予約ビットは、送信時に0に設定し、受信時に無視しなければなりません。"
    },
    {
      "indent": 6,
      "text": "The Circuit Status AVP is used to advertise whether a circuit or interface bound to an L2TP session is up and ready to send and/or receive traffic. Different circuit types have different names for status types. For example, HDLC primary and secondary stations refer to a circuit as being \"Receive Ready\" or \"Receive Not Ready\", while Frame Relay refers to a circuit as \"Active\" or \"Inactive\". This AVP adopts the latter terminology, though the concept remains the same regardless of the PW type for the L2TP session.",
      "ja": "回路状態AVPは、L2TPセッションにバインドされた回路やインターフェースが送信および/またはトラフィックを受信するようにして準備ができているかどうかを宣伝するために使用されます。別の回路の種類は、ステータスタイプごとに異なる名前を持っています。例えば、HDLCプライマリとセカンダリの局は、フレームリレーは、「Active」または「Inactive」などの回路を指しながら、または「受信準備ができていません」「受信準備」であると回路を参照してください。コンセプトは関係なく、L2TPセッションのためのPWタイプの同じままかかわらず、このAVPは、後者の用語を採用しています。"
    },
    {
      "indent": 6,
      "text": "In the simplest case, the circuit to which this AVP refers is a single physical interface, port, or circuit, depending on the application and the session setup. The status indication in this AVP may then be used to provide simple ILMI interworking for a variety of circuit types. For virtual or multipoint interfaces, the Circuit Status AVP is still utilized, but in this case, it refers to the state of an internal structure or a logical set of circuits. Each PW-specific companion document MUST specify precisely how this AVP is translated for each circuit type.",
      "ja": "最も単純な場合では、このAVPが参照する回路は、アプリケーションとセッションセットアップに応じて、単一の物理インタフェース、ポート、または回路です。このAVPのステータス表示は、回路の様々なタイプのための単純なILMIインターワーキングを提供するために使用されてもよいです。仮想またはマルチポイントインターフェイスのため、回路状態AVPは依然として利用されるが、この場合には、内部構造の状態又は回路の論理的なセットを指します。各PW特有の仲間ドキュメントはこのAVPは、各回路タイプ用に変換する方法を正確に指定しなければなりません。"
    },
    {
      "indent": 6,
      "text": "If this AVP is received with a Not Active notification for a given L2TP session, all data traffic for that session MUST cease (or not begin) in the direction of the sender of the Circuit Status AVP until the circuit is advertised as Active.",
      "ja": "このAVPは、与えられたL2TPセッションのためにアクティブでない通知を受信した場合、そのセッションのすべてのデータトラフィックは中止しなければならない（または開始しない）回路がアクティブとして宣伝されるまでの回路状態AVPの送信元の方向に。"
    },
    {
      "indent": 6,
      "text": "The Circuit Status MUST be advertised by this AVP in ICRQ, ICRP, OCRQ, and OCRP messages. Often, the circuit type will be marked Active when initiated, but subsequently MAY be advertised as Inactive. This indicates that an L2TP session is to be created, but that the interface or circuit is still not ready to pass traffic. The ICCN, OCCN, and SLI control messages all MAY contain this AVP to update the status of the circuit after establishment of the L2TP session is requested.",
      "ja": "サーキットステータスはICRQ、ICRP、OCRQ、およびOCRPメッセージにこのAVPによってアドバタイズされなければなりません。開始時に多くの場合、回路の種類がアクティブとしてマークされますが、その後非アクティブとしてアドバタイズされるかもしれません。これは、L2TPセッションが作成されることを示しているが、インターフェースや回路がまだトラフィックを通過する準備ができていないこと。 ICCN、OCCN、およびSLI制御メッセージL2TPセッションの確立が要求された後、すべての回路の状態を更新するには、このAVPを含むかもしれません。"
    },
    {
      "indent": 6,
      "text": "If additional circuit status information is needed for a given PW type, any new PW-specific AVPs MUST be defined in a separate document. This AVP is only for general circuit status information generally applicable to all circuit/interface types.",
      "ja": "付加回路のステータス情報が与えられたPWタイプのために必要とされている場合は、任意の新しいPW特有のAVPは、別の文書で定義する必要があります。このAVPは、全ての回路/インターフェイスタイプに一般的に適用可能な一般的な回路のステータス情報のためのものです。"
    },
    {
      "indent": 6,
      "text": "This AVP MAY be hidden (the H bit MAY be 0 or 1). The M bit for this AVP SHOULD be set to 1, but MAY vary (see Section 5.2). The Length (before hiding) of this AVP is 8.",
      "ja": "このAVPは、（Hビットが0または1でもよい）隠すことができます。このAVPのためのMビットが1に設定されるべきであるが、（セクション5.2を参照）変化してもよいです。このAVPのLength（隠れることの前の）は8です。"
    },
    {
      "indent": 3,
      "text": "Circuit Errors (WEN)",
      "ja": "回路のエラー（WEN）"
    },
    {
      "indent": 6,
      "text": "The Circuit Errors AVP, Attribute Type 34, conveys circuit error information to the peer.",
      "ja": "回線エラーAVP、属性タイプ34は、ピアに回路エラー情報を伝達します。"
    },
    {
      "indent": 6,
      "text": "The Attribute Value field for this AVP has the following format:",
      "ja": "このAVPのためのAttribute Value分野には、以下の形式になっています。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-\n                               |             Reserved           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        Hardware Overruns                      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                         Buffer Overruns                       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                         Timeout Errors                        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        Alignment Errors                       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true
    },
    {
      "indent": 6,
      "text": "The following fields are defined:",
      "ja": "次のフィールドが定義されています。"
    },
    {
      "indent": 6,
      "text": "Reserved: 2 octets of Reserved data is present (providing longword alignment within the AVP of the following values). Reserved data MUST be zero on sending and ignored upon receipt. Hardware Overruns: Number of receive buffer overruns since call was established. Buffer Overruns: Number of buffer overruns detected since call was established. Timeout Errors: Number of timeouts since call was established. Alignment Errors: Number of alignment errors since call was established.",
      "ja": "予約：予約されたデータの2つのオクテットが存在している（以下の値のAVP内のロングワードアラインメントを提供します）。予約されたデータは、受信時に送信され、無視にゼロでなければなりません。ハードウェアオーバーラン：受信バッファオーバーランの数コールが確立されて以来。バッファオーバーラン：コールが確立されてから検出されたバッファオーバーランの数。タイムアウトエラー：コールが確立されてからタイムアウトの数。アラインメントエラー：コールが確立されて以来、アライメントエラーの数。"
    },
    {
      "indent": 6,
      "text": "This AVP MAY be hidden (the H bit MAY be 0 or 1). The M bit for this AVP SHOULD be set to 0, but MAY vary (see Section 5.2). The Length (before hiding) of this AVP is 32.",
      "ja": "このAVPは、（Hビットが0または1でもよい）隠すことができます。このAVPのためのMビットは0に設定されるべきであるが、（セクション5.2を参照）変化してもよいです。このAVPのLength（隠れることの前の）は32です。"
    },
    {
      "indent": 0,
      "text": "6. Control Connection Protocol Specification",
      "section_title": true,
      "ja": "6.制御接続プロトコル仕様"
    },
    {
      "indent": 3,
      "text": "The following control messages are used to establish, maintain, and tear down L2TP control connections. All data packets are sent in network order (high-order octets first). Any \"reserved\" or \"empty\" fields MUST be sent as 0 values to allow for protocol extensibility.",
      "ja": "以下の制御メッセージは、確立、維持、およびL2TPコントロール接続を切断するために使用されています。すべてのデータパケットは、ネットワーク順（上位オクテットが最初）に送信されます。任意には、「予約」または「空」のフィールドは、プロトコルの拡張を可能にするために0値として送信されなければなりません。"
    },
    {
      "indent": 3,
      "text": "The exchanges in which these messages are involved are outlined in Section 3.3.",
      "ja": "これらのメッセージが関与する取引所は3.3節で概説されています。"
    },
    {
      "indent": 0,
      "text": "6.1. Start-Control-Connection-Request (SCCRQ)",
      "section_title": true,
      "ja": "6.1。 [スタートコントロール接続要求（SCCRQ）"
    },
    {
      "indent": 3,
      "text": "Start-Control-Connection-Request (SCCRQ) is a control message used to initiate a control connection between two LCCEs. It is sent by either the LAC or the LNS to begin the control connection establishment process.",
      "ja": "起動コントロール接続要求（SCCRQ）は、2つのLCCEsの間の制御接続を開始するために使用される制御メッセージです。制御コネクション確立プロセスを開始するためにLACかLNSのどちらかによって送られます。"
    },
    {
      "indent": 3,
      "text": "The following AVPs MUST be present in the SCCRQ:",
      "ja": "次のAVPはSCCRQ中に存在している必要があります"
    },
    {
      "indent": 6,
      "text": "Message Type Host Name Router ID Assigned Control Connection ID Pseudowire Capabilities List",
      "ja": "メッセージタイプホスト名ルータID割り当てられた制御コネクションIDスードワイヤ機能一覧"
    },
    {
      "indent": 3,
      "text": "The following AVPs MAY be present in the SCCRQ:",
      "ja": "次のAVPはSCCRQに存在することがあります。"
    },
    {
      "indent": 6,
      "text": "Random Vector Control Message Authentication Nonce Message Digest Control Connection Tie Breaker Vendor Name Receive Window Size Preferred Language",
      "ja": "ランダムベクトル制御メッセージ認証ナンスメッセージダイジェスト制御接続タイブレーカベンダー名は、ウィンドウサイズ優先言語を受け取ります"
    },
    {
      "indent": 0,
      "text": "6.2. Start-Control-Connection-Reply (SCCRP)",
      "section_title": true,
      "ja": "6.2。 [スタートコントロール接続回答（SCCRP）"
    },
    {
      "indent": 3,
      "text": "Start-Control-Connection-Reply (SCCRP) is the control message sent in reply to a received SCCRQ message. The SCCRP is used to indicate that the SCCRQ was accepted and that establishment of the control connection should continue.",
      "ja": "起動コントロール接続応答（SCCRP）は受信されたSCCRQメッセージへの応答で送信された制御メッセージです。 SCCRPは、SCCRQが受け入れられたことを示すために使用されると、制御接続の確立を継続すべきです。"
    },
    {
      "indent": 3,
      "text": "The following AVPs MUST be present in the SCCRP:",
      "ja": "次のAVPはSCCRP中に存在している必要があります"
    },
    {
      "indent": 6,
      "text": "Message Type Host Name Router ID Assigned Control Connection ID Pseudowire Capabilities List",
      "ja": "メッセージタイプホスト名ルータID割り当てられた制御コネクションIDスードワイヤ機能一覧"
    },
    {
      "indent": 3,
      "text": "The following AVPs MAY be present in the SCCRP:",
      "ja": "次のAVPはSCCRPに存在することがあります。"
    },
    {
      "indent": 6,
      "text": "Random Vector Control Message Authentication Nonce Message Digest Vendor Name Receive Window Size Preferred Language",
      "ja": "ランダムベクトル制御メッセージ認証ナンスメッセージダイジェストベンダー名は、ウィンドウサイズ優先言語を受け取ります"
    },
    {
      "indent": 0,
      "text": "6.3. Start-Control-Connection-Connected (SCCCN)",
      "section_title": true,
      "ja": "6.3。 [スタートコントロール接続接続（SCCCN）"
    },
    {
      "indent": 3,
      "text": "Start-Control-Connection-Connected (SCCCN) is the control message sent in reply to an SCCRP. The SCCCN completes the control connection establishment process.",
      "ja": "起動コントロール接続接続（SCCCN）SCCRPへの応答で送信された制御メッセージです。 SCCCNは、制御コネクション確立プロセスを完了します。"
    },
    {
      "indent": 3,
      "text": "The following AVP MUST be present in the SCCCN:",
      "ja": "以下のAVPはSCCCN中に存在している必要があります"
    },
    {
      "indent": 6,
      "text": "Message Type",
      "ja": "メッセージの種類"
    },
    {
      "indent": 3,
      "text": "The following AVP MAY be present in the SCCCN:",
      "ja": "以下のAVPはSCCCNに存在することがあります。"
    },
    {
      "indent": 6,
      "text": "Random Vector Message Digest",
      "ja": "ランダムベクトルメッセージダイジェスト"
    },
    {
      "indent": 0,
      "text": "6.4. Stop-Control-Connection-Notification (StopCCN)",
      "section_title": true,
      "ja": "6.4。停止コントロール接続通知を（StopCCN）"
    },
    {
      "indent": 3,
      "text": "Stop-Control-Connection-Notification (StopCCN) is the control message sent by either LCCE to inform its peer that the control connection is being shut down and that the control connection should be closed. In addition, all active sessions are implicitly cleared (without sending any explicit session control messages). The reason for issuing this request is indicated in the Result Code AVP. There is no explicit reply to the message, only the implicit ACK that is received by the reliable control message delivery layer.",
      "ja": "停止コントロール接続通知（StopCCN）制御接続をシャットダウンし、制御接続を閉じなければならないというされていることをピアに通知するかLCCEによって送られた制御メッセージです。また、すべてのアクティブなセッションが暗黙的に（明示的なセッション制御メッセージを送信せずに）クリアされます。このリクエストを発行する理由は、結果コードAVPで示されています。メッセージ、信頼性の高い制御メッセージの配信層によって受信された唯一の暗黙のACKへの明示的な回答はありません。"
    },
    {
      "indent": 3,
      "text": "The following AVPs MUST be present in the StopCCN:",
      "ja": "次のAVPはStopCCN中に存在している必要があります"
    },
    {
      "indent": 6,
      "text": "Message Type Result Code",
      "ja": "メッセージタイプ結果コード"
    },
    {
      "indent": 3,
      "text": "The following AVPs MAY be present in the StopCCN:",
      "ja": "次のAVPはStopCCNに存在することがあります。"
    },
    {
      "indent": 6,
      "text": "Random Vector Message Digest Assigned Control Connection ID",
      "ja": "ランダムベクトルメッセージダイジェスト割り当てられた制御コネクションID"
    },
    {
      "indent": 3,
      "text": "Note that the Assigned Control Connection ID MUST be present if the StopCCN is sent after an SCCRQ or SCCRP message has been sent.",
      "ja": "StopCCNがSCCRQ、またはSCCRPメッセージが送信された後に送信された場合に割り当てられた制御コネクションIDが存在しなければならないことに注意してください。"
    },
    {
      "indent": 0,
      "text": "6.5. Hello (HELLO)",
      "section_title": true,
      "ja": "6.5。やあやあ）"
    },
    {
      "indent": 3,
      "text": "The Hello (HELLO) message is an L2TP control message sent by either peer of a control connection. This control message is used as a \"keepalive\" for the control connection. See Section 4.2 for a description of the keepalive mechanism.",
      "ja": "ハロー（ハロー）メッセージは、制御接続のどちらかのピアによって送信されたL2TP制御メッセージです。この制御メッセージは、制御接続のための「キープアライブ」として使用されています。キープアライブメカニズムの説明については、4.2節を参照してください。"
    },
    {
      "indent": 3,
      "text": "HELLO messages are global to the control connection. The Session ID in a HELLO message MUST be 0.",
      "ja": "helloメッセージは、制御接続に対してグローバルです。 HELLOメッセージのセッションIDは0でなければなりません。"
    },
    {
      "indent": 3,
      "text": "The following AVP MUST be present in the HELLO:",
      "ja": "以下のAVPは、HELLO中に存在している必要があります"
    },
    {
      "indent": 6,
      "text": "Message Type",
      "ja": "メッセージの種類"
    },
    {
      "indent": 3,
      "text": "The following AVP MAY be present in the HELLO:",
      "ja": "以下のAVPは、HELLOに存在することがあります。"
    },
    {
      "indent": 6,
      "text": "Random Vector Message Digest",
      "ja": "ランダムベクトルメッセージダイジェスト"
    },
    {
      "indent": 0,
      "text": "6.6. Incoming-Call-Request (ICRQ)",
      "section_title": true,
      "ja": "6.6。着信-要求（ICRQ）"
    },
    {
      "indent": 3,
      "text": "Incoming-Call-Request (ICRQ) is the control message sent by an LCCE to a peer when an incoming call is detected (although the ICRQ may also be sent as a result of a local event). It is the first in a three-message exchange used for establishing a session via an L2TP control connection.",
      "ja": "着信リクエスト（ICRQ）（ICRQはまた、ローカルイベントの結果として送信されても​​よいが）着信が検出された場合、ピアにLCCEによって送られた制御メッセージです。これは、L2TP制御接続を介してセッションを確立するために使用される三メッセージ交換の最初です。"
    },
    {
      "indent": 3,
      "text": "The ICRQ is used to indicate that a session is to be established between an LCCE and a peer. The sender of an ICRQ provides the peer with parameter information for the session. However, the sender makes no demands about how the session is terminated at the peer (i.e., whether the L2 traffic is processed locally, forwarded, etc.).",
      "ja": "ICRQは、セッションがLCCEとピアとの間で確立されることを示すために使用されます。 ICRQの送信者は、セッションのためのパラメータ情報を持つピアを提供します。ただし、送信者は（L2トラフィックがローカルで処理されているかどうかなど、転送、すなわち）セッションがピアで終了する方法についての要求を行うものではありません。"
    },
    {
      "indent": 3,
      "text": "The following AVPs MUST be present in the ICRQ:",
      "ja": "次のAVPはICRQ中に存在している必要があります"
    },
    {
      "indent": 6,
      "text": "Message Type Local Session ID Remote Session ID Serial Number Pseudowire Type Remote End ID Circuit Status",
      "ja": "メッセージの種類ローカルセッションIDリモート・セッションIDシリアル番号擬似回線タイプリモートエンドIDサーキットステータス"
    },
    {
      "indent": 3,
      "text": "The following AVPs MAY be present in the ICRQ:",
      "ja": "次のAVPはICRQに存在することがあります。"
    },
    {
      "indent": 6,
      "text": "Random Vector Message Digest Assigned Cookie Session Tie Breaker L2-Specific Sublayer Data Sequencing Tx Connect Speed Rx Connect Speed Physical Channel ID",
      "ja": "ランダムベクトルメッセージダイジェスト割り当てられたクッキーセッションタイブレーカL2特有の副層のデータシーケンスのTx接続速度Rxの接続速度の物理チャネルID"
    },
    {
      "indent": 0,
      "text": "6.7. Incoming-Call-Reply (ICRP)",
      "section_title": true,
      "ja": "6.7。着信-返信（ICRP）"
    },
    {
      "indent": 3,
      "text": "Incoming-Call-Reply (ICRP) is the control message sent by an LCCE in response to a received ICRQ. It is the second in the three-message exchange used for establishing sessions within an L2TP control connection.",
      "ja": "着信リプライ（ICRP）受信ICRQに応答してLCCEによって送られた制御メッセージです。これは、L2TP制御コネクション内でセッションを確立するために使用される三メッセージ交換における第です。"
    },
    {
      "indent": 3,
      "text": "The ICRP is used to indicate that the ICRQ was successful and that the peer should establish (i.e., answer) the incoming call if it has not already done so. It also allows the sender to indicate specific parameters about the L2TP session.",
      "ja": "ICRPはICRQが成功したことを示すために使用され、ピアが確立しなければならないこと（すなわち、答）それはまだ行っていない場合、着信コール。また、送信者がL2TPセッションに関する特定のパラメータを示すことができます。"
    },
    {
      "indent": 3,
      "text": "The following AVPs MUST be present in the ICRP:",
      "ja": "次のAVPは、ICRP中に存在している必要があります"
    },
    {
      "indent": 6,
      "text": "Message Type Local Session ID Remote Session ID Circuit Status",
      "ja": "メッセージタイプローカルセッションIDリモート・セッションIDサーキットステータス"
    },
    {
      "indent": 3,
      "text": "The following AVPs MAY be present in the ICRP:",
      "ja": "次のAVPは、ICRPに存在することがあります。"
    },
    {
      "indent": 6,
      "text": "Random Vector Message Digest Assigned Cookie L2-Specific Sublayer Data Sequencing Tx Connect Speed Rx Connect Speed Physical Channel ID",
      "ja": "クッキーL2特有の副層のデータシーケンスのTx接続速度Rxの接続速度の物理チャネルID割り当てられたランダムベクトルメッセージダイジェスト"
    },
    {
      "indent": 0,
      "text": "6.8. Incoming-Call-Connected (ICCN)",
      "section_title": true,
      "ja": "6.8。着信接続（ICCN）"
    },
    {
      "indent": 3,
      "text": "Incoming-Call-Connected (ICCN) is the control message sent by the LCCE that originally sent an ICRQ upon receiving an ICRP from its peer. It is the final message in the three-message exchange used for establishing L2TP sessions.",
      "ja": "着信接続（ICCN）は、もともとそのピアからICRPを受信するICRQを送ったLCCEによって送られた制御メッセージです。これは、L2TPセッションを確立するために使用される3メッセージ交換の最後のメッセージです。"
    },
    {
      "indent": 3,
      "text": "The ICCN is used to indicate that the ICRP was accepted, that the call has been established, and that the L2TP session should move to the established state. It also allows the sender to indicate specific parameters about the established call (parameters that may not have been available at the time the ICRQ was issued).",
      "ja": "ICCNは、コールが確立されたこと、ICRPが受け入れられたことを示すために使用され、L2TPセッションが確立状態に移行する必要があること。また、送信者が確立された通話（ICRQが発行された時点で入手できなかったかもしれないパラメータ）に関する特定のパラメータを示すことができます。"
    },
    {
      "indent": 3,
      "text": "The following AVPs MUST be present in the ICCN:",
      "ja": "次のAVPはICCN中に存在している必要があります"
    },
    {
      "indent": 6,
      "text": "Message Type Local Session ID Remote Session ID",
      "ja": "メッセージタイプローカルセッションIDリモート・セッションID"
    },
    {
      "indent": 3,
      "text": "The following AVPs MAY be present in the ICCN:",
      "ja": "次のAVPはICCNに存在することがあります。"
    },
    {
      "indent": 6,
      "text": "Random Vector Message Digest L2-Specific Sublayer Data Sequencing Tx Connect Speed Rx Connect Speed Circuit Status",
      "ja": "ランダムベクトルメッセージダイジェストL2特有の副層のデータシーケンスのTx接続速度Rxの接続スピードサーキットステータス"
    },
    {
      "indent": 0,
      "text": "6.9. Outgoing-Call-Request (OCRQ)",
      "section_title": true,
      "ja": "6.9。発信コール-要求（OCRQ）"
    },
    {
      "indent": 3,
      "text": "Outgoing-Call-Request (OCRQ) is the control message sent by an LCCE to an LAC to indicate that an outbound call at the LAC is to be established based on specific destination information sent in this message. It is the first in a three-message exchange used for establishing a session and placing a call on behalf of the initiating LCCE.",
      "ja": "出射コール要求（OCRQ）LACでのアウトバウンドコールは、このメッセージで送信された特定の宛先情報に基づいて確立されることを示すためにLACにLCCEによって送られた制御メッセージです。これは、セッションを確立し、開始LCCEに代わって電話をかけるために使用される3メッセージ交換で初めてです。"
    },
    {
      "indent": 3,
      "text": "Note that a call may be any L2 connection requiring well-known destination information to be sent from an LCCE to an LAC. This call could be a dialup connection to the PSTN, an SVC connection, the IP address of another LCCE, or any other destination dictated by the sender of this message.",
      "ja": "コールはLACへLCCEから送信される、周知の宛先情報を必要とする任意のL2接続であってもよいことに留意されたいです。この呼び出しは、PSTN、SVC接続、別のLCCEのIPアドレス、またはこのメッセージの送信者によって決定される他の任意の宛先へのダイヤルアップ接続であってもよいです。"
    },
    {
      "indent": 3,
      "text": "The following AVPs MUST be present in the OCRQ:",
      "ja": "次のAVPはOCRQ中に存在している必要があります"
    },
    {
      "indent": 6,
      "text": "Message Type Local Session ID Remote Session ID Serial Number Pseudowire Type Remote End ID Circuit Status",
      "ja": "メッセージの種類ローカルセッションIDリモート・セッションIDシリアル番号擬似回線タイプリモートエンドIDサーキットステータス"
    },
    {
      "indent": 3,
      "text": "The following AVPs MAY be present in the OCRQ:",
      "ja": "次のAVPはOCRQに存在することがあります。"
    },
    {
      "indent": 6,
      "text": "Random Vector Message Digest Assigned Cookie Tx Connect Speed Rx Connect Speed Session Tie Breaker L2-Specific Sublayer Data Sequencing",
      "ja": "ランダムベクトルメッセージダイジェストクッキーのTx接続速度Rxの接続スピードセッションタイブレークL2特有の副層のデータシーケンスを割り当て"
    },
    {
      "indent": 0,
      "text": "6.10. Outgoing-Call-Reply (OCRP)",
      "section_title": true,
      "ja": "6.10。発信コール-返信（OCRP）"
    },
    {
      "indent": 3,
      "text": "Outgoing-Call-Reply (OCRP) is the control message sent by an LAC to an LCCE in response to a received OCRQ. It is the second in a three-message exchange used for establishing a session within an L2TP control connection.",
      "ja": "出射コール応答（OCRP）受信OCRQに応答してLCCEにLACによって送られる制御メッセージです。これは、L2TP制御コネクション内でセッションを確立するために使用される三メッセージ交換における第です。"
    },
    {
      "indent": 3,
      "text": "OCRP is used to indicate that the LAC has been able to attempt the outbound call. The message returns any relevant parameters regarding the call attempt. Data MUST NOT be forwarded until the OCCN is received, which indicates that the call has been placed.",
      "ja": "OCRPは、LACがアウトバウンドコールを試みることができていたことを示すために使用されます。メッセージは、コールの試行に関するいかなる関連するパラメータを返します。 OCCNは、通話が置かれていることを示しており、受信されるまでのデータが転送されてはなりません。"
    },
    {
      "indent": 3,
      "text": "The following AVPs MUST be present in the OCRP:",
      "ja": "次のAVPはOCRP中に存在している必要があります"
    },
    {
      "indent": 6,
      "text": "Message Type Local Session ID Remote Session ID Circuit Status",
      "ja": "メッセージタイプローカルセッションIDリモート・セッションIDサーキットステータス"
    },
    {
      "indent": 3,
      "text": "The following AVPs MAY be present in the OCRP:",
      "ja": "次のAVPはOCRPに存在することがあります。"
    },
    {
      "indent": 6,
      "text": "Random Vector Message Digest Assigned Cookie L2-Specific Sublayer Tx Connect Speed Rx Connect Speed Data Sequencing Physical Channel ID",
      "ja": "クッキーL2特有の副層のTx接続速度Rxの接続速度のデータシーケンシング物理チャネルID割り当てられたランダムベクトルメッセージダイジェスト"
    },
    {
      "indent": 0,
      "text": "6.11. Outgoing-Call-Connected (OCCN)",
      "section_title": true,
      "ja": "6.11。発信コール接続（OCCN）"
    },
    {
      "indent": 3,
      "text": "Outgoing-Call-Connected (OCCN) is the control message sent by an LAC to another LCCE after the OCRP and after the outgoing call has been completed. It is the final message in a three-message exchange used for establishing a session.",
      "ja": "発信コール接続（OCCN）はOCRP後および発信コールが完了した後に別のLCCEにLACによって送られたコントロールメッセージです。これは、セッションを確立するために使用される3メッセージ交換の最後のメッセージです。"
    },
    {
      "indent": 3,
      "text": "OCCN is used to indicate that the result of a requested outgoing call was successful. It also provides information to the LCCE who requested the call about the particular parameters obtained after the call was established.",
      "ja": "OCCNは、要求された発信コールの結果が成功したことを示すために使用されます。また、コールが確立された後に得られた特定のパラメータについての呼び出しを要求したLCCEに情報を提供します。"
    },
    {
      "indent": 3,
      "text": "The following AVPs MUST be present in the OCCN:",
      "ja": "次のAVPはOCCN中に存在している必要があります"
    },
    {
      "indent": 6,
      "text": "Message Type Local Session ID Remote Session ID",
      "ja": "メッセージタイプローカルセッションIDリモート・セッションID"
    },
    {
      "indent": 3,
      "text": "The following AVPs MAY be present in the OCCN:",
      "ja": "次のAVPはOCCNに存在することがあります。"
    },
    {
      "indent": 6,
      "text": "Random Vector Message Digest L2-Specific Sublayer Tx Connect Speed Rx Connect Speed Data Sequencing Circuit Status",
      "ja": "ランダムベクトルメッセージダイジェストL2特有の副層のTx接続速度Rxの接続速度データシーケンシングサーキットステータス"
    },
    {
      "indent": 0,
      "text": "6.12. Call-Disconnect-Notify (CDN)",
      "section_title": true,
      "ja": "6.12。 （CDN）を呼び出し-外し-通知"
    },
    {
      "indent": 3,
      "text": "The Call-Disconnect-Notify (CDN) is a control message sent by an LCCE to request disconnection of a specific session. Its purpose is to inform the peer of the disconnection and the reason for the disconnection. The peer MUST clean up any resources, and does not send back any indication of success or failure for such cleanup.",
      "ja": "コール切断、通知（CDN）は、特定のセッションの切断を要求するためにLCCEによって送られた制御メッセージです。その目的は、断線のピアと切断理由を通知することです。ピアは、すべてのリソースをクリーンアップする必要があり、そのようなクリーンアップのための成功または失敗の兆候を返送しません。"
    },
    {
      "indent": 3,
      "text": "The following AVPs MUST be present in the CDN:",
      "ja": "次のAVPは、CDN中に存在している必要があります"
    },
    {
      "indent": 6,
      "text": "Message Type Result Code Local Session ID Remote Session ID",
      "ja": "メッセージタイプ結果コードローカルセッションIDリモート・セッションID"
    },
    {
      "indent": 3,
      "text": "The following AVP MAY be present in the CDN:",
      "ja": "以下のAVPは、CDNに存在することがあります。"
    },
    {
      "indent": 6,
      "text": "Random Vector Message Digest",
      "ja": "ランダムベクトルメッセージダイジェスト"
    },
    {
      "indent": 0,
      "text": "6.13. WAN-Error-Notify (WEN)",
      "section_title": true,
      "ja": "6.13。 WAN誤り通知（WEN）"
    },
    {
      "indent": 3,
      "text": "The WAN-Error-Notify (WEN) is a control message sent from an LAC to an LNS to indicate WAN error conditions. The counters in this message are cumulative. This message should only be sent when an error occurs, and not more than once every 60 seconds. The counters are reset when a new call is established.",
      "ja": "WAN誤り通知（WEN）WANエラー条件を示すためにLNSにLACからの制御メッセージです。このメッセージのカウンタは累積されます。このメッセージは60秒ごとに1回以上のエラーが発生した場合に送信され、そしてませんする必要があります。新しいコールが確立されたときにカウンタがリセットされます。"
    },
    {
      "indent": 3,
      "text": "The following AVPs MUST be present in the WEN:",
      "ja": "次のAVPは、WEN中に存在している必要があります"
    },
    {
      "indent": 6,
      "text": "Message Type Local Session ID Remote Session ID Circuit Errors",
      "ja": "メッセージタイプローカルセッションIDリモート・セッションIDサーキットのエラー"
    },
    {
      "indent": 3,
      "text": "The following AVP MAY be present in the WEN:",
      "ja": "以下のAVPは、WENに存在することがあります。"
    },
    {
      "indent": 6,
      "text": "Random Vector Message Digest",
      "ja": "ランダムベクトルメッセージダイジェスト"
    },
    {
      "indent": 0,
      "text": "6.14. Set-Link-Info (SLI)",
      "section_title": true,
      "ja": "6.14。セットリンク情報（SLI）"
    },
    {
      "indent": 3,
      "text": "The Set-Link-Info control message is sent by an LCCE to convey link or circuit status change information regarding the circuit associated with this L2TP session. For example, if PPP renegotiates LCP at an LNS or between an LAC and a Remote System, or if a forwarded Frame Relay VC transitions to Active or Inactive at an LAC, an SLI message SHOULD be sent to indicate this event. Precise details of when the SLI is sent, what PW type-specific AVPs must be present, and how those AVPs should be interpreted by the receiving peer are outside the scope of this document. These details should be described in the associated pseudowire-specific documents that require use of this message.",
      "ja": "セットリンクインフォ制御メッセージは、このL2TPセッションに関連付けられた回路に関するリンクや回路ステータス変更情報を伝えるためにLCCEによって送られます。 PPPは、LNSで、またはLACとリモートシステムの間でLCPを再交渉場合、転送フレームリレーVCはLACでアクティブまたは非アクティブに遷移した場合、または、SLIメッセージは、このイベントを示すために送信する必要があります。 SLIが送信されたときの正確な詳細は、どのようなPWタイプ固有のAVPが存在し、そしてそれらのAVPを受信するピアによって解釈されるべきであるどのようにこの文書の範囲外でなければなりません。これらの詳細は、このメッセージを使用する必要が関連する疑似回線固有の文書に記載する必要があります。"
    },
    {
      "indent": 3,
      "text": "The following AVPs MUST be present in the SLI:",
      "ja": "次のAVPは、SLIで存在している必要があります"
    },
    {
      "indent": 6,
      "text": "Message Type Local Session ID Remote Session ID",
      "ja": "メッセージタイプローカルセッションIDリモート・セッションID"
    },
    {
      "indent": 3,
      "text": "The following AVPs MAY be present in the SLI:",
      "ja": "次のAVPは、SLIに存在することがあります。"
    },
    {
      "indent": 6,
      "text": "Random Vector Message Digest Circuit Status",
      "ja": "ランダムベクトルメッセージダイジェストサーキットステータス"
    },
    {
      "indent": 0,
      "text": "6.15. Explicit-Acknowledgement (ACK)",
      "section_title": true,
      "ja": "6.15。明示的な応答（ACK）"
    },
    {
      "indent": 3,
      "text": "The Explicit Acknowledgement (ACK) message is used only to acknowledge receipt of a message or messages on the control connection (e.g., for purposes of updating Ns and Nr values). Receipt of this message does not trigger an event for the L2TP protocol state machine.",
      "ja": "明示的な確認応答（ACK）メッセージは、（NsとNrの値を更新する目的で、例えば）制御接続上のメッセージまたはメッセージの受信を確認するためにのみ使用されます。このメッセージの領収書はL2TPプロトコルステートマシンのイベントをトリガしません。"
    },
    {
      "indent": 3,
      "text": "A message received without any AVPs (including the Message Type AVP), is referred to as a Zero Length Body (ZLB) message, and serves the same function as the Explicit Acknowledgement. ZLB messages are only permitted when Control Message Authentication defined in Section 4.3 is not enabled.",
      "ja": "（メッセージタイプAVPを含む）任意のAVPなしで受信されたメッセージは、ゼロ長ボディ（ZLB）メッセージと呼ばれ、明示的な確認応答として同じ機能を果たしています。 4.3節で定義された制御メッセージ認証が有効になっていないときにZLBメッセージのみが許可されています。"
    },
    {
      "indent": 3,
      "text": "The following AVPs MAY be present in the ACK message:",
      "ja": "次のAVPは、ACKメッセージ内に存在することがあります。"
    },
    {
      "indent": 6,
      "text": "Message Type Message Digest",
      "ja": "メッセージタイプメッセージダイジェスト"
    },
    {
      "indent": 0,
      "text": "7. Control Connection State Machines",
      "section_title": true,
      "ja": "7.コントロール接続のステートマシン"
    },
    {
      "indent": 3,
      "text": "The state tables defined in this section govern the exchange of control messages defined in Section 6. Tables are defined for incoming call placement and outgoing call placement, as well as for initiation of the control connection itself. The state tables do not encode timeout and retransmission behavior, as this is handled in the underlying reliable control message delivery mechanism (see Section 4.2).",
      "ja": "このセクションで定義された状態テーブルは6テーブルが着信配置と発呼配置するため、並びに制御接続自体の開始のために定義されているセクションで定義された制御メッセージの交換を支配します。これは、基礎となる信頼性の高い制御メッセージ配信機構（セクション4.2を参照）で処理された状態テーブルは、タイムアウトと再送動作をコードしません。"
    },
    {
      "indent": 0,
      "text": "7.1. Malformed AVPs and Control Messages",
      "section_title": true,
      "ja": "7.1。不正な形式のAVPおよび制御メッセージ"
    },
    {
      "indent": 3,
      "text": "Receipt of an invalid or unrecoverable malformed control message SHOULD be logged appropriately and the control connection cleared to ensure recovery to a known state. The control connection may then be restarted by the initiator.",
      "ja": "無効又は回復不可能な奇形の制御メッセージの受信を適切に記録されるべきであり、制御接続は、既知の状態への回復を確実にするためにクリア。制御接続は、その後、イニシエータによって再起動されてもよいです。"
    },
    {
      "indent": 3,
      "text": "An invalid control message is defined as (1) a message that contains a Message Type marked as mandatory (see Section 5.4.1) but that is unknown to the implementation, or (2) a control message that is received in the wrong state.",
      "ja": "無効な制御メッセージは、（1）必須としてマークされたメッセージタイプを含むメッセージ（5.4.1項を参照）が、それは実装に知られていない、または間違った状態で受信された（2）制御メッセージとして定義されます。"
    },
    {
      "indent": 3,
      "text": "Examples of malformed control messages include (1) a message that has an invalid value in its header, (2) a message that contains an AVP that is formatted incorrectly or whose value is out of range, and (3) a message that is missing a required AVP. A control message with a malformed header MUST be discarded.",
      "ja": "不正な形式の制御メッセージの例は、そのヘッダ内に無効な値を有している（1）メッセージ、（2）誤ってフォーマットまたは値が範囲外であるAVPを含むメッセージ、および欠落している（3）メッセージを含みます必要なAVP。不正な形式のヘッダと制御メッセージは破棄されなければなりません。"
    },
    {
      "indent": 3,
      "text": "When possible, a malformed AVP should be treated as an unrecognized AVP (see Section 5.2). Thus, an attempt to inspect the M bit SHOULD be made to determine the importance of the malformed AVP, and thus, the severity of the malformation to the entire control message. If the M bit can be reasonably inspected within the malformed AVP and is determined to be set, then as with an unrecognized AVP, the associated session or control connection MUST be shut down. If the M bit is inspected and is found to be 0, the AVP MUST be ignored (assuming recovery from the AVP malformation is indeed possible).",
      "ja": "可能な場合、不正なAVPは認識されていないAVP（セクション5.2を参照）として扱われるべきです。これにより、Mビットを検査しようとすると、不正なAVPの重要性を決定するために行われるべきであり、全体の制御メッセージに奇形の、したがって、重症度。 Mビットは合理奇形AVP内で検査することができ、その後、認識されていないAVPと同様に、設定されると判定された場合、関連するセッションまたは制御接続がシャットダウンされなければなりません。 Mビットを検査し、0であることが判明した場合、AVPは、（AVP奇形からの回復が実際に可能であると仮定して）無視しなければなりません。"
    },
    {
      "indent": 3,
      "text": "This policy must not be considered as a license to send malformed AVPs, but rather, as a guide towards how to handle an improperly formatted message if one is received. It is impossible to list all potential malformations of a given message and give advice for each. One example of a malformed AVP situation that should be recoverable is if the Rx Connect Speed AVP is received with a length of 10 rather than 14, implying that the connect speed bits-per-second is being formatted in 4 octets rather than 8. If the AVP does not have its M bit set (as would typically be the case), this condition is not considered catastrophic. As such, the control message should be accepted as though the AVP were not present (though a local error message may be logged).",
      "ja": "このポリシーは、1が受信された場合、不適切にフォーマットされたメッセージを処理する方法に向けたガイドとして、不正な形式のAVPを送信するためのライセンスとして考えではなく、してはいけません。与えられたメッセージのすべての潜在的な奇形を一覧表示し、それぞれについての助言を与えることは不可能です。 Rxの接続スピードAVPは10よりもむしろ14の長さで受信された場合に回復可能であるべきである奇形AVP状況の一例は、場合接続速度ビット毎秒4つのオクテットではなく8でフォーマットされていることを意味（通常場合のように）、この状態は壊滅的とみなされていないAVPは、そのMビットが設定されていません。 （ローカルエラーメッセージが記録されることができるが）AVPが存在しないかのようにこのように、制御メッセージを受け入れなければなりません。"
    },
    {
      "indent": 3,
      "text": "In several cases in the following tables, a protocol message is sent, and then a \"clean up\" occurs. Note that, regardless of the initiator of the control connection destruction, the reliable delivery mechanism must be allowed to run (see Section 4.2) before destroying the control connection. This permits the control connection management messages to be reliably delivered to the peer.",
      "ja": "以下の表のいくつかの例では、プロトコルメッセージが送信され、その後、「クリーンアップ」が発生します。かかわらず、制御接続の破壊の開始の、信頼できる配信機構は制御接続を破壊する前に（セクション4.2を参照）を実行させなければならないことに留意されたいです。これは、コントロールコネクション管理メッセージが確実に相手に配信することを可能にします。"
    },
    {
      "indent": 3,
      "text": "Appendix B.1 contains an example of lock-step control connection establishment.",
      "ja": "付録B.1はロックステップ制御接続確立の例を含んでいます。"
    },
    {
      "indent": 0,
      "text": "7.2. Control Connection States",
      "section_title": true,
      "ja": "7.2。コントロールの接続状態"
    },
    {
      "indent": 3,
      "text": "The L2TP control connection protocol is not distinguishable between the two LCCEs but is distinguishable between the originator and receiver. The originating peer is the one that first initiates establishment of the control connection. (In a tie breaker situation, this is the winner of the tie.) Since either the LAC or the LNS can be the originator, a collision can occur. See the Control Connection Tie Breaker AVP in Section 5.4.3 for a description of this and its resolution.",
      "ja": "L2TPコントロール接続プロトコルは、2つのLCCEsの間で区別可能ではなく、発信者と受信機の間で区別されます。発信元ピアは、第1制御接続の確立を開始するものです。 （タイブレーカーの状況では、これは、タイの勝者である。）、LACまたはLNSのどちらかが発信することができるので、衝突が発生する可能性があります。これの説明とその解決のために、セクション5.4.3でコントロール接続タイブレークAVPを参照してください。"
    },
    {
      "indent": 3,
      "text": "State           Event              Action              New State\n-----           -----              ------              ---------\nidle            Local open         Send SCCRQ          wait-ctl-reply\n                request",
      "raw": true
    },
    {
      "indent": 3,
      "text": "idle Receive SCCRQ, Send SCCRP wait-ctl-conn acceptable",
      "ja": "SCCRQを受信アイドル、SCCRP待ち-CTL-CONN許容を送ります"
    },
    {
      "indent": 3,
      "text": "idle Receive SCCRQ, Send StopCCN, idle not acceptable clean up",
      "ja": "StopCCNを送信し、SCCRQを受信アイドル、アイドル受け入れられないクリーンアップ"
    },
    {
      "indent": 3,
      "text": "idle Receive SCCRP Send StopCCN, idle clean up",
      "ja": "SCCRPはStopCCNを送信、受信アイドル、アイドルクリーンアップ"
    },
    {
      "indent": 3,
      "text": "idle Receive SCCCN Send StopCCN, idle clean up",
      "ja": "SCCCNはStopCCNを送信、受信アイドル、アイドルクリーンアップ"
    },
    {
      "indent": 3,
      "text": "wait-ctl-reply Receive SCCRP, Send SCCCN, established acceptable send control-conn open event to waiting sessions",
      "ja": "SCCRPを受信-CTL-返事を待って、SCCCNを送信し、セッションを待っているに許容可能な送信制御-CONNオープンイベントを設立"
    },
    {
      "indent": 3,
      "text": "wait-ctl-reply Receive SCCRP, Send StopCCN, idle not acceptable clean up",
      "ja": "SCCRPを受信-CTL-返事を待って、StopCCNを送信し、アイドル状態ではない許容可能なクリーンアップ"
    },
    {
      "indent": 3,
      "text": "wait-ctl-reply Receive SCCRQ, Send SCCRP, wait-ctl-conn lose tie breaker, Clean up losing SCCRQ acceptable connection",
      "ja": "待つ-CTL-回答は、失うタイブレーカー-CTL-CONNを待って、SCCRPを送信し、SCCRQを受信SCCRQ許容接続を失っクリーンアップ"
    },
    {
      "indent": 3,
      "text": "wait-ctl-reply Receive SCCRQ, Send StopCCN, idle lose tie breaker, Clean up losing SCCRQ unacceptable connection",
      "ja": "待つ-CTL-返信をSCCRQ容認できない接続を失っクリーンアップ、StopCCN、アイドル失うタイブレーカーを送信し、SCCRQを受信"
    },
    {
      "indent": 3,
      "text": "wait-ctl-reply Receive SCCRQ, Send StopCCN for wait-ctl-reply win tie breaker losing connection",
      "ja": "待つ-CTL-回答がSCCRQを受け取り、待機-CTL-応答をStopCCNを送信し、接続を失うタイブレーカーを獲得"
    },
    {
      "indent": 3,
      "text": "wait-ctl-reply Receive SCCCN Send StopCCN, idle clean up",
      "ja": "待つ-CTL-回答がSCCCNはStopCCNを送信、受信、クリーンアップアイドル"
    },
    {
      "indent": 3,
      "text": "wait-ctl-conn Receive SCCCN, Send control-conn established acceptable open event to waiting sessions",
      "ja": "待つ-CTL-connはSCCCNを受信、制御-connがセッションを待っているに許容可能なオープンイベントを確立送ります"
    },
    {
      "indent": 3,
      "text": "wait-ctl-conn Receive SCCCN, Send StopCCN, idle not acceptable clean up",
      "ja": "待つ-CTL-connが、SCCCNを受信StopCCNを送信し、アイドル状態ではない許容可能なクリーンアップ"
    },
    {
      "indent": 3,
      "text": "wait-ctl-conn Receive SCCRQ, Send StopCCN, idle SCCRP clean up",
      "ja": "待つ-CTL-connがSCCRQを受け取り、StopCCNを送信し、アイドルSCCRPは、クリーンアップ"
    },
    {
      "indent": 3,
      "text": "established Local open Send control-conn established request open event to (new call) waiting sessions",
      "ja": "（新しいコール）待機中のセッションの確立ローカルオープン送信制御-CONN確立要求オープンイベント"
    },
    {
      "indent": 3,
      "text": "established Administrative Send StopCCN, idle control-conn clean up close event",
      "ja": "確立行政送信StopCCN、アイドル制御-CONN closeイベントをクリーンアップ"
    },
    {
      "indent": 3,
      "text": "established Receive SCCRQ, Send StopCCN, idle SCCRP, SCCCN clean up",
      "ja": "StopCCN、アイドルSCCRPを送信し、SCCRQを受け取り、SCCCNはクリーンアップ確立"
    },
    {
      "indent": 3,
      "text": "idle, Receive StopCCN Clean up idle wait-ctl-reply, wait-ctl-conn, established",
      "ja": "アイドル、StopCCNクリーンアップアイドル待機-CTL-返信を受信、待っ-CTL-CONNを設立"
    },
    {
      "indent": 3,
      "text": "The states associated with an LCCE for control connection establishment are as follows:",
      "ja": "次のように制御接続確立のためのLCCEに関連付けられている状態です。"
    },
    {
      "indent": 3,
      "text": "idle Both initiator and recipient start from this state. An initiator transmits an SCCRQ, while a recipient remains in the idle state until receiving an SCCRQ.",
      "ja": "この状態から、イニシエータと受信者の両方がスタートアイドル。受信者がSCCRQを受信するまでアイドル状態のまま開始剤は、SCCRQを送信します。"
    },
    {
      "indent": 3,
      "text": "wait-ctl-reply The originator checks to see if another connection has been requested from the same peer, and if so, handles the collision situation described in Section 5.4.3.",
      "ja": "-CTL-待つ返信別の接続が同じピアから要求されたかどうかを確認するために、発信チェックをし、もしそうであれば、5.4.3項で説明した衝突状況を処理します。"
    },
    {
      "indent": 3,
      "text": "wait-ctl-conn Awaiting an SCCCN. If the SCCCN is valid, the control connection is established; otherwise, it is torn down (sending a StopCCN with the proper result and/or error code).",
      "ja": "待つ-CTL-CONNをSCCCN待ち。 SCCCNが有効であれば、制御接続が確立されます。それ以外の場合は（適切な結果及び/又はエラーコードでStopCCNを送信）取り壊されます。"
    },
    {
      "indent": 3,
      "text": "established An established connection may be terminated by either a local condition or the receipt of a StopCCN. In the event of a local termination, the originator MUST send a StopCCN and clean up the control connection. If the originator receives a StopCCN, it MUST also clean up the control connection.",
      "ja": "確立された確立された接続は、ローカル状態またはStopCCNの受信のいずれかによって終了することができます。ローカル終了の場合には、発信元はStopCCNを送信し、制御接続をクリーンアップする必要があります。発信元がStopCCNを受信した場合、それはまた、制御接続をクリーンアップする必要があります。"
    },
    {
      "indent": 0,
      "text": "7.3. Incoming Calls",
      "section_title": true,
      "ja": "7.3。着信コール"
    },
    {
      "indent": 3,
      "text": "An ICRQ is generated by an LCCE, typically in response to an incoming call or a local event. Once the LCCE sends the ICRQ, it waits for a response from the peer. However, it may choose to postpone establishment of the call (e.g., answering the call, bringing up the circuit) until the peer has indicated with an ICRP that it will accept the call. The peer may choose not to accept the call if, for instance, there are insufficient resources to handle an additional session.",
      "ja": "ICRQは、典型的には、着信コールまたはローカルイベントに応答して、LCCEによって生成されます。 LCCEはICRQを送ると、それはピアからの応答を待ちます。しかし、ピアは、それが呼び出しを受け入れることICRPで示されるまで（例えば、回路を育て、コールに応答）呼の確立を延期することを選択することができます。ピアは、例えば、追加のセッションを処理するための十分なリソースがありますが、あればコールを受け入れるしないこともできます。"
    },
    {
      "indent": 3,
      "text": "If the peer chooses to accept the call, it responds with an ICRP. When the local LCCE receives the ICRP, it attempts to establish the call. A final call connected message, the ICCN, is sent from the local LCCE to the peer to indicate that the call states for both LCCEs should enter the established state. If the call is terminated before the peer can accept it, a CDN is sent by the local LCCE to indicate this condition.",
      "ja": "ピアがコールを受け入れることを選択した場合、それはICRPで応答します。ローカルLCCEは、ICRPを受信すると、通話を確立しようとします。最終的なコール接続メッセージ、ICCNは、両方のLCCEsのための通話状態が確立状態に入るべきであることを示すためにピアにローカルLCCEから送信されます。ピアがそれを受け入れることができる前に通話が終了した場合、CDNはこの状態を示すために、地元のLCCEによって送られます。"
    },
    {
      "indent": 3,
      "text": "When a call transitions to a \"disconnected\" or \"down\" state, the call is cleared normally, and the local LCCE sends a CDN. Similarly, if the peer wishes to clear a call, it sends a CDN and cleans up its session.",
      "ja": "「切断」または「ダウン」状態にすると、コール遷移、コールが正常にクリアされ、地元のLCCEはCDNを送信しています。ピアがコールをクリアしたい場合は同様に、それはCDNを送信し、そのセッションをクリーンアップします。"
    },
    {
      "indent": 0,
      "text": "7.3.1. ICRQ Sender States",
      "section_title": true,
      "ja": "7.3.1。 ICRQ送信者の状態"
    },
    {
      "indent": 3,
      "text": "State           Event              Action           New State\n-----           -----              ------           ---------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "idle Call signal or Initiate local wait-control-conn ready to receive control-conn incoming conn open",
      "ja": "アイドルコール信号またはローカル待機制御-CONNオープン制御-CONNの着信CONNを受信する準備ができて開始"
    },
    {
      "indent": 3,
      "text": "idle Receive ICCN, Clean up idle ICRP, CDN",
      "ja": "ICCNを受信アイドル、アイドルICRP、CDNをクリーンアップ"
    },
    {
      "indent": 3,
      "text": "wait-control- Bearer line drop Clean up idle conn or local close request",
      "ja": "待ち制御 - ベアララインドロップクリーンアップアイドルでCONNまたはローカルクローズ要求"
    },
    {
      "indent": 3,
      "text": "wait-control- control-conn-open Send ICRQ wait-reply conn",
      "ja": "待つ - コントロール - コントロール-CONN-オープン送信ICRQ待ち返信CONN"
    },
    {
      "indent": 3,
      "text": "wait-reply Receive ICRP, Send ICCN established acceptable",
      "ja": "ICRP受信返信を待って、ICCNは許容設立送ります"
    },
    {
      "indent": 3,
      "text": "wait-reply Receive ICRP, Send CDN, idle Not acceptable clean up",
      "ja": "待って返信をクリーンアップアイドル受け入れられない、CDNを送り、ICRPを受信"
    },
    {
      "indent": 3,
      "text": "wait-reply Receive ICRQ, Process as idle lose tie breaker ICRQ Recipient (Section 7.3.2)",
      "ja": "返信を待つアイドル失うタイブレークICRQ受信者（7.3.2）としてICRQ、プロセスを受信"
    },
    {
      "indent": 3,
      "text": "wait-reply Receive ICRQ, Send CDN wait-reply win tie breaker for losing session",
      "ja": "ICRQを受信返信が待って、セッションを失うためのタイブレークを獲得CDN待ち返信を送ります"
    },
    {
      "indent": 3,
      "text": "wait-reply Receive CDN, Clean up idle ICCN",
      "ja": "返信を待つCDNを受信、アイドルICCNをクリーンアップ"
    },
    {
      "indent": 3,
      "text": "wait-reply Local close Send CDN, idle request clean up",
      "ja": "待って返信ローカル近いの送信CDNを、アイドル要求はクリーンアップ"
    },
    {
      "indent": 3,
      "text": "established Receive CDN Clean up idle",
      "ja": "アイドルをCDNクリーンアップ受信確立"
    },
    {
      "indent": 3,
      "text": "established Receive ICRQ, Send CDN, idle ICRP, ICCN clean up",
      "ja": "設立はICCNは、クリーンアップ、ICRQを受信、CDNを送り、アイドルICRP"
    },
    {
      "indent": 3,
      "text": "established Local close Send CDN, idle request clean up",
      "ja": "確立ローカル近いの送信CDN、アイドル要求はクリーンアップ"
    },
    {
      "indent": 3,
      "text": "The states associated with the ICRQ sender are as follows:",
      "ja": "次のようにICRQ送信者に関連付けられた状態は、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "idle The LCCE detects an incoming call on one of its interfaces (e.g., an analog PSTN line rings, or an ATM PVC is provisioned), or a local event occurs. The LCCE initiates its control connection establishment state machine and moves to a state waiting for confirmation of the existence of a control connection.",
      "ja": "LCCEは、そのインターフェイスのいずれかに着信を検出するアイドル（例えば、アナログPSTN回線リング、またはATM PVCがプロビジョニングされている）、またはローカルイベントが発生します。 LCCEは、その制御コネクション確立ステートマシンを開始し、制御接続の有無の確認を待っている状態に移行します。"
    },
    {
      "indent": 3,
      "text": "wait-control-conn In this state, the session is waiting for either the control connection to be opened or for verification that the control connection is already open. Once an indication that the control connection has been opened is received, session control messages may be exchanged. The first of these messages is the ICRQ.",
      "ja": "待っ制御-CONN制御接続のいずれかをオープンするか、検証のための制御接続がすでに開いているため、この状態では、セッションが待機しています。制御接続が開かれたという指示を受信すると、セッション制御メッセージを交換することができます。これらのメッセージの最初はICRQです。"
    },
    {
      "indent": 3,
      "text": "wait-reply The ICRQ sender receives either (1) a CDN indicating the peer is not willing to accept the call (general error or do not accept) and moves back into the idle state, or (2) an ICRP indicating the call is accepted. In the latter case, the LCCE sends an ICCN and enters the established state.",
      "ja": "待ち返信ICRQ送信者が受信し、（1）ピアを示すCDNが呼受け入れる（一般的なエラーまたは受け入れない）望んでいないと、アイドル状態に戻って移動する、又は（2）コールを示すICRPが受け付けられ。後者の場合には、LCCEはICCNを送信し、確立された状態となります。"
    },
    {
      "indent": 3,
      "text": "established Data is exchanged over the session. The call may be cleared by any of the following: + An event on the connected interface: The LCCE sends a CDN. + Receipt of a CDN: The LCCE cleans up, disconnecting the call. + A local reason: The LCCE sends a CDN.",
      "ja": "確立されたデータは、セッション上で交換されます。 +接続インタフェース上のイベント：コールは、次のいずれかによってクリアすることができるLCCEはCDNを送ります。 + CDNの領収書：LCCEがコールを切断する、クリーンアップします。地元の理由+：LCCEはCDNを送ります。"
    },
    {
      "indent": 0,
      "text": "7.3.2. ICRQ Recipient States",
      "section_title": true,
      "ja": "7.3.2。 ICRQ受信者の状態"
    },
    {
      "indent": 3,
      "text": "State           Event              Action            New State\n-----           -----              ------            ---------\nidle            Receive ICRQ,      Send ICRP         wait-connect\n                acceptable",
      "raw": true
    },
    {
      "indent": 3,
      "text": "idle Receive ICRQ, Send CDN, idle not acceptable clean up",
      "ja": "CDNを送り、ICRQを受信アイドル、アイドル受け入れられないクリーンアップ"
    },
    {
      "indent": 3,
      "text": "idle Receive ICRP Send CDN idle clean up",
      "ja": "ICRPは、CDNのアイドルクリーンアップ送信、受信アイドル"
    },
    {
      "indent": 3,
      "text": "idle Receive ICCN Clean up idle",
      "ja": "ICCNクリーンアップ受信アイドルアイドル"
    },
    {
      "indent": 3,
      "text": "wait-connect Receive ICCN, Prepare for established acceptable data",
      "ja": "待って、接続確立許容可能なデータの準備、ICCNを受信"
    },
    {
      "indent": 3,
      "text": "wait-connect Receive ICCN, Send CDN, idle not acceptable clean up",
      "ja": "待つ-接続ICCNを受け取り、CDNを送り、アイドル受け入れられないクリーンアップ"
    },
    {
      "indent": 3,
      "text": "wait-connect Receive ICRQ, Send CDN, idle ICRP clean up",
      "ja": "待つ-接続ICRQを受信、CDNを送り、アイドルICRPは、クリーンアップ"
    },
    {
      "indent": 3,
      "text": "idle, Receive CDN Clean up idle wait-connect, established",
      "ja": "アイドル、CDNのクリーンアップ受信アイドル待機-接続、確立"
    },
    {
      "indent": 3,
      "text": "wait-connect Local close Send CDN, idle established request clean up",
      "ja": "ローカル近いの送信CDNを待ち接続、アイドル確立要求はクリーンアップ"
    },
    {
      "indent": 3,
      "text": "established Receive ICRQ, Send CDN, idle ICRP, ICCN clean up",
      "ja": "設立はICCNは、クリーンアップ、ICRQを受信、CDNを送り、アイドルICRP"
    },
    {
      "indent": 3,
      "text": "The states associated with the ICRQ recipient are as follows:",
      "ja": "次のようにICRQの受信者に関連付けられた状態は、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "idle An ICRQ is received. If the request is not acceptable, a CDN is sent back to the peer LCCE, and the local LCCE remains in the idle state. If the ICRQ is acceptable, an ICRP is sent. The session moves to the wait-connect state.",
      "ja": "受信されたICRQアイドル。要求が受け入れられない場合、CDNは、ピアLCCEに送り返され、そしてローカルLCCEは、アイドル状態のままにされています。 ICRQが許容される場合は、ICRPが送信されます。セッションが待機接続状態に移行します。"
    },
    {
      "indent": 3,
      "text": "wait-connect The local LCCE is waiting for an ICCN from the peer. Upon receipt of the ICCN, the local LCCE moves to established state.",
      "ja": "-待つ接続ローカルLCCEがピアからICCNを待っています。 ICCNを受信すると、ローカルLCCEが確立状態に移行します。"
    },
    {
      "indent": 3,
      "text": "established The session is terminated either by sending a CDN or by receiving a CDN from the peer. Clean up follows on both sides regardless of the initiator.",
      "ja": "セッションがCDNを送ることによって、またはピアからCDNを受信することによってのいずれかで終了する確立。クリーンアップに関係なく、開始剤の両側に従います。"
    },
    {
      "indent": 0,
      "text": "7.4. Outgoing Calls",
      "section_title": true,
      "ja": "7.4。発信コール"
    },
    {
      "indent": 3,
      "text": "Outgoing calls instruct an LAC to place a call. There are three messages for outgoing calls: OCRQ, OCRP, and OCCN. An LCCE first sends an OCRQ to an LAC to request an outgoing call. The LAC MUST respond to the OCRQ with an OCRP once it determines that the proper facilities exist to place the call and that the call is administratively authorized. Once the outbound call is connected, the LAC sends an OCCN to the peer indicating the final result of the call attempt.",
      "ja": "発信コールは、電話をかけるためにLACを指示します。 OCRQ、OCRP、およびOCCN：発信通話のための3件のメッセージがあります。 LCCEは最初の発信コールを要求するために、LACにOCRQを送信します。それは適切な施設が電話をかけるために存在していることや、コールが管理権限を与えていると判断したら、LACはOCRPでOCRQに反応しなければなりません。アウトバウンドコールが接続されると、LACは、呼試行の最終結果を示すピアにOCCNを送信します。"
    },
    {
      "indent": 0,
      "text": "7.4.1. OCRQ Sender States",
      "section_title": true,
      "ja": "7.4.1。 OCRQ送信者の状態"
    },
    {
      "indent": 3,
      "text": "State          Event              Action            New State\n-----          -----              ------            ---------\nidle           Local open         Initiate local    wait-control-conn\n               request            control-conn-open",
      "raw": true
    },
    {
      "indent": 3,
      "text": "idle Receive OCCN, Clean up idle OCRP",
      "ja": "アイドルのクリーンアップ、OCCNを受信アイドルOCRP"
    },
    {
      "indent": 3,
      "text": "wait-control- control-conn-open Send OCRQ wait-reply conn",
      "ja": "待つ - コントロール - コントロール-CONN-オープン送信OCRQ待ち返信CONN"
    },
    {
      "indent": 3,
      "text": "wait-reply Receive OCRP, none wait-connect acceptable",
      "ja": "待って返信をOCRPを受信、どれも許容待機接続"
    },
    {
      "indent": 3,
      "text": "wait-reply Receive OCRP, Send CDN, idle not acceptable clean up",
      "ja": "待って返信をクリーンアップアイドル受け入れられない、CDNを送り、OCRPを受信"
    },
    {
      "indent": 3,
      "text": "wait-reply Receive OCCN Send CDN, idle clean up",
      "ja": "待って返信をクリーンアップアイドル、OCCNはCDNを送信、受信"
    },
    {
      "indent": 3,
      "text": "wait-reply Receive OCRQ, Process as idle lose tie breaker OCRQ Recipient (Section 7.4.2)",
      "ja": "返信を待つアイドル失うタイブレークOCRQ受信者（7.4.2）としてOCRQ、プロセスを受信"
    },
    {
      "indent": 3,
      "text": "wait-reply Receive OCRQ, Send CDN wait-reply win tie breaker for losing session",
      "ja": "OCRQを受信返信が待って、セッションを失うためのタイブレークを獲得CDN待ち返信を送ります"
    },
    {
      "indent": 3,
      "text": "wait-connect Receive OCCN none established",
      "ja": "待つ-接続OCCNのどれも確立していない受信"
    },
    {
      "indent": 3,
      "text": "wait-connect Receive OCRQ, Send CDN, idle OCRP clean up",
      "ja": "待つ-接続OCRQを受信、CDNを送り、アイドルOCRPは、クリーンアップ"
    },
    {
      "indent": 3,
      "text": "idle, Receive CDN Clean up idle wait-reply, wait-connect, established",
      "ja": "アイドル、待って、接続し、CDNのクリーンアップアイドル待機返信を受信確立"
    },
    {
      "indent": 3,
      "text": "established Receive OCRQ, Send CDN, idle OCRP, OCCN clean up",
      "ja": "OCRQを受信、CDNを送り、アイドルOCRP、OCCNはクリーンアップ確立"
    },
    {
      "indent": 3,
      "text": "wait-reply, Local close Send CDN, idle wait-connect, request clean up established wait-control- Local close Clean up idle conn request",
      "ja": "待って返信、ローカル近いの送信CDN、アイドル待機-接続を確立ウェイトコントロール - ローカルクローズクリーンアップアイドルCONN要求をクリーンアップ要求"
    },
    {
      "indent": 3,
      "text": "The states associated with the OCRQ sender are as follows:",
      "ja": "次のようにOCRQ送信者に関連付けられた状態は、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "idle, wait-control-conn When an outgoing call request is initiated, a control connection is created as described above, if not already present. Once the control connection is established, an OCRQ is sent to the LAC, and the session moves into the wait-reply state.",
      "ja": "まだ存在しない場合は、上記のようなアイドルは、待って制御-CONNを発信要求が開始されると、制御接続が作成されます。制御接続が確立されると、OCRQをLACに送信され、セッションが待機応答状態に移行します。"
    },
    {
      "indent": 3,
      "text": "wait-reply If a CDN is received, the session is cleaned up and returns to idle state. If an OCRP is received, the call is in progress, and the session moves to the wait-connect state.",
      "ja": "-待つ返信CDNを受信した場合、セッションはクリーンアップおよびアイドル状態に戻ります。 OCRPを受信した場合、呼び出しが進行中であり、そしてセッションが待機接続状態に移行します。"
    },
    {
      "indent": 3,
      "text": "wait-connect If a CDN is received, the session is cleaned up and returns to idle state. If an OCCN is received, the call has succeeded, and the session may now exchange data.",
      "ja": "-待つ接続CDNを受信した場合、セッションはクリーンアップおよびアイドル状態に戻ります。 OCCNを受信した場合、呼び出しが成功した、とのセッションは現在、データを交換することができます。"
    },
    {
      "indent": 3,
      "text": "established If a CDN is received, the session is cleaned up and returns to idle state. Alternatively, if the LCCE chooses to terminate the session, it sends a CDN to the LAC, cleans up the session, and moves the session to idle state.",
      "ja": "CDNを受信した場合に確立、セッションはクリーンアップおよびアイドル状態に戻ります。あるいは、LCCEは、セッションを終了することを選択した場合、それはLACにCDNを送信し、セッションをクリーンアップし、アイドル状態にセッションを移動させます。"
    },
    {
      "indent": 0,
      "text": "7.4.2. OCRQ Recipient (LAC) States",
      "section_title": true,
      "ja": "7.4.2。 OCRQ受信者（LAC）州"
    },
    {
      "indent": 3,
      "text": "State           Event              Action            New State\n-----           -----              ------            ---------\nidle            Receive OCRQ,      Send OCRP,        wait-cs-answer\n                acceptable         Place call",
      "raw": true
    },
    {
      "indent": 3,
      "text": "idle Receive OCRQ, Send CDN, idle not acceptable clean up",
      "ja": "CDNを送り、OCRQを受信アイドル、アイドル受け入れられないクリーンアップ"
    },
    {
      "indent": 3,
      "text": "idle Receive OCRP Send CDN, idle clean up",
      "ja": "OCRPは、CDNを送信、受信アイドル、クリーンアップアイドル"
    },
    {
      "indent": 3,
      "text": "idle Receive OCCN, Clean up idle CDN",
      "ja": "、OCCNを受信アイドルアイドルCDNをクリーンアップ"
    },
    {
      "indent": 3,
      "text": "wait-cs-answer Call placement Send OCCN established successful",
      "ja": "コールの配置-CS-回答を待つOCCNが成功確立送ります"
    },
    {
      "indent": 3,
      "text": "wait-cs-answer Call placement Send CDN, idle failed clean up",
      "ja": "コールの配置CDNを送る-CS-回答待って、アイドルはクリーンアップに失敗しました"
    },
    {
      "indent": 3,
      "text": "wait-cs-answer Receive OCRQ, Send CDN, idle OCRP, OCCN clean up",
      "ja": "、CDNを送り、アイドルOCRPをOCRQを受信、OCCNはクリーンアップ-CS-答えを待ちます"
    },
    {
      "indent": 3,
      "text": "established Receive OCRQ, Send CDN, idle OCRP, OCCN clean up",
      "ja": "OCRQを受信、CDNを送り、アイドルOCRP、OCCNはクリーンアップ確立"
    },
    {
      "indent": 3,
      "text": "wait-cs-answer, Receive CDN Clean up idle established",
      "ja": "待つ-CS-答え、CDNのクリーンアップ受信アイドル設立"
    },
    {
      "indent": 3,
      "text": "wait-cs-answer, Local close Send CDN, idle established request clean up",
      "ja": "待つ-CS-答え、地元近くの送信CDN、アイドル確立要求がクリーンアップ"
    },
    {
      "indent": 3,
      "text": "The states associated with the LAC for outgoing calls are as follows:",
      "ja": "次のように発信コールのためのLACと関連する状態は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "idle If the OCRQ is received in error, respond with a CDN. Otherwise, place the call, send an OCRP, and move to the wait-cs-answer state.",
      "ja": "OCRQが誤って受信されたアイドル場合は、CDNで応答します。そうでない場合は、電話をかけるOCRPを送信し、待機-CS-回答ステートに移行します。"
    },
    {
      "indent": 3,
      "text": "wait-cs-answer If the call is not completed or a timer expires while waiting for the call to complete, send a CDN with the appropriate error condition set, and go to idle state. If a circuit-switched connection is established, send an OCCN indicating success, and go to established state.",
      "ja": "待つ-CS-答えを呼び出しが完了または呼び出しは、完了し、適切なエラー条件を設定してCDNを送信し、アイドル状態に行くことを待っている間にタイマーが満了していない場合。回線交換接続が確立されている場合は、成功を示すOCCNを送信し、確立状態になります。"
    },
    {
      "indent": 3,
      "text": "established If the LAC receives a CDN from the peer, the call MUST be released via appropriate mechanisms, and the session cleaned up. If the call is disconnected because the circuit transitions to a \"disconnected\" or \"down\" state, the LAC MUST send a CDN to the peer and return to idle state.",
      "ja": "LACは、ピアからのCDNを受信した場合に確立し、通話が適切なメカニズムを介して放出されなければならない、とのセッションがクリーンアップ。 「切断」または「ダウン」状態への回路の遷移は、LACは、ピアにCDNを送信し、アイドル状態に戻らなければならないので、呼が切断された場合。"
    },
    {
      "indent": 0,
      "text": "7.5. Termination of a Control Connection",
      "section_title": true,
      "ja": "7.5。コントロール接続の終了"
    },
    {
      "indent": 3,
      "text": "The termination of a control connection consists of either peer issuing a StopCCN. The sender of this message SHOULD wait a full control message retransmission cycle (e.g., 1 + 2 + 4 + 8 ... seconds) for the acknowledgment of this message before releasing the control information associated with the control connection. The recipient of this message should send an acknowledgment of the message to the peer, then release the associated control information.",
      "ja": "制御接続の終了はStopCCNを発行ピアのいずれかから成ります。このメッセージの送信者は、制御接続に関連する制御情報を解放する前に、このメッセージの受信確認のための完全な制御メッセージの再送周期（例えば、1 + 2 + 4 + 8 ...秒）待機しなければなりません。このメッセージの受信者は、その後、関連する制御情報を解放し、ピアにメッセージの確認応答を送信すべきです。"
    },
    {
      "indent": 3,
      "text": "When to release a control connection is an implementation issue and is not specified in this document. A particular implementation may use whatever policy is appropriate for determining when to release a control connection. Some implementations may leave a control connection open for a period of time or perhaps indefinitely after the last session for that control connection is cleared. Others may choose to disconnect the control connection immediately after the last call on the control connection disconnects.",
      "ja": "制御接続を解除した場合、実装上の問題であり、この文書で指定されていません。特定の実装では、制御接続を解放するときを決定するための適切でどのポリシーを使用してもよいです。その制御接続のための最後のセッションがクリアされた後、一部の実装では、一定期間、または、おそらく無期限にオープン制御接続を残すことができます。その他は、制御接続が切断の最後の呼び出しの直後に制御接続を切断することもできます。"
    },
    {
      "indent": 0,
      "text": "8. Security Considerations",
      "section_title": true,
      "ja": "8.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "This section addresses some of the security issues that L2TP encounters in its operation.",
      "ja": "このセクションでは、L2TPは、その動作中に遭遇したセキュリティ問題の一部に対処しています。"
    },
    {
      "indent": 0,
      "text": "8.1. Control Connection Endpoint and Message Security",
      "section_title": true,
      "ja": "8.1。制御接続のエンドポイントとメッセージセキュリティ"
    },
    {
      "indent": 3,
      "text": "If a shared secret (password) exists between two LCCEs, it may be used to perform a mutual authentication between the two LCCEs, and construct an authentication and integrity check of arriving L2TP control messages. The mechanism provided by L2TPv3 is described in Section 4.3 and in the definition of the Message Digest and Control Message Authentication Nonce AVPs in Section 5.4.1.",
      "ja": "共有シークレット（パスワード）は、2つのLCCEsの間に存在する場合、二つのLCCEsの間で相互認証を実行し、L2TP制御メッセージを到着の認証と整合性チェックを構築するために使用することができます。 L2TPv3のによって提供されるメカニズムは、セクション5.4.1でセクション4.3およびメッセージダイジェストと制御メッセージ認証ノンスのAVPの定義に記載されています。"
    },
    {
      "indent": 3,
      "text": "This control message security mechanism provides for (1) mutual endpoint authentication, and (2) individual control message integrity and authenticity checking. Mutual endpoint authentication ensures that an L2TPv3 control connection is only established between two endpoints that are configured with the proper password. The individual control message and integrity check guards against accidental or intentional packet corruption (i.e., those caused by a control message spoofing or man-in-the-middle attack).",
      "ja": "この制御メッセージのセキュリティメカニズムは、（1）相互エンドポイント認証を提供し、そして（2）個々の制御メッセージの完全性及び真正性をチェックします。相互エンドポイント認証は、L2TPv3の制御接続が唯一正しいパスワードが設定されている2つのエンドポイント間で確立されることを保証します。偶発的または意図的なパケット破損に対する個別の制御メッセージと整合性チェックガード（すなわち、制御メッセージのなりすましや中間者攻撃によって引き起こされたもの）。"
    },
    {
      "indent": 3,
      "text": "The shared secret that is used for all control connection, control message, and AVP security features defined in this document never needs to be sent in the clear between L2TP tunnel endpoints.",
      "ja": "この文書で定義されたすべての制御接続、制御メッセージ、およびAVPセキュリティ機能に使用される共有秘密は決してL2TPトンネルエンドポイント間で平文で送信する必要はありません。"
    },
    {
      "indent": 0,
      "text": "8.2. Data Packet Spoofing",
      "section_title": true,
      "ja": "8.2。データパケットスプーフィング"
    },
    {
      "indent": 3,
      "text": "Packet spoofing for any type of Virtual Private Network (VPN) protocol is of particular concern as insertion of carefully constructed rogue packets into the VPN transit network could result in a violation of VPN traffic separation, leaking data into a customer VPN. This is complicated by the fact that it may be particularly difficult for the operator of the VPN to even be aware that it has become a point of transit into or between customer VPNs.",
      "ja": "仮想プライベートネットワーク（VPN）プロトコルのいずれかのタイプのパケットスプーフィングは、顧客のVPNにデータを漏洩し、VPNトラフィックの分離に違反する可能性がありVPNのトランジットネットワークに慎重に構築し、不正なパケットの挿入として特に懸念されます。これは、VPNのオペレータでも、それが顧客のVPNにまたはの間の通過のポイントとなっていることを意識することは特に難しいかもしれないという事実によって複雑になります。"
    },
    {
      "indent": 3,
      "text": "L2TPv3 provides traffic separation for its VPNs via a 32-bit Session ID in the L2TPv3 data header. When present, the L2TPv3 Cookie (described in Section 4.1), provides an additional check to ensure that an arriving packet is intended for the identified session. Thus, use of a Cookie with the Session ID provides an extra guarantee that the Session ID lookup was performed properly and that the Session ID itself was not corrupted in transit.",
      "ja": "L2TPv3のは、L2TPv3のデータヘッダ内の32ビットのセッションIDを介して、そのVPNのトラフィック分離を提供します。存在する場合、（4.1節を参照）のL2TPv3クッキーは、到着したパケットが特定のセッションのために意図されていることを確認するための追加のチェックを提供します。このように、セッションIDを持つクッキーの使用は、セッションIDの検索が適切に実行されたことと、セッションID自体が輸送中に破損していないという余分な保証を提供します。"
    },
    {
      "indent": 3,
      "text": "In the presence of a blind packet spoofing attack, the Cookie may also provide security against inadvertent leaking of frames into a customer VPN. To illustrate the type of security that it is provided in this case, consider comparing the validation of a 64-bit Cookie in the L2TPv3 header to the admission of packets that match a given source and destination IP address pair. Both the source and destination IP address pair validation and Cookie validation consist of a fast check on cleartext header information on all arriving packets. However, since L2TPv3 uses its own value, it removes the requirement for one to maintain a list of (potentially several) permitted or denied IP addresses, and moreover, to guard knowledge of the permitted IP addresses from hackers who may obtain and spoof them. Further, it is far easier to change a compromised L2TPv3 Cookie than a compromised IP address,\" and a cryptographically random [RFC1750] value is far less likely to be discovered by brute-force attacks compared to an IP address.",
      "ja": "ブラインドパケットスプーフィング攻撃の存在下で、クッキーはまた、顧客のVPNへのフレームの不注意による漏洩に対するセキュリティを提供することができます。それは、この場合に提供されるセキュリティのタイプを示すために、所与の送信元および宛先IPアドレス対と一致するパケットの入場へのL2TPv3ヘッダ中の64ビットのクッキーの検証を比較検討します。送信元および宛先IPアドレス対の検証とクッキー検証の両方が、すべての到着するパケットに平文のヘッダ情報に簡易チェックから成ります。 L2TPv3のは、独自の値を使用していますので、それは（潜在的にいくつか）のリストを維持するために、いずれかの要件を削除し、それらを取得し、なりすますことがハッカーから許可されたIPアドレスの知識を守るため、さらに許可または拒否されたIPアドレスを、と。さらに、侵害IPアドレスよりも妥協しL2TPv3のクッキーを変更することがはるかに簡単です」と、暗号ランダム[RFC1750]の値は、はるかに少ない可能性が高いIPアドレスに比べてブルートフォース攻撃によって発見されます。"
    },
    {
      "indent": 3,
      "text": "For protection against brute-force, blind, insertion attacks, a 64- bit Cookie MUST be used with all sessions. A 32-bit Cookie is vulnerable to brute-force guessing at high packet rates, and as such, should not be considered an effective barrier to blind insertion attacks (though it is still useful as an additional verification of a successful Session ID lookup). The Cookie provides no protection against a sophisticated man-in-the-middle attacker who can sniff and correlate captured data between nodes for use in a coordinated attack.",
      "ja": "ブルートフォース、ブラインド、挿入攻撃に対する保護のために、64ビットのCookieは、すべてのセッションで使用しなければなりません。 32ビット・クッキーは、高いパケットレートで推測力をブルートに対して脆弱であり、（それがまだ成功したセッションIDルックアップの追加検証として有用であるが）のような、ブラインド挿入攻撃に対して有効な障壁と考えるべきではありません。クッキーは嗅ぐと協調し、攻撃に使用するために、ノード間のキャプチャしたデータを関連付けることができ、洗練されたのman-in-the-middle攻撃に対する保護を提供していません。"
    },
    {
      "indent": 3,
      "text": "The Assigned Cookie AVP is used to signal the value and size of the Cookie that must be present in all data packets for a given session. Each Assigned Cookie MUST be selected in a cryptographically random manner [RFC1750] such that a series of Assigned Cookies does not provide any indication of what a future Cookie will be.",
      "ja": "割り当てられたクッキーAVPは、所与のセッションのすべてのデータパケットに存在しなければならないクッキーの値とサイズをシグナリングするために使用されます。各クッキーは暗号ランダムに選択されなければならない割り当てクッキー一連の将来クッキーがどうなるかのいずれかの指示を提供しないように[RFC1750]を割り当てられました。"
    },
    {
      "indent": 3,
      "text": "The L2TPv3 Cookie must not be regarded as a substitute for security such as that provided by IPsec when operating over an open or untrusted network where packets may be sniffed, decoded, and correlated for use in a coordinated attack. See Section 4.1.3 for more information on running L2TP over IPsec.",
      "ja": "L2TPv3のクッキーは、このようなパケットは、傍受復号化、および協調攻撃での使用のために相関させることができる開いているか、信頼できないネットワーク上で動作しているときにIPsecによって提供されるようなセキュリティのための代替と見なされてはなりません。 IPsecの上でL2TPを実行しているの詳細については、セクション4.1.3を参照してください。"
    },
    {
      "indent": 0,
      "text": "9. Internationalization Considerations",
      "section_title": true,
      "ja": "9.国際化に関する注意事項"
    },
    {
      "indent": 3,
      "text": "The Host Name and Vendor Name AVPs are not internationalized. The Vendor Name AVP, although intended to be human-readable, would seem to fit in the category of \"globally visible names\" [RFC2277] and so is represented in US-ASCII.",
      "ja": "ホスト名とベンダー名のAVPは、国際化されていません。ベンダー名AVPは、人間が読めることを意図したものの、「世界的に目に見える名前」[RFC2277]の範疇に収まるように思われるので、US-ASCIIで表現されます。"
    },
    {
      "indent": 3,
      "text": "If (1) an LCCE does not signify a language preference by the inclusion of a Preferred Language AVP (see Section 5.4.3) in the",
      "ja": "（1）LCCEは、優先言語AVPを含めることによって、言語設定を意味するものではない場合に（セクション5.4.3参照）"
    },
    {
      "indent": 3,
      "text": "SCCRQ or SCCRP, (2) the Preferred Language AVP is unrecognized, or (3) the requested language is not supported by the peer LCCE, the default language [RFC2277] MUST be used for all internationalized strings sent by the peer.",
      "ja": "（2）優先言語AVPが認識され、または（3）要求された言語がピアLCCEによってサポートされていないSCCRQ、またはSCCRPは、デフォルト言語[RFC2277]は、ピアによって送信されたすべての国際化された文字列のために使用されなければなりません。"
    },
    {
      "indent": 0,
      "text": "10. IANA Considerations",
      "section_title": true,
      "ja": "10. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document defines a number of \"magic\" numbers to be maintained by the IANA. This section explains the criteria used by the IANA to assign additional numbers in each of these lists. The following subsections describe the assignment policy for the namespaces defined elsewhere in this document.",
      "ja": "この文書は、IANAによって維持される「マジック」番号の数を定義します。このセクションでは、これらの各リストに追加番号を割り当てるためにIANAによって使用される基準を説明しています。以下のサブセクションでは、この文書の他の場所で定義された名前空間の割り当てポリシーを記述する。"
    },
    {
      "indent": 3,
      "text": "Sections 10.1 through 10.3 are requests for new values already managed by IANA according to [RFC3438].",
      "ja": "セクション10.1 10.3までは、すでに[RFC3438]によると、IANAが管理し、新たな価値のための要求です。"
    },
    {
      "indent": 3,
      "text": "The remaining sections are for new registries that have been added to the existing L2TP registry and are maintained by IANA accordingly.",
      "ja": "残りのセクションでは、既存のL2TPレジストリに追加され、それに応じてIANAによって維持され、新しいレジストリのためのものです。"
    },
    {
      "indent": 0,
      "text": "10.1. Control Message Attribute Value Pairs (AVPs)",
      "section_title": true,
      "ja": "10.1。制御メッセージの属性値ペア（AVPの）"
    },
    {
      "indent": 3,
      "text": "This number space is managed by IANA as per [RFC3438].",
      "ja": "この番号のスペースは[RFC3438]あたりとしてIANAによって管理されています。"
    },
    {
      "indent": 3,
      "text": "A summary of the new AVPs follows:",
      "ja": "新しいのAVPの概要は、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Control Message Attribute Value Pairs",
      "ja": "制御メッセージ属性値ペア"
    },
    {
      "indent": 6,
      "text": "Attribute\nType        Description\n---------   ------------------",
      "raw": true
    },
    {
      "indent": 9,
      "text": "58 Extended Vendor ID AVP 59 Message Digest 60 Router ID 61 Assigned Control Connection ID 62 Pseudowire Capabilities List 63 Local Session ID 64 Remote Session ID 65 Assigned Cookie 66 Remote End ID 68 Pseudowire Type 69 L2-Specific Sublayer 70 Data Sequencing 71 Circuit Status 72 Preferred Language 73 Control Message Authentication Nonce 74 Tx Connect Speed 75 Rx Connect Speed",
      "ja": "58拡張ベンダーID AVP 59メッセージダイジェスト60ルータID 61割り当てられた制御コネクションID 62のスードワイヤ機能一覧63ローカルセッションID 64リモート・セッションID 65割り当てられたクッキー66リモートエンドID 68擬似回線タイプ69 L2特有の副層70のデータシーケンス71回線ステータス72優先言語73制御メッセージ認証ナンス74 Txの接続速度75 Rxの接続速度"
    },
    {
      "indent": 0,
      "text": "10.2. Message Type AVP Values",
      "section_title": true,
      "ja": "10.2。メッセージタイプAVP値"
    },
    {
      "indent": 3,
      "text": "This number space is managed by IANA as per [RFC3438]. There is one new message type, defined in Section 3.1, that was allocated for this specification:",
      "ja": "この番号のスペースは[RFC3438]あたりとしてIANAによって管理されています。この仕様のために割り当てられたセクション3.1で定義された1つの新しいメッセージタイプは、あります："
    },
    {
      "indent": 3,
      "text": "Message Type AVP (Attribute Type 0) Values\n------------------------------------------",
      "raw": true
    },
    {
      "indent": 5,
      "text": "Control Connection Management",
      "ja": "コントロール接続管理"
    },
    {
      "indent": 9,
      "text": "20 (ACK) Explicit Acknowledgement",
      "ja": "20（ACK）明示的な確認応答"
    },
    {
      "indent": 0,
      "text": "10.3. Result Code AVP Values",
      "section_title": true,
      "ja": "10.3。コードAVP値の結果"
    },
    {
      "indent": 3,
      "text": "This number space is managed by IANA as per [RFC3438].",
      "ja": "この番号のスペースは[RFC3438]あたりとしてIANAによって管理されています。"
    },
    {
      "indent": 3,
      "text": "New Result Code values for the CDN message are defined in Section 5.4. The following is a summary:",
      "ja": "CDNメッセージのための新しい結果コード値は、5.4節で定義されています。以下は要約です："
    },
    {
      "indent": 3,
      "text": "Result Code AVP (Attribute Type 1) Values\n-----------------------------------------",
      "raw": true
    },
    {
      "indent": 6,
      "text": "General Error Codes",
      "ja": "一般的なエラーコード"
    },
    {
      "indent": 9,
      "text": "13 - Session not established due to losing tie breaker (L2TPv3). 14 - Session not established due to unsupported PW type (L2TPv3). 15 - Session not established, sequencing required without valid L2-Specific Sublayer (L2TPv3). 16 - Finite state machine error or timeout.",
      "ja": "13  - によるタイ・ブレーカー（のL2TPv3）を失うことに確立されていないセッション。 14  - セッションがないため、サポートされていないPWタイプ（L2TPv3の）を設立しました。 15  - セッション確立していない、有効なL2特有の副層（L2TPv3の）せずに必要なシーケンシング。 16  - 有限状態機械誤りかタイムアウト。"
    },
    {
      "indent": 0,
      "text": "10.4. AVP Header Bits",
      "section_title": true,
      "ja": "10.4。 AVPヘッダービット"
    },
    {
      "indent": 3,
      "text": "This is a new registry for IANA to maintain.",
      "ja": "これはIANAが維持するための新しいレジストリです。"
    },
    {
      "indent": 3,
      "text": "Leading Bits of the L2TP AVP Header\n-----------------------------------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "There six bits at the beginning of the L2TP AVP header. New bits are assigned via Standards Action [RFC2434].",
      "ja": "そこL2TP AVPヘッダの先頭に6ビット。新しいビットが標準アクション[RFC2434]を経由して割り当てられます。"
    },
    {
      "indent": 3,
      "text": "Bit 0 - Mandatory (M bit) Bit 1 - Hidden (H bit) Bit 2 - Reserved Bit 3 - Reserved Bit 4 - Reserved Bit 5 - Reserved",
      "ja": "ビット0  - 必須（Mビット）ビット1  - 隠し（Hビット）ビット2  - 予約済みビット3  - 予約ビット4  - 予約ビット5  - 予約"
    },
    {
      "indent": 0,
      "text": "10.5. L2TP Control Message Header Bits",
      "section_title": true,
      "ja": "10.5。 L2TPコントロールメッセージヘッダビット"
    },
    {
      "indent": 3,
      "text": "This is a new registry for IANA to maintain.",
      "ja": "これはIANAが維持するための新しいレジストリです。"
    },
    {
      "indent": 3,
      "text": "Leading Bits of the L2TP Control Message Header\n-----------------------------------------------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "There are 12 bits at the beginning of the L2TP Control Message Header. Reserved bits should only be defined by Standard Action [RFC2434].",
      "ja": "L2TPコントロールメッセージヘッダの先頭の12ビットがあります。予約ビットは、標準アクション[RFC2434]で定義されるべきです。"
    },
    {
      "indent": 3,
      "text": "Bit 0 - Message Type (T bit) Bit 1 - Length Field is Present (L bit) Bit 2 - Reserved Bit 3 - Reserved Bit 4 - Sequence Numbers Present (S bit) Bit 5 - Reserved Bit 6 - Offset Field is Present [RFC2661] Bit 7 - Priority Bit (P bit) [RFC2661] Bit 8 - Reserved Bit 9 - Reserved Bit 10 - Reserved Bit 11 - Reserved",
      "ja": "ビット0  - メッセージタイプ（Tビット）のビット1  - 長さフィールドが存在する（Lビット）のビット2  - 予約済みビット3  - 予約ビット4  - 現在のシーケンス番号（Sビット）ビット5  - リザーブビット6  - フィールドは、[存在するオフセットRFC2661]ビット7  - 優先順位ビット（Pビット）[RFC2661]ビット8  - 予約ビット9  - 予約ビット10  - 予約ビット11  - 予約"
    },
    {
      "indent": 0,
      "text": "10.6. Pseudowire Types",
      "section_title": true,
      "ja": "10.6。擬似回線の種類"
    },
    {
      "indent": 3,
      "text": "This is a new registry for IANA to maintain, there are no values assigned within this document to maintain.",
      "ja": "これはIANAが維持するために、維持するために、この文書の中に割り当てられた値が存在しない新しいレジストリです。"
    },
    {
      "indent": 3,
      "text": "L2TPv3 Pseudowire Types\n-----------------------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The Pseudowire Type (PW Type, see Section 5.4) is a 2-octet value used in the Pseudowire Type AVP and Pseudowire Capabilities List AVP defined in Section 5.4.3. 0 to 32767 are assignable by Expert Review [RFC2434], while 32768 to 65535 are assigned by a First Come First Served policy [RFC2434]. There are no specific pseudowire types assigned within this document. Each pseudowire-specific document must allocate its own PW types from IANA as necessary.",
      "ja": "疑似回線の種類（PWタイプは、セクション5.4を参照）は、セクション5.4.3で定義された疑似タイプAVPと疑似回線の能力リストAVPで使用される2オクテット値です。 32768 65535には、最初に来る最初に役立ったポリシー[RFC2434]で割り当てられている間に32767から0には、専門家レビュー[RFC2434]によって割り当て可能です。この文書の中に割り当てられた特定の疑似回線の種類がありません。各疑似回線固有のドキュメントには、必要に応じて、IANAから独自のPWタイプを割り当てる必要があります。"
    },
    {
      "indent": 0,
      "text": "10.7. Circuit Status Bits",
      "section_title": true,
      "ja": "10.7。回路ステータスビット"
    },
    {
      "indent": 3,
      "text": "This is a new registry for IANA to maintain.",
      "ja": "これはIANAが維持するための新しいレジストリです。"
    },
    {
      "indent": 3,
      "text": "Circuit Status Bits\n-------------------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The Circuit Status field is a 16-bit mask, with the two low order bits assigned. Additional bits may be assigned by IETF Consensus [RFC2434].",
      "ja": "回路状態フィールドは、割り当てられた2つの下位ビットと、16ビット・マスクです。追加のビットは、IETFコンセンサス[RFC2434]によって割り当てられてもよいです。"
    },
    {
      "indent": 3,
      "text": "Bit 14 - New (N bit) Bit 15 - Active (A bit)",
      "ja": "ビット14  - 新しい（Nビット）のビット15  - アクティブ（ビット）"
    },
    {
      "indent": 0,
      "text": "10.8. Default L2-Specific Sublayer bits",
      "section_title": true,
      "ja": "10.8。デフォルトL2特有のSublayerビット"
    },
    {
      "indent": 3,
      "text": "This is a new registry for IANA to maintain.",
      "ja": "これはIANAが維持するための新しいレジストリです。"
    },
    {
      "indent": 3,
      "text": "Default L2-Specific Sublayer Bits\n---------------------------------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The Default L2-Specific Sublayer contains 8 bits in the low-order portion of the header. Reserved bits may be assigned by IETF Consensus [RFC2434].",
      "ja": "デフォルトL2特有のサブレイヤは、ヘッダの下位部分に8ビットを含みます。予約ビットはIETFコンセンサス[RFC2434]によって割り当てられてもよいです。"
    },
    {
      "indent": 3,
      "text": "Bit 0 - Reserved Bit 1 - Sequence (S bit) Bit 2 - Reserved Bit 3 - Reserved Bit 4 - Reserved Bit 5 - Reserved Bit 6 - Reserved Bit 7 - Reserved",
      "ja": "ビット0  - 予約ビット1  - シーケンス（Sビット）ビット2  - 予約済みビット3  - 予約ビット4  - 予約ビット5  - リザーブビット6  - 予約ビット7  - 予約"
    },
    {
      "indent": 0,
      "text": "10.9. L2-Specific Sublayer Type",
      "section_title": true,
      "ja": "10.9。 L2特有の副層タイプ"
    },
    {
      "indent": 3,
      "text": "This is a new registry for IANA to maintain.",
      "ja": "これはIANAが維持するための新しいレジストリです。"
    },
    {
      "indent": 3,
      "text": "L2-Specific Sublayer Type\n-------------------------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The L2-Specific Sublayer Type is a 2-octet unsigned integer. Additional values may be assigned by Expert Review [RFC2434].",
      "ja": "L2特有のSublayerタイプ2オクテットの符号なし整数です。追加の値は、専門家レビュー[RFC2434]によって割り当てられることができます。"
    },
    {
      "indent": 3,
      "text": "0 - No L2-Specific Sublayer 1 - Default L2-Specific Sublayer present",
      "ja": "0  - なしL2特有のSublayer 1  - デフォルトL2特有のSublayer存在"
    },
    {
      "indent": 0,
      "text": "10.10. Data Sequencing Level",
      "section_title": true,
      "ja": "10.10。データシーケンシングレベル"
    },
    {
      "indent": 3,
      "text": "This is a new registry for IANA to maintain.",
      "ja": "これはIANAが維持するための新しいレジストリです。"
    },
    {
      "indent": 3,
      "text": "Data Sequencing Level\n---------------------",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The Data Sequencing Level is a 2-octet unsigned integer Additional values may be assigned by Expert Review [RFC2434].",
      "ja": "データシーケンシングレベルは追加の値は、専門家レビュー[RFC2434]によって割り当てられることが2オクテットの符号なし整数です。"
    },
    {
      "indent": 3,
      "text": "0 - No incoming data packets require sequencing. 1 - Only non-IP data packets require sequencing. 2 - All incoming data packets require sequencing.",
      "ja": "0  - 着信データパケットは、シーケンシングを必要としません。 1  - 唯一の非IPデータパケットは、シーケンシングが必要です。 2  - すべての着信データパケットは、シーケンシングが必要です。"
    },
    {
      "indent": 0,
      "text": "11. References",
      "section_title": true,
      "ja": "11.参考文献"
    },
    {
      "indent": 0,
      "text": "11.1. Normative References",
      "section_title": true,
      "ja": "11.1。引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2277] Alvestrand, H., \"IETF Policy on Character Sets and Languages\", BCP 18, RFC 2277, January 1998.",
      "ja": "[RFC2277] Alvestrand、H.、 \"文字セットと言語のIETF方針\"、BCP 18、RFC 2277、1998年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC2434] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations section in RFCs\", BCP 26, RFC 2434, October 1998.",
      "ja": "[RFC2434] Narten氏、T.とH. Alvestrand、 \"RFCsにIANA問題部に書くためのガイドライン\"、BCP 26、RFC 2434、1998年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC2473] Conta, A. and S. Deering, \"Generic Packet Tunneling in IPv6 Specification\", RFC 2473, December 1998.",
      "ja": "[RFC2473]コンタ、A.、およびS.デアリング、 \"IPv6の仕様の汎用パケットトンネリング\"、RFC 2473、1998年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC2661] Townsley, W., Valencia, A., Rubens, A., Pall, G., Zorn, G., and Palter, B., \"Layer Two Tunneling Layer Two Tunneling Protocol (L2TP)\", RFC 2661, August 1999.",
      "ja": "[RFC2661] Townsley、W.、バレンシア、A.、ルーベンス、A.、ポール、G.、ゾルン、G.、及びPalter、B.、 \"レイヤ2トンネリングレイヤ2トンネリングプロトコル（L2TP）\"、RFC 2661、 1999年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC2865] Rigney, C., Willens, S., Rubens, A., and W. Simpson, \"Remote Authentication Dial In User Service (RADIUS)\", RFC 2865, June 2000.",
      "ja": "[RFC2865] Rigney、C.、ウィレンス、S.、ルーベン、A.、およびW.シンプソン、RFC 2865、2000年6月 \"ユーザーサービス（RADIUS）でリモート認証ダイヤル\"。"
    },
    {
      "indent": 3,
      "text": "[RFC3066] Alvestrand, H., \"Tags for the Identification of Languages\", BCP 47, RFC 3066, January 2001.",
      "ja": "[RFC3066] Alvestrand、H.、 \"言語識別のためのタグ\"、BCP 47、RFC 3066、2001年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC3193] Patel, B., Aboba, B., Dixon, W., Zorn, G., and Booth, S., \"Securing L2TP using IPsec\", RFC 3193, November 2001.",
      "ja": "[RFC3193]パテル、B.、Aboba、B.、ディクソン、W.、ゾルン、G.、及びブース、S.、 \"IPsecを使用してセキュリティ保護L2TP\"、RFC 3193、2001年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC3438] Townsley, W., \"Layer Two Tunneling Protocol (L2TP) Internet Assigned Numbers Authority (IANA) Considerations Update\", BCP 68, RFC 3438, December 2002.",
      "ja": "[RFC3438] Townsley、W.、 \"レイヤ2トンネリングプロトコル（L2TP）IANA（Internet Assigned Numbers Authority）の考慮事項更新\"、BCP 68、RFC 3438、2002年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC3629] Yergeau, F., \"UTF-8, a transformation format of ISO 10646\", STD 63, RFC 3629, November 2003.",
      "ja": "[RFC3629] Yergeau、F.、 \"UTF-8、ISO 10646の変換フォーマット\"、STD 63、RFC 3629、2003年11月。"
    },
    {
      "indent": 0,
      "text": "11.2. Informative References",
      "section_title": true,
      "ja": "11.2。参考文献"
    },
    {
      "indent": 3,
      "text": "[RFC1034] Mockapetris, P., \"Domain Names - Concepts and Facilities\", STD 13, RFC 1034, November 1987.",
      "ja": "[RFC1034] Mockapetris、P.、 \"ドメイン名 - 概念および機能\"、STD 13、RFC 1034、1987年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC1191] Mogul, J. and S. Deering, \"Path MTU Discovery\", RFC 1191, November 1990.",
      "ja": "[RFC1191]モーグル、J.およびS.デアリング、 \"パスMTUディスカバリ\"、RFC 1191、1990年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC1321] Rivest, R., \"The MD5 Message-Digest Algorithm\", RFC 1321, April 1992.",
      "ja": "[RFC1321]のRivest、R.、 \"MD5メッセージダイジェストアルゴリズム\"、RFC 1321、1992年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC1661] Simpson, W., Ed., \"The Point-to-Point Protocol (PPP)\", STD 51, RFC 1661, July 1994.",
      "ja": "[RFC1661]シンプソン、W.、編、 \"ポイントツーポイントプロトコル（PPP）\"、STD 51、RFC 1661、1994年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC1700] Reynolds, J. and Postel, J., \"Assigned Numbers\", STD 2, RFC 1700, October 1994.",
      "ja": "[RFC1700]レイノルズ、J.およびポステル、J.、 \"割り当て番号\"、STD 2、RFC 1700、1994年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC1750] Eastlake, D., Crocker, S., and Schiller, J., \"Randomness Recommendations for Security\", RFC 1750, December 1994.",
      "ja": "[RFC1750]イーストレイク、D.、クロッカー、S.、シラー、J.、 \"セキュリティのためのランダム性に関する推奨事項\"、RFC 1750、1994年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC1958] Carpenter, B., Ed., \"Architectural Principles of the Internet\", RFC 1958, June 1996.",
      "ja": "[RFC1958]大工、B.、エド。、 \"インターネットの建築原則\"、RFC 1958、1996年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC1981] McCann, J., Deering, S., and Mogul, J., \"Path MTU Discovery for IP version 6\", RFC 1981, August 1996.",
      "ja": "[RFC1981]マッキャン、J.、デアリング、S.、および、RFC 1981ムガール人、J.、 \"IPバージョン6のパスMTUディスカバリー\"、1996年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC2072] Berkowitz, H., \"Router Renumbering Guide\", RFC 2072, January 1997.",
      "ja": "[RFC2072]バーコウィッツ、H.、 \"ルータリナンバリングガイド\"、RFC 2072、1997年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC2104] Krawczyk, H., Bellare, M., and Canetti, R., \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, February 1997.",
      "ja": "[RFC2104] Krawczyk、H.、ベラー、M.、およびカネッティ、R.、 \"HMAC：メッセージ認証のための鍵付きハッシュ化\"、RFC 2104、1997年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC2341] Valencia, A., Littlewood, M., and Kolar, T., \"Cisco Layer Two Forwarding (Protocol) L2F\", RFC 2341, May 1998.",
      "ja": "[RFC2341]バレンシア、A.、リトルウッド、M.、およびコーラール、T.、 \"シスコレイヤ二フォワーディング（プロトコル）L2F\"、RFC 2341、1998年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC2401] Kent, S. and Atkinson, R., \"Security Architecture for the Internet Protocol\", RFC 2401, November 1998.",
      "ja": "[RFC2401]ケント、S.とアトキンソン、R.、「インターネットプロトコルのためのセキュリティー体系」、RFC2401、1998年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC2581] Allman, M., Paxson, V., and Stevens, W., \"TCP Congestion Control\", RFC 2581, April 1999.",
      "ja": "[RFC2581]オールマン、M.、パクソン、V.、およびスティーブンス、W.、 \"TCP輻輳制御\"、RFC 2581、1999年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC2637] Hamzeh, K., Pall, G., Verthein, W., Taarud, J., Little, W., and Zorn, G., \"Point-to-Point Tunneling Protocol (PPTP)\", RFC 2637, July 1999.",
      "ja": "[RFC2637] Hamzeh、K.、ポール、G.、Verthein、W.、Taarud、J.、リトル、W.、及びゾルン、G.、 \"ポイントツーポイントトンネリングプロトコル（PPTP）\"、RFC 2637、 1999年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC2732] Hinden, R., Carpenter, B., and Masinter, L., \"Format for Literal IPv6 Addresses in URL's\", RFC 2732, December 1999.",
      "ja": "[RFC2732] HindenとR.、大工、B.、およびMasinter、L.、 \"URLの中にリテラルIPv6アドレスのフォーマット\"、RFC 2732、1999年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC2809] Aboba, B. and Zorn, G., \"Implementation of L2TP Compulsory Tunneling via RADIUS\", RFC 2809, April 2000.",
      "ja": "[RFC2809] Aboba、B.及びゾルン、G.、 \"RADIUSを介してL2TP強制トンネリングの実装\"、RFC 2809、2000年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC3070] Rawat, V., Tio, R., Nanji, S., and Verma, R., \"Layer Two Tunneling Protocol (L2TP) over Frame Relay\", RFC 3070, February 2001.",
      "ja": "[RFC3070] \"フレームリレー上のレイヤ2トンネリングプロトコル（L2TP）\" Rawat、V.、ティオ、R.、蘭芝、S.、およびバーマ、R.、RFC 3070、2001年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC3355] Singh, A., Turner, R., Tio, R., and Nanji, S., \"Layer Two Tunnelling Protocol (L2TP) Over ATM Adaptation Layer 5 (AAL5)\", RFC 3355, August 2002.",
      "ja": "[RFC3355]シン、A.、ターナー、R.、ティオ、R.、および蘭芝、S.、 \"レイヤ2トンネリングプロトコル（L2TP）ATMオーバーアダプテーションレイヤ5（AAL5）\"、RFC 3355、2002年8月。"
    },
    {
      "indent": 3,
      "text": "[KPS] Kaufman, C., Perlman, R., and Speciner, M., \"Network Security: Private Communications in a Public World\", Prentice Hall, March 1995, ISBN 0-13-061466-1.",
      "ja": "[KPS]カウフマン、C.、パールマン、R.、およびSpeciner、M.、 \"ネットワークセキュリティ：公共世界のプライベート・コミュニケーションズ\"、プレンティス・ホール、1995年3月、ISBN 0-13-061466-1。"
    },
    {
      "indent": 3,
      "text": "[STEVENS] Stevens, W. Richard, \"TCP/IP Illustrated, Volume I: The Protocols\", Addison-Wesley Publishing Company, Inc., March 1996, ISBN 0-201-63346-9.",
      "ja": "[STEVENS]スティーブンス、W.リチャード、 \"TCP / IPイラスト、ボリュームI：プロトコル\"、アディソン・ウェズリー出版社、1996年3月、ISBN 0-201-63346-9。"
    },
    {
      "indent": 0,
      "text": "12. Acknowledgments",
      "section_title": true,
      "ja": "12.謝辞"
    },
    {
      "indent": 3,
      "text": "Many of the protocol constructs were originally defined in, and the text of this document began with, RFC 2661, \"L2TPv2\". RFC 2661 authors are W. Townsley, A. Valencia, A. Rubens, G. Pall, G. Zorn and B. Palter.",
      "ja": "プロトコル構築物の多くは、もともとで定義されていた、そしてこの文書のテキストは、RFC 2661、「L2TPv2」、始まりました。 RFC 2661本の著者はW. Townsley、A.バレンシア、A.ルーベンス、G.ポール、G.ソーンとB. Palterです。"
    },
    {
      "indent": 3,
      "text": "The basic concept for L2TP and many of its protocol constructs were adopted from L2F [RFC2341] and PPTP [RFC2637]. Authors of these versions are A. Valencia, M. Littlewood, T. Kolar, K. Hamzeh, G. Pall, W. Verthein, J. Taarud, W. Little, and G. Zorn.",
      "ja": "L2TPそのプロトコル構築物の多くのための基本的な概念は、L2F [RFC2341]とPPTP [RFC2637]から採用しました。これらのバージョンの著者はA.バレンシア、M.リトル、T.コーラール、K. Hamzeh、G.ポール、W. Verthein、J. Taarud、W.リトル、およびG.ゾルンあります。"
    },
    {
      "indent": 3,
      "text": "Danny Mcpherson and Suhail Nanji published the first \"L2TP Service Type\" version, which defined the use of L2TP for tunneling of various L2 payload types (initially, Ethernet and Frame Relay).",
      "ja": "ダニー・マクファーソンとSuhail蘭芝は、様々なL2ペイロードタイプ（最初は、イーサネットおよびフレームリレー）のトンネリングのためのL2TPの使用を定義された最初の「L2TPサービスタイプ」バージョンを、発表しました。"
    },
    {
      "indent": 3,
      "text": "The team for splitting RFC 2661 into this base document and the companion PPP document consisted of Ignacio Goyret, Jed Lau, Bill Palter, Mark Townsley, and Madhvi Verma. Skip Booth also provided very helpful review and comment.",
      "ja": "この基本文書とコンパニオンPPPの文書に分割するRFC 2661のためのチームはイグナシオGoyret、ジェド・ラウ、ビルPalter、マークTownsley、およびMadhviバーマから成っていました。ブースにも非常に役立つレビューとコメントを提供スキップします。"
    },
    {
      "indent": 3,
      "text": "Some constructs of L2TPv3 were based in part on UTI (Universal Transport Interface), which was originally conceived by Peter Lothberg and Tony Bates.",
      "ja": "L2TPv3の一部の構築物は、もともとピーター・ロスバーグとトニー・ベイツによって考え出されたUTI（ユニバーサル・トランスポート・インタフェース）、に部分的に基づいていました。"
    },
    {
      "indent": 3,
      "text": "Stewart Bryant and Simon Barber provided valuable input for the L2TPv3 over IP header.",
      "ja": "スチュワートブライアントとSimonバーバーは、IPヘッダ上のL2TPv3のための貴重な入力を提供しました。"
    },
    {
      "indent": 3,
      "text": "Juha Heinanen provided helpful review in the early stages of this effort.",
      "ja": "ユハHeinanenは、この取り組みの初期段階で役に立つのレビューを提供します。"
    },
    {
      "indent": 3,
      "text": "Jan Vilhuber, Scott Fluhrer, David McGrew, Scott Wainner, Skip Booth and Maria Dos Santos contributed to the Control Message Authentication Mechanism as well as general discussions of security.",
      "ja": "ヤンVilhuber、スコットFluhrer、デビッドマグリュー、スコット・ワイナー、スキップブースとマリア・ドス・サントスは、制御メッセージ認証メカニズムだけでなく、セキュリティの一般的な議論に貢献しました。"
    },
    {
      "indent": 3,
      "text": "James Carlson, Thomas Narten, Maria Dos Santos, Steven Bellovin, Ted Hardie, and Pekka Savola provided very helpful review of the final versions of text.",
      "ja": "ジェームズ・カールソン、トーマスNarten氏、マリア・ドス・サントス、スティーブンBellovin氏、テッドハーディー、およびペッカSavolaは、テキストの最終版の非常に有用なレビューを提供します。"
    },
    {
      "indent": 3,
      "text": "Russ Housley provided valuable review and comment on security, particularly with respect to the Control Message Authentication mechanism.",
      "ja": "ラスHousleyは特に制御メッセージ認証メカニズムに関して、セキュリティ上の貴重なレビューとコメントを提供しました。"
    },
    {
      "indent": 3,
      "text": "Pekka Savola contributed to proper alignment with IPv6 and inspired much of Section 4.1.4 on fragmentation.",
      "ja": "ペッカSavolaは、IPv6との適切なアライメントに貢献し、断片化のセクション4.1.4の多くに影響を与えました。"
    },
    {
      "indent": 3,
      "text": "Aside of his original influence and co-authorship of RFC 2661, Glen Zorn helped get all of the language and character references straight in this document.",
      "ja": "彼の本来の影響力とRFC 2661の共著のはさておき、グレンツォルンは、ストレート、この文書で言語と文字参照のすべてを取得助けました。"
    },
    {
      "indent": 3,
      "text": "A number of people provided valuable input and effort for RFC 2661, on which this document was based:",
      "ja": "人々の数は、この文書が基になったRFC 2661のための貴重な入力と労力を、提供します。"
    },
    {
      "indent": 3,
      "text": "John Bray, Greg Burns, Rich Garrett, Don Grosser, Matt Holdrege, Terry Johnson, Dory Leifer, and Rich Shea provided valuable input and review at the 43rd IETF in Orlando, FL, which led to improvement of the overall readability and clarity of RFC 2661.",
      "ja": "ジョン・ブレイ、グレッグ・バーンズ、リッチ・ギャレット、ドン・グローサー、マット・ホールドレッジは、テリー・ジョンソン、ドーリーLeifer、およびリッチシアバターは、R​​FCの全体的な読みやすさと明確性の改善につながったオーランド、フロリダ州、第43回IETFでの貴重な入力とレビューを提供しました2661。"
    },
    {
      "indent": 3,
      "text": "Thomas Narten provided a great deal of critical review and formatting. He wrote the first version of the IANA Considerations section.",
      "ja": "トーマスNarten氏は、重要な見直しや書式設定の多くを提供します。彼は、IANAの考慮事項セクションの最初のバージョンを書きました。"
    },
    {
      "indent": 3,
      "text": "Dory Leifer made valuable refinements to the protocol definition of L2TP and contributed to the editing of early versions leading to RFC 2661.",
      "ja": "ドーリーLeiferは、L2TPのプロトコル定義に貴重な改良を行い、RFC 2661につながる初期のバージョンの編集に貢献しました。"
    },
    {
      "indent": 3,
      "text": "Steve Cobb and Evan Caves redesigned the state machine tables. Barney Wolff provided a great deal of design input on the original endpoint authentication mechanism.",
      "ja": "スティーブ・コブとエヴァン洞窟は、ステートマシンテーブルを再設計しました。バーニーヴォルフは、元のエンドポイントの認証メカニズムに設計入力の多くを提供します。"
    },
    {
      "indent": 0,
      "text": "Appendix A: Control Slow Start and Congestion Avoidance",
      "ja": "付録A：コントロールスロースタートと輻輳回避"
    },
    {
      "indent": 3,
      "text": "Although each side has indicated the maximum size of its receive window, it is recommended that a slow start and congestion avoidance method be used to transmit control packets. The methods described here are based upon the TCP congestion avoidance algorithm as described in Section 21.6 of TCP/IP Illustrated, Volume I, by W. Richard Stevens [STEVENS] (this algorithm is also described in [RFC2581]).",
      "ja": "各側は、その受信ウィンドウの最大サイズを示したが、スロースタートと輻輳回避方法は、制御パケットを送信するために使用することが推奨されます。 TCP / IPイラスト、私は、W・リチャード・スティーヴンス[STEVENS]で（このアルゴリズムはまた、[RFC2581]で説明された）ボリュームのセクション21.6で説明したように、ここで説明する方法は、TCP輻輳回避アルゴリズムに基づいています。"
    },
    {
      "indent": 3,
      "text": "Slow start and congestion avoidance make use of several variables. The congestion window (CWND) defines the number of packets a sender may send before waiting for an acknowledgment. The size of CWND expands and contracts as described below. Note, however, that CWND is never allowed to exceed the size of the advertised window obtained from the Receive Window AVP. (In the text below, it is assumed any increase will be limited by the Receive Window Size.) The variable SSTHRESH determines when the sender switches from slow start to congestion avoidance. Slow start is used while CWND is less than SSHTRESH.",
      "ja": "スロースタートと輻輳回避には、いくつかの変数を利用します。輻輳ウィンドウ（CWND）は、送信側が確認応答を待機する前に送信することができるパケットの数を定義します。後述のようにCWNDの大きさが伸縮します。 CWNDが受信ウィンドウAVPから取得した広告ウィンドウのサイズを超えることは許されないこと、しかし、注意してください。 （以下の文章では、それは受信ウィンドウサイズによって制限される任意の増加を想定している。）変数SSTHRESHが判断した場合にスロースタートから輻輳回避の送信元スイッチ。 CWNDがSSHTRESH未満の間、スロースタートは、使用されています。"
    },
    {
      "indent": 3,
      "text": "A sender starts out in the slow start phase. CWND is initialized to one packet, and SSHTRESH is initialized to the advertised window (obtained from the Receive Window AVP). The sender then transmits one packet and waits for its acknowledgment (either explicit or piggybacked). When the acknowledgment is received, the congestion window is incremented from one to two. During slow start, CWND is increased by one packet each time an ACK (explicit ACK message or piggybacked) is received. Increasing CWND by one on each ACK has the effect of doubling CWND with each round trip, resulting in an exponential increase. When the value of CWND reaches SSHTRESH, the slow start phase ends and the congestion avoidance phase begins.",
      "ja": "送信側はスロースタートフェーズで実行を開始します。 CWNDは1つのパケットに初期化され、そしてSSHTRESHは（受信ウィンドウAVPから入手した）広告ウィンドウに初期化されます。送信者は、1つのパケットを送信し、その応答（明示的またはピギーバックのいずれか）を待ちます。確認応答が受信されると、輻輳ウィンドウは1から2にインクリメントされます。スロースタート時、CWNDは、一つのパケットによってACK（明示的なACKメッセージ又はピギーバック）が受信されるたびに増加されます。各ACKに1によるCWNDを大きくすると、指数関数的に増加し、その結果、各ラウンドトリップでCWNDを倍にする効果があります。 CWNDの値がSSHTRESHに達したときに、スロースタートフェーズが終了し、輻輳回避フェーズが始まります。"
    },
    {
      "indent": 3,
      "text": "During congestion avoidance, CWND expands more slowly. Specifically, it increases by 1/CWND for every new ACK received. That is, CWND is increased by one packet after CWND new ACKs have been received. Window expansion during the congestion avoidance phase is effectively linear, with CWND increasing by one packet each round trip.",
      "ja": "輻輳回避中に、CWNDは、よりゆっくりと拡大します。すべての新しいACKが受信のために具体的には、1 / CWNDによって増加します。 CWND新しいACKが受信された後ということです、CWNDは1つのパケット増加しています。輻輳回避フェーズの間ウィンドウの拡張は、CWNDが一つのパケットにより各ラウンドトリップの増加に伴って、効果的に線形です。"
    },
    {
      "indent": 3,
      "text": "When congestion occurs (indicated by the triggering of a retransmission) one-half of the CWND is saved in SSTHRESH, and CWND is set to one. The sender then reenters the slow start phase.",
      "ja": "輻輳が発生したときにCWNDの半分がSSTHRESHに保存される（再送のトリガによって示される）、およびCWNDは1に設定されています。送信者はその後、スロースタートフェーズに再び入ります。"
    },
    {
      "indent": 0,
      "text": "Appendix B: Control Message Examples",
      "ja": "付録B：制御メッセージの例"
    },
    {
      "indent": 0,
      "text": "B.1: Lock-Step Control Connection Establishment",
      "ja": "B.1：ロックステップ制御接続の確立"
    },
    {
      "indent": 3,
      "text": "In this example, an LCCE establishes a control connection, with the exchange involving each side alternating in sending messages. This example shows the final acknowledgment explicitly sent within an ACK message. An alternative would be to piggyback the acknowledgment within a message sent as a reply to the ICRQ or OCRQ that will likely follow from the side that initiated the control connection.",
      "ja": "この例では、LCCEは、メッセージを送信する各側交流を伴う交換との制御接続を確立します。この例では、明示的ACKメッセージ内で送信され、最終的な確認を示します。別の可能性が高い制御接続を開始した側から続くICRQまたはOCRQに対する応答として送信されたメッセージ内の確認応答をピギーバックすることであろう。"
    },
    {
      "indent": 6,
      "text": "LCCE A                   LCCE B\n------                   ------\nSCCRQ     ->\nNr: 0, Ns: 0\n                         <-     SCCRP\n                         Nr: 1, Ns: 0\nSCCCN     ->\nNr: 1, Ns: 1\n                         <-       ACK\n                         Nr: 2, Ns: 1",
      "raw": true
    },
    {
      "indent": 0,
      "text": "B.2: Lost Packet with Retransmission",
      "ja": "B.2：失われたパケットの再送信で"
    },
    {
      "indent": 3,
      "text": "An existing control connection has a new session requested by LCCE A. The ICRP is lost and must be retransmitted by LCCE B. Note that loss of the ICRP has two effects: It not only keeps the upper level state machine from progressing, but also keeps LCCE A from seeing a timely lower level acknowledgment of its ICRQ.",
      "ja": "それが進行する上位レベルのステートマシンを維持するだけでなく、続けて：既存の制御接続は、ICRPの損失は2つの効果があることに注意してくださいICRPが失われ、LCCE B.によって再送信されなければならないLCCE Aによって要求された新しいセッションを持っていますそのICRQのタイムリーな低レベルの確認応答を見てからLCCEのA。"
    },
    {
      "indent": 8,
      "text": "LCCE A                           LCCE B\n------                           ------\nICRQ      ->\nNr: 1, Ns: 2\n                 (packet lost)   <-      ICRP\n                                 Nr: 3, Ns: 1",
      "raw": true
    },
    {
      "indent": 6,
      "text": "(pause; LCCE A's timer started first, so fires first)",
      "ja": "（一時停止; LCCE Aのタイマーが最初に起動するので、火災最初）"
    },
    {
      "indent": 7,
      "text": "ICRQ -> Nr: 1, Ns: 2",
      "ja": "ICRQ  - > NO：1、Ns個：2"
    },
    {
      "indent": 6,
      "text": "(Realizing that it has already seen this packet, LCCE B discards the packet and sends an ACK message)",
      "ja": "（それが既にこのパケットを見ていることを実現LCCE Bはパケットを廃棄し、ACKメッセージを送信します）"
    },
    {
      "indent": 41,
      "text": "<-       ACK\nNr: 3, Ns: 2",
      "raw": true
    },
    {
      "indent": 6,
      "text": "(LCCE B's retransmit timer fires)",
      "ja": "（LCCE Bの再送信タイマーが起動）"
    },
    {
      "indent": 7,
      "text": " <- ICRP Nr: 3, Ns: 1 ICCN -> Nr: 2, Ns: 3",
      "ja": "< -  ICRP NO：3、Ns個：1 ICCN  - > NO：2、Ns個：3"
    },
    {
      "indent": 41,
      "text": "<-       ACK\nNr: 4, Ns: 2",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Appendix C: Processing Sequence Numbers",
      "ja": "付録C：処理シーケンス番号"
    },
    {
      "indent": 3,
      "text": "The Default L2-Specific Sublayer, defined in Section 4.6, provides a 24-bit field for sequencing of data packets within an L2TP session. L2TP data packets are never retransmitted, so this sequence is used only to detect packet order, duplicate packets, or lost packets.",
      "ja": "セクション4.6で定義されたデフォルトL2特有サブレイヤは、L2TPセッション内のデータパケットの配列決定のために24ビットのフィールドを提供します。 L2TPデータパケットが再送されることはありませんので、このシーケンスは、パケットのみのため、重複パケット、または失われたパケットを検出するために使用されます。"
    },
    {
      "indent": 3,
      "text": "The 24-bit Sequence Number field of the Default L2-Specific Sublayer contains a packet sequence number for the associated session. Each sequenced data packet that is sent must contain the sequence number, incremented by one, of the previous sequenced packet sent on a given L2TP session. Upon receipt, any packet with a sequence number equal to or greater than the current expected packet (the last received in-order packet plus one) should be considered \"new\" and accepted. All other packets are considered \"old\" or \"duplicate\" and discarded. Note that the 24-bit sequence number space includes zero as a valid sequence number (as such, it may be implemented with a masked 32-bit counter if desired). All new sessions MUST begin sending sequence numbers at zero.",
      "ja": "デフォルトL2特有のSublayerの24ビットのシーケンス番号フィールドは、関連するセッションのパケットのシーケンス番号を含みます。送信された各配列決定されたデータパケットは、指定されたL2TPセッションに送信され、以前の配列決定されたパケットのインクリメントシーケンス番号を、含まれている必要があります。受信すると、現在の予測パケット（最後に受信したイン・オーダパケットを加えたもの）以上のシーケンス番号を持つパケットは、「新しい」とみなされ、受け入れられるべきです。他のすべてのパケットは、「古い」または「重複」とみなされ、廃棄されています。 24ビットのシーケンス番号空間が有効なシーケンス番号（必要な場合など、それがマスクされた32ビットのカウンタを用いて実現されてもよい）としてゼロを含むことに留意されたいです。すべての新しいセッションがゼロでシーケンス番号の送信を開始しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Larger or smaller sequence number fields are possible with L2TP if an alternative format to the Default L2-Specific Sublayer defined in this document is used. While 24 bits may be adequate in a number of circumstances, a larger sequence number space will be less susceptible to sequence number wrapping problems for very high session data rates across long dropout periods. The sequence number processing recommendations below should hold for any size sequence number field.",
      "ja": "この文書で定義されたデフォルトL2特有のSublayerの代替形式が使用される場合、より大きな又はより小さなシーケンス番号フィールドは、L2TPを用いて可能です。 24ビットは、多くの状況において適切であり得るが、より大きなシーケンス番号空間は長いドロップアウト期間を横切って非常に高いセッション・データ・レートのシーケンス番号ラッピングの問題の影響を受けにくくなります。シーケンス番号処理の推奨事項は、以下のいずれかのサイズのシーケンス番号フィールドのために保持する必要があります。"
    },
    {
      "indent": 3,
      "text": "When detecting whether a packet sequence number is \"greater\" or \"less\" than a given sequence number value, wrapping of the sequence number must be considered. This is typically accomplished by keeping a window of sequence numbers beyond the current expected sequence number for determination of whether a packet is \"new\" or not. The window may be sized based on the link speed and sequence number space and SHOULD be configurable with a default equal to one half the size of the available number space (e.g., 2^(n-1), where n is the number of bits available in the sequence number).",
      "ja": "パケットシーケンス番号が与えられたシーケンス番号値よりも「大きい」または「以下」であるか否かを検出した場合、シーケンス番号のラップを考慮しなければなりません。これは通常、パケットは「新」であるか否かの決意のための現在の予想されるシーケンス番号を超えるシーケンス番号のウィンドウを維持することによって達成されます。ウィンドウは、リンク速度とシーケンス番号空間に基づいて寸法決めされてもよく、nはビット数である利用可能な数のスペースの半分の大きさ（例えば、2 ^（N-1）に等しいデフォルトで設定することべきですシーケンス番号で利用可能）。"
    },
    {
      "indent": 3,
      "text": "Upon receipt, packets that exactly match the expected sequence number are processed immediately and the next expected sequence number incremented. Packets that fall within the window for new packets may either be processed immediately and the next expected sequence number updated to one plus that received in the new packet, or held for a very short period of time in hopes of receiving the missing packet(s). This \"very short period\" should be configurable, with a default corresponding to a time lapse that is at least an order of magnitude less than the retransmission timeout periods of higher layer protocols such as TCP.",
      "ja": "受信すると、正確に予想されるシーケンス番号と一致するパケットは、即座に処理され、次に予想されるシーケンス番号がインクリメント。新しいパケットのためのウィンドウ内に収まるパケットはどちらかすぐに処理され、次に予想されるシーケンス番号が欠落しているパケットの受信を期待して、非常に短い時間のために、新たなパケットで受信した1つのプラスに更新、または開催された（S） 。この「非常に短い期間」とは、TCPなどの上位層プロトコルの再送タイムアウト期間未満の少なくとも一桁である時間の経過に対応するデフォルトで、構成可能であるべきです。"
    },
    {
      "indent": 3,
      "text": "For typical transient packet mis-orderings, dropping out-of-order packets alone should suffice and generally requires far less resources than actively reordering packets within L2TP. An exception is a case in which a pair of packet fragments are persistently retransmitted and sent out-of-order. For example, if an IP packet has been fragmented into a very small packet followed by a very large packet before being tunneled by L2TP, it is possible (though admittedly wrong) that the two resulting L2TP packets may be consistently mis-ordered by the PSN in transit between L2TP nodes. If sequence numbers were being enforced at the receiving node without any buffering of out-of-order packets, then the fragmented IP packet may never reach its destination. It may be worth noting here that this condition is true for any tunneling mechanism of IP packets that includes sequence number checking on receipt (i.e., GRE [RFC2890]).",
      "ja": "パケット誤順序典型的な一過性のために、単独のアウトオブオーダーパケットを破棄することは十分なはずであると一般的に積極的にL2TP内のパケットを並べ替えるよりも、はるかに少ないリソースを必要とします。例外は、パケットのフラグメントのペアが持続的に再送信し、アウト・オブ・オーダー送信された場合です。 IPパケットは、L2TPによってトンネリングされる前に、非常に大きなパケットに続く非常に小さなパケットに断片化されている場合、例えば、これは、2つの結果のL2TPパケットが一貫してPSNによって誤順序付けされてもよいこと（確かに間違ったが）ことが可能ですL2TPノード間のトランジットインチシーケンス番号は、アウトオブオーダーパケットのバッファリングせずに受信ノードで施行されていた場合は、断片化されたIPパケットは、その宛先に到達しない可能性があります。なお、この条件は、受信時に検査シーケンス番号（すなわち、GRE [RFC2890]）を含むIPパケットの任意のトンネリングメカニズムについても同様であることがここで注目に値するかもしれません。"
    },
    {
      "indent": 3,
      "text": "Utilization of a Data Sequencing Level (see Section 5.4.3) of 1 (only non-IP data packets require sequencing) allows IP data packets being tunneled by L2TP to not utilize sequence numbers, while utilizing sequence numbers and enforcing packet order for any remaining non-IP data packets. Depending on the requirements of the link layer being tunneled and the network data traversing the data link, this is sufficient in many cases to enforce packet order on frames that require it (such as end-to-end data link control messages), while not on IP packets that are known to be resilient to packet reordering.",
      "ja": "データシーケンシングレベルの利用は、1の（唯一の非IPデータパケットは、シーケンシングを必要とする）ことができるシーケンス番号を利用し、任意の残りのためにパケットの順序を強制しながら、IPデータパケットは、シーケンス番号を利用しないためにL2TPでトンネリングされている（5.4.3項を参照してください）非IPデータパケット。トンネリングされたリンク層とデータリンクをトラバースするネットワークデータの要件に応じて、これは、（例えば、エンド・ツー・エンドのデータリンク制御メッセージなど）それを必要とするフレームにパケットの順序を、一方ではない強制するために、多くの場合に十分ですパケットの並べ替えに弾力性のあることが知られているIPパケットに。"
    },
    {
      "indent": 3,
      "text": "If a large number of packets (i.e., more than one new packet window) are dropped due to an extended outage or loss of sequence number state on one side of the connection (perhaps as part of a forwarding plane reset or failover to a standby node), it is possible that a large number of packets will be sent in-order, but be wrongly detected by the peer as out-of-order. This can be generally characterized for a window size, w, sequence number space, s, and number of packets lost in transit between L2TP endpoints, p, as follows:",
      "ja": "多数のパケット（すなわち、複数の新たなパケット・ウィンドウ）は、接続の一方の側に拡張異常または配列番号状態の損失によるドロップされた場合（おそらくスタンバイノードへ転送プレーンリセットの一部またはフェイルオーバーとして）、多数のパケットがインオーダー送信されることが可能であるが、誤ってアウトオブオーダとしてピアによって検出されます。これは以下のように一般に、シーケンス番号空間、S、及びL2TPエンドポイント、P間にトランジットで失われたパケットの数、wは、ウィンドウサイズに特徴付けることができます。"
    },
    {
      "indent": 3,
      "text": "If s > p > w, then an additional (s - p) packets that were otherwise received in-order, will be incorrectly classified as out-of-order and dropped. Thus, for a sequence number space, s = 128, window size, w = 64, and number of lost packets, p = 70; 128 - 70 = 58 additional packets would be dropped after the outage until the sequence number wrapped back to the current expected next sequence number.",
      "ja": "S> P> wの場合、追加の（S  -  P）そうでない場合に、順に受信されたパケットは、誤ってアウトオブオーダとして分類され、ドロップされるであろう。従って、シーケンス番号空間のために、W = 128、ウィンドウサイズ= 64、および失われたパケットの数をS、P = 70。 128から70 = 58追加のパケットが戻って、現在予想される次のシーケンス番号に包まれたシーケンス番号まで停止後に廃棄されます。"
    },
    {
      "indent": 3,
      "text": "To mitigate this additional packet loss, one MUST inspect the sequence numbers of packets dropped due to being classified as \"old\" and reset the expected sequence number accordingly. This may be accomplished by counting the number of \"old\" packets dropped that were in sequence among themselves and, upon reaching a threshold, resetting the next expected sequence number to that seen in the arriving data packets. Packet timestamps may also be used as an indicator to reset the expected sequence number by detecting a period of time over which \"old\" packets have been received in-sequence. The ideal thresholds will vary depending on link speed, sequence number space, and link tolerance to out-of-order packets, and MUST be configurable.",
      "ja": "この追加のパケット損失を軽減するためには、パケットのシーケンス番号が原因「古い」と分類し、それに応じて期待されるシーケンス番号をリセットされることに落とさ点検しなければなりません。これは、「古い」パケットの数をカウントすることによって達成することができる到着するデータパケットで見られるものと予想される次のシーケンス番号をリセットし、しきい値に達すると、自分たちの間で配列があったことを落として。パケットのタイムスタンプは、「古い」パケットにシーケンス受信されたれる期間を検出することによって、期待されるシーケンス番号をリセットするための指標として使用することができます。理想的なしきい値は、リンク速度、シーケンス番号空間、及びアウトオブオーダーパケットにリンク許容度に応じて変化するであろう、と設定していなければなりません。"
    },
    {
      "indent": 0,
      "text": "Editors' Addresses",
      "ja": "エディタのアドレス"
    },
    {
      "indent": 3,
      "text": "Jed Lau cisco Systems 170 W. Tasman Drive San Jose, CA 95134",
      "ja": "ジェド・ラウシスコシステムズ170 W.タスマン・ドライブサンノゼ、CA 95134"
    },
    {
      "indent": 3,
      "text": "EMail: jedlau@cisco.com",
      "ja": "メールアドレス：jedlau@cisco.com"
    },
    {
      "indent": 3,
      "text": "W. Mark Townsley cisco Systems",
      "ja": "W.マークTownsleyシスコシステムズ"
    },
    {
      "indent": 3,
      "text": "EMail: mark@townsley.net",
      "ja": "メールアドレス：mark@townsley.net"
    },
    {
      "indent": 3,
      "text": "Ignacio Goyret Lucent Technologies",
      "ja": "イグナシオGoyretルーセント・テクノロジーズ"
    },
    {
      "indent": 3,
      "text": "EMail: igoyret@lucent.com",
      "ja": "メールアドレス：igoyret@lucent.com"
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2005).",
      "ja": "著作権（C）インターネット協会（2005）。"
    },
    {
      "indent": 3,
      "text": "This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.",
      "ja": "この文書では、BCP 78に含まれる権利と許可と制限の適用を受けており、その中の記載を除いて、作者は彼らのすべての権利を保有します。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein are provided on an \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書とここに含まれている情報は、基礎とCONTRIBUTOR「そのまま」、ORGANIZATION HE / SHEが表すまたはインターネットソサエティおよびインターネット・エンジニアリング・タスク・フォース放棄すべての保証、明示または、（もしあれば）後援ISに設けられています。黙示、情報の利用は、特定の目的に対する権利または商品性または適合性の黙示の保証を侵害しない任意の保証含むがこれらに限定されません。"
    },
    {
      "indent": 0,
      "text": "Intellectual Property",
      "ja": "知的財産"
    },
    {
      "indent": 3,
      "text": "The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.",
      "ja": "IETFは、本書またはそのような権限下で、ライセンスがたりないかもしれない程度に記載された技術の実装や使用に関係すると主張される可能性があります任意の知的財産権やその他の権利の有効性または範囲に関していかなる位置を取りません利用可能です。またそれは、それがどのような権利を確認する独自の取り組みを行ったことを示すものでもありません。 RFC文書の権利に関する手続きの情報は、BCP 78およびBCP 79に記載されています。"
    },
    {
      "indent": 3,
      "text": "Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.",
      "ja": "IPRの開示のコピーが利用できるようにIETF事務局とライセンスの保証に行われた、または本仕様の実装者または利用者がそのような所有権の使用のための一般的なライセンスまたは許可を取得するために作られた試みの結果を得ることができますhttp://www.ietf.org/iprのIETFのオンラインIPRリポジトリから。"
    },
    {
      "indent": 3,
      "text": "The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.",
      "ja": "IETFは、その注意にこの標準を実装するために必要とされる技術をカバーすることができる任意の著作権、特許または特許出願、またはその他の所有権を持ってすべての利害関係者を招待します。 ietf-ipr@ietf.orgのIETFに情報を記述してください。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "了承"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFC Editor機能のための基金は現在、インターネット協会によって提供されます。"
    }
  ]
}