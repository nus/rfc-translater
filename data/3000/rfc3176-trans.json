{
  "title": {
    "text": "RFC 3176 - InMon Corporation's sFlow: A Method for Monitoring Traffic in Switched and Routed Networks",
    "ja": "RFC 3176 - 米国InMon Corp.のsFlowの：スイッチにトラフィックを監視するための方法およびルーティングされたネットワーク"
  },
  "number": 3176,
  "created_at": "2019-10-24 16:22:52.030193+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                           P. Phaal\nRequest for Comments: 3176                                    S. Panchen\nCategory: Informational                                         N. McKee\n                                                             InMon Corp.\n                                                          September 2001",
      "raw": true
    },
    {
      "indent": 5,
      "text": "InMon Corporation's sFlow: A Method for Monitoring Traffic in\n                 Switched and Routed Networks",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "ja": "このメモの位置付け"
    },
    {
      "indent": 3,
      "text": "This memo provides information for the Internet community. It does not specify an Internet standard of any kind. Distribution of this memo is unlimited.",
      "ja": "このメモはインターネットコミュニティのための情報を提供します。それはどんな種類のインターネット標準を指定しません。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2001). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2001）。全著作権所有。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This memo defines InMon Coporation's sFlow system. sFlow is a technology for monitoring traffic in data networks containing switches and routers. In particular, it defines the sampling mechanisms implemented in an sFlow Agent for monitoring traffic, the sFlow MIB for controlling the sFlow Agent, and the format of sample data used by the sFlow Agent when forwarding data to a central data collector.",
      "ja": "このメモは米国InMon COPORATIONのsFlowのシステムを定義します。 sFlowのは、スイッチやルータを含むデータネットワークのトラフィックを監視するための技術です。特に、トラフィックを監視するためのsFlowエージェントに実装されたサンプリング機構、sFlowエージェントを制御するためのsFlow MIB、および中央データ収集装置にデータを転送するときsFlowエージェントによって使用されるサンプル・データのフォーマットを定義します。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Overview .....................................................  2\n2.  Sampling Mechanisms ..........................................  2\n    2.1 Sampling of Switched Flows ...............................  3\n        2.1.1 Distributed Switching ..............................  4\n        2.1.2 Random Number Generation ...........................  4\n    2.2 Sampling of Network Interface Statistics .................  4\n3.  sFlow MIB ....................................................  5\n    3.1 The SNMP Management Framework ............................  5\n    3.2 Definitions ..............................................  6\n4.  sFlow Datagram Format ........................................ 14\n5.  Security Considerations ...................................... 25\n    5.1 Control .................................................. 26\n    5.2 Transport ................................................ 26\n    5.3 Confidentiality .......................................... 26\n6.  References ................................................... 27\n7.  Authors' Addresses ........................................... 29",
      "raw": true
    },
    {
      "indent": 3,
      "text": "8.  Intellectual Property Statement .............................. 30\n9.  Full Copyright Statement ..................................... 31",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Overview",
      "section_title": true,
      "ja": "1。概要"
    },
    {
      "indent": 3,
      "text": "sFlow is a technology for monitoring traffic in data networks containing switches and routers. In particular, it defines the sampling mechanisms implemented in an sFlow Agent for monitoring traffic, the sFlow MIB for controlling the sFlow Agent, and the format of sample data used by the sFlow Agent when forwarding data to a central data collector.",
      "ja": "sFlowのは、スイッチやルータを含むデータネットワークのトラフィックを監視するための技術です。特に、トラフィックを監視するためのsFlowエージェントに実装されたサンプリング機構、sFlowエージェントを制御するためのsFlow MIB、および中央データ収集装置にデータを転送するときsFlowエージェントによって使用されるサンプル・データのフォーマットを定義します。"
    },
    {
      "indent": 3,
      "text": "The architecture and sampling techniques used in the sFlow monitoring system are designed to provide continuous site-wide (and network-wide) traffic monitoring for high speed switched and routed networks.",
      "ja": "高速の切り替えおよびネットワークをルーティングするためのsFlowモニタリングシステムで使用されるアーキテクチャおよびサンプリング技術は、連続的なサイト全体（およびネットワーク全体）トラフィック監視を提供するように設計されます。"
    },
    {
      "indent": 3,
      "text": "The design specifically addresses issues associated with:",
      "ja": "デザインは、具体的に関連する問題に対処します。"
    },
    {
      "indent": 3,
      "text": "o Accurately monitoring network traffic at Gigabit speeds and higher.",
      "ja": "O正確ギガビット速度と高いのネット​​ワークトラフィックを監視。"
    },
    {
      "indent": 3,
      "text": "o Scaling to manage tens of thousands of agents from a single point.",
      "ja": "1点から数十薬の何千ものを管理するためにスケーリングO。"
    },
    {
      "indent": 3,
      "text": "o Extremely low cost agent implementation.",
      "ja": "O非常に低コストのエージェント実装。"
    },
    {
      "indent": 3,
      "text": "The sFlow monitoring system consists of an sFlow Agent (embedded in a switch or router or in a stand alone probe) and a central data collector, or sFlow Analyzer.",
      "ja": "sFlowの監視システムは、（スイッチまたはルータまたはスタンドアロンプ​​ローブに埋め込まれた）sFlowエージェントと中央のデータ収集、またはsFlowのアナライザから成ります。"
    },
    {
      "indent": 3,
      "text": "The sFlow Agent uses sampling technology to capture traffic statistics from the device it is monitoring. sFlow Datagrams are used to immediately forward the sampled traffic statistics to an sFlow Analyzer for analysis.",
      "ja": "sFlowエージェントは、それが監視しているデバイスからのトラフィックの統計情報をキャプチャするサンプリング技術を使用しています。 sFlowのデータグラムをすぐに分析するためのsFlowアナライザにサンプリングされたトラフィックの統計情報を転送するために使用されています。"
    },
    {
      "indent": 3,
      "text": "This document describes the sampling mechanisms used by the sFlow Agent, the SFLOW MIB used by the sFlow Analyzer to control the sFlow Agent, and the sFlow Datagram Format used by the sFlow Agent to send traffic data to the sFlow Analyzer.",
      "ja": "この文書では、sFlowのアナライザにトラフィックデータを送信するためにsFlowエージェント、sFlowエージェントを制御するためのsFlowアナライザが使用するSFLOW MIB、およびsFlowエージェントによって使用されるのsFlowデータグラムフォーマットで使用されるサンプリングメカニズムについて説明します。"
    },
    {
      "indent": 0,
      "text": "2. Sampling Mechanisms",
      "section_title": true,
      "ja": "2.サンプリングメカニズム"
    },
    {
      "indent": 3,
      "text": "The sFlow Agent uses two forms of sampling: statistical packet-based sampling of switched flows, and time-based sampling of network interface statistics.",
      "ja": "スイッチングされるフローの統計的なパケットベースのサンプリング、およびネットワークインタフェースの統計情報の時間ベースのサンプリング：sFlowエージェントは、サンプリングの二つの形式を使用しています。"
    },
    {
      "indent": 0,
      "text": "2.1 Sampling of Switched Flows",
      "section_title": true,
      "ja": "スイッチドフローの2.1サンプリング"
    },
    {
      "indent": 3,
      "text": "A flow is defined as all the packets that are received on one interface, enter the Switching/Routing Module and are sent to another interface. In the case of a one-armed router, the source and destination interface could be the same. In the case of a broadcast or multicast packet there may be multiple destination interfaces. The sampling mechanism must ensure that any packet involved in a flow has an equal chance of being sampled, irrespective of the flow to which it belongs.",
      "ja": "流れは、一つのインターフェイスで受信されたすべてのパケットは、スイッチング/ルーティングモジュールを入力し、別のインターフェイスに送信されると定義されます。片腕ルータの場合には、送信元と宛先インターフェイスが同じであってもよいです。ブロードキャストまたはマルチキャストパケットの場合には複数の宛先インターフェイスが存在してもよいです。サンプリング機構にかかわらず、それが属するフローの流れに関与する任意のパケットがサンプリングさの等しい機会を有することを確認しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Sampling flows is accomplished as follows: When a packet arrives on an interface, a filtering decision is made that determines whether the packet should be dropped. If the packet is not filtered a destination interface is assigned by the switching/routing function. At this point a decision is made on whether or not to sample the packet. The mechanism involves a counter that is decremented with each packet. When the counter reaches zero a sample is taken. Whether or not a sample is taken, the counter Total_Packets is incremented. Total_Packets is a count of all the packets that could have been sampled.",
      "ja": "パケットがインターフェイスに到着すると、フィルタリングの決定は、パケットが廃棄されるべきか否かを判断することなされる：サンプリングは以下のように実現されて流れます。パケットがフィルタリングされていない場合、宛先インタフェースは、スイッチング/ルーティング機能によって割り当てられます。この時点で、決定は、パケットをサンプリングするかどうかで行われます。機構は、各パケットにデクリメントされるカウンタを含みます。カウンタがゼロに達したときにサンプルが取られます。サンプルが取られているかどうかにかかわらず、カウンターTotal_Packetsがインクリメントされます。 Total_Packetsは、サンプリングされている可能性がすべてのパケットの数です。"
    },
    {
      "indent": 3,
      "text": "Taking a sample involves either copying the packet's header, or extracting features from the packet (see sFlow Datagram Format for a description of the different forms of sample). Every time a sample is taken, the counter Total_Samples, is incremented. Total_Samples is a count of the number of samples generated. Samples are sent by the sampling entity to the sFlow Agent for processing. The sample includes the packet information, and the values of the Total_Packets and Total_Samples counters.",
      "ja": "サンプルを採取する（試料の異なる形態の説明のためのsFlowデータグラムのフォーマットを参照）パケットのヘッダをコピーし、またはパケットから特徴を抽出するのいずれかを含みます。サンプルが取られるたびに、カウンタTotal_Samplesは、インクリメントされます。 Total_Samplesは、生成されたサンプル数のカウントです。サンプルは、処理のためにsFlowエージェントにサンプリングエンティティによって送信されます。サンプルは、パケット情報、およびTotal_PacketsとTotal_Samplesカウンタの値を含みます。"
    },
    {
      "indent": 3,
      "text": "When a sample is taken, the counter indicating how many packets to skip before taking the next sample should be reset. The value of the counter should be set to a random integer where the sequence of random integers used over time should be such that",
      "ja": "サンプルが取られた場合、次のサンプルを取る前にスキップするパケット数を示すカウンタをリセットする必要があります。カウンタの値が経時的に使用されるランダム整数のシーケンスは、そのようにすべきであるランダムな整数に設定されるべきです"
    },
    {
      "indent": 3,
      "text": "(1) Total_Packets/Total_Samples = Rate",
      "ja": "（1）Total_Packets / Total_Samples =レート"
    },
    {
      "indent": 3,
      "text": "An alternative strategy for packet sampling is to generate a random number for each packet, compare the random number to a preset threshold and take a sample whenever the random number is smaller than the threshold value. Calculation of an appropriate threshold value depends on the characteristics of the random number generator, however, the resulting sample stream must still satisfy (1).",
      "ja": "パケットサンプリングのための別の戦略は、各パケットのために乱数を生成し、予め設定された閾値に乱数を比較し、乱数が閾値より小さいときはいつでも、サンプルを取ることです。適切な閾値の計算は、乱数発生器の特性に依存するが、得られたサンプルストリームは、依然として（1）を満たさなければなりません。"
    },
    {
      "indent": 0,
      "text": "2.1.1 Distributed Switching",
      "section_title": true,
      "ja": "2.1.1分散スイッチング"
    },
    {
      "indent": 3,
      "text": "The SFLOW MIB permits separate sampling entities to be associated with different physical or logical elements of the switch (such as interfaces, backplanes or VLANs). Each sampling engine has its own independent state (i.e., Total_Packets, Total_Samples, Skip and Rate), and forwards its own sample messages to the sFlow Agent. The sFlow Agent is responsible for packaging the samples into datagrams for transmission to an sFlow Analyzer.",
      "ja": "SFLOW MIBは、（インターフェース、バックプレーンまたはVLANなど）スイッチの異なる物理的または論理的要素に関連する別のサンプリング・エンティティを可能にします。各サンプリングエンジンは、独自の独立した状態（すなわち、Total_Packets、Total_Samples、スキップやレート）を有し、sFlowエージェントに独自のサンプルメッセージを転送します。 sFlowエージェントは、sFlowのアナライザに伝送するためのデータグラムにサンプルをパッケージングするための責任があります。"
    },
    {
      "indent": 0,
      "text": "2.1.2 Random Number Generation",
      "section_title": true,
      "ja": "2.1.2乱数生成"
    },
    {
      "indent": 3,
      "text": "The essential property of the random number generator is that the mean value of the numbers it generates converges to the required sampling rate.",
      "ja": "乱数生成器の本質的な特性は、数の平均値は、それが必要なサンプリングレートへの収束を発生させるということです。"
    },
    {
      "indent": 3,
      "text": "A uniform distribution random number generator is very effective. The range of skip counts (the variance) does not significantly affect results; variation of +-10% of the mean value is sufficient.",
      "ja": "一様分布乱数発生器は、非常に有効です。スキップカウントの範囲（分散）が大幅に結果には影響しません。平均値の±10％の変動が十分です。"
    },
    {
      "indent": 3,
      "text": "The random number generator must ensure that all numbers in the range between its maximum and minimum values of the distribution are possible; a random number generator only capable of generating even numbers, or numbers with any common divisor is unsuitable.",
      "ja": "乱数発生器は、分布の最大値と最小値の間の範囲内の全ての数が可能であることを確認しなければなりません。任意の公約数と偶数、または数値を生成することができるだけの乱数発生器は不適当です。"
    },
    {
      "indent": 3,
      "text": "A new skip value is only required every time a sample is taken.",
      "ja": "新しいスキップ値は、サンプルが取られるたびに必要とされます。"
    },
    {
      "indent": 0,
      "text": "2.2 Sampling of Network Interface Statistics",
      "section_title": true,
      "ja": "ネットワークインターフェイス統計の2.2サンプリング"
    },
    {
      "indent": 3,
      "text": "The objective of the counter sampling is to efficiently, periodically poll each data source on the device and extract key statistics.",
      "ja": "カウンタのサンプリングの目的は、効率的に、定期的にデバイス上の各データソースをポーリングし、主要な統計情報を抽出することです。"
    },
    {
      "indent": 3,
      "text": "For efficiency and scalability reasons, the sFlow System implements counter polling in the sFlow Agent. A maximum polling interval is assigned to the agent, but the agent is free to schedule polling in order maximize internal efficiency.",
      "ja": "効率性とスケーラビリティの理由から、sFlowのシステムは、sFlowエージェントでのカウンタのポーリングを実装しています。最大ポーリング間隔はエージェントに割り当てられたが、エージェントが内部効率を最大ためにポーリングをスケジュールして自由です。"
    },
    {
      "indent": 3,
      "text": "Flow sampling and counter sampling are designed as part of an integrated system. Both types of samples are combined in sFlow Datagrams. Since flow sampling will cause a steady, but random, stream of datagrams to be sent to the sFlow Analyzer, counter samples may be taken opportunistically in order to fill these datagrams.",
      "ja": "フローサンプリングとカウンターサンプリングは、統合システムの一部として設計されています。サンプルの両方のタイプは、sFlowのデータグラムに結合されます。フローサンプリングは、データグラムの安定したが、ランダム、ストリームは、sFlowのアナライザに送信されることになりますので、カウンターのサンプルは、これらのデータグラムを埋めるために、日和見取ることができます。"
    },
    {
      "indent": 3,
      "text": "One strategy for counter sampling has the sFlow Agent keep a list of counter sources being sampled. When a flow sample is generated the sFlow Agent examines the list and adds counters to the sample datagram, least recently sampled first. Counters are only added to the datagram if the sources are within a short period, 5 seconds say, of failing to meet the required sampling interval (see sFlowCounterSamplingInterval in SFLOW MIB). Whenever a counter source's statistics are added to a sample datagram, the time the counter source was last sampled is updated and the counter source is placed at the end of the list. Periodically, say every second, the sFlow Agent examines the list of counter sources and sends any counters that need to be sent to meet the sampling interval requirement.",
      "ja": "カウンターサンプリングのための1つの戦略は、sFlowエージェントがサンプリングされるカウンタソースのリストを維持しています。フローサンプルが生成されるとsFlowエージェントはリストを調べて、最近最も最初にサンプリングされ、サンプルデータグラムにカウンタを追加します。ソースは短い期間内であればカウンターだけのデータグラムに追加され、5秒が必要なサンプリング間隔を（SFLOW MIBでsFlowCounterSamplingIntervalを参照）を満たしていないの、と言います。カウンタソースの統計がサンプルデータグラムに追加されたときはいつでも、カウンタソースが最後にサンプリングされた時刻が更新され、カウンタのソースがリストの最後に置かれています。定期的に、毎秒言う、sFlowエージェントは、カウンタソースのリストを調べて、サンプリング間隔の要件を満たすために送信する必要が任意のカウンタを送信します。"
    },
    {
      "indent": 3,
      "text": "Alternatively, if the agent regularly schedules counter sampling, then it should schedule each counter source at a different start time (preferably randomly) so that counter sampling is not synchronized within an agent or between agents.",
      "ja": "エージェントは、定期的にスケジュールがサンプリングカウンタ場合あるいは、それは、そのカウンタサンプリングエージェント内またはエージェント間で同期されていないので、異なる開始時間（好ましくはランダム）の各カウンタのソースをスケジュールすべきです。"
    },
    {
      "indent": 0,
      "text": "3. sFlow MIB",
      "section_title": true,
      "ja": "3.のsFlow MIB"
    },
    {
      "indent": 3,
      "text": "The sFlow MIB defines a control interface for an sFlow Agent. This interface provides a standard mechanism for remotely controlling and configuring an sFlow Agent.",
      "ja": "sFlow MIBは、sFlowエージェントの制御インタフェースを定義します。このインタフェースは、リモートでsFlowエージェントを制御および設定するための標準的なメカニズムを提供します。"
    },
    {
      "indent": 0,
      "text": "3.1 The SNMP Management Framework",
      "section_title": true,
      "ja": "3.1 SNMP管理フレームワーク"
    },
    {
      "indent": 3,
      "text": "The SNMP Management Framework presently consists of five major components:",
      "ja": "SNMP Management Frameworkは現在、5つの主要コンポーネントから構成されています。"
    },
    {
      "indent": 3,
      "text": "o An overall architecture, described in RFC 2571 [2].",
      "ja": "RFC 2571に記載され、全体的なアーキテクチャ、O [2]。"
    },
    {
      "indent": 3,
      "text": "o Mechanisms for describing and naming objects and events for the purpose of management. The first version of this Structure of Management Information (SMI) is called SMIv1 and described in STD 16,",
      "ja": "管理の目的のためにオブジェクトとイベントを記述し、命名するためのメカニズムO。管理情報（SMI）のこの構造体の最初のバージョンは、でSMIv1と呼ばれ、STD 16に記載されています"
    },
    {
      "indent": 6,
      "text": "RFC 1155 [3], STD 16, RFC 1212 [4] and RFC 1215 [5]. The second version, called SMIv2, is described in STD 58, RFC 2578 [6], STD 58, RFC 2579 [7] and STD 58, RFC 2580 [8].",
      "ja": "RFC 1155 [3]は、STD 16、RFC 1212 [4]及びRFC 1215 [5]。 SMIv2のと呼ばれる第二のバージョン、STD 58、RFC 2578に記載されている[6]、STD 58、RFC 2579 [7]とSTD 58、RFC 2580 [8]。"
    },
    {
      "indent": 3,
      "text": "o Message protocols for transferring management information. The first version of the SNMP message protocol is called SNMPv1 and described in STD 15, RFC 1157 [9]. A second version of the SNMP message protocol, which is not an Internet standards track protocol, is called SNMPv2c and described in RFC 1901 [10] and RFC 1906 [11]. The third version of the message protocol is called SNMPv3 and described in RFC 1906 [11], RFC 2572 [12] and RFC 2574 [13].",
      "ja": "管理情報を転送するためのOメッセージプロトコル。 SNMPメッセージプロトコルの最初のバージョンは、[9]のSNMPv1と呼ばれ、STD 15、RFC 1157に記載されています。インターネット標準トラックプロトコルでないSNMPメッセージプロトコルの第2のバージョンは、SNMPv2cのと呼ばれ、RFC 1901 [10]およびRFC 1906 [11]に記載されています。メッセージプロトコルの第三のバージョンのSNMPv3と呼ばれ、RFC 1906年に記載されている[11]、RFC 2572 [12]およびRFC 2574 [13]。"
    },
    {
      "indent": 3,
      "text": "o Protocol operations for accessing management information. The first set of protocol operations and associated PDU formats is described in STD 15, RFC 1157 [9]. A second set of protocol operations and associated PDU formats is described in RFC 1905 [14].",
      "ja": "管理情報にアクセスするためのOプロトコル操作。プロトコル操作と関連PDU形式の第一セットは、STD 15、RFC 1157に記載されている[9]。プロトコル操作と関連PDU形式の第2のセットは、RFC 1905 [14]に記載されています。"
    },
    {
      "indent": 3,
      "text": "o A set of fundamental applications described in RFC 2573 [15] and the view-based access control mechanism described in RFC 2575 [16].",
      "ja": "O RFC 2573 [15]とビューベースアクセス制御メカニズムに記載の基本的なアプリケーションのセットは、RFC 2575 [16]に記載します。"
    },
    {
      "indent": 3,
      "text": "A more detailed introduction to the current SNMP Management Framework can be found in RFC 2570 [17].",
      "ja": "現在のSNMP Management Frameworkへの、より詳細な紹介は、RFC 2570 [17]に記載されています。"
    },
    {
      "indent": 3,
      "text": "Managed objects are accessed via a virtual information store, termed the Management Information Base or MIB. Objects in the MIB are defined using the mechanisms defined in the SMI.",
      "ja": "管理対象オブジェクトが仮想情報店を介してアクセスされ、管理情報ベースまたはMIBと呼ばれます。 MIBのオブジェクトは、SMIで定義されたメカニズムを使用して定義されています。"
    },
    {
      "indent": 3,
      "text": "This memo specifies a MIB module that is compliant to the SMIv2. A MIB conforming to the SMIv1 can be produced through the appropriate translations. The resulting translated MIB must be semantically equivalent, except where objects or events are omitted because no translation is possible (use of Counter64). Some machine readable information in SMIv2 will be converted into textual descriptions in SMIv1 during the translation process. However, this loss of machine readable information is not considered to change the semantics of the MIB.",
      "ja": "このメモはSMIv2に対応であるMIBモジュールを指定します。 SMIv1に従うMIBは、適切な翻訳を介して製造することができます。得られた翻訳されたMIBには翻訳（Counter64のの使用）が可能ではないので、オブジェクトまたはイベントが省略されている場合を除いて、意味的に等価でなければなりません。 SMIv2のいくつかの機械読み取り可能な情報には、翻訳プロセスの間、SMIv1の原文の記述に変換されます。しかし、機械読み取り可能な情報のこの損失がMIBの意味論を変えると考えられません。"
    },
    {
      "indent": 0,
      "text": "3.2 Definitions",
      "section_title": true,
      "ja": "3.2定義"
    },
    {
      "indent": 0,
      "text": "SFLOW-MIB DEFINITIONS ::= BEGIN",
      "raw": true
    },
    {
      "indent": 0,
      "text": "IMPORTS",
      "ja": "輸入"
    },
    {
      "indent": 0,
      "text": "MODULE-IDENTITY, OBJECT-TYPE, Integer32, enterprises FROM SNMPv2-SMI SnmpAdminString FROM SNMP-FRAMEWORK-MIB OwnerString FROM RMON-MIB InetAddressType, InetAddress FROM INET-ADDRESS-MIB MODULE-COMPLIANCE, OBJECT-GROUP FROM SNMPv2-CONF;",
      "ja": "MODULE-IDENTITY、OBJECT-TYPE、Integer32の、SNMPv2の-CONF FROM INET-ADDRESS-MIB MODULE-COMPLIANCE、オブジェクト群からRMON-MIBたInetAddressType、InetAddressのFROM SNMP-FRAMEWORK-MIB OwnerString FROMのSNMPv2-SMIれるSnmpAdminString FROM企業。"
    },
    {
      "indent": 0,
      "text": "sFlowMIB MODULE-IDENTITY LAST-UPDATED \"200105150000Z\" -- May 15, 2001 ORGANIZATION \"InMon Corp.\" CONTACT-INFO",
      "ja": "sFlowMIBのMODULE-IDENTITY LAST-UPDATED \"200105150000Z\"  -  2001年5月15日ORGANIZATION \"米国InMon社\"連絡先情報"
    },
    {
      "indent": 9,
      "text": "\"Peter Phaal\n InMon Corp.\n http://www.inmon.com/",
      "raw": true
    },
    {
      "indent": 2,
      "text": " Tel: +1-415-661-6343 Email: peter_phaal@inmon.com\" DESCRIPTION \"The MIB module for managing the generation and transportation of sFlow data records.\"",
      "ja": "電話：+ 1-415-661-6343 Eメール：peter_phaal@inmon.com」DESCRIPTION 『のsFlowデータレコードの生成と輸送を管理するためのMIBモジュール』。"
    },
    {
      "indent": 2,
      "text": "-- -- Revision History -- REVISION \"200105150000Z\" -- May 15, 2001 DESCRIPTION \"Version 1.2",
      "ja": " -   - 改訂履歴 -  REVISION \"200105150000Z\"  -  2001年5月15日DESCRIPTION「バージョン1.2"
    },
    {
      "indent": 11,
      "text": "Brings MIB into SMI v2 compliance.\"",
      "ja": "SMI v2の遵守にMIBをもたらします。」"
    },
    {
      "indent": 2,
      "text": "REVISION \"200105010000Z\" -- May 1, 2001 DESCRIPTION \"Version 1.1",
      "ja": "REVISION \"200105010000Z\"  -  2001年5月1日DESCRIPTION「バージョン1.1"
    },
    {
      "indent": 2,
      "text": "          Adds sFlowDatagramVersion.\"\n::= { enterprises 4300 1 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "sFlowAgent OBJECT IDENTIFIER ::= { sFlowMIB 1 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "sFlowVersion OBJECT-TYPE SYNTAX SnmpAdminString MAX-ACCESS read-only STATUS current DESCRIPTION \"Uniquely identifies the version and implementation of this MIB. The version string must have the following structure: <MIB Version>;<Organization>;<Software Revision> where: <MIB Version> must be '1.2', the version of this MIB. <Organization> the name of the organization responsible for the agent implementation. <Revision> the specific software build of this agent.",
      "ja": "sFlowVersionのOBJECT-TYPE SYNTAXれるSnmpAdminString MAX-ACCESS read-onlyステータス現在の説明は「ユニークなこのMIBのバージョンと実装を特定バージョン文字列は、次のような構造を持っている必要があります。<MIBバージョン>。<組織>、<ソフトウェアリビジョン>ここで、 <MIBバージョン>「1.2」、このMIBのバージョンである必要があります。<組織>エージェント実装を担当する組織の名前。<リビジョン>このエージェントの特定のソフトウェアのビルド。"
    },
    {
      "indent": 8,
      "text": "As an example, the string '1.2;InMon Corp.;2.1.1' indicates\nthat this agent implements version '1.2' of the SFLOW MIB, that\nit was developed by 'InMon Corp.' and that the software build\nis '2.1.1'.",
      "raw": true
    },
    {
      "indent": 8,
      "text": "The MIB Version will change with each revision of the SFLOW",
      "ja": "MIBバージョンはSFLOWの各リビジョンで変更されます"
    },
    {
      "indent": 8,
      "text": "MIB.",
      "ja": "MIB。"
    },
    {
      "indent": 8,
      "text": "Management entities must check the MIB Version and not attempt to manage agents with MIB Versions greater than that for which they were designed.",
      "ja": "管理エンティティは、MIBのバージョンをチェックし、それらが設計されたものよりも大きいMIBのバージョンを使用してエージェントを管理しようとしてはなりません。"
    },
    {
      "indent": 5,
      "text": "   Note: The sFlow Datagram Format has an independent version\n         number which may change independently from <MIB Version>.\n         <MIB Version> applies to the structure and semantics of\n         the SFLOW MIB only.\"\nDEFVAL { \"1.2;;\" }\n::= { sFlowAgent 1 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "sFlowAgentAddressType OBJECT-TYPE\n     SYNTAX      InetAddressType\n     MAX-ACCESS  read-only\n     STATUS      current\n     DESCRIPTION\n       \"The address type of the address associated with this agent.\n        Only ipv4 and ipv6 types are supported.\"\n     ::= { sFlowAgent 2 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "sFlowAgentAddress OBJECT-TYPE\n     SYNTAX      InetAddress\n     MAX-ACCESS  read-only\n     STATUS      current\n     DESCRIPTION\n       \"The IP address associated with this agent.  In the case of a\n        multi-homed agent, this should be the loopback address of the\n        agent.  The sFlowAgent address must provide SNMP connectivity\n        to the agent.  The address should be an invariant that does not\n        change as interfaces are reconfigured, enabled, disabled,\n        added or removed.  A manager should be able to use the\n        sFlowAgentAddress as a unique key that will identify this\n        agent over extended periods of time so that a history can\n        be maintained.\"\n    ::= { sFlowAgent 3 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "sFlowTable OBJECT-TYPE\n     SYNTAX      SEQUENCE OF SFlowEntry\n     MAX-ACCESS  not-accessible\n     STATUS      current\n     DESCRIPTION\n       \"A table of the sFlow samplers within a device.\"\n     ::= { sFlowAgent 4 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "sFlowEntry OBJECT-TYPE SYNTAX SFlowEntry",
      "ja": "sFlowEntryのOBJECT-TYPE SYNTAX SFlowEntry"
    },
    {
      "indent": 5,
      "text": "MAX-ACCESS  not-accessible\nSTATUS      current\nDESCRIPTION\n  \"Attributes of an sFlow sampler.\"\nINDEX { sFlowDataSource }\n::= { sFlowTable 1 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "SFlowEntry ::= SEQUENCE {\n     sFlowDataSource               OBJECT IDENTIFIER,\n     sFlowOwner                    OwnerString,\n     sFlowTimeout                  Integer32,\n     sFlowPacketSamplingRate       Integer32,\n     sFlowCounterSamplingInterval  Integer32,\n     sFlowMaximumHeaderSize        Integer32,\n     sFlowMaximumDatagramSize      Integer32,\n     sFlowCollectorAddressType     InetAddressType,\n     sFlowCollectorAddress         InetAddress,\n     sFlowCollectorPort            Integer32,\n     sFlowDatagramVersion          Integer32\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "sFlowDataSource OBJECT-TYPE SYNTAX OBJECT IDENTIFIER MAX-ACCESS read-only STATUS current DESCRIPTION \"Identifies the source of the data for the sFlow sampler. The following data source types are currently defined:",
      "ja": "sFlowDataSource OBJECT-TYPE構文オブジェクト識別子MAX-ACCESS read-onlyステータス現在の説明は「のsFlowサンプラー用のデータのソースを識別し、次のデータ・ソース・タイプは、現在定義されています："
    },
    {
      "indent": 7,
      "text": "- ifIndex.<I>\nDataSources of this traditional form are called 'port-based'.\nIdeally the sampling entity will perform sampling on all flows\noriginating from or destined to the specified interface.\nHowever, if the switch architecture only permits input or\noutput sampling then the sampling agent is permitted to only\nsample input flows input or output flows.  Each packet must\nonly be considered once for sampling, irrespective of the\nnumber of ports it will be forwarded to.",
      "raw": true
    },
    {
      "indent": 7,
      "text": "Note: Port 0 is used to indicate that all ports on the device are represented by a single data source. - sFlowPacketSamplingRate applies to all ports on the device capable of packet sampling. - sFlowCounterSamplingInterval applies to all ports.",
      "ja": "注：ポート0は、デバイス上のすべてのポートは、単一のデータソースによって表されていることを示すために使用されます。 -  sFlowPacketSamplingRateは、パケットサンプリングが可能なデバイス上のすべてのポートに適用されます。 -  sFlowCounterSamplingIntervalは、すべてのポートに適用されます。"
    },
    {
      "indent": 7,
      "text": "- smonVlanDataSource.<V> A dataSource of this form refers to a 'Packet-based VLAN' and is called a 'VLAN-based' dataSource. <V> is the VLAN",
      "ja": " -  smonVlanDataSource <V>この形式のデータソースは、「パケット・ベースのVLAN」を意味し、「VLANベースの」データソースと呼ばれます。 <V> VLANです"
    },
    {
      "indent": 7,
      "text": "ID as defined by the IEEE 802.1Q standard. The value is between 1 and 4094 inclusive, and it represents an 802.1Q VLAN-ID with global scope within a given bridged domain. Sampling is performed on all packets received that are part of the specified VLAN (no matter which port they arrived on). Each packet will only be considered once for sampling, irrespective of the number of ports it will be forwarded to.",
      "ja": "IEEE 802.1Q標準で定義されたID。値は1〜4094包括的であり、それは与えられたブリッジドメイン内のグローバルスコープの802.1Q VLAN-IDを表します。サンプリングは、指定されたVLAN（彼らはに到着したポートにかかわらず）の一部で受信したすべてのパケットに対して実行されます。各パケットは唯一かかわらず、それが転送されるポートの数を、サンプリングのために一度とみなされます。"
    },
    {
      "indent": 7,
      "text": "- entPhysicalEntry.<N> A dataSource of this form refers to a physical entity within the agent (e.g., entPhysicalClass = backplane(4)) and is called an 'entity-based' dataSource. Sampling is performed on all packets entering the resource (e.g. If the backplane is being sampled, all packets transmitted onto the backplane will be considered as single candidates for sampling irrespective of the number of ports they ultimately reach).",
      "ja": " - 。entPhysicalEntry <N>この形式のデータソースは、薬剤（例えば、entPhysicalClassが=バックプレーン（4））と呼ばれる「エンティティ・ベースの」データソース内の物理エンティティを指します。サンプリングは、（バックプレーンがサンプリングされている場合、例えば、バックプレーンに送信されるすべてのパケットに関係なく、それらが最終的に到達するポート数のサンプリングのための単一の候補として考慮される）リソースに入るすべてのパケットに対して行われます。"
    },
    {
      "indent": 5,
      "text": "  Note: Since each DataSource operates independently, a packet\n        that crosses multiple DataSources may generate multiple\n        flow records.\"\n::= { sFlowEntry 1 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "sFlowOwner OBJECT-TYPE SYNTAX OwnerString MAX-ACCESS read-write STATUS current DESCRIPTION \"The entity making use of this sFlow sampler. The empty string indicates that the sFlow sampler is currently unclaimed. An entity wishing to claim an sFlow sampler must make sure that the sampler is unclaimed before trying to claim it. The sampler is claimed by setting the owner string to identify the entity claiming the sampler. The sampler must be claimed before any changes can be made to other sampler objects.",
      "ja": "sFlowOwnerのOBJECT-TYPE SYNTAX OwnerString MAX-ACCESS読み取りと書き込みステータス現在の説明「エンティティが、このsFlowのサンプラーを使用すること。空の文字列は、sFlowのサンプラーが現在未請求であることを示している。sFlowのサンプラーを主張したいエンティティがことを確認する必要がありますすべての変更は、他のサンプラーオブジェクトに対して行うことができる前に、サンプラーがそれを主張しようとする前に、引き取り手のないです。サンプラーサンプラーを主張するエンティティを識別するために、所有者文字列を設定することで主張されている。サンプラーを主張しなければなりません。"
    },
    {
      "indent": 8,
      "text": "In order to avoid a race condition, the entity taking control\nof the sampler must set both the owner and a value for\nsFlowTimeout in the same SNMP set request.",
      "raw": true
    },
    {
      "indent": 8,
      "text": "When a management entity is finished using the sampler, it should set its value back to unclaimed. The agent must restore all other entities this row to their default values when the owner is set to unclaimed.",
      "ja": "管理エンティティは、サンプラーを使用して終了すると、それが戻って引き取り手にその値を設定する必要があります。所有者は、引き取り手のないに設定されている場合、エージェントはデフォルト値にこの列のすべての他のエンティティを復元する必要があります。"
    },
    {
      "indent": 5,
      "text": "   This mechanism provides no enforcement and relies on the\n   cooperation of management entities in order to ensure that competition for a sampler is fairly resolved.\"\nDEFVAL { \"\" }\n::= { sFlowEntry 2 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "sFlowTimeout OBJECT-TYPE SYNTAX Integer32 MAX-ACCESS read-write STATUS current DESCRIPTION \"The time (in seconds) remaining before the sampler is released and stops sampling. When set, the owner establishes control for the specified period. When read, the remaining time in the interval is returned.",
      "ja": "サンプラーを解放し、サンプリングを停止する前に、残りのsFlowTimeout OBJECT-TYPE構文Integer32 MAX-ACCESS読み取りと書き込みステータス現在の説明「時間（秒）。セット、所有者が指定した期間のための制御を確立します。読み取り、残り時間間隔で返されます。"
    },
    {
      "indent": 8,
      "text": "A management entity wanting to maintain control of the sampler\nis responsible for setting a new value before the old one\nexpires.",
      "raw": true
    },
    {
      "indent": 5,
      "text": "   When the interval expires, the agent is responsible for\n   restoring all other entities in this row to their default\n   values.\"\nDEFVAL { 0 }\n::= { sFlowEntry 3 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "sFlowPacketSamplingRate OBJECT-TYPE SYNTAX Integer32 MAX-ACCESS read-write STATUS current DESCRIPTION \"The statistical sampling rate for packet sampling from this source.",
      "ja": "sFlowPacketSamplingRateのOBJECT-TYPE構文Integer32 MAX-ACCESS読み取りと書き込みステータス現在の説明「このソースからのパケットサンプリングの統計的サンプリング・レート。"
    },
    {
      "indent": 8,
      "text": "Set to N to sample 1/Nth of the packets in the monitored flows.\nAn agent should choose its own algorithm introduce variance\ninto the sampling so that exactly every Nth packet is not\ncounted.  A sampling rate of 1 counts all packets.  A sampling\nrate of 0 disables sampling.",
      "raw": true
    },
    {
      "indent": 8,
      "text": "The agent is permitted to have minimum and maximum allowable values for the sampling rate. A minimum rate lets the agent designer set an upper bound on the overhead associated with sampling, and a maximum rate may be the result of hardware restrictions (such as counter size). In addition not all values between the maximum and minimum may be realizable as the sampling rate (again because of implementation considerations).",
      "ja": "エージェントは、サンプリングレートの最小値と最大許容値を持つことが許されます。最小レートは、エージェント設計者がサンプリングに関連するオーバーヘッドの上限を設定することができ、最大速度は、（例えばカウンタサイズなど）ハードウェアの制約の結果であり得ます。また最大値と最小値の間の全ての値は、（再びため、実装上の考慮事項の）サンプリングレートとして実現されるとは限りません。"
    },
    {
      "indent": 8,
      "text": "When the sampling rate is set the agent is free to adjust the value so that it lies between the maximum and minimum values and has the closest achievable value.",
      "ja": "サンプリングレートが設定されている場合、エージェントは、それが最大値と最小値の間にある最も近い達成可能値になるように値を調整して自由です。"
    },
    {
      "indent": 5,
      "text": "   When read, the agent must return the actual sampling rate it\n   will be using (after the adjustments previously described).  The\n   sampling algorithm must converge so that over time the number\n   of packets sampled approaches 1/Nth of the total number of\n   packets in the monitored flows.\"\nDEFVAL { 0 }\n::= { sFlowEntry 4 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "sFlowCounterSamplingInterval OBJECT-TYPE\n  SYNTAX      Integer32\n     MAX-ACCESS  read-write\n     STATUS      current\n     DESCRIPTION\n       \"The maximum number of seconds between successive samples of the\n        counters associated with this data source.  A sampling interval\n        of 0 disables counter sampling.\"\n     DEFVAL { 0 }\n     ::= { sFlowEntry 5 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "sFlowMaximumHeaderSize OBJECT-TYPE\n     SYNTAX      Integer32\n     MAX-ACCESS  read-write\n     STATUS      current\n     DESCRIPTION\n       \"The maximum number of bytes that should be copied from a\n        sampled packet.  The agent may have an internal maximum and\n        minimum permissible sizes.  If an attempt is made to set this\n        value outside the permissible range then the agent should\n        adjust the value to the closest permissible value.\"\n     DEFVAL { 128 }\n     ::= { sFlowEntry 6 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "sFlowMaximumDatagramSize OBJECT-TYPE\n     SYNTAX      Integer32\n     MAX-ACCESS  read-write\n     STATUS      current\n     DESCRIPTION\n        \"The maximum number of data bytes that can be sent in a single\n         sample datagram.  The manager should set this value to avoid\n         fragmentation of the sFlow datagrams.\"\n     DEFVAL { 1400 }\n     ::= { sFlowEntry 7 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "sFlowCollectorAddressType OBJECT-TYPE SYNTAX InetAddressType MAX-ACCESS read-write",
      "ja": "sFlowCollectorAddressTypeのOBJECT-TYPE構文InetAddressType MAX-ACCESSの読み取りと書き込み"
    },
    {
      "indent": 5,
      "text": "STATUS      current\nDESCRIPTION\n  \"The type of sFlowCollectorAddress.\"\nDEFVAL { ipv4 }\n::= { sFlowEntry 8 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "sFlowCollectorAddress OBJECT-TYPE\n     SYNTAX      InetAddress\n     MAX-ACCESS  read-write\n     STATUS      current\n     DESCRIPTION\n       \"The IP address of the sFlow collector.\n        If set to 0.0.0.0 all sampling is disabled.\"\n     DEFVAL { \"0.0.0.0\" }\n     ::= { sFlowEntry 9 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "sFlowCollectorPort OBJECT-TYPE\n     SYNTAX      Integer32\n     MAX-ACCESS  read-write\n     STATUS      current\n     DESCRIPTION\n       \"The destination port for sFlow datagrams.\"\n     DEFVAL { 6343 }\n     ::= { sFlowEntry 10 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "sFlowDatagramVersion OBJECT-TYPE SYNTAX Integer32 MAX-ACCESS read-write STATUS current DESCRIPTION \"The version of sFlow datagrams that should be sent.",
      "ja": "sFlowDatagramVersionのOBJECT-TYPE構文Integer32 MAX-ACCESS読み取りと書き込みステータス現在の説明「送られるべきであるのsFlowデータグラムのバージョン。"
    },
    {
      "indent": 5,
      "text": "   When set to a value not support by the agent, the agent should\n   adjust the value to the highest supported value less than the\n   requested value, or return an error if no such values exist.\"\nDEFVAL { 4 }\n::= { sFlowEntry 11 }",
      "raw": true
    },
    {
      "indent": 1,
      "text": "-- -- Compliance Statements --",
      "ja": " -   - コンプライアンスステートメント - "
    },
    {
      "indent": 0,
      "text": "sFlowMIBConformance OBJECT IDENTIFIER ::= { sFlowMIB 2 }\nsFlowMIBGroups      OBJECT IDENTIFIER ::= { sFlowMIBConformance 1 }\nsFlowMIBCompliances OBJECT IDENTIFIER ::= { sFlowMIBConformance 2 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "sFlowCompliance MODULE-COMPLIANCE STATUS current",
      "ja": "sFlowCompliance MODULE-COMPLIANCEステータス電流"
    },
    {
      "indent": 5,
      "text": "DESCRIPTION\n  \"Compliance statements for the sFlow Agent.\"",
      "raw": true
    },
    {
      "indent": 5,
      "text": "MODULE -- this module MANDATORY-GROUPS { sFlowAgentGroup } OBJECT sFlowAgentAddressType SYNTAX InetAddressType { ipv4(1) } DESCRIPTION \"Agents need only support ipv4.\"",
      "ja": "MODULE  - このモジュールMANDATORY-GROUPSは{sFlowAgentGroup} OBJECT sFlowAgentAddressType構文InetAddressType {IPv4の（1）} DESCRIPTION \"エージェントはIPv4のみをサポートする必要がある\" と述べました。"
    },
    {
      "indent": 9,
      "text": "OBJECT sFlowCollectorAddressType\nSYNTAX InetAddressType { ipv4(1) }\nDESCRIPTION\n  \"Agents need only support ipv4.\"",
      "raw": true
    },
    {
      "indent": 5,
      "text": "::= { sFlowMIBCompliances 1 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "sFlowAgentGroup OBJECT-GROUP\n     OBJECTS { sFlowVersion, sFlowAgentAddressType, sFlowAgentAddress,\n               sFlowDataSource, sFlowOwner, sFlowTimeout,\n               sFlowPacketSamplingRate, sFlowCounterSamplingInterval,\n               sFlowMaximumHeaderSize, sFlowMaximumDatagramSize,\n               sFlowCollectorAddressType, sFlowCollectorAddress,\n               sFlowCollectorPort, sFlowDatagramVersion }\n      STATUS current\n      DESCRIPTION\n        \"A collection of objects for managing the generation and\n         transportation of sFlow data records.\"\n       ::= { sFlowMIBGroups 1 }",
      "raw": true
    },
    {
      "indent": 0,
      "text": "END",
      "ja": "終わり"
    },
    {
      "indent": 3,
      "text": "The sFlow MIB references definitions from a number of existing RFCs [18], [19], [20] and [21].",
      "ja": "sFlow MIBは、既存のRFCの番号[18]、[19]、[20]及び[21]の定義を参照します。"
    },
    {
      "indent": 0,
      "text": "4. sFlow Datagram Format",
      "section_title": true,
      "ja": "4.のsFlowデータグラムフォーマット"
    },
    {
      "indent": 3,
      "text": "The sFlow datagram format specifies a standard format for the sFlow Agent to send sampled data to a remote data collector.",
      "ja": "sFlowデータグラムフォーマットは、リモート・データ・コレクタにサンプリングされたデータを送信するために、sFlowエージェントのための標準フォーマットを指定します。"
    },
    {
      "indent": 3,
      "text": "The format of the sFlow datagram is specified using the XDR standard [1]. XDR is more compact than ASN.1 and simpler for the sFlow Agent to encode and the sFlow Analyzer to decode.",
      "ja": "sFlowのデータグラムのフォーマットは、XDR標準を使用して指定されている[1]。 XDRは、sFlowエージェントは、符号化するとのsFlowアナライザは、デコードするためのASN.1と簡素よりもコンパクトです。"
    },
    {
      "indent": 3,
      "text": "Samples are sent as UDP packets to the host and port specified in the SFLOW MIB. The lack of reliability in the UDP transport mechanism does not significantly affect the accuracy of the measurements obtained from an sFlow Agent.",
      "ja": "サンプルはSFLOW MIBで指定したホストとポートにUDPパケットとして送信されます。 UDPトランスポート・メカニズムの信頼性の欠如は大幅にsFlowエージェントから得られた測定値の精度に影響を与えません。"
    },
    {
      "indent": 3,
      "text": "o If counter samples are lost then new values will be sent during the next polling interval. The chance of an undetected counter wrap is negligible. The sFlow datagram specifies 64 bit octet counters, and with typical counter polling intervals between 20 to 120 seconds, the chance of a long enough sequence of sFlow datagrams being lost to hide a counter wrap is very small.",
      "ja": "カウンタサンプルが失われた場合、O、新しい値は、次のポーリング間隔の間に送信されます。検出されないカウンタラップの可能性は無視できる程度です。 sFlowデータグラムは、64ビットのオクテットカウンタを指定し、20〜120秒の間の典型的なカウンタのポーリング間隔で、sFlowの十分な長いシーケンスのチャンスはカウンターラップを隠すために失われたデータグラムは非常に小さいです。"
    },
    {
      "indent": 3,
      "text": "o The net effect of lost flow samples is a slight reduction in the effective sampling rate.",
      "ja": "O失われたフローサンプルの正味の効果は、実効サンプリング・レートのわずかな減少です。"
    },
    {
      "indent": 3,
      "text": "The use of UDP reduces the amount of memory required to buffer data. UDP also provides a robust means of delivering timely traffic information during periods of intense traffic (such as a denial of service attack). UDP is more robust than a reliable transport mechanism because under overload the only effect on overall system performance is a slight increase in transmission delay and a greater number of lost packets, neither of which has a significant effect on an sFlow-based monitoring system. If a reliable transport mechanism were used then an overload would introduce long transmission delays and require large amounts of buffer memory on the agent.",
      "ja": "UDPの使用は、データをバッファリングするために必要なメモリの量を減らします。 UDPは、（そのようなサービス拒否攻撃など）強烈なトラフィックの期間中にタイムリーな交通情報を提供する強力な手段を提供します。下は、システム全体のパフォーマンスにのみ影響伝送遅延のわずかな増加とのsFlowベースの監視システムに大きな影響を与えるどちらも失われたパケットのより大きな数であるが過負荷ので、UDPは、信頼性の高い搬送機構よりも堅牢です。信頼性の高い転送メカニズムを使用した場合、過負荷が長い伝送遅延を導入し、エージェントにバッファメモリを大量に必要となります。"
    },
    {
      "indent": 3,
      "text": "While the sFlow Datagram structure permits multiple samples to be included in each datagram, the sampling agent must not wait for a buffer to fill with samples before sending the sample datagram. sFlow sampling is intended to provide timely information on traffic. The agent may at most delay a sample by 1 second before it is required to send the datagram.",
      "ja": "sFlowのデータグラムの構造は、各データグラムに含まれる複数のサンプルを許可している間、サンプリング・エージェントは、サンプルデータグラムを送信する前にサンプルを埋めるために、バッファを待たないでなければなりません。 sFlowのサンプリングは、トラフィックのタイムリーな情報を提供することを意図しています。データグラムを送信するために必要とされる前に、エージェントは、せいぜい1秒でサンプルを遅らせる可能性があります。"
    },
    {
      "indent": 3,
      "text": "The agent should try to piggyback counter samples on the datagram stream resulting from flow sampling. Before sending out a datagram the remaining space in the buffer can be filled with counter samples. The agent has discretion in the timing of its counter polling, the specified counter sampling intervals sFlowCounterSamplingInterval is a maximum, so the agent is free to sample counters early if it has space in a datagram. If counters must be sent in order to satisfy the maximum sampling interval then a datagram must be sent containing the outstanding counters.",
      "ja": "エージェントは、フローサンプリングに起因するデータグラムストリームにカウンタサンプルを便乗しようとする必要があります。データグラムを送信する前にバッファ内の残りの空間は、カウンターサンプルを充填することができます。エージェントは、そのカウンタのポーリング、sFlowCounterSamplingIntervalが最大で指定したカウンタのサンプリング間隔のタイミングで裁量権を持っているので、エージェントはデータグラム内のスペースを持っている場合は、早期のカウンターをサンプリングして自由です。カウンタは最大サンプリング間隔を満たすために送られなければならない場合、データグラムは優れたカウンタを含む送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "The following is the XDR description of an sFlow Datagram:",
      "ja": "次のsFlowデータグラムのXDRの説明は次のとおりです。"
    },
    {
      "indent": 0,
      "text": "/* sFlow Datagram Version 4 */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/* Revision History\n   - version 4 adds support BGP communities\n   - version 3 adds support for extended_url information\n*/",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/* sFlow Sample types */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/* Address Types */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "typedef opaque ip_v4[4];\ntypedef opaque ip_v6[16];",
      "raw": true
    },
    {
      "indent": 0,
      "text": "enum address_type { IP_V4 = 1, IP_V6 = 2 }",
      "ja": "列挙address_type {IP_V4 = 1、IP_V6 = 2}"
    },
    {
      "indent": 0,
      "text": "union address (address_type type) {\n   case IP_V4:\n     ip_v4;\n   case IP_V6:\n     ip_v6;\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/* Packet header data */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "const MAX_HEADER_SIZE = 256;   /* The maximum sampled header size. */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/* The header protocol describes the format of the sampled header */\nenum header_protocol {\n   ETHERNET-ISO8023     = 1,\n   ISO88024-TOKENBUS    = 2,\n   ISO88025-TOKENRING   = 3,\n   FDDI                 = 4,\n   FRAME-RELAY          = 5,\n   X25                  = 6,\n   PPP                  = 7,\n   SMDS                 = 8,\n   AAL5                 = 9,\n   AAL5-IP              = 10, /* e.g., Cisco AAL5 mux */\n   IPv4                 = 11,\n   IPv6                 = 12,\n   MPLS                 = 13\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "struct sampled_header {\n   header_protocol protocol;       /* Format of sampled header */\n   unsigned int frame_length;      /* Original length of packet before\n                                      sampling */\n   opaque header<MAX_HEADER_SIZE>; /* Header bytes */\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/* Packet IP version 4 data */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "struct sampled_ipv4 {",
      "ja": "構造体sampled_ipv4 {"
    },
    {
      "indent": 0,
      "text": "   unsigned int length;     /* The length of the IP packet excluding\n                               lower layer encapsulations */\n   unsigned int protocol;   /* IP Protocol type\n                               (for example, TCP = 6, UDP = 17) */\n   ip_v4 src_ip;            /* Source IP Address */\n   ip_v4 dst_ip;            /* Destination IP Address */\n   unsigned int src_port;   /* TCP/UDP source port number or\n                               equivalent */\n   unsigned int dst_port;   /* TCP/UDP destination port number or\n                               equivalent */\n   unsigned int tcp_flags;  /* TCP flags */\n   unsigned int tos;        /* IP type of service */\n}\n/* Packet IP version 6 data */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "struct sampled_ipv6 {\n   unsigned int length;     /* The length of the IP packet excluding\n                               lower layer encapsulations */\n   unsigned int protocol;   /* IP next header\n                               (for example, TCP = 6, UDP = 17) */\n   ip_v6 src_ip;            /* Source IP Address */\n   ip_v6 dst_ip;            /* Destination IP Address */\n   unsigned int src_port;   /* TCP/UDP source port number or\n                               equivalent */\n   unsigned int dst_port;   /* TCP/UDP destination port number or\n                               equivalent */\n   unsigned int tcp_flags;  /* TCP flags */\n   unsigned int priority;   /* IP priority */\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/* Packet data */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "enum packet_information_type {\n   HEADER  = 1,      /* Packet headers are sampled */\n   IPV4    = 2,      /* IP version 4 data */\n   IPV6    = 3       /* IP version 6 data */\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "union packet_data_type (packet_information_type type) {\n   case HEADER:\n      sampled_header header;\n   case IPV4:\n      sampled_ipv4 ipv4;\n   case IPV6:\n      sampled_ipv6 ipv6;\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/* Extended data types */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/* Extended switch data */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "struct extended_switch {\n   unsigned int src_vlan;     /* The 802.1Q VLAN id of incoming frame */\n   unsigned int src_priority; /* The 802.1p priority of incoming\n                                 frame */\n   unsigned int dst_vlan;     /* The 802.1Q VLAN id of outgoing frame */\n   unsigned int dst_priority; /* The 802.1p priority of outgoing\n                                 frame */\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/* Extended router data */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "struct extended_router {\n   address nexthop;         /* IP address of next hop router */\n   unsigned int src_mask;   /* Source address prefix mask bits */\n   unsigned int dst_mask;   /* Destination address prefix mask bits */\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/* Extended gateway data */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "enum as_path_segment_type {\n   AS_SET      = 1,            /* Unordered set of ASs */\n   AS_SEQUENCE = 2             /* Ordered set of ASs */\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "union as_path_type (as_path_segment_type) {\n   case AS_SET:\n      unsigned int as_set<>;\n   case AS_SEQUENCE:\n      unsigned int as_sequence<>;\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "struct extended_gateway {\n   unsigned int as;            /* Autonomous system number of router */\n   unsigned int src_as;        /* Autonomous system number of source */\n   unsigned int src_peer_as;   /* Autonomous system number of source\n                                  peer */\n   as_path_type dst_as_path<>; /* Autonomous system path to the\n                                  destination */\n   unsigned int communities<>; /* Communities associated with this\n                                  route */\n   unsigned int localpref;     /* LocalPref associated with this\n                                  route */\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/* Extended user data */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "struct extended_user {\n   string src_user<>;          /* User ID associated with packet\n                                  source */\n   string dst_user<>;          /* User ID associated with packet\n                                  destination */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "}",
      "ja": "｝"
    },
    {
      "indent": 0,
      "text": "/* Extended URL data */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "enum url_direction {\n   src    = 1,                 /* URL is associated with source\n                                  address */\n   dst    = 2                  /* URL is associated with destination\n                                  address */\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "struct extended_url {\n   url_direction direction;    /* URL associated with packet source */\n   string url<>;               /* URL associated with the packet flow */\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/* Extended data */\nenum extended_information_type {\n   SWITCH    = 1,      /* Extended switch information */\n   ROUTER    = 2,      /* Extended router information */\n   GATEWAY   = 3,      /* Extended gateway router information */\n   USER      = 4,      /* Extended TACACS/RADIUS user information */\n   URL       = 5       /* Extended URL information */\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "union extended_data_type (extended_information_type type) {\n   case SWITCH:\n      extended_switch switch;\n   case ROUTER:\n      extended_router router;\n   case GATEWAY:\n      extended_gateway gateway;\n   case USER:\n      extended_user user;\n   case URL:\n      extended_url url;\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/* Format of a single flow sample */ struct flow_sample {\nunsigned int sequence_number;    /* Incremented with each flow sample\n                                    generated by this source_id */\nunsigned int source_id;          /* sFlowDataSource encoded as follows:\n                                    The most significant byte of the\n                                    source_id is used to indicate the\n                                    type of sFlowDataSource\n                                    (0 = ifIndex,\n                                    1 = smonVlanDataSource,\n                                    2 = entPhysicalEntry) and the\n                                    lower three bytes contain the\n                                    relevant index value.*/",
      "raw": true
    },
    {
      "indent": 0,
      "text": "unsigned int sampling_rate;      /* sFlowPacketSamplingRate */\nunsigned int sample_pool;        /* Total number of packets that could\n                                    have been sampled (i.e., packets\n                                    skipped by sampling process + total\n                                    number of samples) */\nunsigned int drops;              /* Number times a packet was dropped\n                                    due to lack of resources */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "unsigned int input;               /* SNMP ifIndex of input interface.\n                                     0 if interface is not known.  */\nunsigned int output;              /* SNMP ifIndex of output interface,\n                                     0 if interface is not known.\n                                     Set most significant bit to\n                                     indicate multiple destination\n                                     interfaces (i.e., in case of\n                                     broadcast or multicast)\n                                     and set lower order bits to\n                                     indicate number of destination\n                                     interfaces.\n                                     Examples:\n                                        0x00000002  indicates ifIndex =\n                                                    2\n                                        0x00000000  ifIndex unknown.\n                                        0x80000007  indicates a packet\n                                                    sent to 7\n                                                    interfaces.\n                                        0x80000000  indicates a packet\n                                                    sent to an unknown\n                                                    number of interfaces\n                                                    greater than 1. */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "   packet_data_type packet_data;       /* Information about sampled\n                                          packet */\n   extended_data_type extended_data<>; /* Extended flow information */\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/* Counter types */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/* Generic interface counters - see RFC 2233 */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "struct if_counters {\n   unsigned int ifIndex;\n   unsigned int ifType;\n   unsigned hyper ifSpeed;\n   unsigned int ifDirection;    /* derived from MAU MIB (RFC 2668)\n                                   0 = unknown, 1=full-duplex,\n                                   2=half-duplex, 3 = in, 4=out */\n   unsigned int ifStatus;       /* bit field with the following bits\n                                   assigned\n                                   bit 0 = ifAdminStatus\n                                     (0 = down, 1 = up)\n                                   bit 1 = ifOperStatus\n                                     (0 = down, 1 = up) */\n   unsigned hyper ifInOctets;\n   unsigned int ifInUcastPkts;\n   unsigned int ifInMulticastPkts;\n   unsigned int ifInBroadcastPkts;\n   unsigned int ifInDiscards;\n   unsigned int ifInErrors;\n   unsigned int ifInUnknownProtos;\n   unsigned hyper ifOutOctets;\n   unsigned int ifOutUcastPkts;\n   unsigned int ifOutMulticastPkts;\n   unsigned int ifOutBroadcastPkts;\n   unsigned int ifOutDiscards;\n   unsigned int ifOutErrors;\n   unsigned int ifPromiscuousMode;\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/* Ethernet interface counters - see RFC 2358 */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "struct ethernet_counters {\n   if_counters generic;\n   unsigned int dot3StatsAlignmentErrors;\n   unsigned int dot3StatsFCSErrors;\n   unsigned int dot3StatsSingleCollisionFrames;\n   unsigned int dot3StatsMultipleCollisionFrames;\n   unsigned int dot3StatsSQETestErrors;\n   unsigned int dot3StatsDeferredTransmissions;\n   unsigned int dot3StatsLateCollisions;\n   unsigned int dot3StatsExcessiveCollisions;\n   unsigned int dot3StatsInternalMacTransmitErrors;\n   unsigned int dot3StatsCarrierSenseErrors;\n   unsigned int dot3StatsFrameTooLongs;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "   unsigned int dot3StatsInternalMacReceiveErrors;\n   unsigned int dot3StatsSymbolErrors;\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/* FDDI interface counters - see RFC 1512 */\nstruct fddi_counters {\n  if_counters generic;\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/* Token ring counters - see RFC 1748 */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "struct tokenring_counters {\n  if_counters generic;\n  unsigned int dot5StatsLineErrors;\n  unsigned int dot5StatsBurstErrors;\n  unsigned int dot5StatsACErrors;\n  unsigned int dot5StatsAbortTransErrors;\n  unsigned int dot5StatsInternalErrors;\n  unsigned int dot5StatsLostFrameErrors;\n  unsigned int dot5StatsReceiveCongestions;\n  unsigned int dot5StatsFrameCopiedErrors;\n  unsigned int dot5StatsTokenErrors;\n  unsigned int dot5StatsSoftErrors;\n  unsigned int dot5StatsHardErrors;\n  unsigned int dot5StatsSignalLoss;\n  unsigned int dot5StatsTransmitBeacons;\n  unsigned int dot5StatsRecoverys;\n  unsigned int dot5StatsLobeWires;\n  unsigned int dot5StatsRemoves;\n  unsigned int dot5StatsSingles;\n  unsigned int dot5StatsFreqErrors;\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/* 100 BaseVG interface counters - see RFC 2020 */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "struct vg_counters {\n  if_counters generic;\n  unsigned int dot12InHighPriorityFrames;\n  unsigned hyper dot12InHighPriorityOctets;\n  unsigned int dot12InNormPriorityFrames;\n  unsigned hyper dot12InNormPriorityOctets;\n  unsigned int dot12InIPMErrors;\n  unsigned int dot12InOversizeFrameErrors;\n  unsigned int dot12InDataErrors;\n  unsigned int dot12InNullAddressedFrames;\n  unsigned int dot12OutHighPriorityFrames;\n  unsigned hyper dot12OutHighPriorityOctets;\n  unsigned int dot12TransitionIntoTrainings;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "  unsigned hyper dot12HCInHighPriorityOctets;\n  unsigned hyper dot12HCInNormPriorityOctets;\n  unsigned hyper dot12HCOutHighPriorityOctets;\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/* WAN counters */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "struct wan_counters { if_counters generic; }",
      "ja": "if_countersジェネリック構造体wan_counters {; }"
    },
    {
      "indent": 0,
      "text": "/* VLAN counters */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "struct vlan_counters {\n  unsigned int vlan_id;\n  unsigned hyper octets;\n  unsigned int ucastPkts;\n  unsigned int multicastPkts;\n  unsigned int broadcastPkts;\n  unsigned int discards;\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/* Counter data */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "enum counters_version { GENERIC = 1, ETHERNET = 2, TOKENRING = 3, FDDI = 4, VG = 5, WAN = 6, VLAN = 7 }",
      "ja": "列挙counters_version {1 = GENERIC、ETHERNET = 2、TOKENRING = 3、FDDI = 4、VG = 5、WAN = 6、VLAN = 7}"
    },
    {
      "indent": 0,
      "text": "union counters_type (counters_version version) {\n   case GENERIC:\n      if_counters generic;\n   case ETHERNET:\n      ethernet_counters ethernet;\n   case TOKENRING:\n      tokenring_counters tokenring;\n   case FDDI:\n      fddi_counters fddi;\n   case VG:\n      vg_counters vg;\n   case WAN:\n      wan_counters wan;\n   case VLAN:",
      "raw": true
    },
    {
      "indent": 0,
      "text": " vlan_counters vlan; }",
      "ja": "VLANをvlan_counters。 }"
    },
    {
      "indent": 0,
      "text": "/* Format of a single counter sample */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "struct counters_sample {\n   unsigned int sequence_number;   /* Incremented with each counter\n                                      sample generated by this\n                                      source_id */\n   unsigned int source_id;         /* sFlowDataSource encoded as\n                                      follows:\n                                       The most significant byte of the\n                                       source_id is used to indicate the\n                                       type of sFlowDataSource\n                                       (0 = ifIndex,\n                                       1 = smonVlanDataSource,\n                                       2 = entPhysicalEntry) and the\n                                           lower three\n                                       bytes contain the relevant\n                                       index value.*/",
      "raw": true
    },
    {
      "indent": 0,
      "text": "   unsigned int sampling_interval; /* sFlowCounterSamplingInterval*/\n   counters_type counters;\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/* Format of a sample datagram */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "enum sample_types { FLOWSAMPLE = 1, COUNTERSSAMPLE = 2 }",
      "ja": "列挙sample_types {FLOWSAMPLE = 1、COUNTERSSAMPLE = 2}"
    },
    {
      "indent": 0,
      "text": "union sample_type (sample_types sampletype) {\n   case FLOWSAMPLE:\n      flow_sample flowsample;\n   case COUNTERSSAMPLE:\n      counters_sample counterssample;\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "struct sample_datagram_v4 {\n   address agent_address           /* IP address of sampling agent,\n                                      sFlowAgentAddress. */\n   unsigned int sequence_number;  /* Incremented with each sample\n                                     datagram generated */\n   unsigned int uptime;           /* Current time (in milliseconds since\n                                     device last booted).  Should be set\n                                     as close to datagram transmission\n                                     time as possible.*/",
      "raw": true
    },
    {
      "indent": 0,
      "text": "   sample_type samples<>;         /* An array of flow, counter and delay\n                                     samples */\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "enum datagram_version { VERSION4 = 4 }",
      "ja": "列挙datagram_version {バージョン4 = 4}"
    },
    {
      "indent": 0,
      "text": "union sample_datagram_type (datagram_version version) { case VERSION4: sample_datagram_v4 datagram; }",
      "ja": "組合sample_datagram_type（datagram_version版）{ケースバージョン4：sample_datagram_v4グラム。 }"
    },
    {
      "indent": 0,
      "text": "struct sample_datagram { sample_datagram_type version; }",
      "ja": "構造体sample_datagram {sample_datagram_typeバージョン。 }"
    },
    {
      "indent": 3,
      "text": "The sFlow Datagram specification makes use of definitions from a number of existing RFCs [22], [23], [24], [25], [26], [27] and [28].",
      "ja": "sFlowのデータグラム仕様は既存のRFCの番号[22]、[23]、[24]、[25]、[26]、[27]及び[28]の定義を利用します。"
    },
    {
      "indent": 0,
      "text": "5. Security Considerations",
      "section_title": true,
      "ja": "5.セキュリティについての考慮事項"
    },
    {
      "indent": 3,
      "text": "Deploying a traffic monitoring system raises a number of security related issues. sFlow does not provide specific security mechanisms, relying instead on proper deployment and configuration to maintain an adequate level of security.",
      "ja": "トラフィック監視システムを導入すると、セキュリティ関連の問題の数を発生させます。 sFlowのは、セキュリティの適切なレベルを維持するために、適切な展開と構成に頼っ、特定のセキュリティメカニズムを提供していません。"
    },
    {
      "indent": 3,
      "text": "While the deployment of traffic monitoring systems does create some risk, it also provides a powerful means of detecting and tracing unauthorized network activity.",
      "ja": "トラフィック監視システムの導入は、いくつかのリスクを作成していますが、それはまた、不正なネットワーク活動を検出し、トレースの強力な手段を提供します。"
    },
    {
      "indent": 3,
      "text": "This section is intended to provide information that will help understand potential risks and configuration options for mitigating those risks.",
      "ja": "このセクションでは、これらのリスクを軽減するための潜在的なリスクや設定オプションを理解するのに役立ちます情報を提供することを意図しています。"
    },
    {
      "indent": 0,
      "text": "5.1 Control",
      "section_title": true,
      "ja": "5.1コントロール"
    },
    {
      "indent": 3,
      "text": "The sFlow MIB is used to configure the generation of sFlow samples. The security of SNMP, with access control lists, is usually considered adequate in an enterprise setting. However, there are situations when these security measures are insufficient (for example a WAN router) and SNMP configuration control will be disabled.",
      "ja": "sFlow MIBは、sFlowのサンプルの生成を設定するために使用されます。アクセス制御リストとSNMPのセキュリティは、通常、企業の設定で十分な考えられています。これらのセキュリティ対策が不十分である（例えばWANルータ）とSNMPの構成制御は無効になりますしかし、状況があります。"
    },
    {
      "indent": 3,
      "text": "When SNMP is disabled, a command line interface is typically provided. The following arguments are required to configure sFlow sampling on an interface.",
      "ja": "SNMPが無効になっている場合は、コマンド・ライン・インターフェースは、一般的に提供されます。次の引数は、インターフェイス上のsFlowサンプリングを設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "-sFlowDataSource <source> -sFlowPacketSamplingRate <rate> -sFlowCounterSamplingInterval <interval> -sFlowMaximumHeaderSize <header size> -sFlowMaximumDatagramSize <datagram size> -sFlowCollectorAddress <address> -sFlowCollectorPort <port>",
      "ja": "-sFlowDataSource <ソース> -sFlowPacketSamplingRate <速度> -sFlowCounterSamplingInterval <間隔> -sFlowMaximumHeaderSize <ヘッダサイズ> -sFlowMaximumDatagramSize <データグラムサイズ> -sFlowCollectorAddress <アドレス> -sFlowCollectorPort <ポート>"
    },
    {
      "indent": 0,
      "text": "5.2 Transport",
      "section_title": true,
      "ja": "5.2交通"
    },
    {
      "indent": 3,
      "text": "Traffic information is sent unencrypted across the network from the sFlow Agent to the sFlow Analyzer and is thus vulnerable to eavesdropping. This risk can be limited by creating a secure measurement network and routing the sFlow Datagrams over this network. The choice of technology for creating the secure measurement network is deployment specific, but could include the use of VLANs or VPN tunnels.",
      "ja": "交通情報は、sFlowエージェントからのsFlowアナライザにネットワーク経由で暗号化されずに送信して盗聴することは脆弱です。このリスクは、安全な測定ネットワークを作成し、このネットワーク上のsFlowデータグラムをルーティングすることによって制限することができます。安全な測定ネットワークを作成するための技術の選択は、展開固有のものですが、VLANまたはVPNトンネルの使用を含めることができます。"
    },
    {
      "indent": 3,
      "text": "The sFlow Analyzer is vulnerable to attacks involving spoofed sFlow Datagrams. To limit this vulnerability the sFlow Analyzer should check sequence numbers and verify source addresses. If a secure measurement network has been constructed then only sFlow Datagrams received from that network should be processed.",
      "ja": "sFlowのアナライザは、偽装されたsFlowデータグラムを含む攻撃に対して脆弱です。この脆弱性を制限するためのsFlowアナライザは、シーケンス番号をチェックして、送信元アドレスを確認する必要があります。安全な測定網のみのsFlowデータグラムがそのネットワークから受信し、次に構築されている場合に処理されるべきです。"
    },
    {
      "indent": 0,
      "text": "5.3 Confidentiality",
      "section_title": true,
      "ja": "5.3機密性"
    },
    {
      "indent": 3,
      "text": "Traffic information can reveal confidential information about individual network users. The degree of visibility of application level data can be controlled by limiting the number of header bytes captured by the sFlow agent. In addition, packet sampling makes it virtually impossible to capture sequences of packets from an individual transaction.",
      "ja": "交通情報は、個々のネットワークユーザに関する機密情報を明らかにすることができます。アプリケーションレベルのデータの可視性の程度は、sFlowのエージェントによって捕捉ヘッダ・バイトの数を制限することによって制御することができます。また、パケットサンプリングは、それが事実上不可能、個々のトランザクションからのパケットのシーケンスをキャプチャすることができます。"
    },
    {
      "indent": 3,
      "text": "The traffic patterns discernible by decoding the sFlow Datagrams in the sFlow Analyzer can reveal details of an individual's network related activities and due care should be taken to secure access to the sFlow Analyzer.",
      "ja": "個々のネットワーク関連の活動と細心の注意の詳細を明らかにすることができたsFlowアナライザでのsFlowデータグラムをデコードすることにより、識別可能なトラフィックパターンは、sFlowのアナライザへのアクセスを確保するために取られるべきです。"
    },
    {
      "indent": 0,
      "text": "6. References",
      "section_title": true,
      "ja": "6.参照"
    },
    {
      "indent": 3,
      "text": "[1] Sun Microsystems, Inc., \"XDR: External Data Representation Standard\", RFC 1014, June 1987.",
      "ja": "[1]サン・マイクロシステムズ社、 \"XDR：外部データ表現標準\"、RFC 1014、1987年6月。"
    },
    {
      "indent": 3,
      "text": "[2] Harrington, D., Presuhn, R., and B. Wijnen, \"An Architecture for Describing SNMP Management Frameworks\", RFC 2571, April 1999.",
      "ja": "[2]ハリントン、D.、Presuhn、R.、およびB. Wijnenの、RFC 2571、1999年4月 \"SNMP管理フレームワークを記述するためのアーキテクチャ\"。"
    },
    {
      "indent": 3,
      "text": "[3] Rose, M. and K. McCloghrie, \"Structure and Identification of Management Information for TCP/IP-based Internets\", STD 16, RFC 1155, May 1990.",
      "ja": "[3]ローズ、M.、およびK. McCloghrie、 \"構造とTCP / IPベースのインターネットのための経営情報の識別\"、STD 16、RFC 1155、1990年5月を。"
    },
    {
      "indent": 3,
      "text": "[4] Rose, M. and K. McCloghrie, \"Concise MIB Definitions\", STD 16, RFC 1212, March 1991.",
      "ja": "[4]ローズ、M.、およびK. McCloghrie、 \"簡潔なMIB定義\"、STD 16、RFC 1212、1991年3月。"
    },
    {
      "indent": 3,
      "text": "[5] Rose, M., \"A Convention for Defining Traps for use with the SNMP\", RFC 1215, March 1991.",
      "ja": "[5]ローズ、M.、 \"SNMPとの使用のためのDefining Trapsのための条約\"、RFC 1215、1991年3月。"
    },
    {
      "indent": 3,
      "text": "[6] McCloghrie, K., Perkins, D., Schoenwaelder, J., Case, J., Rose, M. and S. Waldbusser, \"Structure of Management Information Version 2 (SMIv2)\", STD 58, RFC 2578, April 1999.",
      "ja": "[6] McCloghrie、K.、パーキンス、D.、Schoenwaelder、J.、ケース、J.、ローズ、M.およびS. Waldbusser、 \"経営情報バージョン2（SMIv2）の構造\"、STD 58、RFC 2578、 1999年4月。"
    },
    {
      "indent": 3,
      "text": "[7] McCloghrie, K., Perkins, D., Schoenwaelder, J., Case, J., Rose, M. and S. Waldbusser, \"Textual Conventions for SMIv2\", STD 58, RFC 2579, April 1999.",
      "ja": "[7] McCloghrie、K.、パーキンス、D.、Schoenwaelder、J.、ケース、J.、ローズ、M.およびS. Waldbusser、 \"SMIv2のためのテキストの表記法\"、STD 58、RFC 2579、1999年4月。"
    },
    {
      "indent": 3,
      "text": "[8] McCloghrie, K., Perkins, D., Schoenwaelder, J., Case, J., Rose, M. and S. Waldbusser, \"Conformance Statements for SMIv2\", STD 58, RFC 2580, April 1999.",
      "ja": "[8] McCloghrie、K.、パーキンス、D.、Schoenwaelder、J.、ケース、J.、ローズ、M.およびS. Waldbusser、STD 58、RFC 2580、1999年4月 \"SMIv2のための順応文\"。"
    },
    {
      "indent": 3,
      "text": "[9] Case, J., Fedor, M., Schoffstall, M. and J. Davin, \"Simple Network Management Protocol\", STD 15, RFC 1157, May 1990.",
      "ja": "[9]ケース、J.、ヒョードル、M.、Schoffstall、M.、およびJ.デーヴィン、 \"簡単なネットワーク管理プロトコル\"、STD 15、RFC 1157、1990年5月。"
    },
    {
      "indent": 3,
      "text": "[10] Case, J., McCloghrie, K., Rose, M. and S. Waldbusser, \"Introduction to Community-based SNMPv2\", RFC 1901, January 1996.",
      "ja": "[10]ケース、J.、McCloghrie、K.、ローズ、M.およびS. Waldbusser、 \"コミュニティベースのSNMPv2の概要\"、RFC 1901、1996年1月。"
    },
    {
      "indent": 3,
      "text": "[11] Case, J., McCloghrie, K., Rose, M. and S. Waldbusser, \"Transport Mappings for Version 2 of the Simple Network Management Protocol (SNMPv2)\", RFC 1906, January 1996.",
      "ja": "[11]ケース、J.、McCloghrie、K.、ローズ、M.、およびS. Waldbusser、RFC 1906 \"簡易ネットワーク管理プロトコル（SNMPv2）のバージョン2のための交通マッピング\"、1996年1月。"
    },
    {
      "indent": 3,
      "text": "[12] Case, J., Harrington D., Presuhn R. and B. Wijnen, \"Message Processing and Dispatching for the Simple Network Management Protocol (SNMP)\", RFC 2572, April 1999.",
      "ja": "[12]ケース、J.、ハリントンD.、Presuhn R.とB. Wijnenの、 \"メッセージ処理と簡単なネットワーク管理プロトコル（SNMP）のための派遣\"、RFC 2572、1999年4月。"
    },
    {
      "indent": 3,
      "text": "[13] Blumenthal, U. and B. Wijnen, \"User-based Security Model (USM) for version 3 of the Simple Network Management Protocol (SNMPv3)\", RFC 2574, April 1999.",
      "ja": "[13]ブルーメンソール、U.とB. Wijnenの、 \"ユーザベースセキュリティモデル（USM）簡易ネットワーク管理プロトコル（SNMPv3の）のバージョン3のために\"、RFC 2574、1999年4月。"
    },
    {
      "indent": 3,
      "text": "[14] Case, J., McCloghrie, K., Rose, M. and S. Waldbusser, \"Protocol Operations for Version 2 of the Simple Network Management Protocol (SNMPv2)\", RFC 1905, January 1996.",
      "ja": "[14]ケース、J.、McCloghrie、K.、ローズ、M.、およびS. Waldbusser、 \"簡易ネットワーク管理プロトコルのバージョン2のためのプロトコル操作（SNMPv2の）\"、RFC 1905、1996年1月。"
    },
    {
      "indent": 3,
      "text": "[15] Levi, D., Meyer, P. and B. Stewart, \"SNMPv3 Applications\", RFC 2573, April 1999.",
      "ja": "[15]レビ、D.、マイヤー、P.およびB.スチュワート、 \"SNMPv3のアプリケーション\"、RFC 2573、1999年4月。"
    },
    {
      "indent": 3,
      "text": "[16] Wijnen, B., Presuhn, R. and K. McCloghrie, \"View-based Access Control Model (VACM) for the Simple Network Management Protocol (SNMP)\", RFC 2575, April 1999.",
      "ja": "[16] Wijnenの、B.、Presuhn、R.とK. McCloghrie、 \"簡易ネットワーク管理プロトコルのためのビューベースアクセス制御モデル（VACM）（SNMP）\"、RFC 2575、1999年4月。"
    },
    {
      "indent": 3,
      "text": "[17] Case, J., Mundy, R., Partain, D. and B. Stewart, \"Introduction to Version 3 of the Internet-standard Network Management Framework\", RFC 2570, April 1999.",
      "ja": "[17]ケース、J.、マンディ、R.、パーテイン、D.とB.スチュワート、 \"インターネット標準ネットワーク管理フレームワークのバージョン3への序論\"、RFC 2570、1999年4月。"
    },
    {
      "indent": 3,
      "text": "[18] Waldbusser, S., \"Remote Network Monitoring Management Information Base\", RFC 2819, May 2000.",
      "ja": "[18] Waldbusser、S.、 \"管理情報ベースのリモートネットワーク監視\"、RFC 2819、2000年5月。"
    },
    {
      "indent": 3,
      "text": "[19] Waterman, R., Lahaye, B., Romascanu, D. and S. Waldbusser, \"Remote Network Monitoring MIB Extensions for Switched Networks Version 1.0\", RFC 2613, June 1999.",
      "ja": "[19]ウォーターマン、R.、Lahaye、B.、Romascanu、D.とS. Waldbusser、 \"リモートネットワーク監視スイッチングネットワークバージョン1.0のMIB拡張機能\"、RFC 2613、1999年6月。"
    },
    {
      "indent": 3,
      "text": "[20] Daniele, M., Haberman, B., Routhier, S. and J. Schoenwaelder, \"Textual Conventions for Internet Network Addresses\", RFC 2851, June 2000.",
      "ja": "[20]ダニエル、M.、ハーバーマン、B.、Routhier、S.およびJ. Schoenwaelder、 \"インターネットネットワークアドレスのためのテキストの表記法\"、RFC 2851、2000年6月。"
    },
    {
      "indent": 3,
      "text": "[21] Brownlee, N., \"Traffic Flow Measurement: Meter MIB\", RFC 2720, October 1999.",
      "ja": "[21]ブラウンリー、N.、 \"トラフィックフロー測定：メーターMIB\"、RFC 2720、1999年10月。"
    },
    {
      "indent": 3,
      "text": "[22] Smith, A., Flick, J., de Graaf, K., Romanscanu, D., McMaster, D., McCloghrie, K. and S. Roberts, \"Definition of Managed Objects for IEEE 802.3 Medium Attachment Units (MAUs)\", RFC 2668, August 1999.",
      "ja": "[22]スミス、A.、フリック、J.、デ・グラーフ、K.、Romanscanu、D.、マクマスター、D.、McCloghrie、K.およびS.ロバーツ、「IEEE 802.3媒体接続ユニットのための管理オブジェクトの定義（ MAU）」、RFC 2668、1999年8月。"
    },
    {
      "indent": 3,
      "text": "[23] McCloghrie, K. and F. Kastenholz, \"The Interfaces Group MIB using SMIv2\", RFC 2233, November 1997.",
      "ja": "[23] McCloghrie、K.およびF. Kastenholzと、 \"SMIv2のを使用してインターフェイスグループMIB\"、RFC 2233、1997年11月。"
    },
    {
      "indent": 3,
      "text": "[24] Flick, J. and J. Johnson, \"Definition of Managed Objects for the Ethernet-like Interface Types\", RFC 2358, June 1998.",
      "ja": "[24]フリック、J.とJ.ジョンソン、「イーサネットのようなインターフェース型のための管理オブジェクトの定義」、RFC 2358、1998年6月。"
    },
    {
      "indent": 3,
      "text": "[25] Case, J., \"FDDI Management Information Base\", RFC 1512, September 1993.",
      "ja": "[25]ケース、J.、 \"FDDI管理情報ベース\"、RFC 1512、1993年9月。"
    },
    {
      "indent": 3,
      "text": "[26] McCloghrie, K. and E. Decker, \"IEEE 802.5 MIB using SMIv2\", RFC 1748, December 1994.",
      "ja": "[26] McCloghrie、K.およびE.デッカー、 \"SMIv2のを使用してIEEE 802.5 MIB\"、RFC 1748、1994年12月。"
    },
    {
      "indent": 3,
      "text": "[27] Flick, J., \"Definitions of Managed Objects for IEEE 802.12 Interfaces\", RFC 2020, October 1996.",
      "ja": "[27]フリック、J.、RFC 2020、1996年10月 \"IEEE 802.12インタフェースのための管理オブジェクトの定義\"。"
    },
    {
      "indent": 3,
      "text": "[28] Willis, S., Burruss, J. and J. Chu, \"Definitions of Managed Objects for the Fourth Version of the Border Gateway Protocol (BGP-4) using SMIv2\", RFC 1657, July 1994.",
      "ja": "[28]ウィリス、S.、Burruss、J.およびJ.チュー、RFC 1657、1994年7月 \"SMIv2のを使用してボーダーゲートウェイプロトコル（BGP-4）第4版のための管理オブジェクトの定義\"。"
    },
    {
      "indent": 0,
      "text": "7. Authors' Addresses",
      "section_title": true,
      "ja": "7.著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Peter Phaal InMon Corporation 1404 Irving Street San Francisco, CA 94122",
      "ja": "ピーター・秋1404アーヴィングストリート、サンフランシスコ、イマーム株式会社、K 94122"
    },
    {
      "indent": 3,
      "text": "Phone: (415) 661-6343 EMail: peter_phaal@INMON.COM",
      "ja": "電話：（415）661-6343 Eメール：peter_phaal@INMON.COM"
    },
    {
      "indent": 3,
      "text": "Sonia Panchen InMon Corporation 1404 Irving Street San Francisco, CA 94122",
      "ja": "ソニアパンチェン米国InMon Corp. 1404アーヴィングストリート、サンフランシスコ、CA 94122"
    },
    {
      "indent": 3,
      "text": "Phone: (415) 661-6343 EMail: sonia_panchen@INMON.COM",
      "ja": "電話：（415）661-6343 Eメール：sonia_panchen@INMON.COM"
    },
    {
      "indent": 3,
      "text": "Neil McKee InMon Corporation 1404 Irving Street San Francisco, CA 94122",
      "ja": "ニール・マッキー米国InMon Corp. 1404アーヴィングストリート、サンフランシスコ、CA 94122"
    },
    {
      "indent": 3,
      "text": "Phone: (415) 661-6343 EMail: neil_mckee@INMON.COM",
      "ja": "電話：（415）661-6343 Eメール：neil_mckee@INMON.COM"
    },
    {
      "indent": 0,
      "text": "8. Intellectual Property Statement",
      "section_title": true,
      "ja": "8.知的財産権に関する声明"
    },
    {
      "indent": 3,
      "text": "The IETF takes no position regarding the validity or scope of any intellectual property or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; neither does it represent that it has made any effort to identify any such rights. Information on the IETF's procedures with respect to rights in standards-track and standards-related documentation can be found in BCP-11. Copies of claims of rights made available for publication and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementors or users of this specification can be obtained from the IETF Secretariat.",
      "ja": "IETFは、そのような権限下で、ライセンスがたりないかもしれない可能性があるためにどの本書または程度に記載されている技術の実装や使用に関係すると主張される可能性があります任意の知的財産やその他の権利の有効性または範囲に関していかなる位置を取りません利用可能。また、そうした権利を特定するために取り組んできたことを表していないん。スタンダードトラックおよび標準関連文書における権利に関するIETFの手続きの情報は、BCP-11に記載されています。権利の主張のコピーは、出版のために利用可能とライセンスの保証が利用できるようにする、または本仕様の実装者または利用者が、そのような所有権の使用のための一般的なライセンスまたは許可を取得するために作られた試みの結果を得ることができますIETF事務局から。"
    },
    {
      "indent": 3,
      "text": "The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights which may cover technology that may be required to practice this standard. Please address the information to the IETF Executive Director.",
      "ja": "IETFは、その注意にこの標準を実践するために必要な場合があり技術をカバーすることができる任意の著作権、特許または特許出願、またはその他の所有権を持ってすべての利害関係者を招待します。 IETF専務に情​​報を扱ってください。"
    },
    {
      "indent": 0,
      "text": "9. Full Copyright Statement",
      "section_title": true,
      "ja": "9.完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2001). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2001）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.",
      "ja": "この文書とその翻訳は、コピーして他の人に提供し、それ以外についてはコメントまたは派生物は、いかなる種類の制限もなく、全体的にまたは部分的に、準備コピーし、公表して配布することができることを説明したり、その実装を支援することができます、上記の著作権表示とこの段落は、すべてのそのようなコピーや派生物に含まれていることを条件とします。しかし、この文書自体は著作権のための手順はで定義されている場合には、インターネット標準を開発するために必要なものを除き、インターネットソサエティもしくは他のインターネット関連団体に著作権情報や参照を取り除くなど、どのような方法で変更されないかもしれませんインターネット標準化プロセスが続く、または英語以外の言語に翻訳するために、必要に応じなければなりません。"
    },
    {
      "indent": 3,
      "text": "The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.",
      "ja": "上記の制限は永久で、インターネット学会やその後継者や譲渡者によって取り消されることはありません。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein is provided on an \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書とここに含まれている情報は、基礎とインターネットソサエティおよびインターネットエンジニアリングタスクフォースはすべての保証を否認し、明示または黙示、その情報の利用がない任意の保証を含むがこれらに限定されない「として、」上に設けられています特定の目的への権利または商品性または適合性の黙示の保証を侵害します。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFC Editor機能のための基金は現在、インターネット協会によって提供されます。"
    }
  ]
}