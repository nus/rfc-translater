{
  "title": {
    "text": "RFC 3259 - A Message Bus for Local Coordination",
    "ja": "RFC 3259 - 現地調整のためのメッセージバス"
  },
  "number": 3259,
  "created_at": "2019-10-25 16:25:24.954796+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                             J. Ott\nRequest for Comments: 3259                      TZI, Universitaet Bremen\nCategory: Informational                                       C. Perkins\n                                      USC Information Sciences Institute\n                                                             D. Kutscher\n                                                TZI, Universitaet Bremen\n                                                              April 2002",
      "raw": true
    },
    {
      "indent": 18,
      "text": "A Message Bus for Local Coordination",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "ja": "このメモの位置付け"
    },
    {
      "indent": 3,
      "text": "This memo provides information for the Internet community. It does not specify an Internet standard of any kind. Distribution of this memo is unlimited.",
      "ja": "このメモはインターネットコミュニティのための情報を提供します。それはどんな種類のインターネット標準を指定しません。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2002). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2002）。全著作権所有。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "The local Message Bus (Mbus) is a light-weight message-oriented coordination protocol for group communication between application components. The Mbus provides automatic location of communication peers, subject based addressing, reliable message transfer and different types of communication schemes. The protocol is layered on top of IP multicast and is specified for IPv4 and IPv6. The IP multicast scope is limited to link-local multicast. This document specifies the Mbus protocol, i.e., message syntax, addressing and transport mechanisms.",
      "ja": "ローカル・メッセージ・バス（Mバス）は、アプリケーションのコンポーネント間のグループ通信のための軽量メッセージ指向協調プロトコルです。 Mバスは、通信ピア、アドレッシング基づいて被写体、信頼性の高いメッセージ転送及び通信方式の異なるタイプの自動場所を提供します。プロトコルは、IPマルチキャストの上部に積層され、IPv4およびIPv6のために指定されます。 IPマルチキャストスコープはリンクローカルマルチキャストに制限されています。この文書では、Mバス・プロトコル、即ち、メッセージ構文、アドレッシング及び搬送機構を指定します。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.    Introduction . . . . . . . . . . . . . . . . . . . . . . . .  3\n1.1   Mbus Overview  . . . . . . . . . . . . . . . . . . . . . . .  3\n1.2   Purpose of this Document . . . . . . . . . . . . . . . . . .  5\n1.3   Areas of Application . . . . . . . . . . . . . . . . . . . .  5\n1.4   Terminology for requirement specifications . . . . . . . . .  6\n2.    Common Formal Syntax Rules . . . . . . . . . . . . . . . . .  6\n3.    Message Format . . . . . . . . . . . . . . . . . . . . . . .  7\n4.    Addressing . . . . . . . . . . . . . . . . . . . . . . . . .  9\n4.1   Mandatory Address Elements . . . . . . . . . . . . . . . . . 10\n5.    Message Syntax . . . . . . . . . . . . . . . . . . . . . . . 11\n5.1   Message Encoding . . . . . . . . . . . . . . . . . . . . . . 11\n5.2   Message Header . . . . . . . . . . . . . . . . . . . . . . . 11\n5.3   Command Syntax . . . . . . . . . . . . . . . . . . . . . . . 12",
      "raw": true
    },
    {
      "indent": 3,
      "text": "6.    Transport  . . . . . . . . . . . . . . . . . . . . . . . . . 13\n6.1   Local Multicast/Broadcast  . . . . . . . . . . . . . . . . . 14\n6.1.1 Mbus multicast groups for IPv4 . . . . . . . . . . . . . . . 15\n6.1.2 Mbus multicast groups for IPv6 . . . . . . . . . . . . . . . 15\n6.1.3 Use of Broadcast . . . . . . . . . . . . . . . . . . . . . . 16\n6.1.4 Mbus UDP Port Number . . . . . . . . . . . . . . . . . . . . 16\n6.2   Directed Unicast . . . . . . . . . . . . . . . . . . . . . . 16\n7.    Reliability  . . . . . . . . . . . . . . . . . . . . . . . . 18\n8.    Awareness of other Entities  . . . . . . . . . . . . . . . . 20\n8.1   Hello Message Transmission Interval  . . . . . . . . . . . . 21\n8.1.1 Calculating the Interval for Hello Messages  . . . . . . . . 22\n8.1.2 Initialization of Values . . . . . . . . . . . . . . . . . . 23\n8.1.3 Adjusting the Hello Message Interval when the Number of\n      Entities increases . . . . . . . . . . . . . . . . . . . . . 23\n8.1.4 Adjusting the Hello Message Interval when the Number of\n      Entities decreases . . . . . . . . . . . . . . . . . . . . . 23\n8.1.5 Expiration of hello timers . . . . . . . . . . . . . . . . . 23\n8.2   Calculating the Timeout for Mbus Entities  . . . . . . . . . 24\n9.    Messages . . . . . . . . . . . . . . . . . . . . . . . . . . 24\n9.1   mbus.hello . . . . . . . . . . . . . . . . . . . . . . . . . 24\n9.2   mbus.bye . . . . . . . . . . . . . . . . . . . . . . . . . . 25\n9.3   mbus.ping  . . . . . . . . . . . . . . . . . . . . . . . . . 25\n9.4   mbus.quit  . . . . . . . . . . . . . . . . . . . . . . . . . 26\n9.5   mbus.waiting . . . . . . . . . . . . . . . . . . . . . . . . 26\n9.6   mbus.go  . . . . . . . . . . . . . . . . . . . . . . . . . . 27\n10.   Constants  . . . . . . . . . . . . . . . . . . . . . . . . . 27\n11.   Mbus Security  . . . . . . . . . . . . . . . . . . . . . . . 28\n11.1  Security Model . . . . . . . . . . . . . . . . . . . . . . . 28\n11.2  Encryption . . . . . . . . . . . . . . . . . . . . . . . . . 28\n11.3  Message Authentication . . . . . . . . . . . . . . . . . . . 29\n11.4  Procedures for Senders and Receivers . . . . . . . . . . . . 30\n12.   Mbus Configuration . . . . . . . . . . . . . . . . . . . . . 31\n12.1  File based parameter storage . . . . . . . . . . . . . . . . 33\n12.2  Registry based parameter storage . . . . . . . . . . . . . . 34\n13.   Security Considerations  . . . . . . . . . . . . . . . . . . 34\n14.   IANA Considerations  . . . . . . . . . . . . . . . . . . . . 35\n15.   References . . . . . . . . . . . . . . . . . . . . . . . . . 35\nA.    About References . . . . . . . . . . . . . . . . . . . . . . 37\nB.    Limitations and Future Work  . . . . . . . . . . . . . . . . 37\nAuthors' Addresses . . . . . . . . . . . . . . . . . . . . . . . . 38\nFull Copyright Statement . . . . . . . . . . . . . . . . . . . . . 39",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "The implementation of multiparty multimedia conferencing systems is one example where a simple coordination infrastructure can be useful: In a variety of conferencing scenarios, a local communication channel can provide conference-related information exchange between co-located but otherwise independent application entities, for example those taking part in application sessions that belong to the same conference. In loosely coupled conferences such a mechanism allows for coordination of application entities, e.g., to implement synchronization between media streams or to configure entities without user interaction. It can also be used to implement tightly coupled conferences enabling a conference controller to enforce conference wide control within an end system.",
      "ja": "マルチパーティマルチメディア会議システムの実装は、単純な協調インフラストラクチャが有用であることができる一例である：会議シナリオの様々な、ローカル通信チャネルは、例えばそれらのための共同設置それ以外の独立したアプリケーションエンティティ間会議関連の情報交換を提供することができます同じ会議に属しているアプリケーションセッションに参加して。緩く結合された会議では、このような機構は、例えば、メディアストリーム間の同期を実現するために、またはユーザーとの対話なしにエンティティを設定するために、アプリケーション・エンティティの調整を可能にします。また、エンドシステム内の会議広い制御を強制する会議コントローラを有効に密結合された会議を実現するために使用することができます。"
    },
    {
      "indent": 3,
      "text": "Conferencing systems such as IP telephones can also be viewed as components of a distributed system and can thus be integrated into a group of application modules: For example, an IP telephony call that is conducted with a stand-alone IP telephone can be dynamically extended to include media engines for other media types using the coordination function of an appropriate coordination mechanism. Different individual conferencing components can thus be combined to build a coherent multimedia conferencing system for a user.",
      "ja": "このようなIP電話のような会議システムは、分散システムのコンポーネントとみなすことができ、従って、アプリケーションモジュールのグループに統合することができる：例えば、スタンドアロンIP電話を用いて行われるIP電話コールを動的に拡張することができます適切な調整メカニズムの調整機能を使用して、他のメディアタイプのメディアエンジンを含みます。異なる個々の会議コンポーネントは、このようにユーザーのためのコヒーレントマルチメディア会議システムを構築するために組み合わせることができます。"
    },
    {
      "indent": 3,
      "text": "Other possible scenarios include the coordination of application components that are distributed on different hosts in a network, for example, so-called Internet appliances.",
      "ja": "他の可能なシナリオは、例えば、ネットワーク内の別のホストに、いわゆるインターネット・アプライアンスに分散されているアプリケーションコンポーネントの調整を含みます。"
    },
    {
      "indent": 0,
      "text": "1.1 Mbus Overview",
      "section_title": true,
      "ja": "1.1 Mバスの概要"
    },
    {
      "indent": 3,
      "text": "Local coordination of application components requires a number of different interaction models: some messages (such as membership information, floor control notifications, dissemination of conference state changes, etc.) may need to be sent to all local application entities. Messages may also be targeted at a certain application class (e.g., all whiteboards or all audio tools) or agent type (e.g., all user interfaces rather than all media engines). Or there may be any (application- or message-specific) subgrouping defining the intended recipients, e.g., messages related to media synchronization. Finally, there may be messages that are directed at a single entity: for example, specific configuration settings that a conference controller sends to a particular application entity, or query-response exchanges between any local server and its clients.",
      "ja": "すべてのローカルアプリケーションエンティティに送信する必要があるかもしれません（などの会員情報、フロア制御の通知、会議の状態変化の普及、など）いくつかのメッセージ：アプリケーションコンポーネントのローカル調整は異なるインタラクションモデルの数が必要です。メッセージはまた、特定のアプリケーションクラス（例えば、すべてのホワイトボードまたはすべてのオーディオツール）または剤形（例えば、すべてのユーザインタフェースではなく、すべてのメディア・エンジン）を対象とすることができます。または目的の受信者を定義する任意の（用途向けまたはメッセージに特異的な）サブグループが存在してもよい、例えば、メッセージは、メディア同期に関する。会議コントローラは、特定のアプリケーション・エンティティ、または任意のローカルサーバとそのクライアントとの間のクエリ応答の交換機に送信すること、例えば、特定の構成設定：最後に、単一のエンティティに向けられているメッセージが存在してもよいです。"
    },
    {
      "indent": 3,
      "text": "The Mbus protocol as defined here satisfies these different communication needs by defining different message transport mechanisms (defined in Section 6) and by providing a flexible addressing scheme (defined in Section 4).",
      "ja": "ここで定義されるようなのMBusプロトコル（セクション6で定義された）異なるメッセージ転送機構を定義することによって、及び（セクション4で定義された）可撓性アドレス指定方式を提供することにより、これらの異なる通信ニーズを満たします。"
    },
    {
      "indent": 3,
      "text": "Furthermore, Mbus messages exchanged between application entities may have different reliability requirements (which are typically derived from their semantics). Some messages will have a rather transient character conveying ephemeral state information (which is refreshed/updated periodically), such as the volume meter level of an audio receiver entity to be displayed by its user interface agent. Certain Mbus messages (such as queries for parameters or queries to local servers) may require a response from the peer(s), thereby providing an explicit acknowledgment at the semantic level on top of the Mbus. Other messages will modify the application or conference state and hence it is crucial that they do not get lost. The latter type of message has to be delivered reliably to the recipient, whereas messages of the first type do not require reliability mechanisms at the Mbus transport layer. For messages confirmed at the application layer it is up to the discretion of the application whether or not to use a reliable transport underneath.",
      "ja": "また、アプリケーション・エンティティ間で交換のMBusメッセージは、（典型的にはその意味に由来する）異なる信頼性要件を有してもよいです。一部のメッセージは、そのユーザインタフェースエージェントによって表示されるようなオーディオ受信エンティティのボリュームメーターレベルとして（定期的に更新更新される/）短命状態情報を搬送なく過渡特性を有するであろう。 （そのようなパラメータまたはローカルサーバへのクエリのクエリなど）の特定のMBusメッセージは、それによってMバスの上にセマンティックレベルで明示的な確認を提供する、ピア（複数可）からの応答を必要とするかもしれません。他のメッセージは、アプリケーションや会議の状態を変更しますので、彼らが迷子にしないことが重要です。メッセージの後者のタイプは、第1のタイプのメッセージは、Mバス輸送層で信頼性機構を必要としない一方、受信者に確実に配信されなければなりません。アプリケーション層で確認されたメッセージの場合には、下に信頼性の高いトランスポートを使用するかどうかをアプリケーションの裁量に任されています。"
    },
    {
      "indent": 3,
      "text": "In some cases, application entities will want to tailor the degree of reliability to their needs, others will want to rely on the underlying transport to ensure delivery of the messages -- and this may be different for each Mbus message. The Mbus message passing mechanism specified in this document provides a maximum of flexibility by providing reliable transmission achieved through transport-layer acknowledgments (in case of point-to-point communications only) as well as unreliable message passing (for unicast, local multicast, and local broadcast). We address this topic in Section 4.",
      "ja": "これは、それぞれのMbusメッセージの異なる場合があります - いくつかのケースでは、アプリケーションの実体は、他の人がメッセージの配信を保証するために、基礎となる交通機関に頼ることになるでしょう、彼らのニーズに信頼度を調整することになるでしょう。この文書で指定のMBusメッセージパッシング機構は、トランスポート層肯定応答（のみのポイントツーポイント通信の場合）ならびにユニキャストのため信頼できないメッセージパッシング（ローカルマルチキャストを介して達成信頼性の高い伝送を提供することにより、柔軟性の最大値を提供し、ローカル放送）。私たちは、第4節では、このトピックに取り組みます。"
    },
    {
      "indent": 3,
      "text": "Finally, accidental or malicious disturbance of Mbus communications through messages originated by applications from other users needs to be prevented. Accidental reception of Mbus messages from other users may occur if either two users share the same host for using Mbus applications or if they are using Mbus applications that are spread across the same network link: in either case, the used Mbus multicast address and the port number may be identical leading to reception of the other party's Mbus messages in addition to the user's own ones. Malicious disturbance may happen because of applications multicasting (e.g., at a global scope) or unicasting Mbus messages. To eliminate the possibility of processing unwanted Mbus messages, the Mbus protocol contains message digests for authentication. Furthermore, the Mbus allows for encryption to ensure privacy and thus enable using the Mbus for local key distribution and other functions potentially sensitive to eavesdropping. This document defines the framework for configuring Mbus applications with regard to security parameters in Section 12.",
      "ja": "最後に、他のユーザーからのアプリケーションによって発信メッセージを介してMバス通信の偶発的または悪質な妨害を防止する必要があります。いずれかの2人のユーザーがのMBusアプリケーションを使用して、またはそれらが同一のネットワークリンクを介して広がっているのMBusアプリケーションを使用している場合に同じホストを共有する場合、他のユーザーからのMBusメッセージの偶発的な受信が発生することがあります。いずれの場合も、使用のMBusマルチキャストアドレスおよびポート番号は、ユーザー自身のものに加えて、相手のMバスメッセージの受信につながる同一であってもよいです。悪質な乱れがあるためアプリケーションマルチキャスト（例えば、グローバルスコープで）またはMバスメッセージをユニキャストで起こり得ます。不要のMBusメッセージを処理する可能性を排除するために、Mバスプロトコルは、認証のためのメッセージダイジェストを含んでいます。また、Mバスは、プライバシーを保証し、従って盗聴に対して潜在的に感受性ローカル鍵配布および他の機能のためにMバスを使用可能にするために暗号化を可能にします。この文書は、セクション12のセキュリティパラメータに関して、Mバス・アプリケーションを構成するためのフレームワークを定義します。"
    },
    {
      "indent": 0,
      "text": "1.2 Purpose of this Document",
      "section_title": true,
      "ja": "このドキュメントの1.2目的"
    },
    {
      "indent": 3,
      "text": "Three components constitute the message bus: the low level message passing mechanisms, a command syntax and naming hierarchy, and the addressing scheme.",
      "ja": "機構を通過する低レベルのメッセージ、コマンド構文と命名階層、およびアドレス指定スキーム：3つのコンポーネントがメッセージ・バスを構成します。"
    },
    {
      "indent": 3,
      "text": "The purpose of this document is to define the protocol mechanisms of the lower level Mbus message passing mechanism which is common to all Mbus implementations. This includes the specification of",
      "ja": "この文書の目的は、すべてのMBus実装に共通の機構を通過する低レベルのMBusメッセージのプロトコルメカニズムを定義することです。これは、の仕様が含まれて"
    },
    {
      "indent": 3,
      "text": "o the generic Mbus message format;",
      "ja": "一般的なMバスメッセージフォーマットO;"
    },
    {
      "indent": 3,
      "text": "o the addressing concept for application entities (note that concrete addressing schemes are to be defined by application-specific profiles);",
      "ja": "アプリケーションエンティティのアドレッシング・コンセプトO（具体的なアドレス指定方式は、アプリケーション固有のプロファイルによって定義されるべきであることに注意してください）。"
    },
    {
      "indent": 3,
      "text": "o the transport mechanisms to be employed for conveying messages between (co-located) application entities;",
      "ja": "（共同設置）アプリケーションエンティティ間のメッセージを搬送するために使用されるトランスポート機構O。"
    },
    {
      "indent": 3,
      "text": "o the security concept to prevent misuse of the Message Bus (such as taking control of another user's conferencing environment);",
      "ja": "（たとえば、他のユーザーの会議環境の制御を取ると）メッセージバスの誤用を防ぐためのセキュリティコンセプトO;"
    },
    {
      "indent": 3,
      "text": "o the details of the Mbus message syntax; and",
      "ja": "Mバスのメッセージ構文の詳細O;そして"
    },
    {
      "indent": 3,
      "text": "o a set of mandatory application independent commands that are used for bootstrapping Mbus sessions.",
      "ja": "Mバスのセッションをブートストラップするために使用されている必須のアプリケーションの独立したコマンドのセットO。"
    },
    {
      "indent": 0,
      "text": "1.3 Areas of Application",
      "section_title": true,
      "ja": "アプリケーションの1.3エリア"
    },
    {
      "indent": 3,
      "text": "The Mbus protocol can be deployed in many different application areas, including but not limited to:",
      "ja": "Mバスプロトコルは、以下を含む、多くの異なるアプリケーション分野に展開がこれらに限定されないことができます。"
    },
    {
      "indent": 3,
      "text": "Local conference control: In the Mbone community a model has arisen whereby a set of loosely coupled tools are used to participate in a conference. A typical scenario is that audio, video, and shared workspace functionality is provided by three separate tools (although some combined tools exist). This maps well onto the underlying RTP [8] (as well as other) media streams, which are also transmitted separately. Given such an architecture, it is useful to be able to perform some coordination of the separate media tools. For example, it may be desirable to communicate playout-point information between audio and video tools, in order to implement lip-synchronization, to arbitrate the use of shared resources (such as input devices), etc.",
      "ja": "ローカル会議制御：疎結合のツールのセットが会議に参加するために使用されていることにより、MBONEコミュニティのモデルが生じています。典型的なシナリオは、オーディオ、ビデオであり、（いくつかの合成ツールが存在するが）共有ワークスペース機能は、3つの別々のツールによって提供されます。これはまた、別々に送信される下地RTP [8]（ならびに他の）メディアストリーム、上ウェルマップ。このようなアーキテクチャを考えると、別のメディアツールのいくつかの調整を行うことができるように便利です。例えば、等、（例えば入力デバイスなど）の共有リソースの使用を調停するために、リップ同期を実現するために、オーディオとビデオツール間の再生ポイント情報を通信することが望ましいかもしれません"
    },
    {
      "indent": 6,
      "text": "A refinement of this architecture relies on the presence of a number of media engines which perform protocol functions as well as capturing and playout of media. In addition, one (or more) (separate) user interface agents exist that interact with and control their media engine(s). Such an approach allows flexibility in the user-interface design and implementation, but obviously requires some means by which the various involved agents may communicate with one another. This is particularly desirable to enable a coherent response to a user's conference-related actions (such as joining or leaving a conference).",
      "ja": "このアーキテクチャの改良は、プロトコル機能を実行するだけでなく、メディアのキャプチャと再生メディアエンジンの数の存在に依存しています。加えて、1つ（またはそれ以上）（別）のユーザインタフェースエージェントは、それがと相互作用し、そのメディアエンジン（複数可）を制御存在します。このようなアプローチは、ユーザインタフェースの設計と実装における柔軟性を可能にするが、明らかに種々の関与剤が互いに通信することができることにより、いくつかの手段を必要とします。これは、（そのような会議に参加または離脱など）ユーザの会議関連のアクションにコヒーレントな応答を可能にすることが特に望ましいです。"
    },
    {
      "indent": 6,
      "text": "Although current practice in the Mbone community is to work with a loosely coupled conference control model, situations arise where this is not appropriate and a more tightly coupled wide-area conference control protocol must be employed. In such cases, it is highly desirable to be able to re-use the existing tools (media engines) available for loosely coupled conferences and integrate them with a system component implementing the tight conference control model. One appropriate means to achieve this integration is a communication channel that allows a dedicated conference control entity to \"remotely\" control the media engines in addition to or instead of their respective user interfaces.",
      "ja": "MBONEコミュニティの現在の練習は疎結合会議制御モデルで動作するようですが、これは適切ではなく、より緊密に結合された広域会議制御プロトコルを採用しなければならない場合、状況が発生します。このような場合には、疎結合会議のために利用可能な既存のツール（メディアエンジン）を再使用してタイトな会議制御モデルを実装するシステムコンポーネントとそれらを統合することができることが非常に望ましいです。この統合を達成するための一つの適切な手段専用の会議制御エンティティは、「リモート」に加えて、またはその代わりに、それぞれのユーザインターフェースのメディアエンジンを制御することを可能にする通信チャネルです。"
    },
    {
      "indent": 3,
      "text": "Control of device groups in a network: A group of devices that are connected to a local network, e.g., home appliances in a home network, require a local coordination mechanism. Minimizing manual configuration and the the possibility to deploy group communication will be useful in this application area as well.",
      "ja": "ネットワーク内のデバイスグループの管理：ローカルネットワークに接続されたデバイスのグループは、例えば、ホームネットワーク内のホームアプライアンスは、ローカル調整メカニズムを必要とします。グループ通信を展開するために、手動設定や可能性を最小限にするだけでなく、この応用分野に有用であろう。"
    },
    {
      "indent": 0,
      "text": "1.4 Terminology for requirement specifications",
      "section_title": true,
      "ja": "要求仕様に対して1.4用語"
    },
    {
      "indent": 3,
      "text": "In this document, the key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" are to be interpreted as described in RFC 2119 [1] and indicate requirement levels for compliant Mbus implementations.",
      "ja": "この文書では、キーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、 \"NOT SHALL\"、 \"推奨\"、 \"すべきではない\" \"べきである\" \"ないものと\"、 \"MAY\"、および \"オプション\" RFC 2119に記載されるように解釈されるべきである[1]と対応のMBus実装に対する要求レベルを示します。"
    },
    {
      "indent": 0,
      "text": "2. Common Formal Syntax Rules",
      "section_title": true,
      "ja": "2.共通の正式な構文規則"
    },
    {
      "indent": 3,
      "text": "This section contains definitions of common ABNF [13] syntax elements that are later referenced by other definitions in this document:",
      "ja": "このセクションでは、このドキュメントの他の定義によって参照される共通のABNF [13]シンタックス要素の定義を含みます。"
    },
    {
      "indent": 6,
      "text": "base64 = base64_terminal / ( 1*(4base64_CHAR) [base64_terminal] )",
      "ja": "BASE64 = base64_terminal /（1 *（4base64_CHAR）base64_terminal]）"
    },
    {
      "indent": 6,
      "text": "base64_char = UPALPHA / LOALPHA / DIGIT / \"+\" / \"/\" ;; Case-sensitive",
      "ja": "base64_char = UPALPHA / LOALPHA / DIGIT / \"+\" / \"/\" ;;大文字と小文字を区別"
    },
    {
      "indent": 6,
      "text": "base64_terminal = (2base64_char \"==\") / (3base64_char \"=\")",
      "ja": "base64_terminal =（2base64_char \"==\"）/（3base64_char \"=\"）"
    },
    {
      "indent": 6,
      "text": "UPALPHA = %x41-5A ;; Uppercase: A-Z",
      "ja": "UPALPHA =％x41-5A ;;大文字：A-Z"
    },
    {
      "indent": 6,
      "text": "LOALPHA = %x61-7A ;; Lowercase: a-z",
      "ja": "LOALPHA =％x61-7A ;;小文字：-Z"
    },
    {
      "indent": 6,
      "text": "ALPHA = %x41-5A / %x61-7A ; A-Z / a-z",
      "ja": "ALPHA =％x41-5A /％x61-7A。 -Z / Z-"
    },
    {
      "indent": 6,
      "text": "CHAR = %x01-7E ; any 7-bit US-ASCII character, excluding NUL and delete",
      "ja": "CHAR =％x01-7E。 NULを除くすべての7ビットUS-ASCII文字、および削除"
    },
    {
      "indent": 6,
      "text": "OCTET = %x00-FF ; 8 bits of data",
      "ja": "OCTET =％X00-FF。 8ビットのデータ"
    },
    {
      "indent": 6,
      "text": "CR = %x0D ; carriage return",
      "ja": "CR =％x0D。キャリッジリターン"
    },
    {
      "indent": 6,
      "text": "CRLF = CR LF ; Internet standard newline",
      "ja": "CRLF = CR LF。インターネット標準の改行"
    },
    {
      "indent": 6,
      "text": "DIGIT = %x30-39 ; 0-9",
      "ja": "DIGIT =％x30-39。 0-9"
    },
    {
      "indent": 6,
      "text": "DQUOTE = %x22 ; \" (Double Quote)",
      "ja": "DQUOTE =％X22。 \"（二重引用符）"
    },
    {
      "indent": 6,
      "text": "HTAB = %x09 ; horizontal tab",
      "ja": "HTAB =％X09。水平タブ"
    },
    {
      "indent": 6,
      "text": "LF = %x0A ; linefeed",
      "ja": "LF =％X0A。改行"
    },
    {
      "indent": 6,
      "text": "LWSP = *(WSP / CRLF WSP) ; linear white space (past newline)",
      "ja": "LWSP = *（WSP / CRLF WSP）。リニアホワイトスペース（過去改行）"
    },
    {
      "indent": 6,
      "text": "SP = %x20 ; space",
      "ja": "SP =％のX20。スペース"
    },
    {
      "indent": 6,
      "text": "WSP = SP / HTAB ; white space",
      "ja": "WSP = SP / HTAB;ホワイトスペース"
    },
    {
      "indent": 3,
      "text": "Taken from RFC 2234 [13] and RFC 2554 [14].",
      "ja": "RFC 2234 [13]およびRFC 2554 [14]から取ら。"
    },
    {
      "indent": 0,
      "text": "3. Message Format",
      "section_title": true,
      "ja": "3.メッセージフォーマット"
    },
    {
      "indent": 3,
      "text": "An Mbus message comprises a header and a body. The header is used to indicate how and where a message should be delivered and the body provides information and commands to the destination entity. The following pieces of information are included in the header:",
      "ja": "Mバスメッセージは、ヘッダと本体を含みます。ヘッダは、メッセージが配信されるべきであり、身体が宛先エンティティへの情報およびコマンドを提供する方法と場所を示すために使用されます。以下の情報は、ヘッダに含まれています。"
    },
    {
      "indent": 6,
      "text": "A fixed ProtocolID field identifies the version of the message bus protocol used. The protocol defined in this document is \"mbus/1.0\" (case-sensitive).",
      "ja": "固定ProtocolIDフィールドが使用されるメッセージ・バス・プロトコルのバージョンを識別する。この文書で定義されたプロトコルである「MBUS / 1.0」（大文字と小文字を区別）。"
    },
    {
      "indent": 6,
      "text": "A sequence number (SeqNum) is contained in each message. The first message sent by a source SHOULD set SeqNum to zero, and it MUST increment by one for each message sent by that source. A single sequence number is used for all messages from a source, irrespective of the intended recipients and the reliability mode selected. The value range of a sequence number is (0,4294967295). An implementation MUST re-set its sequence number to 0 after reaching 4294967295. Implementations MUST take into account that the SeqNum of other entities may wrap-around.",
      "ja": "シーケンス番号（SEQNUM）は、各メッセージに含まれています。ソースによって送られた最初のメッセージはゼロにSEQNUMを設定しなければならず、そのソースによって送られた各メッセージに対して1つずつ増加しなければなりません。単一のシーケンス番号が、受信者にかかわらず、ソースからのすべてのメッセージに使用され、信頼性モードが選択されました。シーケンス番号の値の範囲は（0,4294967295）です。実装は、他のエンティティのSEQNUMは、ラップアラウンドも考慮しなければならない4294967295の実装に到達した後に0にそのシーケンス番号を再設定しなければなりません。"
    },
    {
      "indent": 6,
      "text": "SeqNums are decimal numbers in ASCII representation.",
      "ja": "SeqNumsは、ASCII表現で小数点以下の数字です。"
    },
    {
      "indent": 6,
      "text": "The TimeStamp field is also contained in each message and SHOULD contain a decimal number representing the time of the message construction in milliseconds since 00:00:00, UTC, January 1, 1970.",
      "ja": "タイムスタンプフィールドは、各メッセージに含まれていると00:00:00からミリ秒のメッセージ構造の時間を表す十進数、UTC 1970年1月1日を含むべきです。"
    },
    {
      "indent": 6,
      "text": "A MessageType field indicates the kind of message being sent. The value \"R\" indicates that the message is to be transmitted reliably and MUST be acknowledged by the recipient, \"U\" indicates an unreliable message which MUST NOT be acknowledged.",
      "ja": "MessageTypeのフィールドは、送信されたメッセージの種類を示します。値「R」がメッセージを確実に送信されると、受信者によって承認されなければならないことを示し、「U」は認めてはいけません、信頼できないメッセージを示します。"
    },
    {
      "indent": 6,
      "text": "The SrcAddr field identifies the sender of a message. This MUST be a complete address, with all address elements specified. The addressing scheme is described in Section 4.",
      "ja": "SRCADDRフィールドは、メッセージの送信者を特定します。これは、指定されたすべてのアドレス要素と、完全なアドレスでなければなりません。アドレッシングスキームは、セクション4に記載されています。"
    },
    {
      "indent": 6,
      "text": "The DestAddr field identifies the intended recipient(s) of the message. This field MAY be wildcarded by omitting address elements and hence address any number (including zero) of application entities. The addressing scheme is described in Section 4.",
      "ja": "DESTADDRフィールドは、メッセージの意図された受信者（複数可）を識別する。このフィールドは、アドレス要素を省略してワイルドカード、したがってアプリケーションエンティティの（ゼロを含む）の任意の数のアドレスであってもよいです。アドレッシングスキームは、セクション4に記載されています。"
    },
    {
      "indent": 6,
      "text": "The AckList field comprises a list of SeqNums for which this message is an acknowledgment. See Section 7 for details.",
      "ja": "ブラックリストフィールドは、このメッセージが確認されたSeqNumsのリストを含みます。詳細については、セクション7を参照してください。"
    },
    {
      "indent": 3,
      "text": "The header is followed by the message body which contains zero or more commands to be delivered to the destination entity. The syntax for a complete message is given in Section 5.",
      "ja": "ヘッダは、宛先エンティティに配信されるゼロ個以上のコマンドを含むメッセージ本体が続きます。完全なメッセージの構文は、第5節で与えられています。"
    },
    {
      "indent": 3,
      "text": "If multiple commands are contained within the same Mbus message payload, they MUST to be delivered to the Mbus application in the same sequence in which they appear in the message payload.",
      "ja": "複数のコマンドが同一のMBusメッセージペイロード内に含まれている場合、それらは、メッセージ・ペイロードに表示される同じ順序でのMBusアプリケーションに配信される必要があります。"
    },
    {
      "indent": 0,
      "text": "4. Addressing",
      "section_title": true,
      "ja": "4.アドレッシング"
    },
    {
      "indent": 3,
      "text": "Each entity in the message has a unique Mbus address that is used to identify the entity. Mbus addresses are sequences of address elements that are tag/value pairs. The tag and the value are separated by a colon and tag/value pairs are separated by whitespace, like this:",
      "ja": "メッセージ内の各エンティティは、エンティティを識別するために使用される一意のMBusアドレスを有しています。 Mバスアドレスは、タグ/値のペアですアドレス要素の配列です。タグ値は、このように、空白で区切られている結腸およびタグ/値のペアによって分離されています。"
    },
    {
      "indent": 6,
      "text": "(tag:value tag:value ...)",
      "ja": "（タグ：値タグ：値...）"
    },
    {
      "indent": 3,
      "text": "The formal ABNF syntax definition for Mbus addresses and their elements is as follows:",
      "ja": "次のようにMバスアドレスとその要素のための正式なABNF構文定義は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "mbus_address = \"(\" *WSP *1address_list *WSP \")\" address_list = address_element / address_element 1*WSP address_list",
      "ja": "mbus_address = \"（\" * WSP * 1address_list * WSP \"）\" ADDRESS_LIST = address_element / address_element 1 * WSP ADDRESS_LIST"
    },
    {
      "indent": 6,
      "text": "address_element = address_tag \":\" address_value",
      "ja": "address_element = address_tag \"：\" address_value"
    },
    {
      "indent": 6,
      "text": "address_tag = 1*32(ALPHA)",
      "ja": "address_tag = 1 * 32（ALPHA）"
    },
    {
      "indent": 6,
      "text": "address_value = 1*64(%x21-27 / %x2A-7E) ; any 7-bit US-ASCII character ; excluding white space, delete, ; control characters, \"(\" and \")\"",
      "ja": "address_value = 1 * 64（％x21-27 /％X2A-7E）。すべての7ビットUS-ASCII文字。 、ホワイトスペースを除く、削除します。制御文字、「（」と「）」"
    },
    {
      "indent": 3,
      "text": "Note that this and other ABNF definitions in this document use the non-terminal symbols defined in Section 2.",
      "ja": "本書でこれと他のABNF定義は、セクション2で定義された非終端記号を使用することに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "An address_tag MUST be unique within an Mbus address, i.e., it MUST only occur once.",
      "ja": "address_tag、すなわち、それは一度だけ発生しなければならない、Mバスアドレス内で一意でなければなりません。"
    },
    {
      "indent": 3,
      "text": "Each entity has a fixed sequence of address elements constituting its address and MUST only process messages sent to addresses that either match all elements or consist of a subset of its own address elements. The order of address elements in an address sequence is not relevant. Two address elements match if both their tags and their values are equivalent. Equivalence for address element and address value strings means that each octet in the one string has the same value as the corresponding octet in the second string. For example, an entity with an address of:",
      "ja": "各エンティティは、そのアドレスを構成するアドレス素子の固定された配列を有し、唯一のプロセスメッセージは、すべての要素に一致するか、それ自身のアドレス要素のサブセットから成るいずれかのアドレスに送信しなければなりません。アドレスシーケンス内のアドレス要素の順序は関係ありません。自分のタグとその値の両方が等しい場合は、2つのアドレスの要素が一致します。アドレス要素とアドレス値文字列の等価性は、1つの文字列内の各オクテットは2番目の文字列に対応するオクテットと同じ値を有することを意味します。例えば、のアドレスを持つエンティティ："
    },
    {
      "indent": 3,
      "text": "(conf:test media:audio module:engine app:rat id:4711-1@192.168.1.1)",
      "ja": "（CONF：試験媒体：オーディオモジュール：エンジンアプリ：ラットID：4711-1@192.168.1.1）"
    },
    {
      "indent": 3,
      "text": "will process messages sent to",
      "ja": "に送信されたメッセージを処理します"
    },
    {
      "indent": 3,
      "text": "(media:audio module:engine) and",
      "ja": "（メディア：音声モジュール：エンジン）と"
    },
    {
      "indent": 3,
      "text": "(module:engine)",
      "ja": "（モジュール：エンジン）"
    },
    {
      "indent": 3,
      "text": "but must ignore messages sent to",
      "ja": "しかしに送信されたメッセージを無視しなければなりません"
    },
    {
      "indent": 3,
      "text": "(conf:test media:audio module:engine app:rat id:123-4@192.168.1.1 foo:bar)",
      "ja": "（CONF：試験媒体：オーディオモジュール：エンジンアプリ：ラットID：123-4@192.168.1.1 FOO：バール）"
    },
    {
      "indent": 3,
      "text": "and",
      "ja": "そして"
    },
    {
      "indent": 3,
      "text": "(foo:bar)",
      "ja": "（FOO：バー）"
    },
    {
      "indent": 3,
      "text": "A message that should be processed by all entities requires an empty set of address elements.",
      "ja": "すべてのエンティティによって処理されるべきメッセージは、アドレス要素の空のセットが必要です。"
    },
    {
      "indent": 0,
      "text": "4.1 Mandatory Address Elements",
      "section_title": true,
      "ja": "4.1必須住所要素"
    },
    {
      "indent": 3,
      "text": "Each Mbus entity MUST provide one mandatory address element that allows it to identify the entity. The element tag is \"id\" and the value MUST be be composed of the following components:",
      "ja": "各MBusエンティティは、エンティティを識別することを可能にする1つの必須のアドレス要素を提供しなければなりません。要素タグは「ID」であり、値は、次のコンポーネントから構成されなければなりません。"
    },
    {
      "indent": 3,
      "text": "o The IP address of the interface that is used for sending messages to the Mbus. For IPv4 this is the address in dotted decimal notation. For IPv6 the interface-ID-part of the node's link-local address in textual representation as specified in RFC 2373 [3] MUST be used.",
      "ja": "Mバスにメッセージを送信するために使用されるインターフェイスのIPアドレス、O。 IPv4の場合、これはドット十進表記のアドレスです。 IPv6のインターフェイスID部分テキスト表現内のノードのリンクローカルアドレスのRFC 2373で指定されるように[3]を使用しなければなりません。"
    },
    {
      "indent": 6,
      "text": "In this specification, this part is called the \"host-ID\".",
      "ja": "本明細書では、この部分は、「ホストID」と呼ばれています。"
    },
    {
      "indent": 3,
      "text": "o An identifier (\"entity-ID\") that is unique within the scope of a single host-ID. The entity comprises two parts. For systems where the concept of a process ID is applicable it is RECOMMENDED that this identifier be composed using a process-ID and a per-process disambiguator for different Mbus entities of a process. If a process ID is not available, this part of the entity-ID may be randomly chosen (it is recommended that at least a 32 bit random number is chosen). Both numbers are represented in decimal textual form and MUST be separated by a '-' (ASCII x2d) character.",
      "ja": "単一のホストIDの範囲内で一意の識別子（「エンティティID」）O。エンティティは二つの部分を含みます。プロセスIDの概念が適用可能であるシステムの場合、この識別子は、プロセスIDとプロセスの別のMBusエンティティのプロセスごとのディスアンビギュエータを用いて構成されることが推奨されます。プロセスIDが利用できない場合、エンティティIDのこの部分は、ランダムに選択することができる（少なくとも32ビットの乱数が選択されることをお勧めします）。どちらの数字は小数点テキスト形式で表現されており、によって分離されなければならない「 - 」（ASCII x2d）文字。"
    },
    {
      "indent": 3,
      "text": "Note that the entity-ID cannot be the port number of the endpoint used for sending messages to the Mbus because implementations MAY use the common Mbus port number for sending to and receiving from the multicast group (as specified in Section 6).",
      "ja": "エンティティIDは、実装が（セクション6で指定されるように）に送信し、マルチキャストグループから受信するための共通のMBusポート番号を使用する可能性があるため、Mバスにメッセージを送信するために使用されるエンドポイントのポート番号ではないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "The complete syntax definition for the entity identifier is as follows:",
      "ja": "次のようにエンティティ識別子の構文定義は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "id-element = \"id:\" id-value",
      "ja": "ID-要素= \"ID：\" ID値"
    },
    {
      "indent": 6,
      "text": "id-value = entity-id \"@\" host-id",
      "ja": "ホスト-ID \"@\" のid値=エンティティID"
    },
    {
      "indent": 6,
      "text": "entity-id = 1*10DIGIT \"-\" 1*5DIGIT",
      "ja": "エンティティID = 1 * DIGIT 10 \" - \" 1 * DIGIT 5"
    },
    {
      "indent": 6,
      "text": "host-id = (IPv4address / IPv6address)",
      "ja": "ホストID =（IPv4Addressを/ IPv6address）"
    },
    {
      "indent": 3,
      "text": "Please refer to [3] for the productions of IPv4address and IPv6address.",
      "ja": "IPv4AddressをとIPv6addressの制作のために[3]を参照してください。"
    },
    {
      "indent": 3,
      "text": "An example for an id element:",
      "ja": "id要素の例："
    },
    {
      "indent": 6,
      "text": "id:4711-99@192.168.1.1",
      "ja": "ID：4711-99@192.168.1.1"
    },
    {
      "indent": 0,
      "text": "5. Message Syntax",
      "section_title": true,
      "ja": "5.メッセージの構文"
    },
    {
      "indent": 0,
      "text": "5.1 Message Encoding",
      "section_title": true,
      "ja": "5.1メッセージエンコーディング"
    },
    {
      "indent": 3,
      "text": "All messages MUST use the UTF-8 character encoding. Note that US ASCII is a subset of UTF-8 and requires no additional encoding, and that a message encoded with UTF-8 will not contain zero bytes.",
      "ja": "すべてのメッセージは、UTF-8文字エンコーディングを使用しなければなりません。米国ASCIIはUTF-8のサブセットであり、追加の符号化を必要とせず、UTF-8でエンコードされたメッセージは、ゼロバイトが含まれないことことに注意してください。"
    },
    {
      "indent": 3,
      "text": "Each Message MAY be encrypted using a secret key algorithm as defined in Section 11.",
      "ja": "セクション11で定義された各メッセージには、秘密鍵アルゴリズムを用いて暗号化することができます。"
    },
    {
      "indent": 0,
      "text": "5.2 Message Header",
      "section_title": true,
      "ja": "5.2メッセージヘッダ"
    },
    {
      "indent": 3,
      "text": "The fields in the header are separated by white space characters, and followed by CRLF. The format of the header is as follows:",
      "ja": "ヘッダ内のフィールドは、空白文字で区切られた、およびCRLFが続きます。次のようにヘッダのフォーマットは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "msg_header = \"mbus/1.0\" 1*WSP SeqNum 1*WSP TimeStamp 1*WSP MessageType 1*WSP SrcAddr 1*WSP DestAddr 1*WSP AckList",
      "ja": "msg_header = \"のMBus / 1.0\" 1 * 1 * SEQNUM WSP WSP WSPタイムスタンプのMessageType 1 * 1 * 1 * SRCADDR WSP WSP WSP DESTADDR 1 * AckList"
    },
    {
      "indent": 3,
      "text": "The header fields are explained in Message Format (Section 3). Here are the ABNF syntax definitions for the header fields:",
      "ja": "ヘッダフィールドは、メッセージ形式（セクション3）で説明されています。ここでは、ヘッダフィールドのABNF構文定義は以下のとおりです。"
    },
    {
      "indent": 6,
      "text": "SeqNum = 1*10DIGIT ; numeric range 0 - 2^32-1",
      "ja": "SEQNUM = 1 * 10DIGIT。数値範囲0から2 ^ 32-1"
    },
    {
      "indent": 6,
      "text": "TimeStamp = 1*13DIGIT",
      "ja": "タイムスタンプ= 1 * 13DIGIT"
    },
    {
      "indent": 6,
      "text": "MessageType = \"R\" / \"U\"",
      "ja": "MessageType = \"R\" / \"U\""
    },
    {
      "indent": 6,
      "text": "ScrAddr = mbus_address",
      "ja": "ScrAddr = mbus_address"
    },
    {
      "indent": 6,
      "text": "DestAddr = mbus_address",
      "ja": "DESTADDR = mbus_address"
    },
    {
      "indent": 6,
      "text": "AckList = \"(\" *WSP *1(1*DIGIT *(1*WSP 1*10DIGIT)) *WSP \")\"",
      "ja": "AckList = \"（\" WSP * 1（1 * DIGIT×（1 * 1 * WSP 10DIGIT））* WSP \"）\""
    },
    {
      "indent": 6,
      "text": "See Section 4 for a definition of \"mbus_address\".",
      "ja": "「mbus_address」の定義については、セクション4を参照してください。"
    },
    {
      "indent": 3,
      "text": "The syntax definition of a complete message is as follows:",
      "ja": "次のように完全なメッセージの構文定義は以下のとおりです。"
    },
    {
      "indent": 6,
      "text": "mbus_message = msg_header *1(CRLF msg_payload)",
      "ja": "mbus_message = msg_header * 1（CRLFのmsg_payload）"
    },
    {
      "indent": 6,
      "text": "msg_payload = mbus_command *(CRLF mbus_command)",
      "ja": "msg_payload = mbus_command *（CRLFのmbus_command）"
    },
    {
      "indent": 3,
      "text": "The definition of production rules for an Mbus command is given in Section 5.3.",
      "ja": "Mバスコマンドのプロダクションルールの定義は、5.3節で与えられています。"
    },
    {
      "indent": 0,
      "text": "5.3 Command Syntax",
      "section_title": true,
      "ja": "5.3コマンドの構文"
    },
    {
      "indent": 3,
      "text": "The header is followed by zero, one, or more, commands to be delivered to the Mbus entities indicated by the DestAddr field. Each command consists of a command name that is followed by a list of zero, or more parameters and is terminated by a newline.",
      "ja": "ヘッダは、ゼロ、1つ、またはそれ以上続いて、DESTADDRフィールドによって示さのMBusエンティティに配信されるように命令します。各コマンドは、ゼロ、またはそれ以上のパラメータのリストが続いていると改行で終了されるコマンド名で構成されています。"
    },
    {
      "indent": 6,
      "text": "command ( parameter parameter ... )",
      "ja": "コマンド（パラメータパラメータ...）"
    },
    {
      "indent": 3,
      "text": "Syntactically, the command name MUST be a `symbol' as defined in the following table. The parameters MAY be any data type drawn from the following table:",
      "ja": "次の表で定義された構文的には、コマンド名が `シンボル」でなければなりません。パラメータは、次の表から引き出される任意のデータ型であってもよいです。"
    },
    {
      "indent": 6,
      "text": "val = Integer / Float / String / List / Symbol / Data",
      "ja": "ヴァル=整数/浮動小数点/文字列/一覧/記号/データ"
    },
    {
      "indent": 6,
      "text": "Integer = *1\"-\" 1*DIGIT",
      "ja": "整数= * 1 \" - \" 1 * DIGIT"
    },
    {
      "indent": 6,
      "text": "Float = *1\"-\" 1*DIGIT \".\" 1*DIGIT",
      "ja": "フロート= * 1 \" - \" 1 * DIGIT \"\" 1 * DIGIT"
    },
    {
      "indent": 6,
      "text": "String = DQUOTE *CHAR DQUOTE ; see below for escape characters",
      "ja": "文字列= DQUOTE * CHAR DQUOTE。エスケープ文字については、以下をご覧ください"
    },
    {
      "indent": 6,
      "text": "List = \"(\" *WSP *1(val *(1*WSP val)) *WSP \")\"",
      "ja": "一覧= \"（\" WSP * * 1（ヴァル*（1 * WSPのval））* WSP \"）\""
    },
    {
      "indent": 6,
      "text": "Symbol = ALPHA *(ALPHA / DIGIT / \"_\" / \"-\" / \".\")",
      "ja": "記号= ALPHA *（ALPHA / DIGIT / \"_\" / \" - \" / \"\"）"
    },
    {
      "indent": 6,
      "text": "Data = \"<\" *base64 \">\"",
      "ja": "データ= \"<\" * BASE64 \">\""
    },
    {
      "indent": 3,
      "text": "Boolean values are encoded as an integer, with the value of zero representing false, and non-zero representing true.",
      "ja": "ブール値は真を表す偽表すゼロの値、および非ゼロで、整数として符号化されます。"
    },
    {
      "indent": 3,
      "text": "String parameters in the payload MUST be enclosed in the double quote (\") character. Within strings, the escape character is the backslash (\\), and the following escape sequences are defined:",
      "ja": "ペイロード内の文字列パラメータは、二重引用符（ \"）文字で囲む必要があり、文字列の中では、エスケープ文字は、バックスラッシュ（\\）で、次のエスケープシーケンスが定義されています。："
    },
    {
      "indent": 6,
      "text": "+----------------+-----------+\n|Escape Sequence |  Meaning  |\n+----------------+-----------+\n|      \\\\        |    \\      |\n|      \\\"        |     \"     |\n|      \\n        | newline   |\n+----------------+-----------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "List parameters do not have to be homogeneous lists, i.e., they can contain parameters of different types.",
      "ja": "リストのパラメータは、すなわち、彼らはさまざまな種類のパラメータを含めることができ、均質なリストである必要はありません。"
    },
    {
      "indent": 3,
      "text": "Opaque data is represented as Base64-encoded (see RFC 1521 [7]) character strings surrounded by \"< \" and \"> \"",
      "ja": "Base64でエンコードされたように不透明なデータが、「<」と「>」で囲まれた文字列（[7] RFC 1521参照）が表されています"
    },
    {
      "indent": 3,
      "text": "The ABNF syntax definition for Mbus commands is as follows:",
      "ja": "MバスのためのABNFの構文定義は、コマンドは次のとおりです。"
    },
    {
      "indent": 6,
      "text": "mbus_command = command_name arglist",
      "ja": "mbus_command =コマンド名引数リスト"
    },
    {
      "indent": 6,
      "text": "command_name = Symbol",
      "ja": "コマンド名=記号"
    },
    {
      "indent": 6,
      "text": "arglist = List",
      "ja": "ガイル=一覧"
    },
    {
      "indent": 3,
      "text": "Command names SHOULD be constructed hierarchically to group conceptually related commands under a common hierarchy. The delimiter between names in the hierarchy MUST be \".\" (dot). Application profiles MUST NOT define commands starting with \"mbus.\".",
      "ja": "コマンド名は、一般的な階層の下にグループ概念的に関連するコマンドに階層的に構成されるべきです。階層内の名前の間の区切り文字でなければなりません「」 （ドット）。アプリケーションプロファイルで始まるコマンドを定義してはならない「MBUS。」。"
    },
    {
      "indent": 3,
      "text": "The Mbus addressing scheme defined in Section 4 allows specifying incomplete addresses by omitting certain elements of an address element list, enabling entities to send commands to a group of Mbus entities. Therefore, all command names SHOULD be unambiguous in a way that it is possible to interpret or ignore them without considering the message's address.",
      "ja": "セクション4で定義されたMバスアドレス指定方式は、Mバスエンティティのグループにコマンドを送信するエンティティをイネーブル、アドレス要素リストの特定の要素を省略して、不完全なアドレスを指定することができます。そのため、すべてのコマンド名は、メッセージのアドレスを考慮せずに、それを解釈するか、無視することが可能であることを明確な方法であるべきです。"
    },
    {
      "indent": 3,
      "text": "A set of commands within a certain hierarchy that MUST be understood by every entity is defined in Section 9.",
      "ja": "すべてのエンティティによって理解されなければならない特定の階層内のコマンドのセットは、セクション9で定義されています。"
    },
    {
      "indent": 0,
      "text": "6. Transport",
      "section_title": true,
      "ja": "6.交通"
    },
    {
      "indent": 3,
      "text": "All messages are transmitted as UDP messages, with two possible alternatives:",
      "ja": "すべてのメッセージは、二つの可能な選択肢で、UDPメッセージとして送信されます。"
    },
    {
      "indent": 3,
      "text": "1. Local multicast/broadcast: This transport class MUST be used for all messages that are not sent to a fully qualified target address. It MAY also be used for messages that are sent to a fully qualified target address. It MUST be provided by conforming implementations. See Section 6.1 for details.",
      "ja": "1.ローカルマルチキャスト/ブロードキャスト：このトランスポート・クラスは、完全修飾ターゲットアドレスに送信されていないすべてのメッセージを使用しなければなりません。また、完全修飾されたターゲットアドレスに送信されたメッセージのために使用されるかもしれません。これは、適合実装によって提供されなければなりません。詳細については、6.1節を参照してください。"
    },
    {
      "indent": 3,
      "text": "2. Directed unicast: This transport class MAY be used for messages that are sent to a fully qualified destination address. It is OPTIONAL and does not have to be provided by conforming implementations.",
      "ja": "2.監督ユニキャスト：このトランスポート・クラスは、完全修飾された宛先アドレスに送信されたメッセージのために使用されるかもしれません。これはオプションで、適合実装によって提供されている必要はありません。"
    },
    {
      "indent": 3,
      "text": "A fully qualified target address is an Mbus address of an existing Mbus entity in an Mbus session. An implementation can identify an Mbus address as fully qualified by maintaining a list of known entities within an Mbus session. Each known entity has its own unique, fully qualified Mbus address.",
      "ja": "完全修飾されたターゲットアドレスは、Mバスのセッションで既存のMbus実体のMバスアドレスです。実装は、Mバスのセッション内で知られているエンティティのリストを維持することによって、完全修飾としてMバスアドレスを識別することができます。既知の各エンティティは、独自の、完全修飾されたMバスアドレスを持っています。"
    },
    {
      "indent": 3,
      "text": "Messages are transmitted in UDP datagrams, a maximum message size of 64 KBytes MUST NOT be exceeded. It is RECOMMENDED that applications using a non host-local scope do not exceed a message size of the link MTU.",
      "ja": "メッセージは、64キロバイトの最大メッセージサイズを超えてはならない、UDPデータグラムで送信されます。非ホストローカルスコープを使用するアプリケーションがリンクMTUのメッセージサイズを超えないことをお勧めします。"
    },
    {
      "indent": 3,
      "text": "Note that \"unicast\", \"multicast\" and \"broadcast\" mean IP Unicast, IP Multicast and IP Broadcast respectively. It is possible to send an Mbus message that is addressed to a single entity using IP Multicast.",
      "ja": "なお、平均IPユニキャスト、それぞれIPマルチキャストとIPブロードキャスト「放送」「ユニキャスト」、「マルチキャスト」と。 IPマルチキャストを使用して単一のエンティティにアドレス指定されたMバスメッセージを送信することが可能です。"
    },
    {
      "indent": 3,
      "text": "This specification deals with both Mbus over UDP/IPv4 and Mbus over UDP/IPv6.",
      "ja": "UDP / IPv6を介しUDP / IPv4およびMBusを通じて、Mバスの両方でこの仕様を扱っています。"
    },
    {
      "indent": 0,
      "text": "6.1 Local Multicast/Broadcast",
      "section_title": true,
      "ja": "6.1ローカルマルチキャスト/ブロードキャスト"
    },
    {
      "indent": 3,
      "text": "In general, the Mbus uses multicast with a limited scope for message transport. Two different Mbus multicast scopes are defined, either of which can be configured to be used with an Mbus session:",
      "ja": "一般的に、Mバスは、メッセージトランスポートのための限られた範囲でマルチキャストを使用します。二つの異なるMバスマルチキャストスコープは、MBusセッションに使用されるように構成することができるいずれかのうち、定義されます。"
    },
    {
      "indent": 3,
      "text": "1. host-local",
      "section_title": true,
      "ja": "1.ホスト・ローカル"
    },
    {
      "indent": 3,
      "text": "2. link-local",
      "section_title": true,
      "ja": "2.リンクローカル"
    },
    {
      "indent": 3,
      "text": "Participants of an Mbus session have to know the multicast address in advance -- it cannot be negotiated during the session since it is already needed for initial communication between the Mbus entities during the bootstrapping phase. It also cannot be allocated prior to an Mbus session because there would be no mechanism to announce the allocated address to all potential Mbus entities. Therefore, the multicast address has to be assigned statically. This document defines the use of statically assigned addresses and also provides a specification of how an Mbus session can be configured to use non-standard, unassigned addresses (see Section 12).",
      "ja": "Mバスセッションの参加者は事前にマルチキャストアドレスを知っている必要があります - それは、すでにブートストラップ相中のMbusエンティティ間の最初の通信のために必要とされているので、それは、セッション中に交渉することはできません。すべての潜在的なのMbus実体に割り当てられたアドレスをアナウンスするメカニズムはないだろうので、それはまた、従来のMbusセッションに割り当てることができません。そのため、マルチキャストアドレスを静的に割り当てる必要があります。この文書は、静的に割り当てられたアドレスの使用を規定し、またのMBusセッション（セクション12を参照）は、非標準の、割り当てられていないアドレスを使用するように構成することができる方法の仕様を提供します。"
    },
    {
      "indent": 3,
      "text": "The following sections specify the use of multicast addresses for IPv4 and IPv6.",
      "ja": "次のセクションでは、IPv4およびIPv6のマルチキャストアドレスを使用することを指定します。"
    },
    {
      "indent": 0,
      "text": "6.1.1 Mbus multicast groups for IPv4",
      "section_title": true,
      "ja": "IPv4の6.1.1のMbusマルチキャストグループ"
    },
    {
      "indent": 3,
      "text": "For IPv4, a statically assigned, scope-relative multicast address as defined by RFC 2365 [11] is used. The offset for the scope relative address for Mbus is 8 (MBUS, see http://www.iana.org/assignments/multicast-addresses [19]).",
      "ja": "IPv4の、RFC 2365によって定義されるように静的に割り当てられ、スコープ相対マルチキャストアドレスのための[11]を用います。 Mバス用スコープ相対アドレスのオフセット8（MBUS、http://www.iana.org/assignments/multicast-addresses参照[19]）。"
    },
    {
      "indent": 3,
      "text": "Different scopes are defined by RFC 2365 [11]. The IPv4 Local Scope (239.255.0.0/16) is the minimal enclosing scope for administratively scoped multicast (as defined by RFC 2365 [11]) and not further divisible -- its exact extent is site dependent.",
      "ja": "異なるスコープは、RFC 2365 [11]によって定義されます。 IPv4のローカルスコープ（239.255.0.0/16）（RFC 2365 [11]によって定義されるように）マルチキャストスコープではなく、さらに分割管理のための最小の囲み範囲である - その正確な範囲は、サイトに依存します。"
    },
    {
      "indent": 3,
      "text": "For the IPv4 Local Scope, applying the rules of RFC 2365 [11] and using the assigned offset of 8, the Mbus multicast address is therefore 239.255.255.247.",
      "ja": "IPv4のローカルスコープ、[11] RFC 2365のルールを適用し、割り当てられた8のオフセットを使用するため、Mバスマルチキャストアドレスは、従って、239.255.255.247です。"
    },
    {
      "indent": 3,
      "text": "For IPv4, the different defined Mbus scopes (host-local and link-local) are to be realized as follows:",
      "ja": "IPv4の場合、異なる規定のMBusスコープ（ホスト - ローカルおよびリンクローカル）は次のように実現されるべきです。"
    },
    {
      "indent": 3,
      "text": "host-local multicast: Unless configured otherwise, the assigned scope-relative Mbus address in the Local Scope (239.255.255.247 as of RFC 2365 [11]) MUST be used. Mbus UDP datagrams SHOULD be sent with a TTL of 0.",
      "ja": "ホストローカルマルチキャスト：特に構成しない限り、ローカルスコープに割り当てられたスコープ相対のMBusアドレス（RFC 2365のよう239.255.255.247 [11]）を使用しなければなりません。 MバスUDPデータグラムは、0のTTLを送ってください。"
    },
    {
      "indent": 3,
      "text": "link-local multicast: Unless configured otherwise, the assigned scope-relative Mbus address in the Local Scope (239.255.255.247 as of RFC 2365 [11]) MUST be used. Mbus UDP datagrams SHOULD be sent with a TTL of 1.",
      "ja": "リンクローカルマルチキャスト：特に構成しない限り、（RFC 2365 [11]のよう239.255.255.247）ローカルスコープに割り当てられたスコープ相対のMBusアドレスを使用しなければなりません。 MバスUDPデータグラムは、1のTTLを送ってください。"
    },
    {
      "indent": 0,
      "text": "6.1.2 Mbus multicast groups for IPv6",
      "section_title": true,
      "ja": "IPv6の6.1.2のMbusマルチキャストグループ"
    },
    {
      "indent": 3,
      "text": "IPv6 has different address ranges for different multicast scopes and distinguishes node local and link local scopes, that are implemented as a set of address prefixes for the different address ranges (RFC 2373 [3]). The link-local prefix is FF02, the node-local prefix is FF01. A permanently assigned multicast address will be used for Mbus multicast communication, i.e., an address that is independent of the scope value and that can be used for all scopes. Implementations for IPv6 MUST use the scope-independent address and the appropriate prefix for the selected scope. For host-local Mbus communication the IPv6 node-local scope prefix MUST be used, for link-local Mbus communication the IPv6 link-local scope prefix MUST be used.",
      "ja": "IPv6は異なるマルチキャストスコープの異なるアドレス範囲を持ち、ローカル・ノードを区別し、異なるアドレス範囲のアドレスプレフィクスのセットとして実装されているローカルスコープを、リンク（RFC 2373 [3]）。リンクローカルプレフィックスはノードローカルプレフィックスはFF01で、FF02です。永続的割り当てられたマルチキャストアドレスは、MBusマルチキャスト通信、すなわち、スコープ値とは無関係であり、それはすべてのスコープのために使用することができるアドレスのために使用されます。 IPv6の実装は、スコープの独立したアドレスと、選択範囲のための適切な接頭辞を使用しなければなりません。ホストローカルのMBus通信のためのIPv6ノードローカルスコーププレフィックスは、IPv6リンクローカルスコープ接頭辞を使用しなければならないリンクローカルのMBus通信のために使用しなければなりません。"
    },
    {
      "indent": 3,
      "text": "The permanent IPv6 multicast address for Mbus/Ipv6 is FF0X:0:0:0:0:0:0:300.",
      "ja": "0：0：0：0：0：0：300のMbus / IPv6のための永久的なIPv6マルチキャストアドレスはFF0Xあります。"
    },
    {
      "indent": 3,
      "text": "FF0X:0:0:0:0:0:0:300 SHOULD be used for Mbus/IPv6 where the X in FF0X indicates that the scope is not fixed because this is an all scope address. This means, for node-local scope, FF01:0:0:0:0:0:0:300 SHOULD be used and for link-local scope FF02:0:0:0:0:0:0:300 SHOULD be used. See RFC 2375 [4] for IPv6 multicast address assignments.",
      "ja": "FF0X：0：0：0：0：0：0 300 FF0XにおけるXは、これがすべての範囲のアドレスであるため、範囲が固定されていないことを示し、Mバス/ IPv6のために使用されるべきです。 0：0：0：0：0：0：0：0：0：0：0：0 300 FF02を使用し、リンクローカルスコープのためされるべきである300であるべきで、これは、ノードローカルスコープのため、FF01は、手段中古。 IPv6マルチキャストアドレスの割り当てについては、RFC 2375 [4]を参照してください。"
    },
    {
      "indent": 3,
      "text": "If a single application system is distributed across several co-located hosts, link local scope SHOULD be used for multicasting Mbus messages that potentially have recipients on the other hosts. The Mbus protocol is not intended (and hence deliberately not designed) for communication between hosts not on the same link. See Section 12 for specifications of Mbus configuration mechanisms.",
      "ja": "単一のアプリケーションシステムは、いくつかの同一位置のホストに分散されている場合、ローカルスコープは、潜在的に他のホストでの受信者を有するのMBusメッセージをマルチキャストするために使用されるべきであるリンク。 Mバスプロトコルはなく、同じリンク上のホスト間の通信のために意図していない（したがって、故意に設計されていない）されています。 Mバス構成メカニズムの仕様については、セクション12を参照してください。"
    },
    {
      "indent": 0,
      "text": "6.1.3 Use of Broadcast",
      "section_title": true,
      "ja": "放送の6.1.3を使用します"
    },
    {
      "indent": 3,
      "text": "In situations where multicast is not available, broadcast MAY be used instead. In these cases an IP broadcast address for the connected network SHOULD be used for sending. The node-local broadcast address for IPv6 is FF01:0:0:0:0:0:0:1, the link-local broadcast address for IPv6 is FF02:0:0:0:0:0:0:1. For IPv4, the generic broadcast address (for link-local broadcast) is 255.255.255.255. It is RECOMMENDED that IPv4-implementations use the generic broadcast address and a TTL of zero for host-local broadcast.",
      "ja": "マルチキャストが利用できない状況では、放送が代わりに使用されるかもしれません。これらのケースで接続されたネットワークのIPブロードキャストアドレスを送信するために使用されるべきである（SHOULD）。 IPv6のリンクローカルブロードキャストアドレスはFF02で、1：0：0：0：0：0：0 IPv6のノードローカルブロードキャストアドレスはFF01 0：0：0：0：0：0：1。 IPv4の場合、（リンクローカル放送のための）一般的なブロードキャストアドレスは255.255.255.255です。 IPv4の実装は、一般的なブロードキャストアドレスとホストのローカル放送のためのゼロのTTLを使用することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "Broadcast MUST NOT be used in situations where multicast is available and supported by all systems participating in an Mbus session.",
      "ja": "ブロードキャストは、マルチキャストが使用可能とのMbusセッションに参加しているすべてのシステムでサポートされている状況で使用してはいけません。"
    },
    {
      "indent": 3,
      "text": "See Section 12 for configuring the use of broadcast.",
      "ja": "ブロードキャストの使用を設定するための第12節を参照してください。"
    },
    {
      "indent": 0,
      "text": "6.1.4 Mbus UDP Port Number",
      "section_title": true,
      "ja": "6.1.4 MバスUDPポート番号"
    },
    {
      "indent": 3,
      "text": "The registered Mbus UDP port number is 47000.",
      "ja": "登録されたMバスUDPポート番号は47000です。"
    },
    {
      "indent": 0,
      "text": "6.2 Directed Unicast",
      "section_title": true,
      "ja": "6.2ダイレクトユニキャスト"
    },
    {
      "indent": 3,
      "text": "Directed unicast (via UDP) to the port of a specific application is an alternative transport class to multicast. Directed unicast is an OPTIONAL optimization and MAY be used by Mbus implementations for delivering messages addressed to a single application entity only -- the address of which the Mbus implementation has learned from other message exchanges before. Note that the DestAddr field of such messages MUST be filled in properly nevertheless. Every Mbus entity SHOULD use a single unique endpoint address for sending messages to the Mbus multicast group or to individual receiving entities. A unique endpoint address is a tuple consisting of the entity's IP address and a UDP source port number, where the port number is different from the standard Mbus port number.",
      "ja": "特定のアプリケーションのポート（UDPを介して）向けられたユニキャスト、マルチキャストの代替トランスポート・クラスです。有向ユニキャストはOPTIONAL最適化され、単一のアプリケーション・エンティティに宛てたメッセージを配信するためのMBus実装によって使用されるかもしれ - のMBus実装前に他のメッセージ交換から学習したのアドレス。このようなメッセージのDESTADDRフィールドは、それにもかかわらず、適切に記入しなければならないことに注意してください。すべてのMbus実体は、Mバスマルチキャストグループまたは個々の受信エンティティにメッセージを送信するために単一の固有のエンドポイントアドレスを使用する必要があります。一意のエンドポイントアドレスは、ポート番号が標準のMBusポート番号とは異なるエンティティのIPアドレスとUDPソースポート番号、からなるタプルです。"
    },
    {
      "indent": 3,
      "text": "Messages MUST only be sent via unicast if the Mbus target address is unique and if the sending entity can verify that the receiving entity uses a unique endpoint address. The latter can be verified by considering the last message received from that entity.",
      "ja": "送信エンティティは、受信エンティティは、固有のエンドポイントアドレスを使用していることを確認できた場合にメッセージのみのMBusターゲットアドレスが一意である場合、ユニキャストを介して送信されなければなりません。後者は、そのエンティティから受信された最後のメッセージを考慮することによって確認することができます。"
    },
    {
      "indent": 6,
      "text": "Note that several Mbus entities, say within the same process, may share a common transport address; in this case, the contents of the destination address field is used to further dispatch the message. Given the definition of \"unique endpoint address\" above, the use of a shared endpoint address and a dispatcher still allows other Mbus entities to send unicast messages to one of the entities that share the endpoint address. So this can be considered an implementation detail.",
      "ja": "いくつかのMbus実体は、同じプロセス内で言って、共通のトランスポートアドレスを共有することがあります。この場合には、宛先アドレスフィールドの内容は、さらにメッセージをディスパッチするのに使用されます。 「ユニークなエンドポイントアドレス」の定義を考える上で、共有のエンドポイントアドレスとディスパッチャの使用は、まだ他のMbus実体は、エンドポイントアドレスを共有するエンティティの1にユニキャストメッセージを送信することができます。だから、これは実装の詳細を考慮することができます。"
    },
    {
      "indent": 3,
      "text": "Messages with an empty target address list MUST always be sent to all Mbus entities (via multicast if available).",
      "ja": "（利用可能な場合、マルチキャストを経由して）空のターゲットアドレスリストを持つメッセージは、常にすべてのMbus実体に送らなければなりません。"
    },
    {
      "indent": 3,
      "text": "The following algorithm can be used by sending entities to determine whether an Mbus address is unique considering the current set of Mbus entities:",
      "ja": "次のアルゴリズムは、Mバスアドレスは、Mバスエンティティの現在のセットを考慮した固有であるかどうかを判断するためにエンティティを送信することにより、使用することができます。"
    },
    {
      "indent": 9,
      "text": "let ta=the target address;\niterate through the set of all\ncurrently known Mbus addresses {\n   let ti=the address in each iteration;\n   count the addresses for which\n   the predicate isSubsetOf(ta,ti) yields true;\n}",
      "raw": true
    },
    {
      "indent": 6,
      "text": "If the count of matching addresses is exactly 1 the address is unique. The following algorithm can be used for the predicate isSubsetOf, that checks whether the second message matches the first according to the rules specified in Section 4. (A match means that a receiving entity that uses the second Mbus address must also process received messages with the first address as a target address.)",
      "ja": "一致するアドレスの数は、1が正確であれば、アドレスはユニークです。以下のアルゴリズムは、第2のメッセージは、マッチが第二のMBusアドレスを使用し、受信エンティティは、プロセスが持つメッセージを受信しなければならないことを意味する（セクション4で指定された規則に従って最初に一致するかどうかをチェックする述語isSubsetOf、のために使用することができますターゲットアドレスとして最初のアドレス。）"
    },
    {
      "indent": 9,
      "text": "isSubsetOf(addr a1,a2) yields true, iff every address element of a1 is contained in a2's address element list.",
      "ja": "A1のすべてのアドレス要素がA2のアドレス要素リストに含まれている場合に限っisSubsetOf（ADDR a1は、a2）は、TRUEに評価します。"
    },
    {
      "indent": 6,
      "text": "An address element a1 is contained in an address element list if the list contains an element that is equal to a1. An address element is considered equal to another address element if it has the same values for both of the two address element fields (tag and value).",
      "ja": "リストはA1に等しい要素が含まれている場合、アドレス素子A1は、アドレス要素リストに含まれています。アドレス要素は、それが2つのアドレス要素フィールド（タグと値）の両方について同じ値を有する場合、別のアドレスエレメントに等しいと考えられます。"
    },
    {
      "indent": 0,
      "text": "7. Reliability",
      "section_title": true,
      "ja": "7.信頼性"
    },
    {
      "indent": 3,
      "text": "While most messages are expected to be sent using unreliable transport, it may be necessary to deliver some messages reliably. Reliability can be selected on a per message basis by means of the MessageType field. Reliable delivery is supported for messages with a single recipient only; i.e., to a fully qualified Mbus address. An entity can thus only send reliable messages to known addresses, i.e., it can only send reliable messages to entities that have announced their existence on the Mbus (e.g., by means of mbus.hello() messages as defined in Section 9.1). A sending entity MUST NOT send a message reliably if the target address is not unique. (See Section 6 for the specification of an algorithm to determine whether an address is unique.) A receiving entity MUST only process and acknowledge a reliable message if the destination address exactly matches its own source address (the destination address MUST NOT be a subset of the source address).",
      "ja": "ほとんどのメッセージは、信頼性の低いトランスポートを使用して送信されることが期待されるが、確実にいくつかのメッセージを配信する必要があるかもしれません。信頼性のMessageTypeフィールドによってメッセージごとに選択することができます。信頼性の高い配信は、単一の受信者とのメッセージのためにサポートされています。つまり、完全修飾されたMバスアドレスへ。エンティティは、このようにだけ（セクション9.1で定義されているようmbus.hello（）メッセージによって、例えば）、すなわち、それが唯一のMバス上で自分の存在を発表しているエンティティに信頼性の高いメッセージを送信することができ、既知のアドレスに信頼性の高いメッセージを送信することができます。ターゲットアドレスが一意でない場合、送信エンティティは、確実にメッセージを送ってはいけません。宛先アドレスが正確に独自の送信元アドレスと一致する場合、受信エンティティ必要がある唯一のプロセスを（アドレスが一意であるかどうかを決定するアルゴリズムの仕様については、セクション6を参照）、信頼性のあるメッセージを確認（宛先アドレスのサブセットであるはずがありません送信元アドレス）。"
    },
    {
      "indent": 3,
      "text": "Disallowing reliable message delivery for messages sent to multiple destinations is motivated by simplicity of the implementation as well as the protocol. The desired effect can be achieved at the application layer by sending individual reliable messages to each fully qualified destination address, if the membership information for the Mbus session is available.",
      "ja": "複数の宛先に送信されるメッセージの拒否信頼性の高いメッセージ配信を実装の単純さ、ならびにプロトコルによって動機付けされます。 MBusセッションのメンバーシップ情報が利用可能である場合、所望の効果は、それぞれの完全修飾宛先アドレスに個々の信頼メッセージを送信することにより、アプリケーション層で達成することができます。"
    },
    {
      "indent": 3,
      "text": "Each message is tagged with a message sequence number. If the MessageType is \"R\", the sender expects an acknowledgment from the recipient within a short period of time. If the acknowledgment is not received within this interval, the sender MUST retransmit the message (with the same message sequence number), increase the timeout, and restart the timer. Messages MUST be retransmitted a small number of times (see below) before the transmission or the recipient are considered to have failed. If the message is not delivered successfully, the sending application is notified. In this case, it is up to the application to determine the specific actions (if any) to be taken.",
      "ja": "各メッセージは、メッセージシーケンス番号でタグ付けされています。 MessageTypeのは、「R」であれば、送信者は時間の短い期間内に受信者からの確認応答を期待しています。承認は、この期間内に受信されない場合、（同じメッセージシーケンス番号で）メッセージを再送しなければならない送信者は、タイムアウトを長くし、タイマーを再起動してください。送信や受信者が失敗したとみなされる前に、メッセージは、（下記参照）少ない回数を再送しなければなりません。メッセージが正常に配信されていない場合は、送信側アプリケーションに通知されます。この場合には、取るべき特定の動作（もしあれば）を決定するために、アプリケーション次第です。"
    },
    {
      "indent": 3,
      "text": "Reliable messages MUST be acknowledged by adding their SeqNum to the AckList field of a message sent to the originator of the reliable message. This message MUST be sent to a fully qualified Mbus target address. Multiple acknowledgments MAY be sent in a single message. Implementations MAY either piggy-back the AckList onto another message sent to the same destination, or MAY send a dedicated acknowledgment message, with no commands in the message payload part.",
      "ja": "信頼性の高いメッセージは、信頼できるメッセージの発信者に送信されたメッセージのAckListフィールドに自分のSEQNUMを追加することによって確認されなければなりません。このメッセージは、完全修飾されたMバスのターゲットアドレスに送らなければなりません。複数の確認応答は、単一のメッセージで送信することができます。実装は、同じ宛先に送信される別のメッセージ上のいずれかピギーバックAckListを得るか、またはメッセージのペイロード部分でないコマンドを使用して、専用の肯定応答メッセージを送信することができます。"
    },
    {
      "indent": 3,
      "text": "The precise procedures are as follows:",
      "ja": "次のように正確な手順は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "Sender: A sender A of a reliable message M to receiver B MUST transmit the message either via IP-multicast or via IP-unicast, keep a copy of M, initialize a retransmission counter N to '1', and start a retransmission timer T (initialized to T_r). If an acknowledgment is received from B, timer T MUST be cancelled and the copy of M is discarded. If T expires, the message M MUST be retransmitted, the counter N MUST be incremented by one, and the timer MUST be restarted (set to N*T_r). If N exceeds the retransmission threshold N_r, the transmission is assumed to have failed, further retransmission attempts MUST NOT be undertaken, the copy of M MUST be discarded, and the sending application SHOULD be notified.",
      "ja": "送信側：Bを受信機に信頼性のあるメッセージMの送信者Aは、IPマルチキャストを介して、またはIPユニキャストのいずれかを介してメッセージを送信するMのコピーを維持し、「1」に再送カウンタNを初期化し、再送タイマーTを起動する必要があります（T_Rに初期化）。肯定応答がBから受信された場合、タイマTをキャンセルしなければならなくて、Mのコピーは破棄されます。 Tが満了した場合、メッセージMは、カウンタNを1インクリメントしなければならない、再送信されなければならない、とタイマーは（N * T_Rにセット）を再起動する必要があります。 Nが再送閾値N_rを超えた場合、送信が失敗したと想定されるさらなる再送の試みが行われてはいけません、Mのコピーを破棄しなければなりません、そして送信側アプリケーションに通知されるべきです。"
    },
    {
      "indent": 3,
      "text": "Receiver: A receiver B of a reliable message from a sender A MUST acknowledge reception of the message within a time period T_c < T_r. This MAY be done by means of a dedicated acknowledgment message or by piggy-backing the acknowledgment on another message addressed only to A.",
      "ja": "受信機：送信者Aからの信頼性の高いメッセージの受信機Bが時間T_C <T_R内のメッセージの受信を確認しなければなりません。これはAにのみ対処し、専用の受信確認メッセージによって、または別のメッセージに確認をピギーバックすることによって行うことができます"
    },
    {
      "indent": 3,
      "text": "Receiver optimization: In a simple implementation, B may choose to immediately send a dedicated acknowledgment message. However, for efficiency, it could add the SeqNum of the received message to a sender-specific list of acknowledgments; if the added SeqNum is the first acknowledgment in the list, B SHOULD start an acknowledgment timer TA (initialized to T_c). When the timer expires, B SHOULD create a dedicated acknowledgment message and send it to A. If B is to transmit another Mbus message addressed only to A, it should piggy-back the acknowledgments onto this message and cancel TA. In either case, B should store a copy of the acknowledgment list as a single entry in the per-sender copy list, keep this entry for a period T_k, and empty the acknowledgment list. In case any of the messages kept in an entry of the copy list is received again from A, the entire acknowledgment list stored in this entry is scheduled for (re-) transmission following the above rules.",
      "ja": "受信機の最適化：単純な実装では、Bはすぐに専用の受信確認メッセージを送信することもできます。しかし、効率のために、それは確認応答の送信者特定のリストに、受信したメッセージのSEQNUMを追加することができます。加えSEQNUMは、リスト内の最初の肯定応答である場合、Bは、肯定応答タイマーTA（T_Cに初期設定）を開始すべきです。タイマが満了すると、Bは、専用の肯定応答メッセージを作成する必要があり、Bは別のMBusメッセージのみA宛に送信する場合A.に送信し、このメッセージへの確認応答をバックピギーとTAをキャンセルしなければなりません。いずれの場合も、Bは、あたりの送信者コピーリスト内の単一のエントリとして承認リストのコピーを保存する期間T_Kのためにこのエントリを維持し、承認リストを空にする必要があります。場合にメッセージのいずれかがAから再び受信されるコピーリストのエントリに保持、このエントリに格納されている全体の確認応答リストは、上記のルール以下の（再）送信のためにスケジュールされています。"
    },
    {
      "indent": 3,
      "text": "Constants and Algorithms: The following constants and algorithms SHOULD be used by implementations:",
      "ja": "定数とアルゴリズム：以下の定数とアルゴリズムが実装によって使用されるべきです。"
    },
    {
      "indent": 6,
      "text": "T_r=100ms",
      "ja": "T_R = 100msの"
    },
    {
      "indent": 6,
      "text": "N_r=3",
      "ja": "N_r = 3"
    },
    {
      "indent": 6,
      "text": "T_c=70ms",
      "ja": "T_C = 70msで"
    },
    {
      "indent": 6,
      "text": "T_k=((N_r)*(N_r+1)/2)*T_r",
      "ja": "T_K =（（N_r）*（N_r + 1）/ 2）* T_R"
    },
    {
      "indent": 0,
      "text": "8. Awareness of other Entities",
      "section_title": true,
      "ja": "他のエンティティの8.意識"
    },
    {
      "indent": 3,
      "text": "Before Mbus entities can communicate with one another, they need to mutually find out about their existence. After this bootstrap procedure that each Mbus entity goes through all other entities listening to the same Mbus know about the newcomer and the newcomer has learned about all the other entities. Furthermore, entities need to be able to to notice the failure (or leaving) of other entities.",
      "ja": "Mバスエンティティが互いに通信できるようにするには、彼らは相互にその存在を知る必要があります。それぞれのMbus実体は同じMバスを聞いて他のすべてのエンティティを通過し、このブートストラップ手順の後新人について知っていると新人を約他のすべてのエンティティを学んできました。また、エンティティが他のエンティティの故障（または離脱）を気づくことができるようにする必要があります。"
    },
    {
      "indent": 3,
      "text": "Any Mbus entity MUST announce its presence (on the Mbus) after starting up. This is to be done repeatedly throughout its lifetime to address the issues of startup sequence: Entities should always become aware of other entities independent of the order of starting.",
      "ja": "任意のMbus実体は、起動後（Mバス上の）その存在を公表しなければなりません。エンティティは常に開始のための独立した他のエンティティを自覚すべきである：これは、起動シーケンスの問題に対処するために、その生涯を通じて繰り返し行う必要があります。"
    },
    {
      "indent": 3,
      "text": "Each Mbus entity MUST maintain the number of Mbus session members and continuously update this number according to any observed changes. The mechanisms of how the existence and the leaving of other entities can be detected are dedicated Mbus messages for entity awareness: mbus.hello (Section 9.1) and mbus.bye (Section 9.2). Each Mbus protocol implementation MUST periodically send mbus.hello messages that are used by other entities to monitor the existence of that entity. If an entity has not received mbus.hello messages for a certain time (see Section 8.2) from an entity, the respective entity is considered to have left the Mbus and MUST be excluded from the set of currently known entities. Upon the reception of a mbus.bye message the respective entity is considered to have left the Mbus as well and MUST be excluded from the set of currently known entities immediately.",
      "ja": "各MBusエンティティは、Mバスセッションメンバーの数を維持し、継続的に、任意の観察された変化に応じて、この数を更新する必要があります。 mbus.hello（9.1節）とmbus.bye（9.2節）：存在と他のエンティティの脱離を検出することができる方法のメカニズムは、エンティティの認識のための専用のMbusメッセージです。各MBusプロトコルの実装は、定期的にそのエンティティの存在を監視するために、他のエンティティによって使用されているmbus.helloメッセージを送らなければなりません。エンティティは、エンティティから（8.2節を参照）一定時間メッセージをmbus.hello受信していない場合は、それぞれのエンティティは、Mバスを残していることが、現在知られているエンティティのセットから除外されなければならないと考えられています。 mbus.byeメッセージを受信すると、それぞれのエンティティは、同様にMバスを残していると考えられ、直ちに現在知られているエンティティのセットから除外しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Each Mbus entity MUST send hello messages to the Mbus after startup. After transmission of the hello message, it MUST start a timer after the expiration of which the next hello message is to be transmitted. Transmission of hello messages MUST NOT be stopped unless the entity detaches from the Mbus. The interval for sending hello messages is dependent on the current number of entities in an Mbus group and can thus change dynamically in order to avoid congestion due to many entities sending hello messages at a constant high rate.",
      "ja": "各MBusエンティティは、起動後にMバスにhelloメッセージを送らなければなりません。ハローメッセージの送信後、次のHelloメッセージが送信されるの満了後、タイマを開始しなければなりません。エンティティはMバスから切り離さない限り、helloメッセージの送信を停止してはなりません。 helloメッセージを送信する間隔は、Mバスグループ内のエンティティの現在の数に依存しているのでによる一定の高レートでhelloメッセージを送信する多くの企業に混雑を避けるために、動的に変更することができます。"
    },
    {
      "indent": 3,
      "text": "Section 8.1 specifies the calculation of hello message intervals that MUST be used by protocol implementations. Using the values that are calculated for obtaining the current hello message timer, the timeout for received hello messages is calculated in Section 8.2. Section 9 specifies the command synopsis for the corresponding Mbus messages.",
      "ja": "セクション8.1は、プロトコルの実装で使用しなければならないハローメッセージ間隔の計算を指定します。現在、helloメッセージのタイマーを取得するために計算された値を使用して、受け取ったhelloメッセージのタイムアウトは、セクション8.2で計算されます。第9章では、対応するMバスメッセージのコマンド概要を指定します。"
    },
    {
      "indent": 0,
      "text": "8.1 Hello Message Transmission Interval",
      "section_title": true,
      "ja": "8.1こんにちは、メッセージ送信間隔"
    },
    {
      "indent": 3,
      "text": "Since the number of entities in an Mbus session may vary, care must be taken to allow the Mbus protocol to automatically scale over a wide range of group sizes. The average rate at which hello messages are received would increase linearly to the number of entities in a session if the sending interval was set to a fixed value. Given an interval of 1 second this would mean that an entity taking part in an Mbus session with n entities would receive n hello messages per second. Assuming all entities resided on one host, this would lead to n*n messages that have to be processed per second -- which is obviously not a viable solution for larger groups. It is therefore necessary to deploy dynamically adapted hello message intervals, taking varying numbers of entities into account. In the following, we specify an algorithm that MUST be used by implementors to calculate the interval for hello messages considering the observed number of Mbus entities.",
      "ja": "MBusセッション内のエンティティの数は変わる可能性があるので、注意がMバスプロトコルが自動的にグループサイズの広い範囲でスケーリングすることを可能にするように注意しなければなりません。送信間隔を固定値に設定された場合は、メッセージが受信されるハローの平均レートは、セッション内のエンティティの数に直線的に増加するであろう。 1秒の間隔を考えると、これは、n個のエンティティとのMbusセッションに参加しているエンティティは、ハローのn秒あたりのメッセージを受け取ることになることを意味します。明らかに、より大きなグループのための実行可能なソリューションではありません - すべてのエンティティは、一つのホスト上に置か仮定すると、これは、n * n個の第2あたりに処理されなければならないメッセージにつながります。考慮に入れ、エンティティの様々な数字を取って、動的に適合helloメッセージの間隔を展開する必要があります。以下では、Mバスエンティティの観察数を考慮し、helloメッセージの間隔を計算するために実装で使用しなければならないアルゴリズムを指定します。"
    },
    {
      "indent": 3,
      "text": "The algorithm features the following characteristics:",
      "ja": "このアルゴリズムは、次のような特徴を備えています："
    },
    {
      "indent": 3,
      "text": "o The number of hello messages that are received by a single entity in a certain time unit remains approximately constant as the number of entities changes.",
      "ja": "O一定時間単位で単一のエンティティによって受信されるHelloメッセージの数は、エンティティの変更の数とほぼ一定のままです。"
    },
    {
      "indent": 3,
      "text": "o The effective interval that is used by a specific Mbus entity is randomized in order to avoid unintentional synchronization of hello messages within an Mbus session. The first hello message of an entity is also delayed by a certain random amount of time.",
      "ja": "O特定のMBusエンティティによって使用される有効期間は、Mバスセッション内Helloメッセージの意図しない同期を回避するためにランダム化されます。エンティティの最初のハローメッセージは、時間の特定のランダム量だけ遅延されます。"
    },
    {
      "indent": 3,
      "text": "o A timer reconsideration mechanism is deployed in order to adapt the interval more appropriately in situations where a rapid change of the number of entities is observed. This is useful when an entity joins an Mbus session and is still learning of the existence of other entities or when a larger number of entities leaves the Mbus at once.",
      "ja": "Oタイマー見直し機構は、エンティティの数の急激な変化が観察された状況で、より適切に間隔を適合させるために配備されています。エンティティは、Mバスのセッションに参加し、まだ他のエンティティの存在の学習またはエンティティの数が多いほど、一度にMバスを離れるとされている場合に便利です。"
    },
    {
      "indent": 0,
      "text": "8.1.1 Calculating the Interval for Hello Messages",
      "section_title": true,
      "ja": "Helloメッセージの間隔を計算8.1.1"
    },
    {
      "indent": 3,
      "text": "The following variable names are used in the calculation specified below (all time values in milliseconds):",
      "ja": "以下の変数名は、以下の指定された計算（ミリ秒すべての時間値）で使用されています。"
    },
    {
      "indent": 3,
      "text": "hello_p: The last time a hello message has been sent by a Mbus entity.",
      "ja": "hello_p：helloメッセージは、Mバスエンティティによって送信された最後の時間。"
    },
    {
      "indent": 3,
      "text": "hello_now: The current time",
      "ja": "hello_now：現在の時間"
    },
    {
      "indent": 3,
      "text": "hello_d: The deterministic calculated interval between hello messages.",
      "ja": "hello_d：helloメッセージ間の決定論、計算の間隔。"
    },
    {
      "indent": 3,
      "text": "hello_e: The effective (randomized) interval between hello messages.",
      "ja": "hello_e：helloメッセージ間の効果的な（無作為化）間隔。"
    },
    {
      "indent": 3,
      "text": "hello_n: The time for the next scheduled transmission of a hello message.",
      "ja": "hello_n：helloメッセージの次に予定された送信のための時間。"
    },
    {
      "indent": 3,
      "text": "entities_p: The numbers of entities at the time hello_n has been last recomputed.",
      "ja": "entities_p：時間hello_nのエンティティの数字は、最後の再計算されています。"
    },
    {
      "indent": 3,
      "text": "entities: The number of currently known entities.",
      "ja": "エンティティ：現在知られているエンティティの数。"
    },
    {
      "indent": 3,
      "text": "The interval between hello messages MUST be calculated as follows:",
      "ja": "次のようにhelloメッセージの間隔を計算しなければなりません："
    },
    {
      "indent": 3,
      "text": "The number of currently known entities is multiplied by c_hello_factor, yielding the interval between hello messages in milliseconds. This is the deterministic calculated interval, denoted hello_d. The minimum value for hello_d is c_hello_min which yields",
      "ja": "現在知られているエンティティの数は、ミリ秒単位でhelloメッセージ間の間隔を得、c_hello_factorを掛けています。これは、決定論的計算された間隔、表記hello_dです。 hello_dの最小値は、利回りc_hello_minです"
    },
    {
      "indent": 6,
      "text": "hello_d = max(c_hello_min,c_hello_factor * entities * 1ms).",
      "ja": "hello_d = MAX（c_hello_min、c_hello_factor *実体* 1ミリ秒）。"
    },
    {
      "indent": 3,
      "text": "Section 8 provides a specification of how to obtain the number of currently known entities. Section 10 provides values for the constants c_hello_factor and c_hello_min.",
      "ja": "第8節は、現在知られているエンティティの数を取得する方法の仕様を提供します。第10節は定数c_hello_factorとc_hello_minの値を提供します。"
    },
    {
      "indent": 3,
      "text": "The effective interval hello_e that is to be used by individual entities is calculated by multiplying hello_d with a randomly chosen number between c_hello_dither_min and c_hello_dither_max as follows:",
      "ja": "個々のエンティティによって使用される有効間隔hello_eは、以下のようc_hello_dither_minとc_hello_dither_max間でランダムに選択された数とhello_d乗算することによって計算されます。"
    },
    {
      "indent": 7,
      "text": "hello_e = c_hello_dither_min +\n          RND * (c_hello_dither_max - c_hello_dither_min)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "with RND being a random function that yields an even distribution between 0 and 1. See also Section 10.",
      "ja": "RNDは、0と1の間の均一な分布をもたらすランダム関数であることでも、セクション10を参照してください。"
    },
    {
      "indent": 3,
      "text": "hello_n, the time for the next hello message in milliseconds is set to hello_e + hello_now.",
      "ja": "hello_n、ミリ秒単位で次のhelloメッセージのための時間は+ hello_nowをhello_eするように設定されています。"
    },
    {
      "indent": 0,
      "text": "8.1.2 Initialization of Values",
      "section_title": true,
      "ja": "値の8.1.2初期化"
    },
    {
      "indent": 3,
      "text": "Upon joining an Mbus session a protocol implementation sets hello_p=0, hello_now=0 and entities=1, entities_p=1 (the Mbus entity itself) and then calculates the time for the next hello message as specified in Section 8.1.1. The next hello message is scheduled for transmission at hello_n.",
      "ja": "MBusセッションに参加すると、プロトコルの実装では、hello_p = 0、hello_now = 0設定し、エンティティ= 1、entities_p = 1（のMBusエンティティ自体）、次いで、セクション8.1.1で指定されるように、次のHelloメッセージの時間を算出します。次のhelloメッセージがhello_nでの伝送のために予定されています。"
    },
    {
      "indent": 0,
      "text": "8.1.3 Adjusting the Hello Message Interval when the Number of Entities increases",
      "ja": "8.1.3エンティティの数が増加した場合こんにちは、メッセージインターバルの調整"
    },
    {
      "indent": 3,
      "text": "When the existence of a new entity is observed by a protocol implementation the number of currently known entities is updated. No further action concerning the calculation of the hello message interval is required. The reconsideration of the timer interval takes place when the current timer for the next hello message expires (see Section 8.1.5).",
      "ja": "新しいエンティティの存在がプロトコル実装によって観察された場合、現在知られているエンティティの数が更新されます。ハローメッセージ間隔の計算に関する更なるアクションは必要とされません。次のhelloメッセージの現在のタイマーが満了したときにタイマ間隔の見直しが行われます（セクション8.1.5を参照してください）。"
    },
    {
      "indent": 0,
      "text": "8.1.4 Adjusting the Hello Message Interval when the Number of Entities decreases",
      "ja": "8.1.4エンティティの数が減少したときのHelloメッセージインターバルの調整"
    },
    {
      "indent": 3,
      "text": "Upon realizing that an entity has left the Mbus the number of currently known entities is updated and the following algorithm should be used to reconsider the timer interval for hello messages:",
      "ja": "エンティティが現在知られているエンティティの数が更新され、次のアルゴリズムは、helloメッセージのためのタイマー間隔を再考するために使用されるべきMバスを離れたことを実現する際に："
    },
    {
      "indent": 3,
      "text": "1. The value for hello_n is updated by setting hello_n = hello_now + (entities/entities_p)*(hello_n - hello_now)",
      "ja": "1. hello_nの値を設定することによって更新されるhello_n = hello_now +（エンティティ/ entities_p）*（hello_n  -  hello_now）"
    },
    {
      "indent": 3,
      "text": "2. The value for hello_p is updated by setting hello_p = hello_now - (entities/entities_p)*(hello_now - hello_p)",
      "ja": "2. hello_pの値が設定することによって更新されhello_p = hello_now  - （エンティティ/ entities_p）*（hello_now  -  hello_p）"
    },
    {
      "indent": 3,
      "text": "3. The currently active timer for the next hello messages is cancelled and a new timer is started for hello_n.",
      "ja": "3.次のhelloメッセージの現在アクティブなタイマーが解除され、新しいタイマーがhello_n開始されます。"
    },
    {
      "indent": 3,
      "text": "4. entities_p is set to entities.",
      "section_title": true,
      "ja": "4. entities_pは、エンティティに設定されています。"
    },
    {
      "indent": 0,
      "text": "8.1.5 Expiration of hello timers",
      "section_title": true,
      "ja": "ハロータイマーの有効期限8.1.5"
    },
    {
      "indent": 3,
      "text": "When the hello message timer expires, the protocol implementation MUST perform the following operations:",
      "ja": "helloメッセージタイマーの期限が切れると、プロトコルの実装には、次の操作を実行する必要があります。"
    },
    {
      "indent": 6,
      "text": "The hello interval hello_e is computed as specified in Section 8.1.1.",
      "ja": "ハロー間隔hello_eは、8.1.1項で指定されるように計算されます。"
    },
    {
      "indent": 6,
      "text": "1. IF hello_e + hello_p <= hello_now THEN a hello message is transmitted. hello_p is set to hello_now, hello_e is calculated again as specified in Section 8.1.1 and hello_n is set to hello_e + hello_now.",
      "ja": "1. IF hello_e + hello_p <= hello_now THEN Helloメッセージが送信されます。 hello_pがhello_nowに設定されているセクション8.1.1で指定されhello_nが+ hello_nowをhello_eするように設定されているように、hello_eが再び計算されます。"
    },
    {
      "indent": 6,
      "text": "2. ELSE IF hello_e + hello_p > hello_now THEN hello_n is set to hello_e + hello_p. A new timer for the next hello message is started to expire at hello_n. No hello message is transmitted.",
      "ja": "2. ELSE IF hello_e + hello_p> hello_now THEN hello_nが+ hello_pをhello_eするように設定されています。次のhelloメッセージのための新しいタイマーがhello_nに失効し始めています。ハローないメッセージが送信されます。"
    },
    {
      "indent": 6,
      "text": "entities_p is set to entities.",
      "ja": "entities_pは、エンティティに設定されています。"
    },
    {
      "indent": 0,
      "text": "8.2 Calculating the Timeout for Mbus Entities",
      "section_title": true,
      "ja": "8.2 Mバスエンティティのタイムアウトを計算"
    },
    {
      "indent": 3,
      "text": "Whenever an Mbus entity has not heard for a time span of c_hello_dead*(hello_d*c_hello_dither_max) milliseconds from another Mbus entity it may consider this entity to have failed (or have quit silently). The number of the currently known entities MUST be updated accordingly. See Section 8.1.4 for details. Note that no need for any further action is necessarily implied from this observation.",
      "ja": "Mバスエンティティは、別のMbus実体からc_hello_deadの*（hello_d * c_hello_dither_max）ミリ秒の時間間隔のために聞いていないときはいつでも、それは、このエンティティが失敗した（または静かに終了している）を検討してください。現在知られているエンティティの数に応じて更新されなければなりません。詳細については、セクション8.1.4を参照してください。任意のさらなる行動の必要は必ずしもこの観察から示唆されないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "Section 8.1.1 specifies how to obtain hello_d. Section 10 defines values for the constants c_hello_dead and c_hello_dither_max.",
      "ja": "8.1.1はhello_dを取得する方法を指定します。セクション10は定数c_hello_deadとc_hello_dither_maxの値を定義します。"
    },
    {
      "indent": 0,
      "text": "9. Messages",
      "section_title": true,
      "ja": "9.メッセージ"
    },
    {
      "indent": 3,
      "text": "This section defines some basic application-independent messages that MUST be understood by all implementations; these messages are required for proper operation of the Mbus. This specification does not contain application-specific messages. These are to be defined outside of the basic Mbus protocol specification in separate Mbus profiles.",
      "ja": "このセクションでは、すべての実装によって理解されなければならないいくつかの基本的なアプリケーションに依存しないメッセージを定義します。これらのメッセージは、Mバスの適切な動作のために必要とされています。この仕様では、アプリケーション固有のメッセージが含まれていません。これらは、別個のMBusプロファイルの基本のMBusプロトコル仕様の外側で定義されます。"
    },
    {
      "indent": 0,
      "text": "9.1 mbus.hello",
      "section_title": true,
      "ja": "9.1 mbus.hello"
    },
    {
      "indent": 6,
      "text": "Syntax:\nmbus.hello()",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Parameters: - none -",
      "ja": "パラメータ： - なし - "
    },
    {
      "indent": 3,
      "text": "mbus.hello messages MUST be sent unreliably to all Mbus entities.",
      "ja": "mbus.helloのメッセージは、すべてのMbus実体に不確実に送らなければなりません。"
    },
    {
      "indent": 3,
      "text": "Each Mbus entity learns about other Mbus entities by observing their mbus.hello messages and tracking the sender address of each message and can thus calculate the current number of entities.",
      "ja": "各MBusエンティティは、各メッセージの送信者アドレスを自分のmbus.helloメッセージを観察し、追跡することによって他のMbus実体について学習ので、エンティティの現在の数を計算することができます。"
    },
    {
      "indent": 3,
      "text": "mbus.hello messages MUST be sent periodically in dynamically calculated intervals as specified in Section 8.",
      "ja": "セクション8で指定されているようmbus.helloメッセージが動的に計算された間隔で定期的に送らなければなりません。"
    },
    {
      "indent": 3,
      "text": "Upon startup the first mbus.hello message MUST be sent after a delay hello_delay, where hello_delay be a randomly chosen number between 0 and c_hello_min (see Section 10).",
      "ja": "起動時に最初mbus.helloメッセージは0とc_hello_minの間にランダムに選択された数であるhello_delay遅延hello_delay、後に送信されなければならない（セクション10を参照）。"
    },
    {
      "indent": 0,
      "text": "9.2 mbus.bye",
      "section_title": true,
      "ja": "9.2 mbus.bye"
    },
    {
      "indent": 6,
      "text": "Syntax: mbus.bye()",
      "ja": "構文：mbus.bye（）"
    },
    {
      "indent": 6,
      "text": "Parameters: - none -",
      "ja": "パラメータ： - なし - "
    },
    {
      "indent": 3,
      "text": "An Mbus entity that is about to terminate (or \"detach\" from the Mbus) SHOULD announce this by transmitting an mbus.bye message. The mbus.bye message MUST be sent unreliably to all entities.",
      "ja": "MBus終了しようとしているエンティティ（またはMバスから「デタッチ」）はmbus.byeメッセージを送信することによって、これを公表すべきです。 mbus.byeメッセージは、すべてのエンティティに不確かに送らなければなりません。"
    },
    {
      "indent": 0,
      "text": "9.3 mbus.ping",
      "section_title": true,
      "ja": "９。３ ｍぶｓ。ぴんｇ"
    },
    {
      "indent": 6,
      "text": "Syntax: mbus.ping()",
      "ja": "構文：mbus.ping（）"
    },
    {
      "indent": 6,
      "text": "Parameters: - none -",
      "ja": "パラメータ： - なし - "
    },
    {
      "indent": 3,
      "text": "mbus.ping can be used to solicit other entities to signal their existence by replying with an mbus.hello message. Each protocol implementation MUST understand mbus.ping and reply with an mbus.hello message. The reply hello message MUST be delayed for hello_delay milliseconds, where hello_delay be a randomly chosen number between 0 and c_hello_min (see Section 10). Several mbus.ping messages MAY be answered by a single mbus.hello: if one or more further mbus.ping messages are received while the entity is waiting hello_delay time units before transmitting the mbus.hello message, no extra mbus.hello message need be scheduled for those additional mbus.ping messages.",
      "ja": "mbus.pingはmbus.helloメッセージで返信することによってその存在を知らせるために、他のエンティティを求めるために使用することができます。各プロトコルの実装はmbus.pingを理解し、mbus.helloメッセージで応答しなければなりません。応答ハローメッセージは0とc_hello_minの間にランダムに選択された数（セクション10を参照）であるhello_delay hello_delayミリ秒、のために遅延されなければなりません。いくつかのmbus.pingメッセージは、単一のmbus.helloによって答えられることがあります。エンティティはmbus.helloメッセージを送信する前にhello_delay時間単位を待っている間、一つ以上の更なるmbus.pingメッセージを受信した場合、余分なmbus.helloメッセージはする必要はありませんこれらの追加mbus.pingメッセージに予定。"
    },
    {
      "indent": 3,
      "text": "As specified in Section 9.1 hello messages MUST be sent unreliably to all Mbus entities. This is also the case for replies to ping messages. An entity that replies to mbus.ping with mbus.hello SHOULD stop any outstanding timers for hello messages after sending the hello message and schedule a new timer event for the subsequent hello message. (Note that using the variables and the algorithms of Section 8.1.1 this can be achieved by setting hello_p to hello_now.)",
      "ja": "9.1節helloメッセージで指定されているように、すべてのMbus実体に不確実に送らなければなりません。また、これは、メッセージをpingに応答するためのケースです。 mbus.helloでmbus.pingへの返信エンティティは、helloメッセージを送信した後に、helloメッセージのために未処理のタイマーを停止し、その後のhelloメッセージのための新しいタイマーイベントをスケジュールする必要があります。 （変数およびセクション8.1.1のアルゴリズムを使用し、これはhello_nowするhello_pを設定することによって達成することができることに留意されたいです。）"
    },
    {
      "indent": 3,
      "text": "mbus.ping allows a new entity to quickly check for other entities without having to wait for the regular individual hello messages. By specifying a target address the new entity can restrict the solicitation for hello messages to a subset of entities it is interested in.",
      "ja": "mbus.pingは、新しいエンティティがすぐに定期的な個別のhelloメッセージを待たずに他のエンティティをチェックすることができます。ターゲット・アドレスを指定して、新しいエンティティは、それが興味を持っているエンティティのサブセットにhelloメッセージのための勧誘を制限することができます。"
    },
    {
      "indent": 0,
      "text": "9.4 mbus.quit",
      "section_title": true,
      "ja": "9.4 mbus.quit"
    },
    {
      "indent": 6,
      "text": "Syntax:\nmbus.quit()",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Parameters: - none -",
      "ja": "パラメータ： - なし - "
    },
    {
      "indent": 3,
      "text": "The mbus.quit message is used to request other entities to terminate themselves (and detach from the Mbus). Whether this request is honoured by receiving entities or not is application specific and not defined in this document.",
      "ja": "mbus.quitメッセージ自体を終了（およびMバスから切り離す）ために、他のエンティティを要求するために使用されます。この要求は実体を受信することで光栄されているかどうかは、アプリケーションの特定と、この文書で定義されていません。"
    },
    {
      "indent": 3,
      "text": "The mbus.quit message can be multicast or sent reliably via unicast to a single Mbus entity or a group of entities.",
      "ja": "mbus.quitメッセージは、マルチキャストまたは単一のMBusエンティティ又はエンティティのグループにユニキャストを介して確実に送信することができます。"
    },
    {
      "indent": 0,
      "text": "9.5 mbus.waiting",
      "section_title": true,
      "ja": "9.5 mbus.waiting"
    },
    {
      "indent": 6,
      "text": "Syntax:\nmbus.waiting(condition)",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 9,
      "text": "symbol condition The condition parameter is used to indicate that the entity transmitting this message is waiting for a particular event to occur.",
      "ja": "シンボル状態条件パラメータは、このメッセージを送信するエンティティが発生する特定のイベントを待っていることを示すために使用されます。"
    },
    {
      "indent": 3,
      "text": "An Mbus entity SHOULD be able to indicate that it is waiting for a certain event to happen (similar to a P() operation on a semaphore but without creating external state somewhere else). In conjunction with this, an Mbus entity SHOULD be capable of indicating to another entity that this condition is now satisfied (similar to a semaphore's V() operation).",
      "ja": "Mバスエンティティは、それが起こるために、特定のイベントのために（セマフォ上のP（）の動作に似ていますが、外部の状態どこか別の場所を作成せずに）待っていることを示すことができるべきである（SHOULD）。これに関連して、Mバスエンティティは、この状態は、現在（セマフォのV（）動作と同様）を満足することを別のエンティティに知らせることができなければなりません。"
    },
    {
      "indent": 3,
      "text": "The mbus.waiting message MAY be broadcast to all Mbus entities, MAY be multicast to an arbitrary subgroup, or MAY be unicast to a particular peer. Transmission of the mbus.waiting message MUST be unreliable and hence MUST be repeated at an application-defined interval (until the condition is satisfied).",
      "ja": "mbus.waitingメッセージは、すべてのMBusエンティティにブロードキャストすることができる任意のサブグループにマルチキャストされてもよく、または特定のピアにユニキャストされるかもしれません。 mbus.waitingメッセージの送信は信頼性が低く、したがって、（条件が満たされるまで）は、アプリケーション定義の間隔で繰り返さでなければなりません。"
    },
    {
      "indent": 3,
      "text": "If an application wants to indicate that it is waiting for several conditions to be met, several mbus.waiting messages are sent (possibly included in the same Mbus payload). Note that mbus.hello and mbus.waiting messages may also be transmitted in a single Mbus payload.",
      "ja": "アプリケーションは、満たされるために、いくつかの条件を待っていることを示したい場合は、いくつかのmbus.waitingメッセージが送信される（おそらく同じMバスペイロードに含まれます）。そのmbus.helloに注意しmbus.waitingメッセージも単一のMBusペイロードに送信することができます。"
    },
    {
      "indent": 0,
      "text": "9.6 mbus.go",
      "section_title": true,
      "ja": "9.6 mbus.go"
    },
    {
      "indent": 6,
      "text": "Syntax:\nmbus.go(condition)",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Parameters:",
      "ja": "パラメーター："
    },
    {
      "indent": 9,
      "text": "symbol condition This parameter specifies which condition is met.",
      "ja": "シンボル条件はこのパラメータは、条件が満たされているかを指定します。"
    },
    {
      "indent": 3,
      "text": "The mbus.go message is sent by an Mbus entity to \"unblock\" another Mbus entity -- which has indicated that it is waiting for a certain condition to be met. Only a single condition can be specified per mbus.go message. If several conditions are satisfied simultaneously multiple mbus.go messages MAY be combined in a single Mbus payload.",
      "ja": "満たすべき所定の条件を待っていることを示した -  mbus.goメッセージは、別のMBusエンティティを「解除」するのMBusエンティティによって送信されます。唯一の条件は、mbus.goメッセージごとに指定することができます。いくつかの条件が満たされている場合、同時に複数mbus.goメッセージが単一のMBusペイロードで組み合わせることができます。"
    },
    {
      "indent": 3,
      "text": "The mbus.go message MUST be sent reliably via unicast to the Mbus entity to unblock.",
      "ja": "mbus.goメッセージがブロック解除するのMBusエンティティにユニキャストを介して確実に送らなければなりません。"
    },
    {
      "indent": 0,
      "text": "10. Constants",
      "section_title": true,
      "ja": "10.定数"
    },
    {
      "indent": 3,
      "text": "The following values for timers and counters mentioned in this document SHOULD be used by implementations:",
      "ja": "この文書に記載さタイマおよびカウンタの値は次の実装で使用されるべきです。"
    },
    {
      "indent": 6,
      "text": "+-------------------+------------------------+--------------+\n|Timer / Counter    | Value                  | Unit         |\n+-------------------+------------------------+--------------+\n|c_hello_factor     | 200                    |     -        |\n|c_hello_min        | 1000                   | milliseconds |\n|c_hello_dither_min | 0.9                    |     -        |\n|c_hello_dither_max | 1.1                    |     -        |\n|c_hello_dead       | 5                      |     -        |\n+-------------------+------------------------+--------------+",
      "raw": true
    },
    {
      "indent": 9,
      "text": "T_r=100ms",
      "ja": "T_R = 100msの"
    },
    {
      "indent": 9,
      "text": "N_r=3",
      "ja": "N_r = 3"
    },
    {
      "indent": 9,
      "text": "T_c=70ms",
      "ja": "T_C = 70msで"
    },
    {
      "indent": 9,
      "text": "T_k=((N_r)*(N_r+1)/2)*T_r",
      "ja": "T_K =（（N_r）*（N_r + 1）/ 2）* T_R"
    },
    {
      "indent": 0,
      "text": "11. Mbus Security",
      "section_title": true,
      "ja": "11. Mバスセキュリティ"
    },
    {
      "indent": 0,
      "text": "11.1 Security Model",
      "section_title": true,
      "ja": "11.1セキュリティモデル"
    },
    {
      "indent": 3,
      "text": "In order to prevent accidental or malicious disturbance of Mbus communications through messages originated by applications from other users, message authentication is deployed (Section 11.3). For each message, a digest MUST be calculated based on the value of a shared secret key value. Receivers of messages MUST check if the sender belongs to the same Mbus security domain by re-calculating the digest and comparing it to the received value. The messages MUST only be processed further if both values are equal. In order to allow different simultaneous Mbus sessions at a given scope and to compensate defective implementations of host local multicast, message authentication MUST be provided by conforming implementations.",
      "ja": "他のユーザからのアプリケーションによって発信メッセージを介してのMBus通信の偶発的または悪質な妨害を防止するために、メッセージ認証は（セクション11.3）に配備されています。各メッセージのために、ダイジェストは、共有秘密鍵の値の値に基づいて計算しなければなりません。送信者がダイジェストを再計算し、受信した値と比較することで、同じMバスのセキュリティドメインに属している場合は、メッセージの受信機はチェックしなければなりません。両方の値が等しい場合、メッセージは、さらに処理されなければなりません。所定の範囲で異なる同時のMBusセッションを可能にするために、ホストローカルマルチキャストの欠陥のある実装を補償するために、メッセージ認証は、実装を従わによって提供されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Privacy of Mbus message transport can be achieved by optionally using symmetric encryption methods (Section 11.2). Each message MAY be encrypted using an additional shared secret key and a symmetric encryption algorithm. Encryption is OPTIONAL for applications, i.e., it is allowed to configure an Mbus domain not to use encryption. But conforming implementations MUST provide the possibility to use message encryption (see below).",
      "ja": "MBusメッセージトランスポートのプライバシーは、必要に応じて、対称暗号化方法（セクション11.2）を使用することによって達成することができます。各メッセージには、追加の共有秘密鍵と対称暗号化アルゴリズムを用いて暗号化することができます。暗号化は、アプリケーションのためのオプションであり、すなわち、暗号化を使用しないMバスドメインを設定することが許可されています。しかし、適合実装は、（下記参照）メッセージの暗号化を使用する可能性を提供しなければなりません。"
    },
    {
      "indent": 3,
      "text": "Message authentication and encryption can be parameterized: the algorithms to apply, the keys to use, etc. These and other parameters are defined in an Mbus configuration object that is accessible by all Mbus entities that participate in an Mbus session. In order to achieve interoperability conforming implementations SHOULD use the values provided by such an Mbus configuration. Section 12 defines the mandatory and optional parameters as well as storage procedures for different platforms. Only in cases where none of the options mentioned in Section 12 is applicable alternative methods of configuring Mbus protocol entities MAY be deployed.",
      "ja": "メッセージ認証および暗号化は、パラメータ化することができます：アルゴリズムは、これらおよび他のパラメータがMバスのセッションに参加するすべてのMbus実体によってアクセス可能であるMバスの構成オブジェクトで定義されているなど、キーを使用するように、適用します。相互運用性適合実装を達成するために、このような構成のMBusによって提供された値を使用すべきです。セクション12は、異なるプラットフォームのために必須とオプションのパラメータ、ならびに記憶手順を定義します。第12節で述べたオプションのいずれもMバスプロトコルエンティティの設定の適用の代替方法が展開されることができるではない場合にのみ。"
    },
    {
      "indent": 3,
      "text": "The algorithms and procedures for applying encryption and authentication techniques are specified in the following sections.",
      "ja": "暗号化および認証技術を適用するためのアルゴリズムおよび手順は、次のセクションで指定されています。"
    },
    {
      "indent": 0,
      "text": "11.2 Encryption",
      "section_title": true,
      "ja": "11.2暗号化"
    },
    {
      "indent": 3,
      "text": "Encryption of messages is OPTIONAL, that means, an Mbus MAY be configured not to use encryption.",
      "ja": "メッセージの暗号化は手段は、Mバスは、暗号化を使用しないように設定することができることを、任意です。"
    },
    {
      "indent": 3,
      "text": "Implementations can choose between different encryption algorithms. Every conforming implementation MUST provide the AES [18] algorithm. In addition, the following algorithms SHOULD be supported: DES [16], 3DES (triple DES) [16] and IDEA [20].",
      "ja": "実装は異なる暗号化アルゴリズムを選択することができます。すべての準拠した実装は、AES [18]のアルゴリズムを提供しなければなりません。加えて、以下のアルゴリズムがサポートされるべきである。[16] DES、3DES（トリプルDES）[16]とIDEA [20]。"
    },
    {
      "indent": 3,
      "text": "For algorithms requiring en/decryption data to be padded to certain boundaries octets with a value of 0 SHOULD be used for padding characters.",
      "ja": "/復号化データが0の値を持つ特定の境界オクテットに水増しする途中必要アルゴリズムのためのパディング文字のために使用されるべきです。"
    },
    {
      "indent": 3,
      "text": "The length of the encryption keys is determined by the currently used encryption algorithm. This means, the configured encryption key MUST NOT be shorter than the native key length for the currently configured algorithm.",
      "ja": "暗号化キーの長さは、現在使用されている暗号化アルゴリズムによって決定されます。これは、構成された暗号化キーは現在設定されているアルゴリズムのネイティブキーの長さよりも短くてはなりません。"
    },
    {
      "indent": 3,
      "text": "DES implementations MUST use the DES Cipher Block Chaining (CBC) mode. DES keys (56 bits) MUST be encoded as 8 octets as described in RFC 1423 [12], resulting in 12 Base64-encoded characters. IDEA uses 128-bit keys (24 Base64-encoded characters). AES can use either 128-bit, 192-bit or 256-bit keys. For Mbus encryption using AES only 128-bit keys (24 Base64-encoded characters) MUST be used.",
      "ja": "DESのインプリメンテーションは、DES暗号ブロック連鎖（CBC）モードを使用しなければなりません。 12 Base64でエンコードされた文字で、その結果、RFC 1423 [12]に記載されているようにDES鍵（56ビット）8つのオクテットとして符号化されなければなりません。 IDEAは128ビットキー（24 Base64でエンコードされた文字）を使用します。 AESは、128ビット、192ビットまたは256ビットのいずれかのキーを使用することができます。 AESのみ128ビットキー（24 Base64でエンコードされた文字）を使用して、Mバス暗号化に使用されなければなりません。"
    },
    {
      "indent": 0,
      "text": "11.3 Message Authentication",
      "section_title": true,
      "ja": "11.3メッセージ認証"
    },
    {
      "indent": 3,
      "text": "For authentication of messages, hashed message authentication codes (HMACs) as described in RFC 2104 [5] are deployed. In general, implementations can choose between a number of digest algorithms. For Mbus authentication, the HMAC algorithm MUST be applied in the following way:",
      "ja": "RFC 2104に記載されているように、メッセージの認証、ハッシュメッセージ認証コード（HMACs）[5]展開されています。一般的に、実装は、ダイジェストアルゴリズムの数との間で選択することができます。 Mバス認証の場合、HMACアルゴリズムは次のように適用する必要があります。"
    },
    {
      "indent": 6,
      "text": "The keyed hash value is calculated using the HMAC algorithm specified in RFC 2104 [5]. The specific hash algorithm and the secret hash key MUST be obtained from the Mbus configuration (see Section 12).",
      "ja": "鍵付きハッシュ値は、RFC 2104で指定されたHMACアルゴリズムを使用して計算される[5]。特定のハッシュアルゴリズムと秘密ハッシュキーは、Mバス構成（セクション12を参照）から得られなければなりません。"
    },
    {
      "indent": 6,
      "text": "The keyed hash values (see RFC 2104 [5]) MUST be truncated to 96 bits (12 octets).",
      "ja": "鍵付きハッシュ値は、96ビット（12オクテット）に切り捨てなければならない（[5] RFC 2104を参照します）。"
    },
    {
      "indent": 6,
      "text": "Subsequently, the resulting 12 octets MUST be Base64-encoded, resulting in 16 Base64-encoded characters (see RFC 1521 [7]).",
      "ja": "その後、得られた12個のオクテット（RFC 1521 [7]を参照）16 Base64でエンコードされた文字をもたらす、Base64で符号化されなければなりません。"
    },
    {
      "indent": 3,
      "text": "Either MD5 [15] or SHA-1 [17] SHOULD be used for message authentication codes (MACs). An implementation MAY provide MD5, whereas SHA-1 MUST be implemented.",
      "ja": "MD5 [15]またはSHA-1 [17]のいずれかは、メッセージ認証コード（MAC）のために使用されるべきです。 SHA-1を実装しなければならないのに対し、実装は、MD5を提供することができます。"
    },
    {
      "indent": 3,
      "text": "The length of the hash keys is determined by the selected hashing algorithm. This means, the configured hash key MUST NOT be shorter than the native key length for the currently configured algorithm.",
      "ja": "ハッシュキーの長さは、選択されたハッシュアルゴリズムによって決定されます。これは、構成されたハッシュキーは、現在設定されているアルゴリズムのネイティブキーの長さよりも短くてはなりません。"
    },
    {
      "indent": 0,
      "text": "11.4 Procedures for Senders and Receivers",
      "section_title": true,
      "ja": "送信側と受信側のための11.4手続き"
    },
    {
      "indent": 3,
      "text": "The algorithms that MUST be provided by implementations are AES and SHA-1.",
      "ja": "実装によって提供されなければならないアルゴリズムは、AES及びSHA-1です。"
    },
    {
      "indent": 3,
      "text": "See Section 12 for a specification of notations for Base64-strings.",
      "ja": "Base64で文字列の表記の仕様については、セクション12を参照してください。"
    },
    {
      "indent": 3,
      "text": "A sender MUST apply the following operations to a message that is to be sent:",
      "ja": "送信者は、送信されるメッセージに次の操作を適用する必要があります。"
    },
    {
      "indent": 3,
      "text": "1. If encryption is enabled, the message MUST be encrypted using the configured algorithm and the configured encryption key. Padding (adding extra-characters) for block-ciphers MUST be applied as specified in Section 11.2. If encryption is not enabled, the message is left unchanged.",
      "ja": "暗号化が有効になっている場合は1、メッセージが設定されたアルゴリズムと構成された暗号鍵を用いて暗号化されなければなりません。第11.2節で指定されるように、ブロック暗号のためのパディング（余分な文字を追加すること）を適用しなければなりません。暗号化が有効でない場合、メッセージは変更されません。"
    },
    {
      "indent": 3,
      "text": "2. Subsequently, a message authentication code (MAC) for the (encrypted) message MUST be calculated using the configured HMAC-algorithm and the configured hash key.",
      "ja": "2.続いて、（暗号化された）メッセージのメッセージ認証コード（MAC）が構成HMACアルゴリズムおよび構成ハッシュキーを使用して計算しなければなりません。"
    },
    {
      "indent": 3,
      "text": "3. The MAC MUST then be converted to Base64 encoding, resulting in 16 Base64-characters as specified in Section 11.3.",
      "ja": "3. MACは、その後、セクション11.3で指定されるように16 Base64で文字をもたらす、Base64エンコードに変換されなければなりません。"
    },
    {
      "indent": 3,
      "text": "4. At last, the sender MUST construct the final message by placing the (encrypted) message after the base64-encoded MAC and a CRLF. The ABNF definition for the final message is as follows:",
      "ja": "4.は、最後に、送信者は、base64エンコードされたMACとCRLF後（暗号化された）メッセージを配置することにより、最終的なメッセージを作成しなければなりません。次のように最後のメッセージのためのABNF定義は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "final_msg = MsgDigest CRLF encr_msg",
      "ja": "final_msg = MsgDigest CRLF encr_msg"
    },
    {
      "indent": 6,
      "text": "MsgDigest = base64",
      "ja": "MsgDigest = BASE64"
    },
    {
      "indent": 6,
      "text": "encr_msg = *OCTET",
      "ja": "encr_msg = * OCTET"
    },
    {
      "indent": 3,
      "text": "A receiver MUST apply the following operations to a message that it has received:",
      "ja": "受信機は、受信したメッセージに次の操作を適用する必要があります。"
    },
    {
      "indent": 3,
      "text": "1. Separate the base64-encoded MAC from the (encrypted) message and decode the MAC.",
      "ja": "1.（暗号化された）メッセージからbase64でエンコードされたMACを分離し、MACを復号します。"
    },
    {
      "indent": 3,
      "text": "2. Re-calculate the MAC for the message using the configured HMAC-algorithm and the configured hash key.",
      "ja": "2.構成さHMACアルゴリズムおよび構成ハッシュキーを使用して、メッセージのMACを再計算します。"
    },
    {
      "indent": 3,
      "text": "3. Compare the original MAC with re-calculated MAC. If they differ, the message MUST be discarded without further processing.",
      "ja": "3.再計算MACで元MACを比較してください。それらが異なる場合、メッセージはさらに処理せずに捨てなければなりません。"
    },
    {
      "indent": 3,
      "text": "4. If encryption is enabled, the message MUST be decrypted using the configured algorithm and the configured encryption key. Trailing octets with a value of 0 MUST be deleted. If the message does not start with the string \"mbus/\" the message MUST be discarded without further processing.",
      "ja": "暗号化が有効になっている場合4.メッセージが設定されたアルゴリズムと設定された暗号鍵を使用して復号化されなければなりません。 0の値を持つ後続のオクテットは削除する必要があります。メッセージは文字列で起動しない場合は、「MBUS /」のメッセージがさらに処理せずに捨てなければなりません。"
    },
    {
      "indent": 0,
      "text": "12. Mbus Configuration",
      "section_title": true,
      "ja": "12. Mバスの設定"
    },
    {
      "indent": 3,
      "text": "An implementation MUST be configurable by the following parameters:",
      "ja": "実装は、次のパラメータによって構成可能でなければなりません。"
    },
    {
      "indent": 6,
      "text": "Configuration version",
      "ja": "コンフィギュレーション・バージョン"
    },
    {
      "indent": 9,
      "text": "The version number of the given configuration entity. Version numbers allow implementations to check if they can process the entries of a given configuration entity. Version number are integer values. The version number for the version specified here is 1.",
      "ja": "所与の構成エンティティのバージョン番号。バージョン番号は、彼らが与えられた構成エンティティのエントリを処理できるかどう実装がチェックすることができます。バージョン番号は整数値です。ここで指定したバージョンのバージョン番号は1です。"
    },
    {
      "indent": 6,
      "text": "Encryption key",
      "ja": "暗号化キー"
    },
    {
      "indent": 9,
      "text": "The secret key used for message encryption.",
      "ja": "メッセージの暗号化に使用する秘密鍵。"
    },
    {
      "indent": 6,
      "text": "Hash key",
      "ja": "ハッシュキー"
    },
    {
      "indent": 9,
      "text": "The hash key used for message authentication.",
      "ja": "メッセージ認証に使用するハッシュキー。"
    },
    {
      "indent": 6,
      "text": "Scope",
      "ja": "範囲"
    },
    {
      "indent": 9,
      "text": "The multicast scope to be used for sent messages.",
      "ja": "送信されたメッセージに使用するマルチキャストスコープ。"
    },
    {
      "indent": 3,
      "text": "The above parameters are mandatory and MUST be present in every Mbus configuration entity.",
      "ja": "上記パラメータは必須であり、すべてのMBus構成エンティティに存在していなければなりません。"
    },
    {
      "indent": 3,
      "text": "The following parameters are optional. When they are present they MUST be honored. When they are not present implementations SHOULD fall back to the predefined default values (as defined in Transport (Section 6)):",
      "ja": "次のパラメータはオプションです。それらが存在する場合、それらは尊重されなければなりません。そうでない場合（トランスポート（第6節）で定義されるように）本実装では、事前定義されたデフォルト値にフォールバックする必要があります。"
    },
    {
      "indent": 6,
      "text": "Address",
      "ja": "住所"
    },
    {
      "indent": 9,
      "text": "The non-standard multicast address to use for message transport.",
      "ja": "非標準のマルチキャストアドレスは、メッセージトランスポートに使用します。"
    },
    {
      "indent": 6,
      "text": "Use of Broadcast",
      "ja": "ブロードキャストの使用"
    },
    {
      "indent": 9,
      "text": "It can be specified whether broadcast should be used. If broadcast has been configured implementations SHOULD use the network broadcast address (as specified in Section 6.1.3) instead of the standard multicast address.",
      "ja": "ブロードキャストを使用するかどうかを指定することができます。 （セクション6.1.3で指定されるように）、ブロードキャスト構成されている実装では、代わりに標準のマルチキャストアドレスのネットワークのブロードキャストアドレスを使用する必要がある場合。"
    },
    {
      "indent": 6,
      "text": "Port Number",
      "ja": "ポート番号"
    },
    {
      "indent": 9,
      "text": "The non-standard UDP port number to use for message transport.",
      "ja": "非標準のUDPポート番号は、メッセージトランスポートに使用します。"
    },
    {
      "indent": 3,
      "text": "Two distinct facilities for parameter storage are considered: For Unix-like systems a per-user configuration file SHOULD be used and for Windows-95/98/NT/2000/XP systems a set of registry entries is defined that SHOULD be used. For other systems it is RECOMMENDED that the file-based configuration mechanism is used.",
      "ja": "パラメータ記憶のための二つの異なる施設が考慮される：Unixライクなシステムでは、ユーザごとの設定ファイルが使用されるべきであるとWindows 95/98 / NT / 2000 / XPシステムのレジストリエントリのセットが使用されるべきであると定義されます。他のシステムでは、ファイルベースの設定メカニズムを使用することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "The syntax of the values for the respective parameter entries remains the same for both configuration facilities. The following defines a set of ABNF (see RFC 2234 [13]) productions that are later re-used for the definitions for the configuration file syntax and registry entries:",
      "ja": "それぞれのパラメータ項目の値の構文は、両方のコンフィギュレーション・施設の同じまま。以下はABNFのセットを定義します（RFC 2234 [13]）は、制作後、再使用される構成ファイルの構文とレジストリエントリの定義について："
    },
    {
      "indent": 3,
      "text": "algo-id = \"NOENCR\" / \"AES\" / \"DES\" / \"3DES\" / \"IDEA\" / \"HMAC-MD5-96\" / \"HMAC-SHA1-96\"",
      "ja": "ALGO-ID = \"NOENCR\" / \"AES\" / \"DES\" / \"3DES\" / \"IDEA\" / \"HMAC-MD5-96\" / \"HMAC-SHA1-96\""
    },
    {
      "indent": 3,
      "text": "scope = \"HOSTLOCAL\" / \"LINKLOCAL\"",
      "ja": "スコープ= \"ローカルホスト\" / \"LINK LOCAL\""
    },
    {
      "indent": 3,
      "text": "key = base64",
      "ja": "キー= BASE64"
    },
    {
      "indent": 3,
      "text": "version_number = 1*10DIGIT",
      "ja": "version_numberは= 1 * 10DIGIT"
    },
    {
      "indent": 3,
      "text": "key_value = \"(\" algo-id \",\" key \")\"",
      "ja": "KEY_VALUE = \"（\" ALGO-ID \"\" キー \"）\""
    },
    {
      "indent": 3,
      "text": "address = IPv4address / IPv6address / \"BROADCAST\"",
      "ja": "アドレス= IPv4Addressを/ IPv6address / \"BROADCAST\""
    },
    {
      "indent": 3,
      "text": "port = 1*5DIGIT ; values from 0 through 65535",
      "ja": "ポート= 1 * 5DIGIT。 0から65535までの値"
    },
    {
      "indent": 3,
      "text": "Given the definition above, a key entry MUST be specified using this notation:",
      "ja": "上記の定義を考えると、キー入力は、この表記法を使用して指定する必要があります。"
    },
    {
      "indent": 6,
      "text": "\"(\"algo-id\",\"base64string\")\"",
      "ja": "\"（\" サムシング-ID \"\" base64string \"）\""
    },
    {
      "indent": 3,
      "text": "algo-id is one of the character strings specified above. For algo-id==\"NOENCR\" the other fields are ignored. The delimiting commas MUST always be present though.",
      "ja": "ALGO-IDは、上記の指定された文字列の一つです。 ALGO-idには==「NOENCR」他のフィールドは無視されます。区切りのカンマは常にかかわらず、存在しなければなりません。"
    },
    {
      "indent": 3,
      "text": "A Base64 string consists of the characters defined in the Base64 char-set (see RFC 1521 [7]) including all possible padding characters, i.e., the length of a Base64-string is always a multiple of 4.",
      "ja": "Base64文字列は、すべての可能なパディング文字を含むのBase64文字セット（RFC 1521参照[7]）で定義された文字で構成、即ち、Base64で文字列の長さが常に4の倍数です。"
    },
    {
      "indent": 3,
      "text": "The scope parameter is used to configure an IP-Multicast scope and may be set to either \"HOSTLOCAL\" or \"LINKLOCAL\". Implementations SHOULD choose an appropriate IP-Multicast scope depending on the value of this parameter and construct an effective IP-Address considering the specifications of Section 6.1.",
      "ja": "スコープパラメータは、IPマルチキャスト範囲を設定するために使用され、「HOSTLOCAL」または「LINKLOCAL」のいずれかに設定することができます。実装は、このパラメータの値に応じて、適切なIPマルチキャストスコープを選択し、セクション6.1の仕様を考慮し効果的なIPアドレスを構築すべきです。"
    },
    {
      "indent": 3,
      "text": "The use of broadcast is configured by providing the value \"BROADCAST\" for the address field. If broadcast has been configured, implementations SHOULD use the network broadcast address for the used IP version instead of the standard multicast address.",
      "ja": "ブロードキャストの使用は、アドレスフィールドの値が「BROADCAST」を提供して構成されています。ブロードキャストが設定されている場合、実装は、代わりに標準のマルチキャストアドレスの使用IPバージョンのためのネットワークブロードキャストアドレスを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "The version_number parameter specifies a version number for the used configuration entity.",
      "ja": "version_numberはパラメータが使用される構成エンティティのバージョン番号を指定します。"
    },
    {
      "indent": 0,
      "text": "12.1 File based parameter storage",
      "section_title": true,
      "ja": "12.1ファイルベースのパラメータ記憶"
    },
    {
      "indent": 3,
      "text": "The file name for an Mbus configuration file is \".mbus\" in the user's home-directory. If an environment variable called MBUS is defined implementations SHOULD interpret the value of this variable as a fully qualified file name that is to be used for the configuration file. Implementations MUST ensure that this file has appropriate file permissions that prevent other users to read or write it. The file MUST exist before a conference is initiated. Its contents MUST be UTF-8 encoded and MUST comply to the following syntax definition:",
      "ja": "Mバス・コンフィギュレーション・ファイルのファイル名は、ユーザのホームディレクトリにある「.mbus」です。 MBUSという環境変数が定義されている場合の実装では、構成ファイルに使用する完全修飾ファイル名として、この変数の値を解釈すべきです。実装は、このファイルには、それを読み書きするために、他のユーザーを防ぐため、適切なファイルのアクセス権を持っていることを確認しなければなりません。会議が開始される前に、ファイルが存在しなければなりません。その内容はUTF-8エンコードされている必要があり、次の構文定義に準拠しなければなりません。"
    },
    {
      "indent": 6,
      "text": "mbus-file = mbus-topic LF *(entry LF)",
      "ja": "MBUS-ファイル= MBUS-トピックLF *（エントリーLF）"
    },
    {
      "indent": 6,
      "text": "mbus-topic = \"[MBUS]\"",
      "ja": "MBUS-トピック= \"[MBUS]\""
    },
    {
      "indent": 6,
      "text": "entry = 1*(version_info / hashkey_info / encryptionkey_info / scope_info / port_info / address_info)",
      "ja": "エントリ= 1 *（version_info / hashkey_info / encryptionkey_info / scope_info / port_info / address_info）"
    },
    {
      "indent": 6,
      "text": "version_info = \"CONFIG_VERSION=\" version_number",
      "ja": "= \"CONFIG_VERSION =\" version_numberはversion_info"
    },
    {
      "indent": 6,
      "text": "hashkey_info = \"HASHKEY=\" key_value",
      "ja": "hashkey_info = \"ハッシュキー=\" KEY_VALUE"
    },
    {
      "indent": 6,
      "text": "encrkey_info = \"ENCRYPTIONKEY=\" key_value",
      "ja": "encrkey_info = \"ENCRYPTIONKEY =\" KEY_VALUE"
    },
    {
      "indent": 6,
      "text": "scope_info = \"SCOPE=\" scope",
      "ja": "scope_info = \"SCOPE =\" スコープ"
    },
    {
      "indent": 6,
      "text": "port_info = \"PORT=\" port",
      "ja": "port_info = \"PORT =\" ポート"
    },
    {
      "indent": 6,
      "text": "address_info = \"ADDRESS=\" address",
      "ja": "address_info = \"ADDRESS =\" アドレス"
    },
    {
      "indent": 3,
      "text": "The following entries are defined: CONFIG_VERSION, HASHKEY, ENCRYPTIONKEY, SCOPE, PORT, ADDRESS.",
      "ja": "次のエントリが定義されていますCONFIG_VERSION、ハッシュキー、ENCRYPTIONKEY、SCOPE、PORT、ADDRESS。"
    },
    {
      "indent": 3,
      "text": "The entries CONFIG_VERSION, HASHKEY and ENCRYPTIONKEY are mandatory, they MUST be present in every Mbus configuration file. The order of entries is not significant.",
      "ja": "エントリーCONFIG_VERSION、ハッシュキーとENCRYPTIONKEYは、彼らがすべてのMバス・コンフィギュレーション・ファイル内に存在しなければならない、必須です。エントリの順序は重要ではありません。"
    },
    {
      "indent": 3,
      "text": "An example for an Mbus configuration file:",
      "ja": "Mバス・コンフィギュレーション・ファイルの例："
    },
    {
      "indent": 6,
      "text": "[MBUS] CONFIG_VERSION=1 HASHKEY=(HMAC-MD5-96,MTIzMTU2MTg5MTEy) ENCRYPTIONKEY=(DES,MTIzMTU2MQ==) SCOPE=HOSTLOCAL ADDRESS=224.255.222.239 PORT=47000",
      "ja": "【MBUS] CONFIG_VERSION = 1つのハッシュキー=（HMAC-MD5-96、MTIzMTU2MTg5MTEy）ENCRYPTIONKEY =（DES、MTIzMTU2MQ ==）SCOPE = HOSTLOCALアドレス= 224.255.222.239 PORT = 47000"
    },
    {
      "indent": 0,
      "text": "12.2 Registry-based parameter storage",
      "section_title": true,
      "ja": "12.2レジストリベースのパラメータ記憶"
    },
    {
      "indent": 3,
      "text": "For systems lacking the concept of a user's home-directory as a place for configuration files the suggested database for configuration settings (e.g., the Windows9x, Windows NT, Windows 2000, Windows XP registry) SHOULD be used. The hierarchy for Mbus related registry entries is as follows:",
      "ja": "コンフィギュレーションのための場所は、構成設定（例えば、Windows9xの、は、Windows NT、Windows 2000、Windows XPのレジストリ）のために提案されたデータベースをファイルとしてユーザのホームディレクトリの概念を欠いたシステムに使用する必要があります。次のようにMバス関連のレジストリエントリの階層は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "HKEY_CURRENT_USER\\Software\\Mbus",
      "ja": "HKEY_CURRENT_USER \\ SOFTWARE \\ Mバス"
    },
    {
      "indent": 3,
      "text": "The entries in this hierarchy section are:",
      "ja": "この階層セクションのエントリは、次のとおりです。"
    },
    {
      "indent": 6,
      "text": "+---------------+--------+----------------+\n|Name           | Type   | ABNF production|\n+---------------+--------+----------------|\n|CONFIG_VERSION | DWORD  | version_number |\n|HASHKEY        | String | key_value      |\n|ENCRYPTIONKEY  | String | key_value      |\n|SCOPE          | String | scope          |\n|ADDRESS        | String | address        |\n|PORT           | DWORD  | port           |\n+---------------+--------+----------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "The same syntax for key values as for the file based configuration facility MUST be used.",
      "ja": "ファイルベースの設定のための施設として、キー値のために同じ構文を使用しなければなりません。"
    },
    {
      "indent": 0,
      "text": "13. Security Considerations",
      "section_title": true,
      "ja": "13.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "The Mbus security mechanisms are specified in Section 11.1.",
      "ja": "Mバスのセキュリティメカニズムは、セクション11.1で指定されています。"
    },
    {
      "indent": 3,
      "text": "It should be noted that the Mbus transport specification defines a mandatory baseline set of algorithms that have to be supported by implementations. This baseline set is intended to provide reasonable security by mandating algorithms and key lengths that are considered to be cryptographically strong enough at the time of writing.",
      "ja": "Mバス輸送仕様が実装によってサポートされなければならないアルゴリズムの必須の基準セットを定義することに留意すべきです。このベースラインセットは、書き込み時に十分な暗号学的に強いと考えられているアルゴリズムとキーの長さを義務付けることにより、合理的なセキュリティを提供することを意図しています。"
    },
    {
      "indent": 3,
      "text": "However, in order to allow for efficiency it is allowable to use cryptographically weaker algorithms, for example HMAC-MD5 instead of",
      "ja": "しかし、暗号弱いアルゴリズムを使用することが許容される効率を可能にするため、例えばHMAC-MD5の代わりに"
    },
    {
      "indent": 3,
      "text": "HMAC-SHA1. Furthermore, encryption can be turned off completely if privacy is provided by other means or not considered important for a certain application.",
      "ja": "HMAC-SHA1。プライバシーが他の手段によって提供されるか、または特定のアプリケーションのために重要であると考えられていない場合はさらに、暗号化は完全にオフにすることができます。"
    },
    {
      "indent": 3,
      "text": "Users of the Mbus should therefore be aware of the selected security configuration and should check if it meets the security demands for a given application. Since every implementation MUST provide the cryptographically strong algorithm it should always be possible to configure an Mbus in a way that secure communication with authentication and privacy is ensured.",
      "ja": "Mバスのしたがって、ユーザーは選択されたセキュリティ設定に注意する必要があり、それは特定のアプリケーションのセキュリティ要求を満たしているかどうかを確認する必要があります。すべての実装は、暗号強度の高いアルゴリズムを提供しなければならないので、常に認証とプライバシーとの安全な通信が確保されるような方法でMバスを構成することが可能でなければなりません。"
    },
    {
      "indent": 3,
      "text": "In any way, application developers should be aware of incorrect IP implementations that do not conform to RFC 1122 [2] and do send datagrams with TTL values of zero, resulting in Mbus messages sent to the local network link although a user might have selected host local scope in the Mbus configuration. When using administratively scoped multicast, users cannot always assume the presence of correctly configured boundary routers. In these cases the use of encryption SHOULD be considered if privacy is desired.",
      "ja": "どのような方法では、アプリケーション開発者は、RFC 1122に準拠していない不正なIP実装に注意する必要があります[2]と、ユーザがホストを選択しているかもしれませんが、ローカルネットワークリンクに送られたのMbusメッセージで、その結果、ゼロのTTL値でデータグラムを送信しますMバス構成でローカルスコープ。管理スコープマルチキャストを使用する場合は、ユーザーが常に正しく設定された境界ルータの存在を仮定することはできません。プライバシーが望まれる場合、これらのケースでは、暗号化の使用が考慮されるべきです。"
    },
    {
      "indent": 0,
      "text": "14. IANA Considerations",
      "section_title": true,
      "ja": "14. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "The IANA has assigned a scope-relative multicast address with an offset of 8 for Mbus/IPv4. The IPv6 permanent multicast address is FF0X:0:0:0:0:0:0:300.",
      "ja": "IANAは、Mバス/ IPv4のために8のオフセットを持つスコープ相対マルチキャストアドレスが割り当てられています。 0：0：0：0：0：0：300 IPv6の永久マルチキャストアドレスはFF0Xです。"
    },
    {
      "indent": 3,
      "text": "The registered Mbus UDP port number is 47000.",
      "ja": "登録されたMバスUDPポート番号は47000です。"
    },
    {
      "indent": 0,
      "text": "15. References",
      "section_title": true,
      "ja": "15.参考文献"
    },
    {
      "indent": 3,
      "text": "[1] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[1]ブラドナーのは、S.は、BCP 14、RFC 2119、1997年3月の \"RFCsにおける使用のためのレベルを示すために\"。"
    },
    {
      "indent": 3,
      "text": "[2] Braden, R., \"Requirements for Internet Hosts -- Communication Layers\", STD 3, RFC 1122, October 1989.",
      "ja": "[2]ブレーデン、R.、 \"インターネットホストのための要件 - 通信層\"、STD 3、RFC 1122、1989年10月。"
    },
    {
      "indent": 3,
      "text": "[3] Hinden, R. and S. Deering, \"IP Version 6 Addressing Architecture\", RFC 2373, July 1998.",
      "ja": "[3] HindenとR.とS.デアリング、 \"IPバージョン6アドレッシング体系\"、RFC 2373、1998年7月。"
    },
    {
      "indent": 3,
      "text": "[4] Hinden, R. and S. Deering, \"IPv6 Multicast Address Assignments\", RFC 2375, July 1998.",
      "ja": "[4] HindenとR.とS.デアリング、 \"IPv6マルチキャストアドレスの割り当て\"、RFC 2375、1998年7月。"
    },
    {
      "indent": 3,
      "text": "[5] Krawczyk, H., Bellare, M. and R. Canetti, \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, February 1997.",
      "ja": "[5] Krawczyk、H.、ベラー、M。およびR.カネッティ、 \"HMAC：メッセージ認証のための鍵付きハッシュ化\"、RFC 2104、1997年2月。"
    },
    {
      "indent": 3,
      "text": "[6] Resnick, P., Editor, \"Internet Message Format\", RFC 2822, April 2001.",
      "ja": "[6]レズニック、P.、エディタ、 \"インターネットメッセージ形式\"、RFC 2822、2001年4月。"
    },
    {
      "indent": 3,
      "text": "[7] Borenstein, N. and N. Freed, \"MIME (Multipurpose Internet Mail Extensions) Part One: Mechanisms for Specifying and Describing the Format of Internet Message Bodies\", RFC 1521, September 1993.",
      "ja": "[7] Borenstein、N.とN.フリードを、「MIME（多目的インターネットメール拡張）第一部：インターネットメッセージ本体の形式を指定し、説明するためのメカニズム」、RFC 1521、1993年9月。"
    },
    {
      "indent": 3,
      "text": "[8] Schulzrinne, H., Casner, S., Frederick, R. and V. Jacobsen, \"RTP: A Transport Protocol for Real-Time Applications\", RFC 1889, January 1996.",
      "ja": "[8] Schulzrinneと、H.、Casner、S.、フレデリック、R.とV.ヤコブセン、 \"RTP：リアルタイムアプリケーションのためのトランスポートプロトコル\"、RFC 1889、1996年1月。"
    },
    {
      "indent": 3,
      "text": "[9] Handley, M., Schulzrinne, H., Schooler, E. and J. Rosenberg, \"SIP: Session Initiation Protocol\", RFC 2543, March 1999.",
      "ja": "[9]ハンドレー、M.、Schulzrinneと、H.、学生はE.およびJ.ローゼンバーグ、 \"SIP：セッション開始プロトコル\"、RFC 2543、1999年3月。"
    },
    {
      "indent": 3,
      "text": "[10] Handley, M. and V. Jacobsen, \"SDP: Session Description Protocol\", RFC 2327, April 1998.",
      "ja": "[10]ハンドレー、M.およびV.ヤコブセン、 \"SDP：セッション記述プロトコル\"、RFC 2327、1998年4月。"
    },
    {
      "indent": 3,
      "text": "[11] Meyer, D., \"Administratively Scoped IP Multicast\", BCP 23, RFC 2365, July 1998.",
      "ja": "[11]マイヤー、D.、 \"管理スコープのIPマルチキャスト\"、BCP 23、RFC 2365、1998年7月。"
    },
    {
      "indent": 3,
      "text": "[12] Balenson, D., \"Privacy Enhancement for Internet Electronic Mail: Part III: Algorithms, Modes, and Identifiers\", RFC 1423, February 1993.",
      "ja": "[12] Balenson、D.、 \"インターネット電子メールのためのプライバシー増進：パートIII：アルゴリズム、モード、および識別子\"、RFC 1423、1993年2月。"
    },
    {
      "indent": 3,
      "text": "[13] Crocker, D. and P. Overell, \"Augmented BNF for Syntax Specifications: ABNF\", RFC 2234, November 1997.",
      "ja": "[13]クロッカー、D.、およびP. Overell、 \"構文仕様のための増大しているBNF：ABNF\"、RFC 2234、1997年11月。"
    },
    {
      "indent": 3,
      "text": "[14] Myers, J., \"SMTP Service Extension for Authentication\", RFC 2554, March 1999.",
      "ja": "[14]マイヤーズ、J.、 \"認証のためのSMTPサービス拡張\"、RFC 2554、1999年3月。"
    },
    {
      "indent": 3,
      "text": "[15] Rivest, R., \"The MD5 Message-Digest Algorithm\", RFC 1321, April 1992.",
      "ja": "[15]リベスト、R.、 \"MD5メッセージダイジェストアルゴリズム\"、RFC 1321、1992年4月。"
    },
    {
      "indent": 3,
      "text": "[16] U.S. DEPARTMENT OF COMMERCE/National Institute of Standards and Technology, \"Data Encryption Standard (DES)\", FIPS PUB 46-3, Category Computer Security, Subcategory Cryptography, October 1999.",
      "ja": "標準の[16]米国商務省/国立技術研究所、「データ暗号化規格（DES）」、FIPS PUBの46-3、カテゴリーコンピュータセキュリティ、サブカテゴリ暗号化、1999年10月。"
    },
    {
      "indent": 3,
      "text": "[17] U.S. DEPARTMENT OF COMMERCE/National Institute of Standards and Technology, \"Secure Hash Standard\", FIPS PUB 180-1, April 1995.",
      "ja": "[17]米国商務省/国立標準技術研究所が、1995年4月、FIPS PUB 180-1の「ハッシュ標準セキュア」。"
    },
    {
      "indent": 3,
      "text": "[18] Daemen, J.D. and V.R. Rijmen, \"AES Proposal: Rijndael\", March 1999.",
      "ja": "[18] Daemen氏、J.D.及びV.R. Rijmen両氏、 \"AES提案：ラインダール\"、1999年3月。"
    },
    {
      "indent": 3,
      "text": "[19] IANA, \"Internet Multicast Addresses\", URL http://www.iana.org/assignments/multicast-addresses, May 2001.",
      "ja": "[19] IANA、 \"インターネットマルチキャストアドレス\"、URL http://www.iana.org/assignments/multicast-addresses、2001年5月。"
    },
    {
      "indent": 3,
      "text": "[20] Schneier, B., \"Applied Cryptography\", Edition 2, Publisher John Wiley & Sons, Inc., status: non-normative, 1996.",
      "ja": "[20]シュナイアー、B.、 \"応用暗号\"、第2版、出版社John Wiley＆Sons社、状態：非規範、1996。"
    },
    {
      "indent": 0,
      "text": "Appendix A. About References",
      "ja": "参考資料については、付録A."
    },
    {
      "indent": 3,
      "text": "Please note that the list of references contains normative as well as non-normative references. Each Non-normative references is marked as \"status: non-normative\". All unmarked references are normative.",
      "ja": "参考文献のリストは、規範的ならびに非規範的な参照が含まれていることに注意してください。各非引用規格は、「：非規範的状態」としてマークされています。すべてのマークされていない参照は規範的です。"
    },
    {
      "indent": 0,
      "text": "Appendix B. Limitations and Future Work",
      "ja": "付録B.制限と今後の課題"
    },
    {
      "indent": 3,
      "text": "The Mbus is a light-weight local coordination mechanism and deliberately not designed for larger scope coordination. It is expected to be used on a single node or -- at most -- on a single network link.",
      "ja": "Mバスは、軽量ローカル調整メカニズムであり、意図的に、より大きな範囲の調整のために設計されていません。せいぜい -   - 単一のノードまたは上で使用することが期待されている単一のネットワークリンク上。"
    },
    {
      "indent": 3,
      "text": "Therefore the Mbus protocol does not contain features that would be required to qualify it for the use over the global Internet:",
      "ja": "そのためのMbusプロトコルは、グローバルなインターネット上での使用のためにそれを修飾するために必要となる機能が含まれていません。"
    },
    {
      "indent": 6,
      "text": "There are no mechanisms to provide congestion control. The issue of congestion control is a general problem for multicast protocols. The Mbus allows for un-acknowledged messages that are sent unreliably, for example as event notifications, from one entity to another. Since negative acknowledgements are not defined there is no way the sender could realize that it is flooding another entity or congesting a low bandwidth network segment.",
      "ja": "輻輳制御を提供するために、何のメカニズムはありません。輻輳制御の問題は、マルチキャストプロトコルのための一般的な問題です。 Mバスは別のエンティティから、イベント通知として例えば、当てにならずに送信され、非を認めたメッセージが可能になります。否定応答が定義されていないので、送信者が、それは別のエンティティをフラッディングまたは低帯域幅のネットワークセグメントに混雑していることを実感できた方法はありません。"
    },
    {
      "indent": 6,
      "text": "The reliability mechanism, i.e., the retransmission timers, are designed to provide effective, responsive message transport on local links but are not suited to cope with larger delays that could be introduced from router queues etc.",
      "ja": "信頼性のメカニズム、すなわち、再送タイマー、ローカルリンク上の効果、応答メッセージの輸送を提供するように設計されているが、その他のルータキューから導入することができ、より大きな遅延に対処するためには適していません"
    },
    {
      "indent": 3,
      "text": "Some experiments are currently underway to test the applicability of bridges between different distributed Mbus domains without changing the basic protocol semantics. Since the use of such bridges should be orthogonal to the basic Mbus protocol definitions and since these experiments are still work in progress there is no mention of this concept in this specification.",
      "ja": "いくつかの実験は、現在、基本的なプロトコルのセマンティクスを変更することなく、異なる分散型のMbusドメイン間のブリッジの適用性を検証するために進行中です。そのようなブリッジを使用すると、基本的なMバスプロトコルの定義に直交すべきであり、これらの実験はまだ進行中の作業されているので、この仕様では、この概念の言及はありませんので。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Joerg Ott TZI, Universitaet Bremen Bibliothekstr. 1 Bremen 28359 Germany",
      "ja": "イェルク・オットTCI、UniversitaetブレーメンBibliothekstr。 1 28359ブレーメンドイツ"
    },
    {
      "indent": 3,
      "text": "Phone: +49.421.201-7028 Fax: +49.421.218-7000 EMail: jo@tzi.uni-bremen.de",
      "ja": "電話：+ 49.421.201-7028ファックス：+ 49.421.218-7000 Eメール：jo@tzi.uni-bremen.de"
    },
    {
      "indent": 3,
      "text": "Colin Perkins USC Information Sciences Institute 3811 N. Fairfax Drive #200 Arlington VA 22203 USA",
      "ja": "コリン・パーキンスUSC情報科学研究所3811 N.フェアファックスドライブ＃200アーリントンVA 22203 USA"
    },
    {
      "indent": 3,
      "text": "EMail: csp@isi.edu",
      "ja": "メールアドレス：csp@isi.edu"
    },
    {
      "indent": 3,
      "text": "Dirk Kutscher TZI, Universitaet Bremen Bibliothekstr. 1 Bremen 28359 Germany",
      "ja": "ディルク御者TZI、ブレーメンBibliothekstrの大学。 1 28359ブレーメンドイツ"
    },
    {
      "indent": 3,
      "text": "Phone: +49.421.218-7595 Fax: +49.421.218-7000 EMail: dku@tzi.uni-bremen.de",
      "ja": "電話：+ 49.421.218-7595ファックス：+ 49.421.218-7000 Eメール：dku@tzi.uni-bremen.de"
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2002). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2002）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.",
      "ja": "この文書とその翻訳は、コピーして他の人に提供し、それ以外についてはコメントまたは派生物は、いかなる種類の制限もなく、全体的にまたは部分的に、準備コピーし、公表して配布することができることを説明したり、その実装を支援することができます、上記の著作権表示とこの段落は、すべてのそのようなコピーや派生物に含まれていることを条件とします。しかし、この文書自体は著作権のための手順はで定義されている場合には、インターネット標準を開発するために必要なものを除き、インターネットソサエティもしくは他のインターネット関連団体に著作権情報や参照を取り除くなど、どのような方法で変更されないかもしれませんインターネット標準化プロセスが続く、または英語以外の言語に翻訳するために、必要に応じなければなりません。"
    },
    {
      "indent": 3,
      "text": "The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.",
      "ja": "上記の制限は永久で、インターネット学会やその後継者や譲渡者によって取り消されることはありません。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein is provided on an \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書とここに含まれている情報は、基礎とインターネットソサエティおよびインターネットエンジニアリングタスクフォースはすべての保証を否認し、明示または黙示、その情報の利用がない任意の保証を含むがこれらに限定されない「として、」上に設けられています特定の目的への権利または商品性または適合性の黙示の保証を侵害します。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFC Editor機能のための基金は現在、インターネット協会によって提供されます。"
    }
  ]
}