{
  "title": {
    "text": "RFC 3079 - Deriving Keys for use with Microsoft Point-to-Point Encryption (MPPE)",
    "ja": "RFC 3079 - Microsoft Point-to-Point暗号化（MPPE）を使用するための鍵の導出"
  },
  "number": 3079,
  "created_at": "2019-10-22 14:49:53.738792+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                            G. Zorn\nRequest for Comments: 3079                                 cisco Systems\nCategory: Informational                                       March 2001",
      "raw": true
    },
    {
      "indent": 1,
      "text": "Deriving Keys for use with Microsoft Point-to-Point Encryption (MPPE)",
      "ja": "Microsoft Point-to-Point暗号化（MPPE）を使用するための鍵の導出"
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "ja": "このメモの位置付け"
    },
    {
      "indent": 3,
      "text": "This memo provides information for the Internet community. It does not specify an Internet standard of any kind. Distribution of this memo is unlimited.",
      "ja": "このメモはインターネットコミュニティのための情報を提供します。それはどんな種類のインターネット標準を指定しません。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2001). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2001）。全著作権所有。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "The Point-to-Point Protocol (PPP) provides a standard method for transporting multi-protocol datagrams over point-to-point links.",
      "ja": "ポイントツーポイントプロトコル（PPP）は、ポイントツーポイントリンク上でマルチプロトコルデータグラムを輸送するための標準的な方法を提供します。"
    },
    {
      "indent": 3,
      "text": "The PPP Compression Control Protocol provides a method to negotiate and utilize compression protocols over PPP encapsulated links.",
      "ja": "PPP圧縮制御プロトコルはPPPカプセル化されたリンクの上に圧縮プロトコルを交渉して利用する方法を提供します。"
    },
    {
      "indent": 3,
      "text": "Microsoft Point to Point Encryption (MPPE) is a means of representing PPP packets in an encrypted form. MPPE uses the RSA RC4 algorithm to provide data confidentiality. The length of the session key to be used for initializing encryption tables can be negotiated. MPPE currently supports 40-bit, 56-bit and 128-bit session keys. MPPE session keys are changed frequently; the exact frequency depends upon the options negotiated, but may be every packet. MPPE is negotiated within option 18 in the Compression Control Protocol.",
      "ja": "暗号化（MPPE）をポイントするマイクロソフトポイントは、暗号化された形式でPPPパケットを表現する手段です。 MPPEは、データの機密性を提供するために、RSA RC4アルゴリズムを使用しています。暗号化テーブルを初期化するために使用されるセッションキーの長さを交渉することができます。 MPPEは、現在、40ビット、56ビットおよび128ビットのセッションキーをサポートします。 MPPEセッションキーは頻繁に変更されています。正確な周波数は、交渉したオプションによって異なりますが、すべてのパケットであってもよいです。 MPPEは、圧縮制御プロトコルでオプション18内に交渉されています。"
    },
    {
      "indent": 3,
      "text": "This document describes the method used to derive initial MPPE session keys from a variety of credential types. It is expected that this memo will be updated whenever Microsoft defines a new key derivation method for MPPE, since its primary purpose is to provide an open, easily accessible reference for third-parties wishing to interoperate with Microsoft products.",
      "ja": "この文書では、クレデンシャルタイプの様々な初期MPPEセッションキーを導出するために使用する方法について説明します。 MicrosoftがMPPEのための新しいキー導出方法を定義したときに、その主な目的は、マイクロソフト製品との相互運用を希望するサードパーティのオープン、容易にアクセス参照を提供するものであるため、このメモは、更新されることが期待されます。"
    },
    {
      "indent": 3,
      "text": "MPPE itself (including the protocol used to negotiate its use, the details of the encryption method used and the algorithm used to change session keys during a session) is described in RFC 3078.",
      "ja": "（その使用をネゴシエートするために使用されるプロトコル、使用される暗号化方法の詳細は、セッション中にセッションキーを変更するために使用されるアルゴリズムを含む）MPPE自体は、RFC 3078に記載されています。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Specification of Requirements ............................... 2\n2.  Deriving Session Keys from MS-CHAP Credentials .............. 2\n2.1.  Generating 40-bit Session Keys ............................ 3\n2.2.  Generating 56-bit Session Keys ............................ 3\n2.3.  Generating 128-bit Session Keys ........................... 4\n2.4.  Key Derivation Functions .................................. 5\n2.5.  Sample Key Derivations .................................... 6\n2.5.1.  Sample 40-bit Key Derivation ............................ 6\n2.5.2.  Sample 56-bit Key Derivation ............................ 6\n2.5.3.  Sample 128-bit Key Derivation ........................... 7\n3.  Deriving Session Keys from MS-CHAP-2 Credentials ............ 7\n3.1.  Generating 40-bit Session Keys ............................ 8\n3.2.  Generating 56-bit Session Keys ............................ 9\n3.3.  Generating 128-bit Session Keys ...........................10\n3.4.  Key Derivation Functions ..................................11\n3.5.  Sample Key Derivations ....................................13\n3.5.1.  Sample 40-bit Key Derivation ............................13\n3.5.2.  Sample 56-bit Key Derivation ............................14\n3.5.3.  Sample 128-bit Key Derivation ...........................15\n4.  Deriving MPPE Session Keys from TLS Session Keys ............16\n4.1.  Generating 40-bit Session Keys ............................16\n4.2.  Generating 56-bit Session Keys ............................17\n4.3.  Generating 128-bit Session Keys ...........................17\n5.  Security Considerations .....................................18\n5.1.  MS-CHAP Credentials .......................................18\n5.2.  EAP-TLS Credentials .......................................19\n6.  References ..................................................19\n7.  Acknowledgements ............................................20\n8.  Author's Address ............................................20\n9.  Full Copyright Statement ....................................21",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Specification of Requirements",
      "section_title": true,
      "ja": "要件の1仕様"
    },
    {
      "indent": 3,
      "text": "In this document, the key words \"MAY\", \"MUST, \"MUST NOT\", \"optional\", \"recommended\", \"SHOULD\", and \"SHOULD NOT\" are to be interpreted as described in [6].",
      "ja": "この文書に記載されている、キーワード \"MAY\"、「MUST、 \"MUST NOT\"、 \"オプション\"、 \"推奨\"、 \"SHOULD\"、および \"the\" は、[6]に記載のように解釈されるべきではありません。"
    },
    {
      "indent": 0,
      "text": "2. Deriving Session Keys from MS-CHAP Credentials",
      "section_title": true,
      "ja": "2. MS-CHAP資格情報からセッション鍵を導出"
    },
    {
      "indent": 3,
      "text": "The Microsoft Challenge-Handshake Authentication Protocol (MS-CHAP-1) [2] is a Microsoft-proprietary PPP [1] authentication protocol, providing the functionality to which LAN-based users are accustomed while integrating the encryption and hashing algorithms used on Windows networks.",
      "ja": "Microsoftチャレンジハンドシェイク認証プロトコル（MS-CHAP-1）[2]の暗号化を統合し、Windowsで使用されるアルゴリズムをハッシュしながらLANベースのユーザが慣れされる機能を提供する、マイクロソフト独自のPPP [1]認証プロトコルでありますネットワーク。"
    },
    {
      "indent": 3,
      "text": "The following sections detail the methods used to derive initial session keys (40-, 56- and 128-bit) from MS-CHAP-1 credentials.",
      "ja": "以下のセクションで詳細最初のセッションキーを導出するために使用される方法（40-、56ビットおよび128ビット）MS-CHAP-1クレデンシャルから。"
    },
    {
      "indent": 3,
      "text": "Implementation Note",
      "ja": "実装上の注意"
    },
    {
      "indent": 6,
      "text": "The initial session key in both directions is derived from the credentials of the peer that initiated the call and the challenge used (if any) is the challenge from the first authentication. This is true for both unilateral and bilateral authentication, as well as for each link in a multilink bundle. In the multi-chassis multilink case, implementations are responsible for ensuring that the correct keys are generated on all participating machines.",
      "ja": "両方向の最初のセッションキーがコールを開始し、使用されるチャレンジは、（もしあれば）最初の認証からのチャレンジであるピアの資格情報から導出されます。これは、両方の一方的かつ双方向認証のためだけでなく、マルチリンクバンドル内の各リンクにも当てはまります。マルチシャーシマルチリンクの場合、実装は正しいキーが参加しているすべてのマシン上で生成されていることを確認する責任があります。"
    },
    {
      "indent": 0,
      "text": "2.1. Generating 40-bit Session Keys",
      "section_title": true,
      "ja": "2.1。 40ビットのセッション鍵を生成します"
    },
    {
      "indent": 3,
      "text": "MPPE uses a derivative of the peer's LAN Manager password as the 40- bit session key used for initializing the RC4 encryption tables.",
      "ja": "MPPEは、RC4暗号化テーブルを初期化するために使用された40ビットのセッションキーとしてピアのLAN Managerパスワードの派生物を使用しています。"
    },
    {
      "indent": 3,
      "text": "The first step is to obfuscate the peer's password using the LmPasswordHash() function (described in [2]). The first 8 octets of the result are used as the basis for the session key generated in the following way:",
      "ja": "最初のステップは、（[2]に記載）LmPasswordHash（）関数を使用して、ピアのパスワードを難読化することです。結果の最初の8つのオクテットは、次のように生成されたセッション鍵のための基礎として使用されています。"
    },
    {
      "indent": 0,
      "text": "/*\n* PasswordHash is the basis for the session key\n* SessionKey is a copy of PasswordHash and is the generative session key\n* 8 is the length (in octets) of the key to be generated.\n*\n*/\nGet_Key(PasswordHash, SessionKey, 8)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/*\n* The effective length of the key is reduced to 40 bits by\n* replacing the first three bytes as follows:\n*/\nSessionKey[0] = 0xd1 ;\nSessionKey[1] = 0x26 ;\nSessionKey[2] = 0x9e ;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "2.2. Generating 56-bit Session Keys",
      "section_title": true,
      "ja": "2.2。 56ビットのセッション鍵を生成します"
    },
    {
      "indent": 3,
      "text": "MPPE uses a derivative of the peer's LAN Manager password as the 56- bit session key used for initializing the RC4 encryption tables.",
      "ja": "MPPEは、RC4暗号化テーブルを初期化するために使用され、56ビットのセッションキーとしてピアのLAN Managerパスワードの派生物を使用しています。"
    },
    {
      "indent": 3,
      "text": "The first step is to obfuscate the peer's password using the LmPasswordHash() function (described in [2]). The first 8 octets of the result are used as the basis for the session key generated in the following way:",
      "ja": "最初のステップは、（[2]に記載）LmPasswordHash（）関数を使用して、ピアのパスワードを難読化することです。結果の最初の8つのオクテットは、次のように生成されたセッション鍵のための基礎として使用されています。"
    },
    {
      "indent": 0,
      "text": "/*\n* PasswordHash is the basis for the session key\n* SessionKey is a copy of PasswordHash and is the generative session key\n* 8 is the length (in octets) of the key to be generated.\n*\n*/\nGet_Key(PasswordHash, SessionKey, 8)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/*\n* The effective length of the key is reduced to 56 bits by\n* replacing the first byte as follows:\n*/\nSessionKey[0] = 0xd1 ;",
      "raw": true
    },
    {
      "indent": 0,
      "text": "2.3. Generating 128-bit Session Keys",
      "section_title": true,
      "ja": "2.3。 128ビットのセッションキーの生成"
    },
    {
      "indent": 3,
      "text": "MPPE uses a derivative of the peer's Windows NT password as the 128- bit session key used for initializing encryption tables.",
      "ja": "MPPE暗号化テーブルを初期化するために使用され、128ビットのセッションキーとしてピアのWindows NTパスワードの派生物を使用しています。"
    },
    {
      "indent": 3,
      "text": "The first step is to obfuscate the peer's password using NtPasswordHash() function as described in [2]. The first 16 octets of the result are then hashed again using the MD4 algorithm. The first 16 octets of the second hash are used as the basis for the session key generated in the following way:",
      "ja": "最初のステップは、[2]に記載のようにNtPasswordHash（）関数を使用して、ピアのパスワードを難読化することです。結果の最初の16個のオクテットは再びMD4アルゴリズムを使用してハッシュされます。第2のハッシュの最初の16個のオクテットは、以下のように生成されたセッション鍵の基礎として使用されます。"
    },
    {
      "indent": 0,
      "text": "/*\n* Challenge (as described in [9]) is sent by the PPP authenticator\n* during authentication and is 8 octets long.\n* NtPasswordHashHash is the basis for the session key.\n* On return, InitialSessionKey contains the initial session\n* key to be used.\n*/\nGet_Start_Key(Challenge, NtPasswordHashHash, InitialSessionKey)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/*\n* CurrentSessionKey is a copy of InitialSessionKey\n* and is the generative session key.\n* Length (in octets) of the key to generate is 16.\n*\n*/\nGet_Key(InitialSessionKey, CurrentSessionKey, 16)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "2.4. Key Derivation Functions",
      "section_title": true,
      "ja": "2.4。鍵導出関数"
    },
    {
      "indent": 3,
      "text": "The following procedures are used to derive the session key.",
      "ja": "次の手順では、セッション鍵を導出するために使用されています。"
    },
    {
      "indent": 0,
      "text": "/*\n * Pads used in key derivation\n */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "SHApad1[40] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};",
      "ja": "SHApad1 [40] = {0x00で、0x00に、0x00に、0x00で、0x00に、0x00で、0x00に、0x00で、0x00に、0x00で、0x00に、0x00で、0x00に、0x00で、0x00に、0x00で、0x00に、0x00で、0x00に、0x00で、0x00に、0x00に、 0x00で、0x00に、0x00で、0x00に、0x00で、0x00に、0x00で、0x00に、0x00で、0x00に、0x00で、0x00に、0x00で、0x00に、0x00で、0x00に、0x00に、0x00を}。"
    },
    {
      "indent": 0,
      "text": "SHApad2[40] = {0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2};",
      "ja": "SHApad2 [40] = {0xf2、0xf2、0xf2、0xf2、0xf2、0xf2、0xf2、0xf2、0xf2、0xf2、0xf2、0xf2、0xf2、0xf2、0xf2、0xf2、0xf2、0xf2、0xf2、0xf2、0xf2、0xf2、 0xf2、0xf2、0xf2、0xf2、0xf2、0xf2、0xf2、0xf2、0xf2、0xf2、0xf2、0xf2、0xf2、0xf2、0xf2、0xf2、0xf2、0xf2}。"
    },
    {
      "indent": 0,
      "text": "/*\n * SHAInit(), SHAUpdate() and SHAFinal() functions are an\n * implementation of Secure Hash Algorithm (SHA-1) [7]. These are\n * available in public domain or can be licensed from\n * RSA Data Security, Inc.\n *\n * 1) InitialSessionKey is 8 octets long for 56- and 40-bit\n *    session keys, 16 octets long for 128 bit session keys.\n * 2) CurrentSessionKey is same as InitialSessionKey when this\n *    routine is called for the first time for the session.\n */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Get_Key( IN InitialSessionKey, IN/OUT CurrentSessionKey IN LengthOfDesiredKey ) { SHAInit(Context) SHAUpdate(Context, InitialSessionKey, LengthOfDesiredKey) SHAUpdate(Context, SHAPad1, 40) SHAUpdate(Context, CurrentSessionKey, LengthOfDesiredKey) SHAUpdate(Context, SHAPad2, 40) SHAFinal(Context, Digest) memcpy(CurrentSessionKey, Digest, LengthOfDesiredKey) }",
      "ja": "Get_Key（InitialSessionKey、IN IN / OUT LengthOfDesiredKey IN CurrentSessionKey）{SHAInit（コンテキスト）SHAUpdate（コンテキスト、InitialSessionKey、LengthOfDesiredKey）SHAUpdate（コンテキスト、SHAPad1、40）SHAUpdate（コンテキスト、CurrentSessionKey、LengthOfDesiredKey）SHAUpdate（コンテキスト、SHAPad2、40）SHAFinal （コンテキスト、ダイジェスト）のmemcpy（CurrentSessionKey、ダイジェスト、LengthOfDesiredKey）}"
    },
    {
      "indent": 0,
      "text": "Get_Start_Key( IN Challenge,",
      "ja": "挑戦Get_Start_Key（、"
    },
    {
      "indent": 0,
      "text": "IN NtPasswordHashHash, OUT InitialSessionKey) { SHAInit(Context) SHAUpdate(Context, NtPasswordHashHash, 16) SHAUpdate(Context, NtPasswordHashHash, 16) SHAUpdate(Context, Challenge, 8) SHAFinal(Context, Digest) memcpy(InitialSessionKey, Digest, 16) }",
      "ja": "NtPasswordHashHash IN、OUT InitialSessionKey）{SHAInit（コンテキスト）SHAUpdate（コンテキスト、NtPasswordHashHash、16）SHAUpdate（コンテキスト、NtPasswordHashHash、16）SHAUpdate（コンテキスト、チャレンジ、8）SHAFinal（コンテキスト、ダイジェスト）のmemcpy（InitialSessionKey、ダイジェスト、16）}"
    },
    {
      "indent": 0,
      "text": "2.5. Sample Key Derivations",
      "section_title": true,
      "ja": "2.5。サンプルキー派生の"
    },
    {
      "indent": 3,
      "text": "The following sections illustrate 40-, 56- and 128-bit key derivations. All intermediate values are in hexadecimal.",
      "ja": "以下のセクションでは、40-、56ビットおよび128ビットの鍵導出を示します。すべての中間値は16進数です。"
    },
    {
      "indent": 0,
      "text": "2.5.1. Sample 40-bit Key Derivation",
      "section_title": true,
      "ja": "2.5.1。サンプル40ビットの鍵の導出"
    },
    {
      "indent": 3,
      "text": "Initial Values Password = \"clientPass\"",
      "ja": "初期値のパスワード=「clientPass」"
    },
    {
      "indent": 3,
      "text": "Step 1: LmPasswordHash(Password, PasswordHash) PasswordHash = 76 a1 52 93 60 96 d7 83 0e 23 90 22 74 04 af d2",
      "ja": "ステップ1：LmPasswordHash（パスワード、PasswordHash）PasswordHash = 76 A1 52 93 60 96 D7 83 0E 23 90 22 74 04 AF D2"
    },
    {
      "indent": 3,
      "text": "Step 2: Copy PasswordHash to SessionKey SessionKey = 76 a1 52 93 60 96 d7 83 0e 23 90 22 74 04 af d2",
      "ja": "ステップ2：SESSIONKEY SESSIONKEYにコピーPasswordHash = 76 A1 52 93 60 96 D7 83 0E 23 90 22 74 04 AF D2"
    },
    {
      "indent": 3,
      "text": "Step 3: GetKey(PasswordHash, SessionKey, 8) SessionKey = d8 08 01 53 8c ec 4a 08",
      "ja": "ステップ3：のGetKey（PasswordHash、SESSIONKEY、8）SESSIONKEY = D8 08 01 53 8C EC 08 4A"
    },
    {
      "indent": 3,
      "text": "Step 4: Reduce the effective key length to 40 bits SessionKey = d1 26 9e 53 8c ec 4a 08",
      "ja": "ステップ4：40ビットSESSIONKEY = D1 26 9E 53 8CのEC 4A 08に有効なキーの長さを減らし"
    },
    {
      "indent": 0,
      "text": "2.5.2. Sample 56-bit Key Derivation",
      "section_title": true,
      "ja": "2.5.2。サンプル56ビットの鍵の導出"
    },
    {
      "indent": 3,
      "text": "Initial Values Password = \"clientPass\"",
      "ja": "初期値のパスワード=「clientPass」"
    },
    {
      "indent": 3,
      "text": "Step 1: LmPasswordHash(Password, PasswordHash) PasswordHash = 76 a1 52 93 60 96 d7 83 0e 23 90 22 74 04 af d2",
      "ja": "ステップ1：LmPasswordHash（パスワード、PasswordHash）PasswordHash = 76 A1 52 93 60 96 D7 83 0E 23 90 22 74 04 AF D2"
    },
    {
      "indent": 3,
      "text": "Step 2: Copy PasswordHash to SessionKey SessionKey = 76 a1 52 93 60 96 d7 83 0e 23 90 22 74 04 af d2",
      "ja": "ステップ2：SESSIONKEY SESSIONKEYにコピーPasswordHash = 76 A1 52 93 60 96 D7 83 0E 23 90 22 74 04 AF D2"
    },
    {
      "indent": 3,
      "text": "Step 3: GetKey(PasswordHash, SessionKey, 8) SessionKey = d8 08 01 53 8c ec 4a 08",
      "ja": "ステップ3：のGetKey（PasswordHash、SESSIONKEY、8）SESSIONKEY = D8 08 01 53 8C EC 08 4A"
    },
    {
      "indent": 3,
      "text": "Step 4: Reduce the effective key length to 56 bits SessionKey = d1 08 01 53 8c ec 4a 08",
      "ja": "ステップ4：56ビットSESSIONKEY = D1 08 01 53 8CのEC 4A 08に有効なキーの長さを減らし"
    },
    {
      "indent": 0,
      "text": "2.5.3. Sample 128-bit Key Derivation",
      "section_title": true,
      "ja": "2.5.3。サンプル128ビットの鍵の導出"
    },
    {
      "indent": 0,
      "text": "Initial Values Password = \"clientPass\" Challenge = 10 2d b5 df 08 5d 30 41",
      "ja": "08 5D 30 41 DF初期値のパスワード= \"clientPass\" チャレンジ= 10 2D B5"
    },
    {
      "indent": 0,
      "text": "Step 1: NtPasswordHash(Password, PasswordHash) PasswordHash = 44 eb ba 8d 53 12 b8 d6 11 47 44 11 f5 69 89 ae",
      "ja": "ステップ1：NtPasswordHash（パスワード、PasswordHash）PasswordHash = 44のEB BAが53 12 B8 D6 11 47 44 11 69 89 F5 AEを図8d"
    },
    {
      "indent": 0,
      "text": "Step 2: PasswordHashHash = MD4(PasswordHash) PasswordHashHash = 41 c0 0c 58 4b d2 d9 1c 40 17 a2 a1 2f a5 9f 3f",
      "ja": "ステップ2：PasswordHashHash = MD4（PasswordHash）PasswordHashHash = 41 C0 0C 58 4B D2 D9 1C 40 17 A2 A1 2F A5 9F 3F"
    },
    {
      "indent": 0,
      "text": "Step 3: GetStartKey(Challenge, PasswordHashHash, InitialSessionKey) InitialSessionKey = a8 94 78 50 cf c0 ac ca d1 78 9f b6 2d dc dd b0",
      "ja": "ステップ3：GetStartKey（チャレンジ、PasswordHashHash、InitialSessionKey）InitialSessionKey = A8 94 78 50 CF C0と交流CA D1 78 9F B6 2D直流のDD B0"
    },
    {
      "indent": 0,
      "text": "Step 4: Copy InitialSessionKey to CurrentSessionKey CurrentSessionKey = a8 94 78 50 cf c0 ac c1 d1 78 9f b6 2d dc dd b0",
      "ja": "ステップ4：コピーInitialSessionKey CurrentSessionKey CurrentSessionKey = A8 94 78 50 CF C0と交流C1 D1 78 9F B6 2D直流DD B0に"
    },
    {
      "indent": 0,
      "text": "Step 5: GetKey(InitialSessionKey, CurrentSessionKey, 16) CurrentSessionKey = 59 d1 59 bc 09 f7 6f 1d a2 a8 6a 28 ff ec 0b 1e",
      "ja": "ステップ5：のGetKey（InitialSessionKey、CurrentSessionKey、16）CurrentSessionKey = 59 59 BC 09 F7 6F 1D A2のA8 6aとD1 28 FF EC 0B 1E"
    },
    {
      "indent": 0,
      "text": "3. Deriving Session Keys from MS-CHAP-2 Credentials",
      "section_title": true,
      "ja": "3. MS-CHAP-2の資格情報からセッション鍵を導出"
    },
    {
      "indent": 3,
      "text": "Version 2 of the Microsoft Challenge-Handshake Authentication Protocol (MS-CHAP-2) [8] is a Microsoft-proprietary PPP authentication protocol, providing the functionality to which LAN-based users are accustomed while integrating the encryption and hashing algorithms used on Windows networks.",
      "ja": "Microsoftチャレンジハンドシェイク認証プロトコル（MS-CHAP-2）のバージョン2 [8]暗号化を統合し、Windowsで使用されるアルゴリズムをハッシュしながらLANベースのユーザが慣れされる機能を提供する、マイクロソフト独自のPPP認証プロトコルでありますネットワーク。"
    },
    {
      "indent": 3,
      "text": "The following sections detail the methods used to derive initial session keys from MS-CHAP-2 credentials. 40-, 56- and 128-bit keys are all derived using the same algorithm from the authenticating peer's Windows NT password. The only difference is in the length of the keys and their effective strength: 40- and 56-bit keys are 8 octets in length, while 128-bit keys are 16 octets long. Separate keys are derived for the send and receive directions of the session.",
      "ja": "以下のセクションで詳細MS-CHAP-2資格情報から最初のセッションキーを導出するために使用される方法。 40-、56ビットおよび128ビットのキーは、すべての認証ピアのWindows NTのパスワードと同じアルゴリズムを使用して導出されています。 128ビットのキーは16オクテット長でありながら、40〜56ビットのキーは、長さが8つのオクテットである。唯一の違いは、キーの長さおよびそれらの有効な強度です。別々のキーは、送信のために導出され、セッションの方向を受信して​​います。"
    },
    {
      "indent": 3,
      "text": "Implementation Note",
      "ja": "実装上の注意"
    },
    {
      "indent": 6,
      "text": "The initial session keys in both directions are derived from the credentials of the peer that initiated the call and the challenges used are those from the first authentication. This is true as well for each link in a multilink bundle. In the multi-chassis multilink case, implementations are responsible for ensuring that the correct keys are generated on all participating machines.",
      "ja": "両方向の最初のセッション鍵をコールし、使用の挑戦を開始したピアの資格情報から導出された第1の認証からのものです。これは、マルチリンクバンドル内の各リンクのためにも当てはまります。マルチシャーシマルチリンクの場合、実装は正しいキーが参加しているすべてのマシン上で生成されていることを確認する責任があります。"
    },
    {
      "indent": 0,
      "text": "3.1. Generating 40-bit Session Keys",
      "section_title": true,
      "ja": "3.1。 40ビットのセッション鍵を生成します"
    },
    {
      "indent": 3,
      "text": "When used in conjunction with MS-CHAP-2 authentication, the initial MPPE session keys are derived from the peer's Windows NT password.",
      "ja": "MS-CHAP-2認証と組み合わせて使用​​する場合、初期MPPEセッションキーは、ピアのWindows NTのパスワードから導出されています。"
    },
    {
      "indent": 3,
      "text": "The first step is to obfuscate the peer's password using NtPasswordHash() function as described in [8].",
      "ja": "最初のステップは、[8]に記載のようにNtPasswordHash（）関数を使用して、ピアのパスワードを難読化することです。"
    },
    {
      "indent": 6,
      "text": "NtPasswordHash(Password, PasswordHash)",
      "ja": "NtPasswordHash（パスワード、PasswordHash）"
    },
    {
      "indent": 3,
      "text": "The first 16 octets of the result are then hashed again using the MD4 algorithm.",
      "ja": "結果の最初の16個のオクテットは再びMD4アルゴリズムを使用してハッシュされます。"
    },
    {
      "indent": 6,
      "text": "PasswordHashHash = md4(PasswordHash)",
      "ja": "PasswordHashHash = MD4（PasswordHash）"
    },
    {
      "indent": 3,
      "text": "The first 16 octets of this second hash are used together with the NT- Response field from the MS-CHAP-2 Response packet [8] as the basis for the master session key:",
      "ja": "この第2のハッシュの最初の16個のオクテットは、MS-CHAP-2応答パケットからNT-応答フィールドと一緒に使用されている[8]マスターセッションキーの基礎として："
    },
    {
      "indent": 6,
      "text": "GetMasterKey(PasswordHashHash, NtResponse, MasterKey)",
      "ja": "GetMasterKey（PasswordHashHash、NtResponse、MASTERKEY）"
    },
    {
      "indent": 3,
      "text": "Once the master key has been generated, it is used to derive two 40- bit session keys, one for sending and one for receiving:",
      "ja": "マスターキーが生成されたら、二つの40-ビットのセッションキー、送信用と受信のための1つを導出するために使用されます。"
    },
    {
      "indent": 6,
      "text": "GetAsymmetricStartKey(MasterKey, MasterSendKey, 8, TRUE, TRUE) GetAsymmetricStartKey(MasterKey, MasterReceiveKey, 8, FALSE, TRUE)",
      "ja": "GetAsymmetricStartKey（MASTERKEY、MasterSendKey、8、TRUE、TRUE）GetAsymmetricStartKey（MASTERKEY、MasterReceiveKey、8、FALSE、TRUE）"
    },
    {
      "indent": 3,
      "text": "The master session keys are never used to encrypt or decrypt data; they are only used in the derivation of transient session keys. The initial transient session keys are obtained by calling the function GetNewKeyFromSHA() (described in [3]):",
      "ja": "マスターセッションキーは、データの暗号化や復号化に使用されることはありません。彼らは唯一の過渡セッションキーの導出に使用されています。初期のトランジエントセッション鍵は、関数GetNewKeyFromSHA（呼び出すことによって得られる）（[3]に記載されています）。"
    },
    {
      "indent": 0,
      "text": "GetNewKeyFromSHA(MasterSendKey, MasterSendKey, 8, SendSessionKey) GetNewKeyFromSHA(MasterReceiveKey, MasterReceiveKey, 8, ReceiveSessionKey)",
      "ja": "GetNewKeyFromSHA（MasterSendKey、MasterSendKey、8、SendSessionKey）GetNewKeyFromSHA（MasterReceiveKey、MasterReceiveKey、8、ReceiveSessionKey）"
    },
    {
      "indent": 3,
      "text": "Next, the effective strength of both keys is reduced by setting the first three octets to known constants:",
      "ja": "次に、両方のキーの有効強度は、既知の定数に最初の3つのオクテットを設定することによって低減されます。"
    },
    {
      "indent": 6,
      "text": "SendSessionKey[0] = ReceiveSessionKey[0] = 0xd1 SendSessionKey[1] = ReceiveSessionKey[1] = 0x26 SendSessionKey[2] = ReceiveSessionKey[2] = 0x9e",
      "ja": "SendSessionKey [0] = ReceiveSessionKey [0] = 0xd1 SendSessionKey [1] = ReceiveSessionKey [1] = 0x26 SendSessionKey [2] = ReceiveSessionKey [2] = 0x9e"
    },
    {
      "indent": 3,
      "text": "Finally, the RC4 tables are initialized using the new session keys:",
      "ja": "最後に、RC4テーブルには、新しいセッションキーを使用して初期化されます。"
    },
    {
      "indent": 6,
      "text": "rc4_key(SendRC4key, 8, SendSessionKey) rc4_key(ReceiveRC4key, 8, ReceiveSessionKey)",
      "ja": "rc4_key（SendRC4key、8、SendSessionKey）rc4_key（ReceiveRC4key、8、ReceiveSessionKey）"
    },
    {
      "indent": 0,
      "text": "3.2. Generating 56-bit Session Keys",
      "section_title": true,
      "ja": "3.2。 56ビットのセッション鍵を生成します"
    },
    {
      "indent": 3,
      "text": "When used in conjunction with MS-CHAP-2 authentication, the initial MPPE session keys are derived from the peer's Windows NT password.",
      "ja": "MS-CHAP-2認証と組み合わせて使用​​する場合、初期MPPEセッションキーは、ピアのWindows NTのパスワードから導出されています。"
    },
    {
      "indent": 3,
      "text": "The first step is to obfuscate the peer's password using NtPasswordHash() function as described in [8].",
      "ja": "最初のステップは、[8]に記載のようにNtPasswordHash（）関数を使用して、ピアのパスワードを難読化することです。"
    },
    {
      "indent": 6,
      "text": "NtPasswordHash(Password, PasswordHash)",
      "ja": "NtPasswordHash（パスワード、PasswordHash）"
    },
    {
      "indent": 3,
      "text": "The first 16 octets of the result are then hashed again using the MD4 algorithm.",
      "ja": "結果の最初の16個のオクテットは再びMD4アルゴリズムを使用してハッシュされます。"
    },
    {
      "indent": 6,
      "text": "PasswordHashHash = md4(PasswordHash)",
      "ja": "PasswordHashHash = MD4（PasswordHash）"
    },
    {
      "indent": 3,
      "text": "The first 16 octets of this second hash are used together with the NT-Response field from the MS-CHAP-2 Response packet [8] as the basis for the master session key:",
      "ja": "この第2のハッシュの最初の16個のオクテットは、MS-CHAP-2応答パケットからNT-応答フィールドと一緒に使用されている[8]マスターセッションキーの基礎として："
    },
    {
      "indent": 6,
      "text": "GetMasterKey(PasswordHashHash, NtResponse, MasterKey)",
      "ja": "GetMasterKey（PasswordHashHash、NtResponse、MASTERKEY）"
    },
    {
      "indent": 3,
      "text": "Once the master key has been generated, it is used to derive two 56-bit session keys, one for sending and one for receiving:",
      "ja": "マスターキーが生成されると、二つの56ビットのセッションキー、送信用と受信のための1つを導出するために使用されます。"
    },
    {
      "indent": 6,
      "text": "GetAsymmetricStartKey(MasterKey, MasterSendKey, 8, TRUE, TRUE) GetAsymmetricStartKey(MasterKey, MasterReceiveKey, 8, FALSE, TRUE)",
      "ja": "GetAsymmetricStartKey（MASTERKEY、MasterSendKey、8、TRUE、TRUE）GetAsymmetricStartKey（MASTERKEY、MasterReceiveKey、8、FALSE、TRUE）"
    },
    {
      "indent": 3,
      "text": "The master session keys are never used to encrypt or decrypt data; they are only used in the derivation of transient session keys. The initial transient session keys are obtained by calling the function GetNewKeyFromSHA() (described in [3]):",
      "ja": "マスターセッションキーは、データの暗号化や復号化に使用されることはありません。彼らは唯一の過渡セッションキーの導出に使用されています。初期のトランジエントセッション鍵は、関数GetNewKeyFromSHA（呼び出すことによって得られる）（[3]に記載されています）。"
    },
    {
      "indent": 0,
      "text": "GetNewKeyFromSHA(MasterSendKey, MasterSendKey, 8, SendSessionKey) GetNewKeyFromSHA(MasterReceiveKey, MasterReceiveKey, 8, ReceiveSessionKey)",
      "ja": "GetNewKeyFromSHA（MasterSendKey、MasterSendKey、8、SendSessionKey）GetNewKeyFromSHA（MasterReceiveKey、MasterReceiveKey、8、ReceiveSessionKey）"
    },
    {
      "indent": 3,
      "text": "Next, the effective strength of both keys is reduced by setting the first octet to a known constant:",
      "ja": "次に、両方のキーの有効強度は、既知の定数に最初のオクテットを設定することによって低減されます。"
    },
    {
      "indent": 6,
      "text": "SendSessionKey[0] = ReceiveSessionKey[0] = 0xd1",
      "ja": "SendSessionKey [0] = ReceiveSessionKey [0] = 0xd1"
    },
    {
      "indent": 3,
      "text": "Finally, the RC4 tables are initialized using the new session keys:",
      "ja": "最後に、RC4テーブルには、新しいセッションキーを使用して初期化されます。"
    },
    {
      "indent": 6,
      "text": "rc4_key(SendRC4key, 8, SendSessionKey) rc4_key(ReceiveRC4key, 8, ReceiveSessionKey)",
      "ja": "rc4_key（SendRC4key、8、SendSessionKey）rc4_key（ReceiveRC4key、8、ReceiveSessionKey）"
    },
    {
      "indent": 0,
      "text": "3.3. Generating 128-bit Session Keys",
      "section_title": true,
      "ja": "3.3。 128ビットのセッションキーの生成"
    },
    {
      "indent": 3,
      "text": "When used in conjunction with MS-CHAP-2 authentication, the initial MPPE session keys are derived from the peer's Windows NT password.",
      "ja": "MS-CHAP-2認証と組み合わせて使用​​する場合、初期MPPEセッションキーは、ピアのWindows NTのパスワードから導出されています。"
    },
    {
      "indent": 3,
      "text": "The first step is to obfuscate the peer's password using NtPasswordHash() function as described in [8].",
      "ja": "最初のステップは、[8]に記載のようにNtPasswordHash（）関数を使用して、ピアのパスワードを難読化することです。"
    },
    {
      "indent": 6,
      "text": "NtPasswordHash(Password, PasswordHash)",
      "ja": "NtPasswordHash（パスワード、PasswordHash）"
    },
    {
      "indent": 3,
      "text": "The first 16 octets of the result are then hashed again using the MD4 algorithm.",
      "ja": "結果の最初の16個のオクテットは再びMD4アルゴリズムを使用してハッシュされます。"
    },
    {
      "indent": 6,
      "text": "PasswordHashHash = md4(PasswordHash)",
      "ja": "PasswordHashHash = MD4（PasswordHash）"
    },
    {
      "indent": 3,
      "text": "The first 16 octets of this second hash are used together with the NT-Response field from the MS-CHAP-2 Response packet [8] as the basis for the master session key:",
      "ja": "この第2のハッシュの最初の16個のオクテットは、MS-CHAP-2応答パケットからNT-応答フィールドと一緒に使用されている[8]マスターセッションキーの基礎として："
    },
    {
      "indent": 6,
      "text": "GetMasterKey(PasswordHashHash, NtResponse, MasterKey)",
      "ja": "GetMasterKey（PasswordHashHash、NtResponse、MASTERKEY）"
    },
    {
      "indent": 3,
      "text": "Once the master key has been generated, it is used to derive two 128-bit master session keys, one for sending and one for receiving:",
      "ja": "マスターキーが生成されたら、2つの128ビットのマスターセッションキー、送信用と受信のための1つを導出するために使用されます。"
    },
    {
      "indent": 0,
      "text": "GetAsymmetricStartKey(MasterKey, MasterSendKey, 16, TRUE, TRUE) GetAsymmetricStartKey(MasterKey, MasterReceiveKey, 16, FALSE, TRUE)",
      "ja": "GetAsymmetricStartKey（MASTERKEY、MasterSendKey、16、TRUE、TRUE）GetAsymmetricStartKey（MASTERKEY、MasterReceiveKey、16、FALSE、TRUE）"
    },
    {
      "indent": 3,
      "text": "The master session keys are never used to encrypt or decrypt data; they are only used in the derivation of transient session keys. The initial transient session keys are obtained by calling the function GetNewKeyFromSHA() (described in [3]):",
      "ja": "マスターセッションキーは、データの暗号化や復号化に使用されることはありません。彼らは唯一の過渡セッションキーの導出に使用されています。初期のトランジエントセッション鍵は、関数GetNewKeyFromSHA（呼び出すことによって得られる）（[3]に記載されています）。"
    },
    {
      "indent": 0,
      "text": "GetNewKeyFromSHA(MasterSendKey, MasterSendKey, 16, SendSessionKey) GetNewKeyFromSHA(MasterReceiveKey, MasterReceiveKey, 16, ReceiveSessionKey)",
      "ja": "GetNewKeyFromSHA（MasterSendKey、MasterSendKey、16、SendSessionKey）GetNewKeyFromSHA（MasterReceiveKey、MasterReceiveKey、16、ReceiveSessionKey）"
    },
    {
      "indent": 3,
      "text": "Finally, the RC4 tables are initialized using the new session keys:",
      "ja": "最後に、RC4テーブルには、新しいセッションキーを使用して初期化されます。"
    },
    {
      "indent": 6,
      "text": "rc4_key(SendRC4key, 16, SendSessionKey) rc4_key(ReceiveRC4key, 16, ReceiveSessionKey)",
      "ja": "rc4_key（SendRC4key、16、SendSessionKey）rc4_key（ReceiveRC4key、16、ReceiveSessionKey）"
    },
    {
      "indent": 0,
      "text": "3.4. Key Derivation Functions",
      "section_title": true,
      "ja": "3.4。鍵導出関数"
    },
    {
      "indent": 3,
      "text": "The following procedures are used to derive the session key.",
      "ja": "次の手順では、セッション鍵を導出するために使用されています。"
    },
    {
      "indent": 0,
      "text": "/*\n * Pads used in key derivation\n */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "SHSpad1[40] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};",
      "ja": "SHSpad1 [40] = {0x00で、0x00に、0x00に、0x00で、0x00に、0x00で、0x00に、0x00で、0x00に、0x00で、0x00に、0x00で、0x00に、0x00で、0x00に、0x00で、0x00に、0x00で、0x00に、0x00で、0x00に、0x00に、 0x00で、0x00に、0x00で、0x00に、0x00で、0x00に、0x00で、0x00に、0x00で、0x00に、0x00で、0x00に、0x00で、0x00に、0x00で、0x00に、0x00に、0x00を}。"
    },
    {
      "indent": 0,
      "text": "SHSpad2[40] = {0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2, 0xf2};",
      "ja": "SHSpad2 [40] = {0xf2、0xf2、0xf2、0xf2、0xf2、0xf2、0xf2、0xf2、0xf2、0xf2、0xf2、0xf2、0xf2、0xf2、0xf2、0xf2、0xf2、0xf2、0xf2、0xf2、0xf2、0xf2、 0xf2、0xf2、0xf2、0xf2、0xf2、0xf2、0xf2、0xf2、0xf2、0xf2、0xf2、0xf2、0xf2、0xf2、0xf2、0xf2、0xf2、0xf2}。"
    },
    {
      "indent": 0,
      "text": "/*\n * \"Magic\" constants used in key derivations\n */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Magic1[27] = {0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x4d, 0x50, 0x50, 0x45, 0x20, 0x4d, 0x61, 0x73, 0x74, 0x65, 0x72, 0x20, 0x4b, 0x65, 0x79};",
      "ja": "Magic1 [27] = {が0x54、0x68、0x69の、0x73、0x20に、0x69の、0x73、0x20に、0x74、0x68、0x65、0x20に、0x4d、0x50を、0x50を、0x45、0x20に、0x4d、の0x61、0x73、0x74、0x65、 0x72、0x20に、0x4b、0x65、0x79}。"
    },
    {
      "indent": 0,
      "text": "Magic2[84] = {0x4f, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x20, 0x73, 0x69, 0x64, 0x65, 0x2c, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x65, 0x6e, 0x64, 0x20, 0x6b, 0x65, 0x79, 0x3b, 0x20, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x73, 0x69, 0x64, 0x65, 0x2c, 0x20, 0x69, 0x74, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x20, 0x6b, 0x65, 0x79, 0x2e};",
      "ja": "Magic2 [84] = {0x4f、0x6e、の0x20、0x74、0x68、0x65、0x20に、は0x63、0x6c、0x69の、0x65、0x6e、0x74、0x20に、0x73、0x69の、0x64、0x65、0x2c、は0x20、0x74、0x68、 0x69の、0x73、0x20に、0x69の、0x73、0x20に、0x74、0x68、0x65、0x20に、0x73、0x65、0x6e、0x64、0x20に、0x6b、0x65、0x79、0x3b、0x20に、0x6f、0x6e、の0x20、0x74、0x68、 0x2c 0x65、0x20に、0x73、0x65、0x72、0x76、0x65、0x72、0x20に、0x73、0x69の、0x64、0x65、0x20に、0x69の、0x74、0x20に、0x69の、0x73、0x20に、0x74、0x68、0x65、0x20に、 0x72、0x65、は0x63、0x65、0x69の、0x76、0x65、0x20に、0x6b、0x65、0x79、0x2e}。"
    },
    {
      "indent": 0,
      "text": "Magic3[84] = {0x4f, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x20, 0x73, 0x69, 0x64, 0x65, 0x2c, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x63, 0x65, 0x69, 0x76, 0x65, 0x20, 0x6b, 0x65, 0x79, 0x3b, 0x20, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x20, 0x73, 0x69, 0x64, 0x65, 0x2c, 0x20, 0x69, 0x74, 0x20, 0x69, 0x73,",
      "ja": "Magic3 [84] = {0x4f、0x6e、の0x20、0x74、0x68、0x65、0x20に、は0x63、0x6c、0x69の、0x65、0x6e、0x74、0x20に、0x73、0x69の、0x64、0x65、0x2c、は0x20、0x74、0x68、 0x69の、0x73、0x20に、0x69の、0x73、0x20に、0x74、0x68、0x65、0x20に、0x72、0x65、は0x63、0x65、0x69の、0x76、0x65、0x20に、0x6b、0x65、0x79、0x3b、0x20に、0x6f、0x6e、 0x2cの0x20、0x74、0x68、0x65、0x20に、0x73、0x65、0x72、0x76、0x65、0x72、0x20に、0x73、0x69の、0x64、0x65、0x20に、0x69の、0x74、0x20に、0x69の、0x73、"
    },
    {
      "indent": 4,
      "text": "0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x65, 0x6e, 0x64, 0x20,\n0x6b, 0x65, 0x79, 0x2e};",
      "raw": true
    },
    {
      "indent": 3,
      "text": "GetMasterKey( IN 16-octet PasswordHashHash, IN 24-octet NTResponse, OUT 16-octet MasterKey ) { 20-octet Digest",
      "ja": "取得MASTERKEY（16オクテットパスワードハッシュハッシュでは、24オクテットの応答IN、OUT 16オクテットMASTERKEY）{20オクテットのダイジェスト"
    },
    {
      "indent": 6,
      "text": "ZeroMemory(Digest, sizeof(Digest));",
      "ja": "ZeroMemory（ダイジェストはsizeof（ダイジェスト））。"
    },
    {
      "indent": 6,
      "text": "/*\n * SHSInit(), SHSUpdate() and SHSFinal()\n * are an implementation of the Secure Hash Standard [7].\n */",
      "raw": true
    },
    {
      "indent": 6,
      "text": "SHSInit(Context);\nSHSUpdate(Context, PasswordHashHash, 16);\nSHSUpdate(Context, NTResponse, 24);\nSHSUpdate(Context, Magic1, 27);\nSHSFinal(Context, Digest);",
      "raw": true
    },
    {
      "indent": 3,
      "text": " MoveMemory(MasterKey, Digest, 16); }",
      "ja": "MoveMemory（MASTERKEY、ダイジェスト、16）。 }"
    },
    {
      "indent": 3,
      "text": "VOID GetAsymetricStartKey( IN 16-octet MasterKey, OUT 8-to-16 octet SessionKey, IN INTEGER SessionKeyLength, IN BOOLEAN IsSend, IN BOOLEAN IsServer ) {",
      "ja": "VOID GetAsymetricStartKey（16オクテットIN MASTERKEY、OUT 8対16オクテットSESSIONKEY、INTEGER SessionKeyLength IN、BOOLEAN IsSend IN、BOOLEAN IsServer IN）{"
    },
    {
      "indent": 6,
      "text": "20-octet Digest;",
      "ja": "20オクテットのダイジェスト。"
    },
    {
      "indent": 6,
      "text": "ZeroMemory(Digest, 20);",
      "ja": "ZeroMemory（ダイジェスト、20）。"
    },
    {
      "indent": 6,
      "text": "if (IsSend) { if (IsServer) { s = Magic3 } else { s = Magic2 } } else { if (IsServer) {",
      "ja": "IF（IsSend）{IF（IsServer）{S = Magic3}他{S = Magic2}}他{IF（IsServer）{"
    },
    {
      "indent": 6,
      "text": " s = Magic2 } else { s = Magic3 } }",
      "ja": "S = Magic2}他{S = Magic3}}"
    },
    {
      "indent": 6,
      "text": "/*\n * SHSInit(), SHSUpdate() and SHSFinal()\n * are an implementation of the Secure Hash Standard [7].\n */",
      "raw": true
    },
    {
      "indent": 6,
      "text": "SHSInit(Context);\nSHSUpdate(Context, MasterKey, 16);\nSHSUpdate(Context, SHSpad1, 40);\nSHSUpdate(Context, s, 84);\nSHSUpdate(Context, SHSpad2, 40);\nSHSFinal(Context, Digest);",
      "raw": true
    },
    {
      "indent": 3,
      "text": " MoveMemory(SessionKey, Digest, SessionKeyLength); }",
      "ja": "MoveMemory（SESSIONKEY、ダイジェスト、SessionKeyLength）。 }"
    },
    {
      "indent": 0,
      "text": "3.5. Sample Key Derivations",
      "section_title": true,
      "ja": "3.5。サンプルキー派生の"
    },
    {
      "indent": 3,
      "text": "The following sections illustrate 40-, 56- and 128-bit key derivations. All intermediate values are in hexadecimal.",
      "ja": "以下のセクションでは、40-、56ビットおよび128ビットの鍵導出を示します。すべての中間値は16進数です。"
    },
    {
      "indent": 0,
      "text": "3.5.1. Sample 40-bit Key Derivation",
      "section_title": true,
      "ja": "3.5.1。サンプル40ビットの鍵の導出"
    },
    {
      "indent": 0,
      "text": "Initial Values UserName = \"User\" = 55 73 65 72",
      "ja": "初期値のユーザー名= \"ユーザー\" = 55 73 65 72"
    },
    {
      "indent": 3,
      "text": "Password = \"clientPass\" = 63 00 6C 00 69 00 65 00 6E 00 74 00 50 00 61 00 73 00 73 00",
      "ja": "Pasvord = \"tslientpas\" =オメガ00 SHTS 00 shtya 00 65 00 00 50 00 61 00 00 shtz shtz 00 shtch 00 TO"
    },
    {
      "indent": 3,
      "text": "AuthenticatorChallenge = 5B 5D 7C 7D 7B 3F 2F 3E 3C 2C 60 21 32 26 26 28 PeerChallenge = 21 40 23 24 25 5E 26 2A 28 29 5F 2B 3A 33 7C 7E",
      "ja": "Otntektrhellenj = Khabbの頬感やや弱いの愛の巣S F P 6021のアモスはBrchillnj = 21人の裁判官40 23 24 25 xは任意のJUDGサンダル父アモスの時間Pセンスをカットすることはありません決して決して"
    },
    {
      "indent": 3,
      "text": "Challenge = D0 2E 43 86 BC E9 12 26",
      "ja": "チャレンジ= D0 2E 43 86 BC E9 12 26"
    },
    {
      "indent": 3,
      "text": "NT-Response = 82 30 9E CD 8D 70 8B 5E A0 8F AA 39 81 CD 83 54 42 33 11 4A 3D 85 D6 DF",
      "ja": "NT-応答= 82 30 9E CD 8D 70 8B 5E A0 8F AA 39 81 CD 83 54 42 33 11 4A 3D 85 D6 DF"
    },
    {
      "indent": 0,
      "text": "Step 1: NtPasswordHash(Password, PasswordHash) PasswordHash = 44 EB BA 8D 53 12 B8 D6 11 47 44 11 F5 69 89 AE",
      "ja": "ステップ1：NtPasswordHash（パスワード、PasswordHash）PasswordHash = 44 EB BA 8D 53 12 B8 D6 11 47 44 11 69 89 F5 AE"
    },
    {
      "indent": 0,
      "text": "Step 2: PasswordHashHash = MD4(PasswordHash) PasswordHashHash = 41 C0 0C 58 4B D2 D9 1C 40 17 A2 A1 2F A5 9F 3F",
      "ja": "ステップ2：PasswordHashHash = MD4（PasswordHash）PasswordHashHash = 41 C0 0C 58 4B D2 D9 1C 40 17 A2 A1 2F A5 9F 3F"
    },
    {
      "indent": 0,
      "text": "Step 3: Derive the master key (GetMasterKey()) MasterKey = FD EC E3 71 7A 8C 83 8C B3 88 E5 27 AE 3C DD 31",
      "ja": "ステップ3：71 7A 8C 83 8C B3 88 = FD EC E3マスターキー（GetMasterKey（））MASTERKEYを派生E5 27 AE 3C DD 31"
    },
    {
      "indent": 0,
      "text": "Step 4: Derive the master send session key (GetAsymmetricStartKey()) SendStartKey40 = 8B 7C DC 14 9B 99 3A 1B",
      "ja": "ステップ4：マスター送信セッション鍵を導出（GetAsymmetricStartKey（））SendStartKey40 = 8（b）（c）DC 14 9B 99 3A 1B"
    },
    {
      "indent": 0,
      "text": "Step 5: Derive the initial send session key (GetNewKeyFromSHA()) SendSessionKey40 = D1 26 9E C4 9F A6 2E 3E",
      "ja": "ステップ5：初期送信セッション鍵を導出（GetNewKeyFromSHA（））SendSessionKey40 = D1 26 9E C4 9F A6 2E 3E"
    },
    {
      "indent": 0,
      "text": "Sample Encrypted Message rc4(SendSessionKey40, \"test message\") = 92 91 37 91 7E 58 03 D6 68 D7 58 98",
      "ja": "サンプル暗号化されたメッセージRC4（SendSessionKey40、 \"テストメッセージ\"）= 92 91 37 91 58 03 7E D6 D7 68 58 98"
    },
    {
      "indent": 0,
      "text": "3.5.2. Sample 56-bit Key Derivation",
      "section_title": true,
      "ja": "3.5.2。サンプル56ビットの鍵の導出"
    },
    {
      "indent": 0,
      "text": "Initial Values UserName = \"User\" = 55 73 65 72",
      "ja": "初期値のユーザー名= \"ユーザー\" = 55 73 65 72"
    },
    {
      "indent": 3,
      "text": "Password = \"clientPass\" = 63 00 6C 00 69 00 65 00 6E 00 74 00 50 00 61 00 73 00 73 00",
      "ja": "Pasvord = \"tslientpas\" =オメガ00 SHTS 00 shtya 00 65 00 00 50 00 61 00 00 shtz shtz 00 shtch 00 TO"
    },
    {
      "indent": 3,
      "text": "AuthenticatorChallenge = 5B 5D 7C 7D 7B 3F 2F 3E 3C 2C 60 21 32 26 26 28 PeerChallenge = 21 40 23 24 25 5E 26 2A 28 29 5F 2B 3A 33 7C 7E",
      "ja": "Otntektrhellenj = Khabbの頬感やや弱いの愛の巣S F P 6021のアモスはBrchillnj = 21人の裁判官40 23 24 25 xは任意のJUDGサンダル父アモスの時間Pセンスをカットすることはありません決して決して"
    },
    {
      "indent": 3,
      "text": "Challenge = D0 2E 43 86 BC E9 12 26",
      "ja": "チャレンジ= D0 2E 43 86 BC E9 12 26"
    },
    {
      "indent": 3,
      "text": "NT-Response = 82 30 9E CD 8D 70 8B 5E A0 8F AA 39 81 CD 83 54 42 33 11 4A 3D 85 D6 DF",
      "ja": "NT-応答= 82 30 9E CD 8D 70 8B 5E A0 8F AA 39 81 CD 83 54 42 33 11 4A 3D 85 D6 DF"
    },
    {
      "indent": 0,
      "text": "Step 1: NtPasswordHash(Password, PasswordHash) PasswordHash = 44 EB BA 8D 53 12 B8 D6 11 47 44 11 F5 69 89 AE",
      "ja": "ステップ1：NtPasswordHash（パスワード、PasswordHash）PasswordHash = 44 EB BA 8D 53 12 B8 D6 11 47 44 11 69 89 F5 AE"
    },
    {
      "indent": 0,
      "text": "Step 2: PasswordHashHash = MD4(PasswordHash) PasswordHashHash = 41 C0 0C 58 4B D2 D9 1C 40 17 A2 A1 2F A5 9F 3F",
      "ja": "ステップ2：PasswordHashHash = MD4（PasswordHash）PasswordHashHash = 41 C0 0C 58 4B D2 D9 1C 40 17 A2 A1 2F A5 9F 3F"
    },
    {
      "indent": 0,
      "text": "Step 3: Derive the master key (GetMasterKey()) MasterKey = FD EC E3 71 7A 8C 83 8C B3 88 E5 27 AE 3C DD 31",
      "ja": "ステップ3：71 7A 8C 83 8C B3 88 = FD EC E3マスターキー（GetMasterKey（））MASTERKEYを派生E5 27 AE 3C DD 31"
    },
    {
      "indent": 0,
      "text": "Step 4: Derive the master send session key (GetAsymmetricStartKey()) SendStartKey56 = 8B 7C DC 14 9B 99 3A 1B",
      "ja": "ステップ4：マスター送信セッション鍵を導出（GetAsymmetricStartKey（））SendStartKey56 = 8（b）（c）DC 14 9B 99 3A 1B"
    },
    {
      "indent": 0,
      "text": "Step 5: Derive the initial send session key (GetNewKeyFromSHA()) SendSessionKey56 = D1 5C 00 C4 9F A6 2E 3E",
      "ja": "ステップ5：初期送信セッション鍵を導出（GetNewKeyFromSHA（））SendSessionKey56 = D1 5C 00 C4 9F A6 2E 3E"
    },
    {
      "indent": 0,
      "text": "Sample Encrypted Message rc4(SendSessionKey40, \"test message\") = 3F 10 68 33 FA 44 8D A8 42 BC 57 58",
      "ja": "サンプル暗号化メッセージRC4（SendSessionKey40、 \"テストメッセージ\"）= 3F 10 68 33 FA 44 8D A8 42 BC 57 58"
    },
    {
      "indent": 0,
      "text": "3.5.3. Sample 128-bit Key Derivation",
      "section_title": true,
      "ja": "3.5.3。サンプル128ビットの鍵の導出"
    },
    {
      "indent": 0,
      "text": "Initial Values UserName = \"User\" = 55 73 65 72",
      "ja": "初期値のユーザー名= \"ユーザー\" = 55 73 65 72"
    },
    {
      "indent": 3,
      "text": "Password = \"clientPass\" = 63 00 6C 00 69 00 65 00 6E 00 74 00 50 00 61 00 73 00 73 00",
      "ja": "Pasvord = \"tslientpas\" =オメガ00 SHTS 00 shtya 00 65 00 00 50 00 61 00 00 shtz shtz 00 shtch 00 TO"
    },
    {
      "indent": 3,
      "text": "AuthenticatorChallenge = 5B 5D 7C 7D 7B 3F 2F 3E 3C 2C 60 21 32 26 26 28",
      "ja": "Otntektrhellenj = Khabb頬感やや弱いの愛の巣S F P 6021のアモス決して決して裁判官"
    },
    {
      "indent": 3,
      "text": "PeerChallenge = 21 40 23 24 25 5E 26 2A 28 29 5F 2B 3A 33 7C 7E",
      "ja": "shte FOR PerChallenge = 21 40 23 24 25 26 5E 5F 2A 28 29 2B 33 7TS"
    },
    {
      "indent": 3,
      "text": "Challenge = D0 2E 43 86 BC E9 12 26",
      "ja": "チャレンジ= D0 2E 43 86 BC E9 12 26"
    },
    {
      "indent": 3,
      "text": "NT-Response = 82 30 9E CD 8D 70 8B 5E A0 8F AA 39 81 CD 83 54 42 33 11 4A 3D 85 D6 DF",
      "ja": "NT-応答= 82 30 9E CD 8D 70 8B 5E A0 8F AA 39 81 CD 83 54 42 33 11 4A 3D 85 D6 DF"
    },
    {
      "indent": 0,
      "text": "Step 1: NtPasswordHash(Password, PasswordHash) PasswordHash = 44 EB BA 8D 53 12 B8 D6 11 47 44 11 F5 69 89 AE",
      "ja": "ステップ1：NtPasswordHash（パスワード、PasswordHash）PasswordHash = 44 EB BA 8D 53 12 B8 D6 11 47 44 11 69 89 F5 AE"
    },
    {
      "indent": 0,
      "text": "Step 2: PasswordHashHash = MD4(PasswordHash) PasswordHashHash = 41 C0 0C 58 4B D2 D9 1C 40 17 A2 A1 2F A5 9F 3F",
      "ja": "ステップ2：PasswordHashHash = MD4（PasswordHash）PasswordHashHash = 41 C0 0C 58 4B D2 D9 1C 40 17 A2 A1 2F A5 9F 3F"
    },
    {
      "indent": 0,
      "text": "Step 2: Derive the master key (GetMasterKey()) MasterKey = FD EC E3 71 7A 8C 83 8C B3 88 E5 27 AE 3C DD 31",
      "ja": "ステップ2：71 7A 8C 83 8C B3 88 = FD EC E3マスターキー（GetMasterKey（））MASTERKEYを派生E5 27 AE 3C DD 31"
    },
    {
      "indent": 0,
      "text": "Step 3: Derive the send master session key (GetAsymmetricStartKey())",
      "ja": "ステップ3：送信マスターセッションキーを導出（GetAsymmetricStartKeyを（））"
    },
    {
      "indent": 3,
      "text": "SendStartKey128 = 8B 7C DC 14 9B 99 3A 1B A1 18 CB 15 3F 56 DC CB",
      "ja": "SendStartKey128 = 8（b）（c）DC 14 9B 99（a）（b）A1 18 CB 15 3F 56直流CB"
    },
    {
      "indent": 0,
      "text": "Step 4: Derive the initial send session key (GetNewKeyFromSHA()) SendSessionKey128 = 40 5C B2 24 7A 79 56 E6 E2 11 00 7A E2 7B 22 D4",
      "ja": "ステップ4：初期送信セッション鍵導出（GetNewKeyFromSHAを（））SendSessionKey128 = 40 5C B2 24 7 79 56 E6 E2 11 00 7A E2 7B 22 D4"
    },
    {
      "indent": 0,
      "text": "Sample Encrypted Message rc4(SendSessionKey128, \"test message\") = 81 84 83 17 DF 68 84 62 72 FB 5A BE",
      "ja": "サンプル暗号化メッセージRC4（SendSessionKey128、 \"テストメッセージ\"）が81 84 83 17 DF 68 84 62 72 FB 5AはBE ="
    },
    {
      "indent": 0,
      "text": "4. Deriving MPPE Session Keys from TLS Session Keys",
      "section_title": true,
      "ja": "4. TLSセッションキーからMPPEセッションキーの導出"
    },
    {
      "indent": 3,
      "text": "The Extensible Authentication Protocol (EAP) [10] is a PPP extension that provides support for additional authentication methods within PPP. Transport Level Security (TLS) [11] provides for mutual authentication, integrity-protected ciphersuite negotiation and key exchange between two endpoints. EAP-TLS [12] is an EAP authentication type which allows the use of TLS within the PPP authentication framework. The following sections describe the methods used to derive initial session keys from TLS session keys. 56-, 40- and 128-bit keys are derived using the same algorithm. The only difference is in the length of the keys and their effective strength: 56- and 40-bit keys are 8 octets in length, while 128-bit keys are 16 octets long. Separate keys are derived for the send and receive directions of the session.",
      "ja": "拡張認証プロトコル（EAP）[10]はPPP内で追加の認証方法のサポートを提供PPP拡張です。トランスポートレベルセキュリティ（TLS）[11]は、相互認証、完全性保護された暗号スイートネゴシエーションと2つのエンドポイント間の鍵交換を提供します。 EAP-TLS [12] PPP認証フレームワーク内でTLSの使用を可能にするEAP認証タイプです。次のセクションでは、TLSセッションキーからの最初のセッション鍵を導出するために使用する方法について説明します。 56ビット、40-および128ビットのキーが同じアルゴリズムを使用して導出されます。 128ビットのキーは16オクテット長でありながら、56ビットと40ビットのキーは、長さが8つのオクテットである。唯一の違いは、キーの長さおよびそれらの有効な強度です。別々のキーは、送信のために導出され、セッションの方向を受信して​​います。"
    },
    {
      "indent": 0,
      "text": "4.1. Generating 40-bit Session Keys",
      "section_title": true,
      "ja": "4.1。 40ビットのセッション鍵を生成します"
    },
    {
      "indent": 3,
      "text": "When MPPE is used in conjunction with EAP-TLS authentication, the TLS master secret is used as the master session key.",
      "ja": "MPPEは、EAP-TLS認証と組み合わせて使用​​される場合、TLSマスター秘密は、マスターセッションキーとして使用されています。"
    },
    {
      "indent": 3,
      "text": "The algorithm used to derive asymmetrical master session keys from the TLS master secret is described in [12]. The master session keys are never used to encrypt or decrypt data; they are only used in the derivation of transient session keys.",
      "ja": "TLSマスターシークレットから非対称のマスターセッションキーを導出するために使用されるアルゴリズムは、[12]に記載されています。マスターセッションキーは、データの暗号化や復号化に使用されることはありません。彼らは唯一の過渡セッションキーの導出に使用されています。"
    },
    {
      "indent": 3,
      "text": "Implementation Note",
      "ja": "実装上の注意"
    },
    {
      "indent": 6,
      "text": "If the asymmetrical master keys are less than 8 octets in length, they MUST be padded on the left with zeroes before being used to derive the initial transient session keys. Conversely, if the asymmetrical master keys are more than 8 octets in length, they must be truncated to 8 octets before being used to derive the initial transient session keys.",
      "ja": "非対称のマスターキーの長さが8未満のオクテットであれば、彼らは初期の過渡セッションキーを導出するために使用される前に、ゼロで左側に埋めなければなりません。非対称のマスターキーの長さが8つの以上のオクテットであれば逆に、彼らは初期の過渡セッションキーを導出するために使用される前に、8つのオクテットに切り詰めなければなりません。"
    },
    {
      "indent": 3,
      "text": "The initial transient session keys are obtained by calling the function GetNewKeyFromSHA() (described in [3]):",
      "ja": "初期のトランジエントセッション鍵は、関数GetNewKeyFromSHA（呼び出すことによって得られる）（[3]に記載されています）。"
    },
    {
      "indent": 0,
      "text": "GetNewKeyFromSHA(MasterSendKey, MasterSendKey, 8, SendSessionKey) GetNewKeyFromSHA(MasterReceiveKey, MasterReceiveKey, 8, ReceiveSessionKey)",
      "ja": "GetNewKeyFromSHA（MasterSendKey、MasterSendKey、8、SendSessionKey）GetNewKeyFromSHA（MasterReceiveKey、MasterReceiveKey、8、ReceiveSessionKey）"
    },
    {
      "indent": 3,
      "text": "Next, the effective strength of both keys is reduced by setting the first three octets to known constants:",
      "ja": "次に、両方のキーの有効強度は、既知の定数に最初の3つのオクテットを設定することによって低減されます。"
    },
    {
      "indent": 6,
      "text": "SendSessionKey[0] = ReceiveSessionKey[0] = 0xD1 SendSessionKey[1] = ReceiveSessionKey[1] = 0x26 SendSessionKey[2] = ReceiveSessionKey[2] = 0x9E",
      "ja": "SendSessionKey [0] = ReceiveSessionKey [0] = 0xD1 SendSessionKey [1] = ReceiveSessionKey [1] = 0x26 SendSessionKey [2] = ReceiveSessionKey [2] = 0x9E"
    },
    {
      "indent": 3,
      "text": "Finally, the RC4 tables are initialized using the new session keys:",
      "ja": "最後に、RC4テーブルには、新しいセッションキーを使用して初期化されます。"
    },
    {
      "indent": 6,
      "text": "rc4_key(SendRC4key, 8, SendSessionKey) rc4_key(ReceiveRC4key, 8, ReceiveSessionKey)",
      "ja": "rc4_key（SendRC4key、8、SendSessionKey）rc4_key（ReceiveRC4key、8、ReceiveSessionKey）"
    },
    {
      "indent": 0,
      "text": "4.2. Generating 56-bit Session Keys",
      "section_title": true,
      "ja": "4.2。 56ビットのセッション鍵を生成します"
    },
    {
      "indent": 3,
      "text": "When MPPE is used in conjunction with EAP-TLS authentication, the TLS master secret is used as the master session key.",
      "ja": "MPPEは、EAP-TLS認証と組み合わせて使用​​される場合、TLSマスター秘密は、マスターセッションキーとして使用されています。"
    },
    {
      "indent": 3,
      "text": "The algorithm used to derive asymmetrical master session keys from the TLS master secret is described in [12]. The master session keys are never used to encrypt or decrypt data; they are only used in the derivation of transient session keys.",
      "ja": "TLSマスターシークレットから非対称のマスターセッションキーを導出するために使用されるアルゴリズムは、[12]に記載されています。マスターセッションキーは、データの暗号化や復号化に使用されることはありません。彼らは唯一の過渡セッションキーの導出に使用されています。"
    },
    {
      "indent": 3,
      "text": "Implementation Note",
      "ja": "実装上の注意"
    },
    {
      "indent": 6,
      "text": "If the asymmetrical master keys are less than 8 octets in length, they MUST be padded on the left with zeroes before being used to derive the initial transient session keys. Conversely, if the asymmetrical master keys are more than 8 octets in length, they must be truncated to 8 octets before being used to derive the initial transient session keys.",
      "ja": "非対称のマスターキーの長さが8未満のオクテットであれば、彼らは初期の過渡セッションキーを導出するために使用される前に、ゼロで左側に埋めなければなりません。非対称のマスターキーの長さが8つの以上のオクテットであれば逆に、彼らは初期の過渡セッションキーを導出するために使用される前に、8つのオクテットに切り詰めなければなりません。"
    },
    {
      "indent": 3,
      "text": "The initial transient session keys are obtained by calling the function GetNewKeyFromSHA() (described in [3]):",
      "ja": "初期のトランジエントセッション鍵は、関数GetNewKeyFromSHA（呼び出すことによって得られる）（[3]に記載されています）。"
    },
    {
      "indent": 0,
      "text": "GetNewKeyFromSHA(MasterSendKey, MasterSendKey, 8, SendSessionKey) GetNewKeyFromSHA(MasterReceiveKey, MasterReceiveKey, 8, ReceiveSessionKey)",
      "ja": "GetNewKeyFromSHA（MasterSendKey、MasterSendKey、8、SendSessionKey）GetNewKeyFromSHA（MasterReceiveKey、MasterReceiveKey、8、ReceiveSessionKey）"
    },
    {
      "indent": 3,
      "text": "Next, the effective strength of both keys is reduced by setting the initial octet to a known constant:",
      "ja": "次に、両方のキーの有効強度は、既知の定数に初期オクテットを設定することにより低減されます。"
    },
    {
      "indent": 6,
      "text": "SendSessionKey[0] = ReceiveSessionKey[0] = 0xD1",
      "ja": "SendSessionKey [0] = ReceiveSessionKey [0] = 0xD1"
    },
    {
      "indent": 3,
      "text": "Finally, the RC4 tables are initialized using the new session keys:",
      "ja": "最後に、RC4テーブルには、新しいセッションキーを使用して初期化されます。"
    },
    {
      "indent": 6,
      "text": "rc4_key(SendRC4key, 8, SendSessionKey) rc4_key(ReceiveRC4key, 8, ReceiveSessionKey)",
      "ja": "rc4_key（SendRC4key、8、SendSessionKey）rc4_key（ReceiveRC4key、8、ReceiveSessionKey）"
    },
    {
      "indent": 0,
      "text": "4.3. Generating 128-bit Session Keys",
      "section_title": true,
      "ja": "4.3。 128ビットのセッションキーの生成"
    },
    {
      "indent": 3,
      "text": "When MPPE is used in conjunction with EAP-TLS authentication, the TLS master secret is used as the master session key.",
      "ja": "MPPEは、EAP-TLS認証と組み合わせて使用​​される場合、TLSマスター秘密は、マスターセッションキーとして使用されています。"
    },
    {
      "indent": 3,
      "text": "The algorithm used to derive asymmetrical master session keys from the TLS master secret is described in [12]. Note that the send key on one side is the receive key on the other.",
      "ja": "TLSマスターシークレットから非対称のマスターセッションキーを導出するために使用されるアルゴリズムは、[12]に記載されています。一方の側の送信キーが他の受信キーであることに注意してください。"
    },
    {
      "indent": 3,
      "text": "The master session keys are never used to encrypt or decrypt data; they are only used in the derivation of transient session keys.",
      "ja": "マスターセッションキーは、データの暗号化や復号化に使用されることはありません。彼らは唯一の過渡セッションキーの導出に使用されています。"
    },
    {
      "indent": 3,
      "text": "Implementation Note",
      "ja": "実装上の注意"
    },
    {
      "indent": 6,
      "text": "If the asymmetrical master keys are less than 16 octets in length, they MUST be padded on the left with zeroes before being used to derive the initial transient session keys. Conversely, if the asymmetrical master keys are more than 16 octets in length, they must be truncated to 16 octets before being used to derive the initial transient session keys.",
      "ja": "非対称のマスターキーの長さが16未満のオクテットであれば、彼らは初期の過渡セッションキーを導出するために使用される前に、ゼロで左側に埋めなければなりません。非対称のマスターキーの長さが16以上のオクテットであれば逆に、彼らは初期の過渡セッションキーを導出するために使用される前に、16個のオクテットに切り詰めなければなりません。"
    },
    {
      "indent": 3,
      "text": "The initial transient session keys are obtained by calling the function GetNewKeyFromSHA() (described in [3]):",
      "ja": "初期のトランジエントセッション鍵は、関数GetNewKeyFromSHA（呼び出すことによって得られる）（[3]に記載されています）。"
    },
    {
      "indent": 0,
      "text": "GetNewKeyFromSHA(MasterSendKey, MasterSendKey, 16, SendSessionKey) GetNewKeyFromSHA(MasterReceiveKey, MasterReceiveKey, 16, ReceiveSessionKey)",
      "ja": "GetNewKeyFromSHA（MasterSendKey、MasterSendKey、16、SendSessionKey）GetNewKeyFromSHA（MasterReceiveKey、MasterReceiveKey、16、ReceiveSessionKey）"
    },
    {
      "indent": 3,
      "text": "Finally, the RC4 tables are initialized using the new session keys:",
      "ja": "最後に、RC4テーブルには、新しいセッションキーを使用して初期化されます。"
    },
    {
      "indent": 6,
      "text": "rc4_key(SendRC4key, 16, SendSessionKey) rc4_key(ReceiveRC4key, 16, ReceiveSessionKey)",
      "ja": "rc4_key（SendRC4key、16、SendSessionKey）rc4_key（ReceiveRC4key、16、ReceiveSessionKey）"
    },
    {
      "indent": 0,
      "text": "5. Security Considerations",
      "section_title": true,
      "ja": "5.セキュリティについての考慮事項"
    },
    {
      "indent": 0,
      "text": "5.1. MS-CHAP Credentials",
      "section_title": true,
      "ja": "5.1。 MS-CHAP資格情報"
    },
    {
      "indent": 3,
      "text": "Because of the way in which 40-bit keys are derived from MS-CHAP-1 credentials, the initial 40-bit session key will be identical in all sessions established under the same peer credentials. For this reason, and because RC4 with a 40-bit key length is believed to be a relatively weak cipher, peers SHOULD NOT use 40-bit keys derived from the LAN Manager password hash (as described above) if it can be avoided.",
      "ja": "なぜなら、40ビットのキーがMS-CHAP-1クレデンシャルから誘導される方法で、最初の40ビットのセッション鍵は同一のピア・クレデンシャルの下で確立されたすべてのセッションに同一です。それを避けることができる場合は、このような理由から、および40ビットの鍵長のRC4が比較的弱い暗号であると考えられているので、ピアは（上記のように）LAN Managerパスワードハッシュから派生40ビットキーを使用しないでください。"
    },
    {
      "indent": 3,
      "text": "Since the MPPE session keys are derived from user passwords (in the MS- CHAP-1 and MS-CHAP-2 cases), care should be taken to ensure the selection of strong passwords and passwords should be changed frequently.",
      "ja": "MPPEセッションキーは（MS-CHAP-1およびMS-CHAP-2の場合）、ユーザパスワードから導出されるので、注意が強力なパスワードおよびパスワードの選択を頻繁に変更しなければならないように注意すべきです。"
    },
    {
      "indent": 0,
      "text": "5.2. EAP-TLS Credentials",
      "section_title": true,
      "ja": "5.2。 EAP-TLSの資格"
    },
    {
      "indent": 3,
      "text": "The strength of the session keys is dependent upon the security of the TLS protocol.",
      "ja": "セッションキーの強度は、TLSプロトコルのセキュリティに依存しています。"
    },
    {
      "indent": 3,
      "text": "The EAP server may be on a separate machine from the PPP authenticator; if this is the case, adequate care must be taken in the transmission of the EAP-TLS master keys to the authenticator.",
      "ja": "EAPサーバは、PPP認証とは別のマシン上にあってもよいです。この場合、十分な注意がオーセンティケータにEAP-TLSマスターキーの送信に注意しなければなりません。"
    },
    {
      "indent": 0,
      "text": "6. References",
      "section_title": true,
      "ja": "6.参照"
    },
    {
      "indent": 3,
      "text": "[1] Simpson, W., \"The Point-to-Point Protocol (PPP)\", STD 51, RFC 1661, July 1994.",
      "ja": "[1]シンプソン、W.、 \"ポイントツーポイントプロトコル（PPP）\"、STD 51、RFC 1661、1994年7月。"
    },
    {
      "indent": 3,
      "text": "[2] Zorn, G. and S. Cobb, \"Microsoft PPP CHAP Extensions\", RFC 2433, October 1998.",
      "ja": "[2]ソーン、G.とS.コブ、 \"マイクロソフトPPP CHAP拡張機能\"、RFC 2433、1998年10月。"
    },
    {
      "indent": 3,
      "text": "[3] Pall, G. and G. Zorn, \"Microsoft Point-to-Point Encryption (MPPE) RFC 3078, March 2001.",
      "ja": "[3]ポール、G.とG.ツォルン、「Microsoft Point-to-Point暗号化（MPPE）RFC 3078、2001年3月。"
    },
    {
      "indent": 3,
      "text": "[4] RC4 is a proprietary encryption algorithm available under license from RSA Data Security Inc. For licensing information, contact: RSA Data Security, Inc. 100 Marine Parkway Redwood City, CA 94065-1031",
      "ja": "[4] RC4は情報、接触のライセンスについては、RSAデータセキュリティ社からライセンスの下で利用可能な独自の暗号化アルゴリズムです：RSA Data Security社の100マリンパークウェイレッドウッドシティー、カリフォルニア州94065から1031"
    },
    {
      "indent": 3,
      "text": "[5] Pall, G., \"Microsoft Point-to-Point Compression (MPPC) Protocol\", RFC 2118, March 1997.",
      "ja": "[5]ポール、G.、 \"マイクロソフトポイントツーポイント圧縮（MPPC）プロトコル\"、RFC 2118、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[6] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[6]ブラドナーのは、S.は、BCP 14、RFC 2119、1997年3月の \"RFCsにおける使用のためのレベルを示すために\"。"
    },
    {
      "indent": 3,
      "text": "[7] \"Secure Hash Standard\", Federal Information Processing Standards Publication 180-1, National Institute of Standards and Technology, April 1995.",
      "ja": "[7]、連邦情報処理規格180-1公報、米国国立標準技術研究所、1995年4月「ハッシュ標準セキュア」。"
    },
    {
      "indent": 3,
      "text": "[8] Zorn, G., \"Microsoft PPP CHAP Extensions, Version 2\", RFC 2759, January 2000.",
      "ja": "[8]ソーン、G.、 \"マイクロソフトPPP CHAP拡張、Version 2\"、RFC 2759、2000年1月。"
    },
    {
      "indent": 3,
      "text": "[9] Simpson, W., \"PPP Challenge Handshake Authentication Protocol (CHAP)\", RFC 1994, August 1996.",
      "ja": "[9]シンプソン、W.、 \"PPPチャレンジハンドシェイク認証プロトコル（CHAP）\"、RFC 1994、1996年8月。"
    },
    {
      "indent": 3,
      "text": "[10] Blunk, L. and J. Vollbrecht, \"PPP Extensible Authentication Protocol (EAP)\", RFC 2284, March 1998.",
      "ja": "[10]ブルンク、L.及びJ. Vollbrecht、 \"PPP拡張認証プロトコル（EAP）\"、RFC 2284、1998年3月。"
    },
    {
      "indent": 3,
      "text": "[11] Dierks, T. and C. Allen, \"The TLS Protocol Version 1.0\", RFC 2246, January 1999.",
      "ja": "[11]ダークス、T.とC.アレン、 \"TLSプロトコルバージョン1.0\"、RFC 2246、1999年1月。"
    },
    {
      "indent": 3,
      "text": "[12] Aboba, B. and D. Simon, \"PPP EAP TLS Authentication Protocol\", RFC 2716, October 1999.",
      "ja": "[12] Aboba、B.及びD.シモン、 \"PPP EAP TLS認証プロトコル\"、RFC 2716、1999年10月。"
    },
    {
      "indent": 0,
      "text": "7. Acknowledgements",
      "section_title": true,
      "ja": "7.謝辞"
    },
    {
      "indent": 3,
      "text": "Anthony Bell, Richard B. Ward, Terence Spies and Thomas Dimitri, all of Microsoft Corporation, significantly contributed to the design and development of MPPE.",
      "ja": "アンソニー・ベル、リチャード・B.ウォード、テレンスのスパイとトーマス・ディミトリ、Microsoft Corporationの全ては、大幅MPPEの設計と開発に貢献しました。"
    },
    {
      "indent": 3,
      "text": "Additional thanks to Robert Friend, Joe Davies, Jody Terrill, Archie Cobbs, Mark Deuser, Vijay Baliga, Brad Robel-Forrest and Jeff Haag for useful feedback.",
      "ja": "有用なフィードバックのためのロバート・フレンド、ジョー・デイヴィス、ジョディ・テリル、アーチーCobbs、マーク・Deuser、ビジェイBaliga、ブラッドRobel-フォレストとジェフ・ハーグへの追加のおかげ。"
    },
    {
      "indent": 3,
      "text": "The technical portions of this memo were completed while the author was employed by Microsoft Corporation.",
      "ja": "著者は、マイクロソフト社が採用している間にこのメモの技術的な部分が完成しました。"
    },
    {
      "indent": 0,
      "text": "8. Author's Address",
      "section_title": true,
      "ja": "8.著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Questions about this memo can also be directed to:",
      "ja": "このメモに関する質問も対象とすることができます。"
    },
    {
      "indent": 3,
      "text": "Glen Zorn cisco Systems 500 108th Avenue N.E. Suite 500 Bellevue, Washington 98004 USA",
      "ja": "グレンツォルンシスコシステムズ500第108アベニューN.E.スイート500ベルビュー、ワシントン98004 USA"
    },
    {
      "indent": 3,
      "text": "Phone: +1 425 438 8218 FAX: +1 425 438 1848 EMail: gwz@cisco.com",
      "ja": "電話：+1 425 438 8218 FAX：+1 425 438 1848 Eメール：gwz@cisco.com"
    },
    {
      "indent": 0,
      "text": "9. Full Copyright Statement",
      "section_title": true,
      "ja": "9.完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2001). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2001）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.",
      "ja": "この文書とその翻訳は、コピーして他の人に提供し、それ以外についてはコメントまたは派生物は、いかなる種類の制限もなく、全体的にまたは部分的に、準備コピーし、公表して配布することができることを説明したり、その実装を支援することができます、上記の著作権表示とこの段落は、すべてのそのようなコピーや派生物に含まれていることを条件とします。しかし、この文書自体は著作権のための手順はで定義されている場合には、インターネット標準を開発するために必要なものを除き、インターネットソサエティもしくは他のインターネット関連団体に著作権情報や参照を取り除くなど、どのような方法で変更されないかもしれませんインターネット標準化プロセスが続く、または英語以外の言語に翻訳するために、必要に応じなければなりません。"
    },
    {
      "indent": 3,
      "text": "The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.",
      "ja": "上記の制限は永久で、インターネット学会やその後継者や譲渡者によって取り消されることはありません。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein is provided on an \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書とここに含まれている情報は、基礎とインターネットソサエティおよびインターネットエンジニアリングタスクフォースはすべての保証を否認し、明示または黙示、その情報の利用がない任意の保証を含むがこれらに限定されない「として、」上に設けられています特定の目的への権利または商品性または適合性の黙示の保証を侵害します。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "了承"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFC Editor機能のための基金は現在、インターネット協会によって提供されます。"
    }
  ]
}