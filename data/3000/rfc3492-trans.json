{
  "title": {
    "text": "RFC 3492 - Punycode: A Bootstring encoding of Unicode for Internationalized Domain Names in Applications (IDNA)",
    "ja": "RFC 3492 - ピュニコード：アプリケーションにおける国際化ドメイン名のUnicodeのブートストリングのエンコード（IDNA）"
  },
  "number": 3492,
  "created_at": "2019-10-29 05:44:47.451146+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                        A. Costello\nRequest for Comments: 3492                 Univ. of California, Berkeley\nCategory: Standards Track                                     March 2003",
      "raw": true
    },
    {
      "indent": 7,
      "text": "       Punycode: A Bootstring encoding of Unicode\nfor Internationalized Domain Names in Applications (IDNA)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "ja": "このメモの位置付け"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "ja": "この文書は、インターネットコミュニティのためのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態と状態への「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2003). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2003）。全著作権所有。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "Punycode is a simple and efficient transfer encoding syntax designed for use with Internationalized Domain Names in Applications (IDNA). It uniquely and reversibly transforms a Unicode string into an ASCII string. ASCII characters in the Unicode string are represented literally, and non-ASCII characters are represented by ASCII characters that are allowed in host name labels (letters, digits, and hyphens). This document defines a general algorithm called Bootstring that allows a string of basic code points to uniquely represent any string of code points drawn from a larger set. Punycode is an instance of Bootstring that uses particular parameter values specified by this document, appropriate for IDNA.",
      "ja": "ピュニコードは、アプリケーション（IDNA）で国際化ドメイン名で使用するために設計されたシンプルかつ効率的な転送エンコードの構文です。それはユニークかつ可逆ASCII文字列にUnicode文字列を変換します。 Unicode文字列内のASCII文字は、文字通り表現され、非ASCII文字は、ホスト名のラベル（文字、数字、およびハイフン）で許可されているASCII文字で表現されています。この文書は、基本的なコードポイントの列を一意により大きなセットから引き出されたコードポイントの任意の文字列を表現することを可能にするブートストリングと呼ばれる一般的なアルゴリズムを定義します。ピュニコードはIDNAのために適切な本文書で指定された特定のパラメータ値を使用してブートストリングのインスタンスです。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction...............................................2\n    1.1 Features..............................................2\n    1.2 Interaction of protocol parts.........................3\n2. Terminology................................................3\n3. Bootstring description.....................................4\n    3.1 Basic code point segregation..........................4\n    3.2 Insertion unsort coding...............................4\n    3.3 Generalized variable-length integers..................5\n    3.4 Bias adaptation.......................................7\n4. Bootstring parameters......................................8\n5. Parameter values for Punycode..............................8\n6. Bootstring algorithms......................................9",
      "raw": true
    },
    {
      "indent": 3,
      "text": "    6.1 Bias adaptation function.............................10\n    6.2 Decoding procedure...................................11\n    6.3 Encoding procedure...................................12\n    6.4 Overflow handling....................................13\n7. Punycode examples.........................................14\n    7.1 Sample strings.......................................14\n    7.2 Decoding traces......................................17\n    7.3 Encoding traces......................................19\n8. Security Considerations...................................20\n9. References................................................21\n    9.1 Normative References.................................21\n    9.2 Informative References...............................21\nA. Mixed-case annotation.....................................22\nB. Disclaimer and license....................................22\nC. Punycode sample implementation............................23\nAuthor's Address.............................................34\nFull Copyright Statement.....................................35",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "[IDNA] describes an architecture for supporting internationalized domain names. Labels containing non-ASCII characters can be represented by ACE labels, which begin with a special ACE prefix and contain only ASCII characters. The remainder of the label after the prefix is a Punycode encoding of a Unicode string satisfying certain constraints. For the details of the prefix and constraints, see [IDNA] and [NAMEPREP].",
      "ja": "[IDNA]国際化ドメイン名をサポートするためのアーキテクチャについて説明します。非ASCII文字を含むラベルは、特別なACEプレフィックスで始まり、ASCII文字のみが含まれているACEラベル、で表すことができます。接頭後にラベルの残りの部分は、特定の制約を満たすUnicode文字列のピュニコードエンコーディングです。プレフィックスと制約の詳細については、[NAMEPREP] [IDNA]を参照して。"
    },
    {
      "indent": 3,
      "text": "Punycode is an instance of a more general algorithm called Bootstring, which allows strings composed from a small set of \"basic\" code points to uniquely represent any string of code points drawn from a larger set. Punycode is Bootstring with particular parameter values appropriate for IDNA.",
      "ja": "ピュニコードは、「基本」コードポイントの小さい集合からなる文字列を一意により大きなセットから引き出されたコードポイントの任意の文字列を表現することを可能にするブートストリングと呼ばれるより一般的なアルゴリズムの例です。ピュニコードはIDNAに適した特定のパラメータ値を用いてブートストリングれます。"
    },
    {
      "indent": 0,
      "text": "1.1 Features",
      "section_title": true,
      "ja": "1.1特長"
    },
    {
      "indent": 3,
      "text": "Bootstring has been designed to have the following features:",
      "ja": "ブートストリングは、次のような特徴を持つように設計されています："
    },
    {
      "indent": 3,
      "text": "* Completeness: Every extended string (sequence of arbitrary code points) can be represented by a basic string (sequence of basic code points). Restrictions on what strings are allowed, and on length, can be imposed by higher layers.",
      "ja": "*完全性：すべての拡張文字列（任意のコード・ポイントのシーケンス）を基本文字列（基本コードポイントのシーケンス）で表すことができます。どのような文字列の制限が許可され、そして長さに、上位層によって課すことができます。"
    },
    {
      "indent": 3,
      "text": "* Uniqueness: There is at most one basic string that represents a given extended string.",
      "ja": "*一意性：指定した拡張文字列を表し、最大1つの基本的な文字列があります。"
    },
    {
      "indent": 3,
      "text": "* Reversibility: Any extended string mapped to a basic string can be recovered from that basic string.",
      "ja": "*可逆性：基本的な文字列にマッピングされた任意の拡張文字列は、その基本的な文字列から回収することができます。"
    },
    {
      "indent": 3,
      "text": "* Efficient encoding: The ratio of basic string length to extended string length is small. This is important in the context of domain names because RFC 1034 [RFC1034] restricts the length of a domain label to 63 characters.",
      "ja": "*効率的な符号化：拡張された文字列の長さに基本的な文字列の長さの比が小さいです。 RFC 1034 [RFC1034]は63個の文字にドメインラベルの長さを制限しているためこれは、ドメイン名の文脈で重要です。"
    },
    {
      "indent": 3,
      "text": "* Simplicity: The encoding and decoding algorithms are reasonably simple to implement. The goals of efficiency and simplicity are at odds; Bootstring aims at a good balance between them.",
      "ja": "*シンプル：符号化と復号化アルゴリズムは、合理的に実現するのは簡単です。効率性とシンプルさの目標は対立しています。ブートストリングは、それらの間の良好なバランスを目指しています。"
    },
    {
      "indent": 3,
      "text": "* Readability: Basic code points appearing in the extended string are represented as themselves in the basic string (although the main purpose is to improve efficiency, not readability).",
      "ja": "*可読性：（主な目的は、効率ではなく、読みやすさを改善することであるが）、拡張文字列に現れる基本的なコードポイントは基本文字列でそれ自体として表されます。"
    },
    {
      "indent": 3,
      "text": "Punycode can also support an additional feature that is not used by the ToASCII and ToUnicode operations of [IDNA]. When extended strings are case-folded prior to encoding, the basic string can use mixed case to tell how to convert the folded string into a mixed-case string. See appendix A \"Mixed-case annotation\".",
      "ja": "ピュニコードまた、[IDNA]のもしToASCIIとのToUnicode操作で使用されていない追加の機能をサポートすることができます。拡張文字列は、大文字小文字が変換符号化の前にあるときは、基本的な文字列は、大文字と小文字の文字列に折りたたまれた文字列を変換する方法を教えて大文字と小文字を使用することができます。 「混合ケース注釈を」付録を参照してください。"
    },
    {
      "indent": 0,
      "text": "1.2 Interaction of protocol parts",
      "section_title": true,
      "ja": "プロトコル部品の1.2インタラクション"
    },
    {
      "indent": 3,
      "text": "Punycode is used by the IDNA protocol [IDNA] for converting domain labels into ASCII; it is not designed for any other purpose. It is explicitly not designed for processing arbitrary free text.",
      "ja": "ピュニコードは、ASCIIにドメインラベルを変換するIDNAプロトコル[IDNA]で使用されます。それは、他の目的のために設計されていません。これは、明示的に任意のフリーテキストを処理するために設計されていません。"
    },
    {
      "indent": 0,
      "text": "2. Terminology",
      "section_title": true,
      "ja": "2.用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14, RFC 2119 [RFC2119].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はありますBCP 14、RFC 2119 [RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 3,
      "text": "A code point is an integral value associated with a character in a coded character set.",
      "ja": "コード・ポイントは、符号化された文字セット内の文字に関連付けられた積分値です。"
    },
    {
      "indent": 3,
      "text": "As in the Unicode Standard [UNICODE], Unicode code points are denoted by \"U+\" followed by four to six hexadecimal digits, while a range of code points is denoted by two hexadecimal numbers separated by \"..\", with no prefixes.",
      "ja": "コードポイントの範囲はないプレフィックスと、「..」で区切られた2つの16進数で表されている間Unicode標準[UNICODE]のように、Unicodeコードポイントは、4〜6桁の16進数字が続く「U +」で示されています。"
    },
    {
      "indent": 3,
      "text": "The operators div and mod perform integer division; (x div y) is the quotient of x divided by y, discarding the remainder, and (x mod y) is the remainder, so (x div y) * y + (x mod y) == x. Bootstring uses these operators only with nonnegative operands, so the quotient and remainder are always nonnegative.",
      "ja": "演算子DIVとMODは整数除算を実行します。 （XのDIVのY）x ==残りを廃棄、yで割ったXの商であり、（MOD Y x）の余りであるので、（MOD Y X）（Xのdiv Y）*のY +。ブートストリングは、非負オペランドでこれらの演算子を使用するため、商と余りは常に非負です。"
    },
    {
      "indent": 3,
      "text": "The break statement jumps out of the innermost loop (as in C).",
      "ja": "break文は、（Cのように）最内ループの外にジャンプします。"
    },
    {
      "indent": 3,
      "text": "An overflow is an attempt to compute a value that exceeds the maximum value of an integer variable.",
      "ja": "オーバーフローは、整数変数の最大値を超える値を計算しようとする試みです。"
    },
    {
      "indent": 0,
      "text": "3. Bootstring description",
      "section_title": true,
      "ja": "3.ブートストリングの説明"
    },
    {
      "indent": 3,
      "text": "Bootstring represents an arbitrary sequence of code points (the \"extended string\") as a sequence of basic code points (the \"basic string\"). This section describes the representation. Section 6 \"Bootstring algorithms\" presents the algorithms as pseudocode. Sections 7.1 \"Decoding traces\" and 7.2 \"Encoding traces\" trace the algorithms for sample inputs.",
      "ja": "ブートストリングは、基本コード・ポイント（「基本的な文字列」）のシーケンスとしてコード・ポイントの任意の配列（「拡張文字列」）を表します。このセクションでは、表現を記述します。第6章「ブートストリングアルゴリズムは」擬似コードなどのアルゴリズムを提示します。セクション7.1「デコード・トレース」と7.2のサンプル入力のためのアルゴリズムをたどる「エンコーディングはトレース」。"
    },
    {
      "indent": 3,
      "text": "The following sections describe the four techniques used in Bootstring. \"Basic code point segregation\" is a very simple and efficient encoding for basic code points occurring in the extended string: they are simply copied all at once. \"Insertion unsort coding\" encodes the non-basic code points as deltas, and processes the code points in numerical order rather than in order of appearance, which typically results in smaller deltas. The deltas are represented as \"generalized variable-length integers\", which use basic code points to represent nonnegative integers. The parameters of this integer representation are dynamically adjusted using \"bias adaptation\", to improve efficiency when consecutive deltas have similar magnitudes.",
      "ja": "次のセクションでは、ブートストリングに使用される4つのテクニックについて説明します。 「基本的なコードポイントの分離は、」拡張された文字列で発生した基本的なコードポイントのための非常にシンプルかつ効率的な符号化である：彼らは単にすべてを一度にコピーされます。 「コーディングソート解除挿入」は、典型的には、より小さなデルタをもたらす、デルタのような非基本コードポイントを符号化し、番号順ではなく、出現順にコードポイントを処理します。デルタは、非負整数を表すために、基本的なコードポイントを使用して、「一般化可変長整数」として表されます。この整数表現のパラメータを動的に連続デルタは同様の大きさを有するとき、効率を改善するために、「バイアス適応」を使用して調整されます。"
    },
    {
      "indent": 0,
      "text": "3.1 Basic code point segregation",
      "section_title": true,
      "ja": "3.1 Basicのコードポイントの分離"
    },
    {
      "indent": 3,
      "text": "All basic code points appearing in the extended string are represented literally at the beginning of the basic string, in their original order, followed by a delimiter if (and only if) the number of basic code points is nonzero. The delimiter is a particular basic code point, which never appears in the remainder of the basic string. The decoder can therefore find the end of the literal portion (if there is one) by scanning for the last delimiter.",
      "ja": "拡張された文字列に現れるすべての基本コードポイントは、基本的なコードポイントの数がゼロでない（そして場合のみ）場合デリミタ続いて、元の順序で、基本的な文字列の先頭に文字通り表されます。デリミタは、基本的な文字列の残りの部分に表示されません特定の基本的なコード・ポイントです。最後のデリミタのスキャンによって（存在する場合）、デコーダは、したがって、リテラル部分の終わりを見つけることができます。"
    },
    {
      "indent": 0,
      "text": "3.2 Insertion unsort coding",
      "section_title": true,
      "ja": "3.2挿入ソート解除コーディング"
    },
    {
      "indent": 3,
      "text": "The remainder of the basic string (after the last delimiter if there is one) represents a sequence of nonnegative integral deltas as generalized variable-length integers, described in section 3.3. The meaning of the deltas is best understood in terms of the decoder.",
      "ja": "（存在する場合、最後のデリミタの後に）基本的な文字列の残りの部分は、セクション3.3で説明した一般化可変長整数として非負積分デルタの配列を表します。デルタの意味は、最高のデコーダの観点で理解されています。"
    },
    {
      "indent": 3,
      "text": "The decoder builds the extended string incrementally. Initially, the extended string is a copy of the literal portion of the basic string (excluding the last delimiter). The decoder inserts non-basic code points, one for each delta, into the extended string, ultimately arriving at the final decoded string.",
      "ja": "デコーダは、増分拡張文字列を構築します。最初に、拡張された文字列は、（最後の区切り文字を除く）の基本的な文字列リテラルの一部のコピーです。デコーダは、最終的に最終的なデコードされた文字列に到着し、拡張された文字列に、非基本コードポイント、各デルタのための1つを挿入します。"
    },
    {
      "indent": 3,
      "text": "At the heart of this process is a state machine with two state variables: an index i and a counter n. The index i refers to a position in the extended string; it ranges from 0 (the first position) to the current length of the extended string (which refers to a potential position beyond the current end). If the current state is <n,i>, the next state is <n,i+1> if i is less than the length of the extended string, or <n+1,0> if i equals the length of the extended string. In other words, each state change causes i to increment, wrapping around to zero if necessary, and n counts the number of wrap-arounds.",
      "ja": "インデックスiとカウンタn：このプロセスの心臓部には2つの状態変数とステートマシンがあります。インデックスiは、拡張文字列内の位置を指します。それが0（最初の位置）から（現在の端を越えて潜在的位置を意味する）、拡張文字列の現在の長さの範囲です。現在の状態である場合には<N、i>は、次の状態は、<N、I + 1> iは、拡張文字列の長さよりも小さい場合、または<N + 1,0> iは、拡張の長さと等しい場合文字列。換言すれば、各状態変化が必要な場合、ゼロにラップアラウンド、iをインクリメントさせ、そしてnはラップアラウンドの数をカウントします。"
    },
    {
      "indent": 3,
      "text": "Notice that the state always advances monotonically (there is no way for the decoder to return to an earlier state). At each state, an insertion is either performed or not performed. At most one insertion is performed in a given state. An insertion inserts the value of n at position i in the extended string. The deltas are a run-length encoding of this sequence of events: they are the lengths of the runs of non-insertion states preceeding the insertion states. Hence, for each delta, the decoder performs delta state changes, then an insertion, and then one more state change. (An implementation need not perform each state change individually, but can instead use division and remainder calculations to compute the next insertion state directly.) It is an error if the inserted code point is a basic code point (because basic code points were supposed to be segregated as described in section 3.1).",
      "ja": "状態は常に単調に進んでいること（デコーダが以前の状態に戻す方法はありません）に注意してください。各状態で、挿入を行うか、行わないのいずれか。せいぜい1つの挿入が与えられた状態で行われます。挿入は、拡張文字列内の位置iにおけるnの値を挿入します。デルタは、この一連のイベントのランレングス符号化されている：彼らは、挿入状態に先行する非挿入状態のランの長さです。したがって、各デルタのために、デコーダは、デルタ状態の変更、挿入、次いでもう一つの状態変化を行います。 （実装は、個々の状態の変更を行う必要はなく、代わりに、直接次の挿入状態を計算する除算と剰余演算を使用することができる。）基本的なコードポイントがになっていたので、挿入されたコードポイント（基本コード・ポイントである場合は、エラーでありますセクション3.1で説明したように）分離します。"
    },
    {
      "indent": 3,
      "text": "The encoder's main task is to derive the sequence of deltas that will cause the decoder to construct the desired string. It can do this by repeatedly scanning the extended string for the next code point that the decoder would need to insert, and counting the number of state changes the decoder would need to perform, mindful of the fact that the decoder's extended string will include only those code points that have already been inserted. Section 6.3 \"Encoding procedure\" gives a precise algorithm.",
      "ja": "エンコーダの主なタスクは、デコーダが目的の文字列を構築するようになりますデルタのシーケンスを導出することです。これは、デコーダは、デコーダの拡張文字列だけのものが挙げられるだろうという事実を、意識実行する必要があります変わり繰り返しデコーダを挿入するために必要となる次のコード・ポイントのために拡張された文字列をスキャンし、状態の数をカウントすることによって、これを行うことができます既に挿入されたコードポイント。 6.3節「符号化手順は、」正確なアルゴリズムを提供します。"
    },
    {
      "indent": 0,
      "text": "3.3 Generalized variable-length integers",
      "section_title": true,
      "ja": "3.3一般化可変長整数"
    },
    {
      "indent": 3,
      "text": "In a conventional integer representation the base is the number of distinct symbols for digits, whose values are 0 through base-1. Let digit_0 denote the least significant digit, digit_1 the next least significant, and so on. The value represented is the sum over j of digit_j * w(j), where w(j) = base^j is the weight (scale factor) for position j. For example, in the base 8 integer 437, the digits are 7, 3, and 4, and the weights are 1, 8, and 64, so the value is 7 + 3*8 + 4*64 = 287. This representation has two disadvantages: First, there are multiple encodings of each value (because there can be extra zeros in the most significant positions), which is inconvenient when unique encodings are needed. Second, the integer is not self-delimiting, so if multiple integers are concatenated the boundaries between them are lost.",
      "ja": "従来の整数表現のベースは、値ベース-1を介して0である数字のための別個のシンボルの数です。 digit_0最下位桁を示すものと、その次の最下位、およびdigit_1。示される値は、位置jについてW（J）=ベース^ jは重み（スケールファクタ）である（J）、W digit_j *のJにわたる和です。値は、この表現が有する7 + 3 * 8 + 4×64 = 287であるので、例えば、基数8の整数437で、数字は7,3、および4であり、重みは、1~8であり、そして64 2つの欠点は：まず、ユニークなエンコーディングが必要な場合には不便である各値（最上位の位置に余分なゼロが存在する可能性があるため）、複数の符号化方式があります。第二に、整数は自己区切りではないので、複数の整数が連結されている場合は、それらの間の境界が失われます。"
    },
    {
      "indent": 3,
      "text": "The generalized variable-length representation solves these two problems. The digit values are still 0 through base-1, but now the integer is self-delimiting by means of thresholds t(j), each of which is in the range 0 through base-1. Exactly one digit, the most significant, satisfies digit_j < t(j). Therefore, if several integers are concatenated, it is easy to separate them, starting with the first if they are little-endian (least significant digit first), or starting with the last if they are big-endian (most significant digit first). As before, the value is the sum over j of digit_j * w(j), but the weights are different:",
      "ja": "一般可変長表現は、この2つの問題を解決します。桁の値は、ベース1を介して依然として0であるが、今整数は、ベース1を介して範囲0であり、各々が閾値T（j）は、によって自己区切りです。正確に1桁、最も重要な、満足しdigit_j <T（J）。いくつかの整数が連結されている場合したがって、彼らが（最初の最下位桁）リトルエンディアンであれば最初から始まる、または、彼らは（最初の最上位桁）ビッグエンディアンであれば最後から開始して、それらを分離することは容易です。前と同じように、値（J）w * digit_jのJにわたって和が、重みが異なります。"
    },
    {
      "indent": 6,
      "text": "w(0) = 1 w(j) = w(j-1) * (base - t(j-1)) for j > 0",
      "ja": "J> 0  - （0）= 1、W（J）= W（J-1）*（T（J-1）塩基）w"
    },
    {
      "indent": 3,
      "text": "For example, consider the little-endian sequence of base 8 digits 734251... Suppose the thresholds are 2, 3, 5, 5, 5, 5... This implies that the weights are 1, 1*(8-2) = 6, 6*(8-3) = 30, 30*(8-5) = 90, 90*(8-5) = 270, and so on. 7 is not less than 2, and 3 is not less than 3, but 4 is less than 5, so 4 is the last digit. The value of 734 is 7*1 + 3*6 + 4*30 = 145. The next integer is 251, with value 2*1 + 5*6 + 1*30 = 62. Decoding this representation is very similar to decoding a conventional integer: Start with a current value of N = 0 and a weight w = 1. Fetch the next digit d and increase N by d * w. If d is less than the current threshold (t) then stop, otherwise increase w by a factor of (base - t), update t for the next position, and repeat.",
      "ja": "例えば、閾値は2、3、5、5、5、5であると仮定...ベースのリトルエンディアンシーケンスを8桁734251を考える...これは、重みが1、1 *（8-2）であることを意味します= 6,6 *（8-3）= 30、30 *（8-5）= 90、90 *（8-5）= 270、など。図7は、2以上であり、3は3以上であるが、4 SO 4を最後の桁であり、5未満です。 734の値は、7×1 + 3 * 6 + 4×30 = 145次の整数値で、251は2 * 1 + 5 * 6 + 1×30 = 62この表現を復号化する復号化することは非常に類似しています従来の整数：次の桁dを取得し、D * WによりNを増やす1. = N = 0の電流値と重みwから開始します。 dが電流閾値（T）よりも小さい場合、停止し、そうでない場合（ベース -  t）の係数でwが増加、次の位置tを更新し、繰り返します。"
    },
    {
      "indent": 3,
      "text": "Encoding this representation is similar to encoding a conventional integer: If N < t then output one digit for N and stop, otherwise output the digit for t + ((N - t) mod (base - t)), then replace N with (N - t) div (base - t), update t for the next position, and repeat.",
      "ja": "この表現を符号化することは、従来の整数を符号化に類似している：NのためのN <T、出力一桁場合や停止、そうでなければ出力のT +ため桁（（N  -  T）MOD（ベース -  T））、次いで（とNを置き換えますN  -  T）DIV（ベース -  t）は、次の位置、及び繰り返しの更新T。"
    },
    {
      "indent": 3,
      "text": "For any particular set of values of t(j), there is exactly one generalized variable-length representation of each nonnegative integral value.",
      "ja": "T（j）の値の任意の特定のセットについて、各非負整数値の正確に一つの一般化された可変長表現があります。"
    },
    {
      "indent": 3,
      "text": "Bootstring uses little-endian ordering so that the deltas can be separated starting with the first. The t(j) values are defined in terms of the constants base, tmin, and tmax, and a state variable called bias:",
      "ja": "ブートストリングは、デルタが最初から始まる分離することができるようにリトルエンディアン順序付けを使用しています。 T（j）の値は定数ベース、TMINとTMAX、および状態変数と呼ばれるバイアスの観点で定義されています。"
    },
    {
      "indent": 6,
      "text": "t(j) = base * (j + 1) - bias, clamped to the range tmin through tmax",
      "ja": "T（J）=ベース*（J + 1） - バイアスは、TMAXを介し範囲TMINにクランプ"
    },
    {
      "indent": 3,
      "text": "The clamping means that if the formula yields a value less than tmin or greater than tmax, then t(j) = tmin or tmax, respectively. (In the pseudocode in section 6 \"Bootstring algorithms\", the expression base * (j + 1) is denoted by k for performance reasons.) These t(j) values cause the representation to favor integers within a particular range determined by the bias.",
      "ja": "クランプ式はそれぞれ、次にT（J）= TMINまたはTMAX、TMAXよりTMINよりも小さいか大きい値が得られる場合、その意味します。 （セクション6の擬似コード「ブートストリングアルゴリズム」は、式ベース*（J + 1）は、パフォーマンス上の理由Kによって示される。）これらのT（j）の値が表現はバイアスによって決定される特定の範囲内の整数を支持させます。"
    },
    {
      "indent": 0,
      "text": "3.4 Bias adaptation",
      "section_title": true,
      "ja": "3.4バイアスの適応"
    },
    {
      "indent": 3,
      "text": "After each delta is encoded or decoded, bias is set for the next delta as follows:",
      "ja": "各差分が符号化又は復号化された後に、次のように、バイアスは次のデルタのために設定されています。"
    },
    {
      "indent": 3,
      "text": "1. Delta is scaled in order to avoid overflow in the next step:",
      "section_title": true,
      "ja": "1.デルタは、次のステップでオーバーフローを防止するためにスケーリングされています。"
    },
    {
      "indent": 9,
      "text": "let delta = delta div 2",
      "ja": "デルタ=デルタのdiv 2を聞かせて"
    },
    {
      "indent": 6,
      "text": "But when this is the very first delta, the divisor is not 2, but instead a constant called damp. This compensates for the fact that the second delta is usually much smaller than the first.",
      "ja": "これは非常に最初のデルタであるときしかし、除数が2ではなく、定数が湿っと呼ばれます。これは、第2のデルタは通常、最初のものよりはるかに小さいという事実を補償します。"
    },
    {
      "indent": 3,
      "text": "2. Delta is increased to compensate for the fact that the next delta will be inserting into a longer string:",
      "ja": "2.デルタは次のデルタが長い文字列に挿入されるという事実を補うために増加されます。"
    },
    {
      "indent": 9,
      "text": "let delta = delta + (delta div numpoints)",
      "ja": "聞かせデルタ=デルタ+（デルタのdiv numpoints）"
    },
    {
      "indent": 6,
      "text": "numpoints is the total number of code points encoded/decoded so far (including the one corresponding to this delta itself, and including the basic code points).",
      "ja": "numpoints（このデルタ自身に対応するもの、及び基本的なコードポイントなどを含む）これまでに符号化/復号化コードポイントの総数です。"
    },
    {
      "indent": 3,
      "text": "3. Delta is repeatedly divided until it falls within a threshold, to predict the minimum number of digits needed to represent the next delta:",
      "ja": "3.それは次のデルタを表すのに必要な最小桁数を予測するために、閾値内に入るまで、デルタが繰り返し分割されています。"
    },
    {
      "indent": 9,
      "text": "while delta > ((base - tmin) * tmax) div 2\ndo let delta = delta div (base - tmin)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "4. The bias is set:",
      "section_title": true,
      "ja": "4.バイアスが設定されます。"
    },
    {
      "indent": 9,
      "text": "let bias =\n  (base * the number of divisions performed in step 3) +\n  (((base - tmin + 1) * delta) div (delta + skew))",
      "raw": true
    },
    {
      "indent": 6,
      "text": "The motivation for this procedure is that the current delta provides a hint about the likely size of the next delta, and so t(j) is set to tmax for the more significant digits starting with the one expected to be last, tmin for the less significant digits up through the one expected to be third-last, and somewhere between tmin and tmax for the digit expected to be second-last (balancing the hope of the expected-last digit being unnecessary against the danger of it being insufficient).",
      "ja": "この手順のための動機は、現在のデルタは、次のデルタのありそうな大きさについてのヒントを提供することであり、したがってT（j）が最後であることが期待1から始まるより有効数字のためのT maxに設定されている、以下のためにTMIN重要なサード最後であることが予想1の数字アップ、そしてどこかTMINとTMAXの間に第二の最後であることが予想数字のために（期待-最後の数字は、それが不十分であることの危険性に対する不必要であることの希望を均衡）。"
    },
    {
      "indent": 0,
      "text": "4. Bootstring parameters",
      "section_title": true,
      "ja": "4.ブートストリングパラメータ"
    },
    {
      "indent": 3,
      "text": "Given a set of basic code points, one needs to be designated as the delimiter. The base cannot be greater than the number of distinguishable basic code points remaining. The digit-values in the range 0 through base-1 need to be associated with distinct non-delimiter basic code points. In some cases multiple code points need to have the same digit-value; for example, uppercase and lowercase versions of the same letter need to be equivalent if basic strings are case-insensitive.",
      "ja": "基本的なコードポイントの集合与えられ、一つは区切り文字として指定する必要があります。塩基は、残りの識別可能な基本的なコードポイントの数を超えることはできません。ベース1を介して範囲0で桁の値が異なる非区切り基本コード・ポイントに関連付けする必要があります。いくつかのケースでは、複数のコード・ポイントは、同じ桁値を有する必要があります。例えば、同じ文字の大文字と小文字のバージョンでは、基本的な文字列は大文字と小文字を区別しない場合と同等にする必要があります。"
    },
    {
      "indent": 3,
      "text": "The initial value of n cannot be greater than the minimum non-basic code point that could appear in extended strings.",
      "ja": "nの初期値は、拡張文字列に表示される可能性が最小の非基本コードポイントを超えることはできません。"
    },
    {
      "indent": 3,
      "text": "The remaining five parameters (tmin, tmax, skew, damp, and the initial value of bias) need to satisfy the following constraints:",
      "ja": "残りの5つのパラメータ（TMIN、TMAX、スキュー、湿気、及びバイアスの初期値）は、以下の制約を満たす必要があります。"
    },
    {
      "indent": 6,
      "text": "0 <= tmin <= tmax <= base-1 skew >= 1 damp >= 2 initial_bias mod base <= base - tmin",
      "ja": "0 <= TMIN <= TMAX <=ベース1スキュー> = 1減衰> = 2 initial_bias MOD基地<=ベース -  TMIN"
    },
    {
      "indent": 3,
      "text": "Provided the constraints are satisfied, these five parameters affect efficiency but not correctness. They are best chosen empirically.",
      "ja": "制約条件が満たされて設けられて、これらの5つのパラメータは、効率性ではなく、正確さに影響を与えます。彼らは最高の経験的に選択されています。"
    },
    {
      "indent": 3,
      "text": "If support for mixed-case annotation is desired (see appendix A), make sure that the code points corresponding to 0 through tmax-1 all have both uppercase and lowercase forms.",
      "ja": "混在ケース注釈のサポートが（付録Aを参照）が所望される場合、コードポイントは、すべてTMAX-1を介して0に対応する両方の大文字と小文字の形態を有することを確認してください。"
    },
    {
      "indent": 0,
      "text": "5. Parameter values for Punycode",
      "section_title": true,
      "ja": "ピュニコード5.パラメータ値"
    },
    {
      "indent": 3,
      "text": "Punycode uses the following Bootstring parameter values:",
      "ja": "ピュニコードには、以下のブートストリングパラメータ値を使用しています："
    },
    {
      "indent": 6,
      "text": "base = 36 tmin = 1 tmax = 26 skew = 38 damp = 700 initial_bias = 72 initial_n = 128 = 0x80",
      "ja": "基地= 36 TMIN = 1 TMAX = 26スキュー= 38減衰= 700 initial_bias = 72 initial_n = 128 = 0x80と"
    },
    {
      "indent": 3,
      "text": "Although the only restriction Punycode imposes on the input integers is that they be nonnegative, these parameters are especially designed to work well with Unicode [UNICODE] code points, which are integers in the range 0..10FFFF (but not D800..DFFF, which are reserved for use by the UTF-16 encoding of Unicode). The basic code points are the ASCII [ASCII] code points (0..7F), of which U+002D (-) is the delimiter, and some of the others have digit-values as follows:",
      "ja": "ピュニコード入力整数に課す唯一の制限は、それらが非負であることがあるが、これらのパラメータは、特に範囲0..10FFFF（ただしD800..DFFFの整数であるユニコード[UNICODE]コードポイント、とうまく動作するように設計され、これは、UnicodeのUTF-16符号化）による使用のために予約されています。 ：（ - ）区切り文字であり、次のように、他の一部は、桁値を有する基本コードポイントはU + 002Dは、そのASCII [ASCII]コードポイント（0..7F）、あります"
    },
    {
      "indent": 6,
      "text": "code points    digit-values\n------------   ----------------------\n41..5A (A-Z) =  0 to 25, respectively\n61..7A (a-z) =  0 to 25, respectively\n30..39 (0-9) = 26 to 35, respectively",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Using hyphen-minus as the delimiter implies that the encoded string can end with a hyphen-minus only if the Unicode string consists entirely of basic code points, but IDNA forbids such strings from being encoded. The encoded string can begin with a hyphen-minus, but IDNA prepends a prefix. Therefore IDNA using Punycode conforms to the RFC 952 rule that host name labels neither begin nor end with a hyphen-minus [RFC952].",
      "ja": "区切り文字としてハイフンマイナスを使用してエンコードされた文字列は、Unicode文字列は、基本的なコードポイントの全体からなるが、IDNAは、符号化されているから、そのような文字列を禁止した場合にのみハイフンマイナスで終了することができることを意味します。エンコードされた文字列は、ハイフンマイナスで始めることができますが、IDNAは、接頭辞を付加します。したがってIDNA使用ピュニコードは、ホスト名がどちらも始まりもなく、ハイフン、マイナス[RFC952]で終わるラベルRFC 952の規則に準拠しています。"
    },
    {
      "indent": 3,
      "text": "A decoder MUST recognize the letters in both uppercase and lowercase forms (including mixtures of both forms). An encoder SHOULD output only uppercase forms or only lowercase forms, unless it uses mixed-case annotation (see appendix A).",
      "ja": "デコーダは、（両方の形の混合物を含む）の両方の大文字と小文字の形態で文字を認識しなければなりません。エンコーダは、それが混在する場合のアノテーションを使用しない限り（付録A参照）、出力のみ大文字フォームまたは小文字のみの形態をすべきです。"
    },
    {
      "indent": 3,
      "text": "Presumably most users will not manually write or type encoded strings (as opposed to cutting and pasting them), but those who do will need to be alert to the potential visual ambiguity between the following sets of characters:",
      "ja": "おそらく、ほとんどのユーザーは、手動で書いたり、入力エンコードされた文字列を（それらをカット＆ペーストではなく）、しかし行う者は、以下の文字の集合との間の潜在的な視覚的なあいまいさへの警戒が必要になりますしません。"
    },
    {
      "indent": 6,
      "text": "G 6 I l 1 O 0 S 5 U V Z 2",
      "ja": "G 6 I L 1 O 0 S 5 U V Z 2"
    },
    {
      "indent": 3,
      "text": "Such ambiguities are usually resolved by context, but in a Punycode encoded string there is no context apparent to humans.",
      "ja": "このような曖昧さは、通常、文脈によって解決が、ピュニコードエンコードされた文字列で、人間には明らか何のコンテキストがありませんされています。"
    },
    {
      "indent": 0,
      "text": "6. Bootstring algorithms",
      "section_title": true,
      "ja": "6.ブートストリングアルゴリズム"
    },
    {
      "indent": 3,
      "text": "Some parts of the pseudocode can be omitted if the parameters satisfy certain conditions (for which Punycode qualifies). These parts are enclosed in {braces}, and notes immediately following the pseudocode explain the conditions under which they can be omitted.",
      "ja": "パラメータは、（ピュニコードが資格れる）特定の条件を満たした場合に擬似コードの一部を省略することができます。これらの部品は、中括弧{}で囲まれ、そして直ちに擬似コードを以下の注意事項は、それらが省略できる条件を説明しています。"
    },
    {
      "indent": 3,
      "text": "Formally, code points are integers, and hence the pseudocode assumes that arithmetic operations can be performed directly on code points. In some programming languages, explicit conversion between code points and integers might be necessary.",
      "ja": "正式に、コードポイントは整数であるので、擬似コードは算術演算がコードポイント上で直接行うことができることを想定しています。一部のプログラミング言語では、コードポイントと整数間の明示的な変換が必要になる場合があります。"
    },
    {
      "indent": 0,
      "text": "6.1 Bias adaptation function",
      "section_title": true,
      "ja": "6.1バイアス適応機能"
    },
    {
      "indent": 3,
      "text": "function adapt(delta,numpoints,firsttime): if firsttime then let delta = delta div damp else let delta = delta div 2 let delta = delta + (delta div numpoints) let k = 0 while delta > ((base - tmin) * tmax) div 2 do begin let delta = delta div (base - tmin) let k = k + base end return k + (((base - tmin + 1) * delta) div (delta + skew))",
      "ja": "関数は（デルタ、numpoints、FIRSTTIME）を適応させる：FIRSTTIMEはその後、他のデルタ=デルタのdiv湿ったデルタ=デルタのdiv 2は、デルタ=デルタ+（デルタのdiv numpoints）はデルタ>（（ベースながら、K = 0を聞かせて聞かせて聞かせて聞かせている場合 -  TMIN）* TMAX）デルタ=デルタDIVせ始めるないDIV 2（塩基 -  TMIN）を聞かせて、K = K +ベース端リターンK +（（（ベース -  TMIN + 1）*デルタ）DIV（デルタ+スキュー））"
    },
    {
      "indent": 3,
      "text": "It does not matter whether the modifications to delta and k inside adapt() affect variables of the same name inside the encoding/decoding procedures, because after calling adapt() the caller does not read those variables before overwriting them.",
      "ja": "これは、デルタに変更するかどうかは問題と適応内部K（）ので、それらを上書きする前にこれらの変数を読み取りません（）適応発信者を呼び出した後、エンコーディング/デコーディング手順の内側に同じ名前の変数には影響を与えません。"
    },
    {
      "indent": 0,
      "text": "6.2 Decoding procedure",
      "section_title": true,
      "ja": "6.2復号化手順"
    },
    {
      "indent": 3,
      "text": "let n = initial_n let i = 0 let bias = initial_bias let output = an empty string indexed from 0 consume all code points before the last delimiter (if there is one) and copy them to output, fail on any non-basic code point if more than zero code points were consumed then consume one more (which will be the last delimiter) while the input is not exhausted do begin let oldi = i let w = 1 for k = base to infinity in steps of base do begin consume a code point, or fail if there was none to consume let digit = the code point's digit-value, fail if it has none let i = i + digit * w, fail on overflow let t = tmin if k <= bias {+ tmin}, or tmax if k >= bias + tmax, or k - bias otherwise if digit < t then break let w = w * (base - t), fail on overflow end let bias = adapt(i - oldi, length(output) + 1, test oldi is 0?) let n = n + i div (length(output) + 1), fail on overflow let i = i mod (length(output) + 1) {if n is a basic code point then fail} insert n into output at position i increment i end",
      "ja": "N = initial_n 0は任意の非基本コードポイント場合に失敗し、（存在する場合）、最後の区切りの前のすべてのコードポイントを消費し、出力にコピーから、私は=バイアス= initial_bias出力をさせましょう0 =空の文字列がインデックスさせましょう以上のゼロ・コード・ポイントは、次に=入力が使い果たされていない間（最後のデリミタであろう）もう一つはoldiを聞かせ始めるか消費iはコードを消費し始めるんベースのステップで無限=ベースWせ= kの1を消費しましたポイントは、またはそれがどれもが私を聞かせていない場合に失敗し、桁=コードポイントの桁値をせ消費する何がなかった場合に失敗= iは、W桁*を+ T = TMINを聞かせてオーバーフローに失敗した場合、K <=バイアス{+ TMIN} 、またはTMAX K> =バイアス+ TMAX、またはK場合 - バイアスは、そうでなければ桁が<T、次いで、W = W *（ベース -  T）させ破る場合、オーバーフロー端に失敗バイアス=適応（Iせ -  oldi、長さ（出力） + 1、試験oldiが0？）私は（長さ（出力）+ 1）DIV N = N +せ、オーバーフローに失敗nが、基本的なコード・ポイントである場合、私は= iは{）（長さ（出力）+ 1国防省せフェイル}私はENを増分位置の出力にN挿入D"
    },
    {
      "indent": 3,
      "text": "The full statement enclosed in braces (checking whether n is a basic code point) can be omitted if initial_n exceeds all basic code points (which is true for Punycode), because n is never less than initial_n.",
      "ja": "initial_nは（ピュニコードも同様である）すべての基本コードポイントを超えている場合、nはinitial_nより少ないことはないので（nは基本コード・ポイントであるかどうかをチェック）中括弧で囲まれた完全なステートメントは、省略することができます。"
    },
    {
      "indent": 3,
      "text": "In the assignment of t, where t is clamped to the range tmin through tmax, \"+ tmin\" can always be omitted. This makes the clamping calculation incorrect when bias < k < bias + tmin, but that cannot happen because of the way bias is computed and because of the constraints on the parameters.",
      "ja": "TがTMAX、「+ TMIN」を介し範囲TMINにクランプされているTの割り当て、常に省略することができます。これは、バイアス<K <バイアス+ TMIN、それが原因で、バイアスが計算されている方法のため、およびパラメータの制約により起こることができないとき、クランプ計算が間違ってます。"
    },
    {
      "indent": 3,
      "text": "Because the decoder state can only advance monotonically, and there is only one representation of any delta, there is therefore only one encoded string that can represent a given sequence of integers. The only error conditions are invalid code points, unexpected end-of-input, overflow, and basic code points encoded using deltas instead of appearing literally. If the decoder fails on these errors as shown above, then it cannot produce the same output for two distinct inputs. Without this property it would have been necessary to re- encode the output and verify that it matches the input in order to guarantee the uniqueness of the encoding.",
      "ja": "デコーダ状態のみ単調に前進することができ、任意のデルタのいずれか一方のみの表現があるため、整数の所定のシーケンスを表すことができる唯一のエンコードされた文字列が存在します。唯一のエラー状態は、無効なコード・ポイント、予期しない終了の入力、オーバーフロー、およびデルタを使用して代わりに文字通りに現れる符号化された基本コード・ポイントです。上記のように、デコーダは、これらのエラーで失敗した場合、それは、2つの異なる入力に対して同じ出力を生成することができません。このプロパティがなければ、エンコードした出力を再し、それがエンコーディングの一意性を保証するために、入力と一致することを確認する必要があったであろう。"
    },
    {
      "indent": 0,
      "text": "6.3 Encoding procedure",
      "section_title": true,
      "ja": "6.3符号化手順"
    },
    {
      "indent": 3,
      "text": "let n = initial_n let delta = 0 let bias = initial_bias let h = b = the number of basic code points in the input copy them to the output in order, followed by a delimiter if b > 0 {if the input contains a non-basic code point < n then fail} while h < length(input) do begin let m = the minimum {non-basic} code point >= n in the input let delta = delta + (m - n) * (h + 1), fail on overflow let n = m for each code point c in the input (in order) do begin if c < n {or c is basic} then increment delta, fail on overflow if c == n then begin let q = delta for k = base to infinity in steps of base do begin let t = tmin if k <= bias {+ tmin}, or tmax if k >= bias + tmax, or k - bias otherwise if q < t then break output the code point for digit t + ((q - t) mod (base - t)) let q = (q - t) div (base - t) end output the code point for digit q let bias = adapt(delta, h + 1, test h equals b?) let delta = 0 increment h end end increment delta and n end",
      "ja": "せ、N =せinitial_nデルタ= 0 LETバイアス= initial_bias時間= bが=入力における基本的なコードポイントの数は、区切り文字が続く順序で出力にコピー許可すれば、入力が非を含む場合、B> 0 {基本コードポイントH <長さ（入力）入力で、M =最小{非塩基}コードポイント> = nはせせ始めるかながら<N次いで}失敗デルタ=デルタ+（M  -  N）*（H + 1 ）、cは<N =次いで、デルタをインクリメントC ==場合オーバーフローに失敗N次いでQをさせ始める{又はCが塩基性である}場合ために入力（）内の各コードポイントCのため= M Nせ始めるかオーバーフローに失敗デルタ開始ない塩基のステップで無限にK =ベースについてのT = TMINを許可すれば、K <=バイアス{+ TMIN}、またはTMAXであれば、K> =バイアス+ TMAX、またはK  -  qは<T、出力破るそうでない場合にバイアス（ -  T）MOD（ベース - （Q T））桁T +のコード点Q =（Q  -  T）とするDIV（ベース -  T）エンド出力桁Qのコードポイントは、バイアスを聞かせ=（デルタ、時間+を適応させます図1は、試験h）は？Bに等しいデルタ= 0インクリメントH末端端増分デルタ及びN末端を聞かせ"
    },
    {
      "indent": 3,
      "text": "The full statement enclosed in braces (checking whether the input contains a non-basic code point less than n) can be omitted if all code points less than initial_n are basic code points (which is true for Punycode if code points are unsigned).",
      "ja": "initial_n未満のすべてのコードポイントが（コードポイントが符号なしである場合ピュニコードについても同様である）基本コード・ポイントである場合（入力がnよりも非基本コードポイント未満含まれているかどうかをチェックする）中括弧で囲まれた完全な文を省略することができます。"
    },
    {
      "indent": 3,
      "text": "The brace-enclosed conditions \"non-basic\" and \"or c is basic\" can be omitted if initial_n exceeds all basic code points (which is true for Punycode), because the code point being tested is never less than initial_n.",
      "ja": "initial_nは（ピュニコードも同様である）すべての基本コードポイントを超えた場合に試験されているコード・ポイントがinitial_nより少ないことはないので、ブレースで囲まれた条件「非塩基性」及び「又はC塩基性である」は、省略することができます。"
    },
    {
      "indent": 3,
      "text": "In the assignment of t, where t is clamped to the range tmin through tmax, \"+ tmin\" can always be omitted. This makes the clamping calculation incorrect when bias < k < bias + tmin, but that cannot happen because of the way bias is computed and because of the constraints on the parameters.",
      "ja": "TがTMAX、「+ TMIN」を介し範囲TMINにクランプされているTの割り当て、常に省略することができます。これは、バイアス<K <バイアス+ TMIN、それが原因で、バイアスが計算されている方法のため、およびパラメータの制約により起こることができないとき、クランプ計算が間違ってます。"
    },
    {
      "indent": 3,
      "text": "The checks for overflow are necessary to avoid producing invalid output when the input contains very large values or is very long.",
      "ja": "オーバーフローをチェックし、入力が非常に大きな値が含まれているか、非常に長い場合、無効な出力を生成する避けるために必要です。"
    },
    {
      "indent": 3,
      "text": "The increment of delta at the bottom of the outer loop cannot overflow because delta < length(input) before the increment, and length(input) is already assumed to be representable. The increment of n could overflow, but only if h == length(input), in which case the procedure is finished anyway.",
      "ja": "アウターループできないオーバーフローの底部のデルタの増分デルタ<インクリメント前の長さ（入力）、および長さ（入力）が既に表現であると仮定されるからです。 Nの増加はオーバーフローだけ手順がとにかく終了した場合に時間==長（入力）、もし可能性があります。"
    },
    {
      "indent": 0,
      "text": "6.4 Overflow handling",
      "section_title": true,
      "ja": "6.4オーバーフロー取り扱い"
    },
    {
      "indent": 3,
      "text": "For IDNA, 26-bit unsigned integers are sufficient to handle all valid IDNA labels without overflow, because any string that needed a 27-bit delta would have to exceed either the code point limit (0..10FFFF) or the label length limit (63 characters). However, overflow handling is necessary because the inputs are not necessarily valid IDNA labels.",
      "ja": "27ビットのデルタを必要な文字列がコードポイントリミット（0..10FFFF）またはラベルの長さ制限（いずれかを超過しなければならないのでIDNAのために、26ビットの符号なし整数は、オーバーフローなしですべての有効IDNAラベルを処理するのに十分です63文字）。入力が必ずしも有効なIDNAラベルではありませんので、しかし、オーバーフロー処理が必要です。"
    },
    {
      "indent": 3,
      "text": "If the programming language does not provide overflow detection, the following technique can be used. Suppose A, B, and C are representable nonnegative integers and C is nonzero. Then A + B overflows if and only if B > maxint - A, and A + (B * C) overflows if and only if B > (maxint - A) div C, where maxint is the greatest integer for which maxint + 1 cannot be represented. Refer to appendix C \"Punycode sample implementation\" for demonstrations of this technique in the C language.",
      "ja": "プログラミング言語は、オーバーフロー検出を提供していない場合は、以下の技術を使用することができます。 A、B、およびCを仮定する表現非負整数であり、Cは非ゼロです。 MAXINTがMAXINT + 1ができないための最大の整数であるDIV C、 - （A MAXINT）>場合にのみB場合A、及びA +（のB * C）オーバーフロー - 次いで、A + Bは、B> MAXINTは場合にのみオーバフロー表現すること。 C言語でこの技術のデモンストレーションのためのC「ピュニコードのサンプル実装を」付録を参照してください。"
    },
    {
      "indent": 3,
      "text": "The decoding and encoding algorithms shown in sections 6.2 and 6.3 handle overflow by detecting it whenever it happens. Another approach is to enforce limits on the inputs that prevent overflow from happening. For example, if the encoder were to verify that no input code points exceed M and that the input length does not exceed L, then no delta could ever exceed (M - initial_n) * (L + 1), and hence no overflow could occur if integer variables were capable of representing values that large. This prevention approach would impose more restrictions on the input than the detection approach does, but might be considered simpler in some programming languages.",
      "ja": "それが起こるたびに、それを検出することによって、セクション6.2および6.3ハンドルオーバーフローに示す復号および符号化アルゴリズム。別のアプローチは、起こってからのオーバーフローを防止入力に制限を強制することです。エンコーダはない入力コードポイントがMを超えていないことと、入力の長さがLを超えていないことを確認した場合、例えば、次に何デルタはこれまで（M  -  initial_n）を超えることができなかった*（L + 1）、従ってオーバーフローが発生することができませんでした整数変数が大きな値を示すことができた場合。この予防的なアプローチは、検出アプローチよりも入力に多くの制限を課すだろうが、いくつかのプログラミング言語でシンプルな考えられるかもしれません。"
    },
    {
      "indent": 3,
      "text": "In theory, the decoder could use an analogous approach, limiting the number of digits in a variable-length integer (that is, limiting the number of iterations in the innermost loop). However, the number of digits that suffice to represent a given delta can sometimes represent much larger deltas (because of the adaptation), and hence this approach would probably need integers wider than 32 bits.",
      "ja": "理論的には、デコーダは、（最も内側のループ内で反復の数を制限する、つまり）可変長整数の桁数を制限し、類似のアプローチを使用することができます。しかし、所与のデルタを表すのに十分で桁数が時々（なぜなら適応の）はるかに大きなデルタを表すことができ、従ってこのアプローチは、おそらく32ビットより広い整数を必要とするであろう。"
    },
    {
      "indent": 3,
      "text": "Yet another approach for the decoder is to allow overflow to occur, but to check the final output string by re-encoding it and comparing to the decoder input. If and only if they do not match (using a case-insensitive ASCII comparison) overflow has occurred. This delayed-detection approach would not impose any more restrictions on the input than the immediate-detection approach does, and might be considered simpler in some programming languages.",
      "ja": "まだデコーダのための別のアプローチは、オーバーフローが発生し、それを再エンコードし、デコーダ入力と比較することによって、最終的な出力文字列をチェックできるようにすることです。彼らは（大文字と小文字を区別しないASCII比較を使用して）一致しない場合にのみ場合は、オーバーフローが発生しました。この遅延検出アプローチは、即時検出アプローチはよりも、入力上の任意のより多くの制限を課すことはない、といくつかのプログラミング言語で単純な考えられるかもしれません。"
    },
    {
      "indent": 3,
      "text": "In fact, if the decoder is used only inside the IDNA ToUnicode operation [IDNA], then it need not check for overflow at all, because ToUnicode performs a higher level re-encoding and comparison, and a mismatch has the same consequence as if the Punycode decoder had failed.",
      "ja": "実際には、デコーダは、のToUnicodeは、より高いレベルの再エンコードおよび比較を行うため、それは、全くオーバーフローをチェックする必要がないだけIDNAのToUnicode動作[IDNA]内で使用、および不整合があれば同じ結果を有している場合ピュニコードデコーダは失敗していました。"
    },
    {
      "indent": 0,
      "text": "7. Punycode examples",
      "section_title": true,
      "ja": "7.ピュニコード例"
    },
    {
      "indent": 0,
      "text": "7.1 Sample strings",
      "section_title": true,
      "ja": "7.1サンプルの文字列"
    },
    {
      "indent": 3,
      "text": "In the Punycode encodings below, the ACE prefix is not shown. Backslashes show where line breaks have been inserted in strings too long for one line.",
      "ja": "以下ピュニコードエンコーディングでは、ACEプレフィックスは表示されません。バックスラッシュは、改行が1行にはあまりにも長い文字列に挿入されている場所を示します。"
    },
    {
      "indent": 3,
      "text": "The first several examples are all translations of the sentence \"Why can't they just speak in <language>?\" (courtesy of Michael Kaplan's \"provincial\" page [PROVINCIAL]). Word breaks and punctuation have been removed, as is often done in domain names.",
      "ja": "最初のいくつかの例には、文のすべての翻訳は「なぜ彼らはただ、<言語>で話すことができないのですか？」 （マイケル・カプランの「地方」ページ[地方]の礼儀）。多くの場合、ドメイン名において行われるように単語の切れ目や句読点は、削除されました。"
    },
    {
      "indent": 3,
      "text": "(A) Arabic (Egyptian): u+0644 u+064A u+0647 u+0645 u+0627 u+0628 u+062A u+0643 u+0644 u+0645 u+0648 u+0634 u+0639 u+0631 u+0628 u+064A u+061F Punycode: egbpdaj6bu4bxfgehfvwxn",
      "ja": "（A）アラビア語（エジプト）：U + 0644に+ 064A + 0647に+ 0645に+ 0627に+ 0628への+ 062A + 0643に+ 0644に+ 0645に+ 0648に+ 0634に+ 0639に+ 0631へ0628で+ + + 061Fピュニコードに064Aで：egbpdaj6bu4bxfgehfvwxn"
    },
    {
      "indent": 3,
      "text": "(B) Chinese (simplified): u+4ED6 u+4EEC u+4E3A u+4EC0 u+4E48 u+4E0D u+8BF4 u+4E2D u+6587 Punycode: ihqwcrb4cv8a8dqg056pqjye",
      "ja": "（B）中国語（簡体字）：U + 4ED6 U + 4EEC U + 4E3A U + 4EC0 U + 4E48 U + 4E0D U + 8BF4 U + 4E2D U + 6587ピュニコード：ihqwcrb4cv8a8dqg056pqjye"
    },
    {
      "indent": 3,
      "text": "(C) Chinese (traditional): u+4ED6 u+5011 u+7232 u+4EC0 u+9EBD u+4E0D u+8AAA u+4E2D u+6587 Punycode: ihqwctvzc91f659drss3x8bo0yb",
      "ja": "8AAA +のU + Uで4EC0 + + + 4E0D 9EBDで7232へ（C）+ + + 5011 4ED6で中国語（繁体字）+ 4E2D 6587ピュニコード：ihqwctvzc91f659drss3x8bo0yb"
    },
    {
      "indent": 3,
      "text": "(D) Czech: Pro<ccaron>prost<ecaron>nemluv<iacute><ccaron>esky U+0050 u+0072 u+006F u+010D u+0070 u+0072 u+006F u+0073 u+0074 u+011B u+006E u+0065 u+006D u+006C u+0075 u+0076 u+00ED u+010D u+0065 u+0073 u+006B u+0079 Punycode: Proprostnemluvesky-uyb24dma41a",
      "ja": "（D）チェコ語：プロ<ccaron>無料<ecaron>Nemluvím<iacute> <ccaron> ESKY U + 0050に+ 0072に+ 006Fまで+ 0074に+ 0073で+ 006Fまで+ 0072に+ 0070で+ 010Dに+ Proprostnemluvesky-uyb24dma41a：+ 006Cに+ + + 0065の006Eへ011Bはピュニコードに+ 0079 + 006Bに+ 0073に+ 0065で0075 + + + 0076 +に00ED 010Dに006Dします"
    },
    {
      "indent": 3,
      "text": "(E) Hebrew: u+05DC u+05DE u+05D4 u+05D4 u+05DD u+05E4 u+05E9 u+05D5 u+05D8 u+05DC u+05D0 u+05DE u+05D3 u+05D1 u+05E8 u+05D9 u+05DD u+05E2 u+05D1 u+05E8 u+05D9 u+05EA Punycode: 4dbcagdahymbxekheh6e0a7fei0b",
      "ja": "（E）ヘブライ語iが+ 05D3 U + 05D1 U + 05E8で+ 05D0 U + 05DEにおける+ 05DCに+ 05D4 U + 05D4 U + 05DD U + 05E4 U + 05E9 U + 05D5 U + 05D8で+ 05DEで05DCを+ 4dbcagdahymbxekheh6e0a7fei0b：05EAピュニコードで+ + + 05D9で05E8に+ U + 05DD + 05D1 05E2で+ 05D9"
    },
    {
      "indent": 3,
      "text": "(F) Hindi (Devanagari): u+092F u+0939 u+0932 u+094B u+0917 u+0939 u+093F u+0928 u+094D u+0926 u+0940 u+0915 u+094D u+092F u+094B u+0902 u+0928 u+0939 u+0940 u+0902 u+092C u+094B u+0932 u+0938 u+0915 u+0924 u+0947 u+0939 u+0948 u+0902 Punycode: i1baa7eci9glrd9b2ae1bj0hfcgg6iyaf8o0a1dig0cd",
      "ja": "（F）ヒンディー語（デバナーガリ）：uは+ 092F + 0939に+ 0932に+ 094Bへの+ 0917に+ 0939 + 093Fに+ 0928 + 0915に+ 0940に+ 0926 + 094D Uへの+ 094D + 092FへのU + + 0938に+ 0915に+ 0924に+ 0947に+ 0939に+ 0948に+ 0902ピュニコードに0902 +へ+ 0928に+ 0939に+ 0940に+ 0902に+ 092Cに+ 094Bと094B 0932 +へ： i1baa7eci9glrd9b2ae1bj0hfcgg6iyaf8o0a1dig0cd"
    },
    {
      "indent": 3,
      "text": "(G) Japanese (kanji and hiragana): u+306A u+305C u+307F u+3093 u+306A u+65E5 u+672C u+8A9E u+3092 u+8A71 u+3057 u+3066 u+304F u+308C u+306A u+3044 u+306E u+304B Punycode: n8jok5ay5dzabd5bym9f0cm5685rrjetr6pdxa",
      "ja": "+ 8A71に+ 3057に+ 3066までで+ 304Fに+ 3092で+ 8A9Eに+の672Cで+ 3093に+ 306Aに+ 65E5の+ 305Cで（G）日本人（漢字とひらがな）、I + 306A 307F +に+ + 306E + 304Bピュニコード中に+ 3044で+ 306Aへの308C：n8jok5ay5dzabd5bym9f0cm5685rrjetr6pdxa"
    },
    {
      "indent": 3,
      "text": "(H) Korean (Hangul syllables): u+C138 u+ACC4 u+C758 u+BAA8 u+B4E0 u+C0AC u+B78C u+B4E4 u+C774 u+D55C u+AD6D u+C5B4 u+B97C u+C774 u+D574 u+D55C u+B2E4 u+BA74 u+C5BC u+B9C8 u+B098 u+C88B u+C744 u+AE4C Punycode: 989aomsvi5e83db1d2a355cv1e0vak1dwrv93d5xbh15a0dt30a5j\\ psd879ccm6fea98c",
      "ja": "（H）、韓国語（ハングル音節）iは+ BAA8で+ C758 + B4E0 + C0AC + B78C + B4E4 + D55Cで+ C774 ACC4 +でC138を+ + + B97Cで+ C5B4 +をAD6D 989aomsvi5e83db1d2a355cv1e0vak1dwrv93d5xbh15a0dt30a5jの\\のpsd879ccm6fea98c：B9C8で+ + B098 +ピュニコードで+ C744 + AE4CにC88B中で+ C5BCでBA74の+中+ B2E4でD55Cの+でC774 + D574"
    },
    {
      "indent": 3,
      "text": "(I) Russian (Cyrillic): U+043F u+043E u+0447 u+0435 u+043C u+0443 u+0436 u+0435 u+043E u+043D u+0438 u+043D u+0435 u+0433 u+043E u+0432 u+043E u+0440 u+044F u+0442 u+043F u+043E u+0440 u+0443 u+0441 u+0441 u+043A u+0438 Punycode: b1abfaaepdrnnbgefbaDotcwatmq2g4l",
      "ja": "（I）ロシア語（ラテン）：+ 043E U + 0447にU + 043F + 0435に+ 043Cに0443 +へ+ 0436に+ 0435に+ 043E U + 043D U + 0438に+ 043D U + 0435に+ 0433へ043Eに+ + + 0432 + 0440 043Eの内の044F + + + 0442 + 0440 + 0441 + 0443 + + + 043A 0438でピュニコードに0441に043Eに+ 043Fに：b1abfaaepdrnnbgefbaDotcwatmq2g4l"
    },
    {
      "indent": 3,
      "text": "(J) Spanish: Porqu<eacute>nopuedensimplementehablarenEspa<ntilde>ol U+0050 u+006F u+0072 u+0071 u+0075 u+00E9 u+006E u+006F u+0070 u+0075 u+0065 u+0064 u+0065 u+006E u+0073 u+0069 u+006D u+0070 u+006C u+0065 u+006D u+0065 u+006E u+0074 u+0065 u+0068 u+0061 u+0062 u+006C u+0061 u+0072 u+0065 u+006E U+0045 u+0073 u+0070 u+0061 u+00F1 u+006F u+006C Punycode: PorqunopuedensimplementehablarenEspaol-fmd56a",
      "ja": "（J）スペイン語：porque <eacute> nopuedensimplementehablarenEspa <Ntilde>オール+ 0050に+ 00E9 Uに+ 0075 + 0071への+ 0072に+ 006F + 006Eに+ 006Fに+ 0070 + 0064 + 0065への+ 0075へU + 0065 + 006EへのU + 0073に+ 0069 + 006DにU + 0070 + 006Dに+ 006Cに+ 0065にU + 0065に+ 0062に+ 0061に+ 0068に+ 0065に+ 006E U + 0074に+で006C U + 006E + 0045 + 0070 + 0073への+ 006Cピュニコードで+ 006F + 00F1に+ 0061までで+ 0072 + 0065 + 0061：PorqunopuedensimplementehablarenEspaol-fmd56a"
    },
    {
      "indent": 3,
      "text": "(K) Vietnamese: T<adotbelow>isaoh<odotbelow>kh<ocirc>ngth<ecirchookabove>ch\\ <ihookabove>n<oacute>iti<ecircacute>ngVi<ecircdotbelow>t U+0054 u+1EA1 u+0069 u+0073 u+0061 u+006F u+0068 u+1ECD u+006B u+0068 u+00F4 u+006E u+0067 u+0074 u+0068 u+1EC3 u+0063 u+0068 u+1EC9 u+006E u+00F3 u+0069 u+0074 u+0069 u+1EBF u+006E u+0067 U+0056 u+0069 u+1EC7 u+0074 Punycode: TisaohkhngthchnitingVit-kjcr8268qyxafd2f1b9g",
      "ja": "（K）ベトナム：T <adotbelow> isaoh <odotbelow> KH <ocirc> ngth <ecirchookabove> CH \\ <ihookabove> N <oacute>移動<ecircacute> ngVi <ecircdotbelow> T U + 0054に+ 1EA1に+ 0069に+ 0073に+ 0061に+ 006F + 006B + 1ECDに+ 0068への+ 0068 + 00F4へ006E +でuは+ 0067 + 0068に+ 1EC3に+ 0063に+ 0068に+ 0074に+ 1EC9 + 006Eの中に00F3 + 0074 + U + U + 0069 + 0069に1EBF 006E + + 0067におけるU + 0056に+ 0069にピュニコードに+ 0074 + 1EC7に：TisaohkhngthchnitingVit-kjcr8268qyxafd2f1b9g"
    },
    {
      "indent": 3,
      "text": "The next several examples are all names of Japanese music artists, song titles, and TV programs, just because the author happens to have them handy (but Japanese is useful for providing examples of single-row text, two-row text, ideographic text, and various mixtures thereof).",
      "ja": "次のいくつかの例では、著者は彼らが手元にたまたま（しかし、日本人は単一行のテキスト、2行のテキスト、表意文字の例を提供するために有用であるという理由だけで、すべての日本の音楽アーティスト、曲のタイトル、およびテレビ番組の名前ですおよびそれらの種々の混合物）。"
    },
    {
      "indent": 3,
      "text": "(L) 3<nen>B<gumi><kinpachi><sensei> u+0033 u+5E74 U+0042 u+7D44 u+91D1 u+516B u+5148 u+751F Punycode: 3B-ww4c5e180e575a65lsy2b",
      "ja": "（L）3 <NEN> B <グミ> <kinpachi> <先生> U + 0033 U + 5E74 U + 0042 U + 7D44 U + 91D1 U + 516B U + 5148 U + 751Fピュニコード：3B-ww4c5e180e575a65lsy2b"
    },
    {
      "indent": 3,
      "text": "(M) <amuro><namie>-with-SUPER-MONKEYS u+5B89 u+5BA4 u+5948 u+7F8E u+6075 u+002D u+0077 u+0069 u+0074 u+0068 u+002D U+0053 U+0055 U+0050 U+0045 U+0052 u+002D U+004D U+004F U+004E U+004B U+0045 U+0059 U+0053 Punycode: -with-SUPER-MONKEYS-pc58ag80a8qai00g7n9n",
      "ja": "（M）<アムロ> <奈美恵> -with-SUPER-MONKEYS U + 5B89 U + 5BA4 U + 5948 U + 7F8E U + 6075 U + 002D U + 0077 U + 0069 U + 0074 U + 0068 U + 002D + U 0053 U + 0055 U + 0050 U + 0045 U + 0052 U + 002D U + 004D U + 004F U + 004E U + 004B U + 0045 U + 0059 U + 0053ピュニコード：-with-SUPER-MONKEYS-pc58ag80a8qai00g7n9n"
    },
    {
      "indent": 3,
      "text": "(N) Hello-Another-Way-<sorezore><no><basho> U+0048 u+0065 u+006C u+006C u+006F u+002D U+0041 u+006E u+006F u+0074 u+0068 u+0065 u+0072 u+002D U+0057 u+0061 u+0079 u+002D u+305D u+308C u+305E u+308C u+306E u+5834 u+6240 Punycode: Hello-Another-Way--fc4qua05auwb3674vfr0b",
      "ja": "（N）ハロー-別-way- <Sorezore> <なし> <芭蕉> U + 0048 + 0065の+ 006Cの+ 006Cに+ 006F + U + 002D U + 0041に+ 006Fに0074 + +で006Eします0068 + 0065 + 0072 +へ002D U + 0057に+ 5834で+ 306Eに+の308Cにおける+ 305Eに+ 0061 + 0079 +へ002D U + 305Dに+で308Cに6240 +のピュニコードに：こんにちは、別の方法--fc4qua05auwb3674vfr0b"
    },
    {
      "indent": 3,
      "text": "(O) <hitotsu><yane><no><shita>2 u+3072 u+3068 u+3064 u+5C4B u+6839 u+306E u+4E0B u+0032 Punycode: 2-u9tlzr9756bt3uc0v",
      "ja": "（O）<ひとつ> <yane> <なし> <shita> 2 U + 3072 U + 3068 U + 3064 U + 5C4B U + 6839 U + 306E U + 4E0B U + 0032ピュニコード：2- u9tlzr9756bt3uc0v"
    },
    {
      "indent": 3,
      "text": "(P) Maji<de>Koi<suru>5<byou><mae> U+004D u+0061 u+006A u+0069 u+3067 U+004B u+006F u+0069 u+3059 u+308B u+0035 u+79D2 u+524D Punycode: MajiKoi5-783gue6qz075azm5e",
      "ja": "（P）マジ<脱>恋<suru> 5 <ビョウ> <メイ> U + 004D + 0061で+ 0069で+ 006Aに+ 3067 U + 004Bへの+ 006F + 0069でで+ 308Bに+ 3059に+ + 524Dピュニコードで0035 + 79D2：MajiKoi5-783gue6qz075azm5e"
    },
    {
      "indent": 3,
      "text": "(Q) <pafii>de<runba> u+30D1 u+30D5 u+30A3 u+30FC u+0064 u+0065 u+30EB u+30F3 u+30D0 Punycode: de-jg4avhby1noc0d",
      "ja": "（Q）<pafii>ド<runba> U + 30D1 U + 30D5 U + 30A3、U + 30FC U + 0064 U + 0065 U + 30EB U + 30F3 U + 30D0ピュニコード：脱jg4avhby1noc0d"
    },
    {
      "indent": 3,
      "text": "(R) <sono><supiido><de> u+305D u+306E u+30B9 u+30D4 u+30FC u+30C9 u+3067 Punycode: d9juau41awczczp",
      "ja": "（R）<ソノ> <supiido> <脱> U + 305D U + 306E U + 30B9、U + 30D4 U + 30FC U + 30C9 U + 3067ピュニコード：d9juau41awczczp"
    },
    {
      "indent": 3,
      "text": "The last example is an ASCII string that breaks the existing rules for host name labels. (It is not a realistic example for IDNA, because IDNA never encodes pure ASCII labels.)",
      "ja": "最後の例では、ホスト名のラベルのための既存のルールを破るASCII文字列です。 （IDNAは、純粋なASCIIラベルをエンコードすることはありませんので、IDNAのための現実的な例ではありません。）"
    },
    {
      "indent": 3,
      "text": "(S) -> $1.00 <- u+002D u+003E u+0020 u+0024 u+0031 u+002E u+0030 u+0030 u+0020 u+003C u+002D Punycode: -> $1.00 <--",
      "ja": "（S） - > $ 1.00 < -  U + 002D U + 003Eで+ 0020ピュニコード002D +へ003C +に対して+ 0020に+ 0030に+ 0030で+ 002Eに+ 0031に+ 0024に： - > $ 1.00 < - "
    },
    {
      "indent": 0,
      "text": "7.2 Decoding traces",
      "section_title": true,
      "ja": "7.2デコード・トレース"
    },
    {
      "indent": 3,
      "text": "In the following traces, the evolving state of the decoder is shown as a sequence of hexadecimal values, representing the code points in the extended string. An asterisk appears just after the most recently inserted code point, indicating both n (the value preceeding the asterisk) and i (the position of the value just after the asterisk). Other numerical values are decimal.",
      "ja": "次のトレースでは、デコーダの進化状態は、拡張文字列内のコードポイントを表す16進値のシーケンスとして示されています。アスタリスクは、単に最も最近挿入されたコードポイントの後に表示され、両方のN（アスタリスクを先行値）を示すと、I（単にアスタリスク後の値の位置）。その他の数値は小数です。"
    },
    {
      "indent": 3,
      "text": "Decoding trace of example B from section 7.1:",
      "ja": "セクション7.1から例Bのトレースをデコード："
    },
    {
      "indent": 3,
      "text": "n is 128, i is 0, bias is 72 input is \"ihqwcrb4cv8a8dqg056pqjye\" there is no delimiter, so extended string starts empty delta \"ihq\" decodes to 19853 bias becomes 21 4E0D * delta \"wc\" decodes to 64 bias becomes 20 4E0D 4E2D * delta \"rb\" decodes to 37 bias becomes 13 4E3A * 4E0D 4E2D delta \"4c\" decodes to 56 bias becomes 17 4E3A 4E48 * 4E0D 4E2D delta \"v8a\" decodes to 599 bias becomes 32 4E3A 4EC0 * 4E48 4E0D 4E2D delta \"8d\" decodes to 130 bias becomes 23 4ED6 * 4E3A 4EC0 4E48 4E0D 4E2D delta \"qg\" decodes to 154 bias becomes 25 4ED6 4EEC * 4E3A 4EC0 4E48 4E0D 4E2D delta \"056p\" decodes to 46301 bias becomes 84 4ED6 4EEC 4E3A 4EC0 4E48 4E0D 4E2D 6587 * delta \"qjye\" decodes to 88531 bias becomes 90 4ED6 4EEC 4E3A 4EC0 4E48 4E0D 8BF4 * 4E2D 6587",
      "ja": "nが128であり、iはバイアスが72入力され、0でない区切り文字が存在しない「ihqwcrb4cv8a8dqg056pqjye」は、そう拡張文字列が空のデルタを開始する19853にデコード「IHQ」バイアスは21 4E0D *デルタ「WC」と64件のバイアスにデコードが20 4E0D 4E2Dなりなります*デルタ \"RB\" は、37件のバイアスにデコード13 4E3A * 4E0D 4E2Dデルタ \"4cは\" 56のバイアス17 4E3A 4E48 * 4E0D 4E2Dデルタ \"v8aは\" 599件のバイアスに復号なる32 4E3A 4EC0 * 4E48 4E0D 4E2Dデルタなる \"8D\" に復号なります130のバイアスをデコードなる23 4ED6 * 154のバイアス46301のバイアスが6587 84 4ED6 4EEC 4E3A 4EC0 4E48 4E0D 4E2Dとなり、25 4ED6 4EEC * 4E3A 4EC0 4E48 4E0D 4E2Dデルタ \"056p\" は復号なるに4E3A 4EC0 4E48 4E0D 4E2Dデルタ \"QG\" がデコード*デルタ \"qjyeは\" 88531のバイアスにデコード90 4ED6 4EEC 4E3A 4EC0 4E48 4E0D 8BF4 * 4E2D 6587となり"
    },
    {
      "indent": 3,
      "text": "Decoding trace of example L from section 7.1:",
      "ja": "セクション7.1から例Lのトレースをデコード："
    },
    {
      "indent": 3,
      "text": "n is 128, i is 0, bias is 72 input is \"3B-ww4c5e180e575a65lsy2b\" literal portion is \"3B-\", so extended string starts as: 0033 0042 delta \"ww4c\" decodes to 62042 bias becomes 27 0033 0042 5148 * delta \"5e\" decodes to 139 bias becomes 24 0033 0042 516B * 5148 delta \"180e\" decodes to 16683 bias becomes 67 0033 5E74 * 0042 516B 5148 delta \"575a\" decodes to 34821 bias becomes 82 0033 5E74 0042 516B 5148 751F * delta \"65l\" decodes to 14592 bias becomes 67 0033 5E74 0042 7D44 * 516B 5148 751F delta \"sy2b\" decodes to 42088 bias becomes 84 0033 5E74 0042 7D44 91D1 * 516B 5148 751F",
      "ja": "N iは0である、128で、バイアスは、72入力が「3B-ww4c5e180e575a65lsy2b」はリテラル部分「3B-」であるので、拡張文字列として開始：0033 0042デルタ「ww4cは」62042のバイアスにデコード「デルタ* 27 0033 0042 5148となります図5Eは、」139のバイアスにデコード24 0033 0042 516B * 5148デルタが \"65リットル \"575A \"34821のバイアス82 0033 5E74 0042 516B 5148 751F *デルタなるに復号\" 180E\" は16683のバイアス67 0033 5E74 * 0042 516B 5148デルタなるにデコード\" 14592のバイアスが84 0033 5E74 0042 7D44 91D1 * 516B 5148 751Fとなり67 0033 5E74 0042 7D44 * 516B 5148 751Fデルタ \"sy2bは\" 42088のバイアスにデコードなりにデコードします"
    },
    {
      "indent": 0,
      "text": "7.3 Encoding traces",
      "section_title": true,
      "ja": "7.3エンコーディングトレース"
    },
    {
      "indent": 3,
      "text": "In the following traces, code point values are hexadecimal, while other numerical values are decimal.",
      "ja": "他の数値は、小数点であるときには、次のトレースでは、コードポイント値が16進数です。"
    },
    {
      "indent": 3,
      "text": "Encoding trace of example B from section 7.1:",
      "ja": "セクション7.1から例Bのトレースをコードします："
    },
    {
      "indent": 3,
      "text": "bias is 72 input is: 4ED6 4EEC 4E3A 4EC0 4E48 4E0D 8BF4 4E2D 6587 there are no basic code points, so no literal portion next code point to insert is 4E0D needed delta is 19853, encodes as \"ihq\" bias becomes 21 next code point to insert is 4E2D needed delta is 64, encodes as \"wc\" bias becomes 20 next code point to insert is 4E3A needed delta is 37, encodes as \"rb\" bias becomes 13 next code point to insert is 4E48 needed delta is 56, encodes as \"4c\" bias becomes 17 next code point to insert is 4EC0 needed delta is 599, encodes as \"v8a\" bias becomes 32 next code point to insert is 4ED6 needed delta is 130, encodes as \"8d\" bias becomes 23 next code point to insert is 4EEC needed delta is 154, encodes as \"qg\" bias becomes 25 next code point to insert is 6587 needed delta is 46301, encodes as \"056p\" bias becomes 84 next code point to insert is 8BF4 needed delta is 88531, encodes as \"qjye\" bias becomes 90 output is \"ihqwcrb4cv8a8dqg056pqjye\"",
      "ja": "バイアス72が入力されている：4ED6 4EEC 4E3A 4EC0 4E48 4E0D 8BF4 4E2D 6587ない基本的なコードポイント、そうないリテラル部次のコード・ポイントが存在しない挿入する4E0Dデルタを必要とされ19853で、「IHQ」バイアスに21次のコードポイントとなるように符号化しますインサートは、4E2Dデルタが64である必要は「WC」バイアスを挿入するために20次のコードポイントとなるようにコード4E3Aデルタを必要とされ、37である「RB」バイアス挿入する13次のコードポイントとなるようにコード4E48デルタを必要とされ、56のように符号化します「v8a」バイアス挿入する32次のコードポイントとなるように、「4C」バイアスを挿入するために17次のコードポイントとなる4EC0デルタが599で必要とされるが、コード4ED6は「8D」バイアスは23次のコードポイントとなるように符号化し、デルタは130であり、必要とされますインサートは、4EECデルタが154である必要で挿入する「QG」バイアスが25となる次のコード・ポイントとしてコード6587はデルタ46301で必要とされる、「056p」バイアスを挿入するために84次のコードポイントとなるようにコード8BF4として符号化し、デルタは88531であり、必要とされます「qjye」はバイアス90の出力が「ihqwcrb4cv8a8dqg056pqjye」でなります"
    },
    {
      "indent": 3,
      "text": "Encoding trace of example L from section 7.1:",
      "ja": "セクション7.1から例Lのトレースをコードします："
    },
    {
      "indent": 3,
      "text": "bias is 72 input is: 0033 5E74 0042 7D44 91D1 516B 5148 751F basic code points (0033, 0042) are copied to literal portion: \"3B-\" next code point to insert is 5148 needed delta is 62042, encodes as \"ww4c\" bias becomes 27 next code point to insert is 516B needed delta is 139, encodes as \"5e\" bias becomes 24 next code point to insert is 5E74 needed delta is 16683, encodes as \"180e\" bias becomes 67 next code point to insert is 751F needed delta is 34821, encodes as \"575a\" bias becomes 82 next code point to insert is 7D44 needed delta is 14592, encodes as \"65l\" bias becomes 67 next code point to insert is 91D1 needed delta is 42088, encodes as \"sy2b\" bias becomes 84 output is \"3B-ww4c5e180e575a65lsy2b\"",
      "ja": "バイアスは、72入力される：0033 5E74 0042 7D44 91D1 516B 5148個の751F基本コード・ポイント（0042 0033）リテラル部分にコピーされる：、挿入する「3B-」次のコードポイント5148は、デルタが62042である必要が「ww4c」バイアスとして符号化します挿入する27次のコード・ポイントになり516Bは、デルタを必要とされ、139で「5E」バイアス挿入する24次のコードポイントとなるようにコード5E74は751Fが必要とされる「180E」バイアス挿入する67次のコードポイントとなるように符号化し、デルタは16683であり、必要とされますデルタは、34821である「575A」バイアスを挿入するために82次のコードポイントとなるようにコード7D44デルタを必要とされ、14592であり、「65リットル」バイアス挿入する67次のコードポイントとなるようにコード91D1はデルタ42088で必要とされる、「sy2b」バイアスとして符号化しますとなり84の出力は、 \"3B-ww4c5e180e575a65lsy2b\" であります"
    },
    {
      "indent": 0,
      "text": "8. Security Considerations",
      "section_title": true,
      "ja": "8.セキュリティの考慮事項"
    },
    {
      "indent": 3,
      "text": "Users expect each domain name in DNS to be controlled by a single authority. If a Unicode string intended for use as a domain label could map to multiple ACE labels, then an internationalized domain name could map to multiple ASCII domain names, each controlled by a different authority, some of which could be spoofs that hijack service requests intended for another. Therefore Punycode is designed so that each Unicode string has a unique encoding.",
      "ja": "ユーザーがDNS内の各ドメイン名は、単一の権限によって制御されることを期待しています。ドメインラベルとして使用することを意図したUnicode文字列は、複数のACEラベルにマッピングすることができれば、その後、国際化ドメイン名は、それぞれそのうちのいくつかは、のために意図したサービス要求を乗っ取るなりすまし可能性があり、異なる権限によって制御、複数のASCIIドメイン名にマップすることができ別の。各Unicode文字列は、固有の符号化を有するようしたがってピュニコードに設計されています。"
    },
    {
      "indent": 3,
      "text": "However, there can still be multiple Unicode representations of the \"same\" text, for various definitions of \"same\". This problem is addressed to some extent by the Unicode standard under the topic of canonicalization, and this work is leveraged for domain names by Nameprep [NAMEPREP].",
      "ja": "しかし、それでも「同じ」の様々な定義については、「同じ」テキストの複数のUnicode表現が存在し得ます。この問題は、正規のトピックの下Unicode標準である程度対処され、そしてこの作品は[NAMEPREP] NAMEPREPによるドメイン名のために活用されます。"
    },
    {
      "indent": 0,
      "text": "9. References",
      "section_title": true,
      "ja": "9.参考文献"
    },
    {
      "indent": 0,
      "text": "9.1 Normative References",
      "section_title": true,
      "ja": "9.1引用規格"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119]ブラドナーの、S.、 \"要件レベルを示すためにRFCsにおける使用のためのキーワード\"、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 0,
      "text": "9.2 Informative References",
      "section_title": true,
      "ja": "9.2参考文献"
    },
    {
      "indent": 3,
      "text": "[RFC952] Harrenstien, K., Stahl, M. and E. Feinler, \"DOD Internet Host Table Specification\", RFC 952, October 1985.",
      "ja": "[RFC952] Harrenstien、K.、スタール、M.およびE. Feinler、 \"DODインターネットホストテーブル仕様\"、RFC 952、1985年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC1034] Mockapetris, P., \"Domain Names - Concepts and Facilities\", STD 13, RFC 1034, November 1987.",
      "ja": "[RFC1034] Mockapetris、P.、 \"ドメイン名 - 概念および機能\"、STD 13、RFC 1034、1987年11月。"
    },
    {
      "indent": 3,
      "text": "[IDNA] Faltstrom, P., Hoffman, P. and A. Costello, \"Internationalizing Domain Names in Applications (IDNA)\", RFC 3490, March 2003.",
      "ja": "[IDNA] Faltstrom、P.、ホフマン、P.およびA.コステロ、 \"アプリケーションにおける国際化ドメイン名（IDNA）\"、RFC 3490、2003年3月。"
    },
    {
      "indent": 3,
      "text": "[NAMEPREP] Hoffman, P. and M. Blanchet, \"Nameprep: A Stringprep Profile for Internationalized Domain Names (IDN)\", RFC 3491, March 2003.",
      "ja": "[NAMEPREP]ホフマン、P.とM.ブランシェ、 \"NAMEPREP：国際化ドメイン名のためのstringprepプロフィール（IDN）\"、RFC 3491、2003年3月。"
    },
    {
      "indent": 3,
      "text": "[ASCII] Cerf, V., \"ASCII format for Network Interchange\", RFC 20, October 1969.",
      "ja": "[ASCII]サーフ、V.、 \"ネットワークの交換のためのASCIIフォーマット\"、RFC 20、1969年10月。"
    },
    {
      "indent": 3,
      "text": "[PROVINCIAL] Kaplan, M., \"The 'anyone can be provincial!' page\", http://www.trigeminal.com/samples/provincial.html.",
      "ja": "[地方]カプラン、M.、「『誰でも地方のことができます！』ページ」、http://www.trigeminal.com/samples/provincial.html。"
    },
    {
      "indent": 3,
      "text": "[UNICODE] The Unicode Consortium, \"The Unicode Standard\", http://www.unicode.org/unicode/standard/standard.html.",
      "ja": "[UNICODE]ユニコードコンソーシアム、 \"Unicode規格\"、http://www.unicode.org/unicode/standard/standard.html。"
    },
    {
      "indent": 0,
      "text": "A. Mixed-case annotation",
      "ja": "A.混在ケース注釈"
    },
    {
      "indent": 3,
      "text": "In order to use Punycode to represent case-insensitive strings, higher layers need to case-fold the strings prior to Punycode encoding. The encoded string can use mixed case as an annotation telling how to convert the folded string into a mixed-case string for display purposes. Note, however, that mixed-case annotation is not used by the ToASCII and ToUnicode operations specified in [IDNA], and therefore implementors of IDNA can disregard this appendix.",
      "ja": "大文字と小文字を区別しない文字列を表すのにピュニコードを使用するために、上位層はピュニコードエンコーディングの前の文字列を大文字倍にする必要があります。エンコードされた文字列は、表示目的のために混在ケース列に折り畳まれた文字列を変換する方法を伝える注釈として混在ケースを使用することができます。混在ケース注釈は[IDNA]で指定もしToASCIIとのToUnicode操作で使用されていないこと、しかし、注意、したがってIDNAを実装は、この付録を無視することができます。"
    },
    {
      "indent": 3,
      "text": "Basic code points can use mixed case directly, because the decoder copies them verbatim, leaving lowercase code points lowercase, and leaving uppercase code points uppercase. Each non-basic code point is represented by a delta, which is represented by a sequence of basic code points, the last of which provides the annotation. If it is uppercase, it is a suggestion to map the non-basic code point to uppercase (if possible); if it is lowercase, it is a suggestion to map the non-basic code point to lowercase (if possible).",
      "ja": "基本的なコードポイントは小文字小文字コードポイントを残し、そして大文字大文字のコードポイントを残し、それらをそのままデコーダコピーので、直接混合ケースを使用することができます。各非基本コードポイントは、アノテーションを提供最後にその基本的なコードポイントの配列で表されるデルタ、で表されます。それが大文字である場合、（可能な場合）大文字に非基本コードポイントをマッピングするための提案です。それは小文字である場合には（可能な場合）、小文字に非基本コードポイントをマップするための提案です。"
    },
    {
      "indent": 3,
      "text": "These annotations do not alter the code points returned by decoders; the annotations are returned separately, for the caller to use or ignore. Encoders can accept annotations in addition to code points, but the annotations do not alter the output, except to influence the uppercase/lowercase form of ASCII letters.",
      "ja": "これらのアノテーションは、デコーダによって返されるコードポイントを変更しません。注釈を使用するか、無視する、発信者のために、個別に返されます。エンコーダは、コード・ポイントに加えて、注釈を受け入れることができますが、ASCII文字の大文字/小文字のフォームに影響を与えるため以外のアノテーションは、出力を変更しないでください。"
    },
    {
      "indent": 3,
      "text": "Punycode encoders and decoders need not support these annotations, and higher layers need not use them.",
      "ja": "ピュニコードエンコーダおよびデコーダは、これらのアノテーションをサポートする必要はありませんし、上位層は、それらを使用する必要はありません。"
    },
    {
      "indent": 0,
      "text": "B. Disclaimer and license",
      "ja": "B.免責事項およびライセンス"
    },
    {
      "indent": 3,
      "text": "Regarding this entire document or any portion of it (including the pseudocode and C code), the author makes no guarantees and is not responsible for any damage resulting from its use. The author grants irrevocable permission to anyone to use, modify, and distribute it in any way that does not diminish the rights of anyone else to use, modify, and distribute it, provided that redistributed derivative works do not contain misleading author or version information. Derivative works need not be licensed under similar terms.",
      "ja": "この文書全体または（擬似コードとCコードを含む）、それのいずれかの部分について、著者は保証を行わず、その使用に起因する損害の原因ではありません。派生作品を再配布提供し、それを使用、変更、および、使用変更する他の誰の権利を損なわない任意の方法でそれを配布し、配布するための誰にも著者の補助金取消不能の許可は、著作者またはバージョンの情報が誤解を招く含まれていません。派生作品は、同様の条件の下でライセンスされる必要はありません。"
    },
    {
      "indent": 0,
      "text": "C. Punycode sample implementation",
      "ja": "C.ピュニコードのサンプル実装"
    },
    {
      "indent": 0,
      "text": "/*\npunycode.c from RFC 3492\nhttp://www.nicemice.net/idn/\nAdam M. Costello\nhttp://www.nicemice.net/amc/",
      "raw": true
    },
    {
      "indent": 0,
      "text": "This is ANSI C code (C89) implementing Punycode (RFC 3492).",
      "ja": "これはピュニコード（RFC 3492）を実装ANSI Cコード（C89）です。"
    },
    {
      "indent": 0,
      "text": "*/",
      "ja": "＊／"
    },
    {
      "indent": 0,
      "text": "/************************************************************/\n/* Public interface (would normally go in its own .h file): */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "#include <limits.h>",
      "ja": "書式#include <limits.hに>"
    },
    {
      "indent": 0,
      "text": "enum punycode_status {\n  punycode_success,\n  punycode_bad_input,   /* Input is invalid.                       */\n  punycode_big_output,  /* Output would exceed the space provided. */\n  punycode_overflow     /* Input needs wider integers to process.  */\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "#if UINT_MAX >= (1 << 26) - 1\ntypedef unsigned int punycode_uint;\n#else\ntypedef unsigned long punycode_uint;\n#endif",
      "raw": true
    },
    {
      "indent": 0,
      "text": "enum punycode_status punycode_encode( punycode_uint input_length, const punycode_uint input[], const unsigned char case_flags[], punycode_uint *output_length, char output[] );",
      "ja": "列挙punycode_status punycode_encode（punycode_uintのinput_length、CONST punycode_uint入力[]、CONST unsigned char型のcase_flags []、punycode_uint * OUTPUT_LENGTH、CHAR出力[]）。"
    },
    {
      "indent": 4,
      "text": "/* punycode_encode() converts Unicode to Punycode.  The input     */\n/* is represented as an array of Unicode code points (not code    */\n/* units; surrogate pairs are not allowed), and the output        */\n/* will be represented as an array of ASCII code points.  The     */\n/* output string is *not* null-terminated; it will contain        */\n/* zeros if and only if the input contains zeros.  (Of course     */\n/* the caller can leave room for a terminator and add one if      */\n/* needed.)  The input_length is the number of code points in     */\n/* the input.  The output_length is an in/out argument: the       */\n/* caller passes in the maximum number of code points that it     */",
      "raw": true
    },
    {
      "indent": 4,
      "text": "/* can receive, and on successful return it will contain the      */\n/* number of code points actually output.  The case_flags array   */\n/* holds input_length boolean values, where nonzero suggests that */\n/* the corresponding Unicode character be forced to uppercase     */\n/* after being decoded (if possible), and zero suggests that      */\n/* it be forced to lowercase (if possible).  ASCII code points    */\n/* are encoded literally, except that ASCII letters are forced    */\n/* to uppercase or lowercase according to the corresponding       */\n/* uppercase flags.  If case_flags is a null pointer then ASCII   */\n/* letters are left as they are, and other code points are        */\n/* treated as if their uppercase flags were zero.  The return     */\n/* value can be any of the punycode_status values defined above   */\n/* except punycode_bad_input; if not punycode_success, then       */\n/* output_size and output might contain garbage.                  */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "enum punycode_status punycode_decode( punycode_uint input_length, const char input[], punycode_uint *output_length, punycode_uint output[], unsigned char case_flags[] );",
      "ja": "列挙punycode_status punycode_decode（punycode_uintのinput_length、CONST文字入力[]、punycode_uint * OUTPUT_LENGTH、punycode_uint出力は[]、unsigned char型のcase_flags []）。"
    },
    {
      "indent": 4,
      "text": "/* punycode_decode() converts Punycode to Unicode.  The input is  */\n/* represented as an array of ASCII code points, and the output   */\n/* will be represented as an array of Unicode code points.  The   */\n/* input_length is the number of code points in the input.  The   */\n/* output_length is an in/out argument: the caller passes in      */\n/* the maximum number of code points that it can receive, and     */\n/* on successful return it will contain the actual number of      */\n/* code points output.  The case_flags array needs room for at    */\n/* least output_length values, or it can be a null pointer if the */\n/* case information is not needed.  A nonzero flag suggests that  */\n/* the corresponding Unicode character be forced to uppercase     */\n/* by the caller (if possible), while zero suggests that it be    */\n/* forced to lowercase (if possible).  ASCII code points are      */\n/* output already in the proper case, but their flags will be set */\n/* appropriately so that applying the flags would be harmless.    */\n/* The return value can be any of the punycode_status values      */\n/* defined above; if not punycode_success, then output_length,    */\n/* output, and case_flags might contain garbage.  On success, the */\n/* decoder will never need to write an output_length greater than */\n/* input_length, because of how the encoding is defined.          */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/**********************************************************/\n/* Implementation (would normally go in its own .c file): */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "#include <string.h>",
      "ja": "書式#include <string.hの>"
    },
    {
      "indent": 0,
      "text": "/*** Bootstring parameters for Punycode ***/",
      "raw": true
    },
    {
      "indent": 0,
      "text": "enum { base = 36, tmin = 1, tmax = 26, skew = 38, damp = 700,\n       initial_bias = 72, initial_n = 0x80, delimiter = 0x2D };",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/* basic(cp) tests whether cp is a basic code point: */\n#define basic(cp) ((punycode_uint)(cp) < 0x80)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/* delim(cp) tests whether cp is a delimiter: */\n#define delim(cp) ((cp) == delimiter)",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/* decode_digit(cp) returns the numeric value of a basic code */\n/* point (for use in representing integers) in the range 0 to */\n/* base-1, or base if cp is does not represent a value.       */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "static punycode_uint decode_digit(punycode_uint cp) { return cp - 48 < 10 ? cp - 22 : cp - 65 < 26 ? cp - 65 : cp - 97 < 26 ? cp - 97 : base; }",
      "ja": "静的punycode_uintのdecode_digit（punycode_uintのCP）{戻りCP  -  48 <10？ CP  -  65 <26：22  -  CP？ CP  -  97 <26：65  -  CP？ CP  -  97：ベース; }"
    },
    {
      "indent": 0,
      "text": "/* encode_digit(d,flag) returns the basic code point whose value      */\n/* (when used for representing integers) is d, which needs to be in   */\n/* the range 0 to base-1.  The lowercase form is used unless flag is  */\n/* nonzero, in which case the uppercase form is used.  The behavior   */\n/* is undefined if flag is nonzero and digit d has no uppercase form. */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "static char encode_digit(punycode_uint d, int flag)\n{\n  return d + 22 + 75 * (d < 26) - ((flag != 0) << 5);\n  /*  0..25 map to ASCII a..z or A..Z */\n  /* 26..35 map to ASCII 0..9         */\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/* flagged(bcp) tests whether a basic code point is flagged */\n/* (uppercase).  The behavior is undefined if bcp is not a  */\n/* basic code point.                                        */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "#define flagged(bcp) ((punycode_uint)(bcp) - 65 < 26)",
      "ja": "#defineは、フラグが立てられ（BCP）（（punycode_uint）（BCP） -  65 <26）"
    },
    {
      "indent": 0,
      "text": "/* encode_basic(bcp,flag) forces a basic code point to lowercase */\n/* if flag is zero, uppercase if flag is nonzero, and returns    */\n/* the resulting code point.  The code point is unchanged if it  */\n/* is caseless.  The behavior is undefined if bcp is not a basic */\n/* code point.                                                   */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "static char encode_basic(punycode_uint bcp, int flag) {",
      "ja": "静的チャーencode_basic（punycode_uintのBCP、INTフラグ）{"
    },
    {
      "indent": 0,
      "text": "  bcp -= (bcp - 97 < 26) << 5;\n  return bcp + ((!flag && (bcp - 65 < 26)) << 5);\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/*** Platform-specific constants ***/",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/* maxint is the maximum value of a punycode_uint variable: */\nstatic const punycode_uint maxint = -1;\n/* Because maxint is unsigned, -1 becomes the maximum value. */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/*** Bias adaptation function ***/",
      "raw": true
    },
    {
      "indent": 0,
      "text": "static punycode_uint adapt( punycode_uint delta, punycode_uint numpoints, int firsttime ) { punycode_uint k;",
      "ja": "静的punycode_uint（punycode_uintデルタ、punycode_uint numpoints、INT FIRSTTIME）{punycode_uint kを適応させます。"
    },
    {
      "indent": 2,
      "text": "delta = firsttime ? delta / damp : delta >> 1;\n/* delta >> 1 is a faster way of doing delta / 2 */\ndelta += delta / numpoints;",
      "raw": true
    },
    {
      "indent": 2,
      "text": "for (k = 0; delta > ((base - tmin) * tmax) / 2; k += base) { delta /= base - tmin; }",
      "ja": "（;  -  TMIN）* TMAX）/ 2デルタ>（（ベース; K + =ベースK = 0）{デルタ/ =ベース -  TMINため、 }"
    },
    {
      "indent": 0,
      "text": " return k + (base - tmin + 1) * delta / (delta + skew); }",
      "ja": "戻りK +（ベース -  TMIN + 1）*デルタ/（デルタ+スキュー）。 }"
    },
    {
      "indent": 0,
      "text": "/*** Main encode function ***/",
      "raw": true
    },
    {
      "indent": 0,
      "text": "enum punycode_status punycode_encode( punycode_uint input_length, const punycode_uint input[], const unsigned char case_flags[], punycode_uint *output_length, char output[] ) { punycode_uint n, delta, h, b, out, max_out, bias, j, m, q, k, t;",
      "ja": "列挙punycode_status punycode_encode（punycode_uintのinput_length、CONST punycode_uint入力[]、CONST unsigned char型のcase_flags []、punycode_uint * OUTPUT_LENGTH、チャー出力は[]）{punycode_uint N、デルタ、H、B、アウト、max_out、バイアス、J、M、Q 、K、T。"
    },
    {
      "indent": 2,
      "text": "/* Initialize the state: */",
      "raw": true
    },
    {
      "indent": 2,
      "text": "n = initial_n;\ndelta = out = 0;\nmax_out = *output_length;\nbias = initial_bias;",
      "raw": true
    },
    {
      "indent": 2,
      "text": "/* Handle the basic code points: */ for (j = 0;  j < input_length;  ++j) {\n  if (basic(input[j])) {\n    if (max_out - out < 2) return punycode_big_output;\n    output[out++] =\n      case_flags ?  encode_basic(input[j], case_flags[j]) : input[j];\n  }\n  /* else if (input[j] < n) return punycode_bad_input; */\n  /* (not needed for Punycode with unsigned code points) */\n}",
      "raw": true
    },
    {
      "indent": 2,
      "text": "h = b = out;",
      "ja": "H = B =うち。"
    },
    {
      "indent": 2,
      "text": "/* h is the number of code points that have been handled, b is the  */\n/* number of basic code points, and out is the number of characters */\n/* that have been output.                                           */",
      "raw": true
    },
    {
      "indent": 2,
      "text": "if (b > 0) output[out++] = delimiter;",
      "ja": "IF（B> 0）出力[OUT ++] =デリミタ。"
    },
    {
      "indent": 2,
      "text": "/* Main encoding loop: */",
      "raw": true
    },
    {
      "indent": 2,
      "text": "while (h < input_length) {\n  /* All non-basic code points < n have been     */\n  /* handled already.  Find the next larger one: */",
      "raw": true
    },
    {
      "indent": 4,
      "text": "for (m = maxint, j = 0;  j < input_length;  ++j) {\n  /* if (basic(input[j])) continue; */\n  /* (not needed for Punycode) */\n  if (input[j] >= n && input[j] < m) m = input[j];\n}",
      "raw": true
    },
    {
      "indent": 4,
      "text": "/* Increase delta enough to advance the decoder's    */\n/* <n,i> state to <m,0>, but guard against overflow: */",
      "raw": true
    },
    {
      "indent": 4,
      "text": "if (m - n > (maxint - delta) / (h + 1)) return punycode_overflow;\ndelta += (m - n) * (h + 1);\nn = m;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "for (j = 0;  j < input_length;  ++j) {\n  /* Punycode does not need to check whether input[j] is basic: */\n  if (input[j] < n /* || basic(input[j]) */ ) {\n    if (++delta == 0) return punycode_overflow;\n  }",
      "raw": true
    },
    {
      "indent": 6,
      "text": "if (input[j] == n) {\n  /* Represent delta as a generalized variable-length integer: */",
      "raw": true
    },
    {
      "indent": 8,
      "text": "for (q = delta, k = base; ; k += base) { if (out >= max_out) return punycode_big_output;",
      "ja": "{IF（> = max_out OUT）戻りpunycode_big_output;（; K + =ベースQ =デルタ、K =ベース）のために、"
    },
    {
      "indent": 8,
      "text": "  t = k <= bias /* + tmin */ ? tmin :     /* +tmin not needed */\n      k >= bias + tmax ? tmax : k - bias;\n  if (q < t) break;\n  output[out++] = encode_digit(t + (q - t) % (base - t), 0);\n  q = (q - t) / (base - t);\n}",
      "raw": true
    },
    {
      "indent": 4,
      "text": "    output[out++] = encode_digit(q, case_flags && case_flags[j]);\n    bias = adapt(delta, h + 1, h == b);\n    delta = 0;\n    ++h;\n  }\n}",
      "raw": true
    },
    {
      "indent": 2,
      "text": " ++delta, ++n; }",
      "ja": "デルタ++、++ nは、 }"
    },
    {
      "indent": 0,
      "text": "  *output_length = out;\n  return punycode_success;\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/*** Main decode function ***/",
      "raw": true
    },
    {
      "indent": 0,
      "text": "enum punycode_status punycode_decode( punycode_uint input_length, const char input[], punycode_uint *output_length, punycode_uint output[], unsigned char case_flags[] ) { punycode_uint n, out, i, max_out, bias, b, j, in, oldi, w, k, digit, t;",
      "ja": "列挙punycode_status punycode_decode（punycode_uintのinput_length、CONST文字入力[]、punycode_uint * OUTPUT_LENGTH、punycode_uint出力[]、unsigned char型のcase_flags []）{punycode_uintのN、アウト、I、max_out、バイアス、B、J、で、oldi、W、 K、数字、T。"
    },
    {
      "indent": 2,
      "text": "/* Initialize the state: */",
      "raw": true
    },
    {
      "indent": 2,
      "text": "n = initial_n;\nout = i = 0;\nmax_out = *output_length;\nbias = initial_bias;",
      "raw": true
    },
    {
      "indent": 2,
      "text": "/* Handle the basic code points:  Let b be the number of input code */\n/* points before the last delimiter, or 0 if there is none, then    */\n/* copy the first b code points to the output.                      */",
      "raw": true
    },
    {
      "indent": 2,
      "text": "for (b = j = 0;  j < input_length;  ++j) if (delim(input[j])) b = j;\nif (b > max_out) return punycode_big_output;",
      "raw": true
    },
    {
      "indent": 2,
      "text": "for (j = 0; j < b; ++j) {",
      "ja": "{（; J <B ++ J、J = 0）のための"
    },
    {
      "indent": 2,
      "text": "  if (case_flags) case_flags[out] = flagged(input[j]);\n  if (!basic(input[j])) return punycode_bad_input;\n  output[out++] = input[j];\n}",
      "raw": true
    },
    {
      "indent": 2,
      "text": "/* Main decoding loop:  Start just after the last delimiter if any  */\n/* basic code points were copied; start at the beginning otherwise. */",
      "raw": true
    },
    {
      "indent": 2,
      "text": "for (in = b > 0 ? b + 1 : 0; in < input_length; ++out) {",
      "ja": "用（IN = B> 0、B + 1：0; <input_lengthに、アウト++）{"
    },
    {
      "indent": 4,
      "text": "/* in is the index of the next character to be consumed, and */\n/* out is the number of code points in the output array.     */",
      "raw": true
    },
    {
      "indent": 4,
      "text": "/* Decode a generalized variable-length integer into delta,  */\n/* which gets added to i.  The overflow checking is easier   */\n/* if we increase i as we go, then subtract off its starting */\n/* value at the end to obtain delta.                         */",
      "raw": true
    },
    {
      "indent": 4,
      "text": "for (oldi = i, w = 1, k = base;  ;  k += base) {\n  if (in >= input_length) return punycode_bad_input;\n  digit = decode_digit(input[in++]);\n  if (digit >= base) return punycode_bad_input;\n  if (digit > (maxint - i) / w) return punycode_overflow;\n  i += digit * w;\n  t = k <= bias /* + tmin */ ? tmin :     /* +tmin not needed */\n      k >= bias + tmax ? tmax : k - bias;\n  if (digit < t) break;\n  if (w > maxint / (base - t)) return punycode_overflow;\n  w *= (base - t);\n}",
      "raw": true
    },
    {
      "indent": 4,
      "text": "bias = adapt(i - oldi, out + 1, oldi == 0);",
      "ja": "（バイアス= I + 1 == 0を取り出した適応）。"
    },
    {
      "indent": 4,
      "text": "/* i was supposed to wrap around from out+1 to 0,   */\n/* incrementing n each time, so we'll fix that now: */",
      "raw": true
    },
    {
      "indent": 4,
      "text": "if (i / (out + 1) > maxint - n) return punycode_overflow;\nn += i / (out + 1);\ni %= (out + 1);",
      "raw": true
    },
    {
      "indent": 4,
      "text": "/* Insert n at position i of the output: */",
      "raw": true
    },
    {
      "indent": 4,
      "text": "/* not needed for Punycode: */\n/* if (decode_digit(n) <= base) return punycode_invalid_input; */\nif (out >= max_out) return punycode_big_output;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "if (case_flags) { memmove(case_flags + i + 1, case_flags + i, out - i);",
      "ja": "IF（case_flags）{MEMMOVE（case_flags + I + 1、case_flags OUT + I  -  I）。"
    },
    {
      "indent": 4,
      "text": "  /* Case of last character determines uppercase flag: */\n  case_flags[i] = flagged(input[in - 1]);\n}",
      "raw": true
    },
    {
      "indent": 2,
      "text": "  memmove(output + i + 1, output + i, (out - i) * sizeof *output);\n  output[i++] = n;\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "  *output_length = out;\n  return punycode_success;\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/******************************************************************/\n/* Wrapper for testing (would normally go in a separate .c file): */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "#include <assert.h> #include <stdio.h> #include <stdlib.h> #include <string.h>",
      "ja": "#include <assert.h>の#include <stdio.hに>する#include <stdlib.h>に含ま書式#include <string.hの>"
    },
    {
      "indent": 0,
      "text": "/* For testing, we'll just set some compile-time limits rather than */\n/* use malloc(), and set a compile-time option rather than using a  */\n/* command-line option.                                             */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "enum {\n  unicode_max_length = 256,\n  ace_max_length = 256\n};",
      "raw": true
    },
    {
      "indent": 0,
      "text": "static void usage(char **argv)\n{\n  fprintf(stderr,\n    \"\\n\"\n    \"%s -e reads code points and writes a Punycode string.\\n\"\n    \"%s -d reads a Punycode string and writes code points.\\n\"\n    \"\\n\"\n    \"Input and output are plain text in the native character set.\\n\"\n    \"Code points are in the form u+hex separated by whitespace.\\n\"\n    \"Although the specification allows Punycode strings to contain\\n\"\n    \"any characters from the ASCII repertoire, this test code\\n\"\n    \"supports only the printable characters, and needs the Punycode\\n\"\n    \"string to be followed by a newline.\\n\"\n    \"The case of the u in u+hex is the force-to-uppercase flag.\\n\"\n    , argv[0], argv[0]);\n  exit(EXIT_FAILURE);\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "static void fail(const char *msg)",
      "ja": "静的な無効た（constのchar *のMSGを）失敗します"
    },
    {
      "indent": 0,
      "text": "{\n  fputs(msg,stderr);\n  exit(EXIT_FAILURE);\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "static const char too_big[] =\n  \"input or output is too large, recompile with larger limits\\n\";\nstatic const char invalid_input[] = \"invalid input\\n\";\nstatic const char overflow[] = \"arithmetic overflow\\n\";\nstatic const char io_error[] = \"I/O error\\n\";",
      "raw": true
    },
    {
      "indent": 0,
      "text": "/* The following string is used to convert printable */\n/* characters between ASCII and the native charset:  */",
      "raw": true
    },
    {
      "indent": 0,
      "text": "static const char print_ascii[] = \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\" \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\" \" !\\\"#$%&'()*+,-./\" \"0123456789:;<=>?\" \"@ABCDEFGHIJKLMNO\" \"PQRSTUVWXYZ[\\\\]^_\" \"`abcdefghijklmno\" \"pqrstuvwxyz{|}~\\n\";",
      "ja": "静的定数チャーprint_ascii [] = \"\\ n \\ n \\ n \\ n \\ n \\ n \\ n \\ n \\ n \\ n \\ n \\ n \\ n \\ n \\ n \\ n\" は「\\ n \\ n \\ n \\ nは\\ N \\ N \\ N \\ N \\ N \\ N \\ N \\ N \\ N \\ N \\ N \\ N」 \"\\！\" ＃$％＆ '（）* +、 -  /」「0123456789：; <=> ？」 \"@ABCDEFGHIJKLMNO\" \"pQRSTUVWXYZ [\\\\] ^ _\" \"` ABCDEFGHIJKLMNO\" \"pqrstuvwxyz {|}〜\\ nを\";"
    },
    {
      "indent": 0,
      "text": "int main(int argc, char **argv)\n{\n  enum punycode_status status;\n  int r;\n  unsigned int input_length, output_length, j;\n  unsigned char case_flags[unicode_max_length];",
      "raw": true
    },
    {
      "indent": 2,
      "text": "if (argc != 2) usage(argv);\nif (argv[1][0] != '-') usage(argv);\nif (argv[1][2] != 0) usage(argv);",
      "raw": true
    },
    {
      "indent": 2,
      "text": "if (argv[1][1] == 'e') {\n  punycode_uint input[unicode_max_length];\n  unsigned long codept;\n  char output[ace_max_length+1], uplus[3];\n  int c;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "/* Read the input code points: */",
      "raw": true
    },
    {
      "indent": 4,
      "text": "input_length = 0;",
      "ja": "input_length = 0;"
    },
    {
      "indent": 4,
      "text": "for (;;) {\n  r = scanf(\"%2s%lx\", uplus, &codept);\n  if (ferror(stdin)) fail(io_error);",
      "raw": true
    },
    {
      "indent": 6,
      "text": "if (r == EOF || r == 0) break;",
      "ja": "もし（R == EOF || R == 0）ブレーク。"
    },
    {
      "indent": 6,
      "text": "if (r != 2 || uplus[1] != '+' || codept > (punycode_uint)-1) { fail(invalid_input); }",
      "ja": "IF（R = 2 || uplus [1] = '+' || codept>（punycode_uint）-1！）{（INVALID_INPUT）失敗。 }"
    },
    {
      "indent": 6,
      "text": "if (input_length == unicode_max_length) fail(too_big);",
      "ja": "もし（input_length == unicode_max_length）（too_big）は失敗。"
    },
    {
      "indent": 6,
      "text": "if (uplus[0] == 'u') case_flags[input_length] = 0;\nelse if (uplus[0] == 'U') case_flags[input_length] = 1;\nelse fail(invalid_input);",
      "raw": true
    },
    {
      "indent": 4,
      "text": " input[input_length++] = codept; }",
      "ja": "入力【input_length ++] = codept。 }"
    },
    {
      "indent": 4,
      "text": "/* Encode: */",
      "raw": true
    },
    {
      "indent": 4,
      "text": "output_length = ace_max_length;\nstatus = punycode_encode(input_length, input, case_flags,\n                         &output_length, output);\nif (status == punycode_bad_input) fail(invalid_input);\nif (status == punycode_big_output) fail(too_big);\nif (status == punycode_overflow) fail(overflow);\nassert(status == punycode_success);",
      "raw": true
    },
    {
      "indent": 4,
      "text": "/* Convert to native charset and output: */",
      "raw": true
    },
    {
      "indent": 4,
      "text": "for (j = 0;  j < output_length;  ++j) {\n  c = output[j];\n  assert(c >= 0 && c <= 127);\n  if (print_ascii[c] == 0) fail(invalid_input);\n  output[j] = print_ascii[c];\n}",
      "raw": true
    },
    {
      "indent": 2,
      "text": "  output[j] = 0;\n  r = puts(output);\n  if (r == EOF) fail(io_error);\n  return EXIT_SUCCESS;\n}",
      "raw": true
    },
    {
      "indent": 2,
      "text": "if (argv[1][1] == 'd') {\n  char input[ace_max_length+2], *p, *pp;\n  punycode_uint output[unicode_max_length];",
      "raw": true
    },
    {
      "indent": 4,
      "text": "/* Read the Punycode input string and convert to ASCII: */",
      "raw": true
    },
    {
      "indent": 4,
      "text": "fgets(input, ace_max_length+2, stdin);\nif (ferror(stdin)) fail(io_error);",
      "raw": true
    },
    {
      "indent": 4,
      "text": "if (feof(stdin)) fail(invalid_input);\ninput_length = strlen(input) - 1;\nif (input[input_length] != '\\n') fail(too_big);\ninput[input_length] = 0;",
      "raw": true
    },
    {
      "indent": 4,
      "text": "for (p = input;  *p != 0;  ++p) {\n  pp = strchr(print_ascii, *p);\n  if (pp == 0) fail(invalid_input);\n  *p = pp - print_ascii;\n}",
      "raw": true
    },
    {
      "indent": 4,
      "text": "/* Decode: */",
      "raw": true
    },
    {
      "indent": 4,
      "text": "output_length = unicode_max_length;\nstatus = punycode_decode(input_length, input, &output_length,\n                         output, case_flags);\nif (status == punycode_bad_input) fail(invalid_input);\nif (status == punycode_big_output) fail(too_big);\nif (status == punycode_overflow) fail(overflow);\nassert(status == punycode_success);",
      "raw": true
    },
    {
      "indent": 4,
      "text": "/* Output the result: */",
      "raw": true
    },
    {
      "indent": 4,
      "text": "for (j = 0;  j < output_length;  ++j) {\n  r = printf(\"%s+%04lX\\n\",\n             case_flags[j] ? \"U\" : \"u\",\n             (unsigned long) output[j] );\n  if (r < 0) fail(io_error);\n}",
      "raw": true
    },
    {
      "indent": 2,
      "text": " return EXIT_SUCCESS; }",
      "ja": "EXIT_SUCCESSを返します。 }"
    },
    {
      "indent": 0,
      "text": "  usage(argv);\n  return EXIT_SUCCESS;  /* not reached, but quiets compiler warning */\n}",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Author's Address",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Adam M. Costello University of California, Berkeley http://www.nicemice.net/amc/",
      "ja": "カリフォルニア大学バークレー校のアダム・M.コステロ大学http://www.nicemice.net/amc/"
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2003). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2003）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.",
      "ja": "この文書とその翻訳は、コピーして他の人に提供し、それ以外についてはコメントまたは派生物は、いかなる種類の制限もなく、全体的にまたは部分的に、準備コピーし、公表して配布することができることを説明したり、その実装を支援することができます、上記の著作権表示とこの段落は、すべてのそのようなコピーや派生物に含まれていることを条件とします。しかし、この文書自体は著作権のための手順はで定義されている場合には、インターネット標準を開発するために必要なものを除き、インターネットソサエティもしくは他のインターネット関連団体に著作権情報や参照を取り除くなど、どのような方法で変更されないかもしれませんインターネット標準化プロセスが続く、または英語以外の言語に翻訳するために、必要に応じなければなりません。"
    },
    {
      "indent": 3,
      "text": "The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.",
      "ja": "上記の制限は永久で、インターネット学会やその後継者や譲渡者によって取り消されることはありません。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein is provided on an \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書とここに含まれている情報は、基礎とインターネットソサエティおよびインターネットエンジニアリングタスクフォースはすべての保証を否認し、明示または黙示、その情報の利用がない任意の保証を含むがこれらに限定されない「として、」上に設けられています特定の目的への権利または商品性または適合性の黙示の保証を侵害します。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "了承"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFC Editor機能のための基金は現在、インターネット協会によって提供されます。"
    }
  ]
}