{
  "title": {
    "text": "RFC 3460 - Policy Core Information Model (PCIM) Extensions",
    "ja": "RFC 3460 - 方針コア情報モデル（PCIM）の拡張機能"
  },
  "number": 3460,
  "created_at": "2019-10-28 18:12:04.324600+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                      B. Moore, Ed.\nRequest for Comments: 3460                                           IBM\nUpdates: 3060                                               January 2003\nCategory: Standards Track",
      "raw": true
    },
    {
      "indent": 12,
      "text": "Policy Core Information Model (PCIM) Extensions",
      "raw": true
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "ja": "このメモの位置付け"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "ja": "この文書は、インターネットコミュニティのためのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態と状態への「インターネット公式プロトコル標準」（STD 1）の最新版を参照してください。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2003). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2003）。全著作権所有。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "抽象"
    },
    {
      "indent": 3,
      "text": "This document specifies a number of changes to the Policy Core Information Model (PCIM, RFC 3060). Two types of changes are included. First, several completely new elements are introduced, for example, classes for header filtering, that extend PCIM into areas that it did not previously cover. Second, there are cases where elements of PCIM (for example, policy rule priorities) are deprecated, and replacement elements are defined (in this case, priorities tied to associations that refer to policy rules). Both types of changes are done in such a way that, to the extent possible, interoperability with implementations of the original PCIM model is preserved. This document updates RFC 3060.",
      "ja": "この文書では、ポリシーコア情報モデル（PCIM、RFC 3060）への変更の数を指定します。変化の二つのタイプが含まれています。まず、いくつかの完全に新しい要素が導入され、例えば、それが以前にカバーしていない領域にPCIMを拡張ヘッダフィルタリングのクラス、。第二に、PCIMの要素は、（例えば、ポリシールールの優先度）が廃止され場合がある、と交換要素（この場合には、優先順位は、ポリシールールを参照アソシエーションに接続）が定義されています。変更の両方のタイプは、可能な限り、元のPCIMモデルの実装との相互運用性が維持されるような方法で行われます。この文書は、RFC 3060に更新します。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction....................................................5\n2. Changes since RFC 3060..........................................5\n3. Overview of the Changes.........................................6\n   3.1. How to Change an Information Model.........................6\n   3.2. List of Changes to the Model...............................6\n        3.2.1. Changes to PolicyRepository.........................6\n        3.2.2. Additional Associations and Additional Reusable\n               Elements............................................7\n        3.2.3. Priorities and Decision Strategies..................7\n        3.2.4. Policy Roles........................................8\n        3.2.5. CompoundPolicyConditions and\n               CompoundPolicyActions...............................8",
      "raw": true
    },
    {
      "indent": 3,
      "text": "        3.2.6. Variables and Values................................9\n        3.2.7. Domain-Level Packet Filtering.......................9\n        3.2.8. Device-Level Packet Filtering.......................9\n4. The Updated Class and Association Class Hierarchies............10\n5. Areas of Extension to PCIM.....................................13\n   5.1. Policy Scope..............................................13\n        5.1.1. Levels of Abstraction: Domain- and Device-Level\n               Policies...........................................13\n        5.1.2. Administrative and Functional Scopes...............14\n   5.2. Reusable Policy Elements..................................15\n   5.3. Policy Sets...............................................16\n   5.4. Nested Policy Rules.......................................16\n        5.4.1. Usage Rules for Nested Rules.......................17\n        5.4.2. Motivation.........................................17\n   5.5. Priorities and Decision Strategies........................18\n        5.5.1. Structuring Decision Strategies....................19\n        5.5.2. Side Effects.......................................21\n        5.5.3. Multiple PolicySet Trees For a Resource............21\n        5.5.4. Deterministic Decisions............................22\n   5.6. Policy Roles..............................................23\n        5.6.1. Comparison of Roles in PCIM with Roles in\n               snmpconf...........................................23\n        5.6.2. Addition of PolicyRoleCollection to PCIMe..........24\n        5.6.3. Roles for PolicyGroups.............................25\n   5.7. Compound Policy Conditions and Compound Policy Actions....27\n        5.7.1. Compound Policy Conditions.........................27\n        5.7.2. Compound Policy Actions............................27\n   5.8. Variables and Values......................................28\n        5.8.1. Simple Policy Conditions...........................29\n        5.8.2. Using Simple Policy Conditions.....................29\n        5.8.3. The Simple Condition Operator......................31\n        5.8.4. SimplePolicyActions................................33\n        5.8.5. Policy Variables...................................35\n        5.8.6. Explicitly Bound Policy Variables..................36\n        5.8.7. Implicitly Bound Policy Variables..................37\n        5.8.8. Structure and Usage of Pre-Defined Variables.......38\n        5.8.9. Rationale for Modeling Implicit Variables\n               as Classes.........................................39\n        5.8.10. Policy Values.....................................40\n   5.9. Packet Filtering..........................................41\n        5.9.1. Domain-Level Packet Filters........................41\n        5.9.2. Device-Level Packet Filters........................42\n   5.10. Conformance to PCIM and PCIMe............................43\n6. Class Definitions..............................................44\n   6.1. The Abstract Class \"PolicySet\"............................44\n   6.2. Update PCIM's Class \"PolicyGroup\".........................45\n   6.3. Update PCIM's Class \"PolicyRule\"..........................45\n   6.4. The Class \"SimplePolicyCondition\".........................46",
      "raw": true
    },
    {
      "indent": 6,
      "text": "6.5. The Class \"CompoundPolicyCondition\".......................47\n6.6. The Class \"CompoundFilterCondition\".......................47\n6.7. The Class \"SimplePolicyAction\"............................48\n6.8. The Class \"CompoundPolicyAction\"..........................48\n6.9. The Abstract Class \"PolicyVariable\".......................50\n6.10. The Class \"PolicyExplicitVariable\".......................50\n     6.10.1. The Single-Valued Property \"ModelClass\"...........51\n     6.10.2. The Single-Valued Property ModelProperty..........51\n6.11. The Abstract Class \"PolicyImplicitVariable\"..............51\n     6.11.1. The Multi-Valued Property \"ValueTypes\"............52\n6.12. Subclasses of \"PolicyImplicitVariable\" Specified\n      in PCIMe.................................................52\n     6.12.1. The Class \"PolicySourceIPv4Variable\"..............52\n     6.12.2. The Class \"PolicySourceIPv6Variable\"..............52\n     6.12.3. The Class \"PolicyDestinationIPv4Variable\".........53\n     6.12.4. The Class \"PolicyDestinationIPv6Variable\".........53\n     6.12.5. The Class \"PolicySourcePortVariable\"..............54\n     6.12.6. The Class \"PolicyDestinationPortVariable\".........54\n     6.12.7. The Class \"PolicyIPProtocolVariable\"..............54\n     6.12.8. The Class \"PolicyIPVersionVariable\"...............55\n     6.12.9. The Class \"PolicyIPToSVariable\"...................55\n     6.12.10. The Class \"PolicyDSCPVariable\"...................55\n     6.12.11. The Class \"PolicyFlowIdVariable\".................56\n     6.12.12. The Class \"PolicySourceMACVariable\"..............56\n     6.12.13. The Class \"PolicyDestinationMACVariable\".........56\n     6.12.14. The Class \"PolicyVLANVariable\"...................56\n     6.12.15. The Class \"PolicyCoSVariable\"....................57\n     6.12.16. The Class \"PolicyEthertypeVariable\"..............57\n     6.12.17. The Class \"PolicySourceSAPVariable\"..............57\n     6.12.18. The Class \"PolicyDestinationSAPVariable\".........58\n     6.12.19. The Class \"PolicySNAPOUIVariable\"................58\n     6.12.20. The Class \"PolicySNAPTypeVariable\"...............59\n     6.12.21. The Class \"PolicyFlowDirectionVariable\"..........59\n6.13. The Abstract Class \"PolicyValue\".........................59\n6.14. Subclasses of \"PolicyValue\" Specified in PCIMe...........60\n     6.14.1. The Class \"PolicyIPv4AddrValue\"...................60\n     6.14.2. The Class \"PolicyIPv6AddrValue....................61\n     6.14.3. The Class \"PolicyMACAddrValue\"....................62\n     6.14.4. The Class \"PolicyStringValue\".....................63\n     6.14.5. The Class \"PolicyBitStringValue\"..................63\n     6.14.6. The Class \"PolicyIntegerValue\"....................64\n     6.14.7. The Class \"PolicyBooleanValue\"....................65\n6.15. The Class \"PolicyRoleCollection\".........................65\n     6.15.1. The Single-Valued Property \"PolicyRole\"...........66\n     6.16. The Class \"ReusablePolicyContainer\".................66\n6.17. Deprecate PCIM's Class \"PolicyRepository\"................66\n6.18. The Abstract Class \"FilterEntryBase\".....................67\n6.19. The Class \"IpHeadersFilter\"..............................67",
      "raw": true
    },
    {
      "indent": 3,
      "text": "        6.19.1. The Property HdrIpVersion.........................68\n        6.19.2. The Property HdrSrcAddress........................68\n        6.19.3. The Property HdrSrcAddressEndOfRange..............68\n        6.19.4. The Property HdrSrcMask...........................69\n        6.19.5. The Property HdrDestAddress.......................69\n        6.19.6. The Property HdrDestAddressEndOfRange.............69\n        6.19.7. The Property HdrDestMask..........................70\n        6.19.8. The Property HdrProtocolID........................70\n        6.19.9. The Property HdrSrcPortStart......................70\n        6.19.10. The Property HdrSrcPortEnd.......................70\n        6.19.11. The Property HdrDestPortStart....................71\n        6.19.12. The Property HdrDestPortEnd......................71\n        6.19.13. The Property HdrDSCP.............................72\n        6.19.14. The Property HdrFlowLabel.................... ...72\n   6.20. The Class \"8021Filter\"...................................72\n        6.20.1. The Property 8021HdrSrcMACAddr....................73\n        6.20.2. The Property 8021HdrSrcMACMask....................73\n        6.20.3. The Property 8021HdrDestMACAddr...................73\n        6.20.4. The Property 8021HdrDestMACMask...................73\n        6.20.5. The Property 8021HdrProtocolID....................74\n        6.20.6. The Property 8021HdrPriorityValue.................74\n        6.20.7. The Property 8021HdrVLANID........................74\n   6.21. The Class FilterList.....................................74\n        6.21.1. The Property Direction............................75\n7. Association and Aggregation Definitions........................75\n   7.1. The Aggregation \"PolicySetComponent\"......................75\n   7.2. Deprecate PCIM's Aggregation \"PolicyGroupInPolicyGroup\"...76\n   7.3. Deprecate PCIM's Aggregation \"PolicyRuleInPolicyGroup\"....76\n   7.4. The Abstract Association \"PolicySetInSystem\"..............77\n   7.5. Update PCIM's Weak Association \"PolicyGroupInSystem\"......77\n   7.6. Update PCIM's Weak Association \"PolicyRuleInSystem\".......78\n   7.7. The Abstract Aggregation \"PolicyConditionStructure\".......79\n   7.8. Update PCIM's Aggregation \"PolicyConditionInPolicyRule\"...79\n   7.9. The Aggregation \"PolicyConditionInPolicyCondition\"........79\n   7.10. The Abstract Aggregation \"PolicyActionStructure\".........80\n   7.11. Update PCIM's Aggregation \"PolicyActionInPolicyRule\".....80\n   7.12. The Aggregation \"PolicyActionInPolicyAction\".............80\n   7.13. The Aggregation \"PolicyVariableInSimplePolicyCondition\"..80\n   7.14. The Aggregation \"PolicyValueInSimplePolicyCondition\".....81\n   7.15. The Aggregation \"PolicyVariableInSimplePolicyAction\".....82\n   7.16. The Aggregation \"PolicyValueInSimplePolicyAction\"........83\n   7.17. The Association \"ReusablePolicy\".........................83\n   7.18. Deprecate PCIM's \"PolicyConditionInPolicyRepository\".....84\n   7.19. Deprecate PCIM's \"PolicyActionInPolicyRepository\"........84\n   7.20. The Association ExpectedPolicyValuesForVariable..........84\n   7.21. The Aggregation \"ContainedDomain\"........................85\n   7.22. Deprecate PCIM's \"PolicyRepositoryInPolicyRepository\"....86\n   7.23. The Aggregation \"EntriesInFilterList\"....................86",
      "raw": true
    },
    {
      "indent": 3,
      "text": "        7.23.1. The Reference GroupComponent......................86\n        7.23.2. The Reference PartComponent.......................87\n        7.23.3. The Property EntrySequence........................87\n   7.24. The Aggregation \"ElementInPolicyRoleCollection\"..........87\n   7.25. The Weak Association \"PolicyRoleCollectionInSystem\"......87\n8. Intellectual Property..........................................88\n9.  Acknowledgements..............................................89\n10. Contributors..................................................89\n11. Security Considerations.......................................91\n12. Normative References..........................................91\n13. Informative References........................................91\nAuthor's Address..................................................92\nFull Copyright Statement..........................................93",
      "raw": true
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1.はじめに"
    },
    {
      "indent": 3,
      "text": "This document specifies a number of changes to the Policy Core Information Model (PCIM), RFC 3060 [1]. Two types of changes are included. First, several completely new elements are introduced, for example, classes for header filtering, that extend PCIM into areas that it did not previously cover. Second, there are cases where elements of PCIM (for example, policy rule priorities) are deprecated, and replacement elements are defined (in this case, priorities tied to associations that refer to policy rules). Both types of changes are done in such a way that, to the extent possible, interoperability with implementations of the original PCIM model is preserved.",
      "ja": "この文書では、ポリシーコア情報モデル（PCIM）への変更の数を指定し、RFC 3060 [1]。変化の二つのタイプが含まれています。まず、いくつかの完全に新しい要素が導入され、例えば、それが以前にカバーしていない領域にPCIMを拡張ヘッダフィルタリングのクラス、。第二に、PCIMの要素は、（例えば、ポリシールールの優先度）が廃止され場合がある、と交換要素（この場合には、優先順位は、ポリシールールを参照アソシエーションに接続）が定義されています。変更の両方のタイプは、可能な限り、元のPCIMモデルの実装との相互運用性が維持されるような方法で行われます。"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14, RFC 2119 [8].",
      "ja": "この文書のキーワード \"MUST\"、 \"MUST NOT\"、 \"REQUIRED\"、、、、 \"べきではない\" \"べきである\" \"ないもの\" \"ものとし\"、 \"推奨\"、 \"MAY\"、および \"OPTIONAL\" はありますBCP 14、RFC 2119に記載されるように解釈される[8]。"
    },
    {
      "indent": 1,
      "text": "2. Changes since",
      "section_title": true,
      "ja": "2.からの変更点"
    },
    {
      "indent": 3,
      "text": "Section 3.2 contains a short discussion of the changes that this document makes to the RFC 3060 information model. Here is a very brief list of the changes:",
      "ja": "3.2節は、この文書はRFC 3060の情報モデルに加えた変更の短い議論が含まれています。ここでは、変更の非常に短いリストは、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "1. Deprecate and replace PolicyRepository and its associations. 2. Clarify and expand the ways that PolicyRules and PolicyGroups are aggregated. 3. Change how prioritization for PolicyRules is represented, and introduce administrator-specified decision strategies for rule evaluation. 4. Expand the role of PolicyRoles, and introduce a means of associating a PolicyRole with a resource. 5. Introduce compound policy conditions and compound policy actions into the model.",
      "ja": "1.非推奨とPolicyRepositoryとその関連付けを交換してください。 2. PolicyRulesとPolicyGroupsが集約されている方法を明確にして展開します。 3. PolicyRulesのための優先順位付けを表現し、ルール評価のための管理者が指定した意思決定戦略を導入する方法を変更します。 4. PolicyRolesの役割を展開し、リソースとPolicyRoleを関連付ける手段をご紹介します。 5.モデルに化合物ポリシーの条件および化合物のポリシーアクションを紹介。"
    },
    {
      "indent": 3,
      "text": "6. Introduce variables and values into the model. 7. Introduce variable and value subclasses for packet-header filtering. 8. Introduce classes for device-level packet-header filtering.",
      "ja": "6.モデルに変数と値を紹介します。 7.パケットのヘッダフィルタリングの変数および値サブクラスを導入します。 8.デバイス・レベルのパケット・ヘッダ・フィルタリングのためのクラスを導入します。"
    },
    {
      "indent": 0,
      "text": "3. Overview of the Changes",
      "section_title": true,
      "ja": "変更の概要3。"
    },
    {
      "indent": 0,
      "text": "3.1. How to Change an Information Model",
      "section_title": true,
      "ja": "3.1。情報モデルを変更する方法"
    },
    {
      "indent": 3,
      "text": "The Policy Core Information Model is closely aligned with the DMTF's CIM Core Policy model. Since there is no separately documented set of rules for specifying IETF information models such as PCIM, it is reasonable to look to the CIM specifications for guidance on how to modify and extend the model. Among the CIM rules for changing an information model are the following. Note that everything said here about \"classes\" applies to association classes (including aggregations) as well as to non- association classes.",
      "ja": "方針コア情報モデルは密接にDMTFのCIM基本方針モデルと整合されます。全く別に、このようなPCIMとしてIETF情報モデルを指定するための一連のルールが文書化されていないので、修正してモデルを拡張する方法についての指導のためのCIM仕様に見て合理的です。情報モデルを変更するためのCIM規則の中で、以下の通りです。すべてが（集計を含む）関連クラスなどの非関連クラスに適用され、ここで、「クラス」について述べていることに注意してください。"
    },
    {
      "indent": 3,
      "text": "o Properties may be added to existing classes. o Classes, and individual properties, may be marked as DEPRECATED. If there is a replacement feature for the deprecated class or property, it is identified explicitly. Otherwise the notation \"No value\" is used. In this document, the notation \"DEPRECATED FOR <feature-name>\" is used to indicate that a feature has been deprecated, and to identify its replacement feature. o Classes may be inserted into the inheritance hierarchy above existing classes, and properties from the existing classes may then be \"pulled up\" into the new classes. The net effect is that the existing classes have exactly the same properties they had before, but the properties are inherited rather than defined explicitly in the classes. o New subclasses may be defined below existing classes.",
      "ja": "Oプロパティは、既存のクラスに追加することができます。 Oクラス、そして個々のプロパティは廃止としてマークすることができます。推奨されないクラスやプロパティの代替機能がある場合は、それが明示的に識別されます。それ以外の場合は表記「いいえ値が」使用されています。この文書では、表記「推奨されていません。<機能名>」機能は廃止されたことを示すために、その代替機能を識別するために使用されます。 Oクラスは既存のクラス上の継承階層に挿入することができ、かつ既存のクラスからのプロパティは、新しいクラスに「プルアップ」することができます。正味の効果は、既存のクラスは、彼らが前に持っていたとまったく同じ性質を持っていますが、プロパティが継承されたのではなくクラスで明示的に定義されているということです。 O新しいサブクラスは、既存のクラス以下に定義することができます。"
    },
    {
      "indent": 0,
      "text": "3.2. List of Changes to the Model",
      "section_title": true,
      "ja": "3.2。モデルへの変更の一覧"
    },
    {
      "indent": 3,
      "text": "The following subsections provide a very brief overview of the changes to PCIM defined in PCIMe. In several cases, the origin of the change is noted, as QPIM [11], ICPM [12], or QDDIM [15].",
      "ja": "以下のサブセクションは、で定義されPCIMe PCIMの変更を非常に簡単な概要を提供しています。いくつかのケースでは、変化の起源はQPIM [11]、ICPM [12]、またはQDDIM [15]のように、注意されたいです。"
    },
    {
      "indent": 0,
      "text": "3.2.1. Changes to PolicyRepository",
      "section_title": true,
      "ja": "3.2.1。ポリシーリポジトリへの変更"
    },
    {
      "indent": 3,
      "text": "Because of the potential for confusion with the Policy Framework component Policy Repository (from the four-box picture: Policy Management Tool, Policy Repository, PDP, PEP), \"PolicyRepository\" is a bad name for the PCIM class representing a container of reusable policy elements. Thus the class PolicyRepository is being replaced with the class ReusablePolicyContainer. To accomplish this change, it is necessary to deprecate the PCIM class PolicyRepository and its three associations, and replace them with a new class ReusablePolicyContainer and new associations. As a separate change, the associations for ReusablePolicyContainer are being broadened, to allow a ReusablePolicyContainer to contain any reusable policy elements. In PCIM, the only associations defined for a PolicyRepository were for it to contain reusable policy conditions and policy actions.",
      "ja": "そのためポリシーフレームワークコンポーネントポリシーリポジトリとの混同の可能性（4-ボックスの絵から：ポリシー管理ツール、ポリシーリポジトリ、PDP、PEP）、「PolicyRepositoryは、」再利用可能なポリシーのコンテナを表すPCIMクラスの悪い名前です要素。したがって、クラスPolicyRepositoryは、クラスReusablePolicyContainerに置き換えられています。この変更を達成するために、PCIMのクラスPolicyRepositoryとその3つの団体を廃止し、新しいクラスReusablePolicyContainerと新しい団体でそれらを交換する必要があります。別の変更として、ReusablePolicyContainerための関連はReusablePolicyContainer任意の再利用可能なポリシー要素を含むことができるように、広げられています。それは、再利用可能なポリシー条件とポリシーアクションを含むようにするためにPCIMでは、PolicyRepositoryのために定義された唯一の団体でした。"
    },
    {
      "indent": 0,
      "text": "3.2.2. Additional Associations and Additional Reusable Elements",
      "section_title": true,
      "ja": "3.2.2。追加の団体や追加の再利用可能な要素"
    },
    {
      "indent": 3,
      "text": "The PolicyRuleInPolicyRule and PolicyGroupInPolicyRule aggregations have, in effect, been imported from QPIM. (\"In effect\" because these two aggregations, as well as PCIM's two aggregations PolicyGroupInPolicyGroup and PolicyRuleInPolicyGroup, are all being combined into a single aggregation PolicySetComponent.) These aggregations make it possible to define larger \"chunks\" of reusable policy to place in a ReusablePolicyContainer. These aggregations also introduce new semantics representing the contextual implications of having one PolicyRule executing within the scope of another PolicyRule.",
      "ja": "PolicyRuleInPolicyRuleとPolicyGroupInPolicyRule集計は、実際には、QPIMから輸入されています。これらの集計はReusablePolicyContainerに配置するための再利用可能なポリシーのより大きな「チャンク」を定義することを可能にする（これらの二つの集合体、ならびにPCIMの2件の集計PolicyGroupInPolicyGroupとPolicyRuleInPolicyGroupは、すべての単一の集約PolicySetComponentに結合されている。ので、「実際に」） 。これらの集計は、別のPolicyRuleの範囲内で実行する1つのPolicyRuleを有するの文脈意味を表す新しい意味論を導入します。"
    },
    {
      "indent": 0,
      "text": "3.2.3. Priorities and Decision Strategies",
      "section_title": true,
      "ja": "3.2.3。優先順位と意思決定戦略"
    },
    {
      "indent": 3,
      "text": "Drawing from both QPIM and ICPM, the Priority property has been deprecated in PolicyRule, and placed instead on the aggregation PolicySetComponent. The QPIM rules for resolving relative priorities across nested PolicyGroups and PolicyRules have been incorporated into PCIMe as well. With the removal of the Priority property from PolicyRule, a new modeling dependency is introduced. In order to prioritize a PolicyRule/PolicyGroup relative to other PolicyRules/PolicyGroups, the elements being prioritized must all reside in one of three places: in a common PolicyGroup, in a common PolicyRule, or in a common System.",
      "ja": "QPIMとICPMの両方から描画、PriorityプロパティはPolicyRuleの中で非推奨、および集約PolicySetComponentに代わりに置かれています。ネストされたPolicyGroupsとPolicyRules横切って相対的な優先順位を解決するためQPIMルールもPCIMeに組み込まれています。 PolicyRuleのから優先プロパティを除去しながら、新しいモデリング依存性が導入されます。他のPolicyRules / PolicyGroupsにPolicyRuleの/のPolicyGroup比べを優先するために、要素が優先されているすべての3つの場所のいずれかに存在する必要があり共通のPolicyGroupに、共通のPolicyRuleに、または共通のシステムに。"
    },
    {
      "indent": 3,
      "text": "In the absence of any clear, general criterion for detecting policy conflicts, the PCIM restriction stating that priorities are relevant only in the case of conflicts is being removed. In its place, a PolicyDecisionStrategy property has been added to the PolicyGroup and PolicyRule classes. This property allows policy administrator to select one of two behaviors with respect to rule evaluation: either perform the actions for all PolicyRules whose conditions evaluate to TRUE, or perform the actions only for the highest-priority PolicyRule whose conditions evaluate to TRUE. (This is accomplished by placing the PolicyDecisionStrategy property in an abstract class PolicySet, from which PolicyGroup and PolicyRule are derived.) The QPIM rules for applying decision strategies to a nested set of PolicyGroups and PolicyRules have also been imported.",
      "ja": "ポリシーの競合を検出するための明確な、一般的な基準がない場合、優先度だけ衝突の場合に関連していることを示すPCIM制限が除去されています。その代わりに、PolicyDecisionStrategyプロパティがのPolicyGroupとPolicyRuleのクラスに追加されました。このプロパティは、ポリシー管理者が評価を支配に対する2つの動作のいずれかを選択することができます：条件TRUEと評価され、すべてのPolicyRulesためのアクションを実行する、または唯一その条件TRUEと評価さ最優先のPolicyRuleのためのアクションを実行するのいずれか。 （これはのPolicyGroupとPolicyRuleのが由来する抽象クラスPOLICYSETにPolicyDecisionStrategyプロパティを配置することによって達成される。）PolicyGroupsとPolicyRulesのネストされたセットに決定戦略を適用するためのQPIMルールもインポートされています。"
    },
    {
      "indent": 0,
      "text": "3.2.4. Policy Roles",
      "section_title": true,
      "ja": "3.2.4。政策の役割"
    },
    {
      "indent": 3,
      "text": "The concept of policy roles is added to PolicyGroups (being present already in the PolicyRule class). This is accomplished via a new superclass for both PolicyRules and PolicyGroups - PolicySet. For nested PolicyRules and PolicyGroups, any roles associated with the outer rule or group are automatically \"inherited\" by the nested one. Additional roles may be added at the level of a nested rule or group.",
      "ja": "ポリシーの役割の概念は、（PolicyRuleのクラスに既に存在している）PolicyGroupsに添加されます。 POLICYSET  - これはPolicyRulesとPolicyGroupsの両方のための新しいスーパークラスを介して達成されます。ネストされたPolicyRulesとPolicyGroupsため、外側ルールまたはグループに関連付けられた任意の役割が自動的にネストされた一方によって「継承」されています。追加の役割は、ネストされたルールまたはグループのレベルで添加することができます。"
    },
    {
      "indent": 3,
      "text": "It was also observed that there is no mechanism in PCIM for assigning roles to resources. For example, while it is possible in PCIM to associate a PolicyRule with the role \"FrameRelay&&WAN\", there is no way to indicate which interfaces match this criterion. A new PolicyRoleCollection class has been defined in PCIMe, representing the collection of resources associated with a particular role. The linkage between a PolicyRule or PolicyGroup and a set of resources is then represented by an instance of PolicyRoleCollection. Equivalent values should be defined in the PolicyRoles property of PolicyRules and PolicyGroups, and in the PolicyRole property in PolicyRoleCollection.",
      "ja": "また、リソースにロールを割り当てるためのPCIMで機構がないことが観察されました。それは役割「フレームリレー&& WAN」とのPolicyRuleを関連付けるPCIMに可能であるが、例えば、この基準に一致するインターフェースかを示す方法はありません。新しいPolicyRoleCollectionクラスは、特定の役割に関連付けられたリソースの集合を表す、PCIMeで定義されています。 PolicyRuleの又はのPolicyGroupとリソースのセットとの間の結合は、その後PolicyRoleCollectionのインスタンスによって表されます。同等の値はPolicyRulesとPolicyGroupsのPolicyRolesプロパティに、そしてPolicyRoleCollectionでPolicyRoleプロパティで定義されなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.2.5. CompoundPolicyConditions and CompoundPolicyActions",
      "section_title": true,
      "ja": "3.2.5。 CompoundPolicyConditionsとCompoundPolicyActions"
    },
    {
      "indent": 3,
      "text": "The concept of a CompoundPolicyCondition has also been imported into PCIMe from QPIM, and broadened to include a parallel CompoundPolicyAction. In both cases the idea is to create reusable \"chunks\" of policy that can exist as named elements in a ReusablePolicyContainer. The \"Compound\" classes and their associations incorporate the condition and action semantics that PCIM defined at the PolicyRule level: DNF/CNF for conditions, and ordering for actions.",
      "ja": "CompoundPolicyConditionの概念は、QPIMからPCIMeにインポートし、パラレルCompoundPolicyActionを含むように広げられています。どちらの場合も考え方はReusablePolicyContainerの名前付きの要素として存在しうる政策の再利用可能な「チャンク」を作成することです。条件のためにDNF / CNF、およびアクションのために発注：「化合物」クラスとその関連は、PCIMがPolicyRuleのレベルで定義された条件とアクションセマンティックスを組み込みます。"
    },
    {
      "indent": 3,
      "text": "Compound conditions and actions are defined to work with any component conditions and actions. In other words, while the components may be instances, respectively, of SimplePolicyCondition and SimplePolicyAction (discussed immediately below), they need not be.",
      "ja": "複合条件とアクションは、任意のコンポーネントの条件とアクションで動作するように定義されています。換言すれば、コンポーネントはそれぞれ、インスタンスであってもよいが、SimplePolicyCondition及びSimplePolicyAction（すぐ下に説明する）の、それらがである必要はありません。"
    },
    {
      "indent": 0,
      "text": "3.2.6. Variables and Values",
      "section_title": true,
      "ja": "3.2.6。変数と値"
    },
    {
      "indent": 3,
      "text": "The SimplePolicyCondition / PolicyVariable / PolicyValue structure has been imported into PCIMe from QPIM. A list of PCIMe-level variables is defined, as well as a list of PCIMe-level values. Other variables and values may, if necessary, be defined in submodels of PCIMe. For example, QPIM defines a set of implicit variables corresponding to fields in RSVP flows.",
      "ja": "SimplePolicyCondition / PolicyVariable / PolicyValue構造がQPIMからPCIMeにインポートされています。 PCIMeレベルの変数のリストが定義され、ならびにPCIMeレベル値のリストです。他の変数と値は、必要に応じて、PCIMeのサブモデル内に定義されてもよいです。例えば、QPIMは、RSVPフロー内のフィールドに対応する暗黙的な変数のセットを定義します。"
    },
    {
      "indent": 3,
      "text": "A corresponding SimplePolicyAction / PolicyVariable / PolicyValue structure is also defined. While the semantics of a SimplePolicyCondition are \"variable matches value\", a SimplePolicyAction has the semantics \"set variable to value\".",
      "ja": "対応SimplePolicyAction / PolicyVariable / PolicyValue構造も定義されています。 SimplePolicyConditionのセマンティクスが「変数一致値」ですが、SimplePolicyActionは「値に変数を設定する」の意味を持っています。"
    },
    {
      "indent": 0,
      "text": "3.2.7. Domain-Level Packet Filtering",
      "section_title": true,
      "ja": "3.2.7。ドメインレベルのパケットフィルタリング"
    },
    {
      "indent": 3,
      "text": "For packet filtering specified at the domain level, a set of PolicyVariables and PolicyValues are defined, corresponding to the fields in an IP packet header plus the most common Layer 2 frame header fields. It is expected that domain-level policy conditions that filter on these header fields will be expressed in terms of CompoundPolicyConditions built up from SimplePolicyConditions that use these variables and values. An additional PolicyVariable, PacketDirection, is also defined, to indicate whether a packet being filtered is traveling inbound or outbound on an interface.",
      "ja": "ドメインレベルで指定されたパケットフィルタリングのために、PolicyVariablesとPolicyValuesのセットは、IPパケットヘッダ内のフィールドに加えて、最も一般的なレイヤ2フレームヘッダフィールドに対応し、定義されています。これらのヘッダーフィールドにフィルタが、これらの変数と値を使用SimplePolicyConditionsから構築CompoundPolicyConditionsで表現されることをドメインレベルのポリシー条件が期待されます。追加PolicyVariable、PacketDirectionは、また、フィルタリングされたパケットがインターフェイス上で着信または発信を走行しているかどうかを示すために、定義されています。"
    },
    {
      "indent": 0,
      "text": "3.2.8. Device-Level Packet Filtering",
      "section_title": true,
      "ja": "3.2.8。デバイスレベルパケットフィルタリング"
    },
    {
      "indent": 3,
      "text": "For packet filtering expressed at the device level, including the packet classifier filters modeled in QDDIM, the variables and values discussed in Section 3.2.7 need not be used. Filter classes derived from the CIM FilterEntryBase class hierarchy are available for use in these contexts. These latter classes have two important differences from the domain-level classes:",
      "ja": "パケットフィルタリングはQDDIMでモデル化パケット分類器フィルタを含む、デバイスレベルで発現されるため、セクション3.2.7で説明した変数と値を使用する必要はありません。 CIM FilterEntryBaseクラス階層から派生したフィルタクラスは、これらの状況で使用できます。これらの後者のクラスは、ドメインレベルのクラスからの二つの重要な違いがあります。"
    },
    {
      "indent": 3,
      "text": "o They support specification of filters for all of the fields in a particular protocol header in a single object instance. With the domain-level classes, separate instances are needed for each header field.",
      "ja": "Oそれらは、単一のオブジェクトのインスタンスに特定のプロトコル・ヘッダ内のフィールドのすべてのフィルタの仕様をサポートします。ドメインレベルのクラスで、別々のインスタンスが各ヘッダフィールドのために必要とされます。"
    },
    {
      "indent": 3,
      "text": "o They provide native representations for the filter values, as opposed to the string representation used by the domain-level classes.",
      "ja": "Oそれらは、ドメインレベルのクラスによって使用される文字列表現とは対照的に、フィルタ値のネイティブ表現を提供します。"
    },
    {
      "indent": 3,
      "text": "Device-level filter classes for the IP-related headers (IP, UDP, and TCP) and the 802 MAC headers are defined, respectively, in Sections 6.19 and 6.20.",
      "ja": "IP関連のヘッダ（IP、UDP、およびTCP）及び802のMACヘッダのデバイスレベルのフィルタクラスは、セクション6.19及び6.20に、それぞれ、定義されています。"
    },
    {
      "indent": 0,
      "text": "4. The Updated Class and Association Class Hierarchies",
      "section_title": true,
      "ja": "4.更新されたクラスおよび関連クラス階層"
    },
    {
      "indent": 3,
      "text": "The following figure shows the class inheritance hierarchy for PCIMe. Changes from the PCIM hierarchy are noted parenthetically.",
      "ja": "次の図は、PCIMeのクラス継承階層を示しています。 PCIM階層からの変更点は、括弧内に記載されています。"
    },
    {
      "indent": 3,
      "text": "ManagedElement (abstract)\n   |\n   +--Policy (abstract)\n   |  |\n   |  +---PolicySet (abstract -- new - 5.3)\n   |  |   |\n   |  |   +---PolicyGroup (moved - 5.3)\n   |  |   |\n   |  |   +---PolicyRule (moved - 5.3)\n   |  |\n   |  +---PolicyCondition (abstract)\n   |  |   |\n   |  |   +---PolicyTimePeriodCondition\n   |  |   |\n   |  |   +---VendorPolicyCondition\n   |  |   |\n   |  |   +---SimplePolicyCondition (new - 5.8.1)\n   |  |   |\n   |  |   +---CompoundPolicyCondition (new - 5.7.1)\n   |  |       |\n   |  |       +---CompoundFilterCondition (new - 5.9)\n   |  |\n   |  +---PolicyAction (abstract)\n   |  |   |\n   |  |   +---VendorPolicyAction\n   |  |   |\n   |  |   +---SimplePolicyAction (new - 5.8.4)\n   |  |   |\n   |  |   +---CompoundPolicyAction (new - 5.7.2)\n   |  |\n   |  +---PolicyVariable (abstract -- new - 5.8.5)\n   |  |   |\n   |  |   +---PolicyExplicitVariable (new - 5.8.6)\n   |  |   |\n   |  |   +---PolicyImplicitVariable (abstract -- new - 5.8.7)\n   |  |       |\n   |  |       +---(subtree of more specific classes -- new - 6.12)\n   |  |\n   |  +---PolicyValue (abstract -- new - 5.8.10)\n   |      |\n   |      +---(subtree of more specific classes -- new - 6.14)\n   |\n   +--Collection (abstract -- newly referenced)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "   |  |\n   |  +--PolicyRoleCollection (new - 5.6.2)\nManagedElement(abstract)\n   |\n   +--ManagedSystemElement (abstract)\n      |\n      +--LogicalElement (abstract)\n         |\n         +--System (abstract)\n         |  |\n         |  +--AdminDomain (abstract)\n         |     |\n         |     +---ReusablePolicyContainer (new - 5.2)\n         |     |\n         |     +---PolicyRepository (deprecated - 5.2)\n         |\n         +--FilterEntryBase (abstract -- new - 6.18)\n         |  |\n         |  +--IpHeadersFilter (new - 6.19)\n         |  |\n         |  +--8021Filter (new - 6.20)\n         |\n         +--FilterList (new - 6.21)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Figure 1. Class Inheritance Hierarchy for PCIMe",
      "ja": "PCIMe図1.クラスの継承階層"
    },
    {
      "indent": 3,
      "text": "The following figure shows the association class hierarchy for PCIMe. As before, changes from PCIM are noted parenthetically.",
      "ja": "次の図は、PCIMeのための関連クラス階層を示しています。前と同じように、PCIMからの変更は、括弧内に記載されています。"
    },
    {
      "indent": 3,
      "text": "[unrooted]\n   |\n   +---PolicyComponent (abstract)\n   |   |\n   |   +---PolicySetComponent (new - 5.3)\n   |   |\n   |   +---PolicyGroupInPolicyGroup (deprecated - 5.3)\n   |   |\n   |   +---PolicyRuleInPolicyGroup (deprecated - 5.3)\n   |   |\n   |   +---PolicyConditionStructure (abstract -- new - 5.7.1)\n   |   |    |\n   |   |    +---PolicyConditionInPolicyRule  (moved - 5.7.1)\n   |   |    |\n   |   |    +---PolicyConditionInPolicyCondition (new - 5.7.1)\n   |   |\n   |   +---PolicyRuleValidityPeriod\n   |   |\n   |   +---PolicyActionStructure (abstract -- new - 5.7.2)\n   |   |    |\n   |   |    +---PolicyActionInPolicyRule  (moved - 5.7.2)\n   |   |    |\n   |   |    +---PolicyActionInPolicyAction (new - 5.7.2)\n   |   |\n   |   +---PolicyVariableInSimplePolicyCondition (new - 5.8.2)\n   |   |\n   |   +---PolicyValueInSimplePolicyCondition (new - 5.8.2)\n   |   |\n   |   +---PolicyVariableInSimplePolicyAction (new - 5.8.4)\n   |   |\n   |   +---PolicyValueInSimplePolicyAction (new - 5.8.4)\n[unrooted]\n   |\n   +---Dependency (abstract)\n   |   |\n   |   +---PolicyInSystem (abstract)\n   |   |   |\n   |   |   +---PolicySetInSystem (abstract, new - 5.3)\n   |   |   |   |\n   |   |   |   +---PolicyGroupInSystem\n   |   |   |   |\n   |   |   |   +---PolicyRuleInSystem\n   |   |   |\n   |   |   +---ReusablePolicy (new - 5.2)\n   |   |   |",
      "raw": true
    },
    {
      "indent": 6,
      "text": "|   |   +---PolicyConditionInPolicyRepository (deprecated - 5.2)\n|   |   |\n|   |   +---PolicyActionInPolicyRepository (deprecated - 5.2)\n|   |\n|   +---ExpectedPolicyValuesForVariable (new - 5.8)\n|   |\n|   +---PolicyRoleCollectionInSystem (new - 5.6.2)\n|\n+---Component (abstract)\n|   |\n|   +---SystemComponent\n|   |   |\n|   |   +---ContainedDomain (new - 5.2)\n|   |   |\n|   |   +---PolicyRepositoryInPolicyRepository (deprecated - 5.2)\n|   |\n|   +---EntriesInFilterList (new - 7.23)\n|\n+---MemberOfCollection (newly referenced)\n    |\n    +--- ElementInPolicyRoleCollection (new - 5.6.2)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Figure 2. Association Class Inheritance Hierarchy for PCIMe",
      "ja": "PCIMe図2.関連クラス継承階層"
    },
    {
      "indent": 3,
      "text": "In addition to these changes that show up at the class and association class level, there are other changes from PCIM involving individual class properties. In some cases new properties are introduced into existing classes, and in other cases existing properties are deprecated (without deprecating the classes that contain them).",
      "ja": "クラスと関連クラスレベルで現れるこれらの変化に加えて、個々のクラスのプロパティを含むPCIMから他の変更があります。いくつかのケースでは新しいプロパティは、既存のクラスに導入され、それ以外の場合には既存のプロパティは、（それらを含むクラスを卑下せず）は推奨されています。"
    },
    {
      "indent": 0,
      "text": "5. Areas of Extension to PCIM",
      "section_title": true,
      "ja": "PCIMへの拡張の5エリア"
    },
    {
      "indent": 3,
      "text": "The following subsections describe each of the areas for which PCIM extensions are being defined.",
      "ja": "以下のサブセクションでは、PCIM拡張機能が定義されている領域のそれぞれを記述する。"
    },
    {
      "indent": 0,
      "text": "5.1. Policy Scope",
      "section_title": true,
      "ja": "5.1。ポリシー適用範囲"
    },
    {
      "indent": 3,
      "text": "Policy scopes may be thought of in two dimensions: 1) the level of abstraction of the policy specification and 2) the applicability of policies to a set of managed resources.",
      "ja": "管理対象リソースのセットへの政策の1）政策の仕様及び2の抽象化のレベルを）適用：ポリシースコープは2次元で考えることができます。"
    },
    {
      "indent": 0,
      "text": "5.1.1. Levels of Abstraction: Domain- and Device-Level Policies",
      "section_title": true,
      "ja": "5.1.1。抽象化のレベル：ドメイン単位およびデバイスレベルのポリシー"
    },
    {
      "indent": 3,
      "text": "Policies vary in level of abstraction, from the business-level expression of service level agreements (SLAs) to the specification of a set of rules that apply to devices in a network. Those latter policies can, themselves, be classified into at least two groups: those policies consumed by a Policy Decision Point (PDP) that specify the rules for an administrative and functional domain, and those policies consumed by a Policy Enforcement Point (PEP) that specify the device-specific rules for a functional domain. The higher-level rules consumed by a PDP, called domain-level policies, may have late binding variables unspecified, or specified by a classification, whereas the device-level rules are likely to have fewer unresolved bindings.",
      "ja": "ポリシーは、ネットワーク内のデバイスに適用されるルールのセットの仕様にサービスレベル契約（SLA）のビジネスレベルの発現から、抽象化のレベルが変化します。これらの後者のポリシーは、それ自体が、少なくとも二つのグループに分類することができる：管理および機能的ドメインのルールを指定するポリシー決定ポイント（PDP）によって消費されるそれらのポリシー、およびポリシー施行点（PEP）で消費されるそれらのポリシーをその機能ドメインのためのデバイス固有のルールを指定します。デバイスレベルの規則が少ない未解決のバインディングを持っている可能性があるのに対し、ドメインレベルのポリシーと呼ばれるPDPで消費されるより高いレベルのルールは、未指定、または分類で指定された遅延バインディング変数を有することができます。"
    },
    {
      "indent": 3,
      "text": "There is a relationship between these levels of policy specification that is out of scope for this standards effort, but that is necessary in the development and deployment of a usable policy-based configuration system. An SLA-level policy transformation to the domain-level policy may be thought of as analogous to a visual builder that takes human input and develops a programmatic rule specification. The relationship between the domain-level policy and the device-level policy may be thought of as analogous to that of a compiler and linkage editor that translates the rules into specific instructions that can be executed on a specific type of platform.",
      "ja": "そここの規格努力の範囲外である政策仕様のこれらのレベル間の関係はあるが、それは、使用可能なポリシーベースのコンフィギュレーションシステムの開発と展開に必要です。ドメインレベルのポリシーにSLAレベルのポリシー変換は、人間の入力を受け取り、プログラムルール仕様を開発ビジュアル・ビルダのような類似したと考えることができます。ドメインレベルのポリシーおよびデバイスレベルのポリシーとの間の関係は、プラットフォームの特定のタイプで実行することができる特定の命令にルールを変換コンパイラとリンケージエディタのそれに類似したとして考えることができます。"
    },
    {
      "indent": 3,
      "text": "PCIM and PCIMe may be used to specify rules at any and all of these levels of abstraction. However, at different levels of abstraction, different mechanisms may be more or less appropriate.",
      "ja": "PCIMとPCIMeは、抽象化のこれらのレベルの任意のおよび全てでの規則を指定するために使用されてもよいです。しかし、抽象化の異なるレベルで、異なるメカニズムが多かれ少なかれ適切であり得ます。"
    },
    {
      "indent": 0,
      "text": "5.1.2. Administrative and Functional Scopes",
      "section_title": true,
      "ja": "5.1.2。管理および機能スコープ"
    },
    {
      "indent": 3,
      "text": "Administrative scopes for policy are represented in PCIM and in these extensions to PCIM as System subclass instances. Typically, a domain-level policy would be scoped by an AdminDomain instance (or by a hierarchy of AdminDomain instances) whereas a device-level policy might be scoped by a System instance that represents the PEP (e.g., an instance of ComputerSystem, see CIM [2]). In addition to collecting policies into an administrative domain, these System classes may also aggregate the resources to which the policies apply.",
      "ja": "ポリシーの管理スコープは、システムのサブクラスのインスタンスとしてPCIMにPCIMにし、これらの拡張機能で表現されています。デバイスレベルのポリシーは、PEPを表すシステム・インスタンスによってスコープされるかもしれないのに対して、典型的には、ドメインレベルのポリシーがいるAdminDomainインスタンス（又はいるAdminDomainインスタンスの階層によって）によってスコープされるであろう（例えば、たComputerSystemのインスタンス、CIMを参照[2]）。管理ドメインにポリシーを収集することに加えて、これらのシステムクラスもポリシーが適用されるリソースを集約することができます。"
    },
    {
      "indent": 3,
      "text": "Functional scopes (sometimes referred to as functional domains) are generally defined by the submodels derived from PCIM and PCIMe, and correspond to the service or services to which the policies apply. So, for example, Quality of Service may be thought of as a functional scope, or Diffserv and Intserv may each be thought of as functional scopes. These scoping decisions are represented by the structure of the submodels derived from PCIM and PCIMe, and may be reflected in the number and types of PEP policy client(s), services, and the interaction between policies. Policies in different functional scopes are organized into disjoint sets of policy rules. Different functional domains may share some roles, some conditions, and even some actions. The rules from different functional domains may even be enforced at the same managed resource, but for the purposes of policy evaluation they are separate. See section 5.5.3 for more information.",
      "ja": "機能スコープは、一般に、PCIMとPCIMe由来するサブモデルによって定義され、サービスまたはポリシーが適用されるサービスに対応している（時には機能的ドメインと呼ばれます）。だから、例えば、サービスの品質は、機能範囲と考えることができる、またはDiffservのとのIntServは、それぞれとして機能スコープと考えることができます。これらのスコープの決定はPCIMとPCIMe由来するサブモデルの構造で表され、その数及びPEPポリシークライアント（複数可）、サービスの種類、およびポリシーとの間の相互作用に反映することができます。異なる機能のスコープのポリシーは、ポリシールールの互いに素な集合に編成されています。異なる機能ドメインは、いくつかの役割、いくつかの条件、さらにいくつかのアクションを共有することがあります。異なる機能ドメインからのルールは同じであっても、管理対象リソースで施行することができるが、政策評価の目的のために、彼らは別のものです。詳細については、セクション5.5.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "The functional scopes MAY be reflected in administrative scopes. That is, deployments of policy may have different administrative scopes for different functional scopes, but there is no requirement to do so.",
      "ja": "機能的スコープは、管理スコープに反映させることができます。つまり、政策の展開は異なる機能スコープの異なる管理スコープを持っているかもしれないが、そうする必要はありません。"
    },
    {
      "indent": 0,
      "text": "5.2. Reusable Policy Elements",
      "section_title": true,
      "ja": "5.2。再利用可能なポリシーの要素"
    },
    {
      "indent": 3,
      "text": "In PCIM, a distinction was drawn between reusable PolicyConditions and PolicyActions and rule-specific ones. The PolicyRepository class was also defined, to serve as a container for these reusable elements. The name \"PolicyRepository\" has proven to be an unfortunate choice for the class that serves as a container for reusable policy elements. This term is already used in documents like the Policy Framework, to denote the location from which the PDP retrieves all policy specifications, and into which the Policy Management Tool places all policy specifications. Consequently, the PolicyRepository class is being deprecated, in favor of a new class ReusablePolicyContainer.",
      "ja": "PCIMにおいて、区別は、再利用可能なPolicyConditionsとPolicyActionsとルール特定のものの間に引かれました。 PolicyRepositoryクラスは、これらの再利用可能な要素のコンテナとして機能するように、定義されました。名前「PolicyRepositoryは、」再利用可能なポリシー要素のコンテナとして機能するクラスの不幸な選択であることが証明されています。この用語は、すでにPDPは、すべてのポリシーの仕様を取得し、その中にポリシー管理ツールは、すべてのポリシーの仕様を配置する場所を示すために、ポリシーフレームワークのようなドキュメントで使用されています。その結果、PolicyRepositoryクラスは、新しいクラスReusablePolicyContainerの賛成で、廃止される予定です。"
    },
    {
      "indent": 3,
      "text": "When a class is deprecated, any associations that refer to it must also be deprecated. So replacements are needed for the two associations PolicyConditionInPolicyRepository and PolicyActionInPolicyRepository, as well as for the aggregation PolicyRepositoryInPolicyRepository. In addition to renaming the PolicyRepository class to ReusablePolicyContainer, however, PCIMe is also broadening the types of policy elements that can be reusable. Consequently, rather than providing one-for-one replacements for the two associations, a single higher-level association ReusablePolicy is defined. This new association allows any policy element (that is, an instance of any subclass of the abstract class Policy) to be placed in a ReusablePolicyContainer.",
      "ja": "クラスは非推奨されている場合、それを参照するすべての団体も廃止される必要があります。だから、置換は2つの団体PolicyConditionInPolicyRepositoryとPolicyActionInPolicyRepositoryのためだけでなく、集約PolicyRepositoryInPolicyRepositoryのために必要とされます。 ReusablePolicyContainerにPolicyRepositoryクラスの名前を変更することに加えて、しかし、PCIMeも再利用可能とすることができるポリシー要素の種類を広げています。従って、むしろ2つのアソシエーションための1対1の交換、ReusablePolicyが定義されている単一の上位レベルの関連付けを提供するより。この新しい関連付けは、任意のポリシー要素（つまり、抽象クラスポリシーの任意のサブクラスのインスタンスである）ReusablePolicyContainerに配置することを可能にします。"
    },
    {
      "indent": 3,
      "text": "Summarizing, the following changes in Sections 6 and 7 are the result of this item:",
      "ja": "要約すると、セクション6および7における以下の変更は、この項目の結果です。"
    },
    {
      "indent": 3,
      "text": "o The class ReusablePolicyContainer is defined. o PCIM's PolicyRepository class is deprecated. o The association ReusablePolicy is defined. o PCIM's PolicyConditionInPolicyRepository association is deprecated. o PCIM's PolicyActionInPolicyRepository association is deprecated. o The aggregation ContainedDomain is defined. o PCIM's PolicyRepositoryInPolicyRepository aggregation is deprecated.",
      "ja": "OクラスReusablePolicyContainerが定義されています。 O PCIMのPolicyRepositoryクラスは廃止されました。関連oをReusablePolicyが定義されています。 O PCIMのPolicyConditionInPolicyRepository協会が推奨されていません。 O PCIMのPolicyActionInPolicyRepository協会が推奨されていません。 O凝集ContainedDomainが定義されています。 O PCIMのPolicyRepositoryInPolicyRepository凝集は廃止されました。"
    },
    {
      "indent": 0,
      "text": "5.3. Policy Sets",
      "section_title": true,
      "ja": "5.3。ポリシーセット"
    },
    {
      "indent": 3,
      "text": "A \"policy\" can be thought of as a coherent set of rules to administer, manage, and control access to network resources (\"Policy Terminology\", reference [10]). The structuring of these coherent sets of rules into subsets is enhanced in this document. In Section 5.4, we discuss the new options for the nesting of policy rules.",
      "ja": "「ポリシー」はルールのコヒーレントセットは、管理、管理、およびネットワークリソースへのアクセスを制御すると考えることができる（「ポリシーの用語」、参考文献[10]）。サブセットにルールのこれらのコヒーレントセットの構造は、本文書に強化されています。 5.4節では、ポリシールールのネストのための新たな選択肢を議論します。"
    },
    {
      "indent": 3,
      "text": "A new abstract class, PolicySet, is introduced to provide an abstraction for a set of rules. It is derived from Policy, and it is inserted into the inheritance hierarchy above both PolicyGroup and PolicyRule. This reflects the additional structural flexibility and semantic capability of both subclasses.",
      "ja": "新しい抽象クラス、POLICYSETは、一連のルールのための抽象化を提供するために導入されます。これは、ポリシーから導出され、それはのPolicyGroupとPolicyRuleの双方上記継承階層に挿入されます。これは、両方のサブクラスの追加的な構造的柔軟性と意味の能力を反映しています。"
    },
    {
      "indent": 3,
      "text": "Two properties are defined in PolicySet: PolicyDecisionStrategy and PolicyRoles. The PolicyDecisionStrategy property is included in PolicySet to define the evaluation relationship among the rules in the policy set. See Section 5.5 for more information. The PolicyRoles property is included in PolicySet to characterize the resources to which the PolicySet applies. See Section 5.6 for more information.",
      "ja": "二つの性質はPOLICYSETに定義されていますPolicyDecisionStrategyとPolicyRolesを。 PolicyDecisionStrategyプロパティは、ポリシー・セット内のルールのうち、評価の関係を定義するPOLICYSETに含まれています。詳細については、セクション5.5を参照してください。 PolicyRolesプロパティはPOLICYSETが適用されるリソースを特徴づけるためにPOLICYSETに含まれています。詳細については、セクション5.6を参照してください。"
    },
    {
      "indent": 3,
      "text": "Along with the definition of the PolicySet class, a new concrete aggregation class is defined that will also be discussed in the following sections. PolicySetComponent is defined as a subclass of PolicyComponent; it provides the containment relationship for a PolicySet in a PolicySet. PolicySetComponent replaces the two PCIM aggregations PolicyGroupInPolicyGroup and PolicyRuleInPolicyGroup, so these two aggregations are deprecated.",
      "ja": "POLICYSETクラスの定義とともに、新しいコンクリート集約クラスは、以下のセクションで説明されるように定義されています。 PolicySetComponentはPolicyComponentのサブクラスとして定義されます。それはPOLICYSETでPOLICYSETための包含関係を提供します。 PolicySetComponentは2件のPCIM集計PolicyGroupInPolicyGroupとPolicyRuleInPolicyGroupを置き換えるので、これら二つの集計は推奨されません。"
    },
    {
      "indent": 3,
      "text": "A PolicySet's relationship to an AdminDomain or other administrative scoping system (for example, a ComputerSystem) is represented by the PolicySetInSystem abstract association. This new association is derived from PolicyInSystem, and the PolicyGroupInSystem and PolicyRuleInSystem associations are now derived from PolicySetInSystem instead of directly from PolicyInSystem. The PolicySetInSystem.Priority property is discussed in Section 5.5.3.",
      "ja": "いるAdminDomainまたは（例えば、のComputerSystem）その他の管理スコープシステムにPOLICYSETの関係はPolicySetInSystem抽象アソシエーションによって表されます。この新しい関連付けはPolicyInSystemに由来し、そしてPolicyGroupInSystemとPolicyRuleInSystem団体は現在、PolicySetInSystem代わりに、直接のPolicyInSystemから由来しています。 PolicySetInSystem.Priorityプロパティは、セクション5.5.3で説明されています。"
    },
    {
      "indent": 0,
      "text": "5.4. Nested Policy Rules",
      "section_title": true,
      "ja": "5.4。ネストされたポリシールール"
    },
    {
      "indent": 3,
      "text": "As previously discussed, policy is described by a set of policy rules that may be grouped into subsets. In this section we introduce the notion of nested rules, or the ability to define rules within rules. Nested rules are also called sub-rules, and we use both terms in this document interchangeably. The aggregation PolicySetComponent is used to represent the nesting of a policy rule in another policy rule.",
      "ja": "前述したように、ポリシーをサブセットにグループ化することができるポリシールールのセットによって記述されます。このセクションでは、ネストされたルールの概念、あるいはルール内のルールを定義する機能を紹介します。ネストされたルールは、サブルールと呼ばれ、我々は、交換可能に、本書では両方の用語を使用します。凝集PolicySetComponentは、別のポリシールールにポリシールールのネストを表すために使用されます。"
    },
    {
      "indent": 0,
      "text": "5.4.1. Usage Rules for Nested Rules",
      "section_title": true,
      "ja": "5.4.1。ネストされたルールの使用規則"
    },
    {
      "indent": 3,
      "text": "The relationship between rules and sub-rules is defined as follows:",
      "ja": "次のようにルールとサブルールとの間の関係が定義されています。"
    },
    {
      "indent": 3,
      "text": "o The parent rule's condition clause is a condition for evaluation of all nested rules; that is, the conditions of the parent are logically ANDed to the conditions of the sub-rules. If the parent rule's condition clause evaluates to FALSE, sub-rules MAY be skipped since they also evaluate to FALSE.",
      "ja": "O親ルールの条件句は、すべてのネストされたルールの評価のための条件です。つまり、親の条件は、論理的にサブルールの条件にAND演算されています。親ルールの条件節はFALSEと評価された場合、彼らはまた、FALSEと評価されているので、サブルールはスキップしてもよいです。"
    },
    {
      "indent": 3,
      "text": "o If the parent rule's condition evaluates to TRUE, the set of sub-rules SHALL BE evaluated according to the decision strategy and priorities as discussed in Section 5.5.",
      "ja": "親ルールの条件がTRUEと評価された場合、5.5節で述べたように、O、サブ規則のセットは、意思決定戦略と優先順位に従って評価しなければなりません。"
    },
    {
      "indent": 3,
      "text": "o If the parent rule's condition evaluates to TRUE, the parent rule's set of actions is executed BEFORE execution of the sub-rules actions. The parent rule's actions are not to be confused with default actions. A default action is one that is to be executed only if none of the more specific sub-rules are executed. If a default action needs to be specified, it needs to be defined as an action that is part of a catchall sub-rule associated with the parent rule. The association linking the default action(s) in this special sub-rule should have the lowest priority relative to all other sub-rule associations:",
      "ja": "親ルールの条件がTRUEと評価された場合、O、アクションの親ルールのセットは、サブルールのアクションの実行前に実行されます。親ルールのアクションは、デフォルトのアクションと混同してはなりません。デフォルトのアクションは、より特定のサブルールのいずれも実行されない場合にのみ実行されるべきものです。デフォルトのアクションを指定する必要がある場合、それは親ルールに関連付けられたキャッチオールサブ規則の一部であるアクションとして定義する必要があります。この特別なサブ規則のデフォルトアクション（複数可）を連結アソシエーションは、他のすべてのサブルールの関連付けに対して最低の優先度を有するべきです。"
    },
    {
      "indent": 8,
      "text": "if parent-condition then parent rule's action\n           if condA then actA\n           if condB then ActB\n           if True then default action",
      "raw": true
    },
    {
      "indent": 6,
      "text": "Such a default action functions as a default when FirstMatching decision strategies are in effect (see section 5.5). If AllMatching applies, the \"default\" action is always performed.",
      "ja": "FirstMatching決定戦略が有効になっているデフォルトのようなデフォルトのアクション機能（セクション5.5を参照してください）。 AllMatchingが適用される場合、「デフォルト」アクションが常に実行されます。"
    },
    {
      "indent": 3,
      "text": "o Policy rules have a context in which they are executed. The rule engine evaluates and applies the policy rules in the context of the managed resource(s) that are identified by the policy roles (or by an explicit association). Submodels MAY add additional context to policy rules based on rule structure; any such additional context is defined by the semantics of the action classes of the submodel.",
      "ja": "Oポリシールールは、それらが実行されるコンテキストを持っています。ルールエンジンは、ポリシーロールによって（または明示的な結合によって）識別される管理対象リソース（単数または複数）のコンテキスト内のポリシールールを評価し、適用します。サブモデルは、ルールの構造に基づいたポリシールールに追加のコンテキストを追加してもよい（MAY）。そのような追加のコンテキストは、サブモデルのアクションクラスのセマンティクスによって定義されます。"
    },
    {
      "indent": 0,
      "text": "5.4.2. Motivation",
      "section_title": true,
      "ja": "5.4.2。動機"
    },
    {
      "indent": 3,
      "text": "Rule nesting enhances Policy readability, expressiveness and reusability. The ability to nest policy rules and form sub-rules is important for manageability and scalability, as it enables complex policy rules to be constructed from multiple simpler policy rules.",
      "ja": "ルールのネストがポリシーの読みやすさ、表現力と再利用性を向上させます。それは複雑なポリシールールは、複数の単純なポリシールールから構成されることを可能にするように入れ子ポリシールール及びフォームサブルールする能力は、管理性と拡張性のために重要です。"
    },
    {
      "indent": 3,
      "text": "These enhancements ease the policy management tools' task, allowing policy rules to be expressed in a way closer to how humans think.",
      "ja": "これらの拡張機能は、ポリシールールが近い人間がどのように考えるかに方法で表現することができるように、ポリシー管理ツールのタスクを容易に。"
    },
    {
      "indent": 3,
      "text": "Although rule nesting can be used to suggest optimizations in the way policy rules are evaluated, as discussed in section 5.5.2 \"Side Effects,\" nesting does not specify nor does it require any particular order of evaluation of conditions. Optimization of rule evaluation can be done in the PDP or in the PEP by dedicated code. This is similar to the relation between a high level programming language like C and machine code. An optimizer can create a more efficient machine code than any optimization done by the programmer within the source code. Nevertheless, if the PEP or PDP does not do optimization, the administrator writing the policy may be able to influence the evaluation of the policy rules for execution using rule nesting.",
      "ja": "ルールネスティングが邪魔に最適化を提案するために使用することができますが、ポリシールールが評価されているセクション5.5.2で説明したように、「副作用、」ネスティングを指定しておらず、条件の評価の任意の特定の順序を必要としません。ルール評価の最適化は、専用コードによってPDP又はPEPで行うことができます。これは、Cのような高水準言語やマシンコードの間の関係と同様です。オプティマイザは、ソースコード内のプログラマによって行わ任意の最適化よりも効率的なマシンコードを作成することができます。 PEPやPDPは、最適化をしない場合はそれにもかかわらず、ポリシーを書いて、管理者は、ルールのネストを使用して実行するためのポリシールールの評価に影響を与えることができるかもしれません。"
    },
    {
      "indent": 3,
      "text": "Nested rules are not designed for policy repository retrieval optimization. It is assumed that all rules and groups that are assigned to a role are retrieved by the PDP or PEP from the policy repository and enforced. Optimizing the number of rules retrieved should be done by clever selection of roles.",
      "ja": "ネストされたルールは、ポリシーリポジトリの検索を最適化するために設計されていません。役割に割り当てられているすべてのルールとグループをポリシーリポジトリからPDP又はPEPによって取得および適用されているものとします。検索されたルールの数を最適化する役割の賢い選択によって行われるべきです。"
    },
    {
      "indent": 0,
      "text": "5.5. Priorities and Decision Strategies",
      "section_title": true,
      "ja": "5.5。優先順位と意思決定戦略"
    },
    {
      "indent": 3,
      "text": "A \"decision strategy\" is used to specify the evaluation method for the policies in a PolicySet. Two decision strategies are defined: \"FirstMatching\" and \"AllMatching.\" The FirstMatching strategy is used to cause the evaluation of the rules in a set such that the only actions enforced on a given examination of the PolicySet are those for the first rule (that is, the rule with the highest priority) that has its conditions evaluate to TRUE. The AllMatching strategy is used to cause the evaluation of all rules in a set; for all of the rules whose conditions evaluate to TRUE, the actions are enforced. Implementations MUST support the FirstMatching decision strategy; implementations MAY support the AllMatching decision strategy.",
      "ja": "「意思決定戦略は」POLICYSETにおける政策の評価方法を指定するために使用されます。 2つの決定戦略が定義されています。「FirstMatching」と「AllMatching。」 FirstMatching戦略はその条件を評価していること（つまり、最も優先度の高いルールです）POLICYSETの与えられた検査に施行アクションのみが、最初のルールのためのものであることが、このようなセットにルールの評価を引き起こすために使用されますTRUEに。 AllMatching戦略はセット内のすべてのルールの評価を引き起こすために使用されます。その条件はTRUEと評価されるすべてのルールのため、アクションが適用されます。実装はFirstMatching決定戦略をサポートしなければなりません。実装はAllMatching決定戦略をサポートするかもしれません。"
    },
    {
      "indent": 3,
      "text": "As previously discussed, the PolicySet subclasses are PolicyGroup and PolicyRule: either subclass may contain PolicySets of either subclass. Loops, including the degenerate case of a PolicySet that contains itself, are not allowed when PolicySets contain other PolicySets. The containment relationship is specified using the PolicySetComponent aggregation.",
      "ja": "前述したように、POLICYSETサブクラスはのPolicyGroupとPolicyRuleのである。いずれかのサブクラスのいずれかのサブクラスのPolicySetsを含んでいてもよいです。 PolicySetsが他のPolicySetsが含まれている場合、それ自体が含まれていPOLICYSETの退化場合を含むループは、許可されていません。包含関係はPolicySetComponent集約を使用して指定されています。"
    },
    {
      "indent": 3,
      "text": "The relative priority within a PolicySet is established by the Priority property of the PolicySetComponent aggregation of the contained PolicyGroup and PolicyRule instances. The use of PCIM's PolicyRule.Priority property is deprecated in favor of this new property. The separation of the priority property from the rule has two advantages. First, it generalizes the concept of priority, so that it can be used for both groups and rules. Second, it places the priority on the relationship between the parent policy set and the subordinate policy group or rule. The assignment of a priority value then becomes much easier, in that the value is used only in relationship to other priorities in the same set.",
      "ja": "POLICYSET内の相対的な優先順位が含まれたPolicyGroupとPolicyRuleのインスタンスのPolicySetComponent集約の優先性によって確立されます。 PCIMのPolicyRule.Priorityプロパティの使用は、この新しいプロパティの賛成で廃止されました。ルールの優先性の分離は、2つの利点を有します。それはグループとルールの両方に使用することができるようにまず、それは、優先順位の概念を一般化します。第二に、それは親のポリシーセットと従属ポリシー・グループまたはルールとの関係に重点を置きます。値は、同じセット内の他の優先順位の関係で使用される優先値の割り当ては、その後、はるかに容易になります。"
    },
    {
      "indent": 3,
      "text": "Together, the PolicySet.PolicyDecisionStrategy and PolicySetComponent.Priority determine the processing for the rules contained in a PolicySet. As before, the larger priority value represents the higher priority. Unlike the earlier definition, PolicySetComponent.Priority MUST have a unique value when compared with others defined for the same aggregating PolicySet. Thus, the evaluation of rules within a set is deterministically specified.",
      "ja": "一緒に、PolicySet.PolicyDecisionStrategyとPolicySetComponent.PriorityはPOLICYSETに含まれるルールの処理を決定します。前と同じように、より大きな優先度の値は、より高い優先度を表します。同じ凝集POLICYSETに対して定義された他のものと比較した場合、以前の定義とは異なり、PolicySetComponent.Priorityは、一意の値を持たなければなりません。このように、セット内のルールの評価は決定的に指定されています。"
    },
    {
      "indent": 3,
      "text": "For a FirstMatching decision strategy, the first rule (that is, the one with the highest priority) in the set that evaluates to True, is the only rule whose actions are enforced for a particular evaluation pass through the PolicySet.",
      "ja": "真と評価セットにおけるFirstMatching決定戦略、最初のルール（つまり、最も優先度の高いものである）ため、その行動特定の評価のために適用されPOLICYSET通過だけルールがあります。"
    },
    {
      "indent": 3,
      "text": "For an AllMatching decision strategy, all of the matching rules are enforced. The relative priority of the rules is used to determine the order in which the actions are to be executed by the enforcement point: the actions of the higher priority rules are executed first. Since the actions of higher priority rules are executed first, lower priority rules that also match may get the \"last word,\" and thus produce a counter-intuitive result. So, for example, if two rules both evaluate to True, and the higher priority rule sets the DSCP to 3 and the lower priority rule sets the DSCP to 4, the action of the lower priority rule will be executed later and, therefore, will \"win,\" in this example, setting the DSCP to 4. Thus, conflicts between rules are resolved by this execution order.",
      "ja": "AllMatching決定戦略のために、一致ルールのすべてが適用されます。優先度の高いルールのアクションが最初に実行されている：ルールの相対的な優先度は、アクションが実施ポイントによって実行される順序を決定するために使用されます。優先度の高いルールのアクションが最初に実行されているので、また、一致低い優先度のルールは、「最後の言葉」を取得し、従って反直感的な結果を生成することができます。したがって、例えば、したがって、2つのルールの両方がTRUEと評価され、優先度の高いルールがDSCPに3を設定し、低い優先度のルールがDSCPに4を設定し、低い優先順位のルールのアクションは、後で実行されるとすれば、意志このように4にDSCPを設定し、この例では「勝つ」、ルール間の競合は、この実行順序によって解決されます。"
    },
    {
      "indent": 3,
      "text": "An implementation of the rule engine need not provide the action sequencing but the actions MUST be sequenced by the PEP or PDP on its behalf. So, for example, the rule engine may provide an ordered list of actions to be executed by the PEP and any required serialization is then provided by the service configured by the rule engine. See Section 5.5.2 for a discussion of side effects.",
      "ja": "ルールエンジンの実装では、アクションシーケンシングを提供する必要はないが、アクションはその代理でPEPやPDPによって配列決定されなければなりません。従って、例えば、ルールエンジンはPEPによって実行されると、必要な直列化は、ルールエンジンによって構成されたサービスによって提供されるアクションの順序付きリストを提供することができます。副作用の議論については、5.5.2項を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.5.1. Structuring Decision Strategies",
      "section_title": true,
      "ja": "5.5.1。構造化決定の戦略"
    },
    {
      "indent": 3,
      "text": "As discussed in Sections 5.3 and 5.4, PolicySet instances may be nested arbitrarily. For a FirstMatching decision strategy on a PolicySet, any contained PolicySet that matches satisfies the termination criteria for the FirstMatching strategy. A PolicySet is considered to match if it is a PolicyRule and its conditions evaluate to True, or if the PolicySet is a PolicyGroup and at least one of its contained PolicyGroups or PolicyRules match. The priority associated with contained PolicySets, then, determines when to terminate rule evaluation in the structured set of rules.",
      "ja": "セクション5.3および5.4で説明したように、POLICYSETインスタンスを任意に入れ子にすることができます。 POLICYSET、満足するFirstMatching戦略の終了基準に合致する任意の含まPOLICYSETにFirstMatching決定戦略のため。 POLICYSETは、それがPolicyRuleのであり、その条件がTrueに評価場合、または一致すると考えられているPOLICYSETはのPolicyGroupとそれに含まれるPolicyGroupsまたはPolicyRulesの試合の少なくとも一方である場合。ルールの構造化されたセット内のルールの評価を終了するときに含まPolicySetsに関連付けられた優先順位は、次に、決定します。"
    },
    {
      "indent": 3,
      "text": "In the example shown in Figure 3, the relative priorities for the nested rules, high to low, are 1A, 1B1, 1X2, 1B3, 1C, 1C1, 1X2 and 1C3. (Note that PolicyRule 1X2 is included in both PolicyGroup 1B and PolicyRule 1C, but with different priorities.) Of course, which rules are enforced is also dependent on which rules, if any, match.",
      "ja": "図3に示す例では、低高のネストされたルールの相対的な優先順位は、図1A、1B1、1X2、1B3、1C、1C1、1X2および1C3です。 （しかし、異なる優先度を有する、PolicyRuleの1X2はのPolicyGroup 1Bおよび1C PolicyRuleの両方に含まれることに注意してください。）もちろん、ルールが適用されあれば、一致し、また規則これに依存しています。"
    },
    {
      "indent": 3,
      "text": "PolicyGroup 1: FirstMatching\n  |\n  +-- Pri=6 -- PolicyRule 1A\n  |\n  +-- Pri=5 -- PolicyGroup 1B: AllMatching\n  |              |\n  |              +-- Pri=5 -- PolicyGroup 1B1: AllMatching\n  |              |              |\n  |              |              +---- etc.\n  |              |\n  |              +-- Pri=4 -- PolicyRule 1X2\n  |              |\n  |              +-- Pri=3 -- PolicyRule 1B3: FirstMatching\n  |                             |\n  |                             +---- etc.\n  |\n  +-- Pri=4 -- PolicyRule 1C: FirstMatching\n                 |\n                 +-- Pri=4 -- PolicyRule 1C1\n                 |\n                 +-- Pri=3 -- PolicyRule 1X2\n                 |\n                 +-- Pri=2 -- PolicyRule 1C3",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Figure 3. Nested PolicySets with Different Decision Strategies",
      "ja": "さまざまな意思決定戦略図3.ネストされたPolicySets"
    },
    {
      "indent": 3,
      "text": "o Because PolicyGroup 1 has a FirstMatching decision strategy, if the conditions of PolicyRule 1A match, its actions are enforced and the evaluation stops.",
      "ja": "PolicyRuleの1Aの試合の条件は、そのアクションが施行されている場合のPolicyGroup 1は、FirstMatching決定戦略を持っていると評価が停止しているので、O。"
    },
    {
      "indent": 3,
      "text": "o If it does not match, PolicyGroup 1B is evaluated using an AllMatching strategy. Since PolicyGroup 1B1 also has an AllMatching strategy all of the rules and groups of rules contained in PolicyGroup 1B1 are evaluated and enforced as appropriate. PolicyRule 1X2 and PolicyRule 1B3 are also evaluated and enforced as appropriate. If any of the sub-rules in the subtrees of PolicyGroup 1B evaluate to True, then PolicyRule 1C is not evaluated because the FirstMatching strategy of PolicyGroup 1 has been satisfied.",
      "ja": "それが一致しない場合は、O、のPolicyGroup 1BはAllMatching戦略を用いて評価されます。 PolicyGroup 1B1もAllMatching戦略を有するためのPolicyGroup 1B1に含まれるルールのルールやグループの全てが評価され、必要に応じて適用されます。 PolicyRuleの1X2とのPolicyRule 1B3についても評価し、必要に応じて適用されます。 PolicyGroup 1Bのサブツリー内のサブルールのいずれかが真と評価された場合のPolicyGroup 1のFirstMatching戦略が満たされているので、その後のPolicyRule 1Cは評価されません。"
    },
    {
      "indent": 3,
      "text": "o If neither PolicyRule 1A nor PolicyGroup 1B yield a match, then PolicyRule 1C is evaluated. Since it is first matching, rules 1C1, 1X2, and 1C3 are evaluated until the first match, if any.",
      "ja": "どちらのポリシールールの1A NPR政策グループ1Bは一致が得られた場合は、O、その後のPolicyRule 1Cが評価されます。それは最初に一致しているので、1C1ルールがあれば、1X2、および1C3は、最初の一致までに評価されています。"
    },
    {
      "indent": 0,
      "text": "5.5.2. Side Effects",
      "section_title": true,
      "ja": "5.5.2。副作用"
    },
    {
      "indent": 3,
      "text": "Although evaluation of conditions is sometimes discussed as an ordered set of operations, the rule engine need not be implemented as a procedural language interpreter. Any side effects of condition evaluation or the execution of actions MUST NOT affect the result of the evaluation of other conditions evaluated by the rule engine in the same evaluation pass. That is, an implementation of a rule engine MAY evaluate all conditions in any order before applying the priority and determining which actions are to be executed.",
      "ja": "条件の評価は、時には操作の順序集合として説明されているが、ルールエンジンは、手続き型言語インタプリタとして実装される必要はありません。条件評価やアクションの実行のいずれかの副作用が同一の評価パスでルールエンジンによって評価、他の条件の評価の結果に影響してはいけません。つまり、ルールエンジンの実装では、優先順位を適用すると、アクションが実行されるかを決定する前に、任意の順序ですべての条件を評価することができます。"
    },
    {
      "indent": 3,
      "text": "So, regardless of how a rule engine is implemented, it MUST NOT include any side effects of condition evaluation in the evaluation of conditions for either of the decision strategies. For both the AllMatching decision strategy and for the nesting of rules within rules (either directly or indirectly) where the actions of more than one rule may be enforced, any side effects of the enforcement of actions MUST NOT be included in condition evaluation on the same evaluation pass.",
      "ja": "だから、関係なく、ルールエンジンがどのように実装されるかの、それは意思決定戦略のいずれかの条件の評価における条件評価のいずれかの副作用を含んではいけません。 AllMatching決定戦略の両方および複数のルールのアクションを実施することができるルール内のルールのネスト（直接または間接的に）するために、アクションの実施の副作用は同じで条件評価に含まれてはいけません評価パス。"
    },
    {
      "indent": 0,
      "text": "5.5.3. Multiple PolicySet Trees For a Resource",
      "section_title": true,
      "ja": "5.5.3。リソースに対して複数のPOLICYSET木"
    },
    {
      "indent": 3,
      "text": "As shown in the example in Figure 3., PolicySet trees are defined by the PolicySet subclass instances and the PolicySetComponent aggregation instances between them. Each PolicySet tree has a defined set of decision strategies and evaluation priorities. In section 5.6 we discuss some improvements in the use of PolicyRoles that cause the parent PolicySet.PolicyRoles to be applied to all contained PolicySet instances. However, a given resource may still have multiple, disjoint PolicySet trees regardless of how they are collected. These top-level PolicySet instances are called \"unrooted\" relative to the given resource.",
      "ja": "図3の例に示すように、POLICYSETツリーはPOLICYSETサブクラスのインスタンスとそれらの間のPolicySetComponent凝集インスタンスによって定義されます。各POLICYSETツリーは、意思決定の戦略や評価の優先順位の定義されたセットがあります。セクション5.6では、私たちは、親PolicySet.PolicyRolesがすべて含まれているPOLICYSETインスタンスに適用させることがPolicyRolesの使用におけるいくつかの改善を議論します。しかし、与えられたリソースはまだかかわらず、それらを収集する方法の複数の、ばらばらPOLICYSETの木を有することができます。これらのトップレベルのPOLICYSETインスタンスは、特定のリソースへの「無根」相対と呼ばれています。"
    },
    {
      "indent": 3,
      "text": "So, a PolicySet instance is defined to be rooted or unrooted in the context of a particular managed element; the relationship to the managed element is usually established by the policy roles of the PolicySet instance and of the managed element (see 5.6 \"Policy Roles\"). A PolicySet instance is unrooted in that context if and only if there is no PolicySetComponent association to a parent PolicySet that is also related to the same managed element. These",
      "ja": "だから、POLICYSETインスタンスは、特定の管理対象要素の文脈に根ざし又は無根することと定義されます。管理対象要素との関係は、通常はPOLICYSETインスタンスのと、管理対象要素の政策の役割（5.6「政策の役割」を参照）によって確立されます。 POLICYSETインスタンスがあれば、その文脈で無根であり、また、同一の管理要素に関連している親POLICYSETへのPolicySetComponentアソシエーションが存在しない場合にのみ。これら"
    },
    {
      "indent": 3,
      "text": "PolicySetComponent aggregations are traversed up the tree without regard to how a PolicySet instance came to be related with the ManagedElement. Figure 4. shows an example where instance A has role A, instance B has role B and so on. In this example, in the context of interface X, instances B, and C are unrooted and instances D, E, and F are all rooted. In the context of interface Y, instance A is unrooted and instances B, C, D, E and F are all rooted.",
      "ja": "PolicySetComponentの集計がPOLICYSETインスタンスが管理対象要素に関連するようになったかに関係なく、ツリーを横断しています。図4は、インスタンスAは、ロールAを有している例を示して、インスタンスBのようにロールB​​とを有しています。この例では、インターフェースXの文脈において、インスタンスB、及びCは無根であり、インスタンスD、E、及びFは、全て根ざしています。界面Yの文脈において、インスタンスAは無根であり、例B、C、D、E及びFは、全て根ざしています。"
    },
    {
      "indent": 3,
      "text": "      +---+            +-----------+   +-----------+\n      | A |            |   I/F X   |   |   I/F Y   |\n      +---+            | has roles |   | has roles |\n       / \\             |   B & C   |   |   A & B   |\n      /   \\            +-----------+   +-----------+\n   +---+ +---+\n   | B | | C |\n   +---+ +---+\n    / \\     \\\n   /   \\     \\\n+---+ +---+ +---+\n| D | | E | | F |\n+---+ +---+ +---+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Figure 4. Unrooted PolicySet Instances",
      "ja": "4.無根POLICYSETインスタンス図"
    },
    {
      "indent": 3,
      "text": "For those cases where there are multiple unrooted PolicySet instances that apply to the same managed resource (i.e., not in a common PolicySetComponent tree), the decision strategy among these disjoint PolicySet instances is the FirstMatching strategy. The priority used with this FirstMatching strategy is defined in the PolicySetInSystem association. The PolicySetInSystem subclass instances are present for all PolicySet instances (it is a required association) but the priority is only used as a default for unrooted PolicySet instances in a given ManagedElement context.",
      "ja": "（すなわち、一般的ではないPolicySetComponentツリー内の）同じ管理対象リソースに適用される複数無根POLICYSETインスタンスが存在するような場合のために、これらの互いに素POLICYSETインスタンス間で決定戦略はFirstMatching戦略です。このFirstMatching戦略使用優先順位がPolicySetInSystem関連で定義されています。 PolicySetInSystemサブクラスのインスタンスはすべてPOLICYSETインスタンスのために存在している（それが必要な関連である）が、優先度のみ与えられた管理対象要素のコンテキストで無根POLICYSETインスタンスのデフォルトとして使用されます。"
    },
    {
      "indent": 3,
      "text": "The FirstMatching strategy is used among all unrooted PolicySet instances that apply to a given resource for a given functional domain. So, for example, the PolicySet instances that are used for QoS policy and the instances that are used for IKE policy, although they are disjoint, are not joined in a FirstMatching decision strategy. Instead, they are evaluated independently of one another.",
      "ja": "FirstMatching戦略は、与えられた機能ドメインのために与えられたリソースに適用されるすべての無根POLICYSETインスタンス間で使用されています。したがって、たとえば、QoSポリシーのために使用されているPOLICYSETインスタンスと、彼らはばらばらですが、IKEポリシーのために使用されているインスタンスは、FirstMatching決定戦略に参加していません。代わりに、彼らは互いに独立して評価されます。"
    },
    {
      "indent": 0,
      "text": "5.5.4. Deterministic Decisions",
      "section_title": true,
      "ja": "5.5.4。決定論的決定"
    },
    {
      "indent": 3,
      "text": "As previously discussed, PolicySetComponent.Priority values MUST be unique within a containing PolicySet and PolicySetInSystem.Priority values MUST be unique for an associated System. Each PolicySet, then, has a deterministic behavior based upon the decision strategy and uniquely defined priority.",
      "ja": "前述したように、PolicySetComponent.Priority値は、関連するシステムのためにユニークでなければなりません含むPOLICYSETとPolicySetInSystem.Priority値内で一意でなければなりません。各POLICYSETは、その後、意思決定の戦略と独自に定義された優先順位に基づいて決定論的な振る舞いを持っています。"
    },
    {
      "indent": 3,
      "text": "There are certainly cases where rules need not have a unique priority value (i.e., where evaluation and execution priority is not important). However, it is believed that the flexibility gained by this capability is not sufficiently beneficial to justify the possible variations in implementation behavior and the resulting confusion that might occur.",
      "ja": "ルールは、一意のプライオリティ値を持つ必要がない場合には（すなわち、評価および実行優先順位が重要でない場合）確かにあります。しかし、この機能によって得られる柔軟性は、実装の挙動と発生する可能性のある結果の混乱の中で可能なバリエーションを正当化するために十分に有益ではないと考えられています。"
    },
    {
      "indent": 0,
      "text": "5.6. Policy Roles",
      "section_title": true,
      "ja": "5.6。政策の役割"
    },
    {
      "indent": 3,
      "text": "A policy role is defined in [10] as \"an administratively specified characteristic of a managed element (for example, an interface). It is a selector for policy rules and PRovisioning Classes (PRCs), to determine the applicability of the rule/PRC to a particular managed element.\"",
      "ja": "ポリシーの役割は、ルール/ PRCの適用性を決定するために、ITポリシールールのセレクタである。（例えば、インタフェース）管理対象要素の管理指定特性」と[10]で定義されたクラス（位相応答曲線）をプロビジョニングされます特定の管理対象要素に。」"
    },
    {
      "indent": 3,
      "text": "In PCIMe, PolicyRoles is defined as a property of PolicySet, which is inherited by both PolicyRules and PolicyGroups. In this document, we also add PolicyRole as the identifying name of a collection of resources (PolicyRoleCollection), where each element in the collection has the specified role characteristic.",
      "ja": "PCIMeにおいて、PolicyRolesはPolicyRulesとPolicyGroups両方によって継承されPOLICYSETのプロパティとして定義されます。この文書では、我々はまた、コレクション内の各要素が指定したロール特性を持っているリソースの集合（PolicyRoleCollection）、の識別名としてPolicyRoleを追加します。"
    },
    {
      "indent": 0,
      "text": "5.6.1. Comparison of Roles in PCIM with Roles in snmpconf",
      "section_title": true,
      "ja": "5.6.1。 SNMPCONFにおける役割とPCIMにおける役割の比較"
    },
    {
      "indent": 3,
      "text": "In the Configuration Management with SNMP (snmpconf) working group's Policy Based Management MIB [14], policy rules are of the form",
      "ja": "SNMPと構成管理（SNMPCONF）ワーキンググループのポリシーベースの管理MIB [14]では、ポリシールールの形式は"
    },
    {
      "indent": 6,
      "text": "if <policyFilter> then <policyAction>",
      "ja": "もし<policyFilter>そして<policyAction>"
    },
    {
      "indent": 3,
      "text": "where <policyFilter> is a set of conditions that are used to determine whether or not the policy applies to an object instance. The policy filter can perform comparison operations on SNMP variables already defined in MIBS (e.g., \"ifType == ethernet\").",
      "ja": "ここで、<policyFilter>ポリシーは、オブジェクト・インスタンスに適用されるか否かを決定するために使用される条件のセットです。ポリシー・フィルタは、既に（例えば、「のifType ==イーサネット」）MIBで定義されたSNMP変数に比較演算を行うことができます。"
    },
    {
      "indent": 3,
      "text": "The policy management MIB defined in [14] defines a Role table that enables one to associate Roles with elements, where roles have the same semantics as in PCIM. Then, since the policyFilter in a policy allows one to define conditions based on the comparison of the values of SNMP variables, one can filter elements based on their roles as defined in the Role group.",
      "ja": "MIBは、[14]で定義されたポリシー管理は、1つのロールがPCIMと同じ意味を持つ要素とロールを関連付けることができロールテーブルを定義します。ポリシーでpolicyFilter一つは、SNMP変数の値の比較に基づいて条件を定義することを可能にするための役割グループで定義され、その後、一方がその役割に基づいて要素をフィルタリングすることができます。"
    },
    {
      "indent": 3,
      "text": "This approach differs from that adopted in PCIM in the following ways. First, in PCIM, a set of role(s) is associated with a policy rule as the values of the PolicyRoles property of a policy rule. The semantics of role(s) are then expected to be implemented by the PDP (i.e., policies are applied to the elements with the appropriate roles). In [14], however, no special processing is required for",
      "ja": "このアプローチは、次の方法でPCIMで採用とは異なります。まず、PCIMに、役割（複数可）のセットは、ポリシールールのPolicyRolesプロパティの値としてポリシールールに関連付けられています。役割（複数可）の意味論は、その後、PDP（すなわち、ポリシーが適切な役割を有する要素に適用されている）によって実装されることが期待されます。 [14]しかし、特別な処理は必要ありません"
    },
    {
      "indent": 3,
      "text": "realizing the semantics of roles; roles are treated just as any other SNMP variables and comparisons of role values can be included in the policy filter of a policy rule.",
      "ja": "役割のセマンティクスを実現。役割は、他のSNMP変数と役割値の比較がポリシールールのポリシーフィルタに含めることができますとして扱われます。"
    },
    {
      "indent": 3,
      "text": "Secondly, in PCIM, there is no formally defined way of associating a role with an object instance, whereas in [14] this is done via the use of the Role tables (pmRoleESTable and pmRoleSETable). The Role tables associate Role values with elements.",
      "ja": "[14]で、これはロールテーブル（pmRoleESTableとpmRoleSETable）の使用を介して行われるのに対し、第二に、PCIMに、オブジェクトインスタンスと役割を関連付ける正式に定義された方法は、全く存在しません。ロールテーブルは要素と役割値を関連付けます。"
    },
    {
      "indent": 0,
      "text": "5.6.2. Addition of PolicyRoleCollection to PCIMe",
      "section_title": true,
      "ja": "5.6.2。 PCIMeへPolicyRoleCollectionの追加"
    },
    {
      "indent": 3,
      "text": "In order to remedy the latter shortcoming in PCIM (the lack of a way of associating a role with an object instance), PCIMe has a new class PolicyRoleCollection derived from the CIM Collection class. Resources that share a common role are aggregated by a PolicyRoleCollection instance, via the ElementInPolicyRoleCollection aggregation. The role is specified in the PolicyRole property of the aggregating PolicyRoleCollection instance.",
      "ja": "PCIM後者欠点（オブジェクトインスタンスと役割を関連付ける方法の欠如）を改善するために、PCIMeは、CIMコレクションクラスから派生した新しいクラスPolicyRoleCollectionを有しています。一般的な役割を共有するリソースはElementInPolicyRoleCollection凝集を介して、PolicyRoleCollectionインスタンスによって集約されます。役割が集約PolicyRoleCollectionインスタンスのPolicyRoleプロパティで指定されています。"
    },
    {
      "indent": 3,
      "text": "A PolicyRoleCollection always exists in the context of a system. As was done in PCIM for PolicyRules and PolicyGroups, an association, PolicyRoleCollectionInSystem, captures this relationship. Remember that in CIM, System is a base class for describing network devices and administrative domains.",
      "ja": "PolicyRoleCollectionは、常にシステムのコンテキストに存在します。 PolicyRulesとPolicyGroups、協会、PolicyRoleCollectionInSystemためPCIMで行ったように、この関係をキャプチャします。 CIMには、システムは、ネットワーク機器や管理ドメインを記述するための基底クラスであることを覚えておいてください。"
    },
    {
      "indent": 3,
      "text": "The association between a PolicyRoleCollection and a system should be consistent with the associations that scope the policy rules/groups that are applied to the resources in that collection. Specifically, a PolicyRoleCollection should be associated with the same System as the applicable PolicyRules and/or PolicyGroups, or to a System higher in the tree formed by the SystemComponent association. When a PEP belongs to multiple Systems (i.e., AdminDomains), and scoping by a single domain is impractical, two alternatives exist. One is to arbitrarily limit domain membership to one System/AdminDomain. The other option is to define a more global AdminDomain that simply includes the others, and/or that spans the business or enterprise.",
      "ja": "PolicyRoleCollectionとシステムとの間の関連付けは、そのコレクション内のリソースに適用されるスコープポリシールール/グループそのアソシエーションと一致しなければなりません。具体的には、PolicyRoleCollection、またはSystemComponent会合によって形成されたツリー内の上位システムに適用PolicyRules及び/又はPolicyGroupsと同じシステムに関連付けされるべきです。 PEPは、複数のシステム（すなわち、AdminDomains）に属し、単一ドメインによるスコープは非現実的である場合、2つの選択肢が存在します。一つは、任意に1つのシステム/いるAdminDomainにドメインのメンバシップを制限することです。他のオプションは、単に他の人を含む、よりグローバルいるAdminDomainを定義することである、および/またはそれがビジネスや企業にまたがります。"
    },
    {
      "indent": 3,
      "text": "As an example, suppose that there are 20 traffic trunks in a network, and that an administrator would like to assign three of them to provide \"gold\" service. Also, the administrator has defined several policy rules which specify how the \"gold\" service is delivered. For these rules, the PolicyRoles property (inherited from PolicySet) is set to \"Gold Service\".",
      "ja": "例として、ネットワーク内の20個のトラフィックトランクがあることを想定し、管理者が「金」のサービスを提供するために、それらの3を割り当てたいということ。また、管理者は、「金」のサービスが配信される方法を指定する複数のポリシールールを定義しています。これらの規則については、（POLICYSETから継承）PolicyRolesプロパティは、「ゴールド・サービス」に設定されています。"
    },
    {
      "indent": 3,
      "text": "In order to associate three traffic trunks with \"gold\" service, an instance of the PolicyRoleCollection class is created and its PolicyRole property is also set to \"Gold Service\". Following this, the administrator associates three traffic trunks with the new instance of PolicyRoleCollection via the ElementInPolicyRoleCollection aggregation. This enables a PDP to determine that the \"Gold Service\" policy rules apply to the three aggregated traffic trunks.",
      "ja": "「ゴールド」のサービスを3つのトラフィックトランクを関連付けるために、PolicyRoleCollectionクラスのインスタンスが作成され、そのPolicyRoleプロパティは、また、「ゴールド・サービス」に設定されています。これに続いて、管理者はElementInPolicyRoleCollection集約を経てPolicyRoleCollectionの新しいインスタンスを持つ3つのトラフィックトランクを関連付けます。これは、「ゴールド・サービス」の政策ルールは3つの集約トラフィックのトランクに適用することを決定するためにPDPを可能にします。"
    },
    {
      "indent": 3,
      "text": "Note that roles are used to optimize policy retrieval. It is not mandatory to implement roles or, if they have been implemented, to group elements in a PolicyRoleCollection. However, if roles are used, then either the collection approach should be implemented, or elements should be capable of reporting their \"pre-programmed\" roles (as is done in COPS).",
      "ja": "ロールは、ポリシーの取得を最適化するために使用されることに留意されたいです。彼らがPolicyRoleCollectionのグループ要素に、実装されている場合は、役割を実装することは必須ではありませんか。ロールが使用される場合は、その後、いずれかの収集手法が実装されるべき、または要素は、（COPSで行われるように）その「予めプログラム」の役割を報告することができなければなりません。"
    },
    {
      "indent": 0,
      "text": "5.6.3. Roles for PolicyGroups",
      "section_title": true,
      "ja": "5.6.3。 PolicyGroupsのための役割"
    },
    {
      "indent": 3,
      "text": "In PCIM, role(s) are only associated with policy rules. However, it may be desirable to associate role(s) with groups of policy rules. For example, a network administrator may want to define a group of rules that apply only to Ethernet interfaces. A policy group can be defined with a role-combination=\"Ethernet\", and all the relevant policy rules can be placed in this policy group. (Note that in PCIMe, role(s) are made available to PolicyGroups as well as to PolicyRules by moving PCIM's PolicyRoles property up from PolicyRule to the new abstract class PolicySet. The property is then inherited by both PolicyGroup and PolicyRule.) Then every policy rule in this policy group implicitly inherits this role-combination from the containing policy group. A similar implicit inheritance applies to nested policy groups.",
      "ja": "PCIMでは、役割（複数可）のみ、ポリシールールに関連付けられています。しかし、ポリシールールのグループと役割（複数可）を関連付けることが望ましいかもしれません。例えば、ネットワーク管理者は、イーサネットインターフェイスにのみ適用されるルールのグループを定義することができます。ポリシーグループは、役割組み合わせ=「イーサネット」と定義することができ、関連するすべてのポリシー・ルールは、このポリシー・グループに配置することができます。 （PCIMeで、役割（複数可）、新たな抽象クラスPOLICYSETへのPolicyRuleからPCIMのPolicyRolesプロパティを移動することでPolicyGroupsにだけでなく、PolicyRulesに利用できるようになります。プロパティは、その後のPolicyGroupとPolicyRuleの両方によって継承されることに注意してください。）そして、すべてのポリシーこのポリシーグループのルールが暗黙のうちに含むポリシー・グループから、この役割の組み合わせを継承します。同様の暗黙の継承は、ネストされたポリシーグループに適用されます。"
    },
    {
      "indent": 3,
      "text": "There is no explicit copying of role(s) from container to contained entity. Obviously, this implicit inheritance of role(s) leads to the possibility of defining inconsistent role(s) (as explained in the example below); the handling of such inconsistencies is beyond the scope of PCIMe.",
      "ja": "含まれるエンティティへのコンテナからの役割（複数可）の明示的なコピーはありません。明らかに、ロール（単数または複数）のこの暗黙の継承は（以下の例で説明したように）一貫性のない役割（複数可）を定義する可能性をもたらします。そのような矛盾の取り扱いはPCIMeの範囲を超えています。"
    },
    {
      "indent": 3,
      "text": "As an example, suppose that there is a PolicyGroup PG1 that contains three PolicyRules, PR1, PR2, and PR3. Assume that PG1 has the roles \"Ethernet\" and \"Fast\". Also, assume that the contained policy rules have the role(s) shown below:",
      "ja": "例として、3 PolicyRules、PR1、PR2、PR3とが含まれていたPolicyGroupのPG1があるとします。 PG1は役割「イーサネット」および「高速」を持っていることを前提としています。また、含まれるポリシールールは、以下に示す役割（複数可）を有すると仮定する。"
    },
    {
      "indent": 3,
      "text": "+------------------------------+\n| PolicyGroup PG1              |\n| PolicyRoles = Ethernet, Fast |\n+------------------------------+\n           |\n           |        +------------------------+\n           |        | PolicyRule PR1         |\n           |--------| PolicyRoles = Ethernet |\n           |        +------------------------+\n           |\n           |        +--------------------------+\n           |        | PolicyRule PR2           |\n           |--------| PolicyRoles = <undefined>|\n           |        +--------------------------+\n           |\n           |        +------------------------+\n           |        | PolicyRule PR3         |\n           |--------| PolicyRoles = Slow     |\n                    +------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Figure 5. Inheritance of Roles",
      "ja": "役割の図5.継承"
    },
    {
      "indent": 3,
      "text": "In this example, the PolicyRoles property value for PR1 is consistent with the value in PG1, and in fact, did not need to be redefined. The value of PolicyRoles for PR2 is undefined. Its roles are implicitly inherited from PG1. Lastly, the value of PolicyRoles for PR3 is \"Slow\". This appears to be in conflict with the role, \"Fast,\" defined in PG1. However, whether these roles are actually in conflict is not clear. In one scenario, the policy administrator may have wanted only \"Fast\"- \"Ethernet\" rules in the policy group. In another scenario, the administrator may be indicating that PR3 applies to all \"Ethernet\" interfaces regardless of whether they are \"Fast\" or \"Slow.\" Only in the former scenario (only \"Fast\"- \"Ethernet\" rules in the policy group) is there a role conflict.",
      "ja": "この例では、PR1のためPolicyRolesプロパティ値はPG1の値と一致している、そして実際には、再定義する必要はありませんでした。 PR2のためPolicyRolesの値は未定義です。その役割は、暗黙のうちPG1から継承されます。最後に、PR3のためPolicyRolesの値が「遅い」です。これはPG1で定義された役割、「速い」と競合していると思われます。しかし、これらの役割は、紛争に実際にあるかどうかは明らかではありません。ポリシーグループに「イーサネット」のルール -  1つのシナリオでは、ポリシー管理者は、唯一の「高速」を望んでいた可能性があります。別のシナリオでは、管理者は、PR3にかかわらず、彼らが「高速」またはであるかどうかのすべての「イーサネット」インタフェースに適用されることを示すことができる「遅いです」。前者のみのシナリオ（唯一の「高速」 - ポリシーグループの「イーサネット」ルール）にロールの競合があります。"
    },
    {
      "indent": 3,
      "text": "Note that it is possible to override implicitly inherited roles via appropriate conditions on a PolicyRule. For example, suppose that PR3 above had defined the following conditions:",
      "ja": "PolicyRuleのに適切な条件を経由して、暗黙的に継承された役割を上書きすることが可能であることに注意してください。例えば、PR3は、上記以下の条件を定義していたとします。"
    },
    {
      "indent": 6,
      "text": "(interface is not \"Fast\") and (interface is \"Slow\")",
      "ja": "（インタフェースは、「スロー」である）（インターフェースは「高速」ではありません）と"
    },
    {
      "indent": 3,
      "text": "This results in unambiguous semantics for PR3.",
      "ja": "これは、PR3のための明確なセマンティクスになります。"
    },
    {
      "indent": 0,
      "text": "5.7. Compound Policy Conditions and Compound Policy Actions",
      "section_title": true,
      "ja": "5.7。複合ポリシー条件及び化合物ポリシーアクション"
    },
    {
      "indent": 3,
      "text": "Compound policy conditions and compound policy actions are introduced to provide additional reusable \"chunks\" of policy.",
      "ja": "複合ポリシーの条件および化合物のポリシーアクションは、ポリシーの追加、再利用可能な「チャンク」を提供するために導入されています。"
    },
    {
      "indent": 0,
      "text": "5.7.1. Compound Policy Conditions",
      "section_title": true,
      "ja": "5.7.1。化合物のポリシー条件"
    },
    {
      "indent": 3,
      "text": "A CompoundPolicyCondition is a PolicyCondition representing a Boolean combination of simpler conditions. The conditions being combined may be SimplePolicyConditions (discussed below in Section 6.4), but the utility of reusable combinations of policy conditions is not necessarily limited to the case where the component conditions are simple ones.",
      "ja": "CompoundPolicyConditionは、単純な条件のブール組み合わせを表すPolicyConditionです。組み合わされる条件はSimplePolicyConditions（セクション6.4で後述する）であってもよいが、ポリシー条件の再利用可能な組み合わせの有用性は、必ずしもコンポーネント条件が簡単なものである場合に限定されるものではありません。"
    },
    {
      "indent": 3,
      "text": "The PCIM extensions to introduce compound policy conditions are relatively straightforward. Since the purpose of the extension is to apply the DNF / CNF logic from PCIM's PolicyConditionInPolicyRule aggregation to a compound condition that aggregates simpler conditions, the following changes are required:",
      "ja": "化合物のポリシー条件を導入するPCIMの拡張は比較的簡単です。拡張の目的は、単純な条件を集約複合条件にPCIMのPolicyConditionInPolicyRule凝集からDNF / CNF論理を適用することであるので、以下の変更が必要です。"
    },
    {
      "indent": 3,
      "text": "o Create a new aggregation PolicyConditionInPolicyCondition, with the same GroupNumber and ConditionNegated properties as PolicyConditionInPolicyRule. The cleanest way to do this is to move the properties up to a new abstract aggregation superclass PolicyConditionStructure, from which the existing aggregation PolicyConditionInPolicyRule and a new aggregation PolicyConditionInPolicyCondition are derived. For now there is no need to re-document the properties themselves, since they are already documented in PCIM as part of the definition of the PolicyConditionInPolicyRule aggregation.",
      "ja": "O PolicyConditionInPolicyRuleと同じGroupNumberとConditionNegated特性を持つ、新しい集約PolicyConditionInPolicyConditionを作成します。これを行うにはクリーンな方法は、既存の集約PolicyConditionInPolicyRuleと新しい集約PolicyConditionInPolicyConditionが由来する新しい抽象集約スーパーPolicyConditionStructure、最大の特性を移動することです。今のところ、彼らはすでにPolicyConditionInPolicyRule集約の定義の一部としてPCIMに記載されているので、プロパティ自体を再文書する必要はありません。"
    },
    {
      "indent": 3,
      "text": "o It is also necessary to define a concrete subclass CompoundPolicyCondition of PolicyCondition, to introduce the ConditionListType property. This property has the same function, and works in exactly the same way, as the corresponding property currently defined in PCIM for the PolicyRule class.",
      "ja": "O ConditionListTypeプロパティを導入し、PolicyConditionの具象サブクラスCompoundPolicyConditionを定義することも必要です。このプロパティは、同様の機能を有し、かつ対応するプロパティが現在PolicyRuleのクラスのPCIMで定義されているように、まったく同じように動作します。"
    },
    {
      "indent": 3,
      "text": "The class and property definitions for representing compound policy conditions are below, in Section 6.",
      "ja": "化合物ポリシー条件を表すクラスおよびプロパティの定義は、第6節では、以下です。"
    },
    {
      "indent": 0,
      "text": "5.7.2. Compound Policy Actions",
      "section_title": true,
      "ja": "5.7.2。化合物のポリシーアクション"
    },
    {
      "indent": 3,
      "text": "A compound action is a convenient construct to represent a sequence of actions to be applied as a single atomic action within a policy rule. In many cases, actions are related to each other and should be looked upon as sub-actions of one \"logical\" action. An example of such a logical action is \"shape & mark\" (i.e., shape a certain stream to a set of predefined bandwidth characteristics and then mark these packets with a certain DSCP value). This logical action is actually composed of two different QoS actions, which should be performed in a well-defined order and as a complete set.",
      "ja": "化合物の作用は、ポリシールール内の単一のアトミック動作として適用されるアクションのシーケンスを表現するための便利な構築物です。多くの場合、アクションは、互いに関連しており、一つの「論理的な」行動のサブアクションとして時に見なければなりません。そのような論理的動作の一例は、「形状＆マーク」である（すなわち、予め定義された帯域幅特性のセットに特定のストリームを形成し、次に特定のDSCP値を持つこれらのパケットにマークを付けます）。この論理的なアクションは、実際には、明確に定義された順序で、完全なセットとして実行されなければならない二つの異なるQoSアクション、で構成されています。"
    },
    {
      "indent": 3,
      "text": "The CompoundPolicyAction construct allows one to create a logical relationship between a number of actions, and to define the activation logic associated with this logical action.",
      "ja": "CompoundPolicyAction構築物は、1つのアクションの数との間の論理的な関係を作成し、この論理的アクションに関連付けられているアクティベーション・ロジックを定義することを可能にします。"
    },
    {
      "indent": 3,
      "text": "The CompoundPolicyAction construct allows the reusability of these complex actions, by storing them in a ReusablePolicyContainer and reusing them in different policy rules. Note that a compound action may also be aggregated by another compound action.",
      "ja": "CompoundPolicyAction構築物はReusablePolicyContainerに格納し、別のポリシールールでそれらを再利用することにより、これらの複雑なアクションの再利用を可能にします。化合物の作用はまた、他の化合物の作用によって凝集されてもよいことに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "As was the case with CompoundPolicyCondition, the PCIM extensions to introduce compound policy actions are relatively straightforward. This time the goal is to apply the property ActionOrder from PCIM's PolicyActionInPolicyRule aggregation to a compound action that aggregates simpler actions. The following changes are required:",
      "ja": "CompoundPolicyConditionの場合と同様に、化合物のポリシーアクションを導入するPCIMの拡張は比較的簡単です。今回の目標は、シンプルなアクションを集約する複合活動にPCIMのPolicyActionInPolicyRule集約からプロパティActionOrderを適用することです。以下の変更が必要とされています。"
    },
    {
      "indent": 3,
      "text": "o Create a new aggregation PolicyActionInPolicyAction, with the same ActionOrder property as PolicyActionInPolicyRule. The cleanest way to do this is to move the property up to a new abstract aggregation superclass PolicyActionStructure, from which the existing aggregation PolicyActionInPolicyRule and a new aggregation PolicyActionInPolicyAction are derived.",
      "ja": "O PolicyActionInPolicyRuleと同じActionOrderプロパティで、新しい集約PolicyActionInPolicyActionを作成します。これを行うにはクリーンな方法は、既存の集約PolicyActionInPolicyRuleと新しい集約PolicyActionInPolicyActionが由来する新しい抽象集約スーパーPolicyActionStructureにプロパティを上に移動することです。"
    },
    {
      "indent": 3,
      "text": "o It is also necessary to define a concrete subclass CompoundPolicyAction of PolicyAction, to introduce the SequencedActions property. This property has the same function, and works in exactly the same way, as the corresponding property currently defined in PCIM for the PolicyRule class.",
      "ja": "O SequencedActionsプロパティを導入し、PolicyActionの具象サブクラスCompoundPolicyActionを定義することも必要です。このプロパティは、同様の機能を有し、かつ対応するプロパティが現在PolicyRuleのクラスのPCIMで定義されているように、まったく同じように動作します。"
    },
    {
      "indent": 3,
      "text": "o Finally, a new property ExecutionStrategy is needed for both the PCIM class PolicyRule and the new class CompoundPolicyAction. This property allows the policy administrator to specify how the PEP should behave in the case where there are multiple actions aggregated by a PolicyRule or by a CompoundPolicyAction.",
      "ja": "O最後に、新しいプロパティExecutionStrategyはPCIMのクラスのPolicyRuleと新しいクラスCompoundPolicyActionの両方のために必要とされています。このプロパティは、PEPがPolicyRuleのまたはCompoundPolicyActionによって集約複数のアクションがある場合にはどのように振る舞うべきかを指定するポリシー管理者にすることができます。"
    },
    {
      "indent": 3,
      "text": "The class and property definitions for representing compound policy actions are below, in Section 6.",
      "ja": "化合物のポリシーアクションを表現するためのクラスとプロパティの定義は、第6節では、以下の通りです。"
    },
    {
      "indent": 0,
      "text": "5.8. Variables and Values",
      "section_title": true,
      "ja": "5.8。変数と値"
    },
    {
      "indent": 3,
      "text": "The following subsections introduce several related concepts, including PolicyVariables and PolicyValues (and their numerous subclasses), SimplePolicyConditions, and SimplePolicyActions.",
      "ja": "以下のサブセクションでは、SimplePolicyConditions、およびSimplePolicyActions PolicyVariablesとPolicyValues（およびその多数のサブクラス）を含むいくつかの関連する概念を導入します。"
    },
    {
      "indent": 0,
      "text": "5.8.1. Simple Policy Conditions",
      "section_title": true,
      "ja": "5.8.1。シンプルなポリシー条件"
    },
    {
      "indent": 3,
      "text": "The SimplePolicyCondition class models elementary Boolean expressions of the form: \"(<variable> MATCH <value>)\". The relationship 'MATCH', which is implicit in the model, is interpreted based on the variable and the value. Section 5.8.3 explains the semantics of the 'MATCH' operator. Arbitrarily complex Boolean expressions can be formed by chaining together any number of simple conditions using relational operators. Individual simple conditions can be negated as well. Arbitrarily complex Boolean expressions are modeled by the class CompoundPolicyCondition (described in Section 5.7.1).",
      "ja": "SimplePolicyConditionクラスモデルフォームの基本ブール式：「（<変数> MATCH <値>）」。モデルに内在する関係「MATCH」は、変数および値に基づいて解釈されます。セクション5.8.3は、「MATCH」演算子の意味を説明しています。任意の複雑なブール式は関係演算子を使用した簡単な条件の任意の数を一緒に連鎖することにより形成することができます。個々の単純な条件は、同様に否定することができます。任意の複雑なブール式は、（5.7.1項で説明）クラスCompoundPolicyConditionによってモデル化されています。"
    },
    {
      "indent": 3,
      "text": "For example, the expression \"SourcePort == 80\" can be modeled by a simple condition. In this example, 'SourcePort' is a variable, '==' is the relational operator denoting the equality relationship (which is generalized by PCIMe to a \"MATCH\" relationship), and '80' is an integer value. The complete interpretation of a simple condition depends on the binding of the variable. Section 5.8.5 describes variables and their binding rules.",
      "ja": "例えば、表現「SourcePort == 80」は、単純な条件によってモデル化することができます。この例では、「SourcePort」は可変であり、「==」（「一致」の関係にPCIMeによって一般化される）等価関係を表す関係演算子であり、「80」の整数値です。簡単な条件の完全な解釈は、変数のバインディングに依存します。セクション5.8.5は、変数とその結合ルールを説明しています。"
    },
    {
      "indent": 3,
      "text": "The SimplePolicyCondition class refines the basic structure of the PolicyCondition class defined in PCIM by using the pair (<variable>, <value>) to form the condition. Note that the operator between the variable and the value is always implied in PCIMe: it is not a part of the formal notation.",
      "ja": "SimplePolicyConditionクラスは、状態を形成する対（<変数>、<値>）を使用してPCIMで定義されたPolicyConditionのクラスの基本構造を洗練します。変数と値の間、オペレータは、常にPCIMeに暗示されていることに注意してください：それは正式な表記法の一部ではありません。"
    },
    {
      "indent": 3,
      "text": "The variable specifies the attribute of an object that should be matched when evaluating the condition. For example, for a QoS model, this object could represent the flow that is being conditioned. A set of predefined variables that cover network attributes commonly used for filtering is introduced in PCIMe, to encourage interoperability. This list covers layer 3 IP attributes such as IP network addresses, protocols and ports, as well as a set of layer 2 attributes (e.g., MAC addresses).",
      "ja": "変数は、条件を評価するときに一致するオブジェクトの属性を指定します。例えば、QoSモデルのために、このオブジェクトは、調整されているフローを表すことができます。一般的に、フィルタリングのために使用されるネットワーク属性をカバーする事前に定義された変数のセットは、相互運用性を奨励するために、PCIMeで導入されます。このリストは、IPは、IPネットワークアドレス、プロトコル、およびポート、ならびに層2つの属性（例えば、MACアドレス）のセットなどの属性層3を覆っています。"
    },
    {
      "indent": 3,
      "text": "The bound variable is matched against a value to produce the Boolean result. For example, in the condition \"The source IP address of the flow belongs to the 10.1.x.x subnet\", a source IP address variable is matched against a 10.1.x.x subnet value.",
      "ja": "バインドされた変数は、ブール型の結果を生成する値と照合されます。 「フローの送信元IPアドレスが10.1.x.xサブネットに属している」状態で、例えば、送信元IPアドレス変数は10.1.x.xサブネット値と照合されます。"
    },
    {
      "indent": 0,
      "text": "5.8.2. Using Simple Policy Conditions",
      "section_title": true,
      "ja": "5.8.2。シンプルなポリシー条件を使用して、"
    },
    {
      "indent": 3,
      "text": "Simple conditions can be used in policy rules directly, or as building blocks for creating compound policy conditions.",
      "ja": "単純な条件は、直接、または化合物のポリシー条件を作成するためのビルディングブロックとしてのポリシールールで使用することができます。"
    },
    {
      "indent": 3,
      "text": "Simple condition composition MUST enforce the following data-type conformance rule: The ValueTypes property of the variable must be compatible with the type of the value class used. The simplest (and friendliest, from a user point-of-view) way to do this is to equate the type of the value class with the name of the class. By ensuring that the ValueTypes property of the variable matches the name of the value class used, we know that the variable and value instance values are compatible with each other.",
      "ja": "単純な条件組成物は、以下のデータ型の適合規則を適用しなければならない：変数の値型のプロパティが使用される値クラスの種類と互換性がなければなりません。これを行うには（ユーザの視点から、そしてフレンドリー）最も簡単な方法は、クラスの名前と値のクラスの種類を同一視することです。変数の値型のプロパティが使用される値のクラスの名前と一致することを確実にすることによって、我々は、変数および値インスタンスの値は相互に互換性があることを知っています。"
    },
    {
      "indent": 3,
      "text": "Composing a simple condition requires that an instance of the class SimplePolicyCondition be created, and that instances of the variable and value classes that it uses also exist. Note that the variable and/or value instances may already exist as reusable objects in an appropriate ReusablePolicyContainer.",
      "ja": "簡単な条件を構成することは、クラスのSimplePolicyConditionのインスタンスが作成されている必要がありますし、それが使用する変数と値クラスのインスタンスも存在していること。変数および/または値インスタンスが既に適切なReusablePolicyContainerに再利用可能なオブジェクトとして存在し得ることに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "Two aggregations are used in order to create the pair (<variable>, <value>). The aggregation PolicyVariableInSimplePolicyCondition relates a SimplePolicyCondition to a single variable instance. Similarly, the aggregation PolicyValueInSimplePolicyCondition relates a SimplePolicyCondition to a single value instance. Both aggregations are defined in this document.",
      "ja": "二つの集計がペアを作成するために使用されている（<変数>、<値>）。凝集PolicyVariableInSimplePolicyConditionは、単一の変数インスタンスにSimplePolicyConditionに関する。同様に、凝集PolicyValueInSimplePolicyConditionは、単一の値インスタンスにSimplePolicyConditionに関する。どちらの集計は、この文書で定義されています。"
    },
    {
      "indent": 3,
      "text": "Figure 6. depicts a SimplePolicyCondition with its associated variable and value. Also shown are two PolicyValue instances that identify the values that the variable can assume.",
      "ja": "図6は、それに関連する変数と値とのSimplePolicyConditionを示します。変数が取り得る値を識別する2つのPolicyValueインスタンスも示されています。"
    },
    {
      "indent": 3,
      "text": "                           +-----------------------+\n                           | SimplePolicyCondition |\n                           +-----------------------+\n                                 *         @\n                                 *         @\n           +------------------+  *         @  +---------------+\n           | (PolicyVariable) |***         @@@| (PolicyValue) |\n           +------------------+               +---------------+\n              #            #\n              #    ooo     #\n              #            #\n+---------------+        +---------------+\n| (PolicyValue) |  ooo   | (PolicyValue) |\n+---------------+        +---------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Aggregation Legend: **** PolicyVariableInSimplePolicyCondition @@@@ PolicyValueInSimplePolicyCondition #### ExpectedPolicyValuesForVariable",
      "ja": "集計凡例：**** PolicyVariableInSimplePolicyCondition @@@@ PolicyValueInSimplePolicyCondition #### ExpectedPolicyValuesForVariable"
    },
    {
      "indent": 3,
      "text": "Figure 6. SimplePolicyCondition",
      "ja": "図6. SimplePolicyCondition"
    },
    {
      "indent": 3,
      "text": "Note: The class names in parenthesis denote subclasses. The classes named in the figure are abstract, and thus cannot themselves be instantiated.",
      "ja": "注意：括弧内のクラス名はサブクラスを示します。図中の名前のクラスは抽象的であり、したがって自体はインスタンス化することはできません。"
    },
    {
      "indent": 0,
      "text": "5.8.3. The Simple Condition Operator",
      "section_title": true,
      "ja": "5.8.3。単純な条件演算子"
    },
    {
      "indent": 3,
      "text": "A simple condition models an elementary Boolean expression of the form \"variable MATCHes value\". However, the formal notation of the SimplePolicyCondition, together with its associations, models only a pair, (<variable>, <value>). The 'MATCH' operator is not directly modeled -- it is implied. Furthermore, this implied 'MATCH' operator carries overloaded semantics.",
      "ja": "簡単な条件モデルフォーム「変数と一致する値」の基本ブール式。しかし、一緒にその関連付け、モデルのみ対とSimplePolicyConditionの正式な表記法（<変数>、<値>）。 「MATCH」演算子は直接モデル化されていない - それが暗示されます。さらに、この暗黙の「MATCH」演算子はオーバーロードされた意味を運びます。"
    },
    {
      "indent": 3,
      "text": "For example, in the simple condition \"DestinationPort MATCH '80'\", the interpretation of the 'MATCH' operator is equality (the 'equal' operator). Clearly, a different interpretation is needed in the following cases:",
      "ja": "例えば、単純な条件「DestinationPort MATCH 『80』」で、「MATCH」オペレータの解釈は等価（「等しい」演算子）です。明らかに、別の解釈は、次の場合に必要とされています。"
    },
    {
      "indent": 3,
      "text": "o \"DestinationPort MATCH {'80', '8080'}\" -- operator is 'IS SET MEMBER'",
      "ja": "O \"DestinationPort MATCH { '80'、 '8080'}\"  - 演算子は '設定されているメンバー'"
    },
    {
      "indent": 3,
      "text": "o \"DestinationPort MATCH {'1 to 255'}\" -- operator is 'IN INTEGER RANGE'",
      "ja": "\"DestinationPort MATCH { '1〜255'}\" O  - 演算子は 'INTEGERの範囲内' であります"
    },
    {
      "indent": 3,
      "text": "o \"SourceIPAddress MATCH 'MyCompany.com'\" -- operator is 'IP ADDRESS AS RESOLVED BY DNS'",
      "ja": "O \"SourceIPAddress MATCHは 'MyCompany.com'\"  -  'DNSによって解決としてIPアドレス' 演算子は、"
    },
    {
      "indent": 3,
      "text": "The examples above illustrate the implicit, context-dependent nature of the 'MATCH' operator. The interpretation depends on the actual variable and value instances in the simple condition. The interpretation is always derived from the bound variable and the value instance associated with the simple condition. Text accompanying the value class and implicit variable definition is used for interpreting the semantics of the 'MATCH' relationship. In the following list, we define generic (type-independent) matching.",
      "ja": "例としては、上記「MATCH」演算子の暗黙の、コンテキスト依存性を示します。解釈は、単純な条件での実際の変数と値のインスタンスに依存します。解釈は常に簡単な条件に関連付けられているバインド変数と値のインスタンスから導出されます。値クラスと暗黙の変数定義を伴うテキストは「MATCH」の関係の意味を解釈するために使用されています。以下のリストでは、ジェネリック（タイプに依存しない）のマッチングを定義します。"
    },
    {
      "indent": 3,
      "text": "PolicyValues may be multi-fielded, where each field may contain a range of values. The same equally holds for PolicyVariables. Basically, we have to deal with single values (singleton), ranges ([lower bound .. upper bound]), and sets (a,b,c). So independent of the variable and value type, the following set of generic matching rules for the 'MATCH' operator are defined.",
      "ja": "PolicyValuesは、各フィールドが値の範囲を含むことができる場合、マルチフィールド化してもよいです。同じことは均等にPolicyVariablesのために保持しています。基本的に、我々は、単一の値（シングルトン）に対処しなければならない、（[下限..上限]）の範囲であり、セット（A、B、C）。変数と値の型の独立したので、「MATCH」演算子のための一般的なマッチングルールの以下のセットが定義されています。"
    },
    {
      "indent": 3,
      "text": "o singleton matches singleton -> the matching rule is defined in the type",
      "ja": "Oシングルトンは、シングルトンに一致 - >マッチングルールが型に定義されています"
    },
    {
      "indent": 3,
      "text": "o singleton matches range [lower bound .. upper bound] -> the matching evaluates to true, if the singleton matches the lower bound or the upper bound or a value in between",
      "ja": "Oシングルトンマッチは範囲[下限..上限]  - シングルトンが下限又は上限またはその間の値と一致する場合、一致は、真と評価>"
    },
    {
      "indent": 3,
      "text": "o singleton matches set -> the matching evaluates to true, if the value of the singleton matches one of the components in the set, where a component may be a singleton or range again",
      "ja": "シングルトンセットに一致○ - シングルトンの値は、コンポーネントがシングルトンであるか、または再度の範囲であり得るセット内のコンポーネントのいずれかを、一致した場合>マッチングは、真と評価します"
    },
    {
      "indent": 3,
      "text": "o ranges [A..B] matches singleton -> is true if A matches B matches singleton",
      "ja": "O [A..B]マッチはシングルトン範囲 - > Aは、Bは、シングルトンに一致する一致した場合も同様です"
    },
    {
      "indent": 3,
      "text": "o range [A..B] matches range [X..Y] -> the matching evaluates to true, if all values of the range [A..B] are also in the range [X..Y]. For instance, [3..5] match [1..6] evaluates to true, whereas [3..5] match [4..6] evaluates to false.",
      "ja": "O範囲[A..B]マッチは[X..Y]の範囲 - 範囲[A..B]の全ての値は、範囲[X..Y]にも記載されていた場合>マッチングは、真と評価されます。 [3..5] [4..6]偽と評価と一致するのに対し、例えば、[3..5]、[1..6]真と評価と一致します。"
    },
    {
      "indent": 3,
      "text": "o range [A..B] matches set (a,b,c, ...) -> the matching evaluates to true, if all values in the range [A..B] are part of the set. For instance, range [2..3] match set ([1..2],3) evaluates to true, as well as range [2..3] match set (2,3), and range [2..3] match set ([1..2],[3..5]).",
      "ja": "設定O範囲[A..B]マッチ（A、B、C、...） - 範囲[A..B]のすべての値は、セットの一部である場合>マッチングは、真と評価されます。例えば、範囲[2..3]マッチセット（[1..2]は、3）真と評価、ならびに範囲[2..3]マッチセット（2,3）、及び範囲[2 .. 3]マッチセット（[1..2]、[3..5]）。"
    },
    {
      "indent": 3,
      "text": "o set (a,b,c, ...) match singleton -> is true if a match b match c match ... match singleton",
      "ja": "マッチBマッチCが一致した場合>本当です...マッチシングルトン -  O（A、B、C、...）マッチシングルトン設定"
    },
    {
      "indent": 3,
      "text": "o set match range -> the matching evaluates to true, if all values in the set are part of the range. For example, set (2,3) match range [1..4] evaluates to true.",
      "ja": "O一致範囲を設定 - >セット内のすべての値は、範囲の一部である場合、マッチングは、真と評価されます。例えば、（2,3）一致範囲[1..4]真と評価設定。"
    },
    {
      "indent": 3,
      "text": "o set (a,b,c,...) match set (x,y,z,...) -> the matching evaluates to true, if all values in the set (a,b,c,...) are part of the set (x,y,z,...). For example, set (1,2,3) match set (1,2,3,4) evaluates to true. Set (1,2,3) match set (1,2) evaluates to false.",
      "ja": "Oセット（A、B、C、...）マッチセット（X、Y、Z、...） - >マッチングは、真と評価された場合のセットのすべての値（A、B、C、... ）セット（X、Y、Z、...）の一部です。例えば、設定（1,2,3）マッチセット（1,2,3,4）が真と評価します。セット（1,2,3）のマッチセット（1,2）がfalseと評価します。"
    },
    {
      "indent": 3,
      "text": "Variables may contain various types (Section 6.11.1). When not stated otherwise, the type of the value bound to the variable at condition evaluation time and the value type of the PolicyValue instance need to be of the same type. If they differ, then the condition evaluates to FALSE.",
      "ja": "変数にはさまざまなタイプ（6.11.1項）を含有してもよいです。特に明記していない場合、条件評価時に変数にバインドされた値の型とPolicyValueインスタンスの値型が同じタイプである必要があります。それらが異なる場合は、条件がFALSEと評価されます。"
    },
    {
      "indent": 3,
      "text": "The ExpectedPolicyValuesForVariable association specifies an expected set of values that can be matched with a variable within a simple condition. Using this association, a source or destination port can be limited to the range 0-200, a source or destination IP address can be limited to a specified list of IPv4 address values, etc.",
      "ja": "ExpectedPolicyValuesForVariableの関連付けは、単純な条件内の変数と一致させることができる値の予想セットを指定します。この関連付けを使用して、送信元または宛先ポートが範囲0-200に制限することができ、送信元または宛先IPアドレスは、IPv4アドレス値の指定されたリストに限定することができる、等"
    },
    {
      "indent": 3,
      "text": "                       +-----------------------+\n                       | SimplePolicyCondition |\n                       +-----------------------+\n                           *               @\n                           *               @\n                           *               @\n+-----------------------------------+   +--------------------------+\n| Name=SmallSourcePorts             |   | Name=Port300             |\n| Class=PolicySourcePortVariable    |   | Class=PolicyIntegerValue |\n| ValueTypes=[PolicyIntegerValue]   |   | IntegerList = [300]      |\n+-----------------------------------+   +--------------------------+\n             #\n             #\n             #\n+-------------------------+\n|Name=SmallPortsValues    |\n|Class=PolicyIntegerValue |\n|IntegerList=[1..200]     |\n+-------------------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Aggregation Legend: **** PolicyVariableInSimplePolicyCondition @@@@ PolicyValueInSimplePolicyCondition #### ExpectedPolicyValuesForVariable",
      "ja": "集計凡例：**** PolicyVariableInSimplePolicyCondition @@@@ PolicyValueInSimplePolicyCondition #### ExpectedPolicyValuesForVariable"
    },
    {
      "indent": 3,
      "text": "Figure 7. An Invalid SimplePolicyCondition",
      "ja": "図7.無効なSimplePolicyCondition"
    },
    {
      "indent": 3,
      "text": "The ability to express these limitations appears in the model to support validation of a SimplePolicyCondition prior to its deployment to an enforcement point. A Policy Management Tool, for example SHOULD NOT accept the SimplePolicyCondition shown in Figure 7. If, however, a policy rule containing this condition does appear at an enforcement point, the expected values play no role in the determination of whether the condition evaluates to True or False. Thus in this example, the SimplePolicyCondition evaluates to True if the source port for the packet under consideration is 300, and it evaluates to False otherwise.",
      "ja": "これらの制限を表現する能力は、実施ポイントへの展開に先立ってSimplePolicyConditionの検証をサポートするために、モデルに表示されます。ポリシー管理ツールは、しかし、この条件を含むポリシールールが施行時点で表示されない場合は、図7に示すSimplePolicyConditionを受け入れるべきではありません例えば、期待値は、条件がTrueに評価されるかどうかの決定に何の役割も果たしていませんまたはFalse。検討中のパケットの送信元ポートは300であり、それ以外の場合はFALSEと評価された場合にこのように、この例では、SimplePolicyConditionはTrueに評価されます。"
    },
    {
      "indent": 0,
      "text": "5.8.4. SimplePolicyActions",
      "section_title": true,
      "ja": "5.8.4。 SimplePolicyActions"
    },
    {
      "indent": 3,
      "text": "The SimplePolicyAction class models the elementary set operation. \"SET <variable> TO <value>\". The set operator MUST overwrite an old value of the variable. In the case where the variable to be updated is multi- valued, the only update operation defined is a complete replacement of all previous values with a new set. In other words, there are no Add or Remove [to/from the set of values] operations defined for SimplePolicyActions.",
      "ja": "SimplePolicyActionクラスモデル基本セット操作。 \"<変数> SET TO <値>\"。集合演算子は、変数の古い値を上書きする必要があります。更新すべき変数がマルチ評価された場合に、定義された唯一の更新操作は、新しい設定されたすべての以前の値の完全な置換です。言い換えれば、[する/値の組から】SimplePolicyActionsに対して定義された動作の追加または削除がありません。"
    },
    {
      "indent": 3,
      "text": "For example, the action \"set DSCP to EF\" can be modeled by a simple action. In this example, 'DSCP' is an implicit variable referring to the IP packet header DSCP field. 'EF' is an integer or bit string value (6 bits). The complete interpretation of a simple action depends on the binding of the variable.",
      "ja": "たとえば、アクション「EFにDSCPを設定するには、」シンプルなアクションによってモデル化することができます。この例では、「DSCP」はIPパケットのヘッダのDSCPフィールドを参照暗黙的変数です。 「EF」は、整数またはビット文字列値（6ビット）です。シンプルなアクションの完全な解釈は、変数のバインディングに依存します。"
    },
    {
      "indent": 3,
      "text": "The SimplePolicyAction class refines the basic structure of the PolicyAction class defined in PCIM, by specifying the contents of the action using the (<variable>, <value>) pair to form the action. The variable specifies the attribute of an object. The value of this attribute is set to the value specified in <value>. Selection of the object is a function of the type of variable involved. See Sections 5.8.6 and 5.8.7, respectively, for details on object selection for explicitly bound and implicitly bound policy variables.",
      "ja": "SimplePolicyActionクラスは、アクションを形成するために（<変数>、<値>）のペアを使用して、アクションの内容を指定することにより、PCIMで定義されたPolicyActionクラスの基本構造を洗練します。変数は、オブジェクトの属性を指定します。この属性の値は、<値>で指定された値に設定されています。オブジェクトの選択は、関与変数の型の関数です。明示的にバインドされ、暗黙的にバインドされたポリシー変数のオブジェクト選択の詳細については、セクションそれぞれ5.8.6と5.8.7を参照してください。"
    },
    {
      "indent": 3,
      "text": "SimplePolicyActions can be used in policy rules directly, or as building blocks for creating CompoundPolicyActions.",
      "ja": "SimplePolicyActionsは、又はCompoundPolicyActionsを作成するためのビルディングブロックとして直接ポリシールールで使用することができます。"
    },
    {
      "indent": 3,
      "text": "The set operation is only valid if the list of types of the variable (ValueTypes property of PolicyImplicitVariable) includes the specified type of the value. Conversion of values from one representation into another is not defined. For example, a variable of IPv4Address type may not be set to a string containing a DNS name. Conversions are part of an implementation-specific mapping of the model.",
      "ja": "変数の種類のリスト（PolicyImplicitVariableの値型性）が値の指定された型が含まれている場合、設定された動作のみ有効です。別に1つの表現からの値の変換が定義されていません。例えば、IPv4Addressを型の変数は、DNS名を含む文字列に設定されなくてもよいです。変換は、モデルの実装固有のマッピングの一部です。"
    },
    {
      "indent": 3,
      "text": "As was the case with SimplePolicyConditions, the role of expected values for the variables that appear in SimplePolicyActions is for validation, prior to the time when an action is executed. Expected values play no role in action execution.",
      "ja": "SimplePolicyConditionsの場合と同様に、SimplePolicyActionsに現れる変数の期待値の役割は、従来のアクションが実行される時に、確認のためです。期待値は、アクションの実行中に何の役割も果たしていません。"
    },
    {
      "indent": 3,
      "text": "Composing a simple action requires that an instance of the class SimplePolicyAction be created, and that instances of the variable and value classes that it uses also exist. Note that the variable and/or value instances may already exist as reusable objects in an appropriate ReusablePolicyContainer.",
      "ja": "シンプルなアクションを構成することは、クラスのSimplePolicyActionのインスタンスが作成されている必要があり、それはまた、使用する変数と値クラスのインスタンスが存在すること。変数および/または値インスタンスが既に適切なReusablePolicyContainerに再利用可能なオブジェクトとして存在し得ることに留意されたいです。"
    },
    {
      "indent": 3,
      "text": "Two aggregations are used in order to create the pair (<variable>, <value>). The aggregation PolicyVariableInSimplePolicyAction relates a SimplePolicyAction to a single variable instance. Similarly, the aggregation PolicyValueInSimplePolicyAction relates a SimplePolicyAction to a single value instance. Both aggregations are defined in this document.",
      "ja": "二つの集計がペアを作成するために使用されている（<変数>、<値>）。凝集PolicyVariableInSimplePolicyActionは、単一の変数インスタンスにSimplePolicyActionに関する。同様に、凝集PolicyValueInSimplePolicyActionは、単一の値インスタンスにSimplePolicyActionに関する。どちらの集計は、この文書で定義されています。"
    },
    {
      "indent": 3,
      "text": "Figure 8. depicts a SimplePolicyAction with its associated variable and value.",
      "ja": "図8は、その関連する変数と値とのSimplePolicyActionを示します。"
    },
    {
      "indent": 3,
      "text": "                           +-----------------------+\n                           | SimplePolicyAction    |\n                           |                       |\n                           +-----------------------+\n                                 *         @\n                                 *         @\n           +------------------+  *         @  +---------------+\n           | (PolicyVariable) |***         @@@| (PolicyValue) |\n           +------------------+               +---------------+\n              #            #\n              #    ooo     #\n              #            #\n+---------------+        +---------------+\n| (PolicyValue) |  ooo   | (PolicyValue) |\n+---------------+        +---------------+",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Aggregation Legend: **** PolicyVariableInSimplePolicyAction @@@@ PolicyValueInSimplePolicyAction #### ExpectedPolicyValuesForVariable",
      "ja": "集計凡例：**** PolicyVariableInSimplePolicyAction @@@@ PolicyValueInSimplePolicyAction #### ExpectedPolicyValuesForVariable"
    },
    {
      "indent": 3,
      "text": "Figure 8. SimplePolicyAction",
      "ja": "図8 SimplePolicyAction"
    },
    {
      "indent": 0,
      "text": "5.8.5. Policy Variables",
      "section_title": true,
      "ja": "5.8.5。政策変数"
    },
    {
      "indent": 3,
      "text": "A variable generically represents information that changes (or \"varies\"), and that is set or evaluated by software. In policy, conditions and actions can abstract information as \"policy variables\" to be evaluated in logical expressions, or set by actions.",
      "ja": "変数は、一般的に変更（又は「変化」）情報を表し、その設定またはソフトウェアによって評価されます。ポリシーでは、条件とアクションは、「政策変数」など抽象的な情報は、論理式で評価することができ、またはアクションによって設定されました。"
    },
    {
      "indent": 3,
      "text": "PCIMe defines two types of PolicyVariables, PolicyImplicitVariables and PolicyExplicitVariables. The semantic difference between these classes is based on modeling context. Explicit variables are bound to exact model constructs, while implicit variables are defined and evaluated outside of a model. For example, one can imagine a PolicyCondition testing whether a CIM ManagedSystemElement's Status property has the value \"Error.\" The Status property is an explicitly defined PolicyVariable (i.e., it is defined in the context of the CIM Schema, and evaluated in the context of a specific instance). On the other hand, network packets are not explicitly modeled or instantiated, since there is no perceived value (at this time) in managing at the packet level. Therefore, a PolicyCondition can make no explicit reference to a model construct that represents a network packet's source address. In this case, an implicit PolicyVariable is defined, to allow evaluation or modification of a packet's source address.",
      "ja": "PCIMeはPolicyVariables、PolicyImplicitVariablesとPolicyExplicitVariablesの2種類が定義されています。これらのクラス間の意味の差は、モデリングコンテキストに基づいています。暗黙的な変数がモデルの外部で定義され、評価されている間、明示的な変数は、正確なモデル構築物に結合されています。例えば、一つはCIM ManagedSystemElementのStatusプロパティに値があるかどうかをテストするPolicyCondition想像できる「エラーを。」 Statusプロパティは、明示的に定義されPolicyVariable（すなわち、それはCIMスキーマの文脈で定義され、特定のインスタンスのコンテキストで評価されている）です。一方、ネットワークパケットは、明示的にパケットレベルでの管理で（この時点で）が知覚される値が存在しないため、モデル化またはインスタンス化されていません。したがって、PolicyConditionは、ネットワークパケットの送信元アドレスを表すモデル構造物への明示的な参照を作ることはできません。この場合は、暗黙のPolicyVariableは、パケットの送信元アドレスの評価や修正を可能にするために、定義されています。"
    },
    {
      "indent": 0,
      "text": "5.8.6. Explicitly Bound Policy Variables",
      "section_title": true,
      "ja": "5.8.6。明示的にバインド政策変数"
    },
    {
      "indent": 3,
      "text": "Explicitly bound policy variables indicate the class and property names of the model construct to be evaluated or set. The CIM Schema defines and constrains \"appropriate\" values for the variable (i.e., model property) using data types and other information such as class/property qualifiers.",
      "ja": "明示的にバインドされたポリシーの変数がモデル構築物のクラスとプロパティ名は、評価または設定することを示しています。 CIMスキーマ定義し、そのようなクラス/プロパティ修飾子としてデータの種類および他の情報を使用して、変数の「適切な」値（すなわち、モデルプロパティ）を拘束します。"
    },
    {
      "indent": 3,
      "text": "A PolicyExplicitVariable is \"explicit\" because its model semantics are exactly defined. It is NOT explicit due to an exact binding to a particular object instance. If PolicyExplicitVariables were tied to instances (either via associations or by an object identification property in the class itself), then we would be forcing element-specific rules. On the other hand, if we only specify the object's model context (class and property name), but leave the binding to the policy framework (for example, using policy roles), then greater flexibility results for either general or element-specific rules.",
      "ja": "そのモデルのセマンティクスが正確に定義されているためPolicyExplicitVariableは、「明示的」です。それが原因の正確な特定のオブジェクトインスタンスへの結合に明示的ではありません。 PolicyExplicitVariablesが（アソシエーションを介して、またはクラス自体内のオブジェクト識別性のいずれか）のインスタンスに接続した場合、我々は、素子固有のルールを強制するであろう。一方、我々は、オブジェクトのモデルのコンテキスト（クラスおよびプロパティ名）を指定し、その後ポリシーフレームワーク（例えば、ポリシー・ロールを使用して）、一般的または要素固有のいずれかのルールのための柔軟性の結果への結合を残す場合。"
    },
    {
      "indent": 3,
      "text": "For example, an element-specific rule is obtained by a condition ((<variable>, <value>) pair) that defines CIM LogicalDevice DeviceID=\"12345\". Alternately, if a PolicyRule's PolicyRoles is \"edge device\" and the condition ((<variable>, <value>) pair) is Status=\"Error\", then a general rule results for all edge devices in error.",
      "ja": "例えば、素子固有のルールは条件により得られる（（<変数>、<値>）ペア）CIMロジカルデバイスのDeviceID =「12345」を定義します。 PolicyRuleのPolicyRolesは、「エッジデバイス」と条件（（<変数>、<値>）ペア）である場合交互ステータス=「エラー」、エラーですべてのエッジデバイスの次に一般的なルールの結果です。"
    },
    {
      "indent": 3,
      "text": "Currently, the only binding for a PolicyExplicitVariable defined in PCIMe is to the instances selected by policy roles. For each such instance, a SimplePolicyCondition that aggregates the PolicyExplicitVariable evaluates to True if and only if ALL of the following are true:",
      "ja": "現在、唯一PCIMeで定義されたPolicyExplicitVariableのバインディング、ポリシーの役割で選択されたインスタンスにあります。各そのような場合のために、PolicyExplicitVariableを集約SimplePolicyConditionがTrueに評価された場合、次のすべてに該当する場合にのみ："
    },
    {
      "indent": 3,
      "text": "o The instance selected is of the class identified by the variable's ModelClass property, or of a subclass of this class. o The instance selected has the property identified by the variable's ModelProperty property. o The value of this property in the instance matches the value specified in the PolicyValue aggregated by the condition.",
      "ja": "O選択したインスタンスは、変数のModelClassプロパティによって識別されたクラスであり、またはこのクラスのサブクラスの。 O選択したインスタンス変数のModelPropertyプロパティによって識別されるプロパティを持っています。 Oインスタンス内のこのプロパティの値は、条件によって凝集PolicyValueで指定された値と一致します。"
    },
    {
      "indent": 3,
      "text": "In all other cases, the SimplePolicyCondition evaluates to False.",
      "ja": "他のすべてのケースでは、SimplePolicyConditionはFalseに評価されます。"
    },
    {
      "indent": 3,
      "text": "For the case where a SimplePolicyAction aggregates a PolicyExplicitVariable, the indicated property in the selected instance is set to the value represented by the PolicyValue that the SimplePolicyAction also aggregates. However, if the selected instance is not of the class identified by the variable's ModelClass property, or of a subclass of this class, then the action is not performed. In this case the SimplePolicyAction is not treated either as a successfully executed action (for the execution strategy Do",
      "ja": "SimplePolicyActionはPolicyExplicitVariableを集約する場合について、選択したインスタンスで示される特性はSimplePolicyActionも凝集ことPolicyValueで表される値に設定されます。選択したインスタンスは、変数のModelClassプロパティによって識別されたクラスの、またはこのクラスのサブクラスでない場合は、その後、アクションは実行されません。この場合、SimplePolicyActionは、いずれかの実行戦略の実行に成功アクション（のように扱われていないですか"
    },
    {
      "indent": 3,
      "text": "Until Success) or as a failed action (for the execution strategy Do Until Failure). Instead, the remaining actions for the policy rule, if any, are executed as if this SimplePolicyAction were not present at all in the list of actions aggregated by the rule.",
      "ja": "成功するまで）、または失敗したアクションとして（実行戦略のために）失敗するまで行います。このSimplePolicyActionルールによって集約アクションのリストに全く存在しなかったかのように代わりに、ポリシールールの残りのアクションは、もしあれば、実行されます。"
    },
    {
      "indent": 3,
      "text": "Explicit variables would be more powerful if they could reach beyond the instances selected by policy roles, to related instances. However, to represent a policy rule involving such variables in any kind of general way requires something that starts to resemble very much a complete policy language. Clearly such a language is outside the scope of PCIMe, although it might be the subject of a future document.",
      "ja": "彼らは、関連するインスタンスに、政策の役割によって選択されたインスタンスを超えて到達することができれば明示的な変数がより強力になります。しかし、一般的な方法のいずれかの種類では、このような変数を含むポリシールールを表現することが非常に多く、完全なポリシー言語に似ていると起動する何かが必要です。それは将来の文書の主題であるかもしれないが、明らかにそのような言語は、PCIMeの範囲外です。"
    },
    {
      "indent": 3,
      "text": "By restricting much of the generality, it would be possible for explicit variables in PCIMe to reach slightly beyond a selected instance. For example, if a selected instance were related to exactly one instance of another class via a particular association class, and if the goal of the policy rule were both to test a property of this related instance and to set a property of that same instance, then it would be possible to represent the condition and action of the rule using PolicyExplicitVariables. Rather than handling this one specific case with explicit variables, though, it was decided to lump them with the more general case, and deal with them if and when a policy language is defined.",
      "ja": "PCIMeでの明示的な変数はわずか選択したインスタンスを超えて到達するために一般の多くを制限することによって、それが可能です。ポリシールールの目的は、この従来例の特性をテストするために、その同じインスタンスのプロパティを設定するために、両方のであれば、例えば、選択されたインスタンスは、特定の関連クラスを介して別のクラスのうちの正確に1つのインスタンスに関連し、そしてれた場合、 PolicyExplicitVariablesを使用して、ルールの条件とアクションを表現することが可能であろう。むしろ明示的な変数を使用して、この一つの特定のケースを扱うよりも、しかし、それはより一般的なケースでそれらをひとまとめ、およびポリシー言語が定義されている場合ならば、それらに対処することを決定しました。"
    },
    {
      "indent": 3,
      "text": "Refer to Section 6.10 for the formal definition of the class PolicyExplicitVariable.",
      "ja": "クラスPolicyExplicitVariableの正式な定義については、セクション6.10を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.8.7. Implicitly Bound Policy Variables",
      "section_title": true,
      "ja": "5.8.7。暗黙的にバインドされたポリシー変数"
    },
    {
      "indent": 3,
      "text": "Implicitly bound policy variables define the data type and semantics of a variable. This determines how the variable is bound to a value in a condition or an action. Further instructions are provided for specifying data type and/or value constraints for implicitly bound variables.",
      "ja": "暗黙的にバインドされたポリシー変数は、変数のデータ型と意味を定義します。これは、変数は条件またはアクションの値にバインドされる方法を決定します。さらに、命令は、暗黙的にバインドされた変数のデータ型および/または値の制約を指定するために設けられています。"
    },
    {
      "indent": 3,
      "text": "PCIMe introduces an abstract class, PolicyImplicitVariable, to model implicitly bound variables. This class is derived from the abstract class PolicyVariable also defined in PCIMe. Each of the implicitly bound variables introduced by PCIMe (and those that are introduced by domain- specific sub-models) MUST be derived from the PolicyImplicitVariable class. The rationale for using this mechanism for modeling is explained below in Section 5.8.9.",
      "ja": "PCIMeは、暗黙的にバインドされた変数をモデル化するために、抽象クラス、PolicyImplicitVariableを紹介します。このクラスはまた、PCIMeで定義された抽象クラスPolicyVariableから派生しています。 PCIMeによって導入された暗黙的に束縛された変数のそれぞれ（およびドメイン - 特定のサブモデルによって導入されているもの）がPolicyImplicitVariableクラスから派生されなければなりません。モデリングのため、このメカニズムを使用するための理論的根拠は、5.8.9項で説明します。"
    },
    {
      "indent": 3,
      "text": "A domain-specific policy information model that extends PCIMe may define additional implicitly bound variables either by deriving them directly from the class PolicyImplicitVariable, or by further refining an existing variable class such as SourcePort. When refining a class such as SourcePort, existing binding rules, type or value constraints may be narrowed.",
      "ja": "PCIMeクラスPolicyImplicitVariableから直接導出することによって、またはさらに、SourcePortとして既存の変数のクラスを精製することにより、いずれかの付加的な暗黙的にバインドされた変数を定義することができる延びドメイン固有のポリシー情報モデル。例えばSourcePortとしてクラスを精製する際に、既存の結合ルールは、タイプまたは値の制約を狭くすることができます。"
    },
    {
      "indent": 0,
      "text": "5.8.8. Structure and Usage of Pre-Defined Variables",
      "section_title": true,
      "ja": "5.8.8。事前定義変数の構造と使用方法"
    },
    {
      "indent": 3,
      "text": "A class derived from PolicyImplicitVariable to model a particular implicitly bound variable SHOULD be constructed so that its name depicts the meaning of the variable. For example, a class defined to model the source port of a TCP/UDP flow SHOULD have 'SourcePort' in its name.",
      "ja": "その名の変数の意味を示しているように、特定の暗黙的にバインド変数をモデル化するためにPolicyImplicitVariableから派生したクラスが構成されるべきです。たとえば、TCP / UDPフローの送信元ポートをモデル化するために定義されたクラスは、その名前に「SourcePort」を持っているべきです。"
    },
    {
      "indent": 3,
      "text": "PCIMe defines one association and one general-purpose mechanism that together characterize each of the implicitly bound variables that it introduces:",
      "ja": "PCIMe一の協会と一緒に、それが導入され、暗黙的に結合した変数のそれぞれを特徴付ける一つの一般的な目的の機構を定義しています。"
    },
    {
      "indent": 3,
      "text": "1. The ExpectedPolicyValuesForVariable association defines the set of value classes that could be matched to this variable.",
      "ja": "1. ExpectedPolicyValuesForVariableアソシエーションは、この変数に適合することができる値クラスのセットを定義します。"
    },
    {
      "indent": 3,
      "text": "2. The list of constraints on the values that the PolicyVariable can hold (i.e., values that the variable must match) are defined by the appropriate properties of an associated PolicyValue class.",
      "ja": "2. PolicyVariableが保持できる値に制約のリスト（すなわち、変数が一致しなければならない値）関連PolicyValueクラスの適切な特性によって定義されます。"
    },
    {
      "indent": 3,
      "text": "In the example presented above, a PolicyImplicitVariable represents the SourcePort of incoming traffic. The ValueTypes property of an instance of this class will hold the class name PolicyIntegerValue. This by itself constrains the data type of the SourcePort instance to be an integer. However, we can further constrain the particular values that the SourcePort variable can hold by entering valid ranges in the IntegerList property of the PolicyIntegerValue instance (0 - 65535 in this document).",
      "ja": "上記の例では、PolicyImplicitVariableは、着信トラフィックのSourcePortを表します。このクラスのインスタンスの値型のプロパティは、クラス名PolicyIntegerValueを開催します。これは、それ自体で整数にSourcePortインスタンスのデータ・タイプを制約します。しかし、我々はさらにSourcePort変数はPolicyIntegerValueインスタンス（ - この文書に記載されている65535 0）のIntegerListプロパティに有効範囲を入力して保持することができる特定の値を制約することができます。"
    },
    {
      "indent": 3,
      "text": "The combination of the VariableName and the ExpectedPolicyValuesForVariable association provide a consistent and extensible set of metadata that define the semantics of variables that are used to form policy conditions. Since the ExpectedPolicyValuesForVariable association points to a PolicyValue instance, any of the values expressible in the PolicyValue class can be used to constrain values that the PolicyImplicitVariable can hold. For example:",
      "ja": "変数名とExpectedPolicyValuesForVariable関連の組み合わせは、ポリシー条件を形成するために使用される変数の意味論を定義するメタデータの一貫性と拡張セットを提供します。 PolicyValueインスタンスへExpectedPolicyValuesForVariable関連ポイントので、PolicyValueクラスの発現の値のいずれかがPolicyImplicitVariableが保持できる値を制約するために使用することができます。例えば："
    },
    {
      "indent": 3,
      "text": "o The ValueTypes property can be used to ensure that only proper classes are used in the expression. For example, the SourcePort variable will not be allowed to ever be of type PolicyIPv4AddrValue, since source ports have different semantics than IP addresses and may not be matched. However, integer value types are allowed as the property ValueTypes holds the string \"PolicyIntegerValue\", which is the class name for integer values.",
      "ja": "O値型のプロパティは、適切なクラスが式の中で使用されることを保証するために使用することができます。送信元ポートは、IPアドレスとは異なる意味を持っていると一致することはできませんので、例えば、SourcePort変数は、これまでのタイプPolicyIPv4AddrValueであることを許可されません。しかし、整数値の型は値型は、整数値のクラス名である文字列「PolicyIntegerValue」を、保持しているプロパティとして許可されています。"
    },
    {
      "indent": 3,
      "text": "o The ExpectedPolicyValuesForVariable association also ensures that variable-specific semantics are enforced (e.g., the SourcePort variable may include a constraint association to a value object defining a specific integer range that should be matched).",
      "ja": "ExpectedPolicyValuesForVariableアソシエーションが、可変固有のセマンティクスが適用されることを保証O（例えば、SourcePort変数が一致しなければならない特定の整数の範囲を定義する値のオブジェクトに制約の関連付けを含むことができます）。"
    },
    {
      "indent": 0,
      "text": "5.8.9. Rationale for Modeling Implicit Variables as Classes",
      "section_title": true,
      "ja": "5.8.9。クラスとしてモデル化暗黙的変数の理論的根拠"
    },
    {
      "indent": 3,
      "text": "An implicitly bound variable can be modeled in one of several ways, including a single class with an enumerator for each individual implicitly bound variable and an abstract class extended for each individual variable. The reasons for using a class inheritance mechanism for specifying individual implicitly bound variables are these:",
      "ja": "暗黙的にバインド変数は、個々の変数に拡張し、個々の暗黙的にバインド変数と抽象クラスの列挙子を持つ単一のクラスを含め、いくつかの方法、のいずれかでモデル化することができます。個々の暗黙的にバインドされた変数を指定するためのクラス継承のメカニズムを使用する理由は、これらのとおりです。"
    },
    {
      "indent": 3,
      "text": "1. It is easy to extend. A domain-specific information model can easily extend the PolicyImplicitVariable class or its subclasses to define domain-specific and context-specific variables. For example, a domain-specific QoS policy information model may introduce an implicitly bound variable class to model applications by deriving a qosApplicationVariable class from the PolicyImplicitVariable abstract class.",
      "ja": "1.拡張が容易です。ドメイン固有の情報モデル容易ドメイン固有およびコンテキスト固有の変数を定義するPolicyImplicitVariableクラスまたはそのサブクラスを拡張することができます。たとえば、ドメイン固有のQoSポリシー情報モデルはPolicyImplicitVariable抽象クラスからqosApplicationVariableクラスを派生させて、アプリケーションをモデル化するために、暗黙的にバインド変数クラスを導入することができます。"
    },
    {
      "indent": 3,
      "text": "2. Introduction of a single structural class for implicitly bound variables would have to include an enumerator property that contains all possible individual implicitly bound variables. This means that a domain-specific information model wishing to introduce an implicitly bound variable must extend the enumerator itself. This results in multiple definitions of the same class, differing in the values available in the enumerator class. One definition, in this document, would include the common implicitly bound variables' names, while a second definition, in the domain-specific information model document, may include additional values ('qosApplicationVariable' in the example above). It wouldn't even be obvious to the application developer that multiple class definitions existed. It would be harder still for the application developer to actually find the correct class to use.",
      "ja": "暗黙的にバインドされた変数のための単一の構造クラスの2.はじめは、すべての可能な個々の暗黙的にバインドされた変数が含まれている列挙子のプロパティを含めなければならないでしょう。これは、暗黙的にバインド変数を導入したいドメイン固有の情報モデルは、列挙子自体を拡張しなければならないことを意味します。これは、列挙子クラスで利用可能な値が異なる、同じクラスの複数の定義になります。 （上記の例では 『qosApplicationVariable）は、第2の定義は、ドメイン固有の情報モデル文書に、追加の値を含むことが、名称』一つの定義は、この文書では、一般的な暗黙的に結合した変数を含むであろう。それも、複数のクラス定義が存在していたアプリケーション開発者には自明ではないでしょう。アプリケーション開発者が実際に正しいクラスを使用することを見つけることは難しく、まだだろう。"
    },
    {
      "indent": 3,
      "text": "3. In addition, an enumerator-based definition would require each additional value to be registered with IANA to ascertain adherence to standards. This would make the process cumbersome.",
      "ja": "3.また、列挙ベースの定義は、標準の遵守を確認するためにIANAに登録される各付加価値を必要とするであろう。これは、プロセスが煩雑になるだろう。"
    },
    {
      "indent": 3,
      "text": "4. A possible argument against the inheritance mechanism would cite the fact that this approach results in an explosion of class definitions compared to an enumerator class, which only introduces a single class. While, by itself, this is not a strike against the approach, it may be argued that data models derived from this information model may be more difficult to optimize for applications. This argument is rejected on the grounds that application optimization is of lesser value for an information model than clarity and ease of extension. In addition, it is hard to claim that the inheritance model places an absolute burden on the optimization. For example, a data model may still use enumeration to denote instances of pre-defined variables and claim PCIMe compliance, as long as the data model can be mapped correctly to the definitions specified in this document.",
      "ja": "4.継承メカニズムに対する可能な引数は、クラス定義の爆発、このアプローチの結果は、単一のクラスを導入列挙子クラスと比較するという事実を引用するであろう。それ自体で、このアプローチに衝突ではないが、この情報モデルから導出されたデータモデルがアプリケーションのために最適化することがより困難であり得ることを主張することができます。この引数は、アプリケーションの最適化は、明快さと拡張の容易さよりも情報モデルのために低い値であることを理由に拒否されます。また、継承モデルが最適化に絶対的な負担を課すことを主張するのは難しいです。例えば、データ・モデルが依然としてデータモデルは、この文書で指定された定義に正確にマッピングすることができる限り、あらかじめ定義された変数および請求PCIMeコンプライアンスのインスタンスを表すために列挙を使用してもよいです。"
    },
    {
      "indent": 0,
      "text": "5.8.10. Policy Values",
      "section_title": true,
      "ja": "5.8.10。ポリシーの値"
    },
    {
      "indent": 3,
      "text": "The abstract class PolicyValue is used for modeling values and constants used in policy conditions. Different value types are derived from this class, to represent the various attributes required. Extensions of the abstract class PolicyValue, defined in this document, provide a list of values for basic network attributes. Values can be used to represent constants as named values. Named values can be kept in a reusable policy container to be reused by multiple conditions. Examples of constants include well-known ports, well-known protocols, server addresses, and other similar concepts.",
      "ja": "抽象クラスPolicyValueは、ポリシー条件で使用される値と定数をモデル化するために使用されます。異なる値の型が必要なさまざまな属性を表すために、このクラスから派生しています。この文書で定義された抽象クラスPolicyValueの拡張機能は、ネットワークの基本的な属性の値のリストを提供します。値は、名前付きの値として定数を表すために使用することができます。名前付きの値は、複数の条件によって再利用するための再利用可能なポリシーコンテナに保管することができます。定数の例は、よく知られたポート、周知のプロトコル、サーバアドレス、および他の同様の概念を含みます。"
    },
    {
      "indent": 3,
      "text": "The PolicyValue subclasses define three basic types of values: scalars, ranges and sets. For example, a well-known port number could be defined using the PolicyIntegerValue class, defining a single value (80 for HTTP), a range (80-88), or a set (80, 82, 8080) of ports, respectively. For details, please see the class definition for each value type in Section 6.14 of this document.",
      "ja": "スカラー、範囲やセット：PolicyValueサブクラスは、値の3つの基本タイプを定義します。それぞれ、例えば、よく知られているポート番号の範囲（80~88）、単一の値（HTTP 80）を規定する、PolicyIntegerValueクラスを使用して定義することができ、またはポートのセット（80、82、8080）。詳細については、このドキュメントのセクション6.14の各値型のクラス定義を参照してください。"
    },
    {
      "indent": 3,
      "text": "PCIMe defines the following subclasses of the abstract class PolicyValue:",
      "ja": "PCIMeは抽象クラスPolicyValueの次のサブクラスを定義します。"
    },
    {
      "indent": 3,
      "text": "Classes for general use:",
      "ja": "一般的な使用のためのクラス："
    },
    {
      "indent": 6,
      "text": "- PolicyStringValue, - PolicyIntegerValue, - PolicyBitStringValue - PolicyBooleanValue.",
      "ja": " - ポリシーSTRINGVALUE、 - ポリシーするIntegerValue、 -  PolicyBitStringValue  - ポリシーするBooleanValue。"
    },
    {
      "indent": 3,
      "text": "Classes for layer 3 Network values:",
      "ja": "レイヤ3ネットワーク値のクラス："
    },
    {
      "indent": 6,
      "text": "- PolicyIPv4AddrValue, - PolicyIPv6AddrValue.",
      "ja": " - ポリシーIPv4Addr値、 - ポリシーIPv6Addr値。"
    },
    {
      "indent": 3,
      "text": "Classes for layer 2 Network values:",
      "ja": "レイヤ2ネットワーク値のクラス："
    },
    {
      "indent": 6,
      "text": "- PolicyMACAddrValue.",
      "ja": " -  PolicyMACAddrValue。"
    },
    {
      "indent": 3,
      "text": "For details, please see the class definition section of each class in Section 6.14 of this document.",
      "ja": "詳細については、このドキュメントのセクション6.14内の各クラスのクラス定義の項を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.9. Packet Filtering",
      "section_title": true,
      "ja": "5.9。パケットフィルタリング"
    },
    {
      "indent": 3,
      "text": "PCIMe contains two mechanisms for representing packet filters. The more general of these, termed here the domain-level model, expresses packet filters in terms of policy variables and policy values. The other mechanism, termed here the device-level model, expresses packet filters in a way that maps more directly to the packet fields to which the filters are being applied. While it is possible to map between these two representations of packet filters, no mapping is provided in PCIMe itself.",
      "ja": "PCIMeは、パケットフィルタを表現するための2つのメカニズムが含まれています。これらのより一般的な、ドメインレベルのモデルは、政策変数とポリシー値の面でパケットフィルタを表現し、ここで呼ばれます。他のメカニズムは、デバイスレベルのモデルは、フィルタが適用されているかにパケットフィールドに、より直接的にマップする方法で、パケットフィルタを表現し、ここで呼ばれます。それは、パケットフィルタのこれら2つの表現の間でマッピングすることは可能であるが、いかなるマッピングはPCIMe自体に設けられていません。"
    },
    {
      "indent": 0,
      "text": "5.9.1. Domain-Level Packet Filters",
      "section_title": true,
      "ja": "5.9.1。ドメインレベルのパケットフィルタ"
    },
    {
      "indent": 3,
      "text": "In addition to filling in the holes in the overall Policy infrastructure, PCIMe proposes a single mechanism for expressing domain-level packet filters in policy conditions. This is being done in response to concerns that even though the initial \"wave\" of submodels derived from PCIM were all filtering on IP packets, each was doing it in a slightly different way. PCIMe proposes a common way to express IP packet filters. The following figure illustrates how packet-filtering conditions are expressed in PCIMe.",
      "ja": "全体的なポリシーインフラストラクチャ内の穴を埋めることに加えて、PCIMeは、ポリシー条件でドメインレベルのパケットフィルタを発現するための単一のメカニズムを提案しています。これは、PCIM由来のサブモデルの初期の「波」は、それぞれがわずかに異なる方法でそれをIPパケット上のすべてのフィルタリングをやっていたたにもかかわらず懸念に対応して行われています。 PCIMeは、IPパケットフィルタを表現する一般的な方法を提案しています。次の図は、パケットフィルタリング条件はPCIMeにおいて発現される様子を示します。"
    },
    {
      "indent": 3,
      "text": "               +---------------------------------+\n               | CompoundFilterCondition         |\n               |   - IsMirrored   boolean        |\n               |   - ConditionListType (DNF|CNF) |\n               +---------------------------------+\n                +               +               +\n                +               +               +\n                +               +               +\n            SimplePC        SimplePC        SimplePC\n            *      @        *      @        *      @\n            *      @        *      @        *      @\n            *      @        *      @        *      @\nFlowDirection    \"In\"     SrcIP  <addr1>  DstIP  <addr2>",
      "raw": true
    },
    {
      "indent": 3,
      "text": "Aggregation Legend: ++++ PolicyConditionInPolicyCondition **** PolicyVariableInSimplePolicyCondition @@@@ PolicyValueInSimplePolicyCondition",
      "ja": "集計凡例：++++ PolicyConditionInPolicyCondition **** PolicyVariableInSimplePolicyCondition @@@@ PolicyValueInSimplePolicyCondition"
    },
    {
      "indent": 3,
      "text": "Figure 9. Packet Filtering in Policy Conditions",
      "ja": "ポリシー条件で図9.パケットフィルタリング"
    },
    {
      "indent": 3,
      "text": "In Figure 9., each SimplePolicyCondition represents a single field to be filtered on: Source IP address, Destination IP address, Source port, etc. An additional SimplePolicyCondition indicates the direction that a packet is traveling on an interface: inbound or outbound. Because of the FlowDirection condition, care must be taken in aggregating a set of SimplePolicyConditions into a CompoundFilterCondition. Otherwise, the resulting CompoundPolicyCondition may match all inbound packets, or all outbound packets, when this is probably not what was intended.",
      "ja": "インバウンドまたはアウトバウンド：追加SimplePolicyConditionパケットがインターフェイス上で走行している方向を示す送信元IPアドレス、宛先IPアドレス、送信元ポート、等：図9に、各SimplePolicyConditionはで濾過される単一フィールドを表します。そのため流れ方向条件のため、注意がCompoundFilterConditionにSimplePolicyConditionsのセットを集約に注意する必要があります。これは意図したのかもしれないときにそれ以外の場合は、結果CompoundPolicyConditionは、すべての着信パケット、またはすべてのアウトバウンドパケットを一致させることができます。"
    },
    {
      "indent": 3,
      "text": "Individual SimplePolicyConditions may be negated when they are aggregated by a CompoundFilterCondition.",
      "ja": "彼らはCompoundFilterConditionによって集約されている場合、個々のSimplePolicyConditionsを否定することができます。"
    },
    {
      "indent": 3,
      "text": "CompoundFilterCondition is a subclass of CompoundPolicyCondition. It introduces one additional property, the Boolean property IsMirrored. The purpose of this property is to allow a single CompoundFilterCondition to match packets traveling in both directions on a higher-level connection such as a TCP session. When this property is TRUE, additional packets match a filter, beyond those that would ordinarily match it. An example will illustrate how this property works.",
      "ja": "CompoundFilterConditionはCompoundPolicyConditionのサブクラスです。これは、1つの追加プロパティ、ブール型プロパティIsMirroredを紹介します。このプロパティの目的は、TCPセッションと、より高いレベルの接続に両方向に移動するパケットに一致する単一CompoundFilterConditionを可能にすることです。このプロパティがTRUEである場合には、追加のパケットは、通常、それにマッチするものを超えて、フィルタに一致します。例では、このプロパティがどのように機能するかを説明します。"
    },
    {
      "indent": 3,
      "text": "Suppose we have a CompoundFilterCondition that aggregates the following three filters, which are ANDed together:",
      "ja": "私たちが一緒にAND演算され、次の3つのフィルタを、集約CompoundFilterConditionがあるとします。"
    },
    {
      "indent": 6,
      "text": "o FlowDirection = \"In\" o Source IP = 9.1.1.1 o Source Port = 80",
      "ja": "= 80元ポート〇〇流れ方向= \"で\" OソースIP = 9.1.1.1"
    },
    {
      "indent": 3,
      "text": "Regardless of whether IsMirrored is TRUE or FALSE, inbound packets will match this CompoundFilterCondition if their Source IP address = 9.1.1.1 and their Source port = 80. If IsMirrored is TRUE, however, an outbound packet will also match the CompoundFilterCondition if its Destination IP address = 9.1.1.1 and its Destination port = 80.",
      "ja": "IsMirroredがTRUEの場合ならば、その送信元IPアドレス= 9.1.1.1とそのソースポート= 80は、しかし、アウトバウンドパケットはまたCompoundFilterConditionと一致するかどうかにかかわらずIsMirroredがTRUEかFALSEであるかどうかの、インバウンドパケットがこのCompoundFilterConditionと一致しますその宛先IPアドレス= 9.1.1.1とその宛先ポート= 80。"
    },
    {
      "indent": 3,
      "text": "IsMirrored \"flips\" the following Source/Destination packet header fields:",
      "ja": "IsMirroredは、次の送信元/送信先のパケットヘッダフィールド「に反転します」："
    },
    {
      "indent": 6,
      "text": "o FlowDirection \"In\" / FlowDirection \"Out\" o Source IP address / Destination IP address o Source port / Destination port o Source MAC address / Destination MAC address o Source [layer-2] SAP / Destination [layer-2] SAP.",
      "ja": "ソース[レイヤ2] SAP /デスティネーション[レイヤー2] SAP OソースMACアドレス/宛先MACアドレスOソースポート/宛先ポートOソースIPアドレス/宛先IPアドレスO \"アウト\" /流れ方向 \"で\" O流れ方向。"
    },
    {
      "indent": 0,
      "text": "5.9.2. Device-Level Packet Filters",
      "section_title": true,
      "ja": "5.9.2。デバイスレベルのパケットフィルタ"
    },
    {
      "indent": 3,
      "text": "At the device level, packet header filters are represented by two subclasses of the abstract class FilterEntryBase: IpHeadersFilter and 8021Filter. Submodels of PCIMe may define other subclasses of FilterEntryBase in addition to these two; ICPM [12], for example, defines subclasses for IPsec-specific filters.",
      "ja": "IpHeadersFilterと8021Filter：デバイスレベルでは、パケットのヘッダフィルタは抽象クラスFilterEntryBaseの2つのサブクラスによって表されます。 PCIMeのサブモデルは、これら二つに加えFilterEntryBaseの他のサブクラスを定義することができます。 ICPM [12]は、例えば、IPsecの固有フィルタのサブクラスを定義します。"
    },
    {
      "indent": 3,
      "text": "Instances of the subclasses of FilterEntryBase are not used directly as filters. They are always aggregated into a FilterList, by the aggregation EntriesInFilterList. For PCIMe and its submodels, the EntrySequence property in this aggregation always takes its default value '0', indicating that the aggregated filter entries are ANDed together.",
      "ja": "FilterEntryBaseのサブクラスのインスタンスは、フィルタとして直接使用されていません。彼らは常に集約EntriesInFilterListにより、FilterListに集約されます。 PCIMeそのサブモデルのために、この凝集のEntrySequenceプロパティは、常にデフォルト値をとる「0」、凝集フィルタエントリが一緒にAND演算されることを示します。"
    },
    {
      "indent": 3,
      "text": "The FilterList class includes an enumeration property Direction, representing the direction of the traffic flow to which the FilterList is to be applied. The value Mirrored(4) for Direction represents exactly the same thing as the IsMirrored boolean does in CompoundFilterCondition. See Section 5.9.1 for details.",
      "ja": "FilterListクラスはFilterListが適用されるトラフィックフローの方向を表し、列挙型プロパティの方向を含みます。方向について（4）ミラーリング値がIsMirroredのブールCompoundFilterConditionでないと全く同じものを表します。詳細については、5.9.1項を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.10. Conformance to PCIM and PCIMe",
      "section_title": true,
      "ja": "5.10。 PCIMとPCIMeへの適合"
    },
    {
      "indent": 3,
      "text": "Because PCIM and PCIMe provide the core classes for modeling policies, they are not in general sufficient by themselves for representing actual policy rules. Submodels, such as QPIM and ICPM, provide the means for expressing policy rules, by defining subclasses of the classes defined in PCIM and PCIMe, and/or by indicating how the PolicyVariables and PolicyValues defined in PCIMe can be used to express conditions and actions applicable to the submodel.",
      "ja": "PCIMとPCIMeモデリングポリシーのコアクラスを提供しているので、彼らは実際のポリシールールを表現するために自分で一般的に十分ではありません。例えばQPIMとICPMなどのサブモデルは、PCIM及びPCIMeで定義されたクラスのサブクラスを定義することによって、及び/又はPCIMeで定義さPolicyVariablesとPolicyValuesが適用条件およびアクションを表現するために使用することができる方法を示すことによって、ポリシールールを表現するための手段を提供しますサブモデルへ。"
    },
    {
      "indent": 3,
      "text": "A particular submodel will not, in general, need to use every element defined in PCIM and PCIMe. For the elements it does not use, a submodel SHOULD remain silent on whether its implementations must support the element, must not support the element, should support the element, etc. For the elements it does use, a submodel SHOULD indicate which elements its implementations must support, which elements they should support, and which elements they may support.",
      "ja": "特定のサブモデルは、一般的に、PCIMとPCIMeで定義されたすべての要素を使用する必要はありません。要素の場合には、サブモデルは、要素の実装を示す必要があり、それは使用しない要素の場合などの要素を、サポートする必要があり、要素をサポートしていなければならない、サブモデルは、その実装が要素をサポートしなければならないかどうかに沈黙SHOULD、使用していませんサポートされている必要があり、それらがサポートすべき要素、およびそれらをサポートする可能性がある要素。"
    },
    {
      "indent": 3,
      "text": "PCIM and PCIMe themselves simply define elements that may be of use to submodels. These documents remain silent on whether implementations are required to support an element, should support it, etc.",
      "ja": "PCIMとPCIMe自体は単にサブモデルに有用であり得る要素を定義します。これらの文書は、など、それをサポートする必要があり、実装は要素をサポートするために必要とされるかどうかに沈黙します"
    },
    {
      "indent": 3,
      "text": "This model (and derived submodels) defines conditions and actions that are used by policy rules. While the conditions and actions defined herein are straightforward and may be presumed to be widely supported, as submodels are developed it is likely that situations will arise in which specific conditions or actions are not supported by some part of the policy execution system. Similarly, situations may also occur where rules contain syntactic or semantic errors.",
      "ja": "このモデル（および派生サブモデル）が条件とポリシールールで使用されるアクションを定義します。本明細書に定義された条件とアクションは簡単で、サブモデルが開発されると、状況が特定の条件またはアクションがポリシー実行システムの一部でサポートされていないで発生する可能性がある、広くサポートしていると推定されてもよいです。ルールは、構文またはセマンティックエラーを含む場合同様、状況も起こり得ます。"
    },
    {
      "indent": 3,
      "text": "It should be understood that the behavior and effect of undefined or incorrectly defined conditions or actions is not prescribed by this information model. While it would be helpful if it were prescribed, the variations in implementation restrict the ability for this information model to control the effect. For example, if an implementation only detected that a PEP could not enforce a given action on that PEP, it would be very difficult to declare that such a failure should affect other PEPs, or the PDP process. On the other hand, if the PDP determines that it cannot properly evaluate a condition, that failure may well affect all applications of the containing rules.",
      "ja": "未定義または不正に定義された条件またはアクションの動作と効果はこの情報モデルで規定されていないことを理解すべきです。それは処方された場合、それが参考になるものの、実装の変化が影響を制御するには、この情報モデルのための能力を制限します。実装のみPEPは、そのPEPに特定のアクションを強制することができなかったことを検出した場合、例えば、そのような障害は、他のPEP、またはPDPプロセスに影響を与えるべきであることを宣言するのは非常に困難であろう。 PDPは、それが適切に条件を評価することができないと判断した場合一方、その失敗はよく含むルールのすべてのアプリケーションに影響を与える可能性があります。"
    },
    {
      "indent": 0,
      "text": "6. Class Definitions",
      "section_title": true,
      "ja": "6.クラス定義"
    },
    {
      "indent": 3,
      "text": "The following definitions supplement those in PCIM itself. PCIM definitions that are not DEPRECATED here are still current parts of the overall Policy Core Information Model.",
      "ja": "以下の定義は、PCIM自身でそれらを補完します。ここでは非推奨されていないPCIM定義はまだ全体的な方針コア情報モデルの現在の部分です。"
    },
    {
      "indent": 0,
      "text": "6.1. The Abstract Class \"PolicySet\"",
      "section_title": true,
      "ja": "6.1。抽象クラス「POLICYSET」"
    },
    {
      "indent": 3,
      "text": "PolicySet is an abstract class that may group policies into a structured set of policies.",
      "ja": "POLICYSETは、その政策の構造化されたセットにも、グループポリシーの抽象クラスです。"
    },
    {
      "indent": 3,
      "text": "NAME PolicySet DESCRIPTION An abstract class that represents a set of policies that form a coherent set. The set of contained policies has a common decision strategy and a common set of policy roles. Subclasses include PolicyGroup and PolicyRule. DERIVED FROM Policy ABSTRACT TRUE PROPERTIES PolicyDecisionStrategy PolicyRoles",
      "ja": "コヒーレントセットを形成ポリシーのセットを表す名前POLICYSET説明抽象クラス。含まれるポリシーのセットは、一般的な意思決定の戦略と政策の役割の共通セットを持っています。サブクラスはのPolicyGroupとのPolicyRuleが含まれます。ポリシーABSTRACT TRUE PROPERTIES PolicyDecisionStrategy PolicyRolesから、派生"
    },
    {
      "indent": 3,
      "text": "The PolicyDecisionStrategy property specifies the evaluation method for policy groups and rules contained within the policy set.",
      "ja": "PolicyDecisionStrategyプロパティは、ポリシー・セット内に含まれるポリシーグループルールの評価方法を指定します。"
    },
    {
      "indent": 3,
      "text": "NAME PolicyDecisionStrategy DESCRIPTION The evaluation method used for policies contained in the PolicySet. FirstMatching enforces the actions of the first rule that evaluates to TRUE; All Matching enforces the actions of all rules that evaluate to TRUE. SYNTAX uint16 VALUES 1 [FirstMatching], 2 [AllMatching] DEFAULT VALUE 1 [FirstMatching]",
      "ja": "POLICYSETに含まれているポリシーに使用される評価方法PolicyDecisionStrategy説明名前。 FirstMatchingはTRUEに評価された最初のルールのアクションを強制します。すべてのマッチングはTRUEと評価されたすべてのルールのアクションを適用します。 VALUES uint16のSYNTAX 1 [FirstMatching]、2 [AllMatching]デフォルト値1 [FirstMatching]"
    },
    {
      "indent": 3,
      "text": "The definition of PolicyRoles is unchanged from PCIM. It is, however, moved from the class Policy up to the superclass PolicySet.",
      "ja": "PolicyRolesの定義は、PCIMから変更されていません。それは、しかし、スーパークラスのPOLICYSETまでのクラスポリシーから移動されます。"
    },
    {
      "indent": 0,
      "text": "6.2. Update PCIM's Class \"PolicyGroup\"",
      "section_title": true,
      "ja": "6.2。更新PCIMのクラス「のPolicyGroup」"
    },
    {
      "indent": 3,
      "text": "The PolicyGroup class is moved, so that it is now derived from PolicySet.",
      "ja": "それが今POLICYSETに由来しているように、のPolicyGroupクラスは、移動しています。"
    },
    {
      "indent": 3,
      "text": "NAME PolicyGroup DESCRIPTION A container for a set of related PolicyRules and PolicyGroups. DERIVED FROM PolicySet ABSTRACT FALSE PROPERTIES (none)",
      "ja": "関連PolicyRulesとPolicyGroupsのセットの名前のPolicyGroup説明Aコンテナ。 POLICYSET ABSTRACT FALSE PROPERTIES（なし）に由来します"
    },
    {
      "indent": 0,
      "text": "6.3. Update PCIM's Class \"PolicyRule\"",
      "section_title": true,
      "ja": "6.3。更新PCIMのクラス「のPolicyRule」"
    },
    {
      "indent": 3,
      "text": "The PolicyRule class is moved, so that it is now derived from PolicySet. The Priority property is also deprecated in PolicyRule, and PolicyRoles is now inherited from the parent class PolicySet. Finally, a new property ExecutionStrategy is introduced, paralleling the property of the same name in the class CompoundPolicyAction.",
      "ja": "それが今POLICYSETに由来しているように、PolicyRuleのクラスは、移動しています。 PriorityプロパティもPolicyRuleので廃止され、そしてPolicyRolesは現在、親クラスPOLICYSETから継承されます。最後に、新しいプロパティExecutionStrategyは、クラスCompoundPolicyActionに同じ名前のプロパティを並列に、導入されます。"
    },
    {
      "indent": 3,
      "text": "NAME PolicyRule DESCRIPTION The central class for representing the \"If Condition then Action\" semantics associated with a policy rule. DERIVED FROM PolicySet ABSTRACT FALSE PROPERTIES Enabled ConditionListType RuleUsage Priority DEPRECATED FOR PolicySetComponent.Priority AND FOR PolicySetInSystem.Priority Mandatory SequencedActions ExecutionStrategy",
      "ja": "ポリシールールに関連付けられている「条件であれば、その後のアクション」の意味を表すためのNAMEのPolicyRuleの説明中央のクラス。 POLICYSET ABSTRACTから、派生FALSE PROPERTIESはConditionListType RuleUsageプライオリティ推奨されていませんPolicySetComponent.Priorityを有効にしてPolicySetInSystem.Priority必須SequencedActions ExecutionStrategy FOR"
    },
    {
      "indent": 3,
      "text": "The property ExecutionStrategy defines the execution strategy to be used upon the sequenced actions aggregated by this PolicyRule. (An equivalent ExecutionStrategy property is also defined for the CompoundPolicyAction class, to provide the same indication for the sequenced actions aggregated by a CompoundPolicyAction.) This document defines three execution strategies:",
      "ja": "プロパティExecutionStrategyこのPolicyRuleの配列決定によって集約アクション時に使用される実行計画を定義します。 （等価ExecutionStrategy性もCompoundPolicyActionによって集約配列決定アクションの同じ表示を提供するために、CompoundPolicyActionクラスのために定義されている。）このドキュメントでは、3つの実行戦略を定義します。"
    },
    {
      "indent": 3,
      "text": "Do Until Success - execute actions according to predefined order, until successful execution of a single action. Do All - execute ALL actions which are part of the modeled set, according to their predefined order. Continue doing this, even if one or more of the actions fails.",
      "ja": "成功までやる - 単一のアクションの実行が成功するまで、事前に定義された順序に従ってアクションを実行します。全ください - 彼らの事前に定義された順序に従って、モデル化されたセットの一部であるすべてのアクションを実行します。アクションの1つ以上が故障した場合でも、これをやって続行します。"
    },
    {
      "indent": 3,
      "text": "Do Until Failure - execute actions according to predefined order, until the first failure in execution of a single sub-action.",
      "ja": "破壊するまで行います - 単一のサブアクションの実行中に最初の失敗まで、事前に定義された順序に従ってアクションを実行します。"
    },
    {
      "indent": 3,
      "text": "The property definition is as follows:",
      "ja": "次のようにプロパティの定義は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "NAME ExecutionStrategy DESCRIPTION An enumeration indicating how to interpret the action ordering for the actions aggregated by this PolicyRule. SYNTAX uint16 (ENUM, {1=Do Until Success, 2=Do All, 3=Do Until Failure} ) DEFAULT VALUE Do All (2)",
      "ja": "ExecutionStrategy説明にこのPolicyRuleのによって集約アクションのアクション注文をどのように解釈するかを示す列挙に名前を付けます。構文uint16のデフォルト値（ENUM、{1が成功するまで、2 =すべての操作を行います= 3が破壊するまで行い=}）ないすべての（2）"
    },
    {
      "indent": 0,
      "text": "6.4. The Class \"SimplePolicyCondition\"",
      "section_title": true,
      "ja": "6.4。クラス「SimplePolicyCondition」"
    },
    {
      "indent": 3,
      "text": "A simple policy condition is composed of an ordered triplet:",
      "ja": "シンプルなポリシー条件は、注文したトリプレットで構成されています。"
    },
    {
      "indent": 6,
      "text": "<Variable> MATCH <Value>",
      "ja": "<変数> MATCH <値>"
    },
    {
      "indent": 3,
      "text": "No formal modeling of the MATCH operator is provided. The 'match' relationship is implied. Such simple conditions are evaluated by answering the question:",
      "ja": "MATCH演算子の正式なモデリングが提供されていません。 「試合」の関係が示唆されます。このような単純な条件は、質問に答えることによって評価されます。"
    },
    {
      "indent": 6,
      "text": "Does <variable> match <value>?",
      "ja": "<変数>試合<値>していますか？"
    },
    {
      "indent": 3,
      "text": "The 'match' relationship is to be interpreted by analyzing the variable and value instances associated with the simple condition.",
      "ja": "「一致」の関係は、単純な状態に関連する変数と値のインスタンスを分析することによって解釈されるべきです。"
    },
    {
      "indent": 3,
      "text": "Simple conditions are building blocks for more complex Boolean Conditions, modeled by the CompoundPolicyCondition class.",
      "ja": "単純な条件はCompoundPolicyConditionクラスによってモデル化し、より複雑なブール条件のためのブロックを構築しています。"
    },
    {
      "indent": 3,
      "text": "The SimplePolicyCondition class is derived from the PolicyCondition class defined in PCIM.",
      "ja": "SimplePolicyConditionクラスはPCIMで定義されたPolicyConditionのクラスから派生しています。"
    },
    {
      "indent": 3,
      "text": "A variable and a value must be associated with a simple condition to make it a meaningful condition, using, respectively, the aggregations PolicyVariableInSimplePolicyCondition and PolicyValueInSimplePolicyCondition.",
      "ja": "変数および値は、それぞれ、集計のPolicyVariableInSimplePolicyConditionとPolicyValueInSimplePolicyConditionを使用して、その意味のある状態にするために単純な条件に関連付けされなければなりません。"
    },
    {
      "indent": 3,
      "text": "The class definition is as follows:",
      "ja": "次のようにクラス定義は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "NAME SimplePolicyCondition DERIVED FROM PolicyCondition ABSTRACT False PROPERTIES (none)",
      "ja": "PolicyCondition ABSTRACT偽PROPERTIES（なし）に由来する名称SimplePolicyCondition"
    },
    {
      "indent": 0,
      "text": "6.5. The Class \"CompoundPolicyCondition\"",
      "section_title": true,
      "ja": "6.5。クラス「CompoundPolicyCondition」"
    },
    {
      "indent": 3,
      "text": "This class represents a compound policy condition, formed by aggregation of simpler policy conditions.",
      "ja": "このクラスは、単純なポリシー条件の凝集によって形成される化合物のポリシー条件を表します。"
    },
    {
      "indent": 3,
      "text": "NAME CompoundPolicyCondition DESCRIPTION A subclass of PolicyCondition that introduces the ConditionListType property, used for assigning DNF / CNF semantics to subordinate policy conditions. DERIVED FROM PolicyCondition ABSTRACT FALSE PROPERTIES ConditionListType",
      "ja": "NAME CompoundPolicyCondition説明下位ポリシー条件にDNF / CNFセマンティクスを割り当てるために使用ConditionListType性を導入するPolicyConditionのサブクラス。 PolicyCondition ABSTRACT FALSEの施設から派生ConditionListType"
    },
    {
      "indent": 3,
      "text": "The ConditionListType property is used to specify whether the list of policy conditions associated with this compound policy condition is in disjunctive normal form (DNF) or conjunctive normal form (CNF). If this property is not present, the list type defaults to DNF. The property definition is as follows:",
      "ja": "ConditionListTypeプロパティは、この化合物のポリシー条件に関連付けられたポリシー条件のリストは、選言標準形（DNF）または連言標準形（CNF）であるか否かを指定するために使用されます。このプロパティが存在しない場合、DNFのリストタイプがデフォルトになります。次のようにプロパティの定義は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "NAME ConditionListType DESCRIPTION Indicates whether the list of policy conditions associated with this policy rule is in disjunctive normal form (DNF) or conjunctive normal form (CNF). SYNTAX uint16 VALUES DNF(1), CNF(2) DEFAULT VALUE DNF(1)",
      "ja": "NAME Con​​ditionListType説明このポリシールールに関連付けられているポリシー条件のリストは、選言標準形（DNF）または連言標準形（CNF）にあるかどうかを示します。 DNF（1）、CNF（2）デフォルト値DNF（1）の値uint16のSYNTAX"
    },
    {
      "indent": 0,
      "text": "6.6. The Class \"CompoundFilterCondition\"",
      "section_title": true,
      "ja": "6.6。クラス「CompoundFilterCondition」"
    },
    {
      "indent": 3,
      "text": "This subclass of CompoundPolicyCondition introduces one additional property, the boolean IsMirrored. This property turns on or off the \"flipping\" of corresponding source and destination fields in a filter specification.",
      "ja": "CompoundPolicyConditionのこのサブクラスは一つの追加のプロパティ、ブールIsMirroredを紹介します。このプロパティは、フィルタ仕様に対応するソース及び宛先フィールドの「反転」またはオフします。"
    },
    {
      "indent": 3,
      "text": "NAME CompoundFilterCondition DESCRIPTION A subclass of CompoundPolicyCondition that introduces the IsMirrored property. DERIVED FROM CompoundPolicyCondition ABSTRACT FALSE PROPERTIES IsMirrored",
      "ja": "NAME CompoundFilterCondition説明IsMirrored性を導入CompoundPolicyConditionのサブクラス。 CompoundPolicyCondition ABSTRACT FALSEの施設から派生IsMirrored"
    },
    {
      "indent": 3,
      "text": "The IsMirrored property indicates whether packets that \"mirror\" a compound filter condition should be treated as matching the filter. The property definition is as follows:",
      "ja": "IsMirroredプロパティは、「ミラー」は、化合物のフィルタ条件がフィルタに合致するものとして扱われるべきであることパケットか否かを示します。次のようにプロパティの定義は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "NAME IsMirrored DESCRIPTION Indicates whether packets that mirror the specified filter are to be treated as matching the filter. SYNTAX boolean DEFAULT VALUE FALSE",
      "ja": "NAME IsMirrored説明指定フィルタをミラーパケットがフィルタに一致するものとして扱われるべきであるかどうかを示します。 SYNTAXブールデフォルト値はFALSE"
    },
    {
      "indent": 0,
      "text": "6.7. The Class \"SimplePolicyAction\"",
      "section_title": true,
      "ja": "6.7。クラス「SimplePolicyAction」"
    },
    {
      "indent": 3,
      "text": "The SimplePolicyAction class models the elementary set operation. \"SET <variable> TO <value>\". The set operator MUST overwrite an old value of the variable.",
      "ja": "SimplePolicyActionクラスモデル基本セット操作。 \"<変数> SET TO <値>\"。集合演算子は、変数の古い値を上書きする必要があります。"
    },
    {
      "indent": 3,
      "text": "Two aggregations are used in order to create the pair <variable> <value>. The aggregation PolicyVariableInSimplePolicyAction relates a SimplePolicyAction to a single variable instance. Similarly, the aggregation PolicyValueInSimplePolicyAction relates a SimplePolicyAction to a single value instance. Both aggregations are defined in this document.",
      "ja": "二つの集計は、<変数> <値>のペアを作成するために使用されています。凝集PolicyVariableInSimplePolicyActionは、単一の変数インスタンスにSimplePolicyActionに関する。同様に、凝集PolicyValueInSimplePolicyActionは、単一の値インスタンスにSimplePolicyActionに関する。どちらの集計は、この文書で定義されています。"
    },
    {
      "indent": 3,
      "text": "NAME SimplePolicyAction DESCRIPTION A subclass of PolicyAction that introduces the notion of \"SET variable TO value\". DERIVED FROM PolicyAction ABSTRACT FALSE PROPERTIES (none)",
      "ja": "NAME SimplePolicyActionの説明は「値に設定変数」の概念を導入PolicyActionのサブクラス。 PolicyAction ABSTRACT FALSE PROPERTIES（なし）に由来します"
    },
    {
      "indent": 0,
      "text": "6.8. The Class \"CompoundPolicyAction\"",
      "section_title": true,
      "ja": "6.8。クラス「CompoundPolicyAction」"
    },
    {
      "indent": 3,
      "text": "The CompoundPolicyAction class is used to represent an expression consisting of an ordered sequence of action terms. Each action term is represented as a subclass of the PolicyAction class, defined in [PCIM]. Compound actions are constructed by associating dependent action terms together using the PolicyActionInPolicyAction aggregation.",
      "ja": "CompoundPolicyActionクラスは、アクション用語の順序付けられた配列からなる式を表すために使用されます。各アクション用語は[PCIM]で定義されたPolicyActionクラスのサブクラスとして表されています。化合物のアクションが一緒に依存アクションの条件を関連付けるPolicyActionInPolicyAction凝集を用いて構成されています。"
    },
    {
      "indent": 3,
      "text": "The class definition is as follows:",
      "ja": "次のようにクラス定義は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "NAME CompoundPolicyAction DESCRIPTION A class for representing sequenced action terms. Each action term is defined to be a subclass of the PolicyAction class. DERIVED FROM PolicyAction ABSTRACT FALSE PROPERTIES SequencedActions ExecutionStrategy",
      "ja": "NAME CompoundPolicyAction説明配列決定動作条件を表すクラス。各アクションの用語はPolicyActionクラスのサブクラスとして定義されています。 PolicyAction ABSTRACT FALSE PROPERTIES SequencedActions ExecutionStrategyから、派生"
    },
    {
      "indent": 3,
      "text": "This is a concrete class, and is therefore directly instantiable.",
      "ja": "これは具象クラスであるため、直接インスタンス化です。"
    },
    {
      "indent": 3,
      "text": "The Property SequencedActions is identical to the SequencedActions property defined in PCIM for the class PolicyRule.",
      "ja": "プロパティSequencedActionsは、クラスPolicyRuleのためのPCIMで定義されてSequencedActionsプロパティと同じです。"
    },
    {
      "indent": 3,
      "text": "The property ExecutionStrategy defines the execution strategy to be used upon the sequenced actions associated with this compound action. (An equivalent ExecutionStrategy property is also defined for the PolicyRule class, to provide the same indication for the sequenced actions associated with a PolicyRule.) This document defines three execution strategies:",
      "ja": "プロパティExecutionStrategyは、この化合物の作用に関連した配列決定されたアクションの際に使用される実行計画を定義します。 （等価ExecutionStrategyプロパティものPolicyRuleに関連した配列決定されたアクションの同じ表示を提供するために、PolicyRuleのクラスのために定義されている。）このドキュメントでは、3つの実行戦略を定義します。"
    },
    {
      "indent": 3,
      "text": "Do Until Success - execute actions according to predefined order, until successful execution of a single sub-action. Do All - execute ALL actions which are part of the modeled set, according to their predefined order. Continue doing this, even if one or more of the sub-actions fails. Do Until Failure - execute actions according to predefined order, until the first failure in execution of a single sub-action.",
      "ja": "成功までやる - 単一のサブアクションの実行が成功するまで、事前に定義された順序に従ってアクションを実行します。全ください - 彼らの事前に定義された順序に従って、モデル化されたセットの一部であるすべてのアクションを実行します。サブアクションの1つ以上が故障した場合でも、これをやって続行します。破壊するまで行います - 単一のサブアクションの実行中に最初の失敗まで、事前に定義された順序に従ってアクションを実行します。"
    },
    {
      "indent": 3,
      "text": "Since a CompoundPolicyAction may itself be aggregated either by a PolicyRule or by another CompoundPolicyAction, its success or failure will be an input to the aggregating entity's execution strategy. Consequently, the following rules are specified, for determining whether a CompoundPolicyAction succeeds or fails:",
      "ja": "CompoundPolicyAction自体がPolicyRuleのまたは別のCompoundPolicyActionいずれかによって集約することができるので、その成功または失敗は、集約エンティティの実行戦略に入力されます。したがって、以下のルールがCompoundPolicyActionが成功したか失敗したかどうかを決定するために、指定されています。"
    },
    {
      "indent": 3,
      "text": "If the CompoundPolicyAction's ExecutionStrategy is Do Until Success, then:",
      "ja": "CompoundPolicyActionのExecutionStrategyが成功するまでは実行している場合は、次のようになります。"
    },
    {
      "indent": 6,
      "text": "o If one component action succeeds, then the CompoundPolicyAction succeeds. o If all component actions fail, then the CompoundPolicyAction fails.",
      "ja": "一成分アクションが成功した場合は、O、そしてCompoundPolicyActionは成功します。すべてのコンポーネントのアクションが失敗した場合は、O、そしてCompoundPolicyActionは失敗します。"
    },
    {
      "indent": 3,
      "text": "If the CompoundPolicyAction's ExecutionStrategy is Do All, then:",
      "ja": "CompoundPolicyActionのExecutionStrategyがある場合は、その後、すべての操作を行います。"
    },
    {
      "indent": 6,
      "text": "o If all component actions succeed, then the CompoundPolicyAction succeeds. o If at least one component action fails, then the CompoundPolicyAction fails.",
      "ja": "すべてのコンポーネントのアクションが成功した場合、O、そしてCompoundPolicyActionは成功します。少なくとも一つの成分アクションが失敗した場合は、O、そしてCompoundPolicyActionは失敗します。"
    },
    {
      "indent": 3,
      "text": "If the CompoundPolicyAction's ExecutionStrategy is Do Until Failure, then:",
      "ja": "CompoundPolicyActionのExecutionStrategyが破壊するまで実行している場合は、次のようになります。"
    },
    {
      "indent": 6,
      "text": "o If all component actions succeed, then the CompoundPolicyAction succeeds. o If at least one component action fails, then the CompoundPolicyAction fails.",
      "ja": "すべてのコンポーネントのアクションが成功した場合、O、そしてCompoundPolicyActionは成功します。少なくとも一つの成分アクションが失敗した場合は、O、そしてCompoundPolicyActionは失敗します。"
    },
    {
      "indent": 3,
      "text": "The definition of the ExecutionStrategy property is as follows:",
      "ja": "次のようにExecutionStrategyプロパティの定義は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "NAME ExecutionStrategy DESCRIPTION An enumeration indicating how to interpret the action ordering for the actions aggregated by this CompoundPolicyAction. SYNTAX uint16 (ENUM, {1=Do Until Success, 2=Do All, 3=Do Until Failure} ) DEFAULT VALUE Do All (2)",
      "ja": "ExecutionStrategy説明にこのCompoundPolicyActionによって集約アクションのアクション注文をどのように解釈するかを示す列挙に名前を付けます。構文uint16のデフォルト値（ENUM、{1が成功するまで、2 =すべての操作を行います= 3が破壊するまで行い=}）ないすべての（2）"
    },
    {
      "indent": 0,
      "text": "6.9. The Abstract Class \"PolicyVariable\"",
      "section_title": true,
      "ja": "6.9。抽象クラス「PolicyVariable」"
    },
    {
      "indent": 3,
      "text": "Variables are used for building individual conditions. The variable specifies the property of a flow or an event that should be matched when evaluating the condition. However, not every combination of a variable and a value creates a meaningful condition. For example, a source IP address variable can not be matched against a value that specifies a port number. A given variable selects the set of matchable value types.",
      "ja": "変数は、個々の条件を構築するために使用されています。変数は、流れや状態を評価するときに一致させる必要があるイベントのプロパティを指定します。しかし、いない変数と値のすべての組み合わせは、意味のある条件を作成します。例えば、送信元IPアドレス変数は、ポート番号を指定する値と照合することができません。与えられた変数は、マッチング可能値型のセットを選択します。"
    },
    {
      "indent": 3,
      "text": "A variable can have constraints that limit the set of values within a particular value type that can be matched against it in a condition. For example, a source-port variable limits the set of values to represent integers to the range of 0-65535. Integers outside this range cannot be matched to the source-port variable, even though they are of the correct data type. Constraints for a given variable are indicated through the ExpectedPolicyValuesForVariable association.",
      "ja": "可変条件で照合することができる特定の値型内の値のセットを制限する制約を有することができます。例えば、ソースポート変数は、0〜65535の範囲の整数を表す値の集合を制限します。この範囲外の整数は、それらが正しいデータ型であっても、送信元ポート変数に一致させることができません。所与の変数の制約がExpectedPolicyValuesForVariable会合を通して示されています。"
    },
    {
      "indent": 3,
      "text": "The PolicyVariable is an abstract class. Implicit and explicit context variable classes are defined as sub classes of the PolicyVariable class. A set of implicit variables is defined in this document as well.",
      "ja": "PolicyVariableは抽象クラスです。暗黙的および明示的なコンテキスト変数のクラスはPolicyVariableクラスのサブクラスとして定義されています。暗黙の変数のセットも、この文書で定義されています。"
    },
    {
      "indent": 3,
      "text": "The class definition is as follows:",
      "ja": "次のようにクラス定義は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "NAME PolicyVariable DERIVED FROM Policy ABSTRACT TRUE PROPERTIES (none)",
      "ja": "ポリシーABSTRACT TRUE PROPERTIES（なし）に由来する名称PolicyVariable"
    },
    {
      "indent": 0,
      "text": "6.10. The Class \"PolicyExplicitVariable\"",
      "section_title": true,
      "ja": "6.10。クラス「PolicyExplicitVariable」"
    },
    {
      "indent": 3,
      "text": "Explicitly defined policy variables are evaluated within the context of the CIM Schema and its modeling constructs. The PolicyExplicitVariable class indicates the exact model property to be evaluated or manipulated. See Section 5.8.6 for a complete discussion of what happens when the values of the ModelClass and",
      "ja": "明示的に定義されたポリシー変数は、CIMスキーマとそのモデリング構造のコンテキスト内で評価されます。 PolicyExplicitVariableクラスを評価または操作する正確なモデルプロパティを示しています。何が起こるかの完全な議論については、セクション5.8.6を参照してくださいするときModelClassの値と、"
    },
    {
      "indent": 3,
      "text": "ModelProperty properties in an instance of this class do not correspond to the characteristics of the model construct being evaluated or updated.",
      "ja": "このクラスのインスタンスでModelProperty特性を評価又は更新されたモデル構築物の特性に対応していません。"
    },
    {
      "indent": 3,
      "text": "The class definition is as follows:",
      "ja": "次のようにクラス定義は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "NAME PolicyExplicitVariable DERIVED FROM PolicyVariable ABSTRACT False PROPERTIES ModelClass, ModelProperty",
      "ja": "PolicyVariable ABSTRACT偽PROPERTIES ModelClass、ModelPropertyから、派生NAME PolicyExplicitVariable"
    },
    {
      "indent": 0,
      "text": "6.10.1. The Single-Valued Property \"ModelClass\"",
      "section_title": true,
      "ja": "6.10.1。単一値プロパティ「ModelClass」"
    },
    {
      "indent": 3,
      "text": "This property is a string specifying the class name whose property is evaluated or set as a PolicyVariable.",
      "ja": "このプロパティは、プロパティを評価またはPolicyVariableとして設定されているクラス名を指定する文字列です。"
    },
    {
      "indent": 3,
      "text": "The property is defined as follows:",
      "ja": "次のようにプロパティが定義されています。"
    },
    {
      "indent": 3,
      "text": "NAME ModelClass SYNTAX String",
      "ja": "ModelClass SYNTAX文字列NAME"
    },
    {
      "indent": 0,
      "text": "6.10.2. The Single-Valued Property ModelProperty",
      "section_title": true,
      "ja": "6.10.2。単一値プロパティModelProperty"
    },
    {
      "indent": 3,
      "text": "This property is a string specifying the property name, within the ModelClass, which is evaluated or set as a PolicyVariable. The property is defined as follows:",
      "ja": "このプロパティは、評価やPolicyVariableとして設定されているModelClass、内のプロパティ名を指定する文字列です。次のようにプロパティが定義されています。"
    },
    {
      "indent": 3,
      "text": "NAME ModelProperty SYNTAX String",
      "ja": "ModelProperty SYNTAX文字列NAME"
    },
    {
      "indent": 0,
      "text": "6.11. The Abstract Class \"PolicyImplicitVariable\"",
      "section_title": true,
      "ja": "6.11。抽象クラス「PolicyImplicitVariable」"
    },
    {
      "indent": 3,
      "text": "Implicitly defined policy variables are evaluated outside of the context of the CIM Schema and its modeling constructs. Subclasses specify the data type and semantics of the PolicyVariables.",
      "ja": "暗黙的に定義されたポリシー変数は、CIMスキーマとそのモデリング構造のコンテキストの外側で評価されます。サブクラスは、政策変数のデータ型とセマンティクスを指定します。"
    },
    {
      "indent": 3,
      "text": "Interpretation and evaluation of a PolicyImplicitVariable can vary, depending on the particular context in which it is used. For example, a \"SourceIP\" address may denote the source address field of an IP packet header, or the sender address delivered by an RSVP PATH message.",
      "ja": "PolicyImplicitVariableの解釈及び評価は、それが使用される特定の文脈に応じて、変えることができます。例えば、「SOURCEIP」アドレスは、IPパケットのヘッダのソースアドレスフィールド、またはRSVP PATHメッセージにより送達送信元アドレスを示してもよいです。"
    },
    {
      "indent": 3,
      "text": "The class definition is as follows:",
      "ja": "次のようにクラス定義は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "NAME PolicyImplicitVariable DERIVED FROM PolicyVariable ABSTRACT True PROPERTIES ValueTypes[ ]",
      "ja": "PolicyVariable ABSTRACT真PROPERTIES値型から派生してNAME PolicyImplicitVariable []"
    },
    {
      "indent": 0,
      "text": "6.11.1. The Multi-Valued Property \"ValueTypes\"",
      "section_title": true,
      "ja": "6.11.1。複数値プロパティの「値型」"
    },
    {
      "indent": 3,
      "text": "This property is a set of strings specifying an unordered list of possible value/data types that can be used in simple conditions and actions, with this variable. The value types are specified by their class names (subclasses of PolicyValue such as PolicyStringValue). The list of class names enables an application to search on a specific name, as well as to ensure that the data type of the variable is of the correct type.",
      "ja": "このプロパティは、この変数を使用して、簡単な条件とアクションで使用できる可能値/データ型の順不同のリストを指定する文字列のセットです。値型は、そのクラス名（例えばPolicyStringValueとしてPolicyValueのサブクラス）によって指定されます。クラス名のリストは、特定の名前で検索するだけでなく、変数のデータ型が正しい型であることを保証するためにアプリケーションを可能にします。"
    },
    {
      "indent": 3,
      "text": "The list of default ValueTypes for each subclass of PolicyImplicitVariable is specified within that variable's definition.",
      "ja": "PolicyImplicitVariableの各サブクラスのデフォルト値型のリストは、その変数の定義内に指定されています。"
    },
    {
      "indent": 3,
      "text": "The property is defined as follows:",
      "ja": "次のようにプロパティが定義されています。"
    },
    {
      "indent": 3,
      "text": "NAME ValueTypes SYNTAX String",
      "ja": "値型SYNTAX文字列NAME"
    },
    {
      "indent": 0,
      "text": "6.12. Subclasses of \"PolicyImplicitVariable\" Specified in PCIMe",
      "section_title": true,
      "ja": "6.12。 PCIMeに指定された「PolicyImplicitVariable」のサブクラス"
    },
    {
      "indent": 3,
      "text": "The following subclasses of PolicyImplicitVariable are defined in PCIMe.",
      "ja": "PolicyImplicitVariableの以下のサブクラスはPCIMeで定義されています。"
    },
    {
      "indent": 0,
      "text": "6.12.1. The Class \"PolicySourceIPv4Variable\"",
      "section_title": true,
      "ja": "6.12.1。クラス「PolicySourceIPv4Variable」"
    },
    {
      "indent": 3,
      "text": "NAME PolicySourceIPv4Variable DESCRIPTION The source IPv4 address. of the outermost IP packet header. \"Outermost\" here refers to the IP packet as it flows on the wire, before any headers have been stripped from it.",
      "ja": "NAME PolicySourceIPv4Variable説明元IPv4アドレス。最も外側のIPパケットヘッダの。それは、ワイヤ上を流れるよう任意のヘッダがそれから除去されている前に、「最も外側」はここで、IPパケットを指します。"
    },
    {
      "indent": 20,
      "text": "ALLOWED VALUE TYPES:\n  - PolicyIPv4AddrValue",
      "raw": true
    },
    {
      "indent": 3,
      "text": "DERIVED FROM PolicyImplicitVariable ABSTRACT FALSE PROPERTIES (none)",
      "ja": "PolicyImplicitVariable ABSTRACT FALSE PROPERTIES（なし）に由来します"
    },
    {
      "indent": 0,
      "text": "6.12.2. The Class \"PolicySourceIPv6Variable\"",
      "section_title": true,
      "ja": "6.12.2。クラス「PolicySourceIPv6Variable」"
    },
    {
      "indent": 3,
      "text": "NAME PolicySourceIPv6Variable DESCRIPTION The source IPv6 address of the outermost IP packet header. \"Outermost\" here refers to the IP packet as it flows on the wire, before any headers have been stripped from it.",
      "ja": "NAME PolicySourceIPv6Variable説明最外側IPパケットヘッダの送信元IPv6アドレス。それは、ワイヤ上を流れるよう任意のヘッダがそれから除去されている前に、「最も外側」はここで、IPパケットを指します。"
    },
    {
      "indent": 20,
      "text": "ALLOWED VALUE TYPES:\n  - PolicyIPv6AddrValue",
      "raw": true
    },
    {
      "indent": 3,
      "text": "DERIVED FROM PolicyImplicitVariable ABSTRACT FALSE PROPERTIES (none)",
      "ja": "PolicyImplicitVariable ABSTRACT FALSE PROPERTIES（なし）に由来します"
    },
    {
      "indent": 0,
      "text": "6.12.3. The Class \"PolicyDestinationIPv4Variable\"",
      "section_title": true,
      "ja": "6.12.3。クラス「PolicyDestinationIPv4Variable」"
    },
    {
      "indent": 3,
      "text": "NAME PolicyDestinationIPv4Variable DESCRIPTION The destination IPv4 address of the outermost IP packet header. \"Outermost\" here refers to the IP packet as it flows on the wire, before any headers have been stripped from it.",
      "ja": "NAME PolicyDestinationIPv4Variable説明最外側IPパケットのヘッダの宛先IPv4アドレス。それは、ワイヤ上を流れるよう任意のヘッダがそれから除去されている前に、「最も外側」はここで、IPパケットを指します。"
    },
    {
      "indent": 20,
      "text": "ALLOWED VALUE TYPES:\n  - PolicyIPv4AddrValue",
      "raw": true
    },
    {
      "indent": 3,
      "text": "DERIVED FROM PolicyImplicitVariable ABSTRACT FALSE PROPERTIES (none)",
      "ja": "PolicyImplicitVariable ABSTRACT FALSE PROPERTIES（なし）に由来します"
    },
    {
      "indent": 0,
      "text": "6.12.4. The Class \"PolicyDestinationIPv6Variable\"",
      "section_title": true,
      "ja": "6.12.4。クラス「PolicyDestinationIPv6Variable」"
    },
    {
      "indent": 3,
      "text": "NAME PolicyDestinationIPv6Variable DESCRIPTION The destination IPv6 address of the outermost IP packet header. \"Outermost\" here refers to the IP packet as it flows on the wire, before any headers have been stripped from it.",
      "ja": "NAME PolicyDestinationIPv6Variable説明最外側IPパケットのヘッダの宛先IPv6アドレス。それは、ワイヤ上を流れるよう任意のヘッダがそれから除去されている前に、「最も外側」はここで、IPパケットを指します。"
    },
    {
      "indent": 20,
      "text": "ALLOWED VALUE TYPES:\n- PolicyIPv6AddrValue",
      "raw": true
    },
    {
      "indent": 3,
      "text": "DERIVED FROM PolicyImplicitVariable ABSTRACT FALSE PROPERTIES (none)",
      "ja": "PolicyImplicitVariable ABSTRACT FALSE PROPERTIES（なし）に由来します"
    },
    {
      "indent": 0,
      "text": "6.12.5. The Class \"PolicySourcePortVariable\"",
      "section_title": true,
      "ja": "6.12.5。クラス「PolicySourcePortVariable」"
    },
    {
      "indent": 3,
      "text": "NAME PolicySourcePortVariable DESCRIPTION Ports are defined as the abstraction that transport protocols use to distinguish among multiple destinations within a given host computer. For TCP and UDP flows, the PolicySourcePortVariable is logically bound to the source port field of the outermost UDP or TCP packet header. \"Outermost\" here refers to the IP packet as it flows on the wire, before any headers have been stripped from it. ALLOWED VALUE TYPES: - PolicyIntegerValue (0..65535)",
      "ja": "NAME PolicySourcePortVariable説明ポートは、トランスポートプロトコルは、所与のホストコンピュータ内に複数の宛先を区別するために使用することを抽象化として定義されます。 TCPおよびUDPフローについて、PolicySourcePortVariableは、論理的に、最も外側のUDPまたはTCPパケットヘッダの送信元ポートフィールドにバインドされています。それは、ワイヤ上を流れるよう任意のヘッダがそれから除去されている前に、「最も外側」はここで、IPパケットを指します。許容値の種類： -  PolicyIntegerValue（0 65535）"
    },
    {
      "indent": 3,
      "text": "DERIVED FROM PolicyImplicitVariable ABSTRACT FALSE PROPERTIES (none)",
      "ja": "PolicyImplicitVariable ABSTRACT FALSE PROPERTIES（なし）に由来します"
    },
    {
      "indent": 0,
      "text": "6.12.6. The Class \"PolicyDestinationPortVariable\"",
      "section_title": true,
      "ja": "6.12.6。クラス「PolicyDestinationPortVariable」"
    },
    {
      "indent": 3,
      "text": "NAME PolicyDestinationPortVariable DESCRIPTION Ports are defined as the abstraction that transport protocols use to distinguish among multiple destinations within a given host computer. For TCP and UDP flows, the PolicyDestinationPortVariable is logically bound to the destination port field of the outermost UDP or TCP packet header. \"Outermost\" here refers to the IP packet as it flows on the wire, before any headers have been stripped from it.",
      "ja": "NAME PolicyDestinationPortVariable説明ポートは、トランスポートプロトコルは、所与のホストコンピュータ内に複数の宛先を区別するために使用することを抽象化として定義されます。 TCPおよびUDPフローについて、PolicyDestinationPortVariableは、論理的に、最も外側のUDPまたはTCPパケットヘッダの宛先ポートフィールドにバインドされています。それは、ワイヤ上を流れるよう任意のヘッダがそれから除去されている前に、「最も外側」はここで、IPパケットを指します。"
    },
    {
      "indent": 19,
      "text": "ALLOWED VALUE TYPES:\n   - PolicyIntegerValue (0..65535)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "DERIVED FROM PolicyImplicitVariable ABSTRACT FALSE PROPERTIES (none)",
      "ja": "PolicyImplicitVariable ABSTRACT FALSE PROPERTIES（なし）に由来します"
    },
    {
      "indent": 0,
      "text": "6.12.7. The Class \"PolicyIPProtocolVariable\"",
      "section_title": true,
      "ja": "6.12.7。クラス「PolicyIPProtocolVariable」"
    },
    {
      "indent": 3,
      "text": "NAME PolicyIPProtocolVariable DESCRIPTION The IP protocol number.",
      "ja": "NAME PolicyIPProtocolVariable説明IPプロトコル番号。"
    },
    {
      "indent": 20,
      "text": "ALLOWED VALUE TYPES:\n  - PolicyIntegerValue (0..255)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "DERIVED FROM PolicyImplicitVariable ABSTRACT FALSE PROPERTIES (none)",
      "ja": "PolicyImplicitVariable ABSTRACT FALSE PROPERTIES（なし）に由来します"
    },
    {
      "indent": 0,
      "text": "6.12.8. The Class \"PolicyIPVersionVariable\"",
      "section_title": true,
      "ja": "6.12.8。クラス「PolicyIPVersionVariable」"
    },
    {
      "indent": 3,
      "text": "NAME PolicyIPVersionVariable DESCRIPTION The IP version number. The well-known values are 4 and 6.",
      "ja": "PolicyIPVersionVariable DESCRIPTIONにIPのバージョン番号と名前を付けます。よく知られている値が4と6です。"
    },
    {
      "indent": 20,
      "text": "ALLOWED VALUE TYPES:\n  - PolicyIntegerValue (0..15)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "DERIVED FROM PolicyImplicitVariable ABSTRACT FALSE PROPERTIES (none)",
      "ja": "PolicyImplicitVariable ABSTRACT FALSE PROPERTIES（なし）に由来します"
    },
    {
      "indent": 0,
      "text": "6.12.9. The Class \"PolicyIPToSVariable\"",
      "section_title": true,
      "ja": "6.12.9。クラス「PolicyIPToSVariable」"
    },
    {
      "indent": 3,
      "text": "NAME PolicyIPToSVariable DESCRIPTION The IP TOS octet.",
      "ja": "PolicyIPToSVariable DESCRIPTIONにIP TOSオクテットに名前を付けます。"
    },
    {
      "indent": 20,
      "text": "ALLOWED VALUE TYPES:\n  - PolicyIntegerValue (0..255)\n  - PolicyBitStringValue (8 bits)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "DERIVED FROM PolicyImplicitVariable ABSTRACT FALSE PROPERTIES (none)",
      "ja": "PolicyImplicitVariable ABSTRACT FALSE PROPERTIES（なし）に由来します"
    },
    {
      "indent": 0,
      "text": "6.12.10. The Class \"PolicyDSCPVariable\"",
      "section_title": true,
      "ja": "6.12.10。クラス「PolicyDSCPVariable」"
    },
    {
      "indent": 3,
      "text": "NAME PolicyDSCPVariable DESCRIPTION The 6 bit Differentiated Service Code Point.",
      "ja": "NAME PolicyDSCPVariable説明6ビットの差別化されたサービスコードポイント。"
    },
    {
      "indent": 20,
      "text": "ALLOWED VALUE TYPES:\n  - PolicyIntegerValue (0..63)\n  - PolicyBitStringValue (6 bits)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "DERIVED FROM PolicyImplicitVariable ABSTRACT FALSE PROPERTIES (none)",
      "ja": "PolicyImplicitVariable ABSTRACT FALSE PROPERTIES（なし）に由来します"
    },
    {
      "indent": 0,
      "text": "6.12.11. The Class \"PolicyFlowIdVariable\"",
      "section_title": true,
      "ja": "6.12.11。クラス「PolicyFlowIdVariable」"
    },
    {
      "indent": 3,
      "text": "NAME PolicyFlowIdVariable DESCRIPTION The flow identifier of the outermost IPv6 packet header. \"Outermost\" here refers to the IP packet as it flows on the wire, before any headers have been stripped from it.",
      "ja": "NAME PolicyFlowIdVariable説明最外IPv6パケットヘッダのフロー識別子。それは、ワイヤ上を流れるよう任意のヘッダがそれから除去されている前に、「最も外側」はここで、IPパケットを指します。"
    },
    {
      "indent": 20,
      "text": "ALLOWED VALUE TYPES:\n  - PolicyIntegerValue (0..1048575\n  - PolicyBitStringValue (20 bits)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "DERIVED FROM PolicyImplicitVariable ABSTRACT FALSE PROPERTIES (none)",
      "ja": "PolicyImplicitVariable ABSTRACT FALSE PROPERTIES（なし）に由来します"
    },
    {
      "indent": 0,
      "text": "6.12.12. The Class \"PolicySourceMACVariable\"",
      "section_title": true,
      "ja": "6.12.12。クラス「PolicySourceMACVariable」"
    },
    {
      "indent": 3,
      "text": "NAME PolicySourceMACVariable DESCRIPTION The source MAC address.",
      "ja": "PolicySourceMACVariable DESCRIPTIONに送信元MACアドレスと名前を付けます。"
    },
    {
      "indent": 20,
      "text": "ALLOWED VALUE TYPES:\n  - PolicyMACAddrValue",
      "raw": true
    },
    {
      "indent": 3,
      "text": "DERIVED FROM PolicyImplicitVariable ABSTRACT FALSE PROPERTIES (none)",
      "ja": "PolicyImplicitVariable ABSTRACT FALSE PROPERTIES（なし）に由来します"
    },
    {
      "indent": 0,
      "text": "6.12.13. The Class \"PolicyDestinationMACVariable\"",
      "section_title": true,
      "ja": "6.12.13。クラス「PolicyDestinationMACVariable」"
    },
    {
      "indent": 3,
      "text": "NAME PolicyDestinationMACVariable DESCRIPTION The destination MAC address.",
      "ja": "PolicyDestinationMACVariable DESCRIPTIONに、宛先MACアドレスと名前を付けます。"
    },
    {
      "indent": 20,
      "text": "ALLOWED VALUE TYPES:\n  - PolicyMACAddrValue",
      "raw": true
    },
    {
      "indent": 3,
      "text": "DERIVED FROM PolicyImplicitVariable ABSTRACT FALSE PROPERTIES (none)",
      "ja": "PolicyImplicitVariable ABSTRACT FALSE PROPERTIES（なし）に由来します"
    },
    {
      "indent": 0,
      "text": "6.12.14. The Class \"PolicyVLANVariable\"",
      "section_title": true,
      "ja": "6.12.14。クラス「PolicyVLANVariable」"
    },
    {
      "indent": 3,
      "text": "NAME PolicyVLANVariable DESCRIPTION The virtual Bridged Local Area Network Identifier, a 12-bit field as defined in the IEEE 802.1q standard.",
      "ja": "NAME PolicyVLANVariable説明仮想ブリッジローカルエリアネットワーク識別子、IEEE 802.1Q規格で定義されている12ビットのフィールド。"
    },
    {
      "indent": 20,
      "text": "ALLOWED VALUE TYPES:\n  - PolicyIntegerValue (0..4095)\n  - PolicyBitStringValue (12 bits)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "DERIVED FROM PolicyImplicitVariable ABSTRACT FALSE PROPERTIES (none)",
      "ja": "PolicyImplicitVariable ABSTRACT FALSE PROPERTIES（なし）に由来します"
    },
    {
      "indent": 0,
      "text": "6.12.15. The Class \"PolicyCoSVariable\"",
      "section_title": true,
      "ja": "6.12.15。クラス「PolicyCoSVariable」"
    },
    {
      "indent": 3,
      "text": "NAME PolicyCoSVariable DESCRIPTION Class of Service, a 3-bit field, used in the layer 2 header to select the forwarding treatment. Bound to the IEEE 802.1q user-priority field.",
      "ja": "サービスのPolicyCoSVariable説明クラス名、レイヤ2ヘッダに使用される3ビットのフィールドは、転送処理を選択します。 IEEE 802.1Qユーザー優先順位フィールドにバインドされました。"
    },
    {
      "indent": 20,
      "text": "ALLOWED VALUE TYPES:\n  - PolicyIntegerValue (0..7)\n  - PolicyBitStringValue (3 bits)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "DERIVED FROM PolicyImplicitVariable ABSTRACT FALSE PROPERTIES (none)",
      "ja": "PolicyImplicitVariable ABSTRACT FALSE PROPERTIES（なし）に由来します"
    },
    {
      "indent": 0,
      "text": "6.12.16. The Class \"PolicyEthertypeVariable\"",
      "section_title": true,
      "ja": "6.12.16。クラス「PolicyEthertypeVariable」"
    },
    {
      "indent": 3,
      "text": "NAME PolicyEthertypeVariable DESCRIPTION The Ethertype protocol number of Ethernet frames.",
      "ja": "NAME PolicyEthertypeVariable説明イーサネットフレームのイーサタイプのプロトコル番号。"
    },
    {
      "indent": 20,
      "text": "ALLOWED VALUE TYPES:\n  - PolicyIntegerValue (0..65535)\n  - PolicyBitStringValue (16 bits)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "DERIVED FROM PolicyImplicitVariable ABSTRACT FALSE PROPERTIES (none)",
      "ja": "PolicyImplicitVariable ABSTRACT FALSE PROPERTIES（なし）に由来します"
    },
    {
      "indent": 0,
      "text": "6.12.17. The Class \"PolicySourceSAPVariable\"",
      "section_title": true,
      "ja": "6.12.17。クラス「PolicySourceSAPVariable」"
    },
    {
      "indent": 3,
      "text": "NAME PolicySourceSAPVariable DESCRIPTION The Source Service Access Point (SAP) number of the IEEE 802.2 LLC header.",
      "ja": "NAME PolicySourceSAPVariable説明IEEE 802.2 LLCヘッダの送信元サービスアクセスポイント（SAP）の数。"
    },
    {
      "indent": 20,
      "text": "ALLOWED VALUE TYPES:\n  - PolicyIntegerValue (0..255)\n  - PolicyBitStringValue (8 bits)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "DERIVED FROM PolicyImplicitVariable ABSTRACT FALSE PROPERTIES (none)",
      "ja": "PolicyImplicitVariable ABSTRACT FALSE PROPERTIES（なし）に由来します"
    },
    {
      "indent": 0,
      "text": "6.12.18. The Class \"PolicyDestinationSAPVariable\"",
      "section_title": true,
      "ja": "6.12.18。クラス「PolicyDestinationSAPVariable」"
    },
    {
      "indent": 3,
      "text": "NAME PolicyDestinationSAPVariable DESCRIPTION The Destination Service Access Point (SAP) number of the IEEE 802.2 LLC header.",
      "ja": "NAME PolicyDestinationSAPVariable DESCRIPTION IEEE 802.2 LLCヘッダの宛先サービス・アクセス・ポイント（SAP）の数。"
    },
    {
      "indent": 20,
      "text": "ALLOWED VALUE TYPES:\n  - PolicyIntegerValue (0..255)\n  - PolicyBitStringValue (8 bits)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "DERIVED FROM PolicyImplicitVariable ABSTRACT FALSE PROPERTIES (none)",
      "ja": "PolicyImplicitVariable ABSTRACT FALSE PROPERTIES（なし）に由来します"
    },
    {
      "indent": 0,
      "text": "6.12.19. The Class \"PolicySNAPOUIVariable\"",
      "section_title": true,
      "ja": "6.12.19。クラス「PolicySNAPOUIVariable」"
    },
    {
      "indent": 3,
      "text": "NAME PolicySNAPOUIVariable DESCRIPTION The value of the first three octets of the Sub-Network Access Protocol (SNAP) Protocol Identifier field for 802.2 SNAP encapsulation, containing an Organizationally Unique Identifier (OUI). The value 00-00-00 indicates the encapsulation of Ethernet frames (RFC 1042). OUI value 00-00-F8 indicates the special encapsulation of Ethernet frames by certain types of bridges (IEEE 802.1H). Other values are supported, but are not further defined here. These OUI values are to be interpreted according to the endian-notation conventions of IEEE 802. For either of the two Ethernet encapsulations, the remainder of the Protocol Identifier field is represented by the PolicySNAPTypeVariable.",
      "ja": "NAME PolicySNAPOUIVariable説明組織固有識別子（OUI）を含有する802.2 SNAPカプセル化のためのサブネットワークアクセスプロトコル（SNAP）プロトコル識別子フィールドの最初の3つのオクテットの値が、。値00-00-00は、イーサネットフレーム（RFC 1042）のカプセル化を示しています。 OUI値00-00-F8は、ブリッジの特定のタイプ（IEEE 802.1H）によってイーサネットフレームの特殊なカプセル化を示しています。他の値はサポートされていますが、ここでさらに定義されていません。これらOUI値は、プロトコル識別子フィールドの残りはPolicySNAPTypeVariableで表され、2つのイーサネットカプセル化のいずれかのIEEE 802のエンディアン表記規則に従って解釈されるべきです。"
    },
    {
      "indent": 20,
      "text": "ALLOWED VALUE TYPES:\n- PolicyIntegerValue (0..16777215)\n- PolicyBitStringValue (24 bits)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "DERIVED FROM PolicyImplicitVariable ABSTRACT FALSE PROPERTIES (none)",
      "ja": "PolicyImplicitVariable ABSTRACT FALSE PROPERTIES（なし）に由来します"
    },
    {
      "indent": 0,
      "text": "6.12.20. The Class \"PolicySNAPTypeVariable\"",
      "section_title": true,
      "ja": "6.12.20。クラス「PolicySNAPTypeVariable」"
    },
    {
      "indent": 3,
      "text": "NAME PolicySNAPTypeVariable DESCRIPTION The value of the 4th and 5th octets of the Sub-Network Access Protocol (SNAP) Protocol Identifier field for IEEE 802 SNAP encapsulation when the PolicySNAPOUIVariable indicates one of the two Encapsulated Ethernet frame formats. This value is undefined for other values of PolicySNAPOUIVariable.",
      "ja": "NAME PolicySNAPTypeVariable DESCRIPTION第4の値と、IEEE 802 SNAPカプセル化のためのサブネットワークアクセスプロトコル（SNAP）の5オクテットプロトコル識別子フィールドPolicySNAPOUIVariableは、2つのカプセル化イーサネット・フレーム・フォーマットのいずれかを示しています。この値は、PolicySNAPOUIVariableの他の値のために定義されていません。"
    },
    {
      "indent": 20,
      "text": "ALLOWED VALUE TYPES:\n  - PolicyIntegerValue (0..65535)\n  - PolicyBitStringValue (16 bits)",
      "raw": true
    },
    {
      "indent": 3,
      "text": "DERIVED FROM PolicyImplicitVariable ABSTRACT FALSE PROPERTIES (none)",
      "ja": "PolicyImplicitVariable ABSTRACT FALSE PROPERTIES（なし）に由来します"
    },
    {
      "indent": 0,
      "text": "6.12.21. The Class \"PolicyFlowDirectionVariable\"",
      "section_title": true,
      "ja": "6.12.21。クラス「PolicyFlowDirectionVariable」"
    },
    {
      "indent": 3,
      "text": "NAME PolicyFlowDirectionVariable DESCRIPTION The direction of a flow relative to a network element. Direction may be \"IN\" and/or \"OUT\".",
      "ja": "PolicyFlowDirectionVariable説明をネットワーク要素への流れの方向を名前。方向は「IN」および/または「OUT」であってもよいです。"
    },
    {
      "indent": 20,
      "text": "ALLOWED VALUE TYPES:\n  - PolicyStringValue ('IN\", \"OUT\")",
      "raw": true
    },
    {
      "indent": 3,
      "text": "DERIVED FROM PolicyImplicitVariable ABSTRACT FALSE PROPERTIES (none)",
      "ja": "PolicyImplicitVariable ABSTRACT FALSE PROPERTIES（なし）に由来します"
    },
    {
      "indent": 3,
      "text": "To match on both inbound and outbound flows, the associated PolicyStringValue object has two entries in its StringList property: \"IN\" and \"OUT\".",
      "ja": "「IN」と「OUT」：インバウンドとアウトバウンドの両方のフローに一致させるには、関連するPolicyStringValueオブジェクトは、そのSTRINGLISTプロパティに2つのエントリがあります。"
    },
    {
      "indent": 0,
      "text": "6.13. The Abstract Class \"PolicyValue\"",
      "section_title": true,
      "ja": "6.13。抽象クラス「PolicyValue」"
    },
    {
      "indent": 3,
      "text": "This is an abstract class that serves as the base class for all subclasses that are used to define value objects in the PCIMe. It is used for defining values and constants used in policy conditions. The class definition is as follows:",
      "ja": "これはPCIMeの値オブジェクトを定義するために使用されるすべてのサブクラスの基本クラスとして機能する抽象クラスです。これは、ポリシー条件で使用される値と定数を定義するために使用されます。次のようにクラス定義は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "NAME PolicyValue DERIVED FROM Policy ABSTRACT True PROPERTIES (none)",
      "ja": "ポリシーABSTRACT真PROPERTIES（なし）に由来する名称PolicyValue"
    },
    {
      "indent": 0,
      "text": "6.14. Subclasses of \"PolicyValue\" Specified in PCIMe",
      "section_title": true,
      "ja": "6.14。 PCIMeに指定された「PolicyValue」のサブクラス"
    },
    {
      "indent": 3,
      "text": "The following subsections contain the PolicyValue subclasses defined in PCIMe. Additional subclasses may be defined in models derived from PCIMe.",
      "ja": "以下のサブセクションでは、PCIMeで定義されたPolicyValueサブクラスが含まれています。追加のサブクラスはPCIMe由来のモデルで定義されていてもよいです。"
    },
    {
      "indent": 0,
      "text": "6.14.1. The Class \"PolicyIPv4AddrValue\"",
      "section_title": true,
      "ja": "6.14.1。クラス「PolicyIPv4AddrValue」"
    },
    {
      "indent": 3,
      "text": "This class is used to provide a list of IPv4Addresses, hostnames and address range values to be matched against in a policy condition. The class definition is as follows:",
      "ja": "このクラスは、ポリシー条件で合致させるIPv4Addresses、ホスト名とアドレス範囲の値のリストを提供するために使用されます。次のようにクラス定義は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "NAME PolicyIPv4AddrValue DERIVED FROM PolicyValue ABSTRACT False PROPERTIES IPv4AddrList[ ]",
      "ja": "PolicyValue ABSTRACT偽の施設から派生NAME PolicyIPv4AddrValue IPv4AddrList []"
    },
    {
      "indent": 3,
      "text": "The IPv4AddrList property provides an unordered list of strings, each specifying a single IPv4 address, a hostname, or a range of IPv4 addresses, according to the ABNF definition [6] of an IPv4 address, as specified below:",
      "ja": "以下に指定されるようIPv4AddrListプロパティは、[6]、IPv4アドレスのABNF定義によれば、それぞれが単一のIPv4アドレス、ホスト名、またはIPv4アドレスの範囲を指定し、文字列の順序付けられていないリストを提供します。"
    },
    {
      "indent": 3,
      "text": "IPv4address = 1*3DIGIT \".\" 1*3DIGIT \".\" 1*3DIGIT \".\" 1*3DIGIT IPv4prefix = IPv4address \"/\" 1*2DIGIT IPv4range = IPv4address\"-\"IPv4address IPv4maskedaddress = IPv4address\",\"IPv4address Hostname (as defined in [4])",
      "ja": "= 1 * 3DIGIT IPv4Addressを \"\" 1 * 3DIGIT \"\" 1 * 3DIGIT \"\" 1 * 3DIGIT IPv4prefix = IPv4Addressを \"/\" 1 * 2DIGIT IPv4range = IPv4Addressを \" - \" IPv4AddressをIPv4maskedaddress = IPv4Addressを \"\" IPv4Addressをホスト名（[4]で定義されるように）"
    },
    {
      "indent": 3,
      "text": "In the above definition, each string entry is either:",
      "ja": "上記の定義では、各文字列エントリのいずれかです："
    },
    {
      "indent": 3,
      "text": "1. A single IPv4address in dot notation, as defined above. Example: 121.1.1.2",
      "ja": "1ドット表記の単一IPv4Addressを、上記のように定義されます。例：121.1.1.2"
    },
    {
      "indent": 3,
      "text": "2. An IPv4prefix address range, as defined above, specified by an address and a prefix length, separated by \"/\". Example: 2.3.128.0/15",
      "ja": "2.アンIPv4prefixアドレス範囲を、「/」で区切られた、アドレスとプレフィックス長で指定された、上記で定義しました。例：2.3.128.0/15"
    },
    {
      "indent": 3,
      "text": "3. An IPv4range address range defined above, specified by a starting address in dot notation and an ending address in dot notation, separated by \"-\". The range includes all addresses between the range's starting and ending addresses, including these two addresses. Example: 1.1.22.1-1.1.22.5",
      "ja": "「 - 」で区切られたドット表記の開始アドレスとドット表記の終了アドレスによって指定された上記で定義された3.アンIPv4rangeアドレス範囲。範囲は、これら二つのアドレスを含む範囲の開始と終了アドレスの間のすべてのアドレスが含まれています。例：1.1.22.1-1.1.22.5"
    },
    {
      "indent": 3,
      "text": "4. An IPv4maskedaddress address range, as defined above, specified by an address and mask. The address and mask are represented in dot notation, separated by a comma \",\". The masked address appears before the comma, and the mask appears after the comma. Example: 2.3.128.0,255.255.248.0.",
      "ja": "アドレスとマスクで指定された、上記で定義した通り4アンIPv4maskedaddressアドレス範囲。アドレスおよびマスク「」コンマで区切られた、ドット表記で表されています。マスクされたアドレスは、コンマの前に表示され、マスクがコンマの後に表示されます。例：2.3.128.0,255.255.248.0。"
    },
    {
      "indent": 3,
      "text": "5. A single Hostname. The Hostname format follows the guidelines and restrictions specified in [4]. Example: www.bigcompany.com.",
      "ja": "5.単一ホスト名。ホスト名の形式は、[4]で指定されたガイドラインおよび制限に従います。例：www.bigcompany.com。"
    },
    {
      "indent": 3,
      "text": "Conditions matching IPv4AddrValues evaluate to true according to the generic matching rules. Additionally, a hostname is matched against another valid IPv4address representation by resolving the hostname into an IPv4 address first, and then comparing the addresses afterwards. Matching hostnames against each other is done using a string comparison of the two names.",
      "ja": "IPv4AddrValuesに一致する条件は、一般的な一致規則に従って真と評価します。また、ホスト名は、最初のIPv4アドレスにホスト名を解決して、その後のアドレスを比較することによって、別の有効なIPv4Addressを表現と照合されます。お互いに対するマッチングのホスト名は、二つの名前の文字列比較を使用して行われます。"
    },
    {
      "indent": 3,
      "text": "The property definition is as follows:",
      "ja": "次のようにプロパティの定義は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "NAME IPv4AddrList SYNTAX String FORMAT IPv4address | IPv4prefix | IPv4range | IPv4maskedaddress | hostname",
      "ja": "NAME IPv4AddrList SYNTAX文字列FORMATのIPv4Addressを| IPv4prefix | IPv4range | IPv4maskedaddress |ホスト名"
    },
    {
      "indent": 0,
      "text": "6.14.2. The Class \"PolicyIPv6AddrValue",
      "section_title": true,
      "ja": "6.14.2。クラス「PolicyIPv6AddrValue"
    },
    {
      "indent": 3,
      "text": "This class is used to define a list of IPv6 addresses, hostnames, and address range values. The class definition is as follows:",
      "ja": "このクラスは、IPv6アドレス、ホスト名、およびアドレス範囲の値のリストを定義するために使用されます。次のようにクラス定義は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "NAME PolicyIPv6AddrValue DERIVED FROM PolicyValue ABSTRACT False PROPERTIES IPv6AddrList[ ]",
      "ja": "PolicyValue ABSTRACT偽の施設から派生NAME PolicyIPv6AddrValue IPv6AddrList []"
    },
    {
      "indent": 3,
      "text": "The property IPv6AddrList provides an unordered list of strings, each specifying an IPv6 address, a hostname, or a range of IPv6 addresses. IPv6 address format definition uses the standard address format defined in [7]. The ABNF definition [6] as specified in [7] is:",
      "ja": "プロパティIPv6AddrListは、それぞれがIPv6アドレス、ホスト名、またはIPv6アドレスの範囲を指定して、文字列の順序なしリストを提供します。 IPv6アドレスフォーマット定義[7]で定義された標準アドレス形式を使用します。で指定されるようにABNF定義は、[6] [7]です。"
    },
    {
      "indent": 3,
      "text": "IPv6address = hexpart [ \":\" IPv4address ] IPv4address = 1*3DIGIT \".\" 1*3DIGIT \".\" 1*3DIGIT \".\" 1*3DIGIT IPv6prefix = hexpart \"/\" 1*2DIGIT hexpart = hexseq | hexseq \"::\" [ hexseq ] | \"::\" [ hexseq ] hexseq = hex4 *( \":\" hex4) hex4 = 1*4HEXDIG IPv6range = IPv6address\"-\"IPv6address IPv6maskedaddress = IPv6address\",\"IPv6address Hostname (as defines in [NAMES])",
      "ja": "IPv6address = hexpart [ \"：\" IPv4Addressを] IPv4Addressを= 1 * 3DIGIT \"\" 1 * 3DIGIT \"\" 1 * 3DIGIT \"\" 1 * 3DIGIT IPv6prefix = hexpart \"/\" 1 * 2DIGIT hexpart = hexseq | hexseq \"::\" [hexseq] | \"::\" [hexseq] hexseq = hex4 *（ \"：\" hex4）hex4 = 1 * 4HEXDIG IPv6range = IPv6address \" - \" IPv6address IPv6maskedaddress = IPv6address \"\" IPv6addressホスト名（[NAMES]で定義のように）"
    },
    {
      "indent": 3,
      "text": "Each string entry is either:",
      "ja": "各文字列エントリのいずれかです："
    },
    {
      "indent": 3,
      "text": "1. A single IPv6address as defined above.",
      "section_title": true,
      "ja": "1.単一IPv6address上記のように定義されます。"
    },
    {
      "indent": 3,
      "text": "2. A single Hostname. Hostname format follows guidelines and restrictions specified in [4].",
      "ja": "2.単一のホスト名。ホスト名の形式は、[4]で指定された注意事項および制約事項に従っています。"
    },
    {
      "indent": 3,
      "text": "3. An IPv6range address range, specified by a starting address in dot notation and an ending address in dot notation, separated by \"-\". The range includes all addresses between the range's starting and ending addresses, including these two addresses.",
      "ja": "「 - 」で区切られたドット表記とドット表記で終了アドレスに開始アドレスで指定3.アンIPv6rangeアドレス範囲。範囲は、これら二つのアドレスを含む範囲の開始と終了アドレスの間のすべてのアドレスが含まれています。"
    },
    {
      "indent": 3,
      "text": "4. An IPv4maskedaddress address range defined above specified by an address and mask. The address and mask are represented in dot notation separated by a comma \",\".",
      "ja": "アドレスとマスクで指定された上記で定義された4アンIPv4maskedaddressアドレス範囲。アドレスおよびマスク「」コンマで区切られたドット表記で表されています。"
    },
    {
      "indent": 3,
      "text": "5. A single IPv6prefix as defined above.",
      "section_title": true,
      "ja": "5.単一IPv6prefix上記のように定義されます。"
    },
    {
      "indent": 3,
      "text": "Conditions matching IPv6AddrValues evaluate to true according to the generic matching rules. Additionally, a hostname is matched against another valid IPv6address representation by resolving the hostname into an IPv6 address first, and then comparing the addresses afterwards. Matching hostnames against each other is done using a string comparison of the two names.",
      "ja": "IPv6AddrValuesに一致する条件は、一般的な一致規則に従って真と評価します。また、ホスト名は、最初にIPv6アドレスにホスト名を解決して、その後のアドレスを比較することによって、別の有効なIPv6address表現と照合されます。お互いに対するマッチングのホスト名は、二つの名前の文字列比較を使用して行われます。"
    },
    {
      "indent": 0,
      "text": "6.14.3. The Class \"PolicyMACAddrValue\"",
      "section_title": true,
      "ja": "6.14.3。クラス「PolicyMACAddrValue」"
    },
    {
      "indent": 3,
      "text": "This class is used to define a list of MAC addresses and MAC address range values. The class definition is as follows:",
      "ja": "このクラスは、MACアドレスとMACアドレスの範囲の値のリストを定義するために使用されます。次のようにクラス定義は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "NAME PolicyMACAddrValue DERIVED FROM PolicyValue ABSTRACT False PROPERTIES MACAddrList[ ]",
      "ja": "PolicyValue ABSTRACT偽の施設から派生NAME PolicyMACAddrValue MACAddrList []"
    },
    {
      "indent": 3,
      "text": "The property MACAddrList provides an unordered list of strings, each specifying a MAC address or a range of MAC addresses. The 802 MAC address canonical format is used. The ABNF definition [6] is:",
      "ja": "プロパティMACAddrListは、各MACアドレスまたはMACアドレスの範囲を指定し、文字列の順序付けられていないリストを提供します。 802のMACアドレス標準的なフォーマットが使用されています。 ABNF定義は、[6]です。"
    },
    {
      "indent": 3,
      "text": "MACaddress = 1*4HEXDIG \":\" 1*4HEXDIG \":\" 1*4HEXDIG MACmaskedaddress = MACaddress\",\"MACaddress",
      "ja": "MACADDRESS = 1 * 4HEXDIG \"：\" 1 * 4HEXDIG \"：\" 1 * = MACADDRESS 4HEXDIG MACmaskedaddress \"\" MACADDRESS"
    },
    {
      "indent": 3,
      "text": "Each string entry is either:",
      "ja": "各文字列エントリのいずれかです："
    },
    {
      "indent": 3,
      "text": "1. A single MAC address. Example: 0000:00A5:0000",
      "section_title": true,
      "ja": "1.単一のMACアドレス。例：0000：0000：00A5"
    },
    {
      "indent": 3,
      "text": "2. A MACmaskedaddress address range defined specified by an address and mask. The mask specifies the relevant bits in the address. Example: 0000:00A5:0000,FFFF:FFFF:0000 defines a range of MAC addresses in which the first four octets are equal to 0000:00A5.",
      "ja": "アドレスとマスクで指定された定義された2 A MACmaskedaddressアドレス範囲。マスクは、アドレスの関連ビットを指定します。例：0000：00A5：0000、FFFF：FFFF：00A5：0000は、最初の4つのオクテットは0000に等しいされたMACアドレスの範囲を定義します。"
    },
    {
      "indent": 3,
      "text": "The property definition is as follows:",
      "ja": "次のようにプロパティの定義は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "NAME MACAddrList SYNTAX String FORMAT MACaddress | MACmaskedaddress",
      "ja": "MACAddrList SYNTAX文字列フォーマットMACADDRESSを名前| MACmaskedaddress"
    },
    {
      "indent": 0,
      "text": "6.14.4. The Class \"PolicyStringValue\"",
      "section_title": true,
      "ja": "6.14.4。クラス「PolicyStringValue」"
    },
    {
      "indent": 3,
      "text": "This class is used to represent a single string value, or a set of string values. Each value can have wildcards. The class definition is as follows:",
      "ja": "このクラスは、単一の文字列値、または文字列値のセットを表すために使用されます。各値は、ワイルドカードを持つことができます。次のようにクラス定義は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "NAME PolicyStringValue DERIVED FROM PolicyValue ABSTRACT False PROPERTIES StringList[ ]",
      "ja": "PolicyValue ABSTRACT偽の施設から派生NAME PolicyStringValue STRINGLIST []"
    },
    {
      "indent": 3,
      "text": "The property StringList provides an unordered list of strings, each representing a single string with wildcards. The asterisk character \"*\" is used as a wildcard, and represents an arbitrary substring replacement. For example, the value \"abc*def\" matches the string \"abcxyzdef\", and the value \"abc*def*\" matches the string \"abcxxxdefyyyzzz\". The syntax definition is identical to the substring assertion syntax defined in [5]. If the asterisk character is required as part of the string value itself, it MUST be quoted as described in Section 4.3 of [5].",
      "ja": "プロパティSTRINGLISTは、それぞれがワイルドカードを持つ単一の文字列を表す文字列の順序付けられていないリストを提供します。アスタリスク文字「*」はワイルドカードとして使用され、任意の部分文字列の置換を表しています。たとえば、値「ABCは* DEF」「abcxyzdef」の文字列に一致し、その値が「ABC * DEF *」文字列「abcxxxdefyyyzzz」にマッチします。構文定義は、[5]で定義されたサブストリングアサーション構文と同じです。アスタリスク文字は、文字列値自体の一部として必要とされている場合は、[5]のセクション4.3で説明したように、それが引用されなければなりません。"
    },
    {
      "indent": 3,
      "text": "The property definition is as follows:",
      "ja": "次のようにプロパティの定義は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "NAME StringList SYNTAX String",
      "ja": "STRINGLIST SYNTAX文字列NAME"
    },
    {
      "indent": 0,
      "text": "6.14.5. The Class \"PolicyBitStringValue\"",
      "section_title": true,
      "ja": "6.14.5。クラス「PolicyBitStringValue」"
    },
    {
      "indent": 3,
      "text": "This class is used to represent a single bit string value, or a set of bit string values. The class definition is as follows:",
      "ja": "このクラスは、単一のビット列の値、又はビット列の値のセットを表すために使用されます。次のようにクラス定義は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "NAME PolicyBitStringValue DERIVED FROM PolicyValue ABSTRACT False PROPERTIES BitStringList[ ]",
      "ja": "NAME PolicyBitStringValueはPolicyValue ABSTRACT偽の施設から派生BitStringList []"
    },
    {
      "indent": 3,
      "text": "The property BitStringList provides an unordered list of strings, each representing a single bit string or a set of bit strings. The number of bits specified SHOULD equal the number of bits of the expected variable. For example, for a one-octet variable, 8 bits should be specified. If the variable does not have a fixed length, the bit string should be matched against the variable's most significant bit string. The formal definition of a bit string is:",
      "ja": "プロパティBitStringListは、それぞれが単一のビットストリングまたはビットストリングの集合を表す文字列の順序付けられていないリストを提供します。指定されたビットの数は、予想される変数のビットの数に等しくなければなりません。例えば、1オクテットの変数に対して、8ビットが指定されなければなりません。変数は固定長を持っていない場合は、ビット列は、変数の最上位ビット列と照合する必要があります。ビット列の正式な定義は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "binary-digit = \"0\" / \"1\" bitString = 1*binary-digit maskedBitString = bitString\",\"bitString",
      "ja": "バイナリ桁= \"0\" / \"1\" ビット文字列= 1 *バイナリ桁maskedBitString =ビット列 \"\" ビット文字列"
    },
    {
      "indent": 3,
      "text": "Each string entry is either:",
      "ja": "各文字列エントリのいずれかです："
    },
    {
      "indent": 3,
      "text": "1. A single bit string. Example: 00111010",
      "section_title": true,
      "ja": "1.単一ビット列。例：00111010"
    },
    {
      "indent": 3,
      "text": "2. A range of bit strings specified using a bit string and a bit mask. The bit string and mask fields have the same number of bits specified. The mask bit string specifies the significant bits in the bit string value. For example, 110110, 100110 and 110111 would match the maskedBitString 100110,101110 but 100100 would not.",
      "ja": "2.ビット列とビットマスクを使用して、指定されたビット列の範囲。ビット列とマスクフィールドは、指定された同じビット数を有します。マスクビット列は、ビット列の値の上位ビットを指定します。例えば、110110、100110と110111はmaskedBitString 100110,101110に一致するだろうが、100100はないでしょう。"
    },
    {
      "indent": 3,
      "text": "The property definition is as follows:",
      "ja": "次のようにプロパティの定義は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "NAME BitStringList SYNTAX String FORMAT bitString | maskedBitString",
      "ja": "BitStringList SYNTAX文字列フォーマットのビット列を名前| maskedBitString"
    },
    {
      "indent": 0,
      "text": "6.14.6. The Class \"PolicyIntegerValue\"",
      "section_title": true,
      "ja": "6.14.6。クラス「PolicyIntegerValue」"
    },
    {
      "indent": 3,
      "text": "This class provides a list of integer and integer range values. Integers of arbitrary sizes can be represented. The class definition is as follows:",
      "ja": "このクラスは、整数および整数範囲値のリストを提供します。任意のサイズの整数を表すことができます。次のようにクラス定義は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "NAME PolicyIntegerValue DERIVED FROM PolicyValue ABSTRACT False PROPERTIES IntegerList[ ]",
      "ja": "PolicyValue ABSTRACT偽の施設から派生NAME PolicyIntegerValue IntegerList []"
    },
    {
      "indent": 3,
      "text": "The property IntegerList provides an unordered list of integers and integer range values, represented as strings. The format of this property takes one of the following forms:",
      "ja": "整数および整数範囲値の順序付けられていないリストを提供IntegerListプロパティは、文字列として表されます。このプロパティの形式は、次のいずれかの形式をとります。"
    },
    {
      "indent": 3,
      "text": "1. An integer value.",
      "section_title": true,
      "ja": "1.整数値。"
    },
    {
      "indent": 3,
      "text": "2. A range of integers. The range is specified by a starting integer and an ending integer, separated by '..'. The starting integer MUST be less than or equal to the ending integer. The range includes all integers between the starting and ending integers, including these two integers.",
      "ja": "2.整数の範囲。範囲は、出発整数によって分離終了整数で指定されました「..」。出発整数で終わる整数より小さいか等しくなければなりません。範囲は、これら二つの整数を含む開始と終了整数、間のすべての整数を含みます。"
    },
    {
      "indent": 3,
      "text": "To represent a range of integers that is not bounded, the reserved words -INFINITY and/or INFINITY can be used in place of the starting and ending integers. In addition to ordinary integer matches, INFINITY matches INFINITY and -INFINITY matches -INFINITY.",
      "ja": "囲まれていない整数の範囲を表現するために、予約語の-INFINITY及び/又はINFINITYは、開始と終了整数の代わりに使用することができます。通常の整数の試合に加えて、INFINITYは、INFINITYと一致し、-INFINITYは-INFINITYに一致します。"
    },
    {
      "indent": 3,
      "text": "The ABNF definition [6] is:",
      "ja": "ABNF定義は、[6]です。"
    },
    {
      "indent": 3,
      "text": "integer = [-]1*DIGIT | \"INFINITY\" | \"-INFINITY\" integerrange = integer\"..\"integer",
      "ja": "整数= [ - ] 1 * DIGIT | \"INFINITY\" | \"-INFINITY\" IntegerRangeを=整数 \"..\" 整数"
    },
    {
      "indent": 3,
      "text": "Using ranges, the operators greater-than, greater-than-or-equal-to, less- than, and less-than-or-equal-to can be expressed. For example, \"X is- greater-than 5\" (where X is an integer) can be translated to \"X matches 6-INFINITY\". This enables the match condition semantics of the operator for the SimplePolicyCondition class to be kept simple (i.e., just the value \"match\").",
      "ja": "等しいより少なくよりもしくは-の範囲を使用して、オペレータはより大、より-大きいかまたは等しく-に、よりless-、および発現させることができます。例えば、「Xは - より大5」（Xは整数）「X 6-INFINITYに一致」に変換することができます。これは（すなわち、ただ値「一致」）、単純な維持するSimplePolicyConditionクラスの演算子の一致条件セマンティクスを可能にします。"
    },
    {
      "indent": 3,
      "text": "The property definition is as follows:",
      "ja": "次のようにプロパティの定義は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "NAME IntegerList SYNTAX String FORMAT integer | integerrange",
      "ja": "IntegerList SYNTAX文字列形式の整数を名前| IntegerRangeを"
    },
    {
      "indent": 0,
      "text": "6.14.7. The Class \"PolicyBooleanValue\"",
      "section_title": true,
      "ja": "6.14.7。クラス「PolicyBooleanValue」"
    },
    {
      "indent": 3,
      "text": "This class is used to represent a Boolean (TRUE/FALSE) value. The class definition is as follows:",
      "ja": "このクラスは、ブール値（TRUE / FALSE）値を表すために使用されます。次のようにクラス定義は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "NAME PolicyBooleanValue DERIVED FROM PolicyValue ABSTRACT False PROPERTIES BooleanValue",
      "ja": "PolicyValue ABSTRACT偽の施設から派生NAME PolicyBooleanValueするBooleanValue"
    },
    {
      "indent": 3,
      "text": "The property definition is as follows:",
      "ja": "次のようにプロパティの定義は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "NAME BooleanValue SYNTAX boolean",
      "ja": "NAMEするBooleanValue SYNTAXブール"
    },
    {
      "indent": 0,
      "text": "6.15. The Class \"PolicyRoleCollection\"",
      "section_title": true,
      "ja": "6.15。クラス「PolicyRoleCollection」"
    },
    {
      "indent": 3,
      "text": "This class represents a collection of managed elements that share a common role. The PolicyRoleCollection always exists in the context of a system, specified using the PolicyRoleCollectionInSystem association. The value of the PolicyRole property in this class specifies the role, and can be matched with the value(s) in the PolicyRoles array in PolicyRules and PolicyGroups. ManagedElements that share the role defined in this collection are aggregated into the collection via the association ElementInPolicyRoleCollection.",
      "ja": "このクラスは、共通の役割を共有する管理対象要素のコレクションを表します。 PolicyRoleCollectionは、常にシステムのコンテキスト内に存在する、PolicyRoleCollectionInSystemアソシエーションを使用して、指定されました。このクラスのPolicyRoleプロパティの値は、役割を指定し、PolicyRulesとPolicyGroupsでPolicyRolesアレイの値（S）と一致させることができます。このコレクションで定義された役割を共有ManagedElementsは協会ElementInPolicyRoleCollection経由コレクションに集約されます。"
    },
    {
      "indent": 3,
      "text": "NAME PolicyRoleCollection DESCRIPTION A subclass of the CIM Collection class used to group together managed elements that share a role. DERIVED FROM Collection ABSTRACT FALSE",
      "ja": "NAMEのPolicyRoleCollection DESCRIPTIONグループ化するために使用されるCIMのコレクションクラスのサブクラスでは、一緒に役割を共有する要素を管理します。コレクションABSTRACT falseから派生"
    },
    {
      "indent": 3,
      "text": "PROPERTIES PolicyRole",
      "ja": "PROPERTIES PolicyRole"
    },
    {
      "indent": 0,
      "text": "6.15.1. The Single-Valued Property \"PolicyRole\"",
      "section_title": true,
      "ja": "6.15.1。単一値プロパティ「PolicyRole」"
    },
    {
      "indent": 3,
      "text": "This property represents the role associated with a PolicyRoleCollection. The property definition is as follows:",
      "ja": "このプロパティは、PolicyRoleCollectionに関連付けられた役割を表します。次のようにプロパティの定義は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "NAME PolicyRole DESCRIPTION A string representing the role associated with a PolicyRoleCollection. SYNTAX string",
      "ja": "PolicyRole説明をPolicyRoleCollectionに関連付けられた役割を表す文字列を名前。 SYNTAX文字列"
    },
    {
      "indent": 0,
      "text": "6.16. The Class \"ReusablePolicyContainer\"",
      "section_title": true,
      "ja": "6.16。クラス「ReusablePolicyContainer」"
    },
    {
      "indent": 3,
      "text": "The new class ReusablePolicyContainer is defined as follows:",
      "ja": "次のように新しいクラスReusablePolicyContainerが定義されています。"
    },
    {
      "indent": 3,
      "text": "NAME ReusablePolicyContainer DESCRIPTION A class representing an administratively defined container for reusable policy-related information. This class does not introduce any additional properties beyond those in its superclass AdminDomain. It does, however, participate in a number of unique associations. DERIVED FROM AdminDomain ABSTRACT FALSE PROPERTIES (none)",
      "ja": "NAME ReusablePolicyContainer DESCRIPTION再利用可能なポリシー関連情報のための管理者が定義コンテナを表すクラス。このクラスは、そのスーパークラスのいるAdminDomainのものを超えて追加のプロパティを導入しません。それは、しかし、ユニークな関連付けの数に参加しません。いるAdminDomain ABSTRACT FALSE PROPERTIES（なし）に由来します"
    },
    {
      "indent": 0,
      "text": "6.17. Deprecate PCIM's Class \"PolicyRepository\"",
      "section_title": true,
      "ja": "6.17。廃止PCIMのクラス「PolicyRepository」"
    },
    {
      "indent": 3,
      "text": "The class definition of PolicyRepository (from PCIM) is updated as follows, with an indication that the class has been deprecated. Note that when an element of the model is deprecated, its replacement element is identified explicitly.",
      "ja": "PolicyRepository（PCIMから）のクラス定義がクラスが廃止されたことを示すと、次のように更新されます。モデルの要素は廃止されたときに、その代替要素が明示的に識別されることに注意してください。"
    },
    {
      "indent": 3,
      "text": "NAME PolicyRepository DEPRECATED FOR ReusablePolicyContainer DESCRIPTION A class representing an administratively defined container for reusable policy-related information. This class does not introduce any additional properties beyond those in its superclass AdminDomain. It does, however, participate in a number of unique associations.",
      "ja": "ReusablePolicyContainer記述のNAME PolicyRepository DEPRECATED再利用可能なポリシー関連情報のための管理者が定義コンテナを表すクラス。このクラスは、そのスーパークラスのいるAdminDomainのものを超えて追加のプロパティを導入しません。それは、しかし、ユニークな関連付けの数に参加しません。"
    },
    {
      "indent": 3,
      "text": "DERIVED FROM AdminDomain ABSTRACT FALSE PROPERTIES (none)",
      "ja": "いるAdminDomain ABSTRACT FALSE PROPERTIES（なし）に由来します"
    },
    {
      "indent": 0,
      "text": "6.18. The Abstract Class \"FilterEntryBase\"",
      "section_title": true,
      "ja": "6.18。抽象クラス「FilterEntryBase」"
    },
    {
      "indent": 3,
      "text": "FilterEntryBase is the abstract base class from which all filter entry classes are derived. It serves as the endpoint for the EntriesInFilterList aggregation, which groups filter entries into filter lists. Its properties include CIM naming attributes and an IsNegated boolean property (to easily \"NOT\" the match information specified in an instance of one of its subclasses).",
      "ja": "FilterEntryBaseは、すべてのフィルタエントリのクラスが派生する抽象基本クラスです。これは、グループがフィルタリストにエントリをフィルタリングEntriesInFilterList集約のためのエンドポイントとして機能します。その性質はCIM命名属性とIsNegatedブールプロパティを含める（にそのサブクラスの1つのインスタンスで指定された簡単に「NOT」試合情報）。"
    },
    {
      "indent": 3,
      "text": "The class definition is as follows:",
      "ja": "次のようにクラス定義は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "NAME FilterEntryBase DESCRIPTION An abstract class representing a single filter that is aggregated into a FilterList via the aggregation EntriesInFilterList. DERIVED FROM LogicalElement TYPE Abstract PROPERTIES IsNegated",
      "ja": "凝集EntriesInFilterList介しFilterListに集約された単一のフィルタを表す名前FilterEntryBase説明抽象クラス。 LogicalElementのTYPE抽象PROPERTIES IsNegatedから、派生"
    },
    {
      "indent": 0,
      "text": "6.19. The Class \"IpHeadersFilter\"",
      "section_title": true,
      "ja": "6.19。クラス「IpHeadersFilter」"
    },
    {
      "indent": 3,
      "text": "This concrete class contains the most commonly required properties for performing filtering on IP, TCP or UDP headers. Properties not present in an instance of IPHeadersFilter are treated as 'all values'. A property HdrIpVersion identifies whether the IP addresses in an instance are IPv4 or IPv6 addresses. Since the source and destination IP addresses come from the same packet header, they will always be of the same type.",
      "ja": "この具象クラスは、IP、TCPまたはUDPヘッダーにフィルタリングを行うための最も一般的に必要なプロパティが含まれています。 IPHeadersFilterのインスタンスに存在しないプロパティには、「すべての値」として扱われます。プロパティHdrIpVersionは、インスタンス内のIPアドレスは、IPv4またはIPv6アドレスであるかどうかを識別する。送信元および宛先IPアドレスが同じパケットヘッダから来るので、それらは常に同じタイプであろう。"
    },
    {
      "indent": 3,
      "text": "The class definition is as follows:",
      "ja": "次のようにクラス定義は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "NAME IpHeadersFilter DESCRIPTION A class representing an entire IP header filter, or any subset of one. DERIVED FROM FilterEntryBase TYPE Concrete PROPERTIES HdrIpVersion, HdrSrcAddress, HdrSrcAddressEndOfRange, HdrSrcMask, HdrDestAddress, HdrDestAddressEndOfRange, HdrDestMask, HdrProtocolID, HdrSrcPortStart, HdrSrcPortEnd, HdrDestPortStart, HdrDestPortEnd, HdrDSCP[ ], HdrFlowLabel",
      "ja": "IpHeadersFilter説明に全体のIPヘッダフィルタを表すクラス、または1つの任意のサブセットに名前を付けます。 HdrIpVersion、HdrSrcAddress、HdrSrcAddressEndOfRange、HdrSrcMask、HdrDestAddress、HdrDestAddressEndOfRange、HdrDestMask、HdrProtocolID、HdrSrcPortStart、HdrSrcPortEnd、HdrDestPortStart、HdrDestPortEnd、HdrDSCP []、HdrFlowLabel FilterEntryBaseタイプコンクリートの施設から派生"
    },
    {
      "indent": 0,
      "text": "6.19.1. The Property HdrIpVersion",
      "section_title": true,
      "ja": "6.19.1。プロパティHdrIpVersion"
    },
    {
      "indent": 3,
      "text": "This property is an 8-bit unsigned integer, identifying the version of the IP addresses to be filtered on. IP versions are identified as they are in the Version field of the IP packet header - IPv4 = 4, IPv6 = 6. These two values are the only ones defined for this property.",
      "ja": "このプロパティは、上で濾過されるIPアドレスのバージョンを識別する、8ビットの符号なし整数です。 IPv4の= 4のIPv6 = 6これらの2つの値がこのプロパティに対して定義された唯一のものであり、 - それらはIPパケットヘッダのバージョンフィールド内にあるように、IPバージョンが識別されます。"
    },
    {
      "indent": 3,
      "text": "The value of this property determines the sizes of the OctetStrings in the six properties HdrSrcAddress, HdrSrcAddressEndOfRange, HdrSrcMask, HdrDestAddress, HdrDestAddressEndOfRange, and HdrDestMask, as follows:",
      "ja": "次のように、このプロパティの値は6つの特性HdrSrcAddress、HdrSrcAddressEndOfRange、HdrSrcMask、HdrDestAddress、HdrDestAddressEndOfRange、及びHdrDestMaskでOctetStringsの大きさを決定します。"
    },
    {
      "indent": 3,
      "text": "o IPv4: OctetString(SIZE (4))",
      "ja": "IPv4のO：OctetStringに（SIZE（4））"
    },
    {
      "indent": 3,
      "text": "o IPv6: OctetString(SIZE (16|20)), depending on whether a scope identifier is present",
      "ja": "IPv6のO：OctetStringに（SIZE（16 | 20））、スコープ識別子が存在するかどうかに依存して"
    },
    {
      "indent": 3,
      "text": "If a value for this property is not provided, then the filter does not consider IP version in selecting matching packets, i.e., IP version matches for all values. In this case, the HdrSrcAddress, HdrSrcAddressEndOfRange, HdrSrcMask, HdrDestAddress, HdrDestAddressEndOfRange, and HdrDestMask must also not be present.",
      "ja": "このプロパティの値が提供されていない場合は、フィルタが一致するパケットを選択するIPバージョンを考慮していない、すなわち、IPのバージョンは、すべての値のために一致します。この場合、HdrSrcAddress、HdrSrcAddressEndOfRange、HdrSrcMask、HdrDestAddress、HdrDestAddressEndOfRange、及びHdrDestMaskも存在してはなりません。"
    },
    {
      "indent": 0,
      "text": "6.19.2. The Property HdrSrcAddress",
      "section_title": true,
      "ja": "6.19.2。プロパティHdrSrcAddress"
    },
    {
      "indent": 3,
      "text": "This property is an OctetString, of a size determined by the value of the HdrIpVersion property, representing a source IP address. When there is no HdrSrcAddressEndOfRange value, this value is compared to the source address in the IP header, subject to the mask represented in the HdrSrcMask property. (Note that the mask is ANDed with the address.) When there is a HdrSrcAddressEndOfRange value, this value is the start of the specified range (i.e., the HdrSrcAddress is lower than the HdrSrcAddressEndOfRange) that is compared to the source address in the IP header and matches on any value in the range.",
      "ja": "このプロパティは、送信元IPアドレスを表す、HdrIpVersionプロパティの値によって決定される大きさのOctetStringに、です。何HdrSrcAddressEndOfRange値がない場合、この値はHdrSrcMaskプロパティで表されるマスクの対象IPヘッダ内のソース・アドレスと比較されます。 （マスクはアドレスとAND演算されることに注意してください。）HdrSrcAddressEndOfRange値がある場合、この値は指定された範囲の先頭（すなわち、HdrSrcAddressがHdrSrcAddressEndOfRange未満である）IPヘッダ内のソース・アドレスと比較されますそして範囲内の任意の値に一致します。"
    },
    {
      "indent": 3,
      "text": "If a value for this property is not provided, then the filter does not consider HdrSrcAddress in selecting matching packets, i.e., HdrSrcAddress matches for all values.",
      "ja": "このプロパティの値が提供されていない場合、フィルタは、一致するパケットを選択する際にHdrSrcAddressを考慮していない、すなわち、HdrSrcAddressはすべての値について一致します。"
    },
    {
      "indent": 0,
      "text": "6.19.3. The Property HdrSrcAddressEndOfRange",
      "section_title": true,
      "ja": "6.19.3。プロパティHdrSrcAddressEndOfRange"
    },
    {
      "indent": 3,
      "text": "This property is an OctetString, of a size determined by the value of the HdrIpVersion property, representing the end of a range of source IP addresses (inclusive), where the start of the range is the HdrSrcAddress property value.",
      "ja": "このプロパティは、範囲の開始がHdrSrcAddressプロパティ値である送信元IPアドレスの範囲（両端を含む）の終了を示す、HdrIpVersionプロパティの値によって決定される大きさの、OctetStringにあります。"
    },
    {
      "indent": 3,
      "text": "If a value for HdrSrcAddress is not provided, then this property also MUST NOT be provided. If a value for this property is provided, then HdrSrcMask MUST NOT be provided.",
      "ja": "HdrSrcAddressの値が提供されていない場合、このプロパティはまた、提供してはなりません。このプロパティの値が提供されている場合、HdrSrcMaskを提供してはなりません。"
    },
    {
      "indent": 0,
      "text": "6.19.4. The Property HdrSrcMask",
      "section_title": true,
      "ja": "6.19.4。プロパティHdrSrcMask"
    },
    {
      "indent": 3,
      "text": "This property is an OctetString, of a size determined by the value of the HdrIpVersion property, representing a mask to be used in comparing the source address in the IP header with the value represented in the HdrSrcAddress property.",
      "ja": "このプロパティは、HdrSrcAddressプロパティで表される値でIPヘッダ内の送信元アドレスを比較する際に使用するマスクを表す、HdrIpVersionプロパティの値によって決定される大きさのOctetStringに、です。"
    },
    {
      "indent": 3,
      "text": "If a value for this property is not provided, then the filter does not consider HdrSrcMask in selecting matching packets, i.e., the value of HdrSrcAddress or the source address range must match the source address in the packet exactly. If a value for this property is provided, then HdrSrcAddressEndOfRange MUST NOT be provided.",
      "ja": "このプロパティの値が提供されていない場合、フィルタは、一致するパケットを選択する際にHdrSrcMaskを考慮していない、すなわち、HdrSrcAddress又は送信元アドレス範囲の値は、正確にパケットの送信元アドレスと一致しなければなりません。このプロパティの値が提供されている場合、HdrSrcAddressEndOfRangeを提供してはなりません。"
    },
    {
      "indent": 0,
      "text": "6.19.5. The Property HdrDestAddress",
      "section_title": true,
      "ja": "6.19.5。プロパティHdrDestAddress"
    },
    {
      "indent": 3,
      "text": "This property is an OctetString, of a size determined by the value of the HdrIpVersion property, representing a destination IP address. When there is no HdrDestAddressEndOfRange value, this value is compared to the destination address in the IP header, subject to the mask represented in the HdrDestMask property. (Note that the mask is ANDed with the address.) When there is a HdrDestAddressEndOfRange value, this value is the start of the specified range (i.e., the HdrDestAddress is lower than the HdrDestAddressEndOfRange) that is compared to the destination address in the IP header and matches on any value in the range.",
      "ja": "このプロパティは、宛先IPアドレスを表す、HdrIpVersionプロパティの値によって決定される大きさのOctetStringに、です。何HdrDestAddressEndOfRange値がない場合、この値はHdrDestMaskプロパティで表されるマスクの対象IPヘッダ内の宛先アドレスと比較されます。 （マスクはアドレスとAND演算されることに注意してください。）HdrDestAddressEndOfRange値がある場合、この値は指定された範囲の先頭（すなわち、HdrDestAddressがHdrDestAddressEndOfRange未満である）IPヘッダ内の宛先アドレスと比較されますそして範囲内の任意の値に一致します。"
    },
    {
      "indent": 3,
      "text": "If a value for this property is not provided, then the filter does not consider HdrDestAddress in selecting matching packets, i.e., HdrDestAddress matches for all values.",
      "ja": "このプロパティの値が提供されていない場合、フィルタは、一致するパケットを選択する際にHdrDestAddressを考慮していない、すなわち、HdrDestAddressはすべての値について一致します。"
    },
    {
      "indent": 0,
      "text": "6.19.6. The Property HdrDestAddressEndOfRange",
      "section_title": true,
      "ja": "6.19.6。プロパティHdrDestAddressEndOfRange"
    },
    {
      "indent": 3,
      "text": "This property is an OctetString, of a size determined by the value of the HdrIpVersion property, representing the end of a range of destination IP addresses (inclusive), where the start of the range is the HdrDestAddress property value.",
      "ja": "このプロパティは、範囲の開始がHdrDestAddressプロパティ値である宛先IPアドレスの範囲（両端を含む）の終了を示す、HdrIpVersionプロパティの値によって決定される大きさの、OctetStringにあります。"
    },
    {
      "indent": 3,
      "text": "If a value for HdrDestAddress is not provided, then this property also MUST NOT be provided. If a value for this property is provided, then HdrDestMask MUST NOT be provided.",
      "ja": "HdrDestAddressの値が提供されていない場合、このプロパティはまた、提供してはなりません。このプロパティの値が提供されている場合、HdrDestMaskを提供してはなりません。"
    },
    {
      "indent": 0,
      "text": "6.19.7. The Property HdrDestMask",
      "section_title": true,
      "ja": "6.19.7。プロパティHdrDestMask"
    },
    {
      "indent": 3,
      "text": "This property is an OctetString, of a size determined by the value of the HdrIpVersion property, representing a mask to be used in comparing the destination address in the IP header with the value represented in the HdrDestAddress property.",
      "ja": "このプロパティは、HdrDestAddressプロパティで表される値でIPヘッダ内の宛先アドレスを比較する際に使用するマスクを表す、HdrIpVersionプロパティの値によって決定される大きさのOctetStringに、です。"
    },
    {
      "indent": 3,
      "text": "If a value for this property is not provided, then the filter does not consider HdrDestMask in selecting matching packets, i.e., the value of HdrDestAddress or the destination address range must match the destination address in the packet exactly. If a value for this property is provided, then HdrDestAddressEndOfRange MUST NOT be provided.",
      "ja": "このプロパティの値が提供されていない場合、フィルタは、一致するパケットを選択する際にHdrDestMaskを考慮していない、すなわち、HdrDestAddressまたは宛先アドレス範囲の値は、正確にパケットの宛先アドレスと一致しなければなりません。このプロパティの値が提供されている場合、HdrDestAddressEndOfRangeを提供してはなりません。"
    },
    {
      "indent": 0,
      "text": "6.19.8. The Property HdrProtocolID",
      "section_title": true,
      "ja": "6.19.8。プロパティHdrProtocolID"
    },
    {
      "indent": 3,
      "text": "This property is an 8-bit unsigned integer, representing an IP protocol type. This value is compared to the Protocol field in the IP header.",
      "ja": "このプロパティは、IPプロトコルタイプを示す、8ビットの符号なし整数です。この値は、IPヘッダーのプロトコルフィールドと比較されます。"
    },
    {
      "indent": 3,
      "text": "If a value for this property is not provided, then the filter does not consider HdrProtocolID in selecting matching packets, i.e., HdrProtocolID matches for all values.",
      "ja": "このプロパティの値が提供されていない場合、フィルタは、一致するパケットを選択する際にHdrProtocolIDを考慮していない、すなわち、HdrProtocolIDはすべての値について一致します。"
    },
    {
      "indent": 0,
      "text": "6.19.9. The Property HdrSrcPortStart",
      "section_title": true,
      "ja": "6.19.9。プロパティHdrSrcPortStart"
    },
    {
      "indent": 3,
      "text": "This property is a 16-bit unsigned integer, representing the lower end of a range of UDP or TCP source ports. The upper end of the range is represented by the HdrSrcPortEnd property. The value of HdrSrcPortStart MUST be no greater than the value of HdrSrcPortEnd. A single port is indicated by equal values for HdrSrcPortStart and HdrSrcPortEnd.",
      "ja": "このプロパティは、UDPまたはTCPソースポート範囲の下端を表す、16ビットの符号なし整数です。範囲の上端はHdrSrcPortEndプロパティによって表されています。 HdrSrcPortStartの値はHdrSrcPortEndの値以下でなければなりません。単一ポートがHdrSrcPortStartとHdrSrcPortEndに対して等しい値で示されます。"
    },
    {
      "indent": 3,
      "text": "A source port filter is evaluated by testing whether the source port identified in the IP header falls within the range of values between HdrSrcPortStart and HdrSrcPortEnd, including these two end points.",
      "ja": "ソースポートフィルタは、IPヘッダ内の識別されたソースポートは、これら2つのエンドポイントを含むHdrSrcPortStartとHdrSrcPortEnd、の間の値の範囲内にあるかどうかを試験することによって評価されます。"
    },
    {
      "indent": 3,
      "text": "If a value for this property is not provided, then the filter does not consider HdrSrcPortStart in selecting matching packets, i.e., there is no lower bound in matching source port values.",
      "ja": "このプロパティの値が提供されていない場合、フィルタは、一致するパケットを選択する際にHdrSrcPortStartを考慮していない、すなわち、ソースポート値と一致でない下限は存在しません。"
    },
    {
      "indent": 0,
      "text": "6.19.10. The Property HdrSrcPortEnd",
      "section_title": true,
      "ja": "6.19.10。プロパティHdrSrcPortEnd"
    },
    {
      "indent": 3,
      "text": "This property is a 16-bit unsigned integer, representing the upper end of a range of UDP or TCP source ports. The lower end of the range is represented by the HdrSrcPortStart property. The value of",
      "ja": "このプロパティは、UDPまたはTCPソースポートの範囲の上限を表す、16ビットの符号なし整数です。範囲の下端はHdrSrcPortStartプロパティによって表されています。の値"
    },
    {
      "indent": 3,
      "text": "HdrSrcPortEnd MUST be no less than the value of HdrSrcPortStart. A single port is indicated by equal values for HdrSrcPortStart and HdrSrcPortEnd.",
      "ja": "HdrSrcPortEndはHdrSrcPortStartの値以上である必要があります。単一ポートがHdrSrcPortStartとHdrSrcPortEndに対して等しい値で示されます。"
    },
    {
      "indent": 3,
      "text": "A source port filter is evaluated by testing whether the source port identified in the IP header falls within the range of values between HdrSrcPortStart and HdrSrcPortEnd, including these two end points.",
      "ja": "ソースポートフィルタは、IPヘッダ内の識別されたソースポートは、これら2つのエンドポイントを含むHdrSrcPortStartとHdrSrcPortEnd、の間の値の範囲内にあるかどうかを試験することによって評価されます。"
    },
    {
      "indent": 3,
      "text": "If a value for this property is not provided, then the filter does not consider HdrSrcPortEnd in selecting matching packets, i.e., there is no upper bound in matching source port values.",
      "ja": "このプロパティの値が提供されていない場合、フィルタは、一致するパケットを選択する際にHdrSrcPortEndを考慮していない、すなわち、ソースポート値に一致するには上限がありません。"
    },
    {
      "indent": 0,
      "text": "6.19.11. The Property HdrDestPortStart",
      "section_title": true,
      "ja": "6.19.11。プロパティHdrDestPortStart"
    },
    {
      "indent": 3,
      "text": "This property is a 16-bit unsigned integer, representing the lower end of a range of UDP or TCP destination ports. The upper end of the range is represented by the HdrDestPortEnd property. The value of HdrDestPortStart MUST be no greater than the value of HdrDestPortEnd. A single port is indicated by equal values for HdrDestPortStart and HdrDestPortEnd.",
      "ja": "このプロパティは、UDPまたはTCP宛先ポートの範囲の下端を表す、16ビットの符号なし整数です。範囲の上端はHdrDestPortEndプロパティによって表されています。 HdrDestPortStartの値はHdrDestPortEndの値以下でなければなりません。単一ポートがHdrDestPortStartとHdrDestPortEndに対して等しい値で示されます。"
    },
    {
      "indent": 3,
      "text": "A destination port filter is evaluated by testing whether the destination port identified in the IP header falls within the range of values between HdrDestPortStart and HdrDestPortEnd, including these two end points.",
      "ja": "宛先ポートフィルタは、IPヘッダ内の識別された宛先ポートは、これら2つのエンドポイントを含むHdrDestPortStartとHdrDestPortEnd、の間の値の範囲内にあるかどうかを試験することによって評価されます。"
    },
    {
      "indent": 3,
      "text": "If a value for this property is not provided, then the filter does not consider HdrDestPortStart in selecting matching packets, i.e., there is no lower bound in matching destination port values.",
      "ja": "このプロパティの値が提供されていない場合、フィルタは、一致するパケットを選択する際にHdrDestPortStartを考慮していない、すなわち、宛先ポート値と一致でない下限は存在しません。"
    },
    {
      "indent": 0,
      "text": "6.19.12. The Property HdrDestPortEnd",
      "section_title": true,
      "ja": "6.19.12。プロパティHdrDestPortEnd"
    },
    {
      "indent": 3,
      "text": "This property is a 16-bit unsigned integer, representing the upper end of a range of UDP or TCP destination ports. The lower end of the range is represented by the HdrDestPortStart property. The value of HdrDestPortEnd MUST be no less than the value of HdrDestPortStart. A single port is indicated by equal values for HdrDestPortStart and HdrDestPortEnd.",
      "ja": "このプロパティは、UDPまたはTCP宛先ポートの範囲の上限を表す、16ビットの符号なし整数です。範囲の下端はHdrDestPortStartプロパティによって表されています。 HdrDestPortEndの値はHdrDestPortStartの値以上である必要があります。単一ポートがHdrDestPortStartとHdrDestPortEndに対して等しい値で示されます。"
    },
    {
      "indent": 3,
      "text": "A destination port filter is evaluated by testing whether the destination port identified in the IP header falls within the range of values between HdrDestPortStart and HdrDestPortEnd, including these two end points.",
      "ja": "宛先ポートフィルタは、IPヘッダ内の識別された宛先ポートは、これら2つのエンドポイントを含むHdrDestPortStartとHdrDestPortEnd、の間の値の範囲内にあるかどうかを試験することによって評価されます。"
    },
    {
      "indent": 3,
      "text": "If a value for this property is not provided, then the filter does not consider HdrDestPortEnd in selecting matching packets, i.e., there is no upper bound in matching destination port values.",
      "ja": "このプロパティの値が提供されていない場合、フィルタは、一致するパケットを選択する際にHdrDestPortEndを考慮していない、すなわち、宛先ポート値に一致するには上限がありません。"
    },
    {
      "indent": 0,
      "text": "6.19.13. The Property HdrDSCP",
      "section_title": true,
      "ja": "6.19.13。プロパティHdrDSCP"
    },
    {
      "indent": 3,
      "text": "The property HdrDSCP is defined as an array of uint8's, restricted to the range 0..63. Since DSCPs are defined as discrete code points, with no inherent structure, there is no semantically significant relationship between different DSCPs. Consequently, there is no provision for specifying a range of DSCPs in this property. However, a list of individual DSCPs, which are ORed together to form a filter, is supported by the array syntax.",
      "ja": "プロパティHdrDSCPは範囲0 63に制限UINT8年代のアレイとして定義されます。 DSCPがない固有の構造と、離散的なコードポイントとして定義されているので、別のDSCPとの間には意味的に有意な関係は存在しません。したがって、このプロパティでのDSCPの範囲を指定するための規定はありません。しかしながら、フィルタを形成するために一緒にORされ、個々のDSCPのリストは、配列構文に支持されています。"
    },
    {
      "indent": 3,
      "text": "If a value for this property is not provided, then the filter does not consider HdrDSCP in selecting matching packets, i.e., HdrDSCP matches for all values.",
      "ja": "このプロパティの値が提供されていない場合、フィルタは、一致するパケットを選択するHdrDSCP考慮していない、すなわち、HdrDSCPはすべての値について一致します。"
    },
    {
      "indent": 0,
      "text": "6.19.14. The Property HdrFlowLabel",
      "section_title": true,
      "ja": "6.19.14。プロパティHdrFlowLabel"
    },
    {
      "indent": 3,
      "text": "The 20-bit Flow Label field in the IPv6 header may be used by a source to label sequences of packets for which it requests special handling by IPv6 devices, such as non-default quality of service or 'real-time' service. This property is an octet string of size 3 (that is, 24 bits), in which the 20-bit Flow Label appears in the rightmost 20 bits, padded on the left with b'0000'.",
      "ja": "IPv6ヘッダーの20ビットのフローラベルフィールドは、デフォルト以外のサービス品質や「リアルタイム」サービスとして、それはIPv6デバイスによる特別な処理を要求するためのパケットのシーケンスにラベルを付けるためにソースによって使用することができます。このプロパティは、サイズ3のオクテット列である（すなわち、24ビット）、20ビットのフローラベルは、右端の20ビットで表示される、B'0000' で左側に埋め。"
    },
    {
      "indent": 3,
      "text": "If a value for this property is not provided, then the filter does not consider HdrFlowLabel in selecting matching packets, i.e., HdrFlowLabel matches for all values.",
      "ja": "このプロパティの値が提供されていない場合、フィルタは、一致するパケットを選択する際にHdrFlowLabelを考慮していない、すなわち、HdrFlowLabelはすべての値について一致します。"
    },
    {
      "indent": 0,
      "text": "6.20. The Class \"8021Filter\"",
      "section_title": true,
      "ja": "6.20。クラス「8021Filter」"
    },
    {
      "indent": 3,
      "text": "This concrete class allows 802.1.source and destination MAC addresses, as well as the 802.1 protocol ID, priority, and VLAN identifier fields, to be expressed in a single object",
      "ja": "この具体的なクラスは、単一のオブジェクト内で発現される802.1.sourceと宛先MACアドレス、ならびに802.1プロトコルID、優先度、およびVLAN識別子フィールドを、可能にします"
    },
    {
      "indent": 3,
      "text": "The class definition is as follows:",
      "ja": "次のようにクラス定義は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "NAME 8021Filter DESCRIPTION A class that allows 802.1 source and destination MAC address and protocol ID, priority, and VLAN identifier filters to be expressed in a single object. DERIVED FROM FilterEntryBase TYPE Concrete PROPERTIES 8021HdrSrcMACAddr, 8021HdrSrcMACMask, 8021HdrDestMACAddr, 8021HdrDestMACMask, 8021HdrProtocolID, 8021HdrPriorityValue, 8021HDRVLANID",
      "ja": "802.1元および宛先MACアドレス、プロトコルID、優先度、およびVLAN識別子フィルタは単一のオブジェクトで表現されることを可能にするクラスを8021Filter説明名前。 FilterEntryBaseのTYPEコンクリートPROPERTIES 8021HdrSrcMACAddr、8021HdrSrcMACMask、8021HdrDestMACAddr、8021HdrDestMACMask、8021HdrProtocolID、8021HdrPriorityValue、8021HDRVLANIDから、派生"
    },
    {
      "indent": 0,
      "text": "6.20.1. The Property 8021HdrSrcMACAddr",
      "section_title": true,
      "ja": "6.20.1。プロパティ8021HdrSrcMACAddr"
    },
    {
      "indent": 3,
      "text": "This property is an OctetString of size 6, representing a 48-bit source MAC address in canonical format. This value is compared to the SourceAddress field in the MAC header, subject to the mask represented in the 8021HdrSrcMACMask property.",
      "ja": "このプロパティは、標準フォーマットで48ビットのソースMACアドレスを表す、サイズ6のOctetStringにあります。この値は8021HdrSrcMACMaskプロパティで表されるマスクの対象MACヘッダ内SourceAddressフィールドと比較されます。"
    },
    {
      "indent": 3,
      "text": "If a value for this property is not provided, then the filter does not consider 8021HdrSrcMACAddr in selecting matching packets, i.e., 8021HdrSrcMACAddr matches for all values.",
      "ja": "このプロパティの値が提供されていない場合、フィルタは、一致するパケットを選択する際に8021HdrSrcMACAddrを考慮していない、すなわち、8021HdrSrcMACAddrはすべての値について一致します。"
    },
    {
      "indent": 0,
      "text": "6.20.2. The Property 8021HdrSrcMACMask",
      "section_title": true,
      "ja": "6.20.2。プロパティ8021HdrSrcMACMask"
    },
    {
      "indent": 3,
      "text": "This property is an OctetString of size 6, representing a 48-bit mask to be used in comparing the SourceAddress field in the MAC header with the value represented in the 8021HdrSrcMACAddr property.",
      "ja": "このプロパティは、8021HdrSrcMACAddrプロパティで表される値でMACヘッダにSourceAddressフィールドを比較する際に使用される48ビットマスクを表す、サイズ6のOctetStringにあります。"
    },
    {
      "indent": 3,
      "text": "If a value for this property is not provided, then the filter does not consider 8021HdrSrcMACMask in selecting matching packets, i.e., the value of 8021HdrSrcMACAddr must match the source MAC address in the packet exactly.",
      "ja": "このプロパティの値が提供されていない場合、フィルタは、一致するパケットを選択する際に8021HdrSrcMACMaskを考慮していない、すなわち、8021HdrSrcMACAddrの値が正確にパケットの送信元MACアドレスと一致しなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.20.3. The Property 8021HdrDestMACAddr",
      "section_title": true,
      "ja": "6.20.3。プロパティ8021HdrDestMACAddr"
    },
    {
      "indent": 3,
      "text": "This property is an OctetString of size 6, representing a 48-bit destination MAC address in canonical format. This value is compared to the DestinationAddress field in the MAC header, subject to the mask represented in the 8021HdrDestMACMask property.",
      "ja": "このプロパティは、標準フォーマットで48ビットの宛先MACアドレスを表す、サイズ6のOctetStringにあります。この値は8021HdrDestMACMaskプロパティで表されるマスクの対象MACヘッダ内の宛先アドレスフィールドと比較されます。"
    },
    {
      "indent": 3,
      "text": "If a value for this property is not provided, then the filter does not consider 8021HdrDestMACAddr in selecting matching packets, i.e., 8021HdrDestMACAddr matches for all values.",
      "ja": "このプロパティの値が提供されていない場合、フィルタは、一致するパケットを選択する際に8021HdrDestMACAddrを考慮していない、すなわち、8021HdrDestMACAddrはすべての値について一致します。"
    },
    {
      "indent": 0,
      "text": "6.20.4. The Property 8021HdrDestMACMask",
      "section_title": true,
      "ja": "6.20.4。プロパティ8021HdrDestMACMask"
    },
    {
      "indent": 3,
      "text": "This property is an OctetString of size 6, representing a 48-bit mask to be used in comparing the DestinationAddress field in the MAC header with the value represented in the 8021HdrDestMACAddr property.",
      "ja": "このプロパティは、8021HdrDestMACAddrプロパティで表される値でMACヘッダに宛先アドレスフィールドを比較する際に使用される48ビットマスクを表す、サイズ6のOctetStringにあります。"
    },
    {
      "indent": 3,
      "text": "If a value for this property is not provided, then the filter does not consider 8021HdrDestMACMask in selecting matching packets, i.e., the value of 8021HdrDestMACAddr must match the destination MAC address in the packet exactly.",
      "ja": "このプロパティの値が提供されていない場合、フィルタは、一致するパケットを選択する際に8021HdrDestMACMaskを考慮していない、すなわち、8021HdrDestMACAddrの値が正確にパケットの宛先MACアドレスと一致しなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.20.5. The Property 8021HdrProtocolID",
      "section_title": true,
      "ja": "6.20.5。プロパティ8021HdrProtocolID"
    },
    {
      "indent": 3,
      "text": "This property is a 16-bit unsigned integer, representing an Ethernet protocol type. This value is compared to the Ethernet Type field in the 802.3 MAC header.",
      "ja": "このプロパティは、イーサネット・プロトコル・タイプを表す、16ビットの符号なし整数です。この値は802.3 MACヘッダのイーサネットタイプフィールドと比較されます。"
    },
    {
      "indent": 3,
      "text": "If a value for this property is not provided, then the filter does not consider 8021HdrProtocolID in selecting matching packets, i.e., 8021HdrProtocolID matches for all values.",
      "ja": "このプロパティの値が提供されていない場合、フィルタは、一致するパケットを選択する際に8021HdrProtocolIDを考慮していない、すなわち、8021HdrProtocolIDはすべての値について一致します。"
    },
    {
      "indent": 0,
      "text": "6.20.6. The Property 8021HdrPriorityValue",
      "section_title": true,
      "ja": "6.20.6。プロパティ8021HdrPriorityValue"
    },
    {
      "indent": 3,
      "text": "This property is an 8-bit unsigned integer, representing an 802.1Q priority. This value is compared to the Priority field in the 802.1Q header. Since the 802.1Q Priority field consists of 3 bits, the values for this property are limited to the range 0..7.",
      "ja": "このプロパティは、802.1Qの優先順位を表す8ビットの符号なし整数です。この値は、802.1Qヘッダーの優先度フィールドと比較されます。 802.1Qプライオリティフィールドは3ビットで構成されているため、このプロパティの値は、範囲0..7に限定されています。"
    },
    {
      "indent": 3,
      "text": "If a value for this property is not provided, then the filter does not consider 8021HdrPriorityValue in selecting matching packets, i.e., 8021HdrPriorityValue matches for all values.",
      "ja": "このプロパティの値が提供されていない場合、フィルタは、一致するパケットを選択する際に8021HdrPriorityValueを考慮していない、すなわち、8021HdrPriorityValueはすべての値について一致します。"
    },
    {
      "indent": 0,
      "text": "6.20.7. The Property 8021HdrVLANID",
      "section_title": true,
      "ja": "6.20.7。プロパティ8021HdrVLANID"
    },
    {
      "indent": 3,
      "text": "This property is a 32-bit unsigned integer, representing an 802.1Q VLAN Identifier. This value is compared to the VLAN ID field in the 802.1Q header. Since the 802.1Q VLAN ID field consists of 12 bits, the values for this property are limited to the range 0..4095.",
      "ja": "このプロパティは、802.1Q VLAN識別子を表す、32ビットの符号なし整数です。この値は、802.1QヘッダーのVLAN IDフィールドと比較されます。 802.1Q VLAN IDフィールドは12ビットで構成されているため、このプロパティの値は、範囲0 4095に限定されます。"
    },
    {
      "indent": 3,
      "text": "If a value for this property is not provided, then the filter does not consider 8021HdrVLANID in selecting matching packets, i.e., 8021HdrVLANID matches for all values.",
      "ja": "このプロパティの値が提供されていない場合、フィルタは、一致するパケットを選択する際に8021HdrVLANIDを考慮していない、すなわち、8021HdrVLANIDはすべての値について一致します。"
    },
    {
      "indent": 0,
      "text": "6.21. The Class FilterList",
      "section_title": true,
      "ja": "6.21。クラスFilterList"
    },
    {
      "indent": 3,
      "text": "This is a concrete class that aggregates instances of (subclasses of) FilterEntryBase via the aggregation EntriesInFilterList. It is possible to aggregate different types of filters into a single FilterList - for example, packet header filters (represented by the IpHeadersFilter class) and security filters (represented by subclasses of FilterEntryBase defined by IPsec).",
      "ja": "これは、集約EntriesInFilterList介しFilterEntryBase（のサブクラス）のインスタンスを集約する具象クラスです。例えば、（IpHeadersFilterクラスによって表される）は、パケットヘッダのフィルタとセキュリティフィルタ（IPSecで定義FilterEntryBaseのサブクラスによって表される） - 単一FilterListにフィルタの種類を集約することが可能です。"
    },
    {
      "indent": 3,
      "text": "The aggregation property EntriesInFilterList.EntrySequence is always set to 0, to indicate that the aggregated filter entries are ANDed together to form a selector for a class of traffic.",
      "ja": "凝集性のEntriesInFilterList.EntrySequenceは常に集約フィルタエントリは、トラフィックのクラスのセレクタを形成するために一緒にAND演算されることを示すために、0に設定されています。"
    },
    {
      "indent": 3,
      "text": "The class definition is as follows:",
      "ja": "次のようにクラス定義は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "NAME FilterList DESCRIPTION A concrete class representing the aggregation of multiple filters. DERIVED FROM LogicalElement TYPE Concrete PROPERTIES Direction",
      "ja": "複数のフィルタの集合を表す名前FilterList説明A具象クラス。 LogicalElement TYPEコンクリートPROPERTIES方向から派生"
    },
    {
      "indent": 0,
      "text": "6.21.1. The Property Direction",
      "section_title": true,
      "ja": "6.21.1。プロパティの方向"
    },
    {
      "indent": 3,
      "text": "This property is a 16-bit unsigned integer enumeration, representing the direction of the traffic flow to which the FilterList is to be applied. Defined enumeration values are",
      "ja": "このプロパティは、FilterListが適用されるトラフィックフローの方向を示す、16ビットの符号なし整数の列挙です。定義された列挙値です"
    },
    {
      "indent": 3,
      "text": "o NotApplicable(0) o Input(1) o Output(2) o Both(3) - This value is used to indicate that the direction is immaterial, e.g., to filter on a source subnet regardless of whether the flow is inbound or outbound o Mirrored(4) - This value is also applicable to both inbound and outbound flow processing, but it indicates that the filter criteria are applied asymmetrically to traffic in both directions and, thus, specifies the reversal of source and destination criteria (as opposed to the equality of these criteria as indicated by \"Both\"). The match conditions in the aggregated FilterEntryBase subclass instances are defined from the perspective of outbound flows and applied to inbound flows as well by reversing the source and destination criteria. So, for example, consider a FilterList with 3 filter entries indicating destination port = 80, and source and destination addresses of a and b, respectively. Then, for the outbound direction, the filter entries match as specified and the 'mirror' (for the inbound direction) matches on source port = 80 and source and destination addresses of b and a, respectively.",
      "ja": "O出力O（0）、入力（1）O NotApplicable（2）の両方（3）O  - この値は関係なく、流れがインバウンドまたはアウトバウンドであるか否かのソースサブネットにフィルタリングするために、例えば、方向は重要でないことを示すために使用されOミラー（4） - この値は、両方のインバウンドとアウトバウンドのフロー処理にも適用可能であるが、それは、フィルタ基準は、両方向のトラフィックに対して非対称に適用されていることを示しており、従って、とは対照的に（送信元と宛先の基準の反転を指定します「両方」で示されるように、これらの基準の平等）。凝集FilterEntryBaseサブクラスのインスタンスに一致条件は、アウトバウンドフローの観点から定義され、ソース及び宛先基準を逆にしてもインバウンドフローに適用されます。だから、例えば、それぞれ、3つの= 80宛先ポートを示すフィルタエントリ、および送信元と宛先のアドレスとBとFilterListを考えます。次いで、アウトバウンド方向のために、フィルタエントリが指定されている一致し、（インバウンド方向用）「ミラー」は、それぞれ、送信元ポート= 80、bの送信元アドレスと宛先アドレスとに一致します。"
    },
    {
      "indent": 0,
      "text": "7. Association and Aggregation Definitions",
      "section_title": true,
      "ja": "7.協会と集約の定義"
    },
    {
      "indent": 3,
      "text": "The following definitions supplement those in PCIM itself. PCIM definitions that are not DEPRECATED here are still current parts of the overall Policy Core Information Model.",
      "ja": "以下の定義は、PCIM自身でそれらを補完します。ここでは非推奨されていないPCIM定義はまだ全体的な方針コア情報モデルの現在の部分です。"
    },
    {
      "indent": 0,
      "text": "7.1. The Aggregation \"PolicySetComponent\"",
      "section_title": true,
      "ja": "7.1。集計「PolicySetComponent」"
    },
    {
      "indent": 3,
      "text": "PolicySetComponent is a new aggregation class that collects instances of PolicySet subclasses (PolicyGroups and PolicyRules) into coherent sets of policies.",
      "ja": "PolicySetComponentは、政策の一貫性セットにPOLICYSETサブクラス（PolicyGroupsとPolicyRules）のインスタンスを収集し、新たな集約クラスです。"
    },
    {
      "indent": 3,
      "text": "NAME PolicySetComponent DESCRIPTION A concrete class representing the components of a policy set that have the same decision strategy, and are prioritized within the set. DERIVED FROM PolicyComponent ABSTRACT FALSE PROPERTIES GroupComponent[ref PolicySet[0..n]] PartComponent[ref PolicySet[0..n]] Priority",
      "ja": "同じ決定戦略を有し、セット内で優先順位付けされたポリシー・セットの構成要素を表すNAME PolicySetComponent説明A具象クラス。 PolicyComponent ABSTRACT FALSEの施設から派生GroupComponent PartComponent [POLICYSET [0..N]参照]優先[POLICYSET [0..N]参照]"
    },
    {
      "indent": 3,
      "text": "The definition of the Priority property is unchanged from its previous definition in [PCIM].",
      "ja": "Priorityプロパティの定義は、[PCIM]でその前の定義から変更されていません。"
    },
    {
      "indent": 3,
      "text": "NAME Priority DESCRIPTION A non-negative integer for prioritizing this PolicySet component relative to other components of the same PolicySet. A larger value indicates a higher priority. SYNTAX uint16 DEFAULT VALUE 0",
      "ja": "NAME優先DESCRIPTION同じPOLICYSETの他の構成要素に対するこのPOLICYSET成分の相対的な優先順位付けするための非負整数。大きな値は、より高い優先度を示します。構文uint16のデフォルト値0"
    },
    {
      "indent": 0,
      "text": "7.2. Deprecate PCIM's Aggregation \"PolicyGroupInPolicyGroup\"",
      "section_title": true,
      "ja": "7.2。廃止PCIMの集約「PolicyGroupInPolicyGroup」"
    },
    {
      "indent": 3,
      "text": "The new aggregation PolicySetComponent is used directly to represent aggregation of PolicyGroups by a higher-level PolicyGroup. Thus the aggregation PolicyGroupInPolicyGroup is no longer needed, and can be deprecated.",
      "ja": "新しい集約PolicySetComponentは、より高いレベルのPolicyGroupによってPolicyGroupsの集合を表現するために直接使用されます。このように集約PolicyGroupInPolicyGroupは不要になり、かつ非推奨することができます。"
    },
    {
      "indent": 3,
      "text": "NAME PolicyGroupInPolicyGroup DEPRECATED FOR PolicySetComponent DESCRIPTION A class representing the aggregation of PolicyGroups by a higher-level PolicyGroup. DERIVED FROM PolicyComponent ABSTRACT FALSE PROPERTIES GroupComponent[ref PolicyGroup[0..n]] PartComponent[ref PolicyGroup[0..n]]",
      "ja": "PolicySetComponent説明の名前PolicyGroupInPolicyGroup DEPRECATED上位のPolicyGroupによってPolicyGroupsの集合を表すクラス。 PolicyComponent ABSTRACT FALSE施設から派生GroupComponent [参考文献のPolicyGroup [0..N] PartComponent [参考文献のPolicyGroup [0..N]"
    },
    {
      "indent": 0,
      "text": "7.3. Deprecate PCIM's Aggregation \"PolicyRuleInPolicyGroup\"",
      "section_title": true,
      "ja": "7.3。廃止PCIMの集約「PolicyRuleInPolicyGroup」"
    },
    {
      "indent": 3,
      "text": "The new aggregation PolicySetComponent is used directly to represent aggregation of PolicyRules by a PolicyGroup. Thus the aggregation PolicyRuleInPolicyGroup is no longer needed, and can be deprecated.",
      "ja": "新しい集約PolicySetComponentはのPolicyGroupによってPolicyRulesの凝集を表現するために直接使用されます。このように集約PolicyRuleInPolicyGroupは不要になり、かつ非推奨することができます。"
    },
    {
      "indent": 3,
      "text": "NAME PolicyRuleInPolicyGroup DEPRECATED FOR PolicySetComponent DESCRIPTION A class representing the aggregation of PolicyRules by a PolicyGroup. DERIVED FROM PolicyComponent",
      "ja": "PolicySetComponent説明の名前PolicyRuleInPolicyGroup DEPRECATEDのPolicyGroupによってPolicyRulesの集合を表すクラス。 PolicyComponentから、派生"
    },
    {
      "indent": 3,
      "text": "ABSTRACT FALSE PROPERTIES GroupComponent[ref PolicyGroup[0..n]] PartComponent[ref PolicyRule[0..n]]",
      "ja": "ABSTRACT FALSE PROPERTIES GroupComponent [参考文献のPolicyGroup [0..N] PartComponent [参考文献のPolicyRule [0..N]"
    },
    {
      "indent": 0,
      "text": "7.4. The Abstract Association \"PolicySetInSystem\"",
      "section_title": true,
      "ja": "7.4。抽象協会「PolicySetInSystem」"
    },
    {
      "indent": 3,
      "text": "PolicySetInSystem is a new association that defines a relationship between a System and a PolicySet used in the administrative scope of that system (e.g., AdminDomain, ComputerSystem). The Priority property is used to assign a relative priority to a PolicySet within the administrative scope in contexts where it is not a component of another PolicySet.",
      "ja": "PolicySetInSystemは、システムとそのシステムの管理範囲（例えば、いるAdminDomain、のComputerSystem）で使用POLICYSETとの間の関係を定義する新しい関連付けです。優先性は、それが別のPOLICYSETの成分ではない状況での管理範囲内POLICYSETに相対的な優先順位を割り当てるために使用されます。"
    },
    {
      "indent": 3,
      "text": "NAME PolicySetInSystem DESCRIPTION An abstract class representing the relationship between a System and a PolicySet that is used in the administrative scope of the System. DERIVED FROM PolicyInSystem ABSTRACT TRUE PROPERTIES Antecedent[ref System[0..1]] Dependent [ref PolicySet[0..n]] Priority",
      "ja": "システムおよびシステムの管理範囲で使用されるPOLICYSETとの関係を表す名前PolicySetInSystem説明抽象クラス。 PolicyInSystem ABSTRACT TRUE PROPERTIES前例[審判システム[0..1]]依存[参照POLICYSET [0..N]]の優先順位から派生して"
    },
    {
      "indent": 3,
      "text": "The Priority property is used to specify the relative priority of the referenced PolicySet when there are more than one PolicySet instances applied to a managed resource that are not PolicySetComponents and, therefore, have no other relative priority defined.",
      "ja": "優先性はPolicySetComponentsなく、したがって、他の相対的な優先順位が定義されていない管理対象リソースに適用される複数のPOLICYSETインスタンスがある場合、参照POLICYSETの相対優先順位を指定するために使用されます。"
    },
    {
      "indent": 3,
      "text": "NAME Priority DESCRIPTION A non-negative integer for prioritizing the referenced PolicySet among other PolicySet instances that are not components of a common PolicySet. A larger value indicates a higher priority. SYNTAX uint16 DEFAULT VALUE 0",
      "ja": "NAME優先説明共通POLICYSETのコンポーネントではない他のPOLICYSETインスタンス間参照POLICYSETに優先順位を付けるための非負整数。大きな値は、より高い優先度を示します。構文uint16のデフォルト値0"
    },
    {
      "indent": 0,
      "text": "7.5. Update PCIM's Weak Association \"PolicyGroupInSystem\"",
      "section_title": true,
      "ja": "7.5。更新PCIMの弱い協会「PolicyGroupInSystem」"
    },
    {
      "indent": 3,
      "text": "Regardless of whether it a component of another PolicySet, a PolicyGroup is itself defined within the scope of a System. This association links a PolicyGroup to the System in whose scope the PolicyGroup is defined. It is a subclass of the abstract PolicySetInSystem association. The class definition for the association is as follows:",
      "ja": "かかわらず、別のPOLICYSETのコンポーネントかどうか、のPolicyGroupは、システムの範囲内で定義そのものです。この関連付けはのPolicyGroupが定義されているその範囲でのシステムへのPolicyGroupをリンクします。これは、抽象PolicySetInSystem協会のサブクラスです。次のように協会のためのクラス定義は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "NAME PolicyGroupInSystem DESCRIPTION A class representing the fact that a PolicyGroup is defined within the scope of a System. DERIVED FROM PolicySetInSystem ABSTRACT FALSE PROPERTIES Antecedent[ref System[1..1]] Dependent [ref PolicyGroup[weak]]",
      "ja": "NAME PolicyGroupInSystem DESCRIPTIONのPolicyGroupがシステムの範囲内で定義されていることを表すクラス。 PolicySetInSystem ABSTRACT FALSE施設から派生前例[REFシステム[1..1]依存性[参考文献のPolicyGroup [弱]"
    },
    {
      "indent": 3,
      "text": "The Reference \"Antecedent\" is inherited from PolicySetInSystem, and overridden to restrict its cardinality to [1..1]. It serves as an object reference to a System that provides a scope for one or more PolicyGroups. Since this is a weak association, the cardinality for this object reference is always 1, that is, a PolicyGroup is always defined within the scope of exactly one System.",
      "ja": "リファレンス「という先行詞は」PolicySetInSystemから継承された、および[1..1]にカーディナリティを制限するためにオーバーライドされます。これは、1つまたは複数のPolicyGroupsのスコープを提供するシステムへのオブジェクト参照として機能します。これは、弱い関連があるので、このオブジェクト参照の基数はのPolicyGroupは、常に正確に一つのシステムの範囲内で定義されている、つまり、常に1です。"
    },
    {
      "indent": 3,
      "text": "The Reference \"Dependent\" is inherited from PolicySetInSystem, and overridden to become an object reference to a PolicyGroup defined within the scope of a System. Note that for any single instance of the association class PolicyGroupInSystem, this property (like all reference properties) is single-valued. The [0..n] cardinality indicates that a given System may have 0, 1, or more than one PolicyGroups defined within its scope.",
      "ja": "参照「依存」はPolicySetInSystemから継承、及びシステムの範囲内で定義されたPolicyGroupへのオブジェクト参照になるように無視されています。関連クラスPolicyGroupInSystemの任意の単一のインスタンスに対して、（すべての参照プロパティのような）このプロパティは単一値であることに留意されたいです。 [0..N]基数は、与えられたシステムは、その範囲内に定義された0,1、または複数のPolicyGroupsを有することができることを示しています。"
    },
    {
      "indent": 0,
      "text": "7.6. Update PCIM's Weak Association \"PolicyRuleInSystem\"",
      "section_title": true,
      "ja": "7.6。更新PCIMの弱い協会「PolicyRuleInSystem」"
    },
    {
      "indent": 3,
      "text": "Regardless of whether it a component of another PolicySet, a PolicyRule is itself defined within the scope of a System. This association links a PolicyRule to the System in whose scope the PolicyRule is defined. It is a subclass of the abstract PolicySetInSystem association. The class definition for the association is as follows:",
      "ja": "かかわらず、別のPOLICYSETのコンポーネントかどうか、のPolicyRuleは、システムの範囲内で定義そのものです。この協会はPolicyRuleのが定義されているその範囲でのシステムへのPolicyRuleをリンクします。これは、抽象PolicySetInSystem協会のサブクラスです。次のように協会のためのクラス定義は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "NAME PolicyRuleInSystem DESCRIPTION A class representing the fact that a PolicyRule is defined within the scope of a System. DERIVED FROM PolicySetInSystem ABSTRACT FALSE PROPERTIES Antecedent[ref System[1..1]] Dependent[ref PolicyRule[weak]]",
      "ja": "PolicyRuleInSystem説明をPolicyRuleのは、システムの範囲内で定義されていることを表すクラスに名前を付けます。 PolicySetInSystem抽象FALSE PROPERTIES前例[REFシステム[1..1]依存性[参考文献のPolicyRule [弱]から、派生"
    },
    {
      "indent": 3,
      "text": "The Reference \"Antecedent\" is inherited from PolicySetInSystem, and overridden to restrict its cardinality to [1..1]. It serves as an object reference to a System that provides a scope for one or more PolicyRules. Since this is a weak association, the cardinality for this object reference is always 1, that is, a PolicyRule is always defined within the scope of exactly one System.",
      "ja": "リファレンス「という先行詞は」PolicySetInSystemから継承された、および[1..1]にカーディナリティを制限するためにオーバーライドされます。これは、1つまたは複数のPolicyRulesのスコープを提供するシステムへのオブジェクト参照として機能します。これは、弱い関連があるので、このオブジェクト参照の基数はPolicyRuleのは常に1つのシステムの範囲内で定義されている、つまり、常に1です。"
    },
    {
      "indent": 3,
      "text": "The Reference \"Dependent\" is inherited from PolicySetInSystem, and overridden to become an object reference to a PolicyRule defined within the scope of a System. Note that for any single instance of the association class PolicyRuleInSystem, this property (like all Reference properties) is single-valued. The [0..n] cardinality indicates that a given System may have 0, 1, or more than one PolicyRules defined within its scope.",
      "ja": "参照「依存」はPolicySetInSystemから継承、及びシステムの範囲内で定義されたPolicyRuleへのオブジェクト参照になるように無視されています。関連クラスPolicyRuleInSystemの任意の単一のインスタンスに対して、（すべての参照プロパティのような）このプロパティは単一値であることに留意されたいです。 [0..N]基数は、与えられたシステムは、その範囲内に定義された0,1、または複数のPolicyRulesを有することができることを示しています。"
    },
    {
      "indent": 0,
      "text": "7.7. The Abstract Aggregation \"PolicyConditionStructure\"",
      "section_title": true,
      "ja": "7.7。抽象集約「PolicyConditionStructure」"
    },
    {
      "indent": 0,
      "text": " NAME PolicyConditionStructure DESCRIPTION A class representing the aggregation of PolicyConditions by an aggregating instance. DERIVED FROM PolicyComponent ABSTRACT TRUE PROPERTIES PartComponent[ref PolicyCondition[0..n]] GroupNumber ConditionNegated 7.8. Update PCIM's Aggregation \"PolicyConditionInPolicyRule\"",
      "ja": "NAME PolicyConditionStructure DESCRIPTION凝集インスタンスによってPolicyConditionsの集合を表すクラス。 PolicyComponent ABSTRACT TRUE PROPERTIES PartComponentから、派生[REF PolicyCondition [0..N] GroupNumberは7.8 ConditionNegated。更新PCIMの集約「PolicyConditionInPolicyRule」"
    },
    {
      "indent": 3,
      "text": "The PCIM aggregation \"PolicyConditionInPolicyRule\" is updated, to make it a subclass of the new abstract aggregation PolicyConditionStructure. The properties GroupNumber and ConditionNegated are now inherited, rather than specified explicitly as they were in PCIM.",
      "ja": "PCIM集約「PolicyConditionInPolicyRuleは」それ、新たな抽象集約PolicyConditionStructureのサブクラスにするために、更新されます。プロパティGroupNumberとConditionNegatedは今、彼らはPCIMであったように明示的に指定するのではなく、継承されています。"
    },
    {
      "indent": 3,
      "text": "NAME PolicyConditionInPolicyRule DESCRIPTION A class representing the aggregation of PolicyConditions by a PolicyRule. DERIVED FROM PolicyConditionStructure ABSTRACT FALSE PROPERTIES GroupComponent[ref PolicyRule[0..n]]",
      "ja": "NAME PolicyConditionInPolicyRule DESCRIPTIONのPolicyRuleによってPolicyConditionsの集合を表すクラス。 PolicyConditionStructure ABSTRACT FALSEの施設から派生GroupComponent [参照のPolicyRule [0..N]]"
    },
    {
      "indent": 0,
      "text": "7.9. The Aggregation \"PolicyConditionInPolicyCondition\"",
      "section_title": true,
      "ja": "7.9。集計「PolicyConditionInPolicyCondition」"
    },
    {
      "indent": 3,
      "text": "A second subclass of PolicyConditionStructure is defined, representing the compounding of policy conditions into a higher-level policy condition.",
      "ja": "PolicyConditionStructureの第二のサブクラスは、より高いレベルのポリシー条件にポリシー条件の配合を表す、定義されています。"
    },
    {
      "indent": 3,
      "text": "NAME PolicyConditionInPolicyCondition DESCRIPTION A class representing the aggregation of PolicyConditions by another PolicyCondition. DERIVED FROM PolicyConditionStructure ABSTRACT FALSE PROPERTIES GroupComponent[ref CompoundPolicyCondition[0..n]]",
      "ja": "NAME PolicyConditionInPolicyCondition DESCRIPTION別のPolicyConditionによってPolicyConditionsの集合を表すクラス。 PolicyConditionStructure ABSTRACT FALSEの施設から派生GroupComponent [参照CompoundPolicyCondition [0..N]]"
    },
    {
      "indent": 0,
      "text": "7.10. The Abstract Aggregation \"PolicyActionStructure\"",
      "section_title": true,
      "ja": "7.10。抽象集約「PolicyActionStructure」"
    },
    {
      "indent": 3,
      "text": "NAME PolicyActionStructure DESCRIPTION A class representing the aggregation of PolicyActions by an aggregating instance. DERIVED FROM PolicyComponent ABSTRACT TRUE PROPERTIES PartComponent[ref PolicyAction[0..n]] ActionOrder",
      "ja": "NAME PolicyActionStructure DESCRIPTION凝集インスタンスによってPolicyActionsの集合を表すクラス。 PolicyComponent ABSTRACT TRUE PROPERTIES PartComponentから派生して、[参照PolicyAction [0..N]] ActionOrder"
    },
    {
      "indent": 3,
      "text": "The definition of the ActionOrder property appears in Section 7.8.3 of PCIM [1].",
      "ja": "ActionOrderプロパティの定義は、PCIMのセクション7.8.3 [1]に表示されます。"
    },
    {
      "indent": 0,
      "text": "7.11. Update PCIM's Aggregation \"PolicyActionInPolicyRule\"",
      "section_title": true,
      "ja": "7.11。更新PCIMの集約「PolicyActionInPolicyRule」"
    },
    {
      "indent": 3,
      "text": "The PCIM aggregation \"PolicyActionInPolicyRule\" is updated, to make it a subclass of the new abstract aggregation PolicyActionStructure. The property ActionOrder is now inherited, rather than specified explicitly as it was in PCIM.",
      "ja": "PCIM集約「PolicyActionInPolicyRuleは」それ、新たな抽象集約PolicyActionStructureのサブクラスにするために、更新されます。プロパティActionOrderは今継承ではなく、それはPCIMにあったように明示的に指定されています。"
    },
    {
      "indent": 3,
      "text": "NAME PolicyActionInPolicyRule DESCRIPTION A class representing the aggregation of PolicyActions by a PolicyRule. DERIVED FROM PolicyActionStructure ABSTRACT FALSE PROPERTIES GroupComponent[ref PolicyRule[0..n]]",
      "ja": "NAME PolicyActionInPolicyRule DESCRIPTIONのPolicyRuleによってPolicyActionsの集合を表すクラス。 PolicyActionStructure ABSTRACT FALSEの施設から派生GroupComponent [参照のPolicyRule [0..N]]"
    },
    {
      "indent": 0,
      "text": "7.12. The Aggregation \"PolicyActionInPolicyAction\"",
      "section_title": true,
      "ja": "7.12。集計「PolicyActionInPolicyAction」"
    },
    {
      "indent": 3,
      "text": "A second subclass of PolicyActionStructure is defined, representing the compounding of policy actions into a higher-level policy action.",
      "ja": "PolicyActionStructureの第二のサブクラスは、より高いレベルのポリシーアクションにポリシーアクションの配合を表す、定義されています。"
    },
    {
      "indent": 3,
      "text": "NAME PolicyActionInPolicyAction DESCRIPTION A class representing the aggregation of PolicyActions by another PolicyAction. DERIVED FROM PolicyActionStructure ABSTRACT FALSE PROPERTIES GroupComponent[ref CompoundPolicyAction[0..n]]",
      "ja": "NAME PolicyActionInPolicyAction DESCRIPTION別のPolicyActionによってPolicyActionsの集合を表すクラス。 PolicyActionStructure ABSTRACT FALSEの施設から派生GroupComponent [参照CompoundPolicyAction [0..N]]"
    },
    {
      "indent": 0,
      "text": "7.13. The Aggregation \"PolicyVariableInSimplePolicyCondition\"",
      "section_title": true,
      "ja": "7.13。集計「PolicyVariableInSimplePolicyCondition」"
    },
    {
      "indent": 3,
      "text": "A simple policy condition is represented as an ordered triplet {variable, operator, value}. This aggregation provides the linkage between a SimplePolicyCondition instance and a single PolicyVariable. The aggregation PolicyValueInSimplePolicyCondition links the SimplePolicyCondition to a single PolicyValue. The Operator property of SimplePolicyCondition represents the third element of the triplet, the operator.",
      "ja": "単純なポリシー条件は、順序付けられたトリプレット{変数、演算子、値}として表されます。この凝集はSimplePolicyConditionインスタンスと単一PolicyVariable間の連結を提供します。集約PolicyValueInSimplePolicyConditionは、単一PolicyValueにSimplePolicyConditionをリンクします。 SimplePolicyConditionのオペレータプロパティはトリプレット、オペレータの3番目の要素を表します。"
    },
    {
      "indent": 3,
      "text": "The class definition for this aggregation is as follows:",
      "ja": "次のように、この集約のためのクラス定義は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "NAME PolicyVariableInSimplePolicyCondition DERIVED FROM PolicyComponent ABSTRACT False PROPERTIES GroupComponent[ref SimplePolicyCondition[0..n]] PartComponent[ref PolicyVariable[1..1] ]",
      "ja": "PolicyComponent ABSTRACT偽施設から派生名称PolicyVariableInSimplePolicyCondition GroupComponent PartComponent [SimplePolicyCondition [0..N]参考文献] [PolicyVariable [1..1]参考文献]"
    },
    {
      "indent": 3,
      "text": "The reference property \"GroupComponent\" is inherited from PolicyComponent, and overridden to become an object reference to a SimplePolicyCondition that contains exactly one PolicyVariable. Note that for any single instance of the aggregation class PolicyVariableInSimplePolicyCondition, this property is single-valued. The [0..n] cardinality indicates that there may be 0, 1, or more SimplePolicyCondition objects that contain any given policy variable object.",
      "ja": "参照プロパティ「GroupComponent」は正確に一つのPolicyVariableが含まれていSimplePolicyConditionへのオブジェクト参照になるようにPolicyComponentから継承され、オーバーライドされています。集約クラスPolicyVariableInSimplePolicyConditionの任意の単一のインスタンスに対して、このプロパティは単一値であることに留意されたいです。 [0..N]基数は、任意の所与のポリシー変数のオブジェクトを含む、0,1、またはそれ以上のSimplePolicyConditionオブジェクトが存在する可能性があることを示しています。"
    },
    {
      "indent": 3,
      "text": "The reference property \"PartComponent\" is inherited from PolicyComponent, and overridden to become an object reference to a PolicyVariable that is defined within the scope of a SimplePolicyCondition. Note that for any single instance of the association class PolicyVariableInSimplePolicyCondition, this property (like all reference properties) is single-valued. The [1..1] cardinality indicates that a SimplePolicyCondition must have exactly one policy variable defined within its scope in order to be meaningful.",
      "ja": "参照プロパティ「PartComponentは」PolicyComponentから継承、及びSimplePolicyConditionの範囲内で定義されるPolicyVariableへのオブジェクト参照になるように無視されています。関連クラスPolicyVariableInSimplePolicyConditionの任意の単一のインスタンスに対して、（すべての参照プロパティのような）このプロパティは単一値であることに留意されたいです。 [1..1]基数は、SimplePolicyConditionは有意義であるために、その範囲内に定義された正確に1つのポリシー変数を有していなければならないことを示しています。"
    },
    {
      "indent": 0,
      "text": "7.14. The Aggregation \"PolicyValueInSimplePolicyCondition\"",
      "section_title": true,
      "ja": "7.14。集計「PolicyValueInSimplePolicyCondition」"
    },
    {
      "indent": 3,
      "text": "A simple policy condition is represented as an ordered triplet {variable, operator, value}. This aggregation provides the linkage between a SimplePolicyCondition instance and a single PolicyValue. The aggregation PolicyVariableInSimplePolicyCondition links the SimplePolicyCondition to a single PolicyVariable. The Operator property of SimplePolicyCondition represents the third element of the triplet, the operator.",
      "ja": "単純なポリシー条件は、順序付けられたトリプレット{変数、演算子、値}として表されます。この凝集はSimplePolicyConditionインスタンスと単一PolicyValue間の連結を提供します。集約PolicyVariableInSimplePolicyConditionは、単一PolicyVariableにSimplePolicyConditionをリンクします。 SimplePolicyConditionのオペレータプロパティはトリプレット、オペレータの3番目の要素を表します。"
    },
    {
      "indent": 3,
      "text": "The class definition for this aggregation is as follows:",
      "ja": "次のように、この集約のためのクラス定義は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "NAME PolicyValueInSimplePolicyCondition DERIVED FROM PolicyComponent ABSTRACT False PROPERTIES GroupComponent[ref SimplePolicyCondition[0..n]] PartComponent[ref PolicyValue[1..1] ]",
      "ja": "PolicyComponent ABSTRACT偽施設から派生名称PolicyValueInSimplePolicyCondition GroupComponent PartComponent [SimplePolicyCondition [0..N]参考文献] [PolicyValue [1..1]参考文献]"
    },
    {
      "indent": 3,
      "text": "The reference property \"GroupComponent\" is inherited from PolicyComponent, and overridden to become an object reference to a SimplePolicyCondition that contains exactly one PolicyValue. Note that for any single instance of the aggregation class PolicyValueInSimplePolicyCondition, this property is single-valued. The [0..n] cardinality indicates that there may be 0, 1, or more SimplePolicyCondition objects that contain any given policy value object.",
      "ja": "参照プロパティ「GroupComponent」は正確に一つのPolicyValueが含まれていSimplePolicyConditionへのオブジェクト参照になるようにPolicyComponentから継承され、オーバーライドされています。集約クラスPolicyValueInSimplePolicyConditionの任意の単一のインスタンスに対して、このプロパティは単一値であることに留意されたいです。 [0..N]基数は、任意の所与のポリシー値オブジェクトを含む、0,1、またはそれ以上のSimplePolicyConditionオブジェクトが存在する可能性があることを示しています。"
    },
    {
      "indent": 3,
      "text": "The reference property \"PartComponent\" is inherited from PolicyComponent, and overridden to become an object reference to a PolicyValue that is defined within the scope of a SimplePolicyCondition. Note that for any single instance of the association class PolicyValueInSimplePolicyCondition, this property (like all reference properties) is single-valued. The [1..1] cardinality indicates that a SimplePolicyCondition must have exactly one policy value defined within its scope in order to be meaningful.",
      "ja": "参照プロパティ「PartComponentは」PolicyComponentから継承、及びSimplePolicyConditionの範囲内で定義されるPolicyValueへのオブジェクト参照になるように無視されています。関連クラスPolicyValueInSimplePolicyConditionの任意の単一のインスタンスに対して、（すべての参照プロパティのような）このプロパティは単一値であることに留意されたいです。 [1..1]基数は、SimplePolicyConditionは有意義であるために、その範囲内に定義された正確に1つのポリシー値を有していなければならないことを示しています。"
    },
    {
      "indent": 0,
      "text": "7.15. The Aggregation \"PolicyVariableInSimplePolicyAction\"",
      "section_title": true,
      "ja": "7.15。集計「PolicyVariableInSimplePolicyAction」"
    },
    {
      "indent": 3,
      "text": "A simple policy action is represented as a pair {variable, value}. This aggregation provides the linkage between a SimplePolicyAction instance and a single PolicyVariable. The aggregation PolicyValueInSimplePolicyAction links the SimplePolicyAction to a single PolicyValue.",
      "ja": "単純なポリシーアクションは、対{変数、値}として表されます。この凝集はSimplePolicyActionインスタンスと単一PolicyVariable間の連結を提供します。集約PolicyValueInSimplePolicyActionは、単一PolicyValueにSimplePolicyActionをリンクします。"
    },
    {
      "indent": 3,
      "text": "The class definition for this aggregation is as follows:",
      "ja": "次のように、この集約のためのクラス定義は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "NAME PolicyVariableInSimplePolicyAction DERIVED FROM PolicyComponent ABSTRACT False PROPERTIES GroupComponent[ref SimplePolicyAction[0..n]] PartComponent[ref PolicyVariable[1..1] ]",
      "ja": "PolicyComponent ABSTRACT偽施設から派生名称PolicyVariableInSimplePolicyAction GroupComponent PartComponent [SimplePolicyAction [0..N]参考文献] [PolicyVariable [1..1]参考文献]"
    },
    {
      "indent": 3,
      "text": "The reference property \"GroupComponent\" is inherited from PolicyComponent, and overridden to become an object reference to a SimplePolicyAction that contains exactly one PolicyVariable. Note that for any single instance of the aggregation class PolicyVariableInSimplePolicyAction, this property is single-valued. The [0..n] cardinality indicates that there may be 0, 1, or more SimplePolicyAction objects that contain any given policy variable object.",
      "ja": "参照プロパティ「GroupComponent」は正確に一つのPolicyVariableが含まれていSimplePolicyActionへのオブジェクト参照になるようにPolicyComponentから継承され、オーバーライドされています。集約クラスPolicyVariableInSimplePolicyActionの任意の単一のインスタンスに対して、このプロパティは単一値であることに留意されたいです。 [0..N]基数は、任意の所与のポリシー変数のオブジェクトを含む、0,1、またはそれ以上のSimplePolicyActionオブジェクトが存在する可能性があることを示しています。"
    },
    {
      "indent": 3,
      "text": "The reference property \"PartComponent\" is inherited from PolicyComponent, and overridden to become an object reference to a PolicyVariable that is defined within the scope of a SimplePolicyAction. Note that for any single instance of the association class PolicyVariableInSimplePolicyAction, this property (like all reference properties) is single-valued. The [1..1] cardinality indicates that a SimplePolicyAction must have exactly one policy variable defined within its scope in order to be meaningful.",
      "ja": "参照プロパティ「PartComponentは」PolicyComponentから継承、及びSimplePolicyActionの範囲内で定義されるPolicyVariableへのオブジェクト参照になるように無視されています。関連クラスPolicyVariableInSimplePolicyActionの任意の単一のインスタンスに対して、（すべての参照プロパティのような）このプロパティは単一値であることに留意されたいです。 [1..1]基数は、SimplePolicyActionは有意義であるために、その範囲内に定義された正確に1つのポリシー変数を有していなければならないことを示しています。"
    },
    {
      "indent": 0,
      "text": "7.16. The Aggregation \"PolicyValueInSimplePolicyAction\"",
      "section_title": true,
      "ja": "7.16。集計「PolicyValueInSimplePolicyAction」"
    },
    {
      "indent": 3,
      "text": "A simple policy action is represented as a pair {variable, value}. This aggregation provides the linkage between a SimplePolicyAction instance and a single PolicyValue. The aggregation PolicyVariableInSimplePolicyAction links the SimplePolicyAction to a single PolicyVariable.",
      "ja": "単純なポリシーアクションは、対{変数、値}として表されます。この凝集はSimplePolicyActionインスタンスと単一PolicyValue間の連結を提供します。集約PolicyVariableInSimplePolicyActionは、単一PolicyVariableにSimplePolicyActionをリンクします。"
    },
    {
      "indent": 3,
      "text": "The class definition for this aggregation is as follows:",
      "ja": "次のように、この集約のためのクラス定義は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "NAME PolicyValueInSimplePolicyAction DERIVED FROM PolicyComponent ABSTRACT False PROPERTIES GroupComponent[ref SimplePolicyAction[0..n]] PartComponent[ref PolicyValue[1..1] ]",
      "ja": "PolicyComponent ABSTRACT偽施設から派生名称PolicyValueInSimplePolicyAction GroupComponent PartComponent [SimplePolicyAction [0..N]参考文献] [PolicyValue [1..1]参考文献]"
    },
    {
      "indent": 3,
      "text": "The reference property \"GroupComponent\" is inherited from PolicyComponent, and overridden to become an object reference to a SimplePolicyAction that contains exactly one PolicyValue. Note that for any single instance of the aggregation class PolicyValueInSimplePolicyAction, this property is single-valued. The [0..n] cardinality indicates that there may be 0, 1, or more SimplePolicyAction objects that contain any given policy value object.",
      "ja": "参照プロパティ「GroupComponent」は正確に一つのPolicyValueが含まれていSimplePolicyActionへのオブジェクト参照になるようにPolicyComponentから継承され、オーバーライドされています。集約クラスPolicyValueInSimplePolicyActionの任意の単一のインスタンスに対して、このプロパティは単一値であることに留意されたいです。 [0..N]基数は、任意の所与のポリシー値オブジェクトを含む、0,1、またはそれ以上のSimplePolicyActionオブジェクトが存在する可能性があることを示しています。"
    },
    {
      "indent": 3,
      "text": "The reference property \"PartComponent\" is inherited from PolicyComponent, and overridden to become an object reference to a PolicyValue that is defined within the scope of a SimplePolicyAction. Note that for any single instance of the association class PolicyValueInSimplePolicyAction, this property (like all reference properties) is single-valued. The [1..1] cardinality indicates that a SimplePolicyAction must have exactly one policy value defined within its scope in order to be meaningful.",
      "ja": "参照プロパティ「PartComponentは」PolicyComponentから継承、及びSimplePolicyActionの範囲内で定義されるPolicyValueへのオブジェクト参照になるように無視されています。関連クラスPolicyValueInSimplePolicyActionの任意の単一のインスタンスに対して、（すべての参照プロパティのような）このプロパティは単一値であることに留意されたいです。 [1..1]基数は、SimplePolicyActionは有意義であるために、その範囲内に定義された正確に1つのポリシー値を有していなければならないことを示しています。"
    },
    {
      "indent": 0,
      "text": "7.17. The Association \"ReusablePolicy\"",
      "section_title": true,
      "ja": "7.17。協会「ReusablePolicy」"
    },
    {
      "indent": 3,
      "text": "The association ReusablePolicy makes it possible to include any subclass of the abstract class \"Policy\" in a ReusablePolicyContainer.",
      "ja": "関連ReusablePolicyはReusablePolicyContainerで抽象クラス「ポリシー」のいずれかのサブクラスを含めることが可能となります。"
    },
    {
      "indent": 3,
      "text": "NAME ReusablePolicy DESCRIPTION A class representing the inclusion of a reusable policy element in a ReusablePolicyContainer. Reusable elements may be PolicyGroups, PolicyRules, PolicyConditions, PolicyActions, PolicyVariables, PolicyValues, or instances of any other subclasses of the abstract class Policy.",
      "ja": "NAME ReusablePolicy DESCRIPTION ReusablePolicyContainerで再利用可能なポリシーの要素の包含を表すクラス。再利用可能な要素は、抽象クラスポリシーのいずれかの他のサブクラスのPolicyGroups、PolicyRules、PolicyConditions、PolicyActions、PolicyVariables、PolicyValues、またはインスタンスかもしれません。"
    },
    {
      "indent": 3,
      "text": "DERIVED FROM PolicyInSystem ABSTRACT FALSE PROPERTIES Antecedent[ref ReusablePolicyContainer[0..1]]",
      "ja": "PolicyInSystem ABSTRACT FALSEの施設から派生前例[審判ReusablePolicyContainer [0..1]]"
    },
    {
      "indent": 0,
      "text": "7.18. Deprecate PCIM's \"PolicyConditionInPolicyRepository\"",
      "section_title": true,
      "ja": "7.18。 PCIMの「PolicyConditionInPolicyRepository」を廃止"
    },
    {
      "indent": 3,
      "text": "NAME PolicyConditionInPolicyRepository DEPRECATED FOR ReusablePolicy DESCRIPTION A class representing the inclusion of a reusable PolicyCondition in a PolicyRepository. DERIVED FROM PolicyInSystem ABSTRACT FALSE PROPERTIES Antecedent[ref PolicyRepository[0..1]] Dependent[ref PolicyCondition[0..n]]",
      "ja": "ReusablePolicy説明の名前PolicyConditionInPolicyRepository DEPRECATED PolicyRepositoryに再利用可能なPolicyConditionの包含を表すクラス。 PolicyInSystem ABSTRACT FALSE施設から派生前例[REF PolicyRepository [0..1]従属[REF PolicyCondition [0..N]"
    },
    {
      "indent": 0,
      "text": "7.19. Deprecate PCIM's \"PolicyActionInPolicyRepository\"",
      "section_title": true,
      "ja": "7.19。 PCIMの「PolicyActionInPolicyRepository」を廃止"
    },
    {
      "indent": 3,
      "text": "NAME PolicyActionInPolicyRepository DEPRECATED FOR ReusablePolicy DESCRIPTION A class representing the inclusion of a reusable PolicyAction in a PolicyRepository. DERIVED FROM PolicyInSystem ABSTRACT FALSE PROPERTIES Antecedent[ref PolicyRepository[0..1]] Dependent[ref PolicyAction[0..n]]",
      "ja": "ReusablePolicy説明の名前PolicyActionInPolicyRepository DEPRECATED PolicyRepositoryに再利用可能なPolicyActionの包含を表すクラス。 PolicyInSystem ABSTRACT FALSE施設から派生前例[REF PolicyRepository [0..1]従属[REF PolicyAction [0..N]"
    },
    {
      "indent": 0,
      "text": "7.20. The Association ExpectedPolicyValuesForVariable",
      "section_title": true,
      "ja": "7.20。協会ExpectedPolicyValuesForVariable"
    },
    {
      "indent": 3,
      "text": "This association links a PolicyValue object to a PolicyVariable object, modeling the set of expected values for that PolicyVariable. Using this association, a variable (instance) may be constrained to be bound- to/assigned only a set of allowed values. For example, modeling an enumerated source port variable, one creates an instance of the PolicySourcePortVariable class and associates with it the set of values (integers) representing the allowed enumeration, using appropriate number of instances of the ExpectedPolicyValuesForVariable association.",
      "ja": "この関連は、そのPolicyVariableの期待値のセットをモデル化、PolicyVariableオブジェクトにPolicyValueオブジェクトをリンクします。この関連付けを使用して、変数（インスタンス）へ/許可された値のセットのみを割り当てbound-なるように制約することができます。例えば、列挙されたソースポート変数をモデル化し、一方はExpectedPolicyValuesForVariableアソシエーションのインスタンスの適切な数を使用して、それにPolicySourcePortVariableクラスと関連付け許可列挙を表す値（整数）のセットのインスタンスを作成します。"
    },
    {
      "indent": 3,
      "text": "Note that a single variable instance may be constrained by any number of values, and a single value may be used to constrain any number of variables. These relationships are manifested by the n-to-m cardinality of the association.",
      "ja": "単一変数インスタンスは任意の数の値によって制約されてもよいし、単一の値は、変数の任意の数を制限するために使用することができることに留意されたいです。これらの関係は、関連のN対Mのカーディナリティによって明らかにされています。"
    },
    {
      "indent": 3,
      "text": "The purpose of this association is to support validation of simple policy conditions and simple policy actions, prior to their deployment to an enforcement point. This association, and the",
      "ja": "この協会の目的は、単純なポリシー条件と前実施ポイントへの展開にシンプルな政策行動の検証をサポートすることです。この関連付け、および"
    },
    {
      "indent": 3,
      "text": "PolicyValue object that it refers to, plays no role when a PDP or a PEP is evaluating a simple policy condition, or executing a simple policy action. See Section 5.8.3 for more details on this point.",
      "ja": "それが参照するPolicyValueオブジェクトは、PDPやPEPは、単純なポリシー条件を評価し、または単純なポリシーアクションを実行しているときに何の役割も果たしません。この点についての詳細は、5.8.3項を参照してください。"
    },
    {
      "indent": 3,
      "text": "The class definition for the association is as follows:",
      "ja": "次のように協会のためのクラス定義は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "NAME ExpectedPolicyValuesForVariable DESCRIPTION A class representing the association of a set of expected values to a variable object. DERIVED FROM Dependency ABSTRACT FALSE PROPERTIES Antecedent [ref PolicyVariable[0..n]] Dependent [ref PolicyValue [0..n]]",
      "ja": "ExpectedPolicyValuesForVariable DESCRIPTIONに可変オブジェクトへの期待値の集合の関連を表すクラスの名前。依存抽象FALSE施設から派生前例[REF PolicyVariable [0..N]従属[REF PolicyValue [0..N]"
    },
    {
      "indent": 3,
      "text": "The reference property Antecedent is inherited from Dependency. Its type and cardinality are overridden to provide the semantics of a variable optionally having value constraints. The [0..n] cardinality indicates that any number of variables may be constrained by a given value.",
      "ja": "参照プロパティの前例は依存から継承されます。その種類とカーディナリティは、必要に応じて値の制約を有する可変のセマンティクスを提供するためにオーバーライドされます。 [0..N]基数は、任意の数の変数が所定の値によって制約されてもよいことを示しています。"
    },
    {
      "indent": 3,
      "text": "The reference property \"Dependent\" is inherited from Dependency, and overridden to become an object reference to a PolicyValue representing the values that a particular PolicyVariable can have. The [0..n] cardinality indicates that a given policy variable may have 0, 1 or more than one PolicyValues defined to model the set(s) of values that the policy variable can take.",
      "ja": "「依存性」参照プロパティは、特定PolicyVariableを有することができる値を表すPolicyValueへのオブジェクト参照になるように依存関係から継承、及びオーバーライドされています。 [0..N]基数は、与えられたポリシー変数は、ポリシー変数が取り得る値の集合（複数可）をモデル化するために定義された0,1、または複数のPolicyValuesを有することができることを示しています。"
    },
    {
      "indent": 0,
      "text": "7.21. The Aggregation \"ContainedDomain\"",
      "section_title": true,
      "ja": "7.21。集計「ContainedDomain」"
    },
    {
      "indent": 3,
      "text": "The aggregation ContainedDomain provides a means of nesting of one ReusablePolicyContainer inside another one. The aggregation is defined at the level of ReusablePolicyContainer's superclass, AdminDomain, to give it applicability to areas other than Core Policy.",
      "ja": "凝集ContainedDomainは、別の内部1 ReusablePolicyContainerのネスティングの手段を提供します。凝集は、基本方針以外の領域にそれを適用性を与えるために、ReusablePolicyContainerのスーパークラス、いるAdminDomainのレベルで定義されています。"
    },
    {
      "indent": 3,
      "text": "NAME ContainedDomain DESCRIPTION A class representing the aggregation of lower level administrative domains by a higher-level AdminDomain. DERIVED FROM SystemComponent ABSTRACT FALSE PROPERTIES GroupComponent[ref AdminDomain [0..n]] PartComponent[ref AdminDomain [0..n]]",
      "ja": "NAME Con​​tainedDomain DESCRIPTION上位いるAdminDomain低いレベルの管理ドメインの集合を表すクラス。 SystemComponent ABSTRACT FALSE施設から派生GroupComponent PartComponent [いるAdminDomain [0..N]参考文献] [いるAdminDomain [0..N]参考文献]"
    },
    {
      "indent": 0,
      "text": "7.22. Deprecate PCIM's \"PolicyRepositoryInPolicyRepository\"",
      "section_title": true,
      "ja": "7.22。 PCIMの「PolicyRepositoryInPolicyRepository」を廃止"
    },
    {
      "indent": 3,
      "text": "NAME PolicyRepositoryInPolicyRepository DEPRECATED FOR ContainedDomain DESCRIPTION A class representing the aggregation of PolicyRepositories by a higher-level PolicyRepository. DERIVED FROM SystemComponent ABSTRACT FALSE PROPERTIES GroupComponent[ref PolicyRepository[0..n]] PartComponent[ref PolicyRepository[0..n]]",
      "ja": "ContainedDomain説明の名前PolicyRepositoryInPolicyRepository DEPRECATED上位PolicyRepositoryによってPolicyRepositoriesの集合を表すクラス。 SystemComponent ABSTRACT FALSE施設から派生GroupComponent [REF PolicyRepository [0..N] PartComponent [REF PolicyRepository [0..N]"
    },
    {
      "indent": 0,
      "text": "7.23. The Aggregation \"EntriesInFilterList\"",
      "section_title": true,
      "ja": "7.23。集計「EntriesInFilterList」"
    },
    {
      "indent": 3,
      "text": "This aggregation is a specialization of the Component aggregation; it is used to define a set of filter entries (subclasses of FilterEntryBase) that are aggregated by a FilterList.",
      "ja": "この凝集は部品集合体の専門です。 FilterListによって集約されるフィルタエントリ（FilterEntryBaseのサブクラス）のセットを定義するために使用されます。"
    },
    {
      "indent": 3,
      "text": "The cardinalities of the aggregation itself are 0..1 on the FilterList end, and 0..n on the FilterEntryBase end. Thus in the general case, a filter entry can exist without being aggregated into any FilterList. However, the only way a filter entry can figure in the PCIMe model is by being aggregated into a FilterList by this aggregation.",
      "ja": "凝集自体のカーディナリティはFilterList端部に0..1であり、FilterEntryBase端に0..N。従って一般的な場合において、フィルタエントリは、任意のFilterListに集約されずに存在することができます。しかし、フィルタエントリがPCIMeモデルで把握することができる唯一の方法は、この凝集によりFilterListに集約されることです。"
    },
    {
      "indent": 3,
      "text": "The class definition for the aggregation is as follows:",
      "ja": "次のように集約のためのクラス定義は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "NAME EntriesInFilterList DESCRIPTION An aggregation used to define a set of filter entries (subclasses of FilterEntryBase) that are aggregated by a particular FilterList. DERIVED FROM Component ABSTRACT False PROPERTIES GroupComponent[ref FilterList[0..1]], PartComponent[ref FilterEntryBase[0..n], EntrySequence",
      "ja": "NAME EntriesInFilterList説明フィルタエントリのセット特定FilterListによって集計され（FilterEntryBaseのサブクラス）を定義するために使用される集約。コンポーネントABSTRACTから派生して偽PROPERTIES GroupComponent [参照FilterList [0..1]]、PartComponent [REF FilterEntryBase [0..N]、EntrySequence"
    },
    {
      "indent": 0,
      "text": "7.23.1. The Reference GroupComponent",
      "section_title": true,
      "ja": "7.23.1。参考GroupComponent"
    },
    {
      "indent": 3,
      "text": "This property is overridden in this aggregation to represent an object reference to a FilterList object (instead of to the more generic ManagedSystemElement object defined in its superclass). It also restricts the cardinality of the aggregate to 0..1 (instead of the more generic 0-or-more), representing the fact that a filter entry always exists within the context of at most one FilterList.",
      "ja": "このプロパティは、（代わりに、そのスーパークラスで定義されているより一般的なManagedSystemElementオブジェクトへの）FilterListオブジェクトへのオブジェクト参照を表すためにこの集合でオーバーライドされます。また、0..1に凝集体のカーディナリティを制限する（代わりに、より一般的な0-OR-以上）、フィルタエントリは常に最大1つFilterListのコンテキスト内に存在することを表します。"
    },
    {
      "indent": 0,
      "text": "7.23.2. The Reference PartComponent",
      "section_title": true,
      "ja": "7.23.2。参考PartComponent"
    },
    {
      "indent": 3,
      "text": "This property is overridden in this aggregation to represent an object reference to a FilterEntryBase object (instead of to the more generic ManagedSystemElement object defined in its superclass). This object represents a single filter entry, which may be aggregated with other filter entries to form the FilterList.",
      "ja": "このプロパティは、（代わりに、そのスーパークラスで定義されているより一般的なManagedSystemElementオブジェクトへの）FilterEntryBaseオブジェクトへのオブジェクト参照を表すためにこの集合でオーバーライドされます。このオブジェクトはFilterListを形成するために、他のフィルタエントリと集約することができる単一のフィルタエントリを表します。"
    },
    {
      "indent": 0,
      "text": "7.23.3. The Property EntrySequence",
      "section_title": true,
      "ja": "7.23.3。プロパティEntrySequence"
    },
    {
      "indent": 3,
      "text": "An unsigned 16-bit integer indicating the order of the filter entry relative to all others in the FilterList. The default value '0' indicates that order is not significant, because the entries in this FilterList are ANDed together.",
      "ja": "FilterListにおける他のすべてに対してフィルタエントリの順序を示す符号なし16ビット整数。デフォルト値は「0」このFilterListのエントリが一緒にAND演算されているので、順序は、重要ではないことを示しています。"
    },
    {
      "indent": 0,
      "text": "7.24. The Aggregation \"ElementInPolicyRoleCollection\"",
      "section_title": true,
      "ja": "7.24。集計「ElementInPolicyRoleCollection」"
    },
    {
      "indent": 3,
      "text": "The following aggregation is used to associate ManagedElements with a PolicyRoleCollection object that represents a role played by these ManagedElements.",
      "ja": "次凝集がこれらのManagedElementsが果たした役割を表しPolicyRoleCollectionオブジェクトとManagedElementsを関連付けるために使用されます。"
    },
    {
      "indent": 3,
      "text": "NAME ElementInPolicyRoleCollection DESCRIPTION A class representing the inclusion of a ManagedElement in a collection, specified as having a given role. All the managed elements in the collection share the same role. DERIVED FROM MemberOfCollection ABSTRACT FALSE PROPERTIES Collection[ref PolicyRoleCollection [0..n]] Member[ref ManagedElement [0..n]]",
      "ja": "NAME ElementInPolicyRoleCollection説明コレクション内の管理対象要素の包含を表すクラスは、与えられた役割を有するものとして指定します。コレクション内のすべての管理対象要素は、同じ役割を共有しています。 MemberOfCollection ABSTRACT FALSEの施設から派生コレクション[参照PolicyRoleCollection [0..N]]メンバー[管理対象要素[0..N]参照]"
    },
    {
      "indent": 0,
      "text": "7.25. The Weak Association \"PolicyRoleCollectionInSystem\"",
      "section_title": true,
      "ja": "7.25。弱い協会「PolicyRoleCollectionInSystem」"
    },
    {
      "indent": 3,
      "text": "A PolicyRoleCollection is defined within the scope of a System. This association links a PolicyRoleCollection to the System in whose scope it is defined.",
      "ja": "PolicyRoleCollectionは、システムの範囲内で定義されています。この関連は、スコープが定義されている中のシステムへのPolicyRoleCollectionをリンクします。"
    },
    {
      "indent": 3,
      "text": "When associating a PolicyRoleCollection with a System, this should be done consistently with the system that scopes the policy rules/groups that are applied to the resources in that collection. A PolicyRoleCollection is associated with the same system as the applicable PolicyRules and/or PolicyGroups, or to a System higher in the tree formed by the SystemComponent association.",
      "ja": "システムとPolicyRoleCollectionを関連付けるとき、これは、そのコレクション内のリソースに適用されるポリシールール/グループをスコープシステムを一貫して行うべきです。 PolicyRoleCollection、またはSystemComponent会合によって形成されたツリー内の上位システムに適用PolicyRules及び/又はPolicyGroupsと同じシステムに関連しています。"
    },
    {
      "indent": 3,
      "text": "The class definition for the association is as follows:",
      "ja": "次のように協会のためのクラス定義は以下のとおりです。"
    },
    {
      "indent": 3,
      "text": "NAME PolicyRoleCollectionInSystem DESCRIPTION A class representing the fact that a PolicyRoleCollection is defined within the scope of a System. DERIVED FROM Dependency ABSTRACT FALSE PROPERTIES Antecedent[ref System[1..1]] Dependent[ref PolicyRoleCollection[weak]]",
      "ja": "PolicyRoleCollectionInSystem説明をPolicyRoleCollectionがシステムの範囲内で定義されていることを表すクラスに名前を付けます。依存要約から、派生FALSE PROPERTIES前例[REFシステム[1..1]依存性[REF PolicyRoleCollection [弱]"
    },
    {
      "indent": 3,
      "text": "The reference property Antecedent is inherited from Dependency, and overridden to become an object reference to a System, and to restrict its cardinality to [1..1]. It serves as an object reference to a System that provides a scope for one or more PolicyRoleCollections. Since this is a weak association, the cardinality for this object reference is always 1, that is, a PolicyRoleCollection is always defined within the scope of exactly one System.",
      "ja": "参照プロパティの前例は、依存関係から継承され、オーバーライドされたシステムへのオブジェクト参照になるように、そして[1..1]にカーディナリティを制限します。これは、1つまたは複数のPolicyRoleCollectionsのスコープを提供するシステムへのオブジェクト参照として機能します。これは、弱い関連があるので、このオブジェクト参照の基数はPolicyRoleCollectionは、常に正確に一つのシステムの範囲内で定義されている、つまり、常に1です。"
    },
    {
      "indent": 3,
      "text": "The reference property Dependent is inherited from Dependency, and overridden to become an object reference to a PolicyRoleCollection defined within the scope of a System. Note that for any single instance of the association class PolicyRoleCollectionInSystem, this property (like all Reference properties) is single-valued. The [0..n] cardinality indicates that a given System may have 0, 1, or more than one PolicyRoleCollections defined within its scope.",
      "ja": "依存基準プロパティは、依存関係から継承、及びシステムの範囲内で定義されPolicyRoleCollectionへのオブジェクト参照になるように上書きされます。関連クラスPolicyRoleCollectionInSystemの任意の単一のインスタンスに対して、（すべての参照プロパティのような）このプロパティは単一値であることに留意されたいです。 [0..N]基数は、与えられたシステムは、その範囲内に定義された0,1、または複数のPolicyRoleCollectionsを有することができることを示しています。"
    },
    {
      "indent": 0,
      "text": "8. Intellectual Property",
      "section_title": true,
      "ja": "8.知的財産"
    },
    {
      "indent": 3,
      "text": "The IETF takes no position regarding the validity or scope of any intellectual property or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; neither does it represent that it has made any effort to identify any such rights. Information on the IETF's procedures with respect to rights in standards-track and standards-related documentation can be found in BCP-11.",
      "ja": "IETFは、そのような権限下で、ライセンスがたりないかもしれない可能性があるためにどの本書または程度に記載されている技術の実装や使用に関係すると主張される可能性があります任意の知的財産やその他の権利の有効性または範囲に関していかなる位置を取りません利用可能。また、そうした権利を特定するために取り組んできたことを表していないん。スタンダードトラックおよび標準関連文書における権利に関するIETFの手続きの情報は、BCP-11に記載されています。"
    },
    {
      "indent": 3,
      "text": "Copies of claims of rights made available for publication and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF Secretariat.",
      "ja": "権利の主張のコピーは、出版のために利用可能とライセンスの保証が利用できるようにする、あるいは本仕様の実装者または利用者がそのような所有権の使用のための一般的なライセンスまたは許可を取得するために作られた試みの結果を得ることができますIETF事務局から。"
    },
    {
      "indent": 3,
      "text": "The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights which may cover technology that may be required to practice this standard. Please address the information to the IETF Executive Director.",
      "ja": "IETFは、その注意にこの標準を実践するために必要な場合があり技術をカバーすることができる任意の著作権、特許または特許出願、またはその他の所有権を持ってすべての利害関係者を招待します。 IETF専務に情​​報を扱ってください。"
    },
    {
      "indent": 0,
      "text": "9. Acknowledgements",
      "section_title": true,
      "ja": "9.謝辞"
    },
    {
      "indent": 3,
      "text": "The starting point for this document was PCIM itself [1], and the first three submodels derived from it [11], [12], [13]. The authors of these documents created the extensions to PCIM, and asked the questions about PCIM, that are reflected in PCIMe.",
      "ja": "この文書のための出発点は、PCIM自体[1]、およびそれに由来する最初の三つのサブモデル[11]、[12]、[13]でした。これらの文書の著者は、PCIMへの拡張を作成し、そしてPCIMeに反映されているPCIMについての質問に、尋ねました。"
    },
    {
      "indent": 0,
      "text": "10. Contributors",
      "section_title": true,
      "ja": "10.協力者"
    },
    {
      "indent": 3,
      "text": "This document includes text written by a number of authors (including the editor), that was subsequently merged by the editor. The following people contributed text to this document:",
      "ja": "この文書は、その後、エディタでマージされました（編集者を含む）多くの著者によって書かれたテキストが含まれています。次の人は、この文書にテキストを寄付しました："
    },
    {
      "indent": 3,
      "text": "Lee Rafalow IBM Corporation, BRQA/501 4205 S. Miami Blvd. Research Triangle Park, NC 27709",
      "ja": "リーRafalow IBMコーポレーション、BRQA / 501 4205 S.マイアミブルバードリサーチトライアングルパーク、NC 27709"
    },
    {
      "indent": 3,
      "text": "Phone: +1 919-254-4455 Fax: +1 919-254-6243 EMail: rafalow@us.ibm.com",
      "ja": "電話：+1 919-254-4455ファックス：+1 919-254-6243電子メール：rafalow@us.ibm.com"
    },
    {
      "indent": 3,
      "text": "Yoram Ramberg Cisco Systems 4 Maskit Street Herzliya Pituach, Israel 46766",
      "ja": "Yoram Rambergシスコシステムズ4 MaskitストリートヘルズリヤPituach、イスラエル46766"
    },
    {
      "indent": 3,
      "text": "Phone: +972-9-970-0081 Fax: +972-9-970-0219 EMail: yramberg@cisco.com",
      "ja": "電話：+ 972-9-970-0081ファックス：+ 972-9-970-0219 Eメール：yramberg@cisco.com"
    },
    {
      "indent": 3,
      "text": "Yoram Snir Cisco Systems 4 Maskit Street Herzliya Pituach, Israel 46766",
      "ja": "Yoram SNIRシスコシステムズ4 MaskitストリートヘルズリヤPituach、イスラエル46766"
    },
    {
      "indent": 3,
      "text": "Phone: +972-9-970-0085 Fax: +972-9-970-0366 EMail: ysnir@cisco.com",
      "ja": "電話：+ 972-9-970-0085ファックス：+ 972-9-970-0366 Eメール：ysnir@cisco.com"
    },
    {
      "indent": 3,
      "text": "Andrea Westerinen Cisco Systems Building 20 725 Alder Drive Milpitas, CA 95035",
      "ja": "アンドレアWesterinenシスコシステムズビル20 725アルダードライブミルピタス、CA 95035"
    },
    {
      "indent": 3,
      "text": "Phone: +1-408-853-8294 Fax: +1-408-527-6351 EMail: andreaw@cisco.com",
      "ja": "電話：+ 1-408-853-8294ファックス：+ 1-408-527-6351 Eメール：andreaw@cisco.com"
    },
    {
      "indent": 3,
      "text": "Ritu Chadha Telcordia Technologies MCC 1J-218R 445 South Street Morristown NJ 07960.",
      "ja": "Ritu ChadhaのTelcordia Technologies社MCC 1J-218R 445サウスストリートモリスNJ 07960。"
    },
    {
      "indent": 3,
      "text": "Phone: +1-973-829-4869 Fax: +1-973-829-5889 EMail: chadha@research.telcordia.com",
      "ja": "電話：+ 1-973-829-4869ファックス：+ 1-973-829-5889 Eメール：chadha@research.telcordia.com"
    },
    {
      "indent": 3,
      "text": "Marcus Brunner NEC Europe Ltd. C&C Research Laboratories Adenauerplatz 6 D-69115 Heidelberg, Germany",
      "ja": "マーカスブルンナーNECヨーロッパ社C＆C研究所アデナウアープラッツ6 D-69115ハイデルベルク、ドイツ"
    },
    {
      "indent": 3,
      "text": "Phone: +49 (0)6221 9051129 Fax: +49 (0)6221 9051155 EMail: brunner@ccrle.nec.de",
      "ja": "電話：+49（0）6221 9051129ファックス：+49（0）6221 9051155 Eメール：brunner@ccrle.nec.de"
    },
    {
      "indent": 3,
      "text": "Ron Cohen Ntear LLC",
      "ja": "ロン・コーエンNtear LLC"
    },
    {
      "indent": 3,
      "text": "EMail: ronc@ntear.com",
      "ja": "メールアドレス：ronc@ntear.com"
    },
    {
      "indent": 3,
      "text": "John Strassner INTELLIDEN, Inc. 90 South Cascade Avenue Colorado Springs, CO 80903",
      "ja": "ジョンStrassner INTELLIDEN社90南カスケード・アベニューコロラドスプリングス、CO 80903"
    },
    {
      "indent": 3,
      "text": "Phone: +1-719-785-0648 EMail: john.strassner@intelliden.com",
      "ja": "電話：+ 1-719-785-0648 Eメール：john.strassner@intelliden.com"
    },
    {
      "indent": 0,
      "text": "11. Security Considerations",
      "section_title": true,
      "ja": "11.セキュリティについての考慮事項"
    },
    {
      "indent": 3,
      "text": "The Policy Core Information Model (PCIM) [1] describes the general security considerations related to the general core policy model. The extensions defined in this document do not introduce any additional considerations related to security.",
      "ja": "方針コア情報モデル（PCIM）[1]一般的なコアポリシーモデルに関連する一般的なセキュリティの考慮事項について説明します。この文書で定義された拡張は、セキュリティに関連する追加の考慮事項を導入しません。"
    },
    {
      "indent": 0,
      "text": "12. Normative References",
      "section_title": true,
      "ja": "12.引用規格"
    },
    {
      "indent": 3,
      "text": "[1] Moore, B., Ellesson, E., Strassner, J. and A. Westerinen, \"Policy Core Information Model -- Version 1 Specification\", RFC 3060, February 2001.",
      "ja": "[1]ムーア、B.、Ellesson、E.、Strassner、J.およびA. Westerinen、 \"方針コア情報モデル - バージョン1つの仕\"、RFC 3060、2001年2月。"
    },
    {
      "indent": 3,
      "text": "[2] Distributed Management Task Force, Inc., \"DMTF Technologies: CIM Standards CIM Schema: Version 2.5\", available at http://www.dmtf.org/standards/cim_schema_v25.php.",
      "ja": "[2]分散管理タスクフォース株式会社、 \"DMTF技術：CIM標準CIMスキーマ：バージョン2.5\"、http://www.dmtf.org/standards/cim_schema_v25.phpでご利用いただけます。"
    },
    {
      "indent": 3,
      "text": "[3] Distributed Management Task Force, Inc., \"Common Information Model (CIM) Specification: Version 2.2\", June 14, 1999, available at http://www.dmtf.org/standards/documents/CIM/DSP0004.pdf.",
      "ja": "[3]分散管理タスクフォース株式会社、 \"共通情報モデル（CIM）仕様：バージョン2.2\"、1999年6月14日、利用可能でhttp://www.dmtf.org/standards/documents/CIM/DSP0004.pdf 。"
    },
    {
      "indent": 3,
      "text": "[4] Mockapetris, P., \"Domain Names - implementation and specification\", STD 13, RFC 1035, November 1987.",
      "ja": "[4] Mockapetris、P.、 \"ドメイン名 - 実装及び仕様\"、STD 13、RFC 1035、1987年11月。"
    },
    {
      "indent": 3,
      "text": "[5] Wahl, M., Coulbeck, A., Howes, T. and S. Kille, \"Lightweight Directory Access Protocol (v3): Attribute Syntax Definitions\", RFC 2252, December 1997.",
      "ja": "[5]ワール、M.、Coulbeck、A.、ハウズ、T.およびS. Kille、 \"軽量のディレクトリアクセスプロトコル（V3）：属性の構文定義\"、RFC 2252、1997年12月。"
    },
    {
      "indent": 3,
      "text": "[6] Crocker, D. and P. Overell, \"Augmented BNF for Syntax Specifications: ABNF\", RFC 2234, November 1997.",
      "ja": "[6]クロッカー、D.、およびP. Overell、 \"構文仕様のための増大しているBNF：ABNF\"、RFC 2234、1997年11月。"
    },
    {
      "indent": 3,
      "text": "[7] Hinden, R. and S. Deering, \"IP Version 6 Addressing Architecture\", RFC 2373, July 1998.",
      "ja": "[7] HindenとR.とS.デアリング、 \"IPバージョン6アドレッシング体系\"、RFC 2373、1998年7月。"
    },
    {
      "indent": 3,
      "text": "[8] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[8]ブラドナーのは、S.は、BCP 14、RFC 2119、1997年3月の \"RFCsにおける使用のためのレベルを示すために\"。"
    },
    {
      "indent": 0,
      "text": "13. Informative References",
      "section_title": true,
      "ja": "13.参考文献"
    },
    {
      "indent": 3,
      "text": "[9] Hovey, R. and S. Bradner, \"The Organizations Involved in the IETF Standards Process\", BCP 11, RFC 2028, October 1996.",
      "ja": "[9] Hovey、R.およびS.ブラドナー、BCP 11、RFC 2028、1996年10月 \"IETF標準化プロセスに関与する組織\"。"
    },
    {
      "indent": 3,
      "text": "[10] Westerinen, A., Schnizlein, J., Strassner, J., Scherling, M., Quinn, B., Herzog, S., Huynh, A., Carlson, M., Perry, J. and Waldbusser, \"Terminology for Policy-Based Management\", RFC 3198, November 2001.",
      "ja": "[10] Westerinen、A.、Schnizlein、J.、Strassner、J.、Scherling、M.、クイン、B.、ヘルツォーク、S.、フイン、A.、カールソン、M.、ペリー、J.およびWaldbusser、 「ポリシーベースの管理のための用語」、RFC 3198、2001年11月。"
    },
    {
      "indent": 3,
      "text": "[11] Snir, Y., and Y. Ramberg, J. Strassner, R. Cohen, \"Policy QoS Information Model\", Work in Progress.",
      "ja": "[11] SNIR、Y.、およびY. Ramberg、J. Strassner、R.コーエン、 \"ポリシーのQoS情報モデル\" が進行中で働いています。"
    },
    {
      "indent": 3,
      "text": "[12] Jason, J., and L. Rafalow, E. Vyncke, \"IPsec Configuration Policy Model\", Work in Progress.",
      "ja": "[12]ジェイソン、J.、およびL. Rafalow、E. Vyncke、 \"IPsecの設定ポリシーモデル\" が進行中で働いています。"
    },
    {
      "indent": 3,
      "text": "[13] Chadha, R., and M. Brunner, M. Yoshida, J. Quittek, G. Mykoniatis, A. Poylisher, R. Vaidyanathan, A. Kind, F. Reichmeyer, \"Policy Framework MPLS Information Model for QoS and TE\", Work in Progress.",
      "ja": "QoSのための[13] Chadha、R.、およびM.ブルンナー、M.吉田、J. Quittek、G. Mykoniatis、A. Poylisher、R.がVaidyanathan、A.種類F. Reichmeyer、「ポリシーフレームワークMPLS情報モデルとTE」、進行中の作業。"
    },
    {
      "indent": 3,
      "text": "[14] S. Waldbusser, and J. Saperia, T. Hongal, \"Policy Based Management MIB\", Work in Progress.",
      "ja": "[14] S. Waldbusser、及びJ. Saperia、T. Hongal、 \"ポリシーベースの管理MIB\"、ProgressのWork。"
    },
    {
      "indent": 3,
      "text": "[15] B. Moore, and D. Durham, J. Halpern, J. Strassner, A. Westerinen, W. Weiss, \"Information Model for Describing Network Device QoS Datapath Mechanisms\", Work in Progress.",
      "ja": "[15] B.ムーア、及びD.ダラム、J.アルペルン、J. Strassner、A. Westerinen、W.ワイス、 \"ネットワークデバイスのQoSデータパスメカニズムを記述するための情報モデル\"、ProgressのWork。"
    },
    {
      "indent": 0,
      "text": "Author's Address",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Bob Moore IBM Corporation, BRQA/501 4205 S. Miami Blvd. Research Triangle Park, NC 27709",
      "ja": "ボブ・ムーアIBM社、BRQA / 501 4205 S.マイアミブルバードリサーチトライアングルパーク、NC 27709"
    },
    {
      "indent": 3,
      "text": "Phone: +1 919-254-4436 Fax: +1 919-254-6243 EMail: remoore@us.ibm.com",
      "ja": "電話：+1 919-254-4436ファックス：+1 919-254-6243電子メール：remoore@us.ibm.com"
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2003). All Rights Reserved.",
      "ja": "著作権（C）インターネット協会（2003）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.",
      "ja": "この文書とその翻訳は、コピーして他の人に提供し、それ以外についてはコメントまたは派生物は、いかなる種類の制限もなく、全体的にまたは部分的に、準備コピーし、公表して配布することができることを説明したり、その実装を支援することができます、上記の著作権表示とこの段落は、すべてのそのようなコピーや派生物に含まれていることを条件とします。しかし、この文書自体は著作権のための手順はで定義されている場合には、インターネット標準を開発するために必要なものを除き、インターネットソサエティもしくは他のインターネット関連団体に著作権情報や参照を取り除くなど、どのような方法で変更されないかもしれませんインターネット標準化プロセスが続く、または英語以外の言語に翻訳するために、必要に応じなければなりません。"
    },
    {
      "indent": 3,
      "text": "The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.",
      "ja": "上記の制限は永久で、インターネット学会やその後継者や譲渡者によって取り消されることはありません。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein is provided on an \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書とここに含まれている情報は、基礎とインターネットソサエティおよびインターネットエンジニアリングタスクフォースはすべての保証を否認し、明示または黙示、その情報の利用がない任意の保証を含むがこれらに限定されない「として、」上に設けられています特定の目的への権利または商品性または適合性の黙示の保証を侵害します。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "了承"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFC Editor機能のための基金は現在、インターネット協会によって提供されます。"
    }
  ]
}